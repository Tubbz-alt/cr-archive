<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/com/sun/javatest/InterviewParameters.java</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * $Id$
   3  *
   4  * Copyright (c) 2001, 2015, Oracle and/or its affiliates. All rights reserved.
   5  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   6  *
   7  * This code is free software; you can redistribute it and/or modify it
   8  * under the terms of the GNU General Public License version 2 only, as
   9  * published by the Free Software Foundation.  Oracle designates this
  10  * particular file as subject to the &quot;Classpath&quot; exception as provided
  11  * by Oracle in the LICENSE file that accompanied this code.
  12  *
  13  * This code is distributed in the hope that it will be useful, but WITHOUT
  14  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  15  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  16  * version 2 for more details (a copy is included in the LICENSE file that
  17  * accompanied this code).
  18  *
  19  * You should have received a copy of the GNU General Public License version
  20  * 2 along with this work; if not, write to the Free Software Foundation,
  21  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  22  *
  23  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  24  * or visit www.oracle.com if you need additional information or have any
  25  * questions.
  26  */
  27 package com.sun.javatest;
  28 
  29 import com.sun.interview.ErrorQuestion;
  30 import com.sun.interview.FinalQuestion;
  31 import com.sun.interview.Interview;
  32 import com.sun.interview.Question;
  33 import com.sun.javatest.tool.CustomPropagationController;
  34 import com.sun.javatest.tool.FileHistory;
  35 import com.sun.javatest.util.BackupPolicy;
  36 import com.sun.javatest.util.I18NResourceBundle;
  37 import com.sun.javatest.util.PropertyUtils;
  38 
  39 import java.io.BufferedInputStream;
  40 import java.io.BufferedOutputStream;
  41 import java.io.File;
  42 import java.io.FileInputStream;
  43 import java.io.FileNotFoundException;
  44 import java.io.FileOutputStream;
  45 import java.io.IOException;
  46 import java.io.InputStream;
  47 import java.io.OutputStream;
  48 import java.util.HashMap;
  49 import java.util.Map;
  50 import java.util.ResourceBundle;
  51 import java.util.SortedMap;
  52 import java.util.TreeMap;
  53 import java.util.Vector;
  54 
  55 /**
  56  * Configuration parameters provided via an interview.
  57  *
  58  * @since 3.0
  59  */
  60 public abstract class InterviewParameters
  61         extends Interview
  62         implements Parameters {
  63 
  64     static final String TESTSUITE = &quot;TESTSUITE&quot;;
  65     static final String WORKDIR = &quot;WORKDIR&quot;;
  66     static final String NAME = &quot;NAME&quot;;
  67     static final String DESC = &quot;DESCRIPTION&quot;;
  68     static final String MARKERS_ENABLED = &quot;MARKERS.enabled&quot;;
  69     static final String MARKERS_FILTER = &quot;MARKERS.filter&quot;;
  70     static final String IS_TEMPLATE = &quot;IS_TEMPLATE&quot;;
  71     static final String TEMPLATE_PATH = &quot;TEMPLATE_PATH&quot;;
  72     static final String TRUE = &quot;true&quot;;
  73     private static I18NResourceBundle i18n = I18NResourceBundle.getBundleForClass(InterviewParameters.class);
  74     //----------------------------------------------------------------------------
  75     private final String[] ignorableProps = {
  76             INTERVIEW,
  77             LOCALE, TESTSUITE, WORKDIR, MARKERS,
  78             IS_TEMPLATE, TEMPLATE_PATH, QUESTION};
  79     private final String[] ignorablePrefs = {MARKERS_PREF, EXTERNAL_PREF, TEMPLATE_PREF};
  80     protected File[] kflFiles;
  81 
  82     //----------------------------------------------------------------------------
  83     private TemplateManager templateManager = null;
  84     private boolean inGetName;
  85     private ExcludeListFilter cachedExcludeListFilter;
  86 
  87 
  88     //----------------------------------------------------------------------------
  89     private KeywordsFilter cachedKeywordsFilter;
  90 
  91     //----------------------------------------------------------------------------
  92     private StatusFilter cachedStatusFilter;
  93     private TestFilter cachedRelevantTestFilter;
  94     private TestSuite cachedRelevantTestFilterTestSuite; // do we need this?
  95     private TestEnvironment cachedRelevantTestFilterEnv;
  96     private TestFilter[] cachedTestFilters;
  97     private BackupPolicy backupPolicy;
  98     private boolean markersEnabled;
  99     private boolean markersFilterEnabled;
 100     private File currFile;
 101     private boolean isTemplate;
 102     private String templatePath;
 103     private long currFileLastModified;
 104     private boolean currFileLoaded;
 105     private CustomPropagationController pc = new CustomPropagationController();
 106 
 107     /**
 108      * Create an InterviewParameters object.
 109      *
 110      * @param tag The tag used to qualify questions in this interview
 111      */
 112     protected InterviewParameters(String tag) {
 113         super(tag);
 114     }
 115 
 116     private static boolean equal(boolean[] b1, boolean... b2) {
 117         if (b1 == null || b2 == null) {
 118             return b1 == b2;
 119         }
 120 
 121         if (b1.length != b2.length) {
 122             return false;
 123         }
 124 
 125         for (int i = 0; i &lt; b1.length; i++) {
 126             if (b1[i] != b2[i]) {
 127                 return false;
 128             }
 129         }
 130 
 131         return true;
 132     }
 133 
 134     private static boolean equal(Vector&lt;TestFilter&gt; v, TestFilter... f) {
 135         if (f == null || v.size() != f.length) {
 136             return false;
 137         }
 138         for (int i = 0; i &lt; v.size(); i++) {
 139             if (!v.get(i).equals(f[i])) {
 140                 return false;
 141             }
 142         }
 143         return true;
 144     }
 145 
 146     /**
 147      * Determine if the specified file is an interview file,
 148      * as determined by whether its extension is .jti or not.
 149      *
 150      * @param f the file to be checked
 151      * @return true if the specified file is an interview file,
 152      * and false otherwise
 153      */
 154     public static boolean isInterviewFile(File f) {
 155         return f.getName().endsWith(&quot;.jti&quot;);
 156     }
 157 
 158     /**
 159      * Create an InterviewParameters as determined by the contents of an
 160      * interview file.
 161      *
 162      * @param file the file to be read
 163      * @return an InterviewParameters as determined by the contents of an
 164      * interview file.
 165      * @throws IOException     is there is a problem reading the file
 166      * @throws Interview.Fault if there is a problem instantiating the
 167      *                         interview
 168      */
 169     public static InterviewParameters open(File file)
 170             throws IOException, Fault {
 171         return open(file, (TestSuite) null, (WorkDirectory) null);
 172     }
 173 
 174     /**
 175      * Create an InterviewParameters by populating the interview for a specified
 176      * test suite with responses from a given file.
 177      *
 178      * @param file      the file to be read
 179      * @param testSuite the test suite for which to create the interview
 180      * @return an InterviewParameters as determined by the test suite
 181      * and the contents of an interview file
 182      * @throws IOException     is there is a problem reading the file
 183      * @throws Interview.Fault if there is a problem instantiating the
 184      *                         interview
 185      */
 186     public static InterviewParameters open(File file, TestSuite testSuite)
 187             throws IOException, Fault {
 188         if (testSuite == null) {
 189             throw new NullPointerException();
 190         }
 191 
 192         return open(file, testSuite, null);
 193     }
 194 
 195     /**
 196      * Create an InterviewParameters by populating the interview for a specified
 197      * work directory with responses from a given file.
 198      *
 199      * @param file    the file to be read
 200      * @param workDir the work directory (implying the test suite) for which
 201      *                to create the interview
 202      * @return an InterviewParameters as determined by the work directory
 203      * and the contents of an interview file
 204      * @throws IOException     is there is a problem reading the file
 205      * @throws Interview.Fault if there is a problem instantiating the
 206      *                         interview
 207      */
 208     public static InterviewParameters open(File file, WorkDirectory workDir)
 209             throws IOException, Fault {
 210         if (workDir == null) {
 211             throw new NullPointerException();
 212         }
 213 
 214         return open(file, workDir.getTestSuite(), workDir);
 215     }
 216 
 217     /**
 218      * @throws WorkDirFault   If there is a problem finding the work directory.
 219      * @throws TestSuiteFault If there is a problem finding the test suite.
 220      * @throws JTIFault       If there is a problem finding the JTI file.  Not thrown
 221      *                        if the file is corrupt or incompatible though.
 222      * @throws Fault          If there is any other problem opening the interview params, such as
 223      *                        problems with data in the JTI, incompatibilities between the workdir,
 224      *                        test suite or work dir.
 225      */
 226     private static InterviewParameters open(File file, TestSuite testSuite, WorkDirectory workDir)
 227             throws IOException, Fault {
 228         // note: the additional Fault types were introduced in JT 3.2.1
 229 
 230         // read the .jti data
 231         Map&lt;String, String&gt; data;
 232 
 233         try (InputStream in = new BufferedInputStream(new FileInputStream(file))) {
 234             data = PropertyUtils.load(in);
 235         } catch (RuntimeException e) {
 236             // can get IllegalArgumentException if the file is corrupt
 237             throw new JTIFault(i18n, &quot;ip.errorReadingFile&quot;, file, e);
 238         }
 239 
 240         // if the test suite has not been given, set it from the .jti data
 241         if (testSuite == null) {
 242             String s = data.get(TESTSUITE);
 243             if (s == null) {
 244                 throw new Fault(i18n, &quot;ip.noTestSuiteInFile&quot;, file);
 245             }
 246 
 247             try {
 248                 testSuite = TestSuite.open(new File(s));
 249             } catch (FileNotFoundException e) {
 250                 throw new TestSuiteFault(i18n, &quot;ip.cantFindTestSuiteInFile&quot;,
 251                         s, file);
 252             } catch (TestSuite.Fault e) {
 253                 throw new Fault(i18n, &quot;ip.cantOpenTestSuiteInFile&quot;,
 254                         s, file, e.getMessage());
 255             }
 256         }
 257 
 258         // if the work directory has not been given,
 259         // set it from the .jti data if given
 260         if (workDir == null) {
 261             String s = data.get(WORKDIR);
 262             if (s != null) {
 263                 try {
 264                     workDir = WorkDirectory.open(new File(s), testSuite);
 265                 } catch (FileNotFoundException e) {
 266                     throw new WorkDirFault(i18n, &quot;ip.cantFindWorkDirInFile&quot;,
 267                             s, file);
 268                 } catch (WorkDirectory.Fault e) {
 269                     throw new Fault(i18n, &quot;ip.cantOpenWorkDirInFile&quot;,
 270                             s, file, e.getMessage());
 271                 }
 272             }
 273         }
 274 
 275         InterviewParameters parameters;
 276 
 277         // create the parameters object
 278         try {
 279             parameters = testSuite.createInterview();
 280         } catch (TestSuite.Fault e) {
 281             throw new Fault(i18n, &quot;ip.cantCreateInterviewForTestSuite&quot;,
 282                     testSuite.getPath(), e.getMessage());
 283         }
 284 
 285         // set the work dir in the parameters object
 286         if (workDir != null) {
 287             parameters.setWorkDirectory(workDir);
 288         }
 289 
 290         // load the .jti data into the parameters object
 291         try {
 292             parameters.load(data, file);
 293         } catch (InterviewParameters.Fault e) {
 294             throw new Fault(i18n, &quot;ip.cantLoadInterview&quot;,
 295                     file, e.getMessage());
 296         }
 297 
 298         return parameters;
 299     }
 300 
 301     /**
 302      * Open a a configuration file, based on paths for the configuration file,
 303      * test suite and work directory. Any, but not all, of these paths may be null.
 304      * Any non-null path must specify an appropriate existing file, otherwise
 305      * an exception will be thrown.
 306      *
 307      * @param testSuitePath  the path for the test suite; if not specified,
 308      *                       the test suite will default from the work directory (if specified) or
 309      *                       the configuration file.
 310      * @param workDirPath    the path for the work directory; if not specified,
 311      *                       the work directory will the default from the config file (if specified),
 312      *                       or will be null if no configuration file is given
 313      * @param configFilePath the path for the configuration file; if not specified,
 314      *                       the result will be a blank interview as created by the test suite.
 315      * @return an InterviewParameters object created from the given arguments
 316      * @throws Interview.Fault if there is any problem creating the
 317      *                         result
 318      */
 319     public static InterviewParameters open(String testSuitePath, String workDirPath, String configFilePath)
 320             throws InterviewParameters.Fault {
 321         File ts = testSuitePath != null &amp;&amp; !testSuitePath.isEmpty()
 322                 ? new File(testSuitePath) : null;
 323         File wd = workDirPath != null &amp;&amp; !workDirPath.isEmpty()
 324                 ? new File(workDirPath) : null;
 325         File cf = configFilePath != null &amp;&amp; !configFilePath.isEmpty()
 326                 ? new File(configFilePath) : null;
 327         return open(ts, wd, cf);
 328     }
 329 
 330     /**
 331      * Open a a configuration file, based on paths for the configuration file,
 332      * test suite and work directory. Any, but not all, of these paths may be null.
 333      * Any non-null path must specify an appropriate existing file, otherwise
 334      * an exception will be thrown.
 335      *
 336      * @param testSuitePath  the path for the test suite; if not specified,
 337      *                       the test suite will default from the work directory (if specified) or
 338      *                       the configuration file.
 339      * @param workDirPath    the path for the work directory; if not specified,
 340      *                       the work directory will bdefault from the config file (if specified),
 341      *                       or will be null if no configuration file is given
 342      * @param configFilePath the path for the configuration file; if not specified,
 343      *                       the result will be a blank interview as created by the test suite.
 344      * @return an InterviewParameters object created from the gievn arguments
 345      * @throws Interview.Fault if there is any problem creating the
 346      *                         result
 347      */
 348     public static InterviewParameters open(File testSuitePath, File workDirPath, File configFilePath)
 349             throws InterviewParameters.Fault {
 350 
 351         // open test suite if specified
 352 
 353         TestSuite testSuite;
 354 
 355         if (testSuitePath != null) {
 356             try {
 357                 testSuite = TestSuite.open(testSuitePath);
 358             } catch (FileNotFoundException e) {
 359                 throw new Fault(i18n, &quot;ip.cantFindTestSuite&quot;, testSuitePath, e);
 360             } catch (TestSuite.Fault e) {
 361                 throw new Fault(i18n, &quot;ip.cantOpenTestSuite&quot;, testSuitePath, e.getMessage());
 362             }
 363         } else {
 364             testSuite = null;
 365         }
 366 
 367         // open work directory if specified, defaulting test suite if appropriate
 368 
 369         WorkDirectory workDir;
 370 
 371         if (workDirPath != null) {
 372             try {
 373                 if (testSuite == null) {
 374                     workDir = WorkDirectory.open(workDirPath);
 375                     testSuite = workDir.getTestSuite();
 376                 } else {
 377                     workDir = WorkDirectory.open(workDirPath, testSuite);
 378                 }
 379             } catch (FileNotFoundException e) {
 380                 throw new Fault(i18n, &quot;ip.cantFindWorkDir&quot;, workDirPath, e);
 381             } catch (WorkDirectory.Fault e) {
 382                 throw new Fault(i18n, &quot;ip.cantOpenWorkDir&quot;, workDirPath, e.getMessage());
 383             }
 384         } else {
 385             workDir = null;
 386         }
 387 
 388         // open config file if specified, defaulting work dir and test suite if appropriate
 389         // default config from test suite if appropriate
 390 
 391         InterviewParameters config;
 392 
 393         if (configFilePath == null) {
 394             if (testSuite != null) {
 395                 try {
 396                     config = testSuite.createInterview();
 397                 } catch (TestSuite.Fault e) {
 398                     throw new Fault(i18n, &quot;ip.cantCreateInterviewForTestSuite&quot;, testSuitePath, e);
 399                 }
 400 
 401                 if (workDir != null) {
 402                     config.setWorkDirectory(workDir);
 403                     FileHistory h = FileHistory.getFileHistory(workDir, &quot;configHistory.jtl&quot;);
 404                     File latestConfigFile = h.getLatestEntry();
 405 
 406                     if (latestConfigFile != null) {
 407                         try {
 408                             config.load(latestConfigFile);
 409                         } catch (IOException e) {
 410                             // ignore?
 411                         }   // catch
 412                     }
 413                 }   // workdir != null
 414             } else {
 415                 throw new Fault(i18n, &quot;ip.noPaths&quot;);
 416             }
 417         } else {
 418             try {
 419                 if (workDir == null) {
 420                     if (testSuite == null) {
 421                         config = open(configFilePath);
 422                         testSuite = config.getTestSuite();
 423                     } else {
 424                         config = open(configFilePath, testSuite);
 425                     }
 426                     workDir = config.getWorkDirectory();
 427                 } else {
 428                     config = open(configFilePath, workDir);
 429                 }
 430             } catch (FileNotFoundException e) {
 431                 throw new Fault(i18n, &quot;ip.cantFindConfigFile&quot;, configFilePath);
 432             } catch (IOException e) {
 433                 throw new Fault(i18n, &quot;ip.cantOpenConfigFile&quot;, configFilePath, e);
 434             }
 435         }
 436 
 437         // if still here, and had sufficient args, config should be open
 438         // and fully initialized
 439         return config;
 440     }
 441 
 442     public CustomPropagationController getPropagationController() {
 443         return pc;
 444     }
 445 
 446     public void setPropagationController(CustomPropagationController pc) {
 447         this.pc = pc;
 448     }
 449 
 450     /**
 451      * Set the work directory to be used for this test run.
 452      *
 453      * @param workDir the work directory to be used for this test run.
 454      *                It must match the test suite to be used for this test run
 455      */
 456     @Override
 457     public abstract void setWorkDirectory(WorkDirectory workDir);
 458 
 459     //----------------------------------------------------------------------------
 460 
 461     /**
 462      * Return the template manager for this InterviewParameters.
 463      */
 464     public TemplateManager getTemplateManger() {
 465         return templateManager;
 466     }
 467 
 468     /**
 469      * Set given template manager for this InterviewParameters.
 470      *
 471      * @param tm new template manager
 472      */
 473     public void setTemplateManger(TemplateManager tm) {
 474         this.templateManager = tm;
 475     }
 476 
 477     /**
 478      * Initialize an InterviewParameters object.
 479      * This method is called when the object is created
 480      * from an entry in a .jtt file.
 481      * By default, the method throws an exception if any arguments
 482      * are given. It should be redefined by any test suites that wish
 483      * to support this type of initialization.
 484      *
 485      * @param args test suite specific args with which to initialize
 486      *             this InterviewParameters object
 487      * @throws Interview.Fault if any problems occurred while processing the arguments
 488      */
 489     public void init(String... args) throws Fault {
 490         if (args != null &amp;&amp; args.length &gt; 0) {
 491             throw new Fault(i18n, &quot;ip.unknownArgs&quot;);
 492         }
 493     }
 494 
 495 
 496     //----------------------------------------------------------------------------
 497 
 498     /**
 499      * Clean up an InterviewParameters object.
 500      * This method should be invoked at the moment InterviewParameters object
 501      * becomes useless by the code, that controls it&#39;s lifecycle. For example,
 502      * at the end of the method which created it&#39;s local instance.
 503      * &lt;p&gt;
 504      * Any following invocations on this object may result in unpredictable
 505      * exceptions because of object inconsistence.
 506      */
 507     public void dispose() {
 508         kflFiles = null;
 509         backupPolicy = null;
 510         cachedExcludeListFilter = null;
 511         cachedKeywordsFilter = null;
 512         cachedRelevantTestFilter = null;
 513         cachedRelevantTestFilterEnv = null;
 514         cachedStatusFilter = null;
 515         cachedTestFilters = null;
 516         pc = null;
 517         templateManager = null;
 518     }
 519 
 520     /**
 521      * Get the name for this configuration.
 522      * By default and for backwards compatibility, this defaults to the
 523      * name of the test environment, which means that the whole environment
 524      * may need to be evaluated to get the required value. Subtypes may
 525      * choose to override this method to provide a more efficient
 526      * implementation.
 527      *
 528      * &lt;p&gt; Since the default implementation gets the name from the test
 529      * environment, clients should not use this method to determine
 530      * the name for the test environment, unless this method is redefined.
 531      * The default implementation detects such a circular usage, and
 532      * returns null in this case.
 533      *
 534      * @return the name for this configuration, or null if not known.
 535      */
 536     public synchronized String getName() {
 537         if (inGetName) {
 538             return null;
 539         }
 540 
 541         try {
 542             inGetName = true;
 543 
 544             EnvParameters eParams = getEnvParameters();
 545             if (eParams != null) {
 546                 // getName to get the name for the environment
 547                 TestEnvironment e = eParams.getEnv();
 548                 if (e != null) {
 549                     return e.getName();
 550                 }
 551             }
 552             return null;
 553         } finally {
 554             inGetName = false;
 555         }
 556     }
 557 
 558     /**
 559      * Get a description for this configuration.
 560      * By default and for backwards compatibility, this defaults to the
 561      * description entry in the test environment, which means that the
 562      * whole environment may need to be evaluated to get the required value.
 563      * Subtypes may choose to override this method to provide a more efficient
 564      * implementation.
 565      *
 566      * @return a description for this configuration, or null if not known
 567      */
 568     public String getDescription() {
 569         EnvParameters eParams = getEnvParameters();
 570         if (eParams != null) {
 571             TestEnvironment e = eParams.getEnv();
 572             if (e != null) {
 573                 return e.getDescription();
 574             }
 575         }
 576         return null;
 577     }
 578 
 579     /**
 580      * Get the next question to the asked after the initial prolog
 581      * of questions.
 582      * The default value is the result of getEnvFirstQuestion.
 583      *
 584      * @return the next question to be asked after the initial prolog
 585      * of questions.
 586      * @see #setFirstQuestion
 587      */
 588     protected Question getPrologSuccessorQuestion() {
 589         return getEnvFirstQuestion();
 590     }
 591 
 592     @Override
 593     public TestEnvironment getEnv() {
 594         EnvParameters eParams = getEnvParameters();
 595         if (eParams == null) {
 596             throw new NullPointerException();
 597         } else {
 598             return eParams.getEnv();
 599         }
 600     }
 601 
 602     /**
 603      * Get the first question to be asked concerning the environment to be
 604      * set up and used for each test to be run. If these questions are
 605      * contained in an interview, this method can be simply implemented as:&lt;br&gt;
 606      * {@code return callInterview(}&lt;i&gt;envInterview&lt;/i&gt;{@code , getEnvSuccessorQuestion);}&lt;br&gt;
 607      *
 608      * @return the first question to be asked concerning the environment to be
 609      * set up and used for each test to be run.
 610      * @see #getEnvSuccessorQuestion
 611      */
 612     protected abstract Question getEnvFirstQuestion();
 613 
 614     /**
 615      * Get the next question to be asked after those concerning
 616      * the environment to be set up and used for each test to be run.
 617      * The default value is the result of getTestsFirstQuestion.
 618      *
 619      * @return the next question to be asked after those concerning
 620      * the environment to be set up and used for each test to be run.
 621      * @see #getEnvFirstQuestion
 622      */
 623     protected Question getEnvSuccessorQuestion() {
 624         return getTestsFirstQuestion();
 625     }
 626 
 627     @Override
 628     public String[] getTests() {
 629         TestsParameters iParams = getTestsParameters();
 630         return iParams == null ? null : iParams.getTests();
 631     }
 632 
 633     /**
 634      * Get the first question to be asked concerning the set of tests
 635      * and folders of tests to be run.
 636      *
 637      * @return the first question to be asked concerning the set of tests
 638      * and folders of tests to be run.
 639      * @see #getTestsSuccessorQuestion
 640      */
 641     protected abstract Question getTestsFirstQuestion();
 642 
 643     /**
 644      * Get the next question to be asked after those concerning
 645      * the tests and folders of tests to be run.
 646      * The default value is the result of getExcludeListFirstQuestion.
 647      *
 648      * @return the next question to be asked after those concerning
 649      * the tests and folders of tests to be run.
 650      * @see #getTestsFirstQuestion
 651      */
 652     protected Question getTestsSuccessorQuestion() {
 653         return getExcludeListFirstQuestion();
 654     }
 655 
 656     @Override
 657     public ExcludeList getExcludeList() {
 658         ExcludeListParameters eParams = getExcludeListParameters();
 659         return eParams == null ? new ExcludeList() : eParams.getExcludeList();
 660     }
 661 
 662     /**
 663      * Get the combined known failures list.
 664      * Interviews expecting to use known failures lists should generally override
 665      * this method and add support for users to change it.
 666      *
 667      * @return Current known failures list - combined from the one or more
 668      * file specified by the user.
 669      * @see #setKnownFailureFiles(java.io.File[])
 670      * @see com.sun.javatest.interview.BasicInterviewParameters
 671      * @since 4.4
 672      */
 673     public KnownFailuresList getKnownFailuresList() {
 674         try {
 675             if (kflFiles != null) {
 676                 return new KnownFailuresList(getKnownFailureFiles());
 677             } else {
 678                 return null;
 679             }
 680 
 681         } catch (IOException | KnownFailuresList.Fault e) {
 682             return null;
 683         }
 684     }
 685 
 686     /**
 687      * Get the current set of known failures list files.
 688      * The default implementation will return the value in the kflFiles
 689      * field, which subclasses may set.
 690      *
 691      * @return The list of known failure list files.  Null if none.
 692      * @see #setKnownFailureFiles(java.io.File[])
 693      * @since 4.4
 694      */
 695     public File[] getKnownFailureFiles() {
 696         return kflFiles;
 697     }
 698 
 699     /**
 700      * Set the set of KFL files.
 701      *
 702      * @param files The known failures list files.  The array should contain
 703      *              one or more elements.
 704      * @since 4.4
 705      */
 706     public void setKnownFailureFiles(File... files) {
 707         kflFiles = files;
 708     }
 709 
 710     /**
 711      * Get the first question to be asked concerning the exclude list
 712      * to be used to exclude tests from the test run.
 713      *
 714      * @return the first question to be asked concerning the exclude list
 715      * to be used to exclude tests from the test run.
 716      * @see #getExcludeListSuccessorQuestion
 717      */
 718     protected abstract Question getExcludeListFirstQuestion();
 719 
 720     //----------------------------------------------------------------------------
 721 
 722     /**
 723      * Get the first question to be asked concerning the exclude list
 724      * to be used to exclude tests from the test run.
 725      *
 726      * @return the first question to be asked concerning the exclude list
 727      * to be used to exclude tests from the test run
 728      * @see #getExcludeListFirstQuestion
 729      * @deprecated Use getExcludeListFirstQuestion().
 730      */
 731     @java.lang.Deprecated
 732     protected Question getExcludeTableFirstQuestion() {
 733         return getExcludeListFirstQuestion();
 734     }
 735 
 736     /**
 737      * Get the next question to be asked after those concerning
 738      * the exclude list to be used to exclude tests from the test run.
 739      * The default value is the result of getKeywordsFirstQuestion,
 740      *
 741      * @return the next question to be asked after those concerning
 742      * the exclude list to be used to exclude tests from the test run.
 743      * @see #getExcludeListFirstQuestion
 744      */
 745     protected Question getExcludeListSuccessorQuestion() {
 746         return getKeywordsFirstQuestion();
 747     }
 748 
 749     /**
 750      * Get the next question to be asked after those concerning
 751      * the exclude list to be used to exclude tests from the test run.
 752      *
 753      * @return the next question to be asked after those concerning
 754      * the exclude list to be used to exclude tests from the test run
 755      * @see #getExcludeListSuccessorQuestion
 756      * @deprecated Use getExcludeListFirstQuestion().
 757      */
 758     @java.lang.Deprecated
 759     protected Question getExcludeTableSuccessorQuestion() {
 760         return getExcludeListSuccessorQuestion();
 761     }
 762 
 763     @Override
 764     public Keywords getKeywords() {
 765         KeywordsParameters kParams = getKeywordsParameters();
 766         return kParams == null ? null : kParams.getKeywords();
 767     }
 768 
 769     /**
 770      * Get the first question to be asked concerning the keywords
 771      * that may be used to select tests for the test run.
 772      *
 773      * @return the first question to be asked concerning the keywords
 774      * that may be used to select tests for the test run.
 775      * @see #getKeywordsSuccessorQuestion
 776      */
 777     protected abstract Question getKeywordsFirstQuestion();
 778 
 779     /**
 780      * Get the next question to be asked after those concerning
 781      * the keywords that may be used to select tests for the test run.
 782      * The default value is the result of getPriorStatusQuestion.
 783      *
 784      * @return the next question to be asked after those concerning
 785      * the keywords that may be used to select tests for the test run.
 786      * @see #getKeywordsFirstQuestion
 787      */
 788     protected Question getKeywordsSuccessorQuestion() {
 789         return getPriorStatusFirstQuestion();
 790     }
 791 
 792     @Override
 793     public boolean[] getPriorStatusValues() {
 794         PriorStatusParameters sParams = getPriorStatusParameters();
 795         return sParams == null ? null : sParams.getPriorStatusValues();
 796     }
 797 
 798     /**
 799      * Get the first question to be asked concerning whether tests should
 800      * be selected for execution according to their prior execution status.
 801      *
 802      * @return the first question to be asked concerning whether tests should
 803      * be selected for execution according to their prior execution status.
 804      * @see #getPriorStatusSuccessorQuestion
 805      */
 806     protected abstract Question getPriorStatusFirstQuestion();
 807 
 808     /**
 809      * Get the next question to be asked after those concerning
 810      * whether tests should be selected for execution according to their
 811      * prior execution status.
 812      * The default value is the result of getConcurrencyFirstQuestion
 813      *
 814      * @return the next question to be asked after those concerning
 815      * whether tests should be selected for execution according to their
 816      * prior execution status.
 817      * @see #getPriorStatusFirstQuestion
 818      */
 819     protected Question getPriorStatusSuccessorQuestion() {
 820         return getConcurrencyFirstQuestion();
 821     }
 822 
 823     @Override
 824     public int getConcurrency() {
 825         ConcurrencyParameters cParams = getConcurrencyParameters();
 826         return cParams == null ? 1 : cParams.getConcurrency();
 827     }
 828 
 829     /**
 830      * Get the first question concerning the number of tests that
 831      * may be run in parallel.
 832      *
 833      * @return the first question concerning the number of tests that
 834      * may be run in parallel.
 835      * @see #getConcurrencySuccessorQuestion
 836      */
 837     protected abstract Question getConcurrencyFirstQuestion();
 838 
 839     /**
 840      * Get the next question after those concerning the number
 841      * of tests that may be run in parallel.
 842      * The default is the result of getTimeoutFactorFirstQuestion
 843      *
 844      * @return the next question after those concerning the number
 845      * of tests that may be run in parallel.
 846      * @see #getConcurrencyFirstQuestion
 847      */
 848     protected Question getConcurrencySuccessorQuestion() {
 849         return getTimeoutFactorFirstQuestion();
 850     }
 851 
 852     @Override
 853     public float getTimeoutFactor() {
 854         TimeoutFactorParameters tParams = getTimeoutFactorParameters();
 855         return tParams == null ? 1 : tParams.getTimeoutFactor();
 856     }
 857 
 858     /**
 859      * Get the first question concerning the scale factor to
 860      * be applied to the standard timeout for each test.
 861      *
 862      * @return the first question concerning the scale factor to
 863      * be applied to the standard timeout for each test.
 864      * @see #getTimeoutFactorSuccessorQuestion
 865      */
 866     protected abstract Question getTimeoutFactorFirstQuestion();
 867 
 868     /**
 869      * Get the next question after those concerning the scale factor to
 870      * be applied to the standard timeout for each test.
 871      * The default is the result of getEpilogFirstQuestion
 872      *
 873      * @return the next question after those concerning the scale factor to
 874      * be applied to the standard timeout for each test.
 875      * @see #getTimeoutFactorFirstQuestion
 876      */
 877     protected Question getTimeoutFactorSuccessorQuestion() {
 878         return getEpilogFirstQuestion();
 879     }
 880 
 881     /**
 882      * Get the first question of the epilog, which should be asked after
 883      * all the other questions in the configuration interview have been asked.
 884      * The epilog should terminate in the standard way with a FinalQuestion.
 885      *
 886      * @return the first question of the epilog, which should be asked after
 887      * all the other questions in the configuration interview have been asked.
 888      */
 889     protected abstract Question getEpilogFirstQuestion();
 890 
 891     /**
 892      * Determine whether all the configuration values are valid, by
 893      * checking if the interview has been completed.
 894      * If so, the result will be true; if not, the result will be false,
 895      * and getErrorMessage will provide details about at least one of the
 896      * invalid values.
 897      *
 898      * @return true if and only if all the configuration values are valid
 899      * @see #getErrorMessage
 900      * @see #isFinishable
 901      */
 902     @Override
 903     public boolean isValid() {
 904         return isFinishable();
 905     }
 906 
 907     /**
 908      * If there is an error in any of the configuration values,
 909      * as indicated by isValid, this method will provide a detail
 910      * message about the first question for which there is a problem.
 911      *
 912      * @return a detail message about the first question with an invalid answer,
 913      * or null if none.
 914      * @see #isValid
 915      */
 916     @Override
 917     public String getErrorMessage() {
 918         Question[] path = getPath();
 919         Question lastQuestion = path[path.length - 1];
 920         if (lastQuestion instanceof FinalQuestion) {
 921             return null;
 922         } else if (lastQuestion instanceof ErrorQuestion) {
 923             return lastQuestion.getText();
 924         } else {
 925             String v = lastQuestion.getStringValue();
 926             return i18n.getString(&quot;ip.noAnswer&quot;,
 927                     lastQuestion.getSummary(), lastQuestion.getText(), lastQuestion.getTag(), Integer.valueOf(v == null ? 0 : 1), trim(v));
 928         }
 929     }
 930 
 931     private String trim(String text) {
 932         return text == null ? null
 933                 : text.length() &lt; 40 ? text
 934                 : text.substring(0, 37) + &quot;...&quot;;
 935     }
 936 
 937     /**
 938      * Get a filter which will filter tests according to the result
 939      * of getExcludeList(). If the result of getExcludeList is null
 940      * or an empty exclude list, the result of this method will also be null.
 941      *
 942      * @return a filter which will filter tests according to the result
 943      * of getExcludeList()
 944      * @see #getExcludeListFilter
 945      * @deprecated Use getExcludeListFilter().
 946      */
 947     @java.lang.Deprecated
 948     public TestFilter getExcludeTableFilter() {
 949         return getExcludeListFilter();
 950     }
 951 
 952     @Override
 953     public TestFilter getExcludeListFilter() {
 954         ExcludeList t = getExcludeList();
 955         if (t == null) {
 956             cachedExcludeListFilter = null;
 957         } else if (cachedExcludeListFilter == null
 958                 || cachedExcludeListFilter.getExcludeList() != t) {
 959             cachedExcludeListFilter = new ExcludeListFilter(t);
 960         }
 961         return cachedExcludeListFilter;
 962     }
 963 
 964     @Override
 965     public TestFilter getKeywordsFilter() {
 966         Keywords k = getKeywords();
 967         if (k == null) {
 968             cachedKeywordsFilter = null;
 969         } else if (cachedKeywordsFilter == null
 970                 || cachedKeywordsFilter.getKeywords() != k) {
 971             cachedKeywordsFilter = new KeywordsFilter(k);
 972         }
 973         return cachedKeywordsFilter;
 974     }
 975 
 976     @Override
 977     public TestFilter getPriorStatusFilter() {
 978         WorkDirectory wd = getWorkDirectory();
 979         TestResultTable r = wd == null ? null : wd.getTestResultTable();
 980         boolean[] s = getPriorStatusValues();
 981         if (r == null || s == null) {
 982             cachedStatusFilter = null;
 983         } else if (cachedStatusFilter == null
 984                 || cachedStatusFilter.getTestResultTable() != r
 985                 || !equal(cachedStatusFilter.getStatusValues(), s)) {
 986             cachedStatusFilter = new StatusFilter(s, r);
 987         }
 988         // else
 989         //   cachedStatusFilter is OK
 990 
 991         return cachedStatusFilter;
 992     }
 993 
 994     @Override
 995     public TestFilter getRelevantTestFilter() {
 996         TestSuite ts = getTestSuite();
 997         TestEnvironment env = getEnv();
 998         if (ts == null || env == null) {
 999             cachedRelevantTestFilter = null;
1000         } else if (cachedRelevantTestFilter == null ||
1001                 ts != cachedRelevantTestFilterTestSuite ||
1002                 env != cachedRelevantTestFilterEnv) {
1003             cachedRelevantTestFilter = ts.createTestFilter(env);
1004         }
1005         return cachedRelevantTestFilter;
1006     }
1007 
1008     @Override
1009     public synchronized TestFilter[] getFilters() {
1010         Vector&lt;TestFilter&gt; v = new Vector&lt;&gt;();
1011 
1012         TestFilter excludeFilter = getExcludeListFilter();
1013         if (excludeFilter != null) {
1014             v.add(excludeFilter);
1015         }
1016 
1017         TestFilter keywordFilter = getKeywordsFilter();
1018         if (keywordFilter != null) {
1019             v.add(keywordFilter);
1020         }
1021 
1022         TestFilter statusFilter = getPriorStatusFilter();
1023         if (statusFilter != null) {
1024             v.add(statusFilter);
1025         }
1026 
1027         v.addAll(getAllRelevantFiltersInTheSuite());
1028 
1029         if (v.isEmpty()) {
1030             return null;
1031         } else if (equal(v, cachedTestFilters)) {
1032             return cachedTestFilters;
1033         } else {
1034             return v.toArray(new TestFilter[v.size()]);
1035         }
1036 
1037     }
1038 
1039     /**
1040      * Determine if the current instance is a template or not.
1041      *
1042      * @return true if the current instance is a template,
1043      * and false otherwise
1044      */
1045     public boolean isTemplate() {
1046         return isTemplate;
1047     }
1048 
1049     /**
1050      * Set if the current instance is a template or not.
1051      * &lt;b&gt;For internal use only, architects should not use this.&lt;/b&gt;
1052      */
1053     public void setTemplate(boolean tm) {
1054         isTemplate = tm;
1055         updatePath();
1056     }
1057 
1058     protected boolean isAutoUpdatableKey(String key) {
1059         return isAutoUpdatableKey(key, null);
1060     }
1061 
1062     protected boolean isAutoUpdatableKey(String key, String subkey) {
1063         return false;
1064     }
1065 
1066     protected boolean isUpdatableKey(String key) {
1067         return true;
1068     }
1069 
1070     /**
1071      * Return String path to the template file for the current instance.
1072      * If the current instance is a template (isTemplate() returns true),
1073      * the path to itself will be returned.
1074      *
1075      * @return String path to the template file, or null if the instance is
1076      * not template-based
1077      */
1078     public String getTemplatePath() {
1079         if (isTemplate()) {
1080             File f = getFile();
1081             if (f != null) {
1082                 return f.getPath();
1083             }
1084         }
1085         return templatePath;
1086     }
1087 
1088     /**
1089      * Set the location of a configuration&#39;s master template.
1090      * Do not change this value if this instance is a template.
1091      */
1092     public void setTemplatePath(String tu) {
1093         templatePath = tu;
1094     }
1095 
1096     /**
1097      * Get the file associated with this interview.
1098      *
1099      * @return the file associated with this interview.
1100      * @see #setFile
1101      * @see #load
1102      * @see #save
1103      */
1104     public File getFile() {
1105         return currFile;
1106     }
1107 
1108     /**
1109      * Set the file associated with this interview. This file will be used
1110      * by subsequent load and save operations.
1111      *
1112      * @param f The file to be associated with this interview.
1113      * @see #getFile
1114      * @see #load
1115      * @see #save
1116      */
1117     public void setFile(File f) {
1118         currFile = f;
1119         currFileLoaded = false;
1120         if (f != null) {
1121             currFileLastModified = f.lastModified();
1122         } else {
1123             // means: unknown; will likely a trigger a reload
1124             currFileLastModified = 0;
1125         }
1126     }
1127 
1128     @Override
1129     public void clear() {
1130         WorkDirectory wd = getWorkDirectory();
1131         super.clear();
1132 
1133         if (wd != null &amp;&amp; TemplateUtilities.getTemplatePath(wd) != null) {
1134             if (wd.getTestSuite() != null) {
1135                 try {
1136                     wd.getTestSuite().loadInterviewFromTemplate(
1137                             TemplateUtilities.getTemplateFile(wd), this);
1138                 } catch (IOException ex) {
1139                     ex.printStackTrace();
1140                 }
1141             }
1142         }
1143         setEdited(false);
1144         currFile = null;
1145     }
1146 
1147     /**
1148      * Load the interview with the contents of the file associated with
1149      * the interview. If the file does not exist, the interview will be
1150      * cleared.
1151      *
1152      * @return true if there was an update from template
1153      * @throws IOException     is there is a problem reading the file
1154      * @throws Interview.Fault if there is a problem loading the
1155      *                         interview
1156      */
1157     public boolean load() throws IOException, Fault {
1158         File f = getFile();
1159         if (f != null &amp;&amp; f.exists()) {
1160             return load(f);
1161         } else {
1162             clear();
1163             setEdited(false);
1164             return false;
1165         }
1166     }
1167 
1168     /**
1169      * Load the interview with the contents of a specified file,
1170      * which will become the default file associated with the interview.
1171      *
1172      * @param file the file to be loaded
1173      * @return true if there was an update from template
1174      * @throws FileNotFoundException if the specified file does not exist.
1175      * @throws IOException           is there is a problem reading the file
1176      * @throws Interview.Fault       if there is a problem loading the
1177      *                               interview
1178      */
1179     public boolean load(File file) throws FileNotFoundException, IOException, Fault {
1180         try (InputStream in = new BufferedInputStream(new FileInputStream(file))) {
1181             Map&lt;String, String&gt; data = PropertyUtils.load(in);
1182             return load(data, file);
1183         }
1184     }
1185 
1186     /**
1187      * Load the interview with data that has already been read from a specified file,
1188      * which will become the default file associated with the interview.
1189      *
1190      * @param data the data to be loaded
1191      * @param file the file from which the data was read
1192      * @return true if there was an update from template
1193      * @throws Interview.Fault if there is a problem loading the interview
1194      */
1195     public boolean load(Map&lt;String, String&gt; data, File file) throws Fault {
1196         load(data);
1197 
1198         // restore template state
1199         String tm = data.get(IS_TEMPLATE);
1200         setTemplate(tm != null &amp;&amp; tm.equalsIgnoreCase(TRUE));
1201 
1202         setEdited(false);
1203         currFile = file;
1204         currFileLastModified = file.lastModified();
1205         currFileLoaded = true;
1206         return checkForUpdates();
1207     }
1208 
1209     /**
1210      * Returns true if there was update
1211      */
1212     public boolean checkForUpdates() {
1213         InterviewPropagator prop = new InterviewPropagator(this,
1214                 ignorableProps, ignorablePrefs);
1215         return prop.checkForUpdate();
1216     }
1217 
1218     @Override
1219     public void load(Map&lt;String, String&gt; data, boolean checkChecksum) throws Fault {
1220         super.load(data, checkChecksum);
1221 
1222         String me = data.get(MARKERS_ENABLED);
1223         setMarkersEnabled(me != null &amp;&amp; me.equalsIgnoreCase(TRUE));
1224 
1225         String mf = data.get(MARKERS_FILTER);
1226         setMarkersFilterEnabled(mf != null &amp;&amp; mf.equalsIgnoreCase(TRUE));
1227 
1228         String tm = data.get(IS_TEMPLATE);
1229         setTemplate(tm != null &amp;&amp; tm.equalsIgnoreCase(TRUE));
1230 
1231         String tu = null;
1232         //if (isTemplate()) {
1233         tu = data.get(TEMPLATE_PATH);
1234         //} else {
1235         //tu = (String) data.get(TEMPLATE_PREF + TEMPLATE_PATH);
1236         //}
1237         setTemplatePath(tu);
1238     }
1239 
1240     /**
1241      * Load the interview as best as possible with the data in another
1242      * Parameters object. If any of the various sub-objects as returned by
1243      * get&lt;i&gt;XXX&lt;/i&gt;Parameters are not recognized, they will be ignored.
1244      *
1245      * @param other The Parameters object to be copied.
1246      */
1247     public void load(Parameters other) {
1248         loadTestsParameters(other.getTestsParameters());
1249         loadExcludeListParameters(other.getExcludeListParameters());
1250         loadKeywordsParameters(other.getKeywordsParameters());
1251         loadPriorStatusParameters(other.getPriorStatusParameters());
1252         loadEnvParameters(other.getEnvParameters());
1253         loadConcurrencyParameters(other.getConcurrencyParameters());
1254         loadTimeoutFactorParameters(other.getTimeoutFactorParameters());
1255     }
1256 
1257     //----------------------------------------------------------------------------
1258 
1259     private void loadTestsParameters(TestsParameters other) {
1260         TestsParameters tp = getTestsParameters();
1261         if (!(tp instanceof MutableTestsParameters)) {
1262             return;
1263         }
1264 
1265         MutableTestsParameters mtp = (MutableTestsParameters) tp;
1266 
1267         if (other instanceof MutableTestsParameters) {
1268             MutableTestsParameters mop = (MutableTestsParameters) other;
1269             mtp.setTestsMode(mop.getTestsMode());
1270             mtp.setSpecifiedTests(mop.getSpecifiedTests());
1271         } else {
1272             String[] tests = other.getTests();
1273             if (tests == null) {
1274                 mtp.setTestsMode(MutableTestsParameters.ALL_TESTS);
1275                 mtp.setSpecifiedTests((String[]) null);
1276             } else {
1277                 mtp.setTestsMode(MutableTestsParameters.SPECIFIED_TESTS);
1278                 mtp.setSpecifiedTests(tests);
1279             }
1280         }
1281     }
1282 
1283     private void loadExcludeListParameters(ExcludeListParameters other) {
1284         ExcludeListParameters tp = getExcludeListParameters();
1285         if (!(tp instanceof MutableExcludeListParameters)) {
1286             return;
1287         }
1288 
1289         MutableExcludeListParameters mtp = (MutableExcludeListParameters) tp;
1290 
1291         if (other instanceof MutableExcludeListParameters) {
1292             MutableExcludeListParameters mop = (MutableExcludeListParameters) other;
1293             mtp.setExcludeMode(mop.getExcludeMode());
1294             mtp.setCustomExcludeFiles(mop.getCustomExcludeFiles());
1295             mtp.setLatestExcludeAutoCheckEnabled(mop.isLatestExcludeAutoCheckEnabled());
1296             mtp.setLatestExcludeAutoCheckMode(mop.getLatestExcludeAutoCheckMode());
1297             mtp.setLatestExcludeAutoCheckInterval(mop.getLatestExcludeAutoCheckInterval());
1298         } else {
1299             mtp.setExcludeMode(MutableExcludeListParameters.CUSTOM_EXCLUDE_LIST);
1300             mtp.setCustomExcludeFiles((File[]) null);
1301             mtp.setLatestExcludeAutoCheckEnabled(false);
1302             mtp.setLatestExcludeAutoCheckMode(MutableExcludeListParameters.CHECK_EVERY_X_DAYS);
1303             mtp.setLatestExcludeAutoCheckInterval(0);
1304         }
1305     }
1306 
1307     private void loadKeywordsParameters(KeywordsParameters other) {
1308         KeywordsParameters tp = getKeywordsParameters();
1309         if (!(tp instanceof MutableKeywordsParameters)) {
1310             return;
1311         }
1312 
1313         MutableKeywordsParameters mtp = (MutableKeywordsParameters) tp;
1314 
1315         if (other instanceof MutableKeywordsParameters) {
1316             MutableKeywordsParameters mop = (MutableKeywordsParameters) other;
1317             mtp.setKeywordsMode(mop.getKeywordsMode());
1318             mtp.setMatchKeywords(mop.getMatchKeywordsMode(), mop.getMatchKeywordsValue());
1319         } else {
1320             Keywords k = other.getKeywords();
1321             if (k == null) {
1322                 mtp.setKeywordsMode(MutableKeywordsParameters.NO_KEYWORDS);
1323                 mtp.setMatchKeywords(MutableKeywordsParameters.EXPR, &quot;&quot;);
1324             } else {
1325                 mtp.setKeywordsMode(MutableKeywordsParameters.MATCH_KEYWORDS);
1326                 mtp.setMatchKeywords(MutableKeywordsParameters.EXPR, k.toString());
1327             }
1328 
1329         }
1330     }
1331 
1332     private void loadPriorStatusParameters(PriorStatusParameters other) {
1333         PriorStatusParameters tp = getPriorStatusParameters();
1334         if (!(tp instanceof MutablePriorStatusParameters)) {
1335             return;
1336         }
1337 
1338         MutablePriorStatusParameters mtp = (MutablePriorStatusParameters) tp;
1339 
1340         if (other instanceof MutablePriorStatusParameters) {
1341             MutablePriorStatusParameters mop = (MutablePriorStatusParameters) other;
1342             mtp.setPriorStatusMode(mop.getPriorStatusMode());
1343             mtp.setMatchPriorStatusValues(mop.getMatchPriorStatusValues());
1344         } else {
1345             boolean[] b = other.getPriorStatusValues();
1346             if (b == null) {
1347                 mtp.setPriorStatusMode(MutablePriorStatusParameters.NO_PRIOR_STATUS);
1348                 mtp.setMatchPriorStatusValues(new boolean[Status.NUM_STATES]);
1349             } else {
1350                 mtp.setPriorStatusMode(MutablePriorStatusParameters.MATCH_PRIOR_STATUS);
1351                 mtp.setMatchPriorStatusValues(b);
1352             }
1353         }
1354     }
1355 
1356     private void loadEnvParameters(EnvParameters other) {
1357         EnvParameters tp = getEnvParameters();
1358         if (!(tp instanceof LegacyEnvParameters)) {
1359             return;
1360         }
1361 
1362         LegacyEnvParameters ltp = (LegacyEnvParameters) tp;
1363 
1364         if (other instanceof LegacyEnvParameters) {
1365             LegacyEnvParameters lop = (LegacyEnvParameters) other;
1366             ltp.setEnvFiles(lop.getEnvFiles());
1367             ltp.setEnvName(lop.getEnvName());
1368         }
1369     }
1370 
1371     private void loadConcurrencyParameters(ConcurrencyParameters other) {
1372         ConcurrencyParameters tp = getConcurrencyParameters();
1373         if (!(tp instanceof MutableConcurrencyParameters)) {
1374             return;
1375         }
1376 
1377         MutableConcurrencyParameters mtp = (MutableConcurrencyParameters) tp;
1378         mtp.setConcurrency(other.getConcurrency());
1379     }
1380 
1381     private void loadTimeoutFactorParameters(TimeoutFactorParameters other) {
1382         TimeoutFactorParameters tp = getTimeoutFactorParameters();
1383         if (!(tp instanceof MutableTimeoutFactorParameters)) {
1384             return;
1385         }
1386 
1387         MutableTimeoutFactorParameters mtp = (MutableTimeoutFactorParameters) tp;
1388         mtp.setTimeoutFactor(other.getTimeoutFactor());
1389     }
1390 
1391     /**
1392      * Save the current set of answers for the interview in the standard
1393      * file associated with the interview.
1394      *
1395      * @throws IOException     is there is a problem writing the file
1396      * @throws Interview.Fault if there is a problem preparing the
1397      *                         interview to be written
1398      * @see #getFile
1399      */
1400     public void save() throws IOException, Fault {
1401         File f = getFile();
1402         if (f == null) {
1403             throw new IllegalStateException();
1404         }
1405         save(f);
1406     }
1407 
1408     /**
1409      * Save the current state of the interview in a specified file,
1410      * and make that file the new file associated with the interview.
1411      *
1412      * @param file the file in which to save the state of the interview
1413      * @throws IOException     is there is a problem writing the file
1414      * @throws Interview.Fault if there is a problem preparing the
1415      *                         interview to be written
1416      * @see #getFile
1417      */
1418     public void save(File file) throws IOException, Fault {
1419         save(file, false);
1420     }
1421 
1422     /**
1423      * Save the current state of the interview in a specified file,
1424      * and make that file the new file associated with the interview.
1425      *
1426      * @param file       the file in which to save the state of the interview
1427      * @param isTemplate
1428      * @throws IOException     is there is a problem writing the file
1429      * @throws Interview.Fault if there is a problem preparing the
1430      *                         interview to be written
1431      * @see #getFile
1432      */
1433     public void save(File file, boolean isTemplate) throws IOException, Fault {
1434         saveAs(file, true, true, isTemplate);
1435 
1436         setEdited(false);
1437         currFile = file;
1438         currFileLastModified = file.lastModified();
1439         currFileLoaded = true;
1440     }
1441 
1442     /**
1443      * Save the current state of the interview in a specified file,
1444      * including the paths for the test suite and work directory.
1445      *
1446      * @param file the file in which to save the state of the interview
1447      * @throws IOException     is there is a problem writing the file
1448      * @throws Interview.Fault if there is a problem preparing the
1449      *                         interview to be written
1450      */
1451     public void saveAs(File file)
1452             throws IOException, Fault {
1453         saveAs(file, true, true);
1454     }
1455 
1456     /**
1457      * Save the current state of the interview in a specified file.
1458      * If the test suite path is not saved, the file can only be used
1459      * as a configuration template.
1460      *
1461      * @param file          the file in which to save the state of the interview
1462      * @param saveTestSuite if true, the test suite path will be saved
1463      *                      in the file.
1464      * @param saveWorkDir   if true, the work directory path will be saved
1465      *                      in the file.
1466      * @param isTemplate    True, the interview will be saved as template.
1467      * @throws IOException     is there is a problem writing the file
1468      * @throws Interview.Fault if there is a problem preparing the
1469      *                         interview to be written
1470      */
1471     public void saveAs(File file, boolean saveTestSuite, boolean saveWorkDir, boolean isTemplate)
1472             throws IOException, Fault {
1473         SortedMap&lt;String, String&gt; data = new TreeMap&lt;&gt;();
1474         setTemplate(isTemplate);        // dubious, why do we need to do this?
1475 
1476         if (saveTestSuite) {
1477             TestSuite ts = getTestSuite();
1478             if (ts != null) {
1479                 data.put(TESTSUITE, ts.getPath());
1480             }
1481         }
1482 
1483         if (saveWorkDir) {
1484             WorkDirectory wd = getWorkDirectory();
1485             if (wd != null) {
1486                 data.put(WORKDIR, wd.getPath());
1487             }
1488         }
1489 
1490         save(data);
1491 
1492         if (this.isTemplate == true) {
1493             TemplateManager tm = this.templateManager;
1494             if (tm != null &amp;&amp; !tm.canSaveTemplate(file)) {
1495                 throw new Interview.Fault(i18n, &quot;ip.badTmplPath&quot;);
1496             }
1497         }
1498 
1499         OutputStream out;
1500         if (backupPolicy == null) {
1501             out = new BufferedOutputStream(new FileOutputStream(file));
1502         } else {
1503             out = backupPolicy.backupAndOpenStream(file);
1504         }
1505 
1506         try {
1507             PropertyUtils.store(data, out, &quot;JT Harness Configuration Interview&quot;);
1508         } finally {
1509             out.close();
1510         }
1511     }
1512 
1513     /**
1514      * Save the current state of the interview in a specified file.
1515      * If the test suite path is not saved, the file can only be used
1516      * as a configuration template.
1517      *
1518      * @param file          the file in which to save the state of the interview
1519      * @param saveTestSuite if true, the test suite path will be saved
1520      *                      in the file.
1521      * @param saveWorkDir   if true, the work directory path will be saved
1522      *                      in the file.
1523      * @throws IOException     is there is a problem writing the file
1524      * @throws Interview.Fault if there is a problem preparing the
1525      *                         interview to be written
1526      */
1527     public void saveAs(File file, boolean saveTestSuite, boolean saveWorkDir)
1528             throws IOException, Fault {
1529         saveAs(file, saveTestSuite, saveWorkDir, false);
1530     }
1531 
1532     @Override
1533     public void save(Map&lt;String, String&gt; data) {
1534         if (markersEnabled) {
1535             data.put(MARKERS_ENABLED, TRUE);
1536         }
1537 
1538         if (markersFilterEnabled) {
1539             data.put(MARKERS_FILTER, TRUE);
1540         }
1541 
1542         if (isTemplate()) {
1543             data.put(IS_TEMPLATE, TRUE);
1544 
1545             storeTemplateProperties(new HashMap&lt;&gt;());
1546         } else {
1547             WorkDirectory wd = getWorkDirectory();
1548             if (wd != null &amp;&amp; TemplateUtilities.getTemplatePath(wd) != null) {
1549                 data.put(TEMPLATE_PATH, TemplateUtilities.getTemplatePath(wd));
1550             }
1551         }
1552 
1553         String name = getName();
1554         if (name != null) {
1555             data.put(NAME, name);
1556         }
1557 
1558         String desc = getDescription();
1559         if (desc != null) {
1560             data.put(DESC, desc);
1561         }
1562 
1563 
1564         super.save(data);
1565     }
1566 
1567     /**
1568      * Get the backup policy to be used when saving configuration files.
1569      *
1570      * @return the backup policy object to be used when saving configuration files
1571      * @see #setBackupPolicy
1572      */
1573     public BackupPolicy getBackupPolicy() {
1574         return backupPolicy;
1575     }
1576 
1577     /**
1578      * Set the backup policy to be used when saving configuration files.
1579      *
1580      * @param backupPolicy the backup policy object to be used when saving configuration files
1581      * @see #getBackupPolicy
1582      */
1583     public void setBackupPolicy(BackupPolicy backupPolicy) {
1584         this.backupPolicy = backupPolicy;
1585     }
1586 
1587     /**
1588      * Check if the current file has been loaded into this interview,
1589      * or if the interview has been saved in it.
1590      *
1591      * @return true if the file associated with the interview was set as a
1592      * side effect of load or save, or false if the file was just set by
1593      * setFile.
1594      */
1595     public boolean isFileLoaded() {
1596         return currFileLoaded;
1597     }
1598 
1599     /**
1600      * Determine if the file associated with this interview has been modified
1601      * on disk after the last call of load or save.
1602      *
1603      * @return true if the file on disk has been modified after it was last
1604      * used by load or save.
1605      * @see #load()
1606      * @see #save()
1607      */
1608     public boolean isFileNewer() {
1609         File f = getFile();
1610         return f != null &amp;&amp; f.exists() &amp;&amp; ((currFileLastModified == 0)
1611                 || (f.lastModified() &gt; currFileLastModified));
1612     }
1613 
1614     /**
1615      * Check whether or not markers should be enabled.
1616      *
1617      * @return whether or not markers should be enabled
1618      * @see #setMarkersEnabled
1619      */
1620     public boolean getMarkersEnabled() {
1621         return markersEnabled;
1622     }
1623 
1624     /**
1625      * Specify whether or not markers should be enabled.
1626      *
1627      * @param on whether or not markers should be enabled
1628      * @see #getMarkersEnabled
1629      */
1630     public void setMarkersEnabled(boolean on) {
1631         if (on != markersEnabled) {
1632             markersEnabled = on;
1633             setEdited(true);
1634         }
1635     }
1636 
1637     /**
1638      * Check whether or not the history list should be filtered to
1639      * just show questions which have been marked.
1640      *
1641      * @return whether or not the  history list should be filtered to
1642      * just show questions which have been marked
1643      * @see #setMarkersFilterEnabled
1644      */
1645     public boolean getMarkersFilterEnabled() {
1646         return markersFilterEnabled;
1647     }
1648 
1649     /**
1650      * Specify whether or not the history list should be filtered to
1651      * just show questions which have been marked.
1652      *
1653      * @param on whether or not the  history list should be filtered to
1654      *           just show questions which have been marked
1655      * @see #getMarkersFilterEnabled
1656      */
1657     public void setMarkersFilterEnabled(boolean on) {
1658         if (on != markersFilterEnabled) {
1659             markersFilterEnabled = on;
1660             setEdited(true);
1661         }
1662     }
1663     /**
1664      * The template manager is used to change behavior of
1665      * template saving, the default implementation is
1666      * the context manager of corresponding test suite.
1667      */
1668     public interface TemplateManager {
1669         /**
1670          * This method is invoked each time before saving template.
1671          * The template will be saved only if this method returns true.
1672          *
1673          * @param file template file
1674          * @return true if this operation is allowed, false otherwise
1675          */
1676         boolean canSaveTemplate(File file);
1677     }
1678 
1679     /**
1680      * Indicates problems when accessing the work directory.
1681      */
1682     public static class WorkDirFault extends Interview.Fault {
1683         /**
1684          * Create a fault with an internationalized message.
1685          *
1686          * @param i18n The bundle from which to get the string.
1687          * @param s    The key for getting the string to be displayed from the
1688          *             supplied bundle.
1689          */
1690         public WorkDirFault(ResourceBundle i18n, String s) {
1691             super(i18n, s);
1692         }
1693 
1694         /**
1695          * Create a fault with an internationalized message.
1696          *
1697          * @param i18n The bundle from which to get the string.
1698          * @param s    The key for getting the string to be displayed from the
1699          *             supplied bundle.
1700          * @param o    Parameter to use when resolving the string from the bundle.
1701          * @see java.text.MessageFormat
1702          */
1703         public WorkDirFault(ResourceBundle i18n, String s, Object o) {
1704             super(i18n, s, o);
1705         }
1706 
1707         /**
1708          * Create a fault with an internationalized message.
1709          *
1710          * @param i18n The bundle from which to get the string.
1711          * @param s    The key for getting the string to be displayed from the
1712          *             supplied bundle.
1713          * @param o    Parameters to use when resolving the string from the bundle.
1714          * @see java.text.MessageFormat
1715          */
1716         public WorkDirFault(ResourceBundle i18n, String s, Object... o) {
1717             super(i18n, s, o);
1718         }
1719     }
1720 
1721     /**
1722      * Indicates problems when accessing the test suite.
1723      */
1724     public static class TestSuiteFault extends Interview.Fault {
1725         /**
1726          * Create a fault with an internationalized message.
1727          *
1728          * @param i18n The bundle from which to get the string.
1729          * @param s    The key for getting the string to be displayed from the
1730          *             supplied bundle.
1731          */
1732         public TestSuiteFault(ResourceBundle i18n, String s) {
1733             super(i18n, s);
1734         }
1735 
1736         /**
1737          * Create a fault with an internationalized message.
1738          *
1739          * @param i18n The bundle from which to get the string.
1740          * @param s    The key for getting the string to be displayed from the
1741          *             supplied bundle.
1742          * @param o    Parameter to use when resolving the string from the bundle.
1743          * @see java.text.MessageFormat
1744          */
1745         public TestSuiteFault(ResourceBundle i18n, String s, Object o) {
1746             super(i18n, s, o);
1747         }
1748 
1749         /**
1750          * Create a fault with an internationalized message.
1751          *
1752          * @param i18n The bundle from which to get the string.
1753          * @param s    The key for getting the string to be displayed from the
1754          *             supplied bundle.
1755          * @param o    Parameters to use when resolving the string from the bundle.
1756          * @see java.text.MessageFormat
1757          */
1758         public TestSuiteFault(ResourceBundle i18n, String s, Object... o) {
1759             super(i18n, s, o);
1760         }
1761     }
1762 
1763     /**
1764      * Indicates problems when accessing the configuration file.
1765      */
1766     public static class JTIFault extends Interview.Fault {
1767         /**
1768          * Create a fault with an internationalized message.
1769          *
1770          * @param i18n The bundle from which to get the string.
1771          * @param s    The key for getting the string to be displayed from the
1772          *             supplied bundle.
1773          */
1774         public JTIFault(ResourceBundle i18n, String s) {
1775             super(i18n, s);
1776         }
1777 
1778         /**
1779          * Create a fault with an internationalized message.
1780          *
1781          * @param i18n The bundle from which to get the string.
1782          * @param s    The key for getting the string to be displayed from the
1783          *             supplied bundle.
1784          * @param o    Parameter to use when resolving the string from the bundle.
1785          * @see java.text.MessageFormat
1786          */
1787         public JTIFault(ResourceBundle i18n, String s, Object o) {
1788             super(i18n, s, o);
1789         }
1790 
1791         /**
1792          * Create a fault with an internationalized message.
1793          *
1794          * @param i18n The bundle from which to get the string.
1795          * @param s    The key for getting the string to be displayed from the
1796          *             supplied bundle.
1797          * @param o    Parameters to use when resolving the string from the bundle.
1798          * @see java.text.MessageFormat
1799          */
1800         public JTIFault(ResourceBundle i18n, String s, Object... o) {
1801             super(i18n, s, o);
1802         }
1803     }
1804 }
    </pre>
  </body>
</html>
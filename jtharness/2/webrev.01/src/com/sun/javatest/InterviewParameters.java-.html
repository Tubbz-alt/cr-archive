<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/com/sun/javatest/InterviewParameters.java</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * $Id$
   3  *
   4  * Copyright (c) 2001, 2015, Oracle and/or its affiliates. All rights reserved.
   5  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   6  *
   7  * This code is free software; you can redistribute it and/or modify it
   8  * under the terms of the GNU General Public License version 2 only, as
   9  * published by the Free Software Foundation.  Oracle designates this
  10  * particular file as subject to the &quot;Classpath&quot; exception as provided
  11  * by Oracle in the LICENSE file that accompanied this code.
  12  *
  13  * This code is distributed in the hope that it will be useful, but WITHOUT
  14  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  15  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  16  * version 2 for more details (a copy is included in the LICENSE file that
  17  * accompanied this code).
  18  *
  19  * You should have received a copy of the GNU General Public License version
  20  * 2 along with this work; if not, write to the Free Software Foundation,
  21  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  22  *
  23  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  24  * or visit www.oracle.com if you need additional information or have any
  25  * questions.
  26  */
  27 package com.sun.javatest;
  28 
  29 import com.sun.interview.ErrorQuestion;
  30 import com.sun.interview.FinalQuestion;
  31 import com.sun.interview.Interview;
  32 import com.sun.interview.Question;
  33 import com.sun.javatest.tool.CustomPropagationController;
  34 import com.sun.javatest.tool.FileHistory;
  35 import com.sun.javatest.util.BackupPolicy;
  36 import com.sun.javatest.util.I18NResourceBundle;
  37 import com.sun.javatest.util.PropertyUtils;
  38 
  39 import java.io.BufferedInputStream;
  40 import java.io.BufferedOutputStream;
  41 import java.io.File;
  42 import java.io.FileInputStream;
  43 import java.io.FileNotFoundException;
  44 import java.io.FileOutputStream;
  45 import java.io.IOException;
  46 import java.io.InputStream;
  47 import java.io.OutputStream;
  48 import java.util.HashMap;
  49 import java.util.Map;
  50 import java.util.ResourceBundle;
  51 import java.util.SortedMap;
  52 import java.util.TreeMap;
  53 import java.util.Vector;
  54 
  55 /**
  56  * Configuration parameters provided via an interview.
  57  *
  58  * @since 3.0
  59  */
  60 public abstract class InterviewParameters
  61         extends Interview
  62         implements Parameters {
  63 
  64     static final String TESTSUITE = &quot;TESTSUITE&quot;;
  65     static final String WORKDIR = &quot;WORKDIR&quot;;
  66     static final String NAME = &quot;NAME&quot;;
  67     static final String DESC = &quot;DESCRIPTION&quot;;
  68     static final String MARKERS_ENABLED = &quot;MARKERS.enabled&quot;;
  69     static final String MARKERS_FILTER = &quot;MARKERS.filter&quot;;
  70     static final String IS_TEMPLATE = &quot;IS_TEMPLATE&quot;;
  71     static final String TEMPLATE_PATH = &quot;TEMPLATE_PATH&quot;;
  72     static final String TRUE = &quot;true&quot;;
  73     private static I18NResourceBundle i18n = I18NResourceBundle.getBundleForClass(InterviewParameters.class);
  74     //----------------------------------------------------------------------------
  75     private final String[] ignorableProps = {
  76             INTERVIEW,
  77             LOCALE, TESTSUITE, WORKDIR, MARKERS,
  78             IS_TEMPLATE, TEMPLATE_PATH, QUESTION};
  79     private final String[] ignorablePrefs = {MARKERS_PREF, EXTERNAL_PREF, TEMPLATE_PREF};
  80     protected File[] kflFiles;
  81 
  82     //----------------------------------------------------------------------------
  83     private TemplateManager templateManager = null;
  84     private boolean inGetName;
  85     private ExcludeListFilter cachedExcludeListFilter;
  86 
  87 
  88     //----------------------------------------------------------------------------
  89     private KeywordsFilter cachedKeywordsFilter;
  90 
  91     //----------------------------------------------------------------------------
  92     private StatusFilter cachedStatusFilter;
  93     private TestFilter cachedRelevantTestFilter;
  94     private TestSuite cachedRelevantTestFilterTestSuite; // do we need this?
  95     private TestEnvironment cachedRelevantTestFilterEnv;
  96     private TestFilter[] cachedTestFilters;
  97     private BackupPolicy backupPolicy;
  98     private boolean markersEnabled;
  99     private boolean markersFilterEnabled;
 100     private File currFile;
 101     private boolean isTemplate;
 102     private String templatePath;
 103     private long currFileLastModified;
 104     private boolean currFileLoaded;
 105     private CustomPropagationController pc = new CustomPropagationController();
 106 
 107     /**
 108      * Create an InterviewParameters object.
 109      *
 110      * @param tag The tag used to qualify questions in this interview
 111      */
 112     protected InterviewParameters(String tag) {
 113         super(tag);
 114     }
 115 
 116     private static boolean equal(boolean[] b1, boolean... b2) {
 117         if (b1 == null || b2 == null) {
 118             return b1 == b2;
 119         }
 120 
 121         if (b1.length != b2.length) {
 122             return false;
 123         }
 124 
 125         for (int i = 0; i &lt; b1.length; i++) {
 126             if (b1[i] != b2[i]) {
 127                 return false;
 128             }
 129         }
 130 
 131         return true;
 132     }
 133 
 134     private static boolean equal(Vector&lt;TestFilter&gt; v, TestFilter... f) {
 135         if (f == null || v.size() != f.length) {
 136             return false;
 137         }
 138         for (int i = 0; i &lt; v.size(); i++) {
 139             if (!v.get(i).equals(f[i])) {
 140                 return false;
 141             }
 142         }
 143         return true;
 144     }
 145 
 146     /**
 147      * Determine if the specified file is an interview file,
 148      * as determined by whether its extension is .jti or not.
 149      *
 150      * @param f the file to be checked
 151      * @return true if the specified file is an interview file,
 152      * and false otherwise
 153      */
 154     public static boolean isInterviewFile(File f) {
 155         return f.getName().endsWith(&quot;.jti&quot;);
 156     }
 157 
 158     /**
 159      * Create an InterviewParameters as determined by the contents of an
 160      * interview file.
 161      *
 162      * @param file the file to be read
 163      * @return an InterviewParameters as determined by the contents of an
 164      * interview file.
 165      * @throws IOException     is there is a problem reading the file
 166      * @throws Interview.Fault if there is a problem instantiating the
 167      *                         interview
 168      */
 169     public static InterviewParameters open(File file)
 170             throws IOException, Fault {
 171         return open(file, (TestSuite) null, (WorkDirectory) null);
 172     }
 173 
 174     /**
 175      * Create an InterviewParameters by populating the interview for a specified
 176      * test suite with responses from a given file.
 177      *
 178      * @param file      the file to be read
 179      * @param testSuite the test suite for which to create the interview
 180      * @return an InterviewParameters as determined by the test suite
 181      * and the contents of an interview file
 182      * @throws IOException     is there is a problem reading the file
 183      * @throws Interview.Fault if there is a problem instantiating the
 184      *                         interview
 185      */
 186     public static InterviewParameters open(File file, TestSuite testSuite)
 187             throws IOException, Fault {
 188         if (testSuite == null) {
 189             throw new NullPointerException();
 190         }
 191 
 192         return open(file, testSuite, null);
 193     }
 194 
 195     /**
 196      * Create an InterviewParameters by populating the interview for a specified
 197      * work directory with responses from a given file.
 198      *
 199      * @param file    the file to be read
 200      * @param workDir the work directory (implying the test suite) for which
 201      *                to create the interview
 202      * @return an InterviewParameters as determined by the work directory
 203      * and the contents of an interview file
 204      * @throws IOException     is there is a problem reading the file
 205      * @throws Interview.Fault if there is a problem instantiating the
 206      *                         interview
 207      */
 208     public static InterviewParameters open(File file, WorkDirectory workDir)
 209             throws IOException, Fault {
 210         if (workDir == null) {
 211             throw new NullPointerException();
 212         }
 213 
 214         return open(file, workDir.getTestSuite(), workDir);
 215     }
 216 
 217     /**
 218      * @throws WorkDirFault   If there is a problem finding the work directory.
 219      * @throws TestSuiteFault If there is a problem finding the test suite.
 220      * @throws JTIFault       If there is a problem finding the JTI file.  Not thrown
 221      *                        if the file is corrupt or incompatible though.
 222      * @throws Fault          If there is any other problem opening the interview params, such as
 223      *                        problems with data in the JTI, incompatibilities between the workdir,
 224      *                        test suite or work dir.
 225      */
 226     private static InterviewParameters open(File file, TestSuite testSuite, WorkDirectory workDir)
 227             throws IOException, Fault {
 228         // note: the additional Fault types were introduced in JT 3.2.1
 229 
 230         // read the .jti data
 231         Map&lt;String, String&gt; data;
 232 
 233         try (InputStream in = new BufferedInputStream(new FileInputStream(file))) {
 234             data = PropertyUtils.load(in);
 235         } catch (RuntimeException e) {
 236             // can get IllegalArgumentException if the file is corrupt
 237             throw new JTIFault(i18n, &quot;ip.errorReadingFile&quot;, file, e);
 238         }
 239 
 240         // if the test suite has not been given, set it from the .jti data
 241         if (testSuite == null) {
 242             String s = data.get(TESTSUITE);
 243             if (s == null) {
 244                 throw new Fault(i18n, &quot;ip.noTestSuiteInFile&quot;, file);
 245             }
 246 
 247             try {
 248                 testSuite = TestSuite.open(new File(s));
 249             } catch (FileNotFoundException e) {
 250                 throw new TestSuiteFault(i18n, &quot;ip.cantFindTestSuiteInFile&quot;,
 251                         s, file);
 252             } catch (TestSuite.Fault e) {
 253                 throw new Fault(i18n, &quot;ip.cantOpenTestSuiteInFile&quot;,
 254                         s, file, e.getMessage());
 255             }
 256         }
 257 
 258         // if the work directory has not been given,
 259         // set it from the .jti data if given
 260         if (workDir == null) {
 261             String s = data.get(WORKDIR);
 262             if (s != null) {
 263                 try {
 264                     workDir = WorkDirectory.open(new File(s), testSuite);
 265                 } catch (FileNotFoundException e) {
 266                     throw new WorkDirFault(i18n, &quot;ip.cantFindWorkDirInFile&quot;,
 267                             s, file);
 268                 } catch (WorkDirectory.Fault e) {
 269                     throw new Fault(i18n, &quot;ip.cantOpenWorkDirInFile&quot;,
 270                             s, file, e.getMessage());
 271                 }
 272             }
 273         }
 274 
 275         InterviewParameters parameters;
 276 
 277         // create the parameters object
 278         try {
 279             parameters = testSuite.createInterview();
 280         } catch (TestSuite.Fault e) {
 281             throw new Fault(i18n, &quot;ip.cantCreateInterviewForTestSuite&quot;,
 282                     testSuite.getPath(), e.getMessage());
 283         }
 284 
 285         // set the work dir in the parameters object
 286         if (workDir != null) {
 287             parameters.setWorkDirectory(workDir);
 288         }
 289 
 290         // load the .jti data into the parameters object
 291         try {
 292             parameters.load(data, file);
 293         } catch (InterviewParameters.Fault e) {
 294             throw new Fault(i18n, &quot;ip.cantLoadInterview&quot;,
 295                     file, e.getMessage());
 296         }
 297 
 298         return parameters;
 299     }
 300 
 301     /**
 302      * Open a a configuration file, based on paths for the configuration file,
 303      * test suite and work directory. Any, but not all, of these paths may be null.
 304      * Any non-null path must specify an appropriate existing file, otherwise
 305      * an exception will be thrown.
 306      *
 307      * @param testSuitePath  the path for the test suite; if not specified,
 308      *                       the test suite will default from the work directory (if specified) or
 309      *                       the configuration file.
 310      * @param workDirPath    the path for the work directory; if not specified,
 311      *                       the work directory will the default from the config file (if specified),
 312      *                       or will be null if no configuration file is given
 313      * @param configFilePath the path for the configuration file; if not specified,
 314      *                       the result will be a blank interview as created by the test suite.
 315      * @return an InterviewParameters object created from the given arguments
 316      * @throws Interview.Fault if there is any problem creating the
 317      *                         result
 318      */
 319     public static InterviewParameters open(String testSuitePath, String workDirPath, String configFilePath)
 320             throws InterviewParameters.Fault {
 321         File ts = testSuitePath != null &amp;&amp; !testSuitePath.isEmpty()
 322                 ? new File(testSuitePath) : null;
 323         File wd = workDirPath != null &amp;&amp; !workDirPath.isEmpty()
 324                 ? new File(workDirPath) : null;
 325         File cf = configFilePath != null &amp;&amp; !configFilePath.isEmpty()
 326                 ? new File(configFilePath) : null;
 327         return open(ts, wd, cf);
 328     }
 329 
 330     /**
 331      * Open a a configuration file, based on paths for the configuration file,
 332      * test suite and work directory. Any, but not all, of these paths may be null.
 333      * Any non-null path must specify an appropriate existing file, otherwise
 334      * an exception will be thrown.
 335      *
 336      * @param testSuitePath  the path for the test suite; if not specified,
 337      *                       the test suite will default from the work directory (if specified) or
 338      *                       the configuration file.
 339      * @param workDirPath    the path for the work directory; if not specified,
 340      *                       the work directory will bdefault from the config file (if specified),
 341      *                       or will be null if no configuration file is given
 342      * @param configFilePath the path for the configuration file; if not specified,
 343      *                       the result will be a blank interview as created by the test suite.
 344      * @return an InterviewParameters object created from the gievn arguments
 345      * @throws Interview.Fault if there is any problem creating the
 346      *                         result
 347      */
 348     public static InterviewParameters open(File testSuitePath, File workDirPath, File configFilePath)
 349             throws InterviewParameters.Fault {
 350 
 351         // open test suite if specified
 352 
 353         TestSuite testSuite;
 354 
 355         if (testSuitePath != null) {
 356             try {
 357                 testSuite = TestSuite.open(testSuitePath);
 358             } catch (FileNotFoundException e) {
 359                 throw new Fault(i18n, &quot;ip.cantFindTestSuite&quot;, testSuitePath, e);
 360             } catch (TestSuite.Fault e) {
 361                 throw new Fault(i18n, &quot;ip.cantOpenTestSuite&quot;, testSuitePath, e.getMessage());
 362             }
 363         } else {
 364             testSuite = null;
 365         }
 366 
 367         // open work directory if specified, defaulting test suite if appropriate
 368 
 369         WorkDirectory workDir;
 370 
 371         if (workDirPath != null) {
 372             try {
 373                 if (testSuite == null) {
 374                     workDir = WorkDirectory.open(workDirPath);
 375                     testSuite = workDir.getTestSuite();
 376                 } else {
 377                     workDir = WorkDirectory.open(workDirPath, testSuite);
 378                 }
 379             } catch (FileNotFoundException e) {
 380                 throw new Fault(i18n, &quot;ip.cantFindWorkDir&quot;, workDirPath, e);
 381             } catch (WorkDirectory.Fault e) {
 382                 throw new Fault(i18n, &quot;ip.cantOpenWorkDir&quot;, workDirPath, e.getMessage());
 383             }
 384         } else {
 385             workDir = null;
 386         }
 387 
 388         // open config file if specified, defaulting work dir and test suite if appropriate
 389         // default config from test suite if appropriate
 390 
 391         InterviewParameters config;
 392 
 393         if (configFilePath == null) {
 394             if (testSuite != null) {
 395                 try {
 396                     config = testSuite.createInterview();
 397                 } catch (TestSuite.Fault e) {
 398                     throw new Fault(i18n, &quot;ip.cantCreateInterviewForTestSuite&quot;, testSuitePath, e);
 399                 }
 400 
 401                 if (workDir != null) {
 402                     config.setWorkDirectory(workDir);
 403                     FileHistory h = FileHistory.getFileHistory(workDir, &quot;configHistory.jtl&quot;);
 404                     File latestConfigFile = h.getLatestEntry();
 405 
 406                     if (latestConfigFile != null) {
 407                         try {
 408                             config.load(latestConfigFile);
 409                         } catch (IOException e) {
 410                             // ignore?
 411                         }   // catch
 412                     }
 413                 }   // workdir != null
 414             } else {
 415                 throw new Fault(i18n, &quot;ip.noPaths&quot;);
 416             }
 417         } else {
 418             try {
 419                 if (workDir == null) {
 420                     if (testSuite == null) {
 421                         config = open(configFilePath);
 422                         testSuite = config.getTestSuite();
 423                     } else {
 424                         config = open(configFilePath, testSuite);
 425                     }
 426                     workDir = config.getWorkDirectory();
 427                 } else {
 428                     config = open(configFilePath, workDir);
 429                 }
 430             } catch (FileNotFoundException e) {
 431                 throw new Fault(i18n, &quot;ip.cantFindConfigFile&quot;, configFilePath);
 432             } catch (IOException e) {
 433                 throw new Fault(i18n, &quot;ip.cantOpenConfigFile&quot;, configFilePath, e);
 434             }
 435         }
 436 
 437         // if still here, and had sufficient args, config should be open
 438         // and fully initialized
 439         return config;
 440     }
 441 
 442     public CustomPropagationController getPropagationController() {
 443         return pc;
 444     }
 445 
 446     public void setPropagationController(CustomPropagationController pc) {
 447         this.pc = pc;
 448     }
 449 
 450     /**
 451      * Set the work directory to be used for this test run.
 452      *
 453      * @param workDir the work directory to be used for this test run.
 454      *                It must match the test suite to be used for this test run
 455      */
 456     @Override
 457     public abstract void setWorkDirectory(WorkDirectory workDir);
 458 
 459     //----------------------------------------------------------------------------
 460 
 461     /**
 462      * Return the template manager for this InterviewParameters.
 463      */
 464     public TemplateManager getTemplateManger() {
 465         return templateManager;
 466     }
 467 
 468     /**
 469      * Set given template manager for this InterviewParameters.
 470      *
 471      * @param tm new template manager
 472      */
 473     public void setTemplateManger(TemplateManager tm) {
 474         this.templateManager = tm;
 475     }
 476 
 477     /**
 478      * Initialize an InterviewParameters object.
 479      * This method is called when the object is created
 480      * from an entry in a .jtt file.
 481      * By default, the method throws an exception if any arguments
 482      * are given. It should be redefined by any test suites that wish
 483      * to support this type of initialization.
 484      *
 485      * @param args test suite specific args with which to initialize
 486      *             this InterviewParameters object
 487      * @throws Interview.Fault if any problems occurred while processing the arguments
 488      */
 489     public void init(String... args) throws Fault {
 490         if (args != null &amp;&amp; args.length &gt; 0) {
 491             throw new Fault(i18n, &quot;ip.unknownArgs&quot;);
 492         }
 493     }
 494 
 495 
 496     //----------------------------------------------------------------------------
 497 
 498     /**
 499      * Clean up an InterviewParameters object.
 500      * This method should be invoked at the moment InterviewParameters object
 501      * becomes useless by the code, that controls it&#39;s lifecycle. For example,
 502      * at the end of the method which created it&#39;s local instance.
 503      * &lt;p&gt;
 504      * Any following invocations on this object may result in unpredictable
 505      * exceptions because of object inconsistence.
 506      */
 507     public void dispose() {
 508         kflFiles = null;
 509         backupPolicy = null;
 510         cachedExcludeListFilter = null;
 511         cachedKeywordsFilter = null;
 512         cachedRelevantTestFilter = null;
 513         cachedRelevantTestFilterEnv = null;
 514         cachedStatusFilter = null;
 515         cachedTestFilters = null;
 516         pc = null;
 517         templateManager = null;
 518     }
 519 
 520     /**
 521      * Get the name for this configuration.
 522      * By default and for backwards compatibility, this defaults to the
 523      * name of the test environment, which means that the whole environment
 524      * may need to be evaluated to get the required value. Subtypes may
 525      * choose to override this method to provide a more efficient
 526      * implementation.
 527      *
 528      * &lt;p&gt; Since the default implementation gets the name from the test
 529      * environment, clients should not use this method to determine
 530      * the name for the test environment, unless this method is redefined.
 531      * The default implementation detects such a circular usage, and
 532      * returns null in this case.
 533      *
 534      * @return the name for this configuration, or null if not known.
 535      */
 536     public synchronized String getName() {
 537         if (inGetName) {
 538             return null;
 539         }
 540 
 541         try {
 542             inGetName = true;
 543 
 544             EnvParameters eParams = getEnvParameters();
 545             if (eParams != null) {
 546                 // getName to get the name for the environment
 547                 TestEnvironment e = eParams.getEnv();
 548                 if (e != null) {
 549                     return e.getName();
 550                 }
 551             }
 552             return null;
 553         } finally {
 554             inGetName = false;
 555         }
 556     }
 557 
 558     /**
 559      * Get a description for this configuration.
 560      * By default and for backwards compatibility, this defaults to the
 561      * description entry in the test environment, which means that the
 562      * whole environment may need to be evaluated to get the required value.
 563      * Subtypes may choose to override this method to provide a more efficient
 564      * implementation.
 565      *
 566      * @return a description for this configuration, or null if not known
 567      */
 568     public String getDescription() {
 569         EnvParameters eParams = getEnvParameters();
 570         if (eParams != null) {
 571             TestEnvironment e = eParams.getEnv();
 572             if (e != null) {
 573                 return e.getDescription();
 574             }
 575         }
 576         return null;
 577     }
 578 
 579     /**
 580      * Get the next question to the asked after the initial prolog
 581      * of questions.
 582      * The default value is the result of getEnvFirstQuestion.
 583      *
 584      * @return the next question to be asked after the initial prolog
 585      * of questions.
 586      * @see #setFirstQuestion
 587      */
 588     protected Question getPrologSuccessorQuestion() {
 589         return getEnvFirstQuestion();
 590     }
 591 
 592     @Override
 593     public TestEnvironment getEnv() {
 594         EnvParameters eParams = getEnvParameters();
 595         if (eParams == null) {
 596             throw new NullPointerException();
 597         } else {
 598             return eParams.getEnv();
 599         }
 600     }
 601 
 602     /**
 603      * Get the first question to be asked concerning the environment to be
 604      * set up and used for each test to be run. If these questions are
 605      * contained in an interview, this method can be simply implemented as:&lt;br&gt;
 606      * {@code return callInterview(}&lt;i&gt;envInterview&lt;/i&gt;{@code , getEnvSuccessorQuestion);}&lt;br&gt;
 607      *
 608      * @return the first question to be asked concerning the environment to be
 609      * set up and used for each test to be run.
 610      * @see #getEnvSuccessorQuestion
 611      */
 612     protected abstract Question getEnvFirstQuestion();
 613 
 614     /**
 615      * Get the next question to be asked after those concerning
 616      * the environment to be set up and used for each test to be run.
 617      * The default value is the result of getTestsFirstQuestion.
 618      *
 619      * @return the next question to be asked after those concerning
 620      * the environment to be set up and used for each test to be run.
 621      * @see #getEnvFirstQuestion
 622      */
 623     protected Question getEnvSuccessorQuestion() {
 624         return getTestsFirstQuestion();
 625     }
 626 
 627     @Override
 628     public String[] getTests() {
 629         TestsParameters iParams = getTestsParameters();
 630         return iParams == null ? null : iParams.getTests();
 631     }
 632 
 633     /**
 634      * Get the first question to be asked concerning the set of tests
 635      * and folders of tests to be run.
 636      *
 637      * @return the first question to be asked concerning the set of tests
 638      * and folders of tests to be run.
 639      * @see #getTestsSuccessorQuestion
 640      */
 641     protected abstract Question getTestsFirstQuestion();
 642 
 643     /**
 644      * Get the next question to be asked after those concerning
 645      * the tests and folders of tests to be run.
 646      * The default value is the result of getExcludeListFirstQuestion.
 647      *
 648      * @return the next question to be asked after those concerning
 649      * the tests and folders of tests to be run.
 650      * @see #getTestsFirstQuestion
 651      */
 652     protected Question getTestsSuccessorQuestion() {
 653         return getExcludeListFirstQuestion();
 654     }
 655 
 656     @Override
 657     public ExcludeList getExcludeList() {
 658         ExcludeListParameters eParams = getExcludeListParameters();
 659         return eParams == null ? new ExcludeList() : eParams.getExcludeList();
 660     }
 661 
 662     /**
 663      * Get the combined known failures list.
 664      * Interviews expecting to use known failures lists should generally override
 665      * this method and add support for users to change it.
 666      *
 667      * @return Current known failures list - combined from the one or more
 668      * file specified by the user.
 669      * @see #setKnownFailureFiles(java.io.File[])
 670      * @see com.sun.javatest.interview.BasicInterviewParameters
 671      * @since 4.4
 672      */
 673     public KnownFailuresList getKnownFailuresList() {
 674         try {
 675             if (kflFiles != null) {
 676                 return new KnownFailuresList(getKnownFailureFiles());
 677             } else {
 678                 return null;
 679             }
 680 
 681         } catch (IOException | KnownFailuresList.Fault e) {
 682             return null;
 683         }
 684     }
 685 
 686     /**
 687      * Get the current set of known failures list files.
 688      * The default implementation will return the value in the kflFiles
 689      * field, which subclasses may set.
 690      *
 691      * @return The list of known failure list files.  Null if none.
 692      * @see #setKnownFailureFiles(java.io.File[])
 693      * @since 4.4
 694      */
 695     public File[] getKnownFailureFiles() {
 696         return kflFiles;
 697     }
 698 
 699     /**
 700      * Set the set of KFL files.
 701      *
 702      * @param files The known failures list files.  The array should contain
 703      *              one or more elements.
 704      * @since 4.4
 705      */
 706     public void setKnownFailureFiles(File... files) {
 707         kflFiles = files;
 708     }
 709 
 710     /**
 711      * Get the first question to be asked concerning the exclude list
 712      * to be used to exclude tests from the test run.
 713      *
 714      * @return the first question to be asked concerning the exclude list
 715      * to be used to exclude tests from the test run.
 716      * @see #getExcludeListSuccessorQuestion
 717      */
 718     protected abstract Question getExcludeListFirstQuestion();
 719 
 720     //----------------------------------------------------------------------------
 721 
 722     /**
 723      * Get the first question to be asked concerning the exclude list
 724      * to be used to exclude tests from the test run.
 725      *
 726      * @return the first question to be asked concerning the exclude list
 727      * to be used to exclude tests from the test run
 728      * @see #getExcludeListFirstQuestion
 729      * @deprecated Use getExcludeListFirstQuestion().
 730      */
 731     @java.lang.Deprecated
 732     protected Question getExcludeTableFirstQuestion() {
 733         return getExcludeListFirstQuestion();
 734     }
 735 
 736     /**
 737      * Get the next question to be asked after those concerning
 738      * the exclude list to be used to exclude tests from the test run.
 739      * The default value is the result of getKeywordsFirstQuestion,
 740      *
 741      * @return the next question to be asked after those concerning
 742      * the exclude list to be used to exclude tests from the test run.
 743      * @see #getExcludeListFirstQuestion
 744      */
 745     protected Question getExcludeListSuccessorQuestion() {
 746         return getKeywordsFirstQuestion();
 747     }
 748 
 749     /**
 750      * Get the next question to be asked after those concerning
 751      * the exclude list to be used to exclude tests from the test run.
 752      *
 753      * @return the next question to be asked after those concerning
 754      * the exclude list to be used to exclude tests from the test run
 755      * @see #getExcludeListSuccessorQuestion
 756      * @deprecated Use getExcludeListFirstQuestion().
 757      */
 758     @java.lang.Deprecated
 759     protected Question getExcludeTableSuccessorQuestion() {
 760         return getExcludeListSuccessorQuestion();
 761     }
 762 
 763     @Override
 764     public Keywords getKeywords() {
 765         KeywordsParameters kParams = getKeywordsParameters();
 766         return kParams == null ? null : kParams.getKeywords();
 767     }
 768 
 769     /**
 770      * Get the first question to be asked concerning the keywords
 771      * that may be used to select tests for the test run.
 772      *
 773      * @return the first question to be asked concerning the keywords
 774      * that may be used to select tests for the test run.
 775      * @see #getKeywordsSuccessorQuestion
 776      */
 777     protected abstract Question getKeywordsFirstQuestion();
 778 
 779     /**
 780      * Get the next question to be asked after those concerning
 781      * the keywords that may be used to select tests for the test run.
 782      * The default value is the result of getPriorStatusQuestion.
 783      *
 784      * @return the next question to be asked after those concerning
 785      * the keywords that may be used to select tests for the test run.
 786      * @see #getKeywordsFirstQuestion
 787      */
 788     protected Question getKeywordsSuccessorQuestion() {
 789         return getPriorStatusFirstQuestion();
 790     }
 791 
 792     @Override
 793     public boolean[] getPriorStatusValues() {
 794         PriorStatusParameters sParams = getPriorStatusParameters();
 795         return sParams == null ? null : sParams.getPriorStatusValues();
 796     }
 797 
 798     /**
 799      * Get the first question to be asked concerning whether tests should
 800      * be selected for execution according to their prior execution status.
 801      *
 802      * @return the first question to be asked concerning whether tests should
 803      * be selected for execution according to their prior execution status.
 804      * @see #getPriorStatusSuccessorQuestion
 805      */
 806     protected abstract Question getPriorStatusFirstQuestion();
 807 
 808     /**
 809      * Get the next question to be asked after those concerning
 810      * whether tests should be selected for execution according to their
 811      * prior execution status.
 812      * The default value is the result of getConcurrencyFirstQuestion
 813      *
 814      * @return the next question to be asked after those concerning
 815      * whether tests should be selected for execution according to their
 816      * prior execution status.
 817      * @see #getPriorStatusFirstQuestion
 818      */
 819     protected Question getPriorStatusSuccessorQuestion() {
 820         return getConcurrencyFirstQuestion();
 821     }
 822 
 823     @Override
 824     public int getConcurrency() {
 825         ConcurrencyParameters cParams = getConcurrencyParameters();
 826         return cParams == null ? 1 : cParams.getConcurrency();
 827     }
 828 
 829     /**
 830      * Get the first question concerning the number of tests that
 831      * may be run in parallel.
 832      *
 833      * @return the first question concerning the number of tests that
 834      * may be run in parallel.
 835      * @see #getConcurrencySuccessorQuestion
 836      */
 837     protected abstract Question getConcurrencyFirstQuestion();
 838 
 839     /**
 840      * Get the next question after those concerning the number
 841      * of tests that may be run in parallel.
 842      * The default is the result of getTimeoutFactorFirstQuestion
 843      *
 844      * @return the next question after those concerning the number
 845      * of tests that may be run in parallel.
 846      * @see #getConcurrencyFirstQuestion
 847      */
 848     protected Question getConcurrencySuccessorQuestion() {
 849         return getTimeoutFactorFirstQuestion();
 850     }
 851 
 852     @Override
 853     public float getTimeoutFactor() {
 854         TimeoutFactorParameters tParams = getTimeoutFactorParameters();
 855         return tParams == null ? 1 : tParams.getTimeoutFactor();
 856     }
 857 
 858     /**
 859      * Get the first question concerning the scale factor to
 860      * be applied to the standard timeout for each test.
 861      *
 862      * @return the first question concerning the scale factor to
 863      * be applied to the standard timeout for each test.
 864      * @see #getTimeoutFactorSuccessorQuestion
 865      */
 866     protected abstract Question getTimeoutFactorFirstQuestion();
 867 
 868     /**
 869      * Get the next question after those concerning the scale factor to
 870      * be applied to the standard timeout for each test.
 871      * The default is the result of getEpilogFirstQuestion
 872      *
 873      * @return the next question after those concerning the scale factor to
 874      * be applied to the standard timeout for each test.
 875      * @see #getTimeoutFactorFirstQuestion
 876      */
 877     protected Question getTimeoutFactorSuccessorQuestion() {
 878         return getEpilogFirstQuestion();
 879     }
 880 
 881     /**
 882      * Get the first question of the epilog, which should be asked after
 883      * all the other questions in the configuration interview have been asked.
 884      * The epilog should terminate in the standard way with a FinalQuestion.
 885      *
 886      * @return the first question of the epilog, which should be asked after
 887      * all the other questions in the configuration interview have been asked.
 888      */
 889     protected abstract Question getEpilogFirstQuestion();
 890 
 891     /**
 892      * Determine whether all the configuration values are valid, by
 893      * checking if the interview has been completed.
 894      * If so, the result will be true; if not, the result will be false,
 895      * and getErrorMessage will provide details about at least one of the
 896      * invalid values.
 897      *
 898      * @return true if and only if all the configuration values are valid
 899      * @see #getErrorMessage
 900      * @see #isFinishable
 901      */
 902     @Override
 903     public boolean isValid() {
 904         return isFinishable();
 905     }
 906 
 907     /**
 908      * If there is an error in any of the configuration values,
 909      * as indicated by isValid, this method will provide a detail
 910      * message about the first question for which there is a problem.
 911      *
 912      * @return a detail message about the first question with an invalid answer,
 913      * or null if none.
 914      * @see #isValid
 915      */
 916     @Override
 917     public String getErrorMessage() {
 918         Question[] path = getPath();
 919         Question lastQuestion = path[path.length - 1];
 920         if (lastQuestion instanceof FinalQuestion) {
 921             return null;
 922         } else if (lastQuestion instanceof ErrorQuestion) {
 923             return lastQuestion.getText();
 924         } else {
 925             String v = lastQuestion.getStringValue();
 926             return i18n.getString(&quot;ip.noAnswer&quot;,
 927                     lastQuestion.getSummary(), lastQuestion.getText(), lastQuestion.getTag(), Integer.valueOf(v == null ? 0 : 1), trim(v));
 928         }
 929     }
 930 
 931     private String trim(String text) {
 932         return text == null ? null
 933                 : text.length() &lt; 40 ? text
 934                 : text.substring(0, 37) + &quot;...&quot;;
 935     }
 936 
 937     /**
 938      * Get a filter which will filter tests according to the result
 939      * of getExcludeList(). If the result of getExcludeList is null
 940      * or an empty exclude list, the result of this method will also be null.
 941      *
 942      * @return a filter which will filter tests according to the result
 943      * of getExcludeList()
 944      * @see #getExcludeListFilter
 945      * @deprecated Use getExcludeListFilter().
 946      */
 947     @java.lang.Deprecated
 948     public TestFilter getExcludeTableFilter() {
 949         return getExcludeListFilter();
 950     }
 951 
 952     @Override
 953     public TestFilter getExcludeListFilter() {
 954         ExcludeList t = getExcludeList();
 955         if (t == null) {
 956             cachedExcludeListFilter = null;
 957         } else if (cachedExcludeListFilter == null
 958                 || cachedExcludeListFilter.getExcludeList() != t) {
 959             cachedExcludeListFilter = new ExcludeListFilter(t);
 960         }
 961         return cachedExcludeListFilter;
 962     }
 963 
 964     @Override
 965     public TestFilter getKeywordsFilter() {
 966         Keywords k = getKeywords();
 967         if (k == null) {
 968             cachedKeywordsFilter = null;
 969         } else if (cachedKeywordsFilter == null
 970                 || cachedKeywordsFilter.getKeywords() != k) {
 971             cachedKeywordsFilter = new KeywordsFilter(k);
 972         }
 973         return cachedKeywordsFilter;
 974     }
 975 
 976     @Override
 977     public TestFilter getPriorStatusFilter() {
 978         WorkDirectory wd = getWorkDirectory();
 979         TestResultTable r = wd == null ? null : wd.getTestResultTable();
 980         boolean[] s = getPriorStatusValues();
 981         if (r == null || s == null) {
 982             cachedStatusFilter = null;
 983         } else if (cachedStatusFilter == null
 984                 || cachedStatusFilter.getTestResultTable() != r
 985                 || !equal(cachedStatusFilter.getStatusValues(), s)) {
 986             cachedStatusFilter = new StatusFilter(s, r);
 987         }
 988         // else
 989         //   cachedStatusFilter is OK
 990 
 991         return cachedStatusFilter;
 992     }
 993 
 994     @Override
 995     public TestFilter getRelevantTestFilter() {
 996         TestSuite ts = getTestSuite();
 997         TestEnvironment env = getEnv();
 998         if (ts == null || env == null) {
 999             cachedRelevantTestFilter = null;
1000         } else if (cachedRelevantTestFilter == null ||
1001                 ts != cachedRelevantTestFilterTestSuite ||
1002                 env != cachedRelevantTestFilterEnv) {
1003             cachedRelevantTestFilter = ts.createTestFilter(env);
1004         }
1005         return cachedRelevantTestFilter;
1006     }
1007 
1008     @Override
1009     public synchronized TestFilter[] getFilters() {
1010         Vector&lt;TestFilter&gt; v = new Vector&lt;&gt;();
1011 
1012         TestFilter excludeFilter = getExcludeListFilter();
1013         if (excludeFilter != null) {
1014             v.add(excludeFilter);
1015         }
1016 
1017         TestFilter keywordFilter = getKeywordsFilter();
1018         if (keywordFilter != null) {
1019             v.add(keywordFilter);
1020         }
1021 
1022         TestFilter statusFilter = getPriorStatusFilter();
1023         if (statusFilter != null) {
1024             v.add(statusFilter);
1025         }
1026 
1027         TestFilter testSuiteFilter = null;
1028         try {
1029             testSuiteFilter = getRelevantTestFilter();
1030         } catch (Exception e) {
1031             testSuiteFilter = null;
1032         }
1033         if (testSuiteFilter != null) {
1034             v.add(testSuiteFilter);
1035         }
1036 
1037         if (v.isEmpty()) {
1038             return null;
1039         } else if (equal(v, cachedTestFilters)) {
1040             return cachedTestFilters;
1041         } else {
1042             return v.toArray(new TestFilter[v.size()]);
1043         }
1044 
1045     }
1046 
1047     /**
1048      * Determine if the current instance is a template or not.
1049      *
1050      * @return true if the current instance is a template,
1051      * and false otherwise
1052      */
1053     public boolean isTemplate() {
1054         return isTemplate;
1055     }
1056 
1057     /**
1058      * Set if the current instance is a template or not.
1059      * &lt;b&gt;For internal use only, architects should not use this.&lt;/b&gt;
1060      */
1061     public void setTemplate(boolean tm) {
1062         isTemplate = tm;
1063         updatePath();
1064     }
1065 
1066     protected boolean isAutoUpdatableKey(String key) {
1067         return isAutoUpdatableKey(key, null);
1068     }
1069 
1070     protected boolean isAutoUpdatableKey(String key, String subkey) {
1071         return false;
1072     }
1073 
1074     protected boolean isUpdatableKey(String key) {
1075         return true;
1076     }
1077 
1078     /**
1079      * Return String path to the template file for the current instance.
1080      * If the current instance is a template (isTemplate() returns true),
1081      * the path to itself will be returned.
1082      *
1083      * @return String path to the template file, or null if the instance is
1084      * not template-based
1085      */
1086     public String getTemplatePath() {
1087         if (isTemplate()) {
1088             File f = getFile();
1089             if (f != null) {
1090                 return f.getPath();
1091             }
1092         }
1093         return templatePath;
1094     }
1095 
1096     /**
1097      * Set the location of a configuration&#39;s master template.
1098      * Do not change this value if this instance is a template.
1099      */
1100     public void setTemplatePath(String tu) {
1101         templatePath = tu;
1102     }
1103 
1104     /**
1105      * Get the file associated with this interview.
1106      *
1107      * @return the file associated with this interview.
1108      * @see #setFile
1109      * @see #load
1110      * @see #save
1111      */
1112     public File getFile() {
1113         return currFile;
1114     }
1115 
1116     /**
1117      * Set the file associated with this interview. This file will be used
1118      * by subsequent load and save operations.
1119      *
1120      * @param f The file to be associated with this interview.
1121      * @see #getFile
1122      * @see #load
1123      * @see #save
1124      */
1125     public void setFile(File f) {
1126         currFile = f;
1127         currFileLoaded = false;
1128         if (f != null) {
1129             currFileLastModified = f.lastModified();
1130         } else {
1131             // means: unknown; will likely a trigger a reload
1132             currFileLastModified = 0;
1133         }
1134     }
1135 
1136     @Override
1137     public void clear() {
1138         WorkDirectory wd = getWorkDirectory();
1139         super.clear();
1140 
1141         if (wd != null &amp;&amp; TemplateUtilities.getTemplatePath(wd) != null) {
1142             if (wd.getTestSuite() != null) {
1143                 try {
1144                     wd.getTestSuite().loadInterviewFromTemplate(
1145                             TemplateUtilities.getTemplateFile(wd), this);
1146                 } catch (IOException ex) {
1147                     ex.printStackTrace();
1148                 }
1149             }
1150         }
1151         setEdited(false);
1152         currFile = null;
1153     }
1154 
1155     /**
1156      * Load the interview with the contents of the file associated with
1157      * the interview. If the file does not exist, the interview will be
1158      * cleared.
1159      *
1160      * @return true if there was an update from template
1161      * @throws IOException     is there is a problem reading the file
1162      * @throws Interview.Fault if there is a problem loading the
1163      *                         interview
1164      */
1165     public boolean load() throws IOException, Fault {
1166         File f = getFile();
1167         if (f != null &amp;&amp; f.exists()) {
1168             return load(f);
1169         } else {
1170             clear();
1171             setEdited(false);
1172             return false;
1173         }
1174     }
1175 
1176     /**
1177      * Load the interview with the contents of a specified file,
1178      * which will become the default file associated with the interview.
1179      *
1180      * @param file the file to be loaded
1181      * @return true if there was an update from template
1182      * @throws FileNotFoundException if the specified file does not exist.
1183      * @throws IOException           is there is a problem reading the file
1184      * @throws Interview.Fault       if there is a problem loading the
1185      *                               interview
1186      */
1187     public boolean load(File file) throws FileNotFoundException, IOException, Fault {
1188         try (InputStream in = new BufferedInputStream(new FileInputStream(file))) {
1189             Map&lt;String, String&gt; data = PropertyUtils.load(in);
1190             return load(data, file);
1191         }
1192     }
1193 
1194     /**
1195      * Load the interview with data that has already been read from a specified file,
1196      * which will become the default file associated with the interview.
1197      *
1198      * @param data the data to be loaded
1199      * @param file the file from which the data was read
1200      * @return true if there was an update from template
1201      * @throws Interview.Fault if there is a problem loading the interview
1202      */
1203     public boolean load(Map&lt;String, String&gt; data, File file) throws Fault {
1204         load(data);
1205 
1206         // restore template state
1207         String tm = data.get(IS_TEMPLATE);
1208         setTemplate(tm != null &amp;&amp; tm.equalsIgnoreCase(TRUE));
1209 
1210         setEdited(false);
1211         currFile = file;
1212         currFileLastModified = file.lastModified();
1213         currFileLoaded = true;
1214         return checkForUpdates();
1215     }
1216 
1217     /**
1218      * Returns true if there was update
1219      */
1220     public boolean checkForUpdates() {
1221         InterviewPropagator prop = new InterviewPropagator(this,
1222                 ignorableProps, ignorablePrefs);
1223         return prop.checkForUpdate();
1224     }
1225 
1226     @Override
1227     public void load(Map&lt;String, String&gt; data, boolean checkChecksum) throws Fault {
1228         super.load(data, checkChecksum);
1229 
1230         String me = data.get(MARKERS_ENABLED);
1231         setMarkersEnabled(me != null &amp;&amp; me.equalsIgnoreCase(TRUE));
1232 
1233         String mf = data.get(MARKERS_FILTER);
1234         setMarkersFilterEnabled(mf != null &amp;&amp; mf.equalsIgnoreCase(TRUE));
1235 
1236         String tm = data.get(IS_TEMPLATE);
1237         setTemplate(tm != null &amp;&amp; tm.equalsIgnoreCase(TRUE));
1238 
1239         String tu = null;
1240         //if (isTemplate()) {
1241         tu = data.get(TEMPLATE_PATH);
1242         //} else {
1243         //tu = (String) data.get(TEMPLATE_PREF + TEMPLATE_PATH);
1244         //}
1245         setTemplatePath(tu);
1246     }
1247 
1248     /**
1249      * Load the interview as best as possible with the data in another
1250      * Parameters object. If any of the various sub-objects as returned by
1251      * get&lt;i&gt;XXX&lt;/i&gt;Parameters are not recognized, they will be ignored.
1252      *
1253      * @param other The Parameters object to be copied.
1254      */
1255     public void load(Parameters other) {
1256         loadTestsParameters(other.getTestsParameters());
1257         loadExcludeListParameters(other.getExcludeListParameters());
1258         loadKeywordsParameters(other.getKeywordsParameters());
1259         loadPriorStatusParameters(other.getPriorStatusParameters());
1260         loadEnvParameters(other.getEnvParameters());
1261         loadConcurrencyParameters(other.getConcurrencyParameters());
1262         loadTimeoutFactorParameters(other.getTimeoutFactorParameters());
1263     }
1264 
1265     //----------------------------------------------------------------------------
1266 
1267     private void loadTestsParameters(TestsParameters other) {
1268         TestsParameters tp = getTestsParameters();
1269         if (!(tp instanceof MutableTestsParameters)) {
1270             return;
1271         }
1272 
1273         MutableTestsParameters mtp = (MutableTestsParameters) tp;
1274 
1275         if (other instanceof MutableTestsParameters) {
1276             MutableTestsParameters mop = (MutableTestsParameters) other;
1277             mtp.setTestsMode(mop.getTestsMode());
1278             mtp.setSpecifiedTests(mop.getSpecifiedTests());
1279         } else {
1280             String[] tests = other.getTests();
1281             if (tests == null) {
1282                 mtp.setTestsMode(MutableTestsParameters.ALL_TESTS);
1283                 mtp.setSpecifiedTests((String[]) null);
1284             } else {
1285                 mtp.setTestsMode(MutableTestsParameters.SPECIFIED_TESTS);
1286                 mtp.setSpecifiedTests(tests);
1287             }
1288         }
1289     }
1290 
1291     private void loadExcludeListParameters(ExcludeListParameters other) {
1292         ExcludeListParameters tp = getExcludeListParameters();
1293         if (!(tp instanceof MutableExcludeListParameters)) {
1294             return;
1295         }
1296 
1297         MutableExcludeListParameters mtp = (MutableExcludeListParameters) tp;
1298 
1299         if (other instanceof MutableExcludeListParameters) {
1300             MutableExcludeListParameters mop = (MutableExcludeListParameters) other;
1301             mtp.setExcludeMode(mop.getExcludeMode());
1302             mtp.setCustomExcludeFiles(mop.getCustomExcludeFiles());
1303             mtp.setLatestExcludeAutoCheckEnabled(mop.isLatestExcludeAutoCheckEnabled());
1304             mtp.setLatestExcludeAutoCheckMode(mop.getLatestExcludeAutoCheckMode());
1305             mtp.setLatestExcludeAutoCheckInterval(mop.getLatestExcludeAutoCheckInterval());
1306         } else {
1307             mtp.setExcludeMode(MutableExcludeListParameters.CUSTOM_EXCLUDE_LIST);
1308             mtp.setCustomExcludeFiles((File[]) null);
1309             mtp.setLatestExcludeAutoCheckEnabled(false);
1310             mtp.setLatestExcludeAutoCheckMode(MutableExcludeListParameters.CHECK_EVERY_X_DAYS);
1311             mtp.setLatestExcludeAutoCheckInterval(0);
1312         }
1313     }
1314 
1315     private void loadKeywordsParameters(KeywordsParameters other) {
1316         KeywordsParameters tp = getKeywordsParameters();
1317         if (!(tp instanceof MutableKeywordsParameters)) {
1318             return;
1319         }
1320 
1321         MutableKeywordsParameters mtp = (MutableKeywordsParameters) tp;
1322 
1323         if (other instanceof MutableKeywordsParameters) {
1324             MutableKeywordsParameters mop = (MutableKeywordsParameters) other;
1325             mtp.setKeywordsMode(mop.getKeywordsMode());
1326             mtp.setMatchKeywords(mop.getMatchKeywordsMode(), mop.getMatchKeywordsValue());
1327         } else {
1328             Keywords k = other.getKeywords();
1329             if (k == null) {
1330                 mtp.setKeywordsMode(MutableKeywordsParameters.NO_KEYWORDS);
1331                 mtp.setMatchKeywords(MutableKeywordsParameters.EXPR, &quot;&quot;);
1332             } else {
1333                 mtp.setKeywordsMode(MutableKeywordsParameters.MATCH_KEYWORDS);
1334                 mtp.setMatchKeywords(MutableKeywordsParameters.EXPR, k.toString());
1335             }
1336 
1337         }
1338     }
1339 
1340     private void loadPriorStatusParameters(PriorStatusParameters other) {
1341         PriorStatusParameters tp = getPriorStatusParameters();
1342         if (!(tp instanceof MutablePriorStatusParameters)) {
1343             return;
1344         }
1345 
1346         MutablePriorStatusParameters mtp = (MutablePriorStatusParameters) tp;
1347 
1348         if (other instanceof MutablePriorStatusParameters) {
1349             MutablePriorStatusParameters mop = (MutablePriorStatusParameters) other;
1350             mtp.setPriorStatusMode(mop.getPriorStatusMode());
1351             mtp.setMatchPriorStatusValues(mop.getMatchPriorStatusValues());
1352         } else {
1353             boolean[] b = other.getPriorStatusValues();
1354             if (b == null) {
1355                 mtp.setPriorStatusMode(MutablePriorStatusParameters.NO_PRIOR_STATUS);
1356                 mtp.setMatchPriorStatusValues(new boolean[Status.NUM_STATES]);
1357             } else {
1358                 mtp.setPriorStatusMode(MutablePriorStatusParameters.MATCH_PRIOR_STATUS);
1359                 mtp.setMatchPriorStatusValues(b);
1360             }
1361         }
1362     }
1363 
1364     private void loadEnvParameters(EnvParameters other) {
1365         EnvParameters tp = getEnvParameters();
1366         if (!(tp instanceof LegacyEnvParameters)) {
1367             return;
1368         }
1369 
1370         LegacyEnvParameters ltp = (LegacyEnvParameters) tp;
1371 
1372         if (other instanceof LegacyEnvParameters) {
1373             LegacyEnvParameters lop = (LegacyEnvParameters) other;
1374             ltp.setEnvFiles(lop.getEnvFiles());
1375             ltp.setEnvName(lop.getEnvName());
1376         }
1377     }
1378 
1379     private void loadConcurrencyParameters(ConcurrencyParameters other) {
1380         ConcurrencyParameters tp = getConcurrencyParameters();
1381         if (!(tp instanceof MutableConcurrencyParameters)) {
1382             return;
1383         }
1384 
1385         MutableConcurrencyParameters mtp = (MutableConcurrencyParameters) tp;
1386         mtp.setConcurrency(other.getConcurrency());
1387     }
1388 
1389     private void loadTimeoutFactorParameters(TimeoutFactorParameters other) {
1390         TimeoutFactorParameters tp = getTimeoutFactorParameters();
1391         if (!(tp instanceof MutableTimeoutFactorParameters)) {
1392             return;
1393         }
1394 
1395         MutableTimeoutFactorParameters mtp = (MutableTimeoutFactorParameters) tp;
1396         mtp.setTimeoutFactor(other.getTimeoutFactor());
1397     }
1398 
1399     /**
1400      * Save the current set of answers for the interview in the standard
1401      * file associated with the interview.
1402      *
1403      * @throws IOException     is there is a problem writing the file
1404      * @throws Interview.Fault if there is a problem preparing the
1405      *                         interview to be written
1406      * @see #getFile
1407      */
1408     public void save() throws IOException, Fault {
1409         File f = getFile();
1410         if (f == null) {
1411             throw new IllegalStateException();
1412         }
1413         save(f);
1414     }
1415 
1416     /**
1417      * Save the current state of the interview in a specified file,
1418      * and make that file the new file associated with the interview.
1419      *
1420      * @param file the file in which to save the state of the interview
1421      * @throws IOException     is there is a problem writing the file
1422      * @throws Interview.Fault if there is a problem preparing the
1423      *                         interview to be written
1424      * @see #getFile
1425      */
1426     public void save(File file) throws IOException, Fault {
1427         save(file, false);
1428     }
1429 
1430     /**
1431      * Save the current state of the interview in a specified file,
1432      * and make that file the new file associated with the interview.
1433      *
1434      * @param file       the file in which to save the state of the interview
1435      * @param isTemplate
1436      * @throws IOException     is there is a problem writing the file
1437      * @throws Interview.Fault if there is a problem preparing the
1438      *                         interview to be written
1439      * @see #getFile
1440      */
1441     public void save(File file, boolean isTemplate) throws IOException, Fault {
1442         saveAs(file, true, true, isTemplate);
1443 
1444         setEdited(false);
1445         currFile = file;
1446         currFileLastModified = file.lastModified();
1447         currFileLoaded = true;
1448     }
1449 
1450     /**
1451      * Save the current state of the interview in a specified file,
1452      * including the paths for the test suite and work directory.
1453      *
1454      * @param file the file in which to save the state of the interview
1455      * @throws IOException     is there is a problem writing the file
1456      * @throws Interview.Fault if there is a problem preparing the
1457      *                         interview to be written
1458      */
1459     public void saveAs(File file)
1460             throws IOException, Fault {
1461         saveAs(file, true, true);
1462     }
1463 
1464     /**
1465      * Save the current state of the interview in a specified file.
1466      * If the test suite path is not saved, the file can only be used
1467      * as a configuration template.
1468      *
1469      * @param file          the file in which to save the state of the interview
1470      * @param saveTestSuite if true, the test suite path will be saved
1471      *                      in the file.
1472      * @param saveWorkDir   if true, the work directory path will be saved
1473      *                      in the file.
1474      * @param isTemplate    True, the interview will be saved as template.
1475      * @throws IOException     is there is a problem writing the file
1476      * @throws Interview.Fault if there is a problem preparing the
1477      *                         interview to be written
1478      */
1479     public void saveAs(File file, boolean saveTestSuite, boolean saveWorkDir, boolean isTemplate)
1480             throws IOException, Fault {
1481         SortedMap&lt;String, String&gt; data = new TreeMap&lt;&gt;();
1482         setTemplate(isTemplate);        // dubious, why do we need to do this?
1483 
1484         if (saveTestSuite) {
1485             TestSuite ts = getTestSuite();
1486             if (ts != null) {
1487                 data.put(TESTSUITE, ts.getPath());
1488             }
1489         }
1490 
1491         if (saveWorkDir) {
1492             WorkDirectory wd = getWorkDirectory();
1493             if (wd != null) {
1494                 data.put(WORKDIR, wd.getPath());
1495             }
1496         }
1497 
1498         save(data);
1499 
1500         if (this.isTemplate == true) {
1501             TemplateManager tm = this.templateManager;
1502             if (tm != null &amp;&amp; !tm.canSaveTemplate(file)) {
1503                 throw new Interview.Fault(i18n, &quot;ip.badTmplPath&quot;);
1504             }
1505         }
1506 
1507         OutputStream out;
1508         if (backupPolicy == null) {
1509             out = new BufferedOutputStream(new FileOutputStream(file));
1510         } else {
1511             out = backupPolicy.backupAndOpenStream(file);
1512         }
1513 
1514         try {
1515             PropertyUtils.store(data, out, &quot;JT Harness Configuration Interview&quot;);
1516         } finally {
1517             out.close();
1518         }
1519     }
1520 
1521     /**
1522      * Save the current state of the interview in a specified file.
1523      * If the test suite path is not saved, the file can only be used
1524      * as a configuration template.
1525      *
1526      * @param file          the file in which to save the state of the interview
1527      * @param saveTestSuite if true, the test suite path will be saved
1528      *                      in the file.
1529      * @param saveWorkDir   if true, the work directory path will be saved
1530      *                      in the file.
1531      * @throws IOException     is there is a problem writing the file
1532      * @throws Interview.Fault if there is a problem preparing the
1533      *                         interview to be written
1534      */
1535     public void saveAs(File file, boolean saveTestSuite, boolean saveWorkDir)
1536             throws IOException, Fault {
1537         saveAs(file, saveTestSuite, saveWorkDir, false);
1538     }
1539 
1540     @Override
1541     public void save(Map&lt;String, String&gt; data) {
1542         if (markersEnabled) {
1543             data.put(MARKERS_ENABLED, TRUE);
1544         }
1545 
1546         if (markersFilterEnabled) {
1547             data.put(MARKERS_FILTER, TRUE);
1548         }
1549 
1550         if (isTemplate()) {
1551             data.put(IS_TEMPLATE, TRUE);
1552 
1553             storeTemplateProperties(new HashMap&lt;&gt;());
1554         } else {
1555             WorkDirectory wd = getWorkDirectory();
1556             if (wd != null &amp;&amp; TemplateUtilities.getTemplatePath(wd) != null) {
1557                 data.put(TEMPLATE_PATH, TemplateUtilities.getTemplatePath(wd));
1558             }
1559         }
1560 
1561         String name = getName();
1562         if (name != null) {
1563             data.put(NAME, name);
1564         }
1565 
1566         String desc = getDescription();
1567         if (desc != null) {
1568             data.put(DESC, desc);
1569         }
1570 
1571 
1572         super.save(data);
1573     }
1574 
1575     /**
1576      * Get the backup policy to be used when saving configuration files.
1577      *
1578      * @return the backup policy object to be used when saving configuration files
1579      * @see #setBackupPolicy
1580      */
1581     public BackupPolicy getBackupPolicy() {
1582         return backupPolicy;
1583     }
1584 
1585     /**
1586      * Set the backup policy to be used when saving configuration files.
1587      *
1588      * @param backupPolicy the backup policy object to be used when saving configuration files
1589      * @see #getBackupPolicy
1590      */
1591     public void setBackupPolicy(BackupPolicy backupPolicy) {
1592         this.backupPolicy = backupPolicy;
1593     }
1594 
1595     /**
1596      * Check if the current file has been loaded into this interview,
1597      * or if the interview has been saved in it.
1598      *
1599      * @return true if the file associated with the interview was set as a
1600      * side effect of load or save, or false if the file was just set by
1601      * setFile.
1602      */
1603     public boolean isFileLoaded() {
1604         return currFileLoaded;
1605     }
1606 
1607     /**
1608      * Determine if the file associated with this interview has been modified
1609      * on disk after the last call of load or save.
1610      *
1611      * @return true if the file on disk has been modified after it was last
1612      * used by load or save.
1613      * @see #load()
1614      * @see #save()
1615      */
1616     public boolean isFileNewer() {
1617         File f = getFile();
1618         return f != null &amp;&amp; f.exists() &amp;&amp; ((currFileLastModified == 0)
1619                 || (f.lastModified() &gt; currFileLastModified));
1620     }
1621 
1622     /**
1623      * Check whether or not markers should be enabled.
1624      *
1625      * @return whether or not markers should be enabled
1626      * @see #setMarkersEnabled
1627      */
1628     public boolean getMarkersEnabled() {
1629         return markersEnabled;
1630     }
1631 
1632     /**
1633      * Specify whether or not markers should be enabled.
1634      *
1635      * @param on whether or not markers should be enabled
1636      * @see #getMarkersEnabled
1637      */
1638     public void setMarkersEnabled(boolean on) {
1639         if (on != markersEnabled) {
1640             markersEnabled = on;
1641             setEdited(true);
1642         }
1643     }
1644 
1645     /**
1646      * Check whether or not the history list should be filtered to
1647      * just show questions which have been marked.
1648      *
1649      * @return whether or not the  history list should be filtered to
1650      * just show questions which have been marked
1651      * @see #setMarkersFilterEnabled
1652      */
1653     public boolean getMarkersFilterEnabled() {
1654         return markersFilterEnabled;
1655     }
1656 
1657     /**
1658      * Specify whether or not the history list should be filtered to
1659      * just show questions which have been marked.
1660      *
1661      * @param on whether or not the  history list should be filtered to
1662      *           just show questions which have been marked
1663      * @see #getMarkersFilterEnabled
1664      */
1665     public void setMarkersFilterEnabled(boolean on) {
1666         if (on != markersFilterEnabled) {
1667             markersFilterEnabled = on;
1668             setEdited(true);
1669         }
1670     }
1671     /**
1672      * The template manager is used to change behavior of
1673      * template saving, the default implementation is
1674      * the context manager of corresponding test suite.
1675      */
1676     public interface TemplateManager {
1677         /**
1678          * This method is invoked each time before saving template.
1679          * The template will be saved only if this method returns true.
1680          *
1681          * @param file template file
1682          * @return true if this operation is allowed, false otherwise
1683          */
1684         boolean canSaveTemplate(File file);
1685     }
1686 
1687     /**
1688      * Indicates problems when accessing the work directory.
1689      */
1690     public static class WorkDirFault extends Interview.Fault {
1691         /**
1692          * Create a fault with an internationalized message.
1693          *
1694          * @param i18n The bundle from which to get the string.
1695          * @param s    The key for getting the string to be displayed from the
1696          *             supplied bundle.
1697          */
1698         public WorkDirFault(ResourceBundle i18n, String s) {
1699             super(i18n, s);
1700         }
1701 
1702         /**
1703          * Create a fault with an internationalized message.
1704          *
1705          * @param i18n The bundle from which to get the string.
1706          * @param s    The key for getting the string to be displayed from the
1707          *             supplied bundle.
1708          * @param o    Parameter to use when resolving the string from the bundle.
1709          * @see java.text.MessageFormat
1710          */
1711         public WorkDirFault(ResourceBundle i18n, String s, Object o) {
1712             super(i18n, s, o);
1713         }
1714 
1715         /**
1716          * Create a fault with an internationalized message.
1717          *
1718          * @param i18n The bundle from which to get the string.
1719          * @param s    The key for getting the string to be displayed from the
1720          *             supplied bundle.
1721          * @param o    Parameters to use when resolving the string from the bundle.
1722          * @see java.text.MessageFormat
1723          */
1724         public WorkDirFault(ResourceBundle i18n, String s, Object... o) {
1725             super(i18n, s, o);
1726         }
1727     }
1728 
1729     /**
1730      * Indicates problems when accessing the test suite.
1731      */
1732     public static class TestSuiteFault extends Interview.Fault {
1733         /**
1734          * Create a fault with an internationalized message.
1735          *
1736          * @param i18n The bundle from which to get the string.
1737          * @param s    The key for getting the string to be displayed from the
1738          *             supplied bundle.
1739          */
1740         public TestSuiteFault(ResourceBundle i18n, String s) {
1741             super(i18n, s);
1742         }
1743 
1744         /**
1745          * Create a fault with an internationalized message.
1746          *
1747          * @param i18n The bundle from which to get the string.
1748          * @param s    The key for getting the string to be displayed from the
1749          *             supplied bundle.
1750          * @param o    Parameter to use when resolving the string from the bundle.
1751          * @see java.text.MessageFormat
1752          */
1753         public TestSuiteFault(ResourceBundle i18n, String s, Object o) {
1754             super(i18n, s, o);
1755         }
1756 
1757         /**
1758          * Create a fault with an internationalized message.
1759          *
1760          * @param i18n The bundle from which to get the string.
1761          * @param s    The key for getting the string to be displayed from the
1762          *             supplied bundle.
1763          * @param o    Parameters to use when resolving the string from the bundle.
1764          * @see java.text.MessageFormat
1765          */
1766         public TestSuiteFault(ResourceBundle i18n, String s, Object... o) {
1767             super(i18n, s, o);
1768         }
1769     }
1770 
1771     /**
1772      * Indicates problems when accessing the configuration file.
1773      */
1774     public static class JTIFault extends Interview.Fault {
1775         /**
1776          * Create a fault with an internationalized message.
1777          *
1778          * @param i18n The bundle from which to get the string.
1779          * @param s    The key for getting the string to be displayed from the
1780          *             supplied bundle.
1781          */
1782         public JTIFault(ResourceBundle i18n, String s) {
1783             super(i18n, s);
1784         }
1785 
1786         /**
1787          * Create a fault with an internationalized message.
1788          *
1789          * @param i18n The bundle from which to get the string.
1790          * @param s    The key for getting the string to be displayed from the
1791          *             supplied bundle.
1792          * @param o    Parameter to use when resolving the string from the bundle.
1793          * @see java.text.MessageFormat
1794          */
1795         public JTIFault(ResourceBundle i18n, String s, Object o) {
1796             super(i18n, s, o);
1797         }
1798 
1799         /**
1800          * Create a fault with an internationalized message.
1801          *
1802          * @param i18n The bundle from which to get the string.
1803          * @param s    The key for getting the string to be displayed from the
1804          *             supplied bundle.
1805          * @param o    Parameters to use when resolving the string from the bundle.
1806          * @see java.text.MessageFormat
1807          */
1808         public JTIFault(ResourceBundle i18n, String s, Object... o) {
1809             super(i18n, s, o);
1810         }
1811     }
1812 }
    </pre>
  </body>
</html>
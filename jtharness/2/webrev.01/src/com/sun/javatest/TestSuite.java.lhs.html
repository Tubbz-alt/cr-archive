<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/com/sun/javatest/TestSuite.java</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * $Id$
   3  *
   4  * Copyright (c) 1996, 2012, Oracle and/or its affiliates. All rights reserved.
   5  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   6  *
   7  * This code is free software; you can redistribute it and/or modify it
   8  * under the terms of the GNU General Public License version 2 only, as
   9  * published by the Free Software Foundation.  Oracle designates this
  10  * particular file as subject to the &quot;Classpath&quot; exception as provided
  11  * by Oracle in the LICENSE file that accompanied this code.
  12  *
  13  * This code is distributed in the hope that it will be useful, but WITHOUT
  14  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  15  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  16  * version 2 for more details (a copy is included in the LICENSE file that
  17  * accompanied this code).
  18  *
  19  * You should have received a copy of the GNU General Public License version
  20  * 2 along with this work; if not, write to the Free Software Foundation,
  21  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  22  *
  23  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  24  * or visit www.oracle.com if you need additional information or have any
  25  * questions.
  26  */
  27 package com.sun.javatest;
  28 
  29 import com.sun.javatest.finder.BinaryTestFinder;
  30 import com.sun.javatest.finder.HTMLTestFinder;
  31 import com.sun.javatest.finder.TestFinderDecorator;
  32 import com.sun.javatest.interview.LegacyParameters;
  33 import com.sun.javatest.lib.KeywordScript;
  34 import com.sun.javatest.logging.ObservedFile;
  35 import com.sun.javatest.logging.WorkDirLogHandler;
  36 import com.sun.javatest.services.PropertyServiceReader;
  37 import com.sun.javatest.services.ServiceManager;
  38 import com.sun.javatest.services.ServiceReader;
  39 import com.sun.javatest.util.BackupPolicy;
  40 import com.sun.javatest.util.I18NResourceBundle;
  41 import com.sun.javatest.util.PropertyUtils;
  42 import com.sun.javatest.util.StringArray;
  43 
  44 import java.io.BufferedInputStream;
  45 import java.io.File;
  46 import java.io.FileInputStream;
  47 import java.io.FileNotFoundException;
  48 import java.io.IOException;
  49 import java.io.InputStream;
  50 import java.lang.ref.WeakReference;
  51 import java.lang.reflect.InvocationTargetException;
  52 import java.lang.reflect.Method;
  53 import java.lang.reflect.Modifier;
  54 import java.net.MalformedURLException;
  55 import java.net.URL;
  56 import java.net.URLClassLoader;
<a name="1" id="anc1"></a>

  57 import java.util.HashMap;
  58 import java.util.Iterator;
<a name="2" id="anc2"></a>
  59 import java.util.Map;
  60 import java.util.Vector;
  61 import java.util.logging.Handler;
  62 import java.util.logging.Level;
  63 import java.util.logging.LogRecord;
  64 import java.util.logging.Logger;
  65 
  66 /**
  67  * A class providing information about and access to the tests in a test suite.
  68  * The primary methods to access and run the tests are
  69  * &lt;ul&gt;
  70  * &lt;li&gt;{@link TestSuite#createTestFinder createTestFinder }
  71  * &lt;li&gt;{@link TestSuite#createTestFilter createTestFilter }
  72  * &lt;li&gt;{@link TestSuite#createScript createScript }
  73  * &lt;/ul&gt;
  74  */
  75 public class TestSuite {
  76     /**
  77      * Should tests which no longer exist in the test suite be
  78      * deleted from a work directory when it is opened?
  79      */
  80     public static final int DELETE_NONTEST_RESULTS = 0;
  81     /*
  82      * Should the content of the test suite be refreshed as the
  83      * tests run?  So the test description should be updated from the
  84      * finder just before the test runs.
  85      */
  86     public static final int REFRESH_ON_RUN = 1;
  87     /**
  88      * Should a test be reset to not run if it is found that the
  89      * test has changed in the test suite (test description does
  90      * not match the one in the existing result).
  91      */
  92     public static final int CLEAR_CHANGED_TEST = 2;
  93     public static final String TM_CONTEXT_NAME = &quot;tmcontext&quot;;
  94     private static final String TESTSUITE_HTML = &quot;testsuite.html&quot;;
  95     private static final String TESTSUITE_JTT = &quot;testsuite.jtt&quot;;
  96     private static final String FIND_LEGACY_CONSTRUCTOR = &quot;com.sun.javatest.ts.findLegacyCtor&quot;;
  97     static Map&lt;String, WorkDirLogHandler&gt; handlersMap = new HashMap&lt;&gt;();
  98 
  99     /**
 100      * Disposed of the shared TestSuite object for this test suite.  Use
 101      * the value from {@code TestSuite.getRoot()} as the value for
 102      * canonRoot.  Using this is only desired when disposal of the shared
 103      * TestSuite object is not desired - traditionally, it is not disposed
 104      * and is reused if the test suite is reopened.
 105      * @param canonRoot Canonical root of the test suite.
 106      * @see TestSuite#getRoot
 107      * @return The object which is about to be discarded.  Null if it was not
 108      *         not cached here.
 109      */
 110     /*
 111     public static TestSuite close(File canonRoot) {
 112         WeakReference ref = (WeakReference)(dirMap.remove(canonRoot));
 113         if (ref != null) {
 114             TestSuite ts = (TestSuite)(ref.get());
 115             if (ts != null) {
 116                 return ts;
 117             }
 118         }
 119 
 120         return null;
 121     }
 122      */
 123     private static Map&lt;File, WeakReference&lt;TestSuite&gt;&gt; dirMap = new HashMap&lt;&gt;(2);
 124     private static I18NResourceBundle i18n = I18NResourceBundle.getBundleForClass(TestSuite.class);
 125     private static String notificationLogName = i18n.getString(&quot;notification.logname&quot;);
 126     private static Vector&lt;GeneralPurposeLogger&gt; gpls;
 127     private static Map&lt;String, File&gt; observedFiles;
 128     private final NotificationLogger notifLogger = new NotificationLogger(null);
 129     private File root;
 130     private Map&lt;String, String&gt; tsInfo;
 131     private ClassLoader loader;
 132     private TestFinder finder;
 133     // the following are used by the default impl of createScript
 134     private Class&lt;? extends Script&gt; scriptClass;
 135     private String[] scriptArgs;
 136     private String[] keywords;
 137     private ServiceReader serviceReader;
 138     private ServiceManager serviceManager;
 139 
 140     /**
 141      * Create a TestSuite object.
 142      *
 143      * @param root   The root file for this test suite.
 144      * @param tsInfo Test suite properties, typically read from the test suite properties file
 145      *               in the root directory of the test suite.
 146      * @param cl     A class loader to be used to load additional classes as required,
 147      *               typically using a class path defined in the test suite properties file.
 148      */
 149     public TestSuite(File root, Map&lt;String, String&gt; tsInfo, ClassLoader cl) {
 150         this.root = root;
 151         this.tsInfo = tsInfo;
 152         this.loader = cl;
 153 
 154         String kw = tsInfo == null ? null : tsInfo.get(&quot;keywords&quot;);
 155         keywords = kw == null ? null : StringArray.split(kw);
 156     }
 157 
 158     /**
 159      * Create a TestSuite object, with no additional test suite properties and no
 160      * class loader.
 161      *
 162      * @param root The root file for this test suite.
 163      */
 164     public TestSuite(File root) {
 165         this.root = root;
 166     }
 167 
 168     /**
 169      * Check if a file is the root of a valid test suite. A valid test suite is identified
 170      * either by the root directory of the test suite, or by the file testsuite.html within
 171      * that directory. The directory must contain either a test suite properties file
 172      * (testsuite.jtt) or, for backwards compatibility, a file named testsuite.html.
 173      *
 174      * @param root The file to be checked.
 175      * @return true if and only if &lt;em&gt;root&lt;/em&gt; is the root of a valid test suite.
 176      */
 177     public static boolean isTestSuite(File root) {
 178         //System.err.println(&quot;TestSuite.isTestSuite: &quot; + root);
 179         File dir;
 180         if (root.isDirectory()) {
 181             dir = root;
 182         } else {
 183             if (root.getName().equalsIgnoreCase(TESTSUITE_HTML)) {
 184                 dir = root.getParentFile();
 185             } else {
 186                 return false;
 187             }
 188         }
 189         File jtt = new File(dir, TESTSUITE_JTT);
 190         File parentDir = dir.getParentFile();
 191         File parent_jtt = parentDir == null ? null : new File(parentDir, TESTSUITE_JTT);
 192         File html = new File(dir, TESTSUITE_HTML);
 193         return isReadableFile(jtt)
 194                 || isReadableFile(html) &amp;&amp; (parent_jtt == null || !parent_jtt.exists());
 195     }
 196 
 197     /**
 198      * Open a test suite.
 199      *
 200      * @param root A file identifying the root of the test suite.
 201      * @return A TestSuite object for the test suite in question. The actual type of the result
 202      * will depend on the test suite properties found in the root directory of the test suite.
 203      * @throws FileNotFoundException       if &lt;em&gt;root&lt;/em&gt; does not exist.
 204      * @throws TestSuite.NotTestSuiteFault if &lt;em&gt;root&lt;/em&gt; does not identify a valid test suite.
 205      * @throws TestSuite.Fault             if any other problems occur while trying to open the test suite.
 206      * @see #isTestSuite
 207      */
 208     public static TestSuite open(File root) throws FileNotFoundException, Fault, NotTestSuiteFault {
 209         if (!root.exists()) {
 210             throw new FileNotFoundException(root.getPath());
 211         }
 212 
 213         File canonRoot;
 214         try {
 215             canonRoot = root.getCanonicalFile();
 216         } catch (IOException e) {
 217             throw new Fault(i18n, &quot;ts.cantCanonicalize&quot;,
 218                     root.getPath(), e.toString());
 219         }
 220 
 221         File canonRootDir;
 222         if (canonRoot.isDirectory()) {
 223             canonRootDir = canonRoot;
 224         } else {
 225             if (canonRoot.getName().equalsIgnoreCase(TESTSUITE_HTML)) {
 226                 canonRootDir = canonRoot.getParentFile();
 227             } else {
 228                 throw new NotTestSuiteFault(i18n, &quot;ts.notTestSuiteFile&quot;, canonRoot);
 229             }
 230         }
 231 
 232         File f = new File(canonRootDir, TESTSUITE_JTT);
 233         if (isReadableFile(f)) {
 234             try (InputStream in = new BufferedInputStream(new FileInputStream(f))) {
 235                 Map&lt;String, String&gt; p = PropertyUtils.load(in);
 236                 return open(canonRoot, p);
 237             } catch (IOException e) {
 238                 throw new Fault(i18n, &quot;ts.cantReadTestSuiteFile&quot;, e.toString());
 239             }
 240         } else {
 241             // check for old style test suite
 242             File ts_html = new File(canonRootDir, TESTSUITE_HTML);
 243             File parentDir = canonRootDir.getParentFile();
 244             File parent_jtt = parentDir == null ? null : new File(parentDir, TESTSUITE_JTT);
 245             if (isReadableFile(ts_html) &amp;&amp; (parent_jtt == null || !parent_jtt.exists())) {
 246                 return open(canonRoot, new HashMap&lt;&gt;());
 247             } else {
 248                 throw new NotTestSuiteFault(i18n, &quot;ts.notTestSuiteFile&quot;, canonRoot);
 249             }
 250         }
 251     }
 252 
 253     /**
 254      * Open a test suite.
 255      *
 256      * @param root   A file identifying the root of the test suite.
 257      * @param tsInfo Test Suite properties read from the test suite properties file.
 258      * @return A TestSuite object for the test suite in question.
 259      * @throws TestSuite.Fault if any problems occur while opening the test suite
 260      */
 261     private static TestSuite open(File root, Map&lt;String, String&gt; tsInfo) throws Fault {
 262         synchronized (dirMap) {
 263             TestSuite ts;
 264 
 265             // if this test suite has already been opened, return that
 266             WeakReference&lt;TestSuite&gt; ref = dirMap.get(root);
 267             if (ref != null) {
 268                 ts = ref.get();
 269                 if (ts != null) {
 270                     return ts;
 271                 }
 272             }
 273 
 274             // otherwise, open it for real
 275             ts = open0(root, tsInfo);
 276 
 277             // save reference in case opened again
 278             dirMap.put(root, new WeakReference&lt;&gt;(ts));
 279             return ts;
 280         }
 281     }
 282 
 283     private static TestSuite open0(File root, Map&lt;String, String&gt; tsInfo) throws Fault {
 284         String[] classPath = StringArray.split(tsInfo.get(&quot;classpath&quot;));
 285 
 286         ClassLoader cl;
 287         if (classPath.length == 0) {
 288             cl = null;
 289         } else {
 290             try {
 291                 File rootDir = root.isDirectory() ? root : root.getParentFile();
 292                 URL[] p = new URL[classPath.length];
 293                 for (int i = 0; i &lt; classPath.length; i++) {
 294                     String cpi = classPath[i];
 295                     if (cpi.toLowerCase().startsWith(&quot;http:&quot;)) {
 296                         p[i] = new URL(cpi);
 297                     } else {
 298                         File f = new File(cpi);
 299                         if (!f.isAbsolute()) {
 300                             f = new File(rootDir, cpi);
 301                         }
 302                         p[i] = f.toURI().toURL();
 303                     }
 304                 }
 305                 cl = new URLClassLoader(p, TestSuite.class.getClassLoader());
 306             } catch (MalformedURLException e) {
 307                 throw new Fault(i18n, &quot;ts.badClassPath&quot;,
 308                         root, e.getMessage());
 309             }
 310         }
 311 
 312         String[] tsClassAndArgs = StringArray.split(tsInfo.get(&quot;testsuite&quot;));
 313 
 314         TestSuite testSuite;
 315         if (tsClassAndArgs.length == 0) {
 316             testSuite = new TestSuite(root, tsInfo, cl);
 317         } else {
 318             String className = tsClassAndArgs[0];
 319 
 320             try {
 321                 Class&lt;? extends TestSuite&gt; c = loadClass(className, cl);
 322                 Class&lt;?&gt;[] tsArgTypes = {File.class, Map.class, ClassLoader.class};
 323                 Object[] tsArgs = {root, tsInfo, cl};
 324                 testSuite = newInstance(c, tsArgTypes, tsArgs);
 325             } catch (ClassCastException e) {
 326                 throw new Fault(i18n, &quot;ts.notASubtype&quot;,
 327                         className, &quot;testsuite&quot;, TestSuite.class.getName());
 328             } catch (UnsupportedClassVersionError uce) {
 329                 throw new Fault(i18n, &quot;ts.compiledRecentVersion&quot;,
 330                         System.getProperty(&quot;java.version&quot;), root.getPath());
 331             }
 332 
 333             String[] args = new String[tsClassAndArgs.length - 1];
 334             System.arraycopy(tsClassAndArgs, 1, args, 0, args.length);
 335             testSuite.init(args);
 336         }
 337 
 338         // initialize test finder
 339         testSuite.setTestFinder(new TestFinderDecorator(testSuite.createTestFinder()));
 340 
 341         return testSuite;
 342     }
 343 
 344     private static String[] envLookup(TestEnvironment env, String name) throws Fault {
 345         try {
 346             return env.lookup(name);
 347         } catch (TestEnvironment.Fault e) {
 348             throw new Fault(i18n, &quot;ts.cantFindNameInEnv&quot;,
 349                     name, e.getMessage());
 350         }
 351     }
 352 
 353     /**
 354      * Create a new instance of a class, translating any exceptions that may arise
 355      * into Fault.
 356      *
 357      * @param c the class to be instantiated
 358      * @return an instance of the specified class
 359      * @throws TestSuite.Fault if any errors arise while trying to instantiate
 360      *                         the class.
 361      */
 362     protected static &lt;T&gt; T newInstance(Class&lt;? extends T&gt; c) throws Fault {
 363         try {
 364             return c.getDeclaredConstructor().newInstance();
 365         } catch (InstantiationException | NoSuchMethodException | InvocationTargetException e) {
 366             throw new Fault(i18n, &quot;ts.cantInstantiate&quot;,
 367                     c.getName(), e);
 368         } catch (IllegalAccessException e) {
 369             throw new Fault(i18n, &quot;ts.illegalAccess&quot;,
 370                     c.getName(), e);
 371         }
 372     }
 373 
 374     /**
 375      * Create a new instance of a class using a non-default constructor,
 376      * translating any exceptions that may arise into Fault.
 377      *
 378      * @param c        the class to be instantiated
 379      * @param argTypes the types of the argument to be passed to the constructor,
 380      *                 (thus implying the constructor to be used.)
 381      * @param args     the arguments to be passed to the constructor
 382      * @return an instance of the specified class
 383      * @throws TestSuite.Fault if any errors arise while trying to instantiate
 384      *                         the class.
 385      */
 386     protected static &lt;T&gt; T newInstance(Class&lt;? extends T&gt; c, Class&lt;?&gt;[] argTypes, Object... args)
 387             throws Fault {
 388         try {
 389             return c.getConstructor(argTypes).newInstance(args);
 390         } catch (IllegalAccessException e) {
 391             throw new Fault(i18n, &quot;ts.illegalAccess&quot;,
 392                     c.getName(), e);
 393         } catch (InstantiationException e) {
 394             throw new Fault(i18n, &quot;ts.cantInstantiate&quot;,
 395                     c.getName(), e);
 396         } catch (InvocationTargetException e) {
 397             Throwable te = e.getTargetException();
 398             if (te instanceof Fault) {
 399                 throw (Fault) te;
 400             } else {
 401                 throw new Fault(i18n, &quot;ts.cantInit&quot;, c.getName(), te);
 402             }
 403         } catch (NoSuchMethodException e) {
 404             // don&#39;t recurse past the use of a single arg constructor
 405             if (argTypes.length &gt; 1 &amp;&amp; Boolean.getBoolean(FIND_LEGACY_CONSTRUCTOR)) {
 406                 return newInstance(c, new Class&lt;?&gt;[]{File.class}, args[0]);
 407             }
 408 
 409             throw new Fault(i18n, &quot;ts.cantFindConstructor&quot;,
 410                     c.getName(), e);
 411         }
 412     }
 413 
 414     /**
 415      * Load a class using a specified loader, translating any errors that may arise
 416      * into Fault.
 417      *
 418      * @param className the name of the class to be loaded
 419      * @param cl        the class loader to use to load the specified class
 420      * @return the class that was loaded
 421      * @throws TestSuite.Fault if there was a problem loading the specified class
 422      */
 423     protected static &lt;T&gt; Class&lt;? extends T&gt; loadClass(String className, ClassLoader cl) throws Fault {
 424         try {
 425             if (cl == null) {
 426                 return (Class&lt;? extends T&gt;) Class.forName(className);
 427             } else {
 428                 return (Class&lt;? extends T&gt;) cl.loadClass(className);
 429             }
 430         } catch (ClassNotFoundException e) {
 431             throw new Fault(i18n, &quot;ts.classNotFound&quot;,
 432                     className, e);
 433         } catch (IllegalArgumentException e) {
 434             throw new Fault(i18n, &quot;ts.badClassName&quot;,
 435                     new Object[]{className});
 436         }
 437     }
 438 
 439     private static boolean isReadableFile(File f) {
 440         return f.exists() &amp;&amp; f.isFile() &amp;&amp; f.canRead();
 441     }
 442 
 443     /**
 444      * Initialize this test suite, with args typically read from a .jtt file.
 445      * The default implementation does not recognize any arguments and always
 446      * throws an exception.
 447      *
 448      * @param args an array of strings to initialize this test suite object
 449      * @throws TestSuite.Fault if there are any problems initializing the
 450      *                         test suite from the specified arguments.
 451      */
 452     protected void init(String... args) throws Fault {
 453         if (args.length &gt; 0) {
 454             throw new Fault(i18n, &quot;ts.badArgs&quot;, args[0]);
 455         }
 456         // should be a decodeArgs loop
 457     }
 458 
 459     /**
 460      * Get the path for the root file of this test suite.
 461      *
 462      * @return the path for the root file of this test suite.
 463      */
 464     public String getPath() {
 465         return root.getPath();
 466     }
 467 
 468     /**
 469      * Get the root file of this test suite.
 470      *
 471      * @return the root file of this test suite.
 472      */
 473     public File getRoot() {
 474         return root;
 475     }
 476 
 477     /**
 478      * Get the root directory of this test suite. If the root file is itself a directory,
 479      * the result will be that directory; otherwise, the result will be the parent directory
 480      * of the root file.
 481      *
 482      * @return the root directory of this test suite.
 483      */
 484     public File getRootDir() {
 485         return root.isDirectory() ? root : new File(root.getParent());
 486     }
 487 
 488     /**
 489      * Get the directory in the test suite that contains the tests.
 490      * By default, the following are checked:
 491      * &lt;ol&gt;
 492      * &lt;li&gt;The {@code tests} property in the test suite properties file.
 493      * If this entry is found, it must either identify an absolute filename, or
 494      * a directory relative to the test suite root directory, using &#39;/&#39; to
 495      * separate the components of the path.
 496      * &lt;li&gt;If the file &lt;em&gt;root&lt;/em&gt;{@code /tests/testsuite.html} exists,
 497      * the result is the directory &lt;em&gt;root&lt;/em&gt;{@code /tests}. This is
 498      * for compatibility with standard TCK layout.
 499      * &lt;li&gt;Otherwise, the result is the root directory of the test suite.
 500      * &lt;/ol&gt;
 501      *
 502      * @return the directory that contains the tests
 503      */
 504     public File getTestsDir() {
 505         String t = tsInfo == null ? null : tsInfo.get(&quot;tests&quot;);
 506         if (t == null || t.isEmpty()) {
 507             File rootDir = getRootDir();
 508             File testsDir = new File(rootDir, &quot;tests&quot;);
 509             if (testsDir.isDirectory()) {
 510                 // if the tests directory exists, and there is no overriding
 511                 // testsuite.jtt entry, assume the tests dir is &quot;tests/&quot;.
 512                 return testsDir;
 513             }
 514             // default
 515             return rootDir;
 516         } else {
 517             File f = new File(t);
 518             if (f.isAbsolute()) {
 519                 return f;
 520             } else {
 521                 return new File(getRootDir(), t.replace(&#39;/&#39;, File.separatorChar));
 522             }
 523         }
 524     }
 525 
 526     /**
 527      * A notification method that is called when a test suite run is starting.
 528      * The method may be used to do any test suite specific initialization.
 529      * If overriding this method, be sure to call the superclass&#39; method.  It is
 530      * fairly typical to register as a harness observer inside this method.  Note
 531      * that if an exception occurs during this method, it will be caught by the
 532      * harness and reported as a Harness.Observer.error().  It is recommended
 533      * that any implementations of this method register as an observer immediately
 534      * so that they can catch this error and do any cleanup to abort the
 535      * test suite startup sequence (check if services were started and close them
 536      * down, etc).
 537      *
 538      * @param harness The harness that will be used to run the tests.
 539      * @throws TestSuite.Fault if an error occurred while doing test suite-specific
 540      *                         initialization that should cause the test run to be aborted.
 541      */
 542     public void starting(Harness harness) throws Fault {
 543         if (getServiceManager() != null) {
 544             serviceManager.setHarness(harness);
 545         }
 546     }
 547 
 548     /**
 549      * Create a test suite specific filter to be used to filter the tests
 550      * to be selected for a test run.
 551      * The method should return null if no test suite specific filtering is required.
 552      * The default is to return null.
 553      *
 554      * @param filterEnv Configuration data that may be used by the filter.
 555      * @return a test suite filter, or null if no test suite specific filter is
 556      * required for this test suite.
<a name="3" id="anc3"></a>



 557      */
<a name="4" id="anc4"></a>
 558     public TestFilter createTestFilter(TestEnvironment filterEnv) {
 559         return null;
 560     }
 561 
<a name="5" id="anc5"></a>












 562     /**
 563      * Get a shared test finder to read the tests in this test suite.
 564      *
 565      * @return a test finder to read the tests in this test suite
 566      * @see #createTestFinder
 567      * @see #setTestFinder
 568      */
 569     public TestFinder getTestFinder() {
 570         return finder;
 571     }
 572 
 573     /**
 574      * Set the shared test finder used to read the tests in this test suite.
 575      * Only one test finder may be set; attempts to change the test finder will
 576      * cause IllegalStateException to be thrown.
 577      * This method is normally called by TestSuite.open to initialize the
 578      * finder to the result of calling createTestFinder.
 579      *
 580      * @param tf the test finder to be used
 581      * @throws IllegalStateException if the test finder has previously
 582      *                               been set to a different value
 583      * @see #getTestFinder
 584      */
 585     protected void setTestFinder(TestFinder tf) {
 586         if (tf == null) {
 587             throw new NullPointerException();
 588         }
 589 
 590         if (finder != null &amp;&amp; finder != tf) {
 591             throw new IllegalStateException();
 592         }
 593 
 594         finder = tf;
 595     }
 596 
 597     /**
 598      * Create a test finder to be used to access the tests in this test suite.
 599      * The default implementation looks for a {@code finder} entry in the
 600      * test suite properties file, which should identify the class to be used
 601      * and any arguments it may require. The class will be loaded via the class
 602      * loader specified when the test suite was opened, if one was given;
 603      * otherwise, the system class loader will be used.
 604      * &lt;p&gt;
 605      * The default implementation attempts to use a file testsuite.jtd
 606      * in the tests directory.  If found, a BinaryTestFinder will be created
 607      * using this file.  If it is not found, then it searches for a property
 608      * named finder in the test suite properties and will attempt to
 609      * instantiate that.  If no entry is found or it is blank, an
 610      * HTMLTestFinder is used, using whatever a basic settings HTMLTestFinder
 611      * initializes to.
 612      *
 613      * @return a test finder to be used to read the tests in the test suite
 614      * @throws TestSuite.Fault if there is a problem creating the test finder
 615      * @see #getTestFinder
 616      * @see #setTestFinder
 617      * @see #getTestsDir
 618      */
 619     protected TestFinder createTestFinder() throws Fault {
 620         File testsDir = getTestsDir();
 621 
 622         // no BTF file; look for a finder=class args... entry
 623         String[] finderCmd = StringArray.split(tsInfo.get(&quot;finder&quot;));
 624         String finderClassName;
 625         String[] finderArgs = new String[0];
 626 
 627         if (finderCmd == null || finderCmd.length == 0) {
 628             //finderCmd = new String[] {HTMLTestFinder.class.getName()};
 629             finderCmd = null;   // ensure null for later use
 630             finderClassName = HTMLTestFinder.class.getName();
 631         } else {
 632             finderClassName = finderCmd[0];
 633 
 634             if (finderCmd.length &gt; 1) {
 635                 finderArgs = new String[finderCmd.length - 1];
 636                 System.arraycopy(finderCmd, 1, finderArgs, 0, finderArgs.length);
 637             } else {
 638                 // finderArgs should remain empty array
 639             }
 640         }
 641 
 642         // first, try looking for testsuite.jtd
 643         String jtd = tsInfo.get(&quot;testsuite.jtd&quot;);
 644         File jtdFile = jtd == null ? new File(testsDir, &quot;testsuite.jtd&quot;) : new File(root, jtd);
 645         if (jtdFile.exists()) {
 646             try {
 647                 // found a file for BinaryTestFinder
 648                 // only pass the finder class if it was not defaulted to HTMLTestFinder
 649                 return createBinaryTestFinder(finderCmd == null ? null : finderClassName,
 650                         finderArgs, testsDir, jtdFile);
 651             } catch (Fault e) {
 652                 // ignore, try to continue with normal finder
 653             }
 654         }
 655 
 656         try {
 657             Class&lt;? extends TestFinder&gt; c = loadClass(finderClassName);
 658             TestFinder tf = newInstance(c);
 659             // called old deprecated entry till we know no-one cares
 660             //tf.init(finderArgs, testsRoot, null, null, tsInfo/*pass in env?*/);
 661             // this likely kills ExpandTestFinder, finally
 662             tf.init(finderArgs, testsDir, null, null, null/*pass in env?*/);
 663             return tf;
 664         } catch (ClassCastException e) {
 665             throw new Fault(i18n, &quot;ts.notASubtype&quot;,
 666                     finderClassName, &quot;finder&quot;, TestFinder.class.getName());
 667         } catch (TestFinder.Fault e) {
 668             throw new Fault(i18n, &quot;ts.errorInitFinder&quot;,
 669                     finderClassName, e.getMessage());
 670         }
 671     }
 672 
 673     /**
 674      * In the case where a JTD file is found, attempt to load a binary test finder.
 675      * The default implementation attempts to use the finder property in the
 676      * test suite properties if it is a BinaryTestFinder subclass.
 677      *
 678      * @param finderClassName Finder class name to attempt to use as a BTF.  Null if
 679      *                        the default BTF class should be used.
 680      * @param finderArgs      Arguments to finder given from the test suite property.
 681      * @param testsDir        Reference location to pass to finder.
 682      * @param jtdFile         Location of the JTD file to give to the BTF.
 683      * @return The binary test finder which was created.
 684      * @throws com.sun.javatest.TestSuite.Fault
 685      * @see com.sun.javatest.TestFinder
 686      * @see com.sun.javatest.finder.BinaryTestFinder
 687      */
 688     protected TestFinder createBinaryTestFinder(String finderClassName,
 689                                                 String finderArgs[], File testsDir, File jtdFile) throws Fault {
 690         try {
 691             TestFinder tf = null;
 692 
 693             if (finderClassName != null) {
 694                 Class&lt;? extends TestFinder&gt; c = loadClass(finderClassName);
 695                 tf = newInstance(c);
 696             }
 697 
 698             if (tf instanceof BinaryTestFinder) {
 699                 tf.init(finderArgs, testsDir, null, null, null);
 700                 return tf;
 701             } else {
 702                 return new BinaryTestFinder(testsDir, jtdFile);
 703             }
 704         } catch (ClassCastException e) {
 705             throw new Fault(i18n, &quot;ts.notASubtype&quot;,
 706                     finderClassName, &quot;finder&quot;, TestFinder.class.getName());
 707         } catch (TestFinder.Fault e) {
 708             throw new Fault(i18n, &quot;ts.errorInitFinder&quot;,
 709                     finderClassName, e.getMessage());
 710         }
 711 
 712     }
 713 
 714     /**
 715      * Create and initialize a TestRunner that can be used to run
 716      * a series of tests.
 717      * The default implementation returns a TestRunner that
 718      * creates a number of test execution threads which each
 719      * create and run a script for each test obtained from
 720      * the test runners iterator.
 721      *
 722      * @return a TestRunner that can be used to run a series of tests
 723      */
 724     public TestRunner createTestRunner() {
 725         return new DefaultTestRunner();
 726     }
 727 
 728     /**
 729      * Create and initialize a Script that can be used to run a test.
 730      * The default implementation looks for a {@code script} entry in the configuration
 731      * data provided, and if not found, looks for a {@code script} entry in the
 732      * test suite properties. The script entry should define the script class
 733      * to use and any arguments it may require. The class will be loaded via the class
 734      * loader specified when the test suite was opened, if one was given;
 735      * otherwise, the system class loader will be used. Individual test suites will
 736      * typically use a more direct means to create an appropriate script object.
 737      * The parameters for this method are normally passed through to the script
 738      * that is created.
 739      * &lt;p&gt;
 740      * Note that the name of this method is &quot;create&quot;, it is not recommended
 741      * that the value returned ever be re-used or cached for subsequent requests
 742      * to this method.
 743      *
 744      * @param td            The test description for the test to be executed.
 745      * @param exclTestCases Any test cases within the test that should not be executed.
 746      * @param scriptEnv     Configuration data to be given to the test as necessary.
 747      * @param workDir       A work directory in which to store the results of the test.
 748      * @param backupPolicy  A policy object used to control how to backup any files that
 749      *                      might be overwritten.
 750      * @return a script to be used to execute the given test
 751      * @throws TestSuite.Fault if any errors occur while creating the script
 752      */
 753     public Script createScript(TestDescription td, String[] exclTestCases, TestEnvironment scriptEnv,
 754                                WorkDirectory workDir,
 755                                BackupPolicy backupPolicy) throws Fault {
 756         if (scriptClass == null) {
 757             String[] script = envLookup(scriptEnv, &quot;script&quot;);
 758             if (script.length == 0) {
 759                 script = StringArray.split(tsInfo.get(&quot;script&quot;));
 760             }
 761             if (script.length &gt; 0) {
 762                 scriptClass = loadClass(script[0]);
 763                 if (!Script.class.isAssignableFrom(scriptClass)) {
 764                     throw new Fault(i18n, &quot;ts.notASubtype&quot;,
 765                             script[0], &quot;script&quot;, Script.class.getName());
 766                 }
 767                 scriptArgs = new String[script.length - 1];
 768                 System.arraycopy(script, 1, scriptArgs, 0, scriptArgs.length);
 769             } else {
 770                 // for backwards compatibility,
 771                 // see if KeywordScript is a reasonable default
 772                 boolean keywordScriptOK = false;
 773                 for (Iterator&lt;String&gt; i = scriptEnv.keys().iterator(); i.hasNext() &amp;&amp; !keywordScriptOK; ) {
 774                     String key = i.next();
 775                     keywordScriptOK = key.startsWith(&quot;script.&quot;);
 776                 }
 777                 if (keywordScriptOK) {
 778                     scriptClass = KeywordScript.class;
 779                     scriptArgs = new String[]{};
 780                 } else {
 781                     throw new Fault(i18n, &quot;ts.noScript&quot;);
 782                 }
 783             }
 784         }
 785 
 786         Script s = newInstance(scriptClass);
 787         s.initArgs(scriptArgs);
 788         s.initTestDescription(td);
 789         s.initExcludedTestCases(exclTestCases);
 790         s.initTestEnvironment(scriptEnv);
 791         s.initWorkDir(workDir);
 792         s.initBackupPolicy(backupPolicy);
 793         s.initClassLoader(loader);
 794         return s;
 795     }
 796 
 797     /**
 798      * Create a configuration interview that can be used to collection the configuration
 799      * data for a test run.
 800      * &lt;p&gt;The default implementation returns a {@link LegacyParameters default}
 801      * interview suitable for use with test suites built with earlier versions
 802      * of the JT Harness: it provides questions equivalent to the fields in
 803      * the GUI Parameter Editor or command-line -params option. As such, much of the
 804      * necessary configuration data is provided indirectly via environment (.jte) files
 805      * which must be created and updated separately.
 806      * &lt;p&gt;Individual test suites should provide their own interview, with questions
 807      * customized to the configuration data they require.
 808      * &lt;p&gt;
 809      * Note that the name of this method is &quot;create&quot;, the harness may instantiate
 810      * multiple copies for temporary use, resetting data or transferring data.
 811      * Do not override this method with an implementation which caches the
 812      * return value.
 813      *
 814      * @return A configuration interview to collect the configuration data for a test run.
 815      * @throws TestSuite.Fault if a problem occurs while creating the interview
 816      */
 817     public InterviewParameters createInterview()
 818             throws Fault {
 819         String[] classNameAndArgs = StringArray.split(tsInfo.get(&quot;interview&quot;));
 820         if (classNameAndArgs == null || classNameAndArgs.length == 0) {
 821             try {
 822                 return new LegacyParameters(this);
 823             } catch (InterviewParameters.Fault e) {
 824                 throw new Fault(i18n, &quot;ts.errorInitDefaultInterview&quot;,
 825                         e.getMessage());
 826             }
 827         }
 828 
 829 
 830         String className = classNameAndArgs[0];
 831         String[] args = new String[classNameAndArgs.length - 1];
 832         System.arraycopy(classNameAndArgs, 1, args, 0, args.length);
 833 
 834         try {
 835             Class&lt;? extends InterviewParameters&gt; c = loadClass(className);
 836             InterviewParameters p = newInstance(c);
 837             p.init(args);
 838             p.setTestSuite(this);
 839             return p;
 840         } catch (ClassCastException e) {
 841             throw new Fault(i18n, &quot;ts.notASubtype&quot;,
 842                     className, &quot;interview&quot;, InterviewParameters.class.getName());
 843         } catch (InterviewParameters.Fault e) {
 844             //e.printStackTrace();
 845             throw new Fault(i18n, &quot;ts.errorInitInterview&quot;,
 846                     className, e.getMessage());
 847         }
 848 
 849     }
 850 
 851     /**
 852      * Create a configuration interview based on specified map of template values
 853      *
 854      * @return A configuration interview to collect the configuration data for a test run.
 855      */
 856     public InterviewParameters loadInterviewFromTemplate(Map&lt;String, String&gt; templateInfo, InterviewParameters newInterview) {
 857         newInterview.storeTemplateProperties(templateInfo);
 858         newInterview.propagateTemplateForAll();
 859         return newInterview;
 860     }
 861 
 862     /**
 863      * Create a configuration interview based on specified template file
 864      *
 865      * @return A configuration interview to collect the configuration data for a test run.
 866      * null if specified file is not template
 867      */
 868     public InterviewParameters loadInterviewFromTemplate(File template,
 869                                                          InterviewParameters ip)
 870             throws IOException {
 871         try (InputStream in = new BufferedInputStream(new FileInputStream(template))) {
 872             Map&lt;String, String&gt; stringProps = PropertyUtils.load(in);
 873             String tm = stringProps.get(InterviewParameters.IS_TEMPLATE);
 874             if (InterviewParameters.TRUE.equals(tm)) {
 875                 stringProps.put(InterviewParameters.TEMPLATE_PATH,
 876                         template.getAbsolutePath());
 877                 ip.setTemplatePath(template.getAbsolutePath());
 878                 return loadInterviewFromTemplate(stringProps, ip);
 879             } else {
 880                 // XXX should probably return ip
 881                 //     or throw Fault
 882                 return null;
 883             }
 884         }
 885     }
 886 
 887     /**
 888      * Get a string containing a unique ID identifying this test suite,
 889      * or null if not available.  The default is taken from the &quot;id&quot; entry
 890      * in the .jtt file.
 891      *
 892      * @return a unique ID identifying the test suite, or null if not specified.
 893      * @see #getName
 894      */
 895     public String getID() {
 896         return tsInfo == null ? null : tsInfo.get(&quot;id&quot;);
 897     }
 898 
 899     /**
 900      * Get a string identifying this test suite, or null if not available.
 901      * The default is taken from the &quot;name&quot; entry in the .jtt file.
 902      * This string is for presentation to the user, and may be localized
 903      * if appropriate.
 904      *
 905      * @return a string identifying the test suite, or null if not specified.
 906      * @see #getID
 907      */
 908     public String getName() {
 909         return tsInfo == null ? null : tsInfo.get(&quot;name&quot;);
 910     }
 911 
 912     /**
 913      * Get the estimated number of tests in the test suite.
 914      * The default is to use the value of the &quot;testCount&quot; property from the
 915      * testsuite.jtt file.
 916      *
 917      * @return The estimated number of tests, or -1 if this number is not available.
 918      */
 919     public int getEstimatedTestCount() {
 920         try {
 921             if (tsInfo != null) {
 922                 String s = tsInfo.get(&quot;testCount&quot;);
 923                 if (s != null) {
 924                     return Integer.parseInt(s);
 925                 }
 926             }
 927         } catch (NumberFormatException e) {
 928             // ignore
 929         }
 930         return -1; // unknown
 931     }
 932 
 933     /**
 934      * Get the file name of the initial exclude list associated with the test suite.
 935      * The default is to use the value of the &quot;initial.jtx&quot; property from the
 936      * testsuite.jtt file. If the value is a relative filename, it will be made absolute
 937      * by evaluating it relative to the test suite root directory.
 938      *
 939      * @return the name of the default exclude list, or null if none specified.
 940      */
 941     public File getInitialExcludeList() {
 942         String s = tsInfo == null ? null : tsInfo.get(&quot;initial.jtx&quot;);
 943         if (s == null) {
 944             return null;
 945         }
 946 
 947         File f = new File(s.replace(&#39;/&#39;, File.separatorChar));
 948         if (!f.isAbsolute()) {
 949             f = new File(getRootDir(), f.getPath());
 950         }
 951         return f;
 952     }
 953 
 954     /**
 955      * Check if the test suite has an initial exclude list.
 956      * The default is to use getInitialExcludeList, and if that returns
 957      * a non-null result, check whether that file exists or not.
 958      *
 959      * @return true if the test suite has an initial exclude list,
 960      * and false otherwise
 961      */
 962     public boolean hasInitialExcludeList() {
 963         File f = getInitialExcludeList();
 964         return f == null ? false : f.exists();
 965     }
 966 
 967     /**
 968      * Get the URL for the latest exclude list associated with the test suite.
 969      * The default is to use the value of the &quot;latest.jtx&quot; property from the
 970      * testsuite.jtt file., which (if present) must be a fully qualified URL
 971      * identifying the latest exclude list for this test suite.
 972      *
 973      * @return the name of the latest exclude list, or null if none specified.
 974      */
 975     public URL getLatestExcludeList() {
 976         try {
 977             String s = tsInfo == null ? null : tsInfo.get(&quot;latest.jtx&quot;);
 978             return s == null ? null : new URL(s);
 979         } catch (MalformedURLException e) {
 980             // ignore
 981             return null;
 982         }
 983     }
 984 
 985     /**
 986      * Check if the test suite has a latest exclude list.
 987      * The default is to use getLatestExcludeList, and to
 988      * check whether that return a non-null result. The URL is not
 989      * itself checked for validity.
 990      *
 991      * @return true if the test suite has a latest exclude list,
 992      * and false otherwise
 993      */
 994     public boolean hasLatestExcludeList() {
 995         URL u = getLatestExcludeList();
 996         return u != null;
 997     }
 998 
 999     /**
1000      * Get the names of any helpsets containing related documents for this
1001      * test suite. The names should identify JavaHelp helpset files, as
1002      * used by javax.help.HelpSet.findHelpSet(ClassLoader, String).
1003      * Thus the names should identify resources of helpsets on the classpath.
1004      * This means you will typically need to put the directory or jar file
1005      * containing the help set on the classpath as well.
1006      * By default, the names will be looked up under the name &quot;additionalDocs&quot;
1007      * in the testsuite.jtt file.
1008      *
1009      * @return an array of names identifying helpsets that contain related
1010      * documents for this testsuite. The result may be null if there are no
1011      * such documents.
1012      */
1013     public String[] getAdditionalDocNames() {
1014         return tsInfo == null
1015                 ? null
1016                 : StringArray.split(tsInfo.get(&quot;additionalDocs&quot;));
1017     }
1018 
1019     /**
1020      * Get the set of valid keywords for this test suite.
1021      * By default, the keywords will be looked up under the name &quot;keywords&quot;
1022      * in the testsuite.jtt file.
1023      *
1024      * @return the set of valid keywords for this test suite, or null
1025      * if not known.
1026      */
1027     public String[] getKeywords() {
1028         return keywords;
1029     }
1030 
1031     /**
1032      * Get a list of associated files for a specified test description.
1033      * Normally, this will include the file containing the test description,
1034      * and any source files used by the test.  By default, the source files
1035      * are determined from the test description&#39;s &quot;source&quot; entry.
1036      *
1037      * @param td The test description for which the associated files are required
1038      * @return a list of associated files for this test description
1039      * @see TestDescription#getSourceURLs()
1040      */
1041     public URL[] getFilesForTest(TestDescription td) {
1042         return td.getSourceURLs();
1043     }
1044 
1045     /**
1046      * This method should be overridden in subclasses
1047      *
1048      * @param path String, which determines path to currently selected test&#39;s folder.
1049      *             This is root relative path. This shouldn&#39;t be null, for the
1050      *             root folder use &quot;&quot;.
1051      * @return array of files with documentation for test&#39;s folder, determined by path.
1052      * null means there no documentation for this folder
1053      */
1054     public URL[] getDocsForFolder(String path) {
1055         return null;
1056     }
1057 
1058     /**
1059      * This method should be overridden in subclasses
1060      *
1061      * @param td TestDescription for currently selected test case. This shouldn&#39;t be null.
1062      * @return array of files with documentation for test case, determined td.
1063      * null means there no documentation for this test case
1064      */
1065     public URL[] getDocsForTest(TestDescription td) {
1066         return null;
1067     }
1068 
1069     /**
1070      * Get A URL identifying a logo for this test suite, or null if none available.
1071      *
1072      * @return a URL for a logo for the testsuite, or null if not available
1073      */
1074     public URL getLogo() {
1075         try {
1076             String s = tsInfo == null ? null : tsInfo.get(&quot;logo&quot;);
1077             return s == null ? null : new URL(getRootDir().toURL(), s);
1078         } catch (MalformedURLException e) {
1079             // ignore
1080             return null;
1081         }
1082     }
1083 
1084     /**
1085      * Load a class using the class loader provided when this test suite was created.
1086      *
1087      * @param className the name of the class to be loaded
1088      * @return the class that was loaded
1089      * @throws TestSuite.Fault if there was a problem loading the specified class
1090      */
1091     public &lt;T&gt; Class&lt;? extends T&gt; loadClass(String className) throws Fault {
1092         return loadClass(className, loader);
1093     }
1094 
1095     /**
1096      * Get the class loader specified when this test suite object was created.
1097      *
1098      * @return the class loader specified when this test suite object was created
1099      */
1100     public ClassLoader getClassLoader() {
1101         return loader;
1102     }
1103 
1104     public ServiceManager getServiceManager() {
1105         if (!needServices()) {
1106             return null;
1107         }
1108 
1109         if (serviceManager == null) {
1110             serviceManager = new ServiceManager(this);
1111         }
1112 
1113         return serviceManager;
1114     }
1115 
1116     /**
1117      * Checks if serviceReader is active and file with service description does
1118      * exist.
1119      *
1120      * @return true, if it&#39;s needed to start services, false otherwise.
1121      */
1122     public boolean needServices() {
1123         ServiceReader sr = getServiceReader();
1124         if (sr == null) {
1125             return false;
1126         }
1127 
1128         /*
1129          * Since jt4.5 the ServiceReader has been extended with a new method.
1130          * To preserve ability to use new javatest with old test suites
1131          * the extra check is performed: check if the newly introduced method
1132          * is abstract or not.
1133          */
1134         boolean isLegacy = false;
1135         try {
1136             Method m = sr.getClass().getMethod(&quot;getServiceDescriptorFileName&quot;);
1137             if (Modifier.isAbstract(m.getModifiers())) {
1138                 isLegacy = true;
1139             }
1140         } catch (NoSuchMethodException e) {
1141             isLegacy = true;
1142         }
1143         File descrFile = isLegacy ?
1144                 new File(getRootDir(), File.separator + &quot;lib&quot; + File.separator + &quot;services.xml&quot;) :
1145                 new File(getRootDir(), sr.getServiceDescriptorFileName());
1146 
1147         return descrFile.exists();
1148     }
1149 
1150     /**
1151      * Returns a test suite specific ServiceReader, used to read Service
1152      * definitions.
1153      *
1154      * @return ServiceReader instance. Default is PropertyServiceReader
1155      */
1156     public ServiceReader getServiceReader() {
1157         if (serviceReader != null) {
1158             return serviceReader;
1159         }
1160 
1161         String servInfo = tsInfo.get(&quot;serviceReader&quot;);
1162         if (servInfo != null) {
1163             String[] args = servInfo.split(&quot; &quot;);
1164             try {
1165                 Class&lt;? extends ServiceReader&gt; c = loadClass(args[0]);
1166                 serviceReader = newInstance(c);
1167                 if (args.length &gt; 1) {
1168                     // problem with java1.5, which has no Arrays.copyOfRange();
1169                     String[] copy = new String[args.length - 1];
1170                     for (int i = 1; i &lt; args.length; i++) {
1171                         copy[i - 1] = args[i];
1172                     }
1173 
1174                     serviceReader.init(this, copy);
1175                 } else {
1176                     serviceReader.init(this, (String[]) null);
1177                 }
1178             } catch (TestSuite.Fault e) {
1179             }
1180         } else {
1181             serviceReader = new PropertyServiceReader();
1182             serviceReader.init(this, (String[]) null);
1183         }
1184 
1185         return serviceReader;
1186     }
1187 
1188     /**
1189      * Get a map containing the test suite data in the .jtt file.
1190      *
1191      * @return a map containing the test suite data in the .jtt file
1192      */
1193     protected Map&lt;String, String&gt; getTestSuiteInfo() {
1194         return tsInfo;
1195     }
1196 
1197     /**
1198      * Get an entry from the data in the .jtt file.
1199      *
1200      * @param name The name of the entry to get from the info in the .jtt file
1201      * @return the value of the specified entry, or null if not found.
1202      */
1203     public String getTestSuiteInfo(String name) {
1204         if (tsInfo == null) {
1205             return null;
1206         } else {
1207             return tsInfo.get(name);
1208         }
1209     }
1210 
1211     /**
1212      * Get the requested behavior for dealing with conflicts between
1213      * which tests are in the test suite vs those in the work directory.
1214      *
1215      * @see #DELETE_NONTEST_RESULTS
1216      * @see #REFRESH_ON_RUN
1217      * @see #CLEAR_CHANGED_TEST
1218      */
1219     public boolean getTestRefreshBehavior(int event) {
1220         switch (event) {
1221             case DELETE_NONTEST_RESULTS:
1222                 return Boolean.valueOf(getTestSuiteInfo(&quot;deleteNonExistTests&quot;)).booleanValue();
1223             case REFRESH_ON_RUN:
1224                 return Boolean.valueOf(getTestSuiteInfo(&quot;refreshTestsOnRun&quot;)).booleanValue();
1225             case CLEAR_CHANGED_TEST:
1226                 return Boolean.valueOf(getTestSuiteInfo(&quot;clearChangedTests&quot;)).booleanValue();
1227             default:
1228                 return false;
1229         }
1230     }
1231 
1232     /**
1233      * Returns notification logger associated with
1234      * given working directory or common logger if null was specified
1235      *
1236      * @param wd - working directory or null
1237      */
1238     public Logger getNotificationLog(WorkDirectory wd) {
1239         return notifLogger;
1240     }
1241 
1242     public ObservedFile getObservedFile(WorkDirectory wd) {
1243         return getObservedFile(wd.getLogFileName());
1244     }
1245 
1246     public ObservedFile getObservedFile(String path) {
1247         String cPath = new File(path).getAbsolutePath();
1248         if (observedFiles.containsKey(cPath)) {
1249             return (ObservedFile) observedFiles.get(cPath);
1250         }
1251         return null;
1252     }
1253 
1254     void setLogFilePath(WorkDirectory wd) {
1255         ObservedFile f = new ObservedFile(wd.getLogFileName());
1256         if (f.length() != 0) {
1257             f.backup();
1258         }
1259         // return to current
1260         f = new ObservedFile(wd.getLogFileName());
1261 
1262         if (observedFiles == null) {
1263             observedFiles = new HashMap&lt;&gt;();
1264         }
1265         if (!observedFiles.containsKey(f.getAbsolutePath())) {
1266             observedFiles.put(f.getAbsolutePath(), f);
1267         }
1268 
1269     }
1270 
1271     /**
1272      * Creates general purpose logger with given key and ResourceBundleName registered for given WorkDirectory.
1273      *
1274      * @param wd  WorkDirectory logger should be registered for; may be {@code null} if no WorkDirectory
1275      *            currently available (the log will be registered for the first WD created for this TestSuite
1276      * @param b   name of ResorceBundle used for this logger; may be {@code null} if not required
1277      * @param key key for this log
1278      * @return general purpose logger with given key registered for given WorkDirectory or TestSuite (if WD is null)
1279      * @throws TestSuite.DuplicateLogNameFault if log with this key has been registered in the system already
1280      * @see #getLog
1281      */
1282 
1283     public Logger createLog(WorkDirectory wd, String b, String key) throws DuplicateLogNameFault {
1284 
1285         if (key == null || key.isEmpty()) {
1286             throw new IllegalArgumentException(&quot;Log name can not be empty&quot;);
1287         }
1288 
1289         String logName = wd.getLogFileName();
1290 
1291         if (gpls == null) {
1292             gpls = new Vector&lt;&gt;();
1293         }
1294 
1295         for (GeneralPurposeLogger gpl : gpls) {
1296             if (gpl.getName().equals(key) &amp;&amp; gpl.getLogFileName().equals(logName)) {
1297                 throw new DuplicateLogNameFault(i18n, &quot;ts.logger.duplicatelognamefault&quot;, key);
1298             }
1299         }
1300 
1301         GeneralPurposeLogger gpl = new GeneralPurposeLogger(key, wd, b, this);
1302         gpls.add(gpl);
1303         return gpl;
1304     }
1305 
1306     /**
1307      * Returns general purpose logger with given key registered for given WorkDirectory.
1308      * The log should be created first.
1309      *
1310      * @param wd  WorkDirectory desired logger is registered for
1311      * @param key key for this log
1312      * @return general purpose logger with given key registered for given WorkDirectory
1313      * @throws TestSuite.NoSuchLogFault if desired log not registered in the system
1314      * @throws NullPointerException     if {@code wd} is null
1315      * @see #createLog
1316      */
1317     public Logger getLog(WorkDirectory wd, String key) throws NoSuchLogFault {
1318         if (gpls == null) {
1319             throw new NoSuchLogFault(i18n, &quot;ts.logger.nologscreated&quot;, key);
1320         }
1321 
1322         if (wd == null) {
1323             throw new NullPointerException(i18n.getString(&quot;ts.logger.nullwd&quot;));
1324         }
1325 
1326         String logFile = wd.getLogFileName();
1327 
1328         for (GeneralPurposeLogger logger : gpls) {
1329             if (logger.getLogFileName().equals(logFile) &amp;&amp; logger.getName().equals(key)) {
1330                 return logger;
1331             }
1332         }
1333         throw new NoSuchLogFault(i18n, &quot;ts.logger.nosuchlogfault&quot;, key);
1334     }
1335 
1336     /**
1337      * Cleans the log file in given WorkDirectory
1338      *
1339      * @param wd WorkDirectory desired logger is registered for
1340      * @throws IOException if log file&#39;s content can&#39;t be erased
1341      */
1342     public void eraseLog(WorkDirectory wd) throws IOException {
1343         if (wd == null) {
1344             throw new NullPointerException(i18n.getString(&quot;ts.logger.nullwd&quot;));
1345         }
1346 
1347         if (gpls != null) {
1348             for (GeneralPurposeLogger gpl : gpls) {
1349                 if (gpl.getLogFileName().equals(wd.getLogFileName())) {
1350                     Handler[] h = gpl.getHandlers();
1351                     if (h[0] instanceof WorkDirLogHandler) {
1352                         ((WorkDirLogHandler) h[0]).eraseLogFile();
1353                         return;
1354                     }
1355                 }
1356             }
1357         }
1358     }
1359 
1360     /**
1361      * An exception used to report errors while using a TestSUite object.
1362      */
1363     public static class Fault extends Exception {
1364         /**
1365          * Create a Fault.
1366          *
1367          * @param i18n A resource bundle in which to find the detail message.
1368          * @param s    The key for the detail message.
1369          */
1370         public Fault(I18NResourceBundle i18n, String s) {
1371             super(i18n.getString(s));
1372         }
1373 
1374         /**
1375          * Create a Fault.
1376          *
1377          * @param i18n A resource bundle in which to find the detail message.
1378          * @param s    The key for the detail message.
1379          * @param o    An argument to be formatted with the detail message by
1380          *             {@link java.text.MessageFormat#format}
1381          */
1382         public Fault(I18NResourceBundle i18n, String s, Object o) {
1383             super(i18n.getString(s, o));
1384         }
1385 
1386         /**
1387          * Create a Fault.
1388          *
1389          * @param i18n A resource bundle in which to find the detail message.
1390          * @param s    The key for the detail message.
1391          * @param o    An array of arguments to be formatted with the detail message by
1392          *             {@link java.text.MessageFormat#format}
1393          */
1394         public Fault(I18NResourceBundle i18n, String s, Object... o) {
1395             super(i18n.getString(s, o));
1396         }
1397     }
1398 
1399     /**
1400      * An exception that is used to report that a given file is not a test suite.
1401      */
1402     public static class NotTestSuiteFault extends Fault {
1403         /**
1404          * Create a Fault.
1405          *
1406          * @param i18n A resource bundle in which to find the detail message.
1407          * @param s    The key for the detail message.
1408          * @param f    The file in question, to be formatted with the detail message by
1409          *             {@link java.text.MessageFormat#format}
1410          */
1411         public NotTestSuiteFault(I18NResourceBundle i18n, String s, File f) {
1412             super(i18n, s, f.getPath());
1413         }
1414     }
1415 
1416     public static class DuplicateLogNameFault extends Fault {
1417         /**
1418          * Create a Fault.
1419          *
1420          * @param i18n A resource bundle in which to find the detail message.
1421          * @param key  The internal name of the log.
1422          *             {@link java.text.MessageFormat#format}
1423          */
1424         public DuplicateLogNameFault(I18NResourceBundle i18n, String s, String key) {
1425             super(i18n, s, key);
1426         }
1427     }
1428 
1429     public static class NoSuchLogFault extends Fault {
1430         /**
1431          * Create a Fault.
1432          *
1433          * @param i18n A resource bundle in which to find the detail message.
1434          * @param key  The internal name of the log.
1435          *             {@link java.text.MessageFormat#format}
1436          */
1437         public NoSuchLogFault(I18NResourceBundle i18n, String s, String key) {
1438             super(i18n, s, key);
1439         }
1440     }
1441 
1442     private static class NotificationLogger extends Logger {
1443         private NotificationLogger(String resourceBundleName) {
1444             super(notificationLogName, resourceBundleName);
1445             setLevel(Level.CONFIG);
1446             // needs to be reimplemented - this initializes Swing, which is not
1447             // allowed inside the core harness
1448             // should be implemented so that the GUI attaches to the logging system
1449             // on startup
1450             //addHandler(new ErrorDialogHandler());
1451         }
1452 
1453         @Override
1454         public synchronized void log(LogRecord record) {
1455             record.setLoggerName(this.getName());
1456             if (record.getThrown() != null) {
1457                 record.setLevel(Level.INFO);
1458             }
1459             super.log(record);
1460         }
1461 
1462 
1463         // overwrite to make sure exception is handled
1464         @Override
1465         public void throwing(String sourceClass, String sourceMethod, Throwable thrown) {
1466             LogRecord lr = new LogRecord(Level.INFO, &quot;THROW&quot;);
1467             lr.setSourceClassName(sourceClass);
1468             lr.setSourceMethodName(sourceMethod);
1469             lr.setThrown(thrown);
1470             log(lr);
1471         }
1472 
1473     }
1474 
1475     private static class GeneralPurposeLogger extends Logger {
1476         private String logFileName;
1477 
1478         private GeneralPurposeLogger(String name, WorkDirectory wd, String resourceBundleName, TestSuite ts) {
1479             super(name, resourceBundleName);
1480             this.logFileName = wd.getLogFileName();
1481 
1482             if (wd != null) {
1483                 if (!handlersMap.containsKey(wd.getLogFileName())) {
1484                     WorkDirLogHandler wdlh = new WorkDirLogHandler(ts.getObservedFile(wd));
1485                     handlersMap.put(wd.getLogFileName(), wdlh);
1486                 }
1487 
1488                 addHandler(handlersMap.get(wd.getLogFileName()));
1489             }
1490             setLevel(Level.ALL);
1491         }
1492 
1493         @Override
1494         public void log(LogRecord record) {
1495             Handler targets[] = getHandlers();
1496             if (targets != null) {
1497                 for (Handler target : targets) {
1498                     if (target instanceof WorkDirLogHandler) {
1499                         ((WorkDirLogHandler) target).publish(record, getName());
1500                     } else {
1501                         target.publish(record);
1502                     }
1503                 }
1504             }
1505         }
1506 
1507         private String getLogFileName() {
1508             return logFileName;
1509         }
1510     }
1511 
1512 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
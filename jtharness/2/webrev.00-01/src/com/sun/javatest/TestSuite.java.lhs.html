<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/com/sun/javatest/TestSuite.java</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * $Id$
   3  *
   4  * Copyright (c) 1996, 2012, Oracle and/or its affiliates. All rights reserved.
   5  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   6  *
   7  * This code is free software; you can redistribute it and/or modify it
   8  * under the terms of the GNU General Public License version 2 only, as
   9  * published by the Free Software Foundation.  Oracle designates this
  10  * particular file as subject to the &quot;Classpath&quot; exception as provided
  11  * by Oracle in the LICENSE file that accompanied this code.
  12  *
  13  * This code is distributed in the hope that it will be useful, but WITHOUT
  14  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  15  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  16  * version 2 for more details (a copy is included in the LICENSE file that
  17  * accompanied this code).
  18  *
  19  * You should have received a copy of the GNU General Public License version
  20  * 2 along with this work; if not, write to the Free Software Foundation,
  21  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  22  *
  23  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  24  * or visit www.oracle.com if you need additional information or have any
  25  * questions.
  26  */
  27 package com.sun.javatest;
  28 
  29 import com.sun.javatest.finder.BinaryTestFinder;
  30 import com.sun.javatest.finder.HTMLTestFinder;
  31 import com.sun.javatest.finder.TestFinderDecorator;
  32 import com.sun.javatest.interview.LegacyParameters;
  33 import com.sun.javatest.lib.KeywordScript;
  34 import com.sun.javatest.logging.ObservedFile;
  35 import com.sun.javatest.logging.WorkDirLogHandler;
  36 import com.sun.javatest.services.PropertyServiceReader;
  37 import com.sun.javatest.services.ServiceManager;
  38 import com.sun.javatest.services.ServiceReader;
  39 import com.sun.javatest.util.BackupPolicy;
  40 import com.sun.javatest.util.I18NResourceBundle;
  41 import com.sun.javatest.util.PropertyUtils;
  42 import com.sun.javatest.util.StringArray;
  43 
  44 import java.io.BufferedInputStream;
  45 import java.io.File;
  46 import java.io.FileInputStream;
  47 import java.io.FileNotFoundException;
  48 import java.io.IOException;
  49 import java.io.InputStream;
  50 import java.lang.ref.WeakReference;
  51 import java.lang.reflect.InvocationTargetException;
  52 import java.lang.reflect.Method;
  53 import java.lang.reflect.Modifier;
  54 import java.net.MalformedURLException;
  55 import java.net.URL;
  56 import java.net.URLClassLoader;
  57 import java.util.Collection;
  58 import java.util.Collections;
  59 import java.util.HashMap;
  60 import java.util.Iterator;
  61 import java.util.List;
  62 import java.util.Map;
  63 import java.util.Vector;
  64 import java.util.logging.Handler;
  65 import java.util.logging.Level;
  66 import java.util.logging.LogRecord;
  67 import java.util.logging.Logger;
  68 
  69 /**
  70  * A class providing information about and access to the tests in a test suite.
  71  * The primary methods to access and run the tests are
  72  * &lt;ul&gt;
  73  * &lt;li&gt;{@link TestSuite#createTestFinder createTestFinder }
  74  * &lt;li&gt;{@link TestSuite#createTestFilter createTestFilter }
  75  * &lt;li&gt;{@link TestSuite#createScript createScript }
  76  * &lt;/ul&gt;
  77  */
  78 public class TestSuite {
  79     /**
  80      * Should tests which no longer exist in the test suite be
  81      * deleted from a work directory when it is opened?
  82      */
  83     public static final int DELETE_NONTEST_RESULTS = 0;
  84     /*
  85      * Should the content of the test suite be refreshed as the
  86      * tests run?  So the test description should be updated from the
  87      * finder just before the test runs.
  88      */
  89     public static final int REFRESH_ON_RUN = 1;
  90     /**
  91      * Should a test be reset to not run if it is found that the
  92      * test has changed in the test suite (test description does
  93      * not match the one in the existing result).
  94      */
  95     public static final int CLEAR_CHANGED_TEST = 2;
  96     public static final String TM_CONTEXT_NAME = &quot;tmcontext&quot;;
  97     private static final String TESTSUITE_HTML = &quot;testsuite.html&quot;;
  98     private static final String TESTSUITE_JTT = &quot;testsuite.jtt&quot;;
  99     private static final String FIND_LEGACY_CONSTRUCTOR = &quot;com.sun.javatest.ts.findLegacyCtor&quot;;
 100     static Map&lt;String, WorkDirLogHandler&gt; handlersMap = new HashMap&lt;&gt;();
 101 
 102     /**
 103      * Disposed of the shared TestSuite object for this test suite.  Use
 104      * the value from {@code TestSuite.getRoot()} as the value for
 105      * canonRoot.  Using this is only desired when disposal of the shared
 106      * TestSuite object is not desired - traditionally, it is not disposed
 107      * and is reused if the test suite is reopened.
 108      * @param canonRoot Canonical root of the test suite.
 109      * @see TestSuite#getRoot
 110      * @return The object which is about to be discarded.  Null if it was not
 111      *         not cached here.
 112      */
 113     /*
 114     public static TestSuite close(File canonRoot) {
 115         WeakReference ref = (WeakReference)(dirMap.remove(canonRoot));
 116         if (ref != null) {
 117             TestSuite ts = (TestSuite)(ref.get());
 118             if (ts != null) {
 119                 return ts;
 120             }
 121         }
 122 
 123         return null;
 124     }
 125      */
 126     private static Map&lt;File, WeakReference&lt;TestSuite&gt;&gt; dirMap = new HashMap&lt;&gt;(2);
 127     private static I18NResourceBundle i18n = I18NResourceBundle.getBundleForClass(TestSuite.class);
 128     private static String notificationLogName = i18n.getString(&quot;notification.logname&quot;);
 129     private static Vector&lt;GeneralPurposeLogger&gt; gpls;
 130     private static Map&lt;String, File&gt; observedFiles;
 131     private final NotificationLogger notifLogger = new NotificationLogger(null);
 132     private File root;
 133     private Map&lt;String, String&gt; tsInfo;
 134     private ClassLoader loader;
 135     private TestFinder finder;
 136     // the following are used by the default impl of createScript
 137     private Class&lt;? extends Script&gt; scriptClass;
 138     private String[] scriptArgs;
 139     private String[] keywords;
 140     private ServiceReader serviceReader;
 141     private ServiceManager serviceManager;
 142 
 143     /**
 144      * Create a TestSuite object.
 145      *
 146      * @param root   The root file for this test suite.
 147      * @param tsInfo Test suite properties, typically read from the test suite properties file
 148      *               in the root directory of the test suite.
 149      * @param cl     A class loader to be used to load additional classes as required,
 150      *               typically using a class path defined in the test suite properties file.
 151      */
 152     public TestSuite(File root, Map&lt;String, String&gt; tsInfo, ClassLoader cl) {
 153         this.root = root;
 154         this.tsInfo = tsInfo;
 155         this.loader = cl;
 156 
 157         String kw = tsInfo == null ? null : tsInfo.get(&quot;keywords&quot;);
 158         keywords = kw == null ? null : StringArray.split(kw);
 159     }
 160 
 161     /**
 162      * Create a TestSuite object, with no additional test suite properties and no
 163      * class loader.
 164      *
 165      * @param root The root file for this test suite.
 166      */
 167     public TestSuite(File root) {
 168         this.root = root;
 169     }
 170 
 171     /**
 172      * Check if a file is the root of a valid test suite. A valid test suite is identified
 173      * either by the root directory of the test suite, or by the file testsuite.html within
 174      * that directory. The directory must contain either a test suite properties file
 175      * (testsuite.jtt) or, for backwards compatibility, a file named testsuite.html.
 176      *
 177      * @param root The file to be checked.
 178      * @return true if and only if &lt;em&gt;root&lt;/em&gt; is the root of a valid test suite.
 179      */
 180     public static boolean isTestSuite(File root) {
 181         //System.err.println(&quot;TestSuite.isTestSuite: &quot; + root);
 182         File dir;
 183         if (root.isDirectory()) {
 184             dir = root;
 185         } else {
 186             if (root.getName().equalsIgnoreCase(TESTSUITE_HTML)) {
 187                 dir = root.getParentFile();
 188             } else {
 189                 return false;
 190             }
 191         }
 192         File jtt = new File(dir, TESTSUITE_JTT);
 193         File parentDir = dir.getParentFile();
 194         File parent_jtt = parentDir == null ? null : new File(parentDir, TESTSUITE_JTT);
 195         File html = new File(dir, TESTSUITE_HTML);
 196         return isReadableFile(jtt)
 197                 || isReadableFile(html) &amp;&amp; (parent_jtt == null || !parent_jtt.exists());
 198     }
 199 
 200     /**
 201      * Open a test suite.
 202      *
 203      * @param root A file identifying the root of the test suite.
 204      * @return A TestSuite object for the test suite in question. The actual type of the result
 205      * will depend on the test suite properties found in the root directory of the test suite.
 206      * @throws FileNotFoundException       if &lt;em&gt;root&lt;/em&gt; does not exist.
 207      * @throws TestSuite.NotTestSuiteFault if &lt;em&gt;root&lt;/em&gt; does not identify a valid test suite.
 208      * @throws TestSuite.Fault             if any other problems occur while trying to open the test suite.
 209      * @see #isTestSuite
 210      */
 211     public static TestSuite open(File root) throws FileNotFoundException, Fault, NotTestSuiteFault {
 212         if (!root.exists()) {
 213             throw new FileNotFoundException(root.getPath());
 214         }
 215 
 216         File canonRoot;
 217         try {
 218             canonRoot = root.getCanonicalFile();
 219         } catch (IOException e) {
 220             throw new Fault(i18n, &quot;ts.cantCanonicalize&quot;,
 221                     root.getPath(), e.toString());
 222         }
 223 
 224         File canonRootDir;
 225         if (canonRoot.isDirectory()) {
 226             canonRootDir = canonRoot;
 227         } else {
 228             if (canonRoot.getName().equalsIgnoreCase(TESTSUITE_HTML)) {
 229                 canonRootDir = canonRoot.getParentFile();
 230             } else {
 231                 throw new NotTestSuiteFault(i18n, &quot;ts.notTestSuiteFile&quot;, canonRoot);
 232             }
 233         }
 234 
 235         File f = new File(canonRootDir, TESTSUITE_JTT);
 236         if (isReadableFile(f)) {
 237             try (InputStream in = new BufferedInputStream(new FileInputStream(f))) {
 238                 Map&lt;String, String&gt; p = PropertyUtils.load(in);
 239                 return open(canonRoot, p);
 240             } catch (IOException e) {
 241                 throw new Fault(i18n, &quot;ts.cantReadTestSuiteFile&quot;, e.toString());
 242             }
 243         } else {
 244             // check for old style test suite
 245             File ts_html = new File(canonRootDir, TESTSUITE_HTML);
 246             File parentDir = canonRootDir.getParentFile();
 247             File parent_jtt = parentDir == null ? null : new File(parentDir, TESTSUITE_JTT);
 248             if (isReadableFile(ts_html) &amp;&amp; (parent_jtt == null || !parent_jtt.exists())) {
 249                 return open(canonRoot, new HashMap&lt;&gt;());
 250             } else {
 251                 throw new NotTestSuiteFault(i18n, &quot;ts.notTestSuiteFile&quot;, canonRoot);
 252             }
 253         }
 254     }
 255 
 256     /**
 257      * Open a test suite.
 258      *
 259      * @param root   A file identifying the root of the test suite.
 260      * @param tsInfo Test Suite properties read from the test suite properties file.
 261      * @return A TestSuite object for the test suite in question.
 262      * @throws TestSuite.Fault if any problems occur while opening the test suite
 263      */
 264     private static TestSuite open(File root, Map&lt;String, String&gt; tsInfo) throws Fault {
 265         synchronized (dirMap) {
 266             TestSuite ts;
 267 
 268             // if this test suite has already been opened, return that
 269             WeakReference&lt;TestSuite&gt; ref = dirMap.get(root);
 270             if (ref != null) {
 271                 ts = ref.get();
 272                 if (ts != null) {
 273                     return ts;
 274                 }
 275             }
 276 
 277             // otherwise, open it for real
 278             ts = open0(root, tsInfo);
 279 
 280             // save reference in case opened again
 281             dirMap.put(root, new WeakReference&lt;&gt;(ts));
 282             return ts;
 283         }
 284     }
 285 
 286     private static TestSuite open0(File root, Map&lt;String, String&gt; tsInfo) throws Fault {
 287         String[] classPath = StringArray.split(tsInfo.get(&quot;classpath&quot;));
 288 
 289         ClassLoader cl;
 290         if (classPath.length == 0) {
 291             cl = null;
 292         } else {
 293             try {
 294                 File rootDir = root.isDirectory() ? root : root.getParentFile();
 295                 URL[] p = new URL[classPath.length];
 296                 for (int i = 0; i &lt; classPath.length; i++) {
 297                     String cpi = classPath[i];
 298                     if (cpi.toLowerCase().startsWith(&quot;http:&quot;)) {
 299                         p[i] = new URL(cpi);
 300                     } else {
 301                         File f = new File(cpi);
 302                         if (!f.isAbsolute()) {
 303                             f = new File(rootDir, cpi);
 304                         }
 305                         p[i] = f.toURI().toURL();
 306                     }
 307                 }
 308                 cl = new URLClassLoader(p, TestSuite.class.getClassLoader());
 309             } catch (MalformedURLException e) {
 310                 throw new Fault(i18n, &quot;ts.badClassPath&quot;,
 311                         root, e.getMessage());
 312             }
 313         }
 314 
 315         String[] tsClassAndArgs = StringArray.split(tsInfo.get(&quot;testsuite&quot;));
 316 
 317         TestSuite testSuite;
 318         if (tsClassAndArgs.length == 0) {
 319             testSuite = new TestSuite(root, tsInfo, cl);
 320         } else {
 321             String className = tsClassAndArgs[0];
 322 
 323             try {
 324                 Class&lt;? extends TestSuite&gt; c = loadClass(className, cl);
 325                 Class&lt;?&gt;[] tsArgTypes = {File.class, Map.class, ClassLoader.class};
 326                 Object[] tsArgs = {root, tsInfo, cl};
 327                 testSuite = newInstance(c, tsArgTypes, tsArgs);
 328             } catch (ClassCastException e) {
 329                 throw new Fault(i18n, &quot;ts.notASubtype&quot;,
 330                         className, &quot;testsuite&quot;, TestSuite.class.getName());
 331             } catch (UnsupportedClassVersionError uce) {
 332                 throw new Fault(i18n, &quot;ts.compiledRecentVersion&quot;,
 333                         System.getProperty(&quot;java.version&quot;), root.getPath());
 334             }
 335 
 336             String[] args = new String[tsClassAndArgs.length - 1];
 337             System.arraycopy(tsClassAndArgs, 1, args, 0, args.length);
 338             testSuite.init(args);
 339         }
 340 
 341         // initialize test finder
 342         testSuite.setTestFinder(new TestFinderDecorator(testSuite.createTestFinder()));
 343 
 344         return testSuite;
 345     }
 346 
 347     private static String[] envLookup(TestEnvironment env, String name) throws Fault {
 348         try {
 349             return env.lookup(name);
 350         } catch (TestEnvironment.Fault e) {
 351             throw new Fault(i18n, &quot;ts.cantFindNameInEnv&quot;,
 352                     name, e.getMessage());
 353         }
 354     }
 355 
 356     /**
 357      * Create a new instance of a class, translating any exceptions that may arise
 358      * into Fault.
 359      *
 360      * @param c the class to be instantiated
 361      * @return an instance of the specified class
 362      * @throws TestSuite.Fault if any errors arise while trying to instantiate
 363      *                         the class.
 364      */
 365     protected static &lt;T&gt; T newInstance(Class&lt;? extends T&gt; c) throws Fault {
 366         try {
 367             return c.getDeclaredConstructor().newInstance();
 368         } catch (InstantiationException | NoSuchMethodException | InvocationTargetException e) {
 369             throw new Fault(i18n, &quot;ts.cantInstantiate&quot;,
 370                     c.getName(), e);
 371         } catch (IllegalAccessException e) {
 372             throw new Fault(i18n, &quot;ts.illegalAccess&quot;,
 373                     c.getName(), e);
 374         }
 375     }
 376 
 377     /**
 378      * Create a new instance of a class using a non-default constructor,
 379      * translating any exceptions that may arise into Fault.
 380      *
 381      * @param c        the class to be instantiated
 382      * @param argTypes the types of the argument to be passed to the constructor,
 383      *                 (thus implying the constructor to be used.)
 384      * @param args     the arguments to be passed to the constructor
 385      * @return an instance of the specified class
 386      * @throws TestSuite.Fault if any errors arise while trying to instantiate
 387      *                         the class.
 388      */
 389     protected static &lt;T&gt; T newInstance(Class&lt;? extends T&gt; c, Class&lt;?&gt;[] argTypes, Object... args)
 390             throws Fault {
 391         try {
 392             return c.getConstructor(argTypes).newInstance(args);
 393         } catch (IllegalAccessException e) {
 394             throw new Fault(i18n, &quot;ts.illegalAccess&quot;,
 395                     c.getName(), e);
 396         } catch (InstantiationException e) {
 397             throw new Fault(i18n, &quot;ts.cantInstantiate&quot;,
 398                     c.getName(), e);
 399         } catch (InvocationTargetException e) {
 400             Throwable te = e.getTargetException();
 401             if (te instanceof Fault) {
 402                 throw (Fault) te;
 403             } else {
 404                 throw new Fault(i18n, &quot;ts.cantInit&quot;, c.getName(), te);
 405             }
 406         } catch (NoSuchMethodException e) {
 407             // don&#39;t recurse past the use of a single arg constructor
 408             if (argTypes.length &gt; 1 &amp;&amp; Boolean.getBoolean(FIND_LEGACY_CONSTRUCTOR)) {
 409                 return newInstance(c, new Class&lt;?&gt;[]{File.class}, args[0]);
 410             }
 411 
 412             throw new Fault(i18n, &quot;ts.cantFindConstructor&quot;,
 413                     c.getName(), e);
 414         }
 415     }
 416 
 417     /**
 418      * Load a class using a specified loader, translating any errors that may arise
 419      * into Fault.
 420      *
 421      * @param className the name of the class to be loaded
 422      * @param cl        the class loader to use to load the specified class
 423      * @return the class that was loaded
 424      * @throws TestSuite.Fault if there was a problem loading the specified class
 425      */
 426     protected static &lt;T&gt; Class&lt;? extends T&gt; loadClass(String className, ClassLoader cl) throws Fault {
 427         try {
 428             if (cl == null) {
 429                 return (Class&lt;? extends T&gt;) Class.forName(className);
 430             } else {
 431                 return (Class&lt;? extends T&gt;) cl.loadClass(className);
 432             }
 433         } catch (ClassNotFoundException e) {
 434             throw new Fault(i18n, &quot;ts.classNotFound&quot;,
 435                     className, e);
 436         } catch (IllegalArgumentException e) {
 437             throw new Fault(i18n, &quot;ts.badClassName&quot;,
 438                     new Object[]{className});
 439         }
 440     }
 441 
 442     private static boolean isReadableFile(File f) {
 443         return f.exists() &amp;&amp; f.isFile() &amp;&amp; f.canRead();
 444     }
 445 
 446     /**
 447      * Initialize this test suite, with args typically read from a .jtt file.
 448      * The default implementation does not recognize any arguments and always
 449      * throws an exception.
 450      *
 451      * @param args an array of strings to initialize this test suite object
 452      * @throws TestSuite.Fault if there are any problems initializing the
 453      *                         test suite from the specified arguments.
 454      */
 455     protected void init(String... args) throws Fault {
 456         if (args.length &gt; 0) {
 457             throw new Fault(i18n, &quot;ts.badArgs&quot;, args[0]);
 458         }
 459         // should be a decodeArgs loop
 460     }
 461 
 462     /**
 463      * Get the path for the root file of this test suite.
 464      *
 465      * @return the path for the root file of this test suite.
 466      */
 467     public String getPath() {
 468         return root.getPath();
 469     }
 470 
 471     /**
 472      * Get the root file of this test suite.
 473      *
 474      * @return the root file of this test suite.
 475      */
 476     public File getRoot() {
 477         return root;
 478     }
 479 
 480     /**
 481      * Get the root directory of this test suite. If the root file is itself a directory,
 482      * the result will be that directory; otherwise, the result will be the parent directory
 483      * of the root file.
 484      *
 485      * @return the root directory of this test suite.
 486      */
 487     public File getRootDir() {
 488         return root.isDirectory() ? root : new File(root.getParent());
 489     }
 490 
 491     /**
 492      * Get the directory in the test suite that contains the tests.
 493      * By default, the following are checked:
 494      * &lt;ol&gt;
 495      * &lt;li&gt;The {@code tests} property in the test suite properties file.
 496      * If this entry is found, it must either identify an absolute filename, or
 497      * a directory relative to the test suite root directory, using &#39;/&#39; to
 498      * separate the components of the path.
 499      * &lt;li&gt;If the file &lt;em&gt;root&lt;/em&gt;{@code /tests/testsuite.html} exists,
 500      * the result is the directory &lt;em&gt;root&lt;/em&gt;{@code /tests}. This is
 501      * for compatibility with standard TCK layout.
 502      * &lt;li&gt;Otherwise, the result is the root directory of the test suite.
 503      * &lt;/ol&gt;
 504      *
 505      * @return the directory that contains the tests
 506      */
 507     public File getTestsDir() {
 508         String t = tsInfo == null ? null : tsInfo.get(&quot;tests&quot;);
 509         if (t == null || t.isEmpty()) {
 510             File rootDir = getRootDir();
 511             File testsDir = new File(rootDir, &quot;tests&quot;);
 512             if (testsDir.isDirectory()) {
 513                 // if the tests directory exists, and there is no overriding
 514                 // testsuite.jtt entry, assume the tests dir is &quot;tests/&quot;.
 515                 return testsDir;
 516             }
 517             // default
 518             return rootDir;
 519         } else {
 520             File f = new File(t);
 521             if (f.isAbsolute()) {
 522                 return f;
 523             } else {
 524                 return new File(getRootDir(), t.replace(&#39;/&#39;, File.separatorChar));
 525             }
 526         }
 527     }
 528 
 529     /**
 530      * A notification method that is called when a test suite run is starting.
 531      * The method may be used to do any test suite specific initialization.
 532      * If overriding this method, be sure to call the superclass&#39; method.  It is
 533      * fairly typical to register as a harness observer inside this method.  Note
 534      * that if an exception occurs during this method, it will be caught by the
 535      * harness and reported as a Harness.Observer.error().  It is recommended
 536      * that any implementations of this method register as an observer immediately
 537      * so that they can catch this error and do any cleanup to abort the
 538      * test suite startup sequence (check if services were started and close them
 539      * down, etc).
 540      *
 541      * @param harness The harness that will be used to run the tests.
 542      * @throws TestSuite.Fault if an error occurred while doing test suite-specific
 543      *                         initialization that should cause the test run to be aborted.
 544      */
 545     public void starting(Harness harness) throws Fault {
 546         if (getServiceManager() != null) {
 547             serviceManager.setHarness(harness);
 548         }
 549     }
 550 
 551     /**
 552      * Create a test suite specific filter to be used to filter the tests
 553      * to be selected for a test run.
 554      * The method should return null if no test suite specific filtering is required.
 555      * The default is to return null.
 556      *
 557      * @param filterEnv Configuration data that may be used by the filter.
 558      * @return a test suite filter, or null if no test suite specific filter is
 559      * required for this test suite.
 560      * @deprecated this method is deprecated, it is temporarily kept for easier migration
 561      * of client subclasses that provide their implementaitons of this method.
<a name="1" id="anc1"></a><span class="line-modified"> 562      * To do the migration please override {@code createAdditionalTestFilters} to return a collection of filters (even having one element).</span>
<span class="line-modified"> 563      * Both this method and {@code createAdditionalTestFilters} are called by the framework and taken into account.</span>
 564      */
 565     @java.lang.Deprecated
 566     public TestFilter createTestFilter(TestEnvironment filterEnv) {
 567         return null;
 568     }
 569 
 570     /**
 571      * Create test suite specific filters to be used to filter the tests for a test run.
 572      * The method should return empty collection if no test suite specific filtering is required.
 573      * Default implementation of this method returns an empty collection.
 574      * Both this method and {@code createTestFilter} are called by the framework and taken into account.
 575      *
 576      * @param filterEnv Configuration data that may be used by the filters.
 577      * @return collection of test suite filters (if there are any)
 578      */
 579     public List&lt;TestFilter&gt; createTestFilters(TestEnvironment filterEnv) {
 580         return Collections.emptyList();
 581     }
 582 
 583     /**
 584      * Get a shared test finder to read the tests in this test suite.
 585      *
 586      * @return a test finder to read the tests in this test suite
 587      * @see #createTestFinder
 588      * @see #setTestFinder
 589      */
 590     public TestFinder getTestFinder() {
 591         return finder;
 592     }
 593 
 594     /**
 595      * Set the shared test finder used to read the tests in this test suite.
 596      * Only one test finder may be set; attempts to change the test finder will
 597      * cause IllegalStateException to be thrown.
 598      * This method is normally called by TestSuite.open to initialize the
 599      * finder to the result of calling createTestFinder.
 600      *
 601      * @param tf the test finder to be used
 602      * @throws IllegalStateException if the test finder has previously
 603      *                               been set to a different value
 604      * @see #getTestFinder
 605      */
 606     protected void setTestFinder(TestFinder tf) {
 607         if (tf == null) {
 608             throw new NullPointerException();
 609         }
 610 
 611         if (finder != null &amp;&amp; finder != tf) {
 612             throw new IllegalStateException();
 613         }
 614 
 615         finder = tf;
 616     }
 617 
 618     /**
 619      * Create a test finder to be used to access the tests in this test suite.
 620      * The default implementation looks for a {@code finder} entry in the
 621      * test suite properties file, which should identify the class to be used
 622      * and any arguments it may require. The class will be loaded via the class
 623      * loader specified when the test suite was opened, if one was given;
 624      * otherwise, the system class loader will be used.
 625      * &lt;p&gt;
 626      * The default implementation attempts to use a file testsuite.jtd
 627      * in the tests directory.  If found, a BinaryTestFinder will be created
 628      * using this file.  If it is not found, then it searches for a property
 629      * named finder in the test suite properties and will attempt to
 630      * instantiate that.  If no entry is found or it is blank, an
 631      * HTMLTestFinder is used, using whatever a basic settings HTMLTestFinder
 632      * initializes to.
 633      *
 634      * @return a test finder to be used to read the tests in the test suite
 635      * @throws TestSuite.Fault if there is a problem creating the test finder
 636      * @see #getTestFinder
 637      * @see #setTestFinder
 638      * @see #getTestsDir
 639      */
 640     protected TestFinder createTestFinder() throws Fault {
 641         File testsDir = getTestsDir();
 642 
 643         // no BTF file; look for a finder=class args... entry
 644         String[] finderCmd = StringArray.split(tsInfo.get(&quot;finder&quot;));
 645         String finderClassName;
 646         String[] finderArgs = new String[0];
 647 
 648         if (finderCmd == null || finderCmd.length == 0) {
 649             //finderCmd = new String[] {HTMLTestFinder.class.getName()};
 650             finderCmd = null;   // ensure null for later use
 651             finderClassName = HTMLTestFinder.class.getName();
 652         } else {
 653             finderClassName = finderCmd[0];
 654 
 655             if (finderCmd.length &gt; 1) {
 656                 finderArgs = new String[finderCmd.length - 1];
 657                 System.arraycopy(finderCmd, 1, finderArgs, 0, finderArgs.length);
 658             } else {
 659                 // finderArgs should remain empty array
 660             }
 661         }
 662 
 663         // first, try looking for testsuite.jtd
 664         String jtd = tsInfo.get(&quot;testsuite.jtd&quot;);
 665         File jtdFile = jtd == null ? new File(testsDir, &quot;testsuite.jtd&quot;) : new File(root, jtd);
 666         if (jtdFile.exists()) {
 667             try {
 668                 // found a file for BinaryTestFinder
 669                 // only pass the finder class if it was not defaulted to HTMLTestFinder
 670                 return createBinaryTestFinder(finderCmd == null ? null : finderClassName,
 671                         finderArgs, testsDir, jtdFile);
 672             } catch (Fault e) {
 673                 // ignore, try to continue with normal finder
 674             }
 675         }
 676 
 677         try {
 678             Class&lt;? extends TestFinder&gt; c = loadClass(finderClassName);
 679             TestFinder tf = newInstance(c);
 680             // called old deprecated entry till we know no-one cares
 681             //tf.init(finderArgs, testsRoot, null, null, tsInfo/*pass in env?*/);
 682             // this likely kills ExpandTestFinder, finally
 683             tf.init(finderArgs, testsDir, null, null, null/*pass in env?*/);
 684             return tf;
 685         } catch (ClassCastException e) {
 686             throw new Fault(i18n, &quot;ts.notASubtype&quot;,
 687                     finderClassName, &quot;finder&quot;, TestFinder.class.getName());
 688         } catch (TestFinder.Fault e) {
 689             throw new Fault(i18n, &quot;ts.errorInitFinder&quot;,
 690                     finderClassName, e.getMessage());
 691         }
 692     }
 693 
 694     /**
 695      * In the case where a JTD file is found, attempt to load a binary test finder.
 696      * The default implementation attempts to use the finder property in the
 697      * test suite properties if it is a BinaryTestFinder subclass.
 698      *
 699      * @param finderClassName Finder class name to attempt to use as a BTF.  Null if
 700      *                        the default BTF class should be used.
 701      * @param finderArgs      Arguments to finder given from the test suite property.
 702      * @param testsDir        Reference location to pass to finder.
 703      * @param jtdFile         Location of the JTD file to give to the BTF.
 704      * @return The binary test finder which was created.
 705      * @throws com.sun.javatest.TestSuite.Fault
 706      * @see com.sun.javatest.TestFinder
 707      * @see com.sun.javatest.finder.BinaryTestFinder
 708      */
 709     protected TestFinder createBinaryTestFinder(String finderClassName,
 710                                                 String finderArgs[], File testsDir, File jtdFile) throws Fault {
 711         try {
 712             TestFinder tf = null;
 713 
 714             if (finderClassName != null) {
 715                 Class&lt;? extends TestFinder&gt; c = loadClass(finderClassName);
 716                 tf = newInstance(c);
 717             }
 718 
 719             if (tf instanceof BinaryTestFinder) {
 720                 tf.init(finderArgs, testsDir, null, null, null);
 721                 return tf;
 722             } else {
 723                 return new BinaryTestFinder(testsDir, jtdFile);
 724             }
 725         } catch (ClassCastException e) {
 726             throw new Fault(i18n, &quot;ts.notASubtype&quot;,
 727                     finderClassName, &quot;finder&quot;, TestFinder.class.getName());
 728         } catch (TestFinder.Fault e) {
 729             throw new Fault(i18n, &quot;ts.errorInitFinder&quot;,
 730                     finderClassName, e.getMessage());
 731         }
 732 
 733     }
 734 
 735     /**
 736      * Create and initialize a TestRunner that can be used to run
 737      * a series of tests.
 738      * The default implementation returns a TestRunner that
 739      * creates a number of test execution threads which each
 740      * create and run a script for each test obtained from
 741      * the test runners iterator.
 742      *
 743      * @return a TestRunner that can be used to run a series of tests
 744      */
 745     public TestRunner createTestRunner() {
 746         return new DefaultTestRunner();
 747     }
 748 
 749     /**
 750      * Create and initialize a Script that can be used to run a test.
 751      * The default implementation looks for a {@code script} entry in the configuration
 752      * data provided, and if not found, looks for a {@code script} entry in the
 753      * test suite properties. The script entry should define the script class
 754      * to use and any arguments it may require. The class will be loaded via the class
 755      * loader specified when the test suite was opened, if one was given;
 756      * otherwise, the system class loader will be used. Individual test suites will
 757      * typically use a more direct means to create an appropriate script object.
 758      * The parameters for this method are normally passed through to the script
 759      * that is created.
 760      * &lt;p&gt;
 761      * Note that the name of this method is &quot;create&quot;, it is not recommended
 762      * that the value returned ever be re-used or cached for subsequent requests
 763      * to this method.
 764      *
 765      * @param td            The test description for the test to be executed.
 766      * @param exclTestCases Any test cases within the test that should not be executed.
 767      * @param scriptEnv     Configuration data to be given to the test as necessary.
 768      * @param workDir       A work directory in which to store the results of the test.
 769      * @param backupPolicy  A policy object used to control how to backup any files that
 770      *                      might be overwritten.
 771      * @return a script to be used to execute the given test
 772      * @throws TestSuite.Fault if any errors occur while creating the script
 773      */
 774     public Script createScript(TestDescription td, String[] exclTestCases, TestEnvironment scriptEnv,
 775                                WorkDirectory workDir,
 776                                BackupPolicy backupPolicy) throws Fault {
 777         if (scriptClass == null) {
 778             String[] script = envLookup(scriptEnv, &quot;script&quot;);
 779             if (script.length == 0) {
 780                 script = StringArray.split(tsInfo.get(&quot;script&quot;));
 781             }
 782             if (script.length &gt; 0) {
 783                 scriptClass = loadClass(script[0]);
 784                 if (!Script.class.isAssignableFrom(scriptClass)) {
 785                     throw new Fault(i18n, &quot;ts.notASubtype&quot;,
 786                             script[0], &quot;script&quot;, Script.class.getName());
 787                 }
 788                 scriptArgs = new String[script.length - 1];
 789                 System.arraycopy(script, 1, scriptArgs, 0, scriptArgs.length);
 790             } else {
 791                 // for backwards compatibility,
 792                 // see if KeywordScript is a reasonable default
 793                 boolean keywordScriptOK = false;
 794                 for (Iterator&lt;String&gt; i = scriptEnv.keys().iterator(); i.hasNext() &amp;&amp; !keywordScriptOK; ) {
 795                     String key = i.next();
 796                     keywordScriptOK = key.startsWith(&quot;script.&quot;);
 797                 }
 798                 if (keywordScriptOK) {
 799                     scriptClass = KeywordScript.class;
 800                     scriptArgs = new String[]{};
 801                 } else {
 802                     throw new Fault(i18n, &quot;ts.noScript&quot;);
 803                 }
 804             }
 805         }
 806 
 807         Script s = newInstance(scriptClass);
 808         s.initArgs(scriptArgs);
 809         s.initTestDescription(td);
 810         s.initExcludedTestCases(exclTestCases);
 811         s.initTestEnvironment(scriptEnv);
 812         s.initWorkDir(workDir);
 813         s.initBackupPolicy(backupPolicy);
 814         s.initClassLoader(loader);
 815         return s;
 816     }
 817 
 818     /**
 819      * Create a configuration interview that can be used to collection the configuration
 820      * data for a test run.
 821      * &lt;p&gt;The default implementation returns a {@link LegacyParameters default}
 822      * interview suitable for use with test suites built with earlier versions
 823      * of the JT Harness: it provides questions equivalent to the fields in
 824      * the GUI Parameter Editor or command-line -params option. As such, much of the
 825      * necessary configuration data is provided indirectly via environment (.jte) files
 826      * which must be created and updated separately.
 827      * &lt;p&gt;Individual test suites should provide their own interview, with questions
 828      * customized to the configuration data they require.
 829      * &lt;p&gt;
 830      * Note that the name of this method is &quot;create&quot;, the harness may instantiate
 831      * multiple copies for temporary use, resetting data or transferring data.
 832      * Do not override this method with an implementation which caches the
 833      * return value.
 834      *
 835      * @return A configuration interview to collect the configuration data for a test run.
 836      * @throws TestSuite.Fault if a problem occurs while creating the interview
 837      */
 838     public InterviewParameters createInterview()
 839             throws Fault {
 840         String[] classNameAndArgs = StringArray.split(tsInfo.get(&quot;interview&quot;));
 841         if (classNameAndArgs == null || classNameAndArgs.length == 0) {
 842             try {
 843                 return new LegacyParameters(this);
 844             } catch (InterviewParameters.Fault e) {
 845                 throw new Fault(i18n, &quot;ts.errorInitDefaultInterview&quot;,
 846                         e.getMessage());
 847             }
 848         }
 849 
 850 
 851         String className = classNameAndArgs[0];
 852         String[] args = new String[classNameAndArgs.length - 1];
 853         System.arraycopy(classNameAndArgs, 1, args, 0, args.length);
 854 
 855         try {
 856             Class&lt;? extends InterviewParameters&gt; c = loadClass(className);
 857             InterviewParameters p = newInstance(c);
 858             p.init(args);
 859             p.setTestSuite(this);
 860             return p;
 861         } catch (ClassCastException e) {
 862             throw new Fault(i18n, &quot;ts.notASubtype&quot;,
 863                     className, &quot;interview&quot;, InterviewParameters.class.getName());
 864         } catch (InterviewParameters.Fault e) {
 865             //e.printStackTrace();
 866             throw new Fault(i18n, &quot;ts.errorInitInterview&quot;,
 867                     className, e.getMessage());
 868         }
 869 
 870     }
 871 
 872     /**
 873      * Create a configuration interview based on specified map of template values
 874      *
 875      * @return A configuration interview to collect the configuration data for a test run.
 876      */
 877     public InterviewParameters loadInterviewFromTemplate(Map&lt;String, String&gt; templateInfo, InterviewParameters newInterview) {
 878         newInterview.storeTemplateProperties(templateInfo);
 879         newInterview.propagateTemplateForAll();
 880         return newInterview;
 881     }
 882 
 883     /**
 884      * Create a configuration interview based on specified template file
 885      *
 886      * @return A configuration interview to collect the configuration data for a test run.
 887      * null if specified file is not template
 888      */
 889     public InterviewParameters loadInterviewFromTemplate(File template,
 890                                                          InterviewParameters ip)
 891             throws IOException {
 892         try (InputStream in = new BufferedInputStream(new FileInputStream(template))) {
 893             Map&lt;String, String&gt; stringProps = PropertyUtils.load(in);
 894             String tm = stringProps.get(InterviewParameters.IS_TEMPLATE);
 895             if (InterviewParameters.TRUE.equals(tm)) {
 896                 stringProps.put(InterviewParameters.TEMPLATE_PATH,
 897                         template.getAbsolutePath());
 898                 ip.setTemplatePath(template.getAbsolutePath());
 899                 return loadInterviewFromTemplate(stringProps, ip);
 900             } else {
 901                 // XXX should probably return ip
 902                 //     or throw Fault
 903                 return null;
 904             }
 905         }
 906     }
 907 
 908     /**
 909      * Get a string containing a unique ID identifying this test suite,
 910      * or null if not available.  The default is taken from the &quot;id&quot; entry
 911      * in the .jtt file.
 912      *
 913      * @return a unique ID identifying the test suite, or null if not specified.
 914      * @see #getName
 915      */
 916     public String getID() {
 917         return tsInfo == null ? null : tsInfo.get(&quot;id&quot;);
 918     }
 919 
 920     /**
 921      * Get a string identifying this test suite, or null if not available.
 922      * The default is taken from the &quot;name&quot; entry in the .jtt file.
 923      * This string is for presentation to the user, and may be localized
 924      * if appropriate.
 925      *
 926      * @return a string identifying the test suite, or null if not specified.
 927      * @see #getID
 928      */
 929     public String getName() {
 930         return tsInfo == null ? null : tsInfo.get(&quot;name&quot;);
 931     }
 932 
 933     /**
 934      * Get the estimated number of tests in the test suite.
 935      * The default is to use the value of the &quot;testCount&quot; property from the
 936      * testsuite.jtt file.
 937      *
 938      * @return The estimated number of tests, or -1 if this number is not available.
 939      */
 940     public int getEstimatedTestCount() {
 941         try {
 942             if (tsInfo != null) {
 943                 String s = tsInfo.get(&quot;testCount&quot;);
 944                 if (s != null) {
 945                     return Integer.parseInt(s);
 946                 }
 947             }
 948         } catch (NumberFormatException e) {
 949             // ignore
 950         }
 951         return -1; // unknown
 952     }
 953 
 954     /**
 955      * Get the file name of the initial exclude list associated with the test suite.
 956      * The default is to use the value of the &quot;initial.jtx&quot; property from the
 957      * testsuite.jtt file. If the value is a relative filename, it will be made absolute
 958      * by evaluating it relative to the test suite root directory.
 959      *
 960      * @return the name of the default exclude list, or null if none specified.
 961      */
 962     public File getInitialExcludeList() {
 963         String s = tsInfo == null ? null : tsInfo.get(&quot;initial.jtx&quot;);
 964         if (s == null) {
 965             return null;
 966         }
 967 
 968         File f = new File(s.replace(&#39;/&#39;, File.separatorChar));
 969         if (!f.isAbsolute()) {
 970             f = new File(getRootDir(), f.getPath());
 971         }
 972         return f;
 973     }
 974 
 975     /**
 976      * Check if the test suite has an initial exclude list.
 977      * The default is to use getInitialExcludeList, and if that returns
 978      * a non-null result, check whether that file exists or not.
 979      *
 980      * @return true if the test suite has an initial exclude list,
 981      * and false otherwise
 982      */
 983     public boolean hasInitialExcludeList() {
 984         File f = getInitialExcludeList();
 985         return f == null ? false : f.exists();
 986     }
 987 
 988     /**
 989      * Get the URL for the latest exclude list associated with the test suite.
 990      * The default is to use the value of the &quot;latest.jtx&quot; property from the
 991      * testsuite.jtt file., which (if present) must be a fully qualified URL
 992      * identifying the latest exclude list for this test suite.
 993      *
 994      * @return the name of the latest exclude list, or null if none specified.
 995      */
 996     public URL getLatestExcludeList() {
 997         try {
 998             String s = tsInfo == null ? null : tsInfo.get(&quot;latest.jtx&quot;);
 999             return s == null ? null : new URL(s);
1000         } catch (MalformedURLException e) {
1001             // ignore
1002             return null;
1003         }
1004     }
1005 
1006     /**
1007      * Check if the test suite has a latest exclude list.
1008      * The default is to use getLatestExcludeList, and to
1009      * check whether that return a non-null result. The URL is not
1010      * itself checked for validity.
1011      *
1012      * @return true if the test suite has a latest exclude list,
1013      * and false otherwise
1014      */
1015     public boolean hasLatestExcludeList() {
1016         URL u = getLatestExcludeList();
1017         return u != null;
1018     }
1019 
1020     /**
1021      * Get the names of any helpsets containing related documents for this
1022      * test suite. The names should identify JavaHelp helpset files, as
1023      * used by javax.help.HelpSet.findHelpSet(ClassLoader, String).
1024      * Thus the names should identify resources of helpsets on the classpath.
1025      * This means you will typically need to put the directory or jar file
1026      * containing the help set on the classpath as well.
1027      * By default, the names will be looked up under the name &quot;additionalDocs&quot;
1028      * in the testsuite.jtt file.
1029      *
1030      * @return an array of names identifying helpsets that contain related
1031      * documents for this testsuite. The result may be null if there are no
1032      * such documents.
1033      */
1034     public String[] getAdditionalDocNames() {
1035         return tsInfo == null
1036                 ? null
1037                 : StringArray.split(tsInfo.get(&quot;additionalDocs&quot;));
1038     }
1039 
1040     /**
1041      * Get the set of valid keywords for this test suite.
1042      * By default, the keywords will be looked up under the name &quot;keywords&quot;
1043      * in the testsuite.jtt file.
1044      *
1045      * @return the set of valid keywords for this test suite, or null
1046      * if not known.
1047      */
1048     public String[] getKeywords() {
1049         return keywords;
1050     }
1051 
1052     /**
1053      * Get a list of associated files for a specified test description.
1054      * Normally, this will include the file containing the test description,
1055      * and any source files used by the test.  By default, the source files
1056      * are determined from the test description&#39;s &quot;source&quot; entry.
1057      *
1058      * @param td The test description for which the associated files are required
1059      * @return a list of associated files for this test description
1060      * @see TestDescription#getSourceURLs()
1061      */
1062     public URL[] getFilesForTest(TestDescription td) {
1063         return td.getSourceURLs();
1064     }
1065 
1066     /**
1067      * This method should be overridden in subclasses
1068      *
1069      * @param path String, which determines path to currently selected test&#39;s folder.
1070      *             This is root relative path. This shouldn&#39;t be null, for the
1071      *             root folder use &quot;&quot;.
1072      * @return array of files with documentation for test&#39;s folder, determined by path.
1073      * null means there no documentation for this folder
1074      */
1075     public URL[] getDocsForFolder(String path) {
1076         return null;
1077     }
1078 
1079     /**
1080      * This method should be overridden in subclasses
1081      *
1082      * @param td TestDescription for currently selected test case. This shouldn&#39;t be null.
1083      * @return array of files with documentation for test case, determined td.
1084      * null means there no documentation for this test case
1085      */
1086     public URL[] getDocsForTest(TestDescription td) {
1087         return null;
1088     }
1089 
1090     /**
1091      * Get A URL identifying a logo for this test suite, or null if none available.
1092      *
1093      * @return a URL for a logo for the testsuite, or null if not available
1094      */
1095     public URL getLogo() {
1096         try {
1097             String s = tsInfo == null ? null : tsInfo.get(&quot;logo&quot;);
1098             return s == null ? null : new URL(getRootDir().toURL(), s);
1099         } catch (MalformedURLException e) {
1100             // ignore
1101             return null;
1102         }
1103     }
1104 
1105     /**
1106      * Load a class using the class loader provided when this test suite was created.
1107      *
1108      * @param className the name of the class to be loaded
1109      * @return the class that was loaded
1110      * @throws TestSuite.Fault if there was a problem loading the specified class
1111      */
1112     public &lt;T&gt; Class&lt;? extends T&gt; loadClass(String className) throws Fault {
1113         return loadClass(className, loader);
1114     }
1115 
1116     /**
1117      * Get the class loader specified when this test suite object was created.
1118      *
1119      * @return the class loader specified when this test suite object was created
1120      */
1121     public ClassLoader getClassLoader() {
1122         return loader;
1123     }
1124 
1125     public ServiceManager getServiceManager() {
1126         if (!needServices()) {
1127             return null;
1128         }
1129 
1130         if (serviceManager == null) {
1131             serviceManager = new ServiceManager(this);
1132         }
1133 
1134         return serviceManager;
1135     }
1136 
1137     /**
1138      * Checks if serviceReader is active and file with service description does
1139      * exist.
1140      *
1141      * @return true, if it&#39;s needed to start services, false otherwise.
1142      */
1143     public boolean needServices() {
1144         ServiceReader sr = getServiceReader();
1145         if (sr == null) {
1146             return false;
1147         }
1148 
1149         /*
1150          * Since jt4.5 the ServiceReader has been extended with a new method.
1151          * To preserve ability to use new javatest with old test suites
1152          * the extra check is performed: check if the newly introduced method
1153          * is abstract or not.
1154          */
1155         boolean isLegacy = false;
1156         try {
1157             Method m = sr.getClass().getMethod(&quot;getServiceDescriptorFileName&quot;);
1158             if (Modifier.isAbstract(m.getModifiers())) {
1159                 isLegacy = true;
1160             }
1161         } catch (NoSuchMethodException e) {
1162             isLegacy = true;
1163         }
1164         File descrFile = isLegacy ?
1165                 new File(getRootDir(), File.separator + &quot;lib&quot; + File.separator + &quot;services.xml&quot;) :
1166                 new File(getRootDir(), sr.getServiceDescriptorFileName());
1167 
1168         return descrFile.exists();
1169     }
1170 
1171     /**
1172      * Returns a test suite specific ServiceReader, used to read Service
1173      * definitions.
1174      *
1175      * @return ServiceReader instance. Default is PropertyServiceReader
1176      */
1177     public ServiceReader getServiceReader() {
1178         if (serviceReader != null) {
1179             return serviceReader;
1180         }
1181 
1182         String servInfo = tsInfo.get(&quot;serviceReader&quot;);
1183         if (servInfo != null) {
1184             String[] args = servInfo.split(&quot; &quot;);
1185             try {
1186                 Class&lt;? extends ServiceReader&gt; c = loadClass(args[0]);
1187                 serviceReader = newInstance(c);
1188                 if (args.length &gt; 1) {
1189                     // problem with java1.5, which has no Arrays.copyOfRange();
1190                     String[] copy = new String[args.length - 1];
1191                     for (int i = 1; i &lt; args.length; i++) {
1192                         copy[i - 1] = args[i];
1193                     }
1194 
1195                     serviceReader.init(this, copy);
1196                 } else {
1197                     serviceReader.init(this, (String[]) null);
1198                 }
1199             } catch (TestSuite.Fault e) {
1200             }
1201         } else {
1202             serviceReader = new PropertyServiceReader();
1203             serviceReader.init(this, (String[]) null);
1204         }
1205 
1206         return serviceReader;
1207     }
1208 
1209     /**
1210      * Get a map containing the test suite data in the .jtt file.
1211      *
1212      * @return a map containing the test suite data in the .jtt file
1213      */
1214     protected Map&lt;String, String&gt; getTestSuiteInfo() {
1215         return tsInfo;
1216     }
1217 
1218     /**
1219      * Get an entry from the data in the .jtt file.
1220      *
1221      * @param name The name of the entry to get from the info in the .jtt file
1222      * @return the value of the specified entry, or null if not found.
1223      */
1224     public String getTestSuiteInfo(String name) {
1225         if (tsInfo == null) {
1226             return null;
1227         } else {
1228             return tsInfo.get(name);
1229         }
1230     }
1231 
1232     /**
1233      * Get the requested behavior for dealing with conflicts between
1234      * which tests are in the test suite vs those in the work directory.
1235      *
1236      * @see #DELETE_NONTEST_RESULTS
1237      * @see #REFRESH_ON_RUN
1238      * @see #CLEAR_CHANGED_TEST
1239      */
1240     public boolean getTestRefreshBehavior(int event) {
1241         switch (event) {
1242             case DELETE_NONTEST_RESULTS:
1243                 return Boolean.valueOf(getTestSuiteInfo(&quot;deleteNonExistTests&quot;)).booleanValue();
1244             case REFRESH_ON_RUN:
1245                 return Boolean.valueOf(getTestSuiteInfo(&quot;refreshTestsOnRun&quot;)).booleanValue();
1246             case CLEAR_CHANGED_TEST:
1247                 return Boolean.valueOf(getTestSuiteInfo(&quot;clearChangedTests&quot;)).booleanValue();
1248             default:
1249                 return false;
1250         }
1251     }
1252 
1253     /**
1254      * Returns notification logger associated with
1255      * given working directory or common logger if null was specified
1256      *
1257      * @param wd - working directory or null
1258      */
1259     public Logger getNotificationLog(WorkDirectory wd) {
1260         return notifLogger;
1261     }
1262 
1263     public ObservedFile getObservedFile(WorkDirectory wd) {
1264         return getObservedFile(wd.getLogFileName());
1265     }
1266 
1267     public ObservedFile getObservedFile(String path) {
1268         String cPath = new File(path).getAbsolutePath();
1269         if (observedFiles.containsKey(cPath)) {
1270             return (ObservedFile) observedFiles.get(cPath);
1271         }
1272         return null;
1273     }
1274 
1275     void setLogFilePath(WorkDirectory wd) {
1276         ObservedFile f = new ObservedFile(wd.getLogFileName());
1277         if (f.length() != 0) {
1278             f.backup();
1279         }
1280         // return to current
1281         f = new ObservedFile(wd.getLogFileName());
1282 
1283         if (observedFiles == null) {
1284             observedFiles = new HashMap&lt;&gt;();
1285         }
1286         if (!observedFiles.containsKey(f.getAbsolutePath())) {
1287             observedFiles.put(f.getAbsolutePath(), f);
1288         }
1289 
1290     }
1291 
1292     /**
1293      * Creates general purpose logger with given key and ResourceBundleName registered for given WorkDirectory.
1294      *
1295      * @param wd  WorkDirectory logger should be registered for; may be {@code null} if no WorkDirectory
1296      *            currently available (the log will be registered for the first WD created for this TestSuite
1297      * @param b   name of ResorceBundle used for this logger; may be {@code null} if not required
1298      * @param key key for this log
1299      * @return general purpose logger with given key registered for given WorkDirectory or TestSuite (if WD is null)
1300      * @throws TestSuite.DuplicateLogNameFault if log with this key has been registered in the system already
1301      * @see #getLog
1302      */
1303 
1304     public Logger createLog(WorkDirectory wd, String b, String key) throws DuplicateLogNameFault {
1305 
1306         if (key == null || key.isEmpty()) {
1307             throw new IllegalArgumentException(&quot;Log name can not be empty&quot;);
1308         }
1309 
1310         String logName = wd.getLogFileName();
1311 
1312         if (gpls == null) {
1313             gpls = new Vector&lt;&gt;();
1314         }
1315 
1316         for (GeneralPurposeLogger gpl : gpls) {
1317             if (gpl.getName().equals(key) &amp;&amp; gpl.getLogFileName().equals(logName)) {
1318                 throw new DuplicateLogNameFault(i18n, &quot;ts.logger.duplicatelognamefault&quot;, key);
1319             }
1320         }
1321 
1322         GeneralPurposeLogger gpl = new GeneralPurposeLogger(key, wd, b, this);
1323         gpls.add(gpl);
1324         return gpl;
1325     }
1326 
1327     /**
1328      * Returns general purpose logger with given key registered for given WorkDirectory.
1329      * The log should be created first.
1330      *
1331      * @param wd  WorkDirectory desired logger is registered for
1332      * @param key key for this log
1333      * @return general purpose logger with given key registered for given WorkDirectory
1334      * @throws TestSuite.NoSuchLogFault if desired log not registered in the system
1335      * @throws NullPointerException     if {@code wd} is null
1336      * @see #createLog
1337      */
1338     public Logger getLog(WorkDirectory wd, String key) throws NoSuchLogFault {
1339         if (gpls == null) {
1340             throw new NoSuchLogFault(i18n, &quot;ts.logger.nologscreated&quot;, key);
1341         }
1342 
1343         if (wd == null) {
1344             throw new NullPointerException(i18n.getString(&quot;ts.logger.nullwd&quot;));
1345         }
1346 
1347         String logFile = wd.getLogFileName();
1348 
1349         for (GeneralPurposeLogger logger : gpls) {
1350             if (logger.getLogFileName().equals(logFile) &amp;&amp; logger.getName().equals(key)) {
1351                 return logger;
1352             }
1353         }
1354         throw new NoSuchLogFault(i18n, &quot;ts.logger.nosuchlogfault&quot;, key);
1355     }
1356 
1357     /**
1358      * Cleans the log file in given WorkDirectory
1359      *
1360      * @param wd WorkDirectory desired logger is registered for
1361      * @throws IOException if log file&#39;s content can&#39;t be erased
1362      */
1363     public void eraseLog(WorkDirectory wd) throws IOException {
1364         if (wd == null) {
1365             throw new NullPointerException(i18n.getString(&quot;ts.logger.nullwd&quot;));
1366         }
1367 
1368         if (gpls != null) {
1369             for (GeneralPurposeLogger gpl : gpls) {
1370                 if (gpl.getLogFileName().equals(wd.getLogFileName())) {
1371                     Handler[] h = gpl.getHandlers();
1372                     if (h[0] instanceof WorkDirLogHandler) {
1373                         ((WorkDirLogHandler) h[0]).eraseLogFile();
1374                         return;
1375                     }
1376                 }
1377             }
1378         }
1379     }
1380 
1381     /**
1382      * An exception used to report errors while using a TestSUite object.
1383      */
1384     public static class Fault extends Exception {
1385         /**
1386          * Create a Fault.
1387          *
1388          * @param i18n A resource bundle in which to find the detail message.
1389          * @param s    The key for the detail message.
1390          */
1391         public Fault(I18NResourceBundle i18n, String s) {
1392             super(i18n.getString(s));
1393         }
1394 
1395         /**
1396          * Create a Fault.
1397          *
1398          * @param i18n A resource bundle in which to find the detail message.
1399          * @param s    The key for the detail message.
1400          * @param o    An argument to be formatted with the detail message by
1401          *             {@link java.text.MessageFormat#format}
1402          */
1403         public Fault(I18NResourceBundle i18n, String s, Object o) {
1404             super(i18n.getString(s, o));
1405         }
1406 
1407         /**
1408          * Create a Fault.
1409          *
1410          * @param i18n A resource bundle in which to find the detail message.
1411          * @param s    The key for the detail message.
1412          * @param o    An array of arguments to be formatted with the detail message by
1413          *             {@link java.text.MessageFormat#format}
1414          */
1415         public Fault(I18NResourceBundle i18n, String s, Object... o) {
1416             super(i18n.getString(s, o));
1417         }
1418     }
1419 
1420     /**
1421      * An exception that is used to report that a given file is not a test suite.
1422      */
1423     public static class NotTestSuiteFault extends Fault {
1424         /**
1425          * Create a Fault.
1426          *
1427          * @param i18n A resource bundle in which to find the detail message.
1428          * @param s    The key for the detail message.
1429          * @param f    The file in question, to be formatted with the detail message by
1430          *             {@link java.text.MessageFormat#format}
1431          */
1432         public NotTestSuiteFault(I18NResourceBundle i18n, String s, File f) {
1433             super(i18n, s, f.getPath());
1434         }
1435     }
1436 
1437     public static class DuplicateLogNameFault extends Fault {
1438         /**
1439          * Create a Fault.
1440          *
1441          * @param i18n A resource bundle in which to find the detail message.
1442          * @param key  The internal name of the log.
1443          *             {@link java.text.MessageFormat#format}
1444          */
1445         public DuplicateLogNameFault(I18NResourceBundle i18n, String s, String key) {
1446             super(i18n, s, key);
1447         }
1448     }
1449 
1450     public static class NoSuchLogFault extends Fault {
1451         /**
1452          * Create a Fault.
1453          *
1454          * @param i18n A resource bundle in which to find the detail message.
1455          * @param key  The internal name of the log.
1456          *             {@link java.text.MessageFormat#format}
1457          */
1458         public NoSuchLogFault(I18NResourceBundle i18n, String s, String key) {
1459             super(i18n, s, key);
1460         }
1461     }
1462 
1463     private static class NotificationLogger extends Logger {
1464         private NotificationLogger(String resourceBundleName) {
1465             super(notificationLogName, resourceBundleName);
1466             setLevel(Level.CONFIG);
1467             // needs to be reimplemented - this initializes Swing, which is not
1468             // allowed inside the core harness
1469             // should be implemented so that the GUI attaches to the logging system
1470             // on startup
1471             //addHandler(new ErrorDialogHandler());
1472         }
1473 
1474         @Override
1475         public synchronized void log(LogRecord record) {
1476             record.setLoggerName(this.getName());
1477             if (record.getThrown() != null) {
1478                 record.setLevel(Level.INFO);
1479             }
1480             super.log(record);
1481         }
1482 
1483 
1484         // overwrite to make sure exception is handled
1485         @Override
1486         public void throwing(String sourceClass, String sourceMethod, Throwable thrown) {
1487             LogRecord lr = new LogRecord(Level.INFO, &quot;THROW&quot;);
1488             lr.setSourceClassName(sourceClass);
1489             lr.setSourceMethodName(sourceMethod);
1490             lr.setThrown(thrown);
1491             log(lr);
1492         }
1493 
1494     }
1495 
1496     private static class GeneralPurposeLogger extends Logger {
1497         private String logFileName;
1498 
1499         private GeneralPurposeLogger(String name, WorkDirectory wd, String resourceBundleName, TestSuite ts) {
1500             super(name, resourceBundleName);
1501             this.logFileName = wd.getLogFileName();
1502 
1503             if (wd != null) {
1504                 if (!handlersMap.containsKey(wd.getLogFileName())) {
1505                     WorkDirLogHandler wdlh = new WorkDirLogHandler(ts.getObservedFile(wd));
1506                     handlersMap.put(wd.getLogFileName(), wdlh);
1507                 }
1508 
1509                 addHandler(handlersMap.get(wd.getLogFileName()));
1510             }
1511             setLevel(Level.ALL);
1512         }
1513 
1514         @Override
1515         public void log(LogRecord record) {
1516             Handler targets[] = getHandlers();
1517             if (targets != null) {
1518                 for (Handler target : targets) {
1519                     if (target instanceof WorkDirLogHandler) {
1520                         ((WorkDirLogHandler) target).publish(record, getName());
1521                     } else {
1522                         target.publish(record);
1523                     }
1524                 }
1525             }
1526         }
1527 
1528         private String getLogFileName() {
1529             return logFileName;
1530         }
1531     }
1532 
1533 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
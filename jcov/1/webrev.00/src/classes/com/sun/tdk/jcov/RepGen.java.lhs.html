<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/classes/com/sun/tdk/jcov/RepGen.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2014, 2018 Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package com.sun.tdk.jcov;
 26 
 27 import com.sun.tdk.jcov.instrument.DataMethod;
 28 import com.sun.tdk.jcov.instrument.DataClass;
 29 import com.sun.tdk.jcov.instrument.DataField;
 30 import com.sun.tdk.jcov.processing.DataProcessorSPI;
 31 import com.sun.tdk.jcov.report.AncFilter;
 32 import com.sun.tdk.jcov.report.ParameterizedAncFilter;
 33 import com.sun.tdk.jcov.report.AncFilterFactory;
 34 import com.sun.tdk.jcov.util.Utils;
 35 import com.sun.tdk.jcov.data.FileFormatException;
 36 import com.sun.tdk.jcov.data.Result;
 37 import com.sun.tdk.jcov.instrument.DataRoot;
 38 import com.sun.tdk.jcov.processing.ProcessingException;
 39 
 40 import com.sun.tdk.jcov.tools.EnvHandler;
 41 import com.sun.tdk.jcov.tools.OptionDescr;
 42 import com.sun.tdk.jcov.io.Reader;
 43 import com.sun.tdk.jcov.filter.ConveyerFilter;
 44 import com.sun.tdk.jcov.filter.MemberFilter;
 45 import com.sun.tdk.jcov.filter.FilterFactory;
 46 import com.sun.tdk.jcov.instrument.InstrumentationOptions;
 47 import com.sun.tdk.jcov.io.ClassSignatureFilter;
 48 import com.sun.tdk.jcov.processing.DefaultDataProcessorSPI;
 49 import com.sun.tdk.jcov.processing.StubSpi;
 50 import com.sun.tdk.jcov.report.DefaultReportGeneratorSPI;
 51 import com.sun.tdk.jcov.report.ProductCoverage;
 52 import com.sun.tdk.jcov.report.ReportGenerator;
 53 import com.sun.tdk.jcov.report.ReportGeneratorSPI;
 54 import com.sun.tdk.jcov.report.SmartTestService;
 55 import com.sun.tdk.jcov.report.javap.JavapClass;
 56 import com.sun.tdk.jcov.report.javap.JavapRepGen;
 57 import com.sun.tdk.jcov.tools.JCovCMDTool;
 58 import com.sun.tdk.jcov.tools.SPIDescr;
 59 import java.io.IOException;
 60 import java.util.ArrayList;
 61 import java.util.ServiceLoader;
 62 import java.util.logging.Level;
 63 import java.util.logging.Logger;
 64 
 65 import static com.sun.tdk.jcov.tools.OptionDescr.*;
 66 import java.io.File;
 67 import java.util.Arrays;
 68 import java.util.List;
 69 import org.objectweb.asm.Opcodes;
 70 
 71 /**
 72  * &lt;p&gt; Report generation. &lt;/p&gt;
 73  *
 74  * @author Andrey Titov
 75  * @author Dmitry Fazunenko
 76  * @author Alexey Fedorchenko
 77  */
 78 public class RepGen extends JCovCMDTool {
 79 
 80     final static String CUSTOM_REPORT_GENERATOR_SPI = &quot;customreport.spi&quot;;
 81     final static String DATA_PROCESSOR_SPI = &quot;dataprocessor.spi&quot;;
 82     private static final String ANC_FILTER_PARAMETER_SEPARATOR = &quot;:&quot;;
 83 
 84     // logger initialization
 85     static {
 86         Utils.initLogger();
 87         logger = Logger.getLogger(RepGen.class.getName());
 88     }
 89     private final static Logger logger;
 90     /**
 91      * Consider or not enums. true - means ignore enum classes.
 92      */
 93     private boolean noEnums = false;
 94     /**
 95      * Whether show or not field coverage in the report (false by default).
 96      */
 97     private boolean showFields = false;
 98     private ReportGeneratorSPI reportGeneratorSPIs[];
 99     private DataProcessorSPI dataProcessorSPIs[];
100     private String[] include = new String[]{&quot;.*&quot;};
101     private String[] exclude = new String[]{&quot;&quot;};
102     private String[] m_include = new String[]{&quot;.*&quot;};
103     private String[] m_exclude = new String[]{&quot;&quot;};
104     private String[] fms = null;
105     private String filter = null;
106     private String[] ancfilters = null;
107     private String[] ancdeffilters = null;
108     private boolean noAbstract = false;
109     private boolean syntheticOn = false;
110     private boolean isPublicAPI = false;
111     private String[] filenames;
112     private String name;
113     private String outputDir;
114     private String testlist;
115     private String srcRootPath;
116     private boolean anonym = false;
117     private boolean withTestsInfo = false;
118     //path to the jar, dir or .class for javap repgen
119     private String classesPath;
120     private AncFilter[] ancfiltersClasses = null;
121     private String mainReportTitle = null;
122     private String overviewListTitle = null;
123     private String entitiesTitle = null;
124 
125     public RepGen() {
126         readPlugins = true;
127     }
128 
129     /**
130      * Generate report using default (html) report generator
131      *
132      * @param output
133      * @param jcovResult
134      * @throws ProcessingException
135      * @throws FileFormatException
136      * @throws Exception
137      */
138     public void generateReport(String output, Result jcovResult) throws ProcessingException, FileFormatException, Exception {
139         generateReport(getDefaultReportGenerator(), output, jcovResult, null);
140     }
141 
142     /**
143      * Generate report using specified format
144      *
145      * @param format
146      * @param output
147      * @param jcovResult
148      * @throws ProcessingException
149      * @throws FileFormatException
150      * @throws Exception
151      */
152     public void generateReport(String format, String output, Result jcovResult) throws ProcessingException, FileFormatException, Exception {
153         generateReport(format, output, jcovResult, null);
154     }
155 
156     /**
157      * Generate report using specified format
158      *
159      * @param format
160      * @param output
161      * @param jcovResult
162      * @param srcRootPath
163      * @throws ProcessingException
164      * @throws FileFormatException
165      * @throws Exception
166      */
167     public void generateReport(String format, String output, Result jcovResult, String srcRootPath) throws ProcessingException, FileFormatException, Exception {
168         ReportGenerator rg = null;
169         if (format != null) {
170             rg = findReportGenerator(format);
171         } else {
172             rg = getDefaultReportGenerator();
173         }
174         if (rg == null) {
175             throw new Exception(&quot;Specified ReportGenerator name (&quot; + format + &quot;) was not found&quot;);
176         }
177 
178         generateReport(rg, output, jcovResult, srcRootPath);
179     }
180 
181     /**
182      * Generate report using specified report generator
183      *
184      * @param rg
185      * @param output
186      * @param jcovResult
187      * @param srcRootPath
188      * @throws ProcessingException
189      * @throws FileFormatException
190      * @throws Exception
191      */
192     public void generateReport(ReportGenerator rg, String output, Result jcovResult, String srcRootPath) throws ProcessingException, FileFormatException, Exception {
193         generateReport(rg, output, jcovResult, srcRootPath, null);
194     }
195 
196     /**
197      * Generate report using specified report generator
198      *
199      * @param rg
200      * @param output
201      * @param jcovResult
202      * @param srcRootPath
203      * @param classes parsed javap classes
204      * @throws ProcessingException
205      * @throws FileFormatException
206      * @throws Exception
207      */
208     public void generateReport(ReportGenerator rg, String output, Result jcovResult, String srcRootPath, List&lt;JavapClass&gt; classes) throws ProcessingException, FileFormatException, Exception {
209         try {
210             logger.log(Level.INFO, &quot;-- Writing report to {0}&quot;, output);
211             rg.init(output);
212             logger.fine(&quot;OK&quot;);
213         } catch (Throwable ex) {
214             logger.log(Level.SEVERE, &quot;Error while reading output file by ReportGenerator &quot; + rg.getClass().getName(), ex);
215             return;
216         }
217 
218         logger.log(Level.INFO, &quot;-- Reading data from {0}&quot;, jcovResult.getResultPath());
219         DataRoot file_image = readDataRootFile(jcovResult.getResultPath(), jcovResult.isTestListSet(), include, exclude, fms);
220 
221         if (!syntheticOn) {
222             file_image.applyFilter(new ANC_FILTER());
223         }
224 
225         MemberFilter customFilter = null;
226         if (filter != null) {
227             logger.fine(&quot;-- Initializing custom filter&quot;);
228             customFilter = initCustomFilter(filter, null);
229             logger.fine(&quot;OK&quot;);
230         }
231         if (customFilter != null) {
232             logger.log(Level.INFO, &quot;-- Applying filter {0}&quot;, customFilter.getClass().getName());
233             file_image.applyFilter(customFilter);
234             logger.fine(&quot;OK&quot;);
235         }
236 
237         if (ancfilters != null){
238             ancfiltersClasses = new AncFilter[ancfilters.length];
239             for (int i = 0; i &lt; ancfilters.length; i++) {
240                 try {
241                     String ancfilter = ancfilters[i];
242                     Class ancFilteClass = Class.forName(ancfilter);
<a name="2" id="anc2"></a><span class="line-modified">243                     ancfiltersClasses[i] = (AncFilter) ancFilteClass.newInstance();</span>
244                 } catch (Exception e) {
245                     throw new Error(&quot;Cannot create an instance of &quot;
246                             + &quot;AncFilter: &quot;, e);
247                 }
248             }
249         }
250 
251         if (ancdeffilters != null) {
252             ServiceLoader&lt;AncFilterFactory&gt; loader = ServiceLoader.load(AncFilterFactory.class);
253             List&lt;AncFilter&gt; defaultANCFiltersList = new ArrayList&lt;AncFilter&gt;();
254             if (ancfiltersClasses != null &amp;&amp; ancfiltersClasses.length &gt; 0) {
255                 defaultANCFiltersList.addAll(Arrays.asList(ancfiltersClasses));
256             }
257             if (ancdeffilters.length == 1 &amp;&amp; ancdeffilters[0].equals(&quot;all&quot;)) {
258                 for (AncFilterFactory factory : loader) {
259                     defaultANCFiltersList.addAll(factory.instantiateAll());
260                 }
261             } else {
262                 for (String defaulAncFilter : ancdeffilters) {
263                     boolean found = false;
264                     String filterName, filterParameters;
265                     int separatorPosition = defaulAncFilter.indexOf(ANC_FILTER_PARAMETER_SEPARATOR);
266                     if (separatorPosition &gt; -1) {
267                         filterName = defaulAncFilter.substring(0, separatorPosition);
268                         filterParameters = defaulAncFilter.substring(separatorPosition +
269                                 ANC_FILTER_PARAMETER_SEPARATOR.length());
270                     } else {
271                         filterName = defaulAncFilter;
272                         filterParameters = null;
273                     }
274                     for (AncFilterFactory factory : loader) {
275                         AncFilter filter = factory.instantiate(filterName);
276                         if (filter != null) {
277                             if (filterParameters != null) {
278                                 if (filter instanceof ParameterizedAncFilter) {
279                                     try {
280                                         ((ParameterizedAncFilter) filter).setParameter(filterParameters);
281                                     } catch (Exception e) {
282                                         throw new RuntimeException(&quot;Unable to set parameter for filter &quot; +
283                                                 filterName + &quot;:&quot; + e.getMessage());
284                                     }
285                                 } else {
286                                     throw new RuntimeException(filterName + &quot; filter does not accept parameters: &quot; + filter);
287                                 }
288                             }
289                             found = true;
290                             defaultANCFiltersList.add(filter);
291                             break;
292                         }
293                     }
294                     if (!found) {
295                         throw new RuntimeException(&quot;There is no ANC filter for \&quot;&quot; + defaulAncFilter + &quot;\&quot; value&quot;);
296                     }
297                 }
298             }
299             ancfiltersClasses = defaultANCFiltersList.toArray(new AncFilter[defaultANCFiltersList.size()]);
300         }
301 
302         if (dataProcessorSPIs != null) {
303             for (DataProcessorSPI spi : dataProcessorSPIs) {
304                 logger.log(Level.INFO, &quot;-- Applying data processor {0}&quot;, spi.getClass());
305                 file_image = spi.getDataProcessor().process(file_image);
306             }
307         }
308         logger.fine(&quot;OK&quot;);
309 
310         SmartTestService sts = null;
311         if (jcovResult.isTestListSet()) {
312             logger.fine(&quot;-- Initializing test list&quot;);
313             sts = new SmartTestService(jcovResult.getTestList());
314             if (file_image.getScaleOpts().getScaleSize() != sts.getTestCount()) {
315                 logger.log(Level.SEVERE, &quot;The sizes of tests in JCov file and in test list differ.\n&quot;
316                         + &quot;Datafile {0} contains {1} item(s).\nThe test list contains {2} item(s).&quot;,
317                         new Object[]{jcovResult.getResultPath(), file_image.getScaleOpts().getScaleSize(), sts.getTestCount()});
318                 throw new Exception(&quot;The sizes of tests in JCov file and in test list differ&quot;);
319             }
320             logger.fine(&quot;OK&quot;);
321         }
322         ReportGenerator.Options options = new ReportGenerator.Options(srcRootPath, sts, classes, withTestsInfo, false,
323                 mainReportTitle, overviewListTitle, entitiesTitle);
324         options.setInstrMode(file_image.getParams().getMode());
325         options.setAnonymOn(anonym);
326 
327         try {
328             ProductCoverage coverage = new ProductCoverage(file_image, options.getSrcRootPaths(), options.getJavapClasses(), isPublicAPI, noAbstract, anonym, ancfiltersClasses);
<a name="3" id="anc3"></a><span class="line-modified">329 </span>
<span class="line-removed">330             logger.log(Level.INFO, &quot;- Starting ReportGenerator {0}&quot;, rg.getClass().getName());</span>
331             rg.generateReport(coverage, options);
<a name="4" id="anc4"></a><span class="line-modified">332         } catch (Throwable ex) {</span>
<span class="line-modified">333             if (ex.getMessage() != null) {</span>
<span class="line-removed">334                 throw new Exception(&quot;ReportGenerator produced exception &quot; + ex.getMessage(), ex);</span>
<span class="line-removed">335             } else {</span>
<span class="line-removed">336                 throw new Exception(&quot;ReportGenerator produced exception &quot; + ex, ex);</span>
<span class="line-removed">337             }</span>
338         }
<a name="5" id="anc5"></a><span class="line-modified">339 </span>
<span class="line-removed">340         logger.log(Level.INFO, &quot;- Report generation done&quot;);</span>
341         return;
342     }
343 
344     /**
345      * Get default (html) report generator
346      *
347      * @return default (html) report generator
348      */
349     public ReportGenerator getDefaultReportGenerator() {
350         return findReportGenerator(&quot;html&quot;);
351     }
352 
353     private ReportGenerator findReportGenerator(String name) {
354         ReportGenerator rg = null;
355         if (reportGeneratorSPIs != null) {
356             for (ReportGeneratorSPI reportGeneratorSPI : reportGeneratorSPIs) {
357                 rg = reportGeneratorSPI.getReportGenerator(name);
358                 if (rg != null) {
359                     return rg;
360                 }
361             }
362         }
363         return new DefaultReportGeneratorSPI().getReportGenerator(name); // can be null
364     }
365 
366     protected DataRoot readDataRootFile(String filename, boolean readScales, String[] include, String[] exclude, String[] modif) throws FileFormatException {
<a name="6" id="anc6"></a><span class="line-removed">367         DataRoot file_image = null;</span>
368         ClassSignatureFilter acceptor = new ClassSignatureFilter(include, exclude, m_include, m_exclude, modif);
<a name="7" id="anc7"></a><span class="line-modified">369         file_image = Reader.readXML(filename, readScales, acceptor);</span>
370         return file_image;
371     }
372 
373     /**
374      * Legacy CMD line entry poiny (use &#39;java -jar jcov.jar Merger&#39; from cmd
375      * instead of &#39;java -cp jcov.jar com.sun.tdk.jcov.Merger&#39;)
376      *
377      * @param args
378      */
379     public static void main(String args[]) {
380         RepGen tool = new RepGen();
381         try {
382             int res = tool.run(args);
383             System.exit(res);
384         } catch (Exception ex) {
385             System.exit(1);
386         }
387     }
388 
389     protected String usageString() {
390         return &quot;java com.sun.tdk.jcov.RepGen [options] filename&quot;;
391     }
392 
393     protected String exampleString() {
394         return &quot;java -cp jcov.jar com.sun.tdk.jcov.RepGen -include java.lang.* -format html -output out result.xml&quot;;
395     }
396 
397     protected String getDescr() {
398         return &quot;generates text or HTML (or custom) reports&quot;;
399     }
400 
401     private MemberFilter createCustomFilter(String spiName) {
402         return FilterFactory.
403                 getInstance(spiName).getMemberFilter();
404 
405     }
406 
407     private MemberFilter initCustomFilter(String filter, String sig) {
408         MemberFilter customPlugin = null;
409         MemberFilter sigFilter = null;
410 
411         if (filter != null) {
412             customPlugin = createCustomFilter(filter);
413         }
414         if (customPlugin == null &amp;&amp; sigFilter == null) {
415             return null;
416         } else if (customPlugin != null &amp;&amp; sigFilter != null) {
417             ConveyerFilter f = new ConveyerFilter();
418             f.add(sigFilter);
419             f.add(customPlugin);
420             return f;
421         } else {
422             return sigFilter != null ? sigFilter : customPlugin;
423         }
424 
425     }
426 
427     public void setReportGeneratorSPIs(ReportGeneratorSPI reportGeneratorSPI[]) {
428         this.reportGeneratorSPIs = reportGeneratorSPI;
429     }
430 
431     public ReportGeneratorSPI[] getReportGeneratorSPIs() {
432         return reportGeneratorSPIs;
433     }
434 
435     public String getFilter() {
436         return filter;
437     }
438 
439     public void setFilter(String filter) {
440         this.filter = filter;
441     }
442 
443     public String[] getFms() {
444         return fms;
445     }
446 
447     public void setFms(String[] fms) {
448         this.fms = fms;
449     }
450 
451     public String[] getInclude() {
452         return include;
453     }
454 
455     public void setInclude(String[] include) {
456         this.include = include;
457     }
458 
459     public boolean isIsPublicAPI() {
460         return isPublicAPI;
461     }
462 
463     public void setIsPublicAPI(boolean isPublicAPI) {
464         this.isPublicAPI = isPublicAPI;
465     }
466 
467     public boolean isNoAbstract() {
468         return noAbstract;
469     }
470 
471     public void setNoAbstract(boolean noAbstract) {
472         this.noAbstract = noAbstract;
473     }
474 
475     public boolean isSyntheticOn() {
476         return syntheticOn;
477     }
478 
479     public void setNoANC(boolean syntheticOn) {
480         this.syntheticOn = syntheticOn;
481     }
482 
483     public boolean isWithTestsInfo() {
484         return withTestsInfo;
485     }
486 
487     public void setWithTestsInfo(boolean withTestsInfo) {
488         this.withTestsInfo = withTestsInfo;
489     }
490 
491     public boolean isNoEnums() {
492         return noEnums;
493     }
494 
495     public void setNoEnums(boolean noEnums) {
496         this.noEnums = noEnums;
497     }
498 
499     public boolean isShowFields() {
500         return showFields;
501     }
502 
503     public void setShowFields(boolean showFields) {
504 //        this.showFields = showFields;
505     }
506 
507     public String[] getExclude() {
508         return exclude;
509     }
510 
511     public void setExclude(String[] exclude) {
512         this.exclude = exclude;
513     }
514 
515     public String getSrcRootPath() {
516         return srcRootPath;
517     }
518 
519     public void setDataProcessorsSPIs(DataProcessorSPI[] dataProcessorSPIs){
520         this.dataProcessorSPIs = dataProcessorSPIs;
521     }
522 
523     /**
524      * Reset all properties to defaults. reportGeneratorSPI = null; include =
525      * new String[] {&quot;.*&quot;}; exclude = new String[] {&quot;&quot;}; fms = null; filter =
526      * null; generateShortFormat = false; noAbstract = false; isPublicAPI =
527      * false; showMethods = true; showBlocks = true; showBranches = true;
528      * showLines = true;
529      */
530     public void resetDefaults() {
531         try {
532             handleEnv_(defineHandler());
533             reportGeneratorSPIs = null;
534             //setFilters(new String[]{&quot;.*&quot;}, new String[]{&quot;&quot;}, null);
535             setNoAbstract(false);
536             setIsPublicAPI(false);
537         } catch (EnvHandlingException ex) {
538             // should not happen
539         }
540     }
541 
542     /**
543      * Set all properties (except custorm report service provider)
544      *
545      * @param include patterns for including data. Set null for default value -
546      * {&quot;.*&quot;} (include all)
547      * @param exclude patterns for excluding data. Set null for default value -
548      * {&quot;&quot;} (exclude nothing)
549      * @param classModifiers modifiers that should have a class to be included
550      * @param filter custom filter classname
551      * @param generateShortFormat should generate short format
552      * @param publicAPI should generate only public API (public and protected)
553      * @param hideAbstract should hide abstract data
554      * @param hideMethods should hide methods
555      * @param hideBlocks should hide blocks
556      * @param hideBranches should hide branches
557      * @param hideLines should hide lines
558      */
559     public void configure(String[] include, String[] exclude, String[] classModifiers,
560             String filter, boolean generateShortFormat, boolean publicAPI, boolean hideAbstract,
561             boolean hideMethods, boolean hideBlocks, boolean hideBranches, boolean hideLines,
562             boolean hideFields) {
563         setFilters(include, exclude, classModifiers);
564         setFilter(filter);
565         this.isPublicAPI = publicAPI;
566 //        this.showFields = !hideFields;
567     }
568 
569     /**
570      * Set filtering properties for the report
571      *
572      * @param include patterns for including data. Set null for default value -
573      * {&quot;.*&quot;} (include all)
574      * @param exclude patterns for excluding data. Set null for default value -
575      * {&quot;&quot;} (exclude nothing)
576      * @param classModifiers modifiers that should have a class to be included
577      */
578     public void setFilters(String[] include, String[] exclude, String[] classModifiers) {
579         if (include == null) {
580             include = new String[]{&quot;.*&quot;};
581         }
582         this.include = include;
583         if (exclude == null) {
584             exclude = new String[]{&quot;&quot;};
585         }
586         this.exclude = exclude;
587         this.fms = classModifiers;
588     }
589 
590     @Override
591     protected int run() throws Exception {
592         Result r;
593         boolean srcZipped = false;
594         if (srcRootPath != null) {
595             File srcRootPathFile = new File(srcRootPath);
596 
597             if (srcRootPathFile.exists() &amp;&amp; srcRootPathFile.isFile() &amp;&amp; (srcRootPath.endsWith(&quot;.zip&quot;) || srcRootPath.endsWith(&quot;.jar&quot;))) {
598                 srcZipped = true;
599                 srcRootPath = outputDir + File.separator + srcRootPathFile.getName().replace(&quot;.zip&quot;, &quot;&quot;).replace(&quot;.jar&quot;, &quot;&quot;);
600                 Utils.unzipFolder(srcRootPathFile, srcRootPath);
601             }
602         }
603 
604         try {
605 
606             logger.log(Level.INFO, &quot;-- Reading test list&quot;);
607             if (filenames.length == 1) {
608                 r = new Result(filenames[0], testlist);
609             } else {
610                 Merger merger = new Merger();
611                 Result[] results = Merger.initResults(filenames, true);
612                 Merger.Merge merge = new Merger.Merge(results, null);
613                 merger.setAddMissing(true);
614                 merger.setRead_scales(true);
615                 merger.setDefaultReadingFilter(include, exclude, m_include, m_exclude, fms);
616                 merger.merge(merge, outputDir, true);
617 
618                 ReportGenerator rg;
619                 if (name != null) {
620                     rg = findReportGenerator(name);
621                 } else {
622                     rg = getDefaultReportGenerator();
623                 }
624                 if (rg == null) {
625                     throw new Exception(&quot;Specified ReportGenerator name (&quot; + name + &quot;) was not found&quot;);
626                 }
627                 rg.init(outputDir);
628                 String[] tl = testlist != null ? Utils.readLines(testlist) : merge.getResultTestList();
629                 SmartTestService sts = new SmartTestService(tl);
630                 ReportGenerator.Options options = new ReportGenerator.Options(srcRootPath, sts, null, true, true,
631                         mainReportTitle, overviewListTitle, entitiesTitle);
632                 try {
633                     DataRoot mergedResult = merge.getResult();
634                     if (!syntheticOn) {
635                         mergedResult.applyFilter(new ANC_FILTER());
636                     }
637 
638                     if (dataProcessorSPIs != null) {
639                         for (DataProcessorSPI spi : dataProcessorSPIs) {
640                             logger.log(Level.INFO, &quot;-- Applying data processor {0}&quot;, spi.getClass());
641                             mergedResult = spi.getDataProcessor().process(mergedResult);
642                         }
643                     }
644 
645                     ProductCoverage coverage = new ProductCoverage(mergedResult, options.getSrcRootPaths(), null, isPublicAPI, noAbstract, ancfiltersClasses);
646                     rg.generateReport(coverage, options);
647 
648                     if (srcZipped) {
649                         Utils.deleteDirectory(new File(srcRootPath));
650                     }
651 
652                 } catch (Throwable ex) {
653                     if (ex.getMessage() != null) {
654                         throw new Exception(&quot;ReportGenerator produced exception &quot; + ex.getMessage(), ex);
655                     } else {
656                         throw new Exception(&quot;ReportGenerator produced exception &quot; + ex, ex);
657                     }
658                 }
659 
<a name="8" id="anc8"></a><span class="line-modified">660                 return 0;</span>
661             }
662         } catch (IOException ex) {
663             logger.log(Level.SEVERE, &quot;Error while reading testlist&quot;, ex);
<a name="9" id="anc9"></a><span class="line-modified">664             return 1;</span>
665         }
666 
667         if (classesPath != null) {
668             try {
669                 logger.log(Level.INFO, &quot;-- Creating javap report&quot;);
670                 setDataProcessorsSPIs(null);
671                 new JavapRepGen(this).run(filenames[0], classesPath, outputDir);
<a name="10" id="anc10"></a><span class="line-modified">672                 return 0;</span>
673             } catch (Exception ex) {
674                 logger.log(Level.SEVERE, &quot;Error while creating javap report&quot;, ex);
<a name="11" id="anc11"></a><span class="line-modified">675                 return 1;</span>
676             }
677         }
678 
679         try {
680             generateReport(name, outputDir, r, srcRootPath);
681 
682             if (srcZipped) {
683                 Utils.deleteDirectory(new File(srcRootPath));
684             }
685 
686             return 0;
687         } catch (FileFormatException e) {
<a name="12" id="anc12"></a><span class="line-removed">688 //            logger.log(Level.SEVERE, &quot;malformed jcov file \&quot;{0}&quot;, filename);</span>
689             logger.log(Level.SEVERE, e.getMessage(), Arrays.toString(filenames));
<a name="13" id="anc13"></a><span class="line-removed">690         } catch (ProcessingException ex) {</span>
691         } catch (Exception ex) {
692             logger.log(Level.SEVERE, ex.getMessage(), ex);
693         }
694         return SUCCESS_EXIT_CODE;
695     }
696 
697     @Override
698     protected EnvHandler defineHandler() {
699         EnvHandler envHandler = new EnvHandler(new OptionDescr[]{
700                     DSC_FMT,
701                     DSC_OUTPUT,
702                     //            DSC_STDOUT,
703                     com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_INCLUDE,
704                     com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_EXCLUDE,
705                     com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_INCLUDE_LIST,
706                     com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_EXCLUDE_LIST,
707                     com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_MINCLUDE_LIST,
708                     com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_MEXCLUDE_LIST,
709                     com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_MINCLUDE,
710                     com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_MEXCLUDE,
711                     com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_FM,
712                     com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_FM_LIST,
713                     DSC_NO_ABSTRACT,
714                     DSC_SYNTHETIC_ON,
715                     DSC_PUBLIC_API,
716                     DSC_SRC_ROOT,
717                     DSC_VERBOSE,
718                     DSC_FILTER_PLUGIN,
719                     DSC_ANC_FILTER_PLUGINS,
720                     DSC_ANC_DEFAULT_FILTERS,
721                     DSC_TEST_LIST,
722                     DSC_ANONYM,
723                     DSC_JAVAP,
724                     DSC_TESTS_INFO,
725                     DSC_REPORT_TITLE_MAIN,
726                     DSC_REPORT_TITLE_OVERVIEW,
727                     DSC_REPORT_TITLE_ENTITIES,}, this);
728         SPIDescr spiDescr = new SPIDescr(CUSTOM_REPORT_GENERATOR_SPI, ReportGeneratorSPI.class);
729         spiDescr.setDefaultSPI(new DefaultReportGeneratorSPI());
730         envHandler.registerSPI(spiDescr);
731 
732         spiDescr = new SPIDescr(DATA_PROCESSOR_SPI, DataProcessorSPI.class);
733         spiDescr.addPreset(&quot;none&quot;, new StubSpi());
734         spiDescr.setDefaultSPI(new DefaultDataProcessorSPI());
735         envHandler.registerSPI(spiDescr);
736 
737         return envHandler;
738     }
739 
740     private int handleEnv_(EnvHandler opts) throws EnvHandlingException {
741         if (opts.isSet(DSC_VERBOSE)) {
742 //            LoggingFormatter.printStackTrace = true; // by default logger doesn&#39;t print stacktrace
743             logger.setLevel(Level.INFO);
744         } else {
745             logger.setLevel(Level.SEVERE);
746         }
747 
748         name = opts.getValue(DSC_FMT);
749         outputDir = opts.getValue(DSC_OUTPUT);
750         // no check for output
751 
752         filter = opts.getValue(DSC_FILTER_PLUGIN);
753         ancfilters = opts.getValues(DSC_ANC_FILTER_PLUGINS);
754         ancdeffilters = opts.getValues(DSC_ANC_DEFAULT_FILTERS);
755         noAbstract = opts.isSet(DSC_NO_ABSTRACT);
756         isPublicAPI = opts.isSet(DSC_PUBLIC_API);
757         anonym = opts.isSet(DSC_ANONYM);
758         syntheticOn = opts.isSet(DSC_SYNTHETIC_ON);
759 
760         include = InstrumentationOptions.handleInclude(opts);
761         exclude = InstrumentationOptions.handleExclude(opts);
762         fms = InstrumentationOptions.handleFM(opts);
763 
764         m_include = InstrumentationOptions.handleMInclude(opts);
765         m_exclude = InstrumentationOptions.handleMExclude(opts);
766 
767         testlist = opts.getValue(DSC_TEST_LIST);
768         Utils.checkFileCanBeNull(testlist, &quot;testlist filename&quot;, Utils.CheckOptions.FILE_EXISTS, Utils.CheckOptions.FILE_CANREAD, Utils.CheckOptions.FILE_ISFILE);
769 
770         withTestsInfo = opts.isSet(DSC_TESTS_INFO);
771 
772         srcRootPath = null;
773         if (opts.isSet(DSC_SRC_ROOT)) {
774             srcRootPath = opts.getValue(DSC_SRC_ROOT);
775         }
776 
777         if (opts.isSet(DSC_REPORT_TITLE_MAIN)){
778             mainReportTitle = opts.getValue(DSC_REPORT_TITLE_MAIN);
779         }
780         if (opts.isSet(DSC_REPORT_TITLE_OVERVIEW)){
781             overviewListTitle = opts.getValue(DSC_REPORT_TITLE_OVERVIEW);
782         }
783         if (opts.isSet(DSC_REPORT_TITLE_ENTITIES)){
784             entitiesTitle = opts.getValue(DSC_REPORT_TITLE_ENTITIES);
785         }
786 
787         ArrayList&lt;ReportGeneratorSPI&gt; reportGenerators = opts.getSPIs(ReportGeneratorSPI.class);
788         if (reportGenerators != null) {
789             reportGeneratorSPIs = reportGenerators.toArray(new ReportGeneratorSPI[reportGenerators.size()]);
790         }
791         ArrayList&lt;DataProcessorSPI&gt; dataProcessors = opts.getSPIs(DataProcessorSPI.class);
792         if (dataProcessors != null) {
793             dataProcessorSPIs = dataProcessors.toArray(new DataProcessorSPI[dataProcessors.size()]);
794         }
795 
796         classesPath = opts.getValue(DSC_JAVAP);
797 
798         return SUCCESS_EXIT_CODE;
799     }
800 
801     @Override
802     protected int handleEnv(EnvHandler opts) throws EnvHandlingException {
803         String[] srcs = opts.getTail();
804         if (srcs == null) {
805             throw new EnvHandlingException(&quot;no input files specified&quot;);
806         }
807 
808         filenames = srcs;
809         Utils.checkFileNotNull(filenames[0], &quot;JCov datafile&quot;, Utils.CheckOptions.FILE_EXISTS, Utils.CheckOptions.FILE_CANREAD, Utils.CheckOptions.FILE_ISFILE);
810         /*if (srcs.length &gt; 1) {
811          logger.log(Level.WARNING,&quot;only \&quot;{0}\&quot; will be processed, the rest of the files will be ignored\n&quot; +
812          &quot;\tto generate report for all files, merge them into one using the merger utility&quot;, filename);
813          }*/
814 
815         return handleEnv_(opts);
816     }
817 
818     public static class ANC_FILTER implements MemberFilter {
819 
820         @Override
821         public boolean accept(DataClass clz) {
822             return true;
823         }
824 
825         @Override
826         public boolean accept(DataClass clz, DataMethod m) {
827 
828             boolean ancMethod;
829 
830             //Synthetic method (and Bridge method)
831             ancMethod = ((m.getAccess() &amp; Opcodes.ACC_SYNTHETIC) != 0);
832 
833             //Enum method
834             ancMethod = ancMethod
835                     || (clz.getSuperName().equals(&quot;java/lang/Enum&quot;) &amp;&amp; (m.getName().equals(&quot;valueOf&quot;) || m.getName().equals(&quot;values&quot;)));
836 
837             return !ancMethod || m.getName().startsWith(&quot;lambda$&quot;);
838 
839         }
840 
841         @Override
842         public boolean accept(DataClass clz, DataField f) {
843             return true;
844         }
845     }
846     final static OptionDescr DSC_FMT =
847             new OptionDescr(&quot;format&quot;, new String[]{&quot;fmt&quot;},
848             &quot;Report generation output.&quot;, VAL_SINGLE,
849             &quot;Specifies the format of the report.\n&quot;
850             + &quot;Use \&quot;text\&quot; for generate text report and \&quot;html\&quot; for generate HTML report\n&quot;
851             + &quot;Text report in one file which contains method/block/branch coverage information.\n&quot;
852             + &quot;HTML report contains coverage information with marked-up sources.\n\n&quot;
853             + &quot;Custom reports can be specified with ReportGeneratorSPI interface.&quot;, &quot;html&quot;);
854     /**
855      *
856      */
857     public final static OptionDescr DSC_OUTPUT =
858             new OptionDescr(&quot;repgen.output&quot;, new String[]{&quot;output&quot;, &quot;o&quot;}, &quot;&quot;, OptionDescr.VAL_SINGLE,
859             &quot;Output directory for generating text and HTML reports.&quot;, &quot;report&quot;);
860     /**
861      *
862      */
863     public final static OptionDescr DSC_TEST_LIST =
864             new OptionDescr(&quot;tests&quot;, &quot;Test list&quot;, OptionDescr.VAL_SINGLE,
865             &quot;Specify the path to the file containing test list. File should contain a list of tests\n&quot;
866             + &quot;with one name per line.&quot;);
867     final static OptionDescr DSC_FILTER_PLUGIN =
868             new OptionDescr(&quot;filter&quot;, &quot;&quot;, OptionDescr.VAL_SINGLE,
869             &quot;Custom filtering plugin class&quot;);
870 
871     final static OptionDescr DSC_ANC_FILTER_PLUGINS =
872             new OptionDescr(&quot;ancfilter&quot;, new String[]{&quot;ancf&quot;}, &quot;Custom anc filtering plugin classes&quot;, OptionDescr.VAL_MULTI,
873                     &quot;&quot;);
874 
875     final static OptionDescr DSC_ANC_DEFAULT_FILTERS =
876             new OptionDescr(&quot;ancdeffilters&quot;, new String[]{&quot;ancdf&quot;}, &quot;Default ANC filter name to use in report&quot;, OptionDescr.VAL_MULTI,
877                     &quot;&quot;);
878 
879     /**
880      *
881      */
882     public final static OptionDescr DSC_SRC_ROOT =
883             new OptionDescr(&quot;sourcepath&quot;, new String[]{&quot;source&quot;, &quot;src&quot;}, &quot;The source files.&quot;, OptionDescr.VAL_SINGLE, &quot;&quot;);
884     final static OptionDescr DSC_VERBOSE =
885             new OptionDescr(&quot;verbose&quot;, &quot;Verbosity.&quot;, &quot;Enable verbose mode.&quot;);
886     /**
887      *
888      */
889     public final static OptionDescr DSC_NO_ABSTRACT =
890             new OptionDescr(&quot;noabstract&quot;, &quot;Additional filtering&quot;, &quot;Do not count abstract methods&quot;);
891     public final static OptionDescr DSC_SYNTHETIC_ON =
892             new OptionDescr(&quot;syntheticon&quot;, &quot;Additional filtering&quot;, &quot;Count coverage for synthetic methods&quot;);
893     /**
894      *
895      */
896     public final static OptionDescr DSC_PUBLIC_API =
897             new OptionDescr(&quot;publicapi&quot;, &quot;&quot;, &quot;Count only public and protected members&quot;);
898     public final static OptionDescr DSC_ANONYM =
899             new OptionDescr(&quot;anonym&quot;, &quot;&quot;, &quot;include methods from anonymous classes into the report&quot;);
900     public final static OptionDescr DSC_JAVAP =
901             new OptionDescr(&quot;javap&quot;, new String[]{&quot;javap&quot;}, &quot;Path to the class files of the product to use javap&quot;, OptionDescr.VAL_SINGLE, &quot;&quot;);
902     public final static OptionDescr DSC_TESTS_INFO =
903             new OptionDescr(&quot;testsinfo&quot;, &quot;Additional information about for specified tests&#39; list&quot;, &quot;Show covererage for all tests in test list&quot;);
904 
905     public final static OptionDescr DSC_REPORT_TITLE_MAIN =
906             new OptionDescr(&quot;mainReportTitle&quot;, new String[]{&quot;mainReportTitle&quot;, &quot;mrtitle&quot;}, &quot;The main report title&quot;, OptionDescr.VAL_SINGLE, &quot;&quot;);
907     public final static OptionDescr DSC_REPORT_TITLE_OVERVIEW =
908             new OptionDescr(&quot;overviewReportTitle&quot;, new String[]{&quot;overviewReportTitle&quot;, &quot;ortitle&quot;}, &quot;The overview list report title&quot;, OptionDescr.VAL_SINGLE, &quot;&quot;);
909     public final static OptionDescr DSC_REPORT_TITLE_ENTITIES =
910             new OptionDescr(&quot;entitiesReportTitle&quot;, new String[]{&quot;entitiesReportTitle&quot;, &quot;ertitle&quot;}, &quot;Entities report title (for modules, packages, subpackages)&quot;, OptionDescr.VAL_SINGLE, &quot;&quot;);
911 }
<a name="14" id="anc14"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="14" type="hidden" />
</body>
</html>
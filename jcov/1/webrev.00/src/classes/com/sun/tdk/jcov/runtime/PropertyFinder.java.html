<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/classes/com/sun/tdk/jcov/runtime/PropertyFinder.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2014, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package com.sun.tdk.jcov.runtime;
 26 
 27 import java.io.File;
 28 import java.io.FileInputStream;
 29 import java.io.InputStream;
 30 import java.lang.reflect.Field;
 31 import java.lang.reflect.Method;
 32 import java.util.Calendar;
 33 import java.util.Properties;
 34 import java.util.regex.Matcher;
 35 import java.util.regex.Pattern;
 36 
 37 /**
 38  * &lt;p&gt; SE implementation of PropertyFinder &lt;/p&gt;
 39  *
 40  * @author Dmitry Fazunenko
 41  * @author Alexey Fedorchenko
 42  */
 43 public final class PropertyFinder {
 44 
 45     /**
 46      * &lt;p&gt; Reads input string substituting macros. No additional shortcarts
 47      * used. &lt;/p&gt;
 48      *
 49      * @param str String to parse and substitute
 50      * @return Parsed string
 51      */
 52     public static String processMacroString(String str) {
 53         return processMacroString(str, null, null);
 54     }
 55 
 56     /**
 57      * &lt;p&gt; Reads input string substituting macros. Additional shortcarts can be
 58      * used to enhance or overwrite default macros. &lt;/p&gt;
 59      *
 60      * @param str String to parse and substitute
 61      * @param shortcarts
 62      * @param datas
 63      * @return
 64      */
 65     public static String processMacroString(String str, char shortcarts[], String datas[]) {
 66         if (str == null) {
 67             return str;
 68         }
 69         StringBuilder buf = new StringBuilder();
 70         int start = 0, pos = 0;
 71         while (true) {
 72             pos = str.indexOf(&#39;%&#39;, start);
 73             if (pos &lt; 0) {
 74                 buf.append(str.substring(start));
 75                 break;
 76             }
 77             buf.append(str.substring(start, pos));
 78             int end = str.indexOf(&#39;%&#39;, pos + 1);
 79             if (end &lt; 0) {
 80                 buf.append(str.substring(pos));
 81                 break;
 82             }
 83             String patt = str.substring(pos, end);
 84             if (end - pos &lt; 2) { // %
 85                 buf.append(&#39;%&#39;);
 86             } else {
 87                 char ch = patt.charAt(1);
 88                 if (end - pos == 2) { // prebuilt patterns
 89                     boolean found = false;
 90                     if (shortcarts != null) {
 91                         for (int i = 0; i &lt; shortcarts.length; ++i) {
 92                             if (shortcarts[i] == ch) {
 93                                 found = true;
 94                                 buf.append(datas[i]);
 95                             }
 96                         }
 97                     }
 98                     if (!found) {
 99                         switch (ch) {
100                             case &#39;d&#39;: // M-D-Y
101                                 Calendar c = Calendar.getInstance();
102                                 buf.append(c.get(Calendar.HOUR_OF_DAY)).append(&#39;:&#39;).
103                                         append(c.get(Calendar.MINUTE)).append(&#39;:&#39;).
104                                         append(c.get(Calendar.SECOND)).append(&#39;_&#39;).
105                                         append(c.get(Calendar.MONTH) + 1).append(&#39;-&#39;).
106                                         append(c.get(Calendar.DAY_OF_MONTH)).append(&#39;-&#39;).
107                                         append(c.get(Calendar.YEAR));
108                                 break;
109                             case &#39;t&#39;: // h:m:s
110                                 c = Calendar.getInstance();
111                                 buf.append(c.get(Calendar.HOUR_OF_DAY)).append(&#39;:&#39;).
112                                         append(c.get(Calendar.MINUTE)).append(&#39;:&#39;).
113                                         append(c.get(Calendar.SECOND));
114                                 break;
115                             case &#39;D&#39;: // VM workdir
116                                 buf.append(System.getProperty(&quot;user.dir&quot;));
117                                 break;
118                             case &#39;R&#39;: // random int
119                                 buf.append(Math.round(Math.random() * 100000));
120                                 break;
121                             case &#39;T&#39;: // time
122                                 buf.append(System.currentTimeMillis());
123                                 break;
124                             case &#39;U&#39;: // username
125                                 buf.append(System.getProperty(&quot;user.name&quot;));
126                                 break;
127                             case &#39;V&#39;: // JAVA version
128                                 buf.append(System.getProperty(&quot;java.version&quot;));
129                                 break;
130                             default:
131                                 --end; // including last % to next search
132                                 buf.append(patt);
133                                 break;
134                         }
135                     }
136                 } else if (ch == &#39;F&#39;) { // field
137                     String className = patt.substring(2, patt.lastIndexOf(&#39;.&#39;));
138                     try {
139                         Class c = Class.forName(className);
140                         Field f = c.getDeclaredField(patt.substring(patt.lastIndexOf(&#39;.&#39;) + 1, patt.length()));
141                         boolean changed = false;
142                         if (!f.isAccessible()) {
143                             f.setAccessible(true);
144                             changed = true;
145                         }
146                         try {
147                             if (f != null) {
148                                 buf.append(f.get(null).toString());
149                             } else {
150                                 --end; // including last % to next search
151                                 buf.append(patt);
152                             }
153                         } finally {
154                             if (changed) {
155                                 f.setAccessible(false);
156                             }
157                         }
158                     } catch (Exception e) {
159                         --end; // including last % to next search
160                         buf.append(patt);
161                     }
162                 } else if (ch == &#39;M&#39;) { // method
163                     String className = patt.substring(2, patt.lastIndexOf(&#39;.&#39;));
164                     try {
165                         Class c = Class.forName(className);
166                         Method m = c.getDeclaredMethod(patt.substring(patt.lastIndexOf(&#39;.&#39;) + 1, patt.length()), (Class[]) null);
167                         boolean changed = false;
168                         if (!m.isAccessible()) {
169                             m.setAccessible(true);
170                             changed = true;
171                         }
172                         try {
173                             if (m != null &amp;&amp; m.getReturnType() != Void.class) {
174                                 buf.append(m.invoke(null, (Object[]) null).toString());
175                             } else {
176                                 --end; // including last % to next search
177                                 buf.append(patt);
178                             }
179                         } finally {
180                             if (changed) {
181                                 m.setAccessible(false);
182                             }
183                         }
184                     } catch (Exception e) {
185                         --end; // including last % to next search
186                         buf.append(patt);
187                     }
188                 } else if (ch == &#39;E&#39; || ch == &#39;P&#39;) { // environment variable or Java property
189                     String prop = System.getenv(patt.substring(2));
190                     if (prop != null) {
191                         buf.append(prop);
192                     } else {
193                         --end; // including last % to next search
194                         buf.append(patt);
195                     }
196                 } else { // Java property
197                     String prop = System.getProperty(patt.substring(1));
198                     if (prop != null) {
199                         buf.append(prop);
200                     } else {
201                         --end; // including last % to next search
202                         buf.append(patt);
203                     }
204                 }
205             }
206             start = end + 1;
207         }
208         return buf.toString();
209     }
210     private static Properties p;
211     private static boolean propsRead = false;
212     private static String propsFile;
213     public static final String PROPERTY_FILE_PREFIX = &quot;jcov.&quot;;
214     public static final String JVM_PROPERTY_PREFIX = PROPERTY_FILE_PREFIX;
215     public static final String ENV_PROPERTY_PREFIX = &quot;JCOV_&quot;;
216 
217     /**
218      * &lt;p&gt; Returns value specified by user. If sys prop defined the value is
219      * taken from system property, if not the looks for env variable setting and
220      * the default value is taken in the last turn. &lt;/p&gt;
221      *
222      * @param name - variable name. JCOV_{NAME} is used for sys env, jcov.{name}
223      * is used for jvm env
224      * @param defaultValue - default value
225      * @return
226      */
227     public static String getStaticValue(String name, String defaultValue) {
228         try {
229             String res = System.getProperty(PROPERTY_FILE_PREFIX + name);
230             if (res != null) {
231                 return res;
232             }
233             res = System.getenv(ENV_PROPERTY_PREFIX + name.replace(&#39;.&#39;, &#39;_&#39;).toUpperCase());
234             if (res != null) {
235                 return res;
236             }
237         } catch (Exception ignored) {
238         }
239         return defaultValue;
240     }
241 
242     /**
243      * &lt;p&gt; Returns value specified by user. If sys prop is defined the value is
244      * taken from system property, if not the looks for env variable setting, if
245      * not it looks in property files and the default value is taken in the last
246      * turn. &lt;/p&gt;
247      *
248      * @param name - variable name. JCOV_{NAME} is used for sys env, jcov.{name}
249      * is used for jvm env
250      * @param defaultValue - default value
251      * @return
252      */
253     public static String findValue(String name, String defaultValue) {
254         String res = getStaticValue(name, null);
255 
256         if (res == null) {
257             Properties p = findProperties();
258             if (p != null) {
259                 res = p.getProperty(PROPERTY_FILE_PREFIX + name, defaultValue);
260             } else {
261                 res = defaultValue;
262             }
263         }
264 
265         return processMacroString(res, null, null);
266     }
267 
268     /**
269      * &lt;p&gt; Searches for jcov property file. First candidate to read is file in
270      * JCOV_PROPFILE system env variable. Second candidate is file in
271      * jcov.propfile jvm env. Third candidate to read is
272      * /com/sun/tdk/jcov/jcov.properties classpath resourse. Last candidate is
273      * {user.home}/.jcov/jcov.properties file. &lt;/p&gt; &lt;p&gt; Every filename is
274      * firstly checked as a file and is read only if such file exists and can be
275      * read. If it&#39;s not a file, can&#39;t be read, doesn&#39;t exist or is not a
276      * property file then classpath resource is checked. &lt;/p&gt;
277      *
278      * @return Properties read from all possible sources or null if not found.
279      */
280     private static Properties findProperties() {
281         if (!propsRead) {
282             propsRead = true;
283             String propfile = getStaticValue(&quot;propfile&quot;, null); // jcov.propfile or JCOV_PROPFILE
284 
285             if (propfile != null) {
286                 p = readProperties(propfile);
287                 if (p != null) {
288                     propsFile = propfile;
289                     return p;
290                 }
291             }
292 
293             if (propfile == null || !(&quot;/com/sun/tdk/jcov/jcov.properties&quot;.equals(propfile))) {
294                 p = readProperties(&quot;/com/sun/tdk/jcov/jcov.properties&quot;);
295                 if (p != null) {
296                     propsFile = &quot;/com/sun/tdk/jcov/jcov.properties&quot;;
297                     return p;
298                 }
299             }
300 
301             try {
302                 p = readProperties(System.getProperty(&quot;user.home&quot;) + File.separator + &quot;.jcov&quot; + File.separator + &quot;jcov.properties&quot;);
303                 if (p != null) {
304                     propsFile = System.getProperty(&quot;user.home&quot;) + File.separator + &quot;.jcov&quot; + File.separator + &quot;jcov.properties&quot;;
305                 }
306             } catch (Exception ignore) {
307             }
308         }
309 
310         return p;
311     }
312 
313     private static Properties loadPropertiesFile(String path, Properties properties) {
314         try(InputStream in = new FileInputStream(path)) {
315             Properties p = ( properties == null) ?  new Properties() : properties;
316             p.load(in);
317             resolveProps(p);
318             properties = p;
319         } catch (Exception ignore) {
320             // warning message
321         }
322         return properties;
323     }
324 
325     private static Properties loadPropertiesStream(String path, Properties properties) {
326         try(InputStream in = JCovSaver.class.getResourceAsStream(path)) {
327             Properties p = ( properties == null) ?  new Properties() : properties;
328             p.load(in);
329             resolveProps(p);
330             properties = p;
331         } catch (Exception ignore) {
332             // warning message
333         }
334         return properties;
335     }
336 
337     /**
338      * &lt;p&gt; Reads jcov property file from specified path &lt;/p&gt; &lt;p&gt;
339      * If it can&#39;t be read then classpath resource is checked. &lt;p&gt;
340      *
341      * @param path Path to look for a property file.
342      * @return Read properties or null if file was not found neither in file
343      * system neither in classpath
344      */
345     public static Properties readProperties(String path) {
346         Properties p = loadPropertiesFile(path, null);
347         return  p == null ? loadPropertiesStream(path, null) : p;
348     }
349 
350     /**
351      * &lt;p&gt; Reads jcov property file from specified path &lt;/p&gt; &lt;p&gt;
352      * If it can&#39;t be read then classpath resource is checked. &lt;p&gt;
353      *
354      * @param path Path to look for a property file.
355      * @return Read properties or null if file was not found neither in file
356      * system neither in classpath
357      */
358     public static Properties readProperties(String path, Properties properties) {
359         if (properties == null) {
360             properties = new Properties();
361         }
362         Properties p = loadPropertiesFile(path, properties);
363         return  properties.equals(p) ? loadPropertiesStream(path, properties) : p;
364     }
365 
366     /**
367      * &lt;p&gt; Resolves all links of ${key} form on other keys in property values.
368      * &lt;/p&gt;
369      *
370      * @param props Properties to resolve.
371      */
372     private static void resolveProps(Properties props) {
373         Pattern p = Pattern.compile(&quot;.*(\\$\\{(.*)\\})&quot;);
374         for (Object o : props.keySet()) {
375             String name = (String) o;
376             String val = props.getProperty(name);
377             Matcher m = p.matcher(val);
378             while (m.find()) {
379                 String link = m.group(2);
380                 String lVal = props.getProperty(link);
381                 val = val.replace(m.group(1), lVal);
382                 m = p.matcher(val);
383             }
384             props.put(o, val);
385         }
386     }
387 
388     /**
389      * &lt;p&gt; Read a single property from property file &lt;/p&gt;
390      *
391      * @param fileName file to look value in
392      * @param name name of value to read
393      * @return value of &quot;name&quot; in fileName property file or null if such
394      * property file doesn&#39;t exist
395      */
396     public static String readPropFrom(String fileName, String name) {
397         Properties props = readProperties(fileName);
398         if (props != null) {
399             return props.getProperty(PROPERTY_FILE_PREFIX + name);
400         } else {
401             return null;
402         }
403     }
404 
405     /**
406      * &lt;p&gt; Describes source of a property by name. Returns a string containing
407      * description of the property source. E.g.: &lt;/p&gt; &lt;ul&gt; &lt;li&gt; &quot;JavaVM property
408      * &#39;jcov.propfile&#39; &lt;/li&gt; &lt;li&gt; &quot;system environment property &#39;JCOV_TEMPLATE&#39;
409      * &lt;/li&gt; &lt;li&gt; &quot;property file from &#39;/temp/jcov/jcov.properties&#39; &lt;/li&gt; &lt;li&gt;
410      * &quot;defaults&quot; &lt;/li&gt; &lt;/ul&gt;
411      *
412      * @param name Property name to check source
413      * @return String describing property source.
414      */
415     public static String findSource(String name) {
416         if (name == null || name.isEmpty()) {
417             return &quot;&quot;;
418         }
419 
420         if (System.getProperty(JVM_PROPERTY_PREFIX + name) != null) {
421             return &quot;JavaVM property &#39;&quot; + JVM_PROPERTY_PREFIX + name + &quot;&#39;&quot;;
422         }
423 
424         if (System.getenv(ENV_PROPERTY_PREFIX + name.toUpperCase()) != null) {
425             return &quot;system environment property &#39;&quot; + ENV_PROPERTY_PREFIX + name.toUpperCase() + &quot;&#39;&quot;;
426         }
427 
428         if (!propsRead) {
429             findProperties();
430         }
431 
432         if (propsFile != null &amp;&amp; p.containsKey(PROPERTY_FILE_PREFIX + name)) {
433             return &quot;property file from &#39;&quot; + propsFile + &quot;&#39;&quot;;
434         }
435 
436         return &quot;defaults&quot;;
437     }
438 
439     /**
440      * &lt;p&gt; Set path for properties file to read values. Can be used many times.
441      * &lt;/p&gt;
442      *
443      * @param path Path to read
444      */
445     public static void setPropertiesFile(String path) {
446         propsFile = path;
447         p = readProperties(path);
448         propsRead = true;
449     }
450 
451     public static void cleanProperties() {
452         p = null;
453         propsFile = null;
454         propsRead = false;
455     }
456 
457     /**
458      * &lt;p&gt; Installs shutdown hook. ME/Card version can&#39;t install shutdown hook.
459      * &lt;/p&gt;
460      */
461     public static void addAutoShutdownSave() {
462         if (Collect.saveAtShutdownEnabled &amp;&amp; &quot;true&quot;.equals(findValue(&quot;autosave&quot;, &quot;true&quot;))) {
463             try {
464                 Runtime.getRuntime().addShutdownHook(new Thread() {
465                     @Override
466                     public void run() {
467                         Collect.disable();
468                         Collect.saveResults();
469                         Collect.enable();
470                         Collect.saveAtShutdownEnabled = false;
471                         Collect.saveEnabled = false;
472                     }
473                 });
474             } catch (Exception ignore) {
475                 System.err.println(&quot;Can&#39;t set shutdown hook.&quot;);
476             }
477         }
478     }
479 
480     /**
481      * &lt;p&gt; Checks whether VM is ready to initialize JCov RT (saver). Most savers
482      * use shutdown hook to save data in time. Shutdown hook needs Thread to be
483      * created but it can&#39;t be created in very early VM livetime. &lt;/p&gt; &lt;p&gt; Due
484      * to restrictions JCovME version should have it&#39;s own isVMReady()
485      * implementation. &lt;/p&gt;
486      *
487      * @return true if VM is ready to install shutdown hook and to read
488      * properties
489      */
490     public static boolean isVMReady() {
491         return System.out != null &amp;&amp; Runtime.getRuntime() != null;//&amp;&amp; sun.misc.VM.isBooted();
492     }
493 
494 }
    </pre>
  </body>
</html>
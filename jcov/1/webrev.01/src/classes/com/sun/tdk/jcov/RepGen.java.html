<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/classes/com/sun/tdk/jcov/RepGen.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2014, 2020 Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package com.sun.tdk.jcov;
 26 
 27 import com.sun.tdk.jcov.instrument.DataMethod;
 28 import com.sun.tdk.jcov.instrument.DataClass;
 29 import com.sun.tdk.jcov.instrument.DataField;
 30 import com.sun.tdk.jcov.processing.DataProcessorSPI;
 31 import com.sun.tdk.jcov.report.AncFilter;
 32 import com.sun.tdk.jcov.report.ParameterizedAncFilter;
 33 import com.sun.tdk.jcov.report.AncFilterFactory;
 34 import com.sun.tdk.jcov.util.Utils;
 35 import com.sun.tdk.jcov.data.FileFormatException;
 36 import com.sun.tdk.jcov.data.Result;
 37 import com.sun.tdk.jcov.instrument.DataRoot;
 38 import com.sun.tdk.jcov.processing.ProcessingException;
 39 
 40 import com.sun.tdk.jcov.tools.EnvHandler;
 41 import com.sun.tdk.jcov.tools.OptionDescr;
 42 import com.sun.tdk.jcov.io.Reader;
 43 import com.sun.tdk.jcov.filter.ConveyerFilter;
 44 import com.sun.tdk.jcov.filter.MemberFilter;
 45 import com.sun.tdk.jcov.filter.FilterFactory;
 46 import com.sun.tdk.jcov.instrument.InstrumentationOptions;
 47 import com.sun.tdk.jcov.io.ClassSignatureFilter;
 48 import com.sun.tdk.jcov.processing.DefaultDataProcessorSPI;
 49 import com.sun.tdk.jcov.processing.StubSpi;
 50 import com.sun.tdk.jcov.report.DefaultReportGeneratorSPI;
 51 import com.sun.tdk.jcov.report.ProductCoverage;
 52 import com.sun.tdk.jcov.report.ReportGenerator;
 53 import com.sun.tdk.jcov.report.ReportGeneratorSPI;
 54 import com.sun.tdk.jcov.report.SmartTestService;
 55 import com.sun.tdk.jcov.report.javap.JavapClass;
 56 import com.sun.tdk.jcov.report.javap.JavapRepGen;
 57 import com.sun.tdk.jcov.tools.JCovCMDTool;
 58 import com.sun.tdk.jcov.tools.SPIDescr;
 59 import java.io.IOException;
 60 import java.util.ArrayList;
 61 import java.util.ServiceLoader;
 62 import java.util.logging.Level;
 63 import java.util.logging.Logger;
 64 
 65 import static com.sun.tdk.jcov.tools.OptionDescr.*;
 66 import java.io.File;
 67 import java.util.Arrays;
 68 import java.util.List;
 69 import org.objectweb.asm.Opcodes;
 70 
 71 /**
 72  * &lt;p&gt; Report generation. &lt;/p&gt;
 73  *
 74  * @author Andrey Titov
 75  * @author Dmitry Fazunenko
 76  * @author Alexey Fedorchenko
 77  */
 78 public class RepGen extends JCovCMDTool {
 79 
 80     final static String CUSTOM_REPORT_GENERATOR_SPI = &quot;customreport.spi&quot;;
 81     final static String DATA_PROCESSOR_SPI = &quot;dataprocessor.spi&quot;;
 82     private static final String ANC_FILTER_PARAMETER_SEPARATOR = &quot;:&quot;;
 83 
 84     // logger initialization
 85     static {
 86         Utils.initLogger();
 87         logger = Logger.getLogger(RepGen.class.getName());
 88     }
 89     private final static Logger logger;
 90     /**
 91      * Consider or not enums. true - means ignore enum classes.
 92      */
 93     private boolean noEnums = false;
 94     /**
 95      * Whether show or not field coverage in the report (false by default).
 96      */
 97     private boolean showFields = false;
 98     private ReportGeneratorSPI reportGeneratorSPIs[];
 99     private DataProcessorSPI dataProcessorSPIs[];
100     private String[] include = new String[]{&quot;.*&quot;};
101     private String[] exclude = new String[]{&quot;&quot;};
102     private String[] m_include = new String[]{&quot;.*&quot;};
103     private String[] m_exclude = new String[]{&quot;&quot;};
104     private String[] fms = null;
105     private String filter = null;
106     private String[] ancfilters = null;
107     private String[] ancdeffilters = null;
108     private boolean noAbstract = false;
109     private boolean syntheticOn = false;
110     private boolean isPublicAPI = false;
111     private String[] filenames;
112     private String name;
113     private String outputDir;
114     private String testlist;
115     private String srcRootPath;
116     private boolean anonym = false;
117     private boolean withTestsInfo = false;
118     //path to the jar, dir or .class for javap repgen
119     private String classesPath;
120     private AncFilter[] ancfiltersClasses = null;
121     private String mainReportTitle = null;
122     private String overviewListTitle = null;
123     private String entitiesTitle = null;
124 
125     public RepGen() {
126         readPlugins = true;
127     }
128 
129     /**
130      * Generate report using default (html) report generator
131      *
132      * @param output
133      * @param jcovResult
134      * @throws ProcessingException
135      * @throws FileFormatException
136      * @throws Exception
137      */
138     public void generateReport(String output, Result jcovResult) throws ProcessingException, FileFormatException, Exception {
139         generateReport(getDefaultReportGenerator(), output, jcovResult, null);
140     }
141 
142     /**
143      * Generate report using specified format
144      *
145      * @param format
146      * @param output
147      * @param jcovResult
148      * @throws ProcessingException
149      * @throws FileFormatException
150      * @throws Exception
151      */
152     public void generateReport(String format, String output, Result jcovResult) throws ProcessingException, FileFormatException, Exception {
153         generateReport(format, output, jcovResult, null);
154     }
155 
156     /**
157      * Generate report using specified format
158      *
159      * @param format
160      * @param output
161      * @param jcovResult
162      * @param srcRootPath
163      * @throws ProcessingException
164      * @throws FileFormatException
165      * @throws Exception
166      */
167     public void generateReport(String format, String output, Result jcovResult, String srcRootPath) throws ProcessingException, FileFormatException, Exception {
168         ReportGenerator rg = null;
169         if (format != null) {
170             rg = findReportGenerator(format);
171         } else {
172             rg = getDefaultReportGenerator();
173         }
174         if (rg == null) {
175             throw new Exception(&quot;Specified ReportGenerator name (&quot; + format + &quot;) was not found&quot;);
176         }
177 
178         generateReport(rg, output, jcovResult, srcRootPath);
179     }
180 
181     /**
182      * Generate report using specified report generator
183      *
184      * @param rg
185      * @param output
186      * @param jcovResult
187      * @param srcRootPath
188      * @throws ProcessingException
189      * @throws FileFormatException
190      * @throws Exception
191      */
192     public void generateReport(ReportGenerator rg, String output, Result jcovResult, String srcRootPath) throws ProcessingException, FileFormatException, Exception {
193         generateReport(rg, output, jcovResult, srcRootPath, null);
194     }
195 
196     /**
197      * Generate report using specified report generator
198      *
199      * @param rg
200      * @param output
201      * @param jcovResult
202      * @param srcRootPath
203      * @param classes parsed javap classes
204      * @throws ProcessingException
205      * @throws FileFormatException
206      * @throws Exception
207      */
208     public void generateReport(ReportGenerator rg, String output, Result jcovResult, String srcRootPath, List&lt;JavapClass&gt; classes) throws ProcessingException, FileFormatException, Exception {
209         try {
210             logger.log(Level.INFO, &quot;-- Writing report to {0}&quot;, output);
211             rg.init(output);
212             logger.fine(&quot;OK&quot;);
213         } catch (Throwable ex) {
214             logger.log(Level.SEVERE, &quot;Error while reading output file by ReportGenerator &quot; + rg.getClass().getName(), ex);
215             return;
216         }
217 
218         logger.log(Level.INFO, &quot;-- Reading data from {0}&quot;, jcovResult.getResultPath());
219         DataRoot file_image = readDataRootFile(jcovResult.getResultPath(), jcovResult.isTestListSet(), include, exclude, fms);
220 
221         if (!syntheticOn) {
222             file_image.applyFilter(new ANC_FILTER());
223         }
224 
225         MemberFilter customFilter = null;
226         if (filter != null) {
227             logger.fine(&quot;-- Initializing custom filter&quot;);
228             customFilter = initCustomFilter(filter, null);
229             logger.fine(&quot;OK&quot;);
230         }
231         if (customFilter != null) {
232             logger.log(Level.INFO, &quot;-- Applying filter {0}&quot;, customFilter.getClass().getName());
233             file_image.applyFilter(customFilter);
234             logger.fine(&quot;OK&quot;);
235         }
236 
237         if (ancfilters != null){
238             ancfiltersClasses = new AncFilter[ancfilters.length];
239             for (int i = 0; i &lt; ancfilters.length; i++) {
240                 try {
241                     String ancfilter = ancfilters[i];
242                     Class ancFilteClass = Class.forName(ancfilter);
243                     ancfiltersClasses[i] = (AncFilter) ancFilteClass.getDeclaredConstructor().newInstance();
244                 } catch (Exception e) {
245                     throw new Error(&quot;Cannot create an instance of &quot;
246                             + &quot;AncFilter: &quot;, e);
247                 }
248             }
249         }
250 
251         if (ancdeffilters != null) {
252             ServiceLoader&lt;AncFilterFactory&gt; loader = ServiceLoader.load(AncFilterFactory.class);
253             List&lt;AncFilter&gt; defaultANCFiltersList = new ArrayList&lt;AncFilter&gt;();
254             if (ancfiltersClasses != null &amp;&amp; ancfiltersClasses.length &gt; 0) {
255                 defaultANCFiltersList.addAll(Arrays.asList(ancfiltersClasses));
256             }
257             if (ancdeffilters.length == 1 &amp;&amp; ancdeffilters[0].equals(&quot;all&quot;)) {
258                 for (AncFilterFactory factory : loader) {
259                     defaultANCFiltersList.addAll(factory.instantiateAll());
260                 }
261             } else {
262                 for (String defaulAncFilter : ancdeffilters) {
263                     boolean found = false;
264                     String filterName, filterParameters;
265                     int separatorPosition = defaulAncFilter.indexOf(ANC_FILTER_PARAMETER_SEPARATOR);
266                     if (separatorPosition &gt; -1) {
267                         filterName = defaulAncFilter.substring(0, separatorPosition);
268                         filterParameters = defaulAncFilter.substring(separatorPosition +
269                                 ANC_FILTER_PARAMETER_SEPARATOR.length());
270                     } else {
271                         filterName = defaulAncFilter;
272                         filterParameters = null;
273                     }
274                     for (AncFilterFactory factory : loader) {
275                         AncFilter filter = factory.instantiate(filterName);
276                         if (filter != null) {
277                             if (filterParameters != null) {
278                                 if (filter instanceof ParameterizedAncFilter) {
279                                     try {
280                                         ((ParameterizedAncFilter) filter).setParameter(filterParameters);
281                                     } catch (Exception e) {
282                                         throw new RuntimeException(&quot;Unable to set parameter for filter &quot; +
283                                                 filterName + &quot;:&quot; + e.getMessage());
284                                     }
285                                 } else {
286                                     throw new RuntimeException(filterName + &quot; filter does not accept parameters: &quot; + filter);
287                                 }
288                             }
289                             found = true;
290                             defaultANCFiltersList.add(filter);
291                             break;
292                         }
293                     }
294                     if (!found) {
295                         throw new RuntimeException(&quot;There is no ANC filter for \&quot;&quot; + defaulAncFilter + &quot;\&quot; value&quot;);
296                     }
297                 }
298             }
299             ancfiltersClasses = defaultANCFiltersList.toArray(new AncFilter[defaultANCFiltersList.size()]);
300         }
301 
302         if (dataProcessorSPIs != null) {
303             for (DataProcessorSPI spi : dataProcessorSPIs) {
304                 logger.log(Level.INFO, &quot;-- Applying data processor {0}&quot;, spi.getClass());
305                 file_image = spi.getDataProcessor().process(file_image);
306             }
307         }
308         logger.fine(&quot;OK&quot;);
309 
310         SmartTestService sts = null;
311         if (jcovResult.isTestListSet()) {
312             logger.fine(&quot;-- Initializing test list&quot;);
313             sts = new SmartTestService(jcovResult.getTestList());
314             if (file_image.getScaleOpts().getScaleSize() != sts.getTestCount()) {
315                 logger.log(Level.SEVERE, &quot;The sizes of tests in JCov file and in test list differ.\n&quot;
316                         + &quot;Datafile {0} contains {1} item(s).\nThe test list contains {2} item(s).&quot;,
317                         new Object[]{jcovResult.getResultPath(), file_image.getScaleOpts().getScaleSize(), sts.getTestCount()});
318                 throw new Exception(&quot;The sizes of tests in JCov file and in test list differ&quot;);
319             }
320             logger.fine(&quot;OK&quot;);
321         }
322         ReportGenerator.Options options = new ReportGenerator.Options(srcRootPath, sts, classes, withTestsInfo, false,
323                 mainReportTitle, overviewListTitle, entitiesTitle);
324         options.setInstrMode(file_image.getParams().getMode());
325         options.setAnonymOn(anonym);
326 
327         try {
328             ProductCoverage coverage = new ProductCoverage(file_image, options.getSrcRootPaths(), options.getJavapClasses(), isPublicAPI, noAbstract, anonym, ancfiltersClasses);
329             logger.log(Level.INFO, &quot;-- Starting ReportGenerator {0}&quot;, rg.getClass().getName());
330             rg.generateReport(coverage, options);
331         } catch (Throwable e) {
332             throw e;
333         }
334         logger.log(Level.INFO, &quot;-- Report generation done&quot;);
335         return;
336     }
337 
338     /**
339      * Get default (html) report generator
340      *
341      * @return default (html) report generator
342      */
343     public ReportGenerator getDefaultReportGenerator() {
344         return findReportGenerator(&quot;html&quot;);
345     }
346 
347     private ReportGenerator findReportGenerator(String name) {
348         ReportGenerator rg = null;
349         if (reportGeneratorSPIs != null) {
350             for (ReportGeneratorSPI reportGeneratorSPI : reportGeneratorSPIs) {
351                 rg = reportGeneratorSPI.getReportGenerator(name);
352                 if (rg != null) {
353                     return rg;
354                 }
355             }
356         }
357         return new DefaultReportGeneratorSPI().getReportGenerator(name); // can be null
358     }
359 
360     protected DataRoot readDataRootFile(String filename, boolean readScales, String[] include, String[] exclude, String[] modif) throws FileFormatException {
361         ClassSignatureFilter acceptor = new ClassSignatureFilter(include, exclude, m_include, m_exclude, modif);
362         DataRoot file_image = Reader.readXML(filename, readScales, acceptor);
363         return file_image;
364     }
365 
366     /**
367      * Legacy CMD line entry poiny (use &#39;java -jar jcov.jar Merger&#39; from cmd
368      * instead of &#39;java -cp jcov.jar com.sun.tdk.jcov.Merger&#39;)
369      *
370      * @param args
371      */
372     public static void main(String args[]) {
373         RepGen tool = new RepGen();
374         try {
375             int res = tool.run(args);
376             System.exit(res);
377         } catch (Exception ex) {
378             System.exit(1);
379         }
380     }
381 
382     protected String usageString() {
383         return &quot;java com.sun.tdk.jcov.RepGen [options] filename&quot;;
384     }
385 
386     protected String exampleString() {
387         return &quot;java -cp jcov.jar com.sun.tdk.jcov.RepGen -include java.lang.* -format html -output out result.xml&quot;;
388     }
389 
390     protected String getDescr() {
391         return &quot;generates text or HTML (or custom) reports&quot;;
392     }
393 
394     private MemberFilter createCustomFilter(String spiName) {
395         return FilterFactory.
396                 getInstance(spiName).getMemberFilter();
397 
398     }
399 
400     private MemberFilter initCustomFilter(String filter, String sig) {
401         MemberFilter customPlugin = null;
402         MemberFilter sigFilter = null;
403 
404         if (filter != null) {
405             customPlugin = createCustomFilter(filter);
406         }
407         if (customPlugin == null &amp;&amp; sigFilter == null) {
408             return null;
409         } else if (customPlugin != null &amp;&amp; sigFilter != null) {
410             ConveyerFilter f = new ConveyerFilter();
411             f.add(sigFilter);
412             f.add(customPlugin);
413             return f;
414         } else {
415             return sigFilter != null ? sigFilter : customPlugin;
416         }
417 
418     }
419 
420     public void setReportGeneratorSPIs(ReportGeneratorSPI reportGeneratorSPI[]) {
421         this.reportGeneratorSPIs = reportGeneratorSPI;
422     }
423 
424     public ReportGeneratorSPI[] getReportGeneratorSPIs() {
425         return reportGeneratorSPIs;
426     }
427 
428     public String getFilter() {
429         return filter;
430     }
431 
432     public void setFilter(String filter) {
433         this.filter = filter;
434     }
435 
436     public String[] getFms() {
437         return fms;
438     }
439 
440     public void setFms(String[] fms) {
441         this.fms = fms;
442     }
443 
444     public String[] getInclude() {
445         return include;
446     }
447 
448     public void setInclude(String[] include) {
449         this.include = include;
450     }
451 
452     public boolean isIsPublicAPI() {
453         return isPublicAPI;
454     }
455 
456     public void setIsPublicAPI(boolean isPublicAPI) {
457         this.isPublicAPI = isPublicAPI;
458     }
459 
460     public boolean isNoAbstract() {
461         return noAbstract;
462     }
463 
464     public void setNoAbstract(boolean noAbstract) {
465         this.noAbstract = noAbstract;
466     }
467 
468     public boolean isSyntheticOn() {
469         return syntheticOn;
470     }
471 
472     public void setNoANC(boolean syntheticOn) {
473         this.syntheticOn = syntheticOn;
474     }
475 
476     public boolean isWithTestsInfo() {
477         return withTestsInfo;
478     }
479 
480     public void setWithTestsInfo(boolean withTestsInfo) {
481         this.withTestsInfo = withTestsInfo;
482     }
483 
484     public boolean isNoEnums() {
485         return noEnums;
486     }
487 
488     public void setNoEnums(boolean noEnums) {
489         this.noEnums = noEnums;
490     }
491 
492     public boolean isShowFields() {
493         return showFields;
494     }
495 
496     public void setShowFields(boolean showFields) {
497 //        this.showFields = showFields;
498     }
499 
500     public String[] getExclude() {
501         return exclude;
502     }
503 
504     public void setExclude(String[] exclude) {
505         this.exclude = exclude;
506     }
507 
508     public String getSrcRootPath() {
509         return srcRootPath;
510     }
511 
512     public void setDataProcessorsSPIs(DataProcessorSPI[] dataProcessorSPIs){
513         this.dataProcessorSPIs = dataProcessorSPIs;
514     }
515 
516     /**
517      * Reset all properties to defaults. reportGeneratorSPI = null; include =
518      * new String[] {&quot;.*&quot;}; exclude = new String[] {&quot;&quot;}; fms = null; filter =
519      * null; generateShortFormat = false; noAbstract = false; isPublicAPI =
520      * false; showMethods = true; showBlocks = true; showBranches = true;
521      * showLines = true;
522      */
523     public void resetDefaults() {
524         try {
525             handleEnv_(defineHandler());
526             reportGeneratorSPIs = null;
527             //setFilters(new String[]{&quot;.*&quot;}, new String[]{&quot;&quot;}, null);
528             setNoAbstract(false);
529             setIsPublicAPI(false);
530         } catch (EnvHandlingException ex) {
531             // should not happen
532         }
533     }
534 
535     /**
536      * Set all properties (except custorm report service provider)
537      *
538      * @param include patterns for including data. Set null for default value -
539      * {&quot;.*&quot;} (include all)
540      * @param exclude patterns for excluding data. Set null for default value -
541      * {&quot;&quot;} (exclude nothing)
542      * @param classModifiers modifiers that should have a class to be included
543      * @param filter custom filter classname
544      * @param generateShortFormat should generate short format
545      * @param publicAPI should generate only public API (public and protected)
546      * @param hideAbstract should hide abstract data
547      * @param hideMethods should hide methods
548      * @param hideBlocks should hide blocks
549      * @param hideBranches should hide branches
550      * @param hideLines should hide lines
551      */
552     public void configure(String[] include, String[] exclude, String[] classModifiers,
553             String filter, boolean generateShortFormat, boolean publicAPI, boolean hideAbstract,
554             boolean hideMethods, boolean hideBlocks, boolean hideBranches, boolean hideLines,
555             boolean hideFields) {
556         setFilters(include, exclude, classModifiers);
557         setFilter(filter);
558         this.isPublicAPI = publicAPI;
559 //        this.showFields = !hideFields;
560     }
561 
562     /**
563      * Set filtering properties for the report
564      *
565      * @param include patterns for including data. Set null for default value -
566      * {&quot;.*&quot;} (include all)
567      * @param exclude patterns for excluding data. Set null for default value -
568      * {&quot;&quot;} (exclude nothing)
569      * @param classModifiers modifiers that should have a class to be included
570      */
571     public void setFilters(String[] include, String[] exclude, String[] classModifiers) {
572         if (include == null) {
573             include = new String[]{&quot;.*&quot;};
574         }
575         this.include = include;
576         if (exclude == null) {
577             exclude = new String[]{&quot;&quot;};
578         }
579         this.exclude = exclude;
580         this.fms = classModifiers;
581     }
582 
583     @Override
584     protected int run() throws Exception {
585         Result r;
586         boolean srcZipped = false;
587         if (srcRootPath != null) {
588             File srcRootPathFile = new File(srcRootPath);
589 
590             if (srcRootPathFile.exists() &amp;&amp; srcRootPathFile.isFile() &amp;&amp; (srcRootPath.endsWith(&quot;.zip&quot;) || srcRootPath.endsWith(&quot;.jar&quot;))) {
591                 srcZipped = true;
592                 srcRootPath = outputDir + File.separator + srcRootPathFile.getName().replace(&quot;.zip&quot;, &quot;&quot;).replace(&quot;.jar&quot;, &quot;&quot;);
593                 Utils.unzipFolder(srcRootPathFile, srcRootPath);
594             }
595         }
596 
597         try {
598 
599             logger.log(Level.INFO, &quot;-- Reading test list&quot;);
600             if (filenames.length == 1) {
601                 r = new Result(filenames[0], testlist);
602             } else {
603                 Merger merger = new Merger();
604                 Result[] results = Merger.initResults(filenames, true);
605                 Merger.Merge merge = new Merger.Merge(results, null);
606                 merger.setAddMissing(true);
607                 merger.setRead_scales(true);
608                 merger.setDefaultReadingFilter(include, exclude, m_include, m_exclude, fms);
609                 merger.merge(merge, outputDir, true);
610 
611                 ReportGenerator rg;
612                 if (name != null) {
613                     rg = findReportGenerator(name);
614                 } else {
615                     rg = getDefaultReportGenerator();
616                 }
617                 if (rg == null) {
618                     throw new Exception(&quot;Specified ReportGenerator name (&quot; + name + &quot;) was not found&quot;);
619                 }
620                 rg.init(outputDir);
621                 String[] tl = testlist != null ? Utils.readLines(testlist) : merge.getResultTestList();
622                 SmartTestService sts = new SmartTestService(tl);
623                 ReportGenerator.Options options = new ReportGenerator.Options(srcRootPath, sts, null, true, true,
624                         mainReportTitle, overviewListTitle, entitiesTitle);
625                 try {
626                     DataRoot mergedResult = merge.getResult();
627                     if (!syntheticOn) {
628                         mergedResult.applyFilter(new ANC_FILTER());
629                     }
630 
631                     if (dataProcessorSPIs != null) {
632                         for (DataProcessorSPI spi : dataProcessorSPIs) {
633                             logger.log(Level.INFO, &quot;-- Applying data processor {0}&quot;, spi.getClass());
634                             mergedResult = spi.getDataProcessor().process(mergedResult);
635                         }
636                     }
637 
638                     ProductCoverage coverage = new ProductCoverage(mergedResult, options.getSrcRootPaths(), null, isPublicAPI, noAbstract, ancfiltersClasses);
639                     rg.generateReport(coverage, options);
640 
641                     if (srcZipped) {
642                         Utils.deleteDirectory(new File(srcRootPath));
643                     }
644 
645                 } catch (Throwable ex) {
646                     if (ex.getMessage() != null) {
647                         throw new Exception(&quot;ReportGenerator produced exception &quot; + ex.getMessage(), ex);
648                     } else {
649                         throw new Exception(&quot;ReportGenerator produced exception &quot; + ex, ex);
650                     }
651                 }
652 
653                 return SUCCESS_EXIT_CODE;
654             }
655         } catch (IOException ex) {
656             logger.log(Level.SEVERE, &quot;Error while reading testlist&quot;, ex);
657             return ERROR_CMDLINE_EXIT_CODE;
658         }
659 
660         if (classesPath != null) {
661             try {
662                 logger.log(Level.INFO, &quot;-- Creating javap report&quot;);
663                 setDataProcessorsSPIs(null);
664                 new JavapRepGen(this).run(filenames[0], classesPath, outputDir);
665                 return SUCCESS_EXIT_CODE;
666             } catch (Exception ex) {
667                 logger.log(Level.SEVERE, &quot;Error while creating javap report&quot;, ex);
668                 return ERROR_CMDLINE_EXIT_CODE;
669             }
670         }
671 
672         try {
673             generateReport(name, outputDir, r, srcRootPath);
674 
675             if (srcZipped) {
676                 Utils.deleteDirectory(new File(srcRootPath));
677             }
678 
679             return 0;
680         } catch (FileFormatException e) {
681             logger.log(Level.SEVERE, e.getMessage(), Arrays.toString(filenames));
682         } catch (Exception ex) {
683             logger.log(Level.SEVERE, ex.getMessage(), ex);
684         }
685         return SUCCESS_EXIT_CODE;
686     }
687 
688     @Override
689     protected EnvHandler defineHandler() {
690         EnvHandler envHandler = new EnvHandler(new OptionDescr[]{
691                     DSC_FMT,
692                     DSC_OUTPUT,
693                     //            DSC_STDOUT,
694                     com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_INCLUDE,
695                     com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_EXCLUDE,
696                     com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_INCLUDE_LIST,
697                     com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_EXCLUDE_LIST,
698                     com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_MINCLUDE_LIST,
699                     com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_MEXCLUDE_LIST,
700                     com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_MINCLUDE,
701                     com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_MEXCLUDE,
702                     com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_FM,
703                     com.sun.tdk.jcov.instrument.InstrumentationOptions.DSC_FM_LIST,
704                     DSC_NO_ABSTRACT,
705                     DSC_SYNTHETIC_ON,
706                     DSC_PUBLIC_API,
707                     DSC_SRC_ROOT,
708                     DSC_VERBOSE,
709                     DSC_FILTER_PLUGIN,
710                     DSC_ANC_FILTER_PLUGINS,
711                     DSC_ANC_DEFAULT_FILTERS,
712                     DSC_TEST_LIST,
713                     DSC_ANONYM,
714                     DSC_JAVAP,
715                     DSC_TESTS_INFO,
716                     DSC_REPORT_TITLE_MAIN,
717                     DSC_REPORT_TITLE_OVERVIEW,
718                     DSC_REPORT_TITLE_ENTITIES,}, this);
719         SPIDescr spiDescr = new SPIDescr(CUSTOM_REPORT_GENERATOR_SPI, ReportGeneratorSPI.class);
720         spiDescr.setDefaultSPI(new DefaultReportGeneratorSPI());
721         envHandler.registerSPI(spiDescr);
722 
723         spiDescr = new SPIDescr(DATA_PROCESSOR_SPI, DataProcessorSPI.class);
724         spiDescr.addPreset(&quot;none&quot;, new StubSpi());
725         spiDescr.setDefaultSPI(new DefaultDataProcessorSPI());
726         envHandler.registerSPI(spiDescr);
727 
728         return envHandler;
729     }
730 
731     private int handleEnv_(EnvHandler opts) throws EnvHandlingException {
732         if (opts.isSet(DSC_VERBOSE)) {
733 //            LoggingFormatter.printStackTrace = true; // by default logger doesn&#39;t print stacktrace
734             logger.setLevel(Level.INFO);
735         } else {
736             logger.setLevel(Level.SEVERE);
737         }
738 
739         name = opts.getValue(DSC_FMT);
740         outputDir = opts.getValue(DSC_OUTPUT);
741         // no check for output
742 
743         filter = opts.getValue(DSC_FILTER_PLUGIN);
744         ancfilters = opts.getValues(DSC_ANC_FILTER_PLUGINS);
745         ancdeffilters = opts.getValues(DSC_ANC_DEFAULT_FILTERS);
746         noAbstract = opts.isSet(DSC_NO_ABSTRACT);
747         isPublicAPI = opts.isSet(DSC_PUBLIC_API);
748         anonym = opts.isSet(DSC_ANONYM);
749         syntheticOn = opts.isSet(DSC_SYNTHETIC_ON);
750 
751         include = InstrumentationOptions.handleInclude(opts);
752         exclude = InstrumentationOptions.handleExclude(opts);
753         fms = InstrumentationOptions.handleFM(opts);
754 
755         m_include = InstrumentationOptions.handleMInclude(opts);
756         m_exclude = InstrumentationOptions.handleMExclude(opts);
757 
758         testlist = opts.getValue(DSC_TEST_LIST);
759         Utils.checkFileCanBeNull(testlist, &quot;testlist filename&quot;, Utils.CheckOptions.FILE_EXISTS, Utils.CheckOptions.FILE_CANREAD, Utils.CheckOptions.FILE_ISFILE);
760 
761         withTestsInfo = opts.isSet(DSC_TESTS_INFO);
762 
763         srcRootPath = null;
764         if (opts.isSet(DSC_SRC_ROOT)) {
765             srcRootPath = opts.getValue(DSC_SRC_ROOT);
766         }
767 
768         if (opts.isSet(DSC_REPORT_TITLE_MAIN)){
769             mainReportTitle = opts.getValue(DSC_REPORT_TITLE_MAIN);
770         }
771         if (opts.isSet(DSC_REPORT_TITLE_OVERVIEW)){
772             overviewListTitle = opts.getValue(DSC_REPORT_TITLE_OVERVIEW);
773         }
774         if (opts.isSet(DSC_REPORT_TITLE_ENTITIES)){
775             entitiesTitle = opts.getValue(DSC_REPORT_TITLE_ENTITIES);
776         }
777 
778         ArrayList&lt;ReportGeneratorSPI&gt; reportGenerators = opts.getSPIs(ReportGeneratorSPI.class);
779         if (reportGenerators != null) {
780             reportGeneratorSPIs = reportGenerators.toArray(new ReportGeneratorSPI[reportGenerators.size()]);
781         }
782         ArrayList&lt;DataProcessorSPI&gt; dataProcessors = opts.getSPIs(DataProcessorSPI.class);
783         if (dataProcessors != null) {
784             dataProcessorSPIs = dataProcessors.toArray(new DataProcessorSPI[dataProcessors.size()]);
785         }
786 
787         classesPath = opts.getValue(DSC_JAVAP);
788 
789         return SUCCESS_EXIT_CODE;
790     }
791 
792     @Override
793     protected int handleEnv(EnvHandler opts) throws EnvHandlingException {
794         String[] srcs = opts.getTail();
795         if (srcs == null) {
796             throw new EnvHandlingException(&quot;no input files specified&quot;);
797         }
798 
799         filenames = srcs;
800         Utils.checkFileNotNull(filenames[0], &quot;JCov datafile&quot;, Utils.CheckOptions.FILE_EXISTS, Utils.CheckOptions.FILE_CANREAD, Utils.CheckOptions.FILE_ISFILE);
801         /*if (srcs.length &gt; 1) {
802          logger.log(Level.WARNING,&quot;only \&quot;{0}\&quot; will be processed, the rest of the files will be ignored\n&quot; +
803          &quot;\tto generate report for all files, merge them into one using the merger utility&quot;, filename);
804          }*/
805 
806         return handleEnv_(opts);
807     }
808 
809     public static class ANC_FILTER implements MemberFilter {
810 
811         @Override
812         public boolean accept(DataClass clz) {
813             return true;
814         }
815 
816         @Override
817         public boolean accept(DataClass clz, DataMethod m) {
818 
819             boolean ancMethod;
820 
821             //Synthetic method (and Bridge method)
822             ancMethod = ((m.getAccess() &amp; Opcodes.ACC_SYNTHETIC) != 0);
823 
824             //Enum method
825             ancMethod = ancMethod
826                     || (clz.getSuperName().equals(&quot;java/lang/Enum&quot;) &amp;&amp; (m.getName().equals(&quot;valueOf&quot;) || m.getName().equals(&quot;values&quot;)));
827 
828             return !ancMethod || m.getName().startsWith(&quot;lambda$&quot;);
829 
830         }
831 
832         @Override
833         public boolean accept(DataClass clz, DataField f) {
834             return true;
835         }
836     }
837     final static OptionDescr DSC_FMT =
838             new OptionDescr(&quot;format&quot;, new String[]{&quot;fmt&quot;},
839             &quot;Report generation output.&quot;, VAL_SINGLE,
840             &quot;Specifies the format of the report.\n&quot;
841             + &quot;Use \&quot;text\&quot; for generate text report and \&quot;html\&quot; for generate HTML report\n&quot;
842             + &quot;Text report in one file which contains method/block/branch coverage information.\n&quot;
843             + &quot;HTML report contains coverage information with marked-up sources.\n\n&quot;
844             + &quot;Custom reports can be specified with ReportGeneratorSPI interface.&quot;, &quot;html&quot;);
845     /**
846      *
847      */
848     public final static OptionDescr DSC_OUTPUT =
849             new OptionDescr(&quot;repgen.output&quot;, new String[]{&quot;output&quot;, &quot;o&quot;}, &quot;&quot;, OptionDescr.VAL_SINGLE,
850             &quot;Output directory for generating text and HTML reports.&quot;, &quot;report&quot;);
851     /**
852      *
853      */
854     public final static OptionDescr DSC_TEST_LIST =
855             new OptionDescr(&quot;tests&quot;, &quot;Test list&quot;, OptionDescr.VAL_SINGLE,
856             &quot;Specify the path to the file containing test list. File should contain a list of tests\n&quot;
857             + &quot;with one name per line.&quot;);
858     final static OptionDescr DSC_FILTER_PLUGIN =
859             new OptionDescr(&quot;filter&quot;, &quot;&quot;, OptionDescr.VAL_SINGLE,
860             &quot;Custom filtering plugin class&quot;);
861 
862     final static OptionDescr DSC_ANC_FILTER_PLUGINS =
863             new OptionDescr(&quot;ancfilter&quot;, new String[]{&quot;ancf&quot;}, &quot;Custom anc filtering plugin classes&quot;, OptionDescr.VAL_MULTI,
864                     &quot;&quot;);
865 
866     final static OptionDescr DSC_ANC_DEFAULT_FILTERS =
867             new OptionDescr(&quot;ancdeffilters&quot;, new String[]{&quot;ancdf&quot;}, &quot;Default ANC filter name to use in report&quot;, OptionDescr.VAL_MULTI,
868                     &quot;&quot;);
869 
870     /**
871      *
872      */
873     public final static OptionDescr DSC_SRC_ROOT =
874             new OptionDescr(&quot;sourcepath&quot;, new String[]{&quot;source&quot;, &quot;src&quot;}, &quot;The source files.&quot;, OptionDescr.VAL_SINGLE, &quot;&quot;);
875     final static OptionDescr DSC_VERBOSE =
876             new OptionDescr(&quot;verbose&quot;, &quot;Verbosity.&quot;, &quot;Enable verbose mode.&quot;);
877     /**
878      *
879      */
880     public final static OptionDescr DSC_NO_ABSTRACT =
881             new OptionDescr(&quot;noabstract&quot;, &quot;Additional filtering&quot;, &quot;Do not count abstract methods&quot;);
882     public final static OptionDescr DSC_SYNTHETIC_ON =
883             new OptionDescr(&quot;syntheticon&quot;, &quot;Additional filtering&quot;, &quot;Count coverage for synthetic methods&quot;);
884     /**
885      *
886      */
887     public final static OptionDescr DSC_PUBLIC_API =
888             new OptionDescr(&quot;publicapi&quot;, &quot;&quot;, &quot;Count only public and protected members&quot;);
889     public final static OptionDescr DSC_ANONYM =
890             new OptionDescr(&quot;anonym&quot;, &quot;&quot;, &quot;include methods from anonymous classes into the report&quot;);
891     public final static OptionDescr DSC_JAVAP =
892             new OptionDescr(&quot;javap&quot;, new String[]{&quot;javap&quot;}, &quot;Path to the class files of the product to use javap&quot;, OptionDescr.VAL_SINGLE, &quot;&quot;);
893     public final static OptionDescr DSC_TESTS_INFO =
894             new OptionDescr(&quot;testsinfo&quot;, &quot;Additional information about for specified tests&#39; list&quot;, &quot;Show covererage for all tests in test list&quot;);
895 
896     public final static OptionDescr DSC_REPORT_TITLE_MAIN =
897             new OptionDescr(&quot;mainReportTitle&quot;, new String[]{&quot;mainReportTitle&quot;, &quot;mrtitle&quot;}, &quot;The main report title&quot;, OptionDescr.VAL_SINGLE, &quot;&quot;);
898     public final static OptionDescr DSC_REPORT_TITLE_OVERVIEW =
899             new OptionDescr(&quot;overviewReportTitle&quot;, new String[]{&quot;overviewReportTitle&quot;, &quot;ortitle&quot;}, &quot;The overview list report title&quot;, OptionDescr.VAL_SINGLE, &quot;&quot;);
900     public final static OptionDescr DSC_REPORT_TITLE_ENTITIES =
901             new OptionDescr(&quot;entitiesReportTitle&quot;, new String[]{&quot;entitiesReportTitle&quot;, &quot;ertitle&quot;}, &quot;Entities report title (for modules, packages, subpackages)&quot;, OptionDescr.VAL_SINGLE, &quot;&quot;);
902 }
    </pre>
  </body>
</html>
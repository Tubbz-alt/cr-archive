<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shared/genCollectedHeap.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../../../os/linux/os_linux.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../../runtime/abstract_vm_version.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/genCollectedHeap.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1104 
1105 HeapWord* GenCollectedHeap::allocate_new_tlab(size_t min_size,
1106                                               size_t requested_size,
1107                                               size_t* actual_size) {
1108   bool gc_overhead_limit_was_exceeded;
1109   HeapWord* result = mem_allocate_work(requested_size /* size */,
1110                                        true /* is_tlab */,
1111                                        &amp;gc_overhead_limit_was_exceeded);
1112   if (result != NULL) {
1113     *actual_size = requested_size;
1114   }
1115 
1116   return result;
1117 }
1118 
1119 // Requires &quot;*prev_ptr&quot; to be non-NULL.  Deletes and a block of minimal size
1120 // from the list headed by &quot;*prev_ptr&quot;.
1121 static ScratchBlock *removeSmallestScratch(ScratchBlock **prev_ptr) {
1122   bool first = true;
1123   size_t min_size = 0;   // &quot;first&quot; makes this conceptually infinite.
<span class="line-modified">1124   ScratchBlock **smallest_ptr, *smallest;</span>
1125   ScratchBlock  *cur = *prev_ptr;
1126   while (cur) {
1127     assert(*prev_ptr == cur, &quot;just checking&quot;);
1128     if (first || cur-&gt;num_words &lt; min_size) {
1129       smallest_ptr = prev_ptr;
1130       smallest     = cur;
1131       min_size     = smallest-&gt;num_words;
1132       first        = false;
1133     }
1134     prev_ptr = &amp;cur-&gt;next;
1135     cur     =  cur-&gt;next;
1136   }
1137   smallest      = *smallest_ptr;
1138   *smallest_ptr = smallest-&gt;next;
1139   return smallest;
1140 }
1141 
1142 // Sort the scratch block list headed by res into decreasing size order,
1143 // and set &quot;res&quot; to the result.
1144 static void sort_scratch_list(ScratchBlock*&amp; list) {
</pre>
</td>
<td>
<hr />
<pre>
1104 
1105 HeapWord* GenCollectedHeap::allocate_new_tlab(size_t min_size,
1106                                               size_t requested_size,
1107                                               size_t* actual_size) {
1108   bool gc_overhead_limit_was_exceeded;
1109   HeapWord* result = mem_allocate_work(requested_size /* size */,
1110                                        true /* is_tlab */,
1111                                        &amp;gc_overhead_limit_was_exceeded);
1112   if (result != NULL) {
1113     *actual_size = requested_size;
1114   }
1115 
1116   return result;
1117 }
1118 
1119 // Requires &quot;*prev_ptr&quot; to be non-NULL.  Deletes and a block of minimal size
1120 // from the list headed by &quot;*prev_ptr&quot;.
1121 static ScratchBlock *removeSmallestScratch(ScratchBlock **prev_ptr) {
1122   bool first = true;
1123   size_t min_size = 0;   // &quot;first&quot; makes this conceptually infinite.
<span class="line-modified">1124   ScratchBlock **smallest_ptr = NULL, *smallest;</span>
1125   ScratchBlock  *cur = *prev_ptr;
1126   while (cur) {
1127     assert(*prev_ptr == cur, &quot;just checking&quot;);
1128     if (first || cur-&gt;num_words &lt; min_size) {
1129       smallest_ptr = prev_ptr;
1130       smallest     = cur;
1131       min_size     = smallest-&gt;num_words;
1132       first        = false;
1133     }
1134     prev_ptr = &amp;cur-&gt;next;
1135     cur     =  cur-&gt;next;
1136   }
1137   smallest      = *smallest_ptr;
1138   *smallest_ptr = smallest-&gt;next;
1139   return smallest;
1140 }
1141 
1142 // Sort the scratch block list headed by res into decreasing size order,
1143 // and set &quot;res&quot; to the result.
1144 static void sort_scratch_list(ScratchBlock*&amp; list) {
</pre>
</td>
</tr>
</table>
<center><a href="../../../os/linux/os_linux.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../../runtime/abstract_vm_version.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os/linux/os_linux.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../../../../make/test/JtregNativeJdk.gmk.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../share/gc/shared/genCollectedHeap.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/linux/os_linux.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  86 # include &lt;signal.h&gt;
  87 # include &lt;endian.h&gt;
  88 # include &lt;errno.h&gt;
  89 # include &lt;dlfcn.h&gt;
  90 # include &lt;stdio.h&gt;
  91 # include &lt;unistd.h&gt;
  92 # include &lt;sys/resource.h&gt;
  93 # include &lt;pthread.h&gt;
  94 # include &lt;sys/stat.h&gt;
  95 # include &lt;sys/time.h&gt;
  96 # include &lt;sys/times.h&gt;
  97 # include &lt;sys/utsname.h&gt;
  98 # include &lt;sys/socket.h&gt;
  99 # include &lt;sys/wait.h&gt;
 100 # include &lt;pwd.h&gt;
 101 # include &lt;poll.h&gt;
 102 # include &lt;fcntl.h&gt;
 103 # include &lt;string.h&gt;
 104 # include &lt;syscall.h&gt;
 105 # include &lt;sys/sysinfo.h&gt;
<span class="line-removed"> 106 # include &lt;gnu/libc-version.h&gt;</span>
 107 # include &lt;sys/ipc.h&gt;
 108 # include &lt;sys/shm.h&gt;
 109 # include &lt;link.h&gt;
 110 # include &lt;stdint.h&gt;
 111 # include &lt;inttypes.h&gt;
 112 # include &lt;sys/ioctl.h&gt;
 113 # include &lt;linux/elf-em.h&gt;
 114 
 115 #ifndef _GNU_SOURCE
 116   #define _GNU_SOURCE
 117   #include &lt;sched.h&gt;
 118   #undef _GNU_SOURCE
 119 #else
 120   #include &lt;sched.h&gt;
 121 #endif
 122 
 123 // if RUSAGE_THREAD for getrusage() has not been defined, do it here. The code calling
 124 // getrusage() is prepared to handle the associated failure.
 125 #ifndef RUSAGE_THREAD
 126   #define RUSAGE_THREAD   (1)               /* only the calling thread */
</pre>
<hr />
<pre>
 135 
 136 enum CoredumpFilterBit {
 137   FILE_BACKED_PVT_BIT = 1 &lt;&lt; 2,
 138   FILE_BACKED_SHARED_BIT = 1 &lt;&lt; 3,
 139   LARGEPAGES_BIT = 1 &lt;&lt; 6,
 140   DAX_SHARED_BIT = 1 &lt;&lt; 8
 141 };
 142 
 143 ////////////////////////////////////////////////////////////////////////////////
 144 // global variables
 145 julong os::Linux::_physical_memory = 0;
 146 
 147 address   os::Linux::_initial_thread_stack_bottom = NULL;
 148 uintptr_t os::Linux::_initial_thread_stack_size   = 0;
 149 
 150 int (*os::Linux::_pthread_getcpuclockid)(pthread_t, clockid_t *) = NULL;
 151 int (*os::Linux::_pthread_setname_np)(pthread_t, const char*) = NULL;
 152 pthread_t os::Linux::_main_thread;
 153 int os::Linux::_page_size = -1;
 154 bool os::Linux::_supports_fast_thread_cpu_time = false;
<span class="line-modified"> 155 const char * os::Linux::_glibc_version = NULL;</span>
<span class="line-modified"> 156 const char * os::Linux::_libpthread_version = NULL;</span>
 157 size_t os::Linux::_default_large_page_size = 0;
 158 
 159 static jlong initial_time_count=0;
 160 
 161 static int clock_tics_per_sec = 100;
 162 
 163 // If the VM might have been created on the primordial thread, we need to resolve the
 164 // primordial thread stack bounds and check if the current thread might be the
 165 // primordial thread in places. If we know that the primordial thread is never used,
 166 // such as when the VM was created by one of the standard java launchers, we can
 167 // avoid this
 168 static bool suppress_primordial_thread_resolution = false;
 169 
 170 // For diagnostics to print a message once. see run_periodic_checks
 171 static sigset_t check_signal_done;
 172 static bool check_signals = true;
 173 
 174 // Signal number used to suspend/resume a thread
 175 
 176 // do not use any signal number less than SIGSEGV, see 4355769
</pre>
<hr />
<pre>
 589     if (thread-&gt;is_VM_thread()) {
 590       // Only the VM thread handles BREAK_SIGNAL ...
 591       pthread_sigmask(SIG_UNBLOCK, vm_signals(), NULL);
 592     } else {
 593       // ... all other threads block BREAK_SIGNAL
 594       pthread_sigmask(SIG_BLOCK, vm_signals(), NULL);
 595     }
 596   }
 597 }
 598 
 599 //////////////////////////////////////////////////////////////////////////////
 600 // detecting pthread library
 601 
 602 void os::Linux::libpthread_init() {
 603   // Save glibc and pthread version strings.
 604 #if !defined(_CS_GNU_LIBC_VERSION) || \
 605     !defined(_CS_GNU_LIBPTHREAD_VERSION)
 606   #error &quot;glibc too old (&lt; 2.3.2)&quot;
 607 #endif
 608 
<span class="line-modified"> 609   size_t n = confstr(_CS_GNU_LIBC_VERSION, NULL, 0);</span>
<span class="line-modified"> 610   assert(n &gt; 0, &quot;cannot retrieve glibc version&quot;);</span>
<span class="line-modified"> 611   char *str = (char *)malloc(n, mtInternal);</span>
<span class="line-modified"> 612   confstr(_CS_GNU_LIBC_VERSION, str, n);</span>
<span class="line-modified"> 613   os::Linux::set_glibc_version(str);</span>



 614 
 615   n = confstr(_CS_GNU_LIBPTHREAD_VERSION, NULL, 0);
<span class="line-modified"> 616   assert(n &gt; 0, &quot;cannot retrieve pthread version&quot;);</span>
<span class="line-modified"> 617   str = (char *)malloc(n, mtInternal);</span>
<span class="line-modified"> 618   confstr(_CS_GNU_LIBPTHREAD_VERSION, str, n);</span>
<span class="line-modified"> 619   os::Linux::set_libpthread_version(str);</span>

 620 }
 621 
 622 /////////////////////////////////////////////////////////////////////////////
 623 // thread stack expansion
 624 
 625 // os::Linux::manually_expand_stack() takes care of expanding the thread
 626 // stack. Note that this is normally not needed: pthread stacks allocate
 627 // thread stack using mmap() without MAP_NORESERVE, so the stack is already
 628 // committed. Therefore it is not necessary to expand the stack manually.
 629 //
 630 // Manually expanding the stack was historically needed on LinuxThreads
 631 // thread stacks, which were allocated with mmap(MAP_GROWSDOWN). Nowadays
 632 // it is kept to deal with very rare corner cases:
 633 //
 634 // For one, user may run the VM on an own implementation of threads
 635 // whose stacks are - like the old LinuxThreads - implemented using
 636 // mmap(MAP_GROWSDOWN).
 637 //
 638 // Also, this coding may be needed if the VM is running on the primordial
 639 // thread. Normally we avoid running on the primordial thread; however,
</pre>
<hr />
<pre>
3178 void os::Linux::sched_getcpu_init() {
3179   // sched_getcpu() should be in libc.
3180   set_sched_getcpu(CAST_TO_FN_PTR(sched_getcpu_func_t,
3181                                   dlsym(RTLD_DEFAULT, &quot;sched_getcpu&quot;)));
3182 
3183   // If it&#39;s not, try a direct syscall.
3184   if (sched_getcpu() == -1) {
3185     set_sched_getcpu(CAST_TO_FN_PTR(sched_getcpu_func_t,
3186                                     (void*)&amp;sched_getcpu_syscall));
3187   }
3188 
3189   if (sched_getcpu() == -1) {
3190     vm_exit_during_initialization(&quot;getcpu(2) system call not supported by kernel&quot;);
3191   }
3192 }
3193 
3194 // Something to do with the numa-aware allocator needs these symbols
3195 extern &quot;C&quot; JNIEXPORT void numa_warn(int number, char *where, ...) { }
3196 extern &quot;C&quot; JNIEXPORT void numa_error(char *where) { }
3197 




















3198 // Handle request to load libnuma symbol version 1.1 (API v1). If it fails
3199 // load symbol from base version instead.
3200 void* os::Linux::libnuma_dlsym(void* handle, const char *name) {
<span class="line-modified">3201   void *f = dlvsym(handle, name, &quot;libnuma_1.1&quot;);</span>
<span class="line-removed">3202   if (f == NULL) {</span>
<span class="line-removed">3203     f = dlsym(handle, name);</span>
<span class="line-removed">3204   }</span>
<span class="line-removed">3205   return f;</span>
3206 }
3207 
3208 // Handle request to load libnuma symbol version 1.2 (API v2) only.
3209 // Return NULL if the symbol is not defined in this particular version.
3210 void* os::Linux::libnuma_v2_dlsym(void* handle, const char* name) {
<span class="line-modified">3211   return dlvsym(handle, name, &quot;libnuma_1.2&quot;);</span>
3212 }
3213 
3214 bool os::Linux::libnuma_init() {
3215   if (sched_getcpu() != -1) { // Requires sched_getcpu() support
3216     void *handle = dlopen(&quot;libnuma.so.1&quot;, RTLD_LAZY);
3217     if (handle != NULL) {
3218       set_numa_node_to_cpus(CAST_TO_FN_PTR(numa_node_to_cpus_func_t,
3219                                            libnuma_dlsym(handle, &quot;numa_node_to_cpus&quot;)));
3220       set_numa_max_node(CAST_TO_FN_PTR(numa_max_node_func_t,
3221                                        libnuma_dlsym(handle, &quot;numa_max_node&quot;)));
3222       set_numa_num_configured_nodes(CAST_TO_FN_PTR(numa_num_configured_nodes_func_t,
3223                                                    libnuma_dlsym(handle, &quot;numa_num_configured_nodes&quot;)));
3224       set_numa_available(CAST_TO_FN_PTR(numa_available_func_t,
3225                                         libnuma_dlsym(handle, &quot;numa_available&quot;)));
3226       set_numa_tonode_memory(CAST_TO_FN_PTR(numa_tonode_memory_func_t,
3227                                             libnuma_dlsym(handle, &quot;numa_tonode_memory&quot;)));
3228       set_numa_interleave_memory(CAST_TO_FN_PTR(numa_interleave_memory_func_t,
3229                                                 libnuma_dlsym(handle, &quot;numa_interleave_memory&quot;)));
3230       set_numa_interleave_memory_v2(CAST_TO_FN_PTR(numa_interleave_memory_v2_func_t,
3231                                                 libnuma_v2_dlsym(handle, &quot;numa_interleave_memory&quot;)));
</pre>
<hr />
<pre>
5138     tty-&gt;print(&quot;Warning: %s handler flags &quot;, exception_name(sig, buf, O_BUFLEN));
5139     tty-&gt;print(&quot;expected:&quot;);
5140     os::Posix::print_sa_flags(tty, os::Linux::get_our_sigflags(sig));
5141     tty-&gt;cr();
5142     tty-&gt;print(&quot;  found:&quot;);
5143     os::Posix::print_sa_flags(tty, act.sa_flags);
5144     tty-&gt;cr();
5145     // No need to check this sig any longer
5146     sigaddset(&amp;check_signal_done, sig);
5147   }
5148 
5149   // Dump all the signal
5150   if (sigismember(&amp;check_signal_done, sig)) {
5151     print_signal_handlers(tty, buf, O_BUFLEN);
5152   }
5153 }
5154 
5155 extern void report_error(char* file_name, int line_no, char* title,
5156                          char* format, ...);
5157 

























































5158 // this is called _before_ most of the global arguments have been parsed
5159 void os::init(void) {
5160   char dummy;   // used to get a guess on initial stack address
5161 
5162   clock_tics_per_sec = sysconf(_SC_CLK_TCK);
5163 
5164   init_random(1234567);
5165 
5166   Linux::set_page_size(sysconf(_SC_PAGESIZE));
5167   if (Linux::page_size() == -1) {
5168     fatal(&quot;os_linux.cpp: os::init: sysconf failed (%s)&quot;,
5169           os::strerror(errno));
5170   }
5171   init_page_sizes((size_t) Linux::page_size());
5172 
5173   Linux::initialize_system_info();
5174 
5175   os::Linux::CPUPerfTicks pticks;
5176   bool res = os::Linux::get_tick_information(&amp;pticks, -1);
5177 
5178   if (res &amp;&amp; pticks.has_steal_ticks) {
5179     has_initial_tick_info = true;
5180     initial_total_ticks = pticks.total;
5181     initial_steal_ticks = pticks.steal;
5182   }
5183 
5184   // _main_thread points to the thread that created/loaded the JVM.
5185   Linux::_main_thread = pthread_self();
5186 
5187   // retrieve entry point for pthread_setname_np
5188   Linux::_pthread_setname_np =
5189     (int(*)(pthread_t, const char*))dlsym(RTLD_DEFAULT, &quot;pthread_setname_np&quot;);
5190 


5191   os::Posix::init();
5192 
5193   initial_time_count = javaTimeNanos();
5194 
5195   // Always warn if no monotonic clock available
5196   if (!os::Posix::supports_monotonic_clock()) {
5197     warning(&quot;No monotonic clock was available - timed services may &quot;    \
5198             &quot;be adversely affected if the time-of-day clock changes&quot;);
5199   }
5200 }
5201 
5202 // To install functions for atexit system call
5203 extern &quot;C&quot; {
5204   static void perfMemory_exit_helper() {
5205     perfMemory_exit();
5206   }
5207 }
5208 
5209 void os::pd_init_container_support() {
5210   OSContainer::init();
</pre>
</td>
<td>
<hr />
<pre>
  86 # include &lt;signal.h&gt;
  87 # include &lt;endian.h&gt;
  88 # include &lt;errno.h&gt;
  89 # include &lt;dlfcn.h&gt;
  90 # include &lt;stdio.h&gt;
  91 # include &lt;unistd.h&gt;
  92 # include &lt;sys/resource.h&gt;
  93 # include &lt;pthread.h&gt;
  94 # include &lt;sys/stat.h&gt;
  95 # include &lt;sys/time.h&gt;
  96 # include &lt;sys/times.h&gt;
  97 # include &lt;sys/utsname.h&gt;
  98 # include &lt;sys/socket.h&gt;
  99 # include &lt;sys/wait.h&gt;
 100 # include &lt;pwd.h&gt;
 101 # include &lt;poll.h&gt;
 102 # include &lt;fcntl.h&gt;
 103 # include &lt;string.h&gt;
 104 # include &lt;syscall.h&gt;
 105 # include &lt;sys/sysinfo.h&gt;

 106 # include &lt;sys/ipc.h&gt;
 107 # include &lt;sys/shm.h&gt;
 108 # include &lt;link.h&gt;
 109 # include &lt;stdint.h&gt;
 110 # include &lt;inttypes.h&gt;
 111 # include &lt;sys/ioctl.h&gt;
 112 # include &lt;linux/elf-em.h&gt;
 113 
 114 #ifndef _GNU_SOURCE
 115   #define _GNU_SOURCE
 116   #include &lt;sched.h&gt;
 117   #undef _GNU_SOURCE
 118 #else
 119   #include &lt;sched.h&gt;
 120 #endif
 121 
 122 // if RUSAGE_THREAD for getrusage() has not been defined, do it here. The code calling
 123 // getrusage() is prepared to handle the associated failure.
 124 #ifndef RUSAGE_THREAD
 125   #define RUSAGE_THREAD   (1)               /* only the calling thread */
</pre>
<hr />
<pre>
 134 
 135 enum CoredumpFilterBit {
 136   FILE_BACKED_PVT_BIT = 1 &lt;&lt; 2,
 137   FILE_BACKED_SHARED_BIT = 1 &lt;&lt; 3,
 138   LARGEPAGES_BIT = 1 &lt;&lt; 6,
 139   DAX_SHARED_BIT = 1 &lt;&lt; 8
 140 };
 141 
 142 ////////////////////////////////////////////////////////////////////////////////
 143 // global variables
 144 julong os::Linux::_physical_memory = 0;
 145 
 146 address   os::Linux::_initial_thread_stack_bottom = NULL;
 147 uintptr_t os::Linux::_initial_thread_stack_size   = 0;
 148 
 149 int (*os::Linux::_pthread_getcpuclockid)(pthread_t, clockid_t *) = NULL;
 150 int (*os::Linux::_pthread_setname_np)(pthread_t, const char*) = NULL;
 151 pthread_t os::Linux::_main_thread;
 152 int os::Linux::_page_size = -1;
 153 bool os::Linux::_supports_fast_thread_cpu_time = false;
<span class="line-modified"> 154 const char * os::Linux::_glibc_version = &quot;unknown&quot;;</span>
<span class="line-modified"> 155 const char * os::Linux::_libpthread_version = &quot;unknown&quot;;</span>
 156 size_t os::Linux::_default_large_page_size = 0;
 157 
 158 static jlong initial_time_count=0;
 159 
 160 static int clock_tics_per_sec = 100;
 161 
 162 // If the VM might have been created on the primordial thread, we need to resolve the
 163 // primordial thread stack bounds and check if the current thread might be the
 164 // primordial thread in places. If we know that the primordial thread is never used,
 165 // such as when the VM was created by one of the standard java launchers, we can
 166 // avoid this
 167 static bool suppress_primordial_thread_resolution = false;
 168 
 169 // For diagnostics to print a message once. see run_periodic_checks
 170 static sigset_t check_signal_done;
 171 static bool check_signals = true;
 172 
 173 // Signal number used to suspend/resume a thread
 174 
 175 // do not use any signal number less than SIGSEGV, see 4355769
</pre>
<hr />
<pre>
 588     if (thread-&gt;is_VM_thread()) {
 589       // Only the VM thread handles BREAK_SIGNAL ...
 590       pthread_sigmask(SIG_UNBLOCK, vm_signals(), NULL);
 591     } else {
 592       // ... all other threads block BREAK_SIGNAL
 593       pthread_sigmask(SIG_BLOCK, vm_signals(), NULL);
 594     }
 595   }
 596 }
 597 
 598 //////////////////////////////////////////////////////////////////////////////
 599 // detecting pthread library
 600 
 601 void os::Linux::libpthread_init() {
 602   // Save glibc and pthread version strings.
 603 #if !defined(_CS_GNU_LIBC_VERSION) || \
 604     !defined(_CS_GNU_LIBPTHREAD_VERSION)
 605   #error &quot;glibc too old (&lt; 2.3.2)&quot;
 606 #endif
 607 
<span class="line-modified"> 608   size_t n;</span>
<span class="line-modified"> 609 </span>
<span class="line-modified"> 610   n = confstr(_CS_GNU_LIBC_VERSION, NULL, 0);</span>
<span class="line-modified"> 611   if (n &gt; 0) {</span>
<span class="line-modified"> 612     char* str = (char *)malloc(n, mtInternal);</span>
<span class="line-added"> 613     confstr(_CS_GNU_LIBC_VERSION, str, n);</span>
<span class="line-added"> 614     os::Linux::set_glibc_version(str);</span>
<span class="line-added"> 615   }</span>
 616 
 617   n = confstr(_CS_GNU_LIBPTHREAD_VERSION, NULL, 0);
<span class="line-modified"> 618   if (n &gt; 0) {</span>
<span class="line-modified"> 619     char* str = (char *)malloc(n, mtInternal);</span>
<span class="line-modified"> 620     confstr(_CS_GNU_LIBPTHREAD_VERSION, str, n);</span>
<span class="line-modified"> 621     os::Linux::set_libpthread_version(str);</span>
<span class="line-added"> 622   }</span>
 623 }
 624 
 625 /////////////////////////////////////////////////////////////////////////////
 626 // thread stack expansion
 627 
 628 // os::Linux::manually_expand_stack() takes care of expanding the thread
 629 // stack. Note that this is normally not needed: pthread stacks allocate
 630 // thread stack using mmap() without MAP_NORESERVE, so the stack is already
 631 // committed. Therefore it is not necessary to expand the stack manually.
 632 //
 633 // Manually expanding the stack was historically needed on LinuxThreads
 634 // thread stacks, which were allocated with mmap(MAP_GROWSDOWN). Nowadays
 635 // it is kept to deal with very rare corner cases:
 636 //
 637 // For one, user may run the VM on an own implementation of threads
 638 // whose stacks are - like the old LinuxThreads - implemented using
 639 // mmap(MAP_GROWSDOWN).
 640 //
 641 // Also, this coding may be needed if the VM is running on the primordial
 642 // thread. Normally we avoid running on the primordial thread; however,
</pre>
<hr />
<pre>
3181 void os::Linux::sched_getcpu_init() {
3182   // sched_getcpu() should be in libc.
3183   set_sched_getcpu(CAST_TO_FN_PTR(sched_getcpu_func_t,
3184                                   dlsym(RTLD_DEFAULT, &quot;sched_getcpu&quot;)));
3185 
3186   // If it&#39;s not, try a direct syscall.
3187   if (sched_getcpu() == -1) {
3188     set_sched_getcpu(CAST_TO_FN_PTR(sched_getcpu_func_t,
3189                                     (void*)&amp;sched_getcpu_syscall));
3190   }
3191 
3192   if (sched_getcpu() == -1) {
3193     vm_exit_during_initialization(&quot;getcpu(2) system call not supported by kernel&quot;);
3194   }
3195 }
3196 
3197 // Something to do with the numa-aware allocator needs these symbols
3198 extern &quot;C&quot; JNIEXPORT void numa_warn(int number, char *where, ...) { }
3199 extern &quot;C&quot; JNIEXPORT void numa_error(char *where) { }
3200 
<span class="line-added">3201 static void* dlvsym_if_available(void* handle, const char* name, const char* version) {</span>
<span class="line-added">3202   typedef void* (*dlvsym_func_type)(void* handle, const char* name, const char* version);</span>
<span class="line-added">3203   static dlvsym_func_type dlvsym_func;</span>
<span class="line-added">3204   static bool initialized = false;</span>
<span class="line-added">3205 </span>
<span class="line-added">3206   if (!initialized) {</span>
<span class="line-added">3207     dlvsym_func = (dlvsym_func_type)dlsym(RTLD_NEXT, &quot;dlvsym&quot;);</span>
<span class="line-added">3208     initialized = true;</span>
<span class="line-added">3209   }</span>
<span class="line-added">3210 </span>
<span class="line-added">3211   if (dlvsym_func != NULL) {</span>
<span class="line-added">3212     void *f = dlvsym_func(handle, name, version);</span>
<span class="line-added">3213     if (f != NULL) {</span>
<span class="line-added">3214       return f;</span>
<span class="line-added">3215     }</span>
<span class="line-added">3216   }</span>
<span class="line-added">3217 </span>
<span class="line-added">3218   return dlsym(handle, name);</span>
<span class="line-added">3219 }</span>
<span class="line-added">3220 </span>
3221 // Handle request to load libnuma symbol version 1.1 (API v1). If it fails
3222 // load symbol from base version instead.
3223 void* os::Linux::libnuma_dlsym(void* handle, const char *name) {
<span class="line-modified">3224   return dlvsym_if_available(handle, name, &quot;libnuma_1.1&quot;);</span>




3225 }
3226 
3227 // Handle request to load libnuma symbol version 1.2 (API v2) only.
3228 // Return NULL if the symbol is not defined in this particular version.
3229 void* os::Linux::libnuma_v2_dlsym(void* handle, const char* name) {
<span class="line-modified">3230   return dlvsym_if_available(handle, name, &quot;libnuma_1.2&quot;);</span>
3231 }
3232 
3233 bool os::Linux::libnuma_init() {
3234   if (sched_getcpu() != -1) { // Requires sched_getcpu() support
3235     void *handle = dlopen(&quot;libnuma.so.1&quot;, RTLD_LAZY);
3236     if (handle != NULL) {
3237       set_numa_node_to_cpus(CAST_TO_FN_PTR(numa_node_to_cpus_func_t,
3238                                            libnuma_dlsym(handle, &quot;numa_node_to_cpus&quot;)));
3239       set_numa_max_node(CAST_TO_FN_PTR(numa_max_node_func_t,
3240                                        libnuma_dlsym(handle, &quot;numa_max_node&quot;)));
3241       set_numa_num_configured_nodes(CAST_TO_FN_PTR(numa_num_configured_nodes_func_t,
3242                                                    libnuma_dlsym(handle, &quot;numa_num_configured_nodes&quot;)));
3243       set_numa_available(CAST_TO_FN_PTR(numa_available_func_t,
3244                                         libnuma_dlsym(handle, &quot;numa_available&quot;)));
3245       set_numa_tonode_memory(CAST_TO_FN_PTR(numa_tonode_memory_func_t,
3246                                             libnuma_dlsym(handle, &quot;numa_tonode_memory&quot;)));
3247       set_numa_interleave_memory(CAST_TO_FN_PTR(numa_interleave_memory_func_t,
3248                                                 libnuma_dlsym(handle, &quot;numa_interleave_memory&quot;)));
3249       set_numa_interleave_memory_v2(CAST_TO_FN_PTR(numa_interleave_memory_v2_func_t,
3250                                                 libnuma_v2_dlsym(handle, &quot;numa_interleave_memory&quot;)));
</pre>
<hr />
<pre>
5157     tty-&gt;print(&quot;Warning: %s handler flags &quot;, exception_name(sig, buf, O_BUFLEN));
5158     tty-&gt;print(&quot;expected:&quot;);
5159     os::Posix::print_sa_flags(tty, os::Linux::get_our_sigflags(sig));
5160     tty-&gt;cr();
5161     tty-&gt;print(&quot;  found:&quot;);
5162     os::Posix::print_sa_flags(tty, act.sa_flags);
5163     tty-&gt;cr();
5164     // No need to check this sig any longer
5165     sigaddset(&amp;check_signal_done, sig);
5166   }
5167 
5168   // Dump all the signal
5169   if (sigismember(&amp;check_signal_done, sig)) {
5170     print_signal_handlers(tty, buf, O_BUFLEN);
5171   }
5172 }
5173 
5174 extern void report_error(char* file_name, int line_no, char* title,
5175                          char* format, ...);
5176 
<span class="line-added">5177 // Some linux distributions (notably: Alpine Linux) include the</span>
<span class="line-added">5178 // grsecurity in the kernel by default. Of particular interest from a</span>
<span class="line-added">5179 // JVM perspective is PaX (https://pax.grsecurity.net/), which adds</span>
<span class="line-added">5180 // some security features related to page attributes. Specifically,</span>
<span class="line-added">5181 // the MPROTECT PaX functionality</span>
<span class="line-added">5182 // (https://pax.grsecurity.net/docs/mprotect.txt) prevents dynamic</span>
<span class="line-added">5183 // code generation by disallowing a (previously) writable page to be</span>
<span class="line-added">5184 // marked as executable. This is, of course, exactly what HotSpot does</span>
<span class="line-added">5185 // for both JIT compiled method, as well as for stubs, adapters, etc.</span>
<span class="line-added">5186 //</span>
<span class="line-added">5187 // Instead of crashing &quot;lazily&quot; when trying to make a page executable,</span>
<span class="line-added">5188 // this code probes for the presence of PaX and reports the failure</span>
<span class="line-added">5189 // eagerly.</span>
<span class="line-added">5190 static void check_pax(void) {</span>
<span class="line-added">5191   // Zero doesn&#39;t generate code dynamically, so no need to perform the PaX check</span>
<span class="line-added">5192 #ifndef ZERO</span>
<span class="line-added">5193   size_t size = os::Linux::page_size();</span>
<span class="line-added">5194 </span>
<span class="line-added">5195   void* p = ::mmap(NULL, size, PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);</span>
<span class="line-added">5196   if (p == MAP_FAILED) {</span>
<span class="line-added">5197     vm_exit_out_of_memory(size, OOM_MMAP_ERROR, &quot;failed to allocate memory for PaX check.&quot;);</span>
<span class="line-added">5198   }</span>
<span class="line-added">5199 </span>
<span class="line-added">5200   int res = ::mprotect(p, size, PROT_WRITE|PROT_EXEC);</span>
<span class="line-added">5201   if (res == -1) {</span>
<span class="line-added">5202     vm_exit_during_initialization(&quot;Failed to mark memory page as executable&quot;,</span>
<span class="line-added">5203                                   &quot;Please check if grsecurity/PaX is enabled in your kernel.\n&quot;</span>
<span class="line-added">5204                                   &quot;\n&quot;</span>
<span class="line-added">5205                                   &quot;For example, you can do this by running (note: you may need root privileges):\n&quot;</span>
<span class="line-added">5206                                   &quot;\n&quot;</span>
<span class="line-added">5207                                   &quot;    sysctl kernel.pax.softmode\n&quot;</span>
<span class="line-added">5208                                   &quot;\n&quot;</span>
<span class="line-added">5209                                   &quot;If PaX is included in the kernel you will see something like this:\n&quot;</span>
<span class="line-added">5210                                   &quot;\n&quot;</span>
<span class="line-added">5211                                   &quot;    kernel.pax.softmode = 0\n&quot;</span>
<span class="line-added">5212                                   &quot;\n&quot;</span>
<span class="line-added">5213                                   &quot;In particular, if the value is 0 (zero), then PaX is enabled.\n&quot;</span>
<span class="line-added">5214                                   &quot;\n&quot;</span>
<span class="line-added">5215                                   &quot;PaX includes security functionality which interferes with the dynamic code\n&quot;</span>
<span class="line-added">5216                                   &quot;generation the JVM relies on. Specifically, the MPROTECT functionality as\n&quot;</span>
<span class="line-added">5217                                   &quot;described on https://pax.grsecurity.net/docs/mprotect.txt is not compatible\n&quot;</span>
<span class="line-added">5218                                   &quot;with the JVM. If you want to allow the JVM to run you will have to disable PaX.\n&quot;</span>
<span class="line-added">5219                                   &quot;You can do this on a per-executable basis using the paxctl tool, for example:\n&quot;</span>
<span class="line-added">5220                                   &quot;\n&quot;</span>
<span class="line-added">5221                                   &quot;    paxctl -cm bin/java\n&quot;</span>
<span class="line-added">5222                                   &quot;\n&quot;</span>
<span class="line-added">5223                                   &quot;Please note that this modifies the executable binary in-place, so you may want\n&quot;</span>
<span class="line-added">5224                                   &quot;to make a backup of it first. Also note that you have to repeat this for other\n&quot;</span>
<span class="line-added">5225                                   &quot;executables like javac, jar, jcmd, etc.\n&quot;</span>
<span class="line-added">5226                                   );</span>
<span class="line-added">5227 </span>
<span class="line-added">5228   }</span>
<span class="line-added">5229 </span>
<span class="line-added">5230   ::munmap(p, size);</span>
<span class="line-added">5231 #endif</span>
<span class="line-added">5232 }</span>
<span class="line-added">5233 </span>
5234 // this is called _before_ most of the global arguments have been parsed
5235 void os::init(void) {
5236   char dummy;   // used to get a guess on initial stack address
5237 
5238   clock_tics_per_sec = sysconf(_SC_CLK_TCK);
5239 
5240   init_random(1234567);
5241 
5242   Linux::set_page_size(sysconf(_SC_PAGESIZE));
5243   if (Linux::page_size() == -1) {
5244     fatal(&quot;os_linux.cpp: os::init: sysconf failed (%s)&quot;,
5245           os::strerror(errno));
5246   }
5247   init_page_sizes((size_t) Linux::page_size());
5248 
5249   Linux::initialize_system_info();
5250 
5251   os::Linux::CPUPerfTicks pticks;
5252   bool res = os::Linux::get_tick_information(&amp;pticks, -1);
5253 
5254   if (res &amp;&amp; pticks.has_steal_ticks) {
5255     has_initial_tick_info = true;
5256     initial_total_ticks = pticks.total;
5257     initial_steal_ticks = pticks.steal;
5258   }
5259 
5260   // _main_thread points to the thread that created/loaded the JVM.
5261   Linux::_main_thread = pthread_self();
5262 
5263   // retrieve entry point for pthread_setname_np
5264   Linux::_pthread_setname_np =
5265     (int(*)(pthread_t, const char*))dlsym(RTLD_DEFAULT, &quot;pthread_setname_np&quot;);
5266 
<span class="line-added">5267   check_pax();</span>
<span class="line-added">5268 </span>
5269   os::Posix::init();
5270 
5271   initial_time_count = javaTimeNanos();
5272 
5273   // Always warn if no monotonic clock available
5274   if (!os::Posix::supports_monotonic_clock()) {
5275     warning(&quot;No monotonic clock was available - timed services may &quot;    \
5276             &quot;be adversely affected if the time-of-day clock changes&quot;);
5277   }
5278 }
5279 
5280 // To install functions for atexit system call
5281 extern &quot;C&quot; {
5282   static void perfMemory_exit_helper() {
5283     perfMemory_exit();
5284   }
5285 }
5286 
5287 void os::pd_init_container_support() {
5288   OSContainer::init();
</pre>
</td>
</tr>
</table>
<center><a href="../../../../make/test/JtregNativeJdk.gmk.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../share/gc/shared/genCollectedHeap.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/make/autoconf/build-aux/config.guess b/make/autoconf/build-aux/config.guess
--- a/make/autoconf/build-aux/config.guess
+++ b/make/autoconf/build-aux/config.guess
@@ -1,8 +1,8 @@
 #!/bin/sh
 #
-# Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License version 2 only, as
 # published by the Free Software Foundation.
@@ -39,26 +39,10 @@
   if [ x"${ldd_version}" = x"musl" ]; then
     OUT=`echo $OUT | sed 's/-gnu/-musl/'`
   fi
 fi
 
-# Test and fix solaris on x86_64
-echo $OUT | grep i386-pc-solaris > /dev/null 2> /dev/null
-if test $? = 0; then
-  # isainfo -n returns either i386 or amd64
-  REAL_CPU=`isainfo -n`
-  OUT=$REAL_CPU`echo $OUT | sed -e 's/[^-]*//'`
-fi
-
-# Test and fix solaris on sparcv9
-echo $OUT | grep sparc-sun-solaris > /dev/null 2> /dev/null
-if test $? = 0; then
-  # isainfo -n returns either sparc or sparcv9
-  REAL_CPU=`isainfo -n`
-  OUT=$REAL_CPU`echo $OUT | sed -e 's/[^-]*//'`
-fi
-
 # Test and fix cygwin on x86_64
 echo $OUT | grep 86-pc-cygwin > /dev/null 2> /dev/null
 if test $? != 0; then
   echo $OUT | grep 86-pc-mingw > /dev/null 2> /dev/null
 fi
diff a/make/autoconf/buildjdk-spec.gmk.in b/make/autoconf/buildjdk-spec.gmk.in
--- a/make/autoconf/buildjdk-spec.gmk.in
+++ b/make/autoconf/buildjdk-spec.gmk.in
@@ -92,13 +92,10 @@
 DISABLE_WARNING_PREFIX := @BUILD_CC_DISABLE_WARNING_PREFIX@
 
 # Save speed and disk space by not enabling debug symbols for the buildjdk
 ENABLE_DEBUG_SYMBOLS := false
 
-# Control whether Hotspot builds gtest tests
-BUILD_GTEST := false
-
 JVM_VARIANTS := server
 JVM_VARIANT_MAIN := server
 JVM_FEATURES_server := cds compiler1 compiler2 g1gc serialgc
 
 # Some users still set EXTRA_*FLAGS on the make command line. Must
diff a/make/autoconf/platform.m4 b/make/autoconf/platform.m4
--- a/make/autoconf/platform.m4
+++ b/make/autoconf/platform.m4
@@ -160,10 +160,22 @@
       VAR_CPU=sparcv9
       VAR_CPU_ARCH=sparc
       VAR_CPU_BITS=64
       VAR_CPU_ENDIAN=big
       ;;
+    sparc)
+      VAR_CPU=sparc
+      VAR_CPU_ARCH=sparc
+      VAR_CPU_BITS=32
+      VAR_CPU_ENDIAN=big
+      ;;
+    sparcv9|sparc64)
+      VAR_CPU=sparcv9
+      VAR_CPU_ARCH=sparc
+      VAR_CPU_BITS=64
+      VAR_CPU_ENDIAN=big
+      ;;
     *)
       AC_MSG_ERROR([unsupported cpu $1])
       ;;
   esac
 ])
@@ -176,14 +188,10 @@
   case "$1" in
     *linux*)
       VAR_OS=linux
       VAR_OS_TYPE=unix
       ;;
-    *solaris*)
-      VAR_OS=solaris
-      VAR_OS_TYPE=unix
-      ;;
     *darwin*)
       VAR_OS=macosx
       VAR_OS_TYPE=unix
       ;;
     *bsd*)
@@ -405,23 +413,10 @@
   elif test "x$OPENJDK_$1_CPU" = xx86_64; then
     OPENJDK_$1_CPU_LEGACY_LIB="amd64"
   fi
   AC_SUBST(OPENJDK_$1_CPU_LEGACY_LIB)
 
-  # OPENJDK_$1_CPU_ISADIR is normally empty. On 64-bit Solaris systems, it is set to
-  # /amd64 or /sparcv9. This string is appended to some library paths, like this:
-  # /usr/lib${OPENJDK_$1_CPU_ISADIR}/libexample.so
-  OPENJDK_$1_CPU_ISADIR=""
-  if test "x$OPENJDK_$1_OS" = xsolaris; then
-    if test "x$OPENJDK_$1_CPU" = xx86_64; then
-      OPENJDK_$1_CPU_ISADIR="/amd64"
-    elif test "x$OPENJDK_$1_CPU" = xsparcv9; then
-      OPENJDK_$1_CPU_ISADIR="/sparcv9"
-    fi
-  fi
-  AC_SUBST(OPENJDK_$1_CPU_ISADIR)
-
   # Setup OPENJDK_$1_CPU_OSARCH, which is used to set the os.arch Java system property
   OPENJDK_$1_CPU_OSARCH="$OPENJDK_$1_CPU"
   if test "x$OPENJDK_$1_OS" = xlinux && test "x$OPENJDK_$1_CPU" = xx86; then
     # On linux only, we replace x86 with i386.
     OPENJDK_$1_CPU_OSARCH="i386"
@@ -547,13 +542,10 @@
   AC_SUBST(OPENJDK_$1_OS_INCLUDE_SUBDIR)
 ])
 
 AC_DEFUN([PLATFORM_SET_RELEASE_FILE_OS_VALUES],
 [
-  if test "x$OPENJDK_TARGET_OS" = "xsolaris"; then
-    RELEASE_FILE_OS_NAME=SunOS
-  fi
   if test "x$OPENJDK_TARGET_OS" = "xlinux"; then
     RELEASE_FILE_OS_NAME=Linux
   fi
   if test "x$OPENJDK_TARGET_OS" = "xwindows"; then
     RELEASE_FILE_OS_NAME=Windows
@@ -603,28 +595,12 @@
   PLATFORM_EXTRACT_TARGET_AND_BUILD
   PLATFORM_SETUP_TARGET_CPU_BITS
   PLATFORM_SET_MODULE_TARGET_OS_VALUES
   PLATFORM_SET_RELEASE_FILE_OS_VALUES
   PLATFORM_SETUP_LEGACY_VARS
-  PLATFORM_CHECK_DEPRECATION
-])
-
-AC_DEFUN([PLATFORM_CHECK_DEPRECATION],
-[
-  UTIL_ARG_ENABLE(NAME: deprecated-ports, DEFAULT: false,
-      RESULT: ENABLE_DEPRECATED_PORTS,
-      DESC: [suppress the error when configuring for a deprecated port])
-
-  if test "x$OPENJDK_TARGET_OS" = xsolaris || \
-      (test "x$OPENJDK_TARGET_CPU_ARCH" = xsparc && \
-      test "x$with_jvm_variants" != xzero); then
-    if test "x$ENABLE_DEPRECATED_PORTS" = "xtrue"; then
-      AC_MSG_WARN([The Solaris and SPARC ports are deprecated and may be removed in a future release.])
-    else
-      AC_MSG_ERROR(m4_normalize([The Solaris and SPARC ports are deprecated and may be removed in a
-        future release. Use --enable-deprecated-ports=yes to suppress this error.]))
-    fi
+
+  # Deprecated in JDK 15
   fi
 ])
 
 AC_DEFUN_ONCE([PLATFORM_SETUP_OPENJDK_BUILD_OS_VERSION],
 [
diff a/make/autoconf/spec.gmk.in b/make/autoconf/spec.gmk.in
--- a/make/autoconf/spec.gmk.in
+++ b/make/autoconf/spec.gmk.in
@@ -83,11 +83,10 @@
 OPENJDK_TARGET_LIBC:=@OPENJDK_TARGET_LIBC@
 
 COMPILE_TYPE:=@COMPILE_TYPE@
 
 # Legacy support
-OPENJDK_TARGET_CPU_ISADIR:=@OPENJDK_TARGET_CPU_ISADIR@
 OPENJDK_TARGET_CPU_LEGACY:=@OPENJDK_TARGET_CPU_LEGACY@
 OPENJDK_TARGET_CPU_LEGACY_LIB:=@OPENJDK_TARGET_CPU_LEGACY_LIB@
 OPENJDK_TARGET_CPU_OSARCH:=@OPENJDK_TARGET_CPU_OSARCH@
 OPENJDK_TARGET_OS_INCLUDE_SUBDIR:=@OPENJDK_TARGET_OS_INCLUDE_SUBDIR@
 
@@ -297,13 +296,10 @@
 
 # Used for make-time verifications
 VALID_JVM_FEATURES := @VALID_JVM_FEATURES@
 VALID_JVM_VARIANTS := @VALID_JVM_VARIANTS@
 
-# Control whether Hotspot builds gtest tests
-BUILD_GTEST := @BUILD_GTEST@
-
 # Allow overriding the default hotspot library path
 HOTSPOT_OVERRIDE_LIBPATH := @HOTSPOT_OVERRIDE_LIBPATH@
 
 # Control use of precompiled header in hotspot libjvm build
 USE_PRECOMPILED_HEADER := @USE_PRECOMPILED_HEADER@
@@ -397,10 +393,12 @@
 JMH_GENERATOR_JAR := @JMH_GENERATOR_JAR@
 JMH_JOPT_SIMPLE_JAR := @JMH_JOPT_SIMPLE_JAR@
 JMH_COMMONS_MATH_JAR := @JMH_COMMONS_MATH_JAR@
 JMH_VERSION := @JMH_VERSION@
 
+GTEST_FRAMEWORK_SRC := @GTEST_FRAMEWORK_SRC@
+
 # Source file for cacerts
 CACERTS_FILE=@CACERTS_FILE@
 
 # Enable unlimited crypto policy
 UNLIMITED_CRYPTO=@UNLIMITED_CRYPTO@
@@ -431,11 +429,11 @@
 MACOSX_VERSION_MAX=@MACOSX_VERSION_MAX@
 
 # The macosx code signing identity to use
 MACOSX_CODESIGN_IDENTITY=@MACOSX_CODESIGN_IDENTITY@
 
-# Toolchain type: gcc, clang, solstudio, lxc, microsoft...
+# Toolchain type: gcc, clang, xlc, microsoft...
 TOOLCHAIN_TYPE:=@TOOLCHAIN_TYPE@
 TOOLCHAIN_VERSION := @TOOLCHAIN_VERSION@
 CC_VERSION_NUMBER := @CC_VERSION_NUMBER@
 CXX_VERSION_NUMBER := @CXX_VERSION_NUMBER@
 
@@ -474,11 +472,10 @@
 C_FLAG_DEPS:=@C_FLAG_DEPS@
 CXX_FLAG_DEPS:=@CXX_FLAG_DEPS@
 
 DISABLE_WARNING_PREFIX := @DISABLE_WARNING_PREFIX@
 CFLAGS_WARNINGS_ARE_ERRORS:=@CFLAGS_WARNINGS_ARE_ERRORS@
-LDFLAGS_WARNINGS_ARE_ERRORS:=@LDFLAGS_WARNINGS_ARE_ERRORS@
 DISABLED_WARNINGS := @DISABLED_WARNINGS@
 DISABLED_WARNINGS_C := @DISABLED_WARNINGS_C@
 DISABLED_WARNINGS_CXX := @DISABLED_WARNINGS_CXX@
 
 # A global flag (true or false) determining if native warnings are considered errors.
@@ -528,11 +525,10 @@
 SDKROOT:=@SDKROOT@
 
 # LDFLAGS used to link the jdk native libraries (C-code)
 LDFLAGS_JDKLIB:=@LDFLAGS_JDKLIB@
 JDKLIB_LIBS:=@JDKLIB_LIBS@
-GLOBAL_LIBS:=@GLOBAL_LIBS@
 
 # LDFLAGS used to link the jdk native launchers (C-code)
 LDFLAGS_JDKEXE:=@LDFLAGS_JDKEXE@
 JDKEXE_LIBS:=@JDKEXE_LIBS@
 
@@ -578,14 +574,10 @@
 
 # Options to linker to specify a mapfile.
 # (Note absence of := assignment, because we do not want to evaluate the macro body here)
 SET_SHARED_LIBRARY_MAPFILE=@SET_SHARED_LIBRARY_MAPFILE@
 
-# Options for C/CXX compiler to be used if linking is performed
-#   using reorder file
-C_FLAG_REORDER:=@C_FLAG_REORDER@
-
 #
 # Options for generating debug symbols
 COMPILE_WITH_DEBUG_SYMBOLS := @COMPILE_WITH_DEBUG_SYMBOLS@
 COPY_DEBUG_SYMBOLS := @COPY_DEBUG_SYMBOLS@
 ZIP_EXTERNAL_DEBUG_SYMBOLS := @ZIP_EXTERNAL_DEBUG_SYMBOLS@
@@ -637,23 +629,21 @@
 JAVADOC_CMD:=@JAVADOC@
 JAR_CMD:=@JAR@
 JLINK_CMD := @JLINK@
 JMOD_CMD := @JMOD@
 JARSIGNER_CMD:=@JARSIGNER@
-JJS_CMD:=@JJS@
 # These variables are meant to be used. They are defined with = instead of := to make
 # it possible to override only the *_CMD variables.
 JAVA=@FIXPATH@ $(JAVA_CMD) $(JAVA_FLAGS_BIG) $(JAVA_FLAGS)
 JAVA_SMALL=@FIXPATH@ $(JAVA_CMD) $(JAVA_FLAGS_SMALL) $(JAVA_FLAGS)
 JAVA_DETACH =@FIXPATH@ @FIXPATH_DETACH_FLAG@ $(JAVA_CMD) $(JAVA_FLAGS_BIG) $(JAVA_FLAGS)
 JAVAC=@FIXPATH@ $(JAVAC_CMD)
 JAVADOC=@FIXPATH@ $(JAVADOC_CMD)
 JAR=@FIXPATH@ $(JAR_CMD)
-JLINK = @FIXPATH@ $(JLINK_CMD) $(JAVA_TOOL_FLAGS_SMALL)
+JLINK = @FIXPATH@ $(JLINK_CMD)
 JMOD = @FIXPATH@ $(JMOD_CMD) $(JAVA_TOOL_FLAGS_SMALL)
 JARSIGNER=@FIXPATH@ $(JARSIGNER_CMD)
-JJS=@FIXPATH@ $(JJS_CMD) $(JAVA_TOOL_FLAGS_SMALL)
 
 BUILD_JAVA_FLAGS := @BOOTCYCLE_JVM_ARGS_BIG@
 BUILD_JAVA=@FIXPATH@ $(BUILD_JDK)/bin/java $(BUILD_JAVA_FLAGS)
 BUILD_JAR=@FIXPATH@ $(BUILD_JDK)/bin/jar
 
@@ -662,10 +652,11 @@
 INTERIM_LANGTOOLS_MODULES := $(addsuffix .interim, $(INTERIM_LANGTOOLS_BASE_MODULES))
 INTERIM_LANGTOOLS_ADD_EXPORTS := \
     --add-exports java.base/sun.reflect.annotation=jdk.compiler.interim \
     --add-exports java.base/jdk.internal.jmod=jdk.compiler.interim \
     --add-exports java.base/jdk.internal.misc=jdk.compiler.interim \
+    --add-exports java.base/sun.invoke.util=jdk.compiler.interim \
     #
 INTERIM_LANGTOOLS_MODULES_COMMA := $(strip $(subst $(SPACE),$(COMMA),$(strip \
     $(INTERIM_LANGTOOLS_MODULES))))
 INTERIM_LANGTOOLS_ARGS := \
     --limit-modules java.base,jdk.zipfs,$(INTERIM_LANGTOOLS_MODULES_COMMA) \
@@ -750,11 +741,10 @@
 CYGPATH:=@CYGPATH@
 WSLPATH:=@WSLPATH@
 LDD:=@LDD@
 OTOOL:=@OTOOL@
 READELF:=@READELF@
-ELFEDIT:=@ELFEDIT@
 EXPR:=@EXPR@
 FILE:=@FILE@
 DOT:=@DOT@
 HG:=@HG@
 GIT:=@GIT@
@@ -767,11 +757,10 @@
 DTRACE := @DTRACE@
 FIXPATH:=@FIXPATH@
 ULIMIT:=@ULIMIT@
 
 TAR_TYPE:=@TAR_TYPE@
-TAR_CREATE_EXTRA_PARAM:=@TAR_CREATE_EXTRA_PARAM@
 TAR_INCLUDE_PARAM:=@TAR_INCLUDE_PARAM@
 TAR_SUPPORTS_TRANSFORM:=@TAR_SUPPORTS_TRANSFORM@
 
 # Build setup
 ENABLE_AOT:=@ENABLE_AOT@
@@ -784,11 +773,10 @@
 LIBZIP_CAN_USE_MMAP:=@LIBZIP_CAN_USE_MMAP@
 MSVCR_DLL:=@MSVCR_DLL@
 VCRUNTIME_1_DLL:=@VCRUNTIME_1_DLL@
 MSVCP_DLL:=@MSVCP_DLL@
 UCRT_DLL_DIR:=@UCRT_DLL_DIR@
-STLPORT_LIB:=@STLPORT_LIB@
 ENABLE_PANDOC:=@ENABLE_PANDOC@
 PANDOC_MARKDOWN_FLAG:=@PANDOC_MARKDOWN_FLAG@
 
 ####################################################
 #
diff a/make/conf/jib-profiles.js b/make/conf/jib-profiles.js
--- a/make/conf/jib-profiles.js
+++ b/make/conf/jib-profiles.js
@@ -243,12 +243,12 @@
     common.build_id = getBuildId(input);
     common.build_number = input.build_number != null ? input.build_number : "0";
 
     // List of the main profile names used for iteration
     common.main_profile_names = [
-        "linux-x64", "linux-x64-musl", "linux-x86", "macosx-x64", "solaris-x64",
-        "solaris-sparcv9", "windows-x64", "windows-x86",
+        "linux-x64", "linux-x64-musl", "linux-x86", "macosx-x64",
+        "windows-x64", "windows-x86",
         "linux-aarch64", "linux-arm32", "linux-ppc64le", "linux-s390x"
     ];
 
     // These are the base setttings for all the main build profiles.
     common.main_profile_base = {
@@ -408,11 +408,11 @@
     var profiles = {
 
         "linux-x64": {
             target_os: "linux",
             target_cpu: "x64",
-            dependencies: ["devkit", "graphviz", "pandoc", "graalunit_lib"],
+            dependencies: ["devkit", "gtest", "graphviz", "pandoc", "graalunit_lib"],
             configure_args: concat(common.configure_args_64bit,
                 "--enable-full-docs", "--with-zlib=system",
                 (isWsl(input) ? [ "--host=x86_64-unknown-linux-gnu",
                     "--build=x86_64-unknown-linux-gnu" ] : [])),
             default_make_targets: ["docs-bundles"],
@@ -428,59 +428,46 @@
 
         "linux-x86": {
             target_os: "linux",
             target_cpu: "x86",
             build_cpu: "x64",
-            dependencies: ["devkit"],
+            dependencies: ["devkit", "gtest"],
             configure_args: concat(common.configure_args_32bit,
                 "--with-jvm-variants=minimal,server", "--with-zlib=system"),
         },
 
         "macosx-x64": {
             target_os: "macosx",
             target_cpu: "x64",
-            dependencies: ["devkit", "pandoc", "graalunit_lib"],
+            dependencies: ["devkit", "gtest", "pandoc", "graalunit_lib"],
             configure_args: concat(common.configure_args_64bit, "--with-zlib=system",
-                "--with-macosx-version-max=10.9.0"),
-        },
-
-        "solaris-x64": {
-            target_os: "solaris",
-            target_cpu: "x64",
-            dependencies: ["devkit", "cups"],
-            configure_args: concat(common.configure_args_64bit,
-                "--with-zlib=system", "--enable-dtrace", "--enable-deprecated-ports=yes"),
-        },
-
-        "solaris-sparcv9": {
-            target_os: "solaris",
-            target_cpu: "sparcv9",
-            dependencies: ["devkit", "cups"],
-            configure_args: concat(common.configure_args_64bit,
-                "--with-zlib=system", "--enable-dtrace", "--enable-deprecated-ports=yes"),
+                "--with-macosx-version-max=10.9.0",
+                // Use system SetFile instead of the one in the devkit as the
+                // devkit one may not work on Catalina.
+                "SETFILE=/usr/bin/SetFile"),
         },
 
         "windows-x64": {
             target_os: "windows",
             target_cpu: "x64",
-            dependencies: ["devkit", "pandoc", "graalunit_lib"],
+            dependencies: ["devkit", "gtest", "pandoc", "graalunit_lib"],
             configure_args: concat(common.configure_args_64bit),
         },
 
         "windows-x86": {
             target_os: "windows",
             target_cpu: "x86",
             build_cpu: "x64",
-            dependencies: ["devkit"],
+            dependencies: ["devkit", "gtest"],
             configure_args: concat(common.configure_args_32bit),
         },
 
         "linux-aarch64": {
             target_os: "linux",
             target_cpu: "aarch64",
             build_cpu: "x64",
-            dependencies: ["devkit", "build_devkit", "pandoc"],
+            dependencies: ["devkit", "gtest", "build_devkit", "pandoc"],
             configure_args: [
                 "--openjdk-target=aarch64-linux-gnu",
 		"--disable-jvm-feature-jvmci",
 		"--disable-jvm-feature-graal",
 		"--disable-jvm-feature-aot",
@@ -489,33 +476,33 @@
 
         "linux-arm32": {
             target_os: "linux",
             target_cpu: "arm",
             build_cpu: "x64",
-            dependencies: ["devkit", "build_devkit"],
+            dependencies: ["devkit", "gtest", "build_devkit"],
             configure_args: [
                 "--openjdk-target=arm-linux-gnueabihf", "--with-freetype=bundled",
                 "--with-abi-profile=arm-vfp-hflt", "--disable-warnings-as-errors"
             ],
         },
 
         "linux-ppc64le": {
             target_os: "linux",
             target_cpu: "ppc64le",
             build_cpu: "x64",
-            dependencies: ["devkit", "build_devkit"],
+            dependencies: ["devkit", "gtest", "build_devkit"],
             configure_args: [
                 "--openjdk-target=ppc64le-linux-gnu", "--with-freetype=bundled",
                 "--disable-warnings-as-errors"
             ],
         },
 
         "linux-s390x": {
             target_os: "linux",
             target_cpu: "s390x",
             build_cpu: "x64",
-            dependencies: ["devkit", "build_devkit"],
+            dependencies: ["devkit", "gtest", "build_devkit"],
             configure_args: [
                 "--openjdk-target=s390x-linux-gnu", "--with-freetype=bundled",
                 "--disable-warnings-as-errors"
             ],
         },
@@ -545,11 +532,11 @@
         dependencies: [ "ant" ],
         environment: {
             "ANT_HOME": input.get("ant", "home_path")
         }
     };
-    [ "linux-x64", "macosx-x64", "solaris-sparcv9", "solaris-x64", "windows-x64"]
+    [ "linux-x64", "macosx-x64", "windows-x64"]
         .forEach(function (name) {
             var maketestName = name + "-testmake";
             profiles[maketestName] = concatObjects(profiles[name], testmakeBase);
             profiles[maketestName].default_make_targets = [ "test-make" ];
         });
@@ -566,11 +553,11 @@
     // Profiles for building the zero jvm variant. These are used for verification.
     var zeroProfiles = {
         "linux-x64-zero": {
             target_os: "linux",
             target_cpu: "x64",
-            dependencies: ["devkit"],
+            dependencies: ["devkit", "gtest"],
             configure_args: concat(common.configure_args_64bit, [
                 "--with-zlib=system",
                 "--with-jvm-variants=zero",
                 "--enable-libffi-bundling"
             ])
@@ -578,11 +565,11 @@
 
         "linux-x86-zero": {
             target_os: "linux",
             target_cpu: "x86",
             build_cpu: "x64",
-            dependencies: ["devkit"],
+            dependencies: ["devkit", "gtest"],
             configure_args:  concat(common.configure_args_32bit, [
                 "--with-zlib=system",
                 "--with-jvm-variants=zero",
                 "--enable-libffi-bundling"
             ])
@@ -601,11 +588,11 @@
     // verfication of this build configuration.
     var noPchProfiles = {
         "linux-x64-debug-nopch": {
             target_os: "linux",
             target_cpu: "x64",
-            dependencies: ["devkit"],
+            dependencies: ["devkit", "gtest"],
             configure_args: concat(common.configure_args_64bit,
                 "--with-zlib=system", "--disable-precompiled-headers"),
         },
     };
     profiles = concatObjects(profiles, noPchProfiles);
@@ -619,11 +606,11 @@
     });
 
     // Bootcycle profiles runs the build with itself as the boot jdk. This can
     // be done in two ways. Either using the builtin bootcycle target in the
     // build system. Or by supplying the main jdk build as bootjdk to configure.
-    [ "linux-x64", "macosx-x64", "solaris-sparcv9", "windows-x64"]
+    [ "linux-x64", "macosx-x64", "windows-x64" ]
         .forEach(function (name) {
             var bootcycleName = name + "-bootcycle";
             var bootcyclePrebuiltName = name + "-bootcycle-prebuilt";
             // The base bootcycle profile just changes the default target
             // compared to the base profile
@@ -632,25 +619,21 @@
             // The prebuilt bootcycle variant modifies the boot jdk argument
             var bootcyclePrebuiltBase = {
                 dependencies: [ name + ".jdk" ],
                 configure_args: [
                     "--with-boot-jdk=" + input.get(name + ".jdk", "home_path"),
-                    // Full docs do not currently work with bootcycle build
-                    // since Nashorn was removed. This negates the
-                    // --enable-full-docs from the main profile.
-                    "--enable-full-docs=auto",
                 ]
             }
             profiles[bootcyclePrebuiltName] = concatObjects(profiles[name],
                 bootcyclePrebuiltBase);
             var bootJdkIndex = profiles[bootcyclePrebuiltName].dependencies.indexOf("boot_jdk");
             delete profiles[bootcyclePrebuiltName].dependencies[bootJdkIndex];
             profiles[bootcyclePrebuiltName].default_make_targets = [ "product-images" ];
         });
 
     // JCov profiles build JCov-instrumented JDK image based on images provided through dependencies.
-    [ "linux-aarch64", "linux-x64", "macosx-x64", "solaris-sparcv9", "windows-x64"]
+    [ "linux-aarch64", "linux-x64", "macosx-x64", "windows-x64" ]
         .forEach(function (name) {
             var jcovName = name + "-jcov";
             profiles[jcovName] = clone(common.main_profile_base);
             profiles[jcovName].target_os = profiles[name].target_os
             profiles[jcovName].target_cpu = profiles[name].target_cpu
@@ -679,16 +662,10 @@
         },
         "macosx-x64": {
             platform: "osx-x64",
             jdk_subdir: "jdk-" + data.version +  ".jdk/Contents/Home",
         },
-        "solaris-x64": {
-            platform: "solaris-x64",
-        },
-        "solaris-sparcv9": {
-            platform: "solaris-sparcv9",
-        },
         "windows-x64": {
             platform: "windows-x64",
             jdk_suffix: "zip",
         },
         "windows-x86": {
@@ -726,11 +703,11 @@
             artifacts: {
                 doc_api_spec: {
                     local: "bundles/\\(jdk.*doc-api-spec.tar.gz\\)",
                     remote: [
                         "bundles/common/jdk-" + data.version + "_doc-api-spec.tar.gz",
-                        "bundles/linux-x64/\\1"
+                        "bundles/common/\\1"
                     ],
                 },
             }
         }
     };
@@ -803,19 +780,19 @@
                     = concat(profiles[cmpBaselineName].default_make_targets, "docs");
             }
             profiles[cmpBaselineName].make_args = [ "COMPARE_BUILD=CONF=" ];
             profiles[cmpBaselineName].configure_args = concat(
                 profiles[cmpBaselineName].configure_args,
-                "--with-hotspot-build-time=n/a", 
+                "--with-hotspot-build-time=n/a",
                 "--disable-precompiled-headers");
             // Do not inherit artifact definitions from base profile
             delete profiles[cmpBaselineName].artifacts;
         });
     });
 
     // Artifacts of JCov profiles
-    [ "linux-aarch64", "linux-x64", "macosx-x64", "solaris-sparcv9", "windows-x64"]
+    [ "linux-aarch64", "linux-x64", "macosx-x64", "windows-x64" ]
         .forEach(function (name) {
             var o = artifactData[name]
             var jdk_subdir = (o.jdk_subdir != null ? o.jdk_subdir : "jdk-" + data.version);
             var jdk_suffix = (o.jdk_suffix != null ? o.jdk_suffix : "tar.gz");
             var pf = o.platform
@@ -1000,12 +977,10 @@
 var getJibProfilesDependencies = function (input, common) {
 
     var devkit_platform_revisions = {
         linux_x64: "gcc9.2.0-OL6.4+1.0",
         macosx_x64: "Xcode10.1-MacOSX10.14+1.0",
-        solaris_x64: "SS12u4-Solaris11u1+1.0",
-        solaris_sparcv9: "SS12u6-Solaris11u3+1.0",
         windows_x64: "VS2019-16.5.3+1.0",
         linux_aarch64: "gcc9.2.0-OL7.6+1.0",
         linux_arm: "gcc8.2.0-Fedora27+1.0",
         linux_ppc64le: "gcc8.2.0-Fedora27+1.0",
         linux_s390x: "gcc8.2.0-Fedora27+1.0"
@@ -1014,13 +989,15 @@
     var devkit_platform = (input.target_cpu == "x86"
         ? input.target_os + "_x64"
         : input.target_platform);
 
     var devkit_cross_prefix = "";
-    if (input.build_platform != input.target_platform
-       && input.build_platform != devkit_platform) {
-        devkit_cross_prefix = input.build_platform + "-to-";
+    if (!(input.target_os == "windows" && isWsl(input))) {
+        if (input.build_platform != input.target_platform
+           && input.build_platform != devkit_platform) {
+            devkit_cross_prefix = input.build_platform + "-to-";
+        }
     }
 
     var boot_jdk_platform = (input.build_os == "macosx" ? "osx" : input.build_os)
         + "-" + input.build_cpu +
         (input.build_libc ? "-" + input.build_libc : "");
@@ -1055,15 +1032,10 @@
                 + boot_jdk_platform + "_bin" + boot_jdk_ext,
             configure_args: "--with-boot-jdk=" + common.boot_jdk_home,
             environment_path: common.boot_jdk_home + "/bin"
         }
     }
-    if (input.build_cpu == 'sparcv9') {
-        boot_jdk.file = "bundles/openjdk/GPL/" + boot_jdk_platform
-            + "/openjdk-" + common.boot_jdk_version + "_"
-            + boot_jdk_platform + "_bin" + boot_jdk_ext;
-    }
 
     var dependencies = {
         boot_jdk: boot_jdk,
 
         devkit: {
@@ -1090,14 +1062,14 @@
         },
 
         jtreg: {
             server: "jpg",
             product: "jtreg",
-            version: "5.0",
+            version: "5.1",
             build_number: "b01",
             checksum_file: "MD5_VALUES",
-            file: "bundles/jtreg_bin-5.0.zip",
+            file: "bundles/jtreg_bin-5.1.zip",
             environment_name: "JT_HOME",
             environment_path: input.get("jtreg", "home_path") + "/bin",
             configure_args: "--with-jtreg=" + input.get("jtreg", "home_path"),
         },
 
@@ -1192,10 +1164,16 @@
             revision: "619_Apr_12_2018",
             module: "graalunit-lib",
             configure_args: "--with-graalunit-lib=" + input.get("graalunit_lib", "install_path"),
             environment_name: "GRAALUNIT_LIB"
         },
+
+        gtest: {
+            organization: common.organization,
+            ext: "tar.gz",
+            revision: "1.8.1"
+        },
     };
 
     return dependencies;
 };
 
diff a/make/hotspot/lib/CompileJvm.gmk b/make/hotspot/lib/CompileJvm.gmk
--- a/make/hotspot/lib/CompileJvm.gmk
+++ b/make/hotspot/lib/CompileJvm.gmk
@@ -27,13 +27,10 @@
 # jvm feature set, specific file overrides, and general flags.
 include lib/JvmFeatures.gmk
 include lib/JvmOverrideFiles.gmk
 include lib/JvmFlags.gmk
 
-# Include support files that will setup DTRACE_EXTRA_OBJECT_FILES.
-include lib/JvmDtraceObjects.gmk
-
 ################################################################################
 # Setup compilation of the main Hotspot native library (libjvm).
 
 JVM_OUTPUTDIR := $(JVM_VARIANT_OUTPUTDIR)/libjvm
 JVM_MAPFILE := $(JVM_OUTPUTDIR)/mapfile
@@ -58,12 +55,10 @@
 JVM_EXCLUDES += adlc
 
 # Needed by abstract_vm_version.cpp
 ifeq ($(call isTargetCpu, x86_64), true)
   OPENJDK_TARGET_CPU_VM_VERSION := amd64
-else ifeq ($(call isTargetCpu, sparcv9), true)
-  OPENJDK_TARGET_CPU_VM_VERSION := sparc
 else
   OPENJDK_TARGET_CPU_VM_VERSION := $(OPENJDK_TARGET_CPU)
 endif
 
 ifneq ($(HOTSPOT_TARGET_LIBC),)
@@ -89,24 +84,21 @@
 
 DISABLED_WARNINGS_gcc := parentheses comment unknown-pragmas address \
     delete-non-virtual-dtor char-subscripts array-bounds int-in-bool-context \
     ignored-qualifiers  missing-field-initializers implicit-fallthrough \
     empty-body strict-overflow sequence-point maybe-uninitialized \
-    misleading-indentation cast-function-type
+    misleading-indentation cast-function-type shift-negative-value
 
 ifeq ($(call check-jvm-feature, zero), true)
   DISABLED_WARNINGS_gcc += return-type switch clobbered
 endif
 
 DISABLED_WARNINGS_clang := tautological-compare \
     undefined-var-template sometimes-uninitialized unknown-pragmas \
     delete-non-virtual-dtor missing-braces char-subscripts \
-    ignored-qualifiers missing-field-initializers mismatched-tags
-
-DISABLED_WARNINGS_solstudio := labelnotused hidef w_novirtualdescr inlafteruse \
-    unknownpragma doubunder w_enumnotused w_toomanyenumnotused \
-    wvarhidenmem wunreachable wnoretvalue notemsource
+    ignored-qualifiers missing-field-initializers mismatched-tags \
+    shift-negative-value
 
 DISABLED_WARNINGS_xlc := tautological-compare shift-negative-value
 
 DISABLED_WARNINGS_microsoft :=
 
@@ -137,33 +129,10 @@
   JVM_EXCLUDE_PATTERNS += x86_64
 else ifeq ($(call isTargetCpu, x86_64), true)
   JVM_EXCLUDE_PATTERNS += x86_32
 endif
 
-# Inline assembly for solaris
-ifeq ($(call isTargetOs, solaris), true)
-  ifeq ($(call isTargetCpu, x86_64), true)
-    JVM_CFLAGS += $(TOPDIR)/src/hotspot/os_cpu/solaris_x86/solaris_x86_64.il
-  else ifeq ($(call isTargetCpu, sparcv9), true)
-    JVM_CFLAGS += $(TOPDIR)/src/hotspot/os_cpu/solaris_sparc/solaris_sparc.il
-  endif
-  # Exclude warnings in devstudio 12.6
-  ifeq ($(CC_VERSION_NUMBER), 5.15)
-    DISABLED_WARNINGS_solstudio += SEC_ARR_OUTSIDE_BOUND_READ \
-      SEC_ARR_OUTSIDE_BOUND_WRITE
-  endif
-endif
-
-ifeq ($(call And, $(call isTargetOs, solaris) $(call isTargetCpu, sparcv9)), true)
-  ifeq ($(COMPILE_WITH_DEBUG_SYMBOLS), false)
-    # NOTE: In the old build, we weirdly enough set -g/-g0 always, regardless
-    # of if debug symbols were needed. Without it, compilation fails on
-    # sparc! :-(
-    JVM_CFLAGS += -g0
-  endif
-endif
-
 ifeq ($(call isTargetOs, windows), true)
   ifeq ($(call isTargetCpuBits, 64), true)
     RC_DESC := 64-Bit$(SPACE)
   endif
   JVM_RCFLAGS += -D"HS_FILEDESC=$(HOTSPOT_VM_DISTRO) $(RC_DESC)$(JVM_VARIANT) VM"
@@ -188,17 +157,15 @@
     OUTPUT_DIR := $(JVM_LIB_OUTPUTDIR), \
     SRC := $(JVM_SRC_DIRS), \
     EXCLUDES := $(JVM_EXCLUDES), \
     EXCLUDE_FILES := $(JVM_EXCLUDE_FILES), \
     EXCLUDE_PATTERNS := $(JVM_EXCLUDE_PATTERNS), \
-    EXTRA_OBJECT_FILES := $(DTRACE_EXTRA_OBJECT_FILES), \
     CFLAGS := $(JVM_CFLAGS), \
     abstract_vm_version.cpp_CXXFLAGS := $(CFLAGS_VM_VERSION), \
     arguments.cpp_CXXFLAGS := $(CFLAGS_VM_VERSION), \
     DISABLED_WARNINGS_gcc := $(DISABLED_WARNINGS_gcc), \
     DISABLED_WARNINGS_clang := $(DISABLED_WARNINGS_clang), \
-    DISABLED_WARNINGS_solstudio := $(DISABLED_WARNINGS_solstudio), \
     DISABLED_WARNINGS_xlc := $(DISABLED_WARNINGS_xlc), \
     DISABLED_WARNINGS_microsoft := $(DISABLED_WARNINGS_microsoft), \
     ASFLAGS := $(JVM_ASFLAGS), \
     LDFLAGS := $(JVM_LDFLAGS), \
     LIBS := $(JVM_LIBS), \
@@ -278,34 +245,24 @@
 # for the associated class.  If the class doesn't provide a more specific
 # declaration (either directly or by inheriting from a class that provides
 # one) then the global definition will be used, triggering this check.
 
 ifneq ($(GENERATE_COMPILE_COMMANDS_ONLY), true)
-  ifneq ($(filter $(TOOLCHAIN_TYPE), gcc clang solstudio), )
+  ifneq ($(filter $(TOOLCHAIN_TYPE), gcc clang), )
 
     DEMANGLED_REGEXP := [^:]operator (new|delete)
 
     # Running c++filt to find offending symbols in all files is too expensive,
-    # especially on Solaris, so use mangled names when looking for symbols.
+    # so use mangled names when looking for symbols.
     # Save the demangling for when something is actually found.
-    ifeq ($(TOOLCHAIN_TYPE), solstudio)
-      MANGLED_SYMS := \
-          __1c2n6FL_pv_ \
-          __1c2N6FL_pv_ \
-          __1c2k6Fpv_v_ \
-          __1c2K6Fpv_v_ \
-          #
-      UNDEF_PATTERN := UNDEF
-    else
-      MANGLED_SYMS := \
-          _ZdaPv \
-          _ZdlPv \
-          _Znam \
-          _Znwm \
-          #
-      UNDEF_PATTERN := ' U '
-    endif
+    MANGLED_SYMS := \
+        _ZdaPv \
+        _ZdlPv \
+        _Znam \
+        _Znwm \
+        #
+    UNDEF_PATTERN := ' U '
 
     define SetupOperatorNewDeleteCheck
         $1.op_check: $1
 	  if [ -n "`$(NM) $$< | $(GREP) $(addprefix -e , $(MANGLED_SYMS)) \
 	      | $(GREP) $(UNDEF_PATTERN)`" ]; then \
diff a/make/modules/java.base/lib/CoreLibraries.gmk b/make/modules/java.base/lib/CoreLibraries.gmk
--- a/make/modules/java.base/lib/CoreLibraries.gmk
+++ b/make/modules/java.base/lib/CoreLibraries.gmk
@@ -27,14 +27,10 @@
 # libfdlibm is statically linked with libjava below and not delivered into the
 # product on its own.
 
 BUILD_LIBFDLIBM_OPTIMIZATION := NONE
 
-ifeq ($(call isTargetOs, solaris), true)
-  BUILD_LIBFDLIBM_OPTIMIZATION := HIGH
-endif
-
 # If FDLIBM_CFLAGS is non-empty we know that we can optimize
 # fdlibm when adding those extra C flags. Currently GCC,
 # and clang only.
 ifneq ($(FDLIBM_CFLAGS), )
   BUILD_LIBFDLIBM_OPTIMIZATION := LOW
@@ -60,11 +56,11 @@
 ))
 
 ##########################################################################################
 
 LIBVERIFY_OPTIMIZATION := HIGH
-ifeq ($(call isTargetOs, solaris linux), true)
+ifeq ($(call isTargetOs, linux), true)
   ifeq ($(COMPILE_WITH_DEBUG_SYMBOLS), true)
     LIBVERIFY_OPTIMIZATION := LOW
   endif
 endif
 
@@ -96,19 +92,17 @@
         $(LIBJAVA_CFLAGS), \
     jdk_util.c_CFLAGS := $(VERSION_CFLAGS), \
     EXTRA_HEADER_DIRS := libfdlibm, \
     WARNINGS_AS_ERRORS_xlc := false, \
     DISABLED_WARNINGS_gcc := unused-result unused-function, \
-    DISABLED_WARNINGS_solstudio := E_STATEMENT_NOT_REACHED, \
     LDFLAGS := $(LDFLAGS_JDKLIB) \
         $(call SET_SHARED_LIBRARY_ORIGIN), \
     LDFLAGS_macosx := -L$(SUPPORT_OUTPUTDIR)/native/$(MODULE)/, \
     LDFLAGS_windows := -delayload:shell32.dll, \
     LIBS := $(BUILD_LIBFDLIBM_TARGET), \
     LIBS_unix := -ljvm, \
     LIBS_linux := $(LIBDL), \
-    LIBS_solaris := -lsocket -lnsl -lscf $(LIBDL), \
     LIBS_aix := $(LIBDL) $(LIBM),\
     LIBS_macosx := -framework CoreFoundation \
         -framework Foundation \
         -framework SystemConfiguration, \
     LIBS_windows := jvm.lib \
@@ -172,11 +166,11 @@
 TARGETS += $(BUILD_LIBJIMAGE)
 
 ##########################################################################################
 
 ifeq ($(call isTargetOs, macosx), true)
-  LIBJLI_EXCLUDE_FILES += java_md_solinux.c
+  LIBJLI_EXCLUDE_FILES += java_md.c
 endif
 
 ifeq ($(call isTargetOs, windows), true)
   # Supply the name of the C runtime lib.
   LIBJLI_CFLAGS += -DMSVCR_DLL_NAME='"$(notdir $(MSVCR_DLL))"'
@@ -215,11 +209,10 @@
     DISABLED_WARNINGS_clang := sometimes-uninitialized format-nonliteral, \
     LDFLAGS := $(LDFLAGS_JDKLIB) \
         $(call SET_SHARED_LIBRARY_ORIGIN), \
     LIBS_unix := $(LIBZ_LIBS), \
     LIBS_linux := $(LIBDL) -lpthread, \
-    LIBS_solaris := $(LIBDL), \
     LIBS_aix := $(LIBDL),\
     LIBS_macosx := -framework Cocoa -framework Security -framework ApplicationServices, \
     LIBS_windows := advapi32.lib comctl32.lib user32.lib, \
 ))
 
diff a/make/modules/jdk.hotspot.agent/Lib.gmk b/make/modules/jdk.hotspot.agent/Lib.gmk
--- a/make/modules/jdk.hotspot.agent/Lib.gmk
+++ b/make/modules/jdk.hotspot.agent/Lib.gmk
@@ -28,13 +28,10 @@
 ################################################################################
 
 ifeq ($(call isTargetOs, linux), true)
   SA_CFLAGS := -D_FILE_OFFSET_BITS=64
 
-else ifeq ($(call isTargetOs, solaris), true)
-  SA_LDFLAGS := -mt
-
 else ifeq ($(call isTargetOs, macosx), true)
   SA_CFLAGS := -Damd64 -D_GNU_SOURCE -mno-omit-leaf-frame-pointer \
       -mstack-alignment=16 -fPIC
   LIBSA_EXTRA_SRC := $(SUPPORT_OUTPUTDIR)/gensrc/jdk.hotspot.agent
 else ifeq ($(call isTargetOs, windows), true)
@@ -65,17 +62,15 @@
     TOOLCHAIN := $(SA_TOOLCHAIN), \
     OPTIMIZATION := HIGH, \
     DISABLED_WARNINGS_microsoft := 4267, \
     DISABLED_WARNINGS_gcc := sign-compare pointer-arith, \
     DISABLED_WARNINGS_clang := sign-compare pointer-arith format-nonliteral, \
-    DISABLED_WARNINGS_CXX_solstudio := truncwarn unknownpragma doubunder, \
     CFLAGS := $(CFLAGS_JDKLIB) $(SA_CFLAGS), \
     CXXFLAGS := $(CXXFLAGS_JDKLIB) $(SA_CFLAGS) $(SA_CXXFLAGS), \
     EXTRA_SRC := $(LIBSA_EXTRA_SRC), \
-    LDFLAGS := $(LDFLAGS_JDKLIB) $(SA_LDFLAGS), \
+    LDFLAGS := $(LDFLAGS_JDKLIB), \
     LIBS_linux := $(LIBDL), \
-    LIBS_solaris := -ldl -ldemangle -lthread -lproc, \
     LIBS_macosx := -framework Foundation -framework JavaNativeFoundation \
         -framework JavaRuntimeSupport -framework Security -framework CoreFoundation, \
     LIBS_windows := dbgeng.lib, \
 ))
 
diff a/make/modules/jdk.jdwp.agent/Lib.gmk b/make/modules/jdk.jdwp.agent/Lib.gmk
--- a/make/modules/jdk.jdwp.agent/Lib.gmk
+++ b/make/modules/jdk.jdwp.agent/Lib.gmk
@@ -1,7 +1,7 @@
 #
-# Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License version 2 only, as
 # published by the Free Software Foundation.  Oracle designates this
@@ -36,11 +36,10 @@
         include \
         libjdwp/export, \
     LDFLAGS := $(LDFLAGS_JDKLIB) \
         $(call SET_SHARED_LIBRARY_ORIGIN), \
     LIBS_linux := -lpthread, \
-    LIBS_solaris := -lnsl -lsocket, \
     LIBS_windows := $(JDKLIB_LIBS) ws2_32.lib iphlpapi.lib, \
 ))
 
 $(BUILD_LIBDT_SOCKET): $(call FindLib, java.base, java)
 
@@ -62,14 +61,12 @@
       libjdwp/export, \
     LDFLAGS := $(LDFLAGS_JDKLIB) \
         $(call SET_SHARED_LIBRARY_ORIGIN), \
     LIBS := $(JDKLIB_LIBS), \
     LIBS_linux := $(LIBDL), \
-    LIBS_solaris := $(LIBDL), \
     LIBS_macosx := -liconv, \
     LIBS_aix := -liconv, \
-    LIBS_windows := $(WIN_JAVA_LIB), \
 ))
 
 $(BUILD_LIBJDWP): $(call FindLib, java.base, java)
 
 TARGETS += $(BUILD_LIBJDWP)
diff a/make/test/JtregNativeJdk.gmk b/make/test/JtregNativeJdk.gmk
--- a/make/test/JtregNativeJdk.gmk
+++ b/make/test/JtregNativeJdk.gmk
@@ -1,7 +1,7 @@
 #
-# Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License version 2 only, as
 # published by the Free Software Foundation.  Oracle designates this
@@ -68,13 +68,10 @@
   BUILD_JDK_JTREG_LIBRARIES_LIBS_libDirectIO := -ljava
   BUILD_JDK_JTREG_EXCLUDE += exerevokeall.c
   ifeq ($(call isTargetOs, linux), true)
     BUILD_JDK_JTREG_LIBRARIES_LIBS_libInheritedChannel := -ljava
     BUILD_JDK_JTREG_EXECUTABLES_LIBS_exelauncher := -ldl
-  else ifeq ($(call isTargetOs, solaris), true)
-    BUILD_JDK_JTREG_LIBRARIES_LIBS_libInheritedChannel := -ljava -lsocket -lnsl
-    BUILD_JDK_JTREG_EXECUTABLES_LIBS_exelauncher := -lthread -ldl
   endif
   BUILD_JDK_JTREG_EXECUTABLES_LIBS_exeJliLaunchTest := -ljli
   BUILD_JDK_JTREG_EXECUTABLES_LIBS_exeCallerAccessTest := -ljvm
 endif
 
diff a/src/hotspot/os/linux/os_linux.cpp b/src/hotspot/os/linux/os_linux.cpp
--- a/src/hotspot/os/linux/os_linux.cpp
+++ b/src/hotspot/os/linux/os_linux.cpp
@@ -151,10 +151,11 @@
 pthread_t os::Linux::_main_thread;
 int os::Linux::_page_size = -1;
 bool os::Linux::_supports_fast_thread_cpu_time = false;
 const char * os::Linux::_glibc_version = "unknown";
 const char * os::Linux::_libpthread_version = "unknown";
+size_t os::Linux::_default_large_page_size = 0;
 
 static jlong initial_time_count=0;
 
 static int clock_tics_per_sec = 100;
 
@@ -1376,22 +1377,39 @@
     return elapsedTime();
   }
 }
 
 jlong os::javaTimeMillis() {
-  timeval time;
-  int status = gettimeofday(&time, NULL);
-  assert(status != -1, "linux error");
-  return jlong(time.tv_sec) * 1000  +  jlong(time.tv_usec / 1000);
+  if (os::Posix::supports_clock_gettime()) {
+    struct timespec ts;
+    int status = os::Posix::clock_gettime(CLOCK_REALTIME, &ts);
+    assert_status(status == 0, status, "gettime error");
+    return jlong(ts.tv_sec) * MILLIUNITS +
+           jlong(ts.tv_nsec) / NANOUNITS_PER_MILLIUNIT;
+  } else {
+    timeval time;
+    int status = gettimeofday(&time, NULL);
+    assert(status != -1, "linux error");
+    return jlong(time.tv_sec) * MILLIUNITS  +
+           jlong(time.tv_usec) / (MICROUNITS / MILLIUNITS);
+  }
 }
 
 void os::javaTimeSystemUTC(jlong &seconds, jlong &nanos) {
-  timeval time;
-  int status = gettimeofday(&time, NULL);
-  assert(status != -1, "linux error");
-  seconds = jlong(time.tv_sec);
-  nanos = jlong(time.tv_usec) * 1000;
+  if (os::Posix::supports_clock_gettime()) {
+    struct timespec ts;
+    int status = os::Posix::clock_gettime(CLOCK_REALTIME, &ts);
+    assert_status(status == 0, status, "gettime error");
+    seconds = jlong(ts.tv_sec);
+    nanos = jlong(ts.tv_nsec);
+  } else {
+    timeval time;
+    int status = gettimeofday(&time, NULL);
+    assert(status != -1, "linux error");
+    seconds = jlong(time.tv_sec);
+    nanos = jlong(time.tv_usec) * (NANOUNITS / MICROUNITS);
+  }
 }
 
 void os::Linux::fast_thread_clock_init() {
   if (!UseLinuxPosixThreadCPUClocks) {
     return;
@@ -2052,12 +2070,12 @@
   ::close(fd);
 
   return true;
 }
 
-static void _print_ascii_file_h(const char* header, const char* filename, outputStream* st) {
-  st->print_cr("%s:", header);
+static void _print_ascii_file_h(const char* header, const char* filename, outputStream* st, bool same_line = true) {
+  st->print("%s:%c", header, same_line ? ' ' : '\n');
   if (!_print_ascii_file(filename, st)) {
     st->print_cr("<Not Available>");
   }
 }
 
@@ -2068,47 +2086,49 @@
   pid_t pid = os::Linux::gettid();
 
   jio_snprintf(fname, sizeof(fname), "/proc/%d/maps", pid);
 
   if (!_print_ascii_file(fname, st)) {
-    st->print("Can not get library information for pid = %d\n", pid);
+    st->print_cr("Can not get library information for pid = %d", pid);
   }
 }
 
-int os::get_loaded_modules_info(os::LoadedModulesCallbackFunc callback, void *param) {
-  FILE *procmapsFile = NULL;
-
-  // Open the procfs maps file for the current process
-  if ((procmapsFile = fopen("/proc/self/maps", "r")) != NULL) {
-    // Allocate PATH_MAX for file name plus a reasonable size for other fields.
-    char line[PATH_MAX + 100];
-
-    // Read line by line from 'file'
-    while (fgets(line, sizeof(line), procmapsFile) != NULL) {
-      u8 base, top, inode;
-      char name[sizeof(line)];
-
-      // Parse fields from line, discard perms, offset and device
-      int matches = sscanf(line, UINT64_FORMAT_X "-" UINT64_FORMAT_X " %*s %*s %*s " INT64_FORMAT " %s",
-             &base, &top, &inode, name);
-      // the last entry 'name' is empty for some entries, so we might have 3 matches instead of 4 for some lines
-      if (matches < 3) continue;
-      if (matches == 3) name[0] = '\0';
-
-      // Filter by inode 0 so that we only get file system mapped files.
-      if (inode != 0) {
-
-        // Call callback with the fields of interest
-        if(callback(name, (address)base, (address)top, param)) {
-          // Oops abort, callback aborted
-          fclose(procmapsFile);
-          return 1;
-        }
+struct loaded_modules_info_param {
+  os::LoadedModulesCallbackFunc callback;
+  void *param;
+};
+
+static int dl_iterate_callback(struct dl_phdr_info *info, size_t size, void *data) {
+  if ((info->dlpi_name == NULL) || (*info->dlpi_name == '\0')) {
+    return 0;
+  }
+
+  struct loaded_modules_info_param *callback_param = reinterpret_cast<struct loaded_modules_info_param *>(data);
+  address base = NULL;
+  address top = NULL;
+  for (int idx = 0; idx < info->dlpi_phnum; idx++) {
+    const ElfW(Phdr) *phdr = info->dlpi_phdr + idx;
+    if (phdr->p_type == PT_LOAD) {
+      address raw_phdr_base = reinterpret_cast<address>(info->dlpi_addr + phdr->p_vaddr);
+
+      address phdr_base = align_down(raw_phdr_base, phdr->p_align);
+      if ((base == NULL) || (base > phdr_base)) {
+        base = phdr_base;
+      }
+
+      address phdr_top = align_up(raw_phdr_base + phdr->p_memsz, phdr->p_align);
+      if ((top == NULL) || (top < phdr_top)) {
+        top = phdr_top;
       }
     }
-    fclose(procmapsFile);
-  }
+  }
+
+  return callback_param->callback(info->dlpi_name, base, top, callback_param->param);
+}
+
+int os::get_loaded_modules_info(os::LoadedModulesCallbackFunc callback, void *param) {
+  struct loaded_modules_info_param callback_param = {callback, param};
   return 0;
 }
 
 void os::print_os_info_brief(outputStream* st) {
   os::Linux::print_distro_info(st);
@@ -2118,37 +2138,43 @@
   os::Linux::print_libversion_info(st);
 
 }
 
 void os::print_os_info(outputStream* st) {
-  st->print("OS:");
+  st->print_cr("OS:");
 
   os::Linux::print_distro_info(st);
 
   os::Posix::print_uname_info(st);
 
   os::Linux::print_uptime_info(st);
 
   // Print warning if unsafe chroot environment detected
   if (unsafe_chroot_detected) {
-    st->print("WARNING!! ");
-    st->print_cr("%s", unstable_chroot_error);
+    st->print_cr("WARNING!! %s", unstable_chroot_error);
   }
 
   os::Linux::print_libversion_info(st);
 
   os::Posix::print_rlimit_info(st);
 
   os::Posix::print_load_average(st);
+  st->cr();
 
   os::Linux::print_full_memory_info(st);
+  st->cr();
 
   os::Linux::print_proc_sys_info(st);
+  st->cr();
 
-  os::Linux::print_ld_preload_file(st);
+  if (os::Linux::print_ld_preload_file(st)) {
+    st->cr();
+  }
 
-  os::Linux::print_container_info(st);
+  if (os::Linux::print_container_info(st)) {
+    st->cr();
+  }
 
   VM_Version::print_platform_virtualization_info(st);
 
   os::Linux::print_steal_info(st);
 }
@@ -2205,13 +2231,12 @@
 
   if (file_exists("/etc/debian_version")) {
     st->print("Debian ");
     _print_ascii_file("/etc/debian_version", st);
   } else {
-    st->print("Linux");
+    st->print_cr("Linux");
   }
-  st->cr();
 }
 
 static void parse_os_info_helper(FILE* fp, char* distro, size_t length, bool get_first_line) {
   char buf[256];
   while (fgets(buf, sizeof(buf), fp)) {
@@ -2276,142 +2301,140 @@
   }
 }
 
 void os::Linux::print_libversion_info(outputStream* st) {
   // libc, pthread
-  st->print("libc:");
+  st->print("libc: ");
   st->print("%s ", os::Linux::glibc_version());
   st->print("%s ", os::Linux::libpthread_version());
   st->cr();
 }
 
 void os::Linux::print_proc_sys_info(outputStream* st) {
-  st->cr();
   _print_ascii_file_h("/proc/sys/kernel/threads-max (system-wide limit on the number of threads)",
                       "/proc/sys/kernel/threads-max", st);
   _print_ascii_file_h("/proc/sys/vm/max_map_count (maximum number of memory map areas a process may have)",
                       "/proc/sys/vm/max_map_count", st);
   _print_ascii_file_h("/proc/sys/kernel/pid_max (system-wide limit on number of process identifiers)",
                       "/proc/sys/kernel/pid_max", st);
 }
 
 void os::Linux::print_full_memory_info(outputStream* st) {
-  _print_ascii_file_h("\n/proc/meminfo", "/proc/meminfo", st);
+  _print_ascii_file_h("/proc/meminfo", "/proc/meminfo", st, false);
   st->cr();
 
   // some information regarding THPs; for details see
   // https://www.kernel.org/doc/Documentation/vm/transhuge.txt
   _print_ascii_file_h("/sys/kernel/mm/transparent_hugepage/enabled",
                       "/sys/kernel/mm/transparent_hugepage/enabled", st);
   _print_ascii_file_h("/sys/kernel/mm/transparent_hugepage/defrag (defrag/compaction efforts parameter)",
                       "/sys/kernel/mm/transparent_hugepage/defrag", st);
 }
 
-void os::Linux::print_ld_preload_file(outputStream* st) {
-  _print_ascii_file("/etc/ld.so.preload", st, "\n/etc/ld.so.preload:");
-  st->cr();
+bool os::Linux::print_ld_preload_file(outputStream* st) {
+  return _print_ascii_file("/etc/ld.so.preload", st, "/etc/ld.so.preload:");
 }
 
 void os::Linux::print_uptime_info(outputStream* st) {
   struct sysinfo sinfo;
   int ret = sysinfo(&sinfo);
   if (ret == 0) {
     os::print_dhm(st, "OS uptime:", (long) sinfo.uptime);
   }
 }
 
-
-void os::Linux::print_container_info(outputStream* st) {
+bool os::Linux::print_container_info(outputStream* st) {
   if (!OSContainer::is_containerized()) {
-    return;
+    return false;
   }
 
-  st->print("container (cgroup) information:\n");
+  st->print_cr("container (cgroup) information:");
 
   const char *p_ct = OSContainer::container_type();
-  st->print("container_type: %s\n", p_ct != NULL ? p_ct : "not supported");
+  st->print_cr("container_type: %s", p_ct != NULL ? p_ct : "not supported");
 
   char *p = OSContainer::cpu_cpuset_cpus();
-  st->print("cpu_cpuset_cpus: %s\n", p != NULL ? p : "not supported");
+  st->print_cr("cpu_cpuset_cpus: %s", p != NULL ? p : "not supported");
   free(p);
 
   p = OSContainer::cpu_cpuset_memory_nodes();
-  st->print("cpu_memory_nodes: %s\n", p != NULL ? p : "not supported");
+  st->print_cr("cpu_memory_nodes: %s", p != NULL ? p : "not supported");
   free(p);
 
   int i = OSContainer::active_processor_count();
   st->print("active_processor_count: ");
   if (i > 0) {
-    st->print("%d\n", i);
+    st->print_cr("%d", i);
   } else {
-    st->print("not supported\n");
+    st->print_cr("not supported");
   }
 
   i = OSContainer::cpu_quota();
   st->print("cpu_quota: ");
   if (i > 0) {
-    st->print("%d\n", i);
+    st->print_cr("%d", i);
   } else {
-    st->print("%s\n", i == OSCONTAINER_ERROR ? "not supported" : "no quota");
+    st->print_cr("%s", i == OSCONTAINER_ERROR ? "not supported" : "no quota");
   }
 
   i = OSContainer::cpu_period();
   st->print("cpu_period: ");
   if (i > 0) {
-    st->print("%d\n", i);
+    st->print_cr("%d", i);
   } else {
-    st->print("%s\n", i == OSCONTAINER_ERROR ? "not supported" : "no period");
+    st->print_cr("%s", i == OSCONTAINER_ERROR ? "not supported" : "no period");
   }
 
   i = OSContainer::cpu_shares();
   st->print("cpu_shares: ");
   if (i > 0) {
-    st->print("%d\n", i);
+    st->print_cr("%d", i);
   } else {
-    st->print("%s\n", i == OSCONTAINER_ERROR ? "not supported" : "no shares");
+    st->print_cr("%s", i == OSCONTAINER_ERROR ? "not supported" : "no shares");
   }
 
   jlong j = OSContainer::memory_limit_in_bytes();
   st->print("memory_limit_in_bytes: ");
   if (j > 0) {
-    st->print(JLONG_FORMAT "\n", j);
+    st->print_cr(JLONG_FORMAT, j);
   } else {
-    st->print("%s\n", j == OSCONTAINER_ERROR ? "not supported" : "unlimited");
+    st->print_cr("%s", j == OSCONTAINER_ERROR ? "not supported" : "unlimited");
   }
 
   j = OSContainer::memory_and_swap_limit_in_bytes();
   st->print("memory_and_swap_limit_in_bytes: ");
   if (j > 0) {
-    st->print(JLONG_FORMAT "\n", j);
+    st->print_cr(JLONG_FORMAT, j);
   } else {
-    st->print("%s\n", j == OSCONTAINER_ERROR ? "not supported" : "unlimited");
+    st->print_cr("%s", j == OSCONTAINER_ERROR ? "not supported" : "unlimited");
   }
 
   j = OSContainer::memory_soft_limit_in_bytes();
   st->print("memory_soft_limit_in_bytes: ");
   if (j > 0) {
-    st->print(JLONG_FORMAT "\n", j);
+    st->print_cr(JLONG_FORMAT, j);
   } else {
-    st->print("%s\n", j == OSCONTAINER_ERROR ? "not supported" : "unlimited");
+    st->print_cr("%s", j == OSCONTAINER_ERROR ? "not supported" : "unlimited");
   }
 
   j = OSContainer::OSContainer::memory_usage_in_bytes();
   st->print("memory_usage_in_bytes: ");
   if (j > 0) {
-    st->print(JLONG_FORMAT "\n", j);
+    st->print_cr(JLONG_FORMAT, j);
   } else {
-    st->print("%s\n", j == OSCONTAINER_ERROR ? "not supported" : "unlimited");
+    st->print_cr("%s", j == OSCONTAINER_ERROR ? "not supported" : "unlimited");
   }
 
   j = OSContainer::OSContainer::memory_max_usage_in_bytes();
   st->print("memory_max_usage_in_bytes: ");
   if (j > 0) {
-    st->print(JLONG_FORMAT "\n", j);
+    st->print_cr(JLONG_FORMAT, j);
   } else {
-    st->print("%s\n", j == OSCONTAINER_ERROR ? "not supported" : "unlimited");
+    st->print_cr("%s", j == OSCONTAINER_ERROR ? "not supported" : "unlimited");
   }
-  st->cr();
+
+  return true;
 }
 
 void os::Linux::print_steal_info(outputStream* st) {
   if (has_initial_tick_info) {
     CPUPerfTicks pticks;
@@ -2537,12 +2560,13 @@
 }
 
 void os::pd_print_cpu_info(outputStream* st, char* buf, size_t buflen) {
   // Only print the model name if the platform provides this as a summary
   if (!print_model_name_and_flags(st, buf, buflen)) {
-    _print_ascii_file_h("\n/proc/cpuinfo", "/proc/cpuinfo", st);
+    _print_ascii_file_h("/proc/cpuinfo", "/proc/cpuinfo", st, false);
   }
+  st->cr();
   print_sys_devices_cpu_info(st, buf, buflen);
 }
 
 #if defined(AMD64) || defined(IA32) || defined(X32)
 const char* search_string = "model name";
@@ -2977,10 +3001,19 @@
 // Define MAP_HUGETLB here so we can build HotSpot on old systems.
 #ifndef MAP_HUGETLB
   #define MAP_HUGETLB 0x40000
 #endif
 
+// If mmap flags are set with MAP_HUGETLB and the system supports multiple
+// huge page sizes, flag bits [26:31] can be used to encode the log2 of the
+// desired huge page size. Otherwise, the system's default huge page size will be used.
+// See mmap(2) man page for more info (since Linux 3.8).
+// https://lwn.net/Articles/533499/
+#ifndef MAP_HUGE_SHIFT
+  #define MAP_HUGE_SHIFT 26
+#endif
+
 // Define MADV_HUGEPAGE here so we can build HotSpot on old systems.
 #ifndef MADV_HUGEPAGE
   #define MADV_HUGEPAGE 14
 #endif
 
@@ -3775,11 +3808,14 @@
 
 // Large page support
 
 static size_t _large_page_size = 0;
 
-size_t os::Linux::find_large_page_size() {
+size_t os::Linux::find_default_large_page_size() {
+  if (_default_large_page_size != 0) {
+    return _default_large_page_size;
+  }
   size_t large_page_size = 0;
 
   // large_page_size on Linux is used to round up heap size. x86 uses either
   // 2M or 4M page, depending on whether PAE (Physical Address Extensions)
   // mode is enabled. AMD64/EM64T uses 2M page in 64bit mode. IA64 can use
@@ -3799,12 +3835,11 @@
     AMD64_ONLY(2 * M)
     ARM32_ONLY(2 * M)
     IA32_ONLY(4 * M)
     IA64_ONLY(256 * M)
     PPC_ONLY(4 * M)
-    S390_ONLY(1 * M)
-    SPARC_ONLY(4 * M);
+    S390_ONLY(1 * M);
 #endif // ZERO
 
   FILE *fp = fopen("/proc/meminfo", "r");
   if (fp) {
     while (!feof(fp)) {
@@ -3823,32 +3858,71 @@
         }
       }
     }
     fclose(fp);
   }
+  return large_page_size;
+}
+
+size_t os::Linux::find_large_page_size(size_t large_page_size) {
+  if (_default_large_page_size == 0) {
+    _default_large_page_size = Linux::find_default_large_page_size();
+  }
+  // We need to scan /sys/kernel/mm/hugepages
+  // to discover the available page sizes
+  const char* sys_hugepages = "/sys/kernel/mm/hugepages";
 
-  if (!FLAG_IS_DEFAULT(LargePageSizeInBytes) && LargePageSizeInBytes != large_page_size) {
-    warning("Setting LargePageSizeInBytes has no effect on this OS. Large page size is "
-            SIZE_FORMAT "%s.", byte_size_in_proper_unit(large_page_size),
-            proper_unit_for_byte_size(large_page_size));
+  DIR *dir = opendir(sys_hugepages);
+  if (dir == NULL) {
+    return _default_large_page_size;
   }
 
-  return large_page_size;
+  struct dirent *entry;
+  size_t page_size;
+  while ((entry = readdir(dir)) != NULL) {
+    if (entry->d_type == DT_DIR &&
+        sscanf(entry->d_name, "hugepages-%zukB", &page_size) == 1) {
+      // The kernel is using kB, hotspot uses bytes
+      if (large_page_size == page_size * K) {
+        closedir(dir);
+        return large_page_size;
+      }
+    }
+  }
+  closedir(dir);
+  return _default_large_page_size;
 }
 
 size_t os::Linux::setup_large_page_size() {
-  _large_page_size = Linux::find_large_page_size();
+  _default_large_page_size = Linux::find_default_large_page_size();
+
+  if (!FLAG_IS_DEFAULT(LargePageSizeInBytes) && LargePageSizeInBytes != _default_large_page_size ) {
+    _large_page_size = find_large_page_size(LargePageSizeInBytes);
+    if (_large_page_size == _default_large_page_size) {
+      warning("Setting LargePageSizeInBytes=" SIZE_FORMAT " has no effect on this OS. Using the default large page size "
+              SIZE_FORMAT "%s.",
+              LargePageSizeInBytes,
+              byte_size_in_proper_unit(_large_page_size), proper_unit_for_byte_size(_large_page_size));
+    }
+  } else {
+    _large_page_size = _default_large_page_size;
+  }
+
   const size_t default_page_size = (size_t)Linux::page_size();
   if (_large_page_size > default_page_size) {
     _page_sizes[0] = _large_page_size;
     _page_sizes[1] = default_page_size;
     _page_sizes[2] = 0;
   }
 
   return _large_page_size;
 }
 
+size_t os::Linux::default_large_page_size() {
+  return _default_large_page_size;
+}
+
 bool os::Linux::setup_large_page_type(size_t page_size) {
   if (FLAG_IS_DEFAULT(UseHugeTLBFS) &&
       FLAG_IS_DEFAULT(UseSHM) &&
       FLAG_IS_DEFAULT(UseTransparentHugePages)) {
 
@@ -4073,13 +4147,16 @@
   assert(UseLargePages && UseHugeTLBFS, "only for Huge TLBFS large pages");
   assert(is_aligned(bytes, os::large_page_size()), "Unaligned size");
   assert(is_aligned(req_addr, os::large_page_size()), "Unaligned address");
 
   int prot = exec ? PROT_READ|PROT_WRITE|PROT_EXEC : PROT_READ|PROT_WRITE;
-  char* addr = (char*)::mmap(req_addr, bytes, prot,
-                             MAP_PRIVATE|MAP_ANONYMOUS|MAP_HUGETLB,
-                             -1, 0);
+  int flags = MAP_PRIVATE|MAP_ANONYMOUS|MAP_HUGETLB;
+
+  if (os::large_page_size() != default_large_page_size()) {
+    flags |= (exact_log2(os::large_page_size()) << MAP_HUGE_SHIFT);
+  }
+  char* addr = (char*)::mmap(req_addr, bytes, prot, flags, -1, 0);
 
   if (addr == MAP_FAILED) {
     warn_on_large_pages_failure(req_addr, bytes, errno);
     return NULL;
   }
@@ -4131,28 +4208,30 @@
     ::munmap(start, end - start);
     return NULL;
   }
 
   int prot = exec ? PROT_READ|PROT_WRITE|PROT_EXEC : PROT_READ|PROT_WRITE;
-
+  int flags = MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED;
   void* result;
 
   // Commit small-paged leading area.
   if (start != lp_start) {
-    result = ::mmap(start, lp_start - start, prot,
-                    MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED,
-                    -1, 0);
+    result = ::mmap(start, lp_start - start, prot, flags, -1, 0);
     if (result == MAP_FAILED) {
       ::munmap(lp_start, end - lp_start);
       return NULL;
     }
   }
 
   // Commit large-paged area.
-  result = ::mmap(lp_start, lp_bytes, prot,
-                  MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED|MAP_HUGETLB,
-                  -1, 0);
+  flags |= MAP_HUGETLB;
+
+  if (os::large_page_size() != default_large_page_size()) {
+    flags |= (exact_log2(os::large_page_size()) << MAP_HUGE_SHIFT);
+  }
+
+  result = ::mmap(lp_start, lp_bytes, prot, flags, -1, 0);
   if (result == MAP_FAILED) {
     warn_on_large_pages_failure(lp_start, lp_bytes, errno);
     // If the mmap above fails, the large pages region will be unmapped and we
     // have regions before and after with small pages. Release these regions.
     //
diff a/src/hotspot/share/gc/shared/genCollectedHeap.cpp b/src/hotspot/share/gc/shared/genCollectedHeap.cpp
--- a/src/hotspot/share/gc/shared/genCollectedHeap.cpp
+++ b/src/hotspot/share/gc/shared/genCollectedHeap.cpp
@@ -25,11 +25,10 @@
 #include "precompiled.hpp"
 #include "aot/aotLoader.hpp"
 #include "classfile/classLoaderDataGraph.hpp"
 #include "classfile/symbolTable.hpp"
 #include "classfile/stringTable.hpp"
-#include "classfile/systemDictionary.hpp"
 #include "classfile/vmSymbols.hpp"
 #include "code/codeCache.hpp"
 #include "code/icBuffer.hpp"
 #include "gc/serial/defNewGeneration.hpp"
 #include "gc/shared/adaptiveSizePolicy.hpp"
@@ -45,11 +44,14 @@
 #include "gc/shared/genArguments.hpp"
 #include "gc/shared/gcVMOperations.hpp"
 #include "gc/shared/genCollectedHeap.hpp"
 #include "gc/shared/genOopClosures.inline.hpp"
 #include "gc/shared/generationSpec.hpp"
+#include "gc/shared/gcInitLogger.hpp"
 #include "gc/shared/locationPrinter.inline.hpp"
+#include "gc/shared/oopStorage.inline.hpp"
+#include "gc/shared/oopStorageSet.hpp"
 #include "gc/shared/oopStorageParState.inline.hpp"
 #include "gc/shared/scavengableNMethods.hpp"
 #include "gc/shared/space.hpp"
 #include "gc/shared/strongRootsScope.hpp"
 #include "gc/shared/weakProcessor.hpp"
@@ -79,23 +81,29 @@
 
 GenCollectedHeap::GenCollectedHeap(Generation::Name young,
                                    Generation::Name old,
                                    const char* policy_counters_name) :
   CollectedHeap(),
+  _young_gen(NULL),
+  _old_gen(NULL),
   _young_gen_spec(new GenerationSpec(young,
                                      NewSize,
                                      MaxNewSize,
                                      GenAlignment)),
   _old_gen_spec(new GenerationSpec(old,
                                    OldSize,
                                    MaxOldSize,
                                    GenAlignment)),
   _rem_set(NULL),
   _soft_ref_gen_policy(),
+  _size_policy(NULL),
   _gc_policy_counters(new GCPolicyCounters(policy_counters_name, 2, 2)),
+  _incremental_collection_failed(false),
   _full_collections_completed(0),
-  _process_strong_tasks(new SubTasksDone(GCH_PS_NumElements)) {
+  _process_strong_tasks(new SubTasksDone(GCH_PS_NumElements)),
+  _young_manager(NULL),
+  _old_manager(NULL) {
 }
 
 jint GenCollectedHeap::initialize() {
   // While there are no constraints in the GC code that HeapWordSize
   // be any particular value, there are multiple other areas in the
@@ -120,17 +128,18 @@
   _rem_set->initialize();
   CardTableBarrierSet *bs = new CardTableBarrierSet(_rem_set);
   bs->initialize();
   BarrierSet::set_barrier_set(bs);
 
-  ReservedSpace young_rs = heap_rs.first_part(_young_gen_spec->max_size(), false, false);
+  ReservedSpace young_rs = heap_rs.first_part(_young_gen_spec->max_size());
   _young_gen = _young_gen_spec->init(young_rs, rem_set());
   ReservedSpace old_rs = heap_rs.last_part(_young_gen_spec->max_size());
 
-  old_rs = old_rs.first_part(_old_gen_spec->max_size(), false, false);
+  old_rs = old_rs.first_part(_old_gen_spec->max_size());
   _old_gen = _old_gen_spec->init(old_rs, rem_set());
-  clear_incremental_collection_failed();
+
+  GCInitLogger::print();
 
   return JNI_OK;
 }
 
 CardTableRS* GenCollectedHeap::create_rem_set(const MemRegion& reserved_region) {
@@ -833,12 +842,12 @@
 #if INCLUDE_AOT
   if (UseAOT && _process_strong_tasks->try_claim_task(GCH_PS_aot_oops_do)) {
     AOTLoader::oops_do(strong_roots);
   }
 #endif
-  if (_process_strong_tasks->try_claim_task(GCH_PS_SystemDictionary_oops_do)) {
-    SystemDictionary::oops_do(strong_roots);
+  if (_process_strong_tasks->try_claim_task(GCH_PS_VMGlobal_oops_do)) {
+    OopStorageSet::vm_global()->oops_do(strong_roots);
   }
 
   if (_process_strong_tasks->try_claim_task(GCH_PS_CodeCache_oops_do)) {
     if (so & SO_ScavengeCodeCache) {
       assert(code_roots != NULL, "must supply closure for code cache");
@@ -1215,21 +1224,22 @@
   log_debug(gc, verify)("RemSet");
   rem_set()->verify();
 }
 
 void GenCollectedHeap::print_on(outputStream* st) const {
-  _young_gen->print_on(st);
-  _old_gen->print_on(st);
+  if (_young_gen != NULL) {
+    _young_gen->print_on(st);
+  }
+  if (_old_gen != NULL) {
+    _old_gen->print_on(st);
+  }
   MetaspaceUtils::print_on(st);
 }
 
 void GenCollectedHeap::gc_threads_do(ThreadClosure* tc) const {
 }
 
-void GenCollectedHeap::print_gc_threads_on(outputStream* st) const {
-}
-
 bool GenCollectedHeap::print_location(outputStream* st, void* addr) const {
   return BlockLocationPrinter<GenCollectedHeap>::print_location(st, addr);
 }
 
 void GenCollectedHeap::print_tracing_info() const {
diff a/src/hotspot/share/runtime/abstract_vm_version.cpp b/src/hotspot/share/runtime/abstract_vm_version.cpp
--- a/src/hotspot/share/runtime/abstract_vm_version.cpp
+++ b/src/hotspot/share/runtime/abstract_vm_version.cpp
@@ -173,11 +173,10 @@
   return VERSION_STRING;
 }
 
 #define OS       LINUX_ONLY("linux")             \
                  WINDOWS_ONLY("windows")         \
-                 SOLARIS_ONLY("solaris")         \
                  AIX_ONLY("aix")                 \
                  BSD_ONLY("bsd")
 
 #ifndef CPU
 #ifdef ZERO
@@ -191,12 +190,11 @@
 #else
 #define CPU      AARCH64_ONLY("aarch64")         \
                  AMD64_ONLY("amd64")             \
                  IA32_ONLY("x86")                \
                  IA64_ONLY("ia64")               \
-                 S390_ONLY("s390")               \
-                 SPARC_ONLY("sparc")
+                 S390_ONLY("s390")
 #endif // !ZERO
 #endif // !CPU
 
 const char *Abstract_VM_Version::vm_platform_string() {
   return OS "-" CPU;
@@ -238,24 +236,10 @@
       #elif _MSC_VER == 1923
         #define HOTSPOT_BUILD_COMPILER "MS VC++ 16.3 (VS2019)"
       #else
         #define HOTSPOT_BUILD_COMPILER "unknown MS VC++:" XSTR(_MSC_VER)
       #endif
-    #elif defined(__SUNPRO_CC)
-      #if __SUNPRO_CC == 0x580
-        #define HOTSPOT_BUILD_COMPILER "Workshop 5.8"
-      #elif __SUNPRO_CC == 0x590
-        #define HOTSPOT_BUILD_COMPILER "Workshop 5.9"
-      #elif __SUNPRO_CC == 0x5100
-        #define HOTSPOT_BUILD_COMPILER "Sun Studio 12u1"
-      #elif __SUNPRO_CC == 0x5120
-        #define HOTSPOT_BUILD_COMPILER "Sun Studio 12u3"
-      #elif __SUNPRO_CC == 0x5130
-        #define HOTSPOT_BUILD_COMPILER "Sun Studio 12u4"
-      #else
-        #define HOTSPOT_BUILD_COMPILER "unknown Workshop:" XSTR(__SUNPRO_CC)
-      #endif
     #elif defined(__clang_version__)
         #define HOTSPOT_BUILD_COMPILER "clang " __VERSION__
     #elif defined(__GNUC__)
         #define HOTSPOT_BUILD_COMPILER "gcc " __VERSION__
     #else
diff a/src/hotspot/share/utilities/globalDefinitions_gcc.hpp b/src/hotspot/share/utilities/globalDefinitions_gcc.hpp
--- a/src/hotspot/share/utilities/globalDefinitions_gcc.hpp
+++ b/src/hotspot/share/utilities/globalDefinitions_gcc.hpp
@@ -37,39 +37,19 @@
 #include <stddef.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <wchar.h>
 
-#ifdef SOLARIS
-#include <ieeefp.h>
-#endif // SOLARIS
-
 #include <math.h>
 #include <time.h>
 #include <fcntl.h>
 #include <dlfcn.h>
 #include <pthread.h>
 
-#ifdef SOLARIS
-#include <thread.h>
-#endif // SOLARIS
-
 #include <limits.h>
 #include <errno.h>
 
-#ifdef SOLARIS
-#include <sys/trap.h>
-#include <sys/regset.h>
-#include <sys/procset.h>
-#include <ucontext.h>
-#include <setjmp.h>
-#endif // SOLARIS
-
-# ifdef SOLARIS_MUTATOR_LIBTHREAD
-# include <sys/procfs.h>
-# endif
-
 #if defined(LINUX) || defined(_ALLBSD_SOURCE)
 #include <inttypes.h>
 #include <signal.h>
 #ifndef __OpenBSD__
 #include <ucontext.h>
@@ -79,38 +59,10 @@
   #include <mach/mach.h>
 #endif
 #include <sys/time.h>
 #endif // LINUX || _ALLBSD_SOURCE
 
-// 4810578: varargs unsafe on 32-bit integer/64-bit pointer architectures
-// When __cplusplus is defined, NULL is defined as 0 (32-bit constant) in
-// system header files.  On 32-bit architectures, there is no problem.
-// On 64-bit architectures, defining NULL as a 32-bit constant can cause
-// problems with varargs functions: C++ integral promotion rules say for
-// varargs, we pass the argument 0 as an int.  So, if NULL was passed to a
-// varargs function it will remain 32-bits.  Depending on the calling
-// convention of the machine, if the argument is passed on the stack then
-// only 32-bits of the "NULL" pointer may be initialized to zero.  The
-// other 32-bits will be garbage.  If the varargs function is expecting a
-// pointer when it extracts the argument, then we have a problem.
-//
-// Solution: For 64-bit architectures, redefine NULL as 64-bit constant 0.
-//
-// Note: this fix doesn't work well on Linux because NULL will be overwritten
-// whenever a system header file is included. Linux handles NULL correctly
-// through a special type '__null'.
-#ifdef SOLARIS
-  #ifdef _LP64
-    #undef NULL
-    #define NULL 0L
-  #else
-    #ifndef NULL
-      #define NULL 0
-    #endif
-  #endif
-#endif
-
 // NULL vs NULL_WORD:
 // On Linux NULL is defined as a special type '__null'. Assigning __null to
 // integer variable will cause gcc warning. Use NULL_WORD in places where a
 // pointer is stored as integer value.  On some platforms, sizeof(intptr_t) >
 // sizeof(void*), so here we want something which is integer type, but has the
@@ -154,55 +106,11 @@
 typedef uint8_t  jubyte;
 typedef uint16_t jushort;
 typedef uint32_t juint;
 typedef uint64_t julong;
 
-
-#ifdef SOLARIS
-// ANSI C++ fixes
-// NOTE:In the ANSI committee's continuing attempt to make each version
-// of C++ incompatible with the previous version, you can no longer cast
-// pointers to functions without specifying linkage unless you want to get
-// warnings.
-//
-// This also means that pointers to functions can no longer be "hidden"
-// in opaque types like void * because at the invokation point warnings
-// will be generated. While this makes perfect sense from a type safety
-// point of view it causes a lot of warnings on old code using C header
-// files. Here are some typedefs to make the job of silencing warnings
-// a bit easier.
-//
-// The final kick in the teeth is that you can only have extern "C" linkage
-// specified at file scope. So these typedefs are here rather than in the
-// .hpp for the class (os:Solaris usually) that needs them.
-
-extern "C" {
-   typedef int (*int_fnP_thread_t_iP_uP_stack_tP_gregset_t)(thread_t, int*, unsigned *, stack_t*, gregset_t);
-   typedef int (*int_fnP_thread_t_i_gregset_t)(thread_t, int, gregset_t);
-   typedef int (*int_fnP_thread_t_i)(thread_t, int);
-   typedef int (*int_fnP_thread_t)(thread_t);
-
-   typedef int (*int_fnP_cond_tP_mutex_tP_timestruc_tP)(cond_t *cv, mutex_t *mx, timestruc_t *abst);
-   typedef int (*int_fnP_cond_tP_mutex_tP)(cond_t *cv, mutex_t *mx);
-
-   // typedef for missing API in libc
-   typedef int (*int_fnP_mutex_tP_i_vP)(mutex_t *, int, void *);
-   typedef int (*int_fnP_mutex_tP)(mutex_t *);
-   typedef int (*int_fnP_cond_tP_i_vP)(cond_t *cv, int scope, void *arg);
-   typedef int (*int_fnP_cond_tP)(cond_t *cv);
-};
-#endif // SOLARIS
-
-// checking for nanness
-#ifdef SOLARIS
-#ifdef SPARC
-inline int g_isnan(float  f) { return isnanf(f); }
-#else
-// isnanf() broken on Intel Solaris use isnand()
-inline int g_isnan(float  f) { return isnand(f); }
-#endif
-inline int g_isnan(double f) { return isnand(f); }
+// checking for nanness
 #elif defined(__APPLE__)
 inline int g_isnan(double f) { return isnan(f); }
 #elif defined(LINUX) || defined(_ALLBSD_SOURCE)
 inline int g_isnan(float  f) { return isnan(f); }
 inline int g_isnan(double f) { return isnan(f); }
diff a/src/java.base/unix/native/libjava/jdk_util_md.h b/src/java.base/unix/native/libjava/jdk_util_md.h
--- a/src/java.base/unix/native/libjava/jdk_util_md.h
+++ b/src/java.base/unix/native/libjava/jdk_util_md.h
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2011, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -25,15 +25,11 @@
 
 #ifndef JDK_UTIL_MD_H
 #define JDK_UTIL_MD_H
 
 // checking for nanness
-#ifdef __solaris__
-#include <ieeefp.h>
-#define ISNANF(f) isnanf(f)
-#define ISNAND(d) isnand(d)
-#elif defined(MACOSX)
+#if defined(MACOSX)
 #include <math.h>
 #define ISNANF(f) isnan(f)
 #define ISNAND(d) isnan(d)
 #elif defined(__linux__) || defined(_ALLBSD_SOURCE)
 #include <math.h>
diff a/src/java.base/unix/native/libjli/java_md.c b/src/java.base/unix/native/libjli/java_md.c
--- /dev/null
+++ b/src/java.base/unix/native/libjli/java_md.c
@@ -0,0 +1,744 @@
+/*
+ * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#include "java.h"
+#include "jvm_md.h"
+#include <dirent.h>
+#include <dlfcn.h>
+#include <fcntl.h>
+#include <inttypes.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include "manifest_info.h"
+
+
+#define JVM_DLL "libjvm.so"
+#define JAVA_DLL "libjava.so"
+#ifdef AIX
+#define LD_LIBRARY_PATH "LIBPATH"
+#else
+#define LD_LIBRARY_PATH "LD_LIBRARY_PATH"
+#endif
+
+/* help jettison the LD_LIBRARY_PATH settings in the future */
+#ifndef SETENV_REQUIRED
+#define SETENV_REQUIRED
+#endif
+
+/*
+ * Flowchart of launcher execs and options processing on unix
+ *
+ * The selection of the proper vm shared library to open depends on
+ * several classes of command line options, including vm "flavor"
+ * options (-client, -server).
+ * The vm selection options are not passed to the running
+ * virtual machine; they must be screened out by the launcher.
+ *
+ * The version specification (if any) is processed first by the
+ * platform independent routine SelectVersion.  This may result in
+ * the exec of the specified launcher version.
+ *
+ * Previously the launcher modified the LD_LIBRARY_PATH appropriately for the
+ * desired data model path, regardless if data models matched or not. The
+ * launcher subsequently exec'ed the desired executable, in order to make the
+ * LD_LIBRARY_PATH path available, for the runtime linker.
+ *
+ * Now, in most cases,the launcher will dlopen the target libjvm.so. All
+ * required libraries are loaded by the runtime linker, using the
+ * $RPATH/$ORIGIN baked into the shared libraries at compile time. Therefore,
+ * in most cases, the launcher will only exec, if the data models are
+ * mismatched, and will not set any environment variables, regardless of the
+ * data models.
+ *
+ * However, if the environment contains a LD_LIBRARY_PATH, this will cause the
+ * launcher to inspect the LD_LIBRARY_PATH. The launcher will check
+ *  a. if the LD_LIBRARY_PATH's first component is the path to the desired
+ *     libjvm.so
+ *  b. if any other libjvm.so is found in any of the paths.
+ * If case b is true, then the launcher will set the LD_LIBRARY_PATH to the
+ * desired JRE and reexec, in order to propagate the environment.
+ *
+ *  Main
+ *  (incoming argv)
+ *  |
+ * \|/
+ * CreateExecutionEnvironment
+ * (determines desired data model)
+ *  |
+ *  |
+ * \|/
+ *  Have Desired Model ? --> NO --> Exit(with error)
+ *  |
+ *  |
+ * \|/
+ * YES
+ *  |
+ *  |
+ * \|/
+ * CheckJvmType
+ * (removes -client, -server, etc.)
+ *  |
+ *  |
+ * \|/
+ * TranslateDashJArgs...
+ * (Prepare to pass args to vm)
+ *  |
+ *  |
+ * \|/
+ * ParseArguments
+ *   |
+ *   |
+ *  \|/
+ * RequiresSetenv
+ * Is LD_LIBRARY_PATH
+ * and friends set ? --> NO --> Continue
+ *  YES
+ *   |
+ *   |
+ *  \|/
+ * Path is desired JRE ? YES --> Continue
+ *  NO
+ *   |
+ *   |
+ *  \|/
+ * Paths have well known
+ * jvm paths ?       --> NO --> Error/Exit
+ *  YES
+ *   |
+ *   |
+ *  \|/
+ *  Does libjvm.so exist
+ *  in any of them ? --> NO  --> Continue
+ *   YES
+ *   |
+ *   |
+ *  \|/
+ *  Set the LD_LIBRARY_PATH
+ *   |
+ *   |
+ *  \|/
+ * Re-exec
+ *   |
+ *   |
+ *  \|/
+ * Main
+ */
+
+/* Store the name of the executable once computed */
+static char *execname = NULL;
+
+/*
+ * execname accessor from other parts of platform dependent logic
+ */
+const char *
+GetExecName() {
+    return execname;
+}
+
+#ifdef SETENV_REQUIRED
+static jboolean
+JvmExists(const char *path) {
+    char tmp[PATH_MAX + 1];
+    struct stat statbuf;
+    JLI_Snprintf(tmp, PATH_MAX, "%s/%s", path, JVM_DLL);
+    if (stat(tmp, &statbuf) == 0) {
+        return JNI_TRUE;
+    }
+    return JNI_FALSE;
+}
+/*
+ * contains a lib/{server,client}/libjvm.so ?
+ */
+static jboolean
+ContainsLibJVM(const char *env) {
+    /* the usual suspects */
+    char clientPattern[] = "lib/client";
+    char serverPattern[] = "lib/server";
+    char *envpath;
+    char *path;
+    char* save_ptr = NULL;
+    jboolean clientPatternFound;
+    jboolean serverPatternFound;
+
+    /* fastest path */
+    if (env == NULL) {
+        return JNI_FALSE;
+    }
+
+    /* to optimize for time, test if any of our usual suspects are present. */
+    clientPatternFound = JLI_StrStr(env, clientPattern) != NULL;
+    serverPatternFound = JLI_StrStr(env, serverPattern) != NULL;
+    if (clientPatternFound == JNI_FALSE && serverPatternFound == JNI_FALSE) {
+        return JNI_FALSE;
+    }
+
+    /*
+     * we have a suspicious path component, check if it contains a libjvm.so
+     */
+    envpath = JLI_StringDup(env);
+    for (path = strtok_r(envpath, ":", &save_ptr); path != NULL; path = strtok_r(NULL, ":", &save_ptr)) {
+        if (clientPatternFound && JLI_StrStr(path, clientPattern) != NULL) {
+            if (JvmExists(path)) {
+                JLI_MemFree(envpath);
+                return JNI_TRUE;
+            }
+        }
+        if (serverPatternFound && JLI_StrStr(path, serverPattern)  != NULL) {
+            if (JvmExists(path)) {
+                JLI_MemFree(envpath);
+                return JNI_TRUE;
+            }
+        }
+    }
+    JLI_MemFree(envpath);
+    return JNI_FALSE;
+}
+
+/*
+ * Test whether the environment variable needs to be set, see flowchart.
+ */
+static jboolean
+RequiresSetenv(const char *jvmpath) {
+    char jpath[PATH_MAX + 1];
+    char *llp;
+    char *dmllp = NULL;
+    char *p; /* a utility pointer */
+
+#ifdef __linux
+#ifndef LIBC
+#error "LIBC not set"
+#endif
+
+    if (strcmp(LIBC, "musl") == 0) {
+      /*
+       * The musl library loader requires LD_LIBRARY_PATH to be set in
+       * order to correctly resolve the dependency libjava.so has on libjvm.so.
+       *
+       * Specifically, it differs from glibc in the sense that even if
+       * libjvm.so has already been loaded it will not be considered a
+       * candidate for resolving the dependency unless the *full* path
+       * of the already loaded library matches the dependency being loaded.
+       *
+       * libjvm.so is being loaded by the launcher using a long path to
+       * dlopen, not just the basename of the library. Typically this
+       * is something like "../lib/server/libjvm.so". However, if/when
+       * libjvm.so later tries to dlopen libjava.so (which it does in
+       * order to get access to a few functions implemented in
+       * libjava.so) the musl loader will, as part of loading
+       * dependent libraries, try to load libjvm.so using only its
+       * basename "libjvm.so". Since this does not match the longer
+       * path path it was first loaded with, the already loaded
+       * library is not considered a candidate, and the loader will
+       * instead look for libjvm.so elsewhere. If it's not in
+       * LD_LIBRARY_PATH the dependency load will fail, and libjava.so
+       * will therefore fail as well.
+       */
+      return JNI_TRUE;
+    }
+#endif
+
+#ifdef AIX
+    /* We always have to set the LIBPATH on AIX because ld doesn't support $ORIGIN. */
+    return JNI_TRUE;
+#endif
+
+    llp = getenv("LD_LIBRARY_PATH");
+    /* no environment variable is a good environment variable */
+    if (llp == NULL && dmllp == NULL) {
+        return JNI_FALSE;
+    }
+#ifdef __linux
+    /*
+     * On linux, if a binary is running as sgid or suid, glibc sets
+     * LD_LIBRARY_PATH to the empty string for security purposes. (In contrast,
+     * on Solaris the LD_LIBRARY_PATH variable for a privileged binary does not
+     * lose its settings; but the dynamic linker does apply more scrutiny to the
+     * path.) The launcher uses the value of LD_LIBRARY_PATH to prevent an exec
+     * loop, here and further downstream. Therefore, if we are running sgid or
+     * suid, this function's setting of LD_LIBRARY_PATH will be ineffective and
+     * we should case a return from the calling function.  Getting the right
+     * libraries will be handled by the RPATH. In reality, this check is
+     * redundant, as the previous check for a non-null LD_LIBRARY_PATH will
+     * return back to the calling function forthwith, it is left here to safe
+     * guard against any changes, in the glibc's existing security policy.
+     */
+    if ((getgid() != getegid()) || (getuid() != geteuid())) {
+        return JNI_FALSE;
+    }
+#endif /* __linux */
+
+    /*
+     * Prevent recursions. Since LD_LIBRARY_PATH is the one which will be set by
+     * previous versions of the JRE, thus it is the only path that matters here.
+     * So we check to see if the desired JRE is set.
+     */
+    JLI_StrNCpy(jpath, jvmpath, PATH_MAX);
+    p = JLI_StrRChr(jpath, '/');
+    *p = '\0';
+    if (llp != NULL && JLI_StrNCmp(llp, jpath, JLI_StrLen(jpath)) == 0) {
+        return JNI_FALSE;
+    }
+
+    /* scrutinize all the paths further */
+    if (llp != NULL &&  ContainsLibJVM(llp)) {
+        return JNI_TRUE;
+    }
+    if (dmllp != NULL && ContainsLibJVM(dmllp)) {
+        return JNI_TRUE;
+    }
+    return JNI_FALSE;
+}
+#endif /* SETENV_REQUIRED */
+
+void
+CreateExecutionEnvironment(int *pargc, char ***pargv,
+                           char jrepath[], jint so_jrepath,
+                           char jvmpath[], jint so_jvmpath,
+                           char jvmcfg[],  jint so_jvmcfg) {
+
+    char * jvmtype = NULL;
+    int argc = *pargc;
+    char **argv = *pargv;
+
+#ifdef SETENV_REQUIRED
+    jboolean mustsetenv = JNI_FALSE;
+    char *runpath = NULL; /* existing effective LD_LIBRARY_PATH setting */
+    char* new_runpath = NULL; /* desired new LD_LIBRARY_PATH string */
+    char* newpath = NULL; /* path on new LD_LIBRARY_PATH */
+    char* lastslash = NULL;
+    char** newenvp = NULL; /* current environment */
+    size_t new_runpath_size;
+#endif  /* SETENV_REQUIRED */
+
+    /* Compute/set the name of the executable */
+    SetExecname(*pargv);
+
+    /* Check to see if the jvmpath exists */
+    /* Find out where the JRE is that we will be using. */
+    if (!GetJREPath(jrepath, so_jrepath, JNI_FALSE)) {
+        JLI_ReportErrorMessage(JRE_ERROR1);
+        exit(2);
+    }
+    JLI_Snprintf(jvmcfg, so_jvmcfg, "%s%slib%sjvm.cfg",
+            jrepath, FILESEP, FILESEP);
+    /* Find the specified JVM type */
+    if (ReadKnownVMs(jvmcfg, JNI_FALSE) < 1) {
+        JLI_ReportErrorMessage(CFG_ERROR7);
+        exit(1);
+    }
+
+    jvmpath[0] = '\0';
+    jvmtype = CheckJvmType(pargc, pargv, JNI_FALSE);
+    if (JLI_StrCmp(jvmtype, "ERROR") == 0) {
+        JLI_ReportErrorMessage(CFG_ERROR9);
+        exit(4);
+    }
+
+    if (!GetJVMPath(jrepath, jvmtype, jvmpath, so_jvmpath)) {
+        JLI_ReportErrorMessage(CFG_ERROR8, jvmtype, jvmpath);
+        exit(4);
+    }
+    /*
+     * we seem to have everything we need, so without further ado
+     * we return back, otherwise proceed to set the environment.
+     */
+#ifdef SETENV_REQUIRED
+    mustsetenv = RequiresSetenv(jvmpath);
+    JLI_TraceLauncher("mustsetenv: %s\n", mustsetenv ? "TRUE" : "FALSE");
+
+    if (mustsetenv == JNI_FALSE) {
+        return;
+    }
+#else
+    return;
+#endif /* SETENV_REQUIRED */
+
+#ifdef SETENV_REQUIRED
+    if (mustsetenv) {
+        /*
+         * We will set the LD_LIBRARY_PATH as follows:
+         *
+         *     o          $JVMPATH (directory portion only)
+         *     o          $JRE/lib
+         *     o          $JRE/../lib
+         *
+         * followed by the user's previous effective LD_LIBRARY_PATH, if
+         * any.
+         */
+
+        runpath = getenv(LD_LIBRARY_PATH);
+
+        /* runpath contains current effective LD_LIBRARY_PATH setting */
+        { /* New scope to declare local variable */
+            char *new_jvmpath = JLI_StringDup(jvmpath);
+            new_runpath_size = ((runpath != NULL) ? JLI_StrLen(runpath) : 0) +
+                    2 * JLI_StrLen(jrepath) +
+                    JLI_StrLen(new_jvmpath) + 52;
+            new_runpath = JLI_MemAlloc(new_runpath_size);
+            newpath = new_runpath + JLI_StrLen(LD_LIBRARY_PATH "=");
+
+
+            /*
+             * Create desired LD_LIBRARY_PATH value for target data model.
+             */
+            {
+                /* remove the name of the .so from the JVM path */
+                lastslash = JLI_StrRChr(new_jvmpath, '/');
+                if (lastslash)
+                    *lastslash = '\0';
+
+                sprintf(new_runpath, LD_LIBRARY_PATH "="
+                        "%s:"
+                        "%s/lib:"
+                        "%s/../lib",
+                        new_jvmpath,
+                        jrepath,
+                        jrepath
+                        );
+
+                JLI_MemFree(new_jvmpath);
+
+                /*
+                 * Check to make sure that the prefix of the current path is the
+                 * desired environment variable setting, though the RequiresSetenv
+                 * checks if the desired runpath exists, this logic does a more
+                 * comprehensive check.
+                 */
+                if (runpath != NULL &&
+                        JLI_StrNCmp(newpath, runpath, JLI_StrLen(newpath)) == 0 &&
+                        (runpath[JLI_StrLen(newpath)] == 0 ||
+                        runpath[JLI_StrLen(newpath)] == ':')) {
+                    JLI_MemFree(new_runpath);
+                    return;
+                }
+            }
+        }
+
+        /*
+         * Place the desired environment setting onto the prefix of
+         * LD_LIBRARY_PATH.  Note that this prevents any possible infinite
+         * loop of execv() because we test for the prefix, above.
+         */
+        if (runpath != 0) {
+            /* ensure storage for runpath + colon + NULL */
+            if ((JLI_StrLen(runpath) + 1 + 1) > new_runpath_size) {
+                JLI_ReportErrorMessageSys(JRE_ERROR11);
+                exit(1);
+            }
+            JLI_StrCat(new_runpath, ":");
+            JLI_StrCat(new_runpath, runpath);
+        }
+
+        if (putenv(new_runpath) != 0) {
+            /* problem allocating memory; LD_LIBRARY_PATH not set properly */
+            exit(1);
+        }
+
+        /*
+         * Unix systems document that they look at LD_LIBRARY_PATH only
+         * once at startup, so we have to re-exec the current executable
+         * to get the changed environment variable to have an effect.
+         */
+
+        newenvp = environ;
+    }
+#endif /* SETENV_REQUIRED */
+    {
+        char *newexec = execname;
+        JLI_TraceLauncher("TRACER_MARKER:About to EXEC\n");
+        (void) fflush(stdout);
+        (void) fflush(stderr);
+#ifdef SETENV_REQUIRED
+        if (mustsetenv) {
+            execve(newexec, argv, newenvp);
+        } else {
+            execv(newexec, argv);
+        }
+#else /* !SETENV_REQUIRED */
+        execv(newexec, argv);
+#endif /* SETENV_REQUIRED */
+        JLI_ReportErrorMessageSys(JRE_ERROR4, newexec);
+    }
+    exit(1);
+}
+
+
+static jboolean
+GetJVMPath(const char *jrepath, const char *jvmtype,
+           char *jvmpath, jint jvmpathsize)
+{
+    struct stat s;
+
+    if (JLI_StrChr(jvmtype, '/')) {
+        JLI_Snprintf(jvmpath, jvmpathsize, "%s/" JVM_DLL, jvmtype);
+    } else {
+        JLI_Snprintf(jvmpath, jvmpathsize, "%s/lib/%s/" JVM_DLL, jrepath, jvmtype);
+    }
+
+    JLI_TraceLauncher("Does `%s' exist ... ", jvmpath);
+
+    if (stat(jvmpath, &s) == 0) {
+        JLI_TraceLauncher("yes.\n");
+        return JNI_TRUE;
+    } else {
+        JLI_TraceLauncher("no.\n");
+        return JNI_FALSE;
+    }
+}
+
+/*
+ * Find path to JRE based on .exe's location or registry settings.
+ */
+static jboolean
+GetJREPath(char *path, jint pathsize, jboolean speculative)
+{
+    char libjava[MAXPATHLEN];
+    struct stat s;
+
+    if (GetApplicationHome(path, pathsize)) {
+        /* Is JRE co-located with the application? */
+        JLI_Snprintf(libjava, sizeof(libjava), "%s/lib/" JAVA_DLL, path);
+        if (access(libjava, F_OK) == 0) {
+            JLI_TraceLauncher("JRE path is %s\n", path);
+            return JNI_TRUE;
+        }
+        /* ensure storage for path + /jre + NULL */
+        if ((JLI_StrLen(path) + 4  + 1) > (size_t) pathsize) {
+            JLI_TraceLauncher("Insufficient space to store JRE path\n");
+            return JNI_FALSE;
+        }
+        /* Does the app ship a private JRE in <apphome>/jre directory? */
+        JLI_Snprintf(libjava, sizeof(libjava), "%s/jre/lib/" JAVA_DLL, path);
+        if (access(libjava, F_OK) == 0) {
+            JLI_StrCat(path, "/jre");
+            JLI_TraceLauncher("JRE path is %s\n", path);
+            return JNI_TRUE;
+        }
+    }
+
+    if (GetApplicationHomeFromDll(path, pathsize)) {
+        JLI_Snprintf(libjava, sizeof(libjava), "%s/lib/" JAVA_DLL, path);
+        if (stat(libjava, &s) == 0) {
+            JLI_TraceLauncher("JRE path is %s\n", path);
+            return JNI_TRUE;
+        }
+    }
+
+    if (!speculative)
+      JLI_ReportErrorMessage(JRE_ERROR8 JAVA_DLL);
+    return JNI_FALSE;
+}
+
+jboolean
+LoadJavaVM(const char *jvmpath, InvocationFunctions *ifn)
+{
+    void *libjvm;
+
+    JLI_TraceLauncher("JVM path is %s\n", jvmpath);
+
+    libjvm = dlopen(jvmpath, RTLD_NOW + RTLD_GLOBAL);
+    if (libjvm == NULL) {
+        JLI_ReportErrorMessage(DLL_ERROR1, __LINE__);
+        JLI_ReportErrorMessage(DLL_ERROR2, jvmpath, dlerror());
+        return JNI_FALSE;
+    }
+
+    ifn->CreateJavaVM = (CreateJavaVM_t)
+        dlsym(libjvm, "JNI_CreateJavaVM");
+    if (ifn->CreateJavaVM == NULL) {
+        JLI_ReportErrorMessage(DLL_ERROR2, jvmpath, dlerror());
+        return JNI_FALSE;
+    }
+
+    ifn->GetDefaultJavaVMInitArgs = (GetDefaultJavaVMInitArgs_t)
+        dlsym(libjvm, "JNI_GetDefaultJavaVMInitArgs");
+    if (ifn->GetDefaultJavaVMInitArgs == NULL) {
+        JLI_ReportErrorMessage(DLL_ERROR2, jvmpath, dlerror());
+        return JNI_FALSE;
+    }
+
+    ifn->GetCreatedJavaVMs = (GetCreatedJavaVMs_t)
+        dlsym(libjvm, "JNI_GetCreatedJavaVMs");
+    if (ifn->GetCreatedJavaVMs == NULL) {
+        JLI_ReportErrorMessage(DLL_ERROR2, jvmpath, dlerror());
+        return JNI_FALSE;
+    }
+
+    return JNI_TRUE;
+}
+
+/*
+ * Compute the name of the executable
+ *
+ * In order to re-exec securely we need the absolute path of the
+ * executable. On Solaris getexecname(3c) may not return an absolute
+ * path so we use dladdr to get the filename of the executable and
+ * then use realpath to derive an absolute path. From Solaris 9
+ * onwards the filename returned in DL_info structure from dladdr is
+ * an absolute pathname so technically realpath isn't required.
+ * On Linux we read the executable name from /proc/self/exe.
+ * As a fallback, and for platforms other than Solaris and Linux,
+ * we use FindExecName to compute the executable name.
+ */
+const char*
+SetExecname(char **argv)
+{
+    char* exec_path = NULL;
+#if defined(__linux__)
+    {
+        const char* self = "/proc/self/exe";
+        char buf[PATH_MAX+1];
+        int len = readlink(self, buf, PATH_MAX);
+        if (len >= 0) {
+            buf[len] = '\0';            /* readlink(2) doesn't NUL terminate */
+            exec_path = JLI_StringDup(buf);
+        }
+    }
+#else /* !__linux__ */
+    {
+        /* Not implemented */
+    }
+#endif
+
+    if (exec_path == NULL) {
+        exec_path = FindExecName(argv[0]);
+    }
+    execname = exec_path;
+    return exec_path;
+}
+
+/* --- Splash Screen shared library support --- */
+static const char* SPLASHSCREEN_SO = JNI_LIB_NAME("splashscreen");
+static void* hSplashLib = NULL;
+
+void* SplashProcAddress(const char* name) {
+    if (!hSplashLib) {
+        int ret;
+        char jrePath[MAXPATHLEN];
+        char splashPath[MAXPATHLEN];
+
+        if (!GetJREPath(jrePath, sizeof(jrePath), JNI_FALSE)) {
+            JLI_ReportErrorMessage(JRE_ERROR1);
+            return NULL;
+        }
+        ret = JLI_Snprintf(splashPath, sizeof(splashPath), "%s/lib/%s",
+                     jrePath, SPLASHSCREEN_SO);
+
+        if (ret >= (int) sizeof(splashPath)) {
+            JLI_ReportErrorMessage(JRE_ERROR11);
+            return NULL;
+        }
+        if (ret < 0) {
+            JLI_ReportErrorMessage(JRE_ERROR13);
+            return NULL;
+        }
+        hSplashLib = dlopen(splashPath, RTLD_LAZY | RTLD_GLOBAL);
+        JLI_TraceLauncher("Info: loaded %s\n", splashPath);
+    }
+    if (hSplashLib) {
+        void* sym = dlsym(hSplashLib, name);
+        return sym;
+    } else {
+        return NULL;
+    }
+}
+
+/*
+ * Signature adapter for pthread_create() or thr_create().
+ */
+static void* ThreadJavaMain(void* args) {
+    return (void*)(intptr_t)JavaMain(args);
+}
+
+/*
+ * Block current thread and continue execution in a new thread.
+ */
+int
+CallJavaMainInNewThread(jlong stack_size, void* args) {
+    int rslt;
+    pthread_t tid;
+    pthread_attr_t attr;
+    pthread_attr_init(&attr);
+    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
+
+    if (stack_size > 0) {
+        pthread_attr_setstacksize(&attr, stack_size);
+    }
+    pthread_attr_setguardsize(&attr, 0); // no pthread guard page on java threads
+
+    if (pthread_create(&tid, &attr, ThreadJavaMain, args) == 0) {
+        void* tmp;
+        pthread_join(tid, &tmp);
+        rslt = (int)(intptr_t)tmp;
+    } else {
+       /*
+        * Continue execution in current thread if for some reason (e.g. out of
+        * memory/LWP)  a new thread can't be created. This will likely fail
+        * later in JavaMain as JNI_CreateJavaVM needs to create quite a
+        * few new threads, anyway, just give it a try..
+        */
+        rslt = JavaMain(args);
+    }
+
+    pthread_attr_destroy(&attr);
+    return rslt;
+}
+
+/* Coarse estimation of number of digits assuming the worst case is a 64-bit pid. */
+#define MAX_PID_STR_SZ   20
+
+int
+JVMInit(InvocationFunctions* ifn, jlong threadStackSize,
+        int argc, char **argv,
+        int mode, char *what, int ret)
+{
+    ShowSplashScreen();
+    return ContinueInNewThread(ifn, threadStackSize, argc, argv, mode, what, ret);
+}
+
+void
+PostJVMInit(JNIEnv *env, jclass mainClass, JavaVM *vm)
+{
+    // stubbed out for windows and *nixes.
+}
+
+void
+RegisterThread()
+{
+    // stubbed out for windows and *nixes.
+}
+
+/*
+ * on unix, we return a false to indicate this option is not applicable
+ */
+jboolean
+ProcessPlatformOption(const char *arg)
+{
+    return JNI_FALSE;
+}
diff a/src/java.base/unix/native/libnio/ch/NativeThread.c b/src/java.base/unix/native/libnio/ch/NativeThread.c
--- a/src/java.base/unix/native/libnio/ch/NativeThread.c
+++ b/src/java.base/unix/native/libnio/ch/NativeThread.c
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2002, 2016, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2002, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -39,13 +39,10 @@
   #define INTERRUPT_SIGNAL (SIGRTMAX - 2)
 #elif defined(_AIX)
   #include <pthread.h>
   /* Also defined in net/aix_close.c */
   #define INTERRUPT_SIGNAL (SIGRTMAX - 1)
-#elif defined(__solaris__)
-  #include <thread.h>
-  #define INTERRUPT_SIGNAL (SIGRTMAX - 2)
 #elif defined(_ALLBSD_SOURCE)
   #include <pthread.h>
   /* Also defined in net/bsd_close.c */
   #define INTERRUPT_SIGNAL SIGIO
 #else
@@ -77,25 +74,17 @@
 }
 
 JNIEXPORT jlong JNICALL
 Java_sun_nio_ch_NativeThread_current(JNIEnv *env, jclass cl)
 {
-#ifdef __solaris__
-    return (jlong)thr_self();
-#else
-    return (jlong)pthread_self();
 #endif
 }
 
 JNIEXPORT void JNICALL
 Java_sun_nio_ch_NativeThread_signal(JNIEnv *env, jclass cl, jlong thread)
 {
     int ret;
-#ifdef __solaris__
-    ret = thr_kill((thread_t)thread, INTERRUPT_SIGNAL);
-#else
-    ret = pthread_kill((pthread_t)thread, INTERRUPT_SIGNAL);
 #endif
 #ifdef MACOSX
     if (ret != 0 && ret != ESRCH)
 #else
     if (ret != 0)
diff a/src/jdk.hotspot.agent/linux/native/libsaproc/ps_proc.c b/src/jdk.hotspot.agent/linux/native/libsaproc/ps_proc.c
--- a/src/jdk.hotspot.agent/linux/native/libsaproc/ps_proc.c
+++ b/src/jdk.hotspot.agent/linux/native/libsaproc/ps_proc.c
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -126,14 +126,10 @@
   // we have already attached to all thread 'pid's, just use ptrace call
   // to get regset now. Note that we don't cache regset upfront for processes.
 // Linux on x86 and sparc are different.  On x86 ptrace(PTRACE_GETREGS, ...)
 // uses pointer from 4th argument and ignores 3rd argument.  On sparc it uses
 // pointer from 3rd argument and ignores 4th argument
-#if defined(sparc) || defined(sparcv9)
-#define ptrace_getregs(request, pid, addr, data) ptrace(request, pid, addr, data)
-#else
-#define ptrace_getregs(request, pid, addr, data) ptrace(request, pid, data, addr)
 #endif
 
 #if defined(_LP64) && defined(PTRACE_GETREGS64)
 #define PTRACE_GETREGS_REQ PTRACE_GETREGS64
 #elif defined(PTRACE_GETREGS)
diff a/src/jdk.jdwp.agent/share/native/libjdwp/util.h b/src/jdk.jdwp.agent/share/native/libjdwp/util.h
--- a/src/jdk.jdwp.agent/share/native/libjdwp/util.h
+++ b/src/jdk.jdwp.agent/share/native/libjdwp/util.h
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1998, 2016, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -249,17 +249,10 @@
 typedef struct ObjectBatch {
     jobject *objects;
     jint     count;
 } ObjectBatch;
 
-/*
- * JNI signature constants, beyond those defined in JDWP_TAG(*)
- */
-#define SIGNATURE_BEGIN_ARGS    '('
-#define SIGNATURE_END_ARGS      ')'
-#define SIGNATURE_END_CLASS     ';'
-
 /*
  * Modifier flags for classes, fields, methods
  */
 #define MOD_PUBLIC       0x0001     /* visible to everyone */
 #define MOD_PRIVATE      0x0002     /* visible only to the defining class */
@@ -289,11 +282,10 @@
 jint uniqueID(void);
 jbyte referenceTypeTag(jclass clazz);
 jbyte specificTypeKey(JNIEnv *env, jobject object);
 jboolean isObjectTag(jbyte tag);
 jvmtiError spawnNewThread(jvmtiStartFunction func, void *arg, char *name);
-void convertSignatureToClassname(char *convert);
 void writeCodeLocation(struct PacketOutputStream *out, jclass clazz,
                        jmethodID method, jlocation location);
 
 jvmtiError classInstances(jclass klass, ObjectBatch *instances, int maxInstances);
 jvmtiError classInstanceCounts(jint classCount, jclass *classes, jlong *counts);
diff a/test/hotspot/jtreg/runtime/8176717/TestInheritFD.java b/test/hotspot/jtreg/runtime/8176717/TestInheritFD.java
--- a/test/hotspot/jtreg/runtime/8176717/TestInheritFD.java
+++ b/test/hotspot/jtreg/runtime/8176717/TestInheritFD.java
@@ -67,11 +67,11 @@
  * (windows can not rename opened files easily)
  *
  * The third VM communicates the success to rename the file by printing "CLOSED
  * FD". The first VM checks that the string was printed by the third VM.
  *
- * On unix like systems "lsof" or "pfiles" is used.
+ * On unix like systems "lsof" is used.
  */
 
 public class TestInheritFD {
 
     public static final String LEAKS_FD = "VM RESULT => LEAKS FD";
@@ -171,16 +171,15 @@
             throw new RuntimeException(e);
         }
     }
 
     static Optional<Command> lsofCommandCache = stream(new Command[]{
-            new Command("/usr/bin/lsof", "-p", true),
-            new Command("/usr/sbin/lsof", "-p", true),
-            new Command("/bin/lsof", "-p", true),
-            new Command("/sbin/lsof", "-p", true),
-            new Command("/usr/local/bin/lsof", "-p", true),
-            new Command("/usr/bin/pfiles", "-F", false), // Solaris
+            new Command("/usr/bin/lsof", "-p"),
+            new Command("/usr/sbin/lsof", "-p"),
+            new Command("/bin/lsof", "-p"),
+            new Command("/sbin/lsof", "-p"),
+            new Command("/usr/local/bin/lsof", "-p"),
         })
         .filter(command -> command.exists())
         .findFirst();
 
     static Optional<Command> lsofCommand() {
@@ -194,11 +193,11 @@
     static Collection<String> outputContainingFilenames() {
         String pid = getPid();
         Command command = lsofCmd();
         System.out.printf("using command: %s%n", command);
         return run(command.name, command.option, pid)
-                .filter(line -> !command.checkPid || line.contains(pid))
+                .filter(line -> line.contains(pid))
                 .collect(toList());
     }
 
     static boolean findOpenLogFile(Collection<String> fileNames) {
         return fileNames.stream()
@@ -219,24 +218,22 @@
     }
 
     private static class Command {
         private final String name;
         private final String option;
-        private final boolean checkPid;
 
-        public Command(String name, String option, boolean checkPid) {
+        public Command(String name, String option) {
             this.name = name;
             this.option = option;
-            this.checkPid = checkPid;
         }
 
         private boolean exists() {
             return new File(name).exists();
         }
 
         public String toString() {
-            return String.format("[name: %s, option: %s, check pid: %b]",
-                    name, option, checkPid);
+            return String.format("[name: %s, option: %s]",
+                    name, option);
         }
     }
 }
 
diff a/test/jdk/TEST.ROOT b/test/jdk/TEST.ROOT
--- a/test/jdk/TEST.ROOT
+++ b/test/jdk/TEST.ROOT
@@ -34,16 +34,17 @@
 
 # Allow querying of various System properties in @requires clauses
 #
 # Source files for classes that will be used at the beginning of each test suite run,
 # to determine additional characteristics of the system for use with the @requires tag.
-# Note: compiled bootlibs code will be located in the folder 'bootClasses'
+# Note: compiled bootlibs classes will be added to BCP.
 requires.extraPropDefns = ../jtreg-ext/requires/VMProps.java
-requires.extraPropDefns.bootlibs = ../lib/sun \
+requires.extraPropDefns.bootlibs = ../lib/sun
+requires.extraPropDefns.libs = \
     ../lib/jdk/test/lib/Platform.java \
     ../lib/jdk/test/lib/Container.java
-requires.extraPropDefns.vmOpts = -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath/a:bootClasses
+requires.extraPropDefns.vmOpts = -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI
 requires.properties= \
     sun.arch.data.model \
     java.runtime.name \
     vm.gc.Z \
     vm.gc.Shenandoah \
@@ -57,11 +58,11 @@
     vm.hasJFR \
     docker.support \
     release.implementor
 
 # Minimum jtreg version
-requiredVersion=5.0 b1
+requiredVersion=5.1 b1
 
 # Path to libraries in the topmost test directory. This is needed so @library
 # does not need ../../ notation to reach them
 external.lib.roots = ../../
 
diff a/test/jdk/java/lang/ProcessBuilder/Basic.java b/test/jdk/java/lang/ProcessBuilder/Basic.java
--- a/test/jdk/java/lang/ProcessBuilder/Basic.java
+++ b/test/jdk/java/lang/ProcessBuilder/Basic.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -2184,34 +2184,11 @@
 
                 thread.start();
                 latch.await();
                 Thread.sleep(10);
 
-                String os = System.getProperty("os.name");
-                if (os.equalsIgnoreCase("Solaris") ||
-                    os.equalsIgnoreCase("SunOS"))
-                {
-                    final Object deferred;
-                    Class<?> c = s.getClass();
-                    if (c.getName().equals(
-                        "java.lang.ProcessImpl$DeferredCloseInputStream"))
-                    {
-                        deferred = s;
-                    } else {
-                        Field deferredField = p.getClass().
-                            getDeclaredField("stdout_inner_stream");
-                        deferredField.setAccessible(true);
-                        deferred = deferredField.get(p);
-                    }
-                    Field useCountField = deferred.getClass().
-                        getDeclaredField("useCount");
-                    useCountField.setAccessible(true);
-
-                    while (useCountField.getInt(deferred) <= 0) {
-                        Thread.yield();
-                    }
-                } else if (s instanceof BufferedInputStream) {
+                if (s instanceof BufferedInputStream) {
                     // Wait until after the s.read occurs in "thread" by
                     // checking when the input stream monitor is acquired
                     // (BufferedInputStream.read is synchronized)
                     while (!isLocked(s, 10)) {
                         Thread.sleep(100);
diff a/test/jdk/tools/launcher/ExecutionEnvironment.java b/test/jdk/tools/launcher/ExecutionEnvironment.java
--- a/test/jdk/tools/launcher/ExecutionEnvironment.java
+++ b/test/jdk/tools/launcher/ExecutionEnvironment.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2009, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -178,46 +178,24 @@
     /*
      * This test ensures that LD_LIBRARY_PATH* values are interpreted by the VM
      * and the expected java.library.path behaviour.
      * For Generic platforms (All *nixes):
      *    * All LD_LIBRARY_PATH variable should be on java.library.path
-     * For Solaris 32-bit
-     *    * The LD_LIBRARY_PATH_32 should override LD_LIBRARY_PATH if specified
-     * For Solaris 64-bit
-     *    * The LD_LIBRARY_PATH_64 should override LD_LIBRARY_PATH if specified
      */
     @Test
     void testJavaLibraryPath() {
         TestResult tr;
 
         Map<String, String> env = new HashMap<>();
 
-        if (TestHelper.isSolaris) {
-            // no override
-            env.clear();
-            env.put(LD_LIBRARY_PATH, LD_LIBRARY_PATH_VALUE);
-            tr = doExec(env, javaCmd, "-jar", testJarFile.getAbsolutePath());
-            verifyJavaLibraryPathGeneric(tr);
-
-            env.clear();
-            for (String x : LD_PATH_STRINGS) {
-                String pairs[] = x.split("=");
-                env.put(pairs[0], pairs[1]);
-            }
-
-            // verify the override occurs for 64-bit system
-            tr = doExec(env, javaCmd, "-jar", testJarFile.getAbsolutePath());
-            verifyJavaLibraryPathOverride(tr, false);
-        } else {
-            for (String x : LD_PATH_STRINGS) {
-                String pairs[] = x.split("=");
-                env.put(pairs[0], pairs[1]);
-            }
-
-            tr = doExec(env, javaCmd, "-jar", testJarFile.getAbsolutePath());
-            verifyJavaLibraryPathGeneric(tr);
+        for (String x : LD_PATH_STRINGS) {
+            String pairs[] = x.split("=");
+            env.put(pairs[0], pairs[1]);
         }
+
+        tr = doExec(env, javaCmd, "-jar", testJarFile.getAbsolutePath());
+        verifyJavaLibraryPathGeneric(tr);
     }
 
     private void verifyJavaLibraryPathGeneric(TestResult tr) {
         if (!tr.matches("java.library.path=.*" + LD_LIBRARY_PATH_VALUE + ".*")) {
             flagError(tr, "testJavaLibraryPath: java.library.path does not contain " +
diff a/test/jdk/tools/launcher/Test7029048.java b/test/jdk/tools/launcher/Test7029048.java
--- a/test/jdk/tools/launcher/Test7029048.java
+++ b/test/jdk/tools/launcher/Test7029048.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -87,33 +87,10 @@
         System.out.println(tr);
         analyze(tr, nLLPComponents, caseID);
     }
 
     static void analyze(TestResult tr, int nLLPComponents, String caseID) {
-        if (isSolaris) {
-            String envValue = getValue("LD_LIBRARY_PATH_64", tr.testOutput);
-           /*
-            * the envValue can never be null, since the test code should always
-            * print a "null" string.
-            */
-            if (envValue == null) {
-                throw new RuntimeException("NPE, likely a program crash ??");
-            }
-            boolean noLLP64 = envValue.equals("null");
-            if (nLLPComponents == 0 && noLLP64) {
-                System.out.println("FAIL: test7029048, " + caseID);
-                System.out.println(" Missing LD_LIBRARY_PATH_64");
-                errors++;
-                return;
-            } else if (nLLPComponents > 3 && !noLLP64) {
-                System.out.println("FAIL: test7029048, " + caseID);
-                System.out.println(" Unexpected LD_LIBRARY_PATH_64: " + envValue);
-                errors++;
-                return;
-            }
-        }
-
         String envValue = getValue(LD_LIBRARY_PATH, tr.testOutput);
        /*
         * the envValue can never be null, since the test code should always
         * print a "null" string.
         */
@@ -214,23 +191,10 @@
             env.clear();
             env.put(LD_LIBRARY_PATH, dstClientDir.getAbsolutePath());
             run(env,
                 v.value + 1,            // Add one to account for our setting
                 "Case 2: " + desc);
-
-            if (isSolaris) {
-                /*
-                 * Case 3: set the appropriate LLP_XX flag,
-                 * java64 LLP_64 is relevant, LLP_32 is ignored
-                 */
-                env.clear();
-                env.put(LD_LIBRARY_PATH_64, dstServerDir.getAbsolutePath());
-                run(env,
-                    // LD_LIBRARY_PATH_64 is copied into LD_LIBRARY_PATH for LIBJVM case
-                    v.value == 0 ? 0 : v.value + 1,
-                    "Case 3: " + desc);
-            }
         }
         return;
     }
 
     public static void main(String... args) throws Exception {
@@ -251,13 +215,10 @@
         int passesLinux = TestHelper.isMusl ? 2 : 6;
 
         if (errors > 0) {
             throw new Exception("Test7029048: FAIL: with "
                     + errors + " errors and passes " + passes);
-        } else if (isSolaris && passes < 9) {
-            throw new Exception("Test7029048: FAIL: " +
-                    "all tests did not run, expected " + 9 + " got " + passes);
         } else if (isLinux && passes < passesLinux) {
              throw new Exception("Test7029048: FAIL: " +
                     "all tests did not run, expected " + passesLinux + " got " + passes);
         } else {
             System.out.println("Test7029048: PASS " + passes);
diff a/test/jdk/tools/launcher/TestHelper.java b/test/jdk/tools/launcher/TestHelper.java
--- a/test/jdk/tools/launcher/TestHelper.java
+++ b/test/jdk/tools/launcher/TestHelper.java
@@ -83,24 +83,20 @@
             System.getProperty("os.name", "unknown").contains("OS X");
     static final boolean is64Bit =
             System.getProperty("sun.arch.data.model").equals("64");
     static final boolean is32Bit =
             System.getProperty("sun.arch.data.model").equals("32");
-    static final boolean isSolaris =
-            System.getProperty("os.name", "unknown").startsWith("SunOS");
     static final boolean isLinux =
             System.getProperty("os.name", "unknown").startsWith("Linux");
     static final boolean isAIX =
             System.getProperty("os.name", "unknown").startsWith("AIX");
     static final boolean isMusl = isMuslLibc();
     static final String LIBJVM = isWindows
                         ? "jvm.dll"
                         : "libjvm" + (isMacOSX ? ".dylib" : ".so");
     static final boolean isExpandedSharedLibraryPath = isAIX || isMusl;
 
-    static final boolean isSparc = System.getProperty("os.arch").startsWith("sparc");
-
     // make a note of the golden default locale
     static final Locale DefaultLocale = Locale.getDefault();
 
     static final String JAVA_FILE_EXT   = ".java";
     static final String CLASS_FILE_EXT  = ".class";

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/lang/ProcessBuilder/Basic.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../../../TEST.ROOT.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../../../tools/launcher/ExecutionEnvironment.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/lang/ProcessBuilder/Basic.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
</pre>
<hr />
<pre>
2169 
2170                                 } else {
2171                                     System.out.write(bytes, 0, r);
2172                                 }
2173                                 for (int c = s.read(); c &gt;= 0; c = s.read())
2174                                     System.out.write(c);
2175                                 System.out.println(&quot;\nEND Child output.&quot;);
2176                             }
2177                             equal(-1, r);
2178                         } catch (IOException ioe) {
2179                             if (!ioe.getMessage().equals(&quot;Stream closed&quot;)) {
2180                                 // BufferedInputStream may throw IOE(&quot;Stream closed&quot;).
2181                                 unexpected(ioe);
2182                             }
2183                         } catch (Throwable t) { unexpected(t); }}};
2184 
2185                 thread.start();
2186                 latch.await();
2187                 Thread.sleep(10);
2188 
<span class="line-modified">2189                 String os = System.getProperty(&quot;os.name&quot;);</span>
<span class="line-removed">2190                 if (os.equalsIgnoreCase(&quot;Solaris&quot;) ||</span>
<span class="line-removed">2191                     os.equalsIgnoreCase(&quot;SunOS&quot;))</span>
<span class="line-removed">2192                 {</span>
<span class="line-removed">2193                     final Object deferred;</span>
<span class="line-removed">2194                     Class&lt;?&gt; c = s.getClass();</span>
<span class="line-removed">2195                     if (c.getName().equals(</span>
<span class="line-removed">2196                         &quot;java.lang.ProcessImpl$DeferredCloseInputStream&quot;))</span>
<span class="line-removed">2197                     {</span>
<span class="line-removed">2198                         deferred = s;</span>
<span class="line-removed">2199                     } else {</span>
<span class="line-removed">2200                         Field deferredField = p.getClass().</span>
<span class="line-removed">2201                             getDeclaredField(&quot;stdout_inner_stream&quot;);</span>
<span class="line-removed">2202                         deferredField.setAccessible(true);</span>
<span class="line-removed">2203                         deferred = deferredField.get(p);</span>
<span class="line-removed">2204                     }</span>
<span class="line-removed">2205                     Field useCountField = deferred.getClass().</span>
<span class="line-removed">2206                         getDeclaredField(&quot;useCount&quot;);</span>
<span class="line-removed">2207                     useCountField.setAccessible(true);</span>
<span class="line-removed">2208 </span>
<span class="line-removed">2209                     while (useCountField.getInt(deferred) &lt;= 0) {</span>
<span class="line-removed">2210                         Thread.yield();</span>
<span class="line-removed">2211                     }</span>
<span class="line-removed">2212                 } else if (s instanceof BufferedInputStream) {</span>
2213                     // Wait until after the s.read occurs in &quot;thread&quot; by
2214                     // checking when the input stream monitor is acquired
2215                     // (BufferedInputStream.read is synchronized)
2216                     while (!isLocked(s, 10)) {
2217                         Thread.sleep(100);
2218                     }
2219                 }
2220                 p.destroy();
2221                 thread.join();
2222             }
2223         } catch (Throwable t) { unexpected(t); }
2224 
2225         //----------------------------------------------------------------
2226         // Check that subprocesses which create subprocesses of their
2227         // own do not cause parent to hang waiting for file
2228         // descriptors to be closed.
2229         //----------------------------------------------------------------
2230         try {
2231             if (Unix.is()
2232                 &amp;&amp; new File(&quot;/bin/bash&quot;).exists()
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
</pre>
<hr />
<pre>
2169 
2170                                 } else {
2171                                     System.out.write(bytes, 0, r);
2172                                 }
2173                                 for (int c = s.read(); c &gt;= 0; c = s.read())
2174                                     System.out.write(c);
2175                                 System.out.println(&quot;\nEND Child output.&quot;);
2176                             }
2177                             equal(-1, r);
2178                         } catch (IOException ioe) {
2179                             if (!ioe.getMessage().equals(&quot;Stream closed&quot;)) {
2180                                 // BufferedInputStream may throw IOE(&quot;Stream closed&quot;).
2181                                 unexpected(ioe);
2182                             }
2183                         } catch (Throwable t) { unexpected(t); }}};
2184 
2185                 thread.start();
2186                 latch.await();
2187                 Thread.sleep(10);
2188 
<span class="line-modified">2189                 if (s instanceof BufferedInputStream) {</span>























2190                     // Wait until after the s.read occurs in &quot;thread&quot; by
2191                     // checking when the input stream monitor is acquired
2192                     // (BufferedInputStream.read is synchronized)
2193                     while (!isLocked(s, 10)) {
2194                         Thread.sleep(100);
2195                     }
2196                 }
2197                 p.destroy();
2198                 thread.join();
2199             }
2200         } catch (Throwable t) { unexpected(t); }
2201 
2202         //----------------------------------------------------------------
2203         // Check that subprocesses which create subprocesses of their
2204         // own do not cause parent to hang waiting for file
2205         // descriptors to be closed.
2206         //----------------------------------------------------------------
2207         try {
2208             if (Unix.is()
2209                 &amp;&amp; new File(&quot;/bin/bash&quot;).exists()
</pre>
</td>
</tr>
</table>
<center><a href="../../../TEST.ROOT.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../../../tools/launcher/ExecutionEnvironment.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
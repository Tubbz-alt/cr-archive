<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/lang/ProcessBuilder/Basic.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 /*
  25  * @test
  26  * @bug 4199068 4738465 4937983 4930681 4926230 4931433 4932663 4986689
  27  *      5026830 5023243 5070673 4052517 4811767 6192449 6397034 6413313
  28  *      6464154 6523983 6206031 4960438 6631352 6631966 6850957 6850958
  29  *      4947220 7018606 7034570 4244896 5049299 8003488 8054494 8058464
  30  *      8067796 8224905
  31  * @key intermittent
  32  * @summary Basic tests for Process and Environment Variable code
  33  * @modules java.base/java.lang:open
  34  * @run main/othervm/timeout=300 Basic
  35  * @run main/othervm/timeout=300 -Djdk.lang.Process.launchMechanism=fork Basic
  36  * @author Martin Buchholz
  37  */
  38 
  39 /*
  40  * @test
  41  * @modules java.base/java.lang:open
  42  * @requires (os.family == &quot;linux&quot;)
  43  * @run main/othervm/timeout=300 -Djdk.lang.Process.launchMechanism=posix_spawn Basic
  44  */
  45 
  46 import java.lang.ProcessBuilder.Redirect;
  47 import java.lang.ProcessHandle;
  48 import static java.lang.ProcessBuilder.Redirect.*;
  49 
  50 import java.io.*;
  51 import java.lang.reflect.Field;
  52 import java.nio.file.Files;
  53 import java.nio.file.Paths;
  54 import java.nio.file.StandardCopyOption;
  55 import java.util.*;
  56 import java.util.concurrent.CountDownLatch;
  57 import java.util.concurrent.TimeUnit;
  58 import java.security.*;
  59 import java.util.regex.Pattern;
  60 import java.util.regex.Matcher;
  61 import static java.lang.System.getenv;
  62 import static java.lang.System.out;
  63 import static java.lang.Boolean.TRUE;
  64 import static java.util.AbstractMap.SimpleImmutableEntry;
  65 
  66 public class Basic {
  67 
  68     /* used for Windows only */
  69     static final String systemRoot = System.getenv(&quot;SystemRoot&quot;);
  70 
  71     /* used for Mac OS X only */
  72     static final String cfUserTextEncoding = System.getenv(&quot;__CF_USER_TEXT_ENCODING&quot;);
  73 
  74     /* used for AIX only */
  75     static final String libpath = System.getenv(&quot;LIBPATH&quot;);
  76 
  77     /* Used for regex String matching for long error messages */
  78     static final String PERMISSION_DENIED_ERROR_MSG = &quot;(Permission denied|error=13)&quot;;
  79     static final String NO_SUCH_FILE_ERROR_MSG = &quot;(No such file|error=2)&quot;;
  80 
  81     /**
  82      * Returns the number of milliseconds since time given by
  83      * startNanoTime, which must have been previously returned from a
  84      * call to {@link System.nanoTime()}.
  85      */
  86     private static long millisElapsedSince(long startNanoTime) {
  87         return TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanoTime);
  88     }
  89 
  90     private static String commandOutput(Reader r) throws Throwable {
  91         StringBuilder sb = new StringBuilder();
  92         int c;
  93         while ((c = r.read()) &gt; 0)
  94             if (c != &#39;\r&#39;)
  95                 sb.append((char) c);
  96         return sb.toString();
  97     }
  98 
  99     private static String commandOutput(Process p) throws Throwable {
 100         check(p.getInputStream()  == p.getInputStream());
 101         check(p.getOutputStream() == p.getOutputStream());
 102         check(p.getErrorStream()  == p.getErrorStream());
 103         Reader r = new InputStreamReader(p.getInputStream(),&quot;UTF-8&quot;);
 104         String output = commandOutput(r);
 105         equal(p.waitFor(), 0);
 106         equal(p.exitValue(), 0);
 107         // The debug/fastdebug versions of the VM may write some warnings to stdout
 108         // (i.e. &quot;Warning:  Cannot open log file: hotspot.log&quot; if the VM is started
 109         // in a directory without write permissions). These warnings will confuse tests
 110         // which match the entire output of the child process so better filter them out.
 111         return output.replaceAll(&quot;Warning:.*\\n&quot;, &quot;&quot;);
 112     }
 113 
 114     private static String commandOutput(ProcessBuilder pb) {
 115         try {
 116             return commandOutput(pb.start());
 117         } catch (Throwable t) {
 118             String commandline = &quot;&quot;;
 119             for (String arg : pb.command())
 120                 commandline += &quot; &quot; + arg;
 121             System.out.println(&quot;Exception trying to run process: &quot; + commandline);
 122             unexpected(t);
 123             return &quot;&quot;;
 124         }
 125     }
 126 
 127     private static String commandOutput(String...command) {
 128         try {
 129             return commandOutput(Runtime.getRuntime().exec(command));
 130         } catch (Throwable t) {
 131             String commandline = &quot;&quot;;
 132             for (String arg : command)
 133                 commandline += &quot; &quot; + arg;
 134             System.out.println(&quot;Exception trying to run process: &quot; + commandline);
 135             unexpected(t);
 136             return &quot;&quot;;
 137         }
 138     }
 139 
 140     private static void checkCommandOutput(ProcessBuilder pb,
 141                                            String expected,
 142                                            String failureMsg) {
 143         String got = commandOutput(pb);
 144         check(got.equals(expected),
 145               failureMsg + &quot;\n&quot; +
 146               &quot;Expected: \&quot;&quot; + expected + &quot;\&quot;\n&quot; +
 147               &quot;Got: \&quot;&quot; + got + &quot;\&quot;&quot;);
 148     }
 149 
 150     private static String absolutifyPath(String path) {
 151         StringBuilder sb = new StringBuilder();
 152         for (String file : path.split(File.pathSeparator)) {
 153             if (sb.length() != 0)
 154                 sb.append(File.pathSeparator);
 155             sb.append(new File(file).getAbsolutePath());
 156         }
 157         return sb.toString();
 158     }
 159 
 160     // compare windows-style, by canonicalizing to upper case,
 161     // not lower case as String.compareToIgnoreCase does
 162     private static class WindowsComparator
 163         implements Comparator&lt;String&gt; {
 164         public int compare(String x, String y) {
 165             return x.toUpperCase(Locale.US)
 166                 .compareTo(y.toUpperCase(Locale.US));
 167         }
 168     }
 169 
 170     private static String sortedLines(String lines) {
 171         String[] arr = lines.split(&quot;\n&quot;);
 172         List&lt;String&gt; ls = new ArrayList&lt;String&gt;();
 173         for (String s : arr)
 174             ls.add(s);
 175         Collections.sort(ls, new WindowsComparator());
 176         StringBuilder sb = new StringBuilder();
 177         for (String s : ls)
 178             sb.append(s + &quot;\n&quot;);
 179         return sb.toString();
 180     }
 181 
 182     private static void compareLinesIgnoreCase(String lines1, String lines2) {
 183         if (! (sortedLines(lines1).equalsIgnoreCase(sortedLines(lines2)))) {
 184             String dashes =
 185                 &quot;-----------------------------------------------------&quot;;
 186             out.println(dashes);
 187             out.print(sortedLines(lines1));
 188             out.println(dashes);
 189             out.print(sortedLines(lines2));
 190             out.println(dashes);
 191             out.println(&quot;sizes: &quot; + sortedLines(lines1).length() +
 192                         &quot; &quot; + sortedLines(lines2).length());
 193 
 194             fail(&quot;Sorted string contents differ&quot;);
 195         }
 196     }
 197 
 198     private static final Runtime runtime = Runtime.getRuntime();
 199 
 200     private static final String[] winEnvCommand = {&quot;cmd.exe&quot;, &quot;/c&quot;, &quot;set&quot;};
 201 
 202     private static String winEnvFilter(String env) {
 203         return env.replaceAll(&quot;\r&quot;, &quot;&quot;)
 204             .replaceAll(&quot;(?m)^(?:COMSPEC|PROMPT|PATHEXT)=.*\n&quot;,&quot;&quot;);
 205     }
 206 
 207     private static String unixEnvProg() {
 208         return new File(&quot;/usr/bin/env&quot;).canExecute() ? &quot;/usr/bin/env&quot;
 209             : &quot;/bin/env&quot;;
 210     }
 211 
 212     private static String nativeEnv(String[] env) {
 213         try {
 214             if (Windows.is()) {
 215                 return winEnvFilter
 216                     (commandOutput(runtime.exec(winEnvCommand, env)));
 217             } else {
 218                 return commandOutput(runtime.exec(unixEnvProg(), env));
 219             }
 220         } catch (Throwable t) { throw new Error(t); }
 221     }
 222 
 223     private static String nativeEnv(ProcessBuilder pb) {
 224         try {
 225             if (Windows.is()) {
 226                 pb.command(winEnvCommand);
 227                 return winEnvFilter(commandOutput(pb));
 228             } else {
 229                 pb.command(new String[]{unixEnvProg()});
 230                 return commandOutput(pb);
 231             }
 232         } catch (Throwable t) { throw new Error(t); }
 233     }
 234 
 235     private static void checkSizes(Map&lt;String,String&gt; environ, int size) {
 236         try {
 237             equal(size, environ.size());
 238             equal(size, environ.entrySet().size());
 239             equal(size, environ.keySet().size());
 240             equal(size, environ.values().size());
 241 
 242             boolean isEmpty = (size == 0);
 243             equal(isEmpty, environ.isEmpty());
 244             equal(isEmpty, environ.entrySet().isEmpty());
 245             equal(isEmpty, environ.keySet().isEmpty());
 246             equal(isEmpty, environ.values().isEmpty());
 247         } catch (Throwable t) { unexpected(t); }
 248     }
 249 
 250     private interface EnvironmentFrobber {
 251         void doIt(Map&lt;String,String&gt; environ);
 252     }
 253 
 254     private static void testVariableDeleter(EnvironmentFrobber fooDeleter) {
 255         try {
 256             Map&lt;String,String&gt; environ = new ProcessBuilder().environment();
 257             environ.put(&quot;Foo&quot;, &quot;BAAR&quot;);
 258             fooDeleter.doIt(environ);
 259             equal(environ.get(&quot;Foo&quot;), null);
 260             equal(environ.remove(&quot;Foo&quot;), null);
 261         } catch (Throwable t) { unexpected(t); }
 262     }
 263 
 264     private static void testVariableAdder(EnvironmentFrobber fooAdder) {
 265         try {
 266             Map&lt;String,String&gt; environ = new ProcessBuilder().environment();
 267             environ.remove(&quot;Foo&quot;);
 268             fooAdder.doIt(environ);
 269             equal(environ.get(&quot;Foo&quot;), &quot;Bahrein&quot;);
 270         } catch (Throwable t) { unexpected(t); }
 271     }
 272 
 273     private static void testVariableModifier(EnvironmentFrobber fooModifier) {
 274         try {
 275             Map&lt;String,String&gt; environ = new ProcessBuilder().environment();
 276             environ.put(&quot;Foo&quot;,&quot;OldValue&quot;);
 277             fooModifier.doIt(environ);
 278             equal(environ.get(&quot;Foo&quot;), &quot;NewValue&quot;);
 279         } catch (Throwable t) { unexpected(t); }
 280     }
 281 
 282     private static void printUTF8(String s) throws IOException {
 283         out.write(s.getBytes(&quot;UTF-8&quot;));
 284     }
 285 
 286     private static String getenvAsString(Map&lt;String,String&gt; environment) {
 287         StringBuilder sb = new StringBuilder();
 288         environment = new TreeMap&lt;&gt;(environment);
 289         for (Map.Entry&lt;String,String&gt; e : environment.entrySet())
 290             // Ignore magic environment variables added by the launcher
 291             if (! e.getKey().equals(&quot;LD_LIBRARY_PATH&quot;))
 292                 sb.append(e.getKey())
 293                     .append(&#39;=&#39;)
 294                     .append(e.getValue())
 295                     .append(&#39;,&#39;);
 296         return sb.toString();
 297     }
 298 
 299     static void print4095(OutputStream s, byte b) throws Throwable {
 300         byte[] bytes = new byte[4095];
 301         Arrays.fill(bytes, b);
 302         s.write(bytes);         // Might hang!
 303     }
 304 
 305     static void checkPermissionDenied(ProcessBuilder pb) {
 306         try {
 307             pb.start();
 308             fail(&quot;Expected IOException not thrown&quot;);
 309         } catch (IOException e) {
 310             String m = e.getMessage();
 311             if (EnglishUnix.is() &amp;&amp;
 312                 ! matches(m, PERMISSION_DENIED_ERROR_MSG))
 313                 unexpected(e);
 314         } catch (Throwable t) { unexpected(t); }
 315     }
 316 
 317     public static class JavaChild {
 318         public static void main(String args[]) throws Throwable {
 319             String action = args[0];
 320             if (action.equals(&quot;sleep&quot;)) {
 321                 Thread.sleep(10 * 60 * 1000L);
 322             } else if (action.equals(&quot;pid&quot;)) {
 323                 System.out.println(ProcessHandle.current().pid());
 324             } else if (action.equals(&quot;testIO&quot;)) {
 325                 String expected = &quot;standard input&quot;;
 326                 char[] buf = new char[expected.length()+1];
 327                 int n = new InputStreamReader(System.in).read(buf,0,buf.length);
 328                 if (n != expected.length())
 329                     System.exit(5);
 330                 if (! new String(buf,0,n).equals(expected))
 331                     System.exit(5);
 332                 System.err.print(&quot;standard error&quot;);
 333                 System.out.print(&quot;standard output&quot;);
 334             } else if (action.equals(&quot;testInheritIO&quot;)
 335                     || action.equals(&quot;testRedirectInherit&quot;)) {
 336                 List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
 337                 childArgs.add(&quot;testIO&quot;);
 338                 ProcessBuilder pb = new ProcessBuilder(childArgs);
 339                 if (action.equals(&quot;testInheritIO&quot;))
 340                     pb.inheritIO();
 341                 else
 342                     redirectIO(pb, INHERIT, INHERIT, INHERIT);
 343                 ProcessResults r = run(pb);
 344                 if (! r.out().equals(&quot;&quot;))
 345                     System.exit(7);
 346                 if (! r.err().equals(&quot;&quot;))
 347                     System.exit(8);
 348                 if (r.exitValue() != 0)
 349                     System.exit(9);
 350             } else if (action.equals(&quot;System.getenv(String)&quot;)) {
 351                 String val = System.getenv(args[1]);
 352                 printUTF8(val == null ? &quot;null&quot; : val);
 353             } else if (action.equals(&quot;System.getenv(\\u1234)&quot;)) {
 354                 String val = System.getenv(&quot;\u1234&quot;);
 355                 printUTF8(val == null ? &quot;null&quot; : val);
 356             } else if (action.equals(&quot;System.getenv()&quot;)) {
 357                 printUTF8(getenvAsString(System.getenv()));
 358             } else if (action.equals(&quot;ArrayOOME&quot;)) {
 359                 Object dummy;
 360                 switch(new Random().nextInt(3)) {
 361                 case 0: dummy = new Integer[Integer.MAX_VALUE]; break;
 362                 case 1: dummy = new double[Integer.MAX_VALUE];  break;
 363                 case 2: dummy = new byte[Integer.MAX_VALUE][];  break;
 364                 default: throw new InternalError();
 365                 }
 366             } else if (action.equals(&quot;pwd&quot;)) {
 367                 printUTF8(new File(System.getProperty(&quot;user.dir&quot;))
 368                           .getCanonicalPath());
 369             } else if (action.equals(&quot;print4095&quot;)) {
 370                 print4095(System.out, (byte) &#39;!&#39;);
 371                 print4095(System.err, (byte) &#39;E&#39;);
 372                 System.exit(5);
 373             } else if (action.equals(&quot;OutErr&quot;)) {
 374                 // You might think the system streams would be
 375                 // buffered, and in fact they are implemented using
 376                 // BufferedOutputStream, but each and every print
 377                 // causes immediate operating system I/O.
 378                 System.out.print(&quot;out&quot;);
 379                 System.err.print(&quot;err&quot;);
 380                 System.out.print(&quot;out&quot;);
 381                 System.err.print(&quot;err&quot;);
 382             } else if (action.equals(&quot;null PATH&quot;)) {
 383                 equal(System.getenv(&quot;PATH&quot;), null);
 384                 check(new File(&quot;/bin/true&quot;).exists());
 385                 check(new File(&quot;/bin/false&quot;).exists());
 386                 ProcessBuilder pb1 = new ProcessBuilder();
 387                 ProcessBuilder pb2 = new ProcessBuilder();
 388                 pb2.environment().put(&quot;PATH&quot;, &quot;anyOldPathIgnoredAnyways&quot;);
 389                 ProcessResults r;
 390 
 391                 for (final ProcessBuilder pb :
 392                          new ProcessBuilder[] {pb1, pb2}) {
 393                     pb.command(&quot;true&quot;);
 394                     equal(run(pb).exitValue(), True.exitValue());
 395 
 396                     pb.command(&quot;false&quot;);
 397                     equal(run(pb).exitValue(), False.exitValue());
 398                 }
 399 
 400                 if (failed != 0) throw new Error(&quot;null PATH&quot;);
 401             } else if (action.equals(&quot;PATH search algorithm&quot;)) {
 402                 equal(System.getenv(&quot;PATH&quot;), &quot;dir1:dir2:&quot;);
 403                 check(new File(TrueExe.path()).exists());
 404                 check(new File(FalseExe.path()).exists());
 405                 String[] cmd = {&quot;prog&quot;};
 406                 ProcessBuilder pb1 = new ProcessBuilder(cmd);
 407                 ProcessBuilder pb2 = new ProcessBuilder(cmd);
 408                 ProcessBuilder pb3 = new ProcessBuilder(cmd);
 409                 pb2.environment().put(&quot;PATH&quot;, &quot;anyOldPathIgnoredAnyways&quot;);
 410                 pb3.environment().remove(&quot;PATH&quot;);
 411 
 412                 for (final ProcessBuilder pb :
 413                          new ProcessBuilder[] {pb1, pb2, pb3}) {
 414                     try {
 415                         // Not on PATH at all; directories don&#39;t exist
 416                         try {
 417                             pb.start();
 418                             fail(&quot;Expected IOException not thrown&quot;);
 419                         } catch (IOException e) {
 420                             String m = e.getMessage();
 421                             if (EnglishUnix.is() &amp;&amp;
 422                                 ! matches(m, NO_SUCH_FILE_ERROR_MSG))
 423                                 unexpected(e);
 424                         } catch (Throwable t) { unexpected(t); }
 425 
 426                         // Not on PATH at all; directories exist
 427                         new File(&quot;dir1&quot;).mkdirs();
 428                         new File(&quot;dir2&quot;).mkdirs();
 429                         try {
 430                             pb.start();
 431                             fail(&quot;Expected IOException not thrown&quot;);
 432                         } catch (IOException e) {
 433                             String m = e.getMessage();
 434                             if (EnglishUnix.is() &amp;&amp;
 435                                 ! matches(m, NO_SUCH_FILE_ERROR_MSG))
 436                                 unexpected(e);
 437                         } catch (Throwable t) { unexpected(t); }
 438 
 439                         // Can&#39;t execute a directory -- permission denied
 440                         // Report EACCES errno
 441                         new File(&quot;dir1/prog&quot;).mkdirs();
 442                         checkPermissionDenied(pb);
 443 
 444                         // continue searching if EACCES
 445                         copy(TrueExe.path(), &quot;dir2/prog&quot;);
 446                         equal(run(pb).exitValue(), True.exitValue());
 447                         new File(&quot;dir1/prog&quot;).delete();
 448                         new File(&quot;dir2/prog&quot;).delete();
 449 
 450                         new File(&quot;dir2/prog&quot;).mkdirs();
 451                         copy(TrueExe.path(), &quot;dir1/prog&quot;);
 452                         equal(run(pb).exitValue(), True.exitValue());
 453 
 454                         // Check empty PATH component means current directory.
 455                         //
 456                         // While we&#39;re here, let&#39;s test different kinds of
 457                         // Unix executables, and PATH vs explicit searching.
 458                         new File(&quot;dir1/prog&quot;).delete();
 459                         new File(&quot;dir2/prog&quot;).delete();
 460                         for (String[] command :
 461                                  new String[][] {
 462                                      new String[] {&quot;./prog&quot;},
 463                                      cmd}) {
 464                             pb.command(command);
 465                             File prog = new File(&quot;./prog&quot;);
 466                             // &quot;Normal&quot; binaries
 467                             copy(TrueExe.path(), &quot;./prog&quot;);
 468                             equal(run(pb).exitValue(),
 469                                   True.exitValue());
 470                             copy(FalseExe.path(), &quot;./prog&quot;);
 471                             equal(run(pb).exitValue(),
 472                                   False.exitValue());
 473                             prog.delete();
 474                             // Interpreter scripts with #!
 475                             setFileContents(prog, &quot;#!/bin/true\n&quot;);
 476                             prog.setExecutable(true);
 477                             equal(run(pb).exitValue(),
 478                                   True.exitValue());
 479                             prog.delete();
 480                             setFileContents(prog, &quot;#!/bin/false\n&quot;);
 481                             prog.setExecutable(true);
 482                             equal(run(pb).exitValue(),
 483                                   False.exitValue());
 484                             // Traditional shell scripts without #!
 485                             setFileContents(prog, &quot;exec /bin/true\n&quot;);
 486                             prog.setExecutable(true);
 487                             equal(run(pb).exitValue(),
 488                                   True.exitValue());
 489                             prog.delete();
 490                             setFileContents(prog, &quot;exec /bin/false\n&quot;);
 491                             prog.setExecutable(true);
 492                             equal(run(pb).exitValue(),
 493                                   False.exitValue());
 494                             prog.delete();
 495                         }
 496 
 497                         // Test Unix interpreter scripts
 498                         File dir1Prog = new File(&quot;dir1/prog&quot;);
 499                         dir1Prog.delete();
 500                         pb.command(new String[] {&quot;prog&quot;, &quot;world&quot;});
 501                         setFileContents(dir1Prog, &quot;#!/bin/echo hello\n&quot;);
 502                         checkPermissionDenied(pb);
 503                         dir1Prog.setExecutable(true);
 504                         equal(run(pb).out(), &quot;hello dir1/prog world\n&quot;);
 505                         equal(run(pb).exitValue(), True.exitValue());
 506                         dir1Prog.delete();
 507                         pb.command(cmd);
 508 
 509                         // Test traditional shell scripts without #!
 510                         setFileContents(dir1Prog, &quot;/bin/echo \&quot;$@\&quot;\n&quot;);
 511                         pb.command(new String[] {&quot;prog&quot;, &quot;hello&quot;, &quot;world&quot;});
 512                         checkPermissionDenied(pb);
 513                         dir1Prog.setExecutable(true);
 514                         equal(run(pb).out(), &quot;hello world\n&quot;);
 515                         equal(run(pb).exitValue(), True.exitValue());
 516                         dir1Prog.delete();
 517                         pb.command(cmd);
 518 
 519                         // If prog found on both parent and child&#39;s PATH,
 520                         // parent&#39;s is used.
 521                         new File(&quot;dir1/prog&quot;).delete();
 522                         new File(&quot;dir2/prog&quot;).delete();
 523                         new File(&quot;prog&quot;).delete();
 524                         new File(&quot;dir3&quot;).mkdirs();
 525                         copy(TrueExe.path(), &quot;dir1/prog&quot;);
 526                         copy(FalseExe.path(), &quot;dir3/prog&quot;);
 527                         pb.environment().put(&quot;PATH&quot;,&quot;dir3&quot;);
 528                         equal(run(pb).exitValue(), True.exitValue());
 529                         copy(TrueExe.path(), &quot;dir3/prog&quot;);
 530                         copy(FalseExe.path(), &quot;dir1/prog&quot;);
 531                         equal(run(pb).exitValue(), False.exitValue());
 532 
 533                     } finally {
 534                         // cleanup
 535                         new File(&quot;dir1/prog&quot;).delete();
 536                         new File(&quot;dir2/prog&quot;).delete();
 537                         new File(&quot;dir3/prog&quot;).delete();
 538                         new File(&quot;dir1&quot;).delete();
 539                         new File(&quot;dir2&quot;).delete();
 540                         new File(&quot;dir3&quot;).delete();
 541                         new File(&quot;prog&quot;).delete();
 542                     }
 543                 }
 544 
 545                 if (failed != 0) throw new Error(&quot;PATH search algorithm&quot;);
 546             }
 547             else throw new Error(&quot;JavaChild invocation error&quot;);
 548         }
 549     }
 550 
 551     private static void copy(String src, String dst) throws IOException {
 552         Files.copy(Paths.get(src), Paths.get(dst),
 553                    StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.COPY_ATTRIBUTES);
 554     }
 555 
 556     private static String javaChildOutput(ProcessBuilder pb, String...args) {
 557         List&lt;String&gt; list = new ArrayList&lt;String&gt;(javaChildArgs);
 558         for (String arg : args)
 559             list.add(arg);
 560         pb.command(list);
 561         return commandOutput(pb);
 562     }
 563 
 564     private static String getenvInChild(ProcessBuilder pb) {
 565         return javaChildOutput(pb, &quot;System.getenv()&quot;);
 566     }
 567 
 568     private static String getenvInChild1234(ProcessBuilder pb) {
 569         return javaChildOutput(pb, &quot;System.getenv(\\u1234)&quot;);
 570     }
 571 
 572     private static String getenvInChild(ProcessBuilder pb, String name) {
 573         return javaChildOutput(pb, &quot;System.getenv(String)&quot;, name);
 574     }
 575 
 576     private static String pwdInChild(ProcessBuilder pb) {
 577         return javaChildOutput(pb, &quot;pwd&quot;);
 578     }
 579 
 580     private static final String javaExe =
 581         System.getProperty(&quot;java.home&quot;) +
 582         File.separator + &quot;bin&quot; + File.separator + &quot;java&quot;;
 583 
 584     private static final String classpath =
 585         System.getProperty(&quot;java.class.path&quot;);
 586 
 587     private static final List&lt;String&gt; javaChildArgs =
 588         Arrays.asList(javaExe,
 589                       &quot;-XX:+DisplayVMOutputToStderr&quot;,
 590                       &quot;-classpath&quot;, absolutifyPath(classpath),
 591                       &quot;Basic$JavaChild&quot;);
 592 
 593     private static void testEncoding(String encoding, String tested) {
 594         try {
 595             // If round trip conversion works, should be able to set env vars
 596             // correctly in child.
 597             if (new String(tested.getBytes()).equals(tested)) {
 598                 out.println(&quot;Testing &quot; + encoding + &quot; environment values&quot;);
 599                 ProcessBuilder pb = new ProcessBuilder();
 600                 pb.environment().put(&quot;ASCIINAME&quot;,tested);
 601                 equal(getenvInChild(pb,&quot;ASCIINAME&quot;), tested);
 602             }
 603         } catch (Throwable t) { unexpected(t); }
 604     }
 605 
 606     static class Windows {
 607         public static boolean is() { return is; }
 608         private static final boolean is =
 609             System.getProperty(&quot;os.name&quot;).startsWith(&quot;Windows&quot;);
 610     }
 611 
 612     static class AIX {
 613         public static boolean is() { return is; }
 614         private static final boolean is =
 615             System.getProperty(&quot;os.name&quot;).equals(&quot;AIX&quot;);
 616     }
 617 
 618     static class Unix {
 619         public static boolean is() { return is; }
 620         private static final boolean is =
 621             (! Windows.is() &amp;&amp;
 622              new File(&quot;/bin/sh&quot;).exists() &amp;&amp;
 623              new File(&quot;/bin/true&quot;).exists() &amp;&amp;
 624              new File(&quot;/bin/false&quot;).exists());
 625     }
 626 
 627     static class BusyBox {
 628         public static boolean is() { return is; }
 629         private static final boolean is =
 630             (! Windows.is() &amp;&amp;
 631              new File(&quot;/bin/busybox&quot;).exists());
 632     }
 633 
 634     static class UnicodeOS {
 635         public static boolean is() { return is; }
 636         private static final String osName = System.getProperty(&quot;os.name&quot;);
 637         private static final boolean is =
 638             // MacOS X would probably also qualify
 639             osName.startsWith(&quot;Windows&quot;)   &amp;&amp;
 640             ! osName.startsWith(&quot;Windows 9&quot;) &amp;&amp;
 641             ! osName.equals(&quot;Windows Me&quot;);
 642     }
 643 
 644     static class MacOSX {
 645         public static boolean is() { return is; }
 646         private static final String osName = System.getProperty(&quot;os.name&quot;);
 647         private static final boolean is = osName.contains(&quot;OS X&quot;);
 648     }
 649 
 650     static class True {
 651         public static int exitValue() { return 0; }
 652     }
 653 
 654     private static class False {
 655         public static int exitValue() { return exitValue; }
 656         private static final int exitValue = exitValue0();
 657         private static int exitValue0() {
 658             // /bin/false returns an *unspecified* non-zero number.
 659             try {
 660                 if (! Unix.is())
 661                     return -1;
 662                 else {
 663                     int rc = new ProcessBuilder(&quot;/bin/false&quot;)
 664                         .start().waitFor();
 665                     check(rc != 0);
 666                     return rc;
 667                 }
 668             } catch (Throwable t) { unexpected(t); return -1; }
 669         }
 670     }
 671 
 672     // On alpine linux, /bin/true and /bin/false are just links to /bin/busybox.
 673     // Some tests copy /bin/true and /bin/false to files with a different filename.
 674     // However, copying the busbox executable into a file with a different name
 675     // won&#39;t result in the expected return codes. As workaround, we create
 676     // executable files that can be copied and produce the exepected return
 677     // values. We use this workaround, if we find the busybox executable.
 678 
 679     private static class TrueExe {
 680         public static String path() { return path; }
 681         private static final String path = path0();
 682         private static String path0(){
 683             if (!BusyBox.is()) {
 684                 return &quot;/bin/true&quot;;
 685             }
 686             else {
 687                 File trueExe = new File(&quot;true&quot;);
 688                 setFileContents(trueExe, &quot;#!/bin/true\n&quot;);
 689                 trueExe.setExecutable(true);
 690                 return trueExe.getAbsolutePath();
 691             }
 692         }
 693     }
 694 
 695     private static class FalseExe {
 696         public static String path() { return path; }
 697         private static final String path = path0();
 698         private static String path0(){
 699             if (!BusyBox.is()) {
 700                 return &quot;/bin/false&quot;;
 701             }
 702             else {
 703                 File falseExe = new File(&quot;false&quot;);
 704                 setFileContents(falseExe, &quot;#!/bin/false\n&quot;);
 705                 falseExe.setExecutable(true);
 706                 return falseExe.getAbsolutePath();
 707             }
 708         }
 709     }
 710 
 711     static class EnglishUnix {
 712         private static final Boolean is =
 713             (! Windows.is() &amp;&amp; isEnglish(&quot;LANG&quot;) &amp;&amp; isEnglish(&quot;LC_ALL&quot;));
 714 
 715         private static boolean isEnglish(String envvar) {
 716             String val = getenv(envvar);
 717             return (val == null) || val.matches(&quot;en.*&quot;) || val.matches(&quot;C&quot;);
 718         }
 719 
 720         /** Returns true if we can expect English OS error strings */
 721         static boolean is() { return is; }
 722     }
 723 
 724     static class DelegatingProcess extends Process {
 725         final Process p;
 726 
 727         DelegatingProcess(Process p) {
 728             this.p = p;
 729         }
 730 
 731         @Override
 732         public void destroy() {
 733             p.destroy();
 734         }
 735 
 736         @Override
 737         public int exitValue() {
 738             return p.exitValue();
 739         }
 740 
 741         @Override
 742         public int waitFor() throws InterruptedException {
 743             return p.waitFor();
 744         }
 745 
 746         @Override
 747         public OutputStream getOutputStream() {
 748             return p.getOutputStream();
 749         }
 750 
 751         @Override
 752         public InputStream getInputStream() {
 753             return p.getInputStream();
 754         }
 755 
 756         @Override
 757         public InputStream getErrorStream() {
 758             return p.getErrorStream();
 759         }
 760     }
 761 
 762     private static boolean matches(String str, String regex) {
 763         return Pattern.compile(regex).matcher(str).find();
 764     }
 765 
 766     private static String matchAndExtract(String str, String regex) {
 767         Matcher matcher = Pattern.compile(regex).matcher(str);
 768         if (matcher.find()) {
 769             return matcher.group();
 770         } else {
 771             return &quot;&quot;;
 772         }
 773     }
 774 
 775     /* Only used for Mac OS X --
 776      * Mac OS X (may) add the variable __CF_USER_TEXT_ENCODING to an empty
 777      * environment. The environment variable JAVA_MAIN_CLASS_&lt;pid&gt; may also
 778      * be set in Mac OS X.
 779      * Remove them both from the list of env variables
 780      */
 781     private static String removeMacExpectedVars(String vars) {
 782         // Check for __CF_USER_TEXT_ENCODING
 783         String cleanedVars = vars.replace(&quot;__CF_USER_TEXT_ENCODING=&quot;
 784                                             +cfUserTextEncoding+&quot;,&quot;,&quot;&quot;);
 785         // Check for JAVA_MAIN_CLASS_&lt;pid&gt;
 786         String javaMainClassStr
 787                 = matchAndExtract(cleanedVars,
 788                                     &quot;JAVA_MAIN_CLASS_\\d+=Basic.JavaChild,&quot;);
 789         return cleanedVars.replace(javaMainClassStr,&quot;&quot;);
 790     }
 791 
 792     /* Only used for AIX --
 793      * AIX adds the variable AIXTHREAD_GUARDPAGES=0 to the environment.
 794      * Remove it from the list of env variables
 795      */
 796     private static String removeAixExpectedVars(String vars) {
 797         return vars.replace(&quot;AIXTHREAD_GUARDPAGES=0,&quot;, &quot;&quot;);
 798     }
 799 
 800     private static String sortByLinesWindowsly(String text) {
 801         String[] lines = text.split(&quot;\n&quot;);
 802         Arrays.sort(lines, new WindowsComparator());
 803         StringBuilder sb = new StringBuilder();
 804         for (String line : lines)
 805             sb.append(line).append(&quot;\n&quot;);
 806         return sb.toString();
 807     }
 808 
 809     private static void checkMapSanity(Map&lt;String,String&gt; map) {
 810         try {
 811             Set&lt;String&gt; keySet = map.keySet();
 812             Collection&lt;String&gt; values = map.values();
 813             Set&lt;Map.Entry&lt;String,String&gt;&gt; entrySet = map.entrySet();
 814 
 815             equal(entrySet.size(), keySet.size());
 816             equal(entrySet.size(), values.size());
 817 
 818             StringBuilder s1 = new StringBuilder();
 819             for (Map.Entry&lt;String,String&gt; e : entrySet)
 820                 s1.append(e.getKey() + &quot;=&quot; + e.getValue() + &quot;\n&quot;);
 821 
 822             StringBuilder s2 = new StringBuilder();
 823             for (String var : keySet)
 824                 s2.append(var + &quot;=&quot; + map.get(var) + &quot;\n&quot;);
 825 
 826             equal(s1.toString(), s2.toString());
 827 
 828             Iterator&lt;String&gt; kIter = keySet.iterator();
 829             Iterator&lt;String&gt; vIter = values.iterator();
 830             Iterator&lt;Map.Entry&lt;String,String&gt;&gt; eIter = entrySet.iterator();
 831 
 832             while (eIter.hasNext()) {
 833                 Map.Entry&lt;String,String&gt; entry = eIter.next();
 834                 String key   = kIter.next();
 835                 String value = vIter.next();
 836                 check(entrySet.contains(entry));
 837                 check(keySet.contains(key));
 838                 check(values.contains(value));
 839                 check(map.containsKey(key));
 840                 check(map.containsValue(value));
 841                 equal(entry.getKey(), key);
 842                 equal(entry.getValue(), value);
 843             }
 844             check(!kIter.hasNext() &amp;&amp;
 845                     !vIter.hasNext());
 846 
 847         } catch (Throwable t) { unexpected(t); }
 848     }
 849 
 850     private static void checkMapEquality(Map&lt;String,String&gt; map1,
 851                                          Map&lt;String,String&gt; map2) {
 852         try {
 853             equal(map1.size(), map2.size());
 854             equal(map1.isEmpty(), map2.isEmpty());
 855             for (String key : map1.keySet()) {
 856                 equal(map1.get(key), map2.get(key));
 857                 check(map2.keySet().contains(key));
 858             }
 859             equal(map1, map2);
 860             equal(map2, map1);
 861             equal(map1.entrySet(), map2.entrySet());
 862             equal(map2.entrySet(), map1.entrySet());
 863             equal(map1.keySet(), map2.keySet());
 864             equal(map2.keySet(), map1.keySet());
 865 
 866             equal(map1.hashCode(), map2.hashCode());
 867             equal(map1.entrySet().hashCode(), map2.entrySet().hashCode());
 868             equal(map1.keySet().hashCode(), map2.keySet().hashCode());
 869         } catch (Throwable t) { unexpected(t); }
 870     }
 871 
 872     static void checkRedirects(ProcessBuilder pb,
 873                                Redirect in, Redirect out, Redirect err) {
 874         equal(pb.redirectInput(), in);
 875         equal(pb.redirectOutput(), out);
 876         equal(pb.redirectError(), err);
 877     }
 878 
 879     static void redirectIO(ProcessBuilder pb,
 880                            Redirect in, Redirect out, Redirect err) {
 881         pb.redirectInput(in);
 882         pb.redirectOutput(out);
 883         pb.redirectError(err);
 884     }
 885 
 886     static void setFileContents(File file, String contents) {
 887         try {
 888             Writer w = new FileWriter(file);
 889             w.write(contents);
 890             w.close();
 891         } catch (Throwable t) { unexpected(t); }
 892     }
 893 
 894     static String fileContents(File file) {
 895         try {
 896             Reader r = new FileReader(file);
 897             StringBuilder sb = new StringBuilder();
 898             char[] buffer = new char[1024];
 899             int n;
 900             while ((n = r.read(buffer)) != -1)
 901                 sb.append(buffer,0,n);
 902             r.close();
 903             return new String(sb);
 904         } catch (Throwable t) { unexpected(t); return &quot;&quot;; }
 905     }
 906 
 907     static void testIORedirection() throws Throwable {
 908         final File ifile = new File(&quot;ifile&quot;);
 909         final File ofile = new File(&quot;ofile&quot;);
 910         final File efile = new File(&quot;efile&quot;);
 911         ifile.delete();
 912         ofile.delete();
 913         efile.delete();
 914 
 915         //----------------------------------------------------------------
 916         // Check mutual inequality of different types of Redirect
 917         //----------------------------------------------------------------
 918         Redirect[] redirects =
 919             { PIPE,
 920               INHERIT,
 921               DISCARD,
 922               Redirect.from(ifile),
 923               Redirect.to(ifile),
 924               Redirect.appendTo(ifile),
 925               Redirect.from(ofile),
 926               Redirect.to(ofile),
 927               Redirect.appendTo(ofile),
 928             };
 929         for (int i = 0; i &lt; redirects.length; i++)
 930             for (int j = 0; j &lt; redirects.length; j++)
 931                 equal(redirects[i].equals(redirects[j]), (i == j));
 932 
 933         //----------------------------------------------------------------
 934         // Check basic properties of different types of Redirect
 935         //----------------------------------------------------------------
 936         equal(PIPE.type(), Redirect.Type.PIPE);
 937         equal(PIPE.toString(), &quot;PIPE&quot;);
 938         equal(PIPE.file(), null);
 939 
 940         equal(INHERIT.type(), Redirect.Type.INHERIT);
 941         equal(INHERIT.toString(), &quot;INHERIT&quot;);
 942         equal(INHERIT.file(), null);
 943 
 944         equal(DISCARD.type(), Redirect.Type.WRITE);
 945         equal(DISCARD.toString(), &quot;WRITE&quot;);
 946         equal(DISCARD.file(), new File((Windows.is() ? &quot;NUL&quot; : &quot;/dev/null&quot;)));
 947 
 948         equal(Redirect.from(ifile).type(), Redirect.Type.READ);
 949         equal(Redirect.from(ifile).toString(),
 950               &quot;redirect to read from file \&quot;ifile\&quot;&quot;);
 951         equal(Redirect.from(ifile).file(), ifile);
 952         equal(Redirect.from(ifile),
 953               Redirect.from(ifile));
 954         equal(Redirect.from(ifile).hashCode(),
 955               Redirect.from(ifile).hashCode());
 956 
 957         equal(Redirect.to(ofile).type(), Redirect.Type.WRITE);
 958         equal(Redirect.to(ofile).toString(),
 959               &quot;redirect to write to file \&quot;ofile\&quot;&quot;);
 960         equal(Redirect.to(ofile).file(), ofile);
 961         equal(Redirect.to(ofile),
 962               Redirect.to(ofile));
 963         equal(Redirect.to(ofile).hashCode(),
 964               Redirect.to(ofile).hashCode());
 965 
 966         equal(Redirect.appendTo(ofile).type(), Redirect.Type.APPEND);
 967         equal(Redirect.appendTo(efile).toString(),
 968               &quot;redirect to append to file \&quot;efile\&quot;&quot;);
 969         equal(Redirect.appendTo(efile).file(), efile);
 970         equal(Redirect.appendTo(efile),
 971               Redirect.appendTo(efile));
 972         equal(Redirect.appendTo(efile).hashCode(),
 973               Redirect.appendTo(efile).hashCode());
 974 
 975         //----------------------------------------------------------------
 976         // Check initial values of redirects
 977         //----------------------------------------------------------------
 978         List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
 979         childArgs.add(&quot;testIO&quot;);
 980         final ProcessBuilder pb = new ProcessBuilder(childArgs);
 981         checkRedirects(pb, PIPE, PIPE, PIPE);
 982 
 983         //----------------------------------------------------------------
 984         // Check inheritIO
 985         //----------------------------------------------------------------
 986         pb.inheritIO();
 987         checkRedirects(pb, INHERIT, INHERIT, INHERIT);
 988 
 989         //----------------------------------------------------------------
 990         // Check DISCARD for stdout,stderr
 991         //----------------------------------------------------------------
 992         redirectIO(pb, INHERIT, DISCARD, DISCARD);
 993         checkRedirects(pb, INHERIT, DISCARD, DISCARD);
 994 
 995         //----------------------------------------------------------------
 996         // Check setters and getters agree
 997         //----------------------------------------------------------------
 998         pb.redirectInput(ifile);
 999         equal(pb.redirectInput().file(), ifile);
1000         equal(pb.redirectInput(), Redirect.from(ifile));
1001 
1002         pb.redirectOutput(ofile);
1003         equal(pb.redirectOutput().file(), ofile);
1004         equal(pb.redirectOutput(), Redirect.to(ofile));
1005 
1006         pb.redirectError(efile);
1007         equal(pb.redirectError().file(), efile);
1008         equal(pb.redirectError(), Redirect.to(efile));
1009 
1010         THROWS(IllegalArgumentException.class,
1011                () -&gt; pb.redirectInput(Redirect.to(ofile)),
1012                () -&gt; pb.redirectOutput(Redirect.from(ifile)),
1013                () -&gt; pb.redirectError(Redirect.from(ifile)),
1014                () -&gt; pb.redirectInput(DISCARD));
1015 
1016         THROWS(NullPointerException.class,
1017                 () -&gt; pb.redirectInput((File)null),
1018                 () -&gt; pb.redirectOutput((File)null),
1019                 () -&gt; pb.redirectError((File)null),
1020                 () -&gt; pb.redirectInput((Redirect)null),
1021                 () -&gt; pb.redirectOutput((Redirect)null),
1022                 () -&gt; pb.redirectError((Redirect)null));
1023 
1024         THROWS(IOException.class,
1025                // Input file does not exist
1026                () -&gt; pb.start());
1027         setFileContents(ifile, &quot;standard input&quot;);
1028 
1029         //----------------------------------------------------------------
1030         // Writing to non-existent files
1031         //----------------------------------------------------------------
1032         {
1033             ProcessResults r = run(pb);
1034             equal(r.exitValue(), 0);
1035             equal(fileContents(ofile), &quot;standard output&quot;);
1036             equal(fileContents(efile), &quot;standard error&quot;);
1037             equal(r.out(), &quot;&quot;);
1038             equal(r.err(), &quot;&quot;);
1039             ofile.delete();
1040             efile.delete();
1041         }
1042 
1043         //----------------------------------------------------------------
1044         // Both redirectErrorStream + redirectError
1045         //----------------------------------------------------------------
1046         {
1047             pb.redirectErrorStream(true);
1048             ProcessResults r = run(pb);
1049             equal(r.exitValue(), 0);
1050             equal(fileContents(ofile),
1051                     &quot;standard error&quot; + &quot;standard output&quot;);
1052             equal(fileContents(efile), &quot;&quot;);
1053             equal(r.out(), &quot;&quot;);
1054             equal(r.err(), &quot;&quot;);
1055             ofile.delete();
1056             efile.delete();
1057         }
1058 
1059         //----------------------------------------------------------------
1060         // Appending to existing files
1061         //----------------------------------------------------------------
1062         {
1063             setFileContents(ofile, &quot;ofile-contents&quot;);
1064             setFileContents(efile, &quot;efile-contents&quot;);
1065             pb.redirectOutput(Redirect.appendTo(ofile));
1066             pb.redirectError(Redirect.appendTo(efile));
1067             pb.redirectErrorStream(false);
1068             ProcessResults r = run(pb);
1069             equal(r.exitValue(), 0);
1070             equal(fileContents(ofile),
1071                   &quot;ofile-contents&quot; + &quot;standard output&quot;);
1072             equal(fileContents(efile),
1073                   &quot;efile-contents&quot; + &quot;standard error&quot;);
1074             equal(r.out(), &quot;&quot;);
1075             equal(r.err(), &quot;&quot;);
1076             ofile.delete();
1077             efile.delete();
1078         }
1079 
1080         //----------------------------------------------------------------
1081         // Replacing existing files
1082         //----------------------------------------------------------------
1083         {
1084             setFileContents(ofile, &quot;ofile-contents&quot;);
1085             setFileContents(efile, &quot;efile-contents&quot;);
1086             pb.redirectOutput(ofile);
1087             pb.redirectError(Redirect.to(efile));
1088             ProcessResults r = run(pb);
1089             equal(r.exitValue(), 0);
1090             equal(fileContents(ofile), &quot;standard output&quot;);
1091             equal(fileContents(efile), &quot;standard error&quot;);
1092             equal(r.out(), &quot;&quot;);
1093             equal(r.err(), &quot;&quot;);
1094             ofile.delete();
1095             efile.delete();
1096         }
1097 
1098         //----------------------------------------------------------------
1099         // Appending twice to the same file?
1100         //----------------------------------------------------------------
1101         {
1102             setFileContents(ofile, &quot;ofile-contents&quot;);
1103             setFileContents(efile, &quot;efile-contents&quot;);
1104             Redirect appender = Redirect.appendTo(ofile);
1105             pb.redirectOutput(appender);
1106             pb.redirectError(appender);
1107             ProcessResults r = run(pb);
1108             equal(r.exitValue(), 0);
1109             equal(fileContents(ofile),
1110                   &quot;ofile-contents&quot; +
1111                   &quot;standard error&quot; +
1112                   &quot;standard output&quot;);
1113             equal(fileContents(efile), &quot;efile-contents&quot;);
1114             equal(r.out(), &quot;&quot;);
1115             equal(r.err(), &quot;&quot;);
1116             ifile.delete();
1117             ofile.delete();
1118             efile.delete();
1119         }
1120 
1121         //----------------------------------------------------------------
1122         // DISCARDing output
1123         //----------------------------------------------------------------
1124         {
1125             setFileContents(ifile, &quot;standard input&quot;);
1126             pb.redirectOutput(DISCARD);
1127             pb.redirectError(DISCARD);
1128             ProcessResults r = run(pb);
1129             equal(r.exitValue(), 0);
1130             equal(r.out(), &quot;&quot;);
1131             equal(r.err(), &quot;&quot;);
1132         }
1133 
1134         //----------------------------------------------------------------
1135         // DISCARDing output and redirecting error
1136         //----------------------------------------------------------------
1137         {
1138             setFileContents(ifile, &quot;standard input&quot;);
1139             setFileContents(ofile, &quot;ofile-contents&quot;);
1140             setFileContents(efile, &quot;efile-contents&quot;);
1141             pb.redirectOutput(DISCARD);
1142             pb.redirectError(efile);
1143             ProcessResults r = run(pb);
1144             equal(r.exitValue(), 0);
1145             equal(fileContents(ofile), &quot;ofile-contents&quot;);
1146             equal(fileContents(efile), &quot;standard error&quot;);
1147             equal(r.out(), &quot;&quot;);
1148             equal(r.err(), &quot;&quot;);
1149             ofile.delete();
1150             efile.delete();
1151         }
1152 
1153         //----------------------------------------------------------------
1154         // DISCARDing error and redirecting output
1155         //----------------------------------------------------------------
1156         {
1157             setFileContents(ifile, &quot;standard input&quot;);
1158             setFileContents(ofile, &quot;ofile-contents&quot;);
1159             setFileContents(efile, &quot;efile-contents&quot;);
1160             pb.redirectOutput(ofile);
1161             pb.redirectError(DISCARD);
1162             ProcessResults r = run(pb);
1163             equal(r.exitValue(), 0);
1164             equal(fileContents(ofile), &quot;standard output&quot;);
1165             equal(fileContents(efile), &quot;efile-contents&quot;);
1166             equal(r.out(), &quot;&quot;);
1167             equal(r.err(), &quot;&quot;);
1168             ofile.delete();
1169             efile.delete();
1170         }
1171 
1172         //----------------------------------------------------------------
1173         // DISCARDing output and merging error into output
1174         //----------------------------------------------------------------
1175         {
1176             setFileContents(ifile, &quot;standard input&quot;);
1177             setFileContents(ofile, &quot;ofile-contents&quot;);
1178             setFileContents(efile, &quot;efile-contents&quot;);
1179             pb.redirectOutput(DISCARD);
1180             pb.redirectErrorStream(true);
1181             pb.redirectError(efile);
1182             ProcessResults r = run(pb);
1183             equal(r.exitValue(), 0);
1184             equal(fileContents(ofile), &quot;ofile-contents&quot;);   // untouched
1185             equal(fileContents(efile), &quot;&quot;);                 // empty
1186             equal(r.out(), &quot;&quot;);
1187             equal(r.err(), &quot;&quot;);
1188             ifile.delete();
1189             ofile.delete();
1190             efile.delete();
1191             pb.redirectErrorStream(false);                  // reset for next test
1192         }
1193 
1194         //----------------------------------------------------------------
1195         // Testing INHERIT is harder.
1196         // Note that this requires __FOUR__ nested JVMs involved in one test,
1197         // if you count the harness JVM.
1198         //----------------------------------------------------------------
1199         for (String testName : new String[] { &quot;testInheritIO&quot;, &quot;testRedirectInherit&quot; } ) {
1200             redirectIO(pb, PIPE, PIPE, PIPE);
1201             List&lt;String&gt; command = pb.command();
1202             command.set(command.size() - 1, testName);
1203             Process p = pb.start();
1204             new PrintStream(p.getOutputStream()).print(&quot;standard input&quot;);
1205             p.getOutputStream().close();
1206             ProcessResults r = run(p);
1207             equal(r.exitValue(), 0);
1208             equal(r.out(), &quot;standard output&quot;);
1209             equal(r.err(), &quot;standard error&quot;);
1210         }
1211 
1212         //----------------------------------------------------------------
1213         // Test security implications of I/O redirection
1214         //----------------------------------------------------------------
1215 
1216         // Read access to current directory is always granted;
1217         // So create a tmpfile for input instead.
1218         final File tmpFile = File.createTempFile(&quot;Basic&quot;, &quot;tmp&quot;);
1219         setFileContents(tmpFile, &quot;standard input&quot;);
1220 
1221         final Policy policy = new Policy();
1222         Policy.setPolicy(policy);
1223         System.setSecurityManager(new SecurityManager());
1224         try {
1225             final Permission xPermission
1226                 = new FilePermission(&quot;&lt;&lt;ALL FILES&gt;&gt;&quot;, &quot;execute&quot;);
1227             final Permission rxPermission
1228                 = new FilePermission(&quot;&lt;&lt;ALL FILES&gt;&gt;&quot;, &quot;read,execute&quot;);
1229             final Permission wxPermission
1230                 = new FilePermission(&quot;&lt;&lt;ALL FILES&gt;&gt;&quot;, &quot;write,execute&quot;);
1231             final Permission rwxPermission
1232                 = new FilePermission(&quot;&lt;&lt;ALL FILES&gt;&gt;&quot;, &quot;read,write,execute&quot;);
1233 
1234             THROWS(SecurityException.class,
1235                    () -&gt; { policy.setPermissions(xPermission);
1236                            redirectIO(pb, from(tmpFile), PIPE, PIPE);
1237                            pb.start();},
1238                    () -&gt; { policy.setPermissions(rxPermission);
1239                            redirectIO(pb, PIPE, to(ofile), PIPE);
1240                            pb.start();},
1241                    () -&gt; { policy.setPermissions(rxPermission);
1242                            redirectIO(pb, PIPE, PIPE, to(efile));
1243                            pb.start();});
1244 
1245             {
1246                 policy.setPermissions(rxPermission);
1247                 redirectIO(pb, from(tmpFile), PIPE, PIPE);
1248                 ProcessResults r = run(pb);
1249                 equal(r.out(), &quot;standard output&quot;);
1250                 equal(r.err(), &quot;standard error&quot;);
1251             }
1252 
1253             {
1254                 policy.setPermissions(wxPermission);
1255                 redirectIO(pb, PIPE, to(ofile), to(efile));
1256                 Process p = pb.start();
1257                 new PrintStream(p.getOutputStream()).print(&quot;standard input&quot;);
1258                 p.getOutputStream().close();
1259                 ProcessResults r = run(p);
1260                 policy.setPermissions(rwxPermission);
1261                 equal(fileContents(ofile), &quot;standard output&quot;);
1262                 equal(fileContents(efile), &quot;standard error&quot;);
1263             }
1264 
1265             {
1266                 policy.setPermissions(rwxPermission);
1267                 redirectIO(pb, from(tmpFile), to(ofile), to(efile));
1268                 ProcessResults r = run(pb);
1269                 policy.setPermissions(rwxPermission);
1270                 equal(fileContents(ofile), &quot;standard output&quot;);
1271                 equal(fileContents(efile), &quot;standard error&quot;);
1272             }
1273 
1274         } finally {
1275             policy.setPermissions(new RuntimePermission(&quot;setSecurityManager&quot;));
1276             System.setSecurityManager(null);
1277             tmpFile.delete();
1278             ifile.delete();
1279             ofile.delete();
1280             efile.delete();
1281         }
1282     }
1283 
1284     static void checkProcessPid() {
1285         ProcessBuilder pb = new ProcessBuilder();
1286         List&lt;String&gt; list = new ArrayList&lt;String&gt;(javaChildArgs);
1287         list.add(&quot;pid&quot;);
1288         pb.command(list);
1289         try {
1290             Process p = pb.start();
1291             String s = commandOutput(p);
1292             long actualPid = Long.valueOf(s.trim());
1293             long expectedPid = p.pid();
1294             equal(actualPid, expectedPid);
1295         } catch (Throwable t) {
1296             unexpected(t);
1297         }
1298 
1299 
1300         // Test the default implementation of Process.getPid
1301         DelegatingProcess p = new DelegatingProcess(null);
1302         THROWS(UnsupportedOperationException.class,
1303                 () -&gt; p.pid(),
1304                 () -&gt; p.toHandle(),
1305                 () -&gt; p.supportsNormalTermination(),
1306                 () -&gt; p.children(),
1307                 () -&gt; p.descendants());
1308 
1309     }
1310 
1311     private static void realMain(String[] args) throws Throwable {
1312         if (Windows.is())
1313             System.out.println(&quot;This appears to be a Windows system.&quot;);
1314         if (Unix.is())
1315             System.out.println(&quot;This appears to be a Unix system.&quot;);
1316         if (UnicodeOS.is())
1317             System.out.println(&quot;This appears to be a Unicode-based OS.&quot;);
1318 
1319         try { testIORedirection(); }
1320         catch (Throwable t) { unexpected(t); }
1321 
1322         //----------------------------------------------------------------
1323         // Basic tests for getPid()
1324         //----------------------------------------------------------------
1325         checkProcessPid();
1326 
1327         //----------------------------------------------------------------
1328         // Basic tests for setting, replacing and deleting envvars
1329         //----------------------------------------------------------------
1330         try {
1331             ProcessBuilder pb = new ProcessBuilder();
1332             Map&lt;String,String&gt; environ = pb.environment();
1333 
1334             // New env var
1335             environ.put(&quot;QUUX&quot;, &quot;BAR&quot;);
1336             equal(environ.get(&quot;QUUX&quot;), &quot;BAR&quot;);
1337             equal(getenvInChild(pb,&quot;QUUX&quot;), &quot;BAR&quot;);
1338 
1339             // Modify env var
1340             environ.put(&quot;QUUX&quot;,&quot;bear&quot;);
1341             equal(environ.get(&quot;QUUX&quot;), &quot;bear&quot;);
1342             equal(getenvInChild(pb,&quot;QUUX&quot;), &quot;bear&quot;);
1343             checkMapSanity(environ);
1344 
1345             // Remove env var
1346             environ.remove(&quot;QUUX&quot;);
1347             equal(environ.get(&quot;QUUX&quot;), null);
1348             equal(getenvInChild(pb,&quot;QUUX&quot;), &quot;null&quot;);
1349             checkMapSanity(environ);
1350 
1351             // Remove non-existent env var
1352             environ.remove(&quot;QUUX&quot;);
1353             equal(environ.get(&quot;QUUX&quot;), null);
1354             equal(getenvInChild(pb,&quot;QUUX&quot;), &quot;null&quot;);
1355             checkMapSanity(environ);
1356         } catch (Throwable t) { unexpected(t); }
1357 
1358         //----------------------------------------------------------------
1359         // Pass Empty environment to child
1360         //----------------------------------------------------------------
1361         try {
1362             ProcessBuilder pb = new ProcessBuilder();
1363             pb.environment().clear();
1364             String expected = Windows.is() ? &quot;SystemRoot=&quot;+systemRoot+&quot;,&quot;: &quot;&quot;;
1365             expected = AIX.is() ? &quot;LIBPATH=&quot;+libpath+&quot;,&quot;: expected;
1366             if (Windows.is()) {
1367                 pb.environment().put(&quot;SystemRoot&quot;, systemRoot);
1368             }
1369             if (AIX.is()) {
1370                 pb.environment().put(&quot;LIBPATH&quot;, libpath);
1371             }
1372             String result = getenvInChild(pb);
1373             if (MacOSX.is()) {
1374                 result = removeMacExpectedVars(result);
1375             }
1376             if (AIX.is()) {
1377                 result = removeAixExpectedVars(result);
1378             }
1379             equal(result, expected);
1380         } catch (Throwable t) { unexpected(t); }
1381 
1382         //----------------------------------------------------------------
1383         // System.getenv() is read-only.
1384         //----------------------------------------------------------------
1385         THROWS(UnsupportedOperationException.class,
1386                () -&gt; getenv().put(&quot;FOO&quot;,&quot;BAR&quot;),
1387                () -&gt; getenv().remove(&quot;PATH&quot;),
1388                () -&gt; getenv().keySet().remove(&quot;PATH&quot;),
1389                () -&gt; getenv().values().remove(&quot;someValue&quot;));
1390 
1391         try {
1392             Collection&lt;Map.Entry&lt;String,String&gt;&gt; c = getenv().entrySet();
1393             if (! c.isEmpty())
1394                 try {
1395                     c.iterator().next().setValue(&quot;foo&quot;);
1396                     fail(&quot;Expected UnsupportedOperationException not thrown&quot;);
1397                 } catch (UnsupportedOperationException e) {} // OK
1398         } catch (Throwable t) { unexpected(t); }
1399 
1400         //----------------------------------------------------------------
1401         // System.getenv() always returns the same object in our implementation.
1402         //----------------------------------------------------------------
1403         try {
1404             check(System.getenv() == System.getenv());
1405         } catch (Throwable t) { unexpected(t); }
1406 
1407         //----------------------------------------------------------------
1408         // You can&#39;t create an env var name containing &quot;=&quot;,
1409         // or an env var name or value containing NUL.
1410         //----------------------------------------------------------------
1411         {
1412             final Map&lt;String,String&gt; m = new ProcessBuilder().environment();
1413             THROWS(IllegalArgumentException.class,
1414                    () -&gt; m.put(&quot;FOO=&quot;,&quot;BAR&quot;),
1415                    () -&gt; m.put(&quot;FOO\u0000&quot;,&quot;BAR&quot;),
1416                    () -&gt; m.put(&quot;FOO&quot;,&quot;BAR\u0000&quot;));
1417         }
1418 
1419         //----------------------------------------------------------------
1420         // Commands must never be null.
1421         //----------------------------------------------------------------
1422         THROWS(NullPointerException.class,
1423                () -&gt; new ProcessBuilder((List&lt;String&gt;)null),
1424                () -&gt; new ProcessBuilder().command((List&lt;String&gt;)null));
1425 
1426         //----------------------------------------------------------------
1427         // Put in a command; get the same one back out.
1428         //----------------------------------------------------------------
1429         try {
1430             List&lt;String&gt; command = new ArrayList&lt;String&gt;();
1431             ProcessBuilder pb = new ProcessBuilder(command);
1432             check(pb.command() == command);
1433             List&lt;String&gt; command2 = new ArrayList&lt;String&gt;(2);
1434             command2.add(&quot;foo&quot;);
1435             command2.add(&quot;bar&quot;);
1436             pb.command(command2);
1437             check(pb.command() == command2);
1438             pb.command(&quot;foo&quot;, &quot;bar&quot;);
1439             check(pb.command() != command2 &amp;&amp; pb.command().equals(command2));
1440             pb.command(command2);
1441             command2.add(&quot;baz&quot;);
1442             equal(pb.command().get(2), &quot;baz&quot;);
1443         } catch (Throwable t) { unexpected(t); }
1444 
1445         //----------------------------------------------------------------
1446         // Commands must contain at least one element.
1447         //----------------------------------------------------------------
1448         THROWS(IndexOutOfBoundsException.class,
1449                () -&gt; new ProcessBuilder().start(),
1450                () -&gt; new ProcessBuilder(new ArrayList&lt;String&gt;()).start(),
1451                () -&gt; Runtime.getRuntime().exec(new String[]{}));
1452 
1453         //----------------------------------------------------------------
1454         // Commands must not contain null elements at start() time.
1455         //----------------------------------------------------------------
1456         THROWS(NullPointerException.class,
1457                () -&gt; new ProcessBuilder(&quot;foo&quot;,null,&quot;bar&quot;).start(),
1458                () -&gt; new ProcessBuilder((String)null).start(),
1459                () -&gt; new ProcessBuilder(new String[]{null}).start(),
1460                () -&gt; new ProcessBuilder(new String[]{&quot;foo&quot;,null,&quot;bar&quot;}).start());
1461 
1462         //----------------------------------------------------------------
1463         // Command lists are growable.
1464         //----------------------------------------------------------------
1465         try {
1466             new ProcessBuilder().command().add(&quot;foo&quot;);
1467             new ProcessBuilder(&quot;bar&quot;).command().add(&quot;foo&quot;);
1468             new ProcessBuilder(new String[]{&quot;1&quot;,&quot;2&quot;}).command().add(&quot;3&quot;);
1469         } catch (Throwable t) { unexpected(t); }
1470 
1471         //----------------------------------------------------------------
1472         // Nulls in environment updates generate NullPointerException
1473         //----------------------------------------------------------------
1474         try {
1475             final Map&lt;String,String&gt; env = new ProcessBuilder().environment();
1476             THROWS(NullPointerException.class,
1477                    () -&gt; env.put(&quot;foo&quot;,null),
1478                    () -&gt; env.put(null,&quot;foo&quot;),
1479                    () -&gt; env.remove(null),
1480                    () -&gt; { for (Map.Entry&lt;String,String&gt; e : env.entrySet())
1481                                e.setValue(null);},
1482                    () -&gt; Runtime.getRuntime().exec(new String[]{&quot;foo&quot;},
1483                                                    new String[]{null}));
1484         } catch (Throwable t) { unexpected(t); }
1485 
1486         //----------------------------------------------------------------
1487         // Non-String types in environment updates generate ClassCastException
1488         //----------------------------------------------------------------
1489         try {
1490             final Map&lt;String,String&gt; env = new ProcessBuilder().environment();
1491             THROWS(ClassCastException.class,
1492                    () -&gt; env.remove(TRUE),
1493                    () -&gt; env.keySet().remove(TRUE),
1494                    () -&gt; env.values().remove(TRUE),
1495                    () -&gt; env.entrySet().remove(TRUE));
1496         } catch (Throwable t) { unexpected(t); }
1497 
1498         //----------------------------------------------------------------
1499         // Check query operations on environment maps
1500         //----------------------------------------------------------------
1501         try {
1502             List&lt;Map&lt;String,String&gt;&gt; envs =
1503                 new ArrayList&lt;Map&lt;String,String&gt;&gt;(2);
1504             envs.add(System.getenv());
1505             envs.add(new ProcessBuilder().environment());
1506             for (final Map&lt;String,String&gt; env : envs) {
1507                 //----------------------------------------------------------------
1508                 // Nulls in environment queries are forbidden.
1509                 //----------------------------------------------------------------
1510                 THROWS(NullPointerException.class,
1511                        () -&gt; getenv(null),
1512                        () -&gt; env.get(null),
1513                        () -&gt; env.containsKey(null),
1514                        () -&gt; env.containsValue(null),
1515                        () -&gt; env.keySet().contains(null),
1516                        () -&gt; env.values().contains(null));
1517 
1518                 //----------------------------------------------------------------
1519                 // Non-String types in environment queries are forbidden.
1520                 //----------------------------------------------------------------
1521                 THROWS(ClassCastException.class,
1522                        () -&gt; env.get(TRUE),
1523                        () -&gt; env.containsKey(TRUE),
1524                        () -&gt; env.containsValue(TRUE),
1525                        () -&gt; env.keySet().contains(TRUE),
1526                        () -&gt; env.values().contains(TRUE));
1527 
1528                 //----------------------------------------------------------------
1529                 // Illegal String values in environment queries are (grumble) OK
1530                 //----------------------------------------------------------------
1531                 equal(env.get(&quot;\u0000&quot;), null);
1532                 check(! env.containsKey(&quot;\u0000&quot;));
1533                 check(! env.containsValue(&quot;\u0000&quot;));
1534                 check(! env.keySet().contains(&quot;\u0000&quot;));
1535                 check(! env.values().contains(&quot;\u0000&quot;));
1536             }
1537 
1538         } catch (Throwable t) { unexpected(t); }
1539 
1540         try {
1541             final Set&lt;Map.Entry&lt;String,String&gt;&gt; entrySet =
1542                 new ProcessBuilder().environment().entrySet();
1543             THROWS(NullPointerException.class,
1544                    () -&gt; entrySet.contains(null));
1545             THROWS(ClassCastException.class,
1546                    () -&gt; entrySet.contains(TRUE),
1547                    () -&gt; entrySet.contains(
1548                              new SimpleImmutableEntry&lt;Boolean,String&gt;(TRUE,&quot;&quot;)));
1549 
1550             check(! entrySet.contains
1551                   (new SimpleImmutableEntry&lt;String,String&gt;(&quot;&quot;, &quot;&quot;)));
1552         } catch (Throwable t) { unexpected(t); }
1553 
1554         //----------------------------------------------------------------
1555         // Put in a directory; get the same one back out.
1556         //----------------------------------------------------------------
1557         try {
1558             ProcessBuilder pb = new ProcessBuilder();
1559             File foo = new File(&quot;foo&quot;);
1560             equal(pb.directory(), null);
1561             equal(pb.directory(foo).directory(), foo);
1562             equal(pb.directory(null).directory(), null);
1563         } catch (Throwable t) { unexpected(t); }
1564 
1565         //----------------------------------------------------------------
1566         // If round-trip conversion works, check envvar pass-through to child
1567         //----------------------------------------------------------------
1568         try {
1569             testEncoding(&quot;ASCII&quot;,   &quot;xyzzy&quot;);
1570             testEncoding(&quot;Latin1&quot;,  &quot;\u00f1\u00e1&quot;);
1571             testEncoding(&quot;Unicode&quot;, &quot;\u22f1\u11e1&quot;);
1572         } catch (Throwable t) { unexpected(t); }
1573 
1574         //----------------------------------------------------------------
1575         // A surprisingly large number of ways to delete an environment var.
1576         //----------------------------------------------------------------
1577         testVariableDeleter(new EnvironmentFrobber() {
1578                 public void doIt(Map&lt;String,String&gt; environ) {
1579                     environ.remove(&quot;Foo&quot;);}});
1580 
1581         testVariableDeleter(new EnvironmentFrobber() {
1582                 public void doIt(Map&lt;String,String&gt; environ) {
1583                     environ.keySet().remove(&quot;Foo&quot;);}});
1584 
1585         testVariableDeleter(new EnvironmentFrobber() {
1586                 public void doIt(Map&lt;String,String&gt; environ) {
1587                     environ.values().remove(&quot;BAAR&quot;);}});
1588 
1589         testVariableDeleter(new EnvironmentFrobber() {
1590                 public void doIt(Map&lt;String,String&gt; environ) {
1591                     // Legally fabricate a ProcessEnvironment.StringEntry,
1592                     // even though it&#39;s private.
1593                     Map&lt;String,String&gt; environ2
1594                         = new ProcessBuilder().environment();
1595                     environ2.clear();
1596                     environ2.put(&quot;Foo&quot;,&quot;BAAR&quot;);
1597                     // Subtlety alert.
1598                     Map.Entry&lt;String,String&gt; e
1599                         = environ2.entrySet().iterator().next();
1600                     environ.entrySet().remove(e);}});
1601 
1602         testVariableDeleter(new EnvironmentFrobber() {
1603                 public void doIt(Map&lt;String,String&gt; environ) {
1604                     Map.Entry&lt;String,String&gt; victim = null;
1605                     for (Map.Entry&lt;String,String&gt; e : environ.entrySet())
1606                         if (e.getKey().equals(&quot;Foo&quot;))
1607                             victim = e;
1608                     if (victim != null)
1609                         environ.entrySet().remove(victim);}});
1610 
1611         testVariableDeleter(new EnvironmentFrobber() {
1612                 public void doIt(Map&lt;String,String&gt; environ) {
1613                     Iterator&lt;String&gt; it = environ.keySet().iterator();
1614                     while (it.hasNext()) {
1615                         String val = it.next();
1616                         if (val.equals(&quot;Foo&quot;))
1617                             it.remove();}}});
1618 
1619         testVariableDeleter(new EnvironmentFrobber() {
1620                 public void doIt(Map&lt;String,String&gt; environ) {
1621                     Iterator&lt;Map.Entry&lt;String,String&gt;&gt; it
1622                         = environ.entrySet().iterator();
1623                     while (it.hasNext()) {
1624                         Map.Entry&lt;String,String&gt; e = it.next();
1625                         if (e.getKey().equals(&quot;Foo&quot;))
1626                             it.remove();}}});
1627 
1628         testVariableDeleter(new EnvironmentFrobber() {
1629                 public void doIt(Map&lt;String,String&gt; environ) {
1630                     Iterator&lt;String&gt; it = environ.values().iterator();
1631                     while (it.hasNext()) {
1632                         String val = it.next();
1633                         if (val.equals(&quot;BAAR&quot;))
1634                             it.remove();}}});
1635 
1636         //----------------------------------------------------------------
1637         // A surprisingly small number of ways to add an environment var.
1638         //----------------------------------------------------------------
1639         testVariableAdder(new EnvironmentFrobber() {
1640                 public void doIt(Map&lt;String,String&gt; environ) {
1641                     environ.put(&quot;Foo&quot;,&quot;Bahrein&quot;);}});
1642 
1643         //----------------------------------------------------------------
1644         // A few ways to modify an environment var.
1645         //----------------------------------------------------------------
1646         testVariableModifier(new EnvironmentFrobber() {
1647                 public void doIt(Map&lt;String,String&gt; environ) {
1648                     environ.put(&quot;Foo&quot;,&quot;NewValue&quot;);}});
1649 
1650         testVariableModifier(new EnvironmentFrobber() {
1651                 public void doIt(Map&lt;String,String&gt; environ) {
1652                     for (Map.Entry&lt;String,String&gt; e : environ.entrySet())
1653                         if (e.getKey().equals(&quot;Foo&quot;))
1654                             e.setValue(&quot;NewValue&quot;);}});
1655 
1656         //----------------------------------------------------------------
1657         // Fiddle with environment sizes
1658         //----------------------------------------------------------------
1659         try {
1660             Map&lt;String,String&gt; environ = new ProcessBuilder().environment();
1661             int size = environ.size();
1662             checkSizes(environ, size);
1663 
1664             environ.put(&quot;UnLiKeLYeNVIROmtNam&quot;, &quot;someVal&quot;);
1665             checkSizes(environ, size+1);
1666 
1667             // Check for environment independence
1668             new ProcessBuilder().environment().clear();
1669 
1670             environ.put(&quot;UnLiKeLYeNVIROmtNam&quot;, &quot;someOtherVal&quot;);
1671             checkSizes(environ, size+1);
1672 
1673             environ.remove(&quot;UnLiKeLYeNVIROmtNam&quot;);
1674             checkSizes(environ, size);
1675 
1676             environ.clear();
1677             checkSizes(environ, 0);
1678 
1679             environ.clear();
1680             checkSizes(environ, 0);
1681 
1682             environ = new ProcessBuilder().environment();
1683             environ.keySet().clear();
1684             checkSizes(environ, 0);
1685 
1686             environ = new ProcessBuilder().environment();
1687             environ.entrySet().clear();
1688             checkSizes(environ, 0);
1689 
1690             environ = new ProcessBuilder().environment();
1691             environ.values().clear();
1692             checkSizes(environ, 0);
1693         } catch (Throwable t) { unexpected(t); }
1694 
1695         //----------------------------------------------------------------
1696         // Check that various map invariants hold
1697         //----------------------------------------------------------------
1698         checkMapSanity(new ProcessBuilder().environment());
1699         checkMapSanity(System.getenv());
1700         checkMapEquality(new ProcessBuilder().environment(),
1701                          new ProcessBuilder().environment());
1702 
1703 
1704         //----------------------------------------------------------------
1705         // Check effects on external &quot;env&quot; command.
1706         //----------------------------------------------------------------
1707         try {
1708             Set&lt;String&gt; env1 = new HashSet&lt;String&gt;
1709                 (Arrays.asList(nativeEnv((String[])null).split(&quot;\n&quot;)));
1710 
1711             ProcessBuilder pb = new ProcessBuilder();
1712             pb.environment().put(&quot;QwErTyUiOp&quot;,&quot;AsDfGhJk&quot;);
1713 
1714             Set&lt;String&gt; env2 = new HashSet&lt;String&gt;
1715                 (Arrays.asList(nativeEnv(pb).split(&quot;\n&quot;)));
1716 
1717             check(env2.size() == env1.size() + 1);
1718             env1.add(&quot;QwErTyUiOp=AsDfGhJk&quot;);
1719             check(env1.equals(env2));
1720         } catch (Throwable t) { unexpected(t); }
1721 
1722         //----------------------------------------------------------------
1723         // Test Runtime.exec(...envp...)
1724         // Check for sort order of environment variables on Windows.
1725         //----------------------------------------------------------------
1726         try {
1727             String systemRoot = &quot;SystemRoot=&quot; + System.getenv(&quot;SystemRoot&quot;);
1728             // &#39;+&#39; &lt; &#39;A&#39; &lt; &#39;Z&#39; &lt; &#39;_&#39; &lt; &#39;a&#39; &lt; &#39;z&#39; &lt; &#39;~&#39;
1729             String[]envp = {&quot;FOO=BAR&quot;,&quot;BAZ=GORP&quot;,&quot;QUUX=&quot;,
1730                             &quot;+=+&quot;, &quot;_=_&quot;, &quot;~=~&quot;, systemRoot};
1731             String output = nativeEnv(envp);
1732             String expected = &quot;+=+\nBAZ=GORP\nFOO=BAR\nQUUX=\n&quot;+systemRoot+&quot;\n_=_\n~=~\n&quot;;
1733             // On Windows, Java must keep the environment sorted.
1734             // Order is random on Unix, so this test does the sort.
1735             if (! Windows.is())
1736                 output = sortByLinesWindowsly(output);
1737             equal(output, expected);
1738         } catch (Throwable t) { unexpected(t); }
1739 
1740         //----------------------------------------------------------------
1741         // Test Runtime.exec(...envp...)
1742         // and check SystemRoot gets set automatically on Windows
1743         //----------------------------------------------------------------
1744         try {
1745             if (Windows.is()) {
1746                 String systemRoot = &quot;SystemRoot=&quot; + System.getenv(&quot;SystemRoot&quot;);
1747                 String[]envp = {&quot;FOO=BAR&quot;,&quot;BAZ=GORP&quot;,&quot;QUUX=&quot;,
1748                                 &quot;+=+&quot;, &quot;_=_&quot;, &quot;~=~&quot;};
1749                 String output = nativeEnv(envp);
1750                 String expected = &quot;+=+\nBAZ=GORP\nFOO=BAR\nQUUX=\n&quot;+systemRoot+&quot;\n_=_\n~=~\n&quot;;
1751                 equal(output, expected);
1752             }
1753         } catch (Throwable t) { unexpected(t); }
1754 
1755         //----------------------------------------------------------------
1756         // System.getenv() must be consistent with System.getenv(String)
1757         //----------------------------------------------------------------
1758         try {
1759             for (Map.Entry&lt;String,String&gt; e : getenv().entrySet())
1760                 equal(getenv(e.getKey()), e.getValue());
1761         } catch (Throwable t) { unexpected(t); }
1762 
1763         //----------------------------------------------------------------
1764         // Fiddle with working directory in child
1765         //----------------------------------------------------------------
1766         try {
1767             String canonicalUserDir =
1768                 new File(System.getProperty(&quot;user.dir&quot;)).getCanonicalPath();
1769             String[] sdirs = new String[]
1770                 {&quot;.&quot;, &quot;..&quot;, &quot;/&quot;, &quot;/bin&quot;,
1771                  &quot;C:&quot;, &quot;c:&quot;, &quot;C:/&quot;, &quot;c:\\&quot;, &quot;\\&quot;, &quot;\\bin&quot;,
1772                  &quot;c:\\windows  &quot;, &quot;c:\\Program Files&quot;, &quot;c:\\Program Files\\&quot; };
1773             for (String sdir : sdirs) {
1774                 File dir = new File(sdir);
1775                 if (! (dir.isDirectory() &amp;&amp; dir.exists()))
1776                     continue;
1777                 out.println(&quot;Testing directory &quot; + dir);
1778                 //dir = new File(dir.getCanonicalPath());
1779 
1780                 ProcessBuilder pb = new ProcessBuilder();
1781                 equal(pb.directory(), null);
1782                 equal(pwdInChild(pb), canonicalUserDir);
1783 
1784                 pb.directory(dir);
1785                 equal(pb.directory(), dir);
1786                 equal(pwdInChild(pb), dir.getCanonicalPath());
1787 
1788                 pb.directory(null);
1789                 equal(pb.directory(), null);
1790                 equal(pwdInChild(pb), canonicalUserDir);
1791 
1792                 pb.directory(dir);
1793             }
1794         } catch (Throwable t) { unexpected(t); }
1795 
1796         //----------------------------------------------------------------
1797         // Working directory with Unicode in child
1798         //----------------------------------------------------------------
1799         try {
1800             if (UnicodeOS.is()) {
1801                 File dir = new File(System.getProperty(&quot;test.dir&quot;, &quot;.&quot;),
1802                                     &quot;ProcessBuilderDir\u4e00\u4e02&quot;);
1803                 try {
1804                     if (!dir.exists())
1805                         dir.mkdir();
1806                     out.println(&quot;Testing Unicode directory:&quot; + dir);
1807                     ProcessBuilder pb = new ProcessBuilder();
1808                     pb.directory(dir);
1809                     equal(pwdInChild(pb), dir.getCanonicalPath());
1810                 } finally {
1811                     if (dir.exists())
1812                         dir.delete();
1813                 }
1814             }
1815         } catch (Throwable t) { unexpected(t); }
1816 
1817         //----------------------------------------------------------------
1818         // OOME in child allocating maximally sized array
1819         // Test for hotspot/jvmti bug 6850957
1820         //----------------------------------------------------------------
1821         try {
1822             List&lt;String&gt; list = new ArrayList&lt;String&gt;(javaChildArgs);
1823             list.add(1, String.format(&quot;-XX:OnOutOfMemoryError=%s -version&quot;,
1824                                       javaExe));
1825             list.add(&quot;ArrayOOME&quot;);
1826             ProcessResults r = run(new ProcessBuilder(list));
1827             check(r.err().contains(&quot;java.lang.OutOfMemoryError:&quot;));
1828             check(r.err().contains(javaExe));
1829             check(r.err().contains(System.getProperty(&quot;java.version&quot;)));
1830             equal(r.exitValue(), 1);
1831         } catch (Throwable t) { unexpected(t); }
1832 
1833         //----------------------------------------------------------------
1834         // Windows has tricky semi-case-insensitive semantics
1835         //----------------------------------------------------------------
1836         if (Windows.is())
1837             try {
1838                 out.println(&quot;Running case insensitve variable tests&quot;);
1839                 for (String[] namePair :
1840                          new String[][]
1841                     { new String[]{&quot;PATH&quot;,&quot;PaTh&quot;},
1842                       new String[]{&quot;home&quot;,&quot;HOME&quot;},
1843                       new String[]{&quot;SYSTEMROOT&quot;,&quot;SystemRoot&quot;}}) {
1844                     check((getenv(namePair[0]) == null &amp;&amp;
1845                            getenv(namePair[1]) == null)
1846                           ||
1847                           getenv(namePair[0]).equals(getenv(namePair[1])),
1848                           &quot;Windows environment variables are not case insensitive&quot;);
1849                 }
1850             } catch (Throwable t) { unexpected(t); }
1851 
1852         //----------------------------------------------------------------
1853         // Test proper Unicode child environment transfer
1854         //----------------------------------------------------------------
1855         if (UnicodeOS.is())
1856             try {
1857                 ProcessBuilder pb = new ProcessBuilder();
1858                 pb.environment().put(&quot;\u1234&quot;,&quot;\u5678&quot;);
1859                 pb.environment().remove(&quot;PATH&quot;);
1860                 equal(getenvInChild1234(pb), &quot;\u5678&quot;);
1861             } catch (Throwable t) { unexpected(t); }
1862 
1863 
1864         //----------------------------------------------------------------
1865         // Test Runtime.exec(...envp...) with envstrings with initial `=&#39;
1866         //----------------------------------------------------------------
1867         try {
1868             List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
1869             childArgs.add(&quot;System.getenv()&quot;);
1870             String[] cmdp = childArgs.toArray(new String[childArgs.size()]);
1871             String[] envp;
1872             String[] envpWin = {&quot;=C:=\\&quot;, &quot;=ExitValue=3&quot;, &quot;SystemRoot=&quot;+systemRoot};
1873             String[] envpOth = {&quot;=ExitValue=3&quot;, &quot;=C:=\\&quot;};
1874             if (Windows.is()) {
1875                 envp = envpWin;
1876             } else {
1877                 envp = envpOth;
1878             }
1879             Process p = Runtime.getRuntime().exec(cmdp, envp);
1880             String expected = Windows.is() ? &quot;=C:=\\,=ExitValue=3,SystemRoot=&quot;+systemRoot+&quot;,&quot; : &quot;=C:=\\,&quot;;
1881             expected = AIX.is() ? expected + &quot;LIBPATH=&quot;+libpath+&quot;,&quot;: expected;
1882             String commandOutput = commandOutput(p);
1883             if (MacOSX.is()) {
1884                 commandOutput = removeMacExpectedVars(commandOutput);
1885             }
1886             if (AIX.is()) {
1887                 commandOutput = removeAixExpectedVars(commandOutput);
1888             }
1889             equal(commandOutput, expected);
1890             if (Windows.is()) {
1891                 ProcessBuilder pb = new ProcessBuilder(childArgs);
1892                 pb.environment().clear();
1893                 pb.environment().put(&quot;SystemRoot&quot;, systemRoot);
1894                 pb.environment().put(&quot;=ExitValue&quot;, &quot;3&quot;);
1895                 pb.environment().put(&quot;=C:&quot;, &quot;\\&quot;);
1896                 equal(commandOutput(pb), expected);
1897             }
1898         } catch (Throwable t) { unexpected(t); }
1899 
1900         //----------------------------------------------------------------
1901         // Test Runtime.exec(...envp...) with envstrings without any `=&#39;
1902         //----------------------------------------------------------------
1903         try {
1904             String[] cmdp = {&quot;echo&quot;};
1905             String[] envp = {&quot;Hello&quot;, &quot;World&quot;}; // Yuck!
1906             Process p = Runtime.getRuntime().exec(cmdp, envp);
1907             equal(commandOutput(p), &quot;\n&quot;);
1908         } catch (Throwable t) { unexpected(t); }
1909 
1910         //----------------------------------------------------------------
1911         // Test Runtime.exec(...envp...) with envstrings containing NULs
1912         //----------------------------------------------------------------
1913         try {
1914             List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
1915             childArgs.add(&quot;System.getenv()&quot;);
1916             String[] cmdp = childArgs.toArray(new String[childArgs.size()]);
1917             String[] envpWin = {&quot;SystemRoot=&quot;+systemRoot, &quot;LC_ALL=C\u0000\u0000&quot;, // Yuck!
1918                              &quot;FO\u0000=B\u0000R&quot;};
1919             String[] envpOth = {&quot;LC_ALL=C\u0000\u0000&quot;, // Yuck!
1920                              &quot;FO\u0000=B\u0000R&quot;};
1921             String[] envp;
1922             if (Windows.is()) {
1923                 envp = envpWin;
1924             } else {
1925                 envp = envpOth;
1926             }
1927             System.out.println (&quot;cmdp&quot;);
1928             for (int i=0; i&lt;cmdp.length; i++) {
1929                 System.out.printf (&quot;cmdp %d: %s\n&quot;, i, cmdp[i]);
1930             }
1931             System.out.println (&quot;envp&quot;);
1932             for (int i=0; i&lt;envp.length; i++) {
1933                 System.out.printf (&quot;envp %d: %s\n&quot;, i, envp[i]);
1934             }
1935             Process p = Runtime.getRuntime().exec(cmdp, envp);
1936             String commandOutput = commandOutput(p);
1937             if (MacOSX.is()) {
1938                 commandOutput = removeMacExpectedVars(commandOutput);
1939             }
1940             if (AIX.is()) {
1941                 commandOutput = removeAixExpectedVars(commandOutput);
1942             }
1943             check(commandOutput.equals(Windows.is()
1944                     ? &quot;LC_ALL=C,SystemRoot=&quot;+systemRoot+&quot;,&quot;
1945                     : AIX.is()
1946                             ? &quot;LC_ALL=C,LIBPATH=&quot;+libpath+&quot;,&quot;
1947                             : &quot;LC_ALL=C,&quot;),
1948                   &quot;Incorrect handling of envstrings containing NULs&quot;);
1949         } catch (Throwable t) { unexpected(t); }
1950 
1951         //----------------------------------------------------------------
1952         // Test the redirectErrorStream property
1953         //----------------------------------------------------------------
1954         try {
1955             ProcessBuilder pb = new ProcessBuilder();
1956             equal(pb.redirectErrorStream(), false);
1957             equal(pb.redirectErrorStream(true), pb);
1958             equal(pb.redirectErrorStream(), true);
1959             equal(pb.redirectErrorStream(false), pb);
1960             equal(pb.redirectErrorStream(), false);
1961         } catch (Throwable t) { unexpected(t); }
1962 
1963         try {
1964             List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
1965             childArgs.add(&quot;OutErr&quot;);
1966             ProcessBuilder pb = new ProcessBuilder(childArgs);
1967             {
1968                 ProcessResults r = run(pb);
1969                 equal(r.out(), &quot;outout&quot;);
1970                 equal(r.err(), &quot;errerr&quot;);
1971             }
1972             {
1973                 pb.redirectErrorStream(true);
1974                 ProcessResults r = run(pb);
1975                 equal(r.out(), &quot;outerrouterr&quot;);
1976                 equal(r.err(), &quot;&quot;);
1977             }
1978         } catch (Throwable t) { unexpected(t); }
1979 
1980         if (Unix.is()) {
1981             //----------------------------------------------------------------
1982             // We can find true and false when PATH is null
1983             //----------------------------------------------------------------
1984             try {
1985                 List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
1986                 childArgs.add(&quot;null PATH&quot;);
1987                 ProcessBuilder pb = new ProcessBuilder(childArgs);
1988                 pb.environment().remove(&quot;PATH&quot;);
1989                 ProcessResults r = run(pb);
1990                 equal(r.out(), &quot;&quot;);
1991                 equal(r.err(), &quot;&quot;);
1992                 equal(r.exitValue(), 0);
1993             } catch (Throwable t) { unexpected(t); }
1994 
1995             //----------------------------------------------------------------
1996             // PATH search algorithm on Unix
1997             //----------------------------------------------------------------
1998             try {
1999                 List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
2000                 childArgs.add(&quot;PATH search algorithm&quot;);
2001                 ProcessBuilder pb = new ProcessBuilder(childArgs);
2002                 pb.environment().put(&quot;PATH&quot;, &quot;dir1:dir2:&quot;);
2003                 ProcessResults r = run(pb);
2004                 equal(r.out(), &quot;&quot;);
2005                 equal(r.err(), &quot;&quot;);
2006                 equal(r.exitValue(), True.exitValue());
2007             } catch (Throwable t) { unexpected(t); }
2008 
2009             //----------------------------------------------------------------
2010             // Parent&#39;s, not child&#39;s PATH is used
2011             //----------------------------------------------------------------
2012             try {
2013                 new File(&quot;suBdiR&quot;).mkdirs();
2014                 copy(TrueExe.path(), &quot;suBdiR/unliKely&quot;);
2015                 final ProcessBuilder pb =
2016                     new ProcessBuilder(new String[]{&quot;unliKely&quot;});
2017                 pb.environment().put(&quot;PATH&quot;, &quot;suBdiR&quot;);
2018                 THROWS(IOException.class, () -&gt; pb.start());
2019             } catch (Throwable t) { unexpected(t);
2020             } finally {
2021                 new File(&quot;suBdiR/unliKely&quot;).delete();
2022                 new File(&quot;suBdiR&quot;).delete();
2023             }
2024         }
2025 
2026         //----------------------------------------------------------------
2027         // Attempt to start bogus program &quot;&quot;
2028         //----------------------------------------------------------------
2029         try {
2030             new ProcessBuilder(&quot;&quot;).start();
2031             fail(&quot;Expected IOException not thrown&quot;);
2032         } catch (IOException e) {
2033             String m = e.getMessage();
2034             if (EnglishUnix.is() &amp;&amp;
2035                 ! matches(m, NO_SUCH_FILE_ERROR_MSG))
2036                 unexpected(e);
2037         } catch (Throwable t) { unexpected(t); }
2038 
2039         //----------------------------------------------------------------
2040         // Check that attempt to execute program name with funny
2041         // characters throws an exception containing those characters.
2042         //----------------------------------------------------------------
2043         for (String programName : new String[] {&quot;\u00f0&quot;, &quot;\u01f0&quot;})
2044             try {
2045                 new ProcessBuilder(programName).start();
2046                 fail(&quot;Expected IOException not thrown&quot;);
2047             } catch (IOException e) {
2048                 String m = e.getMessage();
2049                 Pattern p = Pattern.compile(programName);
2050                 if (! matches(m, programName)
2051                     || (EnglishUnix.is() &amp;&amp;
2052                         ! matches(m, NO_SUCH_FILE_ERROR_MSG)))
2053                     unexpected(e);
2054             } catch (Throwable t) { unexpected(t); }
2055 
2056         //----------------------------------------------------------------
2057         // Attempt to start process in nonexistent directory fails.
2058         //----------------------------------------------------------------
2059         try {
2060             new ProcessBuilder(&quot;echo&quot;)
2061                 .directory(new File(&quot;UnLiKeLY&quot;))
2062                 .start();
2063             fail(&quot;Expected IOException not thrown&quot;);
2064         } catch (IOException e) {
2065             String m = e.getMessage();
2066             if (! matches(m, &quot;in directory&quot;)
2067                 || (EnglishUnix.is() &amp;&amp;
2068                     ! matches(m, NO_SUCH_FILE_ERROR_MSG)))
2069                 unexpected(e);
2070         } catch (Throwable t) { unexpected(t); }
2071 
2072         //----------------------------------------------------------------
2073         // Attempt to write 4095 bytes to the pipe buffer without a
2074         // reader to drain it would deadlock, if not for the fact that
2075         // interprocess pipe buffers are at least 4096 bytes.
2076         //
2077         // Also, check that available reports all the bytes expected
2078         // in the pipe buffer, and that I/O operations do the expected
2079         // things.
2080         //----------------------------------------------------------------
2081         try {
2082             List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
2083             childArgs.add(&quot;print4095&quot;);
2084             final int SIZE = 4095;
2085             final Process p = new ProcessBuilder(childArgs).start();
2086             print4095(p.getOutputStream(), (byte) &#39;!&#39;); // Might hang!
2087             p.waitFor();                                // Might hang!
2088             equal(SIZE, p.getInputStream().available());
2089             equal(SIZE, p.getErrorStream().available());
2090             THROWS(IOException.class,
2091                    () -&gt; { p.getOutputStream().write((byte) &#39;!&#39;);
2092                            p.getOutputStream().flush();});
2093 
2094             final byte[] bytes = new byte[SIZE + 1];
2095             equal(SIZE, p.getInputStream().read(bytes));
2096             for (int i = 0; i &lt; SIZE; i++)
2097                 equal((byte) &#39;!&#39;, bytes[i]);
2098             equal((byte) 0, bytes[SIZE]);
2099 
2100             equal(SIZE, p.getErrorStream().read(bytes));
2101             for (int i = 0; i &lt; SIZE; i++)
2102                 equal((byte) &#39;E&#39;, bytes[i]);
2103             equal((byte) 0, bytes[SIZE]);
2104 
2105             equal(0, p.getInputStream().available());
2106             equal(0, p.getErrorStream().available());
2107             equal(-1, p.getErrorStream().read());
2108             equal(-1, p.getInputStream().read());
2109 
2110             equal(p.exitValue(), 5);
2111 
2112             p.getInputStream().close();
2113             p.getErrorStream().close();
2114             try { p.getOutputStream().close(); } catch (IOException flushFailed) { }
2115 
2116             InputStream[] streams = { p.getInputStream(), p.getErrorStream() };
2117             for (final InputStream in : streams) {
2118                 Fun[] ops = {
2119                     () -&gt; in.read(),
2120                     () -&gt; in.read(bytes),
2121                     () -&gt; in.available()
2122                 };
2123                 for (Fun op : ops) {
2124                     try {
2125                         op.f();
2126                         fail();
2127                     } catch (IOException expected) {
2128                         check(expected.getMessage()
2129                               .matches(&quot;[Ss]tream [Cc]losed&quot;));
2130                     }
2131                 }
2132             }
2133         } catch (Throwable t) { unexpected(t); }
2134 
2135         //----------------------------------------------------------------
2136         // Check that reads which are pending when Process.destroy is
2137         // called, get EOF, or IOException(&quot;Stream closed&quot;).
2138         //----------------------------------------------------------------
2139         try {
2140             final int cases = 4;
2141             for (int i = 0; i &lt; cases; i++) {
2142                 final int action = i;
2143                 List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
2144                 childArgs.add(&quot;sleep&quot;);
2145                 final byte[] bytes = new byte[10];
2146                 final Process p = new ProcessBuilder(childArgs).start();
2147                 final CountDownLatch latch = new CountDownLatch(1);
2148                 final InputStream s;
2149                 switch (action &amp; 0x1) {
2150                     case 0: s = p.getInputStream(); break;
2151                     case 1: s = p.getErrorStream(); break;
2152                     default: throw new Error();
2153                 }
2154                 final Thread thread = new Thread() {
2155                     public void run() {
2156                         try {
2157                             int r;
2158                             latch.countDown();
2159                             switch (action &amp; 0x2) {
2160                                 case 0: r = s.read(); break;
2161                                 case 2: r = s.read(bytes); break;
2162                                 default: throw new Error();
2163                             }
2164                             if (r &gt;= 0) {
2165                                 // The child sent unexpected output; print it to diagnose
2166                                 System.out.println(&quot;Unexpected child output:&quot;);
2167                                 if ((action &amp; 0x2) == 0) {
2168                                     System.out.write(r);    // Single character
2169 
2170                                 } else {
2171                                     System.out.write(bytes, 0, r);
2172                                 }
2173                                 for (int c = s.read(); c &gt;= 0; c = s.read())
2174                                     System.out.write(c);
2175                                 System.out.println(&quot;\nEND Child output.&quot;);
2176                             }
2177                             equal(-1, r);
2178                         } catch (IOException ioe) {
2179                             if (!ioe.getMessage().equals(&quot;Stream closed&quot;)) {
2180                                 // BufferedInputStream may throw IOE(&quot;Stream closed&quot;).
2181                                 unexpected(ioe);
2182                             }
2183                         } catch (Throwable t) { unexpected(t); }}};
2184 
2185                 thread.start();
2186                 latch.await();
2187                 Thread.sleep(10);
2188 
<a name="2" id="anc2"></a><span class="line-modified">2189                 String os = System.getProperty(&quot;os.name&quot;);</span>
<span class="line-removed">2190                 if (os.equalsIgnoreCase(&quot;Solaris&quot;) ||</span>
<span class="line-removed">2191                     os.equalsIgnoreCase(&quot;SunOS&quot;))</span>
<span class="line-removed">2192                 {</span>
<span class="line-removed">2193                     final Object deferred;</span>
<span class="line-removed">2194                     Class&lt;?&gt; c = s.getClass();</span>
<span class="line-removed">2195                     if (c.getName().equals(</span>
<span class="line-removed">2196                         &quot;java.lang.ProcessImpl$DeferredCloseInputStream&quot;))</span>
<span class="line-removed">2197                     {</span>
<span class="line-removed">2198                         deferred = s;</span>
<span class="line-removed">2199                     } else {</span>
<span class="line-removed">2200                         Field deferredField = p.getClass().</span>
<span class="line-removed">2201                             getDeclaredField(&quot;stdout_inner_stream&quot;);</span>
<span class="line-removed">2202                         deferredField.setAccessible(true);</span>
<span class="line-removed">2203                         deferred = deferredField.get(p);</span>
<span class="line-removed">2204                     }</span>
<span class="line-removed">2205                     Field useCountField = deferred.getClass().</span>
<span class="line-removed">2206                         getDeclaredField(&quot;useCount&quot;);</span>
<span class="line-removed">2207                     useCountField.setAccessible(true);</span>
<span class="line-removed">2208 </span>
<span class="line-removed">2209                     while (useCountField.getInt(deferred) &lt;= 0) {</span>
<span class="line-removed">2210                         Thread.yield();</span>
<span class="line-removed">2211                     }</span>
<span class="line-removed">2212                 } else if (s instanceof BufferedInputStream) {</span>
2213                     // Wait until after the s.read occurs in &quot;thread&quot; by
2214                     // checking when the input stream monitor is acquired
2215                     // (BufferedInputStream.read is synchronized)
2216                     while (!isLocked(s, 10)) {
2217                         Thread.sleep(100);
2218                     }
2219                 }
2220                 p.destroy();
2221                 thread.join();
2222             }
2223         } catch (Throwable t) { unexpected(t); }
2224 
2225         //----------------------------------------------------------------
2226         // Check that subprocesses which create subprocesses of their
2227         // own do not cause parent to hang waiting for file
2228         // descriptors to be closed.
2229         //----------------------------------------------------------------
2230         try {
2231             if (Unix.is()
2232                 &amp;&amp; new File(&quot;/bin/bash&quot;).exists()
2233                 &amp;&amp; new File(&quot;/bin/sleep&quot;).exists()) {
2234                 // Notice that we only destroy the process created by us (i.e.
2235                 // our child) but not our grandchild (i.e. &#39;/bin/sleep&#39;). So
2236                 // pay attention that the grandchild doesn&#39;t run too long to
2237                 // avoid polluting the process space with useless processes.
2238                 // Running the grandchild for 60s should be more than enough.
2239                 final String[] cmd = { &quot;/bin/bash&quot;, &quot;-c&quot;, &quot;(/bin/sleep 60)&quot; };
2240                 final String[] cmdkill = { &quot;/bin/bash&quot;, &quot;-c&quot;, &quot;(/usr/bin/pkill -f \&quot;sleep 60\&quot;)&quot; };
2241                 final ProcessBuilder pb = new ProcessBuilder(cmd);
2242                 final Process p = pb.start();
2243                 final InputStream stdout = p.getInputStream();
2244                 final InputStream stderr = p.getErrorStream();
2245                 final OutputStream stdin = p.getOutputStream();
2246                 final Thread reader = new Thread() {
2247                     public void run() {
2248                         try { stdout.read(); }
2249                         catch (IOException e) {
2250                             // Check that reader failed because stream was
2251                             // asynchronously closed.
2252                             // e.printStackTrace();
2253                             String msg = e.getMessage();
2254                             if (EnglishUnix.is() &amp;&amp;
2255                                 ! (msg.matches(&quot;.*Bad file.*&quot;) ||
2256                                         msg.matches(&quot;.*Stream closed.*&quot;)))
2257                                 unexpected(e);
2258                         }
2259                         catch (Throwable t) { unexpected(t); }}};
2260                 reader.setDaemon(true);
2261                 reader.start();
2262                 Thread.sleep(100);
2263                 p.destroy();
2264                 check(p.waitFor() != 0);
2265                 check(p.exitValue() != 0);
2266                 // Subprocess is now dead, but file descriptors remain open.
2267                 // Make sure the test will fail if we don&#39;t manage to close
2268                 // the open streams within 30 seconds. Notice that this time
2269                 // must be shorter than the sleep time of the grandchild.
2270                 Timer t = new Timer(&quot;test/java/lang/ProcessBuilder/Basic.java process reaper&quot;, true);
2271                 t.schedule(new TimerTask() {
2272                       public void run() {
2273                           fail(&quot;Subprocesses which create subprocesses of &quot; +
2274                                &quot;their own caused the parent to hang while &quot; +
2275                                &quot;waiting for file descriptors to be closed.&quot;);
2276                           System.exit(-1);
2277                       }
2278                   }, 30000);
2279                 stdout.close();
2280                 stderr.close();
2281                 stdin.close();
2282                 new ProcessBuilder(cmdkill).start();
2283                 // All streams successfully closed so we can cancel the timer.
2284                 t.cancel();
2285                 //----------------------------------------------------------
2286                 // There remain unsolved issues with asynchronous close.
2287                 // Here&#39;s a highly non-portable experiment to demonstrate:
2288                 //----------------------------------------------------------
2289                 if (Boolean.getBoolean(&quot;wakeupJeff!&quot;)) {
2290                     System.out.println(&quot;wakeupJeff!&quot;);
2291                     // Initialize signal handler for INTERRUPT_SIGNAL.
2292                     new FileInputStream(&quot;/bin/sleep&quot;).getChannel().close();
2293                     // Send INTERRUPT_SIGNAL to every thread in this java.
2294                     String[] wakeupJeff = {
2295                         &quot;/bin/bash&quot;, &quot;-c&quot;,
2296                         &quot;/bin/ps --noheaders -Lfp $PPID | &quot; +
2297                         &quot;/usr/bin/perl -nale &#39;print $F[3]&#39; | &quot; +
2298                         // INTERRUPT_SIGNAL == 62 on my machine du jour.
2299                         &quot;/usr/bin/xargs kill -62&quot;
2300                     };
2301                     new ProcessBuilder(wakeupJeff).start().waitFor();
2302                     // If wakeupJeff worked, reader probably got EBADF.
2303                     reader.join();
2304                 }
2305             }
2306 
2307             //----------------------------------------------------------------
2308             // Check the Process toString() method
2309             //----------------------------------------------------------------
2310             {
2311                 List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
2312                 childArgs.add(&quot;testIO&quot;);
2313                 ProcessBuilder pb = new ProcessBuilder(childArgs);
2314                 pb.redirectInput(Redirect.PIPE);
2315                 pb.redirectOutput(DISCARD);
2316                 pb.redirectError(DISCARD);
2317                 final Process p = pb.start();
2318                 // Child process waits until it gets input
2319                 String s = p.toString();
2320                 check(s.contains(&quot;not exited&quot;));
2321                 check(s.contains(&quot;pid=&quot; + p.pid() + &quot;,&quot;));
2322 
2323                 new PrintStream(p.getOutputStream()).print(&quot;standard input&quot;);
2324                 p.getOutputStream().close();
2325 
2326                 // Check the toString after it exits
2327                 int exitValue = p.waitFor();
2328                 s = p.toString();
2329                 check(s.contains(&quot;pid=&quot; + p.pid() + &quot;,&quot;));
2330                 check(s.contains(&quot;exitValue=&quot; + exitValue) &amp;&amp;
2331                         !s.contains(&quot;not exited&quot;));
2332             }
2333         } catch (Throwable t) { unexpected(t); }
2334 
2335         //----------------------------------------------------------------
2336         // Attempt to start process with insufficient permissions fails.
2337         //----------------------------------------------------------------
2338         try {
2339             new File(&quot;emptyCommand&quot;).delete();
2340             new FileOutputStream(&quot;emptyCommand&quot;).close();
2341             new File(&quot;emptyCommand&quot;).setExecutable(false);
2342             new ProcessBuilder(&quot;./emptyCommand&quot;).start();
2343             fail(&quot;Expected IOException not thrown&quot;);
2344         } catch (IOException e) {
2345             new File(&quot;./emptyCommand&quot;).delete();
2346             String m = e.getMessage();
2347             if (EnglishUnix.is() &amp;&amp;
2348                 ! matches(m, PERMISSION_DENIED_ERROR_MSG))
2349                 unexpected(e);
2350         } catch (Throwable t) { unexpected(t); }
2351 
2352         new File(&quot;emptyCommand&quot;).delete();
2353 
2354         //----------------------------------------------------------------
2355         // Check for correct security permission behavior
2356         //----------------------------------------------------------------
2357         final Policy policy = new Policy();
2358         Policy.setPolicy(policy);
2359         System.setSecurityManager(new SecurityManager());
2360 
2361         try {
2362             // No permissions required to CREATE a ProcessBuilder
2363             policy.setPermissions(/* Nothing */);
2364             new ProcessBuilder(&quot;env&quot;).directory(null).directory();
2365             new ProcessBuilder(&quot;env&quot;).directory(new File(&quot;dir&quot;)).directory();
2366             new ProcessBuilder(&quot;env&quot;).command(&quot;??&quot;).command();
2367         } catch (Throwable t) { unexpected(t); }
2368 
2369         THROWS(SecurityException.class,
2370                () -&gt; { policy.setPermissions(/* Nothing */);
2371                        System.getenv(&quot;foo&quot;);},
2372                () -&gt; { policy.setPermissions(/* Nothing */);
2373                        System.getenv();},
2374                () -&gt; { policy.setPermissions(/* Nothing */);
2375                        new ProcessBuilder(&quot;echo&quot;).start();},
2376                () -&gt; { policy.setPermissions(/* Nothing */);
2377                        Runtime.getRuntime().exec(&quot;echo&quot;);},
2378                () -&gt; { policy.setPermissions(
2379                                new RuntimePermission(&quot;getenv.bar&quot;));
2380                        System.getenv(&quot;foo&quot;);});
2381 
2382         try {
2383             policy.setPermissions(new RuntimePermission(&quot;getenv.foo&quot;));
2384             System.getenv(&quot;foo&quot;);
2385 
2386             policy.setPermissions(new RuntimePermission(&quot;getenv.*&quot;));
2387             System.getenv(&quot;foo&quot;);
2388             System.getenv();
2389             new ProcessBuilder().environment();
2390         } catch (Throwable t) { unexpected(t); }
2391 
2392 
2393         final Permission execPermission
2394             = new FilePermission(&quot;&lt;&lt;ALL FILES&gt;&gt;&quot;, &quot;execute&quot;);
2395 
2396         THROWS(SecurityException.class,
2397                () -&gt; { // environment permission by itself insufficient
2398                        policy.setPermissions(new RuntimePermission(&quot;getenv.*&quot;));
2399                        ProcessBuilder pb = new ProcessBuilder(&quot;env&quot;);
2400                        pb.environment().put(&quot;foo&quot;,&quot;bar&quot;);
2401                        pb.start();},
2402                () -&gt; { // exec permission by itself insufficient
2403                        policy.setPermissions(execPermission);
2404                        ProcessBuilder pb = new ProcessBuilder(&quot;env&quot;);
2405                        pb.environment().put(&quot;foo&quot;,&quot;bar&quot;);
2406                        pb.start();});
2407 
2408         try {
2409             // Both permissions? OK.
2410             policy.setPermissions(new RuntimePermission(&quot;getenv.*&quot;),
2411                                   execPermission);
2412             ProcessBuilder pb = new ProcessBuilder(&quot;env&quot;);
2413             pb.environment().put(&quot;foo&quot;,&quot;bar&quot;);
2414             Process p = pb.start();
2415             closeStreams(p);
2416         } catch (IOException e) { // OK
2417         } catch (Throwable t) { unexpected(t); }
2418 
2419         try {
2420             // Don&#39;t need environment permission unless READING environment
2421             policy.setPermissions(execPermission);
2422             Runtime.getRuntime().exec(&quot;env&quot;, new String[]{});
2423         } catch (IOException e) { // OK
2424         } catch (Throwable t) { unexpected(t); }
2425 
2426         try {
2427             // Don&#39;t need environment permission unless READING environment
2428             policy.setPermissions(execPermission);
2429             new ProcessBuilder(&quot;env&quot;).start();
2430         } catch (IOException e) { // OK
2431         } catch (Throwable t) { unexpected(t); }
2432 
2433         // Restore &quot;normal&quot; state without a security manager
2434         policy.setPermissions(new RuntimePermission(&quot;setSecurityManager&quot;));
2435         System.setSecurityManager(null);
2436 
2437         //----------------------------------------------------------------
2438         // Check that Process.isAlive() &amp;
2439         // Process.waitFor(0, TimeUnit.MILLISECONDS) work as expected.
2440         //----------------------------------------------------------------
2441         try {
2442             List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
2443             childArgs.add(&quot;sleep&quot;);
2444             final Process p = new ProcessBuilder(childArgs).start();
2445             long start = System.nanoTime();
2446             if (!p.isAlive() || p.waitFor(0, TimeUnit.MILLISECONDS)) {
2447                 fail(&quot;Test failed: Process exited prematurely&quot;);
2448             }
2449             long end = System.nanoTime();
2450             // give waitFor(timeout) a wide berth (2s)
2451             System.out.printf(&quot; waitFor process: delta: %d%n&quot;,(end - start) );
2452 
2453             if ((end - start) &gt; TimeUnit.SECONDS.toNanos(2))
2454                 fail(&quot;Test failed: waitFor took too long (&quot; + (end - start) + &quot;ns)&quot;);
2455 
2456             p.destroy();
2457             p.waitFor();
2458 
2459             if (p.isAlive() ||
2460                 !p.waitFor(0, TimeUnit.MILLISECONDS))
2461             {
2462                 fail(&quot;Test failed: Process still alive - please terminate &quot; +
2463                     p.toString() + &quot; manually&quot;);
2464             }
2465         } catch (Throwable t) { unexpected(t); }
2466 
2467         //----------------------------------------------------------------
2468         // Check that Process.waitFor(timeout, TimeUnit.MILLISECONDS)
2469         // works as expected.
2470         //----------------------------------------------------------------
2471         try {
2472             List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
2473             childArgs.add(&quot;sleep&quot;);
2474             final Process p = new ProcessBuilder(childArgs).start();
2475             long start = System.nanoTime();
2476 
2477             p.waitFor(10, TimeUnit.MILLISECONDS);
2478 
2479             long end = System.nanoTime();
2480             if ((end - start) &lt; TimeUnit.MILLISECONDS.toNanos(10))
2481                 fail(&quot;Test failed: waitFor didn&#39;t take long enough (&quot; + (end - start) + &quot;ns)&quot;);
2482 
2483             p.destroy();
2484         } catch (Throwable t) { unexpected(t); }
2485 
2486         //----------------------------------------------------------------
2487         // Check that Process.waitFor(timeout, TimeUnit.MILLISECONDS)
2488         // interrupt works as expected, if interrupted while waiting.
2489         //----------------------------------------------------------------
2490         try {
2491             List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
2492             childArgs.add(&quot;sleep&quot;);
2493             final Process p = new ProcessBuilder(childArgs).start();
2494             final long start = System.nanoTime();
2495             final CountDownLatch aboutToWaitFor = new CountDownLatch(1);
2496 
2497             final Thread thread = new Thread() {
2498                 public void run() {
2499                     try {
2500                         aboutToWaitFor.countDown();
2501                         Thread.currentThread().interrupt();
2502                         boolean result = p.waitFor(30L * 1000L, TimeUnit.MILLISECONDS);
2503                         fail(&quot;waitFor() wasn&#39;t interrupted, its return value was: &quot; + result);
2504                     } catch (InterruptedException success) {
2505                     } catch (Throwable t) { unexpected(t); }
2506                 }
2507             };
2508 
2509             thread.start();
2510             aboutToWaitFor.await();
2511             thread.interrupt();
2512             thread.join(10L * 1000L);
2513             check(millisElapsedSince(start) &lt; 10L * 1000L);
2514             check(!thread.isAlive());
2515             p.destroy();
2516         } catch (Throwable t) { unexpected(t); }
2517 
2518         //----------------------------------------------------------------
2519         // Check that Process.waitFor(Long.MAX_VALUE, TimeUnit.MILLISECONDS)
2520         // interrupt works as expected, if interrupted while waiting.
2521         //----------------------------------------------------------------
2522         try {
2523             List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
2524             childArgs.add(&quot;sleep&quot;);
2525             final Process p = new ProcessBuilder(childArgs).start();
2526             final long start = System.nanoTime();
2527             final CountDownLatch aboutToWaitFor = new CountDownLatch(1);
2528 
2529             final Thread thread = new Thread() {
2530                 public void run() {
2531                     try {
2532                         aboutToWaitFor.countDown();
2533                         Thread.currentThread().interrupt();
2534                         boolean result = p.waitFor(Long.MAX_VALUE, TimeUnit.MILLISECONDS);
2535                         fail(&quot;waitFor() wasn&#39;t interrupted, its return value was: &quot; + result);
2536                     } catch (InterruptedException success) {
2537                     } catch (Throwable t) { unexpected(t); }
2538                 }
2539             };
2540 
2541             thread.start();
2542             aboutToWaitFor.await();
2543             thread.interrupt();
2544             thread.join(10L * 1000L);
2545             check(millisElapsedSince(start) &lt; 10L * 1000L);
2546             check(!thread.isAlive());
2547             p.destroy();
2548         } catch (Throwable t) { unexpected(t); }
2549 
2550         //----------------------------------------------------------------
2551         // Check that Process.waitFor(timeout, TimeUnit.MILLISECONDS)
2552         // interrupt works as expected, if interrupted before waiting.
2553         //----------------------------------------------------------------
2554         try {
2555             List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
2556             childArgs.add(&quot;sleep&quot;);
2557             final Process p = new ProcessBuilder(childArgs).start();
2558             final long start = System.nanoTime();
2559             final CountDownLatch threadStarted = new CountDownLatch(1);
2560 
2561             final Thread thread = new Thread() {
2562                 public void run() {
2563                     try {
2564                         threadStarted.countDown();
2565                         do { Thread.yield(); }
2566                         while (!Thread.currentThread().isInterrupted());
2567                         boolean result = p.waitFor(30L * 1000L, TimeUnit.MILLISECONDS);
2568                         fail(&quot;waitFor() wasn&#39;t interrupted, its return value was: &quot; + result);
2569                     } catch (InterruptedException success) {
2570                     } catch (Throwable t) { unexpected(t); }
2571                 }
2572             };
2573 
2574             thread.start();
2575             threadStarted.await();
2576             thread.interrupt();
2577             thread.join(10L * 1000L);
2578             check(millisElapsedSince(start) &lt; 10L * 1000L);
2579             check(!thread.isAlive());
2580             p.destroy();
2581         } catch (Throwable t) { unexpected(t); }
2582 
2583         //----------------------------------------------------------------
2584         // Check that Process.waitFor(timeout, null) throws NPE.
2585         //----------------------------------------------------------------
2586         try {
2587             List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
2588             childArgs.add(&quot;sleep&quot;);
2589             final Process p = new ProcessBuilder(childArgs).start();
2590             THROWS(NullPointerException.class,
2591                     () -&gt;  p.waitFor(10L, null));
2592             THROWS(NullPointerException.class,
2593                     () -&gt;  p.waitFor(0L, null));
2594             THROWS(NullPointerException.class,
2595                     () -&gt; p.waitFor(-1L, null));
2596             // Terminate process and recheck after it exits
2597             p.destroy();
2598             p.waitFor();
2599             THROWS(NullPointerException.class,
2600                     () -&gt; p.waitFor(10L, null));
2601             THROWS(NullPointerException.class,
2602                     () -&gt; p.waitFor(0L, null));
2603             THROWS(NullPointerException.class,
2604                     () -&gt; p.waitFor(-1L, null));
2605         } catch (Throwable t) { unexpected(t); }
2606 
2607         //----------------------------------------------------------------
2608         // Check that default implementation of Process.waitFor(timeout, null) throws NPE.
2609         //----------------------------------------------------------------
2610         try {
2611             List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
2612             childArgs.add(&quot;sleep&quot;);
2613             final Process proc = new ProcessBuilder(childArgs).start();
2614             final DelegatingProcess p = new DelegatingProcess(proc);
2615 
2616             THROWS(NullPointerException.class,
2617                     () -&gt;  p.waitFor(10L, null));
2618             THROWS(NullPointerException.class,
2619                     () -&gt;  p.waitFor(0L, null));
2620             THROWS(NullPointerException.class,
2621                     () -&gt;  p.waitFor(-1L, null));
2622             // Terminate process and recheck after it exits
2623             p.destroy();
2624             p.waitFor();
2625             THROWS(NullPointerException.class,
2626                     () -&gt; p.waitFor(10L, null));
2627             THROWS(NullPointerException.class,
2628                     () -&gt; p.waitFor(0L, null));
2629             THROWS(NullPointerException.class,
2630                     () -&gt; p.waitFor(-1L, null));
2631         } catch (Throwable t) { unexpected(t); }
2632 
2633         //----------------------------------------------------------------
2634         // Check the default implementation for
2635         // Process.waitFor(long, TimeUnit)
2636         //----------------------------------------------------------------
2637         try {
2638             List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
2639             childArgs.add(&quot;sleep&quot;);
2640             final Process proc = new ProcessBuilder(childArgs).start();
2641             DelegatingProcess p = new DelegatingProcess(proc);
2642             long start = System.nanoTime();
2643 
2644             p.waitFor(1000, TimeUnit.MILLISECONDS);
2645 
2646             long end = System.nanoTime();
2647             if ((end - start) &lt; 500000000)
2648                 fail(&quot;Test failed: waitFor didn&#39;t take long enough&quot;);
2649 
2650             p.destroy();
2651 
2652             p.waitFor(1000, TimeUnit.MILLISECONDS);
2653         } catch (Throwable t) { unexpected(t); }
2654     }
2655 
2656     static void closeStreams(Process p) {
2657         try {
2658             p.getOutputStream().close();
2659             p.getInputStream().close();
2660             p.getErrorStream().close();
2661         } catch (Throwable t) { unexpected(t); }
2662     }
2663 
2664     //----------------------------------------------------------------
2665     // A Policy class designed to make permissions fiddling very easy.
2666     //----------------------------------------------------------------
2667     private static class Policy extends java.security.Policy {
2668         static final java.security.Policy DEFAULT_POLICY = java.security.Policy.getPolicy();
2669 
2670         private Permissions perms;
2671 
2672         public void setPermissions(Permission...permissions) {
2673             perms = new Permissions();
2674             for (Permission permission : permissions)
2675                 perms.add(permission);
2676         }
2677 
2678         public Policy() { setPermissions(/* Nothing */); }
2679 
2680         public PermissionCollection getPermissions(CodeSource cs) {
2681             return perms;
2682         }
2683 
2684         public PermissionCollection getPermissions(ProtectionDomain pd) {
2685             return perms;
2686         }
2687 
2688         public boolean implies(ProtectionDomain pd, Permission p) {
2689             return perms.implies(p) || DEFAULT_POLICY.implies(pd, p);
2690         }
2691 
2692         public void refresh() {}
2693     }
2694 
2695     private static class StreamAccumulator extends Thread {
2696         private final InputStream is;
2697         private final StringBuilder sb = new StringBuilder();
2698         private Throwable throwable = null;
2699 
2700         public String result () throws Throwable {
2701             if (throwable != null)
2702                 throw throwable;
2703             return sb.toString();
2704         }
2705 
2706         StreamAccumulator (InputStream is) {
2707             this.is = is;
2708         }
2709 
2710         public void run() {
2711             try {
2712                 Reader r = new InputStreamReader(is);
2713                 char[] buf = new char[4096];
2714                 int n;
2715                 while ((n = r.read(buf)) &gt; 0) {
2716                     sb.append(buf,0,n);
2717                 }
2718             } catch (Throwable t) {
2719                 throwable = t;
2720             } finally {
2721                 try { is.close(); }
2722                 catch (Throwable t) { throwable = t; }
2723             }
2724         }
2725     }
2726 
2727     static ProcessResults run(ProcessBuilder pb) {
2728         try {
2729             return run(pb.start());
2730         } catch (Throwable t) { unexpected(t); return null; }
2731     }
2732 
2733     private static ProcessResults run(Process p) {
2734         Throwable throwable = null;
2735         int exitValue = -1;
2736         String out = &quot;&quot;;
2737         String err = &quot;&quot;;
2738 
2739         StreamAccumulator outAccumulator =
2740             new StreamAccumulator(p.getInputStream());
2741         StreamAccumulator errAccumulator =
2742             new StreamAccumulator(p.getErrorStream());
2743 
2744         try {
2745             outAccumulator.start();
2746             errAccumulator.start();
2747 
2748             exitValue = p.waitFor();
2749 
2750             outAccumulator.join();
2751             errAccumulator.join();
2752 
2753             out = outAccumulator.result();
2754             err = errAccumulator.result();
2755         } catch (Throwable t) {
2756             throwable = t;
2757         }
2758 
2759         return new ProcessResults(out, err, exitValue, throwable);
2760     }
2761 
2762     //----------------------------------------------------------------
2763     // Results of a command
2764     //----------------------------------------------------------------
2765     private static class ProcessResults {
2766         private final String out;
2767         private final String err;
2768         private final int exitValue;
2769         private final Throwable throwable;
2770 
2771         public ProcessResults(String out,
2772                               String err,
2773                               int exitValue,
2774                               Throwable throwable) {
2775             this.out = out;
2776             this.err = err;
2777             this.exitValue = exitValue;
2778             this.throwable = throwable;
2779         }
2780 
2781         public String out()          { return out; }
2782         public String err()          { return err; }
2783         public int exitValue()       { return exitValue; }
2784         public Throwable throwable() { return throwable; }
2785 
2786         public String toString() {
2787             StringBuilder sb = new StringBuilder();
2788             sb.append(&quot;&lt;STDOUT&gt;\n&quot; + out() + &quot;&lt;/STDOUT&gt;\n&quot;)
2789                 .append(&quot;&lt;STDERR&gt;\n&quot; + err() + &quot;&lt;/STDERR&gt;\n&quot;)
2790                 .append(&quot;exitValue = &quot; + exitValue + &quot;\n&quot;);
2791             if (throwable != null)
2792                 sb.append(throwable.getStackTrace());
2793             return sb.toString();
2794         }
2795     }
2796 
2797     //--------------------- Infrastructure ---------------------------
2798     static volatile int passed = 0, failed = 0;
2799     static void pass() {passed++;}
2800     static void fail() {failed++; Thread.dumpStack();}
2801     static void fail(String msg) {System.err.println(msg); fail();}
2802     static void unexpected(Throwable t) {failed++; t.printStackTrace();}
2803     static void check(boolean cond) {if (cond) pass(); else fail();}
2804     static void check(boolean cond, String m) {if (cond) pass(); else fail(m);}
2805     static void equal(Object x, Object y) {
2806         if (x == null ? y == null : x.equals(y)) pass();
2807         else fail(&quot;&gt;&#39;&quot; + x + &quot;&#39;&lt;&quot; + &quot; not equal to &quot; + &quot;&#39;&quot; + y + &quot;&#39;&quot;);}
2808 
2809     public static void main(String[] args) throws Throwable {
2810         try {realMain(args);} catch (Throwable t) {unexpected(t);}
2811         System.out.printf(&quot;%nPassed = %d, failed = %d%n%n&quot;, passed, failed);
2812         if (failed &gt; 0) throw new AssertionError(&quot;Some tests failed&quot;);}
2813     interface Fun {void f() throws Throwable;}
2814     static void THROWS(Class&lt;? extends Throwable&gt; k, Fun... fs) {
2815         for (Fun f : fs)
2816             try { f.f(); fail(&quot;Expected &quot; + k.getName() + &quot; not thrown&quot;); }
2817             catch (Throwable t) {
2818                 if (k.isAssignableFrom(t.getClass())) pass();
2819                 else unexpected(t);}}
2820 
2821     static boolean isLocked(final Object monitor, final long millis) throws InterruptedException {
2822         return new Thread() {
2823             volatile boolean unlocked;
2824 
2825             @Override
2826             public void run() {
2827                 synchronized (monitor) { unlocked = true; }
2828             }
2829 
2830             boolean isLocked() throws InterruptedException {
2831                 start();
2832                 join(millis);
2833                 return !unlocked;
2834             }
2835         }.isLocked();
2836     }
2837 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
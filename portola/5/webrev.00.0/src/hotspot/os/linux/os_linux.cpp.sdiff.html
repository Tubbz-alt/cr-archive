<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os/linux/os_linux.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../../../../make/test/JtregNativeJdk.gmk.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../share/gc/shared/genCollectedHeap.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/linux/os_linux.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 136   FILE_BACKED_PVT_BIT = 1 &lt;&lt; 2,
 137   FILE_BACKED_SHARED_BIT = 1 &lt;&lt; 3,
 138   LARGEPAGES_BIT = 1 &lt;&lt; 6,
 139   DAX_SHARED_BIT = 1 &lt;&lt; 8
 140 };
 141 
 142 ////////////////////////////////////////////////////////////////////////////////
 143 // global variables
 144 julong os::Linux::_physical_memory = 0;
 145 
 146 address   os::Linux::_initial_thread_stack_bottom = NULL;
 147 uintptr_t os::Linux::_initial_thread_stack_size   = 0;
 148 
 149 int (*os::Linux::_pthread_getcpuclockid)(pthread_t, clockid_t *) = NULL;
 150 int (*os::Linux::_pthread_setname_np)(pthread_t, const char*) = NULL;
 151 pthread_t os::Linux::_main_thread;
 152 int os::Linux::_page_size = -1;
 153 bool os::Linux::_supports_fast_thread_cpu_time = false;
 154 const char * os::Linux::_glibc_version = &quot;unknown&quot;;
 155 const char * os::Linux::_libpthread_version = &quot;unknown&quot;;

 156 
 157 static jlong initial_time_count=0;
 158 
 159 static int clock_tics_per_sec = 100;
 160 
 161 // If the VM might have been created on the primordial thread, we need to resolve the
 162 // primordial thread stack bounds and check if the current thread might be the
 163 // primordial thread in places. If we know that the primordial thread is never used,
 164 // such as when the VM was created by one of the standard java launchers, we can
 165 // avoid this
 166 static bool suppress_primordial_thread_resolution = false;
 167 
 168 // For diagnostics to print a message once. see run_periodic_checks
 169 static sigset_t check_signal_done;
 170 static bool check_signals = true;
 171 
 172 // Signal number used to suspend/resume a thread
 173 
 174 // do not use any signal number less than SIGSEGV, see 4355769
 175 static int SR_signum = SIGUSR2;
</pre>
<hr />
<pre>
1361 }
1362 
1363 jlong os::elapsed_frequency() {
1364   return NANOSECS_PER_SEC; // nanosecond resolution
1365 }
1366 
1367 bool os::supports_vtime() { return true; }
1368 
1369 double os::elapsedVTime() {
1370   struct rusage usage;
1371   int retval = getrusage(RUSAGE_THREAD, &amp;usage);
1372   if (retval == 0) {
1373     return (double) (usage.ru_utime.tv_sec + usage.ru_stime.tv_sec) + (double) (usage.ru_utime.tv_usec + usage.ru_stime.tv_usec) / (1000 * 1000);
1374   } else {
1375     // better than nothing, but not much
1376     return elapsedTime();
1377   }
1378 }
1379 
1380 jlong os::javaTimeMillis() {
<span class="line-modified">1381   timeval time;</span>
<span class="line-modified">1382   int status = gettimeofday(&amp;time, NULL);</span>
<span class="line-modified">1383   assert(status != -1, &quot;linux error&quot;);</span>
<span class="line-modified">1384   return jlong(time.tv_sec) * 1000  +  jlong(time.tv_usec / 1000);</span>









1385 }
1386 
1387 void os::javaTimeSystemUTC(jlong &amp;seconds, jlong &amp;nanos) {
<span class="line-modified">1388   timeval time;</span>
<span class="line-modified">1389   int status = gettimeofday(&amp;time, NULL);</span>
<span class="line-modified">1390   assert(status != -1, &quot;linux error&quot;);</span>
<span class="line-modified">1391   seconds = jlong(time.tv_sec);</span>
<span class="line-modified">1392   nanos = jlong(time.tv_usec) * 1000;</span>








1393 }
1394 
1395 void os::Linux::fast_thread_clock_init() {
1396   if (!UseLinuxPosixThreadCPUClocks) {
1397     return;
1398   }
1399   clockid_t clockid;
1400   struct timespec tp;
1401   int (*pthread_getcpuclockid_func)(pthread_t, clockid_t *) =
1402       (int(*)(pthread_t, clockid_t *)) dlsym(RTLD_DEFAULT, &quot;pthread_getcpuclockid&quot;);
1403 
1404   // Switch to using fast clocks for thread cpu time if
1405   // the clock_getres() returns 0 error code.
1406   // Note, that some kernels may support the current thread
1407   // clock (CLOCK_THREAD_CPUTIME_ID) but not the clocks
1408   // returned by the pthread_getcpuclockid().
1409   // If the fast Posix clocks are supported then the clock_getres()
1410   // must return at least tp.tv_sec == 0 which means a resolution
1411   // better than 1 sec. This is extra check for reliability.
1412 
</pre>
<hr />
<pre>
2037   if (fd == -1) {
2038     return false;
2039   }
2040 
2041   if (hdr != NULL) {
2042     st-&gt;print_cr(&quot;%s&quot;, hdr);
2043   }
2044 
2045   char buf[33];
2046   int bytes;
2047   buf[32] = &#39;\0&#39;;
2048   while ((bytes = ::read(fd, buf, sizeof(buf)-1)) &gt; 0) {
2049     st-&gt;print_raw(buf, bytes);
2050   }
2051 
2052   ::close(fd);
2053 
2054   return true;
2055 }
2056 
<span class="line-modified">2057 static void _print_ascii_file_h(const char* header, const char* filename, outputStream* st) {</span>
<span class="line-modified">2058   st-&gt;print_cr(&quot;%s:&quot;, header);</span>
2059   if (!_print_ascii_file(filename, st)) {
2060     st-&gt;print_cr(&quot;&lt;Not Available&gt;&quot;);
2061   }
2062 }
2063 
2064 void os::print_dll_info(outputStream *st) {
2065   st-&gt;print_cr(&quot;Dynamic libraries:&quot;);
2066 
2067   char fname[32];
2068   pid_t pid = os::Linux::gettid();
2069 
2070   jio_snprintf(fname, sizeof(fname), &quot;/proc/%d/maps&quot;, pid);
2071 
2072   if (!_print_ascii_file(fname, st)) {
<span class="line-modified">2073     st-&gt;print(&quot;Can not get library information for pid = %d\n&quot;, pid);</span>
2074   }
2075 }
2076 
<span class="line-modified">2077 int os::get_loaded_modules_info(os::LoadedModulesCallbackFunc callback, void *param) {</span>
<span class="line-modified">2078   FILE *procmapsFile = NULL;</span>
<span class="line-modified">2079 </span>
<span class="line-modified">2080   // Open the procfs maps file for the current process</span>
<span class="line-modified">2081   if ((procmapsFile = fopen(&quot;/proc/self/maps&quot;, &quot;r&quot;)) != NULL) {</span>
<span class="line-modified">2082     // Allocate PATH_MAX for file name plus a reasonable size for other fields.</span>
<span class="line-modified">2083     char line[PATH_MAX + 100];</span>
<span class="line-modified">2084 </span>
<span class="line-modified">2085     // Read line by line from &#39;file&#39;</span>
<span class="line-modified">2086     while (fgets(line, sizeof(line), procmapsFile) != NULL) {</span>
<span class="line-modified">2087       u8 base, top, inode;</span>
<span class="line-modified">2088       char name[sizeof(line)];</span>
<span class="line-modified">2089 </span>
<span class="line-modified">2090       // Parse fields from line, discard perms, offset and device</span>
<span class="line-modified">2091       int matches = sscanf(line, UINT64_FORMAT_X &quot;-&quot; UINT64_FORMAT_X &quot; %*s %*s %*s &quot; INT64_FORMAT &quot; %s&quot;,</span>
<span class="line-modified">2092              &amp;base, &amp;top, &amp;inode, name);</span>
<span class="line-modified">2093       // the last entry &#39;name&#39; is empty for some entries, so we might have 3 matches instead of 4 for some lines</span>
<span class="line-modified">2094       if (matches &lt; 3) continue;</span>
<span class="line-modified">2095       if (matches == 3) name[0] = &#39;\0&#39;;</span>
<span class="line-modified">2096 </span>
<span class="line-modified">2097       // Filter by inode 0 so that we only get file system mapped files.</span>
<span class="line-modified">2098       if (inode != 0) {</span>
<span class="line-modified">2099 </span>
<span class="line-modified">2100         // Call callback with the fields of interest</span>
<span class="line-modified">2101         if(callback(name, (address)base, (address)top, param)) {</span>
<span class="line-modified">2102           // Oops abort, callback aborted</span>
<span class="line-removed">2103           fclose(procmapsFile);</span>
<span class="line-removed">2104           return 1;</span>
<span class="line-removed">2105         }</span>
2106       }
2107     }
<span class="line-modified">2108     fclose(procmapsFile);</span>
<span class="line-modified">2109   }</span>





2110   return 0;
2111 }
2112 
2113 void os::print_os_info_brief(outputStream* st) {
2114   os::Linux::print_distro_info(st);
2115 
2116   os::Posix::print_uname_info(st);
2117 
2118   os::Linux::print_libversion_info(st);
2119 
2120 }
2121 
2122 void os::print_os_info(outputStream* st) {
<span class="line-modified">2123   st-&gt;print(&quot;OS:&quot;);</span>
2124 
2125   os::Linux::print_distro_info(st);
2126 
2127   os::Posix::print_uname_info(st);
2128 
2129   os::Linux::print_uptime_info(st);
2130 
2131   // Print warning if unsafe chroot environment detected
2132   if (unsafe_chroot_detected) {
<span class="line-modified">2133     st-&gt;print(&quot;WARNING!! &quot;);</span>
<span class="line-removed">2134     st-&gt;print_cr(&quot;%s&quot;, unstable_chroot_error);</span>
2135   }
2136 
2137   os::Linux::print_libversion_info(st);
2138 
2139   os::Posix::print_rlimit_info(st);
2140 
2141   os::Posix::print_load_average(st);

2142 
2143   os::Linux::print_full_memory_info(st);

2144 
2145   os::Linux::print_proc_sys_info(st);

2146 
<span class="line-modified">2147   os::Linux::print_ld_preload_file(st);</span>


2148 
<span class="line-modified">2149   os::Linux::print_container_info(st);</span>


2150 
2151   VM_Version::print_platform_virtualization_info(st);
2152 
2153   os::Linux::print_steal_info(st);
2154 }
2155 
2156 // Try to identify popular distros.
2157 // Most Linux distributions have a /etc/XXX-release file, which contains
2158 // the OS version string. Newer Linux distributions have a /etc/lsb-release
2159 // file that also contains the OS version string. Some have more than one
2160 // /etc/XXX-release file (e.g. Mandrake has both /etc/mandrake-release and
2161 // /etc/redhat-release.), so the order is important.
2162 // Any Linux that is based on Redhat (i.e. Oracle, Mandrake, Sun JDS...) have
2163 // their own specific XXX-release file as well as a redhat-release file.
2164 // Because of this the XXX-release file needs to be searched for before the
2165 // redhat-release file.
2166 // Since Red Hat and SuSE have an lsb-release file that is not very descriptive the
2167 // search for redhat-release / SuSE-release needs to be before lsb-release.
2168 // Since the lsb-release file is the new standard it needs to be searched
2169 // before the older style release files.
</pre>
<hr />
<pre>
2190   &quot;/etc/system-release&quot;,
2191   &quot;/etc/os-release&quot;,
2192   NULL };
2193 
2194 void os::Linux::print_distro_info(outputStream* st) {
2195   for (int i = 0;; i++) {
2196     const char* file = distro_files[i];
2197     if (file == NULL) {
2198       break;  // done
2199     }
2200     // If file prints, we found it.
2201     if (_print_ascii_file(file, st)) {
2202       return;
2203     }
2204   }
2205 
2206   if (file_exists(&quot;/etc/debian_version&quot;)) {
2207     st-&gt;print(&quot;Debian &quot;);
2208     _print_ascii_file(&quot;/etc/debian_version&quot;, st);
2209   } else {
<span class="line-modified">2210     st-&gt;print(&quot;Linux&quot;);</span>
2211   }
<span class="line-removed">2212   st-&gt;cr();</span>
2213 }
2214 
2215 static void parse_os_info_helper(FILE* fp, char* distro, size_t length, bool get_first_line) {
2216   char buf[256];
2217   while (fgets(buf, sizeof(buf), fp)) {
2218     // Edit out extra stuff in expected format
2219     if (strstr(buf, &quot;DISTRIB_DESCRIPTION=&quot;) != NULL || strstr(buf, &quot;PRETTY_NAME=&quot;) != NULL) {
2220       char* ptr = strstr(buf, &quot;\&quot;&quot;);  // the name is in quotes
2221       if (ptr != NULL) {
2222         ptr++; // go beyond first quote
2223         char* nl = strchr(ptr, &#39;\&quot;&#39;);
2224         if (nl != NULL) *nl = &#39;\0&#39;;
2225         strncpy(distro, ptr, length);
2226       } else {
2227         ptr = strstr(buf, &quot;=&quot;);
2228         ptr++; // go beyond equals then
2229         char* nl = strchr(ptr, &#39;\n&#39;);
2230         if (nl != NULL) *nl = &#39;\0&#39;;
2231         strncpy(distro, ptr, length);
2232       }
</pre>
<hr />
<pre>
2261       break; // ran out of distro_files
2262     }
2263     if (file_exists(file)) {
2264       parse_os_info(buf, buflen, file);
2265       return;
2266     }
2267   }
2268   // special case for debian
2269   if (file_exists(&quot;/etc/debian_version&quot;)) {
2270     strncpy(buf, &quot;Debian &quot;, buflen);
2271     if (buflen &gt; 7) {
2272       parse_os_info(&amp;buf[7], buflen-7, &quot;/etc/debian_version&quot;);
2273     }
2274   } else {
2275     strncpy(buf, &quot;Linux&quot;, buflen);
2276   }
2277 }
2278 
2279 void os::Linux::print_libversion_info(outputStream* st) {
2280   // libc, pthread
<span class="line-modified">2281   st-&gt;print(&quot;libc:&quot;);</span>
2282   st-&gt;print(&quot;%s &quot;, os::Linux::glibc_version());
2283   st-&gt;print(&quot;%s &quot;, os::Linux::libpthread_version());
2284   st-&gt;cr();
2285 }
2286 
2287 void os::Linux::print_proc_sys_info(outputStream* st) {
<span class="line-removed">2288   st-&gt;cr();</span>
2289   _print_ascii_file_h(&quot;/proc/sys/kernel/threads-max (system-wide limit on the number of threads)&quot;,
2290                       &quot;/proc/sys/kernel/threads-max&quot;, st);
2291   _print_ascii_file_h(&quot;/proc/sys/vm/max_map_count (maximum number of memory map areas a process may have)&quot;,
2292                       &quot;/proc/sys/vm/max_map_count&quot;, st);
2293   _print_ascii_file_h(&quot;/proc/sys/kernel/pid_max (system-wide limit on number of process identifiers)&quot;,
2294                       &quot;/proc/sys/kernel/pid_max&quot;, st);
2295 }
2296 
2297 void os::Linux::print_full_memory_info(outputStream* st) {
<span class="line-modified">2298   _print_ascii_file_h(&quot;\n/proc/meminfo&quot;, &quot;/proc/meminfo&quot;, st);</span>
2299   st-&gt;cr();
2300 
2301   // some information regarding THPs; for details see
2302   // https://www.kernel.org/doc/Documentation/vm/transhuge.txt
2303   _print_ascii_file_h(&quot;/sys/kernel/mm/transparent_hugepage/enabled&quot;,
2304                       &quot;/sys/kernel/mm/transparent_hugepage/enabled&quot;, st);
2305   _print_ascii_file_h(&quot;/sys/kernel/mm/transparent_hugepage/defrag (defrag/compaction efforts parameter)&quot;,
2306                       &quot;/sys/kernel/mm/transparent_hugepage/defrag&quot;, st);
2307 }
2308 
<span class="line-modified">2309 void os::Linux::print_ld_preload_file(outputStream* st) {</span>
<span class="line-modified">2310   _print_ascii_file(&quot;/etc/ld.so.preload&quot;, st, &quot;\n/etc/ld.so.preload:&quot;);</span>
<span class="line-removed">2311   st-&gt;cr();</span>
2312 }
2313 
2314 void os::Linux::print_uptime_info(outputStream* st) {
2315   struct sysinfo sinfo;
2316   int ret = sysinfo(&amp;sinfo);
2317   if (ret == 0) {
2318     os::print_dhm(st, &quot;OS uptime:&quot;, (long) sinfo.uptime);
2319   }
2320 }
2321 
<span class="line-modified">2322 </span>
<span class="line-removed">2323 void os::Linux::print_container_info(outputStream* st) {</span>
2324   if (!OSContainer::is_containerized()) {
<span class="line-modified">2325     return;</span>
2326   }
2327 
<span class="line-modified">2328   st-&gt;print(&quot;container (cgroup) information:\n&quot;);</span>
2329 
2330   const char *p_ct = OSContainer::container_type();
<span class="line-modified">2331   st-&gt;print(&quot;container_type: %s\n&quot;, p_ct != NULL ? p_ct : &quot;not supported&quot;);</span>
2332 
2333   char *p = OSContainer::cpu_cpuset_cpus();
<span class="line-modified">2334   st-&gt;print(&quot;cpu_cpuset_cpus: %s\n&quot;, p != NULL ? p : &quot;not supported&quot;);</span>
2335   free(p);
2336 
2337   p = OSContainer::cpu_cpuset_memory_nodes();
<span class="line-modified">2338   st-&gt;print(&quot;cpu_memory_nodes: %s\n&quot;, p != NULL ? p : &quot;not supported&quot;);</span>
2339   free(p);
2340 
2341   int i = OSContainer::active_processor_count();
2342   st-&gt;print(&quot;active_processor_count: &quot;);
2343   if (i &gt; 0) {
<span class="line-modified">2344     st-&gt;print(&quot;%d\n&quot;, i);</span>
2345   } else {
<span class="line-modified">2346     st-&gt;print(&quot;not supported\n&quot;);</span>
2347   }
2348 
2349   i = OSContainer::cpu_quota();
2350   st-&gt;print(&quot;cpu_quota: &quot;);
2351   if (i &gt; 0) {
<span class="line-modified">2352     st-&gt;print(&quot;%d\n&quot;, i);</span>
2353   } else {
<span class="line-modified">2354     st-&gt;print(&quot;%s\n&quot;, i == OSCONTAINER_ERROR ? &quot;not supported&quot; : &quot;no quota&quot;);</span>
2355   }
2356 
2357   i = OSContainer::cpu_period();
2358   st-&gt;print(&quot;cpu_period: &quot;);
2359   if (i &gt; 0) {
<span class="line-modified">2360     st-&gt;print(&quot;%d\n&quot;, i);</span>
2361   } else {
<span class="line-modified">2362     st-&gt;print(&quot;%s\n&quot;, i == OSCONTAINER_ERROR ? &quot;not supported&quot; : &quot;no period&quot;);</span>
2363   }
2364 
2365   i = OSContainer::cpu_shares();
2366   st-&gt;print(&quot;cpu_shares: &quot;);
2367   if (i &gt; 0) {
<span class="line-modified">2368     st-&gt;print(&quot;%d\n&quot;, i);</span>
2369   } else {
<span class="line-modified">2370     st-&gt;print(&quot;%s\n&quot;, i == OSCONTAINER_ERROR ? &quot;not supported&quot; : &quot;no shares&quot;);</span>
2371   }
2372 
2373   jlong j = OSContainer::memory_limit_in_bytes();
2374   st-&gt;print(&quot;memory_limit_in_bytes: &quot;);
2375   if (j &gt; 0) {
<span class="line-modified">2376     st-&gt;print(JLONG_FORMAT &quot;\n&quot;, j);</span>
2377   } else {
<span class="line-modified">2378     st-&gt;print(&quot;%s\n&quot;, j == OSCONTAINER_ERROR ? &quot;not supported&quot; : &quot;unlimited&quot;);</span>
2379   }
2380 
2381   j = OSContainer::memory_and_swap_limit_in_bytes();
2382   st-&gt;print(&quot;memory_and_swap_limit_in_bytes: &quot;);
2383   if (j &gt; 0) {
<span class="line-modified">2384     st-&gt;print(JLONG_FORMAT &quot;\n&quot;, j);</span>
2385   } else {
<span class="line-modified">2386     st-&gt;print(&quot;%s\n&quot;, j == OSCONTAINER_ERROR ? &quot;not supported&quot; : &quot;unlimited&quot;);</span>
2387   }
2388 
2389   j = OSContainer::memory_soft_limit_in_bytes();
2390   st-&gt;print(&quot;memory_soft_limit_in_bytes: &quot;);
2391   if (j &gt; 0) {
<span class="line-modified">2392     st-&gt;print(JLONG_FORMAT &quot;\n&quot;, j);</span>
2393   } else {
<span class="line-modified">2394     st-&gt;print(&quot;%s\n&quot;, j == OSCONTAINER_ERROR ? &quot;not supported&quot; : &quot;unlimited&quot;);</span>
2395   }
2396 
2397   j = OSContainer::OSContainer::memory_usage_in_bytes();
2398   st-&gt;print(&quot;memory_usage_in_bytes: &quot;);
2399   if (j &gt; 0) {
<span class="line-modified">2400     st-&gt;print(JLONG_FORMAT &quot;\n&quot;, j);</span>
2401   } else {
<span class="line-modified">2402     st-&gt;print(&quot;%s\n&quot;, j == OSCONTAINER_ERROR ? &quot;not supported&quot; : &quot;unlimited&quot;);</span>
2403   }
2404 
2405   j = OSContainer::OSContainer::memory_max_usage_in_bytes();
2406   st-&gt;print(&quot;memory_max_usage_in_bytes: &quot;);
2407   if (j &gt; 0) {
<span class="line-modified">2408     st-&gt;print(JLONG_FORMAT &quot;\n&quot;, j);</span>
2409   } else {
<span class="line-modified">2410     st-&gt;print(&quot;%s\n&quot;, j == OSCONTAINER_ERROR ? &quot;not supported&quot; : &quot;unlimited&quot;);</span>
2411   }
<span class="line-modified">2412   st-&gt;cr();</span>

2413 }
2414 
2415 void os::Linux::print_steal_info(outputStream* st) {
2416   if (has_initial_tick_info) {
2417     CPUPerfTicks pticks;
2418     bool res = os::Linux::get_tick_information(&amp;pticks, -1);
2419 
2420     if (res &amp;&amp; pticks.has_steal_ticks) {
2421       uint64_t steal_ticks_difference = pticks.steal - initial_steal_ticks;
2422       uint64_t total_ticks_difference = pticks.total - initial_total_ticks;
2423       double steal_ticks_perc = 0.0;
2424       if (total_ticks_difference != 0) {
2425         steal_ticks_perc = (double) steal_ticks_difference / total_ticks_difference;
2426       }
2427       st-&gt;print_cr(&quot;Steal ticks since vm start: &quot; UINT64_FORMAT, steal_ticks_difference);
2428       st-&gt;print_cr(&quot;Steal ticks percentage since vm start:%7.3f&quot;, steal_ticks_perc);
2429     }
2430   }
2431 }
2432 
</pre>
<hr />
<pre>
2522   if (ExtensiveErrorReports) {
2523     _print_ascii_file_h(&quot;Maximum cpu frequency&quot;, &quot;/sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_max_freq&quot;, st);
2524     _print_ascii_file_h(&quot;Minimum cpu frequency&quot;, &quot;/sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_min_freq&quot;, st);
2525     _print_ascii_file_h(&quot;Current cpu frequency&quot;, &quot;/sys/devices/system/cpu/cpu0/cpufreq/scaling_cur_freq&quot;, st);
2526   }
2527   // governors are power schemes, see https://wiki.archlinux.org/index.php/CPU_frequency_scaling
2528   if (ExtensiveErrorReports) {
2529     _print_ascii_file_h(&quot;Available governors&quot;, &quot;/sys/devices/system/cpu/cpu0/cpufreq/scaling_available_governors&quot;, st);
2530   }
2531   _print_ascii_file_h(&quot;Current governor&quot;, &quot;/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor&quot;, st);
2532   // Core performance boost, see https://www.kernel.org/doc/Documentation/cpu-freq/boost.txt
2533   // Raise operating frequency of some cores in a multi-core package if certain conditions apply, e.g.
2534   // whole chip is not fully utilized
2535   _print_ascii_file_h(&quot;Core performance/turbo boost&quot;, &quot;/sys/devices/system/cpu/cpufreq/boost&quot;, st);
2536 #endif
2537 }
2538 
2539 void os::pd_print_cpu_info(outputStream* st, char* buf, size_t buflen) {
2540   // Only print the model name if the platform provides this as a summary
2541   if (!print_model_name_and_flags(st, buf, buflen)) {
<span class="line-modified">2542     _print_ascii_file_h(&quot;\n/proc/cpuinfo&quot;, &quot;/proc/cpuinfo&quot;, st);</span>
2543   }

2544   print_sys_devices_cpu_info(st, buf, buflen);
2545 }
2546 
2547 #if defined(AMD64) || defined(IA32) || defined(X32)
2548 const char* search_string = &quot;model name&quot;;
2549 #elif defined(M68K)
2550 const char* search_string = &quot;CPU&quot;;
2551 #elif defined(PPC64)
2552 const char* search_string = &quot;cpu&quot;;
2553 #elif defined(S390)
2554 const char* search_string = &quot;machine =&quot;;
2555 #elif defined(SPARC)
2556 const char* search_string = &quot;cpu&quot;;
2557 #else
2558 const char* search_string = &quot;Processor&quot;;
2559 #endif
2560 
2561 // Parses the cpuinfo file for string representing the model name.
2562 void os::get_summary_cpu_info(char* cpuinfo, size_t length) {
2563   FILE* fp = fopen(&quot;/proc/cpuinfo&quot;, &quot;r&quot;);
</pre>
<hr />
<pre>
2962 bool os::pd_commit_memory(char* addr, size_t size, bool exec) {
2963   return os::Linux::commit_memory_impl(addr, size, exec) == 0;
2964 }
2965 
2966 void os::pd_commit_memory_or_exit(char* addr, size_t size, bool exec,
2967                                   const char* mesg) {
2968   assert(mesg != NULL, &quot;mesg must be specified&quot;);
2969   int err = os::Linux::commit_memory_impl(addr, size, exec);
2970   if (err != 0) {
2971     // the caller wants all commit errors to exit with the specified mesg:
2972     warn_fail_commit_memory(addr, size, exec, err);
2973     vm_exit_out_of_memory(size, OOM_MMAP_ERROR, &quot;%s&quot;, mesg);
2974   }
2975 }
2976 
2977 // Define MAP_HUGETLB here so we can build HotSpot on old systems.
2978 #ifndef MAP_HUGETLB
2979   #define MAP_HUGETLB 0x40000
2980 #endif
2981 









2982 // Define MADV_HUGEPAGE here so we can build HotSpot on old systems.
2983 #ifndef MADV_HUGEPAGE
2984   #define MADV_HUGEPAGE 14
2985 #endif
2986 
2987 int os::Linux::commit_memory_impl(char* addr, size_t size,
2988                                   size_t alignment_hint, bool exec) {
2989   int err = os::Linux::commit_memory_impl(addr, size, exec);
2990   if (err == 0) {
2991     realign_memory(addr, size, alignment_hint);
2992   }
2993   return err;
2994 }
2995 
2996 bool os::pd_commit_memory(char* addr, size_t size, size_t alignment_hint,
2997                           bool exec) {
2998   return os::Linux::commit_memory_impl(addr, size, alignment_hint, exec) == 0;
2999 }
3000 
3001 void os::pd_commit_memory_or_exit(char* addr, size_t size,
</pre>
<hr />
<pre>
3760   if (fscanf(f, &quot;%lx&quot;, &amp;cdm) != 1) {
3761     fclose(f);
3762     return;
3763   }
3764 
3765   long saved_cdm = cdm;
3766   rewind(f);
3767   cdm |= bit;
3768 
3769   if (cdm != saved_cdm) {
3770     fprintf(f, &quot;%#lx&quot;, cdm);
3771   }
3772 
3773   fclose(f);
3774 }
3775 
3776 // Large page support
3777 
3778 static size_t _large_page_size = 0;
3779 
<span class="line-modified">3780 size_t os::Linux::find_large_page_size() {</span>



3781   size_t large_page_size = 0;
3782 
3783   // large_page_size on Linux is used to round up heap size. x86 uses either
3784   // 2M or 4M page, depending on whether PAE (Physical Address Extensions)
3785   // mode is enabled. AMD64/EM64T uses 2M page in 64bit mode. IA64 can use
3786   // page as large as 256M.
3787   //
3788   // Here we try to figure out page size by parsing /proc/meminfo and looking
3789   // for a line with the following format:
3790   //    Hugepagesize:     2048 kB
3791   //
3792   // If we can&#39;t determine the value (e.g. /proc is not mounted, or the text
3793   // format has been changed), we&#39;ll use the largest page size supported by
3794   // the processor.
3795 
3796 #ifndef ZERO
3797   large_page_size =
3798     AARCH64_ONLY(2 * M)
3799     AMD64_ONLY(2 * M)
3800     ARM32_ONLY(2 * M)
3801     IA32_ONLY(4 * M)
3802     IA64_ONLY(256 * M)
3803     PPC_ONLY(4 * M)
<span class="line-modified">3804     S390_ONLY(1 * M)</span>
<span class="line-removed">3805     SPARC_ONLY(4 * M);</span>
3806 #endif // ZERO
3807 
3808   FILE *fp = fopen(&quot;/proc/meminfo&quot;, &quot;r&quot;);
3809   if (fp) {
3810     while (!feof(fp)) {
3811       int x = 0;
3812       char buf[16];
3813       if (fscanf(fp, &quot;Hugepagesize: %d&quot;, &amp;x) == 1) {
3814         if (x &amp;&amp; fgets(buf, sizeof(buf), fp) &amp;&amp; strcmp(buf, &quot; kB\n&quot;) == 0) {
3815           large_page_size = x * K;
3816           break;
3817         }
3818       } else {
3819         // skip to next line
3820         for (;;) {
3821           int ch = fgetc(fp);
3822           if (ch == EOF || ch == (int)&#39;\n&#39;) break;
3823         }
3824       }
3825     }
3826     fclose(fp);
3827   }










3828 
<span class="line-modified">3829   if (!FLAG_IS_DEFAULT(LargePageSizeInBytes) &amp;&amp; LargePageSizeInBytes != large_page_size) {</span>
<span class="line-modified">3830     warning(&quot;Setting LargePageSizeInBytes has no effect on this OS. Large page size is &quot;</span>
<span class="line-modified">3831             SIZE_FORMAT &quot;%s.&quot;, byte_size_in_proper_unit(large_page_size),</span>
<span class="line-removed">3832             proper_unit_for_byte_size(large_page_size));</span>
3833   }
3834 
<span class="line-modified">3835   return large_page_size;</span>













3836 }
3837 
3838 size_t os::Linux::setup_large_page_size() {
<span class="line-modified">3839   _large_page_size = Linux::find_large_page_size();</span>













3840   const size_t default_page_size = (size_t)Linux::page_size();
3841   if (_large_page_size &gt; default_page_size) {
3842     _page_sizes[0] = _large_page_size;
3843     _page_sizes[1] = default_page_size;
3844     _page_sizes[2] = 0;
3845   }
3846 
3847   return _large_page_size;
3848 }
3849 




3850 bool os::Linux::setup_large_page_type(size_t page_size) {
3851   if (FLAG_IS_DEFAULT(UseHugeTLBFS) &amp;&amp;
3852       FLAG_IS_DEFAULT(UseSHM) &amp;&amp;
3853       FLAG_IS_DEFAULT(UseTransparentHugePages)) {
3854 
3855     // The type of large pages has not been specified by the user.
3856 
3857     // Try UseHugeTLBFS and then UseSHM.
3858     UseHugeTLBFS = UseSHM = true;
3859 
3860     // Don&#39;t try UseTransparentHugePages since there are known
3861     // performance issues with it turned on. This might change in the future.
3862     UseTransparentHugePages = false;
3863   }
3864 
3865   if (UseTransparentHugePages) {
3866     bool warn_on_failure = !FLAG_IS_DEFAULT(UseTransparentHugePages);
3867     if (transparent_huge_pages_sanity_check(warn_on_failure, page_size)) {
3868       UseHugeTLBFS = false;
3869       UseSHM = false;
</pre>
<hr />
<pre>
4058       (!FLAG_IS_DEFAULT(UseLargePages) ||
4059        !FLAG_IS_DEFAULT(UseHugeTLBFS) ||
4060        !FLAG_IS_DEFAULT(LargePageSizeInBytes));
4061 
4062   if (warn_on_failure) {
4063     char msg[128];
4064     jio_snprintf(msg, sizeof(msg), &quot;Failed to reserve large pages memory req_addr: &quot;
4065                  PTR_FORMAT &quot; bytes: &quot; SIZE_FORMAT &quot; (errno = %d).&quot;, req_addr, bytes, error);
4066     warning(&quot;%s&quot;, msg);
4067   }
4068 }
4069 
4070 char* os::Linux::reserve_memory_special_huge_tlbfs_only(size_t bytes,
4071                                                         char* req_addr,
4072                                                         bool exec) {
4073   assert(UseLargePages &amp;&amp; UseHugeTLBFS, &quot;only for Huge TLBFS large pages&quot;);
4074   assert(is_aligned(bytes, os::large_page_size()), &quot;Unaligned size&quot;);
4075   assert(is_aligned(req_addr, os::large_page_size()), &quot;Unaligned address&quot;);
4076 
4077   int prot = exec ? PROT_READ|PROT_WRITE|PROT_EXEC : PROT_READ|PROT_WRITE;
<span class="line-modified">4078   char* addr = (char*)::mmap(req_addr, bytes, prot,</span>
<span class="line-modified">4079                              MAP_PRIVATE|MAP_ANONYMOUS|MAP_HUGETLB,</span>
<span class="line-modified">4080                              -1, 0);</span>



4081 
4082   if (addr == MAP_FAILED) {
4083     warn_on_large_pages_failure(req_addr, bytes, errno);
4084     return NULL;
4085   }
4086 
4087   assert(is_aligned(addr, os::large_page_size()), &quot;Must be&quot;);
4088 
4089   return addr;
4090 }
4091 
4092 // Reserve memory using mmap(MAP_HUGETLB).
4093 //  - bytes shall be a multiple of alignment.
4094 //  - req_addr can be NULL. If not NULL, it must be a multiple of alignment.
4095 //  - alignment sets the alignment at which memory shall be allocated.
4096 //     It must be a multiple of allocation granularity.
4097 // Returns address of memory or NULL. If req_addr was not NULL, will only return
4098 //  req_addr or NULL.
4099 char* os::Linux::reserve_memory_special_huge_tlbfs_mixed(size_t bytes,
4100                                                          size_t alignment,
</pre>
<hr />
<pre>
4116   assert(is_aligned(start, alignment), &quot;Must be&quot;);
4117 
4118   char* end = start + bytes;
4119 
4120   // Find the regions of the allocated chunk that can be promoted to large pages.
4121   char* lp_start = align_up(start, large_page_size);
4122   char* lp_end   = align_down(end, large_page_size);
4123 
4124   size_t lp_bytes = lp_end - lp_start;
4125 
4126   assert(is_aligned(lp_bytes, large_page_size), &quot;Must be&quot;);
4127 
4128   if (lp_bytes == 0) {
4129     // The mapped region doesn&#39;t even span the start and the end of a large page.
4130     // Fall back to allocate a non-special area.
4131     ::munmap(start, end - start);
4132     return NULL;
4133   }
4134 
4135   int prot = exec ? PROT_READ|PROT_WRITE|PROT_EXEC : PROT_READ|PROT_WRITE;
<span class="line-modified">4136 </span>
4137   void* result;
4138 
4139   // Commit small-paged leading area.
4140   if (start != lp_start) {
<span class="line-modified">4141     result = ::mmap(start, lp_start - start, prot,</span>
<span class="line-removed">4142                     MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED,</span>
<span class="line-removed">4143                     -1, 0);</span>
4144     if (result == MAP_FAILED) {
4145       ::munmap(lp_start, end - lp_start);
4146       return NULL;
4147     }
4148   }
4149 
4150   // Commit large-paged area.
<span class="line-modified">4151   result = ::mmap(lp_start, lp_bytes, prot,</span>
<span class="line-modified">4152                   MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED|MAP_HUGETLB,</span>
<span class="line-modified">4153                   -1, 0);</span>




4154   if (result == MAP_FAILED) {
4155     warn_on_large_pages_failure(lp_start, lp_bytes, errno);
4156     // If the mmap above fails, the large pages region will be unmapped and we
4157     // have regions before and after with small pages. Release these regions.
4158     //
4159     // |  mapped  |  unmapped  |  mapped  |
4160     // ^          ^            ^          ^
4161     // start      lp_start     lp_end     end
4162     //
4163     ::munmap(start, lp_start - start);
4164     ::munmap(lp_end, end - lp_end);
4165     return NULL;
4166   }
4167 
4168   // Commit small-paged trailing area.
4169   if (lp_end != end) {
4170     result = ::mmap(lp_end, end - lp_end, prot,
4171                     MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED,
4172                     -1, 0);
4173     if (result == MAP_FAILED) {
</pre>
</td>
<td>
<hr />
<pre>
 136   FILE_BACKED_PVT_BIT = 1 &lt;&lt; 2,
 137   FILE_BACKED_SHARED_BIT = 1 &lt;&lt; 3,
 138   LARGEPAGES_BIT = 1 &lt;&lt; 6,
 139   DAX_SHARED_BIT = 1 &lt;&lt; 8
 140 };
 141 
 142 ////////////////////////////////////////////////////////////////////////////////
 143 // global variables
 144 julong os::Linux::_physical_memory = 0;
 145 
 146 address   os::Linux::_initial_thread_stack_bottom = NULL;
 147 uintptr_t os::Linux::_initial_thread_stack_size   = 0;
 148 
 149 int (*os::Linux::_pthread_getcpuclockid)(pthread_t, clockid_t *) = NULL;
 150 int (*os::Linux::_pthread_setname_np)(pthread_t, const char*) = NULL;
 151 pthread_t os::Linux::_main_thread;
 152 int os::Linux::_page_size = -1;
 153 bool os::Linux::_supports_fast_thread_cpu_time = false;
 154 const char * os::Linux::_glibc_version = &quot;unknown&quot;;
 155 const char * os::Linux::_libpthread_version = &quot;unknown&quot;;
<span class="line-added"> 156 size_t os::Linux::_default_large_page_size = 0;</span>
 157 
 158 static jlong initial_time_count=0;
 159 
 160 static int clock_tics_per_sec = 100;
 161 
 162 // If the VM might have been created on the primordial thread, we need to resolve the
 163 // primordial thread stack bounds and check if the current thread might be the
 164 // primordial thread in places. If we know that the primordial thread is never used,
 165 // such as when the VM was created by one of the standard java launchers, we can
 166 // avoid this
 167 static bool suppress_primordial_thread_resolution = false;
 168 
 169 // For diagnostics to print a message once. see run_periodic_checks
 170 static sigset_t check_signal_done;
 171 static bool check_signals = true;
 172 
 173 // Signal number used to suspend/resume a thread
 174 
 175 // do not use any signal number less than SIGSEGV, see 4355769
 176 static int SR_signum = SIGUSR2;
</pre>
<hr />
<pre>
1362 }
1363 
1364 jlong os::elapsed_frequency() {
1365   return NANOSECS_PER_SEC; // nanosecond resolution
1366 }
1367 
1368 bool os::supports_vtime() { return true; }
1369 
1370 double os::elapsedVTime() {
1371   struct rusage usage;
1372   int retval = getrusage(RUSAGE_THREAD, &amp;usage);
1373   if (retval == 0) {
1374     return (double) (usage.ru_utime.tv_sec + usage.ru_stime.tv_sec) + (double) (usage.ru_utime.tv_usec + usage.ru_stime.tv_usec) / (1000 * 1000);
1375   } else {
1376     // better than nothing, but not much
1377     return elapsedTime();
1378   }
1379 }
1380 
1381 jlong os::javaTimeMillis() {
<span class="line-modified">1382   if (os::Posix::supports_clock_gettime()) {</span>
<span class="line-modified">1383     struct timespec ts;</span>
<span class="line-modified">1384     int status = os::Posix::clock_gettime(CLOCK_REALTIME, &amp;ts);</span>
<span class="line-modified">1385     assert_status(status == 0, status, &quot;gettime error&quot;);</span>
<span class="line-added">1386     return jlong(ts.tv_sec) * MILLIUNITS +</span>
<span class="line-added">1387            jlong(ts.tv_nsec) / NANOUNITS_PER_MILLIUNIT;</span>
<span class="line-added">1388   } else {</span>
<span class="line-added">1389     timeval time;</span>
<span class="line-added">1390     int status = gettimeofday(&amp;time, NULL);</span>
<span class="line-added">1391     assert(status != -1, &quot;linux error&quot;);</span>
<span class="line-added">1392     return jlong(time.tv_sec) * MILLIUNITS  +</span>
<span class="line-added">1393            jlong(time.tv_usec) / (MICROUNITS / MILLIUNITS);</span>
<span class="line-added">1394   }</span>
1395 }
1396 
1397 void os::javaTimeSystemUTC(jlong &amp;seconds, jlong &amp;nanos) {
<span class="line-modified">1398   if (os::Posix::supports_clock_gettime()) {</span>
<span class="line-modified">1399     struct timespec ts;</span>
<span class="line-modified">1400     int status = os::Posix::clock_gettime(CLOCK_REALTIME, &amp;ts);</span>
<span class="line-modified">1401     assert_status(status == 0, status, &quot;gettime error&quot;);</span>
<span class="line-modified">1402     seconds = jlong(ts.tv_sec);</span>
<span class="line-added">1403     nanos = jlong(ts.tv_nsec);</span>
<span class="line-added">1404   } else {</span>
<span class="line-added">1405     timeval time;</span>
<span class="line-added">1406     int status = gettimeofday(&amp;time, NULL);</span>
<span class="line-added">1407     assert(status != -1, &quot;linux error&quot;);</span>
<span class="line-added">1408     seconds = jlong(time.tv_sec);</span>
<span class="line-added">1409     nanos = jlong(time.tv_usec) * (NANOUNITS / MICROUNITS);</span>
<span class="line-added">1410   }</span>
1411 }
1412 
1413 void os::Linux::fast_thread_clock_init() {
1414   if (!UseLinuxPosixThreadCPUClocks) {
1415     return;
1416   }
1417   clockid_t clockid;
1418   struct timespec tp;
1419   int (*pthread_getcpuclockid_func)(pthread_t, clockid_t *) =
1420       (int(*)(pthread_t, clockid_t *)) dlsym(RTLD_DEFAULT, &quot;pthread_getcpuclockid&quot;);
1421 
1422   // Switch to using fast clocks for thread cpu time if
1423   // the clock_getres() returns 0 error code.
1424   // Note, that some kernels may support the current thread
1425   // clock (CLOCK_THREAD_CPUTIME_ID) but not the clocks
1426   // returned by the pthread_getcpuclockid().
1427   // If the fast Posix clocks are supported then the clock_getres()
1428   // must return at least tp.tv_sec == 0 which means a resolution
1429   // better than 1 sec. This is extra check for reliability.
1430 
</pre>
<hr />
<pre>
2055   if (fd == -1) {
2056     return false;
2057   }
2058 
2059   if (hdr != NULL) {
2060     st-&gt;print_cr(&quot;%s&quot;, hdr);
2061   }
2062 
2063   char buf[33];
2064   int bytes;
2065   buf[32] = &#39;\0&#39;;
2066   while ((bytes = ::read(fd, buf, sizeof(buf)-1)) &gt; 0) {
2067     st-&gt;print_raw(buf, bytes);
2068   }
2069 
2070   ::close(fd);
2071 
2072   return true;
2073 }
2074 
<span class="line-modified">2075 static void _print_ascii_file_h(const char* header, const char* filename, outputStream* st, bool same_line = true) {</span>
<span class="line-modified">2076   st-&gt;print(&quot;%s:%c&quot;, header, same_line ? &#39; &#39; : &#39;\n&#39;);</span>
2077   if (!_print_ascii_file(filename, st)) {
2078     st-&gt;print_cr(&quot;&lt;Not Available&gt;&quot;);
2079   }
2080 }
2081 
2082 void os::print_dll_info(outputStream *st) {
2083   st-&gt;print_cr(&quot;Dynamic libraries:&quot;);
2084 
2085   char fname[32];
2086   pid_t pid = os::Linux::gettid();
2087 
2088   jio_snprintf(fname, sizeof(fname), &quot;/proc/%d/maps&quot;, pid);
2089 
2090   if (!_print_ascii_file(fname, st)) {
<span class="line-modified">2091     st-&gt;print_cr(&quot;Can not get library information for pid = %d&quot;, pid);</span>
2092   }
2093 }
2094 
<span class="line-modified">2095 struct loaded_modules_info_param {</span>
<span class="line-modified">2096   os::LoadedModulesCallbackFunc callback;</span>
<span class="line-modified">2097   void *param;</span>
<span class="line-modified">2098 };</span>
<span class="line-modified">2099 </span>
<span class="line-modified">2100 static int dl_iterate_callback(struct dl_phdr_info *info, size_t size, void *data) {</span>
<span class="line-modified">2101   if ((info-&gt;dlpi_name == NULL) || (*info-&gt;dlpi_name == &#39;\0&#39;)) {</span>
<span class="line-modified">2102     return 0;</span>
<span class="line-modified">2103   }</span>
<span class="line-modified">2104 </span>
<span class="line-modified">2105   struct loaded_modules_info_param *callback_param = reinterpret_cast&lt;struct loaded_modules_info_param *&gt;(data);</span>
<span class="line-modified">2106   address base = NULL;</span>
<span class="line-modified">2107   address top = NULL;</span>
<span class="line-modified">2108   for (int idx = 0; idx &lt; info-&gt;dlpi_phnum; idx++) {</span>
<span class="line-modified">2109     const ElfW(Phdr) *phdr = info-&gt;dlpi_phdr + idx;</span>
<span class="line-modified">2110     if (phdr-&gt;p_type == PT_LOAD) {</span>
<span class="line-modified">2111       address raw_phdr_base = reinterpret_cast&lt;address&gt;(info-&gt;dlpi_addr + phdr-&gt;p_vaddr);</span>
<span class="line-modified">2112 </span>
<span class="line-modified">2113       address phdr_base = align_down(raw_phdr_base, phdr-&gt;p_align);</span>
<span class="line-modified">2114       if ((base == NULL) || (base &gt; phdr_base)) {</span>
<span class="line-modified">2115         base = phdr_base;</span>
<span class="line-modified">2116       }</span>
<span class="line-modified">2117 </span>
<span class="line-modified">2118       address phdr_top = align_up(raw_phdr_base + phdr-&gt;p_memsz, phdr-&gt;p_align);</span>
<span class="line-modified">2119       if ((top == NULL) || (top &lt; phdr_top)) {</span>
<span class="line-modified">2120         top = phdr_top;</span>



2121       }
2122     }
<span class="line-modified">2123   }</span>
<span class="line-modified">2124 </span>
<span class="line-added">2125   return callback_param-&gt;callback(info-&gt;dlpi_name, base, top, callback_param-&gt;param);</span>
<span class="line-added">2126 }</span>
<span class="line-added">2127 </span>
<span class="line-added">2128 int os::get_loaded_modules_info(os::LoadedModulesCallbackFunc callback, void *param) {</span>
<span class="line-added">2129   struct loaded_modules_info_param callback_param = {callback, param};</span>
2130   return dl_iterate_phdr(&amp;dl_iterate_callback, &amp;callback_param);
2131 }
2132 
2133 void os::print_os_info_brief(outputStream* st) {
2134   os::Linux::print_distro_info(st);
2135 
2136   os::Posix::print_uname_info(st);
2137 
2138   os::Linux::print_libversion_info(st);
2139 
2140 }
2141 
2142 void os::print_os_info(outputStream* st) {
<span class="line-modified">2143   st-&gt;print_cr(&quot;OS:&quot;);</span>
2144 
2145   os::Linux::print_distro_info(st);
2146 
2147   os::Posix::print_uname_info(st);
2148 
2149   os::Linux::print_uptime_info(st);
2150 
2151   // Print warning if unsafe chroot environment detected
2152   if (unsafe_chroot_detected) {
<span class="line-modified">2153     st-&gt;print_cr(&quot;WARNING!! %s&quot;, unstable_chroot_error);</span>

2154   }
2155 
2156   os::Linux::print_libversion_info(st);
2157 
2158   os::Posix::print_rlimit_info(st);
2159 
2160   os::Posix::print_load_average(st);
<span class="line-added">2161   st-&gt;cr();</span>
2162 
2163   os::Linux::print_full_memory_info(st);
<span class="line-added">2164   st-&gt;cr();</span>
2165 
2166   os::Linux::print_proc_sys_info(st);
<span class="line-added">2167   st-&gt;cr();</span>
2168 
<span class="line-modified">2169   if (os::Linux::print_ld_preload_file(st)) {</span>
<span class="line-added">2170     st-&gt;cr();</span>
<span class="line-added">2171   }</span>
2172 
<span class="line-modified">2173   if (os::Linux::print_container_info(st)) {</span>
<span class="line-added">2174     st-&gt;cr();</span>
<span class="line-added">2175   }</span>
2176 
2177   VM_Version::print_platform_virtualization_info(st);
2178 
2179   os::Linux::print_steal_info(st);
2180 }
2181 
2182 // Try to identify popular distros.
2183 // Most Linux distributions have a /etc/XXX-release file, which contains
2184 // the OS version string. Newer Linux distributions have a /etc/lsb-release
2185 // file that also contains the OS version string. Some have more than one
2186 // /etc/XXX-release file (e.g. Mandrake has both /etc/mandrake-release and
2187 // /etc/redhat-release.), so the order is important.
2188 // Any Linux that is based on Redhat (i.e. Oracle, Mandrake, Sun JDS...) have
2189 // their own specific XXX-release file as well as a redhat-release file.
2190 // Because of this the XXX-release file needs to be searched for before the
2191 // redhat-release file.
2192 // Since Red Hat and SuSE have an lsb-release file that is not very descriptive the
2193 // search for redhat-release / SuSE-release needs to be before lsb-release.
2194 // Since the lsb-release file is the new standard it needs to be searched
2195 // before the older style release files.
</pre>
<hr />
<pre>
2216   &quot;/etc/system-release&quot;,
2217   &quot;/etc/os-release&quot;,
2218   NULL };
2219 
2220 void os::Linux::print_distro_info(outputStream* st) {
2221   for (int i = 0;; i++) {
2222     const char* file = distro_files[i];
2223     if (file == NULL) {
2224       break;  // done
2225     }
2226     // If file prints, we found it.
2227     if (_print_ascii_file(file, st)) {
2228       return;
2229     }
2230   }
2231 
2232   if (file_exists(&quot;/etc/debian_version&quot;)) {
2233     st-&gt;print(&quot;Debian &quot;);
2234     _print_ascii_file(&quot;/etc/debian_version&quot;, st);
2235   } else {
<span class="line-modified">2236     st-&gt;print_cr(&quot;Linux&quot;);</span>
2237   }

2238 }
2239 
2240 static void parse_os_info_helper(FILE* fp, char* distro, size_t length, bool get_first_line) {
2241   char buf[256];
2242   while (fgets(buf, sizeof(buf), fp)) {
2243     // Edit out extra stuff in expected format
2244     if (strstr(buf, &quot;DISTRIB_DESCRIPTION=&quot;) != NULL || strstr(buf, &quot;PRETTY_NAME=&quot;) != NULL) {
2245       char* ptr = strstr(buf, &quot;\&quot;&quot;);  // the name is in quotes
2246       if (ptr != NULL) {
2247         ptr++; // go beyond first quote
2248         char* nl = strchr(ptr, &#39;\&quot;&#39;);
2249         if (nl != NULL) *nl = &#39;\0&#39;;
2250         strncpy(distro, ptr, length);
2251       } else {
2252         ptr = strstr(buf, &quot;=&quot;);
2253         ptr++; // go beyond equals then
2254         char* nl = strchr(ptr, &#39;\n&#39;);
2255         if (nl != NULL) *nl = &#39;\0&#39;;
2256         strncpy(distro, ptr, length);
2257       }
</pre>
<hr />
<pre>
2286       break; // ran out of distro_files
2287     }
2288     if (file_exists(file)) {
2289       parse_os_info(buf, buflen, file);
2290       return;
2291     }
2292   }
2293   // special case for debian
2294   if (file_exists(&quot;/etc/debian_version&quot;)) {
2295     strncpy(buf, &quot;Debian &quot;, buflen);
2296     if (buflen &gt; 7) {
2297       parse_os_info(&amp;buf[7], buflen-7, &quot;/etc/debian_version&quot;);
2298     }
2299   } else {
2300     strncpy(buf, &quot;Linux&quot;, buflen);
2301   }
2302 }
2303 
2304 void os::Linux::print_libversion_info(outputStream* st) {
2305   // libc, pthread
<span class="line-modified">2306   st-&gt;print(&quot;libc: &quot;);</span>
2307   st-&gt;print(&quot;%s &quot;, os::Linux::glibc_version());
2308   st-&gt;print(&quot;%s &quot;, os::Linux::libpthread_version());
2309   st-&gt;cr();
2310 }
2311 
2312 void os::Linux::print_proc_sys_info(outputStream* st) {

2313   _print_ascii_file_h(&quot;/proc/sys/kernel/threads-max (system-wide limit on the number of threads)&quot;,
2314                       &quot;/proc/sys/kernel/threads-max&quot;, st);
2315   _print_ascii_file_h(&quot;/proc/sys/vm/max_map_count (maximum number of memory map areas a process may have)&quot;,
2316                       &quot;/proc/sys/vm/max_map_count&quot;, st);
2317   _print_ascii_file_h(&quot;/proc/sys/kernel/pid_max (system-wide limit on number of process identifiers)&quot;,
2318                       &quot;/proc/sys/kernel/pid_max&quot;, st);
2319 }
2320 
2321 void os::Linux::print_full_memory_info(outputStream* st) {
<span class="line-modified">2322   _print_ascii_file_h(&quot;/proc/meminfo&quot;, &quot;/proc/meminfo&quot;, st, false);</span>
2323   st-&gt;cr();
2324 
2325   // some information regarding THPs; for details see
2326   // https://www.kernel.org/doc/Documentation/vm/transhuge.txt
2327   _print_ascii_file_h(&quot;/sys/kernel/mm/transparent_hugepage/enabled&quot;,
2328                       &quot;/sys/kernel/mm/transparent_hugepage/enabled&quot;, st);
2329   _print_ascii_file_h(&quot;/sys/kernel/mm/transparent_hugepage/defrag (defrag/compaction efforts parameter)&quot;,
2330                       &quot;/sys/kernel/mm/transparent_hugepage/defrag&quot;, st);
2331 }
2332 
<span class="line-modified">2333 bool os::Linux::print_ld_preload_file(outputStream* st) {</span>
<span class="line-modified">2334   return _print_ascii_file(&quot;/etc/ld.so.preload&quot;, st, &quot;/etc/ld.so.preload:&quot;);</span>

2335 }
2336 
2337 void os::Linux::print_uptime_info(outputStream* st) {
2338   struct sysinfo sinfo;
2339   int ret = sysinfo(&amp;sinfo);
2340   if (ret == 0) {
2341     os::print_dhm(st, &quot;OS uptime:&quot;, (long) sinfo.uptime);
2342   }
2343 }
2344 
<span class="line-modified">2345 bool os::Linux::print_container_info(outputStream* st) {</span>

2346   if (!OSContainer::is_containerized()) {
<span class="line-modified">2347     return false;</span>
2348   }
2349 
<span class="line-modified">2350   st-&gt;print_cr(&quot;container (cgroup) information:&quot;);</span>
2351 
2352   const char *p_ct = OSContainer::container_type();
<span class="line-modified">2353   st-&gt;print_cr(&quot;container_type: %s&quot;, p_ct != NULL ? p_ct : &quot;not supported&quot;);</span>
2354 
2355   char *p = OSContainer::cpu_cpuset_cpus();
<span class="line-modified">2356   st-&gt;print_cr(&quot;cpu_cpuset_cpus: %s&quot;, p != NULL ? p : &quot;not supported&quot;);</span>
2357   free(p);
2358 
2359   p = OSContainer::cpu_cpuset_memory_nodes();
<span class="line-modified">2360   st-&gt;print_cr(&quot;cpu_memory_nodes: %s&quot;, p != NULL ? p : &quot;not supported&quot;);</span>
2361   free(p);
2362 
2363   int i = OSContainer::active_processor_count();
2364   st-&gt;print(&quot;active_processor_count: &quot;);
2365   if (i &gt; 0) {
<span class="line-modified">2366     st-&gt;print_cr(&quot;%d&quot;, i);</span>
2367   } else {
<span class="line-modified">2368     st-&gt;print_cr(&quot;not supported&quot;);</span>
2369   }
2370 
2371   i = OSContainer::cpu_quota();
2372   st-&gt;print(&quot;cpu_quota: &quot;);
2373   if (i &gt; 0) {
<span class="line-modified">2374     st-&gt;print_cr(&quot;%d&quot;, i);</span>
2375   } else {
<span class="line-modified">2376     st-&gt;print_cr(&quot;%s&quot;, i == OSCONTAINER_ERROR ? &quot;not supported&quot; : &quot;no quota&quot;);</span>
2377   }
2378 
2379   i = OSContainer::cpu_period();
2380   st-&gt;print(&quot;cpu_period: &quot;);
2381   if (i &gt; 0) {
<span class="line-modified">2382     st-&gt;print_cr(&quot;%d&quot;, i);</span>
2383   } else {
<span class="line-modified">2384     st-&gt;print_cr(&quot;%s&quot;, i == OSCONTAINER_ERROR ? &quot;not supported&quot; : &quot;no period&quot;);</span>
2385   }
2386 
2387   i = OSContainer::cpu_shares();
2388   st-&gt;print(&quot;cpu_shares: &quot;);
2389   if (i &gt; 0) {
<span class="line-modified">2390     st-&gt;print_cr(&quot;%d&quot;, i);</span>
2391   } else {
<span class="line-modified">2392     st-&gt;print_cr(&quot;%s&quot;, i == OSCONTAINER_ERROR ? &quot;not supported&quot; : &quot;no shares&quot;);</span>
2393   }
2394 
2395   jlong j = OSContainer::memory_limit_in_bytes();
2396   st-&gt;print(&quot;memory_limit_in_bytes: &quot;);
2397   if (j &gt; 0) {
<span class="line-modified">2398     st-&gt;print_cr(JLONG_FORMAT, j);</span>
2399   } else {
<span class="line-modified">2400     st-&gt;print_cr(&quot;%s&quot;, j == OSCONTAINER_ERROR ? &quot;not supported&quot; : &quot;unlimited&quot;);</span>
2401   }
2402 
2403   j = OSContainer::memory_and_swap_limit_in_bytes();
2404   st-&gt;print(&quot;memory_and_swap_limit_in_bytes: &quot;);
2405   if (j &gt; 0) {
<span class="line-modified">2406     st-&gt;print_cr(JLONG_FORMAT, j);</span>
2407   } else {
<span class="line-modified">2408     st-&gt;print_cr(&quot;%s&quot;, j == OSCONTAINER_ERROR ? &quot;not supported&quot; : &quot;unlimited&quot;);</span>
2409   }
2410 
2411   j = OSContainer::memory_soft_limit_in_bytes();
2412   st-&gt;print(&quot;memory_soft_limit_in_bytes: &quot;);
2413   if (j &gt; 0) {
<span class="line-modified">2414     st-&gt;print_cr(JLONG_FORMAT, j);</span>
2415   } else {
<span class="line-modified">2416     st-&gt;print_cr(&quot;%s&quot;, j == OSCONTAINER_ERROR ? &quot;not supported&quot; : &quot;unlimited&quot;);</span>
2417   }
2418 
2419   j = OSContainer::OSContainer::memory_usage_in_bytes();
2420   st-&gt;print(&quot;memory_usage_in_bytes: &quot;);
2421   if (j &gt; 0) {
<span class="line-modified">2422     st-&gt;print_cr(JLONG_FORMAT, j);</span>
2423   } else {
<span class="line-modified">2424     st-&gt;print_cr(&quot;%s&quot;, j == OSCONTAINER_ERROR ? &quot;not supported&quot; : &quot;unlimited&quot;);</span>
2425   }
2426 
2427   j = OSContainer::OSContainer::memory_max_usage_in_bytes();
2428   st-&gt;print(&quot;memory_max_usage_in_bytes: &quot;);
2429   if (j &gt; 0) {
<span class="line-modified">2430     st-&gt;print_cr(JLONG_FORMAT, j);</span>
2431   } else {
<span class="line-modified">2432     st-&gt;print_cr(&quot;%s&quot;, j == OSCONTAINER_ERROR ? &quot;not supported&quot; : &quot;unlimited&quot;);</span>
2433   }
<span class="line-modified">2434 </span>
<span class="line-added">2435   return true;</span>
2436 }
2437 
2438 void os::Linux::print_steal_info(outputStream* st) {
2439   if (has_initial_tick_info) {
2440     CPUPerfTicks pticks;
2441     bool res = os::Linux::get_tick_information(&amp;pticks, -1);
2442 
2443     if (res &amp;&amp; pticks.has_steal_ticks) {
2444       uint64_t steal_ticks_difference = pticks.steal - initial_steal_ticks;
2445       uint64_t total_ticks_difference = pticks.total - initial_total_ticks;
2446       double steal_ticks_perc = 0.0;
2447       if (total_ticks_difference != 0) {
2448         steal_ticks_perc = (double) steal_ticks_difference / total_ticks_difference;
2449       }
2450       st-&gt;print_cr(&quot;Steal ticks since vm start: &quot; UINT64_FORMAT, steal_ticks_difference);
2451       st-&gt;print_cr(&quot;Steal ticks percentage since vm start:%7.3f&quot;, steal_ticks_perc);
2452     }
2453   }
2454 }
2455 
</pre>
<hr />
<pre>
2545   if (ExtensiveErrorReports) {
2546     _print_ascii_file_h(&quot;Maximum cpu frequency&quot;, &quot;/sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_max_freq&quot;, st);
2547     _print_ascii_file_h(&quot;Minimum cpu frequency&quot;, &quot;/sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_min_freq&quot;, st);
2548     _print_ascii_file_h(&quot;Current cpu frequency&quot;, &quot;/sys/devices/system/cpu/cpu0/cpufreq/scaling_cur_freq&quot;, st);
2549   }
2550   // governors are power schemes, see https://wiki.archlinux.org/index.php/CPU_frequency_scaling
2551   if (ExtensiveErrorReports) {
2552     _print_ascii_file_h(&quot;Available governors&quot;, &quot;/sys/devices/system/cpu/cpu0/cpufreq/scaling_available_governors&quot;, st);
2553   }
2554   _print_ascii_file_h(&quot;Current governor&quot;, &quot;/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor&quot;, st);
2555   // Core performance boost, see https://www.kernel.org/doc/Documentation/cpu-freq/boost.txt
2556   // Raise operating frequency of some cores in a multi-core package if certain conditions apply, e.g.
2557   // whole chip is not fully utilized
2558   _print_ascii_file_h(&quot;Core performance/turbo boost&quot;, &quot;/sys/devices/system/cpu/cpufreq/boost&quot;, st);
2559 #endif
2560 }
2561 
2562 void os::pd_print_cpu_info(outputStream* st, char* buf, size_t buflen) {
2563   // Only print the model name if the platform provides this as a summary
2564   if (!print_model_name_and_flags(st, buf, buflen)) {
<span class="line-modified">2565     _print_ascii_file_h(&quot;/proc/cpuinfo&quot;, &quot;/proc/cpuinfo&quot;, st, false);</span>
2566   }
<span class="line-added">2567   st-&gt;cr();</span>
2568   print_sys_devices_cpu_info(st, buf, buflen);
2569 }
2570 
2571 #if defined(AMD64) || defined(IA32) || defined(X32)
2572 const char* search_string = &quot;model name&quot;;
2573 #elif defined(M68K)
2574 const char* search_string = &quot;CPU&quot;;
2575 #elif defined(PPC64)
2576 const char* search_string = &quot;cpu&quot;;
2577 #elif defined(S390)
2578 const char* search_string = &quot;machine =&quot;;
2579 #elif defined(SPARC)
2580 const char* search_string = &quot;cpu&quot;;
2581 #else
2582 const char* search_string = &quot;Processor&quot;;
2583 #endif
2584 
2585 // Parses the cpuinfo file for string representing the model name.
2586 void os::get_summary_cpu_info(char* cpuinfo, size_t length) {
2587   FILE* fp = fopen(&quot;/proc/cpuinfo&quot;, &quot;r&quot;);
</pre>
<hr />
<pre>
2986 bool os::pd_commit_memory(char* addr, size_t size, bool exec) {
2987   return os::Linux::commit_memory_impl(addr, size, exec) == 0;
2988 }
2989 
2990 void os::pd_commit_memory_or_exit(char* addr, size_t size, bool exec,
2991                                   const char* mesg) {
2992   assert(mesg != NULL, &quot;mesg must be specified&quot;);
2993   int err = os::Linux::commit_memory_impl(addr, size, exec);
2994   if (err != 0) {
2995     // the caller wants all commit errors to exit with the specified mesg:
2996     warn_fail_commit_memory(addr, size, exec, err);
2997     vm_exit_out_of_memory(size, OOM_MMAP_ERROR, &quot;%s&quot;, mesg);
2998   }
2999 }
3000 
3001 // Define MAP_HUGETLB here so we can build HotSpot on old systems.
3002 #ifndef MAP_HUGETLB
3003   #define MAP_HUGETLB 0x40000
3004 #endif
3005 
<span class="line-added">3006 // If mmap flags are set with MAP_HUGETLB and the system supports multiple</span>
<span class="line-added">3007 // huge page sizes, flag bits [26:31] can be used to encode the log2 of the</span>
<span class="line-added">3008 // desired huge page size. Otherwise, the system&#39;s default huge page size will be used.</span>
<span class="line-added">3009 // See mmap(2) man page for more info (since Linux 3.8).</span>
<span class="line-added">3010 // https://lwn.net/Articles/533499/</span>
<span class="line-added">3011 #ifndef MAP_HUGE_SHIFT</span>
<span class="line-added">3012   #define MAP_HUGE_SHIFT 26</span>
<span class="line-added">3013 #endif</span>
<span class="line-added">3014 </span>
3015 // Define MADV_HUGEPAGE here so we can build HotSpot on old systems.
3016 #ifndef MADV_HUGEPAGE
3017   #define MADV_HUGEPAGE 14
3018 #endif
3019 
3020 int os::Linux::commit_memory_impl(char* addr, size_t size,
3021                                   size_t alignment_hint, bool exec) {
3022   int err = os::Linux::commit_memory_impl(addr, size, exec);
3023   if (err == 0) {
3024     realign_memory(addr, size, alignment_hint);
3025   }
3026   return err;
3027 }
3028 
3029 bool os::pd_commit_memory(char* addr, size_t size, size_t alignment_hint,
3030                           bool exec) {
3031   return os::Linux::commit_memory_impl(addr, size, alignment_hint, exec) == 0;
3032 }
3033 
3034 void os::pd_commit_memory_or_exit(char* addr, size_t size,
</pre>
<hr />
<pre>
3793   if (fscanf(f, &quot;%lx&quot;, &amp;cdm) != 1) {
3794     fclose(f);
3795     return;
3796   }
3797 
3798   long saved_cdm = cdm;
3799   rewind(f);
3800   cdm |= bit;
3801 
3802   if (cdm != saved_cdm) {
3803     fprintf(f, &quot;%#lx&quot;, cdm);
3804   }
3805 
3806   fclose(f);
3807 }
3808 
3809 // Large page support
3810 
3811 static size_t _large_page_size = 0;
3812 
<span class="line-modified">3813 size_t os::Linux::find_default_large_page_size() {</span>
<span class="line-added">3814   if (_default_large_page_size != 0) {</span>
<span class="line-added">3815     return _default_large_page_size;</span>
<span class="line-added">3816   }</span>
3817   size_t large_page_size = 0;
3818 
3819   // large_page_size on Linux is used to round up heap size. x86 uses either
3820   // 2M or 4M page, depending on whether PAE (Physical Address Extensions)
3821   // mode is enabled. AMD64/EM64T uses 2M page in 64bit mode. IA64 can use
3822   // page as large as 256M.
3823   //
3824   // Here we try to figure out page size by parsing /proc/meminfo and looking
3825   // for a line with the following format:
3826   //    Hugepagesize:     2048 kB
3827   //
3828   // If we can&#39;t determine the value (e.g. /proc is not mounted, or the text
3829   // format has been changed), we&#39;ll use the largest page size supported by
3830   // the processor.
3831 
3832 #ifndef ZERO
3833   large_page_size =
3834     AARCH64_ONLY(2 * M)
3835     AMD64_ONLY(2 * M)
3836     ARM32_ONLY(2 * M)
3837     IA32_ONLY(4 * M)
3838     IA64_ONLY(256 * M)
3839     PPC_ONLY(4 * M)
<span class="line-modified">3840     S390_ONLY(1 * M);</span>

3841 #endif // ZERO
3842 
3843   FILE *fp = fopen(&quot;/proc/meminfo&quot;, &quot;r&quot;);
3844   if (fp) {
3845     while (!feof(fp)) {
3846       int x = 0;
3847       char buf[16];
3848       if (fscanf(fp, &quot;Hugepagesize: %d&quot;, &amp;x) == 1) {
3849         if (x &amp;&amp; fgets(buf, sizeof(buf), fp) &amp;&amp; strcmp(buf, &quot; kB\n&quot;) == 0) {
3850           large_page_size = x * K;
3851           break;
3852         }
3853       } else {
3854         // skip to next line
3855         for (;;) {
3856           int ch = fgetc(fp);
3857           if (ch == EOF || ch == (int)&#39;\n&#39;) break;
3858         }
3859       }
3860     }
3861     fclose(fp);
3862   }
<span class="line-added">3863   return large_page_size;</span>
<span class="line-added">3864 }</span>
<span class="line-added">3865 </span>
<span class="line-added">3866 size_t os::Linux::find_large_page_size(size_t large_page_size) {</span>
<span class="line-added">3867   if (_default_large_page_size == 0) {</span>
<span class="line-added">3868     _default_large_page_size = Linux::find_default_large_page_size();</span>
<span class="line-added">3869   }</span>
<span class="line-added">3870   // We need to scan /sys/kernel/mm/hugepages</span>
<span class="line-added">3871   // to discover the available page sizes</span>
<span class="line-added">3872   const char* sys_hugepages = &quot;/sys/kernel/mm/hugepages&quot;;</span>
3873 
<span class="line-modified">3874   DIR *dir = opendir(sys_hugepages);</span>
<span class="line-modified">3875   if (dir == NULL) {</span>
<span class="line-modified">3876     return _default_large_page_size;</span>

3877   }
3878 
<span class="line-modified">3879   struct dirent *entry;</span>
<span class="line-added">3880   size_t page_size;</span>
<span class="line-added">3881   while ((entry = readdir(dir)) != NULL) {</span>
<span class="line-added">3882     if (entry-&gt;d_type == DT_DIR &amp;&amp;</span>
<span class="line-added">3883         sscanf(entry-&gt;d_name, &quot;hugepages-%zukB&quot;, &amp;page_size) == 1) {</span>
<span class="line-added">3884       // The kernel is using kB, hotspot uses bytes</span>
<span class="line-added">3885       if (large_page_size == page_size * K) {</span>
<span class="line-added">3886         closedir(dir);</span>
<span class="line-added">3887         return large_page_size;</span>
<span class="line-added">3888       }</span>
<span class="line-added">3889     }</span>
<span class="line-added">3890   }</span>
<span class="line-added">3891   closedir(dir);</span>
<span class="line-added">3892   return _default_large_page_size;</span>
3893 }
3894 
3895 size_t os::Linux::setup_large_page_size() {
<span class="line-modified">3896   _default_large_page_size = Linux::find_default_large_page_size();</span>
<span class="line-added">3897 </span>
<span class="line-added">3898   if (!FLAG_IS_DEFAULT(LargePageSizeInBytes) &amp;&amp; LargePageSizeInBytes != _default_large_page_size ) {</span>
<span class="line-added">3899     _large_page_size = find_large_page_size(LargePageSizeInBytes);</span>
<span class="line-added">3900     if (_large_page_size == _default_large_page_size) {</span>
<span class="line-added">3901       warning(&quot;Setting LargePageSizeInBytes=&quot; SIZE_FORMAT &quot; has no effect on this OS. Using the default large page size &quot;</span>
<span class="line-added">3902               SIZE_FORMAT &quot;%s.&quot;,</span>
<span class="line-added">3903               LargePageSizeInBytes,</span>
<span class="line-added">3904               byte_size_in_proper_unit(_large_page_size), proper_unit_for_byte_size(_large_page_size));</span>
<span class="line-added">3905     }</span>
<span class="line-added">3906   } else {</span>
<span class="line-added">3907     _large_page_size = _default_large_page_size;</span>
<span class="line-added">3908   }</span>
<span class="line-added">3909 </span>
3910   const size_t default_page_size = (size_t)Linux::page_size();
3911   if (_large_page_size &gt; default_page_size) {
3912     _page_sizes[0] = _large_page_size;
3913     _page_sizes[1] = default_page_size;
3914     _page_sizes[2] = 0;
3915   }
3916 
3917   return _large_page_size;
3918 }
3919 
<span class="line-added">3920 size_t os::Linux::default_large_page_size() {</span>
<span class="line-added">3921   return _default_large_page_size;</span>
<span class="line-added">3922 }</span>
<span class="line-added">3923 </span>
3924 bool os::Linux::setup_large_page_type(size_t page_size) {
3925   if (FLAG_IS_DEFAULT(UseHugeTLBFS) &amp;&amp;
3926       FLAG_IS_DEFAULT(UseSHM) &amp;&amp;
3927       FLAG_IS_DEFAULT(UseTransparentHugePages)) {
3928 
3929     // The type of large pages has not been specified by the user.
3930 
3931     // Try UseHugeTLBFS and then UseSHM.
3932     UseHugeTLBFS = UseSHM = true;
3933 
3934     // Don&#39;t try UseTransparentHugePages since there are known
3935     // performance issues with it turned on. This might change in the future.
3936     UseTransparentHugePages = false;
3937   }
3938 
3939   if (UseTransparentHugePages) {
3940     bool warn_on_failure = !FLAG_IS_DEFAULT(UseTransparentHugePages);
3941     if (transparent_huge_pages_sanity_check(warn_on_failure, page_size)) {
3942       UseHugeTLBFS = false;
3943       UseSHM = false;
</pre>
<hr />
<pre>
4132       (!FLAG_IS_DEFAULT(UseLargePages) ||
4133        !FLAG_IS_DEFAULT(UseHugeTLBFS) ||
4134        !FLAG_IS_DEFAULT(LargePageSizeInBytes));
4135 
4136   if (warn_on_failure) {
4137     char msg[128];
4138     jio_snprintf(msg, sizeof(msg), &quot;Failed to reserve large pages memory req_addr: &quot;
4139                  PTR_FORMAT &quot; bytes: &quot; SIZE_FORMAT &quot; (errno = %d).&quot;, req_addr, bytes, error);
4140     warning(&quot;%s&quot;, msg);
4141   }
4142 }
4143 
4144 char* os::Linux::reserve_memory_special_huge_tlbfs_only(size_t bytes,
4145                                                         char* req_addr,
4146                                                         bool exec) {
4147   assert(UseLargePages &amp;&amp; UseHugeTLBFS, &quot;only for Huge TLBFS large pages&quot;);
4148   assert(is_aligned(bytes, os::large_page_size()), &quot;Unaligned size&quot;);
4149   assert(is_aligned(req_addr, os::large_page_size()), &quot;Unaligned address&quot;);
4150 
4151   int prot = exec ? PROT_READ|PROT_WRITE|PROT_EXEC : PROT_READ|PROT_WRITE;
<span class="line-modified">4152   int flags = MAP_PRIVATE|MAP_ANONYMOUS|MAP_HUGETLB;</span>
<span class="line-modified">4153 </span>
<span class="line-modified">4154   if (os::large_page_size() != default_large_page_size()) {</span>
<span class="line-added">4155     flags |= (exact_log2(os::large_page_size()) &lt;&lt; MAP_HUGE_SHIFT);</span>
<span class="line-added">4156   }</span>
<span class="line-added">4157   char* addr = (char*)::mmap(req_addr, bytes, prot, flags, -1, 0);</span>
4158 
4159   if (addr == MAP_FAILED) {
4160     warn_on_large_pages_failure(req_addr, bytes, errno);
4161     return NULL;
4162   }
4163 
4164   assert(is_aligned(addr, os::large_page_size()), &quot;Must be&quot;);
4165 
4166   return addr;
4167 }
4168 
4169 // Reserve memory using mmap(MAP_HUGETLB).
4170 //  - bytes shall be a multiple of alignment.
4171 //  - req_addr can be NULL. If not NULL, it must be a multiple of alignment.
4172 //  - alignment sets the alignment at which memory shall be allocated.
4173 //     It must be a multiple of allocation granularity.
4174 // Returns address of memory or NULL. If req_addr was not NULL, will only return
4175 //  req_addr or NULL.
4176 char* os::Linux::reserve_memory_special_huge_tlbfs_mixed(size_t bytes,
4177                                                          size_t alignment,
</pre>
<hr />
<pre>
4193   assert(is_aligned(start, alignment), &quot;Must be&quot;);
4194 
4195   char* end = start + bytes;
4196 
4197   // Find the regions of the allocated chunk that can be promoted to large pages.
4198   char* lp_start = align_up(start, large_page_size);
4199   char* lp_end   = align_down(end, large_page_size);
4200 
4201   size_t lp_bytes = lp_end - lp_start;
4202 
4203   assert(is_aligned(lp_bytes, large_page_size), &quot;Must be&quot;);
4204 
4205   if (lp_bytes == 0) {
4206     // The mapped region doesn&#39;t even span the start and the end of a large page.
4207     // Fall back to allocate a non-special area.
4208     ::munmap(start, end - start);
4209     return NULL;
4210   }
4211 
4212   int prot = exec ? PROT_READ|PROT_WRITE|PROT_EXEC : PROT_READ|PROT_WRITE;
<span class="line-modified">4213   int flags = MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED;</span>
4214   void* result;
4215 
4216   // Commit small-paged leading area.
4217   if (start != lp_start) {
<span class="line-modified">4218     result = ::mmap(start, lp_start - start, prot, flags, -1, 0);</span>


4219     if (result == MAP_FAILED) {
4220       ::munmap(lp_start, end - lp_start);
4221       return NULL;
4222     }
4223   }
4224 
4225   // Commit large-paged area.
<span class="line-modified">4226   flags |= MAP_HUGETLB;</span>
<span class="line-modified">4227 </span>
<span class="line-modified">4228   if (os::large_page_size() != default_large_page_size()) {</span>
<span class="line-added">4229     flags |= (exact_log2(os::large_page_size()) &lt;&lt; MAP_HUGE_SHIFT);</span>
<span class="line-added">4230   }</span>
<span class="line-added">4231 </span>
<span class="line-added">4232   result = ::mmap(lp_start, lp_bytes, prot, flags, -1, 0);</span>
4233   if (result == MAP_FAILED) {
4234     warn_on_large_pages_failure(lp_start, lp_bytes, errno);
4235     // If the mmap above fails, the large pages region will be unmapped and we
4236     // have regions before and after with small pages. Release these regions.
4237     //
4238     // |  mapped  |  unmapped  |  mapped  |
4239     // ^          ^            ^          ^
4240     // start      lp_start     lp_end     end
4241     //
4242     ::munmap(start, lp_start - start);
4243     ::munmap(lp_end, end - lp_end);
4244     return NULL;
4245   }
4246 
4247   // Commit small-paged trailing area.
4248   if (lp_end != end) {
4249     result = ::mmap(lp_end, end - lp_end, prot,
4250                     MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED,
4251                     -1, 0);
4252     if (result == MAP_FAILED) {
</pre>
</td>
</tr>
</table>
<center><a href="../../../../make/test/JtregNativeJdk.gmk.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../share/gc/shared/genCollectedHeap.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/make/autoconf/buildjdk-spec.gmk.in b/make/autoconf/buildjdk-spec.gmk.in
--- a/make/autoconf/buildjdk-spec.gmk.in
+++ b/make/autoconf/buildjdk-spec.gmk.in
@@ -52,22 +52,25 @@
 JDK_OUTPUTDIR := $(patsubst $(OUTPUTDIR)%,$(BUILDJDK_OUTPUTDIR)%,$(JDK_OUTPUTDIR))
 IMAGES_OUTPUTDIR := $(patsubst $(OUTPUTDIR)%,$(BUILDJDK_OUTPUTDIR)%,$(IMAGES_OUTPUTDIR))
 
 OPENJDK_BUILD_CPU_LEGACY := @OPENJDK_BUILD_CPU_LEGACY@
 OPENJDK_BUILD_CPU_LEGACY_LIB := @OPENJDK_BUILD_CPU_LEGACY_LIB@
+OPENJDK_BUILD_LIBC := @OPENJDK_BUILD_LIBC@
 OPENJDK_TARGET_CPU := @OPENJDK_BUILD_CPU@
 OPENJDK_TARGET_CPU_ARCH := @OPENJDK_BUILD_CPU_ARCH@
 OPENJDK_TARGET_CPU_BITS := @OPENJDK_BUILD_CPU_BITS@
 OPENJDK_TARGET_CPU_ENDIAN := @OPENJDK_BUILD_CPU_ENDIAN@
 OPENJDK_TARGET_CPU_LEGACY := @OPENJDK_BUILD_CPU_LEGACY@
+OPENJDK_TARGET_LIBC := @OPENJDK_BUILD_LIBC@
 OPENJDK_TARGET_OS_INCLUDE_SUBDIR := @OPENJDK_BUILD_OS_INCLUDE_SUBDIR@
 
 HOTSPOT_TARGET_OS := @HOTSPOT_BUILD_OS@
 HOTSPOT_TARGET_OS_TYPE := @HOTSPOT_BUILD_OS_TYPE@
 HOTSPOT_TARGET_CPU := @HOTSPOT_BUILD_CPU@
 HOTSPOT_TARGET_CPU_ARCH := @HOTSPOT_BUILD_CPU_ARCH@
 HOTSPOT_TARGET_CPU_DEFINE := @HOTSPOT_BUILD_CPU_DEFINE@
+HOTSPOT_TARGET_LIBC := @HOTSPOT_BUILD_LIBC@
 
 CFLAGS_JDKLIB := @OPENJDK_BUILD_CFLAGS_JDKLIB@
 CXXFLAGS_JDKLIB := @OPENJDK_BUILD_CXXFLAGS_JDKLIB@
 LDFLAGS_JDKLIB := @OPENJDK_BUILD_LDFLAGS_JDKLIB@
 CFLAGS_JDKEXE := @OPENJDK_BUILD_CFLAGS_JDKEXE@
diff a/make/autoconf/platform.m4 b/make/autoconf/platform.m4
--- a/make/autoconf/platform.m4
+++ b/make/autoconf/platform.m4
@@ -202,10 +202,22 @@
       ;;
     *)
       AC_MSG_ERROR([unsupported operating system $1])
       ;;
   esac
+
+  case "$1" in
+    *linux*-musl)
+      VAR_LIBC=musl
+      ;;
+    *linux*-gnu)
+      VAR_LIBC=gnu
+      ;;
+    *)
+      VAR_LIBC=default
+      ;;
+  esac
 ])
 
 # Expects $host_os $host_cpu $build_os and $build_cpu
 # and $with_target_bits to have been setup!
 #
@@ -240,21 +252,28 @@
   fi
   OPENJDK_BUILD_CPU="$VAR_CPU"
   OPENJDK_BUILD_CPU_ARCH="$VAR_CPU_ARCH"
   OPENJDK_BUILD_CPU_BITS="$VAR_CPU_BITS"
   OPENJDK_BUILD_CPU_ENDIAN="$VAR_CPU_ENDIAN"
+  OPENJDK_BUILD_LIBC="$VAR_LIBC"
   AC_SUBST(OPENJDK_BUILD_OS)
   AC_SUBST(OPENJDK_BUILD_OS_TYPE)
   AC_SUBST(OPENJDK_BUILD_OS_ENV)
   AC_SUBST(OPENJDK_BUILD_CPU)
   AC_SUBST(OPENJDK_BUILD_CPU_ARCH)
   AC_SUBST(OPENJDK_BUILD_CPU_BITS)
   AC_SUBST(OPENJDK_BUILD_CPU_ENDIAN)
+  AC_SUBST(OPENJDK_BUILD_LIBC)
 
   AC_MSG_CHECKING([openjdk-build os-cpu])
   AC_MSG_RESULT([$OPENJDK_BUILD_OS-$OPENJDK_BUILD_CPU])
 
+  if test "x$OPENJDK_BUILD_OS" = "xlinux"; then
+    AC_MSG_CHECKING([openjdk-build C library])
+    AC_MSG_RESULT([$OPENJDK_BUILD_LIBC])
+  fi
+
   # Convert the autoconf OS/CPU value to our own data, into the VAR_OS/CPU variables.
   PLATFORM_EXTRACT_VARS_FROM_OS($host_os)
   PLATFORM_EXTRACT_VARS_FROM_CPU($host_cpu)
   # ... and setup our own variables. (Do this explicitly to facilitate searching)
   OPENJDK_TARGET_OS="$VAR_OS"
@@ -271,22 +290,29 @@
   OPENJDK_TARGET_CPU="$VAR_CPU"
   OPENJDK_TARGET_CPU_ARCH="$VAR_CPU_ARCH"
   OPENJDK_TARGET_CPU_BITS="$VAR_CPU_BITS"
   OPENJDK_TARGET_CPU_ENDIAN="$VAR_CPU_ENDIAN"
   OPENJDK_TARGET_OS_UPPERCASE=`$ECHO $OPENJDK_TARGET_OS | $TR 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
+  OPENJDK_TARGET_LIBC="$VAR_LIBC"
 
   AC_SUBST(OPENJDK_TARGET_OS)
   AC_SUBST(OPENJDK_TARGET_OS_TYPE)
   AC_SUBST(OPENJDK_TARGET_OS_ENV)
   AC_SUBST(OPENJDK_TARGET_OS_UPPERCASE)
   AC_SUBST(OPENJDK_TARGET_CPU)
   AC_SUBST(OPENJDK_TARGET_CPU_ARCH)
   AC_SUBST(OPENJDK_TARGET_CPU_BITS)
   AC_SUBST(OPENJDK_TARGET_CPU_ENDIAN)
+  AC_SUBST(OPENJDK_TARGET_LIBC)
 
   AC_MSG_CHECKING([openjdk-target os-cpu])
   AC_MSG_RESULT([$OPENJDK_TARGET_OS-$OPENJDK_TARGET_CPU])
+
+  if test "x$OPENJDK_TARGET_OS" = "xlinux"; then
+    AC_MSG_CHECKING([openjdk-target C library])
+    AC_MSG_RESULT([$OPENJDK_TARGET_LIBC])
+  fi
 ])
 
 # Check if a reduced build (32-bit on 64-bit platforms) is requested, and modify behaviour
 # accordingly. Must be done after setting up build and target system, but before
 # doing anything else with these values.
@@ -417,11 +443,17 @@
   if test "x$OPENJDK_$1_CPU" = xx86_64; then
     OPENJDK_$1_CPU_BUNDLE="x64"
   else
     OPENJDK_$1_CPU_BUNDLE="$OPENJDK_$1_CPU"
   fi
-  OPENJDK_$1_BUNDLE_PLATFORM="${OPENJDK_$1_OS_BUNDLE}-${OPENJDK_$1_CPU_BUNDLE}"
+
+  OPENJDK_$1_LIBC_BUNDLE=""
+  if test "x$OPENJDK_$1_LIBC" = "xmusl"; then  
+    OPENJDK_$1_LIBC_BUNDLE="-$OPENJDK_$1_LIBC"
+  fi
+
+  OPENJDK_$1_BUNDLE_PLATFORM="${OPENJDK_$1_OS_BUNDLE}-${OPENJDK_$1_CPU_BUNDLE}${OPENJDK_$1_LIBC_BUNDLE}"
   AC_SUBST(OPENJDK_$1_BUNDLE_PLATFORM)
 
   if test "x$COMPILE_TYPE" = "xcross"; then
     # FIXME: ... or should this include reduced builds..?
     DEFINE_CROSS_COMPILE_ARCH="CROSS_COMPILE_ARCH:=$OPENJDK_$1_CPU_LEGACY"
@@ -488,10 +520,17 @@
   elif test "x$OPENJDK_$1_CPU" != x; then
     HOTSPOT_$1_CPU_DEFINE=$(echo $OPENJDK_$1_CPU | tr a-z A-Z)
   fi
   AC_SUBST(HOTSPOT_$1_CPU_DEFINE)
 
+  if test "x$OPENJDK_$1_LIBC" = "xmusl"; then
+    HOTSPOT_$1_LIBC=$OPENJDK_$1_LIBC
+  else
+    HOTSPOT_$1_LIBC=""
+  fi
+  AC_SUBST(HOTSPOT_$1_LIBC)
+
   # For historical reasons, the OS include directories have odd names.
   OPENJDK_$1_OS_INCLUDE_SUBDIR="$OPENJDK_TARGET_OS"
   if test "x$OPENJDK_TARGET_OS" = "xwindows"; then
     OPENJDK_$1_OS_INCLUDE_SUBDIR="win32"
   elif test "x$OPENJDK_TARGET_OS" = "xmacosx"; then
diff a/make/autoconf/spec.gmk.in b/make/autoconf/spec.gmk.in
--- a/make/autoconf/spec.gmk.in
+++ b/make/autoconf/spec.gmk.in
@@ -78,10 +78,12 @@
 OPENJDK_TARGET_CPU:=@OPENJDK_TARGET_CPU@
 OPENJDK_TARGET_CPU_ARCH:=@OPENJDK_TARGET_CPU_ARCH@
 OPENJDK_TARGET_CPU_BITS:=@OPENJDK_TARGET_CPU_BITS@
 OPENJDK_TARGET_CPU_ENDIAN:=@OPENJDK_TARGET_CPU_ENDIAN@
 
+OPENJDK_TARGET_LIBC:=@OPENJDK_TARGET_LIBC@
+
 COMPILE_TYPE:=@COMPILE_TYPE@
 
 # Legacy support
 OPENJDK_TARGET_CPU_ISADIR:=@OPENJDK_TARGET_CPU_ISADIR@
 OPENJDK_TARGET_CPU_LEGACY:=@OPENJDK_TARGET_CPU_LEGACY@
@@ -94,10 +96,12 @@
 
 HOTSPOT_TARGET_CPU := @HOTSPOT_TARGET_CPU@
 HOTSPOT_TARGET_CPU_ARCH := @HOTSPOT_TARGET_CPU_ARCH@
 HOTSPOT_TARGET_CPU_DEFINE := @HOTSPOT_TARGET_CPU_DEFINE@
 
+HOTSPOT_TARGET_LIBC := @HOTSPOT_TARGET_LIBC@
+
 OPENJDK_TARGET_BUNDLE_PLATFORM:=@OPENJDK_TARGET_BUNDLE_PLATFORM@
 JDK_ARCH_ABI_PROP_NAME := @JDK_ARCH_ABI_PROP_NAME@
 
 # We are building on this build system.
 # When not cross-compiling, it is the same as the target.
@@ -108,10 +112,12 @@
 OPENJDK_BUILD_CPU:=@OPENJDK_BUILD_CPU@
 OPENJDK_BUILD_CPU_ARCH:=@OPENJDK_BUILD_CPU_ARCH@
 OPENJDK_BUILD_CPU_BITS:=@OPENJDK_BUILD_CPU_BITS@
 OPENJDK_BUILD_CPU_ENDIAN:=@OPENJDK_BUILD_CPU_ENDIAN@
 
+OPENJDK_BUILD_LIBC:=@OPENJDK_BUILD_LIBC@
+
 OPENJDK_BUILD_OS_INCLUDE_SUBDIR:=@OPENJDK_TARGET_OS_INCLUDE_SUBDIR@
 
 # Target platform value in ModuleTarget class file attribute.
 OPENJDK_MODULE_TARGET_PLATFORM:=@OPENJDK_MODULE_TARGET_PLATFORM@
 
@@ -866,10 +872,11 @@
 #
 # Misc
 #
 
 INCLUDE_SA=@INCLUDE_SA@
+INCLUDE_SA_ATTACH=@INCLUDE_SA_ATTACH@
 INCLUDE_GRAAL=@INCLUDE_GRAAL@
 INCLUDE_JVMCI=@INCLUDE_JVMCI@
 
 OS_VERSION_MAJOR:=@OS_VERSION_MAJOR@
 OS_VERSION_MINOR:=@OS_VERSION_MINOR@
diff a/make/conf/jib-profiles.js b/make/conf/jib-profiles.js
--- a/make/conf/jib-profiles.js
+++ b/make/conf/jib-profiles.js
@@ -56,12 +56,14 @@
  *
  * input.profile
  * input.build_id
  * input.target_os
  * input.target_cpu
+ * input.target_libc
  * input.build_os
  * input.build_cpu
+ * input.build_libc
  * input.target_platform
  * input.build_platform
  * // The build_osenv_* variables describe the unix layer on Windows systems,
  * // i.e. Cygwin, which may also be 32 or 64 bit.
  * input.build_osenv
@@ -98,17 +100,21 @@
  *     <profile-name>: {
  *       // Name of os the profile is built to run on
  *       target_os; <string>
  *       // Name of cpu the profile is built to run on
  *       target_cpu; <string>
- *       // Combination of target_os and target_cpu for convenience
+ *       // Optional libc string if non standard
+ *       target_libc; <string>
+ *       // Optional combination of target_os and target_cpu for convenience
  *       target_platform; <string>
  *       // Name of os the profile is built on
  *       build_os; <string>
  *       // Name of cpu the profile is built on
  *       build_cpu; <string>
- *       // Combination of build_os and build_cpu for convenience
+ *       // Optional libc string if non standard
+ *       build_libc; <string>
+ *       // Optional combination of build_os and build_cpu for convenience
  *       build_platform; <string>
  *
  *       // List of dependencies needed to build this profile
  *       dependencies: <Array of strings>
  *
@@ -190,11 +196,11 @@
     //     dir just like default configure_args and environment_path variables.
     data.format_version = "1.3";
 
     // Organization, product and version are used when uploading/publishing build results
     data.organization = "";
-    data.product = "jdk";
+    data.product = "jdk-portola";
     data.version = getVersion();
 
     // The base directory for the build output. JIB will assume that the
     // actual build directory will be <output_basedir>/<configuration>
     data.output_basedir = "build";
@@ -237,11 +243,11 @@
     common.build_id = getBuildId(input);
     common.build_number = input.build_number != null ? input.build_number : "0";
 
     // List of the main profile names used for iteration
     common.main_profile_names = [
-        "linux-x64", "linux-x86", "macosx-x64", "solaris-x64",
+        "linux-x64", "linux-x64-musl", "linux-x86", "macosx-x64", "solaris-x64",
         "solaris-sparcv9", "windows-x64", "windows-x86",
         "linux-aarch64", "linux-arm32", "linux-ppc64le", "linux-s390x"
     ];
 
     // These are the base setttings for all the main build profiles.
@@ -410,10 +416,18 @@
                 (isWsl(input) ? [ "--host=x86_64-unknown-linux-gnu",
                     "--build=x86_64-unknown-linux-gnu" ] : [])),
             default_make_targets: ["docs-bundles"],
         },
 
+        "linux-x64-musl": {
+            target_os: "linux",
+            target_cpu: "x64",
+            target_libc: "musl",
+            configure_args: concat(common.configure_args_64bit,
+                "--with-zlib=system"),
+        },
+
         "linux-x86": {
             target_os: "linux",
             target_cpu: "x86",
             build_cpu: "x64",
             dependencies: ["devkit"],
@@ -645,10 +659,14 @@
     // tar.gz.
     var artifactData = {
         "linux-x64": {
             platform: "linux-x64",
         },
+        "linux-x64-musl": {
+            platform: "linux-x64-musl",
+            demo_ext: "tar.gz"
+        },
         "linux-x86": {
             platform: "linux-x86",
         },
         "macosx-x64": {
             platform: "osx-x64",
@@ -988,11 +1006,12 @@
        && input.build_platform != devkit_platform) {
         devkit_cross_prefix = input.build_platform + "-to-";
     }
 
     var boot_jdk_platform = (input.build_os == "macosx" ? "osx" : input.build_os)
-        + "-" + input.build_cpu;
+        + "-" + input.build_cpu +
+        (input.build_libc ? "-" + input.build_libc : "");
     var boot_jdk_ext = (input.build_os == "windows" ? ".zip" : ".tar.gz")
     // If running in WSL and building for Windows, it will look like Linux,
     // but we need a Windows boot JDK.
     if (isWsl(input) && input.target_os == "windows") {
         boot_jdk_platform = "windows-" + input.build_cpu;
@@ -1013,11 +1032,11 @@
             environment_path: common.boot_jdk_home + "/bin"
 	}
     } else {
 	boot_jdk = {
             server: "jpg",
-            product: "jdk",
+            product: input.build_libc == "musl" ? "jdk-portola" : "jdk",
             version: common.boot_jdk_version,
             build_number: common.boot_jdk_build_number,
             file: "bundles/" + boot_jdk_platform + "/jdk-" + common.boot_jdk_version + "_"
                 + boot_jdk_platform + "_bin" + boot_jdk_ext,
             configure_args: "--with-boot-jdk=" + common.boot_jdk_home,
diff a/src/hotspot/os/linux/os_linux.cpp b/src/hotspot/os/linux/os_linux.cpp
--- a/src/hotspot/os/linux/os_linux.cpp
+++ b/src/hotspot/os/linux/os_linux.cpp
@@ -101,11 +101,10 @@
 # include <poll.h>
 # include <fcntl.h>
 # include <string.h>
 # include <syscall.h>
 # include <sys/sysinfo.h>
-# include <gnu/libc-version.h>
 # include <sys/ipc.h>
 # include <sys/shm.h>
 # include <link.h>
 # include <stdint.h>
 # include <inttypes.h>
@@ -149,12 +148,12 @@
 int (*os::Linux::_pthread_getcpuclockid)(pthread_t, clockid_t *) = NULL;
 int (*os::Linux::_pthread_setname_np)(pthread_t, const char*) = NULL;
 pthread_t os::Linux::_main_thread;
 int os::Linux::_page_size = -1;
 bool os::Linux::_supports_fast_thread_cpu_time = false;
-const char * os::Linux::_glibc_version = NULL;
-const char * os::Linux::_libpthread_version = NULL;
+const char * os::Linux::_glibc_version = "unknown";
+const char * os::Linux::_libpthread_version = "unknown";
 
 static jlong initial_time_count=0;
 
 static int clock_tics_per_sec = 100;
 
@@ -602,21 +601,25 @@
 #if !defined(_CS_GNU_LIBC_VERSION) || \
     !defined(_CS_GNU_LIBPTHREAD_VERSION)
   #error "glibc too old (< 2.3.2)"
 #endif
 
-  size_t n = confstr(_CS_GNU_LIBC_VERSION, NULL, 0);
-  assert(n > 0, "cannot retrieve glibc version");
-  char *str = (char *)malloc(n, mtInternal);
-  confstr(_CS_GNU_LIBC_VERSION, str, n);
-  os::Linux::set_glibc_version(str);
+  size_t n;
+
+  n = confstr(_CS_GNU_LIBC_VERSION, NULL, 0);
+  if (n > 0) {
+    char* str = (char *)malloc(n, mtInternal);
+    confstr(_CS_GNU_LIBC_VERSION, str, n);
+    os::Linux::set_glibc_version(str);
+  }
 
   n = confstr(_CS_GNU_LIBPTHREAD_VERSION, NULL, 0);
-  assert(n > 0, "cannot retrieve pthread version");
-  str = (char *)malloc(n, mtInternal);
-  confstr(_CS_GNU_LIBPTHREAD_VERSION, str, n);
-  os::Linux::set_libpthread_version(str);
+  if (n > 0) {
+    char* str = (char *)malloc(n, mtInternal);
+    confstr(_CS_GNU_LIBPTHREAD_VERSION, str, n);
+    os::Linux::set_libpthread_version(str);
+  }
 }
 
 /////////////////////////////////////////////////////////////////////////////
 // thread stack expansion
 
@@ -3115,24 +3118,40 @@
 
 // Something to do with the numa-aware allocator needs these symbols
 extern "C" JNIEXPORT void numa_warn(int number, char *where, ...) { }
 extern "C" JNIEXPORT void numa_error(char *where) { }
 
+static void* dlvsym_if_available(void* handle, const char* name, const char* version) {
+  typedef void* (*dlvsym_func_type)(void* handle, const char* name, const char* version);
+  static dlvsym_func_type dlvsym_func;
+  static bool initialized = false;
+
+  if (!initialized) {
+    dlvsym_func = (dlvsym_func_type)dlsym(RTLD_NEXT, "dlvsym");
+    initialized = true;
+  }
+
+  if (dlvsym_func != NULL) {
+    void *f = dlvsym_func(handle, name, version);
+    if (f != NULL) {
+      return f;
+    }
+  }
+
+  return dlsym(handle, name);
+}
+
 // Handle request to load libnuma symbol version 1.1 (API v1). If it fails
 // load symbol from base version instead.
 void* os::Linux::libnuma_dlsym(void* handle, const char *name) {
-  void *f = dlvsym(handle, name, "libnuma_1.1");
-  if (f == NULL) {
-    f = dlsym(handle, name);
-  }
-  return f;
+  return dlvsym_if_available(handle, name, "libnuma_1.1");
 }
 
 // Handle request to load libnuma symbol version 1.2 (API v2) only.
 // Return NULL if the symbol is not defined in this particular version.
 void* os::Linux::libnuma_v2_dlsym(void* handle, const char* name) {
-  return dlvsym(handle, name, "libnuma_1.2");
+  return dlvsym_if_available(handle, name, "libnuma_1.2");
 }
 
 bool os::Linux::libnuma_init() {
   if (sched_getcpu() != -1) { // Requires sched_getcpu() support
     void *handle = dlopen("libnuma.so.1", RTLD_LAZY);
@@ -5047,10 +5066,67 @@
 }
 
 extern void report_error(char* file_name, int line_no, char* title,
                          char* format, ...);
 
+// Some linux distributions (notably: Alpine Linux) include the
+// grsecurity in the kernel by default. Of particular interest from a
+// JVM perspective is PaX (https://pax.grsecurity.net/), which adds
+// some security features related to page attributes. Specifically,
+// the MPROTECT PaX functionality
+// (https://pax.grsecurity.net/docs/mprotect.txt) prevents dynamic
+// code generation by disallowing a (previously) writable page to be
+// marked as executable. This is, of course, exactly what HotSpot does
+// for both JIT compiled method, as well as for stubs, adapters, etc.
+//
+// Instead of crashing "lazily" when trying to make a page executable,
+// this code probes for the presence of PaX and reports the failure
+// eagerly.
+static void check_pax(void) {
+  // Zero doesn't generate code dynamically, so no need to perform the PaX check
+#ifndef ZERO
+  size_t size = os::Linux::page_size();
+
+  void* p = ::mmap(NULL, size, PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
+  if (p == MAP_FAILED) {
+    vm_exit_out_of_memory(size, OOM_MMAP_ERROR, "failed to allocate memory for PaX check.");
+  }
+
+  int res = ::mprotect(p, size, PROT_WRITE|PROT_EXEC);
+  if (res == -1) {
+    vm_exit_during_initialization("Failed to mark memory page as executable",
+                                  "Please check if grsecurity/PaX is enabled in your kernel.\n"
+                                  "\n"
+                                  "For example, you can do this by running (note: you may need root privileges):\n"
+                                  "\n"
+                                  "    sysctl kernel.pax.softmode\n"
+                                  "\n"
+                                  "If PaX is included in the kernel you will see something like this:\n"
+                                  "\n"
+                                  "    kernel.pax.softmode = 0\n"
+                                  "\n"
+                                  "In particular, if the value is 0 (zero), then PaX is enabled.\n"
+                                  "\n"
+                                  "PaX includes security functionality which interferes with the dynamic code\n"
+                                  "generation the JVM relies on. Specifically, the MPROTECT functionality as\n"
+                                  "described on https://pax.grsecurity.net/docs/mprotect.txt is not compatible\n"
+                                  "with the JVM. If you want to allow the JVM to run you will have to disable PaX.\n"
+                                  "You can do this on a per-executable basis using the paxctl tool, for example:\n"
+                                  "\n"
+                                  "    paxctl -cm bin/java\n"
+                                  "\n"
+                                  "Please note that this modifies the executable binary in-place, so you may want\n"
+                                  "to make a backup of it first. Also note that you have to repeat this for other\n"
+                                  "executables like javac, jar, jcmd, etc.\n"
+                                  );
+
+  }
+
+  ::munmap(p, size);
+#endif
+}
+
 // this is called _before_ most of the global arguments have been parsed
 void os::init(void) {
   char dummy;   // used to get a guess on initial stack address
 
   clock_tics_per_sec = sysconf(_SC_CLK_TCK);
@@ -5080,10 +5156,12 @@
 
   // retrieve entry point for pthread_setname_np
   Linux::_pthread_setname_np =
     (int(*)(pthread_t, const char*))dlsym(RTLD_DEFAULT, "pthread_setname_np");
 
+  check_pax();
+
   os::Posix::init();
 
   initial_time_count = javaTimeNanos();
 
   // Always warn if no monotonic clock available
diff a/test/hotspot/jtreg/runtime/StackGuardPages/exeinvoke.c b/test/hotspot/jtreg/runtime/StackGuardPages/exeinvoke.c
--- a/test/hotspot/jtreg/runtime/StackGuardPages/exeinvoke.c
+++ b/test/hotspot/jtreg/runtime/StackGuardPages/exeinvoke.c
@@ -31,10 +31,11 @@
  * It's OK - don't file a bug.
  */
 
 #include <assert.h>
 #include <jni.h>
+#include <jvm.h>
 #include <alloca.h>
 #include <signal.h>
 #include <string.h>
 #include <sys/mman.h>
 #include <stdlib.h>
@@ -89,10 +90,24 @@
     fprintf(stderr, "Test ERROR. Can't set sigaction (%d)\n", errno);
     exit(7);
   }
 }
 
+int get_java_stacksize () {
+  size_t stacksize;
+  pthread_attr_t attr;
+  JDK1_1InitArgs jdk_args;
+
+  jdk_args.version = JNI_VERSION_1_1;
+  JNI_GetDefaultJavaVMInitArgs(&jdk_args);
+  if (jdk_args.javaStackSize <= 0) {
+    fprintf(stderr, "Test ERROR. Can't get a valid value for the default stacksize.\n");
+    exit(7);
+  }
+  return jdk_args.javaStackSize;
+}
+
 void *run_java_overflow (void *p) {
   JNIEnv *env;
   jclass class_id;
   jmethodID method_id;
   int res;
@@ -256,17 +271,23 @@
   if (JNI_CreateJavaVM (&_jvm, (void **)&env, &vm_args) < 0 ) {
     fprintf(stderr, "Test ERROR. Can't create JavaVM\n");
     exit(7);
   }
 
+  int stack_size = get_java_stacksize();
   pthread_t thr;
+  pthread_attr_t thread_attr;
+
+  pthread_attr_init(&thread_attr);
+  pthread_attr_setstacksize(&thread_attr, stack_size);
 
   if (argc > 1 && strcmp(argv[1], "test_java_overflow") == 0) {
     printf("\nTesting JAVA_OVERFLOW\n");
 
     printf("Testing stack guard page behaviour for other thread\n");
-    pthread_create (&thr, NULL, run_java_overflow, NULL);
+
+    pthread_create (&thr, &thread_attr, run_java_overflow, NULL);
     pthread_join (thr, NULL);
 
     printf("Testing stack guard page behaviour for initial thread\n");
     run_java_overflow(NULL);
     // This test crash on error
@@ -275,11 +296,11 @@
 
   if (argc > 1 && strcmp(argv[1], "test_native_overflow") == 0) {
     printf("\nTesting NATIVE_OVERFLOW\n");
 
     printf("Testing stack guard page behaviour for other thread\n");
-    pthread_create (&thr, NULL, run_native_overflow, NULL);
+    pthread_create (&thr, &thread_attr, run_native_overflow, NULL);
     pthread_join (thr, NULL);
 
     printf("Testing stack guard page behaviour for initial thread\n");
     run_native_overflow(NULL);
 
diff a/test/hotspot/jtreg/runtime/TLS/exestack-tls.c b/test/hotspot/jtreg/runtime/TLS/exestack-tls.c
--- a/test/hotspot/jtreg/runtime/TLS/exestack-tls.c
+++ b/test/hotspot/jtreg/runtime/TLS/exestack-tls.c
@@ -24,11 +24,14 @@
 
 #include <jni.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+
+#ifdef __GLIBC__
 #include <gnu/libc-version.h>
+#endif
 
 // Declare the thread local variable(s) in the main executable. This can be
 // used to demonstrate the issues associated with the on-stack static TLS blocks
 // that may cause insufficient stack space. The dynamic TLS blocks for shared
 // objects (such as a JNI library) loaded via dlopen are not allocated on stack.
@@ -52,10 +55,11 @@
     rv = JNI_CreateJavaVM(jvm, (void**)&env, &args);
     if (rv < 0) return NULL;
     return env;
 }
 
+#if defined(__GLIBC)
 // glibc 2.15 introduced __pthread_get_minstack
 int glibc_has_pthread_get_minstack() {
   const char* glibc_vers = gnu_get_libc_version();
   const int glibc_vers_major = atoi(glibc_vers);
   const int glibc_vers_minor = atoi(strchr(glibc_vers, '.') + 1);;
@@ -64,10 +68,15 @@
     return 1;
   }
   printf("This version does not provide __pthread_get_minstack\n");
   return 0;
 }
+#else
+int glibc_has_pthread_get_minstack() {
+  return 0;
+}
+#endif
 
 int run(jboolean addTLS) {
     JavaVM *jvm;
     jclass testClass;
     jmethodID runMethod;
diff a/test/jdk/TEST.ROOT b/test/jdk/TEST.ROOT
--- a/test/jdk/TEST.ROOT
+++ b/test/jdk/TEST.ROOT
@@ -49,10 +49,11 @@
     vm.gc.Shenandoah \
     vm.graal.enabled \
     vm.compiler1.enabled \
     vm.compiler2.enabled \
     vm.cds \
+    vm.musl \
     vm.debug \
     vm.hasSA \
     vm.hasSAandCanAttach \
     vm.hasJFR \
     docker.support \
diff a/test/jdk/tools/launcher/TestHelper.java b/test/jdk/tools/launcher/TestHelper.java
--- a/test/jdk/tools/launcher/TestHelper.java
+++ b/test/jdk/tools/launcher/TestHelper.java
@@ -89,13 +89,15 @@
             System.getProperty("os.name", "unknown").startsWith("SunOS");
     static final boolean isLinux =
             System.getProperty("os.name", "unknown").startsWith("Linux");
     static final boolean isAIX =
             System.getProperty("os.name", "unknown").startsWith("AIX");
+    static final boolean isMusl = isMuslLibc();
     static final String LIBJVM = isWindows
                         ? "jvm.dll"
                         : "libjvm" + (isMacOSX ? ".dylib" : ".so");
+    static final boolean isExpandedSharedLibraryPath = isAIX || isMusl;
 
     static final boolean isSparc = System.getProperty("os.arch").startsWith("sparc");
 
     // make a note of the golden default locale
     static final Locale DefaultLocale = Locale.getDefault();
@@ -534,10 +536,31 @@
             "}"
         };
         createFile(new File(launcherTestDir, "Main.java"), Arrays.asList(moduleCode));
     }
 
+    /**
+     * Check if we run with musl libc.
+     *
+     * @return true if we run with musl libc.
+     */
+    private static boolean isMuslLibc() {
+        try {
+            ProcessBuilder pb = new ProcessBuilder("ldd", "--version");
+            pb.redirectErrorStream(true);
+            final Process p = pb.start();
+            try (BufferedReader br = new BufferedReader(new InputStreamReader(p.getInputStream()))) {
+                return br.lines()
+                        .findFirst()
+                        .filter(line -> line.contains("musl"))
+                        .isPresent();
+            }
+        } catch (Exception ignore) {
+        }
+        return false;
+    }
+
     static class ToolFilter implements FileFilter {
         final List<String> exclude = new ArrayList<>();
         protected ToolFilter(String... exclude) {
             for (String x : exclude) {
                 String str = x + ((isWindows) ? EXE_FILE_EXT : "");

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/lang/ProcessBuilder/Basic.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 /*
  25  * @test
  26  * @bug 4199068 4738465 4937983 4930681 4926230 4931433 4932663 4986689
  27  *      5026830 5023243 5070673 4052517 4811767 6192449 6397034 6413313
  28  *      6464154 6523983 6206031 4960438 6631352 6631966 6850957 6850958
  29  *      4947220 7018606 7034570 4244896 5049299 8003488 8054494 8058464
  30  *      8067796 8224905
  31  * @key intermittent
  32  * @summary Basic tests for Process and Environment Variable code
  33  * @modules java.base/java.lang:open
  34  * @run main/othervm/timeout=300 Basic
  35  * @run main/othervm/timeout=300 -Djdk.lang.Process.launchMechanism=fork Basic
  36  * @author Martin Buchholz
  37  */
  38 
  39 /*
  40  * @test
  41  * @modules java.base/java.lang:open
  42  * @requires (os.family == &quot;linux&quot;)
  43  * @run main/othervm/timeout=300 -Djdk.lang.Process.launchMechanism=posix_spawn Basic
  44  */
  45 
  46 import java.lang.ProcessBuilder.Redirect;
  47 import java.lang.ProcessHandle;
  48 import static java.lang.ProcessBuilder.Redirect.*;
  49 
  50 import java.io.*;
  51 import java.lang.reflect.Field;
  52 import java.nio.file.Files;
  53 import java.nio.file.Paths;
  54 import java.nio.file.StandardCopyOption;
  55 import java.util.*;
  56 import java.util.concurrent.CountDownLatch;
  57 import java.util.concurrent.TimeUnit;
  58 import java.security.*;
  59 import java.util.regex.Pattern;
  60 import java.util.regex.Matcher;
  61 import static java.lang.System.getenv;
  62 import static java.lang.System.out;
  63 import static java.lang.Boolean.TRUE;
  64 import static java.util.AbstractMap.SimpleImmutableEntry;
  65 
  66 public class Basic {
  67 
  68     /* used for Windows only */
  69     static final String systemRoot = System.getenv(&quot;SystemRoot&quot;);
  70 
  71     /* used for Mac OS X only */
  72     static final String cfUserTextEncoding = System.getenv(&quot;__CF_USER_TEXT_ENCODING&quot;);
  73 
  74     /* used for AIX only */
  75     static final String libpath = System.getenv(&quot;LIBPATH&quot;);
  76 
  77     /**
  78      * Returns the number of milliseconds since time given by
  79      * startNanoTime, which must have been previously returned from a
  80      * call to {@link System.nanoTime()}.
  81      */
  82     private static long millisElapsedSince(long startNanoTime) {
  83         return TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanoTime);
  84     }
  85 
  86     private static String commandOutput(Reader r) throws Throwable {
  87         StringBuilder sb = new StringBuilder();
  88         int c;
  89         while ((c = r.read()) &gt; 0)
  90             if (c != &#39;\r&#39;)
  91                 sb.append((char) c);
  92         return sb.toString();
  93     }
  94 
  95     private static String commandOutput(Process p) throws Throwable {
  96         check(p.getInputStream()  == p.getInputStream());
  97         check(p.getOutputStream() == p.getOutputStream());
  98         check(p.getErrorStream()  == p.getErrorStream());
  99         Reader r = new InputStreamReader(p.getInputStream(),&quot;UTF-8&quot;);
 100         String output = commandOutput(r);
 101         equal(p.waitFor(), 0);
 102         equal(p.exitValue(), 0);
 103         // The debug/fastdebug versions of the VM may write some warnings to stdout
 104         // (i.e. &quot;Warning:  Cannot open log file: hotspot.log&quot; if the VM is started
 105         // in a directory without write permissions). These warnings will confuse tests
 106         // which match the entire output of the child process so better filter them out.
 107         return output.replaceAll(&quot;Warning:.*\\n&quot;, &quot;&quot;);
 108     }
 109 
 110     private static String commandOutput(ProcessBuilder pb) {
 111         try {
 112             return commandOutput(pb.start());
 113         } catch (Throwable t) {
 114             String commandline = &quot;&quot;;
 115             for (String arg : pb.command())
 116                 commandline += &quot; &quot; + arg;
 117             System.out.println(&quot;Exception trying to run process: &quot; + commandline);
 118             unexpected(t);
 119             return &quot;&quot;;
 120         }
 121     }
 122 
 123     private static String commandOutput(String...command) {
 124         try {
 125             return commandOutput(Runtime.getRuntime().exec(command));
 126         } catch (Throwable t) {
 127             String commandline = &quot;&quot;;
 128             for (String arg : command)
 129                 commandline += &quot; &quot; + arg;
 130             System.out.println(&quot;Exception trying to run process: &quot; + commandline);
 131             unexpected(t);
 132             return &quot;&quot;;
 133         }
 134     }
 135 
 136     private static void checkCommandOutput(ProcessBuilder pb,
 137                                            String expected,
 138                                            String failureMsg) {
 139         String got = commandOutput(pb);
 140         check(got.equals(expected),
 141               failureMsg + &quot;\n&quot; +
 142               &quot;Expected: \&quot;&quot; + expected + &quot;\&quot;\n&quot; +
 143               &quot;Got: \&quot;&quot; + got + &quot;\&quot;&quot;);
 144     }
 145 
 146     private static String absolutifyPath(String path) {
 147         StringBuilder sb = new StringBuilder();
 148         for (String file : path.split(File.pathSeparator)) {
 149             if (sb.length() != 0)
 150                 sb.append(File.pathSeparator);
 151             sb.append(new File(file).getAbsolutePath());
 152         }
 153         return sb.toString();
 154     }
 155 
 156     // compare windows-style, by canonicalizing to upper case,
 157     // not lower case as String.compareToIgnoreCase does
 158     private static class WindowsComparator
 159         implements Comparator&lt;String&gt; {
 160         public int compare(String x, String y) {
 161             return x.toUpperCase(Locale.US)
 162                 .compareTo(y.toUpperCase(Locale.US));
 163         }
 164     }
 165 
 166     private static String sortedLines(String lines) {
 167         String[] arr = lines.split(&quot;\n&quot;);
 168         List&lt;String&gt; ls = new ArrayList&lt;String&gt;();
 169         for (String s : arr)
 170             ls.add(s);
 171         Collections.sort(ls, new WindowsComparator());
 172         StringBuilder sb = new StringBuilder();
 173         for (String s : ls)
 174             sb.append(s + &quot;\n&quot;);
 175         return sb.toString();
 176     }
 177 
 178     private static void compareLinesIgnoreCase(String lines1, String lines2) {
 179         if (! (sortedLines(lines1).equalsIgnoreCase(sortedLines(lines2)))) {
 180             String dashes =
 181                 &quot;-----------------------------------------------------&quot;;
 182             out.println(dashes);
 183             out.print(sortedLines(lines1));
 184             out.println(dashes);
 185             out.print(sortedLines(lines2));
 186             out.println(dashes);
 187             out.println(&quot;sizes: &quot; + sortedLines(lines1).length() +
 188                         &quot; &quot; + sortedLines(lines2).length());
 189 
 190             fail(&quot;Sorted string contents differ&quot;);
 191         }
 192     }
 193 
 194     private static final Runtime runtime = Runtime.getRuntime();
 195 
 196     private static final String[] winEnvCommand = {&quot;cmd.exe&quot;, &quot;/c&quot;, &quot;set&quot;};
 197 
 198     private static String winEnvFilter(String env) {
 199         return env.replaceAll(&quot;\r&quot;, &quot;&quot;)
 200             .replaceAll(&quot;(?m)^(?:COMSPEC|PROMPT|PATHEXT)=.*\n&quot;,&quot;&quot;);
 201     }
 202 
 203     private static String unixEnvProg() {
 204         return new File(&quot;/usr/bin/env&quot;).canExecute() ? &quot;/usr/bin/env&quot;
 205             : &quot;/bin/env&quot;;
 206     }
 207 
 208     private static String nativeEnv(String[] env) {
 209         try {
 210             if (Windows.is()) {
 211                 return winEnvFilter
 212                     (commandOutput(runtime.exec(winEnvCommand, env)));
 213             } else {
 214                 return commandOutput(runtime.exec(unixEnvProg(), env));
 215             }
 216         } catch (Throwable t) { throw new Error(t); }
 217     }
 218 
 219     private static String nativeEnv(ProcessBuilder pb) {
 220         try {
 221             if (Windows.is()) {
 222                 pb.command(winEnvCommand);
 223                 return winEnvFilter(commandOutput(pb));
 224             } else {
 225                 pb.command(new String[]{unixEnvProg()});
 226                 return commandOutput(pb);
 227             }
 228         } catch (Throwable t) { throw new Error(t); }
 229     }
 230 
 231     private static void checkSizes(Map&lt;String,String&gt; environ, int size) {
 232         try {
 233             equal(size, environ.size());
 234             equal(size, environ.entrySet().size());
 235             equal(size, environ.keySet().size());
 236             equal(size, environ.values().size());
 237 
 238             boolean isEmpty = (size == 0);
 239             equal(isEmpty, environ.isEmpty());
 240             equal(isEmpty, environ.entrySet().isEmpty());
 241             equal(isEmpty, environ.keySet().isEmpty());
 242             equal(isEmpty, environ.values().isEmpty());
 243         } catch (Throwable t) { unexpected(t); }
 244     }
 245 
 246     private interface EnvironmentFrobber {
 247         void doIt(Map&lt;String,String&gt; environ);
 248     }
 249 
 250     private static void testVariableDeleter(EnvironmentFrobber fooDeleter) {
 251         try {
 252             Map&lt;String,String&gt; environ = new ProcessBuilder().environment();
 253             environ.put(&quot;Foo&quot;, &quot;BAAR&quot;);
 254             fooDeleter.doIt(environ);
 255             equal(environ.get(&quot;Foo&quot;), null);
 256             equal(environ.remove(&quot;Foo&quot;), null);
 257         } catch (Throwable t) { unexpected(t); }
 258     }
 259 
 260     private static void testVariableAdder(EnvironmentFrobber fooAdder) {
 261         try {
 262             Map&lt;String,String&gt; environ = new ProcessBuilder().environment();
 263             environ.remove(&quot;Foo&quot;);
 264             fooAdder.doIt(environ);
 265             equal(environ.get(&quot;Foo&quot;), &quot;Bahrein&quot;);
 266         } catch (Throwable t) { unexpected(t); }
 267     }
 268 
 269     private static void testVariableModifier(EnvironmentFrobber fooModifier) {
 270         try {
 271             Map&lt;String,String&gt; environ = new ProcessBuilder().environment();
 272             environ.put(&quot;Foo&quot;,&quot;OldValue&quot;);
 273             fooModifier.doIt(environ);
 274             equal(environ.get(&quot;Foo&quot;), &quot;NewValue&quot;);
 275         } catch (Throwable t) { unexpected(t); }
 276     }
 277 
 278     private static void printUTF8(String s) throws IOException {
 279         out.write(s.getBytes(&quot;UTF-8&quot;));
 280     }
 281 
 282     private static String getenvAsString(Map&lt;String,String&gt; environment) {
 283         StringBuilder sb = new StringBuilder();
 284         environment = new TreeMap&lt;&gt;(environment);
 285         for (Map.Entry&lt;String,String&gt; e : environment.entrySet())
 286             // Ignore magic environment variables added by the launcher
 287             if (! e.getKey().equals(&quot;LD_LIBRARY_PATH&quot;))
 288                 sb.append(e.getKey())
 289                     .append(&#39;=&#39;)
 290                     .append(e.getValue())
 291                     .append(&#39;,&#39;);
 292         return sb.toString();
 293     }
 294 
 295     static void print4095(OutputStream s, byte b) throws Throwable {
 296         byte[] bytes = new byte[4095];
 297         Arrays.fill(bytes, b);
 298         s.write(bytes);         // Might hang!
 299     }
 300 
 301     static void checkPermissionDenied(ProcessBuilder pb) {
 302         try {
 303             pb.start();
 304             fail(&quot;Expected IOException not thrown&quot;);
 305         } catch (IOException e) {
 306             String m = e.getMessage();
 307             if (EnglishUnix.is() &amp;&amp;
 308                 ! matches(m, &quot;Permission denied&quot;))
 309                 unexpected(e);
 310         } catch (Throwable t) { unexpected(t); }
 311     }
 312 
 313     public static class JavaChild {
 314         public static void main(String args[]) throws Throwable {
 315             String action = args[0];
 316             if (action.equals(&quot;sleep&quot;)) {
 317                 Thread.sleep(10 * 60 * 1000L);
 318             } else if (action.equals(&quot;pid&quot;)) {
 319                 System.out.println(ProcessHandle.current().pid());
 320             } else if (action.equals(&quot;testIO&quot;)) {
 321                 String expected = &quot;standard input&quot;;
 322                 char[] buf = new char[expected.length()+1];
 323                 int n = new InputStreamReader(System.in).read(buf,0,buf.length);
 324                 if (n != expected.length())
 325                     System.exit(5);
 326                 if (! new String(buf,0,n).equals(expected))
 327                     System.exit(5);
 328                 System.err.print(&quot;standard error&quot;);
 329                 System.out.print(&quot;standard output&quot;);
 330             } else if (action.equals(&quot;testInheritIO&quot;)
 331                     || action.equals(&quot;testRedirectInherit&quot;)) {
 332                 List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
 333                 childArgs.add(&quot;testIO&quot;);
 334                 ProcessBuilder pb = new ProcessBuilder(childArgs);
 335                 if (action.equals(&quot;testInheritIO&quot;))
 336                     pb.inheritIO();
 337                 else
 338                     redirectIO(pb, INHERIT, INHERIT, INHERIT);
 339                 ProcessResults r = run(pb);
 340                 if (! r.out().equals(&quot;&quot;))
 341                     System.exit(7);
 342                 if (! r.err().equals(&quot;&quot;))
 343                     System.exit(8);
 344                 if (r.exitValue() != 0)
 345                     System.exit(9);
 346             } else if (action.equals(&quot;System.getenv(String)&quot;)) {
 347                 String val = System.getenv(args[1]);
 348                 printUTF8(val == null ? &quot;null&quot; : val);
 349             } else if (action.equals(&quot;System.getenv(\\u1234)&quot;)) {
 350                 String val = System.getenv(&quot;\u1234&quot;);
 351                 printUTF8(val == null ? &quot;null&quot; : val);
 352             } else if (action.equals(&quot;System.getenv()&quot;)) {
 353                 printUTF8(getenvAsString(System.getenv()));
 354             } else if (action.equals(&quot;ArrayOOME&quot;)) {
 355                 Object dummy;
 356                 switch(new Random().nextInt(3)) {
 357                 case 0: dummy = new Integer[Integer.MAX_VALUE]; break;
 358                 case 1: dummy = new double[Integer.MAX_VALUE];  break;
 359                 case 2: dummy = new byte[Integer.MAX_VALUE][];  break;
 360                 default: throw new InternalError();
 361                 }
 362             } else if (action.equals(&quot;pwd&quot;)) {
 363                 printUTF8(new File(System.getProperty(&quot;user.dir&quot;))
 364                           .getCanonicalPath());
 365             } else if (action.equals(&quot;print4095&quot;)) {
 366                 print4095(System.out, (byte) &#39;!&#39;);
 367                 print4095(System.err, (byte) &#39;E&#39;);
 368                 System.exit(5);
 369             } else if (action.equals(&quot;OutErr&quot;)) {
 370                 // You might think the system streams would be
 371                 // buffered, and in fact they are implemented using
 372                 // BufferedOutputStream, but each and every print
 373                 // causes immediate operating system I/O.
 374                 System.out.print(&quot;out&quot;);
 375                 System.err.print(&quot;err&quot;);
 376                 System.out.print(&quot;out&quot;);
 377                 System.err.print(&quot;err&quot;);
 378             } else if (action.equals(&quot;null PATH&quot;)) {
 379                 equal(System.getenv(&quot;PATH&quot;), null);
 380                 check(new File(&quot;/bin/true&quot;).exists());
 381                 check(new File(&quot;/bin/false&quot;).exists());
 382                 ProcessBuilder pb1 = new ProcessBuilder();
 383                 ProcessBuilder pb2 = new ProcessBuilder();
 384                 pb2.environment().put(&quot;PATH&quot;, &quot;anyOldPathIgnoredAnyways&quot;);
 385                 ProcessResults r;
 386 
 387                 for (final ProcessBuilder pb :
 388                          new ProcessBuilder[] {pb1, pb2}) {
 389                     pb.command(&quot;true&quot;);
 390                     equal(run(pb).exitValue(), True.exitValue());
 391 
 392                     pb.command(&quot;false&quot;);
 393                     equal(run(pb).exitValue(), False.exitValue());
 394                 }
 395 
 396                 if (failed != 0) throw new Error(&quot;null PATH&quot;);
 397             } else if (action.equals(&quot;PATH search algorithm&quot;)) {
 398                 equal(System.getenv(&quot;PATH&quot;), &quot;dir1:dir2:&quot;);
<a name="1" id="anc1"></a><span class="line-modified"> 399                 check(new File(&quot;/bin/true&quot;).exists());</span>
<span class="line-modified"> 400                 check(new File(&quot;/bin/false&quot;).exists());</span>
 401                 String[] cmd = {&quot;prog&quot;};
 402                 ProcessBuilder pb1 = new ProcessBuilder(cmd);
 403                 ProcessBuilder pb2 = new ProcessBuilder(cmd);
 404                 ProcessBuilder pb3 = new ProcessBuilder(cmd);
 405                 pb2.environment().put(&quot;PATH&quot;, &quot;anyOldPathIgnoredAnyways&quot;);
 406                 pb3.environment().remove(&quot;PATH&quot;);
 407 
 408                 for (final ProcessBuilder pb :
 409                          new ProcessBuilder[] {pb1, pb2, pb3}) {
 410                     try {
 411                         // Not on PATH at all; directories don&#39;t exist
 412                         try {
 413                             pb.start();
 414                             fail(&quot;Expected IOException not thrown&quot;);
 415                         } catch (IOException e) {
 416                             String m = e.getMessage();
 417                             if (EnglishUnix.is() &amp;&amp;
 418                                 ! matches(m, &quot;No such file&quot;))
 419                                 unexpected(e);
 420                         } catch (Throwable t) { unexpected(t); }
 421 
 422                         // Not on PATH at all; directories exist
 423                         new File(&quot;dir1&quot;).mkdirs();
 424                         new File(&quot;dir2&quot;).mkdirs();
 425                         try {
 426                             pb.start();
 427                             fail(&quot;Expected IOException not thrown&quot;);
 428                         } catch (IOException e) {
 429                             String m = e.getMessage();
 430                             if (EnglishUnix.is() &amp;&amp;
 431                                 ! matches(m, &quot;No such file&quot;))
 432                                 unexpected(e);
 433                         } catch (Throwable t) { unexpected(t); }
 434 
 435                         // Can&#39;t execute a directory -- permission denied
 436                         // Report EACCES errno
 437                         new File(&quot;dir1/prog&quot;).mkdirs();
 438                         checkPermissionDenied(pb);
 439 
 440                         // continue searching if EACCES
<a name="2" id="anc2"></a><span class="line-modified"> 441                         copy(&quot;/bin/true&quot;, &quot;dir2/prog&quot;);</span>
 442                         equal(run(pb).exitValue(), True.exitValue());
 443                         new File(&quot;dir1/prog&quot;).delete();
 444                         new File(&quot;dir2/prog&quot;).delete();
 445 
 446                         new File(&quot;dir2/prog&quot;).mkdirs();
<a name="3" id="anc3"></a><span class="line-modified"> 447                         copy(&quot;/bin/true&quot;, &quot;dir1/prog&quot;);</span>
 448                         equal(run(pb).exitValue(), True.exitValue());
 449 
 450                         // Check empty PATH component means current directory.
 451                         //
 452                         // While we&#39;re here, let&#39;s test different kinds of
 453                         // Unix executables, and PATH vs explicit searching.
 454                         new File(&quot;dir1/prog&quot;).delete();
 455                         new File(&quot;dir2/prog&quot;).delete();
 456                         for (String[] command :
 457                                  new String[][] {
 458                                      new String[] {&quot;./prog&quot;},
 459                                      cmd}) {
 460                             pb.command(command);
 461                             File prog = new File(&quot;./prog&quot;);
 462                             // &quot;Normal&quot; binaries
<a name="4" id="anc4"></a><span class="line-modified"> 463                             copy(&quot;/bin/true&quot;, &quot;./prog&quot;);</span>
 464                             equal(run(pb).exitValue(),
 465                                   True.exitValue());
<a name="5" id="anc5"></a><span class="line-modified"> 466                             copy(&quot;/bin/false&quot;, &quot;./prog&quot;);</span>
 467                             equal(run(pb).exitValue(),
 468                                   False.exitValue());
 469                             prog.delete();
 470                             // Interpreter scripts with #!
 471                             setFileContents(prog, &quot;#!/bin/true\n&quot;);
 472                             prog.setExecutable(true);
 473                             equal(run(pb).exitValue(),
 474                                   True.exitValue());
 475                             prog.delete();
 476                             setFileContents(prog, &quot;#!/bin/false\n&quot;);
 477                             prog.setExecutable(true);
 478                             equal(run(pb).exitValue(),
 479                                   False.exitValue());
 480                             // Traditional shell scripts without #!
 481                             setFileContents(prog, &quot;exec /bin/true\n&quot;);
 482                             prog.setExecutable(true);
 483                             equal(run(pb).exitValue(),
 484                                   True.exitValue());
 485                             prog.delete();
 486                             setFileContents(prog, &quot;exec /bin/false\n&quot;);
 487                             prog.setExecutable(true);
 488                             equal(run(pb).exitValue(),
 489                                   False.exitValue());
 490                             prog.delete();
 491                         }
 492 
 493                         // Test Unix interpreter scripts
 494                         File dir1Prog = new File(&quot;dir1/prog&quot;);
 495                         dir1Prog.delete();
 496                         pb.command(new String[] {&quot;prog&quot;, &quot;world&quot;});
 497                         setFileContents(dir1Prog, &quot;#!/bin/echo hello\n&quot;);
 498                         checkPermissionDenied(pb);
 499                         dir1Prog.setExecutable(true);
 500                         equal(run(pb).out(), &quot;hello dir1/prog world\n&quot;);
 501                         equal(run(pb).exitValue(), True.exitValue());
 502                         dir1Prog.delete();
 503                         pb.command(cmd);
 504 
 505                         // Test traditional shell scripts without #!
 506                         setFileContents(dir1Prog, &quot;/bin/echo \&quot;$@\&quot;\n&quot;);
 507                         pb.command(new String[] {&quot;prog&quot;, &quot;hello&quot;, &quot;world&quot;});
 508                         checkPermissionDenied(pb);
 509                         dir1Prog.setExecutable(true);
 510                         equal(run(pb).out(), &quot;hello world\n&quot;);
 511                         equal(run(pb).exitValue(), True.exitValue());
 512                         dir1Prog.delete();
 513                         pb.command(cmd);
 514 
 515                         // If prog found on both parent and child&#39;s PATH,
 516                         // parent&#39;s is used.
 517                         new File(&quot;dir1/prog&quot;).delete();
 518                         new File(&quot;dir2/prog&quot;).delete();
 519                         new File(&quot;prog&quot;).delete();
 520                         new File(&quot;dir3&quot;).mkdirs();
<a name="6" id="anc6"></a><span class="line-modified"> 521                         copy(&quot;/bin/true&quot;, &quot;dir1/prog&quot;);</span>
<span class="line-modified"> 522                         copy(&quot;/bin/false&quot;, &quot;dir3/prog&quot;);</span>
 523                         pb.environment().put(&quot;PATH&quot;,&quot;dir3&quot;);
 524                         equal(run(pb).exitValue(), True.exitValue());
<a name="7" id="anc7"></a><span class="line-modified"> 525                         copy(&quot;/bin/true&quot;, &quot;dir3/prog&quot;);</span>
<span class="line-modified"> 526                         copy(&quot;/bin/false&quot;, &quot;dir1/prog&quot;);</span>
 527                         equal(run(pb).exitValue(), False.exitValue());
 528 
 529                     } finally {
 530                         // cleanup
 531                         new File(&quot;dir1/prog&quot;).delete();
 532                         new File(&quot;dir2/prog&quot;).delete();
 533                         new File(&quot;dir3/prog&quot;).delete();
 534                         new File(&quot;dir1&quot;).delete();
 535                         new File(&quot;dir2&quot;).delete();
 536                         new File(&quot;dir3&quot;).delete();
 537                         new File(&quot;prog&quot;).delete();
 538                     }
 539                 }
 540 
 541                 if (failed != 0) throw new Error(&quot;PATH search algorithm&quot;);
 542             }
 543             else throw new Error(&quot;JavaChild invocation error&quot;);
 544         }
 545     }
 546 
 547     private static void copy(String src, String dst) throws IOException {
 548         Files.copy(Paths.get(src), Paths.get(dst),
 549                    StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.COPY_ATTRIBUTES);
 550     }
 551 
 552     private static String javaChildOutput(ProcessBuilder pb, String...args) {
 553         List&lt;String&gt; list = new ArrayList&lt;String&gt;(javaChildArgs);
 554         for (String arg : args)
 555             list.add(arg);
 556         pb.command(list);
 557         return commandOutput(pb);
 558     }
 559 
 560     private static String getenvInChild(ProcessBuilder pb) {
 561         return javaChildOutput(pb, &quot;System.getenv()&quot;);
 562     }
 563 
 564     private static String getenvInChild1234(ProcessBuilder pb) {
 565         return javaChildOutput(pb, &quot;System.getenv(\\u1234)&quot;);
 566     }
 567 
 568     private static String getenvInChild(ProcessBuilder pb, String name) {
 569         return javaChildOutput(pb, &quot;System.getenv(String)&quot;, name);
 570     }
 571 
 572     private static String pwdInChild(ProcessBuilder pb) {
 573         return javaChildOutput(pb, &quot;pwd&quot;);
 574     }
 575 
 576     private static final String javaExe =
 577         System.getProperty(&quot;java.home&quot;) +
 578         File.separator + &quot;bin&quot; + File.separator + &quot;java&quot;;
 579 
 580     private static final String classpath =
 581         System.getProperty(&quot;java.class.path&quot;);
 582 
 583     private static final List&lt;String&gt; javaChildArgs =
 584         Arrays.asList(javaExe,
 585                       &quot;-XX:+DisplayVMOutputToStderr&quot;,
 586                       &quot;-classpath&quot;, absolutifyPath(classpath),
 587                       &quot;Basic$JavaChild&quot;);
 588 
 589     private static void testEncoding(String encoding, String tested) {
 590         try {
 591             // If round trip conversion works, should be able to set env vars
 592             // correctly in child.
 593             if (new String(tested.getBytes()).equals(tested)) {
 594                 out.println(&quot;Testing &quot; + encoding + &quot; environment values&quot;);
 595                 ProcessBuilder pb = new ProcessBuilder();
 596                 pb.environment().put(&quot;ASCIINAME&quot;,tested);
 597                 equal(getenvInChild(pb,&quot;ASCIINAME&quot;), tested);
 598             }
 599         } catch (Throwable t) { unexpected(t); }
 600     }
 601 
 602     static class Windows {
 603         public static boolean is() { return is; }
 604         private static final boolean is =
 605             System.getProperty(&quot;os.name&quot;).startsWith(&quot;Windows&quot;);
 606     }
 607 
 608     static class AIX {
 609         public static boolean is() { return is; }
 610         private static final boolean is =
 611             System.getProperty(&quot;os.name&quot;).equals(&quot;AIX&quot;);
 612     }
 613 
 614     static class Unix {
 615         public static boolean is() { return is; }
 616         private static final boolean is =
 617             (! Windows.is() &amp;&amp;
 618              new File(&quot;/bin/sh&quot;).exists() &amp;&amp;
 619              new File(&quot;/bin/true&quot;).exists() &amp;&amp;
 620              new File(&quot;/bin/false&quot;).exists());
 621     }
 622 
<a name="8" id="anc8"></a>






 623     static class UnicodeOS {
 624         public static boolean is() { return is; }
 625         private static final String osName = System.getProperty(&quot;os.name&quot;);
 626         private static final boolean is =
 627             // MacOS X would probably also qualify
 628             osName.startsWith(&quot;Windows&quot;)   &amp;&amp;
 629             ! osName.startsWith(&quot;Windows 9&quot;) &amp;&amp;
 630             ! osName.equals(&quot;Windows Me&quot;);
 631     }
 632 
 633     static class MacOSX {
 634         public static boolean is() { return is; }
 635         private static final String osName = System.getProperty(&quot;os.name&quot;);
 636         private static final boolean is = osName.contains(&quot;OS X&quot;);
 637     }
 638 
 639     static class True {
 640         public static int exitValue() { return 0; }
 641     }
 642 
 643     private static class False {
 644         public static int exitValue() { return exitValue; }
 645         private static final int exitValue = exitValue0();
 646         private static int exitValue0() {
 647             // /bin/false returns an *unspecified* non-zero number.
 648             try {
 649                 if (! Unix.is())
 650                     return -1;
 651                 else {
 652                     int rc = new ProcessBuilder(&quot;/bin/false&quot;)
 653                         .start().waitFor();
 654                     check(rc != 0);
 655                     return rc;
 656                 }
 657             } catch (Throwable t) { unexpected(t); return -1; }
 658         }
 659     }
 660 
<a name="9" id="anc9"></a>






































 661     static class EnglishUnix {
 662         private static final Boolean is =
 663             (! Windows.is() &amp;&amp; isEnglish(&quot;LANG&quot;) &amp;&amp; isEnglish(&quot;LC_ALL&quot;));
 664 
 665         private static boolean isEnglish(String envvar) {
 666             String val = getenv(envvar);
 667             return (val == null) || val.matches(&quot;en.*&quot;) || val.matches(&quot;C&quot;);
 668         }
 669 
 670         /** Returns true if we can expect English OS error strings */
 671         static boolean is() { return is; }
 672     }
 673 
 674     static class DelegatingProcess extends Process {
 675         final Process p;
 676 
 677         DelegatingProcess(Process p) {
 678             this.p = p;
 679         }
 680 
 681         @Override
 682         public void destroy() {
 683             p.destroy();
 684         }
 685 
 686         @Override
 687         public int exitValue() {
 688             return p.exitValue();
 689         }
 690 
 691         @Override
 692         public int waitFor() throws InterruptedException {
 693             return p.waitFor();
 694         }
 695 
 696         @Override
 697         public OutputStream getOutputStream() {
 698             return p.getOutputStream();
 699         }
 700 
 701         @Override
 702         public InputStream getInputStream() {
 703             return p.getInputStream();
 704         }
 705 
 706         @Override
 707         public InputStream getErrorStream() {
 708             return p.getErrorStream();
 709         }
 710     }
 711 
 712     private static boolean matches(String str, String regex) {
 713         return Pattern.compile(regex).matcher(str).find();
 714     }
 715 
 716     private static String matchAndExtract(String str, String regex) {
 717         Matcher matcher = Pattern.compile(regex).matcher(str);
 718         if (matcher.find()) {
 719             return matcher.group();
 720         } else {
 721             return &quot;&quot;;
 722         }
 723     }
 724 
 725     /* Only used for Mac OS X --
 726      * Mac OS X (may) add the variable __CF_USER_TEXT_ENCODING to an empty
 727      * environment. The environment variable JAVA_MAIN_CLASS_&lt;pid&gt; may also
 728      * be set in Mac OS X.
 729      * Remove them both from the list of env variables
 730      */
 731     private static String removeMacExpectedVars(String vars) {
 732         // Check for __CF_USER_TEXT_ENCODING
 733         String cleanedVars = vars.replace(&quot;__CF_USER_TEXT_ENCODING=&quot;
 734                                             +cfUserTextEncoding+&quot;,&quot;,&quot;&quot;);
 735         // Check for JAVA_MAIN_CLASS_&lt;pid&gt;
 736         String javaMainClassStr
 737                 = matchAndExtract(cleanedVars,
 738                                     &quot;JAVA_MAIN_CLASS_\\d+=Basic.JavaChild,&quot;);
 739         return cleanedVars.replace(javaMainClassStr,&quot;&quot;);
 740     }
 741 
 742     /* Only used for AIX --
 743      * AIX adds the variable AIXTHREAD_GUARDPAGES=0 to the environment.
 744      * Remove it from the list of env variables
 745      */
 746     private static String removeAixExpectedVars(String vars) {
 747         return vars.replace(&quot;AIXTHREAD_GUARDPAGES=0,&quot;, &quot;&quot;);
 748     }
 749 
 750     private static String sortByLinesWindowsly(String text) {
 751         String[] lines = text.split(&quot;\n&quot;);
 752         Arrays.sort(lines, new WindowsComparator());
 753         StringBuilder sb = new StringBuilder();
 754         for (String line : lines)
 755             sb.append(line).append(&quot;\n&quot;);
 756         return sb.toString();
 757     }
 758 
 759     private static void checkMapSanity(Map&lt;String,String&gt; map) {
 760         try {
 761             Set&lt;String&gt; keySet = map.keySet();
 762             Collection&lt;String&gt; values = map.values();
 763             Set&lt;Map.Entry&lt;String,String&gt;&gt; entrySet = map.entrySet();
 764 
 765             equal(entrySet.size(), keySet.size());
 766             equal(entrySet.size(), values.size());
 767 
 768             StringBuilder s1 = new StringBuilder();
 769             for (Map.Entry&lt;String,String&gt; e : entrySet)
 770                 s1.append(e.getKey() + &quot;=&quot; + e.getValue() + &quot;\n&quot;);
 771 
 772             StringBuilder s2 = new StringBuilder();
 773             for (String var : keySet)
 774                 s2.append(var + &quot;=&quot; + map.get(var) + &quot;\n&quot;);
 775 
 776             equal(s1.toString(), s2.toString());
 777 
 778             Iterator&lt;String&gt; kIter = keySet.iterator();
 779             Iterator&lt;String&gt; vIter = values.iterator();
 780             Iterator&lt;Map.Entry&lt;String,String&gt;&gt; eIter = entrySet.iterator();
 781 
 782             while (eIter.hasNext()) {
 783                 Map.Entry&lt;String,String&gt; entry = eIter.next();
 784                 String key   = kIter.next();
 785                 String value = vIter.next();
 786                 check(entrySet.contains(entry));
 787                 check(keySet.contains(key));
 788                 check(values.contains(value));
 789                 check(map.containsKey(key));
 790                 check(map.containsValue(value));
 791                 equal(entry.getKey(), key);
 792                 equal(entry.getValue(), value);
 793             }
 794             check(!kIter.hasNext() &amp;&amp;
 795                     !vIter.hasNext());
 796 
 797         } catch (Throwable t) { unexpected(t); }
 798     }
 799 
 800     private static void checkMapEquality(Map&lt;String,String&gt; map1,
 801                                          Map&lt;String,String&gt; map2) {
 802         try {
 803             equal(map1.size(), map2.size());
 804             equal(map1.isEmpty(), map2.isEmpty());
 805             for (String key : map1.keySet()) {
 806                 equal(map1.get(key), map2.get(key));
 807                 check(map2.keySet().contains(key));
 808             }
 809             equal(map1, map2);
 810             equal(map2, map1);
 811             equal(map1.entrySet(), map2.entrySet());
 812             equal(map2.entrySet(), map1.entrySet());
 813             equal(map1.keySet(), map2.keySet());
 814             equal(map2.keySet(), map1.keySet());
 815 
 816             equal(map1.hashCode(), map2.hashCode());
 817             equal(map1.entrySet().hashCode(), map2.entrySet().hashCode());
 818             equal(map1.keySet().hashCode(), map2.keySet().hashCode());
 819         } catch (Throwable t) { unexpected(t); }
 820     }
 821 
 822     static void checkRedirects(ProcessBuilder pb,
 823                                Redirect in, Redirect out, Redirect err) {
 824         equal(pb.redirectInput(), in);
 825         equal(pb.redirectOutput(), out);
 826         equal(pb.redirectError(), err);
 827     }
 828 
 829     static void redirectIO(ProcessBuilder pb,
 830                            Redirect in, Redirect out, Redirect err) {
 831         pb.redirectInput(in);
 832         pb.redirectOutput(out);
 833         pb.redirectError(err);
 834     }
 835 
 836     static void setFileContents(File file, String contents) {
 837         try {
 838             Writer w = new FileWriter(file);
 839             w.write(contents);
 840             w.close();
 841         } catch (Throwable t) { unexpected(t); }
 842     }
 843 
 844     static String fileContents(File file) {
 845         try {
 846             Reader r = new FileReader(file);
 847             StringBuilder sb = new StringBuilder();
 848             char[] buffer = new char[1024];
 849             int n;
 850             while ((n = r.read(buffer)) != -1)
 851                 sb.append(buffer,0,n);
 852             r.close();
 853             return new String(sb);
 854         } catch (Throwable t) { unexpected(t); return &quot;&quot;; }
 855     }
 856 
 857     static void testIORedirection() throws Throwable {
 858         final File ifile = new File(&quot;ifile&quot;);
 859         final File ofile = new File(&quot;ofile&quot;);
 860         final File efile = new File(&quot;efile&quot;);
 861         ifile.delete();
 862         ofile.delete();
 863         efile.delete();
 864 
 865         //----------------------------------------------------------------
 866         // Check mutual inequality of different types of Redirect
 867         //----------------------------------------------------------------
 868         Redirect[] redirects =
 869             { PIPE,
 870               INHERIT,
 871               DISCARD,
 872               Redirect.from(ifile),
 873               Redirect.to(ifile),
 874               Redirect.appendTo(ifile),
 875               Redirect.from(ofile),
 876               Redirect.to(ofile),
 877               Redirect.appendTo(ofile),
 878             };
 879         for (int i = 0; i &lt; redirects.length; i++)
 880             for (int j = 0; j &lt; redirects.length; j++)
 881                 equal(redirects[i].equals(redirects[j]), (i == j));
 882 
 883         //----------------------------------------------------------------
 884         // Check basic properties of different types of Redirect
 885         //----------------------------------------------------------------
 886         equal(PIPE.type(), Redirect.Type.PIPE);
 887         equal(PIPE.toString(), &quot;PIPE&quot;);
 888         equal(PIPE.file(), null);
 889 
 890         equal(INHERIT.type(), Redirect.Type.INHERIT);
 891         equal(INHERIT.toString(), &quot;INHERIT&quot;);
 892         equal(INHERIT.file(), null);
 893 
 894         equal(DISCARD.type(), Redirect.Type.WRITE);
 895         equal(DISCARD.toString(), &quot;WRITE&quot;);
 896         equal(DISCARD.file(), new File((Windows.is() ? &quot;NUL&quot; : &quot;/dev/null&quot;)));
 897 
 898         equal(Redirect.from(ifile).type(), Redirect.Type.READ);
 899         equal(Redirect.from(ifile).toString(),
 900               &quot;redirect to read from file \&quot;ifile\&quot;&quot;);
 901         equal(Redirect.from(ifile).file(), ifile);
 902         equal(Redirect.from(ifile),
 903               Redirect.from(ifile));
 904         equal(Redirect.from(ifile).hashCode(),
 905               Redirect.from(ifile).hashCode());
 906 
 907         equal(Redirect.to(ofile).type(), Redirect.Type.WRITE);
 908         equal(Redirect.to(ofile).toString(),
 909               &quot;redirect to write to file \&quot;ofile\&quot;&quot;);
 910         equal(Redirect.to(ofile).file(), ofile);
 911         equal(Redirect.to(ofile),
 912               Redirect.to(ofile));
 913         equal(Redirect.to(ofile).hashCode(),
 914               Redirect.to(ofile).hashCode());
 915 
 916         equal(Redirect.appendTo(ofile).type(), Redirect.Type.APPEND);
 917         equal(Redirect.appendTo(efile).toString(),
 918               &quot;redirect to append to file \&quot;efile\&quot;&quot;);
 919         equal(Redirect.appendTo(efile).file(), efile);
 920         equal(Redirect.appendTo(efile),
 921               Redirect.appendTo(efile));
 922         equal(Redirect.appendTo(efile).hashCode(),
 923               Redirect.appendTo(efile).hashCode());
 924 
 925         //----------------------------------------------------------------
 926         // Check initial values of redirects
 927         //----------------------------------------------------------------
 928         List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
 929         childArgs.add(&quot;testIO&quot;);
 930         final ProcessBuilder pb = new ProcessBuilder(childArgs);
 931         checkRedirects(pb, PIPE, PIPE, PIPE);
 932 
 933         //----------------------------------------------------------------
 934         // Check inheritIO
 935         //----------------------------------------------------------------
 936         pb.inheritIO();
 937         checkRedirects(pb, INHERIT, INHERIT, INHERIT);
 938 
 939         //----------------------------------------------------------------
 940         // Check DISCARD for stdout,stderr
 941         //----------------------------------------------------------------
 942         redirectIO(pb, INHERIT, DISCARD, DISCARD);
 943         checkRedirects(pb, INHERIT, DISCARD, DISCARD);
 944 
 945         //----------------------------------------------------------------
 946         // Check setters and getters agree
 947         //----------------------------------------------------------------
 948         pb.redirectInput(ifile);
 949         equal(pb.redirectInput().file(), ifile);
 950         equal(pb.redirectInput(), Redirect.from(ifile));
 951 
 952         pb.redirectOutput(ofile);
 953         equal(pb.redirectOutput().file(), ofile);
 954         equal(pb.redirectOutput(), Redirect.to(ofile));
 955 
 956         pb.redirectError(efile);
 957         equal(pb.redirectError().file(), efile);
 958         equal(pb.redirectError(), Redirect.to(efile));
 959 
 960         THROWS(IllegalArgumentException.class,
 961                () -&gt; pb.redirectInput(Redirect.to(ofile)),
 962                () -&gt; pb.redirectOutput(Redirect.from(ifile)),
 963                () -&gt; pb.redirectError(Redirect.from(ifile)),
 964                () -&gt; pb.redirectInput(DISCARD));
 965 
 966         THROWS(NullPointerException.class,
 967                 () -&gt; pb.redirectInput((File)null),
 968                 () -&gt; pb.redirectOutput((File)null),
 969                 () -&gt; pb.redirectError((File)null),
 970                 () -&gt; pb.redirectInput((Redirect)null),
 971                 () -&gt; pb.redirectOutput((Redirect)null),
 972                 () -&gt; pb.redirectError((Redirect)null));
 973 
 974         THROWS(IOException.class,
 975                // Input file does not exist
 976                () -&gt; pb.start());
 977         setFileContents(ifile, &quot;standard input&quot;);
 978 
 979         //----------------------------------------------------------------
 980         // Writing to non-existent files
 981         //----------------------------------------------------------------
 982         {
 983             ProcessResults r = run(pb);
 984             equal(r.exitValue(), 0);
 985             equal(fileContents(ofile), &quot;standard output&quot;);
 986             equal(fileContents(efile), &quot;standard error&quot;);
 987             equal(r.out(), &quot;&quot;);
 988             equal(r.err(), &quot;&quot;);
 989             ofile.delete();
 990             efile.delete();
 991         }
 992 
 993         //----------------------------------------------------------------
 994         // Both redirectErrorStream + redirectError
 995         //----------------------------------------------------------------
 996         {
 997             pb.redirectErrorStream(true);
 998             ProcessResults r = run(pb);
 999             equal(r.exitValue(), 0);
1000             equal(fileContents(ofile),
1001                     &quot;standard error&quot; + &quot;standard output&quot;);
1002             equal(fileContents(efile), &quot;&quot;);
1003             equal(r.out(), &quot;&quot;);
1004             equal(r.err(), &quot;&quot;);
1005             ofile.delete();
1006             efile.delete();
1007         }
1008 
1009         //----------------------------------------------------------------
1010         // Appending to existing files
1011         //----------------------------------------------------------------
1012         {
1013             setFileContents(ofile, &quot;ofile-contents&quot;);
1014             setFileContents(efile, &quot;efile-contents&quot;);
1015             pb.redirectOutput(Redirect.appendTo(ofile));
1016             pb.redirectError(Redirect.appendTo(efile));
1017             pb.redirectErrorStream(false);
1018             ProcessResults r = run(pb);
1019             equal(r.exitValue(), 0);
1020             equal(fileContents(ofile),
1021                   &quot;ofile-contents&quot; + &quot;standard output&quot;);
1022             equal(fileContents(efile),
1023                   &quot;efile-contents&quot; + &quot;standard error&quot;);
1024             equal(r.out(), &quot;&quot;);
1025             equal(r.err(), &quot;&quot;);
1026             ofile.delete();
1027             efile.delete();
1028         }
1029 
1030         //----------------------------------------------------------------
1031         // Replacing existing files
1032         //----------------------------------------------------------------
1033         {
1034             setFileContents(ofile, &quot;ofile-contents&quot;);
1035             setFileContents(efile, &quot;efile-contents&quot;);
1036             pb.redirectOutput(ofile);
1037             pb.redirectError(Redirect.to(efile));
1038             ProcessResults r = run(pb);
1039             equal(r.exitValue(), 0);
1040             equal(fileContents(ofile), &quot;standard output&quot;);
1041             equal(fileContents(efile), &quot;standard error&quot;);
1042             equal(r.out(), &quot;&quot;);
1043             equal(r.err(), &quot;&quot;);
1044             ofile.delete();
1045             efile.delete();
1046         }
1047 
1048         //----------------------------------------------------------------
1049         // Appending twice to the same file?
1050         //----------------------------------------------------------------
1051         {
1052             setFileContents(ofile, &quot;ofile-contents&quot;);
1053             setFileContents(efile, &quot;efile-contents&quot;);
1054             Redirect appender = Redirect.appendTo(ofile);
1055             pb.redirectOutput(appender);
1056             pb.redirectError(appender);
1057             ProcessResults r = run(pb);
1058             equal(r.exitValue(), 0);
1059             equal(fileContents(ofile),
1060                   &quot;ofile-contents&quot; +
1061                   &quot;standard error&quot; +
1062                   &quot;standard output&quot;);
1063             equal(fileContents(efile), &quot;efile-contents&quot;);
1064             equal(r.out(), &quot;&quot;);
1065             equal(r.err(), &quot;&quot;);
1066             ifile.delete();
1067             ofile.delete();
1068             efile.delete();
1069         }
1070 
1071         //----------------------------------------------------------------
1072         // DISCARDing output
1073         //----------------------------------------------------------------
1074         {
1075             setFileContents(ifile, &quot;standard input&quot;);
1076             pb.redirectOutput(DISCARD);
1077             pb.redirectError(DISCARD);
1078             ProcessResults r = run(pb);
1079             equal(r.exitValue(), 0);
1080             equal(r.out(), &quot;&quot;);
1081             equal(r.err(), &quot;&quot;);
1082         }
1083 
1084         //----------------------------------------------------------------
1085         // DISCARDing output and redirecting error
1086         //----------------------------------------------------------------
1087         {
1088             setFileContents(ifile, &quot;standard input&quot;);
1089             setFileContents(ofile, &quot;ofile-contents&quot;);
1090             setFileContents(efile, &quot;efile-contents&quot;);
1091             pb.redirectOutput(DISCARD);
1092             pb.redirectError(efile);
1093             ProcessResults r = run(pb);
1094             equal(r.exitValue(), 0);
1095             equal(fileContents(ofile), &quot;ofile-contents&quot;);
1096             equal(fileContents(efile), &quot;standard error&quot;);
1097             equal(r.out(), &quot;&quot;);
1098             equal(r.err(), &quot;&quot;);
1099             ofile.delete();
1100             efile.delete();
1101         }
1102 
1103         //----------------------------------------------------------------
1104         // DISCARDing error and redirecting output
1105         //----------------------------------------------------------------
1106         {
1107             setFileContents(ifile, &quot;standard input&quot;);
1108             setFileContents(ofile, &quot;ofile-contents&quot;);
1109             setFileContents(efile, &quot;efile-contents&quot;);
1110             pb.redirectOutput(ofile);
1111             pb.redirectError(DISCARD);
1112             ProcessResults r = run(pb);
1113             equal(r.exitValue(), 0);
1114             equal(fileContents(ofile), &quot;standard output&quot;);
1115             equal(fileContents(efile), &quot;efile-contents&quot;);
1116             equal(r.out(), &quot;&quot;);
1117             equal(r.err(), &quot;&quot;);
1118             ofile.delete();
1119             efile.delete();
1120         }
1121 
1122         //----------------------------------------------------------------
1123         // DISCARDing output and merging error into output
1124         //----------------------------------------------------------------
1125         {
1126             setFileContents(ifile, &quot;standard input&quot;);
1127             setFileContents(ofile, &quot;ofile-contents&quot;);
1128             setFileContents(efile, &quot;efile-contents&quot;);
1129             pb.redirectOutput(DISCARD);
1130             pb.redirectErrorStream(true);
1131             pb.redirectError(efile);
1132             ProcessResults r = run(pb);
1133             equal(r.exitValue(), 0);
1134             equal(fileContents(ofile), &quot;ofile-contents&quot;);   // untouched
1135             equal(fileContents(efile), &quot;&quot;);                 // empty
1136             equal(r.out(), &quot;&quot;);
1137             equal(r.err(), &quot;&quot;);
1138             ifile.delete();
1139             ofile.delete();
1140             efile.delete();
1141             pb.redirectErrorStream(false);                  // reset for next test
1142         }
1143 
1144         //----------------------------------------------------------------
1145         // Testing INHERIT is harder.
1146         // Note that this requires __FOUR__ nested JVMs involved in one test,
1147         // if you count the harness JVM.
1148         //----------------------------------------------------------------
1149         for (String testName : new String[] { &quot;testInheritIO&quot;, &quot;testRedirectInherit&quot; } ) {
1150             redirectIO(pb, PIPE, PIPE, PIPE);
1151             List&lt;String&gt; command = pb.command();
1152             command.set(command.size() - 1, testName);
1153             Process p = pb.start();
1154             new PrintStream(p.getOutputStream()).print(&quot;standard input&quot;);
1155             p.getOutputStream().close();
1156             ProcessResults r = run(p);
1157             equal(r.exitValue(), 0);
1158             equal(r.out(), &quot;standard output&quot;);
1159             equal(r.err(), &quot;standard error&quot;);
1160         }
1161 
1162         //----------------------------------------------------------------
1163         // Test security implications of I/O redirection
1164         //----------------------------------------------------------------
1165 
1166         // Read access to current directory is always granted;
1167         // So create a tmpfile for input instead.
1168         final File tmpFile = File.createTempFile(&quot;Basic&quot;, &quot;tmp&quot;);
1169         setFileContents(tmpFile, &quot;standard input&quot;);
1170 
1171         final Policy policy = new Policy();
1172         Policy.setPolicy(policy);
1173         System.setSecurityManager(new SecurityManager());
1174         try {
1175             final Permission xPermission
1176                 = new FilePermission(&quot;&lt;&lt;ALL FILES&gt;&gt;&quot;, &quot;execute&quot;);
1177             final Permission rxPermission
1178                 = new FilePermission(&quot;&lt;&lt;ALL FILES&gt;&gt;&quot;, &quot;read,execute&quot;);
1179             final Permission wxPermission
1180                 = new FilePermission(&quot;&lt;&lt;ALL FILES&gt;&gt;&quot;, &quot;write,execute&quot;);
1181             final Permission rwxPermission
1182                 = new FilePermission(&quot;&lt;&lt;ALL FILES&gt;&gt;&quot;, &quot;read,write,execute&quot;);
1183 
1184             THROWS(SecurityException.class,
1185                    () -&gt; { policy.setPermissions(xPermission);
1186                            redirectIO(pb, from(tmpFile), PIPE, PIPE);
1187                            pb.start();},
1188                    () -&gt; { policy.setPermissions(rxPermission);
1189                            redirectIO(pb, PIPE, to(ofile), PIPE);
1190                            pb.start();},
1191                    () -&gt; { policy.setPermissions(rxPermission);
1192                            redirectIO(pb, PIPE, PIPE, to(efile));
1193                            pb.start();});
1194 
1195             {
1196                 policy.setPermissions(rxPermission);
1197                 redirectIO(pb, from(tmpFile), PIPE, PIPE);
1198                 ProcessResults r = run(pb);
1199                 equal(r.out(), &quot;standard output&quot;);
1200                 equal(r.err(), &quot;standard error&quot;);
1201             }
1202 
1203             {
1204                 policy.setPermissions(wxPermission);
1205                 redirectIO(pb, PIPE, to(ofile), to(efile));
1206                 Process p = pb.start();
1207                 new PrintStream(p.getOutputStream()).print(&quot;standard input&quot;);
1208                 p.getOutputStream().close();
1209                 ProcessResults r = run(p);
1210                 policy.setPermissions(rwxPermission);
1211                 equal(fileContents(ofile), &quot;standard output&quot;);
1212                 equal(fileContents(efile), &quot;standard error&quot;);
1213             }
1214 
1215             {
1216                 policy.setPermissions(rwxPermission);
1217                 redirectIO(pb, from(tmpFile), to(ofile), to(efile));
1218                 ProcessResults r = run(pb);
1219                 policy.setPermissions(rwxPermission);
1220                 equal(fileContents(ofile), &quot;standard output&quot;);
1221                 equal(fileContents(efile), &quot;standard error&quot;);
1222             }
1223 
1224         } finally {
1225             policy.setPermissions(new RuntimePermission(&quot;setSecurityManager&quot;));
1226             System.setSecurityManager(null);
1227             tmpFile.delete();
1228             ifile.delete();
1229             ofile.delete();
1230             efile.delete();
1231         }
1232     }
1233 
1234     static void checkProcessPid() {
1235         ProcessBuilder pb = new ProcessBuilder();
1236         List&lt;String&gt; list = new ArrayList&lt;String&gt;(javaChildArgs);
1237         list.add(&quot;pid&quot;);
1238         pb.command(list);
1239         try {
1240             Process p = pb.start();
1241             String s = commandOutput(p);
1242             long actualPid = Long.valueOf(s.trim());
1243             long expectedPid = p.pid();
1244             equal(actualPid, expectedPid);
1245         } catch (Throwable t) {
1246             unexpected(t);
1247         }
1248 
1249 
1250         // Test the default implementation of Process.getPid
1251         DelegatingProcess p = new DelegatingProcess(null);
1252         THROWS(UnsupportedOperationException.class,
1253                 () -&gt; p.pid(),
1254                 () -&gt; p.toHandle(),
1255                 () -&gt; p.supportsNormalTermination(),
1256                 () -&gt; p.children(),
1257                 () -&gt; p.descendants());
1258 
1259     }
1260 
1261     private static void realMain(String[] args) throws Throwable {
1262         if (Windows.is())
1263             System.out.println(&quot;This appears to be a Windows system.&quot;);
1264         if (Unix.is())
1265             System.out.println(&quot;This appears to be a Unix system.&quot;);
1266         if (UnicodeOS.is())
1267             System.out.println(&quot;This appears to be a Unicode-based OS.&quot;);
1268 
1269         try { testIORedirection(); }
1270         catch (Throwable t) { unexpected(t); }
1271 
1272         //----------------------------------------------------------------
1273         // Basic tests for getPid()
1274         //----------------------------------------------------------------
1275         checkProcessPid();
1276 
1277         //----------------------------------------------------------------
1278         // Basic tests for setting, replacing and deleting envvars
1279         //----------------------------------------------------------------
1280         try {
1281             ProcessBuilder pb = new ProcessBuilder();
1282             Map&lt;String,String&gt; environ = pb.environment();
1283 
1284             // New env var
1285             environ.put(&quot;QUUX&quot;, &quot;BAR&quot;);
1286             equal(environ.get(&quot;QUUX&quot;), &quot;BAR&quot;);
1287             equal(getenvInChild(pb,&quot;QUUX&quot;), &quot;BAR&quot;);
1288 
1289             // Modify env var
1290             environ.put(&quot;QUUX&quot;,&quot;bear&quot;);
1291             equal(environ.get(&quot;QUUX&quot;), &quot;bear&quot;);
1292             equal(getenvInChild(pb,&quot;QUUX&quot;), &quot;bear&quot;);
1293             checkMapSanity(environ);
1294 
1295             // Remove env var
1296             environ.remove(&quot;QUUX&quot;);
1297             equal(environ.get(&quot;QUUX&quot;), null);
1298             equal(getenvInChild(pb,&quot;QUUX&quot;), &quot;null&quot;);
1299             checkMapSanity(environ);
1300 
1301             // Remove non-existent env var
1302             environ.remove(&quot;QUUX&quot;);
1303             equal(environ.get(&quot;QUUX&quot;), null);
1304             equal(getenvInChild(pb,&quot;QUUX&quot;), &quot;null&quot;);
1305             checkMapSanity(environ);
1306         } catch (Throwable t) { unexpected(t); }
1307 
1308         //----------------------------------------------------------------
1309         // Pass Empty environment to child
1310         //----------------------------------------------------------------
1311         try {
1312             ProcessBuilder pb = new ProcessBuilder();
1313             pb.environment().clear();
1314             String expected = Windows.is() ? &quot;SystemRoot=&quot;+systemRoot+&quot;,&quot;: &quot;&quot;;
1315             expected = AIX.is() ? &quot;LIBPATH=&quot;+libpath+&quot;,&quot;: expected;
1316             if (Windows.is()) {
1317                 pb.environment().put(&quot;SystemRoot&quot;, systemRoot);
1318             }
1319             if (AIX.is()) {
1320                 pb.environment().put(&quot;LIBPATH&quot;, libpath);
1321             }
1322             String result = getenvInChild(pb);
1323             if (MacOSX.is()) {
1324                 result = removeMacExpectedVars(result);
1325             }
1326             if (AIX.is()) {
1327                 result = removeAixExpectedVars(result);
1328             }
1329             equal(result, expected);
1330         } catch (Throwable t) { unexpected(t); }
1331 
1332         //----------------------------------------------------------------
1333         // System.getenv() is read-only.
1334         //----------------------------------------------------------------
1335         THROWS(UnsupportedOperationException.class,
1336                () -&gt; getenv().put(&quot;FOO&quot;,&quot;BAR&quot;),
1337                () -&gt; getenv().remove(&quot;PATH&quot;),
1338                () -&gt; getenv().keySet().remove(&quot;PATH&quot;),
1339                () -&gt; getenv().values().remove(&quot;someValue&quot;));
1340 
1341         try {
1342             Collection&lt;Map.Entry&lt;String,String&gt;&gt; c = getenv().entrySet();
1343             if (! c.isEmpty())
1344                 try {
1345                     c.iterator().next().setValue(&quot;foo&quot;);
1346                     fail(&quot;Expected UnsupportedOperationException not thrown&quot;);
1347                 } catch (UnsupportedOperationException e) {} // OK
1348         } catch (Throwable t) { unexpected(t); }
1349 
1350         //----------------------------------------------------------------
1351         // System.getenv() always returns the same object in our implementation.
1352         //----------------------------------------------------------------
1353         try {
1354             check(System.getenv() == System.getenv());
1355         } catch (Throwable t) { unexpected(t); }
1356 
1357         //----------------------------------------------------------------
1358         // You can&#39;t create an env var name containing &quot;=&quot;,
1359         // or an env var name or value containing NUL.
1360         //----------------------------------------------------------------
1361         {
1362             final Map&lt;String,String&gt; m = new ProcessBuilder().environment();
1363             THROWS(IllegalArgumentException.class,
1364                    () -&gt; m.put(&quot;FOO=&quot;,&quot;BAR&quot;),
1365                    () -&gt; m.put(&quot;FOO\u0000&quot;,&quot;BAR&quot;),
1366                    () -&gt; m.put(&quot;FOO&quot;,&quot;BAR\u0000&quot;));
1367         }
1368 
1369         //----------------------------------------------------------------
1370         // Commands must never be null.
1371         //----------------------------------------------------------------
1372         THROWS(NullPointerException.class,
1373                () -&gt; new ProcessBuilder((List&lt;String&gt;)null),
1374                () -&gt; new ProcessBuilder().command((List&lt;String&gt;)null));
1375 
1376         //----------------------------------------------------------------
1377         // Put in a command; get the same one back out.
1378         //----------------------------------------------------------------
1379         try {
1380             List&lt;String&gt; command = new ArrayList&lt;String&gt;();
1381             ProcessBuilder pb = new ProcessBuilder(command);
1382             check(pb.command() == command);
1383             List&lt;String&gt; command2 = new ArrayList&lt;String&gt;(2);
1384             command2.add(&quot;foo&quot;);
1385             command2.add(&quot;bar&quot;);
1386             pb.command(command2);
1387             check(pb.command() == command2);
1388             pb.command(&quot;foo&quot;, &quot;bar&quot;);
1389             check(pb.command() != command2 &amp;&amp; pb.command().equals(command2));
1390             pb.command(command2);
1391             command2.add(&quot;baz&quot;);
1392             equal(pb.command().get(2), &quot;baz&quot;);
1393         } catch (Throwable t) { unexpected(t); }
1394 
1395         //----------------------------------------------------------------
1396         // Commands must contain at least one element.
1397         //----------------------------------------------------------------
1398         THROWS(IndexOutOfBoundsException.class,
1399                () -&gt; new ProcessBuilder().start(),
1400                () -&gt; new ProcessBuilder(new ArrayList&lt;String&gt;()).start(),
1401                () -&gt; Runtime.getRuntime().exec(new String[]{}));
1402 
1403         //----------------------------------------------------------------
1404         // Commands must not contain null elements at start() time.
1405         //----------------------------------------------------------------
1406         THROWS(NullPointerException.class,
1407                () -&gt; new ProcessBuilder(&quot;foo&quot;,null,&quot;bar&quot;).start(),
1408                () -&gt; new ProcessBuilder((String)null).start(),
1409                () -&gt; new ProcessBuilder(new String[]{null}).start(),
1410                () -&gt; new ProcessBuilder(new String[]{&quot;foo&quot;,null,&quot;bar&quot;}).start());
1411 
1412         //----------------------------------------------------------------
1413         // Command lists are growable.
1414         //----------------------------------------------------------------
1415         try {
1416             new ProcessBuilder().command().add(&quot;foo&quot;);
1417             new ProcessBuilder(&quot;bar&quot;).command().add(&quot;foo&quot;);
1418             new ProcessBuilder(new String[]{&quot;1&quot;,&quot;2&quot;}).command().add(&quot;3&quot;);
1419         } catch (Throwable t) { unexpected(t); }
1420 
1421         //----------------------------------------------------------------
1422         // Nulls in environment updates generate NullPointerException
1423         //----------------------------------------------------------------
1424         try {
1425             final Map&lt;String,String&gt; env = new ProcessBuilder().environment();
1426             THROWS(NullPointerException.class,
1427                    () -&gt; env.put(&quot;foo&quot;,null),
1428                    () -&gt; env.put(null,&quot;foo&quot;),
1429                    () -&gt; env.remove(null),
1430                    () -&gt; { for (Map.Entry&lt;String,String&gt; e : env.entrySet())
1431                                e.setValue(null);},
1432                    () -&gt; Runtime.getRuntime().exec(new String[]{&quot;foo&quot;},
1433                                                    new String[]{null}));
1434         } catch (Throwable t) { unexpected(t); }
1435 
1436         //----------------------------------------------------------------
1437         // Non-String types in environment updates generate ClassCastException
1438         //----------------------------------------------------------------
1439         try {
1440             final Map&lt;String,String&gt; env = new ProcessBuilder().environment();
1441             THROWS(ClassCastException.class,
1442                    () -&gt; env.remove(TRUE),
1443                    () -&gt; env.keySet().remove(TRUE),
1444                    () -&gt; env.values().remove(TRUE),
1445                    () -&gt; env.entrySet().remove(TRUE));
1446         } catch (Throwable t) { unexpected(t); }
1447 
1448         //----------------------------------------------------------------
1449         // Check query operations on environment maps
1450         //----------------------------------------------------------------
1451         try {
1452             List&lt;Map&lt;String,String&gt;&gt; envs =
1453                 new ArrayList&lt;Map&lt;String,String&gt;&gt;(2);
1454             envs.add(System.getenv());
1455             envs.add(new ProcessBuilder().environment());
1456             for (final Map&lt;String,String&gt; env : envs) {
1457                 //----------------------------------------------------------------
1458                 // Nulls in environment queries are forbidden.
1459                 //----------------------------------------------------------------
1460                 THROWS(NullPointerException.class,
1461                        () -&gt; getenv(null),
1462                        () -&gt; env.get(null),
1463                        () -&gt; env.containsKey(null),
1464                        () -&gt; env.containsValue(null),
1465                        () -&gt; env.keySet().contains(null),
1466                        () -&gt; env.values().contains(null));
1467 
1468                 //----------------------------------------------------------------
1469                 // Non-String types in environment queries are forbidden.
1470                 //----------------------------------------------------------------
1471                 THROWS(ClassCastException.class,
1472                        () -&gt; env.get(TRUE),
1473                        () -&gt; env.containsKey(TRUE),
1474                        () -&gt; env.containsValue(TRUE),
1475                        () -&gt; env.keySet().contains(TRUE),
1476                        () -&gt; env.values().contains(TRUE));
1477 
1478                 //----------------------------------------------------------------
1479                 // Illegal String values in environment queries are (grumble) OK
1480                 //----------------------------------------------------------------
1481                 equal(env.get(&quot;\u0000&quot;), null);
1482                 check(! env.containsKey(&quot;\u0000&quot;));
1483                 check(! env.containsValue(&quot;\u0000&quot;));
1484                 check(! env.keySet().contains(&quot;\u0000&quot;));
1485                 check(! env.values().contains(&quot;\u0000&quot;));
1486             }
1487 
1488         } catch (Throwable t) { unexpected(t); }
1489 
1490         try {
1491             final Set&lt;Map.Entry&lt;String,String&gt;&gt; entrySet =
1492                 new ProcessBuilder().environment().entrySet();
1493             THROWS(NullPointerException.class,
1494                    () -&gt; entrySet.contains(null));
1495             THROWS(ClassCastException.class,
1496                    () -&gt; entrySet.contains(TRUE),
1497                    () -&gt; entrySet.contains(
1498                              new SimpleImmutableEntry&lt;Boolean,String&gt;(TRUE,&quot;&quot;)));
1499 
1500             check(! entrySet.contains
1501                   (new SimpleImmutableEntry&lt;String,String&gt;(&quot;&quot;, &quot;&quot;)));
1502         } catch (Throwable t) { unexpected(t); }
1503 
1504         //----------------------------------------------------------------
1505         // Put in a directory; get the same one back out.
1506         //----------------------------------------------------------------
1507         try {
1508             ProcessBuilder pb = new ProcessBuilder();
1509             File foo = new File(&quot;foo&quot;);
1510             equal(pb.directory(), null);
1511             equal(pb.directory(foo).directory(), foo);
1512             equal(pb.directory(null).directory(), null);
1513         } catch (Throwable t) { unexpected(t); }
1514 
1515         //----------------------------------------------------------------
1516         // If round-trip conversion works, check envvar pass-through to child
1517         //----------------------------------------------------------------
1518         try {
1519             testEncoding(&quot;ASCII&quot;,   &quot;xyzzy&quot;);
1520             testEncoding(&quot;Latin1&quot;,  &quot;\u00f1\u00e1&quot;);
1521             testEncoding(&quot;Unicode&quot;, &quot;\u22f1\u11e1&quot;);
1522         } catch (Throwable t) { unexpected(t); }
1523 
1524         //----------------------------------------------------------------
1525         // A surprisingly large number of ways to delete an environment var.
1526         //----------------------------------------------------------------
1527         testVariableDeleter(new EnvironmentFrobber() {
1528                 public void doIt(Map&lt;String,String&gt; environ) {
1529                     environ.remove(&quot;Foo&quot;);}});
1530 
1531         testVariableDeleter(new EnvironmentFrobber() {
1532                 public void doIt(Map&lt;String,String&gt; environ) {
1533                     environ.keySet().remove(&quot;Foo&quot;);}});
1534 
1535         testVariableDeleter(new EnvironmentFrobber() {
1536                 public void doIt(Map&lt;String,String&gt; environ) {
1537                     environ.values().remove(&quot;BAAR&quot;);}});
1538 
1539         testVariableDeleter(new EnvironmentFrobber() {
1540                 public void doIt(Map&lt;String,String&gt; environ) {
1541                     // Legally fabricate a ProcessEnvironment.StringEntry,
1542                     // even though it&#39;s private.
1543                     Map&lt;String,String&gt; environ2
1544                         = new ProcessBuilder().environment();
1545                     environ2.clear();
1546                     environ2.put(&quot;Foo&quot;,&quot;BAAR&quot;);
1547                     // Subtlety alert.
1548                     Map.Entry&lt;String,String&gt; e
1549                         = environ2.entrySet().iterator().next();
1550                     environ.entrySet().remove(e);}});
1551 
1552         testVariableDeleter(new EnvironmentFrobber() {
1553                 public void doIt(Map&lt;String,String&gt; environ) {
1554                     Map.Entry&lt;String,String&gt; victim = null;
1555                     for (Map.Entry&lt;String,String&gt; e : environ.entrySet())
1556                         if (e.getKey().equals(&quot;Foo&quot;))
1557                             victim = e;
1558                     if (victim != null)
1559                         environ.entrySet().remove(victim);}});
1560 
1561         testVariableDeleter(new EnvironmentFrobber() {
1562                 public void doIt(Map&lt;String,String&gt; environ) {
1563                     Iterator&lt;String&gt; it = environ.keySet().iterator();
1564                     while (it.hasNext()) {
1565                         String val = it.next();
1566                         if (val.equals(&quot;Foo&quot;))
1567                             it.remove();}}});
1568 
1569         testVariableDeleter(new EnvironmentFrobber() {
1570                 public void doIt(Map&lt;String,String&gt; environ) {
1571                     Iterator&lt;Map.Entry&lt;String,String&gt;&gt; it
1572                         = environ.entrySet().iterator();
1573                     while (it.hasNext()) {
1574                         Map.Entry&lt;String,String&gt; e = it.next();
1575                         if (e.getKey().equals(&quot;Foo&quot;))
1576                             it.remove();}}});
1577 
1578         testVariableDeleter(new EnvironmentFrobber() {
1579                 public void doIt(Map&lt;String,String&gt; environ) {
1580                     Iterator&lt;String&gt; it = environ.values().iterator();
1581                     while (it.hasNext()) {
1582                         String val = it.next();
1583                         if (val.equals(&quot;BAAR&quot;))
1584                             it.remove();}}});
1585 
1586         //----------------------------------------------------------------
1587         // A surprisingly small number of ways to add an environment var.
1588         //----------------------------------------------------------------
1589         testVariableAdder(new EnvironmentFrobber() {
1590                 public void doIt(Map&lt;String,String&gt; environ) {
1591                     environ.put(&quot;Foo&quot;,&quot;Bahrein&quot;);}});
1592 
1593         //----------------------------------------------------------------
1594         // A few ways to modify an environment var.
1595         //----------------------------------------------------------------
1596         testVariableModifier(new EnvironmentFrobber() {
1597                 public void doIt(Map&lt;String,String&gt; environ) {
1598                     environ.put(&quot;Foo&quot;,&quot;NewValue&quot;);}});
1599 
1600         testVariableModifier(new EnvironmentFrobber() {
1601                 public void doIt(Map&lt;String,String&gt; environ) {
1602                     for (Map.Entry&lt;String,String&gt; e : environ.entrySet())
1603                         if (e.getKey().equals(&quot;Foo&quot;))
1604                             e.setValue(&quot;NewValue&quot;);}});
1605 
1606         //----------------------------------------------------------------
1607         // Fiddle with environment sizes
1608         //----------------------------------------------------------------
1609         try {
1610             Map&lt;String,String&gt; environ = new ProcessBuilder().environment();
1611             int size = environ.size();
1612             checkSizes(environ, size);
1613 
1614             environ.put(&quot;UnLiKeLYeNVIROmtNam&quot;, &quot;someVal&quot;);
1615             checkSizes(environ, size+1);
1616 
1617             // Check for environment independence
1618             new ProcessBuilder().environment().clear();
1619 
1620             environ.put(&quot;UnLiKeLYeNVIROmtNam&quot;, &quot;someOtherVal&quot;);
1621             checkSizes(environ, size+1);
1622 
1623             environ.remove(&quot;UnLiKeLYeNVIROmtNam&quot;);
1624             checkSizes(environ, size);
1625 
1626             environ.clear();
1627             checkSizes(environ, 0);
1628 
1629             environ.clear();
1630             checkSizes(environ, 0);
1631 
1632             environ = new ProcessBuilder().environment();
1633             environ.keySet().clear();
1634             checkSizes(environ, 0);
1635 
1636             environ = new ProcessBuilder().environment();
1637             environ.entrySet().clear();
1638             checkSizes(environ, 0);
1639 
1640             environ = new ProcessBuilder().environment();
1641             environ.values().clear();
1642             checkSizes(environ, 0);
1643         } catch (Throwable t) { unexpected(t); }
1644 
1645         //----------------------------------------------------------------
1646         // Check that various map invariants hold
1647         //----------------------------------------------------------------
1648         checkMapSanity(new ProcessBuilder().environment());
1649         checkMapSanity(System.getenv());
1650         checkMapEquality(new ProcessBuilder().environment(),
1651                          new ProcessBuilder().environment());
1652 
1653 
1654         //----------------------------------------------------------------
1655         // Check effects on external &quot;env&quot; command.
1656         //----------------------------------------------------------------
1657         try {
1658             Set&lt;String&gt; env1 = new HashSet&lt;String&gt;
1659                 (Arrays.asList(nativeEnv((String[])null).split(&quot;\n&quot;)));
1660 
1661             ProcessBuilder pb = new ProcessBuilder();
1662             pb.environment().put(&quot;QwErTyUiOp&quot;,&quot;AsDfGhJk&quot;);
1663 
1664             Set&lt;String&gt; env2 = new HashSet&lt;String&gt;
1665                 (Arrays.asList(nativeEnv(pb).split(&quot;\n&quot;)));
1666 
1667             check(env2.size() == env1.size() + 1);
1668             env1.add(&quot;QwErTyUiOp=AsDfGhJk&quot;);
1669             check(env1.equals(env2));
1670         } catch (Throwable t) { unexpected(t); }
1671 
1672         //----------------------------------------------------------------
1673         // Test Runtime.exec(...envp...)
1674         // Check for sort order of environment variables on Windows.
1675         //----------------------------------------------------------------
1676         try {
1677             String systemRoot = &quot;SystemRoot=&quot; + System.getenv(&quot;SystemRoot&quot;);
1678             // &#39;+&#39; &lt; &#39;A&#39; &lt; &#39;Z&#39; &lt; &#39;_&#39; &lt; &#39;a&#39; &lt; &#39;z&#39; &lt; &#39;~&#39;
1679             String[]envp = {&quot;FOO=BAR&quot;,&quot;BAZ=GORP&quot;,&quot;QUUX=&quot;,
1680                             &quot;+=+&quot;, &quot;_=_&quot;, &quot;~=~&quot;, systemRoot};
1681             String output = nativeEnv(envp);
1682             String expected = &quot;+=+\nBAZ=GORP\nFOO=BAR\nQUUX=\n&quot;+systemRoot+&quot;\n_=_\n~=~\n&quot;;
1683             // On Windows, Java must keep the environment sorted.
1684             // Order is random on Unix, so this test does the sort.
1685             if (! Windows.is())
1686                 output = sortByLinesWindowsly(output);
1687             equal(output, expected);
1688         } catch (Throwable t) { unexpected(t); }
1689 
1690         //----------------------------------------------------------------
1691         // Test Runtime.exec(...envp...)
1692         // and check SystemRoot gets set automatically on Windows
1693         //----------------------------------------------------------------
1694         try {
1695             if (Windows.is()) {
1696                 String systemRoot = &quot;SystemRoot=&quot; + System.getenv(&quot;SystemRoot&quot;);
1697                 String[]envp = {&quot;FOO=BAR&quot;,&quot;BAZ=GORP&quot;,&quot;QUUX=&quot;,
1698                                 &quot;+=+&quot;, &quot;_=_&quot;, &quot;~=~&quot;};
1699                 String output = nativeEnv(envp);
1700                 String expected = &quot;+=+\nBAZ=GORP\nFOO=BAR\nQUUX=\n&quot;+systemRoot+&quot;\n_=_\n~=~\n&quot;;
1701                 equal(output, expected);
1702             }
1703         } catch (Throwable t) { unexpected(t); }
1704 
1705         //----------------------------------------------------------------
1706         // System.getenv() must be consistent with System.getenv(String)
1707         //----------------------------------------------------------------
1708         try {
1709             for (Map.Entry&lt;String,String&gt; e : getenv().entrySet())
1710                 equal(getenv(e.getKey()), e.getValue());
1711         } catch (Throwable t) { unexpected(t); }
1712 
1713         //----------------------------------------------------------------
1714         // Fiddle with working directory in child
1715         //----------------------------------------------------------------
1716         try {
1717             String canonicalUserDir =
1718                 new File(System.getProperty(&quot;user.dir&quot;)).getCanonicalPath();
1719             String[] sdirs = new String[]
1720                 {&quot;.&quot;, &quot;..&quot;, &quot;/&quot;, &quot;/bin&quot;,
1721                  &quot;C:&quot;, &quot;c:&quot;, &quot;C:/&quot;, &quot;c:\\&quot;, &quot;\\&quot;, &quot;\\bin&quot;,
1722                  &quot;c:\\windows  &quot;, &quot;c:\\Program Files&quot;, &quot;c:\\Program Files\\&quot; };
1723             for (String sdir : sdirs) {
1724                 File dir = new File(sdir);
1725                 if (! (dir.isDirectory() &amp;&amp; dir.exists()))
1726                     continue;
1727                 out.println(&quot;Testing directory &quot; + dir);
1728                 //dir = new File(dir.getCanonicalPath());
1729 
1730                 ProcessBuilder pb = new ProcessBuilder();
1731                 equal(pb.directory(), null);
1732                 equal(pwdInChild(pb), canonicalUserDir);
1733 
1734                 pb.directory(dir);
1735                 equal(pb.directory(), dir);
1736                 equal(pwdInChild(pb), dir.getCanonicalPath());
1737 
1738                 pb.directory(null);
1739                 equal(pb.directory(), null);
1740                 equal(pwdInChild(pb), canonicalUserDir);
1741 
1742                 pb.directory(dir);
1743             }
1744         } catch (Throwable t) { unexpected(t); }
1745 
1746         //----------------------------------------------------------------
1747         // Working directory with Unicode in child
1748         //----------------------------------------------------------------
1749         try {
1750             if (UnicodeOS.is()) {
1751                 File dir = new File(System.getProperty(&quot;test.dir&quot;, &quot;.&quot;),
1752                                     &quot;ProcessBuilderDir\u4e00\u4e02&quot;);
1753                 try {
1754                     if (!dir.exists())
1755                         dir.mkdir();
1756                     out.println(&quot;Testing Unicode directory:&quot; + dir);
1757                     ProcessBuilder pb = new ProcessBuilder();
1758                     pb.directory(dir);
1759                     equal(pwdInChild(pb), dir.getCanonicalPath());
1760                 } finally {
1761                     if (dir.exists())
1762                         dir.delete();
1763                 }
1764             }
1765         } catch (Throwable t) { unexpected(t); }
1766 
1767         //----------------------------------------------------------------
1768         // OOME in child allocating maximally sized array
1769         // Test for hotspot/jvmti bug 6850957
1770         //----------------------------------------------------------------
1771         try {
1772             List&lt;String&gt; list = new ArrayList&lt;String&gt;(javaChildArgs);
1773             list.add(1, String.format(&quot;-XX:OnOutOfMemoryError=%s -version&quot;,
1774                                       javaExe));
1775             list.add(&quot;ArrayOOME&quot;);
1776             ProcessResults r = run(new ProcessBuilder(list));
1777             check(r.err().contains(&quot;java.lang.OutOfMemoryError:&quot;));
1778             check(r.err().contains(javaExe));
1779             check(r.err().contains(System.getProperty(&quot;java.version&quot;)));
1780             equal(r.exitValue(), 1);
1781         } catch (Throwable t) { unexpected(t); }
1782 
1783         //----------------------------------------------------------------
1784         // Windows has tricky semi-case-insensitive semantics
1785         //----------------------------------------------------------------
1786         if (Windows.is())
1787             try {
1788                 out.println(&quot;Running case insensitve variable tests&quot;);
1789                 for (String[] namePair :
1790                          new String[][]
1791                     { new String[]{&quot;PATH&quot;,&quot;PaTh&quot;},
1792                       new String[]{&quot;home&quot;,&quot;HOME&quot;},
1793                       new String[]{&quot;SYSTEMROOT&quot;,&quot;SystemRoot&quot;}}) {
1794                     check((getenv(namePair[0]) == null &amp;&amp;
1795                            getenv(namePair[1]) == null)
1796                           ||
1797                           getenv(namePair[0]).equals(getenv(namePair[1])),
1798                           &quot;Windows environment variables are not case insensitive&quot;);
1799                 }
1800             } catch (Throwable t) { unexpected(t); }
1801 
1802         //----------------------------------------------------------------
1803         // Test proper Unicode child environment transfer
1804         //----------------------------------------------------------------
1805         if (UnicodeOS.is())
1806             try {
1807                 ProcessBuilder pb = new ProcessBuilder();
1808                 pb.environment().put(&quot;\u1234&quot;,&quot;\u5678&quot;);
1809                 pb.environment().remove(&quot;PATH&quot;);
1810                 equal(getenvInChild1234(pb), &quot;\u5678&quot;);
1811             } catch (Throwable t) { unexpected(t); }
1812 
1813 
1814         //----------------------------------------------------------------
1815         // Test Runtime.exec(...envp...) with envstrings with initial `=&#39;
1816         //----------------------------------------------------------------
1817         try {
1818             List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
1819             childArgs.add(&quot;System.getenv()&quot;);
1820             String[] cmdp = childArgs.toArray(new String[childArgs.size()]);
1821             String[] envp;
1822             String[] envpWin = {&quot;=C:=\\&quot;, &quot;=ExitValue=3&quot;, &quot;SystemRoot=&quot;+systemRoot};
1823             String[] envpOth = {&quot;=ExitValue=3&quot;, &quot;=C:=\\&quot;};
1824             if (Windows.is()) {
1825                 envp = envpWin;
1826             } else {
1827                 envp = envpOth;
1828             }
1829             Process p = Runtime.getRuntime().exec(cmdp, envp);
1830             String expected = Windows.is() ? &quot;=C:=\\,=ExitValue=3,SystemRoot=&quot;+systemRoot+&quot;,&quot; : &quot;=C:=\\,&quot;;
1831             expected = AIX.is() ? expected + &quot;LIBPATH=&quot;+libpath+&quot;,&quot;: expected;
1832             String commandOutput = commandOutput(p);
1833             if (MacOSX.is()) {
1834                 commandOutput = removeMacExpectedVars(commandOutput);
1835             }
1836             if (AIX.is()) {
1837                 commandOutput = removeAixExpectedVars(commandOutput);
1838             }
1839             equal(commandOutput, expected);
1840             if (Windows.is()) {
1841                 ProcessBuilder pb = new ProcessBuilder(childArgs);
1842                 pb.environment().clear();
1843                 pb.environment().put(&quot;SystemRoot&quot;, systemRoot);
1844                 pb.environment().put(&quot;=ExitValue&quot;, &quot;3&quot;);
1845                 pb.environment().put(&quot;=C:&quot;, &quot;\\&quot;);
1846                 equal(commandOutput(pb), expected);
1847             }
1848         } catch (Throwable t) { unexpected(t); }
1849 
1850         //----------------------------------------------------------------
1851         // Test Runtime.exec(...envp...) with envstrings without any `=&#39;
1852         //----------------------------------------------------------------
1853         try {
1854             String[] cmdp = {&quot;echo&quot;};
1855             String[] envp = {&quot;Hello&quot;, &quot;World&quot;}; // Yuck!
1856             Process p = Runtime.getRuntime().exec(cmdp, envp);
1857             equal(commandOutput(p), &quot;\n&quot;);
1858         } catch (Throwable t) { unexpected(t); }
1859 
1860         //----------------------------------------------------------------
1861         // Test Runtime.exec(...envp...) with envstrings containing NULs
1862         //----------------------------------------------------------------
1863         try {
1864             List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
1865             childArgs.add(&quot;System.getenv()&quot;);
1866             String[] cmdp = childArgs.toArray(new String[childArgs.size()]);
1867             String[] envpWin = {&quot;SystemRoot=&quot;+systemRoot, &quot;LC_ALL=C\u0000\u0000&quot;, // Yuck!
1868                              &quot;FO\u0000=B\u0000R&quot;};
1869             String[] envpOth = {&quot;LC_ALL=C\u0000\u0000&quot;, // Yuck!
1870                              &quot;FO\u0000=B\u0000R&quot;};
1871             String[] envp;
1872             if (Windows.is()) {
1873                 envp = envpWin;
1874             } else {
1875                 envp = envpOth;
1876             }
1877             System.out.println (&quot;cmdp&quot;);
1878             for (int i=0; i&lt;cmdp.length; i++) {
1879                 System.out.printf (&quot;cmdp %d: %s\n&quot;, i, cmdp[i]);
1880             }
1881             System.out.println (&quot;envp&quot;);
1882             for (int i=0; i&lt;envp.length; i++) {
1883                 System.out.printf (&quot;envp %d: %s\n&quot;, i, envp[i]);
1884             }
1885             Process p = Runtime.getRuntime().exec(cmdp, envp);
1886             String commandOutput = commandOutput(p);
1887             if (MacOSX.is()) {
1888                 commandOutput = removeMacExpectedVars(commandOutput);
1889             }
1890             if (AIX.is()) {
1891                 commandOutput = removeAixExpectedVars(commandOutput);
1892             }
1893             check(commandOutput.equals(Windows.is()
1894                     ? &quot;LC_ALL=C,SystemRoot=&quot;+systemRoot+&quot;,&quot;
1895                     : AIX.is()
1896                             ? &quot;LC_ALL=C,LIBPATH=&quot;+libpath+&quot;,&quot;
1897                             : &quot;LC_ALL=C,&quot;),
1898                   &quot;Incorrect handling of envstrings containing NULs&quot;);
1899         } catch (Throwable t) { unexpected(t); }
1900 
1901         //----------------------------------------------------------------
1902         // Test the redirectErrorStream property
1903         //----------------------------------------------------------------
1904         try {
1905             ProcessBuilder pb = new ProcessBuilder();
1906             equal(pb.redirectErrorStream(), false);
1907             equal(pb.redirectErrorStream(true), pb);
1908             equal(pb.redirectErrorStream(), true);
1909             equal(pb.redirectErrorStream(false), pb);
1910             equal(pb.redirectErrorStream(), false);
1911         } catch (Throwable t) { unexpected(t); }
1912 
1913         try {
1914             List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
1915             childArgs.add(&quot;OutErr&quot;);
1916             ProcessBuilder pb = new ProcessBuilder(childArgs);
1917             {
1918                 ProcessResults r = run(pb);
1919                 equal(r.out(), &quot;outout&quot;);
1920                 equal(r.err(), &quot;errerr&quot;);
1921             }
1922             {
1923                 pb.redirectErrorStream(true);
1924                 ProcessResults r = run(pb);
1925                 equal(r.out(), &quot;outerrouterr&quot;);
1926                 equal(r.err(), &quot;&quot;);
1927             }
1928         } catch (Throwable t) { unexpected(t); }
1929 
1930         if (Unix.is()) {
1931             //----------------------------------------------------------------
1932             // We can find true and false when PATH is null
1933             //----------------------------------------------------------------
1934             try {
1935                 List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
1936                 childArgs.add(&quot;null PATH&quot;);
1937                 ProcessBuilder pb = new ProcessBuilder(childArgs);
1938                 pb.environment().remove(&quot;PATH&quot;);
1939                 ProcessResults r = run(pb);
1940                 equal(r.out(), &quot;&quot;);
1941                 equal(r.err(), &quot;&quot;);
1942                 equal(r.exitValue(), 0);
1943             } catch (Throwable t) { unexpected(t); }
1944 
1945             //----------------------------------------------------------------
1946             // PATH search algorithm on Unix
1947             //----------------------------------------------------------------
1948             try {
1949                 List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
1950                 childArgs.add(&quot;PATH search algorithm&quot;);
1951                 ProcessBuilder pb = new ProcessBuilder(childArgs);
1952                 pb.environment().put(&quot;PATH&quot;, &quot;dir1:dir2:&quot;);
1953                 ProcessResults r = run(pb);
1954                 equal(r.out(), &quot;&quot;);
1955                 equal(r.err(), &quot;&quot;);
1956                 equal(r.exitValue(), True.exitValue());
1957             } catch (Throwable t) { unexpected(t); }
1958 
1959             //----------------------------------------------------------------
1960             // Parent&#39;s, not child&#39;s PATH is used
1961             //----------------------------------------------------------------
1962             try {
1963                 new File(&quot;suBdiR&quot;).mkdirs();
<a name="10" id="anc10"></a><span class="line-modified">1964                 copy(&quot;/bin/true&quot;, &quot;suBdiR/unliKely&quot;);</span>
1965                 final ProcessBuilder pb =
1966                     new ProcessBuilder(new String[]{&quot;unliKely&quot;});
1967                 pb.environment().put(&quot;PATH&quot;, &quot;suBdiR&quot;);
1968                 THROWS(IOException.class, () -&gt; pb.start());
1969             } catch (Throwable t) { unexpected(t);
1970             } finally {
1971                 new File(&quot;suBdiR/unliKely&quot;).delete();
1972                 new File(&quot;suBdiR&quot;).delete();
1973             }
1974         }
1975 
1976         //----------------------------------------------------------------
1977         // Attempt to start bogus program &quot;&quot;
1978         //----------------------------------------------------------------
1979         try {
1980             new ProcessBuilder(&quot;&quot;).start();
1981             fail(&quot;Expected IOException not thrown&quot;);
1982         } catch (IOException e) {
1983             String m = e.getMessage();
1984             if (EnglishUnix.is() &amp;&amp;
1985                 ! matches(m, &quot;No such file or directory&quot;))
1986                 unexpected(e);
1987         } catch (Throwable t) { unexpected(t); }
1988 
1989         //----------------------------------------------------------------
1990         // Check that attempt to execute program name with funny
1991         // characters throws an exception containing those characters.
1992         //----------------------------------------------------------------
1993         for (String programName : new String[] {&quot;\u00f0&quot;, &quot;\u01f0&quot;})
1994             try {
1995                 new ProcessBuilder(programName).start();
1996                 fail(&quot;Expected IOException not thrown&quot;);
1997             } catch (IOException e) {
1998                 String m = e.getMessage();
1999                 Pattern p = Pattern.compile(programName);
2000                 if (! matches(m, programName)
2001                     || (EnglishUnix.is()
2002                         &amp;&amp; ! matches(m, &quot;No such file or directory&quot;)))
2003                     unexpected(e);
2004             } catch (Throwable t) { unexpected(t); }
2005 
2006         //----------------------------------------------------------------
2007         // Attempt to start process in nonexistent directory fails.
2008         //----------------------------------------------------------------
2009         try {
2010             new ProcessBuilder(&quot;echo&quot;)
2011                 .directory(new File(&quot;UnLiKeLY&quot;))
2012                 .start();
2013             fail(&quot;Expected IOException not thrown&quot;);
2014         } catch (IOException e) {
2015             String m = e.getMessage();
2016             if (! matches(m, &quot;in directory&quot;)
2017                 || (EnglishUnix.is() &amp;&amp;
2018                     ! matches(m, &quot;No such file or directory&quot;)))
2019                 unexpected(e);
2020         } catch (Throwable t) { unexpected(t); }
2021 
2022         //----------------------------------------------------------------
2023         // Attempt to write 4095 bytes to the pipe buffer without a
2024         // reader to drain it would deadlock, if not for the fact that
2025         // interprocess pipe buffers are at least 4096 bytes.
2026         //
2027         // Also, check that available reports all the bytes expected
2028         // in the pipe buffer, and that I/O operations do the expected
2029         // things.
2030         //----------------------------------------------------------------
2031         try {
2032             List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
2033             childArgs.add(&quot;print4095&quot;);
2034             final int SIZE = 4095;
2035             final Process p = new ProcessBuilder(childArgs).start();
2036             print4095(p.getOutputStream(), (byte) &#39;!&#39;); // Might hang!
2037             p.waitFor();                                // Might hang!
2038             equal(SIZE, p.getInputStream().available());
2039             equal(SIZE, p.getErrorStream().available());
2040             THROWS(IOException.class,
2041                    () -&gt; { p.getOutputStream().write((byte) &#39;!&#39;);
2042                            p.getOutputStream().flush();});
2043 
2044             final byte[] bytes = new byte[SIZE + 1];
2045             equal(SIZE, p.getInputStream().read(bytes));
2046             for (int i = 0; i &lt; SIZE; i++)
2047                 equal((byte) &#39;!&#39;, bytes[i]);
2048             equal((byte) 0, bytes[SIZE]);
2049 
2050             equal(SIZE, p.getErrorStream().read(bytes));
2051             for (int i = 0; i &lt; SIZE; i++)
2052                 equal((byte) &#39;E&#39;, bytes[i]);
2053             equal((byte) 0, bytes[SIZE]);
2054 
2055             equal(0, p.getInputStream().available());
2056             equal(0, p.getErrorStream().available());
2057             equal(-1, p.getErrorStream().read());
2058             equal(-1, p.getInputStream().read());
2059 
2060             equal(p.exitValue(), 5);
2061 
2062             p.getInputStream().close();
2063             p.getErrorStream().close();
2064             try { p.getOutputStream().close(); } catch (IOException flushFailed) { }
2065 
2066             InputStream[] streams = { p.getInputStream(), p.getErrorStream() };
2067             for (final InputStream in : streams) {
2068                 Fun[] ops = {
2069                     () -&gt; in.read(),
2070                     () -&gt; in.read(bytes),
2071                     () -&gt; in.available()
2072                 };
2073                 for (Fun op : ops) {
2074                     try {
2075                         op.f();
2076                         fail();
2077                     } catch (IOException expected) {
2078                         check(expected.getMessage()
2079                               .matches(&quot;[Ss]tream [Cc]losed&quot;));
2080                     }
2081                 }
2082             }
2083         } catch (Throwable t) { unexpected(t); }
2084 
2085         //----------------------------------------------------------------
2086         // Check that reads which are pending when Process.destroy is
2087         // called, get EOF, or IOException(&quot;Stream closed&quot;).
2088         //----------------------------------------------------------------
2089         try {
2090             final int cases = 4;
2091             for (int i = 0; i &lt; cases; i++) {
2092                 final int action = i;
2093                 List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
2094                 childArgs.add(&quot;sleep&quot;);
2095                 final byte[] bytes = new byte[10];
2096                 final Process p = new ProcessBuilder(childArgs).start();
2097                 final CountDownLatch latch = new CountDownLatch(1);
2098                 final InputStream s;
2099                 switch (action &amp; 0x1) {
2100                     case 0: s = p.getInputStream(); break;
2101                     case 1: s = p.getErrorStream(); break;
2102                     default: throw new Error();
2103                 }
2104                 final Thread thread = new Thread() {
2105                     public void run() {
2106                         try {
2107                             int r;
2108                             latch.countDown();
2109                             switch (action &amp; 0x2) {
2110                                 case 0: r = s.read(); break;
2111                                 case 2: r = s.read(bytes); break;
2112                                 default: throw new Error();
2113                             }
2114                             if (r &gt;= 0) {
2115                                 // The child sent unexpected output; print it to diagnose
2116                                 System.out.println(&quot;Unexpected child output:&quot;);
2117                                 if ((action &amp; 0x2) == 0) {
2118                                     System.out.write(r);    // Single character
2119 
2120                                 } else {
2121                                     System.out.write(bytes, 0, r);
2122                                 }
2123                                 for (int c = s.read(); c &gt;= 0; c = s.read())
2124                                     System.out.write(c);
2125                                 System.out.println(&quot;\nEND Child output.&quot;);
2126                             }
2127                             equal(-1, r);
2128                         } catch (IOException ioe) {
2129                             if (!ioe.getMessage().equals(&quot;Stream closed&quot;)) {
2130                                 // BufferedInputStream may throw IOE(&quot;Stream closed&quot;).
2131                                 unexpected(ioe);
2132                             }
2133                         } catch (Throwable t) { unexpected(t); }}};
2134 
2135                 thread.start();
2136                 latch.await();
2137                 Thread.sleep(10);
2138 
2139                 String os = System.getProperty(&quot;os.name&quot;);
2140                 if (os.equalsIgnoreCase(&quot;Solaris&quot;) ||
2141                     os.equalsIgnoreCase(&quot;SunOS&quot;))
2142                 {
2143                     final Object deferred;
2144                     Class&lt;?&gt; c = s.getClass();
2145                     if (c.getName().equals(
2146                         &quot;java.lang.ProcessImpl$DeferredCloseInputStream&quot;))
2147                     {
2148                         deferred = s;
2149                     } else {
2150                         Field deferredField = p.getClass().
2151                             getDeclaredField(&quot;stdout_inner_stream&quot;);
2152                         deferredField.setAccessible(true);
2153                         deferred = deferredField.get(p);
2154                     }
2155                     Field useCountField = deferred.getClass().
2156                         getDeclaredField(&quot;useCount&quot;);
2157                     useCountField.setAccessible(true);
2158 
2159                     while (useCountField.getInt(deferred) &lt;= 0) {
2160                         Thread.yield();
2161                     }
2162                 } else if (s instanceof BufferedInputStream) {
2163                     // Wait until after the s.read occurs in &quot;thread&quot; by
2164                     // checking when the input stream monitor is acquired
2165                     // (BufferedInputStream.read is synchronized)
2166                     while (!isLocked(s, 10)) {
2167                         Thread.sleep(100);
2168                     }
2169                 }
2170                 p.destroy();
2171                 thread.join();
2172             }
2173         } catch (Throwable t) { unexpected(t); }
2174 
2175         //----------------------------------------------------------------
2176         // Check that subprocesses which create subprocesses of their
2177         // own do not cause parent to hang waiting for file
2178         // descriptors to be closed.
2179         //----------------------------------------------------------------
2180         try {
2181             if (Unix.is()
2182                 &amp;&amp; new File(&quot;/bin/bash&quot;).exists()
2183                 &amp;&amp; new File(&quot;/bin/sleep&quot;).exists()) {
2184                 // Notice that we only destroy the process created by us (i.e.
2185                 // our child) but not our grandchild (i.e. &#39;/bin/sleep&#39;). So
2186                 // pay attention that the grandchild doesn&#39;t run too long to
2187                 // avoid polluting the process space with useless processes.
2188                 // Running the grandchild for 60s should be more than enough.
2189                 final String[] cmd = { &quot;/bin/bash&quot;, &quot;-c&quot;, &quot;(/bin/sleep 60)&quot; };
2190                 final String[] cmdkill = { &quot;/bin/bash&quot;, &quot;-c&quot;, &quot;(/usr/bin/pkill -f \&quot;sleep 60\&quot;)&quot; };
2191                 final ProcessBuilder pb = new ProcessBuilder(cmd);
2192                 final Process p = pb.start();
2193                 final InputStream stdout = p.getInputStream();
2194                 final InputStream stderr = p.getErrorStream();
2195                 final OutputStream stdin = p.getOutputStream();
2196                 final Thread reader = new Thread() {
2197                     public void run() {
2198                         try { stdout.read(); }
2199                         catch (IOException e) {
2200                             // Check that reader failed because stream was
2201                             // asynchronously closed.
2202                             // e.printStackTrace();
2203                             String msg = e.getMessage();
2204                             if (EnglishUnix.is() &amp;&amp;
2205                                 ! (msg.matches(&quot;.*Bad file.*&quot;) ||
2206                                         msg.matches(&quot;.*Stream closed.*&quot;)))
2207                                 unexpected(e);
2208                         }
2209                         catch (Throwable t) { unexpected(t); }}};
2210                 reader.setDaemon(true);
2211                 reader.start();
2212                 Thread.sleep(100);
2213                 p.destroy();
2214                 check(p.waitFor() != 0);
2215                 check(p.exitValue() != 0);
2216                 // Subprocess is now dead, but file descriptors remain open.
2217                 // Make sure the test will fail if we don&#39;t manage to close
2218                 // the open streams within 30 seconds. Notice that this time
2219                 // must be shorter than the sleep time of the grandchild.
2220                 Timer t = new Timer(&quot;test/java/lang/ProcessBuilder/Basic.java process reaper&quot;, true);
2221                 t.schedule(new TimerTask() {
2222                       public void run() {
2223                           fail(&quot;Subprocesses which create subprocesses of &quot; +
2224                                &quot;their own caused the parent to hang while &quot; +
2225                                &quot;waiting for file descriptors to be closed.&quot;);
2226                           System.exit(-1);
2227                       }
2228                   }, 30000);
2229                 stdout.close();
2230                 stderr.close();
2231                 stdin.close();
2232                 new ProcessBuilder(cmdkill).start();
2233                 // All streams successfully closed so we can cancel the timer.
2234                 t.cancel();
2235                 //----------------------------------------------------------
2236                 // There remain unsolved issues with asynchronous close.
2237                 // Here&#39;s a highly non-portable experiment to demonstrate:
2238                 //----------------------------------------------------------
2239                 if (Boolean.getBoolean(&quot;wakeupJeff!&quot;)) {
2240                     System.out.println(&quot;wakeupJeff!&quot;);
2241                     // Initialize signal handler for INTERRUPT_SIGNAL.
2242                     new FileInputStream(&quot;/bin/sleep&quot;).getChannel().close();
2243                     // Send INTERRUPT_SIGNAL to every thread in this java.
2244                     String[] wakeupJeff = {
2245                         &quot;/bin/bash&quot;, &quot;-c&quot;,
2246                         &quot;/bin/ps --noheaders -Lfp $PPID | &quot; +
2247                         &quot;/usr/bin/perl -nale &#39;print $F[3]&#39; | &quot; +
2248                         // INTERRUPT_SIGNAL == 62 on my machine du jour.
2249                         &quot;/usr/bin/xargs kill -62&quot;
2250                     };
2251                     new ProcessBuilder(wakeupJeff).start().waitFor();
2252                     // If wakeupJeff worked, reader probably got EBADF.
2253                     reader.join();
2254                 }
2255             }
2256 
2257             //----------------------------------------------------------------
2258             // Check the Process toString() method
2259             //----------------------------------------------------------------
2260             {
2261                 List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
2262                 childArgs.add(&quot;testIO&quot;);
2263                 ProcessBuilder pb = new ProcessBuilder(childArgs);
2264                 pb.redirectInput(Redirect.PIPE);
2265                 pb.redirectOutput(DISCARD);
2266                 pb.redirectError(DISCARD);
2267                 final Process p = pb.start();
2268                 // Child process waits until it gets input
2269                 String s = p.toString();
2270                 check(s.contains(&quot;not exited&quot;));
2271                 check(s.contains(&quot;pid=&quot; + p.pid() + &quot;,&quot;));
2272 
2273                 new PrintStream(p.getOutputStream()).print(&quot;standard input&quot;);
2274                 p.getOutputStream().close();
2275 
2276                 // Check the toString after it exits
2277                 int exitValue = p.waitFor();
2278                 s = p.toString();
2279                 check(s.contains(&quot;pid=&quot; + p.pid() + &quot;,&quot;));
2280                 check(s.contains(&quot;exitValue=&quot; + exitValue) &amp;&amp;
2281                         !s.contains(&quot;not exited&quot;));
2282             }
2283         } catch (Throwable t) { unexpected(t); }
2284 
2285         //----------------------------------------------------------------
2286         // Attempt to start process with insufficient permissions fails.
2287         //----------------------------------------------------------------
2288         try {
2289             new File(&quot;emptyCommand&quot;).delete();
2290             new FileOutputStream(&quot;emptyCommand&quot;).close();
2291             new File(&quot;emptyCommand&quot;).setExecutable(false);
2292             new ProcessBuilder(&quot;./emptyCommand&quot;).start();
2293             fail(&quot;Expected IOException not thrown&quot;);
2294         } catch (IOException e) {
2295             new File(&quot;./emptyCommand&quot;).delete();
2296             String m = e.getMessage();
2297             if (EnglishUnix.is() &amp;&amp;
2298                 ! matches(m, &quot;Permission denied&quot;))
2299                 unexpected(e);
2300         } catch (Throwable t) { unexpected(t); }
2301 
2302         new File(&quot;emptyCommand&quot;).delete();
2303 
2304         //----------------------------------------------------------------
2305         // Check for correct security permission behavior
2306         //----------------------------------------------------------------
2307         final Policy policy = new Policy();
2308         Policy.setPolicy(policy);
2309         System.setSecurityManager(new SecurityManager());
2310 
2311         try {
2312             // No permissions required to CREATE a ProcessBuilder
2313             policy.setPermissions(/* Nothing */);
2314             new ProcessBuilder(&quot;env&quot;).directory(null).directory();
2315             new ProcessBuilder(&quot;env&quot;).directory(new File(&quot;dir&quot;)).directory();
2316             new ProcessBuilder(&quot;env&quot;).command(&quot;??&quot;).command();
2317         } catch (Throwable t) { unexpected(t); }
2318 
2319         THROWS(SecurityException.class,
2320                () -&gt; { policy.setPermissions(/* Nothing */);
2321                        System.getenv(&quot;foo&quot;);},
2322                () -&gt; { policy.setPermissions(/* Nothing */);
2323                        System.getenv();},
2324                () -&gt; { policy.setPermissions(/* Nothing */);
2325                        new ProcessBuilder(&quot;echo&quot;).start();},
2326                () -&gt; { policy.setPermissions(/* Nothing */);
2327                        Runtime.getRuntime().exec(&quot;echo&quot;);},
2328                () -&gt; { policy.setPermissions(
2329                                new RuntimePermission(&quot;getenv.bar&quot;));
2330                        System.getenv(&quot;foo&quot;);});
2331 
2332         try {
2333             policy.setPermissions(new RuntimePermission(&quot;getenv.foo&quot;));
2334             System.getenv(&quot;foo&quot;);
2335 
2336             policy.setPermissions(new RuntimePermission(&quot;getenv.*&quot;));
2337             System.getenv(&quot;foo&quot;);
2338             System.getenv();
2339             new ProcessBuilder().environment();
2340         } catch (Throwable t) { unexpected(t); }
2341 
2342 
2343         final Permission execPermission
2344             = new FilePermission(&quot;&lt;&lt;ALL FILES&gt;&gt;&quot;, &quot;execute&quot;);
2345 
2346         THROWS(SecurityException.class,
2347                () -&gt; { // environment permission by itself insufficient
2348                        policy.setPermissions(new RuntimePermission(&quot;getenv.*&quot;));
2349                        ProcessBuilder pb = new ProcessBuilder(&quot;env&quot;);
2350                        pb.environment().put(&quot;foo&quot;,&quot;bar&quot;);
2351                        pb.start();},
2352                () -&gt; { // exec permission by itself insufficient
2353                        policy.setPermissions(execPermission);
2354                        ProcessBuilder pb = new ProcessBuilder(&quot;env&quot;);
2355                        pb.environment().put(&quot;foo&quot;,&quot;bar&quot;);
2356                        pb.start();});
2357 
2358         try {
2359             // Both permissions? OK.
2360             policy.setPermissions(new RuntimePermission(&quot;getenv.*&quot;),
2361                                   execPermission);
2362             ProcessBuilder pb = new ProcessBuilder(&quot;env&quot;);
2363             pb.environment().put(&quot;foo&quot;,&quot;bar&quot;);
2364             Process p = pb.start();
2365             closeStreams(p);
2366         } catch (IOException e) { // OK
2367         } catch (Throwable t) { unexpected(t); }
2368 
2369         try {
2370             // Don&#39;t need environment permission unless READING environment
2371             policy.setPermissions(execPermission);
2372             Runtime.getRuntime().exec(&quot;env&quot;, new String[]{});
2373         } catch (IOException e) { // OK
2374         } catch (Throwable t) { unexpected(t); }
2375 
2376         try {
2377             // Don&#39;t need environment permission unless READING environment
2378             policy.setPermissions(execPermission);
2379             new ProcessBuilder(&quot;env&quot;).start();
2380         } catch (IOException e) { // OK
2381         } catch (Throwable t) { unexpected(t); }
2382 
2383         // Restore &quot;normal&quot; state without a security manager
2384         policy.setPermissions(new RuntimePermission(&quot;setSecurityManager&quot;));
2385         System.setSecurityManager(null);
2386 
2387         //----------------------------------------------------------------
2388         // Check that Process.isAlive() &amp;
2389         // Process.waitFor(0, TimeUnit.MILLISECONDS) work as expected.
2390         //----------------------------------------------------------------
2391         try {
2392             List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
2393             childArgs.add(&quot;sleep&quot;);
2394             final Process p = new ProcessBuilder(childArgs).start();
2395             long start = System.nanoTime();
2396             if (!p.isAlive() || p.waitFor(0, TimeUnit.MILLISECONDS)) {
2397                 fail(&quot;Test failed: Process exited prematurely&quot;);
2398             }
2399             long end = System.nanoTime();
2400             // give waitFor(timeout) a wide berth (2s)
2401             System.out.printf(&quot; waitFor process: delta: %d%n&quot;,(end - start) );
2402 
2403             if ((end - start) &gt; TimeUnit.SECONDS.toNanos(2))
2404                 fail(&quot;Test failed: waitFor took too long (&quot; + (end - start) + &quot;ns)&quot;);
2405 
2406             p.destroy();
2407             p.waitFor();
2408 
2409             if (p.isAlive() ||
2410                 !p.waitFor(0, TimeUnit.MILLISECONDS))
2411             {
2412                 fail(&quot;Test failed: Process still alive - please terminate &quot; +
2413                     p.toString() + &quot; manually&quot;);
2414             }
2415         } catch (Throwable t) { unexpected(t); }
2416 
2417         //----------------------------------------------------------------
2418         // Check that Process.waitFor(timeout, TimeUnit.MILLISECONDS)
2419         // works as expected.
2420         //----------------------------------------------------------------
2421         try {
2422             List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
2423             childArgs.add(&quot;sleep&quot;);
2424             final Process p = new ProcessBuilder(childArgs).start();
2425             long start = System.nanoTime();
2426 
2427             p.waitFor(10, TimeUnit.MILLISECONDS);
2428 
2429             long end = System.nanoTime();
2430             if ((end - start) &lt; TimeUnit.MILLISECONDS.toNanos(10))
2431                 fail(&quot;Test failed: waitFor didn&#39;t take long enough (&quot; + (end - start) + &quot;ns)&quot;);
2432 
2433             p.destroy();
2434         } catch (Throwable t) { unexpected(t); }
2435 
2436         //----------------------------------------------------------------
2437         // Check that Process.waitFor(timeout, TimeUnit.MILLISECONDS)
2438         // interrupt works as expected, if interrupted while waiting.
2439         //----------------------------------------------------------------
2440         try {
2441             List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
2442             childArgs.add(&quot;sleep&quot;);
2443             final Process p = new ProcessBuilder(childArgs).start();
2444             final long start = System.nanoTime();
2445             final CountDownLatch aboutToWaitFor = new CountDownLatch(1);
2446 
2447             final Thread thread = new Thread() {
2448                 public void run() {
2449                     try {
2450                         aboutToWaitFor.countDown();
2451                         Thread.currentThread().interrupt();
2452                         boolean result = p.waitFor(30L * 1000L, TimeUnit.MILLISECONDS);
2453                         fail(&quot;waitFor() wasn&#39;t interrupted, its return value was: &quot; + result);
2454                     } catch (InterruptedException success) {
2455                     } catch (Throwable t) { unexpected(t); }
2456                 }
2457             };
2458 
2459             thread.start();
2460             aboutToWaitFor.await();
2461             thread.interrupt();
2462             thread.join(10L * 1000L);
2463             check(millisElapsedSince(start) &lt; 10L * 1000L);
2464             check(!thread.isAlive());
2465             p.destroy();
2466         } catch (Throwable t) { unexpected(t); }
2467 
2468         //----------------------------------------------------------------
2469         // Check that Process.waitFor(Long.MAX_VALUE, TimeUnit.MILLISECONDS)
2470         // interrupt works as expected, if interrupted while waiting.
2471         //----------------------------------------------------------------
2472         try {
2473             List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
2474             childArgs.add(&quot;sleep&quot;);
2475             final Process p = new ProcessBuilder(childArgs).start();
2476             final long start = System.nanoTime();
2477             final CountDownLatch aboutToWaitFor = new CountDownLatch(1);
2478 
2479             final Thread thread = new Thread() {
2480                 public void run() {
2481                     try {
2482                         aboutToWaitFor.countDown();
2483                         Thread.currentThread().interrupt();
2484                         boolean result = p.waitFor(Long.MAX_VALUE, TimeUnit.MILLISECONDS);
2485                         fail(&quot;waitFor() wasn&#39;t interrupted, its return value was: &quot; + result);
2486                     } catch (InterruptedException success) {
2487                     } catch (Throwable t) { unexpected(t); }
2488                 }
2489             };
2490 
2491             thread.start();
2492             aboutToWaitFor.await();
2493             thread.interrupt();
2494             thread.join(10L * 1000L);
2495             check(millisElapsedSince(start) &lt; 10L * 1000L);
2496             check(!thread.isAlive());
2497             p.destroy();
2498         } catch (Throwable t) { unexpected(t); }
2499 
2500         //----------------------------------------------------------------
2501         // Check that Process.waitFor(timeout, TimeUnit.MILLISECONDS)
2502         // interrupt works as expected, if interrupted before waiting.
2503         //----------------------------------------------------------------
2504         try {
2505             List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
2506             childArgs.add(&quot;sleep&quot;);
2507             final Process p = new ProcessBuilder(childArgs).start();
2508             final long start = System.nanoTime();
2509             final CountDownLatch threadStarted = new CountDownLatch(1);
2510 
2511             final Thread thread = new Thread() {
2512                 public void run() {
2513                     try {
2514                         threadStarted.countDown();
2515                         do { Thread.yield(); }
2516                         while (!Thread.currentThread().isInterrupted());
2517                         boolean result = p.waitFor(30L * 1000L, TimeUnit.MILLISECONDS);
2518                         fail(&quot;waitFor() wasn&#39;t interrupted, its return value was: &quot; + result);
2519                     } catch (InterruptedException success) {
2520                     } catch (Throwable t) { unexpected(t); }
2521                 }
2522             };
2523 
2524             thread.start();
2525             threadStarted.await();
2526             thread.interrupt();
2527             thread.join(10L * 1000L);
2528             check(millisElapsedSince(start) &lt; 10L * 1000L);
2529             check(!thread.isAlive());
2530             p.destroy();
2531         } catch (Throwable t) { unexpected(t); }
2532 
2533         //----------------------------------------------------------------
2534         // Check that Process.waitFor(timeout, null) throws NPE.
2535         //----------------------------------------------------------------
2536         try {
2537             List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
2538             childArgs.add(&quot;sleep&quot;);
2539             final Process p = new ProcessBuilder(childArgs).start();
2540             THROWS(NullPointerException.class,
2541                     () -&gt;  p.waitFor(10L, null));
2542             THROWS(NullPointerException.class,
2543                     () -&gt;  p.waitFor(0L, null));
2544             THROWS(NullPointerException.class,
2545                     () -&gt; p.waitFor(-1L, null));
2546             // Terminate process and recheck after it exits
2547             p.destroy();
2548             p.waitFor();
2549             THROWS(NullPointerException.class,
2550                     () -&gt; p.waitFor(10L, null));
2551             THROWS(NullPointerException.class,
2552                     () -&gt; p.waitFor(0L, null));
2553             THROWS(NullPointerException.class,
2554                     () -&gt; p.waitFor(-1L, null));
2555         } catch (Throwable t) { unexpected(t); }
2556 
2557         //----------------------------------------------------------------
2558         // Check that default implementation of Process.waitFor(timeout, null) throws NPE.
2559         //----------------------------------------------------------------
2560         try {
2561             List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
2562             childArgs.add(&quot;sleep&quot;);
2563             final Process proc = new ProcessBuilder(childArgs).start();
2564             final DelegatingProcess p = new DelegatingProcess(proc);
2565 
2566             THROWS(NullPointerException.class,
2567                     () -&gt;  p.waitFor(10L, null));
2568             THROWS(NullPointerException.class,
2569                     () -&gt;  p.waitFor(0L, null));
2570             THROWS(NullPointerException.class,
2571                     () -&gt;  p.waitFor(-1L, null));
2572             // Terminate process and recheck after it exits
2573             p.destroy();
2574             p.waitFor();
2575             THROWS(NullPointerException.class,
2576                     () -&gt; p.waitFor(10L, null));
2577             THROWS(NullPointerException.class,
2578                     () -&gt; p.waitFor(0L, null));
2579             THROWS(NullPointerException.class,
2580                     () -&gt; p.waitFor(-1L, null));
2581         } catch (Throwable t) { unexpected(t); }
2582 
2583         //----------------------------------------------------------------
2584         // Check the default implementation for
2585         // Process.waitFor(long, TimeUnit)
2586         //----------------------------------------------------------------
2587         try {
2588             List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
2589             childArgs.add(&quot;sleep&quot;);
2590             final Process proc = new ProcessBuilder(childArgs).start();
2591             DelegatingProcess p = new DelegatingProcess(proc);
2592             long start = System.nanoTime();
2593 
2594             p.waitFor(1000, TimeUnit.MILLISECONDS);
2595 
2596             long end = System.nanoTime();
2597             if ((end - start) &lt; 500000000)
2598                 fail(&quot;Test failed: waitFor didn&#39;t take long enough&quot;);
2599 
2600             p.destroy();
2601 
2602             p.waitFor(1000, TimeUnit.MILLISECONDS);
2603         } catch (Throwable t) { unexpected(t); }
2604     }
2605 
2606     static void closeStreams(Process p) {
2607         try {
2608             p.getOutputStream().close();
2609             p.getInputStream().close();
2610             p.getErrorStream().close();
2611         } catch (Throwable t) { unexpected(t); }
2612     }
2613 
2614     //----------------------------------------------------------------
2615     // A Policy class designed to make permissions fiddling very easy.
2616     //----------------------------------------------------------------
2617     private static class Policy extends java.security.Policy {
2618         static final java.security.Policy DEFAULT_POLICY = java.security.Policy.getPolicy();
2619 
2620         private Permissions perms;
2621 
2622         public void setPermissions(Permission...permissions) {
2623             perms = new Permissions();
2624             for (Permission permission : permissions)
2625                 perms.add(permission);
2626         }
2627 
2628         public Policy() { setPermissions(/* Nothing */); }
2629 
2630         public PermissionCollection getPermissions(CodeSource cs) {
2631             return perms;
2632         }
2633 
2634         public PermissionCollection getPermissions(ProtectionDomain pd) {
2635             return perms;
2636         }
2637 
2638         public boolean implies(ProtectionDomain pd, Permission p) {
2639             return perms.implies(p) || DEFAULT_POLICY.implies(pd, p);
2640         }
2641 
2642         public void refresh() {}
2643     }
2644 
2645     private static class StreamAccumulator extends Thread {
2646         private final InputStream is;
2647         private final StringBuilder sb = new StringBuilder();
2648         private Throwable throwable = null;
2649 
2650         public String result () throws Throwable {
2651             if (throwable != null)
2652                 throw throwable;
2653             return sb.toString();
2654         }
2655 
2656         StreamAccumulator (InputStream is) {
2657             this.is = is;
2658         }
2659 
2660         public void run() {
2661             try {
2662                 Reader r = new InputStreamReader(is);
2663                 char[] buf = new char[4096];
2664                 int n;
2665                 while ((n = r.read(buf)) &gt; 0) {
2666                     sb.append(buf,0,n);
2667                 }
2668             } catch (Throwable t) {
2669                 throwable = t;
2670             } finally {
2671                 try { is.close(); }
2672                 catch (Throwable t) { throwable = t; }
2673             }
2674         }
2675     }
2676 
2677     static ProcessResults run(ProcessBuilder pb) {
2678         try {
2679             return run(pb.start());
2680         } catch (Throwable t) { unexpected(t); return null; }
2681     }
2682 
2683     private static ProcessResults run(Process p) {
2684         Throwable throwable = null;
2685         int exitValue = -1;
2686         String out = &quot;&quot;;
2687         String err = &quot;&quot;;
2688 
2689         StreamAccumulator outAccumulator =
2690             new StreamAccumulator(p.getInputStream());
2691         StreamAccumulator errAccumulator =
2692             new StreamAccumulator(p.getErrorStream());
2693 
2694         try {
2695             outAccumulator.start();
2696             errAccumulator.start();
2697 
2698             exitValue = p.waitFor();
2699 
2700             outAccumulator.join();
2701             errAccumulator.join();
2702 
2703             out = outAccumulator.result();
2704             err = errAccumulator.result();
2705         } catch (Throwable t) {
2706             throwable = t;
2707         }
2708 
2709         return new ProcessResults(out, err, exitValue, throwable);
2710     }
2711 
2712     //----------------------------------------------------------------
2713     // Results of a command
2714     //----------------------------------------------------------------
2715     private static class ProcessResults {
2716         private final String out;
2717         private final String err;
2718         private final int exitValue;
2719         private final Throwable throwable;
2720 
2721         public ProcessResults(String out,
2722                               String err,
2723                               int exitValue,
2724                               Throwable throwable) {
2725             this.out = out;
2726             this.err = err;
2727             this.exitValue = exitValue;
2728             this.throwable = throwable;
2729         }
2730 
2731         public String out()          { return out; }
2732         public String err()          { return err; }
2733         public int exitValue()       { return exitValue; }
2734         public Throwable throwable() { return throwable; }
2735 
2736         public String toString() {
2737             StringBuilder sb = new StringBuilder();
2738             sb.append(&quot;&lt;STDOUT&gt;\n&quot; + out() + &quot;&lt;/STDOUT&gt;\n&quot;)
2739                 .append(&quot;&lt;STDERR&gt;\n&quot; + err() + &quot;&lt;/STDERR&gt;\n&quot;)
2740                 .append(&quot;exitValue = &quot; + exitValue + &quot;\n&quot;);
2741             if (throwable != null)
2742                 sb.append(throwable.getStackTrace());
2743             return sb.toString();
2744         }
2745     }
2746 
2747     //--------------------- Infrastructure ---------------------------
2748     static volatile int passed = 0, failed = 0;
2749     static void pass() {passed++;}
2750     static void fail() {failed++; Thread.dumpStack();}
2751     static void fail(String msg) {System.err.println(msg); fail();}
2752     static void unexpected(Throwable t) {failed++; t.printStackTrace();}
2753     static void check(boolean cond) {if (cond) pass(); else fail();}
2754     static void check(boolean cond, String m) {if (cond) pass(); else fail(m);}
2755     static void equal(Object x, Object y) {
2756         if (x == null ? y == null : x.equals(y)) pass();
2757         else fail(&quot;&gt;&#39;&quot; + x + &quot;&#39;&lt;&quot; + &quot; not equal to &quot; + &quot;&#39;&quot; + y + &quot;&#39;&quot;);}
2758 
2759     public static void main(String[] args) throws Throwable {
2760         try {realMain(args);} catch (Throwable t) {unexpected(t);}
2761         System.out.printf(&quot;%nPassed = %d, failed = %d%n%n&quot;, passed, failed);
2762         if (failed &gt; 0) throw new AssertionError(&quot;Some tests failed&quot;);}
2763     interface Fun {void f() throws Throwable;}
2764     static void THROWS(Class&lt;? extends Throwable&gt; k, Fun... fs) {
2765         for (Fun f : fs)
2766             try { f.f(); fail(&quot;Expected &quot; + k.getName() + &quot; not thrown&quot;); }
2767             catch (Throwable t) {
2768                 if (k.isAssignableFrom(t.getClass())) pass();
2769                 else unexpected(t);}}
2770 
2771     static boolean isLocked(final Object monitor, final long millis) throws InterruptedException {
2772         return new Thread() {
2773             volatile boolean unlocked;
2774 
2775             @Override
2776             public void run() {
2777                 synchronized (monitor) { unlocked = true; }
2778             }
2779 
2780             boolean isLocked() throws InterruptedException {
2781                 start();
2782                 join(millis);
2783                 return !unlocked;
2784             }
2785         }.isLocked();
2786     }
2787 }
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>
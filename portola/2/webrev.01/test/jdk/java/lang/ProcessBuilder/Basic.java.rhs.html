<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/lang/ProcessBuilder/Basic.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 /*
  25  * @test
  26  * @bug 4199068 4738465 4937983 4930681 4926230 4931433 4932663 4986689
  27  *      5026830 5023243 5070673 4052517 4811767 6192449 6397034 6413313
  28  *      6464154 6523983 6206031 4960438 6631352 6631966 6850957 6850958
  29  *      4947220 7018606 7034570 4244896 5049299 8003488 8054494 8058464
  30  *      8067796 8224905
  31  * @key intermittent
  32  * @summary Basic tests for Process and Environment Variable code
  33  * @modules java.base/java.lang:open
  34  * @run main/othervm/timeout=300 Basic
  35  * @run main/othervm/timeout=300 -Djdk.lang.Process.launchMechanism=fork Basic
  36  * @author Martin Buchholz
  37  */
  38 
  39 /*
  40  * @test
  41  * @modules java.base/java.lang:open
  42  * @requires (os.family == &quot;linux&quot;)
  43  * @run main/othervm/timeout=300 -Djdk.lang.Process.launchMechanism=posix_spawn Basic
  44  */
  45 
  46 import java.lang.ProcessBuilder.Redirect;
  47 import java.lang.ProcessHandle;
  48 import static java.lang.ProcessBuilder.Redirect.*;
  49 
  50 import java.io.*;
  51 import java.lang.reflect.Field;
  52 import java.nio.file.Files;
  53 import java.nio.file.Paths;
  54 import java.nio.file.StandardCopyOption;
  55 import java.util.*;
  56 import java.util.concurrent.CountDownLatch;
  57 import java.util.concurrent.TimeUnit;
  58 import java.security.*;
  59 import java.util.regex.Pattern;
  60 import java.util.regex.Matcher;
  61 import static java.lang.System.getenv;
  62 import static java.lang.System.out;
  63 import static java.lang.Boolean.TRUE;
  64 import static java.util.AbstractMap.SimpleImmutableEntry;
  65 
  66 public class Basic {
  67 
  68     /* used for Windows only */
  69     static final String systemRoot = System.getenv(&quot;SystemRoot&quot;);
  70 
  71     /* used for Mac OS X only */
  72     static final String cfUserTextEncoding = System.getenv(&quot;__CF_USER_TEXT_ENCODING&quot;);
  73 
  74     /* used for AIX only */
  75     static final String libpath = System.getenv(&quot;LIBPATH&quot;);
  76 
  77     /**
  78      * Returns the number of milliseconds since time given by
  79      * startNanoTime, which must have been previously returned from a
  80      * call to {@link System.nanoTime()}.
  81      */
  82     private static long millisElapsedSince(long startNanoTime) {
  83         return TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanoTime);
  84     }
  85 
  86     private static String commandOutput(Reader r) throws Throwable {
  87         StringBuilder sb = new StringBuilder();
  88         int c;
  89         while ((c = r.read()) &gt; 0)
  90             if (c != &#39;\r&#39;)
  91                 sb.append((char) c);
  92         return sb.toString();
  93     }
  94 
  95     private static String commandOutput(Process p) throws Throwable {
  96         check(p.getInputStream()  == p.getInputStream());
  97         check(p.getOutputStream() == p.getOutputStream());
  98         check(p.getErrorStream()  == p.getErrorStream());
  99         Reader r = new InputStreamReader(p.getInputStream(),&quot;UTF-8&quot;);
 100         String output = commandOutput(r);
 101         equal(p.waitFor(), 0);
 102         equal(p.exitValue(), 0);
 103         // The debug/fastdebug versions of the VM may write some warnings to stdout
 104         // (i.e. &quot;Warning:  Cannot open log file: hotspot.log&quot; if the VM is started
 105         // in a directory without write permissions). These warnings will confuse tests
 106         // which match the entire output of the child process so better filter them out.
 107         return output.replaceAll(&quot;Warning:.*\\n&quot;, &quot;&quot;);
 108     }
 109 
 110     private static String commandOutput(ProcessBuilder pb) {
 111         try {
 112             return commandOutput(pb.start());
 113         } catch (Throwable t) {
 114             String commandline = &quot;&quot;;
 115             for (String arg : pb.command())
 116                 commandline += &quot; &quot; + arg;
 117             System.out.println(&quot;Exception trying to run process: &quot; + commandline);
 118             unexpected(t);
 119             return &quot;&quot;;
 120         }
 121     }
 122 
 123     private static String commandOutput(String...command) {
 124         try {
 125             return commandOutput(Runtime.getRuntime().exec(command));
 126         } catch (Throwable t) {
 127             String commandline = &quot;&quot;;
 128             for (String arg : command)
 129                 commandline += &quot; &quot; + arg;
 130             System.out.println(&quot;Exception trying to run process: &quot; + commandline);
 131             unexpected(t);
 132             return &quot;&quot;;
 133         }
 134     }
 135 
 136     private static void checkCommandOutput(ProcessBuilder pb,
 137                                            String expected,
 138                                            String failureMsg) {
 139         String got = commandOutput(pb);
 140         check(got.equals(expected),
 141               failureMsg + &quot;\n&quot; +
 142               &quot;Expected: \&quot;&quot; + expected + &quot;\&quot;\n&quot; +
 143               &quot;Got: \&quot;&quot; + got + &quot;\&quot;&quot;);
 144     }
 145 
 146     private static String absolutifyPath(String path) {
 147         StringBuilder sb = new StringBuilder();
 148         for (String file : path.split(File.pathSeparator)) {
 149             if (sb.length() != 0)
 150                 sb.append(File.pathSeparator);
 151             sb.append(new File(file).getAbsolutePath());
 152         }
 153         return sb.toString();
 154     }
 155 
 156     // compare windows-style, by canonicalizing to upper case,
 157     // not lower case as String.compareToIgnoreCase does
 158     private static class WindowsComparator
 159         implements Comparator&lt;String&gt; {
 160         public int compare(String x, String y) {
 161             return x.toUpperCase(Locale.US)
 162                 .compareTo(y.toUpperCase(Locale.US));
 163         }
 164     }
 165 
 166     private static String sortedLines(String lines) {
 167         String[] arr = lines.split(&quot;\n&quot;);
 168         List&lt;String&gt; ls = new ArrayList&lt;String&gt;();
 169         for (String s : arr)
 170             ls.add(s);
 171         Collections.sort(ls, new WindowsComparator());
 172         StringBuilder sb = new StringBuilder();
 173         for (String s : ls)
 174             sb.append(s + &quot;\n&quot;);
 175         return sb.toString();
 176     }
 177 
 178     private static void compareLinesIgnoreCase(String lines1, String lines2) {
 179         if (! (sortedLines(lines1).equalsIgnoreCase(sortedLines(lines2)))) {
 180             String dashes =
 181                 &quot;-----------------------------------------------------&quot;;
 182             out.println(dashes);
 183             out.print(sortedLines(lines1));
 184             out.println(dashes);
 185             out.print(sortedLines(lines2));
 186             out.println(dashes);
 187             out.println(&quot;sizes: &quot; + sortedLines(lines1).length() +
 188                         &quot; &quot; + sortedLines(lines2).length());
 189 
 190             fail(&quot;Sorted string contents differ&quot;);
 191         }
 192     }
 193 
 194     private static final Runtime runtime = Runtime.getRuntime();
 195 
 196     private static final String[] winEnvCommand = {&quot;cmd.exe&quot;, &quot;/c&quot;, &quot;set&quot;};
 197 
 198     private static String winEnvFilter(String env) {
 199         return env.replaceAll(&quot;\r&quot;, &quot;&quot;)
 200             .replaceAll(&quot;(?m)^(?:COMSPEC|PROMPT|PATHEXT)=.*\n&quot;,&quot;&quot;);
 201     }
 202 
 203     private static String unixEnvProg() {
 204         return new File(&quot;/usr/bin/env&quot;).canExecute() ? &quot;/usr/bin/env&quot;
 205             : &quot;/bin/env&quot;;
 206     }
 207 
 208     private static String nativeEnv(String[] env) {
 209         try {
 210             if (Windows.is()) {
 211                 return winEnvFilter
 212                     (commandOutput(runtime.exec(winEnvCommand, env)));
 213             } else {
 214                 return commandOutput(runtime.exec(unixEnvProg(), env));
 215             }
 216         } catch (Throwable t) { throw new Error(t); }
 217     }
 218 
 219     private static String nativeEnv(ProcessBuilder pb) {
 220         try {
 221             if (Windows.is()) {
 222                 pb.command(winEnvCommand);
 223                 return winEnvFilter(commandOutput(pb));
 224             } else {
 225                 pb.command(new String[]{unixEnvProg()});
 226                 return commandOutput(pb);
 227             }
 228         } catch (Throwable t) { throw new Error(t); }
 229     }
 230 
 231     private static void checkSizes(Map&lt;String,String&gt; environ, int size) {
 232         try {
 233             equal(size, environ.size());
 234             equal(size, environ.entrySet().size());
 235             equal(size, environ.keySet().size());
 236             equal(size, environ.values().size());
 237 
 238             boolean isEmpty = (size == 0);
 239             equal(isEmpty, environ.isEmpty());
 240             equal(isEmpty, environ.entrySet().isEmpty());
 241             equal(isEmpty, environ.keySet().isEmpty());
 242             equal(isEmpty, environ.values().isEmpty());
 243         } catch (Throwable t) { unexpected(t); }
 244     }
 245 
 246     private interface EnvironmentFrobber {
 247         void doIt(Map&lt;String,String&gt; environ);
 248     }
 249 
 250     private static void testVariableDeleter(EnvironmentFrobber fooDeleter) {
 251         try {
 252             Map&lt;String,String&gt; environ = new ProcessBuilder().environment();
 253             environ.put(&quot;Foo&quot;, &quot;BAAR&quot;);
 254             fooDeleter.doIt(environ);
 255             equal(environ.get(&quot;Foo&quot;), null);
 256             equal(environ.remove(&quot;Foo&quot;), null);
 257         } catch (Throwable t) { unexpected(t); }
 258     }
 259 
 260     private static void testVariableAdder(EnvironmentFrobber fooAdder) {
 261         try {
 262             Map&lt;String,String&gt; environ = new ProcessBuilder().environment();
 263             environ.remove(&quot;Foo&quot;);
 264             fooAdder.doIt(environ);
 265             equal(environ.get(&quot;Foo&quot;), &quot;Bahrein&quot;);
 266         } catch (Throwable t) { unexpected(t); }
 267     }
 268 
 269     private static void testVariableModifier(EnvironmentFrobber fooModifier) {
 270         try {
 271             Map&lt;String,String&gt; environ = new ProcessBuilder().environment();
 272             environ.put(&quot;Foo&quot;,&quot;OldValue&quot;);
 273             fooModifier.doIt(environ);
 274             equal(environ.get(&quot;Foo&quot;), &quot;NewValue&quot;);
 275         } catch (Throwable t) { unexpected(t); }
 276     }
 277 
 278     private static void printUTF8(String s) throws IOException {
 279         out.write(s.getBytes(&quot;UTF-8&quot;));
 280     }
 281 
 282     private static String getenvAsString(Map&lt;String,String&gt; environment) {
 283         StringBuilder sb = new StringBuilder();
 284         environment = new TreeMap&lt;&gt;(environment);
 285         for (Map.Entry&lt;String,String&gt; e : environment.entrySet())
 286             // Ignore magic environment variables added by the launcher
 287             if (! e.getKey().equals(&quot;LD_LIBRARY_PATH&quot;))
 288                 sb.append(e.getKey())
 289                     .append(&#39;=&#39;)
 290                     .append(e.getValue())
 291                     .append(&#39;,&#39;);
 292         return sb.toString();
 293     }
 294 
 295     static void print4095(OutputStream s, byte b) throws Throwable {
 296         byte[] bytes = new byte[4095];
 297         Arrays.fill(bytes, b);
 298         s.write(bytes);         // Might hang!
 299     }
 300 
 301     static void checkPermissionDenied(ProcessBuilder pb) {
 302         try {
 303             pb.start();
 304             fail(&quot;Expected IOException not thrown&quot;);
 305         } catch (IOException e) {
 306             String m = e.getMessage();
 307             if (EnglishUnix.is() &amp;&amp;
 308                 ! matches(m, &quot;Permission denied&quot;))
 309                 unexpected(e);
 310         } catch (Throwable t) { unexpected(t); }
 311     }
 312 
 313     public static class JavaChild {
 314         public static void main(String args[]) throws Throwable {
 315             String action = args[0];
 316             if (action.equals(&quot;sleep&quot;)) {
 317                 Thread.sleep(10 * 60 * 1000L);
 318             } else if (action.equals(&quot;pid&quot;)) {
 319                 System.out.println(ProcessHandle.current().pid());
 320             } else if (action.equals(&quot;testIO&quot;)) {
 321                 String expected = &quot;standard input&quot;;
 322                 char[] buf = new char[expected.length()+1];
 323                 int n = new InputStreamReader(System.in).read(buf,0,buf.length);
 324                 if (n != expected.length())
 325                     System.exit(5);
 326                 if (! new String(buf,0,n).equals(expected))
 327                     System.exit(5);
 328                 System.err.print(&quot;standard error&quot;);
 329                 System.out.print(&quot;standard output&quot;);
 330             } else if (action.equals(&quot;testInheritIO&quot;)
 331                     || action.equals(&quot;testRedirectInherit&quot;)) {
 332                 List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
 333                 childArgs.add(&quot;testIO&quot;);
 334                 ProcessBuilder pb = new ProcessBuilder(childArgs);
 335                 if (action.equals(&quot;testInheritIO&quot;))
 336                     pb.inheritIO();
 337                 else
 338                     redirectIO(pb, INHERIT, INHERIT, INHERIT);
 339                 ProcessResults r = run(pb);
 340                 if (! r.out().equals(&quot;&quot;))
 341                     System.exit(7);
 342                 if (! r.err().equals(&quot;&quot;))
 343                     System.exit(8);
 344                 if (r.exitValue() != 0)
 345                     System.exit(9);
 346             } else if (action.equals(&quot;System.getenv(String)&quot;)) {
 347                 String val = System.getenv(args[1]);
 348                 printUTF8(val == null ? &quot;null&quot; : val);
 349             } else if (action.equals(&quot;System.getenv(\\u1234)&quot;)) {
 350                 String val = System.getenv(&quot;\u1234&quot;);
 351                 printUTF8(val == null ? &quot;null&quot; : val);
 352             } else if (action.equals(&quot;System.getenv()&quot;)) {
 353                 printUTF8(getenvAsString(System.getenv()));
 354             } else if (action.equals(&quot;ArrayOOME&quot;)) {
 355                 Object dummy;
 356                 switch(new Random().nextInt(3)) {
 357                 case 0: dummy = new Integer[Integer.MAX_VALUE]; break;
 358                 case 1: dummy = new double[Integer.MAX_VALUE];  break;
 359                 case 2: dummy = new byte[Integer.MAX_VALUE][];  break;
 360                 default: throw new InternalError();
 361                 }
 362             } else if (action.equals(&quot;pwd&quot;)) {
 363                 printUTF8(new File(System.getProperty(&quot;user.dir&quot;))
 364                           .getCanonicalPath());
 365             } else if (action.equals(&quot;print4095&quot;)) {
 366                 print4095(System.out, (byte) &#39;!&#39;);
 367                 print4095(System.err, (byte) &#39;E&#39;);
 368                 System.exit(5);
 369             } else if (action.equals(&quot;OutErr&quot;)) {
 370                 // You might think the system streams would be
 371                 // buffered, and in fact they are implemented using
 372                 // BufferedOutputStream, but each and every print
 373                 // causes immediate operating system I/O.
 374                 System.out.print(&quot;out&quot;);
 375                 System.err.print(&quot;err&quot;);
 376                 System.out.print(&quot;out&quot;);
 377                 System.err.print(&quot;err&quot;);
 378             } else if (action.equals(&quot;null PATH&quot;)) {
 379                 equal(System.getenv(&quot;PATH&quot;), null);
 380                 check(new File(&quot;/bin/true&quot;).exists());
 381                 check(new File(&quot;/bin/false&quot;).exists());
 382                 ProcessBuilder pb1 = new ProcessBuilder();
 383                 ProcessBuilder pb2 = new ProcessBuilder();
 384                 pb2.environment().put(&quot;PATH&quot;, &quot;anyOldPathIgnoredAnyways&quot;);
 385                 ProcessResults r;
 386 
 387                 for (final ProcessBuilder pb :
 388                          new ProcessBuilder[] {pb1, pb2}) {
 389                     pb.command(&quot;true&quot;);
 390                     equal(run(pb).exitValue(), True.exitValue());
 391 
 392                     pb.command(&quot;false&quot;);
 393                     equal(run(pb).exitValue(), False.exitValue());
 394                 }
 395 
 396                 if (failed != 0) throw new Error(&quot;null PATH&quot;);
 397             } else if (action.equals(&quot;PATH search algorithm&quot;)) {
 398                 equal(System.getenv(&quot;PATH&quot;), &quot;dir1:dir2:&quot;);
<a name="1" id="anc1"></a><span class="line-modified"> 399                 check(new File(TrueExe.path()).exists());</span>
<span class="line-modified"> 400                 check(new File(FalseExe.path()).exists());</span>
 401                 String[] cmd = {&quot;prog&quot;};
 402                 ProcessBuilder pb1 = new ProcessBuilder(cmd);
 403                 ProcessBuilder pb2 = new ProcessBuilder(cmd);
 404                 ProcessBuilder pb3 = new ProcessBuilder(cmd);
 405                 pb2.environment().put(&quot;PATH&quot;, &quot;anyOldPathIgnoredAnyways&quot;);
 406                 pb3.environment().remove(&quot;PATH&quot;);
 407 
 408                 for (final ProcessBuilder pb :
 409                          new ProcessBuilder[] {pb1, pb2, pb3}) {
 410                     try {
 411                         // Not on PATH at all; directories don&#39;t exist
 412                         try {
 413                             pb.start();
 414                             fail(&quot;Expected IOException not thrown&quot;);
 415                         } catch (IOException e) {
 416                             String m = e.getMessage();
 417                             if (EnglishUnix.is() &amp;&amp;
 418                                 ! matches(m, &quot;No such file&quot;))
 419                                 unexpected(e);
 420                         } catch (Throwable t) { unexpected(t); }
 421 
 422                         // Not on PATH at all; directories exist
 423                         new File(&quot;dir1&quot;).mkdirs();
 424                         new File(&quot;dir2&quot;).mkdirs();
 425                         try {
 426                             pb.start();
 427                             fail(&quot;Expected IOException not thrown&quot;);
 428                         } catch (IOException e) {
 429                             String m = e.getMessage();
 430                             if (EnglishUnix.is() &amp;&amp;
 431                                 ! matches(m, &quot;No such file&quot;))
 432                                 unexpected(e);
 433                         } catch (Throwable t) { unexpected(t); }
 434 
 435                         // Can&#39;t execute a directory -- permission denied
 436                         // Report EACCES errno
 437                         new File(&quot;dir1/prog&quot;).mkdirs();
 438                         checkPermissionDenied(pb);
 439 
 440                         // continue searching if EACCES
<a name="2" id="anc2"></a><span class="line-modified"> 441                         copy(TrueExe.path(), &quot;dir2/prog&quot;);</span>
 442                         equal(run(pb).exitValue(), True.exitValue());
 443                         new File(&quot;dir1/prog&quot;).delete();
 444                         new File(&quot;dir2/prog&quot;).delete();
 445 
 446                         new File(&quot;dir2/prog&quot;).mkdirs();
<a name="3" id="anc3"></a><span class="line-modified"> 447                         copy(TrueExe.path(), &quot;dir1/prog&quot;);</span>
 448                         equal(run(pb).exitValue(), True.exitValue());
 449 
 450                         // Check empty PATH component means current directory.
 451                         //
 452                         // While we&#39;re here, let&#39;s test different kinds of
 453                         // Unix executables, and PATH vs explicit searching.
 454                         new File(&quot;dir1/prog&quot;).delete();
 455                         new File(&quot;dir2/prog&quot;).delete();
 456                         for (String[] command :
 457                                  new String[][] {
 458                                      new String[] {&quot;./prog&quot;},
 459                                      cmd}) {
 460                             pb.command(command);
 461                             File prog = new File(&quot;./prog&quot;);
 462                             // &quot;Normal&quot; binaries
<a name="4" id="anc4"></a><span class="line-modified"> 463                             copy(TrueExe.path(), &quot;./prog&quot;);</span>
 464                             equal(run(pb).exitValue(),
 465                                   True.exitValue());
<a name="5" id="anc5"></a><span class="line-modified"> 466                             copy(FalseExe.path(), &quot;./prog&quot;);</span>
 467                             equal(run(pb).exitValue(),
 468                                   False.exitValue());
 469                             prog.delete();
 470                             // Interpreter scripts with #!
 471                             setFileContents(prog, &quot;#!/bin/true\n&quot;);
 472                             prog.setExecutable(true);
 473                             equal(run(pb).exitValue(),
 474                                   True.exitValue());
 475                             prog.delete();
 476                             setFileContents(prog, &quot;#!/bin/false\n&quot;);
 477                             prog.setExecutable(true);
 478                             equal(run(pb).exitValue(),
 479                                   False.exitValue());
 480                             // Traditional shell scripts without #!
 481                             setFileContents(prog, &quot;exec /bin/true\n&quot;);
 482                             prog.setExecutable(true);
 483                             equal(run(pb).exitValue(),
 484                                   True.exitValue());
 485                             prog.delete();
 486                             setFileContents(prog, &quot;exec /bin/false\n&quot;);
 487                             prog.setExecutable(true);
 488                             equal(run(pb).exitValue(),
 489                                   False.exitValue());
 490                             prog.delete();
 491                         }
 492 
 493                         // Test Unix interpreter scripts
 494                         File dir1Prog = new File(&quot;dir1/prog&quot;);
 495                         dir1Prog.delete();
 496                         pb.command(new String[] {&quot;prog&quot;, &quot;world&quot;});
 497                         setFileContents(dir1Prog, &quot;#!/bin/echo hello\n&quot;);
 498                         checkPermissionDenied(pb);
 499                         dir1Prog.setExecutable(true);
 500                         equal(run(pb).out(), &quot;hello dir1/prog world\n&quot;);
 501                         equal(run(pb).exitValue(), True.exitValue());
 502                         dir1Prog.delete();
 503                         pb.command(cmd);
 504 
 505                         // Test traditional shell scripts without #!
 506                         setFileContents(dir1Prog, &quot;/bin/echo \&quot;$@\&quot;\n&quot;);
 507                         pb.command(new String[] {&quot;prog&quot;, &quot;hello&quot;, &quot;world&quot;});
 508                         checkPermissionDenied(pb);
 509                         dir1Prog.setExecutable(true);
 510                         equal(run(pb).out(), &quot;hello world\n&quot;);
 511                         equal(run(pb).exitValue(), True.exitValue());
 512                         dir1Prog.delete();
 513                         pb.command(cmd);
 514 
 515                         // If prog found on both parent and child&#39;s PATH,
 516                         // parent&#39;s is used.
 517                         new File(&quot;dir1/prog&quot;).delete();
 518                         new File(&quot;dir2/prog&quot;).delete();
 519                         new File(&quot;prog&quot;).delete();
 520                         new File(&quot;dir3&quot;).mkdirs();
<a name="6" id="anc6"></a><span class="line-modified"> 521                         copy(TrueExe.path(), &quot;dir1/prog&quot;);</span>
<span class="line-modified"> 522                         copy(FalseExe.path(), &quot;dir3/prog&quot;);</span>
 523                         pb.environment().put(&quot;PATH&quot;,&quot;dir3&quot;);
 524                         equal(run(pb).exitValue(), True.exitValue());
<a name="7" id="anc7"></a><span class="line-modified"> 525                         copy(TrueExe.path(), &quot;dir3/prog&quot;);</span>
<span class="line-modified"> 526                         copy(FalseExe.path(), &quot;dir1/prog&quot;);</span>
 527                         equal(run(pb).exitValue(), False.exitValue());
 528 
 529                     } finally {
 530                         // cleanup
 531                         new File(&quot;dir1/prog&quot;).delete();
 532                         new File(&quot;dir2/prog&quot;).delete();
 533                         new File(&quot;dir3/prog&quot;).delete();
 534                         new File(&quot;dir1&quot;).delete();
 535                         new File(&quot;dir2&quot;).delete();
 536                         new File(&quot;dir3&quot;).delete();
 537                         new File(&quot;prog&quot;).delete();
 538                     }
 539                 }
 540 
 541                 if (failed != 0) throw new Error(&quot;PATH search algorithm&quot;);
 542             }
 543             else throw new Error(&quot;JavaChild invocation error&quot;);
 544         }
 545     }
 546 
 547     private static void copy(String src, String dst) throws IOException {
 548         Files.copy(Paths.get(src), Paths.get(dst),
 549                    StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.COPY_ATTRIBUTES);
 550     }
 551 
 552     private static String javaChildOutput(ProcessBuilder pb, String...args) {
 553         List&lt;String&gt; list = new ArrayList&lt;String&gt;(javaChildArgs);
 554         for (String arg : args)
 555             list.add(arg);
 556         pb.command(list);
 557         return commandOutput(pb);
 558     }
 559 
 560     private static String getenvInChild(ProcessBuilder pb) {
 561         return javaChildOutput(pb, &quot;System.getenv()&quot;);
 562     }
 563 
 564     private static String getenvInChild1234(ProcessBuilder pb) {
 565         return javaChildOutput(pb, &quot;System.getenv(\\u1234)&quot;);
 566     }
 567 
 568     private static String getenvInChild(ProcessBuilder pb, String name) {
 569         return javaChildOutput(pb, &quot;System.getenv(String)&quot;, name);
 570     }
 571 
 572     private static String pwdInChild(ProcessBuilder pb) {
 573         return javaChildOutput(pb, &quot;pwd&quot;);
 574     }
 575 
 576     private static final String javaExe =
 577         System.getProperty(&quot;java.home&quot;) +
 578         File.separator + &quot;bin&quot; + File.separator + &quot;java&quot;;
 579 
 580     private static final String classpath =
 581         System.getProperty(&quot;java.class.path&quot;);
 582 
 583     private static final List&lt;String&gt; javaChildArgs =
 584         Arrays.asList(javaExe,
 585                       &quot;-XX:+DisplayVMOutputToStderr&quot;,
 586                       &quot;-classpath&quot;, absolutifyPath(classpath),
 587                       &quot;Basic$JavaChild&quot;);
 588 
 589     private static void testEncoding(String encoding, String tested) {
 590         try {
 591             // If round trip conversion works, should be able to set env vars
 592             // correctly in child.
 593             if (new String(tested.getBytes()).equals(tested)) {
 594                 out.println(&quot;Testing &quot; + encoding + &quot; environment values&quot;);
 595                 ProcessBuilder pb = new ProcessBuilder();
 596                 pb.environment().put(&quot;ASCIINAME&quot;,tested);
 597                 equal(getenvInChild(pb,&quot;ASCIINAME&quot;), tested);
 598             }
 599         } catch (Throwable t) { unexpected(t); }
 600     }
 601 
 602     static class Windows {
 603         public static boolean is() { return is; }
 604         private static final boolean is =
 605             System.getProperty(&quot;os.name&quot;).startsWith(&quot;Windows&quot;);
 606     }
 607 
 608     static class AIX {
 609         public static boolean is() { return is; }
 610         private static final boolean is =
 611             System.getProperty(&quot;os.name&quot;).equals(&quot;AIX&quot;);
 612     }
 613 
 614     static class Unix {
 615         public static boolean is() { return is; }
 616         private static final boolean is =
 617             (! Windows.is() &amp;&amp;
 618              new File(&quot;/bin/sh&quot;).exists() &amp;&amp;
 619              new File(&quot;/bin/true&quot;).exists() &amp;&amp;
 620              new File(&quot;/bin/false&quot;).exists());
 621     }
 622 
<a name="8" id="anc8"></a><span class="line-added"> 623     static class BusyBox {</span>
<span class="line-added"> 624         public static boolean is() { return is; }</span>
<span class="line-added"> 625         private static final boolean is =</span>
<span class="line-added"> 626             (! Windows.is() &amp;&amp;</span>
<span class="line-added"> 627              new File(&quot;/bin/busybox&quot;).exists());</span>
<span class="line-added"> 628     }</span>
<span class="line-added"> 629 </span>
 630     static class UnicodeOS {
 631         public static boolean is() { return is; }
 632         private static final String osName = System.getProperty(&quot;os.name&quot;);
 633         private static final boolean is =
 634             // MacOS X would probably also qualify
 635             osName.startsWith(&quot;Windows&quot;)   &amp;&amp;
 636             ! osName.startsWith(&quot;Windows 9&quot;) &amp;&amp;
 637             ! osName.equals(&quot;Windows Me&quot;);
 638     }
 639 
 640     static class MacOSX {
 641         public static boolean is() { return is; }
 642         private static final String osName = System.getProperty(&quot;os.name&quot;);
 643         private static final boolean is = osName.contains(&quot;OS X&quot;);
 644     }
 645 
 646     static class True {
 647         public static int exitValue() { return 0; }
 648     }
 649 
 650     private static class False {
 651         public static int exitValue() { return exitValue; }
 652         private static final int exitValue = exitValue0();
 653         private static int exitValue0() {
 654             // /bin/false returns an *unspecified* non-zero number.
 655             try {
 656                 if (! Unix.is())
 657                     return -1;
 658                 else {
 659                     int rc = new ProcessBuilder(&quot;/bin/false&quot;)
 660                         .start().waitFor();
 661                     check(rc != 0);
 662                     return rc;
 663                 }
 664             } catch (Throwable t) { unexpected(t); return -1; }
 665         }
 666     }
 667 
<a name="9" id="anc9"></a><span class="line-added"> 668     // On alpine linux, /bin/true and /bin/false are just links to /bin/busybox.</span>
<span class="line-added"> 669     // Some tests copy /bin/true and /bin/false to files with a different filename.</span>
<span class="line-added"> 670     // However, copying the busbox executable into a file with a different name</span>
<span class="line-added"> 671     // won&#39;t result in the expected return codes. As workaround, we create</span>
<span class="line-added"> 672     // executable files that can be copied and produce the exepected return</span>
<span class="line-added"> 673     // values. We use this workaround, if we find the busybox executable.</span>
<span class="line-added"> 674 </span>
<span class="line-added"> 675     private static class TrueExe {</span>
<span class="line-added"> 676         public static String path() { return path; }</span>
<span class="line-added"> 677         private static final String path = path0();</span>
<span class="line-added"> 678         private static String path0(){</span>
<span class="line-added"> 679             if (!BusyBox.is()) {</span>
<span class="line-added"> 680                 return &quot;/bin/true&quot;;</span>
<span class="line-added"> 681             }</span>
<span class="line-added"> 682             else {</span>
<span class="line-added"> 683                 File trueExe = new File(&quot;true&quot;);</span>
<span class="line-added"> 684                 setFileContents(trueExe, &quot;#!/bin/true\n&quot;);</span>
<span class="line-added"> 685                 trueExe.setExecutable(true);</span>
<span class="line-added"> 686                 return trueExe.getAbsolutePath();</span>
<span class="line-added"> 687             }</span>
<span class="line-added"> 688         }</span>
<span class="line-added"> 689     }</span>
<span class="line-added"> 690 </span>
<span class="line-added"> 691     private static class FalseExe {</span>
<span class="line-added"> 692         public static String path() { return path; }</span>
<span class="line-added"> 693         private static final String path = path0();</span>
<span class="line-added"> 694         private static String path0(){</span>
<span class="line-added"> 695             if (!BusyBox.is()) {</span>
<span class="line-added"> 696                 return &quot;/bin/false&quot;;</span>
<span class="line-added"> 697             }</span>
<span class="line-added"> 698             else {</span>
<span class="line-added"> 699                 File falseExe = new File(&quot;false&quot;);</span>
<span class="line-added"> 700                 setFileContents(falseExe, &quot;#!/bin/false\n&quot;);</span>
<span class="line-added"> 701                 falseExe.setExecutable(true);</span>
<span class="line-added"> 702                 return falseExe.getAbsolutePath();</span>
<span class="line-added"> 703             }</span>
<span class="line-added"> 704         }</span>
<span class="line-added"> 705     }</span>
<span class="line-added"> 706 </span>
 707     static class EnglishUnix {
 708         private static final Boolean is =
 709             (! Windows.is() &amp;&amp; isEnglish(&quot;LANG&quot;) &amp;&amp; isEnglish(&quot;LC_ALL&quot;));
 710 
 711         private static boolean isEnglish(String envvar) {
 712             String val = getenv(envvar);
 713             return (val == null) || val.matches(&quot;en.*&quot;) || val.matches(&quot;C&quot;);
 714         }
 715 
 716         /** Returns true if we can expect English OS error strings */
 717         static boolean is() { return is; }
 718     }
 719 
 720     static class DelegatingProcess extends Process {
 721         final Process p;
 722 
 723         DelegatingProcess(Process p) {
 724             this.p = p;
 725         }
 726 
 727         @Override
 728         public void destroy() {
 729             p.destroy();
 730         }
 731 
 732         @Override
 733         public int exitValue() {
 734             return p.exitValue();
 735         }
 736 
 737         @Override
 738         public int waitFor() throws InterruptedException {
 739             return p.waitFor();
 740         }
 741 
 742         @Override
 743         public OutputStream getOutputStream() {
 744             return p.getOutputStream();
 745         }
 746 
 747         @Override
 748         public InputStream getInputStream() {
 749             return p.getInputStream();
 750         }
 751 
 752         @Override
 753         public InputStream getErrorStream() {
 754             return p.getErrorStream();
 755         }
 756     }
 757 
 758     private static boolean matches(String str, String regex) {
 759         return Pattern.compile(regex).matcher(str).find();
 760     }
 761 
 762     private static String matchAndExtract(String str, String regex) {
 763         Matcher matcher = Pattern.compile(regex).matcher(str);
 764         if (matcher.find()) {
 765             return matcher.group();
 766         } else {
 767             return &quot;&quot;;
 768         }
 769     }
 770 
 771     /* Only used for Mac OS X --
 772      * Mac OS X (may) add the variable __CF_USER_TEXT_ENCODING to an empty
 773      * environment. The environment variable JAVA_MAIN_CLASS_&lt;pid&gt; may also
 774      * be set in Mac OS X.
 775      * Remove them both from the list of env variables
 776      */
 777     private static String removeMacExpectedVars(String vars) {
 778         // Check for __CF_USER_TEXT_ENCODING
 779         String cleanedVars = vars.replace(&quot;__CF_USER_TEXT_ENCODING=&quot;
 780                                             +cfUserTextEncoding+&quot;,&quot;,&quot;&quot;);
 781         // Check for JAVA_MAIN_CLASS_&lt;pid&gt;
 782         String javaMainClassStr
 783                 = matchAndExtract(cleanedVars,
 784                                     &quot;JAVA_MAIN_CLASS_\\d+=Basic.JavaChild,&quot;);
 785         return cleanedVars.replace(javaMainClassStr,&quot;&quot;);
 786     }
 787 
 788     /* Only used for AIX --
 789      * AIX adds the variable AIXTHREAD_GUARDPAGES=0 to the environment.
 790      * Remove it from the list of env variables
 791      */
 792     private static String removeAixExpectedVars(String vars) {
 793         return vars.replace(&quot;AIXTHREAD_GUARDPAGES=0,&quot;, &quot;&quot;);
 794     }
 795 
 796     private static String sortByLinesWindowsly(String text) {
 797         String[] lines = text.split(&quot;\n&quot;);
 798         Arrays.sort(lines, new WindowsComparator());
 799         StringBuilder sb = new StringBuilder();
 800         for (String line : lines)
 801             sb.append(line).append(&quot;\n&quot;);
 802         return sb.toString();
 803     }
 804 
 805     private static void checkMapSanity(Map&lt;String,String&gt; map) {
 806         try {
 807             Set&lt;String&gt; keySet = map.keySet();
 808             Collection&lt;String&gt; values = map.values();
 809             Set&lt;Map.Entry&lt;String,String&gt;&gt; entrySet = map.entrySet();
 810 
 811             equal(entrySet.size(), keySet.size());
 812             equal(entrySet.size(), values.size());
 813 
 814             StringBuilder s1 = new StringBuilder();
 815             for (Map.Entry&lt;String,String&gt; e : entrySet)
 816                 s1.append(e.getKey() + &quot;=&quot; + e.getValue() + &quot;\n&quot;);
 817 
 818             StringBuilder s2 = new StringBuilder();
 819             for (String var : keySet)
 820                 s2.append(var + &quot;=&quot; + map.get(var) + &quot;\n&quot;);
 821 
 822             equal(s1.toString(), s2.toString());
 823 
 824             Iterator&lt;String&gt; kIter = keySet.iterator();
 825             Iterator&lt;String&gt; vIter = values.iterator();
 826             Iterator&lt;Map.Entry&lt;String,String&gt;&gt; eIter = entrySet.iterator();
 827 
 828             while (eIter.hasNext()) {
 829                 Map.Entry&lt;String,String&gt; entry = eIter.next();
 830                 String key   = kIter.next();
 831                 String value = vIter.next();
 832                 check(entrySet.contains(entry));
 833                 check(keySet.contains(key));
 834                 check(values.contains(value));
 835                 check(map.containsKey(key));
 836                 check(map.containsValue(value));
 837                 equal(entry.getKey(), key);
 838                 equal(entry.getValue(), value);
 839             }
 840             check(!kIter.hasNext() &amp;&amp;
 841                     !vIter.hasNext());
 842 
 843         } catch (Throwable t) { unexpected(t); }
 844     }
 845 
 846     private static void checkMapEquality(Map&lt;String,String&gt; map1,
 847                                          Map&lt;String,String&gt; map2) {
 848         try {
 849             equal(map1.size(), map2.size());
 850             equal(map1.isEmpty(), map2.isEmpty());
 851             for (String key : map1.keySet()) {
 852                 equal(map1.get(key), map2.get(key));
 853                 check(map2.keySet().contains(key));
 854             }
 855             equal(map1, map2);
 856             equal(map2, map1);
 857             equal(map1.entrySet(), map2.entrySet());
 858             equal(map2.entrySet(), map1.entrySet());
 859             equal(map1.keySet(), map2.keySet());
 860             equal(map2.keySet(), map1.keySet());
 861 
 862             equal(map1.hashCode(), map2.hashCode());
 863             equal(map1.entrySet().hashCode(), map2.entrySet().hashCode());
 864             equal(map1.keySet().hashCode(), map2.keySet().hashCode());
 865         } catch (Throwable t) { unexpected(t); }
 866     }
 867 
 868     static void checkRedirects(ProcessBuilder pb,
 869                                Redirect in, Redirect out, Redirect err) {
 870         equal(pb.redirectInput(), in);
 871         equal(pb.redirectOutput(), out);
 872         equal(pb.redirectError(), err);
 873     }
 874 
 875     static void redirectIO(ProcessBuilder pb,
 876                            Redirect in, Redirect out, Redirect err) {
 877         pb.redirectInput(in);
 878         pb.redirectOutput(out);
 879         pb.redirectError(err);
 880     }
 881 
 882     static void setFileContents(File file, String contents) {
 883         try {
 884             Writer w = new FileWriter(file);
 885             w.write(contents);
 886             w.close();
 887         } catch (Throwable t) { unexpected(t); }
 888     }
 889 
 890     static String fileContents(File file) {
 891         try {
 892             Reader r = new FileReader(file);
 893             StringBuilder sb = new StringBuilder();
 894             char[] buffer = new char[1024];
 895             int n;
 896             while ((n = r.read(buffer)) != -1)
 897                 sb.append(buffer,0,n);
 898             r.close();
 899             return new String(sb);
 900         } catch (Throwable t) { unexpected(t); return &quot;&quot;; }
 901     }
 902 
 903     static void testIORedirection() throws Throwable {
 904         final File ifile = new File(&quot;ifile&quot;);
 905         final File ofile = new File(&quot;ofile&quot;);
 906         final File efile = new File(&quot;efile&quot;);
 907         ifile.delete();
 908         ofile.delete();
 909         efile.delete();
 910 
 911         //----------------------------------------------------------------
 912         // Check mutual inequality of different types of Redirect
 913         //----------------------------------------------------------------
 914         Redirect[] redirects =
 915             { PIPE,
 916               INHERIT,
 917               DISCARD,
 918               Redirect.from(ifile),
 919               Redirect.to(ifile),
 920               Redirect.appendTo(ifile),
 921               Redirect.from(ofile),
 922               Redirect.to(ofile),
 923               Redirect.appendTo(ofile),
 924             };
 925         for (int i = 0; i &lt; redirects.length; i++)
 926             for (int j = 0; j &lt; redirects.length; j++)
 927                 equal(redirects[i].equals(redirects[j]), (i == j));
 928 
 929         //----------------------------------------------------------------
 930         // Check basic properties of different types of Redirect
 931         //----------------------------------------------------------------
 932         equal(PIPE.type(), Redirect.Type.PIPE);
 933         equal(PIPE.toString(), &quot;PIPE&quot;);
 934         equal(PIPE.file(), null);
 935 
 936         equal(INHERIT.type(), Redirect.Type.INHERIT);
 937         equal(INHERIT.toString(), &quot;INHERIT&quot;);
 938         equal(INHERIT.file(), null);
 939 
 940         equal(DISCARD.type(), Redirect.Type.WRITE);
 941         equal(DISCARD.toString(), &quot;WRITE&quot;);
 942         equal(DISCARD.file(), new File((Windows.is() ? &quot;NUL&quot; : &quot;/dev/null&quot;)));
 943 
 944         equal(Redirect.from(ifile).type(), Redirect.Type.READ);
 945         equal(Redirect.from(ifile).toString(),
 946               &quot;redirect to read from file \&quot;ifile\&quot;&quot;);
 947         equal(Redirect.from(ifile).file(), ifile);
 948         equal(Redirect.from(ifile),
 949               Redirect.from(ifile));
 950         equal(Redirect.from(ifile).hashCode(),
 951               Redirect.from(ifile).hashCode());
 952 
 953         equal(Redirect.to(ofile).type(), Redirect.Type.WRITE);
 954         equal(Redirect.to(ofile).toString(),
 955               &quot;redirect to write to file \&quot;ofile\&quot;&quot;);
 956         equal(Redirect.to(ofile).file(), ofile);
 957         equal(Redirect.to(ofile),
 958               Redirect.to(ofile));
 959         equal(Redirect.to(ofile).hashCode(),
 960               Redirect.to(ofile).hashCode());
 961 
 962         equal(Redirect.appendTo(ofile).type(), Redirect.Type.APPEND);
 963         equal(Redirect.appendTo(efile).toString(),
 964               &quot;redirect to append to file \&quot;efile\&quot;&quot;);
 965         equal(Redirect.appendTo(efile).file(), efile);
 966         equal(Redirect.appendTo(efile),
 967               Redirect.appendTo(efile));
 968         equal(Redirect.appendTo(efile).hashCode(),
 969               Redirect.appendTo(efile).hashCode());
 970 
 971         //----------------------------------------------------------------
 972         // Check initial values of redirects
 973         //----------------------------------------------------------------
 974         List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
 975         childArgs.add(&quot;testIO&quot;);
 976         final ProcessBuilder pb = new ProcessBuilder(childArgs);
 977         checkRedirects(pb, PIPE, PIPE, PIPE);
 978 
 979         //----------------------------------------------------------------
 980         // Check inheritIO
 981         //----------------------------------------------------------------
 982         pb.inheritIO();
 983         checkRedirects(pb, INHERIT, INHERIT, INHERIT);
 984 
 985         //----------------------------------------------------------------
 986         // Check DISCARD for stdout,stderr
 987         //----------------------------------------------------------------
 988         redirectIO(pb, INHERIT, DISCARD, DISCARD);
 989         checkRedirects(pb, INHERIT, DISCARD, DISCARD);
 990 
 991         //----------------------------------------------------------------
 992         // Check setters and getters agree
 993         //----------------------------------------------------------------
 994         pb.redirectInput(ifile);
 995         equal(pb.redirectInput().file(), ifile);
 996         equal(pb.redirectInput(), Redirect.from(ifile));
 997 
 998         pb.redirectOutput(ofile);
 999         equal(pb.redirectOutput().file(), ofile);
1000         equal(pb.redirectOutput(), Redirect.to(ofile));
1001 
1002         pb.redirectError(efile);
1003         equal(pb.redirectError().file(), efile);
1004         equal(pb.redirectError(), Redirect.to(efile));
1005 
1006         THROWS(IllegalArgumentException.class,
1007                () -&gt; pb.redirectInput(Redirect.to(ofile)),
1008                () -&gt; pb.redirectOutput(Redirect.from(ifile)),
1009                () -&gt; pb.redirectError(Redirect.from(ifile)),
1010                () -&gt; pb.redirectInput(DISCARD));
1011 
1012         THROWS(NullPointerException.class,
1013                 () -&gt; pb.redirectInput((File)null),
1014                 () -&gt; pb.redirectOutput((File)null),
1015                 () -&gt; pb.redirectError((File)null),
1016                 () -&gt; pb.redirectInput((Redirect)null),
1017                 () -&gt; pb.redirectOutput((Redirect)null),
1018                 () -&gt; pb.redirectError((Redirect)null));
1019 
1020         THROWS(IOException.class,
1021                // Input file does not exist
1022                () -&gt; pb.start());
1023         setFileContents(ifile, &quot;standard input&quot;);
1024 
1025         //----------------------------------------------------------------
1026         // Writing to non-existent files
1027         //----------------------------------------------------------------
1028         {
1029             ProcessResults r = run(pb);
1030             equal(r.exitValue(), 0);
1031             equal(fileContents(ofile), &quot;standard output&quot;);
1032             equal(fileContents(efile), &quot;standard error&quot;);
1033             equal(r.out(), &quot;&quot;);
1034             equal(r.err(), &quot;&quot;);
1035             ofile.delete();
1036             efile.delete();
1037         }
1038 
1039         //----------------------------------------------------------------
1040         // Both redirectErrorStream + redirectError
1041         //----------------------------------------------------------------
1042         {
1043             pb.redirectErrorStream(true);
1044             ProcessResults r = run(pb);
1045             equal(r.exitValue(), 0);
1046             equal(fileContents(ofile),
1047                     &quot;standard error&quot; + &quot;standard output&quot;);
1048             equal(fileContents(efile), &quot;&quot;);
1049             equal(r.out(), &quot;&quot;);
1050             equal(r.err(), &quot;&quot;);
1051             ofile.delete();
1052             efile.delete();
1053         }
1054 
1055         //----------------------------------------------------------------
1056         // Appending to existing files
1057         //----------------------------------------------------------------
1058         {
1059             setFileContents(ofile, &quot;ofile-contents&quot;);
1060             setFileContents(efile, &quot;efile-contents&quot;);
1061             pb.redirectOutput(Redirect.appendTo(ofile));
1062             pb.redirectError(Redirect.appendTo(efile));
1063             pb.redirectErrorStream(false);
1064             ProcessResults r = run(pb);
1065             equal(r.exitValue(), 0);
1066             equal(fileContents(ofile),
1067                   &quot;ofile-contents&quot; + &quot;standard output&quot;);
1068             equal(fileContents(efile),
1069                   &quot;efile-contents&quot; + &quot;standard error&quot;);
1070             equal(r.out(), &quot;&quot;);
1071             equal(r.err(), &quot;&quot;);
1072             ofile.delete();
1073             efile.delete();
1074         }
1075 
1076         //----------------------------------------------------------------
1077         // Replacing existing files
1078         //----------------------------------------------------------------
1079         {
1080             setFileContents(ofile, &quot;ofile-contents&quot;);
1081             setFileContents(efile, &quot;efile-contents&quot;);
1082             pb.redirectOutput(ofile);
1083             pb.redirectError(Redirect.to(efile));
1084             ProcessResults r = run(pb);
1085             equal(r.exitValue(), 0);
1086             equal(fileContents(ofile), &quot;standard output&quot;);
1087             equal(fileContents(efile), &quot;standard error&quot;);
1088             equal(r.out(), &quot;&quot;);
1089             equal(r.err(), &quot;&quot;);
1090             ofile.delete();
1091             efile.delete();
1092         }
1093 
1094         //----------------------------------------------------------------
1095         // Appending twice to the same file?
1096         //----------------------------------------------------------------
1097         {
1098             setFileContents(ofile, &quot;ofile-contents&quot;);
1099             setFileContents(efile, &quot;efile-contents&quot;);
1100             Redirect appender = Redirect.appendTo(ofile);
1101             pb.redirectOutput(appender);
1102             pb.redirectError(appender);
1103             ProcessResults r = run(pb);
1104             equal(r.exitValue(), 0);
1105             equal(fileContents(ofile),
1106                   &quot;ofile-contents&quot; +
1107                   &quot;standard error&quot; +
1108                   &quot;standard output&quot;);
1109             equal(fileContents(efile), &quot;efile-contents&quot;);
1110             equal(r.out(), &quot;&quot;);
1111             equal(r.err(), &quot;&quot;);
1112             ifile.delete();
1113             ofile.delete();
1114             efile.delete();
1115         }
1116 
1117         //----------------------------------------------------------------
1118         // DISCARDing output
1119         //----------------------------------------------------------------
1120         {
1121             setFileContents(ifile, &quot;standard input&quot;);
1122             pb.redirectOutput(DISCARD);
1123             pb.redirectError(DISCARD);
1124             ProcessResults r = run(pb);
1125             equal(r.exitValue(), 0);
1126             equal(r.out(), &quot;&quot;);
1127             equal(r.err(), &quot;&quot;);
1128         }
1129 
1130         //----------------------------------------------------------------
1131         // DISCARDing output and redirecting error
1132         //----------------------------------------------------------------
1133         {
1134             setFileContents(ifile, &quot;standard input&quot;);
1135             setFileContents(ofile, &quot;ofile-contents&quot;);
1136             setFileContents(efile, &quot;efile-contents&quot;);
1137             pb.redirectOutput(DISCARD);
1138             pb.redirectError(efile);
1139             ProcessResults r = run(pb);
1140             equal(r.exitValue(), 0);
1141             equal(fileContents(ofile), &quot;ofile-contents&quot;);
1142             equal(fileContents(efile), &quot;standard error&quot;);
1143             equal(r.out(), &quot;&quot;);
1144             equal(r.err(), &quot;&quot;);
1145             ofile.delete();
1146             efile.delete();
1147         }
1148 
1149         //----------------------------------------------------------------
1150         // DISCARDing error and redirecting output
1151         //----------------------------------------------------------------
1152         {
1153             setFileContents(ifile, &quot;standard input&quot;);
1154             setFileContents(ofile, &quot;ofile-contents&quot;);
1155             setFileContents(efile, &quot;efile-contents&quot;);
1156             pb.redirectOutput(ofile);
1157             pb.redirectError(DISCARD);
1158             ProcessResults r = run(pb);
1159             equal(r.exitValue(), 0);
1160             equal(fileContents(ofile), &quot;standard output&quot;);
1161             equal(fileContents(efile), &quot;efile-contents&quot;);
1162             equal(r.out(), &quot;&quot;);
1163             equal(r.err(), &quot;&quot;);
1164             ofile.delete();
1165             efile.delete();
1166         }
1167 
1168         //----------------------------------------------------------------
1169         // DISCARDing output and merging error into output
1170         //----------------------------------------------------------------
1171         {
1172             setFileContents(ifile, &quot;standard input&quot;);
1173             setFileContents(ofile, &quot;ofile-contents&quot;);
1174             setFileContents(efile, &quot;efile-contents&quot;);
1175             pb.redirectOutput(DISCARD);
1176             pb.redirectErrorStream(true);
1177             pb.redirectError(efile);
1178             ProcessResults r = run(pb);
1179             equal(r.exitValue(), 0);
1180             equal(fileContents(ofile), &quot;ofile-contents&quot;);   // untouched
1181             equal(fileContents(efile), &quot;&quot;);                 // empty
1182             equal(r.out(), &quot;&quot;);
1183             equal(r.err(), &quot;&quot;);
1184             ifile.delete();
1185             ofile.delete();
1186             efile.delete();
1187             pb.redirectErrorStream(false);                  // reset for next test
1188         }
1189 
1190         //----------------------------------------------------------------
1191         // Testing INHERIT is harder.
1192         // Note that this requires __FOUR__ nested JVMs involved in one test,
1193         // if you count the harness JVM.
1194         //----------------------------------------------------------------
1195         for (String testName : new String[] { &quot;testInheritIO&quot;, &quot;testRedirectInherit&quot; } ) {
1196             redirectIO(pb, PIPE, PIPE, PIPE);
1197             List&lt;String&gt; command = pb.command();
1198             command.set(command.size() - 1, testName);
1199             Process p = pb.start();
1200             new PrintStream(p.getOutputStream()).print(&quot;standard input&quot;);
1201             p.getOutputStream().close();
1202             ProcessResults r = run(p);
1203             equal(r.exitValue(), 0);
1204             equal(r.out(), &quot;standard output&quot;);
1205             equal(r.err(), &quot;standard error&quot;);
1206         }
1207 
1208         //----------------------------------------------------------------
1209         // Test security implications of I/O redirection
1210         //----------------------------------------------------------------
1211 
1212         // Read access to current directory is always granted;
1213         // So create a tmpfile for input instead.
1214         final File tmpFile = File.createTempFile(&quot;Basic&quot;, &quot;tmp&quot;);
1215         setFileContents(tmpFile, &quot;standard input&quot;);
1216 
1217         final Policy policy = new Policy();
1218         Policy.setPolicy(policy);
1219         System.setSecurityManager(new SecurityManager());
1220         try {
1221             final Permission xPermission
1222                 = new FilePermission(&quot;&lt;&lt;ALL FILES&gt;&gt;&quot;, &quot;execute&quot;);
1223             final Permission rxPermission
1224                 = new FilePermission(&quot;&lt;&lt;ALL FILES&gt;&gt;&quot;, &quot;read,execute&quot;);
1225             final Permission wxPermission
1226                 = new FilePermission(&quot;&lt;&lt;ALL FILES&gt;&gt;&quot;, &quot;write,execute&quot;);
1227             final Permission rwxPermission
1228                 = new FilePermission(&quot;&lt;&lt;ALL FILES&gt;&gt;&quot;, &quot;read,write,execute&quot;);
1229 
1230             THROWS(SecurityException.class,
1231                    () -&gt; { policy.setPermissions(xPermission);
1232                            redirectIO(pb, from(tmpFile), PIPE, PIPE);
1233                            pb.start();},
1234                    () -&gt; { policy.setPermissions(rxPermission);
1235                            redirectIO(pb, PIPE, to(ofile), PIPE);
1236                            pb.start();},
1237                    () -&gt; { policy.setPermissions(rxPermission);
1238                            redirectIO(pb, PIPE, PIPE, to(efile));
1239                            pb.start();});
1240 
1241             {
1242                 policy.setPermissions(rxPermission);
1243                 redirectIO(pb, from(tmpFile), PIPE, PIPE);
1244                 ProcessResults r = run(pb);
1245                 equal(r.out(), &quot;standard output&quot;);
1246                 equal(r.err(), &quot;standard error&quot;);
1247             }
1248 
1249             {
1250                 policy.setPermissions(wxPermission);
1251                 redirectIO(pb, PIPE, to(ofile), to(efile));
1252                 Process p = pb.start();
1253                 new PrintStream(p.getOutputStream()).print(&quot;standard input&quot;);
1254                 p.getOutputStream().close();
1255                 ProcessResults r = run(p);
1256                 policy.setPermissions(rwxPermission);
1257                 equal(fileContents(ofile), &quot;standard output&quot;);
1258                 equal(fileContents(efile), &quot;standard error&quot;);
1259             }
1260 
1261             {
1262                 policy.setPermissions(rwxPermission);
1263                 redirectIO(pb, from(tmpFile), to(ofile), to(efile));
1264                 ProcessResults r = run(pb);
1265                 policy.setPermissions(rwxPermission);
1266                 equal(fileContents(ofile), &quot;standard output&quot;);
1267                 equal(fileContents(efile), &quot;standard error&quot;);
1268             }
1269 
1270         } finally {
1271             policy.setPermissions(new RuntimePermission(&quot;setSecurityManager&quot;));
1272             System.setSecurityManager(null);
1273             tmpFile.delete();
1274             ifile.delete();
1275             ofile.delete();
1276             efile.delete();
1277         }
1278     }
1279 
1280     static void checkProcessPid() {
1281         ProcessBuilder pb = new ProcessBuilder();
1282         List&lt;String&gt; list = new ArrayList&lt;String&gt;(javaChildArgs);
1283         list.add(&quot;pid&quot;);
1284         pb.command(list);
1285         try {
1286             Process p = pb.start();
1287             String s = commandOutput(p);
1288             long actualPid = Long.valueOf(s.trim());
1289             long expectedPid = p.pid();
1290             equal(actualPid, expectedPid);
1291         } catch (Throwable t) {
1292             unexpected(t);
1293         }
1294 
1295 
1296         // Test the default implementation of Process.getPid
1297         DelegatingProcess p = new DelegatingProcess(null);
1298         THROWS(UnsupportedOperationException.class,
1299                 () -&gt; p.pid(),
1300                 () -&gt; p.toHandle(),
1301                 () -&gt; p.supportsNormalTermination(),
1302                 () -&gt; p.children(),
1303                 () -&gt; p.descendants());
1304 
1305     }
1306 
1307     private static void realMain(String[] args) throws Throwable {
1308         if (Windows.is())
1309             System.out.println(&quot;This appears to be a Windows system.&quot;);
1310         if (Unix.is())
1311             System.out.println(&quot;This appears to be a Unix system.&quot;);
1312         if (UnicodeOS.is())
1313             System.out.println(&quot;This appears to be a Unicode-based OS.&quot;);
1314 
1315         try { testIORedirection(); }
1316         catch (Throwable t) { unexpected(t); }
1317 
1318         //----------------------------------------------------------------
1319         // Basic tests for getPid()
1320         //----------------------------------------------------------------
1321         checkProcessPid();
1322 
1323         //----------------------------------------------------------------
1324         // Basic tests for setting, replacing and deleting envvars
1325         //----------------------------------------------------------------
1326         try {
1327             ProcessBuilder pb = new ProcessBuilder();
1328             Map&lt;String,String&gt; environ = pb.environment();
1329 
1330             // New env var
1331             environ.put(&quot;QUUX&quot;, &quot;BAR&quot;);
1332             equal(environ.get(&quot;QUUX&quot;), &quot;BAR&quot;);
1333             equal(getenvInChild(pb,&quot;QUUX&quot;), &quot;BAR&quot;);
1334 
1335             // Modify env var
1336             environ.put(&quot;QUUX&quot;,&quot;bear&quot;);
1337             equal(environ.get(&quot;QUUX&quot;), &quot;bear&quot;);
1338             equal(getenvInChild(pb,&quot;QUUX&quot;), &quot;bear&quot;);
1339             checkMapSanity(environ);
1340 
1341             // Remove env var
1342             environ.remove(&quot;QUUX&quot;);
1343             equal(environ.get(&quot;QUUX&quot;), null);
1344             equal(getenvInChild(pb,&quot;QUUX&quot;), &quot;null&quot;);
1345             checkMapSanity(environ);
1346 
1347             // Remove non-existent env var
1348             environ.remove(&quot;QUUX&quot;);
1349             equal(environ.get(&quot;QUUX&quot;), null);
1350             equal(getenvInChild(pb,&quot;QUUX&quot;), &quot;null&quot;);
1351             checkMapSanity(environ);
1352         } catch (Throwable t) { unexpected(t); }
1353 
1354         //----------------------------------------------------------------
1355         // Pass Empty environment to child
1356         //----------------------------------------------------------------
1357         try {
1358             ProcessBuilder pb = new ProcessBuilder();
1359             pb.environment().clear();
1360             String expected = Windows.is() ? &quot;SystemRoot=&quot;+systemRoot+&quot;,&quot;: &quot;&quot;;
1361             expected = AIX.is() ? &quot;LIBPATH=&quot;+libpath+&quot;,&quot;: expected;
1362             if (Windows.is()) {
1363                 pb.environment().put(&quot;SystemRoot&quot;, systemRoot);
1364             }
1365             if (AIX.is()) {
1366                 pb.environment().put(&quot;LIBPATH&quot;, libpath);
1367             }
1368             String result = getenvInChild(pb);
1369             if (MacOSX.is()) {
1370                 result = removeMacExpectedVars(result);
1371             }
1372             if (AIX.is()) {
1373                 result = removeAixExpectedVars(result);
1374             }
1375             equal(result, expected);
1376         } catch (Throwable t) { unexpected(t); }
1377 
1378         //----------------------------------------------------------------
1379         // System.getenv() is read-only.
1380         //----------------------------------------------------------------
1381         THROWS(UnsupportedOperationException.class,
1382                () -&gt; getenv().put(&quot;FOO&quot;,&quot;BAR&quot;),
1383                () -&gt; getenv().remove(&quot;PATH&quot;),
1384                () -&gt; getenv().keySet().remove(&quot;PATH&quot;),
1385                () -&gt; getenv().values().remove(&quot;someValue&quot;));
1386 
1387         try {
1388             Collection&lt;Map.Entry&lt;String,String&gt;&gt; c = getenv().entrySet();
1389             if (! c.isEmpty())
1390                 try {
1391                     c.iterator().next().setValue(&quot;foo&quot;);
1392                     fail(&quot;Expected UnsupportedOperationException not thrown&quot;);
1393                 } catch (UnsupportedOperationException e) {} // OK
1394         } catch (Throwable t) { unexpected(t); }
1395 
1396         //----------------------------------------------------------------
1397         // System.getenv() always returns the same object in our implementation.
1398         //----------------------------------------------------------------
1399         try {
1400             check(System.getenv() == System.getenv());
1401         } catch (Throwable t) { unexpected(t); }
1402 
1403         //----------------------------------------------------------------
1404         // You can&#39;t create an env var name containing &quot;=&quot;,
1405         // or an env var name or value containing NUL.
1406         //----------------------------------------------------------------
1407         {
1408             final Map&lt;String,String&gt; m = new ProcessBuilder().environment();
1409             THROWS(IllegalArgumentException.class,
1410                    () -&gt; m.put(&quot;FOO=&quot;,&quot;BAR&quot;),
1411                    () -&gt; m.put(&quot;FOO\u0000&quot;,&quot;BAR&quot;),
1412                    () -&gt; m.put(&quot;FOO&quot;,&quot;BAR\u0000&quot;));
1413         }
1414 
1415         //----------------------------------------------------------------
1416         // Commands must never be null.
1417         //----------------------------------------------------------------
1418         THROWS(NullPointerException.class,
1419                () -&gt; new ProcessBuilder((List&lt;String&gt;)null),
1420                () -&gt; new ProcessBuilder().command((List&lt;String&gt;)null));
1421 
1422         //----------------------------------------------------------------
1423         // Put in a command; get the same one back out.
1424         //----------------------------------------------------------------
1425         try {
1426             List&lt;String&gt; command = new ArrayList&lt;String&gt;();
1427             ProcessBuilder pb = new ProcessBuilder(command);
1428             check(pb.command() == command);
1429             List&lt;String&gt; command2 = new ArrayList&lt;String&gt;(2);
1430             command2.add(&quot;foo&quot;);
1431             command2.add(&quot;bar&quot;);
1432             pb.command(command2);
1433             check(pb.command() == command2);
1434             pb.command(&quot;foo&quot;, &quot;bar&quot;);
1435             check(pb.command() != command2 &amp;&amp; pb.command().equals(command2));
1436             pb.command(command2);
1437             command2.add(&quot;baz&quot;);
1438             equal(pb.command().get(2), &quot;baz&quot;);
1439         } catch (Throwable t) { unexpected(t); }
1440 
1441         //----------------------------------------------------------------
1442         // Commands must contain at least one element.
1443         //----------------------------------------------------------------
1444         THROWS(IndexOutOfBoundsException.class,
1445                () -&gt; new ProcessBuilder().start(),
1446                () -&gt; new ProcessBuilder(new ArrayList&lt;String&gt;()).start(),
1447                () -&gt; Runtime.getRuntime().exec(new String[]{}));
1448 
1449         //----------------------------------------------------------------
1450         // Commands must not contain null elements at start() time.
1451         //----------------------------------------------------------------
1452         THROWS(NullPointerException.class,
1453                () -&gt; new ProcessBuilder(&quot;foo&quot;,null,&quot;bar&quot;).start(),
1454                () -&gt; new ProcessBuilder((String)null).start(),
1455                () -&gt; new ProcessBuilder(new String[]{null}).start(),
1456                () -&gt; new ProcessBuilder(new String[]{&quot;foo&quot;,null,&quot;bar&quot;}).start());
1457 
1458         //----------------------------------------------------------------
1459         // Command lists are growable.
1460         //----------------------------------------------------------------
1461         try {
1462             new ProcessBuilder().command().add(&quot;foo&quot;);
1463             new ProcessBuilder(&quot;bar&quot;).command().add(&quot;foo&quot;);
1464             new ProcessBuilder(new String[]{&quot;1&quot;,&quot;2&quot;}).command().add(&quot;3&quot;);
1465         } catch (Throwable t) { unexpected(t); }
1466 
1467         //----------------------------------------------------------------
1468         // Nulls in environment updates generate NullPointerException
1469         //----------------------------------------------------------------
1470         try {
1471             final Map&lt;String,String&gt; env = new ProcessBuilder().environment();
1472             THROWS(NullPointerException.class,
1473                    () -&gt; env.put(&quot;foo&quot;,null),
1474                    () -&gt; env.put(null,&quot;foo&quot;),
1475                    () -&gt; env.remove(null),
1476                    () -&gt; { for (Map.Entry&lt;String,String&gt; e : env.entrySet())
1477                                e.setValue(null);},
1478                    () -&gt; Runtime.getRuntime().exec(new String[]{&quot;foo&quot;},
1479                                                    new String[]{null}));
1480         } catch (Throwable t) { unexpected(t); }
1481 
1482         //----------------------------------------------------------------
1483         // Non-String types in environment updates generate ClassCastException
1484         //----------------------------------------------------------------
1485         try {
1486             final Map&lt;String,String&gt; env = new ProcessBuilder().environment();
1487             THROWS(ClassCastException.class,
1488                    () -&gt; env.remove(TRUE),
1489                    () -&gt; env.keySet().remove(TRUE),
1490                    () -&gt; env.values().remove(TRUE),
1491                    () -&gt; env.entrySet().remove(TRUE));
1492         } catch (Throwable t) { unexpected(t); }
1493 
1494         //----------------------------------------------------------------
1495         // Check query operations on environment maps
1496         //----------------------------------------------------------------
1497         try {
1498             List&lt;Map&lt;String,String&gt;&gt; envs =
1499                 new ArrayList&lt;Map&lt;String,String&gt;&gt;(2);
1500             envs.add(System.getenv());
1501             envs.add(new ProcessBuilder().environment());
1502             for (final Map&lt;String,String&gt; env : envs) {
1503                 //----------------------------------------------------------------
1504                 // Nulls in environment queries are forbidden.
1505                 //----------------------------------------------------------------
1506                 THROWS(NullPointerException.class,
1507                        () -&gt; getenv(null),
1508                        () -&gt; env.get(null),
1509                        () -&gt; env.containsKey(null),
1510                        () -&gt; env.containsValue(null),
1511                        () -&gt; env.keySet().contains(null),
1512                        () -&gt; env.values().contains(null));
1513 
1514                 //----------------------------------------------------------------
1515                 // Non-String types in environment queries are forbidden.
1516                 //----------------------------------------------------------------
1517                 THROWS(ClassCastException.class,
1518                        () -&gt; env.get(TRUE),
1519                        () -&gt; env.containsKey(TRUE),
1520                        () -&gt; env.containsValue(TRUE),
1521                        () -&gt; env.keySet().contains(TRUE),
1522                        () -&gt; env.values().contains(TRUE));
1523 
1524                 //----------------------------------------------------------------
1525                 // Illegal String values in environment queries are (grumble) OK
1526                 //----------------------------------------------------------------
1527                 equal(env.get(&quot;\u0000&quot;), null);
1528                 check(! env.containsKey(&quot;\u0000&quot;));
1529                 check(! env.containsValue(&quot;\u0000&quot;));
1530                 check(! env.keySet().contains(&quot;\u0000&quot;));
1531                 check(! env.values().contains(&quot;\u0000&quot;));
1532             }
1533 
1534         } catch (Throwable t) { unexpected(t); }
1535 
1536         try {
1537             final Set&lt;Map.Entry&lt;String,String&gt;&gt; entrySet =
1538                 new ProcessBuilder().environment().entrySet();
1539             THROWS(NullPointerException.class,
1540                    () -&gt; entrySet.contains(null));
1541             THROWS(ClassCastException.class,
1542                    () -&gt; entrySet.contains(TRUE),
1543                    () -&gt; entrySet.contains(
1544                              new SimpleImmutableEntry&lt;Boolean,String&gt;(TRUE,&quot;&quot;)));
1545 
1546             check(! entrySet.contains
1547                   (new SimpleImmutableEntry&lt;String,String&gt;(&quot;&quot;, &quot;&quot;)));
1548         } catch (Throwable t) { unexpected(t); }
1549 
1550         //----------------------------------------------------------------
1551         // Put in a directory; get the same one back out.
1552         //----------------------------------------------------------------
1553         try {
1554             ProcessBuilder pb = new ProcessBuilder();
1555             File foo = new File(&quot;foo&quot;);
1556             equal(pb.directory(), null);
1557             equal(pb.directory(foo).directory(), foo);
1558             equal(pb.directory(null).directory(), null);
1559         } catch (Throwable t) { unexpected(t); }
1560 
1561         //----------------------------------------------------------------
1562         // If round-trip conversion works, check envvar pass-through to child
1563         //----------------------------------------------------------------
1564         try {
1565             testEncoding(&quot;ASCII&quot;,   &quot;xyzzy&quot;);
1566             testEncoding(&quot;Latin1&quot;,  &quot;\u00f1\u00e1&quot;);
1567             testEncoding(&quot;Unicode&quot;, &quot;\u22f1\u11e1&quot;);
1568         } catch (Throwable t) { unexpected(t); }
1569 
1570         //----------------------------------------------------------------
1571         // A surprisingly large number of ways to delete an environment var.
1572         //----------------------------------------------------------------
1573         testVariableDeleter(new EnvironmentFrobber() {
1574                 public void doIt(Map&lt;String,String&gt; environ) {
1575                     environ.remove(&quot;Foo&quot;);}});
1576 
1577         testVariableDeleter(new EnvironmentFrobber() {
1578                 public void doIt(Map&lt;String,String&gt; environ) {
1579                     environ.keySet().remove(&quot;Foo&quot;);}});
1580 
1581         testVariableDeleter(new EnvironmentFrobber() {
1582                 public void doIt(Map&lt;String,String&gt; environ) {
1583                     environ.values().remove(&quot;BAAR&quot;);}});
1584 
1585         testVariableDeleter(new EnvironmentFrobber() {
1586                 public void doIt(Map&lt;String,String&gt; environ) {
1587                     // Legally fabricate a ProcessEnvironment.StringEntry,
1588                     // even though it&#39;s private.
1589                     Map&lt;String,String&gt; environ2
1590                         = new ProcessBuilder().environment();
1591                     environ2.clear();
1592                     environ2.put(&quot;Foo&quot;,&quot;BAAR&quot;);
1593                     // Subtlety alert.
1594                     Map.Entry&lt;String,String&gt; e
1595                         = environ2.entrySet().iterator().next();
1596                     environ.entrySet().remove(e);}});
1597 
1598         testVariableDeleter(new EnvironmentFrobber() {
1599                 public void doIt(Map&lt;String,String&gt; environ) {
1600                     Map.Entry&lt;String,String&gt; victim = null;
1601                     for (Map.Entry&lt;String,String&gt; e : environ.entrySet())
1602                         if (e.getKey().equals(&quot;Foo&quot;))
1603                             victim = e;
1604                     if (victim != null)
1605                         environ.entrySet().remove(victim);}});
1606 
1607         testVariableDeleter(new EnvironmentFrobber() {
1608                 public void doIt(Map&lt;String,String&gt; environ) {
1609                     Iterator&lt;String&gt; it = environ.keySet().iterator();
1610                     while (it.hasNext()) {
1611                         String val = it.next();
1612                         if (val.equals(&quot;Foo&quot;))
1613                             it.remove();}}});
1614 
1615         testVariableDeleter(new EnvironmentFrobber() {
1616                 public void doIt(Map&lt;String,String&gt; environ) {
1617                     Iterator&lt;Map.Entry&lt;String,String&gt;&gt; it
1618                         = environ.entrySet().iterator();
1619                     while (it.hasNext()) {
1620                         Map.Entry&lt;String,String&gt; e = it.next();
1621                         if (e.getKey().equals(&quot;Foo&quot;))
1622                             it.remove();}}});
1623 
1624         testVariableDeleter(new EnvironmentFrobber() {
1625                 public void doIt(Map&lt;String,String&gt; environ) {
1626                     Iterator&lt;String&gt; it = environ.values().iterator();
1627                     while (it.hasNext()) {
1628                         String val = it.next();
1629                         if (val.equals(&quot;BAAR&quot;))
1630                             it.remove();}}});
1631 
1632         //----------------------------------------------------------------
1633         // A surprisingly small number of ways to add an environment var.
1634         //----------------------------------------------------------------
1635         testVariableAdder(new EnvironmentFrobber() {
1636                 public void doIt(Map&lt;String,String&gt; environ) {
1637                     environ.put(&quot;Foo&quot;,&quot;Bahrein&quot;);}});
1638 
1639         //----------------------------------------------------------------
1640         // A few ways to modify an environment var.
1641         //----------------------------------------------------------------
1642         testVariableModifier(new EnvironmentFrobber() {
1643                 public void doIt(Map&lt;String,String&gt; environ) {
1644                     environ.put(&quot;Foo&quot;,&quot;NewValue&quot;);}});
1645 
1646         testVariableModifier(new EnvironmentFrobber() {
1647                 public void doIt(Map&lt;String,String&gt; environ) {
1648                     for (Map.Entry&lt;String,String&gt; e : environ.entrySet())
1649                         if (e.getKey().equals(&quot;Foo&quot;))
1650                             e.setValue(&quot;NewValue&quot;);}});
1651 
1652         //----------------------------------------------------------------
1653         // Fiddle with environment sizes
1654         //----------------------------------------------------------------
1655         try {
1656             Map&lt;String,String&gt; environ = new ProcessBuilder().environment();
1657             int size = environ.size();
1658             checkSizes(environ, size);
1659 
1660             environ.put(&quot;UnLiKeLYeNVIROmtNam&quot;, &quot;someVal&quot;);
1661             checkSizes(environ, size+1);
1662 
1663             // Check for environment independence
1664             new ProcessBuilder().environment().clear();
1665 
1666             environ.put(&quot;UnLiKeLYeNVIROmtNam&quot;, &quot;someOtherVal&quot;);
1667             checkSizes(environ, size+1);
1668 
1669             environ.remove(&quot;UnLiKeLYeNVIROmtNam&quot;);
1670             checkSizes(environ, size);
1671 
1672             environ.clear();
1673             checkSizes(environ, 0);
1674 
1675             environ.clear();
1676             checkSizes(environ, 0);
1677 
1678             environ = new ProcessBuilder().environment();
1679             environ.keySet().clear();
1680             checkSizes(environ, 0);
1681 
1682             environ = new ProcessBuilder().environment();
1683             environ.entrySet().clear();
1684             checkSizes(environ, 0);
1685 
1686             environ = new ProcessBuilder().environment();
1687             environ.values().clear();
1688             checkSizes(environ, 0);
1689         } catch (Throwable t) { unexpected(t); }
1690 
1691         //----------------------------------------------------------------
1692         // Check that various map invariants hold
1693         //----------------------------------------------------------------
1694         checkMapSanity(new ProcessBuilder().environment());
1695         checkMapSanity(System.getenv());
1696         checkMapEquality(new ProcessBuilder().environment(),
1697                          new ProcessBuilder().environment());
1698 
1699 
1700         //----------------------------------------------------------------
1701         // Check effects on external &quot;env&quot; command.
1702         //----------------------------------------------------------------
1703         try {
1704             Set&lt;String&gt; env1 = new HashSet&lt;String&gt;
1705                 (Arrays.asList(nativeEnv((String[])null).split(&quot;\n&quot;)));
1706 
1707             ProcessBuilder pb = new ProcessBuilder();
1708             pb.environment().put(&quot;QwErTyUiOp&quot;,&quot;AsDfGhJk&quot;);
1709 
1710             Set&lt;String&gt; env2 = new HashSet&lt;String&gt;
1711                 (Arrays.asList(nativeEnv(pb).split(&quot;\n&quot;)));
1712 
1713             check(env2.size() == env1.size() + 1);
1714             env1.add(&quot;QwErTyUiOp=AsDfGhJk&quot;);
1715             check(env1.equals(env2));
1716         } catch (Throwable t) { unexpected(t); }
1717 
1718         //----------------------------------------------------------------
1719         // Test Runtime.exec(...envp...)
1720         // Check for sort order of environment variables on Windows.
1721         //----------------------------------------------------------------
1722         try {
1723             String systemRoot = &quot;SystemRoot=&quot; + System.getenv(&quot;SystemRoot&quot;);
1724             // &#39;+&#39; &lt; &#39;A&#39; &lt; &#39;Z&#39; &lt; &#39;_&#39; &lt; &#39;a&#39; &lt; &#39;z&#39; &lt; &#39;~&#39;
1725             String[]envp = {&quot;FOO=BAR&quot;,&quot;BAZ=GORP&quot;,&quot;QUUX=&quot;,
1726                             &quot;+=+&quot;, &quot;_=_&quot;, &quot;~=~&quot;, systemRoot};
1727             String output = nativeEnv(envp);
1728             String expected = &quot;+=+\nBAZ=GORP\nFOO=BAR\nQUUX=\n&quot;+systemRoot+&quot;\n_=_\n~=~\n&quot;;
1729             // On Windows, Java must keep the environment sorted.
1730             // Order is random on Unix, so this test does the sort.
1731             if (! Windows.is())
1732                 output = sortByLinesWindowsly(output);
1733             equal(output, expected);
1734         } catch (Throwable t) { unexpected(t); }
1735 
1736         //----------------------------------------------------------------
1737         // Test Runtime.exec(...envp...)
1738         // and check SystemRoot gets set automatically on Windows
1739         //----------------------------------------------------------------
1740         try {
1741             if (Windows.is()) {
1742                 String systemRoot = &quot;SystemRoot=&quot; + System.getenv(&quot;SystemRoot&quot;);
1743                 String[]envp = {&quot;FOO=BAR&quot;,&quot;BAZ=GORP&quot;,&quot;QUUX=&quot;,
1744                                 &quot;+=+&quot;, &quot;_=_&quot;, &quot;~=~&quot;};
1745                 String output = nativeEnv(envp);
1746                 String expected = &quot;+=+\nBAZ=GORP\nFOO=BAR\nQUUX=\n&quot;+systemRoot+&quot;\n_=_\n~=~\n&quot;;
1747                 equal(output, expected);
1748             }
1749         } catch (Throwable t) { unexpected(t); }
1750 
1751         //----------------------------------------------------------------
1752         // System.getenv() must be consistent with System.getenv(String)
1753         //----------------------------------------------------------------
1754         try {
1755             for (Map.Entry&lt;String,String&gt; e : getenv().entrySet())
1756                 equal(getenv(e.getKey()), e.getValue());
1757         } catch (Throwable t) { unexpected(t); }
1758 
1759         //----------------------------------------------------------------
1760         // Fiddle with working directory in child
1761         //----------------------------------------------------------------
1762         try {
1763             String canonicalUserDir =
1764                 new File(System.getProperty(&quot;user.dir&quot;)).getCanonicalPath();
1765             String[] sdirs = new String[]
1766                 {&quot;.&quot;, &quot;..&quot;, &quot;/&quot;, &quot;/bin&quot;,
1767                  &quot;C:&quot;, &quot;c:&quot;, &quot;C:/&quot;, &quot;c:\\&quot;, &quot;\\&quot;, &quot;\\bin&quot;,
1768                  &quot;c:\\windows  &quot;, &quot;c:\\Program Files&quot;, &quot;c:\\Program Files\\&quot; };
1769             for (String sdir : sdirs) {
1770                 File dir = new File(sdir);
1771                 if (! (dir.isDirectory() &amp;&amp; dir.exists()))
1772                     continue;
1773                 out.println(&quot;Testing directory &quot; + dir);
1774                 //dir = new File(dir.getCanonicalPath());
1775 
1776                 ProcessBuilder pb = new ProcessBuilder();
1777                 equal(pb.directory(), null);
1778                 equal(pwdInChild(pb), canonicalUserDir);
1779 
1780                 pb.directory(dir);
1781                 equal(pb.directory(), dir);
1782                 equal(pwdInChild(pb), dir.getCanonicalPath());
1783 
1784                 pb.directory(null);
1785                 equal(pb.directory(), null);
1786                 equal(pwdInChild(pb), canonicalUserDir);
1787 
1788                 pb.directory(dir);
1789             }
1790         } catch (Throwable t) { unexpected(t); }
1791 
1792         //----------------------------------------------------------------
1793         // Working directory with Unicode in child
1794         //----------------------------------------------------------------
1795         try {
1796             if (UnicodeOS.is()) {
1797                 File dir = new File(System.getProperty(&quot;test.dir&quot;, &quot;.&quot;),
1798                                     &quot;ProcessBuilderDir\u4e00\u4e02&quot;);
1799                 try {
1800                     if (!dir.exists())
1801                         dir.mkdir();
1802                     out.println(&quot;Testing Unicode directory:&quot; + dir);
1803                     ProcessBuilder pb = new ProcessBuilder();
1804                     pb.directory(dir);
1805                     equal(pwdInChild(pb), dir.getCanonicalPath());
1806                 } finally {
1807                     if (dir.exists())
1808                         dir.delete();
1809                 }
1810             }
1811         } catch (Throwable t) { unexpected(t); }
1812 
1813         //----------------------------------------------------------------
1814         // OOME in child allocating maximally sized array
1815         // Test for hotspot/jvmti bug 6850957
1816         //----------------------------------------------------------------
1817         try {
1818             List&lt;String&gt; list = new ArrayList&lt;String&gt;(javaChildArgs);
1819             list.add(1, String.format(&quot;-XX:OnOutOfMemoryError=%s -version&quot;,
1820                                       javaExe));
1821             list.add(&quot;ArrayOOME&quot;);
1822             ProcessResults r = run(new ProcessBuilder(list));
1823             check(r.err().contains(&quot;java.lang.OutOfMemoryError:&quot;));
1824             check(r.err().contains(javaExe));
1825             check(r.err().contains(System.getProperty(&quot;java.version&quot;)));
1826             equal(r.exitValue(), 1);
1827         } catch (Throwable t) { unexpected(t); }
1828 
1829         //----------------------------------------------------------------
1830         // Windows has tricky semi-case-insensitive semantics
1831         //----------------------------------------------------------------
1832         if (Windows.is())
1833             try {
1834                 out.println(&quot;Running case insensitve variable tests&quot;);
1835                 for (String[] namePair :
1836                          new String[][]
1837                     { new String[]{&quot;PATH&quot;,&quot;PaTh&quot;},
1838                       new String[]{&quot;home&quot;,&quot;HOME&quot;},
1839                       new String[]{&quot;SYSTEMROOT&quot;,&quot;SystemRoot&quot;}}) {
1840                     check((getenv(namePair[0]) == null &amp;&amp;
1841                            getenv(namePair[1]) == null)
1842                           ||
1843                           getenv(namePair[0]).equals(getenv(namePair[1])),
1844                           &quot;Windows environment variables are not case insensitive&quot;);
1845                 }
1846             } catch (Throwable t) { unexpected(t); }
1847 
1848         //----------------------------------------------------------------
1849         // Test proper Unicode child environment transfer
1850         //----------------------------------------------------------------
1851         if (UnicodeOS.is())
1852             try {
1853                 ProcessBuilder pb = new ProcessBuilder();
1854                 pb.environment().put(&quot;\u1234&quot;,&quot;\u5678&quot;);
1855                 pb.environment().remove(&quot;PATH&quot;);
1856                 equal(getenvInChild1234(pb), &quot;\u5678&quot;);
1857             } catch (Throwable t) { unexpected(t); }
1858 
1859 
1860         //----------------------------------------------------------------
1861         // Test Runtime.exec(...envp...) with envstrings with initial `=&#39;
1862         //----------------------------------------------------------------
1863         try {
1864             List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
1865             childArgs.add(&quot;System.getenv()&quot;);
1866             String[] cmdp = childArgs.toArray(new String[childArgs.size()]);
1867             String[] envp;
1868             String[] envpWin = {&quot;=C:=\\&quot;, &quot;=ExitValue=3&quot;, &quot;SystemRoot=&quot;+systemRoot};
1869             String[] envpOth = {&quot;=ExitValue=3&quot;, &quot;=C:=\\&quot;};
1870             if (Windows.is()) {
1871                 envp = envpWin;
1872             } else {
1873                 envp = envpOth;
1874             }
1875             Process p = Runtime.getRuntime().exec(cmdp, envp);
1876             String expected = Windows.is() ? &quot;=C:=\\,=ExitValue=3,SystemRoot=&quot;+systemRoot+&quot;,&quot; : &quot;=C:=\\,&quot;;
1877             expected = AIX.is() ? expected + &quot;LIBPATH=&quot;+libpath+&quot;,&quot;: expected;
1878             String commandOutput = commandOutput(p);
1879             if (MacOSX.is()) {
1880                 commandOutput = removeMacExpectedVars(commandOutput);
1881             }
1882             if (AIX.is()) {
1883                 commandOutput = removeAixExpectedVars(commandOutput);
1884             }
1885             equal(commandOutput, expected);
1886             if (Windows.is()) {
1887                 ProcessBuilder pb = new ProcessBuilder(childArgs);
1888                 pb.environment().clear();
1889                 pb.environment().put(&quot;SystemRoot&quot;, systemRoot);
1890                 pb.environment().put(&quot;=ExitValue&quot;, &quot;3&quot;);
1891                 pb.environment().put(&quot;=C:&quot;, &quot;\\&quot;);
1892                 equal(commandOutput(pb), expected);
1893             }
1894         } catch (Throwable t) { unexpected(t); }
1895 
1896         //----------------------------------------------------------------
1897         // Test Runtime.exec(...envp...) with envstrings without any `=&#39;
1898         //----------------------------------------------------------------
1899         try {
1900             String[] cmdp = {&quot;echo&quot;};
1901             String[] envp = {&quot;Hello&quot;, &quot;World&quot;}; // Yuck!
1902             Process p = Runtime.getRuntime().exec(cmdp, envp);
1903             equal(commandOutput(p), &quot;\n&quot;);
1904         } catch (Throwable t) { unexpected(t); }
1905 
1906         //----------------------------------------------------------------
1907         // Test Runtime.exec(...envp...) with envstrings containing NULs
1908         //----------------------------------------------------------------
1909         try {
1910             List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
1911             childArgs.add(&quot;System.getenv()&quot;);
1912             String[] cmdp = childArgs.toArray(new String[childArgs.size()]);
1913             String[] envpWin = {&quot;SystemRoot=&quot;+systemRoot, &quot;LC_ALL=C\u0000\u0000&quot;, // Yuck!
1914                              &quot;FO\u0000=B\u0000R&quot;};
1915             String[] envpOth = {&quot;LC_ALL=C\u0000\u0000&quot;, // Yuck!
1916                              &quot;FO\u0000=B\u0000R&quot;};
1917             String[] envp;
1918             if (Windows.is()) {
1919                 envp = envpWin;
1920             } else {
1921                 envp = envpOth;
1922             }
1923             System.out.println (&quot;cmdp&quot;);
1924             for (int i=0; i&lt;cmdp.length; i++) {
1925                 System.out.printf (&quot;cmdp %d: %s\n&quot;, i, cmdp[i]);
1926             }
1927             System.out.println (&quot;envp&quot;);
1928             for (int i=0; i&lt;envp.length; i++) {
1929                 System.out.printf (&quot;envp %d: %s\n&quot;, i, envp[i]);
1930             }
1931             Process p = Runtime.getRuntime().exec(cmdp, envp);
1932             String commandOutput = commandOutput(p);
1933             if (MacOSX.is()) {
1934                 commandOutput = removeMacExpectedVars(commandOutput);
1935             }
1936             if (AIX.is()) {
1937                 commandOutput = removeAixExpectedVars(commandOutput);
1938             }
1939             check(commandOutput.equals(Windows.is()
1940                     ? &quot;LC_ALL=C,SystemRoot=&quot;+systemRoot+&quot;,&quot;
1941                     : AIX.is()
1942                             ? &quot;LC_ALL=C,LIBPATH=&quot;+libpath+&quot;,&quot;
1943                             : &quot;LC_ALL=C,&quot;),
1944                   &quot;Incorrect handling of envstrings containing NULs&quot;);
1945         } catch (Throwable t) { unexpected(t); }
1946 
1947         //----------------------------------------------------------------
1948         // Test the redirectErrorStream property
1949         //----------------------------------------------------------------
1950         try {
1951             ProcessBuilder pb = new ProcessBuilder();
1952             equal(pb.redirectErrorStream(), false);
1953             equal(pb.redirectErrorStream(true), pb);
1954             equal(pb.redirectErrorStream(), true);
1955             equal(pb.redirectErrorStream(false), pb);
1956             equal(pb.redirectErrorStream(), false);
1957         } catch (Throwable t) { unexpected(t); }
1958 
1959         try {
1960             List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
1961             childArgs.add(&quot;OutErr&quot;);
1962             ProcessBuilder pb = new ProcessBuilder(childArgs);
1963             {
1964                 ProcessResults r = run(pb);
1965                 equal(r.out(), &quot;outout&quot;);
1966                 equal(r.err(), &quot;errerr&quot;);
1967             }
1968             {
1969                 pb.redirectErrorStream(true);
1970                 ProcessResults r = run(pb);
1971                 equal(r.out(), &quot;outerrouterr&quot;);
1972                 equal(r.err(), &quot;&quot;);
1973             }
1974         } catch (Throwable t) { unexpected(t); }
1975 
1976         if (Unix.is()) {
1977             //----------------------------------------------------------------
1978             // We can find true and false when PATH is null
1979             //----------------------------------------------------------------
1980             try {
1981                 List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
1982                 childArgs.add(&quot;null PATH&quot;);
1983                 ProcessBuilder pb = new ProcessBuilder(childArgs);
1984                 pb.environment().remove(&quot;PATH&quot;);
1985                 ProcessResults r = run(pb);
1986                 equal(r.out(), &quot;&quot;);
1987                 equal(r.err(), &quot;&quot;);
1988                 equal(r.exitValue(), 0);
1989             } catch (Throwable t) { unexpected(t); }
1990 
1991             //----------------------------------------------------------------
1992             // PATH search algorithm on Unix
1993             //----------------------------------------------------------------
1994             try {
1995                 List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
1996                 childArgs.add(&quot;PATH search algorithm&quot;);
1997                 ProcessBuilder pb = new ProcessBuilder(childArgs);
1998                 pb.environment().put(&quot;PATH&quot;, &quot;dir1:dir2:&quot;);
1999                 ProcessResults r = run(pb);
2000                 equal(r.out(), &quot;&quot;);
2001                 equal(r.err(), &quot;&quot;);
2002                 equal(r.exitValue(), True.exitValue());
2003             } catch (Throwable t) { unexpected(t); }
2004 
2005             //----------------------------------------------------------------
2006             // Parent&#39;s, not child&#39;s PATH is used
2007             //----------------------------------------------------------------
2008             try {
2009                 new File(&quot;suBdiR&quot;).mkdirs();
<a name="10" id="anc10"></a><span class="line-modified">2010                 copy(TrueExe.path(), &quot;suBdiR/unliKely&quot;);</span>
2011                 final ProcessBuilder pb =
2012                     new ProcessBuilder(new String[]{&quot;unliKely&quot;});
2013                 pb.environment().put(&quot;PATH&quot;, &quot;suBdiR&quot;);
2014                 THROWS(IOException.class, () -&gt; pb.start());
2015             } catch (Throwable t) { unexpected(t);
2016             } finally {
2017                 new File(&quot;suBdiR/unliKely&quot;).delete();
2018                 new File(&quot;suBdiR&quot;).delete();
2019             }
2020         }
2021 
2022         //----------------------------------------------------------------
2023         // Attempt to start bogus program &quot;&quot;
2024         //----------------------------------------------------------------
2025         try {
2026             new ProcessBuilder(&quot;&quot;).start();
2027             fail(&quot;Expected IOException not thrown&quot;);
2028         } catch (IOException e) {
2029             String m = e.getMessage();
2030             if (EnglishUnix.is() &amp;&amp;
2031                 ! matches(m, &quot;No such file or directory&quot;))
2032                 unexpected(e);
2033         } catch (Throwable t) { unexpected(t); }
2034 
2035         //----------------------------------------------------------------
2036         // Check that attempt to execute program name with funny
2037         // characters throws an exception containing those characters.
2038         //----------------------------------------------------------------
2039         for (String programName : new String[] {&quot;\u00f0&quot;, &quot;\u01f0&quot;})
2040             try {
2041                 new ProcessBuilder(programName).start();
2042                 fail(&quot;Expected IOException not thrown&quot;);
2043             } catch (IOException e) {
2044                 String m = e.getMessage();
2045                 Pattern p = Pattern.compile(programName);
2046                 if (! matches(m, programName)
2047                     || (EnglishUnix.is()
2048                         &amp;&amp; ! matches(m, &quot;No such file or directory&quot;)))
2049                     unexpected(e);
2050             } catch (Throwable t) { unexpected(t); }
2051 
2052         //----------------------------------------------------------------
2053         // Attempt to start process in nonexistent directory fails.
2054         //----------------------------------------------------------------
2055         try {
2056             new ProcessBuilder(&quot;echo&quot;)
2057                 .directory(new File(&quot;UnLiKeLY&quot;))
2058                 .start();
2059             fail(&quot;Expected IOException not thrown&quot;);
2060         } catch (IOException e) {
2061             String m = e.getMessage();
2062             if (! matches(m, &quot;in directory&quot;)
2063                 || (EnglishUnix.is() &amp;&amp;
2064                     ! matches(m, &quot;No such file or directory&quot;)))
2065                 unexpected(e);
2066         } catch (Throwable t) { unexpected(t); }
2067 
2068         //----------------------------------------------------------------
2069         // Attempt to write 4095 bytes to the pipe buffer without a
2070         // reader to drain it would deadlock, if not for the fact that
2071         // interprocess pipe buffers are at least 4096 bytes.
2072         //
2073         // Also, check that available reports all the bytes expected
2074         // in the pipe buffer, and that I/O operations do the expected
2075         // things.
2076         //----------------------------------------------------------------
2077         try {
2078             List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
2079             childArgs.add(&quot;print4095&quot;);
2080             final int SIZE = 4095;
2081             final Process p = new ProcessBuilder(childArgs).start();
2082             print4095(p.getOutputStream(), (byte) &#39;!&#39;); // Might hang!
2083             p.waitFor();                                // Might hang!
2084             equal(SIZE, p.getInputStream().available());
2085             equal(SIZE, p.getErrorStream().available());
2086             THROWS(IOException.class,
2087                    () -&gt; { p.getOutputStream().write((byte) &#39;!&#39;);
2088                            p.getOutputStream().flush();});
2089 
2090             final byte[] bytes = new byte[SIZE + 1];
2091             equal(SIZE, p.getInputStream().read(bytes));
2092             for (int i = 0; i &lt; SIZE; i++)
2093                 equal((byte) &#39;!&#39;, bytes[i]);
2094             equal((byte) 0, bytes[SIZE]);
2095 
2096             equal(SIZE, p.getErrorStream().read(bytes));
2097             for (int i = 0; i &lt; SIZE; i++)
2098                 equal((byte) &#39;E&#39;, bytes[i]);
2099             equal((byte) 0, bytes[SIZE]);
2100 
2101             equal(0, p.getInputStream().available());
2102             equal(0, p.getErrorStream().available());
2103             equal(-1, p.getErrorStream().read());
2104             equal(-1, p.getInputStream().read());
2105 
2106             equal(p.exitValue(), 5);
2107 
2108             p.getInputStream().close();
2109             p.getErrorStream().close();
2110             try { p.getOutputStream().close(); } catch (IOException flushFailed) { }
2111 
2112             InputStream[] streams = { p.getInputStream(), p.getErrorStream() };
2113             for (final InputStream in : streams) {
2114                 Fun[] ops = {
2115                     () -&gt; in.read(),
2116                     () -&gt; in.read(bytes),
2117                     () -&gt; in.available()
2118                 };
2119                 for (Fun op : ops) {
2120                     try {
2121                         op.f();
2122                         fail();
2123                     } catch (IOException expected) {
2124                         check(expected.getMessage()
2125                               .matches(&quot;[Ss]tream [Cc]losed&quot;));
2126                     }
2127                 }
2128             }
2129         } catch (Throwable t) { unexpected(t); }
2130 
2131         //----------------------------------------------------------------
2132         // Check that reads which are pending when Process.destroy is
2133         // called, get EOF, or IOException(&quot;Stream closed&quot;).
2134         //----------------------------------------------------------------
2135         try {
2136             final int cases = 4;
2137             for (int i = 0; i &lt; cases; i++) {
2138                 final int action = i;
2139                 List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
2140                 childArgs.add(&quot;sleep&quot;);
2141                 final byte[] bytes = new byte[10];
2142                 final Process p = new ProcessBuilder(childArgs).start();
2143                 final CountDownLatch latch = new CountDownLatch(1);
2144                 final InputStream s;
2145                 switch (action &amp; 0x1) {
2146                     case 0: s = p.getInputStream(); break;
2147                     case 1: s = p.getErrorStream(); break;
2148                     default: throw new Error();
2149                 }
2150                 final Thread thread = new Thread() {
2151                     public void run() {
2152                         try {
2153                             int r;
2154                             latch.countDown();
2155                             switch (action &amp; 0x2) {
2156                                 case 0: r = s.read(); break;
2157                                 case 2: r = s.read(bytes); break;
2158                                 default: throw new Error();
2159                             }
2160                             if (r &gt;= 0) {
2161                                 // The child sent unexpected output; print it to diagnose
2162                                 System.out.println(&quot;Unexpected child output:&quot;);
2163                                 if ((action &amp; 0x2) == 0) {
2164                                     System.out.write(r);    // Single character
2165 
2166                                 } else {
2167                                     System.out.write(bytes, 0, r);
2168                                 }
2169                                 for (int c = s.read(); c &gt;= 0; c = s.read())
2170                                     System.out.write(c);
2171                                 System.out.println(&quot;\nEND Child output.&quot;);
2172                             }
2173                             equal(-1, r);
2174                         } catch (IOException ioe) {
2175                             if (!ioe.getMessage().equals(&quot;Stream closed&quot;)) {
2176                                 // BufferedInputStream may throw IOE(&quot;Stream closed&quot;).
2177                                 unexpected(ioe);
2178                             }
2179                         } catch (Throwable t) { unexpected(t); }}};
2180 
2181                 thread.start();
2182                 latch.await();
2183                 Thread.sleep(10);
2184 
2185                 String os = System.getProperty(&quot;os.name&quot;);
2186                 if (os.equalsIgnoreCase(&quot;Solaris&quot;) ||
2187                     os.equalsIgnoreCase(&quot;SunOS&quot;))
2188                 {
2189                     final Object deferred;
2190                     Class&lt;?&gt; c = s.getClass();
2191                     if (c.getName().equals(
2192                         &quot;java.lang.ProcessImpl$DeferredCloseInputStream&quot;))
2193                     {
2194                         deferred = s;
2195                     } else {
2196                         Field deferredField = p.getClass().
2197                             getDeclaredField(&quot;stdout_inner_stream&quot;);
2198                         deferredField.setAccessible(true);
2199                         deferred = deferredField.get(p);
2200                     }
2201                     Field useCountField = deferred.getClass().
2202                         getDeclaredField(&quot;useCount&quot;);
2203                     useCountField.setAccessible(true);
2204 
2205                     while (useCountField.getInt(deferred) &lt;= 0) {
2206                         Thread.yield();
2207                     }
2208                 } else if (s instanceof BufferedInputStream) {
2209                     // Wait until after the s.read occurs in &quot;thread&quot; by
2210                     // checking when the input stream monitor is acquired
2211                     // (BufferedInputStream.read is synchronized)
2212                     while (!isLocked(s, 10)) {
2213                         Thread.sleep(100);
2214                     }
2215                 }
2216                 p.destroy();
2217                 thread.join();
2218             }
2219         } catch (Throwable t) { unexpected(t); }
2220 
2221         //----------------------------------------------------------------
2222         // Check that subprocesses which create subprocesses of their
2223         // own do not cause parent to hang waiting for file
2224         // descriptors to be closed.
2225         //----------------------------------------------------------------
2226         try {
2227             if (Unix.is()
2228                 &amp;&amp; new File(&quot;/bin/bash&quot;).exists()
2229                 &amp;&amp; new File(&quot;/bin/sleep&quot;).exists()) {
2230                 // Notice that we only destroy the process created by us (i.e.
2231                 // our child) but not our grandchild (i.e. &#39;/bin/sleep&#39;). So
2232                 // pay attention that the grandchild doesn&#39;t run too long to
2233                 // avoid polluting the process space with useless processes.
2234                 // Running the grandchild for 60s should be more than enough.
2235                 final String[] cmd = { &quot;/bin/bash&quot;, &quot;-c&quot;, &quot;(/bin/sleep 60)&quot; };
2236                 final String[] cmdkill = { &quot;/bin/bash&quot;, &quot;-c&quot;, &quot;(/usr/bin/pkill -f \&quot;sleep 60\&quot;)&quot; };
2237                 final ProcessBuilder pb = new ProcessBuilder(cmd);
2238                 final Process p = pb.start();
2239                 final InputStream stdout = p.getInputStream();
2240                 final InputStream stderr = p.getErrorStream();
2241                 final OutputStream stdin = p.getOutputStream();
2242                 final Thread reader = new Thread() {
2243                     public void run() {
2244                         try { stdout.read(); }
2245                         catch (IOException e) {
2246                             // Check that reader failed because stream was
2247                             // asynchronously closed.
2248                             // e.printStackTrace();
2249                             String msg = e.getMessage();
2250                             if (EnglishUnix.is() &amp;&amp;
2251                                 ! (msg.matches(&quot;.*Bad file.*&quot;) ||
2252                                         msg.matches(&quot;.*Stream closed.*&quot;)))
2253                                 unexpected(e);
2254                         }
2255                         catch (Throwable t) { unexpected(t); }}};
2256                 reader.setDaemon(true);
2257                 reader.start();
2258                 Thread.sleep(100);
2259                 p.destroy();
2260                 check(p.waitFor() != 0);
2261                 check(p.exitValue() != 0);
2262                 // Subprocess is now dead, but file descriptors remain open.
2263                 // Make sure the test will fail if we don&#39;t manage to close
2264                 // the open streams within 30 seconds. Notice that this time
2265                 // must be shorter than the sleep time of the grandchild.
2266                 Timer t = new Timer(&quot;test/java/lang/ProcessBuilder/Basic.java process reaper&quot;, true);
2267                 t.schedule(new TimerTask() {
2268                       public void run() {
2269                           fail(&quot;Subprocesses which create subprocesses of &quot; +
2270                                &quot;their own caused the parent to hang while &quot; +
2271                                &quot;waiting for file descriptors to be closed.&quot;);
2272                           System.exit(-1);
2273                       }
2274                   }, 30000);
2275                 stdout.close();
2276                 stderr.close();
2277                 stdin.close();
2278                 new ProcessBuilder(cmdkill).start();
2279                 // All streams successfully closed so we can cancel the timer.
2280                 t.cancel();
2281                 //----------------------------------------------------------
2282                 // There remain unsolved issues with asynchronous close.
2283                 // Here&#39;s a highly non-portable experiment to demonstrate:
2284                 //----------------------------------------------------------
2285                 if (Boolean.getBoolean(&quot;wakeupJeff!&quot;)) {
2286                     System.out.println(&quot;wakeupJeff!&quot;);
2287                     // Initialize signal handler for INTERRUPT_SIGNAL.
2288                     new FileInputStream(&quot;/bin/sleep&quot;).getChannel().close();
2289                     // Send INTERRUPT_SIGNAL to every thread in this java.
2290                     String[] wakeupJeff = {
2291                         &quot;/bin/bash&quot;, &quot;-c&quot;,
2292                         &quot;/bin/ps --noheaders -Lfp $PPID | &quot; +
2293                         &quot;/usr/bin/perl -nale &#39;print $F[3]&#39; | &quot; +
2294                         // INTERRUPT_SIGNAL == 62 on my machine du jour.
2295                         &quot;/usr/bin/xargs kill -62&quot;
2296                     };
2297                     new ProcessBuilder(wakeupJeff).start().waitFor();
2298                     // If wakeupJeff worked, reader probably got EBADF.
2299                     reader.join();
2300                 }
2301             }
2302 
2303             //----------------------------------------------------------------
2304             // Check the Process toString() method
2305             //----------------------------------------------------------------
2306             {
2307                 List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
2308                 childArgs.add(&quot;testIO&quot;);
2309                 ProcessBuilder pb = new ProcessBuilder(childArgs);
2310                 pb.redirectInput(Redirect.PIPE);
2311                 pb.redirectOutput(DISCARD);
2312                 pb.redirectError(DISCARD);
2313                 final Process p = pb.start();
2314                 // Child process waits until it gets input
2315                 String s = p.toString();
2316                 check(s.contains(&quot;not exited&quot;));
2317                 check(s.contains(&quot;pid=&quot; + p.pid() + &quot;,&quot;));
2318 
2319                 new PrintStream(p.getOutputStream()).print(&quot;standard input&quot;);
2320                 p.getOutputStream().close();
2321 
2322                 // Check the toString after it exits
2323                 int exitValue = p.waitFor();
2324                 s = p.toString();
2325                 check(s.contains(&quot;pid=&quot; + p.pid() + &quot;,&quot;));
2326                 check(s.contains(&quot;exitValue=&quot; + exitValue) &amp;&amp;
2327                         !s.contains(&quot;not exited&quot;));
2328             }
2329         } catch (Throwable t) { unexpected(t); }
2330 
2331         //----------------------------------------------------------------
2332         // Attempt to start process with insufficient permissions fails.
2333         //----------------------------------------------------------------
2334         try {
2335             new File(&quot;emptyCommand&quot;).delete();
2336             new FileOutputStream(&quot;emptyCommand&quot;).close();
2337             new File(&quot;emptyCommand&quot;).setExecutable(false);
2338             new ProcessBuilder(&quot;./emptyCommand&quot;).start();
2339             fail(&quot;Expected IOException not thrown&quot;);
2340         } catch (IOException e) {
2341             new File(&quot;./emptyCommand&quot;).delete();
2342             String m = e.getMessage();
2343             if (EnglishUnix.is() &amp;&amp;
2344                 ! matches(m, &quot;Permission denied&quot;))
2345                 unexpected(e);
2346         } catch (Throwable t) { unexpected(t); }
2347 
2348         new File(&quot;emptyCommand&quot;).delete();
2349 
2350         //----------------------------------------------------------------
2351         // Check for correct security permission behavior
2352         //----------------------------------------------------------------
2353         final Policy policy = new Policy();
2354         Policy.setPolicy(policy);
2355         System.setSecurityManager(new SecurityManager());
2356 
2357         try {
2358             // No permissions required to CREATE a ProcessBuilder
2359             policy.setPermissions(/* Nothing */);
2360             new ProcessBuilder(&quot;env&quot;).directory(null).directory();
2361             new ProcessBuilder(&quot;env&quot;).directory(new File(&quot;dir&quot;)).directory();
2362             new ProcessBuilder(&quot;env&quot;).command(&quot;??&quot;).command();
2363         } catch (Throwable t) { unexpected(t); }
2364 
2365         THROWS(SecurityException.class,
2366                () -&gt; { policy.setPermissions(/* Nothing */);
2367                        System.getenv(&quot;foo&quot;);},
2368                () -&gt; { policy.setPermissions(/* Nothing */);
2369                        System.getenv();},
2370                () -&gt; { policy.setPermissions(/* Nothing */);
2371                        new ProcessBuilder(&quot;echo&quot;).start();},
2372                () -&gt; { policy.setPermissions(/* Nothing */);
2373                        Runtime.getRuntime().exec(&quot;echo&quot;);},
2374                () -&gt; { policy.setPermissions(
2375                                new RuntimePermission(&quot;getenv.bar&quot;));
2376                        System.getenv(&quot;foo&quot;);});
2377 
2378         try {
2379             policy.setPermissions(new RuntimePermission(&quot;getenv.foo&quot;));
2380             System.getenv(&quot;foo&quot;);
2381 
2382             policy.setPermissions(new RuntimePermission(&quot;getenv.*&quot;));
2383             System.getenv(&quot;foo&quot;);
2384             System.getenv();
2385             new ProcessBuilder().environment();
2386         } catch (Throwable t) { unexpected(t); }
2387 
2388 
2389         final Permission execPermission
2390             = new FilePermission(&quot;&lt;&lt;ALL FILES&gt;&gt;&quot;, &quot;execute&quot;);
2391 
2392         THROWS(SecurityException.class,
2393                () -&gt; { // environment permission by itself insufficient
2394                        policy.setPermissions(new RuntimePermission(&quot;getenv.*&quot;));
2395                        ProcessBuilder pb = new ProcessBuilder(&quot;env&quot;);
2396                        pb.environment().put(&quot;foo&quot;,&quot;bar&quot;);
2397                        pb.start();},
2398                () -&gt; { // exec permission by itself insufficient
2399                        policy.setPermissions(execPermission);
2400                        ProcessBuilder pb = new ProcessBuilder(&quot;env&quot;);
2401                        pb.environment().put(&quot;foo&quot;,&quot;bar&quot;);
2402                        pb.start();});
2403 
2404         try {
2405             // Both permissions? OK.
2406             policy.setPermissions(new RuntimePermission(&quot;getenv.*&quot;),
2407                                   execPermission);
2408             ProcessBuilder pb = new ProcessBuilder(&quot;env&quot;);
2409             pb.environment().put(&quot;foo&quot;,&quot;bar&quot;);
2410             Process p = pb.start();
2411             closeStreams(p);
2412         } catch (IOException e) { // OK
2413         } catch (Throwable t) { unexpected(t); }
2414 
2415         try {
2416             // Don&#39;t need environment permission unless READING environment
2417             policy.setPermissions(execPermission);
2418             Runtime.getRuntime().exec(&quot;env&quot;, new String[]{});
2419         } catch (IOException e) { // OK
2420         } catch (Throwable t) { unexpected(t); }
2421 
2422         try {
2423             // Don&#39;t need environment permission unless READING environment
2424             policy.setPermissions(execPermission);
2425             new ProcessBuilder(&quot;env&quot;).start();
2426         } catch (IOException e) { // OK
2427         } catch (Throwable t) { unexpected(t); }
2428 
2429         // Restore &quot;normal&quot; state without a security manager
2430         policy.setPermissions(new RuntimePermission(&quot;setSecurityManager&quot;));
2431         System.setSecurityManager(null);
2432 
2433         //----------------------------------------------------------------
2434         // Check that Process.isAlive() &amp;
2435         // Process.waitFor(0, TimeUnit.MILLISECONDS) work as expected.
2436         //----------------------------------------------------------------
2437         try {
2438             List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
2439             childArgs.add(&quot;sleep&quot;);
2440             final Process p = new ProcessBuilder(childArgs).start();
2441             long start = System.nanoTime();
2442             if (!p.isAlive() || p.waitFor(0, TimeUnit.MILLISECONDS)) {
2443                 fail(&quot;Test failed: Process exited prematurely&quot;);
2444             }
2445             long end = System.nanoTime();
2446             // give waitFor(timeout) a wide berth (2s)
2447             System.out.printf(&quot; waitFor process: delta: %d%n&quot;,(end - start) );
2448 
2449             if ((end - start) &gt; TimeUnit.SECONDS.toNanos(2))
2450                 fail(&quot;Test failed: waitFor took too long (&quot; + (end - start) + &quot;ns)&quot;);
2451 
2452             p.destroy();
2453             p.waitFor();
2454 
2455             if (p.isAlive() ||
2456                 !p.waitFor(0, TimeUnit.MILLISECONDS))
2457             {
2458                 fail(&quot;Test failed: Process still alive - please terminate &quot; +
2459                     p.toString() + &quot; manually&quot;);
2460             }
2461         } catch (Throwable t) { unexpected(t); }
2462 
2463         //----------------------------------------------------------------
2464         // Check that Process.waitFor(timeout, TimeUnit.MILLISECONDS)
2465         // works as expected.
2466         //----------------------------------------------------------------
2467         try {
2468             List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
2469             childArgs.add(&quot;sleep&quot;);
2470             final Process p = new ProcessBuilder(childArgs).start();
2471             long start = System.nanoTime();
2472 
2473             p.waitFor(10, TimeUnit.MILLISECONDS);
2474 
2475             long end = System.nanoTime();
2476             if ((end - start) &lt; TimeUnit.MILLISECONDS.toNanos(10))
2477                 fail(&quot;Test failed: waitFor didn&#39;t take long enough (&quot; + (end - start) + &quot;ns)&quot;);
2478 
2479             p.destroy();
2480         } catch (Throwable t) { unexpected(t); }
2481 
2482         //----------------------------------------------------------------
2483         // Check that Process.waitFor(timeout, TimeUnit.MILLISECONDS)
2484         // interrupt works as expected, if interrupted while waiting.
2485         //----------------------------------------------------------------
2486         try {
2487             List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
2488             childArgs.add(&quot;sleep&quot;);
2489             final Process p = new ProcessBuilder(childArgs).start();
2490             final long start = System.nanoTime();
2491             final CountDownLatch aboutToWaitFor = new CountDownLatch(1);
2492 
2493             final Thread thread = new Thread() {
2494                 public void run() {
2495                     try {
2496                         aboutToWaitFor.countDown();
2497                         Thread.currentThread().interrupt();
2498                         boolean result = p.waitFor(30L * 1000L, TimeUnit.MILLISECONDS);
2499                         fail(&quot;waitFor() wasn&#39;t interrupted, its return value was: &quot; + result);
2500                     } catch (InterruptedException success) {
2501                     } catch (Throwable t) { unexpected(t); }
2502                 }
2503             };
2504 
2505             thread.start();
2506             aboutToWaitFor.await();
2507             thread.interrupt();
2508             thread.join(10L * 1000L);
2509             check(millisElapsedSince(start) &lt; 10L * 1000L);
2510             check(!thread.isAlive());
2511             p.destroy();
2512         } catch (Throwable t) { unexpected(t); }
2513 
2514         //----------------------------------------------------------------
2515         // Check that Process.waitFor(Long.MAX_VALUE, TimeUnit.MILLISECONDS)
2516         // interrupt works as expected, if interrupted while waiting.
2517         //----------------------------------------------------------------
2518         try {
2519             List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
2520             childArgs.add(&quot;sleep&quot;);
2521             final Process p = new ProcessBuilder(childArgs).start();
2522             final long start = System.nanoTime();
2523             final CountDownLatch aboutToWaitFor = new CountDownLatch(1);
2524 
2525             final Thread thread = new Thread() {
2526                 public void run() {
2527                     try {
2528                         aboutToWaitFor.countDown();
2529                         Thread.currentThread().interrupt();
2530                         boolean result = p.waitFor(Long.MAX_VALUE, TimeUnit.MILLISECONDS);
2531                         fail(&quot;waitFor() wasn&#39;t interrupted, its return value was: &quot; + result);
2532                     } catch (InterruptedException success) {
2533                     } catch (Throwable t) { unexpected(t); }
2534                 }
2535             };
2536 
2537             thread.start();
2538             aboutToWaitFor.await();
2539             thread.interrupt();
2540             thread.join(10L * 1000L);
2541             check(millisElapsedSince(start) &lt; 10L * 1000L);
2542             check(!thread.isAlive());
2543             p.destroy();
2544         } catch (Throwable t) { unexpected(t); }
2545 
2546         //----------------------------------------------------------------
2547         // Check that Process.waitFor(timeout, TimeUnit.MILLISECONDS)
2548         // interrupt works as expected, if interrupted before waiting.
2549         //----------------------------------------------------------------
2550         try {
2551             List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
2552             childArgs.add(&quot;sleep&quot;);
2553             final Process p = new ProcessBuilder(childArgs).start();
2554             final long start = System.nanoTime();
2555             final CountDownLatch threadStarted = new CountDownLatch(1);
2556 
2557             final Thread thread = new Thread() {
2558                 public void run() {
2559                     try {
2560                         threadStarted.countDown();
2561                         do { Thread.yield(); }
2562                         while (!Thread.currentThread().isInterrupted());
2563                         boolean result = p.waitFor(30L * 1000L, TimeUnit.MILLISECONDS);
2564                         fail(&quot;waitFor() wasn&#39;t interrupted, its return value was: &quot; + result);
2565                     } catch (InterruptedException success) {
2566                     } catch (Throwable t) { unexpected(t); }
2567                 }
2568             };
2569 
2570             thread.start();
2571             threadStarted.await();
2572             thread.interrupt();
2573             thread.join(10L * 1000L);
2574             check(millisElapsedSince(start) &lt; 10L * 1000L);
2575             check(!thread.isAlive());
2576             p.destroy();
2577         } catch (Throwable t) { unexpected(t); }
2578 
2579         //----------------------------------------------------------------
2580         // Check that Process.waitFor(timeout, null) throws NPE.
2581         //----------------------------------------------------------------
2582         try {
2583             List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
2584             childArgs.add(&quot;sleep&quot;);
2585             final Process p = new ProcessBuilder(childArgs).start();
2586             THROWS(NullPointerException.class,
2587                     () -&gt;  p.waitFor(10L, null));
2588             THROWS(NullPointerException.class,
2589                     () -&gt;  p.waitFor(0L, null));
2590             THROWS(NullPointerException.class,
2591                     () -&gt; p.waitFor(-1L, null));
2592             // Terminate process and recheck after it exits
2593             p.destroy();
2594             p.waitFor();
2595             THROWS(NullPointerException.class,
2596                     () -&gt; p.waitFor(10L, null));
2597             THROWS(NullPointerException.class,
2598                     () -&gt; p.waitFor(0L, null));
2599             THROWS(NullPointerException.class,
2600                     () -&gt; p.waitFor(-1L, null));
2601         } catch (Throwable t) { unexpected(t); }
2602 
2603         //----------------------------------------------------------------
2604         // Check that default implementation of Process.waitFor(timeout, null) throws NPE.
2605         //----------------------------------------------------------------
2606         try {
2607             List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
2608             childArgs.add(&quot;sleep&quot;);
2609             final Process proc = new ProcessBuilder(childArgs).start();
2610             final DelegatingProcess p = new DelegatingProcess(proc);
2611 
2612             THROWS(NullPointerException.class,
2613                     () -&gt;  p.waitFor(10L, null));
2614             THROWS(NullPointerException.class,
2615                     () -&gt;  p.waitFor(0L, null));
2616             THROWS(NullPointerException.class,
2617                     () -&gt;  p.waitFor(-1L, null));
2618             // Terminate process and recheck after it exits
2619             p.destroy();
2620             p.waitFor();
2621             THROWS(NullPointerException.class,
2622                     () -&gt; p.waitFor(10L, null));
2623             THROWS(NullPointerException.class,
2624                     () -&gt; p.waitFor(0L, null));
2625             THROWS(NullPointerException.class,
2626                     () -&gt; p.waitFor(-1L, null));
2627         } catch (Throwable t) { unexpected(t); }
2628 
2629         //----------------------------------------------------------------
2630         // Check the default implementation for
2631         // Process.waitFor(long, TimeUnit)
2632         //----------------------------------------------------------------
2633         try {
2634             List&lt;String&gt; childArgs = new ArrayList&lt;String&gt;(javaChildArgs);
2635             childArgs.add(&quot;sleep&quot;);
2636             final Process proc = new ProcessBuilder(childArgs).start();
2637             DelegatingProcess p = new DelegatingProcess(proc);
2638             long start = System.nanoTime();
2639 
2640             p.waitFor(1000, TimeUnit.MILLISECONDS);
2641 
2642             long end = System.nanoTime();
2643             if ((end - start) &lt; 500000000)
2644                 fail(&quot;Test failed: waitFor didn&#39;t take long enough&quot;);
2645 
2646             p.destroy();
2647 
2648             p.waitFor(1000, TimeUnit.MILLISECONDS);
2649         } catch (Throwable t) { unexpected(t); }
2650     }
2651 
2652     static void closeStreams(Process p) {
2653         try {
2654             p.getOutputStream().close();
2655             p.getInputStream().close();
2656             p.getErrorStream().close();
2657         } catch (Throwable t) { unexpected(t); }
2658     }
2659 
2660     //----------------------------------------------------------------
2661     // A Policy class designed to make permissions fiddling very easy.
2662     //----------------------------------------------------------------
2663     private static class Policy extends java.security.Policy {
2664         static final java.security.Policy DEFAULT_POLICY = java.security.Policy.getPolicy();
2665 
2666         private Permissions perms;
2667 
2668         public void setPermissions(Permission...permissions) {
2669             perms = new Permissions();
2670             for (Permission permission : permissions)
2671                 perms.add(permission);
2672         }
2673 
2674         public Policy() { setPermissions(/* Nothing */); }
2675 
2676         public PermissionCollection getPermissions(CodeSource cs) {
2677             return perms;
2678         }
2679 
2680         public PermissionCollection getPermissions(ProtectionDomain pd) {
2681             return perms;
2682         }
2683 
2684         public boolean implies(ProtectionDomain pd, Permission p) {
2685             return perms.implies(p) || DEFAULT_POLICY.implies(pd, p);
2686         }
2687 
2688         public void refresh() {}
2689     }
2690 
2691     private static class StreamAccumulator extends Thread {
2692         private final InputStream is;
2693         private final StringBuilder sb = new StringBuilder();
2694         private Throwable throwable = null;
2695 
2696         public String result () throws Throwable {
2697             if (throwable != null)
2698                 throw throwable;
2699             return sb.toString();
2700         }
2701 
2702         StreamAccumulator (InputStream is) {
2703             this.is = is;
2704         }
2705 
2706         public void run() {
2707             try {
2708                 Reader r = new InputStreamReader(is);
2709                 char[] buf = new char[4096];
2710                 int n;
2711                 while ((n = r.read(buf)) &gt; 0) {
2712                     sb.append(buf,0,n);
2713                 }
2714             } catch (Throwable t) {
2715                 throwable = t;
2716             } finally {
2717                 try { is.close(); }
2718                 catch (Throwable t) { throwable = t; }
2719             }
2720         }
2721     }
2722 
2723     static ProcessResults run(ProcessBuilder pb) {
2724         try {
2725             return run(pb.start());
2726         } catch (Throwable t) { unexpected(t); return null; }
2727     }
2728 
2729     private static ProcessResults run(Process p) {
2730         Throwable throwable = null;
2731         int exitValue = -1;
2732         String out = &quot;&quot;;
2733         String err = &quot;&quot;;
2734 
2735         StreamAccumulator outAccumulator =
2736             new StreamAccumulator(p.getInputStream());
2737         StreamAccumulator errAccumulator =
2738             new StreamAccumulator(p.getErrorStream());
2739 
2740         try {
2741             outAccumulator.start();
2742             errAccumulator.start();
2743 
2744             exitValue = p.waitFor();
2745 
2746             outAccumulator.join();
2747             errAccumulator.join();
2748 
2749             out = outAccumulator.result();
2750             err = errAccumulator.result();
2751         } catch (Throwable t) {
2752             throwable = t;
2753         }
2754 
2755         return new ProcessResults(out, err, exitValue, throwable);
2756     }
2757 
2758     //----------------------------------------------------------------
2759     // Results of a command
2760     //----------------------------------------------------------------
2761     private static class ProcessResults {
2762         private final String out;
2763         private final String err;
2764         private final int exitValue;
2765         private final Throwable throwable;
2766 
2767         public ProcessResults(String out,
2768                               String err,
2769                               int exitValue,
2770                               Throwable throwable) {
2771             this.out = out;
2772             this.err = err;
2773             this.exitValue = exitValue;
2774             this.throwable = throwable;
2775         }
2776 
2777         public String out()          { return out; }
2778         public String err()          { return err; }
2779         public int exitValue()       { return exitValue; }
2780         public Throwable throwable() { return throwable; }
2781 
2782         public String toString() {
2783             StringBuilder sb = new StringBuilder();
2784             sb.append(&quot;&lt;STDOUT&gt;\n&quot; + out() + &quot;&lt;/STDOUT&gt;\n&quot;)
2785                 .append(&quot;&lt;STDERR&gt;\n&quot; + err() + &quot;&lt;/STDERR&gt;\n&quot;)
2786                 .append(&quot;exitValue = &quot; + exitValue + &quot;\n&quot;);
2787             if (throwable != null)
2788                 sb.append(throwable.getStackTrace());
2789             return sb.toString();
2790         }
2791     }
2792 
2793     //--------------------- Infrastructure ---------------------------
2794     static volatile int passed = 0, failed = 0;
2795     static void pass() {passed++;}
2796     static void fail() {failed++; Thread.dumpStack();}
2797     static void fail(String msg) {System.err.println(msg); fail();}
2798     static void unexpected(Throwable t) {failed++; t.printStackTrace();}
2799     static void check(boolean cond) {if (cond) pass(); else fail();}
2800     static void check(boolean cond, String m) {if (cond) pass(); else fail(m);}
2801     static void equal(Object x, Object y) {
2802         if (x == null ? y == null : x.equals(y)) pass();
2803         else fail(&quot;&gt;&#39;&quot; + x + &quot;&#39;&lt;&quot; + &quot; not equal to &quot; + &quot;&#39;&quot; + y + &quot;&#39;&quot;);}
2804 
2805     public static void main(String[] args) throws Throwable {
2806         try {realMain(args);} catch (Throwable t) {unexpected(t);}
2807         System.out.printf(&quot;%nPassed = %d, failed = %d%n%n&quot;, passed, failed);
2808         if (failed &gt; 0) throw new AssertionError(&quot;Some tests failed&quot;);}
2809     interface Fun {void f() throws Throwable;}
2810     static void THROWS(Class&lt;? extends Throwable&gt; k, Fun... fs) {
2811         for (Fun f : fs)
2812             try { f.f(); fail(&quot;Expected &quot; + k.getName() + &quot; not thrown&quot;); }
2813             catch (Throwable t) {
2814                 if (k.isAssignableFrom(t.getClass())) pass();
2815                 else unexpected(t);}}
2816 
2817     static boolean isLocked(final Object monitor, final long millis) throws InterruptedException {
2818         return new Thread() {
2819             volatile boolean unlocked;
2820 
2821             @Override
2822             public void run() {
2823                 synchronized (monitor) { unlocked = true; }
2824             }
2825 
2826             boolean isLocked() throws InterruptedException {
2827                 start();
2828                 join(millis);
2829                 return !unlocked;
2830             }
2831         }.isLocked();
2832     }
2833 }
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>
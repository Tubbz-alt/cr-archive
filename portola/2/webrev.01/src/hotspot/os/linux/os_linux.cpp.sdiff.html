<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os/linux/os_linux.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../../../../make/test/JtregNativeJdk.gmk.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../share/gc/shared/genCollectedHeap.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/linux/os_linux.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  86 # include &lt;signal.h&gt;
  87 # include &lt;endian.h&gt;
  88 # include &lt;errno.h&gt;
  89 # include &lt;dlfcn.h&gt;
  90 # include &lt;stdio.h&gt;
  91 # include &lt;unistd.h&gt;
  92 # include &lt;sys/resource.h&gt;
  93 # include &lt;pthread.h&gt;
  94 # include &lt;sys/stat.h&gt;
  95 # include &lt;sys/time.h&gt;
  96 # include &lt;sys/times.h&gt;
  97 # include &lt;sys/utsname.h&gt;
  98 # include &lt;sys/socket.h&gt;
  99 # include &lt;sys/wait.h&gt;
 100 # include &lt;pwd.h&gt;
 101 # include &lt;poll.h&gt;
 102 # include &lt;fcntl.h&gt;
 103 # include &lt;string.h&gt;
 104 # include &lt;syscall.h&gt;
 105 # include &lt;sys/sysinfo.h&gt;
<span class="line-removed"> 106 # include &lt;gnu/libc-version.h&gt;</span>
 107 # include &lt;sys/ipc.h&gt;
 108 # include &lt;sys/shm.h&gt;
 109 # include &lt;link.h&gt;
 110 # include &lt;stdint.h&gt;
 111 # include &lt;inttypes.h&gt;
 112 # include &lt;sys/ioctl.h&gt;
 113 
 114 #ifndef _GNU_SOURCE
 115   #define _GNU_SOURCE
 116   #include &lt;sched.h&gt;
 117   #undef _GNU_SOURCE
 118 #else
 119   #include &lt;sched.h&gt;
 120 #endif
 121 
 122 // if RUSAGE_THREAD for getrusage() has not been defined, do it here. The code calling
 123 // getrusage() is prepared to handle the associated failure.
 124 #ifndef RUSAGE_THREAD
 125   #define RUSAGE_THREAD   (1)               /* only the calling thread */
 126 #endif
</pre>
<hr />
<pre>
 134 
 135 enum CoredumpFilterBit {
 136   FILE_BACKED_PVT_BIT = 1 &lt;&lt; 2,
 137   FILE_BACKED_SHARED_BIT = 1 &lt;&lt; 3,
 138   LARGEPAGES_BIT = 1 &lt;&lt; 6,
 139   DAX_SHARED_BIT = 1 &lt;&lt; 8
 140 };
 141 
 142 ////////////////////////////////////////////////////////////////////////////////
 143 // global variables
 144 julong os::Linux::_physical_memory = 0;
 145 
 146 address   os::Linux::_initial_thread_stack_bottom = NULL;
 147 uintptr_t os::Linux::_initial_thread_stack_size   = 0;
 148 
 149 int (*os::Linux::_pthread_getcpuclockid)(pthread_t, clockid_t *) = NULL;
 150 int (*os::Linux::_pthread_setname_np)(pthread_t, const char*) = NULL;
 151 pthread_t os::Linux::_main_thread;
 152 int os::Linux::_page_size = -1;
 153 bool os::Linux::_supports_fast_thread_cpu_time = false;
<span class="line-modified"> 154 const char * os::Linux::_glibc_version = NULL;</span>
<span class="line-modified"> 155 const char * os::Linux::_libpthread_version = NULL;</span>
 156 
 157 static jlong initial_time_count=0;
 158 
 159 static int clock_tics_per_sec = 100;
 160 
 161 // If the VM might have been created on the primordial thread, we need to resolve the
 162 // primordial thread stack bounds and check if the current thread might be the
 163 // primordial thread in places. If we know that the primordial thread is never used,
 164 // such as when the VM was created by one of the standard java launchers, we can
 165 // avoid this
 166 static bool suppress_primordial_thread_resolution = false;
 167 
 168 // For diagnostics to print a message once. see run_periodic_checks
 169 static sigset_t check_signal_done;
 170 static bool check_signals = true;
 171 
 172 // Signal number used to suspend/resume a thread
 173 
 174 // do not use any signal number less than SIGSEGV, see 4355769
 175 static int SR_signum = SIGUSR2;
</pre>
<hr />
<pre>
 587     if (thread-&gt;is_VM_thread()) {
 588       // Only the VM thread handles BREAK_SIGNAL ...
 589       pthread_sigmask(SIG_UNBLOCK, vm_signals(), NULL);
 590     } else {
 591       // ... all other threads block BREAK_SIGNAL
 592       pthread_sigmask(SIG_BLOCK, vm_signals(), NULL);
 593     }
 594   }
 595 }
 596 
 597 //////////////////////////////////////////////////////////////////////////////
 598 // detecting pthread library
 599 
 600 void os::Linux::libpthread_init() {
 601   // Save glibc and pthread version strings.
 602 #if !defined(_CS_GNU_LIBC_VERSION) || \
 603     !defined(_CS_GNU_LIBPTHREAD_VERSION)
 604   #error &quot;glibc too old (&lt; 2.3.2)&quot;
 605 #endif
 606 
<span class="line-modified"> 607   size_t n = confstr(_CS_GNU_LIBC_VERSION, NULL, 0);</span>
<span class="line-modified"> 608   assert(n &gt; 0, &quot;cannot retrieve glibc version&quot;);</span>
<span class="line-modified"> 609   char *str = (char *)malloc(n, mtInternal);</span>
<span class="line-modified"> 610   confstr(_CS_GNU_LIBC_VERSION, str, n);</span>
<span class="line-modified"> 611   os::Linux::set_glibc_version(str);</span>



 612 
 613   n = confstr(_CS_GNU_LIBPTHREAD_VERSION, NULL, 0);
<span class="line-modified"> 614   assert(n &gt; 0, &quot;cannot retrieve pthread version&quot;);</span>
<span class="line-modified"> 615   str = (char *)malloc(n, mtInternal);</span>
<span class="line-modified"> 616   confstr(_CS_GNU_LIBPTHREAD_VERSION, str, n);</span>
<span class="line-modified"> 617   os::Linux::set_libpthread_version(str);</span>

 618 }
 619 
 620 /////////////////////////////////////////////////////////////////////////////
 621 // thread stack expansion
 622 
 623 // os::Linux::manually_expand_stack() takes care of expanding the thread
 624 // stack. Note that this is normally not needed: pthread stacks allocate
 625 // thread stack using mmap() without MAP_NORESERVE, so the stack is already
 626 // committed. Therefore it is not necessary to expand the stack manually.
 627 //
 628 // Manually expanding the stack was historically needed on LinuxThreads
 629 // thread stacks, which were allocated with mmap(MAP_GROWSDOWN). Nowadays
 630 // it is kept to deal with very rare corner cases:
 631 //
 632 // For one, user may run the VM on an own implementation of threads
 633 // whose stacks are - like the old LinuxThreads - implemented using
 634 // mmap(MAP_GROWSDOWN).
 635 //
 636 // Also, this coding may be needed if the VM is running on the primordial
 637 // thread. Normally we avoid running on the primordial thread; however,
</pre>
<hr />
<pre>
3100 void os::Linux::sched_getcpu_init() {
3101   // sched_getcpu() should be in libc.
3102   set_sched_getcpu(CAST_TO_FN_PTR(sched_getcpu_func_t,
3103                                   dlsym(RTLD_DEFAULT, &quot;sched_getcpu&quot;)));
3104 
3105   // If it&#39;s not, try a direct syscall.
3106   if (sched_getcpu() == -1) {
3107     set_sched_getcpu(CAST_TO_FN_PTR(sched_getcpu_func_t,
3108                                     (void*)&amp;sched_getcpu_syscall));
3109   }
3110 
3111   if (sched_getcpu() == -1) {
3112     vm_exit_during_initialization(&quot;getcpu(2) system call not supported by kernel&quot;);
3113   }
3114 }
3115 
3116 // Something to do with the numa-aware allocator needs these symbols
3117 extern &quot;C&quot; JNIEXPORT void numa_warn(int number, char *where, ...) { }
3118 extern &quot;C&quot; JNIEXPORT void numa_error(char *where) { }
3119 




















3120 // Handle request to load libnuma symbol version 1.1 (API v1). If it fails
3121 // load symbol from base version instead.
3122 void* os::Linux::libnuma_dlsym(void* handle, const char *name) {
<span class="line-modified">3123   void *f = dlvsym(handle, name, &quot;libnuma_1.1&quot;);</span>
<span class="line-removed">3124   if (f == NULL) {</span>
<span class="line-removed">3125     f = dlsym(handle, name);</span>
<span class="line-removed">3126   }</span>
<span class="line-removed">3127   return f;</span>
3128 }
3129 
3130 // Handle request to load libnuma symbol version 1.2 (API v2) only.
3131 // Return NULL if the symbol is not defined in this particular version.
3132 void* os::Linux::libnuma_v2_dlsym(void* handle, const char* name) {
<span class="line-modified">3133   return dlvsym(handle, name, &quot;libnuma_1.2&quot;);</span>
3134 }
3135 
3136 bool os::Linux::libnuma_init() {
3137   if (sched_getcpu() != -1) { // Requires sched_getcpu() support
3138     void *handle = dlopen(&quot;libnuma.so.1&quot;, RTLD_LAZY);
3139     if (handle != NULL) {
3140       set_numa_node_to_cpus(CAST_TO_FN_PTR(numa_node_to_cpus_func_t,
3141                                            libnuma_dlsym(handle, &quot;numa_node_to_cpus&quot;)));
3142       set_numa_max_node(CAST_TO_FN_PTR(numa_max_node_func_t,
3143                                        libnuma_dlsym(handle, &quot;numa_max_node&quot;)));
3144       set_numa_num_configured_nodes(CAST_TO_FN_PTR(numa_num_configured_nodes_func_t,
3145                                                    libnuma_dlsym(handle, &quot;numa_num_configured_nodes&quot;)));
3146       set_numa_available(CAST_TO_FN_PTR(numa_available_func_t,
3147                                         libnuma_dlsym(handle, &quot;numa_available&quot;)));
3148       set_numa_tonode_memory(CAST_TO_FN_PTR(numa_tonode_memory_func_t,
3149                                             libnuma_dlsym(handle, &quot;numa_tonode_memory&quot;)));
3150       set_numa_interleave_memory(CAST_TO_FN_PTR(numa_interleave_memory_func_t,
3151                                                 libnuma_dlsym(handle, &quot;numa_interleave_memory&quot;)));
3152       set_numa_interleave_memory_v2(CAST_TO_FN_PTR(numa_interleave_memory_v2_func_t,
3153                                                 libnuma_v2_dlsym(handle, &quot;numa_interleave_memory&quot;)));
</pre>
<hr />
<pre>
5032     tty-&gt;print(&quot;Warning: %s handler flags &quot;, exception_name(sig, buf, O_BUFLEN));
5033     tty-&gt;print(&quot;expected:&quot;);
5034     os::Posix::print_sa_flags(tty, os::Linux::get_our_sigflags(sig));
5035     tty-&gt;cr();
5036     tty-&gt;print(&quot;  found:&quot;);
5037     os::Posix::print_sa_flags(tty, act.sa_flags);
5038     tty-&gt;cr();
5039     // No need to check this sig any longer
5040     sigaddset(&amp;check_signal_done, sig);
5041   }
5042 
5043   // Dump all the signal
5044   if (sigismember(&amp;check_signal_done, sig)) {
5045     print_signal_handlers(tty, buf, O_BUFLEN);
5046   }
5047 }
5048 
5049 extern void report_error(char* file_name, int line_no, char* title,
5050                          char* format, ...);
5051 

























































5052 // this is called _before_ most of the global arguments have been parsed
5053 void os::init(void) {
5054   char dummy;   // used to get a guess on initial stack address
5055 
5056   clock_tics_per_sec = sysconf(_SC_CLK_TCK);
5057 
5058   init_random(1234567);
5059 
5060   Linux::set_page_size(sysconf(_SC_PAGESIZE));
5061   if (Linux::page_size() == -1) {
5062     fatal(&quot;os_linux.cpp: os::init: sysconf failed (%s)&quot;,
5063           os::strerror(errno));
5064   }
5065   init_page_sizes((size_t) Linux::page_size());
5066 
5067   Linux::initialize_system_info();
5068 
5069   os::Linux::CPUPerfTicks pticks;
5070   bool res = os::Linux::get_tick_information(&amp;pticks, -1);
5071 
5072   if (res &amp;&amp; pticks.has_steal_ticks) {
5073     has_initial_tick_info = true;
5074     initial_total_ticks = pticks.total;
5075     initial_steal_ticks = pticks.steal;
5076   }
5077 
5078   // _main_thread points to the thread that created/loaded the JVM.
5079   Linux::_main_thread = pthread_self();
5080 
5081   // retrieve entry point for pthread_setname_np
5082   Linux::_pthread_setname_np =
5083     (int(*)(pthread_t, const char*))dlsym(RTLD_DEFAULT, &quot;pthread_setname_np&quot;);
5084 


5085   os::Posix::init();
5086 
5087   initial_time_count = javaTimeNanos();
5088 
5089   // Always warn if no monotonic clock available
5090   if (!os::Posix::supports_monotonic_clock()) {
5091     warning(&quot;No monotonic clock was available - timed services may &quot;    \
5092             &quot;be adversely affected if the time-of-day clock changes&quot;);
5093   }
5094 }
5095 
5096 // To install functions for atexit system call
5097 extern &quot;C&quot; {
5098   static void perfMemory_exit_helper() {
5099     perfMemory_exit();
5100   }
5101 }
5102 
5103 void os::pd_init_container_support() {
5104   OSContainer::init();
</pre>
</td>
<td>
<hr />
<pre>
  86 # include &lt;signal.h&gt;
  87 # include &lt;endian.h&gt;
  88 # include &lt;errno.h&gt;
  89 # include &lt;dlfcn.h&gt;
  90 # include &lt;stdio.h&gt;
  91 # include &lt;unistd.h&gt;
  92 # include &lt;sys/resource.h&gt;
  93 # include &lt;pthread.h&gt;
  94 # include &lt;sys/stat.h&gt;
  95 # include &lt;sys/time.h&gt;
  96 # include &lt;sys/times.h&gt;
  97 # include &lt;sys/utsname.h&gt;
  98 # include &lt;sys/socket.h&gt;
  99 # include &lt;sys/wait.h&gt;
 100 # include &lt;pwd.h&gt;
 101 # include &lt;poll.h&gt;
 102 # include &lt;fcntl.h&gt;
 103 # include &lt;string.h&gt;
 104 # include &lt;syscall.h&gt;
 105 # include &lt;sys/sysinfo.h&gt;

 106 # include &lt;sys/ipc.h&gt;
 107 # include &lt;sys/shm.h&gt;
 108 # include &lt;link.h&gt;
 109 # include &lt;stdint.h&gt;
 110 # include &lt;inttypes.h&gt;
 111 # include &lt;sys/ioctl.h&gt;
 112 
 113 #ifndef _GNU_SOURCE
 114   #define _GNU_SOURCE
 115   #include &lt;sched.h&gt;
 116   #undef _GNU_SOURCE
 117 #else
 118   #include &lt;sched.h&gt;
 119 #endif
 120 
 121 // if RUSAGE_THREAD for getrusage() has not been defined, do it here. The code calling
 122 // getrusage() is prepared to handle the associated failure.
 123 #ifndef RUSAGE_THREAD
 124   #define RUSAGE_THREAD   (1)               /* only the calling thread */
 125 #endif
</pre>
<hr />
<pre>
 133 
 134 enum CoredumpFilterBit {
 135   FILE_BACKED_PVT_BIT = 1 &lt;&lt; 2,
 136   FILE_BACKED_SHARED_BIT = 1 &lt;&lt; 3,
 137   LARGEPAGES_BIT = 1 &lt;&lt; 6,
 138   DAX_SHARED_BIT = 1 &lt;&lt; 8
 139 };
 140 
 141 ////////////////////////////////////////////////////////////////////////////////
 142 // global variables
 143 julong os::Linux::_physical_memory = 0;
 144 
 145 address   os::Linux::_initial_thread_stack_bottom = NULL;
 146 uintptr_t os::Linux::_initial_thread_stack_size   = 0;
 147 
 148 int (*os::Linux::_pthread_getcpuclockid)(pthread_t, clockid_t *) = NULL;
 149 int (*os::Linux::_pthread_setname_np)(pthread_t, const char*) = NULL;
 150 pthread_t os::Linux::_main_thread;
 151 int os::Linux::_page_size = -1;
 152 bool os::Linux::_supports_fast_thread_cpu_time = false;
<span class="line-modified"> 153 const char * os::Linux::_glibc_version = &quot;unknown&quot;;</span>
<span class="line-modified"> 154 const char * os::Linux::_libpthread_version = &quot;unknown&quot;;</span>
 155 
 156 static jlong initial_time_count=0;
 157 
 158 static int clock_tics_per_sec = 100;
 159 
 160 // If the VM might have been created on the primordial thread, we need to resolve the
 161 // primordial thread stack bounds and check if the current thread might be the
 162 // primordial thread in places. If we know that the primordial thread is never used,
 163 // such as when the VM was created by one of the standard java launchers, we can
 164 // avoid this
 165 static bool suppress_primordial_thread_resolution = false;
 166 
 167 // For diagnostics to print a message once. see run_periodic_checks
 168 static sigset_t check_signal_done;
 169 static bool check_signals = true;
 170 
 171 // Signal number used to suspend/resume a thread
 172 
 173 // do not use any signal number less than SIGSEGV, see 4355769
 174 static int SR_signum = SIGUSR2;
</pre>
<hr />
<pre>
 586     if (thread-&gt;is_VM_thread()) {
 587       // Only the VM thread handles BREAK_SIGNAL ...
 588       pthread_sigmask(SIG_UNBLOCK, vm_signals(), NULL);
 589     } else {
 590       // ... all other threads block BREAK_SIGNAL
 591       pthread_sigmask(SIG_BLOCK, vm_signals(), NULL);
 592     }
 593   }
 594 }
 595 
 596 //////////////////////////////////////////////////////////////////////////////
 597 // detecting pthread library
 598 
 599 void os::Linux::libpthread_init() {
 600   // Save glibc and pthread version strings.
 601 #if !defined(_CS_GNU_LIBC_VERSION) || \
 602     !defined(_CS_GNU_LIBPTHREAD_VERSION)
 603   #error &quot;glibc too old (&lt; 2.3.2)&quot;
 604 #endif
 605 
<span class="line-modified"> 606   size_t n;</span>
<span class="line-modified"> 607 </span>
<span class="line-modified"> 608   n = confstr(_CS_GNU_LIBC_VERSION, NULL, 0);</span>
<span class="line-modified"> 609   if (n &gt; 0) {</span>
<span class="line-modified"> 610     char* str = (char *)malloc(n, mtInternal);</span>
<span class="line-added"> 611     confstr(_CS_GNU_LIBC_VERSION, str, n);</span>
<span class="line-added"> 612     os::Linux::set_glibc_version(str);</span>
<span class="line-added"> 613   }</span>
 614 
 615   n = confstr(_CS_GNU_LIBPTHREAD_VERSION, NULL, 0);
<span class="line-modified"> 616   if (n &gt; 0) {</span>
<span class="line-modified"> 617     char* str = (char *)malloc(n, mtInternal);</span>
<span class="line-modified"> 618     confstr(_CS_GNU_LIBPTHREAD_VERSION, str, n);</span>
<span class="line-modified"> 619     os::Linux::set_libpthread_version(str);</span>
<span class="line-added"> 620   }</span>
 621 }
 622 
 623 /////////////////////////////////////////////////////////////////////////////
 624 // thread stack expansion
 625 
 626 // os::Linux::manually_expand_stack() takes care of expanding the thread
 627 // stack. Note that this is normally not needed: pthread stacks allocate
 628 // thread stack using mmap() without MAP_NORESERVE, so the stack is already
 629 // committed. Therefore it is not necessary to expand the stack manually.
 630 //
 631 // Manually expanding the stack was historically needed on LinuxThreads
 632 // thread stacks, which were allocated with mmap(MAP_GROWSDOWN). Nowadays
 633 // it is kept to deal with very rare corner cases:
 634 //
 635 // For one, user may run the VM on an own implementation of threads
 636 // whose stacks are - like the old LinuxThreads - implemented using
 637 // mmap(MAP_GROWSDOWN).
 638 //
 639 // Also, this coding may be needed if the VM is running on the primordial
 640 // thread. Normally we avoid running on the primordial thread; however,
</pre>
<hr />
<pre>
3103 void os::Linux::sched_getcpu_init() {
3104   // sched_getcpu() should be in libc.
3105   set_sched_getcpu(CAST_TO_FN_PTR(sched_getcpu_func_t,
3106                                   dlsym(RTLD_DEFAULT, &quot;sched_getcpu&quot;)));
3107 
3108   // If it&#39;s not, try a direct syscall.
3109   if (sched_getcpu() == -1) {
3110     set_sched_getcpu(CAST_TO_FN_PTR(sched_getcpu_func_t,
3111                                     (void*)&amp;sched_getcpu_syscall));
3112   }
3113 
3114   if (sched_getcpu() == -1) {
3115     vm_exit_during_initialization(&quot;getcpu(2) system call not supported by kernel&quot;);
3116   }
3117 }
3118 
3119 // Something to do with the numa-aware allocator needs these symbols
3120 extern &quot;C&quot; JNIEXPORT void numa_warn(int number, char *where, ...) { }
3121 extern &quot;C&quot; JNIEXPORT void numa_error(char *where) { }
3122 
<span class="line-added">3123 static void* dlvsym_if_available(void* handle, const char* name, const char* version) {</span>
<span class="line-added">3124   typedef void* (*dlvsym_func_type)(void* handle, const char* name, const char* version);</span>
<span class="line-added">3125   static dlvsym_func_type dlvsym_func;</span>
<span class="line-added">3126   static bool initialized = false;</span>
<span class="line-added">3127 </span>
<span class="line-added">3128   if (!initialized) {</span>
<span class="line-added">3129     dlvsym_func = (dlvsym_func_type)dlsym(RTLD_NEXT, &quot;dlvsym&quot;);</span>
<span class="line-added">3130     initialized = true;</span>
<span class="line-added">3131   }</span>
<span class="line-added">3132 </span>
<span class="line-added">3133   if (dlvsym_func != NULL) {</span>
<span class="line-added">3134     void *f = dlvsym_func(handle, name, version);</span>
<span class="line-added">3135     if (f != NULL) {</span>
<span class="line-added">3136       return f;</span>
<span class="line-added">3137     }</span>
<span class="line-added">3138   }</span>
<span class="line-added">3139 </span>
<span class="line-added">3140   return dlsym(handle, name);</span>
<span class="line-added">3141 }</span>
<span class="line-added">3142 </span>
3143 // Handle request to load libnuma symbol version 1.1 (API v1). If it fails
3144 // load symbol from base version instead.
3145 void* os::Linux::libnuma_dlsym(void* handle, const char *name) {
<span class="line-modified">3146   return dlvsym_if_available(handle, name, &quot;libnuma_1.1&quot;);</span>




3147 }
3148 
3149 // Handle request to load libnuma symbol version 1.2 (API v2) only.
3150 // Return NULL if the symbol is not defined in this particular version.
3151 void* os::Linux::libnuma_v2_dlsym(void* handle, const char* name) {
<span class="line-modified">3152   return dlvsym_if_available(handle, name, &quot;libnuma_1.2&quot;);</span>
3153 }
3154 
3155 bool os::Linux::libnuma_init() {
3156   if (sched_getcpu() != -1) { // Requires sched_getcpu() support
3157     void *handle = dlopen(&quot;libnuma.so.1&quot;, RTLD_LAZY);
3158     if (handle != NULL) {
3159       set_numa_node_to_cpus(CAST_TO_FN_PTR(numa_node_to_cpus_func_t,
3160                                            libnuma_dlsym(handle, &quot;numa_node_to_cpus&quot;)));
3161       set_numa_max_node(CAST_TO_FN_PTR(numa_max_node_func_t,
3162                                        libnuma_dlsym(handle, &quot;numa_max_node&quot;)));
3163       set_numa_num_configured_nodes(CAST_TO_FN_PTR(numa_num_configured_nodes_func_t,
3164                                                    libnuma_dlsym(handle, &quot;numa_num_configured_nodes&quot;)));
3165       set_numa_available(CAST_TO_FN_PTR(numa_available_func_t,
3166                                         libnuma_dlsym(handle, &quot;numa_available&quot;)));
3167       set_numa_tonode_memory(CAST_TO_FN_PTR(numa_tonode_memory_func_t,
3168                                             libnuma_dlsym(handle, &quot;numa_tonode_memory&quot;)));
3169       set_numa_interleave_memory(CAST_TO_FN_PTR(numa_interleave_memory_func_t,
3170                                                 libnuma_dlsym(handle, &quot;numa_interleave_memory&quot;)));
3171       set_numa_interleave_memory_v2(CAST_TO_FN_PTR(numa_interleave_memory_v2_func_t,
3172                                                 libnuma_v2_dlsym(handle, &quot;numa_interleave_memory&quot;)));
</pre>
<hr />
<pre>
5051     tty-&gt;print(&quot;Warning: %s handler flags &quot;, exception_name(sig, buf, O_BUFLEN));
5052     tty-&gt;print(&quot;expected:&quot;);
5053     os::Posix::print_sa_flags(tty, os::Linux::get_our_sigflags(sig));
5054     tty-&gt;cr();
5055     tty-&gt;print(&quot;  found:&quot;);
5056     os::Posix::print_sa_flags(tty, act.sa_flags);
5057     tty-&gt;cr();
5058     // No need to check this sig any longer
5059     sigaddset(&amp;check_signal_done, sig);
5060   }
5061 
5062   // Dump all the signal
5063   if (sigismember(&amp;check_signal_done, sig)) {
5064     print_signal_handlers(tty, buf, O_BUFLEN);
5065   }
5066 }
5067 
5068 extern void report_error(char* file_name, int line_no, char* title,
5069                          char* format, ...);
5070 
<span class="line-added">5071 // Some linux distributions (notably: Alpine Linux) include the</span>
<span class="line-added">5072 // grsecurity in the kernel by default. Of particular interest from a</span>
<span class="line-added">5073 // JVM perspective is PaX (https://pax.grsecurity.net/), which adds</span>
<span class="line-added">5074 // some security features related to page attributes. Specifically,</span>
<span class="line-added">5075 // the MPROTECT PaX functionality</span>
<span class="line-added">5076 // (https://pax.grsecurity.net/docs/mprotect.txt) prevents dynamic</span>
<span class="line-added">5077 // code generation by disallowing a (previously) writable page to be</span>
<span class="line-added">5078 // marked as executable. This is, of course, exactly what HotSpot does</span>
<span class="line-added">5079 // for both JIT compiled method, as well as for stubs, adapters, etc.</span>
<span class="line-added">5080 //</span>
<span class="line-added">5081 // Instead of crashing &quot;lazily&quot; when trying to make a page executable,</span>
<span class="line-added">5082 // this code probes for the presence of PaX and reports the failure</span>
<span class="line-added">5083 // eagerly.</span>
<span class="line-added">5084 static void check_pax(void) {</span>
<span class="line-added">5085   // Zero doesn&#39;t generate code dynamically, so no need to perform the PaX check</span>
<span class="line-added">5086 #ifndef ZERO</span>
<span class="line-added">5087   size_t size = os::Linux::page_size();</span>
<span class="line-added">5088 </span>
<span class="line-added">5089   void* p = ::mmap(NULL, size, PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);</span>
<span class="line-added">5090   if (p == MAP_FAILED) {</span>
<span class="line-added">5091     vm_exit_out_of_memory(size, OOM_MMAP_ERROR, &quot;failed to allocate memory for PaX check.&quot;);</span>
<span class="line-added">5092   }</span>
<span class="line-added">5093 </span>
<span class="line-added">5094   int res = ::mprotect(p, size, PROT_WRITE|PROT_EXEC);</span>
<span class="line-added">5095   if (res == -1) {</span>
<span class="line-added">5096     vm_exit_during_initialization(&quot;Failed to mark memory page as executable&quot;,</span>
<span class="line-added">5097                                   &quot;Please check if grsecurity/PaX is enabled in your kernel.\n&quot;</span>
<span class="line-added">5098                                   &quot;\n&quot;</span>
<span class="line-added">5099                                   &quot;For example, you can do this by running (note: you may need root privileges):\n&quot;</span>
<span class="line-added">5100                                   &quot;\n&quot;</span>
<span class="line-added">5101                                   &quot;    sysctl kernel.pax.softmode\n&quot;</span>
<span class="line-added">5102                                   &quot;\n&quot;</span>
<span class="line-added">5103                                   &quot;If PaX is included in the kernel you will see something like this:\n&quot;</span>
<span class="line-added">5104                                   &quot;\n&quot;</span>
<span class="line-added">5105                                   &quot;    kernel.pax.softmode = 0\n&quot;</span>
<span class="line-added">5106                                   &quot;\n&quot;</span>
<span class="line-added">5107                                   &quot;In particular, if the value is 0 (zero), then PaX is enabled.\n&quot;</span>
<span class="line-added">5108                                   &quot;\n&quot;</span>
<span class="line-added">5109                                   &quot;PaX includes security functionality which interferes with the dynamic code\n&quot;</span>
<span class="line-added">5110                                   &quot;generation the JVM relies on. Specifically, the MPROTECT functionality as\n&quot;</span>
<span class="line-added">5111                                   &quot;described on https://pax.grsecurity.net/docs/mprotect.txt is not compatible\n&quot;</span>
<span class="line-added">5112                                   &quot;with the JVM. If you want to allow the JVM to run you will have to disable PaX.\n&quot;</span>
<span class="line-added">5113                                   &quot;You can do this on a per-executable basis using the paxctl tool, for example:\n&quot;</span>
<span class="line-added">5114                                   &quot;\n&quot;</span>
<span class="line-added">5115                                   &quot;    paxctl -cm bin/java\n&quot;</span>
<span class="line-added">5116                                   &quot;\n&quot;</span>
<span class="line-added">5117                                   &quot;Please note that this modifies the executable binary in-place, so you may want\n&quot;</span>
<span class="line-added">5118                                   &quot;to make a backup of it first. Also note that you have to repeat this for other\n&quot;</span>
<span class="line-added">5119                                   &quot;executables like javac, jar, jcmd, etc.\n&quot;</span>
<span class="line-added">5120                                   );</span>
<span class="line-added">5121 </span>
<span class="line-added">5122   }</span>
<span class="line-added">5123 </span>
<span class="line-added">5124   ::munmap(p, size);</span>
<span class="line-added">5125 #endif</span>
<span class="line-added">5126 }</span>
<span class="line-added">5127 </span>
5128 // this is called _before_ most of the global arguments have been parsed
5129 void os::init(void) {
5130   char dummy;   // used to get a guess on initial stack address
5131 
5132   clock_tics_per_sec = sysconf(_SC_CLK_TCK);
5133 
5134   init_random(1234567);
5135 
5136   Linux::set_page_size(sysconf(_SC_PAGESIZE));
5137   if (Linux::page_size() == -1) {
5138     fatal(&quot;os_linux.cpp: os::init: sysconf failed (%s)&quot;,
5139           os::strerror(errno));
5140   }
5141   init_page_sizes((size_t) Linux::page_size());
5142 
5143   Linux::initialize_system_info();
5144 
5145   os::Linux::CPUPerfTicks pticks;
5146   bool res = os::Linux::get_tick_information(&amp;pticks, -1);
5147 
5148   if (res &amp;&amp; pticks.has_steal_ticks) {
5149     has_initial_tick_info = true;
5150     initial_total_ticks = pticks.total;
5151     initial_steal_ticks = pticks.steal;
5152   }
5153 
5154   // _main_thread points to the thread that created/loaded the JVM.
5155   Linux::_main_thread = pthread_self();
5156 
5157   // retrieve entry point for pthread_setname_np
5158   Linux::_pthread_setname_np =
5159     (int(*)(pthread_t, const char*))dlsym(RTLD_DEFAULT, &quot;pthread_setname_np&quot;);
5160 
<span class="line-added">5161   check_pax();</span>
<span class="line-added">5162 </span>
5163   os::Posix::init();
5164 
5165   initial_time_count = javaTimeNanos();
5166 
5167   // Always warn if no monotonic clock available
5168   if (!os::Posix::supports_monotonic_clock()) {
5169     warning(&quot;No monotonic clock was available - timed services may &quot;    \
5170             &quot;be adversely affected if the time-of-day clock changes&quot;);
5171   }
5172 }
5173 
5174 // To install functions for atexit system call
5175 extern &quot;C&quot; {
5176   static void perfMemory_exit_helper() {
5177     perfMemory_exit();
5178   }
5179 }
5180 
5181 void os::pd_init_container_support() {
5182   OSContainer::init();
</pre>
</td>
</tr>
</table>
<center><a href="../../../../make/test/JtregNativeJdk.gmk.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../share/gc/shared/genCollectedHeap.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
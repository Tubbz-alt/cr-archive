<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.hotspot.agent/linux/native/libsaproc/ps_core.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../java.desktop/unix/native/libawt_xawt/xawt/XToolkit.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="ps_proc.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.hotspot.agent/linux/native/libsaproc/ps_core.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
356             break;
357          }
358       }
359 
360       core_php++;
361    }
362 
363    free(phbuf);
364    return true;
365 err:
366    free(phbuf);
367    return false;
368 }
369 
370 // read segments of a shared object
371 static bool read_lib_segments(struct ps_prochandle* ph, int lib_fd, ELF_EHDR* lib_ehdr, uintptr_t lib_base) {
372   int i = 0;
373   ELF_PHDR* phbuf;
374   ELF_PHDR* lib_php = NULL;
375 




376   int page_size = sysconf(_SC_PAGE_SIZE);
377 
378   if ((phbuf = read_program_header_table(lib_fd, lib_ehdr)) == NULL) {
379     return false;
380   }
381 
382   // we want to process only PT_LOAD segments that are not writable.
383   // i.e., text segments. The read/write/exec (data) segments would
384   // have been already added from core file segments.
385   for (lib_php = phbuf, i = 0; i &lt; lib_ehdr-&gt;e_phnum; i++) {
386     if ((lib_php-&gt;p_type == PT_LOAD) &amp;&amp; !(lib_php-&gt;p_flags &amp; PF_W) &amp;&amp; (lib_php-&gt;p_filesz != 0)) {
387 
388       uintptr_t target_vaddr = lib_php-&gt;p_vaddr + lib_base;
389       map_info *existing_map = core_lookup(ph, target_vaddr);
390 
391       if (existing_map == NULL){
392         if (add_map_info(ph, lib_fd, lib_php-&gt;p_offset,
393                           target_vaddr, lib_php-&gt;p_memsz) == NULL) {
394           goto err;
395         }
396       } else {
397         // Coredump stores value of p_memsz elf field
398         // rounded up to page boundary.
<span class="line-modified">399 </span>
<span class="line-modified">400         if ((existing_map-&gt;memsz != page_size) &amp;&amp;</span>
401             (existing_map-&gt;fd != lib_fd) &amp;&amp;
402             (ROUNDUP(existing_map-&gt;memsz, page_size) != ROUNDUP(lib_php-&gt;p_memsz, page_size))) {
403 
404           print_debug(&quot;address conflict @ 0x%lx (existing map size = %ld, size = %ld, flags = %d)\n&quot;,
405                         target_vaddr, existing_map-&gt;memsz, lib_php-&gt;p_memsz, lib_php-&gt;p_flags);
406           goto err;
407         }
408 
409         /* replace PT_LOAD segment with library segment */
410         print_debug(&quot;overwrote with new address mapping (memsz %ld -&gt; %ld)\n&quot;,
411                      existing_map-&gt;memsz, ROUNDUP(lib_php-&gt;p_memsz, page_size));
412 
413         existing_map-&gt;fd = lib_fd;
414         existing_map-&gt;offset = lib_php-&gt;p_offset;
415         existing_map-&gt;memsz = ROUNDUP(lib_php-&gt;p_memsz, page_size);
416       }
417     }
418 
419     lib_php++;
420   }
</pre>
</td>
<td>
<hr />
<pre>
356             break;
357          }
358       }
359 
360       core_php++;
361    }
362 
363    free(phbuf);
364    return true;
365 err:
366    free(phbuf);
367    return false;
368 }
369 
370 // read segments of a shared object
371 static bool read_lib_segments(struct ps_prochandle* ph, int lib_fd, ELF_EHDR* lib_ehdr, uintptr_t lib_base) {
372   int i = 0;
373   ELF_PHDR* phbuf;
374   ELF_PHDR* lib_php = NULL;
375 
<span class="line-added">376 #ifndef LIBC</span>
<span class="line-added">377 #error &quot;LIBC not set&quot;</span>
<span class="line-added">378 #endif</span>
<span class="line-added">379 </span>
380   int page_size = sysconf(_SC_PAGE_SIZE);
381 
382   if ((phbuf = read_program_header_table(lib_fd, lib_ehdr)) == NULL) {
383     return false;
384   }
385 
386   // we want to process only PT_LOAD segments that are not writable.
387   // i.e., text segments. The read/write/exec (data) segments would
388   // have been already added from core file segments.
389   for (lib_php = phbuf, i = 0; i &lt; lib_ehdr-&gt;e_phnum; i++) {
390     if ((lib_php-&gt;p_type == PT_LOAD) &amp;&amp; !(lib_php-&gt;p_flags &amp; PF_W) &amp;&amp; (lib_php-&gt;p_filesz != 0)) {
391 
392       uintptr_t target_vaddr = lib_php-&gt;p_vaddr + lib_base;
393       map_info *existing_map = core_lookup(ph, target_vaddr);
394 
395       if (existing_map == NULL){
396         if (add_map_info(ph, lib_fd, lib_php-&gt;p_offset,
397                           target_vaddr, lib_php-&gt;p_memsz) == NULL) {
398           goto err;
399         }
400       } else {
401         // Coredump stores value of p_memsz elf field
402         // rounded up to page boundary.
<span class="line-modified">403         if ((strcmp(LIBC, &quot;musl&quot;)) &amp;&amp;</span>
<span class="line-modified">404             (existing_map-&gt;memsz != page_size) &amp;&amp;</span>
405             (existing_map-&gt;fd != lib_fd) &amp;&amp;
406             (ROUNDUP(existing_map-&gt;memsz, page_size) != ROUNDUP(lib_php-&gt;p_memsz, page_size))) {
407 
408           print_debug(&quot;address conflict @ 0x%lx (existing map size = %ld, size = %ld, flags = %d)\n&quot;,
409                         target_vaddr, existing_map-&gt;memsz, lib_php-&gt;p_memsz, lib_php-&gt;p_flags);
410           goto err;
411         }
412 
413         /* replace PT_LOAD segment with library segment */
414         print_debug(&quot;overwrote with new address mapping (memsz %ld -&gt; %ld)\n&quot;,
415                      existing_map-&gt;memsz, ROUNDUP(lib_php-&gt;p_memsz, page_size));
416 
417         existing_map-&gt;fd = lib_fd;
418         existing_map-&gt;offset = lib_php-&gt;p_offset;
419         existing_map-&gt;memsz = ROUNDUP(lib_php-&gt;p_memsz, page_size);
420       }
421     }
422 
423     lib_php++;
424   }
</pre>
</td>
</tr>
</table>
<center><a href="../../../../java.desktop/unix/native/libawt_xawt/xawt/XToolkit.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="ps_proc.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
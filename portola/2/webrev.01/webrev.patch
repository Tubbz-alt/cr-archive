diff a/.jcheck/conf b/.jcheck/conf
--- a/.jcheck/conf
+++ b/.jcheck/conf
@@ -1,2 +1,37 @@
-project=jdk
-bugids=dup
+;
+; Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+; DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+;
+; This code is free software; you can redistribute it and/or modify it
+; under the terms of the GNU General Public License version 2 only, as
+; published by the Free Software Foundation.
+;
+; This code is distributed in the hope that it will be useful, but WITHOUT
+; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+; version 2 for more details (a copy is included in the LICENSE file that
+; accompanied this code).
+;
+; You should have received a copy of the GNU General Public License version
+; 2 along with this work; if not, write to the Free Software Foundation,
+; Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+;
+; Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+; or visit www.oracle.com if you need additional information or have any
+; questions.
+;
+
+[general]
+project=portola
+repository=portola
+jbs=JDK
+
+[checks]
+error=author,committer,whitespace,executable
+
+[census]
+version=0
+domain=openjdk.org
+
+[checks "whitespace"]
+files=.*\.java$|.*\.cpp$|.*\.hpp$|.*\.c$|.*\.h$
diff a/make/ReleaseFile.gmk b/make/ReleaseFile.gmk
--- a/make/ReleaseFile.gmk
+++ b/make/ReleaseFile.gmk
@@ -51,10 +51,11 @@
   $(if $(VENDOR_VERSION_STRING), \
     $(call info-file-item, "IMPLEMENTOR_VERSION", "$(VENDOR_VERSION_STRING)"))
   $(call info-file-item, "JAVA_VERSION_DATE", "$(VERSION_DATE)")
   $(call info-file-item, "OS_NAME", "$(RELEASE_FILE_OS_NAME)")
   $(call info-file-item, "OS_ARCH", "$(RELEASE_FILE_OS_ARCH)")
+  $(call info-file-item, "LIBC", "$(OPENJDK_TARGET_LIBC)")
 endef
 
 # Param 1 - The file containing the MODULES list
 define prepare-info-file
   $(call LogInfo, Generating $(patsubst $(OUTPUTDIR)/%,%,$@))
diff a/make/autoconf/build-aux/config.guess b/make/autoconf/build-aux/config.guess
--- a/make/autoconf/build-aux/config.guess
+++ b/make/autoconf/build-aux/config.guess
@@ -28,10 +28,21 @@
 # and fix the broken property, if needed.
 
 DIR=`dirname $0`
 OUT=`. $DIR/autoconf-config.guess`
 
+# config.guess doesn't identify systems running the musl C library, and will
+# instead return a string with a -gnu suffix. This block detects musl and
+# modifies the string to have a -musl suffix instead. 
+echo $OUT | grep -- -linux- > /dev/null 2> /dev/null
+if test $? = 0; then
+  ldd_version=`ldd --version 2>&1 | head -1 | cut -f1 -d' '`
+  if [ x"${ldd_version}" = x"musl" ]; then
+    OUT=`echo $OUT | sed 's/-gnu/-musl/'`
+  fi
+fi
+
 # Test and fix solaris on x86_64
 echo $OUT | grep i386-pc-solaris > /dev/null 2> /dev/null
 if test $? = 0; then
   # isainfo -n returns either i386 or amd64
   REAL_CPU=`isainfo -n`
diff a/make/autoconf/build-aux/config.sub b/make/autoconf/build-aux/config.sub
--- a/make/autoconf/build-aux/config.sub
+++ b/make/autoconf/build-aux/config.sub
@@ -27,10 +27,15 @@
 # autoconf system (which might easily get lost in a future update), we
 # wrap it and fix the broken property, if needed.
 
 DIR=`dirname $0`
 
+if [ "$1"x = "x86_64-unknown-linux-musl"x ]; then
+    echo $1
+    exit
+fi
+
 # Allow wsl
 if echo $* | grep x86_64-pc-wsl >/dev/null ; then
     echo $*
     exit
 fi
diff a/make/autoconf/buildjdk-spec.gmk.in b/make/autoconf/buildjdk-spec.gmk.in
--- a/make/autoconf/buildjdk-spec.gmk.in
+++ b/make/autoconf/buildjdk-spec.gmk.in
@@ -52,22 +52,25 @@
 JDK_OUTPUTDIR := $(patsubst $(OUTPUTDIR)%,$(BUILDJDK_OUTPUTDIR)%,$(JDK_OUTPUTDIR))
 IMAGES_OUTPUTDIR := $(patsubst $(OUTPUTDIR)%,$(BUILDJDK_OUTPUTDIR)%,$(IMAGES_OUTPUTDIR))
 
 OPENJDK_BUILD_CPU_LEGACY := @OPENJDK_BUILD_CPU_LEGACY@
 OPENJDK_BUILD_CPU_LEGACY_LIB := @OPENJDK_BUILD_CPU_LEGACY_LIB@
+OPENJDK_BUILD_LIBC := @OPENJDK_BUILD_LIBC@
 OPENJDK_TARGET_CPU := @OPENJDK_BUILD_CPU@
 OPENJDK_TARGET_CPU_ARCH := @OPENJDK_BUILD_CPU_ARCH@
 OPENJDK_TARGET_CPU_BITS := @OPENJDK_BUILD_CPU_BITS@
 OPENJDK_TARGET_CPU_ENDIAN := @OPENJDK_BUILD_CPU_ENDIAN@
 OPENJDK_TARGET_CPU_LEGACY := @OPENJDK_BUILD_CPU_LEGACY@
+OPENJDK_TARGET_LIBC := @OPENJDK_BUILD_LIBC@
 OPENJDK_TARGET_OS_INCLUDE_SUBDIR := @OPENJDK_BUILD_OS_INCLUDE_SUBDIR@
 
 HOTSPOT_TARGET_OS := @HOTSPOT_BUILD_OS@
 HOTSPOT_TARGET_OS_TYPE := @HOTSPOT_BUILD_OS_TYPE@
 HOTSPOT_TARGET_CPU := @HOTSPOT_BUILD_CPU@
 HOTSPOT_TARGET_CPU_ARCH := @HOTSPOT_BUILD_CPU_ARCH@
 HOTSPOT_TARGET_CPU_DEFINE := @HOTSPOT_BUILD_CPU_DEFINE@
+HOTSPOT_TARGET_LIBC := @HOTSPOT_BUILD_LIBC@
 
 CFLAGS_JDKLIB := @OPENJDK_BUILD_CFLAGS_JDKLIB@
 CXXFLAGS_JDKLIB := @OPENJDK_BUILD_CXXFLAGS_JDKLIB@
 LDFLAGS_JDKLIB := @OPENJDK_BUILD_LDFLAGS_JDKLIB@
 CFLAGS_JDKEXE := @OPENJDK_BUILD_CFLAGS_JDKEXE@
diff a/make/autoconf/platform.m4 b/make/autoconf/platform.m4
--- a/make/autoconf/platform.m4
+++ b/make/autoconf/platform.m4
@@ -202,10 +202,22 @@
       ;;
     *)
       AC_MSG_ERROR([unsupported operating system $1])
       ;;
   esac
+
+  case "$1" in
+    *linux*-musl)
+      VAR_LIBC=musl
+      ;;
+    *linux*-gnu)
+      VAR_LIBC=gnu
+      ;;
+    *)
+      VAR_LIBC=default
+      ;;
+  esac
 ])
 
 # Expects $host_os $host_cpu $build_os and $build_cpu
 # and $with_target_bits to have been setup!
 #
@@ -240,21 +252,28 @@
   fi
   OPENJDK_BUILD_CPU="$VAR_CPU"
   OPENJDK_BUILD_CPU_ARCH="$VAR_CPU_ARCH"
   OPENJDK_BUILD_CPU_BITS="$VAR_CPU_BITS"
   OPENJDK_BUILD_CPU_ENDIAN="$VAR_CPU_ENDIAN"
+  OPENJDK_BUILD_LIBC="$VAR_LIBC"
   AC_SUBST(OPENJDK_BUILD_OS)
   AC_SUBST(OPENJDK_BUILD_OS_TYPE)
   AC_SUBST(OPENJDK_BUILD_OS_ENV)
   AC_SUBST(OPENJDK_BUILD_CPU)
   AC_SUBST(OPENJDK_BUILD_CPU_ARCH)
   AC_SUBST(OPENJDK_BUILD_CPU_BITS)
   AC_SUBST(OPENJDK_BUILD_CPU_ENDIAN)
+  AC_SUBST(OPENJDK_BUILD_LIBC)
 
   AC_MSG_CHECKING([openjdk-build os-cpu])
   AC_MSG_RESULT([$OPENJDK_BUILD_OS-$OPENJDK_BUILD_CPU])
 
+  if test "x$OPENJDK_BUILD_OS" = "xlinux"; then
+    AC_MSG_CHECKING([openjdk-build C library])
+    AC_MSG_RESULT([$OPENJDK_BUILD_LIBC])
+  fi
+
   # Convert the autoconf OS/CPU value to our own data, into the VAR_OS/CPU variables.
   PLATFORM_EXTRACT_VARS_FROM_OS($host_os)
   PLATFORM_EXTRACT_VARS_FROM_CPU($host_cpu)
   # ... and setup our own variables. (Do this explicitly to facilitate searching)
   OPENJDK_TARGET_OS="$VAR_OS"
@@ -271,22 +290,29 @@
   OPENJDK_TARGET_CPU="$VAR_CPU"
   OPENJDK_TARGET_CPU_ARCH="$VAR_CPU_ARCH"
   OPENJDK_TARGET_CPU_BITS="$VAR_CPU_BITS"
   OPENJDK_TARGET_CPU_ENDIAN="$VAR_CPU_ENDIAN"
   OPENJDK_TARGET_OS_UPPERCASE=`$ECHO $OPENJDK_TARGET_OS | $TR 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
+  OPENJDK_TARGET_LIBC="$VAR_LIBC"
 
   AC_SUBST(OPENJDK_TARGET_OS)
   AC_SUBST(OPENJDK_TARGET_OS_TYPE)
   AC_SUBST(OPENJDK_TARGET_OS_ENV)
   AC_SUBST(OPENJDK_TARGET_OS_UPPERCASE)
   AC_SUBST(OPENJDK_TARGET_CPU)
   AC_SUBST(OPENJDK_TARGET_CPU_ARCH)
   AC_SUBST(OPENJDK_TARGET_CPU_BITS)
   AC_SUBST(OPENJDK_TARGET_CPU_ENDIAN)
+  AC_SUBST(OPENJDK_TARGET_LIBC)
 
   AC_MSG_CHECKING([openjdk-target os-cpu])
   AC_MSG_RESULT([$OPENJDK_TARGET_OS-$OPENJDK_TARGET_CPU])
+
+  if test "x$OPENJDK_TARGET_OS" = "xlinux"; then
+    AC_MSG_CHECKING([openjdk-target C library])
+    AC_MSG_RESULT([$OPENJDK_TARGET_LIBC])
+  fi
 ])
 
 # Check if a reduced build (32-bit on 64-bit platforms) is requested, and modify behaviour
 # accordingly. Must be done after setting up build and target system, but before
 # doing anything else with these values.
@@ -417,11 +443,17 @@
   if test "x$OPENJDK_$1_CPU" = xx86_64; then
     OPENJDK_$1_CPU_BUNDLE="x64"
   else
     OPENJDK_$1_CPU_BUNDLE="$OPENJDK_$1_CPU"
   fi
-  OPENJDK_$1_BUNDLE_PLATFORM="${OPENJDK_$1_OS_BUNDLE}-${OPENJDK_$1_CPU_BUNDLE}"
+
+  OPENJDK_$1_LIBC_BUNDLE=""
+  if test "x$OPENJDK_$1_LIBC" = "xmusl"; then  
+    OPENJDK_$1_LIBC_BUNDLE="-$OPENJDK_$1_LIBC"
+  fi
+
+  OPENJDK_$1_BUNDLE_PLATFORM="${OPENJDK_$1_OS_BUNDLE}-${OPENJDK_$1_CPU_BUNDLE}${OPENJDK_$1_LIBC_BUNDLE}"
   AC_SUBST(OPENJDK_$1_BUNDLE_PLATFORM)
 
   if test "x$COMPILE_TYPE" = "xcross"; then
     # FIXME: ... or should this include reduced builds..?
     DEFINE_CROSS_COMPILE_ARCH="CROSS_COMPILE_ARCH:=$OPENJDK_$1_CPU_LEGACY"
@@ -488,10 +520,17 @@
   elif test "x$OPENJDK_$1_CPU" != x; then
     HOTSPOT_$1_CPU_DEFINE=$(echo $OPENJDK_$1_CPU | tr a-z A-Z)
   fi
   AC_SUBST(HOTSPOT_$1_CPU_DEFINE)
 
+  if test "x$OPENJDK_$1_LIBC" = "xmusl"; then
+    HOTSPOT_$1_LIBC=$OPENJDK_$1_LIBC
+  else
+    HOTSPOT_$1_LIBC=""
+  fi
+  AC_SUBST(HOTSPOT_$1_LIBC)
+
   # For historical reasons, the OS include directories have odd names.
   OPENJDK_$1_OS_INCLUDE_SUBDIR="$OPENJDK_TARGET_OS"
   if test "x$OPENJDK_TARGET_OS" = "xwindows"; then
     OPENJDK_$1_OS_INCLUDE_SUBDIR="win32"
   elif test "x$OPENJDK_TARGET_OS" = "xmacosx"; then
diff a/make/autoconf/spec.gmk.in b/make/autoconf/spec.gmk.in
--- a/make/autoconf/spec.gmk.in
+++ b/make/autoconf/spec.gmk.in
@@ -78,10 +78,12 @@
 OPENJDK_TARGET_CPU:=@OPENJDK_TARGET_CPU@
 OPENJDK_TARGET_CPU_ARCH:=@OPENJDK_TARGET_CPU_ARCH@
 OPENJDK_TARGET_CPU_BITS:=@OPENJDK_TARGET_CPU_BITS@
 OPENJDK_TARGET_CPU_ENDIAN:=@OPENJDK_TARGET_CPU_ENDIAN@
 
+OPENJDK_TARGET_LIBC:=@OPENJDK_TARGET_LIBC@
+
 COMPILE_TYPE:=@COMPILE_TYPE@
 
 # Legacy support
 OPENJDK_TARGET_CPU_ISADIR:=@OPENJDK_TARGET_CPU_ISADIR@
 OPENJDK_TARGET_CPU_LEGACY:=@OPENJDK_TARGET_CPU_LEGACY@
@@ -94,10 +96,12 @@
 
 HOTSPOT_TARGET_CPU := @HOTSPOT_TARGET_CPU@
 HOTSPOT_TARGET_CPU_ARCH := @HOTSPOT_TARGET_CPU_ARCH@
 HOTSPOT_TARGET_CPU_DEFINE := @HOTSPOT_TARGET_CPU_DEFINE@
 
+HOTSPOT_TARGET_LIBC := @HOTSPOT_TARGET_LIBC@
+
 OPENJDK_TARGET_BUNDLE_PLATFORM:=@OPENJDK_TARGET_BUNDLE_PLATFORM@
 JDK_ARCH_ABI_PROP_NAME := @JDK_ARCH_ABI_PROP_NAME@
 
 # We are building on this build system.
 # When not cross-compiling, it is the same as the target.
@@ -108,10 +112,12 @@
 OPENJDK_BUILD_CPU:=@OPENJDK_BUILD_CPU@
 OPENJDK_BUILD_CPU_ARCH:=@OPENJDK_BUILD_CPU_ARCH@
 OPENJDK_BUILD_CPU_BITS:=@OPENJDK_BUILD_CPU_BITS@
 OPENJDK_BUILD_CPU_ENDIAN:=@OPENJDK_BUILD_CPU_ENDIAN@
 
+OPENJDK_BUILD_LIBC:=@OPENJDK_BUILD_LIBC@
+
 OPENJDK_BUILD_OS_INCLUDE_SUBDIR:=@OPENJDK_TARGET_OS_INCLUDE_SUBDIR@
 
 # Target platform value in ModuleTarget class file attribute.
 OPENJDK_MODULE_TARGET_PLATFORM:=@OPENJDK_MODULE_TARGET_PLATFORM@
 
@@ -866,10 +872,11 @@
 #
 # Misc
 #
 
 INCLUDE_SA=@INCLUDE_SA@
+INCLUDE_SA_ATTACH=@INCLUDE_SA_ATTACH@
 INCLUDE_GRAAL=@INCLUDE_GRAAL@
 INCLUDE_JVMCI=@INCLUDE_JVMCI@
 
 OS_VERSION_MAJOR:=@OS_VERSION_MAJOR@
 OS_VERSION_MINOR:=@OS_VERSION_MINOR@
diff a/make/conf/jib-profiles.js b/make/conf/jib-profiles.js
--- a/make/conf/jib-profiles.js
+++ b/make/conf/jib-profiles.js
@@ -56,12 +56,14 @@
  *
  * input.profile
  * input.build_id
  * input.target_os
  * input.target_cpu
+ * input.target_libc
  * input.build_os
  * input.build_cpu
+ * input.build_libc
  * input.target_platform
  * input.build_platform
  * // The build_osenv_* variables describe the unix layer on Windows systems,
  * // i.e. Cygwin, which may also be 32 or 64 bit.
  * input.build_osenv
@@ -98,17 +100,21 @@
  *     <profile-name>: {
  *       // Name of os the profile is built to run on
  *       target_os; <string>
  *       // Name of cpu the profile is built to run on
  *       target_cpu; <string>
- *       // Combination of target_os and target_cpu for convenience
+ *       // Optional libc string if non standard
+ *       target_libc; <string>
+ *       // Optional combination of target_os and target_cpu for convenience
  *       target_platform; <string>
  *       // Name of os the profile is built on
  *       build_os; <string>
  *       // Name of cpu the profile is built on
  *       build_cpu; <string>
- *       // Combination of build_os and build_cpu for convenience
+ *       // Optional libc string if non standard
+ *       build_libc; <string>
+ *       // Optional combination of build_os and build_cpu for convenience
  *       build_platform; <string>
  *
  *       // List of dependencies needed to build this profile
  *       dependencies: <Array of strings>
  *
@@ -190,11 +196,11 @@
     //     dir just like default configure_args and environment_path variables.
     data.format_version = "1.3";
 
     // Organization, product and version are used when uploading/publishing build results
     data.organization = "";
-    data.product = "jdk";
+    data.product = "jdk-portola";
     data.version = getVersion();
 
     // The base directory for the build output. JIB will assume that the
     // actual build directory will be <output_basedir>/<configuration>
     data.output_basedir = "build";
@@ -237,11 +243,11 @@
     common.build_id = getBuildId(input);
     common.build_number = input.build_number != null ? input.build_number : "0";
 
     // List of the main profile names used for iteration
     common.main_profile_names = [
-        "linux-x64", "linux-x86", "macosx-x64", "solaris-x64",
+        "linux-x64", "linux-x64-musl", "linux-x86", "macosx-x64", "solaris-x64",
         "solaris-sparcv9", "windows-x64", "windows-x86",
         "linux-aarch64", "linux-arm32", "linux-ppc64le", "linux-s390x"
     ];
 
     // These are the base setttings for all the main build profiles.
@@ -410,10 +416,18 @@
                 (isWsl(input) ? [ "--host=x86_64-unknown-linux-gnu",
                     "--build=x86_64-unknown-linux-gnu" ] : [])),
             default_make_targets: ["docs-bundles"],
         },
 
+        "linux-x64-musl": {
+            target_os: "linux",
+            target_cpu: "x64",
+            target_libc: "musl",
+            configure_args: concat(common.configure_args_64bit,
+                "--with-zlib=system"),
+        },
+
         "linux-x86": {
             target_os: "linux",
             target_cpu: "x86",
             build_cpu: "x64",
             dependencies: ["devkit"],
@@ -645,10 +659,14 @@
     // tar.gz.
     var artifactData = {
         "linux-x64": {
             platform: "linux-x64",
         },
+        "linux-x64-musl": {
+            platform: "linux-x64-musl",
+            demo_ext: "tar.gz"
+        },
         "linux-x86": {
             platform: "linux-x86",
         },
         "macosx-x64": {
             platform: "osx-x64",
@@ -988,11 +1006,12 @@
        && input.build_platform != devkit_platform) {
         devkit_cross_prefix = input.build_platform + "-to-";
     }
 
     var boot_jdk_platform = (input.build_os == "macosx" ? "osx" : input.build_os)
-        + "-" + input.build_cpu;
+        + "-" + input.build_cpu +
+        (input.build_libc ? "-" + input.build_libc : "");
     var boot_jdk_ext = (input.build_os == "windows" ? ".zip" : ".tar.gz")
     // If running in WSL and building for Windows, it will look like Linux,
     // but we need a Windows boot JDK.
     if (isWsl(input) && input.target_os == "windows") {
         boot_jdk_platform = "windows-" + input.build_cpu;
@@ -1013,11 +1032,11 @@
             environment_path: common.boot_jdk_home + "/bin"
 	}
     } else {
 	boot_jdk = {
             server: "jpg",
-            product: "jdk",
+            product: input.build_libc == "musl" ? "jdk-portola" : "jdk",
             version: common.boot_jdk_version,
             build_number: common.boot_jdk_build_number,
             file: "bundles/" + boot_jdk_platform + "/jdk-" + common.boot_jdk_version + "_"
                 + boot_jdk_platform + "_bin" + boot_jdk_ext,
             configure_args: "--with-boot-jdk=" + common.boot_jdk_home,
diff a/make/hotspot/lib/CompileJvm.gmk b/make/hotspot/lib/CompileJvm.gmk
--- a/make/hotspot/lib/CompileJvm.gmk
+++ b/make/hotspot/lib/CompileJvm.gmk
@@ -64,17 +64,22 @@
   OPENJDK_TARGET_CPU_VM_VERSION := sparc
 else
   OPENJDK_TARGET_CPU_VM_VERSION := $(OPENJDK_TARGET_CPU)
 endif
 
+ifneq ($(HOTSPOT_TARGET_LIBC),)
+  LIBC_DEFINE := -DHOTSPOT_LIBC='"$(HOTSPOT_TARGET_LIBC)"'
+endif
+
 CFLAGS_VM_VERSION := \
     $(VERSION_CFLAGS) \
     -DHOTSPOT_VERSION_STRING='"$(VERSION_STRING)"' \
     -DDEBUG_LEVEL='"$(DEBUG_LEVEL)"' \
     -DHOTSPOT_BUILD_USER='"$(USERNAME)"' \
     -DHOTSPOT_VM_DISTRO='"$(HOTSPOT_VM_DISTRO)"' \
     -DCPU='"$(OPENJDK_TARGET_CPU_VM_VERSION)"' \
+    $(LIBC_DEFINE) \
     #
 
 ################################################################################
 # Disabled warnings
 
diff a/make/hotspot/lib/JvmFlags.gmk b/make/hotspot/lib/JvmFlags.gmk
--- a/make/hotspot/lib/JvmFlags.gmk
+++ b/make/hotspot/lib/JvmFlags.gmk
@@ -64,10 +64,14 @@
     -DTARGET_COMPILER_$(HOTSPOT_TOOLCHAIN_TYPE) \
     -D$(HOTSPOT_TARGET_CPU_DEFINE) \
     -DHOTSPOT_LIB_ARCH='"$(OPENJDK_TARGET_CPU_LEGACY_LIB)"' \
     #
 
+ifneq ($(HOTSPOT_TARGET_LIBC),)
+  JVM_CFLAGS_TARGET_DEFINES += -DHOTSPOT_LIBC='"$(HOTSPOT_TARGET_LIBC)"'
+endif
+
 ifeq ($(DEBUG_LEVEL), release)
   # For hotspot, release builds differ internally between "optimized" and "product"
   # in that "optimize" does not define PRODUCT.
   ifneq ($(HOTSPOT_DEBUG_LEVEL), optimized)
     JVM_CFLAGS_DEBUGLEVEL := -DPRODUCT
diff a/make/lib/CoreLibraries.gmk b/make/lib/CoreLibraries.gmk
--- a/make/lib/CoreLibraries.gmk
+++ b/make/lib/CoreLibraries.gmk
@@ -187,10 +187,12 @@
   ifneq ($(MSVCP_DLL), )
     LIBJLI_CFLAGS += -DMSVCP_DLL_NAME='"$(notdir $(MSVCP_DLL))"'
   endif
 endif
 
+LIBJLI_CFLAGS += -DLIBC=\"$(OPENJDK_TARGET_LIBC)\"
+
 LIBJLI_CFLAGS += $(LIBZ_CFLAGS)
 
 ifneq ($(USE_EXTERNAL_LIBZ), true)
   LIBJLI_EXTRA_FILES += \
       $(addprefix $(TOPDIR)/src/java.base/share/native/libzip/zlib/, \
diff a/make/lib/Lib-jdk.hotspot.agent.gmk b/make/lib/Lib-jdk.hotspot.agent.gmk
--- a/make/lib/Lib-jdk.hotspot.agent.gmk
+++ b/make/lib/Lib-jdk.hotspot.agent.gmk
@@ -51,10 +51,12 @@
       SA_CXXFLAGS := -RTC1
     endif
   endif
 endif
 
+SA_CFLAGS += -DLIBC=\"$(OPENJDK_TARGET_LIBC)\"
+
 SA_TOOLCHAIN := $(TOOLCHAIN_DEFAULT)
 ifeq ($(call isTargetOs, linux), true)
   SA_TOOLCHAIN := TOOLCHAIN_LINK_CXX
 endif
 
diff a/make/lib/Lib-jdk.jdwp.agent.gmk b/make/lib/Lib-jdk.jdwp.agent.gmk
--- a/make/lib/Lib-jdk.jdwp.agent.gmk
+++ b/make/lib/Lib-jdk.jdwp.agent.gmk
@@ -29,10 +29,11 @@
 
 $(eval $(call SetupJdkLibrary, BUILD_LIBDT_SOCKET, \
     NAME := dt_socket, \
     OPTIMIZATION := LOW, \
     CFLAGS := $(CFLAGS_JDKLIB) $(LIBDT_SOCKET_CPPFLAGS), \
+    DISABLED_WARNINGS_gcc := stringop-truncation, \
     EXTRA_HEADER_DIRS := \
         include \
         libjdwp/export, \
     LDFLAGS := $(LDFLAGS_JDKLIB) \
         $(call SET_SHARED_LIBRARY_ORIGIN), \
diff a/make/test/JtregNativeJdk.gmk b/make/test/JtregNativeJdk.gmk
--- a/make/test/JtregNativeJdk.gmk
+++ b/make/test/JtregNativeJdk.gmk
@@ -91,10 +91,15 @@
   # stripping during the test libraries' build.
   BUILD_JDK_JTREG_LIBRARIES_CFLAGS_libFib := -g
   BUILD_JDK_JTREG_LIBRARIES_STRIP_SYMBOLS_libFib := false
 endif
 
+ifeq ($(OPENJDK_TARGET_LIBC), musl)
+  # 'strncpy' output truncated before terminating nul copying as many bytes from a string as its length
+  BUILD_JDK_JTREG_LIBRARIES_CFLAGS_libInheritedChannel := -Wno-stringop-truncation -Wno-stringop-overflow
+endif
+
 # This evaluation is expensive and should only be done if this target was
 # explicitly called.
 ifneq ($(filter build-test-jdk-jtreg-native, $(MAKECMDGOALS)), )
   $(eval $(call SetupTestFilesCompilation, BUILD_JDK_JTREG_LIBRARIES, \
       TYPE := LIBRARY, \
diff a/src/hotspot/os/linux/os_linux.cpp b/src/hotspot/os/linux/os_linux.cpp
--- a/src/hotspot/os/linux/os_linux.cpp
+++ b/src/hotspot/os/linux/os_linux.cpp
@@ -101,11 +101,10 @@
 # include <poll.h>
 # include <fcntl.h>
 # include <string.h>
 # include <syscall.h>
 # include <sys/sysinfo.h>
-# include <gnu/libc-version.h>
 # include <sys/ipc.h>
 # include <sys/shm.h>
 # include <link.h>
 # include <stdint.h>
 # include <inttypes.h>
@@ -149,12 +148,12 @@
 int (*os::Linux::_pthread_getcpuclockid)(pthread_t, clockid_t *) = NULL;
 int (*os::Linux::_pthread_setname_np)(pthread_t, const char*) = NULL;
 pthread_t os::Linux::_main_thread;
 int os::Linux::_page_size = -1;
 bool os::Linux::_supports_fast_thread_cpu_time = false;
-const char * os::Linux::_glibc_version = NULL;
-const char * os::Linux::_libpthread_version = NULL;
+const char * os::Linux::_glibc_version = "unknown";
+const char * os::Linux::_libpthread_version = "unknown";
 
 static jlong initial_time_count=0;
 
 static int clock_tics_per_sec = 100;
 
@@ -602,21 +601,25 @@
 #if !defined(_CS_GNU_LIBC_VERSION) || \
     !defined(_CS_GNU_LIBPTHREAD_VERSION)
   #error "glibc too old (< 2.3.2)"
 #endif
 
-  size_t n = confstr(_CS_GNU_LIBC_VERSION, NULL, 0);
-  assert(n > 0, "cannot retrieve glibc version");
-  char *str = (char *)malloc(n, mtInternal);
-  confstr(_CS_GNU_LIBC_VERSION, str, n);
-  os::Linux::set_glibc_version(str);
+  size_t n;
+
+  n = confstr(_CS_GNU_LIBC_VERSION, NULL, 0);
+  if (n > 0) {
+    char* str = (char *)malloc(n, mtInternal);
+    confstr(_CS_GNU_LIBC_VERSION, str, n);
+    os::Linux::set_glibc_version(str);
+  }
 
   n = confstr(_CS_GNU_LIBPTHREAD_VERSION, NULL, 0);
-  assert(n > 0, "cannot retrieve pthread version");
-  str = (char *)malloc(n, mtInternal);
-  confstr(_CS_GNU_LIBPTHREAD_VERSION, str, n);
-  os::Linux::set_libpthread_version(str);
+  if (n > 0) {
+    char* str = (char *)malloc(n, mtInternal);
+    confstr(_CS_GNU_LIBPTHREAD_VERSION, str, n);
+    os::Linux::set_libpthread_version(str);
+  }
 }
 
 /////////////////////////////////////////////////////////////////////////////
 // thread stack expansion
 
@@ -3115,24 +3118,40 @@
 
 // Something to do with the numa-aware allocator needs these symbols
 extern "C" JNIEXPORT void numa_warn(int number, char *where, ...) { }
 extern "C" JNIEXPORT void numa_error(char *where) { }
 
+static void* dlvsym_if_available(void* handle, const char* name, const char* version) {
+  typedef void* (*dlvsym_func_type)(void* handle, const char* name, const char* version);
+  static dlvsym_func_type dlvsym_func;
+  static bool initialized = false;
+
+  if (!initialized) {
+    dlvsym_func = (dlvsym_func_type)dlsym(RTLD_NEXT, "dlvsym");
+    initialized = true;
+  }
+
+  if (dlvsym_func != NULL) {
+    void *f = dlvsym_func(handle, name, version);
+    if (f != NULL) {
+      return f;
+    }
+  }
+
+  return dlsym(handle, name);
+}
+
 // Handle request to load libnuma symbol version 1.1 (API v1). If it fails
 // load symbol from base version instead.
 void* os::Linux::libnuma_dlsym(void* handle, const char *name) {
-  void *f = dlvsym(handle, name, "libnuma_1.1");
-  if (f == NULL) {
-    f = dlsym(handle, name);
-  }
-  return f;
+  return dlvsym_if_available(handle, name, "libnuma_1.1");
 }
 
 // Handle request to load libnuma symbol version 1.2 (API v2) only.
 // Return NULL if the symbol is not defined in this particular version.
 void* os::Linux::libnuma_v2_dlsym(void* handle, const char* name) {
-  return dlvsym(handle, name, "libnuma_1.2");
+  return dlvsym_if_available(handle, name, "libnuma_1.2");
 }
 
 bool os::Linux::libnuma_init() {
   if (sched_getcpu() != -1) { // Requires sched_getcpu() support
     void *handle = dlopen("libnuma.so.1", RTLD_LAZY);
@@ -5047,10 +5066,67 @@
 }
 
 extern void report_error(char* file_name, int line_no, char* title,
                          char* format, ...);
 
+// Some linux distributions (notably: Alpine Linux) include the
+// grsecurity in the kernel by default. Of particular interest from a
+// JVM perspective is PaX (https://pax.grsecurity.net/), which adds
+// some security features related to page attributes. Specifically,
+// the MPROTECT PaX functionality
+// (https://pax.grsecurity.net/docs/mprotect.txt) prevents dynamic
+// code generation by disallowing a (previously) writable page to be
+// marked as executable. This is, of course, exactly what HotSpot does
+// for both JIT compiled method, as well as for stubs, adapters, etc.
+//
+// Instead of crashing "lazily" when trying to make a page executable,
+// this code probes for the presence of PaX and reports the failure
+// eagerly.
+static void check_pax(void) {
+  // Zero doesn't generate code dynamically, so no need to perform the PaX check
+#ifndef ZERO
+  size_t size = os::Linux::page_size();
+
+  void* p = ::mmap(NULL, size, PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
+  if (p == MAP_FAILED) {
+    vm_exit_out_of_memory(size, OOM_MMAP_ERROR, "failed to allocate memory for PaX check.");
+  }
+
+  int res = ::mprotect(p, size, PROT_WRITE|PROT_EXEC);
+  if (res == -1) {
+    vm_exit_during_initialization("Failed to mark memory page as executable",
+                                  "Please check if grsecurity/PaX is enabled in your kernel.\n"
+                                  "\n"
+                                  "For example, you can do this by running (note: you may need root privileges):\n"
+                                  "\n"
+                                  "    sysctl kernel.pax.softmode\n"
+                                  "\n"
+                                  "If PaX is included in the kernel you will see something like this:\n"
+                                  "\n"
+                                  "    kernel.pax.softmode = 0\n"
+                                  "\n"
+                                  "In particular, if the value is 0 (zero), then PaX is enabled.\n"
+                                  "\n"
+                                  "PaX includes security functionality which interferes with the dynamic code\n"
+                                  "generation the JVM relies on. Specifically, the MPROTECT functionality as\n"
+                                  "described on https://pax.grsecurity.net/docs/mprotect.txt is not compatible\n"
+                                  "with the JVM. If you want to allow the JVM to run you will have to disable PaX.\n"
+                                  "You can do this on a per-executable basis using the paxctl tool, for example:\n"
+                                  "\n"
+                                  "    paxctl -cm bin/java\n"
+                                  "\n"
+                                  "Please note that this modifies the executable binary in-place, so you may want\n"
+                                  "to make a backup of it first. Also note that you have to repeat this for other\n"
+                                  "executables like javac, jar, jcmd, etc.\n"
+                                  );
+
+  }
+
+  ::munmap(p, size);
+#endif
+}
+
 // this is called _before_ most of the global arguments have been parsed
 void os::init(void) {
   char dummy;   // used to get a guess on initial stack address
 
   clock_tics_per_sec = sysconf(_SC_CLK_TCK);
@@ -5080,10 +5156,12 @@
 
   // retrieve entry point for pthread_setname_np
   Linux::_pthread_setname_np =
     (int(*)(pthread_t, const char*))dlsym(RTLD_DEFAULT, "pthread_setname_np");
 
+  check_pax();
+
   os::Posix::init();
 
   initial_time_count = javaTimeNanos();
 
   // Always warn if no monotonic clock available
diff a/src/hotspot/share/gc/shared/genCollectedHeap.cpp b/src/hotspot/share/gc/shared/genCollectedHeap.cpp
--- a/src/hotspot/share/gc/shared/genCollectedHeap.cpp
+++ b/src/hotspot/share/gc/shared/genCollectedHeap.cpp
@@ -1110,11 +1110,11 @@
 // Requires "*prev_ptr" to be non-NULL.  Deletes and a block of minimal size
 // from the list headed by "*prev_ptr".
 static ScratchBlock *removeSmallestScratch(ScratchBlock **prev_ptr) {
   bool first = true;
   size_t min_size = 0;   // "first" makes this conceptually infinite.
-  ScratchBlock **smallest_ptr, *smallest;
+  ScratchBlock **smallest_ptr = NULL, *smallest;
   ScratchBlock  *cur = *prev_ptr;
   while (cur) {
     assert(*prev_ptr == cur, "just checking");
     if (first || cur->num_words < min_size) {
       smallest_ptr = prev_ptr;
diff a/src/hotspot/share/runtime/abstract_vm_version.cpp b/src/hotspot/share/runtime/abstract_vm_version.cpp
--- a/src/hotspot/share/runtime/abstract_vm_version.cpp
+++ b/src/hotspot/share/runtime/abstract_vm_version.cpp
@@ -271,12 +271,18 @@
     #endif
   #else
     #define FLOAT_ARCH_STR XSTR(FLOAT_ARCH)
   #endif
 
-  #define INTERNAL_VERSION_SUFFIX VM_RELEASE ")" \
-         " for " OS "-" CPU FLOAT_ARCH_STR \
+  #ifdef HOTSPOT_LIBC
+    #define LIBC_STR "-" HOTSPOT_LIBC
+  #else
+    #define LIBC_STR ""
+  #endif
+
+  #define INTERNAL_VERSION_SUFFIX VM_RELEASE ")"      \
+         " for " OS "-" CPU FLOAT_ARCH_STR LIBC_STR \
          " JRE (" VERSION_STRING "), built on " __DATE__ " " __TIME__ \
          " by " XSTR(HOTSPOT_BUILD_USER) " with " HOTSPOT_BUILD_COMPILER
 
   return strcmp(DEBUG_LEVEL, "release") == 0
       ? VMNAME " (" INTERNAL_VERSION_SUFFIX
diff a/src/hotspot/share/utilities/globalDefinitions_gcc.hpp b/src/hotspot/share/utilities/globalDefinitions_gcc.hpp
--- a/src/hotspot/share/utilities/globalDefinitions_gcc.hpp
+++ b/src/hotspot/share/utilities/globalDefinitions_gcc.hpp
@@ -202,11 +202,11 @@
 #endif
 inline int g_isnan(double f) { return isnand(f); }
 #elif defined(__APPLE__)
 inline int g_isnan(double f) { return isnan(f); }
 #elif defined(LINUX) || defined(_ALLBSD_SOURCE)
-inline int g_isnan(float  f) { return isnanf(f); }
+inline int g_isnan(float  f) { return isnan(f); }
 inline int g_isnan(double f) { return isnan(f); }
 #else
 #error "missing platform-specific definition here"
 #endif
 
diff a/src/java.base/linux/native/libnet/linux_close.c b/src/java.base/linux/native/libnet/linux_close.c
--- a/src/java.base/linux/native/libnet/linux_close.c
+++ b/src/java.base/linux/native/libnet/linux_close.c
@@ -58,11 +58,11 @@
 } fdEntry_t;
 
 /*
  * Signal to unblock thread
  */
-static int sigWakeup = (__SIGRTMAX - 2);
+static int sigWakeup;
 
 /*
  * fdTable holds one entry per file descriptor, up to a certain
  * maximum.
  * Theoretically, the number of possible file descriptors can get
@@ -147,10 +147,11 @@
     }
 
     /*
      * Setup the signal handler
      */
+    sigWakeup = SIGRTMAX - 2;
     sa.sa_handler = sig_wakeup;
     sa.sa_flags   = 0;
     sigemptyset(&sa.sa_mask);
     sigaction(sigWakeup, &sa, NULL);
 
diff a/src/java.base/unix/native/libjava/childproc.c b/src/java.base/unix/native/libjava/childproc.c
--- a/src/java.base/unix/native/libjava/childproc.c
+++ b/src/java.base/unix/native/libjava/childproc.c
@@ -234,11 +234,17 @@
             const char *argv[],
             const char *const envp[])
 {
     if (envp == NULL || (char **) envp == environ) {
         execvp(file, (char **) argv);
-        return;
+        // ENOEXEC indicates that the file header was not recognized. The musl C
+        // library does not implement the fallback to /bin/sh for that case, so fall
+        // through to the code below which implements that fallback using
+        // execve_with_shell_fallback.
+        if (errno != ENOEXEC) {
+            return;
+        }
     }
 
     if (*file == '\0') {
         errno = ENOENT;
         return;
diff a/src/java.base/unix/native/libjava/jdk_util_md.h b/src/java.base/unix/native/libjava/jdk_util_md.h
--- a/src/java.base/unix/native/libjava/jdk_util_md.h
+++ b/src/java.base/unix/native/libjava/jdk_util_md.h
@@ -35,11 +35,11 @@
 #include <math.h>
 #define ISNANF(f) isnan(f)
 #define ISNAND(d) isnan(d)
 #elif defined(__linux__) || defined(_ALLBSD_SOURCE)
 #include <math.h>
-#define ISNANF(f) isnanf(f)
+#define ISNANF(f) isnan(f)
 #define ISNAND(d) isnan(d)
 #elif defined(_AIX)
 #include <math.h>
 #define ISNANF(f) _isnanf(f)
 #define ISNAND(d) _isnan(d)
diff a/src/java.base/unix/native/libjli/java_md_solinux.c b/src/java.base/unix/native/libjli/java_md_solinux.c
--- a/src/java.base/unix/native/libjli/java_md_solinux.c
+++ b/src/java.base/unix/native/libjli/java_md_solinux.c
@@ -234,10 +234,43 @@
     char jpath[PATH_MAX + 1];
     char *llp;
     char *dmllp = NULL;
     char *p; /* a utility pointer */
 
+#ifdef __linux
+#ifndef LIBC
+#error "LIBC not set"
+#endif
+
+    if (strcmp(LIBC, "musl") == 0) {
+      /*
+       * The musl library loader requires LD_LIBRARY_PATH to be set in
+       * order to correctly resolve the dependency libjava.so has on libjvm.so.
+       *
+       * Specifically, it differs from glibc in the sense that even if
+       * libjvm.so has already been loaded it will not be considered a
+       * candidate for resolving the dependency unless the *full* path
+       * of the already loaded library matches the dependency being loaded.
+       *
+       * libjvm.so is being loaded by the launcher using a long path to
+       * dlopen, not just the basename of the library. Typically this
+       * is something like "../lib/server/libjvm.so". However, if/when
+       * libjvm.so later tries to dlopen libjava.so (which it does in
+       * order to get access to a few functions implemented in
+       * libjava.so) the musl loader will, as part of loading
+       * dependent libraries, try to load libjvm.so using only its
+       * basename "libjvm.so". Since this does not match the longer
+       * path path it was first loaded with, the already loaded
+       * library is not considered a candidate, and the loader will
+       * instead look for libjvm.so elsewhere. If it's not in
+       * LD_LIBRARY_PATH the dependency load will fail, and libjava.so
+       * will therefore fail as well.
+       */
+      return JNI_TRUE;
+    }
+#endif
+
 #ifdef AIX
     /* We always have to set the LIBPATH on AIX because ld doesn't support $ORIGIN. */
     return JNI_TRUE;
 #endif
 
diff a/src/java.base/unix/native/libnio/ch/NativeThread.c b/src/java.base/unix/native/libnio/ch/NativeThread.c
--- a/src/java.base/unix/native/libnio/ch/NativeThread.c
+++ b/src/java.base/unix/native/libnio/ch/NativeThread.c
@@ -34,11 +34,11 @@
 #include <signal.h>
 
 #ifdef __linux__
   #include <pthread.h>
   /* Also defined in net/linux_close.c */
-  #define INTERRUPT_SIGNAL (__SIGRTMAX - 2)
+  #define INTERRUPT_SIGNAL (SIGRTMAX - 2)
 #elif defined(_AIX)
   #include <pthread.h>
   /* Also defined in net/aix_close.c */
   #define INTERRUPT_SIGNAL (SIGRTMAX - 1)
 #elif defined(__solaris__)
diff a/src/java.desktop/unix/native/libawt_xawt/xawt/XToolkit.c b/src/java.desktop/unix/native/libawt_xawt/xawt/XToolkit.c
--- a/src/java.desktop/unix/native/libawt_xawt/xawt/XToolkit.c
+++ b/src/java.desktop/unix/native/libawt_xawt/xawt/XToolkit.c
@@ -25,13 +25,10 @@
 
 #include <X11/Xlib.h>
 #include <X11/Xutil.h>
 #include <X11/Xos.h>
 #include <X11/Xatom.h>
-#ifdef __linux__
-#include <execinfo.h>
-#endif
 
 #include <jvm.h>
 #include <jni.h>
 #include <jlong.h>
 #include <jni_util.h>
@@ -778,30 +775,10 @@
         JNU_ReleaseStringPlatformChars(env, key, (const char*)keystr);
     }
     return ret;
 }
 
-#ifdef __linux__
-void print_stack(void)
-{
-  void *array[10];
-  size_t size;
-  char **strings;
-  size_t i;
-
-  size = backtrace (array, 10);
-  strings = backtrace_symbols (array, size);
-
-  fprintf (stderr, "Obtained %zd stack frames.\n", size);
-
-  for (i = 0; i < size; i++)
-     fprintf (stderr, "%s\n", strings[i]);
-
-  free (strings);
-}
-#endif
-
 Window get_xawt_root_shell(JNIEnv *env) {
   static jclass classXRootWindow = NULL;
   static jmethodID methodGetXRootWindow = NULL;
   static Window xawt_root_shell = None;
 
diff a/src/jdk.hotspot.agent/linux/native/libsaproc/ps_core.c b/src/jdk.hotspot.agent/linux/native/libsaproc/ps_core.c
--- a/src/jdk.hotspot.agent/linux/native/libsaproc/ps_core.c
+++ b/src/jdk.hotspot.agent/linux/native/libsaproc/ps_core.c
@@ -371,10 +371,14 @@
 static bool read_lib_segments(struct ps_prochandle* ph, int lib_fd, ELF_EHDR* lib_ehdr, uintptr_t lib_base) {
   int i = 0;
   ELF_PHDR* phbuf;
   ELF_PHDR* lib_php = NULL;
 
+#ifndef LIBC
+#error "LIBC not set"
+#endif
+
   int page_size = sysconf(_SC_PAGE_SIZE);
 
   if ((phbuf = read_program_header_table(lib_fd, lib_ehdr)) == NULL) {
     return false;
   }
@@ -394,12 +398,12 @@
           goto err;
         }
       } else {
         // Coredump stores value of p_memsz elf field
         // rounded up to page boundary.
-
-        if ((existing_map->memsz != page_size) &&
+        if ((strcmp(LIBC, "musl")) &&
+            (existing_map->memsz != page_size) &&
             (existing_map->fd != lib_fd) &&
             (ROUNDUP(existing_map->memsz, page_size) != ROUNDUP(lib_php->p_memsz, page_size))) {
 
           print_debug("address conflict @ 0x%lx (existing map size = %ld, size = %ld, flags = %d)\n",
                         target_vaddr, existing_map->memsz, lib_php->p_memsz, lib_php->p_flags);
diff a/src/jdk.hotspot.agent/linux/native/libsaproc/ps_proc.c b/src/jdk.hotspot.agent/linux/native/libsaproc/ps_proc.c
--- a/src/jdk.hotspot.agent/linux/native/libsaproc/ps_proc.c
+++ b/src/jdk.hotspot.agent/linux/native/libsaproc/ps_proc.c
@@ -281,13 +281,14 @@
         print_debug("Thread with pid %d does not exist\n", pid);
         return ATTACH_THREAD_DEAD;
       }
     }
     char buf[200];
-    char* msg = strerror_r(errno, buf, sizeof(buf));
-    snprintf(err_buf, err_buf_len, "ptrace(PTRACE_ATTACH, ..) failed for %d: %s", pid, msg);
-    print_error("%s\n", err_buf);
+    if (strerror_r(errno, buf, sizeof(buf) == 0)) {
+      snprintf(err_buf, err_buf_len, "ptrace(PTRACE_ATTACH, ..) failed for %d: %s", pid, buf);
+      print_error("%s\n", err_buf);
+    }
     return ATTACH_FAIL;
   } else {
     attach_state_t wait_ret = ptrace_waitpid(pid);
     if (wait_ret == ATTACH_THREAD_DEAD) {
       print_debug("Thread with pid %d does not exist\n", pid);
diff a/src/jdk.jdwp.agent/share/native/libjdwp/util.h b/src/jdk.jdwp.agent/share/native/libjdwp/util.h
--- a/src/jdk.jdwp.agent/share/native/libjdwp/util.h
+++ b/src/jdk.jdwp.agent/share/native/libjdwp/util.h
@@ -33,19 +33,19 @@
 #include <stdarg.h>
 
 #ifdef DEBUG
     /* Just to make sure these interfaces are not used here. */
     #undef free
-    #define free(p) Do not use this interface.
+    #define free do_not_use_this_interface_free
     #undef malloc
-    #define malloc(p) Do not use this interface.
+    #define malloc do_not_use_this_interface_malloc
     #undef calloc
-    #define calloc(p) Do not use this interface.
+    #define calloc do_not_use_this_interface_calloc
     #undef realloc
-    #define realloc(p) Do not use this interface.
+    #define realloc do_not_use_this_interface_realloc
     #undef strdup
-    #define strdup(p) Do not use this interface.
+    #define strdup do_not_use_this_interface_strdup
 #endif
 
 #include "log_messages.h"
 #include "vm_interface.h"
 #include "JDWP.h"
diff a/test/hotspot/jtreg/runtime/8176717/TestInheritFD.java b/test/hotspot/jtreg/runtime/8176717/TestInheritFD.java
--- a/test/hotspot/jtreg/runtime/8176717/TestInheritFD.java
+++ b/test/hotspot/jtreg/runtime/8176717/TestInheritFD.java
@@ -117,16 +117,17 @@
         public static void main(String[] args) throws IOException, InterruptedException {
             ProcessBuilder pb = createJavaProcessBuilder(
                 "-Dtest.jdk=" + getProperty("test.jdk"),
                 VMShouldNotInheritFileDescriptors.class.getName(),
                 args[0],
-                "" + ProcessHandle.current().pid());
+                getPid());
             pb.inheritIO(); // in future, redirect information from third VM to first VM
             pb.start();
 
             if (!isWindows()) {
-                System.out.println("(Second VM) Open file descriptors:\n" + outputContainingFilenames().stream().collect(joining("\n")));
+                System.out.printf("(Second VM) Open file descriptors: %s%n",
+                        outputContainingFilenames().stream().collect(joining("\n")));
             }
         }
     }
 
     static class VMShouldNotInheritFileDescriptors {
@@ -169,30 +170,36 @@
         } catch (IOException e) {
             throw new RuntimeException(e);
         }
     }
 
-    static Optional<String[]> lsofCommandCache = stream(new String[][]{
-            {"/usr/bin/lsof", "-p"},
-            {"/usr/sbin/lsof", "-p"},
-            {"/bin/lsof", "-p"},
-            {"/sbin/lsof", "-p"},
-            {"/usr/local/bin/lsof", "-p"},
-            {"/usr/bin/pfiles", "-F"}}) // Solaris
-        .filter(args -> new File(args[0]).exists())
+    static Optional<Command> lsofCommandCache = stream(new Command[]{
+            new Command("/usr/bin/lsof", "-p", true),
+            new Command("/usr/sbin/lsof", "-p", true),
+            new Command("/bin/lsof", "-p", true),
+            new Command("/sbin/lsof", "-p", true),
+            new Command("/usr/local/bin/lsof", "-p", true),
+            new Command("/usr/bin/pfiles", "-F", false), // Solaris
+        })
+        .filter(command -> command.exists())
         .findFirst();
 
-    static Optional<String[]> lsofCommand() {
+    static Optional<Command> lsofCommand() {
         return lsofCommandCache;
     }
 
-    static Collection<String> outputContainingFilenames() {
-        long pid = ProcessHandle.current().pid();
+    static Command lsofCmd() {
+        return lsofCommand().orElseThrow(() -> new RuntimeException("lsof like command not found"));
+    }
 
-        String[] command = lsofCommand().orElseThrow(() -> new RuntimeException("lsof like command not found"));
-        System.out.println("using command: " + command[0] + " " + command[1]);
-        return run(command[0], command[1], "" + pid).collect(toList());
+    static Collection<String> outputContainingFilenames() {
+        String pid = getPid();
+        Command command = lsofCmd();
+        System.out.printf("using command: %s%n", command);
+        return run(command.name, command.option, pid)
+                .filter(line -> !command.checkPid || line.contains(pid))
+                .collect(toList());
     }
 
     static boolean findOpenLogFile(Collection<String> fileNames) {
         return fileNames.stream()
             .filter(fileName -> fileName.contains(LOG_SUFFIX))
@@ -204,7 +211,32 @@
         System.out.println("waiting for pid: " + parentPid);
         ProcessHandle.of(parentPid).ifPresent(handle -> handle.onExit().join());
         System.out.println("trying to rename file to the same name: " + f);
         System.out.println(f.renameTo(f) ? RETAINS_FD : LEAKS_FD); // this parts communicates a closed file descriptor by printing "VM RESULT => RETAINS FD"
     }
+
+    private static String getPid() {
+        return Long.toString(ProcessHandle.current().pid());
+    }
+
+    private static class Command {
+        private final String name;
+        private final String option;
+        private final boolean checkPid;
+
+        public Command(String name, String option, boolean checkPid) {
+            this.name = name;
+            this.option = option;
+            this.checkPid = checkPid;
+        }
+
+        private boolean exists() {
+            return new File(name).exists();
+        }
+
+        public String toString() {
+            return String.format("[name: %s, option: %s, check pid: %b]",
+                    name, option, checkPid);
+        }
+    }
 }
 
diff a/test/hotspot/jtreg/runtime/StackGuardPages/exeinvoke.c b/test/hotspot/jtreg/runtime/StackGuardPages/exeinvoke.c
--- a/test/hotspot/jtreg/runtime/StackGuardPages/exeinvoke.c
+++ b/test/hotspot/jtreg/runtime/StackGuardPages/exeinvoke.c
@@ -31,10 +31,11 @@
  * It's OK - don't file a bug.
  */
 
 #include <assert.h>
 #include <jni.h>
+#include <jvm.h>
 #include <alloca.h>
 #include <signal.h>
 #include <string.h>
 #include <sys/mman.h>
 #include <stdlib.h>
@@ -89,10 +90,24 @@
     fprintf(stderr, "Test ERROR. Can't set sigaction (%d)\n", errno);
     exit(7);
   }
 }
 
+int get_java_stacksize () {
+  size_t stacksize;
+  pthread_attr_t attr;
+  JDK1_1InitArgs jdk_args;
+
+  jdk_args.version = JNI_VERSION_1_1;
+  JNI_GetDefaultJavaVMInitArgs(&jdk_args);
+  if (jdk_args.javaStackSize <= 0) {
+    fprintf(stderr, "Test ERROR. Can't get a valid value for the default stacksize.\n");
+    exit(7);
+  }
+  return jdk_args.javaStackSize;
+}
+
 void *run_java_overflow (void *p) {
   JNIEnv *env;
   jclass class_id;
   jmethodID method_id;
   int res;
@@ -256,17 +271,23 @@
   if (JNI_CreateJavaVM (&_jvm, (void **)&env, &vm_args) < 0 ) {
     fprintf(stderr, "Test ERROR. Can't create JavaVM\n");
     exit(7);
   }
 
+  int stack_size = get_java_stacksize();
   pthread_t thr;
+  pthread_attr_t thread_attr;
+
+  pthread_attr_init(&thread_attr);
+  pthread_attr_setstacksize(&thread_attr, stack_size);
 
   if (argc > 1 && strcmp(argv[1], "test_java_overflow") == 0) {
     printf("\nTesting JAVA_OVERFLOW\n");
 
     printf("Testing stack guard page behaviour for other thread\n");
-    pthread_create (&thr, NULL, run_java_overflow, NULL);
+
+    pthread_create (&thr, &thread_attr, run_java_overflow, NULL);
     pthread_join (thr, NULL);
 
     printf("Testing stack guard page behaviour for initial thread\n");
     run_java_overflow(NULL);
     // This test crash on error
@@ -275,11 +296,11 @@
 
   if (argc > 1 && strcmp(argv[1], "test_native_overflow") == 0) {
     printf("\nTesting NATIVE_OVERFLOW\n");
 
     printf("Testing stack guard page behaviour for other thread\n");
-    pthread_create (&thr, NULL, run_native_overflow, NULL);
+    pthread_create (&thr, &thread_attr, run_native_overflow, NULL);
     pthread_join (thr, NULL);
 
     printf("Testing stack guard page behaviour for initial thread\n");
     run_native_overflow(NULL);
 
diff a/test/hotspot/jtreg/runtime/TLS/exestack-tls.c b/test/hotspot/jtreg/runtime/TLS/exestack-tls.c
--- a/test/hotspot/jtreg/runtime/TLS/exestack-tls.c
+++ b/test/hotspot/jtreg/runtime/TLS/exestack-tls.c
@@ -24,11 +24,14 @@
 
 #include <jni.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+
+#ifdef __GLIBC__
 #include <gnu/libc-version.h>
+#endif
 
 // Declare the thread local variable(s) in the main executable. This can be
 // used to demonstrate the issues associated with the on-stack static TLS blocks
 // that may cause insufficient stack space. The dynamic TLS blocks for shared
 // objects (such as a JNI library) loaded via dlopen are not allocated on stack.
@@ -52,10 +55,11 @@
     rv = JNI_CreateJavaVM(jvm, (void**)&env, &args);
     if (rv < 0) return NULL;
     return env;
 }
 
+#if defined(__GLIBC)
 // glibc 2.15 introduced __pthread_get_minstack
 int glibc_has_pthread_get_minstack() {
   const char* glibc_vers = gnu_get_libc_version();
   const int glibc_vers_major = atoi(glibc_vers);
   const int glibc_vers_minor = atoi(strchr(glibc_vers, '.') + 1);;
@@ -64,10 +68,15 @@
     return 1;
   }
   printf("This version does not provide __pthread_get_minstack\n");
   return 0;
 }
+#else
+int glibc_has_pthread_get_minstack() {
+  return 0;
+}
+#endif
 
 int run(jboolean addTLS) {
     JavaVM *jvm;
     jclass testClass;
     jmethodID runMethod;
diff a/test/jdk/TEST.ROOT b/test/jdk/TEST.ROOT
--- a/test/jdk/TEST.ROOT
+++ b/test/jdk/TEST.ROOT
@@ -49,10 +49,11 @@
     vm.gc.Shenandoah \
     vm.graal.enabled \
     vm.compiler1.enabled \
     vm.compiler2.enabled \
     vm.cds \
+    vm.musl \
     vm.debug \
     vm.hasSA \
     vm.hasSAandCanAttach \
     vm.hasJFR \
     docker.support \
diff a/test/jdk/java/lang/ClassLoader/nativeLibrary/NativeLibraryTest.java b/test/jdk/java/lang/ClassLoader/nativeLibrary/NativeLibraryTest.java
--- a/test/jdk/java/lang/ClassLoader/nativeLibrary/NativeLibraryTest.java
+++ b/test/jdk/java/lang/ClassLoader/nativeLibrary/NativeLibraryTest.java
@@ -23,10 +23,13 @@
 
 /*
  * @test
  * @bug 8164512 8191360
  * @requires vm.compMode != "Xcomp"
+ * @comment Under musl, dlclose is a no-op. The static variable 'count' in libnative.c
+ * keeps its value across a GC and the check in Test.java fails.
+ * @requires !vm.musl
  * @summary verify if the native library is unloaded when the class loader is GC'ed
  * @build p.Test
  * @run main/othervm/native -Xcheck:jni NativeLibraryTest
  */
 
diff a/test/jdk/java/lang/ProcessBuilder/Basic.java b/test/jdk/java/lang/ProcessBuilder/Basic.java
--- a/test/jdk/java/lang/ProcessBuilder/Basic.java
+++ b/test/jdk/java/lang/ProcessBuilder/Basic.java
@@ -394,12 +394,12 @@
                 }
 
                 if (failed != 0) throw new Error("null PATH");
             } else if (action.equals("PATH search algorithm")) {
                 equal(System.getenv("PATH"), "dir1:dir2:");
-                check(new File("/bin/true").exists());
-                check(new File("/bin/false").exists());
+                check(new File(TrueExe.path()).exists());
+                check(new File(FalseExe.path()).exists());
                 String[] cmd = {"prog"};
                 ProcessBuilder pb1 = new ProcessBuilder(cmd);
                 ProcessBuilder pb2 = new ProcessBuilder(cmd);
                 ProcessBuilder pb3 = new ProcessBuilder(cmd);
                 pb2.environment().put("PATH", "anyOldPathIgnoredAnyways");
@@ -436,17 +436,17 @@
                         // Report EACCES errno
                         new File("dir1/prog").mkdirs();
                         checkPermissionDenied(pb);
 
                         // continue searching if EACCES
-                        copy("/bin/true", "dir2/prog");
+                        copy(TrueExe.path(), "dir2/prog");
                         equal(run(pb).exitValue(), True.exitValue());
                         new File("dir1/prog").delete();
                         new File("dir2/prog").delete();
 
                         new File("dir2/prog").mkdirs();
-                        copy("/bin/true", "dir1/prog");
+                        copy(TrueExe.path(), "dir1/prog");
                         equal(run(pb).exitValue(), True.exitValue());
 
                         // Check empty PATH component means current directory.
                         //
                         // While we're here, let's test different kinds of
@@ -458,14 +458,14 @@
                                      new String[] {"./prog"},
                                      cmd}) {
                             pb.command(command);
                             File prog = new File("./prog");
                             // "Normal" binaries
-                            copy("/bin/true", "./prog");
+                            copy(TrueExe.path(), "./prog");
                             equal(run(pb).exitValue(),
                                   True.exitValue());
-                            copy("/bin/false", "./prog");
+                            copy(FalseExe.path(), "./prog");
                             equal(run(pb).exitValue(),
                                   False.exitValue());
                             prog.delete();
                             // Interpreter scripts with #!
                             setFileContents(prog, "#!/bin/true\n");
@@ -516,16 +516,16 @@
                         // parent's is used.
                         new File("dir1/prog").delete();
                         new File("dir2/prog").delete();
                         new File("prog").delete();
                         new File("dir3").mkdirs();
-                        copy("/bin/true", "dir1/prog");
-                        copy("/bin/false", "dir3/prog");
+                        copy(TrueExe.path(), "dir1/prog");
+                        copy(FalseExe.path(), "dir3/prog");
                         pb.environment().put("PATH","dir3");
                         equal(run(pb).exitValue(), True.exitValue());
-                        copy("/bin/true", "dir3/prog");
-                        copy("/bin/false", "dir1/prog");
+                        copy(TrueExe.path(), "dir3/prog");
+                        copy(FalseExe.path(), "dir1/prog");
                         equal(run(pb).exitValue(), False.exitValue());
 
                     } finally {
                         // cleanup
                         new File("dir1/prog").delete();
@@ -618,10 +618,17 @@
              new File("/bin/sh").exists() &&
              new File("/bin/true").exists() &&
              new File("/bin/false").exists());
     }
 
+    static class BusyBox {
+        public static boolean is() { return is; }
+        private static final boolean is =
+            (! Windows.is() &&
+             new File("/bin/busybox").exists());
+    }
+
     static class UnicodeOS {
         public static boolean is() { return is; }
         private static final String osName = System.getProperty("os.name");
         private static final boolean is =
             // MacOS X would probably also qualify
@@ -656,10 +663,49 @@
                 }
             } catch (Throwable t) { unexpected(t); return -1; }
         }
     }
 
+    // On alpine linux, /bin/true and /bin/false are just links to /bin/busybox.
+    // Some tests copy /bin/true and /bin/false to files with a different filename.
+    // However, copying the busbox executable into a file with a different name
+    // won't result in the expected return codes. As workaround, we create
+    // executable files that can be copied and produce the exepected return
+    // values. We use this workaround, if we find the busybox executable.
+
+    private static class TrueExe {
+        public static String path() { return path; }
+        private static final String path = path0();
+        private static String path0(){
+            if (!BusyBox.is()) {
+                return "/bin/true";
+            }
+            else {
+                File trueExe = new File("true");
+                setFileContents(trueExe, "#!/bin/true\n");
+                trueExe.setExecutable(true);
+                return trueExe.getAbsolutePath();
+            }
+        }
+    }
+
+    private static class FalseExe {
+        public static String path() { return path; }
+        private static final String path = path0();
+        private static String path0(){
+            if (!BusyBox.is()) {
+                return "/bin/false";
+            }
+            else {
+                File falseExe = new File("false");
+                setFileContents(falseExe, "#!/bin/false\n");
+                falseExe.setExecutable(true);
+                return falseExe.getAbsolutePath();
+            }
+        }
+    }
+
     static class EnglishUnix {
         private static final Boolean is =
             (! Windows.is() && isEnglish("LANG") && isEnglish("LC_ALL"));
 
         private static boolean isEnglish(String envvar) {
@@ -1959,11 +2005,11 @@
             //----------------------------------------------------------------
             // Parent's, not child's PATH is used
             //----------------------------------------------------------------
             try {
                 new File("suBdiR").mkdirs();
-                copy("/bin/true", "suBdiR/unliKely");
+                copy(TrueExe.path(), "suBdiR/unliKely");
                 final ProcessBuilder pb =
                     new ProcessBuilder(new String[]{"unliKely"});
                 pb.environment().put("PATH", "suBdiR");
                 THROWS(IOException.class, () -> pb.start());
             } catch (Throwable t) { unexpected(t);
diff a/test/jdk/java/lang/ProcessHandle/InfoTest.java b/test/jdk/java/lang/ProcessHandle/InfoTest.java
--- a/test/jdk/java/lang/ProcessHandle/InfoTest.java
+++ b/test/jdk/java/lang/ProcessHandle/InfoTest.java
@@ -296,11 +296,18 @@
                     Assert.assertNotNull(user);
                     Assert.assertEquals(user, whoami);
                 }
                 if (info.command().isPresent()) {
                     String command = info.command().get();
-                    String expected = Platform.isWindows() ? "sleep.exe" : "sleep";
+                    String expected = "sleep";
+                    if (Platform.isWindows()) {
+                        expected = "sleep.exe";
+                    } else if (new File("/bin/busybox").exists()) {
+                        // With busybox sleep is just a sym link to busybox.
+                        // The busbox executable is seen as ProcessHandle.Info command.
+                        expected = "busybox";
+                    }
                     Assert.assertTrue(command.endsWith(expected), "Command: expected: \'" +
                             expected + "\', actual: " + command);
 
                     // Verify the command exists and is executable
                     File exe = new File(command);
diff a/test/jdk/tools/launcher/ExecutionEnvironment.java b/test/jdk/tools/launcher/ExecutionEnvironment.java
--- a/test/jdk/tools/launcher/ExecutionEnvironment.java
+++ b/test/jdk/tools/launcher/ExecutionEnvironment.java
@@ -133,20 +133,26 @@
 
         if (!tr.isNotZeroOutput()) {
             flagError(tr, "Error: No output at all. Did the test execute ?");
         }
 
+        boolean isExpandedLibPath = TestHelper.isExpandedSharedLibraryPath;
+
         for (String x : LD_PATH_STRINGS) {
             if (!tr.contains(x)) {
-                if (TestHelper.isAIX && x.startsWith(LD_LIBRARY_PATH)) {
+                if (isExpandedLibPath && x.startsWith(LD_LIBRARY_PATH)) {
                     // AIX does not support the '-rpath' linker options so the
                     // launchers have to prepend the jdk library path to 'LIBPATH'.
-                    String aixLibPath = LD_LIBRARY_PATH + "=" +
-                        System.getenv(LD_LIBRARY_PATH) +
-                        System.getProperty("path.separator") + LD_LIBRARY_PATH_VALUE;
-                    if (!tr.matches(aixLibPath)) {
-                        flagError(tr, "FAIL: did not get <" + aixLibPath + ">");
+                    // The musl library loader requires LD_LIBRARY_PATH to be set in
+                    // order to correctly resolve the dependency libjava.so has on libjvm.so.
+                    String expandedLibPath = String.format("%s=%s%c%s",
+                            LD_LIBRARY_PATH,
+                            System.getenv(LD_LIBRARY_PATH),
+                            File.pathSeparatorChar,
+                            LD_LIBRARY_PATH_VALUE);
+                    if (!tr.matches(expandedLibPath)) {
+                        flagError(tr, "FAIL: did not get <" + expandedLibPath + ">");
                     }
                 }
                 else {
                     flagError(tr, "FAIL: did not get <" + x + ">");
                 }
diff a/test/jdk/tools/launcher/Test7029048.java b/test/jdk/tools/launcher/Test7029048.java
--- a/test/jdk/tools/launcher/Test7029048.java
+++ b/test/jdk/tools/launcher/Test7029048.java
@@ -176,24 +176,24 @@
                     } else {
                         Files.deleteIfExists(dstServerLibjvm.toPath());
                     }
 
                     desc = "LD_LIBRARY_PATH should not be set (no libjvm.so)";
-                    if (TestHelper.isAIX) {
+                    if (TestHelper.isExpandedSharedLibraryPath) {
                         System.out.println("Skipping test case \"" + desc +
-                                           "\" because the Aix launcher adds the paths in any case.");
+                                           "\" because the Aix and Musl launchers add the paths in any case.");
                         continue;
                     }
                     break;
                 case NO_DIR:
                     if (dstLibDir.exists()) {
                         recursiveDelete(dstLibDir);
                     }
                     desc = "LD_LIBRARY_PATH should not be set (no directory)";
-                    if (TestHelper.isAIX) {
+                    if (TestHelper.isExpandedSharedLibraryPath) {
                         System.out.println("Skipping test case \"" + desc +
-                                           "\" because the Aix launcher adds the paths in any case.");
+                                           "\" because the Aix and Musl launchers add the paths in any case.");
                         continue;
                     }
                     break;
                 default:
                     throw new RuntimeException("unknown case");
@@ -245,19 +245,22 @@
         // create our test jar first
         ExecutionEnvironment.createTestJar();
 
         // run the tests
         test7029048();
+
+        int passesLinux = TestHelper.isMusl ? 2 : 6;
+
         if (errors > 0) {
             throw new Exception("Test7029048: FAIL: with "
                     + errors + " errors and passes " + passes);
         } else if (isSolaris && passes < 9) {
             throw new Exception("Test7029048: FAIL: " +
                     "all tests did not run, expected " + 9 + " got " + passes);
-        } else if (isLinux && passes < 6) {
+        } else if (isLinux && passes < passesLinux) {
              throw new Exception("Test7029048: FAIL: " +
-                    "all tests did not run, expected " + 6 + " got " + passes);
+                    "all tests did not run, expected " + passesLinux + " got " + passes);
         } else {
             System.out.println("Test7029048: PASS " + passes);
         }
     }
 }
diff a/test/jdk/tools/launcher/TestHelper.java b/test/jdk/tools/launcher/TestHelper.java
--- a/test/jdk/tools/launcher/TestHelper.java
+++ b/test/jdk/tools/launcher/TestHelper.java
@@ -89,13 +89,15 @@
             System.getProperty("os.name", "unknown").startsWith("SunOS");
     static final boolean isLinux =
             System.getProperty("os.name", "unknown").startsWith("Linux");
     static final boolean isAIX =
             System.getProperty("os.name", "unknown").startsWith("AIX");
+    static final boolean isMusl = isMuslLibc();
     static final String LIBJVM = isWindows
                         ? "jvm.dll"
                         : "libjvm" + (isMacOSX ? ".dylib" : ".so");
+    static final boolean isExpandedSharedLibraryPath = isAIX || isMusl;
 
     static final boolean isSparc = System.getProperty("os.arch").startsWith("sparc");
 
     // make a note of the golden default locale
     static final Locale DefaultLocale = Locale.getDefault();
@@ -534,10 +536,31 @@
             "}"
         };
         createFile(new File(launcherTestDir, "Main.java"), Arrays.asList(moduleCode));
     }
 
+    /**
+     * Check if we run with musl libc.
+     *
+     * @return true if we run with musl libc.
+     */
+    private static boolean isMuslLibc() {
+        try {
+            ProcessBuilder pb = new ProcessBuilder("ldd", "--version");
+            pb.redirectErrorStream(true);
+            final Process p = pb.start();
+            try (BufferedReader br = new BufferedReader(new InputStreamReader(p.getInputStream()))) {
+                return br.lines()
+                        .findFirst()
+                        .filter(line -> line.contains("musl"))
+                        .isPresent();
+            }
+        } catch (Exception ignore) {
+        }
+        return false;
+    }
+
     static class ToolFilter implements FileFilter {
         final List<String> exclude = new ArrayList<>();
         protected ToolFilter(String... exclude) {
             for (String x : exclude) {
                 String str = x + ((isWindows) ? EXE_FILE_EXT : "");
diff a/test/jtreg-ext/requires/VMProps.java b/test/jtreg-ext/requires/VMProps.java
--- a/test/jtreg-ext/requires/VMProps.java
+++ b/test/jtreg-ext/requires/VMProps.java
@@ -21,13 +21,15 @@
  * questions.
  */
 package requires;
 
 import java.io.BufferedInputStream;
+import java.io.BufferedReader;
 import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.InputStream;
+import java.io.InputStreamReader;
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.nio.file.Paths;
 import java.nio.file.StandardOpenOption;
 import java.util.ArrayList;
@@ -114,10 +116,11 @@
         // vm.graal.enabled is true if Graal is used as JIT
         map.put("vm.graal.enabled", this::isGraalEnabled);
         map.put("vm.compiler1.enabled", this::isCompiler1Enabled);
         map.put("vm.compiler2.enabled", this::isCompiler2Enabled);
         map.put("docker.support", this::dockerSupport);
+        map.put("vm.musl", this::isMusl);
         map.put("release.implementor", this::implementor);
         map.put("test.vm.gc.nvdimm", this::isNvdimmTestEnabled);
         vmGC(map); // vm.gc.X = true/false
         vmOptFinalFlags(map);
 
@@ -494,10 +497,30 @@
         p.waitFor(10, TimeUnit.SECONDS);
 
         return (p.exitValue() == 0);
     }
 
+    /**
+     * Check if we run with musl libc.
+     *
+     * @return true if we run with musl libc.
+     */
+    protected String isMusl() {
+        try {
+            ProcessBuilder pb = new ProcessBuilder("ldd", "--version");
+            pb.redirectErrorStream(true);
+            final Process p = pb.start();
+            BufferedReader br = new BufferedReader(new InputStreamReader(p.getInputStream()));
+            String line = br.readLine();
+            if (line != null && line.contains("musl")) {
+                return "true";
+            }
+        } catch (Exception e) {
+        }
+        return "false";
+    }
+
     private String implementor() {
         try (InputStream in = new BufferedInputStream(new FileInputStream(
                 System.getProperty("java.home") + "/release"))) {
             Properties properties = new Properties();
             properties.load(in);

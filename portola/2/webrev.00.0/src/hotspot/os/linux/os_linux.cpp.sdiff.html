<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os/linux/os_linux.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../../../../make/conf/jib-profiles.js.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../../../test/hotspot/jtreg/runtime/StackGuardPages/exeinvoke.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/linux/os_linux.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
  57 #include &quot;runtime/perfMemory.hpp&quot;
  58 #include &quot;runtime/sharedRuntime.hpp&quot;
  59 #include &quot;runtime/statSampler.hpp&quot;
  60 #include &quot;runtime/stubRoutines.hpp&quot;
  61 #include &quot;runtime/thread.inline.hpp&quot;
  62 #include &quot;runtime/threadCritical.hpp&quot;
  63 #include &quot;runtime/threadSMR.hpp&quot;
  64 #include &quot;runtime/timer.hpp&quot;
  65 #include &quot;runtime/vm_version.hpp&quot;
  66 #include &quot;semaphore_posix.hpp&quot;
  67 #include &quot;services/attachListener.hpp&quot;
  68 #include &quot;services/memTracker.hpp&quot;
  69 #include &quot;services/runtimeService.hpp&quot;
  70 #include &quot;utilities/align.hpp&quot;
  71 #include &quot;utilities/decoder.hpp&quot;
  72 #include &quot;utilities/defaultStream.hpp&quot;
  73 #include &quot;utilities/events.hpp&quot;
  74 #include &quot;utilities/elfFile.hpp&quot;
  75 #include &quot;utilities/growableArray.hpp&quot;
  76 #include &quot;utilities/macros.hpp&quot;

  77 #include &quot;utilities/vmError.hpp&quot;
  78 
  79 // put OS-includes here
  80 # include &lt;sys/types.h&gt;
  81 # include &lt;sys/mman.h&gt;
  82 # include &lt;sys/stat.h&gt;
  83 # include &lt;sys/select.h&gt;
  84 # include &lt;pthread.h&gt;
  85 # include &lt;signal.h&gt;
  86 # include &lt;endian.h&gt;
  87 # include &lt;errno.h&gt;
  88 # include &lt;dlfcn.h&gt;
  89 # include &lt;stdio.h&gt;
  90 # include &lt;unistd.h&gt;
  91 # include &lt;sys/resource.h&gt;
  92 # include &lt;pthread.h&gt;
  93 # include &lt;sys/stat.h&gt;
  94 # include &lt;sys/time.h&gt;
  95 # include &lt;sys/times.h&gt;
  96 # include &lt;sys/utsname.h&gt;
</pre>
<hr />
<pre>
 703   // will alloca() a little more space than necessary, which is OK. Don&#39;t use
 704   // os::current_stack_pointer(), as its result can be slightly below current
 705   // stack pointer, causing us to not alloca enough to reach &quot;bottom&quot;.
 706   sp = (address)&amp;sp;
 707 
 708   if (sp &gt; bottom) {
 709     size = sp - bottom;
 710     p = (volatile char *)alloca(size);
 711     assert(p != NULL &amp;&amp; p &lt;= (volatile char *)bottom, &quot;alloca problem?&quot;);
 712     p[0] = &#39;\0&#39;;
 713   }
 714 }
 715 
 716 void os::Linux::expand_stack_to(address bottom) {
 717   _expand_stack_to(bottom);
 718 }
 719 
 720 bool os::Linux::manually_expand_stack(JavaThread * t, address addr) {
 721   assert(t!=NULL, &quot;just checking&quot;);
 722   assert(t-&gt;osthread()-&gt;expanding_stack(), &quot;expand should be set&quot;);
<span class="line-modified"> 723   assert(t-&gt;stack_base() != NULL, &quot;stack_base was not initialized&quot;);</span>
<span class="line-removed"> 724 </span>
 725   if (addr &lt;  t-&gt;stack_base() &amp;&amp; addr &gt;= t-&gt;stack_reserved_zone_base()) {
 726     sigset_t mask_all, old_sigset;
 727     sigfillset(&amp;mask_all);
 728     pthread_sigmask(SIG_SETMASK, &amp;mask_all, &amp;old_sigset);
 729     _expand_stack_to(addr);
 730     pthread_sigmask(SIG_SETMASK, &amp;old_sigset, NULL);
 731     return true;
 732   }
 733   return false;
 734 }
 735 
 736 //////////////////////////////////////////////////////////////////////////////
 737 // create new thread
 738 
 739 // Thread start routine for all newly created threads
 740 static void *thread_native_entry(Thread *thread) {
 741 
 742   thread-&gt;record_stack_base_and_size();
 743 
 744   // Try to randomize the cache line index of hot stack frames.
</pre>
<hr />
<pre>
5187   // Java can be invoked as
5188   // 1. Without numactl and heap will be allocated/configured on all nodes as
5189   //    per the system policy.
5190   // 2. With numactl --interleave:
5191   //      Use numa_get_interleave_mask(v2) API to get nodes bitmask. The same
5192   //      API for membind case bitmask is reset.
5193   //      Interleave is only hint and Kernel can fallback to other nodes if
5194   //      no memory is available on the target nodes.
5195   // 3. With numactl --membind:
5196   //      Use numa_get_membind(v2) API to get nodes bitmask. The same API for
5197   //      interleave case returns bitmask of all nodes.
5198   // numa_all_nodes_ptr holds bitmask of all nodes.
5199   // numa_get_interleave_mask(v2) and numa_get_membind(v2) APIs returns correct
5200   // bitmask when externally configured to run on all or fewer nodes.
5201 
5202   if (!Linux::libnuma_init()) {
5203     UseNUMA = false;
5204   } else {
5205     if ((Linux::numa_max_node() &lt; 1) || Linux::is_bound_to_single_node()) {
5206       // If there&#39;s only one node (they start from 0) or if the process
<span class="line-modified">5207       // is bound explicitly to a single node using membind, disable NUMA.</span>
<span class="line-modified">5208       UseNUMA = false;</span>

5209     } else {
5210 
5211       LogTarget(Info,os) log;
5212       LogStream ls(log);
5213 
5214       Linux::set_configured_numa_policy(Linux::identify_numa_policy());
5215 
5216       struct bitmask* bmp = Linux::_numa_membind_bitmask;
5217       const char* numa_mode = &quot;membind&quot;;
5218 
5219       if (Linux::is_running_in_interleave_mode()) {
5220         bmp = Linux::_numa_interleave_bitmask;
5221         numa_mode = &quot;interleave&quot;;
5222       }
5223 
5224       ls.print(&quot;UseNUMA is enabled and invoked in &#39;%s&#39; mode.&quot;
5225                &quot; Heap will be configured using NUMA memory nodes:&quot;, numa_mode);
5226 
5227       for (int node = 0; node &lt;= Linux::numa_max_node(); node++) {
5228         if (Linux::_numa_bitmask_isbitset(bmp, node)) {
5229           ls.print(&quot; %d&quot;, node);
5230         }
5231       }
5232     }
5233   }
5234 
5235   if (UseParallelGC &amp;&amp; UseNUMA &amp;&amp; UseLargePages &amp;&amp; !can_commit_large_page_memory()) {
5236     // With SHM and HugeTLBFS large pages we cannot uncommit a page, so there&#39;s no way
5237     // we can make the adaptive lgrp chunk resizing work. If the user specified both
5238     // UseNUMA and UseLargePages (or UseSHM/UseHugeTLBFS) on the command line - warn
5239     // and disable adaptive resizing.
5240     if (UseAdaptiveSizePolicy || UseAdaptiveNUMAChunkSizing) {
5241       warning(&quot;UseNUMA is not fully compatible with SHM/HugeTLBFS large pages, &quot;
5242               &quot;disabling adaptive resizing (-XX:-UseAdaptiveSizePolicy -XX:-UseAdaptiveNUMAChunkSizing)&quot;);
5243       UseAdaptiveSizePolicy = false;
5244       UseAdaptiveNUMAChunkSizing = false;
5245     }
5246   }
<span class="line-removed">5247 </span>
<span class="line-removed">5248   if (!UseNUMA &amp;&amp; ForceNUMA) {</span>
<span class="line-removed">5249     UseNUMA = true;</span>
<span class="line-removed">5250   }</span>
5251 }
5252 
5253 // this is called _after_ the global arguments have been parsed
5254 jint os::init_2(void) {
5255 
5256   // This could be set after os::Posix::init() but all platforms
5257   // have to set it the same so we have to mirror Solaris.
5258   DEBUG_ONLY(os::set_mutex_init_done();)
5259 
5260   os::Posix::init_2();
5261 
5262   Linux::fast_thread_clock_init();
5263 
5264   // initialize suspend/resume support - must do this before signal_sets_init()
5265   if (SR_initialize() != 0) {
5266     perror(&quot;SR_initialize failed&quot;);
5267     return JNI_ERR;
5268   }
5269 
5270   Linux::signal_sets_init();
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
  57 #include &quot;runtime/perfMemory.hpp&quot;
  58 #include &quot;runtime/sharedRuntime.hpp&quot;
  59 #include &quot;runtime/statSampler.hpp&quot;
  60 #include &quot;runtime/stubRoutines.hpp&quot;
  61 #include &quot;runtime/thread.inline.hpp&quot;
  62 #include &quot;runtime/threadCritical.hpp&quot;
  63 #include &quot;runtime/threadSMR.hpp&quot;
  64 #include &quot;runtime/timer.hpp&quot;
  65 #include &quot;runtime/vm_version.hpp&quot;
  66 #include &quot;semaphore_posix.hpp&quot;
  67 #include &quot;services/attachListener.hpp&quot;
  68 #include &quot;services/memTracker.hpp&quot;
  69 #include &quot;services/runtimeService.hpp&quot;
  70 #include &quot;utilities/align.hpp&quot;
  71 #include &quot;utilities/decoder.hpp&quot;
  72 #include &quot;utilities/defaultStream.hpp&quot;
  73 #include &quot;utilities/events.hpp&quot;
  74 #include &quot;utilities/elfFile.hpp&quot;
  75 #include &quot;utilities/growableArray.hpp&quot;
  76 #include &quot;utilities/macros.hpp&quot;
<span class="line-added">  77 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  78 #include &quot;utilities/vmError.hpp&quot;
  79 
  80 // put OS-includes here
  81 # include &lt;sys/types.h&gt;
  82 # include &lt;sys/mman.h&gt;
  83 # include &lt;sys/stat.h&gt;
  84 # include &lt;sys/select.h&gt;
  85 # include &lt;pthread.h&gt;
  86 # include &lt;signal.h&gt;
  87 # include &lt;endian.h&gt;
  88 # include &lt;errno.h&gt;
  89 # include &lt;dlfcn.h&gt;
  90 # include &lt;stdio.h&gt;
  91 # include &lt;unistd.h&gt;
  92 # include &lt;sys/resource.h&gt;
  93 # include &lt;pthread.h&gt;
  94 # include &lt;sys/stat.h&gt;
  95 # include &lt;sys/time.h&gt;
  96 # include &lt;sys/times.h&gt;
  97 # include &lt;sys/utsname.h&gt;
</pre>
<hr />
<pre>
 704   // will alloca() a little more space than necessary, which is OK. Don&#39;t use
 705   // os::current_stack_pointer(), as its result can be slightly below current
 706   // stack pointer, causing us to not alloca enough to reach &quot;bottom&quot;.
 707   sp = (address)&amp;sp;
 708 
 709   if (sp &gt; bottom) {
 710     size = sp - bottom;
 711     p = (volatile char *)alloca(size);
 712     assert(p != NULL &amp;&amp; p &lt;= (volatile char *)bottom, &quot;alloca problem?&quot;);
 713     p[0] = &#39;\0&#39;;
 714   }
 715 }
 716 
 717 void os::Linux::expand_stack_to(address bottom) {
 718   _expand_stack_to(bottom);
 719 }
 720 
 721 bool os::Linux::manually_expand_stack(JavaThread * t, address addr) {
 722   assert(t!=NULL, &quot;just checking&quot;);
 723   assert(t-&gt;osthread()-&gt;expanding_stack(), &quot;expand should be set&quot;);
<span class="line-modified"> 724 </span>

 725   if (t-&gt;is_in_usable_stack(addr)) {
 726     sigset_t mask_all, old_sigset;
 727     sigfillset(&amp;mask_all);
 728     pthread_sigmask(SIG_SETMASK, &amp;mask_all, &amp;old_sigset);
 729     _expand_stack_to(addr);
 730     pthread_sigmask(SIG_SETMASK, &amp;old_sigset, NULL);
 731     return true;
 732   }
 733   return false;
 734 }
 735 
 736 //////////////////////////////////////////////////////////////////////////////
 737 // create new thread
 738 
 739 // Thread start routine for all newly created threads
 740 static void *thread_native_entry(Thread *thread) {
 741 
 742   thread-&gt;record_stack_base_and_size();
 743 
 744   // Try to randomize the cache line index of hot stack frames.
</pre>
<hr />
<pre>
5187   // Java can be invoked as
5188   // 1. Without numactl and heap will be allocated/configured on all nodes as
5189   //    per the system policy.
5190   // 2. With numactl --interleave:
5191   //      Use numa_get_interleave_mask(v2) API to get nodes bitmask. The same
5192   //      API for membind case bitmask is reset.
5193   //      Interleave is only hint and Kernel can fallback to other nodes if
5194   //      no memory is available on the target nodes.
5195   // 3. With numactl --membind:
5196   //      Use numa_get_membind(v2) API to get nodes bitmask. The same API for
5197   //      interleave case returns bitmask of all nodes.
5198   // numa_all_nodes_ptr holds bitmask of all nodes.
5199   // numa_get_interleave_mask(v2) and numa_get_membind(v2) APIs returns correct
5200   // bitmask when externally configured to run on all or fewer nodes.
5201 
5202   if (!Linux::libnuma_init()) {
5203     UseNUMA = false;
5204   } else {
5205     if ((Linux::numa_max_node() &lt; 1) || Linux::is_bound_to_single_node()) {
5206       // If there&#39;s only one node (they start from 0) or if the process
<span class="line-modified">5207       // is bound explicitly to a single node using membind, disable NUMA unless</span>
<span class="line-modified">5208       // user explicilty forces NUMA optimizations on single-node/UMA systems</span>
<span class="line-added">5209       UseNUMA = ForceNUMA;</span>
5210     } else {
5211 
5212       LogTarget(Info,os) log;
5213       LogStream ls(log);
5214 
5215       Linux::set_configured_numa_policy(Linux::identify_numa_policy());
5216 
5217       struct bitmask* bmp = Linux::_numa_membind_bitmask;
5218       const char* numa_mode = &quot;membind&quot;;
5219 
5220       if (Linux::is_running_in_interleave_mode()) {
5221         bmp = Linux::_numa_interleave_bitmask;
5222         numa_mode = &quot;interleave&quot;;
5223       }
5224 
5225       ls.print(&quot;UseNUMA is enabled and invoked in &#39;%s&#39; mode.&quot;
5226                &quot; Heap will be configured using NUMA memory nodes:&quot;, numa_mode);
5227 
5228       for (int node = 0; node &lt;= Linux::numa_max_node(); node++) {
5229         if (Linux::_numa_bitmask_isbitset(bmp, node)) {
5230           ls.print(&quot; %d&quot;, node);
5231         }
5232       }
5233     }
5234   }
5235 
5236   if (UseParallelGC &amp;&amp; UseNUMA &amp;&amp; UseLargePages &amp;&amp; !can_commit_large_page_memory()) {
5237     // With SHM and HugeTLBFS large pages we cannot uncommit a page, so there&#39;s no way
5238     // we can make the adaptive lgrp chunk resizing work. If the user specified both
5239     // UseNUMA and UseLargePages (or UseSHM/UseHugeTLBFS) on the command line - warn
5240     // and disable adaptive resizing.
5241     if (UseAdaptiveSizePolicy || UseAdaptiveNUMAChunkSizing) {
5242       warning(&quot;UseNUMA is not fully compatible with SHM/HugeTLBFS large pages, &quot;
5243               &quot;disabling adaptive resizing (-XX:-UseAdaptiveSizePolicy -XX:-UseAdaptiveNUMAChunkSizing)&quot;);
5244       UseAdaptiveSizePolicy = false;
5245       UseAdaptiveNUMAChunkSizing = false;
5246     }
5247   }




5248 }
5249 
5250 // this is called _after_ the global arguments have been parsed
5251 jint os::init_2(void) {
5252 
5253   // This could be set after os::Posix::init() but all platforms
5254   // have to set it the same so we have to mirror Solaris.
5255   DEBUG_ONLY(os::set_mutex_init_done();)
5256 
5257   os::Posix::init_2();
5258 
5259   Linux::fast_thread_clock_init();
5260 
5261   // initialize suspend/resume support - must do this before signal_sets_init()
5262   if (SR_initialize() != 0) {
5263     perror(&quot;SR_initialize failed&quot;);
5264     return JNI_ERR;
5265   }
5266 
5267   Linux::signal_sets_init();
</pre>
</td>
</tr>
</table>
<center><a href="../../../../make/conf/jib-profiles.js.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../../../test/hotspot/jtreg/runtime/StackGuardPages/exeinvoke.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os/linux/os_linux.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../../../../make/modules/jdk.jdwp.agent/Lib.gmk.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../share/utilities/globalDefinitions_gcc.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/linux/os_linux.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  92 # include &lt;sys/resource.h&gt;
  93 # include &lt;pthread.h&gt;
  94 # include &lt;sys/stat.h&gt;
  95 # include &lt;sys/time.h&gt;
  96 # include &lt;sys/times.h&gt;
  97 # include &lt;sys/utsname.h&gt;
  98 # include &lt;sys/socket.h&gt;
  99 # include &lt;sys/wait.h&gt;
 100 # include &lt;pwd.h&gt;
 101 # include &lt;poll.h&gt;
 102 # include &lt;fcntl.h&gt;
 103 # include &lt;string.h&gt;
 104 # include &lt;syscall.h&gt;
 105 # include &lt;sys/sysinfo.h&gt;
 106 # include &lt;sys/ipc.h&gt;
 107 # include &lt;sys/shm.h&gt;
 108 # include &lt;link.h&gt;
 109 # include &lt;stdint.h&gt;
 110 # include &lt;inttypes.h&gt;
 111 # include &lt;sys/ioctl.h&gt;

 112 
 113 #ifndef _GNU_SOURCE
 114   #define _GNU_SOURCE
 115   #include &lt;sched.h&gt;
 116   #undef _GNU_SOURCE
 117 #else
 118   #include &lt;sched.h&gt;
 119 #endif
 120 
 121 // if RUSAGE_THREAD for getrusage() has not been defined, do it here. The code calling
 122 // getrusage() is prepared to handle the associated failure.
 123 #ifndef RUSAGE_THREAD
 124   #define RUSAGE_THREAD   (1)               /* only the calling thread */
 125 #endif
 126 
 127 #define MAX_PATH    (2 * K)
 128 
 129 #define MAX_SECS 100000000
 130 
 131 // for timer info max values which include all bits
</pre>
<hr />
<pre>
1505   // flush buffered output, finish log files
1506   ostream_abort();
1507 
1508   // Check for abort hook
1509   abort_hook_t abort_hook = Arguments::abort_hook();
1510   if (abort_hook != NULL) {
1511     abort_hook();
1512   }
1513 
1514 }
1515 
1516 // Note: os::abort() might be called very early during initialization, or
1517 // called from signal handler. Before adding something to os::abort(), make
1518 // sure it is async-safe and can handle partially initialized VM.
1519 void os::abort(bool dump_core, void* siginfo, const void* context) {
1520   os::shutdown();
1521   if (dump_core) {
1522     if (DumpPrivateMappingsInCore) {
1523       ClassLoader::close_jrt_image();
1524     }
<span class="line-removed">1525 #ifndef PRODUCT</span>
<span class="line-removed">1526     fdStream out(defaultStream::output_fd());</span>
<span class="line-removed">1527     out.print_raw(&quot;Current thread is &quot;);</span>
<span class="line-removed">1528     char buf[16];</span>
<span class="line-removed">1529     jio_snprintf(buf, sizeof(buf), UINTX_FORMAT, os::current_thread_id());</span>
<span class="line-removed">1530     out.print_raw_cr(buf);</span>
<span class="line-removed">1531     out.print_raw_cr(&quot;Dumping core ...&quot;);</span>
<span class="line-removed">1532 #endif</span>
1533     ::abort(); // dump core
1534   }
1535 
1536   ::exit(1);
1537 }
1538 
1539 // Die immediately, no exit hook, no abort hook, no cleanup.
1540 // Dump a core file, if possible, for debugging.
1541 void os::die() {
1542   if (TestUnresponsiveErrorHandler &amp;&amp; !CreateCoredumpOnCrash) {
1543     // For TimeoutInErrorHandlingTest.java, we just kill the VM
1544     // and don&#39;t take the time to generate a core file.
1545     os::signal_raise(SIGKILL);
1546   } else {
1547     ::abort();
1548   }
1549 }
1550 
1551 // thread_id is kernel thread id (similar to Solaris LWP id)
1552 intx os::current_thread_id() { return os::Linux::gettid(); }
</pre>
<hr />
<pre>
1831       return NULL;
1832     }
1833 
1834 #if defined(VM_LITTLE_ENDIAN)
1835     // VM is LE, shared object BE
1836     elf_head.e_machine = be16toh(elf_head.e_machine);
1837 #else
1838     // VM is BE, shared object LE
1839     elf_head.e_machine = le16toh(elf_head.e_machine);
1840 #endif
1841   }
1842 
1843   typedef struct {
1844     Elf32_Half    code;         // Actual value as defined in elf.h
1845     Elf32_Half    compat_class; // Compatibility of archs at VM&#39;s sense
1846     unsigned char elf_class;    // 32 or 64 bit
1847     unsigned char endianness;   // MSB or LSB
1848     char*         name;         // String representation
1849   } arch_t;
1850 
<span class="line-removed">1851 #ifndef EM_486</span>
<span class="line-removed">1852   #define EM_486          6               /* Intel 80486 */</span>
<span class="line-removed">1853 #endif</span>
1854 #ifndef EM_AARCH64
1855   #define EM_AARCH64    183               /* ARM AARCH64 */
1856 #endif
1857 #ifndef EM_RISCV
1858   #define EM_RISCV      243               /* RISC-V */
1859 #endif
1860 
1861   static const arch_t arch_array[]={
1862     {EM_386,         EM_386,     ELFCLASS32, ELFDATA2LSB, (char*)&quot;IA 32&quot;},
1863     {EM_486,         EM_386,     ELFCLASS32, ELFDATA2LSB, (char*)&quot;IA 32&quot;},
1864     {EM_IA_64,       EM_IA_64,   ELFCLASS64, ELFDATA2LSB, (char*)&quot;IA 64&quot;},
1865     {EM_X86_64,      EM_X86_64,  ELFCLASS64, ELFDATA2LSB, (char*)&quot;AMD 64&quot;},
1866     {EM_SPARC,       EM_SPARC,   ELFCLASS32, ELFDATA2MSB, (char*)&quot;Sparc 32&quot;},
1867     {EM_SPARC32PLUS, EM_SPARC,   ELFCLASS32, ELFDATA2MSB, (char*)&quot;Sparc 32&quot;},
1868     {EM_SPARCV9,     EM_SPARCV9, ELFCLASS64, ELFDATA2MSB, (char*)&quot;Sparc v9 64&quot;},
1869     {EM_PPC,         EM_PPC,     ELFCLASS32, ELFDATA2MSB, (char*)&quot;Power PC 32&quot;},
1870 #if defined(VM_LITTLE_ENDIAN)
1871     {EM_PPC64,       EM_PPC64,   ELFCLASS64, ELFDATA2LSB, (char*)&quot;Power PC 64 LE&quot;},
1872     {EM_SH,          EM_SH,      ELFCLASS32, ELFDATA2LSB, (char*)&quot;SuperH&quot;},
1873 #else
</pre>
<hr />
<pre>
2047   if (fd == -1) {
2048     return false;
2049   }
2050 
2051   if (hdr != NULL) {
2052     st-&gt;print_cr(&quot;%s&quot;, hdr);
2053   }
2054 
2055   char buf[33];
2056   int bytes;
2057   buf[32] = &#39;\0&#39;;
2058   while ((bytes = ::read(fd, buf, sizeof(buf)-1)) &gt; 0) {
2059     st-&gt;print_raw(buf, bytes);
2060   }
2061 
2062   ::close(fd);
2063 
2064   return true;
2065 }
2066 







2067 void os::print_dll_info(outputStream *st) {
2068   st-&gt;print_cr(&quot;Dynamic libraries:&quot;);
2069 
2070   char fname[32];
2071   pid_t pid = os::Linux::gettid();
2072 
2073   jio_snprintf(fname, sizeof(fname), &quot;/proc/%d/maps&quot;, pid);
2074 
2075   if (!_print_ascii_file(fname, st)) {
2076     st-&gt;print(&quot;Can not get library information for pid = %d\n&quot;, pid);
2077   }
2078 }
2079 
2080 int os::get_loaded_modules_info(os::LoadedModulesCallbackFunc callback, void *param) {
2081   FILE *procmapsFile = NULL;
2082 
2083   // Open the procfs maps file for the current process
2084   if ((procmapsFile = fopen(&quot;/proc/self/maps&quot;, &quot;r&quot;)) != NULL) {
2085     // Allocate PATH_MAX for file name plus a reasonable size for other fields.
2086     char line[PATH_MAX + 100];
</pre>
<hr />
<pre>
2272   if (file_exists(&quot;/etc/debian_version&quot;)) {
2273     strncpy(buf, &quot;Debian &quot;, buflen);
2274     if (buflen &gt; 7) {
2275       parse_os_info(&amp;buf[7], buflen-7, &quot;/etc/debian_version&quot;);
2276     }
2277   } else {
2278     strncpy(buf, &quot;Linux&quot;, buflen);
2279   }
2280 }
2281 
2282 void os::Linux::print_libversion_info(outputStream* st) {
2283   // libc, pthread
2284   st-&gt;print(&quot;libc:&quot;);
2285   st-&gt;print(&quot;%s &quot;, os::Linux::glibc_version());
2286   st-&gt;print(&quot;%s &quot;, os::Linux::libpthread_version());
2287   st-&gt;cr();
2288 }
2289 
2290 void os::Linux::print_proc_sys_info(outputStream* st) {
2291   st-&gt;cr();
<span class="line-modified">2292   st-&gt;print_cr(&quot;/proc/sys/kernel/threads-max (system-wide limit on the number of threads):&quot;);</span>
<span class="line-modified">2293   _print_ascii_file(&quot;/proc/sys/kernel/threads-max&quot;, st);</span>
<span class="line-modified">2294   st-&gt;cr();</span>
<span class="line-modified">2295   st-&gt;cr();</span>
<span class="line-modified">2296 </span>
<span class="line-modified">2297   st-&gt;print_cr(&quot;/proc/sys/vm/max_map_count (maximum number of memory map areas a process may have):&quot;);</span>
<span class="line-removed">2298   _print_ascii_file(&quot;/proc/sys/vm/max_map_count&quot;, st);</span>
<span class="line-removed">2299   st-&gt;cr();</span>
<span class="line-removed">2300   st-&gt;cr();</span>
<span class="line-removed">2301 </span>
<span class="line-removed">2302   st-&gt;print_cr(&quot;/proc/sys/kernel/pid_max (system-wide limit on number of process identifiers):&quot;);</span>
<span class="line-removed">2303   _print_ascii_file(&quot;/proc/sys/kernel/pid_max&quot;, st);</span>
<span class="line-removed">2304   st-&gt;cr();</span>
<span class="line-removed">2305   st-&gt;cr();</span>
2306 }
2307 
2308 void os::Linux::print_full_memory_info(outputStream* st) {
<span class="line-modified">2309   st-&gt;print(&quot;\n/proc/meminfo:\n&quot;);</span>
<span class="line-removed">2310   _print_ascii_file(&quot;/proc/meminfo&quot;, st);</span>
2311   st-&gt;cr();
2312 
2313   // some information regarding THPs; for details see
2314   // https://www.kernel.org/doc/Documentation/vm/transhuge.txt
<span class="line-modified">2315   st-&gt;print_cr(&quot;/sys/kernel/mm/transparent_hugepage/enabled:&quot;);</span>
<span class="line-modified">2316   if (!_print_ascii_file(&quot;/sys/kernel/mm/transparent_hugepage/enabled&quot;, st)) {</span>
<span class="line-modified">2317     st-&gt;print_cr(&quot;  &lt;Not Available&gt;&quot;);</span>
<span class="line-modified">2318   }</span>
<span class="line-removed">2319   st-&gt;cr();</span>
<span class="line-removed">2320   st-&gt;print_cr(&quot;/sys/kernel/mm/transparent_hugepage/defrag (defrag/compaction efforts parameter):&quot;);</span>
<span class="line-removed">2321   if (!_print_ascii_file(&quot;/sys/kernel/mm/transparent_hugepage/defrag&quot;, st)) {</span>
<span class="line-removed">2322     st-&gt;print_cr(&quot;  &lt;Not Available&gt;&quot;);</span>
<span class="line-removed">2323   }</span>
<span class="line-removed">2324   st-&gt;cr();</span>
2325 }
2326 
2327 void os::Linux::print_ld_preload_file(outputStream* st) {
2328   _print_ascii_file(&quot;/etc/ld.so.preload&quot;, st, &quot;\n/etc/ld.so.preload:&quot;);
2329   st-&gt;cr();
2330 }
2331 
2332 void os::Linux::print_uptime_info(outputStream* st) {
2333   struct sysinfo sinfo;
2334   int ret = sysinfo(&amp;sinfo);
2335   if (ret == 0) {
2336     os::print_dhm(st, &quot;OS uptime:&quot;, (long) sinfo.uptime);
2337   }
2338 }
2339 
2340 
2341 void os::Linux::print_container_info(outputStream* st) {
2342   if (!OSContainer::is_containerized()) {
2343     return;
2344   }
</pre>
<hr />
<pre>
2489           } else {
2490             // model name printed but not flags?  Odd, just return
2491             fclose(fp);
2492             return true;
2493           }
2494         }
2495         // print the flags line too
2496         if (strstr(buf, &quot;flags&quot;) != NULL) {
2497           st-&gt;print_raw(buf);
2498           fclose(fp);
2499           return true;
2500         }
2501       }
2502     }
2503     fclose(fp);
2504   }
2505 #endif // x86 platforms
2506   return false;
2507 }
2508 
















































2509 void os::pd_print_cpu_info(outputStream* st, char* buf, size_t buflen) {
2510   // Only print the model name if the platform provides this as a summary
2511   if (!print_model_name_and_flags(st, buf, buflen)) {
<span class="line-modified">2512     st-&gt;print(&quot;\n/proc/cpuinfo:\n&quot;);</span>
<span class="line-removed">2513     if (!_print_ascii_file(&quot;/proc/cpuinfo&quot;, st)) {</span>
<span class="line-removed">2514       st-&gt;print_cr(&quot;  &lt;Not Available&gt;&quot;);</span>
<span class="line-removed">2515     }</span>
2516   }

2517 }
2518 
2519 #if defined(AMD64) || defined(IA32) || defined(X32)
2520 const char* search_string = &quot;model name&quot;;
2521 #elif defined(M68K)
2522 const char* search_string = &quot;CPU&quot;;
2523 #elif defined(PPC64)
2524 const char* search_string = &quot;cpu&quot;;
2525 #elif defined(S390)
2526 const char* search_string = &quot;machine =&quot;;
2527 #elif defined(SPARC)
2528 const char* search_string = &quot;cpu&quot;;
2529 #else
2530 const char* search_string = &quot;Processor&quot;;
2531 #endif
2532 
2533 // Parses the cpuinfo file for string representing the model name.
2534 void os::get_summary_cpu_info(char* cpuinfo, size_t length) {
2535   FILE* fp = fopen(&quot;/proc/cpuinfo&quot;, &quot;r&quot;);
2536   if (fp != NULL) {
</pre>
<hr />
<pre>
5182 }
5183 
5184 void os::Linux::numa_init() {
5185 
5186   // Java can be invoked as
5187   // 1. Without numactl and heap will be allocated/configured on all nodes as
5188   //    per the system policy.
5189   // 2. With numactl --interleave:
5190   //      Use numa_get_interleave_mask(v2) API to get nodes bitmask. The same
5191   //      API for membind case bitmask is reset.
5192   //      Interleave is only hint and Kernel can fallback to other nodes if
5193   //      no memory is available on the target nodes.
5194   // 3. With numactl --membind:
5195   //      Use numa_get_membind(v2) API to get nodes bitmask. The same API for
5196   //      interleave case returns bitmask of all nodes.
5197   // numa_all_nodes_ptr holds bitmask of all nodes.
5198   // numa_get_interleave_mask(v2) and numa_get_membind(v2) APIs returns correct
5199   // bitmask when externally configured to run on all or fewer nodes.
5200 
5201   if (!Linux::libnuma_init()) {
<span class="line-modified">5202     UseNUMA = false;</span>

5203   } else {
5204     if ((Linux::numa_max_node() &lt; 1) || Linux::is_bound_to_single_node()) {
5205       // If there&#39;s only one node (they start from 0) or if the process
5206       // is bound explicitly to a single node using membind, disable NUMA unless
5207       // user explicilty forces NUMA optimizations on single-node/UMA systems
5208       UseNUMA = ForceNUMA;
5209     } else {
5210 
5211       LogTarget(Info,os) log;
5212       LogStream ls(log);
5213 
5214       Linux::set_configured_numa_policy(Linux::identify_numa_policy());
5215 
5216       struct bitmask* bmp = Linux::_numa_membind_bitmask;
5217       const char* numa_mode = &quot;membind&quot;;
5218 
5219       if (Linux::is_running_in_interleave_mode()) {
5220         bmp = Linux::_numa_interleave_bitmask;
5221         numa_mode = &quot;interleave&quot;;
5222       }
5223 
5224       ls.print(&quot;UseNUMA is enabled and invoked in &#39;%s&#39; mode.&quot;
5225                &quot; Heap will be configured using NUMA memory nodes:&quot;, numa_mode);
5226 
5227       for (int node = 0; node &lt;= Linux::numa_max_node(); node++) {
5228         if (Linux::_numa_bitmask_isbitset(bmp, node)) {
5229           ls.print(&quot; %d&quot;, node);
5230         }
5231       }
5232     }
5233   }
5234 





5235   if (UseParallelGC &amp;&amp; UseNUMA &amp;&amp; UseLargePages &amp;&amp; !can_commit_large_page_memory()) {
5236     // With SHM and HugeTLBFS large pages we cannot uncommit a page, so there&#39;s no way
5237     // we can make the adaptive lgrp chunk resizing work. If the user specified both
5238     // UseNUMA and UseLargePages (or UseSHM/UseHugeTLBFS) on the command line - warn
5239     // and disable adaptive resizing.
5240     if (UseAdaptiveSizePolicy || UseAdaptiveNUMAChunkSizing) {
5241       warning(&quot;UseNUMA is not fully compatible with SHM/HugeTLBFS large pages, &quot;
5242               &quot;disabling adaptive resizing (-XX:-UseAdaptiveSizePolicy -XX:-UseAdaptiveNUMAChunkSizing)&quot;);
5243       UseAdaptiveSizePolicy = false;
5244       UseAdaptiveNUMAChunkSizing = false;
5245     }
5246   }
5247 }
5248 
5249 // this is called _after_ the global arguments have been parsed
5250 jint os::init_2(void) {
5251 
5252   // This could be set after os::Posix::init() but all platforms
5253   // have to set it the same so we have to mirror Solaris.
5254   DEBUG_ONLY(os::set_mutex_init_done();)
</pre>
<hr />
<pre>
5279     return JNI_ERR;
5280   }
5281 
5282 #if defined(IA32)
5283   // Need to ensure we&#39;ve determined the process&#39;s initial stack to
5284   // perform the workaround
5285   Linux::capture_initial_stack(JavaThread::stack_size_at_create());
5286   workaround_expand_exec_shield_cs_limit();
5287 #else
5288   suppress_primordial_thread_resolution = Arguments::created_by_java_launcher();
5289   if (!suppress_primordial_thread_resolution) {
5290     Linux::capture_initial_stack(JavaThread::stack_size_at_create());
5291   }
5292 #endif
5293 
5294   Linux::libpthread_init();
5295   Linux::sched_getcpu_init();
5296   log_info(os)(&quot;HotSpot is running with %s, %s&quot;,
5297                Linux::glibc_version(), Linux::libpthread_version());
5298 
<span class="line-modified">5299   if (UseNUMA) {</span>
5300     Linux::numa_init();
5301   }
5302 
5303   if (MaxFDLimit) {
5304     // set the number of file descriptors to max. print out error
5305     // if getrlimit/setrlimit fails but continue regardless.
5306     struct rlimit nbr_files;
5307     int status = getrlimit(RLIMIT_NOFILE, &amp;nbr_files);
5308     if (status != 0) {
5309       log_info(os)(&quot;os::init_2 getrlimit failed: %s&quot;, os::strerror(errno));
5310     } else {
5311       nbr_files.rlim_cur = nbr_files.rlim_max;
5312       status = setrlimit(RLIMIT_NOFILE, &amp;nbr_files);
5313       if (status != 0) {
5314         log_info(os)(&quot;os::init_2 setrlimit failed: %s&quot;, os::strerror(errno));
5315       }
5316     }
5317   }
5318 
5319   // at-exit methods are called in the reverse order of their registration.
</pre>
</td>
<td>
<hr />
<pre>
  92 # include &lt;sys/resource.h&gt;
  93 # include &lt;pthread.h&gt;
  94 # include &lt;sys/stat.h&gt;
  95 # include &lt;sys/time.h&gt;
  96 # include &lt;sys/times.h&gt;
  97 # include &lt;sys/utsname.h&gt;
  98 # include &lt;sys/socket.h&gt;
  99 # include &lt;sys/wait.h&gt;
 100 # include &lt;pwd.h&gt;
 101 # include &lt;poll.h&gt;
 102 # include &lt;fcntl.h&gt;
 103 # include &lt;string.h&gt;
 104 # include &lt;syscall.h&gt;
 105 # include &lt;sys/sysinfo.h&gt;
 106 # include &lt;sys/ipc.h&gt;
 107 # include &lt;sys/shm.h&gt;
 108 # include &lt;link.h&gt;
 109 # include &lt;stdint.h&gt;
 110 # include &lt;inttypes.h&gt;
 111 # include &lt;sys/ioctl.h&gt;
<span class="line-added"> 112 # include &lt;linux/elf-em.h&gt;</span>
 113 
 114 #ifndef _GNU_SOURCE
 115   #define _GNU_SOURCE
 116   #include &lt;sched.h&gt;
 117   #undef _GNU_SOURCE
 118 #else
 119   #include &lt;sched.h&gt;
 120 #endif
 121 
 122 // if RUSAGE_THREAD for getrusage() has not been defined, do it here. The code calling
 123 // getrusage() is prepared to handle the associated failure.
 124 #ifndef RUSAGE_THREAD
 125   #define RUSAGE_THREAD   (1)               /* only the calling thread */
 126 #endif
 127 
 128 #define MAX_PATH    (2 * K)
 129 
 130 #define MAX_SECS 100000000
 131 
 132 // for timer info max values which include all bits
</pre>
<hr />
<pre>
1506   // flush buffered output, finish log files
1507   ostream_abort();
1508 
1509   // Check for abort hook
1510   abort_hook_t abort_hook = Arguments::abort_hook();
1511   if (abort_hook != NULL) {
1512     abort_hook();
1513   }
1514 
1515 }
1516 
1517 // Note: os::abort() might be called very early during initialization, or
1518 // called from signal handler. Before adding something to os::abort(), make
1519 // sure it is async-safe and can handle partially initialized VM.
1520 void os::abort(bool dump_core, void* siginfo, const void* context) {
1521   os::shutdown();
1522   if (dump_core) {
1523     if (DumpPrivateMappingsInCore) {
1524       ClassLoader::close_jrt_image();
1525     }








1526     ::abort(); // dump core
1527   }
1528 
1529   ::exit(1);
1530 }
1531 
1532 // Die immediately, no exit hook, no abort hook, no cleanup.
1533 // Dump a core file, if possible, for debugging.
1534 void os::die() {
1535   if (TestUnresponsiveErrorHandler &amp;&amp; !CreateCoredumpOnCrash) {
1536     // For TimeoutInErrorHandlingTest.java, we just kill the VM
1537     // and don&#39;t take the time to generate a core file.
1538     os::signal_raise(SIGKILL);
1539   } else {
1540     ::abort();
1541   }
1542 }
1543 
1544 // thread_id is kernel thread id (similar to Solaris LWP id)
1545 intx os::current_thread_id() { return os::Linux::gettid(); }
</pre>
<hr />
<pre>
1824       return NULL;
1825     }
1826 
1827 #if defined(VM_LITTLE_ENDIAN)
1828     // VM is LE, shared object BE
1829     elf_head.e_machine = be16toh(elf_head.e_machine);
1830 #else
1831     // VM is BE, shared object LE
1832     elf_head.e_machine = le16toh(elf_head.e_machine);
1833 #endif
1834   }
1835 
1836   typedef struct {
1837     Elf32_Half    code;         // Actual value as defined in elf.h
1838     Elf32_Half    compat_class; // Compatibility of archs at VM&#39;s sense
1839     unsigned char elf_class;    // 32 or 64 bit
1840     unsigned char endianness;   // MSB or LSB
1841     char*         name;         // String representation
1842   } arch_t;
1843 



1844 #ifndef EM_AARCH64
1845   #define EM_AARCH64    183               /* ARM AARCH64 */
1846 #endif
1847 #ifndef EM_RISCV
1848   #define EM_RISCV      243               /* RISC-V */
1849 #endif
1850 
1851   static const arch_t arch_array[]={
1852     {EM_386,         EM_386,     ELFCLASS32, ELFDATA2LSB, (char*)&quot;IA 32&quot;},
1853     {EM_486,         EM_386,     ELFCLASS32, ELFDATA2LSB, (char*)&quot;IA 32&quot;},
1854     {EM_IA_64,       EM_IA_64,   ELFCLASS64, ELFDATA2LSB, (char*)&quot;IA 64&quot;},
1855     {EM_X86_64,      EM_X86_64,  ELFCLASS64, ELFDATA2LSB, (char*)&quot;AMD 64&quot;},
1856     {EM_SPARC,       EM_SPARC,   ELFCLASS32, ELFDATA2MSB, (char*)&quot;Sparc 32&quot;},
1857     {EM_SPARC32PLUS, EM_SPARC,   ELFCLASS32, ELFDATA2MSB, (char*)&quot;Sparc 32&quot;},
1858     {EM_SPARCV9,     EM_SPARCV9, ELFCLASS64, ELFDATA2MSB, (char*)&quot;Sparc v9 64&quot;},
1859     {EM_PPC,         EM_PPC,     ELFCLASS32, ELFDATA2MSB, (char*)&quot;Power PC 32&quot;},
1860 #if defined(VM_LITTLE_ENDIAN)
1861     {EM_PPC64,       EM_PPC64,   ELFCLASS64, ELFDATA2LSB, (char*)&quot;Power PC 64 LE&quot;},
1862     {EM_SH,          EM_SH,      ELFCLASS32, ELFDATA2LSB, (char*)&quot;SuperH&quot;},
1863 #else
</pre>
<hr />
<pre>
2037   if (fd == -1) {
2038     return false;
2039   }
2040 
2041   if (hdr != NULL) {
2042     st-&gt;print_cr(&quot;%s&quot;, hdr);
2043   }
2044 
2045   char buf[33];
2046   int bytes;
2047   buf[32] = &#39;\0&#39;;
2048   while ((bytes = ::read(fd, buf, sizeof(buf)-1)) &gt; 0) {
2049     st-&gt;print_raw(buf, bytes);
2050   }
2051 
2052   ::close(fd);
2053 
2054   return true;
2055 }
2056 
<span class="line-added">2057 static void _print_ascii_file_h(const char* header, const char* filename, outputStream* st) {</span>
<span class="line-added">2058   st-&gt;print_cr(&quot;%s:&quot;, header);</span>
<span class="line-added">2059   if (!_print_ascii_file(filename, st)) {</span>
<span class="line-added">2060     st-&gt;print_cr(&quot;&lt;Not Available&gt;&quot;);</span>
<span class="line-added">2061   }</span>
<span class="line-added">2062 }</span>
<span class="line-added">2063 </span>
2064 void os::print_dll_info(outputStream *st) {
2065   st-&gt;print_cr(&quot;Dynamic libraries:&quot;);
2066 
2067   char fname[32];
2068   pid_t pid = os::Linux::gettid();
2069 
2070   jio_snprintf(fname, sizeof(fname), &quot;/proc/%d/maps&quot;, pid);
2071 
2072   if (!_print_ascii_file(fname, st)) {
2073     st-&gt;print(&quot;Can not get library information for pid = %d\n&quot;, pid);
2074   }
2075 }
2076 
2077 int os::get_loaded_modules_info(os::LoadedModulesCallbackFunc callback, void *param) {
2078   FILE *procmapsFile = NULL;
2079 
2080   // Open the procfs maps file for the current process
2081   if ((procmapsFile = fopen(&quot;/proc/self/maps&quot;, &quot;r&quot;)) != NULL) {
2082     // Allocate PATH_MAX for file name plus a reasonable size for other fields.
2083     char line[PATH_MAX + 100];
</pre>
<hr />
<pre>
2269   if (file_exists(&quot;/etc/debian_version&quot;)) {
2270     strncpy(buf, &quot;Debian &quot;, buflen);
2271     if (buflen &gt; 7) {
2272       parse_os_info(&amp;buf[7], buflen-7, &quot;/etc/debian_version&quot;);
2273     }
2274   } else {
2275     strncpy(buf, &quot;Linux&quot;, buflen);
2276   }
2277 }
2278 
2279 void os::Linux::print_libversion_info(outputStream* st) {
2280   // libc, pthread
2281   st-&gt;print(&quot;libc:&quot;);
2282   st-&gt;print(&quot;%s &quot;, os::Linux::glibc_version());
2283   st-&gt;print(&quot;%s &quot;, os::Linux::libpthread_version());
2284   st-&gt;cr();
2285 }
2286 
2287 void os::Linux::print_proc_sys_info(outputStream* st) {
2288   st-&gt;cr();
<span class="line-modified">2289   _print_ascii_file_h(&quot;/proc/sys/kernel/threads-max (system-wide limit on the number of threads)&quot;,</span>
<span class="line-modified">2290                       &quot;/proc/sys/kernel/threads-max&quot;, st);</span>
<span class="line-modified">2291   _print_ascii_file_h(&quot;/proc/sys/vm/max_map_count (maximum number of memory map areas a process may have)&quot;,</span>
<span class="line-modified">2292                       &quot;/proc/sys/vm/max_map_count&quot;, st);</span>
<span class="line-modified">2293   _print_ascii_file_h(&quot;/proc/sys/kernel/pid_max (system-wide limit on number of process identifiers)&quot;,</span>
<span class="line-modified">2294                       &quot;/proc/sys/kernel/pid_max&quot;, st);</span>








2295 }
2296 
2297 void os::Linux::print_full_memory_info(outputStream* st) {
<span class="line-modified">2298   _print_ascii_file_h(&quot;\n/proc/meminfo&quot;, &quot;/proc/meminfo&quot;, st);</span>

2299   st-&gt;cr();
2300 
2301   // some information regarding THPs; for details see
2302   // https://www.kernel.org/doc/Documentation/vm/transhuge.txt
<span class="line-modified">2303   _print_ascii_file_h(&quot;/sys/kernel/mm/transparent_hugepage/enabled&quot;,</span>
<span class="line-modified">2304                       &quot;/sys/kernel/mm/transparent_hugepage/enabled&quot;, st);</span>
<span class="line-modified">2305   _print_ascii_file_h(&quot;/sys/kernel/mm/transparent_hugepage/defrag (defrag/compaction efforts parameter)&quot;,</span>
<span class="line-modified">2306                       &quot;/sys/kernel/mm/transparent_hugepage/defrag&quot;, st);</span>






2307 }
2308 
2309 void os::Linux::print_ld_preload_file(outputStream* st) {
2310   _print_ascii_file(&quot;/etc/ld.so.preload&quot;, st, &quot;\n/etc/ld.so.preload:&quot;);
2311   st-&gt;cr();
2312 }
2313 
2314 void os::Linux::print_uptime_info(outputStream* st) {
2315   struct sysinfo sinfo;
2316   int ret = sysinfo(&amp;sinfo);
2317   if (ret == 0) {
2318     os::print_dhm(st, &quot;OS uptime:&quot;, (long) sinfo.uptime);
2319   }
2320 }
2321 
2322 
2323 void os::Linux::print_container_info(outputStream* st) {
2324   if (!OSContainer::is_containerized()) {
2325     return;
2326   }
</pre>
<hr />
<pre>
2471           } else {
2472             // model name printed but not flags?  Odd, just return
2473             fclose(fp);
2474             return true;
2475           }
2476         }
2477         // print the flags line too
2478         if (strstr(buf, &quot;flags&quot;) != NULL) {
2479           st-&gt;print_raw(buf);
2480           fclose(fp);
2481           return true;
2482         }
2483       }
2484     }
2485     fclose(fp);
2486   }
2487 #endif // x86 platforms
2488   return false;
2489 }
2490 
<span class="line-added">2491 // additional information about CPU e.g. available frequency ranges</span>
<span class="line-added">2492 static void print_sys_devices_cpu_info(outputStream* st, char* buf, size_t buflen) {</span>
<span class="line-added">2493   _print_ascii_file_h(&quot;Online cpus&quot;, &quot;/sys/devices/system/cpu/online&quot;, st);</span>
<span class="line-added">2494   _print_ascii_file_h(&quot;Offline cpus&quot;, &quot;/sys/devices/system/cpu/offline&quot;, st);</span>
<span class="line-added">2495 </span>
<span class="line-added">2496   if (ExtensiveErrorReports) {</span>
<span class="line-added">2497     // cache related info (cpu 0, should be similar for other CPUs)</span>
<span class="line-added">2498     for (unsigned int i=0; i &lt; 10; i++) { // handle max. 10 cache entries</span>
<span class="line-added">2499       char hbuf_level[60];</span>
<span class="line-added">2500       char hbuf_type[60];</span>
<span class="line-added">2501       char hbuf_size[60];</span>
<span class="line-added">2502       char hbuf_coherency_line_size[80];</span>
<span class="line-added">2503       snprintf(hbuf_level, 60, &quot;/sys/devices/system/cpu/cpu0/cache/index%u/level&quot;, i);</span>
<span class="line-added">2504       snprintf(hbuf_type, 60, &quot;/sys/devices/system/cpu/cpu0/cache/index%u/type&quot;, i);</span>
<span class="line-added">2505       snprintf(hbuf_size, 60, &quot;/sys/devices/system/cpu/cpu0/cache/index%u/size&quot;, i);</span>
<span class="line-added">2506       snprintf(hbuf_coherency_line_size, 80, &quot;/sys/devices/system/cpu/cpu0/cache/index%u/coherency_line_size&quot;, i);</span>
<span class="line-added">2507       if (file_exists(hbuf_level)) {</span>
<span class="line-added">2508         _print_ascii_file_h(&quot;cache level&quot;, hbuf_level, st);</span>
<span class="line-added">2509         _print_ascii_file_h(&quot;cache type&quot;, hbuf_type, st);</span>
<span class="line-added">2510         _print_ascii_file_h(&quot;cache size&quot;, hbuf_size, st);</span>
<span class="line-added">2511         _print_ascii_file_h(&quot;cache coherency line size&quot;, hbuf_coherency_line_size, st);</span>
<span class="line-added">2512       }</span>
<span class="line-added">2513     }</span>
<span class="line-added">2514   }</span>
<span class="line-added">2515 </span>
<span class="line-added">2516   // we miss the cpufreq entries on Power and s390x</span>
<span class="line-added">2517 #if defined(IA32) || defined(AMD64)</span>
<span class="line-added">2518   _print_ascii_file_h(&quot;BIOS frequency limitation&quot;, &quot;/sys/devices/system/cpu/cpu0/cpufreq/bios_limit&quot;, st);</span>
<span class="line-added">2519   _print_ascii_file_h(&quot;Frequency switch latency (ns)&quot;, &quot;/sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_transition_latency&quot;, st);</span>
<span class="line-added">2520   _print_ascii_file_h(&quot;Available cpu frequencies&quot;, &quot;/sys/devices/system/cpu/cpu0/cpufreq/scaling_available_frequencies&quot;, st);</span>
<span class="line-added">2521   // min and max should be in the Available range but still print them (not all info might be available for all kernels)</span>
<span class="line-added">2522   if (ExtensiveErrorReports) {</span>
<span class="line-added">2523     _print_ascii_file_h(&quot;Maximum cpu frequency&quot;, &quot;/sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_max_freq&quot;, st);</span>
<span class="line-added">2524     _print_ascii_file_h(&quot;Minimum cpu frequency&quot;, &quot;/sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_min_freq&quot;, st);</span>
<span class="line-added">2525     _print_ascii_file_h(&quot;Current cpu frequency&quot;, &quot;/sys/devices/system/cpu/cpu0/cpufreq/scaling_cur_freq&quot;, st);</span>
<span class="line-added">2526   }</span>
<span class="line-added">2527   // governors are power schemes, see https://wiki.archlinux.org/index.php/CPU_frequency_scaling</span>
<span class="line-added">2528   if (ExtensiveErrorReports) {</span>
<span class="line-added">2529     _print_ascii_file_h(&quot;Available governors&quot;, &quot;/sys/devices/system/cpu/cpu0/cpufreq/scaling_available_governors&quot;, st);</span>
<span class="line-added">2530   }</span>
<span class="line-added">2531   _print_ascii_file_h(&quot;Current governor&quot;, &quot;/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor&quot;, st);</span>
<span class="line-added">2532   // Core performance boost, see https://www.kernel.org/doc/Documentation/cpu-freq/boost.txt</span>
<span class="line-added">2533   // Raise operating frequency of some cores in a multi-core package if certain conditions apply, e.g.</span>
<span class="line-added">2534   // whole chip is not fully utilized</span>
<span class="line-added">2535   _print_ascii_file_h(&quot;Core performance/turbo boost&quot;, &quot;/sys/devices/system/cpu/cpufreq/boost&quot;, st);</span>
<span class="line-added">2536 #endif</span>
<span class="line-added">2537 }</span>
<span class="line-added">2538 </span>
2539 void os::pd_print_cpu_info(outputStream* st, char* buf, size_t buflen) {
2540   // Only print the model name if the platform provides this as a summary
2541   if (!print_model_name_and_flags(st, buf, buflen)) {
<span class="line-modified">2542     _print_ascii_file_h(&quot;\n/proc/cpuinfo&quot;, &quot;/proc/cpuinfo&quot;, st);</span>



2543   }
<span class="line-added">2544   print_sys_devices_cpu_info(st, buf, buflen);</span>
2545 }
2546 
2547 #if defined(AMD64) || defined(IA32) || defined(X32)
2548 const char* search_string = &quot;model name&quot;;
2549 #elif defined(M68K)
2550 const char* search_string = &quot;CPU&quot;;
2551 #elif defined(PPC64)
2552 const char* search_string = &quot;cpu&quot;;
2553 #elif defined(S390)
2554 const char* search_string = &quot;machine =&quot;;
2555 #elif defined(SPARC)
2556 const char* search_string = &quot;cpu&quot;;
2557 #else
2558 const char* search_string = &quot;Processor&quot;;
2559 #endif
2560 
2561 // Parses the cpuinfo file for string representing the model name.
2562 void os::get_summary_cpu_info(char* cpuinfo, size_t length) {
2563   FILE* fp = fopen(&quot;/proc/cpuinfo&quot;, &quot;r&quot;);
2564   if (fp != NULL) {
</pre>
<hr />
<pre>
5210 }
5211 
5212 void os::Linux::numa_init() {
5213 
5214   // Java can be invoked as
5215   // 1. Without numactl and heap will be allocated/configured on all nodes as
5216   //    per the system policy.
5217   // 2. With numactl --interleave:
5218   //      Use numa_get_interleave_mask(v2) API to get nodes bitmask. The same
5219   //      API for membind case bitmask is reset.
5220   //      Interleave is only hint and Kernel can fallback to other nodes if
5221   //      no memory is available on the target nodes.
5222   // 3. With numactl --membind:
5223   //      Use numa_get_membind(v2) API to get nodes bitmask. The same API for
5224   //      interleave case returns bitmask of all nodes.
5225   // numa_all_nodes_ptr holds bitmask of all nodes.
5226   // numa_get_interleave_mask(v2) and numa_get_membind(v2) APIs returns correct
5227   // bitmask when externally configured to run on all or fewer nodes.
5228 
5229   if (!Linux::libnuma_init()) {
<span class="line-modified">5230     FLAG_SET_ERGO(UseNUMA, false);</span>
<span class="line-added">5231     FLAG_SET_ERGO(UseNUMAInterleaving, false); // Also depends on libnuma.</span>
5232   } else {
5233     if ((Linux::numa_max_node() &lt; 1) || Linux::is_bound_to_single_node()) {
5234       // If there&#39;s only one node (they start from 0) or if the process
5235       // is bound explicitly to a single node using membind, disable NUMA unless
5236       // user explicilty forces NUMA optimizations on single-node/UMA systems
5237       UseNUMA = ForceNUMA;
5238     } else {
5239 
5240       LogTarget(Info,os) log;
5241       LogStream ls(log);
5242 
5243       Linux::set_configured_numa_policy(Linux::identify_numa_policy());
5244 
5245       struct bitmask* bmp = Linux::_numa_membind_bitmask;
5246       const char* numa_mode = &quot;membind&quot;;
5247 
5248       if (Linux::is_running_in_interleave_mode()) {
5249         bmp = Linux::_numa_interleave_bitmask;
5250         numa_mode = &quot;interleave&quot;;
5251       }
5252 
5253       ls.print(&quot;UseNUMA is enabled and invoked in &#39;%s&#39; mode.&quot;
5254                &quot; Heap will be configured using NUMA memory nodes:&quot;, numa_mode);
5255 
5256       for (int node = 0; node &lt;= Linux::numa_max_node(); node++) {
5257         if (Linux::_numa_bitmask_isbitset(bmp, node)) {
5258           ls.print(&quot; %d&quot;, node);
5259         }
5260       }
5261     }
5262   }
5263 
<span class="line-added">5264   // When NUMA requested, not-NUMA-aware allocations default to interleaving.</span>
<span class="line-added">5265   if (UseNUMA &amp;&amp; !UseNUMAInterleaving) {</span>
<span class="line-added">5266     FLAG_SET_ERGO_IF_DEFAULT(UseNUMAInterleaving, true);</span>
<span class="line-added">5267   }</span>
<span class="line-added">5268 </span>
5269   if (UseParallelGC &amp;&amp; UseNUMA &amp;&amp; UseLargePages &amp;&amp; !can_commit_large_page_memory()) {
5270     // With SHM and HugeTLBFS large pages we cannot uncommit a page, so there&#39;s no way
5271     // we can make the adaptive lgrp chunk resizing work. If the user specified both
5272     // UseNUMA and UseLargePages (or UseSHM/UseHugeTLBFS) on the command line - warn
5273     // and disable adaptive resizing.
5274     if (UseAdaptiveSizePolicy || UseAdaptiveNUMAChunkSizing) {
5275       warning(&quot;UseNUMA is not fully compatible with SHM/HugeTLBFS large pages, &quot;
5276               &quot;disabling adaptive resizing (-XX:-UseAdaptiveSizePolicy -XX:-UseAdaptiveNUMAChunkSizing)&quot;);
5277       UseAdaptiveSizePolicy = false;
5278       UseAdaptiveNUMAChunkSizing = false;
5279     }
5280   }
5281 }
5282 
5283 // this is called _after_ the global arguments have been parsed
5284 jint os::init_2(void) {
5285 
5286   // This could be set after os::Posix::init() but all platforms
5287   // have to set it the same so we have to mirror Solaris.
5288   DEBUG_ONLY(os::set_mutex_init_done();)
</pre>
<hr />
<pre>
5313     return JNI_ERR;
5314   }
5315 
5316 #if defined(IA32)
5317   // Need to ensure we&#39;ve determined the process&#39;s initial stack to
5318   // perform the workaround
5319   Linux::capture_initial_stack(JavaThread::stack_size_at_create());
5320   workaround_expand_exec_shield_cs_limit();
5321 #else
5322   suppress_primordial_thread_resolution = Arguments::created_by_java_launcher();
5323   if (!suppress_primordial_thread_resolution) {
5324     Linux::capture_initial_stack(JavaThread::stack_size_at_create());
5325   }
5326 #endif
5327 
5328   Linux::libpthread_init();
5329   Linux::sched_getcpu_init();
5330   log_info(os)(&quot;HotSpot is running with %s, %s&quot;,
5331                Linux::glibc_version(), Linux::libpthread_version());
5332 
<span class="line-modified">5333   if (UseNUMA || UseNUMAInterleaving) {</span>
5334     Linux::numa_init();
5335   }
5336 
5337   if (MaxFDLimit) {
5338     // set the number of file descriptors to max. print out error
5339     // if getrlimit/setrlimit fails but continue regardless.
5340     struct rlimit nbr_files;
5341     int status = getrlimit(RLIMIT_NOFILE, &amp;nbr_files);
5342     if (status != 0) {
5343       log_info(os)(&quot;os::init_2 getrlimit failed: %s&quot;, os::strerror(errno));
5344     } else {
5345       nbr_files.rlim_cur = nbr_files.rlim_max;
5346       status = setrlimit(RLIMIT_NOFILE, &amp;nbr_files);
5347       if (status != 0) {
5348         log_info(os)(&quot;os::init_2 setrlimit failed: %s&quot;, os::strerror(errno));
5349       }
5350     }
5351   }
5352 
5353   // at-exit methods are called in the reverse order of their registration.
</pre>
</td>
</tr>
</table>
<center><a href="../../../../make/modules/jdk.jdwp.agent/Lib.gmk.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../share/utilities/globalDefinitions_gcc.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
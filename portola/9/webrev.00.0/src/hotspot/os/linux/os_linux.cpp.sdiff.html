<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os/linux/os_linux.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../../../../make/hotspot/lib/CompileJvm.gmk.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../share/gc/shared/genCollectedHeap.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/linux/os_linux.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  28 #include &quot;classfile/systemDictionary.hpp&quot;
  29 #include &quot;classfile/vmSymbols.hpp&quot;
  30 #include &quot;code/icBuffer.hpp&quot;
  31 #include &quot;code/vtableStubs.hpp&quot;
  32 #include &quot;compiler/compileBroker.hpp&quot;
  33 #include &quot;compiler/disassembler.hpp&quot;
  34 #include &quot;interpreter/interpreter.hpp&quot;
  35 #include &quot;logging/log.hpp&quot;
  36 #include &quot;logging/logStream.hpp&quot;
  37 #include &quot;memory/allocation.inline.hpp&quot;
  38 #include &quot;memory/filemap.hpp&quot;
  39 #include &quot;oops/oop.inline.hpp&quot;
  40 #include &quot;os_linux.inline.hpp&quot;
  41 #include &quot;os_posix.inline.hpp&quot;
  42 #include &quot;os_share_linux.hpp&quot;
  43 #include &quot;osContainer_linux.hpp&quot;
  44 #include &quot;prims/jniFastGetField.hpp&quot;
  45 #include &quot;prims/jvm_misc.hpp&quot;
  46 #include &quot;runtime/arguments.hpp&quot;
  47 #include &quot;runtime/atomic.hpp&quot;
<span class="line-removed">  48 #include &quot;runtime/extendedPC.hpp&quot;</span>
  49 #include &quot;runtime/globals.hpp&quot;
  50 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  51 #include &quot;runtime/init.hpp&quot;
  52 #include &quot;runtime/java.hpp&quot;
  53 #include &quot;runtime/javaCalls.hpp&quot;
  54 #include &quot;runtime/mutexLocker.hpp&quot;
  55 #include &quot;runtime/objectMonitor.hpp&quot;
  56 #include &quot;runtime/osThread.hpp&quot;
  57 #include &quot;runtime/perfMemory.hpp&quot;
  58 #include &quot;runtime/sharedRuntime.hpp&quot;
  59 #include &quot;runtime/statSampler.hpp&quot;
  60 #include &quot;runtime/stubRoutines.hpp&quot;
  61 #include &quot;runtime/thread.inline.hpp&quot;
  62 #include &quot;runtime/threadCritical.hpp&quot;
  63 #include &quot;runtime/threadSMR.hpp&quot;
  64 #include &quot;runtime/timer.hpp&quot;
  65 #include &quot;runtime/vm_version.hpp&quot;
  66 #include &quot;semaphore_posix.hpp&quot;
  67 #include &quot;services/attachListener.hpp&quot;
  68 #include &quot;services/memTracker.hpp&quot;
</pre>
<hr />
<pre>
3253       set_numa_bitmask_isbitset(CAST_TO_FN_PTR(numa_bitmask_isbitset_func_t,
3254                                                libnuma_dlsym(handle, &quot;numa_bitmask_isbitset&quot;)));
3255       set_numa_distance(CAST_TO_FN_PTR(numa_distance_func_t,
3256                                        libnuma_dlsym(handle, &quot;numa_distance&quot;)));
3257       set_numa_get_membind(CAST_TO_FN_PTR(numa_get_membind_func_t,
3258                                           libnuma_v2_dlsym(handle, &quot;numa_get_membind&quot;)));
3259       set_numa_get_interleave_mask(CAST_TO_FN_PTR(numa_get_interleave_mask_func_t,
3260                                                   libnuma_v2_dlsym(handle, &quot;numa_get_interleave_mask&quot;)));
3261       set_numa_move_pages(CAST_TO_FN_PTR(numa_move_pages_func_t,
3262                                          libnuma_dlsym(handle, &quot;numa_move_pages&quot;)));
3263       set_numa_set_preferred(CAST_TO_FN_PTR(numa_set_preferred_func_t,
3264                                             libnuma_dlsym(handle, &quot;numa_set_preferred&quot;)));
3265 
3266       if (numa_available() != -1) {
3267         set_numa_all_nodes((unsigned long*)libnuma_dlsym(handle, &quot;numa_all_nodes&quot;));
3268         set_numa_all_nodes_ptr((struct bitmask **)libnuma_dlsym(handle, &quot;numa_all_nodes_ptr&quot;));
3269         set_numa_nodes_ptr((struct bitmask **)libnuma_dlsym(handle, &quot;numa_nodes_ptr&quot;));
3270         set_numa_interleave_bitmask(_numa_get_interleave_mask());
3271         set_numa_membind_bitmask(_numa_get_membind());
3272         // Create an index -&gt; node mapping, since nodes are not always consecutive
<span class="line-modified">3273         _nindex_to_node = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;int&gt;(0, true);</span>
3274         rebuild_nindex_to_node_map();
3275         // Create a cpu -&gt; node mapping
<span class="line-modified">3276         _cpu_to_node = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;int&gt;(0, true);</span>
3277         rebuild_cpu_to_node_map();
3278         return true;
3279       }
3280     }
3281   }
3282   return false;
3283 }
3284 
3285 size_t os::Linux::default_guard_size(os::ThreadType thr_type) {
3286   // Creating guard page is very expensive. Java thread has HotSpot
3287   // guard pages, only enable glibc guard page for non-Java threads.
3288   // (Remember: compiler thread is a Java thread, too!)
3289   return ((thr_type == java_thread || thr_type == compiler_thread) ? 0 : page_size());
3290 }
3291 
3292 void os::Linux::rebuild_nindex_to_node_map() {
3293   int highest_node_number = Linux::numa_max_node();
3294 
3295   nindex_to_node()-&gt;clear();
3296   for (int node = 0; node &lt;= highest_node_number; node++) {
</pre>
<hr />
<pre>
4484 //  within hotspot. Currently used by JFR&#39;s OSThreadSampler
4485 //
4486 //  The remaining code is greatly simplified from the more general suspension
4487 //  code that used to be used.
4488 //
4489 //  The protocol is quite simple:
4490 //  - suspend:
4491 //      - sends a signal to the target thread
4492 //      - polls the suspend state of the osthread using a yield loop
4493 //      - target thread signal handler (SR_handler) sets suspend state
4494 //        and blocks in sigsuspend until continued
4495 //  - resume:
4496 //      - sets target osthread state to continue
4497 //      - sends signal to end the sigsuspend loop in the SR_handler
4498 //
4499 //  Note that the SR_lock plays no role in this suspend/resume protocol,
4500 //  but is checked for NULL in SR_handler as a thread termination indicator.
4501 //  The SR_lock is, however, used by JavaThread::java_suspend()/java_resume() APIs.
4502 //
4503 //  Note that resume_clear_context() and suspend_save_context() are needed
<span class="line-modified">4504 //  by SR_handler(), so that fetch_frame_from_ucontext() works,</span>
4505 //  which in part is used by:
4506 //    - Forte Analyzer: AsyncGetCallTrace()
4507 //    - StackBanging: get_frame_at_stack_banging_point()
4508 
4509 static void resume_clear_context(OSThread *osthread) {
4510   osthread-&gt;set_ucontext(NULL);
4511   osthread-&gt;set_siginfo(NULL);
4512 }
4513 
4514 static void suspend_save_context(OSThread *osthread, siginfo_t* siginfo,
4515                                  ucontext_t* context) {
4516   osthread-&gt;set_ucontext(context);
4517   osthread-&gt;set_siginfo(siginfo);
4518 }
4519 
4520 // Handler function invoked when a thread&#39;s execution is suspended or
4521 // resumed. We have to be careful that only async-safe functions are
4522 // called here (Note: most pthread functions are not async safe and
4523 // should be avoided.)
4524 //
</pre>
</td>
<td>
<hr />
<pre>
  28 #include &quot;classfile/systemDictionary.hpp&quot;
  29 #include &quot;classfile/vmSymbols.hpp&quot;
  30 #include &quot;code/icBuffer.hpp&quot;
  31 #include &quot;code/vtableStubs.hpp&quot;
  32 #include &quot;compiler/compileBroker.hpp&quot;
  33 #include &quot;compiler/disassembler.hpp&quot;
  34 #include &quot;interpreter/interpreter.hpp&quot;
  35 #include &quot;logging/log.hpp&quot;
  36 #include &quot;logging/logStream.hpp&quot;
  37 #include &quot;memory/allocation.inline.hpp&quot;
  38 #include &quot;memory/filemap.hpp&quot;
  39 #include &quot;oops/oop.inline.hpp&quot;
  40 #include &quot;os_linux.inline.hpp&quot;
  41 #include &quot;os_posix.inline.hpp&quot;
  42 #include &quot;os_share_linux.hpp&quot;
  43 #include &quot;osContainer_linux.hpp&quot;
  44 #include &quot;prims/jniFastGetField.hpp&quot;
  45 #include &quot;prims/jvm_misc.hpp&quot;
  46 #include &quot;runtime/arguments.hpp&quot;
  47 #include &quot;runtime/atomic.hpp&quot;

  48 #include &quot;runtime/globals.hpp&quot;
  49 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  50 #include &quot;runtime/init.hpp&quot;
  51 #include &quot;runtime/java.hpp&quot;
  52 #include &quot;runtime/javaCalls.hpp&quot;
  53 #include &quot;runtime/mutexLocker.hpp&quot;
  54 #include &quot;runtime/objectMonitor.hpp&quot;
  55 #include &quot;runtime/osThread.hpp&quot;
  56 #include &quot;runtime/perfMemory.hpp&quot;
  57 #include &quot;runtime/sharedRuntime.hpp&quot;
  58 #include &quot;runtime/statSampler.hpp&quot;
  59 #include &quot;runtime/stubRoutines.hpp&quot;
  60 #include &quot;runtime/thread.inline.hpp&quot;
  61 #include &quot;runtime/threadCritical.hpp&quot;
  62 #include &quot;runtime/threadSMR.hpp&quot;
  63 #include &quot;runtime/timer.hpp&quot;
  64 #include &quot;runtime/vm_version.hpp&quot;
  65 #include &quot;semaphore_posix.hpp&quot;
  66 #include &quot;services/attachListener.hpp&quot;
  67 #include &quot;services/memTracker.hpp&quot;
</pre>
<hr />
<pre>
3252       set_numa_bitmask_isbitset(CAST_TO_FN_PTR(numa_bitmask_isbitset_func_t,
3253                                                libnuma_dlsym(handle, &quot;numa_bitmask_isbitset&quot;)));
3254       set_numa_distance(CAST_TO_FN_PTR(numa_distance_func_t,
3255                                        libnuma_dlsym(handle, &quot;numa_distance&quot;)));
3256       set_numa_get_membind(CAST_TO_FN_PTR(numa_get_membind_func_t,
3257                                           libnuma_v2_dlsym(handle, &quot;numa_get_membind&quot;)));
3258       set_numa_get_interleave_mask(CAST_TO_FN_PTR(numa_get_interleave_mask_func_t,
3259                                                   libnuma_v2_dlsym(handle, &quot;numa_get_interleave_mask&quot;)));
3260       set_numa_move_pages(CAST_TO_FN_PTR(numa_move_pages_func_t,
3261                                          libnuma_dlsym(handle, &quot;numa_move_pages&quot;)));
3262       set_numa_set_preferred(CAST_TO_FN_PTR(numa_set_preferred_func_t,
3263                                             libnuma_dlsym(handle, &quot;numa_set_preferred&quot;)));
3264 
3265       if (numa_available() != -1) {
3266         set_numa_all_nodes((unsigned long*)libnuma_dlsym(handle, &quot;numa_all_nodes&quot;));
3267         set_numa_all_nodes_ptr((struct bitmask **)libnuma_dlsym(handle, &quot;numa_all_nodes_ptr&quot;));
3268         set_numa_nodes_ptr((struct bitmask **)libnuma_dlsym(handle, &quot;numa_nodes_ptr&quot;));
3269         set_numa_interleave_bitmask(_numa_get_interleave_mask());
3270         set_numa_membind_bitmask(_numa_get_membind());
3271         // Create an index -&gt; node mapping, since nodes are not always consecutive
<span class="line-modified">3272         _nindex_to_node = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;int&gt;(0, mtInternal);</span>
3273         rebuild_nindex_to_node_map();
3274         // Create a cpu -&gt; node mapping
<span class="line-modified">3275         _cpu_to_node = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;int&gt;(0, mtInternal);</span>
3276         rebuild_cpu_to_node_map();
3277         return true;
3278       }
3279     }
3280   }
3281   return false;
3282 }
3283 
3284 size_t os::Linux::default_guard_size(os::ThreadType thr_type) {
3285   // Creating guard page is very expensive. Java thread has HotSpot
3286   // guard pages, only enable glibc guard page for non-Java threads.
3287   // (Remember: compiler thread is a Java thread, too!)
3288   return ((thr_type == java_thread || thr_type == compiler_thread) ? 0 : page_size());
3289 }
3290 
3291 void os::Linux::rebuild_nindex_to_node_map() {
3292   int highest_node_number = Linux::numa_max_node();
3293 
3294   nindex_to_node()-&gt;clear();
3295   for (int node = 0; node &lt;= highest_node_number; node++) {
</pre>
<hr />
<pre>
4483 //  within hotspot. Currently used by JFR&#39;s OSThreadSampler
4484 //
4485 //  The remaining code is greatly simplified from the more general suspension
4486 //  code that used to be used.
4487 //
4488 //  The protocol is quite simple:
4489 //  - suspend:
4490 //      - sends a signal to the target thread
4491 //      - polls the suspend state of the osthread using a yield loop
4492 //      - target thread signal handler (SR_handler) sets suspend state
4493 //        and blocks in sigsuspend until continued
4494 //  - resume:
4495 //      - sets target osthread state to continue
4496 //      - sends signal to end the sigsuspend loop in the SR_handler
4497 //
4498 //  Note that the SR_lock plays no role in this suspend/resume protocol,
4499 //  but is checked for NULL in SR_handler as a thread termination indicator.
4500 //  The SR_lock is, however, used by JavaThread::java_suspend()/java_resume() APIs.
4501 //
4502 //  Note that resume_clear_context() and suspend_save_context() are needed
<span class="line-modified">4503 //  by SR_handler(), so that fetch_frame_from_context() works,</span>
4504 //  which in part is used by:
4505 //    - Forte Analyzer: AsyncGetCallTrace()
4506 //    - StackBanging: get_frame_at_stack_banging_point()
4507 
4508 static void resume_clear_context(OSThread *osthread) {
4509   osthread-&gt;set_ucontext(NULL);
4510   osthread-&gt;set_siginfo(NULL);
4511 }
4512 
4513 static void suspend_save_context(OSThread *osthread, siginfo_t* siginfo,
4514                                  ucontext_t* context) {
4515   osthread-&gt;set_ucontext(context);
4516   osthread-&gt;set_siginfo(siginfo);
4517 }
4518 
4519 // Handler function invoked when a thread&#39;s execution is suspended or
4520 // resumed. We have to be careful that only async-safe functions are
4521 // called here (Note: most pthread functions are not async safe and
4522 // should be avoided.)
4523 //
</pre>
</td>
</tr>
</table>
<center><a href="../../../../make/hotspot/lib/CompileJvm.gmk.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../share/gc/shared/genCollectedHeap.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
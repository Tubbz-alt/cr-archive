<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shared/genCollectedHeap.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../../../os/linux/os_linux.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../../../../jdk.hotspot.agent/linux/native/libsaproc/ps_proc.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/genCollectedHeap.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1100 
1101 HeapWord* GenCollectedHeap::allocate_new_tlab(size_t min_size,
1102                                               size_t requested_size,
1103                                               size_t* actual_size) {
1104   bool gc_overhead_limit_was_exceeded;
1105   HeapWord* result = mem_allocate_work(requested_size /* size */,
1106                                        true /* is_tlab */,
1107                                        &amp;gc_overhead_limit_was_exceeded);
1108   if (result != NULL) {
1109     *actual_size = requested_size;
1110   }
1111 
1112   return result;
1113 }
1114 
1115 // Requires &quot;*prev_ptr&quot; to be non-NULL.  Deletes and a block of minimal size
1116 // from the list headed by &quot;*prev_ptr&quot;.
1117 static ScratchBlock *removeSmallestScratch(ScratchBlock **prev_ptr) {
1118   bool first = true;
1119   size_t min_size = 0;   // &quot;first&quot; makes this conceptually infinite.
<span class="line-modified">1120   ScratchBlock **smallest_ptr, *smallest;</span>
1121   ScratchBlock  *cur = *prev_ptr;
1122   while (cur) {
1123     assert(*prev_ptr == cur, &quot;just checking&quot;);
1124     if (first || cur-&gt;num_words &lt; min_size) {
1125       smallest_ptr = prev_ptr;
1126       smallest     = cur;
1127       min_size     = smallest-&gt;num_words;
1128       first        = false;
1129     }
1130     prev_ptr = &amp;cur-&gt;next;
1131     cur     =  cur-&gt;next;
1132   }
1133   smallest      = *smallest_ptr;
1134   *smallest_ptr = smallest-&gt;next;
1135   return smallest;
1136 }
1137 
1138 // Sort the scratch block list headed by res into decreasing size order,
1139 // and set &quot;res&quot; to the result.
1140 static void sort_scratch_list(ScratchBlock*&amp; list) {
</pre>
</td>
<td>
<hr />
<pre>
1100 
1101 HeapWord* GenCollectedHeap::allocate_new_tlab(size_t min_size,
1102                                               size_t requested_size,
1103                                               size_t* actual_size) {
1104   bool gc_overhead_limit_was_exceeded;
1105   HeapWord* result = mem_allocate_work(requested_size /* size */,
1106                                        true /* is_tlab */,
1107                                        &amp;gc_overhead_limit_was_exceeded);
1108   if (result != NULL) {
1109     *actual_size = requested_size;
1110   }
1111 
1112   return result;
1113 }
1114 
1115 // Requires &quot;*prev_ptr&quot; to be non-NULL.  Deletes and a block of minimal size
1116 // from the list headed by &quot;*prev_ptr&quot;.
1117 static ScratchBlock *removeSmallestScratch(ScratchBlock **prev_ptr) {
1118   bool first = true;
1119   size_t min_size = 0;   // &quot;first&quot; makes this conceptually infinite.
<span class="line-modified">1120   ScratchBlock **smallest_ptr = NULL, *smallest;</span>
1121   ScratchBlock  *cur = *prev_ptr;
1122   while (cur) {
1123     assert(*prev_ptr == cur, &quot;just checking&quot;);
1124     if (first || cur-&gt;num_words &lt; min_size) {
1125       smallest_ptr = prev_ptr;
1126       smallest     = cur;
1127       min_size     = smallest-&gt;num_words;
1128       first        = false;
1129     }
1130     prev_ptr = &amp;cur-&gt;next;
1131     cur     =  cur-&gt;next;
1132   }
1133   smallest      = *smallest_ptr;
1134   *smallest_ptr = smallest-&gt;next;
1135   return smallest;
1136 }
1137 
1138 // Sort the scratch block list headed by res into decreasing size order,
1139 // and set &quot;res&quot; to the result.
1140 static void sort_scratch_list(ScratchBlock*&amp; list) {
</pre>
</td>
</tr>
</table>
<center><a href="../../../os/linux/os_linux.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../../../../jdk.hotspot.agent/linux/native/libsaproc/ps_proc.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TypeEnter.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.comp;
  27 
  28 import java.util.ArrayList;
  29 import java.util.HashSet;
  30 import java.util.Set;
  31 import java.util.function.BiConsumer;
  32 import java.util.stream.Collectors;
  33 
  34 import javax.tools.JavaFileObject;
  35 
  36 import com.sun.tools.javac.code.*;
  37 import com.sun.tools.javac.code.Lint.LintCategory;
  38 import com.sun.tools.javac.code.Scope.ImportFilter;
  39 import com.sun.tools.javac.code.Scope.NamedImportScope;
  40 import com.sun.tools.javac.code.Scope.StarImportScope;
  41 import com.sun.tools.javac.code.Scope.WriteableScope;
  42 import com.sun.tools.javac.code.Source.Feature;
  43 import com.sun.tools.javac.comp.Annotate.AnnotationTypeMetadata;
  44 import com.sun.tools.javac.tree.*;
  45 import com.sun.tools.javac.util.*;
  46 import com.sun.tools.javac.util.DefinedBy.Api;
  47 
  48 import com.sun.tools.javac.code.Symbol.*;
  49 import com.sun.tools.javac.code.Type.*;
  50 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  51 import com.sun.tools.javac.tree.JCTree.*;
  52 
  53 import static com.sun.tools.javac.code.Flags.*;
  54 import static com.sun.tools.javac.code.Flags.ANNOTATION;
  55 import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;
  56 import static com.sun.tools.javac.code.Kinds.Kind.*;
  57 import static com.sun.tools.javac.code.TypeTag.CLASS;
  58 import static com.sun.tools.javac.code.TypeTag.ERROR;
  59 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  60 
  61 import static com.sun.tools.javac.code.TypeTag.*;
  62 import static com.sun.tools.javac.code.TypeTag.BOT;
<a name="1" id="anc1"></a>

  63 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  64 
  65 import com.sun.tools.javac.util.Dependencies.CompletionCause;
  66 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
  67 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  68 
  69 /** This is the second phase of Enter, in which classes are completed
  70  *  by resolving their headers and entering their members in the into
  71  *  the class scope. See Enter for an overall overview.
  72  *
  73  *  This class uses internal phases to process the classes. When a phase
  74  *  processes classes, the lower phases are not invoked until all classes
  75  *  pass through the current phase. Note that it is possible that upper phases
  76  *  are run due to recursive completion. The internal phases are:
  77  *  - ImportPhase: shallow pass through imports, adds information about imports
  78  *                 the NamedImportScope and StarImportScope, but avoids queries
  79  *                 about class hierarchy.
  80  *  - HierarchyPhase: resolves the supertypes of the given class. Does not handle
  81  *                    type parameters of the class or type argument of the supertypes.
  82  *  - HeaderPhase: finishes analysis of the header of the given class by resolving
  83  *                 type parameters, attributing supertypes including type arguments
  84  *                 and scheduling full annotation attribution. This phase also adds
  85  *                 a synthetic default constructor if needed and synthetic &quot;this&quot; field.
  86  *  - MembersPhase: resolves headers for fields, methods and constructors in the given class.
  87  *                  Also generates synthetic enum members.
  88  *
  89  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  90  *  If you write code that depends on this, you do so at your own risk.
  91  *  This code and its internal interfaces are subject to change or
  92  *  deletion without notice.&lt;/b&gt;
  93  */
  94 public class TypeEnter implements Completer {
  95     protected static final Context.Key&lt;TypeEnter&gt; typeEnterKey = new Context.Key&lt;&gt;();
  96 
  97     /** A switch to determine whether we check for package/class conflicts
  98      */
  99     final static boolean checkClash = true;
 100 
 101     private final Names names;
 102     private final Enter enter;
 103     private final MemberEnter memberEnter;
 104     private final Log log;
 105     private final Check chk;
 106     private final Attr attr;
 107     private final Symtab syms;
 108     private final TreeMaker make;
 109     private final Todo todo;
 110     private final Annotate annotate;
 111     private final TypeAnnotations typeAnnotations;
 112     private final Types types;
 113     private final JCDiagnostic.Factory diags;
 114     private final DeferredLintHandler deferredLintHandler;
 115     private final Lint lint;
 116     private final TypeEnvs typeEnvs;
 117     private final Dependencies dependencies;
 118 
 119     public static TypeEnter instance(Context context) {
 120         TypeEnter instance = context.get(typeEnterKey);
 121         if (instance == null)
 122             instance = new TypeEnter(context);
 123         return instance;
 124     }
 125 
 126     protected TypeEnter(Context context) {
 127         context.put(typeEnterKey, this);
 128         names = Names.instance(context);
 129         enter = Enter.instance(context);
 130         memberEnter = MemberEnter.instance(context);
 131         log = Log.instance(context);
 132         chk = Check.instance(context);
 133         attr = Attr.instance(context);
 134         syms = Symtab.instance(context);
 135         make = TreeMaker.instance(context);
 136         todo = Todo.instance(context);
 137         annotate = Annotate.instance(context);
 138         typeAnnotations = TypeAnnotations.instance(context);
 139         types = Types.instance(context);
 140         diags = JCDiagnostic.Factory.instance(context);
 141         deferredLintHandler = DeferredLintHandler.instance(context);
 142         lint = Lint.instance(context);
 143         typeEnvs = TypeEnvs.instance(context);
 144         dependencies = Dependencies.instance(context);
 145         Source source = Source.instance(context);
 146         allowTypeAnnos = Feature.TYPE_ANNOTATIONS.allowedInSource(source);
 147         allowDeprecationOnImport = Feature.DEPRECATION_ON_IMPORT.allowedInSource(source);
 148     }
 149 
 150     /** Switch: support type annotations.
 151      */
 152     boolean allowTypeAnnos;
 153 
 154     /**
 155      * Switch: should deprecation warnings be issued on import
 156      */
 157     boolean allowDeprecationOnImport;
 158 
 159     /** A flag to disable completion from time to time during member
 160      *  enter, as we only need to look up types.  This avoids
 161      *  unnecessarily deep recursion.
 162      */
 163     boolean completionEnabled = true;
 164 
 165     /* Verify Imports:
 166      */
 167     protected void ensureImportsChecked(List&lt;JCCompilationUnit&gt; trees) {
 168         // if there remain any unimported toplevels (these must have
 169         // no classes at all), process their import statements as well.
 170         for (JCCompilationUnit tree : trees) {
 171             if (!tree.starImportScope.isFilled()) {
 172                 Env&lt;AttrContext&gt; topEnv = enter.topLevelEnv(tree);
 173                 finishImports(tree, () -&gt; { completeClass.resolveImports(tree, topEnv); });
 174             }
 175         }
 176     }
 177 
 178 /* ********************************************************************
 179  * Source completer
 180  *********************************************************************/
 181 
 182     /** Complete entering a class.
 183      *  @param sym         The symbol of the class to be completed.
 184      */
 185     @Override
 186     public void complete(Symbol sym) throws CompletionFailure {
 187         // Suppress some (recursive) MemberEnter invocations
 188         if (!completionEnabled) {
 189             // Re-install same completer for next time around and return.
 190             Assert.check((sym.flags() &amp; Flags.COMPOUND) == 0);
 191             sym.completer = this;
 192             return;
 193         }
 194 
 195         try {
 196             annotate.blockAnnotations();
 197             sym.flags_field |= UNATTRIBUTED;
 198 
 199             List&lt;Env&lt;AttrContext&gt;&gt; queue;
 200 
 201             dependencies.push((ClassSymbol) sym, CompletionCause.MEMBER_ENTER);
 202             try {
 203                 queue = completeClass.completeEnvs(List.of(typeEnvs.get((ClassSymbol) sym)));
 204             } finally {
 205                 dependencies.pop();
 206             }
 207 
 208             if (!queue.isEmpty()) {
 209                 Set&lt;JCCompilationUnit&gt; seen = new HashSet&lt;&gt;();
 210 
 211                 for (Env&lt;AttrContext&gt; env : queue) {
 212                     if (env.toplevel.defs.contains(env.enclClass) &amp;&amp; seen.add(env.toplevel)) {
 213                         finishImports(env.toplevel, () -&gt; {});
 214                     }
 215                 }
 216             }
 217         } finally {
 218             annotate.unblockAnnotations();
 219         }
 220     }
 221 
 222     void finishImports(JCCompilationUnit toplevel, Runnable resolve) {
 223         JavaFileObject prev = log.useSource(toplevel.sourcefile);
 224         try {
 225             resolve.run();
 226             chk.checkImportsUnique(toplevel);
 227             chk.checkImportsResolvable(toplevel);
 228             chk.checkImportedPackagesObservable(toplevel);
 229             toplevel.namedImportScope.finalizeScope();
 230             toplevel.starImportScope.finalizeScope();
 231         } catch (CompletionFailure cf) {
 232             chk.completionError(toplevel.pos(), cf);
 233         } finally {
 234             log.useSource(prev);
 235         }
 236     }
 237 
 238     abstract class Phase {
 239         private final ListBuffer&lt;Env&lt;AttrContext&gt;&gt; queue = new ListBuffer&lt;&gt;();
 240         private final Phase next;
 241         private final CompletionCause phaseName;
 242 
 243         Phase(CompletionCause phaseName, Phase next) {
 244             this.phaseName = phaseName;
 245             this.next = next;
 246         }
 247 
 248         public final List&lt;Env&lt;AttrContext&gt;&gt; completeEnvs(List&lt;Env&lt;AttrContext&gt;&gt; envs) {
 249             boolean firstToComplete = queue.isEmpty();
 250 
 251             Phase prevTopLevelPhase = topLevelPhase;
 252             boolean success = false;
 253 
 254             try {
 255                 topLevelPhase = this;
 256                 doCompleteEnvs(envs);
 257                 success = true;
 258             } finally {
 259                 topLevelPhase = prevTopLevelPhase;
 260                 if (!success &amp;&amp; firstToComplete) {
 261                     //an exception was thrown, e.g. BreakAttr:
 262                     //the queue would become stale, clear it:
 263                     queue.clear();
 264                 }
 265             }
 266 
 267             if (firstToComplete) {
 268                 List&lt;Env&lt;AttrContext&gt;&gt; out = queue.toList();
 269 
 270                 queue.clear();
 271                 return next != null ? next.completeEnvs(out) : out;
 272             } else {
 273                 return List.nil();
 274             }
 275         }
 276 
 277         protected void doCompleteEnvs(List&lt;Env&lt;AttrContext&gt;&gt; envs) {
 278             for (Env&lt;AttrContext&gt; env : envs) {
 279                 JCClassDecl tree = (JCClassDecl)env.tree;
 280 
 281                 queue.add(env);
 282 
 283                 JavaFileObject prev = log.useSource(env.toplevel.sourcefile);
 284                 DiagnosticPosition prevLintPos = deferredLintHandler.setPos(tree.pos());
 285                 try {
 286                     dependencies.push(env.enclClass.sym, phaseName);
 287                     runPhase(env);
 288                 } catch (CompletionFailure ex) {
 289                     chk.completionError(tree.pos(), ex);
 290                 } finally {
 291                     dependencies.pop();
 292                     deferredLintHandler.setPos(prevLintPos);
 293                     log.useSource(prev);
 294                 }
 295             }
 296         }
 297 
 298         protected abstract void runPhase(Env&lt;AttrContext&gt; env);
 299     }
 300 
 301     private final ImportsPhase completeClass = new ImportsPhase();
 302     private Phase topLevelPhase;
 303 
 304     /**Analyze import clauses.
 305      */
 306     private final class ImportsPhase extends Phase {
 307 
 308         public ImportsPhase() {
 309             super(CompletionCause.IMPORTS_PHASE, new HierarchyPhase());
 310         }
 311 
 312         Env&lt;AttrContext&gt; env;
 313         ImportFilter staticImportFilter;
 314         ImportFilter typeImportFilter;
 315         BiConsumer&lt;JCImport, CompletionFailure&gt; cfHandler =
 316                 (imp, cf) -&gt; chk.completionError(imp.pos(), cf);
 317 
 318         @Override
 319         protected void runPhase(Env&lt;AttrContext&gt; env) {
 320             JCClassDecl tree = env.enclClass;
 321             ClassSymbol sym = tree.sym;
 322 
 323             // If sym is a toplevel-class, make sure any import
 324             // clauses in its source file have been seen.
 325             if (sym.owner.kind == PCK) {
 326                 resolveImports(env.toplevel, env.enclosing(TOPLEVEL));
 327                 todo.append(env);
 328             }
 329 
 330             if (sym.owner.kind == TYP)
 331                 sym.owner.complete();
 332         }
 333 
 334         private void resolveImports(JCCompilationUnit tree, Env&lt;AttrContext&gt; env) {
 335             if (tree.starImportScope.isFilled()) {
 336                 // we must have already processed this toplevel
 337                 return;
 338             }
 339 
 340             ImportFilter prevStaticImportFilter = staticImportFilter;
 341             ImportFilter prevTypeImportFilter = typeImportFilter;
 342             DiagnosticPosition prevLintPos = deferredLintHandler.immediate();
 343             Lint prevLint = chk.setLint(lint);
 344             Env&lt;AttrContext&gt; prevEnv = this.env;
 345             try {
 346                 this.env = env;
 347                 final PackageSymbol packge = env.toplevel.packge;
 348                 this.staticImportFilter =
 349                         (origin, sym) -&gt; sym.isStatic() &amp;&amp;
 350                                          chk.importAccessible(sym, packge) &amp;&amp;
 351                                          sym.isMemberOf((TypeSymbol) origin.owner, types);
 352                 this.typeImportFilter =
 353                         (origin, sym) -&gt; sym.kind == TYP &amp;&amp;
 354                                          chk.importAccessible(sym, packge);
 355 
 356                 // Import-on-demand java.lang.
 357                 PackageSymbol javaLang = syms.enterPackage(syms.java_base, names.java_lang);
 358                 if (javaLang.members().isEmpty() &amp;&amp; !javaLang.exists())
 359                     throw new FatalError(diags.fragment(Fragments.FatalErrNoJavaLang));
 360                 importAll(make.at(tree.pos()).Import(make.QualIdent(javaLang), false), javaLang, env);
 361 
 362                 JCModuleDecl decl = tree.getModuleDecl();
 363 
 364                 // Process the package def and all import clauses.
 365                 if (tree.getPackage() != null &amp;&amp; decl == null)
 366                     checkClassPackageClash(tree.getPackage());
 367 
 368                 for (JCImport imp : tree.getImports()) {
 369                     doImport(imp);
 370                 }
 371 
 372                 if (decl != null) {
 373                     //check @Deprecated:
 374                     markDeprecated(decl.sym, decl.mods.annotations, env);
 375                     // process module annotations
 376                     annotate.annotateLater(decl.mods.annotations, env, env.toplevel.modle, null);
 377                 }
 378             } finally {
 379                 this.env = prevEnv;
 380                 chk.setLint(prevLint);
 381                 deferredLintHandler.setPos(prevLintPos);
 382                 this.staticImportFilter = prevStaticImportFilter;
 383                 this.typeImportFilter = prevTypeImportFilter;
 384             }
 385         }
 386 
 387         private void checkClassPackageClash(JCPackageDecl tree) {
 388             // check that no class exists with same fully qualified name as
 389             // toplevel package
 390             if (checkClash &amp;&amp; tree.pid != null) {
 391                 Symbol p = env.toplevel.packge;
 392                 while (p.owner != syms.rootPackage) {
 393                     p.owner.complete(); // enter all class members of p
 394                     //need to lookup the owning module/package:
 395                     PackageSymbol pack = syms.lookupPackage(env.toplevel.modle, p.owner.getQualifiedName());
 396                     if (syms.getClass(pack.modle, p.getQualifiedName()) != null) {
 397                         log.error(tree.pos,
 398                                   Errors.PkgClashesWithClassOfSameName(p));
 399                     }
 400                     p = p.owner;
 401                 }
 402             }
 403             // process package annotations
 404             annotate.annotateLater(tree.annotations, env, env.toplevel.packge, null);
 405         }
 406 
 407         private void doImport(JCImport tree) {
 408             JCFieldAccess imp = (JCFieldAccess)tree.qualid;
 409             Name name = TreeInfo.name(imp);
 410 
 411             // Create a local environment pointing to this tree to disable
 412             // effects of other imports in Resolve.findGlobalType
 413             Env&lt;AttrContext&gt; localEnv = env.dup(tree);
 414 
 415             TypeSymbol p = attr.attribImportQualifier(tree, localEnv).tsym;
 416             if (name == names.asterisk) {
 417                 // Import on demand.
 418                 chk.checkCanonical(imp.selected);
 419                 if (tree.staticImport)
 420                     importStaticAll(tree, p, env);
 421                 else
 422                     importAll(tree, p, env);
 423             } else {
 424                 // Named type import.
 425                 if (tree.staticImport) {
 426                     importNamedStatic(tree, p, name, localEnv);
 427                     chk.checkCanonical(imp.selected);
 428                 } else {
 429                     Type importedType = attribImportType(imp, localEnv);
 430                     Type originalType = importedType.getOriginalType();
 431                     TypeSymbol c = originalType.hasTag(CLASS) ? originalType.tsym : importedType.tsym;
 432                     chk.checkCanonical(imp);
 433                     importNamed(tree.pos(), c, env, tree);
 434                 }
 435             }
 436         }
 437 
 438         Type attribImportType(JCTree tree, Env&lt;AttrContext&gt; env) {
 439             Assert.check(completionEnabled);
 440             Lint prevLint = chk.setLint(allowDeprecationOnImport ?
 441                     lint : lint.suppress(LintCategory.DEPRECATION, LintCategory.REMOVAL, LintCategory.PREVIEW));
 442             try {
 443                 // To prevent deep recursion, suppress completion of some
 444                 // types.
 445                 completionEnabled = false;
 446                 return attr.attribType(tree, env);
 447             } finally {
 448                 completionEnabled = true;
 449                 chk.setLint(prevLint);
 450             }
 451         }
 452 
 453         /** Import all classes of a class or package on demand.
 454          *  @param imp           The import that is being handled.
 455          *  @param tsym          The class or package the members of which are imported.
 456          *  @param env           The env in which the imported classes will be entered.
 457          */
 458         private void importAll(JCImport imp,
 459                                final TypeSymbol tsym,
 460                                Env&lt;AttrContext&gt; env) {
 461             env.toplevel.starImportScope.importAll(types, tsym.members(), typeImportFilter, imp, cfHandler);
 462         }
 463 
 464         /** Import all static members of a class or package on demand.
 465          *  @param imp           The import that is being handled.
 466          *  @param tsym          The class or package the members of which are imported.
 467          *  @param env           The env in which the imported classes will be entered.
 468          */
 469         private void importStaticAll(JCImport imp,
 470                                      final TypeSymbol tsym,
 471                                      Env&lt;AttrContext&gt; env) {
 472             final StarImportScope toScope = env.toplevel.starImportScope;
 473             final TypeSymbol origin = tsym;
 474 
 475             toScope.importAll(types, origin.members(), staticImportFilter, imp, cfHandler);
 476         }
 477 
 478         /** Import statics types of a given name.  Non-types are handled in Attr.
 479          *  @param imp           The import that is being handled.
 480          *  @param tsym          The class from which the name is imported.
 481          *  @param name          The (simple) name being imported.
 482          *  @param env           The environment containing the named import
 483          *                  scope to add to.
 484          */
 485         private void importNamedStatic(final JCImport imp,
 486                                        final TypeSymbol tsym,
 487                                        final Name name,
 488                                        final Env&lt;AttrContext&gt; env) {
 489             if (tsym.kind != TYP) {
 490                 log.error(DiagnosticFlag.RECOVERABLE, imp.pos(), Errors.StaticImpOnlyClassesAndInterfaces);
 491                 return;
 492             }
 493 
 494             final NamedImportScope toScope = env.toplevel.namedImportScope;
 495             final Scope originMembers = tsym.members();
 496 
 497             imp.importScope = toScope.importByName(types, originMembers, name, staticImportFilter, imp, cfHandler);
 498         }
 499 
 500         /** Import given class.
 501          *  @param pos           Position to be used for error reporting.
 502          *  @param tsym          The class to be imported.
 503          *  @param env           The environment containing the named import
 504          *                  scope to add to.
 505          */
 506         private void importNamed(DiagnosticPosition pos, final Symbol tsym, Env&lt;AttrContext&gt; env, JCImport imp) {
 507             if (tsym.kind == TYP)
 508                 imp.importScope = env.toplevel.namedImportScope.importType(tsym.owner.members(), tsym.owner.members(), tsym);
 509         }
 510 
 511     }
 512 
 513     /**Defines common utility methods used by the HierarchyPhase and HeaderPhase.
 514      */
 515     private abstract class AbstractHeaderPhase extends Phase {
 516 
 517         public AbstractHeaderPhase(CompletionCause phaseName, Phase next) {
 518             super(phaseName, next);
 519         }
 520 
 521         protected Env&lt;AttrContext&gt; baseEnv(JCClassDecl tree, Env&lt;AttrContext&gt; env) {
 522             WriteableScope baseScope = WriteableScope.create(tree.sym);
 523             //import already entered local classes into base scope
 524             for (Symbol sym : env.outer.info.scope.getSymbols(NON_RECURSIVE)) {
 525                 if (sym.isLocal()) {
 526                     baseScope.enter(sym);
 527                 }
 528             }
 529             //import current type-parameters into base scope
 530             if (tree.typarams != null)
 531                 for (List&lt;JCTypeParameter&gt; typarams = tree.typarams;
 532                      typarams.nonEmpty();
 533                      typarams = typarams.tail)
 534                     baseScope.enter(typarams.head.type.tsym);
 535             Env&lt;AttrContext&gt; outer = env.outer; // the base clause can&#39;t see members of this class
 536             Env&lt;AttrContext&gt; localEnv = outer.dup(tree, outer.info.dup(baseScope));
 537             localEnv.baseClause = true;
 538             localEnv.outer = outer;
 539             localEnv.info.isSelfCall = false;
 540             return localEnv;
 541         }
 542 
 543         /** Generate a base clause for an enum type.
 544          *  @param pos              The position for trees and diagnostics, if any
 545          *  @param c                The class symbol of the enum
 546          */
 547         protected  JCExpression enumBase(int pos, ClassSymbol c) {
 548             JCExpression result = make.at(pos).
 549                 TypeApply(make.QualIdent(syms.enumSym),
 550                           List.of(make.Type(c.type)));
 551             return result;
 552         }
 553 
 554         protected Type modelMissingTypes(Env&lt;AttrContext&gt; env, Type t, final JCExpression tree, final boolean interfaceExpected) {
 555             if (!t.hasTag(ERROR))
 556                 return t;
 557 
 558             return new ErrorType(t.getOriginalType(), t.tsym) {
 559                 private Type modelType;
 560 
 561                 @Override
 562                 public Type getModelType() {
 563                     if (modelType == null)
 564                         modelType = new Synthesizer(env.toplevel.modle, getOriginalType(), interfaceExpected).visit(tree);
 565                     return modelType;
 566                 }
 567             };
 568         }
 569             // where:
 570             private class Synthesizer extends JCTree.Visitor {
 571                 ModuleSymbol msym;
 572                 Type originalType;
 573                 boolean interfaceExpected;
 574                 List&lt;ClassSymbol&gt; synthesizedSymbols = List.nil();
 575                 Type result;
 576 
 577                 Synthesizer(ModuleSymbol msym, Type originalType, boolean interfaceExpected) {
 578                     this.msym = msym;
 579                     this.originalType = originalType;
 580                     this.interfaceExpected = interfaceExpected;
 581                 }
 582 
 583                 Type visit(JCTree tree) {
 584                     tree.accept(this);
 585                     return result;
 586                 }
 587 
 588                 List&lt;Type&gt; visit(List&lt;? extends JCTree&gt; trees) {
 589                     ListBuffer&lt;Type&gt; lb = new ListBuffer&lt;&gt;();
 590                     for (JCTree t: trees)
 591                         lb.append(visit(t));
 592                     return lb.toList();
 593                 }
 594 
 595                 @Override
 596                 public void visitTree(JCTree tree) {
 597                     result = syms.errType;
 598                 }
 599 
 600                 @Override
 601                 public void visitIdent(JCIdent tree) {
 602                     if (!tree.type.hasTag(ERROR)) {
 603                         result = tree.type;
 604                     } else {
 605                         result = synthesizeClass(tree.name, msym.unnamedPackage).type;
 606                     }
 607                 }
 608 
 609                 @Override
 610                 public void visitSelect(JCFieldAccess tree) {
 611                     if (!tree.type.hasTag(ERROR)) {
 612                         result = tree.type;
 613                     } else {
 614                         Type selectedType;
 615                         boolean prev = interfaceExpected;
 616                         try {
 617                             interfaceExpected = false;
 618                             selectedType = visit(tree.selected);
 619                         } finally {
 620                             interfaceExpected = prev;
 621                         }
 622                         ClassSymbol c = synthesizeClass(tree.name, selectedType.tsym);
 623                         result = c.type;
 624                     }
 625                 }
 626 
 627                 @Override
 628                 public void visitTypeApply(JCTypeApply tree) {
 629                     if (!tree.type.hasTag(ERROR)) {
 630                         result = tree.type;
 631                     } else {
 632                         ClassType clazzType = (ClassType) visit(tree.clazz);
 633                         if (synthesizedSymbols.contains(clazzType.tsym))
 634                             synthesizeTyparams((ClassSymbol) clazzType.tsym, tree.arguments.size());
 635                         final List&lt;Type&gt; actuals = visit(tree.arguments);
 636                         result = new ErrorType(tree.type, clazzType.tsym) {
 637                             @Override @DefinedBy(Api.LANGUAGE_MODEL)
 638                             public List&lt;Type&gt; getTypeArguments() {
 639                                 return actuals;
 640                             }
 641                         };
 642                     }
 643                 }
 644 
 645                 ClassSymbol synthesizeClass(Name name, Symbol owner) {
 646                     int flags = interfaceExpected ? INTERFACE : 0;
 647                     ClassSymbol c = new ClassSymbol(flags, name, owner);
 648                     c.members_field = new Scope.ErrorScope(c);
 649                     c.type = new ErrorType(originalType, c) {
 650                         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 651                         public List&lt;Type&gt; getTypeArguments() {
 652                             return typarams_field;
 653                         }
 654                     };
 655                     synthesizedSymbols = synthesizedSymbols.prepend(c);
 656                     return c;
 657                 }
 658 
 659                 void synthesizeTyparams(ClassSymbol sym, int n) {
 660                     ClassType ct = (ClassType) sym.type;
 661                     Assert.check(ct.typarams_field.isEmpty());
 662                     if (n == 1) {
 663                         TypeVar v = new TypeVar(names.fromString(&quot;T&quot;), sym, syms.botType);
 664                         ct.typarams_field = ct.typarams_field.prepend(v);
 665                     } else {
 666                         for (int i = n; i &gt; 0; i--) {
 667                             TypeVar v = new TypeVar(names.fromString(&quot;T&quot; + i), sym,
 668                                                     syms.botType);
 669                             ct.typarams_field = ct.typarams_field.prepend(v);
 670                         }
 671                     }
 672                 }
 673             }
 674 
 675         protected void attribSuperTypes(Env&lt;AttrContext&gt; env, Env&lt;AttrContext&gt; baseEnv) {
 676             JCClassDecl tree = env.enclClass;
 677             ClassSymbol sym = tree.sym;
 678             ClassType ct = (ClassType)sym.type;
 679             // Determine supertype.
 680             Type supertype;
 681             JCExpression extending;
 682 
 683             if (tree.extending != null) {
 684                 extending = clearTypeParams(tree.extending);
 685                 supertype = attr.attribBase(extending, sym, baseEnv, true, false, true);
 686                 if (supertype == syms.recordType) {
 687                     log.error(tree, Errors.InvalidSupertypeRecord(supertype.tsym));
 688                 }
 689             } else {
 690                 extending = null;
 691                 supertype = ((tree.mods.flags &amp; Flags.ENUM) != 0)
 692                 ? attr.attribBase(enumBase(tree.pos, sym), sym, baseEnv,
 693                                   true, false, false)
 694                 : (sym.fullname == names.java_lang_Object)
 695                 ? Type.noType
 696                 : sym.isRecord() ? syms.recordType : syms.objectType;
 697             }
 698             ct.supertype_field = modelMissingTypes(baseEnv, supertype, extending, false);
 699 
 700             // Determine interfaces.
 701             ListBuffer&lt;Type&gt; interfaces = new ListBuffer&lt;&gt;();
 702             ListBuffer&lt;Type&gt; all_interfaces = null; // lazy init
 703             List&lt;JCExpression&gt; interfaceTrees = tree.implementing;
 704             for (JCExpression iface : interfaceTrees) {
 705                 iface = clearTypeParams(iface);
 706                 Type it = attr.attribBase(iface, sym, baseEnv, false, true, true);
 707                 if (it.hasTag(CLASS)) {
 708                     interfaces.append(it);
 709                     if (all_interfaces != null) all_interfaces.append(it);
 710                 } else {
 711                     if (all_interfaces == null)
 712                         all_interfaces = new ListBuffer&lt;Type&gt;().appendList(interfaces);
 713                     all_interfaces.append(modelMissingTypes(baseEnv, it, iface, true));
 714                 }
 715             }
 716 
 717             // Determine permits.
 718             ListBuffer&lt;Symbol&gt; permittedSubtypeSymbols = new ListBuffer&lt;&gt;();
 719             List&lt;JCExpression&gt; permittedTrees = tree.permitting;
 720             for (JCExpression permitted : permittedTrees) {
 721                 permitted = clearTypeParams(permitted);
 722                 Type pt = attr.attribBase(permitted, sym, baseEnv, false, false, false);
 723                 permittedSubtypeSymbols.append(pt.tsym);
 724             }
 725 
 726             if ((sym.flags_field &amp; ANNOTATION) != 0) {
 727                 ct.interfaces_field = List.of(syms.annotationType);
 728                 ct.all_interfaces_field = ct.interfaces_field;
 729             }  else {
 730                 ct.interfaces_field = interfaces.toList();
 731                 ct.all_interfaces_field = (all_interfaces == null)
 732                         ? ct.interfaces_field : all_interfaces.toList();
 733             }
 734 
 735             sym.permitted = permittedSubtypeSymbols.toList();
 736             sym.isPermittedExplicit = !permittedSubtypeSymbols.isEmpty();
 737         }
 738             //where:
 739             protected JCExpression clearTypeParams(JCExpression superType) {
 740                 return superType;
 741             }
 742     }
 743 
 744     private final class HierarchyPhase extends AbstractHeaderPhase implements Completer {
 745 
 746         public HierarchyPhase() {
 747             super(CompletionCause.HIERARCHY_PHASE, new PermitsPhase());
 748         }
 749 
 750         @Override
 751         protected void doCompleteEnvs(List&lt;Env&lt;AttrContext&gt;&gt; envs) {
 752             //The ClassSymbols in the envs list may not be in the dependency order.
 753             //To get proper results, for every class or interface C, the supertypes of
 754             //C must be processed by the HierarchyPhase phase before C.
 755             //To achieve that, the HierarchyPhase is registered as the Completer for
 756             //all the classes first, and then all the classes are completed.
 757             for (Env&lt;AttrContext&gt; env : envs) {
 758                 env.enclClass.sym.completer = this;
 759             }
 760             for (Env&lt;AttrContext&gt; env : envs) {
 761                 env.enclClass.sym.complete();
 762             }
 763         }
 764 
 765         @Override
 766         protected void runPhase(Env&lt;AttrContext&gt; env) {
 767             JCClassDecl tree = env.enclClass;
 768             ClassSymbol sym = tree.sym;
 769             ClassType ct = (ClassType)sym.type;
 770 
 771             Env&lt;AttrContext&gt; baseEnv = baseEnv(tree, env);
 772 
 773             attribSuperTypes(env, baseEnv);
 774 
 775             if (sym.fullname == names.java_lang_Object) {
 776                 if (tree.extending != null) {
 777                     chk.checkNonCyclic(tree.extending.pos(),
 778                                        ct.supertype_field);
 779                     ct.supertype_field = Type.noType;
 780                 }
 781                 else if (tree.implementing.nonEmpty()) {
 782                     chk.checkNonCyclic(tree.implementing.head.pos(),
 783                                        ct.interfaces_field.head);
 784                     ct.interfaces_field = List.nil();
 785                 }
 786             }
 787 
 788             markDeprecated(sym, tree.mods.annotations, baseEnv);
 789 
 790             chk.checkNonCyclicDecl(tree);
 791         }
 792             //where:
 793             @Override
 794             protected JCExpression clearTypeParams(JCExpression superType) {
 795                 switch (superType.getTag()) {
 796                     case TYPEAPPLY:
 797                         return ((JCTypeApply) superType).clazz;
 798                 }
 799 
 800                 return superType;
 801             }
 802 
 803         @Override
 804         public void complete(Symbol sym) throws CompletionFailure {
 805             Assert.check((topLevelPhase instanceof ImportsPhase) ||
 806                          (topLevelPhase == this));
 807 
 808             if (topLevelPhase != this) {
 809                 //only do the processing based on dependencies in the HierarchyPhase:
 810                 sym.completer = this;
 811                 return ;
 812             }
 813 
 814             Env&lt;AttrContext&gt; env = typeEnvs.get((ClassSymbol) sym);
 815 
 816             super.doCompleteEnvs(List.of(env));
 817         }
 818 
 819     }
 820 
 821     private final class PermitsPhase extends AbstractHeaderPhase {
 822 
 823         public PermitsPhase() {
 824             super(CompletionCause.HIERARCHY_PHASE, new HeaderPhase());
 825         }
 826 
 827         @Override
 828         protected void runPhase(Env&lt;AttrContext&gt; env) {
 829             JCClassDecl tree = env.enclClass;
<a name="2" id="anc2"></a><span class="line-modified"> 830             if (tree.sym.type != syms.objectType) {</span>
<span class="line-modified"> 831                 List&lt;Type&gt; directSuperTypes = (types.supertype(tree.sym.type) != null ?</span>
<span class="line-modified"> 832                         List.of(types.supertype(tree.sym.type)) :</span>
<span class="line-modified"> 833                         List.nil());</span>
<span class="line-modified"> 834                 directSuperTypes = directSuperTypes.appendList(types.interfaces(tree.sym.type));</span>
<span class="line-modified"> 835                 List&lt;Type&gt; directSuperTypesInSameCU = directSuperTypes.stream()</span>
<span class="line-modified"> 836                         .filter(supertype -&gt;</span>
<span class="line-modified"> 837                                 TreeInfo.declarationFor(supertype.tsym, env.toplevel) != null &amp;&amp;</span>
<span class="line-modified"> 838                                         TreeInfo.declarationFor(tree.sym.outermostClass(), env.toplevel) != null)</span>
<span class="line-modified"> 839                         .collect(List.collector());</span>
<span class="line-removed"> 840                 Set&lt;Type&gt; explicitlySealedSuperTypesInCU = directSuperTypesInSameCU.stream()</span>
<span class="line-removed"> 841                             .filter(type -&gt; type != tree.sym.type &amp;&amp;</span>
<span class="line-removed"> 842                                     type.tsym != null &amp;&amp;</span>
<span class="line-removed"> 843                                     type.tsym.isSealed()).collect(Collectors.toSet());</span>
<span class="line-removed"> 844 </span>
<span class="line-removed"> 845                 boolean anySuperInSameCUIsSealed = !explicitlySealedSuperTypesInCU.isEmpty();</span>
<span class="line-removed"> 846                 if (anySuperInSameCUIsSealed) {</span>
<span class="line-removed"> 847                     java.util.Set&lt;ClassSymbol&gt; potentiallySealedSuperTypes = superTypeSymsInASealedHierarchy(tree.sym, env, true);</span>
<span class="line-removed"> 848                     if (!potentiallySealedSuperTypes.isEmpty()) {</span>
<span class="line-removed"> 849                         for (ClassSymbol supertype : potentiallySealedSuperTypes) {</span>
<span class="line-removed"> 850                             if (!supertype.permitted.contains(tree.sym.type.tsym)) {</span>
<span class="line-removed"> 851                                 if (!supertype.isPermittedExplicit) {</span>
<span class="line-removed"> 852                                     if (!tree.sym.isAnonymous() || tree.sym.isEnum()) {</span>
<span class="line-removed"> 853                                         supertype.permitted = supertype.permitted.append(tree.sym);</span>
<span class="line-removed"> 854                                         tree.sym.hasSealedSuperInSameCU = true;</span>
<span class="line-removed"> 855                                     }</span>
<span class="line-removed"> 856                                 }</span>
<span class="line-removed"> 857                             } else {</span>
<span class="line-removed"> 858                                 tree.sym.hasSealedSuperInSameCU = true;</span>
<span class="line-removed"> 859                             }</span>
 860                         }
 861                     }
 862                 }
<a name="3" id="anc3"></a><span class="line-removed"> 863 </span>
<span class="line-removed"> 864                 java.util.Set&lt;ClassSymbol&gt; sealedSuperSyms = superTypeSymsInASealedHierarchy(tree.sym, env, false);</span>
<span class="line-removed"> 865                 boolean hasSuperTypesInSealedHierarchy = !sealedSuperSyms.isEmpty();</span>
<span class="line-removed"> 866                 if (hasSuperTypesInSealedHierarchy) {</span>
<span class="line-removed"> 867                     tree.sym.sealedSupers = sealedSuperSyms;</span>
<span class="line-removed"> 868                 }</span>
<span class="line-removed"> 869             }</span>
<span class="line-removed"> 870         }</span>
<span class="line-removed"> 871 </span>
<span class="line-removed"> 872         JCTree findTreeReferringSym(JCClassDecl tree, Symbol sym) {</span>
<span class="line-removed"> 873             if (tree.extending != null &amp;&amp; tree.extending.type.tsym == sym) {</span>
<span class="line-removed"> 874                 return tree.extending;</span>
<span class="line-removed"> 875             }</span>
<span class="line-removed"> 876             for (JCExpression implementing: tree.implementing) {</span>
<span class="line-removed"> 877                 if (implementing.type.tsym == sym) {</span>
<span class="line-removed"> 878                     return implementing;</span>
<span class="line-removed"> 879                 }</span>
 880             }
<a name="4" id="anc4"></a><span class="line-removed"> 881             return tree;</span>
<span class="line-removed"> 882         }</span>
<span class="line-removed"> 883 </span>
<span class="line-removed"> 884         boolean areInSameCU(Symbol sym1, Symbol sym2, Env&lt;AttrContext&gt; env) {</span>
<span class="line-removed"> 885             return TreeInfo.declarationFor(sym1, env.toplevel) != null &amp;&amp;</span>
<span class="line-removed"> 886                     TreeInfo.declarationFor(sym2.outermostClass(), env.toplevel) != null;</span>
 887         }
 888 
<a name="5" id="anc5"></a><span class="line-removed"> 889         java.util.Set&lt;ClassSymbol&gt; superTypeSymsInASealedHierarchy(ClassSymbol csym, Env&lt;AttrContext&gt; env, boolean inSameCUOnly) {</span>
<span class="line-removed"> 890             if (csym == null) {</span>
<span class="line-removed"> 891                 return Set.of();</span>
<span class="line-removed"> 892             }</span>
<span class="line-removed"> 893 </span>
<span class="line-removed"> 894             Type supertype = csym.type != null ?</span>
<span class="line-removed"> 895                     types.supertype(csym.type) : null;</span>
<span class="line-removed"> 896             java.util.Set&lt;ClassSymbol&gt; supertypes = new HashSet&lt;&gt;();</span>
<span class="line-removed"> 897 </span>
<span class="line-removed"> 898             if (supertype != null &amp;&amp;</span>
<span class="line-removed"> 899                     supertype.tsym != null &amp;&amp;</span>
<span class="line-removed"> 900                     supertype != syms.objectType &amp;&amp;</span>
<span class="line-removed"> 901                     supertype.tsym != null &amp;&amp;</span>
<span class="line-removed"> 902                     !supertype.tsym.isNonSealed() &amp;&amp;</span>
<span class="line-removed"> 903                     (inSameCUOnly &amp;&amp; areInSameCU(csym, supertype.tsym, env) || !inSameCUOnly)) {</span>
<span class="line-removed"> 904                 supertypes.add((ClassSymbol) supertype.tsym);</span>
<span class="line-removed"> 905             }</span>
<span class="line-removed"> 906 </span>
<span class="line-removed"> 907             if (csym.getInterfaces() != null) {</span>
<span class="line-removed"> 908                 for (Type intf : csym.getInterfaces()) {</span>
<span class="line-removed"> 909                     if (intf != null &amp;&amp; intf.tsym != null &amp;&amp; intf.tsym != null &amp;&amp; !intf.tsym.isNonSealed() &amp;&amp;</span>
<span class="line-removed"> 910                             (inSameCUOnly &amp;&amp; areInSameCU(csym, intf.tsym, env) || !inSameCUOnly)) {</span>
<span class="line-removed"> 911                         supertypes.add((ClassSymbol) intf.tsym);</span>
<span class="line-removed"> 912                     }</span>
<span class="line-removed"> 913                 }</span>
<span class="line-removed"> 914             }</span>
<span class="line-removed"> 915 </span>
<span class="line-removed"> 916             for (ClassSymbol sup : new ArrayList&lt;&gt;(supertypes)) {</span>
<span class="line-removed"> 917                 if (sup instanceof ClassSymbol) {</span>
<span class="line-removed"> 918                     java.util.Set&lt;ClassSymbol&gt; supers = superTypeSymsInASealedHierarchy(sup, env, inSameCUOnly);</span>
<span class="line-removed"> 919                     if ((supers == null || supers.isEmpty()) &amp;&amp; !sup.isSealed()) {</span>
<span class="line-removed"> 920                         supertypes.remove(sup);</span>
<span class="line-removed"> 921                     }</span>
<span class="line-removed"> 922                 } else {</span>
<span class="line-removed"> 923                     supertypes.remove(sup);</span>
<span class="line-removed"> 924                 }</span>
<span class="line-removed"> 925             }</span>
<span class="line-removed"> 926 </span>
<span class="line-removed"> 927             return supertypes;</span>
<span class="line-removed"> 928         }</span>
 929     }
 930 
 931     private final class HeaderPhase extends AbstractHeaderPhase {
 932 
 933         public HeaderPhase() {
 934             super(CompletionCause.HEADER_PHASE, new RecordPhase());
 935         }
 936 
 937         @Override
 938         protected void runPhase(Env&lt;AttrContext&gt; env) {
 939             JCClassDecl tree = env.enclClass;
 940             ClassSymbol sym = tree.sym;
 941             ClassType ct = (ClassType)sym.type;
 942 
 943             // create an environment for evaluating the base clauses
 944             Env&lt;AttrContext&gt; baseEnv = baseEnv(tree, env);
 945 
 946             if (tree.extending != null)
 947                 annotate.queueScanTreeAndTypeAnnotate(tree.extending, baseEnv, sym, tree.pos());
 948             for (JCExpression impl : tree.implementing)
 949                 annotate.queueScanTreeAndTypeAnnotate(impl, baseEnv, sym, tree.pos());
 950             annotate.flush();
 951 
 952             attribSuperTypes(env, baseEnv);
 953 
 954             Set&lt;Type&gt; interfaceSet = new HashSet&lt;&gt;();
 955 
 956             for (JCExpression iface : tree.implementing) {
 957                 Type it = iface.type;
 958                 if (it.hasTag(CLASS))
 959                     chk.checkNotRepeated(iface.pos(), types.erasure(it), interfaceSet);
 960             }
 961 
 962             annotate.annotateLater(tree.mods.annotations, baseEnv,
 963                         sym, tree.pos());
 964             attr.attribTypeVariables(tree.typarams, baseEnv, false);
 965 
 966             for (JCTypeParameter tp : tree.typarams)
 967                 annotate.queueScanTreeAndTypeAnnotate(tp, baseEnv, sym, tree.pos());
 968 
 969             // check that no package exists with same fully qualified name,
 970             // but admit classes in the unnamed package which have the same
 971             // name as a top-level package.
 972             if (checkClash &amp;&amp;
 973                 sym.owner.kind == PCK &amp;&amp; sym.owner != env.toplevel.modle.unnamedPackage &amp;&amp;
 974                 syms.packageExists(env.toplevel.modle, sym.fullname)) {
 975                 log.error(tree.pos, Errors.ClashWithPkgOfSameName(Kinds.kindName(sym),sym));
 976             }
 977             if (sym.owner.kind == PCK &amp;&amp; (sym.flags_field &amp; PUBLIC) == 0 &amp;&amp;
 978                 !env.toplevel.sourcefile.isNameCompatible(sym.name.toString(),JavaFileObject.Kind.SOURCE)) {
 979                 sym.flags_field |= AUXILIARY;
 980             }
 981         }
 982     }
 983 
 984     private abstract class AbstractMembersPhase extends Phase {
 985 
 986         public AbstractMembersPhase(CompletionCause completionCause, Phase next) {
 987             super(completionCause, next);
 988         }
 989 
 990         private boolean completing;
 991         private List&lt;Env&lt;AttrContext&gt;&gt; todo = List.nil();
 992 
 993         @Override
 994         protected void doCompleteEnvs(List&lt;Env&lt;AttrContext&gt;&gt; envs) {
 995             todo = todo.prependList(envs);
 996             if (completing) {
 997                 return ; //the top-level invocation will handle all envs
 998             }
 999             boolean prevCompleting = completing;
1000             completing = true;
1001             try {
1002                 while (todo.nonEmpty()) {
1003                     Env&lt;AttrContext&gt; head = todo.head;
1004                     todo = todo.tail;
1005                     super.doCompleteEnvs(List.of(head));
1006                 }
1007             } finally {
1008                 completing = prevCompleting;
1009             }
1010         }
1011 
1012         void enterThisAndSuper(ClassSymbol sym, Env&lt;AttrContext&gt; env) {
1013             ClassType ct = (ClassType)sym.type;
1014             // enter symbols for &#39;this&#39; into current scope.
1015             VarSymbol thisSym =
1016                     new VarSymbol(FINAL | HASINIT, names._this, sym.type, sym);
1017             thisSym.pos = Position.FIRSTPOS;
1018             env.info.scope.enter(thisSym);
1019             // if this is a class, enter symbol for &#39;super&#39; into current scope.
1020             if ((sym.flags_field &amp; INTERFACE) == 0 &amp;&amp;
1021                     ct.supertype_field.hasTag(CLASS)) {
1022                 VarSymbol superSym =
1023                         new VarSymbol(FINAL | HASINIT, names._super,
1024                                 ct.supertype_field, sym);
1025                 superSym.pos = Position.FIRSTPOS;
1026                 env.info.scope.enter(superSym);
1027             }
1028         }
1029     }
1030 
1031     private final class RecordPhase extends AbstractMembersPhase {
1032 
1033         public RecordPhase() {
1034             super(CompletionCause.RECORD_PHASE, new MembersPhase());
1035         }
1036 
1037         @Override
1038         protected void runPhase(Env&lt;AttrContext&gt; env) {
1039             JCClassDecl tree = env.enclClass;
1040             ClassSymbol sym = tree.sym;
1041             if ((sym.flags_field &amp; RECORD) != 0) {
1042                 List&lt;JCVariableDecl&gt; fields = TreeInfo.recordFields(tree);
1043                 memberEnter.memberEnter(fields, env);
1044                 for (JCVariableDecl field : fields) {
1045                     sym.getRecordComponent(field, true,
1046                             field.mods.annotations.isEmpty() ?
1047                                     List.nil() :
1048                                     new TreeCopier&lt;JCTree&gt;(make.at(field.pos)).copy(field.mods.annotations));
1049                 }
1050 
1051                 enterThisAndSuper(sym, env);
1052 
1053                 // lets enter all constructors
1054                 for (JCTree def : tree.defs) {
1055                     if (TreeInfo.isConstructor(def)) {
1056                         memberEnter.memberEnter(def, env);
1057                     }
1058                 }
1059             }
1060         }
1061     }
1062 
1063     /** Enter member fields and methods of a class
1064      */
1065     private final class MembersPhase extends AbstractMembersPhase {
1066 
1067         public MembersPhase() {
1068             super(CompletionCause.MEMBERS_PHASE, null);
1069         }
1070 
1071         @Override
1072         protected void runPhase(Env&lt;AttrContext&gt; env) {
1073             JCClassDecl tree = env.enclClass;
1074             ClassSymbol sym = tree.sym;
1075             ClassType ct = (ClassType)sym.type;
1076 
1077             // Add default constructor if needed.
1078             DefaultConstructorHelper helper = getDefaultConstructorHelper(env);
1079             if (helper != null) {
1080                 JCTree constrDef = defaultConstructor(make.at(tree.pos), helper);
1081                 tree.defs = tree.defs.prepend(constrDef);
1082             }
1083             if (!sym.isRecord()) {
1084                 enterThisAndSuper(sym, env);
1085             }
1086 
1087             if (!tree.typarams.isEmpty()) {
1088                 for (JCTypeParameter tvar : tree.typarams) {
1089                     chk.checkNonCyclic(tvar, (TypeVar)tvar.type);
1090                 }
1091             }
1092 
1093             finishClass(tree, env);
1094 
1095             if (allowTypeAnnos) {
1096                 typeAnnotations.organizeTypeAnnotationsSignatures(env, (JCClassDecl)env.tree);
1097                 typeAnnotations.validateTypeAnnotationsSignatures(env, (JCClassDecl)env.tree);
1098             }
1099         }
1100 
1101         DefaultConstructorHelper getDefaultConstructorHelper(Env&lt;AttrContext&gt; env) {
1102             JCClassDecl tree = env.enclClass;
1103             ClassSymbol sym = tree.sym;
1104             DefaultConstructorHelper helper = null;
1105             boolean isClassWithoutInit = (sym.flags() &amp; INTERFACE) == 0 &amp;&amp; !TreeInfo.hasConstructors(tree.defs);
1106             boolean isRecord = sym.isRecord();
1107             if (isClassWithoutInit &amp;&amp; !isRecord) {
1108                 helper = new BasicConstructorHelper(sym);
1109                 if (sym.name.isEmpty()) {
1110                     JCNewClass nc = (JCNewClass)env.next.tree;
1111                     if (nc.constructor != null) {
1112                         if (nc.constructor.kind != ERR) {
1113                             helper = new AnonClassConstructorHelper(sym, (MethodSymbol)nc.constructor, nc.encl);
1114                         } else {
1115                             helper = null;
1116                         }
1117                     }
1118                 }
1119             }
1120             if (isRecord) {
1121                 JCMethodDecl canonicalInit = null;
1122                 if (isClassWithoutInit || (canonicalInit = getCanonicalConstructorDecl(env.enclClass)) == null) {
1123                     helper = new RecordConstructorHelper(sym, TreeInfo.recordFields(tree));
1124                 }
1125                 if (canonicalInit != null) {
1126                     canonicalInit.sym.flags_field |= Flags.RECORD;
1127                 }
1128             }
1129             return helper;
1130         }
1131 
1132         /** Enter members for a class.
1133          */
1134         void finishClass(JCClassDecl tree, Env&lt;AttrContext&gt; env) {
1135             if ((tree.mods.flags &amp; Flags.ENUM) != 0 &amp;&amp;
1136                 !tree.sym.type.hasTag(ERROR) &amp;&amp;
1137                 (types.supertype(tree.sym.type).tsym.flags() &amp; Flags.ENUM) == 0) {
1138                 addEnumMembers(tree, env);
1139             }
1140             boolean isRecord = (tree.sym.flags_field &amp; RECORD) != 0;
1141             List&lt;JCTree&gt; alreadyEntered = null;
1142             if (isRecord) {
1143                 alreadyEntered = List.convert(JCTree.class, TreeInfo.recordFields(tree));
1144                 alreadyEntered = alreadyEntered.prependList(tree.defs.stream()
1145                         .filter(t -&gt; TreeInfo.isConstructor(t) &amp;&amp;
1146                                 ((JCMethodDecl)t).sym != null &amp;&amp;
1147                                 (((JCMethodDecl)t).sym.flags_field &amp; Flags.GENERATEDCONSTR) == 0).collect(List.collector()));
1148             }
1149             List&lt;JCTree&gt; defsToEnter = isRecord ?
1150                     tree.defs.diff(alreadyEntered) : tree.defs;
1151             memberEnter.memberEnter(defsToEnter, env);
1152             List&lt;JCTree&gt; defsBeforeAddingNewMembers = tree.defs;
1153             if (isRecord) {
1154                 addRecordMembersIfNeeded(tree, env);
1155             }
1156             if (tree.sym.isAnnotationType()) {
1157                 Assert.check(tree.sym.isCompleted());
1158                 tree.sym.setAnnotationTypeMetadata(new AnnotationTypeMetadata(tree.sym, annotate.annotationTypeSourceCompleter()));
1159             }
1160         }
1161 
1162         private void addAccessor(JCVariableDecl tree, Env&lt;AttrContext&gt; env) {
1163             MethodSymbol implSym = lookupMethod(env.enclClass.sym, tree.sym.name, List.nil());
1164             RecordComponent rec = ((ClassSymbol) tree.sym.owner).getRecordComponent(tree.sym);
1165             if (implSym == null || (implSym.flags_field &amp; GENERATED_MEMBER) != 0) {
1166                 /* here we are pushing the annotations present in the corresponding field down to the accessor
1167                  * it could be that some of those annotations are not applicable to the accessor, they will be striped
1168                  * away later at Check::validateAnnotation
1169                  */
1170                 List&lt;JCAnnotation&gt; originalAnnos = rec.getOriginalAnnos().isEmpty() ?
1171                         rec.getOriginalAnnos() :
1172                         new TreeCopier&lt;JCTree&gt;(make.at(tree.pos)).copy(rec.getOriginalAnnos());
1173                 JCMethodDecl getter = make.at(tree.pos).
1174                         MethodDef(
1175                                 make.Modifiers(Flags.PUBLIC | Flags.GENERATED_MEMBER, originalAnnos),
1176                           tree.sym.name,
1177                           /* we need to special case for the case when the user declared the type as an ident
1178                            * if we don&#39;t do that then we can have issues if type annotations are applied to the
1179                            * return type: javac issues an error if a type annotation is applied to java.lang.String
1180                            * but applying a type annotation to String is kosher
1181                            */
1182                           tree.vartype.hasTag(IDENT) ? make.Ident(tree.vartype.type.tsym) : make.Type(tree.sym.type),
1183                           List.nil(),
1184                           List.nil(),
1185                           List.nil(), // thrown
1186                           null,
1187                           null);
1188                 memberEnter.memberEnter(getter, env);
1189                 rec.accessor = getter.sym;
1190                 rec.accessorMeth = getter;
1191             } else if (implSym != null) {
1192                 rec.accessor = implSym;
1193             }
1194         }
1195 
1196         /** Add the implicit members for an enum type
1197          *  to the symbol table.
1198          */
1199         private void addEnumMembers(JCClassDecl tree, Env&lt;AttrContext&gt; env) {
1200             JCExpression valuesType = make.Type(new ArrayType(tree.sym.type, syms.arrayClass));
1201 
1202             JCMethodDecl values = make.
1203                 MethodDef(make.Modifiers(Flags.PUBLIC|Flags.STATIC),
1204                           names.values,
1205                           valuesType,
1206                           List.nil(),
1207                           List.nil(),
1208                           List.nil(),
1209                           null,
1210                           null);
1211             memberEnter.memberEnter(values, env);
1212 
1213             JCMethodDecl valueOf = make.
1214                 MethodDef(make.Modifiers(Flags.PUBLIC|Flags.STATIC),
1215                           names.valueOf,
1216                           make.Type(tree.sym.type),
1217                           List.nil(),
1218                           List.of(make.VarDef(make.Modifiers(Flags.PARAMETER |
1219                                                              Flags.MANDATED),
1220                                                 names.fromString(&quot;name&quot;),
1221                                                 make.Type(syms.stringType), null)),
1222                           List.nil(),
1223                           null,
1224                           null);
1225             memberEnter.memberEnter(valueOf, env);
1226         }
1227 
1228         JCMethodDecl getCanonicalConstructorDecl(JCClassDecl tree) {
1229             // let&#39;s check if there is a constructor with exactly the same arguments as the record components
1230             List&lt;Type&gt; recordComponentErasedTypes = types.erasure(TreeInfo.recordFields(tree).map(vd -&gt; vd.sym.type));
1231             JCMethodDecl canonicalDecl = null;
1232             for (JCTree def : tree.defs) {
1233                 if (TreeInfo.isConstructor(def)) {
1234                     JCMethodDecl mdecl = (JCMethodDecl)def;
1235                     if (types.isSameTypes(types.erasure(mdecl.params.stream().map(v -&gt; v.sym.type).collect(List.collector())), recordComponentErasedTypes)) {
1236                         canonicalDecl = mdecl;
1237                         break;
1238                     }
1239                 }
1240             }
1241             return canonicalDecl;
1242         }
1243 
1244         /** Add the implicit members for a record
1245          *  to the symbol table.
1246          */
1247         private void addRecordMembersIfNeeded(JCClassDecl tree, Env&lt;AttrContext&gt; env) {
1248             if (lookupMethod(tree.sym, names.toString, List.nil()) == null) {
1249                 JCMethodDecl toString = make.
1250                     MethodDef(make.Modifiers(Flags.PUBLIC | Flags.RECORD | Flags.GENERATED_MEMBER),
1251                               names.toString,
1252                               make.Type(syms.stringType),
1253                               List.nil(),
1254                               List.nil(),
1255                               List.nil(),
1256                               null,
1257                               null);
1258                 memberEnter.memberEnter(toString, env);
1259             }
1260 
1261             if (lookupMethod(tree.sym, names.hashCode, List.nil()) == null) {
1262                 JCMethodDecl hashCode = make.
1263                     MethodDef(make.Modifiers(Flags.PUBLIC | Flags.RECORD | Flags.FINAL | Flags.GENERATED_MEMBER),
1264                               names.hashCode,
1265                               make.Type(syms.intType),
1266                               List.nil(),
1267                               List.nil(),
1268                               List.nil(),
1269                               null,
1270                               null);
1271                 memberEnter.memberEnter(hashCode, env);
1272             }
1273 
1274             if (lookupMethod(tree.sym, names.equals, List.of(syms.objectType)) == null) {
1275                 JCMethodDecl equals = make.
1276                     MethodDef(make.Modifiers(Flags.PUBLIC | Flags.RECORD | Flags.FINAL | Flags.GENERATED_MEMBER),
1277                               names.equals,
1278                               make.Type(syms.booleanType),
1279                               List.nil(),
1280                               List.of(make.VarDef(make.Modifiers(Flags.PARAMETER),
1281                                                 names.fromString(&quot;o&quot;),
1282                                                 make.Type(syms.objectType), null)),
1283                               List.nil(),
1284                               null,
1285                               null);
1286                 memberEnter.memberEnter(equals, env);
1287             }
1288 
1289             // fields can&#39;t be varargs, lets remove the flag
1290             List&lt;JCVariableDecl&gt; recordFields = TreeInfo.recordFields(tree);
1291             for (JCVariableDecl field: recordFields) {
1292                 field.mods.flags &amp;= ~Flags.VARARGS;
1293                 field.sym.flags_field &amp;= ~Flags.VARARGS;
1294             }
1295             // now lets add the accessors
1296             recordFields.stream()
1297                     .filter(vd -&gt; (lookupMethod(syms.objectType.tsym, vd.name, List.nil()) == null))
1298                     .forEach(vd -&gt; addAccessor(vd, env));
1299         }
1300     }
1301 
1302     private MethodSymbol lookupMethod(TypeSymbol tsym, Name name, List&lt;Type&gt; argtypes) {
1303         for (Symbol s : tsym.members().getSymbolsByName(name, s -&gt; s.kind == MTH)) {
1304             if (types.isSameTypes(s.type.getParameterTypes(), argtypes)) {
1305                 return (MethodSymbol) s;
1306             }
1307         }
1308         return null;
1309     }
1310 
1311 /* ***************************************************************************
1312  * tree building
1313  ****************************************************************************/
1314 
1315     interface DefaultConstructorHelper {
1316        Type constructorType();
1317        MethodSymbol constructorSymbol();
1318        Type enclosingType();
1319        TypeSymbol owner();
1320        List&lt;Name&gt; superArgs();
1321        default JCMethodDecl finalAdjustment(JCMethodDecl md) { return md; }
1322     }
1323 
1324     class BasicConstructorHelper implements DefaultConstructorHelper {
1325 
1326         TypeSymbol owner;
1327         Type constructorType;
1328         MethodSymbol constructorSymbol;
1329 
1330         BasicConstructorHelper(TypeSymbol owner) {
1331             this.owner = owner;
1332         }
1333 
1334         @Override
1335         public Type constructorType() {
1336             if (constructorType == null) {
1337                 constructorType = new MethodType(List.nil(), syms.voidType, List.nil(), syms.methodClass);
1338             }
1339             return constructorType;
1340         }
1341 
1342         @Override
1343         public MethodSymbol constructorSymbol() {
1344             if (constructorSymbol == null) {
1345                 long flags;
1346                 if ((owner().flags() &amp; ENUM) != 0 &amp;&amp;
1347                     (types.supertype(owner().type).tsym == syms.enumSym)) {
1348                     // constructors of true enums are private
1349                     flags = PRIVATE | GENERATEDCONSTR;
1350                 } else if ((owner().flags_field &amp; RECORD) != 0) {
1351                     // record constructors are public
1352                     flags = PUBLIC | GENERATEDCONSTR;
1353                 } else {
1354                     flags = (owner().flags() &amp; AccessFlags) | GENERATEDCONSTR;
1355                 }
1356                 constructorSymbol = new MethodSymbol(flags, names.init,
1357                     constructorType(), owner());
1358             }
1359             return constructorSymbol;
1360         }
1361 
1362         @Override
1363         public Type enclosingType() {
1364             return Type.noType;
1365     }
1366 
1367         @Override
1368         public TypeSymbol owner() {
1369             return owner;
1370         }
1371 
1372         @Override
1373         public List&lt;Name&gt; superArgs() {
1374             return List.nil();
1375             }
1376     }
1377 
1378     class AnonClassConstructorHelper extends BasicConstructorHelper {
1379 
1380         MethodSymbol constr;
1381         Type encl;
1382         boolean based = false;
1383 
1384         AnonClassConstructorHelper(TypeSymbol owner, MethodSymbol constr, JCExpression encl) {
1385             super(owner);
1386             this.constr = constr;
1387             this.encl = encl != null ? encl.type : Type.noType;
1388         }
1389 
1390         @Override
1391         public Type constructorType() {
1392             if (constructorType == null) {
1393                 Type ctype = types.memberType(owner.type, constr);
1394                 if (!enclosingType().hasTag(NONE)) {
1395                     ctype = types.createMethodTypeWithParameters(ctype, ctype.getParameterTypes().prepend(enclosingType()));
1396                     based = true;
1397                 }
1398                 constructorType = ctype;
1399             }
1400             return constructorType;
1401         }
1402 
1403         @Override
1404         public MethodSymbol constructorSymbol() {
1405             MethodSymbol csym = super.constructorSymbol();
1406             csym.flags_field |= ANONCONSTR | (constr.flags() &amp; VARARGS);
1407             csym.flags_field |= based ? ANONCONSTR_BASED : 0;
1408             ListBuffer&lt;VarSymbol&gt; params = new ListBuffer&lt;&gt;();
1409             List&lt;Type&gt; argtypes = constructorType().getParameterTypes();
1410             if (!enclosingType().hasTag(NONE)) {
1411                 argtypes = argtypes.tail;
1412                 params = params.prepend(new VarSymbol(PARAMETER, make.paramName(0), enclosingType(), csym));
1413             }
1414             if (constr.params != null) {
1415                 for (VarSymbol p : constr.params) {
1416                     params.add(new VarSymbol(PARAMETER | p.flags(), p.name, argtypes.head, csym));
1417                     argtypes = argtypes.tail;
1418                 }
1419             }
1420             csym.params = params.toList();
1421             return csym;
1422         }
1423 
1424         @Override
1425         public Type enclosingType() {
1426             return encl;
1427         }
1428 
1429         @Override
1430         public List&lt;Name&gt; superArgs() {
1431             List&lt;JCVariableDecl&gt; params = make.Params(constructorType().getParameterTypes(), constructorSymbol());
1432             if (!enclosingType().hasTag(NONE)) {
1433                 params = params.tail;
1434             }
1435             return params.map(vd -&gt; vd.name);
1436         }
1437     }
1438 
1439     class RecordConstructorHelper extends BasicConstructorHelper {
1440 
1441         List&lt;VarSymbol&gt; recordFieldSymbols;
1442         List&lt;JCVariableDecl&gt; recordFieldDecls;
1443 
1444         RecordConstructorHelper(TypeSymbol owner, List&lt;JCVariableDecl&gt; recordFieldDecls) {
1445             super(owner);
1446             this.recordFieldDecls = recordFieldDecls;
1447             this.recordFieldSymbols = recordFieldDecls.map(vd -&gt; vd.sym);
1448         }
1449 
1450         @Override
1451         public Type constructorType() {
1452             if (constructorType == null) {
1453                 List&lt;Type&gt; argtypes = recordFieldSymbols.map(v -&gt; (v.flags_field &amp; Flags.VARARGS) != 0 ? types.elemtype(v.type) : v.type);
1454                 constructorType = new MethodType(argtypes, syms.voidType, List.nil(), syms.methodClass);
1455             }
1456             return constructorType;
1457         }
1458 
1459         @Override
1460         public MethodSymbol constructorSymbol() {
1461             MethodSymbol csym = super.constructorSymbol();
1462             /* if we have to generate a default constructor for records we will treat it as the compact one
1463              * to trigger field initialization later on
1464              */
1465             csym.flags_field |= Flags.COMPACT_RECORD_CONSTRUCTOR | GENERATEDCONSTR;
1466             ListBuffer&lt;VarSymbol&gt; params = new ListBuffer&lt;&gt;();
1467             for (VarSymbol p : recordFieldSymbols) {
1468                 params.add(new VarSymbol(GENERATED_MEMBER | PARAMETER | RECORD | ((p.flags_field &amp; Flags.VARARGS) != 0 ? Flags.VARARGS : 0), p.name, p.type, csym));
1469             }
1470             csym.params = params.toList();
1471             csym.flags_field |= RECORD | PUBLIC;
1472             return csym;
1473         }
1474 
1475         @Override
1476         public JCMethodDecl finalAdjustment(JCMethodDecl md) {
1477             List&lt;JCVariableDecl&gt; tmpRecordFieldDecls = recordFieldDecls;
1478             for (JCVariableDecl arg : md.params) {
1479                 /* at this point we are passing all the annotations in the field to the corresponding
1480                  * parameter in the constructor.
1481                  */
1482                 RecordComponent rc = ((ClassSymbol) owner).getRecordComponent(arg.sym);
1483                 arg.mods.annotations = rc.getOriginalAnnos().isEmpty() ?
1484                         List.nil() :
1485                         new TreeCopier&lt;JCTree&gt;(make.at(arg.pos)).copy(rc.getOriginalAnnos());
1486                 arg.vartype = tmpRecordFieldDecls.head.vartype;
1487                 tmpRecordFieldDecls = tmpRecordFieldDecls.tail;
1488             }
1489             return md;
1490         }
1491     }
1492 
1493     JCTree defaultConstructor(TreeMaker make, DefaultConstructorHelper helper) {
1494         Type initType = helper.constructorType();
1495         MethodSymbol initSym = helper.constructorSymbol();
1496         ListBuffer&lt;JCStatement&gt; stats = new ListBuffer&lt;&gt;();
1497         if (helper.owner().type != syms.objectType) {
1498         JCExpression meth;
1499             if (!helper.enclosingType().hasTag(NONE)) {
1500                 meth = make.Select(make.Ident(initSym.params.head), names._super);
1501             } else {
1502                 meth = make.Ident(names._super);
1503             }
1504             List&lt;JCExpression&gt; typeargs = initType.getTypeArguments().nonEmpty() ?
1505                     make.Types(initType.getTypeArguments()) : null;
1506             JCStatement superCall = make.Exec(make.Apply(typeargs, meth, helper.superArgs().map(make::Ident)));
1507             stats.add(superCall);
1508         }
1509         JCMethodDecl result = make.MethodDef(initSym, make.Block(0, stats.toList()));
1510         return helper.finalAdjustment(result);
1511     }
1512 
1513     /**
1514      * Mark sym deprecated if annotations contain @Deprecated annotation.
1515      */
1516     public void markDeprecated(Symbol sym, List&lt;JCAnnotation&gt; annotations, Env&lt;AttrContext&gt; env) {
1517         // In general, we cannot fully process annotations yet,  but we
1518         // can attribute the annotation types and then check to see if the
1519         // @Deprecated annotation is present.
1520         attr.attribAnnotationTypes(annotations, env);
1521         handleDeprecatedAnnotations(annotations, sym);
1522     }
1523 
1524     /**
1525      * If a list of annotations contains a reference to java.lang.Deprecated,
1526      * set the DEPRECATED flag.
1527      * If the annotation is marked forRemoval=true, also set DEPRECATED_REMOVAL.
1528      **/
1529     private void handleDeprecatedAnnotations(List&lt;JCAnnotation&gt; annotations, Symbol sym) {
1530         for (List&lt;JCAnnotation&gt; al = annotations; !al.isEmpty(); al = al.tail) {
1531             JCAnnotation a = al.head;
1532             if (a.annotationType.type == syms.deprecatedType) {
1533                 sym.flags_field |= (Flags.DEPRECATED | Flags.DEPRECATED_ANNOTATION);
1534                 setFlagIfAttributeTrue(a, sym, names.forRemoval, DEPRECATED_REMOVAL);
1535             } else if (a.annotationType.type == syms.previewFeatureType) {
1536                 sym.flags_field |= Flags.PREVIEW_API;
1537                 setFlagIfAttributeTrue(a, sym, names.essentialAPI, PREVIEW_ESSENTIAL_API);
1538             }
1539         }
1540     }
1541     //where:
1542         private void setFlagIfAttributeTrue(JCAnnotation a, Symbol sym, Name attribute, long flag) {
1543             a.args.stream()
1544                     .filter(e -&gt; e.hasTag(ASSIGN))
1545                     .map(e -&gt; (JCAssign) e)
1546                     .filter(assign -&gt; TreeInfo.name(assign.lhs) == attribute)
1547                     .findFirst()
1548                     .ifPresent(assign -&gt; {
1549                         JCExpression rhs = TreeInfo.skipParens(assign.rhs);
1550                         if (rhs.hasTag(LITERAL)
1551                                 &amp;&amp; Boolean.TRUE.equals(((JCLiteral) rhs).getValue())) {
1552                             sym.flags_field |= flag;
1553                         }
1554                     });
1555         }
1556 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
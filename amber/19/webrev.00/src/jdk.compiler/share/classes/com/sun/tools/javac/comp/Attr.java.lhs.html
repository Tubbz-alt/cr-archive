<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Attr.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.comp;
  27 
  28 import java.util.*;
  29 import java.util.function.BiConsumer;
  30 import java.util.stream.Collectors;
  31 
  32 import javax.lang.model.element.ElementKind;
  33 import javax.tools.JavaFileObject;
  34 
  35 import com.sun.source.tree.CaseTree;
  36 import com.sun.source.tree.IdentifierTree;
  37 import com.sun.source.tree.MemberReferenceTree.ReferenceMode;
  38 import com.sun.source.tree.MemberSelectTree;
  39 import com.sun.source.tree.TreeVisitor;
  40 import com.sun.source.util.SimpleTreeVisitor;
  41 import com.sun.tools.javac.code.*;
  42 import com.sun.tools.javac.code.Lint.LintCategory;
  43 import com.sun.tools.javac.code.Scope.WriteableScope;
  44 import com.sun.tools.javac.code.Source.Feature;
  45 import com.sun.tools.javac.code.Symbol.*;
  46 import com.sun.tools.javac.code.Type.*;
  47 import com.sun.tools.javac.code.TypeMetadata.Annotations;
  48 import com.sun.tools.javac.code.Types.FunctionDescriptorLookupError;
  49 import com.sun.tools.javac.comp.ArgumentAttr.LocalCacheContext;
  50 import com.sun.tools.javac.comp.Check.CheckContext;
  51 import com.sun.tools.javac.comp.DeferredAttr.AttrMode;
  52 import com.sun.tools.javac.comp.MatchBindingsComputer.MatchBindings;
  53 import com.sun.tools.javac.jvm.*;
  54 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.Diamond;
  55 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.DiamondInvalidArg;
  56 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.DiamondInvalidArgs;
  57 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  58 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  59 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  60 import com.sun.tools.javac.tree.*;
  61 import com.sun.tools.javac.tree.JCTree.*;
  62 import com.sun.tools.javac.tree.JCTree.JCPolyExpression.*;
  63 import com.sun.tools.javac.util.*;
  64 import com.sun.tools.javac.util.DefinedBy.Api;
  65 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  66 import com.sun.tools.javac.util.JCDiagnostic.Error;
  67 import com.sun.tools.javac.util.JCDiagnostic.Fragment;
  68 import com.sun.tools.javac.util.JCDiagnostic.Warning;
  69 import com.sun.tools.javac.util.List;
  70 
  71 import static com.sun.tools.javac.code.Flags.*;
  72 import static com.sun.tools.javac.code.Flags.ANNOTATION;
  73 import static com.sun.tools.javac.code.Flags.BLOCK;
  74 import static com.sun.tools.javac.code.Kinds.*;
  75 import static com.sun.tools.javac.code.Kinds.Kind.*;
  76 import static com.sun.tools.javac.code.TypeTag.*;
  77 import static com.sun.tools.javac.code.TypeTag.WILDCARD;
  78 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  79 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
  80 
  81 /** This is the main context-dependent analysis phase in GJC. It
  82  *  encompasses name resolution, type checking and constant folding as
  83  *  subtasks. Some subtasks involve auxiliary classes.
  84  *  @see Check
  85  *  @see Resolve
  86  *  @see ConstFold
  87  *  @see Infer
  88  *
  89  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  90  *  If you write code that depends on this, you do so at your own risk.
  91  *  This code and its internal interfaces are subject to change or
  92  *  deletion without notice.&lt;/b&gt;
  93  */
  94 public class Attr extends JCTree.Visitor {
  95     protected static final Context.Key&lt;Attr&gt; attrKey = new Context.Key&lt;&gt;();
  96 
  97     final Names names;
  98     final Log log;
  99     final Symtab syms;
 100     final Resolve rs;
 101     final Operators operators;
 102     final Infer infer;
 103     final Analyzer analyzer;
 104     final DeferredAttr deferredAttr;
 105     final Check chk;
 106     final Flow flow;
 107     final MemberEnter memberEnter;
 108     final TypeEnter typeEnter;
 109     final TreeMaker make;
 110     final ConstFold cfolder;
 111     final Enter enter;
 112     final Target target;
 113     final Types types;
 114     final Preview preview;
 115     final JCDiagnostic.Factory diags;
 116     final TypeAnnotations typeAnnotations;
 117     final DeferredLintHandler deferredLintHandler;
 118     final TypeEnvs typeEnvs;
 119     final Dependencies dependencies;
 120     final Annotate annotate;
 121     final ArgumentAttr argumentAttr;
 122     final MatchBindingsComputer matchBindingsComputer;
 123 
 124     public static Attr instance(Context context) {
 125         Attr instance = context.get(attrKey);
 126         if (instance == null)
 127             instance = new Attr(context);
 128         return instance;
 129     }
 130 
 131     protected Attr(Context context) {
 132         context.put(attrKey, this);
 133 
 134         names = Names.instance(context);
 135         log = Log.instance(context);
 136         syms = Symtab.instance(context);
 137         rs = Resolve.instance(context);
 138         operators = Operators.instance(context);
 139         chk = Check.instance(context);
 140         flow = Flow.instance(context);
 141         memberEnter = MemberEnter.instance(context);
 142         typeEnter = TypeEnter.instance(context);
 143         make = TreeMaker.instance(context);
 144         enter = Enter.instance(context);
 145         infer = Infer.instance(context);
 146         analyzer = Analyzer.instance(context);
 147         deferredAttr = DeferredAttr.instance(context);
 148         cfolder = ConstFold.instance(context);
 149         target = Target.instance(context);
 150         types = Types.instance(context);
 151         preview = Preview.instance(context);
 152         diags = JCDiagnostic.Factory.instance(context);
 153         annotate = Annotate.instance(context);
 154         typeAnnotations = TypeAnnotations.instance(context);
 155         deferredLintHandler = DeferredLintHandler.instance(context);
 156         typeEnvs = TypeEnvs.instance(context);
 157         dependencies = Dependencies.instance(context);
 158         argumentAttr = ArgumentAttr.instance(context);
 159         matchBindingsComputer = MatchBindingsComputer.instance(context);
 160 
 161         Options options = Options.instance(context);
 162 
 163         Source source = Source.instance(context);
 164         allowPoly = Feature.POLY.allowedInSource(source);
 165         allowTypeAnnos = Feature.TYPE_ANNOTATIONS.allowedInSource(source);
 166         allowLambda = Feature.LAMBDA.allowedInSource(source);
 167         allowDefaultMethods = Feature.DEFAULT_METHODS.allowedInSource(source);
 168         allowStaticInterfaceMethods = Feature.STATIC_INTERFACE_METHODS.allowedInSource(source);
 169         allowReifiableTypesInInstanceof =
 170                 Feature.REIFIABLE_TYPES_INSTANCEOF.allowedInSource(source) &amp;&amp;
 171                 (!preview.isPreview(Feature.REIFIABLE_TYPES_INSTANCEOF) || preview.isEnabled());
 172         sourceName = source.name;
 173         useBeforeDeclarationWarning = options.isSet(&quot;useBeforeDeclarationWarning&quot;);
 174 
 175         statInfo = new ResultInfo(KindSelector.NIL, Type.noType);
 176         varAssignmentInfo = new ResultInfo(KindSelector.ASG, Type.noType);
 177         unknownExprInfo = new ResultInfo(KindSelector.VAL, Type.noType);
 178         methodAttrInfo = new MethodAttrInfo();
 179         unknownTypeInfo = new ResultInfo(KindSelector.TYP, Type.noType);
 180         unknownTypeExprInfo = new ResultInfo(KindSelector.VAL_TYP, Type.noType);
 181         recoveryInfo = new RecoveryInfo(deferredAttr.emptyDeferredAttrContext);
 182     }
 183 
 184     /** Switch: support target-typing inference
 185      */
 186     boolean allowPoly;
 187 
 188     /** Switch: support type annotations.
 189      */
 190     boolean allowTypeAnnos;
 191 
 192     /** Switch: support lambda expressions ?
 193      */
 194     boolean allowLambda;
 195 
 196     /** Switch: support default methods ?
 197      */
 198     boolean allowDefaultMethods;
 199 
 200     /** Switch: static interface methods enabled?
 201      */
 202     boolean allowStaticInterfaceMethods;
 203 
 204     /** Switch: reifiable types in instanceof enabled?
 205      */
 206     boolean allowReifiableTypesInInstanceof;
 207 
 208     /**
 209      * Switch: warn about use of variable before declaration?
 210      * RFE: 6425594
 211      */
 212     boolean useBeforeDeclarationWarning;
 213 
 214     /**
 215      * Switch: name of source level; used for error reporting.
 216      */
 217     String sourceName;
 218 
 219     /** Check kind and type of given tree against protokind and prototype.
 220      *  If check succeeds, store type in tree and return it.
 221      *  If check fails, store errType in tree and return it.
 222      *  No checks are performed if the prototype is a method type.
 223      *  It is not necessary in this case since we know that kind and type
 224      *  are correct.
 225      *
 226      *  @param tree     The tree whose kind and type is checked
 227      *  @param found    The computed type of the tree
 228      *  @param ownkind  The computed kind of the tree
 229      *  @param resultInfo  The expected result of the tree
 230      */
 231     Type check(final JCTree tree,
 232                final Type found,
 233                final KindSelector ownkind,
 234                final ResultInfo resultInfo) {
 235         InferenceContext inferenceContext = resultInfo.checkContext.inferenceContext();
 236         Type owntype;
 237         boolean shouldCheck = !found.hasTag(ERROR) &amp;&amp;
 238                 !resultInfo.pt.hasTag(METHOD) &amp;&amp;
 239                 !resultInfo.pt.hasTag(FORALL);
 240         if (shouldCheck &amp;&amp; !ownkind.subset(resultInfo.pkind)) {
 241             log.error(tree.pos(),
 242                       Errors.UnexpectedType(resultInfo.pkind.kindNames(),
 243                                             ownkind.kindNames()));
 244             owntype = types.createErrorType(found);
 245         } else if (allowPoly &amp;&amp; inferenceContext.free(found)) {
 246             //delay the check if there are inference variables in the found type
 247             //this means we are dealing with a partially inferred poly expression
 248             owntype = shouldCheck ? resultInfo.pt : found;
 249             if (resultInfo.checkMode.installPostInferenceHook()) {
 250                 inferenceContext.addFreeTypeListener(List.of(found),
 251                         instantiatedContext -&gt; {
 252                             ResultInfo pendingResult =
 253                                     resultInfo.dup(inferenceContext.asInstType(resultInfo.pt));
 254                             check(tree, inferenceContext.asInstType(found), ownkind, pendingResult);
 255                         });
 256             }
 257         } else {
 258             owntype = shouldCheck ?
 259             resultInfo.check(tree, found) :
 260             found;
 261         }
 262         if (resultInfo.checkMode.updateTreeType()) {
 263             tree.type = owntype;
 264         }
 265         return owntype;
 266     }
 267 
 268     /** Is given blank final variable assignable, i.e. in a scope where it
 269      *  may be assigned to even though it is final?
 270      *  @param v      The blank final variable.
 271      *  @param env    The current environment.
 272      */
 273     boolean isAssignableAsBlankFinal(VarSymbol v, Env&lt;AttrContext&gt; env) {
 274         Symbol owner = env.info.scope.owner;
 275            // owner refers to the innermost variable, method or
 276            // initializer block declaration at this point.
 277         return
 278             v.owner == owner
 279             ||
 280             ((owner.name == names.init ||    // i.e. we are in a constructor
 281               owner.kind == VAR ||           // i.e. we are in a variable initializer
 282               (owner.flags() &amp; BLOCK) != 0)  // i.e. we are in an initializer block
 283              &amp;&amp;
 284              v.owner == owner.owner
 285              &amp;&amp;
 286              ((v.flags() &amp; STATIC) != 0) == Resolve.isStatic(env));
 287     }
 288 
 289     /** Check that variable can be assigned to.
 290      *  @param pos    The current source code position.
 291      *  @param v      The assigned variable
 292      *  @param base   If the variable is referred to in a Select, the part
 293      *                to the left of the `.&#39;, null otherwise.
 294      *  @param env    The current environment.
 295      */
 296     void checkAssignable(DiagnosticPosition pos, VarSymbol v, JCTree base, Env&lt;AttrContext&gt; env) {
 297         if (v.name == names._this) {
 298             log.error(pos, Errors.CantAssignValToThis);
 299         } else if ((v.flags() &amp; FINAL) != 0 &amp;&amp;
 300             ((v.flags() &amp; HASINIT) != 0
 301              ||
 302              !((base == null ||
 303                TreeInfo.isThisQualifier(base)) &amp;&amp;
 304                isAssignableAsBlankFinal(v, env)))) {
 305             if (v.isResourceVariable()) { //TWR resource
 306                 log.error(pos, Errors.TryResourceMayNotBeAssigned(v));
 307             } else if ((v.flags() &amp; MATCH_BINDING) != 0) {
 308                 log.error(pos, Errors.PatternBindingMayNotBeAssigned(v));
 309             } else {
 310                 log.error(pos, Errors.CantAssignValToFinalVar(v));
 311             }
 312         }
 313     }
 314 
 315     /** Does tree represent a static reference to an identifier?
 316      *  It is assumed that tree is either a SELECT or an IDENT.
 317      *  We have to weed out selects from non-type names here.
 318      *  @param tree    The candidate tree.
 319      */
 320     boolean isStaticReference(JCTree tree) {
 321         if (tree.hasTag(SELECT)) {
 322             Symbol lsym = TreeInfo.symbol(((JCFieldAccess) tree).selected);
 323             if (lsym == null || lsym.kind != TYP) {
 324                 return false;
 325             }
 326         }
 327         return true;
 328     }
 329 
 330     /** Is this symbol a type?
 331      */
 332     static boolean isType(Symbol sym) {
 333         return sym != null &amp;&amp; sym.kind == TYP;
 334     }
 335 
 336     /** The current `this&#39; symbol.
 337      *  @param env    The current environment.
 338      */
 339     Symbol thisSym(DiagnosticPosition pos, Env&lt;AttrContext&gt; env) {
 340         return rs.resolveSelf(pos, env, env.enclClass.sym, names._this);
 341     }
 342 
 343     /** Attribute a parsed identifier.
 344      * @param tree Parsed identifier name
 345      * @param topLevel The toplevel to use
 346      */
 347     public Symbol attribIdent(JCTree tree, JCCompilationUnit topLevel) {
 348         Env&lt;AttrContext&gt; localEnv = enter.topLevelEnv(topLevel);
 349         localEnv.enclClass = make.ClassDef(make.Modifiers(0),
 350                                            syms.errSymbol.name,
 351                                            null, null, null, null);
 352         localEnv.enclClass.sym = syms.errSymbol;
 353         return attribIdent(tree, localEnv);
 354     }
 355 
 356     /** Attribute a parsed identifier.
 357      * @param tree Parsed identifier name
 358      * @param env The env to use
 359      */
 360     public Symbol attribIdent(JCTree tree, Env&lt;AttrContext&gt; env) {
 361         return tree.accept(identAttributer, env);
 362     }
 363     // where
 364         private TreeVisitor&lt;Symbol,Env&lt;AttrContext&gt;&gt; identAttributer = new IdentAttributer();
 365         private class IdentAttributer extends SimpleTreeVisitor&lt;Symbol,Env&lt;AttrContext&gt;&gt; {
 366             @Override @DefinedBy(Api.COMPILER_TREE)
 367             public Symbol visitMemberSelect(MemberSelectTree node, Env&lt;AttrContext&gt; env) {
 368                 Symbol site = visit(node.getExpression(), env);
 369                 if (site.kind == ERR || site.kind == ABSENT_TYP || site.kind == HIDDEN)
 370                     return site;
 371                 Name name = (Name)node.getIdentifier();
 372                 if (site.kind == PCK) {
 373                     env.toplevel.packge = (PackageSymbol)site;
 374                     return rs.findIdentInPackage(null, env, (TypeSymbol)site, name,
 375                             KindSelector.TYP_PCK);
 376                 } else {
 377                     env.enclClass.sym = (ClassSymbol)site;
 378                     return rs.findMemberType(env, site.asType(), name, (TypeSymbol)site);
 379                 }
 380             }
 381 
 382             @Override @DefinedBy(Api.COMPILER_TREE)
 383             public Symbol visitIdentifier(IdentifierTree node, Env&lt;AttrContext&gt; env) {
 384                 return rs.findIdent(null, env, (Name)node.getName(), KindSelector.TYP_PCK);
 385             }
 386         }
 387 
 388     public Type coerce(Type etype, Type ttype) {
 389         return cfolder.coerce(etype, ttype);
 390     }
 391 
 392     public Type attribType(JCTree node, TypeSymbol sym) {
 393         Env&lt;AttrContext&gt; env = typeEnvs.get(sym);
 394         Env&lt;AttrContext&gt; localEnv = env.dup(node, env.info.dup());
 395         return attribTree(node, localEnv, unknownTypeInfo);
 396     }
 397 
 398     public Type attribImportQualifier(JCImport tree, Env&lt;AttrContext&gt; env) {
 399         // Attribute qualifying package or class.
 400         JCFieldAccess s = (JCFieldAccess)tree.qualid;
 401         return attribTree(s.selected, env,
 402                           new ResultInfo(tree.staticImport ?
 403                                          KindSelector.TYP : KindSelector.TYP_PCK,
 404                        Type.noType));
 405     }
 406 
 407     public Env&lt;AttrContext&gt; attribExprToTree(JCTree expr, Env&lt;AttrContext&gt; env, JCTree tree) {
 408         return attribToTree(expr, env, tree, unknownExprInfo);
 409     }
 410 
 411     public Env&lt;AttrContext&gt; attribStatToTree(JCTree stmt, Env&lt;AttrContext&gt; env, JCTree tree) {
 412         return attribToTree(stmt, env, tree, statInfo);
 413     }
 414 
 415     private Env&lt;AttrContext&gt; attribToTree(JCTree root, Env&lt;AttrContext&gt; env, JCTree tree, ResultInfo resultInfo) {
 416         breakTree = tree;
 417         JavaFileObject prev = log.useSource(env.toplevel.sourcefile);
 418         try {
 419             deferredAttr.attribSpeculative(root, env, resultInfo,
 420                     null, DeferredAttr.AttributionMode.ANALYZER,
 421                     argumentAttr.withLocalCacheContext());
 422         } catch (BreakAttr b) {
 423             return b.env;
 424         } catch (AssertionError ae) {
 425             if (ae.getCause() instanceof BreakAttr) {
 426                 return ((BreakAttr)(ae.getCause())).env;
 427             } else {
 428                 throw ae;
 429             }
 430         } finally {
 431             breakTree = null;
 432             log.useSource(prev);
 433         }
 434         return env;
 435     }
 436 
 437     private JCTree breakTree = null;
 438 
 439     private static class BreakAttr extends RuntimeException {
 440         static final long serialVersionUID = -6924771130405446405L;
 441         private transient Env&lt;AttrContext&gt; env;
 442         private BreakAttr(Env&lt;AttrContext&gt; env) {
 443             this.env = env;
 444         }
 445     }
 446 
 447     /**
 448      * Mode controlling behavior of Attr.Check
 449      */
 450     enum CheckMode {
 451 
 452         NORMAL,
 453 
 454         /**
 455          * Mode signalling &#39;fake check&#39; - skip tree update. A side-effect of this mode is
 456          * that the captured var cache in {@code InferenceContext} will be used in read-only
 457          * mode when performing inference checks.
 458          */
 459         NO_TREE_UPDATE {
 460             @Override
 461             public boolean updateTreeType() {
 462                 return false;
 463             }
 464         },
 465         /**
 466          * Mode signalling that caller will manage free types in tree decorations.
 467          */
 468         NO_INFERENCE_HOOK {
 469             @Override
 470             public boolean installPostInferenceHook() {
 471                 return false;
 472             }
 473         };
 474 
 475         public boolean updateTreeType() {
 476             return true;
 477         }
 478         public boolean installPostInferenceHook() {
 479             return true;
 480         }
 481     }
 482 
 483 
 484     class ResultInfo {
 485         final KindSelector pkind;
 486         final Type pt;
 487         final CheckContext checkContext;
 488         final CheckMode checkMode;
 489 
 490         ResultInfo(KindSelector pkind, Type pt) {
 491             this(pkind, pt, chk.basicHandler, CheckMode.NORMAL);
 492         }
 493 
 494         ResultInfo(KindSelector pkind, Type pt, CheckMode checkMode) {
 495             this(pkind, pt, chk.basicHandler, checkMode);
 496         }
 497 
 498         protected ResultInfo(KindSelector pkind,
 499                              Type pt, CheckContext checkContext) {
 500             this(pkind, pt, checkContext, CheckMode.NORMAL);
 501         }
 502 
 503         protected ResultInfo(KindSelector pkind,
 504                              Type pt, CheckContext checkContext, CheckMode checkMode) {
 505             this.pkind = pkind;
 506             this.pt = pt;
 507             this.checkContext = checkContext;
 508             this.checkMode = checkMode;
 509         }
 510 
 511         /**
 512          * Should {@link Attr#attribTree} use the {@ArgumentAttr} visitor instead of this one?
 513          * @param tree The tree to be type-checked.
 514          * @return true if {@ArgumentAttr} should be used.
 515          */
 516         protected boolean needsArgumentAttr(JCTree tree) { return false; }
 517 
 518         protected Type check(final DiagnosticPosition pos, final Type found) {
 519             return chk.checkType(pos, found, pt, checkContext);
 520         }
 521 
 522         protected ResultInfo dup(Type newPt) {
 523             return new ResultInfo(pkind, newPt, checkContext, checkMode);
 524         }
 525 
 526         protected ResultInfo dup(CheckContext newContext) {
 527             return new ResultInfo(pkind, pt, newContext, checkMode);
 528         }
 529 
 530         protected ResultInfo dup(Type newPt, CheckContext newContext) {
 531             return new ResultInfo(pkind, newPt, newContext, checkMode);
 532         }
 533 
 534         protected ResultInfo dup(Type newPt, CheckContext newContext, CheckMode newMode) {
 535             return new ResultInfo(pkind, newPt, newContext, newMode);
 536         }
 537 
 538         protected ResultInfo dup(CheckMode newMode) {
 539             return new ResultInfo(pkind, pt, checkContext, newMode);
 540         }
 541 
 542         @Override
 543         public String toString() {
 544             if (pt != null) {
 545                 return pt.toString();
 546             } else {
 547                 return &quot;&quot;;
 548             }
 549         }
 550     }
 551 
 552     class MethodAttrInfo extends ResultInfo {
 553         public MethodAttrInfo() {
 554             this(chk.basicHandler);
 555         }
 556 
 557         public MethodAttrInfo(CheckContext checkContext) {
 558             super(KindSelector.VAL, Infer.anyPoly, checkContext);
 559         }
 560 
 561         @Override
 562         protected boolean needsArgumentAttr(JCTree tree) {
 563             return true;
 564         }
 565 
 566         protected ResultInfo dup(Type newPt) {
 567             throw new IllegalStateException();
 568         }
 569 
 570         protected ResultInfo dup(CheckContext newContext) {
 571             return new MethodAttrInfo(newContext);
 572         }
 573 
 574         protected ResultInfo dup(Type newPt, CheckContext newContext) {
 575             throw new IllegalStateException();
 576         }
 577 
 578         protected ResultInfo dup(Type newPt, CheckContext newContext, CheckMode newMode) {
 579             throw new IllegalStateException();
 580         }
 581 
 582         protected ResultInfo dup(CheckMode newMode) {
 583             throw new IllegalStateException();
 584         }
 585     }
 586 
 587     class RecoveryInfo extends ResultInfo {
 588 
 589         public RecoveryInfo(final DeferredAttr.DeferredAttrContext deferredAttrContext) {
 590             this(deferredAttrContext, Type.recoveryType);
 591         }
 592 
 593         public RecoveryInfo(final DeferredAttr.DeferredAttrContext deferredAttrContext, Type pt) {
 594             super(KindSelector.VAL, pt, new Check.NestedCheckContext(chk.basicHandler) {
 595                 @Override
 596                 public DeferredAttr.DeferredAttrContext deferredAttrContext() {
 597                     return deferredAttrContext;
 598                 }
 599                 @Override
 600                 public boolean compatible(Type found, Type req, Warner warn) {
 601                     return true;
 602                 }
 603                 @Override
 604                 public void report(DiagnosticPosition pos, JCDiagnostic details) {
 605                     if (pt == Type.recoveryType) {
 606                         chk.basicHandler.report(pos, details);
 607                     }
 608                 }
 609             });
 610         }
 611     }
 612 
 613     final ResultInfo statInfo;
 614     final ResultInfo varAssignmentInfo;
 615     final ResultInfo methodAttrInfo;
 616     final ResultInfo unknownExprInfo;
 617     final ResultInfo unknownTypeInfo;
 618     final ResultInfo unknownTypeExprInfo;
 619     final ResultInfo recoveryInfo;
 620 
 621     Type pt() {
 622         return resultInfo.pt;
 623     }
 624 
 625     KindSelector pkind() {
 626         return resultInfo.pkind;
 627     }
 628 
 629 /* ************************************************************************
 630  * Visitor methods
 631  *************************************************************************/
 632 
 633     /** Visitor argument: the current environment.
 634      */
 635     Env&lt;AttrContext&gt; env;
 636 
 637     /** Visitor argument: the currently expected attribution result.
 638      */
 639     ResultInfo resultInfo;
 640 
 641     /** Visitor result: the computed type.
 642      */
 643     Type result;
 644 
 645     MatchBindings matchBindings = MatchBindingsComputer.EMPTY;
 646 
 647     /** Visitor method: attribute a tree, catching any completion failure
 648      *  exceptions. Return the tree&#39;s type.
 649      *
 650      *  @param tree    The tree to be visited.
 651      *  @param env     The environment visitor argument.
 652      *  @param resultInfo   The result info visitor argument.
 653      */
 654     Type attribTree(JCTree tree, Env&lt;AttrContext&gt; env, ResultInfo resultInfo) {
 655         Env&lt;AttrContext&gt; prevEnv = this.env;
 656         ResultInfo prevResult = this.resultInfo;
 657         try {
 658             this.env = env;
 659             this.resultInfo = resultInfo;
 660             if (resultInfo.needsArgumentAttr(tree)) {
 661                 result = argumentAttr.attribArg(tree, env);
 662             } else {
 663                 tree.accept(this);
 664             }
 665             matchBindings = matchBindingsComputer.finishBindings(tree,
 666                                                                  matchBindings);
 667             if (tree == breakTree &amp;&amp;
 668                     resultInfo.checkContext.deferredAttrContext().mode == AttrMode.CHECK) {
 669                 breakTreeFound(copyEnv(env));
 670             }
 671             return result;
 672         } catch (CompletionFailure ex) {
 673             tree.type = syms.errType;
 674             return chk.completionError(tree.pos(), ex);
 675         } finally {
 676             this.env = prevEnv;
 677             this.resultInfo = prevResult;
 678         }
 679     }
 680 
 681     protected void breakTreeFound(Env&lt;AttrContext&gt; env) {
 682         throw new BreakAttr(env);
 683     }
 684 
 685     Env&lt;AttrContext&gt; copyEnv(Env&lt;AttrContext&gt; env) {
 686         Env&lt;AttrContext&gt; newEnv =
 687                 env.dup(env.tree, env.info.dup(copyScope(env.info.scope)));
 688         if (newEnv.outer != null) {
 689             newEnv.outer = copyEnv(newEnv.outer);
 690         }
 691         return newEnv;
 692     }
 693 
 694     WriteableScope copyScope(WriteableScope sc) {
 695         WriteableScope newScope = WriteableScope.create(sc.owner);
 696         List&lt;Symbol&gt; elemsList = List.nil();
 697         for (Symbol sym : sc.getSymbols()) {
 698             elemsList = elemsList.prepend(sym);
 699         }
 700         for (Symbol s : elemsList) {
 701             newScope.enter(s);
 702         }
 703         return newScope;
 704     }
 705 
 706     /** Derived visitor method: attribute an expression tree.
 707      */
 708     public Type attribExpr(JCTree tree, Env&lt;AttrContext&gt; env, Type pt) {
 709         return attribTree(tree, env, new ResultInfo(KindSelector.VAL, !pt.hasTag(ERROR) ? pt : Type.noType));
 710     }
 711 
 712     /** Derived visitor method: attribute an expression tree with
 713      *  no constraints on the computed type.
 714      */
 715     public Type attribExpr(JCTree tree, Env&lt;AttrContext&gt; env) {
 716         return attribTree(tree, env, unknownExprInfo);
 717     }
 718 
 719     /** Derived visitor method: attribute a type tree.
 720      */
 721     public Type attribType(JCTree tree, Env&lt;AttrContext&gt; env) {
 722         Type result = attribType(tree, env, Type.noType);
 723         return result;
 724     }
 725 
 726     /** Derived visitor method: attribute a type tree.
 727      */
 728     Type attribType(JCTree tree, Env&lt;AttrContext&gt; env, Type pt) {
 729         Type result = attribTree(tree, env, new ResultInfo(KindSelector.TYP, pt));
 730         return result;
 731     }
 732 
 733     /** Derived visitor method: attribute a statement or definition tree.
 734      */
 735     public Type attribStat(JCTree tree, Env&lt;AttrContext&gt; env) {
 736         Env&lt;AttrContext&gt; analyzeEnv = analyzer.copyEnvIfNeeded(tree, env);
 737         Type result = attribTree(tree, env, statInfo);
 738         analyzer.analyzeIfNeeded(tree, analyzeEnv);
 739         return result;
 740     }
 741 
 742     /** Attribute a list of expressions, returning a list of types.
 743      */
 744     List&lt;Type&gt; attribExprs(List&lt;JCExpression&gt; trees, Env&lt;AttrContext&gt; env, Type pt) {
 745         ListBuffer&lt;Type&gt; ts = new ListBuffer&lt;&gt;();
 746         for (List&lt;JCExpression&gt; l = trees; l.nonEmpty(); l = l.tail)
 747             ts.append(attribExpr(l.head, env, pt));
 748         return ts.toList();
 749     }
 750 
 751     /** Attribute a list of statements, returning nothing.
 752      */
 753     &lt;T extends JCTree&gt; void attribStats(List&lt;T&gt; trees, Env&lt;AttrContext&gt; env) {
 754         for (List&lt;T&gt; l = trees; l.nonEmpty(); l = l.tail)
 755             attribStat(l.head, env);
 756     }
 757 
 758     /** Attribute the arguments in a method call, returning the method kind.
 759      */
 760     KindSelector attribArgs(KindSelector initialKind, List&lt;JCExpression&gt; trees, Env&lt;AttrContext&gt; env, ListBuffer&lt;Type&gt; argtypes) {
 761         KindSelector kind = initialKind;
 762         for (JCExpression arg : trees) {
 763             Type argtype = chk.checkNonVoid(arg, attribTree(arg, env, allowPoly ? methodAttrInfo : unknownExprInfo));
 764             if (argtype.hasTag(DEFERRED)) {
 765                 kind = KindSelector.of(KindSelector.POLY, kind);
 766             }
 767             argtypes.append(argtype);
 768         }
 769         return kind;
 770     }
 771 
 772     /** Attribute a type argument list, returning a list of types.
 773      *  Caller is responsible for calling checkRefTypes.
 774      */
 775     List&lt;Type&gt; attribAnyTypes(List&lt;JCExpression&gt; trees, Env&lt;AttrContext&gt; env) {
 776         ListBuffer&lt;Type&gt; argtypes = new ListBuffer&lt;&gt;();
 777         for (List&lt;JCExpression&gt; l = trees; l.nonEmpty(); l = l.tail)
 778             argtypes.append(attribType(l.head, env));
 779         return argtypes.toList();
 780     }
 781 
 782     /** Attribute a type argument list, returning a list of types.
 783      *  Check that all the types are references.
 784      */
 785     List&lt;Type&gt; attribTypes(List&lt;JCExpression&gt; trees, Env&lt;AttrContext&gt; env) {
 786         List&lt;Type&gt; types = attribAnyTypes(trees, env);
 787         return chk.checkRefTypes(trees, types);
 788     }
 789 
 790     /**
 791      * Attribute type variables (of generic classes or methods).
 792      * Compound types are attributed later in attribBounds.
 793      * @param typarams the type variables to enter
 794      * @param env      the current environment
 795      */
 796     void attribTypeVariables(List&lt;JCTypeParameter&gt; typarams, Env&lt;AttrContext&gt; env, boolean checkCyclic) {
 797         for (JCTypeParameter tvar : typarams) {
 798             TypeVar a = (TypeVar)tvar.type;
 799             a.tsym.flags_field |= UNATTRIBUTED;
 800             a.setUpperBound(Type.noType);
 801             if (!tvar.bounds.isEmpty()) {
 802                 List&lt;Type&gt; bounds = List.of(attribType(tvar.bounds.head, env));
 803                 for (JCExpression bound : tvar.bounds.tail)
 804                     bounds = bounds.prepend(attribType(bound, env));
 805                 types.setBounds(a, bounds.reverse());
 806             } else {
 807                 // if no bounds are given, assume a single bound of
 808                 // java.lang.Object.
 809                 types.setBounds(a, List.of(syms.objectType));
 810             }
 811             a.tsym.flags_field &amp;= ~UNATTRIBUTED;
 812         }
 813         if (checkCyclic) {
 814             for (JCTypeParameter tvar : typarams) {
 815                 chk.checkNonCyclic(tvar.pos(), (TypeVar)tvar.type);
 816             }
 817         }
 818     }
 819 
 820     /**
 821      * Attribute the type references in a list of annotations.
 822      */
 823     void attribAnnotationTypes(List&lt;JCAnnotation&gt; annotations,
 824                                Env&lt;AttrContext&gt; env) {
 825         for (List&lt;JCAnnotation&gt; al = annotations; al.nonEmpty(); al = al.tail) {
 826             JCAnnotation a = al.head;
 827             attribType(a.annotationType, env);
 828         }
 829     }
 830 
 831     /**
 832      * Attribute a &quot;lazy constant value&quot;.
 833      *  @param env         The env for the const value
 834      *  @param variable    The initializer for the const value
 835      *  @param type        The expected type, or null
 836      *  @see VarSymbol#setLazyConstValue
 837      */
 838     public Object attribLazyConstantValue(Env&lt;AttrContext&gt; env,
 839                                       JCVariableDecl variable,
 840                                       Type type) {
 841 
 842         DiagnosticPosition prevLintPos
 843                 = deferredLintHandler.setPos(variable.pos());
 844 
 845         final JavaFileObject prevSource = log.useSource(env.toplevel.sourcefile);
 846         try {
 847             Type itype = attribExpr(variable.init, env, type);
 848             if (variable.isImplicitlyTyped()) {
 849                 //fixup local variable type
 850                 type = variable.type = variable.sym.type = chk.checkLocalVarType(variable, itype.baseType(), variable.name);
 851             }
 852             if (itype.constValue() != null) {
 853                 return coerce(itype, type).constValue();
 854             } else {
 855                 return null;
 856             }
 857         } finally {
 858             log.useSource(prevSource);
 859             deferredLintHandler.setPos(prevLintPos);
 860         }
 861     }
 862 
 863     /** Attribute type reference in an `extends&#39; or `implements&#39; clause.
 864      *  Supertypes of anonymous inner classes are usually already attributed.
 865      *
 866      *  @param tree              The tree making up the type reference.
 867      *  @param env               The environment current at the reference.
 868      *  @param classExpected     true if only a class is expected here.
 869      *  @param interfaceExpected true if only an interface is expected here.
 870      */
 871     Type attribBase(JCTree tree,
 872                     ClassSymbol subType,
 873                     Env&lt;AttrContext&gt; env,
 874                     boolean classExpected,
 875                     boolean interfaceExpected,
 876                     boolean checkExtensible) {
 877         Type t = tree.type != null ?
 878             tree.type :
 879             attribType(tree, env);
 880         return checkBase(t, subType, tree, env, classExpected, interfaceExpected, checkExtensible);
 881     }
 882     Type checkBase(Type t,
 883                    ClassSymbol subType,
 884                    JCTree tree,
 885                    Env&lt;AttrContext&gt; env,
 886                    boolean classExpected,
 887                    boolean interfaceExpected,
 888                    boolean checkExtensible) {
 889         final DiagnosticPosition pos = tree.hasTag(TYPEAPPLY) ?
 890                 (((JCTypeApply) tree).clazz).pos() : tree.pos();
 891         if (t.tsym.isAnonymous()) {
 892             log.error(pos, Errors.CantInheritFromAnon);
 893             return types.createErrorType(t);
 894         }
 895         if (t.isErroneous())
 896             return t;
 897         if (t.hasTag(TYPEVAR) &amp;&amp; !classExpected &amp;&amp; !interfaceExpected) {
 898             // check that type variable is already visible
 899             if (t.getUpperBound() == null) {
 900                 log.error(pos, Errors.IllegalForwardRef);
 901                 return types.createErrorType(t);
 902             }
 903         } else {
 904             t = chk.checkClassType(pos, t, checkExtensible);
 905         }
 906         if (interfaceExpected &amp;&amp; (t.tsym.flags() &amp; INTERFACE) == 0) {
 907             log.error(pos, Errors.IntfExpectedHere);
 908             // return errType is necessary since otherwise there might
 909             // be undetected cycles which cause attribution to loop
 910             return types.createErrorType(t);
 911         } else if (checkExtensible &amp;&amp;
 912                    classExpected &amp;&amp;
 913                    (t.tsym.flags() &amp; INTERFACE) != 0) {
 914             log.error(pos, Errors.NoIntfExpectedHere);
 915             return types.createErrorType(t);
 916         }
 917         if (checkExtensible &amp;&amp;
 918             ((t.tsym.flags() &amp; FINAL) != 0)) {
 919             log.error(pos,
 920                       Errors.CantInheritFromFinal(t.tsym));
 921         }
 922         chk.checkNonCyclic(pos, t);
 923         return t;
 924     }
 925 
 926     Type attribIdentAsEnumType(Env&lt;AttrContext&gt; env, JCIdent id) {
 927         Assert.check((env.enclClass.sym.flags() &amp; ENUM) != 0);
 928         id.type = env.info.scope.owner.enclClass().type;
 929         id.sym = env.info.scope.owner.enclClass();
 930         return id.type;
 931     }
 932 
 933     public void visitClassDef(JCClassDecl tree) {
 934         Optional&lt;ArgumentAttr.LocalCacheContext&gt; localCacheContext =
 935                 Optional.ofNullable(env.info.attributionMode.isSpeculative ?
 936                         argumentAttr.withLocalCacheContext() : null);
 937         try {
 938             // Local and anonymous classes have not been entered yet, so we need to
 939             // do it now.
 940             if (env.info.scope.owner.kind.matches(KindSelector.VAL_MTH)) {
 941                 enter.classEnter(tree, env);
 942             } else {
 943                 // If this class declaration is part of a class level annotation,
 944                 // as in @MyAnno(new Object() {}) class MyClass {}, enter it in
 945                 // order to simplify later steps and allow for sensible error
 946                 // messages.
 947                 if (env.tree.hasTag(NEWCLASS) &amp;&amp; TreeInfo.isInAnnotation(env, tree))
 948                     enter.classEnter(tree, env);
 949             }
 950 
 951             ClassSymbol c = tree.sym;
 952             if (c == null) {
 953                 // exit in case something drastic went wrong during enter.
 954                 result = null;
 955             } else {
 956                 // make sure class has been completed:
 957                 c.complete();
 958 
 959                 // If this class appears as an anonymous class
 960                 // in a superclass constructor call
 961                 // disable implicit outer instance from being passed.
 962                 // (This would be an illegal access to &quot;this before super&quot;).
 963                 if (env.info.isSelfCall &amp;&amp;
 964                         env.tree.hasTag(NEWCLASS)) {
 965                     c.flags_field |= NOOUTERTHIS;
 966                 }
 967                 attribClass(tree.pos(), c);
 968                 result = tree.type = c.type;
 969             }
 970         } finally {
 971             localCacheContext.ifPresent(LocalCacheContext::leave);
 972         }
 973     }
 974 
 975     public void visitMethodDef(JCMethodDecl tree) {
 976         MethodSymbol m = tree.sym;
 977         boolean isDefaultMethod = (m.flags() &amp; DEFAULT) != 0;
 978 
 979         Lint lint = env.info.lint.augment(m);
 980         Lint prevLint = chk.setLint(lint);
 981         MethodSymbol prevMethod = chk.setMethod(m);
 982         try {
 983             deferredLintHandler.flush(tree.pos());
 984             chk.checkDeprecatedAnnotation(tree.pos(), m);
 985 
 986 
 987             // Create a new environment with local scope
 988             // for attributing the method.
 989             Env&lt;AttrContext&gt; localEnv = memberEnter.methodEnv(tree, env);
 990             localEnv.info.lint = lint;
 991 
 992             attribStats(tree.typarams, localEnv);
 993 
 994             // If we override any other methods, check that we do so properly.
 995             // JLS ???
 996             if (m.isStatic()) {
 997                 chk.checkHideClashes(tree.pos(), env.enclClass.type, m);
 998             } else {
 999                 chk.checkOverrideClashes(tree.pos(), env.enclClass.type, m);
1000             }
1001             chk.checkOverride(env, tree, m);
1002 
1003             if (isDefaultMethod &amp;&amp; types.overridesObjectMethod(m.enclClass(), m)) {
1004                 log.error(tree, Errors.DefaultOverridesObjectMember(m.name, Kinds.kindName(m.location()), m.location()));
1005             }
1006 
1007             // Enter all type parameters into the local method scope.
1008             for (List&lt;JCTypeParameter&gt; l = tree.typarams; l.nonEmpty(); l = l.tail)
1009                 localEnv.info.scope.enterIfAbsent(l.head.type.tsym);
1010 
1011             ClassSymbol owner = env.enclClass.sym;
1012             if ((owner.flags() &amp; ANNOTATION) != 0 &amp;&amp;
1013                     (tree.params.nonEmpty() ||
1014                     tree.recvparam != null))
1015                 log.error(tree.params.nonEmpty() ?
1016                         tree.params.head.pos() :
1017                         tree.recvparam.pos(),
1018                         Errors.IntfAnnotationMembersCantHaveParams);
1019 
1020             // Attribute all value parameters.
1021             for (List&lt;JCVariableDecl&gt; l = tree.params; l.nonEmpty(); l = l.tail) {
1022                 attribStat(l.head, localEnv);
1023             }
1024 
1025             chk.checkVarargsMethodDecl(localEnv, tree);
1026 
1027             // Check that type parameters are well-formed.
1028             chk.validate(tree.typarams, localEnv);
1029 
1030             // Check that result type is well-formed.
1031             if (tree.restype != null &amp;&amp; !tree.restype.type.hasTag(VOID))
1032                 chk.validate(tree.restype, localEnv);
1033 
1034             // Check that receiver type is well-formed.
1035             if (tree.recvparam != null) {
1036                 // Use a new environment to check the receiver parameter.
1037                 // Otherwise I get &quot;might not have been initialized&quot; errors.
1038                 // Is there a better way?
1039                 Env&lt;AttrContext&gt; newEnv = memberEnter.methodEnv(tree, env);
1040                 attribType(tree.recvparam, newEnv);
1041                 chk.validate(tree.recvparam, newEnv);
1042             }
1043 
1044             if (env.enclClass.sym.isRecord() &amp;&amp; tree.sym.owner.kind == TYP) {
1045                 // lets find if this method is an accessor
1046                 Optional&lt;? extends RecordComponent&gt; recordComponent = env.enclClass.sym.getRecordComponents().stream()
1047                         .filter(rc -&gt; rc.accessor == tree.sym &amp;&amp; (rc.accessor.flags_field &amp; GENERATED_MEMBER) == 0).findFirst();
1048                 if (recordComponent.isPresent()) {
1049                     // the method is a user defined accessor lets check that everything is fine
1050                     if (!tree.sym.isPublic()) {
1051                         log.error(tree, Errors.InvalidAccessorMethodInRecord(env.enclClass.sym, Fragments.MethodMustBePublic));
1052                     }
1053                     if (!types.isSameType(tree.sym.type.getReturnType(), recordComponent.get().type)) {
1054                         log.error(tree, Errors.InvalidAccessorMethodInRecord(env.enclClass.sym,
1055                                 Fragments.AccessorReturnTypeDoesntMatch(tree.sym, recordComponent.get())));
1056                     }
1057                     if (tree.sym.type.asMethodType().thrown != null &amp;&amp; !tree.sym.type.asMethodType().thrown.isEmpty()) {
1058                         log.error(tree,
1059                                 Errors.InvalidAccessorMethodInRecord(env.enclClass.sym, Fragments.AccessorMethodCantThrowException));
1060                     }
1061                     if (!tree.typarams.isEmpty()) {
1062                         log.error(tree,
1063                                 Errors.InvalidAccessorMethodInRecord(env.enclClass.sym, Fragments.AccessorMethodMustNotBeGeneric));
1064                     }
1065                     if (tree.sym.isStatic()) {
1066                         log.error(tree,
1067                                 Errors.InvalidAccessorMethodInRecord(env.enclClass.sym, Fragments.AccessorMethodMustNotBeStatic));
1068                     }
1069                 }
1070 
1071                 if (tree.name == names.init) {
1072                     // if this a constructor other than the canonical one
1073                     if ((tree.sym.flags_field &amp; RECORD) == 0) {
1074                         JCMethodInvocation app = TreeInfo.firstConstructorCall(tree);
1075                         if (app == null ||
1076                                 TreeInfo.name(app.meth) != names._this ||
1077                                 !checkFirstConstructorStat(app, tree, false)) {
1078                             log.error(tree, Errors.FirstStatementMustBeCallToAnotherConstructor);
1079                         }
1080                     } else {
1081                         // but if it is the canonical:
1082 
1083                         // if user generated, then it shouldn&#39;t explicitly invoke any other constructor
1084                         if ((tree.sym.flags_field &amp; GENERATEDCONSTR) == 0) {
1085                             JCMethodInvocation app = TreeInfo.firstConstructorCall(tree);
1086                             if (app != null &amp;&amp;
1087                                     (TreeInfo.name(app.meth) == names._this ||
1088                                             TreeInfo.name(app.meth) == names._super) &amp;&amp;
1089                                     checkFirstConstructorStat(app, tree, false)) {
1090                                 log.error(tree, Errors.InvalidCanonicalConstructorInRecord(
1091                                         Fragments.Canonical, tree.sym.name,
1092                                         Fragments.CanonicalMustNotContainExplicitConstructorInvocation));
1093                             }
1094                         }
1095 
1096                         // also we want to check that no type variables have been defined
1097                         if (!tree.typarams.isEmpty()) {
1098                             log.error(tree, Errors.InvalidCanonicalConstructorInRecord(
1099                                     Fragments.Canonical, tree.sym.name, Fragments.CanonicalMustNotDeclareTypeVariables));
1100                         }
1101 
1102                         /* and now we need to check that the constructor&#39;s arguments are exactly the same as those of the
1103                          * record components
1104                          */
1105                         List&lt;Type&gt; recordComponentTypes = TreeInfo.recordFields(env.enclClass).map(vd -&gt; vd.sym.type);
1106                         for (JCVariableDecl param: tree.params) {
1107                             if (!types.isSameType(param.type, recordComponentTypes.head)) {
1108                                 log.error(param, Errors.InvalidCanonicalConstructorInRecord(
1109                                         Fragments.Canonical, tree.sym.name, Fragments.TypeMustBeIdenticalToCorrespondingRecordComponentType));
1110                             }
1111                             recordComponentTypes = recordComponentTypes.tail;
1112                         }
1113                     }
1114                 }
1115             }
1116 
1117             // annotation method checks
1118             if ((owner.flags() &amp; ANNOTATION) != 0) {
1119                 // annotation method cannot have throws clause
1120                 if (tree.thrown.nonEmpty()) {
1121                     log.error(tree.thrown.head.pos(),
1122                               Errors.ThrowsNotAllowedInIntfAnnotation);
1123                 }
1124                 // annotation method cannot declare type-parameters
1125                 if (tree.typarams.nonEmpty()) {
1126                     log.error(tree.typarams.head.pos(),
1127                               Errors.IntfAnnotationMembersCantHaveTypeParams);
1128                 }
1129                 // validate annotation method&#39;s return type (could be an annotation type)
1130                 chk.validateAnnotationType(tree.restype);
1131                 // ensure that annotation method does not clash with members of Object/Annotation
1132                 chk.validateAnnotationMethod(tree.pos(), m);
1133             }
1134 
1135             for (List&lt;JCExpression&gt; l = tree.thrown; l.nonEmpty(); l = l.tail)
1136                 chk.checkType(l.head.pos(), l.head.type, syms.throwableType);
1137 
1138             if (tree.body == null) {
1139                 // Empty bodies are only allowed for
1140                 // abstract, native, or interface methods, or for methods
1141                 // in a retrofit signature class.
1142                 if (tree.defaultValue != null) {
1143                     if ((owner.flags() &amp; ANNOTATION) == 0)
1144                         log.error(tree.pos(),
1145                                   Errors.DefaultAllowedInIntfAnnotationMember);
1146                 }
1147                 if (isDefaultMethod || (tree.sym.flags() &amp; (ABSTRACT | NATIVE)) == 0)
1148                     log.error(tree.pos(), Errors.MissingMethBodyOrDeclAbstract);
1149             } else if ((tree.sym.flags() &amp; (ABSTRACT|DEFAULT|PRIVATE)) == ABSTRACT) {
1150                 if ((owner.flags() &amp; INTERFACE) != 0) {
1151                     log.error(tree.body.pos(), Errors.IntfMethCantHaveBody);
1152                 } else {
1153                     log.error(tree.pos(), Errors.AbstractMethCantHaveBody);
1154                 }
1155             } else if ((tree.mods.flags &amp; NATIVE) != 0) {
1156                 log.error(tree.pos(), Errors.NativeMethCantHaveBody);
1157             } else {
1158                 // Add an implicit super() call unless an explicit call to
1159                 // super(...) or this(...) is given
1160                 // or we are compiling class java.lang.Object.
1161                 if (tree.name == names.init &amp;&amp; owner.type != syms.objectType) {
1162                     JCBlock body = tree.body;
1163                     if (body.stats.isEmpty() ||
1164                             TreeInfo.getConstructorInvocationName(body.stats, names) == names.empty) {
1165                         JCStatement supCall = make.at(body.pos).Exec(make.Apply(List.nil(),
1166                                 make.Ident(names._super), make.Idents(List.nil())));
1167                         body.stats = body.stats.prepend(supCall);
1168                     } else if ((env.enclClass.sym.flags() &amp; ENUM) != 0 &amp;&amp;
1169                             (tree.mods.flags &amp; GENERATEDCONSTR) == 0 &amp;&amp;
1170                             TreeInfo.isSuperCall(body.stats.head)) {
1171                         // enum constructors are not allowed to call super
1172                         // directly, so make sure there aren&#39;t any super calls
1173                         // in enum constructors, except in the compiler
1174                         // generated one.
1175                         log.error(tree.body.stats.head.pos(),
1176                                   Errors.CallToSuperNotAllowedInEnumCtor(env.enclClass.sym));
1177                     }
1178                     if (env.enclClass.sym.isRecord() &amp;&amp; (tree.sym.flags_field &amp; RECORD) != 0) { // we are seeing the canonical constructor
1179                         List&lt;Name&gt; recordComponentNames = TreeInfo.recordFields(env.enclClass).map(vd -&gt; vd.sym.name);
1180                         List&lt;Name&gt; initParamNames = tree.sym.params.map(p -&gt; p.name);
1181                         if (!initParamNames.equals(recordComponentNames)) {
1182                             log.error(tree, Errors.InvalidCanonicalConstructorInRecord(
1183                                     Fragments.Canonical, env.enclClass.sym.name, Fragments.CanonicalWithNameMismatch));
1184                         }
1185                         if (!tree.sym.isPublic()) {
1186                             log.error(tree, Errors.InvalidCanonicalConstructorInRecord(
1187                                     TreeInfo.isCompactConstructor(tree) ? Fragments.Compact : Fragments.Canonical,
1188                                     env.enclClass.sym.name, Fragments.CanonicalConstructorMustBePublic));
1189                         }
1190                         if (tree.sym.type.asMethodType().thrown != null &amp;&amp; !tree.sym.type.asMethodType().thrown.isEmpty()) {
1191                             log.error(tree,
1192                                     Errors.InvalidCanonicalConstructorInRecord(
1193                                             TreeInfo.isCompactConstructor(tree) ? Fragments.Compact : Fragments.Canonical,
1194                                             env.enclClass.sym.name,
1195                                             Fragments.ThrowsClauseNotAllowedForCanonicalConstructor(
1196                                                     TreeInfo.isCompactConstructor(tree) ? Fragments.Compact : Fragments.Canonical)));
1197                         }
1198                     }
1199                 }
1200 
1201                 // Attribute all type annotations in the body
1202                 annotate.queueScanTreeAndTypeAnnotate(tree.body, localEnv, m, null);
1203                 annotate.flush();
1204 
1205                 // Attribute method body.
1206                 attribStat(tree.body, localEnv);
1207             }
1208 
1209             localEnv.info.scope.leave();
1210             result = tree.type = m.type;
1211         } finally {
1212             chk.setLint(prevLint);
1213             chk.setMethod(prevMethod);
1214         }
1215     }
1216 
1217     public void visitVarDef(JCVariableDecl tree) {
1218         // Local variables have not been entered yet, so we need to do it now:
1219         if (env.info.scope.owner.kind == MTH || env.info.scope.owner.kind == VAR) {
1220             if (tree.sym != null) {
1221                 // parameters have already been entered
1222                 env.info.scope.enter(tree.sym);
1223             } else {
1224                 if (tree.isImplicitlyTyped() &amp;&amp; (tree.getModifiers().flags &amp; PARAMETER) == 0) {
1225                     if (tree.init == null) {
1226                         //cannot use &#39;var&#39; without initializer
1227                         log.error(tree, Errors.CantInferLocalVarType(tree.name, Fragments.LocalMissingInit));
1228                         tree.vartype = make.Erroneous();
1229                     } else {
1230                         Fragment msg = canInferLocalVarType(tree);
1231                         if (msg != null) {
1232                             //cannot use &#39;var&#39; with initializer which require an explicit target
1233                             //(e.g. lambda, method reference, array initializer).
1234                             log.error(tree, Errors.CantInferLocalVarType(tree.name, msg));
1235                             tree.vartype = make.Erroneous();
1236                         }
1237                     }
1238                 }
1239                 try {
1240                     annotate.blockAnnotations();
1241                     memberEnter.memberEnter(tree, env);
1242                 } finally {
1243                     annotate.unblockAnnotations();
1244                 }
1245             }
1246         } else {
1247             if (tree.init != null) {
1248                 // Field initializer expression need to be entered.
1249                 annotate.queueScanTreeAndTypeAnnotate(tree.init, env, tree.sym, tree.pos());
1250                 annotate.flush();
1251             }
1252         }
1253 
1254         VarSymbol v = tree.sym;
1255         Lint lint = env.info.lint.augment(v);
1256         Lint prevLint = chk.setLint(lint);
1257 
1258         // Check that the variable&#39;s declared type is well-formed.
1259         boolean isImplicitLambdaParameter = env.tree.hasTag(LAMBDA) &amp;&amp;
1260                 ((JCLambda)env.tree).paramKind == JCLambda.ParameterKind.IMPLICIT &amp;&amp;
1261                 (tree.sym.flags() &amp; PARAMETER) != 0;
1262         chk.validate(tree.vartype, env, !isImplicitLambdaParameter &amp;&amp; !tree.isImplicitlyTyped());
1263 
1264         try {
1265             v.getConstValue(); // ensure compile-time constant initializer is evaluated
1266             deferredLintHandler.flush(tree.pos());
1267             chk.checkDeprecatedAnnotation(tree.pos(), v);
1268 
1269             if (tree.init != null) {
1270                 if ((v.flags_field &amp; FINAL) == 0 ||
1271                     !memberEnter.needsLazyConstValue(tree.init)) {
1272                     // Not a compile-time constant
1273                     // Attribute initializer in a new environment
1274                     // with the declared variable as owner.
1275                     // Check that initializer conforms to variable&#39;s declared type.
1276                     Env&lt;AttrContext&gt; initEnv = memberEnter.initEnv(tree, env);
1277                     initEnv.info.lint = lint;
1278                     // In order to catch self-references, we set the variable&#39;s
1279                     // declaration position to maximal possible value, effectively
1280                     // marking the variable as undefined.
1281                     initEnv.info.enclVar = v;
1282                     attribExpr(tree.init, initEnv, v.type);
1283                     if (tree.isImplicitlyTyped()) {
1284                         //fixup local variable type
1285                         v.type = chk.checkLocalVarType(tree, tree.init.type.baseType(), tree.name);
1286                     }
1287                 }
1288                 if (tree.isImplicitlyTyped()) {
1289                     setSyntheticVariableType(tree, v.type);
1290                 }
1291             }
1292             result = tree.type = v.type;
1293             if (env.enclClass.sym.isRecord() &amp;&amp; tree.sym.owner.kind == TYP &amp;&amp; !v.isStatic()) {
1294                 if (isNonArgsMethodInObject(v.name)) {
1295                     log.error(tree, Errors.IllegalRecordComponentName(v));
1296                 }
1297             }
1298         }
1299         finally {
1300             chk.setLint(prevLint);
1301         }
1302     }
1303 
1304     private boolean isNonArgsMethodInObject(Name name) {
1305         for (Symbol s : syms.objectType.tsym.members().getSymbolsByName(name, s -&gt; s.kind == MTH)) {
1306             if (s.type.getParameterTypes().isEmpty()) {
1307                 return true;
1308             }
1309         }
1310         return false;
1311     }
1312 
1313     Fragment canInferLocalVarType(JCVariableDecl tree) {
1314         LocalInitScanner lis = new LocalInitScanner();
1315         lis.scan(tree.init);
1316         return lis.badInferenceMsg;
1317     }
1318 
1319     static class LocalInitScanner extends TreeScanner {
1320         Fragment badInferenceMsg = null;
1321         boolean needsTarget = true;
1322 
1323         @Override
1324         public void visitNewArray(JCNewArray tree) {
1325             if (tree.elemtype == null &amp;&amp; needsTarget) {
1326                 badInferenceMsg = Fragments.LocalArrayMissingTarget;
1327             }
1328         }
1329 
1330         @Override
1331         public void visitLambda(JCLambda tree) {
1332             if (needsTarget) {
1333                 badInferenceMsg = Fragments.LocalLambdaMissingTarget;
1334             }
1335         }
1336 
1337         @Override
1338         public void visitTypeCast(JCTypeCast tree) {
1339             boolean prevNeedsTarget = needsTarget;
1340             try {
1341                 needsTarget = false;
1342                 super.visitTypeCast(tree);
1343             } finally {
1344                 needsTarget = prevNeedsTarget;
1345             }
1346         }
1347 
1348         @Override
1349         public void visitReference(JCMemberReference tree) {
1350             if (needsTarget) {
1351                 badInferenceMsg = Fragments.LocalMrefMissingTarget;
1352             }
1353         }
1354 
1355         @Override
1356         public void visitNewClass(JCNewClass tree) {
1357             boolean prevNeedsTarget = needsTarget;
1358             try {
1359                 needsTarget = false;
1360                 super.visitNewClass(tree);
1361             } finally {
1362                 needsTarget = prevNeedsTarget;
1363             }
1364         }
1365 
1366         @Override
1367         public void visitApply(JCMethodInvocation tree) {
1368             boolean prevNeedsTarget = needsTarget;
1369             try {
1370                 needsTarget = false;
1371                 super.visitApply(tree);
1372             } finally {
1373                 needsTarget = prevNeedsTarget;
1374             }
1375         }
1376     }
1377 
1378     public void visitSkip(JCSkip tree) {
1379         result = null;
1380     }
1381 
1382     public void visitBlock(JCBlock tree) {
1383         if (env.info.scope.owner.kind == TYP || env.info.scope.owner.kind == ERR) {
1384             // Block is a static or instance initializer;
1385             // let the owner of the environment be a freshly
1386             // created BLOCK-method.
1387             Symbol fakeOwner =
1388                 new MethodSymbol(tree.flags | BLOCK |
1389                     env.info.scope.owner.flags() &amp; STRICTFP, names.empty, null,
1390                     env.info.scope.owner);
1391             final Env&lt;AttrContext&gt; localEnv =
1392                 env.dup(tree, env.info.dup(env.info.scope.dupUnshared(fakeOwner)));
1393 
1394             if ((tree.flags &amp; STATIC) != 0) localEnv.info.staticLevel++;
1395             // Attribute all type annotations in the block
1396             annotate.queueScanTreeAndTypeAnnotate(tree, localEnv, localEnv.info.scope.owner, null);
1397             annotate.flush();
1398             attribStats(tree.stats, localEnv);
1399 
1400             {
1401                 // Store init and clinit type annotations with the ClassSymbol
1402                 // to allow output in Gen.normalizeDefs.
1403                 ClassSymbol cs = (ClassSymbol)env.info.scope.owner;
1404                 List&lt;Attribute.TypeCompound&gt; tas = localEnv.info.scope.owner.getRawTypeAttributes();
1405                 if ((tree.flags &amp; STATIC) != 0) {
1406                     cs.appendClassInitTypeAttributes(tas);
1407                 } else {
1408                     cs.appendInitTypeAttributes(tas);
1409                 }
1410             }
1411         } else {
1412             // Create a new local environment with a local scope.
1413             Env&lt;AttrContext&gt; localEnv =
1414                 env.dup(tree, env.info.dup(env.info.scope.dup()));
1415             try {
1416                 attribStats(tree.stats, localEnv);
1417             } finally {
1418                 localEnv.info.scope.leave();
1419             }
1420         }
1421         result = null;
1422     }
1423 
1424     public void visitDoLoop(JCDoWhileLoop tree) {
1425         attribStat(tree.body, env.dup(tree));
1426         attribExpr(tree.cond, env, syms.booleanType);
1427         if (!breaksOutOf(tree, tree.body)) {
1428             //include condition&#39;s body when false after the while, if cannot get out of the loop
1429             MatchBindings condBindings = matchBindings;
1430             condBindings.bindingsWhenFalse.forEach(env.info.scope::enter);
1431             condBindings.bindingsWhenFalse.forEach(BindingSymbol::preserveBinding);
1432         }
1433         result = null;
1434     }
1435 
1436     public void visitWhileLoop(JCWhileLoop tree) {
1437         attribExpr(tree.cond, env, syms.booleanType);
1438         MatchBindings condBindings = matchBindings;
1439         // include condition&#39;s bindings when true in the body:
1440         Env&lt;AttrContext&gt; whileEnv = bindingEnv(env, condBindings.bindingsWhenTrue);
1441         try {
1442             attribStat(tree.body, whileEnv.dup(tree));
1443         } finally {
1444             whileEnv.info.scope.leave();
1445         }
1446         if (!breaksOutOf(tree, tree.body)) {
1447             //include condition&#39;s bindings when false after the while, if cannot get out of the loop
1448             condBindings.bindingsWhenFalse.forEach(env.info.scope::enter);
1449             condBindings.bindingsWhenFalse.forEach(BindingSymbol::preserveBinding);
1450         }
1451         result = null;
1452     }
1453 
1454     private boolean breaksOutOf(JCTree loop, JCTree body) {
1455         preFlow(body);
1456         return flow.breaksOutOf(env, loop, body, make);
1457     }
1458 
1459     public void visitForLoop(JCForLoop tree) {
1460         Env&lt;AttrContext&gt; loopEnv =
1461             env.dup(env.tree, env.info.dup(env.info.scope.dup()));
1462         MatchBindings condBindings = MatchBindingsComputer.EMPTY;
1463         try {
1464             attribStats(tree.init, loopEnv);
1465             if (tree.cond != null) {
1466                 attribExpr(tree.cond, loopEnv, syms.booleanType);
1467                 // include condition&#39;s bindings when true in the body and step:
1468                 condBindings = matchBindings;
1469             }
1470             Env&lt;AttrContext&gt; bodyEnv = bindingEnv(loopEnv, condBindings.bindingsWhenTrue);
1471             try {
1472                 bodyEnv.tree = tree; // before, we were not in loop!
1473                 attribStats(tree.step, bodyEnv);
1474                 attribStat(tree.body, bodyEnv);
1475             } finally {
1476                 bodyEnv.info.scope.leave();
1477             }
1478             result = null;
1479         }
1480         finally {
1481             loopEnv.info.scope.leave();
1482         }
1483         if (!breaksOutOf(tree, tree.body)) {
1484             //include condition&#39;s body when false after the while, if cannot get out of the loop
1485             condBindings.bindingsWhenFalse.forEach(env.info.scope::enter);
1486             condBindings.bindingsWhenFalse.forEach(BindingSymbol::preserveBinding);
1487         }
1488     }
1489 
1490     public void visitForeachLoop(JCEnhancedForLoop tree) {
1491         Env&lt;AttrContext&gt; loopEnv =
1492             env.dup(env.tree, env.info.dup(env.info.scope.dup()));
1493         try {
1494             //the Formal Parameter of a for-each loop is not in the scope when
1495             //attributing the for-each expression; we mimic this by attributing
1496             //the for-each expression first (against original scope).
1497             Type exprType = types.cvarUpperBound(attribExpr(tree.expr, loopEnv));
1498             chk.checkNonVoid(tree.pos(), exprType);
1499             Type elemtype = types.elemtype(exprType); // perhaps expr is an array?
1500             if (elemtype == null) {
1501                 // or perhaps expr implements Iterable&lt;T&gt;?
1502                 Type base = types.asSuper(exprType, syms.iterableType.tsym);
1503                 if (base == null) {
1504                     log.error(tree.expr.pos(),
1505                               Errors.ForeachNotApplicableToType(exprType,
1506                                                                 Fragments.TypeReqArrayOrIterable));
1507                     elemtype = types.createErrorType(exprType);
1508                 } else {
1509                     List&lt;Type&gt; iterableParams = base.allparams();
1510                     elemtype = iterableParams.isEmpty()
1511                         ? syms.objectType
1512                         : types.wildUpperBound(iterableParams.head);
1513                 }
1514             }
1515             if (tree.var.isImplicitlyTyped()) {
1516                 Type inferredType = chk.checkLocalVarType(tree.var, elemtype, tree.var.name);
1517                 setSyntheticVariableType(tree.var, inferredType);
1518             }
1519             attribStat(tree.var, loopEnv);
1520             chk.checkType(tree.expr.pos(), elemtype, tree.var.sym.type);
1521             loopEnv.tree = tree; // before, we were not in loop!
1522             attribStat(tree.body, loopEnv);
1523             result = null;
1524         }
1525         finally {
1526             loopEnv.info.scope.leave();
1527         }
1528     }
1529 
1530     public void visitLabelled(JCLabeledStatement tree) {
1531         // Check that label is not used in an enclosing statement
1532         Env&lt;AttrContext&gt; env1 = env;
1533         while (env1 != null &amp;&amp; !env1.tree.hasTag(CLASSDEF)) {
1534             if (env1.tree.hasTag(LABELLED) &amp;&amp;
1535                 ((JCLabeledStatement) env1.tree).label == tree.label) {
1536                 log.error(tree.pos(),
1537                           Errors.LabelAlreadyInUse(tree.label));
1538                 break;
1539             }
1540             env1 = env1.next;
1541         }
1542 
1543         attribStat(tree.body, env.dup(tree));
1544         result = null;
1545     }
1546 
1547     public void visitSwitch(JCSwitch tree) {
1548         handleSwitch(tree, tree.selector, tree.cases, (c, caseEnv) -&gt; {
1549             attribStats(c.stats, caseEnv);
1550         });
1551         result = null;
1552     }
1553 
1554     public void visitSwitchExpression(JCSwitchExpression tree) {
1555         tree.polyKind = (pt().hasTag(NONE) &amp;&amp; pt() != Type.recoveryType &amp;&amp; pt() != Infer.anyPoly) ?
1556                 PolyKind.STANDALONE : PolyKind.POLY;
1557 
1558         if (tree.polyKind == PolyKind.POLY &amp;&amp; resultInfo.pt.hasTag(VOID)) {
1559             //this means we are returning a poly conditional from void-compatible lambda expression
1560             resultInfo.checkContext.report(tree, diags.fragment(Fragments.SwitchExpressionTargetCantBeVoid));
1561             result = tree.type = types.createErrorType(resultInfo.pt);
1562             return;
1563         }
1564 
1565         ResultInfo condInfo = tree.polyKind == PolyKind.STANDALONE ?
1566                 unknownExprInfo :
1567                 resultInfo.dup(switchExpressionContext(resultInfo.checkContext));
1568 
1569         ListBuffer&lt;DiagnosticPosition&gt; caseTypePositions = new ListBuffer&lt;&gt;();
1570         ListBuffer&lt;Type&gt; caseTypes = new ListBuffer&lt;&gt;();
1571 
1572         handleSwitch(tree, tree.selector, tree.cases, (c, caseEnv) -&gt; {
1573             caseEnv.info.yieldResult = condInfo;
1574             attribStats(c.stats, caseEnv);
1575             new TreeScanner() {
1576                 @Override
1577                 public void visitYield(JCYield brk) {
1578                     if (brk.target == tree) {
1579                         caseTypePositions.append(brk.value != null ? brk.value.pos() : brk.pos());
1580                         caseTypes.append(brk.value != null ? brk.value.type : syms.errType);
1581                     }
1582                     super.visitYield(brk);
1583                 }
1584 
1585                 @Override public void visitClassDef(JCClassDecl tree) {}
1586                 @Override public void visitLambda(JCLambda tree) {}
1587             }.scan(c.stats);
1588         });
1589 
1590         if (tree.cases.isEmpty()) {
1591             log.error(tree.pos(),
1592                       Errors.SwitchExpressionEmpty);
1593         } else if (caseTypes.isEmpty()) {
1594             log.error(tree.pos(),
1595                       Errors.SwitchExpressionNoResultExpressions);
1596         }
1597 
1598         Type owntype = (tree.polyKind == PolyKind.STANDALONE) ? condType(caseTypePositions.toList(), caseTypes.toList()) : pt();
1599 
1600         result = tree.type = check(tree, owntype, KindSelector.VAL, resultInfo);
1601     }
1602     //where:
1603         CheckContext switchExpressionContext(CheckContext checkContext) {
1604             return new Check.NestedCheckContext(checkContext) {
1605                 //this will use enclosing check context to check compatibility of
1606                 //subexpression against target type; if we are in a method check context,
1607                 //depending on whether boxing is allowed, we could have incompatibilities
1608                 @Override
1609                 public void report(DiagnosticPosition pos, JCDiagnostic details) {
1610                     enclosingContext.report(pos, diags.fragment(Fragments.IncompatibleTypeInSwitchExpression(details)));
1611                 }
1612             };
1613         }
1614 
1615     private void handleSwitch(JCTree switchTree,
1616                               JCExpression selector,
1617                               List&lt;JCCase&gt; cases,
1618                               BiConsumer&lt;JCCase, Env&lt;AttrContext&gt;&gt; attribCase) {
1619         Type seltype = attribExpr(selector, env);
1620 
1621         Env&lt;AttrContext&gt; switchEnv =
1622             env.dup(switchTree, env.info.dup(env.info.scope.dup()));
1623 
1624         try {
1625             boolean enumSwitch = (seltype.tsym.flags() &amp; Flags.ENUM) != 0;
1626             boolean stringSwitch = types.isSameType(seltype, syms.stringType);
1627             if (!enumSwitch &amp;&amp; !stringSwitch)
1628                 seltype = chk.checkType(selector.pos(), seltype, syms.intType);
1629 
1630             // Attribute all cases and
1631             // check that there are no duplicate case labels or default clauses.
1632             Set&lt;Object&gt; labels = new HashSet&lt;&gt;(); // The set of case labels.
1633             boolean hasDefault = false;      // Is there a default label?
1634             CaseTree.CaseKind caseKind = null;
1635             boolean wasError = false;
1636             for (List&lt;JCCase&gt; l = cases; l.nonEmpty(); l = l.tail) {
1637                 JCCase c = l.head;
1638                 if (caseKind == null) {
1639                     caseKind = c.caseKind;
1640                 } else if (caseKind != c.caseKind &amp;&amp; !wasError) {
1641                     log.error(c.pos(),
1642                               Errors.SwitchMixingCaseTypes);
1643                     wasError = true;
1644                 }
1645                 if (c.getExpressions().nonEmpty()) {
1646                     for (JCExpression pat : c.getExpressions()) {
1647                         if (TreeInfo.isNull(pat)) {
1648                             log.error(pat.pos(),
1649                                       Errors.SwitchNullNotAllowed);
1650                         } else if (enumSwitch) {
1651                             Symbol sym = enumConstant(pat, seltype);
1652                             if (sym == null) {
1653                                 log.error(pat.pos(), Errors.EnumLabelMustBeUnqualifiedEnum);
1654                             } else if (!labels.add(sym)) {
1655                                 log.error(c.pos(), Errors.DuplicateCaseLabel);
1656                             }
1657                         } else {
1658                             Type pattype = attribExpr(pat, switchEnv, seltype);
1659                             if (!pattype.hasTag(ERROR)) {
1660                                 if (pattype.constValue() == null) {
1661                                     log.error(pat.pos(),
1662                                               (stringSwitch ? Errors.StringConstReq : Errors.ConstExprReq));
1663                                 } else if (!labels.add(pattype.constValue())) {
1664                                     log.error(c.pos(), Errors.DuplicateCaseLabel);
1665                                 }
1666                             }
1667                         }
1668                     }
1669                 } else if (hasDefault) {
1670                     log.error(c.pos(), Errors.DuplicateDefaultLabel);
1671                 } else {
1672                     hasDefault = true;
1673                 }
1674                 Env&lt;AttrContext&gt; caseEnv =
1675                     switchEnv.dup(c, env.info.dup(switchEnv.info.scope.dup()));
1676                 try {
1677                     attribCase.accept(c, caseEnv);
1678                 } finally {
1679                     caseEnv.info.scope.leave();
1680                 }
1681                 addVars(c.stats, switchEnv.info.scope);
1682             }
1683         } finally {
1684             switchEnv.info.scope.leave();
1685         }
1686     }
1687     // where
1688         /** Add any variables defined in stats to the switch scope. */
1689         private static void addVars(List&lt;JCStatement&gt; stats, WriteableScope switchScope) {
1690             for (;stats.nonEmpty(); stats = stats.tail) {
1691                 JCTree stat = stats.head;
1692                 if (stat.hasTag(VARDEF))
1693                     switchScope.enter(((JCVariableDecl) stat).sym);
1694             }
1695         }
1696     // where
1697     /** Return the selected enumeration constant symbol, or null. */
1698     private Symbol enumConstant(JCTree tree, Type enumType) {
1699         if (tree.hasTag(IDENT)) {
1700             JCIdent ident = (JCIdent)tree;
1701             Name name = ident.name;
1702             for (Symbol sym : enumType.tsym.members().getSymbolsByName(name)) {
1703                 if (sym.kind == VAR) {
1704                     Symbol s = ident.sym = sym;
1705                     ((VarSymbol)s).getConstValue(); // ensure initializer is evaluated
1706                     ident.type = s.type;
1707                     return ((s.flags_field &amp; Flags.ENUM) == 0)
1708                         ? null : s;
1709                 }
1710             }
1711         }
1712         return null;
1713     }
1714 
1715     public void visitSynchronized(JCSynchronized tree) {
1716         chk.checkRefType(tree.pos(), attribExpr(tree.lock, env));
1717         attribStat(tree.body, env);
1718         result = null;
1719     }
1720 
1721     public void visitTry(JCTry tree) {
1722         // Create a new local environment with a local
1723         Env&lt;AttrContext&gt; localEnv = env.dup(tree, env.info.dup(env.info.scope.dup()));
1724         try {
1725             boolean isTryWithResource = tree.resources.nonEmpty();
1726             // Create a nested environment for attributing the try block if needed
1727             Env&lt;AttrContext&gt; tryEnv = isTryWithResource ?
1728                 env.dup(tree, localEnv.info.dup(localEnv.info.scope.dup())) :
1729                 localEnv;
1730             try {
1731                 // Attribute resource declarations
1732                 for (JCTree resource : tree.resources) {
1733                     CheckContext twrContext = new Check.NestedCheckContext(resultInfo.checkContext) {
1734                         @Override
1735                         public void report(DiagnosticPosition pos, JCDiagnostic details) {
1736                             chk.basicHandler.report(pos, diags.fragment(Fragments.TryNotApplicableToType(details)));
1737                         }
1738                     };
1739                     ResultInfo twrResult =
1740                         new ResultInfo(KindSelector.VAR,
1741                                        syms.autoCloseableType,
1742                                        twrContext);
1743                     if (resource.hasTag(VARDEF)) {
1744                         attribStat(resource, tryEnv);
1745                         twrResult.check(resource, resource.type);
1746 
1747                         //check that resource type cannot throw InterruptedException
1748                         checkAutoCloseable(resource.pos(), localEnv, resource.type);
1749 
1750                         VarSymbol var = ((JCVariableDecl) resource).sym;
1751                         var.setData(ElementKind.RESOURCE_VARIABLE);
1752                     } else {
1753                         attribTree(resource, tryEnv, twrResult);
1754                     }
1755                 }
1756                 // Attribute body
1757                 attribStat(tree.body, tryEnv);
1758             } finally {
1759                 if (isTryWithResource)
1760                     tryEnv.info.scope.leave();
1761             }
1762 
1763             // Attribute catch clauses
1764             for (List&lt;JCCatch&gt; l = tree.catchers; l.nonEmpty(); l = l.tail) {
1765                 JCCatch c = l.head;
1766                 Env&lt;AttrContext&gt; catchEnv =
1767                     localEnv.dup(c, localEnv.info.dup(localEnv.info.scope.dup()));
1768                 try {
1769                     Type ctype = attribStat(c.param, catchEnv);
1770                     if (TreeInfo.isMultiCatch(c)) {
1771                         //multi-catch parameter is implicitly marked as final
1772                         c.param.sym.flags_field |= FINAL | UNION;
1773                     }
1774                     if (c.param.sym.kind == VAR) {
1775                         c.param.sym.setData(ElementKind.EXCEPTION_PARAMETER);
1776                     }
1777                     chk.checkType(c.param.vartype.pos(),
1778                                   chk.checkClassType(c.param.vartype.pos(), ctype),
1779                                   syms.throwableType);
1780                     attribStat(c.body, catchEnv);
1781                 } finally {
1782                     catchEnv.info.scope.leave();
1783                 }
1784             }
1785 
1786             // Attribute finalizer
1787             if (tree.finalizer != null) attribStat(tree.finalizer, localEnv);
1788             result = null;
1789         }
1790         finally {
1791             localEnv.info.scope.leave();
1792         }
1793     }
1794 
1795     void checkAutoCloseable(DiagnosticPosition pos, Env&lt;AttrContext&gt; env, Type resource) {
1796         if (!resource.isErroneous() &amp;&amp;
1797             types.asSuper(resource, syms.autoCloseableType.tsym) != null &amp;&amp;
1798             !types.isSameType(resource, syms.autoCloseableType)) { // Don&#39;t emit warning for AutoCloseable itself
1799             Symbol close = syms.noSymbol;
1800             Log.DiagnosticHandler discardHandler = new Log.DiscardDiagnosticHandler(log);
1801             try {
1802                 close = rs.resolveQualifiedMethod(pos,
1803                         env,
1804                         types.skipTypeVars(resource, false),
1805                         names.close,
1806                         List.nil(),
1807                         List.nil());
1808             }
1809             finally {
1810                 log.popDiagnosticHandler(discardHandler);
1811             }
1812             if (close.kind == MTH &amp;&amp;
1813                     close.overrides(syms.autoCloseableClose, resource.tsym, types, true) &amp;&amp;
1814                     chk.isHandled(syms.interruptedExceptionType, types.memberType(resource, close).getThrownTypes()) &amp;&amp;
1815                     env.info.lint.isEnabled(LintCategory.TRY)) {
1816                 log.warning(LintCategory.TRY, pos, Warnings.TryResourceThrowsInterruptedExc(resource));
1817             }
1818         }
1819     }
1820 
1821     public void visitConditional(JCConditional tree) {
1822         Type condtype = attribExpr(tree.cond, env, syms.booleanType);
1823         MatchBindings condBindings = matchBindings;
1824 
1825         tree.polyKind = (!allowPoly ||
1826                 pt().hasTag(NONE) &amp;&amp; pt() != Type.recoveryType &amp;&amp; pt() != Infer.anyPoly ||
1827                 isBooleanOrNumeric(env, tree)) ?
1828                 PolyKind.STANDALONE : PolyKind.POLY;
1829 
1830         if (tree.polyKind == PolyKind.POLY &amp;&amp; resultInfo.pt.hasTag(VOID)) {
1831             //this means we are returning a poly conditional from void-compatible lambda expression
1832             resultInfo.checkContext.report(tree, diags.fragment(Fragments.ConditionalTargetCantBeVoid));
1833             result = tree.type = types.createErrorType(resultInfo.pt);
1834             return;
1835         }
1836 
1837         ResultInfo condInfo = tree.polyKind == PolyKind.STANDALONE ?
1838                 unknownExprInfo :
1839                 resultInfo.dup(conditionalContext(resultInfo.checkContext));
1840 
1841 
1842         // x ? y : z
1843         // include x&#39;s bindings when true in y
1844         // include x&#39;s bindings when false in z
1845 
1846         Type truetype;
1847         Env&lt;AttrContext&gt; trueEnv = bindingEnv(env, condBindings.bindingsWhenTrue);
1848         try {
1849             truetype = attribTree(tree.truepart, trueEnv, condInfo);
1850         } finally {
1851             trueEnv.info.scope.leave();
1852         }
1853 
1854         MatchBindings trueBindings = matchBindings;
1855 
1856         Type falsetype;
1857         Env&lt;AttrContext&gt; falseEnv = bindingEnv(env, condBindings.bindingsWhenFalse);
1858         try {
1859             falsetype = attribTree(tree.falsepart, falseEnv, condInfo);
1860         } finally {
1861             falseEnv.info.scope.leave();
1862         }
1863 
1864         MatchBindings falseBindings = matchBindings;
1865 
1866         Type owntype = (tree.polyKind == PolyKind.STANDALONE) ?
1867                 condType(List.of(tree.truepart.pos(), tree.falsepart.pos()),
1868                          List.of(truetype, falsetype)) : pt();
1869         if (condtype.constValue() != null &amp;&amp;
1870                 truetype.constValue() != null &amp;&amp;
1871                 falsetype.constValue() != null &amp;&amp;
1872                 !owntype.hasTag(NONE)) {
1873             //constant folding
1874             owntype = cfolder.coerce(condtype.isTrue() ? truetype : falsetype, owntype);
1875         }
1876         result = check(tree, owntype, KindSelector.VAL, resultInfo);
1877         matchBindings = matchBindingsComputer.conditional(tree, condBindings, trueBindings, falseBindings);
1878     }
1879     //where
1880         private boolean isBooleanOrNumeric(Env&lt;AttrContext&gt; env, JCExpression tree) {
1881             switch (tree.getTag()) {
1882                 case LITERAL: return ((JCLiteral)tree).typetag.isSubRangeOf(DOUBLE) ||
1883                               ((JCLiteral)tree).typetag == BOOLEAN ||
1884                               ((JCLiteral)tree).typetag == BOT;
1885                 case LAMBDA: case REFERENCE: return false;
1886                 case PARENS: return isBooleanOrNumeric(env, ((JCParens)tree).expr);
1887                 case CONDEXPR:
1888                     JCConditional condTree = (JCConditional)tree;
1889                     return isBooleanOrNumeric(env, condTree.truepart) &amp;&amp;
1890                             isBooleanOrNumeric(env, condTree.falsepart);
1891                 case APPLY:
1892                     JCMethodInvocation speculativeMethodTree =
1893                             (JCMethodInvocation)deferredAttr.attribSpeculative(
1894                                     tree, env, unknownExprInfo,
1895                                     argumentAttr.withLocalCacheContext());
1896                     Symbol msym = TreeInfo.symbol(speculativeMethodTree.meth);
1897                     Type receiverType = speculativeMethodTree.meth.hasTag(IDENT) ?
1898                             env.enclClass.type :
1899                             ((JCFieldAccess)speculativeMethodTree.meth).selected.type;
1900                     Type owntype = types.memberType(receiverType, msym).getReturnType();
1901                     return primitiveOrBoxed(owntype);
1902                 case NEWCLASS:
1903                     JCExpression className =
1904                             removeClassParams.translate(((JCNewClass)tree).clazz);
1905                     JCExpression speculativeNewClassTree =
1906                             (JCExpression)deferredAttr.attribSpeculative(
1907                                     className, env, unknownTypeInfo,
1908                                     argumentAttr.withLocalCacheContext());
1909                     return primitiveOrBoxed(speculativeNewClassTree.type);
1910                 default:
1911                     Type speculativeType = deferredAttr.attribSpeculative(tree, env, unknownExprInfo,
1912                             argumentAttr.withLocalCacheContext()).type;
1913                     return primitiveOrBoxed(speculativeType);
1914             }
1915         }
1916         //where
1917             boolean primitiveOrBoxed(Type t) {
1918                 return (!t.hasTag(TYPEVAR) &amp;&amp; types.unboxedTypeOrType(t).isPrimitive());
1919             }
1920 
1921             TreeTranslator removeClassParams = new TreeTranslator() {
1922                 @Override
1923                 public void visitTypeApply(JCTypeApply tree) {
1924                     result = translate(tree.clazz);
1925                 }
1926             };
1927 
1928         CheckContext conditionalContext(CheckContext checkContext) {
1929             return new Check.NestedCheckContext(checkContext) {
1930                 //this will use enclosing check context to check compatibility of
1931                 //subexpression against target type; if we are in a method check context,
1932                 //depending on whether boxing is allowed, we could have incompatibilities
1933                 @Override
1934                 public void report(DiagnosticPosition pos, JCDiagnostic details) {
1935                     enclosingContext.report(pos, diags.fragment(Fragments.IncompatibleTypeInConditional(details)));
1936                 }
1937             };
1938         }
1939 
1940         /** Compute the type of a conditional expression, after
1941          *  checking that it exists.  See JLS 15.25. Does not take into
1942          *  account the special case where condition and both arms
1943          *  are constants.
1944          *
1945          *  @param pos      The source position to be used for error
1946          *                  diagnostics.
1947          *  @param thentype The type of the expression&#39;s then-part.
1948          *  @param elsetype The type of the expression&#39;s else-part.
1949          */
1950         Type condType(List&lt;DiagnosticPosition&gt; positions, List&lt;Type&gt; condTypes) {
1951             if (condTypes.isEmpty()) {
1952                 return syms.objectType; //TODO: how to handle?
1953             }
1954             Type first = condTypes.head;
1955             // If same type, that is the result
1956             if (condTypes.tail.stream().allMatch(t -&gt; types.isSameType(first, t)))
1957                 return first.baseType();
1958 
1959             List&lt;Type&gt; unboxedTypes = condTypes.stream()
1960                                                .map(t -&gt; t.isPrimitive() ? t : types.unboxedType(t))
1961                                                .collect(List.collector());
1962 
1963             // Otherwise, if both arms can be converted to a numeric
1964             // type, return the least numeric type that fits both arms
1965             // (i.e. return larger of the two, or return int if one
1966             // arm is short, the other is char).
1967             if (unboxedTypes.stream().allMatch(t -&gt; t.isPrimitive())) {
1968                 // If one arm has an integer subrange type (i.e., byte,
1969                 // short, or char), and the other is an integer constant
1970                 // that fits into the subrange, return the subrange type.
1971                 for (Type type : unboxedTypes) {
1972                     if (!type.getTag().isStrictSubRangeOf(INT)) {
1973                         continue;
1974                     }
1975                     if (unboxedTypes.stream().filter(t -&gt; t != type).allMatch(t -&gt; t.hasTag(INT) &amp;&amp; types.isAssignable(t, type)))
1976                         return type.baseType();
1977                 }
1978 
1979                 for (TypeTag tag : primitiveTags) {
1980                     Type candidate = syms.typeOfTag[tag.ordinal()];
1981                     if (unboxedTypes.stream().allMatch(t -&gt; types.isSubtype(t, candidate))) {
1982                         return candidate;
1983                     }
1984                 }
1985             }
1986 
1987             // Those were all the cases that could result in a primitive
1988             condTypes = condTypes.stream()
1989                                  .map(t -&gt; t.isPrimitive() ? types.boxedClass(t).type : t)
1990                                  .collect(List.collector());
1991 
1992             for (Type type : condTypes) {
1993                 if (condTypes.stream().filter(t -&gt; t != type).allMatch(t -&gt; types.isAssignable(t, type)))
1994                     return type.baseType();
1995             }
1996 
1997             Iterator&lt;DiagnosticPosition&gt; posIt = positions.iterator();
1998 
1999             condTypes = condTypes.stream()
2000                                  .map(t -&gt; chk.checkNonVoid(posIt.next(), t))
2001                                  .collect(List.collector());
2002 
2003             // both are known to be reference types.  The result is
2004             // lub(thentype,elsetype). This cannot fail, as it will
2005             // always be possible to infer &quot;Object&quot; if nothing better.
2006             return types.lub(condTypes.stream().map(t -&gt; t.baseType()).collect(List.collector()));
2007         }
2008 
2009     final static TypeTag[] primitiveTags = new TypeTag[]{
2010         BYTE,
2011         CHAR,
2012         SHORT,
2013         INT,
2014         LONG,
2015         FLOAT,
2016         DOUBLE,
2017         BOOLEAN,
2018     };
2019 
2020     Env&lt;AttrContext&gt; bindingEnv(Env&lt;AttrContext&gt; env, List&lt;BindingSymbol&gt; bindings) {
2021         Env&lt;AttrContext&gt; env1 = env.dup(env.tree, env.info.dup(env.info.scope.dup()));
2022         bindings.forEach(env1.info.scope::enter);
2023         return env1;
2024     }
2025 
2026     public void visitIf(JCIf tree) {
2027         attribExpr(tree.cond, env, syms.booleanType);
2028 
2029         // if (x) { y } [ else z ]
2030         // include x&#39;s bindings when true in y
2031         // include x&#39;s bindings when false in z
2032 
2033         MatchBindings condBindings = matchBindings;
2034         Env&lt;AttrContext&gt; thenEnv = bindingEnv(env, condBindings.bindingsWhenTrue);
2035 
2036         try {
2037             attribStat(tree.thenpart, thenEnv);
2038         } finally {
2039             thenEnv.info.scope.leave();
2040         }
2041 
2042         preFlow(tree.thenpart);
2043         boolean aliveAfterThen = flow.aliveAfter(env, tree.thenpart, make);
2044         boolean aliveAfterElse;
2045 
2046         if (tree.elsepart != null) {
2047             Env&lt;AttrContext&gt; elseEnv = bindingEnv(env, condBindings.bindingsWhenFalse);
2048             try {
2049                 attribStat(tree.elsepart, elseEnv);
2050             } finally {
2051                 elseEnv.info.scope.leave();
2052             }
2053             preFlow(tree.elsepart);
2054             aliveAfterElse = flow.aliveAfter(env, tree.elsepart, make);
2055         } else {
2056             aliveAfterElse = true;
2057         }
2058 
2059         chk.checkEmptyIf(tree);
2060 
2061         List&lt;BindingSymbol&gt; afterIfBindings = List.nil();
2062 
2063         if (aliveAfterThen &amp;&amp; !aliveAfterElse) {
2064             afterIfBindings = condBindings.bindingsWhenTrue;
2065         } else if (aliveAfterElse &amp;&amp; !aliveAfterThen) {
2066             afterIfBindings = condBindings.bindingsWhenFalse;
2067         }
2068 
2069         afterIfBindings.forEach(env.info.scope::enter);
2070         afterIfBindings.forEach(BindingSymbol::preserveBinding);
2071 
2072         result = null;
2073     }
2074 
2075         void preFlow(JCTree tree) {
2076             new PostAttrAnalyzer() {
2077                 @Override
2078                 public void scan(JCTree tree) {
2079                     if (tree == null ||
2080                             (tree.type != null &amp;&amp;
2081                             tree.type == Type.stuckType)) {
2082                         //don&#39;t touch stuck expressions!
2083                         return;
2084                     }
2085                     super.scan(tree);
2086                 }
2087             }.scan(tree);
2088         }
2089 
2090     public void visitExec(JCExpressionStatement tree) {
2091         //a fresh environment is required for 292 inference to work properly ---
2092         //see Infer.instantiatePolymorphicSignatureInstance()
2093         Env&lt;AttrContext&gt; localEnv = env.dup(tree);
2094         attribExpr(tree.expr, localEnv);
2095         result = null;
2096     }
2097 
2098     public void visitBreak(JCBreak tree) {
2099         tree.target = findJumpTarget(tree.pos(), tree.getTag(), tree.label, env);
2100         result = null;
2101     }
2102 
2103     public void visitYield(JCYield tree) {
2104         if (env.info.yieldResult != null) {
2105             attribTree(tree.value, env, env.info.yieldResult);
2106             tree.target = findJumpTarget(tree.pos(), tree.getTag(), names.empty, env);
2107         } else {
2108             log.error(tree.pos(), tree.value.hasTag(PARENS)
2109                     ? Errors.NoSwitchExpressionQualify
2110                     : Errors.NoSwitchExpression);
2111             attribTree(tree.value, env, unknownExprInfo);
2112         }
2113         result = null;
2114     }
2115 
2116     public void visitContinue(JCContinue tree) {
2117         tree.target = findJumpTarget(tree.pos(), tree.getTag(), tree.label, env);
2118         result = null;
2119     }
2120     //where
2121         /** Return the target of a break, continue or yield statement,
2122          *  if it exists, report an error if not.
2123          *  Note: The target of a labelled break or continue is the
2124          *  (non-labelled) statement tree referred to by the label,
2125          *  not the tree representing the labelled statement itself.
2126          *
2127          *  @param pos     The position to be used for error diagnostics
2128          *  @param tag     The tag of the jump statement. This is either
2129          *                 Tree.BREAK or Tree.CONTINUE.
2130          *  @param label   The label of the jump statement, or null if no
2131          *                 label is given.
2132          *  @param env     The environment current at the jump statement.
2133          */
2134         private JCTree findJumpTarget(DiagnosticPosition pos,
2135                                                    JCTree.Tag tag,
2136                                                    Name label,
2137                                                    Env&lt;AttrContext&gt; env) {
2138             Pair&lt;JCTree, Error&gt; jumpTarget = findJumpTargetNoError(tag, label, env);
2139 
2140             if (jumpTarget.snd != null) {
2141                 log.error(pos, jumpTarget.snd);
2142             }
2143 
2144             return jumpTarget.fst;
2145         }
2146         /** Return the target of a break or continue statement, if it exists,
2147          *  report an error if not.
2148          *  Note: The target of a labelled break or continue is the
2149          *  (non-labelled) statement tree referred to by the label,
2150          *  not the tree representing the labelled statement itself.
2151          *
2152          *  @param tag     The tag of the jump statement. This is either
2153          *                 Tree.BREAK or Tree.CONTINUE.
2154          *  @param label   The label of the jump statement, or null if no
2155          *                 label is given.
2156          *  @param env     The environment current at the jump statement.
2157          */
2158         private Pair&lt;JCTree, JCDiagnostic.Error&gt; findJumpTargetNoError(JCTree.Tag tag,
2159                                                                        Name label,
2160                                                                        Env&lt;AttrContext&gt; env) {
2161             // Search environments outwards from the point of jump.
2162             Env&lt;AttrContext&gt; env1 = env;
2163             JCDiagnostic.Error pendingError = null;
2164             LOOP:
2165             while (env1 != null) {
2166                 switch (env1.tree.getTag()) {
2167                     case LABELLED:
2168                         JCLabeledStatement labelled = (JCLabeledStatement)env1.tree;
2169                         if (label == labelled.label) {
2170                             // If jump is a continue, check that target is a loop.
2171                             if (tag == CONTINUE) {
2172                                 if (!labelled.body.hasTag(DOLOOP) &amp;&amp;
2173                                         !labelled.body.hasTag(WHILELOOP) &amp;&amp;
2174                                         !labelled.body.hasTag(FORLOOP) &amp;&amp;
2175                                         !labelled.body.hasTag(FOREACHLOOP)) {
2176                                     pendingError = Errors.NotLoopLabel(label);
2177                                 }
2178                                 // Found labelled statement target, now go inwards
2179                                 // to next non-labelled tree.
2180                                 return Pair.of(TreeInfo.referencedStatement(labelled), pendingError);
2181                             } else {
2182                                 return Pair.of(labelled, pendingError);
2183                             }
2184                         }
2185                         break;
2186                     case DOLOOP:
2187                     case WHILELOOP:
2188                     case FORLOOP:
2189                     case FOREACHLOOP:
2190                         if (label == null) return Pair.of(env1.tree, pendingError);
2191                         break;
2192                     case SWITCH:
2193                         if (label == null &amp;&amp; tag == BREAK) return Pair.of(env1.tree, null);
2194                         break;
2195                     case SWITCH_EXPRESSION:
2196                         if (tag == YIELD) {
2197                             return Pair.of(env1.tree, null);
2198                         } else if (tag == BREAK) {
2199                             pendingError = Errors.BreakOutsideSwitchExpression;
2200                         } else {
2201                             pendingError = Errors.ContinueOutsideSwitchExpression;
2202                         }
2203                         break;
2204                     case LAMBDA:
2205                     case METHODDEF:
2206                     case CLASSDEF:
2207                         break LOOP;
2208                     default:
2209                 }
2210                 env1 = env1.next;
2211             }
2212             if (label != null)
2213                 return Pair.of(null, Errors.UndefLabel(label));
2214             else if (pendingError != null)
2215                 return Pair.of(null, pendingError);
2216             else if (tag == CONTINUE)
2217                 return Pair.of(null, Errors.ContOutsideLoop);
2218             else
2219                 return Pair.of(null, Errors.BreakOutsideSwitchLoop);
2220         }
2221 
2222     public void visitReturn(JCReturn tree) {
2223         // Check that there is an enclosing method which is
2224         // nested within than the enclosing class.
2225         if (env.info.returnResult == null) {
2226             log.error(tree.pos(), Errors.RetOutsideMeth);
2227         } else if (env.info.yieldResult != null) {
2228             log.error(tree.pos(), Errors.ReturnOutsideSwitchExpression);
2229         } else if (!env.info.isLambda &amp;&amp;
2230                 !env.info.isNewClass &amp;&amp;
2231                 env.enclMethod != null &amp;&amp;
2232                 TreeInfo.isCompactConstructor(env.enclMethod)) {
2233             log.error(env.enclMethod,
2234                     Errors.InvalidCanonicalConstructorInRecord(Fragments.Compact, env.enclMethod.sym.name, Fragments.CanonicalCantHaveReturnStatement));
2235         } else {
2236             // Attribute return expression, if it exists, and check that
2237             // it conforms to result type of enclosing method.
2238             if (tree.expr != null) {
2239                 if (env.info.returnResult.pt.hasTag(VOID)) {
2240                     env.info.returnResult.checkContext.report(tree.expr.pos(),
2241                               diags.fragment(Fragments.UnexpectedRetVal));
2242                 }
2243                 attribTree(tree.expr, env, env.info.returnResult);
2244             } else if (!env.info.returnResult.pt.hasTag(VOID) &amp;&amp;
2245                     !env.info.returnResult.pt.hasTag(NONE)) {
2246                 env.info.returnResult.checkContext.report(tree.pos(),
2247                               diags.fragment(Fragments.MissingRetVal(env.info.returnResult.pt)));
2248             }
2249         }
2250         result = null;
2251     }
2252 
2253     public void visitThrow(JCThrow tree) {
2254         Type owntype = attribExpr(tree.expr, env, allowPoly ? Type.noType : syms.throwableType);
2255         if (allowPoly) {
2256             chk.checkType(tree, owntype, syms.throwableType);
2257         }
2258         result = null;
2259     }
2260 
2261     public void visitAssert(JCAssert tree) {
2262         attribExpr(tree.cond, env, syms.booleanType);
2263         if (tree.detail != null) {
2264             chk.checkNonVoid(tree.detail.pos(), attribExpr(tree.detail, env));
2265         }
2266         result = null;
2267     }
2268 
2269      /** Visitor method for method invocations.
2270      *  NOTE: The method part of an application will have in its type field
2271      *        the return type of the method, not the method&#39;s type itself!
2272      */
2273     public void visitApply(JCMethodInvocation tree) {
2274         // The local environment of a method application is
2275         // a new environment nested in the current one.
2276         Env&lt;AttrContext&gt; localEnv = env.dup(tree, env.info.dup());
2277 
2278         // The types of the actual method arguments.
2279         List&lt;Type&gt; argtypes;
2280 
2281         // The types of the actual method type arguments.
2282         List&lt;Type&gt; typeargtypes = null;
2283 
2284         Name methName = TreeInfo.name(tree.meth);
2285 
2286         boolean isConstructorCall =
2287             methName == names._this || methName == names._super;
2288 
2289         ListBuffer&lt;Type&gt; argtypesBuf = new ListBuffer&lt;&gt;();
2290         if (isConstructorCall) {
2291             // We are seeing a ...this(...) or ...super(...) call.
2292             // Check that this is the first statement in a constructor.
2293             checkFirstConstructorStat(tree, env.enclMethod, true);
2294 
2295             // Record the fact
2296             // that this is a constructor call (using isSelfCall).
2297             localEnv.info.isSelfCall = true;
2298 
2299             // Attribute arguments, yielding list of argument types.
2300             KindSelector kind = attribArgs(KindSelector.MTH, tree.args, localEnv, argtypesBuf);
2301             argtypes = argtypesBuf.toList();
2302             typeargtypes = attribTypes(tree.typeargs, localEnv);
2303 
2304             // Variable `site&#39; points to the class in which the called
2305             // constructor is defined.
2306             Type site = env.enclClass.sym.type;
2307             if (methName == names._super) {
2308                 if (site == syms.objectType) {
2309                     log.error(tree.meth.pos(), Errors.NoSuperclass(site));
2310                     site = types.createErrorType(syms.objectType);
2311                 } else {
2312                     site = types.supertype(site);
2313                 }
2314             }
2315 
2316             if (site.hasTag(CLASS)) {
2317                 Type encl = site.getEnclosingType();
2318                 while (encl != null &amp;&amp; encl.hasTag(TYPEVAR))
2319                     encl = encl.getUpperBound();
2320                 if (encl.hasTag(CLASS)) {
2321                     // we are calling a nested class
2322 
2323                     if (tree.meth.hasTag(SELECT)) {
2324                         JCTree qualifier = ((JCFieldAccess) tree.meth).selected;
2325 
2326                         // We are seeing a prefixed call, of the form
2327                         //     &lt;expr&gt;.super(...).
2328                         // Check that the prefix expression conforms
2329                         // to the outer instance type of the class.
2330                         chk.checkRefType(qualifier.pos(),
2331                                          attribExpr(qualifier, localEnv,
2332                                                     encl));
2333                     } else if (methName == names._super) {
2334                         // qualifier omitted; check for existence
2335                         // of an appropriate implicit qualifier.
2336                         rs.resolveImplicitThis(tree.meth.pos(),
2337                                                localEnv, site, true);
2338                     }
2339                 } else if (tree.meth.hasTag(SELECT)) {
2340                     log.error(tree.meth.pos(),
2341                               Errors.IllegalQualNotIcls(site.tsym));
2342                 }
2343 
2344                 // if we&#39;re calling a java.lang.Enum constructor,
2345                 // prefix the implicit String and int parameters
2346                 if (site.tsym == syms.enumSym)
2347                     argtypes = argtypes.prepend(syms.intType).prepend(syms.stringType);
2348 
2349                 // Resolve the called constructor under the assumption
2350                 // that we are referring to a superclass instance of the
2351                 // current instance (JLS ???).
2352                 boolean selectSuperPrev = localEnv.info.selectSuper;
2353                 localEnv.info.selectSuper = true;
2354                 localEnv.info.pendingResolutionPhase = null;
2355                 Symbol sym = rs.resolveConstructor(
2356                     tree.meth.pos(), localEnv, site, argtypes, typeargtypes);
2357                 localEnv.info.selectSuper = selectSuperPrev;
2358 
2359                 // Set method symbol to resolved constructor...
2360                 TreeInfo.setSymbol(tree.meth, sym);
2361 
2362                 // ...and check that it is legal in the current context.
2363                 // (this will also set the tree&#39;s type)
2364                 Type mpt = newMethodTemplate(resultInfo.pt, argtypes, typeargtypes);
2365                 checkId(tree.meth, site, sym, localEnv,
2366                         new ResultInfo(kind, mpt));
2367             }
2368             // Otherwise, `site&#39; is an error type and we do nothing
2369             result = tree.type = syms.voidType;
2370         } else {
2371             // Otherwise, we are seeing a regular method call.
2372             // Attribute the arguments, yielding list of argument types, ...
2373             KindSelector kind = attribArgs(KindSelector.VAL, tree.args, localEnv, argtypesBuf);
2374             argtypes = argtypesBuf.toList();
2375             typeargtypes = attribAnyTypes(tree.typeargs, localEnv);
2376 
2377             // ... and attribute the method using as a prototype a methodtype
2378             // whose formal argument types is exactly the list of actual
2379             // arguments (this will also set the method symbol).
2380             Type mpt = newMethodTemplate(resultInfo.pt, argtypes, typeargtypes);
2381             localEnv.info.pendingResolutionPhase = null;
2382             Type mtype = attribTree(tree.meth, localEnv, new ResultInfo(kind, mpt, resultInfo.checkContext));
2383 
2384             // Compute the result type.
2385             Type restype = mtype.getReturnType();
2386             if (restype.hasTag(WILDCARD))
2387                 throw new AssertionError(mtype);
2388 
2389             Type qualifier = (tree.meth.hasTag(SELECT))
2390                     ? ((JCFieldAccess) tree.meth).selected.type
2391                     : env.enclClass.sym.type;
2392             Symbol msym = TreeInfo.symbol(tree.meth);
2393             restype = adjustMethodReturnType(msym, qualifier, methName, argtypes, restype);
2394 
2395             chk.checkRefTypes(tree.typeargs, typeargtypes);
2396 
2397             // Check that value of resulting type is admissible in the
2398             // current context.  Also, capture the return type
2399             Type capturedRes = resultInfo.checkContext.inferenceContext().cachedCapture(tree, restype, true);
2400             result = check(tree, capturedRes, KindSelector.VAL, resultInfo);
2401         }
2402         chk.validate(tree.typeargs, localEnv);
2403     }
2404     //where
2405         Type adjustMethodReturnType(Symbol msym, Type qualifierType, Name methodName, List&lt;Type&gt; argtypes, Type restype) {
2406             if (msym != null &amp;&amp;
2407                     msym.owner == syms.objectType.tsym &amp;&amp;
2408                     methodName == names.getClass &amp;&amp;
2409                     argtypes.isEmpty()) {
2410                 // as a special case, x.getClass() has type Class&lt;? extends |X|&gt;
2411                 return new ClassType(restype.getEnclosingType(),
2412                         List.of(new WildcardType(types.erasure(qualifierType),
2413                                 BoundKind.EXTENDS,
2414                                 syms.boundClass)),
2415                         restype.tsym,
2416                         restype.getMetadata());
2417             } else if (msym != null &amp;&amp;
2418                     msym.owner == syms.arrayClass &amp;&amp;
2419                     methodName == names.clone &amp;&amp;
2420                     types.isArray(qualifierType)) {
2421                 // as a special case, array.clone() has a result that is
2422                 // the same as static type of the array being cloned
2423                 return qualifierType;
2424             } else {
2425                 return restype;
2426             }
2427         }
2428 
2429         /** Check that given application node appears as first statement
2430          *  in a constructor call.
2431          *  @param tree          The application node
2432          *  @param enclMethod    The enclosing method of the application.
2433          *  @param error         Should an error be issued?
2434          */
2435         boolean checkFirstConstructorStat(JCMethodInvocation tree, JCMethodDecl enclMethod, boolean error) {
2436             if (enclMethod != null &amp;&amp; enclMethod.name == names.init) {
2437                 JCBlock body = enclMethod.body;
2438                 if (body.stats.head.hasTag(EXEC) &amp;&amp;
2439                     ((JCExpressionStatement) body.stats.head).expr == tree)
2440                     return true;
2441             }
2442             if (error) {
2443                 log.error(tree.pos(),
2444                         Errors.CallMustBeFirstStmtInCtor(TreeInfo.name(tree.meth)));
2445             }
2446             return false;
2447         }
2448 
2449         /** Obtain a method type with given argument types.
2450          */
2451         Type newMethodTemplate(Type restype, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
2452             MethodType mt = new MethodType(argtypes, restype, List.nil(), syms.methodClass);
2453             return (typeargtypes == null) ? mt : (Type)new ForAll(typeargtypes, mt);
2454         }
2455 
2456     public void visitNewClass(final JCNewClass tree) {
2457         Type owntype = types.createErrorType(tree.type);
2458 
2459         // The local environment of a class creation is
2460         // a new environment nested in the current one.
2461         Env&lt;AttrContext&gt; localEnv = env.dup(tree, env.info.dup());
2462 
2463         // The anonymous inner class definition of the new expression,
2464         // if one is defined by it.
2465         JCClassDecl cdef = tree.def;
2466 
2467         // If enclosing class is given, attribute it, and
2468         // complete class name to be fully qualified
2469         JCExpression clazz = tree.clazz; // Class field following new
2470         JCExpression clazzid;            // Identifier in class field
2471         JCAnnotatedType annoclazzid;     // Annotated type enclosing clazzid
2472         annoclazzid = null;
2473 
2474         if (clazz.hasTag(TYPEAPPLY)) {
2475             clazzid = ((JCTypeApply) clazz).clazz;
2476             if (clazzid.hasTag(ANNOTATED_TYPE)) {
2477                 annoclazzid = (JCAnnotatedType) clazzid;
2478                 clazzid = annoclazzid.underlyingType;
2479             }
2480         } else {
2481             if (clazz.hasTag(ANNOTATED_TYPE)) {
2482                 annoclazzid = (JCAnnotatedType) clazz;
2483                 clazzid = annoclazzid.underlyingType;
2484             } else {
2485                 clazzid = clazz;
2486             }
2487         }
2488 
2489         JCExpression clazzid1 = clazzid; // The same in fully qualified form
2490 
2491         if (tree.encl != null) {
2492             // We are seeing a qualified new, of the form
2493             //    &lt;expr&gt;.new C &lt;...&gt; (...) ...
2494             // In this case, we let clazz stand for the name of the
2495             // allocated class C prefixed with the type of the qualifier
2496             // expression, so that we can
2497             // resolve it with standard techniques later. I.e., if
2498             // &lt;expr&gt; has type T, then &lt;expr&gt;.new C &lt;...&gt; (...)
2499             // yields a clazz T.C.
2500             Type encltype = chk.checkRefType(tree.encl.pos(),
2501                                              attribExpr(tree.encl, env));
2502             // TODO 308: in &lt;expr&gt;.new C, do we also want to add the type annotations
2503             // from expr to the combined type, or not? Yes, do this.
2504             clazzid1 = make.at(clazz.pos).Select(make.Type(encltype),
2505                                                  ((JCIdent) clazzid).name);
2506 
2507             EndPosTable endPosTable = this.env.toplevel.endPositions;
2508             endPosTable.storeEnd(clazzid1, tree.getEndPosition(endPosTable));
2509             if (clazz.hasTag(ANNOTATED_TYPE)) {
2510                 JCAnnotatedType annoType = (JCAnnotatedType) clazz;
2511                 List&lt;JCAnnotation&gt; annos = annoType.annotations;
2512 
2513                 if (annoType.underlyingType.hasTag(TYPEAPPLY)) {
2514                     clazzid1 = make.at(tree.pos).
2515                         TypeApply(clazzid1,
2516                                   ((JCTypeApply) clazz).arguments);
2517                 }
2518 
2519                 clazzid1 = make.at(tree.pos).
2520                     AnnotatedType(annos, clazzid1);
2521             } else if (clazz.hasTag(TYPEAPPLY)) {
2522                 clazzid1 = make.at(tree.pos).
2523                     TypeApply(clazzid1,
2524                               ((JCTypeApply) clazz).arguments);
2525             }
2526 
2527             clazz = clazzid1;
2528         }
2529 
2530         // Attribute clazz expression and store
2531         // symbol + type back into the attributed tree.
2532         Type clazztype;
2533 
2534         try {
2535             env.info.isNewClass = true;
2536             clazztype = TreeInfo.isEnumInit(env.tree) ?
2537                 attribIdentAsEnumType(env, (JCIdent)clazz) :
2538                 attribType(clazz, env);
2539         } finally {
2540             env.info.isNewClass = false;
2541         }
2542 
2543         clazztype = chk.checkDiamond(tree, clazztype);
2544         chk.validate(clazz, localEnv);
2545         if (tree.encl != null) {
2546             // We have to work in this case to store
2547             // symbol + type back into the attributed tree.
2548             tree.clazz.type = clazztype;
2549             TreeInfo.setSymbol(clazzid, TreeInfo.symbol(clazzid1));
2550             clazzid.type = ((JCIdent) clazzid).sym.type;
2551             if (annoclazzid != null) {
2552                 annoclazzid.type = clazzid.type;
2553             }
2554             if (!clazztype.isErroneous()) {
2555                 if (cdef != null &amp;&amp; clazztype.tsym.isInterface()) {
2556                     log.error(tree.encl.pos(), Errors.AnonClassImplIntfNoQualForNew);
2557                 } else if (clazztype.tsym.isStatic()) {
2558                     log.error(tree.encl.pos(), Errors.QualifiedNewOfStaticClass(clazztype.tsym));
2559                 }
2560             }
2561         } else if (!clazztype.tsym.isInterface() &amp;&amp;
2562                    clazztype.getEnclosingType().hasTag(CLASS)) {
2563             // Check for the existence of an apropos outer instance
2564             rs.resolveImplicitThis(tree.pos(), env, clazztype);
2565         }
2566 
2567         // Attribute constructor arguments.
2568         ListBuffer&lt;Type&gt; argtypesBuf = new ListBuffer&lt;&gt;();
2569         final KindSelector pkind =
2570             attribArgs(KindSelector.VAL, tree.args, localEnv, argtypesBuf);
2571         List&lt;Type&gt; argtypes = argtypesBuf.toList();
2572         List&lt;Type&gt; typeargtypes = attribTypes(tree.typeargs, localEnv);
2573 
2574         if (clazztype.hasTag(CLASS) || clazztype.hasTag(ERROR)) {
2575             // Enums may not be instantiated except implicitly
2576             if ((clazztype.tsym.flags_field &amp; Flags.ENUM) != 0 &amp;&amp;
2577                 (!env.tree.hasTag(VARDEF) ||
2578                  (((JCVariableDecl) env.tree).mods.flags &amp; Flags.ENUM) == 0 ||
2579                  ((JCVariableDecl) env.tree).init != tree))
2580                 log.error(tree.pos(), Errors.EnumCantBeInstantiated);
2581 
2582             boolean isSpeculativeDiamondInferenceRound = TreeInfo.isDiamond(tree) &amp;&amp;
2583                     resultInfo.checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.SPECULATIVE;
2584             boolean skipNonDiamondPath = false;
2585             // Check that class is not abstract
2586             if (cdef == null &amp;&amp; !isSpeculativeDiamondInferenceRound &amp;&amp; // class body may be nulled out in speculative tree copy
2587                 (clazztype.tsym.flags() &amp; (ABSTRACT | INTERFACE)) != 0) {
2588                 log.error(tree.pos(),
2589                           Errors.AbstractCantBeInstantiated(clazztype.tsym));
2590                 skipNonDiamondPath = true;
2591             } else if (cdef != null &amp;&amp; clazztype.tsym.isInterface()) {
2592                 // Check that no constructor arguments are given to
2593                 // anonymous classes implementing an interface
2594                 if (!argtypes.isEmpty())
2595                     log.error(tree.args.head.pos(), Errors.AnonClassImplIntfNoArgs);
2596 
2597                 if (!typeargtypes.isEmpty())
2598                     log.error(tree.typeargs.head.pos(), Errors.AnonClassImplIntfNoTypeargs);
2599 
2600                 // Error recovery: pretend no arguments were supplied.
2601                 argtypes = List.nil();
2602                 typeargtypes = List.nil();
2603                 skipNonDiamondPath = true;
2604             }
2605             if (TreeInfo.isDiamond(tree)) {
2606                 ClassType site = new ClassType(clazztype.getEnclosingType(),
2607                             clazztype.tsym.type.getTypeArguments(),
2608                                                clazztype.tsym,
2609                                                clazztype.getMetadata());
2610 
2611                 Env&lt;AttrContext&gt; diamondEnv = localEnv.dup(tree);
2612                 diamondEnv.info.selectSuper = cdef != null || tree.classDeclRemoved();
2613                 diamondEnv.info.pendingResolutionPhase = null;
2614 
2615                 //if the type of the instance creation expression is a class type
2616                 //apply method resolution inference (JLS 15.12.2.7). The return type
2617                 //of the resolved constructor will be a partially instantiated type
2618                 Symbol constructor = rs.resolveDiamond(tree.pos(),
2619                             diamondEnv,
2620                             site,
2621                             argtypes,
2622                             typeargtypes);
2623                 tree.constructor = constructor.baseSymbol();
2624 
2625                 final TypeSymbol csym = clazztype.tsym;
2626                 ResultInfo diamondResult = new ResultInfo(pkind, newMethodTemplate(resultInfo.pt, argtypes, typeargtypes),
2627                         diamondContext(tree, csym, resultInfo.checkContext), CheckMode.NO_TREE_UPDATE);
2628                 Type constructorType = tree.constructorType = types.createErrorType(clazztype);
2629                 constructorType = checkId(tree, site,
2630                         constructor,
2631                         diamondEnv,
2632                         diamondResult);
2633 
2634                 tree.clazz.type = types.createErrorType(clazztype);
2635                 if (!constructorType.isErroneous()) {
2636                     tree.clazz.type = clazz.type = constructorType.getReturnType();
2637                     tree.constructorType = types.createMethodTypeWithReturn(constructorType, syms.voidType);
2638                 }
2639                 clazztype = chk.checkClassType(tree.clazz, tree.clazz.type, true);
2640             }
2641 
2642             // Resolve the called constructor under the assumption
2643             // that we are referring to a superclass instance of the
2644             // current instance (JLS ???).
2645             else if (!skipNonDiamondPath) {
2646                 //the following code alters some of the fields in the current
2647                 //AttrContext - hence, the current context must be dup&#39;ed in
2648                 //order to avoid downstream failures
2649                 Env&lt;AttrContext&gt; rsEnv = localEnv.dup(tree);
2650                 rsEnv.info.selectSuper = cdef != null;
2651                 rsEnv.info.pendingResolutionPhase = null;
2652                 tree.constructor = rs.resolveConstructor(
2653                     tree.pos(), rsEnv, clazztype, argtypes, typeargtypes);
2654                 if (cdef == null) { //do not check twice!
2655                     tree.constructorType = checkId(tree,
2656                             clazztype,
2657                             tree.constructor,
2658                             rsEnv,
2659                             new ResultInfo(pkind, newMethodTemplate(syms.voidType, argtypes, typeargtypes), CheckMode.NO_TREE_UPDATE));
2660                     if (rsEnv.info.lastResolveVarargs())
2661                         Assert.check(tree.constructorType.isErroneous() || tree.varargsElement != null);
2662                 }
2663             }
2664 
2665             if (cdef != null) {
2666                 visitAnonymousClassDefinition(tree, clazz, clazztype, cdef, localEnv, argtypes, typeargtypes, pkind);
2667                 return;
2668             }
2669 
2670             if (tree.constructor != null &amp;&amp; tree.constructor.kind == MTH)
2671                 owntype = clazztype;
2672         }
2673         result = check(tree, owntype, KindSelector.VAL, resultInfo);
2674         InferenceContext inferenceContext = resultInfo.checkContext.inferenceContext();
2675         if (tree.constructorType != null &amp;&amp; inferenceContext.free(tree.constructorType)) {
2676             //we need to wait for inference to finish and then replace inference vars in the constructor type
2677             inferenceContext.addFreeTypeListener(List.of(tree.constructorType),
2678                     instantiatedContext -&gt; {
2679                         tree.constructorType = instantiatedContext.asInstType(tree.constructorType);
2680                     });
2681         }
2682         chk.validate(tree.typeargs, localEnv);
2683     }
2684 
2685         // where
2686         private void visitAnonymousClassDefinition(JCNewClass tree, JCExpression clazz, Type clazztype,
2687                                                    JCClassDecl cdef, Env&lt;AttrContext&gt; localEnv,
2688                                                    List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes,
2689                                                    KindSelector pkind) {
2690             // We are seeing an anonymous class instance creation.
2691             // In this case, the class instance creation
2692             // expression
2693             //
2694             //    E.new &lt;typeargs1&gt;C&lt;typargs2&gt;(args) { ... }
2695             //
2696             // is represented internally as
2697             //
2698             //    E . new &lt;typeargs1&gt;C&lt;typargs2&gt;(args) ( class &lt;empty-name&gt; { ... } )  .
2699             //
2700             // This expression is then *transformed* as follows:
2701             //
2702             // (1) add an extends or implements clause
2703             // (2) add a constructor.
2704             //
2705             // For instance, if C is a class, and ET is the type of E,
2706             // the expression
2707             //
2708             //    E.new &lt;typeargs1&gt;C&lt;typargs2&gt;(args) { ... }
2709             //
2710             // is translated to (where X is a fresh name and typarams is the
2711             // parameter list of the super constructor):
2712             //
2713             //   new &lt;typeargs1&gt;X(&lt;*nullchk*&gt;E, args) where
2714             //     X extends C&lt;typargs2&gt; {
2715             //       &lt;typarams&gt; X(ET e, args) {
2716             //         e.&lt;typeargs1&gt;super(args)
2717             //       }
2718             //       ...
2719             //     }
2720             InferenceContext inferenceContext = resultInfo.checkContext.inferenceContext();
2721             final boolean isDiamond = TreeInfo.isDiamond(tree);
2722             if (isDiamond
2723                     &amp;&amp; ((tree.constructorType != null &amp;&amp; inferenceContext.free(tree.constructorType))
2724                     || (tree.clazz.type != null &amp;&amp; inferenceContext.free(tree.clazz.type)))) {
2725                 final ResultInfo resultInfoForClassDefinition = this.resultInfo;
2726                 inferenceContext.addFreeTypeListener(List.of(tree.constructorType, tree.clazz.type),
2727                         instantiatedContext -&gt; {
2728                             tree.constructorType = instantiatedContext.asInstType(tree.constructorType);
2729                             tree.clazz.type = clazz.type = instantiatedContext.asInstType(clazz.type);
2730                             ResultInfo prevResult = this.resultInfo;
2731                             try {
2732                                 this.resultInfo = resultInfoForClassDefinition;
2733                                 visitAnonymousClassDefinition(tree, clazz, clazz.type, cdef,
2734                                                             localEnv, argtypes, typeargtypes, pkind);
2735                             } finally {
2736                                 this.resultInfo = prevResult;
2737                             }
2738                         });
2739             } else {
2740                 if (isDiamond &amp;&amp; clazztype.hasTag(CLASS)) {
2741                     List&lt;Type&gt; invalidDiamondArgs = chk.checkDiamondDenotable((ClassType)clazztype);
2742                     if (!clazztype.isErroneous() &amp;&amp; invalidDiamondArgs.nonEmpty()) {
2743                         // One or more types inferred in the previous steps is non-denotable.
2744                         Fragment fragment = Diamond(clazztype.tsym);
2745                         log.error(tree.clazz.pos(),
2746                                 Errors.CantApplyDiamond1(
2747                                         fragment,
2748                                         invalidDiamondArgs.size() &gt; 1 ?
2749                                                 DiamondInvalidArgs(invalidDiamondArgs, fragment) :
2750                                                 DiamondInvalidArg(invalidDiamondArgs, fragment)));
2751                     }
2752                     // For &lt;&gt;(){}, inferred types must also be accessible.
2753                     for (Type t : clazztype.getTypeArguments()) {
2754                         rs.checkAccessibleType(env, t);
2755                     }
2756                 }
2757 
2758                 // If we already errored, be careful to avoid a further avalanche. ErrorType answers
2759                 // false for isInterface call even when the original type is an interface.
2760                 boolean implementing = clazztype.tsym.isInterface() ||
2761                         clazztype.isErroneous() &amp;&amp; !clazztype.getOriginalType().hasTag(NONE) &amp;&amp;
2762                         clazztype.getOriginalType().tsym.isInterface();
2763 
2764                 if (implementing) {
2765                     cdef.implementing = List.of(clazz);
2766                 } else {
2767                     cdef.extending = clazz;
2768                 }
2769 
2770                 if (resultInfo.checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.CHECK &amp;&amp;
2771                     isSerializable(clazztype)) {
2772                     localEnv.info.isSerializable = true;
2773                 }
2774 
2775                 attribStat(cdef, localEnv);
2776 
2777                 List&lt;Type&gt; finalargtypes;
2778                 // If an outer instance is given,
2779                 // prefix it to the constructor arguments
2780                 // and delete it from the new expression
2781                 if (tree.encl != null &amp;&amp; !clazztype.tsym.isInterface()) {
2782                     finalargtypes = argtypes.prepend(tree.encl.type);
2783                 } else {
2784                     finalargtypes = argtypes;
2785                 }
2786 
2787                 // Reassign clazztype and recompute constructor. As this necessarily involves
2788                 // another attribution pass for deferred types in the case of &lt;&gt;, replicate
2789                 // them. Original arguments have right decorations already.
2790                 if (isDiamond &amp;&amp; pkind.contains(KindSelector.POLY)) {
2791                     finalargtypes = finalargtypes.map(deferredAttr.deferredCopier);
2792                 }
2793 
2794                 clazztype = clazztype.hasTag(ERROR) ? types.createErrorType(cdef.sym.type)
2795                                                     : cdef.sym.type;
2796                 Symbol sym = tree.constructor = rs.resolveConstructor(
2797                         tree.pos(), localEnv, clazztype, finalargtypes, typeargtypes);
2798                 Assert.check(!sym.kind.isResolutionError());
2799                 tree.constructor = sym;
2800                 tree.constructorType = checkId(tree,
2801                         clazztype,
2802                         tree.constructor,
2803                         localEnv,
2804                         new ResultInfo(pkind, newMethodTemplate(syms.voidType, finalargtypes, typeargtypes), CheckMode.NO_TREE_UPDATE));
2805             }
2806             Type owntype = (tree.constructor != null &amp;&amp; tree.constructor.kind == MTH) ?
2807                                 clazztype : types.createErrorType(tree.type);
2808             result = check(tree, owntype, KindSelector.VAL, resultInfo.dup(CheckMode.NO_INFERENCE_HOOK));
2809             chk.validate(tree.typeargs, localEnv);
2810         }
2811 
2812         CheckContext diamondContext(JCNewClass clazz, TypeSymbol tsym, CheckContext checkContext) {
2813             return new Check.NestedCheckContext(checkContext) {
2814                 @Override
2815                 public void report(DiagnosticPosition _unused, JCDiagnostic details) {
2816                     enclosingContext.report(clazz.clazz,
2817                             diags.fragment(Fragments.CantApplyDiamond1(Fragments.Diamond(tsym), details)));
2818                 }
2819             };
2820         }
2821 
2822     /** Make an attributed null check tree.
2823      */
2824     public JCExpression makeNullCheck(JCExpression arg) {
2825         // optimization: new Outer() can never be null; skip null check
2826         if (arg.getTag() == NEWCLASS)
2827             return arg;
2828         // optimization: X.this is never null; skip null check
2829         Name name = TreeInfo.name(arg);
2830         if (name == names._this || name == names._super) return arg;
2831 
2832         JCTree.Tag optag = NULLCHK;
2833         JCUnary tree = make.at(arg.pos).Unary(optag, arg);
2834         tree.operator = operators.resolveUnary(arg, optag, arg.type);
2835         tree.type = arg.type;
2836         return tree;
2837     }
2838 
2839     public void visitNewArray(JCNewArray tree) {
2840         Type owntype = types.createErrorType(tree.type);
2841         Env&lt;AttrContext&gt; localEnv = env.dup(tree);
2842         Type elemtype;
2843         if (tree.elemtype != null) {
2844             elemtype = attribType(tree.elemtype, localEnv);
2845             chk.validate(tree.elemtype, localEnv);
2846             owntype = elemtype;
2847             for (List&lt;JCExpression&gt; l = tree.dims; l.nonEmpty(); l = l.tail) {
2848                 attribExpr(l.head, localEnv, syms.intType);
2849                 owntype = new ArrayType(owntype, syms.arrayClass);
2850             }
2851         } else {
2852             // we are seeing an untyped aggregate { ... }
2853             // this is allowed only if the prototype is an array
2854             if (pt().hasTag(ARRAY)) {
2855                 elemtype = types.elemtype(pt());
2856             } else {
2857                 if (!pt().hasTag(ERROR) &amp;&amp;
2858                         (env.info.enclVar == null || !env.info.enclVar.type.isErroneous())) {
2859                     log.error(tree.pos(),
2860                               Errors.IllegalInitializerForType(pt()));
2861                 }
2862                 elemtype = types.createErrorType(pt());
2863             }
2864         }
2865         if (tree.elems != null) {
2866             attribExprs(tree.elems, localEnv, elemtype);
2867             owntype = new ArrayType(elemtype, syms.arrayClass);
2868         }
2869         if (!types.isReifiable(elemtype))
2870             log.error(tree.pos(), Errors.GenericArrayCreation);
2871         result = check(tree, owntype, KindSelector.VAL, resultInfo);
2872     }
2873 
2874     /*
2875      * A lambda expression can only be attributed when a target-type is available.
2876      * In addition, if the target-type is that of a functional interface whose
2877      * descriptor contains inference variables in argument position the lambda expression
2878      * is &#39;stuck&#39; (see DeferredAttr).
2879      */
2880     @Override
2881     public void visitLambda(final JCLambda that) {
2882         boolean wrongContext = false;
2883         if (pt().isErroneous() || (pt().hasTag(NONE) &amp;&amp; pt() != Type.recoveryType)) {
2884             if (pt().hasTag(NONE) &amp;&amp; (env.info.enclVar == null || !env.info.enclVar.type.isErroneous())) {
2885                 //lambda only allowed in assignment or method invocation/cast context
2886                 log.error(that.pos(), Errors.UnexpectedLambda);
2887             }
2888             resultInfo = recoveryInfo;
2889             wrongContext = true;
2890         }
2891         //create an environment for attribution of the lambda expression
2892         final Env&lt;AttrContext&gt; localEnv = lambdaEnv(that, env);
2893         boolean needsRecovery =
2894                 resultInfo.checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.CHECK;
2895         try {
2896             if (needsRecovery &amp;&amp; isSerializable(pt())) {
2897                 localEnv.info.isSerializable = true;
2898                 localEnv.info.isSerializableLambda = true;
2899             }
2900             localEnv.info.isLambda = true;
2901             List&lt;Type&gt; explicitParamTypes = null;
2902             if (that.paramKind == JCLambda.ParameterKind.EXPLICIT) {
2903                 //attribute lambda parameters
2904                 attribStats(that.params, localEnv);
2905                 explicitParamTypes = TreeInfo.types(that.params);
2906             }
2907 
2908             TargetInfo targetInfo = getTargetInfo(that, resultInfo, explicitParamTypes);
2909             Type currentTarget = targetInfo.target;
2910             Type lambdaType = targetInfo.descriptor;
2911 
2912             if (currentTarget.tsym != null &amp;&amp; ((ClassSymbol)currentTarget.tsym).isSealed()) {
2913                 log.error(that, Errors.CantInheritFromSealed(currentTarget.tsym));
2914             }
2915 
2916             if (currentTarget.isErroneous()) {
2917                 result = that.type = currentTarget;
2918                 return;
2919             }
2920 
2921             setFunctionalInfo(localEnv, that, pt(), lambdaType, currentTarget, resultInfo.checkContext);
2922 
2923             if (lambdaType.hasTag(FORALL)) {
2924                 //lambda expression target desc cannot be a generic method
2925                 Fragment msg = Fragments.InvalidGenericLambdaTarget(lambdaType,
2926                                                                     kindName(currentTarget.tsym),
2927                                                                     currentTarget.tsym);
2928                 resultInfo.checkContext.report(that, diags.fragment(msg));
2929                 result = that.type = types.createErrorType(pt());
2930                 return;
2931             }
2932 
2933             if (that.paramKind == JCLambda.ParameterKind.IMPLICIT) {
2934                 //add param type info in the AST
2935                 List&lt;Type&gt; actuals = lambdaType.getParameterTypes();
2936                 List&lt;JCVariableDecl&gt; params = that.params;
2937 
2938                 boolean arityMismatch = false;
2939 
2940                 while (params.nonEmpty()) {
2941                     if (actuals.isEmpty()) {
2942                         //not enough actuals to perform lambda parameter inference
2943                         arityMismatch = true;
2944                     }
2945                     //reset previously set info
2946                     Type argType = arityMismatch ?
2947                             syms.errType :
2948                             actuals.head;
2949                     if (params.head.isImplicitlyTyped()) {
2950                         setSyntheticVariableType(params.head, argType);
2951                     }
2952                     params.head.sym = null;
2953                     actuals = actuals.isEmpty() ?
2954                             actuals :
2955                             actuals.tail;
2956                     params = params.tail;
2957                 }
2958 
2959                 //attribute lambda parameters
2960                 attribStats(that.params, localEnv);
2961 
2962                 if (arityMismatch) {
2963                     resultInfo.checkContext.report(that, diags.fragment(Fragments.IncompatibleArgTypesInLambda));
2964                         result = that.type = types.createErrorType(currentTarget);
2965                         return;
2966                 }
2967             }
2968 
2969             //from this point on, no recovery is needed; if we are in assignment context
2970             //we will be able to attribute the whole lambda body, regardless of errors;
2971             //if we are in a &#39;check&#39; method context, and the lambda is not compatible
2972             //with the target-type, it will be recovered anyway in Attr.checkId
2973             needsRecovery = false;
2974 
2975             ResultInfo bodyResultInfo = localEnv.info.returnResult =
2976                     lambdaBodyResult(that, lambdaType, resultInfo);
2977 
2978             if (that.getBodyKind() == JCLambda.BodyKind.EXPRESSION) {
2979                 attribTree(that.getBody(), localEnv, bodyResultInfo);
2980             } else {
2981                 JCBlock body = (JCBlock)that.body;
2982                 if (body == breakTree &amp;&amp;
2983                         resultInfo.checkContext.deferredAttrContext().mode == AttrMode.CHECK) {
2984                     breakTreeFound(copyEnv(localEnv));
2985                 }
2986                 attribStats(body.stats, localEnv);
2987             }
2988 
2989             result = check(that, currentTarget, KindSelector.VAL, resultInfo);
2990 
2991             boolean isSpeculativeRound =
2992                     resultInfo.checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.SPECULATIVE;
2993 
2994             preFlow(that);
2995             flow.analyzeLambda(env, that, make, isSpeculativeRound);
2996 
2997             that.type = currentTarget; //avoids recovery at this stage
2998             checkLambdaCompatible(that, lambdaType, resultInfo.checkContext);
2999 
3000             if (!isSpeculativeRound) {
3001                 //add thrown types as bounds to the thrown types free variables if needed:
3002                 if (resultInfo.checkContext.inferenceContext().free(lambdaType.getThrownTypes())) {
3003                     List&lt;Type&gt; inferredThrownTypes = flow.analyzeLambdaThrownTypes(env, that, make);
3004                     if(!checkExConstraints(inferredThrownTypes, lambdaType.getThrownTypes(), resultInfo.checkContext.inferenceContext())) {
3005                         log.error(that, Errors.IncompatibleThrownTypesInMref(lambdaType.getThrownTypes()));
3006                     }
3007                 }
3008 
3009                 checkAccessibleTypes(that, localEnv, resultInfo.checkContext.inferenceContext(), lambdaType, currentTarget);
3010             }
3011             result = wrongContext ? that.type = types.createErrorType(pt())
3012                                   : check(that, currentTarget, KindSelector.VAL, resultInfo);
3013         } catch (Types.FunctionDescriptorLookupError ex) {
3014             JCDiagnostic cause = ex.getDiagnostic();
3015             resultInfo.checkContext.report(that, cause);
3016             result = that.type = types.createErrorType(pt());
3017             return;
3018         } catch (CompletionFailure cf) {
3019             chk.completionError(that.pos(), cf);
3020         } catch (Throwable t) {
3021             //when an unexpected exception happens, avoid attempts to attribute the same tree again
3022             //as that would likely cause the same exception again.
3023             needsRecovery = false;
3024             throw t;
3025         } finally {
3026             localEnv.info.scope.leave();
3027             if (needsRecovery) {
3028                 attribTree(that, env, recoveryInfo);
3029             }
3030         }
3031     }
3032     //where
3033         class TargetInfo {
3034             Type target;
3035             Type descriptor;
3036 
3037             public TargetInfo(Type target, Type descriptor) {
3038                 this.target = target;
3039                 this.descriptor = descriptor;
3040             }
3041         }
3042 
3043         TargetInfo getTargetInfo(JCPolyExpression that, ResultInfo resultInfo, List&lt;Type&gt; explicitParamTypes) {
3044             Type lambdaType;
3045             Type currentTarget = resultInfo.pt;
3046             if (resultInfo.pt != Type.recoveryType) {
3047                 /* We need to adjust the target. If the target is an
3048                  * intersection type, for example: SAM &amp; I1 &amp; I2 ...
3049                  * the target will be updated to SAM
3050                  */
3051                 currentTarget = targetChecker.visit(currentTarget, that);
3052                 if (!currentTarget.isIntersection()) {
3053                     if (explicitParamTypes != null) {
3054                         currentTarget = infer.instantiateFunctionalInterface(that,
3055                                 currentTarget, explicitParamTypes, resultInfo.checkContext);
3056                     }
3057                     currentTarget = types.removeWildcards(currentTarget);
3058                     lambdaType = types.findDescriptorType(currentTarget);
3059                 } else {
3060                     IntersectionClassType ict = (IntersectionClassType)currentTarget;
3061                     ListBuffer&lt;Type&gt; components = new ListBuffer&lt;&gt;();
3062                     for (Type bound : ict.getExplicitComponents()) {
3063                         if (explicitParamTypes != null) {
3064                             try {
3065                                 bound = infer.instantiateFunctionalInterface(that,
3066                                         bound, explicitParamTypes, resultInfo.checkContext);
3067                             } catch (FunctionDescriptorLookupError t) {
3068                                 // do nothing
3069                             }
3070                         }
3071                         bound = types.removeWildcards(bound);
3072                         components.add(bound);
3073                     }
3074                     currentTarget = types.makeIntersectionType(components.toList());
3075                     currentTarget.tsym.flags_field |= INTERFACE;
3076                     lambdaType = types.findDescriptorType(currentTarget);
3077                 }
3078 
3079             } else {
3080                 currentTarget = Type.recoveryType;
3081                 lambdaType = fallbackDescriptorType(that);
3082             }
3083             if (that.hasTag(LAMBDA) &amp;&amp; lambdaType.hasTag(FORALL)) {
3084                 //lambda expression target desc cannot be a generic method
3085                 Fragment msg = Fragments.InvalidGenericLambdaTarget(lambdaType,
3086                                                                     kindName(currentTarget.tsym),
3087                                                                     currentTarget.tsym);
3088                 resultInfo.checkContext.report(that, diags.fragment(msg));
3089                 currentTarget = types.createErrorType(pt());
3090             }
3091             return new TargetInfo(currentTarget, lambdaType);
3092         }
3093 
3094         void preFlow(JCLambda tree) {
3095             new PostAttrAnalyzer() {
3096                 @Override
3097                 public void scan(JCTree tree) {
3098                     if (tree == null ||
3099                             (tree.type != null &amp;&amp;
3100                             tree.type == Type.stuckType)) {
3101                         //don&#39;t touch stuck expressions!
3102                         return;
3103                     }
3104                     super.scan(tree);
3105                 }
3106 
3107                 @Override
3108                 public void visitClassDef(JCClassDecl that) {
3109                     // or class declaration trees!
3110                 }
3111 
3112                 public void visitLambda(JCLambda that) {
3113                     // or lambda expressions!
3114                 }
3115             }.scan(tree.body);
3116         }
3117 
3118         Types.MapVisitor&lt;DiagnosticPosition&gt; targetChecker = new Types.MapVisitor&lt;DiagnosticPosition&gt;() {
3119 
3120             @Override
3121             public Type visitClassType(ClassType t, DiagnosticPosition pos) {
3122                 return t.isIntersection() ?
3123                         visitIntersectionClassType((IntersectionClassType)t, pos) : t;
3124             }
3125 
3126             public Type visitIntersectionClassType(IntersectionClassType ict, DiagnosticPosition pos) {
3127                 types.findDescriptorSymbol(makeNotionalInterface(ict, pos));
3128                 return ict;
3129             }
3130 
3131             private TypeSymbol makeNotionalInterface(IntersectionClassType ict, DiagnosticPosition pos) {
3132                 ListBuffer&lt;Type&gt; targs = new ListBuffer&lt;&gt;();
3133                 ListBuffer&lt;Type&gt; supertypes = new ListBuffer&lt;&gt;();
3134                 for (Type i : ict.interfaces_field) {
3135                     if (i.isParameterized()) {
3136                         targs.appendList(i.tsym.type.allparams());
3137                     }
3138                     supertypes.append(i.tsym.type);
3139                 }
3140                 IntersectionClassType notionalIntf = types.makeIntersectionType(supertypes.toList());
3141                 notionalIntf.allparams_field = targs.toList();
3142                 notionalIntf.tsym.flags_field |= INTERFACE;
3143                 return notionalIntf.tsym;
3144             }
3145         };
3146 
3147         private Type fallbackDescriptorType(JCExpression tree) {
3148             switch (tree.getTag()) {
3149                 case LAMBDA:
3150                     JCLambda lambda = (JCLambda)tree;
3151                     List&lt;Type&gt; argtypes = List.nil();
3152                     for (JCVariableDecl param : lambda.params) {
3153                         argtypes = param.vartype != null &amp;&amp; param.vartype.type != null ?
3154                                 argtypes.append(param.vartype.type) :
3155                                 argtypes.append(syms.errType);
3156                     }
3157                     return new MethodType(argtypes, Type.recoveryType,
3158                             List.of(syms.throwableType), syms.methodClass);
3159                 case REFERENCE:
3160                     return new MethodType(List.nil(), Type.recoveryType,
3161                             List.of(syms.throwableType), syms.methodClass);
3162                 default:
3163                     Assert.error(&quot;Cannot get here!&quot;);
3164             }
3165             return null;
3166         }
3167 
3168         private void checkAccessibleTypes(final DiagnosticPosition pos, final Env&lt;AttrContext&gt; env,
3169                 final InferenceContext inferenceContext, final Type... ts) {
3170             checkAccessibleTypes(pos, env, inferenceContext, List.from(ts));
3171         }
3172 
3173         private void checkAccessibleTypes(final DiagnosticPosition pos, final Env&lt;AttrContext&gt; env,
3174                 final InferenceContext inferenceContext, final List&lt;Type&gt; ts) {
3175             if (inferenceContext.free(ts)) {
3176                 inferenceContext.addFreeTypeListener(ts,
3177                         solvedContext -&gt; checkAccessibleTypes(pos, env, solvedContext, solvedContext.asInstTypes(ts)));
3178             } else {
3179                 for (Type t : ts) {
3180                     rs.checkAccessibleType(env, t);
3181                 }
3182             }
3183         }
3184 
3185         /**
3186          * Lambda/method reference have a special check context that ensures
3187          * that i.e. a lambda return type is compatible with the expected
3188          * type according to both the inherited context and the assignment
3189          * context.
3190          */
3191         class FunctionalReturnContext extends Check.NestedCheckContext {
3192 
3193             FunctionalReturnContext(CheckContext enclosingContext) {
3194                 super(enclosingContext);
3195             }
3196 
3197             @Override
3198             public boolean compatible(Type found, Type req, Warner warn) {
3199                 //return type must be compatible in both current context and assignment context
3200                 return chk.basicHandler.compatible(inferenceContext().asUndetVar(found), inferenceContext().asUndetVar(req), warn);
3201             }
3202 
3203             @Override
3204             public void report(DiagnosticPosition pos, JCDiagnostic details) {
3205                 enclosingContext.report(pos, diags.fragment(Fragments.IncompatibleRetTypeInLambda(details)));
3206             }
3207         }
3208 
3209         class ExpressionLambdaReturnContext extends FunctionalReturnContext {
3210 
3211             JCExpression expr;
3212             boolean expStmtExpected;
3213 
3214             ExpressionLambdaReturnContext(JCExpression expr, CheckContext enclosingContext) {
3215                 super(enclosingContext);
3216                 this.expr = expr;
3217             }
3218 
3219             @Override
3220             public void report(DiagnosticPosition pos, JCDiagnostic details) {
3221                 if (expStmtExpected) {
3222                     enclosingContext.report(pos, diags.fragment(Fragments.StatExprExpected));
3223                 } else {
3224                     super.report(pos, details);
3225                 }
3226             }
3227 
3228             @Override
3229             public boolean compatible(Type found, Type req, Warner warn) {
3230                 //a void return is compatible with an expression statement lambda
3231                 if (req.hasTag(VOID)) {
3232                     expStmtExpected = true;
3233                     return TreeInfo.isExpressionStatement(expr);
3234                 } else {
3235                     return super.compatible(found, req, warn);
3236                 }
3237             }
3238         }
3239 
3240         ResultInfo lambdaBodyResult(JCLambda that, Type descriptor, ResultInfo resultInfo) {
3241             FunctionalReturnContext funcContext = that.getBodyKind() == JCLambda.BodyKind.EXPRESSION ?
3242                     new ExpressionLambdaReturnContext((JCExpression)that.getBody(), resultInfo.checkContext) :
3243                     new FunctionalReturnContext(resultInfo.checkContext);
3244 
3245             return descriptor.getReturnType() == Type.recoveryType ?
3246                     recoveryInfo :
3247                     new ResultInfo(KindSelector.VAL,
3248                             descriptor.getReturnType(), funcContext);
3249         }
3250 
3251         /**
3252         * Lambda compatibility. Check that given return types, thrown types, parameter types
3253         * are compatible with the expected functional interface descriptor. This means that:
3254         * (i) parameter types must be identical to those of the target descriptor; (ii) return
3255         * types must be compatible with the return type of the expected descriptor.
3256         */
3257         void checkLambdaCompatible(JCLambda tree, Type descriptor, CheckContext checkContext) {
3258             Type returnType = checkContext.inferenceContext().asUndetVar(descriptor.getReturnType());
3259 
3260             //return values have already been checked - but if lambda has no return
3261             //values, we must ensure that void/value compatibility is correct;
3262             //this amounts at checking that, if a lambda body can complete normally,
3263             //the descriptor&#39;s return type must be void
3264             if (tree.getBodyKind() == JCLambda.BodyKind.STATEMENT &amp;&amp; tree.canCompleteNormally &amp;&amp;
3265                     !returnType.hasTag(VOID) &amp;&amp; returnType != Type.recoveryType) {
3266                 Fragment msg =
3267                         Fragments.IncompatibleRetTypeInLambda(Fragments.MissingRetVal(returnType));
3268                 checkContext.report(tree,
3269                                     diags.fragment(msg));
3270             }
3271 
3272             List&lt;Type&gt; argTypes = checkContext.inferenceContext().asUndetVars(descriptor.getParameterTypes());
3273             if (!types.isSameTypes(argTypes, TreeInfo.types(tree.params))) {
3274                 checkContext.report(tree, diags.fragment(Fragments.IncompatibleArgTypesInLambda));
3275             }
3276         }
3277 
3278         /* Map to hold &#39;fake&#39; clinit methods. If a lambda is used to initialize a
3279          * static field and that lambda has type annotations, these annotations will
3280          * also be stored at these fake clinit methods.
3281          *
3282          * LambdaToMethod also use fake clinit methods so they can be reused.
3283          * Also as LTM is a phase subsequent to attribution, the methods from
3284          * clinits can be safely removed by LTM to save memory.
3285          */
3286         private Map&lt;ClassSymbol, MethodSymbol&gt; clinits = new HashMap&lt;&gt;();
3287 
3288         public MethodSymbol removeClinit(ClassSymbol sym) {
3289             return clinits.remove(sym);
3290         }
3291 
3292         /* This method returns an environment to be used to attribute a lambda
3293          * expression.
3294          *
3295          * The owner of this environment is a method symbol. If the current owner
3296          * is not a method, for example if the lambda is used to initialize
3297          * a field, then if the field is:
3298          *
3299          * - an instance field, we use the first constructor.
3300          * - a static field, we create a fake clinit method.
3301          */
3302         public Env&lt;AttrContext&gt; lambdaEnv(JCLambda that, Env&lt;AttrContext&gt; env) {
3303             Env&lt;AttrContext&gt; lambdaEnv;
3304             Symbol owner = env.info.scope.owner;
3305             if (owner.kind == VAR &amp;&amp; owner.owner.kind == TYP) {
3306                 //field initializer
3307                 ClassSymbol enclClass = owner.enclClass();
3308                 Symbol newScopeOwner = env.info.scope.owner;
3309                 /* if the field isn&#39;t static, then we can get the first constructor
3310                  * and use it as the owner of the environment. This is what
3311                  * LTM code is doing to look for type annotations so we are fine.
3312                  */
3313                 if ((owner.flags() &amp; STATIC) == 0) {
3314                     for (Symbol s : enclClass.members_field.getSymbolsByName(names.init)) {
3315                         newScopeOwner = s;
3316                         break;
3317                     }
3318                 } else {
3319                     /* if the field is static then we need to create a fake clinit
3320                      * method, this method can later be reused by LTM.
3321                      */
3322                     MethodSymbol clinit = clinits.get(enclClass);
3323                     if (clinit == null) {
3324                         Type clinitType = new MethodType(List.nil(),
3325                                 syms.voidType, List.nil(), syms.methodClass);
3326                         clinit = new MethodSymbol(STATIC | SYNTHETIC | PRIVATE,
3327                                 names.clinit, clinitType, enclClass);
3328                         clinit.params = List.nil();
3329                         clinits.put(enclClass, clinit);
3330                     }
3331                     newScopeOwner = clinit;
3332                 }
3333                 lambdaEnv = env.dup(that, env.info.dup(env.info.scope.dupUnshared(newScopeOwner)));
3334             } else {
3335                 lambdaEnv = env.dup(that, env.info.dup(env.info.scope.dup()));
3336             }
3337             lambdaEnv.info.yieldResult = null;
3338             return lambdaEnv;
3339         }
3340 
3341     @Override
3342     public void visitReference(final JCMemberReference that) {
3343         if (pt().isErroneous() || (pt().hasTag(NONE) &amp;&amp; pt() != Type.recoveryType)) {
3344             if (pt().hasTag(NONE) &amp;&amp; (env.info.enclVar == null || !env.info.enclVar.type.isErroneous())) {
3345                 //method reference only allowed in assignment or method invocation/cast context
3346                 log.error(that.pos(), Errors.UnexpectedMref);
3347             }
3348             result = that.type = types.createErrorType(pt());
3349             return;
3350         }
3351         final Env&lt;AttrContext&gt; localEnv = env.dup(that);
3352         try {
3353             //attribute member reference qualifier - if this is a constructor
3354             //reference, the expected kind must be a type
3355             Type exprType = attribTree(that.expr, env, memberReferenceQualifierResult(that));
3356 
3357             if (that.getMode() == JCMemberReference.ReferenceMode.NEW) {
3358                 exprType = chk.checkConstructorRefType(that.expr, exprType);
3359                 if (!exprType.isErroneous() &amp;&amp;
3360                     exprType.isRaw() &amp;&amp;
3361                     that.typeargs != null) {
3362                     log.error(that.expr.pos(),
3363                               Errors.InvalidMref(Kinds.kindName(that.getMode()),
3364                                                  Fragments.MrefInferAndExplicitParams));
3365                     exprType = types.createErrorType(exprType);
3366                 }
3367             }
3368 
3369             if (exprType.isErroneous()) {
3370                 //if the qualifier expression contains problems,
3371                 //give up attribution of method reference
3372                 result = that.type = exprType;
3373                 return;
3374             }
3375 
3376             if (TreeInfo.isStaticSelector(that.expr, names)) {
3377                 //if the qualifier is a type, validate it; raw warning check is
3378                 //omitted as we don&#39;t know at this stage as to whether this is a
3379                 //raw selector (because of inference)
3380                 chk.validate(that.expr, env, false);
3381             } else {
3382                 Symbol lhsSym = TreeInfo.symbol(that.expr);
3383                 localEnv.info.selectSuper = lhsSym != null &amp;&amp; lhsSym.name == names._super;
3384             }
3385             //attrib type-arguments
3386             List&lt;Type&gt; typeargtypes = List.nil();
3387             if (that.typeargs != null) {
3388                 typeargtypes = attribTypes(that.typeargs, localEnv);
3389             }
3390 
3391             boolean isTargetSerializable =
3392                     resultInfo.checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.CHECK &amp;&amp;
3393                     isSerializable(pt());
3394             TargetInfo targetInfo = getTargetInfo(that, resultInfo, null);
3395             Type currentTarget = targetInfo.target;
3396             Type desc = targetInfo.descriptor;
3397 
3398             setFunctionalInfo(localEnv, that, pt(), desc, currentTarget, resultInfo.checkContext);
3399             List&lt;Type&gt; argtypes = desc.getParameterTypes();
3400             Resolve.MethodCheck referenceCheck = rs.resolveMethodCheck;
3401 
3402             if (resultInfo.checkContext.inferenceContext().free(argtypes)) {
3403                 referenceCheck = rs.new MethodReferenceCheck(resultInfo.checkContext.inferenceContext());
3404             }
3405 
3406             Pair&lt;Symbol, Resolve.ReferenceLookupHelper&gt; refResult = null;
3407             List&lt;Type&gt; saved_undet = resultInfo.checkContext.inferenceContext().save();
3408             try {
3409                 refResult = rs.resolveMemberReference(localEnv, that, that.expr.type,
3410                         that.name, argtypes, typeargtypes, targetInfo.descriptor, referenceCheck,
3411                         resultInfo.checkContext.inferenceContext(), rs.basicReferenceChooser);
3412             } finally {
3413                 resultInfo.checkContext.inferenceContext().rollback(saved_undet);
3414             }
3415 
3416             Symbol refSym = refResult.fst;
3417             Resolve.ReferenceLookupHelper lookupHelper = refResult.snd;
3418 
3419             /** this switch will need to go away and be replaced by the new RESOLUTION_TARGET testing
3420              *  JDK-8075541
3421              */
3422             if (refSym.kind != MTH) {
3423                 boolean targetError;
3424                 switch (refSym.kind) {
3425                     case ABSENT_MTH:
3426                     case MISSING_ENCL:
3427                         targetError = false;
3428                         break;
3429                     case WRONG_MTH:
3430                     case WRONG_MTHS:
3431                     case AMBIGUOUS:
3432                     case HIDDEN:
3433                     case STATICERR:
3434                         targetError = true;
3435                         break;
3436                     default:
3437                         Assert.error(&quot;unexpected result kind &quot; + refSym.kind);
3438                         targetError = false;
3439                 }
3440 
3441                 JCDiagnostic detailsDiag = ((Resolve.ResolveError)refSym.baseSymbol())
3442                         .getDiagnostic(JCDiagnostic.DiagnosticType.FRAGMENT,
3443                                 that, exprType.tsym, exprType, that.name, argtypes, typeargtypes);
3444 
3445                 JCDiagnostic diag = diags.create(log.currentSource(), that,
3446                         targetError ?
3447                             Fragments.InvalidMref(Kinds.kindName(that.getMode()), detailsDiag) :
3448                             Errors.InvalidMref(Kinds.kindName(that.getMode()), detailsDiag));
3449 
3450                 if (targetError &amp;&amp; currentTarget == Type.recoveryType) {
3451                     //a target error doesn&#39;t make sense during recovery stage
3452                     //as we don&#39;t know what actual parameter types are
3453                     result = that.type = currentTarget;
3454                     return;
3455                 } else {
3456                     if (targetError) {
3457                         resultInfo.checkContext.report(that, diag);
3458                     } else {
3459                         log.report(diag);
3460                     }
3461                     result = that.type = types.createErrorType(currentTarget);
3462                     return;
3463                 }
3464             }
3465 
3466             that.sym = refSym.isConstructor() ? refSym.baseSymbol() : refSym;
3467             that.kind = lookupHelper.referenceKind(that.sym);
3468             that.ownerAccessible = rs.isAccessible(localEnv, that.sym.enclClass());
3469 
3470             if (desc.getReturnType() == Type.recoveryType) {
3471                 // stop here
3472                 result = that.type = currentTarget;
3473                 return;
3474             }
3475 
3476             if (!env.info.attributionMode.isSpeculative &amp;&amp; that.getMode() == JCMemberReference.ReferenceMode.NEW) {
3477                 Type enclosingType = exprType.getEnclosingType();
3478                 if (enclosingType != null &amp;&amp; enclosingType.hasTag(CLASS)) {
3479                     // Check for the existence of an appropriate outer instance
3480                     rs.resolveImplicitThis(that.pos(), env, exprType);
3481                 }
3482             }
3483 
3484             if (resultInfo.checkContext.deferredAttrContext().mode == AttrMode.CHECK) {
3485 
3486                 if (that.getMode() == ReferenceMode.INVOKE &amp;&amp;
3487                         TreeInfo.isStaticSelector(that.expr, names) &amp;&amp;
3488                         that.kind.isUnbound() &amp;&amp;
3489                         lookupHelper.site.isRaw()) {
3490                     chk.checkRaw(that.expr, localEnv);
3491                 }
3492 
3493                 if (that.sym.isStatic() &amp;&amp; TreeInfo.isStaticSelector(that.expr, names) &amp;&amp;
3494                         exprType.getTypeArguments().nonEmpty()) {
3495                     //static ref with class type-args
3496                     log.error(that.expr.pos(),
3497                               Errors.InvalidMref(Kinds.kindName(that.getMode()),
3498                                                  Fragments.StaticMrefWithTargs));
3499                     result = that.type = types.createErrorType(currentTarget);
3500                     return;
3501                 }
3502 
3503                 if (!refSym.isStatic() &amp;&amp; that.kind == JCMemberReference.ReferenceKind.SUPER) {
3504                     // Check that super-qualified symbols are not abstract (JLS)
3505                     rs.checkNonAbstract(that.pos(), that.sym);
3506                 }
3507 
3508                 if (isTargetSerializable) {
3509                     chk.checkAccessFromSerializableElement(that, true);
3510                 }
3511             }
3512 
3513             ResultInfo checkInfo =
3514                     resultInfo.dup(newMethodTemplate(
3515                         desc.getReturnType().hasTag(VOID) ? Type.noType : desc.getReturnType(),
3516                         that.kind.isUnbound() ? argtypes.tail : argtypes, typeargtypes),
3517                         new FunctionalReturnContext(resultInfo.checkContext), CheckMode.NO_TREE_UPDATE);
3518 
3519             Type refType = checkId(that, lookupHelper.site, refSym, localEnv, checkInfo);
3520 
3521             if (that.kind.isUnbound() &amp;&amp;
3522                     resultInfo.checkContext.inferenceContext().free(argtypes.head)) {
3523                 //re-generate inference constraints for unbound receiver
3524                 if (!types.isSubtype(resultInfo.checkContext.inferenceContext().asUndetVar(argtypes.head), exprType)) {
3525                     //cannot happen as this has already been checked - we just need
3526                     //to regenerate the inference constraints, as that has been lost
3527                     //as a result of the call to inferenceContext.save()
3528                     Assert.error(&quot;Can&#39;t get here&quot;);
3529                 }
3530             }
3531 
3532             if (!refType.isErroneous()) {
3533                 refType = types.createMethodTypeWithReturn(refType,
3534                         adjustMethodReturnType(refSym, lookupHelper.site, that.name, checkInfo.pt.getParameterTypes(), refType.getReturnType()));
3535             }
3536 
3537             //go ahead with standard method reference compatibility check - note that param check
3538             //is a no-op (as this has been taken care during method applicability)
3539             boolean isSpeculativeRound =
3540                     resultInfo.checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.SPECULATIVE;
3541 
3542             that.type = currentTarget; //avoids recovery at this stage
3543             checkReferenceCompatible(that, desc, refType, resultInfo.checkContext, isSpeculativeRound);
3544             if (!isSpeculativeRound) {
3545                 checkAccessibleTypes(that, localEnv, resultInfo.checkContext.inferenceContext(), desc, currentTarget);
3546             }
3547             result = check(that, currentTarget, KindSelector.VAL, resultInfo);
3548         } catch (Types.FunctionDescriptorLookupError ex) {
3549             JCDiagnostic cause = ex.getDiagnostic();
3550             resultInfo.checkContext.report(that, cause);
3551             result = that.type = types.createErrorType(pt());
3552             return;
3553         }
3554     }
3555     //where
3556         ResultInfo memberReferenceQualifierResult(JCMemberReference tree) {
3557             //if this is a constructor reference, the expected kind must be a type
3558             return new ResultInfo(tree.getMode() == ReferenceMode.INVOKE ?
3559                                   KindSelector.VAL_TYP : KindSelector.TYP,
3560                                   Type.noType);
3561         }
3562 
3563 
3564     @SuppressWarnings(&quot;fallthrough&quot;)
3565     void checkReferenceCompatible(JCMemberReference tree, Type descriptor, Type refType, CheckContext checkContext, boolean speculativeAttr) {
3566         InferenceContext inferenceContext = checkContext.inferenceContext();
3567         Type returnType = inferenceContext.asUndetVar(descriptor.getReturnType());
3568 
3569         Type resType;
3570         switch (tree.getMode()) {
3571             case NEW:
3572                 if (!tree.expr.type.isRaw()) {
3573                     resType = tree.expr.type;
3574                     break;
3575                 }
3576             default:
3577                 resType = refType.getReturnType();
3578         }
3579 
3580         Type incompatibleReturnType = resType;
3581 
3582         if (returnType.hasTag(VOID)) {
3583             incompatibleReturnType = null;
3584         }
3585 
3586         if (!returnType.hasTag(VOID) &amp;&amp; !resType.hasTag(VOID)) {
3587             if (resType.isErroneous() ||
3588                     new FunctionalReturnContext(checkContext).compatible(resType, returnType,
3589                             checkContext.checkWarner(tree, resType, returnType))) {
3590                 incompatibleReturnType = null;
3591             }
3592         }
3593 
3594         if (incompatibleReturnType != null) {
3595             Fragment msg =
3596                     Fragments.IncompatibleRetTypeInMref(Fragments.InconvertibleTypes(resType, descriptor.getReturnType()));
3597             checkContext.report(tree, diags.fragment(msg));
3598         } else {
3599             if (inferenceContext.free(refType)) {
3600                 // we need to wait for inference to finish and then replace inference vars in the referent type
3601                 inferenceContext.addFreeTypeListener(List.of(refType),
3602                         instantiatedContext -&gt; {
3603                             tree.referentType = instantiatedContext.asInstType(refType);
3604                         });
3605             } else {
3606                 tree.referentType = refType;
3607             }
3608         }
3609 
3610         if (!speculativeAttr) {
3611             if (!checkExConstraints(refType.getThrownTypes(), descriptor.getThrownTypes(), inferenceContext)) {
3612                 log.error(tree, Errors.IncompatibleThrownTypesInMref(refType.getThrownTypes()));
3613             }
3614         }
3615     }
3616 
3617     boolean checkExConstraints(
3618             List&lt;Type&gt; thrownByFuncExpr,
3619             List&lt;Type&gt; thrownAtFuncType,
3620             InferenceContext inferenceContext) {
3621         /** 18.2.5: Otherwise, let E1, ..., En be the types in the function type&#39;s throws clause that
3622          *  are not proper types
3623          */
3624         List&lt;Type&gt; nonProperList = thrownAtFuncType.stream()
3625                 .filter(e -&gt; inferenceContext.free(e)).collect(List.collector());
3626         List&lt;Type&gt; properList = thrownAtFuncType.diff(nonProperList);
3627 
3628         /** Let X1,...,Xm be the checked exception types that the lambda body can throw or
3629          *  in the throws clause of the invocation type of the method reference&#39;s compile-time
3630          *  declaration
3631          */
3632         List&lt;Type&gt; checkedList = thrownByFuncExpr.stream()
3633                 .filter(e -&gt; chk.isChecked(e)).collect(List.collector());
3634 
3635         /** If n = 0 (the function type&#39;s throws clause consists only of proper types), then
3636          *  if there exists some i (1 &lt;= i &lt;= m) such that Xi is not a subtype of any proper type
3637          *  in the throws clause, the constraint reduces to false; otherwise, the constraint
3638          *  reduces to true
3639          */
3640         ListBuffer&lt;Type&gt; uncaughtByProperTypes = new ListBuffer&lt;&gt;();
3641         for (Type checked : checkedList) {
3642             boolean isSubtype = false;
3643             for (Type proper : properList) {
3644                 if (types.isSubtype(checked, proper)) {
3645                     isSubtype = true;
3646                     break;
3647                 }
3648             }
3649             if (!isSubtype) {
3650                 uncaughtByProperTypes.add(checked);
3651             }
3652         }
3653 
3654         if (nonProperList.isEmpty() &amp;&amp; !uncaughtByProperTypes.isEmpty()) {
3655             return false;
3656         }
3657 
3658         /** If n &gt; 0, the constraint reduces to a set of subtyping constraints:
3659          *  for all i (1 &lt;= i &lt;= m), if Xi is not a subtype of any proper type in the
3660          *  throws clause, then the constraints include, for all j (1 &lt;= j &lt;= n), &lt;Xi &lt;: Ej&gt;
3661          */
3662         List&lt;Type&gt; nonProperAsUndet = inferenceContext.asUndetVars(nonProperList);
3663         uncaughtByProperTypes.forEach(checkedEx -&gt; {
3664             nonProperAsUndet.forEach(nonProper -&gt; {
3665                 types.isSubtype(checkedEx, nonProper);
3666             });
3667         });
3668 
3669         /** In addition, for all j (1 &lt;= j &lt;= n), the constraint reduces to the bound throws Ej
3670          */
3671         nonProperAsUndet.stream()
3672                 .filter(t -&gt; t.hasTag(UNDETVAR))
3673                 .forEach(t -&gt; ((UndetVar)t).setThrow());
3674         return true;
3675     }
3676 
3677     /**
3678      * Set functional type info on the underlying AST. Note: as the target descriptor
3679      * might contain inference variables, we might need to register an hook in the
3680      * current inference context.
3681      */
3682     private void setFunctionalInfo(final Env&lt;AttrContext&gt; env, final JCFunctionalExpression fExpr,
3683             final Type pt, final Type descriptorType, final Type primaryTarget, final CheckContext checkContext) {
3684         if (checkContext.inferenceContext().free(descriptorType)) {
3685             checkContext.inferenceContext().addFreeTypeListener(List.of(pt, descriptorType),
3686                     inferenceContext -&gt; setFunctionalInfo(env, fExpr, pt, inferenceContext.asInstType(descriptorType),
3687                     inferenceContext.asInstType(primaryTarget), checkContext));
3688         } else {
3689             if (pt.hasTag(CLASS)) {
3690                 fExpr.target = primaryTarget;
3691             }
3692             if (checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.CHECK &amp;&amp;
3693                     pt != Type.recoveryType) {
3694                 //check that functional interface class is well-formed
3695                 try {
3696                     /* Types.makeFunctionalInterfaceClass() may throw an exception
3697                      * when it&#39;s executed post-inference. See the listener code
3698                      * above.
3699                      */
3700                     ClassSymbol csym = types.makeFunctionalInterfaceClass(env,
3701                             names.empty, fExpr.target, ABSTRACT);
3702                     if (csym != null) {
3703                         chk.checkImplementations(env.tree, csym, csym);
3704                         try {
3705                             //perform an additional functional interface check on the synthetic class,
3706                             //as there may be spurious errors for raw targets - because of existing issues
3707                             //with membership and inheritance (see JDK-8074570).
3708                             csym.flags_field |= INTERFACE;
3709                             types.findDescriptorType(csym.type);
3710                         } catch (FunctionDescriptorLookupError err) {
3711                             resultInfo.checkContext.report(fExpr,
3712                                     diags.fragment(Fragments.NoSuitableFunctionalIntfInst(fExpr.target)));
3713                         }
3714                     }
3715                 } catch (Types.FunctionDescriptorLookupError ex) {
3716                     JCDiagnostic cause = ex.getDiagnostic();
3717                     resultInfo.checkContext.report(env.tree, cause);
3718                 }
3719             }
3720         }
3721     }
3722 
3723     public void visitParens(JCParens tree) {
3724         Type owntype = attribTree(tree.expr, env, resultInfo);
3725         result = check(tree, owntype, pkind(), resultInfo);
3726         Symbol sym = TreeInfo.symbol(tree);
3727         if (sym != null &amp;&amp; sym.kind.matches(KindSelector.TYP_PCK))
3728             log.error(tree.pos(), Errors.IllegalParenthesizedExpression);
3729     }
3730 
3731     public void visitAssign(JCAssign tree) {
3732         Type owntype = attribTree(tree.lhs, env.dup(tree), varAssignmentInfo);
3733         Type capturedType = capture(owntype);
3734         attribExpr(tree.rhs, env, owntype);
3735         result = check(tree, capturedType, KindSelector.VAL, resultInfo);
3736     }
3737 
3738     public void visitAssignop(JCAssignOp tree) {
3739         // Attribute arguments.
3740         Type owntype = attribTree(tree.lhs, env, varAssignmentInfo);
3741         Type operand = attribExpr(tree.rhs, env);
3742         // Find operator.
3743         Symbol operator = tree.operator = operators.resolveBinary(tree, tree.getTag().noAssignOp(), owntype, operand);
3744         if (operator != operators.noOpSymbol &amp;&amp;
3745                 !owntype.isErroneous() &amp;&amp;
3746                 !operand.isErroneous()) {
3747             chk.checkDivZero(tree.rhs.pos(), operator, operand);
3748             chk.checkCastable(tree.rhs.pos(),
3749                               operator.type.getReturnType(),
3750                               owntype);
3751         }
3752         result = check(tree, owntype, KindSelector.VAL, resultInfo);
3753     }
3754 
3755     public void visitUnary(JCUnary tree) {
3756         // Attribute arguments.
3757         Type argtype = (tree.getTag().isIncOrDecUnaryOp())
3758             ? attribTree(tree.arg, env, varAssignmentInfo)
3759             : chk.checkNonVoid(tree.arg.pos(), attribExpr(tree.arg, env));
3760 
3761         // Find operator.
3762         Symbol operator = tree.operator = operators.resolveUnary(tree, tree.getTag(), argtype);
3763         Type owntype = types.createErrorType(tree.type);
3764         if (operator != operators.noOpSymbol &amp;&amp;
3765                 !argtype.isErroneous()) {
3766             owntype = (tree.getTag().isIncOrDecUnaryOp())
3767                 ? tree.arg.type
3768                 : operator.type.getReturnType();
3769             int opc = ((OperatorSymbol)operator).opcode;
3770 
3771             // If the argument is constant, fold it.
3772             if (argtype.constValue() != null) {
3773                 Type ctype = cfolder.fold1(opc, argtype);
3774                 if (ctype != null) {
3775                     owntype = cfolder.coerce(ctype, owntype);
3776                 }
3777             }
3778         }
3779         result = check(tree, owntype, KindSelector.VAL, resultInfo);
3780         matchBindings = matchBindingsComputer.unary(tree, matchBindings);
3781     }
3782 
3783     public void visitBinary(JCBinary tree) {
3784         // Attribute arguments.
3785         Type left = chk.checkNonVoid(tree.lhs.pos(), attribExpr(tree.lhs, env));
3786         // x &amp;&amp; y
3787         // include x&#39;s bindings when true in y
3788 
3789         // x || y
3790         // include x&#39;s bindings when false in y
3791 
3792         MatchBindings lhsBindings = matchBindings;
3793         List&lt;BindingSymbol&gt; propagatedBindings;
3794         switch (tree.getTag()) {
3795             case AND:
3796                 propagatedBindings = lhsBindings.bindingsWhenTrue;
3797                 break;
3798             case OR:
3799                 propagatedBindings = lhsBindings.bindingsWhenFalse;
3800                 break;
3801             default:
3802                 propagatedBindings = List.nil();
3803                 break;
3804         }
3805         Env&lt;AttrContext&gt; rhsEnv = bindingEnv(env, propagatedBindings);
3806         Type right;
3807         try {
3808             right = chk.checkNonVoid(tree.rhs.pos(), attribExpr(tree.rhs, rhsEnv));
3809         } finally {
3810             rhsEnv.info.scope.leave();
3811         }
3812 
3813         matchBindings = matchBindingsComputer.binary(tree, lhsBindings, matchBindings);
3814 
3815         // Find operator.
3816         Symbol operator = tree.operator = operators.resolveBinary(tree, tree.getTag(), left, right);
3817         Type owntype = types.createErrorType(tree.type);
3818         if (operator != operators.noOpSymbol &amp;&amp;
3819                 !left.isErroneous() &amp;&amp;
3820                 !right.isErroneous()) {
3821             owntype = operator.type.getReturnType();
3822             int opc = ((OperatorSymbol)operator).opcode;
3823             // If both arguments are constants, fold them.
3824             if (left.constValue() != null &amp;&amp; right.constValue() != null) {
3825                 Type ctype = cfolder.fold2(opc, left, right);
3826                 if (ctype != null) {
3827                     owntype = cfolder.coerce(ctype, owntype);
3828                 }
3829             }
3830 
3831             // Check that argument types of a reference ==, != are
3832             // castable to each other, (JLS 15.21).  Note: unboxing
3833             // comparisons will not have an acmp* opc at this point.
3834             if ((opc == ByteCodes.if_acmpeq || opc == ByteCodes.if_acmpne)) {
3835                 if (!types.isCastable(left, right, new Warner(tree.pos()))) {
3836                     log.error(tree.pos(), Errors.IncomparableTypes(left, right));
3837                 }
3838             }
3839 
3840             chk.checkDivZero(tree.rhs.pos(), operator, right);
3841         }
3842         result = check(tree, owntype, KindSelector.VAL, resultInfo);
3843     }
3844 
3845     public void visitTypeCast(final JCTypeCast tree) {
3846         Type clazztype = attribType(tree.clazz, env);
3847         chk.validate(tree.clazz, env, false);
3848         //a fresh environment is required for 292 inference to work properly ---
3849         //see Infer.instantiatePolymorphicSignatureInstance()
3850         Env&lt;AttrContext&gt; localEnv = env.dup(tree);
3851         //should we propagate the target type?
3852         final ResultInfo castInfo;
3853         JCExpression expr = TreeInfo.skipParens(tree.expr);
3854         boolean isPoly = allowPoly &amp;&amp; (expr.hasTag(LAMBDA) || expr.hasTag(REFERENCE));
3855         if (isPoly) {
3856             //expression is a poly - we need to propagate target type info
3857             castInfo = new ResultInfo(KindSelector.VAL, clazztype,
3858                                       new Check.NestedCheckContext(resultInfo.checkContext) {
3859                 @Override
3860                 public boolean compatible(Type found, Type req, Warner warn) {
3861                     return types.isCastable(found, req, warn);
3862                 }
3863             });
3864         } else {
3865             //standalone cast - target-type info is not propagated
3866             castInfo = unknownExprInfo;
3867         }
3868         Type exprtype = attribTree(tree.expr, localEnv, castInfo);
3869         Type owntype = isPoly ? clazztype : chk.checkCastable(tree.expr.pos(), exprtype, clazztype);
3870         if (exprtype.constValue() != null)
3871             owntype = cfolder.coerce(exprtype, owntype);
3872         result = check(tree, capture(owntype), KindSelector.VAL, resultInfo);
3873         if (!isPoly)
3874             chk.checkRedundantCast(localEnv, tree);
3875     }
3876 
3877     public void visitTypeTest(JCInstanceOf tree) {
3878         Type exprtype = chk.checkNullOrRefType(
3879                 tree.expr.pos(), attribExpr(tree.expr, env));
3880         Type clazztype;
3881         JCTree typeTree;
3882         if (tree.pattern.getTag() == BINDINGPATTERN) {
3883             attribTree(tree.pattern, env, unknownExprInfo);
3884             clazztype = tree.pattern.type;
3885             JCBindingPattern pattern = (JCBindingPattern) tree.pattern;
3886             typeTree = pattern.vartype;
3887             if (!clazztype.hasTag(TYPEVAR)) {
3888                 clazztype = chk.checkClassOrArrayType(pattern.vartype.pos(), clazztype);
3889             }
3890         } else {
3891             clazztype = attribType(tree.pattern, env);
3892             typeTree = tree.pattern;
3893         }
3894         if (!clazztype.hasTag(TYPEVAR)) {
3895             clazztype = chk.checkClassOrArrayType(typeTree.pos(), clazztype);
3896         }
3897         if (!clazztype.isErroneous() &amp;&amp; !types.isReifiable(clazztype)) {
3898             boolean valid = false;
3899             if (allowReifiableTypesInInstanceof) {
3900                 if (preview.isPreview(Feature.REIFIABLE_TYPES_INSTANCEOF)) {
3901                     preview.warnPreview(tree.expr.pos(), Feature.REIFIABLE_TYPES_INSTANCEOF);
3902                 }
3903                 Warner warner = new Warner();
3904                 if (!types.isCastable(exprtype, clazztype, warner)) {
3905                     chk.basicHandler.report(tree.expr.pos(),
3906                                             diags.fragment(Fragments.InconvertibleTypes(exprtype, clazztype)));
3907                 } else if (warner.hasLint(LintCategory.UNCHECKED)) {
3908                     log.error(tree.expr.pos(),
3909                               Errors.InstanceofReifiableNotSafe(exprtype, clazztype));
3910                 } else {
3911                     valid = true;
3912                 }
3913             } else {
3914                 log.error(typeTree.pos(), Errors.IllegalGenericTypeForInstof);
3915             }
3916             if (!valid) {
3917                 clazztype = types.createErrorType(clazztype);
3918             }
3919         }
3920         chk.validate(typeTree, env, false);
3921         chk.checkCastable(tree.expr.pos(), exprtype, clazztype);
3922         result = check(tree, syms.booleanType, KindSelector.VAL, resultInfo);
3923     }
3924 
3925     public void visitBindingPattern(JCBindingPattern tree) {
3926         ResultInfo varInfo = new ResultInfo(KindSelector.TYP, resultInfo.pt, resultInfo.checkContext);
3927         tree.type = attribTree(tree.vartype, env, varInfo);
3928         VarSymbol v = tree.symbol = new BindingSymbol(tree.name, tree.vartype.type, env.info.scope.owner);
3929         if (chk.checkUnique(tree.pos(), v, env.info.scope)) {
3930             chk.checkTransparentVar(tree.pos(), v, env.info.scope);
3931         }
3932         annotate.queueScanTreeAndTypeAnnotate(tree.vartype, env, v, tree.pos());
3933         annotate.flush();
3934         result = tree.type;
3935         matchBindings = new MatchBindings(List.of(tree.symbol), List.nil());
3936     }
3937 
3938     public void visitIndexed(JCArrayAccess tree) {
3939         Type owntype = types.createErrorType(tree.type);
3940         Type atype = attribExpr(tree.indexed, env);
3941         attribExpr(tree.index, env, syms.intType);
3942         if (types.isArray(atype))
3943             owntype = types.elemtype(atype);
3944         else if (!atype.hasTag(ERROR))
3945             log.error(tree.pos(), Errors.ArrayReqButFound(atype));
3946         if (!pkind().contains(KindSelector.VAL))
3947             owntype = capture(owntype);
3948         result = check(tree, owntype, KindSelector.VAR, resultInfo);
3949     }
3950 
3951     public void visitIdent(JCIdent tree) {
3952         Symbol sym;
3953 
3954         // Find symbol
3955         if (pt().hasTag(METHOD) || pt().hasTag(FORALL)) {
3956             // If we are looking for a method, the prototype `pt&#39; will be a
3957             // method type with the type of the call&#39;s arguments as parameters.
3958             env.info.pendingResolutionPhase = null;
3959             sym = rs.resolveMethod(tree.pos(), env, tree.name, pt().getParameterTypes(), pt().getTypeArguments());
3960         } else if (tree.sym != null &amp;&amp; tree.sym.kind != VAR) {
3961             sym = tree.sym;
3962         } else {
3963             sym = rs.resolveIdent(tree.pos(), env, tree.name, pkind());
3964         }
3965         tree.sym = sym;
3966 
3967         // (1) Also find the environment current for the class where
3968         //     sym is defined (`symEnv&#39;).
3969         // Only for pre-tiger versions (1.4 and earlier):
3970         // (2) Also determine whether we access symbol out of an anonymous
3971         //     class in a this or super call.  This is illegal for instance
3972         //     members since such classes don&#39;t carry a this$n link.
3973         //     (`noOuterThisPath&#39;).
3974         Env&lt;AttrContext&gt; symEnv = env;
3975         boolean noOuterThisPath = false;
3976         if (env.enclClass.sym.owner.kind != PCK &amp;&amp; // we are in an inner class
3977             sym.kind.matches(KindSelector.VAL_MTH) &amp;&amp;
3978             sym.owner.kind == TYP &amp;&amp;
3979             tree.name != names._this &amp;&amp; tree.name != names._super) {
3980 
3981             // Find environment in which identifier is defined.
3982             while (symEnv.outer != null &amp;&amp;
3983                    !sym.isMemberOf(symEnv.enclClass.sym, types)) {
3984                 if ((symEnv.enclClass.sym.flags() &amp; NOOUTERTHIS) != 0)
3985                     noOuterThisPath = false;
3986                 symEnv = symEnv.outer;
3987             }
3988         }
3989 
3990         // If symbol is a variable, ...
3991         if (sym.kind == VAR) {
3992             VarSymbol v = (VarSymbol)sym;
3993 
3994             // ..., evaluate its initializer, if it has one, and check for
3995             // illegal forward reference.
3996             checkInit(tree, env, v, false);
3997 
3998             // If we are expecting a variable (as opposed to a value), check
3999             // that the variable is assignable in the current environment.
4000             if (KindSelector.ASG.subset(pkind()))
4001                 checkAssignable(tree.pos(), v, null, env);
4002         }
4003 
4004         // In a constructor body,
4005         // if symbol is a field or instance method, check that it is
4006         // not accessed before the supertype constructor is called.
4007         if ((symEnv.info.isSelfCall || noOuterThisPath) &amp;&amp;
4008             sym.kind.matches(KindSelector.VAL_MTH) &amp;&amp;
4009             sym.owner.kind == TYP &amp;&amp;
4010             (sym.flags() &amp; STATIC) == 0) {
4011             chk.earlyRefError(tree.pos(), sym.kind == VAR ?
4012                                           sym : thisSym(tree.pos(), env));
4013         }
4014         Env&lt;AttrContext&gt; env1 = env;
4015         if (sym.kind != ERR &amp;&amp; sym.kind != TYP &amp;&amp;
4016             sym.owner != null &amp;&amp; sym.owner != env1.enclClass.sym) {
4017             // If the found symbol is inaccessible, then it is
4018             // accessed through an enclosing instance.  Locate this
4019             // enclosing instance:
4020             while (env1.outer != null &amp;&amp; !rs.isAccessible(env, env1.enclClass.sym.type, sym))
4021                 env1 = env1.outer;
4022         }
4023 
4024         if (env.info.isSerializable) {
4025             chk.checkAccessFromSerializableElement(tree, env.info.isSerializableLambda);
4026         }
4027 
4028         result = checkId(tree, env1.enclClass.sym.type, sym, env, resultInfo);
4029     }
4030 
4031     public void visitSelect(JCFieldAccess tree) {
4032         // Determine the expected kind of the qualifier expression.
4033         KindSelector skind = KindSelector.NIL;
4034         if (tree.name == names._this || tree.name == names._super ||
4035                 tree.name == names._class)
4036         {
4037             skind = KindSelector.TYP;
4038         } else {
4039             if (pkind().contains(KindSelector.PCK))
4040                 skind = KindSelector.of(skind, KindSelector.PCK);
4041             if (pkind().contains(KindSelector.TYP))
4042                 skind = KindSelector.of(skind, KindSelector.TYP, KindSelector.PCK);
4043             if (pkind().contains(KindSelector.VAL_MTH))
4044                 skind = KindSelector.of(skind, KindSelector.VAL, KindSelector.TYP);
4045         }
4046 
4047         // Attribute the qualifier expression, and determine its symbol (if any).
4048         Type site = attribTree(tree.selected, env, new ResultInfo(skind, Type.noType));
4049         if (!pkind().contains(KindSelector.TYP_PCK))
4050             site = capture(site); // Capture field access
4051 
4052         // don&#39;t allow T.class T[].class, etc
4053         if (skind == KindSelector.TYP) {
4054             Type elt = site;
4055             while (elt.hasTag(ARRAY))
4056                 elt = ((ArrayType)elt).elemtype;
4057             if (elt.hasTag(TYPEVAR)) {
4058                 log.error(tree.pos(), Errors.TypeVarCantBeDeref);
4059                 result = tree.type = types.createErrorType(tree.name, site.tsym, site);
4060                 tree.sym = tree.type.tsym;
4061                 return ;
4062             }
4063         }
4064 
4065         // If qualifier symbol is a type or `super&#39;, assert `selectSuper&#39;
4066         // for the selection. This is relevant for determining whether
4067         // protected symbols are accessible.
4068         Symbol sitesym = TreeInfo.symbol(tree.selected);
4069         boolean selectSuperPrev = env.info.selectSuper;
4070         env.info.selectSuper =
4071             sitesym != null &amp;&amp;
4072             sitesym.name == names._super;
4073 
4074         // Determine the symbol represented by the selection.
4075         env.info.pendingResolutionPhase = null;
4076         Symbol sym = selectSym(tree, sitesym, site, env, resultInfo);
4077         if (sym.kind == VAR &amp;&amp; sym.name != names._super &amp;&amp; env.info.defaultSuperCallSite != null) {
4078             log.error(tree.selected.pos(), Errors.NotEnclClass(site.tsym));
4079             sym = syms.errSymbol;
4080         }
4081         if (sym.exists() &amp;&amp; !isType(sym) &amp;&amp; pkind().contains(KindSelector.TYP_PCK)) {
4082             site = capture(site);
4083             sym = selectSym(tree, sitesym, site, env, resultInfo);
4084         }
4085         boolean varArgs = env.info.lastResolveVarargs();
4086         tree.sym = sym;
4087 
4088         if (site.hasTag(TYPEVAR) &amp;&amp; !isType(sym) &amp;&amp; sym.kind != ERR) {
4089             site = types.skipTypeVars(site, true);
4090         }
4091 
4092         // If that symbol is a variable, ...
4093         if (sym.kind == VAR) {
4094             VarSymbol v = (VarSymbol)sym;
4095 
4096             // ..., evaluate its initializer, if it has one, and check for
4097             // illegal forward reference.
4098             checkInit(tree, env, v, true);
4099 
4100             // If we are expecting a variable (as opposed to a value), check
4101             // that the variable is assignable in the current environment.
4102             if (KindSelector.ASG.subset(pkind()))
4103                 checkAssignable(tree.pos(), v, tree.selected, env);
4104         }
4105 
4106         if (sitesym != null &amp;&amp;
4107                 sitesym.kind == VAR &amp;&amp;
4108                 ((VarSymbol)sitesym).isResourceVariable() &amp;&amp;
4109                 sym.kind == MTH &amp;&amp;
4110                 sym.name.equals(names.close) &amp;&amp;
4111                 sym.overrides(syms.autoCloseableClose, sitesym.type.tsym, types, true) &amp;&amp;
4112                 env.info.lint.isEnabled(LintCategory.TRY)) {
4113             log.warning(LintCategory.TRY, tree, Warnings.TryExplicitCloseCall);
4114         }
4115 
4116         // Disallow selecting a type from an expression
4117         if (isType(sym) &amp;&amp; (sitesym == null || !sitesym.kind.matches(KindSelector.TYP_PCK))) {
4118             tree.type = check(tree.selected, pt(),
4119                               sitesym == null ?
4120                                       KindSelector.VAL : sitesym.kind.toSelector(),
4121                               new ResultInfo(KindSelector.TYP_PCK, pt()));
4122         }
4123 
4124         if (isType(sitesym)) {
4125             if (sym.name == names._this) {
4126                 // If `C&#39; is the currently compiled class, check that
4127                 // C.this&#39; does not appear in a call to a super(...)
4128                 if (env.info.isSelfCall &amp;&amp;
4129                     site.tsym == env.enclClass.sym) {
4130                     chk.earlyRefError(tree.pos(), sym);
4131                 }
4132             } else {
4133                 // Check if type-qualified fields or methods are static (JLS)
4134                 if ((sym.flags() &amp; STATIC) == 0 &amp;&amp;
4135                     sym.name != names._super &amp;&amp;
4136                     (sym.kind == VAR || sym.kind == MTH)) {
4137                     rs.accessBase(rs.new StaticError(sym),
4138                               tree.pos(), site, sym.name, true);
4139                 }
4140             }
4141             if (!allowStaticInterfaceMethods &amp;&amp; sitesym.isInterface() &amp;&amp;
4142                     sym.isStatic() &amp;&amp; sym.kind == MTH) {
4143                 log.error(DiagnosticFlag.SOURCE_LEVEL, tree.pos(), Feature.STATIC_INTERFACE_METHODS_INVOKE.error(sourceName));
4144             }
4145         } else if (sym.kind != ERR &amp;&amp;
4146                    (sym.flags() &amp; STATIC) != 0 &amp;&amp;
4147                    sym.name != names._class) {
4148             // If the qualified item is not a type and the selected item is static, report
4149             // a warning. Make allowance for the class of an array type e.g. Object[].class)
4150             chk.warnStatic(tree, Warnings.StaticNotQualifiedByType(sym.kind.kindName(), sym.owner));
4151         }
4152 
4153         // If we are selecting an instance member via a `super&#39;, ...
4154         if (env.info.selectSuper &amp;&amp; (sym.flags() &amp; STATIC) == 0) {
4155 
4156             // Check that super-qualified symbols are not abstract (JLS)
4157             rs.checkNonAbstract(tree.pos(), sym);
4158 
4159             if (site.isRaw()) {
4160                 // Determine argument types for site.
4161                 Type site1 = types.asSuper(env.enclClass.sym.type, site.tsym);
4162                 if (site1 != null) site = site1;
4163             }
4164         }
4165 
4166         if (env.info.isSerializable) {
4167             chk.checkAccessFromSerializableElement(tree, env.info.isSerializableLambda);
4168         }
4169 
4170         env.info.selectSuper = selectSuperPrev;
4171         result = checkId(tree, site, sym, env, resultInfo);
4172     }
4173     //where
4174         /** Determine symbol referenced by a Select expression,
4175          *
4176          *  @param tree   The select tree.
4177          *  @param site   The type of the selected expression,
4178          *  @param env    The current environment.
4179          *  @param resultInfo The current result.
4180          */
4181         private Symbol selectSym(JCFieldAccess tree,
4182                                  Symbol location,
4183                                  Type site,
4184                                  Env&lt;AttrContext&gt; env,
4185                                  ResultInfo resultInfo) {
4186             DiagnosticPosition pos = tree.pos();
4187             Name name = tree.name;
4188             switch (site.getTag()) {
4189             case PACKAGE:
4190                 return rs.accessBase(
4191                     rs.findIdentInPackage(pos, env, site.tsym, name, resultInfo.pkind),
4192                     pos, location, site, name, true);
4193             case ARRAY:
4194             case CLASS:
4195                 if (resultInfo.pt.hasTag(METHOD) || resultInfo.pt.hasTag(FORALL)) {
4196                     return rs.resolveQualifiedMethod(
4197                         pos, env, location, site, name, resultInfo.pt.getParameterTypes(), resultInfo.pt.getTypeArguments());
4198                 } else if (name == names._this || name == names._super) {
4199                     return rs.resolveSelf(pos, env, site.tsym, name);
4200                 } else if (name == names._class) {
4201                     // In this case, we have already made sure in
4202                     // visitSelect that qualifier expression is a type.
4203                     return syms.getClassField(site, types);
4204                 } else {
4205                     // We are seeing a plain identifier as selector.
4206                     Symbol sym = rs.findIdentInType(pos, env, site, name, resultInfo.pkind);
4207                         sym = rs.accessBase(sym, pos, location, site, name, true);
4208                     return sym;
4209                 }
4210             case WILDCARD:
4211                 throw new AssertionError(tree);
4212             case TYPEVAR:
4213                 // Normally, site.getUpperBound() shouldn&#39;t be null.
4214                 // It should only happen during memberEnter/attribBase
4215                 // when determining the super type which *must* be
4216                 // done before attributing the type variables.  In
4217                 // other words, we are seeing this illegal program:
4218                 // class B&lt;T&gt; extends A&lt;T.foo&gt; {}
4219                 Symbol sym = (site.getUpperBound() != null)
4220                     ? selectSym(tree, location, capture(site.getUpperBound()), env, resultInfo)
4221                     : null;
4222                 if (sym == null) {
4223                     log.error(pos, Errors.TypeVarCantBeDeref);
4224                     return syms.errSymbol;
4225                 } else {
4226                     Symbol sym2 = (sym.flags() &amp; Flags.PRIVATE) != 0 ?
4227                         rs.new AccessError(env, site, sym) :
4228                                 sym;
4229                     rs.accessBase(sym2, pos, location, site, name, true);
4230                     return sym;
4231                 }
4232             case ERROR:
4233                 // preserve identifier names through errors
4234                 return types.createErrorType(name, site.tsym, site).tsym;
4235             default:
4236                 // The qualifier expression is of a primitive type -- only
4237                 // .class is allowed for these.
4238                 if (name == names._class) {
4239                     // In this case, we have already made sure in Select that
4240                     // qualifier expression is a type.
4241                     return syms.getClassField(site, types);
4242                 } else {
4243                     log.error(pos, Errors.CantDeref(site));
4244                     return syms.errSymbol;
4245                 }
4246             }
4247         }
4248 
4249         /** Determine type of identifier or select expression and check that
4250          *  (1) the referenced symbol is not deprecated
4251          *  (2) the symbol&#39;s type is safe (@see checkSafe)
4252          *  (3) if symbol is a variable, check that its type and kind are
4253          *      compatible with the prototype and protokind.
4254          *  (4) if symbol is an instance field of a raw type,
4255          *      which is being assigned to, issue an unchecked warning if its
4256          *      type changes under erasure.
4257          *  (5) if symbol is an instance method of a raw type, issue an
4258          *      unchecked warning if its argument types change under erasure.
4259          *  If checks succeed:
4260          *    If symbol is a constant, return its constant type
4261          *    else if symbol is a method, return its result type
4262          *    otherwise return its type.
4263          *  Otherwise return errType.
4264          *
4265          *  @param tree       The syntax tree representing the identifier
4266          *  @param site       If this is a select, the type of the selected
4267          *                    expression, otherwise the type of the current class.
4268          *  @param sym        The symbol representing the identifier.
4269          *  @param env        The current environment.
4270          *  @param resultInfo    The expected result
4271          */
4272         Type checkId(JCTree tree,
4273                      Type site,
4274                      Symbol sym,
4275                      Env&lt;AttrContext&gt; env,
4276                      ResultInfo resultInfo) {
4277             return (resultInfo.pt.hasTag(FORALL) || resultInfo.pt.hasTag(METHOD)) ?
4278                     checkMethodIdInternal(tree, site, sym, env, resultInfo) :
4279                     checkIdInternal(tree, site, sym, resultInfo.pt, env, resultInfo);
4280         }
4281 
4282         Type checkMethodIdInternal(JCTree tree,
4283                      Type site,
4284                      Symbol sym,
4285                      Env&lt;AttrContext&gt; env,
4286                      ResultInfo resultInfo) {
4287             if (resultInfo.pkind.contains(KindSelector.POLY)) {
4288                 Type pt = resultInfo.pt.map(deferredAttr.new RecoveryDeferredTypeMap(AttrMode.SPECULATIVE, sym, env.info.pendingResolutionPhase));
4289                 Type owntype = checkIdInternal(tree, site, sym, pt, env, resultInfo);
4290                 resultInfo.pt.map(deferredAttr.new RecoveryDeferredTypeMap(AttrMode.CHECK, sym, env.info.pendingResolutionPhase));
4291                 return owntype;
4292             } else {
4293                 return checkIdInternal(tree, site, sym, resultInfo.pt, env, resultInfo);
4294             }
4295         }
4296 
4297         Type checkIdInternal(JCTree tree,
4298                      Type site,
4299                      Symbol sym,
4300                      Type pt,
4301                      Env&lt;AttrContext&gt; env,
4302                      ResultInfo resultInfo) {
4303             if (pt.isErroneous()) {
4304                 return types.createErrorType(site);
4305             }
4306             Type owntype; // The computed type of this identifier occurrence.
4307             switch (sym.kind) {
4308             case TYP:
4309                 // For types, the computed type equals the symbol&#39;s type,
4310                 // except for two situations:
4311                 owntype = sym.type;
4312                 if (owntype.hasTag(CLASS)) {
4313                     chk.checkForBadAuxiliaryClassAccess(tree.pos(), env, (ClassSymbol)sym);
4314                     Type ownOuter = owntype.getEnclosingType();
4315 
4316                     // (a) If the symbol&#39;s type is parameterized, erase it
4317                     // because no type parameters were given.
4318                     // We recover generic outer type later in visitTypeApply.
4319                     if (owntype.tsym.type.getTypeArguments().nonEmpty()) {
4320                         owntype = types.erasure(owntype);
4321                     }
4322 
4323                     // (b) If the symbol&#39;s type is an inner class, then
4324                     // we have to interpret its outer type as a superclass
4325                     // of the site type. Example:
4326                     //
4327                     // class Tree&lt;A&gt; { class Visitor { ... } }
4328                     // class PointTree extends Tree&lt;Point&gt; { ... }
4329                     // ...PointTree.Visitor...
4330                     //
4331                     // Then the type of the last expression above is
4332                     // Tree&lt;Point&gt;.Visitor.
4333                     else if (ownOuter.hasTag(CLASS) &amp;&amp; site != ownOuter) {
4334                         Type normOuter = site;
4335                         if (normOuter.hasTag(CLASS)) {
4336                             normOuter = types.asEnclosingSuper(site, ownOuter.tsym);
4337                         }
4338                         if (normOuter == null) // perhaps from an import
4339                             normOuter = types.erasure(ownOuter);
4340                         if (normOuter != ownOuter)
4341                             owntype = new ClassType(
4342                                 normOuter, List.nil(), owntype.tsym,
4343                                 owntype.getMetadata());
4344                     }
4345                 }
4346                 break;
4347             case VAR:
4348                 VarSymbol v = (VarSymbol)sym;
4349 
4350                 if (env.info.enclVar != null
4351                         &amp;&amp; v.type.hasTag(NONE)) {
4352                     //self reference to implicitly typed variable declaration
4353                     log.error(TreeInfo.positionFor(v, env.enclClass), Errors.CantInferLocalVarType(v.name, Fragments.LocalSelfRef));
4354                     return v.type = types.createErrorType(v.type);
4355                 }
4356 
4357                 // Test (4): if symbol is an instance field of a raw type,
4358                 // which is being assigned to, issue an unchecked warning if
4359                 // its type changes under erasure.
4360                 if (KindSelector.ASG.subset(pkind()) &amp;&amp;
4361                     v.owner.kind == TYP &amp;&amp;
4362                     (v.flags() &amp; STATIC) == 0 &amp;&amp;
4363                     (site.hasTag(CLASS) || site.hasTag(TYPEVAR))) {
4364                     Type s = types.asOuterSuper(site, v.owner);
4365                     if (s != null &amp;&amp;
4366                         s.isRaw() &amp;&amp;
4367                         !types.isSameType(v.type, v.erasure(types))) {
4368                         chk.warnUnchecked(tree.pos(), Warnings.UncheckedAssignToVar(v, s));
4369                     }
4370                 }
4371                 // The computed type of a variable is the type of the
4372                 // variable symbol, taken as a member of the site type.
4373                 owntype = (sym.owner.kind == TYP &amp;&amp;
4374                            sym.name != names._this &amp;&amp; sym.name != names._super)
4375                     ? types.memberType(site, sym)
4376                     : sym.type;
4377 
4378                 // If the variable is a constant, record constant value in
4379                 // computed type.
4380                 if (v.getConstValue() != null &amp;&amp; isStaticReference(tree))
4381                     owntype = owntype.constType(v.getConstValue());
4382 
4383                 if (resultInfo.pkind == KindSelector.VAL) {
4384                     owntype = capture(owntype); // capture &quot;names as expressions&quot;
4385                 }
4386                 break;
4387             case MTH: {
4388                 owntype = checkMethod(site, sym,
4389                         new ResultInfo(resultInfo.pkind, resultInfo.pt.getReturnType(), resultInfo.checkContext, resultInfo.checkMode),
4390                         env, TreeInfo.args(env.tree), resultInfo.pt.getParameterTypes(),
4391                         resultInfo.pt.getTypeArguments());
4392                 break;
4393             }
4394             case PCK: case ERR:
4395                 owntype = sym.type;
4396                 break;
4397             default:
4398                 throw new AssertionError(&quot;unexpected kind: &quot; + sym.kind +
4399                                          &quot; in tree &quot; + tree);
4400             }
4401 
4402             // Emit a `deprecation&#39; warning if symbol is deprecated.
4403             // (for constructors (but not for constructor references), the error
4404             // was given when the constructor was resolved)
4405 
4406             if (sym.name != names.init || tree.hasTag(REFERENCE)) {
4407                 chk.checkDeprecated(tree.pos(), env.info.scope.owner, sym);
4408                 chk.checkSunAPI(tree.pos(), sym);
4409                 chk.checkProfile(tree.pos(), sym);
4410                 chk.checkPreview(tree.pos(), sym);
4411             }
4412 
4413             // If symbol is a variable, check that its type and
4414             // kind are compatible with the prototype and protokind.
4415             return check(tree, owntype, sym.kind.toSelector(), resultInfo);
4416         }
4417 
4418         /** Check that variable is initialized and evaluate the variable&#39;s
4419          *  initializer, if not yet done. Also check that variable is not
4420          *  referenced before it is defined.
4421          *  @param tree    The tree making up the variable reference.
4422          *  @param env     The current environment.
4423          *  @param v       The variable&#39;s symbol.
4424          */
4425         private void checkInit(JCTree tree,
4426                                Env&lt;AttrContext&gt; env,
4427                                VarSymbol v,
4428                                boolean onlyWarning) {
4429             // A forward reference is diagnosed if the declaration position
4430             // of the variable is greater than the current tree position
4431             // and the tree and variable definition occur in the same class
4432             // definition.  Note that writes don&#39;t count as references.
4433             // This check applies only to class and instance
4434             // variables.  Local variables follow different scope rules,
4435             // and are subject to definite assignment checking.
4436             Env&lt;AttrContext&gt; initEnv = enclosingInitEnv(env);
4437             if (initEnv != null &amp;&amp;
4438                 (initEnv.info.enclVar == v || v.pos &gt; tree.pos) &amp;&amp;
4439                 v.owner.kind == TYP &amp;&amp;
4440                 v.owner == env.info.scope.owner.enclClass() &amp;&amp;
4441                 ((v.flags() &amp; STATIC) != 0) == Resolve.isStatic(env) &amp;&amp;
4442                 (!env.tree.hasTag(ASSIGN) ||
4443                  TreeInfo.skipParens(((JCAssign) env.tree).lhs) != tree)) {
4444                 if (!onlyWarning || isStaticEnumField(v)) {
4445                     Error errkey = (initEnv.info.enclVar == v) ?
4446                                 Errors.IllegalSelfRef : Errors.IllegalForwardRef;
4447                     log.error(tree.pos(), errkey);
4448                 } else if (useBeforeDeclarationWarning) {
4449                     Warning warnkey = (initEnv.info.enclVar == v) ?
4450                                 Warnings.SelfRef(v) : Warnings.ForwardRef(v);
4451                     log.warning(tree.pos(), warnkey);
4452                 }
4453             }
4454 
4455             v.getConstValue(); // ensure initializer is evaluated
4456 
4457             checkEnumInitializer(tree, env, v);
4458         }
4459 
4460         /**
4461          * Returns the enclosing init environment associated with this env (if any). An init env
4462          * can be either a field declaration env or a static/instance initializer env.
4463          */
4464         Env&lt;AttrContext&gt; enclosingInitEnv(Env&lt;AttrContext&gt; env) {
4465             while (true) {
4466                 switch (env.tree.getTag()) {
4467                     case VARDEF:
4468                         JCVariableDecl vdecl = (JCVariableDecl)env.tree;
4469                         if (vdecl.sym.owner.kind == TYP) {
4470                             //field
4471                             return env;
4472                         }
4473                         break;
4474                     case BLOCK:
4475                         if (env.next.tree.hasTag(CLASSDEF)) {
4476                             //instance/static initializer
4477                             return env;
4478                         }
4479                         break;
4480                     case METHODDEF:
4481                     case CLASSDEF:
4482                     case TOPLEVEL:
4483                         return null;
4484                 }
4485                 Assert.checkNonNull(env.next);
4486                 env = env.next;
4487             }
4488         }
4489 
4490         /**
4491          * Check for illegal references to static members of enum.  In
4492          * an enum type, constructors and initializers may not
4493          * reference its static members unless they are constant.
4494          *
4495          * @param tree    The tree making up the variable reference.
4496          * @param env     The current environment.
4497          * @param v       The variable&#39;s symbol.
4498          * @jls 8.9 Enum Types
4499          */
4500         private void checkEnumInitializer(JCTree tree, Env&lt;AttrContext&gt; env, VarSymbol v) {
4501             // JLS:
4502             //
4503             // &quot;It is a compile-time error to reference a static field
4504             // of an enum type that is not a compile-time constant
4505             // (15.28) from constructors, instance initializer blocks,
4506             // or instance variable initializer expressions of that
4507             // type. It is a compile-time error for the constructors,
4508             // instance initializer blocks, or instance variable
4509             // initializer expressions of an enum constant e to refer
4510             // to itself or to an enum constant of the same type that
4511             // is declared to the right of e.&quot;
4512             if (isStaticEnumField(v)) {
4513                 ClassSymbol enclClass = env.info.scope.owner.enclClass();
4514 
4515                 if (enclClass == null || enclClass.owner == null)
4516                     return;
4517 
4518                 // See if the enclosing class is the enum (or a
4519                 // subclass thereof) declaring v.  If not, this
4520                 // reference is OK.
4521                 if (v.owner != enclClass &amp;&amp; !types.isSubtype(enclClass.type, v.owner.type))
4522                     return;
4523 
4524                 // If the reference isn&#39;t from an initializer, then
4525                 // the reference is OK.
4526                 if (!Resolve.isInitializer(env))
4527                     return;
4528 
4529                 log.error(tree.pos(), Errors.IllegalEnumStaticRef);
4530             }
4531         }
4532 
4533         /** Is the given symbol a static, non-constant field of an Enum?
4534          *  Note: enum literals should not be regarded as such
4535          */
4536         private boolean isStaticEnumField(VarSymbol v) {
4537             return Flags.isEnum(v.owner) &amp;&amp;
4538                    Flags.isStatic(v) &amp;&amp;
4539                    !Flags.isConstant(v) &amp;&amp;
4540                    v.name != names._class;
4541         }
4542 
4543     /**
4544      * Check that method arguments conform to its instantiation.
4545      **/
4546     public Type checkMethod(Type site,
4547                             final Symbol sym,
4548                             ResultInfo resultInfo,
4549                             Env&lt;AttrContext&gt; env,
4550                             final List&lt;JCExpression&gt; argtrees,
4551                             List&lt;Type&gt; argtypes,
4552                             List&lt;Type&gt; typeargtypes) {
4553         // Test (5): if symbol is an instance method of a raw type, issue
4554         // an unchecked warning if its argument types change under erasure.
4555         if ((sym.flags() &amp; STATIC) == 0 &amp;&amp;
4556             (site.hasTag(CLASS) || site.hasTag(TYPEVAR))) {
4557             Type s = types.asOuterSuper(site, sym.owner);
4558             if (s != null &amp;&amp; s.isRaw() &amp;&amp;
4559                 !types.isSameTypes(sym.type.getParameterTypes(),
4560                                    sym.erasure(types).getParameterTypes())) {
4561                 chk.warnUnchecked(env.tree.pos(), Warnings.UncheckedCallMbrOfRawType(sym, s));
4562             }
4563         }
4564 
4565         if (env.info.defaultSuperCallSite != null) {
4566             for (Type sup : types.interfaces(env.enclClass.type).prepend(types.supertype((env.enclClass.type)))) {
4567                 if (!sup.tsym.isSubClass(sym.enclClass(), types) ||
4568                         types.isSameType(sup, env.info.defaultSuperCallSite)) continue;
4569                 List&lt;MethodSymbol&gt; icand_sup =
4570                         types.interfaceCandidates(sup, (MethodSymbol)sym);
4571                 if (icand_sup.nonEmpty() &amp;&amp;
4572                         icand_sup.head != sym &amp;&amp;
4573                         icand_sup.head.overrides(sym, icand_sup.head.enclClass(), types, true)) {
4574                     log.error(env.tree.pos(),
4575                               Errors.IllegalDefaultSuperCall(env.info.defaultSuperCallSite, Fragments.OverriddenDefault(sym, sup)));
4576                     break;
4577                 }
4578             }
4579             env.info.defaultSuperCallSite = null;
4580         }
4581 
4582         if (sym.isStatic() &amp;&amp; site.isInterface() &amp;&amp; env.tree.hasTag(APPLY)) {
4583             JCMethodInvocation app = (JCMethodInvocation)env.tree;
4584             if (app.meth.hasTag(SELECT) &amp;&amp;
4585                     !TreeInfo.isStaticSelector(((JCFieldAccess)app.meth).selected, names)) {
4586                 log.error(env.tree.pos(), Errors.IllegalStaticIntfMethCall(site));
4587             }
4588         }
4589 
4590         // Compute the identifier&#39;s instantiated type.
4591         // For methods, we need to compute the instance type by
4592         // Resolve.instantiate from the symbol&#39;s type as well as
4593         // any type arguments and value arguments.
4594         Warner noteWarner = new Warner();
4595         try {
4596             Type owntype = rs.checkMethod(
4597                     env,
4598                     site,
4599                     sym,
4600                     resultInfo,
4601                     argtypes,
4602                     typeargtypes,
4603                     noteWarner);
4604 
4605             DeferredAttr.DeferredTypeMap&lt;Void&gt; checkDeferredMap =
4606                 deferredAttr.new DeferredTypeMap&lt;&gt;(DeferredAttr.AttrMode.CHECK, sym, env.info.pendingResolutionPhase);
4607 
4608             argtypes = argtypes.map(checkDeferredMap);
4609 
4610             if (noteWarner.hasNonSilentLint(LintCategory.UNCHECKED)) {
4611                 chk.warnUnchecked(env.tree.pos(), Warnings.UncheckedMethInvocationApplied(kindName(sym),
4612                         sym.name,
4613                         rs.methodArguments(sym.type.getParameterTypes()),
4614                         rs.methodArguments(argtypes.map(checkDeferredMap)),
4615                         kindName(sym.location()),
4616                         sym.location()));
4617                 if (resultInfo.pt != Infer.anyPoly ||
4618                         !owntype.hasTag(METHOD) ||
4619                         !owntype.isPartial()) {
4620                     //if this is not a partially inferred method type, erase return type. Otherwise,
4621                     //erasure is carried out in PartiallyInferredMethodType.check().
4622                     owntype = new MethodType(owntype.getParameterTypes(),
4623                             types.erasure(owntype.getReturnType()),
4624                             types.erasure(owntype.getThrownTypes()),
4625                             syms.methodClass);
4626                 }
4627             }
4628 
4629             PolyKind pkind = (sym.type.hasTag(FORALL) &amp;&amp;
4630                  sym.type.getReturnType().containsAny(((ForAll)sym.type).tvars)) ?
4631                  PolyKind.POLY : PolyKind.STANDALONE;
4632             TreeInfo.setPolyKind(env.tree, pkind);
4633 
4634             return (resultInfo.pt == Infer.anyPoly) ?
4635                     owntype :
4636                     chk.checkMethod(owntype, sym, env, argtrees, argtypes, env.info.lastResolveVarargs(),
4637                             resultInfo.checkContext.inferenceContext());
4638         } catch (Infer.InferenceException ex) {
4639             //invalid target type - propagate exception outwards or report error
4640             //depending on the current check context
4641             resultInfo.checkContext.report(env.tree.pos(), ex.getDiagnostic());
4642             return types.createErrorType(site);
4643         } catch (Resolve.InapplicableMethodException ex) {
4644             final JCDiagnostic diag = ex.getDiagnostic();
4645             Resolve.InapplicableSymbolError errSym = rs.new InapplicableSymbolError(null) {
4646                 @Override
4647                 protected Pair&lt;Symbol, JCDiagnostic&gt; errCandidate() {
4648                     return new Pair&lt;&gt;(sym, diag);
4649                 }
4650             };
4651             List&lt;Type&gt; argtypes2 = argtypes.map(
4652                     rs.new ResolveDeferredRecoveryMap(AttrMode.CHECK, sym, env.info.pendingResolutionPhase));
4653             JCDiagnostic errDiag = errSym.getDiagnostic(JCDiagnostic.DiagnosticType.ERROR,
4654                     env.tree, sym, site, sym.name, argtypes2, typeargtypes);
4655             log.report(errDiag);
4656             return types.createErrorType(site);
4657         }
4658     }
4659 
4660     public void visitLiteral(JCLiteral tree) {
4661         result = check(tree, litType(tree.typetag).constType(tree.value),
4662                 KindSelector.VAL, resultInfo);
4663     }
4664     //where
4665     /** Return the type of a literal with given type tag.
4666      */
4667     Type litType(TypeTag tag) {
4668         return (tag == CLASS) ? syms.stringType : syms.typeOfTag[tag.ordinal()];
4669     }
4670 
4671     public void visitTypeIdent(JCPrimitiveTypeTree tree) {
4672         result = check(tree, syms.typeOfTag[tree.typetag.ordinal()], KindSelector.TYP, resultInfo);
4673     }
4674 
4675     public void visitTypeArray(JCArrayTypeTree tree) {
4676         Type etype = attribType(tree.elemtype, env);
4677         Type type = new ArrayType(etype, syms.arrayClass);
4678         result = check(tree, type, KindSelector.TYP, resultInfo);
4679     }
4680 
4681     /** Visitor method for parameterized types.
4682      *  Bound checking is left until later, since types are attributed
4683      *  before supertype structure is completely known
4684      */
4685     public void visitTypeApply(JCTypeApply tree) {
4686         Type owntype = types.createErrorType(tree.type);
4687 
4688         // Attribute functor part of application and make sure it&#39;s a class.
4689         Type clazztype = chk.checkClassType(tree.clazz.pos(), attribType(tree.clazz, env));
4690 
4691         // Attribute type parameters
4692         List&lt;Type&gt; actuals = attribTypes(tree.arguments, env);
4693 
4694         if (clazztype.hasTag(CLASS)) {
4695             List&lt;Type&gt; formals = clazztype.tsym.type.getTypeArguments();
4696             if (actuals.isEmpty()) //diamond
4697                 actuals = formals;
4698 
4699             if (actuals.length() == formals.length()) {
4700                 List&lt;Type&gt; a = actuals;
4701                 List&lt;Type&gt; f = formals;
4702                 while (a.nonEmpty()) {
4703                     a.head = a.head.withTypeVar(f.head);
4704                     a = a.tail;
4705                     f = f.tail;
4706                 }
4707                 // Compute the proper generic outer
4708                 Type clazzOuter = clazztype.getEnclosingType();
4709                 if (clazzOuter.hasTag(CLASS)) {
4710                     Type site;
4711                     JCExpression clazz = TreeInfo.typeIn(tree.clazz);
4712                     if (clazz.hasTag(IDENT)) {
4713                         site = env.enclClass.sym.type;
4714                     } else if (clazz.hasTag(SELECT)) {
4715                         site = ((JCFieldAccess) clazz).selected.type;
4716                     } else throw new AssertionError(&quot;&quot;+tree);
4717                     if (clazzOuter.hasTag(CLASS) &amp;&amp; site != clazzOuter) {
4718                         if (site.hasTag(CLASS))
4719                             site = types.asOuterSuper(site, clazzOuter.tsym);
4720                         if (site == null)
4721                             site = types.erasure(clazzOuter);
4722                         clazzOuter = site;
4723                     }
4724                 }
4725                 owntype = new ClassType(clazzOuter, actuals, clazztype.tsym,
4726                                         clazztype.getMetadata());
4727             } else {
4728                 if (formals.length() != 0) {
4729                     log.error(tree.pos(),
4730                               Errors.WrongNumberTypeArgs(Integer.toString(formals.length())));
4731                 } else {
4732                     log.error(tree.pos(), Errors.TypeDoesntTakeParams(clazztype.tsym));
4733                 }
4734                 owntype = types.createErrorType(tree.type);
4735             }
4736         }
4737         result = check(tree, owntype, KindSelector.TYP, resultInfo);
4738     }
4739 
4740     public void visitTypeUnion(JCTypeUnion tree) {
4741         ListBuffer&lt;Type&gt; multicatchTypes = new ListBuffer&lt;&gt;();
4742         ListBuffer&lt;Type&gt; all_multicatchTypes = null; // lazy, only if needed
4743         for (JCExpression typeTree : tree.alternatives) {
4744             Type ctype = attribType(typeTree, env);
4745             ctype = chk.checkType(typeTree.pos(),
4746                           chk.checkClassType(typeTree.pos(), ctype),
4747                           syms.throwableType);
4748             if (!ctype.isErroneous()) {
4749                 //check that alternatives of a union type are pairwise
4750                 //unrelated w.r.t. subtyping
4751                 if (chk.intersects(ctype,  multicatchTypes.toList())) {
4752                     for (Type t : multicatchTypes) {
4753                         boolean sub = types.isSubtype(ctype, t);
4754                         boolean sup = types.isSubtype(t, ctype);
4755                         if (sub || sup) {
4756                             //assume &#39;a&#39; &lt;: &#39;b&#39;
4757                             Type a = sub ? ctype : t;
4758                             Type b = sub ? t : ctype;
4759                             log.error(typeTree.pos(), Errors.MulticatchTypesMustBeDisjoint(a, b));
4760                         }
4761                     }
4762                 }
4763                 multicatchTypes.append(ctype);
4764                 if (all_multicatchTypes != null)
4765                     all_multicatchTypes.append(ctype);
4766             } else {
4767                 if (all_multicatchTypes == null) {
4768                     all_multicatchTypes = new ListBuffer&lt;&gt;();
4769                     all_multicatchTypes.appendList(multicatchTypes);
4770                 }
4771                 all_multicatchTypes.append(ctype);
4772             }
4773         }
4774         Type t = check(tree, types.lub(multicatchTypes.toList()),
4775                 KindSelector.TYP, resultInfo.dup(CheckMode.NO_TREE_UPDATE));
4776         if (t.hasTag(CLASS)) {
4777             List&lt;Type&gt; alternatives =
4778                 ((all_multicatchTypes == null) ? multicatchTypes : all_multicatchTypes).toList();
4779             t = new UnionClassType((ClassType) t, alternatives);
4780         }
4781         tree.type = result = t;
4782     }
4783 
4784     public void visitTypeIntersection(JCTypeIntersection tree) {
4785         attribTypes(tree.bounds, env);
4786         tree.type = result = checkIntersection(tree, tree.bounds);
4787     }
4788 
4789     public void visitTypeParameter(JCTypeParameter tree) {
4790         TypeVar typeVar = (TypeVar) tree.type;
4791 
4792         if (tree.annotations != null &amp;&amp; tree.annotations.nonEmpty()) {
4793             annotate.annotateTypeParameterSecondStage(tree, tree.annotations);
4794         }
4795 
4796         if (!typeVar.getUpperBound().isErroneous()) {
4797             //fixup type-parameter bound computed in &#39;attribTypeVariables&#39;
4798             typeVar.setUpperBound(checkIntersection(tree, tree.bounds));
4799         }
4800     }
4801 
4802     Type checkIntersection(JCTree tree, List&lt;JCExpression&gt; bounds) {
4803         Set&lt;Type&gt; boundSet = new HashSet&lt;&gt;();
4804         if (bounds.nonEmpty()) {
4805             // accept class or interface or typevar as first bound.
4806             bounds.head.type = checkBase(bounds.head.type, syms.unknownSymbol, bounds.head, env, false, false, false);
4807             boundSet.add(types.erasure(bounds.head.type));
4808             if (bounds.head.type.isErroneous()) {
4809                 return bounds.head.type;
4810             }
4811             else if (bounds.head.type.hasTag(TYPEVAR)) {
4812                 // if first bound was a typevar, do not accept further bounds.
4813                 if (bounds.tail.nonEmpty()) {
4814                     log.error(bounds.tail.head.pos(),
4815                               Errors.TypeVarMayNotBeFollowedByOtherBounds);
4816                     return bounds.head.type;
4817                 }
4818             } else {
4819                 // if first bound was a class or interface, accept only interfaces
4820                 // as further bounds.
4821                 for (JCExpression bound : bounds.tail) {
4822                     bound.type = checkBase(bound.type, syms.unknownSymbol, bound, env, false, true, false);
4823                     if (bound.type.isErroneous()) {
4824                         bounds = List.of(bound);
4825                     }
4826                     else if (bound.type.hasTag(CLASS)) {
4827                         chk.checkNotRepeated(bound.pos(), types.erasure(bound.type), boundSet);
4828                     }
4829                 }
4830             }
4831         }
4832 
4833         if (bounds.length() == 0) {
4834             return syms.objectType;
4835         } else if (bounds.length() == 1) {
4836             return bounds.head.type;
4837         } else {
4838             Type owntype = types.makeIntersectionType(TreeInfo.types(bounds));
4839             // ... the variable&#39;s bound is a class type flagged COMPOUND
4840             // (see comment for TypeVar.bound).
4841             // In this case, generate a class tree that represents the
4842             // bound class, ...
4843             JCExpression extending;
4844             List&lt;JCExpression&gt; implementing;
4845             if (!bounds.head.type.isInterface()) {
4846                 extending = bounds.head;
4847                 implementing = bounds.tail;
4848             } else {
4849                 extending = null;
4850                 implementing = bounds;
4851             }
4852             JCClassDecl cd = make.at(tree).ClassDef(
4853                 make.Modifiers(PUBLIC | ABSTRACT),
4854                 names.empty, List.nil(),
4855                 extending, implementing, List.nil());
4856 
4857             ClassSymbol c = (ClassSymbol)owntype.tsym;
4858             Assert.check((c.flags() &amp; COMPOUND) != 0);
4859             cd.sym = c;
4860             c.sourcefile = env.toplevel.sourcefile;
4861 
4862             // ... and attribute the bound class
4863             c.flags_field |= UNATTRIBUTED;
4864             Env&lt;AttrContext&gt; cenv = enter.classEnv(cd, env);
4865             typeEnvs.put(c, cenv);
4866             attribClass(c);
4867             return owntype;
4868         }
4869     }
4870 
4871     public void visitWildcard(JCWildcard tree) {
4872         //- System.err.println(&quot;visitWildcard(&quot;+tree+&quot;);&quot;);//DEBUG
4873         Type type = (tree.kind.kind == BoundKind.UNBOUND)
4874             ? syms.objectType
4875             : attribType(tree.inner, env);
4876         result = check(tree, new WildcardType(chk.checkRefType(tree.pos(), type),
4877                                               tree.kind.kind,
4878                                               syms.boundClass),
4879                 KindSelector.TYP, resultInfo);
4880     }
4881 
4882     public void visitAnnotation(JCAnnotation tree) {
4883         Assert.error(&quot;should be handled in annotate&quot;);
4884     }
4885 
4886     public void visitAnnotatedType(JCAnnotatedType tree) {
4887         attribAnnotationTypes(tree.annotations, env);
4888         Type underlyingType = attribType(tree.underlyingType, env);
4889         Type annotatedType = underlyingType.annotatedType(Annotations.TO_BE_SET);
4890 
4891         if (!env.info.isNewClass)
4892             annotate.annotateTypeSecondStage(tree, tree.annotations, annotatedType);
4893         result = tree.type = annotatedType;
4894     }
4895 
4896     public void visitErroneous(JCErroneous tree) {
4897         if (tree.errs != null)
4898             for (JCTree err : tree.errs)
4899                 attribTree(err, env, new ResultInfo(KindSelector.ERR, pt()));
4900         result = tree.type = syms.errType;
4901     }
4902 
4903     /** Default visitor method for all other trees.
4904      */
4905     public void visitTree(JCTree tree) {
4906         throw new AssertionError();
4907     }
4908 
4909     /**
4910      * Attribute an env for either a top level tree or class or module declaration.
4911      */
4912     public void attrib(Env&lt;AttrContext&gt; env) {
4913         switch (env.tree.getTag()) {
4914             case MODULEDEF:
4915                 attribModule(env.tree.pos(), ((JCModuleDecl)env.tree).sym);
4916                 break;
4917             case TOPLEVEL:
4918                 attribTopLevel(env);
4919                 break;
4920             case PACKAGEDEF:
4921                 attribPackage(env.tree.pos(), ((JCPackageDecl) env.tree).packge);
4922                 break;
4923             default:
4924                 attribClass(env.tree.pos(), env.enclClass.sym);
4925         }
4926     }
4927 
4928     /**
4929      * Attribute a top level tree. These trees are encountered when the
4930      * package declaration has annotations.
4931      */
4932     public void attribTopLevel(Env&lt;AttrContext&gt; env) {
4933         JCCompilationUnit toplevel = env.toplevel;
4934         try {
4935             annotate.flush();
4936         } catch (CompletionFailure ex) {
4937             chk.completionError(toplevel.pos(), ex);
4938         }
4939     }
4940 
4941     public void attribPackage(DiagnosticPosition pos, PackageSymbol p) {
4942         try {
4943             annotate.flush();
4944             attribPackage(p);
4945         } catch (CompletionFailure ex) {
4946             chk.completionError(pos, ex);
4947         }
4948     }
4949 
4950     void attribPackage(PackageSymbol p) {
4951         Env&lt;AttrContext&gt; env = typeEnvs.get(p);
4952         chk.checkDeprecatedAnnotation(((JCPackageDecl) env.tree).pid.pos(), p);
4953     }
4954 
4955     public void attribModule(DiagnosticPosition pos, ModuleSymbol m) {
4956         try {
4957             annotate.flush();
4958             attribModule(m);
4959         } catch (CompletionFailure ex) {
4960             chk.completionError(pos, ex);
4961         }
4962     }
4963 
4964     void attribModule(ModuleSymbol m) {
4965         // Get environment current at the point of module definition.
4966         Env&lt;AttrContext&gt; env = enter.typeEnvs.get(m);
4967         attribStat(env.tree, env);
4968     }
4969 
4970     /** Main method: attribute class definition associated with given class symbol.
4971      *  reporting completion failures at the given position.
4972      *  @param pos The source position at which completion errors are to be
4973      *             reported.
4974      *  @param c   The class symbol whose definition will be attributed.
4975      */
4976     public void attribClass(DiagnosticPosition pos, ClassSymbol c) {
4977         try {
4978             annotate.flush();
4979             attribClass(c);
4980         } catch (CompletionFailure ex) {
4981             chk.completionError(pos, ex);
4982         }
4983     }
4984 
4985     /** Attribute class definition associated with given class symbol.
4986      *  @param c   The class symbol whose definition will be attributed.
4987      */
4988     void attribClass(ClassSymbol c) throws CompletionFailure {
4989         if (c.type.hasTag(ERROR)) return;
4990 
4991         // Check for cycles in the inheritance graph, which can arise from
4992         // ill-formed class files.
4993         chk.checkNonCyclic(null, c.type);
4994 
4995         Type st = types.supertype(c.type);
4996         if ((c.flags_field &amp; Flags.COMPOUND) == 0) {
4997             // First, attribute superclass.
4998             if (st.hasTag(CLASS))
4999                 attribClass((ClassSymbol)st.tsym);
5000 
5001             // Next attribute owner, if it is a class.
5002             if (c.owner.kind == TYP &amp;&amp; c.owner.type.hasTag(CLASS))
5003                 attribClass((ClassSymbol)c.owner);
5004         }
5005 
5006         // The previous operations might have attributed the current class
5007         // if there was a cycle. So we test first whether the class is still
5008         // UNATTRIBUTED.
5009         if ((c.flags_field &amp; UNATTRIBUTED) != 0) {
5010             c.flags_field &amp;= ~UNATTRIBUTED;
5011 
5012             // Get environment current at the point of class definition.
5013             Env&lt;AttrContext&gt; env = typeEnvs.get(c);
5014 
5015             if (c.isSealed() &amp;&amp;
5016                     !c.isEnum() &amp;&amp;
5017                     !c.isPermittedExplicit &amp;&amp;
5018                     c.permitted.isEmpty()) {
5019                 log.error(env.tree, Errors.SealedTypeMustHaveSubtypes);
5020             }
5021 
<a name="1" id="anc1"></a><span class="line-modified">5022             if (c.isSealed() &amp;&amp; !c.permitted.isEmpty()) {</span>
5023                 Set&lt;Symbol&gt; permittedTypes = new HashSet&lt;&gt;();
5024                 boolean sealedInUnnamed = c.packge().modle == syms.unnamedModule || c.packge().modle == syms.noModule;
5025                 for (Symbol subTypeSym : c.permitted) {
5026                     boolean isTypeVar = false;
5027                     if (subTypeSym.type.getTag() == TYPEVAR) {
<a name="2" id="anc2"></a><span class="line-modified">5028                         isTypeVar = true;</span>
5029                         log.error(TreeInfo.declarationFor(subTypeSym, env.tree), Errors.TypeVarListedInPermits);
5030                     }
5031                     if (subTypeSym.isAnonymous() &amp;&amp; !c.isEnum()) {
5032                         log.error(TreeInfo.declarationFor(subTypeSym, env.tree), Errors.CantInheritFromSealed(c));
5033                     }
5034                     if (permittedTypes.contains(subTypeSym)) {
5035                         log.error(TreeInfo.declarationFor(subTypeSym, env.tree), Errors.DuplicatedTypeInPermits(subTypeSym.type));
5036                     } else {
5037                         permittedTypes.add(subTypeSym);
5038                     }
5039                     if (sealedInUnnamed) {
5040                         if (subTypeSym.packge() != c.packge()) {
5041                             log.error(TreeInfo.declarationFor(subTypeSym, env.tree), Errors.CantInheritFromSealed(c));
5042                         }
5043                     } else if (subTypeSym.packge().modle != c.packge().modle) {
5044                         log.error(TreeInfo.declarationFor(subTypeSym, env.tree), Errors.CantInheritFromSealed(c));
5045                     }
5046                     if (subTypeSym == c.type.tsym || types.isSuperType(subTypeSym.type, c.type)) {
5047                         log.error(TreeInfo.declarationFor(subTypeSym, ((JCClassDecl)env.tree).permitting),
5048                                 Errors.TypeListedInPermitsIsSameClassOrSupertype(subTypeSym == c.type.tsym ?
5049                                         Fragments.SameClass : Fragments.Supertype));
<a name="3" id="anc3"></a><span class="line-modified">5050                     } else {</span>
<span class="line-modified">5051                         if (!isTypeVar &amp;&amp; !((ClassSymbol)subTypeSym).sealedSupers.contains(c.type.tsym)) {</span>



5052                             log.error(TreeInfo.declarationFor(subTypeSym, env.tree),
5053                                     Errors.SubtypeListedInPermitsDoesntExtendSealed(subTypeSym.type, c.type));
5054                         }
5055                     }
5056                 }
5057             }
5058 
<a name="4" id="anc4"></a><span class="line-modified">5059             if (!c.sealedSupers.isEmpty() &amp;&amp; c.isLocal() &amp;&amp; !c.isEnum()) {</span>
<span class="line-modified">5060                 log.error(TreeInfo.declarationFor(c, env.tree), Errors.LocalClassesCantExtendSealed);</span>
<span class="line-modified">5061             }</span>











5062 
<a name="5" id="anc5"></a><span class="line-modified">5063             if (!c.sealedSupers.isEmpty()) {</span>
<span class="line-removed">5064                 for (ClassSymbol supertypeSym : c.sealedSupers) {</span>
5065                     if (!supertypeSym.permitted.contains(c.type.tsym)) {
<a name="6" id="anc6"></a><span class="line-modified">5066                         if (supertypeSym.isPermittedExplicit) {</span>
<span class="line-removed">5067                             log.error(TreeInfo.declarationFor(c.type.tsym, env.tree), Errors.CantInheritFromSealed(supertypeSym));</span>
<span class="line-removed">5068                         }</span>
5069                     }
5070                 }
5071                 if (!c.isNonSealed() &amp;&amp; !c.isFinal() &amp;&amp; !c.isSealed()) {
5072                     log.error(TreeInfo.declarationFor(c, env.tree), Errors.NonSealedSealedOrFinalExpected);
5073                 }
<a name="7" id="anc7"></a><span class="line-removed">5074 </span>
<span class="line-removed">5075                 if (!c.hasSealedSuperInSameCU) {</span>
<span class="line-removed">5076                     // that supertype most have a permits clause allowing this class to extend it</span>
<span class="line-removed">5077                     List&lt;Type&gt; closureOutsideOfSameCU = types.closure(c.type).stream()</span>
<span class="line-removed">5078                             .filter(supertype -&gt;</span>
<span class="line-removed">5079                                     TreeInfo.declarationFor(supertype.tsym, env.toplevel) == null ||</span>
<span class="line-removed">5080                                             TreeInfo.declarationFor(c.outermostClass(), env.toplevel) == null)</span>
<span class="line-removed">5081                             .collect(List.collector());</span>
<span class="line-removed">5082                     Set&lt;Type&gt; explicitlySealedSuperTypesOutsideOfCU = closureOutsideOfSameCU.stream()</span>
<span class="line-removed">5083                             .filter(type -&gt; type != c.type &amp;&amp; type.tsym.isSealed()).collect(Collectors.toSet());</span>
<span class="line-removed">5084                     for (Type supertype : explicitlySealedSuperTypesOutsideOfCU) {</span>
<span class="line-removed">5085                         if (!((ClassSymbol)supertype.tsym).permitted.contains(c.type.tsym)) {</span>
<span class="line-removed">5086                             log.error(TreeInfo.declarationFor(c, env.tree), Errors.CantInheritFromSealed(supertype.tsym));</span>
<span class="line-removed">5087                         }</span>
<span class="line-removed">5088                     }</span>
<span class="line-removed">5089 </span>
<span class="line-removed">5090                     if (!c.isNonSealed() &amp;&amp; !c.isFinal() &amp;&amp; !c.isSealed()) {</span>
<span class="line-removed">5091                         log.error(TreeInfo.declarationFor(c, env.tree), Errors.NonSealedSealedOrFinalExpected);</span>
<span class="line-removed">5092                     }</span>
<span class="line-removed">5093                 }</span>
<span class="line-removed">5094             }</span>
<span class="line-removed">5095 </span>
<span class="line-removed">5096             if ((c.flags_field &amp; Flags.NON_SEALED) != 0 &amp;&amp; c.sealedSupers.isEmpty()) {</span>
<span class="line-removed">5097                 log.error(TreeInfo.declarationFor(c, env.tree), Errors.NonSealedWithNoSealedSupertype);</span>
5098             }
5099 
5100             // The info.lint field in the envs stored in typeEnvs is deliberately uninitialized,
5101             // because the annotations were not available at the time the env was created. Therefore,
5102             // we look up the environment chain for the first enclosing environment for which the
5103             // lint value is set. Typically, this is the parent env, but might be further if there
5104             // are any envs created as a result of TypeParameter nodes.
5105             Env&lt;AttrContext&gt; lintEnv = env;
5106             while (lintEnv.info.lint == null)
5107                 lintEnv = lintEnv.next;
5108 
5109             // Having found the enclosing lint value, we can initialize the lint value for this class
5110             env.info.lint = lintEnv.info.lint.augment(c);
5111 
5112             Lint prevLint = chk.setLint(env.info.lint);
5113             JavaFileObject prev = log.useSource(c.sourcefile);
5114             ResultInfo prevReturnRes = env.info.returnResult;
5115 
5116             try {
5117                 deferredLintHandler.flush(env.tree);
5118                 env.info.returnResult = null;
5119                 // java.lang.Enum may not be subclassed by a non-enum
5120                 if (st.tsym == syms.enumSym &amp;&amp;
5121                     ((c.flags_field &amp; (Flags.ENUM|Flags.COMPOUND)) == 0))
5122                     log.error(env.tree.pos(), Errors.EnumNoSubclassing);
5123 
5124                 // Enums may not be extended by source-level classes
5125                 if (st.tsym != null &amp;&amp;
5126                     ((st.tsym.flags_field &amp; Flags.ENUM) != 0) &amp;&amp;
5127                     ((c.flags_field &amp; (Flags.ENUM | Flags.COMPOUND)) == 0)) {
5128                     log.error(env.tree.pos(), Errors.EnumTypesNotExtensible);
5129                 }
5130 
5131                 if (isSerializable(c.type)) {
5132                     env.info.isSerializable = true;
5133                 }
5134 
5135                 attribClassBody(env, c);
5136 
5137                 chk.checkDeprecatedAnnotation(env.tree.pos(), c);
5138                 chk.checkClassOverrideEqualsAndHashIfNeeded(env.tree.pos(), c);
5139                 chk.checkFunctionalInterface((JCClassDecl) env.tree, c);
5140                 chk.checkLeaksNotAccessible(env, (JCClassDecl) env.tree);
5141             } finally {
5142                 env.info.returnResult = prevReturnRes;
5143                 log.useSource(prev);
5144                 chk.setLint(prevLint);
5145             }
5146 
5147         }
5148     }
5149 
5150     public void visitImport(JCImport tree) {
5151         // nothing to do
5152     }
5153 
5154     public void visitModuleDef(JCModuleDecl tree) {
5155         tree.sym.completeUsesProvides();
5156         ModuleSymbol msym = tree.sym;
5157         Lint lint = env.outer.info.lint = env.outer.info.lint.augment(msym);
5158         Lint prevLint = chk.setLint(lint);
5159         chk.checkModuleName(tree);
5160         chk.checkDeprecatedAnnotation(tree, msym);
5161 
5162         try {
5163             deferredLintHandler.flush(tree.pos());
5164         } finally {
5165             chk.setLint(prevLint);
5166         }
5167     }
5168 
5169     /** Finish the attribution of a class. */
5170     private void attribClassBody(Env&lt;AttrContext&gt; env, ClassSymbol c) {
5171         JCClassDecl tree = (JCClassDecl)env.tree;
5172         Assert.check(c == tree.sym);
5173 
5174         // Validate type parameters, supertype and interfaces.
5175         attribStats(tree.typarams, env);
5176         if (!c.isAnonymous()) {
5177             //already checked if anonymous
5178             chk.validate(tree.typarams, env);
5179             chk.validate(tree.extending, env);
5180             chk.validate(tree.implementing, env);
5181         }
5182 
5183         c.markAbstractIfNeeded(types);
5184 
5185         // If this is a non-abstract class, check that it has no abstract
5186         // methods or unimplemented methods of an implemented interface.
5187         if ((c.flags() &amp; (ABSTRACT | INTERFACE)) == 0) {
5188             chk.checkAllDefined(tree.pos(), c);
5189         }
5190 
5191         if ((c.flags() &amp; ANNOTATION) != 0) {
5192             if (tree.implementing.nonEmpty())
5193                 log.error(tree.implementing.head.pos(),
5194                           Errors.CantExtendIntfAnnotation);
5195             if (tree.typarams.nonEmpty()) {
5196                 log.error(tree.typarams.head.pos(),
5197                           Errors.IntfAnnotationCantHaveTypeParams(c));
5198             }
5199 
5200             // If this annotation type has a @Repeatable, validate
5201             Attribute.Compound repeatable = c.getAnnotationTypeMetadata().getRepeatable();
5202             // If this annotation type has a @Repeatable, validate
5203             if (repeatable != null) {
5204                 // get diagnostic position for error reporting
5205                 DiagnosticPosition cbPos = getDiagnosticPosition(tree, repeatable.type);
5206                 Assert.checkNonNull(cbPos);
5207 
5208                 chk.validateRepeatable(c, repeatable, cbPos);
5209             }
5210         } else {
5211             // Check that all extended classes and interfaces
5212             // are compatible (i.e. no two define methods with same arguments
5213             // yet different return types).  (JLS 8.4.6.3)
5214             chk.checkCompatibleSupertypes(tree.pos(), c.type);
5215             if (allowDefaultMethods) {
5216                 chk.checkDefaultMethodClashes(tree.pos(), c.type);
5217             }
5218         }
5219 
5220         // Check that class does not import the same parameterized interface
5221         // with two different argument lists.
5222         chk.checkClassBounds(tree.pos(), c.type);
5223 
5224         tree.type = c.type;
5225 
5226         for (List&lt;JCTypeParameter&gt; l = tree.typarams;
5227              l.nonEmpty(); l = l.tail) {
5228              Assert.checkNonNull(env.info.scope.findFirst(l.head.name));
5229         }
5230 
5231         // Check that a generic class doesn&#39;t extend Throwable
5232         if (!c.type.allparams().isEmpty() &amp;&amp; types.isSubtype(c.type, syms.throwableType))
5233             log.error(tree.extending.pos(), Errors.GenericThrowable);
5234 
5235         // Check that all methods which implement some
5236         // method conform to the method they implement.
5237         chk.checkImplementations(tree);
5238 
5239         //check that a resource implementing AutoCloseable cannot throw InterruptedException
5240         checkAutoCloseable(tree.pos(), env, c.type);
5241 
5242         for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
5243             // Attribute declaration
5244             attribStat(l.head, env);
5245             // Check that declarations in inner classes are not static (JLS 8.1.2)
5246             // Make an exception for static constants.
5247             if (c.owner.kind != PCK &amp;&amp;
5248                     ((c.flags() &amp; STATIC) == 0 || c.name == names.empty) &amp;&amp;
5249                     (TreeInfo.flags(l.head) &amp; (STATIC | INTERFACE)) != 0) {
5250                 Symbol sym = null;
5251                 if (l.head.hasTag(VARDEF)) sym = ((JCVariableDecl) l.head).sym;
5252                 if (sym == null ||
5253                         sym.kind != VAR ||
5254                         ((VarSymbol) sym).getConstValue() == null)
5255                     log.error(l.head.pos(), Errors.IclsCantHaveStaticDecl(c));
5256             }
5257         }
5258 
5259         // Check for cycles among non-initial constructors.
5260         chk.checkCyclicConstructors(tree);
5261 
5262         // Check for cycles among annotation elements.
5263         chk.checkNonCyclicElements(tree);
5264 
5265         // Check for proper use of serialVersionUID
5266         if (env.info.lint.isEnabled(LintCategory.SERIAL)
5267                 &amp;&amp; isSerializable(c.type)
5268                 &amp;&amp; (c.flags() &amp; (Flags.ENUM | Flags.INTERFACE)) == 0
5269                 &amp;&amp; !c.isAnonymous()) {
5270             checkSerialVersionUID(tree, c);
5271         }
5272         if (allowTypeAnnos) {
5273             // Correctly organize the positions of the type annotations
5274             typeAnnotations.organizeTypeAnnotationsBodies(tree);
5275 
5276             // Check type annotations applicability rules
5277             validateTypeAnnotations(tree, false);
5278         }
5279     }
5280         // where
5281         /** get a diagnostic position for an attribute of Type t, or null if attribute missing */
5282         private DiagnosticPosition getDiagnosticPosition(JCClassDecl tree, Type t) {
5283             for(List&lt;JCAnnotation&gt; al = tree.mods.annotations; !al.isEmpty(); al = al.tail) {
5284                 if (types.isSameType(al.head.annotationType.type, t))
5285                     return al.head.pos();
5286             }
5287 
5288             return null;
5289         }
5290 
5291         /** check if a type is a subtype of Serializable, if that is available. */
5292         boolean isSerializable(Type t) {
5293             try {
5294                 syms.serializableType.complete();
5295             }
5296             catch (CompletionFailure e) {
5297                 return false;
5298             }
5299             return types.isSubtype(t, syms.serializableType);
5300         }
5301 
5302         /** Check that an appropriate serialVersionUID member is defined. */
5303         private void checkSerialVersionUID(JCClassDecl tree, ClassSymbol c) {
5304 
5305             // check for presence of serialVersionUID
5306             VarSymbol svuid = null;
5307             for (Symbol sym : c.members().getSymbolsByName(names.serialVersionUID)) {
5308                 if (sym.kind == VAR) {
5309                     svuid = (VarSymbol)sym;
5310                     break;
5311                 }
5312             }
5313 
5314             if (svuid == null) {
5315                 log.warning(LintCategory.SERIAL,
5316                         tree.pos(), Warnings.MissingSVUID(c));
5317                 return;
5318             }
5319 
5320             // check that it is static final
5321             if ((svuid.flags() &amp; (STATIC | FINAL)) !=
5322                 (STATIC | FINAL))
5323                 log.warning(LintCategory.SERIAL,
5324                         TreeInfo.diagnosticPositionFor(svuid, tree), Warnings.ImproperSVUID(c));
5325 
5326             // check that it is long
5327             else if (!svuid.type.hasTag(LONG))
5328                 log.warning(LintCategory.SERIAL,
5329                         TreeInfo.diagnosticPositionFor(svuid, tree), Warnings.LongSVUID(c));
5330 
5331             // check constant
5332             else if (svuid.getConstValue() == null)
5333                 log.warning(LintCategory.SERIAL,
5334                         TreeInfo.diagnosticPositionFor(svuid, tree), Warnings.ConstantSVUID(c));
5335         }
5336 
5337     private Type capture(Type type) {
5338         return types.capture(type);
5339     }
5340 
5341     private void setSyntheticVariableType(JCVariableDecl tree, Type type) {
5342         if (type.isErroneous()) {
5343             tree.vartype = make.at(Position.NOPOS).Erroneous();
5344         } else {
5345             tree.vartype = make.at(Position.NOPOS).Type(type);
5346         }
5347     }
5348 
5349     public void validateTypeAnnotations(JCTree tree, boolean sigOnly) {
5350         tree.accept(new TypeAnnotationsValidator(sigOnly));
5351     }
5352     //where
5353     private final class TypeAnnotationsValidator extends TreeScanner {
5354 
5355         private final boolean sigOnly;
5356         public TypeAnnotationsValidator(boolean sigOnly) {
5357             this.sigOnly = sigOnly;
5358         }
5359 
5360         public void visitAnnotation(JCAnnotation tree) {
5361             chk.validateTypeAnnotation(tree, false);
5362             super.visitAnnotation(tree);
5363         }
5364         public void visitAnnotatedType(JCAnnotatedType tree) {
5365             if (!tree.underlyingType.type.isErroneous()) {
5366                 super.visitAnnotatedType(tree);
5367             }
5368         }
5369         public void visitTypeParameter(JCTypeParameter tree) {
5370             chk.validateTypeAnnotations(tree.annotations, true);
5371             scan(tree.bounds);
5372             // Don&#39;t call super.
5373             // This is needed because above we call validateTypeAnnotation with
5374             // false, which would forbid annotations on type parameters.
5375             // super.visitTypeParameter(tree);
5376         }
5377         public void visitMethodDef(JCMethodDecl tree) {
5378             if (tree.recvparam != null &amp;&amp;
5379                     !tree.recvparam.vartype.type.isErroneous()) {
5380                 checkForDeclarationAnnotations(tree.recvparam.mods.annotations,
5381                         tree.recvparam.vartype.type.tsym);
5382             }
5383             if (tree.restype != null &amp;&amp; tree.restype.type != null) {
5384                 validateAnnotatedType(tree.restype, tree.restype.type);
5385             }
5386             if (sigOnly) {
5387                 scan(tree.mods);
5388                 scan(tree.restype);
5389                 scan(tree.typarams);
5390                 scan(tree.recvparam);
5391                 scan(tree.params);
5392                 scan(tree.thrown);
5393             } else {
5394                 scan(tree.defaultValue);
5395                 scan(tree.body);
5396             }
5397         }
5398         public void visitVarDef(final JCVariableDecl tree) {
5399             //System.err.println(&quot;validateTypeAnnotations.visitVarDef &quot; + tree);
5400             if (tree.sym != null &amp;&amp; tree.sym.type != null &amp;&amp; !tree.isImplicitlyTyped())
5401                 validateAnnotatedType(tree.vartype, tree.sym.type);
5402             scan(tree.mods);
5403             scan(tree.vartype);
5404             if (!sigOnly) {
5405                 scan(tree.init);
5406             }
5407         }
5408         public void visitTypeCast(JCTypeCast tree) {
5409             if (tree.clazz != null &amp;&amp; tree.clazz.type != null)
5410                 validateAnnotatedType(tree.clazz, tree.clazz.type);
5411             super.visitTypeCast(tree);
5412         }
5413         public void visitTypeTest(JCInstanceOf tree) {
5414             if (tree.pattern != null &amp;&amp; !(tree.pattern instanceof JCPattern) &amp;&amp; tree.pattern.type != null)
5415                 validateAnnotatedType(tree.pattern, tree.pattern.type);
5416             super.visitTypeTest(tree);
5417         }
5418         public void visitNewClass(JCNewClass tree) {
5419             if (tree.clazz != null &amp;&amp; tree.clazz.type != null) {
5420                 if (tree.clazz.hasTag(ANNOTATED_TYPE)) {
5421                     checkForDeclarationAnnotations(((JCAnnotatedType) tree.clazz).annotations,
5422                             tree.clazz.type.tsym);
5423                 }
5424                 if (tree.def != null) {
5425                     checkForDeclarationAnnotations(tree.def.mods.annotations, tree.clazz.type.tsym);
5426                 }
5427 
5428                 validateAnnotatedType(tree.clazz, tree.clazz.type);
5429             }
5430             super.visitNewClass(tree);
5431         }
5432         public void visitNewArray(JCNewArray tree) {
5433             if (tree.elemtype != null &amp;&amp; tree.elemtype.type != null) {
5434                 if (tree.elemtype.hasTag(ANNOTATED_TYPE)) {
5435                     checkForDeclarationAnnotations(((JCAnnotatedType) tree.elemtype).annotations,
5436                             tree.elemtype.type.tsym);
5437                 }
5438                 validateAnnotatedType(tree.elemtype, tree.elemtype.type);
5439             }
5440             super.visitNewArray(tree);
5441         }
5442         public void visitClassDef(JCClassDecl tree) {
5443             //System.err.println(&quot;validateTypeAnnotations.visitClassDef &quot; + tree);
5444             if (sigOnly) {
5445                 scan(tree.mods);
5446                 scan(tree.typarams);
5447                 scan(tree.extending);
5448                 scan(tree.implementing);
5449             }
5450             for (JCTree member : tree.defs) {
5451                 if (member.hasTag(Tag.CLASSDEF)) {
5452                     continue;
5453                 }
5454                 scan(member);
5455             }
5456         }
5457         public void visitBlock(JCBlock tree) {
5458             if (!sigOnly) {
5459                 scan(tree.stats);
5460             }
5461         }
5462 
5463         /* I would want to model this after
5464          * com.sun.tools.javac.comp.Check.Validator.visitSelectInternal(JCFieldAccess)
5465          * and override visitSelect and visitTypeApply.
5466          * However, we only set the annotated type in the top-level type
5467          * of the symbol.
5468          * Therefore, we need to override each individual location where a type
5469          * can occur.
5470          */
5471         private void validateAnnotatedType(final JCTree errtree, final Type type) {
5472             //System.err.println(&quot;Attr.validateAnnotatedType: &quot; + errtree + &quot; type: &quot; + type);
5473 
5474             if (type.isPrimitiveOrVoid()) {
5475                 return;
5476             }
5477 
5478             JCTree enclTr = errtree;
5479             Type enclTy = type;
5480 
5481             boolean repeat = true;
5482             while (repeat) {
5483                 if (enclTr.hasTag(TYPEAPPLY)) {
5484                     List&lt;Type&gt; tyargs = enclTy.getTypeArguments();
5485                     List&lt;JCExpression&gt; trargs = ((JCTypeApply)enclTr).getTypeArguments();
5486                     if (trargs.length() &gt; 0) {
5487                         // Nothing to do for diamonds
5488                         if (tyargs.length() == trargs.length()) {
5489                             for (int i = 0; i &lt; tyargs.length(); ++i) {
5490                                 validateAnnotatedType(trargs.get(i), tyargs.get(i));
5491                             }
5492                         }
5493                         // If the lengths don&#39;t match, it&#39;s either a diamond
5494                         // or some nested type that redundantly provides
5495                         // type arguments in the tree.
5496                     }
5497 
5498                     // Look at the clazz part of a generic type
5499                     enclTr = ((JCTree.JCTypeApply)enclTr).clazz;
5500                 }
5501 
5502                 if (enclTr.hasTag(SELECT)) {
5503                     enclTr = ((JCTree.JCFieldAccess)enclTr).getExpression();
5504                     if (enclTy != null &amp;&amp;
5505                             !enclTy.hasTag(NONE)) {
5506                         enclTy = enclTy.getEnclosingType();
5507                     }
5508                 } else if (enclTr.hasTag(ANNOTATED_TYPE)) {
5509                     JCAnnotatedType at = (JCTree.JCAnnotatedType) enclTr;
5510                     if (enclTy == null || enclTy.hasTag(NONE)) {
5511                         if (at.getAnnotations().size() == 1) {
5512                             log.error(at.underlyingType.pos(), Errors.CantTypeAnnotateScoping1(at.getAnnotations().head.attribute));
5513                         } else {
5514                             ListBuffer&lt;Attribute.Compound&gt; comps = new ListBuffer&lt;&gt;();
5515                             for (JCAnnotation an : at.getAnnotations()) {
5516                                 comps.add(an.attribute);
5517                             }
5518                             log.error(at.underlyingType.pos(), Errors.CantTypeAnnotateScoping(comps.toList()));
5519                         }
5520                         repeat = false;
5521                     }
5522                     enclTr = at.underlyingType;
5523                     // enclTy doesn&#39;t need to be changed
5524                 } else if (enclTr.hasTag(IDENT)) {
5525                     repeat = false;
5526                 } else if (enclTr.hasTag(JCTree.Tag.WILDCARD)) {
5527                     JCWildcard wc = (JCWildcard) enclTr;
5528                     if (wc.getKind() == JCTree.Kind.EXTENDS_WILDCARD ||
5529                             wc.getKind() == JCTree.Kind.SUPER_WILDCARD) {
5530                         validateAnnotatedType(wc.getBound(), wc.getBound().type);
5531                     } else {
5532                         // Nothing to do for UNBOUND
5533                     }
5534                     repeat = false;
5535                 } else if (enclTr.hasTag(TYPEARRAY)) {
5536                     JCArrayTypeTree art = (JCArrayTypeTree) enclTr;
5537                     validateAnnotatedType(art.getType(), art.elemtype.type);
5538                     repeat = false;
5539                 } else if (enclTr.hasTag(TYPEUNION)) {
5540                     JCTypeUnion ut = (JCTypeUnion) enclTr;
5541                     for (JCTree t : ut.getTypeAlternatives()) {
5542                         validateAnnotatedType(t, t.type);
5543                     }
5544                     repeat = false;
5545                 } else if (enclTr.hasTag(TYPEINTERSECTION)) {
5546                     JCTypeIntersection it = (JCTypeIntersection) enclTr;
5547                     for (JCTree t : it.getBounds()) {
5548                         validateAnnotatedType(t, t.type);
5549                     }
5550                     repeat = false;
5551                 } else if (enclTr.getKind() == JCTree.Kind.PRIMITIVE_TYPE ||
5552                            enclTr.getKind() == JCTree.Kind.ERRONEOUS) {
5553                     repeat = false;
5554                 } else {
5555                     Assert.error(&quot;Unexpected tree: &quot; + enclTr + &quot; with kind: &quot; + enclTr.getKind() +
5556                             &quot; within: &quot;+ errtree + &quot; with kind: &quot; + errtree.getKind());
5557                 }
5558             }
5559         }
5560 
5561         private void checkForDeclarationAnnotations(List&lt;? extends JCAnnotation&gt; annotations,
5562                 Symbol sym) {
5563             // Ensure that no declaration annotations are present.
5564             // Note that a tree type might be an AnnotatedType with
5565             // empty annotations, if only declaration annotations were given.
5566             // This method will raise an error for such a type.
5567             for (JCAnnotation ai : annotations) {
5568                 if (!ai.type.isErroneous() &amp;&amp;
5569                         typeAnnotations.annotationTargetType(ai.attribute, sym) == TypeAnnotations.AnnotationType.DECLARATION) {
5570                     log.error(ai.pos(), Errors.AnnotationTypeNotApplicableToType(ai.type));
5571                 }
5572             }
5573         }
5574     }
5575 
5576     // &lt;editor-fold desc=&quot;post-attribution visitor&quot;&gt;
5577 
5578     /**
5579      * Handle missing types/symbols in an AST. This routine is useful when
5580      * the compiler has encountered some errors (which might have ended up
5581      * terminating attribution abruptly); if the compiler is used in fail-over
5582      * mode (e.g. by an IDE) and the AST contains semantic errors, this routine
5583      * prevents NPE to be propagated during subsequent compilation steps.
5584      */
5585     public void postAttr(JCTree tree) {
5586         new PostAttrAnalyzer().scan(tree);
5587     }
5588 
5589     class PostAttrAnalyzer extends TreeScanner {
5590 
5591         private void initTypeIfNeeded(JCTree that) {
5592             if (that.type == null) {
5593                 if (that.hasTag(METHODDEF)) {
5594                     that.type = dummyMethodType((JCMethodDecl)that);
5595                 } else {
5596                     that.type = syms.unknownType;
5597                 }
5598             }
5599         }
5600 
5601         /* Construct a dummy method type. If we have a method declaration,
5602          * and the declared return type is void, then use that return type
5603          * instead of UNKNOWN to avoid spurious error messages in lambda
5604          * bodies (see:JDK-8041704).
5605          */
5606         private Type dummyMethodType(JCMethodDecl md) {
5607             Type restype = syms.unknownType;
5608             if (md != null &amp;&amp; md.restype != null &amp;&amp; md.restype.hasTag(TYPEIDENT)) {
5609                 JCPrimitiveTypeTree prim = (JCPrimitiveTypeTree)md.restype;
5610                 if (prim.typetag == VOID)
5611                     restype = syms.voidType;
5612             }
5613             return new MethodType(List.nil(), restype,
5614                                   List.nil(), syms.methodClass);
5615         }
5616         private Type dummyMethodType() {
5617             return dummyMethodType(null);
5618         }
5619 
5620         @Override
5621         public void scan(JCTree tree) {
5622             if (tree == null) return;
5623             if (tree instanceof JCExpression) {
5624                 initTypeIfNeeded(tree);
5625             }
5626             super.scan(tree);
5627         }
5628 
5629         @Override
5630         public void visitIdent(JCIdent that) {
5631             if (that.sym == null) {
5632                 that.sym = syms.unknownSymbol;
5633             }
5634         }
5635 
5636         @Override
5637         public void visitSelect(JCFieldAccess that) {
5638             if (that.sym == null) {
5639                 that.sym = syms.unknownSymbol;
5640             }
5641             super.visitSelect(that);
5642         }
5643 
5644         @Override
5645         public void visitClassDef(JCClassDecl that) {
5646             initTypeIfNeeded(that);
5647             if (that.sym == null) {
5648                 that.sym = new ClassSymbol(0, that.name, that.type, syms.noSymbol);
5649             }
5650             super.visitClassDef(that);
5651         }
5652 
5653         @Override
5654         public void visitMethodDef(JCMethodDecl that) {
5655             initTypeIfNeeded(that);
5656             if (that.sym == null) {
5657                 that.sym = new MethodSymbol(0, that.name, that.type, syms.noSymbol);
5658             }
5659             super.visitMethodDef(that);
5660         }
5661 
5662         @Override
5663         public void visitVarDef(JCVariableDecl that) {
5664             initTypeIfNeeded(that);
5665             if (that.sym == null) {
5666                 that.sym = new VarSymbol(0, that.name, that.type, syms.noSymbol);
5667                 that.sym.adr = 0;
5668             }
5669             if (that.vartype == null) {
5670                 that.vartype = make.at(Position.NOPOS).Erroneous();
5671             }
5672             super.visitVarDef(that);
5673         }
5674 
5675         @Override
5676         public void visitBindingPattern(JCBindingPattern that) {
5677             if (that.symbol == null) {
5678                 that.symbol = new BindingSymbol(that.name, that.type, syms.noSymbol);
5679                 that.symbol.adr = 0;
5680             }
5681             super.visitBindingPattern(that);
5682         }
5683 
5684         @Override
5685         public void visitNewClass(JCNewClass that) {
5686             if (that.constructor == null) {
5687                 that.constructor = new MethodSymbol(0, names.init,
5688                         dummyMethodType(), syms.noSymbol);
5689             }
5690             if (that.constructorType == null) {
5691                 that.constructorType = syms.unknownType;
5692             }
5693             super.visitNewClass(that);
5694         }
5695 
5696         @Override
5697         public void visitAssignop(JCAssignOp that) {
5698             if (that.operator == null) {
5699                 that.operator = new OperatorSymbol(names.empty, dummyMethodType(),
5700                         -1, syms.noSymbol);
5701             }
5702             super.visitAssignop(that);
5703         }
5704 
5705         @Override
5706         public void visitBinary(JCBinary that) {
5707             if (that.operator == null) {
5708                 that.operator = new OperatorSymbol(names.empty, dummyMethodType(),
5709                         -1, syms.noSymbol);
5710             }
5711             super.visitBinary(that);
5712         }
5713 
5714         @Override
5715         public void visitUnary(JCUnary that) {
5716             if (that.operator == null) {
5717                 that.operator = new OperatorSymbol(names.empty, dummyMethodType(),
5718                         -1, syms.noSymbol);
5719             }
5720             super.visitUnary(that);
5721         }
5722 
5723         @Override
5724         public void visitReference(JCMemberReference that) {
5725             super.visitReference(that);
5726             if (that.sym == null) {
5727                 that.sym = new MethodSymbol(0, names.empty, dummyMethodType(),
5728                         syms.noSymbol);
5729             }
5730         }
5731     }
5732     // &lt;/editor-fold&gt;
5733 
5734     public void setPackageSymbols(JCExpression pid, Symbol pkg) {
5735         new TreeScanner() {
5736             Symbol packge = pkg;
5737             @Override
5738             public void visitIdent(JCIdent that) {
5739                 that.sym = packge;
5740             }
5741 
5742             @Override
5743             public void visitSelect(JCFieldAccess that) {
5744                 that.sym = packge;
5745                 packge = packge.owner;
5746                 super.visitSelect(that);
5747             }
5748         }.scan(pid);
5749     }
5750 
5751 }
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
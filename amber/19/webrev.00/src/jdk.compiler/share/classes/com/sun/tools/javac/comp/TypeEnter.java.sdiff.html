<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TypeEnter.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Attr.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../../../test/langtools/tools/javac/sealed/SealedDiffConfigurationsTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TypeEnter.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  43 import com.sun.tools.javac.comp.Annotate.AnnotationTypeMetadata;
  44 import com.sun.tools.javac.tree.*;
  45 import com.sun.tools.javac.util.*;
  46 import com.sun.tools.javac.util.DefinedBy.Api;
  47 
  48 import com.sun.tools.javac.code.Symbol.*;
  49 import com.sun.tools.javac.code.Type.*;
  50 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  51 import com.sun.tools.javac.tree.JCTree.*;
  52 
  53 import static com.sun.tools.javac.code.Flags.*;
  54 import static com.sun.tools.javac.code.Flags.ANNOTATION;
  55 import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;
  56 import static com.sun.tools.javac.code.Kinds.Kind.*;
  57 import static com.sun.tools.javac.code.TypeTag.CLASS;
  58 import static com.sun.tools.javac.code.TypeTag.ERROR;
  59 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  60 
  61 import static com.sun.tools.javac.code.TypeTag.*;
  62 import static com.sun.tools.javac.code.TypeTag.BOT;


  63 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  64 
  65 import com.sun.tools.javac.util.Dependencies.CompletionCause;
  66 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
  67 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  68 
  69 /** This is the second phase of Enter, in which classes are completed
  70  *  by resolving their headers and entering their members in the into
  71  *  the class scope. See Enter for an overall overview.
  72  *
  73  *  This class uses internal phases to process the classes. When a phase
  74  *  processes classes, the lower phases are not invoked until all classes
  75  *  pass through the current phase. Note that it is possible that upper phases
  76  *  are run due to recursive completion. The internal phases are:
  77  *  - ImportPhase: shallow pass through imports, adds information about imports
  78  *                 the NamedImportScope and StarImportScope, but avoids queries
  79  *                 about class hierarchy.
  80  *  - HierarchyPhase: resolves the supertypes of the given class. Does not handle
  81  *                    type parameters of the class or type argument of the supertypes.
  82  *  - HeaderPhase: finishes analysis of the header of the given class by resolving
</pre>
<hr />
<pre>
 810                 sym.completer = this;
 811                 return ;
 812             }
 813 
 814             Env&lt;AttrContext&gt; env = typeEnvs.get((ClassSymbol) sym);
 815 
 816             super.doCompleteEnvs(List.of(env));
 817         }
 818 
 819     }
 820 
 821     private final class PermitsPhase extends AbstractHeaderPhase {
 822 
 823         public PermitsPhase() {
 824             super(CompletionCause.HIERARCHY_PHASE, new HeaderPhase());
 825         }
 826 
 827         @Override
 828         protected void runPhase(Env&lt;AttrContext&gt; env) {
 829             JCClassDecl tree = env.enclClass;
<span class="line-modified"> 830             if (tree.sym.type != syms.objectType) {</span>
<span class="line-modified"> 831                 List&lt;Type&gt; directSuperTypes = (types.supertype(tree.sym.type) != null ?</span>
<span class="line-modified"> 832                         List.of(types.supertype(tree.sym.type)) :</span>
<span class="line-modified"> 833                         List.nil());</span>
<span class="line-modified"> 834                 directSuperTypes = directSuperTypes.appendList(types.interfaces(tree.sym.type));</span>
<span class="line-modified"> 835                 List&lt;Type&gt; directSuperTypesInSameCU = directSuperTypes.stream()</span>
<span class="line-modified"> 836                         .filter(supertype -&gt;</span>
<span class="line-modified"> 837                                 TreeInfo.declarationFor(supertype.tsym, env.toplevel) != null &amp;&amp;</span>
<span class="line-modified"> 838                                         TreeInfo.declarationFor(tree.sym.outermostClass(), env.toplevel) != null)</span>
<span class="line-modified"> 839                         .collect(List.collector());</span>
<span class="line-removed"> 840                 Set&lt;Type&gt; explicitlySealedSuperTypesInCU = directSuperTypesInSameCU.stream()</span>
<span class="line-removed"> 841                             .filter(type -&gt; type != tree.sym.type &amp;&amp;</span>
<span class="line-removed"> 842                                     type.tsym != null &amp;&amp;</span>
<span class="line-removed"> 843                                     type.tsym.isSealed()).collect(Collectors.toSet());</span>
<span class="line-removed"> 844 </span>
<span class="line-removed"> 845                 boolean anySuperInSameCUIsSealed = !explicitlySealedSuperTypesInCU.isEmpty();</span>
<span class="line-removed"> 846                 if (anySuperInSameCUIsSealed) {</span>
<span class="line-removed"> 847                     java.util.Set&lt;ClassSymbol&gt; potentiallySealedSuperTypes = superTypeSymsInASealedHierarchy(tree.sym, env, true);</span>
<span class="line-removed"> 848                     if (!potentiallySealedSuperTypes.isEmpty()) {</span>
<span class="line-removed"> 849                         for (ClassSymbol supertype : potentiallySealedSuperTypes) {</span>
<span class="line-removed"> 850                             if (!supertype.permitted.contains(tree.sym.type.tsym)) {</span>
<span class="line-removed"> 851                                 if (!supertype.isPermittedExplicit) {</span>
<span class="line-removed"> 852                                     if (!tree.sym.isAnonymous() || tree.sym.isEnum()) {</span>
<span class="line-removed"> 853                                         supertype.permitted = supertype.permitted.append(tree.sym);</span>
<span class="line-removed"> 854                                         tree.sym.hasSealedSuperInSameCU = true;</span>
<span class="line-removed"> 855                                     }</span>
<span class="line-removed"> 856                                 }</span>
<span class="line-removed"> 857                             } else {</span>
<span class="line-removed"> 858                                 tree.sym.hasSealedSuperInSameCU = true;</span>
<span class="line-removed"> 859                             }</span>
 860                         }
 861                     }
 862                 }
<span class="line-removed"> 863 </span>
<span class="line-removed"> 864                 java.util.Set&lt;ClassSymbol&gt; sealedSuperSyms = superTypeSymsInASealedHierarchy(tree.sym, env, false);</span>
<span class="line-removed"> 865                 boolean hasSuperTypesInSealedHierarchy = !sealedSuperSyms.isEmpty();</span>
<span class="line-removed"> 866                 if (hasSuperTypesInSealedHierarchy) {</span>
<span class="line-removed"> 867                     tree.sym.sealedSupers = sealedSuperSyms;</span>
<span class="line-removed"> 868                 }</span>
<span class="line-removed"> 869             }</span>
<span class="line-removed"> 870         }</span>
<span class="line-removed"> 871 </span>
<span class="line-removed"> 872         JCTree findTreeReferringSym(JCClassDecl tree, Symbol sym) {</span>
<span class="line-removed"> 873             if (tree.extending != null &amp;&amp; tree.extending.type.tsym == sym) {</span>
<span class="line-removed"> 874                 return tree.extending;</span>
<span class="line-removed"> 875             }</span>
<span class="line-removed"> 876             for (JCExpression implementing: tree.implementing) {</span>
<span class="line-removed"> 877                 if (implementing.type.tsym == sym) {</span>
<span class="line-removed"> 878                     return implementing;</span>
<span class="line-removed"> 879                 }</span>
 880             }
<span class="line-removed"> 881             return tree;</span>
<span class="line-removed"> 882         }</span>
<span class="line-removed"> 883 </span>
<span class="line-removed"> 884         boolean areInSameCU(Symbol sym1, Symbol sym2, Env&lt;AttrContext&gt; env) {</span>
<span class="line-removed"> 885             return TreeInfo.declarationFor(sym1, env.toplevel) != null &amp;&amp;</span>
<span class="line-removed"> 886                     TreeInfo.declarationFor(sym2.outermostClass(), env.toplevel) != null;</span>
 887         }
 888 
<span class="line-removed"> 889         java.util.Set&lt;ClassSymbol&gt; superTypeSymsInASealedHierarchy(ClassSymbol csym, Env&lt;AttrContext&gt; env, boolean inSameCUOnly) {</span>
<span class="line-removed"> 890             if (csym == null) {</span>
<span class="line-removed"> 891                 return Set.of();</span>
<span class="line-removed"> 892             }</span>
<span class="line-removed"> 893 </span>
<span class="line-removed"> 894             Type supertype = csym.type != null ?</span>
<span class="line-removed"> 895                     types.supertype(csym.type) : null;</span>
<span class="line-removed"> 896             java.util.Set&lt;ClassSymbol&gt; supertypes = new HashSet&lt;&gt;();</span>
<span class="line-removed"> 897 </span>
<span class="line-removed"> 898             if (supertype != null &amp;&amp;</span>
<span class="line-removed"> 899                     supertype.tsym != null &amp;&amp;</span>
<span class="line-removed"> 900                     supertype != syms.objectType &amp;&amp;</span>
<span class="line-removed"> 901                     supertype.tsym != null &amp;&amp;</span>
<span class="line-removed"> 902                     !supertype.tsym.isNonSealed() &amp;&amp;</span>
<span class="line-removed"> 903                     (inSameCUOnly &amp;&amp; areInSameCU(csym, supertype.tsym, env) || !inSameCUOnly)) {</span>
<span class="line-removed"> 904                 supertypes.add((ClassSymbol) supertype.tsym);</span>
<span class="line-removed"> 905             }</span>
<span class="line-removed"> 906 </span>
<span class="line-removed"> 907             if (csym.getInterfaces() != null) {</span>
<span class="line-removed"> 908                 for (Type intf : csym.getInterfaces()) {</span>
<span class="line-removed"> 909                     if (intf != null &amp;&amp; intf.tsym != null &amp;&amp; intf.tsym != null &amp;&amp; !intf.tsym.isNonSealed() &amp;&amp;</span>
<span class="line-removed"> 910                             (inSameCUOnly &amp;&amp; areInSameCU(csym, intf.tsym, env) || !inSameCUOnly)) {</span>
<span class="line-removed"> 911                         supertypes.add((ClassSymbol) intf.tsym);</span>
<span class="line-removed"> 912                     }</span>
<span class="line-removed"> 913                 }</span>
<span class="line-removed"> 914             }</span>
<span class="line-removed"> 915 </span>
<span class="line-removed"> 916             for (ClassSymbol sup : new ArrayList&lt;&gt;(supertypes)) {</span>
<span class="line-removed"> 917                 if (sup instanceof ClassSymbol) {</span>
<span class="line-removed"> 918                     java.util.Set&lt;ClassSymbol&gt; supers = superTypeSymsInASealedHierarchy(sup, env, inSameCUOnly);</span>
<span class="line-removed"> 919                     if ((supers == null || supers.isEmpty()) &amp;&amp; !sup.isSealed()) {</span>
<span class="line-removed"> 920                         supertypes.remove(sup);</span>
<span class="line-removed"> 921                     }</span>
<span class="line-removed"> 922                 } else {</span>
<span class="line-removed"> 923                     supertypes.remove(sup);</span>
<span class="line-removed"> 924                 }</span>
<span class="line-removed"> 925             }</span>
<span class="line-removed"> 926 </span>
<span class="line-removed"> 927             return supertypes;</span>
<span class="line-removed"> 928         }</span>
 929     }
 930 
 931     private final class HeaderPhase extends AbstractHeaderPhase {
 932 
 933         public HeaderPhase() {
 934             super(CompletionCause.HEADER_PHASE, new RecordPhase());
 935         }
 936 
 937         @Override
 938         protected void runPhase(Env&lt;AttrContext&gt; env) {
 939             JCClassDecl tree = env.enclClass;
 940             ClassSymbol sym = tree.sym;
 941             ClassType ct = (ClassType)sym.type;
 942 
 943             // create an environment for evaluating the base clauses
 944             Env&lt;AttrContext&gt; baseEnv = baseEnv(tree, env);
 945 
 946             if (tree.extending != null)
 947                 annotate.queueScanTreeAndTypeAnnotate(tree.extending, baseEnv, sym, tree.pos());
 948             for (JCExpression impl : tree.implementing)
</pre>
</td>
<td>
<hr />
<pre>
  43 import com.sun.tools.javac.comp.Annotate.AnnotationTypeMetadata;
  44 import com.sun.tools.javac.tree.*;
  45 import com.sun.tools.javac.util.*;
  46 import com.sun.tools.javac.util.DefinedBy.Api;
  47 
  48 import com.sun.tools.javac.code.Symbol.*;
  49 import com.sun.tools.javac.code.Type.*;
  50 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  51 import com.sun.tools.javac.tree.JCTree.*;
  52 
  53 import static com.sun.tools.javac.code.Flags.*;
  54 import static com.sun.tools.javac.code.Flags.ANNOTATION;
  55 import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;
  56 import static com.sun.tools.javac.code.Kinds.Kind.*;
  57 import static com.sun.tools.javac.code.TypeTag.CLASS;
  58 import static com.sun.tools.javac.code.TypeTag.ERROR;
  59 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  60 
  61 import static com.sun.tools.javac.code.TypeTag.*;
  62 import static com.sun.tools.javac.code.TypeTag.BOT;
<span class="line-added">  63 import com.sun.tools.javac.comp.AttrContext;</span>
<span class="line-added">  64 import com.sun.tools.javac.comp.Env;</span>
  65 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  66 
  67 import com.sun.tools.javac.util.Dependencies.CompletionCause;
  68 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
  69 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  70 
  71 /** This is the second phase of Enter, in which classes are completed
  72  *  by resolving their headers and entering their members in the into
  73  *  the class scope. See Enter for an overall overview.
  74  *
  75  *  This class uses internal phases to process the classes. When a phase
  76  *  processes classes, the lower phases are not invoked until all classes
  77  *  pass through the current phase. Note that it is possible that upper phases
  78  *  are run due to recursive completion. The internal phases are:
  79  *  - ImportPhase: shallow pass through imports, adds information about imports
  80  *                 the NamedImportScope and StarImportScope, but avoids queries
  81  *                 about class hierarchy.
  82  *  - HierarchyPhase: resolves the supertypes of the given class. Does not handle
  83  *                    type parameters of the class or type argument of the supertypes.
  84  *  - HeaderPhase: finishes analysis of the header of the given class by resolving
</pre>
<hr />
<pre>
 812                 sym.completer = this;
 813                 return ;
 814             }
 815 
 816             Env&lt;AttrContext&gt; env = typeEnvs.get((ClassSymbol) sym);
 817 
 818             super.doCompleteEnvs(List.of(env));
 819         }
 820 
 821     }
 822 
 823     private final class PermitsPhase extends AbstractHeaderPhase {
 824 
 825         public PermitsPhase() {
 826             super(CompletionCause.HIERARCHY_PHASE, new HeaderPhase());
 827         }
 828 
 829         @Override
 830         protected void runPhase(Env&lt;AttrContext&gt; env) {
 831             JCClassDecl tree = env.enclClass;
<span class="line-modified"> 832             if (!tree.sym.isAnonymous() || tree.sym.isEnum()) {</span>
<span class="line-modified"> 833                 for (Type supertype : types.directSupertypes(tree.sym.type)) {</span>
<span class="line-modified"> 834                     if (supertype.tsym.kind == TYP) {</span>
<span class="line-modified"> 835                         ClassSymbol supClass = (ClassSymbol) supertype.tsym;</span>
<span class="line-modified"> 836                         Env&lt;AttrContext&gt; supClassEnv = enter.getEnv(supClass);</span>
<span class="line-modified"> 837                         if (supClass.isSealed() &amp;&amp;</span>
<span class="line-modified"> 838                             !supClass.isPermittedExplicit &amp;&amp;</span>
<span class="line-modified"> 839                             supClassEnv != null &amp;&amp;</span>
<span class="line-modified"> 840                             supClassEnv.toplevel == env.toplevel) {</span>
<span class="line-modified"> 841                             supClass.permitted = supClass.permitted.append(tree.sym);</span>




















 842                         }
 843                     }
 844                 }

















 845             }






 846         }
 847 








































 848     }
 849 
 850     private final class HeaderPhase extends AbstractHeaderPhase {
 851 
 852         public HeaderPhase() {
 853             super(CompletionCause.HEADER_PHASE, new RecordPhase());
 854         }
 855 
 856         @Override
 857         protected void runPhase(Env&lt;AttrContext&gt; env) {
 858             JCClassDecl tree = env.enclClass;
 859             ClassSymbol sym = tree.sym;
 860             ClassType ct = (ClassType)sym.type;
 861 
 862             // create an environment for evaluating the base clauses
 863             Env&lt;AttrContext&gt; baseEnv = baseEnv(tree, env);
 864 
 865             if (tree.extending != null)
 866                 annotate.queueScanTreeAndTypeAnnotate(tree.extending, baseEnv, sym, tree.pos());
 867             for (JCExpression impl : tree.implementing)
</pre>
</td>
</tr>
</table>
<center><a href="Attr.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../../../test/langtools/tools/javac/sealed/SealedDiffConfigurationsTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Attr.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../code/Symbol.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TypeEnter.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Attr.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
5002             if (c.owner.kind == TYP &amp;&amp; c.owner.type.hasTag(CLASS))
5003                 attribClass((ClassSymbol)c.owner);
5004         }
5005 
5006         // The previous operations might have attributed the current class
5007         // if there was a cycle. So we test first whether the class is still
5008         // UNATTRIBUTED.
5009         if ((c.flags_field &amp; UNATTRIBUTED) != 0) {
5010             c.flags_field &amp;= ~UNATTRIBUTED;
5011 
5012             // Get environment current at the point of class definition.
5013             Env&lt;AttrContext&gt; env = typeEnvs.get(c);
5014 
5015             if (c.isSealed() &amp;&amp;
5016                     !c.isEnum() &amp;&amp;
5017                     !c.isPermittedExplicit &amp;&amp;
5018                     c.permitted.isEmpty()) {
5019                 log.error(env.tree, Errors.SealedTypeMustHaveSubtypes);
5020             }
5021 
<span class="line-modified">5022             if (c.isSealed() &amp;&amp; !c.permitted.isEmpty()) {</span>
5023                 Set&lt;Symbol&gt; permittedTypes = new HashSet&lt;&gt;();
5024                 boolean sealedInUnnamed = c.packge().modle == syms.unnamedModule || c.packge().modle == syms.noModule;
5025                 for (Symbol subTypeSym : c.permitted) {
5026                     boolean isTypeVar = false;
5027                     if (subTypeSym.type.getTag() == TYPEVAR) {
<span class="line-modified">5028                         isTypeVar = true;</span>
5029                         log.error(TreeInfo.declarationFor(subTypeSym, env.tree), Errors.TypeVarListedInPermits);
5030                     }
5031                     if (subTypeSym.isAnonymous() &amp;&amp; !c.isEnum()) {
5032                         log.error(TreeInfo.declarationFor(subTypeSym, env.tree), Errors.CantInheritFromSealed(c));
5033                     }
5034                     if (permittedTypes.contains(subTypeSym)) {
5035                         log.error(TreeInfo.declarationFor(subTypeSym, env.tree), Errors.DuplicatedTypeInPermits(subTypeSym.type));
5036                     } else {
5037                         permittedTypes.add(subTypeSym);
5038                     }
5039                     if (sealedInUnnamed) {
5040                         if (subTypeSym.packge() != c.packge()) {
5041                             log.error(TreeInfo.declarationFor(subTypeSym, env.tree), Errors.CantInheritFromSealed(c));
5042                         }
5043                     } else if (subTypeSym.packge().modle != c.packge().modle) {
5044                         log.error(TreeInfo.declarationFor(subTypeSym, env.tree), Errors.CantInheritFromSealed(c));
5045                     }
5046                     if (subTypeSym == c.type.tsym || types.isSuperType(subTypeSym.type, c.type)) {
5047                         log.error(TreeInfo.declarationFor(subTypeSym, ((JCClassDecl)env.tree).permitting),
5048                                 Errors.TypeListedInPermitsIsSameClassOrSupertype(subTypeSym == c.type.tsym ?
5049                                         Fragments.SameClass : Fragments.Supertype));
<span class="line-modified">5050                     } else {</span>
<span class="line-modified">5051                         if (!isTypeVar &amp;&amp; !((ClassSymbol)subTypeSym).sealedSupers.contains(c.type.tsym)) {</span>



5052                             log.error(TreeInfo.declarationFor(subTypeSym, env.tree),
5053                                     Errors.SubtypeListedInPermitsDoesntExtendSealed(subTypeSym.type, c.type));
5054                         }
5055                     }
5056                 }
5057             }
5058 
<span class="line-modified">5059             if (!c.sealedSupers.isEmpty() &amp;&amp; c.isLocal() &amp;&amp; !c.isEnum()) {</span>
<span class="line-modified">5060                 log.error(TreeInfo.declarationFor(c, env.tree), Errors.LocalClassesCantExtendSealed);</span>
<span class="line-modified">5061             }</span>











5062 
<span class="line-modified">5063             if (!c.sealedSupers.isEmpty()) {</span>
<span class="line-removed">5064                 for (ClassSymbol supertypeSym : c.sealedSupers) {</span>
5065                     if (!supertypeSym.permitted.contains(c.type.tsym)) {
<span class="line-modified">5066                         if (supertypeSym.isPermittedExplicit) {</span>
<span class="line-removed">5067                             log.error(TreeInfo.declarationFor(c.type.tsym, env.tree), Errors.CantInheritFromSealed(supertypeSym));</span>
<span class="line-removed">5068                         }</span>
5069                     }
5070                 }
5071                 if (!c.isNonSealed() &amp;&amp; !c.isFinal() &amp;&amp; !c.isSealed()) {
5072                     log.error(TreeInfo.declarationFor(c, env.tree), Errors.NonSealedSealedOrFinalExpected);
5073                 }
<span class="line-removed">5074 </span>
<span class="line-removed">5075                 if (!c.hasSealedSuperInSameCU) {</span>
<span class="line-removed">5076                     // that supertype most have a permits clause allowing this class to extend it</span>
<span class="line-removed">5077                     List&lt;Type&gt; closureOutsideOfSameCU = types.closure(c.type).stream()</span>
<span class="line-removed">5078                             .filter(supertype -&gt;</span>
<span class="line-removed">5079                                     TreeInfo.declarationFor(supertype.tsym, env.toplevel) == null ||</span>
<span class="line-removed">5080                                             TreeInfo.declarationFor(c.outermostClass(), env.toplevel) == null)</span>
<span class="line-removed">5081                             .collect(List.collector());</span>
<span class="line-removed">5082                     Set&lt;Type&gt; explicitlySealedSuperTypesOutsideOfCU = closureOutsideOfSameCU.stream()</span>
<span class="line-removed">5083                             .filter(type -&gt; type != c.type &amp;&amp; type.tsym.isSealed()).collect(Collectors.toSet());</span>
<span class="line-removed">5084                     for (Type supertype : explicitlySealedSuperTypesOutsideOfCU) {</span>
<span class="line-removed">5085                         if (!((ClassSymbol)supertype.tsym).permitted.contains(c.type.tsym)) {</span>
<span class="line-removed">5086                             log.error(TreeInfo.declarationFor(c, env.tree), Errors.CantInheritFromSealed(supertype.tsym));</span>
<span class="line-removed">5087                         }</span>
<span class="line-removed">5088                     }</span>
<span class="line-removed">5089 </span>
<span class="line-removed">5090                     if (!c.isNonSealed() &amp;&amp; !c.isFinal() &amp;&amp; !c.isSealed()) {</span>
<span class="line-removed">5091                         log.error(TreeInfo.declarationFor(c, env.tree), Errors.NonSealedSealedOrFinalExpected);</span>
<span class="line-removed">5092                     }</span>
<span class="line-removed">5093                 }</span>
<span class="line-removed">5094             }</span>
<span class="line-removed">5095 </span>
<span class="line-removed">5096             if ((c.flags_field &amp; Flags.NON_SEALED) != 0 &amp;&amp; c.sealedSupers.isEmpty()) {</span>
<span class="line-removed">5097                 log.error(TreeInfo.declarationFor(c, env.tree), Errors.NonSealedWithNoSealedSupertype);</span>
5098             }
5099 
5100             // The info.lint field in the envs stored in typeEnvs is deliberately uninitialized,
5101             // because the annotations were not available at the time the env was created. Therefore,
5102             // we look up the environment chain for the first enclosing environment for which the
5103             // lint value is set. Typically, this is the parent env, but might be further if there
5104             // are any envs created as a result of TypeParameter nodes.
5105             Env&lt;AttrContext&gt; lintEnv = env;
5106             while (lintEnv.info.lint == null)
5107                 lintEnv = lintEnv.next;
5108 
5109             // Having found the enclosing lint value, we can initialize the lint value for this class
5110             env.info.lint = lintEnv.info.lint.augment(c);
5111 
5112             Lint prevLint = chk.setLint(env.info.lint);
5113             JavaFileObject prev = log.useSource(c.sourcefile);
5114             ResultInfo prevReturnRes = env.info.returnResult;
5115 
5116             try {
5117                 deferredLintHandler.flush(env.tree);
</pre>
</td>
<td>
<hr />
<pre>
5002             if (c.owner.kind == TYP &amp;&amp; c.owner.type.hasTag(CLASS))
5003                 attribClass((ClassSymbol)c.owner);
5004         }
5005 
5006         // The previous operations might have attributed the current class
5007         // if there was a cycle. So we test first whether the class is still
5008         // UNATTRIBUTED.
5009         if ((c.flags_field &amp; UNATTRIBUTED) != 0) {
5010             c.flags_field &amp;= ~UNATTRIBUTED;
5011 
5012             // Get environment current at the point of class definition.
5013             Env&lt;AttrContext&gt; env = typeEnvs.get(c);
5014 
5015             if (c.isSealed() &amp;&amp;
5016                     !c.isEnum() &amp;&amp;
5017                     !c.isPermittedExplicit &amp;&amp;
5018                     c.permitted.isEmpty()) {
5019                 log.error(env.tree, Errors.SealedTypeMustHaveSubtypes);
5020             }
5021 
<span class="line-modified">5022             if (c.isSealed()) {</span>
5023                 Set&lt;Symbol&gt; permittedTypes = new HashSet&lt;&gt;();
5024                 boolean sealedInUnnamed = c.packge().modle == syms.unnamedModule || c.packge().modle == syms.noModule;
5025                 for (Symbol subTypeSym : c.permitted) {
5026                     boolean isTypeVar = false;
5027                     if (subTypeSym.type.getTag() == TYPEVAR) {
<span class="line-modified">5028                         isTypeVar = true; //error recovery</span>
5029                         log.error(TreeInfo.declarationFor(subTypeSym, env.tree), Errors.TypeVarListedInPermits);
5030                     }
5031                     if (subTypeSym.isAnonymous() &amp;&amp; !c.isEnum()) {
5032                         log.error(TreeInfo.declarationFor(subTypeSym, env.tree), Errors.CantInheritFromSealed(c));
5033                     }
5034                     if (permittedTypes.contains(subTypeSym)) {
5035                         log.error(TreeInfo.declarationFor(subTypeSym, env.tree), Errors.DuplicatedTypeInPermits(subTypeSym.type));
5036                     } else {
5037                         permittedTypes.add(subTypeSym);
5038                     }
5039                     if (sealedInUnnamed) {
5040                         if (subTypeSym.packge() != c.packge()) {
5041                             log.error(TreeInfo.declarationFor(subTypeSym, env.tree), Errors.CantInheritFromSealed(c));
5042                         }
5043                     } else if (subTypeSym.packge().modle != c.packge().modle) {
5044                         log.error(TreeInfo.declarationFor(subTypeSym, env.tree), Errors.CantInheritFromSealed(c));
5045                     }
5046                     if (subTypeSym == c.type.tsym || types.isSuperType(subTypeSym.type, c.type)) {
5047                         log.error(TreeInfo.declarationFor(subTypeSym, ((JCClassDecl)env.tree).permitting),
5048                                 Errors.TypeListedInPermitsIsSameClassOrSupertype(subTypeSym == c.type.tsym ?
5049                                         Fragments.SameClass : Fragments.Supertype));
<span class="line-modified">5050                     } else if (!isTypeVar) {</span>
<span class="line-modified">5051                         boolean thisIsASuper = types.directSupertypes(subTypeSym.type)</span>
<span class="line-added">5052                                                     .stream()</span>
<span class="line-added">5053                                                     .anyMatch(d -&gt; d.tsym == c);</span>
<span class="line-added">5054                         if (!thisIsASuper) {</span>
5055                             log.error(TreeInfo.declarationFor(subTypeSym, env.tree),
5056                                     Errors.SubtypeListedInPermitsDoesntExtendSealed(subTypeSym.type, c.type));
5057                         }
5058                     }
5059                 }
5060             }
5061 
<span class="line-modified">5062             List&lt;ClassSymbol&gt; sealedSupers = types.directSupertypes(c.type)</span>
<span class="line-modified">5063                                                   .stream()</span>
<span class="line-modified">5064                                                   .filter(s -&gt; s.tsym.isSealed())</span>
<span class="line-added">5065                                                   .map(s -&gt; (ClassSymbol) s.tsym)</span>
<span class="line-added">5066                                                   .collect(List.collector());</span>
<span class="line-added">5067 </span>
<span class="line-added">5068             if (sealedSupers.isEmpty()) {</span>
<span class="line-added">5069                 if ((c.flags_field &amp; Flags.NON_SEALED) != 0) {</span>
<span class="line-added">5070                     log.error(TreeInfo.declarationFor(c, env.tree), Errors.NonSealedWithNoSealedSupertype);</span>
<span class="line-added">5071                 }</span>
<span class="line-added">5072             } else {</span>
<span class="line-added">5073                 if (c.isLocal() &amp;&amp; !c.isEnum()) {</span>
<span class="line-added">5074                     log.error(TreeInfo.declarationFor(c, env.tree), Errors.LocalClassesCantExtendSealed);</span>
<span class="line-added">5075                 }</span>
5076 
<span class="line-modified">5077                 for (ClassSymbol supertypeSym : sealedSupers) {</span>

5078                     if (!supertypeSym.permitted.contains(c.type.tsym)) {
<span class="line-modified">5079                         log.error(TreeInfo.declarationFor(c.type.tsym, env.tree), Errors.CantInheritFromSealed(supertypeSym));</span>


5080                     }
5081                 }
5082                 if (!c.isNonSealed() &amp;&amp; !c.isFinal() &amp;&amp; !c.isSealed()) {
5083                     log.error(TreeInfo.declarationFor(c, env.tree), Errors.NonSealedSealedOrFinalExpected);
5084                 }
























5085             }
5086 
5087             // The info.lint field in the envs stored in typeEnvs is deliberately uninitialized,
5088             // because the annotations were not available at the time the env was created. Therefore,
5089             // we look up the environment chain for the first enclosing environment for which the
5090             // lint value is set. Typically, this is the parent env, but might be further if there
5091             // are any envs created as a result of TypeParameter nodes.
5092             Env&lt;AttrContext&gt; lintEnv = env;
5093             while (lintEnv.info.lint == null)
5094                 lintEnv = lintEnv.next;
5095 
5096             // Having found the enclosing lint value, we can initialize the lint value for this class
5097             env.info.lint = lintEnv.info.lint.augment(c);
5098 
5099             Lint prevLint = chk.setLint(env.info.lint);
5100             JavaFileObject prev = log.useSource(c.sourcefile);
5101             ResultInfo prevReturnRes = env.info.returnResult;
5102 
5103             try {
5104                 deferredLintHandler.flush(env.tree);
</pre>
</td>
</tr>
</table>
<center><a href="../code/Symbol.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TypeEnter.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
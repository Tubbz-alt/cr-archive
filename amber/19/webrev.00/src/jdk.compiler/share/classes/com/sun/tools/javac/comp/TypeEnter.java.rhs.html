<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TypeEnter.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.comp;
  27 
  28 import java.util.ArrayList;
  29 import java.util.HashSet;
  30 import java.util.Set;
  31 import java.util.function.BiConsumer;
  32 import java.util.stream.Collectors;
  33 
  34 import javax.tools.JavaFileObject;
  35 
  36 import com.sun.tools.javac.code.*;
  37 import com.sun.tools.javac.code.Lint.LintCategory;
  38 import com.sun.tools.javac.code.Scope.ImportFilter;
  39 import com.sun.tools.javac.code.Scope.NamedImportScope;
  40 import com.sun.tools.javac.code.Scope.StarImportScope;
  41 import com.sun.tools.javac.code.Scope.WriteableScope;
  42 import com.sun.tools.javac.code.Source.Feature;
  43 import com.sun.tools.javac.comp.Annotate.AnnotationTypeMetadata;
  44 import com.sun.tools.javac.tree.*;
  45 import com.sun.tools.javac.util.*;
  46 import com.sun.tools.javac.util.DefinedBy.Api;
  47 
  48 import com.sun.tools.javac.code.Symbol.*;
  49 import com.sun.tools.javac.code.Type.*;
  50 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  51 import com.sun.tools.javac.tree.JCTree.*;
  52 
  53 import static com.sun.tools.javac.code.Flags.*;
  54 import static com.sun.tools.javac.code.Flags.ANNOTATION;
  55 import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;
  56 import static com.sun.tools.javac.code.Kinds.Kind.*;
  57 import static com.sun.tools.javac.code.TypeTag.CLASS;
  58 import static com.sun.tools.javac.code.TypeTag.ERROR;
  59 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  60 
  61 import static com.sun.tools.javac.code.TypeTag.*;
  62 import static com.sun.tools.javac.code.TypeTag.BOT;
<a name="1" id="anc1"></a><span class="line-added">  63 import com.sun.tools.javac.comp.AttrContext;</span>
<span class="line-added">  64 import com.sun.tools.javac.comp.Env;</span>
  65 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  66 
  67 import com.sun.tools.javac.util.Dependencies.CompletionCause;
  68 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
  69 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  70 
  71 /** This is the second phase of Enter, in which classes are completed
  72  *  by resolving their headers and entering their members in the into
  73  *  the class scope. See Enter for an overall overview.
  74  *
  75  *  This class uses internal phases to process the classes. When a phase
  76  *  processes classes, the lower phases are not invoked until all classes
  77  *  pass through the current phase. Note that it is possible that upper phases
  78  *  are run due to recursive completion. The internal phases are:
  79  *  - ImportPhase: shallow pass through imports, adds information about imports
  80  *                 the NamedImportScope and StarImportScope, but avoids queries
  81  *                 about class hierarchy.
  82  *  - HierarchyPhase: resolves the supertypes of the given class. Does not handle
  83  *                    type parameters of the class or type argument of the supertypes.
  84  *  - HeaderPhase: finishes analysis of the header of the given class by resolving
  85  *                 type parameters, attributing supertypes including type arguments
  86  *                 and scheduling full annotation attribution. This phase also adds
  87  *                 a synthetic default constructor if needed and synthetic &quot;this&quot; field.
  88  *  - MembersPhase: resolves headers for fields, methods and constructors in the given class.
  89  *                  Also generates synthetic enum members.
  90  *
  91  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  92  *  If you write code that depends on this, you do so at your own risk.
  93  *  This code and its internal interfaces are subject to change or
  94  *  deletion without notice.&lt;/b&gt;
  95  */
  96 public class TypeEnter implements Completer {
  97     protected static final Context.Key&lt;TypeEnter&gt; typeEnterKey = new Context.Key&lt;&gt;();
  98 
  99     /** A switch to determine whether we check for package/class conflicts
 100      */
 101     final static boolean checkClash = true;
 102 
 103     private final Names names;
 104     private final Enter enter;
 105     private final MemberEnter memberEnter;
 106     private final Log log;
 107     private final Check chk;
 108     private final Attr attr;
 109     private final Symtab syms;
 110     private final TreeMaker make;
 111     private final Todo todo;
 112     private final Annotate annotate;
 113     private final TypeAnnotations typeAnnotations;
 114     private final Types types;
 115     private final JCDiagnostic.Factory diags;
 116     private final DeferredLintHandler deferredLintHandler;
 117     private final Lint lint;
 118     private final TypeEnvs typeEnvs;
 119     private final Dependencies dependencies;
 120 
 121     public static TypeEnter instance(Context context) {
 122         TypeEnter instance = context.get(typeEnterKey);
 123         if (instance == null)
 124             instance = new TypeEnter(context);
 125         return instance;
 126     }
 127 
 128     protected TypeEnter(Context context) {
 129         context.put(typeEnterKey, this);
 130         names = Names.instance(context);
 131         enter = Enter.instance(context);
 132         memberEnter = MemberEnter.instance(context);
 133         log = Log.instance(context);
 134         chk = Check.instance(context);
 135         attr = Attr.instance(context);
 136         syms = Symtab.instance(context);
 137         make = TreeMaker.instance(context);
 138         todo = Todo.instance(context);
 139         annotate = Annotate.instance(context);
 140         typeAnnotations = TypeAnnotations.instance(context);
 141         types = Types.instance(context);
 142         diags = JCDiagnostic.Factory.instance(context);
 143         deferredLintHandler = DeferredLintHandler.instance(context);
 144         lint = Lint.instance(context);
 145         typeEnvs = TypeEnvs.instance(context);
 146         dependencies = Dependencies.instance(context);
 147         Source source = Source.instance(context);
 148         allowTypeAnnos = Feature.TYPE_ANNOTATIONS.allowedInSource(source);
 149         allowDeprecationOnImport = Feature.DEPRECATION_ON_IMPORT.allowedInSource(source);
 150     }
 151 
 152     /** Switch: support type annotations.
 153      */
 154     boolean allowTypeAnnos;
 155 
 156     /**
 157      * Switch: should deprecation warnings be issued on import
 158      */
 159     boolean allowDeprecationOnImport;
 160 
 161     /** A flag to disable completion from time to time during member
 162      *  enter, as we only need to look up types.  This avoids
 163      *  unnecessarily deep recursion.
 164      */
 165     boolean completionEnabled = true;
 166 
 167     /* Verify Imports:
 168      */
 169     protected void ensureImportsChecked(List&lt;JCCompilationUnit&gt; trees) {
 170         // if there remain any unimported toplevels (these must have
 171         // no classes at all), process their import statements as well.
 172         for (JCCompilationUnit tree : trees) {
 173             if (!tree.starImportScope.isFilled()) {
 174                 Env&lt;AttrContext&gt; topEnv = enter.topLevelEnv(tree);
 175                 finishImports(tree, () -&gt; { completeClass.resolveImports(tree, topEnv); });
 176             }
 177         }
 178     }
 179 
 180 /* ********************************************************************
 181  * Source completer
 182  *********************************************************************/
 183 
 184     /** Complete entering a class.
 185      *  @param sym         The symbol of the class to be completed.
 186      */
 187     @Override
 188     public void complete(Symbol sym) throws CompletionFailure {
 189         // Suppress some (recursive) MemberEnter invocations
 190         if (!completionEnabled) {
 191             // Re-install same completer for next time around and return.
 192             Assert.check((sym.flags() &amp; Flags.COMPOUND) == 0);
 193             sym.completer = this;
 194             return;
 195         }
 196 
 197         try {
 198             annotate.blockAnnotations();
 199             sym.flags_field |= UNATTRIBUTED;
 200 
 201             List&lt;Env&lt;AttrContext&gt;&gt; queue;
 202 
 203             dependencies.push((ClassSymbol) sym, CompletionCause.MEMBER_ENTER);
 204             try {
 205                 queue = completeClass.completeEnvs(List.of(typeEnvs.get((ClassSymbol) sym)));
 206             } finally {
 207                 dependencies.pop();
 208             }
 209 
 210             if (!queue.isEmpty()) {
 211                 Set&lt;JCCompilationUnit&gt; seen = new HashSet&lt;&gt;();
 212 
 213                 for (Env&lt;AttrContext&gt; env : queue) {
 214                     if (env.toplevel.defs.contains(env.enclClass) &amp;&amp; seen.add(env.toplevel)) {
 215                         finishImports(env.toplevel, () -&gt; {});
 216                     }
 217                 }
 218             }
 219         } finally {
 220             annotate.unblockAnnotations();
 221         }
 222     }
 223 
 224     void finishImports(JCCompilationUnit toplevel, Runnable resolve) {
 225         JavaFileObject prev = log.useSource(toplevel.sourcefile);
 226         try {
 227             resolve.run();
 228             chk.checkImportsUnique(toplevel);
 229             chk.checkImportsResolvable(toplevel);
 230             chk.checkImportedPackagesObservable(toplevel);
 231             toplevel.namedImportScope.finalizeScope();
 232             toplevel.starImportScope.finalizeScope();
 233         } catch (CompletionFailure cf) {
 234             chk.completionError(toplevel.pos(), cf);
 235         } finally {
 236             log.useSource(prev);
 237         }
 238     }
 239 
 240     abstract class Phase {
 241         private final ListBuffer&lt;Env&lt;AttrContext&gt;&gt; queue = new ListBuffer&lt;&gt;();
 242         private final Phase next;
 243         private final CompletionCause phaseName;
 244 
 245         Phase(CompletionCause phaseName, Phase next) {
 246             this.phaseName = phaseName;
 247             this.next = next;
 248         }
 249 
 250         public final List&lt;Env&lt;AttrContext&gt;&gt; completeEnvs(List&lt;Env&lt;AttrContext&gt;&gt; envs) {
 251             boolean firstToComplete = queue.isEmpty();
 252 
 253             Phase prevTopLevelPhase = topLevelPhase;
 254             boolean success = false;
 255 
 256             try {
 257                 topLevelPhase = this;
 258                 doCompleteEnvs(envs);
 259                 success = true;
 260             } finally {
 261                 topLevelPhase = prevTopLevelPhase;
 262                 if (!success &amp;&amp; firstToComplete) {
 263                     //an exception was thrown, e.g. BreakAttr:
 264                     //the queue would become stale, clear it:
 265                     queue.clear();
 266                 }
 267             }
 268 
 269             if (firstToComplete) {
 270                 List&lt;Env&lt;AttrContext&gt;&gt; out = queue.toList();
 271 
 272                 queue.clear();
 273                 return next != null ? next.completeEnvs(out) : out;
 274             } else {
 275                 return List.nil();
 276             }
 277         }
 278 
 279         protected void doCompleteEnvs(List&lt;Env&lt;AttrContext&gt;&gt; envs) {
 280             for (Env&lt;AttrContext&gt; env : envs) {
 281                 JCClassDecl tree = (JCClassDecl)env.tree;
 282 
 283                 queue.add(env);
 284 
 285                 JavaFileObject prev = log.useSource(env.toplevel.sourcefile);
 286                 DiagnosticPosition prevLintPos = deferredLintHandler.setPos(tree.pos());
 287                 try {
 288                     dependencies.push(env.enclClass.sym, phaseName);
 289                     runPhase(env);
 290                 } catch (CompletionFailure ex) {
 291                     chk.completionError(tree.pos(), ex);
 292                 } finally {
 293                     dependencies.pop();
 294                     deferredLintHandler.setPos(prevLintPos);
 295                     log.useSource(prev);
 296                 }
 297             }
 298         }
 299 
 300         protected abstract void runPhase(Env&lt;AttrContext&gt; env);
 301     }
 302 
 303     private final ImportsPhase completeClass = new ImportsPhase();
 304     private Phase topLevelPhase;
 305 
 306     /**Analyze import clauses.
 307      */
 308     private final class ImportsPhase extends Phase {
 309 
 310         public ImportsPhase() {
 311             super(CompletionCause.IMPORTS_PHASE, new HierarchyPhase());
 312         }
 313 
 314         Env&lt;AttrContext&gt; env;
 315         ImportFilter staticImportFilter;
 316         ImportFilter typeImportFilter;
 317         BiConsumer&lt;JCImport, CompletionFailure&gt; cfHandler =
 318                 (imp, cf) -&gt; chk.completionError(imp.pos(), cf);
 319 
 320         @Override
 321         protected void runPhase(Env&lt;AttrContext&gt; env) {
 322             JCClassDecl tree = env.enclClass;
 323             ClassSymbol sym = tree.sym;
 324 
 325             // If sym is a toplevel-class, make sure any import
 326             // clauses in its source file have been seen.
 327             if (sym.owner.kind == PCK) {
 328                 resolveImports(env.toplevel, env.enclosing(TOPLEVEL));
 329                 todo.append(env);
 330             }
 331 
 332             if (sym.owner.kind == TYP)
 333                 sym.owner.complete();
 334         }
 335 
 336         private void resolveImports(JCCompilationUnit tree, Env&lt;AttrContext&gt; env) {
 337             if (tree.starImportScope.isFilled()) {
 338                 // we must have already processed this toplevel
 339                 return;
 340             }
 341 
 342             ImportFilter prevStaticImportFilter = staticImportFilter;
 343             ImportFilter prevTypeImportFilter = typeImportFilter;
 344             DiagnosticPosition prevLintPos = deferredLintHandler.immediate();
 345             Lint prevLint = chk.setLint(lint);
 346             Env&lt;AttrContext&gt; prevEnv = this.env;
 347             try {
 348                 this.env = env;
 349                 final PackageSymbol packge = env.toplevel.packge;
 350                 this.staticImportFilter =
 351                         (origin, sym) -&gt; sym.isStatic() &amp;&amp;
 352                                          chk.importAccessible(sym, packge) &amp;&amp;
 353                                          sym.isMemberOf((TypeSymbol) origin.owner, types);
 354                 this.typeImportFilter =
 355                         (origin, sym) -&gt; sym.kind == TYP &amp;&amp;
 356                                          chk.importAccessible(sym, packge);
 357 
 358                 // Import-on-demand java.lang.
 359                 PackageSymbol javaLang = syms.enterPackage(syms.java_base, names.java_lang);
 360                 if (javaLang.members().isEmpty() &amp;&amp; !javaLang.exists())
 361                     throw new FatalError(diags.fragment(Fragments.FatalErrNoJavaLang));
 362                 importAll(make.at(tree.pos()).Import(make.QualIdent(javaLang), false), javaLang, env);
 363 
 364                 JCModuleDecl decl = tree.getModuleDecl();
 365 
 366                 // Process the package def and all import clauses.
 367                 if (tree.getPackage() != null &amp;&amp; decl == null)
 368                     checkClassPackageClash(tree.getPackage());
 369 
 370                 for (JCImport imp : tree.getImports()) {
 371                     doImport(imp);
 372                 }
 373 
 374                 if (decl != null) {
 375                     //check @Deprecated:
 376                     markDeprecated(decl.sym, decl.mods.annotations, env);
 377                     // process module annotations
 378                     annotate.annotateLater(decl.mods.annotations, env, env.toplevel.modle, null);
 379                 }
 380             } finally {
 381                 this.env = prevEnv;
 382                 chk.setLint(prevLint);
 383                 deferredLintHandler.setPos(prevLintPos);
 384                 this.staticImportFilter = prevStaticImportFilter;
 385                 this.typeImportFilter = prevTypeImportFilter;
 386             }
 387         }
 388 
 389         private void checkClassPackageClash(JCPackageDecl tree) {
 390             // check that no class exists with same fully qualified name as
 391             // toplevel package
 392             if (checkClash &amp;&amp; tree.pid != null) {
 393                 Symbol p = env.toplevel.packge;
 394                 while (p.owner != syms.rootPackage) {
 395                     p.owner.complete(); // enter all class members of p
 396                     //need to lookup the owning module/package:
 397                     PackageSymbol pack = syms.lookupPackage(env.toplevel.modle, p.owner.getQualifiedName());
 398                     if (syms.getClass(pack.modle, p.getQualifiedName()) != null) {
 399                         log.error(tree.pos,
 400                                   Errors.PkgClashesWithClassOfSameName(p));
 401                     }
 402                     p = p.owner;
 403                 }
 404             }
 405             // process package annotations
 406             annotate.annotateLater(tree.annotations, env, env.toplevel.packge, null);
 407         }
 408 
 409         private void doImport(JCImport tree) {
 410             JCFieldAccess imp = (JCFieldAccess)tree.qualid;
 411             Name name = TreeInfo.name(imp);
 412 
 413             // Create a local environment pointing to this tree to disable
 414             // effects of other imports in Resolve.findGlobalType
 415             Env&lt;AttrContext&gt; localEnv = env.dup(tree);
 416 
 417             TypeSymbol p = attr.attribImportQualifier(tree, localEnv).tsym;
 418             if (name == names.asterisk) {
 419                 // Import on demand.
 420                 chk.checkCanonical(imp.selected);
 421                 if (tree.staticImport)
 422                     importStaticAll(tree, p, env);
 423                 else
 424                     importAll(tree, p, env);
 425             } else {
 426                 // Named type import.
 427                 if (tree.staticImport) {
 428                     importNamedStatic(tree, p, name, localEnv);
 429                     chk.checkCanonical(imp.selected);
 430                 } else {
 431                     Type importedType = attribImportType(imp, localEnv);
 432                     Type originalType = importedType.getOriginalType();
 433                     TypeSymbol c = originalType.hasTag(CLASS) ? originalType.tsym : importedType.tsym;
 434                     chk.checkCanonical(imp);
 435                     importNamed(tree.pos(), c, env, tree);
 436                 }
 437             }
 438         }
 439 
 440         Type attribImportType(JCTree tree, Env&lt;AttrContext&gt; env) {
 441             Assert.check(completionEnabled);
 442             Lint prevLint = chk.setLint(allowDeprecationOnImport ?
 443                     lint : lint.suppress(LintCategory.DEPRECATION, LintCategory.REMOVAL, LintCategory.PREVIEW));
 444             try {
 445                 // To prevent deep recursion, suppress completion of some
 446                 // types.
 447                 completionEnabled = false;
 448                 return attr.attribType(tree, env);
 449             } finally {
 450                 completionEnabled = true;
 451                 chk.setLint(prevLint);
 452             }
 453         }
 454 
 455         /** Import all classes of a class or package on demand.
 456          *  @param imp           The import that is being handled.
 457          *  @param tsym          The class or package the members of which are imported.
 458          *  @param env           The env in which the imported classes will be entered.
 459          */
 460         private void importAll(JCImport imp,
 461                                final TypeSymbol tsym,
 462                                Env&lt;AttrContext&gt; env) {
 463             env.toplevel.starImportScope.importAll(types, tsym.members(), typeImportFilter, imp, cfHandler);
 464         }
 465 
 466         /** Import all static members of a class or package on demand.
 467          *  @param imp           The import that is being handled.
 468          *  @param tsym          The class or package the members of which are imported.
 469          *  @param env           The env in which the imported classes will be entered.
 470          */
 471         private void importStaticAll(JCImport imp,
 472                                      final TypeSymbol tsym,
 473                                      Env&lt;AttrContext&gt; env) {
 474             final StarImportScope toScope = env.toplevel.starImportScope;
 475             final TypeSymbol origin = tsym;
 476 
 477             toScope.importAll(types, origin.members(), staticImportFilter, imp, cfHandler);
 478         }
 479 
 480         /** Import statics types of a given name.  Non-types are handled in Attr.
 481          *  @param imp           The import that is being handled.
 482          *  @param tsym          The class from which the name is imported.
 483          *  @param name          The (simple) name being imported.
 484          *  @param env           The environment containing the named import
 485          *                  scope to add to.
 486          */
 487         private void importNamedStatic(final JCImport imp,
 488                                        final TypeSymbol tsym,
 489                                        final Name name,
 490                                        final Env&lt;AttrContext&gt; env) {
 491             if (tsym.kind != TYP) {
 492                 log.error(DiagnosticFlag.RECOVERABLE, imp.pos(), Errors.StaticImpOnlyClassesAndInterfaces);
 493                 return;
 494             }
 495 
 496             final NamedImportScope toScope = env.toplevel.namedImportScope;
 497             final Scope originMembers = tsym.members();
 498 
 499             imp.importScope = toScope.importByName(types, originMembers, name, staticImportFilter, imp, cfHandler);
 500         }
 501 
 502         /** Import given class.
 503          *  @param pos           Position to be used for error reporting.
 504          *  @param tsym          The class to be imported.
 505          *  @param env           The environment containing the named import
 506          *                  scope to add to.
 507          */
 508         private void importNamed(DiagnosticPosition pos, final Symbol tsym, Env&lt;AttrContext&gt; env, JCImport imp) {
 509             if (tsym.kind == TYP)
 510                 imp.importScope = env.toplevel.namedImportScope.importType(tsym.owner.members(), tsym.owner.members(), tsym);
 511         }
 512 
 513     }
 514 
 515     /**Defines common utility methods used by the HierarchyPhase and HeaderPhase.
 516      */
 517     private abstract class AbstractHeaderPhase extends Phase {
 518 
 519         public AbstractHeaderPhase(CompletionCause phaseName, Phase next) {
 520             super(phaseName, next);
 521         }
 522 
 523         protected Env&lt;AttrContext&gt; baseEnv(JCClassDecl tree, Env&lt;AttrContext&gt; env) {
 524             WriteableScope baseScope = WriteableScope.create(tree.sym);
 525             //import already entered local classes into base scope
 526             for (Symbol sym : env.outer.info.scope.getSymbols(NON_RECURSIVE)) {
 527                 if (sym.isLocal()) {
 528                     baseScope.enter(sym);
 529                 }
 530             }
 531             //import current type-parameters into base scope
 532             if (tree.typarams != null)
 533                 for (List&lt;JCTypeParameter&gt; typarams = tree.typarams;
 534                      typarams.nonEmpty();
 535                      typarams = typarams.tail)
 536                     baseScope.enter(typarams.head.type.tsym);
 537             Env&lt;AttrContext&gt; outer = env.outer; // the base clause can&#39;t see members of this class
 538             Env&lt;AttrContext&gt; localEnv = outer.dup(tree, outer.info.dup(baseScope));
 539             localEnv.baseClause = true;
 540             localEnv.outer = outer;
 541             localEnv.info.isSelfCall = false;
 542             return localEnv;
 543         }
 544 
 545         /** Generate a base clause for an enum type.
 546          *  @param pos              The position for trees and diagnostics, if any
 547          *  @param c                The class symbol of the enum
 548          */
 549         protected  JCExpression enumBase(int pos, ClassSymbol c) {
 550             JCExpression result = make.at(pos).
 551                 TypeApply(make.QualIdent(syms.enumSym),
 552                           List.of(make.Type(c.type)));
 553             return result;
 554         }
 555 
 556         protected Type modelMissingTypes(Env&lt;AttrContext&gt; env, Type t, final JCExpression tree, final boolean interfaceExpected) {
 557             if (!t.hasTag(ERROR))
 558                 return t;
 559 
 560             return new ErrorType(t.getOriginalType(), t.tsym) {
 561                 private Type modelType;
 562 
 563                 @Override
 564                 public Type getModelType() {
 565                     if (modelType == null)
 566                         modelType = new Synthesizer(env.toplevel.modle, getOriginalType(), interfaceExpected).visit(tree);
 567                     return modelType;
 568                 }
 569             };
 570         }
 571             // where:
 572             private class Synthesizer extends JCTree.Visitor {
 573                 ModuleSymbol msym;
 574                 Type originalType;
 575                 boolean interfaceExpected;
 576                 List&lt;ClassSymbol&gt; synthesizedSymbols = List.nil();
 577                 Type result;
 578 
 579                 Synthesizer(ModuleSymbol msym, Type originalType, boolean interfaceExpected) {
 580                     this.msym = msym;
 581                     this.originalType = originalType;
 582                     this.interfaceExpected = interfaceExpected;
 583                 }
 584 
 585                 Type visit(JCTree tree) {
 586                     tree.accept(this);
 587                     return result;
 588                 }
 589 
 590                 List&lt;Type&gt; visit(List&lt;? extends JCTree&gt; trees) {
 591                     ListBuffer&lt;Type&gt; lb = new ListBuffer&lt;&gt;();
 592                     for (JCTree t: trees)
 593                         lb.append(visit(t));
 594                     return lb.toList();
 595                 }
 596 
 597                 @Override
 598                 public void visitTree(JCTree tree) {
 599                     result = syms.errType;
 600                 }
 601 
 602                 @Override
 603                 public void visitIdent(JCIdent tree) {
 604                     if (!tree.type.hasTag(ERROR)) {
 605                         result = tree.type;
 606                     } else {
 607                         result = synthesizeClass(tree.name, msym.unnamedPackage).type;
 608                     }
 609                 }
 610 
 611                 @Override
 612                 public void visitSelect(JCFieldAccess tree) {
 613                     if (!tree.type.hasTag(ERROR)) {
 614                         result = tree.type;
 615                     } else {
 616                         Type selectedType;
 617                         boolean prev = interfaceExpected;
 618                         try {
 619                             interfaceExpected = false;
 620                             selectedType = visit(tree.selected);
 621                         } finally {
 622                             interfaceExpected = prev;
 623                         }
 624                         ClassSymbol c = synthesizeClass(tree.name, selectedType.tsym);
 625                         result = c.type;
 626                     }
 627                 }
 628 
 629                 @Override
 630                 public void visitTypeApply(JCTypeApply tree) {
 631                     if (!tree.type.hasTag(ERROR)) {
 632                         result = tree.type;
 633                     } else {
 634                         ClassType clazzType = (ClassType) visit(tree.clazz);
 635                         if (synthesizedSymbols.contains(clazzType.tsym))
 636                             synthesizeTyparams((ClassSymbol) clazzType.tsym, tree.arguments.size());
 637                         final List&lt;Type&gt; actuals = visit(tree.arguments);
 638                         result = new ErrorType(tree.type, clazzType.tsym) {
 639                             @Override @DefinedBy(Api.LANGUAGE_MODEL)
 640                             public List&lt;Type&gt; getTypeArguments() {
 641                                 return actuals;
 642                             }
 643                         };
 644                     }
 645                 }
 646 
 647                 ClassSymbol synthesizeClass(Name name, Symbol owner) {
 648                     int flags = interfaceExpected ? INTERFACE : 0;
 649                     ClassSymbol c = new ClassSymbol(flags, name, owner);
 650                     c.members_field = new Scope.ErrorScope(c);
 651                     c.type = new ErrorType(originalType, c) {
 652                         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 653                         public List&lt;Type&gt; getTypeArguments() {
 654                             return typarams_field;
 655                         }
 656                     };
 657                     synthesizedSymbols = synthesizedSymbols.prepend(c);
 658                     return c;
 659                 }
 660 
 661                 void synthesizeTyparams(ClassSymbol sym, int n) {
 662                     ClassType ct = (ClassType) sym.type;
 663                     Assert.check(ct.typarams_field.isEmpty());
 664                     if (n == 1) {
 665                         TypeVar v = new TypeVar(names.fromString(&quot;T&quot;), sym, syms.botType);
 666                         ct.typarams_field = ct.typarams_field.prepend(v);
 667                     } else {
 668                         for (int i = n; i &gt; 0; i--) {
 669                             TypeVar v = new TypeVar(names.fromString(&quot;T&quot; + i), sym,
 670                                                     syms.botType);
 671                             ct.typarams_field = ct.typarams_field.prepend(v);
 672                         }
 673                     }
 674                 }
 675             }
 676 
 677         protected void attribSuperTypes(Env&lt;AttrContext&gt; env, Env&lt;AttrContext&gt; baseEnv) {
 678             JCClassDecl tree = env.enclClass;
 679             ClassSymbol sym = tree.sym;
 680             ClassType ct = (ClassType)sym.type;
 681             // Determine supertype.
 682             Type supertype;
 683             JCExpression extending;
 684 
 685             if (tree.extending != null) {
 686                 extending = clearTypeParams(tree.extending);
 687                 supertype = attr.attribBase(extending, sym, baseEnv, true, false, true);
 688                 if (supertype == syms.recordType) {
 689                     log.error(tree, Errors.InvalidSupertypeRecord(supertype.tsym));
 690                 }
 691             } else {
 692                 extending = null;
 693                 supertype = ((tree.mods.flags &amp; Flags.ENUM) != 0)
 694                 ? attr.attribBase(enumBase(tree.pos, sym), sym, baseEnv,
 695                                   true, false, false)
 696                 : (sym.fullname == names.java_lang_Object)
 697                 ? Type.noType
 698                 : sym.isRecord() ? syms.recordType : syms.objectType;
 699             }
 700             ct.supertype_field = modelMissingTypes(baseEnv, supertype, extending, false);
 701 
 702             // Determine interfaces.
 703             ListBuffer&lt;Type&gt; interfaces = new ListBuffer&lt;&gt;();
 704             ListBuffer&lt;Type&gt; all_interfaces = null; // lazy init
 705             List&lt;JCExpression&gt; interfaceTrees = tree.implementing;
 706             for (JCExpression iface : interfaceTrees) {
 707                 iface = clearTypeParams(iface);
 708                 Type it = attr.attribBase(iface, sym, baseEnv, false, true, true);
 709                 if (it.hasTag(CLASS)) {
 710                     interfaces.append(it);
 711                     if (all_interfaces != null) all_interfaces.append(it);
 712                 } else {
 713                     if (all_interfaces == null)
 714                         all_interfaces = new ListBuffer&lt;Type&gt;().appendList(interfaces);
 715                     all_interfaces.append(modelMissingTypes(baseEnv, it, iface, true));
 716                 }
 717             }
 718 
 719             // Determine permits.
 720             ListBuffer&lt;Symbol&gt; permittedSubtypeSymbols = new ListBuffer&lt;&gt;();
 721             List&lt;JCExpression&gt; permittedTrees = tree.permitting;
 722             for (JCExpression permitted : permittedTrees) {
 723                 permitted = clearTypeParams(permitted);
 724                 Type pt = attr.attribBase(permitted, sym, baseEnv, false, false, false);
 725                 permittedSubtypeSymbols.append(pt.tsym);
 726             }
 727 
 728             if ((sym.flags_field &amp; ANNOTATION) != 0) {
 729                 ct.interfaces_field = List.of(syms.annotationType);
 730                 ct.all_interfaces_field = ct.interfaces_field;
 731             }  else {
 732                 ct.interfaces_field = interfaces.toList();
 733                 ct.all_interfaces_field = (all_interfaces == null)
 734                         ? ct.interfaces_field : all_interfaces.toList();
 735             }
 736 
 737             sym.permitted = permittedSubtypeSymbols.toList();
 738             sym.isPermittedExplicit = !permittedSubtypeSymbols.isEmpty();
 739         }
 740             //where:
 741             protected JCExpression clearTypeParams(JCExpression superType) {
 742                 return superType;
 743             }
 744     }
 745 
 746     private final class HierarchyPhase extends AbstractHeaderPhase implements Completer {
 747 
 748         public HierarchyPhase() {
 749             super(CompletionCause.HIERARCHY_PHASE, new PermitsPhase());
 750         }
 751 
 752         @Override
 753         protected void doCompleteEnvs(List&lt;Env&lt;AttrContext&gt;&gt; envs) {
 754             //The ClassSymbols in the envs list may not be in the dependency order.
 755             //To get proper results, for every class or interface C, the supertypes of
 756             //C must be processed by the HierarchyPhase phase before C.
 757             //To achieve that, the HierarchyPhase is registered as the Completer for
 758             //all the classes first, and then all the classes are completed.
 759             for (Env&lt;AttrContext&gt; env : envs) {
 760                 env.enclClass.sym.completer = this;
 761             }
 762             for (Env&lt;AttrContext&gt; env : envs) {
 763                 env.enclClass.sym.complete();
 764             }
 765         }
 766 
 767         @Override
 768         protected void runPhase(Env&lt;AttrContext&gt; env) {
 769             JCClassDecl tree = env.enclClass;
 770             ClassSymbol sym = tree.sym;
 771             ClassType ct = (ClassType)sym.type;
 772 
 773             Env&lt;AttrContext&gt; baseEnv = baseEnv(tree, env);
 774 
 775             attribSuperTypes(env, baseEnv);
 776 
 777             if (sym.fullname == names.java_lang_Object) {
 778                 if (tree.extending != null) {
 779                     chk.checkNonCyclic(tree.extending.pos(),
 780                                        ct.supertype_field);
 781                     ct.supertype_field = Type.noType;
 782                 }
 783                 else if (tree.implementing.nonEmpty()) {
 784                     chk.checkNonCyclic(tree.implementing.head.pos(),
 785                                        ct.interfaces_field.head);
 786                     ct.interfaces_field = List.nil();
 787                 }
 788             }
 789 
 790             markDeprecated(sym, tree.mods.annotations, baseEnv);
 791 
 792             chk.checkNonCyclicDecl(tree);
 793         }
 794             //where:
 795             @Override
 796             protected JCExpression clearTypeParams(JCExpression superType) {
 797                 switch (superType.getTag()) {
 798                     case TYPEAPPLY:
 799                         return ((JCTypeApply) superType).clazz;
 800                 }
 801 
 802                 return superType;
 803             }
 804 
 805         @Override
 806         public void complete(Symbol sym) throws CompletionFailure {
 807             Assert.check((topLevelPhase instanceof ImportsPhase) ||
 808                          (topLevelPhase == this));
 809 
 810             if (topLevelPhase != this) {
 811                 //only do the processing based on dependencies in the HierarchyPhase:
 812                 sym.completer = this;
 813                 return ;
 814             }
 815 
 816             Env&lt;AttrContext&gt; env = typeEnvs.get((ClassSymbol) sym);
 817 
 818             super.doCompleteEnvs(List.of(env));
 819         }
 820 
 821     }
 822 
 823     private final class PermitsPhase extends AbstractHeaderPhase {
 824 
 825         public PermitsPhase() {
 826             super(CompletionCause.HIERARCHY_PHASE, new HeaderPhase());
 827         }
 828 
 829         @Override
 830         protected void runPhase(Env&lt;AttrContext&gt; env) {
 831             JCClassDecl tree = env.enclClass;
<a name="2" id="anc2"></a><span class="line-modified"> 832             if (!tree.sym.isAnonymous() || tree.sym.isEnum()) {</span>
<span class="line-modified"> 833                 for (Type supertype : types.directSupertypes(tree.sym.type)) {</span>
<span class="line-modified"> 834                     if (supertype.tsym.kind == TYP) {</span>
<span class="line-modified"> 835                         ClassSymbol supClass = (ClassSymbol) supertype.tsym;</span>
<span class="line-modified"> 836                         Env&lt;AttrContext&gt; supClassEnv = enter.getEnv(supClass);</span>
<span class="line-modified"> 837                         if (supClass.isSealed() &amp;&amp;</span>
<span class="line-modified"> 838                             !supClass.isPermittedExplicit &amp;&amp;</span>
<span class="line-modified"> 839                             supClassEnv != null &amp;&amp;</span>
<span class="line-modified"> 840                             supClassEnv.toplevel == env.toplevel) {</span>
<span class="line-modified"> 841                             supClass.permitted = supClass.permitted.append(tree.sym);</span>




















 842                         }
 843                     }
 844                 }
<a name="3" id="anc3"></a>
















 845             }
<a name="4" id="anc4"></a>





 846         }
 847 
<a name="5" id="anc5"></a>







































 848     }
 849 
 850     private final class HeaderPhase extends AbstractHeaderPhase {
 851 
 852         public HeaderPhase() {
 853             super(CompletionCause.HEADER_PHASE, new RecordPhase());
 854         }
 855 
 856         @Override
 857         protected void runPhase(Env&lt;AttrContext&gt; env) {
 858             JCClassDecl tree = env.enclClass;
 859             ClassSymbol sym = tree.sym;
 860             ClassType ct = (ClassType)sym.type;
 861 
 862             // create an environment for evaluating the base clauses
 863             Env&lt;AttrContext&gt; baseEnv = baseEnv(tree, env);
 864 
 865             if (tree.extending != null)
 866                 annotate.queueScanTreeAndTypeAnnotate(tree.extending, baseEnv, sym, tree.pos());
 867             for (JCExpression impl : tree.implementing)
 868                 annotate.queueScanTreeAndTypeAnnotate(impl, baseEnv, sym, tree.pos());
 869             annotate.flush();
 870 
 871             attribSuperTypes(env, baseEnv);
 872 
 873             Set&lt;Type&gt; interfaceSet = new HashSet&lt;&gt;();
 874 
 875             for (JCExpression iface : tree.implementing) {
 876                 Type it = iface.type;
 877                 if (it.hasTag(CLASS))
 878                     chk.checkNotRepeated(iface.pos(), types.erasure(it), interfaceSet);
 879             }
 880 
 881             annotate.annotateLater(tree.mods.annotations, baseEnv,
 882                         sym, tree.pos());
 883             attr.attribTypeVariables(tree.typarams, baseEnv, false);
 884 
 885             for (JCTypeParameter tp : tree.typarams)
 886                 annotate.queueScanTreeAndTypeAnnotate(tp, baseEnv, sym, tree.pos());
 887 
 888             // check that no package exists with same fully qualified name,
 889             // but admit classes in the unnamed package which have the same
 890             // name as a top-level package.
 891             if (checkClash &amp;&amp;
 892                 sym.owner.kind == PCK &amp;&amp; sym.owner != env.toplevel.modle.unnamedPackage &amp;&amp;
 893                 syms.packageExists(env.toplevel.modle, sym.fullname)) {
 894                 log.error(tree.pos, Errors.ClashWithPkgOfSameName(Kinds.kindName(sym),sym));
 895             }
 896             if (sym.owner.kind == PCK &amp;&amp; (sym.flags_field &amp; PUBLIC) == 0 &amp;&amp;
 897                 !env.toplevel.sourcefile.isNameCompatible(sym.name.toString(),JavaFileObject.Kind.SOURCE)) {
 898                 sym.flags_field |= AUXILIARY;
 899             }
 900         }
 901     }
 902 
 903     private abstract class AbstractMembersPhase extends Phase {
 904 
 905         public AbstractMembersPhase(CompletionCause completionCause, Phase next) {
 906             super(completionCause, next);
 907         }
 908 
 909         private boolean completing;
 910         private List&lt;Env&lt;AttrContext&gt;&gt; todo = List.nil();
 911 
 912         @Override
 913         protected void doCompleteEnvs(List&lt;Env&lt;AttrContext&gt;&gt; envs) {
 914             todo = todo.prependList(envs);
 915             if (completing) {
 916                 return ; //the top-level invocation will handle all envs
 917             }
 918             boolean prevCompleting = completing;
 919             completing = true;
 920             try {
 921                 while (todo.nonEmpty()) {
 922                     Env&lt;AttrContext&gt; head = todo.head;
 923                     todo = todo.tail;
 924                     super.doCompleteEnvs(List.of(head));
 925                 }
 926             } finally {
 927                 completing = prevCompleting;
 928             }
 929         }
 930 
 931         void enterThisAndSuper(ClassSymbol sym, Env&lt;AttrContext&gt; env) {
 932             ClassType ct = (ClassType)sym.type;
 933             // enter symbols for &#39;this&#39; into current scope.
 934             VarSymbol thisSym =
 935                     new VarSymbol(FINAL | HASINIT, names._this, sym.type, sym);
 936             thisSym.pos = Position.FIRSTPOS;
 937             env.info.scope.enter(thisSym);
 938             // if this is a class, enter symbol for &#39;super&#39; into current scope.
 939             if ((sym.flags_field &amp; INTERFACE) == 0 &amp;&amp;
 940                     ct.supertype_field.hasTag(CLASS)) {
 941                 VarSymbol superSym =
 942                         new VarSymbol(FINAL | HASINIT, names._super,
 943                                 ct.supertype_field, sym);
 944                 superSym.pos = Position.FIRSTPOS;
 945                 env.info.scope.enter(superSym);
 946             }
 947         }
 948     }
 949 
 950     private final class RecordPhase extends AbstractMembersPhase {
 951 
 952         public RecordPhase() {
 953             super(CompletionCause.RECORD_PHASE, new MembersPhase());
 954         }
 955 
 956         @Override
 957         protected void runPhase(Env&lt;AttrContext&gt; env) {
 958             JCClassDecl tree = env.enclClass;
 959             ClassSymbol sym = tree.sym;
 960             if ((sym.flags_field &amp; RECORD) != 0) {
 961                 List&lt;JCVariableDecl&gt; fields = TreeInfo.recordFields(tree);
 962                 memberEnter.memberEnter(fields, env);
 963                 for (JCVariableDecl field : fields) {
 964                     sym.getRecordComponent(field, true,
 965                             field.mods.annotations.isEmpty() ?
 966                                     List.nil() :
 967                                     new TreeCopier&lt;JCTree&gt;(make.at(field.pos)).copy(field.mods.annotations));
 968                 }
 969 
 970                 enterThisAndSuper(sym, env);
 971 
 972                 // lets enter all constructors
 973                 for (JCTree def : tree.defs) {
 974                     if (TreeInfo.isConstructor(def)) {
 975                         memberEnter.memberEnter(def, env);
 976                     }
 977                 }
 978             }
 979         }
 980     }
 981 
 982     /** Enter member fields and methods of a class
 983      */
 984     private final class MembersPhase extends AbstractMembersPhase {
 985 
 986         public MembersPhase() {
 987             super(CompletionCause.MEMBERS_PHASE, null);
 988         }
 989 
 990         @Override
 991         protected void runPhase(Env&lt;AttrContext&gt; env) {
 992             JCClassDecl tree = env.enclClass;
 993             ClassSymbol sym = tree.sym;
 994             ClassType ct = (ClassType)sym.type;
 995 
 996             // Add default constructor if needed.
 997             DefaultConstructorHelper helper = getDefaultConstructorHelper(env);
 998             if (helper != null) {
 999                 JCTree constrDef = defaultConstructor(make.at(tree.pos), helper);
1000                 tree.defs = tree.defs.prepend(constrDef);
1001             }
1002             if (!sym.isRecord()) {
1003                 enterThisAndSuper(sym, env);
1004             }
1005 
1006             if (!tree.typarams.isEmpty()) {
1007                 for (JCTypeParameter tvar : tree.typarams) {
1008                     chk.checkNonCyclic(tvar, (TypeVar)tvar.type);
1009                 }
1010             }
1011 
1012             finishClass(tree, env);
1013 
1014             if (allowTypeAnnos) {
1015                 typeAnnotations.organizeTypeAnnotationsSignatures(env, (JCClassDecl)env.tree);
1016                 typeAnnotations.validateTypeAnnotationsSignatures(env, (JCClassDecl)env.tree);
1017             }
1018         }
1019 
1020         DefaultConstructorHelper getDefaultConstructorHelper(Env&lt;AttrContext&gt; env) {
1021             JCClassDecl tree = env.enclClass;
1022             ClassSymbol sym = tree.sym;
1023             DefaultConstructorHelper helper = null;
1024             boolean isClassWithoutInit = (sym.flags() &amp; INTERFACE) == 0 &amp;&amp; !TreeInfo.hasConstructors(tree.defs);
1025             boolean isRecord = sym.isRecord();
1026             if (isClassWithoutInit &amp;&amp; !isRecord) {
1027                 helper = new BasicConstructorHelper(sym);
1028                 if (sym.name.isEmpty()) {
1029                     JCNewClass nc = (JCNewClass)env.next.tree;
1030                     if (nc.constructor != null) {
1031                         if (nc.constructor.kind != ERR) {
1032                             helper = new AnonClassConstructorHelper(sym, (MethodSymbol)nc.constructor, nc.encl);
1033                         } else {
1034                             helper = null;
1035                         }
1036                     }
1037                 }
1038             }
1039             if (isRecord) {
1040                 JCMethodDecl canonicalInit = null;
1041                 if (isClassWithoutInit || (canonicalInit = getCanonicalConstructorDecl(env.enclClass)) == null) {
1042                     helper = new RecordConstructorHelper(sym, TreeInfo.recordFields(tree));
1043                 }
1044                 if (canonicalInit != null) {
1045                     canonicalInit.sym.flags_field |= Flags.RECORD;
1046                 }
1047             }
1048             return helper;
1049         }
1050 
1051         /** Enter members for a class.
1052          */
1053         void finishClass(JCClassDecl tree, Env&lt;AttrContext&gt; env) {
1054             if ((tree.mods.flags &amp; Flags.ENUM) != 0 &amp;&amp;
1055                 !tree.sym.type.hasTag(ERROR) &amp;&amp;
1056                 (types.supertype(tree.sym.type).tsym.flags() &amp; Flags.ENUM) == 0) {
1057                 addEnumMembers(tree, env);
1058             }
1059             boolean isRecord = (tree.sym.flags_field &amp; RECORD) != 0;
1060             List&lt;JCTree&gt; alreadyEntered = null;
1061             if (isRecord) {
1062                 alreadyEntered = List.convert(JCTree.class, TreeInfo.recordFields(tree));
1063                 alreadyEntered = alreadyEntered.prependList(tree.defs.stream()
1064                         .filter(t -&gt; TreeInfo.isConstructor(t) &amp;&amp;
1065                                 ((JCMethodDecl)t).sym != null &amp;&amp;
1066                                 (((JCMethodDecl)t).sym.flags_field &amp; Flags.GENERATEDCONSTR) == 0).collect(List.collector()));
1067             }
1068             List&lt;JCTree&gt; defsToEnter = isRecord ?
1069                     tree.defs.diff(alreadyEntered) : tree.defs;
1070             memberEnter.memberEnter(defsToEnter, env);
1071             List&lt;JCTree&gt; defsBeforeAddingNewMembers = tree.defs;
1072             if (isRecord) {
1073                 addRecordMembersIfNeeded(tree, env);
1074             }
1075             if (tree.sym.isAnnotationType()) {
1076                 Assert.check(tree.sym.isCompleted());
1077                 tree.sym.setAnnotationTypeMetadata(new AnnotationTypeMetadata(tree.sym, annotate.annotationTypeSourceCompleter()));
1078             }
1079         }
1080 
1081         private void addAccessor(JCVariableDecl tree, Env&lt;AttrContext&gt; env) {
1082             MethodSymbol implSym = lookupMethod(env.enclClass.sym, tree.sym.name, List.nil());
1083             RecordComponent rec = ((ClassSymbol) tree.sym.owner).getRecordComponent(tree.sym);
1084             if (implSym == null || (implSym.flags_field &amp; GENERATED_MEMBER) != 0) {
1085                 /* here we are pushing the annotations present in the corresponding field down to the accessor
1086                  * it could be that some of those annotations are not applicable to the accessor, they will be striped
1087                  * away later at Check::validateAnnotation
1088                  */
1089                 List&lt;JCAnnotation&gt; originalAnnos = rec.getOriginalAnnos().isEmpty() ?
1090                         rec.getOriginalAnnos() :
1091                         new TreeCopier&lt;JCTree&gt;(make.at(tree.pos)).copy(rec.getOriginalAnnos());
1092                 JCMethodDecl getter = make.at(tree.pos).
1093                         MethodDef(
1094                                 make.Modifiers(Flags.PUBLIC | Flags.GENERATED_MEMBER, originalAnnos),
1095                           tree.sym.name,
1096                           /* we need to special case for the case when the user declared the type as an ident
1097                            * if we don&#39;t do that then we can have issues if type annotations are applied to the
1098                            * return type: javac issues an error if a type annotation is applied to java.lang.String
1099                            * but applying a type annotation to String is kosher
1100                            */
1101                           tree.vartype.hasTag(IDENT) ? make.Ident(tree.vartype.type.tsym) : make.Type(tree.sym.type),
1102                           List.nil(),
1103                           List.nil(),
1104                           List.nil(), // thrown
1105                           null,
1106                           null);
1107                 memberEnter.memberEnter(getter, env);
1108                 rec.accessor = getter.sym;
1109                 rec.accessorMeth = getter;
1110             } else if (implSym != null) {
1111                 rec.accessor = implSym;
1112             }
1113         }
1114 
1115         /** Add the implicit members for an enum type
1116          *  to the symbol table.
1117          */
1118         private void addEnumMembers(JCClassDecl tree, Env&lt;AttrContext&gt; env) {
1119             JCExpression valuesType = make.Type(new ArrayType(tree.sym.type, syms.arrayClass));
1120 
1121             JCMethodDecl values = make.
1122                 MethodDef(make.Modifiers(Flags.PUBLIC|Flags.STATIC),
1123                           names.values,
1124                           valuesType,
1125                           List.nil(),
1126                           List.nil(),
1127                           List.nil(),
1128                           null,
1129                           null);
1130             memberEnter.memberEnter(values, env);
1131 
1132             JCMethodDecl valueOf = make.
1133                 MethodDef(make.Modifiers(Flags.PUBLIC|Flags.STATIC),
1134                           names.valueOf,
1135                           make.Type(tree.sym.type),
1136                           List.nil(),
1137                           List.of(make.VarDef(make.Modifiers(Flags.PARAMETER |
1138                                                              Flags.MANDATED),
1139                                                 names.fromString(&quot;name&quot;),
1140                                                 make.Type(syms.stringType), null)),
1141                           List.nil(),
1142                           null,
1143                           null);
1144             memberEnter.memberEnter(valueOf, env);
1145         }
1146 
1147         JCMethodDecl getCanonicalConstructorDecl(JCClassDecl tree) {
1148             // let&#39;s check if there is a constructor with exactly the same arguments as the record components
1149             List&lt;Type&gt; recordComponentErasedTypes = types.erasure(TreeInfo.recordFields(tree).map(vd -&gt; vd.sym.type));
1150             JCMethodDecl canonicalDecl = null;
1151             for (JCTree def : tree.defs) {
1152                 if (TreeInfo.isConstructor(def)) {
1153                     JCMethodDecl mdecl = (JCMethodDecl)def;
1154                     if (types.isSameTypes(types.erasure(mdecl.params.stream().map(v -&gt; v.sym.type).collect(List.collector())), recordComponentErasedTypes)) {
1155                         canonicalDecl = mdecl;
1156                         break;
1157                     }
1158                 }
1159             }
1160             return canonicalDecl;
1161         }
1162 
1163         /** Add the implicit members for a record
1164          *  to the symbol table.
1165          */
1166         private void addRecordMembersIfNeeded(JCClassDecl tree, Env&lt;AttrContext&gt; env) {
1167             if (lookupMethod(tree.sym, names.toString, List.nil()) == null) {
1168                 JCMethodDecl toString = make.
1169                     MethodDef(make.Modifiers(Flags.PUBLIC | Flags.RECORD | Flags.GENERATED_MEMBER),
1170                               names.toString,
1171                               make.Type(syms.stringType),
1172                               List.nil(),
1173                               List.nil(),
1174                               List.nil(),
1175                               null,
1176                               null);
1177                 memberEnter.memberEnter(toString, env);
1178             }
1179 
1180             if (lookupMethod(tree.sym, names.hashCode, List.nil()) == null) {
1181                 JCMethodDecl hashCode = make.
1182                     MethodDef(make.Modifiers(Flags.PUBLIC | Flags.RECORD | Flags.FINAL | Flags.GENERATED_MEMBER),
1183                               names.hashCode,
1184                               make.Type(syms.intType),
1185                               List.nil(),
1186                               List.nil(),
1187                               List.nil(),
1188                               null,
1189                               null);
1190                 memberEnter.memberEnter(hashCode, env);
1191             }
1192 
1193             if (lookupMethod(tree.sym, names.equals, List.of(syms.objectType)) == null) {
1194                 JCMethodDecl equals = make.
1195                     MethodDef(make.Modifiers(Flags.PUBLIC | Flags.RECORD | Flags.FINAL | Flags.GENERATED_MEMBER),
1196                               names.equals,
1197                               make.Type(syms.booleanType),
1198                               List.nil(),
1199                               List.of(make.VarDef(make.Modifiers(Flags.PARAMETER),
1200                                                 names.fromString(&quot;o&quot;),
1201                                                 make.Type(syms.objectType), null)),
1202                               List.nil(),
1203                               null,
1204                               null);
1205                 memberEnter.memberEnter(equals, env);
1206             }
1207 
1208             // fields can&#39;t be varargs, lets remove the flag
1209             List&lt;JCVariableDecl&gt; recordFields = TreeInfo.recordFields(tree);
1210             for (JCVariableDecl field: recordFields) {
1211                 field.mods.flags &amp;= ~Flags.VARARGS;
1212                 field.sym.flags_field &amp;= ~Flags.VARARGS;
1213             }
1214             // now lets add the accessors
1215             recordFields.stream()
1216                     .filter(vd -&gt; (lookupMethod(syms.objectType.tsym, vd.name, List.nil()) == null))
1217                     .forEach(vd -&gt; addAccessor(vd, env));
1218         }
1219     }
1220 
1221     private MethodSymbol lookupMethod(TypeSymbol tsym, Name name, List&lt;Type&gt; argtypes) {
1222         for (Symbol s : tsym.members().getSymbolsByName(name, s -&gt; s.kind == MTH)) {
1223             if (types.isSameTypes(s.type.getParameterTypes(), argtypes)) {
1224                 return (MethodSymbol) s;
1225             }
1226         }
1227         return null;
1228     }
1229 
1230 /* ***************************************************************************
1231  * tree building
1232  ****************************************************************************/
1233 
1234     interface DefaultConstructorHelper {
1235        Type constructorType();
1236        MethodSymbol constructorSymbol();
1237        Type enclosingType();
1238        TypeSymbol owner();
1239        List&lt;Name&gt; superArgs();
1240        default JCMethodDecl finalAdjustment(JCMethodDecl md) { return md; }
1241     }
1242 
1243     class BasicConstructorHelper implements DefaultConstructorHelper {
1244 
1245         TypeSymbol owner;
1246         Type constructorType;
1247         MethodSymbol constructorSymbol;
1248 
1249         BasicConstructorHelper(TypeSymbol owner) {
1250             this.owner = owner;
1251         }
1252 
1253         @Override
1254         public Type constructorType() {
1255             if (constructorType == null) {
1256                 constructorType = new MethodType(List.nil(), syms.voidType, List.nil(), syms.methodClass);
1257             }
1258             return constructorType;
1259         }
1260 
1261         @Override
1262         public MethodSymbol constructorSymbol() {
1263             if (constructorSymbol == null) {
1264                 long flags;
1265                 if ((owner().flags() &amp; ENUM) != 0 &amp;&amp;
1266                     (types.supertype(owner().type).tsym == syms.enumSym)) {
1267                     // constructors of true enums are private
1268                     flags = PRIVATE | GENERATEDCONSTR;
1269                 } else if ((owner().flags_field &amp; RECORD) != 0) {
1270                     // record constructors are public
1271                     flags = PUBLIC | GENERATEDCONSTR;
1272                 } else {
1273                     flags = (owner().flags() &amp; AccessFlags) | GENERATEDCONSTR;
1274                 }
1275                 constructorSymbol = new MethodSymbol(flags, names.init,
1276                     constructorType(), owner());
1277             }
1278             return constructorSymbol;
1279         }
1280 
1281         @Override
1282         public Type enclosingType() {
1283             return Type.noType;
1284     }
1285 
1286         @Override
1287         public TypeSymbol owner() {
1288             return owner;
1289         }
1290 
1291         @Override
1292         public List&lt;Name&gt; superArgs() {
1293             return List.nil();
1294             }
1295     }
1296 
1297     class AnonClassConstructorHelper extends BasicConstructorHelper {
1298 
1299         MethodSymbol constr;
1300         Type encl;
1301         boolean based = false;
1302 
1303         AnonClassConstructorHelper(TypeSymbol owner, MethodSymbol constr, JCExpression encl) {
1304             super(owner);
1305             this.constr = constr;
1306             this.encl = encl != null ? encl.type : Type.noType;
1307         }
1308 
1309         @Override
1310         public Type constructorType() {
1311             if (constructorType == null) {
1312                 Type ctype = types.memberType(owner.type, constr);
1313                 if (!enclosingType().hasTag(NONE)) {
1314                     ctype = types.createMethodTypeWithParameters(ctype, ctype.getParameterTypes().prepend(enclosingType()));
1315                     based = true;
1316                 }
1317                 constructorType = ctype;
1318             }
1319             return constructorType;
1320         }
1321 
1322         @Override
1323         public MethodSymbol constructorSymbol() {
1324             MethodSymbol csym = super.constructorSymbol();
1325             csym.flags_field |= ANONCONSTR | (constr.flags() &amp; VARARGS);
1326             csym.flags_field |= based ? ANONCONSTR_BASED : 0;
1327             ListBuffer&lt;VarSymbol&gt; params = new ListBuffer&lt;&gt;();
1328             List&lt;Type&gt; argtypes = constructorType().getParameterTypes();
1329             if (!enclosingType().hasTag(NONE)) {
1330                 argtypes = argtypes.tail;
1331                 params = params.prepend(new VarSymbol(PARAMETER, make.paramName(0), enclosingType(), csym));
1332             }
1333             if (constr.params != null) {
1334                 for (VarSymbol p : constr.params) {
1335                     params.add(new VarSymbol(PARAMETER | p.flags(), p.name, argtypes.head, csym));
1336                     argtypes = argtypes.tail;
1337                 }
1338             }
1339             csym.params = params.toList();
1340             return csym;
1341         }
1342 
1343         @Override
1344         public Type enclosingType() {
1345             return encl;
1346         }
1347 
1348         @Override
1349         public List&lt;Name&gt; superArgs() {
1350             List&lt;JCVariableDecl&gt; params = make.Params(constructorType().getParameterTypes(), constructorSymbol());
1351             if (!enclosingType().hasTag(NONE)) {
1352                 params = params.tail;
1353             }
1354             return params.map(vd -&gt; vd.name);
1355         }
1356     }
1357 
1358     class RecordConstructorHelper extends BasicConstructorHelper {
1359 
1360         List&lt;VarSymbol&gt; recordFieldSymbols;
1361         List&lt;JCVariableDecl&gt; recordFieldDecls;
1362 
1363         RecordConstructorHelper(TypeSymbol owner, List&lt;JCVariableDecl&gt; recordFieldDecls) {
1364             super(owner);
1365             this.recordFieldDecls = recordFieldDecls;
1366             this.recordFieldSymbols = recordFieldDecls.map(vd -&gt; vd.sym);
1367         }
1368 
1369         @Override
1370         public Type constructorType() {
1371             if (constructorType == null) {
1372                 List&lt;Type&gt; argtypes = recordFieldSymbols.map(v -&gt; (v.flags_field &amp; Flags.VARARGS) != 0 ? types.elemtype(v.type) : v.type);
1373                 constructorType = new MethodType(argtypes, syms.voidType, List.nil(), syms.methodClass);
1374             }
1375             return constructorType;
1376         }
1377 
1378         @Override
1379         public MethodSymbol constructorSymbol() {
1380             MethodSymbol csym = super.constructorSymbol();
1381             /* if we have to generate a default constructor for records we will treat it as the compact one
1382              * to trigger field initialization later on
1383              */
1384             csym.flags_field |= Flags.COMPACT_RECORD_CONSTRUCTOR | GENERATEDCONSTR;
1385             ListBuffer&lt;VarSymbol&gt; params = new ListBuffer&lt;&gt;();
1386             for (VarSymbol p : recordFieldSymbols) {
1387                 params.add(new VarSymbol(GENERATED_MEMBER | PARAMETER | RECORD | ((p.flags_field &amp; Flags.VARARGS) != 0 ? Flags.VARARGS : 0), p.name, p.type, csym));
1388             }
1389             csym.params = params.toList();
1390             csym.flags_field |= RECORD | PUBLIC;
1391             return csym;
1392         }
1393 
1394         @Override
1395         public JCMethodDecl finalAdjustment(JCMethodDecl md) {
1396             List&lt;JCVariableDecl&gt; tmpRecordFieldDecls = recordFieldDecls;
1397             for (JCVariableDecl arg : md.params) {
1398                 /* at this point we are passing all the annotations in the field to the corresponding
1399                  * parameter in the constructor.
1400                  */
1401                 RecordComponent rc = ((ClassSymbol) owner).getRecordComponent(arg.sym);
1402                 arg.mods.annotations = rc.getOriginalAnnos().isEmpty() ?
1403                         List.nil() :
1404                         new TreeCopier&lt;JCTree&gt;(make.at(arg.pos)).copy(rc.getOriginalAnnos());
1405                 arg.vartype = tmpRecordFieldDecls.head.vartype;
1406                 tmpRecordFieldDecls = tmpRecordFieldDecls.tail;
1407             }
1408             return md;
1409         }
1410     }
1411 
1412     JCTree defaultConstructor(TreeMaker make, DefaultConstructorHelper helper) {
1413         Type initType = helper.constructorType();
1414         MethodSymbol initSym = helper.constructorSymbol();
1415         ListBuffer&lt;JCStatement&gt; stats = new ListBuffer&lt;&gt;();
1416         if (helper.owner().type != syms.objectType) {
1417         JCExpression meth;
1418             if (!helper.enclosingType().hasTag(NONE)) {
1419                 meth = make.Select(make.Ident(initSym.params.head), names._super);
1420             } else {
1421                 meth = make.Ident(names._super);
1422             }
1423             List&lt;JCExpression&gt; typeargs = initType.getTypeArguments().nonEmpty() ?
1424                     make.Types(initType.getTypeArguments()) : null;
1425             JCStatement superCall = make.Exec(make.Apply(typeargs, meth, helper.superArgs().map(make::Ident)));
1426             stats.add(superCall);
1427         }
1428         JCMethodDecl result = make.MethodDef(initSym, make.Block(0, stats.toList()));
1429         return helper.finalAdjustment(result);
1430     }
1431 
1432     /**
1433      * Mark sym deprecated if annotations contain @Deprecated annotation.
1434      */
1435     public void markDeprecated(Symbol sym, List&lt;JCAnnotation&gt; annotations, Env&lt;AttrContext&gt; env) {
1436         // In general, we cannot fully process annotations yet,  but we
1437         // can attribute the annotation types and then check to see if the
1438         // @Deprecated annotation is present.
1439         attr.attribAnnotationTypes(annotations, env);
1440         handleDeprecatedAnnotations(annotations, sym);
1441     }
1442 
1443     /**
1444      * If a list of annotations contains a reference to java.lang.Deprecated,
1445      * set the DEPRECATED flag.
1446      * If the annotation is marked forRemoval=true, also set DEPRECATED_REMOVAL.
1447      **/
1448     private void handleDeprecatedAnnotations(List&lt;JCAnnotation&gt; annotations, Symbol sym) {
1449         for (List&lt;JCAnnotation&gt; al = annotations; !al.isEmpty(); al = al.tail) {
1450             JCAnnotation a = al.head;
1451             if (a.annotationType.type == syms.deprecatedType) {
1452                 sym.flags_field |= (Flags.DEPRECATED | Flags.DEPRECATED_ANNOTATION);
1453                 setFlagIfAttributeTrue(a, sym, names.forRemoval, DEPRECATED_REMOVAL);
1454             } else if (a.annotationType.type == syms.previewFeatureType) {
1455                 sym.flags_field |= Flags.PREVIEW_API;
1456                 setFlagIfAttributeTrue(a, sym, names.essentialAPI, PREVIEW_ESSENTIAL_API);
1457             }
1458         }
1459     }
1460     //where:
1461         private void setFlagIfAttributeTrue(JCAnnotation a, Symbol sym, Name attribute, long flag) {
1462             a.args.stream()
1463                     .filter(e -&gt; e.hasTag(ASSIGN))
1464                     .map(e -&gt; (JCAssign) e)
1465                     .filter(assign -&gt; TreeInfo.name(assign.lhs) == attribute)
1466                     .findFirst()
1467                     .ifPresent(assign -&gt; {
1468                         JCExpression rhs = TreeInfo.skipParens(assign.rhs);
1469                         if (rhs.hasTag(LITERAL)
1470                                 &amp;&amp; Boolean.TRUE.equals(((JCLiteral) rhs).getValue())) {
1471                             sym.flags_field |= flag;
1472                         }
1473                     });
1474         }
1475 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
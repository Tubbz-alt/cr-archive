<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavacParser.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../../../index.html" target="_top">index</a> next &gt;</center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavacParser.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 547     /**
 548      * Get the end position for a tree node.  The end position is
 549      * defined to be the position of the last character of the last
 550      * token of the node&#39;s source text.  Returns Position.NOPOS if end
 551      * positions are not generated or the position is otherwise not
 552      * found.
 553      * @param tree  The tree node
 554      */
 555     public int getEndPos(JCTree tree) {
 556         return endPosTable.getEndPos(tree);
 557     }
 558 
 559 
 560 
 561 /* ---------- parsing -------------- */
 562 
 563     /**
 564      * Ident = IDENTIFIER
 565      */
 566     public Name ident() {
<span class="line-modified"> 567         return ident(false);</span>
 568     }
 569 
 570     protected Name ident(boolean advanceOnErrors) {




 571         if (token.kind == IDENTIFIER) {
 572             Name name = token.name();
 573             nextToken();
 574             return name;
 575         } else if (token.kind == ASSERT) {
 576             log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.AssertAsIdentifier);
 577             nextToken();
 578             return names.error;
 579         } else if (token.kind == ENUM) {
 580             log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.EnumAsIdentifier);
 581             nextToken();
 582             return names.error;
 583         } else if (token.kind == THIS) {
 584             if (allowThisIdent) {
 585                 // Make sure we&#39;re using a supported source version.
 586                 checkSourceLevel(Feature.TYPE_ANNOTATIONS);
 587                 Name name = token.name();
 588                 nextToken();
 589                 return name;
 590             } else {
 591                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.ThisAsIdentifier);
 592                 nextToken();
 593                 return names.error;
 594             }
 595         } else if (token.kind == UNDERSCORE) {
<span class="line-modified"> 596             if (Feature.UNDERSCORE_IDENTIFIER.allowedInSource(source)) {</span>
<span class="line-modified"> 597                 log.warning(token.pos, Warnings.UnderscoreAsIdentifier);</span>
<span class="line-modified"> 598             } else {</span>
<span class="line-modified"> 599                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.UnderscoreAsIdentifier);</span>






 600             }
 601             Name name = token.name();
 602             nextToken();
 603             return name;
 604         } else {
 605             accept(IDENTIFIER);
 606             if (advanceOnErrors) {
 607                 nextToken();
 608             }
 609             return names.error;
 610         }
 611     }
 612 
 613     /**
 614      * Qualident = Ident { DOT [Annotations] Ident }
 615      */
 616     public JCExpression qualident(boolean allowAnnos) {
<span class="line-modified"> 617         JCExpression t = toP(F.at(token.pos).Ident(ident()));</span>




 618         while (token.kind == DOT) {
 619             int pos = token.pos;
 620             nextToken();
 621             List&lt;JCAnnotation&gt; tyannos = null;
 622             if (allowAnnos) {
 623                 tyannos = typeAnnotationsOpt();
 624             }
 625             t = toP(F.at(pos).Select(t, ident()));
 626             if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {
 627                 t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
 628             }
 629         }
 630         return t;
 631     }
 632 
 633     JCExpression literal(Name prefix) {
 634         return literal(prefix, token.pos);
 635     }
 636 
 637     /**
</pre>
<hr />
<pre>
1778                     break;
1779                 default:
1780                     //this includes EOF
1781                     return defaultResult;
1782             }
1783         }
1784     }
1785 
1786     /** Accepts all identifier-like tokens */
1787     protected Filter&lt;TokenKind&gt; LAX_IDENTIFIER = t -&gt; t == IDENTIFIER || t == UNDERSCORE || t == ASSERT || t == ENUM;
1788 
1789     enum ParensResult {
1790         CAST,
1791         EXPLICIT_LAMBDA,
1792         IMPLICIT_LAMBDA,
1793         PARENS
1794     }
1795 
1796     JCExpression lambdaExpressionOrStatement(boolean hasParens, boolean explicitParams, int pos) {
1797         List&lt;JCVariableDecl&gt; params = explicitParams ?
<span class="line-modified">1798                 formalParameters(true, false) :</span>
1799                 implicitParameters(hasParens);
1800         if (explicitParams) {
1801             LambdaClassifier lambdaClassifier = new LambdaClassifier();
1802             for (JCVariableDecl param: params) {
1803                 Name restrictedTypeName;
1804                 if (param.vartype != null &amp;&amp;
1805                         (restrictedTypeName = restrictedTypeName(param.vartype, false)) != null &amp;&amp;
1806                         param.vartype.hasTag(TYPEARRAY)) {
1807                     log.error(DiagnosticFlag.SYNTAX, param.pos,
1808                         Feature.VAR_SYNTAX_IMPLICIT_LAMBDAS.allowedInSource(source)
1809                             ? Errors.RestrictedTypeNotAllowedArray(restrictedTypeName) : Errors.RestrictedTypeNotAllowedHere(restrictedTypeName));
1810                 }
1811                 lambdaClassifier.addParameter(param);
1812                 if (lambdaClassifier.result() == LambdaParameterKind.ERROR) {
1813                     break;
1814                 }
1815             }
1816             if (lambdaClassifier.diagFragment != null) {
1817                 log.error(DiagnosticFlag.SYNTAX, pos, Errors.InvalidLambdaParameterDeclaration(lambdaClassifier.diagFragment));
1818             }
</pre>
<hr />
<pre>
2856 
2857     private JCStatement doRecover(int startPos, ErrorRecoveryAction action, Error errorKey) {
2858         int errPos = S.errPos();
2859         JCTree stm = action.doRecover(this);
2860         S.errPos(errPos);
2861         return toP(F.Exec(syntaxError(startPos, List.of(stm), errorKey)));
2862     }
2863 
2864     /** CatchClause     = CATCH &quot;(&quot; FormalParameter &quot;)&quot; Block
2865      * TODO: the &quot;FormalParameter&quot; is not correct, it uses the special &quot;catchTypes&quot; rule below.
2866      */
2867     protected JCCatch catchClause() {
2868         int pos = token.pos;
2869         accept(CATCH);
2870         accept(LPAREN);
2871         JCModifiers mods = optFinal(Flags.PARAMETER);
2872         List&lt;JCExpression&gt; catchTypes = catchTypes();
2873         JCExpression paramType = catchTypes.size() &gt; 1 ?
2874                 toP(F.at(catchTypes.head.getStartPosition()).TypeUnion(catchTypes)) :
2875                 catchTypes.head;
<span class="line-modified">2876         JCVariableDecl formal = variableDeclaratorId(mods, paramType);</span>
2877         accept(RPAREN);
2878         JCBlock body = block();
2879         return F.at(pos).Catch(formal, body);
2880     }
2881 
2882     List&lt;JCExpression&gt; catchTypes() {
2883         ListBuffer&lt;JCExpression&gt; catchTypes = new ListBuffer&lt;&gt;();
2884         catchTypes.add(parseType());
2885         while (token.kind == BAR) {
2886             nextToken();
2887             // Instead of qualident this is now parseType.
2888             // But would that allow too much, e.g. arrays or generics?
2889             catchTypes.add(parseType());
2890         }
2891         return catchTypes.toList();
2892     }
2893 
2894     /** SwitchBlockStatementGroups = { SwitchBlockStatementGroup }
2895      *  SwitchBlockStatementGroup = SwitchLabel BlockStatements
2896      *  SwitchLabel = CASE ConstantExpression &quot;:&quot; | DEFAULT &quot;:&quot;
</pre>
<hr />
<pre>
3353                 log.warning(pos, Warnings.RestrictedTypeNotAllowedPreview(name, Source.JDK14));
3354             }
3355         }
3356         if (name == names.sealed) {
3357             if (allowSealedTypes) {
3358                 return Source.JDK15;
3359             } else if (shouldWarn) {
3360                 log.warning(pos, Warnings.RestrictedTypeNotAllowedPreview(name, Source.JDK15));
3361             }
3362         }
3363         if (name == names.permits) {
3364             if (allowSealedTypes) {
3365                 return Source.JDK15;
3366             } else if (shouldWarn) {
3367                 log.warning(pos, Warnings.RestrictedTypeNotAllowedPreview(name, Source.JDK15));
3368             }
3369         }
3370         return null;
3371     }
3372 





























3373     /** VariableDeclaratorId = Ident BracketsOpt
3374      */
3375     JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type) {

3376         return variableDeclaratorId(mods, type, false, false);
3377     }
3378     //where
3379     JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type, boolean lambdaParameter, boolean recordComponent) {






3380         int pos = token.pos;
3381         Name name;
<span class="line-modified">3382         if (lambdaParameter &amp;&amp; token.kind == UNDERSCORE) {</span>


3383             log.error(pos, Errors.UnderscoreAsIdentifierInLambda);
3384             name = token.name();
3385             nextToken();




3386         } else {
3387             if (allowThisIdent ||
<span class="line-modified">3388                 !lambdaParameter ||</span>
3389                 LAX_IDENTIFIER.accepts(token.kind) ||
3390                 mods.flags != Flags.PARAMETER ||
3391                 mods.annotations.nonEmpty()) {
<span class="line-modified">3392                 JCExpression pn = qualident(false);</span>
3393                 if (pn.hasTag(Tag.IDENT) &amp;&amp; ((JCIdent)pn).name != names._this) {
3394                     name = ((JCIdent)pn).name;
3395                 } else {
3396                     if (allowThisIdent) {
3397                         if ((mods.flags &amp; Flags.VARARGS) != 0) {
3398                             log.error(token.pos, Errors.VarargsAndReceiver);
3399                         }
3400                         if (token.kind == LBRACKET) {
3401                             log.error(token.pos, Errors.ArrayAndReceiver);
3402                         }
3403                         if (pn.hasTag(Tag.SELECT) &amp;&amp; ((JCFieldAccess)pn).name != names._this) {
3404                             log.error(token.pos, Errors.WrongReceiver);
3405                         }
3406                     }
3407                     return toP(F.at(pos).ReceiverVarDef(mods, pn, type));
3408                 }
3409             } else {
3410                 /** if it is a lambda parameter and the token kind is not an identifier,
3411                  *  and there are no modifiers or annotations, then this means that the compiler
3412                  *  supposed the lambda to be explicit but it can contain a mix of implicit,
3413                  *  var or explicit parameters. So we assign the error name to the parameter name
3414                  *  instead of issuing an error and analyze the lambda parameters as a whole at
3415                  *  a higher level.
3416                  */
3417                 name = names.empty;
3418             }
3419         }
3420         if ((mods.flags &amp; Flags.VARARGS) != 0 &amp;&amp;
3421                 token.kind == LBRACKET) {
3422             log.error(token.pos, Errors.VarargsAndOldArraySyntax);
3423         }

3424         if (recordComponent &amp;&amp; token.kind == LBRACKET) {
3425             log.error(token.pos, Errors.RecordComponentAndOldArraySyntax);
3426         }
3427         type = bracketsOpt(type);
3428 
3429         return toP(F.at(pos).VarDef(mods, name, type, null));








3430     }
3431 
3432     /** Resources = Resource { &quot;;&quot; Resources }
3433      */
3434     List&lt;JCTree&gt; resources() {
3435         ListBuffer&lt;JCTree&gt; defs = new ListBuffer&lt;&gt;();
3436         defs.append(resource());
3437         while (token.kind == SEMI) {
3438             // All but last of multiple declarators must subsume a semicolon
3439             storeEnd(defs.last(), token.endPos);
3440             int semiColonPos = token.pos;
3441             nextToken();
3442             if (token.kind == RPAREN) { // Optional trailing semicolon
3443                                        // after last resource
3444                 break;
3445             }
3446             defs.append(resource());
3447         }
3448         return defs.toList();
3449     }
</pre>
<hr />
<pre>
3763         if (token.kind == IMPLEMENTS) {
3764             nextToken();
3765             implementing = typeList();
3766         }
3767         List&lt;JCExpression&gt; permitting = permitsClause(mods, &quot;class&quot;);
3768         List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(name, false, false);
3769         JCClassDecl result = toP(F.at(pos).ClassDef(
3770             mods, name, typarams, extending, implementing, permitting, defs));
3771         attach(result, dc);
3772         return result;
3773     }
3774 
3775     protected JCClassDecl recordDeclaration(JCModifiers mods, Comment dc) {
3776         int pos = token.pos;
3777         nextToken();
3778         mods.flags |= Flags.RECORD;
3779         Name name = typeName();
3780 
3781         List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
3782 
<span class="line-modified">3783         List&lt;JCVariableDecl&gt; headerFields = formalParameters(false, true);</span>
3784 
3785         List&lt;JCExpression&gt; implementing = List.nil();
3786         if (token.kind == IMPLEMENTS) {
3787             nextToken();
3788             implementing = typeList();
3789         }
3790         List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(name, false, true);
3791         java.util.List&lt;JCVariableDecl&gt; fields = new ArrayList&lt;&gt;();
3792         for (JCVariableDecl field : headerFields) {
3793             fields.add(field);
3794         }
3795         for (JCTree def : defs) {
3796             if (def.hasTag(METHODDEF)) {
3797                 JCMethodDecl methDef = (JCMethodDecl) def;
3798                 if (methDef.name == names.init &amp;&amp; methDef.params.isEmpty() &amp;&amp; (methDef.mods.flags &amp; Flags.COMPACT_RECORD_CONSTRUCTOR) != 0) {
3799                     ListBuffer&lt;JCVariableDecl&gt; tmpParams = new ListBuffer&lt;&gt;();
3800                     for (JCVariableDecl param : headerFields) {
3801                         tmpParams.add(F.at(param)
3802                                 // we will get flags plus annotations from the record component
3803                                 .VarDef(F.Modifiers(Flags.PARAMETER | param.mods.flags &amp; Flags.VARARGS, param.mods.annotations),
</pre>
<hr />
<pre>
4276                               Name name,
4277                               List&lt;JCTypeParameter&gt; typarams,
4278                               boolean isInterface, boolean isVoid,
4279                               boolean isRecord,
4280                               Comment dc) {
4281         if (isInterface) {
4282             if ((mods.flags &amp; Flags.STATIC) != 0) {
4283                 checkSourceLevel(Feature.STATIC_INTERFACE_METHODS);
4284             }
4285             if ((mods.flags &amp; Flags.PRIVATE) != 0) {
4286                 checkSourceLevel(Feature.PRIVATE_INTERFACE_METHODS);
4287             }
4288         }
4289         JCVariableDecl prevReceiverParam = this.receiverParam;
4290         try {
4291             this.receiverParam = null;
4292             // Parsing formalParameters sets the receiverParam, if present
4293             List&lt;JCVariableDecl&gt; params = List.nil();
4294             List&lt;JCExpression&gt; thrown = List.nil();
4295             if (!isRecord || name != names.init || token.kind == LPAREN) {
<span class="line-modified">4296                 params = formalParameters();</span>
4297                 if (!isVoid) type = bracketsOpt(type);
4298                 if (token.kind == THROWS) {
4299                     nextToken();
4300                     thrown = qualidentList(true);
4301                 }
4302             }
4303             JCBlock body = null;
4304             JCExpression defaultValue;
4305             if (token.kind == LBRACE) {
4306                 body = block();
4307                 defaultValue = null;
4308             } else {
4309                 if (token.kind == DEFAULT) {
4310                     accept(DEFAULT);
4311                     defaultValue = annotationValue();
4312                 } else {
4313                     defaultValue = null;
4314                 }
4315                 accept(SEMI);
4316                 if (token.pos &lt;= endPosTable.errorEndPos) {
</pre>
<hr />
<pre>
4392     JCTypeParameter typeParameter() {
4393         int pos = token.pos;
4394         List&lt;JCAnnotation&gt; annos = typeAnnotationsOpt();
4395         Name name = typeName();
4396         ListBuffer&lt;JCExpression&gt; bounds = new ListBuffer&lt;&gt;();
4397         if (token.kind == EXTENDS) {
4398             nextToken();
4399             bounds.append(parseType());
4400             while (token.kind == AMP) {
4401                 nextToken();
4402                 bounds.append(parseType());
4403             }
4404         }
4405         return toP(F.at(pos).TypeParameter(name, bounds.toList(), annos));
4406     }
4407 
4408     /** FormalParameters = &quot;(&quot; [ FormalParameterList ] &quot;)&quot;
4409      *  FormalParameterList = [ FormalParameterListNovarargs , ] LastFormalParameter
4410      *  FormalParameterListNovarargs = [ FormalParameterListNovarargs , ] FormalParameter
4411      */
<span class="line-modified">4412     List&lt;JCVariableDecl&gt; formalParameters() {</span>
<span class="line-removed">4413         return formalParameters(false, false);</span>
<span class="line-removed">4414     }</span>
<span class="line-removed">4415     List&lt;JCVariableDecl&gt; formalParameters(boolean lambdaParameters, boolean recordComponents) {</span>
4416         ListBuffer&lt;JCVariableDecl&gt; params = new ListBuffer&lt;&gt;();
4417         JCVariableDecl lastParam;
4418         accept(LPAREN);
4419         if (token.kind != RPAREN) {
<span class="line-modified">4420             this.allowThisIdent = !lambdaParameters &amp;&amp; !recordComponents;</span>
<span class="line-modified">4421             lastParam = formalParameter(lambdaParameters, recordComponents);</span>
4422             if (lastParam.nameexpr != null) {
4423                 this.receiverParam = lastParam;
4424             } else {
4425                 params.append(lastParam);
4426             }
4427             this.allowThisIdent = false;
4428             while (token.kind == COMMA) {
4429                 if ((lastParam.mods.flags &amp; Flags.VARARGS) != 0) {
4430                     log.error(DiagnosticFlag.SYNTAX, lastParam, Errors.VarargsMustBeLast);
4431                 }
4432                 nextToken();
<span class="line-modified">4433                 params.append(lastParam = formalParameter(lambdaParameters, recordComponents));</span>
4434             }
4435         }
4436         if (token.kind == RPAREN) {
4437             nextToken();
4438         } else {
4439             setErrorEndPos(token.pos);
4440             reportSyntaxError(S.prevToken().endPos, Errors.Expected3(COMMA, RPAREN, LBRACKET));
4441         }
4442         return params.toList();
4443     }
4444 
4445     List&lt;JCVariableDecl&gt; implicitParameters(boolean hasParens) {
4446         if (hasParens) {
4447             accept(LPAREN);
4448         }
4449         ListBuffer&lt;JCVariableDecl&gt; params = new ListBuffer&lt;&gt;();
4450         if (token.kind != RPAREN &amp;&amp; token.kind != ARROW) {
4451             params.append(implicitParameter());
4452             while (token.kind == COMMA) {
4453                 nextToken();
</pre>
<hr />
<pre>
4524             } else if (TreeInfo.typeIn(lastToModify).hasTag(SELECT)) {
4525                 ((JCFieldAccess) TreeInfo.typeIn(lastToModify)).selected = mostInnerType;
4526             } else {
4527                 // We never saw a SELECT or TYPEAPPLY, return the annotated type.
4528                 mostInnerTypeToReturn = mostInnerType;
4529             }
4530         }
4531 
4532         if (mostInnerArrayType == null) {
4533             return mostInnerTypeToReturn;
4534         } else {
4535             mostInnerArrayType.elemtype = mostInnerTypeToReturn;
4536             storeEnd(type, origEndPos);
4537             return type;
4538         }
4539     }
4540 
4541     /** FormalParameter = { FINAL | &#39;@&#39; Annotation } Type VariableDeclaratorId
4542      *  LastFormalParameter = { FINAL | &#39;@&#39; Annotation } Type &#39;...&#39; Ident | FormalParameter
4543      */
<span class="line-modified">4544     protected JCVariableDecl formalParameter(boolean lambdaParameter, boolean recordComponent) {</span>
<span class="line-modified">4545         JCModifiers mods = !recordComponent ? optFinal(Flags.PARAMETER) : modifiersOpt();</span>
<span class="line-modified">4546         if (recordComponent &amp;&amp; mods.flags != 0) {</span>
4547             log.error(mods.pos, Errors.RecordCantDeclareFieldModifiers);
4548         }
<span class="line-modified">4549         if (recordComponent) {</span>
4550             mods.flags |= Flags.RECORD | Flags.FINAL | Flags.PRIVATE | Flags.GENERATED_MEMBER;
4551         }
4552         // need to distinguish between vararg annos and array annos
4553         // look at typeAnnotationsPushedBack comment
4554         this.permitTypeAnnotationsPushBack = true;
<span class="line-modified">4555         JCExpression type = parseType(lambdaParameter);</span>
4556         this.permitTypeAnnotationsPushBack = false;
4557 
4558         if (token.kind == ELLIPSIS) {
4559             List&lt;JCAnnotation&gt; varargsAnnos = typeAnnotationsPushedBack;
4560             typeAnnotationsPushedBack = List.nil();
4561             mods.flags |= Flags.VARARGS;
4562             // insert var arg type annotations
4563             type = insertAnnotationsToMostInner(type, varargsAnnos, true);
4564             nextToken();
4565         } else {
4566             // if not a var arg, then typeAnnotationsPushedBack should be null
4567             if (typeAnnotationsPushedBack.nonEmpty()) {
4568                 reportSyntaxError(typeAnnotationsPushedBack.head.pos, Errors.IllegalStartOfType);
4569             }
4570             typeAnnotationsPushedBack = List.nil();
4571         }

4572         return variableDeclaratorId(mods, type, lambdaParameter, recordComponent);



4573     }
4574 
4575     protected JCVariableDecl implicitParameter() {
4576         JCModifiers mods = F.at(token.pos).Modifiers(Flags.PARAMETER);

4577         return variableDeclaratorId(mods, null, true, false);



4578     }
4579 
4580 /* ---------- auxiliary methods -------------- */
4581     /** Check that given tree is a legal expression statement.
4582      */
4583     protected JCExpression checkExprStat(JCExpression t) {
4584         if (!TreeInfo.isExpressionStatement(t)) {
4585             JCExpression ret = F.at(t.pos).Erroneous(List.&lt;JCTree&gt;of(t));
4586             log.error(DiagnosticFlag.SYNTAX, ret, Errors.NotStmt);
4587             return ret;
4588         } else {
4589             return t;
4590         }
4591     }
4592 
4593     /** Return precedence of operator represented by token,
4594      *  -1 if token is not a binary operator. @see TreeInfo.opPrec
4595      */
4596     static int prec(TokenKind token) {
4597         JCTree.Tag oc = optag(token);
</pre>
</td>
<td>
<hr />
<pre>
 547     /**
 548      * Get the end position for a tree node.  The end position is
 549      * defined to be the position of the last character of the last
 550      * token of the node&#39;s source text.  Returns Position.NOPOS if end
 551      * positions are not generated or the position is otherwise not
 552      * found.
 553      * @param tree  The tree node
 554      */
 555     public int getEndPos(JCTree tree) {
 556         return endPosTable.getEndPos(tree);
 557     }
 558 
 559 
 560 
 561 /* ---------- parsing -------------- */
 562 
 563     /**
 564      * Ident = IDENTIFIER
 565      */
 566     public Name ident() {
<span class="line-modified"> 567         return ident(false, false);</span>
 568     }
 569 
 570     protected Name ident(boolean advanceOnErrors) {
<span class="line-added"> 571         return ident(advanceOnErrors, false);</span>
<span class="line-added"> 572     }</span>
<span class="line-added"> 573 </span>
<span class="line-added"> 574     protected Name ident(boolean advanceOnErrors, boolean underscoreAllowed) {</span>
 575         if (token.kind == IDENTIFIER) {
 576             Name name = token.name();
 577             nextToken();
 578             return name;
 579         } else if (token.kind == ASSERT) {
 580             log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.AssertAsIdentifier);
 581             nextToken();
 582             return names.error;
 583         } else if (token.kind == ENUM) {
 584             log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.EnumAsIdentifier);
 585             nextToken();
 586             return names.error;
 587         } else if (token.kind == THIS) {
 588             if (allowThisIdent) {
 589                 // Make sure we&#39;re using a supported source version.
 590                 checkSourceLevel(Feature.TYPE_ANNOTATIONS);
 591                 Name name = token.name();
 592                 nextToken();
 593                 return name;
 594             } else {
 595                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.ThisAsIdentifier);
 596                 nextToken();
 597                 return names.error;
 598             }
 599         } else if (token.kind == UNDERSCORE) {
<span class="line-modified"> 600             if (!underscoreAllowed) {</span>
<span class="line-modified"> 601                 if (Feature.UNDERSCORE_AS_PARAM_NAME.allowedInSource(source)) {</span>
<span class="line-modified"> 602                     log.error(token.pos, Errors.UnderscoreNotAllowed);</span>
<span class="line-modified"> 603                 } else {</span>
<span class="line-added"> 604                     if (Feature.UNDERSCORE_IDENTIFIER.allowedInSource(source)) {</span>
<span class="line-added"> 605                         log.warning(token.pos, Warnings.UnderscoreAsIdentifier);</span>
<span class="line-added"> 606                     } else {</span>
<span class="line-added"> 607                         log.error(token.pos, Errors.UnderscoreAsIdentifier);</span>
<span class="line-added"> 608                     }</span>
<span class="line-added"> 609                 }</span>
 610             }
 611             Name name = token.name();
 612             nextToken();
 613             return name;
 614         } else {
 615             accept(IDENTIFIER);
 616             if (advanceOnErrors) {
 617                 nextToken();
 618             }
 619             return names.error;
 620         }
 621     }
 622 
 623     /**
 624      * Qualident = Ident { DOT [Annotations] Ident }
 625      */
 626     public JCExpression qualident(boolean allowAnnos) {
<span class="line-modified"> 627         return qualident(allowAnnos, false);</span>
<span class="line-added"> 628     }</span>
<span class="line-added"> 629 </span>
<span class="line-added"> 630     public JCExpression qualident(boolean allowAnnos, boolean underscoreAllowed) {</span>
<span class="line-added"> 631         JCExpression t = toP(F.at(token.pos).Ident(ident(false, underscoreAllowed)));</span>
 632         while (token.kind == DOT) {
 633             int pos = token.pos;
 634             nextToken();
 635             List&lt;JCAnnotation&gt; tyannos = null;
 636             if (allowAnnos) {
 637                 tyannos = typeAnnotationsOpt();
 638             }
 639             t = toP(F.at(pos).Select(t, ident()));
 640             if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {
 641                 t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
 642             }
 643         }
 644         return t;
 645     }
 646 
 647     JCExpression literal(Name prefix) {
 648         return literal(prefix, token.pos);
 649     }
 650 
 651     /**
</pre>
<hr />
<pre>
1792                     break;
1793                 default:
1794                     //this includes EOF
1795                     return defaultResult;
1796             }
1797         }
1798     }
1799 
1800     /** Accepts all identifier-like tokens */
1801     protected Filter&lt;TokenKind&gt; LAX_IDENTIFIER = t -&gt; t == IDENTIFIER || t == UNDERSCORE || t == ASSERT || t == ENUM;
1802 
1803     enum ParensResult {
1804         CAST,
1805         EXPLICIT_LAMBDA,
1806         IMPLICIT_LAMBDA,
1807         PARENS
1808     }
1809 
1810     JCExpression lambdaExpressionOrStatement(boolean hasParens, boolean explicitParams, int pos) {
1811         List&lt;JCVariableDecl&gt; params = explicitParams ?
<span class="line-modified">1812                 formalParameters(FormalParameterKind.LAMBDA) :</span>
1813                 implicitParameters(hasParens);
1814         if (explicitParams) {
1815             LambdaClassifier lambdaClassifier = new LambdaClassifier();
1816             for (JCVariableDecl param: params) {
1817                 Name restrictedTypeName;
1818                 if (param.vartype != null &amp;&amp;
1819                         (restrictedTypeName = restrictedTypeName(param.vartype, false)) != null &amp;&amp;
1820                         param.vartype.hasTag(TYPEARRAY)) {
1821                     log.error(DiagnosticFlag.SYNTAX, param.pos,
1822                         Feature.VAR_SYNTAX_IMPLICIT_LAMBDAS.allowedInSource(source)
1823                             ? Errors.RestrictedTypeNotAllowedArray(restrictedTypeName) : Errors.RestrictedTypeNotAllowedHere(restrictedTypeName));
1824                 }
1825                 lambdaClassifier.addParameter(param);
1826                 if (lambdaClassifier.result() == LambdaParameterKind.ERROR) {
1827                     break;
1828                 }
1829             }
1830             if (lambdaClassifier.diagFragment != null) {
1831                 log.error(DiagnosticFlag.SYNTAX, pos, Errors.InvalidLambdaParameterDeclaration(lambdaClassifier.diagFragment));
1832             }
</pre>
<hr />
<pre>
2870 
2871     private JCStatement doRecover(int startPos, ErrorRecoveryAction action, Error errorKey) {
2872         int errPos = S.errPos();
2873         JCTree stm = action.doRecover(this);
2874         S.errPos(errPos);
2875         return toP(F.Exec(syntaxError(startPos, List.of(stm), errorKey)));
2876     }
2877 
2878     /** CatchClause     = CATCH &quot;(&quot; FormalParameter &quot;)&quot; Block
2879      * TODO: the &quot;FormalParameter&quot; is not correct, it uses the special &quot;catchTypes&quot; rule below.
2880      */
2881     protected JCCatch catchClause() {
2882         int pos = token.pos;
2883         accept(CATCH);
2884         accept(LPAREN);
2885         JCModifiers mods = optFinal(Flags.PARAMETER);
2886         List&lt;JCExpression&gt; catchTypes = catchTypes();
2887         JCExpression paramType = catchTypes.size() &gt; 1 ?
2888                 toP(F.at(catchTypes.head.getStartPosition()).TypeUnion(catchTypes)) :
2889                 catchTypes.head;
<span class="line-modified">2890         JCVariableDecl formal = variableDeclaratorId(mods, paramType, FormalParameterKind.CATCH);</span>
2891         accept(RPAREN);
2892         JCBlock body = block();
2893         return F.at(pos).Catch(formal, body);
2894     }
2895 
2896     List&lt;JCExpression&gt; catchTypes() {
2897         ListBuffer&lt;JCExpression&gt; catchTypes = new ListBuffer&lt;&gt;();
2898         catchTypes.add(parseType());
2899         while (token.kind == BAR) {
2900             nextToken();
2901             // Instead of qualident this is now parseType.
2902             // But would that allow too much, e.g. arrays or generics?
2903             catchTypes.add(parseType());
2904         }
2905         return catchTypes.toList();
2906     }
2907 
2908     /** SwitchBlockStatementGroups = { SwitchBlockStatementGroup }
2909      *  SwitchBlockStatementGroup = SwitchLabel BlockStatements
2910      *  SwitchLabel = CASE ConstantExpression &quot;:&quot; | DEFAULT &quot;:&quot;
</pre>
<hr />
<pre>
3367                 log.warning(pos, Warnings.RestrictedTypeNotAllowedPreview(name, Source.JDK14));
3368             }
3369         }
3370         if (name == names.sealed) {
3371             if (allowSealedTypes) {
3372                 return Source.JDK15;
3373             } else if (shouldWarn) {
3374                 log.warning(pos, Warnings.RestrictedTypeNotAllowedPreview(name, Source.JDK15));
3375             }
3376         }
3377         if (name == names.permits) {
3378             if (allowSealedTypes) {
3379                 return Source.JDK15;
3380             } else if (shouldWarn) {
3381                 log.warning(pos, Warnings.RestrictedTypeNotAllowedPreview(name, Source.JDK15));
3382             }
3383         }
3384         return null;
3385     }
3386 
<span class="line-added">3387     /** The kind of a formal parameter</span>
<span class="line-added">3388      */</span>
<span class="line-added">3389     enum FormalParameterKind {</span>
<span class="line-added">3390         /* a formal lambda parameter</span>
<span class="line-added">3391          */</span>
<span class="line-added">3392         LAMBDA {</span>
<span class="line-added">3393             @Override</span>
<span class="line-added">3394             boolean isLambdaParameter() {</span>
<span class="line-added">3395                 return true;</span>
<span class="line-added">3396             }</span>
<span class="line-added">3397         },</span>
<span class="line-added">3398         /* a formal catch clause parameter</span>
<span class="line-added">3399          */</span>
<span class="line-added">3400         CATCH,</span>
<span class="line-added">3401         /* a formal method parameter</span>
<span class="line-added">3402          */</span>
<span class="line-added">3403         METHOD,</span>
<span class="line-added">3404         /* a formal record parameter</span>
<span class="line-added">3405          */</span>
<span class="line-added">3406         RECORD;</span>
<span class="line-added">3407 </span>
<span class="line-added">3408         boolean isLambdaParameter() {</span>
<span class="line-added">3409             return false;</span>
<span class="line-added">3410         }</span>
<span class="line-added">3411         boolean isRecordParameter() {</span>
<span class="line-added">3412             return false;</span>
<span class="line-added">3413         }</span>
<span class="line-added">3414     }</span>
<span class="line-added">3415 </span>
3416     /** VariableDeclaratorId = Ident BracketsOpt
3417      */
3418     JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type) {
<span class="line-added">3419 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span>
3420         return variableDeclaratorId(mods, type, false, false);
3421     }
3422     //where
3423     JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type, boolean lambdaParameter, boolean recordComponent) {
<span class="line-added">3424 =======</span>
<span class="line-added">3425         return variableDeclaratorId(mods, type, FormalParameterKind.METHOD);</span>
<span class="line-added">3426     }</span>
<span class="line-added">3427 </span>
<span class="line-added">3428     JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type, FormalParameterKind parameterKind) {</span>
<span class="line-added">3429 &gt;&gt;&gt;&gt;&gt;&gt;&gt; 7cffdc99929e9bbd89765c7d0e8390f9e40fe238</span>
3430         int pos = token.pos;
3431         Name name;
<span class="line-modified">3432         boolean allowUnderscoreAsFormal = Feature.UNDERSCORE_AS_PARAM_NAME.allowedInSource(source);</span>
<span class="line-added">3433         boolean isUnderscore = token.kind == UNDERSCORE;</span>
<span class="line-added">3434         if (parameterKind.isLambdaParameter() &amp;&amp; isUnderscore &amp;&amp; !allowUnderscoreAsFormal) {</span>
3435             log.error(pos, Errors.UnderscoreAsIdentifierInLambda);
3436             name = token.name();
3437             nextToken();
<span class="line-added">3438         } else if (parameterKind == FormalParameterKind.METHOD &amp;&amp; isUnderscore &amp;&amp; allowUnderscoreAsFormal) {</span>
<span class="line-added">3439             log.error(pos, Errors.UnderscoreAsIdentifierInMethod);</span>
<span class="line-added">3440             name = token.name();</span>
<span class="line-added">3441             nextToken();</span>
3442         } else {
3443             if (allowThisIdent ||
<span class="line-modified">3444                 parameterKind != FormalParameterKind.LAMBDA ||</span>
3445                 LAX_IDENTIFIER.accepts(token.kind) ||
3446                 mods.flags != Flags.PARAMETER ||
3447                 mods.annotations.nonEmpty()) {
<span class="line-modified">3448                 JCExpression pn = qualident(false, allowUnderscoreAsFormal);</span>
3449                 if (pn.hasTag(Tag.IDENT) &amp;&amp; ((JCIdent)pn).name != names._this) {
3450                     name = ((JCIdent)pn).name;
3451                 } else {
3452                     if (allowThisIdent) {
3453                         if ((mods.flags &amp; Flags.VARARGS) != 0) {
3454                             log.error(token.pos, Errors.VarargsAndReceiver);
3455                         }
3456                         if (token.kind == LBRACKET) {
3457                             log.error(token.pos, Errors.ArrayAndReceiver);
3458                         }
3459                         if (pn.hasTag(Tag.SELECT) &amp;&amp; ((JCFieldAccess)pn).name != names._this) {
3460                             log.error(token.pos, Errors.WrongReceiver);
3461                         }
3462                     }
3463                     return toP(F.at(pos).ReceiverVarDef(mods, pn, type));
3464                 }
3465             } else {
3466                 /** if it is a lambda parameter and the token kind is not an identifier,
3467                  *  and there are no modifiers or annotations, then this means that the compiler
3468                  *  supposed the lambda to be explicit but it can contain a mix of implicit,
3469                  *  var or explicit parameters. So we assign the error name to the parameter name
3470                  *  instead of issuing an error and analyze the lambda parameters as a whole at
3471                  *  a higher level.
3472                  */
3473                 name = names.empty;
3474             }
3475         }
3476         if ((mods.flags &amp; Flags.VARARGS) != 0 &amp;&amp;
3477                 token.kind == LBRACKET) {
3478             log.error(token.pos, Errors.VarargsAndOldArraySyntax);
3479         }
<span class="line-added">3480 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span>
3481         if (recordComponent &amp;&amp; token.kind == LBRACKET) {
3482             log.error(token.pos, Errors.RecordComponentAndOldArraySyntax);
3483         }
3484         type = bracketsOpt(type);
3485 
3486         return toP(F.at(pos).VarDef(mods, name, type, null));
<span class="line-added">3487 =======</span>
<span class="line-added">3488         int dimensionsPos = token.pos;</span>
<span class="line-added">3489         JCExpression typeWithDimensions = bracketsOpt(type);</span>
<span class="line-added">3490         if (allowUnderscoreAsFormal &amp;&amp; isUnderscore &amp;&amp; typeWithDimensions != type) {</span>
<span class="line-added">3491             log.error(dimensionsPos, Errors.UnderscoreCantBeFollowedByDimensions);</span>
<span class="line-added">3492         }</span>
<span class="line-added">3493         return toP(F.at(pos).VarDef(mods, name, typeWithDimensions, null));</span>
<span class="line-added">3494 &gt;&gt;&gt;&gt;&gt;&gt;&gt; 7cffdc99929e9bbd89765c7d0e8390f9e40fe238</span>
3495     }
3496 
3497     /** Resources = Resource { &quot;;&quot; Resources }
3498      */
3499     List&lt;JCTree&gt; resources() {
3500         ListBuffer&lt;JCTree&gt; defs = new ListBuffer&lt;&gt;();
3501         defs.append(resource());
3502         while (token.kind == SEMI) {
3503             // All but last of multiple declarators must subsume a semicolon
3504             storeEnd(defs.last(), token.endPos);
3505             int semiColonPos = token.pos;
3506             nextToken();
3507             if (token.kind == RPAREN) { // Optional trailing semicolon
3508                                        // after last resource
3509                 break;
3510             }
3511             defs.append(resource());
3512         }
3513         return defs.toList();
3514     }
</pre>
<hr />
<pre>
3828         if (token.kind == IMPLEMENTS) {
3829             nextToken();
3830             implementing = typeList();
3831         }
3832         List&lt;JCExpression&gt; permitting = permitsClause(mods, &quot;class&quot;);
3833         List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(name, false, false);
3834         JCClassDecl result = toP(F.at(pos).ClassDef(
3835             mods, name, typarams, extending, implementing, permitting, defs));
3836         attach(result, dc);
3837         return result;
3838     }
3839 
3840     protected JCClassDecl recordDeclaration(JCModifiers mods, Comment dc) {
3841         int pos = token.pos;
3842         nextToken();
3843         mods.flags |= Flags.RECORD;
3844         Name name = typeName();
3845 
3846         List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
3847 
<span class="line-modified">3848         List&lt;JCVariableDecl&gt; headerFields = formalParameters(FormalParameterKind.RECORD);</span>
3849 
3850         List&lt;JCExpression&gt; implementing = List.nil();
3851         if (token.kind == IMPLEMENTS) {
3852             nextToken();
3853             implementing = typeList();
3854         }
3855         List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(name, false, true);
3856         java.util.List&lt;JCVariableDecl&gt; fields = new ArrayList&lt;&gt;();
3857         for (JCVariableDecl field : headerFields) {
3858             fields.add(field);
3859         }
3860         for (JCTree def : defs) {
3861             if (def.hasTag(METHODDEF)) {
3862                 JCMethodDecl methDef = (JCMethodDecl) def;
3863                 if (methDef.name == names.init &amp;&amp; methDef.params.isEmpty() &amp;&amp; (methDef.mods.flags &amp; Flags.COMPACT_RECORD_CONSTRUCTOR) != 0) {
3864                     ListBuffer&lt;JCVariableDecl&gt; tmpParams = new ListBuffer&lt;&gt;();
3865                     for (JCVariableDecl param : headerFields) {
3866                         tmpParams.add(F.at(param)
3867                                 // we will get flags plus annotations from the record component
3868                                 .VarDef(F.Modifiers(Flags.PARAMETER | param.mods.flags &amp; Flags.VARARGS, param.mods.annotations),
</pre>
<hr />
<pre>
4341                               Name name,
4342                               List&lt;JCTypeParameter&gt; typarams,
4343                               boolean isInterface, boolean isVoid,
4344                               boolean isRecord,
4345                               Comment dc) {
4346         if (isInterface) {
4347             if ((mods.flags &amp; Flags.STATIC) != 0) {
4348                 checkSourceLevel(Feature.STATIC_INTERFACE_METHODS);
4349             }
4350             if ((mods.flags &amp; Flags.PRIVATE) != 0) {
4351                 checkSourceLevel(Feature.PRIVATE_INTERFACE_METHODS);
4352             }
4353         }
4354         JCVariableDecl prevReceiverParam = this.receiverParam;
4355         try {
4356             this.receiverParam = null;
4357             // Parsing formalParameters sets the receiverParam, if present
4358             List&lt;JCVariableDecl&gt; params = List.nil();
4359             List&lt;JCExpression&gt; thrown = List.nil();
4360             if (!isRecord || name != names.init || token.kind == LPAREN) {
<span class="line-modified">4361                 params = formalParameters(FormalParameterKind.METHOD);</span>
4362                 if (!isVoid) type = bracketsOpt(type);
4363                 if (token.kind == THROWS) {
4364                     nextToken();
4365                     thrown = qualidentList(true);
4366                 }
4367             }
4368             JCBlock body = null;
4369             JCExpression defaultValue;
4370             if (token.kind == LBRACE) {
4371                 body = block();
4372                 defaultValue = null;
4373             } else {
4374                 if (token.kind == DEFAULT) {
4375                     accept(DEFAULT);
4376                     defaultValue = annotationValue();
4377                 } else {
4378                     defaultValue = null;
4379                 }
4380                 accept(SEMI);
4381                 if (token.pos &lt;= endPosTable.errorEndPos) {
</pre>
<hr />
<pre>
4457     JCTypeParameter typeParameter() {
4458         int pos = token.pos;
4459         List&lt;JCAnnotation&gt; annos = typeAnnotationsOpt();
4460         Name name = typeName();
4461         ListBuffer&lt;JCExpression&gt; bounds = new ListBuffer&lt;&gt;();
4462         if (token.kind == EXTENDS) {
4463             nextToken();
4464             bounds.append(parseType());
4465             while (token.kind == AMP) {
4466                 nextToken();
4467                 bounds.append(parseType());
4468             }
4469         }
4470         return toP(F.at(pos).TypeParameter(name, bounds.toList(), annos));
4471     }
4472 
4473     /** FormalParameters = &quot;(&quot; [ FormalParameterList ] &quot;)&quot;
4474      *  FormalParameterList = [ FormalParameterListNovarargs , ] LastFormalParameter
4475      *  FormalParameterListNovarargs = [ FormalParameterListNovarargs , ] FormalParameter
4476      */
<span class="line-modified">4477     List&lt;JCVariableDecl&gt; formalParameters(FormalParameterKind parameterKind) {</span>



4478         ListBuffer&lt;JCVariableDecl&gt; params = new ListBuffer&lt;&gt;();
4479         JCVariableDecl lastParam;
4480         accept(LPAREN);
4481         if (token.kind != RPAREN) {
<span class="line-modified">4482             this.allowThisIdent = parameterKind != FormalParameterKind.LAMBDA &amp;&amp; parameterKind != FormalParameterKind.RECORD;</span>
<span class="line-modified">4483             lastParam = formalParameter(parameterKind);</span>
4484             if (lastParam.nameexpr != null) {
4485                 this.receiverParam = lastParam;
4486             } else {
4487                 params.append(lastParam);
4488             }
4489             this.allowThisIdent = false;
4490             while (token.kind == COMMA) {
4491                 if ((lastParam.mods.flags &amp; Flags.VARARGS) != 0) {
4492                     log.error(DiagnosticFlag.SYNTAX, lastParam, Errors.VarargsMustBeLast);
4493                 }
4494                 nextToken();
<span class="line-modified">4495                 params.append(lastParam = formalParameter(parameterKind));</span>
4496             }
4497         }
4498         if (token.kind == RPAREN) {
4499             nextToken();
4500         } else {
4501             setErrorEndPos(token.pos);
4502             reportSyntaxError(S.prevToken().endPos, Errors.Expected3(COMMA, RPAREN, LBRACKET));
4503         }
4504         return params.toList();
4505     }
4506 
4507     List&lt;JCVariableDecl&gt; implicitParameters(boolean hasParens) {
4508         if (hasParens) {
4509             accept(LPAREN);
4510         }
4511         ListBuffer&lt;JCVariableDecl&gt; params = new ListBuffer&lt;&gt;();
4512         if (token.kind != RPAREN &amp;&amp; token.kind != ARROW) {
4513             params.append(implicitParameter());
4514             while (token.kind == COMMA) {
4515                 nextToken();
</pre>
<hr />
<pre>
4586             } else if (TreeInfo.typeIn(lastToModify).hasTag(SELECT)) {
4587                 ((JCFieldAccess) TreeInfo.typeIn(lastToModify)).selected = mostInnerType;
4588             } else {
4589                 // We never saw a SELECT or TYPEAPPLY, return the annotated type.
4590                 mostInnerTypeToReturn = mostInnerType;
4591             }
4592         }
4593 
4594         if (mostInnerArrayType == null) {
4595             return mostInnerTypeToReturn;
4596         } else {
4597             mostInnerArrayType.elemtype = mostInnerTypeToReturn;
4598             storeEnd(type, origEndPos);
4599             return type;
4600         }
4601     }
4602 
4603     /** FormalParameter = { FINAL | &#39;@&#39; Annotation } Type VariableDeclaratorId
4604      *  LastFormalParameter = { FINAL | &#39;@&#39; Annotation } Type &#39;...&#39; Ident | FormalParameter
4605      */
<span class="line-modified">4606     protected JCVariableDecl formalParameter(FormalParameterKind parameterKind) {</span>
<span class="line-modified">4607         JCModifiers mods = parameterKind != FormalParameterKind.RECORD ? optFinal(Flags.PARAMETER) : modifiersOpt();</span>
<span class="line-modified">4608         if (parameterKind == FormalParameterKind.RECORD &amp;&amp; mods.flags != 0) {</span>
4609             log.error(mods.pos, Errors.RecordCantDeclareFieldModifiers);
4610         }
<span class="line-modified">4611         if (parameterKind == FormalParameterKind.RECORD) {</span>
4612             mods.flags |= Flags.RECORD | Flags.FINAL | Flags.PRIVATE | Flags.GENERATED_MEMBER;
4613         }
4614         // need to distinguish between vararg annos and array annos
4615         // look at typeAnnotationsPushedBack comment
4616         this.permitTypeAnnotationsPushBack = true;
<span class="line-modified">4617         JCExpression type = parseType(parameterKind == FormalParameterKind.LAMBDA);</span>
4618         this.permitTypeAnnotationsPushBack = false;
4619 
4620         if (token.kind == ELLIPSIS) {
4621             List&lt;JCAnnotation&gt; varargsAnnos = typeAnnotationsPushedBack;
4622             typeAnnotationsPushedBack = List.nil();
4623             mods.flags |= Flags.VARARGS;
4624             // insert var arg type annotations
4625             type = insertAnnotationsToMostInner(type, varargsAnnos, true);
4626             nextToken();
4627         } else {
4628             // if not a var arg, then typeAnnotationsPushedBack should be null
4629             if (typeAnnotationsPushedBack.nonEmpty()) {
4630                 reportSyntaxError(typeAnnotationsPushedBack.head.pos, Errors.IllegalStartOfType);
4631             }
4632             typeAnnotationsPushedBack = List.nil();
4633         }
<span class="line-added">4634 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span>
4635         return variableDeclaratorId(mods, type, lambdaParameter, recordComponent);
<span class="line-added">4636 =======</span>
<span class="line-added">4637         return variableDeclaratorId(mods, type, parameterKind);</span>
<span class="line-added">4638 &gt;&gt;&gt;&gt;&gt;&gt;&gt; 7cffdc99929e9bbd89765c7d0e8390f9e40fe238</span>
4639     }
4640 
4641     protected JCVariableDecl implicitParameter() {
4642         JCModifiers mods = F.at(token.pos).Modifiers(Flags.PARAMETER);
<span class="line-added">4643 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span>
4644         return variableDeclaratorId(mods, null, true, false);
<span class="line-added">4645 =======</span>
<span class="line-added">4646         return variableDeclaratorId(mods, null, FormalParameterKind.LAMBDA);</span>
<span class="line-added">4647 &gt;&gt;&gt;&gt;&gt;&gt;&gt; 7cffdc99929e9bbd89765c7d0e8390f9e40fe238</span>
4648     }
4649 
4650 /* ---------- auxiliary methods -------------- */
4651     /** Check that given tree is a legal expression statement.
4652      */
4653     protected JCExpression checkExprStat(JCExpression t) {
4654         if (!TreeInfo.isExpressionStatement(t)) {
4655             JCExpression ret = F.at(t.pos).Erroneous(List.&lt;JCTree&gt;of(t));
4656             log.error(DiagnosticFlag.SYNTAX, ret, Errors.NotStmt);
4657             return ret;
4658         } else {
4659             return t;
4660         }
4661     }
4662 
4663     /** Return precedence of operator represented by token,
4664      *  -1 if token is not a binary operator. @see TreeInfo.opPrec
4665      */
4666     static int prec(TokenKind token) {
4667         JCTree.Tag oc = optag(token);
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../../../index.html" target="_top">index</a> next &gt;</center>  </body>
</html>
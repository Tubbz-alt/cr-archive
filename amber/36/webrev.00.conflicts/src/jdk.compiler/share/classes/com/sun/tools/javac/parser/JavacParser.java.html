<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavacParser.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.parser;
  27 
  28 import java.util.*;
  29 import java.util.function.Function;
  30 import java.util.stream.Collectors;
  31 
  32 import com.sun.source.tree.CaseTree;
  33 import com.sun.source.tree.MemberReferenceTree.ReferenceMode;
  34 import com.sun.source.tree.ModuleTree.ModuleKind;
  35 
  36 import com.sun.tools.javac.code.*;
  37 import com.sun.tools.javac.code.Source.Feature;
  38 import com.sun.tools.javac.parser.Tokens.*;
  39 import com.sun.tools.javac.parser.Tokens.Comment.CommentStyle;
  40 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  41 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  42 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  43 import com.sun.tools.javac.tree.*;
  44 import com.sun.tools.javac.tree.JCTree.*;
  45 import com.sun.tools.javac.util.*;
  46 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
  47 import com.sun.tools.javac.util.JCDiagnostic.Error;
  48 import com.sun.tools.javac.util.JCDiagnostic.Fragment;
  49 import com.sun.tools.javac.util.List;
  50 
  51 import static com.sun.tools.javac.parser.Tokens.TokenKind.*;
  52 import static com.sun.tools.javac.parser.Tokens.TokenKind.ASSERT;
  53 import static com.sun.tools.javac.parser.Tokens.TokenKind.CASE;
  54 import static com.sun.tools.javac.parser.Tokens.TokenKind.CATCH;
  55 import static com.sun.tools.javac.parser.Tokens.TokenKind.EQ;
  56 import static com.sun.tools.javac.parser.Tokens.TokenKind.GT;
  57 import static com.sun.tools.javac.parser.Tokens.TokenKind.IMPORT;
  58 import static com.sun.tools.javac.parser.Tokens.TokenKind.LT;
  59 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  60 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.ImplicitAndExplicitNotAllowed;
  61 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.VarAndExplicitNotAllowed;
  62 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.VarAndImplicitNotAllowed;
  63 
  64 /** The parser maps a token sequence into an abstract syntax
  65  *  tree. It operates by recursive descent, with code derived
  66  *  systematically from an LL(1) grammar. For efficiency reasons, an
  67  *  operator precedence scheme is used for parsing binary operation
  68  *  expressions.
  69  *
  70  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  71  *  If you write code that depends on this, you do so at your own risk.
  72  *  This code and its internal interfaces are subject to change or
  73  *  deletion without notice.&lt;/b&gt;
  74  */
  75 public class JavacParser implements Parser {
  76 
  77     /** The number of precedence levels of infix operators.
  78      */
  79     private static final int infixPrecedenceLevels = 10;
  80 
  81     /** Is the parser instantiated to parse a module-info file ?
  82      */
  83     private final boolean parseModuleInfo;
  84 
  85     /** The scanner used for lexical analysis.
  86      */
  87     protected Lexer S;
  88 
  89     /** The factory to be used for abstract syntax tree construction.
  90      */
  91     protected TreeMaker F;
  92 
  93     /** The log to be used for error diagnostics.
  94      */
  95     private Log log;
  96 
  97     /** The Source language setting. */
  98     private Source source;
  99 
 100     /** The Preview language setting. */
 101     private Preview preview;
 102 
 103     /** The name table. */
 104     private Names names;
 105 
 106     /** End position mappings container */
 107     protected final AbstractEndPosTable endPosTable;
 108 
 109     // Because of javac&#39;s limited lookahead, some contexts are ambiguous in
 110     // the presence of type annotations even though they are not ambiguous
 111     // in the absence of type annotations.  Consider this code:
 112     //   void m(String [] m) { }
 113     //   void m(String ... m) { }
 114     // After parsing &quot;String&quot;, javac calls bracketsOpt which immediately
 115     // returns if the next character is not &#39;[&#39;.  Similarly, javac can see
 116     // if the next token is ... and in that case parse an ellipsis.  But in
 117     // the presence of type annotations:
 118     //   void m(String @A [] m) { }
 119     //   void m(String @A ... m) { }
 120     // no finite lookahead is enough to determine whether to read array
 121     // levels or an ellipsis.  Furthermore, if you call bracketsOpt, then
 122     // bracketsOpt first reads all the leading annotations and only then
 123     // discovers that it needs to fail.  bracketsOpt needs a way to push
 124     // back the extra annotations that it read.  (But, bracketsOpt should
 125     // not *always* be allowed to push back extra annotations that it finds
 126     // -- in most contexts, any such extra annotation is an error.
 127     //
 128     // The following two variables permit type annotations that have
 129     // already been read to be stored for later use.  Alternate
 130     // implementations are possible but would cause much larger changes to
 131     // the parser.
 132 
 133     /** Type annotations that have already been read but have not yet been used. **/
 134     private List&lt;JCAnnotation&gt; typeAnnotationsPushedBack = List.nil();
 135 
 136     /**
 137      * If the parser notices extra annotations, then it either immediately
 138      * issues an error (if this variable is false) or places the extra
 139      * annotations in variable typeAnnotationsPushedBack (if this variable
 140      * is true).
 141      */
 142     private boolean permitTypeAnnotationsPushBack = false;
 143 
 144     interface ErrorRecoveryAction {
 145         JCTree doRecover(JavacParser parser);
 146     }
 147 
 148     enum BasicErrorRecoveryAction implements ErrorRecoveryAction {
 149         BLOCK_STMT {public JCTree doRecover(JavacParser parser) { return parser.parseStatementAsBlock(); }},
 150         CATCH_CLAUSE {public JCTree doRecover(JavacParser parser) { return parser.catchClause(); }}
 151     }
 152 
 153     /** Construct a parser from a given scanner, tree factory and log.
 154      */
 155     protected JavacParser(ParserFactory fac,
 156                           Lexer S,
 157                           boolean keepDocComments,
 158                           boolean keepLineMap,
 159                           boolean keepEndPositions) {
 160         this(fac, S, keepDocComments, keepLineMap, keepEndPositions, false);
 161 
 162     }
 163     /** Construct a parser from a given scanner, tree factory and log.
 164      */
 165     protected JavacParser(ParserFactory fac,
 166                      Lexer S,
 167                      boolean keepDocComments,
 168                      boolean keepLineMap,
 169                      boolean keepEndPositions,
 170                      boolean parseModuleInfo) {
 171         this.S = S;
 172         nextToken(); // prime the pump
 173         this.F = fac.F;
 174         this.log = fac.log;
 175         this.names = fac.names;
 176         this.source = fac.source;
 177         this.preview = fac.preview;
 178         this.allowStringFolding = fac.options.getBoolean(&quot;allowStringFolding&quot;, true);
 179         this.keepDocComments = keepDocComments;
 180         this.parseModuleInfo = parseModuleInfo;
 181         docComments = newDocCommentTable(keepDocComments, fac);
 182         this.keepLineMap = keepLineMap;
 183         this.errorTree = F.Erroneous();
 184         endPosTable = newEndPosTable(keepEndPositions);
 185         this.allowYieldStatement = (!preview.isPreview(Feature.SWITCH_EXPRESSION) || preview.isEnabled()) &amp;&amp;
 186                 Feature.SWITCH_EXPRESSION.allowedInSource(source);
 187         this.allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &amp;&amp;
 188                 Feature.RECORDS.allowedInSource(source);
 189         this.allowSealedTypes = (!preview.isPreview(Feature.SEALED_CLASSES) || preview.isEnabled()) &amp;&amp;
 190                 Feature.SEALED_CLASSES.allowedInSource(source);
 191     }
 192 
 193     protected AbstractEndPosTable newEndPosTable(boolean keepEndPositions) {
 194         return  keepEndPositions
 195                 ? new SimpleEndPosTable(this)
 196                 : new EmptyEndPosTable(this);
 197     }
 198 
 199     protected DocCommentTable newDocCommentTable(boolean keepDocComments, ParserFactory fac) {
 200         return keepDocComments ? new LazyDocCommentTable(fac) : null;
 201     }
 202 
 203     /** Switch: should we fold strings?
 204      */
 205     boolean allowStringFolding;
 206 
 207     /** Switch: should we keep docComments?
 208      */
 209     boolean keepDocComments;
 210 
 211     /** Switch: should we keep line table?
 212      */
 213     boolean keepLineMap;
 214 
 215     /** Switch: is &quot;this&quot; allowed as an identifier?
 216      * This is needed to parse receiver types.
 217      */
 218     boolean allowThisIdent;
 219 
 220     /** Switch: is yield statement allowed in this source level?
 221      */
 222     boolean allowYieldStatement;
 223 
 224     /** Switch: are records allowed in this source level?
 225      */
 226     boolean allowRecords;
 227 
 228     /** Switch: are sealed types allowed in this source level?
 229      */
 230     boolean allowSealedTypes;
 231 
 232     /** The type of the method receiver, as specified by a first &quot;this&quot; parameter.
 233      */
 234     JCVariableDecl receiverParam;
 235 
 236     /** When terms are parsed, the mode determines which is expected:
 237      *     mode = EXPR        : an expression
 238      *     mode = TYPE        : a type
 239      *     mode = NOPARAMS    : no parameters allowed for type
 240      *     mode = TYPEARG     : type argument
 241      *     mode |= NOLAMBDA   : lambdas are not allowed
 242      */
 243     protected static final int EXPR = 0x1;
 244     protected static final int TYPE = 0x2;
 245     protected static final int NOPARAMS = 0x4;
 246     protected static final int TYPEARG = 0x8;
 247     protected static final int DIAMOND = 0x10;
 248     protected static final int NOLAMBDA = 0x20;
 249 
 250     protected void selectExprMode() {
 251         mode = (mode &amp; NOLAMBDA) | EXPR;
 252     }
 253 
 254     protected void selectTypeMode() {
 255         mode = (mode &amp; NOLAMBDA) | TYPE;
 256     }
 257 
 258     /** The current mode.
 259      */
 260     protected int mode = 0;
 261 
 262     /** The mode of the term that was parsed last.
 263      */
 264     protected int lastmode = 0;
 265 
 266     /* ---------- token management -------------- */
 267 
 268     protected Token token;
 269 
 270     public Token token() {
 271         return token;
 272     }
 273 
 274     public void nextToken() {
 275         S.nextToken();
 276         token = S.token();
 277     }
 278 
 279     protected boolean peekToken(Filter&lt;TokenKind&gt; tk) {
 280         return peekToken(0, tk);
 281     }
 282 
 283     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt; tk) {
 284         return tk.accepts(S.token(lookahead + 1).kind);
 285     }
 286 
 287     protected boolean peekToken(Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2) {
 288         return peekToken(0, tk1, tk2);
 289     }
 290 
 291     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2) {
 292         return tk1.accepts(S.token(lookahead + 1).kind) &amp;&amp;
 293                 tk2.accepts(S.token(lookahead + 2).kind);
 294     }
 295 
 296     protected boolean peekToken(Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2, Filter&lt;TokenKind&gt; tk3) {
 297         return peekToken(0, tk1, tk2, tk3);
 298     }
 299 
 300     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2, Filter&lt;TokenKind&gt; tk3) {
 301         return tk1.accepts(S.token(lookahead + 1).kind) &amp;&amp;
 302                 tk2.accepts(S.token(lookahead + 2).kind) &amp;&amp;
 303                 tk3.accepts(S.token(lookahead + 3).kind);
 304     }
 305 
 306     @SuppressWarnings(&quot;unchecked&quot;)
 307     protected boolean peekToken(Filter&lt;TokenKind&gt;... kinds) {
 308         return peekToken(0, kinds);
 309     }
 310 
 311     @SuppressWarnings(&quot;unchecked&quot;)
 312     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt;... kinds) {
 313         for (; lookahead &lt; kinds.length ; lookahead++) {
 314             if (!kinds[lookahead].accepts(S.token(lookahead + 1).kind)) {
 315                 return false;
 316             }
 317         }
 318         return true;
 319     }
 320 
 321     /* ---------- error recovery -------------- */
 322 
 323     private JCErroneous errorTree;
 324 
 325     /** Skip forward until a suitable stop token is found.
 326      */
 327     protected void skip(boolean stopAtImport, boolean stopAtMemberDecl, boolean stopAtIdentifier, boolean stopAtStatement) {
 328          while (true) {
 329              switch (token.kind) {
 330                 case SEMI:
 331                     nextToken();
 332                     return;
 333                 case PUBLIC:
 334                 case FINAL:
 335                 case ABSTRACT:
 336                 case MONKEYS_AT:
 337                 case EOF:
 338                 case CLASS:
 339                 case INTERFACE:
 340                 case ENUM:
 341                     return;
 342                 case IMPORT:
 343                     if (stopAtImport)
 344                         return;
 345                     break;
 346                 case LBRACE:
 347                 case RBRACE:
 348                 case PRIVATE:
 349                 case PROTECTED:
 350                 case STATIC:
 351                 case TRANSIENT:
 352                 case NATIVE:
 353                 case VOLATILE:
 354                 case SYNCHRONIZED:
 355                 case STRICTFP:
 356                 case LT:
 357                 case BYTE:
 358                 case SHORT:
 359                 case CHAR:
 360                 case INT:
 361                 case LONG:
 362                 case FLOAT:
 363                 case DOUBLE:
 364                 case BOOLEAN:
 365                 case VOID:
 366                     if (stopAtMemberDecl)
 367                         return;
 368                     break;
 369                 case UNDERSCORE:
 370                 case IDENTIFIER:
 371                    if (stopAtIdentifier)
 372                         return;
 373                     break;
 374                 case CASE:
 375                 case DEFAULT:
 376                 case IF:
 377                 case FOR:
 378                 case WHILE:
 379                 case DO:
 380                 case TRY:
 381                 case SWITCH:
 382                 case RETURN:
 383                 case THROW:
 384                 case BREAK:
 385                 case CONTINUE:
 386                 case ELSE:
 387                 case FINALLY:
 388                 case CATCH:
 389                 case THIS:
 390                 case SUPER:
 391                 case NEW:
 392                     if (stopAtStatement)
 393                         return;
 394                     break;
 395                 case ASSERT:
 396                     if (stopAtStatement)
 397                         return;
 398                     break;
 399             }
 400             nextToken();
 401         }
 402     }
 403 
 404     protected JCErroneous syntaxError(int pos, Error errorKey) {
 405         return syntaxError(pos, List.nil(), errorKey);
 406     }
 407 
 408     protected JCErroneous syntaxError(int pos, List&lt;JCTree&gt; errs, Error errorKey) {
 409         setErrorEndPos(pos);
 410         JCErroneous err = F.at(pos).Erroneous(errs);
 411         reportSyntaxError(err, errorKey);
 412         if (errs != null) {
 413             JCTree last = errs.last();
 414             if (last != null)
 415                 storeEnd(last, pos);
 416         }
 417         return toP(err);
 418     }
 419 
 420     private static final int RECOVERY_THRESHOLD = 50;
 421     private int errorPos = Position.NOPOS;
 422     private int count = 0;
 423 
 424     /**
 425      * Report a syntax using the given the position parameter and arguments,
 426      * unless one was already reported at the same position.
 427      */
 428     protected void reportSyntaxError(int pos, Error errorKey) {
 429         JCDiagnostic.DiagnosticPosition diag = new JCDiagnostic.SimpleDiagnosticPosition(pos);
 430         reportSyntaxError(diag, errorKey);
 431     }
 432 
 433     /**
 434      * Report a syntax error using the given DiagnosticPosition object and
 435      * arguments, unless one was already reported at the same position.
 436      */
 437     protected void reportSyntaxError(JCDiagnostic.DiagnosticPosition diagPos, Error errorKey) {
 438         int pos = diagPos.getPreferredPosition();
 439         if (pos &gt; S.errPos() || pos == Position.NOPOS) {
 440             if (token.kind == EOF) {
 441                 log.error(DiagnosticFlag.SYNTAX, diagPos, Errors.PrematureEof);
 442             } else {
 443                 log.error(DiagnosticFlag.SYNTAX, diagPos, errorKey);
 444             }
 445         }
 446         S.errPos(pos);
 447         if (token.pos == errorPos) {
 448             //check for a possible infinite loop in parsing:
 449             Assert.check(count++ &lt; RECOVERY_THRESHOLD);
 450         } else {
 451             count = 0;
 452             errorPos = token.pos;
 453         }
 454     }
 455 
 456     /** If next input token matches given token, skip it, otherwise report
 457      *  an error.
 458      */
 459     public void accept(TokenKind tk) {
 460         accept(tk, Errors::Expected);
 461     }
 462 
 463     /** If next input token matches given token, skip it, otherwise report
 464      *  an error.
 465      */
 466     public void accept(TokenKind tk, Function&lt;TokenKind, Error&gt; errorProvider) {
 467         if (token.kind == tk) {
 468             nextToken();
 469         } else {
 470             setErrorEndPos(token.pos);
 471             reportSyntaxError(S.prevToken().endPos, errorProvider.apply(tk));
 472         }
 473     }
 474 
 475     /** Report an illegal start of expression/type error at given position.
 476      */
 477     JCExpression illegal(int pos) {
 478         setErrorEndPos(pos);
 479         if ((mode &amp; EXPR) != 0)
 480             return syntaxError(pos, Errors.IllegalStartOfExpr);
 481         else
 482             return syntaxError(pos, Errors.IllegalStartOfType);
 483 
 484     }
 485 
 486     /** Report an illegal start of expression/type error at current position.
 487      */
 488     JCExpression illegal() {
 489         return illegal(token.pos);
 490     }
 491 
 492     /** Diagnose a modifier flag from the set, if any. */
 493     protected void checkNoMods(long mods) {
 494         if (mods != 0) {
 495             long lowestMod = mods &amp; -mods;
 496             log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.ModNotAllowedHere(Flags.asFlagSet(lowestMod)));
 497         }
 498     }
 499 
 500 /* ---------- doc comments --------- */
 501 
 502     /** A table to store all documentation comments
 503      *  indexed by the tree nodes they refer to.
 504      *  defined only if option flag keepDocComment is set.
 505      */
 506     private final DocCommentTable docComments;
 507 
 508     /** Make an entry into docComments hashtable,
 509      *  provided flag keepDocComments is set and given doc comment is non-null.
 510      *  @param tree   The tree to be used as index in the hashtable
 511      *  @param dc     The doc comment to associate with the tree, or null.
 512      */
 513     protected void attach(JCTree tree, Comment dc) {
 514         if (keepDocComments &amp;&amp; dc != null) {
 515 //          System.out.println(&quot;doc comment = &quot;);System.out.println(dc);//DEBUG
 516             docComments.putComment(tree, dc);
 517         }
 518     }
 519 
 520 /* -------- source positions ------- */
 521 
 522     protected void setErrorEndPos(int errPos) {
 523         endPosTable.setErrorEndPos(errPos);
 524     }
 525 
 526     protected void storeEnd(JCTree tree, int endpos) {
 527         endPosTable.storeEnd(tree, endpos);
 528     }
 529 
 530     protected &lt;T extends JCTree&gt; T to(T t) {
 531         return endPosTable.to(t);
 532     }
 533 
 534     protected &lt;T extends JCTree&gt; T toP(T t) {
 535         return endPosTable.toP(t);
 536     }
 537 
 538     /** Get the start position for a tree node.  The start position is
 539      * defined to be the position of the first character of the first
 540      * token of the node&#39;s source text.
 541      * @param tree  The tree node
 542      */
 543     public int getStartPos(JCTree tree) {
 544         return TreeInfo.getStartPos(tree);
 545     }
 546 
 547     /**
 548      * Get the end position for a tree node.  The end position is
 549      * defined to be the position of the last character of the last
 550      * token of the node&#39;s source text.  Returns Position.NOPOS if end
 551      * positions are not generated or the position is otherwise not
 552      * found.
 553      * @param tree  The tree node
 554      */
 555     public int getEndPos(JCTree tree) {
 556         return endPosTable.getEndPos(tree);
 557     }
 558 
 559 
 560 
 561 /* ---------- parsing -------------- */
 562 
 563     /**
 564      * Ident = IDENTIFIER
 565      */
 566     public Name ident() {
 567         return ident(false, false);
 568     }
 569 
 570     protected Name ident(boolean advanceOnErrors) {
 571         return ident(advanceOnErrors, false);
 572     }
 573 
 574     protected Name ident(boolean advanceOnErrors, boolean underscoreAllowed) {
 575         if (token.kind == IDENTIFIER) {
 576             Name name = token.name();
 577             nextToken();
 578             return name;
 579         } else if (token.kind == ASSERT) {
 580             log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.AssertAsIdentifier);
 581             nextToken();
 582             return names.error;
 583         } else if (token.kind == ENUM) {
 584             log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.EnumAsIdentifier);
 585             nextToken();
 586             return names.error;
 587         } else if (token.kind == THIS) {
 588             if (allowThisIdent) {
 589                 // Make sure we&#39;re using a supported source version.
 590                 checkSourceLevel(Feature.TYPE_ANNOTATIONS);
 591                 Name name = token.name();
 592                 nextToken();
 593                 return name;
 594             } else {
 595                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.ThisAsIdentifier);
 596                 nextToken();
 597                 return names.error;
 598             }
 599         } else if (token.kind == UNDERSCORE) {
 600             if (!underscoreAllowed) {
 601                 if (Feature.UNDERSCORE_AS_PARAM_NAME.allowedInSource(source)) {
 602                     log.error(token.pos, Errors.UnderscoreNotAllowed);
 603                 } else {
 604                     if (Feature.UNDERSCORE_IDENTIFIER.allowedInSource(source)) {
 605                         log.warning(token.pos, Warnings.UnderscoreAsIdentifier);
 606                     } else {
 607                         log.error(token.pos, Errors.UnderscoreAsIdentifier);
 608                     }
 609                 }
 610             }
 611             Name name = token.name();
 612             nextToken();
 613             return name;
 614         } else {
 615             accept(IDENTIFIER);
 616             if (advanceOnErrors) {
 617                 nextToken();
 618             }
 619             return names.error;
 620         }
 621     }
 622 
 623     /**
 624      * Qualident = Ident { DOT [Annotations] Ident }
 625      */
 626     public JCExpression qualident(boolean allowAnnos) {
 627         return qualident(allowAnnos, false);
 628     }
 629 
 630     public JCExpression qualident(boolean allowAnnos, boolean underscoreAllowed) {
 631         JCExpression t = toP(F.at(token.pos).Ident(ident(false, underscoreAllowed)));
 632         while (token.kind == DOT) {
 633             int pos = token.pos;
 634             nextToken();
 635             List&lt;JCAnnotation&gt; tyannos = null;
 636             if (allowAnnos) {
 637                 tyannos = typeAnnotationsOpt();
 638             }
 639             t = toP(F.at(pos).Select(t, ident()));
 640             if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {
 641                 t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
 642             }
 643         }
 644         return t;
 645     }
 646 
 647     JCExpression literal(Name prefix) {
 648         return literal(prefix, token.pos);
 649     }
 650 
 651     /**
 652      * Literal =
 653      *     INTLITERAL
 654      *   | LONGLITERAL
 655      *   | FLOATLITERAL
 656      *   | DOUBLELITERAL
 657      *   | CHARLITERAL
 658      *   | STRINGLITERAL
 659      *   | TRUE
 660      *   | FALSE
 661      *   | NULL
 662      */
 663     JCExpression literal(Name prefix, int pos) {
 664         JCExpression t = errorTree;
 665         switch (token.kind) {
 666         case INTLITERAL:
 667             try {
 668                 t = F.at(pos).Literal(
 669                     TypeTag.INT,
 670                     Convert.string2int(strval(prefix), token.radix()));
 671             } catch (NumberFormatException ex) {
 672                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.IntNumberTooLarge(strval(prefix)));
 673             }
 674             break;
 675         case LONGLITERAL:
 676             try {
 677                 t = F.at(pos).Literal(
 678                     TypeTag.LONG,
 679                     Long.valueOf(Convert.string2long(strval(prefix), token.radix())));
 680             } catch (NumberFormatException ex) {
 681                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.IntNumberTooLarge(strval(prefix)));
 682             }
 683             break;
 684         case FLOATLITERAL: {
 685             String proper = token.radix() == 16 ?
 686                     (&quot;0x&quot;+ token.stringVal()) :
 687                     token.stringVal();
 688             Float n;
 689             try {
 690                 n = Float.valueOf(proper);
 691             } catch (NumberFormatException ex) {
 692                 // error already reported in scanner
 693                 n = Float.NaN;
 694             }
 695             if (n.floatValue() == 0.0f &amp;&amp; !isZero(proper))
 696                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.FpNumberTooSmall);
 697             else if (n.floatValue() == Float.POSITIVE_INFINITY)
 698                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.FpNumberTooLarge);
 699             else
 700                 t = F.at(pos).Literal(TypeTag.FLOAT, n);
 701             break;
 702         }
 703         case DOUBLELITERAL: {
 704             String proper = token.radix() == 16 ?
 705                     (&quot;0x&quot;+ token.stringVal()) :
 706                     token.stringVal();
 707             Double n;
 708             try {
 709                 n = Double.valueOf(proper);
 710             } catch (NumberFormatException ex) {
 711                 // error already reported in scanner
 712                 n = Double.NaN;
 713             }
 714             if (n.doubleValue() == 0.0d &amp;&amp; !isZero(proper))
 715                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.FpNumberTooSmall);
 716             else if (n.doubleValue() == Double.POSITIVE_INFINITY)
 717                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.FpNumberTooLarge);
 718             else
 719                 t = F.at(pos).Literal(TypeTag.DOUBLE, n);
 720             break;
 721         }
 722         case CHARLITERAL:
 723             t = F.at(pos).Literal(
 724                 TypeTag.CHAR,
 725                 token.stringVal().charAt(0) + 0);
 726             break;
 727         case STRINGLITERAL:
 728             t = F.at(pos).Literal(
 729                 TypeTag.CLASS,
 730                 token.stringVal());
 731             break;
 732         case TRUE: case FALSE:
 733             t = F.at(pos).Literal(
 734                 TypeTag.BOOLEAN,
 735                 (token.kind == TRUE ? 1 : 0));
 736             break;
 737         case NULL:
 738             t = F.at(pos).Literal(
 739                 TypeTag.BOT,
 740                 null);
 741             break;
 742         default:
 743             Assert.error();
 744         }
 745         if (t == errorTree)
 746             t = F.at(pos).Erroneous();
 747         storeEnd(t, token.endPos);
 748         nextToken();
 749         return t;
 750     }
 751     //where
 752         boolean isZero(String s) {
 753             char[] cs = s.toCharArray();
 754             int base = ((cs.length &gt; 1 &amp;&amp; Character.toLowerCase(cs[1]) == &#39;x&#39;) ? 16 : 10);
 755             int i = ((base==16) ? 2 : 0);
 756             while (i &lt; cs.length &amp;&amp; (cs[i] == &#39;0&#39; || cs[i] == &#39;.&#39;)) i++;
 757             return !(i &lt; cs.length &amp;&amp; (Character.digit(cs[i], base) &gt; 0));
 758         }
 759 
 760         String strval(Name prefix) {
 761             String s = token.stringVal();
 762             return prefix.isEmpty() ? s : prefix + s;
 763         }
 764 
 765     /** terms can be either expressions or types.
 766      */
 767     public JCExpression parseExpression() {
 768         return term(EXPR);
 769     }
 770 
 771     /**
 772      * parses (optional) type annotations followed by a type. If the
 773      * annotations are present before the type and are not consumed during array
 774      * parsing, this method returns a {@link JCAnnotatedType} consisting of
 775      * these annotations and the underlying type. Otherwise, it returns the
 776      * underlying type.
 777      *
 778      * &lt;p&gt;
 779      *
 780      * Note that this method sets {@code mode} to {@code TYPE} first, before
 781      * parsing annotations.
 782      */
 783     public JCExpression parseType() {
 784         return parseType(false);
 785     }
 786 
 787     public JCExpression parseType(boolean allowVar) {
 788         List&lt;JCAnnotation&gt; annotations = typeAnnotationsOpt();
 789         return parseType(allowVar, annotations);
 790     }
 791 
 792     public JCExpression parseType(boolean allowVar, List&lt;JCAnnotation&gt; annotations) {
 793         JCExpression result = unannotatedType(allowVar);
 794 
 795         if (annotations.nonEmpty()) {
 796             result = insertAnnotationsToMostInner(result, annotations, false);
 797         }
 798 
 799         return result;
 800     }
 801 
 802     public JCExpression unannotatedType(boolean allowVar) {
 803         JCExpression result = term(TYPE);
 804         Name restrictedTypeName = restrictedTypeName(result, !allowVar);
 805 
 806         if (restrictedTypeName != null &amp;&amp; (!allowVar || restrictedTypeName != names.var)) {
 807             syntaxError(result.pos, Errors.RestrictedTypeNotAllowedHere(restrictedTypeName));
 808         }
 809 
 810         return result;
 811     }
 812 
 813 
 814 
 815     protected JCExpression term(int newmode) {
 816         int prevmode = mode;
 817         mode = newmode;
 818         JCExpression t = term();
 819         lastmode = mode;
 820         mode = prevmode;
 821         return t;
 822     }
 823 
 824     /**
 825      *  {@literal
 826      *  Expression = Expression1 [ExpressionRest]
 827      *  ExpressionRest = [AssignmentOperator Expression1]
 828      *  AssignmentOperator = &quot;=&quot; | &quot;+=&quot; | &quot;-=&quot; | &quot;*=&quot; | &quot;/=&quot; |
 829      *                       &quot;&amp;=&quot; | &quot;|=&quot; | &quot;^=&quot; |
 830      *                       &quot;%=&quot; | &quot;&lt;&lt;=&quot; | &quot;&gt;&gt;=&quot; | &quot;&gt;&gt;&gt;=&quot;
 831      *  Type = Type1
 832      *  TypeNoParams = TypeNoParams1
 833      *  StatementExpression = Expression
 834      *  ConstantExpression = Expression
 835      *  }
 836      */
 837     JCExpression term() {
 838         JCExpression t = term1();
 839         if ((mode &amp; EXPR) != 0 &amp;&amp;
 840             (token.kind == EQ || PLUSEQ.compareTo(token.kind) &lt;= 0 &amp;&amp; token.kind.compareTo(GTGTGTEQ) &lt;= 0))
 841             return termRest(t);
 842         else
 843             return t;
 844     }
 845 
 846     JCExpression termRest(JCExpression t) {
 847         switch (token.kind) {
 848         case EQ: {
 849             int pos = token.pos;
 850             nextToken();
 851             selectExprMode();
 852             JCExpression t1 = term();
 853             return toP(F.at(pos).Assign(t, t1));
 854         }
 855         case PLUSEQ:
 856         case SUBEQ:
 857         case STAREQ:
 858         case SLASHEQ:
 859         case PERCENTEQ:
 860         case AMPEQ:
 861         case BAREQ:
 862         case CARETEQ:
 863         case LTLTEQ:
 864         case GTGTEQ:
 865         case GTGTGTEQ:
 866             int pos = token.pos;
 867             TokenKind tk = token.kind;
 868             nextToken();
 869             selectExprMode();
 870             JCExpression t1 = term();
 871             return F.at(pos).Assignop(optag(tk), t, t1);
 872         default:
 873             return t;
 874         }
 875     }
 876 
 877     /** Expression1   = Expression2 [Expression1Rest]
 878      *  Type1         = Type2
 879      *  TypeNoParams1 = TypeNoParams2
 880      */
 881     JCExpression term1() {
 882         JCExpression t = term2();
 883         if ((mode &amp; EXPR) != 0 &amp;&amp; token.kind == QUES) {
 884             selectExprMode();
 885             return term1Rest(t);
 886         } else {
 887             return t;
 888         }
 889     }
 890 
 891     /** Expression1Rest = [&quot;?&quot; Expression &quot;:&quot; Expression1]
 892      */
 893     JCExpression term1Rest(JCExpression t) {
 894         if (token.kind == QUES) {
 895             int pos = token.pos;
 896             nextToken();
 897             JCExpression t1 = term();
 898             accept(COLON);
 899             JCExpression t2 = term1();
 900             return F.at(pos).Conditional(t, t1, t2);
 901         } else {
 902             return t;
 903         }
 904     }
 905 
 906     /** Expression2   = Expression3 [Expression2Rest]
 907      *  Type2         = Type3
 908      *  TypeNoParams2 = TypeNoParams3
 909      */
 910     JCExpression term2() {
 911         JCExpression t = term3();
 912         if ((mode &amp; EXPR) != 0 &amp;&amp; prec(token.kind) &gt;= TreeInfo.orPrec) {
 913             selectExprMode();
 914             return term2Rest(t, TreeInfo.orPrec);
 915         } else {
 916             return t;
 917         }
 918     }
 919 
 920     /*  Expression2Rest = {infixop Expression3}
 921      *                  | Expression3 instanceof Type
 922      *                  | Expression3 instanceof Pattern
 923      *  infixop         = &quot;||&quot;
 924      *                  | &quot;&amp;&amp;&quot;
 925      *                  | &quot;|&quot;
 926      *                  | &quot;^&quot;
 927      *                  | &quot;&amp;&quot;
 928      *                  | &quot;==&quot; | &quot;!=&quot;
 929      *                  | &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;&lt;=&quot; | &quot;&gt;=&quot;
 930      *                  | &quot;&lt;&lt;&quot; | &quot;&gt;&gt;&quot; | &quot;&gt;&gt;&gt;&quot;
 931      *                  | &quot;+&quot; | &quot;-&quot;
 932      *                  | &quot;*&quot; | &quot;/&quot; | &quot;%&quot;
 933      */
 934     JCExpression term2Rest(JCExpression t, int minprec) {
 935         JCExpression[] odStack = newOdStack();
 936         Token[] opStack = newOpStack();
 937 
 938         // optimization, was odStack = new Tree[...]; opStack = new Tree[...];
 939         int top = 0;
 940         odStack[0] = t;
 941         int startPos = token.pos;
 942         Token topOp = Tokens.DUMMY;
 943         while (prec(token.kind) &gt;= minprec) {
 944             opStack[top] = topOp;
 945 
 946             if (token.kind == INSTANCEOF) {
 947                 int pos = token.pos;
 948                 nextToken();
 949                 JCTree pattern = parseType();
 950                 if (token.kind == IDENTIFIER) {
 951                     checkSourceLevel(token.pos, Feature.PATTERN_MATCHING_IN_INSTANCEOF);
 952                     pattern = toP(F.at(token.pos).BindingPattern(ident(), pattern));
 953                 }
 954                 odStack[top] = F.at(pos).TypeTest(odStack[top], pattern);
 955             } else {
 956                 topOp = token;
 957                 nextToken();
 958                 top++;
 959                 odStack[top] = term3();
 960             }
 961             while (top &gt; 0 &amp;&amp; prec(topOp.kind) &gt;= prec(token.kind)) {
 962                 odStack[top - 1] = F.at(topOp.pos).Binary(optag(topOp.kind), odStack[top - 1], odStack[top]);
 963                 top--;
 964                 topOp = opStack[top];
 965             }
 966         }
 967         Assert.check(top == 0);
 968         t = odStack[0];
 969 
 970         if (t.hasTag(JCTree.Tag.PLUS)) {
 971             t = foldStrings(t);
 972         }
 973 
 974         odStackSupply.add(odStack);
 975         opStackSupply.add(opStack);
 976         return t;
 977     }
 978     //where
 979         /** If tree is a concatenation of string literals, replace it
 980          *  by a single literal representing the concatenated string.
 981          */
 982         protected JCExpression foldStrings(JCExpression tree) {
 983             if (!allowStringFolding)
 984                 return tree;
 985             ListBuffer&lt;JCExpression&gt; opStack = new ListBuffer&lt;&gt;();
 986             ListBuffer&lt;JCLiteral&gt; litBuf = new ListBuffer&lt;&gt;();
 987             boolean needsFolding = false;
 988             JCExpression curr = tree;
 989             while (true) {
 990                 if (curr.hasTag(JCTree.Tag.PLUS)) {
 991                     JCBinary op = (JCBinary)curr;
 992                     needsFolding |= foldIfNeeded(op.rhs, litBuf, opStack, false);
 993                     curr = op.lhs;
 994                 } else {
 995                     needsFolding |= foldIfNeeded(curr, litBuf, opStack, true);
 996                     break; //last one!
 997                 }
 998             }
 999             if (needsFolding) {
1000                 List&lt;JCExpression&gt; ops = opStack.toList();
1001                 JCExpression res = ops.head;
1002                 for (JCExpression op : ops.tail) {
1003                     res = F.at(op.getStartPosition()).Binary(optag(TokenKind.PLUS), res, op);
1004                     storeEnd(res, getEndPos(op));
1005                 }
1006                 return res;
1007             } else {
1008                 return tree;
1009             }
1010         }
1011 
1012         private boolean foldIfNeeded(JCExpression tree, ListBuffer&lt;JCLiteral&gt; litBuf,
1013                                                 ListBuffer&lt;JCExpression&gt; opStack, boolean last) {
1014             JCLiteral str = stringLiteral(tree);
1015             if (str != null) {
1016                 litBuf.prepend(str);
1017                 return last &amp;&amp; merge(litBuf, opStack);
1018             } else {
1019                 boolean res = merge(litBuf, opStack);
1020                 litBuf.clear();
1021                 opStack.prepend(tree);
1022                 return res;
1023             }
1024         }
1025 
1026         boolean merge(ListBuffer&lt;JCLiteral&gt; litBuf, ListBuffer&lt;JCExpression&gt; opStack) {
1027             if (litBuf.isEmpty()) {
1028                 return false;
1029             } else if (litBuf.size() == 1) {
1030                 opStack.prepend(litBuf.first());
1031                 return false;
1032             } else {
1033                 JCExpression t = F.at(litBuf.first().getStartPosition()).Literal(TypeTag.CLASS,
1034                         litBuf.stream().map(lit -&gt; (String)lit.getValue()).collect(Collectors.joining()));
1035                 storeEnd(t, litBuf.last().getEndPosition(endPosTable));
1036                 opStack.prepend(t);
1037                 return true;
1038             }
1039         }
1040 
1041         private JCLiteral stringLiteral(JCTree tree) {
1042             if (tree.hasTag(LITERAL)) {
1043                 JCLiteral lit = (JCLiteral)tree;
1044                 if (lit.typetag == TypeTag.CLASS) {
1045                     return lit;
1046                 }
1047             }
1048             return null;
1049         }
1050 
1051 
1052         /** optimization: To save allocating a new operand/operator stack
1053          *  for every binary operation, we use supplys.
1054          */
1055         ArrayList&lt;JCExpression[]&gt; odStackSupply = new ArrayList&lt;&gt;();
1056         ArrayList&lt;Token[]&gt; opStackSupply = new ArrayList&lt;&gt;();
1057 
1058         private JCExpression[] newOdStack() {
1059             if (odStackSupply.isEmpty())
1060                 return new JCExpression[infixPrecedenceLevels + 1];
1061             return odStackSupply.remove(odStackSupply.size() - 1);
1062         }
1063 
1064         private Token[] newOpStack() {
1065             if (opStackSupply.isEmpty())
1066                 return new Token[infixPrecedenceLevels + 1];
1067             return opStackSupply.remove(opStackSupply.size() - 1);
1068         }
1069 
1070     /**
1071      *  Expression3    = PrefixOp Expression3
1072      *                 | &quot;(&quot; Expr | TypeNoParams &quot;)&quot; Expression3
1073      *                 | Primary {Selector} {PostfixOp}
1074      *
1075      *  {@literal
1076      *  Primary        = &quot;(&quot; Expression &quot;)&quot;
1077      *                 | Literal
1078      *                 | [TypeArguments] THIS [Arguments]
1079      *                 | [TypeArguments] SUPER SuperSuffix
1080      *                 | NEW [TypeArguments] Creator
1081      *                 | &quot;(&quot; Arguments &quot;)&quot; &quot;-&gt;&quot; ( Expression | Block )
1082      *                 | Ident &quot;-&gt;&quot; ( Expression | Block )
1083      *                 | [Annotations] Ident { &quot;.&quot; [Annotations] Ident }
1084      *                 | Expression3 MemberReferenceSuffix
1085      *                   [ [Annotations] &quot;[&quot; ( &quot;]&quot; BracketsOpt &quot;.&quot; CLASS | Expression &quot;]&quot; )
1086      *                   | Arguments
1087      *                   | &quot;.&quot; ( CLASS | THIS | [TypeArguments] SUPER Arguments | NEW [TypeArguments] InnerCreator )
1088      *                   ]
1089      *                 | BasicType BracketsOpt &quot;.&quot; CLASS
1090      *  }
1091      *
1092      *  PrefixOp       = &quot;++&quot; | &quot;--&quot; | &quot;!&quot; | &quot;~&quot; | &quot;+&quot; | &quot;-&quot;
1093      *  PostfixOp      = &quot;++&quot; | &quot;--&quot;
1094      *  Type3          = Ident { &quot;.&quot; Ident } [TypeArguments] {TypeSelector} BracketsOpt
1095      *                 | BasicType
1096      *  TypeNoParams3  = Ident { &quot;.&quot; Ident } BracketsOpt
1097      *  Selector       = &quot;.&quot; [TypeArguments] Ident [Arguments]
1098      *                 | &quot;.&quot; THIS
1099      *                 | &quot;.&quot; [TypeArguments] SUPER SuperSuffix
1100      *                 | &quot;.&quot; NEW [TypeArguments] InnerCreator
1101      *                 | &quot;[&quot; Expression &quot;]&quot;
1102      *  TypeSelector   = &quot;.&quot; Ident [TypeArguments]
1103      *  SuperSuffix    = Arguments | &quot;.&quot; Ident [Arguments]
1104      */
1105     protected JCExpression term3() {
1106         int pos = token.pos;
1107         JCExpression t;
1108         List&lt;JCExpression&gt; typeArgs = typeArgumentsOpt(EXPR);
1109         switch (token.kind) {
1110         case QUES:
1111             if ((mode &amp; TYPE) != 0 &amp;&amp; (mode &amp; (TYPEARG|NOPARAMS)) == TYPEARG) {
1112                 selectTypeMode();
1113                 return typeArgument();
1114             } else
1115                 return illegal();
1116         case PLUSPLUS: case SUBSUB: case BANG: case TILDE: case PLUS: case SUB:
1117             if (typeArgs == null &amp;&amp; (mode &amp; EXPR) != 0) {
1118                 TokenKind tk = token.kind;
1119                 nextToken();
1120                 selectExprMode();
1121                 if (tk == SUB &amp;&amp;
1122                     (token.kind == INTLITERAL || token.kind == LONGLITERAL) &amp;&amp;
1123                     token.radix() == 10) {
1124                     selectExprMode();
1125                     t = literal(names.hyphen, pos);
1126                 } else {
1127                     t = term3();
1128                     return F.at(pos).Unary(unoptag(tk), t);
1129                 }
1130             } else return illegal();
1131             break;
1132         case LPAREN:
1133             if (typeArgs == null &amp;&amp; (mode &amp; EXPR) != 0) {
1134                 ParensResult pres = analyzeParens();
1135                 switch (pres) {
1136                     case CAST:
1137                        accept(LPAREN);
1138                        selectTypeMode();
1139                        int pos1 = pos;
1140                        List&lt;JCExpression&gt; targets = List.of(t = parseType());
1141                        while (token.kind == AMP) {
1142                            checkSourceLevel(Feature.INTERSECTION_TYPES_IN_CAST);
1143                            accept(AMP);
1144                            targets = targets.prepend(parseType());
1145                        }
1146                        if (targets.length() &gt; 1) {
1147                            t = toP(F.at(pos1).TypeIntersection(targets.reverse()));
1148                        }
1149                        accept(RPAREN);
1150                        selectExprMode();
1151                        JCExpression t1 = term3();
1152                        return F.at(pos).TypeCast(t, t1);
1153                     case IMPLICIT_LAMBDA:
1154                     case EXPLICIT_LAMBDA:
1155                         t = lambdaExpressionOrStatement(true, pres == ParensResult.EXPLICIT_LAMBDA, pos);
1156                         break;
1157                     default: //PARENS
1158                         accept(LPAREN);
1159                         selectExprMode();
1160                         t = termRest(term1Rest(term2Rest(term3(), TreeInfo.orPrec)));
1161                         accept(RPAREN);
1162                         t = toP(F.at(pos).Parens(t));
1163                         break;
1164                 }
1165             } else {
1166                 return illegal();
1167             }
1168             break;
1169         case THIS:
1170             if ((mode &amp; EXPR) != 0) {
1171                 selectExprMode();
1172                 t = to(F.at(pos).Ident(names._this));
1173                 nextToken();
1174                 if (typeArgs == null)
1175                     t = argumentsOpt(null, t);
1176                 else
1177                     t = arguments(typeArgs, t);
1178                 typeArgs = null;
1179             } else return illegal();
1180             break;
1181         case SUPER:
1182             if ((mode &amp; EXPR) != 0) {
1183                 selectExprMode();
1184                 t = to(F.at(pos).Ident(names._super));
1185                 t = superSuffix(typeArgs, t);
1186                 typeArgs = null;
1187             } else return illegal();
1188             break;
1189         case INTLITERAL: case LONGLITERAL: case FLOATLITERAL: case DOUBLELITERAL:
1190         case CHARLITERAL: case STRINGLITERAL:
1191         case TRUE: case FALSE: case NULL:
1192             if (typeArgs == null &amp;&amp; (mode &amp; EXPR) != 0) {
1193                 selectExprMode();
1194                 t = literal(names.empty);
1195             } else return illegal();
1196             break;
1197         case NEW:
1198             if (typeArgs != null) return illegal();
1199             if ((mode &amp; EXPR) != 0) {
1200                 selectExprMode();
1201                 nextToken();
1202                 if (token.kind == LT) typeArgs = typeArguments(false);
1203                 t = creator(pos, typeArgs);
1204                 typeArgs = null;
1205             } else return illegal();
1206             break;
1207         case MONKEYS_AT:
1208             // Only annotated cast types and method references are valid
1209             List&lt;JCAnnotation&gt; typeAnnos = typeAnnotationsOpt();
1210             if (typeAnnos.isEmpty()) {
1211                 // else there would be no &#39;@&#39;
1212                 throw new AssertionError(&quot;Expected type annotations, but found none!&quot;);
1213             }
1214 
1215             JCExpression expr = term3();
1216 
1217             if ((mode &amp; TYPE) == 0) {
1218                 // Type annotations on class literals no longer legal
1219                 switch (expr.getTag()) {
1220                 case REFERENCE: {
1221                     JCMemberReference mref = (JCMemberReference) expr;
1222                     mref.expr = toP(F.at(pos).AnnotatedType(typeAnnos, mref.expr));
1223                     t = mref;
1224                     break;
1225                 }
1226                 case SELECT: {
1227                     JCFieldAccess sel = (JCFieldAccess) expr;
1228 
1229                     if (sel.name != names._class) {
1230                         return illegal();
1231                     } else {
1232                         log.error(token.pos, Errors.NoAnnotationsOnDotClass);
1233                         return expr;
1234                     }
1235                 }
1236                 default:
1237                     return illegal(typeAnnos.head.pos);
1238                 }
1239 
1240             } else {
1241                 // Type annotations targeting a cast
1242                 t = insertAnnotationsToMostInner(expr, typeAnnos, false);
1243             }
1244             break;
1245         case UNDERSCORE: case IDENTIFIER: case ASSERT: case ENUM:
1246             if (typeArgs != null) return illegal();
1247             if ((mode &amp; EXPR) != 0 &amp;&amp; (mode &amp; NOLAMBDA) == 0 &amp;&amp; peekToken(ARROW)) {
1248                 t = lambdaExpressionOrStatement(false, false, pos);
1249             } else {
1250                 t = toP(F.at(token.pos).Ident(ident()));
1251                 loop: while (true) {
1252                     pos = token.pos;
1253                     final List&lt;JCAnnotation&gt; annos = typeAnnotationsOpt();
1254 
1255                     // need to report an error later if LBRACKET is for array
1256                     // index access rather than array creation level
1257                     if (!annos.isEmpty() &amp;&amp; token.kind != LBRACKET &amp;&amp; token.kind != ELLIPSIS)
1258                         return illegal(annos.head.pos);
1259 
1260                     switch (token.kind) {
1261                     case LBRACKET:
1262                         nextToken();
1263                         if (token.kind == RBRACKET) {
1264                             nextToken();
1265                             t = bracketsOpt(t);
1266                             t = toP(F.at(pos).TypeArray(t));
1267                             if (annos.nonEmpty()) {
1268                                 t = toP(F.at(pos).AnnotatedType(annos, t));
1269                             }
1270                             t = bracketsSuffix(t);
1271                         } else {
1272                             if ((mode &amp; EXPR) != 0) {
1273                                 selectExprMode();
1274                                 JCExpression t1 = term();
1275                                 if (!annos.isEmpty()) t = illegal(annos.head.pos);
1276                                 t = to(F.at(pos).Indexed(t, t1));
1277                             }
1278                             accept(RBRACKET);
1279                         }
1280                         break loop;
1281                     case LPAREN:
1282                         if ((mode &amp; EXPR) != 0) {
1283                             selectExprMode();
1284                             t = arguments(typeArgs, t);
1285                             if (!annos.isEmpty()) t = illegal(annos.head.pos);
1286                             typeArgs = null;
1287                         }
1288                         break loop;
1289                     case DOT:
1290                         nextToken();
1291                         if (token.kind == TokenKind.IDENTIFIER &amp;&amp; typeArgs != null) {
1292                             return illegal();
1293                         }
1294                         int oldmode = mode;
1295                         mode &amp;= ~NOPARAMS;
1296                         typeArgs = typeArgumentsOpt(EXPR);
1297                         mode = oldmode;
1298                         if ((mode &amp; EXPR) != 0) {
1299                             switch (token.kind) {
1300                             case CLASS:
1301                                 if (typeArgs != null) return illegal();
1302                                 selectExprMode();
1303                                 t = to(F.at(pos).Select(t, names._class));
1304                                 nextToken();
1305                                 break loop;
1306                             case THIS:
1307                                 if (typeArgs != null) return illegal();
1308                                 selectExprMode();
1309                                 t = to(F.at(pos).Select(t, names._this));
1310                                 nextToken();
1311                                 break loop;
1312                             case SUPER:
1313                                 selectExprMode();
1314                                 t = to(F.at(pos).Select(t, names._super));
1315                                 t = superSuffix(typeArgs, t);
1316                                 typeArgs = null;
1317                                 break loop;
1318                             case NEW:
1319                                 if (typeArgs != null) return illegal();
1320                                 selectExprMode();
1321                                 int pos1 = token.pos;
1322                                 nextToken();
1323                                 if (token.kind == LT) typeArgs = typeArguments(false);
1324                                 t = innerCreator(pos1, typeArgs, t);
1325                                 typeArgs = null;
1326                                 break loop;
1327                             }
1328                         }
1329 
1330                         List&lt;JCAnnotation&gt; tyannos = null;
1331                         if ((mode &amp; TYPE) != 0 &amp;&amp; token.kind == MONKEYS_AT) {
1332                             tyannos = typeAnnotationsOpt();
1333                         }
1334                         // typeArgs saved for next loop iteration.
1335                         t = toP(F.at(pos).Select(t, ident()));
1336                         if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {
1337                             t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
1338                         }
1339                         break;
1340                     case ELLIPSIS:
1341                         if (this.permitTypeAnnotationsPushBack) {
1342                             this.typeAnnotationsPushedBack = annos;
1343                         } else if (annos.nonEmpty()) {
1344                             // Don&#39;t return here -- error recovery attempt
1345                             illegal(annos.head.pos);
1346                         }
1347                         break loop;
1348                     case LT:
1349                         if ((mode &amp; TYPE) == 0 &amp;&amp; isUnboundMemberRef()) {
1350                             //this is an unbound method reference whose qualifier
1351                             //is a generic type i.e. A&lt;S&gt;::m
1352                             int pos1 = token.pos;
1353                             accept(LT);
1354                             ListBuffer&lt;JCExpression&gt; args = new ListBuffer&lt;&gt;();
1355                             args.append(typeArgument());
1356                             while (token.kind == COMMA) {
1357                                 nextToken();
1358                                 args.append(typeArgument());
1359                             }
1360                             accept(GT);
1361                             t = toP(F.at(pos1).TypeApply(t, args.toList()));
1362                             while (token.kind == DOT) {
1363                                 nextToken();
1364                                 selectTypeMode();
1365                                 t = toP(F.at(token.pos).Select(t, ident()));
1366                                 t = typeArgumentsOpt(t);
1367                             }
1368                             t = bracketsOpt(t);
1369                             if (token.kind != COLCOL) {
1370                                 //method reference expected here
1371                                 t = illegal();
1372                             }
1373                             selectExprMode();
1374                             return term3Rest(t, typeArgs);
1375                         }
1376                         break loop;
1377                     default:
1378                         break loop;
1379                     }
1380                 }
1381             }
1382             if (typeArgs != null) illegal();
1383             t = typeArgumentsOpt(t);
1384             break;
1385         case BYTE: case SHORT: case CHAR: case INT: case LONG: case FLOAT:
1386         case DOUBLE: case BOOLEAN:
1387             if (typeArgs != null) illegal();
1388             t = bracketsSuffix(bracketsOpt(basicType()));
1389             break;
1390         case VOID:
1391             if (typeArgs != null) illegal();
1392             if ((mode &amp; EXPR) != 0) {
1393                 nextToken();
1394                 if (token.kind == DOT) {
1395                     JCPrimitiveTypeTree ti = toP(F.at(pos).TypeIdent(TypeTag.VOID));
1396                     t = bracketsSuffix(ti);
1397                 } else {
1398                     return illegal(pos);
1399                 }
1400             } else {
1401                 // Support the corner case of myMethodHandle.&lt;void&gt;invoke() by passing
1402                 // a void type (like other primitive types) to the next phase.
1403                 // The error will be reported in Attr.attribTypes or Attr.visitApply.
1404                 JCPrimitiveTypeTree ti = to(F.at(pos).TypeIdent(TypeTag.VOID));
1405                 nextToken();
1406                 return ti;
1407                 //return illegal();
1408             }
1409             break;
1410         case SWITCH:
1411             checkSourceLevel(Feature.SWITCH_EXPRESSION);
1412             allowYieldStatement = true;
1413             int switchPos = token.pos;
1414             nextToken();
1415             JCExpression selector = parExpression();
1416             accept(LBRACE);
1417             ListBuffer&lt;JCCase&gt; cases = new ListBuffer&lt;&gt;();
1418             while (true) {
1419                 pos = token.pos;
1420                 switch (token.kind) {
1421                 case CASE:
1422                 case DEFAULT:
1423                     cases.appendList(switchExpressionStatementGroup());
1424                     break;
1425                 case RBRACE: case EOF:
1426                     JCSwitchExpression e = to(F.at(switchPos).SwitchExpression(selector,
1427                                                                                cases.toList()));
1428                     e.endpos = token.pos;
1429                     accept(RBRACE);
1430                     return e;
1431                 default:
1432                     nextToken(); // to ensure progress
1433                     syntaxError(pos, Errors.Expected3(CASE, DEFAULT, RBRACE));
1434                 }
1435             }
1436         default:
1437             return illegal();
1438         }
1439         return term3Rest(t, typeArgs);
1440     }
1441 
1442     private List&lt;JCCase&gt; switchExpressionStatementGroup() {
1443         ListBuffer&lt;JCCase&gt; caseExprs = new ListBuffer&lt;&gt;();
1444         int casePos = token.pos;
1445         ListBuffer&lt;JCExpression&gt; pats = new ListBuffer&lt;&gt;();
1446 
1447         if (token.kind == DEFAULT) {
1448             nextToken();
1449         } else {
1450             accept(CASE);
1451             while (true) {
1452                 pats.append(term(EXPR | NOLAMBDA));
1453                 if (token.kind != COMMA) break;
1454                 checkSourceLevel(Feature.SWITCH_MULTIPLE_CASE_LABELS);
1455                 nextToken();
1456             };
1457         }
1458         List&lt;JCStatement&gt; stats = null;
1459         JCTree body = null;
1460         CaseTree.CaseKind kind;
1461         switch (token.kind) {
1462             case ARROW:
1463                 checkSourceLevel(Feature.SWITCH_RULE);
1464                 nextToken();
1465                 if (token.kind == TokenKind.THROW || token.kind == TokenKind.LBRACE) {
1466                     stats = List.of(parseStatement());
1467                     body = stats.head;
1468                     kind = JCCase.RULE;
1469                 } else {
1470                     JCExpression value = parseExpression();
1471                     stats = List.of(to(F.at(value).Yield(value)));
1472                     body = value;
1473                     kind = JCCase.RULE;
1474                     accept(SEMI);
1475                 }
1476                 break;
1477             default:
1478                 accept(COLON, tk -&gt; Errors.Expected2(COLON, ARROW));
1479                 stats = blockStatements();
1480                 kind = JCCase.STATEMENT;
1481                 break;
1482         }
1483         caseExprs.append(toP(F.at(casePos).Case(kind, pats.toList(), stats, body)));
1484         return caseExprs.toList();
1485     }
1486 
1487     JCExpression term3Rest(JCExpression t, List&lt;JCExpression&gt; typeArgs) {
1488         if (typeArgs != null) illegal();
1489         while (true) {
1490             int pos1 = token.pos;
1491             final List&lt;JCAnnotation&gt; annos = typeAnnotationsOpt();
1492 
1493             if (token.kind == LBRACKET) {
1494                 nextToken();
1495                 if ((mode &amp; TYPE) != 0) {
1496                     int oldmode = mode;
1497                     selectTypeMode();
1498                     if (token.kind == RBRACKET) {
1499                         nextToken();
1500                         t = bracketsOpt(t);
1501                         t = toP(F.at(pos1).TypeArray(t));
1502                         if (token.kind == COLCOL) {
1503                             selectExprMode();
1504                             continue;
1505                         }
1506                         if (annos.nonEmpty()) {
1507                             t = toP(F.at(pos1).AnnotatedType(annos, t));
1508                         }
1509                         return t;
1510                     }
1511                     mode = oldmode;
1512                 }
1513                 if ((mode &amp; EXPR) != 0) {
1514                     selectExprMode();
1515                     JCExpression t1 = term();
1516                     t = to(F.at(pos1).Indexed(t, t1));
1517                 }
1518                 accept(RBRACKET);
1519             } else if (token.kind == DOT) {
1520                 nextToken();
1521                 typeArgs = typeArgumentsOpt(EXPR);
1522                 if (token.kind == SUPER &amp;&amp; (mode &amp; EXPR) != 0) {
1523                     selectExprMode();
1524                     t = to(F.at(pos1).Select(t, names._super));
1525                     nextToken();
1526                     t = arguments(typeArgs, t);
1527                     typeArgs = null;
1528                 } else if (token.kind == NEW &amp;&amp; (mode &amp; EXPR) != 0) {
1529                     if (typeArgs != null) return illegal();
1530                     selectExprMode();
1531                     int pos2 = token.pos;
1532                     nextToken();
1533                     if (token.kind == LT) typeArgs = typeArguments(false);
1534                     t = innerCreator(pos2, typeArgs, t);
1535                     typeArgs = null;
1536                 } else {
1537                     List&lt;JCAnnotation&gt; tyannos = null;
1538                     if ((mode &amp; TYPE) != 0 &amp;&amp; token.kind == MONKEYS_AT) {
1539                         // is the mode check needed?
1540                         tyannos = typeAnnotationsOpt();
1541                     }
1542                     t = toP(F.at(pos1).Select(t, ident(true)));
1543                     if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {
1544                         t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
1545                     }
1546                     t = argumentsOpt(typeArgs, typeArgumentsOpt(t));
1547                     typeArgs = null;
1548                 }
1549             } else if ((mode &amp; EXPR) != 0 &amp;&amp; token.kind == COLCOL) {
1550                 selectExprMode();
1551                 if (typeArgs != null) return illegal();
1552                 accept(COLCOL);
1553                 t = memberReferenceSuffix(pos1, t);
1554             } else {
1555                 if (!annos.isEmpty()) {
1556                     if (permitTypeAnnotationsPushBack)
1557                         typeAnnotationsPushedBack = annos;
1558                     else
1559                         return illegal(annos.head.pos);
1560                 }
1561                 break;
1562             }
1563         }
1564         while ((token.kind == PLUSPLUS || token.kind == SUBSUB) &amp;&amp; (mode &amp; EXPR) != 0) {
1565             selectExprMode();
1566             t = to(F.at(token.pos).Unary(
1567                   token.kind == PLUSPLUS ? POSTINC : POSTDEC, t));
1568             nextToken();
1569         }
1570         return toP(t);
1571     }
1572 
1573     /**
1574      * If we see an identifier followed by a &#39;&amp;lt;&#39; it could be an unbound
1575      * method reference or a binary expression. To disambiguate, look for a
1576      * matching &#39;&amp;gt;&#39; and see if the subsequent terminal is either &#39;.&#39; or &#39;::&#39;.
1577      */
1578     @SuppressWarnings(&quot;fallthrough&quot;)
1579     boolean isUnboundMemberRef() {
1580         int pos = 0, depth = 0;
1581         outer: for (Token t = S.token(pos) ; ; t = S.token(++pos)) {
1582             switch (t.kind) {
1583                 case IDENTIFIER: case UNDERSCORE: case QUES: case EXTENDS: case SUPER:
1584                 case DOT: case RBRACKET: case LBRACKET: case COMMA:
1585                 case BYTE: case SHORT: case INT: case LONG: case FLOAT:
1586                 case DOUBLE: case BOOLEAN: case CHAR:
1587                 case MONKEYS_AT:
1588                     break;
1589 
1590                 case LPAREN:
1591                     // skip annotation values
1592                     int nesting = 0;
1593                     for (; ; pos++) {
1594                         TokenKind tk2 = S.token(pos).kind;
1595                         switch (tk2) {
1596                             case EOF:
1597                                 return false;
1598                             case LPAREN:
1599                                 nesting++;
1600                                 break;
1601                             case RPAREN:
1602                                 nesting--;
1603                                 if (nesting == 0) {
1604                                     continue outer;
1605                                 }
1606                                 break;
1607                         }
1608                     }
1609 
1610                 case LT:
1611                     depth++; break;
1612                 case GTGTGT:
1613                     depth--;
1614                 case GTGT:
1615                     depth--;
1616                 case GT:
1617                     depth--;
1618                     if (depth == 0) {
1619                         TokenKind nextKind = S.token(pos + 1).kind;
1620                         return
1621                             nextKind == TokenKind.DOT ||
1622                             nextKind == TokenKind.LBRACKET ||
1623                             nextKind == TokenKind.COLCOL;
1624                     }
1625                     break;
1626                 default:
1627                     return false;
1628             }
1629         }
1630     }
1631 
1632     /**
1633      * If we see an identifier followed by a &#39;&amp;lt;&#39; it could be an unbound
1634      * method reference or a binary expression. To disambiguate, look for a
1635      * matching &#39;&amp;gt;&#39; and see if the subsequent terminal is either &#39;.&#39; or &#39;::&#39;.
1636      */
1637     @SuppressWarnings(&quot;fallthrough&quot;)
1638     ParensResult analyzeParens() {
1639         int depth = 0;
1640         boolean type = false;
1641         ParensResult defaultResult = ParensResult.PARENS;
1642         outer: for (int lookahead = 0; ; lookahead++) {
1643             TokenKind tk = S.token(lookahead).kind;
1644             switch (tk) {
1645                 case COMMA:
1646                     type = true;
1647                 case EXTENDS: case SUPER: case DOT: case AMP:
1648                     //skip
1649                     break;
1650                 case QUES:
1651                     if (peekToken(lookahead, EXTENDS) ||
1652                             peekToken(lookahead, SUPER)) {
1653                         //wildcards
1654                         type = true;
1655                     }
1656                     break;
1657                 case BYTE: case SHORT: case INT: case LONG: case FLOAT:
1658                 case DOUBLE: case BOOLEAN: case CHAR: case VOID:
1659                     if (peekToken(lookahead, RPAREN)) {
1660                         //Type, &#39;)&#39; -&gt; cast
1661                         return ParensResult.CAST;
1662                     } else if (peekToken(lookahead, LAX_IDENTIFIER)) {
1663                         //Type, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39; -&gt; explicit lambda
1664                         return ParensResult.EXPLICIT_LAMBDA;
1665                     }
1666                     break;
1667                 case LPAREN:
1668                     if (lookahead != 0) {
1669                         // &#39;(&#39; in a non-starting position -&gt; parens
1670                         return ParensResult.PARENS;
1671                     } else if (peekToken(lookahead, RPAREN)) {
1672                         // &#39;(&#39;, &#39;)&#39; -&gt; explicit lambda
1673                         return ParensResult.EXPLICIT_LAMBDA;
1674                     }
1675                     break;
1676                 case RPAREN:
1677                     // if we have seen something that looks like a type,
1678                     // then it&#39;s a cast expression
1679                     if (type) return ParensResult.CAST;
1680                     // otherwise, disambiguate cast vs. parenthesized expression
1681                     // based on subsequent token.
1682                     switch (S.token(lookahead + 1).kind) {
1683                         /*case PLUSPLUS: case SUBSUB: */
1684                         case BANG: case TILDE:
1685                         case LPAREN: case THIS: case SUPER:
1686                         case INTLITERAL: case LONGLITERAL: case FLOATLITERAL:
1687                         case DOUBLELITERAL: case CHARLITERAL: case STRINGLITERAL:
1688                         case TRUE: case FALSE: case NULL:
1689                         case NEW: case IDENTIFIER: case ASSERT: case ENUM: case UNDERSCORE:
1690                         case SWITCH:
1691                         case BYTE: case SHORT: case CHAR: case INT:
1692                         case LONG: case FLOAT: case DOUBLE: case BOOLEAN: case VOID:
1693                             return ParensResult.CAST;
1694                         default:
1695                             return defaultResult;
1696                     }
1697                 case UNDERSCORE:
1698                 case ASSERT:
1699                 case ENUM:
1700                 case IDENTIFIER:
1701                     if (peekToken(lookahead, LAX_IDENTIFIER)) {
1702                         // Identifier, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39; -&gt; explicit lambda
1703                         return ParensResult.EXPLICIT_LAMBDA;
1704                     } else if (peekToken(lookahead, RPAREN, ARROW)) {
1705                         // Identifier, &#39;)&#39; &#39;-&gt;&#39; -&gt; implicit lambda
1706                         return (mode &amp; NOLAMBDA) == 0 ? ParensResult.IMPLICIT_LAMBDA
1707                                                       : ParensResult.PARENS;
1708                     } else if (depth == 0 &amp;&amp; peekToken(lookahead, COMMA)) {
1709                         defaultResult = ParensResult.IMPLICIT_LAMBDA;
1710                     }
1711                     type = false;
1712                     break;
1713                 case FINAL:
1714                 case ELLIPSIS:
1715                     //those can only appear in explicit lambdas
1716                     return ParensResult.EXPLICIT_LAMBDA;
1717                 case MONKEYS_AT:
1718                     type = true;
1719                     lookahead += 1; //skip &#39;@&#39;
1720                     while (peekToken(lookahead, DOT)) {
1721                         lookahead += 2;
1722                     }
1723                     if (peekToken(lookahead, LPAREN)) {
1724                         lookahead++;
1725                         //skip annotation values
1726                         int nesting = 0;
1727                         for (; ; lookahead++) {
1728                             TokenKind tk2 = S.token(lookahead).kind;
1729                             switch (tk2) {
1730                                 case EOF:
1731                                     return ParensResult.PARENS;
1732                                 case LPAREN:
1733                                     nesting++;
1734                                     break;
1735                                 case RPAREN:
1736                                     nesting--;
1737                                     if (nesting == 0) {
1738                                         continue outer;
1739                                     }
1740                                 break;
1741                             }
1742                         }
1743                     }
1744                     break;
1745                 case LBRACKET:
1746                     if (peekToken(lookahead, RBRACKET, LAX_IDENTIFIER)) {
1747                         // &#39;[&#39;, &#39;]&#39;, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39; -&gt; explicit lambda
1748                         return ParensResult.EXPLICIT_LAMBDA;
1749                     } else if (peekToken(lookahead, RBRACKET, RPAREN) ||
1750                             peekToken(lookahead, RBRACKET, AMP)) {
1751                         // &#39;[&#39;, &#39;]&#39;, &#39;)&#39; -&gt; cast
1752                         // &#39;[&#39;, &#39;]&#39;, &#39;&amp;&#39; -&gt; cast (intersection type)
1753                         return ParensResult.CAST;
1754                     } else if (peekToken(lookahead, RBRACKET)) {
1755                         //consume the &#39;]&#39; and skip
1756                         type = true;
1757                         lookahead++;
1758                         break;
1759                     } else {
1760                         return ParensResult.PARENS;
1761                     }
1762                 case LT:
1763                     depth++; break;
1764                 case GTGTGT:
1765                     depth--;
1766                 case GTGT:
1767                     depth--;
1768                 case GT:
1769                     depth--;
1770                     if (depth == 0) {
1771                         if (peekToken(lookahead, RPAREN) ||
1772                                 peekToken(lookahead, AMP)) {
1773                             // &#39;&gt;&#39;, &#39;)&#39; -&gt; cast
1774                             // &#39;&gt;&#39;, &#39;&amp;&#39; -&gt; cast
1775                             return ParensResult.CAST;
1776                         } else if (peekToken(lookahead, LAX_IDENTIFIER, COMMA) ||
1777                                 peekToken(lookahead, LAX_IDENTIFIER, RPAREN, ARROW) ||
1778                                 peekToken(lookahead, ELLIPSIS)) {
1779                             // &#39;&gt;&#39;, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39;, &#39;,&#39; -&gt; explicit lambda
1780                             // &#39;&gt;&#39;, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39;, &#39;)&#39;, &#39;-&gt;&#39; -&gt; explicit lambda
1781                             // &#39;&gt;&#39;, &#39;...&#39; -&gt; explicit lambda
1782                             return ParensResult.EXPLICIT_LAMBDA;
1783                         }
1784                         //it looks a type, but could still be (i) a cast to generic type,
1785                         //(ii) an unbound method reference or (iii) an explicit lambda
1786                         type = true;
1787                         break;
1788                     } else if (depth &lt; 0) {
1789                         //unbalanced &#39;&lt;&#39;, &#39;&gt;&#39; - not a generic type
1790                         return ParensResult.PARENS;
1791                     }
1792                     break;
1793                 default:
1794                     //this includes EOF
1795                     return defaultResult;
1796             }
1797         }
1798     }
1799 
1800     /** Accepts all identifier-like tokens */
1801     protected Filter&lt;TokenKind&gt; LAX_IDENTIFIER = t -&gt; t == IDENTIFIER || t == UNDERSCORE || t == ASSERT || t == ENUM;
1802 
1803     enum ParensResult {
1804         CAST,
1805         EXPLICIT_LAMBDA,
1806         IMPLICIT_LAMBDA,
1807         PARENS
1808     }
1809 
1810     JCExpression lambdaExpressionOrStatement(boolean hasParens, boolean explicitParams, int pos) {
1811         List&lt;JCVariableDecl&gt; params = explicitParams ?
1812                 formalParameters(FormalParameterKind.LAMBDA) :
1813                 implicitParameters(hasParens);
1814         if (explicitParams) {
1815             LambdaClassifier lambdaClassifier = new LambdaClassifier();
1816             for (JCVariableDecl param: params) {
1817                 Name restrictedTypeName;
1818                 if (param.vartype != null &amp;&amp;
1819                         (restrictedTypeName = restrictedTypeName(param.vartype, false)) != null &amp;&amp;
1820                         param.vartype.hasTag(TYPEARRAY)) {
1821                     log.error(DiagnosticFlag.SYNTAX, param.pos,
1822                         Feature.VAR_SYNTAX_IMPLICIT_LAMBDAS.allowedInSource(source)
1823                             ? Errors.RestrictedTypeNotAllowedArray(restrictedTypeName) : Errors.RestrictedTypeNotAllowedHere(restrictedTypeName));
1824                 }
1825                 lambdaClassifier.addParameter(param);
1826                 if (lambdaClassifier.result() == LambdaParameterKind.ERROR) {
1827                     break;
1828                 }
1829             }
1830             if (lambdaClassifier.diagFragment != null) {
1831                 log.error(DiagnosticFlag.SYNTAX, pos, Errors.InvalidLambdaParameterDeclaration(lambdaClassifier.diagFragment));
1832             }
1833             for (JCVariableDecl param: params) {
1834                 if (param.vartype != null
1835                         &amp;&amp; restrictedTypeName(param.vartype, true) != null) {
1836                     checkSourceLevel(param.pos, Feature.VAR_SYNTAX_IMPLICIT_LAMBDAS);
1837                     param.startPos = TreeInfo.getStartPos(param.vartype);
1838                     param.vartype = null;
1839                 }
1840             }
1841         }
1842         return lambdaExpressionOrStatementRest(params, pos);
1843     }
1844 
1845     enum LambdaParameterKind {
1846         VAR(0),
1847         EXPLICIT(1),
1848         IMPLICIT(2),
1849         ERROR(-1);
1850 
1851         private final int index;
1852 
1853         LambdaParameterKind(int index) {
1854             this.index = index;
1855         }
1856     }
1857 
1858     private final static Fragment[][] decisionTable = new Fragment[][] {
1859         /*              VAR                              EXPLICIT                         IMPLICIT  */
1860         /* VAR      */ {null,                            VarAndExplicitNotAllowed,        VarAndImplicitNotAllowed},
1861         /* EXPLICIT */ {VarAndExplicitNotAllowed,        null,                            ImplicitAndExplicitNotAllowed},
1862         /* IMPLICIT */ {VarAndImplicitNotAllowed,        ImplicitAndExplicitNotAllowed,   null},
1863     };
1864 
1865     class LambdaClassifier {
1866 
1867         LambdaParameterKind kind;
1868         Fragment diagFragment;
1869         List&lt;JCVariableDecl&gt; params;
1870 
1871         void addParameter(JCVariableDecl param) {
1872             if (param.vartype != null &amp;&amp; param.name != names.empty) {
1873                 if (restrictedTypeName(param.vartype, false) != null) {
1874                     reduce(LambdaParameterKind.VAR);
1875                 } else {
1876                     reduce(LambdaParameterKind.EXPLICIT);
1877                 }
1878             }
1879             if (param.vartype == null &amp;&amp; param.name != names.empty ||
1880                 param.vartype != null &amp;&amp; param.name == names.empty) {
1881                 reduce(LambdaParameterKind.IMPLICIT);
1882             }
1883         }
1884 
1885         private void reduce(LambdaParameterKind newKind) {
1886             if (kind == null) {
1887                 kind = newKind;
1888             } else if (kind != newKind &amp;&amp; kind != LambdaParameterKind.ERROR) {
1889                 LambdaParameterKind currentKind = kind;
1890                 kind = LambdaParameterKind.ERROR;
1891                 boolean varIndex = currentKind.index == LambdaParameterKind.VAR.index ||
1892                         newKind.index == LambdaParameterKind.VAR.index;
1893                 diagFragment = Feature.VAR_SYNTAX_IMPLICIT_LAMBDAS.allowedInSource(source) || !varIndex ?
1894                         decisionTable[currentKind.index][newKind.index] : null;
1895             }
1896         }
1897 
1898         LambdaParameterKind result() {
1899             return kind;
1900         }
1901     }
1902 
1903     JCExpression lambdaExpressionOrStatementRest(List&lt;JCVariableDecl&gt; args, int pos) {
1904         checkSourceLevel(Feature.LAMBDA);
1905         accept(ARROW);
1906 
1907         return token.kind == LBRACE ?
1908             lambdaStatement(args, pos, token.pos) :
1909             lambdaExpression(args, pos);
1910     }
1911 
1912     JCExpression lambdaStatement(List&lt;JCVariableDecl&gt; args, int pos, int pos2) {
1913         JCBlock block = block(pos2, 0);
1914         return toP(F.at(pos).Lambda(args, block));
1915     }
1916 
1917     JCExpression lambdaExpression(List&lt;JCVariableDecl&gt; args, int pos) {
1918         JCTree expr = parseExpression();
1919         return toP(F.at(pos).Lambda(args, expr));
1920     }
1921 
1922     /** SuperSuffix = Arguments | &quot;.&quot; [TypeArguments] Ident [Arguments]
1923      */
1924     JCExpression superSuffix(List&lt;JCExpression&gt; typeArgs, JCExpression t) {
1925         nextToken();
1926         if (token.kind == LPAREN || typeArgs != null) {
1927             t = arguments(typeArgs, t);
1928         } else if (token.kind == COLCOL) {
1929             if (typeArgs != null) return illegal();
1930             t = memberReferenceSuffix(t);
1931         } else {
1932             int pos = token.pos;
1933             accept(DOT);
1934             typeArgs = (token.kind == LT) ? typeArguments(false) : null;
1935             t = toP(F.at(pos).Select(t, ident()));
1936             t = argumentsOpt(typeArgs, t);
1937         }
1938         return t;
1939     }
1940 
1941     /** BasicType = BYTE | SHORT | CHAR | INT | LONG | FLOAT | DOUBLE | BOOLEAN
1942      */
1943     JCPrimitiveTypeTree basicType() {
1944         JCPrimitiveTypeTree t = to(F.at(token.pos).TypeIdent(typetag(token.kind)));
1945         nextToken();
1946         return t;
1947     }
1948 
1949     /** ArgumentsOpt = [ Arguments ]
1950      */
1951     JCExpression argumentsOpt(List&lt;JCExpression&gt; typeArgs, JCExpression t) {
1952         if ((mode &amp; EXPR) != 0 &amp;&amp; token.kind == LPAREN || typeArgs != null) {
1953             selectExprMode();
1954             return arguments(typeArgs, t);
1955         } else {
1956             return t;
1957         }
1958     }
1959 
1960     /** Arguments = &quot;(&quot; [Expression { COMMA Expression }] &quot;)&quot;
1961      */
1962     List&lt;JCExpression&gt; arguments() {
1963         ListBuffer&lt;JCExpression&gt; args = new ListBuffer&lt;&gt;();
1964         if (token.kind == LPAREN) {
1965             nextToken();
1966             if (token.kind != RPAREN) {
1967                 args.append(parseExpression());
1968                 while (token.kind == COMMA) {
1969                     nextToken();
1970                     args.append(parseExpression());
1971                 }
1972             }
1973             accept(RPAREN);
1974         } else {
1975             syntaxError(token.pos, Errors.Expected(LPAREN));
1976         }
1977         return args.toList();
1978     }
1979 
1980     JCExpression arguments(List&lt;JCExpression&gt; typeArgs, JCExpression t) {
1981         int pos = token.pos;
1982         List&lt;JCExpression&gt; args = arguments();
1983         JCExpression mi = F.at(pos).Apply(typeArgs, t, args);
1984         if (t.hasTag(IDENT) &amp;&amp; isInvalidUnqualifiedMethodIdentifier(((JCIdent) t).pos,
1985                                                                     ((JCIdent) t).name)) {
1986             log.error(DiagnosticFlag.SYNTAX, t, Errors.InvalidYield);
1987             mi = F.Erroneous(List.of(mi));
1988         }
1989         return toP(mi);
1990     }
1991 
1992     boolean isInvalidUnqualifiedMethodIdentifier(int pos, Name name) {
1993         if (name == names.yield) {
1994             if (allowYieldStatement) {
1995                 return true;
1996             } else {
1997                 log.warning(pos, Warnings.InvalidYield);
1998             }
1999         }
2000         return false;
2001     }
2002 
2003     /**  TypeArgumentsOpt = [ TypeArguments ]
2004      */
2005     JCExpression typeArgumentsOpt(JCExpression t) {
2006         if (token.kind == LT &amp;&amp;
2007             (mode &amp; TYPE) != 0 &amp;&amp;
2008             (mode &amp; NOPARAMS) == 0) {
2009             selectTypeMode();
2010             return typeArguments(t, false);
2011         } else {
2012             return t;
2013         }
2014     }
2015     List&lt;JCExpression&gt; typeArgumentsOpt() {
2016         return typeArgumentsOpt(TYPE);
2017     }
2018 
2019     List&lt;JCExpression&gt; typeArgumentsOpt(int useMode) {
2020         if (token.kind == LT) {
2021             if ((mode &amp; useMode) == 0 ||
2022                 (mode &amp; NOPARAMS) != 0) {
2023                 illegal();
2024             }
2025             mode = useMode;
2026             return typeArguments(false);
2027         }
2028         return null;
2029     }
2030 
2031     /**
2032      *  {@literal
2033      *  TypeArguments  = &quot;&lt;&quot; TypeArgument {&quot;,&quot; TypeArgument} &quot;&gt;&quot;
2034      *  }
2035      */
2036     List&lt;JCExpression&gt; typeArguments(boolean diamondAllowed) {
2037         if (token.kind == LT) {
2038             nextToken();
2039             if (token.kind == GT &amp;&amp; diamondAllowed) {
2040                 checkSourceLevel(Feature.DIAMOND);
2041                 mode |= DIAMOND;
2042                 nextToken();
2043                 return List.nil();
2044             } else {
2045                 ListBuffer&lt;JCExpression&gt; args = new ListBuffer&lt;&gt;();
2046                 args.append(((mode &amp; EXPR) == 0) ? typeArgument() : parseType());
2047                 while (token.kind == COMMA) {
2048                     nextToken();
2049                     args.append(((mode &amp; EXPR) == 0) ? typeArgument() : parseType());
2050                 }
2051                 switch (token.kind) {
2052 
2053                 case GTGTGTEQ: case GTGTEQ: case GTEQ:
2054                 case GTGTGT: case GTGT:
2055                     token = S.split();
2056                     break;
2057                 case GT:
2058                     nextToken();
2059                     break;
2060                 default:
2061                     args.append(syntaxError(token.pos, Errors.Expected(GT)));
2062                     break;
2063                 }
2064                 return args.toList();
2065             }
2066         } else {
2067             return List.of(syntaxError(token.pos, Errors.Expected(LT)));
2068         }
2069     }
2070 
2071     /**
2072      *  {@literal
2073      *  TypeArgument = Type
2074      *               | [Annotations] &quot;?&quot;
2075      *               | [Annotations] &quot;?&quot; EXTENDS Type {&quot;&amp;&quot; Type}
2076      *               | [Annotations] &quot;?&quot; SUPER Type
2077      *  }
2078      */
2079     JCExpression typeArgument() {
2080         List&lt;JCAnnotation&gt; annotations = typeAnnotationsOpt();
2081         if (token.kind != QUES) return parseType(false, annotations);
2082         int pos = token.pos;
2083         nextToken();
2084         JCExpression result;
2085         if (token.kind == EXTENDS) {
2086             TypeBoundKind t = to(F.at(pos).TypeBoundKind(BoundKind.EXTENDS));
2087             nextToken();
2088             JCExpression bound = parseType();
2089             result = F.at(pos).Wildcard(t, bound);
2090         } else if (token.kind == SUPER) {
2091             TypeBoundKind t = to(F.at(pos).TypeBoundKind(BoundKind.SUPER));
2092             nextToken();
2093             JCExpression bound = parseType();
2094             result = F.at(pos).Wildcard(t, bound);
2095         } else if (LAX_IDENTIFIER.accepts(token.kind)) {
2096             //error recovery
2097             TypeBoundKind t = F.at(Position.NOPOS).TypeBoundKind(BoundKind.UNBOUND);
2098             JCExpression wc = toP(F.at(pos).Wildcard(t, null));
2099             JCIdent id = toP(F.at(token.pos).Ident(ident()));
2100             JCErroneous err = F.at(pos).Erroneous(List.&lt;JCTree&gt;of(wc, id));
2101             reportSyntaxError(err, Errors.Expected3(GT, EXTENDS, SUPER));
2102             result = err;
2103         } else {
2104             TypeBoundKind t = toP(F.at(pos).TypeBoundKind(BoundKind.UNBOUND));
2105             result = toP(F.at(pos).Wildcard(t, null));
2106         }
2107         if (!annotations.isEmpty()) {
2108             result = toP(F.at(annotations.head.pos).AnnotatedType(annotations,result));
2109         }
2110         return result;
2111     }
2112 
2113     JCTypeApply typeArguments(JCExpression t, boolean diamondAllowed) {
2114         int pos = token.pos;
2115         List&lt;JCExpression&gt; args = typeArguments(diamondAllowed);
2116         return toP(F.at(pos).TypeApply(t, args));
2117     }
2118 
2119     /**
2120      * BracketsOpt = { [Annotations] &quot;[&quot; &quot;]&quot; }*
2121      *
2122      * &lt;p&gt;
2123      *
2124      * &lt;code&gt;annotations&lt;/code&gt; is the list of annotations targeting
2125      * the expression &lt;code&gt;t&lt;/code&gt;.
2126      */
2127     private JCExpression bracketsOpt(JCExpression t,
2128             List&lt;JCAnnotation&gt; annotations) {
2129         List&lt;JCAnnotation&gt; nextLevelAnnotations = typeAnnotationsOpt();
2130 
2131         if (token.kind == LBRACKET) {
2132             int pos = token.pos;
2133             nextToken();
2134             t = bracketsOptCont(t, pos, nextLevelAnnotations);
2135         } else if (!nextLevelAnnotations.isEmpty()) {
2136             if (permitTypeAnnotationsPushBack) {
2137                 this.typeAnnotationsPushedBack = nextLevelAnnotations;
2138             } else {
2139                 return illegal(nextLevelAnnotations.head.pos);
2140             }
2141         }
2142 
2143         if (!annotations.isEmpty()) {
2144             t = toP(F.at(token.pos).AnnotatedType(annotations, t));
2145         }
2146         return t;
2147     }
2148 
2149     /** BracketsOpt = [ &quot;[&quot; &quot;]&quot; { [Annotations] &quot;[&quot; &quot;]&quot;} ]
2150      */
2151     private JCExpression bracketsOpt(JCExpression t) {
2152         return bracketsOpt(t, List.nil());
2153     }
2154 
2155     private JCExpression bracketsOptCont(JCExpression t, int pos,
2156             List&lt;JCAnnotation&gt; annotations) {
2157         accept(RBRACKET);
2158         t = bracketsOpt(t);
2159         t = toP(F.at(pos).TypeArray(t));
2160         if (annotations.nonEmpty()) {
2161             t = toP(F.at(pos).AnnotatedType(annotations, t));
2162         }
2163         return t;
2164     }
2165 
2166     /** BracketsSuffixExpr = &quot;.&quot; CLASS
2167      *  BracketsSuffixType =
2168      */
2169     JCExpression bracketsSuffix(JCExpression t) {
2170         if ((mode &amp; EXPR) != 0 &amp;&amp; token.kind == DOT) {
2171             selectExprMode();
2172             int pos = token.pos;
2173             nextToken();
2174             accept(CLASS);
2175             if (token.pos == endPosTable.errorEndPos) {
2176                 // error recovery
2177                 Name name;
2178                 if (LAX_IDENTIFIER.accepts(token.kind)) {
2179                     name = token.name();
2180                     nextToken();
2181                 } else {
2182                     name = names.error;
2183                 }
2184                 t = F.at(pos).Erroneous(List.&lt;JCTree&gt;of(toP(F.at(pos).Select(t, name))));
2185             } else {
2186                 Tag tag = t.getTag();
2187                 // Type annotations are illegal on class literals. Annotated non array class literals
2188                 // are complained about directly in term3(), Here check for type annotations on dimensions
2189                 // taking care to handle some interior dimension(s) being annotated.
2190                 if ((tag == TYPEARRAY &amp;&amp; TreeInfo.containsTypeAnnotation(t)) || tag == ANNOTATED_TYPE)
2191                     syntaxError(token.pos, Errors.NoAnnotationsOnDotClass);
2192                 t = toP(F.at(pos).Select(t, names._class));
2193             }
2194         } else if ((mode &amp; TYPE) != 0) {
2195             if (token.kind != COLCOL) {
2196                 selectTypeMode();
2197             }
2198         } else if (token.kind != COLCOL) {
2199             syntaxError(token.pos, Errors.DotClassExpected);
2200         }
2201         return t;
2202     }
2203 
2204     /**
2205      * MemberReferenceSuffix = &quot;::&quot; [TypeArguments] Ident
2206      *                       | &quot;::&quot; [TypeArguments] &quot;new&quot;
2207      */
2208     JCExpression memberReferenceSuffix(JCExpression t) {
2209         int pos1 = token.pos;
2210         accept(COLCOL);
2211         return memberReferenceSuffix(pos1, t);
2212     }
2213 
2214     JCExpression memberReferenceSuffix(int pos1, JCExpression t) {
2215         checkSourceLevel(Feature.METHOD_REFERENCES);
2216         selectExprMode();
2217         List&lt;JCExpression&gt; typeArgs = null;
2218         if (token.kind == LT) {
2219             typeArgs = typeArguments(false);
2220         }
2221         Name refName;
2222         ReferenceMode refMode;
2223         if (token.kind == NEW) {
2224             refMode = ReferenceMode.NEW;
2225             refName = names.init;
2226             nextToken();
2227         } else {
2228             refMode = ReferenceMode.INVOKE;
2229             refName = ident();
2230         }
2231         return toP(F.at(t.getStartPosition()).Reference(refMode, refName, t, typeArgs));
2232     }
2233 
2234     /** Creator = [Annotations] Qualident [TypeArguments] ( ArrayCreatorRest | ClassCreatorRest )
2235      */
2236     JCExpression creator(int newpos, List&lt;JCExpression&gt; typeArgs) {
2237         List&lt;JCAnnotation&gt; newAnnotations = typeAnnotationsOpt();
2238 
2239         switch (token.kind) {
2240         case BYTE: case SHORT: case CHAR: case INT: case LONG: case FLOAT:
2241         case DOUBLE: case BOOLEAN:
2242             if (typeArgs == null) {
2243                 if (newAnnotations.isEmpty()) {
2244                     return arrayCreatorRest(newpos, basicType());
2245                 } else {
2246                     return arrayCreatorRest(newpos, toP(F.at(newAnnotations.head.pos).AnnotatedType(newAnnotations, basicType())));
2247                 }
2248             }
2249             break;
2250         default:
2251         }
2252         JCExpression t = qualident(true);
2253 
2254         int oldmode = mode;
2255         selectTypeMode();
2256         boolean diamondFound = false;
2257         int lastTypeargsPos = -1;
2258         if (token.kind == LT) {
2259             lastTypeargsPos = token.pos;
2260             t = typeArguments(t, true);
2261             diamondFound = (mode &amp; DIAMOND) != 0;
2262         }
2263         while (token.kind == DOT) {
2264             if (diamondFound) {
2265                 //cannot select after a diamond
2266                 illegal();
2267             }
2268             int pos = token.pos;
2269             nextToken();
2270             List&lt;JCAnnotation&gt; tyannos = typeAnnotationsOpt();
2271             t = toP(F.at(pos).Select(t, ident()));
2272 
2273             if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {
2274                 t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
2275             }
2276 
2277             if (token.kind == LT) {
2278                 lastTypeargsPos = token.pos;
2279                 t = typeArguments(t, true);
2280                 diamondFound = (mode &amp; DIAMOND) != 0;
2281             }
2282         }
2283         mode = oldmode;
2284         if (token.kind == LBRACKET || token.kind == MONKEYS_AT) {
2285             // handle type annotations for non primitive arrays
2286             if (newAnnotations.nonEmpty()) {
2287                 t = insertAnnotationsToMostInner(t, newAnnotations, false);
2288             }
2289 
2290             JCExpression e = arrayCreatorRest(newpos, t);
2291             if (diamondFound) {
2292                 reportSyntaxError(lastTypeargsPos, Errors.CannotCreateArrayWithDiamond);
2293                 return toP(F.at(newpos).Erroneous(List.of(e)));
2294             }
2295             else if (typeArgs != null) {
2296                 int pos = newpos;
2297                 if (!typeArgs.isEmpty() &amp;&amp; typeArgs.head.pos != Position.NOPOS) {
2298                     // note: this should always happen but we should
2299                     // not rely on this as the parser is continuously
2300                     // modified to improve error recovery.
2301                     pos = typeArgs.head.pos;
2302                 }
2303                 setErrorEndPos(S.prevToken().endPos);
2304                 JCErroneous err = F.at(pos).Erroneous(typeArgs.prepend(e));
2305                 reportSyntaxError(err, Errors.CannotCreateArrayWithTypeArguments);
2306                 return toP(err);
2307             }
2308             return e;
2309         } else if (token.kind == LPAREN) {
2310             // handle type annotations for instantiations and anonymous classes
2311             if (newAnnotations.nonEmpty()) {
2312                 t = insertAnnotationsToMostInner(t, newAnnotations, false);
2313             }
2314             return classCreatorRest(newpos, null, typeArgs, t);
2315         } else {
2316             setErrorEndPos(token.pos);
2317             reportSyntaxError(token.pos, Errors.Expected2(LPAREN, LBRACKET));
2318             t = toP(F.at(newpos).NewClass(null, typeArgs, t, List.nil(), null));
2319             return toP(F.at(newpos).Erroneous(List.&lt;JCTree&gt;of(t)));
2320         }
2321     }
2322 
2323     /** InnerCreator = [Annotations] Ident [TypeArguments] ClassCreatorRest
2324      */
2325     JCExpression innerCreator(int newpos, List&lt;JCExpression&gt; typeArgs, JCExpression encl) {
2326         List&lt;JCAnnotation&gt; newAnnotations = typeAnnotationsOpt();
2327 
2328         JCExpression t = toP(F.at(token.pos).Ident(ident()));
2329 
2330         if (newAnnotations.nonEmpty()) {
2331             t = toP(F.at(newAnnotations.head.pos).AnnotatedType(newAnnotations, t));
2332         }
2333 
2334         if (token.kind == LT) {
2335             int oldmode = mode;
2336             t = typeArguments(t, true);
2337             mode = oldmode;
2338         }
2339         return classCreatorRest(newpos, encl, typeArgs, t);
2340     }
2341 
2342     /** ArrayCreatorRest = [Annotations] &quot;[&quot; ( &quot;]&quot; BracketsOpt ArrayInitializer
2343      *                         | Expression &quot;]&quot; {[Annotations]  &quot;[&quot; Expression &quot;]&quot;} BracketsOpt )
2344      */
2345     JCExpression arrayCreatorRest(int newpos, JCExpression elemtype) {
2346         List&lt;JCAnnotation&gt; annos = typeAnnotationsOpt();
2347 
2348         accept(LBRACKET);
2349         if (token.kind == RBRACKET) {
2350             accept(RBRACKET);
2351             elemtype = bracketsOpt(elemtype, annos);
2352             if (token.kind == LBRACE) {
2353                 JCNewArray na = (JCNewArray)arrayInitializer(newpos, elemtype);
2354                 if (annos.nonEmpty()) {
2355                     // when an array initializer is present then
2356                     // the parsed annotations should target the
2357                     // new array tree
2358                     // bracketsOpt inserts the annotation in
2359                     // elemtype, and it needs to be corrected
2360                     //
2361                     JCAnnotatedType annotated = (JCAnnotatedType)elemtype;
2362                     assert annotated.annotations == annos;
2363                     na.annotations = annotated.annotations;
2364                     na.elemtype = annotated.underlyingType;
2365                 }
2366                 return na;
2367             } else {
2368                 JCExpression t = toP(F.at(newpos).NewArray(elemtype, List.nil(), null));
2369                 return syntaxError(token.pos, List.of(t), Errors.ArrayDimensionMissing);
2370             }
2371         } else {
2372             ListBuffer&lt;JCExpression&gt; dims = new ListBuffer&lt;&gt;();
2373 
2374             // maintain array dimension type annotations
2375             ListBuffer&lt;List&lt;JCAnnotation&gt;&gt; dimAnnotations = new ListBuffer&lt;&gt;();
2376             dimAnnotations.append(annos);
2377 
2378             dims.append(parseExpression());
2379             accept(RBRACKET);
2380             while (token.kind == LBRACKET
2381                     || token.kind == MONKEYS_AT) {
2382                 List&lt;JCAnnotation&gt; maybeDimAnnos = typeAnnotationsOpt();
2383                 int pos = token.pos;
2384                 nextToken();
2385                 if (token.kind == RBRACKET) {
2386                     elemtype = bracketsOptCont(elemtype, pos, maybeDimAnnos);
2387                 } else {
2388                     if (token.kind == RBRACKET) { // no dimension
2389                         elemtype = bracketsOptCont(elemtype, pos, maybeDimAnnos);
2390                     } else {
2391                         dimAnnotations.append(maybeDimAnnos);
2392                         dims.append(parseExpression());
2393                         accept(RBRACKET);
2394                     }
2395                 }
2396             }
2397 
2398             List&lt;JCExpression&gt; elems = null;
2399             int errpos = token.pos;
2400 
2401             if (token.kind == LBRACE) {
2402                 elems = arrayInitializerElements(newpos, elemtype);
2403             }
2404 
2405             JCNewArray na = toP(F.at(newpos).NewArray(elemtype, dims.toList(), elems));
2406             na.dimAnnotations = dimAnnotations.toList();
2407 
2408             if (elems != null) {
2409                 return syntaxError(errpos, List.of(na), Errors.IllegalArrayCreationBothDimensionAndInitialization);
2410             }
2411 
2412             return na;
2413         }
2414     }
2415 
2416     /** ClassCreatorRest = Arguments [ClassBody]
2417      */
2418     JCNewClass classCreatorRest(int newpos,
2419                                   JCExpression encl,
2420                                   List&lt;JCExpression&gt; typeArgs,
2421                                   JCExpression t)
2422     {
2423         List&lt;JCExpression&gt; args = arguments();
2424         JCClassDecl body = null;
2425         if (token.kind == LBRACE) {
2426             int pos = token.pos;
2427             List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(names.empty, false, false);
2428             JCModifiers mods = F.at(Position.NOPOS).Modifiers(0);
2429             body = toP(F.at(pos).AnonymousClassDef(mods, defs));
2430         }
2431         return toP(F.at(newpos).NewClass(encl, typeArgs, t, args, body));
2432     }
2433 
2434     /** ArrayInitializer = &quot;{&quot; [VariableInitializer {&quot;,&quot; VariableInitializer}] [&quot;,&quot;] &quot;}&quot;
2435      */
2436     JCExpression arrayInitializer(int newpos, JCExpression t) {
2437         List&lt;JCExpression&gt; elems = arrayInitializerElements(newpos, t);
2438         return toP(F.at(newpos).NewArray(t, List.nil(), elems));
2439     }
2440 
2441     List&lt;JCExpression&gt; arrayInitializerElements(int newpos, JCExpression t) {
2442         accept(LBRACE);
2443         ListBuffer&lt;JCExpression&gt; elems = new ListBuffer&lt;&gt;();
2444         if (token.kind == COMMA) {
2445             nextToken();
2446         } else if (token.kind != RBRACE) {
2447             elems.append(variableInitializer());
2448             while (token.kind == COMMA) {
2449                 nextToken();
2450                 if (token.kind == RBRACE) break;
2451                 elems.append(variableInitializer());
2452             }
2453         }
2454         accept(RBRACE);
2455         return elems.toList();
2456     }
2457 
2458     /** VariableInitializer = ArrayInitializer | Expression
2459      */
2460     public JCExpression variableInitializer() {
2461         return token.kind == LBRACE ? arrayInitializer(token.pos, null) : parseExpression();
2462     }
2463 
2464     /** ParExpression = &quot;(&quot; Expression &quot;)&quot;
2465      */
2466     JCExpression parExpression() {
2467         int pos = token.pos;
2468         accept(LPAREN);
2469         JCExpression t = parseExpression();
2470         accept(RPAREN);
2471         return toP(F.at(pos).Parens(t));
2472     }
2473 
2474     /** Block = &quot;{&quot; BlockStatements &quot;}&quot;
2475      */
2476     JCBlock block(int pos, long flags) {
2477         accept(LBRACE);
2478         List&lt;JCStatement&gt; stats = blockStatements();
2479         JCBlock t = F.at(pos).Block(flags, stats);
2480         while (token.kind == CASE || token.kind == DEFAULT) {
2481             syntaxError(token.pos, Errors.Orphaned(token.kind));
2482             switchBlockStatementGroups();
2483         }
2484         // the Block node has a field &quot;endpos&quot; for first char of last token, which is
2485         // usually but not necessarily the last char of the last token.
2486         t.endpos = token.pos;
2487         accept(RBRACE);
2488         return toP(t);
2489     }
2490 
2491     public JCBlock block() {
2492         return block(token.pos, 0);
2493     }
2494 
2495     /** BlockStatements = { BlockStatement }
2496      *  BlockStatement  = LocalVariableDeclarationStatement
2497      *                  | ClassOrInterfaceOrEnumDeclaration
2498      *                  | [Ident &quot;:&quot;] Statement
2499      *  LocalVariableDeclarationStatement
2500      *                  = { FINAL | &#39;@&#39; Annotation } Type VariableDeclarators &quot;;&quot;
2501      */
2502     @SuppressWarnings(&quot;fallthrough&quot;)
2503     List&lt;JCStatement&gt; blockStatements() {
2504         //todo: skip to anchor on error(?)
2505         int lastErrPos = -1;
2506         ListBuffer&lt;JCStatement&gt; stats = new ListBuffer&lt;&gt;();
2507         while (true) {
2508             List&lt;JCStatement&gt; stat = blockStatement();
2509             if (stat.isEmpty()) {
2510                 return stats.toList();
2511             } else {
2512                 // error recovery
2513                 if (token.pos == lastErrPos)
2514                     return stats.toList();
2515                 if (token.pos &lt;= endPosTable.errorEndPos) {
2516                     skip(false, true, true, true);
2517                     lastErrPos = token.pos;
2518                 }
2519                 stats.addAll(stat);
2520             }
2521         }
2522     }
2523 
2524     /*
2525      * Parse a Statement (JLS 14.5). As an enhancement to improve error recovery,
2526      * this method will also recognize variable and class declarations (which are
2527      * not legal for a Statement) by delegating the parsing to BlockStatement (JLS 14.2).
2528      * If any illegal declarations are found, they will be wrapped in an erroneous tree,
2529      * and an error will be produced by this method.
2530      */
2531     JCStatement parseStatementAsBlock() {
2532         int pos = token.pos;
2533         List&lt;JCStatement&gt; stats = blockStatement();
2534         if (stats.isEmpty()) {
2535             JCErroneous e = syntaxError(pos, Errors.IllegalStartOfStmt);
2536             return toP(F.at(pos).Exec(e));
2537         } else {
2538             JCStatement first = stats.head;
2539             Error error = null;
2540             switch (first.getTag()) {
2541             case CLASSDEF:
2542                 error = Errors.ClassNotAllowed;
2543                 break;
2544             case VARDEF:
2545                 error = Errors.VariableNotAllowed;
2546                 break;
2547             }
2548             if (error != null) {
2549                 log.error(DiagnosticFlag.SYNTAX, first, error);
2550                 List&lt;JCBlock&gt; blist = List.of(F.at(first.pos).Block(0, stats));
2551                 return toP(F.at(pos).Exec(F.at(first.pos).Erroneous(blist)));
2552             }
2553             return first;
2554         }
2555     }
2556 
2557     /**This method parses a statement appearing inside a block.
2558      */
2559     @SuppressWarnings(&quot;fallthrough&quot;)
2560     List&lt;JCStatement&gt; blockStatement() {
2561         //todo: skip to anchor on error(?)
2562         Comment dc;
2563         int pos = token.pos;
2564         switch (token.kind) {
2565         case RBRACE: case CASE: case DEFAULT: case EOF:
2566             return List.nil();
2567         case LBRACE: case IF: case FOR: case WHILE: case DO: case TRY:
2568         case SWITCH: case SYNCHRONIZED: case RETURN: case THROW: case BREAK:
2569         case CONTINUE: case SEMI: case ELSE: case FINALLY: case CATCH:
2570         case ASSERT:
2571             return List.of(parseSimpleStatement());
2572         case MONKEYS_AT:
2573         case FINAL: {
2574             dc = token.comment(CommentStyle.JAVADOC);
2575             JCModifiers mods = modifiersOpt();
2576             if (token.kind == INTERFACE ||
2577                 token.kind == CLASS ||
2578                 token.kind == ENUM ||
2579                 isRecordStart()) {
2580                 return List.of(classOrRecordOrInterfaceOrEnumDeclaration(mods, dc));
2581             } else {
2582                 JCExpression t = parseType(true);
2583                 return localVariableDeclarations(mods, t);
2584             }
2585         }
2586         case ABSTRACT: case STRICTFP: {
2587             dc = token.comment(CommentStyle.JAVADOC);
2588             JCModifiers mods = modifiersOpt();
2589             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(mods, dc));
2590         }
2591         case INTERFACE:
2592         case CLASS:
2593             dc = token.comment(CommentStyle.JAVADOC);
2594             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(), dc));
2595         case ENUM:
2596             if (!allowRecords) {
2597                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.LocalEnum);
2598             }
2599             dc = token.comment(CommentStyle.JAVADOC);
2600             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(), dc));
2601         case IDENTIFIER:
2602             if (token.name() == names.yield &amp;&amp; allowYieldStatement) {
2603                 Token next = S.token(1);
2604                 boolean isYieldStatement;
2605                 switch (next.kind) {
2606                     case PLUS: case SUB: case STRINGLITERAL: case CHARLITERAL:
2607                     case INTLITERAL: case LONGLITERAL: case FLOATLITERAL: case DOUBLELITERAL:
2608                     case NULL: case IDENTIFIER: case TRUE: case FALSE:
2609                     case NEW: case SWITCH: case THIS: case SUPER:
2610                         isYieldStatement = true;
2611                         break;
2612                     case PLUSPLUS: case SUBSUB:
2613                         isYieldStatement = S.token(2).kind != SEMI;
2614                         break;
2615                     case LPAREN:
2616                         int lookahead = 2;
2617                         int balance = 1;
2618                         boolean hasComma = false;
2619                         Token l;
2620                         while ((l = S.token(lookahead)).kind != EOF &amp;&amp; balance != 0) {
2621                             switch (l.kind) {
2622                                 case LPAREN: balance++; break;
2623                                 case RPAREN: balance--; break;
2624                                 case COMMA: if (balance == 1) hasComma = true; break;
2625                             }
2626                             lookahead++;
2627                         }
2628                         isYieldStatement = (!hasComma &amp;&amp; lookahead != 3) || l.kind == ARROW;
2629                         break;
2630                     case SEMI: //error recovery - this is not a valid statement:
2631                         isYieldStatement = true;
2632                         break;
2633                     default:
2634                         isYieldStatement = false;
2635                         break;
2636                 }
2637 
2638                 if (isYieldStatement) {
2639                     nextToken();
2640                     JCExpression t = term(EXPR);
2641                     accept(SEMI);
2642                     return List.of(toP(F.at(pos).Yield(t)));
2643                 }
2644 
2645                 //else intentional fall-through
2646             } else {
2647                 if (isNonSealedClassStart(true)) {
2648                     log.error(token.pos, Errors.SealedOrNonSealedLocalClassesNotAllowed);
2649                     nextToken();
2650                     nextToken();
2651                     nextToken();
2652                     return List.of(classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(), token.comment(CommentStyle.JAVADOC)));
2653                 } else if (isSealedClassStart(true)) {
2654                     checkSourceLevel(Feature.SEALED_CLASSES);
2655                     log.error(token.pos, Errors.SealedOrNonSealedLocalClassesNotAllowed);
2656                     nextToken();
2657                     return List.of(classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(), token.comment(CommentStyle.JAVADOC)));
2658                 }
2659             }
2660         }
2661         if (isRecordStart() &amp;&amp; allowRecords) {
2662             dc = token.comment(CommentStyle.JAVADOC);
2663             return List.of(recordDeclaration(F.at(pos).Modifiers(0), dc));
2664         } else {
2665             Token prevToken = token;
2666             JCExpression t = term(EXPR | TYPE);
2667             if (token.kind == COLON &amp;&amp; t.hasTag(IDENT)) {
2668                 nextToken();
2669                 JCStatement stat = parseStatementAsBlock();
2670                 return List.of(F.at(pos).Labelled(prevToken.name(), stat));
2671             } else if ((lastmode &amp; TYPE) != 0 &amp;&amp; LAX_IDENTIFIER.accepts(token.kind)) {
2672                 pos = token.pos;
2673                 JCModifiers mods = F.at(Position.NOPOS).Modifiers(0);
2674                 F.at(pos);
2675                 return localVariableDeclarations(mods, t);
2676             } else {
2677                 // This Exec is an &quot;ExpressionStatement&quot;; it subsumes the terminating semicolon
2678                 t = checkExprStat(t);
2679                 accept(SEMI);
2680                 JCExpressionStatement expr = toP(F.at(pos).Exec(t));
2681                 return List.of(expr);
2682             }
2683         }
2684     }
2685     //where
2686         private List&lt;JCStatement&gt; localVariableDeclarations(JCModifiers mods, JCExpression type) {
2687             ListBuffer&lt;JCStatement&gt; stats =
2688                     variableDeclarators(mods, type, new ListBuffer&lt;&gt;(), true);
2689             // A &quot;LocalVariableDeclarationStatement&quot; subsumes the terminating semicolon
2690             accept(SEMI);
2691             storeEnd(stats.last(), S.prevToken().endPos);
2692             return stats.toList();
2693         }
2694 
2695     /** Statement =
2696      *       Block
2697      *     | IF ParExpression Statement [ELSE Statement]
2698      *     | FOR &quot;(&quot; ForInitOpt &quot;;&quot; [Expression] &quot;;&quot; ForUpdateOpt &quot;)&quot; Statement
2699      *     | FOR &quot;(&quot; FormalParameter : Expression &quot;)&quot; Statement
2700      *     | WHILE ParExpression Statement
2701      *     | DO Statement WHILE ParExpression &quot;;&quot;
2702      *     | TRY Block ( Catches | [Catches] FinallyPart )
2703      *     | TRY &quot;(&quot; ResourceSpecification &quot;;&quot;opt &quot;)&quot; Block [Catches] [FinallyPart]
2704      *     | SWITCH ParExpression &quot;{&quot; SwitchBlockStatementGroups &quot;}&quot;
2705      *     | SYNCHRONIZED ParExpression Block
2706      *     | RETURN [Expression] &quot;;&quot;
2707      *     | THROW Expression &quot;;&quot;
2708      *     | BREAK [Ident] &quot;;&quot;
2709      *     | CONTINUE [Ident] &quot;;&quot;
2710      *     | ASSERT Expression [ &quot;:&quot; Expression ] &quot;;&quot;
2711      *     | &quot;;&quot;
2712      */
2713     public JCStatement parseSimpleStatement() {
2714         int pos = token.pos;
2715         switch (token.kind) {
2716         case LBRACE:
2717             return block();
2718         case IF: {
2719             nextToken();
2720             JCExpression cond = parExpression();
2721             JCStatement thenpart = parseStatementAsBlock();
2722             JCStatement elsepart = null;
2723             if (token.kind == ELSE) {
2724                 nextToken();
2725                 elsepart = parseStatementAsBlock();
2726             }
2727             return F.at(pos).If(cond, thenpart, elsepart);
2728         }
2729         case FOR: {
2730             nextToken();
2731             accept(LPAREN);
2732             List&lt;JCStatement&gt; inits = token.kind == SEMI ? List.nil() : forInit();
2733             if (inits.length() == 1 &amp;&amp;
2734                 inits.head.hasTag(VARDEF) &amp;&amp;
2735                 ((JCVariableDecl) inits.head).init == null &amp;&amp;
2736                 token.kind == COLON) {
2737                 JCVariableDecl var = (JCVariableDecl)inits.head;
2738                 accept(COLON);
2739                 JCExpression expr = parseExpression();
2740                 accept(RPAREN);
2741                 JCStatement body = parseStatementAsBlock();
2742                 return F.at(pos).ForeachLoop(var, expr, body);
2743             } else {
2744                 accept(SEMI);
2745                 JCExpression cond = token.kind == SEMI ? null : parseExpression();
2746                 accept(SEMI);
2747                 List&lt;JCExpressionStatement&gt; steps = token.kind == RPAREN ? List.nil() : forUpdate();
2748                 accept(RPAREN);
2749                 JCStatement body = parseStatementAsBlock();
2750                 return F.at(pos).ForLoop(inits, cond, steps, body);
2751             }
2752         }
2753         case WHILE: {
2754             nextToken();
2755             JCExpression cond = parExpression();
2756             JCStatement body = parseStatementAsBlock();
2757             return F.at(pos).WhileLoop(cond, body);
2758         }
2759         case DO: {
2760             nextToken();
2761             JCStatement body = parseStatementAsBlock();
2762             accept(WHILE);
2763             JCExpression cond = parExpression();
2764             accept(SEMI);
2765             JCDoWhileLoop t = toP(F.at(pos).DoLoop(body, cond));
2766             return t;
2767         }
2768         case TRY: {
2769             nextToken();
2770             List&lt;JCTree&gt; resources = List.nil();
2771             if (token.kind == LPAREN) {
2772                 nextToken();
2773                 resources = resources();
2774                 accept(RPAREN);
2775             }
2776             JCBlock body = block();
2777             ListBuffer&lt;JCCatch&gt; catchers = new ListBuffer&lt;&gt;();
2778             JCBlock finalizer = null;
2779             if (token.kind == CATCH || token.kind == FINALLY) {
2780                 while (token.kind == CATCH) catchers.append(catchClause());
2781                 if (token.kind == FINALLY) {
2782                     nextToken();
2783                     finalizer = block();
2784                 }
2785             } else {
2786                 if (resources.isEmpty()) {
2787                     log.error(DiagnosticFlag.SYNTAX, pos, Errors.TryWithoutCatchFinallyOrResourceDecls);
2788                 }
2789             }
2790             return F.at(pos).Try(resources, body, catchers.toList(), finalizer);
2791         }
2792         case SWITCH: {
2793             nextToken();
2794             JCExpression selector = parExpression();
2795             accept(LBRACE);
2796             List&lt;JCCase&gt; cases = switchBlockStatementGroups();
2797             JCSwitch t = to(F.at(pos).Switch(selector, cases));
2798             accept(RBRACE);
2799             return t;
2800         }
2801         case SYNCHRONIZED: {
2802             nextToken();
2803             JCExpression lock = parExpression();
2804             JCBlock body = block();
2805             return F.at(pos).Synchronized(lock, body);
2806         }
2807         case RETURN: {
2808             nextToken();
2809             JCExpression result = token.kind == SEMI ? null : parseExpression();
2810             accept(SEMI);
2811             JCReturn t = toP(F.at(pos).Return(result));
2812             return t;
2813         }
2814         case THROW: {
2815             nextToken();
2816             JCExpression exc = parseExpression();
2817             accept(SEMI);
2818             JCThrow t = toP(F.at(pos).Throw(exc));
2819             return t;
2820         }
2821         case BREAK: {
2822             nextToken();
2823             Name label = LAX_IDENTIFIER.accepts(token.kind) ? ident() : null;
2824             accept(SEMI);
2825             JCBreak t = toP(F.at(pos).Break(label));
2826             return t;
2827         }
2828         case CONTINUE: {
2829             nextToken();
2830             Name label = LAX_IDENTIFIER.accepts(token.kind) ? ident() : null;
2831             accept(SEMI);
2832             JCContinue t =  toP(F.at(pos).Continue(label));
2833             return t;
2834         }
2835         case SEMI:
2836             nextToken();
2837             return toP(F.at(pos).Skip());
2838         case ELSE:
2839             int elsePos = token.pos;
2840             nextToken();
2841             return doRecover(elsePos, BasicErrorRecoveryAction.BLOCK_STMT, Errors.ElseWithoutIf);
2842         case FINALLY:
2843             int finallyPos = token.pos;
2844             nextToken();
2845             return doRecover(finallyPos, BasicErrorRecoveryAction.BLOCK_STMT, Errors.FinallyWithoutTry);
2846         case CATCH:
2847             return doRecover(token.pos, BasicErrorRecoveryAction.CATCH_CLAUSE, Errors.CatchWithoutTry);
2848         case ASSERT: {
2849             nextToken();
2850             JCExpression assertion = parseExpression();
2851             JCExpression message = null;
2852             if (token.kind == COLON) {
2853                 nextToken();
2854                 message = parseExpression();
2855             }
2856             accept(SEMI);
2857             JCAssert t = toP(F.at(pos).Assert(assertion, message));
2858             return t;
2859         }
2860         default:
2861             Assert.error();
2862             return null;
2863         }
2864     }
2865 
2866     @Override
2867     public JCStatement parseStatement() {
2868         return parseStatementAsBlock();
2869     }
2870 
2871     private JCStatement doRecover(int startPos, ErrorRecoveryAction action, Error errorKey) {
2872         int errPos = S.errPos();
2873         JCTree stm = action.doRecover(this);
2874         S.errPos(errPos);
2875         return toP(F.Exec(syntaxError(startPos, List.of(stm), errorKey)));
2876     }
2877 
2878     /** CatchClause     = CATCH &quot;(&quot; FormalParameter &quot;)&quot; Block
2879      * TODO: the &quot;FormalParameter&quot; is not correct, it uses the special &quot;catchTypes&quot; rule below.
2880      */
2881     protected JCCatch catchClause() {
2882         int pos = token.pos;
2883         accept(CATCH);
2884         accept(LPAREN);
2885         JCModifiers mods = optFinal(Flags.PARAMETER);
2886         List&lt;JCExpression&gt; catchTypes = catchTypes();
2887         JCExpression paramType = catchTypes.size() &gt; 1 ?
2888                 toP(F.at(catchTypes.head.getStartPosition()).TypeUnion(catchTypes)) :
2889                 catchTypes.head;
2890         JCVariableDecl formal = variableDeclaratorId(mods, paramType, FormalParameterKind.CATCH);
2891         accept(RPAREN);
2892         JCBlock body = block();
2893         return F.at(pos).Catch(formal, body);
2894     }
2895 
2896     List&lt;JCExpression&gt; catchTypes() {
2897         ListBuffer&lt;JCExpression&gt; catchTypes = new ListBuffer&lt;&gt;();
2898         catchTypes.add(parseType());
2899         while (token.kind == BAR) {
2900             nextToken();
2901             // Instead of qualident this is now parseType.
2902             // But would that allow too much, e.g. arrays or generics?
2903             catchTypes.add(parseType());
2904         }
2905         return catchTypes.toList();
2906     }
2907 
2908     /** SwitchBlockStatementGroups = { SwitchBlockStatementGroup }
2909      *  SwitchBlockStatementGroup = SwitchLabel BlockStatements
2910      *  SwitchLabel = CASE ConstantExpression &quot;:&quot; | DEFAULT &quot;:&quot;
2911      */
2912     List&lt;JCCase&gt; switchBlockStatementGroups() {
2913         ListBuffer&lt;JCCase&gt; cases = new ListBuffer&lt;&gt;();
2914         while (true) {
2915             int pos = token.pos;
2916             switch (token.kind) {
2917             case CASE:
2918             case DEFAULT:
2919                 cases.appendList(switchBlockStatementGroup());
2920                 break;
2921             case RBRACE: case EOF:
2922                 return cases.toList();
2923             default:
2924                 nextToken(); // to ensure progress
2925                 syntaxError(pos, Errors.Expected3(CASE, DEFAULT, RBRACE));
2926             }
2927         }
2928     }
2929 
2930     protected List&lt;JCCase&gt; switchBlockStatementGroup() {
2931         int pos = token.pos;
2932         List&lt;JCStatement&gt; stats;
2933         JCCase c;
2934         ListBuffer&lt;JCCase&gt; cases = new ListBuffer&lt;JCCase&gt;();
2935         switch (token.kind) {
2936         case CASE: {
2937             nextToken();
2938             ListBuffer&lt;JCExpression&gt; pats = new ListBuffer&lt;&gt;();
2939             while (true) {
2940                 pats.append(term(EXPR | NOLAMBDA));
2941                 if (token.kind != COMMA) break;
2942                 nextToken();
2943                 checkSourceLevel(Feature.SWITCH_MULTIPLE_CASE_LABELS);
2944             };
2945             CaseTree.CaseKind caseKind;
2946             JCTree body = null;
2947             if (token.kind == ARROW) {
2948                 checkSourceLevel(Feature.SWITCH_RULE);
2949                 accept(ARROW);
2950                 caseKind = JCCase.RULE;
2951                 JCStatement statement = parseStatementAsBlock();
2952                 if (!statement.hasTag(EXEC) &amp;&amp; !statement.hasTag(BLOCK) &amp;&amp; !statement.hasTag(Tag.THROW)) {
2953                     log.error(statement.pos(), Errors.SwitchCaseUnexpectedStatement);
2954                 }
2955                 stats = List.of(statement);
2956                 body = stats.head;
2957             } else {
2958                 accept(COLON, tk -&gt; Errors.Expected2(COLON, ARROW));
2959                 caseKind = JCCase.STATEMENT;
2960                 stats = blockStatements();
2961             }
2962             c = F.at(pos).Case(caseKind, pats.toList(), stats, body);
2963             if (stats.isEmpty())
2964                 storeEnd(c, S.prevToken().endPos);
2965             return cases.append(c).toList();
2966         }
2967         case DEFAULT: {
2968             nextToken();
2969             CaseTree.CaseKind caseKind;
2970             JCTree body = null;
2971             if (token.kind == ARROW) {
2972                 checkSourceLevel(Feature.SWITCH_RULE);
2973                 accept(ARROW);
2974                 caseKind = JCCase.RULE;
2975                 JCStatement statement = parseStatementAsBlock();
2976                 if (!statement.hasTag(EXEC) &amp;&amp; !statement.hasTag(BLOCK) &amp;&amp; !statement.hasTag(Tag.THROW)) {
2977                     log.error(statement.pos(), Errors.SwitchCaseUnexpectedStatement);
2978                 }
2979                 stats = List.of(statement);
2980                 body = stats.head;
2981             } else {
2982                 accept(COLON, tk -&gt; Errors.Expected2(COLON, ARROW));
2983                 caseKind = JCCase.STATEMENT;
2984                 stats = blockStatements();
2985             }
2986             c = F.at(pos).Case(caseKind, List.nil(), stats, body);
2987             if (stats.isEmpty())
2988                 storeEnd(c, S.prevToken().endPos);
2989             return cases.append(c).toList();
2990         }
2991         }
2992         throw new AssertionError(&quot;should not reach here&quot;);
2993     }
2994 
2995     /** MoreStatementExpressions = { COMMA StatementExpression }
2996      */
2997     &lt;T extends ListBuffer&lt;? super JCExpressionStatement&gt;&gt; T moreStatementExpressions(int pos,
2998                                                                     JCExpression first,
2999                                                                     T stats) {
3000         // This Exec is a &quot;StatementExpression&quot;; it subsumes no terminating token
3001         stats.append(toP(F.at(pos).Exec(checkExprStat(first))));
3002         while (token.kind == COMMA) {
3003             nextToken();
3004             pos = token.pos;
3005             JCExpression t = parseExpression();
3006             // This Exec is a &quot;StatementExpression&quot;; it subsumes no terminating token
3007             stats.append(toP(F.at(pos).Exec(checkExprStat(t))));
3008         }
3009         return stats;
3010     }
3011 
3012     /** ForInit = StatementExpression MoreStatementExpressions
3013      *           |  { FINAL | &#39;@&#39; Annotation } Type VariableDeclarators
3014      */
3015     List&lt;JCStatement&gt; forInit() {
3016         ListBuffer&lt;JCStatement&gt; stats = new ListBuffer&lt;&gt;();
3017         int pos = token.pos;
3018         if (token.kind == FINAL || token.kind == MONKEYS_AT) {
3019             return variableDeclarators(optFinal(0), parseType(true), stats, true).toList();
3020         } else {
3021             JCExpression t = term(EXPR | TYPE);
3022             if ((lastmode &amp; TYPE) != 0 &amp;&amp; LAX_IDENTIFIER.accepts(token.kind)) {
3023                 return variableDeclarators(modifiersOpt(), t, stats, true).toList();
3024             } else if ((lastmode &amp; TYPE) != 0 &amp;&amp; token.kind == COLON) {
3025                 log.error(DiagnosticFlag.SYNTAX, pos, Errors.BadInitializer(&quot;for-loop&quot;));
3026                 return List.of((JCStatement)F.at(pos).VarDef(modifiersOpt(), names.error, t, null));
3027             } else {
3028                 return moreStatementExpressions(pos, t, stats).toList();
3029             }
3030         }
3031     }
3032 
3033     /** ForUpdate = StatementExpression MoreStatementExpressions
3034      */
3035     List&lt;JCExpressionStatement&gt; forUpdate() {
3036         return moreStatementExpressions(token.pos,
3037                                         parseExpression(),
3038                                         new ListBuffer&lt;JCExpressionStatement&gt;()).toList();
3039     }
3040 
3041     /** AnnotationsOpt = { &#39;@&#39; Annotation }
3042      *
3043      * @param kind Whether to parse an ANNOTATION or TYPE_ANNOTATION
3044      */
3045     protected List&lt;JCAnnotation&gt; annotationsOpt(Tag kind) {
3046         if (token.kind != MONKEYS_AT) return List.nil(); // optimization
3047         ListBuffer&lt;JCAnnotation&gt; buf = new ListBuffer&lt;&gt;();
3048         int prevmode = mode;
3049         while (token.kind == MONKEYS_AT) {
3050             int pos = token.pos;
3051             nextToken();
3052             buf.append(annotation(pos, kind));
3053         }
3054         lastmode = mode;
3055         mode = prevmode;
3056         List&lt;JCAnnotation&gt; annotations = buf.toList();
3057 
3058         return annotations;
3059     }
3060 
3061     List&lt;JCAnnotation&gt; typeAnnotationsOpt() {
3062         List&lt;JCAnnotation&gt; annotations = annotationsOpt(Tag.TYPE_ANNOTATION);
3063         return annotations;
3064     }
3065 
3066     /** ModifiersOpt = { Modifier }
3067      *  Modifier = PUBLIC | PROTECTED | PRIVATE | STATIC | ABSTRACT | FINAL
3068      *           | NATIVE | SYNCHRONIZED | TRANSIENT | VOLATILE | &quot;@&quot;
3069      *           | &quot;@&quot; Annotation
3070      */
3071     protected JCModifiers modifiersOpt() {
3072         return modifiersOpt(null);
3073     }
3074     protected JCModifiers modifiersOpt(JCModifiers partial) {
3075         long flags;
3076         ListBuffer&lt;JCAnnotation&gt; annotations = new ListBuffer&lt;&gt;();
3077         int pos;
3078         if (partial == null) {
3079             flags = 0;
3080             pos = token.pos;
3081         } else {
3082             flags = partial.flags;
3083             annotations.appendList(partial.annotations);
3084             pos = partial.pos;
3085         }
3086         if (token.deprecatedFlag()) {
3087             flags |= Flags.DEPRECATED;
3088         }
3089         int lastPos;
3090     loop:
3091         while (true) {
3092             long flag;
3093             switch (token.kind) {
3094             case PRIVATE     : flag = Flags.PRIVATE; break;
3095             case PROTECTED   : flag = Flags.PROTECTED; break;
3096             case PUBLIC      : flag = Flags.PUBLIC; break;
3097             case STATIC      : flag = Flags.STATIC; break;
3098             case TRANSIENT   : flag = Flags.TRANSIENT; break;
3099             case FINAL       : flag = Flags.FINAL; break;
3100             case ABSTRACT    : flag = Flags.ABSTRACT; break;
3101             case NATIVE      : flag = Flags.NATIVE; break;
3102             case VOLATILE    : flag = Flags.VOLATILE; break;
3103             case SYNCHRONIZED: flag = Flags.SYNCHRONIZED; break;
3104             case STRICTFP    : flag = Flags.STRICTFP; break;
3105             case MONKEYS_AT  : flag = Flags.ANNOTATION; break;
3106             case DEFAULT     : checkSourceLevel(Feature.DEFAULT_METHODS); flag = Flags.DEFAULT; break;
3107             case ERROR       : flag = 0; nextToken(); break;
3108             case IDENTIFIER  : {
3109                 if (isNonSealedClassStart(false)) {
3110                     flag = Flags.NON_SEALED;
3111                     nextToken();
3112                     nextToken();
3113                     break;
3114                 }
3115                 if (isSealedClassStart(false)) {
3116                     checkSourceLevel(Feature.SEALED_CLASSES);
3117                     flag = Flags.SEALED;
3118                     break;
3119                 }
3120                 break loop;
3121             }
3122             default: break loop;
3123             }
3124             if ((flags &amp; flag) != 0) log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.RepeatedModifier);
3125             lastPos = token.pos;
3126             nextToken();
3127             if (flag == Flags.ANNOTATION) {
3128                 if (token.kind != INTERFACE) {
3129                     JCAnnotation ann = annotation(lastPos, Tag.ANNOTATION);
3130                     // if first modifier is an annotation, set pos to annotation&#39;s.
3131                     if (flags == 0 &amp;&amp; annotations.isEmpty())
3132                         pos = ann.pos;
3133                     annotations.append(ann);
3134                     flag = 0;
3135                 }
3136             }
3137             flags |= flag;
3138         }
3139         switch (token.kind) {
3140         case ENUM: flags |= Flags.ENUM; break;
3141         case INTERFACE: flags |= Flags.INTERFACE; break;
3142         default: break;
3143         }
3144 
3145         /* A modifiers tree with no modifier tokens or annotations
3146          * has no text position. */
3147         if ((flags &amp; (Flags.ModifierFlags | Flags.ANNOTATION)) == 0 &amp;&amp; annotations.isEmpty())
3148             pos = Position.NOPOS;
3149 
3150         JCModifiers mods = F.at(pos).Modifiers(flags, annotations.toList());
3151         if (pos != Position.NOPOS)
3152             storeEnd(mods, S.prevToken().endPos);
3153         return mods;
3154     }
3155 
3156     /** Annotation              = &quot;@&quot; Qualident [ &quot;(&quot; AnnotationFieldValues &quot;)&quot; ]
3157      *
3158      * @param pos position of &quot;@&quot; token
3159      * @param kind Whether to parse an ANNOTATION or TYPE_ANNOTATION
3160      */
3161     JCAnnotation annotation(int pos, Tag kind) {
3162         // accept(AT); // AT consumed by caller
3163         if (kind == Tag.TYPE_ANNOTATION) {
3164             checkSourceLevel(Feature.TYPE_ANNOTATIONS);
3165         }
3166         JCTree ident = qualident(false);
3167         List&lt;JCExpression&gt; fieldValues = annotationFieldValuesOpt();
3168         JCAnnotation ann;
3169         if (kind == Tag.ANNOTATION) {
3170             ann = F.at(pos).Annotation(ident, fieldValues);
3171         } else if (kind == Tag.TYPE_ANNOTATION) {
3172             ann = F.at(pos).TypeAnnotation(ident, fieldValues);
3173         } else {
3174             throw new AssertionError(&quot;Unhandled annotation kind: &quot; + kind);
3175         }
3176 
3177         storeEnd(ann, S.prevToken().endPos);
3178         return ann;
3179     }
3180 
3181     List&lt;JCExpression&gt; annotationFieldValuesOpt() {
3182         return (token.kind == LPAREN) ? annotationFieldValues() : List.nil();
3183     }
3184 
3185     /** AnnotationFieldValues   = &quot;(&quot; [ AnnotationFieldValue { &quot;,&quot; AnnotationFieldValue } ] &quot;)&quot; */
3186     List&lt;JCExpression&gt; annotationFieldValues() {
3187         accept(LPAREN);
3188         ListBuffer&lt;JCExpression&gt; buf = new ListBuffer&lt;&gt;();
3189         if (token.kind != RPAREN) {
3190             buf.append(annotationFieldValue());
3191             while (token.kind == COMMA) {
3192                 nextToken();
3193                 buf.append(annotationFieldValue());
3194             }
3195         }
3196         accept(RPAREN);
3197         return buf.toList();
3198     }
3199 
3200     /** AnnotationFieldValue    = AnnotationValue
3201      *                          | Identifier &quot;=&quot; AnnotationValue
3202      */
3203     JCExpression annotationFieldValue() {
3204         if (LAX_IDENTIFIER.accepts(token.kind)) {
3205             selectExprMode();
3206             JCExpression t1 = term1();
3207             if (t1.hasTag(IDENT) &amp;&amp; token.kind == EQ) {
3208                 int pos = token.pos;
3209                 accept(EQ);
3210                 JCExpression v = annotationValue();
3211                 return toP(F.at(pos).Assign(t1, v));
3212             } else {
3213                 return t1;
3214             }
3215         }
3216         return annotationValue();
3217     }
3218 
3219     /* AnnotationValue          = ConditionalExpression
3220      *                          | Annotation
3221      *                          | &quot;{&quot; [ AnnotationValue { &quot;,&quot; AnnotationValue } ] [&quot;,&quot;] &quot;}&quot;
3222      */
3223     JCExpression annotationValue() {
3224         int pos;
3225         switch (token.kind) {
3226         case MONKEYS_AT:
3227             pos = token.pos;
3228             nextToken();
3229             return annotation(pos, Tag.ANNOTATION);
3230         case LBRACE:
3231             pos = token.pos;
3232             accept(LBRACE);
3233             ListBuffer&lt;JCExpression&gt; buf = new ListBuffer&lt;&gt;();
3234             if (token.kind == COMMA) {
3235                 nextToken();
3236             } else if (token.kind != RBRACE) {
3237                 buf.append(annotationValue());
3238                 while (token.kind == COMMA) {
3239                     nextToken();
3240                     if (token.kind == RBRACE) break;
3241                     buf.append(annotationValue());
3242                 }
3243             }
3244             accept(RBRACE);
3245             return toP(F.at(pos).NewArray(null, List.nil(), buf.toList()));
3246         default:
3247             selectExprMode();
3248             return term1();
3249         }
3250     }
3251 
3252     /** VariableDeclarators = VariableDeclarator { &quot;,&quot; VariableDeclarator }
3253      */
3254     public &lt;T extends ListBuffer&lt;? super JCVariableDecl&gt;&gt; T variableDeclarators(JCModifiers mods,
3255                                                                          JCExpression type,
3256                                                                          T vdefs,
3257                                                                          boolean localDecl)
3258     {
3259         return variableDeclaratorsRest(token.pos, mods, type, ident(), false, null, vdefs, localDecl);
3260     }
3261 
3262     /** VariableDeclaratorsRest = VariableDeclaratorRest { &quot;,&quot; VariableDeclarator }
3263      *  ConstantDeclaratorsRest = ConstantDeclaratorRest { &quot;,&quot; ConstantDeclarator }
3264      *
3265      *  @param reqInit  Is an initializer always required?
3266      *  @param dc       The documentation comment for the variable declarations, or null.
3267      */
3268     protected &lt;T extends ListBuffer&lt;? super JCVariableDecl&gt;&gt; T variableDeclaratorsRest(int pos,
3269                                                                      JCModifiers mods,
3270                                                                      JCExpression type,
3271                                                                      Name name,
3272                                                                      boolean reqInit,
3273                                                                      Comment dc,
3274                                                                      T vdefs,
3275                                                                      boolean localDecl)
3276     {
3277         JCVariableDecl head = variableDeclaratorRest(pos, mods, type, name, reqInit, dc, localDecl, false);
3278         vdefs.append(head);
3279         while (token.kind == COMMA) {
3280             // All but last of multiple declarators subsume a comma
3281             storeEnd((JCTree)vdefs.last(), token.endPos);
3282             nextToken();
3283             vdefs.append(variableDeclarator(mods, type, reqInit, dc, localDecl));
3284         }
3285         return vdefs;
3286     }
3287 
3288     /** VariableDeclarator = Ident VariableDeclaratorRest
3289      *  ConstantDeclarator = Ident ConstantDeclaratorRest
3290      */
3291     JCVariableDecl variableDeclarator(JCModifiers mods, JCExpression type, boolean reqInit, Comment dc, boolean localDecl) {
3292         return variableDeclaratorRest(token.pos, mods, type, ident(), reqInit, dc, localDecl, true);
3293     }
3294 
3295     /** VariableDeclaratorRest = BracketsOpt [&quot;=&quot; VariableInitializer]
3296      *  ConstantDeclaratorRest = BracketsOpt &quot;=&quot; VariableInitializer
3297      *
3298      *  @param reqInit  Is an initializer always required?
3299      *  @param dc       The documentation comment for the variable declarations, or null.
3300      */
3301     JCVariableDecl variableDeclaratorRest(int pos, JCModifiers mods, JCExpression type, Name name,
3302                                   boolean reqInit, Comment dc, boolean localDecl, boolean compound) {
3303         type = bracketsOpt(type);
3304         JCExpression init = null;
3305         if (token.kind == EQ) {
3306             nextToken();
3307             init = variableInitializer();
3308         }
3309         else if (reqInit) syntaxError(token.pos, Errors.Expected(EQ));
3310         JCTree elemType = TreeInfo.innermostType(type, true);
3311         int startPos = Position.NOPOS;
3312         if (elemType.hasTag(IDENT)) {
3313             Name typeName = ((JCIdent)elemType).name;
3314             if (restrictedTypeNameStartingAtSource(typeName, pos, !compound &amp;&amp; localDecl) != null) {
3315                 if (type.hasTag(TYPEARRAY) &amp;&amp; !compound) {
3316                     //error - &#39;var&#39; and arrays
3317                     reportSyntaxError(pos, Errors.RestrictedTypeNotAllowedArray(typeName));
3318                 } else {
3319                     if(compound)
3320                         //error - &#39;var&#39; in compound local var decl
3321                         reportSyntaxError(pos, Errors.RestrictedTypeNotAllowedCompound(typeName));
3322                     startPos = TreeInfo.getStartPos(mods);
3323                     if (startPos == Position.NOPOS)
3324                         startPos = TreeInfo.getStartPos(type);
3325                     //implicit type
3326                     type = null;
3327                 }
3328             }
3329         }
3330         JCVariableDecl result =
3331             toP(F.at(pos).VarDef(mods, name, type, init));
3332         attach(result, dc);
3333         result.startPos = startPos;
3334         return result;
3335     }
3336 
3337     Name restrictedTypeName(JCExpression e, boolean shouldWarn) {
3338         switch (e.getTag()) {
3339             case IDENT:
3340                 return restrictedTypeNameStartingAtSource(((JCIdent)e).name, e.pos, shouldWarn) != null ? ((JCIdent)e).name : null;
3341             case TYPEARRAY:
3342                 return restrictedTypeName(((JCArrayTypeTree)e).elemtype, shouldWarn);
3343             default:
3344                 return null;
3345         }
3346     }
3347 
3348     Source restrictedTypeNameStartingAtSource(Name name, int pos, boolean shouldWarn) {
3349         if (name == names.var) {
3350             if (Feature.LOCAL_VARIABLE_TYPE_INFERENCE.allowedInSource(source)) {
3351                 return Source.JDK10;
3352             } else if (shouldWarn) {
3353                 log.warning(pos, Warnings.RestrictedTypeNotAllowed(name, Source.JDK10));
3354             }
3355         }
3356         if (name == names.yield) {
3357             if (allowYieldStatement) {
3358                 return Source.JDK14;
3359             } else if (shouldWarn) {
3360                 log.warning(pos, Warnings.RestrictedTypeNotAllowed(name, Source.JDK14));
3361             }
3362         }
3363         if (name == names.record) {
3364             if (allowRecords) {
3365                 return Source.JDK14;
3366             } else if (shouldWarn) {
3367                 log.warning(pos, Warnings.RestrictedTypeNotAllowedPreview(name, Source.JDK14));
3368             }
3369         }
3370         if (name == names.sealed) {
3371             if (allowSealedTypes) {
3372                 return Source.JDK15;
3373             } else if (shouldWarn) {
3374                 log.warning(pos, Warnings.RestrictedTypeNotAllowedPreview(name, Source.JDK15));
3375             }
3376         }
3377         if (name == names.permits) {
3378             if (allowSealedTypes) {
3379                 return Source.JDK15;
3380             } else if (shouldWarn) {
3381                 log.warning(pos, Warnings.RestrictedTypeNotAllowedPreview(name, Source.JDK15));
3382             }
3383         }
3384         return null;
3385     }
3386 
3387     /** The kind of a formal parameter
3388      */
3389     enum FormalParameterKind {
3390         /* a formal lambda parameter
3391          */
3392         LAMBDA {
3393             @Override
3394             boolean isLambdaParameter() {
3395                 return true;
3396             }
3397         },
3398         /* a formal catch clause parameter
3399          */
3400         CATCH,
3401         /* a formal method parameter
3402          */
3403         METHOD,
3404         /* a formal record parameter
3405          */
3406         RECORD;
3407 
3408         boolean isLambdaParameter() {
3409             return false;
3410         }
3411         boolean isRecordParameter() {
3412             return false;
3413         }
3414     }
3415 
3416     /** VariableDeclaratorId = Ident BracketsOpt
3417      */
3418     JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type) {
3419 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
3420         return variableDeclaratorId(mods, type, false, false);
3421     }
3422     //where
3423     JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type, boolean lambdaParameter, boolean recordComponent) {
3424 =======
3425         return variableDeclaratorId(mods, type, FormalParameterKind.METHOD);
3426     }
3427 
3428     JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type, FormalParameterKind parameterKind) {
3429 &gt;&gt;&gt;&gt;&gt;&gt;&gt; 7cffdc99929e9bbd89765c7d0e8390f9e40fe238
3430         int pos = token.pos;
3431         Name name;
3432         boolean allowUnderscoreAsFormal = Feature.UNDERSCORE_AS_PARAM_NAME.allowedInSource(source);
3433         boolean isUnderscore = token.kind == UNDERSCORE;
3434         if (parameterKind.isLambdaParameter() &amp;&amp; isUnderscore &amp;&amp; !allowUnderscoreAsFormal) {
3435             log.error(pos, Errors.UnderscoreAsIdentifierInLambda);
3436             name = token.name();
3437             nextToken();
3438         } else if (parameterKind == FormalParameterKind.METHOD &amp;&amp; isUnderscore &amp;&amp; allowUnderscoreAsFormal) {
3439             log.error(pos, Errors.UnderscoreAsIdentifierInMethod);
3440             name = token.name();
3441             nextToken();
3442         } else {
3443             if (allowThisIdent ||
3444                 parameterKind != FormalParameterKind.LAMBDA ||
3445                 LAX_IDENTIFIER.accepts(token.kind) ||
3446                 mods.flags != Flags.PARAMETER ||
3447                 mods.annotations.nonEmpty()) {
3448                 JCExpression pn = qualident(false, allowUnderscoreAsFormal);
3449                 if (pn.hasTag(Tag.IDENT) &amp;&amp; ((JCIdent)pn).name != names._this) {
3450                     name = ((JCIdent)pn).name;
3451                 } else {
3452                     if (allowThisIdent) {
3453                         if ((mods.flags &amp; Flags.VARARGS) != 0) {
3454                             log.error(token.pos, Errors.VarargsAndReceiver);
3455                         }
3456                         if (token.kind == LBRACKET) {
3457                             log.error(token.pos, Errors.ArrayAndReceiver);
3458                         }
3459                         if (pn.hasTag(Tag.SELECT) &amp;&amp; ((JCFieldAccess)pn).name != names._this) {
3460                             log.error(token.pos, Errors.WrongReceiver);
3461                         }
3462                     }
3463                     return toP(F.at(pos).ReceiverVarDef(mods, pn, type));
3464                 }
3465             } else {
3466                 /** if it is a lambda parameter and the token kind is not an identifier,
3467                  *  and there are no modifiers or annotations, then this means that the compiler
3468                  *  supposed the lambda to be explicit but it can contain a mix of implicit,
3469                  *  var or explicit parameters. So we assign the error name to the parameter name
3470                  *  instead of issuing an error and analyze the lambda parameters as a whole at
3471                  *  a higher level.
3472                  */
3473                 name = names.empty;
3474             }
3475         }
3476         if ((mods.flags &amp; Flags.VARARGS) != 0 &amp;&amp;
3477                 token.kind == LBRACKET) {
3478             log.error(token.pos, Errors.VarargsAndOldArraySyntax);
3479         }
3480 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
3481         if (recordComponent &amp;&amp; token.kind == LBRACKET) {
3482             log.error(token.pos, Errors.RecordComponentAndOldArraySyntax);
3483         }
3484         type = bracketsOpt(type);
3485 
3486         return toP(F.at(pos).VarDef(mods, name, type, null));
3487 =======
3488         int dimensionsPos = token.pos;
3489         JCExpression typeWithDimensions = bracketsOpt(type);
3490         if (allowUnderscoreAsFormal &amp;&amp; isUnderscore &amp;&amp; typeWithDimensions != type) {
3491             log.error(dimensionsPos, Errors.UnderscoreCantBeFollowedByDimensions);
3492         }
3493         return toP(F.at(pos).VarDef(mods, name, typeWithDimensions, null));
3494 &gt;&gt;&gt;&gt;&gt;&gt;&gt; 7cffdc99929e9bbd89765c7d0e8390f9e40fe238
3495     }
3496 
3497     /** Resources = Resource { &quot;;&quot; Resources }
3498      */
3499     List&lt;JCTree&gt; resources() {
3500         ListBuffer&lt;JCTree&gt; defs = new ListBuffer&lt;&gt;();
3501         defs.append(resource());
3502         while (token.kind == SEMI) {
3503             // All but last of multiple declarators must subsume a semicolon
3504             storeEnd(defs.last(), token.endPos);
3505             int semiColonPos = token.pos;
3506             nextToken();
3507             if (token.kind == RPAREN) { // Optional trailing semicolon
3508                                        // after last resource
3509                 break;
3510             }
3511             defs.append(resource());
3512         }
3513         return defs.toList();
3514     }
3515 
3516     /** Resource = VariableModifiersOpt Type VariableDeclaratorId &quot;=&quot; Expression
3517      *           | Expression
3518      */
3519     protected JCTree resource() {
3520         int startPos = token.pos;
3521         if (token.kind == FINAL || token.kind == MONKEYS_AT) {
3522             JCModifiers mods = optFinal(Flags.FINAL);
3523             JCExpression t = parseType(true);
3524             return variableDeclaratorRest(token.pos, mods, t, ident(), true, null, true, false);
3525         }
3526         JCExpression t = term(EXPR | TYPE);
3527         if ((lastmode &amp; TYPE) != 0 &amp;&amp; LAX_IDENTIFIER.accepts(token.kind)) {
3528             JCModifiers mods = toP(F.at(startPos).Modifiers(Flags.FINAL));
3529             return variableDeclaratorRest(token.pos, mods, t, ident(), true, null, true, false);
3530         } else {
3531             checkSourceLevel(Feature.EFFECTIVELY_FINAL_VARIABLES_IN_TRY_WITH_RESOURCES);
3532             if (!t.hasTag(IDENT) &amp;&amp; !t.hasTag(SELECT)) {
3533                 log.error(t.pos(), Errors.TryWithResourcesExprNeedsVar);
3534             }
3535 
3536             return t;
3537         }
3538     }
3539 
3540     /** CompilationUnit = [ { &quot;@&quot; Annotation } PACKAGE Qualident &quot;;&quot;] {ImportDeclaration} {TypeDeclaration}
3541      */
3542     public JCTree.JCCompilationUnit parseCompilationUnit() {
3543         Token firstToken = token;
3544         JCModifiers mods = null;
3545         boolean consumedToplevelDoc = false;
3546         boolean seenImport = false;
3547         boolean seenPackage = false;
3548         ListBuffer&lt;JCTree&gt; defs = new ListBuffer&lt;&gt;();
3549         if (token.kind == MONKEYS_AT)
3550             mods = modifiersOpt();
3551 
3552         if (token.kind == PACKAGE) {
3553             int packagePos = token.pos;
3554             List&lt;JCAnnotation&gt; annotations = List.nil();
3555             seenPackage = true;
3556             if (mods != null) {
3557                 checkNoMods(mods.flags);
3558                 annotations = mods.annotations;
3559                 mods = null;
3560             }
3561             nextToken();
3562             JCExpression pid = qualident(false);
3563             accept(SEMI);
3564             JCPackageDecl pd = toP(F.at(packagePos).PackageDecl(annotations, pid));
3565             attach(pd, firstToken.comment(CommentStyle.JAVADOC));
3566             consumedToplevelDoc = true;
3567             defs.append(pd);
3568         }
3569 
3570         boolean checkForImports = true;
3571         boolean firstTypeDecl = true;
3572         while (token.kind != EOF) {
3573             if (token.pos &lt;= endPosTable.errorEndPos) {
3574                 // error recovery
3575                 skip(checkForImports, false, false, false);
3576                 if (token.kind == EOF)
3577                     break;
3578             }
3579             if (checkForImports &amp;&amp; mods == null &amp;&amp; token.kind == IMPORT) {
3580                 seenImport = true;
3581                 defs.append(importDeclaration());
3582             } else {
3583                 Comment docComment = token.comment(CommentStyle.JAVADOC);
3584                 if (firstTypeDecl &amp;&amp; !seenImport &amp;&amp; !seenPackage) {
3585                     docComment = firstToken.comment(CommentStyle.JAVADOC);
3586                     consumedToplevelDoc = true;
3587                 }
3588                 if (mods != null || token.kind != SEMI)
3589                     mods = modifiersOpt(mods);
3590                 if (firstTypeDecl &amp;&amp; token.kind == IDENTIFIER) {
3591                     ModuleKind kind = ModuleKind.STRONG;
3592                     if (token.name() == names.open) {
3593                         kind = ModuleKind.OPEN;
3594                         nextToken();
3595                     }
3596                     if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.module) {
3597                         if (mods != null) {
3598                             checkNoMods(mods.flags &amp; ~Flags.DEPRECATED);
3599                         }
3600                         defs.append(moduleDecl(mods, kind, docComment));
3601                         consumedToplevelDoc = true;
3602                         break;
3603                     } else if (kind != ModuleKind.STRONG) {
3604                         reportSyntaxError(token.pos, Errors.ExpectedModule);
3605                     }
3606                 }
3607                 JCTree def = typeDeclaration(mods, docComment);
3608                 if (def instanceof JCExpressionStatement)
3609                     def = ((JCExpressionStatement)def).expr;
3610                 defs.append(def);
3611                 if (def instanceof JCClassDecl)
3612                     checkForImports = false;
3613                 mods = null;
3614                 firstTypeDecl = false;
3615             }
3616         }
3617         JCTree.JCCompilationUnit toplevel = F.at(firstToken.pos).TopLevel(defs.toList());
3618         if (!consumedToplevelDoc)
3619             attach(toplevel, firstToken.comment(CommentStyle.JAVADOC));
3620         if (defs.isEmpty())
3621             storeEnd(toplevel, S.prevToken().endPos);
3622         if (keepDocComments)
3623             toplevel.docComments = docComments;
3624         if (keepLineMap)
3625             toplevel.lineMap = S.getLineMap();
3626         this.endPosTable.setParser(null); // remove reference to parser
3627         toplevel.endPositions = this.endPosTable;
3628         return toplevel;
3629     }
3630 
3631     JCModuleDecl moduleDecl(JCModifiers mods, ModuleKind kind, Comment dc) {
3632         int pos = token.pos;
3633         checkSourceLevel(Feature.MODULES);
3634 
3635         nextToken();
3636         JCExpression name = qualident(false);
3637         List&lt;JCDirective&gt; directives = null;
3638 
3639         accept(LBRACE);
3640         directives = moduleDirectiveList();
3641         accept(RBRACE);
3642         accept(EOF);
3643 
3644         JCModuleDecl result = toP(F.at(pos).ModuleDef(mods, kind, name, directives));
3645         attach(result, dc);
3646         return result;
3647     }
3648 
3649     List&lt;JCDirective&gt; moduleDirectiveList() {
3650         ListBuffer&lt;JCDirective&gt; defs = new ListBuffer&lt;&gt;();
3651         while (token.kind == IDENTIFIER) {
3652             int pos = token.pos;
3653             if (token.name() == names.requires) {
3654                 nextToken();
3655                 boolean isTransitive = false;
3656                 boolean isStaticPhase = false;
3657             loop:
3658                 while (true) {
3659                     switch (token.kind) {
3660                         case IDENTIFIER:
3661                             if (token.name() == names.transitive &amp;&amp; !isTransitive) {
3662                                 Token t1 = S.token(1);
3663                                 if (t1.kind == SEMI || t1.kind == DOT) {
3664                                     break loop;
3665                                 }
3666                                 isTransitive = true;
3667                                 break;
3668                             } else {
3669                                 break loop;
3670                             }
3671                         case STATIC:
3672                             if (isStaticPhase) {
3673                                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.RepeatedModifier);
3674                             }
3675                             isStaticPhase = true;
3676                             break;
3677                         default:
3678                             break loop;
3679                     }
3680                     nextToken();
3681                 }
3682                 JCExpression moduleName = qualident(false);
3683                 accept(SEMI);
3684                 defs.append(toP(F.at(pos).Requires(isTransitive, isStaticPhase, moduleName)));
3685             } else if (token.name() == names.exports || token.name() == names.opens) {
3686                 boolean exports = token.name() == names.exports;
3687                 nextToken();
3688                 JCExpression pkgName = qualident(false);
3689                 List&lt;JCExpression&gt; moduleNames = null;
3690                 if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.to) {
3691                     nextToken();
3692                     moduleNames = qualidentList(false);
3693                 }
3694                 accept(SEMI);
3695                 JCDirective d;
3696                 if (exports) {
3697                     d = F.at(pos).Exports(pkgName, moduleNames);
3698                 } else {
3699                     d = F.at(pos).Opens(pkgName, moduleNames);
3700                 }
3701                 defs.append(toP(d));
3702             } else if (token.name() == names.provides) {
3703                 nextToken();
3704                 JCExpression serviceName = qualident(false);
3705                 if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.with) {
3706                     nextToken();
3707                     List&lt;JCExpression&gt; implNames = qualidentList(false);
3708                     accept(SEMI);
3709                     defs.append(toP(F.at(pos).Provides(serviceName, implNames)));
3710                 } else {
3711                     log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.ExpectedStr(&quot;&#39;&quot; + names.with + &quot;&#39;&quot;));
3712                     skip(false, false, false, false);
3713                 }
3714             } else if (token.name() == names.uses) {
3715                 nextToken();
3716                 JCExpression service = qualident(false);
3717                 accept(SEMI);
3718                 defs.append(toP(F.at(pos).Uses(service)));
3719             } else {
3720                 setErrorEndPos(pos);
3721                 reportSyntaxError(pos, Errors.InvalidModuleDirective);
3722                 break;
3723             }
3724         }
3725         return defs.toList();
3726     }
3727 
3728     /** ImportDeclaration = IMPORT [ STATIC ] Ident { &quot;.&quot; Ident } [ &quot;.&quot; &quot;*&quot; ] &quot;;&quot;
3729      */
3730     protected JCTree importDeclaration() {
3731         int pos = token.pos;
3732         nextToken();
3733         boolean importStatic = false;
3734         if (token.kind == STATIC) {
3735             importStatic = true;
3736             nextToken();
3737         }
3738         JCExpression pid = toP(F.at(token.pos).Ident(ident()));
3739         do {
3740             int pos1 = token.pos;
3741             accept(DOT);
3742             if (token.kind == STAR) {
3743                 pid = to(F.at(pos1).Select(pid, names.asterisk));
3744                 nextToken();
3745                 break;
3746             } else {
3747                 pid = toP(F.at(pos1).Select(pid, ident()));
3748             }
3749         } while (token.kind == DOT);
3750         accept(SEMI);
3751         return toP(F.at(pos).Import(pid, importStatic));
3752     }
3753 
3754     /** TypeDeclaration = ClassOrInterfaceOrEnumDeclaration
3755      *                  | &quot;;&quot;
3756      */
3757     JCTree typeDeclaration(JCModifiers mods, Comment docComment) {
3758         int pos = token.pos;
3759         if (mods == null &amp;&amp; token.kind == SEMI) {
3760             nextToken();
3761             return toP(F.at(pos).Skip());
3762         } else {
3763             return classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(mods), docComment);
3764         }
3765     }
3766 
3767     /** ClassOrInterfaceOrEnumDeclaration = ModifiersOpt
3768      *           (ClassDeclaration | InterfaceDeclaration | EnumDeclaration)
3769      *  @param mods     Any modifiers starting the class or interface declaration
3770      *  @param dc       The documentation comment for the class, or null.
3771      */
3772     protected JCStatement classOrRecordOrInterfaceOrEnumDeclaration(JCModifiers mods, Comment dc) {
3773         if (token.kind == CLASS) {
3774             return classDeclaration(mods, dc);
3775         } if (isRecordStart()) {
3776             return recordDeclaration(mods, dc);
3777         } else if (token.kind == INTERFACE) {
3778             return interfaceDeclaration(mods, dc);
3779         } else if (token.kind == ENUM) {
3780             return enumDeclaration(mods, dc);
3781         } else {
3782             int pos = token.pos;
3783             List&lt;JCTree&gt; errs;
3784             if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.record &amp;&amp; preview.isEnabled()) {
3785                 checkSourceLevel(Feature.RECORDS);
3786                 JCErroneous erroneousTree = syntaxError(token.pos, List.of(mods), Errors.RecordHeaderExpected);
3787                 return toP(F.Exec(erroneousTree));
3788             } else {
3789                 if (LAX_IDENTIFIER.accepts(token.kind)) {
3790                     errs = List.of(mods, toP(F.at(pos).Ident(ident())));
3791                     setErrorEndPos(token.pos);
3792                 } else {
3793                     errs = List.of(mods);
3794                 }
3795                 final JCErroneous erroneousTree;
3796                 if (parseModuleInfo) {
3797                     erroneousTree = syntaxError(pos, errs, Errors.ExpectedModuleOrOpen);
3798                 } else {
3799                     if (allowRecords) {
3800                         erroneousTree = syntaxError(pos, errs, Errors.Expected4(CLASS, INTERFACE, ENUM, &quot;record&quot;));
3801                     } else {
3802                         erroneousTree = syntaxError(pos, errs, Errors.Expected3(CLASS, INTERFACE, ENUM));
3803                     }
3804                 }
3805                 return toP(F.Exec(erroneousTree));
3806             }
3807         }
3808     }
3809 
3810     /** ClassDeclaration = CLASS Ident TypeParametersOpt [EXTENDS Type]
3811      *                     [IMPLEMENTS TypeList] ClassBody
3812      *  @param mods    The modifiers starting the class declaration
3813      *  @param dc       The documentation comment for the class, or null.
3814      */
3815     protected JCClassDecl classDeclaration(JCModifiers mods, Comment dc) {
3816         int pos = token.pos;
3817         accept(CLASS);
3818         Name name = typeName();
3819 
3820         List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
3821 
3822         JCExpression extending = null;
3823         if (token.kind == EXTENDS) {
3824             nextToken();
3825             extending = parseType();
3826         }
3827         List&lt;JCExpression&gt; implementing = List.nil();
3828         if (token.kind == IMPLEMENTS) {
3829             nextToken();
3830             implementing = typeList();
3831         }
3832         List&lt;JCExpression&gt; permitting = permitsClause(mods, &quot;class&quot;);
3833         List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(name, false, false);
3834         JCClassDecl result = toP(F.at(pos).ClassDef(
3835             mods, name, typarams, extending, implementing, permitting, defs));
3836         attach(result, dc);
3837         return result;
3838     }
3839 
3840     protected JCClassDecl recordDeclaration(JCModifiers mods, Comment dc) {
3841         int pos = token.pos;
3842         nextToken();
3843         mods.flags |= Flags.RECORD;
3844         Name name = typeName();
3845 
3846         List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
3847 
3848         List&lt;JCVariableDecl&gt; headerFields = formalParameters(FormalParameterKind.RECORD);
3849 
3850         List&lt;JCExpression&gt; implementing = List.nil();
3851         if (token.kind == IMPLEMENTS) {
3852             nextToken();
3853             implementing = typeList();
3854         }
3855         List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(name, false, true);
3856         java.util.List&lt;JCVariableDecl&gt; fields = new ArrayList&lt;&gt;();
3857         for (JCVariableDecl field : headerFields) {
3858             fields.add(field);
3859         }
3860         for (JCTree def : defs) {
3861             if (def.hasTag(METHODDEF)) {
3862                 JCMethodDecl methDef = (JCMethodDecl) def;
3863                 if (methDef.name == names.init &amp;&amp; methDef.params.isEmpty() &amp;&amp; (methDef.mods.flags &amp; Flags.COMPACT_RECORD_CONSTRUCTOR) != 0) {
3864                     ListBuffer&lt;JCVariableDecl&gt; tmpParams = new ListBuffer&lt;&gt;();
3865                     for (JCVariableDecl param : headerFields) {
3866                         tmpParams.add(F.at(param)
3867                                 // we will get flags plus annotations from the record component
3868                                 .VarDef(F.Modifiers(Flags.PARAMETER | param.mods.flags &amp; Flags.VARARGS, param.mods.annotations),
3869                                 param.name, param.vartype, null));
3870                     }
3871                     methDef.params = tmpParams.toList();
3872                 }
3873             }
3874         }
3875         for (int i = fields.size() - 1; i &gt;= 0; i--) {
3876             JCVariableDecl field = fields.get(i);
3877             defs = defs.prepend(field);
3878         }
3879         JCClassDecl result = toP(F.at(pos).ClassDef(mods, name, typarams, null, implementing, defs));
3880         attach(result, dc);
3881         return result;
3882     }
3883 
3884     Name typeName() {
3885         int pos = token.pos;
3886         Name name = ident();
3887         Source source = restrictedTypeNameStartingAtSource(name, pos, true);
3888         if (source != null) {
3889             reportSyntaxError(pos, Errors.RestrictedTypeNotAllowed(name, source));
3890         }
3891         return name;
3892     }
3893 
3894     /** InterfaceDeclaration = INTERFACE Ident TypeParametersOpt
3895      *                         [EXTENDS TypeList] InterfaceBody
3896      *  @param mods    The modifiers starting the interface declaration
3897      *  @param dc       The documentation comment for the interface, or null.
3898      */
3899     protected JCClassDecl interfaceDeclaration(JCModifiers mods, Comment dc) {
3900         int pos = token.pos;
3901         accept(INTERFACE);
3902 
3903         Name name = typeName();
3904 
3905         List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
3906 
3907         List&lt;JCExpression&gt; extending = List.nil();
3908         if (token.kind == EXTENDS) {
3909             nextToken();
3910             extending = typeList();
3911         }
3912         List&lt;JCExpression&gt; permitting = permitsClause(mods, &quot;interface&quot;);
3913         List&lt;JCTree&gt; defs;
3914         defs = classInterfaceOrRecordBody(name, true, false);
3915         JCClassDecl result = toP(F.at(pos).ClassDef(
3916             mods, name, typarams, null, extending, permitting, defs));
3917         attach(result, dc);
3918         return result;
3919     }
3920 
3921     List&lt;JCExpression&gt; permitsClause(JCModifiers mods, String classOrInterface) {
3922         if (allowSealedTypes &amp;&amp; token.kind == IDENTIFIER &amp;&amp; token.name() == names.permits) {
3923             checkSourceLevel(Feature.SEALED_CLASSES);
3924             if ((mods.flags &amp; Flags.SEALED) == 0) {
3925                 log.error(token.pos, Errors.InvalidPermitsClause(Fragments.ClassIsNotSealed(classOrInterface)));
3926             }
3927             nextToken();
3928             return qualidentList(false);
3929         }
3930         return List.nil();
3931     }
3932 
3933     /** EnumDeclaration = ENUM Ident [IMPLEMENTS TypeList] EnumBody
3934      *  @param mods    The modifiers starting the enum declaration
3935      *  @param dc       The documentation comment for the enum, or null.
3936      */
3937     protected JCClassDecl enumDeclaration(JCModifiers mods, Comment dc) {
3938         int pos = token.pos;
3939         accept(ENUM);
3940 
3941         Name name = typeName();
3942 
3943         List&lt;JCExpression&gt; implementing = List.nil();
3944         if (token.kind == IMPLEMENTS) {
3945             nextToken();
3946             implementing = typeList();
3947         }
3948 
3949         List&lt;JCTree&gt; defs = enumBody(name);
3950         mods.flags |= Flags.ENUM;
3951         JCClassDecl result = toP(F.at(pos).
3952             ClassDef(mods, name, List.nil(),
3953                      null, implementing, defs));
3954         attach(result, dc);
3955         return result;
3956     }
3957 
3958     /** EnumBody = &quot;{&quot; { EnumeratorDeclarationList } [&quot;,&quot;]
3959      *                  [ &quot;;&quot; {ClassBodyDeclaration} ] &quot;}&quot;
3960      */
3961     List&lt;JCTree&gt; enumBody(Name enumName) {
3962         accept(LBRACE);
3963         ListBuffer&lt;JCTree&gt; defs = new ListBuffer&lt;&gt;();
3964         boolean wasSemi = false;
3965         boolean hasStructuralErrors = false;
3966         boolean wasError = false;
3967         if (token.kind == COMMA) {
3968             nextToken();
3969             if (token.kind == SEMI) {
3970                 wasSemi = true;
3971                 nextToken();
3972             } else if (token.kind != RBRACE) {
3973                 reportSyntaxError(S.prevToken().endPos,
3974                                   Errors.Expected2(RBRACE, SEMI));
3975                 wasError = true;
3976             }
3977         }
3978         while (token.kind != RBRACE &amp;&amp; token.kind != EOF) {
3979             if (token.kind == SEMI) {
3980                 accept(SEMI);
3981                 wasSemi = true;
3982                 if (token.kind == RBRACE || token.kind == EOF) break;
3983             }
3984             EnumeratorEstimate memberType = estimateEnumeratorOrMember(enumName);
3985             if (memberType == EnumeratorEstimate.UNKNOWN) {
3986                 memberType = wasSemi ? EnumeratorEstimate.MEMBER
3987                                      : EnumeratorEstimate.ENUMERATOR;
3988             }
3989             if (memberType == EnumeratorEstimate.ENUMERATOR) {
3990                 wasError = false;
3991                 if (wasSemi &amp;&amp; !hasStructuralErrors) {
3992                     reportSyntaxError(token.pos, Errors.EnumConstantNotExpected);
3993                     hasStructuralErrors = true;
3994                 }
3995                 defs.append(enumeratorDeclaration(enumName));
3996                 if (token.pos &lt;= endPosTable.errorEndPos) {
3997                     // error recovery
3998                    skip(false, true, true, false);
3999                 } else {
4000                     if (token.kind != RBRACE &amp;&amp; token.kind != SEMI &amp;&amp; token.kind != EOF) {
4001                         if (token.kind == COMMA) {
4002                             nextToken();
4003                         } else {
4004                             setErrorEndPos(token.pos);
4005                             reportSyntaxError(S.prevToken().endPos,
4006                                               Errors.Expected3(COMMA, RBRACE, SEMI));
4007                             wasError = true;
4008                         }
4009                     }
4010                 }
4011             } else {
4012                 if (!wasSemi &amp;&amp; !hasStructuralErrors &amp;&amp; !wasError) {
4013                     reportSyntaxError(token.pos, Errors.EnumConstantExpected);
4014                     hasStructuralErrors = true;
4015                 }
4016                 wasError = false;
4017                 defs.appendList(classOrInterfaceOrRecordBodyDeclaration(enumName,
4018                                                                 false, false));
4019                 if (token.pos &lt;= endPosTable.errorEndPos) {
4020                     // error recovery
4021                    skip(false, true, true, false);
4022                 }
4023             }
4024         }
4025         accept(RBRACE);
4026         return defs.toList();
4027     }
4028 
4029     private EnumeratorEstimate estimateEnumeratorOrMember(Name enumName) {
4030         // if we are seeing a record declaration inside of an enum we want the same error message as expected for a
4031         // let&#39;s say an interface declaration inside an enum
4032         if (token.kind == TokenKind.IDENTIFIER &amp;&amp; token.name() != enumName &amp;&amp;
4033                 (!allowRecords || !isRecordStart())) {
4034             Token next = S.token(1);
4035             switch (next.kind) {
4036                 case LPAREN: case LBRACE: case COMMA: case SEMI:
4037                     return EnumeratorEstimate.ENUMERATOR;
4038             }
4039         }
4040         switch (token.kind) {
4041             case IDENTIFIER: case MONKEYS_AT: case LT:
4042                 if (token.kind == IDENTIFIER) {
4043                     if (allowRecords &amp;&amp; isRecordStart()) {
4044                         return EnumeratorEstimate.MEMBER;
4045                     }
4046                 }
4047                 return EnumeratorEstimate.UNKNOWN;
4048             default:
4049                 return EnumeratorEstimate.MEMBER;
4050         }
4051     }
4052 
4053     private enum EnumeratorEstimate {
4054         ENUMERATOR,
4055         MEMBER,
4056         UNKNOWN;
4057     }
4058 
4059     /** EnumeratorDeclaration = AnnotationsOpt [TypeArguments] IDENTIFIER [ Arguments ] [ &quot;{&quot; ClassBody &quot;}&quot; ]
4060      */
4061     JCTree enumeratorDeclaration(Name enumName) {
4062         Comment dc = token.comment(CommentStyle.JAVADOC);
4063         int flags = Flags.PUBLIC|Flags.STATIC|Flags.FINAL|Flags.ENUM;
4064         if (token.deprecatedFlag()) {
4065             flags |= Flags.DEPRECATED;
4066         }
4067         int pos = token.pos;
4068         List&lt;JCAnnotation&gt; annotations = annotationsOpt(Tag.ANNOTATION);
4069         JCModifiers mods = F.at(annotations.isEmpty() ? Position.NOPOS : pos).Modifiers(flags, annotations);
4070         List&lt;JCExpression&gt; typeArgs = typeArgumentsOpt();
4071         int identPos = token.pos;
4072         Name name = ident();
4073         int createPos = token.pos;
4074         List&lt;JCExpression&gt; args = (token.kind == LPAREN)
4075             ? arguments() : List.nil();
4076         JCClassDecl body = null;
4077         if (token.kind == LBRACE) {
4078             JCModifiers mods1 = F.at(Position.NOPOS).Modifiers(Flags.ENUM);
4079             List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(names.empty, false, false);
4080             body = toP(F.at(identPos).AnonymousClassDef(mods1, defs));
4081         }
4082         if (args.isEmpty() &amp;&amp; body == null)
4083             createPos = identPos;
4084         JCIdent ident = F.at(identPos).Ident(enumName);
4085         JCNewClass create = F.at(createPos).NewClass(null, typeArgs, ident, args, body);
4086         if (createPos != identPos)
4087             storeEnd(create, S.prevToken().endPos);
4088         ident = F.at(identPos).Ident(enumName);
4089         JCTree result = toP(F.at(pos).VarDef(mods, name, ident, create));
4090         attach(result, dc);
4091         return result;
4092     }
4093 
4094     /** TypeList = Type {&quot;,&quot; Type}
4095      */
4096     List&lt;JCExpression&gt; typeList() {
4097         ListBuffer&lt;JCExpression&gt; ts = new ListBuffer&lt;&gt;();
4098         ts.append(parseType());
4099         while (token.kind == COMMA) {
4100             nextToken();
4101             ts.append(parseType());
4102         }
4103         return ts.toList();
4104     }
4105 
4106     /** ClassBody     = &quot;{&quot; {ClassBodyDeclaration} &quot;}&quot;
4107      *  InterfaceBody = &quot;{&quot; {InterfaceBodyDeclaration} &quot;}&quot;
4108      */
4109     List&lt;JCTree&gt; classInterfaceOrRecordBody(Name className, boolean isInterface, boolean isRecord) {
4110         accept(LBRACE);
4111         if (token.pos &lt;= endPosTable.errorEndPos) {
4112             // error recovery
4113             skip(false, true, false, false);
4114             if (token.kind == LBRACE)
4115                 nextToken();
4116         }
4117         ListBuffer&lt;JCTree&gt; defs = new ListBuffer&lt;&gt;();
4118         while (token.kind != RBRACE &amp;&amp; token.kind != EOF) {
4119             defs.appendList(classOrInterfaceOrRecordBodyDeclaration(className, isInterface, isRecord));
4120             if (token.pos &lt;= endPosTable.errorEndPos) {
4121                // error recovery
4122                skip(false, true, true, false);
4123            }
4124         }
4125         accept(RBRACE);
4126         return defs.toList();
4127     }
4128 
4129     /** ClassBodyDeclaration =
4130      *      &quot;;&quot;
4131      *    | [STATIC] Block
4132      *    | ModifiersOpt
4133      *      ( Type Ident
4134      *        ( VariableDeclaratorsRest &quot;;&quot; | MethodDeclaratorRest )
4135      *      | VOID Ident VoidMethodDeclaratorRest
4136      *      | TypeParameters [Annotations]
4137      *        ( Type Ident MethodDeclaratorRest
4138      *        | VOID Ident VoidMethodDeclaratorRest
4139      *        )
4140      *      | Ident ConstructorDeclaratorRest
4141      *      | TypeParameters Ident ConstructorDeclaratorRest
4142      *      | ClassOrInterfaceOrEnumDeclaration
4143      *      )
4144      *  InterfaceBodyDeclaration =
4145      *      &quot;;&quot;
4146      *    | ModifiersOpt
4147      *      ( Type Ident
4148      *        ( ConstantDeclaratorsRest &quot;;&quot; | MethodDeclaratorRest )
4149      *      | VOID Ident MethodDeclaratorRest
4150      *      | TypeParameters [Annotations]
4151      *        ( Type Ident MethodDeclaratorRest
4152      *        | VOID Ident VoidMethodDeclaratorRest
4153      *        )
4154      *      | ClassOrInterfaceOrEnumDeclaration
4155      *      )
4156      *
4157      */
4158     protected List&lt;JCTree&gt; classOrInterfaceOrRecordBodyDeclaration(Name className, boolean isInterface, boolean isRecord) {
4159         if (token.kind == SEMI) {
4160             nextToken();
4161             return List.nil();
4162         } else {
4163             Comment dc = token.comment(CommentStyle.JAVADOC);
4164             int pos = token.pos;
4165             JCModifiers mods = modifiersOpt();
4166             if (token.kind == CLASS ||
4167                 allowRecords &amp;&amp; isRecordStart() ||
4168                 token.kind == INTERFACE ||
4169                 token.kind == ENUM) {
4170                 return List.of(classOrRecordOrInterfaceOrEnumDeclaration(mods, dc));
4171             } else if (token.kind == LBRACE &amp;&amp;
4172                        (mods.flags &amp; Flags.StandardFlags &amp; ~Flags.STATIC) == 0 &amp;&amp;
4173                        mods.annotations.isEmpty()) {
4174                 if (isInterface) {
4175                     log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.InitializerNotAllowed);
4176                 } else if (isRecord &amp;&amp; (mods.flags &amp; Flags.STATIC) == 0) {
4177                     log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.InstanceInitializerNotAllowedInRecords);
4178                 }
4179                 return List.of(block(pos, mods.flags));
4180             } else {
4181                 pos = token.pos;
4182                 List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
4183                 // if there are type parameters but no modifiers, save the start
4184                 // position of the method in the modifiers.
4185                 if (typarams.nonEmpty() &amp;&amp; mods.pos == Position.NOPOS) {
4186                     mods.pos = pos;
4187                     storeEnd(mods, pos);
4188                 }
4189                 List&lt;JCAnnotation&gt; annosAfterParams = annotationsOpt(Tag.ANNOTATION);
4190 
4191                 if (annosAfterParams.nonEmpty()) {
4192                     checkSourceLevel(annosAfterParams.head.pos, Feature.ANNOTATIONS_AFTER_TYPE_PARAMS);
4193                     mods.annotations = mods.annotations.appendList(annosAfterParams);
4194                     if (mods.pos == Position.NOPOS)
4195                         mods.pos = mods.annotations.head.pos;
4196                 }
4197 
4198                 Token tk = token;
4199                 pos = token.pos;
4200                 JCExpression type;
4201                 boolean isVoid = token.kind == VOID;
4202                 if (isVoid) {
4203                     type = to(F.at(pos).TypeIdent(TypeTag.VOID));
4204                     nextToken();
4205                 } else {
4206                     // method returns types are un-annotated types
4207                     type = unannotatedType(false);
4208                 }
4209                 if ((token.kind == LPAREN &amp;&amp; !isInterface ||
4210                         isRecord &amp;&amp; token.kind == LBRACE) &amp;&amp; type.hasTag(IDENT)) {
4211                     if (isInterface || tk.name() != className)
4212                         log.error(DiagnosticFlag.SYNTAX, pos, Errors.InvalidMethDeclRetTypeReq);
4213                     else if (annosAfterParams.nonEmpty())
4214                         illegal(annosAfterParams.head.pos);
4215                     if (isRecord &amp;&amp; token.kind == LBRACE) {
4216                         mods.flags |= Flags.COMPACT_RECORD_CONSTRUCTOR;
4217                     }
4218                     return List.of(methodDeclaratorRest(
4219                         pos, mods, null, names.init, typarams,
4220                         isInterface, true, isRecord, dc));
4221                 } else if (isRecord &amp;&amp; type.hasTag(IDENT) &amp;&amp; token.kind == THROWS) {
4222                     // trying to define a compact constructor with a throws clause
4223                     log.error(DiagnosticFlag.SYNTAX, token.pos,
4224                             Errors.InvalidCanonicalConstructorInRecord(
4225                                     Fragments.Compact,
4226                                     className,
4227                                     Fragments.ThrowsClauseNotAllowedForCanonicalConstructor(Fragments.Compact)));
4228                     skip(false, true, false, false);
4229                     return List.of(methodDeclaratorRest(
4230                             pos, mods, null, names.init, typarams,
4231                             isInterface, true, isRecord, dc));
4232                 } else {
4233                     pos = token.pos;
4234                     Name name = ident();
4235                     if (token.kind == LPAREN) {
4236                         return List.of(methodDeclaratorRest(
4237                             pos, mods, type, name, typarams,
4238                             isInterface, isVoid, false, dc));
4239                     } else if (!isVoid &amp;&amp; typarams.isEmpty()) {
4240                         if (!isRecord || (isRecord &amp;&amp; (mods.flags &amp; Flags.STATIC) != 0)) {
4241                         List&lt;JCTree&gt; defs =
4242                             variableDeclaratorsRest(pos, mods, type, name, isInterface, dc,
4243                                                     new ListBuffer&lt;JCTree&gt;(), false).toList();
4244                         accept(SEMI);
4245                         storeEnd(defs.last(), S.prevToken().endPos);
4246                         return defs;
4247                     } else {
4248                             int errPos = pos;
4249                             variableDeclaratorsRest(pos, mods, type, name, isInterface, dc,
4250                                     new ListBuffer&lt;JCTree&gt;(), false).toList();
4251                             accept(SEMI);
4252                             return List.of(syntaxError(errPos, null, Errors.RecordCannotDeclareInstanceFields));
4253                         }
4254                     } else {
4255                         pos = token.pos;
4256                         List&lt;JCTree&gt; err;
4257                         if (isVoid || typarams.nonEmpty()) {
4258                             JCMethodDecl m =
4259                                     toP(F.at(pos).MethodDef(mods, name, type, typarams,
4260                                                             List.nil(), List.nil(), null, null));
4261                             attach(m, dc);
4262                             err = List.of(m);
4263                         } else {
4264                             err = List.nil();
4265                         }
4266                         return List.of(syntaxError(token.pos, err, Errors.Expected(LPAREN)));
4267                     }
4268                 }
4269             }
4270         }
4271     }
4272 
4273     protected boolean isRecordStart() {
4274         if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.record &amp;&amp;
4275             (peekToken(TokenKind.IDENTIFIER, TokenKind.LPAREN) ||
4276              peekToken(TokenKind.IDENTIFIER, TokenKind.EOF) ||
4277              peekToken(TokenKind.IDENTIFIER, TokenKind.LT))) {
4278              checkSourceLevel(Feature.RECORDS);
4279             return true;
4280         } else {
4281             return false;
4282         }
4283     }
4284 
4285     protected boolean isNonSealedClassStart(boolean local) {
4286         if (isNonSealedIdentifier(token, 0)) {
4287             Token next = S.token(3);
4288             return allowedAfterSealedOrNonSealed(next, local, true);
4289         }
4290         return false;
4291     }
4292 
4293     protected boolean isNonSealedIdentifier(Token someToken, int lookAheadOffset) {
4294         if (someToken.name() == names.non &amp;&amp; peekToken(lookAheadOffset, TokenKind.SUB, TokenKind.IDENTIFIER)) {
4295             Token tokenSub = S.token(lookAheadOffset + 1);
4296             Token tokenSealed = S.token(lookAheadOffset + 2);
4297             if (someToken.endPos == tokenSub.pos &amp;&amp;
4298                     tokenSub.endPos == tokenSealed.pos &amp;&amp;
4299                     tokenSealed.name() == names.sealed) {
4300                 checkSourceLevel(Feature.SEALED_CLASSES);
4301                 return true;
4302             }
4303         }
4304         return false;
4305     }
4306 
4307     protected boolean isSealedClassStart(boolean local) {
4308         if (token.name() == names.sealed) {
4309             Token next = S.token(1);
4310             if (allowedAfterSealedOrNonSealed(next, local, false)) {
4311                 checkSourceLevel(Feature.SEALED_CLASSES);
4312                 return true;
4313             }
4314         }
4315         return false;
4316     }
4317 
4318     private boolean allowedAfterSealedOrNonSealed(Token next, boolean local, boolean currentIsNonSealed) {
4319         return local ?
4320             switch (next.kind) {
4321                 case MONKEYS_AT, ABSTRACT, FINAL, STRICTFP, CLASS, INTERFACE, ENUM -&gt; true;
4322                 default -&gt; false;
4323             } :
4324             switch (next.kind) {
4325                 case MONKEYS_AT, PUBLIC, PROTECTED, PRIVATE, ABSTRACT, STATIC, FINAL, STRICTFP, CLASS, INTERFACE, ENUM -&gt; true;
4326                 case IDENTIFIER -&gt; isNonSealedIdentifier(next, currentIsNonSealed ? 3 : 1) || next.name() == names.sealed;
4327                 default -&gt; false;
4328             };
4329     }
4330 
4331     /** MethodDeclaratorRest =
4332      *      FormalParameters BracketsOpt [THROWS TypeList] ( MethodBody | [DEFAULT AnnotationValue] &quot;;&quot;)
4333      *  VoidMethodDeclaratorRest =
4334      *      FormalParameters [THROWS TypeList] ( MethodBody | &quot;;&quot;)
4335      *  ConstructorDeclaratorRest =
4336      *      &quot;(&quot; FormalParameterListOpt &quot;)&quot; [THROWS TypeList] MethodBody
4337      */
4338     protected JCTree methodDeclaratorRest(int pos,
4339                               JCModifiers mods,
4340                               JCExpression type,
4341                               Name name,
4342                               List&lt;JCTypeParameter&gt; typarams,
4343                               boolean isInterface, boolean isVoid,
4344                               boolean isRecord,
4345                               Comment dc) {
4346         if (isInterface) {
4347             if ((mods.flags &amp; Flags.STATIC) != 0) {
4348                 checkSourceLevel(Feature.STATIC_INTERFACE_METHODS);
4349             }
4350             if ((mods.flags &amp; Flags.PRIVATE) != 0) {
4351                 checkSourceLevel(Feature.PRIVATE_INTERFACE_METHODS);
4352             }
4353         }
4354         JCVariableDecl prevReceiverParam = this.receiverParam;
4355         try {
4356             this.receiverParam = null;
4357             // Parsing formalParameters sets the receiverParam, if present
4358             List&lt;JCVariableDecl&gt; params = List.nil();
4359             List&lt;JCExpression&gt; thrown = List.nil();
4360             if (!isRecord || name != names.init || token.kind == LPAREN) {
4361                 params = formalParameters(FormalParameterKind.METHOD);
4362                 if (!isVoid) type = bracketsOpt(type);
4363                 if (token.kind == THROWS) {
4364                     nextToken();
4365                     thrown = qualidentList(true);
4366                 }
4367             }
4368             JCBlock body = null;
4369             JCExpression defaultValue;
4370             if (token.kind == LBRACE) {
4371                 body = block();
4372                 defaultValue = null;
4373             } else {
4374                 if (token.kind == DEFAULT) {
4375                     accept(DEFAULT);
4376                     defaultValue = annotationValue();
4377                 } else {
4378                     defaultValue = null;
4379                 }
4380                 accept(SEMI);
4381                 if (token.pos &lt;= endPosTable.errorEndPos) {
4382                     // error recovery
4383                     skip(false, true, false, false);
4384                     if (token.kind == LBRACE) {
4385                         body = block();
4386                     }
4387                 }
4388             }
4389 
4390             JCMethodDecl result =
4391                     toP(F.at(pos).MethodDef(mods, name, type, typarams,
4392                                             receiverParam, params, thrown,
4393                                             body, defaultValue));
4394             attach(result, dc);
4395             return result;
4396         } finally {
4397             this.receiverParam = prevReceiverParam;
4398         }
4399     }
4400 
4401     /** QualidentList = [Annotations] Qualident {&quot;,&quot; [Annotations] Qualident}
4402      */
4403     List&lt;JCExpression&gt; qualidentList(boolean allowAnnos) {
4404         ListBuffer&lt;JCExpression&gt; ts = new ListBuffer&lt;&gt;();
4405 
4406         List&lt;JCAnnotation&gt; typeAnnos = allowAnnos ? typeAnnotationsOpt() : List.nil();
4407         JCExpression qi = qualident(allowAnnos);
4408         if (!typeAnnos.isEmpty()) {
4409             JCExpression at = insertAnnotationsToMostInner(qi, typeAnnos, false);
4410             ts.append(at);
4411         } else {
4412             ts.append(qi);
4413         }
4414         while (token.kind == COMMA) {
4415             nextToken();
4416 
4417             typeAnnos = allowAnnos ? typeAnnotationsOpt() : List.nil();
4418             qi = qualident(allowAnnos);
4419             if (!typeAnnos.isEmpty()) {
4420                 JCExpression at = insertAnnotationsToMostInner(qi, typeAnnos, false);
4421                 ts.append(at);
4422             } else {
4423                 ts.append(qi);
4424             }
4425         }
4426         return ts.toList();
4427     }
4428 
4429     /**
4430      *  {@literal
4431      *  TypeParametersOpt = [&quot;&lt;&quot; TypeParameter {&quot;,&quot; TypeParameter} &quot;&gt;&quot;]
4432      *  }
4433      */
4434     protected List&lt;JCTypeParameter&gt; typeParametersOpt() {
4435         if (token.kind == LT) {
4436             ListBuffer&lt;JCTypeParameter&gt; typarams = new ListBuffer&lt;&gt;();
4437             nextToken();
4438             typarams.append(typeParameter());
4439             while (token.kind == COMMA) {
4440                 nextToken();
4441                 typarams.append(typeParameter());
4442             }
4443             accept(GT);
4444             return typarams.toList();
4445         } else {
4446             return List.nil();
4447         }
4448     }
4449 
4450     /**
4451      *  {@literal
4452      *  TypeParameter = [Annotations] TypeVariable [TypeParameterBound]
4453      *  TypeParameterBound = EXTENDS Type {&quot;&amp;&quot; Type}
4454      *  TypeVariable = Ident
4455      *  }
4456      */
4457     JCTypeParameter typeParameter() {
4458         int pos = token.pos;
4459         List&lt;JCAnnotation&gt; annos = typeAnnotationsOpt();
4460         Name name = typeName();
4461         ListBuffer&lt;JCExpression&gt; bounds = new ListBuffer&lt;&gt;();
4462         if (token.kind == EXTENDS) {
4463             nextToken();
4464             bounds.append(parseType());
4465             while (token.kind == AMP) {
4466                 nextToken();
4467                 bounds.append(parseType());
4468             }
4469         }
4470         return toP(F.at(pos).TypeParameter(name, bounds.toList(), annos));
4471     }
4472 
4473     /** FormalParameters = &quot;(&quot; [ FormalParameterList ] &quot;)&quot;
4474      *  FormalParameterList = [ FormalParameterListNovarargs , ] LastFormalParameter
4475      *  FormalParameterListNovarargs = [ FormalParameterListNovarargs , ] FormalParameter
4476      */
4477     List&lt;JCVariableDecl&gt; formalParameters(FormalParameterKind parameterKind) {
4478         ListBuffer&lt;JCVariableDecl&gt; params = new ListBuffer&lt;&gt;();
4479         JCVariableDecl lastParam;
4480         accept(LPAREN);
4481         if (token.kind != RPAREN) {
4482             this.allowThisIdent = parameterKind != FormalParameterKind.LAMBDA &amp;&amp; parameterKind != FormalParameterKind.RECORD;
4483             lastParam = formalParameter(parameterKind);
4484             if (lastParam.nameexpr != null) {
4485                 this.receiverParam = lastParam;
4486             } else {
4487                 params.append(lastParam);
4488             }
4489             this.allowThisIdent = false;
4490             while (token.kind == COMMA) {
4491                 if ((lastParam.mods.flags &amp; Flags.VARARGS) != 0) {
4492                     log.error(DiagnosticFlag.SYNTAX, lastParam, Errors.VarargsMustBeLast);
4493                 }
4494                 nextToken();
4495                 params.append(lastParam = formalParameter(parameterKind));
4496             }
4497         }
4498         if (token.kind == RPAREN) {
4499             nextToken();
4500         } else {
4501             setErrorEndPos(token.pos);
4502             reportSyntaxError(S.prevToken().endPos, Errors.Expected3(COMMA, RPAREN, LBRACKET));
4503         }
4504         return params.toList();
4505     }
4506 
4507     List&lt;JCVariableDecl&gt; implicitParameters(boolean hasParens) {
4508         if (hasParens) {
4509             accept(LPAREN);
4510         }
4511         ListBuffer&lt;JCVariableDecl&gt; params = new ListBuffer&lt;&gt;();
4512         if (token.kind != RPAREN &amp;&amp; token.kind != ARROW) {
4513             params.append(implicitParameter());
4514             while (token.kind == COMMA) {
4515                 nextToken();
4516                 params.append(implicitParameter());
4517             }
4518         }
4519         if (hasParens) {
4520             accept(RPAREN);
4521         }
4522         return params.toList();
4523     }
4524 
4525     JCModifiers optFinal(long flags) {
4526         JCModifiers mods = modifiersOpt();
4527         checkNoMods(mods.flags &amp; ~(Flags.FINAL | Flags.DEPRECATED));
4528         mods.flags |= flags;
4529         return mods;
4530     }
4531 
4532     /**
4533      * Inserts the annotations (and possibly a new array level)
4534      * to the left-most type in an array or nested type.
4535      *
4536      * When parsing a type like {@code @B Outer.Inner @A []}, the
4537      * {@code @A} annotation should target the array itself, while
4538      * {@code @B} targets the nested type {@code Outer}.
4539      *
4540      * Currently the parser parses the annotation first, then
4541      * the array, and then inserts the annotation to the left-most
4542      * nested type.
4543      *
4544      * When {@code createNewLevel} is true, then a new array
4545      * level is inserted as the most inner type, and have the
4546      * annotations target it.  This is useful in the case of
4547      * varargs, e.g. {@code String @A [] @B ...}, as the parser
4548      * first parses the type {@code String @A []} then inserts
4549      * a new array level with {@code @B} annotation.
4550      */
4551     private JCExpression insertAnnotationsToMostInner(
4552             JCExpression type, List&lt;JCAnnotation&gt; annos,
4553             boolean createNewLevel) {
4554         int origEndPos = getEndPos(type);
4555         JCExpression mostInnerType = type;
4556         JCArrayTypeTree mostInnerArrayType = null;
4557         while (TreeInfo.typeIn(mostInnerType).hasTag(TYPEARRAY)) {
4558             mostInnerArrayType = (JCArrayTypeTree) TreeInfo.typeIn(mostInnerType);
4559             mostInnerType = mostInnerArrayType.elemtype;
4560         }
4561 
4562         if (createNewLevel) {
4563             mostInnerType = to(F.at(token.pos).TypeArray(mostInnerType));
4564         }
4565 
4566         JCExpression mostInnerTypeToReturn = mostInnerType;
4567         if (annos.nonEmpty()) {
4568             JCExpression lastToModify = mostInnerType;
4569 
4570             while (TreeInfo.typeIn(mostInnerType).hasTag(SELECT) ||
4571                     TreeInfo.typeIn(mostInnerType).hasTag(TYPEAPPLY)) {
4572                 while (TreeInfo.typeIn(mostInnerType).hasTag(SELECT)) {
4573                     lastToModify = mostInnerType;
4574                     mostInnerType = ((JCFieldAccess) TreeInfo.typeIn(mostInnerType)).getExpression();
4575                 }
4576                 while (TreeInfo.typeIn(mostInnerType).hasTag(TYPEAPPLY)) {
4577                     lastToModify = mostInnerType;
4578                     mostInnerType = ((JCTypeApply) TreeInfo.typeIn(mostInnerType)).clazz;
4579                 }
4580             }
4581 
4582             mostInnerType = F.at(annos.head.pos).AnnotatedType(annos, mostInnerType);
4583 
4584             if (TreeInfo.typeIn(lastToModify).hasTag(TYPEAPPLY)) {
4585                 ((JCTypeApply) TreeInfo.typeIn(lastToModify)).clazz = mostInnerType;
4586             } else if (TreeInfo.typeIn(lastToModify).hasTag(SELECT)) {
4587                 ((JCFieldAccess) TreeInfo.typeIn(lastToModify)).selected = mostInnerType;
4588             } else {
4589                 // We never saw a SELECT or TYPEAPPLY, return the annotated type.
4590                 mostInnerTypeToReturn = mostInnerType;
4591             }
4592         }
4593 
4594         if (mostInnerArrayType == null) {
4595             return mostInnerTypeToReturn;
4596         } else {
4597             mostInnerArrayType.elemtype = mostInnerTypeToReturn;
4598             storeEnd(type, origEndPos);
4599             return type;
4600         }
4601     }
4602 
4603     /** FormalParameter = { FINAL | &#39;@&#39; Annotation } Type VariableDeclaratorId
4604      *  LastFormalParameter = { FINAL | &#39;@&#39; Annotation } Type &#39;...&#39; Ident | FormalParameter
4605      */
4606     protected JCVariableDecl formalParameter(FormalParameterKind parameterKind) {
4607         JCModifiers mods = parameterKind != FormalParameterKind.RECORD ? optFinal(Flags.PARAMETER) : modifiersOpt();
4608         if (parameterKind == FormalParameterKind.RECORD &amp;&amp; mods.flags != 0) {
4609             log.error(mods.pos, Errors.RecordCantDeclareFieldModifiers);
4610         }
4611         if (parameterKind == FormalParameterKind.RECORD) {
4612             mods.flags |= Flags.RECORD | Flags.FINAL | Flags.PRIVATE | Flags.GENERATED_MEMBER;
4613         }
4614         // need to distinguish between vararg annos and array annos
4615         // look at typeAnnotationsPushedBack comment
4616         this.permitTypeAnnotationsPushBack = true;
4617         JCExpression type = parseType(parameterKind == FormalParameterKind.LAMBDA);
4618         this.permitTypeAnnotationsPushBack = false;
4619 
4620         if (token.kind == ELLIPSIS) {
4621             List&lt;JCAnnotation&gt; varargsAnnos = typeAnnotationsPushedBack;
4622             typeAnnotationsPushedBack = List.nil();
4623             mods.flags |= Flags.VARARGS;
4624             // insert var arg type annotations
4625             type = insertAnnotationsToMostInner(type, varargsAnnos, true);
4626             nextToken();
4627         } else {
4628             // if not a var arg, then typeAnnotationsPushedBack should be null
4629             if (typeAnnotationsPushedBack.nonEmpty()) {
4630                 reportSyntaxError(typeAnnotationsPushedBack.head.pos, Errors.IllegalStartOfType);
4631             }
4632             typeAnnotationsPushedBack = List.nil();
4633         }
4634 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
4635         return variableDeclaratorId(mods, type, lambdaParameter, recordComponent);
4636 =======
4637         return variableDeclaratorId(mods, type, parameterKind);
4638 &gt;&gt;&gt;&gt;&gt;&gt;&gt; 7cffdc99929e9bbd89765c7d0e8390f9e40fe238
4639     }
4640 
4641     protected JCVariableDecl implicitParameter() {
4642         JCModifiers mods = F.at(token.pos).Modifiers(Flags.PARAMETER);
4643 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
4644         return variableDeclaratorId(mods, null, true, false);
4645 =======
4646         return variableDeclaratorId(mods, null, FormalParameterKind.LAMBDA);
4647 &gt;&gt;&gt;&gt;&gt;&gt;&gt; 7cffdc99929e9bbd89765c7d0e8390f9e40fe238
4648     }
4649 
4650 /* ---------- auxiliary methods -------------- */
4651     /** Check that given tree is a legal expression statement.
4652      */
4653     protected JCExpression checkExprStat(JCExpression t) {
4654         if (!TreeInfo.isExpressionStatement(t)) {
4655             JCExpression ret = F.at(t.pos).Erroneous(List.&lt;JCTree&gt;of(t));
4656             log.error(DiagnosticFlag.SYNTAX, ret, Errors.NotStmt);
4657             return ret;
4658         } else {
4659             return t;
4660         }
4661     }
4662 
4663     /** Return precedence of operator represented by token,
4664      *  -1 if token is not a binary operator. @see TreeInfo.opPrec
4665      */
4666     static int prec(TokenKind token) {
4667         JCTree.Tag oc = optag(token);
4668         return (oc != NO_TAG) ? TreeInfo.opPrec(oc) : -1;
4669     }
4670 
4671     /**
4672      * Return the lesser of two positions, making allowance for either one
4673      * being unset.
4674      */
4675     static int earlier(int pos1, int pos2) {
4676         if (pos1 == Position.NOPOS)
4677             return pos2;
4678         if (pos2 == Position.NOPOS)
4679             return pos1;
4680         return (pos1 &lt; pos2 ? pos1 : pos2);
4681     }
4682 
4683     /** Return operation tag of binary operator represented by token,
4684      *  No_TAG if token is not a binary operator.
4685      */
4686     static JCTree.Tag optag(TokenKind token) {
4687         switch (token) {
4688         case BARBAR:
4689             return OR;
4690         case AMPAMP:
4691             return AND;
4692         case BAR:
4693             return BITOR;
4694         case BAREQ:
4695             return BITOR_ASG;
4696         case CARET:
4697             return BITXOR;
4698         case CARETEQ:
4699             return BITXOR_ASG;
4700         case AMP:
4701             return BITAND;
4702         case AMPEQ:
4703             return BITAND_ASG;
4704         case EQEQ:
4705             return JCTree.Tag.EQ;
4706         case BANGEQ:
4707             return NE;
4708         case LT:
4709             return JCTree.Tag.LT;
4710         case GT:
4711             return JCTree.Tag.GT;
4712         case LTEQ:
4713             return LE;
4714         case GTEQ:
4715             return GE;
4716         case LTLT:
4717             return SL;
4718         case LTLTEQ:
4719             return SL_ASG;
4720         case GTGT:
4721             return SR;
4722         case GTGTEQ:
4723             return SR_ASG;
4724         case GTGTGT:
4725             return USR;
4726         case GTGTGTEQ:
4727             return USR_ASG;
4728         case PLUS:
4729             return JCTree.Tag.PLUS;
4730         case PLUSEQ:
4731             return PLUS_ASG;
4732         case SUB:
4733             return MINUS;
4734         case SUBEQ:
4735             return MINUS_ASG;
4736         case STAR:
4737             return MUL;
4738         case STAREQ:
4739             return MUL_ASG;
4740         case SLASH:
4741             return DIV;
4742         case SLASHEQ:
4743             return DIV_ASG;
4744         case PERCENT:
4745             return MOD;
4746         case PERCENTEQ:
4747             return MOD_ASG;
4748         case INSTANCEOF:
4749             return TYPETEST;
4750         default:
4751             return NO_TAG;
4752         }
4753     }
4754 
4755     /** Return operation tag of unary operator represented by token,
4756      *  No_TAG if token is not a binary operator.
4757      */
4758     static JCTree.Tag unoptag(TokenKind token) {
4759         switch (token) {
4760         case PLUS:
4761             return POS;
4762         case SUB:
4763             return NEG;
4764         case BANG:
4765             return NOT;
4766         case TILDE:
4767             return COMPL;
4768         case PLUSPLUS:
4769             return PREINC;
4770         case SUBSUB:
4771             return PREDEC;
4772         default:
4773             return NO_TAG;
4774         }
4775     }
4776 
4777     /** Return type tag of basic type represented by token,
4778      *  NONE if token is not a basic type identifier.
4779      */
4780     static TypeTag typetag(TokenKind token) {
4781         switch (token) {
4782         case BYTE:
4783             return TypeTag.BYTE;
4784         case CHAR:
4785             return TypeTag.CHAR;
4786         case SHORT:
4787             return TypeTag.SHORT;
4788         case INT:
4789             return TypeTag.INT;
4790         case LONG:
4791             return TypeTag.LONG;
4792         case FLOAT:
4793             return TypeTag.FLOAT;
4794         case DOUBLE:
4795             return TypeTag.DOUBLE;
4796         case BOOLEAN:
4797             return TypeTag.BOOLEAN;
4798         default:
4799             return TypeTag.NONE;
4800         }
4801     }
4802 
4803     void checkSourceLevel(Feature feature) {
4804         checkSourceLevel(token.pos, feature);
4805     }
4806 
4807     protected void checkSourceLevel(int pos, Feature feature) {
4808         if (preview.isPreview(feature) &amp;&amp; !preview.isEnabled()) {
4809             //preview feature without --preview flag, error
4810             log.error(DiagnosticFlag.SOURCE_LEVEL, pos, preview.disabledError(feature));
4811         } else if (!feature.allowedInSource(source)) {
4812             //incompatible source level, error
4813             log.error(DiagnosticFlag.SOURCE_LEVEL, pos, feature.error(source.name));
4814         } else if (preview.isPreview(feature)) {
4815             //use of preview feature, warn
4816             preview.warnPreview(pos, feature);
4817         }
4818     }
4819 
4820     /*
4821      * a functional source tree and end position mappings
4822      */
4823     protected static class SimpleEndPosTable extends AbstractEndPosTable {
4824 
4825         private final IntHashTable endPosMap;
4826 
4827         SimpleEndPosTable(JavacParser parser) {
4828             super(parser);
4829             endPosMap = new IntHashTable();
4830         }
4831 
4832         public void storeEnd(JCTree tree, int endpos) {
4833             endPosMap.putAtIndex(tree, errorEndPos &gt; endpos ? errorEndPos : endpos,
4834                                  endPosMap.lookup(tree));
4835         }
4836 
4837         protected &lt;T extends JCTree&gt; T to(T t) {
4838             storeEnd(t, parser.token.endPos);
4839             return t;
4840         }
4841 
4842         protected &lt;T extends JCTree&gt; T toP(T t) {
4843             storeEnd(t, parser.S.prevToken().endPos);
4844             return t;
4845         }
4846 
4847         public int getEndPos(JCTree tree) {
4848             int value = endPosMap.getFromIndex(endPosMap.lookup(tree));
4849             // As long as Position.NOPOS==-1, this just returns value.
4850             return (value == -1) ? Position.NOPOS : value;
4851         }
4852 
4853         public int replaceTree(JCTree oldTree, JCTree newTree) {
4854             int pos = endPosMap.remove(oldTree);
4855             if (pos != -1) {
4856                 storeEnd(newTree, pos);
4857                 return pos;
4858             }
4859             return Position.NOPOS;
4860         }
4861     }
4862 
4863     /*
4864      * a default skeletal implementation without any mapping overhead.
4865      */
4866     protected static class EmptyEndPosTable extends AbstractEndPosTable {
4867 
4868         EmptyEndPosTable(JavacParser parser) {
4869             super(parser);
4870         }
4871 
4872         public void storeEnd(JCTree tree, int endpos) { /* empty */ }
4873 
4874         protected &lt;T extends JCTree&gt; T to(T t) {
4875             return t;
4876         }
4877 
4878         protected &lt;T extends JCTree&gt; T toP(T t) {
4879             return t;
4880         }
4881 
4882         public int getEndPos(JCTree tree) {
4883             return Position.NOPOS;
4884         }
4885 
4886         public int replaceTree(JCTree oldTree, JCTree newTree) {
4887             return Position.NOPOS;
4888         }
4889 
4890     }
4891 
4892     protected static abstract class AbstractEndPosTable implements EndPosTable {
4893         /**
4894          * The current parser.
4895          */
4896         protected JavacParser parser;
4897 
4898         /**
4899          * Store the last error position.
4900          */
4901         public int errorEndPos = Position.NOPOS;
4902 
4903         public AbstractEndPosTable(JavacParser parser) {
4904             this.parser = parser;
4905         }
4906 
4907         /**
4908          * Store current token&#39;s ending position for a tree, the value of which
4909          * will be the greater of last error position and the ending position of
4910          * the current token.
4911          * @param t The tree.
4912          */
4913         protected abstract &lt;T extends JCTree&gt; T to(T t);
4914 
4915         /**
4916          * Store current token&#39;s ending position for a tree, the value of which
4917          * will be the greater of last error position and the ending position of
4918          * the previous token.
4919          * @param t The tree.
4920          */
4921         protected abstract &lt;T extends JCTree&gt; T toP(T t);
4922 
4923         /**
4924          * Set the error position during the parsing phases, the value of which
4925          * will be set only if it is greater than the last stored error position.
4926          * @param errPos The error position
4927          */
4928         public void setErrorEndPos(int errPos) {
4929             if (errPos &gt; errorEndPos) {
4930                 errorEndPos = errPos;
4931             }
4932         }
4933 
4934         public void setParser(JavacParser parser) {
4935             this.parser = parser;
4936         }
4937     }
4938 }
    </pre>
  </body>
</html>
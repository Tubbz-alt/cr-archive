<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/prims/jvmtiRedefineClasses.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;aot/aotLoader.hpp&quot;
  27 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  28 #include &quot;classfile/classFileStream.hpp&quot;
  29 #include &quot;classfile/javaClasses.inline.hpp&quot;
  30 #include &quot;classfile/metadataOnStackMark.hpp&quot;
  31 #include &quot;classfile/symbolTable.hpp&quot;
  32 #include &quot;classfile/systemDictionary.hpp&quot;
  33 #include &quot;classfile/verifier.hpp&quot;
  34 #include &quot;code/codeCache.hpp&quot;
  35 #include &quot;compiler/compileBroker.hpp&quot;
  36 #include &quot;interpreter/oopMapCache.hpp&quot;
  37 #include &quot;interpreter/rewriter.hpp&quot;
  38 #include &quot;jfr/jfrEvents.hpp&quot;
  39 #include &quot;logging/logStream.hpp&quot;
  40 #include &quot;memory/metadataFactory.hpp&quot;
  41 #include &quot;memory/metaspaceShared.hpp&quot;
  42 #include &quot;memory/resourceArea.hpp&quot;
  43 #include &quot;memory/universe.hpp&quot;
  44 #include &quot;oops/annotations.hpp&quot;
  45 #include &quot;oops/constantPool.hpp&quot;
  46 #include &quot;oops/fieldStreams.inline.hpp&quot;
  47 #include &quot;oops/klassVtable.hpp&quot;
  48 #include &quot;oops/oop.inline.hpp&quot;
  49 #include &quot;oops/recordComponent.hpp&quot;
  50 #include &quot;prims/jvmtiImpl.hpp&quot;
  51 #include &quot;prims/jvmtiRedefineClasses.hpp&quot;
  52 #include &quot;prims/jvmtiThreadState.inline.hpp&quot;
  53 #include &quot;prims/resolvedMethodTable.hpp&quot;
  54 #include &quot;prims/methodComparator.hpp&quot;
  55 #include &quot;runtime/atomic.hpp&quot;
  56 #include &quot;runtime/deoptimization.hpp&quot;
  57 #include &quot;runtime/handles.inline.hpp&quot;
  58 #include &quot;runtime/jniHandles.inline.hpp&quot;
  59 #include &quot;runtime/relocator.hpp&quot;
  60 #include &quot;runtime/safepointVerifiers.hpp&quot;
  61 #include &quot;utilities/bitMap.inline.hpp&quot;
  62 #include &quot;utilities/events.hpp&quot;
  63 
  64 Array&lt;Method*&gt;* VM_RedefineClasses::_old_methods = NULL;
  65 Array&lt;Method*&gt;* VM_RedefineClasses::_new_methods = NULL;
  66 Method**  VM_RedefineClasses::_matching_old_methods = NULL;
  67 Method**  VM_RedefineClasses::_matching_new_methods = NULL;
  68 Method**  VM_RedefineClasses::_deleted_methods      = NULL;
  69 Method**  VM_RedefineClasses::_added_methods        = NULL;
  70 int       VM_RedefineClasses::_matching_methods_length = 0;
  71 int       VM_RedefineClasses::_deleted_methods_length  = 0;
  72 int       VM_RedefineClasses::_added_methods_length    = 0;
  73 bool      VM_RedefineClasses::_has_redefined_Object = false;
  74 bool      VM_RedefineClasses::_has_null_class_loader = false;
  75 u8        VM_RedefineClasses::_id_counter = 0;
  76 
  77 VM_RedefineClasses::VM_RedefineClasses(jint class_count,
  78                                        const jvmtiClassDefinition *class_defs,
  79                                        JvmtiClassLoadKind class_load_kind) {
  80   _class_count = class_count;
  81   _class_defs = class_defs;
  82   _class_load_kind = class_load_kind;
  83   _any_class_has_resolved_methods = false;
  84   _res = JVMTI_ERROR_NONE;
  85   _the_class = NULL;
  86   _has_redefined_Object = false;
  87   _has_null_class_loader = false;
  88   _id = next_id();
  89 }
  90 
  91 static inline InstanceKlass* get_ik(jclass def) {
  92   oop mirror = JNIHandles::resolve_non_null(def);
  93   return InstanceKlass::cast(java_lang_Class::as_Klass(mirror));
  94 }
  95 
  96 // If any of the classes are being redefined, wait
  97 // Parallel constant pool merging leads to indeterminate constant pools.
  98 void VM_RedefineClasses::lock_classes() {
  99   MonitorLocker ml(RedefineClasses_lock);
 100   bool has_redefined;
 101   do {
 102     has_redefined = false;
 103     // Go through classes each time until none are being redefined.
 104     for (int i = 0; i &lt; _class_count; i++) {
 105       if (get_ik(_class_defs[i].klass)-&gt;is_being_redefined()) {
 106         ml.wait();
 107         has_redefined = true;
 108         break;  // for loop
 109       }
 110     }
 111   } while (has_redefined);
 112   for (int i = 0; i &lt; _class_count; i++) {
 113     get_ik(_class_defs[i].klass)-&gt;set_is_being_redefined(true);
 114   }
 115   ml.notify_all();
 116 }
 117 
 118 void VM_RedefineClasses::unlock_classes() {
 119   MonitorLocker ml(RedefineClasses_lock);
 120   for (int i = 0; i &lt; _class_count; i++) {
 121     assert(get_ik(_class_defs[i].klass)-&gt;is_being_redefined(),
 122            &quot;should be being redefined to get here&quot;);
 123     get_ik(_class_defs[i].klass)-&gt;set_is_being_redefined(false);
 124   }
 125   ml.notify_all();
 126 }
 127 
 128 bool VM_RedefineClasses::doit_prologue() {
 129   if (_class_count == 0) {
 130     _res = JVMTI_ERROR_NONE;
 131     return false;
 132   }
 133   if (_class_defs == NULL) {
 134     _res = JVMTI_ERROR_NULL_POINTER;
 135     return false;
 136   }
 137 
 138   for (int i = 0; i &lt; _class_count; i++) {
 139     if (_class_defs[i].klass == NULL) {
 140       _res = JVMTI_ERROR_INVALID_CLASS;
 141       return false;
 142     }
 143     if (_class_defs[i].class_byte_count == 0) {
 144       _res = JVMTI_ERROR_INVALID_CLASS_FORMAT;
 145       return false;
 146     }
 147     if (_class_defs[i].class_bytes == NULL) {
 148       _res = JVMTI_ERROR_NULL_POINTER;
 149       return false;
 150     }
 151 
 152     oop mirror = JNIHandles::resolve_non_null(_class_defs[i].klass);
 153     // classes for primitives, arrays, hidden and vm unsafe anonymous classes
 154     // cannot be redefined.
 155     if (!is_modifiable_class(mirror)) {
 156       _res = JVMTI_ERROR_UNMODIFIABLE_CLASS;
 157       return false;
 158     }
 159   }
 160 
 161   // Start timer after all the sanity checks; not quite accurate, but
 162   // better than adding a bunch of stop() calls.
 163   if (log_is_enabled(Info, redefine, class, timer)) {
 164     _timer_vm_op_prologue.start();
 165   }
 166 
 167   lock_classes();
 168   // We first load new class versions in the prologue, because somewhere down the
 169   // call chain it is required that the current thread is a Java thread.
 170   _res = load_new_class_versions(Thread::current());
 171   if (_res != JVMTI_ERROR_NONE) {
 172     // free any successfully created classes, since none are redefined
 173     for (int i = 0; i &lt; _class_count; i++) {
 174       if (_scratch_classes[i] != NULL) {
 175         ClassLoaderData* cld = _scratch_classes[i]-&gt;class_loader_data();
 176         // Free the memory for this class at class unloading time.  Not before
 177         // because CMS might think this is still live.
 178         InstanceKlass* ik = get_ik(_class_defs[i].klass);
 179         if (ik-&gt;get_cached_class_file() == _scratch_classes[i]-&gt;get_cached_class_file()) {
 180           // Don&#39;t double-free cached_class_file copied from the original class if error.
 181           _scratch_classes[i]-&gt;set_cached_class_file(NULL);
 182         }
 183         cld-&gt;add_to_deallocate_list(InstanceKlass::cast(_scratch_classes[i]));
 184       }
 185     }
 186     // Free os::malloc allocated memory in load_new_class_version.
 187     os::free(_scratch_classes);
 188     _timer_vm_op_prologue.stop();
 189     unlock_classes();
 190     return false;
 191   }
 192 
 193   _timer_vm_op_prologue.stop();
 194   return true;
 195 }
 196 
 197 void VM_RedefineClasses::doit() {
 198   Thread *thread = Thread::current();
 199 
 200 #if INCLUDE_CDS
 201   if (UseSharedSpaces) {
 202     // Sharing is enabled so we remap the shared readonly space to
 203     // shared readwrite, private just in case we need to redefine
 204     // a shared class. We do the remap during the doit() phase of
 205     // the safepoint to be safer.
 206     if (!MetaspaceShared::remap_shared_readonly_as_readwrite()) {
 207       log_info(redefine, class, load)(&quot;failed to remap shared readonly space to readwrite, private&quot;);
 208       _res = JVMTI_ERROR_INTERNAL;
 209       return;
 210     }
 211   }
 212 #endif
 213 
 214   // Mark methods seen on stack and everywhere else so old methods are not
 215   // cleaned up if they&#39;re on the stack.
 216   MetadataOnStackMark md_on_stack(/*walk_all_metadata*/true, /*redefinition_walk*/true);
 217   HandleMark hm(thread);   // make sure any handles created are deleted
 218                            // before the stack walk again.
 219 
 220   for (int i = 0; i &lt; _class_count; i++) {
 221     redefine_single_class(_class_defs[i].klass, _scratch_classes[i], thread);
 222   }
 223 
 224   // Flush all compiled code that depends on the classes redefined.
 225   flush_dependent_code();
 226 
 227   // Adjust constantpool caches and vtables for all classes
 228   // that reference methods of the evolved classes.
 229   // Have to do this after all classes are redefined and all methods that
 230   // are redefined are marked as old.
 231   AdjustAndCleanMetadata adjust_and_clean_metadata(thread);
 232   ClassLoaderDataGraph::classes_do(&amp;adjust_and_clean_metadata);
 233 
 234   // JSR-292 support
 235   if (_any_class_has_resolved_methods) {
 236     bool trace_name_printed = false;
 237     ResolvedMethodTable::adjust_method_entries(&amp;trace_name_printed);
 238   }
 239 
 240   // Increment flag indicating that some invariants are no longer true.
 241   // See jvmtiExport.hpp for detailed explanation.
 242   JvmtiExport::increment_redefinition_count();
 243 
 244   // check_class() is optionally called for product bits, but is
 245   // always called for non-product bits.
 246 #ifdef PRODUCT
 247   if (log_is_enabled(Trace, redefine, class, obsolete, metadata)) {
 248 #endif
 249     log_trace(redefine, class, obsolete, metadata)(&quot;calling check_class&quot;);
 250     CheckClass check_class(thread);
 251     ClassLoaderDataGraph::classes_do(&amp;check_class);
 252 #ifdef PRODUCT
 253   }
 254 #endif
 255 
 256   // Clean up any metadata now unreferenced while MetadataOnStackMark is set.
 257   ClassLoaderDataGraph::clean_deallocate_lists(false);
 258 }
 259 
 260 void VM_RedefineClasses::doit_epilogue() {
 261   unlock_classes();
 262 
 263   // Free os::malloc allocated memory.
 264   os::free(_scratch_classes);
 265 
 266   // Reset the_class to null for error printing.
 267   _the_class = NULL;
 268 
 269   if (log_is_enabled(Info, redefine, class, timer)) {
 270     // Used to have separate timers for &quot;doit&quot; and &quot;all&quot;, but the timer
 271     // overhead skewed the measurements.
 272     julong doit_time = _timer_rsc_phase1.milliseconds() +
 273                        _timer_rsc_phase2.milliseconds();
 274     julong all_time = _timer_vm_op_prologue.milliseconds() + doit_time;
 275 
 276     log_info(redefine, class, timer)
 277       (&quot;vm_op: all=&quot; JULONG_FORMAT &quot;  prologue=&quot; JULONG_FORMAT &quot;  doit=&quot; JULONG_FORMAT,
 278        all_time, (julong)_timer_vm_op_prologue.milliseconds(), doit_time);
 279     log_info(redefine, class, timer)
 280       (&quot;redefine_single_class: phase1=&quot; JULONG_FORMAT &quot;  phase2=&quot; JULONG_FORMAT,
 281        (julong)_timer_rsc_phase1.milliseconds(), (julong)_timer_rsc_phase2.milliseconds());
 282   }
 283 }
 284 
 285 bool VM_RedefineClasses::is_modifiable_class(oop klass_mirror) {
 286   // classes for primitives cannot be redefined
 287   if (java_lang_Class::is_primitive(klass_mirror)) {
 288     return false;
 289   }
 290   Klass* k = java_lang_Class::as_Klass(klass_mirror);
 291   // classes for arrays cannot be redefined
 292   if (k == NULL || !k-&gt;is_instance_klass()) {
 293     return false;
 294   }
 295 
 296   // Cannot redefine or retransform a hidden or an unsafe anonymous class.
 297   if (InstanceKlass::cast(k)-&gt;is_hidden() ||
 298       InstanceKlass::cast(k)-&gt;is_unsafe_anonymous()) {
 299     return false;
 300   }
 301   return true;
 302 }
 303 
 304 // Append the current entry at scratch_i in scratch_cp to *merge_cp_p
 305 // where the end of *merge_cp_p is specified by *merge_cp_length_p. For
 306 // direct CP entries, there is just the current entry to append. For
 307 // indirect and double-indirect CP entries, there are zero or more
 308 // referenced CP entries along with the current entry to append.
 309 // Indirect and double-indirect CP entries are handled by recursive
 310 // calls to append_entry() as needed. The referenced CP entries are
 311 // always appended to *merge_cp_p before the referee CP entry. These
 312 // referenced CP entries may already exist in *merge_cp_p in which case
 313 // there is nothing extra to append and only the current entry is
 314 // appended.
 315 void VM_RedefineClasses::append_entry(const constantPoolHandle&amp; scratch_cp,
 316        int scratch_i, constantPoolHandle *merge_cp_p, int *merge_cp_length_p,
 317        TRAPS) {
 318 
 319   // append is different depending on entry tag type
 320   switch (scratch_cp-&gt;tag_at(scratch_i).value()) {
 321 
 322     // The old verifier is implemented outside the VM. It loads classes,
 323     // but does not resolve constant pool entries directly so we never
 324     // see Class entries here with the old verifier. Similarly the old
 325     // verifier does not like Class entries in the input constant pool.
 326     // The split-verifier is implemented in the VM so it can optionally
 327     // and directly resolve constant pool entries to load classes. The
 328     // split-verifier can accept either Class entries or UnresolvedClass
 329     // entries in the input constant pool. We revert the appended copy
 330     // back to UnresolvedClass so that either verifier will be happy
 331     // with the constant pool entry.
 332     //
 333     // this is an indirect CP entry so it needs special handling
 334     case JVM_CONSTANT_Class:
 335     case JVM_CONSTANT_UnresolvedClass:
 336     {
 337       int name_i = scratch_cp-&gt;klass_name_index_at(scratch_i);
 338       int new_name_i = find_or_append_indirect_entry(scratch_cp, name_i, merge_cp_p,
 339                                                      merge_cp_length_p, THREAD);
 340 
 341       if (new_name_i != name_i) {
 342         log_trace(redefine, class, constantpool)
 343           (&quot;Class entry@%d name_index change: %d to %d&quot;,
 344            *merge_cp_length_p, name_i, new_name_i);
 345       }
 346 
 347       (*merge_cp_p)-&gt;temp_unresolved_klass_at_put(*merge_cp_length_p, new_name_i);
 348       if (scratch_i != *merge_cp_length_p) {
 349         // The new entry in *merge_cp_p is at a different index than
 350         // the new entry in scratch_cp so we need to map the index values.
 351         map_index(scratch_cp, scratch_i, *merge_cp_length_p);
 352       }
 353       (*merge_cp_length_p)++;
 354     } break;
 355 
 356     // these are direct CP entries so they can be directly appended,
 357     // but double and long take two constant pool entries
 358     case JVM_CONSTANT_Double:  // fall through
 359     case JVM_CONSTANT_Long:
 360     {
 361       ConstantPool::copy_entry_to(scratch_cp, scratch_i, *merge_cp_p, *merge_cp_length_p,
 362         THREAD);
 363 
 364       if (scratch_i != *merge_cp_length_p) {
 365         // The new entry in *merge_cp_p is at a different index than
 366         // the new entry in scratch_cp so we need to map the index values.
 367         map_index(scratch_cp, scratch_i, *merge_cp_length_p);
 368       }
 369       (*merge_cp_length_p) += 2;
 370     } break;
 371 
 372     // these are direct CP entries so they can be directly appended
 373     case JVM_CONSTANT_Float:   // fall through
 374     case JVM_CONSTANT_Integer: // fall through
 375     case JVM_CONSTANT_Utf8:    // fall through
 376 
 377     // This was an indirect CP entry, but it has been changed into
 378     // Symbol*s so this entry can be directly appended.
 379     case JVM_CONSTANT_String:      // fall through
 380     {
 381       ConstantPool::copy_entry_to(scratch_cp, scratch_i, *merge_cp_p, *merge_cp_length_p,
 382         THREAD);
 383 
 384       if (scratch_i != *merge_cp_length_p) {
 385         // The new entry in *merge_cp_p is at a different index than
 386         // the new entry in scratch_cp so we need to map the index values.
 387         map_index(scratch_cp, scratch_i, *merge_cp_length_p);
 388       }
 389       (*merge_cp_length_p)++;
 390     } break;
 391 
 392     // this is an indirect CP entry so it needs special handling
 393     case JVM_CONSTANT_NameAndType:
 394     {
 395       int name_ref_i = scratch_cp-&gt;name_ref_index_at(scratch_i);
 396       int new_name_ref_i = find_or_append_indirect_entry(scratch_cp, name_ref_i, merge_cp_p,
 397                                                          merge_cp_length_p, THREAD);
 398 
 399       int signature_ref_i = scratch_cp-&gt;signature_ref_index_at(scratch_i);
 400       int new_signature_ref_i = find_or_append_indirect_entry(scratch_cp, signature_ref_i,
 401                                                               merge_cp_p, merge_cp_length_p,
 402                                                               THREAD);
 403 
 404       // If the referenced entries already exist in *merge_cp_p, then
 405       // both new_name_ref_i and new_signature_ref_i will both be 0.
 406       // In that case, all we are appending is the current entry.
 407       if (new_name_ref_i != name_ref_i) {
 408         log_trace(redefine, class, constantpool)
 409           (&quot;NameAndType entry@%d name_ref_index change: %d to %d&quot;,
 410            *merge_cp_length_p, name_ref_i, new_name_ref_i);
 411       }
 412       if (new_signature_ref_i != signature_ref_i) {
 413         log_trace(redefine, class, constantpool)
 414           (&quot;NameAndType entry@%d signature_ref_index change: %d to %d&quot;,
 415            *merge_cp_length_p, signature_ref_i, new_signature_ref_i);
 416       }
 417 
 418       (*merge_cp_p)-&gt;name_and_type_at_put(*merge_cp_length_p,
 419         new_name_ref_i, new_signature_ref_i);
 420       if (scratch_i != *merge_cp_length_p) {
 421         // The new entry in *merge_cp_p is at a different index than
 422         // the new entry in scratch_cp so we need to map the index values.
 423         map_index(scratch_cp, scratch_i, *merge_cp_length_p);
 424       }
 425       (*merge_cp_length_p)++;
 426     } break;
 427 
 428     // this is a double-indirect CP entry so it needs special handling
 429     case JVM_CONSTANT_Fieldref:           // fall through
 430     case JVM_CONSTANT_InterfaceMethodref: // fall through
 431     case JVM_CONSTANT_Methodref:
 432     {
 433       int klass_ref_i = scratch_cp-&gt;uncached_klass_ref_index_at(scratch_i);
 434       int new_klass_ref_i = find_or_append_indirect_entry(scratch_cp, klass_ref_i,
 435                                                           merge_cp_p, merge_cp_length_p, THREAD);
 436 
 437       int name_and_type_ref_i = scratch_cp-&gt;uncached_name_and_type_ref_index_at(scratch_i);
 438       int new_name_and_type_ref_i = find_or_append_indirect_entry(scratch_cp, name_and_type_ref_i,
 439                                                           merge_cp_p, merge_cp_length_p, THREAD);
 440 
 441       const char *entry_name = NULL;
 442       switch (scratch_cp-&gt;tag_at(scratch_i).value()) {
 443       case JVM_CONSTANT_Fieldref:
 444         entry_name = &quot;Fieldref&quot;;
 445         (*merge_cp_p)-&gt;field_at_put(*merge_cp_length_p, new_klass_ref_i,
 446           new_name_and_type_ref_i);
 447         break;
 448       case JVM_CONSTANT_InterfaceMethodref:
 449         entry_name = &quot;IFMethodref&quot;;
 450         (*merge_cp_p)-&gt;interface_method_at_put(*merge_cp_length_p,
 451           new_klass_ref_i, new_name_and_type_ref_i);
 452         break;
 453       case JVM_CONSTANT_Methodref:
 454         entry_name = &quot;Methodref&quot;;
 455         (*merge_cp_p)-&gt;method_at_put(*merge_cp_length_p, new_klass_ref_i,
 456           new_name_and_type_ref_i);
 457         break;
 458       default:
 459         guarantee(false, &quot;bad switch&quot;);
 460         break;
 461       }
 462 
 463       if (klass_ref_i != new_klass_ref_i) {
 464         log_trace(redefine, class, constantpool)
 465           (&quot;%s entry@%d class_index changed: %d to %d&quot;, entry_name, *merge_cp_length_p, klass_ref_i, new_klass_ref_i);
 466       }
 467       if (name_and_type_ref_i != new_name_and_type_ref_i) {
 468         log_trace(redefine, class, constantpool)
 469           (&quot;%s entry@%d name_and_type_index changed: %d to %d&quot;,
 470            entry_name, *merge_cp_length_p, name_and_type_ref_i, new_name_and_type_ref_i);
 471       }
 472 
 473       if (scratch_i != *merge_cp_length_p) {
 474         // The new entry in *merge_cp_p is at a different index than
 475         // the new entry in scratch_cp so we need to map the index values.
 476         map_index(scratch_cp, scratch_i, *merge_cp_length_p);
 477       }
 478       (*merge_cp_length_p)++;
 479     } break;
 480 
 481     // this is an indirect CP entry so it needs special handling
 482     case JVM_CONSTANT_MethodType:
 483     {
 484       int ref_i = scratch_cp-&gt;method_type_index_at(scratch_i);
 485       int new_ref_i = find_or_append_indirect_entry(scratch_cp, ref_i, merge_cp_p,
 486                                                     merge_cp_length_p, THREAD);
 487       if (new_ref_i != ref_i) {
 488         log_trace(redefine, class, constantpool)
 489           (&quot;MethodType entry@%d ref_index change: %d to %d&quot;, *merge_cp_length_p, ref_i, new_ref_i);
 490       }
 491       (*merge_cp_p)-&gt;method_type_index_at_put(*merge_cp_length_p, new_ref_i);
 492       if (scratch_i != *merge_cp_length_p) {
 493         // The new entry in *merge_cp_p is at a different index than
 494         // the new entry in scratch_cp so we need to map the index values.
 495         map_index(scratch_cp, scratch_i, *merge_cp_length_p);
 496       }
 497       (*merge_cp_length_p)++;
 498     } break;
 499 
 500     // this is an indirect CP entry so it needs special handling
 501     case JVM_CONSTANT_MethodHandle:
 502     {
 503       int ref_kind = scratch_cp-&gt;method_handle_ref_kind_at(scratch_i);
 504       int ref_i = scratch_cp-&gt;method_handle_index_at(scratch_i);
 505       int new_ref_i = find_or_append_indirect_entry(scratch_cp, ref_i, merge_cp_p,
 506                                                     merge_cp_length_p, THREAD);
 507       if (new_ref_i != ref_i) {
 508         log_trace(redefine, class, constantpool)
 509           (&quot;MethodHandle entry@%d ref_index change: %d to %d&quot;, *merge_cp_length_p, ref_i, new_ref_i);
 510       }
 511       (*merge_cp_p)-&gt;method_handle_index_at_put(*merge_cp_length_p, ref_kind, new_ref_i);
 512       if (scratch_i != *merge_cp_length_p) {
 513         // The new entry in *merge_cp_p is at a different index than
 514         // the new entry in scratch_cp so we need to map the index values.
 515         map_index(scratch_cp, scratch_i, *merge_cp_length_p);
 516       }
 517       (*merge_cp_length_p)++;
 518     } break;
 519 
 520     // this is an indirect CP entry so it needs special handling
 521     case JVM_CONSTANT_Dynamic:  // fall through
 522     case JVM_CONSTANT_InvokeDynamic:
 523     {
 524       // Index of the bootstrap specifier in the operands array
 525       int old_bs_i = scratch_cp-&gt;bootstrap_methods_attribute_index(scratch_i);
 526       int new_bs_i = find_or_append_operand(scratch_cp, old_bs_i, merge_cp_p,
 527                                             merge_cp_length_p, THREAD);
 528       // The bootstrap method NameAndType_info index
 529       int old_ref_i = scratch_cp-&gt;bootstrap_name_and_type_ref_index_at(scratch_i);
 530       int new_ref_i = find_or_append_indirect_entry(scratch_cp, old_ref_i, merge_cp_p,
 531                                                     merge_cp_length_p, THREAD);
 532       if (new_bs_i != old_bs_i) {
 533         log_trace(redefine, class, constantpool)
 534           (&quot;Dynamic entry@%d bootstrap_method_attr_index change: %d to %d&quot;,
 535            *merge_cp_length_p, old_bs_i, new_bs_i);
 536       }
 537       if (new_ref_i != old_ref_i) {
 538         log_trace(redefine, class, constantpool)
 539           (&quot;Dynamic entry@%d name_and_type_index change: %d to %d&quot;, *merge_cp_length_p, old_ref_i, new_ref_i);
 540       }
 541 
 542       if (scratch_cp-&gt;tag_at(scratch_i).is_dynamic_constant())
 543         (*merge_cp_p)-&gt;dynamic_constant_at_put(*merge_cp_length_p, new_bs_i, new_ref_i);
 544       else
 545         (*merge_cp_p)-&gt;invoke_dynamic_at_put(*merge_cp_length_p, new_bs_i, new_ref_i);
 546       if (scratch_i != *merge_cp_length_p) {
 547         // The new entry in *merge_cp_p is at a different index than
 548         // the new entry in scratch_cp so we need to map the index values.
 549         map_index(scratch_cp, scratch_i, *merge_cp_length_p);
 550       }
 551       (*merge_cp_length_p)++;
 552     } break;
 553 
 554     // At this stage, Class or UnresolvedClass could be in scratch_cp, but not
 555     // ClassIndex
 556     case JVM_CONSTANT_ClassIndex: // fall through
 557 
 558     // Invalid is used as the tag for the second constant pool entry
 559     // occupied by JVM_CONSTANT_Double or JVM_CONSTANT_Long. It should
 560     // not be seen by itself.
 561     case JVM_CONSTANT_Invalid: // fall through
 562 
 563     // At this stage, String could be here, but not StringIndex
 564     case JVM_CONSTANT_StringIndex: // fall through
 565 
 566     // At this stage JVM_CONSTANT_UnresolvedClassInError should not be
 567     // here
 568     case JVM_CONSTANT_UnresolvedClassInError: // fall through
 569 
 570     default:
 571     {
 572       // leave a breadcrumb
 573       jbyte bad_value = scratch_cp-&gt;tag_at(scratch_i).value();
 574       ShouldNotReachHere();
 575     } break;
 576   } // end switch tag value
 577 } // end append_entry()
 578 
 579 
 580 int VM_RedefineClasses::find_or_append_indirect_entry(const constantPoolHandle&amp; scratch_cp,
 581       int ref_i, constantPoolHandle *merge_cp_p, int *merge_cp_length_p, TRAPS) {
 582 
 583   int new_ref_i = ref_i;
 584   bool match = (ref_i &lt; *merge_cp_length_p) &amp;&amp;
 585                scratch_cp-&gt;compare_entry_to(ref_i, *merge_cp_p, ref_i, THREAD);
 586 
 587   if (!match) {
 588     // forward reference in *merge_cp_p or not a direct match
 589     int found_i = scratch_cp-&gt;find_matching_entry(ref_i, *merge_cp_p, THREAD);
 590     if (found_i != 0) {
 591       guarantee(found_i != ref_i, &quot;compare_entry_to() and find_matching_entry() do not agree&quot;);
 592       // Found a matching entry somewhere else in *merge_cp_p so just need a mapping entry.
 593       new_ref_i = found_i;
 594       map_index(scratch_cp, ref_i, found_i);
 595     } else {
 596       // no match found so we have to append this entry to *merge_cp_p
 597       append_entry(scratch_cp, ref_i, merge_cp_p, merge_cp_length_p, THREAD);
 598       // The above call to append_entry() can only append one entry
 599       // so the post call query of *merge_cp_length_p is only for
 600       // the sake of consistency.
 601       new_ref_i = *merge_cp_length_p - 1;
 602     }
 603   }
 604 
 605   return new_ref_i;
 606 } // end find_or_append_indirect_entry()
 607 
 608 
 609 // Append a bootstrap specifier into the merge_cp operands that is semantically equal
 610 // to the scratch_cp operands bootstrap specifier passed by the old_bs_i index.
 611 // Recursively append new merge_cp entries referenced by the new bootstrap specifier.
 612 void VM_RedefineClasses::append_operand(const constantPoolHandle&amp; scratch_cp, int old_bs_i,
 613        constantPoolHandle *merge_cp_p, int *merge_cp_length_p, TRAPS) {
 614 
 615   int old_ref_i = scratch_cp-&gt;operand_bootstrap_method_ref_index_at(old_bs_i);
 616   int new_ref_i = find_or_append_indirect_entry(scratch_cp, old_ref_i, merge_cp_p,
 617                                                 merge_cp_length_p, THREAD);
 618   if (new_ref_i != old_ref_i) {
 619     log_trace(redefine, class, constantpool)
 620       (&quot;operands entry@%d bootstrap method ref_index change: %d to %d&quot;, _operands_cur_length, old_ref_i, new_ref_i);
 621   }
 622 
 623   Array&lt;u2&gt;* merge_ops = (*merge_cp_p)-&gt;operands();
 624   int new_bs_i = _operands_cur_length;
 625   // We have _operands_cur_length == 0 when the merge_cp operands is empty yet.
 626   // However, the operand_offset_at(0) was set in the extend_operands() call.
 627   int new_base = (new_bs_i == 0) ? (*merge_cp_p)-&gt;operand_offset_at(0)
 628                                  : (*merge_cp_p)-&gt;operand_next_offset_at(new_bs_i - 1);
 629   int argc     = scratch_cp-&gt;operand_argument_count_at(old_bs_i);
 630 
 631   ConstantPool::operand_offset_at_put(merge_ops, _operands_cur_length, new_base);
 632   merge_ops-&gt;at_put(new_base++, new_ref_i);
 633   merge_ops-&gt;at_put(new_base++, argc);
 634 
 635   for (int i = 0; i &lt; argc; i++) {
 636     int old_arg_ref_i = scratch_cp-&gt;operand_argument_index_at(old_bs_i, i);
 637     int new_arg_ref_i = find_or_append_indirect_entry(scratch_cp, old_arg_ref_i, merge_cp_p,
 638                                                       merge_cp_length_p, THREAD);
 639     merge_ops-&gt;at_put(new_base++, new_arg_ref_i);
 640     if (new_arg_ref_i != old_arg_ref_i) {
 641       log_trace(redefine, class, constantpool)
 642         (&quot;operands entry@%d bootstrap method argument ref_index change: %d to %d&quot;,
 643          _operands_cur_length, old_arg_ref_i, new_arg_ref_i);
 644     }
 645   }
 646   if (old_bs_i != _operands_cur_length) {
 647     // The bootstrap specifier in *merge_cp_p is at a different index than
 648     // that in scratch_cp so we need to map the index values.
 649     map_operand_index(old_bs_i, new_bs_i);
 650   }
 651   _operands_cur_length++;
 652 } // end append_operand()
 653 
 654 
 655 int VM_RedefineClasses::find_or_append_operand(const constantPoolHandle&amp; scratch_cp,
 656       int old_bs_i, constantPoolHandle *merge_cp_p, int *merge_cp_length_p, TRAPS) {
 657 
 658   int new_bs_i = old_bs_i; // bootstrap specifier index
 659   bool match = (old_bs_i &lt; _operands_cur_length) &amp;&amp;
 660                scratch_cp-&gt;compare_operand_to(old_bs_i, *merge_cp_p, old_bs_i, THREAD);
 661 
 662   if (!match) {
 663     // forward reference in *merge_cp_p or not a direct match
 664     int found_i = scratch_cp-&gt;find_matching_operand(old_bs_i, *merge_cp_p,
 665                                                     _operands_cur_length, THREAD);
 666     if (found_i != -1) {
 667       guarantee(found_i != old_bs_i, &quot;compare_operand_to() and find_matching_operand() disagree&quot;);
 668       // found a matching operand somewhere else in *merge_cp_p so just need a mapping
 669       new_bs_i = found_i;
 670       map_operand_index(old_bs_i, found_i);
 671     } else {
 672       // no match found so we have to append this bootstrap specifier to *merge_cp_p
 673       append_operand(scratch_cp, old_bs_i, merge_cp_p, merge_cp_length_p, THREAD);
 674       new_bs_i = _operands_cur_length - 1;
 675     }
 676   }
 677   return new_bs_i;
 678 } // end find_or_append_operand()
 679 
 680 
 681 void VM_RedefineClasses::finalize_operands_merge(const constantPoolHandle&amp; merge_cp, TRAPS) {
 682   if (merge_cp-&gt;operands() == NULL) {
 683     return;
 684   }
 685   // Shrink the merge_cp operands
 686   merge_cp-&gt;shrink_operands(_operands_cur_length, CHECK);
 687 
 688   if (log_is_enabled(Trace, redefine, class, constantpool)) {
 689     // don&#39;t want to loop unless we are tracing
 690     int count = 0;
 691     for (int i = 1; i &lt; _operands_index_map_p-&gt;length(); i++) {
 692       int value = _operands_index_map_p-&gt;at(i);
 693       if (value != -1) {
 694         log_trace(redefine, class, constantpool)(&quot;operands_index_map[%d]: old=%d new=%d&quot;, count, i, value);
 695         count++;
 696       }
 697     }
 698   }
 699   // Clean-up
 700   _operands_index_map_p = NULL;
 701   _operands_cur_length = 0;
 702   _operands_index_map_count = 0;
 703 } // end finalize_operands_merge()
 704 
 705 // Symbol* comparator for qsort
 706 // The caller must have an active ResourceMark.
 707 static int symcmp(const void* a, const void* b) {
 708   char* astr = (*(Symbol**)a)-&gt;as_C_string();
 709   char* bstr = (*(Symbol**)b)-&gt;as_C_string();
 710   return strcmp(astr, bstr);
 711 }
 712 
 713 static jvmtiError check_nest_attributes(InstanceKlass* the_class,
 714                                         InstanceKlass* scratch_class) {
 715   // Check whether the class NestHost attribute has been changed.
 716   Thread* thread = Thread::current();
 717   ResourceMark rm(thread);
 718   u2 the_nest_host_idx = the_class-&gt;nest_host_index();
 719   u2 scr_nest_host_idx = scratch_class-&gt;nest_host_index();
 720 
 721   if (the_nest_host_idx != 0 &amp;&amp; scr_nest_host_idx != 0) {
 722     Symbol* the_sym = the_class-&gt;constants()-&gt;klass_name_at(the_nest_host_idx);
 723     Symbol* scr_sym = scratch_class-&gt;constants()-&gt;klass_name_at(scr_nest_host_idx);
 724     if (the_sym != scr_sym) {
 725       log_trace(redefine, class, nestmates)
 726         (&quot;redefined class %s attribute change error: NestHost class: %s replaced with: %s&quot;,
 727          the_class-&gt;external_name(), the_sym-&gt;as_C_string(), scr_sym-&gt;as_C_string());
 728       return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
 729     }
 730   } else if ((the_nest_host_idx == 0) ^ (scr_nest_host_idx == 0)) {
 731     const char* action_str = (the_nest_host_idx != 0) ? &quot;removed&quot; : &quot;added&quot;;
 732     log_trace(redefine, class, nestmates)
 733       (&quot;redefined class %s attribute change error: NestHost attribute %s&quot;,
 734        the_class-&gt;external_name(), action_str);
 735     return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
 736   }
 737 
 738   // Check whether the class NestMembers attribute has been changed.
 739   Array&lt;u2&gt;* the_nest_members = the_class-&gt;nest_members();
 740   Array&lt;u2&gt;* scr_nest_members = scratch_class-&gt;nest_members();
 741   bool the_members_exists = the_nest_members != Universe::the_empty_short_array();
 742   bool scr_members_exists = scr_nest_members != Universe::the_empty_short_array();
 743 
 744   int members_len = the_nest_members-&gt;length();
 745   if (the_members_exists &amp;&amp; scr_members_exists) {
 746     if (members_len != scr_nest_members-&gt;length()) {
 747       log_trace(redefine, class, nestmates)
 748         (&quot;redefined class %s attribute change error: NestMember len=%d changed to len=%d&quot;,
 749          the_class-&gt;external_name(), members_len, scr_nest_members-&gt;length());
 750       return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
 751     }
 752 
 753     // The order of entries in the NestMembers array is not specified so we
 754     // have to explicitly check for the same contents. We do this by copying
 755     // the referenced symbols into their own arrays, sorting them and then
 756     // comparing each element pair.
 757 
 758     Symbol** the_syms = NEW_RESOURCE_ARRAY_RETURN_NULL(Symbol*, members_len);
 759     Symbol** scr_syms = NEW_RESOURCE_ARRAY_RETURN_NULL(Symbol*, members_len);
 760 
 761     if (the_syms == NULL || scr_syms == NULL) {
 762       return JVMTI_ERROR_OUT_OF_MEMORY;
 763     }
 764 
 765     for (int i = 0; i &lt; members_len; i++) {
 766       int the_cp_index = the_nest_members-&gt;at(i);
 767       int scr_cp_index = scr_nest_members-&gt;at(i);
 768       the_syms[i] = the_class-&gt;constants()-&gt;klass_name_at(the_cp_index);
 769       scr_syms[i] = scratch_class-&gt;constants()-&gt;klass_name_at(scr_cp_index);
 770     }
 771 
 772     qsort(the_syms, members_len, sizeof(Symbol*), symcmp);
 773     qsort(scr_syms, members_len, sizeof(Symbol*), symcmp);
 774 
 775     for (int i = 0; i &lt; members_len; i++) {
 776       if (the_syms[i] != scr_syms[i]) {
 777         log_trace(redefine, class, nestmates)
 778           (&quot;redefined class %s attribute change error: NestMembers[%d]: %s changed to %s&quot;,
 779            the_class-&gt;external_name(), i, the_syms[i]-&gt;as_C_string(), scr_syms[i]-&gt;as_C_string());
 780         return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
 781       }
 782     }
 783   } else if (the_members_exists ^ scr_members_exists) {
 784     const char* action_str = (the_members_exists) ? &quot;removed&quot; : &quot;added&quot;;
 785     log_trace(redefine, class, nestmates)
 786       (&quot;redefined class %s attribute change error: NestMembers attribute %s&quot;,
 787        the_class-&gt;external_name(), action_str);
 788     return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
 789   }
 790 
 791   return JVMTI_ERROR_NONE;
 792 }
 793 
 794 // Return an error status if the class Record attribute was changed.
 795 static jvmtiError check_record_attribute(InstanceKlass* the_class, InstanceKlass* scratch_class) {
 796   // Get lists of record components.
 797   Array&lt;RecordComponent*&gt;* the_record = the_class-&gt;record_components();
 798   Array&lt;RecordComponent*&gt;* scr_record = scratch_class-&gt;record_components();
 799   bool the_record_exists = the_record != NULL;
 800   bool scr_record_exists = scr_record != NULL;
 801 
 802   if (the_record_exists &amp;&amp; scr_record_exists) {
 803     int the_num_components = the_record-&gt;length();
 804     int scr_num_components = scr_record-&gt;length();
 805     if (the_num_components != scr_num_components) {
 806       log_trace(redefine, class, record)
 807         (&quot;redefined class %s attribute change error: Record num_components=%d changed to num_components=%d&quot;,
 808          the_class-&gt;external_name(), the_num_components, scr_num_components);
 809       return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
 810     }
 811 
 812     // Compare each field in each record component.
 813     ConstantPool* the_cp =  the_class-&gt;constants();
 814     ConstantPool* scr_cp =  scratch_class-&gt;constants();
 815     for (int x = 0; x &lt; the_num_components; x++) {
 816       RecordComponent* the_component = the_record-&gt;at(x);
 817       RecordComponent* scr_component = scr_record-&gt;at(x);
 818       const Symbol* const the_name = the_cp-&gt;symbol_at(the_component-&gt;name_index());
 819       const Symbol* const scr_name = scr_cp-&gt;symbol_at(scr_component-&gt;name_index());
 820       const Symbol* const the_descr = the_cp-&gt;symbol_at(the_component-&gt;descriptor_index());
 821       const Symbol* const scr_descr = scr_cp-&gt;symbol_at(scr_component-&gt;descriptor_index());
 822       if (the_name != scr_name || the_descr != scr_descr) {
 823         log_trace(redefine, class, record)
 824           (&quot;redefined class %s attribute change error: Record name_index, descriptor_index, and/or attributes_count changed&quot;,
 825            the_class-&gt;external_name());
 826         return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
 827       }
 828 
 829       int the_gen_sig = the_component-&gt;generic_signature_index();
 830       int scr_gen_sig = scr_component-&gt;generic_signature_index();
 831       const Symbol* const the_gen_sig_sym = (the_gen_sig == 0 ? NULL :
 832         the_cp-&gt;symbol_at(the_component-&gt;generic_signature_index()));
 833       const Symbol* const scr_gen_sig_sym = (scr_gen_sig == 0 ? NULL :
 834         scr_cp-&gt;symbol_at(scr_component-&gt;generic_signature_index()));
 835       if (the_gen_sig_sym != scr_gen_sig_sym) {
 836         log_trace(redefine, class, record)
 837           (&quot;redefined class %s attribute change error: Record generic_signature attribute changed&quot;,
 838            the_class-&gt;external_name());
 839         return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
 840       }
 841 
 842       // It&#39;s okay if a record component&#39;s annotations were changed.
 843     }
 844 
 845   } else if (the_record_exists ^ scr_record_exists) {
 846     const char* action_str = (the_record_exists) ? &quot;removed&quot; : &quot;added&quot;;
 847     log_trace(redefine, class, record)
 848       (&quot;redefined class %s attribute change error: Record attribute %s&quot;,
 849        the_class-&gt;external_name(), action_str);
 850     return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
 851   }
 852 
 853   return JVMTI_ERROR_NONE;
 854 }
 855 
 856 
 857 static jvmtiError check_permitted_subclasses_attribute(InstanceKlass* the_class,
<a name="1" id="anc1"></a><span class="line-modified"> 858                                                      InstanceKlass* scratch_class) {</span>
 859   // Check whether the class PermittedSubclasses attribute has been changed.
<a name="2" id="anc2"></a>

 860   Array&lt;u2&gt;* the_permitted_subclasses = the_class-&gt;permitted_subclasses();
 861   Array&lt;u2&gt;* scr_permitted_subclasses = scratch_class-&gt;permitted_subclasses();
 862   bool the_subclasses_exist = the_permitted_subclasses != Universe::the_empty_short_array();
 863   bool scr_subclasses_exist = scr_permitted_subclasses != Universe::the_empty_short_array();
 864   int subclasses_len = the_permitted_subclasses-&gt;length();
 865   if (the_subclasses_exist &amp;&amp; scr_subclasses_exist) {
 866     if (subclasses_len != scr_permitted_subclasses-&gt;length()) {
 867       log_trace(redefine, class, sealed)
 868         (&quot;redefined class %s attribute change error: PermittedSubclasses len=%d changed to len=%d&quot;,
 869          the_class-&gt;external_name(), subclasses_len, scr_permitted_subclasses-&gt;length());
 870       return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
 871     }
 872 
 873     // The order of entries in the PermittedSubclasses array is not specified so
 874     // we have to explicitly check for the same contents. We do this by copying
 875     // the referenced symbols into their own arrays, sorting them and then
 876     // comparing each element pair.
 877 
 878     Symbol** the_syms = NEW_RESOURCE_ARRAY_RETURN_NULL(Symbol*, subclasses_len);
 879     Symbol** scr_syms = NEW_RESOURCE_ARRAY_RETURN_NULL(Symbol*, subclasses_len);
 880 
 881     if (the_syms == NULL || scr_syms == NULL) {
 882       return JVMTI_ERROR_OUT_OF_MEMORY;
 883     }
 884 
 885     for (int i = 0; i &lt; subclasses_len; i++) {
 886       int the_cp_index = the_permitted_subclasses-&gt;at(i);
 887       int scr_cp_index = scr_permitted_subclasses-&gt;at(i);
 888       the_syms[i] = the_class-&gt;constants()-&gt;klass_name_at(the_cp_index);
 889       scr_syms[i] = scratch_class-&gt;constants()-&gt;klass_name_at(scr_cp_index);
 890     }
 891 
 892     qsort(the_syms, subclasses_len, sizeof(Symbol*), symcmp);
 893     qsort(scr_syms, subclasses_len, sizeof(Symbol*), symcmp);
 894 
 895     for (int i = 0; i &lt; subclasses_len; i++) {
 896       if (the_syms[i] != scr_syms[i]) {
 897         log_trace(redefine, class, sealed)
 898           (&quot;redefined class %s attribute change error: PermittedSubclasses[%d]: %s changed to %s&quot;,
 899            the_class-&gt;external_name(), i, the_syms[i]-&gt;as_C_string(), scr_syms[i]-&gt;as_C_string());
 900         return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
 901       }
 902     }
 903   } else if (the_subclasses_exist ^ scr_subclasses_exist) {
 904     const char* action_str = (the_subclasses_exist) ? &quot;removed&quot; : &quot;added&quot;;
 905     log_trace(redefine, class, sealed)
 906       (&quot;redefined class %s attribute change error: PermittedSubclasses attribute %s&quot;,
 907        the_class-&gt;external_name(), action_str);
 908     return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
 909   }
 910 
 911   return JVMTI_ERROR_NONE;
 912 }
 913 
 914 static bool can_add_or_delete(Method* m) {
 915       // Compatibility mode
 916   return (AllowRedefinitionToAddDeleteMethods &amp;&amp;
 917           (m-&gt;is_private() &amp;&amp; (m-&gt;is_static() || m-&gt;is_final())));
 918 }
 919 
 920 jvmtiError VM_RedefineClasses::compare_and_normalize_class_versions(
 921              InstanceKlass* the_class,
 922              InstanceKlass* scratch_class) {
 923   int i;
 924 
 925   // Check superclasses, or rather their names, since superclasses themselves can be
 926   // requested to replace.
 927   // Check for NULL superclass first since this might be java.lang.Object
 928   if (the_class-&gt;super() != scratch_class-&gt;super() &amp;&amp;
 929       (the_class-&gt;super() == NULL || scratch_class-&gt;super() == NULL ||
 930        the_class-&gt;super()-&gt;name() !=
 931        scratch_class-&gt;super()-&gt;name())) {
 932     return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_HIERARCHY_CHANGED;
 933   }
 934 
 935   // Check if the number, names and order of directly implemented interfaces are the same.
 936   // I think in principle we should just check if the sets of names of directly implemented
 937   // interfaces are the same, i.e. the order of declaration (which, however, if changed in the
 938   // .java file, also changes in .class file) should not matter. However, comparing sets is
 939   // technically a bit more difficult, and, more importantly, I am not sure at present that the
 940   // order of interfaces does not matter on the implementation level, i.e. that the VM does not
 941   // rely on it somewhere.
 942   Array&lt;InstanceKlass*&gt;* k_interfaces = the_class-&gt;local_interfaces();
 943   Array&lt;InstanceKlass*&gt;* k_new_interfaces = scratch_class-&gt;local_interfaces();
 944   int n_intfs = k_interfaces-&gt;length();
 945   if (n_intfs != k_new_interfaces-&gt;length()) {
 946     return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_HIERARCHY_CHANGED;
 947   }
 948   for (i = 0; i &lt; n_intfs; i++) {
 949     if (k_interfaces-&gt;at(i)-&gt;name() !=
 950         k_new_interfaces-&gt;at(i)-&gt;name()) {
 951       return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_HIERARCHY_CHANGED;
 952     }
 953   }
 954 
 955   // Check whether class is in the error init state.
 956   if (the_class-&gt;is_in_error_state()) {
 957     // TBD #5057930: special error code is needed in 1.6
 958     return JVMTI_ERROR_INVALID_CLASS;
 959   }
 960 
 961   // Check whether the nest-related attributes have been changed.
 962   jvmtiError err = check_nest_attributes(the_class, scratch_class);
 963   if (err != JVMTI_ERROR_NONE) {
 964     return err;
 965   }
 966 
 967   // Check whether the Record attribute has been changed.
 968   err = check_record_attribute(the_class, scratch_class);
 969   if (err != JVMTI_ERROR_NONE) {
 970     return err;
 971   }
 972 
 973   // Check whether the PermittedSubclasses attribute has been changed.
 974   err = check_permitted_subclasses_attribute(the_class, scratch_class);
 975   if (err != JVMTI_ERROR_NONE) {
 976     return err;
 977   }
 978 
 979   // Check whether class modifiers are the same.
 980   jushort old_flags = (jushort) the_class-&gt;access_flags().get_flags();
 981   jushort new_flags = (jushort) scratch_class-&gt;access_flags().get_flags();
 982   if (old_flags != new_flags) {
 983     return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_MODIFIERS_CHANGED;
 984   }
 985 
 986   // Check if the number, names, types and order of fields declared in these classes
 987   // are the same.
 988   JavaFieldStream old_fs(the_class);
 989   JavaFieldStream new_fs(scratch_class);
 990   for (; !old_fs.done() &amp;&amp; !new_fs.done(); old_fs.next(), new_fs.next()) {
 991     // access
 992     old_flags = old_fs.access_flags().as_short();
 993     new_flags = new_fs.access_flags().as_short();
 994     if ((old_flags ^ new_flags) &amp; JVM_RECOGNIZED_FIELD_MODIFIERS) {
 995       return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_SCHEMA_CHANGED;
 996     }
 997     // offset
 998     if (old_fs.offset() != new_fs.offset()) {
 999       return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_SCHEMA_CHANGED;
1000     }
1001     // name and signature
1002     Symbol* name_sym1 = the_class-&gt;constants()-&gt;symbol_at(old_fs.name_index());
1003     Symbol* sig_sym1 = the_class-&gt;constants()-&gt;symbol_at(old_fs.signature_index());
1004     Symbol* name_sym2 = scratch_class-&gt;constants()-&gt;symbol_at(new_fs.name_index());
1005     Symbol* sig_sym2 = scratch_class-&gt;constants()-&gt;symbol_at(new_fs.signature_index());
1006     if (name_sym1 != name_sym2 || sig_sym1 != sig_sym2) {
1007       return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_SCHEMA_CHANGED;
1008     }
1009   }
1010 
1011   // If both streams aren&#39;t done then we have a differing number of
1012   // fields.
1013   if (!old_fs.done() || !new_fs.done()) {
1014     return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_SCHEMA_CHANGED;
1015   }
1016 
1017   // Do a parallel walk through the old and new methods. Detect
1018   // cases where they match (exist in both), have been added in
1019   // the new methods, or have been deleted (exist only in the
1020   // old methods).  The class file parser places methods in order
1021   // by method name, but does not order overloaded methods by
1022   // signature.  In order to determine what fate befell the methods,
1023   // this code places the overloaded new methods that have matching
1024   // old methods in the same order as the old methods and places
1025   // new overloaded methods at the end of overloaded methods of
1026   // that name. The code for this order normalization is adapted
1027   // from the algorithm used in InstanceKlass::find_method().
1028   // Since we are swapping out of order entries as we find them,
1029   // we only have to search forward through the overloaded methods.
1030   // Methods which are added and have the same name as an existing
1031   // method (but different signature) will be put at the end of
1032   // the methods with that name, and the name mismatch code will
1033   // handle them.
1034   Array&lt;Method*&gt;* k_old_methods(the_class-&gt;methods());
1035   Array&lt;Method*&gt;* k_new_methods(scratch_class-&gt;methods());
1036   int n_old_methods = k_old_methods-&gt;length();
1037   int n_new_methods = k_new_methods-&gt;length();
1038   Thread* thread = Thread::current();
1039 
1040   int ni = 0;
1041   int oi = 0;
1042   while (true) {
1043     Method* k_old_method;
1044     Method* k_new_method;
1045     enum { matched, added, deleted, undetermined } method_was = undetermined;
1046 
1047     if (oi &gt;= n_old_methods) {
1048       if (ni &gt;= n_new_methods) {
1049         break; // we&#39;ve looked at everything, done
1050       }
1051       // New method at the end
1052       k_new_method = k_new_methods-&gt;at(ni);
1053       method_was = added;
1054     } else if (ni &gt;= n_new_methods) {
1055       // Old method, at the end, is deleted
1056       k_old_method = k_old_methods-&gt;at(oi);
1057       method_was = deleted;
1058     } else {
1059       // There are more methods in both the old and new lists
1060       k_old_method = k_old_methods-&gt;at(oi);
1061       k_new_method = k_new_methods-&gt;at(ni);
1062       if (k_old_method-&gt;name() != k_new_method-&gt;name()) {
1063         // Methods are sorted by method name, so a mismatch means added
1064         // or deleted
1065         if (k_old_method-&gt;name()-&gt;fast_compare(k_new_method-&gt;name()) &gt; 0) {
1066           method_was = added;
1067         } else {
1068           method_was = deleted;
1069         }
1070       } else if (k_old_method-&gt;signature() == k_new_method-&gt;signature()) {
1071         // Both the name and signature match
1072         method_was = matched;
1073       } else {
1074         // The name matches, but the signature doesn&#39;t, which means we have to
1075         // search forward through the new overloaded methods.
1076         int nj;  // outside the loop for post-loop check
1077         for (nj = ni + 1; nj &lt; n_new_methods; nj++) {
1078           Method* m = k_new_methods-&gt;at(nj);
1079           if (k_old_method-&gt;name() != m-&gt;name()) {
1080             // reached another method name so no more overloaded methods
1081             method_was = deleted;
1082             break;
1083           }
1084           if (k_old_method-&gt;signature() == m-&gt;signature()) {
1085             // found a match so swap the methods
1086             k_new_methods-&gt;at_put(ni, m);
1087             k_new_methods-&gt;at_put(nj, k_new_method);
1088             k_new_method = m;
1089             method_was = matched;
1090             break;
1091           }
1092         }
1093 
1094         if (nj &gt;= n_new_methods) {
1095           // reached the end without a match; so method was deleted
1096           method_was = deleted;
1097         }
1098       }
1099     }
1100 
1101     switch (method_was) {
1102     case matched:
1103       // methods match, be sure modifiers do too
1104       old_flags = (jushort) k_old_method-&gt;access_flags().get_flags();
1105       new_flags = (jushort) k_new_method-&gt;access_flags().get_flags();
1106       if ((old_flags ^ new_flags) &amp; ~(JVM_ACC_NATIVE)) {
1107         return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_MODIFIERS_CHANGED;
1108       }
1109       {
1110         u2 new_num = k_new_method-&gt;method_idnum();
1111         u2 old_num = k_old_method-&gt;method_idnum();
1112         if (new_num != old_num) {
1113           Method* idnum_owner = scratch_class-&gt;method_with_idnum(old_num);
1114           if (idnum_owner != NULL) {
1115             // There is already a method assigned this idnum -- switch them
1116             // Take current and original idnum from the new_method
1117             idnum_owner-&gt;set_method_idnum(new_num);
1118             idnum_owner-&gt;set_orig_method_idnum(k_new_method-&gt;orig_method_idnum());
1119           }
1120           // Take current and original idnum from the old_method
1121           k_new_method-&gt;set_method_idnum(old_num);
1122           k_new_method-&gt;set_orig_method_idnum(k_old_method-&gt;orig_method_idnum());
1123           if (thread-&gt;has_pending_exception()) {
1124             return JVMTI_ERROR_OUT_OF_MEMORY;
1125           }
1126         }
1127       }
1128       log_trace(redefine, class, normalize)
1129         (&quot;Method matched: new: %s [%d] == old: %s [%d]&quot;,
1130          k_new_method-&gt;name_and_sig_as_C_string(), ni, k_old_method-&gt;name_and_sig_as_C_string(), oi);
1131       // advance to next pair of methods
1132       ++oi;
1133       ++ni;
1134       break;
1135     case added:
1136       // method added, see if it is OK
1137       if (!can_add_or_delete(k_new_method)) {
1138         return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_ADDED;
1139       }
1140       {
1141         u2 num = the_class-&gt;next_method_idnum();
1142         if (num == ConstMethod::UNSET_IDNUM) {
1143           // cannot add any more methods
1144           return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_ADDED;
1145         }
1146         u2 new_num = k_new_method-&gt;method_idnum();
1147         Method* idnum_owner = scratch_class-&gt;method_with_idnum(num);
1148         if (idnum_owner != NULL) {
1149           // There is already a method assigned this idnum -- switch them
1150           // Take current and original idnum from the new_method
1151           idnum_owner-&gt;set_method_idnum(new_num);
1152           idnum_owner-&gt;set_orig_method_idnum(k_new_method-&gt;orig_method_idnum());
1153         }
1154         k_new_method-&gt;set_method_idnum(num);
1155         k_new_method-&gt;set_orig_method_idnum(num);
1156         if (thread-&gt;has_pending_exception()) {
1157           return JVMTI_ERROR_OUT_OF_MEMORY;
1158         }
1159       }
1160       log_trace(redefine, class, normalize)
1161         (&quot;Method added: new: %s [%d]&quot;, k_new_method-&gt;name_and_sig_as_C_string(), ni);
1162       ++ni; // advance to next new method
1163       break;
1164     case deleted:
1165       // method deleted, see if it is OK
1166       if (!can_add_or_delete(k_old_method)) {
1167         return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_DELETED;
1168       }
1169       log_trace(redefine, class, normalize)
1170         (&quot;Method deleted: old: %s [%d]&quot;, k_old_method-&gt;name_and_sig_as_C_string(), oi);
1171       ++oi; // advance to next old method
1172       break;
1173     default:
1174       ShouldNotReachHere();
1175     }
1176   }
1177 
1178   return JVMTI_ERROR_NONE;
1179 }
1180 
1181 
1182 // Find new constant pool index value for old constant pool index value
1183 // by seaching the index map. Returns zero (0) if there is no mapped
1184 // value for the old constant pool index.
1185 int VM_RedefineClasses::find_new_index(int old_index) {
1186   if (_index_map_count == 0) {
1187     // map is empty so nothing can be found
1188     return 0;
1189   }
1190 
1191   if (old_index &lt; 1 || old_index &gt;= _index_map_p-&gt;length()) {
1192     // The old_index is out of range so it is not mapped. This should
1193     // not happen in regular constant pool merging use, but it can
1194     // happen if a corrupt annotation is processed.
1195     return 0;
1196   }
1197 
1198   int value = _index_map_p-&gt;at(old_index);
1199   if (value == -1) {
1200     // the old_index is not mapped
1201     return 0;
1202   }
1203 
1204   return value;
1205 } // end find_new_index()
1206 
1207 
1208 // Find new bootstrap specifier index value for old bootstrap specifier index
1209 // value by seaching the index map. Returns unused index (-1) if there is
1210 // no mapped value for the old bootstrap specifier index.
1211 int VM_RedefineClasses::find_new_operand_index(int old_index) {
1212   if (_operands_index_map_count == 0) {
1213     // map is empty so nothing can be found
1214     return -1;
1215   }
1216 
1217   if (old_index == -1 || old_index &gt;= _operands_index_map_p-&gt;length()) {
1218     // The old_index is out of range so it is not mapped.
1219     // This should not happen in regular constant pool merging use.
1220     return -1;
1221   }
1222 
1223   int value = _operands_index_map_p-&gt;at(old_index);
1224   if (value == -1) {
1225     // the old_index is not mapped
1226     return -1;
1227   }
1228 
1229   return value;
1230 } // end find_new_operand_index()
1231 
1232 
1233 // Returns true if the current mismatch is due to a resolved/unresolved
1234 // class pair. Otherwise, returns false.
1235 bool VM_RedefineClasses::is_unresolved_class_mismatch(const constantPoolHandle&amp; cp1,
1236        int index1, const constantPoolHandle&amp; cp2, int index2) {
1237 
1238   jbyte t1 = cp1-&gt;tag_at(index1).value();
1239   if (t1 != JVM_CONSTANT_Class &amp;&amp; t1 != JVM_CONSTANT_UnresolvedClass) {
1240     return false;  // wrong entry type; not our special case
1241   }
1242 
1243   jbyte t2 = cp2-&gt;tag_at(index2).value();
1244   if (t2 != JVM_CONSTANT_Class &amp;&amp; t2 != JVM_CONSTANT_UnresolvedClass) {
1245     return false;  // wrong entry type; not our special case
1246   }
1247 
1248   if (t1 == t2) {
1249     return false;  // not a mismatch; not our special case
1250   }
1251 
1252   char *s1 = cp1-&gt;klass_name_at(index1)-&gt;as_C_string();
1253   char *s2 = cp2-&gt;klass_name_at(index2)-&gt;as_C_string();
1254   if (strcmp(s1, s2) != 0) {
1255     return false;  // strings don&#39;t match; not our special case
1256   }
1257 
1258   return true;  // made it through the gauntlet; this is our special case
1259 } // end is_unresolved_class_mismatch()
1260 
1261 
1262 jvmtiError VM_RedefineClasses::load_new_class_versions(TRAPS) {
1263 
1264   // For consistency allocate memory using os::malloc wrapper.
1265   _scratch_classes = (InstanceKlass**)
1266     os::malloc(sizeof(InstanceKlass*) * _class_count, mtClass);
1267   if (_scratch_classes == NULL) {
1268     return JVMTI_ERROR_OUT_OF_MEMORY;
1269   }
1270   // Zero initialize the _scratch_classes array.
1271   for (int i = 0; i &lt; _class_count; i++) {
1272     _scratch_classes[i] = NULL;
1273   }
1274 
1275   ResourceMark rm(THREAD);
1276 
1277   JvmtiThreadState *state = JvmtiThreadState::state_for(JavaThread::current());
1278   // state can only be NULL if the current thread is exiting which
1279   // should not happen since we&#39;re trying to do a RedefineClasses
1280   guarantee(state != NULL, &quot;exiting thread calling load_new_class_versions&quot;);
1281   for (int i = 0; i &lt; _class_count; i++) {
1282     // Create HandleMark so that any handles created while loading new class
1283     // versions are deleted. Constant pools are deallocated while merging
1284     // constant pools
1285     HandleMark hm(THREAD);
1286     InstanceKlass* the_class = get_ik(_class_defs[i].klass);
1287     Symbol*  the_class_sym = the_class-&gt;name();
1288 
1289     log_debug(redefine, class, load)
1290       (&quot;loading name=%s kind=%d (avail_mem=&quot; UINT64_FORMAT &quot;K)&quot;,
1291        the_class-&gt;external_name(), _class_load_kind, os::available_memory() &gt;&gt; 10);
1292 
1293     ClassFileStream st((u1*)_class_defs[i].class_bytes,
1294                        _class_defs[i].class_byte_count,
1295                        &quot;__VM_RedefineClasses__&quot;,
1296                        ClassFileStream::verify);
1297 
1298     // Parse the stream.
1299     Handle the_class_loader(THREAD, the_class-&gt;class_loader());
1300     Handle protection_domain(THREAD, the_class-&gt;protection_domain());
1301     // Set redefined class handle in JvmtiThreadState class.
1302     // This redefined class is sent to agent event handler for class file
1303     // load hook event.
1304     state-&gt;set_class_being_redefined(the_class, _class_load_kind);
1305 
1306     ClassLoadInfo cl_info(protection_domain);
1307     InstanceKlass* scratch_class = SystemDictionary::parse_stream(
1308                                                       the_class_sym,
1309                                                       the_class_loader,
1310                                                       &amp;st,
1311                                                       cl_info,
1312                                                       THREAD);
1313     // Clear class_being_redefined just to be sure.
1314     state-&gt;clear_class_being_redefined();
1315 
1316     // TODO: if this is retransform, and nothing changed we can skip it
1317 
1318     // Need to clean up allocated InstanceKlass if there&#39;s an error so assign
1319     // the result here. Caller deallocates all the scratch classes in case of
1320     // an error.
1321     _scratch_classes[i] = scratch_class;
1322 
1323     if (HAS_PENDING_EXCEPTION) {
1324       Symbol* ex_name = PENDING_EXCEPTION-&gt;klass()-&gt;name();
1325       log_info(redefine, class, load, exceptions)(&quot;parse_stream exception: &#39;%s&#39;&quot;, ex_name-&gt;as_C_string());
1326       CLEAR_PENDING_EXCEPTION;
1327 
1328       if (ex_name == vmSymbols::java_lang_UnsupportedClassVersionError()) {
1329         return JVMTI_ERROR_UNSUPPORTED_VERSION;
1330       } else if (ex_name == vmSymbols::java_lang_ClassFormatError()) {
1331         return JVMTI_ERROR_INVALID_CLASS_FORMAT;
1332       } else if (ex_name == vmSymbols::java_lang_ClassCircularityError()) {
1333         return JVMTI_ERROR_CIRCULAR_CLASS_DEFINITION;
1334       } else if (ex_name == vmSymbols::java_lang_NoClassDefFoundError()) {
1335         // The message will be &quot;XXX (wrong name: YYY)&quot;
1336         return JVMTI_ERROR_NAMES_DONT_MATCH;
1337       } else if (ex_name == vmSymbols::java_lang_OutOfMemoryError()) {
1338         return JVMTI_ERROR_OUT_OF_MEMORY;
1339       } else {  // Just in case more exceptions can be thrown..
1340         return JVMTI_ERROR_FAILS_VERIFICATION;
1341       }
1342     }
1343 
1344     // Ensure class is linked before redefine
1345     if (!the_class-&gt;is_linked()) {
1346       the_class-&gt;link_class(THREAD);
1347       if (HAS_PENDING_EXCEPTION) {
1348         Symbol* ex_name = PENDING_EXCEPTION-&gt;klass()-&gt;name();
1349         log_info(redefine, class, load, exceptions)(&quot;link_class exception: &#39;%s&#39;&quot;, ex_name-&gt;as_C_string());
1350         CLEAR_PENDING_EXCEPTION;
1351         if (ex_name == vmSymbols::java_lang_OutOfMemoryError()) {
1352           return JVMTI_ERROR_OUT_OF_MEMORY;
1353         } else {
1354           return JVMTI_ERROR_INTERNAL;
1355         }
1356       }
1357     }
1358 
1359     // Do the validity checks in compare_and_normalize_class_versions()
1360     // before verifying the byte codes. By doing these checks first, we
1361     // limit the number of functions that require redirection from
1362     // the_class to scratch_class. In particular, we don&#39;t have to
1363     // modify JNI GetSuperclass() and thus won&#39;t change its performance.
1364     jvmtiError res = compare_and_normalize_class_versions(the_class,
1365                        scratch_class);
1366     if (res != JVMTI_ERROR_NONE) {
1367       return res;
1368     }
1369 
1370     // verify what the caller passed us
1371     {
1372       // The bug 6214132 caused the verification to fail.
1373       // Information about the_class and scratch_class is temporarily
1374       // recorded into jvmtiThreadState. This data is used to redirect
1375       // the_class to scratch_class in the JVM_* functions called by the
1376       // verifier. Please, refer to jvmtiThreadState.hpp for the detailed
1377       // description.
1378       RedefineVerifyMark rvm(the_class, scratch_class, state);
1379       Verifier::verify(scratch_class, true, THREAD);
1380     }
1381 
1382     if (HAS_PENDING_EXCEPTION) {
1383       Symbol* ex_name = PENDING_EXCEPTION-&gt;klass()-&gt;name();
1384       log_info(redefine, class, load, exceptions)(&quot;verify_byte_codes exception: &#39;%s&#39;&quot;, ex_name-&gt;as_C_string());
1385       CLEAR_PENDING_EXCEPTION;
1386       if (ex_name == vmSymbols::java_lang_OutOfMemoryError()) {
1387         return JVMTI_ERROR_OUT_OF_MEMORY;
1388       } else {
1389         // tell the caller the bytecodes are bad
1390         return JVMTI_ERROR_FAILS_VERIFICATION;
1391       }
1392     }
1393 
1394     res = merge_cp_and_rewrite(the_class, scratch_class, THREAD);
1395     if (HAS_PENDING_EXCEPTION) {
1396       Symbol* ex_name = PENDING_EXCEPTION-&gt;klass()-&gt;name();
1397       log_info(redefine, class, load, exceptions)(&quot;merge_cp_and_rewrite exception: &#39;%s&#39;&quot;, ex_name-&gt;as_C_string());
1398       CLEAR_PENDING_EXCEPTION;
1399       if (ex_name == vmSymbols::java_lang_OutOfMemoryError()) {
1400         return JVMTI_ERROR_OUT_OF_MEMORY;
1401       } else {
1402         return JVMTI_ERROR_INTERNAL;
1403       }
1404     }
1405 
1406     if (VerifyMergedCPBytecodes) {
1407       // verify what we have done during constant pool merging
1408       {
1409         RedefineVerifyMark rvm(the_class, scratch_class, state);
1410         Verifier::verify(scratch_class, true, THREAD);
1411       }
1412 
1413       if (HAS_PENDING_EXCEPTION) {
1414         Symbol* ex_name = PENDING_EXCEPTION-&gt;klass()-&gt;name();
1415         log_info(redefine, class, load, exceptions)
1416           (&quot;verify_byte_codes post merge-CP exception: &#39;%s&#39;&quot;, ex_name-&gt;as_C_string());
1417         CLEAR_PENDING_EXCEPTION;
1418         if (ex_name == vmSymbols::java_lang_OutOfMemoryError()) {
1419           return JVMTI_ERROR_OUT_OF_MEMORY;
1420         } else {
1421           // tell the caller that constant pool merging screwed up
1422           return JVMTI_ERROR_INTERNAL;
1423         }
1424       }
1425     }
1426 
1427     Rewriter::rewrite(scratch_class, THREAD);
1428     if (!HAS_PENDING_EXCEPTION) {
1429       scratch_class-&gt;link_methods(THREAD);
1430     }
1431     if (HAS_PENDING_EXCEPTION) {
1432       Symbol* ex_name = PENDING_EXCEPTION-&gt;klass()-&gt;name();
1433       log_info(redefine, class, load, exceptions)
1434         (&quot;Rewriter::rewrite or link_methods exception: &#39;%s&#39;&quot;, ex_name-&gt;as_C_string());
1435       CLEAR_PENDING_EXCEPTION;
1436       if (ex_name == vmSymbols::java_lang_OutOfMemoryError()) {
1437         return JVMTI_ERROR_OUT_OF_MEMORY;
1438       } else {
1439         return JVMTI_ERROR_INTERNAL;
1440       }
1441     }
1442 
1443     log_debug(redefine, class, load)
1444       (&quot;loaded name=%s (avail_mem=&quot; UINT64_FORMAT &quot;K)&quot;, the_class-&gt;external_name(), os::available_memory() &gt;&gt; 10);
1445   }
1446 
1447   return JVMTI_ERROR_NONE;
1448 }
1449 
1450 
1451 // Map old_index to new_index as needed. scratch_cp is only needed
1452 // for log calls.
1453 void VM_RedefineClasses::map_index(const constantPoolHandle&amp; scratch_cp,
1454        int old_index, int new_index) {
1455   if (find_new_index(old_index) != 0) {
1456     // old_index is already mapped
1457     return;
1458   }
1459 
1460   if (old_index == new_index) {
1461     // no mapping is needed
1462     return;
1463   }
1464 
1465   _index_map_p-&gt;at_put(old_index, new_index);
1466   _index_map_count++;
1467 
1468   log_trace(redefine, class, constantpool)
1469     (&quot;mapped tag %d at index %d to %d&quot;, scratch_cp-&gt;tag_at(old_index).value(), old_index, new_index);
1470 } // end map_index()
1471 
1472 
1473 // Map old_index to new_index as needed.
1474 void VM_RedefineClasses::map_operand_index(int old_index, int new_index) {
1475   if (find_new_operand_index(old_index) != -1) {
1476     // old_index is already mapped
1477     return;
1478   }
1479 
1480   if (old_index == new_index) {
1481     // no mapping is needed
1482     return;
1483   }
1484 
1485   _operands_index_map_p-&gt;at_put(old_index, new_index);
1486   _operands_index_map_count++;
1487 
1488   log_trace(redefine, class, constantpool)(&quot;mapped bootstrap specifier at index %d to %d&quot;, old_index, new_index);
1489 } // end map_index()
1490 
1491 
1492 // Merge old_cp and scratch_cp and return the results of the merge via
1493 // merge_cp_p. The number of entries in *merge_cp_p is returned via
1494 // merge_cp_length_p. The entries in old_cp occupy the same locations
1495 // in *merge_cp_p. Also creates a map of indices from entries in
1496 // scratch_cp to the corresponding entry in *merge_cp_p. Index map
1497 // entries are only created for entries in scratch_cp that occupy a
1498 // different location in *merged_cp_p.
1499 bool VM_RedefineClasses::merge_constant_pools(const constantPoolHandle&amp; old_cp,
1500        const constantPoolHandle&amp; scratch_cp, constantPoolHandle *merge_cp_p,
1501        int *merge_cp_length_p, TRAPS) {
1502 
1503   if (merge_cp_p == NULL) {
1504     assert(false, &quot;caller must provide scratch constantPool&quot;);
1505     return false; // robustness
1506   }
1507   if (merge_cp_length_p == NULL) {
1508     assert(false, &quot;caller must provide scratch CP length&quot;);
1509     return false; // robustness
1510   }
1511   // Worst case we need old_cp-&gt;length() + scratch_cp()-&gt;length(),
1512   // but the caller might be smart so make sure we have at least
1513   // the minimum.
1514   if ((*merge_cp_p)-&gt;length() &lt; old_cp-&gt;length()) {
1515     assert(false, &quot;merge area too small&quot;);
1516     return false; // robustness
1517   }
1518 
1519   log_info(redefine, class, constantpool)(&quot;old_cp_len=%d, scratch_cp_len=%d&quot;, old_cp-&gt;length(), scratch_cp-&gt;length());
1520 
1521   {
1522     // Pass 0:
1523     // The old_cp is copied to *merge_cp_p; this means that any code
1524     // using old_cp does not have to change. This work looks like a
1525     // perfect fit for ConstantPool*::copy_cp_to(), but we need to
1526     // handle one special case:
1527     // - revert JVM_CONSTANT_Class to JVM_CONSTANT_UnresolvedClass
1528     // This will make verification happy.
1529 
1530     int old_i;  // index into old_cp
1531 
1532     // index zero (0) is not used in constantPools
1533     for (old_i = 1; old_i &lt; old_cp-&gt;length(); old_i++) {
1534       // leave debugging crumb
1535       jbyte old_tag = old_cp-&gt;tag_at(old_i).value();
1536       switch (old_tag) {
1537       case JVM_CONSTANT_Class:
1538       case JVM_CONSTANT_UnresolvedClass:
1539         // revert the copy to JVM_CONSTANT_UnresolvedClass
1540         // May be resolving while calling this so do the same for
1541         // JVM_CONSTANT_UnresolvedClass (klass_name_at() deals with transition)
1542         (*merge_cp_p)-&gt;temp_unresolved_klass_at_put(old_i,
1543           old_cp-&gt;klass_name_index_at(old_i));
1544         break;
1545 
1546       case JVM_CONSTANT_Double:
1547       case JVM_CONSTANT_Long:
1548         // just copy the entry to *merge_cp_p, but double and long take
1549         // two constant pool entries
1550         ConstantPool::copy_entry_to(old_cp, old_i, *merge_cp_p, old_i, CHECK_false);
1551         old_i++;
1552         break;
1553 
1554       default:
1555         // just copy the entry to *merge_cp_p
1556         ConstantPool::copy_entry_to(old_cp, old_i, *merge_cp_p, old_i, CHECK_false);
1557         break;
1558       }
1559     } // end for each old_cp entry
1560 
1561     ConstantPool::copy_operands(old_cp, *merge_cp_p, CHECK_false);
1562     (*merge_cp_p)-&gt;extend_operands(scratch_cp, CHECK_false);
1563 
1564     // We don&#39;t need to sanity check that *merge_cp_length_p is within
1565     // *merge_cp_p bounds since we have the minimum on-entry check above.
1566     (*merge_cp_length_p) = old_i;
1567   }
1568 
1569   // merge_cp_len should be the same as old_cp-&gt;length() at this point
1570   // so this trace message is really a &quot;warm-and-breathing&quot; message.
1571   log_debug(redefine, class, constantpool)(&quot;after pass 0: merge_cp_len=%d&quot;, *merge_cp_length_p);
1572 
1573   int scratch_i;  // index into scratch_cp
1574   {
1575     // Pass 1a:
1576     // Compare scratch_cp entries to the old_cp entries that we have
1577     // already copied to *merge_cp_p. In this pass, we are eliminating
1578     // exact duplicates (matching entry at same index) so we only
1579     // compare entries in the common indice range.
1580     int increment = 1;
1581     int pass1a_length = MIN2(old_cp-&gt;length(), scratch_cp-&gt;length());
1582     for (scratch_i = 1; scratch_i &lt; pass1a_length; scratch_i += increment) {
1583       switch (scratch_cp-&gt;tag_at(scratch_i).value()) {
1584       case JVM_CONSTANT_Double:
1585       case JVM_CONSTANT_Long:
1586         // double and long take two constant pool entries
1587         increment = 2;
1588         break;
1589 
1590       default:
1591         increment = 1;
1592         break;
1593       }
1594 
1595       bool match = scratch_cp-&gt;compare_entry_to(scratch_i, *merge_cp_p,
1596         scratch_i, CHECK_false);
1597       if (match) {
1598         // found a match at the same index so nothing more to do
1599         continue;
1600       } else if (is_unresolved_class_mismatch(scratch_cp, scratch_i,
1601                                               *merge_cp_p, scratch_i)) {
1602         // The mismatch in compare_entry_to() above is because of a
1603         // resolved versus unresolved class entry at the same index
1604         // with the same string value. Since Pass 0 reverted any
1605         // class entries to unresolved class entries in *merge_cp_p,
1606         // we go with the unresolved class entry.
1607         continue;
1608       }
1609 
1610       int found_i = scratch_cp-&gt;find_matching_entry(scratch_i, *merge_cp_p,
1611         CHECK_false);
1612       if (found_i != 0) {
1613         guarantee(found_i != scratch_i,
1614           &quot;compare_entry_to() and find_matching_entry() do not agree&quot;);
1615 
1616         // Found a matching entry somewhere else in *merge_cp_p so
1617         // just need a mapping entry.
1618         map_index(scratch_cp, scratch_i, found_i);
1619         continue;
1620       }
1621 
1622       // The find_matching_entry() call above could fail to find a match
1623       // due to a resolved versus unresolved class or string entry situation
1624       // like we solved above with the is_unresolved_*_mismatch() calls.
1625       // However, we would have to call is_unresolved_*_mismatch() over
1626       // all of *merge_cp_p (potentially) and that doesn&#39;t seem to be
1627       // worth the time.
1628 
1629       // No match found so we have to append this entry and any unique
1630       // referenced entries to *merge_cp_p.
1631       append_entry(scratch_cp, scratch_i, merge_cp_p, merge_cp_length_p,
1632         CHECK_false);
1633     }
1634   }
1635 
1636   log_debug(redefine, class, constantpool)
1637     (&quot;after pass 1a: merge_cp_len=%d, scratch_i=%d, index_map_len=%d&quot;,
1638      *merge_cp_length_p, scratch_i, _index_map_count);
1639 
1640   if (scratch_i &lt; scratch_cp-&gt;length()) {
1641     // Pass 1b:
1642     // old_cp is smaller than scratch_cp so there are entries in
1643     // scratch_cp that we have not yet processed. We take care of
1644     // those now.
1645     int increment = 1;
1646     for (; scratch_i &lt; scratch_cp-&gt;length(); scratch_i += increment) {
1647       switch (scratch_cp-&gt;tag_at(scratch_i).value()) {
1648       case JVM_CONSTANT_Double:
1649       case JVM_CONSTANT_Long:
1650         // double and long take two constant pool entries
1651         increment = 2;
1652         break;
1653 
1654       default:
1655         increment = 1;
1656         break;
1657       }
1658 
1659       int found_i =
1660         scratch_cp-&gt;find_matching_entry(scratch_i, *merge_cp_p, CHECK_false);
1661       if (found_i != 0) {
1662         // Found a matching entry somewhere else in *merge_cp_p so
1663         // just need a mapping entry.
1664         map_index(scratch_cp, scratch_i, found_i);
1665         continue;
1666       }
1667 
1668       // No match found so we have to append this entry and any unique
1669       // referenced entries to *merge_cp_p.
1670       append_entry(scratch_cp, scratch_i, merge_cp_p, merge_cp_length_p,
1671         CHECK_false);
1672     }
1673 
1674     log_debug(redefine, class, constantpool)
1675       (&quot;after pass 1b: merge_cp_len=%d, scratch_i=%d, index_map_len=%d&quot;,
1676        *merge_cp_length_p, scratch_i, _index_map_count);
1677   }
1678   finalize_operands_merge(*merge_cp_p, THREAD);
1679 
1680   return true;
1681 } // end merge_constant_pools()
1682 
1683 
1684 // Scoped object to clean up the constant pool(s) created for merging
1685 class MergeCPCleaner {
1686   ClassLoaderData*   _loader_data;
1687   ConstantPool*      _cp;
1688   ConstantPool*      _scratch_cp;
1689  public:
1690   MergeCPCleaner(ClassLoaderData* loader_data, ConstantPool* merge_cp) :
1691                  _loader_data(loader_data), _cp(merge_cp), _scratch_cp(NULL) {}
1692   ~MergeCPCleaner() {
1693     _loader_data-&gt;add_to_deallocate_list(_cp);
1694     if (_scratch_cp != NULL) {
1695       _loader_data-&gt;add_to_deallocate_list(_scratch_cp);
1696     }
1697   }
1698   void add_scratch_cp(ConstantPool* scratch_cp) { _scratch_cp = scratch_cp; }
1699 };
1700 
1701 // Merge constant pools between the_class and scratch_class and
1702 // potentially rewrite bytecodes in scratch_class to use the merged
1703 // constant pool.
1704 jvmtiError VM_RedefineClasses::merge_cp_and_rewrite(
1705              InstanceKlass* the_class, InstanceKlass* scratch_class,
1706              TRAPS) {
1707   // worst case merged constant pool length is old and new combined
1708   int merge_cp_length = the_class-&gt;constants()-&gt;length()
1709         + scratch_class-&gt;constants()-&gt;length();
1710 
1711   // Constant pools are not easily reused so we allocate a new one
1712   // each time.
1713   // merge_cp is created unsafe for concurrent GC processing.  It
1714   // should be marked safe before discarding it. Even though
1715   // garbage,  if it crosses a card boundary, it may be scanned
1716   // in order to find the start of the first complete object on the card.
1717   ClassLoaderData* loader_data = the_class-&gt;class_loader_data();
1718   ConstantPool* merge_cp_oop =
1719     ConstantPool::allocate(loader_data,
1720                            merge_cp_length,
1721                            CHECK_(JVMTI_ERROR_OUT_OF_MEMORY));
1722   MergeCPCleaner cp_cleaner(loader_data, merge_cp_oop);
1723 
1724   HandleMark hm(THREAD);  // make sure handles are cleared before
1725                           // MergeCPCleaner clears out merge_cp_oop
1726   constantPoolHandle merge_cp(THREAD, merge_cp_oop);
1727 
1728   // Get constants() from the old class because it could have been rewritten
1729   // while we were at a safepoint allocating a new constant pool.
1730   constantPoolHandle old_cp(THREAD, the_class-&gt;constants());
1731   constantPoolHandle scratch_cp(THREAD, scratch_class-&gt;constants());
1732 
1733   // If the length changed, the class was redefined out from under us. Return
1734   // an error.
1735   if (merge_cp_length != the_class-&gt;constants()-&gt;length()
1736          + scratch_class-&gt;constants()-&gt;length()) {
1737     return JVMTI_ERROR_INTERNAL;
1738   }
1739 
1740   // Update the version number of the constant pools (may keep scratch_cp)
1741   merge_cp-&gt;increment_and_save_version(old_cp-&gt;version());
1742   scratch_cp-&gt;increment_and_save_version(old_cp-&gt;version());
1743 
1744   ResourceMark rm(THREAD);
1745   _index_map_count = 0;
1746   _index_map_p = new intArray(scratch_cp-&gt;length(), scratch_cp-&gt;length(), -1);
1747 
1748   _operands_cur_length = ConstantPool::operand_array_length(old_cp-&gt;operands());
1749   _operands_index_map_count = 0;
1750   int operands_index_map_len = ConstantPool::operand_array_length(scratch_cp-&gt;operands());
1751   _operands_index_map_p = new intArray(operands_index_map_len, operands_index_map_len, -1);
1752 
1753   // reference to the cp holder is needed for copy_operands()
1754   merge_cp-&gt;set_pool_holder(scratch_class);
1755   bool result = merge_constant_pools(old_cp, scratch_cp, &amp;merge_cp,
1756                   &amp;merge_cp_length, THREAD);
1757   merge_cp-&gt;set_pool_holder(NULL);
1758 
1759   if (!result) {
1760     // The merge can fail due to memory allocation failure or due
1761     // to robustness checks.
1762     return JVMTI_ERROR_INTERNAL;
1763   }
1764 
1765   // Save fields from the old_cp.
1766   merge_cp-&gt;copy_fields(old_cp());
1767   scratch_cp-&gt;copy_fields(old_cp());
1768 
1769   log_info(redefine, class, constantpool)(&quot;merge_cp_len=%d, index_map_len=%d&quot;, merge_cp_length, _index_map_count);
1770 
1771   if (_index_map_count == 0) {
1772     // there is nothing to map between the new and merged constant pools
1773 
1774     if (old_cp-&gt;length() == scratch_cp-&gt;length()) {
1775       // The old and new constant pools are the same length and the
1776       // index map is empty. This means that the three constant pools
1777       // are equivalent (but not the same). Unfortunately, the new
1778       // constant pool has not gone through link resolution nor have
1779       // the new class bytecodes gone through constant pool cache
1780       // rewriting so we can&#39;t use the old constant pool with the new
1781       // class.
1782 
1783       // toss the merged constant pool at return
1784     } else if (old_cp-&gt;length() &lt; scratch_cp-&gt;length()) {
1785       // The old constant pool has fewer entries than the new constant
1786       // pool and the index map is empty. This means the new constant
1787       // pool is a superset of the old constant pool. However, the old
1788       // class bytecodes have already gone through constant pool cache
1789       // rewriting so we can&#39;t use the new constant pool with the old
1790       // class.
1791 
1792       // toss the merged constant pool at return
1793     } else {
1794       // The old constant pool has more entries than the new constant
1795       // pool and the index map is empty. This means that both the old
1796       // and merged constant pools are supersets of the new constant
1797       // pool.
1798 
1799       // Replace the new constant pool with a shrunken copy of the
1800       // merged constant pool
1801       set_new_constant_pool(loader_data, scratch_class, merge_cp, merge_cp_length,
1802                             CHECK_(JVMTI_ERROR_OUT_OF_MEMORY));
1803       // The new constant pool replaces scratch_cp so have cleaner clean it up.
1804       // It can&#39;t be cleaned up while there are handles to it.
1805       cp_cleaner.add_scratch_cp(scratch_cp());
1806     }
1807   } else {
1808     if (log_is_enabled(Trace, redefine, class, constantpool)) {
1809       // don&#39;t want to loop unless we are tracing
1810       int count = 0;
1811       for (int i = 1; i &lt; _index_map_p-&gt;length(); i++) {
1812         int value = _index_map_p-&gt;at(i);
1813 
1814         if (value != -1) {
1815           log_trace(redefine, class, constantpool)(&quot;index_map[%d]: old=%d new=%d&quot;, count, i, value);
1816           count++;
1817         }
1818       }
1819     }
1820 
1821     // We have entries mapped between the new and merged constant pools
1822     // so we have to rewrite some constant pool references.
1823     if (!rewrite_cp_refs(scratch_class, THREAD)) {
1824       return JVMTI_ERROR_INTERNAL;
1825     }
1826 
1827     // Replace the new constant pool with a shrunken copy of the
1828     // merged constant pool so now the rewritten bytecodes have
1829     // valid references; the previous new constant pool will get
1830     // GCed.
1831     set_new_constant_pool(loader_data, scratch_class, merge_cp, merge_cp_length,
1832                           CHECK_(JVMTI_ERROR_OUT_OF_MEMORY));
1833     // The new constant pool replaces scratch_cp so have cleaner clean it up.
1834     // It can&#39;t be cleaned up while there are handles to it.
1835     cp_cleaner.add_scratch_cp(scratch_cp());
1836   }
1837 
1838   return JVMTI_ERROR_NONE;
1839 } // end merge_cp_and_rewrite()
1840 
1841 
1842 // Rewrite constant pool references in klass scratch_class.
1843 bool VM_RedefineClasses::rewrite_cp_refs(InstanceKlass* scratch_class,
1844        TRAPS) {
1845 
1846   // rewrite constant pool references in the nest attributes:
1847   if (!rewrite_cp_refs_in_nest_attributes(scratch_class)) {
1848     // propagate failure back to caller
1849     return false;
1850   }
1851 
1852   // rewrite constant pool references in the Record attribute:
1853   if (!rewrite_cp_refs_in_record_attribute(scratch_class, THREAD)) {
1854     // propagate failure back to caller
1855     return false;
1856   }
1857 
1858   // rewrite constant pool references in the PermittedSubclasses attribute:
1859   if (!rewrite_cp_refs_in_permitted_subclasses_attribute(scratch_class)) {
1860     // propagate failure back to caller
1861     return false;
1862   }
1863 
1864   // rewrite constant pool references in the methods:
1865   if (!rewrite_cp_refs_in_methods(scratch_class, THREAD)) {
1866     // propagate failure back to caller
1867     return false;
1868   }
1869 
1870   // rewrite constant pool references in the class_annotations:
1871   if (!rewrite_cp_refs_in_class_annotations(scratch_class, THREAD)) {
1872     // propagate failure back to caller
1873     return false;
1874   }
1875 
1876   // rewrite constant pool references in the fields_annotations:
1877   if (!rewrite_cp_refs_in_fields_annotations(scratch_class, THREAD)) {
1878     // propagate failure back to caller
1879     return false;
1880   }
1881 
1882   // rewrite constant pool references in the methods_annotations:
1883   if (!rewrite_cp_refs_in_methods_annotations(scratch_class, THREAD)) {
1884     // propagate failure back to caller
1885     return false;
1886   }
1887 
1888   // rewrite constant pool references in the methods_parameter_annotations:
1889   if (!rewrite_cp_refs_in_methods_parameter_annotations(scratch_class,
1890          THREAD)) {
1891     // propagate failure back to caller
1892     return false;
1893   }
1894 
1895   // rewrite constant pool references in the methods_default_annotations:
1896   if (!rewrite_cp_refs_in_methods_default_annotations(scratch_class,
1897          THREAD)) {
1898     // propagate failure back to caller
1899     return false;
1900   }
1901 
1902   // rewrite constant pool references in the class_type_annotations:
1903   if (!rewrite_cp_refs_in_class_type_annotations(scratch_class, THREAD)) {
1904     // propagate failure back to caller
1905     return false;
1906   }
1907 
1908   // rewrite constant pool references in the fields_type_annotations:
1909   if (!rewrite_cp_refs_in_fields_type_annotations(scratch_class, THREAD)) {
1910     // propagate failure back to caller
1911     return false;
1912   }
1913 
1914   // rewrite constant pool references in the methods_type_annotations:
1915   if (!rewrite_cp_refs_in_methods_type_annotations(scratch_class, THREAD)) {
1916     // propagate failure back to caller
1917     return false;
1918   }
1919 
1920   // There can be type annotations in the Code part of a method_info attribute.
1921   // These annotations are not accessible, even by reflection.
1922   // Currently they are not even parsed by the ClassFileParser.
1923   // If runtime access is added they will also need to be rewritten.
1924 
1925   // rewrite source file name index:
1926   u2 source_file_name_idx = scratch_class-&gt;source_file_name_index();
1927   if (source_file_name_idx != 0) {
1928     u2 new_source_file_name_idx = find_new_index(source_file_name_idx);
1929     if (new_source_file_name_idx != 0) {
1930       scratch_class-&gt;set_source_file_name_index(new_source_file_name_idx);
1931     }
1932   }
1933 
1934   // rewrite class generic signature index:
1935   u2 generic_signature_index = scratch_class-&gt;generic_signature_index();
1936   if (generic_signature_index != 0) {
1937     u2 new_generic_signature_index = find_new_index(generic_signature_index);
1938     if (new_generic_signature_index != 0) {
1939       scratch_class-&gt;set_generic_signature_index(new_generic_signature_index);
1940     }
1941   }
1942 
1943   return true;
1944 } // end rewrite_cp_refs()
1945 
1946 // Rewrite constant pool references in the NestHost and NestMembers attributes.
1947 bool VM_RedefineClasses::rewrite_cp_refs_in_nest_attributes(
1948        InstanceKlass* scratch_class) {
1949 
1950   u2 cp_index = scratch_class-&gt;nest_host_index();
1951   if (cp_index != 0) {
1952     scratch_class-&gt;set_nest_host_index(find_new_index(cp_index));
1953   }
1954   Array&lt;u2&gt;* nest_members = scratch_class-&gt;nest_members();
1955   for (int i = 0; i &lt; nest_members-&gt;length(); i++) {
1956     u2 cp_index = nest_members-&gt;at(i);
1957     nest_members-&gt;at_put(i, find_new_index(cp_index));
1958   }
1959   return true;
1960 }
1961 
1962 // Rewrite constant pool references in the Record attribute.
1963 bool VM_RedefineClasses::rewrite_cp_refs_in_record_attribute(
1964        InstanceKlass* scratch_class, TRAPS) {
1965   Array&lt;RecordComponent*&gt;* components = scratch_class-&gt;record_components();
1966   if (components != NULL) {
1967     for (int i = 0; i &lt; components-&gt;length(); i++) {
1968       RecordComponent* component = components-&gt;at(i);
1969       u2 cp_index = component-&gt;name_index();
1970       component-&gt;set_name_index(find_new_index(cp_index));
1971       cp_index = component-&gt;descriptor_index();
1972       component-&gt;set_descriptor_index(find_new_index(cp_index));
1973       cp_index = component-&gt;generic_signature_index();
1974       if (cp_index != 0) {
1975         component-&gt;set_generic_signature_index(find_new_index(cp_index));
1976       }
1977 
1978       AnnotationArray* annotations = component-&gt;annotations();
1979       if (annotations != NULL &amp;&amp; annotations-&gt;length() != 0) {
1980         int byte_i = 0;  // byte index into annotations
1981         if (!rewrite_cp_refs_in_annotations_typeArray(annotations, byte_i, THREAD)) {
1982           log_debug(redefine, class, annotation)(&quot;bad record_component_annotations at %d&quot;, i);
1983           // propagate failure back to caller
1984           return false;
1985         }
1986       }
1987 
1988       AnnotationArray* type_annotations = component-&gt;type_annotations();
1989       if (type_annotations != NULL &amp;&amp; type_annotations-&gt;length() != 0) {
1990         int byte_i = 0;  // byte index into annotations
1991         if (!rewrite_cp_refs_in_annotations_typeArray(type_annotations, byte_i, THREAD)) {
1992           log_debug(redefine, class, annotation)(&quot;bad record_component_type_annotations at %d&quot;, i);
1993           // propagate failure back to caller
1994           return false;
1995         }
1996       }
1997     }
1998   }
1999   return true;
2000 }
2001 
2002 // Rewrite constant pool references in the PermittedSubclasses attribute.
2003 bool VM_RedefineClasses::rewrite_cp_refs_in_permitted_subclasses_attribute(
2004        InstanceKlass* scratch_class) {
2005 
2006   Array&lt;u2&gt;* permitted_subclasses = scratch_class-&gt;permitted_subclasses();
<a name="3" id="anc3"></a><span class="line-modified">2007   if (permitted_subclasses != NULL) {</span>
<span class="line-modified">2008     for (int i = 0; i &lt; permitted_subclasses-&gt;length(); i++) {</span>
<span class="line-modified">2009       u2 cp_index = permitted_subclasses-&gt;at(i);</span>
<span class="line-modified">2010       permitted_subclasses-&gt;at_put(i, find_new_index(cp_index));</span>
<span class="line-removed">2011     }</span>
2012   }
2013   return true;
2014 }
2015 
2016 // Rewrite constant pool references in the methods.
2017 bool VM_RedefineClasses::rewrite_cp_refs_in_methods(
2018        InstanceKlass* scratch_class, TRAPS) {
2019 
2020   Array&lt;Method*&gt;* methods = scratch_class-&gt;methods();
2021 
2022   if (methods == NULL || methods-&gt;length() == 0) {
2023     // no methods so nothing to do
2024     return true;
2025   }
2026 
2027   // rewrite constant pool references in the methods:
2028   for (int i = methods-&gt;length() - 1; i &gt;= 0; i--) {
2029     methodHandle method(THREAD, methods-&gt;at(i));
2030     methodHandle new_method;
2031     rewrite_cp_refs_in_method(method, &amp;new_method, THREAD);
2032     if (!new_method.is_null()) {
2033       // the method has been replaced so save the new method version
2034       // even in the case of an exception.  original method is on the
2035       // deallocation list.
2036       methods-&gt;at_put(i, new_method());
2037     }
2038     if (HAS_PENDING_EXCEPTION) {
2039       Symbol* ex_name = PENDING_EXCEPTION-&gt;klass()-&gt;name();
2040       log_info(redefine, class, load, exceptions)(&quot;rewrite_cp_refs_in_method exception: &#39;%s&#39;&quot;, ex_name-&gt;as_C_string());
2041       // Need to clear pending exception here as the super caller sets
2042       // the JVMTI_ERROR_INTERNAL if the returned value is false.
2043       CLEAR_PENDING_EXCEPTION;
2044       return false;
2045     }
2046   }
2047 
2048   return true;
2049 }
2050 
2051 
2052 // Rewrite constant pool references in the specific method. This code
2053 // was adapted from Rewriter::rewrite_method().
2054 void VM_RedefineClasses::rewrite_cp_refs_in_method(methodHandle method,
2055        methodHandle *new_method_p, TRAPS) {
2056 
2057   *new_method_p = methodHandle();  // default is no new method
2058 
2059   // We cache a pointer to the bytecodes here in code_base. If GC
2060   // moves the Method*, then the bytecodes will also move which
2061   // will likely cause a crash. We create a NoSafepointVerifier
2062   // object to detect whether we pass a possible safepoint in this
2063   // code block.
2064   NoSafepointVerifier nsv;
2065 
2066   // Bytecodes and their length
2067   address code_base = method-&gt;code_base();
2068   int code_length = method-&gt;code_size();
2069 
2070   int bc_length;
2071   for (int bci = 0; bci &lt; code_length; bci += bc_length) {
2072     address bcp = code_base + bci;
2073     Bytecodes::Code c = (Bytecodes::Code)(*bcp);
2074 
2075     bc_length = Bytecodes::length_for(c);
2076     if (bc_length == 0) {
2077       // More complicated bytecodes report a length of zero so
2078       // we have to try again a slightly different way.
2079       bc_length = Bytecodes::length_at(method(), bcp);
2080     }
2081 
2082     assert(bc_length != 0, &quot;impossible bytecode length&quot;);
2083 
2084     switch (c) {
2085       case Bytecodes::_ldc:
2086       {
2087         int cp_index = *(bcp + 1);
2088         int new_index = find_new_index(cp_index);
2089 
2090         if (StressLdcRewrite &amp;&amp; new_index == 0) {
2091           // If we are stressing ldc -&gt; ldc_w rewriting, then we
2092           // always need a new_index value.
2093           new_index = cp_index;
2094         }
2095         if (new_index != 0) {
2096           // the original index is mapped so we have more work to do
2097           if (!StressLdcRewrite &amp;&amp; new_index &lt;= max_jubyte) {
2098             // The new value can still use ldc instead of ldc_w
2099             // unless we are trying to stress ldc -&gt; ldc_w rewriting
2100             log_trace(redefine, class, constantpool)
2101               (&quot;%s@&quot; INTPTR_FORMAT &quot; old=%d, new=%d&quot;, Bytecodes::name(c), p2i(bcp), cp_index, new_index);
2102             *(bcp + 1) = new_index;
2103           } else {
2104             log_trace(redefine, class, constantpool)
2105               (&quot;%s-&gt;ldc_w@&quot; INTPTR_FORMAT &quot; old=%d, new=%d&quot;, Bytecodes::name(c), p2i(bcp), cp_index, new_index);
2106             // the new value needs ldc_w instead of ldc
2107             u_char inst_buffer[4]; // max instruction size is 4 bytes
2108             bcp = (address)inst_buffer;
2109             // construct new instruction sequence
2110             *bcp = Bytecodes::_ldc_w;
2111             bcp++;
2112             // Rewriter::rewrite_method() does not rewrite ldc -&gt; ldc_w.
2113             // See comment below for difference between put_Java_u2()
2114             // and put_native_u2().
2115             Bytes::put_Java_u2(bcp, new_index);
2116 
2117             Relocator rc(method, NULL /* no RelocatorListener needed */);
2118             methodHandle m;
2119             {
2120               PauseNoSafepointVerifier pnsv(&amp;nsv);
2121 
2122               // ldc is 2 bytes and ldc_w is 3 bytes
2123               m = rc.insert_space_at(bci, 3, inst_buffer, CHECK);
2124             }
2125 
2126             // return the new method so that the caller can update
2127             // the containing class
2128             *new_method_p = method = m;
2129             // switch our bytecode processing loop from the old method
2130             // to the new method
2131             code_base = method-&gt;code_base();
2132             code_length = method-&gt;code_size();
2133             bcp = code_base + bci;
2134             c = (Bytecodes::Code)(*bcp);
2135             bc_length = Bytecodes::length_for(c);
2136             assert(bc_length != 0, &quot;sanity check&quot;);
2137           } // end we need ldc_w instead of ldc
2138         } // end if there is a mapped index
2139       } break;
2140 
2141       // these bytecodes have a two-byte constant pool index
2142       case Bytecodes::_anewarray      : // fall through
2143       case Bytecodes::_checkcast      : // fall through
2144       case Bytecodes::_getfield       : // fall through
2145       case Bytecodes::_getstatic      : // fall through
2146       case Bytecodes::_instanceof     : // fall through
2147       case Bytecodes::_invokedynamic  : // fall through
2148       case Bytecodes::_invokeinterface: // fall through
2149       case Bytecodes::_invokespecial  : // fall through
2150       case Bytecodes::_invokestatic   : // fall through
2151       case Bytecodes::_invokevirtual  : // fall through
2152       case Bytecodes::_ldc_w          : // fall through
2153       case Bytecodes::_ldc2_w         : // fall through
2154       case Bytecodes::_multianewarray : // fall through
2155       case Bytecodes::_new            : // fall through
2156       case Bytecodes::_putfield       : // fall through
2157       case Bytecodes::_putstatic      :
2158       {
2159         address p = bcp + 1;
2160         int cp_index = Bytes::get_Java_u2(p);
2161         int new_index = find_new_index(cp_index);
2162         if (new_index != 0) {
2163           // the original index is mapped so update w/ new value
2164           log_trace(redefine, class, constantpool)
2165             (&quot;%s@&quot; INTPTR_FORMAT &quot; old=%d, new=%d&quot;, Bytecodes::name(c),p2i(bcp), cp_index, new_index);
2166           // Rewriter::rewrite_method() uses put_native_u2() in this
2167           // situation because it is reusing the constant pool index
2168           // location for a native index into the ConstantPoolCache.
2169           // Since we are updating the constant pool index prior to
2170           // verification and ConstantPoolCache initialization, we
2171           // need to keep the new index in Java byte order.
2172           Bytes::put_Java_u2(p, new_index);
2173         }
2174       } break;
2175       default:
2176         break;
2177     }
2178   } // end for each bytecode
2179 
2180   // We also need to rewrite the parameter name indexes, if there is
2181   // method parameter data present
2182   if(method-&gt;has_method_parameters()) {
2183     const int len = method-&gt;method_parameters_length();
2184     MethodParametersElement* elem = method-&gt;method_parameters_start();
2185 
2186     for (int i = 0; i &lt; len; i++) {
2187       const u2 cp_index = elem[i].name_cp_index;
2188       const u2 new_cp_index = find_new_index(cp_index);
2189       if (new_cp_index != 0) {
2190         elem[i].name_cp_index = new_cp_index;
2191       }
2192     }
2193   }
2194 } // end rewrite_cp_refs_in_method()
2195 
2196 
2197 // Rewrite constant pool references in the class_annotations field.
2198 bool VM_RedefineClasses::rewrite_cp_refs_in_class_annotations(
2199        InstanceKlass* scratch_class, TRAPS) {
2200 
2201   AnnotationArray* class_annotations = scratch_class-&gt;class_annotations();
2202   if (class_annotations == NULL || class_annotations-&gt;length() == 0) {
2203     // no class_annotations so nothing to do
2204     return true;
2205   }
2206 
2207   log_debug(redefine, class, annotation)(&quot;class_annotations length=%d&quot;, class_annotations-&gt;length());
2208 
2209   int byte_i = 0;  // byte index into class_annotations
2210   return rewrite_cp_refs_in_annotations_typeArray(class_annotations, byte_i,
2211            THREAD);
2212 }
2213 
2214 
2215 // Rewrite constant pool references in an annotations typeArray. This
2216 // &quot;structure&quot; is adapted from the RuntimeVisibleAnnotations_attribute
2217 // that is described in section 4.8.15 of the 2nd-edition of the VM spec:
2218 //
2219 // annotations_typeArray {
2220 //   u2 num_annotations;
2221 //   annotation annotations[num_annotations];
2222 // }
2223 //
2224 bool VM_RedefineClasses::rewrite_cp_refs_in_annotations_typeArray(
2225        AnnotationArray* annotations_typeArray, int &amp;byte_i_ref, TRAPS) {
2226 
2227   if ((byte_i_ref + 2) &gt; annotations_typeArray-&gt;length()) {
2228     // not enough room for num_annotations field
2229     log_debug(redefine, class, annotation)(&quot;length() is too small for num_annotations field&quot;);
2230     return false;
2231   }
2232 
2233   u2 num_annotations = Bytes::get_Java_u2((address)
2234                          annotations_typeArray-&gt;adr_at(byte_i_ref));
2235   byte_i_ref += 2;
2236 
2237   log_debug(redefine, class, annotation)(&quot;num_annotations=%d&quot;, num_annotations);
2238 
2239   int calc_num_annotations = 0;
2240   for (; calc_num_annotations &lt; num_annotations; calc_num_annotations++) {
2241     if (!rewrite_cp_refs_in_annotation_struct(annotations_typeArray,
2242            byte_i_ref, THREAD)) {
2243       log_debug(redefine, class, annotation)(&quot;bad annotation_struct at %d&quot;, calc_num_annotations);
2244       // propagate failure back to caller
2245       return false;
2246     }
2247   }
2248   assert(num_annotations == calc_num_annotations, &quot;sanity check&quot;);
2249 
2250   return true;
2251 } // end rewrite_cp_refs_in_annotations_typeArray()
2252 
2253 
2254 // Rewrite constant pool references in the annotation struct portion of
2255 // an annotations_typeArray. This &quot;structure&quot; is from section 4.8.15 of
2256 // the 2nd-edition of the VM spec:
2257 //
2258 // struct annotation {
2259 //   u2 type_index;
2260 //   u2 num_element_value_pairs;
2261 //   {
2262 //     u2 element_name_index;
2263 //     element_value value;
2264 //   } element_value_pairs[num_element_value_pairs];
2265 // }
2266 //
2267 bool VM_RedefineClasses::rewrite_cp_refs_in_annotation_struct(
2268        AnnotationArray* annotations_typeArray, int &amp;byte_i_ref, TRAPS) {
2269   if ((byte_i_ref + 2 + 2) &gt; annotations_typeArray-&gt;length()) {
2270     // not enough room for smallest annotation_struct
2271     log_debug(redefine, class, annotation)(&quot;length() is too small for annotation_struct&quot;);
2272     return false;
2273   }
2274 
2275   u2 type_index = rewrite_cp_ref_in_annotation_data(annotations_typeArray,
2276                     byte_i_ref, &quot;type_index&quot;, THREAD);
2277 
2278   u2 num_element_value_pairs = Bytes::get_Java_u2((address)
2279                                  annotations_typeArray-&gt;adr_at(byte_i_ref));
2280   byte_i_ref += 2;
2281 
2282   log_debug(redefine, class, annotation)
2283     (&quot;type_index=%d  num_element_value_pairs=%d&quot;, type_index, num_element_value_pairs);
2284 
2285   int calc_num_element_value_pairs = 0;
2286   for (; calc_num_element_value_pairs &lt; num_element_value_pairs;
2287        calc_num_element_value_pairs++) {
2288     if ((byte_i_ref + 2) &gt; annotations_typeArray-&gt;length()) {
2289       // not enough room for another element_name_index, let alone
2290       // the rest of another component
2291       log_debug(redefine, class, annotation)(&quot;length() is too small for element_name_index&quot;);
2292       return false;
2293     }
2294 
2295     u2 element_name_index = rewrite_cp_ref_in_annotation_data(
2296                               annotations_typeArray, byte_i_ref,
2297                               &quot;element_name_index&quot;, THREAD);
2298 
2299     log_debug(redefine, class, annotation)(&quot;element_name_index=%d&quot;, element_name_index);
2300 
2301     if (!rewrite_cp_refs_in_element_value(annotations_typeArray,
2302            byte_i_ref, THREAD)) {
2303       log_debug(redefine, class, annotation)(&quot;bad element_value at %d&quot;, calc_num_element_value_pairs);
2304       // propagate failure back to caller
2305       return false;
2306     }
2307   } // end for each component
2308   assert(num_element_value_pairs == calc_num_element_value_pairs,
2309     &quot;sanity check&quot;);
2310 
2311   return true;
2312 } // end rewrite_cp_refs_in_annotation_struct()
2313 
2314 
2315 // Rewrite a constant pool reference at the current position in
2316 // annotations_typeArray if needed. Returns the original constant
2317 // pool reference if a rewrite was not needed or the new constant
2318 // pool reference if a rewrite was needed.
2319 u2 VM_RedefineClasses::rewrite_cp_ref_in_annotation_data(
2320      AnnotationArray* annotations_typeArray, int &amp;byte_i_ref,
2321      const char * trace_mesg, TRAPS) {
2322 
2323   address cp_index_addr = (address)
2324     annotations_typeArray-&gt;adr_at(byte_i_ref);
2325   u2 old_cp_index = Bytes::get_Java_u2(cp_index_addr);
2326   u2 new_cp_index = find_new_index(old_cp_index);
2327   if (new_cp_index != 0) {
2328     log_debug(redefine, class, annotation)(&quot;mapped old %s=%d&quot;, trace_mesg, old_cp_index);
2329     Bytes::put_Java_u2(cp_index_addr, new_cp_index);
2330     old_cp_index = new_cp_index;
2331   }
2332   byte_i_ref += 2;
2333   return old_cp_index;
2334 }
2335 
2336 
2337 // Rewrite constant pool references in the element_value portion of an
2338 // annotations_typeArray. This &quot;structure&quot; is from section 4.8.15.1 of
2339 // the 2nd-edition of the VM spec:
2340 //
2341 // struct element_value {
2342 //   u1 tag;
2343 //   union {
2344 //     u2 const_value_index;
2345 //     {
2346 //       u2 type_name_index;
2347 //       u2 const_name_index;
2348 //     } enum_const_value;
2349 //     u2 class_info_index;
2350 //     annotation annotation_value;
2351 //     struct {
2352 //       u2 num_values;
2353 //       element_value values[num_values];
2354 //     } array_value;
2355 //   } value;
2356 // }
2357 //
2358 bool VM_RedefineClasses::rewrite_cp_refs_in_element_value(
2359        AnnotationArray* annotations_typeArray, int &amp;byte_i_ref, TRAPS) {
2360 
2361   if ((byte_i_ref + 1) &gt; annotations_typeArray-&gt;length()) {
2362     // not enough room for a tag let alone the rest of an element_value
2363     log_debug(redefine, class, annotation)(&quot;length() is too small for a tag&quot;);
2364     return false;
2365   }
2366 
2367   u1 tag = annotations_typeArray-&gt;at(byte_i_ref);
2368   byte_i_ref++;
2369   log_debug(redefine, class, annotation)(&quot;tag=&#39;%c&#39;&quot;, tag);
2370 
2371   switch (tag) {
2372     // These BaseType tag values are from Table 4.2 in VM spec:
2373     case JVM_SIGNATURE_BYTE:
2374     case JVM_SIGNATURE_CHAR:
2375     case JVM_SIGNATURE_DOUBLE:
2376     case JVM_SIGNATURE_FLOAT:
2377     case JVM_SIGNATURE_INT:
2378     case JVM_SIGNATURE_LONG:
2379     case JVM_SIGNATURE_SHORT:
2380     case JVM_SIGNATURE_BOOLEAN:
2381 
2382     // The remaining tag values are from Table 4.8 in the 2nd-edition of
2383     // the VM spec:
2384     case &#39;s&#39;:
2385     {
2386       // For the above tag values (including the BaseType values),
2387       // value.const_value_index is right union field.
2388 
2389       if ((byte_i_ref + 2) &gt; annotations_typeArray-&gt;length()) {
2390         // not enough room for a const_value_index
2391         log_debug(redefine, class, annotation)(&quot;length() is too small for a const_value_index&quot;);
2392         return false;
2393       }
2394 
2395       u2 const_value_index = rewrite_cp_ref_in_annotation_data(
2396                                annotations_typeArray, byte_i_ref,
2397                                &quot;const_value_index&quot;, THREAD);
2398 
2399       log_debug(redefine, class, annotation)(&quot;const_value_index=%d&quot;, const_value_index);
2400     } break;
2401 
2402     case &#39;e&#39;:
2403     {
2404       // for the above tag value, value.enum_const_value is right union field
2405 
2406       if ((byte_i_ref + 4) &gt; annotations_typeArray-&gt;length()) {
2407         // not enough room for a enum_const_value
2408         log_debug(redefine, class, annotation)(&quot;length() is too small for a enum_const_value&quot;);
2409         return false;
2410       }
2411 
2412       u2 type_name_index = rewrite_cp_ref_in_annotation_data(
2413                              annotations_typeArray, byte_i_ref,
2414                              &quot;type_name_index&quot;, THREAD);
2415 
2416       u2 const_name_index = rewrite_cp_ref_in_annotation_data(
2417                               annotations_typeArray, byte_i_ref,
2418                               &quot;const_name_index&quot;, THREAD);
2419 
2420       log_debug(redefine, class, annotation)
2421         (&quot;type_name_index=%d  const_name_index=%d&quot;, type_name_index, const_name_index);
2422     } break;
2423 
2424     case &#39;c&#39;:
2425     {
2426       // for the above tag value, value.class_info_index is right union field
2427 
2428       if ((byte_i_ref + 2) &gt; annotations_typeArray-&gt;length()) {
2429         // not enough room for a class_info_index
2430         log_debug(redefine, class, annotation)(&quot;length() is too small for a class_info_index&quot;);
2431         return false;
2432       }
2433 
2434       u2 class_info_index = rewrite_cp_ref_in_annotation_data(
2435                               annotations_typeArray, byte_i_ref,
2436                               &quot;class_info_index&quot;, THREAD);
2437 
2438       log_debug(redefine, class, annotation)(&quot;class_info_index=%d&quot;, class_info_index);
2439     } break;
2440 
2441     case &#39;@&#39;:
2442       // For the above tag value, value.attr_value is the right union
2443       // field. This is a nested annotation.
2444       if (!rewrite_cp_refs_in_annotation_struct(annotations_typeArray,
2445              byte_i_ref, THREAD)) {
2446         // propagate failure back to caller
2447         return false;
2448       }
2449       break;
2450 
2451     case JVM_SIGNATURE_ARRAY:
2452     {
2453       if ((byte_i_ref + 2) &gt; annotations_typeArray-&gt;length()) {
2454         // not enough room for a num_values field
2455         log_debug(redefine, class, annotation)(&quot;length() is too small for a num_values field&quot;);
2456         return false;
2457       }
2458 
2459       // For the above tag value, value.array_value is the right union
2460       // field. This is an array of nested element_value.
2461       u2 num_values = Bytes::get_Java_u2((address)
2462                         annotations_typeArray-&gt;adr_at(byte_i_ref));
2463       byte_i_ref += 2;
2464       log_debug(redefine, class, annotation)(&quot;num_values=%d&quot;, num_values);
2465 
2466       int calc_num_values = 0;
2467       for (; calc_num_values &lt; num_values; calc_num_values++) {
2468         if (!rewrite_cp_refs_in_element_value(
2469                annotations_typeArray, byte_i_ref, THREAD)) {
2470           log_debug(redefine, class, annotation)(&quot;bad nested element_value at %d&quot;, calc_num_values);
2471           // propagate failure back to caller
2472           return false;
2473         }
2474       }
2475       assert(num_values == calc_num_values, &quot;sanity check&quot;);
2476     } break;
2477 
2478     default:
2479       log_debug(redefine, class, annotation)(&quot;bad tag=0x%x&quot;, tag);
2480       return false;
2481   } // end decode tag field
2482 
2483   return true;
2484 } // end rewrite_cp_refs_in_element_value()
2485 
2486 
2487 // Rewrite constant pool references in a fields_annotations field.
2488 bool VM_RedefineClasses::rewrite_cp_refs_in_fields_annotations(
2489        InstanceKlass* scratch_class, TRAPS) {
2490 
2491   Array&lt;AnnotationArray*&gt;* fields_annotations = scratch_class-&gt;fields_annotations();
2492 
2493   if (fields_annotations == NULL || fields_annotations-&gt;length() == 0) {
2494     // no fields_annotations so nothing to do
2495     return true;
2496   }
2497 
2498   log_debug(redefine, class, annotation)(&quot;fields_annotations length=%d&quot;, fields_annotations-&gt;length());
2499 
2500   for (int i = 0; i &lt; fields_annotations-&gt;length(); i++) {
2501     AnnotationArray* field_annotations = fields_annotations-&gt;at(i);
2502     if (field_annotations == NULL || field_annotations-&gt;length() == 0) {
2503       // this field does not have any annotations so skip it
2504       continue;
2505     }
2506 
2507     int byte_i = 0;  // byte index into field_annotations
2508     if (!rewrite_cp_refs_in_annotations_typeArray(field_annotations, byte_i,
2509            THREAD)) {
2510       log_debug(redefine, class, annotation)(&quot;bad field_annotations at %d&quot;, i);
2511       // propagate failure back to caller
2512       return false;
2513     }
2514   }
2515 
2516   return true;
2517 } // end rewrite_cp_refs_in_fields_annotations()
2518 
2519 
2520 // Rewrite constant pool references in a methods_annotations field.
2521 bool VM_RedefineClasses::rewrite_cp_refs_in_methods_annotations(
2522        InstanceKlass* scratch_class, TRAPS) {
2523 
2524   for (int i = 0; i &lt; scratch_class-&gt;methods()-&gt;length(); i++) {
2525     Method* m = scratch_class-&gt;methods()-&gt;at(i);
2526     AnnotationArray* method_annotations = m-&gt;constMethod()-&gt;method_annotations();
2527 
2528     if (method_annotations == NULL || method_annotations-&gt;length() == 0) {
2529       // this method does not have any annotations so skip it
2530       continue;
2531     }
2532 
2533     int byte_i = 0;  // byte index into method_annotations
2534     if (!rewrite_cp_refs_in_annotations_typeArray(method_annotations, byte_i,
2535            THREAD)) {
2536       log_debug(redefine, class, annotation)(&quot;bad method_annotations at %d&quot;, i);
2537       // propagate failure back to caller
2538       return false;
2539     }
2540   }
2541 
2542   return true;
2543 } // end rewrite_cp_refs_in_methods_annotations()
2544 
2545 
2546 // Rewrite constant pool references in a methods_parameter_annotations
2547 // field. This &quot;structure&quot; is adapted from the
2548 // RuntimeVisibleParameterAnnotations_attribute described in section
2549 // 4.8.17 of the 2nd-edition of the VM spec:
2550 //
2551 // methods_parameter_annotations_typeArray {
2552 //   u1 num_parameters;
2553 //   {
2554 //     u2 num_annotations;
2555 //     annotation annotations[num_annotations];
2556 //   } parameter_annotations[num_parameters];
2557 // }
2558 //
2559 bool VM_RedefineClasses::rewrite_cp_refs_in_methods_parameter_annotations(
2560        InstanceKlass* scratch_class, TRAPS) {
2561 
2562   for (int i = 0; i &lt; scratch_class-&gt;methods()-&gt;length(); i++) {
2563     Method* m = scratch_class-&gt;methods()-&gt;at(i);
2564     AnnotationArray* method_parameter_annotations = m-&gt;constMethod()-&gt;parameter_annotations();
2565     if (method_parameter_annotations == NULL
2566         || method_parameter_annotations-&gt;length() == 0) {
2567       // this method does not have any parameter annotations so skip it
2568       continue;
2569     }
2570 
2571     if (method_parameter_annotations-&gt;length() &lt; 1) {
2572       // not enough room for a num_parameters field
2573       log_debug(redefine, class, annotation)(&quot;length() is too small for a num_parameters field at %d&quot;, i);
2574       return false;
2575     }
2576 
2577     int byte_i = 0;  // byte index into method_parameter_annotations
2578 
2579     u1 num_parameters = method_parameter_annotations-&gt;at(byte_i);
2580     byte_i++;
2581 
2582     log_debug(redefine, class, annotation)(&quot;num_parameters=%d&quot;, num_parameters);
2583 
2584     int calc_num_parameters = 0;
2585     for (; calc_num_parameters &lt; num_parameters; calc_num_parameters++) {
2586       if (!rewrite_cp_refs_in_annotations_typeArray(
2587              method_parameter_annotations, byte_i, THREAD)) {
2588         log_debug(redefine, class, annotation)(&quot;bad method_parameter_annotations at %d&quot;, calc_num_parameters);
2589         // propagate failure back to caller
2590         return false;
2591       }
2592     }
2593     assert(num_parameters == calc_num_parameters, &quot;sanity check&quot;);
2594   }
2595 
2596   return true;
2597 } // end rewrite_cp_refs_in_methods_parameter_annotations()
2598 
2599 
2600 // Rewrite constant pool references in a methods_default_annotations
2601 // field. This &quot;structure&quot; is adapted from the AnnotationDefault_attribute
2602 // that is described in section 4.8.19 of the 2nd-edition of the VM spec:
2603 //
2604 // methods_default_annotations_typeArray {
2605 //   element_value default_value;
2606 // }
2607 //
2608 bool VM_RedefineClasses::rewrite_cp_refs_in_methods_default_annotations(
2609        InstanceKlass* scratch_class, TRAPS) {
2610 
2611   for (int i = 0; i &lt; scratch_class-&gt;methods()-&gt;length(); i++) {
2612     Method* m = scratch_class-&gt;methods()-&gt;at(i);
2613     AnnotationArray* method_default_annotations = m-&gt;constMethod()-&gt;default_annotations();
2614     if (method_default_annotations == NULL
2615         || method_default_annotations-&gt;length() == 0) {
2616       // this method does not have any default annotations so skip it
2617       continue;
2618     }
2619 
2620     int byte_i = 0;  // byte index into method_default_annotations
2621 
2622     if (!rewrite_cp_refs_in_element_value(
2623            method_default_annotations, byte_i, THREAD)) {
2624       log_debug(redefine, class, annotation)(&quot;bad default element_value at %d&quot;, i);
2625       // propagate failure back to caller
2626       return false;
2627     }
2628   }
2629 
2630   return true;
2631 } // end rewrite_cp_refs_in_methods_default_annotations()
2632 
2633 
2634 // Rewrite constant pool references in a class_type_annotations field.
2635 bool VM_RedefineClasses::rewrite_cp_refs_in_class_type_annotations(
2636        InstanceKlass* scratch_class, TRAPS) {
2637 
2638   AnnotationArray* class_type_annotations = scratch_class-&gt;class_type_annotations();
2639   if (class_type_annotations == NULL || class_type_annotations-&gt;length() == 0) {
2640     // no class_type_annotations so nothing to do
2641     return true;
2642   }
2643 
2644   log_debug(redefine, class, annotation)(&quot;class_type_annotations length=%d&quot;, class_type_annotations-&gt;length());
2645 
2646   int byte_i = 0;  // byte index into class_type_annotations
2647   return rewrite_cp_refs_in_type_annotations_typeArray(class_type_annotations,
2648       byte_i, &quot;ClassFile&quot;, THREAD);
2649 } // end rewrite_cp_refs_in_class_type_annotations()
2650 
2651 
2652 // Rewrite constant pool references in a fields_type_annotations field.
2653 bool VM_RedefineClasses::rewrite_cp_refs_in_fields_type_annotations(
2654        InstanceKlass* scratch_class, TRAPS) {
2655 
2656   Array&lt;AnnotationArray*&gt;* fields_type_annotations = scratch_class-&gt;fields_type_annotations();
2657   if (fields_type_annotations == NULL || fields_type_annotations-&gt;length() == 0) {
2658     // no fields_type_annotations so nothing to do
2659     return true;
2660   }
2661 
2662   log_debug(redefine, class, annotation)(&quot;fields_type_annotations length=%d&quot;, fields_type_annotations-&gt;length());
2663 
2664   for (int i = 0; i &lt; fields_type_annotations-&gt;length(); i++) {
2665     AnnotationArray* field_type_annotations = fields_type_annotations-&gt;at(i);
2666     if (field_type_annotations == NULL || field_type_annotations-&gt;length() == 0) {
2667       // this field does not have any annotations so skip it
2668       continue;
2669     }
2670 
2671     int byte_i = 0;  // byte index into field_type_annotations
2672     if (!rewrite_cp_refs_in_type_annotations_typeArray(field_type_annotations,
2673            byte_i, &quot;field_info&quot;, THREAD)) {
2674       log_debug(redefine, class, annotation)(&quot;bad field_type_annotations at %d&quot;, i);
2675       // propagate failure back to caller
2676       return false;
2677     }
2678   }
2679 
2680   return true;
2681 } // end rewrite_cp_refs_in_fields_type_annotations()
2682 
2683 
2684 // Rewrite constant pool references in a methods_type_annotations field.
2685 bool VM_RedefineClasses::rewrite_cp_refs_in_methods_type_annotations(
2686        InstanceKlass* scratch_class, TRAPS) {
2687 
2688   for (int i = 0; i &lt; scratch_class-&gt;methods()-&gt;length(); i++) {
2689     Method* m = scratch_class-&gt;methods()-&gt;at(i);
2690     AnnotationArray* method_type_annotations = m-&gt;constMethod()-&gt;type_annotations();
2691 
2692     if (method_type_annotations == NULL || method_type_annotations-&gt;length() == 0) {
2693       // this method does not have any annotations so skip it
2694       continue;
2695     }
2696 
2697     log_debug(redefine, class, annotation)(&quot;methods type_annotations length=%d&quot;, method_type_annotations-&gt;length());
2698 
2699     int byte_i = 0;  // byte index into method_type_annotations
2700     if (!rewrite_cp_refs_in_type_annotations_typeArray(method_type_annotations,
2701            byte_i, &quot;method_info&quot;, THREAD)) {
2702       log_debug(redefine, class, annotation)(&quot;bad method_type_annotations at %d&quot;, i);
2703       // propagate failure back to caller
2704       return false;
2705     }
2706   }
2707 
2708   return true;
2709 } // end rewrite_cp_refs_in_methods_type_annotations()
2710 
2711 
2712 // Rewrite constant pool references in a type_annotations
2713 // field. This &quot;structure&quot; is adapted from the
2714 // RuntimeVisibleTypeAnnotations_attribute described in
2715 // section 4.7.20 of the Java SE 8 Edition of the VM spec:
2716 //
2717 // type_annotations_typeArray {
2718 //   u2              num_annotations;
2719 //   type_annotation annotations[num_annotations];
2720 // }
2721 //
2722 bool VM_RedefineClasses::rewrite_cp_refs_in_type_annotations_typeArray(
2723        AnnotationArray* type_annotations_typeArray, int &amp;byte_i_ref,
2724        const char * location_mesg, TRAPS) {
2725 
2726   if ((byte_i_ref + 2) &gt; type_annotations_typeArray-&gt;length()) {
2727     // not enough room for num_annotations field
2728     log_debug(redefine, class, annotation)(&quot;length() is too small for num_annotations field&quot;);
2729     return false;
2730   }
2731 
2732   u2 num_annotations = Bytes::get_Java_u2((address)
2733                          type_annotations_typeArray-&gt;adr_at(byte_i_ref));
2734   byte_i_ref += 2;
2735 
2736   log_debug(redefine, class, annotation)(&quot;num_type_annotations=%d&quot;, num_annotations);
2737 
2738   int calc_num_annotations = 0;
2739   for (; calc_num_annotations &lt; num_annotations; calc_num_annotations++) {
2740     if (!rewrite_cp_refs_in_type_annotation_struct(type_annotations_typeArray,
2741            byte_i_ref, location_mesg, THREAD)) {
2742       log_debug(redefine, class, annotation)(&quot;bad type_annotation_struct at %d&quot;, calc_num_annotations);
2743       // propagate failure back to caller
2744       return false;
2745     }
2746   }
2747   assert(num_annotations == calc_num_annotations, &quot;sanity check&quot;);
2748 
2749   if (byte_i_ref != type_annotations_typeArray-&gt;length()) {
2750     log_debug(redefine, class, annotation)
2751       (&quot;read wrong amount of bytes at end of processing type_annotations_typeArray (%d of %d bytes were read)&quot;,
2752        byte_i_ref, type_annotations_typeArray-&gt;length());
2753     return false;
2754   }
2755 
2756   return true;
2757 } // end rewrite_cp_refs_in_type_annotations_typeArray()
2758 
2759 
2760 // Rewrite constant pool references in a type_annotation
2761 // field. This &quot;structure&quot; is adapted from the
2762 // RuntimeVisibleTypeAnnotations_attribute described in
2763 // section 4.7.20 of the Java SE 8 Edition of the VM spec:
2764 //
2765 // type_annotation {
2766 //   u1 target_type;
2767 //   union {
2768 //     type_parameter_target;
2769 //     supertype_target;
2770 //     type_parameter_bound_target;
2771 //     empty_target;
2772 //     method_formal_parameter_target;
2773 //     throws_target;
2774 //     localvar_target;
2775 //     catch_target;
2776 //     offset_target;
2777 //     type_argument_target;
2778 //   } target_info;
2779 //   type_path target_path;
2780 //   annotation anno;
2781 // }
2782 //
2783 bool VM_RedefineClasses::rewrite_cp_refs_in_type_annotation_struct(
2784        AnnotationArray* type_annotations_typeArray, int &amp;byte_i_ref,
2785        const char * location_mesg, TRAPS) {
2786 
2787   if (!skip_type_annotation_target(type_annotations_typeArray,
2788          byte_i_ref, location_mesg, THREAD)) {
2789     return false;
2790   }
2791 
2792   if (!skip_type_annotation_type_path(type_annotations_typeArray,
2793          byte_i_ref, THREAD)) {
2794     return false;
2795   }
2796 
2797   if (!rewrite_cp_refs_in_annotation_struct(type_annotations_typeArray,
2798          byte_i_ref, THREAD)) {
2799     return false;
2800   }
2801 
2802   return true;
2803 } // end rewrite_cp_refs_in_type_annotation_struct()
2804 
2805 
2806 // Read, verify and skip over the target_type and target_info part
2807 // so that rewriting can continue in the later parts of the struct.
2808 //
2809 // u1 target_type;
2810 // union {
2811 //   type_parameter_target;
2812 //   supertype_target;
2813 //   type_parameter_bound_target;
2814 //   empty_target;
2815 //   method_formal_parameter_target;
2816 //   throws_target;
2817 //   localvar_target;
2818 //   catch_target;
2819 //   offset_target;
2820 //   type_argument_target;
2821 // } target_info;
2822 //
2823 bool VM_RedefineClasses::skip_type_annotation_target(
2824        AnnotationArray* type_annotations_typeArray, int &amp;byte_i_ref,
2825        const char * location_mesg, TRAPS) {
2826 
2827   if ((byte_i_ref + 1) &gt; type_annotations_typeArray-&gt;length()) {
2828     // not enough room for a target_type let alone the rest of a type_annotation
2829     log_debug(redefine, class, annotation)(&quot;length() is too small for a target_type&quot;);
2830     return false;
2831   }
2832 
2833   u1 target_type = type_annotations_typeArray-&gt;at(byte_i_ref);
2834   byte_i_ref += 1;
2835   log_debug(redefine, class, annotation)(&quot;target_type=0x%.2x&quot;, target_type);
2836   log_debug(redefine, class, annotation)(&quot;location=%s&quot;, location_mesg);
2837 
2838   // Skip over target_info
2839   switch (target_type) {
2840     case 0x00:
2841     // kind: type parameter declaration of generic class or interface
2842     // location: ClassFile
2843     case 0x01:
2844     // kind: type parameter declaration of generic method or constructor
2845     // location: method_info
2846 
2847     {
2848       // struct:
2849       // type_parameter_target {
2850       //   u1 type_parameter_index;
2851       // }
2852       //
2853       if ((byte_i_ref + 1) &gt; type_annotations_typeArray-&gt;length()) {
2854         log_debug(redefine, class, annotation)(&quot;length() is too small for a type_parameter_target&quot;);
2855         return false;
2856       }
2857 
2858       u1 type_parameter_index = type_annotations_typeArray-&gt;at(byte_i_ref);
2859       byte_i_ref += 1;
2860 
2861       log_debug(redefine, class, annotation)(&quot;type_parameter_target: type_parameter_index=%d&quot;, type_parameter_index);
2862     } break;
2863 
2864     case 0x10:
2865     // kind: type in extends clause of class or interface declaration
2866     //       (including the direct superclass of an unsafe anonymous class declaration),
2867     //       or in implements clause of interface declaration
2868     // location: ClassFile
2869 
2870     {
2871       // struct:
2872       // supertype_target {
2873       //   u2 supertype_index;
2874       // }
2875       //
2876       if ((byte_i_ref + 2) &gt; type_annotations_typeArray-&gt;length()) {
2877         log_debug(redefine, class, annotation)(&quot;length() is too small for a supertype_target&quot;);
2878         return false;
2879       }
2880 
2881       u2 supertype_index = Bytes::get_Java_u2((address)
2882                              type_annotations_typeArray-&gt;adr_at(byte_i_ref));
2883       byte_i_ref += 2;
2884 
2885       log_debug(redefine, class, annotation)(&quot;supertype_target: supertype_index=%d&quot;, supertype_index);
2886     } break;
2887 
2888     case 0x11:
2889     // kind: type in bound of type parameter declaration of generic class or interface
2890     // location: ClassFile
2891     case 0x12:
2892     // kind: type in bound of type parameter declaration of generic method or constructor
2893     // location: method_info
2894 
2895     {
2896       // struct:
2897       // type_parameter_bound_target {
2898       //   u1 type_parameter_index;
2899       //   u1 bound_index;
2900       // }
2901       //
2902       if ((byte_i_ref + 2) &gt; type_annotations_typeArray-&gt;length()) {
2903         log_debug(redefine, class, annotation)(&quot;length() is too small for a type_parameter_bound_target&quot;);
2904         return false;
2905       }
2906 
2907       u1 type_parameter_index = type_annotations_typeArray-&gt;at(byte_i_ref);
2908       byte_i_ref += 1;
2909       u1 bound_index = type_annotations_typeArray-&gt;at(byte_i_ref);
2910       byte_i_ref += 1;
2911 
2912       log_debug(redefine, class, annotation)
2913         (&quot;type_parameter_bound_target: type_parameter_index=%d, bound_index=%d&quot;, type_parameter_index, bound_index);
2914     } break;
2915 
2916     case 0x13:
2917     // kind: type in field declaration
2918     // location: field_info
2919     case 0x14:
2920     // kind: return type of method, or type of newly constructed object
2921     // location: method_info
2922     case 0x15:
2923     // kind: receiver type of method or constructor
2924     // location: method_info
2925 
2926     {
2927       // struct:
2928       // empty_target {
2929       // }
2930       //
2931       log_debug(redefine, class, annotation)(&quot;empty_target&quot;);
2932     } break;
2933 
2934     case 0x16:
2935     // kind: type in formal parameter declaration of method, constructor, or lambda expression
2936     // location: method_info
2937 
2938     {
2939       // struct:
2940       // formal_parameter_target {
2941       //   u1 formal_parameter_index;
2942       // }
2943       //
2944       if ((byte_i_ref + 1) &gt; type_annotations_typeArray-&gt;length()) {
2945         log_debug(redefine, class, annotation)(&quot;length() is too small for a formal_parameter_target&quot;);
2946         return false;
2947       }
2948 
2949       u1 formal_parameter_index = type_annotations_typeArray-&gt;at(byte_i_ref);
2950       byte_i_ref += 1;
2951 
2952       log_debug(redefine, class, annotation)
2953         (&quot;formal_parameter_target: formal_parameter_index=%d&quot;, formal_parameter_index);
2954     } break;
2955 
2956     case 0x17:
2957     // kind: type in throws clause of method or constructor
2958     // location: method_info
2959 
2960     {
2961       // struct:
2962       // throws_target {
2963       //   u2 throws_type_index
2964       // }
2965       //
2966       if ((byte_i_ref + 2) &gt; type_annotations_typeArray-&gt;length()) {
2967         log_debug(redefine, class, annotation)(&quot;length() is too small for a throws_target&quot;);
2968         return false;
2969       }
2970 
2971       u2 throws_type_index = Bytes::get_Java_u2((address)
2972                                type_annotations_typeArray-&gt;adr_at(byte_i_ref));
2973       byte_i_ref += 2;
2974 
2975       log_debug(redefine, class, annotation)(&quot;throws_target: throws_type_index=%d&quot;, throws_type_index);
2976     } break;
2977 
2978     case 0x40:
2979     // kind: type in local variable declaration
2980     // location: Code
2981     case 0x41:
2982     // kind: type in resource variable declaration
2983     // location: Code
2984 
2985     {
2986       // struct:
2987       // localvar_target {
2988       //   u2 table_length;
2989       //   struct {
2990       //     u2 start_pc;
2991       //     u2 length;
2992       //     u2 index;
2993       //   } table[table_length];
2994       // }
2995       //
2996       if ((byte_i_ref + 2) &gt; type_annotations_typeArray-&gt;length()) {
2997         // not enough room for a table_length let alone the rest of a localvar_target
2998         log_debug(redefine, class, annotation)(&quot;length() is too small for a localvar_target table_length&quot;);
2999         return false;
3000       }
3001 
3002       u2 table_length = Bytes::get_Java_u2((address)
3003                           type_annotations_typeArray-&gt;adr_at(byte_i_ref));
3004       byte_i_ref += 2;
3005 
3006       log_debug(redefine, class, annotation)(&quot;localvar_target: table_length=%d&quot;, table_length);
3007 
3008       int table_struct_size = 2 + 2 + 2; // 3 u2 variables per table entry
3009       int table_size = table_length * table_struct_size;
3010 
3011       if ((byte_i_ref + table_size) &gt; type_annotations_typeArray-&gt;length()) {
3012         // not enough room for a table
3013         log_debug(redefine, class, annotation)(&quot;length() is too small for a table array of length %d&quot;, table_length);
3014         return false;
3015       }
3016 
3017       // Skip over table
3018       byte_i_ref += table_size;
3019     } break;
3020 
3021     case 0x42:
3022     // kind: type in exception parameter declaration
3023     // location: Code
3024 
3025     {
3026       // struct:
3027       // catch_target {
3028       //   u2 exception_table_index;
3029       // }
3030       //
3031       if ((byte_i_ref + 2) &gt; type_annotations_typeArray-&gt;length()) {
3032         log_debug(redefine, class, annotation)(&quot;length() is too small for a catch_target&quot;);
3033         return false;
3034       }
3035 
3036       u2 exception_table_index = Bytes::get_Java_u2((address)
3037                                    type_annotations_typeArray-&gt;adr_at(byte_i_ref));
3038       byte_i_ref += 2;
3039 
3040       log_debug(redefine, class, annotation)(&quot;catch_target: exception_table_index=%d&quot;, exception_table_index);
3041     } break;
3042 
3043     case 0x43:
3044     // kind: type in instanceof expression
3045     // location: Code
3046     case 0x44:
3047     // kind: type in new expression
3048     // location: Code
3049     case 0x45:
3050     // kind: type in method reference expression using ::new
3051     // location: Code
3052     case 0x46:
3053     // kind: type in method reference expression using ::Identifier
3054     // location: Code
3055 
3056     {
3057       // struct:
3058       // offset_target {
3059       //   u2 offset;
3060       // }
3061       //
3062       if ((byte_i_ref + 2) &gt; type_annotations_typeArray-&gt;length()) {
3063         log_debug(redefine, class, annotation)(&quot;length() is too small for a offset_target&quot;);
3064         return false;
3065       }
3066 
3067       u2 offset = Bytes::get_Java_u2((address)
3068                     type_annotations_typeArray-&gt;adr_at(byte_i_ref));
3069       byte_i_ref += 2;
3070 
3071       log_debug(redefine, class, annotation)(&quot;offset_target: offset=%d&quot;, offset);
3072     } break;
3073 
3074     case 0x47:
3075     // kind: type in cast expression
3076     // location: Code
3077     case 0x48:
3078     // kind: type argument for generic constructor in new expression or
3079     //       explicit constructor invocation statement
3080     // location: Code
3081     case 0x49:
3082     // kind: type argument for generic method in method invocation expression
3083     // location: Code
3084     case 0x4A:
3085     // kind: type argument for generic constructor in method reference expression using ::new
3086     // location: Code
3087     case 0x4B:
3088     // kind: type argument for generic method in method reference expression using ::Identifier
3089     // location: Code
3090 
3091     {
3092       // struct:
3093       // type_argument_target {
3094       //   u2 offset;
3095       //   u1 type_argument_index;
3096       // }
3097       //
3098       if ((byte_i_ref + 3) &gt; type_annotations_typeArray-&gt;length()) {
3099         log_debug(redefine, class, annotation)(&quot;length() is too small for a type_argument_target&quot;);
3100         return false;
3101       }
3102 
3103       u2 offset = Bytes::get_Java_u2((address)
3104                     type_annotations_typeArray-&gt;adr_at(byte_i_ref));
3105       byte_i_ref += 2;
3106       u1 type_argument_index = type_annotations_typeArray-&gt;at(byte_i_ref);
3107       byte_i_ref += 1;
3108 
3109       log_debug(redefine, class, annotation)
3110         (&quot;type_argument_target: offset=%d, type_argument_index=%d&quot;, offset, type_argument_index);
3111     } break;
3112 
3113     default:
3114       log_debug(redefine, class, annotation)(&quot;unknown target_type&quot;);
3115 #ifdef ASSERT
3116       ShouldNotReachHere();
3117 #endif
3118       return false;
3119   }
3120 
3121   return true;
3122 } // end skip_type_annotation_target()
3123 
3124 
3125 // Read, verify and skip over the type_path part so that rewriting
3126 // can continue in the later parts of the struct.
3127 //
3128 // type_path {
3129 //   u1 path_length;
3130 //   {
3131 //     u1 type_path_kind;
3132 //     u1 type_argument_index;
3133 //   } path[path_length];
3134 // }
3135 //
3136 bool VM_RedefineClasses::skip_type_annotation_type_path(
3137        AnnotationArray* type_annotations_typeArray, int &amp;byte_i_ref, TRAPS) {
3138 
3139   if ((byte_i_ref + 1) &gt; type_annotations_typeArray-&gt;length()) {
3140     // not enough room for a path_length let alone the rest of the type_path
3141     log_debug(redefine, class, annotation)(&quot;length() is too small for a type_path&quot;);
3142     return false;
3143   }
3144 
3145   u1 path_length = type_annotations_typeArray-&gt;at(byte_i_ref);
3146   byte_i_ref += 1;
3147 
3148   log_debug(redefine, class, annotation)(&quot;type_path: path_length=%d&quot;, path_length);
3149 
3150   int calc_path_length = 0;
3151   for (; calc_path_length &lt; path_length; calc_path_length++) {
3152     if ((byte_i_ref + 1 + 1) &gt; type_annotations_typeArray-&gt;length()) {
3153       // not enough room for a path
3154       log_debug(redefine, class, annotation)
3155         (&quot;length() is too small for path entry %d of %d&quot;, calc_path_length, path_length);
3156       return false;
3157     }
3158 
3159     u1 type_path_kind = type_annotations_typeArray-&gt;at(byte_i_ref);
3160     byte_i_ref += 1;
3161     u1 type_argument_index = type_annotations_typeArray-&gt;at(byte_i_ref);
3162     byte_i_ref += 1;
3163 
3164     log_debug(redefine, class, annotation)
3165       (&quot;type_path: path[%d]: type_path_kind=%d, type_argument_index=%d&quot;,
3166        calc_path_length, type_path_kind, type_argument_index);
3167 
3168     if (type_path_kind &gt; 3 || (type_path_kind != 3 &amp;&amp; type_argument_index != 0)) {
3169       // not enough room for a path
3170       log_debug(redefine, class, annotation)(&quot;inconsistent type_path values&quot;);
3171       return false;
3172     }
3173   }
3174   assert(path_length == calc_path_length, &quot;sanity check&quot;);
3175 
3176   return true;
3177 } // end skip_type_annotation_type_path()
3178 
3179 
3180 // Rewrite constant pool references in the method&#39;s stackmap table.
3181 // These &quot;structures&quot; are adapted from the StackMapTable_attribute that
3182 // is described in section 4.8.4 of the 6.0 version of the VM spec
3183 // (dated 2005.10.26):
3184 // file:///net/quincunx.sfbay/export/gbracha/ClassFile-Java6.pdf
3185 //
3186 // stack_map {
3187 //   u2 number_of_entries;
3188 //   stack_map_frame entries[number_of_entries];
3189 // }
3190 //
3191 void VM_RedefineClasses::rewrite_cp_refs_in_stack_map_table(
3192        const methodHandle&amp; method, TRAPS) {
3193 
3194   if (!method-&gt;has_stackmap_table()) {
3195     return;
3196   }
3197 
3198   AnnotationArray* stackmap_data = method-&gt;stackmap_data();
3199   address stackmap_p = (address)stackmap_data-&gt;adr_at(0);
3200   address stackmap_end = stackmap_p + stackmap_data-&gt;length();
3201 
3202   assert(stackmap_p + 2 &lt;= stackmap_end, &quot;no room for number_of_entries&quot;);
3203   u2 number_of_entries = Bytes::get_Java_u2(stackmap_p);
3204   stackmap_p += 2;
3205 
3206   log_debug(redefine, class, stackmap)(&quot;number_of_entries=%u&quot;, number_of_entries);
3207 
3208   // walk through each stack_map_frame
3209   u2 calc_number_of_entries = 0;
3210   for (; calc_number_of_entries &lt; number_of_entries; calc_number_of_entries++) {
3211     // The stack_map_frame structure is a u1 frame_type followed by
3212     // 0 or more bytes of data:
3213     //
3214     // union stack_map_frame {
3215     //   same_frame;
3216     //   same_locals_1_stack_item_frame;
3217     //   same_locals_1_stack_item_frame_extended;
3218     //   chop_frame;
3219     //   same_frame_extended;
3220     //   append_frame;
3221     //   full_frame;
3222     // }
3223 
3224     assert(stackmap_p + 1 &lt;= stackmap_end, &quot;no room for frame_type&quot;);
3225     u1 frame_type = *stackmap_p;
3226     stackmap_p++;
3227 
3228     // same_frame {
3229     //   u1 frame_type = SAME; /* 0-63 */
3230     // }
3231     if (frame_type &lt;= 63) {
3232       // nothing more to do for same_frame
3233     }
3234 
3235     // same_locals_1_stack_item_frame {
3236     //   u1 frame_type = SAME_LOCALS_1_STACK_ITEM; /* 64-127 */
3237     //   verification_type_info stack[1];
3238     // }
3239     else if (frame_type &gt;= 64 &amp;&amp; frame_type &lt;= 127) {
3240       rewrite_cp_refs_in_verification_type_info(stackmap_p, stackmap_end,
3241         calc_number_of_entries, frame_type, THREAD);
3242     }
3243 
3244     // reserved for future use
3245     else if (frame_type &gt;= 128 &amp;&amp; frame_type &lt;= 246) {
3246       // nothing more to do for reserved frame_types
3247     }
3248 
3249     // same_locals_1_stack_item_frame_extended {
3250     //   u1 frame_type = SAME_LOCALS_1_STACK_ITEM_EXTENDED; /* 247 */
3251     //   u2 offset_delta;
3252     //   verification_type_info stack[1];
3253     // }
3254     else if (frame_type == 247) {
3255       stackmap_p += 2;
3256       rewrite_cp_refs_in_verification_type_info(stackmap_p, stackmap_end,
3257         calc_number_of_entries, frame_type, THREAD);
3258     }
3259 
3260     // chop_frame {
3261     //   u1 frame_type = CHOP; /* 248-250 */
3262     //   u2 offset_delta;
3263     // }
3264     else if (frame_type &gt;= 248 &amp;&amp; frame_type &lt;= 250) {
3265       stackmap_p += 2;
3266     }
3267 
3268     // same_frame_extended {
3269     //   u1 frame_type = SAME_FRAME_EXTENDED; /* 251*/
3270     //   u2 offset_delta;
3271     // }
3272     else if (frame_type == 251) {
3273       stackmap_p += 2;
3274     }
3275 
3276     // append_frame {
3277     //   u1 frame_type = APPEND; /* 252-254 */
3278     //   u2 offset_delta;
3279     //   verification_type_info locals[frame_type - 251];
3280     // }
3281     else if (frame_type &gt;= 252 &amp;&amp; frame_type &lt;= 254) {
3282       assert(stackmap_p + 2 &lt;= stackmap_end,
3283         &quot;no room for offset_delta&quot;);
3284       stackmap_p += 2;
3285       u1 len = frame_type - 251;
3286       for (u1 i = 0; i &lt; len; i++) {
3287         rewrite_cp_refs_in_verification_type_info(stackmap_p, stackmap_end,
3288           calc_number_of_entries, frame_type, THREAD);
3289       }
3290     }
3291 
3292     // full_frame {
3293     //   u1 frame_type = FULL_FRAME; /* 255 */
3294     //   u2 offset_delta;
3295     //   u2 number_of_locals;
3296     //   verification_type_info locals[number_of_locals];
3297     //   u2 number_of_stack_items;
3298     //   verification_type_info stack[number_of_stack_items];
3299     // }
3300     else if (frame_type == 255) {
3301       assert(stackmap_p + 2 + 2 &lt;= stackmap_end,
3302         &quot;no room for smallest full_frame&quot;);
3303       stackmap_p += 2;
3304 
3305       u2 number_of_locals = Bytes::get_Java_u2(stackmap_p);
3306       stackmap_p += 2;
3307 
3308       for (u2 locals_i = 0; locals_i &lt; number_of_locals; locals_i++) {
3309         rewrite_cp_refs_in_verification_type_info(stackmap_p, stackmap_end,
3310           calc_number_of_entries, frame_type, THREAD);
3311       }
3312 
3313       // Use the largest size for the number_of_stack_items, but only get
3314       // the right number of bytes.
3315       u2 number_of_stack_items = Bytes::get_Java_u2(stackmap_p);
3316       stackmap_p += 2;
3317 
3318       for (u2 stack_i = 0; stack_i &lt; number_of_stack_items; stack_i++) {
3319         rewrite_cp_refs_in_verification_type_info(stackmap_p, stackmap_end,
3320           calc_number_of_entries, frame_type, THREAD);
3321       }
3322     }
3323   } // end while there is a stack_map_frame
3324   assert(number_of_entries == calc_number_of_entries, &quot;sanity check&quot;);
3325 } // end rewrite_cp_refs_in_stack_map_table()
3326 
3327 
3328 // Rewrite constant pool references in the verification type info
3329 // portion of the method&#39;s stackmap table. These &quot;structures&quot; are
3330 // adapted from the StackMapTable_attribute that is described in
3331 // section 4.8.4 of the 6.0 version of the VM spec (dated 2005.10.26):
3332 // file:///net/quincunx.sfbay/export/gbracha/ClassFile-Java6.pdf
3333 //
3334 // The verification_type_info structure is a u1 tag followed by 0 or
3335 // more bytes of data:
3336 //
3337 // union verification_type_info {
3338 //   Top_variable_info;
3339 //   Integer_variable_info;
3340 //   Float_variable_info;
3341 //   Long_variable_info;
3342 //   Double_variable_info;
3343 //   Null_variable_info;
3344 //   UninitializedThis_variable_info;
3345 //   Object_variable_info;
3346 //   Uninitialized_variable_info;
3347 // }
3348 //
3349 void VM_RedefineClasses::rewrite_cp_refs_in_verification_type_info(
3350        address&amp; stackmap_p_ref, address stackmap_end, u2 frame_i,
3351        u1 frame_type, TRAPS) {
3352 
3353   assert(stackmap_p_ref + 1 &lt;= stackmap_end, &quot;no room for tag&quot;);
3354   u1 tag = *stackmap_p_ref;
3355   stackmap_p_ref++;
3356 
3357   switch (tag) {
3358   // Top_variable_info {
3359   //   u1 tag = ITEM_Top; /* 0 */
3360   // }
3361   // verificationType.hpp has zero as ITEM_Bogus instead of ITEM_Top
3362   case 0:  // fall through
3363 
3364   // Integer_variable_info {
3365   //   u1 tag = ITEM_Integer; /* 1 */
3366   // }
3367   case ITEM_Integer:  // fall through
3368 
3369   // Float_variable_info {
3370   //   u1 tag = ITEM_Float; /* 2 */
3371   // }
3372   case ITEM_Float:  // fall through
3373 
3374   // Double_variable_info {
3375   //   u1 tag = ITEM_Double; /* 3 */
3376   // }
3377   case ITEM_Double:  // fall through
3378 
3379   // Long_variable_info {
3380   //   u1 tag = ITEM_Long; /* 4 */
3381   // }
3382   case ITEM_Long:  // fall through
3383 
3384   // Null_variable_info {
3385   //   u1 tag = ITEM_Null; /* 5 */
3386   // }
3387   case ITEM_Null:  // fall through
3388 
3389   // UninitializedThis_variable_info {
3390   //   u1 tag = ITEM_UninitializedThis; /* 6 */
3391   // }
3392   case ITEM_UninitializedThis:
3393     // nothing more to do for the above tag types
3394     break;
3395 
3396   // Object_variable_info {
3397   //   u1 tag = ITEM_Object; /* 7 */
3398   //   u2 cpool_index;
3399   // }
3400   case ITEM_Object:
3401   {
3402     assert(stackmap_p_ref + 2 &lt;= stackmap_end, &quot;no room for cpool_index&quot;);
3403     u2 cpool_index = Bytes::get_Java_u2(stackmap_p_ref);
3404     u2 new_cp_index = find_new_index(cpool_index);
3405     if (new_cp_index != 0) {
3406       log_debug(redefine, class, stackmap)(&quot;mapped old cpool_index=%d&quot;, cpool_index);
3407       Bytes::put_Java_u2(stackmap_p_ref, new_cp_index);
3408       cpool_index = new_cp_index;
3409     }
3410     stackmap_p_ref += 2;
3411 
3412     log_debug(redefine, class, stackmap)
3413       (&quot;frame_i=%u, frame_type=%u, cpool_index=%d&quot;, frame_i, frame_type, cpool_index);
3414   } break;
3415 
3416   // Uninitialized_variable_info {
3417   //   u1 tag = ITEM_Uninitialized; /* 8 */
3418   //   u2 offset;
3419   // }
3420   case ITEM_Uninitialized:
3421     assert(stackmap_p_ref + 2 &lt;= stackmap_end, &quot;no room for offset&quot;);
3422     stackmap_p_ref += 2;
3423     break;
3424 
3425   default:
3426     log_debug(redefine, class, stackmap)(&quot;frame_i=%u, frame_type=%u, bad tag=0x%x&quot;, frame_i, frame_type, tag);
3427     ShouldNotReachHere();
3428     break;
3429   } // end switch (tag)
3430 } // end rewrite_cp_refs_in_verification_type_info()
3431 
3432 
3433 // Change the constant pool associated with klass scratch_class to
3434 // scratch_cp. If shrink is true, then scratch_cp_length elements
3435 // are copied from scratch_cp to a smaller constant pool and the
3436 // smaller constant pool is associated with scratch_class.
3437 void VM_RedefineClasses::set_new_constant_pool(
3438        ClassLoaderData* loader_data,
3439        InstanceKlass* scratch_class, constantPoolHandle scratch_cp,
3440        int scratch_cp_length, TRAPS) {
3441   assert(scratch_cp-&gt;length() &gt;= scratch_cp_length, &quot;sanity check&quot;);
3442 
3443   // scratch_cp is a merged constant pool and has enough space for a
3444   // worst case merge situation. We want to associate the minimum
3445   // sized constant pool with the klass to save space.
3446   ConstantPool* cp = ConstantPool::allocate(loader_data, scratch_cp_length, CHECK);
3447   constantPoolHandle smaller_cp(THREAD, cp);
3448 
3449   // preserve version() value in the smaller copy
3450   int version = scratch_cp-&gt;version();
3451   assert(version != 0, &quot;sanity check&quot;);
3452   smaller_cp-&gt;set_version(version);
3453 
3454   // attach klass to new constant pool
3455   // reference to the cp holder is needed for copy_operands()
3456   smaller_cp-&gt;set_pool_holder(scratch_class);
3457 
3458   smaller_cp-&gt;copy_fields(scratch_cp());
3459 
3460   scratch_cp-&gt;copy_cp_to(1, scratch_cp_length - 1, smaller_cp, 1, THREAD);
3461   if (HAS_PENDING_EXCEPTION) {
3462     // Exception is handled in the caller
3463     loader_data-&gt;add_to_deallocate_list(smaller_cp());
3464     return;
3465   }
3466   scratch_cp = smaller_cp;
3467 
3468   // attach new constant pool to klass
3469   scratch_class-&gt;set_constants(scratch_cp());
3470   scratch_cp-&gt;initialize_unresolved_klasses(loader_data, CHECK);
3471 
3472   int i;  // for portability
3473 
3474   // update each field in klass to use new constant pool indices as needed
3475   for (JavaFieldStream fs(scratch_class); !fs.done(); fs.next()) {
3476     jshort cur_index = fs.name_index();
3477     jshort new_index = find_new_index(cur_index);
3478     if (new_index != 0) {
3479       log_trace(redefine, class, constantpool)(&quot;field-name_index change: %d to %d&quot;, cur_index, new_index);
3480       fs.set_name_index(new_index);
3481     }
3482     cur_index = fs.signature_index();
3483     new_index = find_new_index(cur_index);
3484     if (new_index != 0) {
3485       log_trace(redefine, class, constantpool)(&quot;field-signature_index change: %d to %d&quot;, cur_index, new_index);
3486       fs.set_signature_index(new_index);
3487     }
3488     cur_index = fs.initval_index();
3489     new_index = find_new_index(cur_index);
3490     if (new_index != 0) {
3491       log_trace(redefine, class, constantpool)(&quot;field-initval_index change: %d to %d&quot;, cur_index, new_index);
3492       fs.set_initval_index(new_index);
3493     }
3494     cur_index = fs.generic_signature_index();
3495     new_index = find_new_index(cur_index);
3496     if (new_index != 0) {
3497       log_trace(redefine, class, constantpool)(&quot;field-generic_signature change: %d to %d&quot;, cur_index, new_index);
3498       fs.set_generic_signature_index(new_index);
3499     }
3500   } // end for each field
3501 
3502   // Update constant pool indices in the inner classes info to use
3503   // new constant indices as needed. The inner classes info is a
3504   // quadruple:
3505   // (inner_class_info, outer_class_info, inner_name, inner_access_flags)
3506   InnerClassesIterator iter(scratch_class);
3507   for (; !iter.done(); iter.next()) {
3508     int cur_index = iter.inner_class_info_index();
3509     if (cur_index == 0) {
3510       continue;  // JVM spec. allows null inner class refs so skip it
3511     }
3512     int new_index = find_new_index(cur_index);
3513     if (new_index != 0) {
3514       log_trace(redefine, class, constantpool)(&quot;inner_class_info change: %d to %d&quot;, cur_index, new_index);
3515       iter.set_inner_class_info_index(new_index);
3516     }
3517     cur_index = iter.outer_class_info_index();
3518     new_index = find_new_index(cur_index);
3519     if (new_index != 0) {
3520       log_trace(redefine, class, constantpool)(&quot;outer_class_info change: %d to %d&quot;, cur_index, new_index);
3521       iter.set_outer_class_info_index(new_index);
3522     }
3523     cur_index = iter.inner_name_index();
3524     new_index = find_new_index(cur_index);
3525     if (new_index != 0) {
3526       log_trace(redefine, class, constantpool)(&quot;inner_name change: %d to %d&quot;, cur_index, new_index);
3527       iter.set_inner_name_index(new_index);
3528     }
3529   } // end for each inner class
3530 
3531   // Attach each method in klass to the new constant pool and update
3532   // to use new constant pool indices as needed:
3533   Array&lt;Method*&gt;* methods = scratch_class-&gt;methods();
3534   for (i = methods-&gt;length() - 1; i &gt;= 0; i--) {
3535     methodHandle method(THREAD, methods-&gt;at(i));
3536     method-&gt;set_constants(scratch_cp());
3537 
3538     int new_index = find_new_index(method-&gt;name_index());
3539     if (new_index != 0) {
3540       log_trace(redefine, class, constantpool)
3541         (&quot;method-name_index change: %d to %d&quot;, method-&gt;name_index(), new_index);
3542       method-&gt;set_name_index(new_index);
3543     }
3544     new_index = find_new_index(method-&gt;signature_index());
3545     if (new_index != 0) {
3546       log_trace(redefine, class, constantpool)
3547         (&quot;method-signature_index change: %d to %d&quot;, method-&gt;signature_index(), new_index);
3548       method-&gt;set_signature_index(new_index);
3549     }
3550     new_index = find_new_index(method-&gt;generic_signature_index());
3551     if (new_index != 0) {
3552       log_trace(redefine, class, constantpool)
3553         (&quot;method-generic_signature_index change: %d to %d&quot;, method-&gt;generic_signature_index(), new_index);
3554       method-&gt;set_generic_signature_index(new_index);
3555     }
3556 
3557     // Update constant pool indices in the method&#39;s checked exception
3558     // table to use new constant indices as needed.
3559     int cext_length = method-&gt;checked_exceptions_length();
3560     if (cext_length &gt; 0) {
3561       CheckedExceptionElement * cext_table =
3562         method-&gt;checked_exceptions_start();
3563       for (int j = 0; j &lt; cext_length; j++) {
3564         int cur_index = cext_table[j].class_cp_index;
3565         int new_index = find_new_index(cur_index);
3566         if (new_index != 0) {
3567           log_trace(redefine, class, constantpool)(&quot;cext-class_cp_index change: %d to %d&quot;, cur_index, new_index);
3568           cext_table[j].class_cp_index = (u2)new_index;
3569         }
3570       } // end for each checked exception table entry
3571     } // end if there are checked exception table entries
3572 
3573     // Update each catch type index in the method&#39;s exception table
3574     // to use new constant pool indices as needed. The exception table
3575     // holds quadruple entries of the form:
3576     //   (beg_bci, end_bci, handler_bci, klass_index)
3577 
3578     ExceptionTable ex_table(method());
3579     int ext_length = ex_table.length();
3580 
3581     for (int j = 0; j &lt; ext_length; j ++) {
3582       int cur_index = ex_table.catch_type_index(j);
3583       int new_index = find_new_index(cur_index);
3584       if (new_index != 0) {
3585         log_trace(redefine, class, constantpool)(&quot;ext-klass_index change: %d to %d&quot;, cur_index, new_index);
3586         ex_table.set_catch_type_index(j, new_index);
3587       }
3588     } // end for each exception table entry
3589 
3590     // Update constant pool indices in the method&#39;s local variable
3591     // table to use new constant indices as needed. The local variable
3592     // table hold sextuple entries of the form:
3593     // (start_pc, length, name_index, descriptor_index, signature_index, slot)
3594     int lvt_length = method-&gt;localvariable_table_length();
3595     if (lvt_length &gt; 0) {
3596       LocalVariableTableElement * lv_table =
3597         method-&gt;localvariable_table_start();
3598       for (int j = 0; j &lt; lvt_length; j++) {
3599         int cur_index = lv_table[j].name_cp_index;
3600         int new_index = find_new_index(cur_index);
3601         if (new_index != 0) {
3602           log_trace(redefine, class, constantpool)(&quot;lvt-name_cp_index change: %d to %d&quot;, cur_index, new_index);
3603           lv_table[j].name_cp_index = (u2)new_index;
3604         }
3605         cur_index = lv_table[j].descriptor_cp_index;
3606         new_index = find_new_index(cur_index);
3607         if (new_index != 0) {
3608           log_trace(redefine, class, constantpool)(&quot;lvt-descriptor_cp_index change: %d to %d&quot;, cur_index, new_index);
3609           lv_table[j].descriptor_cp_index = (u2)new_index;
3610         }
3611         cur_index = lv_table[j].signature_cp_index;
3612         new_index = find_new_index(cur_index);
3613         if (new_index != 0) {
3614           log_trace(redefine, class, constantpool)(&quot;lvt-signature_cp_index change: %d to %d&quot;, cur_index, new_index);
3615           lv_table[j].signature_cp_index = (u2)new_index;
3616         }
3617       } // end for each local variable table entry
3618     } // end if there are local variable table entries
3619 
3620     rewrite_cp_refs_in_stack_map_table(method, THREAD);
3621   } // end for each method
3622 } // end set_new_constant_pool()
3623 
3624 
3625 // Unevolving classes may point to methods of the_class directly
3626 // from their constant pool caches, itables, and/or vtables. We
3627 // use the ClassLoaderDataGraph::classes_do() facility and this helper
3628 // to fix up these pointers.  MethodData also points to old methods and
3629 // must be cleaned.
3630 
3631 // Adjust cpools and vtables closure
3632 void VM_RedefineClasses::AdjustAndCleanMetadata::do_klass(Klass* k) {
3633 
3634   // This is a very busy routine. We don&#39;t want too much tracing
3635   // printed out.
3636   bool trace_name_printed = false;
3637 
3638   // If the class being redefined is java.lang.Object, we need to fix all
3639   // array class vtables also
3640   if (k-&gt;is_array_klass() &amp;&amp; _has_redefined_Object) {
3641     k-&gt;vtable().adjust_method_entries(&amp;trace_name_printed);
3642 
3643   } else if (k-&gt;is_instance_klass()) {
3644     HandleMark hm(_thread);
3645     InstanceKlass *ik = InstanceKlass::cast(k);
3646 
3647     // Clean MethodData of this class&#39;s methods so they don&#39;t refer to
3648     // old methods that are no longer running.
3649     Array&lt;Method*&gt;* methods = ik-&gt;methods();
3650     int num_methods = methods-&gt;length();
3651     for (int index = 0; index &lt; num_methods; ++index) {
3652       if (methods-&gt;at(index)-&gt;method_data() != NULL) {
3653         methods-&gt;at(index)-&gt;method_data()-&gt;clean_weak_method_links();
3654       }
3655     }
3656 
3657     // HotSpot specific optimization! HotSpot does not currently
3658     // support delegation from the bootstrap class loader to a
3659     // user-defined class loader. This means that if the bootstrap
3660     // class loader is the initiating class loader, then it will also
3661     // be the defining class loader. This also means that classes
3662     // loaded by the bootstrap class loader cannot refer to classes
3663     // loaded by a user-defined class loader. Note: a user-defined
3664     // class loader can delegate to the bootstrap class loader.
3665     //
3666     // If the current class being redefined has a user-defined class
3667     // loader as its defining class loader, then we can skip all
3668     // classes loaded by the bootstrap class loader.
3669     if (!_has_null_class_loader &amp;&amp; ik-&gt;class_loader() == NULL) {
3670       return;
3671     }
3672 
3673     // Adjust all vtables, default methods and itables, to clean out old methods.
3674     ResourceMark rm(_thread);
3675     if (ik-&gt;vtable_length() &gt; 0) {
3676       ik-&gt;vtable().adjust_method_entries(&amp;trace_name_printed);
3677       ik-&gt;adjust_default_methods(&amp;trace_name_printed);
3678     }
3679 
3680     if (ik-&gt;itable_length() &gt; 0) {
3681       ik-&gt;itable().adjust_method_entries(&amp;trace_name_printed);
3682     }
3683 
3684     // The constant pools in other classes (other_cp) can refer to
3685     // old methods.  We have to update method information in
3686     // other_cp&#39;s cache. If other_cp has a previous version, then we
3687     // have to repeat the process for each previous version. The
3688     // constant pool cache holds the Method*s for non-virtual
3689     // methods and for virtual, final methods.
3690     //
3691     // Special case: if the current class being redefined, then new_cp
3692     // has already been attached to the_class and old_cp has already
3693     // been added as a previous version. The new_cp doesn&#39;t have any
3694     // cached references to old methods so it doesn&#39;t need to be
3695     // updated. We can simply start with the previous version(s) in
3696     // that case.
3697     ConstantPoolCache* cp_cache;
3698 
3699     if (!ik-&gt;is_being_redefined()) {
3700       // this klass&#39; constant pool cache may need adjustment
3701       ConstantPool* other_cp = ik-&gt;constants();
3702       cp_cache = other_cp-&gt;cache();
3703       if (cp_cache != NULL) {
3704         cp_cache-&gt;adjust_method_entries(&amp;trace_name_printed);
3705       }
3706     }
3707 
3708     // the previous versions&#39; constant pool caches may need adjustment
3709     for (InstanceKlass* pv_node = ik-&gt;previous_versions();
3710          pv_node != NULL;
3711          pv_node = pv_node-&gt;previous_versions()) {
3712       cp_cache = pv_node-&gt;constants()-&gt;cache();
3713       if (cp_cache != NULL) {
3714         cp_cache-&gt;adjust_method_entries(&amp;trace_name_printed);
3715       }
3716     }
3717   }
3718 }
3719 
3720 void VM_RedefineClasses::update_jmethod_ids(Thread* thread) {
3721   for (int j = 0; j &lt; _matching_methods_length; ++j) {
3722     Method* old_method = _matching_old_methods[j];
3723     jmethodID jmid = old_method-&gt;find_jmethod_id_or_null();
3724     if (jmid != NULL) {
3725       // There is a jmethodID, change it to point to the new method
3726       methodHandle new_method_h(thread, _matching_new_methods[j]);
3727       Method::change_method_associated_with_jmethod_id(jmid, new_method_h());
3728       assert(Method::resolve_jmethod_id(jmid) == _matching_new_methods[j],
3729              &quot;should be replaced&quot;);
3730     }
3731   }
3732 }
3733 
3734 int VM_RedefineClasses::check_methods_and_mark_as_obsolete() {
3735   int emcp_method_count = 0;
3736   int obsolete_count = 0;
3737   int old_index = 0;
3738   for (int j = 0; j &lt; _matching_methods_length; ++j, ++old_index) {
3739     Method* old_method = _matching_old_methods[j];
3740     Method* new_method = _matching_new_methods[j];
3741     Method* old_array_method;
3742 
3743     // Maintain an old_index into the _old_methods array by skipping
3744     // deleted methods
3745     while ((old_array_method = _old_methods-&gt;at(old_index)) != old_method) {
3746       ++old_index;
3747     }
3748 
3749     if (MethodComparator::methods_EMCP(old_method, new_method)) {
3750       // The EMCP definition from JSR-163 requires the bytecodes to be
3751       // the same with the exception of constant pool indices which may
3752       // differ. However, the constants referred to by those indices
3753       // must be the same.
3754       //
3755       // We use methods_EMCP() for comparison since constant pool
3756       // merging can remove duplicate constant pool entries that were
3757       // present in the old method and removed from the rewritten new
3758       // method. A faster binary comparison function would consider the
3759       // old and new methods to be different when they are actually
3760       // EMCP.
3761       //
3762       // The old and new methods are EMCP and you would think that we
3763       // could get rid of one of them here and now and save some space.
3764       // However, the concept of EMCP only considers the bytecodes and
3765       // the constant pool entries in the comparison. Other things,
3766       // e.g., the line number table (LNT) or the local variable table
3767       // (LVT) don&#39;t count in the comparison. So the new (and EMCP)
3768       // method can have a new LNT that we need so we can&#39;t just
3769       // overwrite the new method with the old method.
3770       //
3771       // When this routine is called, we have already attached the new
3772       // methods to the_class so the old methods are effectively
3773       // overwritten. However, if an old method is still executing,
3774       // then the old method cannot be collected until sometime after
3775       // the old method call has returned. So the overwriting of old
3776       // methods by new methods will save us space except for those
3777       // (hopefully few) old methods that are still executing.
3778       //
3779       // A method refers to a ConstMethod* and this presents another
3780       // possible avenue to space savings. The ConstMethod* in the
3781       // new method contains possibly new attributes (LNT, LVT, etc).
3782       // At first glance, it seems possible to save space by replacing
3783       // the ConstMethod* in the old method with the ConstMethod*
3784       // from the new method. The old and new methods would share the
3785       // same ConstMethod* and we would save the space occupied by
3786       // the old ConstMethod*. However, the ConstMethod* contains
3787       // a back reference to the containing method. Sharing the
3788       // ConstMethod* between two methods could lead to confusion in
3789       // the code that uses the back reference. This would lead to
3790       // brittle code that could be broken in non-obvious ways now or
3791       // in the future.
3792       //
3793       // Another possibility is to copy the ConstMethod* from the new
3794       // method to the old method and then overwrite the new method with
3795       // the old method. Since the ConstMethod* contains the bytecodes
3796       // for the method embedded in the oop, this option would change
3797       // the bytecodes out from under any threads executing the old
3798       // method and make the thread&#39;s bcp invalid. Since EMCP requires
3799       // that the bytecodes be the same modulo constant pool indices, it
3800       // is straight forward to compute the correct new bcp in the new
3801       // ConstMethod* from the old bcp in the old ConstMethod*. The
3802       // time consuming part would be searching all the frames in all
3803       // of the threads to find all of the calls to the old method.
3804       //
3805       // It looks like we will have to live with the limited savings
3806       // that we get from effectively overwriting the old methods
3807       // when the new methods are attached to the_class.
3808 
3809       // Count number of methods that are EMCP.  The method will be marked
3810       // old but not obsolete if it is EMCP.
3811       emcp_method_count++;
3812 
3813       // An EMCP method is _not_ obsolete. An obsolete method has a
3814       // different jmethodID than the current method. An EMCP method
3815       // has the same jmethodID as the current method. Having the
3816       // same jmethodID for all EMCP versions of a method allows for
3817       // a consistent view of the EMCP methods regardless of which
3818       // EMCP method you happen to have in hand. For example, a
3819       // breakpoint set in one EMCP method will work for all EMCP
3820       // versions of the method including the current one.
3821     } else {
3822       // mark obsolete methods as such
3823       old_method-&gt;set_is_obsolete();
3824       obsolete_count++;
3825 
3826       // obsolete methods need a unique idnum so they become new entries in
3827       // the jmethodID cache in InstanceKlass
3828       assert(old_method-&gt;method_idnum() == new_method-&gt;method_idnum(), &quot;must match&quot;);
3829       u2 num = InstanceKlass::cast(_the_class)-&gt;next_method_idnum();
3830       if (num != ConstMethod::UNSET_IDNUM) {
3831         old_method-&gt;set_method_idnum(num);
3832       }
3833 
3834       // With tracing we try not to &quot;yack&quot; too much. The position of
3835       // this trace assumes there are fewer obsolete methods than
3836       // EMCP methods.
3837       if (log_is_enabled(Trace, redefine, class, obsolete, mark)) {
3838         ResourceMark rm;
3839         log_trace(redefine, class, obsolete, mark)
3840           (&quot;mark %s(%s) as obsolete&quot;, old_method-&gt;name()-&gt;as_C_string(), old_method-&gt;signature()-&gt;as_C_string());
3841       }
3842     }
3843     old_method-&gt;set_is_old();
3844   }
3845   for (int i = 0; i &lt; _deleted_methods_length; ++i) {
3846     Method* old_method = _deleted_methods[i];
3847 
3848     assert(!old_method-&gt;has_vtable_index(),
3849            &quot;cannot delete methods with vtable entries&quot;);;
3850 
3851     // Mark all deleted methods as old, obsolete and deleted
3852     old_method-&gt;set_is_deleted();
3853     old_method-&gt;set_is_old();
3854     old_method-&gt;set_is_obsolete();
3855     ++obsolete_count;
3856     // With tracing we try not to &quot;yack&quot; too much. The position of
3857     // this trace assumes there are fewer obsolete methods than
3858     // EMCP methods.
3859     if (log_is_enabled(Trace, redefine, class, obsolete, mark)) {
3860       ResourceMark rm;
3861       log_trace(redefine, class, obsolete, mark)
3862         (&quot;mark deleted %s(%s) as obsolete&quot;, old_method-&gt;name()-&gt;as_C_string(), old_method-&gt;signature()-&gt;as_C_string());
3863     }
3864   }
3865   assert((emcp_method_count + obsolete_count) == _old_methods-&gt;length(),
3866     &quot;sanity check&quot;);
3867   log_trace(redefine, class, obsolete, mark)(&quot;EMCP_cnt=%d, obsolete_cnt=%d&quot;, emcp_method_count, obsolete_count);
3868   return emcp_method_count;
3869 }
3870 
3871 // This internal class transfers the native function registration from old methods
3872 // to new methods.  It is designed to handle both the simple case of unchanged
3873 // native methods and the complex cases of native method prefixes being added and/or
3874 // removed.
3875 // It expects only to be used during the VM_RedefineClasses op (a safepoint).
3876 //
3877 // This class is used after the new methods have been installed in &quot;the_class&quot;.
3878 //
3879 // So, for example, the following must be handled.  Where &#39;m&#39; is a method and
3880 // a number followed by an underscore is a prefix.
3881 //
3882 //                                      Old Name    New Name
3883 // Simple transfer to new method        m       -&gt;  m
3884 // Add prefix                           m       -&gt;  1_m
3885 // Remove prefix                        1_m     -&gt;  m
3886 // Simultaneous add of prefixes         m       -&gt;  3_2_1_m
3887 // Simultaneous removal of prefixes     3_2_1_m -&gt;  m
3888 // Simultaneous add and remove          1_m     -&gt;  2_m
3889 // Same, caused by prefix removal only  3_2_1_m -&gt;  3_2_m
3890 //
3891 class TransferNativeFunctionRegistration {
3892  private:
3893   InstanceKlass* the_class;
3894   int prefix_count;
3895   char** prefixes;
3896 
3897   // Recursively search the binary tree of possibly prefixed method names.
3898   // Iteration could be used if all agents were well behaved. Full tree walk is
3899   // more resilent to agents not cleaning up intermediate methods.
3900   // Branch at each depth in the binary tree is:
3901   //    (1) without the prefix.
3902   //    (2) with the prefix.
3903   // where &#39;prefix&#39; is the prefix at that &#39;depth&#39; (first prefix, second prefix,...)
3904   Method* search_prefix_name_space(int depth, char* name_str, size_t name_len,
3905                                      Symbol* signature) {
3906     TempNewSymbol name_symbol = SymbolTable::probe(name_str, (int)name_len);
3907     if (name_symbol != NULL) {
3908       Method* method = the_class-&gt;lookup_method(name_symbol, signature);
3909       if (method != NULL) {
3910         // Even if prefixed, intermediate methods must exist.
3911         if (method-&gt;is_native()) {
3912           // Wahoo, we found a (possibly prefixed) version of the method, return it.
3913           return method;
3914         }
3915         if (depth &lt; prefix_count) {
3916           // Try applying further prefixes (other than this one).
3917           method = search_prefix_name_space(depth+1, name_str, name_len, signature);
3918           if (method != NULL) {
3919             return method; // found
3920           }
3921 
3922           // Try adding this prefix to the method name and see if it matches
3923           // another method name.
3924           char* prefix = prefixes[depth];
3925           size_t prefix_len = strlen(prefix);
3926           size_t trial_len = name_len + prefix_len;
3927           char* trial_name_str = NEW_RESOURCE_ARRAY(char, trial_len + 1);
3928           strcpy(trial_name_str, prefix);
3929           strcat(trial_name_str, name_str);
3930           method = search_prefix_name_space(depth+1, trial_name_str, trial_len,
3931                                             signature);
3932           if (method != NULL) {
3933             // If found along this branch, it was prefixed, mark as such
3934             method-&gt;set_is_prefixed_native();
3935             return method; // found
3936           }
3937         }
3938       }
3939     }
3940     return NULL;  // This whole branch bore nothing
3941   }
3942 
3943   // Return the method name with old prefixes stripped away.
3944   char* method_name_without_prefixes(Method* method) {
3945     Symbol* name = method-&gt;name();
3946     char* name_str = name-&gt;as_utf8();
3947 
3948     // Old prefixing may be defunct, strip prefixes, if any.
3949     for (int i = prefix_count-1; i &gt;= 0; i--) {
3950       char* prefix = prefixes[i];
3951       size_t prefix_len = strlen(prefix);
3952       if (strncmp(prefix, name_str, prefix_len) == 0) {
3953         name_str += prefix_len;
3954       }
3955     }
3956     return name_str;
3957   }
3958 
3959   // Strip any prefixes off the old native method, then try to find a
3960   // (possibly prefixed) new native that matches it.
3961   Method* strip_and_search_for_new_native(Method* method) {
3962     ResourceMark rm;
3963     char* name_str = method_name_without_prefixes(method);
3964     return search_prefix_name_space(0, name_str, strlen(name_str),
3965                                     method-&gt;signature());
3966   }
3967 
3968  public:
3969 
3970   // Construct a native method transfer processor for this class.
3971   TransferNativeFunctionRegistration(InstanceKlass* _the_class) {
3972     assert(SafepointSynchronize::is_at_safepoint(), &quot;sanity check&quot;);
3973 
3974     the_class = _the_class;
3975     prefixes = JvmtiExport::get_all_native_method_prefixes(&amp;prefix_count);
3976   }
3977 
3978   // Attempt to transfer any of the old or deleted methods that are native
3979   void transfer_registrations(Method** old_methods, int methods_length) {
3980     for (int j = 0; j &lt; methods_length; j++) {
3981       Method* old_method = old_methods[j];
3982 
3983       if (old_method-&gt;is_native() &amp;&amp; old_method-&gt;has_native_function()) {
3984         Method* new_method = strip_and_search_for_new_native(old_method);
3985         if (new_method != NULL) {
3986           // Actually set the native function in the new method.
3987           // Redefine does not send events (except CFLH), certainly not this
3988           // behind the scenes re-registration.
3989           new_method-&gt;set_native_function(old_method-&gt;native_function(),
3990                               !Method::native_bind_event_is_interesting);
3991         }
3992       }
3993     }
3994   }
3995 };
3996 
3997 // Don&#39;t lose the association between a native method and its JNI function.
3998 void VM_RedefineClasses::transfer_old_native_function_registrations(InstanceKlass* the_class) {
3999   TransferNativeFunctionRegistration transfer(the_class);
4000   transfer.transfer_registrations(_deleted_methods, _deleted_methods_length);
4001   transfer.transfer_registrations(_matching_old_methods, _matching_methods_length);
4002 }
4003 
4004 // Deoptimize all compiled code that depends on this class.
4005 //
4006 // If the can_redefine_classes capability is obtained in the onload
4007 // phase then the compiler has recorded all dependencies from startup.
4008 // In that case we need only deoptimize and throw away all compiled code
4009 // that depends on the class.
4010 //
4011 // If can_redefine_classes is obtained sometime after the onload
4012 // phase then the dependency information may be incomplete. In that case
4013 // the first call to RedefineClasses causes all compiled code to be
4014 // thrown away. As can_redefine_classes has been obtained then
4015 // all future compilations will record dependencies so second and
4016 // subsequent calls to RedefineClasses need only throw away code
4017 // that depends on the class.
4018 //
4019 
4020 // First step is to walk the code cache for each class redefined and mark
4021 // dependent methods.  Wait until all classes are processed to deoptimize everything.
4022 void VM_RedefineClasses::mark_dependent_code(InstanceKlass* ik) {
4023   assert_locked_or_safepoint(Compile_lock);
4024 
4025   // All dependencies have been recorded from startup or this is a second or
4026   // subsequent use of RedefineClasses
4027   if (JvmtiExport::all_dependencies_are_recorded()) {
4028     CodeCache::mark_for_evol_deoptimization(ik);
4029   }
4030 }
4031 
4032 void VM_RedefineClasses::flush_dependent_code() {
4033   assert(SafepointSynchronize::is_at_safepoint(), &quot;sanity check&quot;);
4034 
4035   bool deopt_needed;
4036 
4037   // This is the first redefinition, mark all the nmethods for deoptimization
4038   if (!JvmtiExport::all_dependencies_are_recorded()) {
4039     log_debug(redefine, class, nmethod)(&quot;Marked all nmethods for deopt&quot;);
4040     CodeCache::mark_all_nmethods_for_evol_deoptimization();
4041     deopt_needed = true;
4042   } else {
4043     int deopt = CodeCache::mark_dependents_for_evol_deoptimization();
4044     log_debug(redefine, class, nmethod)(&quot;Marked %d dependent nmethods for deopt&quot;, deopt);
4045     deopt_needed = (deopt != 0);
4046   }
4047 
4048   if (deopt_needed) {
4049     CodeCache::flush_evol_dependents();
4050   }
4051 
4052   // From now on we know that the dependency information is complete
4053   JvmtiExport::set_all_dependencies_are_recorded(true);
4054 }
4055 
4056 void VM_RedefineClasses::compute_added_deleted_matching_methods() {
4057   Method* old_method;
4058   Method* new_method;
4059 
4060   _matching_old_methods = NEW_RESOURCE_ARRAY(Method*, _old_methods-&gt;length());
4061   _matching_new_methods = NEW_RESOURCE_ARRAY(Method*, _old_methods-&gt;length());
4062   _added_methods        = NEW_RESOURCE_ARRAY(Method*, _new_methods-&gt;length());
4063   _deleted_methods      = NEW_RESOURCE_ARRAY(Method*, _old_methods-&gt;length());
4064 
4065   _matching_methods_length = 0;
4066   _deleted_methods_length  = 0;
4067   _added_methods_length    = 0;
4068 
4069   int nj = 0;
4070   int oj = 0;
4071   while (true) {
4072     if (oj &gt;= _old_methods-&gt;length()) {
4073       if (nj &gt;= _new_methods-&gt;length()) {
4074         break; // we&#39;ve looked at everything, done
4075       }
4076       // New method at the end
4077       new_method = _new_methods-&gt;at(nj);
4078       _added_methods[_added_methods_length++] = new_method;
4079       ++nj;
4080     } else if (nj &gt;= _new_methods-&gt;length()) {
4081       // Old method, at the end, is deleted
4082       old_method = _old_methods-&gt;at(oj);
4083       _deleted_methods[_deleted_methods_length++] = old_method;
4084       ++oj;
4085     } else {
4086       old_method = _old_methods-&gt;at(oj);
4087       new_method = _new_methods-&gt;at(nj);
4088       if (old_method-&gt;name() == new_method-&gt;name()) {
4089         if (old_method-&gt;signature() == new_method-&gt;signature()) {
4090           _matching_old_methods[_matching_methods_length  ] = old_method;
4091           _matching_new_methods[_matching_methods_length++] = new_method;
4092           ++nj;
4093           ++oj;
4094         } else {
4095           // added overloaded have already been moved to the end,
4096           // so this is a deleted overloaded method
4097           _deleted_methods[_deleted_methods_length++] = old_method;
4098           ++oj;
4099         }
4100       } else { // names don&#39;t match
4101         if (old_method-&gt;name()-&gt;fast_compare(new_method-&gt;name()) &gt; 0) {
4102           // new method
4103           _added_methods[_added_methods_length++] = new_method;
4104           ++nj;
4105         } else {
4106           // deleted method
4107           _deleted_methods[_deleted_methods_length++] = old_method;
4108           ++oj;
4109         }
4110       }
4111     }
4112   }
4113   assert(_matching_methods_length + _deleted_methods_length == _old_methods-&gt;length(), &quot;sanity&quot;);
4114   assert(_matching_methods_length + _added_methods_length == _new_methods-&gt;length(), &quot;sanity&quot;);
4115 }
4116 
4117 
4118 void VM_RedefineClasses::swap_annotations(InstanceKlass* the_class,
4119                                           InstanceKlass* scratch_class) {
4120   // Swap annotation fields values
4121   Annotations* old_annotations = the_class-&gt;annotations();
4122   the_class-&gt;set_annotations(scratch_class-&gt;annotations());
4123   scratch_class-&gt;set_annotations(old_annotations);
4124 }
4125 
4126 
4127 // Install the redefinition of a class:
4128 //    - house keeping (flushing breakpoints and caches, deoptimizing
4129 //      dependent compiled code)
4130 //    - replacing parts in the_class with parts from scratch_class
4131 //    - adding a weak reference to track the obsolete but interesting
4132 //      parts of the_class
4133 //    - adjusting constant pool caches and vtables in other classes
4134 //      that refer to methods in the_class. These adjustments use the
4135 //      ClassLoaderDataGraph::classes_do() facility which only allows
4136 //      a helper method to be specified. The interesting parameters
4137 //      that we would like to pass to the helper method are saved in
4138 //      static global fields in the VM operation.
4139 void VM_RedefineClasses::redefine_single_class(jclass the_jclass,
4140        InstanceKlass* scratch_class, TRAPS) {
4141 
4142   HandleMark hm(THREAD);   // make sure handles from this call are freed
4143 
4144   if (log_is_enabled(Info, redefine, class, timer)) {
4145     _timer_rsc_phase1.start();
4146   }
4147 
4148   InstanceKlass* the_class = get_ik(the_jclass);
4149 
4150   // Set some flags to control and optimize adjusting method entries
4151   _has_redefined_Object |= the_class == SystemDictionary::Object_klass();
4152   _has_null_class_loader |= the_class-&gt;class_loader() == NULL;
4153 
4154   // Remove all breakpoints in methods of this class
4155   JvmtiBreakpoints&amp; jvmti_breakpoints = JvmtiCurrentBreakpoints::get_jvmti_breakpoints();
4156   jvmti_breakpoints.clearall_in_class_at_safepoint(the_class);
4157 
4158   // Mark all compiled code that depends on this class
4159   mark_dependent_code(the_class);
4160 
4161   _old_methods = the_class-&gt;methods();
4162   _new_methods = scratch_class-&gt;methods();
4163   _the_class = the_class;
4164   compute_added_deleted_matching_methods();
4165   update_jmethod_ids(THREAD);
4166 
4167   _any_class_has_resolved_methods = the_class-&gt;has_resolved_methods() || _any_class_has_resolved_methods;
4168 
4169   // Attach new constant pool to the original klass. The original
4170   // klass still refers to the old constant pool (for now).
4171   scratch_class-&gt;constants()-&gt;set_pool_holder(the_class);
4172 
4173 #if 0
4174   // In theory, with constant pool merging in place we should be able
4175   // to save space by using the new, merged constant pool in place of
4176   // the old constant pool(s). By &quot;pool(s)&quot; I mean the constant pool in
4177   // the klass version we are replacing now and any constant pool(s) in
4178   // previous versions of klass. Nice theory, doesn&#39;t work in practice.
4179   // When this code is enabled, even simple programs throw NullPointer
4180   // exceptions. I&#39;m guessing that this is caused by some constant pool
4181   // cache difference between the new, merged constant pool and the
4182   // constant pool that was just being used by the klass. I&#39;m keeping
4183   // this code around to archive the idea, but the code has to remain
4184   // disabled for now.
4185 
4186   // Attach each old method to the new constant pool. This can be
4187   // done here since we are past the bytecode verification and
4188   // constant pool optimization phases.
4189   for (int i = _old_methods-&gt;length() - 1; i &gt;= 0; i--) {
4190     Method* method = _old_methods-&gt;at(i);
4191     method-&gt;set_constants(scratch_class-&gt;constants());
4192   }
4193 
4194   // NOTE: this doesn&#39;t work because you can redefine the same class in two
4195   // threads, each getting their own constant pool data appended to the
4196   // original constant pool.  In order for the new methods to work when they
4197   // become old methods, they need to keep their updated copy of the constant pool.
4198 
4199   {
4200     // walk all previous versions of the klass
4201     InstanceKlass *ik = the_class;
4202     PreviousVersionWalker pvw(ik);
4203     do {
4204       ik = pvw.next_previous_version();
4205       if (ik != NULL) {
4206 
4207         // attach previous version of klass to the new constant pool
4208         ik-&gt;set_constants(scratch_class-&gt;constants());
4209 
4210         // Attach each method in the previous version of klass to the
4211         // new constant pool
4212         Array&lt;Method*&gt;* prev_methods = ik-&gt;methods();
4213         for (int i = prev_methods-&gt;length() - 1; i &gt;= 0; i--) {
4214           Method* method = prev_methods-&gt;at(i);
4215           method-&gt;set_constants(scratch_class-&gt;constants());
4216         }
4217       }
4218     } while (ik != NULL);
4219   }
4220 #endif
4221 
4222   // Replace methods and constantpool
4223   the_class-&gt;set_methods(_new_methods);
4224   scratch_class-&gt;set_methods(_old_methods);     // To prevent potential GCing of the old methods,
4225                                           // and to be able to undo operation easily.
4226 
4227   Array&lt;int&gt;* old_ordering = the_class-&gt;method_ordering();
4228   the_class-&gt;set_method_ordering(scratch_class-&gt;method_ordering());
4229   scratch_class-&gt;set_method_ordering(old_ordering);
4230 
4231   ConstantPool* old_constants = the_class-&gt;constants();
4232   the_class-&gt;set_constants(scratch_class-&gt;constants());
4233   scratch_class-&gt;set_constants(old_constants);  // See the previous comment.
4234 #if 0
4235   // We are swapping the guts of &quot;the new class&quot; with the guts of &quot;the
4236   // class&quot;. Since the old constant pool has just been attached to &quot;the
4237   // new class&quot;, it seems logical to set the pool holder in the old
4238   // constant pool also. However, doing this will change the observable
4239   // class hierarchy for any old methods that are still executing. A
4240   // method can query the identity of its &quot;holder&quot; and this query uses
4241   // the method&#39;s constant pool link to find the holder. The change in
4242   // holding class from &quot;the class&quot; to &quot;the new class&quot; can confuse
4243   // things.
4244   //
4245   // Setting the old constant pool&#39;s holder will also cause
4246   // verification done during vtable initialization below to fail.
4247   // During vtable initialization, the vtable&#39;s class is verified to be
4248   // a subtype of the method&#39;s holder. The vtable&#39;s class is &quot;the
4249   // class&quot; and the method&#39;s holder is gotten from the constant pool
4250   // link in the method itself. For &quot;the class&quot;&#39;s directly implemented
4251   // methods, the method holder is &quot;the class&quot; itself (as gotten from
4252   // the new constant pool). The check works fine in this case. The
4253   // check also works fine for methods inherited from super classes.
4254   //
4255   // Miranda methods are a little more complicated. A miranda method is
4256   // provided by an interface when the class implementing the interface
4257   // does not provide its own method.  These interfaces are implemented
4258   // internally as an InstanceKlass. These special instanceKlasses
4259   // share the constant pool of the class that &quot;implements&quot; the
4260   // interface. By sharing the constant pool, the method holder of a
4261   // miranda method is the class that &quot;implements&quot; the interface. In a
4262   // non-redefine situation, the subtype check works fine. However, if
4263   // the old constant pool&#39;s pool holder is modified, then the check
4264   // fails because there is no class hierarchy relationship between the
4265   // vtable&#39;s class and &quot;the new class&quot;.
4266 
4267   old_constants-&gt;set_pool_holder(scratch_class());
4268 #endif
4269 
4270   // track number of methods that are EMCP for add_previous_version() call below
4271   int emcp_method_count = check_methods_and_mark_as_obsolete();
4272   transfer_old_native_function_registrations(the_class);
4273 
4274   // The class file bytes from before any retransformable agents mucked
4275   // with them was cached on the scratch class, move to the_class.
4276   // Note: we still want to do this if nothing needed caching since it
4277   // should get cleared in the_class too.
4278   if (the_class-&gt;get_cached_class_file() == 0) {
4279     // the_class doesn&#39;t have a cache yet so copy it
4280     the_class-&gt;set_cached_class_file(scratch_class-&gt;get_cached_class_file());
4281   }
4282   else if (scratch_class-&gt;get_cached_class_file() !=
4283            the_class-&gt;get_cached_class_file()) {
4284     // The same class can be present twice in the scratch classes list or there
4285     // are multiple concurrent RetransformClasses calls on different threads.
4286     // In such cases we have to deallocate scratch_class cached_class_file.
4287     os::free(scratch_class-&gt;get_cached_class_file());
4288   }
4289 
4290   // NULL out in scratch class to not delete twice.  The class to be redefined
4291   // always owns these bytes.
4292   scratch_class-&gt;set_cached_class_file(NULL);
4293 
4294   // Replace inner_classes
4295   Array&lt;u2&gt;* old_inner_classes = the_class-&gt;inner_classes();
4296   the_class-&gt;set_inner_classes(scratch_class-&gt;inner_classes());
4297   scratch_class-&gt;set_inner_classes(old_inner_classes);
4298 
4299   // Initialize the vtable and interface table after
4300   // methods have been rewritten
4301   // no exception should happen here since we explicitly
4302   // do not check loader constraints.
4303   // compare_and_normalize_class_versions has already checked:
4304   //  - classloaders unchanged, signatures unchanged
4305   //  - all instanceKlasses for redefined classes reused &amp; contents updated
4306   the_class-&gt;vtable().initialize_vtable(false, THREAD);
4307   the_class-&gt;itable().initialize_itable(false, THREAD);
4308   assert(!HAS_PENDING_EXCEPTION || (THREAD-&gt;pending_exception()-&gt;is_a(SystemDictionary::ThreadDeath_klass())), &quot;redefine exception&quot;);
4309 
4310   // Leave arrays of jmethodIDs and itable index cache unchanged
4311 
4312   // Copy the &quot;source file name&quot; attribute from new class version
4313   the_class-&gt;set_source_file_name_index(
4314     scratch_class-&gt;source_file_name_index());
4315 
4316   // Copy the &quot;source debug extension&quot; attribute from new class version
4317   the_class-&gt;set_source_debug_extension(
4318     scratch_class-&gt;source_debug_extension(),
4319     scratch_class-&gt;source_debug_extension() == NULL ? 0 :
4320     (int)strlen(scratch_class-&gt;source_debug_extension()));
4321 
4322   // Use of javac -g could be different in the old and the new
4323   if (scratch_class-&gt;access_flags().has_localvariable_table() !=
4324       the_class-&gt;access_flags().has_localvariable_table()) {
4325 
4326     AccessFlags flags = the_class-&gt;access_flags();
4327     if (scratch_class-&gt;access_flags().has_localvariable_table()) {
4328       flags.set_has_localvariable_table();
4329     } else {
4330       flags.clear_has_localvariable_table();
4331     }
4332     the_class-&gt;set_access_flags(flags);
4333   }
4334 
4335   swap_annotations(the_class, scratch_class);
4336 
4337   // Replace CP indexes for class and name+type of enclosing method
4338   u2 old_class_idx  = the_class-&gt;enclosing_method_class_index();
4339   u2 old_method_idx = the_class-&gt;enclosing_method_method_index();
4340   the_class-&gt;set_enclosing_method_indices(
4341     scratch_class-&gt;enclosing_method_class_index(),
4342     scratch_class-&gt;enclosing_method_method_index());
4343   scratch_class-&gt;set_enclosing_method_indices(old_class_idx, old_method_idx);
4344 
4345   // Replace fingerprint data
4346   the_class-&gt;set_has_passed_fingerprint_check(scratch_class-&gt;has_passed_fingerprint_check());
4347   the_class-&gt;store_fingerprint(scratch_class-&gt;get_stored_fingerprint());
4348 
4349   the_class-&gt;set_has_been_redefined();
4350 
4351   if (!the_class-&gt;should_be_initialized()) {
4352     // Class was already initialized, so AOT has only seen the original version.
4353     // We need to let AOT look at it again.
4354     AOTLoader::load_for_klass(the_class, THREAD);
4355   }
4356 
4357   // keep track of previous versions of this class
4358   the_class-&gt;add_previous_version(scratch_class, emcp_method_count);
4359 
4360   _timer_rsc_phase1.stop();
4361   if (log_is_enabled(Info, redefine, class, timer)) {
4362     _timer_rsc_phase2.start();
4363   }
4364 
4365   if (the_class-&gt;oop_map_cache() != NULL) {
4366     // Flush references to any obsolete methods from the oop map cache
4367     // so that obsolete methods are not pinned.
4368     the_class-&gt;oop_map_cache()-&gt;flush_obsolete_entries();
4369   }
4370 
4371   increment_class_counter((InstanceKlass *)the_class, THREAD);
4372 
4373   if (EventClassRedefinition::is_enabled()) {
4374     EventClassRedefinition event;
4375     event.set_classModificationCount(java_lang_Class::classRedefinedCount(the_class-&gt;java_mirror()));
4376     event.set_redefinedClass(the_class);
4377     event.set_redefinitionId(_id);
4378     event.commit();
4379   }
4380 
4381   {
4382     ResourceMark rm(THREAD);
4383     // increment the classRedefinedCount field in the_class and in any
4384     // direct and indirect subclasses of the_class
4385     log_info(redefine, class, load)
4386       (&quot;redefined name=%s, count=%d (avail_mem=&quot; UINT64_FORMAT &quot;K)&quot;,
4387        the_class-&gt;external_name(), java_lang_Class::classRedefinedCount(the_class-&gt;java_mirror()), os::available_memory() &gt;&gt; 10);
4388     Events::log_redefinition(THREAD, &quot;redefined class name=%s, count=%d&quot;,
4389                              the_class-&gt;external_name(),
4390                              java_lang_Class::classRedefinedCount(the_class-&gt;java_mirror()));
4391 
4392   }
4393   _timer_rsc_phase2.stop();
4394 
4395 } // end redefine_single_class()
4396 
4397 
4398 // Increment the classRedefinedCount field in the specific InstanceKlass
4399 // and in all direct and indirect subclasses.
4400 void VM_RedefineClasses::increment_class_counter(InstanceKlass *ik, TRAPS) {
4401   oop class_mirror = ik-&gt;java_mirror();
4402   Klass* class_oop = java_lang_Class::as_Klass(class_mirror);
4403   int new_count = java_lang_Class::classRedefinedCount(class_mirror) + 1;
4404   java_lang_Class::set_classRedefinedCount(class_mirror, new_count);
4405 
4406   if (class_oop != _the_class) {
4407     // _the_class count is printed at end of redefine_single_class()
4408     log_debug(redefine, class, subclass)(&quot;updated count in subclass=%s to %d&quot;, ik-&gt;external_name(), new_count);
4409   }
4410 
4411   for (Klass *subk = ik-&gt;subklass(); subk != NULL;
4412        subk = subk-&gt;next_sibling()) {
4413     if (subk-&gt;is_instance_klass()) {
4414       // Only update instanceKlasses
4415       InstanceKlass *subik = InstanceKlass::cast(subk);
4416       // recursively do subclasses of the current subclass
4417       increment_class_counter(subik, THREAD);
4418     }
4419   }
4420 }
4421 
4422 void VM_RedefineClasses::CheckClass::do_klass(Klass* k) {
4423   bool no_old_methods = true;  // be optimistic
4424 
4425   // Both array and instance classes have vtables.
4426   // a vtable should never contain old or obsolete methods
4427   ResourceMark rm(_thread);
4428   if (k-&gt;vtable_length() &gt; 0 &amp;&amp;
4429       !k-&gt;vtable().check_no_old_or_obsolete_entries()) {
4430     if (log_is_enabled(Trace, redefine, class, obsolete, metadata)) {
4431       log_trace(redefine, class, obsolete, metadata)
4432         (&quot;klassVtable::check_no_old_or_obsolete_entries failure -- OLD or OBSOLETE method found -- class: %s&quot;,
4433          k-&gt;signature_name());
4434       k-&gt;vtable().dump_vtable();
4435     }
4436     no_old_methods = false;
4437   }
4438 
4439   if (k-&gt;is_instance_klass()) {
4440     HandleMark hm(_thread);
4441     InstanceKlass *ik = InstanceKlass::cast(k);
4442 
4443     // an itable should never contain old or obsolete methods
4444     if (ik-&gt;itable_length() &gt; 0 &amp;&amp;
4445         !ik-&gt;itable().check_no_old_or_obsolete_entries()) {
4446       if (log_is_enabled(Trace, redefine, class, obsolete, metadata)) {
4447         log_trace(redefine, class, obsolete, metadata)
4448           (&quot;klassItable::check_no_old_or_obsolete_entries failure -- OLD or OBSOLETE method found -- class: %s&quot;,
4449            ik-&gt;signature_name());
4450         ik-&gt;itable().dump_itable();
4451       }
4452       no_old_methods = false;
4453     }
4454 
4455     // the constant pool cache should never contain non-deleted old or obsolete methods
4456     if (ik-&gt;constants() != NULL &amp;&amp;
4457         ik-&gt;constants()-&gt;cache() != NULL &amp;&amp;
4458         !ik-&gt;constants()-&gt;cache()-&gt;check_no_old_or_obsolete_entries()) {
4459       if (log_is_enabled(Trace, redefine, class, obsolete, metadata)) {
4460         log_trace(redefine, class, obsolete, metadata)
4461           (&quot;cp-cache::check_no_old_or_obsolete_entries failure -- OLD or OBSOLETE method found -- class: %s&quot;,
4462            ik-&gt;signature_name());
4463         ik-&gt;constants()-&gt;cache()-&gt;dump_cache();
4464       }
4465       no_old_methods = false;
4466     }
4467   }
4468 
4469   // print and fail guarantee if old methods are found.
4470   if (!no_old_methods) {
4471     if (log_is_enabled(Trace, redefine, class, obsolete, metadata)) {
4472       dump_methods();
4473     } else {
4474       log_trace(redefine, class)(&quot;Use the &#39;-Xlog:redefine+class*:&#39; option &quot;
4475         &quot;to see more info about the following guarantee() failure.&quot;);
4476     }
4477     guarantee(false, &quot;OLD and/or OBSOLETE method(s) found&quot;);
4478   }
4479 }
4480 
4481 u8 VM_RedefineClasses::next_id() {
4482   while (true) {
4483     u8 id = _id_counter;
4484     u8 next_id = id + 1;
4485     u8 result = Atomic::cmpxchg(&amp;_id_counter, id, next_id);
4486     if (result == id) {
4487       return next_id;
4488     }
4489   }
4490 }
4491 
4492 void VM_RedefineClasses::dump_methods() {
4493   int j;
4494   log_trace(redefine, class, dump)(&quot;_old_methods --&quot;);
4495   for (j = 0; j &lt; _old_methods-&gt;length(); ++j) {
4496     LogStreamHandle(Trace, redefine, class, dump) log_stream;
4497     Method* m = _old_methods-&gt;at(j);
4498     log_stream.print(&quot;%4d  (%5d)  &quot;, j, m-&gt;vtable_index());
4499     m-&gt;access_flags().print_on(&amp;log_stream);
4500     log_stream.print(&quot; --  &quot;);
4501     m-&gt;print_name(&amp;log_stream);
4502     log_stream.cr();
4503   }
4504   log_trace(redefine, class, dump)(&quot;_new_methods --&quot;);
4505   for (j = 0; j &lt; _new_methods-&gt;length(); ++j) {
4506     LogStreamHandle(Trace, redefine, class, dump) log_stream;
4507     Method* m = _new_methods-&gt;at(j);
4508     log_stream.print(&quot;%4d  (%5d)  &quot;, j, m-&gt;vtable_index());
4509     m-&gt;access_flags().print_on(&amp;log_stream);
4510     log_stream.print(&quot; --  &quot;);
4511     m-&gt;print_name(&amp;log_stream);
4512     log_stream.cr();
4513   }
4514   log_trace(redefine, class, dump)(&quot;_matching_methods --&quot;);
4515   for (j = 0; j &lt; _matching_methods_length; ++j) {
4516     LogStreamHandle(Trace, redefine, class, dump) log_stream;
4517     Method* m = _matching_old_methods[j];
4518     log_stream.print(&quot;%4d  (%5d)  &quot;, j, m-&gt;vtable_index());
4519     m-&gt;access_flags().print_on(&amp;log_stream);
4520     log_stream.print(&quot; --  &quot;);
4521     m-&gt;print_name();
4522     log_stream.cr();
4523 
4524     m = _matching_new_methods[j];
4525     log_stream.print(&quot;      (%5d)  &quot;, m-&gt;vtable_index());
4526     m-&gt;access_flags().print_on(&amp;log_stream);
4527     log_stream.cr();
4528   }
4529   log_trace(redefine, class, dump)(&quot;_deleted_methods --&quot;);
4530   for (j = 0; j &lt; _deleted_methods_length; ++j) {
4531     LogStreamHandle(Trace, redefine, class, dump) log_stream;
4532     Method* m = _deleted_methods[j];
4533     log_stream.print(&quot;%4d  (%5d)  &quot;, j, m-&gt;vtable_index());
4534     m-&gt;access_flags().print_on(&amp;log_stream);
4535     log_stream.print(&quot; --  &quot;);
4536     m-&gt;print_name(&amp;log_stream);
4537     log_stream.cr();
4538   }
4539   log_trace(redefine, class, dump)(&quot;_added_methods --&quot;);
4540   for (j = 0; j &lt; _added_methods_length; ++j) {
4541     LogStreamHandle(Trace, redefine, class, dump) log_stream;
4542     Method* m = _added_methods[j];
4543     log_stream.print(&quot;%4d  (%5d)  &quot;, j, m-&gt;vtable_index());
4544     m-&gt;access_flags().print_on(&amp;log_stream);
4545     log_stream.print(&quot; --  &quot;);
4546     m-&gt;print_name(&amp;log_stream);
4547     log_stream.cr();
4548   }
4549 }
4550 
4551 void VM_RedefineClasses::print_on_error(outputStream* st) const {
4552   VM_Operation::print_on_error(st);
4553   if (_the_class != NULL) {
4554     ResourceMark rm;
4555     st-&gt;print_cr(&quot;, redefining class %s&quot;, _the_class-&gt;external_name());
4556   }
4557 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
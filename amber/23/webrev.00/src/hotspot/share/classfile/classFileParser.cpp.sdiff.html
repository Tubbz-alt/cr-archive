<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/classFileParser.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../../../../make/data/jdwp/jdwp.spec.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../oops/instanceKlass.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classFileParser.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
3496 
3497     cfs-&gt;guarantee_more(sizeof(u2) * argument_count, CHECK);  // argv[argc]
3498     for (int j = 0; j &lt; argument_count; j++) {
3499       const u2 argument_index = cfs-&gt;get_u2_fast();
3500       check_property(
3501         valid_cp_range(argument_index, cp_size) &amp;&amp;
3502         cp-&gt;tag_at(argument_index).is_loadable_constant(),
3503         &quot;argument_index %u has bad constant type in class file %s&quot;,
3504         argument_index,
3505         CHECK);
3506       operands-&gt;at_put(operand_fill_index++, argument_index);
3507     }
3508   }
3509   guarantee_property(current_start + attribute_byte_length == cfs-&gt;current(),
3510                      &quot;Bad length on BootstrapMethods in class file %s&quot;,
3511                      CHECK);
3512 }
3513 
3514 bool ClassFileParser::supports_sealed_types() {
3515   return _major_version == JVM_CLASSFILE_MAJOR_VERSION &amp;&amp;
<span class="line-modified">3516     _minor_version == JAVA_PREVIEW_MINOR_VERSION &amp;&amp;</span>
<span class="line-modified">3517     Arguments::enable_preview();</span>
3518 }
3519 
3520 bool ClassFileParser::supports_records() {
3521   return _major_version == JVM_CLASSFILE_MAJOR_VERSION &amp;&amp;
<span class="line-modified">3522     _minor_version == JAVA_PREVIEW_MINOR_VERSION &amp;&amp;</span>
<span class="line-modified">3523     Arguments::enable_preview();</span>
3524 }
3525 
3526 void ClassFileParser::parse_classfile_attributes(const ClassFileStream* const cfs,
3527                                                  ConstantPool* cp,
3528                  ClassFileParser::ClassAnnotationCollector* parsed_annotations,
3529                                                  TRAPS) {
3530   assert(cfs != NULL, &quot;invariant&quot;);
3531   assert(cp != NULL, &quot;invariant&quot;);
3532   assert(parsed_annotations != NULL, &quot;invariant&quot;);
3533 
3534   // Set inner classes attribute to default sentinel
3535   _inner_classes = Universe::the_empty_short_array();
3536   // Set nest members attribute to default sentinel
3537   _nest_members = Universe::the_empty_short_array();
3538   // Set _permitted_subclasses attribute to default sentinel
3539   _permitted_subclasses = Universe::the_empty_short_array();
3540   cfs-&gt;guarantee_more(2, CHECK);  // attributes_count
3541   u2 attributes_count = cfs-&gt;get_u2_fast();
3542   bool parsed_sourcefile_attribute = false;
3543   bool parsed_innerclasses_attribute = false;
</pre>
<hr />
<pre>
3773               // --enable-preview wasn&#39;t specified then a java.lang.UnsupportedClassVersionError
3774               // exception would have been thrown.
3775               ResourceMark rm(THREAD);
3776               if (supports_records()) {
3777                 log_info(class, record)(
3778                   &quot;Ignoring Record attribute in class %s because super type is not java.lang.Record&quot;,
3779                   _class_name-&gt;as_C_string());
3780               } else {
3781                 log_info(class, record)(
3782                   &quot;Ignoring Record attribute in class %s because class file version is not %d.65535&quot;,
3783                    _class_name-&gt;as_C_string(), JVM_CLASSFILE_MAJOR_VERSION);
3784               }
3785             }
3786             cfs-&gt;skip_u1(attribute_length, CHECK);
3787           } else if (_major_version &gt;= JAVA_15_VERSION) {
3788             // Check for PermittedSubclasses tag
3789             if (tag == vmSymbols::tag_permitted_subclasses()) {
3790               if (supports_sealed_types()) {
3791                 if (parsed_permitted_subclasses_attribute) {
3792                   classfile_parse_error(&quot;Multiple PermittedSubclasses attributes in class file %s&quot;, CHECK);

3793                 // Classes marked ACC_FINAL cannot have a PermittedSubclasses attribute.
<span class="line-modified">3794                 } else if (_access_flags.is_final()) {</span>
3795                   classfile_parse_error(&quot;PermittedSubclasses attribute in final class file %s&quot;, CHECK);
<span class="line-removed">3796                 } else {</span>
<span class="line-removed">3797                   parsed_permitted_subclasses_attribute = true;</span>
3798                 }

3799                 permitted_subclasses_attribute_start = cfs-&gt;current();
3800                 permitted_subclasses_attribute_length = attribute_length;
3801               }
3802               cfs-&gt;skip_u1(attribute_length, CHECK);
3803             } else {
3804               // Unknown attribute
3805               cfs-&gt;skip_u1(attribute_length, CHECK);
3806             }
3807           } else {
3808             // Unknown attribute
3809             cfs-&gt;skip_u1(attribute_length, CHECK);
3810           }
3811         } else {
3812           // Unknown attribute
3813           cfs-&gt;skip_u1(attribute_length, CHECK);
3814         }
3815       } else {
3816         // Unknown attribute
3817         cfs-&gt;skip_u1(attribute_length, CHECK);
3818       }
</pre>
<hr />
<pre>
4743 
4744     // length will be less than the max_transitive_size if duplicates were removed
4745     const int length = result-&gt;length();
4746     assert(length &lt;= max_transitive_size, &quot;just checking&quot;);
4747     Array&lt;InstanceKlass*&gt;* const new_result =
4748       MetadataFactory::new_array&lt;InstanceKlass*&gt;(loader_data, length, CHECK_NULL);
4749     for (int i = 0; i &lt; length; i++) {
4750       InstanceKlass* const e = result-&gt;at(i);
4751       assert(e != NULL, &quot;just checking&quot;);
4752       new_result-&gt;at_put(i, e);
4753     }
4754     return new_result;
4755   }
4756 }
4757 
4758 static void check_super_class_access(const InstanceKlass* this_klass, TRAPS) {
4759   assert(this_klass != NULL, &quot;invariant&quot;);
4760   const Klass* const super = this_klass-&gt;super();
4761 
4762   if (super != NULL) {
<span class="line-removed">4763     assert(super-&gt;is_instance_klass(), &quot;super is not instance klass&quot;);</span>
4764     const InstanceKlass* super_ik = InstanceKlass::cast(super);
4765 
4766     if (super-&gt;is_final()) {
4767       ResourceMark rm(THREAD);
4768       Exceptions::fthrow(
4769         THREAD_AND_LOCATION,
4770         vmSymbols::java_lang_VerifyError(),
4771         &quot;class %s cannot inherit from final class %s&quot;,
4772         this_klass-&gt;external_name(),
4773         super_ik-&gt;external_name());
4774       return;
4775     }
4776 
4777     if (super_ik-&gt;is_sealed() &amp;&amp; !super_ik-&gt;has_as_permitted_subclass(this_klass)) {
4778       ResourceMark rm(THREAD);
4779       Exceptions::fthrow(
4780         THREAD_AND_LOCATION,
<span class="line-modified">4781         vmSymbols::java_lang_VerifyError(),</span>
4782         &quot;class %s cannot inherit from sealed class %s&quot;,
4783         this_klass-&gt;external_name(),
4784         super_ik-&gt;external_name());
4785       return;
4786     }
4787 
4788     // If the loader is not the boot loader then throw an exception if its
4789     // superclass is in package jdk.internal.reflect and its loader is not a
4790     // special reflection class loader
4791     if (!this_klass-&gt;class_loader_data()-&gt;is_the_null_class_loader_data()) {
4792       PackageEntry* super_package = super-&gt;package();
4793       if (super_package != NULL &amp;&amp;
4794           super_package-&gt;name()-&gt;fast_compare(vmSymbols::jdk_internal_reflect()) == 0 &amp;&amp;
4795           !java_lang_ClassLoader::is_reflection_class_loader(this_klass-&gt;class_loader())) {
4796         ResourceMark rm(THREAD);
4797         Exceptions::fthrow(
4798           THREAD_AND_LOCATION,
4799           vmSymbols::java_lang_IllegalAccessError(),
4800           &quot;class %s loaded by %s cannot access jdk/internal/reflect superclass %s&quot;,
4801           this_klass-&gt;external_name(),
</pre>
<hr />
<pre>
4832           &quot;superclass access check failed: %s&quot;,
4833           msg);
4834       }
4835     }
4836   }
4837 }
4838 
4839 
4840 static void check_super_interface_access(const InstanceKlass* this_klass, TRAPS) {
4841   assert(this_klass != NULL, &quot;invariant&quot;);
4842   const Array&lt;InstanceKlass*&gt;* const local_interfaces = this_klass-&gt;local_interfaces();
4843   const int lng = local_interfaces-&gt;length();
4844   for (int i = lng - 1; i &gt;= 0; i--) {
4845     InstanceKlass* const k = local_interfaces-&gt;at(i);
4846     assert (k != NULL &amp;&amp; k-&gt;is_interface(), &quot;invalid interface&quot;);
4847 
4848     if (k-&gt;is_sealed() &amp;&amp; !k-&gt;has_as_permitted_subclass(this_klass)) {
4849       ResourceMark rm(THREAD);
4850       Exceptions::fthrow(
4851         THREAD_AND_LOCATION,
<span class="line-modified">4852         vmSymbols::java_lang_VerifyError(),</span>
4853         &quot;class %s cannot %s sealed interface %s&quot;,
4854         this_klass-&gt;external_name(),
4855         this_klass-&gt;is_interface() ? &quot;extend&quot; : &quot;implement&quot;,
4856         k-&gt;external_name());
4857       return;
4858     }
4859 
4860     Reflection::VerifyClassAccessResults vca_result =
4861       Reflection::verify_class_access(this_klass, k, false);
4862     if (vca_result != Reflection::ACCESS_OK) {
4863       ResourceMark rm(THREAD);
4864       char* msg = Reflection::verify_class_access_msg(this_klass,
4865                                                       k,
4866                                                       vca_result);
4867       if (msg == NULL) {
4868         bool same_module = (this_klass-&gt;module() == k-&gt;module());
4869         Exceptions::fthrow(
4870           THREAD_AND_LOCATION,
4871           vmSymbols::java_lang_IllegalAccessError(),
4872           &quot;class %s cannot access its superinterface %s (%s%s%s)&quot;,
</pre>
</td>
<td>
<hr />
<pre>
3496 
3497     cfs-&gt;guarantee_more(sizeof(u2) * argument_count, CHECK);  // argv[argc]
3498     for (int j = 0; j &lt; argument_count; j++) {
3499       const u2 argument_index = cfs-&gt;get_u2_fast();
3500       check_property(
3501         valid_cp_range(argument_index, cp_size) &amp;&amp;
3502         cp-&gt;tag_at(argument_index).is_loadable_constant(),
3503         &quot;argument_index %u has bad constant type in class file %s&quot;,
3504         argument_index,
3505         CHECK);
3506       operands-&gt;at_put(operand_fill_index++, argument_index);
3507     }
3508   }
3509   guarantee_property(current_start + attribute_byte_length == cfs-&gt;current(),
3510                      &quot;Bad length on BootstrapMethods in class file %s&quot;,
3511                      CHECK);
3512 }
3513 
3514 bool ClassFileParser::supports_sealed_types() {
3515   return _major_version == JVM_CLASSFILE_MAJOR_VERSION &amp;&amp;
<span class="line-modified">3516          _minor_version == JAVA_PREVIEW_MINOR_VERSION &amp;&amp;</span>
<span class="line-modified">3517          Arguments::enable_preview();</span>
3518 }
3519 
3520 bool ClassFileParser::supports_records() {
3521   return _major_version == JVM_CLASSFILE_MAJOR_VERSION &amp;&amp;
<span class="line-modified">3522          _minor_version == JAVA_PREVIEW_MINOR_VERSION &amp;&amp;</span>
<span class="line-modified">3523          Arguments::enable_preview();</span>
3524 }
3525 
3526 void ClassFileParser::parse_classfile_attributes(const ClassFileStream* const cfs,
3527                                                  ConstantPool* cp,
3528                  ClassFileParser::ClassAnnotationCollector* parsed_annotations,
3529                                                  TRAPS) {
3530   assert(cfs != NULL, &quot;invariant&quot;);
3531   assert(cp != NULL, &quot;invariant&quot;);
3532   assert(parsed_annotations != NULL, &quot;invariant&quot;);
3533 
3534   // Set inner classes attribute to default sentinel
3535   _inner_classes = Universe::the_empty_short_array();
3536   // Set nest members attribute to default sentinel
3537   _nest_members = Universe::the_empty_short_array();
3538   // Set _permitted_subclasses attribute to default sentinel
3539   _permitted_subclasses = Universe::the_empty_short_array();
3540   cfs-&gt;guarantee_more(2, CHECK);  // attributes_count
3541   u2 attributes_count = cfs-&gt;get_u2_fast();
3542   bool parsed_sourcefile_attribute = false;
3543   bool parsed_innerclasses_attribute = false;
</pre>
<hr />
<pre>
3773               // --enable-preview wasn&#39;t specified then a java.lang.UnsupportedClassVersionError
3774               // exception would have been thrown.
3775               ResourceMark rm(THREAD);
3776               if (supports_records()) {
3777                 log_info(class, record)(
3778                   &quot;Ignoring Record attribute in class %s because super type is not java.lang.Record&quot;,
3779                   _class_name-&gt;as_C_string());
3780               } else {
3781                 log_info(class, record)(
3782                   &quot;Ignoring Record attribute in class %s because class file version is not %d.65535&quot;,
3783                    _class_name-&gt;as_C_string(), JVM_CLASSFILE_MAJOR_VERSION);
3784               }
3785             }
3786             cfs-&gt;skip_u1(attribute_length, CHECK);
3787           } else if (_major_version &gt;= JAVA_15_VERSION) {
3788             // Check for PermittedSubclasses tag
3789             if (tag == vmSymbols::tag_permitted_subclasses()) {
3790               if (supports_sealed_types()) {
3791                 if (parsed_permitted_subclasses_attribute) {
3792                   classfile_parse_error(&quot;Multiple PermittedSubclasses attributes in class file %s&quot;, CHECK);
<span class="line-added">3793                 }</span>
3794                 // Classes marked ACC_FINAL cannot have a PermittedSubclasses attribute.
<span class="line-modified">3795                 if (_access_flags.is_final()) {</span>
3796                   classfile_parse_error(&quot;PermittedSubclasses attribute in final class file %s&quot;, CHECK);


3797                 }
<span class="line-added">3798                 parsed_permitted_subclasses_attribute = true;</span>
3799                 permitted_subclasses_attribute_start = cfs-&gt;current();
3800                 permitted_subclasses_attribute_length = attribute_length;
3801               }
3802               cfs-&gt;skip_u1(attribute_length, CHECK);
3803             } else {
3804               // Unknown attribute
3805               cfs-&gt;skip_u1(attribute_length, CHECK);
3806             }
3807           } else {
3808             // Unknown attribute
3809             cfs-&gt;skip_u1(attribute_length, CHECK);
3810           }
3811         } else {
3812           // Unknown attribute
3813           cfs-&gt;skip_u1(attribute_length, CHECK);
3814         }
3815       } else {
3816         // Unknown attribute
3817         cfs-&gt;skip_u1(attribute_length, CHECK);
3818       }
</pre>
<hr />
<pre>
4743 
4744     // length will be less than the max_transitive_size if duplicates were removed
4745     const int length = result-&gt;length();
4746     assert(length &lt;= max_transitive_size, &quot;just checking&quot;);
4747     Array&lt;InstanceKlass*&gt;* const new_result =
4748       MetadataFactory::new_array&lt;InstanceKlass*&gt;(loader_data, length, CHECK_NULL);
4749     for (int i = 0; i &lt; length; i++) {
4750       InstanceKlass* const e = result-&gt;at(i);
4751       assert(e != NULL, &quot;just checking&quot;);
4752       new_result-&gt;at_put(i, e);
4753     }
4754     return new_result;
4755   }
4756 }
4757 
4758 static void check_super_class_access(const InstanceKlass* this_klass, TRAPS) {
4759   assert(this_klass != NULL, &quot;invariant&quot;);
4760   const Klass* const super = this_klass-&gt;super();
4761 
4762   if (super != NULL) {

4763     const InstanceKlass* super_ik = InstanceKlass::cast(super);
4764 
4765     if (super-&gt;is_final()) {
4766       ResourceMark rm(THREAD);
4767       Exceptions::fthrow(
4768         THREAD_AND_LOCATION,
4769         vmSymbols::java_lang_VerifyError(),
4770         &quot;class %s cannot inherit from final class %s&quot;,
4771         this_klass-&gt;external_name(),
4772         super_ik-&gt;external_name());
4773       return;
4774     }
4775 
4776     if (super_ik-&gt;is_sealed() &amp;&amp; !super_ik-&gt;has_as_permitted_subclass(this_klass)) {
4777       ResourceMark rm(THREAD);
4778       Exceptions::fthrow(
4779         THREAD_AND_LOCATION,
<span class="line-modified">4780         vmSymbols::java_lang_IncompatibleClassChangeError(),</span>
4781         &quot;class %s cannot inherit from sealed class %s&quot;,
4782         this_klass-&gt;external_name(),
4783         super_ik-&gt;external_name());
4784       return;
4785     }
4786 
4787     // If the loader is not the boot loader then throw an exception if its
4788     // superclass is in package jdk.internal.reflect and its loader is not a
4789     // special reflection class loader
4790     if (!this_klass-&gt;class_loader_data()-&gt;is_the_null_class_loader_data()) {
4791       PackageEntry* super_package = super-&gt;package();
4792       if (super_package != NULL &amp;&amp;
4793           super_package-&gt;name()-&gt;fast_compare(vmSymbols::jdk_internal_reflect()) == 0 &amp;&amp;
4794           !java_lang_ClassLoader::is_reflection_class_loader(this_klass-&gt;class_loader())) {
4795         ResourceMark rm(THREAD);
4796         Exceptions::fthrow(
4797           THREAD_AND_LOCATION,
4798           vmSymbols::java_lang_IllegalAccessError(),
4799           &quot;class %s loaded by %s cannot access jdk/internal/reflect superclass %s&quot;,
4800           this_klass-&gt;external_name(),
</pre>
<hr />
<pre>
4831           &quot;superclass access check failed: %s&quot;,
4832           msg);
4833       }
4834     }
4835   }
4836 }
4837 
4838 
4839 static void check_super_interface_access(const InstanceKlass* this_klass, TRAPS) {
4840   assert(this_klass != NULL, &quot;invariant&quot;);
4841   const Array&lt;InstanceKlass*&gt;* const local_interfaces = this_klass-&gt;local_interfaces();
4842   const int lng = local_interfaces-&gt;length();
4843   for (int i = lng - 1; i &gt;= 0; i--) {
4844     InstanceKlass* const k = local_interfaces-&gt;at(i);
4845     assert (k != NULL &amp;&amp; k-&gt;is_interface(), &quot;invalid interface&quot;);
4846 
4847     if (k-&gt;is_sealed() &amp;&amp; !k-&gt;has_as_permitted_subclass(this_klass)) {
4848       ResourceMark rm(THREAD);
4849       Exceptions::fthrow(
4850         THREAD_AND_LOCATION,
<span class="line-modified">4851         vmSymbols::java_lang_IncompatibleClassChangeError(),</span>
4852         &quot;class %s cannot %s sealed interface %s&quot;,
4853         this_klass-&gt;external_name(),
4854         this_klass-&gt;is_interface() ? &quot;extend&quot; : &quot;implement&quot;,
4855         k-&gt;external_name());
4856       return;
4857     }
4858 
4859     Reflection::VerifyClassAccessResults vca_result =
4860       Reflection::verify_class_access(this_klass, k, false);
4861     if (vca_result != Reflection::ACCESS_OK) {
4862       ResourceMark rm(THREAD);
4863       char* msg = Reflection::verify_class_access_msg(this_klass,
4864                                                       k,
4865                                                       vca_result);
4866       if (msg == NULL) {
4867         bool same_module = (this_klass-&gt;module() == k-&gt;module());
4868         Exceptions::fthrow(
4869           THREAD_AND_LOCATION,
4870           vmSymbols::java_lang_IllegalAccessError(),
4871           &quot;class %s cannot access its superinterface %s (%s%s%s)&quot;,
</pre>
</td>
</tr>
</table>
<center><a href="../../../../make/data/jdwp/jdwp.spec.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../oops/instanceKlass.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/java/lang/Class.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1994, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang;
  27 
  28 import java.lang.annotation.Annotation;
  29 import java.lang.constant.ClassDesc;
  30 import java.lang.invoke.TypeDescriptor;
  31 import java.lang.invoke.MethodHandles;
  32 import java.lang.module.ModuleReader;
  33 import java.lang.ref.SoftReference;
  34 import java.io.IOException;
  35 import java.io.InputStream;
  36 import java.io.ObjectStreamField;
  37 import java.lang.reflect.AnnotatedElement;
  38 import java.lang.reflect.AnnotatedType;
  39 import java.lang.reflect.Array;
  40 import java.lang.reflect.Constructor;
  41 import java.lang.reflect.Executable;
  42 import java.lang.reflect.Field;
  43 import java.lang.reflect.GenericArrayType;
  44 import java.lang.reflect.GenericDeclaration;
  45 import java.lang.reflect.InvocationTargetException;
  46 import java.lang.reflect.Member;
  47 import java.lang.reflect.Method;
  48 import java.lang.reflect.Modifier;
  49 import java.lang.reflect.Proxy;
  50 import java.lang.reflect.RecordComponent;
  51 import java.lang.reflect.Type;
  52 import java.lang.reflect.TypeVariable;
  53 import java.lang.constant.Constable;
  54 import java.net.URL;
  55 import java.security.AccessController;
  56 import java.security.PrivilegedAction;
  57 import java.util.ArrayList;
  58 import java.util.Arrays;
  59 import java.util.Collection;
  60 import java.util.HashMap;
  61 import java.util.LinkedHashMap;
  62 import java.util.LinkedHashSet;
  63 import java.util.List;
  64 import java.util.Map;
  65 import java.util.Objects;
  66 import java.util.Optional;
  67 import java.util.stream.Collectors;
  68 
  69 import jdk.internal.HotSpotIntrinsicCandidate;
  70 import jdk.internal.loader.BootLoader;
  71 import jdk.internal.loader.BuiltinClassLoader;
  72 import jdk.internal.misc.Unsafe;
  73 import jdk.internal.module.Resources;
  74 import jdk.internal.reflect.CallerSensitive;
  75 import jdk.internal.reflect.ConstantPool;
  76 import jdk.internal.reflect.Reflection;
  77 import jdk.internal.reflect.ReflectionFactory;
  78 import jdk.internal.vm.annotation.ForceInline;
  79 import sun.invoke.util.Wrapper;
  80 import sun.reflect.generics.factory.CoreReflectionFactory;
  81 import sun.reflect.generics.factory.GenericsFactory;
  82 import sun.reflect.generics.repository.ClassRepository;
  83 import sun.reflect.generics.repository.MethodRepository;
  84 import sun.reflect.generics.repository.ConstructorRepository;
  85 import sun.reflect.generics.scope.ClassScope;
  86 import sun.security.util.SecurityConstants;
  87 import sun.reflect.annotation.*;
  88 import sun.reflect.misc.ReflectUtil;
  89 
  90 /**
  91  * Instances of the class {@code Class} represent classes and
  92  * interfaces in a running Java application. An enum type and a record
  93  * type are kinds of class; an annotation type is a kind of
  94  * interface. Every array also belongs to a class that is reflected as
  95  * a {@code Class} object that is shared by all arrays with the same
  96  * element type and number of dimensions.  The primitive Java types
  97  * ({@code boolean}, {@code byte}, {@code char}, {@code short}, {@code
  98  * int}, {@code long}, {@code float}, and {@code double}), and the
  99  * keyword {@code void} are also represented as {@code Class} objects.
 100  *
 101  * &lt;p&gt; {@code Class} has no public constructor. Instead a {@code Class}
 102  * object is constructed automatically by the Java Virtual Machine when
 103  * a class is derived from the bytes of a {@code class} file through
 104  * the invocation of one of the following methods:
 105  * &lt;ul&gt;
 106  * &lt;li&gt; {@link ClassLoader#defineClass(String, byte[], int, int) ClassLoader::defineClass}
 107  * &lt;li&gt; {@link java.lang.invoke.MethodHandles.Lookup#defineClass(byte[])
 108  *      java.lang.invoke.MethodHandles.Lookup::defineClass}
 109  * &lt;li&gt; {@link java.lang.invoke.MethodHandles.Lookup#defineHiddenClass(byte[], boolean, MethodHandles.Lookup.ClassOption...)
 110  *      java.lang.invoke.MethodHandles.Lookup::defineHiddenClass}
 111  * &lt;/ul&gt;
 112  *
 113  * &lt;p&gt; The methods of class {@code Class} expose many characteristics of a
 114  * class or interface. Most characteristics are derived from the {@code class}
 115  * file that the class loader passed to the Java Virtual Machine or
 116  * from the {@code class} file passed to {@code Lookup::defineClass}
 117  * or {@code Lookup::defineHiddenClass}.
 118  * A few characteristics are determined by the class loading environment
 119  * at run time, such as the module returned by {@link #getModule() getModule()}.
 120  *
 121  * &lt;p&gt; The following example uses a {@code Class} object to print the
 122  * class name of an object:
 123  *
 124  * &lt;blockquote&gt;&lt;pre&gt;
 125  *     void printClassName(Object obj) {
 126  *         System.out.println(&quot;The class of &quot; + obj +
 127  *                            &quot; is &quot; + obj.getClass().getName());
 128  *     }
 129  * &lt;/pre&gt;&lt;/blockquote&gt;
 130  *
 131  * It is also possible to get the {@code Class} object for a named
 132  * type (or for {@code void}) using a &lt;i&gt;class literal&lt;/i&gt;.
 133  * For example:
 134  *
 135  * &lt;blockquote&gt;
 136  *     {@code System.out.println(&quot;The name of class Foo is: &quot;+Foo.class.getName());}
 137  * &lt;/blockquote&gt;
 138  *
 139  * &lt;p&gt; Some methods of class {@code Class} expose whether the declaration of
 140  * a class or interface in Java source code was &lt;em&gt;enclosed&lt;/em&gt; within
 141  * another declaration. Other methods describe how a class or interface
 142  * is situated in a &lt;em&gt;nest&lt;/em&gt;. A &lt;a id=&quot;nest&quot;&gt;nest&lt;/a&gt; is a set of
 143  * classes and interfaces, in the same run-time package, that
 144  * allow mutual access to their {@code private} members.
 145  * The classes and interfaces are known as &lt;em&gt;nestmates&lt;/em&gt;.
 146  * One nestmate acts as the
 147  * &lt;em&gt;nest host&lt;/em&gt;, and enumerates the other nestmates which
 148  * belong to the nest; each of them in turn records it as the nest host.
 149  * The classes and interfaces which belong to a nest, including its host, are
 150  * determined when
 151  * {@code class} files are generated, for example, a Java compiler
 152  * will typically record a top-level class as the host of a nest where the
 153  * other members are the classes and interfaces whose declarations are
 154  * enclosed within the top-level class declaration.
 155  *
 156  * &lt;p&gt; A class or interface created by the invocation of
 157  * {@link java.lang.invoke.MethodHandles.Lookup#defineHiddenClass(byte[], boolean, MethodHandles.Lookup.ClassOption...)
 158  * Lookup::defineHiddenClass} is a {@linkplain Class#isHidden() &lt;em&gt;hidden&lt;/em&gt;}
 159  * class or interface.
 160  * All kinds of class, including enum types and record types, may be
 161  * hidden classes; all kinds of interface, including annotation types,
 162  * may be hidden interfaces.
 163  *
 164  * The {@linkplain #getName() name of a hidden class or interface} is
 165  * not a &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;binary name&lt;/a&gt;,
 166  * which means the following:
 167  * &lt;ul&gt;
 168  * &lt;li&gt;A hidden class or interface cannot be referenced by the constant pools
 169  *     of other classes and interfaces.
 170  * &lt;li&gt;A hidden class or interface cannot be described in
 171  *     {@linkplain java.lang.constant.ConstantDesc &lt;em&gt;nominal form&lt;/em&gt;} by
 172  *     {@link #describeConstable() Class::describeConstable},
 173  *     {@link ClassDesc#of(String) ClassDesc::of}, or
 174  *     {@link ClassDesc#ofDescriptor(String) ClassDesc::ofDescriptor}.
 175  * &lt;li&gt;A hidden class or interface cannot be discovered by {@link #forName Class::forName}
 176  *     or {@link ClassLoader#loadClass(String, boolean) ClassLoader::loadClass}.
 177  * &lt;/ul&gt;
 178  *
 179  * A hidden class or interface is never an array class, but may be
 180  * the element type of an array. In all other respects, the fact that
 181  * a class or interface is hidden has no bearing on the characteristics
 182  * exposed by the methods of class {@code Class}.
 183  *
 184  * @param &lt;T&gt; the type of the class modeled by this {@code Class}
 185  * object.  For example, the type of {@code String.class} is {@code
 186  * Class&lt;String&gt;}.  Use {@code Class&lt;?&gt;} if the class being modeled is
 187  * unknown.
 188  *
 189  * @author  unascribed
 190  * @see     java.lang.ClassLoader#defineClass(byte[], int, int)
 191  * @since   1.0
 192  * @jls 15.8.2 Class Literals
 193  */
 194 public final class Class&lt;T&gt; implements java.io.Serializable,
 195                               GenericDeclaration,
 196                               Type,
 197                               AnnotatedElement,
 198                               TypeDescriptor.OfField&lt;Class&lt;?&gt;&gt;,
 199                               Constable {
 200     private static final int ANNOTATION= 0x00002000;
 201     private static final int ENUM      = 0x00004000;
 202     private static final int SYNTHETIC = 0x00001000;
 203 
 204     private static native void registerNatives();
 205     static {
 206         registerNatives();
 207     }
 208 
 209     /*
 210      * Private constructor. Only the Java Virtual Machine creates Class objects.
 211      * This constructor is not used and prevents the default constructor being
 212      * generated.
 213      */
 214     private Class(ClassLoader loader, Class&lt;?&gt; arrayComponentType) {
 215         // Initialize final field for classLoader.  The initialization value of non-null
 216         // prevents future JIT optimizations from assuming this final field is null.
 217         classLoader = loader;
 218         componentType = arrayComponentType;
 219     }
 220 
 221     /**
 222      * Converts the object to a string. The string representation is the
 223      * string &quot;class&quot; or &quot;interface&quot;, followed by a space, and then by the
 224      * name of the class in the format returned by {@code getName}.
 225      * If this {@code Class} object represents a primitive type,
 226      * this method returns the name of the primitive type.  If
 227      * this {@code Class} object represents void this method returns
 228      * &quot;void&quot;. If this {@code Class} object represents an array type,
 229      * this method returns &quot;class &quot; followed by {@code getName}.
 230      *
 231      * @return a string representation of this {@code Class} object.
 232      */
 233     public String toString() {
 234         return (isInterface() ? &quot;interface &quot; : (isPrimitive() ? &quot;&quot; : &quot;class &quot;))
 235             + getName();
 236     }
 237 
 238     /**
 239      * Returns a string describing this {@code Class}, including
 240      * information about modifiers and type parameters.
 241      *
 242      * The string is formatted as a list of type modifiers, if any,
 243      * followed by the kind of type (empty string for primitive types
 244      * and {@code class}, {@code enum}, {@code interface},
 245      * {@code @interface}, or {@code record} as appropriate), followed
 246      * by the type&#39;s name, followed by an angle-bracketed
 247      * comma-separated list of the type&#39;s type parameters, if any,
 248      * including informative bounds on the type parameters, if any.
 249      *
 250      * A space is used to separate modifiers from one another and to
 251      * separate any modifiers from the kind of type. The modifiers
 252      * occur in canonical order. If there are no type parameters, the
 253      * type parameter list is elided.
 254      *
 255      * For an array type, the string starts with the type name,
 256      * followed by an angle-bracketed comma-separated list of the
 257      * type&#39;s type parameters, if any, followed by a sequence of
 258      * {@code []} characters, one set of brackets per dimension of
 259      * the array.
 260      *
 261      * &lt;p&gt;Note that since information about the runtime representation
 262      * of a type is being generated, modifiers not present on the
 263      * originating source code or illegal on the originating source
 264      * code may be present.
 265      *
 266      * @return a string describing this {@code Class}, including
 267      * information about modifiers and type parameters
 268      *
 269      * @since 1.8
 270      */
 271     @SuppressWarnings(&quot;preview&quot;)
 272     public String toGenericString() {
 273         if (isPrimitive()) {
 274             return toString();
 275         } else {
 276             StringBuilder sb = new StringBuilder();
 277             Class&lt;?&gt; component = this;
 278             int arrayDepth = 0;
 279 
 280             if (isArray()) {
 281                 do {
 282                     arrayDepth++;
 283                     component = component.getComponentType();
 284                 } while (component.isArray());
 285                 sb.append(component.getName());
 286             } else {
 287                 // Class modifiers are a superset of interface modifiers
 288                 int modifiers = getModifiers() &amp; Modifier.classModifiers();
 289                 if (modifiers != 0) {
 290                     sb.append(Modifier.toString(modifiers));
 291                     sb.append(&#39; &#39;);
 292                 }
 293 
 294                 if (isAnnotation()) {
 295                     sb.append(&#39;@&#39;);
 296                 }
 297                 if (isInterface()) { // Note: all annotation types are interfaces
 298                     sb.append(&quot;interface&quot;);
 299                 } else {
 300                     if (isEnum())
 301                         sb.append(&quot;enum&quot;);
 302                     else if (isRecord())
 303                         sb.append(&quot;record&quot;);
 304                     else
 305                         sb.append(&quot;class&quot;);
 306                 }
 307                 sb.append(&#39; &#39;);
 308                 sb.append(getName());
 309             }
 310 
 311             TypeVariable&lt;?&gt;[] typeparms = component.getTypeParameters();
 312             if (typeparms.length &gt; 0) {
 313                 sb.append(Arrays.stream(typeparms)
 314                           .map(Class::typeVarBounds)
 315                           .collect(Collectors.joining(&quot;,&quot;, &quot;&lt;&quot;, &quot;&gt;&quot;)));
 316             }
 317 
 318             if (arrayDepth &gt; 0) sb.append(&quot;[]&quot;.repeat(arrayDepth));
 319 
 320             return sb.toString();
 321         }
 322     }
 323 
 324     static String typeVarBounds(TypeVariable&lt;?&gt; typeVar) {
 325         Type[] bounds = typeVar.getBounds();
 326         if (bounds.length == 1 &amp;&amp; bounds[0].equals(Object.class)) {
 327             return typeVar.getName();
 328         } else {
 329             return typeVar.getName() + &quot; extends &quot; +
 330                 Arrays.stream(bounds)
 331                 .map(Type::getTypeName)
 332                 .collect(Collectors.joining(&quot; &amp; &quot;));
 333         }
 334     }
 335 
 336     /**
 337      * Returns the {@code Class} object associated with the class or
 338      * interface with the given string name.  Invoking this method is
 339      * equivalent to:
 340      *
 341      * &lt;blockquote&gt;
 342      *  {@code Class.forName(className, true, currentLoader)}
 343      * &lt;/blockquote&gt;
 344      *
 345      * where {@code currentLoader} denotes the defining class loader of
 346      * the current class.
 347      *
 348      * &lt;p&gt; For example, the following code fragment returns the
 349      * runtime {@code Class} descriptor for the class named
 350      * {@code java.lang.Thread}:
 351      *
 352      * &lt;blockquote&gt;
 353      *   {@code Class t = Class.forName(&quot;java.lang.Thread&quot;)}
 354      * &lt;/blockquote&gt;
 355      * &lt;p&gt;
 356      * A call to {@code forName(&quot;X&quot;)} causes the class named
 357      * {@code X} to be initialized.
 358      *
 359      * @param      className   the fully qualified name of the desired class.
 360      * @return     the {@code Class} object for the class with the
 361      *             specified name.
 362      * @throws    LinkageError if the linkage fails
 363      * @throws    ExceptionInInitializerError if the initialization provoked
 364      *            by this method fails
 365      * @throws    ClassNotFoundException if the class cannot be located
 366      *
 367      * @jls 12.2 Loading of Classes and Interfaces
 368      * @jls 12.3 Linking of Classes and Interfaces
 369      * @jls 12.4 Initialization of Classes and Interfaces
 370      */
 371     @CallerSensitive
 372     public static Class&lt;?&gt; forName(String className)
 373                 throws ClassNotFoundException {
 374         Class&lt;?&gt; caller = Reflection.getCallerClass();
 375         return forName0(className, true, ClassLoader.getClassLoader(caller), caller);
 376     }
 377 
 378 
 379     /**
 380      * Returns the {@code Class} object associated with the class or
 381      * interface with the given string name, using the given class loader.
 382      * Given the fully qualified name for a class or interface (in the same
 383      * format returned by {@code getName}) this method attempts to
 384      * locate and load the class or interface.  The specified class
 385      * loader is used to load the class or interface.  If the parameter
 386      * {@code loader} is null, the class is loaded through the bootstrap
 387      * class loader.  The class is initialized only if the
 388      * {@code initialize} parameter is {@code true} and if it has
 389      * not been initialized earlier.
 390      *
 391      * &lt;p&gt; If {@code name} denotes a primitive type or void, an attempt
 392      * will be made to locate a user-defined class in the unnamed package whose
 393      * name is {@code name}. Therefore, this method cannot be used to
 394      * obtain any of the {@code Class} objects representing primitive
 395      * types or void.
 396      *
 397      * &lt;p&gt; If {@code name} denotes an array class, the component type of
 398      * the array class is loaded but not initialized.
 399      *
 400      * &lt;p&gt; For example, in an instance method the expression:
 401      *
 402      * &lt;blockquote&gt;
 403      *  {@code Class.forName(&quot;Foo&quot;)}
 404      * &lt;/blockquote&gt;
 405      *
 406      * is equivalent to:
 407      *
 408      * &lt;blockquote&gt;
 409      *  {@code Class.forName(&quot;Foo&quot;, true, this.getClass().getClassLoader())}
 410      * &lt;/blockquote&gt;
 411      *
 412      * Note that this method throws errors related to loading, linking
 413      * or initializing as specified in Sections {@jls 12.2}, {@jls
 414      * 12.3}, and {@jls 12.4} of &lt;cite&gt;The Java&amp;trade; Language
 415      * Specification&lt;/cite&gt;.
 416      * Note that this method does not check whether the requested class
 417      * is accessible to its caller.
 418      *
 419      * @param name       fully qualified name of the desired class
 420 
 421      * @param initialize if {@code true} the class will be initialized
 422      *                   (which implies linking). See Section {@jls
 423      *                   12.4} of &lt;cite&gt;The Java&amp;trade; Language
 424      *                   Specification&lt;/cite&gt;.
 425      * @param loader     class loader from which the class must be loaded
 426      * @return           class object representing the desired class
 427      *
 428      * @throws    LinkageError if the linkage fails
 429      * @throws    ExceptionInInitializerError if the initialization provoked
 430      *            by this method fails
 431      * @throws    ClassNotFoundException if the class cannot be located by
 432      *            the specified class loader
 433      * @throws    SecurityException
 434      *            if a security manager is present, and the {@code loader} is
 435      *            {@code null}, and the caller&#39;s class loader is not
 436      *            {@code null}, and the caller does not have the
 437      *            {@link RuntimePermission}{@code (&quot;getClassLoader&quot;)}
 438      *
 439      * @see       java.lang.Class#forName(String)
 440      * @see       java.lang.ClassLoader
 441      *
 442      * @jls 12.2 Loading of Classes and Interfaces
 443      * @jls 12.3 Linking of Classes and Interfaces
 444      * @jls 12.4 Initialization of Classes and Interfaces
 445      * @since     1.2
 446      */
 447     @CallerSensitive
 448     public static Class&lt;?&gt; forName(String name, boolean initialize,
 449                                    ClassLoader loader)
 450         throws ClassNotFoundException
 451     {
 452         Class&lt;?&gt; caller = null;
 453         SecurityManager sm = System.getSecurityManager();
 454         if (sm != null) {
 455             // Reflective call to get caller class is only needed if a security manager
 456             // is present.  Avoid the overhead of making this call otherwise.
 457             caller = Reflection.getCallerClass();
 458             if (loader == null) {
 459                 ClassLoader ccl = ClassLoader.getClassLoader(caller);
 460                 if (ccl != null) {
 461                     sm.checkPermission(
 462                         SecurityConstants.GET_CLASSLOADER_PERMISSION);
 463                 }
 464             }
 465         }
 466         return forName0(name, initialize, loader, caller);
 467     }
 468 
 469     /** Called after security check for system loader access checks have been made. */
 470     private static native Class&lt;?&gt; forName0(String name, boolean initialize,
 471                                             ClassLoader loader,
 472                                             Class&lt;?&gt; caller)
 473         throws ClassNotFoundException;
 474 
 475 
 476     /**
 477      * Returns the {@code Class} with the given &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;
 478      * binary name&lt;/a&gt; in the given module.
 479      *
 480      * &lt;p&gt; This method attempts to locate and load the class or interface.
 481      * It does not link the class, and does not run the class initializer.
 482      * If the class is not found, this method returns {@code null}. &lt;/p&gt;
 483      *
 484      * &lt;p&gt; If the class loader of the given module defines other modules and
 485      * the given name is a class defined in a different module, this method
 486      * returns {@code null} after the class is loaded. &lt;/p&gt;
 487      *
 488      * &lt;p&gt; This method does not check whether the requested class is
 489      * accessible to its caller. &lt;/p&gt;
 490      *
 491      * @apiNote
 492      * This method returns {@code null} on failure rather than
 493      * throwing a {@link ClassNotFoundException}, as is done by
 494      * the {@link #forName(String, boolean, ClassLoader)} method.
 495      * The security check is a stack-based permission check if the caller
 496      * loads a class in another module.
 497      *
 498      * @param  module   A module
 499      * @param  name     The &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;binary name&lt;/a&gt;
 500      *                  of the class
 501      * @return {@code Class} object of the given name defined in the given module;
 502      *         {@code null} if not found.
 503      *
 504      * @throws NullPointerException if the given module or name is {@code null}
 505      *
 506      * @throws LinkageError if the linkage fails
 507      *
 508      * @throws SecurityException
 509      *         &lt;ul&gt;
 510      *         &lt;li&gt; if the caller is not the specified module and
 511      *         {@code RuntimePermission(&quot;getClassLoader&quot;)} permission is denied; or&lt;/li&gt;
 512      *         &lt;li&gt; access to the module content is denied. For example,
 513      *         permission check will be performed when a class loader calls
 514      *         {@link ModuleReader#open(String)} to read the bytes of a class file
 515      *         in a module.&lt;/li&gt;
 516      *         &lt;/ul&gt;
 517      *
 518      * @jls 12.2 Loading of Classes and Interfaces
 519      * @jls 12.3 Linking of Classes and Interfaces
 520      * @since 9
 521      * @spec JPMS
 522      */
 523     @CallerSensitive
 524     public static Class&lt;?&gt; forName(Module module, String name) {
 525         Objects.requireNonNull(module);
 526         Objects.requireNonNull(name);
 527 
 528         ClassLoader cl;
 529         SecurityManager sm = System.getSecurityManager();
 530         if (sm != null) {
 531             Class&lt;?&gt; caller = Reflection.getCallerClass();
 532             if (caller != null &amp;&amp; caller.getModule() != module) {
 533                 // if caller is null, Class.forName is the last java frame on the stack.
 534                 // java.base has all permissions
 535                 sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);
 536             }
 537             PrivilegedAction&lt;ClassLoader&gt; pa = module::getClassLoader;
 538             cl = AccessController.doPrivileged(pa);
 539         } else {
 540             cl = module.getClassLoader();
 541         }
 542 
 543         if (cl != null) {
 544             return cl.loadClass(module, name);
 545         } else {
 546             return BootLoader.loadClass(module, name);
 547         }
 548     }
 549 
 550     /**
 551      * Creates a new instance of the class represented by this {@code Class}
 552      * object.  The class is instantiated as if by a {@code new}
 553      * expression with an empty argument list.  The class is initialized if it
 554      * has not already been initialized.
 555      *
 556      * @deprecated This method propagates any exception thrown by the
 557      * nullary constructor, including a checked exception.  Use of
 558      * this method effectively bypasses the compile-time exception
 559      * checking that would otherwise be performed by the compiler.
 560      * The {@link
 561      * java.lang.reflect.Constructor#newInstance(java.lang.Object...)
 562      * Constructor.newInstance} method avoids this problem by wrapping
 563      * any exception thrown by the constructor in a (checked) {@link
 564      * java.lang.reflect.InvocationTargetException}.
 565      *
 566      * &lt;p&gt;The call
 567      *
 568      * &lt;pre&gt;{@code
 569      * clazz.newInstance()
 570      * }&lt;/pre&gt;
 571      *
 572      * can be replaced by
 573      *
 574      * &lt;pre&gt;{@code
 575      * clazz.getDeclaredConstructor().newInstance()
 576      * }&lt;/pre&gt;
 577      *
 578      * The latter sequence of calls is inferred to be able to throw
 579      * the additional exception types {@link
 580      * InvocationTargetException} and {@link
 581      * NoSuchMethodException}. Both of these exception types are
 582      * subclasses of {@link ReflectiveOperationException}.
 583      *
 584      * @return  a newly allocated instance of the class represented by this
 585      *          object.
 586      * @throws  IllegalAccessException  if the class or its nullary
 587      *          constructor is not accessible.
 588      * @throws  InstantiationException
 589      *          if this {@code Class} represents an abstract class,
 590      *          an interface, an array class, a primitive type, or void;
 591      *          or if the class has no nullary constructor;
 592      *          or if the instantiation fails for some other reason.
 593      * @throws  ExceptionInInitializerError if the initialization
 594      *          provoked by this method fails.
 595      * @throws  SecurityException
 596      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
 597      *          the caller&#39;s class loader is not the same as or an
 598      *          ancestor of the class loader for the current class and
 599      *          invocation of {@link SecurityManager#checkPackageAccess
 600      *          s.checkPackageAccess()} denies access to the package
 601      *          of this class.
 602      */
 603     @CallerSensitive
 604     @Deprecated(since=&quot;9&quot;)
 605     public T newInstance()
 606         throws InstantiationException, IllegalAccessException
 607     {
 608         SecurityManager sm = System.getSecurityManager();
 609         if (sm != null) {
 610             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), false);
 611         }
 612 
 613         // Constructor lookup
 614         Constructor&lt;T&gt; tmpConstructor = cachedConstructor;
 615         if (tmpConstructor == null) {
 616             if (this == Class.class) {
 617                 throw new IllegalAccessException(
 618                     &quot;Can not call newInstance() on the Class for java.lang.Class&quot;
 619                 );
 620             }
 621             try {
 622                 Class&lt;?&gt;[] empty = {};
 623                 final Constructor&lt;T&gt; c = getReflectionFactory().copyConstructor(
 624                     getConstructor0(empty, Member.DECLARED));
 625                 // Disable accessibility checks on the constructor
 626                 // access check is done with the true caller
 627                 java.security.AccessController.doPrivileged(
 628                     new java.security.PrivilegedAction&lt;&gt;() {
 629                         public Void run() {
 630                                 c.setAccessible(true);
 631                                 return null;
 632                             }
 633                         });
 634                 cachedConstructor = tmpConstructor = c;
 635             } catch (NoSuchMethodException e) {
 636                 throw (InstantiationException)
 637                     new InstantiationException(getName()).initCause(e);
 638             }
 639         }
 640 
 641         try {
 642             Class&lt;?&gt; caller = Reflection.getCallerClass();
 643             return getReflectionFactory().newInstance(tmpConstructor, null, caller);
 644         } catch (InvocationTargetException e) {
 645             Unsafe.getUnsafe().throwException(e.getTargetException());
 646             // Not reached
 647             return null;
 648         }
 649     }
 650 
 651     private transient volatile Constructor&lt;T&gt; cachedConstructor;
 652 
 653     /**
 654      * Determines if the specified {@code Object} is assignment-compatible
 655      * with the object represented by this {@code Class}.  This method is
 656      * the dynamic equivalent of the Java language {@code instanceof}
 657      * operator. The method returns {@code true} if the specified
 658      * {@code Object} argument is non-null and can be cast to the
 659      * reference type represented by this {@code Class} object without
 660      * raising a {@code ClassCastException.} It returns {@code false}
 661      * otherwise.
 662      *
 663      * &lt;p&gt; Specifically, if this {@code Class} object represents a
 664      * declared class, this method returns {@code true} if the specified
 665      * {@code Object} argument is an instance of the represented class (or
 666      * of any of its subclasses); it returns {@code false} otherwise. If
 667      * this {@code Class} object represents an array class, this method
 668      * returns {@code true} if the specified {@code Object} argument
 669      * can be converted to an object of the array class by an identity
 670      * conversion or by a widening reference conversion; it returns
 671      * {@code false} otherwise. If this {@code Class} object
 672      * represents an interface, this method returns {@code true} if the
 673      * class or any superclass of the specified {@code Object} argument
 674      * implements this interface; it returns {@code false} otherwise. If
 675      * this {@code Class} object represents a primitive type, this method
 676      * returns {@code false}.
 677      *
 678      * @param   obj the object to check
 679      * @return  true if {@code obj} is an instance of this class
 680      *
 681      * @since 1.1
 682      */
 683     @HotSpotIntrinsicCandidate
 684     public native boolean isInstance(Object obj);
 685 
 686 
 687     /**
 688      * Determines if the class or interface represented by this
 689      * {@code Class} object is either the same as, or is a superclass or
 690      * superinterface of, the class or interface represented by the specified
 691      * {@code Class} parameter. It returns {@code true} if so;
 692      * otherwise it returns {@code false}. If this {@code Class}
 693      * object represents a primitive type, this method returns
 694      * {@code true} if the specified {@code Class} parameter is
 695      * exactly this {@code Class} object; otherwise it returns
 696      * {@code false}.
 697      *
 698      * &lt;p&gt; Specifically, this method tests whether the type represented by the
 699      * specified {@code Class} parameter can be converted to the type
 700      * represented by this {@code Class} object via an identity conversion
 701      * or via a widening reference conversion. See &lt;cite&gt;The Java&amp;trade; Language
 702      * Specification&lt;/cite&gt;, sections {@jls 5.1.1} and {@jls 5.1.4},
 703      * for details.
 704      *
 705      * @param     cls the {@code Class} object to be checked
 706      * @return    the {@code boolean} value indicating whether objects of the
 707      *            type {@code cls} can be assigned to objects of this class
 708      * @throws    NullPointerException if the specified Class parameter is
 709      *            null.
 710      * @since     1.1
 711      */
 712     @HotSpotIntrinsicCandidate
 713     public native boolean isAssignableFrom(Class&lt;?&gt; cls);
 714 
 715 
 716     /**
 717      * Determines if this {@code Class} object represents an
 718      * interface type.
 719      *
 720      * @return  {@code true} if this {@code Class} object represents an interface;
 721      *          {@code false} otherwise.
 722      */
 723     @HotSpotIntrinsicCandidate
 724     public native boolean isInterface();
 725 
 726 
 727     /**
 728      * Determines if this {@code Class} object represents an array class.
 729      *
 730      * @return  {@code true} if this {@code Class} object represents an array class;
 731      *          {@code false} otherwise.
 732      * @since   1.1
 733      */
 734     @HotSpotIntrinsicCandidate
 735     public native boolean isArray();
 736 
 737 
 738     /**
 739      * Determines if the specified {@code Class} object represents a
 740      * primitive type.
 741      *
 742      * &lt;p&gt; There are nine predefined {@code Class} objects to represent
 743      * the eight primitive types and void.  These are created by the Java
 744      * Virtual Machine, and have the same names as the primitive types that
 745      * they represent, namely {@code boolean}, {@code byte},
 746      * {@code char}, {@code short}, {@code int},
 747      * {@code long}, {@code float}, and {@code double}.
 748      *
 749      * &lt;p&gt; These objects may only be accessed via the following public static
 750      * final variables, and are the only {@code Class} objects for which
 751      * this method returns {@code true}.
 752      *
 753      * @return true if and only if this class represents a primitive type
 754      *
 755      * @see     java.lang.Boolean#TYPE
 756      * @see     java.lang.Character#TYPE
 757      * @see     java.lang.Byte#TYPE
 758      * @see     java.lang.Short#TYPE
 759      * @see     java.lang.Integer#TYPE
 760      * @see     java.lang.Long#TYPE
 761      * @see     java.lang.Float#TYPE
 762      * @see     java.lang.Double#TYPE
 763      * @see     java.lang.Void#TYPE
 764      * @since 1.1
 765      */
 766     @HotSpotIntrinsicCandidate
 767     public native boolean isPrimitive();
 768 
 769     /**
 770      * Returns true if this {@code Class} object represents an annotation
 771      * type.  Note that if this method returns true, {@link #isInterface()}
 772      * would also return true, as all annotation types are also interfaces.
 773      *
 774      * @return {@code true} if this {@code Class} object represents an annotation
 775      *      type; {@code false} otherwise
 776      * @since 1.5
 777      */
 778     public boolean isAnnotation() {
 779         return (getModifiers() &amp; ANNOTATION) != 0;
 780     }
 781 
 782     /**
 783      * Returns {@code true} if and only if this class has the synthetic modifier
 784      * bit set.
 785      *
 786      * @return {@code true} if and only if this class has the synthetic modifier bit set
 787      * @jls 13.1 The Form of a Binary
 788      * @jvms 4.1 The {@code ClassFile} Structure
 789      * @since 1.5
 790      */
 791     public boolean isSynthetic() {
 792         return (getModifiers() &amp; SYNTHETIC) != 0;
 793     }
 794 
 795     /**
 796      * Returns the  name of the entity (class, interface, array class,
 797      * primitive type, or void) represented by this {@code Class} object.
 798      *
 799      * &lt;p&gt; If this {@code Class} object represents a class or interface,
 800      * not an array class, then:
 801      * &lt;ul&gt;
 802      * &lt;li&gt; If the class or interface is not {@linkplain #isHidden() hidden},
 803      *      then the &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;binary name&lt;/a&gt;
 804      *      of the class or interface is returned.
 805      * &lt;li&gt; If the class or interface is hidden, then the result is a string
 806      *      of the form: {@code N + &#39;/&#39; + &lt;suffix&gt;}
 807      *      where {@code N} is the &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;binary name&lt;/a&gt;
 808      *      indicated by the {@code class} file passed to
 809      *      {@link java.lang.invoke.MethodHandles.Lookup#defineHiddenClass(byte[], boolean, MethodHandles.Lookup.ClassOption...)
 810      *      Lookup::defineHiddenClass}, and {@code &lt;suffix&gt;} is an unqualified name.
 811      * &lt;/ul&gt;
 812      *
 813      * &lt;p&gt; If this {@code Class} object represents an array class, then
 814      * the result is a string consisting of one or more &#39;{@code [}&#39; characters
 815      * representing the depth of the array nesting, followed by the element
 816      * type as encoded using the following table:
 817      *
 818      * &lt;blockquote&gt;&lt;table class=&quot;striped&quot;&gt;
 819      * &lt;caption style=&quot;display:none&quot;&gt;Element types and encodings&lt;/caption&gt;
 820      * &lt;thead&gt;
 821      * &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt; Element Type &lt;th scope=&quot;col&quot;&gt; Encoding
 822      * &lt;/thead&gt;
 823      * &lt;tbody style=&quot;text-align:left&quot;&gt;
 824      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code boolean} &lt;td style=&quot;text-align:center&quot;&gt; {@code Z}
 825      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code byte}    &lt;td style=&quot;text-align:center&quot;&gt; {@code B}
 826      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code char}    &lt;td style=&quot;text-align:center&quot;&gt; {@code C}
 827      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; class or interface with &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;binary name&lt;/a&gt; &lt;i&gt;N&lt;/i&gt;
 828      *                                      &lt;td style=&quot;text-align:center&quot;&gt; {@code L}&lt;em&gt;N&lt;/em&gt;{@code ;}
 829      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code double}  &lt;td style=&quot;text-align:center&quot;&gt; {@code D}
 830      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code float}   &lt;td style=&quot;text-align:center&quot;&gt; {@code F}
 831      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code int}     &lt;td style=&quot;text-align:center&quot;&gt; {@code I}
 832      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code long}    &lt;td style=&quot;text-align:center&quot;&gt; {@code J}
 833      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code short}   &lt;td style=&quot;text-align:center&quot;&gt; {@code S}
 834      * &lt;/tbody&gt;
 835      * &lt;/table&gt;&lt;/blockquote&gt;
 836      *
 837      * &lt;p&gt; If this {@code Class} object represents a primitive type or {@code void},
 838      * then the result is a string with the same spelling as the Java language
 839      * keyword which corresponds to the primitive type or {@code void}.
 840      *
 841      * &lt;p&gt; Examples:
 842      * &lt;blockquote&gt;&lt;pre&gt;
 843      * String.class.getName()
 844      *     returns &quot;java.lang.String&quot;
 845      * byte.class.getName()
 846      *     returns &quot;byte&quot;
 847      * (new Object[3]).getClass().getName()
 848      *     returns &quot;[Ljava.lang.Object;&quot;
 849      * (new int[3][4][5][6][7][8][9]).getClass().getName()
 850      *     returns &quot;[[[[[[[I&quot;
 851      * &lt;/pre&gt;&lt;/blockquote&gt;
 852      *
 853      * @return  the name of the class, interface, or other entity
 854      *          represented by this {@code Class} object.
 855      * @jls 13.1 The Form of a Binary
 856      */
 857     public String getName() {
 858         String name = this.name;
 859         return name != null ? name : initClassName();
 860     }
 861 
 862     // Cache the name to reduce the number of calls into the VM.
 863     // This field would be set by VM itself during initClassName call.
 864     private transient String name;
 865     private native String initClassName();
 866 
 867     /**
 868      * Returns the class loader for the class.  Some implementations may use
 869      * null to represent the bootstrap class loader. This method will return
 870      * null in such implementations if this class was loaded by the bootstrap
 871      * class loader.
 872      *
 873      * &lt;p&gt;If this {@code Class} object
 874      * represents a primitive type or void, null is returned.
 875      *
 876      * @return  the class loader that loaded the class or interface
 877      *          represented by this {@code Class} object.
 878      * @throws  SecurityException
 879      *          if a security manager is present, and the caller&#39;s class loader
 880      *          is not {@code null} and is not the same as or an ancestor of the
 881      *          class loader for the class whose class loader is requested,
 882      *          and the caller does not have the
 883      *          {@link RuntimePermission}{@code (&quot;getClassLoader&quot;)}
 884      * @see java.lang.ClassLoader
 885      * @see SecurityManager#checkPermission
 886      * @see java.lang.RuntimePermission
 887      */
 888     @CallerSensitive
 889     @ForceInline // to ensure Reflection.getCallerClass optimization
 890     public ClassLoader getClassLoader() {
 891         ClassLoader cl = getClassLoader0();
 892         if (cl == null)
 893             return null;
 894         SecurityManager sm = System.getSecurityManager();
 895         if (sm != null) {
 896             ClassLoader.checkClassLoaderPermission(cl, Reflection.getCallerClass());
 897         }
 898         return cl;
 899     }
 900 
 901     // Package-private to allow ClassLoader access
 902     ClassLoader getClassLoader0() { return classLoader; }
 903 
 904     /**
 905      * Returns the module that this class or interface is a member of.
 906      *
 907      * If this class represents an array type then this method returns the
 908      * {@code Module} for the element type. If this class represents a
 909      * primitive type or void, then the {@code Module} object for the
 910      * {@code java.base} module is returned.
 911      *
 912      * If this class is in an unnamed module then the {@linkplain
 913      * ClassLoader#getUnnamedModule() unnamed} {@code Module} of the class
 914      * loader for this class is returned.
 915      *
 916      * @return the module that this class or interface is a member of
 917      *
 918      * @since 9
 919      * @spec JPMS
 920      */
 921     public Module getModule() {
 922         return module;
 923     }
 924 
 925     // set by VM
 926     private transient Module module;
 927 
 928     // Initialized in JVM not by private constructor
 929     // This field is filtered from reflection access, i.e. getDeclaredField
 930     // will throw NoSuchFieldException
 931     private final ClassLoader classLoader;
 932 
 933     // Set by VM
 934     private transient Object classData;
 935 
 936     // package-private
 937     Object getClassData() {
 938         return classData;
 939     }
 940 
 941     /**
 942      * Returns an array of {@code TypeVariable} objects that represent the
 943      * type variables declared by the generic declaration represented by this
 944      * {@code GenericDeclaration} object, in declaration order.  Returns an
 945      * array of length 0 if the underlying generic declaration declares no type
 946      * variables.
 947      *
 948      * @return an array of {@code TypeVariable} objects that represent
 949      *     the type variables declared by this generic declaration
 950      * @throws java.lang.reflect.GenericSignatureFormatError if the generic
 951      *     signature of this generic declaration does not conform to
 952      *     the format specified in section {@jvms 4.7.9} of
 953      *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;
 954      * @since 1.5
 955      */
 956     @SuppressWarnings(&quot;unchecked&quot;)
 957     public TypeVariable&lt;Class&lt;T&gt;&gt;[] getTypeParameters() {
 958         ClassRepository info = getGenericInfo();
 959         if (info != null)
 960             return (TypeVariable&lt;Class&lt;T&gt;&gt;[])info.getTypeParameters();
 961         else
 962             return (TypeVariable&lt;Class&lt;T&gt;&gt;[])new TypeVariable&lt;?&gt;[0];
 963     }
 964 
 965 
 966     /**
 967      * Returns the {@code Class} representing the direct superclass of the
 968      * entity (class, interface, primitive type or void) represented by
 969      * this {@code Class}.  If this {@code Class} represents either the
 970      * {@code Object} class, an interface, a primitive type, or void, then
 971      * null is returned.  If this {@code Class} object represents an array class
 972      * then the {@code Class} object representing the {@code Object} class is
 973      * returned.
 974      *
 975      * @return the direct superclass of the class represented by this {@code Class} object
 976      */
 977     @HotSpotIntrinsicCandidate
 978     public native Class&lt;? super T&gt; getSuperclass();
 979 
 980 
 981     /**
 982      * Returns the {@code Type} representing the direct superclass of
 983      * the entity (class, interface, primitive type or void) represented by
 984      * this {@code Class} object.
 985      *
 986      * &lt;p&gt;If the superclass is a parameterized type, the {@code Type}
 987      * object returned must accurately reflect the actual type
 988      * arguments used in the source code. The parameterized type
 989      * representing the superclass is created if it had not been
 990      * created before. See the declaration of {@link
 991      * java.lang.reflect.ParameterizedType ParameterizedType} for the
 992      * semantics of the creation process for parameterized types.  If
 993      * this {@code Class} object represents either the {@code Object}
 994      * class, an interface, a primitive type, or void, then null is
 995      * returned.  If this {@code Class} object represents an array class
 996      * then the {@code Class} object representing the {@code Object} class is
 997      * returned.
 998      *
 999      * @throws java.lang.reflect.GenericSignatureFormatError if the generic
1000      *     class signature does not conform to the format specified in
1001      *     section {@jvms 4.7.9} of &lt;cite&gt;The Java&amp;trade; Virtual
1002      *     Machine Specification&lt;/cite&gt;
1003      * @throws TypeNotPresentException if the generic superclass
1004      *     refers to a non-existent type declaration
1005      * @throws java.lang.reflect.MalformedParameterizedTypeException if the
1006      *     generic superclass refers to a parameterized type that cannot be
1007      *     instantiated  for any reason
1008      * @return the direct superclass of the class represented by this {@code Class} object
1009      * @since 1.5
1010      */
1011     public Type getGenericSuperclass() {
1012         ClassRepository info = getGenericInfo();
1013         if (info == null) {
1014             return getSuperclass();
1015         }
1016 
1017         // Historical irregularity:
1018         // Generic signature marks interfaces with superclass = Object
1019         // but this API returns null for interfaces
1020         if (isInterface()) {
1021             return null;
1022         }
1023 
1024         return info.getSuperclass();
1025     }
1026 
1027     /**
1028      * Gets the package of this class.
1029      *
1030      * &lt;p&gt;If this class represents an array type, a primitive type or void,
1031      * this method returns {@code null}.
1032      *
1033      * @return the package of this class.
1034      * @revised 9
1035      * @spec JPMS
1036      */
1037     public Package getPackage() {
1038         if (isPrimitive() || isArray()) {
1039             return null;
1040         }
1041         ClassLoader cl = getClassLoader0();
1042         return cl != null ? cl.definePackage(this)
1043                           : BootLoader.definePackage(this);
1044     }
1045 
1046     /**
1047      * Returns the fully qualified package name.
1048      *
1049      * &lt;p&gt; If this class is a top level class, then this method returns the fully
1050      * qualified name of the package that the class is a member of, or the
1051      * empty string if the class is in an unnamed package.
1052      *
1053      * &lt;p&gt; If this class is a member class, then this method is equivalent to
1054      * invoking {@code getPackageName()} on the {@linkplain #getEnclosingClass
1055      * enclosing class}.
1056      *
1057      * &lt;p&gt; If this class is a {@linkplain #isLocalClass local class} or an {@linkplain
1058      * #isAnonymousClass() anonymous class}, then this method is equivalent to
1059      * invoking {@code getPackageName()} on the {@linkplain #getDeclaringClass
1060      * declaring class} of the {@linkplain #getEnclosingMethod enclosing method} or
1061      * {@linkplain #getEnclosingConstructor enclosing constructor}.
1062      *
1063      * &lt;p&gt; If this class represents an array type then this method returns the
1064      * package name of the element type. If this class represents a primitive
1065      * type or void then the package name &quot;{@code java.lang}&quot; is returned.
1066      *
1067      * @return the fully qualified package name
1068      *
1069      * @since 9
1070      * @spec JPMS
1071      * @jls 6.7 Fully Qualified Names
1072      */
1073     public String getPackageName() {
1074         String pn = this.packageName;
1075         if (pn == null) {
1076             Class&lt;?&gt; c = isArray() ? elementType() : this;
1077             if (c.isPrimitive()) {
1078                 pn = &quot;java.lang&quot;;
1079             } else {
1080                 String cn = c.getName();
1081                 int dot = cn.lastIndexOf(&#39;.&#39;);
1082                 pn = (dot != -1) ? cn.substring(0, dot).intern() : &quot;&quot;;
1083             }
1084             this.packageName = pn;
1085         }
1086         return pn;
1087     }
1088 
1089     // cached package name
1090     private transient String packageName;
1091 
1092     /**
1093      * Returns the interfaces directly implemented by the class or interface
1094      * represented by this {@code Class} object.
1095      *
1096      * &lt;p&gt;If this {@code Class} object represents a class, the return value is an array
1097      * containing objects representing all interfaces directly implemented by
1098      * the class.  The order of the interface objects in the array corresponds
1099      * to the order of the interface names in the {@code implements} clause of
1100      * the declaration of the class represented by this {@code Class} object.  For example,
1101      * given the declaration:
1102      * &lt;blockquote&gt;
1103      * {@code class Shimmer implements FloorWax, DessertTopping { ... }}
1104      * &lt;/blockquote&gt;
1105      * suppose the value of {@code s} is an instance of
1106      * {@code Shimmer}; the value of the expression:
1107      * &lt;blockquote&gt;
1108      * {@code s.getClass().getInterfaces()[0]}
1109      * &lt;/blockquote&gt;
1110      * is the {@code Class} object that represents interface
1111      * {@code FloorWax}; and the value of:
1112      * &lt;blockquote&gt;
1113      * {@code s.getClass().getInterfaces()[1]}
1114      * &lt;/blockquote&gt;
1115      * is the {@code Class} object that represents interface
1116      * {@code DessertTopping}.
1117      *
1118      * &lt;p&gt;If this {@code Class} object represents an interface, the array contains objects
1119      * representing all interfaces directly extended by the interface.  The
1120      * order of the interface objects in the array corresponds to the order of
1121      * the interface names in the {@code extends} clause of the declaration of
1122      * the interface represented by this {@code Class} object.
1123      *
1124      * &lt;p&gt;If this {@code Class} object represents a class or interface that implements no
1125      * interfaces, the method returns an array of length 0.
1126      *
1127      * &lt;p&gt;If this {@code Class} object represents a primitive type or void, the method
1128      * returns an array of length 0.
1129      *
1130      * &lt;p&gt;If this {@code Class} object represents an array type, the
1131      * interfaces {@code Cloneable} and {@code java.io.Serializable} are
1132      * returned in that order.
1133      *
1134      * @return an array of interfaces directly implemented by this class
1135      */
1136     public Class&lt;?&gt;[] getInterfaces() {
1137         // defensively copy before handing over to user code
1138         return getInterfaces(true);
1139     }
1140 
1141     private Class&lt;?&gt;[] getInterfaces(boolean cloneArray) {
1142         ReflectionData&lt;T&gt; rd = reflectionData();
1143         if (rd == null) {
1144             // no cloning required
1145             return getInterfaces0();
1146         } else {
1147             Class&lt;?&gt;[] interfaces = rd.interfaces;
1148             if (interfaces == null) {
1149                 interfaces = getInterfaces0();
1150                 rd.interfaces = interfaces;
1151             }
1152             // defensively copy if requested
1153             return cloneArray ? interfaces.clone() : interfaces;
1154         }
1155     }
1156 
1157     private native Class&lt;?&gt;[] getInterfaces0();
1158 
1159     /**
1160      * Returns the {@code Type}s representing the interfaces
1161      * directly implemented by the class or interface represented by
1162      * this {@code Class} object.
1163      *
1164      * &lt;p&gt;If a superinterface is a parameterized type, the
1165      * {@code Type} object returned for it must accurately reflect
1166      * the actual type arguments used in the source code. The
1167      * parameterized type representing each superinterface is created
1168      * if it had not been created before. See the declaration of
1169      * {@link java.lang.reflect.ParameterizedType ParameterizedType}
1170      * for the semantics of the creation process for parameterized
1171      * types.
1172      *
1173      * &lt;p&gt;If this {@code Class} object represents a class, the return value is an array
1174      * containing objects representing all interfaces directly implemented by
1175      * the class.  The order of the interface objects in the array corresponds
1176      * to the order of the interface names in the {@code implements} clause of
1177      * the declaration of the class represented by this {@code Class} object.
1178      *
1179      * &lt;p&gt;If this {@code Class} object represents an interface, the array contains objects
1180      * representing all interfaces directly extended by the interface.  The
1181      * order of the interface objects in the array corresponds to the order of
1182      * the interface names in the {@code extends} clause of the declaration of
1183      * the interface represented by this {@code Class} object.
1184      *
1185      * &lt;p&gt;If this {@code Class} object represents a class or interface that implements no
1186      * interfaces, the method returns an array of length 0.
1187      *
1188      * &lt;p&gt;If this {@code Class} object represents a primitive type or void, the method
1189      * returns an array of length 0.
1190      *
1191      * &lt;p&gt;If this {@code Class} object represents an array type, the
1192      * interfaces {@code Cloneable} and {@code java.io.Serializable} are
1193      * returned in that order.
1194      *
1195      * @throws java.lang.reflect.GenericSignatureFormatError
1196      *     if the generic class signature does not conform to the
1197      *     format specified in section {@jvms 4.7.9} of &lt;cite&gt;The
1198      *     Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;
1199      * @throws TypeNotPresentException if any of the generic
1200      *     superinterfaces refers to a non-existent type declaration
1201      * @throws java.lang.reflect.MalformedParameterizedTypeException
1202      *     if any of the generic superinterfaces refer to a parameterized
1203      *     type that cannot be instantiated for any reason
1204      * @return an array of interfaces directly implemented by this class
1205      * @since 1.5
1206      */
1207     public Type[] getGenericInterfaces() {
1208         ClassRepository info = getGenericInfo();
1209         return (info == null) ?  getInterfaces() : info.getSuperInterfaces();
1210     }
1211 
1212 
1213     /**
1214      * Returns the {@code Class} representing the component type of an
1215      * array.  If this class does not represent an array class this method
1216      * returns null.
1217      *
1218      * @return the {@code Class} representing the component type of this
1219      * class if this class is an array
1220      * @see     java.lang.reflect.Array
1221      * @since 1.1
1222      */
1223     public Class&lt;?&gt; getComponentType() {
1224         // Only return for array types. Storage may be reused for Class for instance types.
1225         if (isArray()) {
1226             return componentType;
1227         } else {
1228             return null;
1229         }
1230     }
1231 
1232     private final Class&lt;?&gt; componentType;
1233 
1234     /*
1235      * Returns the {@code Class} representing the element type of an array class.
1236      * If this class does not represent an array class, then this method returns
1237      * {@code null}.
1238      */
1239     private Class&lt;?&gt; elementType() {
1240         if (!isArray()) return null;
1241 
1242         Class&lt;?&gt; c = this;
1243         while (c.isArray()) {
1244             c = c.getComponentType();
1245         }
1246         return c;
1247     }
1248 
1249     /**
1250      * Returns the Java language modifiers for this class or interface, encoded
1251      * in an integer. The modifiers consist of the Java Virtual Machine&#39;s
1252      * constants for {@code public}, {@code protected},
1253      * {@code private}, {@code final}, {@code static},
1254      * {@code abstract} and {@code interface}; they should be decoded
1255      * using the methods of class {@code Modifier}.
1256      *
1257      * &lt;p&gt; If the underlying class is an array class, then its
1258      * {@code public}, {@code private} and {@code protected}
1259      * modifiers are the same as those of its component type.  If this
1260      * {@code Class} object represents a primitive type or void, its
1261      * {@code public} modifier is always {@code true}, and its
1262      * {@code protected} and {@code private} modifiers are always
1263      * {@code false}. If this {@code Class} object represents an array class, a
1264      * primitive type or void, then its {@code final} modifier is always
1265      * {@code true} and its interface modifier is always
1266      * {@code false}. The values of its other modifiers are not determined
1267      * by this specification.
1268      *
1269      * &lt;p&gt; The modifier encodings are defined in section {@jvms 4.1}
1270      * of &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;.
1271      *
1272      * @return the {@code int} representing the modifiers for this class
1273      * @see     java.lang.reflect.Modifier
1274      * @since 1.1
1275      */
1276     @HotSpotIntrinsicCandidate
1277     public native int getModifiers();
1278 
1279 
1280     /**
1281      * Gets the signers of this class.
1282      *
1283      * @return  the signers of this class, or null if there are no signers.  In
1284      *          particular, this method returns null if this {@code Class} object represents
1285      *          a primitive type or void.
1286      * @since   1.1
1287      */
1288     public native Object[] getSigners();
1289 
1290 
1291     /**
1292      * Set the signers of this class.
1293      */
1294     native void setSigners(Object[] signers);
1295 
1296 
1297     /**
1298      * If this {@code Class} object represents a local or anonymous
1299      * class within a method, returns a {@link
1300      * java.lang.reflect.Method Method} object representing the
1301      * immediately enclosing method of the underlying class. Returns
1302      * {@code null} otherwise.
1303      *
1304      * In particular, this method returns {@code null} if the underlying
1305      * class is a local or anonymous class immediately enclosed by a type
1306      * declaration, instance initializer or static initializer.
1307      *
1308      * @return the immediately enclosing method of the underlying class, if
1309      *     that class is a local or anonymous class; otherwise {@code null}.
1310      *
1311      * @throws SecurityException
1312      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
1313      *         following conditions is met:
1314      *
1315      *         &lt;ul&gt;
1316      *
1317      *         &lt;li&gt; the caller&#39;s class loader is not the same as the
1318      *         class loader of the enclosing class and invocation of
1319      *         {@link SecurityManager#checkPermission
1320      *         s.checkPermission} method with
1321      *         {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
1322      *         denies access to the methods within the enclosing class
1323      *
1324      *         &lt;li&gt; the caller&#39;s class loader is not the same as or an
1325      *         ancestor of the class loader for the enclosing class and
1326      *         invocation of {@link SecurityManager#checkPackageAccess
1327      *         s.checkPackageAccess()} denies access to the package
1328      *         of the enclosing class
1329      *
1330      *         &lt;/ul&gt;
1331      * @since 1.5
1332      */
1333     @CallerSensitive
1334     public Method getEnclosingMethod() throws SecurityException {
1335         EnclosingMethodInfo enclosingInfo = getEnclosingMethodInfo();
1336 
1337         if (enclosingInfo == null)
1338             return null;
1339         else {
1340             if (!enclosingInfo.isMethod())
1341                 return null;
1342 
1343             MethodRepository typeInfo = MethodRepository.make(enclosingInfo.getDescriptor(),
1344                                                               getFactory());
1345             Class&lt;?&gt;   returnType       = toClass(typeInfo.getReturnType());
1346             Type []    parameterTypes   = typeInfo.getParameterTypes();
1347             Class&lt;?&gt;[] parameterClasses = new Class&lt;?&gt;[parameterTypes.length];
1348 
1349             // Convert Types to Classes; returned types *should*
1350             // be class objects since the methodDescriptor&#39;s used
1351             // don&#39;t have generics information
1352             for(int i = 0; i &lt; parameterClasses.length; i++)
1353                 parameterClasses[i] = toClass(parameterTypes[i]);
1354 
1355             // Perform access check
1356             final Class&lt;?&gt; enclosingCandidate = enclosingInfo.getEnclosingClass();
1357             SecurityManager sm = System.getSecurityManager();
1358             if (sm != null) {
1359                 enclosingCandidate.checkMemberAccess(sm, Member.DECLARED,
1360                                                      Reflection.getCallerClass(), true);
1361             }
1362             Method[] candidates = enclosingCandidate.privateGetDeclaredMethods(false);
1363 
1364             /*
1365              * Loop over all declared methods; match method name,
1366              * number of and type of parameters, *and* return
1367              * type.  Matching return type is also necessary
1368              * because of covariant returns, etc.
1369              */
1370             ReflectionFactory fact = getReflectionFactory();
1371             for (Method m : candidates) {
1372                 if (m.getName().equals(enclosingInfo.getName()) &amp;&amp;
1373                     arrayContentsEq(parameterClasses,
1374                                     fact.getExecutableSharedParameterTypes(m))) {
1375                     // finally, check return type
1376                     if (m.getReturnType().equals(returnType)) {
1377                         return fact.copyMethod(m);
1378                     }
1379                 }
1380             }
1381 
1382             throw new InternalError(&quot;Enclosing method not found&quot;);
1383         }
1384     }
1385 
1386     private native Object[] getEnclosingMethod0();
1387 
1388     private EnclosingMethodInfo getEnclosingMethodInfo() {
1389         Object[] enclosingInfo = getEnclosingMethod0();
1390         if (enclosingInfo == null)
1391             return null;
1392         else {
1393             return new EnclosingMethodInfo(enclosingInfo);
1394         }
1395     }
1396 
1397     private static final class EnclosingMethodInfo {
1398         private final Class&lt;?&gt; enclosingClass;
1399         private final String name;
1400         private final String descriptor;
1401 
1402         static void validate(Object[] enclosingInfo) {
1403             if (enclosingInfo.length != 3)
1404                 throw new InternalError(&quot;Malformed enclosing method information&quot;);
1405             try {
1406                 // The array is expected to have three elements:
1407 
1408                 // the immediately enclosing class
1409                 Class&lt;?&gt; enclosingClass = (Class&lt;?&gt;)enclosingInfo[0];
1410                 assert(enclosingClass != null);
1411 
1412                 // the immediately enclosing method or constructor&#39;s
1413                 // name (can be null).
1414                 String name = (String)enclosingInfo[1];
1415 
1416                 // the immediately enclosing method or constructor&#39;s
1417                 // descriptor (null iff name is).
1418                 String descriptor = (String)enclosingInfo[2];
1419                 assert((name != null &amp;&amp; descriptor != null) || name == descriptor);
1420             } catch (ClassCastException cce) {
1421                 throw new InternalError(&quot;Invalid type in enclosing method information&quot;, cce);
1422             }
1423         }
1424 
1425         EnclosingMethodInfo(Object[] enclosingInfo) {
1426             validate(enclosingInfo);
1427             this.enclosingClass = (Class&lt;?&gt;)enclosingInfo[0];
1428             this.name = (String)enclosingInfo[1];
1429             this.descriptor = (String)enclosingInfo[2];
1430         }
1431 
1432         boolean isPartial() {
1433             return enclosingClass == null || name == null || descriptor == null;
1434         }
1435 
1436         boolean isConstructor() { return !isPartial() &amp;&amp; &quot;&lt;init&gt;&quot;.equals(name); }
1437 
1438         boolean isMethod() { return !isPartial() &amp;&amp; !isConstructor() &amp;&amp; !&quot;&lt;clinit&gt;&quot;.equals(name); }
1439 
1440         Class&lt;?&gt; getEnclosingClass() { return enclosingClass; }
1441 
1442         String getName() { return name; }
1443 
1444         String getDescriptor() { return descriptor; }
1445 
1446     }
1447 
1448     private static Class&lt;?&gt; toClass(Type o) {
1449         if (o instanceof GenericArrayType)
1450             return Array.newInstance(toClass(((GenericArrayType)o).getGenericComponentType()),
1451                                      0)
1452                 .getClass();
1453         return (Class&lt;?&gt;)o;
1454      }
1455 
1456     /**
1457      * If this {@code Class} object represents a local or anonymous
1458      * class within a constructor, returns a {@link
1459      * java.lang.reflect.Constructor Constructor} object representing
1460      * the immediately enclosing constructor of the underlying
1461      * class. Returns {@code null} otherwise.  In particular, this
1462      * method returns {@code null} if the underlying class is a local
1463      * or anonymous class immediately enclosed by a type declaration,
1464      * instance initializer or static initializer.
1465      *
1466      * @return the immediately enclosing constructor of the underlying class, if
1467      *     that class is a local or anonymous class; otherwise {@code null}.
1468      * @throws SecurityException
1469      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
1470      *         following conditions is met:
1471      *
1472      *         &lt;ul&gt;
1473      *
1474      *         &lt;li&gt; the caller&#39;s class loader is not the same as the
1475      *         class loader of the enclosing class and invocation of
1476      *         {@link SecurityManager#checkPermission
1477      *         s.checkPermission} method with
1478      *         {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
1479      *         denies access to the constructors within the enclosing class
1480      *
1481      *         &lt;li&gt; the caller&#39;s class loader is not the same as or an
1482      *         ancestor of the class loader for the enclosing class and
1483      *         invocation of {@link SecurityManager#checkPackageAccess
1484      *         s.checkPackageAccess()} denies access to the package
1485      *         of the enclosing class
1486      *
1487      *         &lt;/ul&gt;
1488      * @since 1.5
1489      */
1490     @CallerSensitive
1491     public Constructor&lt;?&gt; getEnclosingConstructor() throws SecurityException {
1492         EnclosingMethodInfo enclosingInfo = getEnclosingMethodInfo();
1493 
1494         if (enclosingInfo == null)
1495             return null;
1496         else {
1497             if (!enclosingInfo.isConstructor())
1498                 return null;
1499 
1500             ConstructorRepository typeInfo = ConstructorRepository.make(enclosingInfo.getDescriptor(),
1501                                                                         getFactory());
1502             Type []    parameterTypes   = typeInfo.getParameterTypes();
1503             Class&lt;?&gt;[] parameterClasses = new Class&lt;?&gt;[parameterTypes.length];
1504 
1505             // Convert Types to Classes; returned types *should*
1506             // be class objects since the methodDescriptor&#39;s used
1507             // don&#39;t have generics information
1508             for(int i = 0; i &lt; parameterClasses.length; i++)
1509                 parameterClasses[i] = toClass(parameterTypes[i]);
1510 
1511             // Perform access check
1512             final Class&lt;?&gt; enclosingCandidate = enclosingInfo.getEnclosingClass();
1513             SecurityManager sm = System.getSecurityManager();
1514             if (sm != null) {
1515                 enclosingCandidate.checkMemberAccess(sm, Member.DECLARED,
1516                                                      Reflection.getCallerClass(), true);
1517             }
1518 
1519             Constructor&lt;?&gt;[] candidates = enclosingCandidate
1520                     .privateGetDeclaredConstructors(false);
1521             /*
1522              * Loop over all declared constructors; match number
1523              * of and type of parameters.
1524              */
1525             ReflectionFactory fact = getReflectionFactory();
1526             for (Constructor&lt;?&gt; c : candidates) {
1527                 if (arrayContentsEq(parameterClasses,
1528                                     fact.getExecutableSharedParameterTypes(c))) {
1529                     return fact.copyConstructor(c);
1530                 }
1531             }
1532 
1533             throw new InternalError(&quot;Enclosing constructor not found&quot;);
1534         }
1535     }
1536 
1537 
1538     /**
1539      * If the class or interface represented by this {@code Class} object
1540      * is a member of another class, returns the {@code Class} object
1541      * representing the class in which it was declared.  This method returns
1542      * null if this class or interface is not a member of any other class.  If
1543      * this {@code Class} object represents an array class, a primitive
1544      * type, or void,then this method returns null.
1545      *
1546      * @return the declaring class for this class
1547      * @throws SecurityException
1548      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and the caller&#39;s
1549      *         class loader is not the same as or an ancestor of the class
1550      *         loader for the declaring class and invocation of {@link
1551      *         SecurityManager#checkPackageAccess s.checkPackageAccess()}
1552      *         denies access to the package of the declaring class
1553      * @since 1.1
1554      */
1555     @CallerSensitive
1556     public Class&lt;?&gt; getDeclaringClass() throws SecurityException {
1557         final Class&lt;?&gt; candidate = getDeclaringClass0();
1558 
1559         if (candidate != null) {
1560             SecurityManager sm = System.getSecurityManager();
1561             if (sm != null) {
1562                 candidate.checkPackageAccess(sm,
1563                     ClassLoader.getClassLoader(Reflection.getCallerClass()), true);
1564             }
1565         }
1566         return candidate;
1567     }
1568 
1569     private native Class&lt;?&gt; getDeclaringClass0();
1570 
1571 
1572     /**
1573      * Returns the immediately enclosing class of the underlying
1574      * class.  If the underlying class is a top level class this
1575      * method returns {@code null}.
1576      * @return the immediately enclosing class of the underlying class
1577      * @throws     SecurityException
1578      *             If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and the caller&#39;s
1579      *             class loader is not the same as or an ancestor of the class
1580      *             loader for the enclosing class and invocation of {@link
1581      *             SecurityManager#checkPackageAccess s.checkPackageAccess()}
1582      *             denies access to the package of the enclosing class
1583      * @since 1.5
1584      */
1585     @CallerSensitive
1586     public Class&lt;?&gt; getEnclosingClass() throws SecurityException {
1587         // There are five kinds of classes (or interfaces):
1588         // a) Top level classes
1589         // b) Nested classes (static member classes)
1590         // c) Inner classes (non-static member classes)
1591         // d) Local classes (named classes declared within a method)
1592         // e) Anonymous classes
1593 
1594 
1595         // JVM Spec 4.7.7: A class must have an EnclosingMethod
1596         // attribute if and only if it is a local class or an
1597         // anonymous class.
1598         EnclosingMethodInfo enclosingInfo = getEnclosingMethodInfo();
1599         Class&lt;?&gt; enclosingCandidate;
1600 
1601         if (enclosingInfo == null) {
1602             // This is a top level or a nested class or an inner class (a, b, or c)
1603             enclosingCandidate = getDeclaringClass0();
1604         } else {
1605             Class&lt;?&gt; enclosingClass = enclosingInfo.getEnclosingClass();
1606             // This is a local class or an anonymous class (d or e)
1607             if (enclosingClass == this || enclosingClass == null)
1608                 throw new InternalError(&quot;Malformed enclosing method information&quot;);
1609             else
1610                 enclosingCandidate = enclosingClass;
1611         }
1612 
1613         if (enclosingCandidate != null) {
1614             SecurityManager sm = System.getSecurityManager();
1615             if (sm != null) {
1616                 enclosingCandidate.checkPackageAccess(sm,
1617                     ClassLoader.getClassLoader(Reflection.getCallerClass()), true);
1618             }
1619         }
1620         return enclosingCandidate;
1621     }
1622 
1623     /**
1624      * Returns the simple name of the underlying class as given in the
1625      * source code. Returns an empty string if the underlying class is
1626      * anonymous.
1627      *
1628      * &lt;p&gt;The simple name of an array is the simple name of the
1629      * component type with &quot;[]&quot; appended.  In particular the simple
1630      * name of an array whose component type is anonymous is &quot;[]&quot;.
1631      *
1632      * @return the simple name of the underlying class
1633      * @since 1.5
1634      */
1635     public String getSimpleName() {
1636         ReflectionData&lt;T&gt; rd = reflectionData();
1637         String simpleName = rd.simpleName;
1638         if (simpleName == null) {
1639             rd.simpleName = simpleName = getSimpleName0();
1640         }
1641         return simpleName;
1642     }
1643 
1644     private String getSimpleName0() {
1645         if (isArray()) {
1646             return getComponentType().getSimpleName() + &quot;[]&quot;;
1647         }
1648         String simpleName = getSimpleBinaryName();
1649         if (simpleName == null) { // top level class
1650             simpleName = getName();
1651             simpleName = simpleName.substring(simpleName.lastIndexOf(&#39;.&#39;) + 1); // strip the package name
1652         }
1653         return simpleName;
1654     }
1655 
1656     /**
1657      * Return an informative string for the name of this type.
1658      *
1659      * @return an informative string for the name of this type
1660      * @since 1.8
1661      */
1662     public String getTypeName() {
1663         if (isArray()) {
1664             try {
1665                 Class&lt;?&gt; cl = this;
1666                 int dimensions = 0;
1667                 do {
1668                     dimensions++;
1669                     cl = cl.getComponentType();
1670                 } while (cl.isArray());
1671                 return cl.getName() + &quot;[]&quot;.repeat(dimensions);
1672             } catch (Throwable e) { /*FALLTHRU*/ }
1673         }
1674         return getName();
1675     }
1676 
1677     /**
1678      * Returns the canonical name of the underlying class as
1679      * defined by &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
1680      * Returns {@code null} if the underlying class does not have a canonical
1681      * name. Classes without canonical names include:
1682      * &lt;ul&gt;
1683      * &lt;li&gt;a {@linkplain #isLocalClass() local class}
1684      * &lt;li&gt;a {@linkplain #isAnonymousClass() anonymous class}
1685      * &lt;li&gt;a {@linkplain #isHidden() hidden class}
1686      * &lt;li&gt;an array whose component type does not have a canonical name&lt;/li&gt;
1687      * &lt;/ul&gt;
1688      *
1689      * @return the canonical name of the underlying class if it exists, and
1690      * {@code null} otherwise.
1691      * @since 1.5
1692      */
1693     public String getCanonicalName() {
1694         ReflectionData&lt;T&gt; rd = reflectionData();
1695         String canonicalName = rd.canonicalName;
1696         if (canonicalName == null) {
1697             rd.canonicalName = canonicalName = getCanonicalName0();
1698         }
1699         return canonicalName == ReflectionData.NULL_SENTINEL? null : canonicalName;
1700     }
1701 
1702     private String getCanonicalName0() {
1703         if (isArray()) {
1704             String canonicalName = getComponentType().getCanonicalName();
1705             if (canonicalName != null)
1706                 return canonicalName + &quot;[]&quot;;
1707             else
1708                 return ReflectionData.NULL_SENTINEL;
1709         }
1710         if (isHidden() || isLocalOrAnonymousClass())
1711             return ReflectionData.NULL_SENTINEL;
1712         Class&lt;?&gt; enclosingClass = getEnclosingClass();
1713         if (enclosingClass == null) { // top level class
1714             return getName();
1715         } else {
1716             String enclosingName = enclosingClass.getCanonicalName();
1717             if (enclosingName == null)
1718                 return ReflectionData.NULL_SENTINEL;
1719             return enclosingName + &quot;.&quot; + getSimpleName();
1720         }
1721     }
1722 
1723     /**
1724      * Returns {@code true} if and only if the underlying class
1725      * is an anonymous class.
1726      *
1727      * @apiNote
1728      * An anonymous class is not a {@linkplain #isHidden() hidden class}.
1729      *
1730      * @return {@code true} if and only if this class is an anonymous class.
1731      * @since 1.5
1732      */
1733     public boolean isAnonymousClass() {
1734         return !isArray() &amp;&amp; isLocalOrAnonymousClass() &amp;&amp;
1735                 getSimpleBinaryName0() == null;
1736     }
1737 
1738     /**
1739      * Returns {@code true} if and only if the underlying class
1740      * is a local class.
1741      *
1742      * @return {@code true} if and only if this class is a local class.
1743      * @since 1.5
1744      */
1745     public boolean isLocalClass() {
1746         return isLocalOrAnonymousClass() &amp;&amp;
1747                 (isArray() || getSimpleBinaryName0() != null);
1748     }
1749 
1750     /**
1751      * Returns {@code true} if and only if the underlying class
1752      * is a member class.
1753      *
1754      * @return {@code true} if and only if this class is a member class.
1755      * @since 1.5
1756      */
1757     public boolean isMemberClass() {
1758         return !isLocalOrAnonymousClass() &amp;&amp; getDeclaringClass0() != null;
1759     }
1760 
1761     /**
1762      * Returns the &quot;simple binary name&quot; of the underlying class, i.e.,
1763      * the binary name without the leading enclosing class name.
1764      * Returns {@code null} if the underlying class is a top level
1765      * class.
1766      */
1767     private String getSimpleBinaryName() {
1768         if (isTopLevelClass())
1769             return null;
1770         String name = getSimpleBinaryName0();
1771         if (name == null) // anonymous class
1772             return &quot;&quot;;
1773         return name;
1774     }
1775 
1776     private native String getSimpleBinaryName0();
1777 
1778     /**
1779      * Returns {@code true} if this is a top level class.  Returns {@code false}
1780      * otherwise.
1781      */
1782     private boolean isTopLevelClass() {
1783         return !isLocalOrAnonymousClass() &amp;&amp; getDeclaringClass0() == null;
1784     }
1785 
1786     /**
1787      * Returns {@code true} if this is a local class or an anonymous
1788      * class.  Returns {@code false} otherwise.
1789      */
1790     private boolean isLocalOrAnonymousClass() {
1791         // JVM Spec 4.7.7: A class must have an EnclosingMethod
1792         // attribute if and only if it is a local class or an
1793         // anonymous class.
1794         return hasEnclosingMethodInfo();
1795     }
1796 
1797     private boolean hasEnclosingMethodInfo() {
1798         Object[] enclosingInfo = getEnclosingMethod0();
1799         if (enclosingInfo != null) {
1800             EnclosingMethodInfo.validate(enclosingInfo);
1801             return true;
1802         }
1803         return false;
1804     }
1805 
1806     /**
1807      * Returns an array containing {@code Class} objects representing all
1808      * the public classes and interfaces that are members of the class
1809      * represented by this {@code Class} object.  This includes public
1810      * class and interface members inherited from superclasses and public class
1811      * and interface members declared by the class.  This method returns an
1812      * array of length 0 if this {@code Class} object has no public member
1813      * classes or interfaces.  This method also returns an array of length 0 if
1814      * this {@code Class} object represents a primitive type, an array
1815      * class, or void.
1816      *
1817      * @return the array of {@code Class} objects representing the public
1818      *         members of this class
1819      * @throws SecurityException
1820      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
1821      *         the caller&#39;s class loader is not the same as or an
1822      *         ancestor of the class loader for the current class and
1823      *         invocation of {@link SecurityManager#checkPackageAccess
1824      *         s.checkPackageAccess()} denies access to the package
1825      *         of this class.
1826      *
1827      * @since 1.1
1828      */
1829     @CallerSensitive
1830     public Class&lt;?&gt;[] getClasses() {
1831         SecurityManager sm = System.getSecurityManager();
1832         if (sm != null) {
1833             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), false);
1834         }
1835 
1836         // Privileged so this implementation can look at DECLARED classes,
1837         // something the caller might not have privilege to do.  The code here
1838         // is allowed to look at DECLARED classes because (1) it does not hand
1839         // out anything other than public members and (2) public member access
1840         // has already been ok&#39;d by the SecurityManager.
1841 
1842         return java.security.AccessController.doPrivileged(
1843             new java.security.PrivilegedAction&lt;&gt;() {
1844                 public Class&lt;?&gt;[] run() {
1845                     List&lt;Class&lt;?&gt;&gt; list = new ArrayList&lt;&gt;();
1846                     Class&lt;?&gt; currentClass = Class.this;
1847                     while (currentClass != null) {
1848                         for (Class&lt;?&gt; m : currentClass.getDeclaredClasses()) {
1849                             if (Modifier.isPublic(m.getModifiers())) {
1850                                 list.add(m);
1851                             }
1852                         }
1853                         currentClass = currentClass.getSuperclass();
1854                     }
1855                     return list.toArray(new Class&lt;?&gt;[0]);
1856                 }
1857             });
1858     }
1859 
1860 
1861     /**
1862      * Returns an array containing {@code Field} objects reflecting all
1863      * the accessible public fields of the class or interface represented by
1864      * this {@code Class} object.
1865      *
1866      * &lt;p&gt; If this {@code Class} object represents a class or interface with
1867      * no accessible public fields, then this method returns an array of length
1868      * 0.
1869      *
1870      * &lt;p&gt; If this {@code Class} object represents a class, then this method
1871      * returns the public fields of the class and of all its superclasses and
1872      * superinterfaces.
1873      *
1874      * &lt;p&gt; If this {@code Class} object represents an interface, then this
1875      * method returns the fields of the interface and of all its
1876      * superinterfaces.
1877      *
1878      * &lt;p&gt; If this {@code Class} object represents an array type, a primitive
1879      * type, or void, then this method returns an array of length 0.
1880      *
1881      * &lt;p&gt; The elements in the returned array are not sorted and are not in any
1882      * particular order.
1883      *
1884      * @return the array of {@code Field} objects representing the
1885      *         public fields
1886      * @throws SecurityException
1887      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
1888      *         the caller&#39;s class loader is not the same as or an
1889      *         ancestor of the class loader for the current class and
1890      *         invocation of {@link SecurityManager#checkPackageAccess
1891      *         s.checkPackageAccess()} denies access to the package
1892      *         of this class.
1893      *
1894      * @since 1.1
1895      * @jls 8.2 Class Members
1896      * @jls 8.3 Field Declarations
1897      */
1898     @CallerSensitive
1899     public Field[] getFields() throws SecurityException {
1900         SecurityManager sm = System.getSecurityManager();
1901         if (sm != null) {
1902             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
1903         }
1904         return copyFields(privateGetPublicFields());
1905     }
1906 
1907 
1908     /**
1909      * Returns an array containing {@code Method} objects reflecting all the
1910      * public methods of the class or interface represented by this {@code
1911      * Class} object, including those declared by the class or interface and
1912      * those inherited from superclasses and superinterfaces.
1913      *
1914      * &lt;p&gt; If this {@code Class} object represents an array type, then the
1915      * returned array has a {@code Method} object for each of the public
1916      * methods inherited by the array type from {@code Object}. It does not
1917      * contain a {@code Method} object for {@code clone()}.
1918      *
1919      * &lt;p&gt; If this {@code Class} object represents an interface then the
1920      * returned array does not contain any implicitly declared methods from
1921      * {@code Object}. Therefore, if no methods are explicitly declared in
1922      * this interface or any of its superinterfaces then the returned array
1923      * has length 0. (Note that a {@code Class} object which represents a class
1924      * always has public methods, inherited from {@code Object}.)
1925      *
1926      * &lt;p&gt; The returned array never contains methods with names &quot;{@code &lt;init&gt;}&quot;
1927      * or &quot;{@code &lt;clinit&gt;}&quot;.
1928      *
1929      * &lt;p&gt; The elements in the returned array are not sorted and are not in any
1930      * particular order.
1931      *
1932      * &lt;p&gt; Generally, the result is computed as with the following 4 step algorithm.
1933      * Let C be the class or interface represented by this {@code Class} object:
1934      * &lt;ol&gt;
1935      * &lt;li&gt; A union of methods is composed of:
1936      *   &lt;ol type=&quot;a&quot;&gt;
1937      *   &lt;li&gt; C&#39;s declared public instance and static methods as returned by
1938      *        {@link #getDeclaredMethods()} and filtered to include only public
1939      *        methods.&lt;/li&gt;
1940      *   &lt;li&gt; If C is a class other than {@code Object}, then include the result
1941      *        of invoking this algorithm recursively on the superclass of C.&lt;/li&gt;
1942      *   &lt;li&gt; Include the results of invoking this algorithm recursively on all
1943      *        direct superinterfaces of C, but include only instance methods.&lt;/li&gt;
1944      *   &lt;/ol&gt;&lt;/li&gt;
1945      * &lt;li&gt; Union from step 1 is partitioned into subsets of methods with same
1946      *      signature (name, parameter types) and return type.&lt;/li&gt;
1947      * &lt;li&gt; Within each such subset only the most specific methods are selected.
1948      *      Let method M be a method from a set of methods with same signature
1949      *      and return type. M is most specific if there is no such method
1950      *      N != M from the same set, such that N is more specific than M.
1951      *      N is more specific than M if:
1952      *   &lt;ol type=&quot;a&quot;&gt;
1953      *   &lt;li&gt; N is declared by a class and M is declared by an interface; or&lt;/li&gt;
1954      *   &lt;li&gt; N and M are both declared by classes or both by interfaces and
1955      *        N&#39;s declaring type is the same as or a subtype of M&#39;s declaring type
1956      *        (clearly, if M&#39;s and N&#39;s declaring types are the same type, then
1957      *        M and N are the same method).&lt;/li&gt;
1958      *   &lt;/ol&gt;&lt;/li&gt;
1959      * &lt;li&gt; The result of this algorithm is the union of all selected methods from
1960      *      step 3.&lt;/li&gt;
1961      * &lt;/ol&gt;
1962      *
1963      * @apiNote There may be more than one method with a particular name
1964      * and parameter types in a class because while the Java language forbids a
1965      * class to declare multiple methods with the same signature but different
1966      * return types, the Java virtual machine does not.  This
1967      * increased flexibility in the virtual machine can be used to
1968      * implement various language features.  For example, covariant
1969      * returns can be implemented with {@linkplain
1970      * java.lang.reflect.Method#isBridge bridge methods}; the bridge
1971      * method and the overriding method would have the same
1972      * signature but different return types.
1973      *
1974      * @return the array of {@code Method} objects representing the
1975      *         public methods of this class
1976      * @throws SecurityException
1977      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
1978      *         the caller&#39;s class loader is not the same as or an
1979      *         ancestor of the class loader for the current class and
1980      *         invocation of {@link SecurityManager#checkPackageAccess
1981      *         s.checkPackageAccess()} denies access to the package
1982      *         of this class.
1983      *
1984      * @jls 8.2 Class Members
1985      * @jls 8.4 Method Declarations
1986      * @since 1.1
1987      */
1988     @CallerSensitive
1989     public Method[] getMethods() throws SecurityException {
1990         SecurityManager sm = System.getSecurityManager();
1991         if (sm != null) {
1992             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
1993         }
1994         return copyMethods(privateGetPublicMethods());
1995     }
1996 
1997 
1998     /**
1999      * Returns an array containing {@code Constructor} objects reflecting
2000      * all the public constructors of the class represented by this
2001      * {@code Class} object.  An array of length 0 is returned if the
2002      * class has no public constructors, or if the class is an array class, or
2003      * if the class reflects a primitive type or void.
2004      *
2005      * @apiNote
2006      * While this method returns an array of {@code
2007      * Constructor&lt;T&gt;} objects (that is an array of constructors from
2008      * this class), the return type of this method is {@code
2009      * Constructor&lt;?&gt;[]} and &lt;em&gt;not&lt;/em&gt; {@code Constructor&lt;T&gt;[]} as
2010      * might be expected.  This less informative return type is
2011      * necessary since after being returned from this method, the
2012      * array could be modified to hold {@code Constructor} objects for
2013      * different classes, which would violate the type guarantees of
2014      * {@code Constructor&lt;T&gt;[]}.
2015      *
2016      * @return the array of {@code Constructor} objects representing the
2017      *         public constructors of this class
2018      * @throws SecurityException
2019      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
2020      *         the caller&#39;s class loader is not the same as or an
2021      *         ancestor of the class loader for the current class and
2022      *         invocation of {@link SecurityManager#checkPackageAccess
2023      *         s.checkPackageAccess()} denies access to the package
2024      *         of this class.
2025      *
2026      * @since 1.1
2027      */
2028     @CallerSensitive
2029     public Constructor&lt;?&gt;[] getConstructors() throws SecurityException {
2030         SecurityManager sm = System.getSecurityManager();
2031         if (sm != null) {
2032             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
2033         }
2034         return copyConstructors(privateGetDeclaredConstructors(true));
2035     }
2036 
2037 
2038     /**
2039      * Returns a {@code Field} object that reflects the specified public member
2040      * field of the class or interface represented by this {@code Class}
2041      * object. The {@code name} parameter is a {@code String} specifying the
2042      * simple name of the desired field.
2043      *
2044      * &lt;p&gt; The field to be reflected is determined by the algorithm that
2045      * follows.  Let C be the class or interface represented by this {@code Class} object:
2046      *
2047      * &lt;OL&gt;
2048      * &lt;LI&gt; If C declares a public field with the name specified, that is the
2049      *      field to be reflected.&lt;/LI&gt;
2050      * &lt;LI&gt; If no field was found in step 1 above, this algorithm is applied
2051      *      recursively to each direct superinterface of C. The direct
2052      *      superinterfaces are searched in the order they were declared.&lt;/LI&gt;
2053      * &lt;LI&gt; If no field was found in steps 1 and 2 above, and C has a
2054      *      superclass S, then this algorithm is invoked recursively upon S.
2055      *      If C has no superclass, then a {@code NoSuchFieldException}
2056      *      is thrown.&lt;/LI&gt;
2057      * &lt;/OL&gt;
2058      *
2059      * &lt;p&gt; If this {@code Class} object represents an array type, then this
2060      * method does not find the {@code length} field of the array type.
2061      *
2062      * @param name the field name
2063      * @return the {@code Field} object of this class specified by
2064      *         {@code name}
2065      * @throws NoSuchFieldException if a field with the specified name is
2066      *         not found.
2067      * @throws NullPointerException if {@code name} is {@code null}
2068      * @throws SecurityException
2069      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
2070      *         the caller&#39;s class loader is not the same as or an
2071      *         ancestor of the class loader for the current class and
2072      *         invocation of {@link SecurityManager#checkPackageAccess
2073      *         s.checkPackageAccess()} denies access to the package
2074      *         of this class.
2075      *
2076      * @since 1.1
2077      * @jls 8.2 Class Members
2078      * @jls 8.3 Field Declarations
2079      */
2080     @CallerSensitive
2081     public Field getField(String name)
2082         throws NoSuchFieldException, SecurityException {
2083         Objects.requireNonNull(name);
2084         SecurityManager sm = System.getSecurityManager();
2085         if (sm != null) {
2086             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
2087         }
2088         Field field = getField0(name);
2089         if (field == null) {
2090             throw new NoSuchFieldException(name);
2091         }
2092         return getReflectionFactory().copyField(field);
2093     }
2094 
2095 
2096     /**
2097      * Returns a {@code Method} object that reflects the specified public
2098      * member method of the class or interface represented by this
2099      * {@code Class} object. The {@code name} parameter is a
2100      * {@code String} specifying the simple name of the desired method. The
2101      * {@code parameterTypes} parameter is an array of {@code Class}
2102      * objects that identify the method&#39;s formal parameter types, in declared
2103      * order. If {@code parameterTypes} is {@code null}, it is
2104      * treated as if it were an empty array.
2105      *
2106      * &lt;p&gt; If this {@code Class} object represents an array type, then this
2107      * method finds any public method inherited by the array type from
2108      * {@code Object} except method {@code clone()}.
2109      *
2110      * &lt;p&gt; If this {@code Class} object represents an interface then this
2111      * method does not find any implicitly declared method from
2112      * {@code Object}. Therefore, if no methods are explicitly declared in
2113      * this interface or any of its superinterfaces, then this method does not
2114      * find any method.
2115      *
2116      * &lt;p&gt; This method does not find any method with name &quot;{@code &lt;init&gt;}&quot; or
2117      * &quot;{@code &lt;clinit&gt;}&quot;.
2118      *
2119      * &lt;p&gt; Generally, the method to be reflected is determined by the 4 step
2120      * algorithm that follows.
2121      * Let C be the class or interface represented by this {@code Class} object:
2122      * &lt;ol&gt;
2123      * &lt;li&gt; A union of methods is composed of:
2124      *   &lt;ol type=&quot;a&quot;&gt;
2125      *   &lt;li&gt; C&#39;s declared public instance and static methods as returned by
2126      *        {@link #getDeclaredMethods()} and filtered to include only public
2127      *        methods that match given {@code name} and {@code parameterTypes}&lt;/li&gt;
2128      *   &lt;li&gt; If C is a class other than {@code Object}, then include the result
2129      *        of invoking this algorithm recursively on the superclass of C.&lt;/li&gt;
2130      *   &lt;li&gt; Include the results of invoking this algorithm recursively on all
2131      *        direct superinterfaces of C, but include only instance methods.&lt;/li&gt;
2132      *   &lt;/ol&gt;&lt;/li&gt;
2133      * &lt;li&gt; This union is partitioned into subsets of methods with same
2134      *      return type (the selection of methods from step 1 also guarantees that
2135      *      they have the same method name and parameter types).&lt;/li&gt;
2136      * &lt;li&gt; Within each such subset only the most specific methods are selected.
2137      *      Let method M be a method from a set of methods with same VM
2138      *      signature (return type, name, parameter types).
2139      *      M is most specific if there is no such method N != M from the same
2140      *      set, such that N is more specific than M. N is more specific than M
2141      *      if:
2142      *   &lt;ol type=&quot;a&quot;&gt;
2143      *   &lt;li&gt; N is declared by a class and M is declared by an interface; or&lt;/li&gt;
2144      *   &lt;li&gt; N and M are both declared by classes or both by interfaces and
2145      *        N&#39;s declaring type is the same as or a subtype of M&#39;s declaring type
2146      *        (clearly, if M&#39;s and N&#39;s declaring types are the same type, then
2147      *        M and N are the same method).&lt;/li&gt;
2148      *   &lt;/ol&gt;&lt;/li&gt;
2149      * &lt;li&gt; The result of this algorithm is chosen arbitrarily from the methods
2150      *      with most specific return type among all selected methods from step 3.
2151      *      Let R be a return type of a method M from the set of all selected methods
2152      *      from step 3. M is a method with most specific return type if there is
2153      *      no such method N != M from the same set, having return type S != R,
2154      *      such that S is a subtype of R as determined by
2155      *      R.class.{@link #isAssignableFrom}(S.class).
2156      * &lt;/ol&gt;
2157      *
2158      * @apiNote There may be more than one method with matching name and
2159      * parameter types in a class because while the Java language forbids a
2160      * class to declare multiple methods with the same signature but different
2161      * return types, the Java virtual machine does not.  This
2162      * increased flexibility in the virtual machine can be used to
2163      * implement various language features.  For example, covariant
2164      * returns can be implemented with {@linkplain
2165      * java.lang.reflect.Method#isBridge bridge methods}; the bridge
2166      * method and the overriding method would have the same
2167      * signature but different return types. This method would return the
2168      * overriding method as it would have a more specific return type.
2169      *
2170      * @param name the name of the method
2171      * @param parameterTypes the list of parameters
2172      * @return the {@code Method} object that matches the specified
2173      *         {@code name} and {@code parameterTypes}
2174      * @throws NoSuchMethodException if a matching method is not found
2175      *         or if the name is &quot;&amp;lt;init&amp;gt;&quot;or &quot;&amp;lt;clinit&amp;gt;&quot;.
2176      * @throws NullPointerException if {@code name} is {@code null}
2177      * @throws SecurityException
2178      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
2179      *         the caller&#39;s class loader is not the same as or an
2180      *         ancestor of the class loader for the current class and
2181      *         invocation of {@link SecurityManager#checkPackageAccess
2182      *         s.checkPackageAccess()} denies access to the package
2183      *         of this class.
2184      *
2185      * @jls 8.2 Class Members
2186      * @jls 8.4 Method Declarations
2187      * @since 1.1
2188      */
2189     @CallerSensitive
2190     public Method getMethod(String name, Class&lt;?&gt;... parameterTypes)
2191         throws NoSuchMethodException, SecurityException {
2192         Objects.requireNonNull(name);
2193         SecurityManager sm = System.getSecurityManager();
2194         if (sm != null) {
2195             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
2196         }
2197         Method method = getMethod0(name, parameterTypes);
2198         if (method == null) {
2199             throw new NoSuchMethodException(methodToString(name, parameterTypes));
2200         }
2201         return getReflectionFactory().copyMethod(method);
2202     }
2203 
2204     /**
2205      * Returns a {@code Constructor} object that reflects the specified
2206      * public constructor of the class represented by this {@code Class}
2207      * object. The {@code parameterTypes} parameter is an array of
2208      * {@code Class} objects that identify the constructor&#39;s formal
2209      * parameter types, in declared order.
2210      *
2211      * If this {@code Class} object represents an inner class
2212      * declared in a non-static context, the formal parameter types
2213      * include the explicit enclosing instance as the first parameter.
2214      *
2215      * &lt;p&gt; The constructor to reflect is the public constructor of the class
2216      * represented by this {@code Class} object whose formal parameter
2217      * types match those specified by {@code parameterTypes}.
2218      *
2219      * @param parameterTypes the parameter array
2220      * @return the {@code Constructor} object of the public constructor that
2221      *         matches the specified {@code parameterTypes}
2222      * @throws NoSuchMethodException if a matching method is not found.
2223      * @throws SecurityException
2224      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
2225      *         the caller&#39;s class loader is not the same as or an
2226      *         ancestor of the class loader for the current class and
2227      *         invocation of {@link SecurityManager#checkPackageAccess
2228      *         s.checkPackageAccess()} denies access to the package
2229      *         of this class.
2230      *
2231      * @since 1.1
2232      */
2233     @CallerSensitive
2234     public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)
2235         throws NoSuchMethodException, SecurityException
2236     {
2237         SecurityManager sm = System.getSecurityManager();
2238         if (sm != null) {
2239             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
2240         }
2241         return getReflectionFactory().copyConstructor(
2242             getConstructor0(parameterTypes, Member.PUBLIC));
2243     }
2244 
2245 
2246     /**
2247      * Returns an array of {@code Class} objects reflecting all the
2248      * classes and interfaces declared as members of the class represented by
2249      * this {@code Class} object. This includes public, protected, default
2250      * (package) access, and private classes and interfaces declared by the
2251      * class, but excludes inherited classes and interfaces.  This method
2252      * returns an array of length 0 if the class declares no classes or
2253      * interfaces as members, or if this {@code Class} object represents a
2254      * primitive type, an array class, or void.
2255      *
2256      * @return the array of {@code Class} objects representing all the
2257      *         declared members of this class
2258      * @throws SecurityException
2259      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2260      *         following conditions is met:
2261      *
2262      *         &lt;ul&gt;
2263      *
2264      *         &lt;li&gt; the caller&#39;s class loader is not the same as the
2265      *         class loader of this class and invocation of
2266      *         {@link SecurityManager#checkPermission
2267      *         s.checkPermission} method with
2268      *         {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2269      *         denies access to the declared classes within this class
2270      *
2271      *         &lt;li&gt; the caller&#39;s class loader is not the same as or an
2272      *         ancestor of the class loader for the current class and
2273      *         invocation of {@link SecurityManager#checkPackageAccess
2274      *         s.checkPackageAccess()} denies access to the package
2275      *         of this class
2276      *
2277      *         &lt;/ul&gt;
2278      *
2279      * @since 1.1
2280      */
2281     @CallerSensitive
2282     public Class&lt;?&gt;[] getDeclaredClasses() throws SecurityException {
2283         SecurityManager sm = System.getSecurityManager();
2284         if (sm != null) {
2285             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), false);
2286         }
2287         return getDeclaredClasses0();
2288     }
2289 
2290 
2291     /**
2292      * Returns an array of {@code Field} objects reflecting all the fields
2293      * declared by the class or interface represented by this
2294      * {@code Class} object. This includes public, protected, default
2295      * (package) access, and private fields, but excludes inherited fields.
2296      *
2297      * &lt;p&gt; If this {@code Class} object represents a class or interface with no
2298      * declared fields, then this method returns an array of length 0.
2299      *
2300      * &lt;p&gt; If this {@code Class} object represents an array type, a primitive
2301      * type, or void, then this method returns an array of length 0.
2302      *
2303      * &lt;p&gt; The elements in the returned array are not sorted and are not in any
2304      * particular order.
2305      *
2306      * @return  the array of {@code Field} objects representing all the
2307      *          declared fields of this class
2308      * @throws  SecurityException
2309      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2310      *          following conditions is met:
2311      *
2312      *          &lt;ul&gt;
2313      *
2314      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2315      *          class loader of this class and invocation of
2316      *          {@link SecurityManager#checkPermission
2317      *          s.checkPermission} method with
2318      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2319      *          denies access to the declared fields within this class
2320      *
2321      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2322      *          ancestor of the class loader for the current class and
2323      *          invocation of {@link SecurityManager#checkPackageAccess
2324      *          s.checkPackageAccess()} denies access to the package
2325      *          of this class
2326      *
2327      *          &lt;/ul&gt;
2328      *
2329      * @since 1.1
2330      * @jls 8.2 Class Members
2331      * @jls 8.3 Field Declarations
2332      */
2333     @CallerSensitive
2334     public Field[] getDeclaredFields() throws SecurityException {
2335         SecurityManager sm = System.getSecurityManager();
2336         if (sm != null) {
2337             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2338         }
2339         return copyFields(privateGetDeclaredFields(false));
2340     }
2341 
2342     /**
2343      * {@preview Associated with records, a preview feature of the Java language.
2344      *
2345      *           This method is associated with &lt;i&gt;records&lt;/i&gt;, a preview
2346      *           feature of the Java language. Preview features
2347      *           may be removed in a future release, or upgraded to permanent
2348      *           features of the Java language.}
2349      *
2350      * Returns an array of {@code RecordComponent} objects representing all the
2351      * record components of this record class, or {@code null} if this class is
2352      * not a record class.
2353      *
2354      * &lt;p&gt; The components are returned in the same order that they are declared
2355      * in the record header. The array is empty if this record class has no
2356      * components. If the class is not a record class, that is {@link
2357      * #isRecord()} returns {@code false}, then this method returns {@code null}.
2358      * Conversely, if {@link #isRecord()} returns {@code true}, then this method
2359      * returns a non-null value.
2360      *
2361      * @return  An array of {@code RecordComponent} objects representing all the
2362      *          record components of this record class, or {@code null} if this
2363      *          class is not a record class
2364      * @throws  SecurityException
2365      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2366      *          following conditions is met:
2367      *
2368      *          &lt;ul&gt;
2369      *
2370      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2371      *          class loader of this class and invocation of
2372      *          {@link SecurityManager#checkPermission
2373      *          s.checkPermission} method with
2374      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2375      *          denies access to the declared methods within this class
2376      *
2377      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2378      *          ancestor of the class loader for the current class and
2379      *          invocation of {@link SecurityManager#checkPackageAccess
2380      *          s.checkPackageAccess()} denies access to the package
2381      *          of this class
2382      *
2383      *          &lt;/ul&gt;
2384      *
2385      * @jls 8.10 Record Types
2386      * @since 14
2387      */
2388     @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.RECORDS,
2389                                  essentialAPI=false)
2390     @SuppressWarnings(&quot;preview&quot;)
2391     @CallerSensitive
2392     public RecordComponent[] getRecordComponents() {
2393         SecurityManager sm = System.getSecurityManager();
2394         if (sm != null) {
2395             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2396         }
2397         if (!isRecord()) {
2398             return null;
2399         }
2400         RecordComponent[] recordComponents = getRecordComponents0();
2401         if (recordComponents == null) {
2402             return new RecordComponent[0];
2403         }
2404         return recordComponents;
2405     }
2406 
2407     /**
2408      * Returns an array containing {@code Method} objects reflecting all the
2409      * declared methods of the class or interface represented by this {@code
2410      * Class} object, including public, protected, default (package)
2411      * access, and private methods, but excluding inherited methods.
2412      *
2413      * &lt;p&gt; If this {@code Class} object represents a type that has multiple
2414      * declared methods with the same name and parameter types, but different
2415      * return types, then the returned array has a {@code Method} object for
2416      * each such method.
2417      *
2418      * &lt;p&gt; If this {@code Class} object represents a type that has a class
2419      * initialization method {@code &lt;clinit&gt;}, then the returned array does
2420      * &lt;em&gt;not&lt;/em&gt; have a corresponding {@code Method} object.
2421      *
2422      * &lt;p&gt; If this {@code Class} object represents a class or interface with no
2423      * declared methods, then the returned array has length 0.
2424      *
2425      * &lt;p&gt; If this {@code Class} object represents an array type, a primitive
2426      * type, or void, then the returned array has length 0.
2427      *
2428      * &lt;p&gt; The elements in the returned array are not sorted and are not in any
2429      * particular order.
2430      *
2431      * @return  the array of {@code Method} objects representing all the
2432      *          declared methods of this class
2433      * @throws  SecurityException
2434      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2435      *          following conditions is met:
2436      *
2437      *          &lt;ul&gt;
2438      *
2439      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2440      *          class loader of this class and invocation of
2441      *          {@link SecurityManager#checkPermission
2442      *          s.checkPermission} method with
2443      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2444      *          denies access to the declared methods within this class
2445      *
2446      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2447      *          ancestor of the class loader for the current class and
2448      *          invocation of {@link SecurityManager#checkPackageAccess
2449      *          s.checkPackageAccess()} denies access to the package
2450      *          of this class
2451      *
2452      *          &lt;/ul&gt;
2453      *
2454      * @jls 8.2 Class Members
2455      * @jls 8.4 Method Declarations
2456      * @since 1.1
2457      */
2458     @CallerSensitive
2459     public Method[] getDeclaredMethods() throws SecurityException {
2460         SecurityManager sm = System.getSecurityManager();
2461         if (sm != null) {
2462             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2463         }
2464         return copyMethods(privateGetDeclaredMethods(false));
2465     }
2466 
2467 
2468     /**
2469      * Returns an array of {@code Constructor} objects reflecting all the
2470      * constructors declared by the class represented by this
2471      * {@code Class} object. These are public, protected, default
2472      * (package) access, and private constructors.  The elements in the array
2473      * returned are not sorted and are not in any particular order.  If the
2474      * class has a default constructor, it is included in the returned array.
2475      * This method returns an array of length 0 if this {@code Class}
2476      * object represents an interface, a primitive type, an array class, or
2477      * void.
2478      *
2479      * &lt;p&gt; See &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;,
2480      * section {@jls 8.2}.
2481      *
2482      * @return  the array of {@code Constructor} objects representing all the
2483      *          declared constructors of this class
2484      * @throws  SecurityException
2485      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2486      *          following conditions is met:
2487      *
2488      *          &lt;ul&gt;
2489      *
2490      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2491      *          class loader of this class and invocation of
2492      *          {@link SecurityManager#checkPermission
2493      *          s.checkPermission} method with
2494      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2495      *          denies access to the declared constructors within this class
2496      *
2497      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2498      *          ancestor of the class loader for the current class and
2499      *          invocation of {@link SecurityManager#checkPackageAccess
2500      *          s.checkPackageAccess()} denies access to the package
2501      *          of this class
2502      *
2503      *          &lt;/ul&gt;
2504      *
2505      * @since 1.1
2506      */
2507     @CallerSensitive
2508     public Constructor&lt;?&gt;[] getDeclaredConstructors() throws SecurityException {
2509         SecurityManager sm = System.getSecurityManager();
2510         if (sm != null) {
2511             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2512         }
2513         return copyConstructors(privateGetDeclaredConstructors(false));
2514     }
2515 
2516 
2517     /**
2518      * Returns a {@code Field} object that reflects the specified declared
2519      * field of the class or interface represented by this {@code Class}
2520      * object. The {@code name} parameter is a {@code String} that specifies
2521      * the simple name of the desired field.
2522      *
2523      * &lt;p&gt; If this {@code Class} object represents an array type, then this
2524      * method does not find the {@code length} field of the array type.
2525      *
2526      * @param name the name of the field
2527      * @return  the {@code Field} object for the specified field in this
2528      *          class
2529      * @throws  NoSuchFieldException if a field with the specified name is
2530      *          not found.
2531      * @throws  NullPointerException if {@code name} is {@code null}
2532      * @throws  SecurityException
2533      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2534      *          following conditions is met:
2535      *
2536      *          &lt;ul&gt;
2537      *
2538      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2539      *          class loader of this class and invocation of
2540      *          {@link SecurityManager#checkPermission
2541      *          s.checkPermission} method with
2542      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2543      *          denies access to the declared field
2544      *
2545      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2546      *          ancestor of the class loader for the current class and
2547      *          invocation of {@link SecurityManager#checkPackageAccess
2548      *          s.checkPackageAccess()} denies access to the package
2549      *          of this class
2550      *
2551      *          &lt;/ul&gt;
2552      *
2553      * @since 1.1
2554      * @jls 8.2 Class Members
2555      * @jls 8.3 Field Declarations
2556      */
2557     @CallerSensitive
2558     public Field getDeclaredField(String name)
2559         throws NoSuchFieldException, SecurityException {
2560         Objects.requireNonNull(name);
2561         SecurityManager sm = System.getSecurityManager();
2562         if (sm != null) {
2563             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2564         }
2565         Field field = searchFields(privateGetDeclaredFields(false), name);
2566         if (field == null) {
2567             throw new NoSuchFieldException(name);
2568         }
2569         return getReflectionFactory().copyField(field);
2570     }
2571 
2572 
2573     /**
2574      * Returns a {@code Method} object that reflects the specified
2575      * declared method of the class or interface represented by this
2576      * {@code Class} object. The {@code name} parameter is a
2577      * {@code String} that specifies the simple name of the desired
2578      * method, and the {@code parameterTypes} parameter is an array of
2579      * {@code Class} objects that identify the method&#39;s formal parameter
2580      * types, in declared order.  If more than one method with the same
2581      * parameter types is declared in a class, and one of these methods has a
2582      * return type that is more specific than any of the others, that method is
2583      * returned; otherwise one of the methods is chosen arbitrarily.  If the
2584      * name is &quot;&amp;lt;init&amp;gt;&quot;or &quot;&amp;lt;clinit&amp;gt;&quot; a {@code NoSuchMethodException}
2585      * is raised.
2586      *
2587      * &lt;p&gt; If this {@code Class} object represents an array type, then this
2588      * method does not find the {@code clone()} method.
2589      *
2590      * @param name the name of the method
2591      * @param parameterTypes the parameter array
2592      * @return  the {@code Method} object for the method of this class
2593      *          matching the specified name and parameters
2594      * @throws  NoSuchMethodException if a matching method is not found.
2595      * @throws  NullPointerException if {@code name} is {@code null}
2596      * @throws  SecurityException
2597      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2598      *          following conditions is met:
2599      *
2600      *          &lt;ul&gt;
2601      *
2602      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2603      *          class loader of this class and invocation of
2604      *          {@link SecurityManager#checkPermission
2605      *          s.checkPermission} method with
2606      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2607      *          denies access to the declared method
2608      *
2609      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2610      *          ancestor of the class loader for the current class and
2611      *          invocation of {@link SecurityManager#checkPackageAccess
2612      *          s.checkPackageAccess()} denies access to the package
2613      *          of this class
2614      *
2615      *          &lt;/ul&gt;
2616      *
2617      * @jls 8.2 Class Members
2618      * @jls 8.4 Method Declarations
2619      * @since 1.1
2620      */
2621     @CallerSensitive
2622     public Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)
2623         throws NoSuchMethodException, SecurityException {
2624         Objects.requireNonNull(name);
2625         SecurityManager sm = System.getSecurityManager();
2626         if (sm != null) {
2627             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2628         }
2629         Method method = searchMethods(privateGetDeclaredMethods(false), name, parameterTypes);
2630         if (method == null) {
2631             throw new NoSuchMethodException(methodToString(name, parameterTypes));
2632         }
2633         return getReflectionFactory().copyMethod(method);
2634     }
2635 
2636     /**
2637      * Returns the list of {@code Method} objects for the declared public
2638      * methods of this class or interface that have the specified method name
2639      * and parameter types.
2640      *
2641      * @param name the name of the method
2642      * @param parameterTypes the parameter array
2643      * @return the list of {@code Method} objects for the public methods of
2644      *         this class matching the specified name and parameters
2645      */
2646     List&lt;Method&gt; getDeclaredPublicMethods(String name, Class&lt;?&gt;... parameterTypes) {
2647         Method[] methods = privateGetDeclaredMethods(/* publicOnly */ true);
2648         ReflectionFactory factory = getReflectionFactory();
2649         List&lt;Method&gt; result = new ArrayList&lt;&gt;();
2650         for (Method method : methods) {
2651             if (method.getName().equals(name)
2652                 &amp;&amp; Arrays.equals(
2653                     factory.getExecutableSharedParameterTypes(method),
2654                     parameterTypes)) {
2655                 result.add(factory.copyMethod(method));
2656             }
2657         }
2658         return result;
2659     }
2660 
2661     /**
2662      * Returns a {@code Constructor} object that reflects the specified
2663      * constructor of the class or interface represented by this
2664      * {@code Class} object.  The {@code parameterTypes} parameter is
2665      * an array of {@code Class} objects that identify the constructor&#39;s
2666      * formal parameter types, in declared order.
2667      *
2668      * If this {@code Class} object represents an inner class
2669      * declared in a non-static context, the formal parameter types
2670      * include the explicit enclosing instance as the first parameter.
2671      *
2672      * @param parameterTypes the parameter array
2673      * @return  The {@code Constructor} object for the constructor with the
2674      *          specified parameter list
2675      * @throws  NoSuchMethodException if a matching method is not found.
2676      * @throws  SecurityException
2677      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2678      *          following conditions is met:
2679      *
2680      *          &lt;ul&gt;
2681      *
2682      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2683      *          class loader of this class and invocation of
2684      *          {@link SecurityManager#checkPermission
2685      *          s.checkPermission} method with
2686      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2687      *          denies access to the declared constructor
2688      *
2689      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2690      *          ancestor of the class loader for the current class and
2691      *          invocation of {@link SecurityManager#checkPackageAccess
2692      *          s.checkPackageAccess()} denies access to the package
2693      *          of this class
2694      *
2695      *          &lt;/ul&gt;
2696      *
2697      * @since 1.1
2698      */
2699     @CallerSensitive
2700     public Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)
2701         throws NoSuchMethodException, SecurityException
2702     {
2703         SecurityManager sm = System.getSecurityManager();
2704         if (sm != null) {
2705             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2706         }
2707 
2708         return getReflectionFactory().copyConstructor(
2709             getConstructor0(parameterTypes, Member.DECLARED));
2710     }
2711 
2712     /**
2713      * Finds a resource with a given name.
2714      *
2715      * &lt;p&gt; If this class is in a named {@link Module Module} then this method
2716      * will attempt to find the resource in the module. This is done by
2717      * delegating to the module&#39;s class loader {@link
2718      * ClassLoader#findResource(String,String) findResource(String,String)}
2719      * method, invoking it with the module name and the absolute name of the
2720      * resource. Resources in named modules are subject to the rules for
2721      * encapsulation specified in the {@code Module} {@link
2722      * Module#getResourceAsStream getResourceAsStream} method and so this
2723      * method returns {@code null} when the resource is a
2724      * non-&quot;{@code .class}&quot; resource in a package that is not open to the
2725      * caller&#39;s module.
2726      *
2727      * &lt;p&gt; Otherwise, if this class is not in a named module then the rules for
2728      * searching resources associated with a given class are implemented by the
2729      * defining {@linkplain ClassLoader class loader} of the class.  This method
2730      * delegates to this {@code Class} object&#39;s class loader.
2731      * If this {@code Class} object was loaded by the bootstrap class loader,
2732      * the method delegates to {@link ClassLoader#getSystemResourceAsStream}.
2733      *
2734      * &lt;p&gt; Before delegation, an absolute resource name is constructed from the
2735      * given resource name using this algorithm:
2736      *
2737      * &lt;ul&gt;
2738      *
2739      * &lt;li&gt; If the {@code name} begins with a {@code &#39;/&#39;}
2740      * (&lt;code&gt;&#39;&amp;#92;u002f&#39;&lt;/code&gt;), then the absolute name of the resource is the
2741      * portion of the {@code name} following the {@code &#39;/&#39;}.
2742      *
2743      * &lt;li&gt; Otherwise, the absolute name is of the following form:
2744      *
2745      * &lt;blockquote&gt;
2746      *   {@code modified_package_name/name}
2747      * &lt;/blockquote&gt;
2748      *
2749      * &lt;p&gt; Where the {@code modified_package_name} is the package name of this
2750      * object with {@code &#39;/&#39;} substituted for {@code &#39;.&#39;}
2751      * (&lt;code&gt;&#39;&amp;#92;u002e&#39;&lt;/code&gt;).
2752      *
2753      * &lt;/ul&gt;
2754      *
2755      * @param  name name of the desired resource
2756      * @return  A {@link java.io.InputStream} object; {@code null} if no
2757      *          resource with this name is found, the resource is in a package
2758      *          that is not {@linkplain Module#isOpen(String, Module) open} to at
2759      *          least the caller module, or access to the resource is denied
2760      *          by the security manager.
2761      * @throws  NullPointerException If {@code name} is {@code null}
2762      *
2763      * @see Module#getResourceAsStream(String)
2764      * @since  1.1
2765      * @revised 9
2766      * @spec JPMS
2767      */
2768     @CallerSensitive
2769     public InputStream getResourceAsStream(String name) {
2770         name = resolveName(name);
2771 
2772         Module thisModule = getModule();
2773         if (thisModule.isNamed()) {
2774             // check if resource can be located by caller
2775             if (Resources.canEncapsulate(name)
2776                 &amp;&amp; !isOpenToCaller(name, Reflection.getCallerClass())) {
2777                 return null;
2778             }
2779 
2780             // resource not encapsulated or in package open to caller
2781             String mn = thisModule.getName();
2782             ClassLoader cl = getClassLoader0();
2783             try {
2784 
2785                 // special-case built-in class loaders to avoid the
2786                 // need for a URL connection
2787                 if (cl == null) {
2788                     return BootLoader.findResourceAsStream(mn, name);
2789                 } else if (cl instanceof BuiltinClassLoader) {
2790                     return ((BuiltinClassLoader) cl).findResourceAsStream(mn, name);
2791                 } else {
2792                     URL url = cl.findResource(mn, name);
2793                     return (url != null) ? url.openStream() : null;
2794                 }
2795 
2796             } catch (IOException | SecurityException e) {
2797                 return null;
2798             }
2799         }
2800 
2801         // unnamed module
2802         ClassLoader cl = getClassLoader0();
2803         if (cl == null) {
2804             return ClassLoader.getSystemResourceAsStream(name);
2805         } else {
2806             return cl.getResourceAsStream(name);
2807         }
2808     }
2809 
2810     /**
2811      * Finds a resource with a given name.
2812      *
2813      * &lt;p&gt; If this class is in a named {@link Module Module} then this method
2814      * will attempt to find the resource in the module. This is done by
2815      * delegating to the module&#39;s class loader {@link
2816      * ClassLoader#findResource(String,String) findResource(String,String)}
2817      * method, invoking it with the module name and the absolute name of the
2818      * resource. Resources in named modules are subject to the rules for
2819      * encapsulation specified in the {@code Module} {@link
2820      * Module#getResourceAsStream getResourceAsStream} method and so this
2821      * method returns {@code null} when the resource is a
2822      * non-&quot;{@code .class}&quot; resource in a package that is not open to the
2823      * caller&#39;s module.
2824      *
2825      * &lt;p&gt; Otherwise, if this class is not in a named module then the rules for
2826      * searching resources associated with a given class are implemented by the
2827      * defining {@linkplain ClassLoader class loader} of the class.  This method
2828      * delegates to this {@code Class} object&#39;s class loader.
2829      * If this {@code Class} object was loaded by the bootstrap class loader,
2830      * the method delegates to {@link ClassLoader#getSystemResource}.
2831      *
2832      * &lt;p&gt; Before delegation, an absolute resource name is constructed from the
2833      * given resource name using this algorithm:
2834      *
2835      * &lt;ul&gt;
2836      *
2837      * &lt;li&gt; If the {@code name} begins with a {@code &#39;/&#39;}
2838      * (&lt;code&gt;&#39;&amp;#92;u002f&#39;&lt;/code&gt;), then the absolute name of the resource is the
2839      * portion of the {@code name} following the {@code &#39;/&#39;}.
2840      *
2841      * &lt;li&gt; Otherwise, the absolute name is of the following form:
2842      *
2843      * &lt;blockquote&gt;
2844      *   {@code modified_package_name/name}
2845      * &lt;/blockquote&gt;
2846      *
2847      * &lt;p&gt; Where the {@code modified_package_name} is the package name of this
2848      * object with {@code &#39;/&#39;} substituted for {@code &#39;.&#39;}
2849      * (&lt;code&gt;&#39;&amp;#92;u002e&#39;&lt;/code&gt;).
2850      *
2851      * &lt;/ul&gt;
2852      *
2853      * @param  name name of the desired resource
2854      * @return A {@link java.net.URL} object; {@code null} if no resource with
2855      *         this name is found, the resource cannot be located by a URL, the
2856      *         resource is in a package that is not
2857      *         {@linkplain Module#isOpen(String, Module) open} to at least the caller
2858      *         module, or access to the resource is denied by the security
2859      *         manager.
2860      * @throws NullPointerException If {@code name} is {@code null}
2861      * @since  1.1
2862      * @revised 9
2863      * @spec JPMS
2864      */
2865     @CallerSensitive
2866     public URL getResource(String name) {
2867         name = resolveName(name);
2868 
2869         Module thisModule = getModule();
2870         if (thisModule.isNamed()) {
2871             // check if resource can be located by caller
2872             if (Resources.canEncapsulate(name)
2873                 &amp;&amp; !isOpenToCaller(name, Reflection.getCallerClass())) {
2874                 return null;
2875             }
2876 
2877             // resource not encapsulated or in package open to caller
2878             String mn = thisModule.getName();
2879             ClassLoader cl = getClassLoader0();
2880             try {
2881                 if (cl == null) {
2882                     return BootLoader.findResource(mn, name);
2883                 } else {
2884                     return cl.findResource(mn, name);
2885                 }
2886             } catch (IOException ioe) {
2887                 return null;
2888             }
2889         }
2890 
2891         // unnamed module
2892         ClassLoader cl = getClassLoader0();
2893         if (cl == null) {
2894             return ClassLoader.getSystemResource(name);
2895         } else {
2896             return cl.getResource(name);
2897         }
2898     }
2899 
2900     /**
2901      * Returns true if a resource with the given name can be located by the
2902      * given caller. All resources in a module can be located by code in
2903      * the module. For other callers, then the package needs to be open to
2904      * the caller.
2905      */
2906     private boolean isOpenToCaller(String name, Class&lt;?&gt; caller) {
2907         // assert getModule().isNamed();
2908         Module thisModule = getModule();
2909         Module callerModule = (caller != null) ? caller.getModule() : null;
2910         if (callerModule != thisModule) {
2911             String pn = Resources.toPackageName(name);
2912             if (thisModule.getDescriptor().packages().contains(pn)) {
2913                 if (callerModule == null &amp;&amp; !thisModule.isOpen(pn)) {
2914                     // no caller, package not open
2915                     return false;
2916                 }
2917                 if (!thisModule.isOpen(pn, callerModule)) {
2918                     // package not open to caller
2919                     return false;
2920                 }
2921             }
2922         }
2923         return true;
2924     }
2925 
2926 
2927     /** protection domain returned when the internal domain is null */
2928     private static java.security.ProtectionDomain allPermDomain;
2929 
2930     /**
2931      * Returns the {@code ProtectionDomain} of this class.  If there is a
2932      * security manager installed, this method first calls the security
2933      * manager&#39;s {@code checkPermission} method with a
2934      * {@code RuntimePermission(&quot;getProtectionDomain&quot;)} permission to
2935      * ensure it&#39;s ok to get the
2936      * {@code ProtectionDomain}.
2937      *
2938      * @return the ProtectionDomain of this class
2939      *
2940      * @throws SecurityException
2941      *        if a security manager exists and its
2942      *        {@code checkPermission} method doesn&#39;t allow
2943      *        getting the ProtectionDomain.
2944      *
2945      * @see java.security.ProtectionDomain
2946      * @see SecurityManager#checkPermission
2947      * @see java.lang.RuntimePermission
2948      * @since 1.2
2949      */
2950     public java.security.ProtectionDomain getProtectionDomain() {
2951         SecurityManager sm = System.getSecurityManager();
2952         if (sm != null) {
2953             sm.checkPermission(SecurityConstants.GET_PD_PERMISSION);
2954         }
2955         return protectionDomain();
2956     }
2957 
2958     // package-private
2959     java.security.ProtectionDomain protectionDomain() {
2960         java.security.ProtectionDomain pd = getProtectionDomain0();
2961         if (pd == null) {
2962             if (allPermDomain == null) {
2963                 java.security.Permissions perms =
2964                     new java.security.Permissions();
2965                 perms.add(SecurityConstants.ALL_PERMISSION);
2966                 allPermDomain =
2967                     new java.security.ProtectionDomain(null, perms);
2968             }
2969             pd = allPermDomain;
2970         }
2971         return pd;
2972     }
2973 
2974     /**
2975      * Returns the ProtectionDomain of this class.
2976      */
2977     private native java.security.ProtectionDomain getProtectionDomain0();
2978 
2979     /*
2980      * Return the Virtual Machine&#39;s Class object for the named
2981      * primitive type.
2982      */
2983     static native Class&lt;?&gt; getPrimitiveClass(String name);
2984 
2985     /*
2986      * Check if client is allowed to access members.  If access is denied,
2987      * throw a SecurityException.
2988      *
2989      * This method also enforces package access.
2990      *
2991      * &lt;p&gt; Default policy: allow all clients access with normal Java access
2992      * control.
2993      *
2994      * &lt;p&gt; NOTE: should only be called if a SecurityManager is installed
2995      */
2996     private void checkMemberAccess(SecurityManager sm, int which,
2997                                    Class&lt;?&gt; caller, boolean checkProxyInterfaces) {
2998         /* Default policy allows access to all {@link Member#PUBLIC} members,
2999          * as well as access to classes that have the same class loader as the caller.
3000          * In all other cases, it requires RuntimePermission(&quot;accessDeclaredMembers&quot;)
3001          * permission.
3002          */
3003         final ClassLoader ccl = ClassLoader.getClassLoader(caller);
3004         if (which != Member.PUBLIC) {
3005             final ClassLoader cl = getClassLoader0();
3006             if (ccl != cl) {
3007                 sm.checkPermission(SecurityConstants.CHECK_MEMBER_ACCESS_PERMISSION);
3008             }
3009         }
3010         this.checkPackageAccess(sm, ccl, checkProxyInterfaces);
3011     }
3012 
3013     /*
3014      * Checks if a client loaded in ClassLoader ccl is allowed to access this
3015      * class under the current package access policy. If access is denied,
3016      * throw a SecurityException.
3017      *
3018      * NOTE: this method should only be called if a SecurityManager is active
3019      */
3020     private void checkPackageAccess(SecurityManager sm, final ClassLoader ccl,
3021                                     boolean checkProxyInterfaces) {
3022         final ClassLoader cl = getClassLoader0();
3023 
3024         if (ReflectUtil.needsPackageAccessCheck(ccl, cl)) {
3025             String pkg = this.getPackageName();
3026             if (pkg != null &amp;&amp; !pkg.isEmpty()) {
3027                 // skip the package access check on a proxy class in default proxy package
3028                 if (!Proxy.isProxyClass(this) || ReflectUtil.isNonPublicProxyClass(this)) {
3029                     sm.checkPackageAccess(pkg);
3030                 }
3031             }
3032         }
3033         // check package access on the proxy interfaces
3034         if (checkProxyInterfaces &amp;&amp; Proxy.isProxyClass(this)) {
3035             ReflectUtil.checkProxyPackageAccess(ccl, this.getInterfaces());
3036         }
3037     }
3038 
3039     /**
3040      * Add a package name prefix if the name is not absolute Remove leading &quot;/&quot;
3041      * if name is absolute
3042      */
3043     private String resolveName(String name) {
3044         if (!name.startsWith(&quot;/&quot;)) {
3045             Class&lt;?&gt; c = isArray() ? elementType() : this;
3046             String baseName = c.getPackageName();
3047             if (baseName != null &amp;&amp; !baseName.isEmpty()) {
3048                 name = baseName.replace(&#39;.&#39;, &#39;/&#39;) + &quot;/&quot; + name;
3049             }
3050         } else {
3051             name = name.substring(1);
3052         }
3053         return name;
3054     }
3055 
3056     /**
3057      * Atomic operations support.
3058      */
3059     private static class Atomic {
3060         // initialize Unsafe machinery here, since we need to call Class.class instance method
3061         // and have to avoid calling it in the static initializer of the Class class...
3062         private static final Unsafe unsafe = Unsafe.getUnsafe();
3063         // offset of Class.reflectionData instance field
3064         private static final long reflectionDataOffset
3065                 = unsafe.objectFieldOffset(Class.class, &quot;reflectionData&quot;);
3066         // offset of Class.annotationType instance field
3067         private static final long annotationTypeOffset
3068                 = unsafe.objectFieldOffset(Class.class, &quot;annotationType&quot;);
3069         // offset of Class.annotationData instance field
3070         private static final long annotationDataOffset
3071                 = unsafe.objectFieldOffset(Class.class, &quot;annotationData&quot;);
3072 
3073         static &lt;T&gt; boolean casReflectionData(Class&lt;?&gt; clazz,
3074                                              SoftReference&lt;ReflectionData&lt;T&gt;&gt; oldData,
3075                                              SoftReference&lt;ReflectionData&lt;T&gt;&gt; newData) {
3076             return unsafe.compareAndSetReference(clazz, reflectionDataOffset, oldData, newData);
3077         }
3078 
3079         static &lt;T&gt; boolean casAnnotationType(Class&lt;?&gt; clazz,
3080                                              AnnotationType oldType,
3081                                              AnnotationType newType) {
3082             return unsafe.compareAndSetReference(clazz, annotationTypeOffset, oldType, newType);
3083         }
3084 
3085         static &lt;T&gt; boolean casAnnotationData(Class&lt;?&gt; clazz,
3086                                              AnnotationData oldData,
3087                                              AnnotationData newData) {
3088             return unsafe.compareAndSetReference(clazz, annotationDataOffset, oldData, newData);
3089         }
3090     }
3091 
3092     /**
3093      * Reflection support.
3094      */
3095 
3096     // Reflection data caches various derived names and reflective members. Cached
3097     // values may be invalidated when JVM TI RedefineClasses() is called
3098     private static class ReflectionData&lt;T&gt; {
3099         volatile Field[] declaredFields;
3100         volatile Field[] publicFields;
3101         volatile Method[] declaredMethods;
3102         volatile Method[] publicMethods;
3103         volatile Constructor&lt;T&gt;[] declaredConstructors;
3104         volatile Constructor&lt;T&gt;[] publicConstructors;
3105         // Intermediate results for getFields and getMethods
3106         volatile Field[] declaredPublicFields;
3107         volatile Method[] declaredPublicMethods;
3108         volatile Class&lt;?&gt;[] interfaces;
3109         volatile ClassDesc[] permittedSubclasses;
3110 
3111         // Cached names
3112         String simpleName;
3113         String canonicalName;
3114         static final String NULL_SENTINEL = new String();
3115 
3116         // Value of classRedefinedCount when we created this ReflectionData instance
3117         final int redefinedCount;
3118 
3119         ReflectionData(int redefinedCount) {
3120             this.redefinedCount = redefinedCount;
3121         }
3122     }
3123 
3124     private transient volatile SoftReference&lt;ReflectionData&lt;T&gt;&gt; reflectionData;
3125 
3126     // Incremented by the VM on each call to JVM TI RedefineClasses()
3127     // that redefines this class or a superclass.
3128     private transient volatile int classRedefinedCount;
3129 
3130     // Lazily create and cache ReflectionData
3131     private ReflectionData&lt;T&gt; reflectionData() {
3132         SoftReference&lt;ReflectionData&lt;T&gt;&gt; reflectionData = this.reflectionData;
3133         int classRedefinedCount = this.classRedefinedCount;
3134         ReflectionData&lt;T&gt; rd;
3135         if (reflectionData != null &amp;&amp;
3136             (rd = reflectionData.get()) != null &amp;&amp;
3137             rd.redefinedCount == classRedefinedCount) {
3138             return rd;
3139         }
3140         // else no SoftReference or cleared SoftReference or stale ReflectionData
3141         // -&gt; create and replace new instance
3142         return newReflectionData(reflectionData, classRedefinedCount);
3143     }
3144 
3145     private ReflectionData&lt;T&gt; newReflectionData(SoftReference&lt;ReflectionData&lt;T&gt;&gt; oldReflectionData,
3146                                                 int classRedefinedCount) {
3147         while (true) {
3148             ReflectionData&lt;T&gt; rd = new ReflectionData&lt;&gt;(classRedefinedCount);
3149             // try to CAS it...
3150             if (Atomic.casReflectionData(this, oldReflectionData, new SoftReference&lt;&gt;(rd))) {
3151                 return rd;
3152             }
3153             // else retry
3154             oldReflectionData = this.reflectionData;
3155             classRedefinedCount = this.classRedefinedCount;
3156             if (oldReflectionData != null &amp;&amp;
3157                 (rd = oldReflectionData.get()) != null &amp;&amp;
3158                 rd.redefinedCount == classRedefinedCount) {
3159                 return rd;
3160             }
3161         }
3162     }
3163 
3164     // Generic signature handling
3165     private native String getGenericSignature0();
3166 
3167     // Generic info repository; lazily initialized
3168     private transient volatile ClassRepository genericInfo;
3169 
3170     // accessor for factory
3171     private GenericsFactory getFactory() {
3172         // create scope and factory
3173         return CoreReflectionFactory.make(this, ClassScope.make(this));
3174     }
3175 
3176     // accessor for generic info repository;
3177     // generic info is lazily initialized
3178     private ClassRepository getGenericInfo() {
3179         ClassRepository genericInfo = this.genericInfo;
3180         if (genericInfo == null) {
3181             String signature = getGenericSignature0();
3182             if (signature == null) {
3183                 genericInfo = ClassRepository.NONE;
3184             } else {
3185                 genericInfo = ClassRepository.make(signature, getFactory());
3186             }
3187             this.genericInfo = genericInfo;
3188         }
3189         return (genericInfo != ClassRepository.NONE) ? genericInfo : null;
3190     }
3191 
3192     // Annotations handling
3193     native byte[] getRawAnnotations();
3194     // Since 1.8
3195     native byte[] getRawTypeAnnotations();
3196     static byte[] getExecutableTypeAnnotationBytes(Executable ex) {
3197         return getReflectionFactory().getExecutableTypeAnnotationBytes(ex);
3198     }
3199 
3200     native ConstantPool getConstantPool();
3201 
3202     //
3203     //
3204     // java.lang.reflect.Field handling
3205     //
3206     //
3207 
3208     // Returns an array of &quot;root&quot; fields. These Field objects must NOT
3209     // be propagated to the outside world, but must instead be copied
3210     // via ReflectionFactory.copyField.
3211     private Field[] privateGetDeclaredFields(boolean publicOnly) {
3212         Field[] res;
3213         ReflectionData&lt;T&gt; rd = reflectionData();
3214         if (rd != null) {
3215             res = publicOnly ? rd.declaredPublicFields : rd.declaredFields;
3216             if (res != null) return res;
3217         }
3218         // No cached value available; request value from VM
3219         res = Reflection.filterFields(this, getDeclaredFields0(publicOnly));
3220         if (rd != null) {
3221             if (publicOnly) {
3222                 rd.declaredPublicFields = res;
3223             } else {
3224                 rd.declaredFields = res;
3225             }
3226         }
3227         return res;
3228     }
3229 
3230     // Returns an array of &quot;root&quot; fields. These Field objects must NOT
3231     // be propagated to the outside world, but must instead be copied
3232     // via ReflectionFactory.copyField.
3233     private Field[] privateGetPublicFields() {
3234         Field[] res;
3235         ReflectionData&lt;T&gt; rd = reflectionData();
3236         if (rd != null) {
3237             res = rd.publicFields;
3238             if (res != null) return res;
3239         }
3240 
3241         // Use a linked hash set to ensure order is preserved and
3242         // fields from common super interfaces are not duplicated
3243         LinkedHashSet&lt;Field&gt; fields = new LinkedHashSet&lt;&gt;();
3244 
3245         // Local fields
3246         addAll(fields, privateGetDeclaredFields(true));
3247 
3248         // Direct superinterfaces, recursively
3249         for (Class&lt;?&gt; si : getInterfaces()) {
3250             addAll(fields, si.privateGetPublicFields());
3251         }
3252 
3253         // Direct superclass, recursively
3254         Class&lt;?&gt; sc = getSuperclass();
3255         if (sc != null) {
3256             addAll(fields, sc.privateGetPublicFields());
3257         }
3258 
3259         res = fields.toArray(new Field[0]);
3260         if (rd != null) {
3261             rd.publicFields = res;
3262         }
3263         return res;
3264     }
3265 
3266     private static void addAll(Collection&lt;Field&gt; c, Field[] o) {
3267         for (Field f : o) {
3268             c.add(f);
3269         }
3270     }
3271 
3272 
3273     //
3274     //
3275     // java.lang.reflect.Constructor handling
3276     //
3277     //
3278 
3279     // Returns an array of &quot;root&quot; constructors. These Constructor
3280     // objects must NOT be propagated to the outside world, but must
3281     // instead be copied via ReflectionFactory.copyConstructor.
3282     private Constructor&lt;T&gt;[] privateGetDeclaredConstructors(boolean publicOnly) {
3283         Constructor&lt;T&gt;[] res;
3284         ReflectionData&lt;T&gt; rd = reflectionData();
3285         if (rd != null) {
3286             res = publicOnly ? rd.publicConstructors : rd.declaredConstructors;
3287             if (res != null) return res;
3288         }
3289         // No cached value available; request value from VM
3290         if (isInterface()) {
3291             @SuppressWarnings(&quot;unchecked&quot;)
3292             Constructor&lt;T&gt;[] temporaryRes = (Constructor&lt;T&gt;[]) new Constructor&lt;?&gt;[0];
3293             res = temporaryRes;
3294         } else {
3295             res = getDeclaredConstructors0(publicOnly);
3296         }
3297         if (rd != null) {
3298             if (publicOnly) {
3299                 rd.publicConstructors = res;
3300             } else {
3301                 rd.declaredConstructors = res;
3302             }
3303         }
3304         return res;
3305     }
3306 
3307     //
3308     //
3309     // java.lang.reflect.Method handling
3310     //
3311     //
3312 
3313     // Returns an array of &quot;root&quot; methods. These Method objects must NOT
3314     // be propagated to the outside world, but must instead be copied
3315     // via ReflectionFactory.copyMethod.
3316     private Method[] privateGetDeclaredMethods(boolean publicOnly) {
3317         Method[] res;
3318         ReflectionData&lt;T&gt; rd = reflectionData();
3319         if (rd != null) {
3320             res = publicOnly ? rd.declaredPublicMethods : rd.declaredMethods;
3321             if (res != null) return res;
3322         }
3323         // No cached value available; request value from VM
3324         res = Reflection.filterMethods(this, getDeclaredMethods0(publicOnly));
3325         if (rd != null) {
3326             if (publicOnly) {
3327                 rd.declaredPublicMethods = res;
3328             } else {
3329                 rd.declaredMethods = res;
3330             }
3331         }
3332         return res;
3333     }
3334 
3335     // Returns an array of &quot;root&quot; methods. These Method objects must NOT
3336     // be propagated to the outside world, but must instead be copied
3337     // via ReflectionFactory.copyMethod.
3338     private Method[] privateGetPublicMethods() {
3339         Method[] res;
3340         ReflectionData&lt;T&gt; rd = reflectionData();
3341         if (rd != null) {
3342             res = rd.publicMethods;
3343             if (res != null) return res;
3344         }
3345 
3346         // No cached value available; compute value recursively.
3347         // Start by fetching public declared methods...
3348         PublicMethods pms = new PublicMethods();
3349         for (Method m : privateGetDeclaredMethods(/* publicOnly */ true)) {
3350             pms.merge(m);
3351         }
3352         // ...then recur over superclass methods...
3353         Class&lt;?&gt; sc = getSuperclass();
3354         if (sc != null) {
3355             for (Method m : sc.privateGetPublicMethods()) {
3356                 pms.merge(m);
3357             }
3358         }
3359         // ...and finally over direct superinterfaces.
3360         for (Class&lt;?&gt; intf : getInterfaces(/* cloneArray */ false)) {
3361             for (Method m : intf.privateGetPublicMethods()) {
3362                 // static interface methods are not inherited
3363                 if (!Modifier.isStatic(m.getModifiers())) {
3364                     pms.merge(m);
3365                 }
3366             }
3367         }
3368 
3369         res = pms.toArray();
3370         if (rd != null) {
3371             rd.publicMethods = res;
3372         }
3373         return res;
3374     }
3375 
3376 
3377     //
3378     // Helpers for fetchers of one field, method, or constructor
3379     //
3380 
3381     // This method does not copy the returned Field object!
3382     private static Field searchFields(Field[] fields, String name) {
3383         for (Field field : fields) {
3384             if (field.getName().equals(name)) {
3385                 return field;
3386             }
3387         }
3388         return null;
3389     }
3390 
3391     // Returns a &quot;root&quot; Field object. This Field object must NOT
3392     // be propagated to the outside world, but must instead be copied
3393     // via ReflectionFactory.copyField.
3394     private Field getField0(String name) {
3395         // Note: the intent is that the search algorithm this routine
3396         // uses be equivalent to the ordering imposed by
3397         // privateGetPublicFields(). It fetches only the declared
3398         // public fields for each class, however, to reduce the number
3399         // of Field objects which have to be created for the common
3400         // case where the field being requested is declared in the
3401         // class which is being queried.
3402         Field res;
3403         // Search declared public fields
3404         if ((res = searchFields(privateGetDeclaredFields(true), name)) != null) {
3405             return res;
3406         }
3407         // Direct superinterfaces, recursively
3408         Class&lt;?&gt;[] interfaces = getInterfaces(/* cloneArray */ false);
3409         for (Class&lt;?&gt; c : interfaces) {
3410             if ((res = c.getField0(name)) != null) {
3411                 return res;
3412             }
3413         }
3414         // Direct superclass, recursively
3415         if (!isInterface()) {
3416             Class&lt;?&gt; c = getSuperclass();
3417             if (c != null) {
3418                 if ((res = c.getField0(name)) != null) {
3419                     return res;
3420                 }
3421             }
3422         }
3423         return null;
3424     }
3425 
3426     // This method does not copy the returned Method object!
3427     private static Method searchMethods(Method[] methods,
3428                                         String name,
3429                                         Class&lt;?&gt;[] parameterTypes)
3430     {
3431         ReflectionFactory fact = getReflectionFactory();
3432         Method res = null;
3433         for (Method m : methods) {
3434             if (m.getName().equals(name)
3435                 &amp;&amp; arrayContentsEq(parameterTypes,
3436                                    fact.getExecutableSharedParameterTypes(m))
3437                 &amp;&amp; (res == null
3438                     || (res.getReturnType() != m.getReturnType()
3439                         &amp;&amp; res.getReturnType().isAssignableFrom(m.getReturnType()))))
3440                 res = m;
3441         }
3442         return res;
3443     }
3444 
3445     private static final Class&lt;?&gt;[] EMPTY_CLASS_ARRAY = new Class&lt;?&gt;[0];
3446 
3447     // Returns a &quot;root&quot; Method object. This Method object must NOT
3448     // be propagated to the outside world, but must instead be copied
3449     // via ReflectionFactory.copyMethod.
3450     private Method getMethod0(String name, Class&lt;?&gt;[] parameterTypes) {
3451         PublicMethods.MethodList res = getMethodsRecursive(
3452             name,
3453             parameterTypes == null ? EMPTY_CLASS_ARRAY : parameterTypes,
3454             /* includeStatic */ true);
3455         return res == null ? null : res.getMostSpecific();
3456     }
3457 
3458     // Returns a list of &quot;root&quot; Method objects. These Method objects must NOT
3459     // be propagated to the outside world, but must instead be copied
3460     // via ReflectionFactory.copyMethod.
3461     private PublicMethods.MethodList getMethodsRecursive(String name,
3462                                                          Class&lt;?&gt;[] parameterTypes,
3463                                                          boolean includeStatic) {
3464         // 1st check declared public methods
3465         Method[] methods = privateGetDeclaredMethods(/* publicOnly */ true);
3466         PublicMethods.MethodList res = PublicMethods.MethodList
3467             .filter(methods, name, parameterTypes, includeStatic);
3468         // if there is at least one match among declared methods, we need not
3469         // search any further as such match surely overrides matching methods
3470         // declared in superclass(es) or interface(s).
3471         if (res != null) {
3472             return res;
3473         }
3474 
3475         // if there was no match among declared methods,
3476         // we must consult the superclass (if any) recursively...
3477         Class&lt;?&gt; sc = getSuperclass();
3478         if (sc != null) {
3479             res = sc.getMethodsRecursive(name, parameterTypes, includeStatic);
3480         }
3481 
3482         // ...and coalesce the superclass methods with methods obtained
3483         // from directly implemented interfaces excluding static methods...
3484         for (Class&lt;?&gt; intf : getInterfaces(/* cloneArray */ false)) {
3485             res = PublicMethods.MethodList.merge(
3486                 res, intf.getMethodsRecursive(name, parameterTypes,
3487                                               /* includeStatic */ false));
3488         }
3489 
3490         return res;
3491     }
3492 
3493     // Returns a &quot;root&quot; Constructor object. This Constructor object must NOT
3494     // be propagated to the outside world, but must instead be copied
3495     // via ReflectionFactory.copyConstructor.
3496     private Constructor&lt;T&gt; getConstructor0(Class&lt;?&gt;[] parameterTypes,
3497                                         int which) throws NoSuchMethodException
3498     {
3499         ReflectionFactory fact = getReflectionFactory();
3500         Constructor&lt;T&gt;[] constructors = privateGetDeclaredConstructors((which == Member.PUBLIC));
3501         for (Constructor&lt;T&gt; constructor : constructors) {
3502             if (arrayContentsEq(parameterTypes,
3503                                 fact.getExecutableSharedParameterTypes(constructor))) {
3504                 return constructor;
3505             }
3506         }
3507         throw new NoSuchMethodException(methodToString(&quot;&lt;init&gt;&quot;, parameterTypes));
3508     }
3509 
3510     //
3511     // Other helpers and base implementation
3512     //
3513 
3514     private static boolean arrayContentsEq(Object[] a1, Object[] a2) {
3515         if (a1 == null) {
3516             return a2 == null || a2.length == 0;
3517         }
3518 
3519         if (a2 == null) {
3520             return a1.length == 0;
3521         }
3522 
3523         if (a1.length != a2.length) {
3524             return false;
3525         }
3526 
3527         for (int i = 0; i &lt; a1.length; i++) {
3528             if (a1[i] != a2[i]) {
3529                 return false;
3530             }
3531         }
3532 
3533         return true;
3534     }
3535 
3536     private static Field[] copyFields(Field[] arg) {
3537         Field[] out = new Field[arg.length];
3538         ReflectionFactory fact = getReflectionFactory();
3539         for (int i = 0; i &lt; arg.length; i++) {
3540             out[i] = fact.copyField(arg[i]);
3541         }
3542         return out;
3543     }
3544 
3545     private static Method[] copyMethods(Method[] arg) {
3546         Method[] out = new Method[arg.length];
3547         ReflectionFactory fact = getReflectionFactory();
3548         for (int i = 0; i &lt; arg.length; i++) {
3549             out[i] = fact.copyMethod(arg[i]);
3550         }
3551         return out;
3552     }
3553 
3554     private static &lt;U&gt; Constructor&lt;U&gt;[] copyConstructors(Constructor&lt;U&gt;[] arg) {
3555         Constructor&lt;U&gt;[] out = arg.clone();
3556         ReflectionFactory fact = getReflectionFactory();
3557         for (int i = 0; i &lt; out.length; i++) {
3558             out[i] = fact.copyConstructor(out[i]);
3559         }
3560         return out;
3561     }
3562 
3563     private native Field[]       getDeclaredFields0(boolean publicOnly);
3564     private native Method[]      getDeclaredMethods0(boolean publicOnly);
3565     private native Constructor&lt;T&gt;[] getDeclaredConstructors0(boolean publicOnly);
3566     private native Class&lt;?&gt;[]   getDeclaredClasses0();
3567     @SuppressWarnings(&quot;preview&quot;)
3568     private native RecordComponent[] getRecordComponents0();
3569     private native boolean      isRecord0();
3570 
3571     /**
3572      * Helper method to get the method name from arguments.
3573      */
3574     private String methodToString(String name, Class&lt;?&gt;[] argTypes) {
3575         return getName() + &#39;.&#39; + name +
3576                 ((argTypes == null || argTypes.length == 0) ?
3577                 &quot;()&quot; :
3578                 Arrays.stream(argTypes)
3579                         .map(c -&gt; c == null ? &quot;null&quot; : c.getName())
3580                         .collect(Collectors.joining(&quot;,&quot;, &quot;(&quot;, &quot;)&quot;)));
3581     }
3582 
3583     /** use serialVersionUID from JDK 1.1 for interoperability */
3584     @java.io.Serial
3585     private static final long serialVersionUID = 3206093459760846163L;
3586 
3587 
3588     /**
3589      * Class Class is special cased within the Serialization Stream Protocol.
3590      *
3591      * A Class instance is written initially into an ObjectOutputStream in the
3592      * following format:
3593      * &lt;pre&gt;
3594      *      {@code TC_CLASS} ClassDescriptor
3595      *      A ClassDescriptor is a special cased serialization of
3596      *      a {@code java.io.ObjectStreamClass} instance.
3597      * &lt;/pre&gt;
3598      * A new handle is generated for the initial time the class descriptor
3599      * is written into the stream. Future references to the class descriptor
3600      * are written as references to the initial class descriptor instance.
3601      *
3602      * @see java.io.ObjectStreamClass
3603      */
3604     @java.io.Serial
3605     private static final ObjectStreamField[] serialPersistentFields =
3606         new ObjectStreamField[0];
3607 
3608 
3609     /**
3610      * Returns the assertion status that would be assigned to this
3611      * class if it were to be initialized at the time this method is invoked.
3612      * If this class has had its assertion status set, the most recent
3613      * setting will be returned; otherwise, if any package default assertion
3614      * status pertains to this class, the most recent setting for the most
3615      * specific pertinent package default assertion status is returned;
3616      * otherwise, if this class is not a system class (i.e., it has a
3617      * class loader) its class loader&#39;s default assertion status is returned;
3618      * otherwise, the system class default assertion status is returned.
3619      *
3620      * @apiNote
3621      * Few programmers will have any need for this method; it is provided
3622      * for the benefit of the JDK itself.  (It allows a class to determine at
3623      * the time that it is initialized whether assertions should be enabled.)
3624      * Note that this method is not guaranteed to return the actual
3625      * assertion status that was (or will be) associated with the specified
3626      * class when it was (or will be) initialized.
3627      *
3628      * @return the desired assertion status of the specified class.
3629      * @see    java.lang.ClassLoader#setClassAssertionStatus
3630      * @see    java.lang.ClassLoader#setPackageAssertionStatus
3631      * @see    java.lang.ClassLoader#setDefaultAssertionStatus
3632      * @since  1.4
3633      */
3634     public boolean desiredAssertionStatus() {
3635         ClassLoader loader = getClassLoader0();
3636         // If the loader is null this is a system class, so ask the VM
3637         if (loader == null)
3638             return desiredAssertionStatus0(this);
3639 
3640         // If the classloader has been initialized with the assertion
3641         // directives, ask it. Otherwise, ask the VM.
3642         synchronized(loader.assertionLock) {
3643             if (loader.classAssertionStatus != null) {
3644                 return loader.desiredAssertionStatus(getName());
3645             }
3646         }
3647         return desiredAssertionStatus0(this);
3648     }
3649 
3650     // Retrieves the desired assertion status of this class from the VM
3651     private static native boolean desiredAssertionStatus0(Class&lt;?&gt; clazz);
3652 
3653     /**
3654      * Returns true if and only if this class was declared as an enum in the
3655      * source code.
3656      *
3657      * Note that {@link java.lang.Enum} is not itself an enum type.
3658      *
3659      * Also note that if an enum constant is declared with a class body,
3660      * the class of that enum constant object is an anonymous class
3661      * and &lt;em&gt;not&lt;/em&gt; the class of the declaring enum type. The
3662      * {@link Enum#getDeclaringClass} method of an enum constant can
3663      * be used to get the class of the enum type declaring the
3664      * constant.
3665      *
3666      * @return true if and only if this class was declared as an enum in the
3667      *     source code
3668      * @since 1.5
3669      * @jls 8.9.1 Enum Constants
3670      */
3671     public boolean isEnum() {
3672         // An enum must both directly extend java.lang.Enum and have
3673         // the ENUM bit set; classes for specialized enum constants
3674         // don&#39;t do the former.
3675         return (this.getModifiers() &amp; ENUM) != 0 &amp;&amp;
3676         this.getSuperclass() == java.lang.Enum.class;
3677     }
3678 
3679     /** java.lang.Record.class */
3680     private static final Class&lt;?&gt; JAVA_LANG_RECORD_CLASS = javaLangRecordClass();
3681     private static Class&lt;?&gt; javaLangRecordClass() {
3682         try {
3683             return Class.forName0(&quot;java.lang.Record&quot;, false, null, null);
3684         } catch (ClassNotFoundException e) {
3685             throw new InternalError(&quot;should not reach here&quot;, e);
3686         }
3687     }
3688 
3689     /**
3690      * {@preview Associated with records, a preview feature of the Java language.
3691      *
3692      *           This method is associated with &lt;i&gt;records&lt;/i&gt;, a preview
3693      *           feature of the Java language. Preview features
3694      *           may be removed in a future release, or upgraded to permanent
3695      *           features of the Java language.}
3696      *
3697      * Returns {@code true} if and only if this class is a record class.
3698      *
3699      * &lt;p&gt; The {@linkplain #getSuperclass() direct superclass} of a record
3700      * class is {@code java.lang.Record}. A record class has (possibly zero)
3701      * record components, that is, {@link #getRecordComponents()} returns a
3702      * non-null value.
3703      *
3704      * &lt;p&gt; Note that class {@link Record} is not a record type and thus invoking
3705      * this method on class {@code Record} returns {@code false}.
3706      *
3707      * @return true if and only if this class is a record class, otherwise false
3708      * @jls 8.10 Record Types
3709      * @since 14
3710      */
3711     @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.RECORDS,
3712                                  essentialAPI=false)
3713     public boolean isRecord() {
3714         return getSuperclass() == JAVA_LANG_RECORD_CLASS &amp;&amp; isRecord0();
3715     }
3716 
3717     // Fetches the factory for reflective objects
3718     private static ReflectionFactory getReflectionFactory() {
3719         if (reflectionFactory == null) {
3720             reflectionFactory =
3721                 java.security.AccessController.doPrivileged
3722                     (new ReflectionFactory.GetReflectionFactoryAction());
3723         }
3724         return reflectionFactory;
3725     }
3726     private static ReflectionFactory reflectionFactory;
3727 
3728     /**
3729      * Returns the elements of this enum class or null if this
3730      * Class object does not represent an enum type.
3731      *
3732      * @return an array containing the values comprising the enum class
3733      *     represented by this {@code Class} object in the order they&#39;re
3734      *     declared, or null if this {@code Class} object does not
3735      *     represent an enum type
3736      * @since 1.5
3737      */
3738     public T[] getEnumConstants() {
3739         T[] values = getEnumConstantsShared();
3740         return (values != null) ? values.clone() : null;
3741     }
3742 
3743     /**
3744      * Returns the elements of this enum class or null if this
3745      * Class object does not represent an enum type;
3746      * identical to getEnumConstants except that the result is
3747      * uncloned, cached, and shared by all callers.
3748      */
3749     T[] getEnumConstantsShared() {
3750         T[] constants = enumConstants;
3751         if (constants == null) {
3752             if (!isEnum()) return null;
3753             try {
3754                 final Method values = getMethod(&quot;values&quot;);
3755                 java.security.AccessController.doPrivileged(
3756                     new java.security.PrivilegedAction&lt;&gt;() {
3757                         public Void run() {
3758                                 values.setAccessible(true);
3759                                 return null;
3760                             }
3761                         });
3762                 @SuppressWarnings(&quot;unchecked&quot;)
3763                 T[] temporaryConstants = (T[])values.invoke(null);
3764                 enumConstants = constants = temporaryConstants;
3765             }
3766             // These can happen when users concoct enum-like classes
3767             // that don&#39;t comply with the enum spec.
3768             catch (InvocationTargetException | NoSuchMethodException |
3769                    IllegalAccessException ex) { return null; }
3770         }
3771         return constants;
3772     }
3773     private transient volatile T[] enumConstants;
3774 
3775     /**
3776      * Returns a map from simple name to enum constant.  This package-private
3777      * method is used internally by Enum to implement
3778      * {@code public static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt;, String)}
3779      * efficiently.  Note that the map is returned by this method is
3780      * created lazily on first use.  Typically it won&#39;t ever get created.
3781      */
3782     Map&lt;String, T&gt; enumConstantDirectory() {
3783         Map&lt;String, T&gt; directory = enumConstantDirectory;
3784         if (directory == null) {
3785             T[] universe = getEnumConstantsShared();
3786             if (universe == null)
3787                 throw new IllegalArgumentException(
3788                     getName() + &quot; is not an enum type&quot;);
3789             directory = new HashMap&lt;&gt;((int)(universe.length / 0.75f) + 1);
3790             for (T constant : universe) {
3791                 directory.put(((Enum&lt;?&gt;)constant).name(), constant);
3792             }
3793             enumConstantDirectory = directory;
3794         }
3795         return directory;
3796     }
3797     private transient volatile Map&lt;String, T&gt; enumConstantDirectory;
3798 
3799     /**
3800      * Casts an object to the class or interface represented
3801      * by this {@code Class} object.
3802      *
3803      * @param obj the object to be cast
3804      * @return the object after casting, or null if obj is null
3805      *
3806      * @throws ClassCastException if the object is not
3807      * null and is not assignable to the type T.
3808      *
3809      * @since 1.5
3810      */
3811     @SuppressWarnings(&quot;unchecked&quot;)
3812     @HotSpotIntrinsicCandidate
3813     public T cast(Object obj) {
3814         if (obj != null &amp;&amp; !isInstance(obj))
3815             throw new ClassCastException(cannotCastMsg(obj));
3816         return (T) obj;
3817     }
3818 
3819     private String cannotCastMsg(Object obj) {
3820         return &quot;Cannot cast &quot; + obj.getClass().getName() + &quot; to &quot; + getName();
3821     }
3822 
3823     /**
3824      * Casts this {@code Class} object to represent a subclass of the class
3825      * represented by the specified class object.  Checks that the cast
3826      * is valid, and throws a {@code ClassCastException} if it is not.  If
3827      * this method succeeds, it always returns a reference to this {@code Class} object.
3828      *
3829      * &lt;p&gt;This method is useful when a client needs to &quot;narrow&quot; the type of
3830      * a {@code Class} object to pass it to an API that restricts the
3831      * {@code Class} objects that it is willing to accept.  A cast would
3832      * generate a compile-time warning, as the correctness of the cast
3833      * could not be checked at runtime (because generic types are implemented
3834      * by erasure).
3835      *
3836      * @param &lt;U&gt; the type to cast this {@code Class} object to
3837      * @param clazz the class of the type to cast this {@code Class} object to
3838      * @return this {@code Class} object, cast to represent a subclass of
3839      *    the specified class object.
3840      * @throws ClassCastException if this {@code Class} object does not
3841      *    represent a subclass of the specified class (here &quot;subclass&quot; includes
3842      *    the class itself).
3843      * @since 1.5
3844      */
3845     @SuppressWarnings(&quot;unchecked&quot;)
3846     public &lt;U&gt; Class&lt;? extends U&gt; asSubclass(Class&lt;U&gt; clazz) {
3847         if (clazz.isAssignableFrom(this))
3848             return (Class&lt;? extends U&gt;) this;
3849         else
3850             throw new ClassCastException(this.toString());
3851     }
3852 
3853     /**
3854      * {@inheritDoc}
3855      * &lt;p&gt;Note that any annotation returned by this method is a
3856      * declaration annotation.
3857      *
3858      * @throws NullPointerException {@inheritDoc}
3859      * @since 1.5
3860      */
3861     @Override
3862     @SuppressWarnings(&quot;unchecked&quot;)
3863     public &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass) {
3864         Objects.requireNonNull(annotationClass);
3865 
3866         return (A) annotationData().annotations.get(annotationClass);
3867     }
3868 
3869     /**
3870      * {@inheritDoc}
3871      * @throws NullPointerException {@inheritDoc}
3872      * @since 1.5
3873      */
3874     @Override
3875     public boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) {
3876         return GenericDeclaration.super.isAnnotationPresent(annotationClass);
3877     }
3878 
3879     /**
3880      * {@inheritDoc}
3881      * &lt;p&gt;Note that any annotations returned by this method are
3882      * declaration annotations.
3883      *
3884      * @throws NullPointerException {@inheritDoc}
3885      * @since 1.8
3886      */
3887     @Override
3888     public &lt;A extends Annotation&gt; A[] getAnnotationsByType(Class&lt;A&gt; annotationClass) {
3889         Objects.requireNonNull(annotationClass);
3890 
3891         AnnotationData annotationData = annotationData();
3892         return AnnotationSupport.getAssociatedAnnotations(annotationData.declaredAnnotations,
3893                                                           this,
3894                                                           annotationClass);
3895     }
3896 
3897     /**
3898      * {@inheritDoc}
3899      * &lt;p&gt;Note that any annotations returned by this method are
3900      * declaration annotations.
3901      *
3902      * @since 1.5
3903      */
3904     @Override
3905     public Annotation[] getAnnotations() {
3906         return AnnotationParser.toArray(annotationData().annotations);
3907     }
3908 
3909     /**
3910      * {@inheritDoc}
3911      * &lt;p&gt;Note that any annotation returned by this method is a
3912      * declaration annotation.
3913      *
3914      * @throws NullPointerException {@inheritDoc}
3915      * @since 1.8
3916      */
3917     @Override
3918     @SuppressWarnings(&quot;unchecked&quot;)
3919     public &lt;A extends Annotation&gt; A getDeclaredAnnotation(Class&lt;A&gt; annotationClass) {
3920         Objects.requireNonNull(annotationClass);
3921 
3922         return (A) annotationData().declaredAnnotations.get(annotationClass);
3923     }
3924 
3925     /**
3926      * {@inheritDoc}
3927      * &lt;p&gt;Note that any annotations returned by this method are
3928      * declaration annotations.
3929      *
3930      * @throws NullPointerException {@inheritDoc}
3931      * @since 1.8
3932      */
3933     @Override
3934     public &lt;A extends Annotation&gt; A[] getDeclaredAnnotationsByType(Class&lt;A&gt; annotationClass) {
3935         Objects.requireNonNull(annotationClass);
3936 
3937         return AnnotationSupport.getDirectlyAndIndirectlyPresent(annotationData().declaredAnnotations,
3938                                                                  annotationClass);
3939     }
3940 
3941     /**
3942      * {@inheritDoc}
3943      * &lt;p&gt;Note that any annotations returned by this method are
3944      * declaration annotations.
3945      *
3946      * @since 1.5
3947      */
3948     @Override
3949     public Annotation[] getDeclaredAnnotations()  {
3950         return AnnotationParser.toArray(annotationData().declaredAnnotations);
3951     }
3952 
3953     // annotation data that might get invalidated when JVM TI RedefineClasses() is called
3954     private static class AnnotationData {
3955         final Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations;
3956         final Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations;
3957 
3958         // Value of classRedefinedCount when we created this AnnotationData instance
3959         final int redefinedCount;
3960 
3961         AnnotationData(Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations,
3962                        Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations,
3963                        int redefinedCount) {
3964             this.annotations = annotations;
3965             this.declaredAnnotations = declaredAnnotations;
3966             this.redefinedCount = redefinedCount;
3967         }
3968     }
3969 
3970     // Annotations cache
3971     @SuppressWarnings(&quot;UnusedDeclaration&quot;)
3972     private transient volatile AnnotationData annotationData;
3973 
3974     private AnnotationData annotationData() {
3975         while (true) { // retry loop
3976             AnnotationData annotationData = this.annotationData;
3977             int classRedefinedCount = this.classRedefinedCount;
3978             if (annotationData != null &amp;&amp;
3979                 annotationData.redefinedCount == classRedefinedCount) {
3980                 return annotationData;
3981             }
3982             // null or stale annotationData -&gt; optimistically create new instance
3983             AnnotationData newAnnotationData = createAnnotationData(classRedefinedCount);
3984             // try to install it
3985             if (Atomic.casAnnotationData(this, annotationData, newAnnotationData)) {
3986                 // successfully installed new AnnotationData
3987                 return newAnnotationData;
3988             }
3989         }
3990     }
3991 
3992     private AnnotationData createAnnotationData(int classRedefinedCount) {
3993         Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations =
3994             AnnotationParser.parseAnnotations(getRawAnnotations(), getConstantPool(), this);
3995         Class&lt;?&gt; superClass = getSuperclass();
3996         Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations = null;
3997         if (superClass != null) {
3998             Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; superAnnotations =
3999                 superClass.annotationData().annotations;
4000             for (Map.Entry&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; e : superAnnotations.entrySet()) {
4001                 Class&lt;? extends Annotation&gt; annotationClass = e.getKey();
4002                 if (AnnotationType.getInstance(annotationClass).isInherited()) {
4003                     if (annotations == null) { // lazy construction
4004                         annotations = new LinkedHashMap&lt;&gt;((Math.max(
4005                                 declaredAnnotations.size(),
4006                                 Math.min(12, declaredAnnotations.size() + superAnnotations.size())
4007                             ) * 4 + 2) / 3
4008                         );
4009                     }
4010                     annotations.put(annotationClass, e.getValue());
4011                 }
4012             }
4013         }
4014         if (annotations == null) {
4015             // no inherited annotations -&gt; share the Map with declaredAnnotations
4016             annotations = declaredAnnotations;
4017         } else {
4018             // at least one inherited annotation -&gt; declared may override inherited
4019             annotations.putAll(declaredAnnotations);
4020         }
4021         return new AnnotationData(annotations, declaredAnnotations, classRedefinedCount);
4022     }
4023 
4024     // Annotation types cache their internal (AnnotationType) form
4025 
4026     @SuppressWarnings(&quot;UnusedDeclaration&quot;)
4027     private transient volatile AnnotationType annotationType;
4028 
4029     boolean casAnnotationType(AnnotationType oldType, AnnotationType newType) {
4030         return Atomic.casAnnotationType(this, oldType, newType);
4031     }
4032 
4033     AnnotationType getAnnotationType() {
4034         return annotationType;
4035     }
4036 
4037     Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; getDeclaredAnnotationMap() {
4038         return annotationData().declaredAnnotations;
4039     }
4040 
4041     /* Backing store of user-defined values pertaining to this class.
4042      * Maintained by the ClassValue class.
4043      */
4044     transient ClassValue.ClassValueMap classValueMap;
4045 
4046     /**
4047      * Returns an {@code AnnotatedType} object that represents the use of a
4048      * type to specify the superclass of the entity represented by this {@code
4049      * Class} object. (The &lt;em&gt;use&lt;/em&gt; of type Foo to specify the superclass
4050      * in &#39;...  extends Foo&#39; is distinct from the &lt;em&gt;declaration&lt;/em&gt; of type
4051      * Foo.)
4052      *
4053      * &lt;p&gt; If this {@code Class} object represents a type whose declaration
4054      * does not explicitly indicate an annotated superclass, then the return
4055      * value is an {@code AnnotatedType} object representing an element with no
4056      * annotations.
4057      *
4058      * &lt;p&gt; If this {@code Class} represents either the {@code Object} class, an
4059      * interface type, an array type, a primitive type, or void, the return
4060      * value is {@code null}.
4061      *
4062      * @return an object representing the superclass
4063      * @since 1.8
4064      */
4065     public AnnotatedType getAnnotatedSuperclass() {
4066         if (this == Object.class ||
4067                 isInterface() ||
4068                 isArray() ||
4069                 isPrimitive() ||
4070                 this == Void.TYPE) {
4071             return null;
4072         }
4073 
4074         return TypeAnnotationParser.buildAnnotatedSuperclass(getRawTypeAnnotations(), getConstantPool(), this);
4075     }
4076 
4077     /**
4078      * Returns an array of {@code AnnotatedType} objects that represent the use
4079      * of types to specify superinterfaces of the entity represented by this
4080      * {@code Class} object. (The &lt;em&gt;use&lt;/em&gt; of type Foo to specify a
4081      * superinterface in &#39;... implements Foo&#39; is distinct from the
4082      * &lt;em&gt;declaration&lt;/em&gt; of type Foo.)
4083      *
4084      * &lt;p&gt; If this {@code Class} object represents a class, the return value is
4085      * an array containing objects representing the uses of interface types to
4086      * specify interfaces implemented by the class. The order of the objects in
4087      * the array corresponds to the order of the interface types used in the
4088      * &#39;implements&#39; clause of the declaration of this {@code Class} object.
4089      *
4090      * &lt;p&gt; If this {@code Class} object represents an interface, the return
4091      * value is an array containing objects representing the uses of interface
4092      * types to specify interfaces directly extended by the interface. The
4093      * order of the objects in the array corresponds to the order of the
4094      * interface types used in the &#39;extends&#39; clause of the declaration of this
4095      * {@code Class} object.
4096      *
4097      * &lt;p&gt; If this {@code Class} object represents a class or interface whose
4098      * declaration does not explicitly indicate any annotated superinterfaces,
4099      * the return value is an array of length 0.
4100      *
4101      * &lt;p&gt; If this {@code Class} object represents either the {@code Object}
4102      * class, an array type, a primitive type, or void, the return value is an
4103      * array of length 0.
4104      *
4105      * @return an array representing the superinterfaces
4106      * @since 1.8
4107      */
4108     public AnnotatedType[] getAnnotatedInterfaces() {
4109          return TypeAnnotationParser.buildAnnotatedInterfaces(getRawTypeAnnotations(), getConstantPool(), this);
4110     }
4111 
4112     private native Class&lt;?&gt; getNestHost0();
4113 
4114     /**
4115      * Returns the nest host of the &lt;a href=#nest&gt;nest&lt;/a&gt; to which the class
4116      * or interface represented by this {@code Class} object belongs.
4117      * Every class and interface belongs to exactly one nest.
4118      *
4119      * If the nest host of this class or interface has previously
4120      * been determined, then this method returns the nest host.
4121      * If the nest host of this class or interface has
4122      * not previously been determined, then this method determines the nest
4123      * host using the algorithm of JVMS 5.4.4, and returns it.
4124      *
4125      * Often, a class or interface belongs to a nest consisting only of itself,
4126      * in which case this method returns {@code this} to indicate that the class
4127      * or interface is the nest host.
4128      *
4129      * &lt;p&gt;If this {@code Class} object represents a primitive type, an array type,
4130      * or {@code void}, then this method returns {@code this},
4131      * indicating that the represented entity belongs to the nest consisting only of
4132      * itself, and is the nest host.
4133      *
4134      * @return the nest host of this class or interface
4135      *
4136      * @throws SecurityException
4137      *         If the returned class is not the current class, and
4138      *         if a security manager, &lt;i&gt;s&lt;/i&gt;, is present and the caller&#39;s
4139      *         class loader is not the same as or an ancestor of the class
4140      *         loader for the returned class and invocation of {@link
4141      *         SecurityManager#checkPackageAccess s.checkPackageAccess()}
4142      *         denies access to the package of the returned class
4143      * @since 11
4144      * @jvms 4.7.28 The {@code NestHost} Attribute
4145      * @jvms 4.7.29 The {@code NestMembers} Attribute
4146      * @jvms 5.4.4 Access Control
4147      */
4148     @CallerSensitive
4149     public Class&lt;?&gt; getNestHost() {
4150         if (isPrimitive() || isArray()) {
4151             return this;
4152         }
4153 
4154         Class&lt;?&gt; host = getNestHost0();
4155         if (host == this) {
4156             return this;
4157         }
4158         // returning a different class requires a security check
4159         SecurityManager sm = System.getSecurityManager();
4160         if (sm != null) {
4161             checkPackageAccess(sm,
4162                                ClassLoader.getClassLoader(Reflection.getCallerClass()), true);
4163         }
4164         return host;
4165     }
4166 
4167     /**
4168      * Determines if the given {@code Class} is a nestmate of the
4169      * class or interface represented by this {@code Class} object.
4170      * Two classes or interfaces are nestmates
4171      * if they have the same {@linkplain #getNestHost() nest host}.
4172      *
4173      * @param c the class to check
4174      * @return {@code true} if this class and {@code c} are members of
4175      * the same nest; and {@code false} otherwise.
4176      *
4177      * @since 11
4178      */
4179     public boolean isNestmateOf(Class&lt;?&gt; c) {
4180         if (this == c) {
4181             return true;
4182         }
4183         if (isPrimitive() || isArray() ||
4184             c.isPrimitive() || c.isArray()) {
4185             return false;
4186         }
4187 
4188         return getNestHost() == c.getNestHost();
4189     }
4190 
4191     private native Class&lt;?&gt;[] getNestMembers0();
4192 
4193     /**
4194      * Returns an array containing {@code Class} objects representing all the
4195      * classes and interfaces that are members of the nest to which the class
4196      * or interface represented by this {@code Class} object belongs.
4197      *
4198      * First, this method obtains the {@linkplain #getNestHost() nest host},
4199      * {@code H}, of the nest to which the class or interface represented by
4200      * this {@code Class} object belongs. The zeroth element of the returned
4201      * array is {@code H}.
4202      *
4203      * Then, for each class or interface {@code C} which is recorded by {@code H}
4204      * as being a member of its nest, this method attempts to obtain the {@code Class}
4205      * object for {@code C} (using {@linkplain #getClassLoader() the defining class
4206      * loader} of the current {@code Class} object), and then obtains the
4207      * {@linkplain #getNestHost() nest host} of the nest to which {@code C} belongs.
4208      * The classes and interfaces which are recorded by {@code H} as being members
4209      * of its nest, and for which {@code H} can be determined as their nest host,
4210      * are indicated by subsequent elements of the returned array. The order of
4211      * such elements is unspecified. Duplicates are permitted.
4212      *
4213      * &lt;p&gt;If this {@code Class} object represents a primitive type, an array type,
4214      * or {@code void}, then this method returns a single-element array containing
4215      * {@code this}.
4216      *
4217      * @apiNote
4218      * The returned array includes only the nest members recorded in the {@code NestMembers}
4219      * attribute, and not any hidden classes that were added to the nest via
4220      * {@link MethodHandles.Lookup#defineHiddenClass(byte[], boolean, MethodHandles.Lookup.ClassOption...)
4221      * Lookup::defineHiddenClass}.
4222      *
4223      * @return an array of all classes and interfaces in the same nest as
4224      * this class or interface
4225      *
4226      * @throws SecurityException
4227      * If any returned class is not the current class, and
4228      * if a security manager, &lt;i&gt;s&lt;/i&gt;, is present and the caller&#39;s
4229      * class loader is not the same as or an ancestor of the class
4230      * loader for that returned class and invocation of {@link
4231      * SecurityManager#checkPackageAccess s.checkPackageAccess()}
4232      * denies access to the package of that returned class
4233      *
4234      * @since 11
4235      * @see #getNestHost()
4236      * @jvms 4.7.28 The {@code NestHost} Attribute
4237      * @jvms 4.7.29 The {@code NestMembers} Attribute
4238      */
4239     @CallerSensitive
4240     public Class&lt;?&gt;[] getNestMembers() {
4241         if (isPrimitive() || isArray()) {
4242             return new Class&lt;?&gt;[] { this };
4243         }
4244         Class&lt;?&gt;[] members = getNestMembers0();
4245         // Can&#39;t actually enable this due to bootstrapping issues
4246         // assert(members.length != 1 || members[0] == this); // expected invariant from VM
4247 
4248         if (members.length &gt; 1) {
4249             // If we return anything other than the current class we need
4250             // a security check
4251             SecurityManager sm = System.getSecurityManager();
4252             if (sm != null) {
4253                 checkPackageAccess(sm,
4254                                    ClassLoader.getClassLoader(Reflection.getCallerClass()), true);
4255             }
4256         }
4257         return members;
4258     }
4259 
4260     /**
4261      * Returns the descriptor string of the entity (class, interface, array class,
4262      * primitive type, or {@code void}) represented by this {@code Class} object.
4263      *
4264      * &lt;p&gt; If this {@code Class} object represents a class or interface,
4265      * not an array class, then:
4266      * &lt;ul&gt;
4267      * &lt;li&gt; If the class or interface is not {@linkplain Class#isHidden() hidden},
4268      *      then the result is a field descriptor (JVMS {@jvms 4.3.2})
4269      *      for the class or interface. Calling
4270      *      {@link ClassDesc#ofDescriptor(String) ClassDesc::ofDescriptor}
4271      *      with the result descriptor string produces a {@link ClassDesc ClassDesc}
4272      *      describing this class or interface.
4273      * &lt;li&gt; If the class or interface is {@linkplain Class#isHidden() hidden},
4274      *      then the result is a string of the form:
4275      *      &lt;blockquote&gt;
4276      *      {@code &quot;L&quot; +} &lt;em&gt;N&lt;/em&gt; {@code + &quot;.&quot; + &lt;suffix&gt; + &quot;;&quot;}
4277      *      &lt;/blockquote&gt;
4278      *      where &lt;em&gt;N&lt;/em&gt; is the &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;binary name&lt;/a&gt;
4279      *      encoded in internal form indicated by the {@code class} file passed to
4280      *      {@link MethodHandles.Lookup#defineHiddenClass(byte[], boolean, MethodHandles.Lookup.ClassOption...)
4281      *      Lookup::defineHiddenClass}, and {@code &lt;suffix&gt;} is an unqualified name.
4282      *      A hidden class or interface has no {@linkplain ClassDesc nominal descriptor}.
4283      *      The result string is not a type descriptor.
4284      * &lt;/ul&gt;
4285      *
4286      * &lt;p&gt; If this {@code Class} object represents an array class, then
4287      * the result is a string consisting of one or more &#39;{@code [}&#39; characters
4288      * representing the depth of the array nesting, followed by the
4289      * descriptor string of the element type.
4290      * &lt;ul&gt;
4291      * &lt;li&gt; If the element type is not a {@linkplain Class#isHidden() hidden} class
4292      * or interface, then this array class can be described nominally.
4293      * Calling {@link ClassDesc#ofDescriptor(String) ClassDesc::ofDescriptor}
4294      * with the result descriptor string produces a {@link ClassDesc ClassDesc}
4295      * describing this array class.
4296      * &lt;li&gt; If the element type is a {@linkplain Class#isHidden() hidden} class or
4297      * interface, then this array class cannot be described nominally.
4298      * The result string is not a type descriptor.
4299      * &lt;/ul&gt;
4300      *
4301      * &lt;p&gt; If this {@code Class} object represents a primitive type or
4302      * {@code void}, then the result is a field descriptor string which
4303      * is a one-letter code corresponding to a primitive type or {@code void}
4304      * ({@code &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;F&quot;, &quot;I&quot;, &quot;J&quot;, &quot;S&quot;, &quot;Z&quot;, &quot;V&quot;}) (JVMS {@jvms 4.3.2}).
4305      *
4306      * @apiNote
4307      * This is not a strict inverse of {@link #forName};
4308      * distinct classes which share a common name but have different class loaders
4309      * will have identical descriptor strings.
4310      *
4311      * @return the descriptor string for this {@code Class} object
4312      * @jvms 4.3.2 Field Descriptors
4313      * @since 12
4314      */
4315     @Override
4316     public String descriptorString() {
4317         if (isPrimitive())
4318             return Wrapper.forPrimitiveType(this).basicTypeString();
4319 
4320         if (isArray()) {
4321             return &quot;[&quot; + componentType.descriptorString();
4322         } else if (isHidden()) {
4323             String name = getName();
4324             int index = name.indexOf(&#39;/&#39;);
4325             return &quot;L&quot; + name.substring(0, index).replace(&#39;.&#39;, &#39;/&#39;)
4326                        + &quot;.&quot; + name.substring(index+1) + &quot;;&quot;;
4327         } else {
4328             return &quot;L&quot; + getName().replace(&#39;.&#39;, &#39;/&#39;) + &quot;;&quot;;
4329         }
4330     }
4331 
4332     /**
4333      * Returns the component type of this {@code Class}, if it describes
4334      * an array type, or {@code null} otherwise.
4335      *
4336      * @implSpec
4337      * Equivalent to {@link Class#getComponentType()}.
4338      *
4339      * @return a {@code Class} describing the component type, or {@code null}
4340      * if this {@code Class} does not describe an array type
4341      * @since 12
4342      */
4343     @Override
4344     public Class&lt;?&gt; componentType() {
4345         return isArray() ? componentType : null;
4346     }
4347 
4348     /**
4349      * Returns a {@code Class} for an array type whose component type
4350      * is described by this {@linkplain Class}.
4351      *
4352      * @return a {@code Class} describing the array type
4353      * @since 12
4354      */
4355     @Override
4356     public Class&lt;?&gt; arrayType() {
4357         return Array.newInstance(this, 0).getClass();
4358     }
4359 
4360     /**
4361      * Returns a nominal descriptor for this instance, if one can be
4362      * constructed, or an empty {@link Optional} if one cannot be.
4363      *
4364      * @return An {@link Optional} containing the resulting nominal descriptor,
4365      * or an empty {@link Optional} if one cannot be constructed.
4366      * @since 12
4367      */
4368     @Override
4369     public Optional&lt;ClassDesc&gt; describeConstable() {
4370         Class&lt;?&gt; c = isArray() ? elementType() : this;
4371         return c.isHidden() ? Optional.empty()
4372                             : Optional.of(ClassDesc.ofDescriptor(descriptorString()));
4373    }
4374 
4375     /**
4376      * Returns {@code true} if and only if the underlying class is a hidden class.
4377      *
4378      * @return {@code true} if and only if this class is a hidden class.
4379      *
4380      * @since 15
4381      * @see MethodHandles.Lookup#defineHiddenClass
4382      */
4383     @HotSpotIntrinsicCandidate
4384     public native boolean isHidden();
4385 
4386     /**
4387      * {@preview Associated with sealed classes, a preview feature of the Java language.
4388      *
4389      *           This method is associated with &lt;i&gt;sealed classes&lt;/i&gt;, a preview
4390      *           feature of the Java language. Preview features
4391      *           may be removed in a future release, or upgraded to permanent
4392      *           features of the Java language.}
4393      *
4394      * Returns an array containing {@code ClassDesc} objects representing all the
4395      * permitted subclasses of this {@code Class} if it is sealed. Returns an empty array if this
4396      * {@code Class} is not sealed.
4397      *
4398      * @return an array of class descriptors of all the permitted subclasses of this class
4399      *
4400      * @jls 8.1 Class Declarations
4401      * @jls 9.1 Interface Declarations
4402      * @since 15
4403      */
4404     @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.SEALED_CLASSES, essentialAPI=false)
4405     public ClassDesc[] permittedSubclasses() {
4406         ReflectionData&lt;T&gt; rd = reflectionData();
4407         if (rd.permittedSubclasses != null) {
4408             return rd.permittedSubclasses;
4409         }
4410 
4411         if (isArray() || isPrimitive()) {
4412             rd.permittedSubclasses = new ClassDesc[0];
4413             return rd.permittedSubclasses;
4414         }
4415         String[] subclassNames = getPermittedSubclasses0();
4416         if (subclassNames.length == 0) {
4417             rd.permittedSubclasses = new ClassDesc[0];
4418             return rd.permittedSubclasses;
4419         }
4420         ClassDesc[] constants = new ClassDesc[subclassNames.length];
4421         int i = 0;
4422         for (String subclassName : subclassNames) {
4423             try {
4424                 constants[i++] = ClassDesc.of(subclassName.replace(&#39;/&#39;, &#39;.&#39;));
4425             } catch (IllegalArgumentException iae) {
4426                 throw new InternalError(&quot;Invalid type in permitted subclasses information: &quot; + subclassName, iae);
4427             }
4428         }
4429         rd.permittedSubclasses = constants;
4430         return constants;
4431     }
4432 
4433     /**
4434      * * {@preview Associated with sealed classes, a preview feature of the Java language.
4435      *
4436      *           This method is associated with &lt;i&gt;sealed classes&lt;/i&gt;, a preview
4437      *           feature of the Java language. Preview features
4438      *           may be removed in a future release, or upgraded to permanent
4439      *           features of the Java language.}
4440      *
4441      * Returns true if this {@linkplain Class} is sealed.
4442      *
4443      * @return returns true if this class is sealed
4444      *
4445      * @jls 8.1 Class Declarations
4446      * @jls 9.1 Interface Declarations
4447      * @since 15
4448      */
4449     @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.SEALED_CLASSES, essentialAPI=false)
4450     @SuppressWarnings(&quot;preview&quot;)
4451     public boolean isSealed() {
4452         return permittedSubclasses().length != 0;
4453     }
4454 
4455     private native String[] getPermittedSubclasses0();
4456 }
    </pre>
  </body>
</html>
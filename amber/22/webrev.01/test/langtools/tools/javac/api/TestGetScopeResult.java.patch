diff a/test/langtools/tools/javac/api/TestGetScopeResult.java b/test/langtools/tools/javac/api/TestGetScopeResult.java
--- a/test/langtools/tools/javac/api/TestGetScopeResult.java
+++ b/test/langtools/tools/javac/api/TestGetScopeResult.java
@@ -21,11 +21,11 @@
  * questions.
  */
 
 /*
  * @test
- * @bug 8205418 8207229 8207230 8230847
+ * @bug 8205418 8207229 8207230 8230847 8245786
  * @summary Test the outcomes from Trees.getScope
  * @modules jdk.compiler/com.sun.tools.javac.api
  *          jdk.compiler/com.sun.tools.javac.comp
  *          jdk.compiler/com.sun.tools.javac.tree
  *          jdk.compiler/com.sun.tools.javac.util
@@ -41,10 +41,11 @@
 import javax.tools.SimpleJavaFileObject;
 import javax.tools.StandardJavaFileManager;
 import javax.tools.ToolProvider;
 
 import com.sun.source.tree.BlockTree;
+import com.sun.source.tree.ClassTree;
 import com.sun.source.tree.CompilationUnitTree;
 import com.sun.source.tree.ConditionalExpressionTree;
 import com.sun.source.tree.IdentifierTree;
 import com.sun.source.tree.LambdaExpressionTree;
 import com.sun.source.tree.MethodInvocationTree;
@@ -76,10 +77,11 @@
         new TestGetScopeResult().testVariablesInSwitch();
         new TestGetScopeResult().testMemberRefs();
         new TestGetScopeResult().testAnnotations();
         new TestGetScopeResult().testAnnotationsLazy();
         new TestGetScopeResult().testCircular();
+        new TestGetScopeResult().testRecord();
     }
 
     public void run() throws IOException {
         String[] simpleLambda = {
             "s:java.lang.String",
@@ -177,16 +179,11 @@
 
             new TreePathScanner<Void, Void>() {
                 @Override
                 public Void visitLambdaExpression(LambdaExpressionTree node, Void p) {
                     Scope scope = Trees.instance(t).getScope(new TreePath(getCurrentPath(), node.getBody()));
-                    while (scope.getEnclosingClass() != null) {
-                        for (Element el : scope.getLocalElements()) {
-                            actual.add(el.getSimpleName() + ":" +el.asType().toString());
-                        }
-                        scope = scope.getEnclosingScope();
-                    }
+                    actual.addAll(dumpScope(scope));
                     return super.visitLambdaExpression(node, p);
                 }
             }.scan(cut, null);
 
             List<String> expectedList = List.of(expected);
@@ -491,6 +488,60 @@
                 }
             }.scan(cut, null);
         }
     }
 
+    void testRecord() throws IOException {
+        JavacTool c = JavacTool.create();
+        try (StandardJavaFileManager fm = c.getStandardFileManager(null, null, null)) {
+            class MyFileObject extends SimpleJavaFileObject {
+                MyFileObject() {
+                    super(URI.create("myfo:///Test.java"), SOURCE);
+                }
+                @Override
+                public String getCharContent(boolean ignoreEncodingErrors) {
+                    return "record Test<T>(int mark) {}";
+                }
+            }
+            Context ctx = new Context();
+            TestAnalyzer.preRegister(ctx);
+            List<String> options = List.of("--enable-preview",
+                                           "-source", System.getProperty("java.specification.version"));
+            JavacTask t = (JavacTask) c.getTask(null, fm, null, options, null,
+                                                List.of(new MyFileObject()), ctx);
+            CompilationUnitTree cut = t.parse().iterator().next();
+            t.analyze();
+
+            List<String> actual = new ArrayList<>();
+
+            new TreePathScanner<Void, Void>() {
+                @Override
+                public Void visitClass(ClassTree node, Void p) {
+                    Scope scope = Trees.instance(t).getScope(getCurrentPath());
+                    actual.addAll(dumpScope(scope));
+                    return super.visitClass(node, p);
+                }
+            }.scan(cut, null);
+
+            List<String> expected = List.of(
+                    "super:java.lang.Record",
+                    "this:Test<T>",
+                    "T:T"
+            );
+
+            if (!expected.equals(actual)) {
+                throw new AssertionError("Unexpected Scope content: " + actual);
+            }
+        }
+    }
+
+    private List<String> dumpScope(Scope scope) {
+        List<String> content = new ArrayList<>();
+        while (scope.getEnclosingClass() != null) {
+            for (Element el : scope.getLocalElements()) {
+                content.add(el.getSimpleName() + ":" +el.asType().toString());
+            }
+            scope = scope.getEnclosingScope();
+        }
+        return content;
+    }
 }

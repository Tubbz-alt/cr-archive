<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/foreign/TestMemoryAccess.java</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="TestLayouts.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="TestNative.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/foreign/TestMemoryAccess.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  6  *  under the terms of the GNU General Public License version 2 only, as
  7  *  published by the Free Software Foundation.
  8  *
  9  *  This code is distributed in the hope that it will be useful, but WITHOUT
 10  *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  *  version 2 for more details (a copy is included in the LICENSE file that
 13  *  accompanied this code).
 14  *
 15  *  You should have received a copy of the GNU General Public License version
 16  *  2 along with this work; if not, write to the Free Software Foundation,
 17  *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  *  or visit www.oracle.com if you need additional information or have any
 21  *  questions.
 22  */
 23 
 24 /*
 25  * @test
<span class="line-modified"> 26  * @run testng/othervm -Xverify:all TestMemoryAccess</span>



 27  */
 28 
 29 import jdk.incubator.foreign.GroupLayout;
 30 import jdk.incubator.foreign.MemoryLayouts;
 31 import jdk.incubator.foreign.MemoryLayout;
 32 import jdk.incubator.foreign.MemoryLayout.PathElement;
 33 import jdk.incubator.foreign.MemorySegment;
 34 import jdk.incubator.foreign.SequenceLayout;
 35 import jdk.incubator.foreign.ValueLayout;
 36 import jdk.incubator.foreign.MemoryAddress;
 37 import java.lang.invoke.VarHandle;
 38 import java.util.function.Function;
 39 
 40 import org.testng.annotations.*;
 41 import static org.testng.Assert.*;
 42 
 43 public class TestMemoryAccess {
 44 
 45     @Test(dataProvider = &quot;elements&quot;)
 46     public void testAccess(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, ValueLayout elemLayout, Class&lt;?&gt; carrier, Checker checker) {
</pre>
<hr />
<pre>
 64     public void testArrayAccess(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, MemoryLayout elemLayout, Class&lt;?&gt; carrier, ArrayChecker checker) {
 65         SequenceLayout seq = MemoryLayout.ofSequence(10, elemLayout.withName(&quot;elem&quot;));
 66         testArrayAccessInternal(viewFactory, seq, seq.varHandle(carrier, PathElement.sequenceElement()), checker);
 67     }
 68 
 69     @Test(dataProvider = &quot;arrayElements&quot;)
 70     public void testPaddedArrayAccessByName(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, MemoryLayout elemLayout, Class&lt;?&gt; carrier, ArrayChecker checker) {
 71         SequenceLayout seq = MemoryLayout.ofSequence(10, MemoryLayout.ofStruct(MemoryLayout.ofPaddingBits(elemLayout.bitSize()), elemLayout.withName(&quot;elem&quot;)));
 72         testArrayAccessInternal(viewFactory, seq, seq.varHandle(carrier, MemoryLayout.PathElement.sequenceElement(), MemoryLayout.PathElement.groupElement(&quot;elem&quot;)), checker);
 73     }
 74 
 75     @Test(dataProvider = &quot;arrayElements&quot;)
 76     public void testPaddedArrayAccessByIndexSeq(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, MemoryLayout elemLayout, Class&lt;?&gt; carrier, ArrayChecker checker) {
 77         SequenceLayout seq = MemoryLayout.ofSequence(10, MemoryLayout.ofSequence(2, elemLayout));
 78         testArrayAccessInternal(viewFactory, seq, seq.varHandle(carrier, PathElement.sequenceElement(), MemoryLayout.PathElement.sequenceElement(1)), checker);
 79     }
 80 
 81     private void testAccessInternal(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, MemoryLayout layout, VarHandle handle, Checker checker) {
 82         MemoryAddress outer_address;
 83         try (MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(layout))) {

 84             MemoryAddress addr = segment.baseAddress();
 85             try {
 86                 checker.check(handle, addr);
<span class="line-modified"> 87                 if (segment.isReadOnly()) {</span>
 88                     throw new AssertionError(); //not ok, memory should be immutable
 89                 }
 90             } catch (UnsupportedOperationException ex) {
<span class="line-modified"> 91                 if (!segment.isReadOnly()) {</span>
 92                     throw new AssertionError(); //we should not have failed!
 93                 }
 94                 return;
 95             }
 96             try {
 97                 checker.check(handle, addr.addOffset(layout.byteSize()));
 98                 throw new AssertionError(); //not ok, out of bounds
 99             } catch (IndexOutOfBoundsException ex) {
100                 //ok, should fail (out of bounds)
101             }
102             outer_address = addr; //leak!
103         }
104         try {
105             checker.check(handle, outer_address);
106             throw new AssertionError(); //not ok, scope is closed
107         } catch (IllegalStateException ex) {
108             //ok, should fail (scope is closed)
109         }
110     }
111 
112     private void testArrayAccessInternal(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, SequenceLayout seq, VarHandle handle, ArrayChecker checker) {
113         MemoryAddress outer_address;
114         try (MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(seq))) {

115             MemoryAddress addr = segment.baseAddress();
116             try {
117                 for (int i = 0; i &lt; seq.elementCount().getAsLong(); i++) {
118                     checker.check(handle, addr, i);
119                 }
<span class="line-modified">120                 if (segment.isReadOnly()) {</span>
121                     throw new AssertionError(); //not ok, memory should be immutable
122                 }
123             } catch (UnsupportedOperationException ex) {
<span class="line-modified">124                 if (!segment.isReadOnly()) {</span>
125                     throw new AssertionError(); //we should not have failed!
126                 }
127                 return;
128             }
129             try {
130                 checker.check(handle, addr, seq.elementCount().getAsLong());
131                 throw new AssertionError(); //not ok, out of bounds
132             } catch (IndexOutOfBoundsException ex) {
133                 //ok, should fail (out of bounds)
134             }
135             outer_address = addr; //leak!
136         }
137         try {
138             checker.check(handle, outer_address, 0);
139             throw new AssertionError(); //not ok, scope is closed
140         } catch (IllegalStateException ex) {
141             //ok, should fail (scope is closed)
142         }
143     }
144 
</pre>
<hr />
<pre>
163     @Test(dataProvider = &quot;matrixElements&quot;)
164     public void testPaddedMatrixAccessByIndexSeq(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, MemoryLayout elemLayout, Class&lt;?&gt; carrier, MatrixChecker checker) {
165         SequenceLayout seq = MemoryLayout.ofSequence(20,
166                 MemoryLayout.ofSequence(10, MemoryLayout.ofSequence(2, elemLayout)));
167         testMatrixAccessInternal(viewFactory, seq,
168                 seq.varHandle(carrier,
169                         PathElement.sequenceElement(), PathElement.sequenceElement(), PathElement.sequenceElement(1)),
170                 checker);
171     }
172 
173     @Test(dataProvider = &quot;badCarriers&quot;,
174           expectedExceptions = IllegalArgumentException.class)
175     public void testBadCarriers(Class&lt;?&gt; carrier) {
176         ValueLayout l = MemoryLayouts.BITS_32_LE.withName(&quot;elem&quot;);
177         l.varHandle(carrier);
178     }
179 
180     private void testMatrixAccessInternal(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, SequenceLayout seq, VarHandle handle, MatrixChecker checker) {
181         MemoryAddress outer_address;
182         try (MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(seq))) {

183             MemoryAddress addr = segment.baseAddress();
184             try {
185                 for (int i = 0; i &lt; seq.elementCount().getAsLong(); i++) {
186                     for (int j = 0; j &lt; ((SequenceLayout) seq.elementLayout()).elementCount().getAsLong(); j++) {
187                         checker.check(handle, addr, i, j);
188                     }
189                 }
<span class="line-modified">190                 if (segment.isReadOnly()) {</span>
191                     throw new AssertionError(); //not ok, memory should be immutable
192                 }
193             } catch (UnsupportedOperationException ex) {
<span class="line-modified">194                 if (!segment.isReadOnly()) {</span>
195                     throw new AssertionError(); //we should not have failed!
196                 }
197                 return;
198             }
199             try {
200                 checker.check(handle, addr, seq.elementCount().getAsLong(),
201                         ((SequenceLayout)seq.elementLayout()).elementCount().getAsLong());
202                 throw new AssertionError(); //not ok, out of bounds
203             } catch (IndexOutOfBoundsException ex) {
204                 //ok, should fail (out of bounds)
205             }
206             outer_address = addr; //leak!
207         }
208         try {
209             checker.check(handle, outer_address, 0, 0);
210             throw new AssertionError(); //not ok, scope is closed
211         } catch (IllegalStateException ex) {
212             //ok, should fail (scope is closed)
213         }
214     }
215 
216     static Function&lt;MemorySegment, MemorySegment&gt; ID = Function.identity();
<span class="line-modified">217     static Function&lt;MemorySegment, MemorySegment&gt; IMMUTABLE = MemorySegment::asReadOnly;</span>
218 
219     @DataProvider(name = &quot;elements&quot;)
220     public Object[][] createData() {
221         return new Object[][] {
222                 //BE, RW
223                 { ID, MemoryLayouts.BITS_8_BE, byte.class, Checker.BYTE },
224                 { ID, MemoryLayouts.BITS_16_BE, short.class, Checker.SHORT },
225                 { ID, MemoryLayouts.BITS_16_BE, char.class, Checker.CHAR },
226                 { ID, MemoryLayouts.BITS_32_BE, int.class, Checker.INT },
227                 { ID, MemoryLayouts.BITS_64_BE, long.class, Checker.LONG },
228                 { ID, MemoryLayouts.BITS_32_BE, float.class, Checker.FLOAT },
229                 { ID, MemoryLayouts.BITS_64_BE, double.class, Checker.DOUBLE },
230                 //BE, RO
231                 { IMMUTABLE, MemoryLayouts.BITS_8_BE, byte.class, Checker.BYTE },
232                 { IMMUTABLE, MemoryLayouts.BITS_16_BE, short.class, Checker.SHORT },
233                 { IMMUTABLE, MemoryLayouts.BITS_16_BE, char.class, Checker.CHAR },
234                 { IMMUTABLE, MemoryLayouts.BITS_32_BE, int.class, Checker.INT },
235                 { IMMUTABLE, MemoryLayouts.BITS_64_BE, long.class, Checker.LONG },
236                 { IMMUTABLE, MemoryLayouts.BITS_32_BE, float.class, Checker.FLOAT },
237                 { IMMUTABLE, MemoryLayouts.BITS_64_BE, double.class, Checker.DOUBLE },
</pre>
</td>
<td>
<hr />
<pre>
  6  *  under the terms of the GNU General Public License version 2 only, as
  7  *  published by the Free Software Foundation.
  8  *
  9  *  This code is distributed in the hope that it will be useful, but WITHOUT
 10  *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  *  version 2 for more details (a copy is included in the LICENSE file that
 13  *  accompanied this code).
 14  *
 15  *  You should have received a copy of the GNU General Public License version
 16  *  2 along with this work; if not, write to the Free Software Foundation,
 17  *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  *  or visit www.oracle.com if you need additional information or have any
 21  *  questions.
 22  */
 23 
 24 /*
 25  * @test
<span class="line-modified"> 26  * @run testng/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=true -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=false -Xverify:all TestMemoryAccess</span>
<span class="line-added"> 27  * @run testng/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=true -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=true -Xverify:all TestMemoryAccess</span>
<span class="line-added"> 28  * @run testng/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=false -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=false -Xverify:all TestMemoryAccess</span>
<span class="line-added"> 29  * @run testng/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=false -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=true -Xverify:all TestMemoryAccess</span>
 30  */
 31 
 32 import jdk.incubator.foreign.GroupLayout;
 33 import jdk.incubator.foreign.MemoryLayouts;
 34 import jdk.incubator.foreign.MemoryLayout;
 35 import jdk.incubator.foreign.MemoryLayout.PathElement;
 36 import jdk.incubator.foreign.MemorySegment;
 37 import jdk.incubator.foreign.SequenceLayout;
 38 import jdk.incubator.foreign.ValueLayout;
 39 import jdk.incubator.foreign.MemoryAddress;
 40 import java.lang.invoke.VarHandle;
 41 import java.util.function.Function;
 42 
 43 import org.testng.annotations.*;
 44 import static org.testng.Assert.*;
 45 
 46 public class TestMemoryAccess {
 47 
 48     @Test(dataProvider = &quot;elements&quot;)
 49     public void testAccess(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, ValueLayout elemLayout, Class&lt;?&gt; carrier, Checker checker) {
</pre>
<hr />
<pre>
 67     public void testArrayAccess(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, MemoryLayout elemLayout, Class&lt;?&gt; carrier, ArrayChecker checker) {
 68         SequenceLayout seq = MemoryLayout.ofSequence(10, elemLayout.withName(&quot;elem&quot;));
 69         testArrayAccessInternal(viewFactory, seq, seq.varHandle(carrier, PathElement.sequenceElement()), checker);
 70     }
 71 
 72     @Test(dataProvider = &quot;arrayElements&quot;)
 73     public void testPaddedArrayAccessByName(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, MemoryLayout elemLayout, Class&lt;?&gt; carrier, ArrayChecker checker) {
 74         SequenceLayout seq = MemoryLayout.ofSequence(10, MemoryLayout.ofStruct(MemoryLayout.ofPaddingBits(elemLayout.bitSize()), elemLayout.withName(&quot;elem&quot;)));
 75         testArrayAccessInternal(viewFactory, seq, seq.varHandle(carrier, MemoryLayout.PathElement.sequenceElement(), MemoryLayout.PathElement.groupElement(&quot;elem&quot;)), checker);
 76     }
 77 
 78     @Test(dataProvider = &quot;arrayElements&quot;)
 79     public void testPaddedArrayAccessByIndexSeq(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, MemoryLayout elemLayout, Class&lt;?&gt; carrier, ArrayChecker checker) {
 80         SequenceLayout seq = MemoryLayout.ofSequence(10, MemoryLayout.ofSequence(2, elemLayout));
 81         testArrayAccessInternal(viewFactory, seq, seq.varHandle(carrier, PathElement.sequenceElement(), MemoryLayout.PathElement.sequenceElement(1)), checker);
 82     }
 83 
 84     private void testAccessInternal(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, MemoryLayout layout, VarHandle handle, Checker checker) {
 85         MemoryAddress outer_address;
 86         try (MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(layout))) {
<span class="line-added"> 87             boolean isRO = !segment.hasAccessModes(MemorySegment.WRITE);</span>
 88             MemoryAddress addr = segment.baseAddress();
 89             try {
 90                 checker.check(handle, addr);
<span class="line-modified"> 91                 if (isRO) {</span>
 92                     throw new AssertionError(); //not ok, memory should be immutable
 93                 }
 94             } catch (UnsupportedOperationException ex) {
<span class="line-modified"> 95                 if (!isRO) {</span>
 96                     throw new AssertionError(); //we should not have failed!
 97                 }
 98                 return;
 99             }
100             try {
101                 checker.check(handle, addr.addOffset(layout.byteSize()));
102                 throw new AssertionError(); //not ok, out of bounds
103             } catch (IndexOutOfBoundsException ex) {
104                 //ok, should fail (out of bounds)
105             }
106             outer_address = addr; //leak!
107         }
108         try {
109             checker.check(handle, outer_address);
110             throw new AssertionError(); //not ok, scope is closed
111         } catch (IllegalStateException ex) {
112             //ok, should fail (scope is closed)
113         }
114     }
115 
116     private void testArrayAccessInternal(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, SequenceLayout seq, VarHandle handle, ArrayChecker checker) {
117         MemoryAddress outer_address;
118         try (MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(seq))) {
<span class="line-added">119             boolean isRO = !segment.hasAccessModes(MemorySegment.WRITE);</span>
120             MemoryAddress addr = segment.baseAddress();
121             try {
122                 for (int i = 0; i &lt; seq.elementCount().getAsLong(); i++) {
123                     checker.check(handle, addr, i);
124                 }
<span class="line-modified">125                 if (isRO) {</span>
126                     throw new AssertionError(); //not ok, memory should be immutable
127                 }
128             } catch (UnsupportedOperationException ex) {
<span class="line-modified">129                 if (!isRO) {</span>
130                     throw new AssertionError(); //we should not have failed!
131                 }
132                 return;
133             }
134             try {
135                 checker.check(handle, addr, seq.elementCount().getAsLong());
136                 throw new AssertionError(); //not ok, out of bounds
137             } catch (IndexOutOfBoundsException ex) {
138                 //ok, should fail (out of bounds)
139             }
140             outer_address = addr; //leak!
141         }
142         try {
143             checker.check(handle, outer_address, 0);
144             throw new AssertionError(); //not ok, scope is closed
145         } catch (IllegalStateException ex) {
146             //ok, should fail (scope is closed)
147         }
148     }
149 
</pre>
<hr />
<pre>
168     @Test(dataProvider = &quot;matrixElements&quot;)
169     public void testPaddedMatrixAccessByIndexSeq(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, MemoryLayout elemLayout, Class&lt;?&gt; carrier, MatrixChecker checker) {
170         SequenceLayout seq = MemoryLayout.ofSequence(20,
171                 MemoryLayout.ofSequence(10, MemoryLayout.ofSequence(2, elemLayout)));
172         testMatrixAccessInternal(viewFactory, seq,
173                 seq.varHandle(carrier,
174                         PathElement.sequenceElement(), PathElement.sequenceElement(), PathElement.sequenceElement(1)),
175                 checker);
176     }
177 
178     @Test(dataProvider = &quot;badCarriers&quot;,
179           expectedExceptions = IllegalArgumentException.class)
180     public void testBadCarriers(Class&lt;?&gt; carrier) {
181         ValueLayout l = MemoryLayouts.BITS_32_LE.withName(&quot;elem&quot;);
182         l.varHandle(carrier);
183     }
184 
185     private void testMatrixAccessInternal(Function&lt;MemorySegment, MemorySegment&gt; viewFactory, SequenceLayout seq, VarHandle handle, MatrixChecker checker) {
186         MemoryAddress outer_address;
187         try (MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(seq))) {
<span class="line-added">188             boolean isRO = !segment.hasAccessModes(MemorySegment.WRITE);</span>
189             MemoryAddress addr = segment.baseAddress();
190             try {
191                 for (int i = 0; i &lt; seq.elementCount().getAsLong(); i++) {
192                     for (int j = 0; j &lt; ((SequenceLayout) seq.elementLayout()).elementCount().getAsLong(); j++) {
193                         checker.check(handle, addr, i, j);
194                     }
195                 }
<span class="line-modified">196                 if (isRO) {</span>
197                     throw new AssertionError(); //not ok, memory should be immutable
198                 }
199             } catch (UnsupportedOperationException ex) {
<span class="line-modified">200                 if (!isRO) {</span>
201                     throw new AssertionError(); //we should not have failed!
202                 }
203                 return;
204             }
205             try {
206                 checker.check(handle, addr, seq.elementCount().getAsLong(),
207                         ((SequenceLayout)seq.elementLayout()).elementCount().getAsLong());
208                 throw new AssertionError(); //not ok, out of bounds
209             } catch (IndexOutOfBoundsException ex) {
210                 //ok, should fail (out of bounds)
211             }
212             outer_address = addr; //leak!
213         }
214         try {
215             checker.check(handle, outer_address, 0, 0);
216             throw new AssertionError(); //not ok, scope is closed
217         } catch (IllegalStateException ex) {
218             //ok, should fail (scope is closed)
219         }
220     }
221 
222     static Function&lt;MemorySegment, MemorySegment&gt; ID = Function.identity();
<span class="line-modified">223     static Function&lt;MemorySegment, MemorySegment&gt; IMMUTABLE = ms -&gt; ms.withAccessModes(MemorySegment.READ | MemorySegment.CLOSE);</span>
224 
225     @DataProvider(name = &quot;elements&quot;)
226     public Object[][] createData() {
227         return new Object[][] {
228                 //BE, RW
229                 { ID, MemoryLayouts.BITS_8_BE, byte.class, Checker.BYTE },
230                 { ID, MemoryLayouts.BITS_16_BE, short.class, Checker.SHORT },
231                 { ID, MemoryLayouts.BITS_16_BE, char.class, Checker.CHAR },
232                 { ID, MemoryLayouts.BITS_32_BE, int.class, Checker.INT },
233                 { ID, MemoryLayouts.BITS_64_BE, long.class, Checker.LONG },
234                 { ID, MemoryLayouts.BITS_32_BE, float.class, Checker.FLOAT },
235                 { ID, MemoryLayouts.BITS_64_BE, double.class, Checker.DOUBLE },
236                 //BE, RO
237                 { IMMUTABLE, MemoryLayouts.BITS_8_BE, byte.class, Checker.BYTE },
238                 { IMMUTABLE, MemoryLayouts.BITS_16_BE, short.class, Checker.SHORT },
239                 { IMMUTABLE, MemoryLayouts.BITS_16_BE, char.class, Checker.CHAR },
240                 { IMMUTABLE, MemoryLayouts.BITS_32_BE, int.class, Checker.INT },
241                 { IMMUTABLE, MemoryLayouts.BITS_64_BE, long.class, Checker.LONG },
242                 { IMMUTABLE, MemoryLayouts.BITS_32_BE, float.class, Checker.FLOAT },
243                 { IMMUTABLE, MemoryLayouts.BITS_64_BE, double.class, Checker.DOUBLE },
</pre>
</td>
</tr>
</table>
<center><a href="TestLayouts.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="TestNative.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
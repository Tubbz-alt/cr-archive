<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/foreign/TestByteBuffer.java</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="TestArrays.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="TestLayoutConstants.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/foreign/TestByteBuffer.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /*
 27  * @test
 28  * @modules java.base/sun.nio.ch
 29  *          jdk.incubator.foreign/jdk.internal.foreign
 30  * @run testng TestByteBuffer
 31  */
 32 
 33 

 34 import jdk.incubator.foreign.MemoryLayouts;
 35 import jdk.incubator.foreign.MemoryLayout;
 36 import jdk.incubator.foreign.MemoryAddress;
 37 import jdk.incubator.foreign.MemorySegment;
 38 import jdk.incubator.foreign.MemoryLayout.PathElement;
 39 import jdk.incubator.foreign.SequenceLayout;
 40 
 41 import java.io.File;

 42 import java.lang.invoke.MethodHandle;
 43 import java.lang.invoke.MethodHandles;
 44 import java.lang.invoke.VarHandle;
 45 import java.lang.ref.WeakReference;
 46 import java.lang.reflect.InvocationTargetException;
 47 import java.lang.reflect.Method;
 48 import java.lang.reflect.Modifier;
 49 import java.nio.Buffer;
 50 import java.nio.ByteBuffer;
 51 import java.nio.ByteOrder;
 52 import java.nio.CharBuffer;
 53 import java.nio.DoubleBuffer;
 54 import java.nio.FloatBuffer;
 55 import java.nio.IntBuffer;
<span class="line-removed"> 56 import java.nio.InvalidMarkException;</span>
 57 import java.nio.LongBuffer;
 58 import java.nio.MappedByteBuffer;
 59 import java.nio.ShortBuffer;
 60 import java.nio.channels.FileChannel;


 61 import java.nio.file.StandardOpenOption;
 62 import java.util.HashMap;
 63 import java.util.Map;
<span class="line-removed"> 64 import java.util.Optional;</span>
 65 import java.util.function.BiConsumer;
 66 import java.util.function.BiFunction;
 67 import java.util.function.Consumer;
 68 import java.util.function.Function;
<span class="line-modified"> 69 import java.util.function.Supplier;</span>
 70 import java.util.stream.Stream;
 71 


 72 import jdk.internal.foreign.MemoryAddressImpl;

 73 import org.testng.SkipException;
 74 import org.testng.annotations.*;
 75 import sun.nio.ch.DirectBuffer;
<span class="line-modified"> 76 </span>
 77 import static org.testng.Assert.*;
 78 
 79 public class TestByteBuffer {
 80 














 81     static SequenceLayout tuples = MemoryLayout.ofSequence(500,
 82             MemoryLayout.ofStruct(
 83                     MemoryLayouts.BITS_32_BE.withName(&quot;index&quot;),
 84                     MemoryLayouts.BITS_32_BE.withName(&quot;value&quot;)
 85             ));
 86 
 87     static SequenceLayout bytes = MemoryLayout.ofSequence(100,
 88             MemoryLayouts.BITS_8_BE
 89     );
 90 
 91     static SequenceLayout chars = MemoryLayout.ofSequence(100,
 92             MemoryLayouts.BITS_16_BE
 93     );
 94 
 95     static SequenceLayout shorts = MemoryLayout.ofSequence(100,
 96             MemoryLayouts.BITS_16_BE
 97     );
 98 
 99     static SequenceLayout ints = MemoryLayout.ofSequence(100,
100             MemoryLayouts.BITS_32_BE
</pre>
<hr />
<pre>
200         //write to channel
201         try (FileChannel channel = FileChannel.open(f.toPath(), StandardOpenOption.READ, StandardOpenOption.WRITE)) {
202             withMappedBuffer(channel, FileChannel.MapMode.READ_WRITE, 0, tuples.byteSize(), mbb -&gt; {
203                 MemorySegment segment = MemorySegment.ofByteBuffer(mbb);
204                 MemoryAddress base = segment.baseAddress();
205                 initTuples(base);
206                 mbb.force();
207             });
208         }
209 
210         //read from channel
211         try (FileChannel channel = FileChannel.open(f.toPath(), StandardOpenOption.READ)) {
212             withMappedBuffer(channel, FileChannel.MapMode.READ_ONLY, 0, tuples.byteSize(), mbb -&gt; {
213                 MemorySegment segment = MemorySegment.ofByteBuffer(mbb);
214                 MemoryAddress base = segment.baseAddress();
215                 checkTuples(base, mbb);
216             });
217         }
218     }
219 















220     @Test
221     public void testMappedSegment() throws Throwable {
222         File f = new File(&quot;test2.out&quot;);
223         f.createNewFile();
224         f.deleteOnExit();
225 
226         //write to channel
<span class="line-modified">227         try (MemorySegment segment = MemorySegment.mapFromPath(f.toPath(), tuples.byteSize(), FileChannel.MapMode.READ_WRITE)) {</span>
228             MemoryAddress base = segment.baseAddress();
229             initTuples(base);

230         }
231 
232         //read from channel
233         try (MemorySegment segment = MemorySegment.mapFromPath(f.toPath(), tuples.byteSize(), FileChannel.MapMode.READ_ONLY)) {
234             MemoryAddress base = segment.baseAddress();
235             checkTuples(base, segment.asByteBuffer());
236         }
237     }
238 
239     static void withMappedBuffer(FileChannel channel, FileChannel.MapMode mode, long pos, long size, Consumer&lt;MappedByteBuffer&gt; action) throws Throwable {
240         MappedByteBuffer mbb = channel.map(mode, pos, size);
241         var ref = new WeakReference&lt;&gt;(mbb);
242         action.accept(mbb);
243         mbb = null;
244         //wait for it to be GCed
245         System.gc();
246         while (ref.get() != null) {
247             Thread.sleep(20);
248         }
249     }
</pre>
<hr />
<pre>
373         MemoryAddress second = MemorySegment.ofByteBuffer(segment.asByteBuffer()).baseAddress();
374         checker.accept(second);
375     }
376 
377     @Test(dataProvider=&quot;resizeOps&quot;)
378     public void testResizeRoundtripNative(Consumer&lt;MemoryAddress&gt; checker, Consumer&lt;MemoryAddress&gt; initializer, SequenceLayout seq) {
379         try (MemorySegment segment = MemorySegment.allocateNative(seq)) {
380             MemoryAddress first = segment.baseAddress();
381             initializer.accept(first);
382             MemoryAddress second = MemorySegment.ofByteBuffer(segment.asByteBuffer()).baseAddress();
383             checker.accept(second);
384         }
385     }
386 
387     @Test(expectedExceptions = IllegalStateException.class)
388     public void testBufferOnClosedScope() {
389         MemorySegment leaked;
390         try (MemorySegment segment = MemorySegment.allocateNative(bytes)) {
391             leaked = segment;
392         }
<span class="line-modified">393         leaked.asByteBuffer();</span>

394     }
395 
396     @Test(expectedExceptions = { UnsupportedOperationException.class,
397                                  IllegalArgumentException.class })
398     public void testTooBigForByteBuffer() {
<span class="line-modified">399         MemorySegment.allocateNative((long) Integer.MAX_VALUE * 2).asByteBuffer();</span>


400     }
401 
402     @Test(dataProvider=&quot;resizeOps&quot;)
403     public void testCopyHeapToNative(Consumer&lt;MemoryAddress&gt; checker, Consumer&lt;MemoryAddress&gt; initializer, SequenceLayout seq) {
404         checkByteArrayAlignment(seq.elementLayout());
405         int bytes = (int)seq.byteSize();
406         try (MemorySegment nativeArray = MemorySegment.allocateNative(bytes);
407              MemorySegment heapArray = MemorySegment.ofArray(new byte[bytes])) {
408             initializer.accept(heapArray.baseAddress());
409             MemoryAddress.copy(heapArray.baseAddress(), nativeArray.baseAddress(), bytes);
410             checker.accept(nativeArray.baseAddress());
411         }
412     }
413 
414     @Test(dataProvider=&quot;resizeOps&quot;)
415     public void testCopyNativeToHeap(Consumer&lt;MemoryAddress&gt; checker, Consumer&lt;MemoryAddress&gt; initializer, SequenceLayout seq) {
416         checkByteArrayAlignment(seq.elementLayout());
417         int bytes = (int)seq.byteSize();
418         try (MemorySegment nativeArray = MemorySegment.allocateNative(seq);
419              MemorySegment heapArray = MemorySegment.ofArray(new byte[bytes])) {
420             initializer.accept(nativeArray.baseAddress());
421             MemoryAddress.copy(nativeArray.baseAddress(), heapArray.baseAddress(), bytes);
422             checker.accept(heapArray.baseAddress());
423         }
424     }
425 



















































426     @DataProvider(name = &quot;bufferOps&quot;)
427     public static Object[][] bufferOps() throws Throwable {
428         return new Object[][]{
429                 { (Function&lt;ByteBuffer, Buffer&gt;) bb -&gt; bb, bufferMembers(ByteBuffer.class)},
430                 { (Function&lt;ByteBuffer, Buffer&gt;) ByteBuffer::asCharBuffer, bufferMembers(CharBuffer.class)},
431                 { (Function&lt;ByteBuffer, Buffer&gt;) ByteBuffer::asShortBuffer, bufferMembers(ShortBuffer.class)},
432                 { (Function&lt;ByteBuffer, Buffer&gt;) ByteBuffer::asIntBuffer, bufferMembers(IntBuffer.class)},
433                 { (Function&lt;ByteBuffer, Buffer&gt;) ByteBuffer::asFloatBuffer, bufferMembers(FloatBuffer.class)},
434                 { (Function&lt;ByteBuffer, Buffer&gt;) ByteBuffer::asLongBuffer, bufferMembers(LongBuffer.class)},
435                 { (Function&lt;ByteBuffer, Buffer&gt;) ByteBuffer::asDoubleBuffer, bufferMembers(DoubleBuffer.class)},
436         };
437     }
438 
439     static Map&lt;Method, Object[]&gt; bufferMembers(Class&lt;?&gt; bufferClass) {
440         Map&lt;Method, Object[]&gt; members = new HashMap&lt;&gt;();
441         for (Method m : bufferClass.getMethods()) {
442             //skip statics and method declared in j.l.Object
443             if (m.getDeclaringClass().equals(Object.class) ||
444                     (m.getModifiers() &amp; Modifier.STATIC) != 0) continue;
445             Object[] args = Stream.of(m.getParameterTypes())
</pre>
<hr />
<pre>
549                 return new boolean[1];
550             } else if (c == byte[].class) {
551                 return new byte[1];
552             } else if (c == short[].class) {
553                 return new short[1];
554             } else if (c == int[].class) {
555                 return new int[1];
556             } else if (c == long[].class) {
557                 return new long[1];
558             } else if (c == float[].class) {
559                 return new float[1];
560             } else if (c == double[].class) {
561                 return new double[1];
562             } else {
563                 throw new IllegalStateException();
564             }
565         } else {
566             return null;
567         }
568     }























569 }
</pre>
</td>
<td>
<hr />
<pre>
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /*
 27  * @test
 28  * @modules java.base/sun.nio.ch
 29  *          jdk.incubator.foreign/jdk.internal.foreign
 30  * @run testng TestByteBuffer
 31  */
 32 
 33 
<span class="line-added"> 34 import jdk.incubator.foreign.MappedMemorySegment;</span>
 35 import jdk.incubator.foreign.MemoryLayouts;
 36 import jdk.incubator.foreign.MemoryLayout;
 37 import jdk.incubator.foreign.MemoryAddress;
 38 import jdk.incubator.foreign.MemorySegment;
 39 import jdk.incubator.foreign.MemoryLayout.PathElement;
 40 import jdk.incubator.foreign.SequenceLayout;
 41 
 42 import java.io.File;
<span class="line-added"> 43 import java.io.IOException;</span>
 44 import java.lang.invoke.MethodHandle;
 45 import java.lang.invoke.MethodHandles;
 46 import java.lang.invoke.VarHandle;
 47 import java.lang.ref.WeakReference;
 48 import java.lang.reflect.InvocationTargetException;
 49 import java.lang.reflect.Method;
 50 import java.lang.reflect.Modifier;
 51 import java.nio.Buffer;
 52 import java.nio.ByteBuffer;
 53 import java.nio.ByteOrder;
 54 import java.nio.CharBuffer;
 55 import java.nio.DoubleBuffer;
 56 import java.nio.FloatBuffer;
 57 import java.nio.IntBuffer;

 58 import java.nio.LongBuffer;
 59 import java.nio.MappedByteBuffer;
 60 import java.nio.ShortBuffer;
 61 import java.nio.channels.FileChannel;
<span class="line-added"> 62 import java.nio.file.Files;</span>
<span class="line-added"> 63 import java.nio.file.Path;</span>
 64 import java.nio.file.StandardOpenOption;
 65 import java.util.HashMap;
 66 import java.util.Map;

 67 import java.util.function.BiConsumer;
 68 import java.util.function.BiFunction;
 69 import java.util.function.Consumer;
 70 import java.util.function.Function;
<span class="line-modified"> 71 import java.util.function.Predicate;</span>
 72 import java.util.stream.Stream;
 73 
<span class="line-added"> 74 import jdk.internal.foreign.HeapMemorySegmentImpl;</span>
<span class="line-added"> 75 import jdk.internal.foreign.MappedMemorySegmentImpl;</span>
 76 import jdk.internal.foreign.MemoryAddressImpl;
<span class="line-added"> 77 import jdk.internal.foreign.NativeMemorySegmentImpl;</span>
 78 import org.testng.SkipException;
 79 import org.testng.annotations.*;
 80 import sun.nio.ch.DirectBuffer;
<span class="line-modified"> 81 import static jdk.incubator.foreign.MemorySegment.*;</span>
 82 import static org.testng.Assert.*;
 83 
 84 public class TestByteBuffer {
 85 
<span class="line-added"> 86     static Path tempPath;</span>
<span class="line-added"> 87 </span>
<span class="line-added"> 88     static {</span>
<span class="line-added"> 89         try {</span>
<span class="line-added"> 90             File file = File.createTempFile(&quot;buffer&quot;, &quot;txt&quot;);</span>
<span class="line-added"> 91             file.deleteOnExit();</span>
<span class="line-added"> 92             tempPath = file.toPath();</span>
<span class="line-added"> 93             Files.write(file.toPath(), new byte[256], StandardOpenOption.WRITE);</span>
<span class="line-added"> 94 </span>
<span class="line-added"> 95         } catch (IOException ex) {</span>
<span class="line-added"> 96             throw new ExceptionInInitializerError(ex);</span>
<span class="line-added"> 97         }</span>
<span class="line-added"> 98     }</span>
<span class="line-added"> 99 </span>
100     static SequenceLayout tuples = MemoryLayout.ofSequence(500,
101             MemoryLayout.ofStruct(
102                     MemoryLayouts.BITS_32_BE.withName(&quot;index&quot;),
103                     MemoryLayouts.BITS_32_BE.withName(&quot;value&quot;)
104             ));
105 
106     static SequenceLayout bytes = MemoryLayout.ofSequence(100,
107             MemoryLayouts.BITS_8_BE
108     );
109 
110     static SequenceLayout chars = MemoryLayout.ofSequence(100,
111             MemoryLayouts.BITS_16_BE
112     );
113 
114     static SequenceLayout shorts = MemoryLayout.ofSequence(100,
115             MemoryLayouts.BITS_16_BE
116     );
117 
118     static SequenceLayout ints = MemoryLayout.ofSequence(100,
119             MemoryLayouts.BITS_32_BE
</pre>
<hr />
<pre>
219         //write to channel
220         try (FileChannel channel = FileChannel.open(f.toPath(), StandardOpenOption.READ, StandardOpenOption.WRITE)) {
221             withMappedBuffer(channel, FileChannel.MapMode.READ_WRITE, 0, tuples.byteSize(), mbb -&gt; {
222                 MemorySegment segment = MemorySegment.ofByteBuffer(mbb);
223                 MemoryAddress base = segment.baseAddress();
224                 initTuples(base);
225                 mbb.force();
226             });
227         }
228 
229         //read from channel
230         try (FileChannel channel = FileChannel.open(f.toPath(), StandardOpenOption.READ)) {
231             withMappedBuffer(channel, FileChannel.MapMode.READ_ONLY, 0, tuples.byteSize(), mbb -&gt; {
232                 MemorySegment segment = MemorySegment.ofByteBuffer(mbb);
233                 MemoryAddress base = segment.baseAddress();
234                 checkTuples(base, mbb);
235             });
236         }
237     }
238 
<span class="line-added">239     static final int ALL_ACCESS_MODES = READ | WRITE | CLOSE | ACQUIRE | HANDOFF;</span>
<span class="line-added">240 </span>
<span class="line-added">241     @Test</span>
<span class="line-added">242     public void testDefaultAccessModesMappedSegment() throws Throwable {</span>
<span class="line-added">243         try (MappedMemorySegment segment = MemorySegment.mapFromPath(tempPath, 8, FileChannel.MapMode.READ_WRITE)) {</span>
<span class="line-added">244             assertTrue(segment.hasAccessModes(ALL_ACCESS_MODES));</span>
<span class="line-added">245             assertEquals(segment.accessModes(), ALL_ACCESS_MODES);</span>
<span class="line-added">246         }</span>
<span class="line-added">247 </span>
<span class="line-added">248         try (MappedMemorySegment segment = MemorySegment.mapFromPath(tempPath, 8, FileChannel.MapMode.READ_ONLY)) {</span>
<span class="line-added">249             assertTrue(segment.hasAccessModes(ALL_ACCESS_MODES &amp; ~WRITE));</span>
<span class="line-added">250             assertEquals(segment.accessModes(), ALL_ACCESS_MODES&amp; ~WRITE);</span>
<span class="line-added">251         }</span>
<span class="line-added">252     }</span>
<span class="line-added">253 </span>
254     @Test
255     public void testMappedSegment() throws Throwable {
256         File f = new File(&quot;test2.out&quot;);
257         f.createNewFile();
258         f.deleteOnExit();
259 
260         //write to channel
<span class="line-modified">261         try (MappedMemorySegment segment = MemorySegment.mapFromPath(f.toPath(), tuples.byteSize(), FileChannel.MapMode.READ_WRITE)) {</span>
262             MemoryAddress base = segment.baseAddress();
263             initTuples(base);
<span class="line-added">264             segment.force();</span>
265         }
266 
267         //read from channel
268         try (MemorySegment segment = MemorySegment.mapFromPath(f.toPath(), tuples.byteSize(), FileChannel.MapMode.READ_ONLY)) {
269             MemoryAddress base = segment.baseAddress();
270             checkTuples(base, segment.asByteBuffer());
271         }
272     }
273 
274     static void withMappedBuffer(FileChannel channel, FileChannel.MapMode mode, long pos, long size, Consumer&lt;MappedByteBuffer&gt; action) throws Throwable {
275         MappedByteBuffer mbb = channel.map(mode, pos, size);
276         var ref = new WeakReference&lt;&gt;(mbb);
277         action.accept(mbb);
278         mbb = null;
279         //wait for it to be GCed
280         System.gc();
281         while (ref.get() != null) {
282             Thread.sleep(20);
283         }
284     }
</pre>
<hr />
<pre>
408         MemoryAddress second = MemorySegment.ofByteBuffer(segment.asByteBuffer()).baseAddress();
409         checker.accept(second);
410     }
411 
412     @Test(dataProvider=&quot;resizeOps&quot;)
413     public void testResizeRoundtripNative(Consumer&lt;MemoryAddress&gt; checker, Consumer&lt;MemoryAddress&gt; initializer, SequenceLayout seq) {
414         try (MemorySegment segment = MemorySegment.allocateNative(seq)) {
415             MemoryAddress first = segment.baseAddress();
416             initializer.accept(first);
417             MemoryAddress second = MemorySegment.ofByteBuffer(segment.asByteBuffer()).baseAddress();
418             checker.accept(second);
419         }
420     }
421 
422     @Test(expectedExceptions = IllegalStateException.class)
423     public void testBufferOnClosedScope() {
424         MemorySegment leaked;
425         try (MemorySegment segment = MemorySegment.allocateNative(bytes)) {
426             leaked = segment;
427         }
<span class="line-modified">428         ByteBuffer byteBuffer = leaked.asByteBuffer(); // ok</span>
<span class="line-added">429         byteBuffer.get(); // should throw</span>
430     }
431 
432     @Test(expectedExceptions = { UnsupportedOperationException.class,
433                                  IllegalArgumentException.class })
434     public void testTooBigForByteBuffer() {
<span class="line-modified">435         try (MemorySegment segment = MemorySegment.allocateNative((long)Integer.MAX_VALUE + 10L)) {</span>
<span class="line-added">436             segment.asByteBuffer();</span>
<span class="line-added">437         }</span>
438     }
439 
440     @Test(dataProvider=&quot;resizeOps&quot;)
441     public void testCopyHeapToNative(Consumer&lt;MemoryAddress&gt; checker, Consumer&lt;MemoryAddress&gt; initializer, SequenceLayout seq) {
442         checkByteArrayAlignment(seq.elementLayout());
443         int bytes = (int)seq.byteSize();
444         try (MemorySegment nativeArray = MemorySegment.allocateNative(bytes);
445              MemorySegment heapArray = MemorySegment.ofArray(new byte[bytes])) {
446             initializer.accept(heapArray.baseAddress());
447             MemoryAddress.copy(heapArray.baseAddress(), nativeArray.baseAddress(), bytes);
448             checker.accept(nativeArray.baseAddress());
449         }
450     }
451 
452     @Test(dataProvider=&quot;resizeOps&quot;)
453     public void testCopyNativeToHeap(Consumer&lt;MemoryAddress&gt; checker, Consumer&lt;MemoryAddress&gt; initializer, SequenceLayout seq) {
454         checkByteArrayAlignment(seq.elementLayout());
455         int bytes = (int)seq.byteSize();
456         try (MemorySegment nativeArray = MemorySegment.allocateNative(seq);
457              MemorySegment heapArray = MemorySegment.ofArray(new byte[bytes])) {
458             initializer.accept(nativeArray.baseAddress());
459             MemoryAddress.copy(nativeArray.baseAddress(), heapArray.baseAddress(), bytes);
460             checker.accept(heapArray.baseAddress());
461         }
462     }
463 
<span class="line-added">464     @Test</span>
<span class="line-added">465     public void testDefaultAccessModesOfBuffer() {</span>
<span class="line-added">466         ByteBuffer rwBuffer = ByteBuffer.wrap(new byte[4]);</span>
<span class="line-added">467         try (MemorySegment segment = MemorySegment.ofByteBuffer(rwBuffer)) {</span>
<span class="line-added">468             assertTrue(segment.hasAccessModes(ALL_ACCESS_MODES));</span>
<span class="line-added">469             assertEquals(segment.accessModes(), ALL_ACCESS_MODES);</span>
<span class="line-added">470         }</span>
<span class="line-added">471 </span>
<span class="line-added">472         ByteBuffer roBuffer = rwBuffer.asReadOnlyBuffer();</span>
<span class="line-added">473         try (MemorySegment segment = MemorySegment.ofByteBuffer(roBuffer)) {</span>
<span class="line-added">474             assertTrue(segment.hasAccessModes(ALL_ACCESS_MODES &amp; ~WRITE));</span>
<span class="line-added">475             assertEquals(segment.accessModes(), ALL_ACCESS_MODES &amp; ~WRITE);</span>
<span class="line-added">476         }</span>
<span class="line-added">477     }</span>
<span class="line-added">478 </span>
<span class="line-added">479     @Test(dataProvider=&quot;bufferSources&quot;)</span>
<span class="line-added">480     public void testBufferToSegment(ByteBuffer bb, Predicate&lt;MemorySegment&gt; segmentChecker) {</span>
<span class="line-added">481         MemorySegment segment = MemorySegment.ofByteBuffer(bb);</span>
<span class="line-added">482         assertEquals(segment.hasAccessModes(MemorySegment.WRITE), !bb.isReadOnly());</span>
<span class="line-added">483         assertTrue(segmentChecker.test(segment));</span>
<span class="line-added">484         assertTrue(segmentChecker.test(segment.asSlice(0, segment.byteSize())));</span>
<span class="line-added">485         assertTrue(segmentChecker.test(segment.withAccessModes(MemorySegment.READ)));</span>
<span class="line-added">486         assertEquals(bb.capacity(), segment.byteSize());</span>
<span class="line-added">487         //another round trip</span>
<span class="line-added">488         segment = MemorySegment.ofByteBuffer(segment.asByteBuffer());</span>
<span class="line-added">489         assertEquals(segment.hasAccessModes(MemorySegment.WRITE), !bb.isReadOnly());</span>
<span class="line-added">490         assertTrue(segmentChecker.test(segment));</span>
<span class="line-added">491         assertTrue(segmentChecker.test(segment.asSlice(0, segment.byteSize())));</span>
<span class="line-added">492         assertTrue(segmentChecker.test(segment.withAccessModes(MemorySegment.READ)));</span>
<span class="line-added">493         assertEquals(bb.capacity(), segment.byteSize());</span>
<span class="line-added">494     }</span>
<span class="line-added">495 </span>
<span class="line-added">496     @Test</span>
<span class="line-added">497     public void testRoundTripAccess() {</span>
<span class="line-added">498         try(MemorySegment ms = MemorySegment.allocateNative(4)) {</span>
<span class="line-added">499             MemorySegment msNoAccess = ms.withAccessModes(MemorySegment.READ); // READ is required to make BB</span>
<span class="line-added">500             MemorySegment msRoundTrip = MemorySegment.ofByteBuffer(msNoAccess.asByteBuffer());</span>
<span class="line-added">501             assertEquals(msNoAccess.accessModes(), msRoundTrip.accessModes());</span>
<span class="line-added">502         }</span>
<span class="line-added">503     }</span>
<span class="line-added">504 </span>
<span class="line-added">505     @Test(expectedExceptions = IllegalStateException.class)</span>
<span class="line-added">506     public void testDeadAccessOnClosedBufferSegment() {</span>
<span class="line-added">507         MemorySegment s1 = MemorySegment.allocateNative(MemoryLayouts.JAVA_INT);</span>
<span class="line-added">508         MemorySegment s2 = MemorySegment.ofByteBuffer(s1.asByteBuffer());</span>
<span class="line-added">509 </span>
<span class="line-added">510         s1.close(); // memory freed</span>
<span class="line-added">511 </span>
<span class="line-added">512         intHandle.set(s2.baseAddress(), 0L, 10); // Dead access!</span>
<span class="line-added">513     }</span>
<span class="line-added">514 </span>
515     @DataProvider(name = &quot;bufferOps&quot;)
516     public static Object[][] bufferOps() throws Throwable {
517         return new Object[][]{
518                 { (Function&lt;ByteBuffer, Buffer&gt;) bb -&gt; bb, bufferMembers(ByteBuffer.class)},
519                 { (Function&lt;ByteBuffer, Buffer&gt;) ByteBuffer::asCharBuffer, bufferMembers(CharBuffer.class)},
520                 { (Function&lt;ByteBuffer, Buffer&gt;) ByteBuffer::asShortBuffer, bufferMembers(ShortBuffer.class)},
521                 { (Function&lt;ByteBuffer, Buffer&gt;) ByteBuffer::asIntBuffer, bufferMembers(IntBuffer.class)},
522                 { (Function&lt;ByteBuffer, Buffer&gt;) ByteBuffer::asFloatBuffer, bufferMembers(FloatBuffer.class)},
523                 { (Function&lt;ByteBuffer, Buffer&gt;) ByteBuffer::asLongBuffer, bufferMembers(LongBuffer.class)},
524                 { (Function&lt;ByteBuffer, Buffer&gt;) ByteBuffer::asDoubleBuffer, bufferMembers(DoubleBuffer.class)},
525         };
526     }
527 
528     static Map&lt;Method, Object[]&gt; bufferMembers(Class&lt;?&gt; bufferClass) {
529         Map&lt;Method, Object[]&gt; members = new HashMap&lt;&gt;();
530         for (Method m : bufferClass.getMethods()) {
531             //skip statics and method declared in j.l.Object
532             if (m.getDeclaringClass().equals(Object.class) ||
533                     (m.getModifiers() &amp; Modifier.STATIC) != 0) continue;
534             Object[] args = Stream.of(m.getParameterTypes())
</pre>
<hr />
<pre>
638                 return new boolean[1];
639             } else if (c == byte[].class) {
640                 return new byte[1];
641             } else if (c == short[].class) {
642                 return new short[1];
643             } else if (c == int[].class) {
644                 return new int[1];
645             } else if (c == long[].class) {
646                 return new long[1];
647             } else if (c == float[].class) {
648                 return new float[1];
649             } else if (c == double[].class) {
650                 return new double[1];
651             } else {
652                 throw new IllegalStateException();
653             }
654         } else {
655             return null;
656         }
657     }
<span class="line-added">658 </span>
<span class="line-added">659     @DataProvider(name = &quot;bufferSources&quot;)</span>
<span class="line-added">660     public static Object[][] bufferSources() {</span>
<span class="line-added">661         Predicate&lt;MemorySegment&gt; heapTest = segment -&gt; segment instanceof HeapMemorySegmentImpl;</span>
<span class="line-added">662         Predicate&lt;MemorySegment&gt; nativeTest = segment -&gt; segment instanceof NativeMemorySegmentImpl;</span>
<span class="line-added">663         Predicate&lt;MemorySegment&gt; mappedTest = segment -&gt; segment instanceof MappedMemorySegmentImpl;</span>
<span class="line-added">664         try (FileChannel channel = FileChannel.open(tempPath, StandardOpenOption.READ, StandardOpenOption.WRITE)) {</span>
<span class="line-added">665             return new Object[][]{</span>
<span class="line-added">666                     { ByteBuffer.wrap(new byte[256]), heapTest },</span>
<span class="line-added">667                     { ByteBuffer.allocate(256), heapTest },</span>
<span class="line-added">668                     { ByteBuffer.allocateDirect(256), nativeTest },</span>
<span class="line-added">669                     { channel.map(FileChannel.MapMode.READ_WRITE, 0L, 256), mappedTest },</span>
<span class="line-added">670 </span>
<span class="line-added">671                     { ByteBuffer.wrap(new byte[256]).asReadOnlyBuffer(), heapTest },</span>
<span class="line-added">672                     { ByteBuffer.allocate(256).asReadOnlyBuffer(), heapTest },</span>
<span class="line-added">673                     { ByteBuffer.allocateDirect(256).asReadOnlyBuffer(), nativeTest },</span>
<span class="line-added">674                     { channel.map(FileChannel.MapMode.READ_WRITE, 0L, 256).asReadOnlyBuffer(),</span>
<span class="line-added">675                             nativeTest /* this seems to be an existing bug in the BB implementation */ }</span>
<span class="line-added">676             };</span>
<span class="line-added">677         } catch (IOException ex) {</span>
<span class="line-added">678             throw new ExceptionInInitializerError(ex);</span>
<span class="line-added">679         }</span>
<span class="line-added">680     }</span>
681 }
</pre>
</td>
</tr>
</table>
<center><a href="TestArrays.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="TestLayoutConstants.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/jfr/leakprofiler/chains/dfsClosure.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../gc/z/zOopClosures.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="dfsClosure.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/leakprofiler/chains/dfsClosure.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jfr/leakprofiler/chains/bitset.inline.hpp&quot;
 27 #include &quot;jfr/leakprofiler/chains/dfsClosure.hpp&quot;
 28 #include &quot;jfr/leakprofiler/chains/edge.hpp&quot;
 29 #include &quot;jfr/leakprofiler/chains/edgeStore.hpp&quot;
 30 #include &quot;jfr/leakprofiler/chains/rootSetClosure.hpp&quot;
 31 #include &quot;jfr/leakprofiler/utilities/granularTimer.hpp&quot;
 32 #include &quot;jfr/leakprofiler/utilities/rootType.hpp&quot;
 33 #include &quot;jfr/leakprofiler/utilities/unifiedOopRef.inline.hpp&quot;
 34 #include &quot;memory/iterator.inline.hpp&quot;
 35 #include &quot;memory/resourceArea.hpp&quot;
 36 #include &quot;oops/access.inline.hpp&quot;
 37 #include &quot;oops/oop.inline.hpp&quot;
 38 #include &quot;utilities/align.hpp&quot;
 39 
<span class="line-modified"> 40  // max dfs depth should not exceed size of stack</span>
<span class="line-removed"> 41 static const size_t max_dfs_depth = 4000;</span>
 42 
 43 void DFSClosure::find_leaks_from_edge(EdgeStore* edge_store,
 44                                       BitSet* mark_bits,
 45                                       const Edge* start_edge) {
 46   assert(edge_store != NULL, &quot;invariant&quot;);
 47   assert(mark_bits != NULL,&quot; invariant&quot;);
 48   assert(start_edge != NULL, &quot;invariant&quot;);
 49 
 50   // Depth-first search, starting from a BFS egde
 51   DFSClosure dfs(edge_store, mark_bits, start_edge);
 52   start_edge-&gt;pointee()-&gt;oop_iterate(&amp;dfs);
 53 }
 54 
 55 void DFSClosure::find_leaks_from_root_set(EdgeStore* edge_store,
 56                                           BitSet* mark_bits) {
 57   assert(edge_store != NULL, &quot;invariant&quot;);
 58   assert(mark_bits != NULL, &quot;invariant&quot;);
 59 
 60   // Mark root set, to avoid going sideways
 61   DFSClosure dfs(edge_store, mark_bits, NULL);
 62   dfs._max_depth = 1;
 63   RootSetClosure&lt;DFSClosure&gt; rs(&amp;dfs);
 64   rs.process();
 65 
 66   // Depth-first search
 67   dfs._max_depth = max_dfs_depth;
 68   dfs._ignore_root_set = true;
 69   rs.process();
 70 }
 71 
 72 DFSClosure::DFSClosure(EdgeStore* edge_store, BitSet* mark_bits, const Edge* start_edge)
 73   :_edge_store(edge_store), _mark_bits(mark_bits), _start_edge(start_edge),
 74   _max_depth(max_dfs_depth), _depth(0), _ignore_root_set(false) {
<span class="line-removed"> 75   _reference_stack = NEW_C_HEAP_ARRAY(UnifiedOopRef, max_dfs_depth, mtTracing);</span>
<span class="line-removed"> 76 }</span>
<span class="line-removed"> 77 </span>
<span class="line-removed"> 78 DFSClosure::~DFSClosure() {</span>
<span class="line-removed"> 79   FREE_C_HEAP_ARRAY(UnifiedOopRef, _reference_stack);</span>
 80 }
 81 
 82 void DFSClosure::closure_impl(UnifiedOopRef reference, const oop pointee) {
 83   assert(pointee != NULL, &quot;invariant&quot;);
 84   assert(!reference.is_null(), &quot;invariant&quot;);
 85 
 86   if (GranularTimer::is_finished()) {
 87     return;
 88   }
 89   if (_depth == 0 &amp;&amp; _ignore_root_set) {
 90     // Root set is already marked, but we want
 91     // to continue, so skip is_marked check.
 92     assert(_mark_bits-&gt;is_marked(pointee), &quot;invariant&quot;);
 93   }  else {
 94     if (_mark_bits-&gt;is_marked(pointee)) {
 95       return;
 96     }
 97   }
 98   _reference_stack[_depth] = reference;
 99   _mark_bits-&gt;mark_obj(pointee);
</pre>
</td>
<td>
<hr />
<pre>
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jfr/leakprofiler/chains/bitset.inline.hpp&quot;
 27 #include &quot;jfr/leakprofiler/chains/dfsClosure.hpp&quot;
 28 #include &quot;jfr/leakprofiler/chains/edge.hpp&quot;
 29 #include &quot;jfr/leakprofiler/chains/edgeStore.hpp&quot;
 30 #include &quot;jfr/leakprofiler/chains/rootSetClosure.hpp&quot;
 31 #include &quot;jfr/leakprofiler/utilities/granularTimer.hpp&quot;
 32 #include &quot;jfr/leakprofiler/utilities/rootType.hpp&quot;
 33 #include &quot;jfr/leakprofiler/utilities/unifiedOopRef.inline.hpp&quot;
 34 #include &quot;memory/iterator.inline.hpp&quot;
 35 #include &quot;memory/resourceArea.hpp&quot;
 36 #include &quot;oops/access.inline.hpp&quot;
 37 #include &quot;oops/oop.inline.hpp&quot;
 38 #include &quot;utilities/align.hpp&quot;
 39 
<span class="line-modified"> 40 UnifiedOopRef DFSClosure::_reference_stack[max_dfs_depth];</span>

 41 
 42 void DFSClosure::find_leaks_from_edge(EdgeStore* edge_store,
 43                                       BitSet* mark_bits,
 44                                       const Edge* start_edge) {
 45   assert(edge_store != NULL, &quot;invariant&quot;);
 46   assert(mark_bits != NULL,&quot; invariant&quot;);
 47   assert(start_edge != NULL, &quot;invariant&quot;);
 48 
 49   // Depth-first search, starting from a BFS egde
 50   DFSClosure dfs(edge_store, mark_bits, start_edge);
 51   start_edge-&gt;pointee()-&gt;oop_iterate(&amp;dfs);
 52 }
 53 
 54 void DFSClosure::find_leaks_from_root_set(EdgeStore* edge_store,
 55                                           BitSet* mark_bits) {
 56   assert(edge_store != NULL, &quot;invariant&quot;);
 57   assert(mark_bits != NULL, &quot;invariant&quot;);
 58 
 59   // Mark root set, to avoid going sideways
 60   DFSClosure dfs(edge_store, mark_bits, NULL);
 61   dfs._max_depth = 1;
 62   RootSetClosure&lt;DFSClosure&gt; rs(&amp;dfs);
 63   rs.process();
 64 
 65   // Depth-first search
 66   dfs._max_depth = max_dfs_depth;
 67   dfs._ignore_root_set = true;
 68   rs.process();
 69 }
 70 
 71 DFSClosure::DFSClosure(EdgeStore* edge_store, BitSet* mark_bits, const Edge* start_edge)
 72   :_edge_store(edge_store), _mark_bits(mark_bits), _start_edge(start_edge),
 73   _max_depth(max_dfs_depth), _depth(0), _ignore_root_set(false) {





 74 }
 75 
 76 void DFSClosure::closure_impl(UnifiedOopRef reference, const oop pointee) {
 77   assert(pointee != NULL, &quot;invariant&quot;);
 78   assert(!reference.is_null(), &quot;invariant&quot;);
 79 
 80   if (GranularTimer::is_finished()) {
 81     return;
 82   }
 83   if (_depth == 0 &amp;&amp; _ignore_root_set) {
 84     // Root set is already marked, but we want
 85     // to continue, so skip is_marked check.
 86     assert(_mark_bits-&gt;is_marked(pointee), &quot;invariant&quot;);
 87   }  else {
 88     if (_mark_bits-&gt;is_marked(pointee)) {
 89       return;
 90     }
 91   }
 92   _reference_stack[_depth] = reference;
 93   _mark_bits-&gt;mark_obj(pointee);
</pre>
</td>
</tr>
</table>
<center><a href="../../../gc/z/zOopClosures.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="dfsClosure.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
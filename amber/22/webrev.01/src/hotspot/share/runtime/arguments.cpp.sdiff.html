<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/arguments.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../prims/jvm.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="arguments.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/arguments.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 543 
 544   // -------------- Obsolete Flags - sorted by expired_in --------------
 545   { &quot;PermSize&quot;,                      JDK_Version::undefined(), JDK_Version::jdk(8),  JDK_Version::undefined() },
 546   { &quot;MaxPermSize&quot;,                   JDK_Version::undefined(), JDK_Version::jdk(8),  JDK_Version::undefined() },
 547   { &quot;SharedReadWriteSize&quot;,           JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },
 548   { &quot;SharedReadOnlySize&quot;,            JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },
 549   { &quot;SharedMiscDataSize&quot;,            JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },
 550   { &quot;SharedMiscCodeSize&quot;,            JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },
 551   { &quot;BindGCTaskThreadsToCPUs&quot;,       JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(16) },
 552   { &quot;UseGCTaskAffinity&quot;,             JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(16) },
 553   { &quot;GCTaskTimeStampEntries&quot;,        JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(16) },
 554   { &quot;G1RSetScanBlockSize&quot;,           JDK_Version::jdk(14),     JDK_Version::jdk(15), JDK_Version::jdk(16) },
 555   { &quot;UseParallelOldGC&quot;,              JDK_Version::jdk(14),     JDK_Version::jdk(15), JDK_Version::jdk(16) },
 556   { &quot;CompactFields&quot;,                 JDK_Version::jdk(14),     JDK_Version::jdk(15), JDK_Version::jdk(16) },
 557   { &quot;FieldsAllocationStyle&quot;,         JDK_Version::jdk(14),     JDK_Version::jdk(15), JDK_Version::jdk(16) },
 558 #ifndef X86
 559   { &quot;UseSSE&quot;,                        JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
 560 #endif // !X86
 561   { &quot;UseAdaptiveGCBoundary&quot;,         JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
 562   { &quot;MonitorBound&quot;,                  JDK_Version::jdk(14),     JDK_Version::jdk(15), JDK_Version::jdk(16) },






 563 
 564 #ifdef TEST_VERIFY_SPECIAL_JVM_FLAGS
 565   // These entries will generate build errors.  Their purpose is to test the macros.
 566   { &quot;dep &gt; obs&quot;,                    JDK_Version::jdk(9), JDK_Version::jdk(8), JDK_Version::undefined() },
 567   { &quot;dep &gt; exp &quot;,                   JDK_Version::jdk(9), JDK_Version::undefined(), JDK_Version::jdk(8) },
 568   { &quot;obs &gt; exp &quot;,                   JDK_Version::undefined(), JDK_Version::jdk(9), JDK_Version::jdk(8) },
 569   { &quot;obs &gt; exp&quot;,                    JDK_Version::jdk(8), JDK_Version::undefined(), JDK_Version::jdk(10) },
 570   { &quot;not deprecated or obsolete&quot;,   JDK_Version::undefined(), JDK_Version::undefined(), JDK_Version::jdk(9) },
 571   { &quot;dup option&quot;,                   JDK_Version::jdk(9), JDK_Version::undefined(), JDK_Version::undefined() },
 572   { &quot;dup option&quot;,                   JDK_Version::jdk(9), JDK_Version::undefined(), JDK_Version::undefined() },
 573 #endif
 574 
 575 #ifndef COMPILER2
 576   // These flags were generally available, but are C2 only, now.
 577   { &quot;MaxInlineLevel&quot;,               JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
 578   { &quot;MaxRecursiveInlineLevel&quot;,      JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
 579   { &quot;InlineSmallCode&quot;,              JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
 580   { &quot;MaxInlineSize&quot;,                JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
 581   { &quot;FreqInlineSize&quot;,               JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
 582   { &quot;MaxTrivialSize&quot;,               JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
 583 #endif
 584 
 585   { NULL, JDK_Version(0), JDK_Version(0) }
 586 };
 587 
 588 // Flags that are aliases for other flags.
 589 typedef struct {
 590   const char* alias_name;
 591   const char* real_name;
 592 } AliasedFlag;
 593 
 594 static AliasedFlag const aliased_jvm_flags[] = {
 595   { &quot;DefaultMaxRAMFraction&quot;,    &quot;MaxRAMFraction&quot;    },
 596   { &quot;CreateMinidumpOnCrash&quot;,    &quot;CreateCoredumpOnCrash&quot; },
 597   { NULL, NULL}
 598 };
 599 
 600 // NOTE: A compatibility request will be necessary for each alias to be removed.
 601 static AliasedLoggingFlag const aliased_logging_flags[] = {
<span class="line-removed"> 602   { &quot;PrintCompressedOopsMode&quot;,   LogLevel::Info,  true,  LOG_TAGS(gc, heap, coops) },</span>
 603   { &quot;PrintSharedSpaces&quot;,         LogLevel::Info,  true,  LOG_TAGS(cds) },
 604   { &quot;TraceBiasedLocking&quot;,        LogLevel::Info,  true,  LOG_TAGS(biasedlocking) },
 605   { &quot;TraceClassLoading&quot;,         LogLevel::Info,  true,  LOG_TAGS(class, load) },
 606   { &quot;TraceClassLoadingPreorder&quot;, LogLevel::Debug, true,  LOG_TAGS(class, preorder) },
 607   { &quot;TraceClassPaths&quot;,           LogLevel::Info,  true,  LOG_TAGS(class, path) },
 608   { &quot;TraceClassResolution&quot;,      LogLevel::Debug, true,  LOG_TAGS(class, resolve) },
 609   { &quot;TraceClassUnloading&quot;,       LogLevel::Info,  true,  LOG_TAGS(class, unload) },
 610   { &quot;TraceExceptions&quot;,           LogLevel::Info,  true,  LOG_TAGS(exceptions) },
 611   { &quot;TraceInvokeDynamic&quot;,        LogLevel::Debug, true,  LOG_TAGS(methodhandles, indy) },
 612   { &quot;TraceLoaderConstraints&quot;,    LogLevel::Info,  true,  LOG_TAGS(class, loader, constraints) },
 613   { &quot;TraceMethodHandles&quot;,        LogLevel::Info,  true,  LOG_TAGS(methodhandles) },
 614   { &quot;TraceMonitorInflation&quot;,     LogLevel::Trace, true,  LOG_TAGS(monitorinflation) },
 615   { &quot;TraceSafepointCleanupTime&quot;, LogLevel::Info,  true,  LOG_TAGS(safepoint, cleanup) },
 616   { &quot;TraceJVMTIObjectTagging&quot;,   LogLevel::Debug, true,  LOG_TAGS(jvmti, objecttagging) },
 617   { &quot;TraceRedefineClasses&quot;,      LogLevel::Info,  false, LOG_TAGS(redefine, class) },
 618   { &quot;PrintJNIResolving&quot;,         LogLevel::Debug, true,  LOG_TAGS(jni, resolve) },
 619   { NULL,                        LogLevel::Off,   false, LOG_TAGS(_NO_TAG) }
 620 };
 621 
 622 #ifndef PRODUCT
</pre>
<hr />
<pre>
2124                 TLABRefillWasteFraction);
2125     status = false;
2126   }
2127 
2128   if (PrintNMTStatistics) {
2129 #if INCLUDE_NMT
2130     if (MemTracker::tracking_level() == NMT_off) {
2131 #endif // INCLUDE_NMT
2132       warning(&quot;PrintNMTStatistics is disabled, because native memory tracking is not enabled&quot;);
2133       PrintNMTStatistics = false;
2134 #if INCLUDE_NMT
2135     }
2136 #endif
2137   }
2138 
2139   status = CompilerConfig::check_args_consistency(status);
2140 #if INCLUDE_JVMCI
2141   if (status &amp;&amp; EnableJVMCI) {
2142     PropertyList_unique_add(&amp;_system_properties, &quot;jdk.internal.vm.ci.enabled&quot;, &quot;true&quot;,
2143         AddProperty, UnwriteableProperty, InternalProperty);
<span class="line-modified">2144     if (!create_numbered_property(&quot;jdk.module.addmods&quot;, &quot;jdk.internal.vm.ci&quot;, addmods_count++)) {</span>
2145       return false;
2146     }
2147   }
2148 #endif
2149 
2150 #ifndef SUPPORT_RESERVED_STACK_AREA
2151   if (StackReservedPages != 0) {
2152     FLAG_SET_CMDLINE(StackReservedPages, 0);
2153     warning(&quot;Reserved Stack Area not supported on this platform&quot;);
2154   }
2155 #endif
2156 
2157   status = status &amp;&amp; GCArguments::check_args_consistency();
2158 
2159   return status;
2160 }
2161 
2162 bool Arguments::is_bad_option(const JavaVMOption* option, jboolean ignore,
2163   const char* option_type) {
2164   if (ignore) return false;
</pre>
<hr />
<pre>
2188 
2189   // Check the sign first since atojulong() parses only unsigned values.
2190   bool value_is_positive = !(*value == &#39;-&#39;);
2191 
2192   if (value_is_positive) {
2193     julong n;
2194     bool good_return = atojulong(value, &amp;n);
2195     if (good_return) {
2196       bool above_minimum = n &gt;= min_size;
2197       bool value_is_too_large = n &gt; max_uintx;
2198 
2199       if (above_minimum &amp;&amp; !value_is_too_large) {
2200         *uintx_arg = n;
2201         return true;
2202       }
2203     }
2204   }
2205   return false;
2206 }
2207 
<span class="line-modified">2208 bool Arguments::create_property(const char* prop_name, const char* prop_value, PropertyInternal internal) {</span>


2209   size_t prop_len = strlen(prop_name) + strlen(prop_value) + 2;
2210   char* property = AllocateHeap(prop_len, mtArguments);
2211   int ret = jio_snprintf(property, prop_len, &quot;%s=%s&quot;, prop_name, prop_value);
2212   if (ret &lt; 0 || ret &gt;= (int)prop_len) {
2213     FreeHeap(property);
2214     return false;
2215   }
<span class="line-modified">2216   bool added = add_property(property, UnwriteableProperty, internal);</span>





2217   FreeHeap(property);
2218   return added;
2219 }
2220 
<span class="line-modified">2221 bool Arguments::create_numbered_property(const char* prop_base_name, const char* prop_value, unsigned int count) {</span>

2222   const unsigned int props_count_limit = 1000;
2223   const int max_digits = 3;
2224   const int extra_symbols_count = 3; // includes &#39;.&#39;, &#39;=&#39;, &#39;\0&#39;
2225 
2226   // Make sure count is &lt; props_count_limit. Otherwise, memory allocation will be too small.
2227   if (count &lt; props_count_limit) {
2228     size_t prop_len = strlen(prop_base_name) + strlen(prop_value) + max_digits + extra_symbols_count;
2229     char* property = AllocateHeap(prop_len, mtArguments);
2230     int ret = jio_snprintf(property, prop_len, &quot;%s.%d=%s&quot;, prop_base_name, count, prop_value);
2231     if (ret &lt; 0 || ret &gt;= (int)prop_len) {
2232       FreeHeap(property);
2233       jio_fprintf(defaultStream::error_stream(), &quot;Failed to create property %s.%d=%s\n&quot;, prop_base_name, count, prop_value);
2234       return false;
2235     }
2236     bool added = add_property(property, UnwriteableProperty, InternalProperty);
2237     FreeHeap(property);
2238     return added;
2239   }
2240 
2241   jio_fprintf(defaultStream::error_stream(), &quot;Property count limit exceeded: %s, limit=%d\n&quot;, prop_base_name, props_count_limit);
</pre>
<hr />
<pre>
2363 }
2364 
2365 int Arguments::process_patch_mod_option(const char* patch_mod_tail, bool* patch_mod_javabase) {
2366   // --patch-module=&lt;module&gt;=&lt;file&gt;(&lt;pathsep&gt;&lt;file&gt;)*
2367   assert(patch_mod_tail != NULL, &quot;Unexpected NULL patch-module value&quot;);
2368   // Find the equal sign between the module name and the path specification
2369   const char* module_equal = strchr(patch_mod_tail, &#39;=&#39;);
2370   if (module_equal == NULL) {
2371     jio_fprintf(defaultStream::output_stream(), &quot;Missing &#39;=&#39; in --patch-module specification\n&quot;);
2372     return JNI_ERR;
2373   } else {
2374     // Pick out the module name
2375     size_t module_len = module_equal - patch_mod_tail;
2376     char* module_name = NEW_C_HEAP_ARRAY_RETURN_NULL(char, module_len+1, mtArguments);
2377     if (module_name != NULL) {
2378       memcpy(module_name, patch_mod_tail, module_len);
2379       *(module_name + module_len) = &#39;\0&#39;;
2380       // The path piece begins one past the module_equal sign
2381       add_patch_mod_prefix(module_name, module_equal + 1, patch_mod_javabase);
2382       FREE_C_HEAP_ARRAY(char, module_name);
<span class="line-modified">2383       if (!create_numbered_property(&quot;jdk.module.patch&quot;, patch_mod_tail, patch_mod_count++)) {</span>
2384         return JNI_ENOMEM;
2385       }
2386     } else {
2387       return JNI_ENOMEM;
2388     }
2389   }
2390   return JNI_OK;
2391 }
2392 
2393 // Parse -Xss memory string parameter and convert to ThreadStackSize in K.
2394 jint Arguments::parse_xss(const JavaVMOption* option, const char* tail, intx* out_ThreadStackSize) {
2395   // The min and max sizes match the values in globals.hpp, but scaled
2396   // with K. The values have been chosen so that alignment with page
2397   // size doesn&#39;t change the max value, which makes the conversions
2398   // back and forth between Xss value and ThreadStackSize value easier.
2399   // The values have also been chosen to fit inside a 32-bit signed type.
2400   const julong min_ThreadStackSize = 0;
2401   const julong max_ThreadStackSize = 1 * M;
2402 
2403   const julong min_size = min_ThreadStackSize * K;
</pre>
<hr />
<pre>
2508         const char* pos = strchr(tail, &#39;:&#39;);
2509         size_t len = (pos == NULL) ? strlen(tail) : pos - tail;
2510         char* name = NEW_C_HEAP_ARRAY(char, len + 1, mtArguments);
2511         jio_snprintf(name, len + 1, &quot;%s&quot;, tail);
2512 
2513         char *options = NULL;
2514         if(pos != NULL) {
2515           size_t len2 = strlen(pos+1) + 1; // options start after &#39;:&#39;.  Final zero must be copied.
2516           options = (char*)memcpy(NEW_C_HEAP_ARRAY(char, len2, mtArguments), pos+1, len2);
2517         }
2518 #if !INCLUDE_JVMTI
2519         if (strcmp(name, &quot;jdwp&quot;) == 0) {
2520           jio_fprintf(defaultStream::error_stream(),
2521             &quot;Debugging agents are not supported in this VM\n&quot;);
2522           return JNI_ERR;
2523         }
2524 #endif // !INCLUDE_JVMTI
2525         add_init_library(name, options);
2526       }
2527     } else if (match_option(option, &quot;--add-reads=&quot;, &amp;tail)) {
<span class="line-modified">2528       if (!create_numbered_property(&quot;jdk.module.addreads&quot;, tail, addreads_count++)) {</span>
2529         return JNI_ENOMEM;
2530       }
2531     } else if (match_option(option, &quot;--add-exports=&quot;, &amp;tail)) {
<span class="line-modified">2532       if (!create_numbered_property(&quot;jdk.module.addexports&quot;, tail, addexports_count++)) {</span>
2533         return JNI_ENOMEM;
2534       }
2535     } else if (match_option(option, &quot;--add-opens=&quot;, &amp;tail)) {
<span class="line-modified">2536       if (!create_numbered_property(&quot;jdk.module.addopens&quot;, tail, addopens_count++)) {</span>
2537         return JNI_ENOMEM;
2538       }
2539     } else if (match_option(option, &quot;--add-modules=&quot;, &amp;tail)) {
<span class="line-modified">2540       if (!create_numbered_property(&quot;jdk.module.addmods&quot;, tail, addmods_count++)) {</span>
2541         return JNI_ENOMEM;
2542       }
2543     } else if (match_option(option, &quot;--limit-modules=&quot;, &amp;tail)) {
<span class="line-modified">2544       if (!create_property(&quot;jdk.module.limitmods&quot;, tail, InternalProperty)) {</span>
2545         return JNI_ENOMEM;
2546       }
2547     } else if (match_option(option, &quot;--module-path=&quot;, &amp;tail)) {
<span class="line-modified">2548       if (!create_property(&quot;jdk.module.path&quot;, tail, ExternalProperty)) {</span>
2549         return JNI_ENOMEM;
2550       }
2551     } else if (match_option(option, &quot;--upgrade-module-path=&quot;, &amp;tail)) {
<span class="line-modified">2552       if (!create_property(&quot;jdk.module.upgrade.path&quot;, tail, ExternalProperty)) {</span>
2553         return JNI_ENOMEM;
2554       }
2555     } else if (match_option(option, &quot;--patch-module=&quot;, &amp;tail)) {
2556       // --patch-module=&lt;module&gt;=&lt;file&gt;(&lt;pathsep&gt;&lt;file&gt;)*
2557       int res = process_patch_mod_option(tail, patch_mod_javabase);
2558       if (res != JNI_OK) {
2559         return res;
2560       }
2561     } else if (match_option(option, &quot;--illegal-access=&quot;, &amp;tail)) {
<span class="line-modified">2562       if (!create_property(&quot;jdk.module.illegalAccess&quot;, tail, ExternalProperty)) {</span>
2563         return JNI_ENOMEM;
2564       }
2565     // -agentlib and -agentpath
2566     } else if (match_option(option, &quot;-agentlib:&quot;, &amp;tail) ||
2567           (is_absolute_path = match_option(option, &quot;-agentpath:&quot;, &amp;tail))) {
2568       if(tail != NULL) {
2569         const char* pos = strchr(tail, &#39;=&#39;);
2570         char* name;
2571         if (pos == NULL) {
2572           name = os::strdup_check_oom(tail, mtArguments);
2573         } else {
2574           size_t len = pos - tail;
2575           name = NEW_C_HEAP_ARRAY(char, len + 1, mtArguments);
2576           memcpy(name, tail, len);
2577           name[len] = &#39;\0&#39;;
2578         }
2579 
2580         char *options = NULL;
2581         if(pos != NULL) {
2582           options = os::strdup_check_oom(pos + 1, mtArguments);
</pre>
<hr />
<pre>
2586           jio_fprintf(defaultStream::error_stream(),
2587             &quot;Debugging agents are not supported in this VM\n&quot;);
2588           return JNI_ERR;
2589         }
2590 #endif // !INCLUDE_JVMTI
2591         add_init_agent(name, options, is_absolute_path);
2592       }
2593     // -javaagent
2594     } else if (match_option(option, &quot;-javaagent:&quot;, &amp;tail)) {
2595 #if !INCLUDE_JVMTI
2596       jio_fprintf(defaultStream::error_stream(),
2597         &quot;Instrumentation agents are not supported in this VM\n&quot;);
2598       return JNI_ERR;
2599 #else
2600       if (tail != NULL) {
2601         size_t length = strlen(tail) + 1;
2602         char *options = NEW_C_HEAP_ARRAY(char, length, mtArguments);
2603         jio_snprintf(options, length, &quot;%s&quot;, tail);
2604         add_instrument_agent(&quot;instrument&quot;, options, false);
2605         // java agents need module java.instrument
<span class="line-modified">2606         if (!create_numbered_property(&quot;jdk.module.addmods&quot;, &quot;java.instrument&quot;, addmods_count++)) {</span>
2607           return JNI_ENOMEM;
2608         }
2609       }
2610 #endif // !INCLUDE_JVMTI
2611     // --enable_preview
2612     } else if (match_option(option, &quot;--enable-preview&quot;)) {
2613       set_enable_preview();
2614     // -Xnoclassgc
2615     } else if (match_option(option, &quot;-Xnoclassgc&quot;)) {
2616       if (FLAG_SET_CMDLINE(ClassUnloading, false) != JVMFlag::SUCCESS) {
2617         return JNI_EINVAL;
2618       }
2619     // -Xbatch
2620     } else if (match_option(option, &quot;-Xbatch&quot;)) {
2621       if (FLAG_SET_CMDLINE(BackgroundCompilation, false) != JVMFlag::SUCCESS) {
2622         return JNI_EINVAL;
2623       }
2624     // -Xmn for compatibility with other JVM vendors
2625     } else if (match_option(option, &quot;-Xmn&quot;, &amp;tail)) {
2626       julong long_initial_young_size = 0;
</pre>
<hr />
<pre>
2767           &quot;-Djava.ext.dirs=%s is not supported.  Use -classpath instead.\n&quot;, value);
2768         return JNI_EINVAL;
2769       }
2770       // Check for module related properties.  They must be set using the modules
2771       // options. For example: use &quot;--add-modules=java.sql&quot;, not
2772       // &quot;-Djdk.module.addmods=java.sql&quot;
2773       if (is_internal_module_property(option-&gt;optionString + 2)) {
2774         needs_module_property_warning = true;
2775         continue;
2776       }
2777       if (!add_property(tail)) {
2778         return JNI_ENOMEM;
2779       }
2780       // Out of the box management support
2781       if (match_option(option, &quot;-Dcom.sun.management&quot;, &amp;tail)) {
2782 #if INCLUDE_MANAGEMENT
2783         if (FLAG_SET_CMDLINE(ManagementServer, true) != JVMFlag::SUCCESS) {
2784           return JNI_EINVAL;
2785         }
2786         // management agent in module jdk.management.agent
<span class="line-modified">2787         if (!create_numbered_property(&quot;jdk.module.addmods&quot;, &quot;jdk.management.agent&quot;, addmods_count++)) {</span>
2788           return JNI_ENOMEM;
2789         }
2790 #else
2791         jio_fprintf(defaultStream::output_stream(),
2792           &quot;-Dcom.sun.management is not supported in this VM.\n&quot;);
2793         return JNI_ERR;
2794 #endif
2795       }
2796     // -Xint
2797     } else if (match_option(option, &quot;-Xint&quot;)) {
2798           set_mode_flags(_int);
2799     // -Xmixed
2800     } else if (match_option(option, &quot;-Xmixed&quot;)) {
2801           set_mode_flags(_mixed);
2802     // -Xcomp
2803     } else if (match_option(option, &quot;-Xcomp&quot;)) {
2804       // for testing the compiler; turn off all flags that inhibit compilation
2805           set_mode_flags(_comp);
2806     // -Xshare:dump
2807     } else if (match_option(option, &quot;-Xshare:dump&quot;)) {
</pre>
<hr />
<pre>
4294 void Arguments::PropertyList_add(SystemProperty** plist, const char* k, const char* v,
4295                                  bool writeable, bool internal) {
4296   if (plist == NULL)
4297     return;
4298 
4299   SystemProperty* new_p = new SystemProperty(k, v, writeable, internal);
4300   PropertyList_add(plist, new_p);
4301 }
4302 
4303 void Arguments::PropertyList_add(SystemProperty *element) {
4304   PropertyList_add(&amp;_system_properties, element);
4305 }
4306 
4307 // This add maintains unique property key in the list.
4308 void Arguments::PropertyList_unique_add(SystemProperty** plist, const char* k, const char* v,
4309                                         PropertyAppendable append, PropertyWriteable writeable,
4310                                         PropertyInternal internal) {
4311   if (plist == NULL)
4312     return;
4313 
<span class="line-modified">4314   // If property key exist then update with new value.</span>

4315   SystemProperty* prop;
4316   for (prop = *plist; prop != NULL; prop = prop-&gt;next()) {
4317     if (strcmp(k, prop-&gt;key()) == 0) {
4318       if (append == AppendProperty) {
<span class="line-modified">4319         prop-&gt;append_value(v);</span>
4320       } else {
<span class="line-modified">4321         prop-&gt;set_value(v);</span>
4322       }
4323       return;
4324     }
4325   }
4326 
4327   PropertyList_add(plist, k, v, writeable == WriteableProperty, internal == InternalProperty);
4328 }
4329 
4330 // Copies src into buf, replacing &quot;%%&quot; with &quot;%&quot; and &quot;%p&quot; with pid
4331 // Returns true if all of the source pointed by src has been copied over to
4332 // the destination buffer pointed by buf. Otherwise, returns false.
4333 // Notes:
4334 // 1. If the length (buflen) of the destination buffer excluding the
4335 // NULL terminator character is not long enough for holding the expanded
4336 // pid characters, it also returns false instead of returning the partially
4337 // expanded one.
4338 // 2. The passed in &quot;buflen&quot; should be large enough to hold the null terminator.
4339 bool Arguments::copy_expand_pid(const char* src, size_t srclen,
4340                                 char* buf, size_t buflen) {
4341   const char* p = src;
</pre>
</td>
<td>
<hr />
<pre>
 543 
 544   // -------------- Obsolete Flags - sorted by expired_in --------------
 545   { &quot;PermSize&quot;,                      JDK_Version::undefined(), JDK_Version::jdk(8),  JDK_Version::undefined() },
 546   { &quot;MaxPermSize&quot;,                   JDK_Version::undefined(), JDK_Version::jdk(8),  JDK_Version::undefined() },
 547   { &quot;SharedReadWriteSize&quot;,           JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },
 548   { &quot;SharedReadOnlySize&quot;,            JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },
 549   { &quot;SharedMiscDataSize&quot;,            JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },
 550   { &quot;SharedMiscCodeSize&quot;,            JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },
 551   { &quot;BindGCTaskThreadsToCPUs&quot;,       JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(16) },
 552   { &quot;UseGCTaskAffinity&quot;,             JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(16) },
 553   { &quot;GCTaskTimeStampEntries&quot;,        JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(16) },
 554   { &quot;G1RSetScanBlockSize&quot;,           JDK_Version::jdk(14),     JDK_Version::jdk(15), JDK_Version::jdk(16) },
 555   { &quot;UseParallelOldGC&quot;,              JDK_Version::jdk(14),     JDK_Version::jdk(15), JDK_Version::jdk(16) },
 556   { &quot;CompactFields&quot;,                 JDK_Version::jdk(14),     JDK_Version::jdk(15), JDK_Version::jdk(16) },
 557   { &quot;FieldsAllocationStyle&quot;,         JDK_Version::jdk(14),     JDK_Version::jdk(15), JDK_Version::jdk(16) },
 558 #ifndef X86
 559   { &quot;UseSSE&quot;,                        JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
 560 #endif // !X86
 561   { &quot;UseAdaptiveGCBoundary&quot;,         JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
 562   { &quot;MonitorBound&quot;,                  JDK_Version::jdk(14),     JDK_Version::jdk(15), JDK_Version::jdk(16) },
<span class="line-added"> 563 #ifdef AARCH64</span>
<span class="line-added"> 564   { &quot;UseBarriersForVolatile&quot;,        JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },</span>
<span class="line-added"> 565 #endif</span>
<span class="line-added"> 566   { &quot;UseLWPSynchronization&quot;,         JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },</span>
<span class="line-added"> 567   { &quot;BranchOnRegister&quot;,              JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },</span>
<span class="line-added"> 568   { &quot;LIRFillDelaySlots&quot;,             JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },</span>
 569 
 570 #ifdef TEST_VERIFY_SPECIAL_JVM_FLAGS
 571   // These entries will generate build errors.  Their purpose is to test the macros.
 572   { &quot;dep &gt; obs&quot;,                    JDK_Version::jdk(9), JDK_Version::jdk(8), JDK_Version::undefined() },
 573   { &quot;dep &gt; exp &quot;,                   JDK_Version::jdk(9), JDK_Version::undefined(), JDK_Version::jdk(8) },
 574   { &quot;obs &gt; exp &quot;,                   JDK_Version::undefined(), JDK_Version::jdk(9), JDK_Version::jdk(8) },
 575   { &quot;obs &gt; exp&quot;,                    JDK_Version::jdk(8), JDK_Version::undefined(), JDK_Version::jdk(10) },
 576   { &quot;not deprecated or obsolete&quot;,   JDK_Version::undefined(), JDK_Version::undefined(), JDK_Version::jdk(9) },
 577   { &quot;dup option&quot;,                   JDK_Version::jdk(9), JDK_Version::undefined(), JDK_Version::undefined() },
 578   { &quot;dup option&quot;,                   JDK_Version::jdk(9), JDK_Version::undefined(), JDK_Version::undefined() },
 579 #endif
 580 
 581 #ifndef COMPILER2
 582   // These flags were generally available, but are C2 only, now.
 583   { &quot;MaxInlineLevel&quot;,               JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
 584   { &quot;MaxRecursiveInlineLevel&quot;,      JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
 585   { &quot;InlineSmallCode&quot;,              JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
 586   { &quot;MaxInlineSize&quot;,                JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
 587   { &quot;FreqInlineSize&quot;,               JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
 588   { &quot;MaxTrivialSize&quot;,               JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
 589 #endif
 590 
 591   { NULL, JDK_Version(0), JDK_Version(0) }
 592 };
 593 
 594 // Flags that are aliases for other flags.
 595 typedef struct {
 596   const char* alias_name;
 597   const char* real_name;
 598 } AliasedFlag;
 599 
 600 static AliasedFlag const aliased_jvm_flags[] = {
 601   { &quot;DefaultMaxRAMFraction&quot;,    &quot;MaxRAMFraction&quot;    },
 602   { &quot;CreateMinidumpOnCrash&quot;,    &quot;CreateCoredumpOnCrash&quot; },
 603   { NULL, NULL}
 604 };
 605 
 606 // NOTE: A compatibility request will be necessary for each alias to be removed.
 607 static AliasedLoggingFlag const aliased_logging_flags[] = {

 608   { &quot;PrintSharedSpaces&quot;,         LogLevel::Info,  true,  LOG_TAGS(cds) },
 609   { &quot;TraceBiasedLocking&quot;,        LogLevel::Info,  true,  LOG_TAGS(biasedlocking) },
 610   { &quot;TraceClassLoading&quot;,         LogLevel::Info,  true,  LOG_TAGS(class, load) },
 611   { &quot;TraceClassLoadingPreorder&quot;, LogLevel::Debug, true,  LOG_TAGS(class, preorder) },
 612   { &quot;TraceClassPaths&quot;,           LogLevel::Info,  true,  LOG_TAGS(class, path) },
 613   { &quot;TraceClassResolution&quot;,      LogLevel::Debug, true,  LOG_TAGS(class, resolve) },
 614   { &quot;TraceClassUnloading&quot;,       LogLevel::Info,  true,  LOG_TAGS(class, unload) },
 615   { &quot;TraceExceptions&quot;,           LogLevel::Info,  true,  LOG_TAGS(exceptions) },
 616   { &quot;TraceInvokeDynamic&quot;,        LogLevel::Debug, true,  LOG_TAGS(methodhandles, indy) },
 617   { &quot;TraceLoaderConstraints&quot;,    LogLevel::Info,  true,  LOG_TAGS(class, loader, constraints) },
 618   { &quot;TraceMethodHandles&quot;,        LogLevel::Info,  true,  LOG_TAGS(methodhandles) },
 619   { &quot;TraceMonitorInflation&quot;,     LogLevel::Trace, true,  LOG_TAGS(monitorinflation) },
 620   { &quot;TraceSafepointCleanupTime&quot;, LogLevel::Info,  true,  LOG_TAGS(safepoint, cleanup) },
 621   { &quot;TraceJVMTIObjectTagging&quot;,   LogLevel::Debug, true,  LOG_TAGS(jvmti, objecttagging) },
 622   { &quot;TraceRedefineClasses&quot;,      LogLevel::Info,  false, LOG_TAGS(redefine, class) },
 623   { &quot;PrintJNIResolving&quot;,         LogLevel::Debug, true,  LOG_TAGS(jni, resolve) },
 624   { NULL,                        LogLevel::Off,   false, LOG_TAGS(_NO_TAG) }
 625 };
 626 
 627 #ifndef PRODUCT
</pre>
<hr />
<pre>
2129                 TLABRefillWasteFraction);
2130     status = false;
2131   }
2132 
2133   if (PrintNMTStatistics) {
2134 #if INCLUDE_NMT
2135     if (MemTracker::tracking_level() == NMT_off) {
2136 #endif // INCLUDE_NMT
2137       warning(&quot;PrintNMTStatistics is disabled, because native memory tracking is not enabled&quot;);
2138       PrintNMTStatistics = false;
2139 #if INCLUDE_NMT
2140     }
2141 #endif
2142   }
2143 
2144   status = CompilerConfig::check_args_consistency(status);
2145 #if INCLUDE_JVMCI
2146   if (status &amp;&amp; EnableJVMCI) {
2147     PropertyList_unique_add(&amp;_system_properties, &quot;jdk.internal.vm.ci.enabled&quot;, &quot;true&quot;,
2148         AddProperty, UnwriteableProperty, InternalProperty);
<span class="line-modified">2149     if (!create_numbered_module_property(&quot;jdk.module.addmods&quot;, &quot;jdk.internal.vm.ci&quot;, addmods_count++)) {</span>
2150       return false;
2151     }
2152   }
2153 #endif
2154 
2155 #ifndef SUPPORT_RESERVED_STACK_AREA
2156   if (StackReservedPages != 0) {
2157     FLAG_SET_CMDLINE(StackReservedPages, 0);
2158     warning(&quot;Reserved Stack Area not supported on this platform&quot;);
2159   }
2160 #endif
2161 
2162   status = status &amp;&amp; GCArguments::check_args_consistency();
2163 
2164   return status;
2165 }
2166 
2167 bool Arguments::is_bad_option(const JavaVMOption* option, jboolean ignore,
2168   const char* option_type) {
2169   if (ignore) return false;
</pre>
<hr />
<pre>
2193 
2194   // Check the sign first since atojulong() parses only unsigned values.
2195   bool value_is_positive = !(*value == &#39;-&#39;);
2196 
2197   if (value_is_positive) {
2198     julong n;
2199     bool good_return = atojulong(value, &amp;n);
2200     if (good_return) {
2201       bool above_minimum = n &gt;= min_size;
2202       bool value_is_too_large = n &gt; max_uintx;
2203 
2204       if (above_minimum &amp;&amp; !value_is_too_large) {
2205         *uintx_arg = n;
2206         return true;
2207       }
2208     }
2209   }
2210   return false;
2211 }
2212 
<span class="line-modified">2213 bool Arguments::create_module_property(const char* prop_name, const char* prop_value, PropertyInternal internal) {</span>
<span class="line-added">2214   assert(is_internal_module_property(prop_name) ||</span>
<span class="line-added">2215          strcmp(prop_name, &quot;jdk.module.illegalAccess&quot;) == 0, &quot;unknown module property: &#39;%s&#39;&quot;, prop_name);</span>
2216   size_t prop_len = strlen(prop_name) + strlen(prop_value) + 2;
2217   char* property = AllocateHeap(prop_len, mtArguments);
2218   int ret = jio_snprintf(property, prop_len, &quot;%s=%s&quot;, prop_name, prop_value);
2219   if (ret &lt; 0 || ret &gt;= (int)prop_len) {
2220     FreeHeap(property);
2221     return false;
2222   }
<span class="line-modified">2223   // These are not strictly writeable properties as they cannot be set via -Dprop=val. But that</span>
<span class="line-added">2224   // is enforced by checking is_internal_module_property(). We need the property to be writeable so</span>
<span class="line-added">2225   // that multiple occurrences of the associated flag just causes the existing property value to be</span>
<span class="line-added">2226   // replaced (&quot;last option wins&quot;). Otherwise we would need to keep track of the flags and only convert</span>
<span class="line-added">2227   // to a property after we have finished flag processing.</span>
<span class="line-added">2228   bool added = add_property(property, WriteableProperty, internal);</span>
2229   FreeHeap(property);
2230   return added;
2231 }
2232 
<span class="line-modified">2233 bool Arguments::create_numbered_module_property(const char* prop_base_name, const char* prop_value, unsigned int count) {</span>
<span class="line-added">2234   assert(is_internal_module_property(prop_base_name), &quot;unknown module property: &#39;%s&#39;&quot;, prop_base_name);</span>
2235   const unsigned int props_count_limit = 1000;
2236   const int max_digits = 3;
2237   const int extra_symbols_count = 3; // includes &#39;.&#39;, &#39;=&#39;, &#39;\0&#39;
2238 
2239   // Make sure count is &lt; props_count_limit. Otherwise, memory allocation will be too small.
2240   if (count &lt; props_count_limit) {
2241     size_t prop_len = strlen(prop_base_name) + strlen(prop_value) + max_digits + extra_symbols_count;
2242     char* property = AllocateHeap(prop_len, mtArguments);
2243     int ret = jio_snprintf(property, prop_len, &quot;%s.%d=%s&quot;, prop_base_name, count, prop_value);
2244     if (ret &lt; 0 || ret &gt;= (int)prop_len) {
2245       FreeHeap(property);
2246       jio_fprintf(defaultStream::error_stream(), &quot;Failed to create property %s.%d=%s\n&quot;, prop_base_name, count, prop_value);
2247       return false;
2248     }
2249     bool added = add_property(property, UnwriteableProperty, InternalProperty);
2250     FreeHeap(property);
2251     return added;
2252   }
2253 
2254   jio_fprintf(defaultStream::error_stream(), &quot;Property count limit exceeded: %s, limit=%d\n&quot;, prop_base_name, props_count_limit);
</pre>
<hr />
<pre>
2376 }
2377 
2378 int Arguments::process_patch_mod_option(const char* patch_mod_tail, bool* patch_mod_javabase) {
2379   // --patch-module=&lt;module&gt;=&lt;file&gt;(&lt;pathsep&gt;&lt;file&gt;)*
2380   assert(patch_mod_tail != NULL, &quot;Unexpected NULL patch-module value&quot;);
2381   // Find the equal sign between the module name and the path specification
2382   const char* module_equal = strchr(patch_mod_tail, &#39;=&#39;);
2383   if (module_equal == NULL) {
2384     jio_fprintf(defaultStream::output_stream(), &quot;Missing &#39;=&#39; in --patch-module specification\n&quot;);
2385     return JNI_ERR;
2386   } else {
2387     // Pick out the module name
2388     size_t module_len = module_equal - patch_mod_tail;
2389     char* module_name = NEW_C_HEAP_ARRAY_RETURN_NULL(char, module_len+1, mtArguments);
2390     if (module_name != NULL) {
2391       memcpy(module_name, patch_mod_tail, module_len);
2392       *(module_name + module_len) = &#39;\0&#39;;
2393       // The path piece begins one past the module_equal sign
2394       add_patch_mod_prefix(module_name, module_equal + 1, patch_mod_javabase);
2395       FREE_C_HEAP_ARRAY(char, module_name);
<span class="line-modified">2396       if (!create_numbered_module_property(&quot;jdk.module.patch&quot;, patch_mod_tail, patch_mod_count++)) {</span>
2397         return JNI_ENOMEM;
2398       }
2399     } else {
2400       return JNI_ENOMEM;
2401     }
2402   }
2403   return JNI_OK;
2404 }
2405 
2406 // Parse -Xss memory string parameter and convert to ThreadStackSize in K.
2407 jint Arguments::parse_xss(const JavaVMOption* option, const char* tail, intx* out_ThreadStackSize) {
2408   // The min and max sizes match the values in globals.hpp, but scaled
2409   // with K. The values have been chosen so that alignment with page
2410   // size doesn&#39;t change the max value, which makes the conversions
2411   // back and forth between Xss value and ThreadStackSize value easier.
2412   // The values have also been chosen to fit inside a 32-bit signed type.
2413   const julong min_ThreadStackSize = 0;
2414   const julong max_ThreadStackSize = 1 * M;
2415 
2416   const julong min_size = min_ThreadStackSize * K;
</pre>
<hr />
<pre>
2521         const char* pos = strchr(tail, &#39;:&#39;);
2522         size_t len = (pos == NULL) ? strlen(tail) : pos - tail;
2523         char* name = NEW_C_HEAP_ARRAY(char, len + 1, mtArguments);
2524         jio_snprintf(name, len + 1, &quot;%s&quot;, tail);
2525 
2526         char *options = NULL;
2527         if(pos != NULL) {
2528           size_t len2 = strlen(pos+1) + 1; // options start after &#39;:&#39;.  Final zero must be copied.
2529           options = (char*)memcpy(NEW_C_HEAP_ARRAY(char, len2, mtArguments), pos+1, len2);
2530         }
2531 #if !INCLUDE_JVMTI
2532         if (strcmp(name, &quot;jdwp&quot;) == 0) {
2533           jio_fprintf(defaultStream::error_stream(),
2534             &quot;Debugging agents are not supported in this VM\n&quot;);
2535           return JNI_ERR;
2536         }
2537 #endif // !INCLUDE_JVMTI
2538         add_init_library(name, options);
2539       }
2540     } else if (match_option(option, &quot;--add-reads=&quot;, &amp;tail)) {
<span class="line-modified">2541       if (!create_numbered_module_property(&quot;jdk.module.addreads&quot;, tail, addreads_count++)) {</span>
2542         return JNI_ENOMEM;
2543       }
2544     } else if (match_option(option, &quot;--add-exports=&quot;, &amp;tail)) {
<span class="line-modified">2545       if (!create_numbered_module_property(&quot;jdk.module.addexports&quot;, tail, addexports_count++)) {</span>
2546         return JNI_ENOMEM;
2547       }
2548     } else if (match_option(option, &quot;--add-opens=&quot;, &amp;tail)) {
<span class="line-modified">2549       if (!create_numbered_module_property(&quot;jdk.module.addopens&quot;, tail, addopens_count++)) {</span>
2550         return JNI_ENOMEM;
2551       }
2552     } else if (match_option(option, &quot;--add-modules=&quot;, &amp;tail)) {
<span class="line-modified">2553       if (!create_numbered_module_property(&quot;jdk.module.addmods&quot;, tail, addmods_count++)) {</span>
2554         return JNI_ENOMEM;
2555       }
2556     } else if (match_option(option, &quot;--limit-modules=&quot;, &amp;tail)) {
<span class="line-modified">2557       if (!create_module_property(&quot;jdk.module.limitmods&quot;, tail, InternalProperty)) {</span>
2558         return JNI_ENOMEM;
2559       }
2560     } else if (match_option(option, &quot;--module-path=&quot;, &amp;tail)) {
<span class="line-modified">2561       if (!create_module_property(&quot;jdk.module.path&quot;, tail, ExternalProperty)) {</span>
2562         return JNI_ENOMEM;
2563       }
2564     } else if (match_option(option, &quot;--upgrade-module-path=&quot;, &amp;tail)) {
<span class="line-modified">2565       if (!create_module_property(&quot;jdk.module.upgrade.path&quot;, tail, ExternalProperty)) {</span>
2566         return JNI_ENOMEM;
2567       }
2568     } else if (match_option(option, &quot;--patch-module=&quot;, &amp;tail)) {
2569       // --patch-module=&lt;module&gt;=&lt;file&gt;(&lt;pathsep&gt;&lt;file&gt;)*
2570       int res = process_patch_mod_option(tail, patch_mod_javabase);
2571       if (res != JNI_OK) {
2572         return res;
2573       }
2574     } else if (match_option(option, &quot;--illegal-access=&quot;, &amp;tail)) {
<span class="line-modified">2575       if (!create_module_property(&quot;jdk.module.illegalAccess&quot;, tail, ExternalProperty)) {</span>
2576         return JNI_ENOMEM;
2577       }
2578     // -agentlib and -agentpath
2579     } else if (match_option(option, &quot;-agentlib:&quot;, &amp;tail) ||
2580           (is_absolute_path = match_option(option, &quot;-agentpath:&quot;, &amp;tail))) {
2581       if(tail != NULL) {
2582         const char* pos = strchr(tail, &#39;=&#39;);
2583         char* name;
2584         if (pos == NULL) {
2585           name = os::strdup_check_oom(tail, mtArguments);
2586         } else {
2587           size_t len = pos - tail;
2588           name = NEW_C_HEAP_ARRAY(char, len + 1, mtArguments);
2589           memcpy(name, tail, len);
2590           name[len] = &#39;\0&#39;;
2591         }
2592 
2593         char *options = NULL;
2594         if(pos != NULL) {
2595           options = os::strdup_check_oom(pos + 1, mtArguments);
</pre>
<hr />
<pre>
2599           jio_fprintf(defaultStream::error_stream(),
2600             &quot;Debugging agents are not supported in this VM\n&quot;);
2601           return JNI_ERR;
2602         }
2603 #endif // !INCLUDE_JVMTI
2604         add_init_agent(name, options, is_absolute_path);
2605       }
2606     // -javaagent
2607     } else if (match_option(option, &quot;-javaagent:&quot;, &amp;tail)) {
2608 #if !INCLUDE_JVMTI
2609       jio_fprintf(defaultStream::error_stream(),
2610         &quot;Instrumentation agents are not supported in this VM\n&quot;);
2611       return JNI_ERR;
2612 #else
2613       if (tail != NULL) {
2614         size_t length = strlen(tail) + 1;
2615         char *options = NEW_C_HEAP_ARRAY(char, length, mtArguments);
2616         jio_snprintf(options, length, &quot;%s&quot;, tail);
2617         add_instrument_agent(&quot;instrument&quot;, options, false);
2618         // java agents need module java.instrument
<span class="line-modified">2619         if (!create_numbered_module_property(&quot;jdk.module.addmods&quot;, &quot;java.instrument&quot;, addmods_count++)) {</span>
2620           return JNI_ENOMEM;
2621         }
2622       }
2623 #endif // !INCLUDE_JVMTI
2624     // --enable_preview
2625     } else if (match_option(option, &quot;--enable-preview&quot;)) {
2626       set_enable_preview();
2627     // -Xnoclassgc
2628     } else if (match_option(option, &quot;-Xnoclassgc&quot;)) {
2629       if (FLAG_SET_CMDLINE(ClassUnloading, false) != JVMFlag::SUCCESS) {
2630         return JNI_EINVAL;
2631       }
2632     // -Xbatch
2633     } else if (match_option(option, &quot;-Xbatch&quot;)) {
2634       if (FLAG_SET_CMDLINE(BackgroundCompilation, false) != JVMFlag::SUCCESS) {
2635         return JNI_EINVAL;
2636       }
2637     // -Xmn for compatibility with other JVM vendors
2638     } else if (match_option(option, &quot;-Xmn&quot;, &amp;tail)) {
2639       julong long_initial_young_size = 0;
</pre>
<hr />
<pre>
2780           &quot;-Djava.ext.dirs=%s is not supported.  Use -classpath instead.\n&quot;, value);
2781         return JNI_EINVAL;
2782       }
2783       // Check for module related properties.  They must be set using the modules
2784       // options. For example: use &quot;--add-modules=java.sql&quot;, not
2785       // &quot;-Djdk.module.addmods=java.sql&quot;
2786       if (is_internal_module_property(option-&gt;optionString + 2)) {
2787         needs_module_property_warning = true;
2788         continue;
2789       }
2790       if (!add_property(tail)) {
2791         return JNI_ENOMEM;
2792       }
2793       // Out of the box management support
2794       if (match_option(option, &quot;-Dcom.sun.management&quot;, &amp;tail)) {
2795 #if INCLUDE_MANAGEMENT
2796         if (FLAG_SET_CMDLINE(ManagementServer, true) != JVMFlag::SUCCESS) {
2797           return JNI_EINVAL;
2798         }
2799         // management agent in module jdk.management.agent
<span class="line-modified">2800         if (!create_numbered_module_property(&quot;jdk.module.addmods&quot;, &quot;jdk.management.agent&quot;, addmods_count++)) {</span>
2801           return JNI_ENOMEM;
2802         }
2803 #else
2804         jio_fprintf(defaultStream::output_stream(),
2805           &quot;-Dcom.sun.management is not supported in this VM.\n&quot;);
2806         return JNI_ERR;
2807 #endif
2808       }
2809     // -Xint
2810     } else if (match_option(option, &quot;-Xint&quot;)) {
2811           set_mode_flags(_int);
2812     // -Xmixed
2813     } else if (match_option(option, &quot;-Xmixed&quot;)) {
2814           set_mode_flags(_mixed);
2815     // -Xcomp
2816     } else if (match_option(option, &quot;-Xcomp&quot;)) {
2817       // for testing the compiler; turn off all flags that inhibit compilation
2818           set_mode_flags(_comp);
2819     // -Xshare:dump
2820     } else if (match_option(option, &quot;-Xshare:dump&quot;)) {
</pre>
<hr />
<pre>
4307 void Arguments::PropertyList_add(SystemProperty** plist, const char* k, const char* v,
4308                                  bool writeable, bool internal) {
4309   if (plist == NULL)
4310     return;
4311 
4312   SystemProperty* new_p = new SystemProperty(k, v, writeable, internal);
4313   PropertyList_add(plist, new_p);
4314 }
4315 
4316 void Arguments::PropertyList_add(SystemProperty *element) {
4317   PropertyList_add(&amp;_system_properties, element);
4318 }
4319 
4320 // This add maintains unique property key in the list.
4321 void Arguments::PropertyList_unique_add(SystemProperty** plist, const char* k, const char* v,
4322                                         PropertyAppendable append, PropertyWriteable writeable,
4323                                         PropertyInternal internal) {
4324   if (plist == NULL)
4325     return;
4326 
<span class="line-modified">4327   // If property key exists and is writeable, then update with new value.</span>
<span class="line-added">4328   // Trying to update a non-writeable property is silently ignored.</span>
4329   SystemProperty* prop;
4330   for (prop = *plist; prop != NULL; prop = prop-&gt;next()) {
4331     if (strcmp(k, prop-&gt;key()) == 0) {
4332       if (append == AppendProperty) {
<span class="line-modified">4333         prop-&gt;append_writeable_value(v);</span>
4334       } else {
<span class="line-modified">4335         prop-&gt;set_writeable_value(v);</span>
4336       }
4337       return;
4338     }
4339   }
4340 
4341   PropertyList_add(plist, k, v, writeable == WriteableProperty, internal == InternalProperty);
4342 }
4343 
4344 // Copies src into buf, replacing &quot;%%&quot; with &quot;%&quot; and &quot;%p&quot; with pid
4345 // Returns true if all of the source pointed by src has been copied over to
4346 // the destination buffer pointed by buf. Otherwise, returns false.
4347 // Notes:
4348 // 1. If the length (buflen) of the destination buffer excluding the
4349 // NULL terminator character is not long enough for holding the expanded
4350 // pid characters, it also returns false instead of returning the partially
4351 // expanded one.
4352 // 2. The passed in &quot;buflen&quot; should be large enough to hold the null terminator.
4353 bool Arguments::copy_expand_pid(const char* src, size_t srclen,
4354                                 char* buf, size_t buflen) {
4355   const char* p = src;
</pre>
</td>
</tr>
</table>
<center><a href="../prims/jvm.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="arguments.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
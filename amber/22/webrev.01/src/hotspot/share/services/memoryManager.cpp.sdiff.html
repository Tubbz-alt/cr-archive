<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/services/memoryManager.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../runtime/vmStructs.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="memoryManager.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/services/memoryManager.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/systemDictionary.hpp&quot;
 27 #include &quot;classfile/vmSymbols.hpp&quot;
 28 #include &quot;memory/allocation.inline.hpp&quot;
 29 #include &quot;oops/oop.inline.hpp&quot;
 30 #include &quot;runtime/atomic.hpp&quot;
 31 #include &quot;runtime/handles.inline.hpp&quot;
 32 #include &quot;runtime/javaCalls.hpp&quot;
 33 #include &quot;services/lowMemoryDetector.hpp&quot;
 34 #include &quot;services/management.hpp&quot;
 35 #include &quot;services/memoryManager.hpp&quot;
 36 #include &quot;services/memoryPool.hpp&quot;
 37 #include &quot;services/memoryService.hpp&quot;
 38 #include &quot;services/gcNotifier.hpp&quot;
 39 #include &quot;utilities/dtrace.hpp&quot;
 40 
<span class="line-modified"> 41 MemoryManager::MemoryManager(const char* name) : _name(name) {</span>
<span class="line-modified"> 42   _num_pools = 0;</span>
<span class="line-removed"> 43   (void)const_cast&lt;instanceOop&amp;&gt;(_memory_mgr_obj = instanceOop(NULL));</span>
<span class="line-removed"> 44 }</span>
 45 
 46 int MemoryManager::add_pool(MemoryPool* pool) {
 47   int index = _num_pools;
 48   assert(index &lt; MemoryManager::max_num_pools, &quot;_num_pools exceeds the max&quot;);
 49   if (index &lt; MemoryManager::max_num_pools) {
 50     _pools[index] = pool;
 51     _num_pools++;
 52   }
 53   pool-&gt;add_manager(this);
 54   return index;
 55 }
 56 




 57 MemoryManager* MemoryManager::get_code_cache_memory_manager() {
 58   return new MemoryManager(&quot;CodeCacheManager&quot;);
 59 }
 60 
 61 MemoryManager* MemoryManager::get_metaspace_memory_manager() {
 62   return new MemoryManager(&quot;Metaspace Manager&quot;);
 63 }
 64 
 65 instanceOop MemoryManager::get_memory_manager_instance(TRAPS) {
 66   // Must do an acquire so as to force ordering of subsequent
 67   // loads from anything _memory_mgr_obj points to or implies.
 68   instanceOop mgr_obj = Atomic::load_acquire(&amp;_memory_mgr_obj);
 69   if (mgr_obj == NULL) {
 70     // It&#39;s ok for more than one thread to execute the code up to the locked region.
 71     // Extra manager instances will just be gc&#39;ed.
 72     Klass* k = Management::sun_management_ManagementFactoryHelper_klass(CHECK_NULL);
 73 
 74     Handle mgr_name = java_lang_String::create_from_str(name(), CHECK_NULL);
 75 
 76     JavaValue result(T_OBJECT);
</pre>
</td>
<td>
<hr />
<pre>
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/systemDictionary.hpp&quot;
 27 #include &quot;classfile/vmSymbols.hpp&quot;
 28 #include &quot;memory/allocation.inline.hpp&quot;
 29 #include &quot;oops/oop.inline.hpp&quot;
 30 #include &quot;runtime/atomic.hpp&quot;
 31 #include &quot;runtime/handles.inline.hpp&quot;
 32 #include &quot;runtime/javaCalls.hpp&quot;
 33 #include &quot;services/lowMemoryDetector.hpp&quot;
 34 #include &quot;services/management.hpp&quot;
 35 #include &quot;services/memoryManager.hpp&quot;
 36 #include &quot;services/memoryPool.hpp&quot;
 37 #include &quot;services/memoryService.hpp&quot;
 38 #include &quot;services/gcNotifier.hpp&quot;
 39 #include &quot;utilities/dtrace.hpp&quot;
 40 
<span class="line-modified"> 41 MemoryManager::MemoryManager(const char* name) :</span>
<span class="line-modified"> 42   _num_pools(0), _name(name), _memory_mgr_obj() {}</span>


 43 
 44 int MemoryManager::add_pool(MemoryPool* pool) {
 45   int index = _num_pools;
 46   assert(index &lt; MemoryManager::max_num_pools, &quot;_num_pools exceeds the max&quot;);
 47   if (index &lt; MemoryManager::max_num_pools) {
 48     _pools[index] = pool;
 49     _num_pools++;
 50   }
 51   pool-&gt;add_manager(this);
 52   return index;
 53 }
 54 
<span class="line-added"> 55 bool MemoryManager::is_manager(instanceHandle mh) const {</span>
<span class="line-added"> 56   return mh() == Atomic::load(&amp;_memory_mgr_obj);</span>
<span class="line-added"> 57 }</span>
<span class="line-added"> 58 </span>
 59 MemoryManager* MemoryManager::get_code_cache_memory_manager() {
 60   return new MemoryManager(&quot;CodeCacheManager&quot;);
 61 }
 62 
 63 MemoryManager* MemoryManager::get_metaspace_memory_manager() {
 64   return new MemoryManager(&quot;Metaspace Manager&quot;);
 65 }
 66 
 67 instanceOop MemoryManager::get_memory_manager_instance(TRAPS) {
 68   // Must do an acquire so as to force ordering of subsequent
 69   // loads from anything _memory_mgr_obj points to or implies.
 70   instanceOop mgr_obj = Atomic::load_acquire(&amp;_memory_mgr_obj);
 71   if (mgr_obj == NULL) {
 72     // It&#39;s ok for more than one thread to execute the code up to the locked region.
 73     // Extra manager instances will just be gc&#39;ed.
 74     Klass* k = Management::sun_management_ManagementFactoryHelper_klass(CHECK_NULL);
 75 
 76     Handle mgr_name = java_lang_String::create_from_str(name(), CHECK_NULL);
 77 
 78     JavaValue result(T_OBJECT);
</pre>
</td>
</tr>
</table>
<center><a href="../runtime/vmStructs.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="memoryManager.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
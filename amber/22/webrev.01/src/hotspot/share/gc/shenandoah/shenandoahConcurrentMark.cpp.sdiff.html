<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/shenandoahConcurrentMark.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahCollectionSet.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahEvacOOMHandler.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahConcurrentMark.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 67 public:
 68   ShenandoahInitMarkRootsClosure(ShenandoahObjToScanQueue* q) :
 69     _queue(q),
 70     _heap(ShenandoahHeap::heap()),
 71     _mark_context(_heap-&gt;marking_context()) {};
 72 
 73   void do_oop(narrowOop* p) { do_oop_work(p); }
 74   void do_oop(oop* p)       { do_oop_work(p); }
 75 };
 76 
 77 ShenandoahMarkRefsSuperClosure::ShenandoahMarkRefsSuperClosure(ShenandoahObjToScanQueue* q, ReferenceProcessor* rp) :
 78   MetadataVisitingOopIterateClosure(rp),
 79   _queue(q),
 80   _heap(ShenandoahHeap::heap()),
 81   _mark_context(_heap-&gt;marking_context())
 82 { }
 83 
 84 template&lt;UpdateRefsMode UPDATE_REFS&gt;
 85 class ShenandoahInitMarkRootsTask : public AbstractGangTask {
 86 private:
<span class="line-modified"> 87   ShenandoahAllRootScanner* _rp;</span>
 88 public:
<span class="line-modified"> 89   ShenandoahInitMarkRootsTask(ShenandoahAllRootScanner* rp) :</span>
 90     AbstractGangTask(&quot;Shenandoah init mark roots task&quot;),
 91     _rp(rp) {
 92   }
 93 
 94   void work(uint worker_id) {
 95     assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
 96     ShenandoahParallelWorkerSession worker_session(worker_id);
 97 
 98     ShenandoahHeap* heap = ShenandoahHeap::heap();
 99     ShenandoahObjToScanQueueSet* queues = heap-&gt;concurrent_mark()-&gt;task_queues();
100     assert(queues-&gt;get_reserved() &gt; worker_id, &quot;Queue has not been reserved for worker id: %d&quot;, worker_id);
101 
102     ShenandoahObjToScanQueue* q = queues-&gt;queue(worker_id);
103 
104     ShenandoahInitMarkRootsClosure&lt;UPDATE_REFS&gt; mark_cl(q);
105     do_work(heap, &amp;mark_cl, worker_id);
106   }
107 
108 private:
109   void do_work(ShenandoahHeap* heap, OopClosure* oops, uint worker_id) {
</pre>
<hr />
<pre>
277                    false, // not cancellable
278                    _dedup_string);
279 
280     assert(_cm-&gt;task_queues()-&gt;is_empty(), &quot;Should be empty&quot;);
281   }
282 };
283 
284 void ShenandoahConcurrentMark::mark_roots(ShenandoahPhaseTimings::Phase root_phase) {
285   assert(Thread::current()-&gt;is_VM_thread(), &quot;can only do this in VMThread&quot;);
286   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
287 
288   ShenandoahHeap* heap = ShenandoahHeap::heap();
289 
290   ShenandoahGCPhase phase(root_phase);
291 
292   WorkGang* workers = heap-&gt;workers();
293   uint nworkers = workers-&gt;active_workers();
294 
295   assert(nworkers &lt;= task_queues()-&gt;size(), &quot;Just check&quot;);
296 
<span class="line-modified">297   ShenandoahAllRootScanner root_proc(nworkers, root_phase);</span>
298   TASKQUEUE_STATS_ONLY(task_queues()-&gt;reset_taskqueue_stats());
299   task_queues()-&gt;reserve(nworkers);
300 
301   if (heap-&gt;has_forwarded_objects()) {
302     ShenandoahInitMarkRootsTask&lt;RESOLVE&gt; mark_roots(&amp;root_proc);
303     workers-&gt;run_task(&amp;mark_roots);
304   } else {
305     // No need to update references, which means the heap is stable.
306     // Can save time not walking through forwarding pointers.
307     ShenandoahInitMarkRootsTask&lt;NONE&gt; mark_roots(&amp;root_proc);
308     workers-&gt;run_task(&amp;mark_roots);
309   }
310 
<span class="line-modified">311   if (ShenandoahConcurrentScanCodeRoots) {</span>
<span class="line-removed">312     clear_claim_codecache();</span>
<span class="line-removed">313   }</span>
314 }
315 
316 void ShenandoahConcurrentMark::update_roots(ShenandoahPhaseTimings::Phase root_phase) {
317   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
318   assert(root_phase == ShenandoahPhaseTimings::full_gc_update_roots ||
319          root_phase == ShenandoahPhaseTimings::degen_gc_update_roots,
320          &quot;Only for these phases&quot;);
321 
322   ShenandoahGCPhase phase(root_phase);
323 
324   bool check_alive = root_phase == ShenandoahPhaseTimings::degen_gc_update_roots;
325 
326 #if COMPILER2_OR_JVMCI
327   DerivedPointerTable::clear();
328 #endif
329 
330   uint nworkers = _heap-&gt;workers()-&gt;active_workers();
331 
332   ShenandoahRootUpdater root_updater(nworkers, root_phase);
333   ShenandoahUpdateRootsTask update_roots(&amp;root_updater, check_alive);
</pre>
<hr />
<pre>
375 #if COMPILER2_OR_JVMCI
376   DerivedPointerTable::update_pointers();
377 #endif
378 }
379 
380 void ShenandoahConcurrentMark::initialize(uint workers) {
381   _heap = ShenandoahHeap::heap();
382 
383   uint num_queues = MAX2(workers, 1U);
384 
385   _task_queues = new ShenandoahObjToScanQueueSet((int) num_queues);
386 
387   for (uint i = 0; i &lt; num_queues; ++i) {
388     ShenandoahObjToScanQueue* task_queue = new ShenandoahObjToScanQueue();
389     task_queue-&gt;initialize();
390     _task_queues-&gt;register_queue(i, task_queue);
391   }
392 }
393 
394 void ShenandoahConcurrentMark::concurrent_scan_code_roots(uint worker_id, ReferenceProcessor* rp) {
<span class="line-modified">395   if (ShenandoahConcurrentScanCodeRoots &amp;&amp; claim_codecache()) {</span>
396     ShenandoahObjToScanQueue* q = task_queues()-&gt;queue(worker_id);
397     if (!_heap-&gt;unload_classes()) {
398       MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
399       // TODO: We can not honor StringDeduplication here, due to lock ranking
400       // inversion. So, we may miss some deduplication candidates.
401       if (_heap-&gt;has_forwarded_objects()) {
402         ShenandoahMarkResolveRefsClosure cl(q, rp);
403         CodeBlobToOopClosure blobs(&amp;cl, !CodeBlobToOopClosure::FixRelocations);
404         CodeCache::blobs_do(&amp;blobs);
405       } else {
406         ShenandoahMarkRefsClosure cl(q, rp);
407         CodeBlobToOopClosure blobs(&amp;cl, !CodeBlobToOopClosure::FixRelocations);
408         CodeCache::blobs_do(&amp;blobs);
409       }
410     }
411   }
412 }
413 
414 void ShenandoahConcurrentMark::mark_from_roots() {
415   WorkGang* workers = _heap-&gt;workers();
</pre>
<hr />
<pre>
926       if (q-&gt;pop(t) ||
927           queues-&gt;steal(worker_id, t)) {
928         do_task&lt;T&gt;(q, cl, live_data, &amp;t);
929         work++;
930       } else {
931         break;
932       }
933     }
934 
935     if (work == 0) {
936       // No work encountered in current stride, try to terminate.
937       // Need to leave the STS here otherwise it might block safepoints.
938       ShenandoahSuspendibleThreadSetLeaver stsl(CANCELLABLE &amp;&amp; ShenandoahSuspendibleWorkers);
939       ShenandoahTerminatorTerminator tt(heap);
940       if (terminator-&gt;offer_termination(&amp;tt)) return;
941     }
942   }
943 }
944 
945 bool ShenandoahConcurrentMark::claim_codecache() {
<span class="line-removed">946   assert(ShenandoahConcurrentScanCodeRoots, &quot;must not be called otherwise&quot;);</span>
947   return _claimed_codecache.try_set();
948 }
949 
950 void ShenandoahConcurrentMark::clear_claim_codecache() {
<span class="line-removed">951   assert(ShenandoahConcurrentScanCodeRoots, &quot;must not be called otherwise&quot;);</span>
952   _claimed_codecache.unset();
953 }
</pre>
</td>
<td>
<hr />
<pre>
 67 public:
 68   ShenandoahInitMarkRootsClosure(ShenandoahObjToScanQueue* q) :
 69     _queue(q),
 70     _heap(ShenandoahHeap::heap()),
 71     _mark_context(_heap-&gt;marking_context()) {};
 72 
 73   void do_oop(narrowOop* p) { do_oop_work(p); }
 74   void do_oop(oop* p)       { do_oop_work(p); }
 75 };
 76 
 77 ShenandoahMarkRefsSuperClosure::ShenandoahMarkRefsSuperClosure(ShenandoahObjToScanQueue* q, ReferenceProcessor* rp) :
 78   MetadataVisitingOopIterateClosure(rp),
 79   _queue(q),
 80   _heap(ShenandoahHeap::heap()),
 81   _mark_context(_heap-&gt;marking_context())
 82 { }
 83 
 84 template&lt;UpdateRefsMode UPDATE_REFS&gt;
 85 class ShenandoahInitMarkRootsTask : public AbstractGangTask {
 86 private:
<span class="line-modified"> 87   ShenandoahRootScanner* _rp;</span>
 88 public:
<span class="line-modified"> 89   ShenandoahInitMarkRootsTask(ShenandoahRootScanner* rp) :</span>
 90     AbstractGangTask(&quot;Shenandoah init mark roots task&quot;),
 91     _rp(rp) {
 92   }
 93 
 94   void work(uint worker_id) {
 95     assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
 96     ShenandoahParallelWorkerSession worker_session(worker_id);
 97 
 98     ShenandoahHeap* heap = ShenandoahHeap::heap();
 99     ShenandoahObjToScanQueueSet* queues = heap-&gt;concurrent_mark()-&gt;task_queues();
100     assert(queues-&gt;get_reserved() &gt; worker_id, &quot;Queue has not been reserved for worker id: %d&quot;, worker_id);
101 
102     ShenandoahObjToScanQueue* q = queues-&gt;queue(worker_id);
103 
104     ShenandoahInitMarkRootsClosure&lt;UPDATE_REFS&gt; mark_cl(q);
105     do_work(heap, &amp;mark_cl, worker_id);
106   }
107 
108 private:
109   void do_work(ShenandoahHeap* heap, OopClosure* oops, uint worker_id) {
</pre>
<hr />
<pre>
277                    false, // not cancellable
278                    _dedup_string);
279 
280     assert(_cm-&gt;task_queues()-&gt;is_empty(), &quot;Should be empty&quot;);
281   }
282 };
283 
284 void ShenandoahConcurrentMark::mark_roots(ShenandoahPhaseTimings::Phase root_phase) {
285   assert(Thread::current()-&gt;is_VM_thread(), &quot;can only do this in VMThread&quot;);
286   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
287 
288   ShenandoahHeap* heap = ShenandoahHeap::heap();
289 
290   ShenandoahGCPhase phase(root_phase);
291 
292   WorkGang* workers = heap-&gt;workers();
293   uint nworkers = workers-&gt;active_workers();
294 
295   assert(nworkers &lt;= task_queues()-&gt;size(), &quot;Just check&quot;);
296 
<span class="line-modified">297   ShenandoahRootScanner root_proc(nworkers, root_phase);</span>
298   TASKQUEUE_STATS_ONLY(task_queues()-&gt;reset_taskqueue_stats());
299   task_queues()-&gt;reserve(nworkers);
300 
301   if (heap-&gt;has_forwarded_objects()) {
302     ShenandoahInitMarkRootsTask&lt;RESOLVE&gt; mark_roots(&amp;root_proc);
303     workers-&gt;run_task(&amp;mark_roots);
304   } else {
305     // No need to update references, which means the heap is stable.
306     // Can save time not walking through forwarding pointers.
307     ShenandoahInitMarkRootsTask&lt;NONE&gt; mark_roots(&amp;root_proc);
308     workers-&gt;run_task(&amp;mark_roots);
309   }
310 
<span class="line-modified">311   clear_claim_codecache();</span>


312 }
313 
314 void ShenandoahConcurrentMark::update_roots(ShenandoahPhaseTimings::Phase root_phase) {
315   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
316   assert(root_phase == ShenandoahPhaseTimings::full_gc_update_roots ||
317          root_phase == ShenandoahPhaseTimings::degen_gc_update_roots,
318          &quot;Only for these phases&quot;);
319 
320   ShenandoahGCPhase phase(root_phase);
321 
322   bool check_alive = root_phase == ShenandoahPhaseTimings::degen_gc_update_roots;
323 
324 #if COMPILER2_OR_JVMCI
325   DerivedPointerTable::clear();
326 #endif
327 
328   uint nworkers = _heap-&gt;workers()-&gt;active_workers();
329 
330   ShenandoahRootUpdater root_updater(nworkers, root_phase);
331   ShenandoahUpdateRootsTask update_roots(&amp;root_updater, check_alive);
</pre>
<hr />
<pre>
373 #if COMPILER2_OR_JVMCI
374   DerivedPointerTable::update_pointers();
375 #endif
376 }
377 
378 void ShenandoahConcurrentMark::initialize(uint workers) {
379   _heap = ShenandoahHeap::heap();
380 
381   uint num_queues = MAX2(workers, 1U);
382 
383   _task_queues = new ShenandoahObjToScanQueueSet((int) num_queues);
384 
385   for (uint i = 0; i &lt; num_queues; ++i) {
386     ShenandoahObjToScanQueue* task_queue = new ShenandoahObjToScanQueue();
387     task_queue-&gt;initialize();
388     _task_queues-&gt;register_queue(i, task_queue);
389   }
390 }
391 
392 void ShenandoahConcurrentMark::concurrent_scan_code_roots(uint worker_id, ReferenceProcessor* rp) {
<span class="line-modified">393   if (claim_codecache()) {</span>
394     ShenandoahObjToScanQueue* q = task_queues()-&gt;queue(worker_id);
395     if (!_heap-&gt;unload_classes()) {
396       MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
397       // TODO: We can not honor StringDeduplication here, due to lock ranking
398       // inversion. So, we may miss some deduplication candidates.
399       if (_heap-&gt;has_forwarded_objects()) {
400         ShenandoahMarkResolveRefsClosure cl(q, rp);
401         CodeBlobToOopClosure blobs(&amp;cl, !CodeBlobToOopClosure::FixRelocations);
402         CodeCache::blobs_do(&amp;blobs);
403       } else {
404         ShenandoahMarkRefsClosure cl(q, rp);
405         CodeBlobToOopClosure blobs(&amp;cl, !CodeBlobToOopClosure::FixRelocations);
406         CodeCache::blobs_do(&amp;blobs);
407       }
408     }
409   }
410 }
411 
412 void ShenandoahConcurrentMark::mark_from_roots() {
413   WorkGang* workers = _heap-&gt;workers();
</pre>
<hr />
<pre>
924       if (q-&gt;pop(t) ||
925           queues-&gt;steal(worker_id, t)) {
926         do_task&lt;T&gt;(q, cl, live_data, &amp;t);
927         work++;
928       } else {
929         break;
930       }
931     }
932 
933     if (work == 0) {
934       // No work encountered in current stride, try to terminate.
935       // Need to leave the STS here otherwise it might block safepoints.
936       ShenandoahSuspendibleThreadSetLeaver stsl(CANCELLABLE &amp;&amp; ShenandoahSuspendibleWorkers);
937       ShenandoahTerminatorTerminator tt(heap);
938       if (terminator-&gt;offer_termination(&amp;tt)) return;
939     }
940   }
941 }
942 
943 bool ShenandoahConcurrentMark::claim_codecache() {

944   return _claimed_codecache.try_set();
945 }
946 
947 void ShenandoahConcurrentMark::clear_claim_codecache() {

948   _claimed_codecache.unset();
949 }
</pre>
</td>
</tr>
</table>
<center><a href="shenandoahCollectionSet.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahEvacOOMHandler.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/shenandoah/c2/shenandoahSupport.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2015, 2019, Red Hat, Inc. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 
  27 #include &quot;gc/shenandoah/c2/shenandoahSupport.hpp&quot;
  28 #include &quot;gc/shenandoah/c2/shenandoahBarrierSetC2.hpp&quot;
  29 #include &quot;gc/shenandoah/shenandoahBarrierSetAssembler.hpp&quot;
  30 #include &quot;gc/shenandoah/shenandoahForwarding.hpp&quot;
  31 #include &quot;gc/shenandoah/shenandoahHeap.hpp&quot;
  32 #include &quot;gc/shenandoah/shenandoahHeapRegion.hpp&quot;
  33 #include &quot;gc/shenandoah/shenandoahRuntime.hpp&quot;
  34 #include &quot;gc/shenandoah/shenandoahThreadLocalData.hpp&quot;
  35 #include &quot;opto/arraycopynode.hpp&quot;
  36 #include &quot;opto/block.hpp&quot;
  37 #include &quot;opto/callnode.hpp&quot;
  38 #include &quot;opto/castnode.hpp&quot;
  39 #include &quot;opto/movenode.hpp&quot;
  40 #include &quot;opto/phaseX.hpp&quot;
  41 #include &quot;opto/rootnode.hpp&quot;
  42 #include &quot;opto/runtime.hpp&quot;
  43 #include &quot;opto/subnode.hpp&quot;
  44 
  45 bool ShenandoahBarrierC2Support::expand(Compile* C, PhaseIterGVN&amp; igvn) {
  46   ShenandoahBarrierSetC2State* state = ShenandoahBarrierSetC2::bsc2()-&gt;state();
  47   if ((state-&gt;enqueue_barriers_count() +
  48        state-&gt;load_reference_barriers_count()) &gt; 0) {
  49     bool attempt_more_loopopts = ShenandoahLoopOptsAfterExpansion;
  50     C-&gt;clear_major_progress();
  51     PhaseIdealLoop ideal_loop(igvn, LoopOptsShenandoahExpand);
  52     if (C-&gt;failing()) return false;
  53     PhaseIdealLoop::verify(igvn);
  54     DEBUG_ONLY(verify_raw_mem(C-&gt;root());)
  55     if (attempt_more_loopopts) {
  56       C-&gt;set_major_progress();
  57       if (!C-&gt;optimize_loops(igvn, LoopOptsShenandoahPostExpand)) {
  58         return false;
  59       }
  60       C-&gt;clear_major_progress();
  61       if (C-&gt;range_check_cast_count() &gt; 0) {
  62         // No more loop optimizations. Remove all range check dependent CastIINodes.
  63         C-&gt;remove_range_check_casts(igvn);
  64         igvn.optimize();
  65       }
  66     }
  67   }
  68   return true;
  69 }
  70 
  71 bool ShenandoahBarrierC2Support::is_gc_state_test(Node* iff, int mask) {
  72   if (!UseShenandoahGC) {
  73     return false;
  74   }
  75   assert(iff-&gt;is_If(), &quot;bad input&quot;);
  76   if (iff-&gt;Opcode() != Op_If) {
  77     return false;
  78   }
  79   Node* bol = iff-&gt;in(1);
  80   if (!bol-&gt;is_Bool() || bol-&gt;as_Bool()-&gt;_test._test != BoolTest::ne) {
  81     return false;
  82   }
  83   Node* cmp = bol-&gt;in(1);
  84   if (cmp-&gt;Opcode() != Op_CmpI) {
  85     return false;
  86   }
  87   Node* in1 = cmp-&gt;in(1);
  88   Node* in2 = cmp-&gt;in(2);
  89   if (in2-&gt;find_int_con(-1) != 0) {
  90     return false;
  91   }
  92   if (in1-&gt;Opcode() != Op_AndI) {
  93     return false;
  94   }
  95   in2 = in1-&gt;in(2);
  96   if (in2-&gt;find_int_con(-1) != mask) {
  97     return false;
  98   }
  99   in1 = in1-&gt;in(1);
 100 
 101   return is_gc_state_load(in1);
 102 }
 103 
 104 bool ShenandoahBarrierC2Support::is_heap_stable_test(Node* iff) {
 105   return is_gc_state_test(iff, ShenandoahHeap::HAS_FORWARDED);
 106 }
 107 
 108 bool ShenandoahBarrierC2Support::is_gc_state_load(Node *n) {
 109   if (!UseShenandoahGC) {
 110     return false;
 111   }
 112   if (n-&gt;Opcode() != Op_LoadB &amp;&amp; n-&gt;Opcode() != Op_LoadUB) {
 113     return false;
 114   }
 115   Node* addp = n-&gt;in(MemNode::Address);
 116   if (!addp-&gt;is_AddP()) {
 117     return false;
 118   }
 119   Node* base = addp-&gt;in(AddPNode::Address);
 120   Node* off = addp-&gt;in(AddPNode::Offset);
 121   if (base-&gt;Opcode() != Op_ThreadLocal) {
 122     return false;
 123   }
 124   if (off-&gt;find_intptr_t_con(-1) != in_bytes(ShenandoahThreadLocalData::gc_state_offset())) {
 125     return false;
 126   }
 127   return true;
 128 }
 129 
 130 bool ShenandoahBarrierC2Support::has_safepoint_between(Node* start, Node* stop, PhaseIdealLoop *phase) {
 131   assert(phase-&gt;is_dominator(stop, start), &quot;bad inputs&quot;);
 132   ResourceMark rm;
 133   Unique_Node_List wq;
 134   wq.push(start);
 135   for (uint next = 0; next &lt; wq.size(); next++) {
 136     Node *m = wq.at(next);
 137     if (m == stop) {
 138       continue;
 139     }
 140     if (m-&gt;is_SafePoint() &amp;&amp; !m-&gt;is_CallLeaf()) {
 141       return true;
 142     }
 143     if (m-&gt;is_Region()) {
 144       for (uint i = 1; i &lt; m-&gt;req(); i++) {
 145         wq.push(m-&gt;in(i));
 146       }
 147     } else {
 148       wq.push(m-&gt;in(0));
 149     }
 150   }
 151   return false;
 152 }
 153 
 154 #ifdef ASSERT
 155 bool ShenandoahBarrierC2Support::verify_helper(Node* in, Node_Stack&amp; phis, VectorSet&amp; visited, verify_type t, bool trace, Unique_Node_List&amp; barriers_used) {
 156   assert(phis.size() == 0, &quot;&quot;);
 157 
 158   while (true) {
 159     if (in-&gt;bottom_type() == TypePtr::NULL_PTR) {
 160       if (trace) {tty-&gt;print_cr(&quot;NULL&quot;);}
 161     } else if (!in-&gt;bottom_type()-&gt;make_ptr()-&gt;make_oopptr()) {
 162       if (trace) {tty-&gt;print_cr(&quot;Non oop&quot;);}
 163     } else {
 164       if (in-&gt;is_ConstraintCast()) {
 165         in = in-&gt;in(1);
 166         continue;
 167       } else if (in-&gt;is_AddP()) {
 168         assert(!in-&gt;in(AddPNode::Address)-&gt;is_top(), &quot;no raw memory access&quot;);
 169         in = in-&gt;in(AddPNode::Address);
 170         continue;
 171       } else if (in-&gt;is_Con()) {
 172         if (trace) {
 173           tty-&gt;print(&quot;Found constant&quot;);
 174           in-&gt;dump();
 175         }
 176       } else if (in-&gt;Opcode() == Op_Parm) {
 177         if (trace) {
 178           tty-&gt;print(&quot;Found argument&quot;);
 179         }
 180       } else if (in-&gt;Opcode() == Op_CreateEx) {
 181         if (trace) {
 182           tty-&gt;print(&quot;Found create-exception&quot;);
 183         }
 184       } else if (in-&gt;Opcode() == Op_LoadP &amp;&amp; in-&gt;adr_type() == TypeRawPtr::BOTTOM) {
 185         if (trace) {
 186           tty-&gt;print(&quot;Found raw LoadP (OSR argument?)&quot;);
 187         }
 188       } else if (in-&gt;Opcode() == Op_ShenandoahLoadReferenceBarrier) {
 189         if (t == ShenandoahOopStore) {
 190           uint i = 0;
 191           for (; i &lt; phis.size(); i++) {
 192             Node* n = phis.node_at(i);
 193             if (n-&gt;Opcode() == Op_ShenandoahEnqueueBarrier) {
 194               break;
 195             }
 196           }
 197           if (i == phis.size()) {
 198             return false;
 199           }
 200         }
 201         barriers_used.push(in);
 202         if (trace) {tty-&gt;print(&quot;Found barrier&quot;); in-&gt;dump();}
 203       } else if (in-&gt;Opcode() == Op_ShenandoahEnqueueBarrier) {
 204         if (t != ShenandoahOopStore) {
 205           in = in-&gt;in(1);
 206           continue;
 207         }
 208         if (trace) {tty-&gt;print(&quot;Found enqueue barrier&quot;); in-&gt;dump();}
 209         phis.push(in, in-&gt;req());
 210         in = in-&gt;in(1);
 211         continue;
 212       } else if (in-&gt;is_Proj() &amp;&amp; in-&gt;in(0)-&gt;is_Allocate()) {
 213         if (trace) {
 214           tty-&gt;print(&quot;Found alloc&quot;);
 215           in-&gt;in(0)-&gt;dump();
 216         }
 217       } else if (in-&gt;is_Proj() &amp;&amp; (in-&gt;in(0)-&gt;Opcode() == Op_CallStaticJava || in-&gt;in(0)-&gt;Opcode() == Op_CallDynamicJava)) {
 218         if (trace) {
 219           tty-&gt;print(&quot;Found Java call&quot;);
 220         }
 221       } else if (in-&gt;is_Phi()) {
 222         if (!visited.test_set(in-&gt;_idx)) {
 223           if (trace) {tty-&gt;print(&quot;Pushed phi:&quot;); in-&gt;dump();}
 224           phis.push(in, 2);
 225           in = in-&gt;in(1);
 226           continue;
 227         }
 228         if (trace) {tty-&gt;print(&quot;Already seen phi:&quot;); in-&gt;dump();}
 229       } else if (in-&gt;Opcode() == Op_CMoveP || in-&gt;Opcode() == Op_CMoveN) {
 230         if (!visited.test_set(in-&gt;_idx)) {
 231           if (trace) {tty-&gt;print(&quot;Pushed cmovep:&quot;); in-&gt;dump();}
 232           phis.push(in, CMoveNode::IfTrue);
 233           in = in-&gt;in(CMoveNode::IfFalse);
 234           continue;
 235         }
 236         if (trace) {tty-&gt;print(&quot;Already seen cmovep:&quot;); in-&gt;dump();}
 237       } else if (in-&gt;Opcode() == Op_EncodeP || in-&gt;Opcode() == Op_DecodeN) {
 238         in = in-&gt;in(1);
 239         continue;
 240       } else {
 241         return false;
 242       }
 243     }
 244     bool cont = false;
 245     while (phis.is_nonempty()) {
 246       uint idx = phis.index();
 247       Node* phi = phis.node();
 248       if (idx &gt;= phi-&gt;req()) {
 249         if (trace) {tty-&gt;print(&quot;Popped phi:&quot;); phi-&gt;dump();}
 250         phis.pop();
 251         continue;
 252       }
 253       if (trace) {tty-&gt;print(&quot;Next entry(%d) for phi:&quot;, idx); phi-&gt;dump();}
 254       in = phi-&gt;in(idx);
 255       phis.set_index(idx+1);
 256       cont = true;
 257       break;
 258     }
 259     if (!cont) {
 260       break;
 261     }
 262   }
 263   return true;
 264 }
 265 
 266 void ShenandoahBarrierC2Support::report_verify_failure(const char* msg, Node* n1, Node* n2) {
 267   if (n1 != NULL) {
 268     n1-&gt;dump(+10);
 269   }
 270   if (n2 != NULL) {
 271     n2-&gt;dump(+10);
 272   }
 273   fatal(&quot;%s&quot;, msg);
 274 }
 275 
 276 void ShenandoahBarrierC2Support::verify(RootNode* root) {
 277   ResourceMark rm;
 278   Unique_Node_List wq;
 279   GrowableArray&lt;Node*&gt; barriers;
 280   Unique_Node_List barriers_used;
 281   Node_Stack phis(0);
 282   VectorSet visited(Thread::current()-&gt;resource_area());
 283   const bool trace = false;
 284   const bool verify_no_useless_barrier = false;
 285 
 286   wq.push(root);
 287   for (uint next = 0; next &lt; wq.size(); next++) {
 288     Node *n = wq.at(next);
 289     if (n-&gt;is_Load()) {
 290       const bool trace = false;
 291       if (trace) {tty-&gt;print(&quot;Verifying&quot;); n-&gt;dump();}
 292       if (n-&gt;Opcode() == Op_LoadRange || n-&gt;Opcode() == Op_LoadKlass || n-&gt;Opcode() == Op_LoadNKlass) {
 293         if (trace) {tty-&gt;print_cr(&quot;Load range/klass&quot;);}
 294       } else {
 295         const TypePtr* adr_type = n-&gt;as_Load()-&gt;adr_type();
 296 
 297         if (adr_type-&gt;isa_oopptr() &amp;&amp; adr_type-&gt;is_oopptr()-&gt;offset() == oopDesc::mark_offset_in_bytes()) {
 298           if (trace) {tty-&gt;print_cr(&quot;Mark load&quot;);}
 299         } else if (adr_type-&gt;isa_instptr() &amp;&amp;
 300                    adr_type-&gt;is_instptr()-&gt;klass()-&gt;is_subtype_of(Compile::current()-&gt;env()-&gt;Reference_klass()) &amp;&amp;
 301                    adr_type-&gt;is_instptr()-&gt;offset() == java_lang_ref_Reference::referent_offset) {
 302           if (trace) {tty-&gt;print_cr(&quot;Reference.get()&quot;);}
 303         } else if (!verify_helper(n-&gt;in(MemNode::Address), phis, visited, ShenandoahLoad, trace, barriers_used)) {
 304           report_verify_failure(&quot;Shenandoah verification: Load should have barriers&quot;, n);
 305         }
 306       }
 307     } else if (n-&gt;is_Store()) {
 308       const bool trace = false;
 309 
 310       if (trace) {tty-&gt;print(&quot;Verifying&quot;); n-&gt;dump();}
 311       if (n-&gt;in(MemNode::ValueIn)-&gt;bottom_type()-&gt;make_oopptr()) {
 312         Node* adr = n-&gt;in(MemNode::Address);
 313         bool verify = true;
 314 
 315         if (adr-&gt;is_AddP() &amp;&amp; adr-&gt;in(AddPNode::Base)-&gt;is_top()) {
 316           adr = adr-&gt;in(AddPNode::Address);
 317           if (adr-&gt;is_AddP()) {
 318             assert(adr-&gt;in(AddPNode::Base)-&gt;is_top(), &quot;&quot;);
 319             adr = adr-&gt;in(AddPNode::Address);
 320             if (adr-&gt;Opcode() == Op_LoadP &amp;&amp;
 321                 adr-&gt;in(MemNode::Address)-&gt;in(AddPNode::Base)-&gt;is_top() &amp;&amp;
 322                 adr-&gt;in(MemNode::Address)-&gt;in(AddPNode::Address)-&gt;Opcode() == Op_ThreadLocal &amp;&amp;
 323                 adr-&gt;in(MemNode::Address)-&gt;in(AddPNode::Offset)-&gt;find_intptr_t_con(-1) == in_bytes(ShenandoahThreadLocalData::satb_mark_queue_buffer_offset())) {
 324               if (trace) {tty-&gt;print_cr(&quot;SATB prebarrier&quot;);}
 325               verify = false;
 326             }
 327           }
 328         }
 329 
 330         if (verify &amp;&amp; !verify_helper(n-&gt;in(MemNode::ValueIn), phis, visited, ShenandoahStoreValEnqueueBarrier ? ShenandoahOopStore : ShenandoahValue, trace, barriers_used)) {
 331           report_verify_failure(&quot;Shenandoah verification: Store should have barriers&quot;, n);
 332         }
 333       }
 334       if (!verify_helper(n-&gt;in(MemNode::Address), phis, visited, ShenandoahStore, trace, barriers_used)) {
 335         report_verify_failure(&quot;Shenandoah verification: Store (address) should have barriers&quot;, n);
 336       }
 337     } else if (n-&gt;Opcode() == Op_CmpP) {
 338       const bool trace = false;
 339 
 340       Node* in1 = n-&gt;in(1);
 341       Node* in2 = n-&gt;in(2);
 342       if (in1-&gt;bottom_type()-&gt;isa_oopptr()) {
 343         if (trace) {tty-&gt;print(&quot;Verifying&quot;); n-&gt;dump();}
 344 
 345         bool mark_inputs = false;
 346         if (in1-&gt;bottom_type() == TypePtr::NULL_PTR || in2-&gt;bottom_type() == TypePtr::NULL_PTR ||
 347             (in1-&gt;is_Con() || in2-&gt;is_Con())) {
 348           if (trace) {tty-&gt;print_cr(&quot;Comparison against a constant&quot;);}
 349           mark_inputs = true;
 350         } else if ((in1-&gt;is_CheckCastPP() &amp;&amp; in1-&gt;in(1)-&gt;is_Proj() &amp;&amp; in1-&gt;in(1)-&gt;in(0)-&gt;is_Allocate()) ||
 351                    (in2-&gt;is_CheckCastPP() &amp;&amp; in2-&gt;in(1)-&gt;is_Proj() &amp;&amp; in2-&gt;in(1)-&gt;in(0)-&gt;is_Allocate())) {
 352           if (trace) {tty-&gt;print_cr(&quot;Comparison with newly alloc&#39;ed object&quot;);}
 353           mark_inputs = true;
 354         } else {
 355           assert(in2-&gt;bottom_type()-&gt;isa_oopptr(), &quot;&quot;);
 356 
 357           if (!verify_helper(in1, phis, visited, ShenandoahStore, trace, barriers_used) ||
 358               !verify_helper(in2, phis, visited, ShenandoahStore, trace, barriers_used)) {
 359             report_verify_failure(&quot;Shenandoah verification: Cmp should have barriers&quot;, n);
 360           }
 361         }
 362         if (verify_no_useless_barrier &amp;&amp;
 363             mark_inputs &amp;&amp;
 364             (!verify_helper(in1, phis, visited, ShenandoahValue, trace, barriers_used) ||
 365              !verify_helper(in2, phis, visited, ShenandoahValue, trace, barriers_used))) {
 366           phis.clear();
 367           visited.reset();
 368         }
 369       }
 370     } else if (n-&gt;is_LoadStore()) {
 371       if (n-&gt;in(MemNode::ValueIn)-&gt;bottom_type()-&gt;make_ptr() &amp;&amp;
 372           !verify_helper(n-&gt;in(MemNode::ValueIn), phis, visited, ShenandoahStoreValEnqueueBarrier ? ShenandoahOopStore : ShenandoahValue, trace, barriers_used)) {
 373         report_verify_failure(&quot;Shenandoah verification: LoadStore (value) should have barriers&quot;, n);
 374       }
 375 
 376       if (n-&gt;in(MemNode::Address)-&gt;bottom_type()-&gt;make_oopptr() &amp;&amp; !verify_helper(n-&gt;in(MemNode::Address), phis, visited, ShenandoahStore, trace, barriers_used)) {
 377         report_verify_failure(&quot;Shenandoah verification: LoadStore (address) should have barriers&quot;, n);
 378       }
 379     } else if (n-&gt;Opcode() == Op_CallLeafNoFP || n-&gt;Opcode() == Op_CallLeaf) {
 380       CallNode* call = n-&gt;as_Call();
 381 
 382       static struct {
 383         const char* name;
 384         struct {
 385           int pos;
 386           verify_type t;
 387         } args[6];
 388       } calls[] = {
 389         &quot;aescrypt_encryptBlock&quot;,
 390         { { TypeFunc::Parms, ShenandoahLoad },   { TypeFunc::Parms+1, ShenandoahStore },  { TypeFunc::Parms+2, ShenandoahLoad },
 391           { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
 392         &quot;aescrypt_decryptBlock&quot;,
 393         { { TypeFunc::Parms, ShenandoahLoad },   { TypeFunc::Parms+1, ShenandoahStore },  { TypeFunc::Parms+2, ShenandoahLoad },
 394           { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
 395         &quot;multiplyToLen&quot;,
 396         { { TypeFunc::Parms, ShenandoahLoad },   { TypeFunc::Parms+2, ShenandoahLoad },   { TypeFunc::Parms+4, ShenandoahStore },
 397           { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
 398         &quot;squareToLen&quot;,
 399         { { TypeFunc::Parms, ShenandoahLoad },   { TypeFunc::Parms+2, ShenandoahLoad },   { -1,  ShenandoahNone},
 400           { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
 401         &quot;montgomery_multiply&quot;,
 402         { { TypeFunc::Parms, ShenandoahLoad },   { TypeFunc::Parms+1, ShenandoahLoad },   { TypeFunc::Parms+2, ShenandoahLoad },
 403           { TypeFunc::Parms+6, ShenandoahStore }, { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
 404         &quot;montgomery_square&quot;,
 405         { { TypeFunc::Parms, ShenandoahLoad },   { TypeFunc::Parms+1, ShenandoahLoad },   { TypeFunc::Parms+5, ShenandoahStore },
 406           { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
 407         &quot;mulAdd&quot;,
 408         { { TypeFunc::Parms, ShenandoahStore },  { TypeFunc::Parms+1, ShenandoahLoad },   { -1,  ShenandoahNone},
 409           { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
 410         &quot;vectorizedMismatch&quot;,
 411         { { TypeFunc::Parms, ShenandoahLoad },   { TypeFunc::Parms+1, ShenandoahLoad },   { -1,  ShenandoahNone},
 412           { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
 413         &quot;updateBytesCRC32&quot;,
 414         { { TypeFunc::Parms+1, ShenandoahLoad }, { -1,  ShenandoahNone},                  { -1,  ShenandoahNone},
 415           { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
 416         &quot;updateBytesAdler32&quot;,
 417         { { TypeFunc::Parms+1, ShenandoahLoad }, { -1,  ShenandoahNone},                  { -1,  ShenandoahNone},
 418           { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
 419         &quot;updateBytesCRC32C&quot;,
 420         { { TypeFunc::Parms+1, ShenandoahLoad }, { TypeFunc::Parms+3, ShenandoahLoad},    { -1,  ShenandoahNone},
 421           { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
 422         &quot;counterMode_AESCrypt&quot;,
 423         { { TypeFunc::Parms, ShenandoahLoad },   { TypeFunc::Parms+1, ShenandoahStore },  { TypeFunc::Parms+2, ShenandoahLoad },
 424           { TypeFunc::Parms+3, ShenandoahStore }, { TypeFunc::Parms+5, ShenandoahStore }, { TypeFunc::Parms+6, ShenandoahStore } },
 425         &quot;cipherBlockChaining_encryptAESCrypt&quot;,
 426         { { TypeFunc::Parms, ShenandoahLoad },   { TypeFunc::Parms+1, ShenandoahStore },  { TypeFunc::Parms+2, ShenandoahLoad },
 427           { TypeFunc::Parms+3, ShenandoahLoad },  { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
 428         &quot;cipherBlockChaining_decryptAESCrypt&quot;,
 429         { { TypeFunc::Parms, ShenandoahLoad },   { TypeFunc::Parms+1, ShenandoahStore },  { TypeFunc::Parms+2, ShenandoahLoad },
 430           { TypeFunc::Parms+3, ShenandoahLoad },  { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
 431         &quot;shenandoah_clone_barrier&quot;,
 432         { { TypeFunc::Parms, ShenandoahLoad },   { -1,  ShenandoahNone},                  { -1,  ShenandoahNone},
 433           { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
 434         &quot;ghash_processBlocks&quot;,
 435         { { TypeFunc::Parms, ShenandoahStore },  { TypeFunc::Parms+1, ShenandoahLoad },   { TypeFunc::Parms+2, ShenandoahLoad },
 436           { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
 437         &quot;sha1_implCompress&quot;,
 438         { { TypeFunc::Parms, ShenandoahLoad },  { TypeFunc::Parms+1, ShenandoahStore },   { -1, ShenandoahNone },
 439           { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
 440         &quot;sha256_implCompress&quot;,
 441         { { TypeFunc::Parms, ShenandoahLoad },  { TypeFunc::Parms+1, ShenandoahStore },   { -1, ShenandoahNone },
 442           { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
 443         &quot;sha512_implCompress&quot;,
 444         { { TypeFunc::Parms, ShenandoahLoad },  { TypeFunc::Parms+1, ShenandoahStore },   { -1, ShenandoahNone },
 445           { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
 446         &quot;sha1_implCompressMB&quot;,
 447         { { TypeFunc::Parms, ShenandoahLoad },  { TypeFunc::Parms+1, ShenandoahStore },   { -1, ShenandoahNone },
 448           { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
 449         &quot;sha256_implCompressMB&quot;,
 450         { { TypeFunc::Parms, ShenandoahLoad },  { TypeFunc::Parms+1, ShenandoahStore },   { -1, ShenandoahNone },
 451           { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
 452         &quot;sha512_implCompressMB&quot;,
 453         { { TypeFunc::Parms, ShenandoahLoad },  { TypeFunc::Parms+1, ShenandoahStore },   { -1, ShenandoahNone },
 454           { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
 455         &quot;encodeBlock&quot;,
 456         { { TypeFunc::Parms, ShenandoahLoad },  { TypeFunc::Parms+3, ShenandoahStore },   { -1, ShenandoahNone },
 457           { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
 458       };
 459 
 460       if (call-&gt;is_call_to_arraycopystub()) {
 461         Node* dest = NULL;
 462         const TypeTuple* args = n-&gt;as_Call()-&gt;_tf-&gt;domain();
 463         for (uint i = TypeFunc::Parms, j = 0; i &lt; args-&gt;cnt(); i++) {
 464           if (args-&gt;field_at(i)-&gt;isa_ptr()) {
 465             j++;
 466             if (j == 2) {
 467               dest = n-&gt;in(i);
 468               break;
 469             }
 470           }
 471         }
 472         if (!verify_helper(n-&gt;in(TypeFunc::Parms), phis, visited, ShenandoahLoad, trace, barriers_used) ||
 473             !verify_helper(dest, phis, visited, ShenandoahStore, trace, barriers_used)) {
 474           report_verify_failure(&quot;Shenandoah verification: ArrayCopy should have barriers&quot;, n);
 475         }
 476       } else if (strlen(call-&gt;_name) &gt; 5 &amp;&amp;
 477                  !strcmp(call-&gt;_name + strlen(call-&gt;_name) - 5, &quot;_fill&quot;)) {
 478         if (!verify_helper(n-&gt;in(TypeFunc::Parms), phis, visited, ShenandoahStore, trace, barriers_used)) {
 479           report_verify_failure(&quot;Shenandoah verification: _fill should have barriers&quot;, n);
 480         }
 481       } else if (!strcmp(call-&gt;_name, &quot;shenandoah_wb_pre&quot;)) {
 482         // skip
 483       } else {
 484         const int calls_len = sizeof(calls) / sizeof(calls[0]);
 485         int i = 0;
 486         for (; i &lt; calls_len; i++) {
 487           if (!strcmp(calls[i].name, call-&gt;_name)) {
 488             break;
 489           }
 490         }
 491         if (i != calls_len) {
 492           const uint args_len = sizeof(calls[0].args) / sizeof(calls[0].args[0]);
 493           for (uint j = 0; j &lt; args_len; j++) {
 494             int pos = calls[i].args[j].pos;
 495             if (pos == -1) {
 496               break;
 497             }
 498             if (!verify_helper(call-&gt;in(pos), phis, visited, calls[i].args[j].t, trace, barriers_used)) {
 499               report_verify_failure(&quot;Shenandoah verification: intrinsic calls should have barriers&quot;, n);
 500             }
 501           }
 502           for (uint j = TypeFunc::Parms; j &lt; call-&gt;req(); j++) {
 503             if (call-&gt;in(j)-&gt;bottom_type()-&gt;make_ptr() &amp;&amp;
 504                 call-&gt;in(j)-&gt;bottom_type()-&gt;make_ptr()-&gt;isa_oopptr()) {
 505               uint k = 0;
 506               for (; k &lt; args_len &amp;&amp; calls[i].args[k].pos != (int)j; k++);
 507               if (k == args_len) {
 508                 fatal(&quot;arg %d for call %s not covered&quot;, j, call-&gt;_name);
 509               }
 510             }
 511           }
 512         } else {
 513           for (uint j = TypeFunc::Parms; j &lt; call-&gt;req(); j++) {
 514             if (call-&gt;in(j)-&gt;bottom_type()-&gt;make_ptr() &amp;&amp;
 515                 call-&gt;in(j)-&gt;bottom_type()-&gt;make_ptr()-&gt;isa_oopptr()) {
 516               fatal(&quot;%s not covered&quot;, call-&gt;_name);
 517             }
 518           }
 519         }
 520       }
 521     } else if (n-&gt;Opcode() == Op_ShenandoahEnqueueBarrier || n-&gt;Opcode() == Op_ShenandoahLoadReferenceBarrier) {
 522       // skip
 523     } else if (n-&gt;is_AddP()
 524                || n-&gt;is_Phi()
 525                || n-&gt;is_ConstraintCast()
 526                || n-&gt;Opcode() == Op_Return
 527                || n-&gt;Opcode() == Op_CMoveP
 528                || n-&gt;Opcode() == Op_CMoveN
 529                || n-&gt;Opcode() == Op_Rethrow
 530                || n-&gt;is_MemBar()
 531                || n-&gt;Opcode() == Op_Conv2B
 532                || n-&gt;Opcode() == Op_SafePoint
 533                || n-&gt;is_CallJava()
 534                || n-&gt;Opcode() == Op_Unlock
 535                || n-&gt;Opcode() == Op_EncodeP
 536                || n-&gt;Opcode() == Op_DecodeN) {
 537       // nothing to do
 538     } else {
 539       static struct {
 540         int opcode;
 541         struct {
 542           int pos;
 543           verify_type t;
 544         } inputs[2];
 545       } others[] = {
 546         Op_FastLock,
 547         { { 1, ShenandoahLoad },                  { -1, ShenandoahNone} },
 548         Op_Lock,
 549         { { TypeFunc::Parms, ShenandoahLoad },    { -1, ShenandoahNone} },
 550         Op_ArrayCopy,
 551         { { ArrayCopyNode::Src, ShenandoahLoad }, { ArrayCopyNode::Dest, ShenandoahStore } },
 552         Op_StrCompressedCopy,
 553         { { 2, ShenandoahLoad },                  { 3, ShenandoahStore } },
 554         Op_StrInflatedCopy,
 555         { { 2, ShenandoahLoad },                  { 3, ShenandoahStore } },
 556         Op_AryEq,
 557         { { 2, ShenandoahLoad },                  { 3, ShenandoahLoad } },
 558         Op_StrIndexOf,
 559         { { 2, ShenandoahLoad },                  { 4, ShenandoahLoad } },
 560         Op_StrComp,
 561         { { 2, ShenandoahLoad },                  { 4, ShenandoahLoad } },
 562         Op_StrEquals,
 563         { { 2, ShenandoahLoad },                  { 3, ShenandoahLoad } },
 564         Op_EncodeISOArray,
 565         { { 2, ShenandoahLoad },                  { 3, ShenandoahStore } },
 566         Op_HasNegatives,
 567         { { 2, ShenandoahLoad },                  { -1, ShenandoahNone} },
 568         Op_CastP2X,
 569         { { 1, ShenandoahLoad },                  { -1, ShenandoahNone} },
 570         Op_StrIndexOfChar,
 571         { { 2, ShenandoahLoad },                  { -1, ShenandoahNone } },
 572       };
 573 
 574       const int others_len = sizeof(others) / sizeof(others[0]);
 575       int i = 0;
 576       for (; i &lt; others_len; i++) {
 577         if (others[i].opcode == n-&gt;Opcode()) {
 578           break;
 579         }
 580       }
 581       uint stop = n-&gt;is_Call() ? n-&gt;as_Call()-&gt;tf()-&gt;domain()-&gt;cnt() : n-&gt;req();
 582       if (i != others_len) {
 583         const uint inputs_len = sizeof(others[0].inputs) / sizeof(others[0].inputs[0]);
 584         for (uint j = 0; j &lt; inputs_len; j++) {
 585           int pos = others[i].inputs[j].pos;
 586           if (pos == -1) {
 587             break;
 588           }
 589           if (!verify_helper(n-&gt;in(pos), phis, visited, others[i].inputs[j].t, trace, barriers_used)) {
 590             report_verify_failure(&quot;Shenandoah verification: intrinsic calls should have barriers&quot;, n);
 591           }
 592         }
 593         for (uint j = 1; j &lt; stop; j++) {
 594           if (n-&gt;in(j) != NULL &amp;&amp; n-&gt;in(j)-&gt;bottom_type()-&gt;make_ptr() &amp;&amp;
 595               n-&gt;in(j)-&gt;bottom_type()-&gt;make_ptr()-&gt;make_oopptr()) {
 596             uint k = 0;
 597             for (; k &lt; inputs_len &amp;&amp; others[i].inputs[k].pos != (int)j; k++);
 598             if (k == inputs_len) {
 599               fatal(&quot;arg %d for node %s not covered&quot;, j, n-&gt;Name());
 600             }
 601           }
 602         }
 603       } else {
 604         for (uint j = 1; j &lt; stop; j++) {
 605           if (n-&gt;in(j) != NULL &amp;&amp; n-&gt;in(j)-&gt;bottom_type()-&gt;make_ptr() &amp;&amp;
 606               n-&gt;in(j)-&gt;bottom_type()-&gt;make_ptr()-&gt;make_oopptr()) {
 607             fatal(&quot;%s not covered&quot;, n-&gt;Name());
 608           }
 609         }
 610       }
 611     }
 612 
 613     if (n-&gt;is_SafePoint()) {
 614       SafePointNode* sfpt = n-&gt;as_SafePoint();
 615       if (verify_no_useless_barrier &amp;&amp; sfpt-&gt;jvms() != NULL) {
 616         for (uint i = sfpt-&gt;jvms()-&gt;scloff(); i &lt; sfpt-&gt;jvms()-&gt;endoff(); i++) {
 617           if (!verify_helper(sfpt-&gt;in(i), phis, visited, ShenandoahLoad, trace, barriers_used)) {
 618             phis.clear();
 619             visited.reset();
 620           }
 621         }
 622       }
 623     }
 624   }
 625 
 626   if (verify_no_useless_barrier) {
 627     for (int i = 0; i &lt; barriers.length(); i++) {
 628       Node* n = barriers.at(i);
 629       if (!barriers_used.member(n)) {
 630         tty-&gt;print(&quot;XXX useless barrier&quot;); n-&gt;dump(-2);
 631         ShouldNotReachHere();
 632       }
 633     }
 634   }
 635 }
 636 #endif
 637 
 638 bool ShenandoahBarrierC2Support::is_dominator_same_ctrl(Node* c, Node* d, Node* n, PhaseIdealLoop* phase) {
 639   // That both nodes have the same control is not sufficient to prove
 640   // domination, verify that there&#39;s no path from d to n
 641   ResourceMark rm;
 642   Unique_Node_List wq;
 643   wq.push(d);
 644   for (uint next = 0; next &lt; wq.size(); next++) {
 645     Node *m = wq.at(next);
 646     if (m == n) {
 647       return false;
 648     }
 649     if (m-&gt;is_Phi() &amp;&amp; m-&gt;in(0)-&gt;is_Loop()) {
 650       assert(phase-&gt;ctrl_or_self(m-&gt;in(LoopNode::EntryControl)) != c, &quot;following loop entry should lead to new control&quot;);
 651     } else {
 652       if (m-&gt;is_Store() || m-&gt;is_LoadStore()) {
 653         // Take anti-dependencies into account
 654         Node* mem = m-&gt;in(MemNode::Memory);
 655         for (DUIterator_Fast imax, i = mem-&gt;fast_outs(imax); i &lt; imax; i++) {
 656           Node* u = mem-&gt;fast_out(i);
 657           if (u-&gt;is_Load() &amp;&amp; phase-&gt;C-&gt;can_alias(m-&gt;adr_type(), phase-&gt;C-&gt;get_alias_index(u-&gt;adr_type())) &amp;&amp;
 658               phase-&gt;ctrl_or_self(u) == c) {
 659             wq.push(u);
 660           }
 661         }
 662       }
 663       for (uint i = 0; i &lt; m-&gt;req(); i++) {
 664         if (m-&gt;in(i) != NULL &amp;&amp; phase-&gt;ctrl_or_self(m-&gt;in(i)) == c) {
 665           wq.push(m-&gt;in(i));
 666         }
 667       }
 668     }
 669   }
 670   return true;
 671 }
 672 
 673 bool ShenandoahBarrierC2Support::is_dominator(Node* d_c, Node* n_c, Node* d, Node* n, PhaseIdealLoop* phase) {
 674   if (d_c != n_c) {
 675     return phase-&gt;is_dominator(d_c, n_c);
 676   }
 677   return is_dominator_same_ctrl(d_c, d, n, phase);
 678 }
 679 
 680 Node* next_mem(Node* mem, int alias) {
 681   Node* res = NULL;
 682   if (mem-&gt;is_Proj()) {
 683     res = mem-&gt;in(0);
 684   } else if (mem-&gt;is_SafePoint() || mem-&gt;is_MemBar()) {
 685     res = mem-&gt;in(TypeFunc::Memory);
 686   } else if (mem-&gt;is_Phi()) {
 687     res = mem-&gt;in(1);
 688   } else if (mem-&gt;is_MergeMem()) {
 689     res = mem-&gt;as_MergeMem()-&gt;memory_at(alias);
 690   } else if (mem-&gt;is_Store() || mem-&gt;is_LoadStore() || mem-&gt;is_ClearArray()) {
 691     assert(alias = Compile::AliasIdxRaw, &quot;following raw memory can&#39;t lead to a barrier&quot;);
 692     res = mem-&gt;in(MemNode::Memory);
 693   } else {
 694 #ifdef ASSERT
 695     mem-&gt;dump();
 696 #endif
 697     ShouldNotReachHere();
 698   }
 699   return res;
 700 }
 701 
 702 Node* ShenandoahBarrierC2Support::no_branches(Node* c, Node* dom, bool allow_one_proj, PhaseIdealLoop* phase) {
 703   Node* iffproj = NULL;
 704   while (c != dom) {
 705     Node* next = phase-&gt;idom(c);
 706     assert(next-&gt;unique_ctrl_out() == c || c-&gt;is_Proj() || c-&gt;is_Region(), &quot;multiple control flow out but no proj or region?&quot;);
 707     if (c-&gt;is_Region()) {
 708       ResourceMark rm;
 709       Unique_Node_List wq;
 710       wq.push(c);
 711       for (uint i = 0; i &lt; wq.size(); i++) {
 712         Node *n = wq.at(i);
 713         if (n == next) {
 714           continue;
 715         }
 716         if (n-&gt;is_Region()) {
 717           for (uint j = 1; j &lt; n-&gt;req(); j++) {
 718             wq.push(n-&gt;in(j));
 719           }
 720         } else {
 721           wq.push(n-&gt;in(0));
 722         }
 723       }
 724       for (uint i = 0; i &lt; wq.size(); i++) {
 725         Node *n = wq.at(i);
 726         assert(n-&gt;is_CFG(), &quot;&quot;);
 727         if (n-&gt;is_Multi()) {
 728           for (DUIterator_Fast jmax, j = n-&gt;fast_outs(jmax); j &lt; jmax; j++) {
 729             Node* u = n-&gt;fast_out(j);
 730             if (u-&gt;is_CFG()) {
 731               if (!wq.member(u) &amp;&amp; !u-&gt;as_Proj()-&gt;is_uncommon_trap_proj(Deoptimization::Reason_none)) {
 732                 return NodeSentinel;
 733               }
 734             }
 735           }
 736         }
 737       }
 738     } else  if (c-&gt;is_Proj()) {
 739       if (c-&gt;is_IfProj()) {
 740         if (c-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none) != NULL) {
 741           // continue;
 742         } else {
 743           if (!allow_one_proj) {
 744             return NodeSentinel;
 745           }
 746           if (iffproj == NULL) {
 747             iffproj = c;
 748           } else {
 749             return NodeSentinel;
 750           }
 751         }
 752       } else if (c-&gt;Opcode() == Op_JumpProj) {
 753         return NodeSentinel; // unsupported
 754       } else if (c-&gt;Opcode() == Op_CatchProj) {
 755         return NodeSentinel; // unsupported
 756       } else if (c-&gt;Opcode() == Op_CProj &amp;&amp; next-&gt;Opcode() == Op_NeverBranch) {
 757         return NodeSentinel; // unsupported
 758       } else {
 759         assert(next-&gt;unique_ctrl_out() == c, &quot;unsupported branch pattern&quot;);
 760       }
 761     }
 762     c = next;
 763   }
 764   return iffproj;
 765 }
 766 
 767 Node* ShenandoahBarrierC2Support::dom_mem(Node* mem, Node* ctrl, int alias, Node*&amp; mem_ctrl, PhaseIdealLoop* phase) {
 768   ResourceMark rm;
 769   VectorSet wq(Thread::current()-&gt;resource_area());
 770   wq.set(mem-&gt;_idx);
 771   mem_ctrl = phase-&gt;ctrl_or_self(mem);
 772   while (!phase-&gt;is_dominator(mem_ctrl, ctrl) || mem_ctrl == ctrl) {
 773     mem = next_mem(mem, alias);
 774     if (wq.test_set(mem-&gt;_idx)) {
 775       return NULL;
 776     }
 777     mem_ctrl = phase-&gt;ctrl_or_self(mem);
 778   }
 779   if (mem-&gt;is_MergeMem()) {
 780     mem = mem-&gt;as_MergeMem()-&gt;memory_at(alias);
 781     mem_ctrl = phase-&gt;ctrl_or_self(mem);
 782   }
 783   return mem;
 784 }
 785 
 786 Node* ShenandoahBarrierC2Support::find_bottom_mem(Node* ctrl, PhaseIdealLoop* phase) {
 787   Node* mem = NULL;
 788   Node* c = ctrl;
 789   do {
 790     if (c-&gt;is_Region()) {
 791       for (DUIterator_Fast imax, i = c-&gt;fast_outs(imax); i &lt; imax &amp;&amp; mem == NULL; i++) {
 792         Node* u = c-&gt;fast_out(i);
 793         if (u-&gt;is_Phi() &amp;&amp; u-&gt;bottom_type() == Type::MEMORY) {
 794           if (u-&gt;adr_type() == TypePtr::BOTTOM) {
 795             mem = u;
 796           }
 797         }
 798       }
 799     } else {
 800       if (c-&gt;is_Call() &amp;&amp; c-&gt;as_Call()-&gt;adr_type() != NULL) {
 801         CallProjections projs;
 802         c-&gt;as_Call()-&gt;extract_projections(&amp;projs, true, false);
 803         if (projs.fallthrough_memproj != NULL) {
 804           if (projs.fallthrough_memproj-&gt;adr_type() == TypePtr::BOTTOM) {
 805             if (projs.catchall_memproj == NULL) {
 806               mem = projs.fallthrough_memproj;
 807             } else {
 808               if (phase-&gt;is_dominator(projs.fallthrough_catchproj, ctrl)) {
 809                 mem = projs.fallthrough_memproj;
 810               } else {
 811                 assert(phase-&gt;is_dominator(projs.catchall_catchproj, ctrl), &quot;one proj must dominate barrier&quot;);
 812                 mem = projs.catchall_memproj;
 813               }
 814             }
 815           }
 816         } else {
 817           Node* proj = c-&gt;as_Call()-&gt;proj_out(TypeFunc::Memory);
 818           if (proj != NULL &amp;&amp;
 819               proj-&gt;adr_type() == TypePtr::BOTTOM) {
 820             mem = proj;
 821           }
 822         }
 823       } else {
 824         for (DUIterator_Fast imax, i = c-&gt;fast_outs(imax); i &lt; imax; i++) {
 825           Node* u = c-&gt;fast_out(i);
 826           if (u-&gt;is_Proj() &amp;&amp;
 827               u-&gt;bottom_type() == Type::MEMORY &amp;&amp;
 828               u-&gt;adr_type() == TypePtr::BOTTOM) {
 829               assert(c-&gt;is_SafePoint() || c-&gt;is_MemBar() || c-&gt;is_Start(), &quot;&quot;);
 830               assert(mem == NULL, &quot;only one proj&quot;);
 831               mem = u;
 832           }
 833         }
 834         assert(!c-&gt;is_Call() || c-&gt;as_Call()-&gt;adr_type() != NULL || mem == NULL, &quot;no mem projection expected&quot;);
 835       }
 836     }
 837     c = phase-&gt;idom(c);
 838   } while (mem == NULL);
 839   return mem;
 840 }
 841 
 842 void ShenandoahBarrierC2Support::follow_barrier_uses(Node* n, Node* ctrl, Unique_Node_List&amp; uses, PhaseIdealLoop* phase) {
 843   for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
 844     Node* u = n-&gt;fast_out(i);
 845     if (!u-&gt;is_CFG() &amp;&amp; phase-&gt;get_ctrl(u) == ctrl &amp;&amp; (!u-&gt;is_Phi() || !u-&gt;in(0)-&gt;is_Loop() || u-&gt;in(LoopNode::LoopBackControl) != n)) {
 846       uses.push(u);
 847     }
 848   }
 849 }
 850 
 851 static void hide_strip_mined_loop(OuterStripMinedLoopNode* outer, CountedLoopNode* inner, PhaseIdealLoop* phase) {
 852   OuterStripMinedLoopEndNode* le = inner-&gt;outer_loop_end();
 853   Node* new_outer = new LoopNode(outer-&gt;in(LoopNode::EntryControl), outer-&gt;in(LoopNode::LoopBackControl));
 854   phase-&gt;register_control(new_outer, phase-&gt;get_loop(outer), outer-&gt;in(LoopNode::EntryControl));
 855   Node* new_le = new IfNode(le-&gt;in(0), le-&gt;in(1), le-&gt;_prob, le-&gt;_fcnt);
 856   phase-&gt;register_control(new_le, phase-&gt;get_loop(le), le-&gt;in(0));
 857   phase-&gt;lazy_replace(outer, new_outer);
 858   phase-&gt;lazy_replace(le, new_le);
 859   inner-&gt;clear_strip_mined();
 860 }
 861 
 862 void ShenandoahBarrierC2Support::test_gc_state(Node*&amp; ctrl, Node* raw_mem, Node*&amp; test_fail_ctrl,
 863                                                PhaseIdealLoop* phase, int flags) {
 864   PhaseIterGVN&amp; igvn = phase-&gt;igvn();
 865   Node* old_ctrl = ctrl;
 866 
 867   Node* thread          = new ThreadLocalNode();
 868   Node* gc_state_offset = igvn.MakeConX(in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
 869   Node* gc_state_addr   = new AddPNode(phase-&gt;C-&gt;top(), thread, gc_state_offset);
 870   Node* gc_state        = new LoadBNode(old_ctrl, raw_mem, gc_state_addr,
 871                                         DEBUG_ONLY(phase-&gt;C-&gt;get_adr_type(Compile::AliasIdxRaw)) NOT_DEBUG(NULL),
 872                                         TypeInt::BYTE, MemNode::unordered);
 873   Node* gc_state_and    = new AndINode(gc_state, igvn.intcon(flags));
 874   Node* gc_state_cmp    = new CmpINode(gc_state_and, igvn.zerocon(T_INT));
 875   Node* gc_state_bool   = new BoolNode(gc_state_cmp, BoolTest::ne);
 876 
 877   IfNode* gc_state_iff  = new IfNode(old_ctrl, gc_state_bool, PROB_UNLIKELY(0.999), COUNT_UNKNOWN);
 878   ctrl                  = new IfTrueNode(gc_state_iff);
 879   test_fail_ctrl        = new IfFalseNode(gc_state_iff);
 880 
 881   IdealLoopTree* loop = phase-&gt;get_loop(old_ctrl);
 882   phase-&gt;register_control(gc_state_iff,   loop, old_ctrl);
 883   phase-&gt;register_control(ctrl,           loop, gc_state_iff);
 884   phase-&gt;register_control(test_fail_ctrl, loop, gc_state_iff);
 885 
 886   phase-&gt;register_new_node(thread,        old_ctrl);
 887   phase-&gt;register_new_node(gc_state_addr, old_ctrl);
 888   phase-&gt;register_new_node(gc_state,      old_ctrl);
 889   phase-&gt;register_new_node(gc_state_and,  old_ctrl);
 890   phase-&gt;register_new_node(gc_state_cmp,  old_ctrl);
 891   phase-&gt;register_new_node(gc_state_bool, old_ctrl);
 892 
 893   phase-&gt;set_ctrl(gc_state_offset, phase-&gt;C-&gt;root());
 894 
 895   assert(is_gc_state_test(gc_state_iff, flags), &quot;Should match the shape&quot;);
 896 }
 897 
 898 void ShenandoahBarrierC2Support::test_null(Node*&amp; ctrl, Node* val, Node*&amp; null_ctrl, PhaseIdealLoop* phase) {
 899   Node* old_ctrl = ctrl;
 900   PhaseIterGVN&amp; igvn = phase-&gt;igvn();
 901 
 902   const Type* val_t = igvn.type(val);
 903   if (val_t-&gt;meet(TypePtr::NULL_PTR) == val_t) {
 904     Node* null_cmp   = new CmpPNode(val, igvn.zerocon(T_OBJECT));
 905     Node* null_test  = new BoolNode(null_cmp, BoolTest::ne);
 906 
 907     IfNode* null_iff = new IfNode(old_ctrl, null_test, PROB_LIKELY(0.999), COUNT_UNKNOWN);
 908     ctrl             = new IfTrueNode(null_iff);
 909     null_ctrl        = new IfFalseNode(null_iff);
 910 
 911     IdealLoopTree* loop = phase-&gt;get_loop(old_ctrl);
 912     phase-&gt;register_control(null_iff,  loop, old_ctrl);
 913     phase-&gt;register_control(ctrl,      loop, null_iff);
 914     phase-&gt;register_control(null_ctrl, loop, null_iff);
 915 
 916     phase-&gt;register_new_node(null_cmp,  old_ctrl);
 917     phase-&gt;register_new_node(null_test, old_ctrl);
 918   }
 919 }
 920 
 921 void ShenandoahBarrierC2Support::test_in_cset(Node*&amp; ctrl, Node*&amp; not_cset_ctrl, Node* val, Node* raw_mem, PhaseIdealLoop* phase) {
 922   Node* old_ctrl = ctrl;
 923   PhaseIterGVN&amp; igvn = phase-&gt;igvn();
 924 
 925   Node* raw_val        = new CastP2XNode(old_ctrl, val);
 926   Node* cset_idx       = new URShiftXNode(raw_val, igvn.intcon(ShenandoahHeapRegion::region_size_bytes_shift_jint()));
<a name="1" id="anc1"></a><span class="line-modified"> 927   Node* cset_addr      = igvn.makecon(TypeRawPtr::make(ShenandoahHeap::in_cset_fast_test_addr()));</span>
<span class="line-modified"> 928   Node* cset_load_addr = new AddPNode(phase-&gt;C-&gt;top(), cset_addr, cset_idx);</span>
<span class="line-modified"> 929   Node* cset_load      = new LoadBNode(old_ctrl, raw_mem, cset_load_addr,</span>







 930                                        DEBUG_ONLY(phase-&gt;C-&gt;get_adr_type(Compile::AliasIdxRaw)) NOT_DEBUG(NULL),
 931                                        TypeInt::BYTE, MemNode::unordered);
 932   Node* cset_cmp       = new CmpINode(cset_load, igvn.zerocon(T_INT));
 933   Node* cset_bool      = new BoolNode(cset_cmp, BoolTest::ne);
 934 
 935   IfNode* cset_iff     = new IfNode(old_ctrl, cset_bool, PROB_UNLIKELY(0.999), COUNT_UNKNOWN);
 936   ctrl                 = new IfTrueNode(cset_iff);
 937   not_cset_ctrl        = new IfFalseNode(cset_iff);
 938 
 939   IdealLoopTree *loop = phase-&gt;get_loop(old_ctrl);
 940   phase-&gt;register_control(cset_iff,      loop, old_ctrl);
 941   phase-&gt;register_control(ctrl,          loop, cset_iff);
 942   phase-&gt;register_control(not_cset_ctrl, loop, cset_iff);
 943 
<a name="2" id="anc2"></a><span class="line-modified"> 944   phase-&gt;set_ctrl(cset_addr, phase-&gt;C-&gt;root());</span>
 945 
 946   phase-&gt;register_new_node(raw_val,        old_ctrl);
 947   phase-&gt;register_new_node(cset_idx,       old_ctrl);
<a name="3" id="anc3"></a>
 948   phase-&gt;register_new_node(cset_load_addr, old_ctrl);
<a name="4" id="anc4"></a>
 949   phase-&gt;register_new_node(cset_load,      old_ctrl);
 950   phase-&gt;register_new_node(cset_cmp,       old_ctrl);
 951   phase-&gt;register_new_node(cset_bool,      old_ctrl);
 952 }
 953 
 954 void ShenandoahBarrierC2Support::call_lrb_stub(Node*&amp; ctrl, Node*&amp; val, Node* load_addr, Node*&amp; result_mem, Node* raw_mem, bool is_native, PhaseIdealLoop* phase) {
 955   IdealLoopTree*loop = phase-&gt;get_loop(ctrl);
 956   const TypePtr* obj_type = phase-&gt;igvn().type(val)-&gt;is_oopptr();
 957 
 958   // The slow path stub consumes and produces raw memory in addition
 959   // to the existing memory edges
 960   Node* base = find_bottom_mem(ctrl, phase);
 961   MergeMemNode* mm = MergeMemNode::make(base);
 962   mm-&gt;set_memory_at(Compile::AliasIdxRaw, raw_mem);
 963   phase-&gt;register_new_node(mm, ctrl);
 964 
 965   address target = LP64_ONLY(UseCompressedOops) NOT_LP64(false) ?
 966           CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_narrow) :
 967           CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier);
 968 
 969   address calladdr = is_native ? CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_native)
 970                                : target;
 971   const char* name = is_native ? &quot;load_reference_barrier_native&quot; : &quot;load_reference_barrier&quot;;
 972   Node* call = new CallLeafNode(ShenandoahBarrierSetC2::shenandoah_load_reference_barrier_Type(), calladdr, name, TypeRawPtr::BOTTOM);
 973 
 974   call-&gt;init_req(TypeFunc::Control, ctrl);
 975   call-&gt;init_req(TypeFunc::I_O, phase-&gt;C-&gt;top());
 976   call-&gt;init_req(TypeFunc::Memory, mm);
 977   call-&gt;init_req(TypeFunc::FramePtr, phase-&gt;C-&gt;top());
 978   call-&gt;init_req(TypeFunc::ReturnAdr, phase-&gt;C-&gt;top());
 979   call-&gt;init_req(TypeFunc::Parms, val);
 980   call-&gt;init_req(TypeFunc::Parms+1, load_addr);
 981   phase-&gt;register_control(call, loop, ctrl);
 982   ctrl = new ProjNode(call, TypeFunc::Control);
 983   phase-&gt;register_control(ctrl, loop, call);
 984   result_mem = new ProjNode(call, TypeFunc::Memory);
 985   phase-&gt;register_new_node(result_mem, call);
 986   val = new ProjNode(call, TypeFunc::Parms);
 987   phase-&gt;register_new_node(val, call);
 988   val = new CheckCastPPNode(ctrl, val, obj_type);
 989   phase-&gt;register_new_node(val, ctrl);
 990 }
 991 
 992 void ShenandoahBarrierC2Support::fix_ctrl(Node* barrier, Node* region, const MemoryGraphFixer&amp; fixer, Unique_Node_List&amp; uses, Unique_Node_List&amp; uses_to_ignore, uint last, PhaseIdealLoop* phase) {
 993   Node* ctrl = phase-&gt;get_ctrl(barrier);
 994   Node* init_raw_mem = fixer.find_mem(ctrl, barrier);
 995 
 996   // Update the control of all nodes that should be after the
 997   // barrier control flow
 998   uses.clear();
 999   // Every node that is control dependent on the barrier&#39;s input
1000   // control will be after the expanded barrier. The raw memory (if
1001   // its memory is control dependent on the barrier&#39;s input control)
1002   // must stay above the barrier.
1003   uses_to_ignore.clear();
1004   if (phase-&gt;has_ctrl(init_raw_mem) &amp;&amp; phase-&gt;get_ctrl(init_raw_mem) == ctrl &amp;&amp; !init_raw_mem-&gt;is_Phi()) {
1005     uses_to_ignore.push(init_raw_mem);
1006   }
1007   for (uint next = 0; next &lt; uses_to_ignore.size(); next++) {
1008     Node *n = uses_to_ignore.at(next);
1009     for (uint i = 0; i &lt; n-&gt;req(); i++) {
1010       Node* in = n-&gt;in(i);
1011       if (in != NULL &amp;&amp; phase-&gt;has_ctrl(in) &amp;&amp; phase-&gt;get_ctrl(in) == ctrl) {
1012         uses_to_ignore.push(in);
1013       }
1014     }
1015   }
1016   for (DUIterator_Fast imax, i = ctrl-&gt;fast_outs(imax); i &lt; imax; i++) {
1017     Node* u = ctrl-&gt;fast_out(i);
1018     if (u-&gt;_idx &lt; last &amp;&amp;
1019         u != barrier &amp;&amp;
1020         !uses_to_ignore.member(u) &amp;&amp;
1021         (u-&gt;in(0) != ctrl || (!u-&gt;is_Region() &amp;&amp; !u-&gt;is_Phi())) &amp;&amp;
1022         (ctrl-&gt;Opcode() != Op_CatchProj || u-&gt;Opcode() != Op_CreateEx)) {
1023       Node* old_c = phase-&gt;ctrl_or_self(u);
1024       Node* c = old_c;
1025       if (c != ctrl ||
1026           is_dominator_same_ctrl(old_c, barrier, u, phase) ||
1027           ShenandoahBarrierSetC2::is_shenandoah_state_load(u)) {
1028         phase-&gt;igvn().rehash_node_delayed(u);
1029         int nb = u-&gt;replace_edge(ctrl, region);
1030         if (u-&gt;is_CFG()) {
1031           if (phase-&gt;idom(u) == ctrl) {
1032             phase-&gt;set_idom(u, region, phase-&gt;dom_depth(region));
1033           }
1034         } else if (phase-&gt;get_ctrl(u) == ctrl) {
1035           assert(u != init_raw_mem, &quot;should leave input raw mem above the barrier&quot;);
1036           uses.push(u);
1037         }
1038         assert(nb == 1, &quot;more than 1 ctrl input?&quot;);
1039         --i, imax -= nb;
1040       }
1041     }
1042   }
1043 }
1044 
1045 static Node* create_phis_on_call_return(Node* ctrl, Node* c, Node* n, Node* n_clone, const CallProjections&amp; projs, PhaseIdealLoop* phase) {
1046   Node* region = NULL;
1047   while (c != ctrl) {
1048     if (c-&gt;is_Region()) {
1049       region = c;
1050     }
1051     c = phase-&gt;idom(c);
1052   }
1053   assert(region != NULL, &quot;&quot;);
1054   Node* phi = new PhiNode(region, n-&gt;bottom_type());
1055   for (uint j = 1; j &lt; region-&gt;req(); j++) {
1056     Node* in = region-&gt;in(j);
1057     if (phase-&gt;is_dominator(projs.fallthrough_catchproj, in)) {
1058       phi-&gt;init_req(j, n);
1059     } else if (phase-&gt;is_dominator(projs.catchall_catchproj, in)) {
1060       phi-&gt;init_req(j, n_clone);
1061     } else {
1062       phi-&gt;init_req(j, create_phis_on_call_return(ctrl, in, n, n_clone, projs, phase));
1063     }
1064   }
1065   phase-&gt;register_new_node(phi, region);
1066   return phi;
1067 }
1068 
1069 void ShenandoahBarrierC2Support::pin_and_expand(PhaseIdealLoop* phase) {
1070   ShenandoahBarrierSetC2State* state = ShenandoahBarrierSetC2::bsc2()-&gt;state();
1071 
1072   Unique_Node_List uses;
1073   for (int i = 0; i &lt; state-&gt;enqueue_barriers_count(); i++) {
1074     Node* barrier = state-&gt;enqueue_barrier(i);
1075     Node* ctrl = phase-&gt;get_ctrl(barrier);
1076     IdealLoopTree* loop = phase-&gt;get_loop(ctrl);
1077     if (loop-&gt;_head-&gt;is_OuterStripMinedLoop()) {
1078       // Expanding a barrier here will break loop strip mining
1079       // verification. Transform the loop so the loop nest doesn&#39;t
1080       // appear as strip mined.
1081       OuterStripMinedLoopNode* outer = loop-&gt;_head-&gt;as_OuterStripMinedLoop();
1082       hide_strip_mined_loop(outer, outer-&gt;unique_ctrl_out()-&gt;as_CountedLoop(), phase);
1083     }
1084   }
1085 
1086   Node_Stack stack(0);
1087   Node_List clones;
1088   for (int i = state-&gt;load_reference_barriers_count() - 1; i &gt;= 0; i--) {
1089     ShenandoahLoadReferenceBarrierNode* lrb = state-&gt;load_reference_barrier(i);
<a name="5" id="anc5"></a><span class="line-removed">1090     if (lrb-&gt;is_redundant()) {</span>
<span class="line-removed">1091       continue;</span>
<span class="line-removed">1092     }</span>
1093 
1094     Node* ctrl = phase-&gt;get_ctrl(lrb);
1095     Node* val = lrb-&gt;in(ShenandoahLoadReferenceBarrierNode::ValueIn);
1096 
1097     CallStaticJavaNode* unc = NULL;
1098     Node* unc_ctrl = NULL;
1099     Node* uncasted_val = val;
1100 
1101     for (DUIterator_Fast imax, i = lrb-&gt;fast_outs(imax); i &lt; imax; i++) {
1102       Node* u = lrb-&gt;fast_out(i);
1103       if (u-&gt;Opcode() == Op_CastPP &amp;&amp;
1104           u-&gt;in(0) != NULL &amp;&amp;
1105           phase-&gt;is_dominator(u-&gt;in(0), ctrl)) {
1106         const Type* u_t = phase-&gt;igvn().type(u);
1107 
1108         if (u_t-&gt;meet(TypePtr::NULL_PTR) != u_t &amp;&amp;
1109             u-&gt;in(0)-&gt;Opcode() == Op_IfTrue &amp;&amp;
1110             u-&gt;in(0)-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none) &amp;&amp;
1111             u-&gt;in(0)-&gt;in(0)-&gt;is_If() &amp;&amp;
1112             u-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;Opcode() == Op_Bool &amp;&amp;
1113             u-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;as_Bool()-&gt;_test._test == BoolTest::ne &amp;&amp;
1114             u-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;Opcode() == Op_CmpP &amp;&amp;
1115             u-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(1) == val &amp;&amp;
1116             u-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(2)-&gt;bottom_type() == TypePtr::NULL_PTR) {
1117           IdealLoopTree* loop = phase-&gt;get_loop(ctrl);
1118           IdealLoopTree* unc_loop = phase-&gt;get_loop(u-&gt;in(0));
1119 
1120           if (!unc_loop-&gt;is_member(loop)) {
1121             continue;
1122           }
1123 
1124           Node* branch = no_branches(ctrl, u-&gt;in(0), false, phase);
1125           assert(branch == NULL || branch == NodeSentinel, &quot;was not looking for a branch&quot;);
1126           if (branch == NodeSentinel) {
1127             continue;
1128           }
1129 
1130           Node* iff = u-&gt;in(0)-&gt;in(0);
1131           Node* bol = iff-&gt;in(1)-&gt;clone();
1132           Node* cmp = bol-&gt;in(1)-&gt;clone();
1133           cmp-&gt;set_req(1, lrb);
1134           bol-&gt;set_req(1, cmp);
1135           phase-&gt;igvn().replace_input_of(iff, 1, bol);
1136           phase-&gt;set_ctrl(lrb, iff-&gt;in(0));
1137           phase-&gt;register_new_node(cmp, iff-&gt;in(0));
1138           phase-&gt;register_new_node(bol, iff-&gt;in(0));
1139           break;
1140         }
1141       }
1142     }
1143     if ((ctrl-&gt;is_Proj() &amp;&amp; ctrl-&gt;in(0)-&gt;is_CallJava()) || ctrl-&gt;is_CallJava()) {
1144       CallNode* call = ctrl-&gt;is_Proj() ? ctrl-&gt;in(0)-&gt;as_CallJava() : ctrl-&gt;as_CallJava();
1145       if (call-&gt;entry_point() == OptoRuntime::rethrow_stub()) {
1146         // The rethrow call may have too many projections to be
1147         // properly handled here. Given there&#39;s no reason for a
1148         // barrier to depend on the call, move it above the call
1149         stack.push(lrb, 0);
1150         do {
1151           Node* n = stack.node();
1152           uint idx = stack.index();
1153           if (idx &lt; n-&gt;req()) {
1154             Node* in = n-&gt;in(idx);
1155             stack.set_index(idx+1);
1156             if (in != NULL) {
1157               if (phase-&gt;has_ctrl(in)) {
1158                 if (phase-&gt;is_dominator(call, phase-&gt;get_ctrl(in))) {
1159 #ifdef ASSERT
1160                   for (uint i = 0; i &lt; stack.size(); i++) {
1161                     assert(stack.node_at(i) != in, &quot;node shouldn&#39;t have been seen yet&quot;);
1162                   }
1163 #endif
1164                   stack.push(in, 0);
1165                 }
1166               } else {
1167                 assert(phase-&gt;is_dominator(in, call-&gt;in(0)), &quot;no dependency on the call&quot;);
1168               }
1169             }
1170           } else {
1171             phase-&gt;set_ctrl(n, call-&gt;in(0));
1172             stack.pop();
1173           }
1174         } while(stack.size() &gt; 0);
1175         continue;
1176       }
1177       CallProjections projs;
1178       call-&gt;extract_projections(&amp;projs, false, false);
1179 
1180 #ifdef ASSERT
1181       VectorSet cloned(Thread::current()-&gt;resource_area());
1182 #endif
1183       Node* lrb_clone = lrb-&gt;clone();
1184       phase-&gt;register_new_node(lrb_clone, projs.catchall_catchproj);
1185       phase-&gt;set_ctrl(lrb, projs.fallthrough_catchproj);
1186 
1187       stack.push(lrb, 0);
1188       clones.push(lrb_clone);
1189 
1190       do {
1191         assert(stack.size() == clones.size(), &quot;&quot;);
1192         Node* n = stack.node();
1193 #ifdef ASSERT
1194         if (n-&gt;is_Load()) {
1195           Node* mem = n-&gt;in(MemNode::Memory);
1196           for (DUIterator_Fast jmax, j = mem-&gt;fast_outs(jmax); j &lt; jmax; j++) {
1197             Node* u = mem-&gt;fast_out(j);
1198             assert(!u-&gt;is_Store() || !u-&gt;is_LoadStore() || phase-&gt;get_ctrl(u) != ctrl, &quot;anti dependent store?&quot;);
1199           }
1200         }
1201 #endif
1202         uint idx = stack.index();
1203         Node* n_clone = clones.at(clones.size()-1);
1204         if (idx &lt; n-&gt;outcnt()) {
1205           Node* u = n-&gt;raw_out(idx);
1206           Node* c = phase-&gt;ctrl_or_self(u);
1207           if (phase-&gt;is_dominator(call, c) &amp;&amp; phase-&gt;is_dominator(c, projs.fallthrough_proj)) {
1208             stack.set_index(idx+1);
1209             assert(!u-&gt;is_CFG(), &quot;&quot;);
1210             stack.push(u, 0);
1211             assert(!cloned.test_set(u-&gt;_idx), &quot;only one clone&quot;);
1212             Node* u_clone = u-&gt;clone();
1213             int nb = u_clone-&gt;replace_edge(n, n_clone);
1214             assert(nb &gt; 0, &quot;should have replaced some uses&quot;);
1215             phase-&gt;register_new_node(u_clone, projs.catchall_catchproj);
1216             clones.push(u_clone);
1217             phase-&gt;set_ctrl(u, projs.fallthrough_catchproj);
1218           } else {
1219             bool replaced = false;
1220             if (u-&gt;is_Phi()) {
1221               for (uint k = 1; k &lt; u-&gt;req(); k++) {
1222                 if (u-&gt;in(k) == n) {
1223                   if (phase-&gt;is_dominator(projs.catchall_catchproj, u-&gt;in(0)-&gt;in(k))) {
1224                     phase-&gt;igvn().replace_input_of(u, k, n_clone);
1225                     replaced = true;
1226                   } else if (!phase-&gt;is_dominator(projs.fallthrough_catchproj, u-&gt;in(0)-&gt;in(k))) {
1227                     phase-&gt;igvn().replace_input_of(u, k, create_phis_on_call_return(ctrl, u-&gt;in(0)-&gt;in(k), n, n_clone, projs, phase));
1228                     replaced = true;
1229                   }
1230                 }
1231               }
1232             } else {
1233               if (phase-&gt;is_dominator(projs.catchall_catchproj, c)) {
1234                 phase-&gt;igvn().rehash_node_delayed(u);
1235                 int nb = u-&gt;replace_edge(n, n_clone);
1236                 assert(nb &gt; 0, &quot;should have replaced some uses&quot;);
1237                 replaced = true;
1238               } else if (!phase-&gt;is_dominator(projs.fallthrough_catchproj, c)) {
1239                 if (u-&gt;is_If()) {
1240                   // Can&#39;t break If/Bool/Cmp chain
1241                   assert(n-&gt;is_Bool(), &quot;unexpected If shape&quot;);
1242                   assert(stack.node_at(stack.size()-2)-&gt;is_Cmp(), &quot;unexpected If shape&quot;);
1243                   assert(n_clone-&gt;is_Bool(), &quot;unexpected clone&quot;);
1244                   assert(clones.at(clones.size()-2)-&gt;is_Cmp(), &quot;unexpected clone&quot;);
1245                   Node* bol_clone = n-&gt;clone();
1246                   Node* cmp_clone = stack.node_at(stack.size()-2)-&gt;clone();
1247                   bol_clone-&gt;set_req(1, cmp_clone);
1248 
1249                   Node* nn = stack.node_at(stack.size()-3);
1250                   Node* nn_clone = clones.at(clones.size()-3);
1251                   assert(nn-&gt;Opcode() == nn_clone-&gt;Opcode(), &quot;mismatch&quot;);
1252 
1253                   int nb = cmp_clone-&gt;replace_edge(nn, create_phis_on_call_return(ctrl, c, nn, nn_clone, projs, phase));
1254                   assert(nb &gt; 0, &quot;should have replaced some uses&quot;);
1255 
1256                   phase-&gt;register_new_node(bol_clone, u-&gt;in(0));
1257                   phase-&gt;register_new_node(cmp_clone, u-&gt;in(0));
1258 
1259                   phase-&gt;igvn().replace_input_of(u, 1, bol_clone);
1260 
1261                 } else {
1262                   phase-&gt;igvn().rehash_node_delayed(u);
1263                   int nb = u-&gt;replace_edge(n, create_phis_on_call_return(ctrl, c, n, n_clone, projs, phase));
1264                   assert(nb &gt; 0, &quot;should have replaced some uses&quot;);
1265                 }
1266                 replaced = true;
1267               }
1268             }
1269             if (!replaced) {
1270               stack.set_index(idx+1);
1271             }
1272           }
1273         } else {
1274           stack.pop();
1275           clones.pop();
1276         }
1277       } while (stack.size() &gt; 0);
1278       assert(stack.size() == 0 &amp;&amp; clones.size() == 0, &quot;&quot;);
1279     }
1280   }
1281 
1282   for (int i = 0; i &lt; state-&gt;load_reference_barriers_count(); i++) {
1283     ShenandoahLoadReferenceBarrierNode* lrb = state-&gt;load_reference_barrier(i);
<a name="6" id="anc6"></a><span class="line-removed">1284     if (lrb-&gt;is_redundant()) {</span>
<span class="line-removed">1285       continue;</span>
<span class="line-removed">1286     }</span>
1287     Node* ctrl = phase-&gt;get_ctrl(lrb);
1288     IdealLoopTree* loop = phase-&gt;get_loop(ctrl);
1289     if (loop-&gt;_head-&gt;is_OuterStripMinedLoop()) {
1290       // Expanding a barrier here will break loop strip mining
1291       // verification. Transform the loop so the loop nest doesn&#39;t
1292       // appear as strip mined.
1293       OuterStripMinedLoopNode* outer = loop-&gt;_head-&gt;as_OuterStripMinedLoop();
1294       hide_strip_mined_loop(outer, outer-&gt;unique_ctrl_out()-&gt;as_CountedLoop(), phase);
1295     }
1296   }
1297 
1298   // Expand load-reference-barriers
1299   MemoryGraphFixer fixer(Compile::AliasIdxRaw, true, phase);
1300   Unique_Node_List uses_to_ignore;
1301   for (int i = state-&gt;load_reference_barriers_count() - 1; i &gt;= 0; i--) {
1302     ShenandoahLoadReferenceBarrierNode* lrb = state-&gt;load_reference_barrier(i);
<a name="7" id="anc7"></a><span class="line-removed">1303     if (lrb-&gt;is_redundant()) {</span>
<span class="line-removed">1304       phase-&gt;igvn().replace_node(lrb, lrb-&gt;in(ShenandoahLoadReferenceBarrierNode::ValueIn));</span>
<span class="line-removed">1305       continue;</span>
<span class="line-removed">1306     }</span>
1307     uint last = phase-&gt;C-&gt;unique();
1308     Node* ctrl = phase-&gt;get_ctrl(lrb);
1309     Node* val = lrb-&gt;in(ShenandoahLoadReferenceBarrierNode::ValueIn);
1310 
1311 
1312     Node* orig_ctrl = ctrl;
1313 
1314     Node* raw_mem = fixer.find_mem(ctrl, lrb);
1315     Node* init_raw_mem = raw_mem;
1316     Node* raw_mem_for_ctrl = fixer.find_mem(ctrl, NULL);
1317 
1318     IdealLoopTree *loop = phase-&gt;get_loop(ctrl);
1319 
1320     Node* heap_stable_ctrl = NULL;
1321     Node* null_ctrl = NULL;
1322 
1323     assert(val-&gt;bottom_type()-&gt;make_oopptr(), &quot;need oop&quot;);
1324     assert(val-&gt;bottom_type()-&gt;make_oopptr()-&gt;const_oop() == NULL, &quot;expect non-constant&quot;);
1325 
1326     enum { _heap_stable = 1, _not_cset, _evac_path, PATH_LIMIT };
1327     Node* region = new RegionNode(PATH_LIMIT);
1328     Node* val_phi = new PhiNode(region, val-&gt;bottom_type()-&gt;is_oopptr());
1329     Node* raw_mem_phi = PhiNode::make(region, raw_mem, Type::MEMORY, TypeRawPtr::BOTTOM);
1330 
1331     // Stable path.
1332     test_gc_state(ctrl, raw_mem, heap_stable_ctrl, phase, ShenandoahHeap::HAS_FORWARDED);
1333     IfNode* heap_stable_iff = heap_stable_ctrl-&gt;in(0)-&gt;as_If();
1334 
1335     // Heap stable case
1336     region-&gt;init_req(_heap_stable, heap_stable_ctrl);
1337     val_phi-&gt;init_req(_heap_stable, val);
1338     raw_mem_phi-&gt;init_req(_heap_stable, raw_mem);
1339 
1340     // Test for in-cset.
1341     // Wires !in_cset(obj) to slot 2 of region and phis
1342     Node* not_cset_ctrl = NULL;
1343     test_in_cset(ctrl, not_cset_ctrl, val, raw_mem, phase);
1344     if (not_cset_ctrl != NULL) {
1345       region-&gt;init_req(_not_cset, not_cset_ctrl);
1346       val_phi-&gt;init_req(_not_cset, val);
1347       raw_mem_phi-&gt;init_req(_not_cset, raw_mem);
1348     }
1349 
1350     // Resolve object when orig-value is in cset.
1351     // Make the unconditional resolve for fwdptr.
1352 
1353     // Call lrb-stub and wire up that path in slots 4
1354     Node* result_mem = NULL;
1355 
1356     Node* addr;
1357     if (ShenandoahSelfFixing) {
1358       VectorSet visited(Thread::current()-&gt;resource_area());
1359       addr = get_load_addr(phase, visited, lrb);
1360     } else {
1361       addr = phase-&gt;igvn().zerocon(T_OBJECT);
1362     }
1363     if (addr-&gt;Opcode() == Op_AddP) {
1364       Node* orig_base = addr-&gt;in(AddPNode::Base);
1365       Node* base = new CheckCastPPNode(ctrl, orig_base, orig_base-&gt;bottom_type(), true);
1366       phase-&gt;register_new_node(base, ctrl);
1367       if (addr-&gt;in(AddPNode::Base) == addr-&gt;in((AddPNode::Address))) {
1368         // Field access
1369         addr = addr-&gt;clone();
1370         addr-&gt;set_req(AddPNode::Base, base);
1371         addr-&gt;set_req(AddPNode::Address, base);
1372         phase-&gt;register_new_node(addr, ctrl);
1373       } else {
1374         Node* addr2 = addr-&gt;in(AddPNode::Address);
1375         if (addr2-&gt;Opcode() == Op_AddP &amp;&amp; addr2-&gt;in(AddPNode::Base) == addr2-&gt;in(AddPNode::Address) &amp;&amp;
1376               addr2-&gt;in(AddPNode::Base) == orig_base) {
1377           addr2 = addr2-&gt;clone();
1378           addr2-&gt;set_req(AddPNode::Base, base);
1379           addr2-&gt;set_req(AddPNode::Address, base);
1380           phase-&gt;register_new_node(addr2, ctrl);
1381           addr = addr-&gt;clone();
1382           addr-&gt;set_req(AddPNode::Base, base);
1383           addr-&gt;set_req(AddPNode::Address, addr2);
1384           phase-&gt;register_new_node(addr, ctrl);
1385         }
1386       }
1387     }
1388     call_lrb_stub(ctrl, val, addr, result_mem, raw_mem, lrb-&gt;is_native(), phase);
1389     region-&gt;init_req(_evac_path, ctrl);
1390     val_phi-&gt;init_req(_evac_path, val);
1391     raw_mem_phi-&gt;init_req(_evac_path, result_mem);
1392 
1393     phase-&gt;register_control(region, loop, heap_stable_iff);
1394     Node* out_val = val_phi;
1395     phase-&gt;register_new_node(val_phi, region);
1396     phase-&gt;register_new_node(raw_mem_phi, region);
1397 
1398     fix_ctrl(lrb, region, fixer, uses, uses_to_ignore, last, phase);
1399 
1400     ctrl = orig_ctrl;
1401 
1402     phase-&gt;igvn().replace_node(lrb, out_val);
1403 
1404     follow_barrier_uses(out_val, ctrl, uses, phase);
1405 
1406     for(uint next = 0; next &lt; uses.size(); next++ ) {
1407       Node *n = uses.at(next);
1408       assert(phase-&gt;get_ctrl(n) == ctrl, &quot;bad control&quot;);
1409       assert(n != init_raw_mem, &quot;should leave input raw mem above the barrier&quot;);
1410       phase-&gt;set_ctrl(n, region);
1411       follow_barrier_uses(n, ctrl, uses, phase);
1412     }
1413 
1414     // The slow path call produces memory: hook the raw memory phi
1415     // from the expanded load reference barrier with the rest of the graph
1416     // which may require adding memory phis at every post dominated
1417     // region and at enclosing loop heads. Use the memory state
1418     // collected in memory_nodes to fix the memory graph. Update that
1419     // memory state as we go.
1420     fixer.fix_mem(ctrl, region, init_raw_mem, raw_mem_for_ctrl, raw_mem_phi, uses);
1421   }
1422   // Done expanding load-reference-barriers.
1423   assert(ShenandoahBarrierSetC2::bsc2()-&gt;state()-&gt;load_reference_barriers_count() == 0, &quot;all load reference barrier nodes should have been replaced&quot;);
1424 
1425   for (int i = state-&gt;enqueue_barriers_count() - 1; i &gt;= 0; i--) {
1426     Node* barrier = state-&gt;enqueue_barrier(i);
1427     Node* pre_val = barrier-&gt;in(1);
1428 
1429     if (phase-&gt;igvn().type(pre_val)-&gt;higher_equal(TypePtr::NULL_PTR)) {
1430       ShouldNotReachHere();
1431       continue;
1432     }
1433 
1434     Node* ctrl = phase-&gt;get_ctrl(barrier);
1435 
1436     if (ctrl-&gt;is_Proj() &amp;&amp; ctrl-&gt;in(0)-&gt;is_CallJava()) {
1437       assert(is_dominator(phase-&gt;get_ctrl(pre_val), ctrl-&gt;in(0)-&gt;in(0), pre_val, ctrl-&gt;in(0), phase), &quot;can&#39;t move&quot;);
1438       ctrl = ctrl-&gt;in(0)-&gt;in(0);
1439       phase-&gt;set_ctrl(barrier, ctrl);
1440     } else if (ctrl-&gt;is_CallRuntime()) {
1441       assert(is_dominator(phase-&gt;get_ctrl(pre_val), ctrl-&gt;in(0), pre_val, ctrl, phase), &quot;can&#39;t move&quot;);
1442       ctrl = ctrl-&gt;in(0);
1443       phase-&gt;set_ctrl(barrier, ctrl);
1444     }
1445 
1446     Node* init_ctrl = ctrl;
1447     IdealLoopTree* loop = phase-&gt;get_loop(ctrl);
1448     Node* raw_mem = fixer.find_mem(ctrl, barrier);
1449     Node* init_raw_mem = raw_mem;
1450     Node* raw_mem_for_ctrl = fixer.find_mem(ctrl, NULL);
1451     Node* heap_stable_ctrl = NULL;
1452     Node* null_ctrl = NULL;
1453     uint last = phase-&gt;C-&gt;unique();
1454 
1455     enum { _heap_stable = 1, _heap_unstable, PATH_LIMIT };
1456     Node* region = new RegionNode(PATH_LIMIT);
1457     Node* phi = PhiNode::make(region, raw_mem, Type::MEMORY, TypeRawPtr::BOTTOM);
1458 
1459     enum { _fast_path = 1, _slow_path, _null_path, PATH_LIMIT2 };
1460     Node* region2 = new RegionNode(PATH_LIMIT2);
1461     Node* phi2 = PhiNode::make(region2, raw_mem, Type::MEMORY, TypeRawPtr::BOTTOM);
1462 
1463     // Stable path.
1464     test_gc_state(ctrl, raw_mem, heap_stable_ctrl, phase, ShenandoahHeap::MARKING);
1465     region-&gt;init_req(_heap_stable, heap_stable_ctrl);
1466     phi-&gt;init_req(_heap_stable, raw_mem);
1467 
1468     // Null path
1469     Node* reg2_ctrl = NULL;
1470     test_null(ctrl, pre_val, null_ctrl, phase);
1471     if (null_ctrl != NULL) {
1472       reg2_ctrl = null_ctrl-&gt;in(0);
1473       region2-&gt;init_req(_null_path, null_ctrl);
1474       phi2-&gt;init_req(_null_path, raw_mem);
1475     } else {
1476       region2-&gt;del_req(_null_path);
1477       phi2-&gt;del_req(_null_path);
1478     }
1479 
1480     const int index_offset = in_bytes(ShenandoahThreadLocalData::satb_mark_queue_index_offset());
1481     const int buffer_offset = in_bytes(ShenandoahThreadLocalData::satb_mark_queue_buffer_offset());
1482     Node* thread = new ThreadLocalNode();
1483     phase-&gt;register_new_node(thread, ctrl);
1484     Node* buffer_adr = new AddPNode(phase-&gt;C-&gt;top(), thread, phase-&gt;igvn().MakeConX(buffer_offset));
1485     phase-&gt;register_new_node(buffer_adr, ctrl);
1486     Node* index_adr = new AddPNode(phase-&gt;C-&gt;top(), thread, phase-&gt;igvn().MakeConX(index_offset));
1487     phase-&gt;register_new_node(index_adr, ctrl);
1488 
1489     BasicType index_bt = TypeX_X-&gt;basic_type();
1490     assert(sizeof(size_t) == type2aelembytes(index_bt), &quot;Loading G1 SATBMarkQueue::_index with wrong size.&quot;);
1491     const TypePtr* adr_type = TypeRawPtr::BOTTOM;
1492     Node* index = new LoadXNode(ctrl, raw_mem, index_adr, adr_type, TypeX_X, MemNode::unordered);
1493     phase-&gt;register_new_node(index, ctrl);
1494     Node* index_cmp = new CmpXNode(index, phase-&gt;igvn().MakeConX(0));
1495     phase-&gt;register_new_node(index_cmp, ctrl);
1496     Node* index_test = new BoolNode(index_cmp, BoolTest::ne);
1497     phase-&gt;register_new_node(index_test, ctrl);
1498     IfNode* queue_full_iff = new IfNode(ctrl, index_test, PROB_LIKELY(0.999), COUNT_UNKNOWN);
1499     if (reg2_ctrl == NULL) reg2_ctrl = queue_full_iff;
1500     phase-&gt;register_control(queue_full_iff, loop, ctrl);
1501     Node* not_full = new IfTrueNode(queue_full_iff);
1502     phase-&gt;register_control(not_full, loop, queue_full_iff);
1503     Node* full = new IfFalseNode(queue_full_iff);
1504     phase-&gt;register_control(full, loop, queue_full_iff);
1505 
1506     ctrl = not_full;
1507 
1508     Node* next_index = new SubXNode(index, phase-&gt;igvn().MakeConX(sizeof(intptr_t)));
1509     phase-&gt;register_new_node(next_index, ctrl);
1510 
1511     Node* buffer  = new LoadPNode(ctrl, raw_mem, buffer_adr, adr_type, TypeRawPtr::NOTNULL, MemNode::unordered);
1512     phase-&gt;register_new_node(buffer, ctrl);
1513     Node *log_addr = new AddPNode(phase-&gt;C-&gt;top(), buffer, next_index);
1514     phase-&gt;register_new_node(log_addr, ctrl);
1515     Node* log_store = new StorePNode(ctrl, raw_mem, log_addr, adr_type, pre_val, MemNode::unordered);
1516     phase-&gt;register_new_node(log_store, ctrl);
1517     // update the index
1518     Node* index_update = new StoreXNode(ctrl, log_store, index_adr, adr_type, next_index, MemNode::unordered);
1519     phase-&gt;register_new_node(index_update, ctrl);
1520 
1521     // Fast-path case
1522     region2-&gt;init_req(_fast_path, ctrl);
1523     phi2-&gt;init_req(_fast_path, index_update);
1524 
1525     ctrl = full;
1526 
1527     Node* base = find_bottom_mem(ctrl, phase);
1528 
1529     MergeMemNode* mm = MergeMemNode::make(base);
1530     mm-&gt;set_memory_at(Compile::AliasIdxRaw, raw_mem);
1531     phase-&gt;register_new_node(mm, ctrl);
1532 
1533     Node* call = new CallLeafNode(ShenandoahBarrierSetC2::write_ref_field_pre_entry_Type(), CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry), &quot;shenandoah_wb_pre&quot;, TypeRawPtr::BOTTOM);
1534     call-&gt;init_req(TypeFunc::Control, ctrl);
1535     call-&gt;init_req(TypeFunc::I_O, phase-&gt;C-&gt;top());
1536     call-&gt;init_req(TypeFunc::Memory, mm);
1537     call-&gt;init_req(TypeFunc::FramePtr, phase-&gt;C-&gt;top());
1538     call-&gt;init_req(TypeFunc::ReturnAdr, phase-&gt;C-&gt;top());
1539     call-&gt;init_req(TypeFunc::Parms, pre_val);
1540     call-&gt;init_req(TypeFunc::Parms+1, thread);
1541     phase-&gt;register_control(call, loop, ctrl);
1542 
1543     Node* ctrl_proj = new ProjNode(call, TypeFunc::Control);
1544     phase-&gt;register_control(ctrl_proj, loop, call);
1545     Node* mem_proj = new ProjNode(call, TypeFunc::Memory);
1546     phase-&gt;register_new_node(mem_proj, call);
1547 
1548     // Slow-path case
1549     region2-&gt;init_req(_slow_path, ctrl_proj);
1550     phi2-&gt;init_req(_slow_path, mem_proj);
1551 
1552     phase-&gt;register_control(region2, loop, reg2_ctrl);
1553     phase-&gt;register_new_node(phi2, region2);
1554 
1555     region-&gt;init_req(_heap_unstable, region2);
1556     phi-&gt;init_req(_heap_unstable, phi2);
1557 
1558     phase-&gt;register_control(region, loop, heap_stable_ctrl-&gt;in(0));
1559     phase-&gt;register_new_node(phi, region);
1560 
1561     fix_ctrl(barrier, region, fixer, uses, uses_to_ignore, last, phase);
1562     for(uint next = 0; next &lt; uses.size(); next++ ) {
1563       Node *n = uses.at(next);
1564       assert(phase-&gt;get_ctrl(n) == init_ctrl, &quot;bad control&quot;);
1565       assert(n != init_raw_mem, &quot;should leave input raw mem above the barrier&quot;);
1566       phase-&gt;set_ctrl(n, region);
1567       follow_barrier_uses(n, init_ctrl, uses, phase);
1568     }
1569     fixer.fix_mem(init_ctrl, region, init_raw_mem, raw_mem_for_ctrl, phi, uses);
1570 
1571     phase-&gt;igvn().replace_node(barrier, pre_val);
1572   }
1573   assert(state-&gt;enqueue_barriers_count() == 0, &quot;all enqueue barrier nodes should have been replaced&quot;);
1574 
1575 }
1576 
1577 Node* ShenandoahBarrierC2Support::get_load_addr(PhaseIdealLoop* phase, VectorSet&amp; visited, Node* in) {
1578   if (visited.test_set(in-&gt;_idx)) {
1579     return NULL;
1580   }
1581   switch (in-&gt;Opcode()) {
1582     case Op_Proj:
1583       return get_load_addr(phase, visited, in-&gt;in(0));
1584     case Op_CastPP:
1585     case Op_CheckCastPP:
1586     case Op_DecodeN:
1587     case Op_EncodeP:
1588       return get_load_addr(phase, visited, in-&gt;in(1));
1589     case Op_LoadN:
1590     case Op_LoadP:
1591       return in-&gt;in(MemNode::Address);
1592     case Op_CompareAndExchangeN:
1593     case Op_CompareAndExchangeP:
1594     case Op_GetAndSetN:
1595     case Op_GetAndSetP:
1596     case Op_ShenandoahCompareAndExchangeP:
1597     case Op_ShenandoahCompareAndExchangeN:
1598       // Those instructions would just have stored a different
1599       // value into the field. No use to attempt to fix it at this point.
1600       return phase-&gt;igvn().zerocon(T_OBJECT);
1601     case Op_CMoveP:
1602     case Op_CMoveN: {
1603       Node* t = get_load_addr(phase, visited, in-&gt;in(CMoveNode::IfTrue));
1604       Node* f = get_load_addr(phase, visited, in-&gt;in(CMoveNode::IfFalse));
1605       // Handle unambiguous cases: single address reported on both branches.
1606       if (t != NULL &amp;&amp; f == NULL) return t;
1607       if (t == NULL &amp;&amp; f != NULL) return f;
1608       if (t != NULL &amp;&amp; t == f)    return t;
1609       // Ambiguity.
1610       return phase-&gt;igvn().zerocon(T_OBJECT);
1611     }
1612     case Op_Phi: {
1613       Node* addr = NULL;
1614       for (uint i = 1; i &lt; in-&gt;req(); i++) {
1615         Node* addr1 = get_load_addr(phase, visited, in-&gt;in(i));
1616         if (addr == NULL) {
1617           addr = addr1;
1618         }
1619         if (addr != addr1) {
1620           return phase-&gt;igvn().zerocon(T_OBJECT);
1621         }
1622       }
1623       return addr;
1624     }
1625     case Op_ShenandoahLoadReferenceBarrier:
1626       return get_load_addr(phase, visited, in-&gt;in(ShenandoahLoadReferenceBarrierNode::ValueIn));
1627     case Op_ShenandoahEnqueueBarrier:
1628       return get_load_addr(phase, visited, in-&gt;in(1));
1629     case Op_CallDynamicJava:
1630     case Op_CallLeaf:
1631     case Op_CallStaticJava:
1632     case Op_ConN:
1633     case Op_ConP:
1634     case Op_Parm:
1635     case Op_CreateEx:
1636       return phase-&gt;igvn().zerocon(T_OBJECT);
1637     default:
1638 #ifdef ASSERT
1639       fatal(&quot;Unknown node in get_load_addr: %s&quot;, NodeClassNames[in-&gt;Opcode()]);
1640 #endif
1641       return phase-&gt;igvn().zerocon(T_OBJECT);
1642   }
1643 
1644 }
1645 
1646 void ShenandoahBarrierC2Support::move_gc_state_test_out_of_loop(IfNode* iff, PhaseIdealLoop* phase) {
1647   IdealLoopTree *loop = phase-&gt;get_loop(iff);
1648   Node* loop_head = loop-&gt;_head;
1649   Node* entry_c = loop_head-&gt;in(LoopNode::EntryControl);
1650 
1651   Node* bol = iff-&gt;in(1);
1652   Node* cmp = bol-&gt;in(1);
1653   Node* andi = cmp-&gt;in(1);
1654   Node* load = andi-&gt;in(1);
1655 
1656   assert(is_gc_state_load(load), &quot;broken&quot;);
1657   if (!phase-&gt;is_dominator(load-&gt;in(0), entry_c)) {
1658     Node* mem_ctrl = NULL;
1659     Node* mem = dom_mem(load-&gt;in(MemNode::Memory), loop_head, Compile::AliasIdxRaw, mem_ctrl, phase);
1660     load = load-&gt;clone();
1661     load-&gt;set_req(MemNode::Memory, mem);
1662     load-&gt;set_req(0, entry_c);
1663     phase-&gt;register_new_node(load, entry_c);
1664     andi = andi-&gt;clone();
1665     andi-&gt;set_req(1, load);
1666     phase-&gt;register_new_node(andi, entry_c);
1667     cmp = cmp-&gt;clone();
1668     cmp-&gt;set_req(1, andi);
1669     phase-&gt;register_new_node(cmp, entry_c);
1670     bol = bol-&gt;clone();
1671     bol-&gt;set_req(1, cmp);
1672     phase-&gt;register_new_node(bol, entry_c);
1673 
1674     phase-&gt;igvn().replace_input_of(iff, 1, bol);
1675   }
1676 }
1677 
1678 bool ShenandoahBarrierC2Support::identical_backtoback_ifs(Node* n, PhaseIdealLoop* phase) {
1679   if (!n-&gt;is_If() || n-&gt;is_CountedLoopEnd()) {
1680     return false;
1681   }
1682   Node* region = n-&gt;in(0);
1683 
1684   if (!region-&gt;is_Region()) {
1685     return false;
1686   }
1687   Node* dom = phase-&gt;idom(region);
1688   if (!dom-&gt;is_If()) {
1689     return false;
1690   }
1691 
1692   if (!is_heap_stable_test(n) || !is_heap_stable_test(dom)) {
1693     return false;
1694   }
1695 
1696   IfNode* dom_if = dom-&gt;as_If();
1697   Node* proj_true = dom_if-&gt;proj_out(1);
1698   Node* proj_false = dom_if-&gt;proj_out(0);
1699 
1700   for (uint i = 1; i &lt; region-&gt;req(); i++) {
1701     if (phase-&gt;is_dominator(proj_true, region-&gt;in(i))) {
1702       continue;
1703     }
1704     if (phase-&gt;is_dominator(proj_false, region-&gt;in(i))) {
1705       continue;
1706     }
1707     return false;
1708   }
1709 
1710   return true;
1711 }
1712 
1713 void ShenandoahBarrierC2Support::merge_back_to_back_tests(Node* n, PhaseIdealLoop* phase) {
1714   assert(is_heap_stable_test(n), &quot;no other tests&quot;);
1715   if (identical_backtoback_ifs(n, phase)) {
1716     Node* n_ctrl = n-&gt;in(0);
1717     if (phase-&gt;can_split_if(n_ctrl)) {
1718       IfNode* dom_if = phase-&gt;idom(n_ctrl)-&gt;as_If();
1719       if (is_heap_stable_test(n)) {
1720         Node* gc_state_load = n-&gt;in(1)-&gt;in(1)-&gt;in(1)-&gt;in(1);
1721         assert(is_gc_state_load(gc_state_load), &quot;broken&quot;);
1722         Node* dom_gc_state_load = dom_if-&gt;in(1)-&gt;in(1)-&gt;in(1)-&gt;in(1);
1723         assert(is_gc_state_load(dom_gc_state_load), &quot;broken&quot;);
1724         if (gc_state_load != dom_gc_state_load) {
1725           phase-&gt;igvn().replace_node(gc_state_load, dom_gc_state_load);
1726         }
1727       }
1728       PhiNode* bolphi = PhiNode::make_blank(n_ctrl, n-&gt;in(1));
1729       Node* proj_true = dom_if-&gt;proj_out(1);
1730       Node* proj_false = dom_if-&gt;proj_out(0);
1731       Node* con_true = phase-&gt;igvn().makecon(TypeInt::ONE);
1732       Node* con_false = phase-&gt;igvn().makecon(TypeInt::ZERO);
1733 
1734       for (uint i = 1; i &lt; n_ctrl-&gt;req(); i++) {
1735         if (phase-&gt;is_dominator(proj_true, n_ctrl-&gt;in(i))) {
1736           bolphi-&gt;init_req(i, con_true);
1737         } else {
1738           assert(phase-&gt;is_dominator(proj_false, n_ctrl-&gt;in(i)), &quot;bad if&quot;);
1739           bolphi-&gt;init_req(i, con_false);
1740         }
1741       }
1742       phase-&gt;register_new_node(bolphi, n_ctrl);
1743       phase-&gt;igvn().replace_input_of(n, 1, bolphi);
1744       phase-&gt;do_split_if(n);
1745     }
1746   }
1747 }
1748 
1749 IfNode* ShenandoahBarrierC2Support::find_unswitching_candidate(const IdealLoopTree* loop, PhaseIdealLoop* phase) {
1750   // Find first invariant test that doesn&#39;t exit the loop
1751   LoopNode *head = loop-&gt;_head-&gt;as_Loop();
1752   IfNode* unswitch_iff = NULL;
1753   Node* n = head-&gt;in(LoopNode::LoopBackControl);
1754   int loop_has_sfpts = -1;
1755   while (n != head) {
1756     Node* n_dom = phase-&gt;idom(n);
1757     if (n-&gt;is_Region()) {
1758       if (n_dom-&gt;is_If()) {
1759         IfNode* iff = n_dom-&gt;as_If();
1760         if (iff-&gt;in(1)-&gt;is_Bool()) {
1761           BoolNode* bol = iff-&gt;in(1)-&gt;as_Bool();
1762           if (bol-&gt;in(1)-&gt;is_Cmp()) {
1763             // If condition is invariant and not a loop exit,
1764             // then found reason to unswitch.
1765             if (is_heap_stable_test(iff) &amp;&amp;
1766                 (loop_has_sfpts == -1 || loop_has_sfpts == 0)) {
1767               assert(!loop-&gt;is_loop_exit(iff), &quot;both branches should be in the loop&quot;);
1768               if (loop_has_sfpts == -1) {
1769                 for(uint i = 0; i &lt; loop-&gt;_body.size(); i++) {
1770                   Node *m = loop-&gt;_body[i];
1771                   if (m-&gt;is_SafePoint() &amp;&amp; !m-&gt;is_CallLeaf()) {
1772                     loop_has_sfpts = 1;
1773                     break;
1774                   }
1775                 }
1776                 if (loop_has_sfpts == -1) {
1777                   loop_has_sfpts = 0;
1778                 }
1779               }
1780               if (!loop_has_sfpts) {
1781                 unswitch_iff = iff;
1782               }
1783             }
1784           }
1785         }
1786       }
1787     }
1788     n = n_dom;
1789   }
1790   return unswitch_iff;
1791 }
1792 
1793 
1794 void ShenandoahBarrierC2Support::optimize_after_expansion(VectorSet &amp;visited, Node_Stack &amp;stack, Node_List &amp;old_new, PhaseIdealLoop* phase) {
1795   Node_List heap_stable_tests;
1796   stack.push(phase-&gt;C-&gt;start(), 0);
1797   do {
1798     Node* n = stack.node();
1799     uint i = stack.index();
1800 
1801     if (i &lt; n-&gt;outcnt()) {
1802       Node* u = n-&gt;raw_out(i);
1803       stack.set_index(i+1);
1804       if (!visited.test_set(u-&gt;_idx)) {
1805         stack.push(u, 0);
1806       }
1807     } else {
1808       stack.pop();
1809       if (n-&gt;is_If() &amp;&amp; is_heap_stable_test(n)) {
1810         heap_stable_tests.push(n);
1811       }
1812     }
1813   } while (stack.size() &gt; 0);
1814 
1815   for (uint i = 0; i &lt; heap_stable_tests.size(); i++) {
1816     Node* n = heap_stable_tests.at(i);
1817     assert(is_heap_stable_test(n), &quot;only evacuation test&quot;);
1818     merge_back_to_back_tests(n, phase);
1819   }
1820 
1821   if (!phase-&gt;C-&gt;major_progress()) {
1822     VectorSet seen(Thread::current()-&gt;resource_area());
1823     for (uint i = 0; i &lt; heap_stable_tests.size(); i++) {
1824       Node* n = heap_stable_tests.at(i);
1825       IdealLoopTree* loop = phase-&gt;get_loop(n);
1826       if (loop != phase-&gt;ltree_root() &amp;&amp;
1827           loop-&gt;_child == NULL &amp;&amp;
1828           !loop-&gt;_irreducible) {
1829         Node* head = loop-&gt;_head;
1830         if (head-&gt;is_Loop() &amp;&amp;
1831             (!head-&gt;is_CountedLoop() || head-&gt;as_CountedLoop()-&gt;is_main_loop() || head-&gt;as_CountedLoop()-&gt;is_normal_loop()) &amp;&amp;
1832             !seen.test_set(head-&gt;_idx)) {
1833           IfNode* iff = find_unswitching_candidate(loop, phase);
1834           if (iff != NULL) {
1835             Node* bol = iff-&gt;in(1);
1836             if (head-&gt;as_Loop()-&gt;is_strip_mined()) {
1837               head-&gt;as_Loop()-&gt;verify_strip_mined(0);
1838             }
1839             move_gc_state_test_out_of_loop(iff, phase);
1840 
1841             AutoNodeBudget node_budget(phase);
1842 
1843             if (loop-&gt;policy_unswitching(phase)) {
1844               if (head-&gt;as_Loop()-&gt;is_strip_mined()) {
1845                 OuterStripMinedLoopNode* outer = head-&gt;as_CountedLoop()-&gt;outer_loop();
1846                 hide_strip_mined_loop(outer, head-&gt;as_CountedLoop(), phase);
1847               }
1848               phase-&gt;do_unswitching(loop, old_new);
1849             } else {
1850               // Not proceeding with unswitching. Move load back in
1851               // the loop.
1852               phase-&gt;igvn().replace_input_of(iff, 1, bol);
1853             }
1854           }
1855         }
1856       }
1857     }
1858   }
1859 }
1860 
1861 #ifdef ASSERT
1862 void ShenandoahBarrierC2Support::verify_raw_mem(RootNode* root) {
1863   const bool trace = false;
1864   ResourceMark rm;
1865   Unique_Node_List nodes;
1866   Unique_Node_List controls;
1867   Unique_Node_List memories;
1868 
1869   nodes.push(root);
1870   for (uint next = 0; next &lt; nodes.size(); next++) {
1871     Node *n  = nodes.at(next);
1872     if (ShenandoahBarrierSetC2::is_shenandoah_lrb_call(n)) {
1873       controls.push(n);
1874       if (trace) { tty-&gt;print(&quot;XXXXXX verifying&quot;); n-&gt;dump(); }
1875       for (uint next2 = 0; next2 &lt; controls.size(); next2++) {
1876         Node *m = controls.at(next2);
1877         for (DUIterator_Fast imax, i = m-&gt;fast_outs(imax); i &lt; imax; i++) {
1878           Node* u = m-&gt;fast_out(i);
1879           if (u-&gt;is_CFG() &amp;&amp; !u-&gt;is_Root() &amp;&amp;
1880               !(u-&gt;Opcode() == Op_CProj &amp;&amp; u-&gt;in(0)-&gt;Opcode() == Op_NeverBranch &amp;&amp; u-&gt;as_Proj()-&gt;_con == 1) &amp;&amp;
1881               !(u-&gt;is_Region() &amp;&amp; u-&gt;unique_ctrl_out()-&gt;Opcode() == Op_Halt)) {
1882             if (trace) { tty-&gt;print(&quot;XXXXXX pushing control&quot;); u-&gt;dump(); }
1883             controls.push(u);
1884           }
1885         }
1886       }
1887       memories.push(n-&gt;as_Call()-&gt;proj_out(TypeFunc::Memory));
1888       for (uint next2 = 0; next2 &lt; memories.size(); next2++) {
1889         Node *m = memories.at(next2);
1890         assert(m-&gt;bottom_type() == Type::MEMORY, &quot;&quot;);
1891         for (DUIterator_Fast imax, i = m-&gt;fast_outs(imax); i &lt; imax; i++) {
1892           Node* u = m-&gt;fast_out(i);
1893           if (u-&gt;bottom_type() == Type::MEMORY &amp;&amp; (u-&gt;is_Mem() || u-&gt;is_ClearArray())) {
1894             if (trace) { tty-&gt;print(&quot;XXXXXX pushing memory&quot;); u-&gt;dump(); }
1895             memories.push(u);
1896           } else if (u-&gt;is_LoadStore()) {
1897             if (trace) { tty-&gt;print(&quot;XXXXXX pushing memory&quot;); u-&gt;find_out_with(Op_SCMemProj)-&gt;dump(); }
1898             memories.push(u-&gt;find_out_with(Op_SCMemProj));
1899           } else if (u-&gt;is_MergeMem() &amp;&amp; u-&gt;as_MergeMem()-&gt;memory_at(Compile::AliasIdxRaw) == m) {
1900             if (trace) { tty-&gt;print(&quot;XXXXXX pushing memory&quot;); u-&gt;dump(); }
1901             memories.push(u);
1902           } else if (u-&gt;is_Phi()) {
1903             assert(u-&gt;bottom_type() == Type::MEMORY, &quot;&quot;);
1904             if (u-&gt;adr_type() == TypeRawPtr::BOTTOM || u-&gt;adr_type() == TypePtr::BOTTOM) {
1905               assert(controls.member(u-&gt;in(0)), &quot;&quot;);
1906               if (trace) { tty-&gt;print(&quot;XXXXXX pushing memory&quot;); u-&gt;dump(); }
1907               memories.push(u);
1908             }
1909           } else if (u-&gt;is_SafePoint() || u-&gt;is_MemBar()) {
1910             for (DUIterator_Fast jmax, j = u-&gt;fast_outs(jmax); j &lt; jmax; j++) {
1911               Node* uu = u-&gt;fast_out(j);
1912               if (uu-&gt;bottom_type() == Type::MEMORY) {
1913                 if (trace) { tty-&gt;print(&quot;XXXXXX pushing memory&quot;); uu-&gt;dump(); }
1914                 memories.push(uu);
1915               }
1916             }
1917           }
1918         }
1919       }
1920       for (uint next2 = 0; next2 &lt; controls.size(); next2++) {
1921         Node *m = controls.at(next2);
1922         if (m-&gt;is_Region()) {
1923           bool all_in = true;
1924           for (uint i = 1; i &lt; m-&gt;req(); i++) {
1925             if (!controls.member(m-&gt;in(i))) {
1926               all_in = false;
1927               break;
1928             }
1929           }
1930           if (trace) { tty-&gt;print(&quot;XXX verifying %s&quot;, all_in ? &quot;all in&quot; : &quot;&quot;); m-&gt;dump(); }
1931           bool found_phi = false;
1932           for (DUIterator_Fast jmax, j = m-&gt;fast_outs(jmax); j &lt; jmax &amp;&amp; !found_phi; j++) {
1933             Node* u = m-&gt;fast_out(j);
1934             if (u-&gt;is_Phi() &amp;&amp; memories.member(u)) {
1935               found_phi = true;
1936               for (uint i = 1; i &lt; u-&gt;req() &amp;&amp; found_phi; i++) {
1937                 Node* k = u-&gt;in(i);
1938                 if (memories.member(k) != controls.member(m-&gt;in(i))) {
1939                   found_phi = false;
1940                 }
1941               }
1942             }
1943           }
1944           assert(found_phi || all_in, &quot;&quot;);
1945         }
1946       }
1947       controls.clear();
1948       memories.clear();
1949     }
1950     for( uint i = 0; i &lt; n-&gt;len(); ++i ) {
1951       Node *m = n-&gt;in(i);
1952       if (m != NULL) {
1953         nodes.push(m);
1954       }
1955     }
1956   }
1957 }
1958 #endif
1959 
1960 ShenandoahEnqueueBarrierNode::ShenandoahEnqueueBarrierNode(Node* val) : Node(NULL, val) {
1961   ShenandoahBarrierSetC2::bsc2()-&gt;state()-&gt;add_enqueue_barrier(this);
1962 }
1963 
1964 const Type* ShenandoahEnqueueBarrierNode::bottom_type() const {
1965   if (in(1) == NULL || in(1)-&gt;is_top()) {
1966     return Type::TOP;
1967   }
1968   const Type* t = in(1)-&gt;bottom_type();
1969   if (t == TypePtr::NULL_PTR) {
1970     return t;
1971   }
1972   return t-&gt;is_oopptr();
1973 }
1974 
1975 const Type* ShenandoahEnqueueBarrierNode::Value(PhaseGVN* phase) const {
1976   if (in(1) == NULL) {
1977     return Type::TOP;
1978   }
1979   const Type* t = phase-&gt;type(in(1));
1980   if (t == Type::TOP) {
1981     return Type::TOP;
1982   }
1983   if (t == TypePtr::NULL_PTR) {
1984     return t;
1985   }
1986   return t-&gt;is_oopptr();
1987 }
1988 
1989 int ShenandoahEnqueueBarrierNode::needed(Node* n) {
1990   if (n == NULL ||
1991       n-&gt;is_Allocate() ||
1992       n-&gt;Opcode() == Op_ShenandoahEnqueueBarrier ||
1993       n-&gt;bottom_type() == TypePtr::NULL_PTR ||
1994       (n-&gt;bottom_type()-&gt;make_oopptr() != NULL &amp;&amp; n-&gt;bottom_type()-&gt;make_oopptr()-&gt;const_oop() != NULL)) {
1995     return NotNeeded;
1996   }
1997   if (n-&gt;is_Phi() ||
1998       n-&gt;is_CMove()) {
1999     return MaybeNeeded;
2000   }
2001   return Needed;
2002 }
2003 
2004 Node* ShenandoahEnqueueBarrierNode::next(Node* n) {
2005   for (;;) {
2006     if (n == NULL) {
2007       return n;
2008     } else if (n-&gt;bottom_type() == TypePtr::NULL_PTR) {
2009       return n;
2010     } else if (n-&gt;bottom_type()-&gt;make_oopptr() != NULL &amp;&amp; n-&gt;bottom_type()-&gt;make_oopptr()-&gt;const_oop() != NULL) {
2011       return n;
2012     } else if (n-&gt;is_ConstraintCast() ||
2013                n-&gt;Opcode() == Op_DecodeN ||
2014                n-&gt;Opcode() == Op_EncodeP) {
2015       n = n-&gt;in(1);
2016     } else if (n-&gt;is_Proj()) {
2017       n = n-&gt;in(0);
2018     } else {
2019       return n;
2020     }
2021   }
2022   ShouldNotReachHere();
2023   return NULL;
2024 }
2025 
2026 Node* ShenandoahEnqueueBarrierNode::Identity(PhaseGVN* phase) {
2027   PhaseIterGVN* igvn = phase-&gt;is_IterGVN();
2028 
2029   Node* n = next(in(1));
2030 
2031   int cont = needed(n);
2032 
2033   if (cont == NotNeeded) {
2034     return in(1);
2035   } else if (cont == MaybeNeeded) {
2036     if (igvn == NULL) {
2037       phase-&gt;record_for_igvn(this);
2038       return this;
2039     } else {
2040       ResourceMark rm;
2041       Unique_Node_List wq;
2042       uint wq_i = 0;
2043 
2044       for (;;) {
2045         if (n-&gt;is_Phi()) {
2046           for (uint i = 1; i &lt; n-&gt;req(); i++) {
2047             Node* m = n-&gt;in(i);
2048             if (m != NULL) {
2049               wq.push(m);
2050             }
2051           }
2052         } else {
2053           assert(n-&gt;is_CMove(), &quot;nothing else here&quot;);
2054           Node* m = n-&gt;in(CMoveNode::IfFalse);
2055           wq.push(m);
2056           m = n-&gt;in(CMoveNode::IfTrue);
2057           wq.push(m);
2058         }
2059         Node* orig_n = NULL;
2060         do {
2061           if (wq_i &gt;= wq.size()) {
2062             return in(1);
2063           }
2064           n = wq.at(wq_i);
2065           wq_i++;
2066           orig_n = n;
2067           n = next(n);
2068           cont = needed(n);
2069           if (cont == Needed) {
2070             return this;
2071           }
2072         } while (cont != MaybeNeeded || (orig_n != n &amp;&amp; wq.member(n)));
2073       }
2074     }
2075   }
2076 
2077   return this;
2078 }
2079 
2080 #ifdef ASSERT
2081 static bool has_never_branch(Node* root) {
2082   for (uint i = 1; i &lt; root-&gt;req(); i++) {
2083     Node* in = root-&gt;in(i);
2084     if (in != NULL &amp;&amp; in-&gt;Opcode() == Op_Halt &amp;&amp; in-&gt;in(0)-&gt;is_Proj() &amp;&amp; in-&gt;in(0)-&gt;in(0)-&gt;Opcode() == Op_NeverBranch) {
2085       return true;
2086     }
2087   }
2088   return false;
2089 }
2090 #endif
2091 
2092 void MemoryGraphFixer::collect_memory_nodes() {
2093   Node_Stack stack(0);
2094   VectorSet visited(Thread::current()-&gt;resource_area());
2095   Node_List regions;
2096 
2097   // Walk the raw memory graph and create a mapping from CFG node to
2098   // memory node. Exclude phis for now.
2099   stack.push(_phase-&gt;C-&gt;root(), 1);
2100   do {
2101     Node* n = stack.node();
2102     int opc = n-&gt;Opcode();
2103     uint i = stack.index();
2104     if (i &lt; n-&gt;req()) {
2105       Node* mem = NULL;
2106       if (opc == Op_Root) {
2107         Node* in = n-&gt;in(i);
2108         int in_opc = in-&gt;Opcode();
2109         if (in_opc == Op_Return || in_opc == Op_Rethrow) {
2110           mem = in-&gt;in(TypeFunc::Memory);
2111         } else if (in_opc == Op_Halt) {
2112           if (in-&gt;in(0)-&gt;is_Region()) {
2113             Node* r = in-&gt;in(0);
2114             for (uint j = 1; j &lt; r-&gt;req(); j++) {
2115               assert(r-&gt;in(j)-&gt;Opcode() != Op_NeverBranch, &quot;&quot;);
2116             }
2117           } else {
2118             Node* proj = in-&gt;in(0);
2119             assert(proj-&gt;is_Proj(), &quot;&quot;);
2120             Node* in = proj-&gt;in(0);
2121             assert(in-&gt;is_CallStaticJava() || in-&gt;Opcode() == Op_NeverBranch || in-&gt;Opcode() == Op_Catch || proj-&gt;is_IfProj(), &quot;&quot;);
2122             if (in-&gt;is_CallStaticJava()) {
2123               mem = in-&gt;in(TypeFunc::Memory);
2124             } else if (in-&gt;Opcode() == Op_Catch) {
2125               Node* call = in-&gt;in(0)-&gt;in(0);
2126               assert(call-&gt;is_Call(), &quot;&quot;);
2127               mem = call-&gt;in(TypeFunc::Memory);
2128             } else if (in-&gt;Opcode() == Op_NeverBranch) {
2129               Node* head = in-&gt;in(0);
2130               assert(head-&gt;is_Region(), &quot;unexpected infinite loop graph shape&quot;);
2131 
2132               Node* phi_mem = NULL;
2133               for (DUIterator_Fast jmax, j = head-&gt;fast_outs(jmax); j &lt; jmax; j++) {
2134                 Node* u = head-&gt;fast_out(j);
2135                 if (u-&gt;is_Phi() &amp;&amp; u-&gt;bottom_type() == Type::MEMORY) {
2136                   if (_phase-&gt;C-&gt;get_alias_index(u-&gt;adr_type()) == _alias) {
2137                     assert(phi_mem == NULL || phi_mem-&gt;adr_type() == TypePtr::BOTTOM, &quot;&quot;);
2138                     phi_mem = u;
2139                   } else if (u-&gt;adr_type() == TypePtr::BOTTOM) {
2140                     assert(phi_mem == NULL || _phase-&gt;C-&gt;get_alias_index(phi_mem-&gt;adr_type()) == _alias, &quot;&quot;);
2141                     if (phi_mem == NULL) {
2142                       phi_mem = u;
2143                     }
2144                   }
2145                 }
2146               }
2147               if (phi_mem == NULL) {
2148                 for (uint j = 1; j &lt; head-&gt;req(); j++) {
2149                   Node* tail = head-&gt;in(j);
2150                   if (!_phase-&gt;is_dominator(head, tail)) {
2151                     continue;
2152                   }
2153                   Node* c = tail;
2154                   while (c != head) {
2155                     if (c-&gt;is_SafePoint() &amp;&amp; !c-&gt;is_CallLeaf()) {
2156                       Node* m =c-&gt;in(TypeFunc::Memory);
2157                       if (m-&gt;is_MergeMem()) {
2158                         m = m-&gt;as_MergeMem()-&gt;memory_at(_alias);
2159                       }
2160                       assert(mem == NULL || mem == m, &quot;several memory states&quot;);
2161                       mem = m;
2162                     }
2163                     c = _phase-&gt;idom(c);
2164                   }
2165                   assert(mem != NULL, &quot;should have found safepoint&quot;);
2166                 }
2167                 assert(mem != NULL, &quot;should have found safepoint&quot;);
2168               } else {
2169                 mem = phi_mem;
2170               }
2171             }
2172           }
2173         } else {
2174 #ifdef ASSERT
2175           n-&gt;dump();
2176           in-&gt;dump();
2177 #endif
2178           ShouldNotReachHere();
2179         }
2180       } else {
2181         assert(n-&gt;is_Phi() &amp;&amp; n-&gt;bottom_type() == Type::MEMORY, &quot;&quot;);
2182         assert(n-&gt;adr_type() == TypePtr::BOTTOM || _phase-&gt;C-&gt;get_alias_index(n-&gt;adr_type()) == _alias, &quot;&quot;);
2183         mem = n-&gt;in(i);
2184       }
2185       i++;
2186       stack.set_index(i);
2187       if (mem == NULL) {
2188         continue;
2189       }
2190       for (;;) {
2191         if (visited.test_set(mem-&gt;_idx) || mem-&gt;is_Start()) {
2192           break;
2193         }
2194         if (mem-&gt;is_Phi()) {
2195           stack.push(mem, 2);
2196           mem = mem-&gt;in(1);
2197         } else if (mem-&gt;is_Proj()) {
2198           stack.push(mem, mem-&gt;req());
2199           mem = mem-&gt;in(0);
2200         } else if (mem-&gt;is_SafePoint() || mem-&gt;is_MemBar()) {
2201           mem = mem-&gt;in(TypeFunc::Memory);
2202         } else if (mem-&gt;is_MergeMem()) {
2203           MergeMemNode* mm = mem-&gt;as_MergeMem();
2204           mem = mm-&gt;memory_at(_alias);
2205         } else if (mem-&gt;is_Store() || mem-&gt;is_LoadStore() || mem-&gt;is_ClearArray()) {
2206           assert(_alias == Compile::AliasIdxRaw, &quot;&quot;);
2207           stack.push(mem, mem-&gt;req());
2208           mem = mem-&gt;in(MemNode::Memory);
2209         } else {
2210 #ifdef ASSERT
2211           mem-&gt;dump();
2212 #endif
2213           ShouldNotReachHere();
2214         }
2215       }
2216     } else {
2217       if (n-&gt;is_Phi()) {
2218         // Nothing
2219       } else if (!n-&gt;is_Root()) {
2220         Node* c = get_ctrl(n);
2221         _memory_nodes.map(c-&gt;_idx, n);
2222       }
2223       stack.pop();
2224     }
2225   } while(stack.is_nonempty());
2226 
2227   // Iterate over CFG nodes in rpo and propagate memory state to
2228   // compute memory state at regions, creating new phis if needed.
2229   Node_List rpo_list;
2230   visited.clear();
2231   _phase-&gt;rpo(_phase-&gt;C-&gt;root(), stack, visited, rpo_list);
2232   Node* root = rpo_list.pop();
2233   assert(root == _phase-&gt;C-&gt;root(), &quot;&quot;);
2234 
2235   const bool trace = false;
2236 #ifdef ASSERT
2237   if (trace) {
2238     for (int i = rpo_list.size() - 1; i &gt;= 0; i--) {
2239       Node* c = rpo_list.at(i);
2240       if (_memory_nodes[c-&gt;_idx] != NULL) {
2241         tty-&gt;print(&quot;X %d&quot;, c-&gt;_idx);  _memory_nodes[c-&gt;_idx]-&gt;dump();
2242       }
2243     }
2244   }
2245 #endif
2246   uint last = _phase-&gt;C-&gt;unique();
2247 
2248 #ifdef ASSERT
2249   uint8_t max_depth = 0;
2250   for (LoopTreeIterator iter(_phase-&gt;ltree_root()); !iter.done(); iter.next()) {
2251     IdealLoopTree* lpt = iter.current();
2252     max_depth = MAX2(max_depth, lpt-&gt;_nest);
2253   }
2254 #endif
2255 
2256   bool progress = true;
2257   int iteration = 0;
2258   Node_List dead_phis;
2259   while (progress) {
2260     progress = false;
2261     iteration++;
2262     assert(iteration &lt;= 2+max_depth || _phase-&gt;C-&gt;has_irreducible_loop() || has_never_branch(_phase-&gt;C-&gt;root()), &quot;&quot;);
2263     if (trace) { tty-&gt;print_cr(&quot;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX&quot;); }
2264 
2265     for (int i = rpo_list.size() - 1; i &gt;= 0; i--) {
2266       Node* c = rpo_list.at(i);
2267 
2268       Node* prev_mem = _memory_nodes[c-&gt;_idx];
2269       if (c-&gt;is_Region() &amp;&amp; (_include_lsm || !c-&gt;is_OuterStripMinedLoop())) {
2270         Node* prev_region = regions[c-&gt;_idx];
2271         Node* unique = NULL;
2272         for (uint j = 1; j &lt; c-&gt;req() &amp;&amp; unique != NodeSentinel; j++) {
2273           Node* m = _memory_nodes[c-&gt;in(j)-&gt;_idx];
2274           assert(m != NULL || (c-&gt;is_Loop() &amp;&amp; j == LoopNode::LoopBackControl &amp;&amp; iteration == 1) || _phase-&gt;C-&gt;has_irreducible_loop() || has_never_branch(_phase-&gt;C-&gt;root()), &quot;expect memory state&quot;);
2275           if (m != NULL) {
2276             if (m == prev_region &amp;&amp; ((c-&gt;is_Loop() &amp;&amp; j == LoopNode::LoopBackControl) || (prev_region-&gt;is_Phi() &amp;&amp; prev_region-&gt;in(0) == c))) {
2277               assert(c-&gt;is_Loop() &amp;&amp; j == LoopNode::LoopBackControl || _phase-&gt;C-&gt;has_irreducible_loop() || has_never_branch(_phase-&gt;C-&gt;root()), &quot;&quot;);
2278               // continue
2279             } else if (unique == NULL) {
2280               unique = m;
2281             } else if (m == unique) {
2282               // continue
2283             } else {
2284               unique = NodeSentinel;
2285             }
2286           }
2287         }
2288         assert(unique != NULL, &quot;empty phi???&quot;);
2289         if (unique != NodeSentinel) {
2290           if (prev_region != NULL &amp;&amp; prev_region-&gt;is_Phi() &amp;&amp; prev_region-&gt;in(0) == c) {
2291             dead_phis.push(prev_region);
2292           }
2293           regions.map(c-&gt;_idx, unique);
2294         } else {
2295           Node* phi = NULL;
2296           if (prev_region != NULL &amp;&amp; prev_region-&gt;is_Phi() &amp;&amp; prev_region-&gt;in(0) == c &amp;&amp; prev_region-&gt;_idx &gt;= last) {
2297             phi = prev_region;
2298             for (uint k = 1; k &lt; c-&gt;req(); k++) {
2299               Node* m = _memory_nodes[c-&gt;in(k)-&gt;_idx];
2300               assert(m != NULL, &quot;expect memory state&quot;);
2301               phi-&gt;set_req(k, m);
2302             }
2303           } else {
2304             for (DUIterator_Fast jmax, j = c-&gt;fast_outs(jmax); j &lt; jmax &amp;&amp; phi == NULL; j++) {
2305               Node* u = c-&gt;fast_out(j);
2306               if (u-&gt;is_Phi() &amp;&amp; u-&gt;bottom_type() == Type::MEMORY &amp;&amp;
2307                   (u-&gt;adr_type() == TypePtr::BOTTOM || _phase-&gt;C-&gt;get_alias_index(u-&gt;adr_type()) == _alias)) {
2308                 phi = u;
2309                 for (uint k = 1; k &lt; c-&gt;req() &amp;&amp; phi != NULL; k++) {
2310                   Node* m = _memory_nodes[c-&gt;in(k)-&gt;_idx];
2311                   assert(m != NULL, &quot;expect memory state&quot;);
2312                   if (u-&gt;in(k) != m) {
2313                     phi = NULL;
2314                   }
2315                 }
2316               }
2317             }
2318             if (phi == NULL) {
2319               phi = new PhiNode(c, Type::MEMORY, _phase-&gt;C-&gt;get_adr_type(_alias));
2320               for (uint k = 1; k &lt; c-&gt;req(); k++) {
2321                 Node* m = _memory_nodes[c-&gt;in(k)-&gt;_idx];
2322                 assert(m != NULL, &quot;expect memory state&quot;);
2323                 phi-&gt;init_req(k, m);
2324               }
2325             }
2326           }
2327           assert(phi != NULL, &quot;&quot;);
2328           regions.map(c-&gt;_idx, phi);
2329         }
2330         Node* current_region = regions[c-&gt;_idx];
2331         if (current_region != prev_region) {
2332           progress = true;
2333           if (prev_region == prev_mem) {
2334             _memory_nodes.map(c-&gt;_idx, current_region);
2335           }
2336         }
2337       } else if (prev_mem == NULL || prev_mem-&gt;is_Phi() || ctrl_or_self(prev_mem) != c) {
2338         Node* m = _memory_nodes[_phase-&gt;idom(c)-&gt;_idx];
2339         assert(m != NULL, &quot;expect memory state&quot;);
2340         if (m != prev_mem) {
2341           _memory_nodes.map(c-&gt;_idx, m);
2342           progress = true;
2343         }
2344       }
2345 #ifdef ASSERT
2346       if (trace) { tty-&gt;print(&quot;X %d&quot;, c-&gt;_idx);  _memory_nodes[c-&gt;_idx]-&gt;dump(); }
2347 #endif
2348     }
2349   }
2350 
2351   // Replace existing phi with computed memory state for that region
2352   // if different (could be a new phi or a dominating memory node if
2353   // that phi was found to be useless).
2354   while (dead_phis.size() &gt; 0) {
2355     Node* n = dead_phis.pop();
2356     n-&gt;replace_by(_phase-&gt;C-&gt;top());
2357     n-&gt;destruct();
2358   }
2359   for (int i = rpo_list.size() - 1; i &gt;= 0; i--) {
2360     Node* c = rpo_list.at(i);
2361     if (c-&gt;is_Region() &amp;&amp; (_include_lsm || !c-&gt;is_OuterStripMinedLoop())) {
2362       Node* n = regions[c-&gt;_idx];
2363       if (n-&gt;is_Phi() &amp;&amp; n-&gt;_idx &gt;= last &amp;&amp; n-&gt;in(0) == c) {
2364         _phase-&gt;register_new_node(n, c);
2365       }
2366     }
2367   }
2368   for (int i = rpo_list.size() - 1; i &gt;= 0; i--) {
2369     Node* c = rpo_list.at(i);
2370     if (c-&gt;is_Region() &amp;&amp; (_include_lsm || !c-&gt;is_OuterStripMinedLoop())) {
2371       Node* n = regions[c-&gt;_idx];
2372       for (DUIterator_Fast imax, i = c-&gt;fast_outs(imax); i &lt; imax; i++) {
2373         Node* u = c-&gt;fast_out(i);
2374         if (u-&gt;is_Phi() &amp;&amp; u-&gt;bottom_type() == Type::MEMORY &amp;&amp;
2375             u != n) {
2376           if (u-&gt;adr_type() == TypePtr::BOTTOM) {
2377             fix_memory_uses(u, n, n, c);
2378           } else if (_phase-&gt;C-&gt;get_alias_index(u-&gt;adr_type()) == _alias) {
2379             _phase-&gt;lazy_replace(u, n);
2380             --i; --imax;
2381           }
2382         }
2383       }
2384     }
2385   }
2386 }
2387 
2388 Node* MemoryGraphFixer::get_ctrl(Node* n) const {
2389   Node* c = _phase-&gt;get_ctrl(n);
2390   if (n-&gt;is_Proj() &amp;&amp; n-&gt;in(0) != NULL &amp;&amp; n-&gt;in(0)-&gt;is_Call()) {
2391     assert(c == n-&gt;in(0), &quot;&quot;);
2392     CallNode* call = c-&gt;as_Call();
2393     CallProjections projs;
2394     call-&gt;extract_projections(&amp;projs, true, false);
2395     if (projs.catchall_memproj != NULL) {
2396       if (projs.fallthrough_memproj == n) {
2397         c = projs.fallthrough_catchproj;
2398       } else {
2399         assert(projs.catchall_memproj == n, &quot;&quot;);
2400         c = projs.catchall_catchproj;
2401       }
2402     }
2403   }
2404   return c;
2405 }
2406 
2407 Node* MemoryGraphFixer::ctrl_or_self(Node* n) const {
2408   if (_phase-&gt;has_ctrl(n))
2409     return get_ctrl(n);
2410   else {
2411     assert (n-&gt;is_CFG(), &quot;must be a CFG node&quot;);
2412     return n;
2413   }
2414 }
2415 
2416 bool MemoryGraphFixer::mem_is_valid(Node* m, Node* c) const {
2417   return m != NULL &amp;&amp; get_ctrl(m) == c;
2418 }
2419 
2420 Node* MemoryGraphFixer::find_mem(Node* ctrl, Node* n) const {
2421   assert(n == NULL || _phase-&gt;ctrl_or_self(n) == ctrl, &quot;&quot;);
2422   Node* mem = _memory_nodes[ctrl-&gt;_idx];
2423   Node* c = ctrl;
2424   while (!mem_is_valid(mem, c) &amp;&amp;
2425          (!c-&gt;is_CatchProj() || mem == NULL || c-&gt;in(0)-&gt;in(0)-&gt;in(0) != get_ctrl(mem))) {
2426     c = _phase-&gt;idom(c);
2427     mem = _memory_nodes[c-&gt;_idx];
2428   }
2429   if (n != NULL &amp;&amp; mem_is_valid(mem, c)) {
2430     while (!ShenandoahBarrierC2Support::is_dominator_same_ctrl(c, mem, n, _phase) &amp;&amp; _phase-&gt;ctrl_or_self(mem) == ctrl) {
2431       mem = next_mem(mem, _alias);
2432     }
2433     if (mem-&gt;is_MergeMem()) {
2434       mem = mem-&gt;as_MergeMem()-&gt;memory_at(_alias);
2435     }
2436     if (!mem_is_valid(mem, c)) {
2437       do {
2438         c = _phase-&gt;idom(c);
2439         mem = _memory_nodes[c-&gt;_idx];
2440       } while (!mem_is_valid(mem, c) &amp;&amp;
2441                (!c-&gt;is_CatchProj() || mem == NULL || c-&gt;in(0)-&gt;in(0)-&gt;in(0) != get_ctrl(mem)));
2442     }
2443   }
2444   assert(mem-&gt;bottom_type() == Type::MEMORY, &quot;&quot;);
2445   return mem;
2446 }
2447 
2448 bool MemoryGraphFixer::has_mem_phi(Node* region) const {
2449   for (DUIterator_Fast imax, i = region-&gt;fast_outs(imax); i &lt; imax; i++) {
2450     Node* use = region-&gt;fast_out(i);
2451     if (use-&gt;is_Phi() &amp;&amp; use-&gt;bottom_type() == Type::MEMORY &amp;&amp;
2452         (_phase-&gt;C-&gt;get_alias_index(use-&gt;adr_type()) == _alias)) {
2453       return true;
2454     }
2455   }
2456   return false;
2457 }
2458 
2459 void MemoryGraphFixer::fix_mem(Node* ctrl, Node* new_ctrl, Node* mem, Node* mem_for_ctrl, Node* new_mem, Unique_Node_List&amp; uses) {
2460   assert(_phase-&gt;ctrl_or_self(new_mem) == new_ctrl, &quot;&quot;);
2461   const bool trace = false;
2462   DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ control is&quot;); ctrl-&gt;dump(); });
2463   DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ mem is&quot;); mem-&gt;dump(); });
2464   GrowableArray&lt;Node*&gt; phis;
2465   if (mem_for_ctrl != mem) {
2466     Node* old = mem_for_ctrl;
2467     Node* prev = NULL;
2468     while (old != mem) {
2469       prev = old;
2470       if (old-&gt;is_Store() || old-&gt;is_ClearArray() || old-&gt;is_LoadStore()) {
2471         assert(_alias == Compile::AliasIdxRaw, &quot;&quot;);
2472         old = old-&gt;in(MemNode::Memory);
2473       } else if (old-&gt;Opcode() == Op_SCMemProj) {
2474         assert(_alias == Compile::AliasIdxRaw, &quot;&quot;);
2475         old = old-&gt;in(0);
2476       } else {
2477         ShouldNotReachHere();
2478       }
2479     }
2480     assert(prev != NULL, &quot;&quot;);
2481     if (new_ctrl != ctrl) {
2482       _memory_nodes.map(ctrl-&gt;_idx, mem);
2483       _memory_nodes.map(new_ctrl-&gt;_idx, mem_for_ctrl);
2484     }
2485     uint input = (uint)MemNode::Memory;
2486     _phase-&gt;igvn().replace_input_of(prev, input, new_mem);
2487   } else {
2488     uses.clear();
2489     _memory_nodes.map(new_ctrl-&gt;_idx, new_mem);
2490     uses.push(new_ctrl);
2491     for(uint next = 0; next &lt; uses.size(); next++ ) {
2492       Node *n = uses.at(next);
2493       assert(n-&gt;is_CFG(), &quot;&quot;);
2494       DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ ctrl&quot;); n-&gt;dump(); });
2495       for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
2496         Node* u = n-&gt;fast_out(i);
2497         if (!u-&gt;is_Root() &amp;&amp; u-&gt;is_CFG() &amp;&amp; u != n) {
2498           Node* m = _memory_nodes[u-&gt;_idx];
2499           if (u-&gt;is_Region() &amp;&amp; (!u-&gt;is_OuterStripMinedLoop() || _include_lsm) &amp;&amp;
2500               !has_mem_phi(u) &amp;&amp;
2501               u-&gt;unique_ctrl_out()-&gt;Opcode() != Op_Halt) {
2502             DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ region&quot;); u-&gt;dump(); });
2503             DEBUG_ONLY(if (trace &amp;&amp; m != NULL) { tty-&gt;print(&quot;ZZZ mem&quot;); m-&gt;dump(); });
2504 
2505             if (!mem_is_valid(m, u) || !m-&gt;is_Phi()) {
2506               bool push = true;
2507               bool create_phi = true;
2508               if (_phase-&gt;is_dominator(new_ctrl, u)) {
2509                 create_phi = false;
2510               }
2511               if (create_phi) {
2512                 Node* phi = new PhiNode(u, Type::MEMORY, _phase-&gt;C-&gt;get_adr_type(_alias));
2513                 _phase-&gt;register_new_node(phi, u);
2514                 phis.push(phi);
2515                 DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ new phi&quot;); phi-&gt;dump(); });
2516                 if (!mem_is_valid(m, u)) {
2517                   DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ setting mem&quot;); phi-&gt;dump(); });
2518                   _memory_nodes.map(u-&gt;_idx, phi);
2519                 } else {
2520                   DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ NOT setting mem&quot;); m-&gt;dump(); });
2521                   for (;;) {
2522                     assert(m-&gt;is_Mem() || m-&gt;is_LoadStore() || m-&gt;is_Proj(), &quot;&quot;);
2523                     Node* next = NULL;
2524                     if (m-&gt;is_Proj()) {
2525                       next = m-&gt;in(0);
2526                     } else {
2527                       assert(m-&gt;is_Mem() || m-&gt;is_LoadStore(), &quot;&quot;);
2528                       assert(_alias == Compile::AliasIdxRaw, &quot;&quot;);
2529                       next = m-&gt;in(MemNode::Memory);
2530                     }
2531                     if (_phase-&gt;get_ctrl(next) != u) {
2532                       break;
2533                     }
2534                     if (next-&gt;is_MergeMem()) {
2535                       assert(_phase-&gt;get_ctrl(next-&gt;as_MergeMem()-&gt;memory_at(_alias)) != u, &quot;&quot;);
2536                       break;
2537                     }
2538                     if (next-&gt;is_Phi()) {
2539                       assert(next-&gt;adr_type() == TypePtr::BOTTOM &amp;&amp; next-&gt;in(0) == u, &quot;&quot;);
2540                       break;
2541                     }
2542                     m = next;
2543                   }
2544 
2545                   DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ setting to phi&quot;); m-&gt;dump(); });
2546                   assert(m-&gt;is_Mem() || m-&gt;is_LoadStore(), &quot;&quot;);
2547                   uint input = (uint)MemNode::Memory;
2548                   _phase-&gt;igvn().replace_input_of(m, input, phi);
2549                   push = false;
2550                 }
2551               } else {
2552                 DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ skipping region&quot;); u-&gt;dump(); });
2553               }
2554               if (push) {
2555                 uses.push(u);
2556               }
2557             }
2558           } else if (!mem_is_valid(m, u) &amp;&amp;
2559                      !(u-&gt;Opcode() == Op_CProj &amp;&amp; u-&gt;in(0)-&gt;Opcode() == Op_NeverBranch &amp;&amp; u-&gt;as_Proj()-&gt;_con == 1)) {
2560             uses.push(u);
2561           }
2562         }
2563       }
2564     }
2565     for (int i = 0; i &lt; phis.length(); i++) {
2566       Node* n = phis.at(i);
2567       Node* r = n-&gt;in(0);
2568       DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ fixing new phi&quot;); n-&gt;dump(); });
2569       for (uint j = 1; j &lt; n-&gt;req(); j++) {
2570         Node* m = find_mem(r-&gt;in(j), NULL);
2571         _phase-&gt;igvn().replace_input_of(n, j, m);
2572         DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ fixing new phi: %d&quot;, j); m-&gt;dump(); });
2573       }
2574     }
2575   }
2576   uint last = _phase-&gt;C-&gt;unique();
2577   MergeMemNode* mm = NULL;
2578   int alias = _alias;
2579   DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ raw mem is&quot;); mem-&gt;dump(); });
2580   // Process loads first to not miss an anti-dependency: if the memory
2581   // edge of a store is updated before a load is processed then an
2582   // anti-dependency may be missed.
2583   for (DUIterator i = mem-&gt;outs(); mem-&gt;has_out(i); i++) {
2584     Node* u = mem-&gt;out(i);
2585     if (u-&gt;_idx &lt; last &amp;&amp; u-&gt;is_Load() &amp;&amp; _phase-&gt;C-&gt;get_alias_index(u-&gt;adr_type()) == alias) {
2586       Node* m = find_mem(_phase-&gt;get_ctrl(u), u);
2587       if (m != mem) {
2588         DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ setting memory of use&quot;); u-&gt;dump(); });
2589         _phase-&gt;igvn().replace_input_of(u, MemNode::Memory, m);
2590         --i;
2591       }
2592     }
2593   }
2594   for (DUIterator i = mem-&gt;outs(); mem-&gt;has_out(i); i++) {
2595     Node* u = mem-&gt;out(i);
2596     if (u-&gt;_idx &lt; last) {
2597       if (u-&gt;is_Mem()) {
2598         if (_phase-&gt;C-&gt;get_alias_index(u-&gt;adr_type()) == alias) {
2599           Node* m = find_mem(_phase-&gt;get_ctrl(u), u);
2600           if (m != mem) {
2601             DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ setting memory of use&quot;); u-&gt;dump(); });
2602             _phase-&gt;igvn().replace_input_of(u, MemNode::Memory, m);
2603             --i;
2604           }
2605         }
2606       } else if (u-&gt;is_MergeMem()) {
2607         MergeMemNode* u_mm = u-&gt;as_MergeMem();
2608         if (u_mm-&gt;memory_at(alias) == mem) {
2609           MergeMemNode* newmm = NULL;
2610           for (DUIterator_Fast jmax, j = u-&gt;fast_outs(jmax); j &lt; jmax; j++) {
2611             Node* uu = u-&gt;fast_out(j);
2612             assert(!uu-&gt;is_MergeMem(), &quot;chain of MergeMems?&quot;);
2613             if (uu-&gt;is_Phi()) {
2614               assert(uu-&gt;adr_type() == TypePtr::BOTTOM, &quot;&quot;);
2615               Node* region = uu-&gt;in(0);
2616               int nb = 0;
2617               for (uint k = 1; k &lt; uu-&gt;req(); k++) {
2618                 if (uu-&gt;in(k) == u) {
2619                   Node* m = find_mem(region-&gt;in(k), NULL);
2620                   if (m != mem) {
2621                     DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ setting memory of phi %d&quot;, k); uu-&gt;dump(); });
2622                     newmm = clone_merge_mem(u, mem, m, _phase-&gt;ctrl_or_self(m), i);
2623                     if (newmm != u) {
2624                       _phase-&gt;igvn().replace_input_of(uu, k, newmm);
2625                       nb++;
2626                       --jmax;
2627                     }
2628                   }
2629                 }
2630               }
2631               if (nb &gt; 0) {
2632                 --j;
2633               }
2634             } else {
2635               Node* m = find_mem(_phase-&gt;ctrl_or_self(uu), uu);
2636               if (m != mem) {
2637                 DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ setting memory of use&quot;); uu-&gt;dump(); });
2638                 newmm = clone_merge_mem(u, mem, m, _phase-&gt;ctrl_or_self(m), i);
2639                 if (newmm != u) {
2640                   _phase-&gt;igvn().replace_input_of(uu, uu-&gt;find_edge(u), newmm);
2641                   --j, --jmax;
2642                 }
2643               }
2644             }
2645           }
2646         }
2647       } else if (u-&gt;is_Phi()) {
2648         assert(u-&gt;bottom_type() == Type::MEMORY, &quot;what else?&quot;);
2649         if (_phase-&gt;C-&gt;get_alias_index(u-&gt;adr_type()) == alias || u-&gt;adr_type() == TypePtr::BOTTOM) {
2650           Node* region = u-&gt;in(0);
2651           bool replaced = false;
2652           for (uint j = 1; j &lt; u-&gt;req(); j++) {
2653             if (u-&gt;in(j) == mem) {
2654               Node* m = find_mem(region-&gt;in(j), NULL);
2655               Node* nnew = m;
2656               if (m != mem) {
2657                 if (u-&gt;adr_type() == TypePtr::BOTTOM) {
2658                   mm = allocate_merge_mem(mem, m, _phase-&gt;ctrl_or_self(m));
2659                   nnew = mm;
2660                 }
2661                 DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ setting memory of phi %d&quot;, j); u-&gt;dump(); });
2662                 _phase-&gt;igvn().replace_input_of(u, j, nnew);
2663                 replaced = true;
2664               }
2665             }
2666           }
2667           if (replaced) {
2668             --i;
2669           }
2670         }
2671       } else if ((u-&gt;adr_type() == TypePtr::BOTTOM &amp;&amp; u-&gt;Opcode() != Op_StrInflatedCopy) ||
2672                  u-&gt;adr_type() == NULL) {
2673         assert(u-&gt;adr_type() != NULL ||
2674                u-&gt;Opcode() == Op_Rethrow ||
2675                u-&gt;Opcode() == Op_Return ||
2676                u-&gt;Opcode() == Op_SafePoint ||
2677                (u-&gt;is_CallStaticJava() &amp;&amp; u-&gt;as_CallStaticJava()-&gt;uncommon_trap_request() != 0) ||
2678                (u-&gt;is_CallStaticJava() &amp;&amp; u-&gt;as_CallStaticJava()-&gt;_entry_point == OptoRuntime::rethrow_stub()) ||
2679                u-&gt;Opcode() == Op_CallLeaf, &quot;&quot;);
2680         Node* m = find_mem(_phase-&gt;ctrl_or_self(u), u);
2681         if (m != mem) {
2682           mm = allocate_merge_mem(mem, m, _phase-&gt;get_ctrl(m));
2683           _phase-&gt;igvn().replace_input_of(u, u-&gt;find_edge(mem), mm);
2684           --i;
2685         }
2686       } else if (_phase-&gt;C-&gt;get_alias_index(u-&gt;adr_type()) == alias) {
2687         Node* m = find_mem(_phase-&gt;ctrl_or_self(u), u);
2688         if (m != mem) {
2689           DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ setting memory of use&quot;); u-&gt;dump(); });
2690           _phase-&gt;igvn().replace_input_of(u, u-&gt;find_edge(mem), m);
2691           --i;
2692         }
2693       } else if (u-&gt;adr_type() != TypePtr::BOTTOM &amp;&amp;
2694                  _memory_nodes[_phase-&gt;ctrl_or_self(u)-&gt;_idx] == u) {
2695         Node* m = find_mem(_phase-&gt;ctrl_or_self(u), u);
2696         assert(m != mem, &quot;&quot;);
2697         // u is on the wrong slice...
2698         assert(u-&gt;is_ClearArray(), &quot;&quot;);
2699         DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ setting memory of use&quot;); u-&gt;dump(); });
2700         _phase-&gt;igvn().replace_input_of(u, u-&gt;find_edge(mem), m);
2701         --i;
2702       }
2703     }
2704   }
2705 #ifdef ASSERT
2706   assert(new_mem-&gt;outcnt() &gt; 0, &quot;&quot;);
2707   for (int i = 0; i &lt; phis.length(); i++) {
2708     Node* n = phis.at(i);
2709     assert(n-&gt;outcnt() &gt; 0, &quot;new phi must have uses now&quot;);
2710   }
2711 #endif
2712 }
2713 
2714 MergeMemNode* MemoryGraphFixer::allocate_merge_mem(Node* mem, Node* rep_proj, Node* rep_ctrl) const {
2715   MergeMemNode* mm = MergeMemNode::make(mem);
2716   mm-&gt;set_memory_at(_alias, rep_proj);
2717   _phase-&gt;register_new_node(mm, rep_ctrl);
2718   return mm;
2719 }
2720 
2721 MergeMemNode* MemoryGraphFixer::clone_merge_mem(Node* u, Node* mem, Node* rep_proj, Node* rep_ctrl, DUIterator&amp; i) const {
2722   MergeMemNode* newmm = NULL;
2723   MergeMemNode* u_mm = u-&gt;as_MergeMem();
2724   Node* c = _phase-&gt;get_ctrl(u);
2725   if (_phase-&gt;is_dominator(c, rep_ctrl)) {
2726     c = rep_ctrl;
2727   } else {
2728     assert(_phase-&gt;is_dominator(rep_ctrl, c), &quot;one must dominate the other&quot;);
2729   }
2730   if (u-&gt;outcnt() == 1) {
2731     if (u-&gt;req() &gt; (uint)_alias &amp;&amp; u-&gt;in(_alias) == mem) {
2732       _phase-&gt;igvn().replace_input_of(u, _alias, rep_proj);
2733       --i;
2734     } else {
2735       _phase-&gt;igvn().rehash_node_delayed(u);
2736       u_mm-&gt;set_memory_at(_alias, rep_proj);
2737     }
2738     newmm = u_mm;
2739     _phase-&gt;set_ctrl_and_loop(u, c);
2740   } else {
2741     // can&#39;t simply clone u and then change one of its input because
2742     // it adds and then removes an edge which messes with the
2743     // DUIterator
2744     newmm = MergeMemNode::make(u_mm-&gt;base_memory());
2745     for (uint j = 0; j &lt; u-&gt;req(); j++) {
2746       if (j &lt; newmm-&gt;req()) {
2747         if (j == (uint)_alias) {
2748           newmm-&gt;set_req(j, rep_proj);
2749         } else if (newmm-&gt;in(j) != u-&gt;in(j)) {
2750           newmm-&gt;set_req(j, u-&gt;in(j));
2751         }
2752       } else if (j == (uint)_alias) {
2753         newmm-&gt;add_req(rep_proj);
2754       } else {
2755         newmm-&gt;add_req(u-&gt;in(j));
2756       }
2757     }
2758     if ((uint)_alias &gt;= u-&gt;req()) {
2759       newmm-&gt;set_memory_at(_alias, rep_proj);
2760     }
2761     _phase-&gt;register_new_node(newmm, c);
2762   }
2763   return newmm;
2764 }
2765 
2766 bool MemoryGraphFixer::should_process_phi(Node* phi) const {
2767   if (phi-&gt;adr_type() == TypePtr::BOTTOM) {
2768     Node* region = phi-&gt;in(0);
2769     for (DUIterator_Fast jmax, j = region-&gt;fast_outs(jmax); j &lt; jmax; j++) {
2770       Node* uu = region-&gt;fast_out(j);
2771       if (uu-&gt;is_Phi() &amp;&amp; uu != phi &amp;&amp; uu-&gt;bottom_type() == Type::MEMORY &amp;&amp; _phase-&gt;C-&gt;get_alias_index(uu-&gt;adr_type()) == _alias) {
2772         return false;
2773       }
2774     }
2775     return true;
2776   }
2777   return _phase-&gt;C-&gt;get_alias_index(phi-&gt;adr_type()) == _alias;
2778 }
2779 
2780 void MemoryGraphFixer::fix_memory_uses(Node* mem, Node* replacement, Node* rep_proj, Node* rep_ctrl) const {
2781   uint last = _phase-&gt; C-&gt;unique();
2782   MergeMemNode* mm = NULL;
2783   assert(mem-&gt;bottom_type() == Type::MEMORY, &quot;&quot;);
2784   for (DUIterator i = mem-&gt;outs(); mem-&gt;has_out(i); i++) {
2785     Node* u = mem-&gt;out(i);
2786     if (u != replacement &amp;&amp; u-&gt;_idx &lt; last) {
2787       if (u-&gt;is_MergeMem()) {
2788         MergeMemNode* u_mm = u-&gt;as_MergeMem();
2789         if (u_mm-&gt;memory_at(_alias) == mem) {
2790           MergeMemNode* newmm = NULL;
2791           for (DUIterator_Fast jmax, j = u-&gt;fast_outs(jmax); j &lt; jmax; j++) {
2792             Node* uu = u-&gt;fast_out(j);
2793             assert(!uu-&gt;is_MergeMem(), &quot;chain of MergeMems?&quot;);
2794             if (uu-&gt;is_Phi()) {
2795               if (should_process_phi(uu)) {
2796                 Node* region = uu-&gt;in(0);
2797                 int nb = 0;
2798                 for (uint k = 1; k &lt; uu-&gt;req(); k++) {
2799                   if (uu-&gt;in(k) == u &amp;&amp; _phase-&gt;is_dominator(rep_ctrl, region-&gt;in(k))) {
2800                     if (newmm == NULL) {
2801                       newmm = clone_merge_mem(u, mem, rep_proj, rep_ctrl, i);
2802                     }
2803                     if (newmm != u) {
2804                       _phase-&gt;igvn().replace_input_of(uu, k, newmm);
2805                       nb++;
2806                       --jmax;
2807                     }
2808                   }
2809                 }
2810                 if (nb &gt; 0) {
2811                   --j;
2812                 }
2813               }
2814             } else {
2815               if (rep_ctrl != uu &amp;&amp; ShenandoahBarrierC2Support::is_dominator(rep_ctrl, _phase-&gt;ctrl_or_self(uu), replacement, uu, _phase)) {
2816                 if (newmm == NULL) {
2817                   newmm = clone_merge_mem(u, mem, rep_proj, rep_ctrl, i);
2818                 }
2819                 if (newmm != u) {
2820                   _phase-&gt;igvn().replace_input_of(uu, uu-&gt;find_edge(u), newmm);
2821                   --j, --jmax;
2822                 }
2823               }
2824             }
2825           }
2826         }
2827       } else if (u-&gt;is_Phi()) {
2828         assert(u-&gt;bottom_type() == Type::MEMORY, &quot;what else?&quot;);
2829         Node* region = u-&gt;in(0);
2830         if (should_process_phi(u)) {
2831           bool replaced = false;
2832           for (uint j = 1; j &lt; u-&gt;req(); j++) {
2833             if (u-&gt;in(j) == mem &amp;&amp; _phase-&gt;is_dominator(rep_ctrl, region-&gt;in(j))) {
2834               Node* nnew = rep_proj;
2835               if (u-&gt;adr_type() == TypePtr::BOTTOM) {
2836                 if (mm == NULL) {
2837                   mm = allocate_merge_mem(mem, rep_proj, rep_ctrl);
2838                 }
2839                 nnew = mm;
2840               }
2841               _phase-&gt;igvn().replace_input_of(u, j, nnew);
2842               replaced = true;
2843             }
2844           }
2845           if (replaced) {
2846             --i;
2847           }
2848 
2849         }
2850       } else if ((u-&gt;adr_type() == TypePtr::BOTTOM &amp;&amp; u-&gt;Opcode() != Op_StrInflatedCopy) ||
2851                  u-&gt;adr_type() == NULL) {
2852         assert(u-&gt;adr_type() != NULL ||
2853                u-&gt;Opcode() == Op_Rethrow ||
2854                u-&gt;Opcode() == Op_Return ||
2855                u-&gt;Opcode() == Op_SafePoint ||
2856                u-&gt;Opcode() == Op_StoreIConditional ||
2857                u-&gt;Opcode() == Op_StoreLConditional ||
2858                (u-&gt;is_CallStaticJava() &amp;&amp; u-&gt;as_CallStaticJava()-&gt;uncommon_trap_request() != 0) ||
2859                (u-&gt;is_CallStaticJava() &amp;&amp; u-&gt;as_CallStaticJava()-&gt;_entry_point == OptoRuntime::rethrow_stub()) ||
2860                u-&gt;Opcode() == Op_CallLeaf, &quot;%s&quot;, u-&gt;Name());
2861         if (ShenandoahBarrierC2Support::is_dominator(rep_ctrl, _phase-&gt;ctrl_or_self(u), replacement, u, _phase)) {
2862           if (mm == NULL) {
2863             mm = allocate_merge_mem(mem, rep_proj, rep_ctrl);
2864           }
2865           _phase-&gt;igvn().replace_input_of(u, u-&gt;find_edge(mem), mm);
2866           --i;
2867         }
2868       } else if (_phase-&gt;C-&gt;get_alias_index(u-&gt;adr_type()) == _alias) {
2869         if (ShenandoahBarrierC2Support::is_dominator(rep_ctrl, _phase-&gt;ctrl_or_self(u), replacement, u, _phase)) {
2870           _phase-&gt;igvn().replace_input_of(u, u-&gt;find_edge(mem), rep_proj);
2871           --i;
2872         }
2873       }
2874     }
2875   }
2876 }
2877 
2878 ShenandoahLoadReferenceBarrierNode::ShenandoahLoadReferenceBarrierNode(Node* ctrl, Node* obj, bool native)
2879 : Node(ctrl, obj), _native(native) {
2880   ShenandoahBarrierSetC2::bsc2()-&gt;state()-&gt;add_load_reference_barrier(this);
2881 }
2882 
2883 bool ShenandoahLoadReferenceBarrierNode::is_native() const {
2884   return _native;
2885 }
2886 
2887 uint ShenandoahLoadReferenceBarrierNode::size_of() const {
2888   return sizeof(*this);
2889 }
2890 
2891 uint ShenandoahLoadReferenceBarrierNode::hash() const {
2892   return Node::hash() + (_native ? 1 : 0);
2893 }
2894 
2895 bool ShenandoahLoadReferenceBarrierNode::cmp( const Node &amp;n ) const {
2896   return Node::cmp(n) &amp;&amp; n.Opcode() == Op_ShenandoahLoadReferenceBarrier &amp;&amp;
2897          _native == ((const ShenandoahLoadReferenceBarrierNode&amp;)n)._native;
2898 }
2899 
2900 const Type* ShenandoahLoadReferenceBarrierNode::bottom_type() const {
2901   if (in(ValueIn) == NULL || in(ValueIn)-&gt;is_top()) {
2902     return Type::TOP;
2903   }
2904   const Type* t = in(ValueIn)-&gt;bottom_type();
2905   if (t == TypePtr::NULL_PTR) {
2906     return t;
2907   }
2908   return t-&gt;is_oopptr();
2909 }
2910 
2911 const Type* ShenandoahLoadReferenceBarrierNode::Value(PhaseGVN* phase) const {
2912   // Either input is TOP ==&gt; the result is TOP
2913   const Type *t2 = phase-&gt;type(in(ValueIn));
2914   if( t2 == Type::TOP ) return Type::TOP;
2915 
2916   if (t2 == TypePtr::NULL_PTR) {
2917     return t2;
2918   }
2919 
2920   const Type* type = t2-&gt;is_oopptr();
2921   return type;
2922 }
2923 
2924 Node* ShenandoahLoadReferenceBarrierNode::Identity(PhaseGVN* phase) {
2925   Node* value = in(ValueIn);
2926   if (!needs_barrier(phase, value)) {
2927     return value;
2928   }
2929   return this;
2930 }
2931 
2932 bool ShenandoahLoadReferenceBarrierNode::needs_barrier(PhaseGVN* phase, Node* n) {
2933   Unique_Node_List visited;
2934   return needs_barrier_impl(phase, n, visited);
2935 }
2936 
2937 bool ShenandoahLoadReferenceBarrierNode::needs_barrier_impl(PhaseGVN* phase, Node* n, Unique_Node_List &amp;visited) {
2938   if (n == NULL) return false;
2939   if (visited.member(n)) {
2940     return false; // Been there.
2941   }
2942   visited.push(n);
2943 
2944   if (n-&gt;is_Allocate()) {
2945     // tty-&gt;print_cr(&quot;optimize barrier on alloc&quot;);
2946     return false;
2947   }
2948   if (n-&gt;is_Call()) {
2949     // tty-&gt;print_cr(&quot;optimize barrier on call&quot;);
2950     return false;
2951   }
2952 
2953   const Type* type = phase-&gt;type(n);
2954   if (type == Type::TOP) {
2955     return false;
2956   }
2957   if (type-&gt;make_ptr()-&gt;higher_equal(TypePtr::NULL_PTR)) {
2958     // tty-&gt;print_cr(&quot;optimize barrier on null&quot;);
2959     return false;
2960   }
2961   if (type-&gt;make_oopptr() &amp;&amp; type-&gt;make_oopptr()-&gt;const_oop() != NULL) {
2962     // tty-&gt;print_cr(&quot;optimize barrier on constant&quot;);
2963     return false;
2964   }
2965 
2966   switch (n-&gt;Opcode()) {
2967     case Op_AddP:
2968       return true; // TODO: Can refine?
2969     case Op_LoadP:
2970     case Op_ShenandoahCompareAndExchangeN:
2971     case Op_ShenandoahCompareAndExchangeP:
2972     case Op_CompareAndExchangeN:
2973     case Op_CompareAndExchangeP:
2974     case Op_GetAndSetN:
2975     case Op_GetAndSetP:
2976       return true;
2977     case Op_Phi: {
2978       for (uint i = 1; i &lt; n-&gt;req(); i++) {
2979         if (needs_barrier_impl(phase, n-&gt;in(i), visited)) return true;
2980       }
2981       return false;
2982     }
2983     case Op_CheckCastPP:
2984     case Op_CastPP:
2985       return needs_barrier_impl(phase, n-&gt;in(1), visited);
2986     case Op_Proj:
2987       return needs_barrier_impl(phase, n-&gt;in(0), visited);
2988     case Op_ShenandoahLoadReferenceBarrier:
2989       // tty-&gt;print_cr(&quot;optimize barrier on barrier&quot;);
2990       return false;
2991     case Op_Parm:
2992       // tty-&gt;print_cr(&quot;optimize barrier on input arg&quot;);
2993       return false;
2994     case Op_DecodeN:
2995     case Op_EncodeP:
2996       return needs_barrier_impl(phase, n-&gt;in(1), visited);
2997     case Op_LoadN:
2998       return true;
2999     case Op_CMoveN:
3000     case Op_CMoveP:
3001       return needs_barrier_impl(phase, n-&gt;in(2), visited) ||
3002              needs_barrier_impl(phase, n-&gt;in(3), visited);
3003     case Op_ShenandoahEnqueueBarrier:
3004       return needs_barrier_impl(phase, n-&gt;in(1), visited);
3005     case Op_CreateEx:
3006       return false;
3007     default:
3008       break;
3009   }
3010 #ifdef ASSERT
3011   tty-&gt;print(&quot;need barrier on?: &quot;);
3012   tty-&gt;print_cr(&quot;ins:&quot;);
3013   n-&gt;dump(2);
3014   tty-&gt;print_cr(&quot;outs:&quot;);
3015   n-&gt;dump(-2);
3016   ShouldNotReachHere();
3017 #endif
3018   return true;
3019 }
<a name="8" id="anc8"></a><span class="line-removed">3020 </span>
<span class="line-removed">3021 bool ShenandoahLoadReferenceBarrierNode::is_redundant() {</span>
<span class="line-removed">3022   Unique_Node_List visited;</span>
<span class="line-removed">3023   Node_Stack stack(0);</span>
<span class="line-removed">3024   stack.push(this, 0);</span>
<span class="line-removed">3025 </span>
<span class="line-removed">3026   // Check if the barrier is actually useful: go over nodes looking for useful uses</span>
<span class="line-removed">3027   // (e.g. memory accesses). Stop once we detected a required use. Otherwise, walk</span>
<span class="line-removed">3028   // until we ran out of nodes, and then declare the barrier redundant.</span>
<span class="line-removed">3029   while (stack.size() &gt; 0) {</span>
<span class="line-removed">3030     Node* n = stack.node();</span>
<span class="line-removed">3031     if (visited.member(n)) {</span>
<span class="line-removed">3032       stack.pop();</span>
<span class="line-removed">3033       continue;</span>
<span class="line-removed">3034     }</span>
<span class="line-removed">3035     visited.push(n);</span>
<span class="line-removed">3036     bool visit_users = false;</span>
<span class="line-removed">3037     switch (n-&gt;Opcode()) {</span>
<span class="line-removed">3038       case Op_CallStaticJava:</span>
<span class="line-removed">3039       case Op_CallDynamicJava:</span>
<span class="line-removed">3040       case Op_CallLeaf:</span>
<span class="line-removed">3041       case Op_CallLeafNoFP:</span>
<span class="line-removed">3042       case Op_CompareAndSwapL:</span>
<span class="line-removed">3043       case Op_CompareAndSwapI:</span>
<span class="line-removed">3044       case Op_CompareAndSwapB:</span>
<span class="line-removed">3045       case Op_CompareAndSwapS:</span>
<span class="line-removed">3046       case Op_CompareAndSwapN:</span>
<span class="line-removed">3047       case Op_CompareAndSwapP:</span>
<span class="line-removed">3048       case Op_CompareAndExchangeL:</span>
<span class="line-removed">3049       case Op_CompareAndExchangeI:</span>
<span class="line-removed">3050       case Op_CompareAndExchangeB:</span>
<span class="line-removed">3051       case Op_CompareAndExchangeS:</span>
<span class="line-removed">3052       case Op_CompareAndExchangeN:</span>
<span class="line-removed">3053       case Op_CompareAndExchangeP:</span>
<span class="line-removed">3054       case Op_WeakCompareAndSwapL:</span>
<span class="line-removed">3055       case Op_WeakCompareAndSwapI:</span>
<span class="line-removed">3056       case Op_WeakCompareAndSwapB:</span>
<span class="line-removed">3057       case Op_WeakCompareAndSwapS:</span>
<span class="line-removed">3058       case Op_WeakCompareAndSwapN:</span>
<span class="line-removed">3059       case Op_WeakCompareAndSwapP:</span>
<span class="line-removed">3060       case Op_ShenandoahCompareAndSwapN:</span>
<span class="line-removed">3061       case Op_ShenandoahCompareAndSwapP:</span>
<span class="line-removed">3062       case Op_ShenandoahWeakCompareAndSwapN:</span>
<span class="line-removed">3063       case Op_ShenandoahWeakCompareAndSwapP:</span>
<span class="line-removed">3064       case Op_ShenandoahCompareAndExchangeN:</span>
<span class="line-removed">3065       case Op_ShenandoahCompareAndExchangeP:</span>
<span class="line-removed">3066       case Op_GetAndSetL:</span>
<span class="line-removed">3067       case Op_GetAndSetI:</span>
<span class="line-removed">3068       case Op_GetAndSetB:</span>
<span class="line-removed">3069       case Op_GetAndSetS:</span>
<span class="line-removed">3070       case Op_GetAndSetP:</span>
<span class="line-removed">3071       case Op_GetAndSetN:</span>
<span class="line-removed">3072       case Op_GetAndAddL:</span>
<span class="line-removed">3073       case Op_GetAndAddI:</span>
<span class="line-removed">3074       case Op_GetAndAddB:</span>
<span class="line-removed">3075       case Op_GetAndAddS:</span>
<span class="line-removed">3076       case Op_ShenandoahEnqueueBarrier:</span>
<span class="line-removed">3077       case Op_FastLock:</span>
<span class="line-removed">3078       case Op_FastUnlock:</span>
<span class="line-removed">3079       case Op_Rethrow:</span>
<span class="line-removed">3080       case Op_Return:</span>
<span class="line-removed">3081       case Op_StoreB:</span>
<span class="line-removed">3082       case Op_StoreC:</span>
<span class="line-removed">3083       case Op_StoreD:</span>
<span class="line-removed">3084       case Op_StoreF:</span>
<span class="line-removed">3085       case Op_StoreL:</span>
<span class="line-removed">3086       case Op_StoreLConditional:</span>
<span class="line-removed">3087       case Op_StoreI:</span>
<span class="line-removed">3088       case Op_StoreIConditional:</span>
<span class="line-removed">3089       case Op_StoreN:</span>
<span class="line-removed">3090       case Op_StoreP:</span>
<span class="line-removed">3091       case Op_StoreVector:</span>
<span class="line-removed">3092       case Op_StrInflatedCopy:</span>
<span class="line-removed">3093       case Op_StrCompressedCopy:</span>
<span class="line-removed">3094       case Op_EncodeP:</span>
<span class="line-removed">3095       case Op_CastP2X:</span>
<span class="line-removed">3096       case Op_SafePoint:</span>
<span class="line-removed">3097       case Op_EncodeISOArray:</span>
<span class="line-removed">3098       case Op_AryEq:</span>
<span class="line-removed">3099       case Op_StrEquals:</span>
<span class="line-removed">3100       case Op_StrComp:</span>
<span class="line-removed">3101       case Op_StrIndexOf:</span>
<span class="line-removed">3102       case Op_StrIndexOfChar:</span>
<span class="line-removed">3103       case Op_HasNegatives:</span>
<span class="line-removed">3104         // Known to require barriers</span>
<span class="line-removed">3105         return false;</span>
<span class="line-removed">3106       case Op_CmpP: {</span>
<span class="line-removed">3107         if (n-&gt;in(1)-&gt;bottom_type()-&gt;higher_equal(TypePtr::NULL_PTR) ||</span>
<span class="line-removed">3108             n-&gt;in(2)-&gt;bottom_type()-&gt;higher_equal(TypePtr::NULL_PTR)) {</span>
<span class="line-removed">3109           // One of the sides is known null, no need for barrier.</span>
<span class="line-removed">3110         } else {</span>
<span class="line-removed">3111           return false;</span>
<span class="line-removed">3112         }</span>
<span class="line-removed">3113         break;</span>
<span class="line-removed">3114       }</span>
<span class="line-removed">3115       case Op_LoadB:</span>
<span class="line-removed">3116       case Op_LoadUB:</span>
<span class="line-removed">3117       case Op_LoadUS:</span>
<span class="line-removed">3118       case Op_LoadD:</span>
<span class="line-removed">3119       case Op_LoadF:</span>
<span class="line-removed">3120       case Op_LoadL:</span>
<span class="line-removed">3121       case Op_LoadI:</span>
<span class="line-removed">3122       case Op_LoadS:</span>
<span class="line-removed">3123       case Op_LoadN:</span>
<span class="line-removed">3124       case Op_LoadP:</span>
<span class="line-removed">3125       case Op_LoadVector: {</span>
<span class="line-removed">3126         const TypePtr* adr_type = n-&gt;adr_type();</span>
<span class="line-removed">3127         int alias_idx = Compile::current()-&gt;get_alias_index(adr_type);</span>
<span class="line-removed">3128         Compile::AliasType* alias_type = Compile::current()-&gt;alias_type(alias_idx);</span>
<span class="line-removed">3129         ciField* field = alias_type-&gt;field();</span>
<span class="line-removed">3130         bool is_static = field != NULL &amp;&amp; field-&gt;is_static();</span>
<span class="line-removed">3131         bool is_final = field != NULL &amp;&amp; field-&gt;is_final();</span>
<span class="line-removed">3132 </span>
<span class="line-removed">3133         if (ShenandoahOptimizeStaticFinals &amp;&amp; is_static &amp;&amp; is_final) {</span>
<span class="line-removed">3134           // Loading the constant does not require barriers: it should be handled</span>
<span class="line-removed">3135           // as part of GC roots already.</span>
<span class="line-removed">3136         } else {</span>
<span class="line-removed">3137           return false;</span>
<span class="line-removed">3138         }</span>
<span class="line-removed">3139         break;</span>
<span class="line-removed">3140       }</span>
<span class="line-removed">3141       case Op_Conv2B:</span>
<span class="line-removed">3142       case Op_LoadRange:</span>
<span class="line-removed">3143       case Op_LoadKlass:</span>
<span class="line-removed">3144       case Op_LoadNKlass:</span>
<span class="line-removed">3145         // Do not require barriers</span>
<span class="line-removed">3146         break;</span>
<span class="line-removed">3147       case Op_AddP:</span>
<span class="line-removed">3148       case Op_CheckCastPP:</span>
<span class="line-removed">3149       case Op_CastPP:</span>
<span class="line-removed">3150       case Op_CMoveP:</span>
<span class="line-removed">3151       case Op_Phi:</span>
<span class="line-removed">3152       case Op_ShenandoahLoadReferenceBarrier:</span>
<span class="line-removed">3153         // Whether or not these need the barriers depends on their users</span>
<span class="line-removed">3154         visit_users = true;</span>
<span class="line-removed">3155         break;</span>
<span class="line-removed">3156       default: {</span>
<span class="line-removed">3157 #ifdef ASSERT</span>
<span class="line-removed">3158         fatal(&quot;Unknown node in is_redundant: %s&quot;, NodeClassNames[n-&gt;Opcode()]);</span>
<span class="line-removed">3159 #else</span>
<span class="line-removed">3160         // Default to have excess barriers, rather than miss some.</span>
<span class="line-removed">3161         return false;</span>
<span class="line-removed">3162 #endif</span>
<span class="line-removed">3163       }</span>
<span class="line-removed">3164     }</span>
<span class="line-removed">3165 </span>
<span class="line-removed">3166     stack.pop();</span>
<span class="line-removed">3167     if (visit_users) {</span>
<span class="line-removed">3168       for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-removed">3169         Node* user = n-&gt;fast_out(i);</span>
<span class="line-removed">3170         if (user != NULL) {</span>
<span class="line-removed">3171           stack.push(user, 0);</span>
<span class="line-removed">3172         }</span>
<span class="line-removed">3173       }</span>
<span class="line-removed">3174     }</span>
<span class="line-removed">3175   }</span>
<span class="line-removed">3176 </span>
<span class="line-removed">3177   // No need for barrier found.</span>
<span class="line-removed">3178   return true;</span>
<span class="line-removed">3179 }</span>
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
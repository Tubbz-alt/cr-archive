<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/shenandoahHeap.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahHeap.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahHeapRegion.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahHeap.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 68 }
 69 
 70 inline WorkGang* ShenandoahHeap::get_safepoint_workers() {
 71   return _safepoint_workers;
 72 }
 73 
 74 inline size_t ShenandoahHeap::heap_region_index_containing(const void* addr) const {
 75   uintptr_t region_start = ((uintptr_t) addr);
 76   uintptr_t index = (region_start - (uintptr_t) base()) &gt;&gt; ShenandoahHeapRegion::region_size_bytes_shift();
 77   assert(index &lt; num_regions(), &quot;Region index is in bounds: &quot; PTR_FORMAT, p2i(addr));
 78   return index;
 79 }
 80 
 81 inline ShenandoahHeapRegion* const ShenandoahHeap::heap_region_containing(const void* addr) const {
 82   size_t index = heap_region_index_containing(addr);
 83   ShenandoahHeapRegion* const result = get_region(index);
 84   assert(addr &gt;= result-&gt;bottom() &amp;&amp; addr &lt; result-&gt;end(), &quot;Heap region contains the address: &quot; PTR_FORMAT, p2i(addr));
 85   return result;
 86 }
 87 








 88 template &lt;class T&gt;
 89 inline oop ShenandoahHeap::update_with_forwarded_not_null(T* p, oop obj) {
 90   if (in_collection_set(obj)) {
 91     shenandoah_assert_forwarded_except(p, obj, is_full_gc_in_progress() || cancelled_gc() || is_degenerated_gc_in_progress());
 92     obj = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);
 93     RawAccess&lt;IS_NOT_NULL&gt;::oop_store(p, obj);
 94   }
 95 #ifdef ASSERT
 96   else {
 97     shenandoah_assert_not_forwarded(p, obj);
 98   }
 99 #endif
100   return obj;
101 }
102 
103 template &lt;class T&gt;
104 inline oop ShenandoahHeap::maybe_update_with_forwarded(T* p) {
105   T o = RawAccess&lt;&gt;::oop_load(p);
106   if (!CompressedOops::is_null(o)) {
107     oop obj = CompressedOops::decode_not_null(o);
</pre>
</td>
<td>
<hr />
<pre>
 68 }
 69 
 70 inline WorkGang* ShenandoahHeap::get_safepoint_workers() {
 71   return _safepoint_workers;
 72 }
 73 
 74 inline size_t ShenandoahHeap::heap_region_index_containing(const void* addr) const {
 75   uintptr_t region_start = ((uintptr_t) addr);
 76   uintptr_t index = (region_start - (uintptr_t) base()) &gt;&gt; ShenandoahHeapRegion::region_size_bytes_shift();
 77   assert(index &lt; num_regions(), &quot;Region index is in bounds: &quot; PTR_FORMAT, p2i(addr));
 78   return index;
 79 }
 80 
 81 inline ShenandoahHeapRegion* const ShenandoahHeap::heap_region_containing(const void* addr) const {
 82   size_t index = heap_region_index_containing(addr);
 83   ShenandoahHeapRegion* const result = get_region(index);
 84   assert(addr &gt;= result-&gt;bottom() &amp;&amp; addr &lt; result-&gt;end(), &quot;Heap region contains the address: &quot; PTR_FORMAT, p2i(addr));
 85   return result;
 86 }
 87 
<span class="line-added"> 88 inline void ShenandoahHeap::enter_evacuation(Thread* t) {</span>
<span class="line-added"> 89   _oom_evac_handler.enter_evacuation(t);</span>
<span class="line-added"> 90 }</span>
<span class="line-added"> 91 </span>
<span class="line-added"> 92 inline void ShenandoahHeap::leave_evacuation(Thread* t) {</span>
<span class="line-added"> 93   _oom_evac_handler.leave_evacuation(t);</span>
<span class="line-added"> 94 }</span>
<span class="line-added"> 95 </span>
 96 template &lt;class T&gt;
 97 inline oop ShenandoahHeap::update_with_forwarded_not_null(T* p, oop obj) {
 98   if (in_collection_set(obj)) {
 99     shenandoah_assert_forwarded_except(p, obj, is_full_gc_in_progress() || cancelled_gc() || is_degenerated_gc_in_progress());
100     obj = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);
101     RawAccess&lt;IS_NOT_NULL&gt;::oop_store(p, obj);
102   }
103 #ifdef ASSERT
104   else {
105     shenandoah_assert_not_forwarded(p, obj);
106   }
107 #endif
108   return obj;
109 }
110 
111 template &lt;class T&gt;
112 inline oop ShenandoahHeap::maybe_update_with_forwarded(T* p) {
113   T o = RawAccess&lt;&gt;::oop_load(p);
114   if (!CompressedOops::is_null(o)) {
115     oop obj = CompressedOops::decode_not_null(o);
</pre>
</td>
</tr>
</table>
<center><a href="shenandoahHeap.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahHeapRegion.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
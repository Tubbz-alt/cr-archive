<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/loopnode.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="loopnode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="loopopts.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/loopnode.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1013   // Build and verify the loop tree without modifying the graph.  This
1014   // is useful to verify that all inputs properly dominate their uses.
1015   static void verify(PhaseIterGVN&amp; igvn) {
1016 #ifdef ASSERT
1017     ResourceMark rm;
1018     PhaseIdealLoop v(igvn);
1019 #endif
1020   }
1021 
1022   // Recommended way to use PhaseIdealLoop.
1023   // Run PhaseIdealLoop in some mode and allocates a local scope for memory allocations.
1024   static void optimize(PhaseIterGVN &amp;igvn, LoopOptsMode mode) {
1025     ResourceMark rm;
1026     PhaseIdealLoop v(igvn, mode);
1027   }
1028 
1029   // True if the method has at least 1 irreducible loop
1030   bool _has_irreducible_loops;
1031 
1032   // Per-Node transform
<span class="line-modified">1033   virtual Node* transform(Node* n) { return 0; }</span>






1034 
1035   bool is_counted_loop(Node* n, IdealLoopTree* &amp;loop);

1036   IdealLoopTree* create_outer_strip_mined_loop(BoolNode *test, Node *cmp, Node *init_control,
1037                                                IdealLoopTree* loop, float cl_prob, float le_fcnt,
1038                                                Node*&amp; entry_control, Node*&amp; iffalse);
1039 
1040   Node* exact_limit( IdealLoopTree *loop );
1041 
1042   // Return a post-walked LoopNode
1043   IdealLoopTree *get_loop( Node *n ) const {
1044     // Dead nodes have no loop, so return the top level loop instead
1045     if (!has_node(n))  return _ltree_root;
1046     assert(!has_ctrl(n), &quot;&quot;);
1047     return (IdealLoopTree*)_nodes[n-&gt;_idx];
1048   }
1049 
1050   IdealLoopTree* ltree_root() const { return _ltree_root; }
1051 
1052   // Is &#39;n&#39; a (nested) member of &#39;loop&#39;?
1053   int is_member( const IdealLoopTree *loop, Node *n ) const {
1054     return loop-&gt;is_member(get_loop(n)); }
1055 
</pre>
<hr />
<pre>
1119   // will repeat till the doubled loop body does all remaining iterations in 1
1120   // pass.
1121   void do_maximally_unroll( IdealLoopTree *loop, Node_List &amp;old_new );
1122 
1123   // Unroll the loop body one step - make each trip do 2 iterations.
1124   void do_unroll( IdealLoopTree *loop, Node_List &amp;old_new, bool adjust_min_trip );
1125 
1126   // Mark vector reduction candidates before loop unrolling
1127   void mark_reductions( IdealLoopTree *loop );
1128 
1129   // Return true if exp is a constant times an induction var
1130   bool is_scaled_iv(Node* exp, Node* iv, int* p_scale);
1131 
1132   // Return true if exp is a scaled induction var plus (or minus) constant
1133   bool is_scaled_iv_plus_offset(Node* exp, Node* iv, int* p_scale, Node** p_offset, int depth = 0);
1134 
1135   // Create a new if above the uncommon_trap_if_pattern for the predicate to be promoted
1136   ProjNode* create_new_if_for_predicate(ProjNode* cont_proj, Node* new_entry, Deoptimization::DeoptReason reason,
1137                                         int opcode, bool if_cont_is_true_proj = true);
1138 
<span class="line-modified">1139   void register_control(Node* n, IdealLoopTree *loop, Node* pred);</span>
1140 
1141   static Node* skip_all_loop_predicates(Node* entry);
1142   static Node* skip_loop_predicates(Node* entry);
1143 
1144   // Find a good location to insert a predicate
1145   static ProjNode* find_predicate_insertion_point(Node* start_c, Deoptimization::DeoptReason reason);
1146   // Find a predicate
1147   static Node* find_predicate(Node* entry);
1148   // Construct a range check for a predicate if
1149   BoolNode* rc_predicate(IdealLoopTree *loop, Node* ctrl,
1150                          int scale, Node* offset,
1151                          Node* init, Node* limit, jint stride,
1152                          Node* range, bool upper, bool &amp;overflow);
1153 
1154   // Implementation of the loop predication to promote checks outside the loop
1155   bool loop_predication_impl(IdealLoopTree *loop);
1156   bool loop_predication_impl_helper(IdealLoopTree *loop, ProjNode* proj, ProjNode *predicate_proj,
1157                                     CountedLoopNode *cl, ConNode* zero, Invariance&amp; invar,
1158                                     Deoptimization::DeoptReason reason);
1159   bool loop_predication_should_follow_branches(IdealLoopTree *loop, ProjNode *predicate_proj, float&amp; loop_trip_cnt);
</pre>
</td>
<td>
<hr />
<pre>
1013   // Build and verify the loop tree without modifying the graph.  This
1014   // is useful to verify that all inputs properly dominate their uses.
1015   static void verify(PhaseIterGVN&amp; igvn) {
1016 #ifdef ASSERT
1017     ResourceMark rm;
1018     PhaseIdealLoop v(igvn);
1019 #endif
1020   }
1021 
1022   // Recommended way to use PhaseIdealLoop.
1023   // Run PhaseIdealLoop in some mode and allocates a local scope for memory allocations.
1024   static void optimize(PhaseIterGVN &amp;igvn, LoopOptsMode mode) {
1025     ResourceMark rm;
1026     PhaseIdealLoop v(igvn, mode);
1027   }
1028 
1029   // True if the method has at least 1 irreducible loop
1030   bool _has_irreducible_loops;
1031 
1032   // Per-Node transform
<span class="line-modified">1033   virtual Node* transform(Node* n) { return NULL; }</span>
<span class="line-added">1034 </span>
<span class="line-added">1035   Node* loop_exit_control(Node* x, IdealLoopTree* loop);</span>
<span class="line-added">1036   Node* loop_exit_test(Node* back_control, IdealLoopTree* loop, Node*&amp; incr, Node*&amp; limit, BoolTest::mask&amp; bt, float&amp; cl_prob);</span>
<span class="line-added">1037   Node* loop_iv_incr(Node* incr, Node* x, IdealLoopTree* loop, Node*&amp; phi_incr);</span>
<span class="line-added">1038   Node* loop_iv_stride(Node* incr, IdealLoopTree* loop, Node*&amp; xphi);</span>
<span class="line-added">1039   PhiNode* loop_iv_phi(Node* xphi, Node* phi_incr, Node* x, IdealLoopTree* loop);</span>
1040 
1041   bool is_counted_loop(Node* n, IdealLoopTree* &amp;loop);
<span class="line-added">1042   IdealLoopTree* insert_outer_loop(IdealLoopTree* loop, LoopNode* outer_l, Node* outer_ift);</span>
1043   IdealLoopTree* create_outer_strip_mined_loop(BoolNode *test, Node *cmp, Node *init_control,
1044                                                IdealLoopTree* loop, float cl_prob, float le_fcnt,
1045                                                Node*&amp; entry_control, Node*&amp; iffalse);
1046 
1047   Node* exact_limit( IdealLoopTree *loop );
1048 
1049   // Return a post-walked LoopNode
1050   IdealLoopTree *get_loop( Node *n ) const {
1051     // Dead nodes have no loop, so return the top level loop instead
1052     if (!has_node(n))  return _ltree_root;
1053     assert(!has_ctrl(n), &quot;&quot;);
1054     return (IdealLoopTree*)_nodes[n-&gt;_idx];
1055   }
1056 
1057   IdealLoopTree* ltree_root() const { return _ltree_root; }
1058 
1059   // Is &#39;n&#39; a (nested) member of &#39;loop&#39;?
1060   int is_member( const IdealLoopTree *loop, Node *n ) const {
1061     return loop-&gt;is_member(get_loop(n)); }
1062 
</pre>
<hr />
<pre>
1126   // will repeat till the doubled loop body does all remaining iterations in 1
1127   // pass.
1128   void do_maximally_unroll( IdealLoopTree *loop, Node_List &amp;old_new );
1129 
1130   // Unroll the loop body one step - make each trip do 2 iterations.
1131   void do_unroll( IdealLoopTree *loop, Node_List &amp;old_new, bool adjust_min_trip );
1132 
1133   // Mark vector reduction candidates before loop unrolling
1134   void mark_reductions( IdealLoopTree *loop );
1135 
1136   // Return true if exp is a constant times an induction var
1137   bool is_scaled_iv(Node* exp, Node* iv, int* p_scale);
1138 
1139   // Return true if exp is a scaled induction var plus (or minus) constant
1140   bool is_scaled_iv_plus_offset(Node* exp, Node* iv, int* p_scale, Node** p_offset, int depth = 0);
1141 
1142   // Create a new if above the uncommon_trap_if_pattern for the predicate to be promoted
1143   ProjNode* create_new_if_for_predicate(ProjNode* cont_proj, Node* new_entry, Deoptimization::DeoptReason reason,
1144                                         int opcode, bool if_cont_is_true_proj = true);
1145 
<span class="line-modified">1146   void register_control(Node* n, IdealLoopTree *loop, Node* pred, bool update_body = true);</span>
1147 
1148   static Node* skip_all_loop_predicates(Node* entry);
1149   static Node* skip_loop_predicates(Node* entry);
1150 
1151   // Find a good location to insert a predicate
1152   static ProjNode* find_predicate_insertion_point(Node* start_c, Deoptimization::DeoptReason reason);
1153   // Find a predicate
1154   static Node* find_predicate(Node* entry);
1155   // Construct a range check for a predicate if
1156   BoolNode* rc_predicate(IdealLoopTree *loop, Node* ctrl,
1157                          int scale, Node* offset,
1158                          Node* init, Node* limit, jint stride,
1159                          Node* range, bool upper, bool &amp;overflow);
1160 
1161   // Implementation of the loop predication to promote checks outside the loop
1162   bool loop_predication_impl(IdealLoopTree *loop);
1163   bool loop_predication_impl_helper(IdealLoopTree *loop, ProjNode* proj, ProjNode *predicate_proj,
1164                                     CountedLoopNode *cl, ConNode* zero, Invariance&amp; invar,
1165                                     Deoptimization::DeoptReason reason);
1166   bool loop_predication_should_follow_branches(IdealLoopTree *loop, ProjNode *predicate_proj, float&amp; loop_trip_cnt);
</pre>
</td>
</tr>
</table>
<center><a href="loopnode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="loopopts.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
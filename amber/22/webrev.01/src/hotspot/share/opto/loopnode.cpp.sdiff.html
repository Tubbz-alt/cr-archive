<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/loopnode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="loopPredicate.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="loopnode.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/loopnode.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 246   set_ctrl(n, early);
 247 }
 248 
 249 //------------------------------set_subtree_ctrl-------------------------------
 250 // set missing _ctrl entries on new nodes
 251 void PhaseIdealLoop::set_subtree_ctrl( Node *n ) {
 252   // Already set?  Get out.
 253   if( _nodes[n-&gt;_idx] ) return;
 254   // Recursively set _nodes array to indicate where the Node goes
 255   uint i;
 256   for( i = 0; i &lt; n-&gt;req(); ++i ) {
 257     Node *m = n-&gt;in(i);
 258     if( m &amp;&amp; m != C-&gt;root() )
 259       set_subtree_ctrl( m );
 260   }
 261 
 262   // Fixup self
 263   set_early_ctrl( n );
 264 }
 265 






















 266 // Create a skeleton strip mined outer loop: a Loop head before the
 267 // inner strip mined loop, a safepoint and an exit condition guarded
 268 // by an opaque node after the inner strip mined loop with a backedge
 269 // to the loop head. The inner strip mined loop is left as it is. Only
 270 // once loop optimizations are over, do we adjust the inner loop exit
 271 // condition to limit its number of iterations, set the outer loop
 272 // exit condition and add Phis to the outer loop head. Some loop
 273 // optimizations that operate on the inner strip mined loop need to be
 274 // aware of the outer strip mined loop: loop unswitching needs to
 275 // clone the outer loop as well as the inner, unrolling needs to only
 276 // clone the inner loop etc. No optimizations need to change the outer
 277 // strip mined loop as it is only a skeleton.
 278 IdealLoopTree* PhaseIdealLoop::create_outer_strip_mined_loop(BoolNode *test, Node *cmp, Node *init_control,
 279                                                              IdealLoopTree* loop, float cl_prob, float le_fcnt,
 280                                                              Node*&amp; entry_control, Node*&amp; iffalse) {
 281   Node* outer_test = _igvn.intcon(0);
 282   set_ctrl(outer_test, C-&gt;root());
 283   Node *orig = iffalse;
 284   iffalse = iffalse-&gt;clone();
 285   _igvn.register_new_node_with_optimizer(iffalse);
 286   set_idom(iffalse, idom(orig), dom_depth(orig));
 287 
 288   IfNode *outer_le = new OuterStripMinedLoopEndNode(iffalse, outer_test, cl_prob, le_fcnt);
 289   Node *outer_ift = new IfTrueNode (outer_le);
 290   Node* outer_iff = orig;
 291   _igvn.replace_input_of(outer_iff, 0, outer_le);
 292 
 293   LoopNode *outer_l = new OuterStripMinedLoopNode(C, init_control, outer_ift);
 294   entry_control = outer_l;
 295 
<span class="line-modified"> 296   IdealLoopTree* outer_ilt = new IdealLoopTree(this, outer_l, outer_ift);</span>
<span class="line-removed"> 297   IdealLoopTree* parent = loop-&gt;_parent;</span>
<span class="line-removed"> 298   IdealLoopTree* sibling = parent-&gt;_child;</span>
<span class="line-removed"> 299   if (sibling == loop) {</span>
<span class="line-removed"> 300     parent-&gt;_child = outer_ilt;</span>
<span class="line-removed"> 301   } else {</span>
<span class="line-removed"> 302     while (sibling-&gt;_next != loop) {</span>
<span class="line-removed"> 303       sibling = sibling-&gt;_next;</span>
<span class="line-removed"> 304     }</span>
<span class="line-removed"> 305     sibling-&gt;_next = outer_ilt;</span>
<span class="line-removed"> 306   }</span>
<span class="line-removed"> 307   outer_ilt-&gt;_next = loop-&gt;_next;</span>
<span class="line-removed"> 308   outer_ilt-&gt;_parent = parent;</span>
<span class="line-removed"> 309   outer_ilt-&gt;_child = loop;</span>
<span class="line-removed"> 310   outer_ilt-&gt;_nest = loop-&gt;_nest;</span>
<span class="line-removed"> 311   loop-&gt;_parent = outer_ilt;</span>
<span class="line-removed"> 312   loop-&gt;_next = NULL;</span>
<span class="line-removed"> 313   loop-&gt;_nest++;</span>
 314 
 315   set_loop(iffalse, outer_ilt);
<span class="line-modified"> 316   register_control(outer_le, outer_ilt, iffalse);</span>
<span class="line-modified"> 317   register_control(outer_ift, outer_ilt, outer_le);</span>


 318   set_idom(outer_iff, outer_le, dom_depth(outer_le));
 319   _igvn.register_new_node_with_optimizer(outer_l);
 320   set_loop(outer_l, outer_ilt);
 321   set_idom(outer_l, init_control, dom_depth(init_control)+1);
 322 
 323   return outer_ilt;
 324 }
 325 
 326 void PhaseIdealLoop::insert_loop_limit_check(ProjNode* limit_check_proj, Node* cmp_limit, Node* bol) {
 327   Node* new_predicate_proj = create_new_if_for_predicate(limit_check_proj, NULL,
 328                                                          Deoptimization::Reason_loop_limit_check,
 329                                                          Op_If);
 330   Node* iff = new_predicate_proj-&gt;in(0);
 331   assert(iff-&gt;Opcode() == Op_If, &quot;bad graph shape&quot;);
 332   Node* conv = iff-&gt;in(1);
 333   assert(conv-&gt;Opcode() == Op_Conv2B, &quot;bad graph shape&quot;);
 334   Node* opaq = conv-&gt;in(1);
 335   assert(opaq-&gt;Opcode() == Op_Opaque1, &quot;bad graph shape&quot;);
 336   cmp_limit = _igvn.register_new_node_with_optimizer(cmp_limit);
 337   bol = _igvn.register_new_node_with_optimizer(bol);
 338   set_subtree_ctrl(bol);
 339   _igvn.replace_input_of(iff, 1, bol);
 340 
 341 #ifndef PRODUCT
 342   // report that the loop predication has been actually performed
 343   // for this loop
 344   if (TraceLoopLimitCheck) {
 345     tty-&gt;print_cr(&quot;Counted Loop Limit Check generated:&quot;);
 346     debug_only( bol-&gt;dump(2); )
 347   }
 348 #endif
 349 }
 350 
<span class="line-modified"> 351 //------------------------------is_counted_loop--------------------------------</span>
<span class="line-removed"> 352 bool PhaseIdealLoop::is_counted_loop(Node* x, IdealLoopTree*&amp; loop) {</span>
<span class="line-removed"> 353   PhaseGVN *gvn = &amp;_igvn;</span>
<span class="line-removed"> 354 </span>
 355   // Counted loop head must be a good RegionNode with only 3 not NULL
 356   // control input edges: Self, Entry, LoopBack.
 357   if (x-&gt;in(LoopNode::Self) == NULL || x-&gt;req() != 3 || loop-&gt;_irreducible) {
<span class="line-modified"> 358     return false;</span>
 359   }
 360   Node *init_control = x-&gt;in(LoopNode::EntryControl);
 361   Node *back_control = x-&gt;in(LoopNode::LoopBackControl);
<span class="line-modified"> 362   if (init_control == NULL || back_control == NULL)    // Partially dead</span>
<span class="line-modified"> 363     return false;</span>

 364   // Must also check for TOP when looking for a dead loop
<span class="line-modified"> 365   if (init_control-&gt;is_top() || back_control-&gt;is_top())</span>
<span class="line-modified"> 366     return false;</span>

 367 
 368   // Allow funny placement of Safepoint
 369   if (back_control-&gt;Opcode() == Op_SafePoint) {
<span class="line-removed"> 370     if (LoopStripMiningIter != 0) {</span>
<span class="line-removed"> 371       // Leaving the safepoint on the backedge and creating a</span>
<span class="line-removed"> 372       // CountedLoop will confuse optimizations. We can&#39;t move the</span>
<span class="line-removed"> 373       // safepoint around because its jvm state wouldn&#39;t match a new</span>
<span class="line-removed"> 374       // location. Give up on that loop.</span>
<span class="line-removed"> 375       return false;</span>
<span class="line-removed"> 376     }</span>
 377     back_control = back_control-&gt;in(TypeFunc::Control);
 378   }
 379 
 380   // Controlling test for loop
 381   Node *iftrue = back_control;
 382   uint iftrue_op = iftrue-&gt;Opcode();
 383   if (iftrue_op != Op_IfTrue &amp;&amp;
<span class="line-modified"> 384       iftrue_op != Op_IfFalse)</span>
 385     // I have a weird back-control.  Probably the loop-exit test is in
 386     // the middle of the loop and I am looking at some trailing control-flow
 387     // merge point.  To fix this I would have to partially peel the loop.
<span class="line-modified"> 388     return false; // Obscure back-control</span>

 389 
 390   // Get boolean guarding loop-back test
 391   Node *iff = iftrue-&gt;in(0);
<span class="line-modified"> 392   if (get_loop(iff) != loop || !iff-&gt;in(1)-&gt;is_Bool())</span>
<span class="line-modified"> 393     return false;</span>
<span class="line-modified"> 394   BoolNode *test = iff-&gt;in(1)-&gt;as_Bool();</span>
<span class="line-modified"> 395   BoolTest::mask bt = test-&gt;_test._test;</span>
<span class="line-modified"> 396   float cl_prob = iff-&gt;as_If()-&gt;_prob;</span>








 397   if (iftrue_op == Op_IfFalse) {
 398     bt = BoolTest(bt).negate();
 399     cl_prob = 1.0 - cl_prob;
 400   }
 401   // Get backedge compare
<span class="line-modified"> 402   Node *cmp = test-&gt;in(1);</span>
<span class="line-modified"> 403   int cmp_op = cmp-&gt;Opcode();</span>
<span class="line-modified"> 404   if (cmp_op != Op_CmpI)</span>
<span class="line-modified"> 405     return false;                // Avoid pointer &amp; float compares</span>
 406 
 407   // Find the trip-counter increment &amp; limit.  Limit must be loop invariant.
<span class="line-modified"> 408   Node *incr  = cmp-&gt;in(1);</span>
<span class="line-modified"> 409   Node *limit = cmp-&gt;in(2);</span>
 410 
 411   // ---------
 412   // need &#39;loop()&#39; test to tell if limit is loop invariant
 413   // ---------
 414 
 415   if (!is_member(loop, get_ctrl(incr))) { // Swapped trip counter and limit?
<span class="line-modified"> 416     Node *tmp = incr;            // Then reverse order into the CmpI</span>
 417     incr = limit;
 418     limit = tmp;
 419     bt = BoolTest(bt).commute(); // And commute the exit test
 420   }
<span class="line-modified"> 421   if (is_member(loop, get_ctrl(limit))) // Limit must be loop-invariant</span>
<span class="line-modified"> 422     return false;</span>
<span class="line-modified"> 423   if (!is_member(loop, get_ctrl(incr))) // Trip counter must be loop-variant</span>














































































 424     return false;











 425 
<span class="line-removed"> 426   Node* phi_incr = NULL;</span>
 427   // Trip-counter increment must be commutative &amp; associative.
 428   if (incr-&gt;Opcode() == Op_CastII) {
 429     incr = incr-&gt;in(1);
 430   }
<span class="line-modified"> 431   if (incr-&gt;is_Phi()) {</span>
<span class="line-modified"> 432     if (incr-&gt;as_Phi()-&gt;region() != x || incr-&gt;req() != 3)</span>
<span class="line-modified"> 433       return false; // Not simple trip counter expression</span>
<span class="line-modified"> 434     phi_incr = incr;</span>
<span class="line-modified"> 435     incr = phi_incr-&gt;in(LoopNode::LoopBackControl); // Assume incr is on backedge of Phi</span>
<span class="line-removed"> 436     if (!is_member(loop, get_ctrl(incr))) // Trip counter must be loop-variant</span>
<span class="line-removed"> 437       return false;</span>
 438   }
 439 
 440   Node* trunc1 = NULL;
 441   Node* trunc2 = NULL;
 442   const TypeInt* iv_trunc_t = NULL;
 443   Node* orig_incr = incr;
 444   if (!(incr = CountedLoopNode::match_incr_with_optional_truncation(incr, &amp;trunc1, &amp;trunc2, &amp;iv_trunc_t))) {
 445     return false; // Funny increment opcode
 446   }
 447   assert(incr-&gt;Opcode() == Op_AddI, &quot;wrong increment code&quot;);
 448 





































 449   const TypeInt* limit_t = gvn-&gt;type(limit)-&gt;is_int();
 450   if (trunc1 != NULL) {
 451     // When there is a truncation, we must be sure that after the truncation
 452     // the trip counter will end up higher than the limit, otherwise we are looking
 453     // at an endless loop. Can happen with range checks.
 454 
 455     // Example:
 456     // int i = 0;
 457     // while (true)
 458     //    sum + = array[i];
 459     //    i++;
 460     //    i = i &amp;&amp; 0x7fff;
 461     //  }
 462     //
 463     // If the array is shorter than 0x8000 this exits through a AIOOB
 464     //  - Counted loop transformation is ok
 465     // If the array is longer then this is an endless loop
 466     //  - No transformation can be done.
 467 
 468     const TypeInt* incr_t = gvn-&gt;type(orig_incr)-&gt;is_int();
 469     if (limit_t-&gt;_hi &gt; incr_t-&gt;_hi) {
 470       // if the limit can have a higher value than the increment (before the phi)
 471       return false;
 472     }
 473   }
 474 
<span class="line-removed"> 475   // Get merge point</span>
<span class="line-removed"> 476   Node *xphi = incr-&gt;in(1);</span>
<span class="line-removed"> 477   Node *stride = incr-&gt;in(2);</span>
<span class="line-removed"> 478   if (!stride-&gt;is_Con()) {     // Oops, swap these</span>
<span class="line-removed"> 479     if (!xphi-&gt;is_Con())       // Is the other guy a constant?</span>
<span class="line-removed"> 480       return false;             // Nope, unknown stride, bail out</span>
<span class="line-removed"> 481     Node *tmp = xphi;           // &#39;incr&#39; is commutative, so ok to swap</span>
<span class="line-removed"> 482     xphi = stride;</span>
<span class="line-removed"> 483     stride = tmp;</span>
<span class="line-removed"> 484   }</span>
<span class="line-removed"> 485   if (xphi-&gt;Opcode() == Op_CastII) {</span>
<span class="line-removed"> 486     xphi = xphi-&gt;in(1);</span>
<span class="line-removed"> 487   }</span>
<span class="line-removed"> 488   // Stride must be constant</span>
<span class="line-removed"> 489   int stride_con = stride-&gt;get_int();</span>
<span class="line-removed"> 490   if (stride_con == 0)</span>
<span class="line-removed"> 491     return false; // missed some peephole opt</span>
<span class="line-removed"> 492 </span>
<span class="line-removed"> 493   if (!xphi-&gt;is_Phi())</span>
<span class="line-removed"> 494     return false; // Too much math on the trip counter</span>
<span class="line-removed"> 495   if (phi_incr != NULL &amp;&amp; phi_incr != xphi)</span>
<span class="line-removed"> 496     return false;</span>
<span class="line-removed"> 497   PhiNode *phi = xphi-&gt;as_Phi();</span>
<span class="line-removed"> 498 </span>
<span class="line-removed"> 499   // Phi must be of loop header; backedge must wrap to increment</span>
<span class="line-removed"> 500   if (phi-&gt;region() != x)</span>
<span class="line-removed"> 501     return false;</span>
<span class="line-removed"> 502   if ((trunc1 == NULL &amp;&amp; phi-&gt;in(LoopNode::LoopBackControl) != incr) ||</span>
<span class="line-removed"> 503       (trunc1 != NULL &amp;&amp; phi-&gt;in(LoopNode::LoopBackControl) != trunc1)) {</span>
<span class="line-removed"> 504     return false;</span>
<span class="line-removed"> 505   }</span>
 506   Node *init_trip = phi-&gt;in(LoopNode::EntryControl);
 507 
 508   // If iv trunc type is smaller than int, check for possible wrap.
 509   if (!TypeInt::INT-&gt;higher_equal(iv_trunc_t)) {
 510     assert(trunc1 != NULL, &quot;must have found some truncation&quot;);
 511 
 512     // Get a better type for the phi (filtered thru if&#39;s)
 513     const TypeInt* phi_ft = filtered_type(phi);
 514 
 515     // Can iv take on a value that will wrap?
 516     //
 517     // Ensure iv&#39;s limit is not within &quot;stride&quot; of the wrap value.
 518     //
 519     // Example for &quot;short&quot; type
 520     //    Truncation ensures value is in the range -32768..32767 (iv_trunc_t)
 521     //    If the stride is +10, then the last value of the induction
 522     //    variable before the increment (phi_ft-&gt;_hi) must be
 523     //    &lt;= 32767 - 10 and (phi_ft-&gt;_lo) must be &gt;= -32768 to
 524     //    ensure no truncation occurs after the increment.
 525 
</pre>
<hr />
<pre>
 591   //
 592   // for (i=0; i &lt;= max_jint; i++) {}
 593   // for (i=0; i &lt;  max_jint; i+=2) {}
 594   //
 595   //
 596   // Limit check predicate depends on the loop test:
 597   //
 598   // for(;i != limit; i++)       --&gt; limit &lt;= (max_jint)
 599   // for(;i &lt;  limit; i+=stride) --&gt; limit &lt;= (max_jint - stride + 1)
 600   // for(;i &lt;= limit; i+=stride) --&gt; limit &lt;= (max_jint - stride    )
 601   //
 602 
 603   // Check if limit is excluded to do more precise int overflow check.
 604   bool incl_limit = (bt == BoolTest::le || bt == BoolTest::ge);
 605   int stride_m  = stride_con - (incl_limit ? 0 : (stride_con &gt; 0 ? 1 : -1));
 606 
 607   // If compare points directly to the phi we need to adjust
 608   // the compare so that it points to the incr. Limit have
 609   // to be adjusted to keep trip count the same and the
 610   // adjusted limit should be checked for int overflow.

 611   if (phi_incr != NULL) {
 612     stride_m  += stride_con;
 613   }
 614 
<span class="line-modified"> 615   if (limit-&gt;is_Con()) {</span>
<span class="line-modified"> 616     int limit_con = limit-&gt;get_int();</span>
<span class="line-modified"> 617     if ((stride_con &gt; 0 &amp;&amp; limit_con &gt; (max_jint - stride_m)) ||</span>
<span class="line-modified"> 618         (stride_con &lt; 0 &amp;&amp; limit_con &lt; (min_jint - stride_m))) {</span>
<span class="line-modified"> 619       // Bailout: it could be integer overflow.</span>
<span class="line-modified"> 620       return false;</span>


 621     }
<span class="line-removed"> 622   } else if ((stride_con &gt; 0 &amp;&amp; limit_t-&gt;_hi &lt;= (max_jint - stride_m)) ||</span>
<span class="line-removed"> 623              (stride_con &lt; 0 &amp;&amp; limit_t-&gt;_lo &gt;= (min_jint - stride_m))) {</span>
<span class="line-removed"> 624       // Limit&#39;s type may satisfy the condition, for example,</span>
<span class="line-removed"> 625       // when it is an array length.</span>
<span class="line-removed"> 626   } else {</span>
 627     // Generate loop&#39;s limit check.
 628     // Loop limit check predicate should be near the loop.
 629     ProjNode *limit_check_proj = find_predicate_insertion_point(init_control, Deoptimization::Reason_loop_limit_check);
 630     if (!limit_check_proj) {
 631       // The limit check predicate is not generated if this method trapped here before.
 632 #ifdef ASSERT
 633       if (TraceLoopLimitCheck) {
 634         tty-&gt;print(&quot;missing loop limit check:&quot;);
 635         loop-&gt;dump_head();
 636         x-&gt;dump(1);
 637       }
 638 #endif
 639       return false;
 640     }
 641 
 642     IfNode* check_iff = limit_check_proj-&gt;in(0)-&gt;as_If();
 643 
 644     if (!is_dominator(get_ctrl(limit), check_iff-&gt;in(0))) {
 645       return false;
 646     }
</pre>
<hr />
<pre>
 704       if (stride_con &gt; 0) {
 705         // &#39;ne&#39; can be replaced with &#39;lt&#39; only when init &lt; limit.
 706         bt = BoolTest::lt;
 707       } else if (stride_con &lt; 0) {
 708         // &#39;ne&#39; can be replaced with &#39;gt&#39; only when init &gt; limit.
 709         bt = BoolTest::gt;
 710       }
 711     }
 712   }
 713 
 714   if (phi_incr != NULL) {
 715     // If compare points directly to the phi we need to adjust
 716     // the compare so that it points to the incr. Limit have
 717     // to be adjusted to keep trip count the same and we
 718     // should avoid int overflow.
 719     //
 720     //   i = init; do {} while(i++ &lt; limit);
 721     // is converted to
 722     //   i = init; do {} while(++i &lt; limit+1);
 723     //
<span class="line-modified"> 724     limit = gvn-&gt;transform(new AddINode(limit, stride));</span>
 725   }
 726 
 727   if (incl_limit) {
 728     // The limit check guaranties that &#39;limit &lt;= (max_jint - stride)&#39; so
 729     // we can convert &#39;i &lt;= limit&#39; to &#39;i &lt; limit+1&#39; since stride != 0.
 730     //
 731     Node* one = (stride_con &gt; 0) ? gvn-&gt;intcon( 1) : gvn-&gt;intcon(-1);
<span class="line-modified"> 732     limit = gvn-&gt;transform(new AddINode(limit, one));</span>
 733     if (bt == BoolTest::le)
 734       bt = BoolTest::lt;
 735     else if (bt == BoolTest::ge)
 736       bt = BoolTest::gt;
 737     else
 738       ShouldNotReachHere();
 739   }
<span class="line-modified"> 740   set_subtree_ctrl( limit );</span>
 741 
 742   if (LoopStripMiningIter == 0) {
 743     // Check for SafePoint on backedge and remove
 744     Node *sfpt = x-&gt;in(LoopNode::LoopBackControl);
 745     if (sfpt-&gt;Opcode() == Op_SafePoint &amp;&amp; is_deleteable_safept(sfpt)) {
 746       lazy_replace( sfpt, iftrue );
 747       if (loop-&gt;_safepts != NULL) {
 748         loop-&gt;_safepts-&gt;yank(sfpt);
 749       }
 750       loop-&gt;_tail = iftrue;
 751     }
 752   }
 753 
 754   // Build a canonical trip test.
 755   // Clone code, as old values may be in use.
 756   incr = incr-&gt;clone();
 757   incr-&gt;set_req(1,phi);
 758   incr-&gt;set_req(2,stride);
 759   incr = _igvn.register_new_node_with_optimizer(incr);
 760   set_early_ctrl( incr );
 761   _igvn.rehash_node_delayed(phi);
 762   phi-&gt;set_req_X( LoopNode::LoopBackControl, incr, &amp;_igvn );
 763 
 764   // If phi type is more restrictive than Int, raise to
 765   // Int to prevent (almost) infinite recursion in igvn
 766   // which can only handle integer types for constants or minint..maxint.
 767   if (!TypeInt::INT-&gt;higher_equal(phi-&gt;bottom_type())) {
 768     Node* nphi = PhiNode::make(phi-&gt;in(0), phi-&gt;in(LoopNode::EntryControl), TypeInt::INT);
 769     nphi-&gt;set_req(LoopNode::LoopBackControl, phi-&gt;in(LoopNode::LoopBackControl));
 770     nphi = _igvn.register_new_node_with_optimizer(nphi);
 771     set_ctrl(nphi, get_ctrl(phi));
 772     _igvn.replace_node(phi, nphi);
 773     phi = nphi-&gt;as_Phi();
 774   }
 775   cmp = cmp-&gt;clone();
 776   cmp-&gt;set_req(1,incr);
<span class="line-modified"> 777   cmp-&gt;set_req(2,limit);</span>
 778   cmp = _igvn.register_new_node_with_optimizer(cmp);
 779   set_ctrl(cmp, iff-&gt;in(0));
 780 
 781   test = test-&gt;clone()-&gt;as_Bool();
 782   (*(BoolTest*)&amp;test-&gt;_test)._test = bt;
 783   test-&gt;set_req(1,cmp);
 784   _igvn.register_new_node_with_optimizer(test);
 785   set_ctrl(test, iff-&gt;in(0));
 786 
 787   // Replace the old IfNode with a new LoopEndNode
 788   Node *lex = _igvn.register_new_node_with_optimizer(new CountedLoopEndNode( iff-&gt;in(0), test, cl_prob, iff-&gt;as_If()-&gt;_fcnt ));
 789   IfNode *le = lex-&gt;as_If();
 790   uint dd = dom_depth(iff);
 791   set_idom(le, le-&gt;in(0), dd); // Update dominance for loop exit
 792   set_loop(le, loop);
 793 
 794   // Get the loop-exit control
 795   Node *iffalse = iff-&gt;as_If()-&gt;proj_out(!(iftrue_op == Op_IfTrue));
 796 
 797   // Need to swap loop-exit and loop-back control?
</pre>
<hr />
<pre>
 840   // The following assert is approximately true, and defines the intention
 841   // of can_be_counted_loop.  It fails, however, because phase-&gt;type
 842   // is not yet initialized for this loop and its parts.
 843   //assert(l-&gt;can_be_counted_loop(this), &quot;sanity&quot;);
 844   _igvn.register_new_node_with_optimizer(l);
 845   set_loop(l, loop);
 846   loop-&gt;_head = l;
 847   // Fix all data nodes placed at the old loop head.
 848   // Uses the lazy-update mechanism of &#39;get_ctrl&#39;.
 849   lazy_replace( x, l );
 850   set_idom(l, entry_control, dom_depth(entry_control) + 1);
 851 
 852   if (LoopStripMiningIter == 0 || strip_mine_loop) {
 853     // Check for immediately preceding SafePoint and remove
 854     if (sfpt2-&gt;Opcode() == Op_SafePoint &amp;&amp; (LoopStripMiningIter != 0 || is_deleteable_safept(sfpt2))) {
 855       if (strip_mine_loop) {
 856         Node* outer_le = outer_ilt-&gt;_tail-&gt;in(0);
 857         Node* sfpt = sfpt2-&gt;clone();
 858         sfpt-&gt;set_req(0, iffalse);
 859         outer_le-&gt;set_req(0, sfpt);
<span class="line-modified"> 860         register_control(sfpt, outer_ilt, iffalse);</span>


 861         set_idom(outer_le, sfpt, dom_depth(sfpt));
 862       }
 863       lazy_replace( sfpt2, sfpt2-&gt;in(TypeFunc::Control));
 864       if (loop-&gt;_safepts != NULL) {
 865         loop-&gt;_safepts-&gt;yank(sfpt2);
 866       }
 867     }
 868   }
 869 
 870   // Free up intermediate goo
 871   _igvn.remove_dead_node(hook);
 872 
 873 #ifdef ASSERT
 874   assert(l-&gt;is_valid_counted_loop(), &quot;counted loop shape is messed up&quot;);
 875   assert(l == loop-&gt;_head &amp;&amp; l-&gt;phi() == phi &amp;&amp; l-&gt;loopexit_or_null() == lex, &quot;&quot; );
 876 #endif
 877 #ifndef PRODUCT
 878   if (TraceLoopOpts) {
 879     tty-&gt;print(&quot;Counted      &quot;);
 880     loop-&gt;dump_head();
</pre>
<hr />
<pre>
1576             }
1577 #endif
1578           }
1579         }
1580       }
1581     }
1582   }
1583 
1584   if (iv_phi != NULL) {
1585     // Now adjust the inner loop&#39;s exit condition
1586     Node* limit = inner_cl-&gt;limit();
1587     Node* sub = NULL;
1588     if (stride &gt; 0) {
1589       sub = igvn-&gt;transform(new SubINode(limit, iv_phi));
1590     } else {
1591       sub = igvn-&gt;transform(new SubINode(iv_phi, limit));
1592     }
1593     // sub is positive and can be larger than the max signed int
1594     // value. Use an unsigned min.
1595     Node* const_iters = igvn-&gt;intcon(scaled_iters);
<span class="line-modified">1596     Node* cmp = igvn-&gt;transform(new CmpUNode(sub, const_iters));</span>
<span class="line-removed">1597     Node* bol = igvn-&gt;transform(new BoolNode(cmp, BoolTest::lt));</span>
<span class="line-removed">1598     Node* min = igvn-&gt;transform(new CMoveINode(bol, const_iters, sub, TypeInt::make(0, scaled_iters, Type::WidenMin)));</span>
1599 
1600     Node* new_limit = NULL;
1601     if (stride &gt; 0) {
1602       new_limit = igvn-&gt;transform(new AddINode(min, iv_phi));
1603     } else {
1604       new_limit = igvn-&gt;transform(new SubINode(iv_phi, min));
1605     }
1606     Node* inner_cmp = inner_cle-&gt;cmp_node();
1607     Node* inner_bol = inner_cle-&gt;in(CountedLoopEndNode::TestValue);
1608     Node* outer_bol = inner_bol;
1609     // cmp node for inner loop may be shared
1610     inner_cmp = inner_cmp-&gt;clone();
1611     inner_cmp-&gt;set_req(2, new_limit);
1612     inner_bol = inner_bol-&gt;clone();
1613     inner_bol-&gt;set_req(1, igvn-&gt;transform(inner_cmp));
1614     igvn-&gt;replace_input_of(inner_cle, CountedLoopEndNode::TestValue, igvn-&gt;transform(inner_bol));
1615     // Set the outer loop&#39;s exit condition too
1616     igvn-&gt;replace_input_of(outer_loop_end(), 1, outer_bol);
1617   } else {
1618     assert(false, &quot;should be able to adjust outer loop&quot;);
</pre>
</td>
<td>
<hr />
<pre>
 246   set_ctrl(n, early);
 247 }
 248 
 249 //------------------------------set_subtree_ctrl-------------------------------
 250 // set missing _ctrl entries on new nodes
 251 void PhaseIdealLoop::set_subtree_ctrl( Node *n ) {
 252   // Already set?  Get out.
 253   if( _nodes[n-&gt;_idx] ) return;
 254   // Recursively set _nodes array to indicate where the Node goes
 255   uint i;
 256   for( i = 0; i &lt; n-&gt;req(); ++i ) {
 257     Node *m = n-&gt;in(i);
 258     if( m &amp;&amp; m != C-&gt;root() )
 259       set_subtree_ctrl( m );
 260   }
 261 
 262   // Fixup self
 263   set_early_ctrl( n );
 264 }
 265 
<span class="line-added"> 266 IdealLoopTree* PhaseIdealLoop::insert_outer_loop(IdealLoopTree* loop, LoopNode* outer_l, Node* outer_ift) {</span>
<span class="line-added"> 267   IdealLoopTree* outer_ilt = new IdealLoopTree(this, outer_l, outer_ift);</span>
<span class="line-added"> 268   IdealLoopTree* parent = loop-&gt;_parent;</span>
<span class="line-added"> 269   IdealLoopTree* sibling = parent-&gt;_child;</span>
<span class="line-added"> 270   if (sibling == loop) {</span>
<span class="line-added"> 271     parent-&gt;_child = outer_ilt;</span>
<span class="line-added"> 272   } else {</span>
<span class="line-added"> 273     while (sibling-&gt;_next != loop) {</span>
<span class="line-added"> 274       sibling = sibling-&gt;_next;</span>
<span class="line-added"> 275     }</span>
<span class="line-added"> 276     sibling-&gt;_next = outer_ilt;</span>
<span class="line-added"> 277   }</span>
<span class="line-added"> 278   outer_ilt-&gt;_next = loop-&gt;_next;</span>
<span class="line-added"> 279   outer_ilt-&gt;_parent = parent;</span>
<span class="line-added"> 280   outer_ilt-&gt;_child = loop;</span>
<span class="line-added"> 281   outer_ilt-&gt;_nest = loop-&gt;_nest;</span>
<span class="line-added"> 282   loop-&gt;_parent = outer_ilt;</span>
<span class="line-added"> 283   loop-&gt;_next = NULL;</span>
<span class="line-added"> 284   loop-&gt;_nest++;</span>
<span class="line-added"> 285   return outer_ilt;</span>
<span class="line-added"> 286 }</span>
<span class="line-added"> 287 </span>
 288 // Create a skeleton strip mined outer loop: a Loop head before the
 289 // inner strip mined loop, a safepoint and an exit condition guarded
 290 // by an opaque node after the inner strip mined loop with a backedge
 291 // to the loop head. The inner strip mined loop is left as it is. Only
 292 // once loop optimizations are over, do we adjust the inner loop exit
 293 // condition to limit its number of iterations, set the outer loop
 294 // exit condition and add Phis to the outer loop head. Some loop
 295 // optimizations that operate on the inner strip mined loop need to be
 296 // aware of the outer strip mined loop: loop unswitching needs to
 297 // clone the outer loop as well as the inner, unrolling needs to only
 298 // clone the inner loop etc. No optimizations need to change the outer
 299 // strip mined loop as it is only a skeleton.
 300 IdealLoopTree* PhaseIdealLoop::create_outer_strip_mined_loop(BoolNode *test, Node *cmp, Node *init_control,
 301                                                              IdealLoopTree* loop, float cl_prob, float le_fcnt,
 302                                                              Node*&amp; entry_control, Node*&amp; iffalse) {
 303   Node* outer_test = _igvn.intcon(0);
 304   set_ctrl(outer_test, C-&gt;root());
 305   Node *orig = iffalse;
 306   iffalse = iffalse-&gt;clone();
 307   _igvn.register_new_node_with_optimizer(iffalse);
 308   set_idom(iffalse, idom(orig), dom_depth(orig));
 309 
 310   IfNode *outer_le = new OuterStripMinedLoopEndNode(iffalse, outer_test, cl_prob, le_fcnt);
 311   Node *outer_ift = new IfTrueNode (outer_le);
 312   Node* outer_iff = orig;
 313   _igvn.replace_input_of(outer_iff, 0, outer_le);
 314 
 315   LoopNode *outer_l = new OuterStripMinedLoopNode(C, init_control, outer_ift);
 316   entry_control = outer_l;
 317 
<span class="line-modified"> 318   IdealLoopTree* outer_ilt = insert_outer_loop(loop, outer_l, outer_ift);</span>

















 319 
 320   set_loop(iffalse, outer_ilt);
<span class="line-modified"> 321   // When this code runs, loop bodies have not yet been populated.</span>
<span class="line-modified"> 322   const bool body_populated = false;</span>
<span class="line-added"> 323   register_control(outer_le, outer_ilt, iffalse, body_populated);</span>
<span class="line-added"> 324   register_control(outer_ift, outer_ilt, outer_le, body_populated);</span>
 325   set_idom(outer_iff, outer_le, dom_depth(outer_le));
 326   _igvn.register_new_node_with_optimizer(outer_l);
 327   set_loop(outer_l, outer_ilt);
 328   set_idom(outer_l, init_control, dom_depth(init_control)+1);
 329 
 330   return outer_ilt;
 331 }
 332 
 333 void PhaseIdealLoop::insert_loop_limit_check(ProjNode* limit_check_proj, Node* cmp_limit, Node* bol) {
 334   Node* new_predicate_proj = create_new_if_for_predicate(limit_check_proj, NULL,
 335                                                          Deoptimization::Reason_loop_limit_check,
 336                                                          Op_If);
 337   Node* iff = new_predicate_proj-&gt;in(0);
 338   assert(iff-&gt;Opcode() == Op_If, &quot;bad graph shape&quot;);
 339   Node* conv = iff-&gt;in(1);
 340   assert(conv-&gt;Opcode() == Op_Conv2B, &quot;bad graph shape&quot;);
 341   Node* opaq = conv-&gt;in(1);
 342   assert(opaq-&gt;Opcode() == Op_Opaque1, &quot;bad graph shape&quot;);
 343   cmp_limit = _igvn.register_new_node_with_optimizer(cmp_limit);
 344   bol = _igvn.register_new_node_with_optimizer(bol);
 345   set_subtree_ctrl(bol);
 346   _igvn.replace_input_of(iff, 1, bol);
 347 
 348 #ifndef PRODUCT
 349   // report that the loop predication has been actually performed
 350   // for this loop
 351   if (TraceLoopLimitCheck) {
 352     tty-&gt;print_cr(&quot;Counted Loop Limit Check generated:&quot;);
 353     debug_only( bol-&gt;dump(2); )
 354   }
 355 #endif
 356 }
 357 
<span class="line-modified"> 358 Node* PhaseIdealLoop::loop_exit_control(Node* x, IdealLoopTree* loop) {</span>



 359   // Counted loop head must be a good RegionNode with only 3 not NULL
 360   // control input edges: Self, Entry, LoopBack.
 361   if (x-&gt;in(LoopNode::Self) == NULL || x-&gt;req() != 3 || loop-&gt;_irreducible) {
<span class="line-modified"> 362     return NULL;</span>
 363   }
 364   Node *init_control = x-&gt;in(LoopNode::EntryControl);
 365   Node *back_control = x-&gt;in(LoopNode::LoopBackControl);
<span class="line-modified"> 366   if (init_control == NULL || back_control == NULL) {   // Partially dead</span>
<span class="line-modified"> 367     return NULL;</span>
<span class="line-added"> 368   }</span>
 369   // Must also check for TOP when looking for a dead loop
<span class="line-modified"> 370   if (init_control-&gt;is_top() || back_control-&gt;is_top()) {</span>
<span class="line-modified"> 371     return NULL;</span>
<span class="line-added"> 372   }</span>
 373 
 374   // Allow funny placement of Safepoint
 375   if (back_control-&gt;Opcode() == Op_SafePoint) {







 376     back_control = back_control-&gt;in(TypeFunc::Control);
 377   }
 378 
 379   // Controlling test for loop
 380   Node *iftrue = back_control;
 381   uint iftrue_op = iftrue-&gt;Opcode();
 382   if (iftrue_op != Op_IfTrue &amp;&amp;
<span class="line-modified"> 383       iftrue_op != Op_IfFalse) {</span>
 384     // I have a weird back-control.  Probably the loop-exit test is in
 385     // the middle of the loop and I am looking at some trailing control-flow
 386     // merge point.  To fix this I would have to partially peel the loop.
<span class="line-modified"> 387     return NULL; // Obscure back-control</span>
<span class="line-added"> 388   }</span>
 389 
 390   // Get boolean guarding loop-back test
 391   Node *iff = iftrue-&gt;in(0);
<span class="line-modified"> 392   if (get_loop(iff) != loop || !iff-&gt;in(1)-&gt;is_Bool()) {</span>
<span class="line-modified"> 393     return NULL;</span>
<span class="line-modified"> 394   }</span>
<span class="line-modified"> 395   return iftrue;</span>
<span class="line-modified"> 396 }</span>
<span class="line-added"> 397 </span>
<span class="line-added"> 398 Node* PhaseIdealLoop::loop_exit_test(Node* back_control, IdealLoopTree* loop, Node*&amp; incr, Node*&amp; limit, BoolTest::mask&amp; bt, float&amp; cl_prob) {</span>
<span class="line-added"> 399   Node* iftrue = back_control;</span>
<span class="line-added"> 400   uint iftrue_op = iftrue-&gt;Opcode();</span>
<span class="line-added"> 401   Node* iff = iftrue-&gt;in(0);</span>
<span class="line-added"> 402   BoolNode* test = iff-&gt;in(1)-&gt;as_Bool();</span>
<span class="line-added"> 403   bt = test-&gt;_test._test;</span>
<span class="line-added"> 404   cl_prob = iff-&gt;as_If()-&gt;_prob;</span>
 405   if (iftrue_op == Op_IfFalse) {
 406     bt = BoolTest(bt).negate();
 407     cl_prob = 1.0 - cl_prob;
 408   }
 409   // Get backedge compare
<span class="line-modified"> 410   Node* cmp = test-&gt;in(1);</span>
<span class="line-modified"> 411   if (!cmp-&gt;is_Cmp()) {</span>
<span class="line-modified"> 412     return NULL;</span>
<span class="line-modified"> 413   }</span>
 414 
 415   // Find the trip-counter increment &amp; limit.  Limit must be loop invariant.
<span class="line-modified"> 416   incr  = cmp-&gt;in(1);</span>
<span class="line-modified"> 417   limit = cmp-&gt;in(2);</span>
 418 
 419   // ---------
 420   // need &#39;loop()&#39; test to tell if limit is loop invariant
 421   // ---------
 422 
 423   if (!is_member(loop, get_ctrl(incr))) { // Swapped trip counter and limit?
<span class="line-modified"> 424     Node* tmp = incr;            // Then reverse order into the CmpI</span>
 425     incr = limit;
 426     limit = tmp;
 427     bt = BoolTest(bt).commute(); // And commute the exit test
 428   }
<span class="line-modified"> 429   if (is_member(loop, get_ctrl(limit))) { // Limit must be loop-invariant</span>
<span class="line-modified"> 430     return NULL;</span>
<span class="line-modified"> 431   }</span>
<span class="line-added"> 432   if (!is_member(loop, get_ctrl(incr))) { // Trip counter must be loop-variant</span>
<span class="line-added"> 433     return NULL;</span>
<span class="line-added"> 434   }</span>
<span class="line-added"> 435   return cmp;</span>
<span class="line-added"> 436 }</span>
<span class="line-added"> 437 </span>
<span class="line-added"> 438 Node* PhaseIdealLoop::loop_iv_incr(Node* incr, Node* x, IdealLoopTree* loop, Node*&amp; phi_incr) {</span>
<span class="line-added"> 439   if (incr-&gt;is_Phi()) {</span>
<span class="line-added"> 440     if (incr-&gt;as_Phi()-&gt;region() != x || incr-&gt;req() != 3) {</span>
<span class="line-added"> 441       return NULL; // Not simple trip counter expression</span>
<span class="line-added"> 442     }</span>
<span class="line-added"> 443     phi_incr = incr;</span>
<span class="line-added"> 444     incr = phi_incr-&gt;in(LoopNode::LoopBackControl); // Assume incr is on backedge of Phi</span>
<span class="line-added"> 445     if (!is_member(loop, get_ctrl(incr))) { // Trip counter must be loop-variant</span>
<span class="line-added"> 446       return NULL;</span>
<span class="line-added"> 447     }</span>
<span class="line-added"> 448   }</span>
<span class="line-added"> 449   return incr;</span>
<span class="line-added"> 450 }</span>
<span class="line-added"> 451 </span>
<span class="line-added"> 452 Node* PhaseIdealLoop::loop_iv_stride(Node* incr, IdealLoopTree* loop, Node*&amp; xphi) {</span>
<span class="line-added"> 453   assert(incr-&gt;Opcode() == Op_AddI || incr-&gt;Opcode() == Op_AddL, &quot;caller resp.&quot;);</span>
<span class="line-added"> 454   // Get merge point</span>
<span class="line-added"> 455   xphi = incr-&gt;in(1);</span>
<span class="line-added"> 456   Node *stride = incr-&gt;in(2);</span>
<span class="line-added"> 457   if (!stride-&gt;is_Con()) {     // Oops, swap these</span>
<span class="line-added"> 458     if (!xphi-&gt;is_Con()) {     // Is the other guy a constant?</span>
<span class="line-added"> 459       return NULL;             // Nope, unknown stride, bail out</span>
<span class="line-added"> 460     }</span>
<span class="line-added"> 461     Node *tmp = xphi;          // &#39;incr&#39; is commutative, so ok to swap</span>
<span class="line-added"> 462     xphi = stride;</span>
<span class="line-added"> 463     stride = tmp;</span>
<span class="line-added"> 464   }</span>
<span class="line-added"> 465   return stride;</span>
<span class="line-added"> 466 }</span>
<span class="line-added"> 467 </span>
<span class="line-added"> 468 PhiNode* PhaseIdealLoop::loop_iv_phi(Node* xphi, Node* phi_incr, Node* x, IdealLoopTree* loop) {</span>
<span class="line-added"> 469   if (!xphi-&gt;is_Phi()) {</span>
<span class="line-added"> 470     return NULL; // Too much math on the trip counter</span>
<span class="line-added"> 471   }</span>
<span class="line-added"> 472   if (phi_incr != NULL &amp;&amp; phi_incr != xphi) {</span>
<span class="line-added"> 473     return NULL;</span>
<span class="line-added"> 474   }</span>
<span class="line-added"> 475   PhiNode *phi = xphi-&gt;as_Phi();</span>
<span class="line-added"> 476 </span>
<span class="line-added"> 477   // Phi must be of loop header; backedge must wrap to increment</span>
<span class="line-added"> 478   if (phi-&gt;region() != x) {</span>
<span class="line-added"> 479     return NULL;</span>
<span class="line-added"> 480   }</span>
<span class="line-added"> 481   return phi;</span>
<span class="line-added"> 482 }</span>
<span class="line-added"> 483 </span>
<span class="line-added"> 484 // Return 0 if it won&#39;t overflow, -1 if it must overflow, and 1 otherwise.</span>
<span class="line-added"> 485 static int check_stride_overflow(jint stride_con, const TypeInt* limit_t) {</span>
<span class="line-added"> 486   if (stride_con &gt; 0) {</span>
<span class="line-added"> 487     if (limit_t-&gt;_lo &gt; (max_jint - stride_con)) {</span>
<span class="line-added"> 488       return -1;</span>
<span class="line-added"> 489     }</span>
<span class="line-added"> 490     if (limit_t-&gt;_hi &gt; (max_jint - stride_con)) {</span>
<span class="line-added"> 491       return 1;</span>
<span class="line-added"> 492     }</span>
<span class="line-added"> 493   } else {</span>
<span class="line-added"> 494     if (limit_t-&gt;_hi &lt; (min_jint - stride_con)) {</span>
<span class="line-added"> 495       return -1;</span>
<span class="line-added"> 496     }</span>
<span class="line-added"> 497     if (limit_t-&gt;_lo &lt; (min_jint - stride_con)) {</span>
<span class="line-added"> 498       return 1;</span>
<span class="line-added"> 499     }</span>
<span class="line-added"> 500   }</span>
<span class="line-added"> 501   return 0;</span>
<span class="line-added"> 502 }</span>
<span class="line-added"> 503 </span>
<span class="line-added"> 504 //------------------------------is_counted_loop--------------------------------</span>
<span class="line-added"> 505 bool PhaseIdealLoop::is_counted_loop(Node* x, IdealLoopTree*&amp; loop) {</span>
<span class="line-added"> 506   PhaseGVN *gvn = &amp;_igvn;</span>
<span class="line-added"> 507 </span>
<span class="line-added"> 508   Node* back_control = loop_exit_control(x, loop);</span>
<span class="line-added"> 509   if (back_control == NULL) {</span>
 510     return false;
<span class="line-added"> 511   }</span>
<span class="line-added"> 512 </span>
<span class="line-added"> 513   BoolTest::mask bt = BoolTest::illegal;</span>
<span class="line-added"> 514   float cl_prob = 0;</span>
<span class="line-added"> 515   Node* incr = NULL;</span>
<span class="line-added"> 516   Node* limit = NULL;</span>
<span class="line-added"> 517 </span>
<span class="line-added"> 518   Node* cmp = loop_exit_test(back_control, loop, incr, limit, bt, cl_prob);</span>
<span class="line-added"> 519   if (cmp == NULL || cmp-&gt;Opcode() != Op_CmpI) {</span>
<span class="line-added"> 520     return false; // Avoid pointer &amp; float &amp; 64-bit compares</span>
<span class="line-added"> 521   }</span>
 522 

 523   // Trip-counter increment must be commutative &amp; associative.
 524   if (incr-&gt;Opcode() == Op_CastII) {
 525     incr = incr-&gt;in(1);
 526   }
<span class="line-modified"> 527 </span>
<span class="line-modified"> 528   Node* phi_incr = NULL;</span>
<span class="line-modified"> 529   incr = loop_iv_incr(incr, x, loop, phi_incr);</span>
<span class="line-modified"> 530   if (incr == NULL) {</span>
<span class="line-modified"> 531     return false;</span>


 532   }
 533 
 534   Node* trunc1 = NULL;
 535   Node* trunc2 = NULL;
 536   const TypeInt* iv_trunc_t = NULL;
 537   Node* orig_incr = incr;
 538   if (!(incr = CountedLoopNode::match_incr_with_optional_truncation(incr, &amp;trunc1, &amp;trunc2, &amp;iv_trunc_t))) {
 539     return false; // Funny increment opcode
 540   }
 541   assert(incr-&gt;Opcode() == Op_AddI, &quot;wrong increment code&quot;);
 542 
<span class="line-added"> 543   Node* xphi = NULL;</span>
<span class="line-added"> 544   Node* stride = loop_iv_stride(incr, loop, xphi);</span>
<span class="line-added"> 545 </span>
<span class="line-added"> 546   if (stride == NULL) {</span>
<span class="line-added"> 547     return false;</span>
<span class="line-added"> 548   }</span>
<span class="line-added"> 549 </span>
<span class="line-added"> 550   if (xphi-&gt;Opcode() == Op_CastII) {</span>
<span class="line-added"> 551     xphi = xphi-&gt;in(1);</span>
<span class="line-added"> 552   }</span>
<span class="line-added"> 553 </span>
<span class="line-added"> 554   // Stride must be constant</span>
<span class="line-added"> 555   int stride_con = stride-&gt;get_int();</span>
<span class="line-added"> 556   assert(stride_con != 0, &quot;missed some peephole opt&quot;);</span>
<span class="line-added"> 557 </span>
<span class="line-added"> 558   PhiNode* phi = loop_iv_phi(xphi, phi_incr, x, loop);</span>
<span class="line-added"> 559 </span>
<span class="line-added"> 560   if (phi == NULL ||</span>
<span class="line-added"> 561       (trunc1 == NULL &amp;&amp; phi-&gt;in(LoopNode::LoopBackControl) != incr) ||</span>
<span class="line-added"> 562       (trunc1 != NULL &amp;&amp; phi-&gt;in(LoopNode::LoopBackControl) != trunc1)) {</span>
<span class="line-added"> 563     return false;</span>
<span class="line-added"> 564   }</span>
<span class="line-added"> 565 </span>
<span class="line-added"> 566   if (x-&gt;in(LoopNode::LoopBackControl)-&gt;Opcode() == Op_SafePoint &amp;&amp;</span>
<span class="line-added"> 567       LoopStripMiningIter != 0) {</span>
<span class="line-added"> 568     // Leaving the safepoint on the backedge and creating a</span>
<span class="line-added"> 569     // CountedLoop will confuse optimizations. We can&#39;t move the</span>
<span class="line-added"> 570     // safepoint around because its jvm state wouldn&#39;t match a new</span>
<span class="line-added"> 571     // location. Give up on that loop.</span>
<span class="line-added"> 572     return false;</span>
<span class="line-added"> 573   }</span>
<span class="line-added"> 574 </span>
<span class="line-added"> 575   Node* iftrue = back_control;</span>
<span class="line-added"> 576   uint iftrue_op = iftrue-&gt;Opcode();</span>
<span class="line-added"> 577   Node* iff = iftrue-&gt;in(0);</span>
<span class="line-added"> 578   BoolNode* test = iff-&gt;in(1)-&gt;as_Bool();</span>
<span class="line-added"> 579 </span>
 580   const TypeInt* limit_t = gvn-&gt;type(limit)-&gt;is_int();
 581   if (trunc1 != NULL) {
 582     // When there is a truncation, we must be sure that after the truncation
 583     // the trip counter will end up higher than the limit, otherwise we are looking
 584     // at an endless loop. Can happen with range checks.
 585 
 586     // Example:
 587     // int i = 0;
 588     // while (true)
 589     //    sum + = array[i];
 590     //    i++;
 591     //    i = i &amp;&amp; 0x7fff;
 592     //  }
 593     //
 594     // If the array is shorter than 0x8000 this exits through a AIOOB
 595     //  - Counted loop transformation is ok
 596     // If the array is longer then this is an endless loop
 597     //  - No transformation can be done.
 598 
 599     const TypeInt* incr_t = gvn-&gt;type(orig_incr)-&gt;is_int();
 600     if (limit_t-&gt;_hi &gt; incr_t-&gt;_hi) {
 601       // if the limit can have a higher value than the increment (before the phi)
 602       return false;
 603     }
 604   }
 605 































 606   Node *init_trip = phi-&gt;in(LoopNode::EntryControl);
 607 
 608   // If iv trunc type is smaller than int, check for possible wrap.
 609   if (!TypeInt::INT-&gt;higher_equal(iv_trunc_t)) {
 610     assert(trunc1 != NULL, &quot;must have found some truncation&quot;);
 611 
 612     // Get a better type for the phi (filtered thru if&#39;s)
 613     const TypeInt* phi_ft = filtered_type(phi);
 614 
 615     // Can iv take on a value that will wrap?
 616     //
 617     // Ensure iv&#39;s limit is not within &quot;stride&quot; of the wrap value.
 618     //
 619     // Example for &quot;short&quot; type
 620     //    Truncation ensures value is in the range -32768..32767 (iv_trunc_t)
 621     //    If the stride is +10, then the last value of the induction
 622     //    variable before the increment (phi_ft-&gt;_hi) must be
 623     //    &lt;= 32767 - 10 and (phi_ft-&gt;_lo) must be &gt;= -32768 to
 624     //    ensure no truncation occurs after the increment.
 625 
</pre>
<hr />
<pre>
 691   //
 692   // for (i=0; i &lt;= max_jint; i++) {}
 693   // for (i=0; i &lt;  max_jint; i+=2) {}
 694   //
 695   //
 696   // Limit check predicate depends on the loop test:
 697   //
 698   // for(;i != limit; i++)       --&gt; limit &lt;= (max_jint)
 699   // for(;i &lt;  limit; i+=stride) --&gt; limit &lt;= (max_jint - stride + 1)
 700   // for(;i &lt;= limit; i+=stride) --&gt; limit &lt;= (max_jint - stride    )
 701   //
 702 
 703   // Check if limit is excluded to do more precise int overflow check.
 704   bool incl_limit = (bt == BoolTest::le || bt == BoolTest::ge);
 705   int stride_m  = stride_con - (incl_limit ? 0 : (stride_con &gt; 0 ? 1 : -1));
 706 
 707   // If compare points directly to the phi we need to adjust
 708   // the compare so that it points to the incr. Limit have
 709   // to be adjusted to keep trip count the same and the
 710   // adjusted limit should be checked for int overflow.
<span class="line-added"> 711   Node* adjusted_limit = limit;</span>
 712   if (phi_incr != NULL) {
 713     stride_m  += stride_con;
 714   }
 715 
<span class="line-modified"> 716   Node *init_control = x-&gt;in(LoopNode::EntryControl);</span>
<span class="line-modified"> 717 </span>
<span class="line-modified"> 718   int sov = check_stride_overflow(stride_m, limit_t);</span>
<span class="line-modified"> 719   // If sov==0, limit&#39;s type always satisfies the condition, for</span>
<span class="line-modified"> 720   // example, when it is an array length.</span>
<span class="line-modified"> 721   if (sov != 0) {</span>
<span class="line-added"> 722     if (sov &lt; 0) {</span>
<span class="line-added"> 723       return false;  // Bailout: integer overflow is certain.</span>
 724     }





 725     // Generate loop&#39;s limit check.
 726     // Loop limit check predicate should be near the loop.
 727     ProjNode *limit_check_proj = find_predicate_insertion_point(init_control, Deoptimization::Reason_loop_limit_check);
 728     if (!limit_check_proj) {
 729       // The limit check predicate is not generated if this method trapped here before.
 730 #ifdef ASSERT
 731       if (TraceLoopLimitCheck) {
 732         tty-&gt;print(&quot;missing loop limit check:&quot;);
 733         loop-&gt;dump_head();
 734         x-&gt;dump(1);
 735       }
 736 #endif
 737       return false;
 738     }
 739 
 740     IfNode* check_iff = limit_check_proj-&gt;in(0)-&gt;as_If();
 741 
 742     if (!is_dominator(get_ctrl(limit), check_iff-&gt;in(0))) {
 743       return false;
 744     }
</pre>
<hr />
<pre>
 802       if (stride_con &gt; 0) {
 803         // &#39;ne&#39; can be replaced with &#39;lt&#39; only when init &lt; limit.
 804         bt = BoolTest::lt;
 805       } else if (stride_con &lt; 0) {
 806         // &#39;ne&#39; can be replaced with &#39;gt&#39; only when init &gt; limit.
 807         bt = BoolTest::gt;
 808       }
 809     }
 810   }
 811 
 812   if (phi_incr != NULL) {
 813     // If compare points directly to the phi we need to adjust
 814     // the compare so that it points to the incr. Limit have
 815     // to be adjusted to keep trip count the same and we
 816     // should avoid int overflow.
 817     //
 818     //   i = init; do {} while(i++ &lt; limit);
 819     // is converted to
 820     //   i = init; do {} while(++i &lt; limit+1);
 821     //
<span class="line-modified"> 822     adjusted_limit = gvn-&gt;transform(new AddINode(limit, stride));</span>
 823   }
 824 
 825   if (incl_limit) {
 826     // The limit check guaranties that &#39;limit &lt;= (max_jint - stride)&#39; so
 827     // we can convert &#39;i &lt;= limit&#39; to &#39;i &lt; limit+1&#39; since stride != 0.
 828     //
 829     Node* one = (stride_con &gt; 0) ? gvn-&gt;intcon( 1) : gvn-&gt;intcon(-1);
<span class="line-modified"> 830     adjusted_limit = gvn-&gt;transform(new AddINode(adjusted_limit, one));</span>
 831     if (bt == BoolTest::le)
 832       bt = BoolTest::lt;
 833     else if (bt == BoolTest::ge)
 834       bt = BoolTest::gt;
 835     else
 836       ShouldNotReachHere();
 837   }
<span class="line-modified"> 838   set_subtree_ctrl(adjusted_limit);</span>
 839 
 840   if (LoopStripMiningIter == 0) {
 841     // Check for SafePoint on backedge and remove
 842     Node *sfpt = x-&gt;in(LoopNode::LoopBackControl);
 843     if (sfpt-&gt;Opcode() == Op_SafePoint &amp;&amp; is_deleteable_safept(sfpt)) {
 844       lazy_replace( sfpt, iftrue );
 845       if (loop-&gt;_safepts != NULL) {
 846         loop-&gt;_safepts-&gt;yank(sfpt);
 847       }
 848       loop-&gt;_tail = iftrue;
 849     }
 850   }
 851 
 852   // Build a canonical trip test.
 853   // Clone code, as old values may be in use.
 854   incr = incr-&gt;clone();
 855   incr-&gt;set_req(1,phi);
 856   incr-&gt;set_req(2,stride);
 857   incr = _igvn.register_new_node_with_optimizer(incr);
 858   set_early_ctrl( incr );
 859   _igvn.rehash_node_delayed(phi);
 860   phi-&gt;set_req_X( LoopNode::LoopBackControl, incr, &amp;_igvn );
 861 
 862   // If phi type is more restrictive than Int, raise to
 863   // Int to prevent (almost) infinite recursion in igvn
 864   // which can only handle integer types for constants or minint..maxint.
 865   if (!TypeInt::INT-&gt;higher_equal(phi-&gt;bottom_type())) {
 866     Node* nphi = PhiNode::make(phi-&gt;in(0), phi-&gt;in(LoopNode::EntryControl), TypeInt::INT);
 867     nphi-&gt;set_req(LoopNode::LoopBackControl, phi-&gt;in(LoopNode::LoopBackControl));
 868     nphi = _igvn.register_new_node_with_optimizer(nphi);
 869     set_ctrl(nphi, get_ctrl(phi));
 870     _igvn.replace_node(phi, nphi);
 871     phi = nphi-&gt;as_Phi();
 872   }
 873   cmp = cmp-&gt;clone();
 874   cmp-&gt;set_req(1,incr);
<span class="line-modified"> 875   cmp-&gt;set_req(2, adjusted_limit);</span>
 876   cmp = _igvn.register_new_node_with_optimizer(cmp);
 877   set_ctrl(cmp, iff-&gt;in(0));
 878 
 879   test = test-&gt;clone()-&gt;as_Bool();
 880   (*(BoolTest*)&amp;test-&gt;_test)._test = bt;
 881   test-&gt;set_req(1,cmp);
 882   _igvn.register_new_node_with_optimizer(test);
 883   set_ctrl(test, iff-&gt;in(0));
 884 
 885   // Replace the old IfNode with a new LoopEndNode
 886   Node *lex = _igvn.register_new_node_with_optimizer(new CountedLoopEndNode( iff-&gt;in(0), test, cl_prob, iff-&gt;as_If()-&gt;_fcnt ));
 887   IfNode *le = lex-&gt;as_If();
 888   uint dd = dom_depth(iff);
 889   set_idom(le, le-&gt;in(0), dd); // Update dominance for loop exit
 890   set_loop(le, loop);
 891 
 892   // Get the loop-exit control
 893   Node *iffalse = iff-&gt;as_If()-&gt;proj_out(!(iftrue_op == Op_IfTrue));
 894 
 895   // Need to swap loop-exit and loop-back control?
</pre>
<hr />
<pre>
 938   // The following assert is approximately true, and defines the intention
 939   // of can_be_counted_loop.  It fails, however, because phase-&gt;type
 940   // is not yet initialized for this loop and its parts.
 941   //assert(l-&gt;can_be_counted_loop(this), &quot;sanity&quot;);
 942   _igvn.register_new_node_with_optimizer(l);
 943   set_loop(l, loop);
 944   loop-&gt;_head = l;
 945   // Fix all data nodes placed at the old loop head.
 946   // Uses the lazy-update mechanism of &#39;get_ctrl&#39;.
 947   lazy_replace( x, l );
 948   set_idom(l, entry_control, dom_depth(entry_control) + 1);
 949 
 950   if (LoopStripMiningIter == 0 || strip_mine_loop) {
 951     // Check for immediately preceding SafePoint and remove
 952     if (sfpt2-&gt;Opcode() == Op_SafePoint &amp;&amp; (LoopStripMiningIter != 0 || is_deleteable_safept(sfpt2))) {
 953       if (strip_mine_loop) {
 954         Node* outer_le = outer_ilt-&gt;_tail-&gt;in(0);
 955         Node* sfpt = sfpt2-&gt;clone();
 956         sfpt-&gt;set_req(0, iffalse);
 957         outer_le-&gt;set_req(0, sfpt);
<span class="line-modified"> 958         // When this code runs, loop bodies have not yet been populated.</span>
<span class="line-added"> 959         const bool body_populated = false;</span>
<span class="line-added"> 960         register_control(sfpt, outer_ilt, iffalse, body_populated);</span>
 961         set_idom(outer_le, sfpt, dom_depth(sfpt));
 962       }
 963       lazy_replace( sfpt2, sfpt2-&gt;in(TypeFunc::Control));
 964       if (loop-&gt;_safepts != NULL) {
 965         loop-&gt;_safepts-&gt;yank(sfpt2);
 966       }
 967     }
 968   }
 969 
 970   // Free up intermediate goo
 971   _igvn.remove_dead_node(hook);
 972 
 973 #ifdef ASSERT
 974   assert(l-&gt;is_valid_counted_loop(), &quot;counted loop shape is messed up&quot;);
 975   assert(l == loop-&gt;_head &amp;&amp; l-&gt;phi() == phi &amp;&amp; l-&gt;loopexit_or_null() == lex, &quot;&quot; );
 976 #endif
 977 #ifndef PRODUCT
 978   if (TraceLoopOpts) {
 979     tty-&gt;print(&quot;Counted      &quot;);
 980     loop-&gt;dump_head();
</pre>
<hr />
<pre>
1676             }
1677 #endif
1678           }
1679         }
1680       }
1681     }
1682   }
1683 
1684   if (iv_phi != NULL) {
1685     // Now adjust the inner loop&#39;s exit condition
1686     Node* limit = inner_cl-&gt;limit();
1687     Node* sub = NULL;
1688     if (stride &gt; 0) {
1689       sub = igvn-&gt;transform(new SubINode(limit, iv_phi));
1690     } else {
1691       sub = igvn-&gt;transform(new SubINode(iv_phi, limit));
1692     }
1693     // sub is positive and can be larger than the max signed int
1694     // value. Use an unsigned min.
1695     Node* const_iters = igvn-&gt;intcon(scaled_iters);
<span class="line-modified">1696     Node* min = MaxNode::unsigned_min(sub, const_iters, TypeInt::make(0, scaled_iters, Type::WidenMin), *igvn);</span>


1697 
1698     Node* new_limit = NULL;
1699     if (stride &gt; 0) {
1700       new_limit = igvn-&gt;transform(new AddINode(min, iv_phi));
1701     } else {
1702       new_limit = igvn-&gt;transform(new SubINode(iv_phi, min));
1703     }
1704     Node* inner_cmp = inner_cle-&gt;cmp_node();
1705     Node* inner_bol = inner_cle-&gt;in(CountedLoopEndNode::TestValue);
1706     Node* outer_bol = inner_bol;
1707     // cmp node for inner loop may be shared
1708     inner_cmp = inner_cmp-&gt;clone();
1709     inner_cmp-&gt;set_req(2, new_limit);
1710     inner_bol = inner_bol-&gt;clone();
1711     inner_bol-&gt;set_req(1, igvn-&gt;transform(inner_cmp));
1712     igvn-&gt;replace_input_of(inner_cle, CountedLoopEndNode::TestValue, igvn-&gt;transform(inner_bol));
1713     // Set the outer loop&#39;s exit condition too
1714     igvn-&gt;replace_input_of(outer_loop_end(), 1, outer_bol);
1715   } else {
1716     assert(false, &quot;should be able to adjust outer loop&quot;);
</pre>
</td>
</tr>
</table>
<center><a href="loopPredicate.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="loopnode.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
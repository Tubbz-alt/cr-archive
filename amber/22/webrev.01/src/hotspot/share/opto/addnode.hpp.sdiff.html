<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/addnode.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="addnode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c2_globals.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/addnode.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
200   virtual uint ideal_reg() const { return Op_RegI; }
201 };
202 
203 //------------------------------XorINode---------------------------------------
204 // XOR&#39;ing 2 longs
205 class XorLNode : public AddNode {
206 public:
207   XorLNode( Node *in1, Node *in2 ) : AddNode(in1,in2) {}
208   virtual int Opcode() const;
209   virtual const Type *add_ring( const Type *, const Type * ) const;
210   virtual const Type *add_id() const { return TypeLong::ZERO; }
211   virtual const Type *bottom_type() const { return TypeLong::LONG; }
212   virtual uint ideal_reg() const { return Op_RegL; }
213 };
214 
215 //------------------------------MaxNode----------------------------------------
216 // Max (or min) of 2 values.  Included with the ADD nodes because it inherits
217 // all the behavior of addition on a ring.  Only new thing is that we allow
218 // 2 equal inputs to be equal.
219 class MaxNode : public AddNode {




220 public:
221   MaxNode( Node *in1, Node *in2 ) : AddNode(in1,in2) {}
222   virtual int Opcode() const = 0;


























223 };
224 
225 //------------------------------MaxINode---------------------------------------
226 // Maximum of 2 integers.  Included with the ADD nodes because it inherits
227 // all the behavior of addition on a ring.
228 class MaxINode : public MaxNode {
229 public:
230   MaxINode( Node *in1, Node *in2 ) : MaxNode(in1,in2) {}
231   virtual int Opcode() const;
232   virtual const Type *add_ring( const Type *, const Type * ) const;
233   virtual const Type *add_id() const { return TypeInt::make(min_jint); }
234   virtual const Type *bottom_type() const { return TypeInt::INT; }
235   virtual uint ideal_reg() const { return Op_RegI; }
236 };
237 
238 //------------------------------MinINode---------------------------------------
239 // MINimum of 2 integers.  Included with the ADD nodes because it inherits
240 // all the behavior of addition on a ring.
241 class MinINode : public MaxNode {
242 public:
</pre>
</td>
<td>
<hr />
<pre>
200   virtual uint ideal_reg() const { return Op_RegI; }
201 };
202 
203 //------------------------------XorINode---------------------------------------
204 // XOR&#39;ing 2 longs
205 class XorLNode : public AddNode {
206 public:
207   XorLNode( Node *in1, Node *in2 ) : AddNode(in1,in2) {}
208   virtual int Opcode() const;
209   virtual const Type *add_ring( const Type *, const Type * ) const;
210   virtual const Type *add_id() const { return TypeLong::ZERO; }
211   virtual const Type *bottom_type() const { return TypeLong::LONG; }
212   virtual uint ideal_reg() const { return Op_RegL; }
213 };
214 
215 //------------------------------MaxNode----------------------------------------
216 // Max (or min) of 2 values.  Included with the ADD nodes because it inherits
217 // all the behavior of addition on a ring.  Only new thing is that we allow
218 // 2 equal inputs to be equal.
219 class MaxNode : public AddNode {
<span class="line-added">220 private:</span>
<span class="line-added">221   static Node* build_min_max(Node* a, Node* b, bool is_max, bool is_unsigned, const Type* t, PhaseGVN&amp; gvn);</span>
<span class="line-added">222   static Node* build_min_max_diff_with_zero(Node* a, Node* b, bool is_max, const Type* t, PhaseGVN&amp; gvn);</span>
<span class="line-added">223 </span>
224 public:
225   MaxNode( Node *in1, Node *in2 ) : AddNode(in1,in2) {}
226   virtual int Opcode() const = 0;
<span class="line-added">227 </span>
<span class="line-added">228   static Node* unsigned_max(Node* a, Node* b, const Type* t, PhaseGVN&amp; gvn) {</span>
<span class="line-added">229     return build_min_max(a, b, true, true, t, gvn);</span>
<span class="line-added">230   }</span>
<span class="line-added">231 </span>
<span class="line-added">232   static Node* unsigned_min(Node* a, Node* b, const Type* t, PhaseGVN&amp; gvn) {</span>
<span class="line-added">233     return build_min_max(a, b, false, true, t, gvn);</span>
<span class="line-added">234   }</span>
<span class="line-added">235 </span>
<span class="line-added">236   static Node* signed_max(Node* a, Node* b, const Type* t, PhaseGVN&amp; gvn) {</span>
<span class="line-added">237     return build_min_max(a, b, true, false, t, gvn);</span>
<span class="line-added">238   }</span>
<span class="line-added">239 </span>
<span class="line-added">240   static Node* signed_min(Node* a, Node* b, const Type* t, PhaseGVN&amp; gvn) {</span>
<span class="line-added">241     return build_min_max(a, b, false, false, t, gvn);</span>
<span class="line-added">242   }</span>
<span class="line-added">243 </span>
<span class="line-added">244   // max(a-b, 0)</span>
<span class="line-added">245   static Node* max_diff_with_zero(Node* a, Node* b, const Type* t, PhaseGVN&amp; gvn) {</span>
<span class="line-added">246     return build_min_max_diff_with_zero(a, b, true, t, gvn);</span>
<span class="line-added">247   }</span>
<span class="line-added">248 </span>
<span class="line-added">249   // min(a-b, 0)</span>
<span class="line-added">250   static Node* min_diff_with_zero(Node* a, Node* b, const Type* t, PhaseGVN&amp; gvn) {</span>
<span class="line-added">251     return build_min_max_diff_with_zero(a, b, false, t, gvn);</span>
<span class="line-added">252   }</span>
253 };
254 
255 //------------------------------MaxINode---------------------------------------
256 // Maximum of 2 integers.  Included with the ADD nodes because it inherits
257 // all the behavior of addition on a ring.
258 class MaxINode : public MaxNode {
259 public:
260   MaxINode( Node *in1, Node *in2 ) : MaxNode(in1,in2) {}
261   virtual int Opcode() const;
262   virtual const Type *add_ring( const Type *, const Type * ) const;
263   virtual const Type *add_id() const { return TypeInt::make(min_jint); }
264   virtual const Type *bottom_type() const { return TypeInt::INT; }
265   virtual uint ideal_reg() const { return Op_RegI; }
266 };
267 
268 //------------------------------MinINode---------------------------------------
269 // MINimum of 2 integers.  Included with the ADD nodes because it inherits
270 // all the behavior of addition on a ring.
271 class MinINode : public MaxNode {
272 public:
</pre>
</td>
</tr>
</table>
<center><a href="addnode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c2_globals.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
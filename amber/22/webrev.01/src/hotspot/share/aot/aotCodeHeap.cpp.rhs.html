<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/aot/aotCodeHeap.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 #include &quot;precompiled.hpp&quot;
  25 
  26 #include &quot;aot/aotCodeHeap.hpp&quot;
  27 #include &quot;aot/aotLoader.hpp&quot;
  28 #include &quot;ci/ciUtilities.inline.hpp&quot;
  29 #include &quot;classfile/javaAssertions.hpp&quot;
  30 #include &quot;gc/shared/cardTable.hpp&quot;
  31 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
  32 #include &quot;gc/shared/gcConfig.hpp&quot;
  33 #include &quot;gc/g1/heapRegion.hpp&quot;
  34 #include &quot;interpreter/abstractInterpreter.hpp&quot;
  35 #include &quot;jvmci/compilerRuntime.hpp&quot;
  36 #include &quot;jvmci/jvmciRuntime.hpp&quot;
  37 #include &quot;logging/log.hpp&quot;
  38 #include &quot;memory/allocation.inline.hpp&quot;
  39 #include &quot;memory/universe.hpp&quot;
  40 #include &quot;oops/compressedOops.hpp&quot;
  41 #include &quot;oops/klass.inline.hpp&quot;
  42 #include &quot;oops/method.inline.hpp&quot;
  43 #include &quot;runtime/atomic.hpp&quot;
  44 #include &quot;runtime/deoptimization.hpp&quot;
  45 #include &quot;runtime/handles.inline.hpp&quot;
  46 #include &quot;runtime/os.hpp&quot;
  47 #include &quot;runtime/safepointVerifiers.hpp&quot;
  48 #include &quot;runtime/sharedRuntime.hpp&quot;
  49 #include &quot;runtime/vmOperations.hpp&quot;
  50 #include &quot;utilities/powerOfTwo.hpp&quot;
  51 #include &quot;utilities/sizes.hpp&quot;
  52 
  53 bool AOTLib::_narrow_oop_shift_initialized = false;
  54 int  AOTLib::_narrow_oop_shift = 0;
  55 int  AOTLib::_narrow_klass_shift = 0;
  56 
  57 address AOTLib::load_symbol(const char *name) {
  58   address symbol = (address) os::dll_lookup(_dl_handle, name);
  59   if (symbol == NULL) {
  60     tty-&gt;print_cr(&quot;Shared file %s error: missing %s&quot;, _name, name);
  61     vm_exit(1);
  62   }
  63   return symbol;
  64 }
  65 
  66 Klass* AOTCodeHeap::get_klass_from_got(const char* klass_name, int klass_len, const Method* method) {
  67   AOTKlassData* klass_data = (AOTKlassData*)_lib-&gt;load_symbol(klass_name);
  68   Klass* k = (Klass*)_klasses_got[klass_data-&gt;_got_index];
  69   if (k == NULL) {
  70     Thread* thread = Thread::current();
  71     k = lookup_klass(klass_name, klass_len, method, thread);
  72     // Note, exceptions are cleared.
  73     if (k == NULL) {
  74       fatal(&quot;Shared file %s error: klass %s should be resolved already&quot;, _lib-&gt;name(), klass_name);
  75       vm_exit(1);
  76     }
  77     // Patch now to avoid extra runtime lookup
  78     _klasses_got[klass_data-&gt;_got_index] = k;
  79     if (k-&gt;is_instance_klass()) {
  80       InstanceKlass* ik = InstanceKlass::cast(k);
  81       if (ik-&gt;is_initialized()) {
  82         _klasses_got[klass_data-&gt;_got_index - 1] = ik;
  83       }
  84     }
  85   }
  86   return k;
  87 }
  88 
  89 Klass* AOTCodeHeap::lookup_klass(const char* name, int len, const Method* method, Thread* thread) {
  90   ResourceMark rm(thread);
  91   assert(method != NULL, &quot;incorrect call parameter&quot;);
  92   methodHandle caller(thread, (Method*)method);
  93 
  94   // Use class loader of aot method.
  95   Handle loader(thread, caller-&gt;method_holder()-&gt;class_loader());
  96   Handle protection_domain(thread, caller-&gt;method_holder()-&gt;protection_domain());
  97 
  98   // Ignore wrapping L and ;
  99   if (name[0] == JVM_SIGNATURE_CLASS) {
 100     assert(len &gt; 2, &quot;small name %s&quot;, name);
 101     name++;
 102     len -= 2;
 103   }
 104   TempNewSymbol sym = SymbolTable::probe(name, len);
 105   if (sym == NULL) {
 106     log_debug(aot, class, resolve)(&quot;Probe failed for AOT class %s&quot;, name);
 107     return NULL;
 108   }
 109   Klass* k = SystemDictionary::find_instance_or_array_klass(sym, loader, protection_domain, thread);
 110   assert(!thread-&gt;has_pending_exception(), &quot;should not throw&quot;);
 111 
 112   if (k != NULL) {
 113     log_info(aot, class, resolve)(&quot;%s %s (lookup)&quot;, caller-&gt;method_holder()-&gt;external_name(), k-&gt;external_name());
 114   }
 115   return k;
 116 }
 117 
 118 void AOTLib::handle_config_error(const char* format, ...) {
 119   if (PrintAOT) {
 120     va_list ap;
 121     va_start(ap, format);
 122     tty-&gt;vprint_cr(format, ap);
 123     va_end(ap);
 124   }
 125   if (UseAOTStrictLoading) {
 126     vm_exit(1);
 127   }
 128   _valid = false;
 129 }
 130 
 131 void AOTLib::verify_flag(bool aot_flag, bool flag, const char* name) {
 132   if (_valid &amp;&amp; aot_flag != flag) {
 133     handle_config_error(&quot;Shared file %s error: %s has different value &#39;%s&#39; from current &#39;%s&#39;&quot;, _name, name , (aot_flag ? &quot;true&quot; : &quot;false&quot;), (flag ? &quot;true&quot; : &quot;false&quot;));
 134   }
 135 }
 136 
 137 void AOTLib::verify_flag(int aot_flag, int flag, const char* name) {
 138   if (_valid &amp;&amp; aot_flag != flag) {
 139     handle_config_error(&quot;Shared file %s error: %s has different value &#39;%d&#39; from current &#39;%d&#39;&quot;, _name, name , aot_flag, flag);
 140   }
 141 }
 142 
 143 void AOTLib::verify_config() {
 144   GrowableArray&lt;AOTLib*&gt;* libraries = AOTLoader::libraries();
 145   for (GrowableArrayIterator&lt;AOTLib*&gt; lib = libraries-&gt;begin(); lib != libraries-&gt;end(); ++lib) {
 146     if ((*lib)-&gt;_config == _config) {
 147       handle_config_error(&quot;AOT library %s already loaded.&quot;, (*lib)-&gt;_name);
 148       return;
 149     }
 150   }
 151 
 152   if (_header-&gt;_version != AOTHeader::AOT_SHARED_VERSION) {
 153     handle_config_error(&quot;Invalid version of the shared file %s. Expected %d but was %d&quot;, _name, _header-&gt;_version, AOTHeader::AOT_SHARED_VERSION);
 154     return;
 155   }
 156 
 157   const char* aot_jvm_version = (const char*)_header + _header-&gt;_jvm_version_offset + 2;
 158   if (strcmp(aot_jvm_version, VM_Version::jre_release_version()) != 0) {
 159     handle_config_error(&quot;JVM version &#39;%s&#39; recorded in the shared file %s does not match current version &#39;%s&#39;&quot;, aot_jvm_version, _name, VM_Version::jre_release_version());
 160     return;
 161   }
 162 
 163   // Debug VM has different layout of runtime and metadata structures
 164 #ifdef ASSERT
 165   verify_flag(_config-&gt;_debug_VM, true, &quot;Debug VM version&quot;);
 166 #else
 167   verify_flag(!(_config-&gt;_debug_VM), true, &quot;Product VM version&quot;);
 168 #endif
 169   // Check configuration size
 170   verify_flag(_config-&gt;_config_size, AOTConfiguration::CONFIG_SIZE, &quot;AOT configuration size&quot;);
 171 
 172   // Check GC
 173   CollectedHeap::Name gc = (CollectedHeap::Name)_config-&gt;_gc;
 174   if (_valid &amp;&amp; !GCConfig::is_gc_selected(gc)) {
 175     handle_config_error(&quot;Shared file %s error: used &#39;%s&#39; is different from current &#39;%s&#39;&quot;, _name, GCConfig::hs_err_name(gc), GCConfig::hs_err_name());
 176   }
 177 
 178   // Check flags
 179   verify_flag(_config-&gt;_useCompressedOops, UseCompressedOops, &quot;UseCompressedOops&quot;);
 180   verify_flag(_config-&gt;_useCompressedClassPointers, UseCompressedClassPointers, &quot;UseCompressedClassPointers&quot;);
 181   verify_flag(_config-&gt;_useTLAB, UseTLAB, &quot;UseTLAB&quot;);
 182   verify_flag(_config-&gt;_useBiasedLocking, UseBiasedLocking, &quot;UseBiasedLocking&quot;);
 183   verify_flag(_config-&gt;_objectAlignment, ObjectAlignmentInBytes, &quot;ObjectAlignmentInBytes&quot;);
 184   verify_flag(_config-&gt;_contendedPaddingWidth, ContendedPaddingWidth, &quot;ContendedPaddingWidth&quot;);
 185   verify_flag(_config-&gt;_enableContended, EnableContended, &quot;EnableContended&quot;);
 186   verify_flag(_config-&gt;_restrictContended, RestrictContended, &quot;RestrictContended&quot;);
 187 
 188   if (!TieredCompilation &amp;&amp; _config-&gt;_tieredAOT) {
 189     handle_config_error(&quot;Shared file %s error: Expected to run with tiered compilation on&quot;, _name);
 190   }
 191 
 192   // Shifts are static values which initialized by 0 until java heap initialization.
 193   // AOT libs are loaded before heap initialized so shift values are not set.
 194   // It is okay since ObjectAlignmentInBytes flag which defines shifts value is set before AOT libs are loaded.
 195   // Set shifts value based on first AOT library config.
 196   if (UseCompressedOops &amp;&amp; _valid) {
 197     if (!_narrow_oop_shift_initialized) {
 198       _narrow_oop_shift = _config-&gt;_narrowOopShift;
 199       if (UseCompressedClassPointers) { // It is set only if UseCompressedOops is set
 200         _narrow_klass_shift = _config-&gt;_narrowKlassShift;
 201       }
 202       _narrow_oop_shift_initialized = true;
 203     } else {
 204       verify_flag(_config-&gt;_narrowOopShift, _narrow_oop_shift, &quot;aot_config-&gt;_narrowOopShift&quot;);
 205       if (UseCompressedClassPointers) { // It is set only if UseCompressedOops is set
 206         verify_flag(_config-&gt;_narrowKlassShift, _narrow_klass_shift, &quot;aot_config-&gt;_narrowKlassShift&quot;);
 207       }
 208     }
 209   }
 210 }
 211 
 212 AOTLib::~AOTLib() {
 213   os::free((void*) _name);
 214 }
 215 
 216 AOTCodeHeap::~AOTCodeHeap() {
 217   FREE_C_HEAP_ARRAY(AOTClass, _classes);
 218   FREE_C_HEAP_ARRAY(CodeToAMethod, _code_to_aot);
 219 }
 220 
 221 AOTLib::AOTLib(void* handle, const char* name, int dso_id) : _valid(true), _dl_handle(handle), _dso_id(dso_id) {
 222   _name = (const char*) os::strdup(name);
 223 
 224   // Verify that VM runs with the same parameters as AOT tool.
 225   _config = (AOTConfiguration*) load_symbol(&quot;A.config&quot;);
 226   _header = (AOTHeader*) load_symbol(&quot;A.header&quot;);
 227 
 228   verify_config();
 229 
 230   if (!_valid &amp;&amp; PrintAOT) {
 231       tty-&gt;print(&quot;%7d &quot;, (int) tty-&gt;time_stamp().milliseconds());
 232       tty-&gt;print_cr(&quot;%4d     skipped %s  aot library&quot;, _dso_id, _name);
 233   }
 234 }
 235 
 236 AOTCodeHeap::AOTCodeHeap(AOTLib* lib) :
 237     CodeHeap(&quot;CodeHeap &#39;AOT&#39;&quot;, CodeBlobType::AOT), _lib(lib), _classes(NULL), _code_to_aot(NULL) {
 238   assert(_lib-&gt;is_valid(), &quot;invalid library&quot;);
 239 
 240   _lib_symbols_initialized = false;
 241   _aot_id = 0;
 242 
 243   _class_count = _lib-&gt;header()-&gt;_class_count;
 244   _method_count = _lib-&gt;header()-&gt;_method_count;
 245 
 246   // Collect metaspace info: names -&gt; address in .got section
 247   _metaspace_names = (const char*) _lib-&gt;load_symbol(&quot;A.meta.names&quot;);
 248   _method_metadata =     (address) _lib-&gt;load_symbol(&quot;A.meth.metadata&quot;);
 249   _methods_offsets =     (address) _lib-&gt;load_symbol(&quot;A.meth.offsets&quot;);
 250   _klasses_offsets =     (address) _lib-&gt;load_symbol(&quot;A.kls.offsets&quot;);
 251   _dependencies    =     (address) _lib-&gt;load_symbol(&quot;A.kls.dependencies&quot;);
 252   _code_space      =     (address) _lib-&gt;load_symbol(&quot;A.text&quot;);
 253 
 254   // First cell is number of elements.
 255   _klasses_got      = (Metadata**) _lib-&gt;load_symbol(&quot;A.kls.got&quot;);
 256   _klasses_got_size = _lib-&gt;header()-&gt;_klasses_got_size;
 257 
 258   _metadata_got      = (Metadata**) _lib-&gt;load_symbol(&quot;A.meta.got&quot;);
 259   _metadata_got_size = _lib-&gt;header()-&gt;_metadata_got_size;
 260 
 261   _oop_got      = (oop*) _lib-&gt;load_symbol(&quot;A.oop.got&quot;);
 262   _oop_got_size = _lib-&gt;header()-&gt;_oop_got_size;
 263 
 264   // Collect stubs info
 265   _stubs_offsets = (int*) _lib-&gt;load_symbol(&quot;A.stubs.offsets&quot;);
 266 
 267   // code segments table
 268   _code_segments = (address) _lib-&gt;load_symbol(&quot;A.code.segments&quot;);
 269 
 270   // method state
 271   _method_state = (jlong*) _lib-&gt;load_symbol(&quot;A.meth.state&quot;);
 272 
 273   // Create a table for mapping classes
 274   _classes = NEW_C_HEAP_ARRAY(AOTClass, _class_count, mtCode);
 275   memset(_classes, 0, _class_count * sizeof(AOTClass));
 276 
 277   // Create table for searching AOTCompiledMethod based on pc.
 278   _code_to_aot = NEW_C_HEAP_ARRAY(CodeToAMethod, _method_count, mtCode);
 279   memset(_code_to_aot, 0, _method_count * sizeof(CodeToAMethod));
 280 
 281   _memory.set_low_boundary((char *)_code_space);
 282   _memory.set_high_boundary((char *)_code_space);
 283   _memory.set_low((char *)_code_space);
 284   _memory.set_high((char *)_code_space);
 285 
 286   _segmap.set_low_boundary((char *)_code_segments);
 287   _segmap.set_low((char *)_code_segments);
 288 
 289   _log2_segment_size = exact_log2(_lib-&gt;config()-&gt;_codeSegmentSize);
 290 
 291   // Register aot stubs
 292   register_stubs();
 293 
 294   if (PrintAOT || (PrintCompilation &amp;&amp; PrintAOT)) {
 295     tty-&gt;print(&quot;%7d &quot;, (int) tty-&gt;time_stamp().milliseconds());
 296     tty-&gt;print_cr(&quot;%4d     loaded    %s  aot library&quot;, _lib-&gt;id(), _lib-&gt;name());
 297   }
 298 }
 299 
 300 void AOTCodeHeap::publish_aot(const methodHandle&amp; mh, AOTMethodData* method_data, int code_id) {
 301   // The method may be explicitly excluded by the user.
 302   // Or Interpreter uses an intrinsic for this method.
 303   // Or method has breakpoints.
 304   if (CompilerOracle::should_exclude(mh) ||
 305       !AbstractInterpreter::can_be_compiled(mh) ||
 306       (mh-&gt;number_of_breakpoints() &gt; 0)) {
 307     return;
 308   }
 309   // Make sure no break points were set in the method in case of a safepoint
 310   // in the following code until aot code is registered.
 311   NoSafepointVerifier nsv;
 312 
 313   address code = method_data-&gt;_code;
 314   const char* name = method_data-&gt;_name;
 315   aot_metadata* meta = method_data-&gt;_meta;
 316 
 317   if (meta-&gt;scopes_pcs_begin() == meta-&gt;scopes_pcs_end()) {
 318     // Switch off NoSafepointVerifier because log_info() may cause safepoint
 319     // and it is fine because aot code will not be registered here.
 320     PauseNoSafepointVerifier pnsv(&amp;nsv);
 321 
 322     // When the AOT compiler compiles something big we fail to generate metadata
 323     // in CodeInstaller::gather_metadata. In that case the scopes_pcs_begin == scopes_pcs_end.
 324     // In all successful cases we always have 2 entries of scope pcs.
 325     log_info(aot, class, resolve)(&quot;Failed to load %s (no metadata available)&quot;, mh-&gt;name_and_sig_as_C_string());
 326     _code_to_aot[code_id]._state = invalid;
 327     return;
 328   }
 329 
 330   jlong* state_adr = &amp;_method_state[code_id];
 331   address metadata_table = method_data-&gt;_metadata_table;
 332   int metadata_size = method_data-&gt;_metadata_size;
 333   assert(code_id &lt; _method_count, &quot;sanity&quot;);
 334   _aot_id++;
 335 
 336 #ifdef ASSERT
 337   if (_aot_id &gt; CIStop || _aot_id &lt; CIStart) {
 338     // Skip compilation
 339     return;
 340   }
 341 #endif
 342   // Check one more time.
 343   if (_code_to_aot[code_id]._state == invalid) {
 344     return;
 345   }
 346   AOTCompiledMethod *aot = new AOTCompiledMethod(code, mh(), meta, metadata_table, metadata_size, state_adr, this, name, code_id, _aot_id);
 347   assert(_code_to_aot[code_id]._aot == NULL, &quot;should be not initialized&quot;);
 348   _code_to_aot[code_id]._aot = aot; // Should set this first
 349   if (Atomic::cmpxchg(&amp;_code_to_aot[code_id]._state, not_set, in_use) != not_set) {
 350     _code_to_aot[code_id]._aot = NULL; // Clean
 351   } else { // success
 352     // Publish method
 353 #ifdef TIERED
 354     mh-&gt;set_aot_code(aot);
 355 #endif
 356     {
 357       MutexLocker pl(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);
 358       Method::set_code(mh, aot);
 359     }
 360     if (PrintAOT || (PrintCompilation &amp;&amp; PrintAOT)) {
 361       PauseNoSafepointVerifier pnsv(&amp;nsv); // aot code is registered already
 362       aot-&gt;print_on(tty, NULL);
 363     }
 364     // Publish oop only after we are visible to CompiledMethodIterator
 365     aot-&gt;set_oop(mh()-&gt;method_holder()-&gt;klass_holder());
 366   }
 367 }
 368 
<a name="1" id="anc1"></a><span class="line-modified"> 369 void AOTCodeHeap::link_klass(const Klass* klass) {</span>
 370   ResourceMark rm;
<a name="2" id="anc2"></a><span class="line-added"> 371   assert(klass != NULL, &quot;Should be given a klass&quot;);</span>
<span class="line-added"> 372   AOTKlassData* klass_data = (AOTKlassData*) os::dll_lookup(_lib-&gt;dl_handle(), klass-&gt;signature_name());</span>
<span class="line-added"> 373   if (klass_data != NULL) {</span>
<span class="line-added"> 374     // Set both GOT cells, resolved and initialized klass pointers.</span>
<span class="line-added"> 375     // _got_index points to second cell - resolved klass pointer.</span>
<span class="line-added"> 376     _klasses_got[klass_data-&gt;_got_index-1] = (Metadata*)klass; // Initialized</span>
<span class="line-added"> 377     _klasses_got[klass_data-&gt;_got_index  ] = (Metadata*)klass; // Resolved</span>
<span class="line-added"> 378     if (PrintAOT) {</span>
<span class="line-added"> 379       tty-&gt;print_cr(&quot;[Found  %s  in  %s]&quot;, klass-&gt;internal_name(), _lib-&gt;name());</span>
<span class="line-added"> 380     }</span>
<span class="line-added"> 381   }</span>
<span class="line-added"> 382 }</span>
<span class="line-added"> 383 </span>
<span class="line-added"> 384 void AOTCodeHeap::link_known_klasses() {</span>
 385   for (int i = T_BOOLEAN; i &lt;= T_CONFLICT; i++) {
 386     BasicType t = (BasicType)i;
 387     if (is_java_primitive(t)) {
 388       const Klass* arr_klass = Universe::typeArrayKlassObj(t);
<a name="3" id="anc3"></a><span class="line-modified"> 389       link_klass(arr_klass);</span>









 390     }
 391   }
<a name="4" id="anc4"></a><span class="line-added"> 392   link_klass(SystemDictionary::Reference_klass());</span>
 393 }
 394 
 395 void AOTCodeHeap::register_stubs() {
 396   int stubs_count = _stubs_offsets[0]; // contains number
 397   _stubs_offsets++;
 398   AOTMethodOffsets* stub_offsets = (AOTMethodOffsets*)_stubs_offsets;
 399   for (int i = 0; i &lt; stubs_count; ++i) {
 400     const char* stub_name = _metaspace_names + stub_offsets[i]._name_offset;
 401     address entry = _code_space  + stub_offsets[i]._code_offset;
 402     aot_metadata* meta = (aot_metadata *) (_method_metadata + stub_offsets[i]._meta_offset);
 403     address metadata_table = (address)_metadata_got + stub_offsets[i]._metadata_got_offset;
 404     int metadata_size = stub_offsets[i]._metadata_got_size;
 405     int code_id = stub_offsets[i]._code_id;
 406     assert(code_id &lt; _method_count, &quot;sanity&quot;);
 407     jlong* state_adr = &amp;_method_state[code_id];
 408     int len = Bytes::get_Java_u2((address)stub_name);
 409     stub_name += 2;
 410     char* full_name = NEW_C_HEAP_ARRAY(char, len+5, mtCode);
 411     memcpy(full_name, &quot;AOT &quot;, 4);
 412     memcpy(full_name+4, stub_name, len);
 413     full_name[len+4] = 0;
 414     guarantee(_code_to_aot[code_id]._state != invalid, &quot;stub %s can&#39;t be invalidated&quot;, full_name);
 415     AOTCompiledMethod* aot = new AOTCompiledMethod(entry, NULL, meta, metadata_table, metadata_size, state_adr, this, full_name, code_id, i);
 416     assert(_code_to_aot[code_id]._aot  == NULL, &quot;should be not initialized&quot;);
 417     _code_to_aot[code_id]._aot  = aot;
 418     if (Atomic::cmpxchg(&amp;_code_to_aot[code_id]._state, not_set, in_use) != not_set) {
 419       fatal(&quot;stab &#39;%s&#39; code state is %d&quot;, full_name, _code_to_aot[code_id]._state);
 420     }
 421     // Adjust code buffer boundaries only for stubs because they are last in the buffer.
 422     adjust_boundaries(aot);
 423     if (PrintAOT &amp;&amp; Verbose) {
 424       aot-&gt;print_on(tty, NULL);
 425     }
 426   }
 427 }
 428 
 429 #define SET_AOT_GLOBAL_SYMBOL_VALUE(AOTSYMNAME, AOTSYMTYPE, VMSYMVAL) \
 430   {                                                                   \
 431     AOTSYMTYPE * adr = (AOTSYMTYPE *) os::dll_lookup(_lib-&gt;dl_handle(), AOTSYMNAME);  \
 432     /* Check for a lookup error */                                    \
 433     guarantee(adr != NULL, &quot;AOT Symbol not found %s&quot;, AOTSYMNAME);    \
 434     *adr = (AOTSYMTYPE) VMSYMVAL;                                     \
 435   }
 436 
 437 void AOTCodeHeap::link_graal_runtime_symbols()  {
 438     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_monitorenter&quot;, address, JVMCIRuntime::monitorenter);
 439     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_monitorexit&quot;, address, JVMCIRuntime::monitorexit);
 440     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_log_object&quot;, address, JVMCIRuntime::log_object);
 441     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_log_printf&quot;, address, JVMCIRuntime::log_printf);
 442     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_log_primitive&quot;, address, JVMCIRuntime::log_primitive);
 443     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_new_instance&quot;, address, JVMCIRuntime::new_instance);
 444     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_new_array&quot;, address, JVMCIRuntime::new_array);
 445     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_new_multi_array&quot;, address, JVMCIRuntime::new_multi_array);
 446     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_dynamic_new_instance&quot;, address, JVMCIRuntime::dynamic_new_instance);
 447     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_dynamic_new_array&quot;, address, JVMCIRuntime::dynamic_new_array);
 448     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_new_instance_or_null&quot;, address, JVMCIRuntime::new_instance_or_null);
 449     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_new_array_or_null&quot;, address, JVMCIRuntime::new_array_or_null);
 450     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_new_multi_array_or_null&quot;, address, JVMCIRuntime::new_multi_array_or_null);
 451     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_dynamic_new_instance_or_null&quot;, address, JVMCIRuntime::dynamic_new_instance_or_null);
 452     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_dynamic_new_array_or_null&quot;, address, JVMCIRuntime::dynamic_new_array_or_null);
 453     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_validate_object&quot;, address, JVMCIRuntime::validate_object);
 454 #if INCLUDE_G1GC
 455     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_write_barrier_pre&quot;, address, JVMCIRuntime::write_barrier_pre);
 456     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_write_barrier_post&quot;, address, JVMCIRuntime::write_barrier_post);
 457 #endif
 458     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_identity_hash_code&quot;, address, JVMCIRuntime::identity_hash_code);
 459     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_exception_handler_for_pc&quot;, address, JVMCIRuntime::exception_handler_for_pc);
 460     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_test_deoptimize_call_int&quot;, address, JVMCIRuntime::test_deoptimize_call_int);
 461     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_throw_and_post_jvmti_exception&quot;, address, JVMCIRuntime::throw_and_post_jvmti_exception);
 462     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_throw_klass_external_name_exception&quot;, address, JVMCIRuntime::throw_klass_external_name_exception);
 463     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_throw_class_cast_exception&quot;, address, JVMCIRuntime::throw_class_cast_exception);
 464     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_vm_message&quot;, address, JVMCIRuntime::vm_message);
 465     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_jvmci_runtime_vm_error&quot;, address, JVMCIRuntime::vm_error);
 466 }
 467 
 468 void AOTCodeHeap::link_shared_runtime_symbols() {
 469     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_resolve_static_entry&quot;, address, SharedRuntime::get_resolve_static_call_stub());
 470     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_resolve_virtual_entry&quot;, address, SharedRuntime::get_resolve_virtual_call_stub());
 471     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_resolve_opt_virtual_entry&quot;, address, SharedRuntime::get_resolve_opt_virtual_call_stub());
 472     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_deopt_blob_unpack&quot;, address, SharedRuntime::deopt_blob()-&gt;unpack());
 473     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_deopt_blob_unpack_with_exception_in_tls&quot;, address, SharedRuntime::deopt_blob()-&gt;unpack_with_exception_in_tls());
 474     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_deopt_blob_uncommon_trap&quot;, address, SharedRuntime::deopt_blob()-&gt;uncommon_trap());
 475     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_ic_miss_stub&quot;, address, SharedRuntime::get_ic_miss_stub());
 476     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_handle_wrong_method_stub&quot;, address, SharedRuntime::get_handle_wrong_method_stub());
 477     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_exception_handler_for_return_address&quot;, address, SharedRuntime::exception_handler_for_return_address);
 478     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_register_finalizer&quot;, address, SharedRuntime::register_finalizer);
 479     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_object_notify&quot;, address, JVMCIRuntime::object_notify);
 480     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_object_notifyAll&quot;, address, JVMCIRuntime::object_notifyAll);
 481     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_OSR_migration_end&quot;, address, SharedRuntime::OSR_migration_end);
 482     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_enable_stack_reserved_zone&quot;, address, SharedRuntime::enable_stack_reserved_zone);
 483     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_resolve_dynamic_invoke&quot;, address, CompilerRuntime::resolve_dynamic_invoke);
 484     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_resolve_string_by_symbol&quot;, address, CompilerRuntime::resolve_string_by_symbol);
 485     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_resolve_klass_by_symbol&quot;, address, CompilerRuntime::resolve_klass_by_symbol);
 486     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_resolve_method_by_symbol_and_load_counters&quot;, address, CompilerRuntime::resolve_method_by_symbol_and_load_counters);
 487     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_initialize_klass_by_symbol&quot;, address, CompilerRuntime::initialize_klass_by_symbol);
 488     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_invocation_event&quot;, address, CompilerRuntime::invocation_event);
 489     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_backedge_event&quot;, address, CompilerRuntime::backedge_event);
 490 
 491     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_shared_runtime_dpow&quot;, address, SharedRuntime::dpow);
 492     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_shared_runtime_dexp&quot;, address, SharedRuntime::dexp);
 493     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_shared_runtime_dcos&quot;, address, SharedRuntime::dcos);
 494     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_shared_runtime_dsin&quot;, address, SharedRuntime::dsin);
 495     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_shared_runtime_dtan&quot;, address, SharedRuntime::dtan);
 496     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_shared_runtime_dlog&quot;, address, SharedRuntime::dlog);
 497     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_shared_runtime_dlog10&quot;, address, SharedRuntime::dlog10);
 498 }
 499 
 500 void AOTCodeHeap::link_stub_routines_symbols() {
 501     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_jbyte_arraycopy&quot;, address, StubRoutines::_jbyte_arraycopy);
 502     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_jshort_arraycopy&quot;, address, StubRoutines::_jshort_arraycopy);
 503     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_jint_arraycopy&quot;, address, StubRoutines::_jint_arraycopy);
 504     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_jlong_arraycopy&quot;, address, StubRoutines::_jlong_arraycopy);
 505     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_oop_arraycopy&quot;, address, StubRoutines::_oop_arraycopy);
 506     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_oop_arraycopy_uninit&quot;, address, StubRoutines::_oop_arraycopy_uninit);
 507 
 508     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_jbyte_disjoint_arraycopy&quot;, address, StubRoutines::_jbyte_disjoint_arraycopy);
 509     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_jshort_disjoint_arraycopy&quot;, address, StubRoutines::_jshort_disjoint_arraycopy);
 510     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_jint_disjoint_arraycopy&quot;, address, StubRoutines::_jint_disjoint_arraycopy);
 511     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_jlong_disjoint_arraycopy&quot;, address, StubRoutines::_jlong_disjoint_arraycopy);
 512     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_oop_disjoint_arraycopy&quot;, address, StubRoutines::_oop_disjoint_arraycopy);
 513     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_oop_disjoint_arraycopy_uninit&quot;, address, StubRoutines::_oop_disjoint_arraycopy_uninit);
 514 
 515     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_arrayof_jbyte_arraycopy&quot;, address, StubRoutines::_arrayof_jbyte_arraycopy);
 516     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_arrayof_jshort_arraycopy&quot;, address, StubRoutines::_arrayof_jshort_arraycopy);
 517     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_arrayof_jint_arraycopy&quot;, address, StubRoutines::_arrayof_jint_arraycopy);
 518     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_arrayof_jlong_arraycopy&quot;, address, StubRoutines::_arrayof_jlong_arraycopy);
 519     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_arrayof_oop_arraycopy&quot;, address, StubRoutines::_arrayof_oop_arraycopy);
 520     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_arrayof_oop_arraycopy_uninit&quot;, address, StubRoutines::_arrayof_oop_arraycopy_uninit);
 521 
 522     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_arrayof_jbyte_disjoint_arraycopy&quot;, address, StubRoutines::_arrayof_jbyte_disjoint_arraycopy);
 523     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_arrayof_jshort_disjoint_arraycopy&quot;, address, StubRoutines::_arrayof_jshort_disjoint_arraycopy);
 524     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_arrayof_jint_disjoint_arraycopy&quot;, address, StubRoutines::_arrayof_jint_disjoint_arraycopy);
 525     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_arrayof_jlong_disjoint_arraycopy&quot;, address, StubRoutines::_arrayof_jlong_disjoint_arraycopy);
 526     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_arrayof_oop_disjoint_arraycopy&quot;, address, StubRoutines::_arrayof_oop_disjoint_arraycopy);
 527     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_arrayof_oop_disjoint_arraycopy_uninit&quot;, address, StubRoutines::_arrayof_oop_disjoint_arraycopy_uninit);
 528 
 529     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_unsafe_arraycopy&quot;, address, StubRoutines::_unsafe_arraycopy);
 530 
 531     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_checkcast_arraycopy&quot;, address, StubRoutines::_checkcast_arraycopy);
 532 
 533     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_generic_arraycopy&quot;, address, StubRoutines::_generic_arraycopy);
 534 
 535     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_aescrypt_encryptBlock&quot;, address, StubRoutines::_aescrypt_encryptBlock);
 536     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_aescrypt_decryptBlock&quot;, address, StubRoutines::_aescrypt_decryptBlock);
 537     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_cipherBlockChaining_encryptAESCrypt&quot;, address, StubRoutines::_cipherBlockChaining_encryptAESCrypt);
 538     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_cipherBlockChaining_decryptAESCrypt&quot;, address, StubRoutines::_cipherBlockChaining_decryptAESCrypt);
 539     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_electronicCodeBook_encryptAESCrypt&quot;, address, StubRoutines::_electronicCodeBook_encryptAESCrypt);
 540     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_electronicCodeBook_decryptAESCrypt&quot;, address, StubRoutines::_electronicCodeBook_decryptAESCrypt);
 541     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_update_bytes_crc32&quot;, address, StubRoutines::_updateBytesCRC32);
 542     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_crc_table_adr&quot;, address, StubRoutines::_crc_table_adr);
 543 
 544 
 545     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_sha1_implCompress&quot;, address, StubRoutines::_sha1_implCompress);
 546     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_sha1_implCompressMB&quot;, address, StubRoutines::_sha1_implCompressMB);
 547     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_sha256_implCompress&quot;, address, StubRoutines::_sha256_implCompress);
 548     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_sha256_implCompressMB&quot;, address, StubRoutines::_sha256_implCompressMB);
 549     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_sha512_implCompress&quot;, address, StubRoutines::_sha512_implCompress);
 550     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_sha512_implCompressMB&quot;, address, StubRoutines::_sha512_implCompressMB);
 551     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_multiplyToLen&quot;, address, StubRoutines::_multiplyToLen);
 552 
 553     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_counterMode_AESCrypt&quot;, address, StubRoutines::_counterMode_AESCrypt);
 554     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_ghash_processBlocks&quot;, address, StubRoutines::_ghash_processBlocks);
 555     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_base64_encodeBlock&quot;, address, StubRoutines::_base64_encodeBlock);
 556     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_crc32c_table_addr&quot;, address, StubRoutines::_crc32c_table_addr);
 557     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_updateBytesCRC32C&quot;, address, StubRoutines::_updateBytesCRC32C);
 558     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_updateBytesAdler32&quot;, address, StubRoutines::_updateBytesAdler32);
 559     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_squareToLen&quot;, address, StubRoutines::_squareToLen);
 560     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_mulAdd&quot;, address, StubRoutines::_mulAdd);
 561     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_montgomeryMultiply&quot;,  address, StubRoutines::_montgomeryMultiply);
 562     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_montgomerySquare&quot;, address, StubRoutines::_montgomerySquare);
 563     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_vectorizedMismatch&quot;, address, StubRoutines::_vectorizedMismatch);
 564     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_bigIntegerRightShiftWorker&quot;, address, StubRoutines::_bigIntegerRightShiftWorker);
 565     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_bigIntegerLeftShiftWorker&quot;, address, StubRoutines::_bigIntegerLeftShiftWorker);
 566 
 567     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_stub_routines_throw_delayed_StackOverflowError_entry&quot;, address, StubRoutines::_throw_delayed_StackOverflowError_entry);
 568 
 569 }
 570 
 571 void AOTCodeHeap::link_os_symbols() {
 572     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_os_javaTimeMillis&quot;, address, os::javaTimeMillis);
 573     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_os_javaTimeNanos&quot;, address, os::javaTimeNanos);
 574 }
 575 
 576 /*
 577  * Link any global symbols in precompiled DSO with dlopen() _dl_handle
 578  * dso_handle.
 579  */
 580 
 581 void AOTCodeHeap::link_global_lib_symbols() {
 582   if (!_lib_symbols_initialized) {
 583     _lib_symbols_initialized = true;
 584 
 585     CollectedHeap* heap = Universe::heap();
 586     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_card_table_address&quot;, address, (BarrierSet::barrier_set()-&gt;is_a(BarrierSet::CardTableBarrierSet) ? ci_card_table_address() : NULL));
 587     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_heap_top_address&quot;, address, (heap-&gt;supports_inline_contig_alloc() ? heap-&gt;top_addr() : NULL));
 588     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_heap_end_address&quot;, address, (heap-&gt;supports_inline_contig_alloc() ? heap-&gt;end_addr() : NULL));
 589     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_narrow_klass_base_address&quot;, address, CompressedKlassPointers::base());
 590     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_narrow_oop_base_address&quot;, address, CompressedOops::base());
 591 #if INCLUDE_G1GC
 592     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_log_of_heap_region_grain_bytes&quot;, int, HeapRegion::LogOfHRGrainBytes);
 593 #endif
 594     SET_AOT_GLOBAL_SYMBOL_VALUE(&quot;_aot_inline_contiguous_allocation_supported&quot;, bool, heap-&gt;supports_inline_contig_alloc());
 595     link_shared_runtime_symbols();
 596     link_stub_routines_symbols();
 597     link_os_symbols();
 598     link_graal_runtime_symbols();
<a name="5" id="anc5"></a><span class="line-modified"> 599     link_known_klasses();</span>


 600   }
 601 }
 602 
 603 #ifndef PRODUCT
 604 int AOTCodeHeap::klasses_seen = 0;
 605 int AOTCodeHeap::aot_klasses_found = 0;
 606 int AOTCodeHeap::aot_klasses_fp_miss = 0;
 607 int AOTCodeHeap::aot_klasses_cl_miss = 0;
 608 int AOTCodeHeap::aot_methods_found = 0;
 609 
 610 void AOTCodeHeap::print_statistics() {
 611   tty-&gt;print_cr(&quot;Classes seen: %d  AOT classes found: %d  AOT methods found: %d&quot;, klasses_seen, aot_klasses_found, aot_methods_found);
 612   tty-&gt;print_cr(&quot;AOT fingerprint mismatches: %d  AOT class loader mismatches: %d&quot;, aot_klasses_fp_miss, aot_klasses_cl_miss);
 613 }
 614 #endif
 615 
 616 Method* AOTCodeHeap::find_method(Klass* klass, Thread* thread, const char* method_name) {
 617   int method_name_len = Bytes::get_Java_u2((address)method_name);
 618   method_name += 2;
 619   const char* signature_name = method_name + method_name_len;
 620   int signature_name_len = Bytes::get_Java_u2((address)signature_name);
 621   signature_name += 2;
 622   // The class should have been loaded so the method and signature should already be
 623   // in the symbol table.  If they&#39;re not there, the method doesn&#39;t exist.
 624   TempNewSymbol name = SymbolTable::probe(method_name, method_name_len);
 625   TempNewSymbol signature = SymbolTable::probe(signature_name, signature_name_len);
 626 
 627   Method* m;
 628   if (name == NULL || signature == NULL) {
 629     m = NULL;
 630   } else if (name == vmSymbols::object_initializer_name() ||
 631              name == vmSymbols::class_initializer_name()) {
 632     // Never search superclasses for constructors
 633     if (klass-&gt;is_instance_klass()) {
 634       m = InstanceKlass::cast(klass)-&gt;find_method(name, signature);
 635     } else {
 636       m = NULL;
 637     }
 638   } else {
 639     m = klass-&gt;lookup_method(name, signature);
 640     if (m == NULL &amp;&amp; klass-&gt;is_instance_klass()) {
 641       m = InstanceKlass::cast(klass)-&gt;lookup_method_in_ordered_interfaces(name, signature);
 642     }
 643   }
 644   if (m == NULL) {
 645     // Fatal error because we assume classes and methods should not be changed since aot compilation.
 646     const char* klass_name = klass-&gt;external_name();
 647     int klass_len = (int)strlen(klass_name);
 648     char* meta_name = NEW_RESOURCE_ARRAY(char, klass_len + 1 + method_name_len + signature_name_len + 1);
 649     memcpy(meta_name, klass_name, klass_len);
 650     meta_name[klass_len] = &#39;.&#39;;
 651     memcpy(&amp;meta_name[klass_len + 1], method_name, method_name_len);
 652     memcpy(&amp;meta_name[klass_len + 1 + method_name_len], signature_name, signature_name_len);
 653     meta_name[klass_len + 1 + method_name_len + signature_name_len] = &#39;\0&#39;;
 654     Handle exception = Exceptions::new_exception(thread, vmSymbols::java_lang_NoSuchMethodError(), meta_name);
 655     java_lang_Throwable::print(exception(), tty);
 656     tty-&gt;cr();
 657     java_lang_Throwable::print_stack_trace(exception, tty);
 658     tty-&gt;cr();
 659     fatal(&quot;Failed to find method &#39;%s&#39;&quot;, meta_name);
 660   }
 661   NOT_PRODUCT( aot_methods_found++; )
 662   return m;
 663 }
 664 
 665 AOTKlassData* AOTCodeHeap::find_klass(const char *name) {
 666   return (AOTKlassData*) os::dll_lookup(_lib-&gt;dl_handle(), name);
 667 }
 668 
 669 AOTKlassData* AOTCodeHeap::find_klass(InstanceKlass* ik) {
 670   ResourceMark rm;
 671   AOTKlassData* klass_data = find_klass(ik-&gt;signature_name());
 672   return klass_data;
 673 }
 674 
 675 bool AOTCodeHeap::is_dependent_method(Klass* dependee, AOTCompiledMethod* aot) {
 676   InstanceKlass *dependee_ik = InstanceKlass::cast(dependee);
 677   AOTKlassData* klass_data = find_klass(dependee_ik);
 678   if (klass_data == NULL) {
 679     return false; // no AOT records for this class - no dependencies
 680   }
 681   if (!dependee_ik-&gt;has_passed_fingerprint_check()) {
 682     return false; // different class
 683   }
 684 
 685   int methods_offset = klass_data-&gt;_dependent_methods_offset;
 686   if (methods_offset &gt;= 0) {
 687     address methods_cnt_adr = _dependencies + methods_offset;
 688     int methods_cnt = *(int*)methods_cnt_adr;
 689     int* indexes = (int*)(methods_cnt_adr + 4);
 690     for (int i = 0; i &lt; methods_cnt; ++i) {
 691       int code_id = indexes[i];
 692       if (_code_to_aot[code_id]._aot == aot) {
 693         return true; // found dependent method
 694       }
 695     }
 696   }
 697   return false;
 698 }
 699 
 700 void AOTCodeHeap::mark_evol_dependent_methods(InstanceKlass* dependee) {
 701   AOTKlassData* klass_data = find_klass(dependee);
 702   if (klass_data == NULL) {
 703     return; // no AOT records for this class - no dependencies
 704   }
 705   if (!dependee-&gt;has_passed_fingerprint_check()) {
 706     return; // different class
 707   }
 708 
 709   int methods_offset = klass_data-&gt;_dependent_methods_offset;
 710   if (methods_offset &gt;= 0) {
 711     address methods_cnt_adr = _dependencies + methods_offset;
 712     int methods_cnt = *(int*)methods_cnt_adr;
 713     int* indexes = (int*)(methods_cnt_adr + 4);
 714     for (int i = 0; i &lt; methods_cnt; ++i) {
 715       int code_id = indexes[i];
 716       AOTCompiledMethod* aot = _code_to_aot[code_id]._aot;
 717       if (aot != NULL) {
 718         aot-&gt;mark_for_deoptimization(false);
 719       }
 720     }
 721   }
 722 }
 723 
 724 void AOTCodeHeap::sweep_dependent_methods(int* indexes, int methods_cnt) {
 725   int marked = 0;
 726   for (int i = 0; i &lt; methods_cnt; ++i) {
 727     int code_id = indexes[i];
 728     // Invalidate aot code.
 729     if (Atomic::cmpxchg(&amp;_code_to_aot[code_id]._state, not_set, invalid) != not_set) {
 730       if (_code_to_aot[code_id]._state == in_use) {
 731         AOTCompiledMethod* aot = _code_to_aot[code_id]._aot;
 732         assert(aot != NULL, &quot;aot should be set&quot;);
 733         if (!aot-&gt;is_runtime_stub()) { // Something is wrong - should not invalidate stubs.
 734           aot-&gt;mark_for_deoptimization(false);
 735           marked++;
 736         }
 737       }
 738     }
 739   }
 740   if (marked &gt; 0) {
 741     Deoptimization::deoptimize_all_marked();
 742   }
 743 }
 744 
 745 void AOTCodeHeap::sweep_dependent_methods(AOTKlassData* klass_data) {
 746   // Make dependent methods non_entrant forever.
 747   int methods_offset = klass_data-&gt;_dependent_methods_offset;
 748   if (methods_offset &gt;= 0) {
 749     address methods_cnt_adr = _dependencies + methods_offset;
 750     int methods_cnt = *(int*)methods_cnt_adr;
 751     int* indexes = (int*)(methods_cnt_adr + 4);
 752     sweep_dependent_methods(indexes, methods_cnt);
 753   }
 754 }
 755 
 756 void AOTCodeHeap::sweep_dependent_methods(InstanceKlass* ik) {
 757   AOTKlassData* klass_data = find_klass(ik);
 758   vmassert(klass_data != NULL, &quot;dependency data missing&quot;);
 759   sweep_dependent_methods(klass_data);
 760 }
 761 
 762 void AOTCodeHeap::sweep_method(AOTCompiledMethod *aot) {
 763   int indexes[] = {aot-&gt;method_index()};
 764   sweep_dependent_methods(indexes, 1);
 765   vmassert(aot-&gt;method()-&gt;code() != aot TIERED_ONLY( &amp;&amp; aot-&gt;method()-&gt;aot_code() == NULL), &quot;method still active&quot;);
 766 }
 767 
 768 
 769 bool AOTCodeHeap::load_klass_data(InstanceKlass* ik, Thread* thread) {
 770   ResourceMark rm;
 771 
 772   NOT_PRODUCT( klasses_seen++; )
 773 
 774   // AOT does not support custom class loaders.
 775   ClassLoaderData* cld = ik-&gt;class_loader_data();
 776   if (!cld-&gt;is_builtin_class_loader_data()) {
 777     log_trace(aot, class, load)(&quot;skip class  %s  for custom classloader %s (%p) tid=&quot; INTPTR_FORMAT,
 778                                 ik-&gt;internal_name(), cld-&gt;loader_name(), cld, p2i(thread));
 779     return false;
 780   }
 781 
 782   AOTKlassData* klass_data = find_klass(ik);
 783   if (klass_data == NULL) {
 784     return false;
 785   }
 786 
 787   if (!ik-&gt;has_passed_fingerprint_check()) {
 788     NOT_PRODUCT( aot_klasses_fp_miss++; )
 789     log_trace(aot, class, fingerprint)(&quot;class  %s%s  has bad fingerprint in  %s tid=&quot; INTPTR_FORMAT,
 790                                        ik-&gt;internal_name(), ik-&gt;is_shared() ? &quot; (shared)&quot; : &quot;&quot;,
 791                                        _lib-&gt;name(), p2i(thread));
 792     sweep_dependent_methods(klass_data);
 793     return false;
 794   }
 795 
 796   if (ik-&gt;has_been_redefined()) {
 797     log_trace(aot, class, load)(&quot;class  %s%s in %s  has been redefined tid=&quot; INTPTR_FORMAT,
 798                                 ik-&gt;internal_name(), ik-&gt;is_shared() ? &quot; (shared)&quot; : &quot;&quot;,
 799                                 _lib-&gt;name(), p2i(thread));
 800     sweep_dependent_methods(klass_data);
 801     return false;
 802   }
 803 
 804   assert(klass_data-&gt;_class_id &lt; _class_count, &quot;invalid class id&quot;);
 805   AOTClass* aot_class = &amp;_classes[klass_data-&gt;_class_id];
 806   ClassLoaderData* aot_cld = aot_class-&gt;_classloader;
 807   if (aot_cld != NULL &amp;&amp; aot_cld != cld) {
 808     log_trace(aot, class, load)(&quot;class  %s  in  %s already loaded for classloader %s (%p) vs %s (%p) tid=&quot; INTPTR_FORMAT,
 809                                 ik-&gt;internal_name(), _lib-&gt;name(), aot_cld-&gt;loader_name(), aot_cld, cld-&gt;loader_name(), cld, p2i(thread));
 810     NOT_PRODUCT( aot_klasses_cl_miss++; )
 811     return false;
 812   }
 813 
 814   if (_lib-&gt;config()-&gt;_omitAssertions &amp;&amp; JavaAssertions::enabled(ik-&gt;name()-&gt;as_C_string(), ik-&gt;class_loader() == NULL)) {
 815     log_trace(aot, class, load)(&quot;class  %s  in  %s does not have java assertions in compiled code, but assertions are enabled for this execution.&quot;, ik-&gt;internal_name(), _lib-&gt;name());
 816     sweep_dependent_methods(klass_data);
 817     return false;
 818   }
 819 
 820   NOT_PRODUCT( aot_klasses_found++; )
 821 
 822   log_trace(aot, class, load)(&quot;found  %s  in  %s for classloader %s (%p) tid=&quot; INTPTR_FORMAT, ik-&gt;internal_name(), _lib-&gt;name(), cld-&gt;loader_name(), cld, p2i(thread));
 823 
 824   aot_class-&gt;_classloader = cld;
 825   // Set klass&#39;s Resolve (second) got cell.
 826   _klasses_got[klass_data-&gt;_got_index] = ik;
 827   if (ik-&gt;is_initialized()) {
 828     _klasses_got[klass_data-&gt;_got_index - 1] = ik;
 829   }
 830 
 831   // Initialize global symbols of the DSO to the corresponding VM symbol values.
 832   link_global_lib_symbols();
 833 
 834   int methods_offset = klass_data-&gt;_compiled_methods_offset;
 835   if (methods_offset &gt;= 0) {
 836     address methods_cnt_adr = _methods_offsets + methods_offset;
 837     int methods_cnt = *(int*)methods_cnt_adr;
 838     // Collect data about compiled methods
 839     AOTMethodData* methods_data = NEW_RESOURCE_ARRAY(AOTMethodData, methods_cnt);
 840     AOTMethodOffsets* methods_offsets = (AOTMethodOffsets*)(methods_cnt_adr + 4);
 841     for (int i = 0; i &lt; methods_cnt; ++i) {
 842       AOTMethodOffsets* method_offsets = &amp;methods_offsets[i];
 843       int code_id = method_offsets-&gt;_code_id;
 844       if (_code_to_aot[code_id]._state == invalid) {
 845         continue; // skip AOT methods slots which have been invalidated
 846       }
 847       AOTMethodData* method_data = &amp;methods_data[i];
 848       const char* aot_name = _metaspace_names + method_offsets-&gt;_name_offset;
 849       method_data-&gt;_name = aot_name;
 850       method_data-&gt;_code = _code_space  + method_offsets-&gt;_code_offset;
 851       method_data-&gt;_meta = (aot_metadata*)(_method_metadata + method_offsets-&gt;_meta_offset);
 852       method_data-&gt;_metadata_table = (address)_metadata_got + method_offsets-&gt;_metadata_got_offset;
 853       method_data-&gt;_metadata_size  = method_offsets-&gt;_metadata_got_size;
 854       // aot_name format: &quot;&lt;u2_size&gt;Ljava/lang/ThreadGroup;&lt;u2_size&gt;addUnstarted&lt;u2_size&gt;()V&quot;
 855       int klass_len = Bytes::get_Java_u2((address)aot_name);
 856       const char* method_name = aot_name + 2 + klass_len;
 857       Method* m = AOTCodeHeap::find_method(ik, thread, method_name);
 858       methodHandle mh(thread, m);
 859       if (mh-&gt;code() != NULL) { // Does it have already compiled code?
 860         continue; // Don&#39;t overwrite
 861       }
 862       publish_aot(mh, method_data, code_id);
 863     }
 864   }
 865   return true;
 866 }
 867 
 868 AOTCompiledMethod* AOTCodeHeap::next_in_use_at(int start) const {
 869   for (int index = start; index &lt; _method_count; index++) {
 870     if (_code_to_aot[index]._state != in_use) {
 871       continue; // Skip uninitialized entries.
 872     }
 873     AOTCompiledMethod* aot = _code_to_aot[index]._aot;
 874     return aot;
 875   }
 876   return NULL;
 877 }
 878 
 879 void* AOTCodeHeap::first() const {
 880   return next_in_use_at(0);
 881 }
 882 
 883 void* AOTCodeHeap::next(void* p) const {
 884   AOTCompiledMethod *aot = (AOTCompiledMethod *)p;
 885   int next_index = aot-&gt;method_index() + 1;
 886   assert(next_index &lt;= _method_count, &quot;&quot;);
 887   if (next_index == _method_count) {
 888     return NULL;
 889   }
 890   return next_in_use_at(next_index);
 891 }
 892 
 893 void* AOTCodeHeap::find_start(void* p) const {
 894   if (!contains(p)) {
 895     return NULL;
 896   }
 897   size_t offset = pointer_delta(p, low_boundary(), 1);
 898   // Use segments table
 899   size_t seg_idx = offset / _lib-&gt;config()-&gt;_codeSegmentSize;
 900   if ((int)(_code_segments[seg_idx]) == 0xff) {
 901     return NULL;
 902   }
 903   while (_code_segments[seg_idx] &gt; 0) {
 904     seg_idx -= (int)_code_segments[seg_idx];
 905   }
 906   int code_offset = (int)seg_idx * _lib-&gt;config()-&gt;_codeSegmentSize;
 907   int aot_index = *(int*)(_code_space + code_offset);
 908   AOTCompiledMethod* aot = _code_to_aot[aot_index]._aot;
 909   assert(aot != NULL, &quot;should find registered aot method&quot;);
 910   return aot;
 911 }
 912 
 913 AOTCompiledMethod* AOTCodeHeap::find_aot(address p) const {
 914   assert(contains(p), &quot;should be here&quot;);
 915   return (AOTCompiledMethod *)find_start(p);
 916 }
 917 
 918 CodeBlob* AOTCodeHeap::find_blob_unsafe(void* start) const {
 919   return (CodeBlob*)AOTCodeHeap::find_start(start);
 920 }
 921 
 922 void AOTCodeHeap::oops_do(OopClosure* f) {
 923   for (int i = 0; i &lt; _oop_got_size; i++) {
 924     oop* p = &amp;_oop_got[i];
 925     if (*p == NULL)  continue;  // skip non-oops
 926     f-&gt;do_oop(p);
 927   }
 928   for (int index = 0; index &lt; _method_count; index++) {
 929     if (_code_to_aot[index]._state != in_use) {
 930       continue; // Skip uninitialized entries.
 931     }
 932     AOTCompiledMethod* aot = _code_to_aot[index]._aot;
 933     aot-&gt;do_oops(f);
 934   }
 935 }
 936 
 937 // Scan only klasses_got cells which should have only Klass*,
 938 // metadata_got cells are scanned only for alive AOT methods
 939 // by AOTCompiledMethod::metadata_do().
 940 void AOTCodeHeap::got_metadata_do(MetadataClosure* f) {
 941   for (int i = 1; i &lt; _klasses_got_size; i++) {
 942     Metadata** p = &amp;_klasses_got[i];
 943     Metadata* md = *p;
 944     if (md == NULL)  continue;  // skip non-oops
 945     if (Metaspace::contains(md)) {
 946       f-&gt;do_metadata(md);
 947     } else {
 948       intptr_t meta = (intptr_t)md;
 949       fatal(&quot;Invalid value in _klasses_got[%d] = &quot; INTPTR_FORMAT, i, meta);
 950     }
 951   }
 952 }
 953 
 954 void AOTCodeHeap::cleanup_inline_caches() {
 955   for (int index = 0; index &lt; _method_count; index++) {
 956     if (_code_to_aot[index]._state != in_use) {
 957       continue; // Skip uninitialized entries.
 958     }
 959     AOTCompiledMethod* aot = _code_to_aot[index]._aot;
 960     aot-&gt;cleanup_inline_caches(false);
 961   }
 962 }
 963 
 964 #ifdef ASSERT
 965 int AOTCodeHeap::verify_icholder_relocations() {
 966   int count = 0;
 967   for (int index = 0; index &lt; _method_count; index++) {
 968     if (_code_to_aot[index]._state != in_use) {
 969       continue; // Skip uninitialized entries.
 970     }
 971     AOTCompiledMethod* aot = _code_to_aot[index]._aot;
 972     count += aot-&gt;verify_icholder_relocations();
 973   }
 974   return count;
 975 }
 976 #endif
 977 
 978 void AOTCodeHeap::metadata_do(MetadataClosure* f) {
 979   for (int index = 0; index &lt; _method_count; index++) {
 980     if (_code_to_aot[index]._state != in_use) {
 981       continue; // Skip uninitialized entries.
 982     }
 983     AOTCompiledMethod* aot = _code_to_aot[index]._aot;
 984     if (aot-&gt;_is_alive()) {
 985       aot-&gt;metadata_do(f);
 986     }
 987   }
 988   // Scan klasses_got cells.
 989   got_metadata_do(f);
 990 }
 991 
 992 bool AOTCodeHeap::reconcile_dynamic_klass(AOTCompiledMethod *caller, InstanceKlass* holder, int index, Klass *dyno_klass, const char *descriptor1, const char *descriptor2) {
 993   const char * const descriptors[2] = {descriptor1, descriptor2};
 994   JavaThread *thread = JavaThread::current();
 995   ResourceMark rm(thread);
 996 
 997   AOTKlassData* holder_data = find_klass(holder);
 998   vmassert(holder_data != NULL, &quot;klass %s not found&quot;, holder-&gt;signature_name());
 999   vmassert(is_dependent_method(holder, caller), &quot;sanity&quot;);
1000 
1001   AOTKlassData* dyno_data = NULL;
1002   bool adapter_failed = false;
1003   char buf[64];
1004   int descriptor_index = 0;
1005   // descriptors[0] specific name (&quot;adapter:&lt;method_id&gt;&quot;) for matching
1006   // descriptors[1] fall-back name (&quot;adapter&quot;) for depdencies
1007   while (descriptor_index &lt; 2) {
1008     const char *descriptor = descriptors[descriptor_index];
1009     if (descriptor == NULL) {
1010       break;
1011     }
1012     jio_snprintf(buf, sizeof buf, &quot;%s&lt;%d:%d&gt;&quot;, descriptor, holder_data-&gt;_class_id, index);
1013     dyno_data = find_klass(buf);
1014     if (dyno_data != NULL) {
1015       break;
1016     }
1017     // If match failed then try fall-back for dependencies
1018     ++descriptor_index;
1019     adapter_failed = true;
1020   }
1021 
1022   if (dyno_data == NULL &amp;&amp; dyno_klass == NULL) {
1023     // all is well, no (appendix) at compile-time, and still none
1024     return true;
1025   }
1026 
1027   if (dyno_data == NULL) {
1028     // no (appendix) at build-time, but now there is
1029     sweep_dependent_methods(holder_data);
1030     return false;
1031   }
1032 
1033   if (adapter_failed) {
1034     // adapter method mismatch
1035     sweep_dependent_methods(holder_data);
1036     sweep_dependent_methods(dyno_data);
1037     return false;
1038   }
1039 
1040   if (dyno_klass == NULL) {
1041     // (appendix) at build-time, none now
1042     sweep_dependent_methods(holder_data);
1043     sweep_dependent_methods(dyno_data);
1044     return false;
1045   }
1046 
1047   // TODO: support array appendix object
1048   if (!dyno_klass-&gt;is_instance_klass()) {
1049     sweep_dependent_methods(holder_data);
1050     sweep_dependent_methods(dyno_data);
1051     return false;
1052   }
1053 
1054   InstanceKlass* dyno = InstanceKlass::cast(dyno_klass);
1055 
1056   if (!dyno-&gt;is_hidden() &amp;&amp; !dyno-&gt;is_unsafe_anonymous()) {
1057     if (_klasses_got[dyno_data-&gt;_got_index] != dyno) {
1058       // compile-time class different from runtime class, fail and deoptimize
1059       sweep_dependent_methods(holder_data);
1060       sweep_dependent_methods(dyno_data);
1061       return false;
1062     }
1063 
1064     if (dyno-&gt;is_initialized()) {
1065       _klasses_got[dyno_data-&gt;_got_index - 1] = dyno;
1066     }
1067     return true;
1068   }
1069 
1070   // TODO: support anonymous supers
1071   if (!dyno-&gt;supers_have_passed_fingerprint_checks() || dyno-&gt;get_stored_fingerprint() != dyno_data-&gt;_fingerprint) {
1072       NOT_PRODUCT( aot_klasses_fp_miss++; )
1073       log_trace(aot, class, fingerprint)(&quot;class  %s%s  has bad fingerprint in  %s tid=&quot; INTPTR_FORMAT,
1074           dyno-&gt;internal_name(), dyno-&gt;is_shared() ? &quot; (shared)&quot; : &quot;&quot;,
1075           _lib-&gt;name(), p2i(thread));
1076     sweep_dependent_methods(holder_data);
1077     sweep_dependent_methods(dyno_data);
1078     return false;
1079   }
1080 
1081   _klasses_got[dyno_data-&gt;_got_index] = dyno;
1082   if (dyno-&gt;is_initialized()) {
1083     _klasses_got[dyno_data-&gt;_got_index - 1] = dyno;
1084   }
1085 
1086   // TODO: hook up any AOT code
1087   // load_klass_data(dyno_data, thread);
1088   return true;
1089 }
1090 
1091 bool AOTCodeHeap::reconcile_dynamic_method(AOTCompiledMethod *caller, InstanceKlass* holder, int index, Method *adapter_method) {
1092     InstanceKlass *adapter_klass = adapter_method-&gt;method_holder();
1093     char buf[64];
1094     jio_snprintf(buf, sizeof buf, &quot;adapter:%d&quot;, adapter_method-&gt;method_idnum());
1095     if (!reconcile_dynamic_klass(caller, holder, index, adapter_klass, buf, &quot;adapter&quot;)) {
1096       return false;
1097     }
1098     return true;
1099 }
1100 
1101 bool AOTCodeHeap::reconcile_dynamic_invoke(AOTCompiledMethod* caller, InstanceKlass* holder, int index, Method* adapter_method, Klass *appendix_klass) {
1102     if (!reconcile_dynamic_klass(caller, holder, index, appendix_klass, &quot;appendix&quot;)) {
1103       return false;
1104     }
1105 
1106     if (!reconcile_dynamic_method(caller, holder, index, adapter_method)) {
1107       return false;
1108     }
1109 
1110     return true;
1111 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
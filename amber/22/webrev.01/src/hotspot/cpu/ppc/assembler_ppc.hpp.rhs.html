<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/ppc/assembler_ppc.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2002, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2012, 2020 SAP SE. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #ifndef CPU_PPC_ASSEMBLER_PPC_HPP
  27 #define CPU_PPC_ASSEMBLER_PPC_HPP
  28 
  29 #include &quot;asm/register.hpp&quot;
  30 
  31 // Address is an abstraction used to represent a memory location
  32 // as used in assembler instructions.
  33 // PPC instructions grok either baseReg + indexReg or baseReg + disp.
  34 class Address {
  35  private:
  36   Register _base;         // Base register.
  37   Register _index;        // Index register.
  38   intptr_t _disp;         // Displacement.
  39 
  40  public:
  41   Address(Register b, Register i, address d = 0)
  42     : _base(b), _index(i), _disp((intptr_t)d) {
  43     assert(i == noreg || d == 0, &quot;can&#39;t have both&quot;);
  44   }
  45 
  46   Address(Register b, address d = 0)
  47     : _base(b), _index(noreg), _disp((intptr_t)d) {}
  48 
  49   Address(Register b, intptr_t d)
  50     : _base(b), _index(noreg), _disp(d) {}
  51 
  52   Address(Register b, RegisterOrConstant roc)
  53     : _base(b), _index(noreg), _disp(0) {
  54     if (roc.is_constant()) _disp = roc.as_constant(); else _index = roc.as_register();
  55   }
  56 
  57   Address()
  58     : _base(noreg), _index(noreg), _disp(0) {}
  59 
  60   // accessors
  61   Register base()  const { return _base; }
  62   Register index() const { return _index; }
  63   int      disp()  const { return (int)_disp; }
  64   bool     is_const() const { return _base == noreg &amp;&amp; _index == noreg; }
  65 };
  66 
  67 class AddressLiteral {
  68  private:
  69   address          _address;
  70   RelocationHolder _rspec;
  71 
  72   RelocationHolder rspec_from_rtype(relocInfo::relocType rtype, address addr) {
  73     switch (rtype) {
  74     case relocInfo::external_word_type:
  75       return external_word_Relocation::spec(addr);
  76     case relocInfo::internal_word_type:
  77       return internal_word_Relocation::spec(addr);
  78     case relocInfo::opt_virtual_call_type:
  79       return opt_virtual_call_Relocation::spec();
  80     case relocInfo::static_call_type:
  81       return static_call_Relocation::spec();
  82     case relocInfo::runtime_call_type:
  83       return runtime_call_Relocation::spec();
  84     case relocInfo::none:
  85       return RelocationHolder();
  86     default:
  87       ShouldNotReachHere();
  88       return RelocationHolder();
  89     }
  90   }
  91 
  92  protected:
  93   // creation
  94   AddressLiteral() : _address(NULL), _rspec(NULL) {}
  95 
  96  public:
  97   AddressLiteral(address addr, RelocationHolder const&amp; rspec)
  98     : _address(addr),
  99       _rspec(rspec) {}
 100 
 101   AddressLiteral(address addr, relocInfo::relocType rtype = relocInfo::none)
 102     : _address((address) addr),
 103       _rspec(rspec_from_rtype(rtype, (address) addr)) {}
 104 
 105   AddressLiteral(oop* addr, relocInfo::relocType rtype = relocInfo::none)
 106     : _address((address) addr),
 107       _rspec(rspec_from_rtype(rtype, (address) addr)) {}
 108 
 109   intptr_t value() const { return (intptr_t) _address; }
 110 
 111   const RelocationHolder&amp; rspec() const { return _rspec; }
 112 };
 113 
 114 // Argument is an abstraction used to represent an outgoing
 115 // actual argument or an incoming formal parameter, whether
 116 // it resides in memory or in a register, in a manner consistent
 117 // with the PPC Application Binary Interface, or ABI. This is
 118 // often referred to as the native or C calling convention.
 119 
 120 class Argument {
 121  private:
 122   int _number;  // The number of the argument.
 123  public:
 124   enum {
 125     // Only 8 registers may contain integer parameters.
 126     n_register_parameters = 8,
 127     // Can have up to 8 floating registers.
 128     n_float_register_parameters = 8,
 129 
 130     // PPC C calling conventions.
 131     // The first eight arguments are passed in int regs if they are int.
 132     n_int_register_parameters_c = 8,
 133     // The first thirteen float arguments are passed in float regs.
 134     n_float_register_parameters_c = 13,
 135     // Only the first 8 parameters are not placed on the stack. Aix disassembly
 136     // shows that xlC places all float args after argument 8 on the stack AND
 137     // in a register. This is not documented, but we follow this convention, too.
 138     n_regs_not_on_stack_c = 8,
 139   };
 140   // creation
 141   Argument(int number) : _number(number) {}
 142 
 143   int  number() const { return _number; }
 144 
 145   // Locating register-based arguments:
 146   bool is_register() const { return _number &lt; n_register_parameters; }
 147 
 148   Register as_register() const {
 149     assert(is_register(), &quot;must be a register argument&quot;);
 150     return as_Register(number() + R3_ARG1-&gt;encoding());
 151   }
 152 };
 153 
 154 #if !defined(ABI_ELFv2)
 155 // A ppc64 function descriptor.
 156 struct FunctionDescriptor {
 157  private:
 158   address _entry;
 159   address _toc;
 160   address _env;
 161 
 162  public:
 163   inline address entry() const { return _entry; }
 164   inline address toc()   const { return _toc; }
 165   inline address env()   const { return _env; }
 166 
 167   inline void set_entry(address entry) { _entry = entry; }
 168   inline void set_toc(  address toc)   { _toc   = toc; }
 169   inline void set_env(  address env)   { _env   = env; }
 170 
 171   inline static ByteSize entry_offset() { return byte_offset_of(FunctionDescriptor, _entry); }
 172   inline static ByteSize toc_offset()   { return byte_offset_of(FunctionDescriptor, _toc); }
 173   inline static ByteSize env_offset()   { return byte_offset_of(FunctionDescriptor, _env); }
 174 
 175   // Friend functions can be called without loading toc and env.
 176   enum {
 177     friend_toc = 0xcafe,
 178     friend_env = 0xc0de
 179   };
 180 
 181   inline bool is_friend_function() const {
 182     return (toc() == (address) friend_toc) &amp;&amp; (env() == (address) friend_env);
 183   }
 184 
 185   // Constructor for stack-allocated instances.
 186   FunctionDescriptor() {
 187     _entry = (address) 0xbad;
 188     _toc   = (address) 0xbad;
 189     _env   = (address) 0xbad;
 190   }
 191 };
 192 #endif
 193 
 194 
 195 // The PPC Assembler: Pure assembler doing NO optimizations on the
 196 // instruction level; i.e., what you write is what you get. The
 197 // Assembler is generating code into a CodeBuffer.
 198 
 199 class Assembler : public AbstractAssembler {
 200  protected:
 201   // Displacement routines
 202   static int  patched_branch(int dest_pos, int inst, int inst_pos);
 203   static int  branch_destination(int inst, int pos);
 204 
 205   friend class AbstractAssembler;
 206 
 207   // Code patchers need various routines like inv_wdisp()
 208   friend class NativeInstruction;
 209   friend class NativeGeneralJump;
 210   friend class Relocation;
 211 
 212  public:
 213 
 214   enum shifts {
 215     XO_21_29_SHIFT = 2,
 216     XO_21_30_SHIFT = 1,
 217     XO_27_29_SHIFT = 2,
 218     XO_30_31_SHIFT = 0,
 219     SPR_5_9_SHIFT  = 11u, // SPR_5_9 field in bits 11 -- 15
 220     SPR_0_4_SHIFT  = 16u, // SPR_0_4 field in bits 16 -- 20
 221     RS_SHIFT       = 21u, // RS field in bits 21 -- 25
 222     OPCODE_SHIFT   = 26u, // opcode in bits 26 -- 31
 223   };
 224 
 225   enum opcdxos_masks {
 226     XL_FORM_OPCODE_MASK = (63u &lt;&lt; OPCODE_SHIFT) | (1023u &lt;&lt; 1),
 227     ADDI_OPCODE_MASK    = (63u &lt;&lt; OPCODE_SHIFT),
 228     ADDIS_OPCODE_MASK   = (63u &lt;&lt; OPCODE_SHIFT),
 229     BXX_OPCODE_MASK     = (63u &lt;&lt; OPCODE_SHIFT),
 230     BCXX_OPCODE_MASK    = (63u &lt;&lt; OPCODE_SHIFT),
 231     // trap instructions
 232     TDI_OPCODE_MASK     = (63u &lt;&lt; OPCODE_SHIFT),
 233     TWI_OPCODE_MASK     = (63u &lt;&lt; OPCODE_SHIFT),
 234     TD_OPCODE_MASK      = (63u &lt;&lt; OPCODE_SHIFT) | (1023u &lt;&lt; 1),
 235     TW_OPCODE_MASK      = (63u &lt;&lt; OPCODE_SHIFT) | (1023u &lt;&lt; 1),
 236     LD_OPCODE_MASK      = (63u &lt;&lt; OPCODE_SHIFT) | (3u &lt;&lt; XO_30_31_SHIFT), // DS-FORM
 237     STD_OPCODE_MASK     = LD_OPCODE_MASK,
 238     STDU_OPCODE_MASK    = STD_OPCODE_MASK,
 239     STDX_OPCODE_MASK    = (63u &lt;&lt; OPCODE_SHIFT) | (1023u &lt;&lt; 1),
 240     STDUX_OPCODE_MASK   = STDX_OPCODE_MASK,
 241     STW_OPCODE_MASK     = (63u &lt;&lt; OPCODE_SHIFT),
 242     STWU_OPCODE_MASK    = STW_OPCODE_MASK,
 243     STWX_OPCODE_MASK    = (63u &lt;&lt; OPCODE_SHIFT) | (1023u &lt;&lt; 1),
 244     STWUX_OPCODE_MASK   = STWX_OPCODE_MASK,
 245     MTCTR_OPCODE_MASK   = ~(31u &lt;&lt; RS_SHIFT),
 246     ORI_OPCODE_MASK     = (63u &lt;&lt; OPCODE_SHIFT),
 247     ORIS_OPCODE_MASK    = (63u &lt;&lt; OPCODE_SHIFT),
 248     RLDICR_OPCODE_MASK  = (63u &lt;&lt; OPCODE_SHIFT) | (7u &lt;&lt; XO_27_29_SHIFT)
 249   };
 250 
 251   enum opcdxos {
 252     ADD_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT | 266u &lt;&lt; 1),
 253     ADDC_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  10u &lt;&lt; 1),
 254     ADDI_OPCODE   = (14u &lt;&lt; OPCODE_SHIFT),
 255     ADDIS_OPCODE  = (15u &lt;&lt; OPCODE_SHIFT),
 256     ADDIC__OPCODE = (13u &lt;&lt; OPCODE_SHIFT),
 257     ADDE_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 138u &lt;&lt; 1),
 258     ADDME_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 234u &lt;&lt; 1),
 259     ADDZE_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 202u &lt;&lt; 1),
 260     SUBF_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  40u &lt;&lt; 1),
 261     SUBFC_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |   8u &lt;&lt; 1),
 262     SUBFE_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 136u &lt;&lt; 1),
 263     SUBFIC_OPCODE = (8u  &lt;&lt; OPCODE_SHIFT),
 264     SUBFME_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 232u &lt;&lt; 1),
 265     SUBFZE_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 200u &lt;&lt; 1),
 266     DIVW_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 491u &lt;&lt; 1),
 267     MULLW_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 235u &lt;&lt; 1),
 268     MULHW_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  75u &lt;&lt; 1),
 269     MULHWU_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  11u &lt;&lt; 1),
 270     MULLI_OPCODE  = (7u  &lt;&lt; OPCODE_SHIFT),
 271     AND_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  28u &lt;&lt; 1),
 272     ANDI_OPCODE   = (28u &lt;&lt; OPCODE_SHIFT),
 273     ANDIS_OPCODE  = (29u &lt;&lt; OPCODE_SHIFT),
 274     ANDC_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  60u &lt;&lt; 1),
 275     ORC_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT | 412u &lt;&lt; 1),
 276     OR_OPCODE     = (31u &lt;&lt; OPCODE_SHIFT | 444u &lt;&lt; 1),
 277     ORI_OPCODE    = (24u &lt;&lt; OPCODE_SHIFT),
 278     ORIS_OPCODE   = (25u &lt;&lt; OPCODE_SHIFT),
 279     XOR_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT | 316u &lt;&lt; 1),
 280     XORI_OPCODE   = (26u &lt;&lt; OPCODE_SHIFT),
 281     XORIS_OPCODE  = (27u &lt;&lt; OPCODE_SHIFT),
 282 
 283     NEG_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT | 104u &lt;&lt; 1),
 284 
 285     RLWINM_OPCODE = (21u &lt;&lt; OPCODE_SHIFT),
 286     CLRRWI_OPCODE = RLWINM_OPCODE,
 287     CLRLWI_OPCODE = RLWINM_OPCODE,
 288 
 289     RLWIMI_OPCODE = (20u &lt;&lt; OPCODE_SHIFT),
 290 
 291     SLW_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  24u &lt;&lt; 1),
 292     SLWI_OPCODE   = RLWINM_OPCODE,
 293     SRW_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT | 536u &lt;&lt; 1),
 294     SRWI_OPCODE   = RLWINM_OPCODE,
 295     SRAW_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 792u &lt;&lt; 1),
 296     SRAWI_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 824u &lt;&lt; 1),
 297 
 298     CMP_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |   0u &lt;&lt; 1),
 299     CMPI_OPCODE   = (11u &lt;&lt; OPCODE_SHIFT),
 300     CMPL_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  32u &lt;&lt; 1),
 301     CMPLI_OPCODE  = (10u &lt;&lt; OPCODE_SHIFT),
 302     CMPRB_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 192u &lt;&lt; 1),
 303     CMPEQB_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 224u &lt;&lt; 1),
 304 
 305     ISEL_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  15u &lt;&lt; 1),
 306 
 307     // Special purpose registers
 308     MTSPR_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 467u &lt;&lt; 1),
 309     MFSPR_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 339u &lt;&lt; 1),
 310 
 311     MTXER_OPCODE  = (MTSPR_OPCODE | 1 &lt;&lt; SPR_0_4_SHIFT),
 312     MFXER_OPCODE  = (MFSPR_OPCODE | 1 &lt;&lt; SPR_0_4_SHIFT),
 313 
 314     MTDSCR_OPCODE = (MTSPR_OPCODE | 3 &lt;&lt; SPR_0_4_SHIFT),
 315     MFDSCR_OPCODE = (MFSPR_OPCODE | 3 &lt;&lt; SPR_0_4_SHIFT),
 316 
 317     MTLR_OPCODE   = (MTSPR_OPCODE | 8 &lt;&lt; SPR_0_4_SHIFT),
 318     MFLR_OPCODE   = (MFSPR_OPCODE | 8 &lt;&lt; SPR_0_4_SHIFT),
 319 
 320     MTCTR_OPCODE  = (MTSPR_OPCODE | 9 &lt;&lt; SPR_0_4_SHIFT),
 321     MFCTR_OPCODE  = (MFSPR_OPCODE | 9 &lt;&lt; SPR_0_4_SHIFT),
 322 
 323     // Attention: Higher and lower half are inserted in reversed order.
 324     MTTFHAR_OPCODE   = (MTSPR_OPCODE | 4 &lt;&lt; SPR_5_9_SHIFT | 0 &lt;&lt; SPR_0_4_SHIFT),
 325     MFTFHAR_OPCODE   = (MFSPR_OPCODE | 4 &lt;&lt; SPR_5_9_SHIFT | 0 &lt;&lt; SPR_0_4_SHIFT),
 326     MTTFIAR_OPCODE   = (MTSPR_OPCODE | 4 &lt;&lt; SPR_5_9_SHIFT | 1 &lt;&lt; SPR_0_4_SHIFT),
 327     MFTFIAR_OPCODE   = (MFSPR_OPCODE | 4 &lt;&lt; SPR_5_9_SHIFT | 1 &lt;&lt; SPR_0_4_SHIFT),
 328     MTTEXASR_OPCODE  = (MTSPR_OPCODE | 4 &lt;&lt; SPR_5_9_SHIFT | 2 &lt;&lt; SPR_0_4_SHIFT),
 329     MFTEXASR_OPCODE  = (MFSPR_OPCODE | 4 &lt;&lt; SPR_5_9_SHIFT | 2 &lt;&lt; SPR_0_4_SHIFT),
 330     MTTEXASRU_OPCODE = (MTSPR_OPCODE | 4 &lt;&lt; SPR_5_9_SHIFT | 3 &lt;&lt; SPR_0_4_SHIFT),
 331     MFTEXASRU_OPCODE = (MFSPR_OPCODE | 4 &lt;&lt; SPR_5_9_SHIFT | 3 &lt;&lt; SPR_0_4_SHIFT),
 332 
 333     MTVRSAVE_OPCODE  = (MTSPR_OPCODE | 8 &lt;&lt; SPR_5_9_SHIFT | 0 &lt;&lt; SPR_0_4_SHIFT),
 334     MFVRSAVE_OPCODE  = (MFSPR_OPCODE | 8 &lt;&lt; SPR_5_9_SHIFT | 0 &lt;&lt; SPR_0_4_SHIFT),
 335 
 336     MFTB_OPCODE   = (MFSPR_OPCODE | 8 &lt;&lt; SPR_5_9_SHIFT | 12 &lt;&lt; SPR_0_4_SHIFT),
 337 
 338     MTCRF_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 144u &lt;&lt; 1),
 339     MFCR_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 19u &lt;&lt; 1),
 340     MCRF_OPCODE   = (19u &lt;&lt; OPCODE_SHIFT | 0u &lt;&lt; 1),
 341     SETB_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 128u &lt;&lt; 1),
 342 
 343     // condition register logic instructions
 344     CRAND_OPCODE  = (19u &lt;&lt; OPCODE_SHIFT | 257u &lt;&lt; 1),
 345     CRNAND_OPCODE = (19u &lt;&lt; OPCODE_SHIFT | 225u &lt;&lt; 1),
 346     CROR_OPCODE   = (19u &lt;&lt; OPCODE_SHIFT | 449u &lt;&lt; 1),
 347     CRXOR_OPCODE  = (19u &lt;&lt; OPCODE_SHIFT | 193u &lt;&lt; 1),
 348     CRNOR_OPCODE  = (19u &lt;&lt; OPCODE_SHIFT |  33u &lt;&lt; 1),
 349     CREQV_OPCODE  = (19u &lt;&lt; OPCODE_SHIFT | 289u &lt;&lt; 1),
 350     CRANDC_OPCODE = (19u &lt;&lt; OPCODE_SHIFT | 129u &lt;&lt; 1),
 351     CRORC_OPCODE  = (19u &lt;&lt; OPCODE_SHIFT | 417u &lt;&lt; 1),
 352 
 353     BCLR_OPCODE   = (19u &lt;&lt; OPCODE_SHIFT | 16u &lt;&lt; 1),
 354     BXX_OPCODE      = (18u &lt;&lt; OPCODE_SHIFT),
 355     BCXX_OPCODE     = (16u &lt;&lt; OPCODE_SHIFT),
 356 
 357     // CTR-related opcodes
 358     BCCTR_OPCODE  = (19u &lt;&lt; OPCODE_SHIFT | 528u &lt;&lt; 1),
 359 
 360     LWZ_OPCODE   = (32u &lt;&lt; OPCODE_SHIFT),
 361     LWZX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  23u &lt;&lt; 1),
 362     LWZU_OPCODE  = (33u &lt;&lt; OPCODE_SHIFT),
 363     LWBRX_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  534 &lt;&lt; 1),
 364 
 365     LHA_OPCODE   = (42u &lt;&lt; OPCODE_SHIFT),
 366     LHAX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 343u &lt;&lt; 1),
 367     LHAU_OPCODE  = (43u &lt;&lt; OPCODE_SHIFT),
 368 
 369     LHZ_OPCODE   = (40u &lt;&lt; OPCODE_SHIFT),
 370     LHZX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 279u &lt;&lt; 1),
 371     LHZU_OPCODE  = (41u &lt;&lt; OPCODE_SHIFT),
 372     LHBRX_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  790 &lt;&lt; 1),
 373 
 374     LBZ_OPCODE   = (34u &lt;&lt; OPCODE_SHIFT),
 375     LBZX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  87u &lt;&lt; 1),
 376     LBZU_OPCODE  = (35u &lt;&lt; OPCODE_SHIFT),
 377 
 378     STW_OPCODE   = (36u &lt;&lt; OPCODE_SHIFT),
 379     STWX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 151u &lt;&lt; 1),
 380     STWU_OPCODE  = (37u &lt;&lt; OPCODE_SHIFT),
 381     STWUX_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 183u &lt;&lt; 1),
 382     STWBRX_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 662u &lt;&lt; 1),
 383 
 384     STH_OPCODE   = (44u &lt;&lt; OPCODE_SHIFT),
 385     STHX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 407u &lt;&lt; 1),
 386     STHU_OPCODE  = (45u &lt;&lt; OPCODE_SHIFT),
 387     STHBRX_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 918u &lt;&lt; 1),
 388 
 389     STB_OPCODE   = (38u &lt;&lt; OPCODE_SHIFT),
 390     STBX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 215u &lt;&lt; 1),
 391     STBU_OPCODE  = (39u &lt;&lt; OPCODE_SHIFT),
 392 
 393     EXTSB_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 954u &lt;&lt; 1),
 394     EXTSH_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 922u &lt;&lt; 1),
 395     EXTSW_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 986u &lt;&lt; 1),               // X-FORM
 396 
 397     // 32 bit opcode encodings
 398 
 399     LWA_OPCODE    = (58u &lt;&lt; OPCODE_SHIFT |   2u &lt;&lt; XO_30_31_SHIFT), // DS-FORM
 400     LWAX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 341u &lt;&lt; XO_21_30_SHIFT), // X-FORM
 401 
 402     CNTLZW_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  26u &lt;&lt; XO_21_30_SHIFT), // X-FORM
 403     CNTTZW_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 538u &lt;&lt; XO_21_30_SHIFT), // X-FORM
 404 
 405     // 64 bit opcode encodings
 406 
 407     LD_OPCODE     = (58u &lt;&lt; OPCODE_SHIFT |   0u &lt;&lt; XO_30_31_SHIFT), // DS-FORM
 408     LDU_OPCODE    = (58u &lt;&lt; OPCODE_SHIFT |   1u &lt;&lt; XO_30_31_SHIFT), // DS-FORM
 409     LDX_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  21u &lt;&lt; XO_21_30_SHIFT), // X-FORM
 410     LDBRX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 532u &lt;&lt; 1),              // X-FORM
 411 
 412     STD_OPCODE    = (62u &lt;&lt; OPCODE_SHIFT |   0u &lt;&lt; XO_30_31_SHIFT), // DS-FORM
 413     STDU_OPCODE   = (62u &lt;&lt; OPCODE_SHIFT |   1u &lt;&lt; XO_30_31_SHIFT), // DS-FORM
 414     STDUX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 181u &lt;&lt; 1),              // X-FORM
 415     STDX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 149u &lt;&lt; XO_21_30_SHIFT), // X-FORM
 416     STDBRX_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 660u &lt;&lt; 1),              // X-FORM
 417 
 418     RLDICR_OPCODE = (30u &lt;&lt; OPCODE_SHIFT |   1u &lt;&lt; XO_27_29_SHIFT), // MD-FORM
 419     RLDICL_OPCODE = (30u &lt;&lt; OPCODE_SHIFT |   0u &lt;&lt; XO_27_29_SHIFT), // MD-FORM
 420     RLDIC_OPCODE  = (30u &lt;&lt; OPCODE_SHIFT |   2u &lt;&lt; XO_27_29_SHIFT), // MD-FORM
 421     RLDIMI_OPCODE = (30u &lt;&lt; OPCODE_SHIFT |   3u &lt;&lt; XO_27_29_SHIFT), // MD-FORM
 422 
 423     SRADI_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 413u &lt;&lt; XO_21_29_SHIFT), // XS-FORM
 424 
 425     SLD_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  27u &lt;&lt; 1),              // X-FORM
 426     SRD_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT | 539u &lt;&lt; 1),              // X-FORM
 427     SRAD_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 794u &lt;&lt; 1),              // X-FORM
 428 
 429     MULLD_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 233u &lt;&lt; 1),              // XO-FORM
 430     MULHD_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  73u &lt;&lt; 1),              // XO-FORM
 431     MULHDU_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |   9u &lt;&lt; 1),              // XO-FORM
 432     DIVD_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 489u &lt;&lt; 1),              // XO-FORM
 433 
 434     CNTLZD_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  58u &lt;&lt; XO_21_30_SHIFT), // X-FORM
 435     CNTTZD_OPCODE = (31u &lt;&lt; OPCODE_SHIFT | 570u &lt;&lt; XO_21_30_SHIFT), // X-FORM
 436     NAND_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT | 476u &lt;&lt; XO_21_30_SHIFT), // X-FORM
 437     NOR_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT | 124u &lt;&lt; XO_21_30_SHIFT), // X-FORM
 438 
 439 
 440     // opcodes only used for floating arithmetic
 441     FADD_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |  21u &lt;&lt; 1),
 442     FADDS_OPCODE  = (59u &lt;&lt; OPCODE_SHIFT |  21u &lt;&lt; 1),
 443     FCMPU_OPCODE  = (63u &lt;&lt; OPCODE_SHIFT |  00u &lt;&lt; 1),
 444     FDIV_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |  18u &lt;&lt; 1),
 445     FDIVS_OPCODE  = (59u &lt;&lt; OPCODE_SHIFT |  18u &lt;&lt; 1),
 446     FMR_OPCODE    = (63u &lt;&lt; OPCODE_SHIFT |  72u &lt;&lt; 1),
 447     FRIN_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT | 392u &lt;&lt; 1),
 448     FRIP_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT | 456u &lt;&lt; 1),
 449     FRIM_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT | 488u &lt;&lt; 1),
 450     // These are special Power6 opcodes, reused for &quot;lfdepx&quot; and &quot;stfdepx&quot;
 451     // on Power7.  Do not use.
 452     // MFFGPR_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 607u &lt;&lt; 1),
 453     // MFTGPR_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT | 735u &lt;&lt; 1),
 454     CMPB_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  508  &lt;&lt; 1),
 455     POPCNTB_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  122  &lt;&lt; 1),
 456     POPCNTW_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  378  &lt;&lt; 1),
 457     POPCNTD_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  506  &lt;&lt; 1),
 458     FABS_OPCODE    = (63u &lt;&lt; OPCODE_SHIFT |  264u &lt;&lt; 1),
 459     FNABS_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |  136u &lt;&lt; 1),
 460     FMUL_OPCODE    = (63u &lt;&lt; OPCODE_SHIFT |   25u &lt;&lt; 1),
 461     FMULS_OPCODE   = (59u &lt;&lt; OPCODE_SHIFT |   25u &lt;&lt; 1),
 462     FNEG_OPCODE    = (63u &lt;&lt; OPCODE_SHIFT |   40u &lt;&lt; 1),
 463     FSUB_OPCODE    = (63u &lt;&lt; OPCODE_SHIFT |   20u &lt;&lt; 1),
 464     FSUBS_OPCODE   = (59u &lt;&lt; OPCODE_SHIFT |   20u &lt;&lt; 1),
 465 
 466     // PPC64-internal FPU conversion opcodes
 467     FCFID_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |  846u &lt;&lt; 1),
 468     FCFIDS_OPCODE  = (59u &lt;&lt; OPCODE_SHIFT |  846u &lt;&lt; 1),
 469     FCTID_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |  814u &lt;&lt; 1),
 470     FCTIDZ_OPCODE  = (63u &lt;&lt; OPCODE_SHIFT |  815u &lt;&lt; 1),
 471     FCTIW_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |   14u &lt;&lt; 1),
 472     FCTIWZ_OPCODE  = (63u &lt;&lt; OPCODE_SHIFT |   15u &lt;&lt; 1),
 473     FRSP_OPCODE    = (63u &lt;&lt; OPCODE_SHIFT |   12u &lt;&lt; 1),
 474 
 475     // Fused multiply-accumulate instructions.
 476     FMADD_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |   29u &lt;&lt; 1),
 477     FMADDS_OPCODE  = (59u &lt;&lt; OPCODE_SHIFT |   29u &lt;&lt; 1),
 478     FMSUB_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |   28u &lt;&lt; 1),
 479     FMSUBS_OPCODE  = (59u &lt;&lt; OPCODE_SHIFT |   28u &lt;&lt; 1),
 480     FNMADD_OPCODE  = (63u &lt;&lt; OPCODE_SHIFT |   31u &lt;&lt; 1),
 481     FNMADDS_OPCODE = (59u &lt;&lt; OPCODE_SHIFT |   31u &lt;&lt; 1),
 482     FNMSUB_OPCODE  = (63u &lt;&lt; OPCODE_SHIFT |   30u &lt;&lt; 1),
 483     FNMSUBS_OPCODE = (59u &lt;&lt; OPCODE_SHIFT |   30u &lt;&lt; 1),
 484 
 485     LFD_OPCODE     = (50u &lt;&lt; OPCODE_SHIFT |   00u &lt;&lt; 1),
 486     LFDU_OPCODE    = (51u &lt;&lt; OPCODE_SHIFT |   00u &lt;&lt; 1),
 487     LFDX_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  599u &lt;&lt; 1),
 488     LFS_OPCODE     = (48u &lt;&lt; OPCODE_SHIFT |   00u &lt;&lt; 1),
 489     LFSU_OPCODE    = (49u &lt;&lt; OPCODE_SHIFT |   00u &lt;&lt; 1),
 490     LFSX_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  535u &lt;&lt; 1),
 491 
 492     STFD_OPCODE    = (54u &lt;&lt; OPCODE_SHIFT |   00u &lt;&lt; 1),
 493     STFDU_OPCODE   = (55u &lt;&lt; OPCODE_SHIFT |   00u &lt;&lt; 1),
 494     STFDX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  727u &lt;&lt; 1),
 495     STFS_OPCODE    = (52u &lt;&lt; OPCODE_SHIFT |   00u &lt;&lt; 1),
 496     STFSU_OPCODE   = (53u &lt;&lt; OPCODE_SHIFT |   00u &lt;&lt; 1),
 497     STFSX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  663u &lt;&lt; 1),
 498 
 499     FSQRT_OPCODE   = (63u &lt;&lt; OPCODE_SHIFT |   22u &lt;&lt; 1),            // A-FORM
 500     FSQRTS_OPCODE  = (59u &lt;&lt; OPCODE_SHIFT |   22u &lt;&lt; 1),            // A-FORM
 501 
 502     // Vector instruction support for &gt;= Power6
 503     // Vector Storage Access
 504     LVEBX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |    7u &lt;&lt; 1),
 505     LVEHX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |   39u &lt;&lt; 1),
 506     LVEWX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |   71u &lt;&lt; 1),
 507     LVX_OPCODE     = (31u &lt;&lt; OPCODE_SHIFT |  103u &lt;&lt; 1),
 508     LVXL_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  359u &lt;&lt; 1),
 509     STVEBX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  135u &lt;&lt; 1),
 510     STVEHX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  167u &lt;&lt; 1),
 511     STVEWX_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  199u &lt;&lt; 1),
 512     STVX_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  231u &lt;&lt; 1),
 513     STVXL_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  487u &lt;&lt; 1),
 514     LVSL_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |    6u &lt;&lt; 1),
 515     LVSR_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |   38u &lt;&lt; 1),
 516 
 517     // Vector-Scalar (VSX) instruction support.
 518     LXVD2X_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  844u &lt;&lt; 1),
 519     STXVD2X_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  972u &lt;&lt; 1),
 520     MTVSRD_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  179u &lt;&lt; 1),
 521     MTVSRWZ_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  243u &lt;&lt; 1),
 522     MFVSRD_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |   51u &lt;&lt; 1),
 523     MTVSRWA_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  211u &lt;&lt; 1),
 524     MFVSRWZ_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  115u &lt;&lt; 1),
 525     XXPERMDI_OPCODE= (60u &lt;&lt; OPCODE_SHIFT |   10u &lt;&lt; 3),
 526     XXMRGHW_OPCODE = (60u &lt;&lt; OPCODE_SHIFT |   18u &lt;&lt; 3),
 527     XXMRGLW_OPCODE = (60u &lt;&lt; OPCODE_SHIFT |   50u &lt;&lt; 3),
 528     XXSPLTW_OPCODE = (60u &lt;&lt; OPCODE_SHIFT |  164u &lt;&lt; 2),
 529     XXLOR_OPCODE   = (60u &lt;&lt; OPCODE_SHIFT |  146u &lt;&lt; 3),
 530     XXLXOR_OPCODE  = (60u &lt;&lt; OPCODE_SHIFT |  154u &lt;&lt; 3),
 531     XXLEQV_OPCODE  = (60u &lt;&lt; OPCODE_SHIFT |  186u &lt;&lt; 3),
 532     XVDIVSP_OPCODE = (60u &lt;&lt; OPCODE_SHIFT |   88u &lt;&lt; 3),
 533     XXBRD_OPCODE   = (60u &lt;&lt; OPCODE_SHIFT |  475u &lt;&lt; 2 | 23u &lt;&lt; 16), // XX2-FORM
 534     XXBRW_OPCODE   = (60u &lt;&lt; OPCODE_SHIFT |  475u &lt;&lt; 2 | 15u &lt;&lt; 16), // XX2-FORM
 535     XVDIVDP_OPCODE = (60u &lt;&lt; OPCODE_SHIFT |  120u &lt;&lt; 3),
 536     XVABSSP_OPCODE = (60u &lt;&lt; OPCODE_SHIFT |  409u &lt;&lt; 2),
 537     XVABSDP_OPCODE = (60u &lt;&lt; OPCODE_SHIFT |  473u &lt;&lt; 2),
 538     XVNEGSP_OPCODE = (60u &lt;&lt; OPCODE_SHIFT |  441u &lt;&lt; 2),
 539     XVNEGDP_OPCODE = (60u &lt;&lt; OPCODE_SHIFT |  505u &lt;&lt; 2),
 540     XVSQRTSP_OPCODE= (60u &lt;&lt; OPCODE_SHIFT |  139u &lt;&lt; 2),
 541     XVSQRTDP_OPCODE= (60u &lt;&lt; OPCODE_SHIFT |  203u &lt;&lt; 2),
 542     XSCVDPSPN_OPCODE=(60u &lt;&lt; OPCODE_SHIFT |  267u &lt;&lt; 2),
 543     XVADDDP_OPCODE = (60u &lt;&lt; OPCODE_SHIFT |   96u &lt;&lt; 3),
 544     XVSUBDP_OPCODE = (60u &lt;&lt; OPCODE_SHIFT |  104u &lt;&lt; 3),
 545     XVMULSP_OPCODE = (60u &lt;&lt; OPCODE_SHIFT |   80u &lt;&lt; 3),
 546     XVMULDP_OPCODE = (60u &lt;&lt; OPCODE_SHIFT |  112u &lt;&lt; 3),
 547     XVMADDASP_OPCODE=(60u &lt;&lt; OPCODE_SHIFT |   65u &lt;&lt; 3),
 548     XVMADDADP_OPCODE=(60u &lt;&lt; OPCODE_SHIFT |   97u &lt;&lt; 3),
 549     XVMSUBASP_OPCODE=(60u &lt;&lt; OPCODE_SHIFT |   81u &lt;&lt; 3),
 550     XVMSUBADP_OPCODE=(60u &lt;&lt; OPCODE_SHIFT |  113u &lt;&lt; 3),
 551     XVNMSUBASP_OPCODE=(60u&lt;&lt; OPCODE_SHIFT |  209u &lt;&lt; 3),
 552     XVNMSUBADP_OPCODE=(60u&lt;&lt; OPCODE_SHIFT |  241u &lt;&lt; 3),
 553     XVRDPI_OPCODE  = (60u &lt;&lt; OPCODE_SHIFT |  201u &lt;&lt; 2),
 554     XVRDPIM_OPCODE = (60u &lt;&lt; OPCODE_SHIFT |  249u &lt;&lt; 2),
 555     XVRDPIP_OPCODE = (60u &lt;&lt; OPCODE_SHIFT |  233u &lt;&lt; 2),
 556 
 557     // Deliver A Random Number (introduced with POWER9)
 558     DARN_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  755u &lt;&lt; 1),
 559 
 560     // Vector Permute and Formatting
 561     VPKPX_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT |  782u     ),
 562     VPKSHSS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  398u     ),
 563     VPKSWSS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  462u     ),
 564     VPKSHUS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  270u     ),
 565     VPKSWUS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  334u     ),
 566     VPKUHUM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |   14u     ),
 567     VPKUWUM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |   78u     ),
 568     VPKUHUS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  142u     ),
 569     VPKUWUS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  206u     ),
 570     VUPKHPX_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  846u     ),
 571     VUPKHSB_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  526u     ),
 572     VUPKHSH_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  590u     ),
 573     VUPKLPX_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  974u     ),
 574     VUPKLSB_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  654u     ),
 575     VUPKLSH_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  718u     ),
 576 
 577     VMRGHB_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |   12u     ),
 578     VMRGHW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  140u     ),
 579     VMRGHH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |   76u     ),
 580     VMRGLB_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  268u     ),
 581     VMRGLW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  396u     ),
 582     VMRGLH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  332u     ),
 583 
 584     VSPLT_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT |  524u     ),
 585     VSPLTH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  588u     ),
 586     VSPLTW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  652u     ),
 587     VSPLTISB_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  780u     ),
 588     VSPLTISH_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  844u     ),
 589     VSPLTISW_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  908u     ),
 590 
 591     VPERM_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT |   43u     ),
 592     VSEL_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |   42u     ),
 593 
 594     VSL_OPCODE     = (4u  &lt;&lt; OPCODE_SHIFT |  452u     ),
 595     VSLDOI_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |   44u     ),
 596     VSLO_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT | 1036u     ),
 597     VSR_OPCODE     = (4u  &lt;&lt; OPCODE_SHIFT |  708u     ),
 598     VSRO_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT | 1100u     ),
 599 
 600     // Vector Integer
 601     VADDCUW_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  384u     ),
 602     VADDSHS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  832u     ),
 603     VADDSBS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  768u     ),
 604     VADDSWS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  896u     ),
 605     VADDUBM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |    0u     ),
 606     VADDUWM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  128u     ),
 607     VADDUHM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |   64u     ),
 608     VADDUDM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  192u     ),
 609     VADDUBS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  512u     ),
 610     VADDUWS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  640u     ),
 611     VADDUHS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  576u     ),
 612     VADDFP_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |   10u     ),
 613     VSUBCUW_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1408u     ),
 614     VSUBSHS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1856u     ),
 615     VSUBSBS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1792u     ),
 616     VSUBSWS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1920u     ),
 617     VSUBUBM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1024u     ),
 618     VSUBUWM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1152u     ),
 619     VSUBUHM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1088u     ),
 620     VSUBUDM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1216u     ),
 621     VSUBUBS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1536u     ),
 622     VSUBUWS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1664u     ),
 623     VSUBUHS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1600u     ),
 624     VSUBFP_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |   74u     ),
 625 
 626     VMULESB_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  776u     ),
 627     VMULEUB_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  520u     ),
 628     VMULESH_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  840u     ),
 629     VMULEUH_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  584u     ),
 630     VMULOSB_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  264u     ),
 631     VMULOUB_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |    8u     ),
 632     VMULOSH_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  328u     ),
 633     VMULOSW_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  392u     ),
 634     VMULOUH_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |   72u     ),
 635     VMULUWM_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |  137u     ),
 636     VMHADDSHS_OPCODE=(4u  &lt;&lt; OPCODE_SHIFT |   32u     ),
 637     VMHRADDSHS_OPCODE=(4u &lt;&lt; OPCODE_SHIFT |   33u     ),
 638     VMLADDUHM_OPCODE=(4u  &lt;&lt; OPCODE_SHIFT |   34u     ),
 639     VMSUBUHM_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |   36u     ),
 640     VMSUMMBM_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |   37u     ),
 641     VMSUMSHM_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |   40u     ),
 642     VMSUMSHS_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |   41u     ),
 643     VMSUMUHM_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |   38u     ),
 644     VMSUMUHS_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |   39u     ),
 645     VMADDFP_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT |   46u     ),
 646 
 647     VSUMSWS_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1928u     ),
 648     VSUM2SWS_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT | 1672u     ),
 649     VSUM4SBS_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT | 1800u     ),
 650     VSUM4UBS_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT | 1544u     ),
 651     VSUM4SHS_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT | 1608u     ),
 652 
 653     VAVGSB_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1282u     ),
 654     VAVGSW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1410u     ),
 655     VAVGSH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1346u     ),
 656     VAVGUB_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1026u     ),
 657     VAVGUW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1154u     ),
 658     VAVGUH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1090u     ),
 659 
 660     VMAXSB_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  258u     ),
 661     VMAXSW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  386u     ),
 662     VMAXSH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  322u     ),
 663     VMAXUB_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |    2u     ),
 664     VMAXUW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  130u     ),
 665     VMAXUH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |   66u     ),
 666     VMINSB_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  770u     ),
 667     VMINSW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  898u     ),
 668     VMINSH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  834u     ),
 669     VMINUB_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  514u     ),
 670     VMINUW_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  642u     ),
 671     VMINUH_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT |  578u     ),
 672 
 673     VCMPEQUB_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |    6u     ),
 674     VCMPEQUH_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |   70u     ),
 675     VCMPEQUW_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  134u     ),
 676     VCMPGTSH_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  838u     ),
 677     VCMPGTSB_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  774u     ),
 678     VCMPGTSW_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  902u     ),
 679     VCMPGTUB_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  518u     ),
 680     VCMPGTUH_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  582u     ),
 681     VCMPGTUW_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT |  646u     ),
 682 
 683     VAND_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT | 1028u     ),
 684     VANDC_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT | 1092u     ),
 685     VNOR_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT | 1284u     ),
 686     VOR_OPCODE     = (4u  &lt;&lt; OPCODE_SHIFT | 1156u     ),
 687     VXOR_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT | 1220u     ),
 688     VRLD_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |  196u     ),
 689     VRLB_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |    4u     ),
 690     VRLW_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |  132u     ),
 691     VRLH_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |   68u     ),
 692     VSLB_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |  260u     ),
 693     VSKW_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |  388u     ),
 694     VSLH_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |  324u     ),
 695     VSRB_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |  516u     ),
 696     VSRW_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |  644u     ),
 697     VSRH_OPCODE    = (4u  &lt;&lt; OPCODE_SHIFT |  580u     ),
 698     VSRAB_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT |  772u     ),
 699     VSRAW_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT |  900u     ),
 700     VSRAH_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT |  836u     ),
 701     VPOPCNTW_OPCODE= (4u  &lt;&lt; OPCODE_SHIFT | 1923u     ),
 702 
 703     // Vector Floating-Point
 704     // not implemented yet
 705 
 706     // Vector Status and Control
 707     MTVSCR_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1604u     ),
 708     MFVSCR_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1540u     ),
 709 
 710     // AES (introduced with Power 8)
 711     VCIPHER_OPCODE      = (4u  &lt;&lt; OPCODE_SHIFT | 1288u),
 712     VCIPHERLAST_OPCODE  = (4u  &lt;&lt; OPCODE_SHIFT | 1289u),
 713     VNCIPHER_OPCODE     = (4u  &lt;&lt; OPCODE_SHIFT | 1352u),
 714     VNCIPHERLAST_OPCODE = (4u  &lt;&lt; OPCODE_SHIFT | 1353u),
 715     VSBOX_OPCODE        = (4u  &lt;&lt; OPCODE_SHIFT | 1480u),
 716 
 717     // SHA (introduced with Power 8)
 718     VSHASIGMAD_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT | 1730u),
 719     VSHASIGMAW_OPCODE   = (4u  &lt;&lt; OPCODE_SHIFT | 1666u),
 720 
 721     // Vector Binary Polynomial Multiplication (introduced with Power 8)
 722     VPMSUMB_OPCODE      = (4u  &lt;&lt; OPCODE_SHIFT | 1032u),
 723     VPMSUMD_OPCODE      = (4u  &lt;&lt; OPCODE_SHIFT | 1224u),
 724     VPMSUMH_OPCODE      = (4u  &lt;&lt; OPCODE_SHIFT | 1096u),
 725     VPMSUMW_OPCODE      = (4u  &lt;&lt; OPCODE_SHIFT | 1160u),
 726 
 727     // Vector Permute and Xor (introduced with Power 8)
 728     VPERMXOR_OPCODE     = (4u  &lt;&lt; OPCODE_SHIFT |   45u),
 729 
 730     // Transactional Memory instructions (introduced with Power 8)
 731     TBEGIN_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  654u &lt;&lt; 1),
 732     TEND_OPCODE      = (31u &lt;&lt; OPCODE_SHIFT |  686u &lt;&lt; 1),
 733     TABORT_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  910u &lt;&lt; 1),
 734     TABORTWC_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  782u &lt;&lt; 1),
 735     TABORTWCI_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  846u &lt;&lt; 1),
 736     TABORTDC_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  814u &lt;&lt; 1),
 737     TABORTDCI_OPCODE = (31u &lt;&lt; OPCODE_SHIFT |  878u &lt;&lt; 1),
 738     TSR_OPCODE       = (31u &lt;&lt; OPCODE_SHIFT |  750u &lt;&lt; 1),
 739     TCHECK_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  718u &lt;&lt; 1),
 740 
 741     // Icache and dcache related instructions
 742     DCBA_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  758u &lt;&lt; 1),
 743     DCBZ_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT | 1014u &lt;&lt; 1),
 744     DCBST_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |   54u &lt;&lt; 1),
 745     DCBF_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |   86u &lt;&lt; 1),
 746 
 747     DCBT_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  278u &lt;&lt; 1),
 748     DCBTST_OPCODE  = (31u &lt;&lt; OPCODE_SHIFT |  246u &lt;&lt; 1),
 749     ICBI_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  982u &lt;&lt; 1),
 750 
 751     // Instruction synchronization
 752     ISYNC_OPCODE   = (19u &lt;&lt; OPCODE_SHIFT |  150u &lt;&lt; 1),
 753     // Memory barriers
 754     SYNC_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |  598u &lt;&lt; 1),
 755     EIEIO_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  854u &lt;&lt; 1),
 756 
 757     // Wait instructions for polling.
 758     WAIT_OPCODE    = (31u &lt;&lt; OPCODE_SHIFT |   62u &lt;&lt; 1),
 759 
 760     // Trap instructions
 761     TDI_OPCODE     = (2u  &lt;&lt; OPCODE_SHIFT),
 762     TWI_OPCODE     = (3u  &lt;&lt; OPCODE_SHIFT),
 763     TD_OPCODE      = (31u &lt;&lt; OPCODE_SHIFT |   68u &lt;&lt; 1),
 764     TW_OPCODE      = (31u &lt;&lt; OPCODE_SHIFT |    4u &lt;&lt; 1),
 765 
 766     // Atomics.
 767     LBARX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |   52u &lt;&lt; 1),
 768     LHARX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  116u &lt;&lt; 1),
 769     LWARX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |   20u &lt;&lt; 1),
 770     LDARX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |   84u &lt;&lt; 1),
 771     LQARX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  276u &lt;&lt; 1),
 772     STBCX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  694u &lt;&lt; 1),
 773     STHCX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  726u &lt;&lt; 1),
 774     STWCX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  150u &lt;&lt; 1),
 775     STDCX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  214u &lt;&lt; 1),
 776     STQCX_OPCODE   = (31u &lt;&lt; OPCODE_SHIFT |  182u &lt;&lt; 1)
 777 
 778   };
 779 
 780   // Trap instructions TO bits
 781   enum trap_to_bits {
 782     // single bits
 783     traptoLessThanSigned      = 1 &lt;&lt; 4, // 0, left end
 784     traptoGreaterThanSigned   = 1 &lt;&lt; 3,
 785     traptoEqual               = 1 &lt;&lt; 2,
 786     traptoLessThanUnsigned    = 1 &lt;&lt; 1,
 787     traptoGreaterThanUnsigned = 1 &lt;&lt; 0, // 4, right end
 788 
 789     // compound ones
 790     traptoUnconditional       = (traptoLessThanSigned |
 791                                  traptoGreaterThanSigned |
 792                                  traptoEqual |
 793                                  traptoLessThanUnsigned |
 794                                  traptoGreaterThanUnsigned)
 795   };
 796 
 797   // Branch hints BH field
 798   enum branch_hint_bh {
 799     // bclr cases:
 800     bhintbhBCLRisReturn            = 0,
 801     bhintbhBCLRisNotReturnButSame  = 1,
 802     bhintbhBCLRisNotPredictable    = 3,
 803 
 804     // bcctr cases:
 805     bhintbhBCCTRisNotReturnButSame = 0,
 806     bhintbhBCCTRisNotPredictable   = 3
 807   };
 808 
 809   // Branch prediction hints AT field
 810   enum branch_hint_at {
 811     bhintatNoHint     = 0,  // at=00
 812     bhintatIsNotTaken = 2,  // at=10
 813     bhintatIsTaken    = 3   // at=11
 814   };
 815 
 816   // Branch prediction hints
 817   enum branch_hint_concept {
 818     // Use the same encoding as branch_hint_at to simply code.
 819     bhintNoHint       = bhintatNoHint,
 820     bhintIsNotTaken   = bhintatIsNotTaken,
 821     bhintIsTaken      = bhintatIsTaken
 822   };
 823 
 824   // Used in BO field of branch instruction.
 825   enum branch_condition {
 826     bcondCRbiIs0      =  4, // bo=001at
 827     bcondCRbiIs1      = 12, // bo=011at
 828     bcondAlways       = 20  // bo=10100
 829   };
 830 
 831   // Branch condition with combined prediction hints.
 832   enum branch_condition_with_hint {
 833     bcondCRbiIs0_bhintNoHint     = bcondCRbiIs0 | bhintatNoHint,
 834     bcondCRbiIs0_bhintIsNotTaken = bcondCRbiIs0 | bhintatIsNotTaken,
 835     bcondCRbiIs0_bhintIsTaken    = bcondCRbiIs0 | bhintatIsTaken,
 836     bcondCRbiIs1_bhintNoHint     = bcondCRbiIs1 | bhintatNoHint,
 837     bcondCRbiIs1_bhintIsNotTaken = bcondCRbiIs1 | bhintatIsNotTaken,
 838     bcondCRbiIs1_bhintIsTaken    = bcondCRbiIs1 | bhintatIsTaken,
 839   };
 840 
 841   // Elemental Memory Barriers (&gt;=Power 8)
 842   enum Elemental_Membar_mask_bits {
 843     StoreStore = 1 &lt;&lt; 0,
 844     StoreLoad  = 1 &lt;&lt; 1,
 845     LoadStore  = 1 &lt;&lt; 2,
 846     LoadLoad   = 1 &lt;&lt; 3
 847   };
 848 
 849   // Branch prediction hints.
 850   inline static int add_bhint_to_boint(const int bhint, const int boint) {
 851     switch (boint) {
 852       case bcondCRbiIs0:
 853       case bcondCRbiIs1:
 854         // branch_hint and branch_hint_at have same encodings
 855         assert(   (int)bhintNoHint     == (int)bhintatNoHint
 856                &amp;&amp; (int)bhintIsNotTaken == (int)bhintatIsNotTaken
 857                &amp;&amp; (int)bhintIsTaken    == (int)bhintatIsTaken,
 858                &quot;wrong encodings&quot;);
 859         assert((bhint &amp; 0x03) == bhint, &quot;wrong encodings&quot;);
 860         return (boint &amp; ~0x03) | bhint;
 861       case bcondAlways:
 862         // no branch_hint
 863         return boint;
 864       default:
 865         ShouldNotReachHere();
 866         return 0;
 867     }
 868   }
 869 
 870   // Extract bcond from boint.
 871   inline static int inv_boint_bcond(const int boint) {
 872     int r_bcond = boint &amp; ~0x03;
 873     assert(r_bcond == bcondCRbiIs0 ||
 874            r_bcond == bcondCRbiIs1 ||
 875            r_bcond == bcondAlways,
 876            &quot;bad branch condition&quot;);
 877     return r_bcond;
 878   }
 879 
 880   // Extract bhint from boint.
 881   inline static int inv_boint_bhint(const int boint) {
 882     int r_bhint = boint &amp; 0x03;
 883     assert(r_bhint == bhintatNoHint ||
 884            r_bhint == bhintatIsNotTaken ||
 885            r_bhint == bhintatIsTaken,
 886            &quot;bad branch hint&quot;);
 887     return r_bhint;
 888   }
 889 
 890   // Calculate opposite of given bcond.
 891   inline static int opposite_bcond(const int bcond) {
 892     switch (bcond) {
 893       case bcondCRbiIs0:
 894         return bcondCRbiIs1;
 895       case bcondCRbiIs1:
 896         return bcondCRbiIs0;
 897       default:
 898         ShouldNotReachHere();
 899         return 0;
 900     }
 901   }
 902 
 903   // Calculate opposite of given bhint.
 904   inline static int opposite_bhint(const int bhint) {
 905     switch (bhint) {
 906       case bhintatNoHint:
 907         return bhintatNoHint;
 908       case bhintatIsNotTaken:
 909         return bhintatIsTaken;
 910       case bhintatIsTaken:
 911         return bhintatIsNotTaken;
 912       default:
 913         ShouldNotReachHere();
 914         return 0;
 915     }
 916   }
 917 
 918   // PPC branch instructions
 919   enum ppcops {
 920     b_op    = 18,
 921     bc_op   = 16,
 922     bcr_op  = 19
 923   };
 924 
 925   enum Condition {
 926     negative         = 0,
 927     less             = 0,
 928     positive         = 1,
 929     greater          = 1,
 930     zero             = 2,
 931     equal            = 2,
 932     summary_overflow = 3,
 933   };
 934 
 935  public:
 936   // Helper functions for groups of instructions
 937 
 938   enum Predict { pt = 1, pn = 0 }; // pt = predict taken
 939 
 940   //---&lt;  calculate length of instruction  &gt;---
 941   // With PPC64 being a RISC architecture, this always is BytesPerInstWord
 942   // instruction must start at passed address
 943   static unsigned int instr_len(unsigned char *instr) { return BytesPerInstWord; }
 944 
 945   //---&lt;  longest instructions  &gt;---
 946   static unsigned int instr_maxlen() { return BytesPerInstWord; }
 947 
 948   // Test if x is within signed immediate range for nbits.
 949   static bool is_simm(int x, unsigned int nbits) {
 950     assert(0 &lt; nbits &amp;&amp; nbits &lt; 32, &quot;out of bounds&quot;);
 951     const int   min      = -(((int)1) &lt;&lt; nbits-1);
 952     const int   maxplus1 =  (((int)1) &lt;&lt; nbits-1);
 953     return min &lt;= x &amp;&amp; x &lt; maxplus1;
 954   }
 955 
 956   static bool is_simm(jlong x, unsigned int nbits) {
 957     assert(0 &lt; nbits &amp;&amp; nbits &lt; 64, &quot;out of bounds&quot;);
 958     const jlong min      = -(((jlong)1) &lt;&lt; nbits-1);
 959     const jlong maxplus1 =  (((jlong)1) &lt;&lt; nbits-1);
 960     return min &lt;= x &amp;&amp; x &lt; maxplus1;
 961   }
 962 
 963   // Test if x is within unsigned immediate range for nbits.
 964   static bool is_uimm(int x, unsigned int nbits) {
 965     assert(0 &lt; nbits &amp;&amp; nbits &lt; 32, &quot;out of bounds&quot;);
 966     const unsigned int maxplus1 = (((unsigned int)1) &lt;&lt; nbits);
 967     return (unsigned int)x &lt; maxplus1;
 968   }
 969 
 970   static bool is_uimm(jlong x, unsigned int nbits) {
 971     assert(0 &lt; nbits &amp;&amp; nbits &lt; 64, &quot;out of bounds&quot;);
 972     const julong maxplus1 = (((julong)1) &lt;&lt; nbits);
 973     return (julong)x &lt; maxplus1;
 974   }
 975 
 976  protected:
 977   // helpers
 978 
 979   // X is supposed to fit in a field &quot;nbits&quot; wide
 980   // and be sign-extended. Check the range.
 981   static void assert_signed_range(intptr_t x, int nbits) {
 982     assert(nbits == 32 || (-(1 &lt;&lt; nbits-1) &lt;= x &amp;&amp; x &lt; (1 &lt;&lt; nbits-1)),
 983            &quot;value out of range&quot;);
 984   }
 985 
 986   static void assert_signed_word_disp_range(intptr_t x, int nbits) {
 987     assert((x &amp; 3) == 0, &quot;not word aligned&quot;);
 988     assert_signed_range(x, nbits + 2);
 989   }
 990 
 991   static void assert_unsigned_const(int x, int nbits) {
 992     assert(juint(x) &lt; juint(1 &lt;&lt; nbits), &quot;unsigned constant out of range&quot;);
 993   }
 994 
 995   static int fmask(juint hi_bit, juint lo_bit) {
 996     assert(hi_bit &gt;= lo_bit &amp;&amp; hi_bit &lt; 32, &quot;bad bits&quot;);
 997     return (1 &lt;&lt; ( hi_bit-lo_bit + 1 )) - 1;
 998   }
 999 
1000   // inverse of u_field
1001   static int inv_u_field(int x, int hi_bit, int lo_bit) {
1002     juint r = juint(x) &gt;&gt; lo_bit;
1003     r &amp;= fmask(hi_bit, lo_bit);
1004     return int(r);
1005   }
1006 
1007   // signed version: extract from field and sign-extend
1008   static int inv_s_field_ppc(int x, int hi_bit, int lo_bit) {
1009     x = x &lt;&lt; (31-hi_bit);
1010     x = x &gt;&gt; (31-hi_bit+lo_bit);
1011     return x;
1012   }
1013 
1014   static int u_field(int x, int hi_bit, int lo_bit) {
1015     assert((x &amp; ~fmask(hi_bit, lo_bit)) == 0, &quot;value out of range&quot;);
1016     int r = x &lt;&lt; lo_bit;
1017     assert(inv_u_field(r, hi_bit, lo_bit) == x, &quot;just checking&quot;);
1018     return r;
1019   }
1020 
1021   // Same as u_field for signed values
1022   static int s_field(int x, int hi_bit, int lo_bit) {
1023     int nbits = hi_bit - lo_bit + 1;
1024     assert(nbits == 32 || (-(1 &lt;&lt; nbits-1) &lt;= x &amp;&amp; x &lt; (1 &lt;&lt; nbits-1)),
1025       &quot;value out of range&quot;);
1026     x &amp;= fmask(hi_bit, lo_bit);
1027     int r = x &lt;&lt; lo_bit;
1028     return r;
1029   }
1030 
1031   // inv_op for ppc instructions
1032   static int inv_op_ppc(int x) { return inv_u_field(x, 31, 26); }
1033 
1034   // Determine target address from li, bd field of branch instruction.
1035   static intptr_t inv_li_field(int x) {
1036     intptr_t r = inv_s_field_ppc(x, 25, 2);
1037     r = (r &lt;&lt; 2);
1038     return r;
1039   }
1040   static intptr_t inv_bd_field(int x, intptr_t pos) {
1041     intptr_t r = inv_s_field_ppc(x, 15, 2);
1042     r = (r &lt;&lt; 2) + pos;
1043     return r;
1044   }
1045 
1046   #define inv_opp_u_field(x, hi_bit, lo_bit) inv_u_field(x, 31-(lo_bit), 31-(hi_bit))
1047   #define inv_opp_s_field(x, hi_bit, lo_bit) inv_s_field_ppc(x, 31-(lo_bit), 31-(hi_bit))
1048   // Extract instruction fields from instruction words.
1049  public:
1050   static int inv_ra_field(int x)  { return inv_opp_u_field(x, 15, 11); }
1051   static int inv_rb_field(int x)  { return inv_opp_u_field(x, 20, 16); }
1052   static int inv_rt_field(int x)  { return inv_opp_u_field(x, 10,  6); }
1053   static int inv_rta_field(int x) { return inv_opp_u_field(x, 15, 11); }
1054   static int inv_rs_field(int x)  { return inv_opp_u_field(x, 10,  6); }
1055   // Ds uses opp_s_field(x, 31, 16), but lowest 2 bits must be 0.
1056   // Inv_ds_field uses range (x, 29, 16) but shifts by 2 to ensure that lowest bits are 0.
1057   static int inv_ds_field(int x)  { return inv_opp_s_field(x, 29, 16) &lt;&lt; 2; }
1058   static int inv_d1_field(int x)  { return inv_opp_s_field(x, 31, 16); }
1059   static int inv_si_field(int x)  { return inv_opp_s_field(x, 31, 16); }
1060   static int inv_to_field(int x)  { return inv_opp_u_field(x, 10, 6);  }
1061   static int inv_lk_field(int x)  { return inv_opp_u_field(x, 31, 31); }
1062   static int inv_bo_field(int x)  { return inv_opp_u_field(x, 10,  6); }
1063   static int inv_bi_field(int x)  { return inv_opp_u_field(x, 15, 11); }
1064 
1065   #define opp_u_field(x, hi_bit, lo_bit) u_field(x, 31-(lo_bit), 31-(hi_bit))
1066   #define opp_s_field(x, hi_bit, lo_bit) s_field(x, 31-(lo_bit), 31-(hi_bit))
1067 
1068   // instruction fields
1069   static int aa(       int         x)  { return  opp_u_field(x,             30, 30); }
1070   static int ba(       int         x)  { return  opp_u_field(x,             15, 11); }
1071   static int bb(       int         x)  { return  opp_u_field(x,             20, 16); }
1072   static int bc(       int         x)  { return  opp_u_field(x,             25, 21); }
1073   static int bd(       int         x)  { return  opp_s_field(x,             29, 16); }
1074   static int bf( ConditionRegister cr) { return  bf(cr-&gt;encoding()); }
1075   static int bf(       int         x)  { return  opp_u_field(x,              8,  6); }
1076   static int bfa(ConditionRegister cr) { return  bfa(cr-&gt;encoding()); }
1077   static int bfa(      int         x)  { return  opp_u_field(x,             13, 11); }
1078   static int bh(       int         x)  { return  opp_u_field(x,             20, 19); }
1079   static int bi(       int         x)  { return  opp_u_field(x,             15, 11); }
1080   static int bi0(ConditionRegister cr, Condition c) { return (cr-&gt;encoding() &lt;&lt; 2) | c; }
1081   static int bo(       int         x)  { return  opp_u_field(x,             10,  6); }
1082   static int bt(       int         x)  { return  opp_u_field(x,             10,  6); }
1083   static int d1(       int         x)  { return  opp_s_field(x,             31, 16); }
1084   static int ds(       int         x)  { assert((x &amp; 0x3) == 0, &quot;unaligned offset&quot;); return opp_s_field(x, 31, 16); }
1085   static int eh(       int         x)  { return  opp_u_field(x,             31, 31); }
1086   static int flm(      int         x)  { return  opp_u_field(x,             14,  7); }
1087   static int fra(    FloatRegister r)  { return  fra(r-&gt;encoding());}
1088   static int frb(    FloatRegister r)  { return  frb(r-&gt;encoding());}
1089   static int frc(    FloatRegister r)  { return  frc(r-&gt;encoding());}
1090   static int frs(    FloatRegister r)  { return  frs(r-&gt;encoding());}
1091   static int frt(    FloatRegister r)  { return  frt(r-&gt;encoding());}
1092   static int fra(      int         x)  { return  opp_u_field(x,             15, 11); }
1093   static int frb(      int         x)  { return  opp_u_field(x,             20, 16); }
1094   static int frc(      int         x)  { return  opp_u_field(x,             25, 21); }
1095   static int frs(      int         x)  { return  opp_u_field(x,             10,  6); }
1096   static int frt(      int         x)  { return  opp_u_field(x,             10,  6); }
1097   static int fxm(      int         x)  { return  opp_u_field(x,             19, 12); }
1098   static int l10(      int         x)  { assert(x == 0 || x == 1,  &quot;must be 0 or 1&quot;); return opp_u_field(x, 10, 10); }
1099   static int l14(      int         x)  { return  opp_u_field(x,             15, 14); }
1100   static int l15(      int         x)  { return  opp_u_field(x,             15, 15); }
1101   static int l910(     int         x)  { return  opp_u_field(x,             10,  9); }
1102   static int e1215(    int         x)  { return  opp_u_field(x,             15, 12); }
1103   static int lev(      int         x)  { return  opp_u_field(x,             26, 20); }
1104   static int li(       int         x)  { return  opp_s_field(x,             29,  6); }
1105   static int lk(       int         x)  { return  opp_u_field(x,             31, 31); }
1106   static int mb2125(   int         x)  { return  opp_u_field(x,             25, 21); }
1107   static int me2630(   int         x)  { return  opp_u_field(x,             30, 26); }
1108   static int mb2126(   int         x)  { return  opp_u_field(((x &amp; 0x1f) &lt;&lt; 1) | ((x &amp; 0x20) &gt;&gt; 5), 26, 21); }
1109   static int me2126(   int         x)  { return  mb2126(x); }
1110   static int nb(       int         x)  { return  opp_u_field(x,             20, 16); }
1111   //static int opcd(   int         x)  { return  opp_u_field(x,              5,  0); } // is contained in our opcodes
1112   static int oe(       int         x)  { return  opp_u_field(x,             21, 21); }
1113   static int ra(       Register    r)  { return  ra(r-&gt;encoding()); }
1114   static int ra(       int         x)  { return  opp_u_field(x,             15, 11); }
1115   static int rb(       Register    r)  { return  rb(r-&gt;encoding()); }
1116   static int rb(       int         x)  { return  opp_u_field(x,             20, 16); }
1117   static int rc(       int         x)  { return  opp_u_field(x,             31, 31); }
1118   static int rs(       Register    r)  { return  rs(r-&gt;encoding()); }
1119   static int rs(       int         x)  { return  opp_u_field(x,             10,  6); }
1120   // we don&#39;t want to use R0 in memory accesses, because it has value `0&#39; then
1121   static int ra0mem(   Register    r)  { assert(r != R0, &quot;cannot use register R0 in memory access&quot;); return ra(r); }
1122   static int ra0mem(   int         x)  { assert(x != 0,  &quot;cannot use register 0 in memory access&quot;);  return ra(x); }
1123 
1124   // register r is target
1125   static int rt(       Register    r)  { return rs(r); }
1126   static int rt(       int         x)  { return rs(x); }
1127   static int rta(      Register    r)  { return ra(r); }
1128   static int rta0mem(  Register    r)  { rta(r); return ra0mem(r); }
1129 
1130   static int sh1620(   int         x)  { return  opp_u_field(x,             20, 16); }
1131   static int sh30(     int         x)  { return  opp_u_field(x,             30, 30); }
1132   static int sh162030( int         x)  { return  sh1620(x &amp; 0x1f) | sh30((x &amp; 0x20) &gt;&gt; 5); }
1133   static int si(       int         x)  { return  opp_s_field(x,             31, 16); }
1134   static int spr(      int         x)  { return  opp_u_field(x,             20, 11); }
1135   static int sr(       int         x)  { return  opp_u_field(x,             15, 12); }
1136   static int tbr(      int         x)  { return  opp_u_field(x,             20, 11); }
1137   static int th(       int         x)  { return  opp_u_field(x,             10,  7); }
1138   static int thct(     int         x)  { assert((x&amp;8) == 0, &quot;must be valid cache specification&quot;);  return th(x); }
1139   static int thds(     int         x)  { assert((x&amp;8) == 8, &quot;must be valid stream specification&quot;); return th(x); }
1140   static int to(       int         x)  { return  opp_u_field(x,             10,  6); }
1141   static int u(        int         x)  { return  opp_u_field(x,             19, 16); }
1142   static int ui(       int         x)  { return  opp_u_field(x,             31, 16); }
1143 
1144   // Support vector instructions for &gt;= Power6.
1145   static int vra(      int         x)  { return  opp_u_field(x,             15, 11); }
1146   static int vrb(      int         x)  { return  opp_u_field(x,             20, 16); }
1147   static int vrc(      int         x)  { return  opp_u_field(x,             25, 21); }
1148   static int vrs(      int         x)  { return  opp_u_field(x,             10,  6); }
1149   static int vrt(      int         x)  { return  opp_u_field(x,             10,  6); }
1150 
1151   static int vra(   VectorRegister r)  { return  vra(r-&gt;encoding());}
1152   static int vrb(   VectorRegister r)  { return  vrb(r-&gt;encoding());}
1153   static int vrc(   VectorRegister r)  { return  vrc(r-&gt;encoding());}
1154   static int vrs(   VectorRegister r)  { return  vrs(r-&gt;encoding());}
1155   static int vrt(   VectorRegister r)  { return  vrt(r-&gt;encoding());}
1156 
1157   // Only used on SHA sigma instructions (VX-form)
1158   static int vst(      int         x)  { return  opp_u_field(x,             16, 16); }
1159   static int vsix(     int         x)  { return  opp_u_field(x,             20, 17); }
1160 
1161   // Support Vector-Scalar (VSX) instructions.
1162   static int vsra(      int         x)  { return  opp_u_field(x &amp; 0x1F,     15, 11) | opp_u_field((x &amp; 0x20) &gt;&gt; 5, 29, 29); }
1163   static int vsrb(      int         x)  { return  opp_u_field(x &amp; 0x1F,     20, 16) | opp_u_field((x &amp; 0x20) &gt;&gt; 5, 30, 30); }
1164   static int vsrs(      int         x)  { return  opp_u_field(x &amp; 0x1F,     10,  6) | opp_u_field((x &amp; 0x20) &gt;&gt; 5, 31, 31); }
1165   static int vsrt(      int         x)  { return  vsrs(x); }
1166   static int vsdm(      int         x)  { return  opp_u_field(x,            23, 22); }
1167 
1168   static int vsra(   VectorSRegister r)  { return  vsra(r-&gt;encoding());}
1169   static int vsrb(   VectorSRegister r)  { return  vsrb(r-&gt;encoding());}
1170   static int vsrs(   VectorSRegister r)  { return  vsrs(r-&gt;encoding());}
1171   static int vsrt(   VectorSRegister r)  { return  vsrt(r-&gt;encoding());}
1172 
1173   static int vsplt_uim( int        x)  { return  opp_u_field(x,             15, 12); } // for vsplt* instructions
1174   static int vsplti_sim(int        x)  { return  opp_u_field(x,             15, 11); } // for vsplti* instructions
1175   static int vsldoi_shb(int        x)  { return  opp_u_field(x,             25, 22); } // for vsldoi instruction
1176   static int vcmp_rc(   int        x)  { return  opp_u_field(x,             21, 21); } // for vcmp* instructions
1177   static int xxsplt_uim(int        x)  { return  opp_u_field(x,             15, 14); } // for xxsplt* instructions
1178 
1179   //static int xo1(     int        x)  { return  opp_u_field(x,             29, 21); }// is contained in our opcodes
1180   //static int xo2(     int        x)  { return  opp_u_field(x,             30, 21); }// is contained in our opcodes
1181   //static int xo3(     int        x)  { return  opp_u_field(x,             30, 22); }// is contained in our opcodes
1182   //static int xo4(     int        x)  { return  opp_u_field(x,             30, 26); }// is contained in our opcodes
1183   //static int xo5(     int        x)  { return  opp_u_field(x,             29, 27); }// is contained in our opcodes
1184   //static int xo6(     int        x)  { return  opp_u_field(x,             30, 27); }// is contained in our opcodes
1185   //static int xo7(     int        x)  { return  opp_u_field(x,             31, 30); }// is contained in our opcodes
1186 
1187  protected:
1188   // Compute relative address for branch.
1189   static intptr_t disp(intptr_t x, intptr_t off) {
1190     int xx = x - off;
1191     xx = xx &gt;&gt; 2;
1192     return xx;
1193   }
1194 
1195  public:
1196   // signed immediate, in low bits, nbits long
1197   static int simm(int x, int nbits) {
1198     assert_signed_range(x, nbits);
1199     return x &amp; ((1 &lt;&lt; nbits) - 1);
1200   }
1201 
1202   // unsigned immediate, in low bits, nbits long
1203   static int uimm(int x, int nbits) {
1204     assert_unsigned_const(x, nbits);
1205     return x &amp; ((1 &lt;&lt; nbits) - 1);
1206   }
1207 
1208   static void set_imm(int* instr, short s) {
1209     // imm is always in the lower 16 bits of the instruction,
1210     // so this is endian-neutral. Same for the get_imm below.
1211     uint32_t w = *(uint32_t *)instr;
1212     *instr = (int)((w &amp; ~0x0000FFFF) | (s &amp; 0x0000FFFF));
1213   }
1214 
1215   static int get_imm(address a, int instruction_number) {
1216     return (short)((int *)a)[instruction_number];
1217   }
1218 
1219   static inline int hi16_signed(  int x) { return (int)(int16_t)(x &gt;&gt; 16); }
1220   static inline int lo16_unsigned(int x) { return x &amp; 0xffff; }
1221 
1222  protected:
1223 
1224   // Extract the top 32 bits in a 64 bit word.
1225   static int32_t hi32(int64_t x) {
1226     int32_t r = int32_t((uint64_t)x &gt;&gt; 32);
1227     return r;
1228   }
1229 
1230  public:
1231 
1232   static inline unsigned int align_addr(unsigned int addr, unsigned int a) {
1233     return ((addr + (a - 1)) &amp; ~(a - 1));
1234   }
1235 
1236   static inline bool is_aligned(unsigned int addr, unsigned int a) {
1237     return (0 == addr % a);
1238   }
1239 
1240   void flush() {
1241     AbstractAssembler::flush();
1242   }
1243 
1244   inline void emit_int32(int);  // shadows AbstractAssembler::emit_int32
1245   inline void emit_data(int);
1246   inline void emit_data(int, RelocationHolder const&amp;);
1247   inline void emit_data(int, relocInfo::relocType rtype);
1248 
1249   // Emit an address.
1250   inline address emit_addr(const address addr = NULL);
1251 
1252 #if !defined(ABI_ELFv2)
1253   // Emit a function descriptor with the specified entry point, TOC,
1254   // and ENV. If the entry point is NULL, the descriptor will point
1255   // just past the descriptor.
1256   // Use values from friend functions as defaults.
1257   inline address emit_fd(address entry = NULL,
1258                          address toc = (address) FunctionDescriptor::friend_toc,
1259                          address env = (address) FunctionDescriptor::friend_env);
1260 #endif
1261 
1262   /////////////////////////////////////////////////////////////////////////////////////
1263   // PPC instructions
1264   /////////////////////////////////////////////////////////////////////////////////////
1265 
1266   // Memory instructions use r0 as hard coded 0, e.g. to simulate loading
1267   // immediates. The normal instruction encoders enforce that r0 is not
1268   // passed to them. Use either extended mnemonics encoders or the special ra0
1269   // versions.
1270 
1271   // Issue an illegal instruction.
1272   inline void illtrap();
1273   static inline bool is_illtrap(int x);
1274 
1275   // PPC 1, section 3.3.8, Fixed-Point Arithmetic Instructions
1276   inline void addi( Register d, Register a, int si16);
1277   inline void addis(Register d, Register a, int si16);
1278  private:
1279   inline void addi_r0ok( Register d, Register a, int si16);
1280   inline void addis_r0ok(Register d, Register a, int si16);
1281  public:
1282   inline void addic_( Register d, Register a, int si16);
1283   inline void subfic( Register d, Register a, int si16);
1284   inline void add(    Register d, Register a, Register b);
1285   inline void add_(   Register d, Register a, Register b);
1286   inline void subf(   Register d, Register a, Register b);  // d = b - a    &quot;Sub_from&quot;, as in ppc spec.
1287   inline void sub(    Register d, Register a, Register b);  // d = a - b    Swap operands of subf for readability.
1288   inline void subf_(  Register d, Register a, Register b);
1289   inline void addc(   Register d, Register a, Register b);
1290   inline void addc_(  Register d, Register a, Register b);
1291   inline void subfc(  Register d, Register a, Register b);
1292   inline void subfc_( Register d, Register a, Register b);
1293   inline void adde(   Register d, Register a, Register b);
1294   inline void adde_(  Register d, Register a, Register b);
1295   inline void subfe(  Register d, Register a, Register b);
1296   inline void subfe_( Register d, Register a, Register b);
1297   inline void addme(  Register d, Register a);
1298   inline void addme_( Register d, Register a);
1299   inline void subfme( Register d, Register a);
1300   inline void subfme_(Register d, Register a);
1301   inline void addze(  Register d, Register a);
1302   inline void addze_( Register d, Register a);
1303   inline void subfze( Register d, Register a);
1304   inline void subfze_(Register d, Register a);
1305   inline void neg(    Register d, Register a);
1306   inline void neg_(   Register d, Register a);
1307   inline void mulli(  Register d, Register a, int si16);
1308   inline void mulld(  Register d, Register a, Register b);
1309   inline void mulld_( Register d, Register a, Register b);
1310   inline void mullw(  Register d, Register a, Register b);
1311   inline void mullw_( Register d, Register a, Register b);
1312   inline void mulhw(  Register d, Register a, Register b);
1313   inline void mulhw_( Register d, Register a, Register b);
1314   inline void mulhwu( Register d, Register a, Register b);
1315   inline void mulhwu_(Register d, Register a, Register b);
1316   inline void mulhd(  Register d, Register a, Register b);
1317   inline void mulhd_( Register d, Register a, Register b);
1318   inline void mulhdu( Register d, Register a, Register b);
1319   inline void mulhdu_(Register d, Register a, Register b);
1320   inline void divd(   Register d, Register a, Register b);
1321   inline void divd_(  Register d, Register a, Register b);
1322   inline void divw(   Register d, Register a, Register b);
1323   inline void divw_(  Register d, Register a, Register b);
1324 
1325   // Fixed-Point Arithmetic Instructions with Overflow detection
1326   inline void addo(    Register d, Register a, Register b);
1327   inline void addo_(   Register d, Register a, Register b);
1328   inline void subfo(   Register d, Register a, Register b);
1329   inline void subfo_(  Register d, Register a, Register b);
1330   inline void addco(   Register d, Register a, Register b);
1331   inline void addco_(  Register d, Register a, Register b);
1332   inline void subfco(  Register d, Register a, Register b);
1333   inline void subfco_( Register d, Register a, Register b);
1334   inline void addeo(   Register d, Register a, Register b);
1335   inline void addeo_(  Register d, Register a, Register b);
1336   inline void subfeo(  Register d, Register a, Register b);
1337   inline void subfeo_( Register d, Register a, Register b);
1338   inline void addmeo(  Register d, Register a);
1339   inline void addmeo_( Register d, Register a);
1340   inline void subfmeo( Register d, Register a);
1341   inline void subfmeo_(Register d, Register a);
1342   inline void addzeo(  Register d, Register a);
1343   inline void addzeo_( Register d, Register a);
1344   inline void subfzeo( Register d, Register a);
1345   inline void subfzeo_(Register d, Register a);
1346   inline void nego(    Register d, Register a);
1347   inline void nego_(   Register d, Register a);
1348   inline void mulldo(  Register d, Register a, Register b);
1349   inline void mulldo_( Register d, Register a, Register b);
1350   inline void mullwo(  Register d, Register a, Register b);
1351   inline void mullwo_( Register d, Register a, Register b);
1352   inline void divdo(   Register d, Register a, Register b);
1353   inline void divdo_(  Register d, Register a, Register b);
1354   inline void divwo(   Register d, Register a, Register b);
1355   inline void divwo_(  Register d, Register a, Register b);
1356 
1357   // extended mnemonics
1358   inline void li(   Register d, int si16);
1359   inline void lis(  Register d, int si16);
1360   inline void addir(Register d, int si16, Register a);
1361   inline void subi( Register d, Register a, int si16);
1362 
1363   static bool is_addi(int x) {
1364      return ADDI_OPCODE == (x &amp; ADDI_OPCODE_MASK);
1365   }
1366   static bool is_addis(int x) {
1367      return ADDIS_OPCODE == (x &amp; ADDIS_OPCODE_MASK);
1368   }
1369   static bool is_bxx(int x) {
1370      return BXX_OPCODE == (x &amp; BXX_OPCODE_MASK);
1371   }
1372   static bool is_b(int x) {
1373      return BXX_OPCODE == (x &amp; BXX_OPCODE_MASK) &amp;&amp; inv_lk_field(x) == 0;
1374   }
1375   static bool is_bl(int x) {
1376      return BXX_OPCODE == (x &amp; BXX_OPCODE_MASK) &amp;&amp; inv_lk_field(x) == 1;
1377   }
1378   static bool is_bcxx(int x) {
1379      return BCXX_OPCODE == (x &amp; BCXX_OPCODE_MASK);
1380   }
1381   static bool is_bxx_or_bcxx(int x) {
1382      return is_bxx(x) || is_bcxx(x);
1383   }
1384   static bool is_bctrl(int x) {
1385      return x == 0x4e800421;
1386   }
1387   static bool is_bctr(int x) {
1388      return x == 0x4e800420;
1389   }
1390   static bool is_bclr(int x) {
1391      return BCLR_OPCODE == (x &amp; XL_FORM_OPCODE_MASK);
1392   }
1393   static bool is_li(int x) {
1394      return is_addi(x) &amp;&amp; inv_ra_field(x)==0;
1395   }
1396   static bool is_lis(int x) {
1397      return is_addis(x) &amp;&amp; inv_ra_field(x)==0;
1398   }
1399   static bool is_mtctr(int x) {
1400      return MTCTR_OPCODE == (x &amp; MTCTR_OPCODE_MASK);
1401   }
1402   static bool is_ld(int x) {
1403      return LD_OPCODE == (x &amp; LD_OPCODE_MASK);
1404   }
1405   static bool is_std(int x) {
1406      return STD_OPCODE == (x &amp; STD_OPCODE_MASK);
1407   }
1408   static bool is_stdu(int x) {
1409      return STDU_OPCODE == (x &amp; STDU_OPCODE_MASK);
1410   }
1411   static bool is_stdx(int x) {
1412      return STDX_OPCODE == (x &amp; STDX_OPCODE_MASK);
1413   }
1414   static bool is_stdux(int x) {
1415      return STDUX_OPCODE == (x &amp; STDUX_OPCODE_MASK);
1416   }
1417   static bool is_stwx(int x) {
1418      return STWX_OPCODE == (x &amp; STWX_OPCODE_MASK);
1419   }
1420   static bool is_stwux(int x) {
1421      return STWUX_OPCODE == (x &amp; STWUX_OPCODE_MASK);
1422   }
1423   static bool is_stw(int x) {
1424      return STW_OPCODE == (x &amp; STW_OPCODE_MASK);
1425   }
1426   static bool is_stwu(int x) {
1427      return STWU_OPCODE == (x &amp; STWU_OPCODE_MASK);
1428   }
1429   static bool is_ori(int x) {
1430      return ORI_OPCODE == (x &amp; ORI_OPCODE_MASK);
1431   };
1432   static bool is_oris(int x) {
1433      return ORIS_OPCODE == (x &amp; ORIS_OPCODE_MASK);
1434   };
1435   static bool is_rldicr(int x) {
1436      return (RLDICR_OPCODE == (x &amp; RLDICR_OPCODE_MASK));
1437   };
1438   static bool is_nop(int x) {
1439     return x == 0x60000000;
1440   }
1441   // endgroup opcode for Power6
1442   static bool is_endgroup(int x) {
1443     return is_ori(x) &amp;&amp; inv_ra_field(x) == 1 &amp;&amp; inv_rs_field(x) == 1 &amp;&amp; inv_d1_field(x) == 0;
1444   }
1445 
1446 
1447  private:
1448   // PPC 1, section 3.3.9, Fixed-Point Compare Instructions
1449   inline void cmpi( ConditionRegister bf, int l, Register a, int si16);
1450   inline void cmp(  ConditionRegister bf, int l, Register a, Register b);
1451   inline void cmpli(ConditionRegister bf, int l, Register a, int ui16);
1452   inline void cmpl( ConditionRegister bf, int l, Register a, Register b);
1453 
1454  public:
1455   // extended mnemonics of Compare Instructions
1456   inline void cmpwi( ConditionRegister crx, Register a, int si16);
1457   inline void cmpdi( ConditionRegister crx, Register a, int si16);
1458   inline void cmpw(  ConditionRegister crx, Register a, Register b);
1459   inline void cmpd(  ConditionRegister crx, Register a, Register b);
1460   inline void cmplwi(ConditionRegister crx, Register a, int ui16);
1461   inline void cmpldi(ConditionRegister crx, Register a, int ui16);
1462   inline void cmplw( ConditionRegister crx, Register a, Register b);
1463   inline void cmpld( ConditionRegister crx, Register a, Register b);
1464 
1465   // &gt;= Power9
1466   inline void cmprb( ConditionRegister bf, int l, Register a, Register b);
1467   inline void cmpeqb(ConditionRegister bf, Register a, Register b);
1468 
1469   inline void isel(   Register d, Register a, Register b, int bc);
1470   // Convenient version which takes: Condition register, Condition code and invert flag. Omit b to keep old value.
1471   inline void isel(   Register d, ConditionRegister cr, Condition cc, bool inv, Register a, Register b = noreg);
1472   // Set d = 0 if (cr.cc) equals 1, otherwise b.
1473   inline void isel_0( Register d, ConditionRegister cr, Condition cc, Register b = noreg);
1474 
1475   // PPC 1, section 3.3.11, Fixed-Point Logical Instructions
1476          void andi(   Register a, Register s, long ui16);   // optimized version
1477   inline void andi_(  Register a, Register s, int ui16);
1478   inline void andis_( Register a, Register s, int ui16);
1479   inline void ori(    Register a, Register s, int ui16);
1480   inline void oris(   Register a, Register s, int ui16);
1481   inline void xori(   Register a, Register s, int ui16);
1482   inline void xoris(  Register a, Register s, int ui16);
1483   inline void andr(   Register a, Register s, Register b);  // suffixed by &#39;r&#39; as &#39;and&#39; is C++ keyword
1484   inline void and_(   Register a, Register s, Register b);
1485   // Turn or0(rx,rx,rx) into a nop and avoid that we accidently emit a
1486   // SMT-priority change instruction (see SMT instructions below).
1487   inline void or_unchecked(Register a, Register s, Register b);
1488   inline void orr(    Register a, Register s, Register b);  // suffixed by &#39;r&#39; as &#39;or&#39; is C++ keyword
1489   inline void or_(    Register a, Register s, Register b);
1490   inline void xorr(   Register a, Register s, Register b);  // suffixed by &#39;r&#39; as &#39;xor&#39; is C++ keyword
1491   inline void xor_(   Register a, Register s, Register b);
1492   inline void nand(   Register a, Register s, Register b);
1493   inline void nand_(  Register a, Register s, Register b);
1494   inline void nor(    Register a, Register s, Register b);
1495   inline void nor_(   Register a, Register s, Register b);
1496   inline void andc(   Register a, Register s, Register b);
1497   inline void andc_(  Register a, Register s, Register b);
1498   inline void orc(    Register a, Register s, Register b);
1499   inline void orc_(   Register a, Register s, Register b);
1500   inline void extsb(  Register a, Register s);
1501   inline void extsb_( Register a, Register s);
1502   inline void extsh(  Register a, Register s);
1503   inline void extsh_( Register a, Register s);
1504   inline void extsw(  Register a, Register s);
1505   inline void extsw_( Register a, Register s);
1506 
1507   // extended mnemonics
1508   inline void nop();
1509   // NOP for FP and BR units (different versions to allow them to be in one group)
1510   inline void fpnop0();
1511   inline void fpnop1();
1512   inline void brnop0();
1513   inline void brnop1();
1514   inline void brnop2();
1515 
1516   inline void mr(      Register d, Register s);
1517   inline void ori_opt( Register d, int ui16);
1518   inline void oris_opt(Register d, int ui16);
1519 
1520   // endgroup opcode for Power6
1521   inline void endgroup();
1522 
1523   // count instructions
1524   inline void cntlzw(  Register a, Register s);
1525   inline void cntlzw_( Register a, Register s);
1526   inline void cntlzd(  Register a, Register s);
1527   inline void cntlzd_( Register a, Register s);
1528   inline void cnttzw(  Register a, Register s);
1529   inline void cnttzw_( Register a, Register s);
1530   inline void cnttzd(  Register a, Register s);
1531   inline void cnttzd_( Register a, Register s);
1532 
1533   // PPC 1, section 3.3.12, Fixed-Point Rotate and Shift Instructions
1534   inline void sld(     Register a, Register s, Register b);
1535   inline void sld_(    Register a, Register s, Register b);
1536   inline void slw(     Register a, Register s, Register b);
1537   inline void slw_(    Register a, Register s, Register b);
1538   inline void srd(     Register a, Register s, Register b);
1539   inline void srd_(    Register a, Register s, Register b);
1540   inline void srw(     Register a, Register s, Register b);
1541   inline void srw_(    Register a, Register s, Register b);
1542   inline void srad(    Register a, Register s, Register b);
1543   inline void srad_(   Register a, Register s, Register b);
1544   inline void sraw(    Register a, Register s, Register b);
1545   inline void sraw_(   Register a, Register s, Register b);
1546   inline void sradi(   Register a, Register s, int sh6);
1547   inline void sradi_(  Register a, Register s, int sh6);
1548   inline void srawi(   Register a, Register s, int sh5);
1549   inline void srawi_(  Register a, Register s, int sh5);
1550 
1551   // extended mnemonics for Shift Instructions
1552   inline void sldi(    Register a, Register s, int sh6);
1553   inline void sldi_(   Register a, Register s, int sh6);
1554   inline void slwi(    Register a, Register s, int sh5);
1555   inline void slwi_(   Register a, Register s, int sh5);
1556   inline void srdi(    Register a, Register s, int sh6);
1557   inline void srdi_(   Register a, Register s, int sh6);
1558   inline void srwi(    Register a, Register s, int sh5);
1559   inline void srwi_(   Register a, Register s, int sh5);
1560 
1561   inline void clrrdi(  Register a, Register s, int ui6);
1562   inline void clrrdi_( Register a, Register s, int ui6);
1563   inline void clrldi(  Register a, Register s, int ui6);
1564   inline void clrldi_( Register a, Register s, int ui6);
1565   inline void clrlsldi(Register a, Register s, int clrl6, int shl6);
1566   inline void clrlsldi_(Register a, Register s, int clrl6, int shl6);
1567   inline void extrdi(  Register a, Register s, int n, int b);
1568   // testbit with condition register
1569   inline void testbitdi(ConditionRegister cr, Register a, Register s, int ui6);
1570 
1571   // rotate instructions
1572   inline void rotldi(  Register a, Register s, int n);
1573   inline void rotrdi(  Register a, Register s, int n);
1574   inline void rotlwi(  Register a, Register s, int n);
1575   inline void rotrwi(  Register a, Register s, int n);
1576 
1577   // Rotate Instructions
1578   inline void rldic(   Register a, Register s, int sh6, int mb6);
1579   inline void rldic_(  Register a, Register s, int sh6, int mb6);
1580   inline void rldicr(  Register a, Register s, int sh6, int mb6);
1581   inline void rldicr_( Register a, Register s, int sh6, int mb6);
1582   inline void rldicl(  Register a, Register s, int sh6, int mb6);
1583   inline void rldicl_( Register a, Register s, int sh6, int mb6);
1584   inline void rlwinm(  Register a, Register s, int sh5, int mb5, int me5);
1585   inline void rlwinm_( Register a, Register s, int sh5, int mb5, int me5);
1586   inline void rldimi(  Register a, Register s, int sh6, int mb6);
1587   inline void rldimi_( Register a, Register s, int sh6, int mb6);
1588   inline void rlwimi(  Register a, Register s, int sh5, int mb5, int me5);
1589   inline void insrdi(  Register a, Register s, int n,   int b);
1590   inline void insrwi(  Register a, Register s, int n,   int b);
1591 
1592   // PPC 1, section 3.3.2 Fixed-Point Load Instructions
1593   // 4 bytes
1594   inline void lwzx( Register d, Register s1, Register s2);
1595   inline void lwz(  Register d, int si16,    Register s1);
1596   inline void lwzu( Register d, int si16,    Register s1);
1597 
1598   // 4 bytes
1599   inline void lwax( Register d, Register s1, Register s2);
1600   inline void lwa(  Register d, int si16,    Register s1);
1601 
1602   // 4 bytes reversed
1603   inline void lwbrx( Register d, Register s1, Register s2);
1604 
1605   // 2 bytes
1606   inline void lhzx( Register d, Register s1, Register s2);
1607   inline void lhz(  Register d, int si16,    Register s1);
1608   inline void lhzu( Register d, int si16,    Register s1);
1609 
1610   // 2 bytes reversed
1611   inline void lhbrx( Register d, Register s1, Register s2);
1612 
1613   // 2 bytes
1614   inline void lhax( Register d, Register s1, Register s2);
1615   inline void lha(  Register d, int si16,    Register s1);
1616   inline void lhau( Register d, int si16,    Register s1);
1617 
1618   // 1 byte
1619   inline void lbzx( Register d, Register s1, Register s2);
1620   inline void lbz(  Register d, int si16,    Register s1);
1621   inline void lbzu( Register d, int si16,    Register s1);
1622 
1623   // 8 bytes
1624   inline void ldx(  Register d, Register s1, Register s2);
1625   inline void ld(   Register d, int si16,    Register s1);
1626   inline void ldu(  Register d, int si16,    Register s1);
1627 
1628   // 8 bytes reversed
1629   inline void ldbrx( Register d, Register s1, Register s2);
1630 
1631   // For convenience. Load pointer into d from b+s1.
1632   inline void ld_ptr(Register d, int b, Register s1);
1633   DEBUG_ONLY(inline void ld_ptr(Register d, ByteSize b, Register s1);)
1634 
1635   //  PPC 1, section 3.3.3 Fixed-Point Store Instructions
1636   inline void stwx( Register d, Register s1, Register s2);
1637   inline void stw(  Register d, int si16,    Register s1);
1638   inline void stwu( Register d, int si16,    Register s1);
1639   inline void stwbrx( Register d, Register s1, Register s2);
1640 
1641   inline void sthx( Register d, Register s1, Register s2);
1642   inline void sth(  Register d, int si16,    Register s1);
1643   inline void sthu( Register d, int si16,    Register s1);
1644   inline void sthbrx( Register d, Register s1, Register s2);
1645 
1646   inline void stbx( Register d, Register s1, Register s2);
1647   inline void stb(  Register d, int si16,    Register s1);
1648   inline void stbu( Register d, int si16,    Register s1);
1649 
1650   inline void stdx( Register d, Register s1, Register s2);
1651   inline void std(  Register d, int si16,    Register s1);
1652   inline void stdu( Register d, int si16,    Register s1);
1653   inline void stdux(Register s, Register a,  Register b);
1654   inline void stdbrx( Register d, Register s1, Register s2);
1655 
1656   inline void st_ptr(Register d, int si16,    Register s1);
1657   DEBUG_ONLY(inline void st_ptr(Register d, ByteSize b, Register s1);)
1658 
1659   // PPC 1, section 3.3.13 Move To/From System Register Instructions
1660   inline void mtlr( Register s1);
1661   inline void mflr( Register d);
1662   inline void mtctr(Register s1);
1663   inline void mfctr(Register d);
1664   inline void mtcrf(int fxm, Register s);
1665   inline void mfcr( Register d);
1666   inline void mcrf( ConditionRegister crd, ConditionRegister cra);
1667   inline void mtcr( Register s);
1668   // &gt;= Power9
1669   inline void setb( Register d, ConditionRegister cra);
1670 
1671   // Special purpose registers
1672   // Exception Register
1673   inline void mtxer(Register s1);
1674   inline void mfxer(Register d);
1675   // Vector Register Save Register
1676   inline void mtvrsave(Register s1);
1677   inline void mfvrsave(Register d);
1678   // Timebase
1679   inline void mftb(Register d);
1680   // Introduced with Power 8:
1681   // Data Stream Control Register
1682   inline void mtdscr(Register s1);
1683   inline void mfdscr(Register d );
1684   // Transactional Memory Registers
1685   inline void mftfhar(Register d);
1686   inline void mftfiar(Register d);
1687   inline void mftexasr(Register d);
1688   inline void mftexasru(Register d);
1689 
1690   // TEXASR bit description
1691   enum transaction_failure_reason {
1692     // Upper half (TEXASRU):
1693     tm_failure_code       =  0, // The Failure Code is copied from tabort or treclaim operand.
1694     tm_failure_persistent =  7, // The failure is likely to recur on each execution.
1695     tm_disallowed         =  8, // The instruction is not permitted.
1696     tm_nesting_of         =  9, // The maximum transaction level was exceeded.
1697     tm_footprint_of       = 10, // The tracking limit for transactional storage accesses was exceeded.
1698     tm_self_induced_cf    = 11, // A self-induced conflict occurred in Suspended state.
1699     tm_non_trans_cf       = 12, // A conflict occurred with a non-transactional access by another processor.
1700     tm_trans_cf           = 13, // A conflict occurred with another transaction.
1701     tm_translation_cf     = 14, // A conflict occurred with a TLB invalidation.
1702     tm_inst_fetch_cf      = 16, // An instruction fetch was performed from a block that was previously written transactionally.
1703     tm_tabort             = 31, // Termination was caused by the execution of an abort instruction.
1704     // Lower half:
1705     tm_suspended          = 32, // Failure was recorded in Suspended state.
1706     tm_failure_summary    = 36, // Failure has been detected and recorded.
1707     tm_tfiar_exact        = 37, // Value in the TFIAR is exact.
1708     tm_rot                = 38, // Rollback-only transaction.
1709     tm_transaction_level  = 52, // Transaction level (nesting depth + 1).
1710   };
1711 
1712   // PPC 1, section 2.4.1 Branch Instructions
1713   inline void b(  address a, relocInfo::relocType rt = relocInfo::none);
1714   inline void b(  Label&amp; L);
1715   inline void bl( address a, relocInfo::relocType rt = relocInfo::none);
1716   inline void bl( Label&amp; L);
1717   inline void bc( int boint, int biint, address a, relocInfo::relocType rt = relocInfo::none);
1718   inline void bc( int boint, int biint, Label&amp; L);
1719   inline void bcl(int boint, int biint, address a, relocInfo::relocType rt = relocInfo::none);
1720   inline void bcl(int boint, int biint, Label&amp; L);
1721 
1722   inline void bclr(  int boint, int biint, int bhint, relocInfo::relocType rt = relocInfo::none);
1723   inline void bclrl( int boint, int biint, int bhint, relocInfo::relocType rt = relocInfo::none);
1724   inline void bcctr( int boint, int biint, int bhint = bhintbhBCCTRisNotReturnButSame,
1725                          relocInfo::relocType rt = relocInfo::none);
1726   inline void bcctrl(int boint, int biint, int bhint = bhintbhBCLRisReturn,
1727                          relocInfo::relocType rt = relocInfo::none);
1728 
1729   // helper function for b, bcxx
1730   inline bool is_within_range_of_b(address a, address pc);
1731   inline bool is_within_range_of_bcxx(address a, address pc);
1732 
1733   // get the destination of a bxx branch (b, bl, ba, bla)
1734   static inline address  bxx_destination(address baddr);
1735   static inline address  bxx_destination(int instr, address pc);
1736   static inline intptr_t bxx_destination_offset(int instr, intptr_t bxx_pos);
1737 
1738   // extended mnemonics for branch instructions
1739   inline void blt(ConditionRegister crx, Label&amp; L);
1740   inline void bgt(ConditionRegister crx, Label&amp; L);
1741   inline void beq(ConditionRegister crx, Label&amp; L);
1742   inline void bso(ConditionRegister crx, Label&amp; L);
1743   inline void bge(ConditionRegister crx, Label&amp; L);
1744   inline void ble(ConditionRegister crx, Label&amp; L);
1745   inline void bne(ConditionRegister crx, Label&amp; L);
1746   inline void bns(ConditionRegister crx, Label&amp; L);
1747 
1748   // Branch instructions with static prediction hints.
1749   inline void blt_predict_taken(    ConditionRegister crx, Label&amp; L);
1750   inline void bgt_predict_taken(    ConditionRegister crx, Label&amp; L);
1751   inline void beq_predict_taken(    ConditionRegister crx, Label&amp; L);
1752   inline void bso_predict_taken(    ConditionRegister crx, Label&amp; L);
1753   inline void bge_predict_taken(    ConditionRegister crx, Label&amp; L);
1754   inline void ble_predict_taken(    ConditionRegister crx, Label&amp; L);
1755   inline void bne_predict_taken(    ConditionRegister crx, Label&amp; L);
1756   inline void bns_predict_taken(    ConditionRegister crx, Label&amp; L);
1757   inline void blt_predict_not_taken(ConditionRegister crx, Label&amp; L);
1758   inline void bgt_predict_not_taken(ConditionRegister crx, Label&amp; L);
1759   inline void beq_predict_not_taken(ConditionRegister crx, Label&amp; L);
1760   inline void bso_predict_not_taken(ConditionRegister crx, Label&amp; L);
1761   inline void bge_predict_not_taken(ConditionRegister crx, Label&amp; L);
1762   inline void ble_predict_not_taken(ConditionRegister crx, Label&amp; L);
1763   inline void bne_predict_not_taken(ConditionRegister crx, Label&amp; L);
1764   inline void bns_predict_not_taken(ConditionRegister crx, Label&amp; L);
1765 
1766   // for use in conjunction with testbitdi:
1767   inline void btrue( ConditionRegister crx, Label&amp; L);
1768   inline void bfalse(ConditionRegister crx, Label&amp; L);
1769 
1770   inline void bltl(ConditionRegister crx, Label&amp; L);
1771   inline void bgtl(ConditionRegister crx, Label&amp; L);
1772   inline void beql(ConditionRegister crx, Label&amp; L);
1773   inline void bsol(ConditionRegister crx, Label&amp; L);
1774   inline void bgel(ConditionRegister crx, Label&amp; L);
1775   inline void blel(ConditionRegister crx, Label&amp; L);
1776   inline void bnel(ConditionRegister crx, Label&amp; L);
1777   inline void bnsl(ConditionRegister crx, Label&amp; L);
1778 
1779   // extended mnemonics for Branch Instructions via LR
1780   // We use `blr&#39; for returns.
1781   inline void blr(relocInfo::relocType rt = relocInfo::none);
1782 
1783   // extended mnemonics for Branch Instructions with CTR
1784   // bdnz means `decrement CTR and jump to L if CTR is not zero&#39;
1785   inline void bdnz(Label&amp; L);
1786   // Decrement and branch if result is zero.
1787   inline void bdz(Label&amp; L);
1788   // we use `bctr[l]&#39; for jumps/calls in function descriptor glue
1789   // code, e.g. calls to runtime functions
1790   inline void bctr( relocInfo::relocType rt = relocInfo::none);
1791   inline void bctrl(relocInfo::relocType rt = relocInfo::none);
1792   // conditional jumps/branches via CTR
1793   inline void beqctr( ConditionRegister crx, relocInfo::relocType rt = relocInfo::none);
1794   inline void beqctrl(ConditionRegister crx, relocInfo::relocType rt = relocInfo::none);
1795   inline void bnectr( ConditionRegister crx, relocInfo::relocType rt = relocInfo::none);
1796   inline void bnectrl(ConditionRegister crx, relocInfo::relocType rt = relocInfo::none);
1797 
1798   // condition register logic instructions
1799   // NOTE: There&#39;s a preferred form: d and s2 should point into the same condition register.
1800   inline void crand( int d, int s1, int s2);
1801   inline void crnand(int d, int s1, int s2);
1802   inline void cror(  int d, int s1, int s2);
1803   inline void crxor( int d, int s1, int s2);
1804   inline void crnor( int d, int s1, int s2);
1805   inline void creqv( int d, int s1, int s2);
1806   inline void crandc(int d, int s1, int s2);
1807   inline void crorc( int d, int s1, int s2);
1808 
1809   // More convenient version.
1810   int condition_register_bit(ConditionRegister cr, Condition c) {
1811     return 4 * (int)(intptr_t)cr + c;
1812   }
1813   void crand( ConditionRegister crdst, Condition cdst, ConditionRegister crsrc, Condition csrc);
1814   void crnand(ConditionRegister crdst, Condition cdst, ConditionRegister crsrc, Condition csrc);
1815   void cror(  ConditionRegister crdst, Condition cdst, ConditionRegister crsrc, Condition csrc);
1816   void crxor( ConditionRegister crdst, Condition cdst, ConditionRegister crsrc, Condition csrc);
1817   void crnor( ConditionRegister crdst, Condition cdst, ConditionRegister crsrc, Condition csrc);
1818   void creqv( ConditionRegister crdst, Condition cdst, ConditionRegister crsrc, Condition csrc);
1819   void crandc(ConditionRegister crdst, Condition cdst, ConditionRegister crsrc, Condition csrc);
1820   void crorc( ConditionRegister crdst, Condition cdst, ConditionRegister crsrc, Condition csrc);
1821 
1822   // icache and dcache related instructions
1823   inline void icbi(  Register s1, Register s2);
1824   //inline void dcba(Register s1, Register s2); // Instruction for embedded processor only.
1825   inline void dcbz(  Register s1, Register s2);
1826   inline void dcbst( Register s1, Register s2);
1827   inline void dcbf(  Register s1, Register s2);
1828 
1829   enum ct_cache_specification {
1830     ct_primary_cache   = 0,
1831     ct_secondary_cache = 2
1832   };
1833   // dcache read hint
1834   inline void dcbt(    Register s1, Register s2);
1835   inline void dcbtct(  Register s1, Register s2, int ct);
1836   inline void dcbtds(  Register s1, Register s2, int ds);
1837   // dcache write hint
1838   inline void dcbtst(  Register s1, Register s2);
1839   inline void dcbtstct(Register s1, Register s2, int ct);
1840 
1841   //  machine barrier instructions:
1842   //
1843   //  - sync    two-way memory barrier, aka fence
1844   //  - lwsync  orders  Store|Store,
1845   //                     Load|Store,
1846   //                     Load|Load,
1847   //            but not Store|Load
1848   //  - eieio   orders memory accesses for device memory (only)
1849   //  - isync   invalidates speculatively executed instructions
1850   //            From the Power ISA 2.06 documentation:
1851   //             &quot;[...] an isync instruction prevents the execution of
1852   //            instructions following the isync until instructions
1853   //            preceding the isync have completed, [...]&quot;
1854   //            From IBM&#39;s AIX assembler reference:
1855   //             &quot;The isync [...] instructions causes the processor to
1856   //            refetch any instructions that might have been fetched
1857   //            prior to the isync instruction. The instruction isync
1858   //            causes the processor to wait for all previous instructions
1859   //            to complete. Then any instructions already fetched are
1860   //            discarded and instruction processing continues in the
1861   //            environment established by the previous instructions.&quot;
1862   //
1863   //  semantic barrier instructions:
1864   //  (as defined in orderAccess.hpp)
1865   //
1866   //  - release  orders Store|Store,       (maps to lwsync)
1867   //                     Load|Store
1868   //  - acquire  orders  Load|Store,       (maps to lwsync)
1869   //                     Load|Load
1870   //  - fence    orders Store|Store,       (maps to sync)
1871   //                     Load|Store,
1872   //                     Load|Load,
1873   //                    Store|Load
1874   //
1875  private:
1876   inline void sync(int l);
1877  public:
1878   inline void sync();
1879   inline void lwsync();
1880   inline void ptesync();
1881   inline void eieio();
1882   inline void isync();
1883   inline void elemental_membar(int e); // Elemental Memory Barriers (&gt;=Power 8)
1884 
1885   // Wait instructions for polling. Attention: May result in SIGILL.
1886   inline void wait();
1887   inline void waitrsv(); // &gt;=Power7
1888 
1889   // atomics
1890   inline void lbarx_unchecked(Register d, Register a, Register b, int eh1 = 0); // &gt;=Power 8
1891   inline void lharx_unchecked(Register d, Register a, Register b, int eh1 = 0); // &gt;=Power 8
1892   inline void lwarx_unchecked(Register d, Register a, Register b, int eh1 = 0);
1893   inline void ldarx_unchecked(Register d, Register a, Register b, int eh1 = 0);
1894   inline void lqarx_unchecked(Register d, Register a, Register b, int eh1 = 0); // &gt;=Power 8
1895   inline bool lxarx_hint_exclusive_access();
1896   inline void lbarx(  Register d, Register a, Register b, bool hint_exclusive_access = false);
1897   inline void lharx(  Register d, Register a, Register b, bool hint_exclusive_access = false);
1898   inline void lwarx(  Register d, Register a, Register b, bool hint_exclusive_access = false);
1899   inline void ldarx(  Register d, Register a, Register b, bool hint_exclusive_access = false);
1900   inline void lqarx(  Register d, Register a, Register b, bool hint_exclusive_access = false);
1901   inline void stbcx_( Register s, Register a, Register b);
1902   inline void sthcx_( Register s, Register a, Register b);
1903   inline void stwcx_( Register s, Register a, Register b);
1904   inline void stdcx_( Register s, Register a, Register b);
1905   inline void stqcx_( Register s, Register a, Register b);
1906 
1907   // Instructions for adjusting thread priority for simultaneous
1908   // multithreading (SMT) on Power5.
1909  private:
1910   inline void smt_prio_very_low();
1911   inline void smt_prio_medium_high();
1912   inline void smt_prio_high();
1913 
1914  public:
1915   inline void smt_prio_low();
1916   inline void smt_prio_medium_low();
1917   inline void smt_prio_medium();
1918   // &gt;= Power7
1919   inline void smt_yield();
1920   inline void smt_mdoio();
1921   inline void smt_mdoom();
1922   // &gt;= Power8
1923   inline void smt_miso();
1924 
1925   // trap instructions
1926   inline void twi_0(Register a); // for load with acquire semantics use load+twi_0+isync (trap can&#39;t occur)
1927   // NOT FOR DIRECT USE!!
1928  protected:
1929   inline void tdi_unchecked(int tobits, Register a, int si16);
1930   inline void twi_unchecked(int tobits, Register a, int si16);
1931   inline void tdi(          int tobits, Register a, int si16);   // asserts UseSIGTRAP
1932   inline void twi(          int tobits, Register a, int si16);   // asserts UseSIGTRAP
1933   inline void td(           int tobits, Register a, Register b); // asserts UseSIGTRAP
1934   inline void tw(           int tobits, Register a, Register b); // asserts UseSIGTRAP
1935 
<a name="1" id="anc1"></a><span class="line-added">1936  public:</span>
1937   static bool is_tdi(int x, int tobits, int ra, int si16) {
1938      return (TDI_OPCODE == (x &amp; TDI_OPCODE_MASK))
1939          &amp;&amp; (tobits == inv_to_field(x))
1940          &amp;&amp; (ra == -1/*any reg*/ || ra == inv_ra_field(x))
1941          &amp;&amp; (si16 == inv_si_field(x));
1942   }
1943 
<a name="2" id="anc2"></a><span class="line-added">1944   static int tdi_get_si16(int x, int tobits, int ra) {</span>
<span class="line-added">1945     if (TDI_OPCODE == (x &amp; TDI_OPCODE_MASK)</span>
<span class="line-added">1946         &amp;&amp; (tobits == inv_to_field(x))</span>
<span class="line-added">1947         &amp;&amp; (ra == -1/*any reg*/ || ra == inv_ra_field(x))) {</span>
<span class="line-added">1948       return inv_si_field(x);</span>
<span class="line-added">1949     }</span>
<span class="line-added">1950     return -1; // No valid tdi instruction.</span>
<span class="line-added">1951   }</span>
<span class="line-added">1952 </span>
1953   static bool is_twi(int x, int tobits, int ra, int si16) {
1954      return (TWI_OPCODE == (x &amp; TWI_OPCODE_MASK))
1955          &amp;&amp; (tobits == inv_to_field(x))
1956          &amp;&amp; (ra == -1/*any reg*/ || ra == inv_ra_field(x))
1957          &amp;&amp; (si16 == inv_si_field(x));
1958   }
1959 
1960   static bool is_twi(int x, int tobits, int ra) {
1961      return (TWI_OPCODE == (x &amp; TWI_OPCODE_MASK))
1962          &amp;&amp; (tobits == inv_to_field(x))
1963          &amp;&amp; (ra == -1/*any reg*/ || ra == inv_ra_field(x));
1964   }
1965 
1966   static bool is_td(int x, int tobits, int ra, int rb) {
1967      return (TD_OPCODE == (x &amp; TD_OPCODE_MASK))
1968          &amp;&amp; (tobits == inv_to_field(x))
1969          &amp;&amp; (ra == -1/*any reg*/ || ra == inv_ra_field(x))
1970          &amp;&amp; (rb == -1/*any reg*/ || rb == inv_rb_field(x));
1971   }
1972 
1973   static bool is_tw(int x, int tobits, int ra, int rb) {
1974      return (TW_OPCODE == (x &amp; TW_OPCODE_MASK))
1975          &amp;&amp; (tobits == inv_to_field(x))
1976          &amp;&amp; (ra == -1/*any reg*/ || ra == inv_ra_field(x))
1977          &amp;&amp; (rb == -1/*any reg*/ || rb == inv_rb_field(x));
1978   }
1979 
<a name="3" id="anc3"></a>
1980   // PPC floating point instructions
1981   // PPC 1, section 4.6.2 Floating-Point Load Instructions
1982   inline void lfs(  FloatRegister d, int si16,   Register a);
1983   inline void lfsu( FloatRegister d, int si16,   Register a);
1984   inline void lfsx( FloatRegister d, Register a, Register b);
1985   inline void lfd(  FloatRegister d, int si16,   Register a);
1986   inline void lfdu( FloatRegister d, int si16,   Register a);
1987   inline void lfdx( FloatRegister d, Register a, Register b);
1988 
1989   // PPC 1, section 4.6.3 Floating-Point Store Instructions
1990   inline void stfs(  FloatRegister s, int si16,   Register a);
1991   inline void stfsu( FloatRegister s, int si16,   Register a);
1992   inline void stfsx( FloatRegister s, Register a, Register b);
1993   inline void stfd(  FloatRegister s, int si16,   Register a);
1994   inline void stfdu( FloatRegister s, int si16,   Register a);
1995   inline void stfdx( FloatRegister s, Register a, Register b);
1996 
1997   // PPC 1, section 4.6.4 Floating-Point Move Instructions
1998   inline void fmr(  FloatRegister d, FloatRegister b);
1999   inline void fmr_( FloatRegister d, FloatRegister b);
2000 
2001   inline void frin( FloatRegister d, FloatRegister b);
2002   inline void frip( FloatRegister d, FloatRegister b);
2003   inline void frim( FloatRegister d, FloatRegister b);
2004 
2005   //  inline void mffgpr( FloatRegister d, Register b);
2006   //  inline void mftgpr( Register d, FloatRegister b);
2007   inline void cmpb(   Register a, Register s, Register b);
2008   inline void popcntb(Register a, Register s);
2009   inline void popcntw(Register a, Register s);
2010   inline void popcntd(Register a, Register s);
2011 
2012   inline void fneg(  FloatRegister d, FloatRegister b);
2013   inline void fneg_( FloatRegister d, FloatRegister b);
2014   inline void fabs(  FloatRegister d, FloatRegister b);
2015   inline void fabs_( FloatRegister d, FloatRegister b);
2016   inline void fnabs( FloatRegister d, FloatRegister b);
2017   inline void fnabs_(FloatRegister d, FloatRegister b);
2018 
2019   // PPC 1, section 4.6.5.1 Floating-Point Elementary Arithmetic Instructions
2020   inline void fadd(  FloatRegister d, FloatRegister a, FloatRegister b);
2021   inline void fadd_( FloatRegister d, FloatRegister a, FloatRegister b);
2022   inline void fadds( FloatRegister d, FloatRegister a, FloatRegister b);
2023   inline void fadds_(FloatRegister d, FloatRegister a, FloatRegister b);
2024   inline void fsub(  FloatRegister d, FloatRegister a, FloatRegister b);
2025   inline void fsub_( FloatRegister d, FloatRegister a, FloatRegister b);
2026   inline void fsubs( FloatRegister d, FloatRegister a, FloatRegister b);
2027   inline void fsubs_(FloatRegister d, FloatRegister a, FloatRegister b);
2028   inline void fmul(  FloatRegister d, FloatRegister a, FloatRegister c);
2029   inline void fmul_( FloatRegister d, FloatRegister a, FloatRegister c);
2030   inline void fmuls( FloatRegister d, FloatRegister a, FloatRegister c);
2031   inline void fmuls_(FloatRegister d, FloatRegister a, FloatRegister c);
2032   inline void fdiv(  FloatRegister d, FloatRegister a, FloatRegister b);
2033   inline void fdiv_( FloatRegister d, FloatRegister a, FloatRegister b);
2034   inline void fdivs( FloatRegister d, FloatRegister a, FloatRegister b);
2035   inline void fdivs_(FloatRegister d, FloatRegister a, FloatRegister b);
2036 
2037   // Fused multiply-accumulate instructions.
2038   // WARNING: Use only when rounding between the 2 parts is not desired.
2039   // Some floating point tck tests will fail if used incorrectly.
2040   inline void fmadd(   FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
2041   inline void fmadd_(  FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
2042   inline void fmadds(  FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
2043   inline void fmadds_( FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
2044   inline void fmsub(   FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
2045   inline void fmsub_(  FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
2046   inline void fmsubs(  FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
2047   inline void fmsubs_( FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
2048   inline void fnmadd(  FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
2049   inline void fnmadd_( FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
2050   inline void fnmadds( FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
2051   inline void fnmadds_(FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
2052   inline void fnmsub(  FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
2053   inline void fnmsub_( FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
2054   inline void fnmsubs( FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
2055   inline void fnmsubs_(FloatRegister d, FloatRegister a, FloatRegister c, FloatRegister b);
2056 
2057   // PPC 1, section 4.6.6 Floating-Point Rounding and Conversion Instructions
2058   inline void frsp(  FloatRegister d, FloatRegister b);
2059   inline void fctid( FloatRegister d, FloatRegister b);
2060   inline void fctidz(FloatRegister d, FloatRegister b);
2061   inline void fctiw( FloatRegister d, FloatRegister b);
2062   inline void fctiwz(FloatRegister d, FloatRegister b);
2063   inline void fcfid( FloatRegister d, FloatRegister b);
2064   inline void fcfids(FloatRegister d, FloatRegister b);
2065 
2066   // PPC 1, section 4.6.7 Floating-Point Compare Instructions
2067   inline void fcmpu( ConditionRegister crx, FloatRegister a, FloatRegister b);
2068 
2069   inline void fsqrt( FloatRegister d, FloatRegister b);
2070   inline void fsqrts(FloatRegister d, FloatRegister b);
2071 
2072   // Vector instructions for &gt;= Power6.
2073   inline void lvebx(    VectorRegister d, Register s1, Register s2);
2074   inline void lvehx(    VectorRegister d, Register s1, Register s2);
2075   inline void lvewx(    VectorRegister d, Register s1, Register s2);
2076   inline void lvx(      VectorRegister d, Register s1, Register s2);
2077   inline void lvxl(     VectorRegister d, Register s1, Register s2);
2078   inline void stvebx(   VectorRegister d, Register s1, Register s2);
2079   inline void stvehx(   VectorRegister d, Register s1, Register s2);
2080   inline void stvewx(   VectorRegister d, Register s1, Register s2);
2081   inline void stvx(     VectorRegister d, Register s1, Register s2);
2082   inline void stvxl(    VectorRegister d, Register s1, Register s2);
2083   inline void lvsl(     VectorRegister d, Register s1, Register s2);
2084   inline void lvsr(     VectorRegister d, Register s1, Register s2);
2085   inline void vpkpx(    VectorRegister d, VectorRegister a, VectorRegister b);
2086   inline void vpkshss(  VectorRegister d, VectorRegister a, VectorRegister b);
2087   inline void vpkswss(  VectorRegister d, VectorRegister a, VectorRegister b);
2088   inline void vpkshus(  VectorRegister d, VectorRegister a, VectorRegister b);
2089   inline void vpkswus(  VectorRegister d, VectorRegister a, VectorRegister b);
2090   inline void vpkuhum(  VectorRegister d, VectorRegister a, VectorRegister b);
2091   inline void vpkuwum(  VectorRegister d, VectorRegister a, VectorRegister b);
2092   inline void vpkuhus(  VectorRegister d, VectorRegister a, VectorRegister b);
2093   inline void vpkuwus(  VectorRegister d, VectorRegister a, VectorRegister b);
2094   inline void vupkhpx(  VectorRegister d, VectorRegister b);
2095   inline void vupkhsb(  VectorRegister d, VectorRegister b);
2096   inline void vupkhsh(  VectorRegister d, VectorRegister b);
2097   inline void vupklpx(  VectorRegister d, VectorRegister b);
2098   inline void vupklsb(  VectorRegister d, VectorRegister b);
2099   inline void vupklsh(  VectorRegister d, VectorRegister b);
2100   inline void vmrghb(   VectorRegister d, VectorRegister a, VectorRegister b);
2101   inline void vmrghw(   VectorRegister d, VectorRegister a, VectorRegister b);
2102   inline void vmrghh(   VectorRegister d, VectorRegister a, VectorRegister b);
2103   inline void vmrglb(   VectorRegister d, VectorRegister a, VectorRegister b);
2104   inline void vmrglw(   VectorRegister d, VectorRegister a, VectorRegister b);
2105   inline void vmrglh(   VectorRegister d, VectorRegister a, VectorRegister b);
2106   inline void vsplt(    VectorRegister d, int ui4,          VectorRegister b);
2107   inline void vsplth(   VectorRegister d, int ui3,          VectorRegister b);
2108   inline void vspltw(   VectorRegister d, int ui2,          VectorRegister b);
2109   inline void vspltisb( VectorRegister d, int si5);
2110   inline void vspltish( VectorRegister d, int si5);
2111   inline void vspltisw( VectorRegister d, int si5);
2112   inline void vperm(    VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2113   inline void vsel(     VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2114   inline void vsl(      VectorRegister d, VectorRegister a, VectorRegister b);
2115   inline void vsldoi(   VectorRegister d, VectorRegister a, VectorRegister b, int ui4);
2116   inline void vslo(     VectorRegister d, VectorRegister a, VectorRegister b);
2117   inline void vsr(      VectorRegister d, VectorRegister a, VectorRegister b);
2118   inline void vsro(     VectorRegister d, VectorRegister a, VectorRegister b);
2119   inline void vaddcuw(  VectorRegister d, VectorRegister a, VectorRegister b);
2120   inline void vaddshs(  VectorRegister d, VectorRegister a, VectorRegister b);
2121   inline void vaddsbs(  VectorRegister d, VectorRegister a, VectorRegister b);
2122   inline void vaddsws(  VectorRegister d, VectorRegister a, VectorRegister b);
2123   inline void vaddubm(  VectorRegister d, VectorRegister a, VectorRegister b);
2124   inline void vadduwm(  VectorRegister d, VectorRegister a, VectorRegister b);
2125   inline void vadduhm(  VectorRegister d, VectorRegister a, VectorRegister b);
2126   inline void vaddudm(  VectorRegister d, VectorRegister a, VectorRegister b);
2127   inline void vaddubs(  VectorRegister d, VectorRegister a, VectorRegister b);
2128   inline void vadduws(  VectorRegister d, VectorRegister a, VectorRegister b);
2129   inline void vadduhs(  VectorRegister d, VectorRegister a, VectorRegister b);
2130   inline void vaddfp(   VectorRegister d, VectorRegister a, VectorRegister b);
2131   inline void vsubcuw(  VectorRegister d, VectorRegister a, VectorRegister b);
2132   inline void vsubshs(  VectorRegister d, VectorRegister a, VectorRegister b);
2133   inline void vsubsbs(  VectorRegister d, VectorRegister a, VectorRegister b);
2134   inline void vsubsws(  VectorRegister d, VectorRegister a, VectorRegister b);
2135   inline void vsububm(  VectorRegister d, VectorRegister a, VectorRegister b);
2136   inline void vsubuwm(  VectorRegister d, VectorRegister a, VectorRegister b);
2137   inline void vsubuhm(  VectorRegister d, VectorRegister a, VectorRegister b);
2138   inline void vsubudm(  VectorRegister d, VectorRegister a, VectorRegister b);
2139   inline void vsububs(  VectorRegister d, VectorRegister a, VectorRegister b);
2140   inline void vsubuws(  VectorRegister d, VectorRegister a, VectorRegister b);
2141   inline void vsubuhs(  VectorRegister d, VectorRegister a, VectorRegister b);
2142   inline void vsubfp(   VectorRegister d, VectorRegister a, VectorRegister b);
2143   inline void vmulesb(  VectorRegister d, VectorRegister a, VectorRegister b);
2144   inline void vmuleub(  VectorRegister d, VectorRegister a, VectorRegister b);
2145   inline void vmulesh(  VectorRegister d, VectorRegister a, VectorRegister b);
2146   inline void vmuleuh(  VectorRegister d, VectorRegister a, VectorRegister b);
2147   inline void vmulosb(  VectorRegister d, VectorRegister a, VectorRegister b);
2148   inline void vmuloub(  VectorRegister d, VectorRegister a, VectorRegister b);
2149   inline void vmulosh(  VectorRegister d, VectorRegister a, VectorRegister b);
2150   inline void vmulosw(  VectorRegister d, VectorRegister a, VectorRegister b);
2151   inline void vmulouh(  VectorRegister d, VectorRegister a, VectorRegister b);
2152   inline void vmuluwm(  VectorRegister d, VectorRegister a, VectorRegister b);
2153   inline void vmhaddshs(VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2154   inline void vmhraddshs(VectorRegister d,VectorRegister a, VectorRegister b, VectorRegister c);
2155   inline void vmladduhm(VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2156   inline void vmsubuhm( VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2157   inline void vmsummbm( VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2158   inline void vmsumshm( VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2159   inline void vmsumshs( VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2160   inline void vmsumuhm( VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2161   inline void vmsumuhs( VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2162   inline void vmaddfp(  VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2163   inline void vsumsws(  VectorRegister d, VectorRegister a, VectorRegister b);
2164   inline void vsum2sws( VectorRegister d, VectorRegister a, VectorRegister b);
2165   inline void vsum4sbs( VectorRegister d, VectorRegister a, VectorRegister b);
2166   inline void vsum4ubs( VectorRegister d, VectorRegister a, VectorRegister b);
2167   inline void vsum4shs( VectorRegister d, VectorRegister a, VectorRegister b);
2168   inline void vavgsb(   VectorRegister d, VectorRegister a, VectorRegister b);
2169   inline void vavgsw(   VectorRegister d, VectorRegister a, VectorRegister b);
2170   inline void vavgsh(   VectorRegister d, VectorRegister a, VectorRegister b);
2171   inline void vavgub(   VectorRegister d, VectorRegister a, VectorRegister b);
2172   inline void vavguw(   VectorRegister d, VectorRegister a, VectorRegister b);
2173   inline void vavguh(   VectorRegister d, VectorRegister a, VectorRegister b);
2174   inline void vmaxsb(   VectorRegister d, VectorRegister a, VectorRegister b);
2175   inline void vmaxsw(   VectorRegister d, VectorRegister a, VectorRegister b);
2176   inline void vmaxsh(   VectorRegister d, VectorRegister a, VectorRegister b);
2177   inline void vmaxub(   VectorRegister d, VectorRegister a, VectorRegister b);
2178   inline void vmaxuw(   VectorRegister d, VectorRegister a, VectorRegister b);
2179   inline void vmaxuh(   VectorRegister d, VectorRegister a, VectorRegister b);
2180   inline void vminsb(   VectorRegister d, VectorRegister a, VectorRegister b);
2181   inline void vminsw(   VectorRegister d, VectorRegister a, VectorRegister b);
2182   inline void vminsh(   VectorRegister d, VectorRegister a, VectorRegister b);
2183   inline void vminub(   VectorRegister d, VectorRegister a, VectorRegister b);
2184   inline void vminuw(   VectorRegister d, VectorRegister a, VectorRegister b);
2185   inline void vminuh(   VectorRegister d, VectorRegister a, VectorRegister b);
2186   inline void vcmpequb( VectorRegister d, VectorRegister a, VectorRegister b);
2187   inline void vcmpequh( VectorRegister d, VectorRegister a, VectorRegister b);
2188   inline void vcmpequw( VectorRegister d, VectorRegister a, VectorRegister b);
2189   inline void vcmpgtsh( VectorRegister d, VectorRegister a, VectorRegister b);
2190   inline void vcmpgtsb( VectorRegister d, VectorRegister a, VectorRegister b);
2191   inline void vcmpgtsw( VectorRegister d, VectorRegister a, VectorRegister b);
2192   inline void vcmpgtub( VectorRegister d, VectorRegister a, VectorRegister b);
2193   inline void vcmpgtuh( VectorRegister d, VectorRegister a, VectorRegister b);
2194   inline void vcmpgtuw( VectorRegister d, VectorRegister a, VectorRegister b);
2195   inline void vcmpequb_(VectorRegister d, VectorRegister a, VectorRegister b);
2196   inline void vcmpequh_(VectorRegister d, VectorRegister a, VectorRegister b);
2197   inline void vcmpequw_(VectorRegister d, VectorRegister a, VectorRegister b);
2198   inline void vcmpgtsh_(VectorRegister d, VectorRegister a, VectorRegister b);
2199   inline void vcmpgtsb_(VectorRegister d, VectorRegister a, VectorRegister b);
2200   inline void vcmpgtsw_(VectorRegister d, VectorRegister a, VectorRegister b);
2201   inline void vcmpgtub_(VectorRegister d, VectorRegister a, VectorRegister b);
2202   inline void vcmpgtuh_(VectorRegister d, VectorRegister a, VectorRegister b);
2203   inline void vcmpgtuw_(VectorRegister d, VectorRegister a, VectorRegister b);
2204   inline void vand(     VectorRegister d, VectorRegister a, VectorRegister b);
2205   inline void vandc(    VectorRegister d, VectorRegister a, VectorRegister b);
2206   inline void vnor(     VectorRegister d, VectorRegister a, VectorRegister b);
2207   inline void vor(      VectorRegister d, VectorRegister a, VectorRegister b);
2208   inline void vmr(      VectorRegister d, VectorRegister a);
2209   inline void vxor(     VectorRegister d, VectorRegister a, VectorRegister b);
2210   inline void vrld(     VectorRegister d, VectorRegister a, VectorRegister b);
2211   inline void vrlb(     VectorRegister d, VectorRegister a, VectorRegister b);
2212   inline void vrlw(     VectorRegister d, VectorRegister a, VectorRegister b);
2213   inline void vrlh(     VectorRegister d, VectorRegister a, VectorRegister b);
2214   inline void vslb(     VectorRegister d, VectorRegister a, VectorRegister b);
2215   inline void vskw(     VectorRegister d, VectorRegister a, VectorRegister b);
2216   inline void vslh(     VectorRegister d, VectorRegister a, VectorRegister b);
2217   inline void vsrb(     VectorRegister d, VectorRegister a, VectorRegister b);
2218   inline void vsrw(     VectorRegister d, VectorRegister a, VectorRegister b);
2219   inline void vsrh(     VectorRegister d, VectorRegister a, VectorRegister b);
2220   inline void vsrab(    VectorRegister d, VectorRegister a, VectorRegister b);
2221   inline void vsraw(    VectorRegister d, VectorRegister a, VectorRegister b);
2222   inline void vsrah(    VectorRegister d, VectorRegister a, VectorRegister b);
2223   inline void vpopcntw( VectorRegister d, VectorRegister b);
2224   // Vector Floating-Point not implemented yet
2225   inline void mtvscr(   VectorRegister b);
2226   inline void mfvscr(   VectorRegister d);
2227 
2228   // Vector-Scalar (VSX) instructions.
2229   inline void lxvd2x(   VectorSRegister d, Register a);
2230   inline void lxvd2x(   VectorSRegister d, Register a, Register b);
2231   inline void stxvd2x(  VectorSRegister d, Register a);
2232   inline void stxvd2x(  VectorSRegister d, Register a, Register b);
2233   inline void mtvrwz(   VectorRegister  d, Register a);
2234   inline void mfvrwz(   Register        a, VectorRegister d);
2235   inline void mtvrd(    VectorRegister  d, Register a);
2236   inline void mfvrd(    Register        a, VectorRegister d);
2237   inline void xxpermdi( VectorSRegister d, VectorSRegister a, VectorSRegister b, int dm);
2238   inline void xxmrghw(  VectorSRegister d, VectorSRegister a, VectorSRegister b);
2239   inline void xxmrglw(  VectorSRegister d, VectorSRegister a, VectorSRegister b);
2240   inline void mtvsrd(   VectorSRegister d, Register a);
2241   inline void mfvsrd(   Register        d, VectorSRegister a);
2242   inline void mtvsrwz(  VectorSRegister d, Register a);
2243   inline void mfvsrwz(  Register        d, VectorSRegister a);
2244   inline void xxspltw(  VectorSRegister d, VectorSRegister b, int ui2);
2245   inline void xxlor(    VectorSRegister d, VectorSRegister a, VectorSRegister b);
2246   inline void xxlxor(   VectorSRegister d, VectorSRegister a, VectorSRegister b);
2247   inline void xxleqv(   VectorSRegister d, VectorSRegister a, VectorSRegister b);
2248   inline void xxbrd(    VectorSRegister d, VectorSRegister b);
2249   inline void xxbrw(    VectorSRegister d, VectorSRegister b);
2250   inline void xvdivsp(  VectorSRegister d, VectorSRegister a, VectorSRegister b);
2251   inline void xvdivdp(  VectorSRegister d, VectorSRegister a, VectorSRegister b);
2252   inline void xvabssp(  VectorSRegister d, VectorSRegister b);
2253   inline void xvabsdp(  VectorSRegister d, VectorSRegister b);
2254   inline void xvnegsp(  VectorSRegister d, VectorSRegister b);
2255   inline void xvnegdp(  VectorSRegister d, VectorSRegister b);
2256   inline void xvsqrtsp( VectorSRegister d, VectorSRegister b);
2257   inline void xvsqrtdp( VectorSRegister d, VectorSRegister b);
2258   inline void xscvdpspn(VectorSRegister d, VectorSRegister b);
2259   inline void xvadddp(  VectorSRegister d, VectorSRegister a, VectorSRegister b);
2260   inline void xvsubdp(  VectorSRegister d, VectorSRegister a, VectorSRegister b);
2261   inline void xvmulsp(  VectorSRegister d, VectorSRegister a, VectorSRegister b);
2262   inline void xvmuldp(  VectorSRegister d, VectorSRegister a, VectorSRegister b);
2263   inline void xvmaddasp(VectorSRegister d, VectorSRegister a, VectorSRegister b);
2264   inline void xvmaddadp(VectorSRegister d, VectorSRegister a, VectorSRegister b);
2265   inline void xvmsubasp(VectorSRegister d, VectorSRegister a, VectorSRegister b);
2266   inline void xvmsubadp(VectorSRegister d, VectorSRegister a, VectorSRegister b);
2267   inline void xvnmsubasp(VectorSRegister d, VectorSRegister a, VectorSRegister b);
2268   inline void xvnmsubadp(VectorSRegister d, VectorSRegister a, VectorSRegister b);
2269   inline void xvrdpi(   VectorSRegister d, VectorSRegister b);
2270   inline void xvrdpim(  VectorSRegister d, VectorSRegister b);
2271   inline void xvrdpip(  VectorSRegister d, VectorSRegister b);
2272 
2273   // VSX Extended Mnemonics
2274   inline void xxspltd(  VectorSRegister d, VectorSRegister a, int x);
2275   inline void xxmrghd(  VectorSRegister d, VectorSRegister a, VectorSRegister b);
2276   inline void xxmrgld(  VectorSRegister d, VectorSRegister a, VectorSRegister b);
2277   inline void xxswapd(  VectorSRegister d, VectorSRegister a);
2278 
2279   // Vector-Scalar (VSX) instructions.
2280   inline void mtfprd(   FloatRegister   d, Register a);
2281   inline void mtfprwa(  FloatRegister   d, Register a);
2282   inline void mffprd(   Register        a, FloatRegister d);
2283 
2284   // Deliver A Random Number (introduced with POWER9)
2285   inline void darn( Register d, int l = 1 /*L=CRN*/);
2286 
2287   // AES (introduced with Power 8)
2288   inline void vcipher(     VectorRegister d, VectorRegister a, VectorRegister b);
2289   inline void vcipherlast( VectorRegister d, VectorRegister a, VectorRegister b);
2290   inline void vncipher(    VectorRegister d, VectorRegister a, VectorRegister b);
2291   inline void vncipherlast(VectorRegister d, VectorRegister a, VectorRegister b);
2292   inline void vsbox(       VectorRegister d, VectorRegister a);
2293 
2294   // SHA (introduced with Power 8)
2295   inline void vshasigmad(VectorRegister d, VectorRegister a, bool st, int six);
2296   inline void vshasigmaw(VectorRegister d, VectorRegister a, bool st, int six);
2297 
2298   // Vector Binary Polynomial Multiplication (introduced with Power 8)
2299   inline void vpmsumb(  VectorRegister d, VectorRegister a, VectorRegister b);
2300   inline void vpmsumd(  VectorRegister d, VectorRegister a, VectorRegister b);
2301   inline void vpmsumh(  VectorRegister d, VectorRegister a, VectorRegister b);
2302   inline void vpmsumw(  VectorRegister d, VectorRegister a, VectorRegister b);
2303 
2304   // Vector Permute and Xor (introduced with Power 8)
2305   inline void vpermxor( VectorRegister d, VectorRegister a, VectorRegister b, VectorRegister c);
2306 
2307   // Transactional Memory instructions (introduced with Power 8)
2308   inline void tbegin_();    // R=0
2309   inline void tbeginrot_(); // R=1 Rollback-Only Transaction
2310   inline void tend_();    // A=0
2311   inline void tendall_(); // A=1
2312   inline void tabort_();
2313   inline void tabort_(Register a);
2314   inline void tabortwc_(int t, Register a, Register b);
2315   inline void tabortwci_(int t, Register a, int si);
2316   inline void tabortdc_(int t, Register a, Register b);
2317   inline void tabortdci_(int t, Register a, int si);
2318   inline void tsuspend_(); // tsr with L=0
2319   inline void tresume_();  // tsr with L=1
2320   inline void tcheck(int f);
2321 
2322   static bool is_tbegin(int x) {
2323     return TBEGIN_OPCODE == (x &amp; (0x3f &lt;&lt; OPCODE_SHIFT | 0x3ff &lt;&lt; 1));
2324   }
2325 
2326   // The following encoders use r0 as second operand. These instructions
2327   // read r0 as &#39;0&#39;.
2328   inline void lwzx( Register d, Register s2);
2329   inline void lwz(  Register d, int si16);
2330   inline void lwax( Register d, Register s2);
2331   inline void lwa(  Register d, int si16);
2332   inline void lwbrx(Register d, Register s2);
2333   inline void lhzx( Register d, Register s2);
2334   inline void lhz(  Register d, int si16);
2335   inline void lhax( Register d, Register s2);
2336   inline void lha(  Register d, int si16);
2337   inline void lhbrx(Register d, Register s2);
2338   inline void lbzx( Register d, Register s2);
2339   inline void lbz(  Register d, int si16);
2340   inline void ldx(  Register d, Register s2);
2341   inline void ld(   Register d, int si16);
2342   inline void ldbrx(Register d, Register s2);
2343   inline void stwx( Register d, Register s2);
2344   inline void stw(  Register d, int si16);
2345   inline void stwbrx( Register d, Register s2);
2346   inline void sthx( Register d, Register s2);
2347   inline void sth(  Register d, int si16);
2348   inline void sthbrx( Register d, Register s2);
2349   inline void stbx( Register d, Register s2);
2350   inline void stb(  Register d, int si16);
2351   inline void stdx( Register d, Register s2);
2352   inline void std(  Register d, int si16);
2353   inline void stdbrx( Register d, Register s2);
2354 
2355   // PPC 2, section 3.2.1 Instruction Cache Instructions
2356   inline void icbi(    Register s2);
2357   // PPC 2, section 3.2.2 Data Cache Instructions
2358   //inlinevoid dcba(   Register s2); // Instruction for embedded processor only.
2359   inline void dcbz(    Register s2);
2360   inline void dcbst(   Register s2);
2361   inline void dcbf(    Register s2);
2362   // dcache read hint
2363   inline void dcbt(    Register s2);
2364   inline void dcbtct(  Register s2, int ct);
2365   inline void dcbtds(  Register s2, int ds);
2366   // dcache write hint
2367   inline void dcbtst(  Register s2);
2368   inline void dcbtstct(Register s2, int ct);
2369 
2370   // Atomics: use ra0mem to disallow R0 as base.
2371   inline void lbarx_unchecked(Register d, Register b, int eh1);
2372   inline void lharx_unchecked(Register d, Register b, int eh1);
2373   inline void lwarx_unchecked(Register d, Register b, int eh1);
2374   inline void ldarx_unchecked(Register d, Register b, int eh1);
2375   inline void lqarx_unchecked(Register d, Register b, int eh1);
2376   inline void lbarx( Register d, Register b, bool hint_exclusive_access);
2377   inline void lharx( Register d, Register b, bool hint_exclusive_access);
2378   inline void lwarx( Register d, Register b, bool hint_exclusive_access);
2379   inline void ldarx( Register d, Register b, bool hint_exclusive_access);
2380   inline void lqarx( Register d, Register b, bool hint_exclusive_access);
2381   inline void stbcx_(Register s, Register b);
2382   inline void sthcx_(Register s, Register b);
2383   inline void stwcx_(Register s, Register b);
2384   inline void stdcx_(Register s, Register b);
2385   inline void stqcx_(Register s, Register b);
2386   inline void lfs(   FloatRegister d, int si16);
2387   inline void lfsx(  FloatRegister d, Register b);
2388   inline void lfd(   FloatRegister d, int si16);
2389   inline void lfdx(  FloatRegister d, Register b);
2390   inline void stfs(  FloatRegister s, int si16);
2391   inline void stfsx( FloatRegister s, Register b);
2392   inline void stfd(  FloatRegister s, int si16);
2393   inline void stfdx( FloatRegister s, Register b);
2394   inline void lvebx( VectorRegister d, Register s2);
2395   inline void lvehx( VectorRegister d, Register s2);
2396   inline void lvewx( VectorRegister d, Register s2);
2397   inline void lvx(   VectorRegister d, Register s2);
2398   inline void lvxl(  VectorRegister d, Register s2);
2399   inline void stvebx(VectorRegister d, Register s2);
2400   inline void stvehx(VectorRegister d, Register s2);
2401   inline void stvewx(VectorRegister d, Register s2);
2402   inline void stvx(  VectorRegister d, Register s2);
2403   inline void stvxl( VectorRegister d, Register s2);
2404   inline void lvsl(  VectorRegister d, Register s2);
2405   inline void lvsr(  VectorRegister d, Register s2);
2406 
2407   // Endianess specific concatenation of 2 loaded vectors.
2408   inline void load_perm(VectorRegister perm, Register addr);
2409   inline void vec_perm(VectorRegister first_dest, VectorRegister second, VectorRegister perm);
2410   inline void vec_perm(VectorRegister dest, VectorRegister first, VectorRegister second, VectorRegister perm);
2411 
2412   // RegisterOrConstant versions.
2413   // These emitters choose between the versions using two registers and
2414   // those with register and immediate, depending on the content of roc.
2415   // If the constant is not encodable as immediate, instructions to
2416   // load the constant are emitted beforehand. Store instructions need a
2417   // tmp reg if the constant is not encodable as immediate.
2418   // Size unpredictable.
2419   void ld(  Register d, RegisterOrConstant roc, Register s1 = noreg);
2420   void lwa( Register d, RegisterOrConstant roc, Register s1 = noreg);
2421   void lwz( Register d, RegisterOrConstant roc, Register s1 = noreg);
2422   void lha( Register d, RegisterOrConstant roc, Register s1 = noreg);
2423   void lhz( Register d, RegisterOrConstant roc, Register s1 = noreg);
2424   void lbz( Register d, RegisterOrConstant roc, Register s1 = noreg);
2425   void std( Register d, RegisterOrConstant roc, Register s1 = noreg, Register tmp = noreg);
2426   void stw( Register d, RegisterOrConstant roc, Register s1 = noreg, Register tmp = noreg);
2427   void sth( Register d, RegisterOrConstant roc, Register s1 = noreg, Register tmp = noreg);
2428   void stb( Register d, RegisterOrConstant roc, Register s1 = noreg, Register tmp = noreg);
2429   void add( Register d, RegisterOrConstant roc, Register s1);
2430   void subf(Register d, RegisterOrConstant roc, Register s1);
2431   void cmpd(ConditionRegister d, RegisterOrConstant roc, Register s1);
2432   // Load pointer d from s1+roc.
2433   void ld_ptr(Register d, RegisterOrConstant roc, Register s1 = noreg) { ld(d, roc, s1); }
2434 
2435   // Emit several instructions to load a 64 bit constant. This issues a fixed
2436   // instruction pattern so that the constant can be patched later on.
2437   enum {
2438     load_const_size = 5 * BytesPerInstWord
2439   };
2440          void load_const(Register d, long a,            Register tmp = noreg);
2441   inline void load_const(Register d, void* a,           Register tmp = noreg);
2442   inline void load_const(Register d, Label&amp; L,          Register tmp = noreg);
2443   inline void load_const(Register d, AddressLiteral&amp; a, Register tmp = noreg);
2444   inline void load_const32(Register d, int i); // load signed int (patchable)
2445 
2446   // Load a 64 bit constant, optimized, not identifyable.
2447   // Tmp can be used to increase ILP. Set return_simm16_rest = true to get a
2448   // 16 bit immediate offset. This is useful if the offset can be encoded in
2449   // a succeeding instruction.
2450          int load_const_optimized(Register d, long a,  Register tmp = noreg, bool return_simm16_rest = false);
2451   inline int load_const_optimized(Register d, void* a, Register tmp = noreg, bool return_simm16_rest = false) {
2452     return load_const_optimized(d, (long)(unsigned long)a, tmp, return_simm16_rest);
2453   }
2454 
2455   // If return_simm16_rest, the return value needs to get added afterwards.
2456          int add_const_optimized(Register d, Register s, long x, Register tmp = R0, bool return_simm16_rest = false);
2457   inline int add_const_optimized(Register d, Register s, void* a, Register tmp = R0, bool return_simm16_rest = false) {
2458     return add_const_optimized(d, s, (long)(unsigned long)a, tmp, return_simm16_rest);
2459   }
2460 
2461   // If return_simm16_rest, the return value needs to get added afterwards.
2462   inline int sub_const_optimized(Register d, Register s, long x, Register tmp = R0, bool return_simm16_rest = false) {
2463     return add_const_optimized(d, s, -x, tmp, return_simm16_rest);
2464   }
2465   inline int sub_const_optimized(Register d, Register s, void* a, Register tmp = R0, bool return_simm16_rest = false) {
2466     return sub_const_optimized(d, s, (long)(unsigned long)a, tmp, return_simm16_rest);
2467   }
2468 
2469   // Creation
2470   Assembler(CodeBuffer* code) : AbstractAssembler(code) {
2471 #ifdef CHECK_DELAY
2472     delay_state = no_delay;
2473 #endif
2474   }
2475 
2476   // Testing
2477 #ifndef PRODUCT
2478   void test_asm();
2479 #endif
2480 };
2481 
2482 
2483 #endif // CPU_PPC_ASSEMBLER_PPC_HPP
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
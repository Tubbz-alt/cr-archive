diff a/src/hotspot/cpu/ppc/nativeInst_ppc.cpp b/src/hotspot/cpu/ppc/nativeInst_ppc.cpp
--- a/src/hotspot/cpu/ppc/nativeInst_ppc.cpp
+++ b/src/hotspot/cpu/ppc/nativeInst_ppc.cpp
@@ -37,14 +37,13 @@
 #include "utilities/ostream.hpp"
 #ifdef COMPILER1
 #include "c1/c1_Runtime1.hpp"
 #endif
 
-// We use an illtrap for marking a method as not_entrant or zombie iff !UseSIGTRAP
+// We use an illtrap for marking a method as not_entrant or zombie
 // Work around a C++ compiler bug which changes 'this'
 bool NativeInstruction::is_sigill_zombie_not_entrant_at(address addr) {
-  assert(!UseSIGTRAP, "precondition");
   if (*(int*)addr != 0 /*illtrap*/) return false;
   CodeBlob* cb = CodeCache::find_blob_unsafe(addr);
   if (cb == NULL || !cb->is_nmethod()) return false;
   nmethod *nm = (nmethod *)cb;
   // This method is not_entrant or zombie iff the illtrap instruction is
@@ -333,17 +332,12 @@
   // Patch this nmethod atomically. Always use illtrap/trap in debug build.
   if (DEBUG_ONLY(false &&) a->is_within_range_of_b(dest, a->pc())) {
     a->b(dest);
   } else {
     // The signal handler will continue at dest=OptoRuntime::handle_wrong_method_stub().
-    if (TrapBasedNotEntrantChecks) {
-      // We use a special trap for marking a method as not_entrant or zombie.
-      a->trap_zombie_not_entrant();
-    } else {
-      // We use an illtrap for marking a method as not_entrant or zombie.
-      a->illtrap();
-    }
+    // We use an illtrap for marking a method as not_entrant or zombie.
+    a->illtrap();
   }
   ICache::ppc64_flush_icache_bytes(verified_entry, code_size);
 }
 
 #ifdef ASSERT

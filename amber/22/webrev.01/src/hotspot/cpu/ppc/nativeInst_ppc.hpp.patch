diff a/src/hotspot/cpu/ppc/nativeInst_ppc.hpp b/src/hotspot/cpu/ppc/nativeInst_ppc.hpp
--- a/src/hotspot/cpu/ppc/nativeInst_ppc.hpp
+++ b/src/hotspot/cpu/ppc/nativeInst_ppc.hpp
@@ -58,21 +58,16 @@
   bool is_sigtrap_null_check() {
     assert(UseSIGTRAP && TrapBasedNullChecks, "precondition");
     return MacroAssembler::is_trap_null_check(long_at(0));
   }
 
-  // We use a special trap for marking a method as not_entrant or zombie
-  // iff UseSIGTRAP.
-  bool is_sigtrap_zombie_not_entrant() {
-    assert(UseSIGTRAP, "precondition");
-    return MacroAssembler::is_trap_zombie_not_entrant(long_at(0));
+  int get_stop_type() {
+    return MacroAssembler::tdi_get_si16(long_at(0), Assembler::traptoUnconditional, 0);
   }
 
-  // We use an illtrap for marking a method as not_entrant or zombie
-  // iff !UseSIGTRAP.
+  // We use an illtrap for marking a method as not_entrant or zombie.
   bool is_sigill_zombie_not_entrant() {
-    assert(!UseSIGTRAP, "precondition");
     // Work around a C++ compiler bug which changes 'this'.
     return NativeInstruction::is_sigill_zombie_not_entrant_at(addr_at(0));
   }
   static bool is_sigill_zombie_not_entrant_at(address addr);
 
@@ -82,15 +77,10 @@
     assert(UseSIGTRAP && TrapBasedRangeChecks, "precondition");
     return MacroAssembler::is_trap_range_check(long_at(0));
   }
 #endif
 
-  // 'should not reach here'.
-  bool is_sigtrap_should_not_reach_here() {
-    return MacroAssembler::is_trap_should_not_reach_here(long_at(0));
-  }
-
   bool is_safepoint_poll() {
     // Is the current instruction a POTENTIAL read access to the polling page?
     // The current arguments of the instruction are not checked!
     if (USE_POLL_BIT_ONLY) {
       int encoding = SafepointMechanism::poll_bit();

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/aarch64/templateTable_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jniFastGetField_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vm_version_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/templateTable_aarch64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
</pre>
<hr />
<pre>
2470   const Register off   = r19;
2471   const Register flags = r0;
2472   const Register raw_flags = r6;
2473   const Register bc    = r4; // uses same reg as obj, so don&#39;t mix them
2474 
2475   resolve_cache_and_index(byte_no, cache, index, sizeof(u2));
2476   jvmti_post_field_access(cache, index, is_static, false);
2477   load_field_cp_cache_entry(obj, cache, index, off, raw_flags, is_static);
2478 
2479   if (!is_static) {
2480     // obj is on the stack
2481     pop_and_check_object(obj);
2482   }
2483 
2484   // 8179954: We need to make sure that the code generated for
2485   // volatile accesses forms a sequentially-consistent set of
2486   // operations when combined with STLR and LDAR.  Without a leading
2487   // membar it&#39;s possible for a simple Dekker test to fail if loads
2488   // use LDR;DMB but stores use STLR.  This can happen if C2 compiles
2489   // the stores in one method and we interpret the loads in another.
<span class="line-modified">2490   if (! UseBarriersForVolatile) {</span>
2491     Label notVolatile;
2492     __ tbz(raw_flags, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
2493     __ membar(MacroAssembler::AnyAny);
2494     __ bind(notVolatile);
2495   }
2496 
2497   const Address field(obj, off);
2498 
2499   Label Done, notByte, notBool, notInt, notShort, notChar,
2500               notLong, notFloat, notObj, notDouble;
2501 
2502   // x86 uses a shift and mask or wings it with a shift plus assert
2503   // the mask is not needed. aarch64 just uses bitfield extract
2504   __ ubfxw(flags, raw_flags, ConstantPoolCacheEntry::tos_state_shift,
2505            ConstantPoolCacheEntry::tos_state_bits);
2506 
2507   assert(btos == 0, &quot;change code, btos != 0&quot;);
2508   __ cbnz(flags, notByte);
2509 
2510   // Don&#39;t rewrite getstatic, only getfield
</pre>
<hr />
<pre>
3066   }
3067 
3068   // access constant pool cache
3069   __ get_cache_and_index_at_bcp(r2, r1, 1);
3070   __ ldr(r1, Address(r2, in_bytes(ConstantPoolCache::base_offset() +
3071                                   ConstantPoolCacheEntry::f2_offset())));
3072   __ ldrw(r3, Address(r2, in_bytes(ConstantPoolCache::base_offset() +
3073                                    ConstantPoolCacheEntry::flags_offset())));
3074 
3075   // r0: object
3076   __ verify_oop(r0);
3077   __ null_check(r0);
3078   const Address field(r0, r1);
3079 
3080   // 8179954: We need to make sure that the code generated for
3081   // volatile accesses forms a sequentially-consistent set of
3082   // operations when combined with STLR and LDAR.  Without a leading
3083   // membar it&#39;s possible for a simple Dekker test to fail if loads
3084   // use LDR;DMB but stores use STLR.  This can happen if C2 compiles
3085   // the stores in one method and we interpret the loads in another.
<span class="line-modified">3086   if (! UseBarriersForVolatile) {</span>
3087     Label notVolatile;
3088     __ tbz(r3, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
3089     __ membar(MacroAssembler::AnyAny);
3090     __ bind(notVolatile);
3091   }
3092 
3093   // access field
3094   switch (bytecode()) {
3095   case Bytecodes::_fast_agetfield:
3096     do_oop_load(_masm, field, r0, IN_HEAP);
3097     __ verify_oop(r0);
3098     break;
3099   case Bytecodes::_fast_lgetfield:
3100     __ access_load_at(T_LONG, IN_HEAP, r0, field, noreg, noreg);
3101     break;
3102   case Bytecodes::_fast_igetfield:
3103     __ access_load_at(T_INT, IN_HEAP, r0, field, noreg, noreg);
3104     break;
3105   case Bytecodes::_fast_bgetfield:
3106     __ access_load_at(T_BYTE, IN_HEAP, r0, field, noreg, noreg);
</pre>
<hr />
<pre>
3128   }
3129 }
3130 
3131 void TemplateTable::fast_xaccess(TosState state)
3132 {
3133   transition(vtos, state);
3134 
3135   // get receiver
3136   __ ldr(r0, aaddress(0));
3137   // access constant pool cache
3138   __ get_cache_and_index_at_bcp(r2, r3, 2);
3139   __ ldr(r1, Address(r2, in_bytes(ConstantPoolCache::base_offset() +
3140                                   ConstantPoolCacheEntry::f2_offset())));
3141 
3142   // 8179954: We need to make sure that the code generated for
3143   // volatile accesses forms a sequentially-consistent set of
3144   // operations when combined with STLR and LDAR.  Without a leading
3145   // membar it&#39;s possible for a simple Dekker test to fail if loads
3146   // use LDR;DMB but stores use STLR.  This can happen if C2 compiles
3147   // the stores in one method and we interpret the loads in another.
<span class="line-modified">3148   if (! UseBarriersForVolatile) {</span>
3149     Label notVolatile;
3150     __ ldrw(r3, Address(r2, in_bytes(ConstantPoolCache::base_offset() +
3151                                      ConstantPoolCacheEntry::flags_offset())));
3152     __ tbz(r3, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
3153     __ membar(MacroAssembler::AnyAny);
3154     __ bind(notVolatile);
3155   }
3156 
3157   // make sure exception is reported in correct bcp range (getfield is
3158   // next instruction)
3159   __ increment(rbcp);
3160   __ null_check(r0);
3161   switch (state) {
3162   case itos:
3163     __ access_load_at(T_INT, IN_HEAP, r0, Address(r0, r1, Address::lsl(0)), noreg, noreg);
3164     break;
3165   case atos:
3166     do_oop_load(_masm, Address(r0, r1, Address::lsl(0)), r0, IN_HEAP);
3167     __ verify_oop(r0);
3168     break;
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
</pre>
<hr />
<pre>
2470   const Register off   = r19;
2471   const Register flags = r0;
2472   const Register raw_flags = r6;
2473   const Register bc    = r4; // uses same reg as obj, so don&#39;t mix them
2474 
2475   resolve_cache_and_index(byte_no, cache, index, sizeof(u2));
2476   jvmti_post_field_access(cache, index, is_static, false);
2477   load_field_cp_cache_entry(obj, cache, index, off, raw_flags, is_static);
2478 
2479   if (!is_static) {
2480     // obj is on the stack
2481     pop_and_check_object(obj);
2482   }
2483 
2484   // 8179954: We need to make sure that the code generated for
2485   // volatile accesses forms a sequentially-consistent set of
2486   // operations when combined with STLR and LDAR.  Without a leading
2487   // membar it&#39;s possible for a simple Dekker test to fail if loads
2488   // use LDR;DMB but stores use STLR.  This can happen if C2 compiles
2489   // the stores in one method and we interpret the loads in another.
<span class="line-modified">2490   if (!is_c1_or_interpreter_only()){</span>
2491     Label notVolatile;
2492     __ tbz(raw_flags, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
2493     __ membar(MacroAssembler::AnyAny);
2494     __ bind(notVolatile);
2495   }
2496 
2497   const Address field(obj, off);
2498 
2499   Label Done, notByte, notBool, notInt, notShort, notChar,
2500               notLong, notFloat, notObj, notDouble;
2501 
2502   // x86 uses a shift and mask or wings it with a shift plus assert
2503   // the mask is not needed. aarch64 just uses bitfield extract
2504   __ ubfxw(flags, raw_flags, ConstantPoolCacheEntry::tos_state_shift,
2505            ConstantPoolCacheEntry::tos_state_bits);
2506 
2507   assert(btos == 0, &quot;change code, btos != 0&quot;);
2508   __ cbnz(flags, notByte);
2509 
2510   // Don&#39;t rewrite getstatic, only getfield
</pre>
<hr />
<pre>
3066   }
3067 
3068   // access constant pool cache
3069   __ get_cache_and_index_at_bcp(r2, r1, 1);
3070   __ ldr(r1, Address(r2, in_bytes(ConstantPoolCache::base_offset() +
3071                                   ConstantPoolCacheEntry::f2_offset())));
3072   __ ldrw(r3, Address(r2, in_bytes(ConstantPoolCache::base_offset() +
3073                                    ConstantPoolCacheEntry::flags_offset())));
3074 
3075   // r0: object
3076   __ verify_oop(r0);
3077   __ null_check(r0);
3078   const Address field(r0, r1);
3079 
3080   // 8179954: We need to make sure that the code generated for
3081   // volatile accesses forms a sequentially-consistent set of
3082   // operations when combined with STLR and LDAR.  Without a leading
3083   // membar it&#39;s possible for a simple Dekker test to fail if loads
3084   // use LDR;DMB but stores use STLR.  This can happen if C2 compiles
3085   // the stores in one method and we interpret the loads in another.
<span class="line-modified">3086   if (!is_c1_or_interpreter_only()) {</span>
3087     Label notVolatile;
3088     __ tbz(r3, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
3089     __ membar(MacroAssembler::AnyAny);
3090     __ bind(notVolatile);
3091   }
3092 
3093   // access field
3094   switch (bytecode()) {
3095   case Bytecodes::_fast_agetfield:
3096     do_oop_load(_masm, field, r0, IN_HEAP);
3097     __ verify_oop(r0);
3098     break;
3099   case Bytecodes::_fast_lgetfield:
3100     __ access_load_at(T_LONG, IN_HEAP, r0, field, noreg, noreg);
3101     break;
3102   case Bytecodes::_fast_igetfield:
3103     __ access_load_at(T_INT, IN_HEAP, r0, field, noreg, noreg);
3104     break;
3105   case Bytecodes::_fast_bgetfield:
3106     __ access_load_at(T_BYTE, IN_HEAP, r0, field, noreg, noreg);
</pre>
<hr />
<pre>
3128   }
3129 }
3130 
3131 void TemplateTable::fast_xaccess(TosState state)
3132 {
3133   transition(vtos, state);
3134 
3135   // get receiver
3136   __ ldr(r0, aaddress(0));
3137   // access constant pool cache
3138   __ get_cache_and_index_at_bcp(r2, r3, 2);
3139   __ ldr(r1, Address(r2, in_bytes(ConstantPoolCache::base_offset() +
3140                                   ConstantPoolCacheEntry::f2_offset())));
3141 
3142   // 8179954: We need to make sure that the code generated for
3143   // volatile accesses forms a sequentially-consistent set of
3144   // operations when combined with STLR and LDAR.  Without a leading
3145   // membar it&#39;s possible for a simple Dekker test to fail if loads
3146   // use LDR;DMB but stores use STLR.  This can happen if C2 compiles
3147   // the stores in one method and we interpret the loads in another.
<span class="line-modified">3148   if (!is_c1_or_interpreter_only()) {</span>
3149     Label notVolatile;
3150     __ ldrw(r3, Address(r2, in_bytes(ConstantPoolCache::base_offset() +
3151                                      ConstantPoolCacheEntry::flags_offset())));
3152     __ tbz(r3, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
3153     __ membar(MacroAssembler::AnyAny);
3154     __ bind(notVolatile);
3155   }
3156 
3157   // make sure exception is reported in correct bcp range (getfield is
3158   // next instruction)
3159   __ increment(rbcp);
3160   __ null_check(r0);
3161   switch (state) {
3162   case itos:
3163     __ access_load_at(T_INT, IN_HEAP, r0, Address(r0, r1, Address::lsl(0)), noreg, noreg);
3164     break;
3165   case atos:
3166     do_oop_load(_masm, Address(r0, r1, Address::lsl(0)), r0, IN_HEAP);
3167     __ verify_oop(r0);
3168     break;
</pre>
</td>
</tr>
</table>
<center><a href="jniFastGetField_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vm_version_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
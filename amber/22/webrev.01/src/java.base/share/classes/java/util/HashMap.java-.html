<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/java/util/HashMap.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.util;
  27 
  28 import java.io.IOException;
  29 import java.io.InvalidObjectException;
  30 import java.io.Serializable;
  31 import java.lang.reflect.ParameterizedType;
  32 import java.lang.reflect.Type;
  33 import java.util.function.BiConsumer;
  34 import java.util.function.BiFunction;
  35 import java.util.function.Consumer;
  36 import java.util.function.Function;
  37 import jdk.internal.access.SharedSecrets;
  38 
  39 /**
  40  * Hash table based implementation of the {@code Map} interface.  This
  41  * implementation provides all of the optional map operations, and permits
  42  * {@code null} values and the {@code null} key.  (The {@code HashMap}
  43  * class is roughly equivalent to {@code Hashtable}, except that it is
  44  * unsynchronized and permits nulls.)  This class makes no guarantees as to
  45  * the order of the map; in particular, it does not guarantee that the order
  46  * will remain constant over time.
  47  *
  48  * &lt;p&gt;This implementation provides constant-time performance for the basic
  49  * operations ({@code get} and {@code put}), assuming the hash function
  50  * disperses the elements properly among the buckets.  Iteration over
  51  * collection views requires time proportional to the &quot;capacity&quot; of the
  52  * {@code HashMap} instance (the number of buckets) plus its size (the number
  53  * of key-value mappings).  Thus, it&#39;s very important not to set the initial
  54  * capacity too high (or the load factor too low) if iteration performance is
  55  * important.
  56  *
  57  * &lt;p&gt;An instance of {@code HashMap} has two parameters that affect its
  58  * performance: &lt;i&gt;initial capacity&lt;/i&gt; and &lt;i&gt;load factor&lt;/i&gt;.  The
  59  * &lt;i&gt;capacity&lt;/i&gt; is the number of buckets in the hash table, and the initial
  60  * capacity is simply the capacity at the time the hash table is created.  The
  61  * &lt;i&gt;load factor&lt;/i&gt; is a measure of how full the hash table is allowed to
  62  * get before its capacity is automatically increased.  When the number of
  63  * entries in the hash table exceeds the product of the load factor and the
  64  * current capacity, the hash table is &lt;i&gt;rehashed&lt;/i&gt; (that is, internal data
  65  * structures are rebuilt) so that the hash table has approximately twice the
  66  * number of buckets.
  67  *
  68  * &lt;p&gt;As a general rule, the default load factor (.75) offers a good
  69  * tradeoff between time and space costs.  Higher values decrease the
  70  * space overhead but increase the lookup cost (reflected in most of
  71  * the operations of the {@code HashMap} class, including
  72  * {@code get} and {@code put}).  The expected number of entries in
  73  * the map and its load factor should be taken into account when
  74  * setting its initial capacity, so as to minimize the number of
  75  * rehash operations.  If the initial capacity is greater than the
  76  * maximum number of entries divided by the load factor, no rehash
  77  * operations will ever occur.
  78  *
  79  * &lt;p&gt;If many mappings are to be stored in a {@code HashMap}
  80  * instance, creating it with a sufficiently large capacity will allow
  81  * the mappings to be stored more efficiently than letting it perform
  82  * automatic rehashing as needed to grow the table.  Note that using
  83  * many keys with the same {@code hashCode()} is a sure way to slow
  84  * down performance of any hash table. To ameliorate impact, when keys
  85  * are {@link Comparable}, this class may use comparison order among
  86  * keys to help break ties.
  87  *
  88  * &lt;p&gt;&lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt;
  89  * If multiple threads access a hash map concurrently, and at least one of
  90  * the threads modifies the map structurally, it &lt;i&gt;must&lt;/i&gt; be
  91  * synchronized externally.  (A structural modification is any operation
  92  * that adds or deletes one or more mappings; merely changing the value
  93  * associated with a key that an instance already contains is not a
  94  * structural modification.)  This is typically accomplished by
  95  * synchronizing on some object that naturally encapsulates the map.
  96  *
  97  * If no such object exists, the map should be &quot;wrapped&quot; using the
  98  * {@link Collections#synchronizedMap Collections.synchronizedMap}
  99  * method.  This is best done at creation time, to prevent accidental
 100  * unsynchronized access to the map:&lt;pre&gt;
 101  *   Map m = Collections.synchronizedMap(new HashMap(...));&lt;/pre&gt;
 102  *
 103  * &lt;p&gt;The iterators returned by all of this class&#39;s &quot;collection view methods&quot;
 104  * are &lt;i&gt;fail-fast&lt;/i&gt;: if the map is structurally modified at any time after
 105  * the iterator is created, in any way except through the iterator&#39;s own
 106  * {@code remove} method, the iterator will throw a
 107  * {@link ConcurrentModificationException}.  Thus, in the face of concurrent
 108  * modification, the iterator fails quickly and cleanly, rather than risking
 109  * arbitrary, non-deterministic behavior at an undetermined time in the
 110  * future.
 111  *
 112  * &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed
 113  * as it is, generally speaking, impossible to make any hard guarantees in the
 114  * presence of unsynchronized concurrent modification.  Fail-fast iterators
 115  * throw {@code ConcurrentModificationException} on a best-effort basis.
 116  * Therefore, it would be wrong to write a program that depended on this
 117  * exception for its correctness: &lt;i&gt;the fail-fast behavior of iterators
 118  * should be used only to detect bugs.&lt;/i&gt;
 119  *
 120  * &lt;p&gt;This class is a member of the
 121  * &lt;a href=&quot;{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework&quot;&gt;
 122  * Java Collections Framework&lt;/a&gt;.
 123  *
 124  * @param &lt;K&gt; the type of keys maintained by this map
 125  * @param &lt;V&gt; the type of mapped values
 126  *
 127  * @author  Doug Lea
 128  * @author  Josh Bloch
 129  * @author  Arthur van Hoff
 130  * @author  Neal Gafter
 131  * @see     Object#hashCode()
 132  * @see     Collection
 133  * @see     Map
 134  * @see     TreeMap
 135  * @see     Hashtable
 136  * @since   1.2
 137  */
 138 public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;
 139     implements Map&lt;K,V&gt;, Cloneable, Serializable {
 140 
 141     @java.io.Serial
 142     private static final long serialVersionUID = 362498820763181265L;
 143 
 144     /*
 145      * Implementation notes.
 146      *
 147      * This map usually acts as a binned (bucketed) hash table, but
 148      * when bins get too large, they are transformed into bins of
 149      * TreeNodes, each structured similarly to those in
 150      * java.util.TreeMap. Most methods try to use normal bins, but
 151      * relay to TreeNode methods when applicable (simply by checking
 152      * instanceof a node).  Bins of TreeNodes may be traversed and
 153      * used like any others, but additionally support faster lookup
 154      * when overpopulated. However, since the vast majority of bins in
 155      * normal use are not overpopulated, checking for existence of
 156      * tree bins may be delayed in the course of table methods.
 157      *
 158      * Tree bins (i.e., bins whose elements are all TreeNodes) are
 159      * ordered primarily by hashCode, but in the case of ties, if two
 160      * elements are of the same &quot;class C implements Comparable&lt;C&gt;&quot;,
 161      * type then their compareTo method is used for ordering. (We
 162      * conservatively check generic types via reflection to validate
 163      * this -- see method comparableClassFor).  The added complexity
 164      * of tree bins is worthwhile in providing worst-case O(log n)
 165      * operations when keys either have distinct hashes or are
 166      * orderable, Thus, performance degrades gracefully under
 167      * accidental or malicious usages in which hashCode() methods
 168      * return values that are poorly distributed, as well as those in
 169      * which many keys share a hashCode, so long as they are also
 170      * Comparable. (If neither of these apply, we may waste about a
 171      * factor of two in time and space compared to taking no
 172      * precautions. But the only known cases stem from poor user
 173      * programming practices that are already so slow that this makes
 174      * little difference.)
 175      *
 176      * Because TreeNodes are about twice the size of regular nodes, we
 177      * use them only when bins contain enough nodes to warrant use
 178      * (see TREEIFY_THRESHOLD). And when they become too small (due to
 179      * removal or resizing) they are converted back to plain bins.  In
 180      * usages with well-distributed user hashCodes, tree bins are
 181      * rarely used.  Ideally, under random hashCodes, the frequency of
 182      * nodes in bins follows a Poisson distribution
 183      * (http://en.wikipedia.org/wiki/Poisson_distribution) with a
 184      * parameter of about 0.5 on average for the default resizing
 185      * threshold of 0.75, although with a large variance because of
 186      * resizing granularity. Ignoring variance, the expected
 187      * occurrences of list size k are (exp(-0.5) * pow(0.5, k) /
 188      * factorial(k)). The first values are:
 189      *
 190      * 0:    0.60653066
 191      * 1:    0.30326533
 192      * 2:    0.07581633
 193      * 3:    0.01263606
 194      * 4:    0.00157952
 195      * 5:    0.00015795
 196      * 6:    0.00001316
 197      * 7:    0.00000094
 198      * 8:    0.00000006
 199      * more: less than 1 in ten million
 200      *
 201      * The root of a tree bin is normally its first node.  However,
 202      * sometimes (currently only upon Iterator.remove), the root might
 203      * be elsewhere, but can be recovered following parent links
 204      * (method TreeNode.root()).
 205      *
 206      * All applicable internal methods accept a hash code as an
 207      * argument (as normally supplied from a public method), allowing
 208      * them to call each other without recomputing user hashCodes.
 209      * Most internal methods also accept a &quot;tab&quot; argument, that is
 210      * normally the current table, but may be a new or old one when
 211      * resizing or converting.
 212      *
 213      * When bin lists are treeified, split, or untreeified, we keep
 214      * them in the same relative access/traversal order (i.e., field
 215      * Node.next) to better preserve locality, and to slightly
 216      * simplify handling of splits and traversals that invoke
 217      * iterator.remove. When using comparators on insertion, to keep a
 218      * total ordering (or as close as is required here) across
 219      * rebalancings, we compare classes and identityHashCodes as
 220      * tie-breakers.
 221      *
 222      * The use and transitions among plain vs tree modes is
 223      * complicated by the existence of subclass LinkedHashMap. See
 224      * below for hook methods defined to be invoked upon insertion,
 225      * removal and access that allow LinkedHashMap internals to
 226      * otherwise remain independent of these mechanics. (This also
 227      * requires that a map instance be passed to some utility methods
 228      * that may create new nodes.)
 229      *
 230      * The concurrent-programming-like SSA-based coding style helps
 231      * avoid aliasing errors amid all of the twisty pointer operations.
 232      */
 233 
 234     /**
 235      * The default initial capacity - MUST be a power of two.
 236      */
 237     static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16
 238 
 239     /**
 240      * The maximum capacity, used if a higher value is implicitly specified
 241      * by either of the constructors with arguments.
 242      * MUST be a power of two &lt;= 1&lt;&lt;30.
 243      */
 244     static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;
 245 
 246     /**
 247      * The load factor used when none specified in constructor.
 248      */
 249     static final float DEFAULT_LOAD_FACTOR = 0.75f;
 250 
 251     /**
 252      * The bin count threshold for using a tree rather than list for a
 253      * bin.  Bins are converted to trees when adding an element to a
 254      * bin with at least this many nodes. The value must be greater
 255      * than 2 and should be at least 8 to mesh with assumptions in
 256      * tree removal about conversion back to plain bins upon
 257      * shrinkage.
 258      */
 259     static final int TREEIFY_THRESHOLD = 8;
 260 
 261     /**
 262      * The bin count threshold for untreeifying a (split) bin during a
 263      * resize operation. Should be less than TREEIFY_THRESHOLD, and at
 264      * most 6 to mesh with shrinkage detection under removal.
 265      */
 266     static final int UNTREEIFY_THRESHOLD = 6;
 267 
 268     /**
 269      * The smallest table capacity for which bins may be treeified.
 270      * (Otherwise the table is resized if too many nodes in a bin.)
 271      * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts
 272      * between resizing and treeification thresholds.
 273      */
 274     static final int MIN_TREEIFY_CAPACITY = 64;
 275 
 276     /**
 277      * Basic hash bin node, used for most entries.  (See below for
 278      * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)
 279      */
 280     static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {
 281         final int hash;
 282         final K key;
 283         V value;
 284         Node&lt;K,V&gt; next;
 285 
 286         Node(int hash, K key, V value, Node&lt;K,V&gt; next) {
 287             this.hash = hash;
 288             this.key = key;
 289             this.value = value;
 290             this.next = next;
 291         }
 292 
 293         public final K getKey()        { return key; }
 294         public final V getValue()      { return value; }
 295         public final String toString() { return key + &quot;=&quot; + value; }
 296 
 297         public final int hashCode() {
 298             return Objects.hashCode(key) ^ Objects.hashCode(value);
 299         }
 300 
 301         public final V setValue(V newValue) {
 302             V oldValue = value;
 303             value = newValue;
 304             return oldValue;
 305         }
 306 
 307         public final boolean equals(Object o) {
 308             if (o == this)
 309                 return true;
 310             if (o instanceof Map.Entry) {
 311                 Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;
 312                 if (Objects.equals(key, e.getKey()) &amp;&amp;
 313                     Objects.equals(value, e.getValue()))
 314                     return true;
 315             }
 316             return false;
 317         }
 318     }
 319 
 320     /* ---------------- Static utilities -------------- */
 321 
 322     /**
 323      * Computes key.hashCode() and spreads (XORs) higher bits of hash
 324      * to lower.  Because the table uses power-of-two masking, sets of
 325      * hashes that vary only in bits above the current mask will
 326      * always collide. (Among known examples are sets of Float keys
 327      * holding consecutive whole numbers in small tables.)  So we
 328      * apply a transform that spreads the impact of higher bits
 329      * downward. There is a tradeoff between speed, utility, and
 330      * quality of bit-spreading. Because many common sets of hashes
 331      * are already reasonably distributed (so don&#39;t benefit from
 332      * spreading), and because we use trees to handle large sets of
 333      * collisions in bins, we just XOR some shifted bits in the
 334      * cheapest possible way to reduce systematic lossage, as well as
 335      * to incorporate impact of the highest bits that would otherwise
 336      * never be used in index calculations because of table bounds.
 337      */
 338     static final int hash(Object key) {
 339         int h;
 340         return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
 341     }
 342 
 343     /**
 344      * Returns x&#39;s Class if it is of the form &quot;class C implements
 345      * Comparable&lt;C&gt;&quot;, else null.
 346      */
 347     static Class&lt;?&gt; comparableClassFor(Object x) {
 348         if (x instanceof Comparable) {
 349             Class&lt;?&gt; c; Type[] ts, as; ParameterizedType p;
 350             if ((c = x.getClass()) == String.class) // bypass checks
 351                 return c;
 352             if ((ts = c.getGenericInterfaces()) != null) {
 353                 for (Type t : ts) {
 354                     if ((t instanceof ParameterizedType) &amp;&amp;
 355                         ((p = (ParameterizedType) t).getRawType() ==
 356                          Comparable.class) &amp;&amp;
 357                         (as = p.getActualTypeArguments()) != null &amp;&amp;
 358                         as.length == 1 &amp;&amp; as[0] == c) // type arg is c
 359                         return c;
 360                 }
 361             }
 362         }
 363         return null;
 364     }
 365 
 366     /**
 367      * Returns k.compareTo(x) if x matches kc (k&#39;s screened comparable
 368      * class), else 0.
 369      */
 370     @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;}) // for cast to Comparable
 371     static int compareComparables(Class&lt;?&gt; kc, Object k, Object x) {
 372         return (x == null || x.getClass() != kc ? 0 :
 373                 ((Comparable)k).compareTo(x));
 374     }
 375 
 376     /**
 377      * Returns a power of two size for the given target capacity.
 378      */
 379     static final int tableSizeFor(int cap) {
 380         int n = -1 &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - 1);
 381         return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
 382     }
 383 
 384     /* ---------------- Fields -------------- */
 385 
 386     /**
 387      * The table, initialized on first use, and resized as
 388      * necessary. When allocated, length is always a power of two.
 389      * (We also tolerate length zero in some operations to allow
 390      * bootstrapping mechanics that are currently not needed.)
 391      */
 392     transient Node&lt;K,V&gt;[] table;
 393 
 394     /**
 395      * Holds cached entrySet(). Note that AbstractMap fields are used
 396      * for keySet() and values().
 397      */
 398     transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;
 399 
 400     /**
 401      * The number of key-value mappings contained in this map.
 402      */
 403     transient int size;
 404 
 405     /**
 406      * The number of times this HashMap has been structurally modified
 407      * Structural modifications are those that change the number of mappings in
 408      * the HashMap or otherwise modify its internal structure (e.g.,
 409      * rehash).  This field is used to make iterators on Collection-views of
 410      * the HashMap fail-fast.  (See ConcurrentModificationException).
 411      */
 412     transient int modCount;
 413 
 414     /**
 415      * The next size value at which to resize (capacity * load factor).
 416      *
 417      * @serial
 418      */
 419     // (The javadoc description is true upon serialization.
 420     // Additionally, if the table array has not been allocated, this
 421     // field holds the initial array capacity, or zero signifying
 422     // DEFAULT_INITIAL_CAPACITY.)
 423     int threshold;
 424 
 425     /**
 426      * The load factor for the hash table.
 427      *
 428      * @serial
 429      */
 430     final float loadFactor;
 431 
 432     /* ---------------- Public operations -------------- */
 433 
 434     /**
 435      * Constructs an empty {@code HashMap} with the specified initial
 436      * capacity and load factor.
 437      *
 438      * @param  initialCapacity the initial capacity
 439      * @param  loadFactor      the load factor
 440      * @throws IllegalArgumentException if the initial capacity is negative
 441      *         or the load factor is nonpositive
 442      */
 443     public HashMap(int initialCapacity, float loadFactor) {
 444         if (initialCapacity &lt; 0)
 445             throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +
 446                                                initialCapacity);
 447         if (initialCapacity &gt; MAXIMUM_CAPACITY)
 448             initialCapacity = MAXIMUM_CAPACITY;
 449         if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
 450             throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +
 451                                                loadFactor);
 452         this.loadFactor = loadFactor;
 453         this.threshold = tableSizeFor(initialCapacity);
 454     }
 455 
 456     /**
 457      * Constructs an empty {@code HashMap} with the specified initial
 458      * capacity and the default load factor (0.75).
 459      *
 460      * @param  initialCapacity the initial capacity.
 461      * @throws IllegalArgumentException if the initial capacity is negative.
 462      */
 463     public HashMap(int initialCapacity) {
 464         this(initialCapacity, DEFAULT_LOAD_FACTOR);
 465     }
 466 
 467     /**
 468      * Constructs an empty {@code HashMap} with the default initial capacity
 469      * (16) and the default load factor (0.75).
 470      */
 471     public HashMap() {
 472         this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted
 473     }
 474 
 475     /**
 476      * Constructs a new {@code HashMap} with the same mappings as the
 477      * specified {@code Map}.  The {@code HashMap} is created with
 478      * default load factor (0.75) and an initial capacity sufficient to
 479      * hold the mappings in the specified {@code Map}.
 480      *
 481      * @param   m the map whose mappings are to be placed in this map
 482      * @throws  NullPointerException if the specified map is null
 483      */
 484     public HashMap(Map&lt;? extends K, ? extends V&gt; m) {
 485         this.loadFactor = DEFAULT_LOAD_FACTOR;
 486         putMapEntries(m, false);
 487     }
 488 
 489     /**
 490      * Implements Map.putAll and Map constructor.
 491      *
 492      * @param m the map
 493      * @param evict false when initially constructing this map, else
 494      * true (relayed to method afterNodeInsertion).
 495      */
 496     final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) {
 497         int s = m.size();
 498         if (s &gt; 0) {
 499             if (table == null) { // pre-size
 500                 float ft = ((float)s / loadFactor) + 1.0F;
 501                 int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ?
 502                          (int)ft : MAXIMUM_CAPACITY);
 503                 if (t &gt; threshold)
 504                     threshold = tableSizeFor(t);
 505             } else {
 506                 // Because of linked-list bucket constraints, we cannot
 507                 // expand all at once, but can reduce total resize
 508                 // effort by repeated doubling now vs later
 509                 while (s &gt; threshold &amp;&amp; table.length &lt; MAXIMUM_CAPACITY)
 510                     resize();
 511             }
 512 
 513             for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) {
 514                 K key = e.getKey();
 515                 V value = e.getValue();
 516                 putVal(hash(key), key, value, false, evict);
 517             }
 518         }
 519     }
 520 
 521     /**
 522      * Returns the number of key-value mappings in this map.
 523      *
 524      * @return the number of key-value mappings in this map
 525      */
 526     public int size() {
 527         return size;
 528     }
 529 
 530     /**
 531      * Returns {@code true} if this map contains no key-value mappings.
 532      *
 533      * @return {@code true} if this map contains no key-value mappings
 534      */
 535     public boolean isEmpty() {
 536         return size == 0;
 537     }
 538 
 539     /**
 540      * Returns the value to which the specified key is mapped,
 541      * or {@code null} if this map contains no mapping for the key.
 542      *
 543      * &lt;p&gt;More formally, if this map contains a mapping from a key
 544      * {@code k} to a value {@code v} such that {@code (key==null ? k==null :
 545      * key.equals(k))}, then this method returns {@code v}; otherwise
 546      * it returns {@code null}.  (There can be at most one such mapping.)
 547      *
 548      * &lt;p&gt;A return value of {@code null} does not &lt;i&gt;necessarily&lt;/i&gt;
 549      * indicate that the map contains no mapping for the key; it&#39;s also
 550      * possible that the map explicitly maps the key to {@code null}.
 551      * The {@link #containsKey containsKey} operation may be used to
 552      * distinguish these two cases.
 553      *
 554      * @see #put(Object, Object)
 555      */
 556     public V get(Object key) {
 557         Node&lt;K,V&gt; e;
 558         return (e = getNode(hash(key), key)) == null ? null : e.value;
 559     }
 560 
 561     /**
 562      * Implements Map.get and related methods.
 563      *
 564      * @param hash hash for key
 565      * @param key the key
 566      * @return the node, or null if none
 567      */
 568     final Node&lt;K,V&gt; getNode(int hash, Object key) {
 569         Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;
 570         if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
 571             (first = tab[(n - 1) &amp; hash]) != null) {
 572             if (first.hash == hash &amp;&amp; // always check first node
 573                 ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))
 574                 return first;
 575             if ((e = first.next) != null) {
 576                 if (first instanceof TreeNode)
 577                     return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);
 578                 do {
 579                     if (e.hash == hash &amp;&amp;
 580                         ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
 581                         return e;
 582                 } while ((e = e.next) != null);
 583             }
 584         }
 585         return null;
 586     }
 587 
 588     /**
 589      * Returns {@code true} if this map contains a mapping for the
 590      * specified key.
 591      *
 592      * @param   key   The key whose presence in this map is to be tested
 593      * @return {@code true} if this map contains a mapping for the specified
 594      * key.
 595      */
 596     public boolean containsKey(Object key) {
 597         return getNode(hash(key), key) != null;
 598     }
 599 
 600     /**
 601      * Associates the specified value with the specified key in this map.
 602      * If the map previously contained a mapping for the key, the old
 603      * value is replaced.
 604      *
 605      * @param key key with which the specified value is to be associated
 606      * @param value value to be associated with the specified key
 607      * @return the previous value associated with {@code key}, or
 608      *         {@code null} if there was no mapping for {@code key}.
 609      *         (A {@code null} return can also indicate that the map
 610      *         previously associated {@code null} with {@code key}.)
 611      */
 612     public V put(K key, V value) {
 613         return putVal(hash(key), key, value, false, true);
 614     }
 615 
 616     /**
 617      * Implements Map.put and related methods.
 618      *
 619      * @param hash hash for key
 620      * @param key the key
 621      * @param value the value to put
 622      * @param onlyIfAbsent if true, don&#39;t change existing value
 623      * @param evict if false, the table is in creation mode.
 624      * @return previous value, or null if none
 625      */
 626     final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
 627                    boolean evict) {
 628         Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
 629         if ((tab = table) == null || (n = tab.length) == 0)
 630             n = (tab = resize()).length;
 631         if ((p = tab[i = (n - 1) &amp; hash]) == null)
 632             tab[i] = newNode(hash, key, value, null);
 633         else {
 634             Node&lt;K,V&gt; e; K k;
 635             if (p.hash == hash &amp;&amp;
 636                 ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
 637                 e = p;
 638             else if (p instanceof TreeNode)
 639                 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
 640             else {
 641                 for (int binCount = 0; ; ++binCount) {
 642                     if ((e = p.next) == null) {
 643                         p.next = newNode(hash, key, value, null);
 644                         if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
 645                             treeifyBin(tab, hash);
 646                         break;
 647                     }
 648                     if (e.hash == hash &amp;&amp;
 649                         ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
 650                         break;
 651                     p = e;
 652                 }
 653             }
 654             if (e != null) { // existing mapping for key
 655                 V oldValue = e.value;
 656                 if (!onlyIfAbsent || oldValue == null)
 657                     e.value = value;
 658                 afterNodeAccess(e);
 659                 return oldValue;
 660             }
 661         }
 662         ++modCount;
 663         if (++size &gt; threshold)
 664             resize();
 665         afterNodeInsertion(evict);
 666         return null;
 667     }
 668 
 669     /**
 670      * Initializes or doubles table size.  If null, allocates in
 671      * accord with initial capacity target held in field threshold.
 672      * Otherwise, because we are using power-of-two expansion, the
 673      * elements from each bin must either stay at same index, or move
 674      * with a power of two offset in the new table.
 675      *
 676      * @return the table
 677      */
 678     final Node&lt;K,V&gt;[] resize() {
 679         Node&lt;K,V&gt;[] oldTab = table;
 680         int oldCap = (oldTab == null) ? 0 : oldTab.length;
 681         int oldThr = threshold;
 682         int newCap, newThr = 0;
 683         if (oldCap &gt; 0) {
 684             if (oldCap &gt;= MAXIMUM_CAPACITY) {
 685                 threshold = Integer.MAX_VALUE;
 686                 return oldTab;
 687             }
 688             else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;
 689                      oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
 690                 newThr = oldThr &lt;&lt; 1; // double threshold
 691         }
 692         else if (oldThr &gt; 0) // initial capacity was placed in threshold
 693             newCap = oldThr;
 694         else {               // zero initial threshold signifies using defaults
 695             newCap = DEFAULT_INITIAL_CAPACITY;
 696             newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
 697         }
 698         if (newThr == 0) {
 699             float ft = (float)newCap * loadFactor;
 700             newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?
 701                       (int)ft : Integer.MAX_VALUE);
 702         }
 703         threshold = newThr;
 704         @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})
 705         Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];
 706         table = newTab;
 707         if (oldTab != null) {
 708             for (int j = 0; j &lt; oldCap; ++j) {
 709                 Node&lt;K,V&gt; e;
 710                 if ((e = oldTab[j]) != null) {
 711                     oldTab[j] = null;
 712                     if (e.next == null)
 713                         newTab[e.hash &amp; (newCap - 1)] = e;
 714                     else if (e instanceof TreeNode)
 715                         ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);
 716                     else { // preserve order
 717                         Node&lt;K,V&gt; loHead = null, loTail = null;
 718                         Node&lt;K,V&gt; hiHead = null, hiTail = null;
 719                         Node&lt;K,V&gt; next;
 720                         do {
 721                             next = e.next;
 722                             if ((e.hash &amp; oldCap) == 0) {
 723                                 if (loTail == null)
 724                                     loHead = e;
 725                                 else
 726                                     loTail.next = e;
 727                                 loTail = e;
 728                             }
 729                             else {
 730                                 if (hiTail == null)
 731                                     hiHead = e;
 732                                 else
 733                                     hiTail.next = e;
 734                                 hiTail = e;
 735                             }
 736                         } while ((e = next) != null);
 737                         if (loTail != null) {
 738                             loTail.next = null;
 739                             newTab[j] = loHead;
 740                         }
 741                         if (hiTail != null) {
 742                             hiTail.next = null;
 743                             newTab[j + oldCap] = hiHead;
 744                         }
 745                     }
 746                 }
 747             }
 748         }
 749         return newTab;
 750     }
 751 
 752     /**
 753      * Replaces all linked nodes in bin at index for given hash unless
 754      * table is too small, in which case resizes instead.
 755      */
 756     final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) {
 757         int n, index; Node&lt;K,V&gt; e;
 758         if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)
 759             resize();
 760         else if ((e = tab[index = (n - 1) &amp; hash]) != null) {
 761             TreeNode&lt;K,V&gt; hd = null, tl = null;
 762             do {
 763                 TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null);
 764                 if (tl == null)
 765                     hd = p;
 766                 else {
 767                     p.prev = tl;
 768                     tl.next = p;
 769                 }
 770                 tl = p;
 771             } while ((e = e.next) != null);
 772             if ((tab[index] = hd) != null)
 773                 hd.treeify(tab);
 774         }
 775     }
 776 
 777     /**
 778      * Copies all of the mappings from the specified map to this map.
 779      * These mappings will replace any mappings that this map had for
 780      * any of the keys currently in the specified map.
 781      *
 782      * @param m mappings to be stored in this map
 783      * @throws NullPointerException if the specified map is null
 784      */
 785     public void putAll(Map&lt;? extends K, ? extends V&gt; m) {
 786         putMapEntries(m, true);
 787     }
 788 
 789     /**
 790      * Removes the mapping for the specified key from this map if present.
 791      *
 792      * @param  key key whose mapping is to be removed from the map
 793      * @return the previous value associated with {@code key}, or
 794      *         {@code null} if there was no mapping for {@code key}.
 795      *         (A {@code null} return can also indicate that the map
 796      *         previously associated {@code null} with {@code key}.)
 797      */
 798     public V remove(Object key) {
 799         Node&lt;K,V&gt; e;
 800         return (e = removeNode(hash(key), key, null, false, true)) == null ?
 801             null : e.value;
 802     }
 803 
 804     /**
 805      * Implements Map.remove and related methods.
 806      *
 807      * @param hash hash for key
 808      * @param key the key
 809      * @param value the value to match if matchValue, else ignored
 810      * @param matchValue if true only remove if value is equal
 811      * @param movable if false do not move other nodes while removing
 812      * @return the node, or null if none
 813      */
 814     final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,
 815                                boolean matchValue, boolean movable) {
 816         Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index;
 817         if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
 818             (p = tab[index = (n - 1) &amp; hash]) != null) {
 819             Node&lt;K,V&gt; node = null, e; K k; V v;
 820             if (p.hash == hash &amp;&amp;
 821                 ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
 822                 node = p;
 823             else if ((e = p.next) != null) {
 824                 if (p instanceof TreeNode)
 825                     node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);
 826                 else {
 827                     do {
 828                         if (e.hash == hash &amp;&amp;
 829                             ((k = e.key) == key ||
 830                              (key != null &amp;&amp; key.equals(k)))) {
 831                             node = e;
 832                             break;
 833                         }
 834                         p = e;
 835                     } while ((e = e.next) != null);
 836                 }
 837             }
 838             if (node != null &amp;&amp; (!matchValue || (v = node.value) == value ||
 839                                  (value != null &amp;&amp; value.equals(v)))) {
 840                 if (node instanceof TreeNode)
 841                     ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable);
 842                 else if (node == p)
 843                     tab[index] = node.next;
 844                 else
 845                     p.next = node.next;
 846                 ++modCount;
 847                 --size;
 848                 afterNodeRemoval(node);
 849                 return node;
 850             }
 851         }
 852         return null;
 853     }
 854 
 855     /**
 856      * Removes all of the mappings from this map.
 857      * The map will be empty after this call returns.
 858      */
 859     public void clear() {
 860         Node&lt;K,V&gt;[] tab;
 861         modCount++;
 862         if ((tab = table) != null &amp;&amp; size &gt; 0) {
 863             size = 0;
 864             for (int i = 0; i &lt; tab.length; ++i)
 865                 tab[i] = null;
 866         }
 867     }
 868 
 869     /**
 870      * Returns {@code true} if this map maps one or more keys to the
 871      * specified value.
 872      *
 873      * @param value value whose presence in this map is to be tested
 874      * @return {@code true} if this map maps one or more keys to the
 875      *         specified value
 876      */
 877     public boolean containsValue(Object value) {
 878         Node&lt;K,V&gt;[] tab; V v;
 879         if ((tab = table) != null &amp;&amp; size &gt; 0) {
 880             for (Node&lt;K,V&gt; e : tab) {
 881                 for (; e != null; e = e.next) {
 882                     if ((v = e.value) == value ||
 883                         (value != null &amp;&amp; value.equals(v)))
 884                         return true;
 885                 }
 886             }
 887         }
 888         return false;
 889     }
 890 
 891     /**
 892      * Returns a {@link Set} view of the keys contained in this map.
 893      * The set is backed by the map, so changes to the map are
 894      * reflected in the set, and vice-versa.  If the map is modified
 895      * while an iteration over the set is in progress (except through
 896      * the iterator&#39;s own {@code remove} operation), the results of
 897      * the iteration are undefined.  The set supports element removal,
 898      * which removes the corresponding mapping from the map, via the
 899      * {@code Iterator.remove}, {@code Set.remove},
 900      * {@code removeAll}, {@code retainAll}, and {@code clear}
 901      * operations.  It does not support the {@code add} or {@code addAll}
 902      * operations.
 903      *
 904      * @return a set view of the keys contained in this map
 905      */
 906     public Set&lt;K&gt; keySet() {
 907         Set&lt;K&gt; ks = keySet;
 908         if (ks == null) {
 909             ks = new KeySet();
 910             keySet = ks;
 911         }
 912         return ks;
 913     }
 914 
 915     /**
 916      * Prepares the array for {@link Collection#toArray(Object[])} implementation.
 917      * If supplied array is smaller than this map size, a new array is allocated.
 918      * If supplied array is bigger than this map size, a null is written at size index.
 919      *
 920      * @param a an original array passed to {@code toArray()} method
 921      * @param &lt;T&gt; type of array elements
 922      * @return an array ready to be filled and returned from {@code toArray()} method.
 923      */
 924     @SuppressWarnings(&quot;unchecked&quot;)
 925     final &lt;T&gt; T[] prepareArray(T[] a) {
 926         int size = this.size;
 927         if (a.length &lt; size) {
 928             return (T[]) java.lang.reflect.Array
 929                     .newInstance(a.getClass().getComponentType(), size);
 930         }
 931         if (a.length &gt; size) {
 932             a[size] = null;
 933         }
 934         return a;
 935     }
 936 
 937     /**
 938      * Fills an array with this map keys and returns it. This method assumes
 939      * that input array is big enough to fit all the keys. Use
 940      * {@link #prepareArray(Object[])} to ensure this.
 941      *
 942      * @param a an array to fill
 943      * @param &lt;T&gt; type of array elements
 944      * @return supplied array
 945      */
 946     &lt;T&gt; T[] keysToArray(T[] a) {
 947         Object[] r = a;
 948         Node&lt;K,V&gt;[] tab;
 949         int idx = 0;
 950         if (size &gt; 0 &amp;&amp; (tab = table) != null) {
 951             for (Node&lt;K,V&gt; e : tab) {
 952                 for (; e != null; e = e.next) {
 953                     r[idx++] = e.key;
 954                 }
 955             }
 956         }
 957         return a;
 958     }
 959 
 960     /**
 961      * Fills an array with this map values and returns it. This method assumes
 962      * that input array is big enough to fit all the values. Use
 963      * {@link #prepareArray(Object[])} to ensure this.
 964      *
 965      * @param a an array to fill
 966      * @param &lt;T&gt; type of array elements
 967      * @return supplied array
 968      */
 969     &lt;T&gt; T[] valuesToArray(T[] a) {
 970         Object[] r = a;
 971         Node&lt;K,V&gt;[] tab;
 972         int idx = 0;
 973         if (size &gt; 0 &amp;&amp; (tab = table) != null) {
 974             for (Node&lt;K,V&gt; e : tab) {
 975                 for (; e != null; e = e.next) {
 976                     r[idx++] = e.value;
 977                 }
 978             }
 979         }
 980         return a;
 981     }
 982 
 983     final class KeySet extends AbstractSet&lt;K&gt; {
 984         public final int size()                 { return size; }
 985         public final void clear()               { HashMap.this.clear(); }
 986         public final Iterator&lt;K&gt; iterator()     { return new KeyIterator(); }
 987         public final boolean contains(Object o) { return containsKey(o); }
 988         public final boolean remove(Object key) {
 989             return removeNode(hash(key), key, null, false, true) != null;
 990         }
 991         public final Spliterator&lt;K&gt; spliterator() {
 992             return new KeySpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0);
 993         }
 994 
 995         public Object[] toArray() {
 996             return keysToArray(new Object[size]);
 997         }
 998 
 999         public &lt;T&gt; T[] toArray(T[] a) {
1000             return keysToArray(prepareArray(a));
1001         }
1002 
1003         public final void forEach(Consumer&lt;? super K&gt; action) {
1004             Node&lt;K,V&gt;[] tab;
1005             if (action == null)
1006                 throw new NullPointerException();
1007             if (size &gt; 0 &amp;&amp; (tab = table) != null) {
1008                 int mc = modCount;
1009                 for (Node&lt;K,V&gt; e : tab) {
1010                     for (; e != null; e = e.next)
1011                         action.accept(e.key);
1012                 }
1013                 if (modCount != mc)
1014                     throw new ConcurrentModificationException();
1015             }
1016         }
1017     }
1018 
1019     /**
1020      * Returns a {@link Collection} view of the values contained in this map.
1021      * The collection is backed by the map, so changes to the map are
1022      * reflected in the collection, and vice-versa.  If the map is
1023      * modified while an iteration over the collection is in progress
1024      * (except through the iterator&#39;s own {@code remove} operation),
1025      * the results of the iteration are undefined.  The collection
1026      * supports element removal, which removes the corresponding
1027      * mapping from the map, via the {@code Iterator.remove},
1028      * {@code Collection.remove}, {@code removeAll},
1029      * {@code retainAll} and {@code clear} operations.  It does not
1030      * support the {@code add} or {@code addAll} operations.
1031      *
1032      * @return a view of the values contained in this map
1033      */
1034     public Collection&lt;V&gt; values() {
1035         Collection&lt;V&gt; vs = values;
1036         if (vs == null) {
1037             vs = new Values();
1038             values = vs;
1039         }
1040         return vs;
1041     }
1042 
1043     final class Values extends AbstractCollection&lt;V&gt; {
1044         public final int size()                 { return size; }
1045         public final void clear()               { HashMap.this.clear(); }
1046         public final Iterator&lt;V&gt; iterator()     { return new ValueIterator(); }
1047         public final boolean contains(Object o) { return containsValue(o); }
1048         public final Spliterator&lt;V&gt; spliterator() {
1049             return new ValueSpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0);
1050         }
1051 
1052         public Object[] toArray() {
1053             return valuesToArray(new Object[size]);
1054         }
1055 
1056         public &lt;T&gt; T[] toArray(T[] a) {
1057             return valuesToArray(prepareArray(a));
1058         }
1059 
1060         public final void forEach(Consumer&lt;? super V&gt; action) {
1061             Node&lt;K,V&gt;[] tab;
1062             if (action == null)
1063                 throw new NullPointerException();
1064             if (size &gt; 0 &amp;&amp; (tab = table) != null) {
1065                 int mc = modCount;
1066                 for (Node&lt;K,V&gt; e : tab) {
1067                     for (; e != null; e = e.next)
1068                         action.accept(e.value);
1069                 }
1070                 if (modCount != mc)
1071                     throw new ConcurrentModificationException();
1072             }
1073         }
1074     }
1075 
1076     /**
1077      * Returns a {@link Set} view of the mappings contained in this map.
1078      * The set is backed by the map, so changes to the map are
1079      * reflected in the set, and vice-versa.  If the map is modified
1080      * while an iteration over the set is in progress (except through
1081      * the iterator&#39;s own {@code remove} operation, or through the
1082      * {@code setValue} operation on a map entry returned by the
1083      * iterator) the results of the iteration are undefined.  The set
1084      * supports element removal, which removes the corresponding
1085      * mapping from the map, via the {@code Iterator.remove},
1086      * {@code Set.remove}, {@code removeAll}, {@code retainAll} and
1087      * {@code clear} operations.  It does not support the
1088      * {@code add} or {@code addAll} operations.
1089      *
1090      * @return a set view of the mappings contained in this map
1091      */
1092     public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {
1093         Set&lt;Map.Entry&lt;K,V&gt;&gt; es;
1094         return (es = entrySet) == null ? (entrySet = new EntrySet()) : es;
1095     }
1096 
1097     final class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; {
1098         public final int size()                 { return size; }
1099         public final void clear()               { HashMap.this.clear(); }
1100         public final Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() {
1101             return new EntryIterator();
1102         }
1103         public final boolean contains(Object o) {
1104             if (!(o instanceof Map.Entry))
1105                 return false;
1106             Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;
1107             Object key = e.getKey();
1108             Node&lt;K,V&gt; candidate = getNode(hash(key), key);
1109             return candidate != null &amp;&amp; candidate.equals(e);
1110         }
1111         public final boolean remove(Object o) {
1112             if (o instanceof Map.Entry) {
1113                 Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;
1114                 Object key = e.getKey();
1115                 Object value = e.getValue();
1116                 return removeNode(hash(key), key, value, true, true) != null;
1117             }
1118             return false;
1119         }
1120         public final Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() {
1121             return new EntrySpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0);
1122         }
1123         public final void forEach(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) {
1124             Node&lt;K,V&gt;[] tab;
1125             if (action == null)
1126                 throw new NullPointerException();
1127             if (size &gt; 0 &amp;&amp; (tab = table) != null) {
1128                 int mc = modCount;
1129                 for (Node&lt;K,V&gt; e : tab) {
1130                     for (; e != null; e = e.next)
1131                         action.accept(e);
1132                 }
1133                 if (modCount != mc)
1134                     throw new ConcurrentModificationException();
1135             }
1136         }
1137     }
1138 
1139     // Overrides of JDK8 Map extension methods
1140 
1141     @Override
1142     public V getOrDefault(Object key, V defaultValue) {
1143         Node&lt;K,V&gt; e;
1144         return (e = getNode(hash(key), key)) == null ? defaultValue : e.value;
1145     }
1146 
1147     @Override
1148     public V putIfAbsent(K key, V value) {
1149         return putVal(hash(key), key, value, true, true);
1150     }
1151 
1152     @Override
1153     public boolean remove(Object key, Object value) {
1154         return removeNode(hash(key), key, value, true, true) != null;
1155     }
1156 
1157     @Override
1158     public boolean replace(K key, V oldValue, V newValue) {
1159         Node&lt;K,V&gt; e; V v;
1160         if ((e = getNode(hash(key), key)) != null &amp;&amp;
1161             ((v = e.value) == oldValue || (v != null &amp;&amp; v.equals(oldValue)))) {
1162             e.value = newValue;
1163             afterNodeAccess(e);
1164             return true;
1165         }
1166         return false;
1167     }
1168 
1169     @Override
1170     public V replace(K key, V value) {
1171         Node&lt;K,V&gt; e;
1172         if ((e = getNode(hash(key), key)) != null) {
1173             V oldValue = e.value;
1174             e.value = value;
1175             afterNodeAccess(e);
1176             return oldValue;
1177         }
1178         return null;
1179     }
1180 
1181     /**
1182      * {@inheritDoc}
1183      *
1184      * &lt;p&gt;This method will, on a best-effort basis, throw a
1185      * {@link ConcurrentModificationException} if it is detected that the
1186      * mapping function modifies this map during computation.
1187      *
1188      * @throws ConcurrentModificationException if it is detected that the
1189      * mapping function modified this map
1190      */
1191     @Override
1192     public V computeIfAbsent(K key,
1193                              Function&lt;? super K, ? extends V&gt; mappingFunction) {
1194         if (mappingFunction == null)
1195             throw new NullPointerException();
1196         int hash = hash(key);
1197         Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; int n, i;
1198         int binCount = 0;
1199         TreeNode&lt;K,V&gt; t = null;
1200         Node&lt;K,V&gt; old = null;
1201         if (size &gt; threshold || (tab = table) == null ||
1202             (n = tab.length) == 0)
1203             n = (tab = resize()).length;
1204         if ((first = tab[i = (n - 1) &amp; hash]) != null) {
1205             if (first instanceof TreeNode)
1206                 old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);
1207             else {
1208                 Node&lt;K,V&gt; e = first; K k;
1209                 do {
1210                     if (e.hash == hash &amp;&amp;
1211                         ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) {
1212                         old = e;
1213                         break;
1214                     }
1215                     ++binCount;
1216                 } while ((e = e.next) != null);
1217             }
1218             V oldValue;
1219             if (old != null &amp;&amp; (oldValue = old.value) != null) {
1220                 afterNodeAccess(old);
1221                 return oldValue;
1222             }
1223         }
1224         int mc = modCount;
1225         V v = mappingFunction.apply(key);
1226         if (mc != modCount) { throw new ConcurrentModificationException(); }
1227         if (v == null) {
1228             return null;
1229         } else if (old != null) {
1230             old.value = v;
1231             afterNodeAccess(old);
1232             return v;
1233         }
1234         else if (t != null)
1235             t.putTreeVal(this, tab, hash, key, v);
1236         else {
1237             tab[i] = newNode(hash, key, v, first);
1238             if (binCount &gt;= TREEIFY_THRESHOLD - 1)
1239                 treeifyBin(tab, hash);
1240         }
1241         modCount = mc + 1;
1242         ++size;
1243         afterNodeInsertion(true);
1244         return v;
1245     }
1246 
1247     /**
1248      * {@inheritDoc}
1249      *
1250      * &lt;p&gt;This method will, on a best-effort basis, throw a
1251      * {@link ConcurrentModificationException} if it is detected that the
1252      * remapping function modifies this map during computation.
1253      *
1254      * @throws ConcurrentModificationException if it is detected that the
1255      * remapping function modified this map
1256      */
1257     @Override
1258     public V computeIfPresent(K key,
1259                               BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {
1260         if (remappingFunction == null)
1261             throw new NullPointerException();
1262         Node&lt;K,V&gt; e; V oldValue;
1263         int hash = hash(key);
1264         if ((e = getNode(hash, key)) != null &amp;&amp;
1265             (oldValue = e.value) != null) {
1266             int mc = modCount;
1267             V v = remappingFunction.apply(key, oldValue);
1268             if (mc != modCount) { throw new ConcurrentModificationException(); }
1269             if (v != null) {
1270                 e.value = v;
1271                 afterNodeAccess(e);
1272                 return v;
1273             }
1274             else
1275                 removeNode(hash, key, null, false, true);
1276         }
1277         return null;
1278     }
1279 
1280     /**
1281      * {@inheritDoc}
1282      *
1283      * &lt;p&gt;This method will, on a best-effort basis, throw a
1284      * {@link ConcurrentModificationException} if it is detected that the
1285      * remapping function modifies this map during computation.
1286      *
1287      * @throws ConcurrentModificationException if it is detected that the
1288      * remapping function modified this map
1289      */
1290     @Override
1291     public V compute(K key,
1292                      BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {
1293         if (remappingFunction == null)
1294             throw new NullPointerException();
1295         int hash = hash(key);
1296         Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; int n, i;
1297         int binCount = 0;
1298         TreeNode&lt;K,V&gt; t = null;
1299         Node&lt;K,V&gt; old = null;
1300         if (size &gt; threshold || (tab = table) == null ||
1301             (n = tab.length) == 0)
1302             n = (tab = resize()).length;
1303         if ((first = tab[i = (n - 1) &amp; hash]) != null) {
1304             if (first instanceof TreeNode)
1305                 old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);
1306             else {
1307                 Node&lt;K,V&gt; e = first; K k;
1308                 do {
1309                     if (e.hash == hash &amp;&amp;
1310                         ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) {
1311                         old = e;
1312                         break;
1313                     }
1314                     ++binCount;
1315                 } while ((e = e.next) != null);
1316             }
1317         }
1318         V oldValue = (old == null) ? null : old.value;
1319         int mc = modCount;
1320         V v = remappingFunction.apply(key, oldValue);
1321         if (mc != modCount) { throw new ConcurrentModificationException(); }
1322         if (old != null) {
1323             if (v != null) {
1324                 old.value = v;
1325                 afterNodeAccess(old);
1326             }
1327             else
1328                 removeNode(hash, key, null, false, true);
1329         }
1330         else if (v != null) {
1331             if (t != null)
1332                 t.putTreeVal(this, tab, hash, key, v);
1333             else {
1334                 tab[i] = newNode(hash, key, v, first);
1335                 if (binCount &gt;= TREEIFY_THRESHOLD - 1)
1336                     treeifyBin(tab, hash);
1337             }
1338             modCount = mc + 1;
1339             ++size;
1340             afterNodeInsertion(true);
1341         }
1342         return v;
1343     }
1344 
1345     /**
1346      * {@inheritDoc}
1347      *
1348      * &lt;p&gt;This method will, on a best-effort basis, throw a
1349      * {@link ConcurrentModificationException} if it is detected that the
1350      * remapping function modifies this map during computation.
1351      *
1352      * @throws ConcurrentModificationException if it is detected that the
1353      * remapping function modified this map
1354      */
1355     @Override
1356     public V merge(K key, V value,
1357                    BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) {
1358         if (value == null || remappingFunction == null)
1359             throw new NullPointerException();
1360         int hash = hash(key);
1361         Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; int n, i;
1362         int binCount = 0;
1363         TreeNode&lt;K,V&gt; t = null;
1364         Node&lt;K,V&gt; old = null;
1365         if (size &gt; threshold || (tab = table) == null ||
1366             (n = tab.length) == 0)
1367             n = (tab = resize()).length;
1368         if ((first = tab[i = (n - 1) &amp; hash]) != null) {
1369             if (first instanceof TreeNode)
1370                 old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);
1371             else {
1372                 Node&lt;K,V&gt; e = first; K k;
1373                 do {
1374                     if (e.hash == hash &amp;&amp;
1375                         ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) {
1376                         old = e;
1377                         break;
1378                     }
1379                     ++binCount;
1380                 } while ((e = e.next) != null);
1381             }
1382         }
1383         if (old != null) {
1384             V v;
1385             if (old.value != null) {
1386                 int mc = modCount;
1387                 v = remappingFunction.apply(old.value, value);
1388                 if (mc != modCount) {
1389                     throw new ConcurrentModificationException();
1390                 }
1391             } else {
1392                 v = value;
1393             }
1394             if (v != null) {
1395                 old.value = v;
1396                 afterNodeAccess(old);
1397             }
1398             else
1399                 removeNode(hash, key, null, false, true);
1400             return v;
1401         } else {
1402             if (t != null)
1403                 t.putTreeVal(this, tab, hash, key, value);
1404             else {
1405                 tab[i] = newNode(hash, key, value, first);
1406                 if (binCount &gt;= TREEIFY_THRESHOLD - 1)
1407                     treeifyBin(tab, hash);
1408             }
1409             ++modCount;
1410             ++size;
1411             afterNodeInsertion(true);
1412             return value;
1413         }
1414     }
1415 
1416     @Override
1417     public void forEach(BiConsumer&lt;? super K, ? super V&gt; action) {
1418         Node&lt;K,V&gt;[] tab;
1419         if (action == null)
1420             throw new NullPointerException();
1421         if (size &gt; 0 &amp;&amp; (tab = table) != null) {
1422             int mc = modCount;
1423             for (Node&lt;K,V&gt; e : tab) {
1424                 for (; e != null; e = e.next)
1425                     action.accept(e.key, e.value);
1426             }
1427             if (modCount != mc)
1428                 throw new ConcurrentModificationException();
1429         }
1430     }
1431 
1432     @Override
1433     public void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function) {
1434         Node&lt;K,V&gt;[] tab;
1435         if (function == null)
1436             throw new NullPointerException();
1437         if (size &gt; 0 &amp;&amp; (tab = table) != null) {
1438             int mc = modCount;
1439             for (Node&lt;K,V&gt; e : tab) {
1440                 for (; e != null; e = e.next) {
1441                     e.value = function.apply(e.key, e.value);
1442                 }
1443             }
1444             if (modCount != mc)
1445                 throw new ConcurrentModificationException();
1446         }
1447     }
1448 
1449     /* ------------------------------------------------------------ */
1450     // Cloning and serialization
1451 
1452     /**
1453      * Returns a shallow copy of this {@code HashMap} instance: the keys and
1454      * values themselves are not cloned.
1455      *
1456      * @return a shallow copy of this map
1457      */
1458     @SuppressWarnings(&quot;unchecked&quot;)
1459     @Override
1460     public Object clone() {
1461         HashMap&lt;K,V&gt; result;
1462         try {
1463             result = (HashMap&lt;K,V&gt;)super.clone();
1464         } catch (CloneNotSupportedException e) {
1465             // this shouldn&#39;t happen, since we are Cloneable
1466             throw new InternalError(e);
1467         }
1468         result.reinitialize();
1469         result.putMapEntries(this, false);
1470         return result;
1471     }
1472 
1473     // These methods are also used when serializing HashSets
1474     final float loadFactor() { return loadFactor; }
1475     final int capacity() {
1476         return (table != null) ? table.length :
1477             (threshold &gt; 0) ? threshold :
1478             DEFAULT_INITIAL_CAPACITY;
1479     }
1480 
1481     /**
1482      * Saves this map to a stream (that is, serializes it).
1483      *
1484      * @param s the stream
1485      * @throws IOException if an I/O error occurs
1486      * @serialData The &lt;i&gt;capacity&lt;/i&gt; of the HashMap (the length of the
1487      *             bucket array) is emitted (int), followed by the
1488      *             &lt;i&gt;size&lt;/i&gt; (an int, the number of key-value
1489      *             mappings), followed by the key (Object) and value (Object)
1490      *             for each key-value mapping.  The key-value mappings are
1491      *             emitted in no particular order.
1492      */
1493     @java.io.Serial
1494     private void writeObject(java.io.ObjectOutputStream s)
1495         throws IOException {
1496         int buckets = capacity();
1497         // Write out the threshold, loadfactor, and any hidden stuff
1498         s.defaultWriteObject();
1499         s.writeInt(buckets);
1500         s.writeInt(size);
1501         internalWriteEntries(s);
1502     }
1503 
1504     /**
1505      * Reconstitutes this map from a stream (that is, deserializes it).
1506      * @param s the stream
1507      * @throws ClassNotFoundException if the class of a serialized object
1508      *         could not be found
1509      * @throws IOException if an I/O error occurs
1510      */
1511     @java.io.Serial
1512     private void readObject(java.io.ObjectInputStream s)
1513         throws IOException, ClassNotFoundException {
1514         // Read in the threshold (ignored), loadfactor, and any hidden stuff
1515         s.defaultReadObject();
1516         reinitialize();
1517         if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
1518             throw new InvalidObjectException(&quot;Illegal load factor: &quot; +
1519                                              loadFactor);
1520         s.readInt();                // Read and ignore number of buckets
1521         int mappings = s.readInt(); // Read number of mappings (size)
1522         if (mappings &lt; 0)
1523             throw new InvalidObjectException(&quot;Illegal mappings count: &quot; +
1524                                              mappings);
1525         else if (mappings &gt; 0) { // (if zero, use defaults)
1526             // Size the table using given load factor only if within
1527             // range of 0.25...4.0
1528             float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f);
1529             float fc = (float)mappings / lf + 1.0f;
1530             int cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?
1531                        DEFAULT_INITIAL_CAPACITY :
1532                        (fc &gt;= MAXIMUM_CAPACITY) ?
1533                        MAXIMUM_CAPACITY :
1534                        tableSizeFor((int)fc));
1535             float ft = (float)cap * lf;
1536             threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?
1537                          (int)ft : Integer.MAX_VALUE);
1538 
1539             // Check Map.Entry[].class since it&#39;s the nearest public type to
1540             // what we&#39;re actually creating.
1541             SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Map.Entry[].class, cap);
1542             @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})
1543             Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])new Node[cap];
1544             table = tab;
1545 
1546             // Read the keys and values, and put the mappings in the HashMap
1547             for (int i = 0; i &lt; mappings; i++) {
1548                 @SuppressWarnings(&quot;unchecked&quot;)
1549                     K key = (K) s.readObject();
1550                 @SuppressWarnings(&quot;unchecked&quot;)
1551                     V value = (V) s.readObject();
1552                 putVal(hash(key), key, value, false, false);
1553             }
1554         }
1555     }
1556 
1557     /* ------------------------------------------------------------ */
1558     // iterators
1559 
1560     abstract class HashIterator {
1561         Node&lt;K,V&gt; next;        // next entry to return
1562         Node&lt;K,V&gt; current;     // current entry
1563         int expectedModCount;  // for fast-fail
1564         int index;             // current slot
1565 
1566         HashIterator() {
1567             expectedModCount = modCount;
1568             Node&lt;K,V&gt;[] t = table;
1569             current = next = null;
1570             index = 0;
1571             if (t != null &amp;&amp; size &gt; 0) { // advance to first entry
1572                 do {} while (index &lt; t.length &amp;&amp; (next = t[index++]) == null);
1573             }
1574         }
1575 
1576         public final boolean hasNext() {
1577             return next != null;
1578         }
1579 
1580         final Node&lt;K,V&gt; nextNode() {
1581             Node&lt;K,V&gt;[] t;
1582             Node&lt;K,V&gt; e = next;
1583             if (modCount != expectedModCount)
1584                 throw new ConcurrentModificationException();
1585             if (e == null)
1586                 throw new NoSuchElementException();
1587             if ((next = (current = e).next) == null &amp;&amp; (t = table) != null) {
1588                 do {} while (index &lt; t.length &amp;&amp; (next = t[index++]) == null);
1589             }
1590             return e;
1591         }
1592 
1593         public final void remove() {
1594             Node&lt;K,V&gt; p = current;
1595             if (p == null)
1596                 throw new IllegalStateException();
1597             if (modCount != expectedModCount)
1598                 throw new ConcurrentModificationException();
1599             current = null;
1600             removeNode(p.hash, p.key, null, false, false);
1601             expectedModCount = modCount;
1602         }
1603     }
1604 
1605     final class KeyIterator extends HashIterator
1606         implements Iterator&lt;K&gt; {
1607         public final K next() { return nextNode().key; }
1608     }
1609 
1610     final class ValueIterator extends HashIterator
1611         implements Iterator&lt;V&gt; {
1612         public final V next() { return nextNode().value; }
1613     }
1614 
1615     final class EntryIterator extends HashIterator
1616         implements Iterator&lt;Map.Entry&lt;K,V&gt;&gt; {
1617         public final Map.Entry&lt;K,V&gt; next() { return nextNode(); }
1618     }
1619 
1620     /* ------------------------------------------------------------ */
1621     // spliterators
1622 
1623     static class HashMapSpliterator&lt;K,V&gt; {
1624         final HashMap&lt;K,V&gt; map;
1625         Node&lt;K,V&gt; current;          // current node
1626         int index;                  // current index, modified on advance/split
1627         int fence;                  // one past last index
1628         int est;                    // size estimate
1629         int expectedModCount;       // for comodification checks
1630 
1631         HashMapSpliterator(HashMap&lt;K,V&gt; m, int origin,
1632                            int fence, int est,
1633                            int expectedModCount) {
1634             this.map = m;
1635             this.index = origin;
1636             this.fence = fence;
1637             this.est = est;
1638             this.expectedModCount = expectedModCount;
1639         }
1640 
1641         final int getFence() { // initialize fence and size on first use
1642             int hi;
1643             if ((hi = fence) &lt; 0) {
1644                 HashMap&lt;K,V&gt; m = map;
1645                 est = m.size;
1646                 expectedModCount = m.modCount;
1647                 Node&lt;K,V&gt;[] tab = m.table;
1648                 hi = fence = (tab == null) ? 0 : tab.length;
1649             }
1650             return hi;
1651         }
1652 
1653         public final long estimateSize() {
1654             getFence(); // force init
1655             return (long) est;
1656         }
1657     }
1658 
1659     static final class KeySpliterator&lt;K,V&gt;
1660         extends HashMapSpliterator&lt;K,V&gt;
1661         implements Spliterator&lt;K&gt; {
1662         KeySpliterator(HashMap&lt;K,V&gt; m, int origin, int fence, int est,
1663                        int expectedModCount) {
1664             super(m, origin, fence, est, expectedModCount);
1665         }
1666 
1667         public KeySpliterator&lt;K,V&gt; trySplit() {
1668             int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1;
1669             return (lo &gt;= mid || current != null) ? null :
1670                 new KeySpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= 1,
1671                                         expectedModCount);
1672         }
1673 
1674         public void forEachRemaining(Consumer&lt;? super K&gt; action) {
1675             int i, hi, mc;
1676             if (action == null)
1677                 throw new NullPointerException();
1678             HashMap&lt;K,V&gt; m = map;
1679             Node&lt;K,V&gt;[] tab = m.table;
1680             if ((hi = fence) &lt; 0) {
1681                 mc = expectedModCount = m.modCount;
1682                 hi = fence = (tab == null) ? 0 : tab.length;
1683             }
1684             else
1685                 mc = expectedModCount;
1686             if (tab != null &amp;&amp; tab.length &gt;= hi &amp;&amp;
1687                 (i = index) &gt;= 0 &amp;&amp; (i &lt; (index = hi) || current != null)) {
1688                 Node&lt;K,V&gt; p = current;
1689                 current = null;
1690                 do {
1691                     if (p == null)
1692                         p = tab[i++];
1693                     else {
1694                         action.accept(p.key);
1695                         p = p.next;
1696                     }
1697                 } while (p != null || i &lt; hi);
1698                 if (m.modCount != mc)
1699                     throw new ConcurrentModificationException();
1700             }
1701         }
1702 
1703         public boolean tryAdvance(Consumer&lt;? super K&gt; action) {
1704             int hi;
1705             if (action == null)
1706                 throw new NullPointerException();
1707             Node&lt;K,V&gt;[] tab = map.table;
1708             if (tab != null &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= 0) {
1709                 while (current != null || index &lt; hi) {
1710                     if (current == null)
1711                         current = tab[index++];
1712                     else {
1713                         K k = current.key;
1714                         current = current.next;
1715                         action.accept(k);
1716                         if (map.modCount != expectedModCount)
1717                             throw new ConcurrentModificationException();
1718                         return true;
1719                     }
1720                 }
1721             }
1722             return false;
1723         }
1724 
1725         public int characteristics() {
1726             return (fence &lt; 0 || est == map.size ? Spliterator.SIZED : 0) |
1727                 Spliterator.DISTINCT;
1728         }
1729     }
1730 
1731     static final class ValueSpliterator&lt;K,V&gt;
1732         extends HashMapSpliterator&lt;K,V&gt;
1733         implements Spliterator&lt;V&gt; {
1734         ValueSpliterator(HashMap&lt;K,V&gt; m, int origin, int fence, int est,
1735                          int expectedModCount) {
1736             super(m, origin, fence, est, expectedModCount);
1737         }
1738 
1739         public ValueSpliterator&lt;K,V&gt; trySplit() {
1740             int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1;
1741             return (lo &gt;= mid || current != null) ? null :
1742                 new ValueSpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= 1,
1743                                           expectedModCount);
1744         }
1745 
1746         public void forEachRemaining(Consumer&lt;? super V&gt; action) {
1747             int i, hi, mc;
1748             if (action == null)
1749                 throw new NullPointerException();
1750             HashMap&lt;K,V&gt; m = map;
1751             Node&lt;K,V&gt;[] tab = m.table;
1752             if ((hi = fence) &lt; 0) {
1753                 mc = expectedModCount = m.modCount;
1754                 hi = fence = (tab == null) ? 0 : tab.length;
1755             }
1756             else
1757                 mc = expectedModCount;
1758             if (tab != null &amp;&amp; tab.length &gt;= hi &amp;&amp;
1759                 (i = index) &gt;= 0 &amp;&amp; (i &lt; (index = hi) || current != null)) {
1760                 Node&lt;K,V&gt; p = current;
1761                 current = null;
1762                 do {
1763                     if (p == null)
1764                         p = tab[i++];
1765                     else {
1766                         action.accept(p.value);
1767                         p = p.next;
1768                     }
1769                 } while (p != null || i &lt; hi);
1770                 if (m.modCount != mc)
1771                     throw new ConcurrentModificationException();
1772             }
1773         }
1774 
1775         public boolean tryAdvance(Consumer&lt;? super V&gt; action) {
1776             int hi;
1777             if (action == null)
1778                 throw new NullPointerException();
1779             Node&lt;K,V&gt;[] tab = map.table;
1780             if (tab != null &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= 0) {
1781                 while (current != null || index &lt; hi) {
1782                     if (current == null)
1783                         current = tab[index++];
1784                     else {
1785                         V v = current.value;
1786                         current = current.next;
1787                         action.accept(v);
1788                         if (map.modCount != expectedModCount)
1789                             throw new ConcurrentModificationException();
1790                         return true;
1791                     }
1792                 }
1793             }
1794             return false;
1795         }
1796 
1797         public int characteristics() {
1798             return (fence &lt; 0 || est == map.size ? Spliterator.SIZED : 0);
1799         }
1800     }
1801 
1802     static final class EntrySpliterator&lt;K,V&gt;
1803         extends HashMapSpliterator&lt;K,V&gt;
1804         implements Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; {
1805         EntrySpliterator(HashMap&lt;K,V&gt; m, int origin, int fence, int est,
1806                          int expectedModCount) {
1807             super(m, origin, fence, est, expectedModCount);
1808         }
1809 
1810         public EntrySpliterator&lt;K,V&gt; trySplit() {
1811             int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1;
1812             return (lo &gt;= mid || current != null) ? null :
1813                 new EntrySpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= 1,
1814                                           expectedModCount);
1815         }
1816 
1817         public void forEachRemaining(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) {
1818             int i, hi, mc;
1819             if (action == null)
1820                 throw new NullPointerException();
1821             HashMap&lt;K,V&gt; m = map;
1822             Node&lt;K,V&gt;[] tab = m.table;
1823             if ((hi = fence) &lt; 0) {
1824                 mc = expectedModCount = m.modCount;
1825                 hi = fence = (tab == null) ? 0 : tab.length;
1826             }
1827             else
1828                 mc = expectedModCount;
1829             if (tab != null &amp;&amp; tab.length &gt;= hi &amp;&amp;
1830                 (i = index) &gt;= 0 &amp;&amp; (i &lt; (index = hi) || current != null)) {
1831                 Node&lt;K,V&gt; p = current;
1832                 current = null;
1833                 do {
1834                     if (p == null)
1835                         p = tab[i++];
1836                     else {
1837                         action.accept(p);
1838                         p = p.next;
1839                     }
1840                 } while (p != null || i &lt; hi);
1841                 if (m.modCount != mc)
1842                     throw new ConcurrentModificationException();
1843             }
1844         }
1845 
1846         public boolean tryAdvance(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) {
1847             int hi;
1848             if (action == null)
1849                 throw new NullPointerException();
1850             Node&lt;K,V&gt;[] tab = map.table;
1851             if (tab != null &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= 0) {
1852                 while (current != null || index &lt; hi) {
1853                     if (current == null)
1854                         current = tab[index++];
1855                     else {
1856                         Node&lt;K,V&gt; e = current;
1857                         current = current.next;
1858                         action.accept(e);
1859                         if (map.modCount != expectedModCount)
1860                             throw new ConcurrentModificationException();
1861                         return true;
1862                     }
1863                 }
1864             }
1865             return false;
1866         }
1867 
1868         public int characteristics() {
1869             return (fence &lt; 0 || est == map.size ? Spliterator.SIZED : 0) |
1870                 Spliterator.DISTINCT;
1871         }
1872     }
1873 
1874     /* ------------------------------------------------------------ */
1875     // LinkedHashMap support
1876 
1877 
1878     /*
1879      * The following package-protected methods are designed to be
1880      * overridden by LinkedHashMap, but not by any other subclass.
1881      * Nearly all other internal methods are also package-protected
1882      * but are declared final, so can be used by LinkedHashMap, view
1883      * classes, and HashSet.
1884      */
1885 
1886     // Create a regular (non-tree) node
1887     Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) {
1888         return new Node&lt;&gt;(hash, key, value, next);
1889     }
1890 
1891     // For conversion from TreeNodes to plain nodes
1892     Node&lt;K,V&gt; replacementNode(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next) {
1893         return new Node&lt;&gt;(p.hash, p.key, p.value, next);
1894     }
1895 
1896     // Create a tree bin node
1897     TreeNode&lt;K,V&gt; newTreeNode(int hash, K key, V value, Node&lt;K,V&gt; next) {
1898         return new TreeNode&lt;&gt;(hash, key, value, next);
1899     }
1900 
1901     // For treeifyBin
1902     TreeNode&lt;K,V&gt; replacementTreeNode(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next) {
1903         return new TreeNode&lt;&gt;(p.hash, p.key, p.value, next);
1904     }
1905 
1906     /**
1907      * Reset to initial default state.  Called by clone and readObject.
1908      */
1909     void reinitialize() {
1910         table = null;
1911         entrySet = null;
1912         keySet = null;
1913         values = null;
1914         modCount = 0;
1915         threshold = 0;
1916         size = 0;
1917     }
1918 
1919     // Callbacks to allow LinkedHashMap post-actions
1920     void afterNodeAccess(Node&lt;K,V&gt; p) { }
1921     void afterNodeInsertion(boolean evict) { }
1922     void afterNodeRemoval(Node&lt;K,V&gt; p) { }
1923 
1924     // Called only from writeObject, to ensure compatible ordering.
1925     void internalWriteEntries(java.io.ObjectOutputStream s) throws IOException {
1926         Node&lt;K,V&gt;[] tab;
1927         if (size &gt; 0 &amp;&amp; (tab = table) != null) {
1928             for (Node&lt;K,V&gt; e : tab) {
1929                 for (; e != null; e = e.next) {
1930                     s.writeObject(e.key);
1931                     s.writeObject(e.value);
1932                 }
1933             }
1934         }
1935     }
1936 
1937     /* ------------------------------------------------------------ */
1938     // Tree bins
1939 
1940     /**
1941      * Entry for Tree bins. Extends LinkedHashMap.Entry (which in turn
1942      * extends Node) so can be used as extension of either regular or
1943      * linked node.
1944      */
1945     static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; {
1946         TreeNode&lt;K,V&gt; parent;  // red-black tree links
1947         TreeNode&lt;K,V&gt; left;
1948         TreeNode&lt;K,V&gt; right;
1949         TreeNode&lt;K,V&gt; prev;    // needed to unlink next upon deletion
1950         boolean red;
1951         TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) {
1952             super(hash, key, val, next);
1953         }
1954 
1955         /**
1956          * Returns root of tree containing this node.
1957          */
1958         final TreeNode&lt;K,V&gt; root() {
1959             for (TreeNode&lt;K,V&gt; r = this, p;;) {
1960                 if ((p = r.parent) == null)
1961                     return r;
1962                 r = p;
1963             }
1964         }
1965 
1966         /**
1967          * Ensures that the given root is the first node of its bin.
1968          */
1969         static &lt;K,V&gt; void moveRootToFront(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root) {
1970             int n;
1971             if (root != null &amp;&amp; tab != null &amp;&amp; (n = tab.length) &gt; 0) {
1972                 int index = (n - 1) &amp; root.hash;
1973                 TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index];
1974                 if (root != first) {
1975                     Node&lt;K,V&gt; rn;
1976                     tab[index] = root;
1977                     TreeNode&lt;K,V&gt; rp = root.prev;
1978                     if ((rn = root.next) != null)
1979                         ((TreeNode&lt;K,V&gt;)rn).prev = rp;
1980                     if (rp != null)
1981                         rp.next = rn;
1982                     if (first != null)
1983                         first.prev = root;
1984                     root.next = first;
1985                     root.prev = null;
1986                 }
1987                 assert checkInvariants(root);
1988             }
1989         }
1990 
1991         /**
1992          * Finds the node starting at root p with the given hash and key.
1993          * The kc argument caches comparableClassFor(key) upon first use
1994          * comparing keys.
1995          */
1996         final TreeNode&lt;K,V&gt; find(int h, Object k, Class&lt;?&gt; kc) {
1997             TreeNode&lt;K,V&gt; p = this;
1998             do {
1999                 int ph, dir; K pk;
2000                 TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;
2001                 if ((ph = p.hash) &gt; h)
2002                     p = pl;
2003                 else if (ph &lt; h)
2004                     p = pr;
2005                 else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk)))
2006                     return p;
2007                 else if (pl == null)
2008                     p = pr;
2009                 else if (pr == null)
2010                     p = pl;
2011                 else if ((kc != null ||
2012                           (kc = comparableClassFor(k)) != null) &amp;&amp;
2013                          (dir = compareComparables(kc, k, pk)) != 0)
2014                     p = (dir &lt; 0) ? pl : pr;
2015                 else if ((q = pr.find(h, k, kc)) != null)
2016                     return q;
2017                 else
2018                     p = pl;
2019             } while (p != null);
2020             return null;
2021         }
2022 
2023         /**
2024          * Calls find for root node.
2025          */
2026         final TreeNode&lt;K,V&gt; getTreeNode(int h, Object k) {
2027             return ((parent != null) ? root() : this).find(h, k, null);
2028         }
2029 
2030         /**
2031          * Tie-breaking utility for ordering insertions when equal
2032          * hashCodes and non-comparable. We don&#39;t require a total
2033          * order, just a consistent insertion rule to maintain
2034          * equivalence across rebalancings. Tie-breaking further than
2035          * necessary simplifies testing a bit.
2036          */
2037         static int tieBreakOrder(Object a, Object b) {
2038             int d;
2039             if (a == null || b == null ||
2040                 (d = a.getClass().getName().
2041                  compareTo(b.getClass().getName())) == 0)
2042                 d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ?
2043                      -1 : 1);
2044             return d;
2045         }
2046 
2047         /**
2048          * Forms tree of the nodes linked from this node.
2049          */
2050         final void treeify(Node&lt;K,V&gt;[] tab) {
2051             TreeNode&lt;K,V&gt; root = null;
2052             for (TreeNode&lt;K,V&gt; x = this, next; x != null; x = next) {
2053                 next = (TreeNode&lt;K,V&gt;)x.next;
2054                 x.left = x.right = null;
2055                 if (root == null) {
2056                     x.parent = null;
2057                     x.red = false;
2058                     root = x;
2059                 }
2060                 else {
2061                     K k = x.key;
2062                     int h = x.hash;
2063                     Class&lt;?&gt; kc = null;
2064                     for (TreeNode&lt;K,V&gt; p = root;;) {
2065                         int dir, ph;
2066                         K pk = p.key;
2067                         if ((ph = p.hash) &gt; h)
2068                             dir = -1;
2069                         else if (ph &lt; h)
2070                             dir = 1;
2071                         else if ((kc == null &amp;&amp;
2072                                   (kc = comparableClassFor(k)) == null) ||
2073                                  (dir = compareComparables(kc, k, pk)) == 0)
2074                             dir = tieBreakOrder(k, pk);
2075 
2076                         TreeNode&lt;K,V&gt; xp = p;
2077                         if ((p = (dir &lt;= 0) ? p.left : p.right) == null) {
2078                             x.parent = xp;
2079                             if (dir &lt;= 0)
2080                                 xp.left = x;
2081                             else
2082                                 xp.right = x;
2083                             root = balanceInsertion(root, x);
2084                             break;
2085                         }
2086                     }
2087                 }
2088             }
2089             moveRootToFront(tab, root);
2090         }
2091 
2092         /**
2093          * Returns a list of non-TreeNodes replacing those linked from
2094          * this node.
2095          */
2096         final Node&lt;K,V&gt; untreeify(HashMap&lt;K,V&gt; map) {
2097             Node&lt;K,V&gt; hd = null, tl = null;
2098             for (Node&lt;K,V&gt; q = this; q != null; q = q.next) {
2099                 Node&lt;K,V&gt; p = map.replacementNode(q, null);
2100                 if (tl == null)
2101                     hd = p;
2102                 else
2103                     tl.next = p;
2104                 tl = p;
2105             }
2106             return hd;
2107         }
2108 
2109         /**
2110          * Tree version of putVal.
2111          */
2112         final TreeNode&lt;K,V&gt; putTreeVal(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,
2113                                        int h, K k, V v) {
2114             Class&lt;?&gt; kc = null;
2115             boolean searched = false;
2116             TreeNode&lt;K,V&gt; root = (parent != null) ? root() : this;
2117             for (TreeNode&lt;K,V&gt; p = root;;) {
2118                 int dir, ph; K pk;
2119                 if ((ph = p.hash) &gt; h)
2120                     dir = -1;
2121                 else if (ph &lt; h)
2122                     dir = 1;
2123                 else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk)))
2124                     return p;
2125                 else if ((kc == null &amp;&amp;
2126                           (kc = comparableClassFor(k)) == null) ||
2127                          (dir = compareComparables(kc, k, pk)) == 0) {
2128                     if (!searched) {
2129                         TreeNode&lt;K,V&gt; q, ch;
2130                         searched = true;
2131                         if (((ch = p.left) != null &amp;&amp;
2132                              (q = ch.find(h, k, kc)) != null) ||
2133                             ((ch = p.right) != null &amp;&amp;
2134                              (q = ch.find(h, k, kc)) != null))
2135                             return q;
2136                     }
2137                     dir = tieBreakOrder(k, pk);
2138                 }
2139 
2140                 TreeNode&lt;K,V&gt; xp = p;
2141                 if ((p = (dir &lt;= 0) ? p.left : p.right) == null) {
2142                     Node&lt;K,V&gt; xpn = xp.next;
2143                     TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);
2144                     if (dir &lt;= 0)
2145                         xp.left = x;
2146                     else
2147                         xp.right = x;
2148                     xp.next = x;
2149                     x.parent = x.prev = xp;
2150                     if (xpn != null)
2151                         ((TreeNode&lt;K,V&gt;)xpn).prev = x;
2152                     moveRootToFront(tab, balanceInsertion(root, x));
2153                     return null;
2154                 }
2155             }
2156         }
2157 
2158         /**
2159          * Removes the given node, that must be present before this call.
2160          * This is messier than typical red-black deletion code because we
2161          * cannot swap the contents of an interior node with a leaf
2162          * successor that is pinned by &quot;next&quot; pointers that are accessible
2163          * independently during traversal. So instead we swap the tree
2164          * linkages. If the current tree appears to have too few nodes,
2165          * the bin is converted back to a plain bin. (The test triggers
2166          * somewhere between 2 and 6 nodes, depending on tree structure).
2167          */
2168         final void removeTreeNode(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,
2169                                   boolean movable) {
2170             int n;
2171             if (tab == null || (n = tab.length) == 0)
2172                 return;
2173             int index = (n - 1) &amp; hash;
2174             TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl;
2175             TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev;
2176             if (pred == null)
2177                 tab[index] = first = succ;
2178             else
2179                 pred.next = succ;
2180             if (succ != null)
2181                 succ.prev = pred;
2182             if (first == null)
2183                 return;
2184             if (root.parent != null)
2185                 root = root.root();
2186             if (root == null
2187                 || (movable
2188                     &amp;&amp; (root.right == null
2189                         || (rl = root.left) == null
2190                         || rl.left == null))) {
2191                 tab[index] = first.untreeify(map);  // too small
2192                 return;
2193             }
2194             TreeNode&lt;K,V&gt; p = this, pl = left, pr = right, replacement;
2195             if (pl != null &amp;&amp; pr != null) {
2196                 TreeNode&lt;K,V&gt; s = pr, sl;
2197                 while ((sl = s.left) != null) // find successor
2198                     s = sl;
2199                 boolean c = s.red; s.red = p.red; p.red = c; // swap colors
2200                 TreeNode&lt;K,V&gt; sr = s.right;
2201                 TreeNode&lt;K,V&gt; pp = p.parent;
2202                 if (s == pr) { // p was s&#39;s direct parent
2203                     p.parent = s;
2204                     s.right = p;
2205                 }
2206                 else {
2207                     TreeNode&lt;K,V&gt; sp = s.parent;
2208                     if ((p.parent = sp) != null) {
2209                         if (s == sp.left)
2210                             sp.left = p;
2211                         else
2212                             sp.right = p;
2213                     }
2214                     if ((s.right = pr) != null)
2215                         pr.parent = s;
2216                 }
2217                 p.left = null;
2218                 if ((p.right = sr) != null)
2219                     sr.parent = p;
2220                 if ((s.left = pl) != null)
2221                     pl.parent = s;
2222                 if ((s.parent = pp) == null)
2223                     root = s;
2224                 else if (p == pp.left)
2225                     pp.left = s;
2226                 else
2227                     pp.right = s;
2228                 if (sr != null)
2229                     replacement = sr;
2230                 else
2231                     replacement = p;
2232             }
2233             else if (pl != null)
2234                 replacement = pl;
2235             else if (pr != null)
2236                 replacement = pr;
2237             else
2238                 replacement = p;
2239             if (replacement != p) {
2240                 TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent;
2241                 if (pp == null)
2242                     (root = replacement).red = false;
2243                 else if (p == pp.left)
2244                     pp.left = replacement;
2245                 else
2246                     pp.right = replacement;
2247                 p.left = p.right = p.parent = null;
2248             }
2249 
2250             TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement);
2251 
2252             if (replacement == p) {  // detach
2253                 TreeNode&lt;K,V&gt; pp = p.parent;
2254                 p.parent = null;
2255                 if (pp != null) {
2256                     if (p == pp.left)
2257                         pp.left = null;
2258                     else if (p == pp.right)
2259                         pp.right = null;
2260                 }
2261             }
2262             if (movable)
2263                 moveRootToFront(tab, r);
2264         }
2265 
2266         /**
2267          * Splits nodes in a tree bin into lower and upper tree bins,
2268          * or untreeifies if now too small. Called only from resize;
2269          * see above discussion about split bits and indices.
2270          *
2271          * @param map the map
2272          * @param tab the table for recording bin heads
2273          * @param index the index of the table being split
2274          * @param bit the bit of hash to split on
2275          */
2276         final void split(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int index, int bit) {
2277             TreeNode&lt;K,V&gt; b = this;
2278             // Relink into lo and hi lists, preserving order
2279             TreeNode&lt;K,V&gt; loHead = null, loTail = null;
2280             TreeNode&lt;K,V&gt; hiHead = null, hiTail = null;
2281             int lc = 0, hc = 0;
2282             for (TreeNode&lt;K,V&gt; e = b, next; e != null; e = next) {
2283                 next = (TreeNode&lt;K,V&gt;)e.next;
2284                 e.next = null;
2285                 if ((e.hash &amp; bit) == 0) {
2286                     if ((e.prev = loTail) == null)
2287                         loHead = e;
2288                     else
2289                         loTail.next = e;
2290                     loTail = e;
2291                     ++lc;
2292                 }
2293                 else {
2294                     if ((e.prev = hiTail) == null)
2295                         hiHead = e;
2296                     else
2297                         hiTail.next = e;
2298                     hiTail = e;
2299                     ++hc;
2300                 }
2301             }
2302 
2303             if (loHead != null) {
2304                 if (lc &lt;= UNTREEIFY_THRESHOLD)
2305                     tab[index] = loHead.untreeify(map);
2306                 else {
2307                     tab[index] = loHead;
2308                     if (hiHead != null) // (else is already treeified)
2309                         loHead.treeify(tab);
2310                 }
2311             }
2312             if (hiHead != null) {
2313                 if (hc &lt;= UNTREEIFY_THRESHOLD)
2314                     tab[index + bit] = hiHead.untreeify(map);
2315                 else {
2316                     tab[index + bit] = hiHead;
2317                     if (loHead != null)
2318                         hiHead.treeify(tab);
2319                 }
2320             }
2321         }
2322 
2323         /* ------------------------------------------------------------ */
2324         // Red-black tree methods, all adapted from CLR
2325 
2326         static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateLeft(TreeNode&lt;K,V&gt; root,
2327                                               TreeNode&lt;K,V&gt; p) {
2328             TreeNode&lt;K,V&gt; r, pp, rl;
2329             if (p != null &amp;&amp; (r = p.right) != null) {
2330                 if ((rl = p.right = r.left) != null)
2331                     rl.parent = p;
2332                 if ((pp = r.parent = p.parent) == null)
2333                     (root = r).red = false;
2334                 else if (pp.left == p)
2335                     pp.left = r;
2336                 else
2337                     pp.right = r;
2338                 r.left = p;
2339                 p.parent = r;
2340             }
2341             return root;
2342         }
2343 
2344         static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateRight(TreeNode&lt;K,V&gt; root,
2345                                                TreeNode&lt;K,V&gt; p) {
2346             TreeNode&lt;K,V&gt; l, pp, lr;
2347             if (p != null &amp;&amp; (l = p.left) != null) {
2348                 if ((lr = p.left = l.right) != null)
2349                     lr.parent = p;
2350                 if ((pp = l.parent = p.parent) == null)
2351                     (root = l).red = false;
2352                 else if (pp.right == p)
2353                     pp.right = l;
2354                 else
2355                     pp.left = l;
2356                 l.right = p;
2357                 p.parent = l;
2358             }
2359             return root;
2360         }
2361 
2362         static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceInsertion(TreeNode&lt;K,V&gt; root,
2363                                                     TreeNode&lt;K,V&gt; x) {
2364             x.red = true;
2365             for (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) {
2366                 if ((xp = x.parent) == null) {
2367                     x.red = false;
2368                     return x;
2369                 }
2370                 else if (!xp.red || (xpp = xp.parent) == null)
2371                     return root;
2372                 if (xp == (xppl = xpp.left)) {
2373                     if ((xppr = xpp.right) != null &amp;&amp; xppr.red) {
2374                         xppr.red = false;
2375                         xp.red = false;
2376                         xpp.red = true;
2377                         x = xpp;
2378                     }
2379                     else {
2380                         if (x == xp.right) {
2381                             root = rotateLeft(root, x = xp);
2382                             xpp = (xp = x.parent) == null ? null : xp.parent;
2383                         }
2384                         if (xp != null) {
2385                             xp.red = false;
2386                             if (xpp != null) {
2387                                 xpp.red = true;
2388                                 root = rotateRight(root, xpp);
2389                             }
2390                         }
2391                     }
2392                 }
2393                 else {
2394                     if (xppl != null &amp;&amp; xppl.red) {
2395                         xppl.red = false;
2396                         xp.red = false;
2397                         xpp.red = true;
2398                         x = xpp;
2399                     }
2400                     else {
2401                         if (x == xp.left) {
2402                             root = rotateRight(root, x = xp);
2403                             xpp = (xp = x.parent) == null ? null : xp.parent;
2404                         }
2405                         if (xp != null) {
2406                             xp.red = false;
2407                             if (xpp != null) {
2408                                 xpp.red = true;
2409                                 root = rotateLeft(root, xpp);
2410                             }
2411                         }
2412                     }
2413                 }
2414             }
2415         }
2416 
2417         static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceDeletion(TreeNode&lt;K,V&gt; root,
2418                                                    TreeNode&lt;K,V&gt; x) {
2419             for (TreeNode&lt;K,V&gt; xp, xpl, xpr;;) {
2420                 if (x == null || x == root)
2421                     return root;
2422                 else if ((xp = x.parent) == null) {
2423                     x.red = false;
2424                     return x;
2425                 }
2426                 else if (x.red) {
2427                     x.red = false;
2428                     return root;
2429                 }
2430                 else if ((xpl = xp.left) == x) {
2431                     if ((xpr = xp.right) != null &amp;&amp; xpr.red) {
2432                         xpr.red = false;
2433                         xp.red = true;
2434                         root = rotateLeft(root, xp);
2435                         xpr = (xp = x.parent) == null ? null : xp.right;
2436                     }
2437                     if (xpr == null)
2438                         x = xp;
2439                     else {
2440                         TreeNode&lt;K,V&gt; sl = xpr.left, sr = xpr.right;
2441                         if ((sr == null || !sr.red) &amp;&amp;
2442                             (sl == null || !sl.red)) {
2443                             xpr.red = true;
2444                             x = xp;
2445                         }
2446                         else {
2447                             if (sr == null || !sr.red) {
2448                                 if (sl != null)
2449                                     sl.red = false;
2450                                 xpr.red = true;
2451                                 root = rotateRight(root, xpr);
2452                                 xpr = (xp = x.parent) == null ?
2453                                     null : xp.right;
2454                             }
2455                             if (xpr != null) {
2456                                 xpr.red = (xp == null) ? false : xp.red;
2457                                 if ((sr = xpr.right) != null)
2458                                     sr.red = false;
2459                             }
2460                             if (xp != null) {
2461                                 xp.red = false;
2462                                 root = rotateLeft(root, xp);
2463                             }
2464                             x = root;
2465                         }
2466                     }
2467                 }
2468                 else { // symmetric
2469                     if (xpl != null &amp;&amp; xpl.red) {
2470                         xpl.red = false;
2471                         xp.red = true;
2472                         root = rotateRight(root, xp);
2473                         xpl = (xp = x.parent) == null ? null : xp.left;
2474                     }
2475                     if (xpl == null)
2476                         x = xp;
2477                     else {
2478                         TreeNode&lt;K,V&gt; sl = xpl.left, sr = xpl.right;
2479                         if ((sl == null || !sl.red) &amp;&amp;
2480                             (sr == null || !sr.red)) {
2481                             xpl.red = true;
2482                             x = xp;
2483                         }
2484                         else {
2485                             if (sl == null || !sl.red) {
2486                                 if (sr != null)
2487                                     sr.red = false;
2488                                 xpl.red = true;
2489                                 root = rotateLeft(root, xpl);
2490                                 xpl = (xp = x.parent) == null ?
2491                                     null : xp.left;
2492                             }
2493                             if (xpl != null) {
2494                                 xpl.red = (xp == null) ? false : xp.red;
2495                                 if ((sl = xpl.left) != null)
2496                                     sl.red = false;
2497                             }
2498                             if (xp != null) {
2499                                 xp.red = false;
2500                                 root = rotateRight(root, xp);
2501                             }
2502                             x = root;
2503                         }
2504                     }
2505                 }
2506             }
2507         }
2508 
2509         /**
2510          * Recursive invariant check
2511          */
2512         static &lt;K,V&gt; boolean checkInvariants(TreeNode&lt;K,V&gt; t) {
2513             TreeNode&lt;K,V&gt; tp = t.parent, tl = t.left, tr = t.right,
2514                 tb = t.prev, tn = (TreeNode&lt;K,V&gt;)t.next;
2515             if (tb != null &amp;&amp; tb.next != t)
2516                 return false;
2517             if (tn != null &amp;&amp; tn.prev != t)
2518                 return false;
2519             if (tp != null &amp;&amp; t != tp.left &amp;&amp; t != tp.right)
2520                 return false;
2521             if (tl != null &amp;&amp; (tl.parent != t || tl.hash &gt; t.hash))
2522                 return false;
2523             if (tr != null &amp;&amp; (tr.parent != t || tr.hash &lt; t.hash))
2524                 return false;
2525             if (t.red &amp;&amp; tl != null &amp;&amp; tl.red &amp;&amp; tr != null &amp;&amp; tr.red)
2526                 return false;
2527             if (tl != null &amp;&amp; !checkInvariants(tl))
2528                 return false;
2529             if (tr != null &amp;&amp; !checkInvariants(tr))
2530                 return false;
2531             return true;
2532         }
2533     }
2534 
2535 }
    </pre>
  </body>
</html>
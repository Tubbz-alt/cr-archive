<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/invoke/X-VarHandleByteArrayView.java.template</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="X-VarHandle.java.template.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../reflect/Executable.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/X-VarHandleByteArrayView.java.template</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 package java.lang.invoke;
  26 
  27 import jdk.internal.access.JavaNioAccess;
  28 import jdk.internal.access.SharedSecrets;

  29 import jdk.internal.misc.Unsafe;
  30 import jdk.internal.util.Preconditions;
  31 import jdk.internal.vm.annotation.ForceInline;
  32 
  33 import java.nio.ByteBuffer;
  34 import java.nio.ReadOnlyBufferException;
  35 import java.util.Objects;
  36 
  37 import static java.lang.invoke.MethodHandleStatics.UNSAFE;
  38 
  39 #warn
  40 
  41 final class VarHandleByteArrayAs$Type$s extends VarHandleByteArrayBase {
  42 
  43     static JavaNioAccess nioAccess = SharedSecrets.getJavaNioAccess();
  44 
  45     static final int ALIGN = $BoxType$.BYTES - 1;
  46 
  47 #if[floatingPoint]
  48     @ForceInline
</pre>
<hr />
<pre>
  81 
  82         @Override
  83         final MethodType accessModeTypeUncached(AccessMode accessMode) {
  84             return accessMode.at.accessModeType(byte[].class, $type$.class, int.class);
  85         }
  86 
  87         @ForceInline
  88         static int index(byte[] ba, int index) {
  89             return Preconditions.checkIndex(index, ba.length - ALIGN, null);
  90         }
  91 
  92         @ForceInline
  93         static long address(byte[] ba, int index) {
  94             long address = ((long) index) + Unsafe.ARRAY_BYTE_BASE_OFFSET;
  95             if ((address &amp; ALIGN) != 0)
  96                 throw newIllegalStateExceptionForMisalignedAccess(index);
  97             return address;
  98         }
  99 
 100         @ForceInline
<span class="line-modified"> 101         static $type$ get(ArrayHandle handle, Object oba, int index) {</span>

 102             byte[] ba = (byte[]) oba;
 103 #if[floatingPoint]
 104             $rawType$ rawValue = UNSAFE.get$RawType$Unaligned(
 105                     ba,
 106                     ((long) index(ba, index)) + Unsafe.ARRAY_BYTE_BASE_OFFSET,
 107                     handle.be);
 108             return $Type$.$rawType$BitsTo$Type$(rawValue);
 109 #else[floatingPoint]
 110             return UNSAFE.get$Type$Unaligned(
 111                     ba,
 112                     ((long) index(ba, index)) + Unsafe.ARRAY_BYTE_BASE_OFFSET,
 113                     handle.be);
 114 #end[floatingPoint]
 115         }
 116 
 117         @ForceInline
<span class="line-modified"> 118         static void set(ArrayHandle handle, Object oba, int index, $type$ value) {</span>

 119             byte[] ba = (byte[]) oba;
 120 #if[floatingPoint]
 121             UNSAFE.put$RawType$Unaligned(
 122                     ba,
 123                     ((long) index(ba, index)) + Unsafe.ARRAY_BYTE_BASE_OFFSET,
 124                     $Type$.$type$ToRaw$RawType$Bits(value),
 125                     handle.be);
 126 #else[floatingPoint]
 127             UNSAFE.put$RawType$Unaligned(
 128                     ba,
 129                     ((long) index(ba, index)) + Unsafe.ARRAY_BYTE_BASE_OFFSET,
 130                     value,
 131                     handle.be);
 132 #end[floatingPoint]
 133         }
 134 
 135         @ForceInline
<span class="line-modified"> 136         static $type$ getVolatile(ArrayHandle handle, Object oba, int index) {</span>

 137             byte[] ba = (byte[]) oba;
 138             return convEndian(handle.be,
 139                               UNSAFE.get$RawType$Volatile(
 140                                       ba,
 141                                       address(ba, index(ba, index))));
 142         }
 143 
 144         @ForceInline
<span class="line-modified"> 145         static void setVolatile(ArrayHandle handle, Object oba, int index, $type$ value) {</span>

 146             byte[] ba = (byte[]) oba;
 147             UNSAFE.put$RawType$Volatile(
 148                     ba,
 149                     address(ba, index(ba, index)),
 150                     convEndian(handle.be, value));
 151         }
 152 
 153         @ForceInline
<span class="line-modified"> 154         static $type$ getAcquire(ArrayHandle handle, Object oba, int index) {</span>

 155             byte[] ba = (byte[]) oba;
 156             return convEndian(handle.be,
 157                               UNSAFE.get$RawType$Acquire(
 158                                       ba,
 159                                       address(ba, index(ba, index))));
 160         }
 161 
 162         @ForceInline
<span class="line-modified"> 163         static void setRelease(ArrayHandle handle, Object oba, int index, $type$ value) {</span>

 164             byte[] ba = (byte[]) oba;
 165             UNSAFE.put$RawType$Release(
 166                     ba,
 167                     address(ba, index(ba, index)),
 168                     convEndian(handle.be, value));
 169         }
 170 
 171         @ForceInline
<span class="line-modified"> 172         static $type$ getOpaque(ArrayHandle handle, Object oba, int index) {</span>

 173             byte[] ba = (byte[]) oba;
 174             return convEndian(handle.be,
 175                               UNSAFE.get$RawType$Opaque(
 176                                       ba,
 177                                       address(ba, index(ba, index))));
 178         }
 179 
 180         @ForceInline
<span class="line-modified"> 181         static void setOpaque(ArrayHandle handle, Object oba, int index, $type$ value) {</span>

 182             byte[] ba = (byte[]) oba;
 183             UNSAFE.put$RawType$Opaque(
 184                     ba,
 185                     address(ba, index(ba, index)),
 186                     convEndian(handle.be, value));
 187         }
 188 #if[CAS]
 189 
 190         @ForceInline
<span class="line-modified"> 191         static boolean compareAndSet(ArrayHandle handle, Object oba, int index, $type$ expected, $type$ value) {</span>

 192             byte[] ba = (byte[]) oba;
 193 #if[Object]
 194             return UNSAFE.compareAndSetReference(
 195                     ba,
 196                     address(ba, index(ba, index)),
 197                     convEndian(handle.be, expected), convEndian(handle.be, value));
 198 #else[Object]
 199             return UNSAFE.compareAndSet$RawType$(
 200                     ba,
 201                     address(ba, index(ba, index)),
 202                     convEndian(handle.be, expected), convEndian(handle.be, value));
 203 #end[Object]
 204         }
 205 
 206         @ForceInline
<span class="line-modified"> 207         static $type$ compareAndExchange(ArrayHandle handle, Object oba, int index, $type$ expected, $type$ value) {</span>

 208             byte[] ba = (byte[]) oba;
 209             return convEndian(handle.be,
 210                               UNSAFE.compareAndExchange$RawType$(
 211                                       ba,
 212                                       address(ba, index(ba, index)),
 213                                       convEndian(handle.be, expected), convEndian(handle.be, value)));
 214         }
 215 
 216         @ForceInline
<span class="line-modified"> 217         static $type$ compareAndExchangeAcquire(ArrayHandle handle, Object oba, int index, $type$ expected, $type$ value) {</span>

 218             byte[] ba = (byte[]) oba;
 219             return convEndian(handle.be,
 220                               UNSAFE.compareAndExchange$RawType$Acquire(
 221                                       ba,
 222                                       address(ba, index(ba, index)),
 223                                       convEndian(handle.be, expected), convEndian(handle.be, value)));
 224         }
 225 
 226         @ForceInline
<span class="line-modified"> 227         static $type$ compareAndExchangeRelease(ArrayHandle handle, Object oba, int index, $type$ expected, $type$ value) {</span>

 228             byte[] ba = (byte[]) oba;
 229             return convEndian(handle.be,
 230                               UNSAFE.compareAndExchange$RawType$Release(
 231                                       ba,
 232                                       address(ba, index(ba, index)),
 233                                       convEndian(handle.be, expected), convEndian(handle.be, value)));
 234         }
 235 
 236         @ForceInline
<span class="line-modified"> 237         static boolean weakCompareAndSetPlain(ArrayHandle handle, Object oba, int index, $type$ expected, $type$ value) {</span>

 238             byte[] ba = (byte[]) oba;
 239             return UNSAFE.weakCompareAndSet$RawType$Plain(
 240                     ba,
 241                     address(ba, index(ba, index)),
 242                     convEndian(handle.be, expected), convEndian(handle.be, value));
 243         }
 244 
 245         @ForceInline
<span class="line-modified"> 246         static boolean weakCompareAndSet(ArrayHandle handle, Object oba, int index, $type$ expected, $type$ value) {</span>

 247             byte[] ba = (byte[]) oba;
 248             return UNSAFE.weakCompareAndSet$RawType$(
 249                     ba,
 250                     address(ba, index(ba, index)),
 251                     convEndian(handle.be, expected), convEndian(handle.be, value));
 252         }
 253 
 254         @ForceInline
<span class="line-modified"> 255         static boolean weakCompareAndSetAcquire(ArrayHandle handle, Object oba, int index, $type$ expected, $type$ value) {</span>

 256             byte[] ba = (byte[]) oba;
 257             return UNSAFE.weakCompareAndSet$RawType$Acquire(
 258                     ba,
 259                     address(ba, index(ba, index)),
 260                     convEndian(handle.be, expected), convEndian(handle.be, value));
 261         }
 262 
 263         @ForceInline
<span class="line-modified"> 264         static boolean weakCompareAndSetRelease(ArrayHandle handle, Object oba, int index, $type$ expected, $type$ value) {</span>

 265             byte[] ba = (byte[]) oba;
 266             return UNSAFE.weakCompareAndSet$RawType$Release(
 267                     ba,
 268                     address(ba, index(ba, index)),
 269                     convEndian(handle.be, expected), convEndian(handle.be, value));
 270         }
 271 
 272         @ForceInline
<span class="line-modified"> 273         static $type$ getAndSet(ArrayHandle handle, Object oba, int index, $type$ value) {</span>

 274             byte[] ba = (byte[]) oba;
 275 #if[Object]
 276             return convEndian(handle.be,
 277                               UNSAFE.getAndSetReference(
 278                                       ba,
 279                                       address(ba, index(ba, index)),
 280                                       convEndian(handle.be, value)));
 281 #else[Object]
 282             return convEndian(handle.be,
 283                               UNSAFE.getAndSet$RawType$(
 284                                       ba,
 285                                       address(ba, index(ba, index)),
 286                                       convEndian(handle.be, value)));
 287 #end[Object]
 288         }
 289 
 290         @ForceInline
<span class="line-modified"> 291         static $type$ getAndSetAcquire(ArrayHandle handle, Object oba, int index, $type$ value) {</span>

 292             byte[] ba = (byte[]) oba;
 293             return convEndian(handle.be,
 294                               UNSAFE.getAndSet$RawType$Acquire(
 295                                       ba,
 296                                       address(ba, index(ba, index)),
 297                                       convEndian(handle.be, value)));
 298         }
 299 
 300         @ForceInline
<span class="line-modified"> 301         static $type$ getAndSetRelease(ArrayHandle handle, Object oba, int index, $type$ value) {</span>

 302             byte[] ba = (byte[]) oba;
 303             return convEndian(handle.be,
 304                               UNSAFE.getAndSet$RawType$Release(
 305                                       ba,
 306                                       address(ba, index(ba, index)),
 307                                       convEndian(handle.be, value)));
 308         }
 309 #end[CAS]
 310 #if[AtomicAdd]
 311 
 312         @ForceInline
<span class="line-modified"> 313         static $type$ getAndAdd(ArrayHandle handle, Object oba, int index, $type$ delta) {</span>

 314             byte[] ba = (byte[]) oba;
 315             if (handle.be == BE) {
 316                 return UNSAFE.getAndAdd$RawType$(
 317                         ba,
 318                         address(ba, index(ba, index)),
 319                         delta);
 320             } else {
 321                 return getAndAddConvEndianWithCAS(ba, index, delta);
 322             }
 323         }
 324 
 325         @ForceInline
<span class="line-modified"> 326         static $type$ getAndAddAcquire(ArrayHandle handle, Object oba, int index, $type$ delta) {</span>

 327             byte[] ba = (byte[]) oba;
 328             if (handle.be == BE) {
 329                 return UNSAFE.getAndAdd$RawType$Acquire(
 330                         ba,
 331                         address(ba, index(ba, index)),
 332                         delta);
 333             } else {
 334                 return getAndAddConvEndianWithCAS(ba, index, delta);
 335             }
 336         }
 337 
 338         @ForceInline
<span class="line-modified"> 339         static $type$ getAndAddRelease(ArrayHandle handle, Object oba, int index, $type$ delta) {</span>

 340             byte[] ba = (byte[]) oba;
 341             if (handle.be == BE) {
 342                 return UNSAFE.getAndAdd$RawType$Release(
 343                         ba,
 344                         address(ba, index(ba, index)),
 345                         delta);
 346             } else {
 347                 return getAndAddConvEndianWithCAS(ba, index, delta);
 348             }
 349         }
 350 
 351         @ForceInline
 352         static $type$ getAndAddConvEndianWithCAS(byte[] ba, int index, $type$ delta) {
 353             $type$ nativeExpectedValue, expectedValue;
 354             long offset = address(ba, index(ba, index));
 355             do {
 356                 nativeExpectedValue = UNSAFE.get$RawType$Volatile(ba, offset);
 357                 expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
 358             } while (!UNSAFE.weakCompareAndSet$RawType$(ba, offset,
 359                     nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue + delta)));
 360             return expectedValue;
 361         }
 362 #end[AtomicAdd]
 363 #if[Bitwise]
 364 
 365         @ForceInline
<span class="line-modified"> 366         static $type$ getAndBitwiseOr(ArrayHandle handle, Object oba, int index, $type$ value) {</span>

 367             byte[] ba = (byte[]) oba;
 368             if (handle.be == BE) {
 369                 return UNSAFE.getAndBitwiseOr$RawType$(
 370                         ba,
 371                         address(ba, index(ba, index)),
 372                         value);
 373             } else {
 374                 return getAndBitwiseOrConvEndianWithCAS(ba, index, value);
 375             }
 376         }
 377 
 378         @ForceInline
<span class="line-modified"> 379         static $type$ getAndBitwiseOrRelease(ArrayHandle handle, Object oba, int index, $type$ value) {</span>

 380             byte[] ba = (byte[]) oba;
 381             if (handle.be == BE) {
 382                 return UNSAFE.getAndBitwiseOr$RawType$Release(
 383                         ba,
 384                         address(ba, index(ba, index)),
 385                         value);
 386             } else {
 387                 return getAndBitwiseOrConvEndianWithCAS(ba, index, value);
 388             }
 389         }
 390 
 391         @ForceInline
<span class="line-modified"> 392         static $type$ getAndBitwiseOrAcquire(ArrayHandle handle, Object oba, int index, $type$ value) {</span>

 393             byte[] ba = (byte[]) oba;
 394             if (handle.be == BE) {
 395                 return UNSAFE.getAndBitwiseOr$RawType$Acquire(
 396                         ba,
 397                         address(ba, index(ba, index)),
 398                         value);
 399             } else {
 400                 return getAndBitwiseOrConvEndianWithCAS(ba, index, value);
 401             }
 402         }
 403 
 404         @ForceInline
 405         static $type$ getAndBitwiseOrConvEndianWithCAS(byte[] ba, int index, $type$ value) {
 406             $type$ nativeExpectedValue, expectedValue;
 407             long offset = address(ba, index(ba, index));
 408             do {
 409                 nativeExpectedValue = UNSAFE.get$RawType$Volatile(ba, offset);
 410                 expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
 411             } while (!UNSAFE.weakCompareAndSet$RawType$(ba, offset,
 412                     nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue | value)));
 413             return expectedValue;
 414         }
 415 
 416         @ForceInline
<span class="line-modified"> 417         static $type$ getAndBitwiseAnd(ArrayHandle handle, Object oba, int index, $type$ value) {</span>

 418             byte[] ba = (byte[]) oba;
 419             if (handle.be == BE) {
 420                 return UNSAFE.getAndBitwiseAnd$RawType$(
 421                         ba,
 422                         address(ba, index(ba, index)),
 423                         value);
 424             } else {
 425                 return getAndBitwiseAndConvEndianWithCAS(ba, index, value);
 426             }
 427         }
 428 
 429         @ForceInline
<span class="line-modified"> 430         static $type$ getAndBitwiseAndRelease(ArrayHandle handle, Object oba, int index, $type$ value) {</span>

 431             byte[] ba = (byte[]) oba;
 432             if (handle.be == BE) {
 433                 return UNSAFE.getAndBitwiseAnd$RawType$Release(
 434                         ba,
 435                         address(ba, index(ba, index)),
 436                         value);
 437             } else {
 438                 return getAndBitwiseAndConvEndianWithCAS(ba, index, value);
 439             }
 440         }
 441 
 442         @ForceInline
<span class="line-modified"> 443         static $type$ getAndBitwiseAndAcquire(ArrayHandle handle, Object oba, int index, $type$ value) {</span>

 444             byte[] ba = (byte[]) oba;
 445             if (handle.be == BE) {
 446                 return UNSAFE.getAndBitwiseAnd$RawType$Acquire(
 447                         ba,
 448                         address(ba, index(ba, index)),
 449                         value);
 450             } else {
 451                 return getAndBitwiseAndConvEndianWithCAS(ba, index, value);
 452             }
 453         }
 454 
 455         @ForceInline
 456         static $type$ getAndBitwiseAndConvEndianWithCAS(byte[] ba, int index, $type$ value) {
 457             $type$ nativeExpectedValue, expectedValue;
 458             long offset = address(ba, index(ba, index));
 459             do {
 460                 nativeExpectedValue = UNSAFE.get$RawType$Volatile(ba, offset);
 461                 expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
 462             } while (!UNSAFE.weakCompareAndSet$RawType$(ba, offset,
 463                     nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue &amp; value)));
 464             return expectedValue;
 465         }
 466 
 467         @ForceInline
<span class="line-modified"> 468         static $type$ getAndBitwiseXor(ArrayHandle handle, Object oba, int index, $type$ value) {</span>

 469             byte[] ba = (byte[]) oba;
 470             if (handle.be == BE) {
 471                 return UNSAFE.getAndBitwiseXor$RawType$(
 472                         ba,
 473                         address(ba, index(ba, index)),
 474                         value);
 475             } else {
 476                 return getAndBitwiseXorConvEndianWithCAS(ba, index, value);
 477             }
 478         }
 479 
 480         @ForceInline
<span class="line-modified"> 481         static $type$ getAndBitwiseXorRelease(ArrayHandle handle, Object oba, int index, $type$ value) {</span>

 482             byte[] ba = (byte[]) oba;
 483             if (handle.be == BE) {
 484                 return UNSAFE.getAndBitwiseXor$RawType$Release(
 485                         ba,
 486                         address(ba, index(ba, index)),
 487                         value);
 488             } else {
 489                 return getAndBitwiseXorConvEndianWithCAS(ba, index, value);
 490             }
 491         }
 492 
 493         @ForceInline
<span class="line-modified"> 494         static $type$ getAndBitwiseXorAcquire(ArrayHandle handle, Object oba, int index, $type$ value) {</span>

 495             byte[] ba = (byte[]) oba;
 496             if (handle.be == BE) {
 497                 return UNSAFE.getAndBitwiseXor$RawType$Acquire(
 498                         ba,
 499                         address(ba, index(ba, index)),
 500                         value);
 501             } else {
 502                 return getAndBitwiseXorConvEndianWithCAS(ba, index, value);
 503             }
 504         }
 505 
 506         @ForceInline
 507         static $type$ getAndBitwiseXorConvEndianWithCAS(byte[] ba, int index, $type$ value) {
 508             $type$ nativeExpectedValue, expectedValue;
 509             long offset = address(ba, index(ba, index));
 510             do {
 511                 nativeExpectedValue = UNSAFE.get$RawType$Volatile(ba, offset);
 512                 expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
 513             } while (!UNSAFE.weakCompareAndSet$RawType$(ba, offset,
 514                     nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue ^ value)));
</pre>
<hr />
<pre>
 516         }
 517 #end[Bitwise]
 518 
 519         static final VarForm FORM = new VarForm(ArrayHandle.class, byte[].class, $type$.class, int.class);
 520     }
 521 
 522 
 523     static final class ByteBufferHandle extends ByteArrayViewVarHandle {
 524 
 525         ByteBufferHandle(boolean be) {
 526             super(ByteBufferHandle.FORM, be);
 527         }
 528 
 529         @Override
 530         final MethodType accessModeTypeUncached(AccessMode accessMode) {
 531             return accessMode.at.accessModeType(ByteBuffer.class, $type$.class, int.class);
 532         }
 533 
 534         @ForceInline
 535         static int index(ByteBuffer bb, int index) {
<span class="line-modified"> 536             nioAccess.checkSegment(bb);</span>



 537             return Preconditions.checkIndex(index, UNSAFE.getInt(bb, BUFFER_LIMIT) - ALIGN, null);
 538         }
 539 
 540         @ForceInline
 541         static int indexRO(ByteBuffer bb, int index) {
 542             if (UNSAFE.getBoolean(bb, BYTE_BUFFER_IS_READ_ONLY))
 543                 throw new ReadOnlyBufferException();
 544             return index(bb, index);
 545         }
 546 
 547         @ForceInline
 548         static long address(ByteBuffer bb, int index) {
 549             long address = ((long) index) + UNSAFE.getLong(bb, BUFFER_ADDRESS);
 550             if ((address &amp; ALIGN) != 0)
 551                 throw newIllegalStateExceptionForMisalignedAccess(index);
 552             return address;
 553         }
 554 
 555         @ForceInline
<span class="line-modified"> 556         static $type$ get(ByteBufferHandle handle, Object obb, int index) {</span>

 557             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 558 #if[floatingPoint]
 559             $rawType$ rawValue = UNSAFE.get$RawType$Unaligned(
 560                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 561                     ((long) index(bb, index)) + UNSAFE.getLong(bb, BUFFER_ADDRESS),
 562                     handle.be);
 563             return $Type$.$rawType$BitsTo$Type$(rawValue);
 564 #else[floatingPoint]
 565             return UNSAFE.get$Type$Unaligned(
 566                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 567                     ((long) index(bb, index)) + UNSAFE.getLong(bb, BUFFER_ADDRESS),
 568                     handle.be);
 569 #end[floatingPoint]
 570         }
 571 
 572         @ForceInline
<span class="line-modified"> 573         static void set(ByteBufferHandle handle, Object obb, int index, $type$ value) {</span>

 574             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 575 #if[floatingPoint]
 576             UNSAFE.put$RawType$Unaligned(
 577                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 578                     ((long) indexRO(bb, index)) + UNSAFE.getLong(bb, BUFFER_ADDRESS),
 579                     $Type$.$type$ToRaw$RawType$Bits(value),
 580                     handle.be);
 581 #else[floatingPoint]
 582             UNSAFE.put$Type$Unaligned(
 583                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 584                     ((long) indexRO(bb, index)) + UNSAFE.getLong(bb, BUFFER_ADDRESS),
 585                     value,
 586                     handle.be);
 587 #end[floatingPoint]
 588         }
 589 
 590         @ForceInline
<span class="line-modified"> 591         static $type$ getVolatile(ByteBufferHandle handle, Object obb, int index) {</span>

 592             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 593             return convEndian(handle.be,
 594                               UNSAFE.get$RawType$Volatile(
 595                                       UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 596                                       address(bb, index(bb, index))));
 597         }
 598 
 599         @ForceInline
<span class="line-modified"> 600         static void setVolatile(ByteBufferHandle handle, Object obb, int index, $type$ value) {</span>

 601             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 602             UNSAFE.put$RawType$Volatile(
 603                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 604                     address(bb, indexRO(bb, index)),
 605                     convEndian(handle.be, value));
 606         }
 607 
 608         @ForceInline
<span class="line-modified"> 609         static $type$ getAcquire(ByteBufferHandle handle, Object obb, int index) {</span>

 610             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 611             return convEndian(handle.be,
 612                               UNSAFE.get$RawType$Acquire(
 613                                       UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 614                                       address(bb, index(bb, index))));
 615         }
 616 
 617         @ForceInline
<span class="line-modified"> 618         static void setRelease(ByteBufferHandle handle, Object obb, int index, $type$ value) {</span>

 619             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 620             UNSAFE.put$RawType$Release(
 621                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 622                     address(bb, indexRO(bb, index)),
 623                     convEndian(handle.be, value));
 624         }
 625 
 626         @ForceInline
<span class="line-modified"> 627         static $type$ getOpaque(ByteBufferHandle handle, Object obb, int index) {</span>

 628             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 629             return convEndian(handle.be,
 630                               UNSAFE.get$RawType$Opaque(
 631                                       UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 632                                       address(bb, index(bb, index))));
 633         }
 634 
 635         @ForceInline
<span class="line-modified"> 636         static void setOpaque(ByteBufferHandle handle, Object obb, int index, $type$ value) {</span>

 637             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 638             UNSAFE.put$RawType$Opaque(
 639                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 640                     address(bb, indexRO(bb, index)),
 641                     convEndian(handle.be, value));
 642         }
 643 #if[CAS]
 644 
 645         @ForceInline
<span class="line-modified"> 646         static boolean compareAndSet(ByteBufferHandle handle, Object obb, int index, $type$ expected, $type$ value) {</span>

 647             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 648 #if[Object]
 649             return UNSAFE.compareAndSetReference(
 650                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 651                     address(bb, indexRO(bb, index)),
 652                     convEndian(handle.be, expected), convEndian(handle.be, value));
 653 #else[Object]
 654             return UNSAFE.compareAndSet$RawType$(
 655                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 656                     address(bb, indexRO(bb, index)),
 657                     convEndian(handle.be, expected), convEndian(handle.be, value));
 658 #end[Object]
 659         }
 660 
 661         @ForceInline
<span class="line-modified"> 662         static $type$ compareAndExchange(ByteBufferHandle handle, Object obb, int index, $type$ expected, $type$ value) {</span>

 663             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 664             return convEndian(handle.be,
 665                               UNSAFE.compareAndExchange$RawType$(
 666                                       UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 667                                       address(bb, indexRO(bb, index)),
 668                                       convEndian(handle.be, expected), convEndian(handle.be, value)));
 669         }
 670 
 671         @ForceInline
<span class="line-modified"> 672         static $type$ compareAndExchangeAcquire(ByteBufferHandle handle, Object obb, int index, $type$ expected, $type$ value) {</span>

 673             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 674             return convEndian(handle.be,
 675                               UNSAFE.compareAndExchange$RawType$Acquire(
 676                                       UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 677                                       address(bb, indexRO(bb, index)),
 678                                       convEndian(handle.be, expected), convEndian(handle.be, value)));
 679         }
 680 
 681         @ForceInline
<span class="line-modified"> 682         static $type$ compareAndExchangeRelease(ByteBufferHandle handle, Object obb, int index, $type$ expected, $type$ value) {</span>

 683             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 684             return convEndian(handle.be,
 685                               UNSAFE.compareAndExchange$RawType$Release(
 686                                       UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 687                                       address(bb, indexRO(bb, index)),
 688                                       convEndian(handle.be, expected), convEndian(handle.be, value)));
 689         }
 690 
 691         @ForceInline
<span class="line-modified"> 692         static boolean weakCompareAndSetPlain(ByteBufferHandle handle, Object obb, int index, $type$ expected, $type$ value) {</span>

 693             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 694             return UNSAFE.weakCompareAndSet$RawType$Plain(
 695                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 696                     address(bb, indexRO(bb, index)),
 697                     convEndian(handle.be, expected), convEndian(handle.be, value));
 698         }
 699 
 700         @ForceInline
<span class="line-modified"> 701         static boolean weakCompareAndSet(ByteBufferHandle handle, Object obb, int index, $type$ expected, $type$ value) {</span>

 702             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 703             return UNSAFE.weakCompareAndSet$RawType$(
 704                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 705                     address(bb, indexRO(bb, index)),
 706                     convEndian(handle.be, expected), convEndian(handle.be, value));
 707         }
 708 
 709         @ForceInline
<span class="line-modified"> 710         static boolean weakCompareAndSetAcquire(ByteBufferHandle handle, Object obb, int index, $type$ expected, $type$ value) {</span>

 711             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 712             return UNSAFE.weakCompareAndSet$RawType$Acquire(
 713                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 714                     address(bb, indexRO(bb, index)),
 715                     convEndian(handle.be, expected), convEndian(handle.be, value));
 716         }
 717 
 718         @ForceInline
<span class="line-modified"> 719         static boolean weakCompareAndSetRelease(ByteBufferHandle handle, Object obb, int index, $type$ expected, $type$ value) {</span>

 720             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 721             return UNSAFE.weakCompareAndSet$RawType$Release(
 722                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 723                     address(bb, indexRO(bb, index)),
 724                     convEndian(handle.be, expected), convEndian(handle.be, value));
 725         }
 726 
 727         @ForceInline
<span class="line-modified"> 728         static $type$ getAndSet(ByteBufferHandle handle, Object obb, int index, $type$ value) {</span>

 729             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 730 #if[Object]
 731             return convEndian(handle.be,
 732                               UNSAFE.getAndSetReference(
 733                                       UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 734                                       address(bb, indexRO(bb, index)),
 735                                       convEndian(handle.be, value)));
 736 #else[Object]
 737             return convEndian(handle.be,
 738                               UNSAFE.getAndSet$RawType$(
 739                                       UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 740                                       address(bb, indexRO(bb, index)),
 741                                       convEndian(handle.be, value)));
 742 #end[Object]
 743         }
 744 
 745         @ForceInline
<span class="line-modified"> 746         static $type$ getAndSetAcquire(ByteBufferHandle handle, Object obb, int index, $type$ value) {</span>

 747             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 748             return convEndian(handle.be,
 749                               UNSAFE.getAndSet$RawType$Acquire(
 750                                       UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 751                                       address(bb, indexRO(bb, index)),
 752                                       convEndian(handle.be, value)));
 753         }
 754 
 755         @ForceInline
<span class="line-modified"> 756         static $type$ getAndSetRelease(ByteBufferHandle handle, Object obb, int index, $type$ value) {</span>

 757             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 758             return convEndian(handle.be,
 759                               UNSAFE.getAndSet$RawType$Release(
 760                                       UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 761                                       address(bb, indexRO(bb, index)),
 762                                       convEndian(handle.be, value)));
 763         }
 764 #end[CAS]
 765 #if[AtomicAdd]
 766 
 767         @ForceInline
<span class="line-modified"> 768         static $type$ getAndAdd(ByteBufferHandle handle, Object obb, int index, $type$ delta) {</span>

 769             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 770             if (handle.be == BE) {
 771                 return UNSAFE.getAndAdd$RawType$(
 772                         UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 773                         address(bb, indexRO(bb, index)),
 774                         delta);
 775             } else {
 776                 return getAndAddConvEndianWithCAS(bb, index, delta);
 777             }
 778         }
 779 
 780         @ForceInline
<span class="line-modified"> 781         static $type$ getAndAddAcquire(ByteBufferHandle handle, Object obb, int index, $type$ delta) {</span>

 782             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 783             if (handle.be == BE) {
 784                 return UNSAFE.getAndAdd$RawType$Acquire(
 785                         UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 786                         address(bb, indexRO(bb, index)),
 787                         delta);
 788             } else {
 789                 return getAndAddConvEndianWithCAS(bb, index, delta);
 790             }
 791         }
 792 
 793         @ForceInline
<span class="line-modified"> 794         static $type$ getAndAddRelease(ByteBufferHandle handle, Object obb, int index, $type$ delta) {</span>

 795             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 796             if (handle.be == BE) {
 797                 return UNSAFE.getAndAdd$RawType$Release(
 798                         UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 799                         address(bb, indexRO(bb, index)),
 800                         delta);
 801             } else {
 802                 return getAndAddConvEndianWithCAS(bb, index, delta);
 803             }
 804         }
 805 
 806         @ForceInline
 807         static $type$ getAndAddConvEndianWithCAS(ByteBuffer bb, int index, $type$ delta) {
 808             $type$ nativeExpectedValue, expectedValue;
 809             Object base = UNSAFE.getReference(bb, BYTE_BUFFER_HB);
 810             long offset = address(bb, indexRO(bb, index));
 811             do {
 812                 nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
 813                 expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
 814             } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,
 815                     nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue + delta)));
 816             return expectedValue;
 817         }
 818 #end[AtomicAdd]
 819 #if[Bitwise]
 820 
 821         @ForceInline
<span class="line-modified"> 822         static $type$ getAndBitwiseOr(ByteBufferHandle handle, Object obb, int index, $type$ value) {</span>

 823             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 824             if (handle.be == BE) {
 825                 return UNSAFE.getAndBitwiseOr$RawType$(
 826                         UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 827                         address(bb, indexRO(bb, index)),
 828                         value);
 829             } else {
 830                 return getAndBitwiseOrConvEndianWithCAS(bb, index, value);
 831             }
 832         }
 833 
 834         @ForceInline
<span class="line-modified"> 835         static $type$ getAndBitwiseOrRelease(ByteBufferHandle handle, Object obb, int index, $type$ value) {</span>

 836             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 837             if (handle.be == BE) {
 838                 return UNSAFE.getAndBitwiseOr$RawType$Release(
 839                         UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 840                         address(bb, indexRO(bb, index)),
 841                         value);
 842             } else {
 843                 return getAndBitwiseOrConvEndianWithCAS(bb, index, value);
 844             }
 845         }
 846 
 847         @ForceInline
<span class="line-modified"> 848         static $type$ getAndBitwiseOrAcquire(ByteBufferHandle handle, Object obb, int index, $type$ value) {</span>

 849             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 850             if (handle.be == BE) {
 851                 return UNSAFE.getAndBitwiseOr$RawType$Acquire(
 852                         UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 853                         address(bb, indexRO(bb, index)),
 854                         value);
 855             } else {
 856                 return getAndBitwiseOrConvEndianWithCAS(bb, index, value);
 857             }
 858         }
 859 
 860         @ForceInline
 861         static $type$ getAndBitwiseOrConvEndianWithCAS(ByteBuffer bb, int index, $type$ value) {
 862             $type$ nativeExpectedValue, expectedValue;
 863             Object base = UNSAFE.getReference(bb, BYTE_BUFFER_HB);
 864             long offset = address(bb, indexRO(bb, index));
 865             do {
 866                 nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
 867                 expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
 868             } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,
 869                     nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue | value)));
 870             return expectedValue;
 871         }
 872 
 873         @ForceInline
<span class="line-modified"> 874         static $type$ getAndBitwiseAnd(ByteBufferHandle handle, Object obb, int index, $type$ value) {</span>

 875             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 876             if (handle.be == BE) {
 877                 return UNSAFE.getAndBitwiseAnd$RawType$(
 878                         UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 879                         address(bb, indexRO(bb, index)),
 880                         value);
 881             } else {
 882                 return getAndBitwiseAndConvEndianWithCAS(bb, index, value);
 883             }
 884         }
 885 
 886         @ForceInline
<span class="line-modified"> 887         static $type$ getAndBitwiseAndRelease(ByteBufferHandle handle, Object obb, int index, $type$ value) {</span>

 888             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 889             if (handle.be == BE) {
 890                 return UNSAFE.getAndBitwiseAnd$RawType$Release(
 891                         UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 892                         address(bb, indexRO(bb, index)),
 893                         value);
 894             } else {
 895                 return getAndBitwiseAndConvEndianWithCAS(bb, index, value);
 896             }
 897         }
 898 
 899         @ForceInline
<span class="line-modified"> 900         static $type$ getAndBitwiseAndAcquire(ByteBufferHandle handle, Object obb, int index, $type$ value) {</span>

 901             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 902             if (handle.be == BE) {
 903                 return UNSAFE.getAndBitwiseAnd$RawType$Acquire(
 904                         UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 905                         address(bb, indexRO(bb, index)),
 906                         value);
 907             } else {
 908                 return getAndBitwiseAndConvEndianWithCAS(bb, index, value);
 909             }
 910         }
 911 
 912         @ForceInline
 913         static $type$ getAndBitwiseAndConvEndianWithCAS(ByteBuffer bb, int index, $type$ value) {
 914             $type$ nativeExpectedValue, expectedValue;
 915             Object base = UNSAFE.getReference(bb, BYTE_BUFFER_HB);
 916             long offset = address(bb, indexRO(bb, index));
 917             do {
 918                 nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
 919                 expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
 920             } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,
 921                     nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue &amp; value)));
 922             return expectedValue;
 923         }
 924 
 925 
 926         @ForceInline
<span class="line-modified"> 927         static $type$ getAndBitwiseXor(ByteBufferHandle handle, Object obb, int index, $type$ value) {</span>

 928             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 929             if (handle.be == BE) {
 930                 return UNSAFE.getAndBitwiseXor$RawType$(
 931                         UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 932                         address(bb, indexRO(bb, index)),
 933                         value);
 934             } else {
 935                 return getAndBitwiseXorConvEndianWithCAS(bb, index, value);
 936             }
 937         }
 938 
 939         @ForceInline
<span class="line-modified"> 940         static $type$ getAndBitwiseXorRelease(ByteBufferHandle handle, Object obb, int index, $type$ value) {</span>

 941             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 942             if (handle.be == BE) {
 943                 return UNSAFE.getAndBitwiseXor$RawType$Release(
 944                         UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 945                         address(bb, indexRO(bb, index)),
 946                         value);
 947             } else {
 948                 return getAndBitwiseXorConvEndianWithCAS(bb, index, value);
 949             }
 950         }
 951 
 952         @ForceInline
<span class="line-modified"> 953         static $type$ getAndBitwiseXorAcquire(ByteBufferHandle handle, Object obb, int index, $type$ value) {</span>

 954             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 955             if (handle.be == BE) {
 956                 return UNSAFE.getAndBitwiseXor$RawType$Acquire(
 957                         UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 958                         address(bb, indexRO(bb, index)),
 959                         value);
 960             } else {
 961                 return getAndBitwiseXorConvEndianWithCAS(bb, index, value);
 962             }
 963         }
 964 
 965         @ForceInline
 966         static $type$ getAndBitwiseXorConvEndianWithCAS(ByteBuffer bb, int index, $type$ value) {
 967             $type$ nativeExpectedValue, expectedValue;
 968             Object base = UNSAFE.getReference(bb, BYTE_BUFFER_HB);
 969             long offset = address(bb, indexRO(bb, index));
 970             do {
 971                 nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
 972                 expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
 973             } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,
</pre>
</td>
<td>
<hr />
<pre>
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 package java.lang.invoke;
  26 
  27 import jdk.internal.access.JavaNioAccess;
  28 import jdk.internal.access.SharedSecrets;
<span class="line-added">  29 import jdk.internal.access.foreign.MemorySegmentProxy;</span>
  30 import jdk.internal.misc.Unsafe;
  31 import jdk.internal.util.Preconditions;
  32 import jdk.internal.vm.annotation.ForceInline;
  33 
  34 import java.nio.ByteBuffer;
  35 import java.nio.ReadOnlyBufferException;
  36 import java.util.Objects;
  37 
  38 import static java.lang.invoke.MethodHandleStatics.UNSAFE;
  39 
  40 #warn
  41 
  42 final class VarHandleByteArrayAs$Type$s extends VarHandleByteArrayBase {
  43 
  44     static JavaNioAccess nioAccess = SharedSecrets.getJavaNioAccess();
  45 
  46     static final int ALIGN = $BoxType$.BYTES - 1;
  47 
  48 #if[floatingPoint]
  49     @ForceInline
</pre>
<hr />
<pre>
  82 
  83         @Override
  84         final MethodType accessModeTypeUncached(AccessMode accessMode) {
  85             return accessMode.at.accessModeType(byte[].class, $type$.class, int.class);
  86         }
  87 
  88         @ForceInline
  89         static int index(byte[] ba, int index) {
  90             return Preconditions.checkIndex(index, ba.length - ALIGN, null);
  91         }
  92 
  93         @ForceInline
  94         static long address(byte[] ba, int index) {
  95             long address = ((long) index) + Unsafe.ARRAY_BYTE_BASE_OFFSET;
  96             if ((address &amp; ALIGN) != 0)
  97                 throw newIllegalStateExceptionForMisalignedAccess(index);
  98             return address;
  99         }
 100 
 101         @ForceInline
<span class="line-modified"> 102         static $type$ get(VarHandle ob, Object oba, int index) {</span>
<span class="line-added"> 103             ArrayHandle handle = (ArrayHandle)ob;</span>
 104             byte[] ba = (byte[]) oba;
 105 #if[floatingPoint]
 106             $rawType$ rawValue = UNSAFE.get$RawType$Unaligned(
 107                     ba,
 108                     ((long) index(ba, index)) + Unsafe.ARRAY_BYTE_BASE_OFFSET,
 109                     handle.be);
 110             return $Type$.$rawType$BitsTo$Type$(rawValue);
 111 #else[floatingPoint]
 112             return UNSAFE.get$Type$Unaligned(
 113                     ba,
 114                     ((long) index(ba, index)) + Unsafe.ARRAY_BYTE_BASE_OFFSET,
 115                     handle.be);
 116 #end[floatingPoint]
 117         }
 118 
 119         @ForceInline
<span class="line-modified"> 120         static void set(VarHandle ob, Object oba, int index, $type$ value) {</span>
<span class="line-added"> 121             ArrayHandle handle = (ArrayHandle)ob;</span>
 122             byte[] ba = (byte[]) oba;
 123 #if[floatingPoint]
 124             UNSAFE.put$RawType$Unaligned(
 125                     ba,
 126                     ((long) index(ba, index)) + Unsafe.ARRAY_BYTE_BASE_OFFSET,
 127                     $Type$.$type$ToRaw$RawType$Bits(value),
 128                     handle.be);
 129 #else[floatingPoint]
 130             UNSAFE.put$RawType$Unaligned(
 131                     ba,
 132                     ((long) index(ba, index)) + Unsafe.ARRAY_BYTE_BASE_OFFSET,
 133                     value,
 134                     handle.be);
 135 #end[floatingPoint]
 136         }
 137 
 138         @ForceInline
<span class="line-modified"> 139         static $type$ getVolatile(VarHandle ob, Object oba, int index) {</span>
<span class="line-added"> 140             ArrayHandle handle = (ArrayHandle)ob;</span>
 141             byte[] ba = (byte[]) oba;
 142             return convEndian(handle.be,
 143                               UNSAFE.get$RawType$Volatile(
 144                                       ba,
 145                                       address(ba, index(ba, index))));
 146         }
 147 
 148         @ForceInline
<span class="line-modified"> 149         static void setVolatile(VarHandle ob, Object oba, int index, $type$ value) {</span>
<span class="line-added"> 150             ArrayHandle handle = (ArrayHandle)ob;</span>
 151             byte[] ba = (byte[]) oba;
 152             UNSAFE.put$RawType$Volatile(
 153                     ba,
 154                     address(ba, index(ba, index)),
 155                     convEndian(handle.be, value));
 156         }
 157 
 158         @ForceInline
<span class="line-modified"> 159         static $type$ getAcquire(VarHandle ob, Object oba, int index) {</span>
<span class="line-added"> 160             ArrayHandle handle = (ArrayHandle)ob;</span>
 161             byte[] ba = (byte[]) oba;
 162             return convEndian(handle.be,
 163                               UNSAFE.get$RawType$Acquire(
 164                                       ba,
 165                                       address(ba, index(ba, index))));
 166         }
 167 
 168         @ForceInline
<span class="line-modified"> 169         static void setRelease(VarHandle ob, Object oba, int index, $type$ value) {</span>
<span class="line-added"> 170             ArrayHandle handle = (ArrayHandle)ob;</span>
 171             byte[] ba = (byte[]) oba;
 172             UNSAFE.put$RawType$Release(
 173                     ba,
 174                     address(ba, index(ba, index)),
 175                     convEndian(handle.be, value));
 176         }
 177 
 178         @ForceInline
<span class="line-modified"> 179         static $type$ getOpaque(VarHandle ob, Object oba, int index) {</span>
<span class="line-added"> 180             ArrayHandle handle = (ArrayHandle)ob;</span>
 181             byte[] ba = (byte[]) oba;
 182             return convEndian(handle.be,
 183                               UNSAFE.get$RawType$Opaque(
 184                                       ba,
 185                                       address(ba, index(ba, index))));
 186         }
 187 
 188         @ForceInline
<span class="line-modified"> 189         static void setOpaque(VarHandle ob, Object oba, int index, $type$ value) {</span>
<span class="line-added"> 190             ArrayHandle handle = (ArrayHandle)ob;</span>
 191             byte[] ba = (byte[]) oba;
 192             UNSAFE.put$RawType$Opaque(
 193                     ba,
 194                     address(ba, index(ba, index)),
 195                     convEndian(handle.be, value));
 196         }
 197 #if[CAS]
 198 
 199         @ForceInline
<span class="line-modified"> 200         static boolean compareAndSet(VarHandle ob, Object oba, int index, $type$ expected, $type$ value) {</span>
<span class="line-added"> 201             ArrayHandle handle = (ArrayHandle)ob;</span>
 202             byte[] ba = (byte[]) oba;
 203 #if[Object]
 204             return UNSAFE.compareAndSetReference(
 205                     ba,
 206                     address(ba, index(ba, index)),
 207                     convEndian(handle.be, expected), convEndian(handle.be, value));
 208 #else[Object]
 209             return UNSAFE.compareAndSet$RawType$(
 210                     ba,
 211                     address(ba, index(ba, index)),
 212                     convEndian(handle.be, expected), convEndian(handle.be, value));
 213 #end[Object]
 214         }
 215 
 216         @ForceInline
<span class="line-modified"> 217         static $type$ compareAndExchange(VarHandle ob, Object oba, int index, $type$ expected, $type$ value) {</span>
<span class="line-added"> 218             ArrayHandle handle = (ArrayHandle)ob;</span>
 219             byte[] ba = (byte[]) oba;
 220             return convEndian(handle.be,
 221                               UNSAFE.compareAndExchange$RawType$(
 222                                       ba,
 223                                       address(ba, index(ba, index)),
 224                                       convEndian(handle.be, expected), convEndian(handle.be, value)));
 225         }
 226 
 227         @ForceInline
<span class="line-modified"> 228         static $type$ compareAndExchangeAcquire(VarHandle ob, Object oba, int index, $type$ expected, $type$ value) {</span>
<span class="line-added"> 229             ArrayHandle handle = (ArrayHandle)ob;</span>
 230             byte[] ba = (byte[]) oba;
 231             return convEndian(handle.be,
 232                               UNSAFE.compareAndExchange$RawType$Acquire(
 233                                       ba,
 234                                       address(ba, index(ba, index)),
 235                                       convEndian(handle.be, expected), convEndian(handle.be, value)));
 236         }
 237 
 238         @ForceInline
<span class="line-modified"> 239         static $type$ compareAndExchangeRelease(VarHandle ob, Object oba, int index, $type$ expected, $type$ value) {</span>
<span class="line-added"> 240             ArrayHandle handle = (ArrayHandle)ob;</span>
 241             byte[] ba = (byte[]) oba;
 242             return convEndian(handle.be,
 243                               UNSAFE.compareAndExchange$RawType$Release(
 244                                       ba,
 245                                       address(ba, index(ba, index)),
 246                                       convEndian(handle.be, expected), convEndian(handle.be, value)));
 247         }
 248 
 249         @ForceInline
<span class="line-modified"> 250         static boolean weakCompareAndSetPlain(VarHandle ob, Object oba, int index, $type$ expected, $type$ value) {</span>
<span class="line-added"> 251             ArrayHandle handle = (ArrayHandle)ob;</span>
 252             byte[] ba = (byte[]) oba;
 253             return UNSAFE.weakCompareAndSet$RawType$Plain(
 254                     ba,
 255                     address(ba, index(ba, index)),
 256                     convEndian(handle.be, expected), convEndian(handle.be, value));
 257         }
 258 
 259         @ForceInline
<span class="line-modified"> 260         static boolean weakCompareAndSet(VarHandle ob, Object oba, int index, $type$ expected, $type$ value) {</span>
<span class="line-added"> 261             ArrayHandle handle = (ArrayHandle)ob;</span>
 262             byte[] ba = (byte[]) oba;
 263             return UNSAFE.weakCompareAndSet$RawType$(
 264                     ba,
 265                     address(ba, index(ba, index)),
 266                     convEndian(handle.be, expected), convEndian(handle.be, value));
 267         }
 268 
 269         @ForceInline
<span class="line-modified"> 270         static boolean weakCompareAndSetAcquire(VarHandle ob, Object oba, int index, $type$ expected, $type$ value) {</span>
<span class="line-added"> 271             ArrayHandle handle = (ArrayHandle)ob;</span>
 272             byte[] ba = (byte[]) oba;
 273             return UNSAFE.weakCompareAndSet$RawType$Acquire(
 274                     ba,
 275                     address(ba, index(ba, index)),
 276                     convEndian(handle.be, expected), convEndian(handle.be, value));
 277         }
 278 
 279         @ForceInline
<span class="line-modified"> 280         static boolean weakCompareAndSetRelease(VarHandle ob, Object oba, int index, $type$ expected, $type$ value) {</span>
<span class="line-added"> 281             ArrayHandle handle = (ArrayHandle)ob;</span>
 282             byte[] ba = (byte[]) oba;
 283             return UNSAFE.weakCompareAndSet$RawType$Release(
 284                     ba,
 285                     address(ba, index(ba, index)),
 286                     convEndian(handle.be, expected), convEndian(handle.be, value));
 287         }
 288 
 289         @ForceInline
<span class="line-modified"> 290         static $type$ getAndSet(VarHandle ob, Object oba, int index, $type$ value) {</span>
<span class="line-added"> 291             ArrayHandle handle = (ArrayHandle)ob;</span>
 292             byte[] ba = (byte[]) oba;
 293 #if[Object]
 294             return convEndian(handle.be,
 295                               UNSAFE.getAndSetReference(
 296                                       ba,
 297                                       address(ba, index(ba, index)),
 298                                       convEndian(handle.be, value)));
 299 #else[Object]
 300             return convEndian(handle.be,
 301                               UNSAFE.getAndSet$RawType$(
 302                                       ba,
 303                                       address(ba, index(ba, index)),
 304                                       convEndian(handle.be, value)));
 305 #end[Object]
 306         }
 307 
 308         @ForceInline
<span class="line-modified"> 309         static $type$ getAndSetAcquire(VarHandle ob, Object oba, int index, $type$ value) {</span>
<span class="line-added"> 310             ArrayHandle handle = (ArrayHandle)ob;</span>
 311             byte[] ba = (byte[]) oba;
 312             return convEndian(handle.be,
 313                               UNSAFE.getAndSet$RawType$Acquire(
 314                                       ba,
 315                                       address(ba, index(ba, index)),
 316                                       convEndian(handle.be, value)));
 317         }
 318 
 319         @ForceInline
<span class="line-modified"> 320         static $type$ getAndSetRelease(VarHandle ob, Object oba, int index, $type$ value) {</span>
<span class="line-added"> 321             ArrayHandle handle = (ArrayHandle)ob;</span>
 322             byte[] ba = (byte[]) oba;
 323             return convEndian(handle.be,
 324                               UNSAFE.getAndSet$RawType$Release(
 325                                       ba,
 326                                       address(ba, index(ba, index)),
 327                                       convEndian(handle.be, value)));
 328         }
 329 #end[CAS]
 330 #if[AtomicAdd]
 331 
 332         @ForceInline
<span class="line-modified"> 333         static $type$ getAndAdd(VarHandle ob, Object oba, int index, $type$ delta) {</span>
<span class="line-added"> 334             ArrayHandle handle = (ArrayHandle)ob;</span>
 335             byte[] ba = (byte[]) oba;
 336             if (handle.be == BE) {
 337                 return UNSAFE.getAndAdd$RawType$(
 338                         ba,
 339                         address(ba, index(ba, index)),
 340                         delta);
 341             } else {
 342                 return getAndAddConvEndianWithCAS(ba, index, delta);
 343             }
 344         }
 345 
 346         @ForceInline
<span class="line-modified"> 347         static $type$ getAndAddAcquire(VarHandle ob, Object oba, int index, $type$ delta) {</span>
<span class="line-added"> 348             ArrayHandle handle = (ArrayHandle)ob;</span>
 349             byte[] ba = (byte[]) oba;
 350             if (handle.be == BE) {
 351                 return UNSAFE.getAndAdd$RawType$Acquire(
 352                         ba,
 353                         address(ba, index(ba, index)),
 354                         delta);
 355             } else {
 356                 return getAndAddConvEndianWithCAS(ba, index, delta);
 357             }
 358         }
 359 
 360         @ForceInline
<span class="line-modified"> 361         static $type$ getAndAddRelease(VarHandle ob, Object oba, int index, $type$ delta) {</span>
<span class="line-added"> 362             ArrayHandle handle = (ArrayHandle)ob;</span>
 363             byte[] ba = (byte[]) oba;
 364             if (handle.be == BE) {
 365                 return UNSAFE.getAndAdd$RawType$Release(
 366                         ba,
 367                         address(ba, index(ba, index)),
 368                         delta);
 369             } else {
 370                 return getAndAddConvEndianWithCAS(ba, index, delta);
 371             }
 372         }
 373 
 374         @ForceInline
 375         static $type$ getAndAddConvEndianWithCAS(byte[] ba, int index, $type$ delta) {
 376             $type$ nativeExpectedValue, expectedValue;
 377             long offset = address(ba, index(ba, index));
 378             do {
 379                 nativeExpectedValue = UNSAFE.get$RawType$Volatile(ba, offset);
 380                 expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
 381             } while (!UNSAFE.weakCompareAndSet$RawType$(ba, offset,
 382                     nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue + delta)));
 383             return expectedValue;
 384         }
 385 #end[AtomicAdd]
 386 #if[Bitwise]
 387 
 388         @ForceInline
<span class="line-modified"> 389         static $type$ getAndBitwiseOr(VarHandle ob, Object oba, int index, $type$ value) {</span>
<span class="line-added"> 390             ArrayHandle handle = (ArrayHandle)ob;</span>
 391             byte[] ba = (byte[]) oba;
 392             if (handle.be == BE) {
 393                 return UNSAFE.getAndBitwiseOr$RawType$(
 394                         ba,
 395                         address(ba, index(ba, index)),
 396                         value);
 397             } else {
 398                 return getAndBitwiseOrConvEndianWithCAS(ba, index, value);
 399             }
 400         }
 401 
 402         @ForceInline
<span class="line-modified"> 403         static $type$ getAndBitwiseOrRelease(VarHandle ob, Object oba, int index, $type$ value) {</span>
<span class="line-added"> 404             ArrayHandle handle = (ArrayHandle)ob;</span>
 405             byte[] ba = (byte[]) oba;
 406             if (handle.be == BE) {
 407                 return UNSAFE.getAndBitwiseOr$RawType$Release(
 408                         ba,
 409                         address(ba, index(ba, index)),
 410                         value);
 411             } else {
 412                 return getAndBitwiseOrConvEndianWithCAS(ba, index, value);
 413             }
 414         }
 415 
 416         @ForceInline
<span class="line-modified"> 417         static $type$ getAndBitwiseOrAcquire(VarHandle ob, Object oba, int index, $type$ value) {</span>
<span class="line-added"> 418             ArrayHandle handle = (ArrayHandle)ob;</span>
 419             byte[] ba = (byte[]) oba;
 420             if (handle.be == BE) {
 421                 return UNSAFE.getAndBitwiseOr$RawType$Acquire(
 422                         ba,
 423                         address(ba, index(ba, index)),
 424                         value);
 425             } else {
 426                 return getAndBitwiseOrConvEndianWithCAS(ba, index, value);
 427             }
 428         }
 429 
 430         @ForceInline
 431         static $type$ getAndBitwiseOrConvEndianWithCAS(byte[] ba, int index, $type$ value) {
 432             $type$ nativeExpectedValue, expectedValue;
 433             long offset = address(ba, index(ba, index));
 434             do {
 435                 nativeExpectedValue = UNSAFE.get$RawType$Volatile(ba, offset);
 436                 expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
 437             } while (!UNSAFE.weakCompareAndSet$RawType$(ba, offset,
 438                     nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue | value)));
 439             return expectedValue;
 440         }
 441 
 442         @ForceInline
<span class="line-modified"> 443         static $type$ getAndBitwiseAnd(VarHandle ob, Object oba, int index, $type$ value) {</span>
<span class="line-added"> 444             ArrayHandle handle = (ArrayHandle)ob;</span>
 445             byte[] ba = (byte[]) oba;
 446             if (handle.be == BE) {
 447                 return UNSAFE.getAndBitwiseAnd$RawType$(
 448                         ba,
 449                         address(ba, index(ba, index)),
 450                         value);
 451             } else {
 452                 return getAndBitwiseAndConvEndianWithCAS(ba, index, value);
 453             }
 454         }
 455 
 456         @ForceInline
<span class="line-modified"> 457         static $type$ getAndBitwiseAndRelease(VarHandle ob, Object oba, int index, $type$ value) {</span>
<span class="line-added"> 458             ArrayHandle handle = (ArrayHandle)ob;</span>
 459             byte[] ba = (byte[]) oba;
 460             if (handle.be == BE) {
 461                 return UNSAFE.getAndBitwiseAnd$RawType$Release(
 462                         ba,
 463                         address(ba, index(ba, index)),
 464                         value);
 465             } else {
 466                 return getAndBitwiseAndConvEndianWithCAS(ba, index, value);
 467             }
 468         }
 469 
 470         @ForceInline
<span class="line-modified"> 471         static $type$ getAndBitwiseAndAcquire(VarHandle ob, Object oba, int index, $type$ value) {</span>
<span class="line-added"> 472             ArrayHandle handle = (ArrayHandle)ob;</span>
 473             byte[] ba = (byte[]) oba;
 474             if (handle.be == BE) {
 475                 return UNSAFE.getAndBitwiseAnd$RawType$Acquire(
 476                         ba,
 477                         address(ba, index(ba, index)),
 478                         value);
 479             } else {
 480                 return getAndBitwiseAndConvEndianWithCAS(ba, index, value);
 481             }
 482         }
 483 
 484         @ForceInline
 485         static $type$ getAndBitwiseAndConvEndianWithCAS(byte[] ba, int index, $type$ value) {
 486             $type$ nativeExpectedValue, expectedValue;
 487             long offset = address(ba, index(ba, index));
 488             do {
 489                 nativeExpectedValue = UNSAFE.get$RawType$Volatile(ba, offset);
 490                 expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
 491             } while (!UNSAFE.weakCompareAndSet$RawType$(ba, offset,
 492                     nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue &amp; value)));
 493             return expectedValue;
 494         }
 495 
 496         @ForceInline
<span class="line-modified"> 497         static $type$ getAndBitwiseXor(VarHandle ob, Object oba, int index, $type$ value) {</span>
<span class="line-added"> 498             ArrayHandle handle = (ArrayHandle)ob;</span>
 499             byte[] ba = (byte[]) oba;
 500             if (handle.be == BE) {
 501                 return UNSAFE.getAndBitwiseXor$RawType$(
 502                         ba,
 503                         address(ba, index(ba, index)),
 504                         value);
 505             } else {
 506                 return getAndBitwiseXorConvEndianWithCAS(ba, index, value);
 507             }
 508         }
 509 
 510         @ForceInline
<span class="line-modified"> 511         static $type$ getAndBitwiseXorRelease(VarHandle ob, Object oba, int index, $type$ value) {</span>
<span class="line-added"> 512             ArrayHandle handle = (ArrayHandle)ob;</span>
 513             byte[] ba = (byte[]) oba;
 514             if (handle.be == BE) {
 515                 return UNSAFE.getAndBitwiseXor$RawType$Release(
 516                         ba,
 517                         address(ba, index(ba, index)),
 518                         value);
 519             } else {
 520                 return getAndBitwiseXorConvEndianWithCAS(ba, index, value);
 521             }
 522         }
 523 
 524         @ForceInline
<span class="line-modified"> 525         static $type$ getAndBitwiseXorAcquire(VarHandle ob, Object oba, int index, $type$ value) {</span>
<span class="line-added"> 526             ArrayHandle handle = (ArrayHandle)ob;</span>
 527             byte[] ba = (byte[]) oba;
 528             if (handle.be == BE) {
 529                 return UNSAFE.getAndBitwiseXor$RawType$Acquire(
 530                         ba,
 531                         address(ba, index(ba, index)),
 532                         value);
 533             } else {
 534                 return getAndBitwiseXorConvEndianWithCAS(ba, index, value);
 535             }
 536         }
 537 
 538         @ForceInline
 539         static $type$ getAndBitwiseXorConvEndianWithCAS(byte[] ba, int index, $type$ value) {
 540             $type$ nativeExpectedValue, expectedValue;
 541             long offset = address(ba, index(ba, index));
 542             do {
 543                 nativeExpectedValue = UNSAFE.get$RawType$Volatile(ba, offset);
 544                 expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
 545             } while (!UNSAFE.weakCompareAndSet$RawType$(ba, offset,
 546                     nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue ^ value)));
</pre>
<hr />
<pre>
 548         }
 549 #end[Bitwise]
 550 
 551         static final VarForm FORM = new VarForm(ArrayHandle.class, byte[].class, $type$.class, int.class);
 552     }
 553 
 554 
 555     static final class ByteBufferHandle extends ByteArrayViewVarHandle {
 556 
 557         ByteBufferHandle(boolean be) {
 558             super(ByteBufferHandle.FORM, be);
 559         }
 560 
 561         @Override
 562         final MethodType accessModeTypeUncached(AccessMode accessMode) {
 563             return accessMode.at.accessModeType(ByteBuffer.class, $type$.class, int.class);
 564         }
 565 
 566         @ForceInline
 567         static int index(ByteBuffer bb, int index) {
<span class="line-modified"> 568             MemorySegmentProxy segmentProxy = nioAccess.bufferSegment(bb);</span>
<span class="line-added"> 569             if (segmentProxy != null) {</span>
<span class="line-added"> 570                 segmentProxy.checkValidState();</span>
<span class="line-added"> 571             }</span>
 572             return Preconditions.checkIndex(index, UNSAFE.getInt(bb, BUFFER_LIMIT) - ALIGN, null);
 573         }
 574 
 575         @ForceInline
 576         static int indexRO(ByteBuffer bb, int index) {
 577             if (UNSAFE.getBoolean(bb, BYTE_BUFFER_IS_READ_ONLY))
 578                 throw new ReadOnlyBufferException();
 579             return index(bb, index);
 580         }
 581 
 582         @ForceInline
 583         static long address(ByteBuffer bb, int index) {
 584             long address = ((long) index) + UNSAFE.getLong(bb, BUFFER_ADDRESS);
 585             if ((address &amp; ALIGN) != 0)
 586                 throw newIllegalStateExceptionForMisalignedAccess(index);
 587             return address;
 588         }
 589 
 590         @ForceInline
<span class="line-modified"> 591         static $type$ get(VarHandle ob, Object obb, int index) {</span>
<span class="line-added"> 592             ByteBufferHandle handle = (ByteBufferHandle)ob;</span>
 593             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 594 #if[floatingPoint]
 595             $rawType$ rawValue = UNSAFE.get$RawType$Unaligned(
 596                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 597                     ((long) index(bb, index)) + UNSAFE.getLong(bb, BUFFER_ADDRESS),
 598                     handle.be);
 599             return $Type$.$rawType$BitsTo$Type$(rawValue);
 600 #else[floatingPoint]
 601             return UNSAFE.get$Type$Unaligned(
 602                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 603                     ((long) index(bb, index)) + UNSAFE.getLong(bb, BUFFER_ADDRESS),
 604                     handle.be);
 605 #end[floatingPoint]
 606         }
 607 
 608         @ForceInline
<span class="line-modified"> 609         static void set(VarHandle ob, Object obb, int index, $type$ value) {</span>
<span class="line-added"> 610             ByteBufferHandle handle = (ByteBufferHandle)ob;</span>
 611             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 612 #if[floatingPoint]
 613             UNSAFE.put$RawType$Unaligned(
 614                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 615                     ((long) indexRO(bb, index)) + UNSAFE.getLong(bb, BUFFER_ADDRESS),
 616                     $Type$.$type$ToRaw$RawType$Bits(value),
 617                     handle.be);
 618 #else[floatingPoint]
 619             UNSAFE.put$Type$Unaligned(
 620                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 621                     ((long) indexRO(bb, index)) + UNSAFE.getLong(bb, BUFFER_ADDRESS),
 622                     value,
 623                     handle.be);
 624 #end[floatingPoint]
 625         }
 626 
 627         @ForceInline
<span class="line-modified"> 628         static $type$ getVolatile(VarHandle ob, Object obb, int index) {</span>
<span class="line-added"> 629             ByteBufferHandle handle = (ByteBufferHandle)ob;</span>
 630             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 631             return convEndian(handle.be,
 632                               UNSAFE.get$RawType$Volatile(
 633                                       UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 634                                       address(bb, index(bb, index))));
 635         }
 636 
 637         @ForceInline
<span class="line-modified"> 638         static void setVolatile(VarHandle ob, Object obb, int index, $type$ value) {</span>
<span class="line-added"> 639             ByteBufferHandle handle = (ByteBufferHandle)ob;</span>
 640             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 641             UNSAFE.put$RawType$Volatile(
 642                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 643                     address(bb, indexRO(bb, index)),
 644                     convEndian(handle.be, value));
 645         }
 646 
 647         @ForceInline
<span class="line-modified"> 648         static $type$ getAcquire(VarHandle ob, Object obb, int index) {</span>
<span class="line-added"> 649             ByteBufferHandle handle = (ByteBufferHandle)ob;</span>
 650             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 651             return convEndian(handle.be,
 652                               UNSAFE.get$RawType$Acquire(
 653                                       UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 654                                       address(bb, index(bb, index))));
 655         }
 656 
 657         @ForceInline
<span class="line-modified"> 658         static void setRelease(VarHandle ob, Object obb, int index, $type$ value) {</span>
<span class="line-added"> 659             ByteBufferHandle handle = (ByteBufferHandle)ob;</span>
 660             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 661             UNSAFE.put$RawType$Release(
 662                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 663                     address(bb, indexRO(bb, index)),
 664                     convEndian(handle.be, value));
 665         }
 666 
 667         @ForceInline
<span class="line-modified"> 668         static $type$ getOpaque(VarHandle ob, Object obb, int index) {</span>
<span class="line-added"> 669             ByteBufferHandle handle = (ByteBufferHandle)ob;</span>
 670             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 671             return convEndian(handle.be,
 672                               UNSAFE.get$RawType$Opaque(
 673                                       UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 674                                       address(bb, index(bb, index))));
 675         }
 676 
 677         @ForceInline
<span class="line-modified"> 678         static void setOpaque(VarHandle ob, Object obb, int index, $type$ value) {</span>
<span class="line-added"> 679             ByteBufferHandle handle = (ByteBufferHandle)ob;</span>
 680             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 681             UNSAFE.put$RawType$Opaque(
 682                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 683                     address(bb, indexRO(bb, index)),
 684                     convEndian(handle.be, value));
 685         }
 686 #if[CAS]
 687 
 688         @ForceInline
<span class="line-modified"> 689         static boolean compareAndSet(VarHandle ob, Object obb, int index, $type$ expected, $type$ value) {</span>
<span class="line-added"> 690             ByteBufferHandle handle = (ByteBufferHandle)ob;</span>
 691             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 692 #if[Object]
 693             return UNSAFE.compareAndSetReference(
 694                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 695                     address(bb, indexRO(bb, index)),
 696                     convEndian(handle.be, expected), convEndian(handle.be, value));
 697 #else[Object]
 698             return UNSAFE.compareAndSet$RawType$(
 699                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 700                     address(bb, indexRO(bb, index)),
 701                     convEndian(handle.be, expected), convEndian(handle.be, value));
 702 #end[Object]
 703         }
 704 
 705         @ForceInline
<span class="line-modified"> 706         static $type$ compareAndExchange(VarHandle ob, Object obb, int index, $type$ expected, $type$ value) {</span>
<span class="line-added"> 707             ByteBufferHandle handle = (ByteBufferHandle)ob;</span>
 708             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 709             return convEndian(handle.be,
 710                               UNSAFE.compareAndExchange$RawType$(
 711                                       UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 712                                       address(bb, indexRO(bb, index)),
 713                                       convEndian(handle.be, expected), convEndian(handle.be, value)));
 714         }
 715 
 716         @ForceInline
<span class="line-modified"> 717         static $type$ compareAndExchangeAcquire(VarHandle ob, Object obb, int index, $type$ expected, $type$ value) {</span>
<span class="line-added"> 718             ByteBufferHandle handle = (ByteBufferHandle)ob;</span>
 719             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 720             return convEndian(handle.be,
 721                               UNSAFE.compareAndExchange$RawType$Acquire(
 722                                       UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 723                                       address(bb, indexRO(bb, index)),
 724                                       convEndian(handle.be, expected), convEndian(handle.be, value)));
 725         }
 726 
 727         @ForceInline
<span class="line-modified"> 728         static $type$ compareAndExchangeRelease(VarHandle ob, Object obb, int index, $type$ expected, $type$ value) {</span>
<span class="line-added"> 729             ByteBufferHandle handle = (ByteBufferHandle)ob;</span>
 730             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 731             return convEndian(handle.be,
 732                               UNSAFE.compareAndExchange$RawType$Release(
 733                                       UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 734                                       address(bb, indexRO(bb, index)),
 735                                       convEndian(handle.be, expected), convEndian(handle.be, value)));
 736         }
 737 
 738         @ForceInline
<span class="line-modified"> 739         static boolean weakCompareAndSetPlain(VarHandle ob, Object obb, int index, $type$ expected, $type$ value) {</span>
<span class="line-added"> 740             ByteBufferHandle handle = (ByteBufferHandle)ob;</span>
 741             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 742             return UNSAFE.weakCompareAndSet$RawType$Plain(
 743                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 744                     address(bb, indexRO(bb, index)),
 745                     convEndian(handle.be, expected), convEndian(handle.be, value));
 746         }
 747 
 748         @ForceInline
<span class="line-modified"> 749         static boolean weakCompareAndSet(VarHandle ob, Object obb, int index, $type$ expected, $type$ value) {</span>
<span class="line-added"> 750             ByteBufferHandle handle = (ByteBufferHandle)ob;</span>
 751             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 752             return UNSAFE.weakCompareAndSet$RawType$(
 753                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 754                     address(bb, indexRO(bb, index)),
 755                     convEndian(handle.be, expected), convEndian(handle.be, value));
 756         }
 757 
 758         @ForceInline
<span class="line-modified"> 759         static boolean weakCompareAndSetAcquire(VarHandle ob, Object obb, int index, $type$ expected, $type$ value) {</span>
<span class="line-added"> 760             ByteBufferHandle handle = (ByteBufferHandle)ob;</span>
 761             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 762             return UNSAFE.weakCompareAndSet$RawType$Acquire(
 763                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 764                     address(bb, indexRO(bb, index)),
 765                     convEndian(handle.be, expected), convEndian(handle.be, value));
 766         }
 767 
 768         @ForceInline
<span class="line-modified"> 769         static boolean weakCompareAndSetRelease(VarHandle ob, Object obb, int index, $type$ expected, $type$ value) {</span>
<span class="line-added"> 770             ByteBufferHandle handle = (ByteBufferHandle)ob;</span>
 771             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 772             return UNSAFE.weakCompareAndSet$RawType$Release(
 773                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 774                     address(bb, indexRO(bb, index)),
 775                     convEndian(handle.be, expected), convEndian(handle.be, value));
 776         }
 777 
 778         @ForceInline
<span class="line-modified"> 779         static $type$ getAndSet(VarHandle ob, Object obb, int index, $type$ value) {</span>
<span class="line-added"> 780             ByteBufferHandle handle = (ByteBufferHandle)ob;</span>
 781             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 782 #if[Object]
 783             return convEndian(handle.be,
 784                               UNSAFE.getAndSetReference(
 785                                       UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 786                                       address(bb, indexRO(bb, index)),
 787                                       convEndian(handle.be, value)));
 788 #else[Object]
 789             return convEndian(handle.be,
 790                               UNSAFE.getAndSet$RawType$(
 791                                       UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 792                                       address(bb, indexRO(bb, index)),
 793                                       convEndian(handle.be, value)));
 794 #end[Object]
 795         }
 796 
 797         @ForceInline
<span class="line-modified"> 798         static $type$ getAndSetAcquire(VarHandle ob, Object obb, int index, $type$ value) {</span>
<span class="line-added"> 799             ByteBufferHandle handle = (ByteBufferHandle)ob;</span>
 800             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 801             return convEndian(handle.be,
 802                               UNSAFE.getAndSet$RawType$Acquire(
 803                                       UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 804                                       address(bb, indexRO(bb, index)),
 805                                       convEndian(handle.be, value)));
 806         }
 807 
 808         @ForceInline
<span class="line-modified"> 809         static $type$ getAndSetRelease(VarHandle ob, Object obb, int index, $type$ value) {</span>
<span class="line-added"> 810             ByteBufferHandle handle = (ByteBufferHandle)ob;</span>
 811             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 812             return convEndian(handle.be,
 813                               UNSAFE.getAndSet$RawType$Release(
 814                                       UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 815                                       address(bb, indexRO(bb, index)),
 816                                       convEndian(handle.be, value)));
 817         }
 818 #end[CAS]
 819 #if[AtomicAdd]
 820 
 821         @ForceInline
<span class="line-modified"> 822         static $type$ getAndAdd(VarHandle ob, Object obb, int index, $type$ delta) {</span>
<span class="line-added"> 823             ByteBufferHandle handle = (ByteBufferHandle)ob;</span>
 824             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 825             if (handle.be == BE) {
 826                 return UNSAFE.getAndAdd$RawType$(
 827                         UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 828                         address(bb, indexRO(bb, index)),
 829                         delta);
 830             } else {
 831                 return getAndAddConvEndianWithCAS(bb, index, delta);
 832             }
 833         }
 834 
 835         @ForceInline
<span class="line-modified"> 836         static $type$ getAndAddAcquire(VarHandle ob, Object obb, int index, $type$ delta) {</span>
<span class="line-added"> 837             ByteBufferHandle handle = (ByteBufferHandle)ob;</span>
 838             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 839             if (handle.be == BE) {
 840                 return UNSAFE.getAndAdd$RawType$Acquire(
 841                         UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 842                         address(bb, indexRO(bb, index)),
 843                         delta);
 844             } else {
 845                 return getAndAddConvEndianWithCAS(bb, index, delta);
 846             }
 847         }
 848 
 849         @ForceInline
<span class="line-modified"> 850         static $type$ getAndAddRelease(VarHandle ob, Object obb, int index, $type$ delta) {</span>
<span class="line-added"> 851             ByteBufferHandle handle = (ByteBufferHandle)ob;</span>
 852             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 853             if (handle.be == BE) {
 854                 return UNSAFE.getAndAdd$RawType$Release(
 855                         UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 856                         address(bb, indexRO(bb, index)),
 857                         delta);
 858             } else {
 859                 return getAndAddConvEndianWithCAS(bb, index, delta);
 860             }
 861         }
 862 
 863         @ForceInline
 864         static $type$ getAndAddConvEndianWithCAS(ByteBuffer bb, int index, $type$ delta) {
 865             $type$ nativeExpectedValue, expectedValue;
 866             Object base = UNSAFE.getReference(bb, BYTE_BUFFER_HB);
 867             long offset = address(bb, indexRO(bb, index));
 868             do {
 869                 nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
 870                 expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
 871             } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,
 872                     nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue + delta)));
 873             return expectedValue;
 874         }
 875 #end[AtomicAdd]
 876 #if[Bitwise]
 877 
 878         @ForceInline
<span class="line-modified"> 879         static $type$ getAndBitwiseOr(VarHandle ob, Object obb, int index, $type$ value) {</span>
<span class="line-added"> 880             ByteBufferHandle handle = (ByteBufferHandle)ob;</span>
 881             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 882             if (handle.be == BE) {
 883                 return UNSAFE.getAndBitwiseOr$RawType$(
 884                         UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 885                         address(bb, indexRO(bb, index)),
 886                         value);
 887             } else {
 888                 return getAndBitwiseOrConvEndianWithCAS(bb, index, value);
 889             }
 890         }
 891 
 892         @ForceInline
<span class="line-modified"> 893         static $type$ getAndBitwiseOrRelease(VarHandle ob, Object obb, int index, $type$ value) {</span>
<span class="line-added"> 894             ByteBufferHandle handle = (ByteBufferHandle)ob;</span>
 895             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 896             if (handle.be == BE) {
 897                 return UNSAFE.getAndBitwiseOr$RawType$Release(
 898                         UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 899                         address(bb, indexRO(bb, index)),
 900                         value);
 901             } else {
 902                 return getAndBitwiseOrConvEndianWithCAS(bb, index, value);
 903             }
 904         }
 905 
 906         @ForceInline
<span class="line-modified"> 907         static $type$ getAndBitwiseOrAcquire(VarHandle ob, Object obb, int index, $type$ value) {</span>
<span class="line-added"> 908             ByteBufferHandle handle = (ByteBufferHandle)ob;</span>
 909             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 910             if (handle.be == BE) {
 911                 return UNSAFE.getAndBitwiseOr$RawType$Acquire(
 912                         UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 913                         address(bb, indexRO(bb, index)),
 914                         value);
 915             } else {
 916                 return getAndBitwiseOrConvEndianWithCAS(bb, index, value);
 917             }
 918         }
 919 
 920         @ForceInline
 921         static $type$ getAndBitwiseOrConvEndianWithCAS(ByteBuffer bb, int index, $type$ value) {
 922             $type$ nativeExpectedValue, expectedValue;
 923             Object base = UNSAFE.getReference(bb, BYTE_BUFFER_HB);
 924             long offset = address(bb, indexRO(bb, index));
 925             do {
 926                 nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
 927                 expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
 928             } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,
 929                     nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue | value)));
 930             return expectedValue;
 931         }
 932 
 933         @ForceInline
<span class="line-modified"> 934         static $type$ getAndBitwiseAnd(VarHandle ob, Object obb, int index, $type$ value) {</span>
<span class="line-added"> 935             ByteBufferHandle handle = (ByteBufferHandle)ob;</span>
 936             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 937             if (handle.be == BE) {
 938                 return UNSAFE.getAndBitwiseAnd$RawType$(
 939                         UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 940                         address(bb, indexRO(bb, index)),
 941                         value);
 942             } else {
 943                 return getAndBitwiseAndConvEndianWithCAS(bb, index, value);
 944             }
 945         }
 946 
 947         @ForceInline
<span class="line-modified"> 948         static $type$ getAndBitwiseAndRelease(VarHandle ob, Object obb, int index, $type$ value) {</span>
<span class="line-added"> 949             ByteBufferHandle handle = (ByteBufferHandle)ob;</span>
 950             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 951             if (handle.be == BE) {
 952                 return UNSAFE.getAndBitwiseAnd$RawType$Release(
 953                         UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 954                         address(bb, indexRO(bb, index)),
 955                         value);
 956             } else {
 957                 return getAndBitwiseAndConvEndianWithCAS(bb, index, value);
 958             }
 959         }
 960 
 961         @ForceInline
<span class="line-modified"> 962         static $type$ getAndBitwiseAndAcquire(VarHandle ob, Object obb, int index, $type$ value) {</span>
<span class="line-added"> 963             ByteBufferHandle handle = (ByteBufferHandle)ob;</span>
 964             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 965             if (handle.be == BE) {
 966                 return UNSAFE.getAndBitwiseAnd$RawType$Acquire(
 967                         UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 968                         address(bb, indexRO(bb, index)),
 969                         value);
 970             } else {
 971                 return getAndBitwiseAndConvEndianWithCAS(bb, index, value);
 972             }
 973         }
 974 
 975         @ForceInline
 976         static $type$ getAndBitwiseAndConvEndianWithCAS(ByteBuffer bb, int index, $type$ value) {
 977             $type$ nativeExpectedValue, expectedValue;
 978             Object base = UNSAFE.getReference(bb, BYTE_BUFFER_HB);
 979             long offset = address(bb, indexRO(bb, index));
 980             do {
 981                 nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
 982                 expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
 983             } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,
 984                     nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue &amp; value)));
 985             return expectedValue;
 986         }
 987 
 988 
 989         @ForceInline
<span class="line-modified"> 990         static $type$ getAndBitwiseXor(VarHandle ob, Object obb, int index, $type$ value) {</span>
<span class="line-added"> 991             ByteBufferHandle handle = (ByteBufferHandle)ob;</span>
 992             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
 993             if (handle.be == BE) {
 994                 return UNSAFE.getAndBitwiseXor$RawType$(
 995                         UNSAFE.getReference(bb, BYTE_BUFFER_HB),
 996                         address(bb, indexRO(bb, index)),
 997                         value);
 998             } else {
 999                 return getAndBitwiseXorConvEndianWithCAS(bb, index, value);
1000             }
1001         }
1002 
1003         @ForceInline
<span class="line-modified">1004         static $type$ getAndBitwiseXorRelease(VarHandle ob, Object obb, int index, $type$ value) {</span>
<span class="line-added">1005             ByteBufferHandle handle = (ByteBufferHandle)ob;</span>
1006             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
1007             if (handle.be == BE) {
1008                 return UNSAFE.getAndBitwiseXor$RawType$Release(
1009                         UNSAFE.getReference(bb, BYTE_BUFFER_HB),
1010                         address(bb, indexRO(bb, index)),
1011                         value);
1012             } else {
1013                 return getAndBitwiseXorConvEndianWithCAS(bb, index, value);
1014             }
1015         }
1016 
1017         @ForceInline
<span class="line-modified">1018         static $type$ getAndBitwiseXorAcquire(VarHandle ob, Object obb, int index, $type$ value) {</span>
<span class="line-added">1019             ByteBufferHandle handle = (ByteBufferHandle)ob;</span>
1020             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
1021             if (handle.be == BE) {
1022                 return UNSAFE.getAndBitwiseXor$RawType$Acquire(
1023                         UNSAFE.getReference(bb, BYTE_BUFFER_HB),
1024                         address(bb, indexRO(bb, index)),
1025                         value);
1026             } else {
1027                 return getAndBitwiseXorConvEndianWithCAS(bb, index, value);
1028             }
1029         }
1030 
1031         @ForceInline
1032         static $type$ getAndBitwiseXorConvEndianWithCAS(ByteBuffer bb, int index, $type$ value) {
1033             $type$ nativeExpectedValue, expectedValue;
1034             Object base = UNSAFE.getReference(bb, BYTE_BUFFER_HB);
1035             long offset = address(bb, indexRO(bb, index));
1036             do {
1037                 nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
1038                 expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
1039             } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,
</pre>
</td>
</tr>
</table>
<center><a href="X-VarHandle.java.template.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../reflect/Executable.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
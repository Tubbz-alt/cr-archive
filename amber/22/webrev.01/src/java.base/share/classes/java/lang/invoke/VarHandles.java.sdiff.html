<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/invoke/VarHandles.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="VarHandleGuards.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="X-VarHandle.java.template.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/VarHandles.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.lang.invoke;
 27 
 28 import sun.invoke.util.Wrapper;
 29 

 30 import java.lang.reflect.Field;

 31 import java.lang.reflect.Modifier;
 32 import java.nio.ByteOrder;


 33 import java.util.Map;

 34 import java.util.concurrent.ConcurrentHashMap;
 35 import java.util.concurrent.ConcurrentMap;

 36 
 37 import static java.lang.invoke.MethodHandleStatics.UNSAFE;


 38 
 39 final class VarHandles {
 40 
 41     static ClassValue&lt;ConcurrentMap&lt;Integer, MethodHandle&gt;&gt; ADDRESS_FACTORIES = new ClassValue&lt;&gt;() {
 42         @Override
 43         protected ConcurrentMap&lt;Integer, MethodHandle&gt; computeValue(Class&lt;?&gt; type) {
 44             return new ConcurrentHashMap&lt;&gt;();
 45         }
 46     };
 47 
 48     static VarHandle makeFieldHandle(MemberName f, Class&lt;?&gt; refc, Class&lt;?&gt; type, boolean isWriteAllowedOnFinalFields) {
 49         if (!f.isStatic()) {
 50             long foffset = MethodHandleNatives.objectFieldOffset(f);
 51             if (!type.isPrimitive()) {
<span class="line-modified"> 52                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
 53                        ? new VarHandleReferences.FieldInstanceReadOnly(refc, foffset, type)
<span class="line-modified"> 54                        : new VarHandleReferences.FieldInstanceReadWrite(refc, foffset, type);</span>
 55             }
 56             else if (type == boolean.class) {
<span class="line-modified"> 57                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
 58                        ? new VarHandleBooleans.FieldInstanceReadOnly(refc, foffset)
<span class="line-modified"> 59                        : new VarHandleBooleans.FieldInstanceReadWrite(refc, foffset);</span>
 60             }
 61             else if (type == byte.class) {
<span class="line-modified"> 62                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
 63                        ? new VarHandleBytes.FieldInstanceReadOnly(refc, foffset)
<span class="line-modified"> 64                        : new VarHandleBytes.FieldInstanceReadWrite(refc, foffset);</span>
 65             }
 66             else if (type == short.class) {
<span class="line-modified"> 67                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
 68                        ? new VarHandleShorts.FieldInstanceReadOnly(refc, foffset)
<span class="line-modified"> 69                        : new VarHandleShorts.FieldInstanceReadWrite(refc, foffset);</span>
 70             }
 71             else if (type == char.class) {
<span class="line-modified"> 72                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
 73                        ? new VarHandleChars.FieldInstanceReadOnly(refc, foffset)
<span class="line-modified"> 74                        : new VarHandleChars.FieldInstanceReadWrite(refc, foffset);</span>
 75             }
 76             else if (type == int.class) {
<span class="line-modified"> 77                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
 78                        ? new VarHandleInts.FieldInstanceReadOnly(refc, foffset)
<span class="line-modified"> 79                        : new VarHandleInts.FieldInstanceReadWrite(refc, foffset);</span>
 80             }
 81             else if (type == long.class) {
<span class="line-modified"> 82                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
 83                        ? new VarHandleLongs.FieldInstanceReadOnly(refc, foffset)
<span class="line-modified"> 84                        : new VarHandleLongs.FieldInstanceReadWrite(refc, foffset);</span>
 85             }
 86             else if (type == float.class) {
<span class="line-modified"> 87                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
 88                        ? new VarHandleFloats.FieldInstanceReadOnly(refc, foffset)
<span class="line-modified"> 89                        : new VarHandleFloats.FieldInstanceReadWrite(refc, foffset);</span>
 90             }
 91             else if (type == double.class) {
<span class="line-modified"> 92                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
 93                        ? new VarHandleDoubles.FieldInstanceReadOnly(refc, foffset)
<span class="line-modified"> 94                        : new VarHandleDoubles.FieldInstanceReadWrite(refc, foffset);</span>
 95             }
 96             else {
 97                 throw new UnsupportedOperationException();
 98             }
 99         }
100         else {
101             // TODO This is not lazy on first invocation
102             // and might cause some circular initialization issues
103 
104             // Replace with something similar to direct method handles
105             // where a barrier is used then elided after use
106 
107             if (UNSAFE.shouldBeInitialized(refc))
108                 UNSAFE.ensureClassInitialized(refc);
109 
110             Object base = MethodHandleNatives.staticFieldBase(f);
111             long foffset = MethodHandleNatives.staticFieldOffset(f);
112             if (!type.isPrimitive()) {
<span class="line-modified">113                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
114                        ? new VarHandleReferences.FieldStaticReadOnly(base, foffset, type)
<span class="line-modified">115                        : new VarHandleReferences.FieldStaticReadWrite(base, foffset, type);</span>
116             }
117             else if (type == boolean.class) {
<span class="line-modified">118                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
119                        ? new VarHandleBooleans.FieldStaticReadOnly(base, foffset)
<span class="line-modified">120                        : new VarHandleBooleans.FieldStaticReadWrite(base, foffset);</span>
121             }
122             else if (type == byte.class) {
<span class="line-modified">123                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
124                        ? new VarHandleBytes.FieldStaticReadOnly(base, foffset)
<span class="line-modified">125                        : new VarHandleBytes.FieldStaticReadWrite(base, foffset);</span>
126             }
127             else if (type == short.class) {
<span class="line-modified">128                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
129                        ? new VarHandleShorts.FieldStaticReadOnly(base, foffset)
<span class="line-modified">130                        : new VarHandleShorts.FieldStaticReadWrite(base, foffset);</span>
131             }
132             else if (type == char.class) {
<span class="line-modified">133                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
134                        ? new VarHandleChars.FieldStaticReadOnly(base, foffset)
<span class="line-modified">135                        : new VarHandleChars.FieldStaticReadWrite(base, foffset);</span>
136             }
137             else if (type == int.class) {
<span class="line-modified">138                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
139                        ? new VarHandleInts.FieldStaticReadOnly(base, foffset)
<span class="line-modified">140                        : new VarHandleInts.FieldStaticReadWrite(base, foffset);</span>
141             }
142             else if (type == long.class) {
<span class="line-modified">143                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
144                        ? new VarHandleLongs.FieldStaticReadOnly(base, foffset)
<span class="line-modified">145                        : new VarHandleLongs.FieldStaticReadWrite(base, foffset);</span>
146             }
147             else if (type == float.class) {
<span class="line-modified">148                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
149                        ? new VarHandleFloats.FieldStaticReadOnly(base, foffset)
<span class="line-modified">150                        : new VarHandleFloats.FieldStaticReadWrite(base, foffset);</span>
151             }
152             else if (type == double.class) {
<span class="line-modified">153                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
154                        ? new VarHandleDoubles.FieldStaticReadOnly(base, foffset)
<span class="line-modified">155                        : new VarHandleDoubles.FieldStaticReadWrite(base, foffset);</span>
156             }
157             else {
158                 throw new UnsupportedOperationException();
159             }
160         }
161     }
162 
163     // Required by instance field handles
164     static Field getFieldFromReceiverAndOffset(Class&lt;?&gt; receiverType,
165                                                long offset,
166                                                Class&lt;?&gt; fieldType) {
167         for (Field f : receiverType.getDeclaredFields()) {
168             if (Modifier.isStatic(f.getModifiers())) continue;
169 
170             if (offset == UNSAFE.objectFieldOffset(f)) {
171                 assert f.getType() == fieldType;
172                 return f;
173             }
174         }
175         throw new InternalError(&quot;Field not found at offset&quot;);
</pre>
<hr />
<pre>
186 
187             if (offset == UNSAFE.staticFieldOffset(f)) {
188                 assert f.getType() == fieldType;
189                 return f;
190             }
191         }
192         throw new InternalError(&quot;Static field not found at offset&quot;);
193     }
194 
195     static VarHandle makeArrayElementHandle(Class&lt;?&gt; arrayClass) {
196         if (!arrayClass.isArray())
197             throw new IllegalArgumentException(&quot;not an array: &quot; + arrayClass);
198 
199         Class&lt;?&gt; componentType = arrayClass.getComponentType();
200 
201         int aoffset = UNSAFE.arrayBaseOffset(arrayClass);
202         int ascale = UNSAFE.arrayIndexScale(arrayClass);
203         int ashift = 31 - Integer.numberOfLeadingZeros(ascale);
204 
205         if (!componentType.isPrimitive()) {
<span class="line-modified">206             return new VarHandleReferences.Array(aoffset, ashift, arrayClass);</span>
207         }
208         else if (componentType == boolean.class) {
<span class="line-modified">209             return new VarHandleBooleans.Array(aoffset, ashift);</span>
210         }
211         else if (componentType == byte.class) {
<span class="line-modified">212             return new VarHandleBytes.Array(aoffset, ashift);</span>
213         }
214         else if (componentType == short.class) {
<span class="line-modified">215             return new VarHandleShorts.Array(aoffset, ashift);</span>
216         }
217         else if (componentType == char.class) {
<span class="line-modified">218             return new VarHandleChars.Array(aoffset, ashift);</span>
219         }
220         else if (componentType == int.class) {
<span class="line-modified">221             return new VarHandleInts.Array(aoffset, ashift);</span>
222         }
223         else if (componentType == long.class) {
<span class="line-modified">224             return new VarHandleLongs.Array(aoffset, ashift);</span>
225         }
226         else if (componentType == float.class) {
<span class="line-modified">227             return new VarHandleFloats.Array(aoffset, ashift);</span>
228         }
229         else if (componentType == double.class) {
<span class="line-modified">230             return new VarHandleDoubles.Array(aoffset, ashift);</span>
231         }
232         else {
233             throw new UnsupportedOperationException();
234         }
235     }
236 
237     static VarHandle byteArrayViewHandle(Class&lt;?&gt; viewArrayClass,
238                                          boolean be) {
239         if (!viewArrayClass.isArray())
240             throw new IllegalArgumentException(&quot;not an array: &quot; + viewArrayClass);
241 
242         Class&lt;?&gt; viewComponentType = viewArrayClass.getComponentType();
243 
244         if (viewComponentType == long.class) {
<span class="line-modified">245             return new VarHandleByteArrayAsLongs.ArrayHandle(be);</span>
246         }
247         else if (viewComponentType == int.class) {
<span class="line-modified">248             return new VarHandleByteArrayAsInts.ArrayHandle(be);</span>
249         }
250         else if (viewComponentType == short.class) {
<span class="line-modified">251             return new VarHandleByteArrayAsShorts.ArrayHandle(be);</span>
252         }
253         else if (viewComponentType == char.class) {
<span class="line-modified">254             return new VarHandleByteArrayAsChars.ArrayHandle(be);</span>
255         }
256         else if (viewComponentType == double.class) {
<span class="line-modified">257             return new VarHandleByteArrayAsDoubles.ArrayHandle(be);</span>
258         }
259         else if (viewComponentType == float.class) {
<span class="line-modified">260             return new VarHandleByteArrayAsFloats.ArrayHandle(be);</span>
261         }
262 
263         throw new UnsupportedOperationException();
264     }
265 
266     static VarHandle makeByteBufferViewHandle(Class&lt;?&gt; viewArrayClass,
267                                               boolean be) {
268         if (!viewArrayClass.isArray())
269             throw new IllegalArgumentException(&quot;not an array: &quot; + viewArrayClass);
270 
271         Class&lt;?&gt; viewComponentType = viewArrayClass.getComponentType();
272 
273         if (viewComponentType == long.class) {
<span class="line-modified">274             return new VarHandleByteArrayAsLongs.ByteBufferHandle(be);</span>
275         }
276         else if (viewComponentType == int.class) {
<span class="line-modified">277             return new VarHandleByteArrayAsInts.ByteBufferHandle(be);</span>
278         }
279         else if (viewComponentType == short.class) {
<span class="line-modified">280             return new VarHandleByteArrayAsShorts.ByteBufferHandle(be);</span>
281         }
282         else if (viewComponentType == char.class) {
<span class="line-modified">283             return new VarHandleByteArrayAsChars.ByteBufferHandle(be);</span>
284         }
285         else if (viewComponentType == double.class) {
<span class="line-modified">286             return new VarHandleByteArrayAsDoubles.ByteBufferHandle(be);</span>
287         }
288         else if (viewComponentType == float.class) {
<span class="line-modified">289             return new VarHandleByteArrayAsFloats.ByteBufferHandle(be);</span>
290         }
291 
292         throw new UnsupportedOperationException();
293     }
294 
295     /**
296      * Creates a memory access VarHandle.
297      *
298      * Resulting VarHandle will take a memory address as first argument,
299      * and a certain number of coordinate {@code long} parameters, depending on the length
300      * of the {@code strides} argument array.
301      *
302      * Coordinates are multiplied with corresponding scale factors ({@code strides}) and added
303      * to a single fixed offset to compute an effective offset from the given MemoryAddress for the access.
304      *
305      * @param carrier the Java carrier type.
306      * @param alignmentMask alignment requirement to be checked upon access. In bytes. Expressed as a mask.
307      * @param byteOrder the byte order.
308      * @param offset a constant offset for the access.
309      * @param strides the scale factors with which to multiply given access coordinates.
310      * @return the created VarHandle.
311      */
312     static VarHandle makeMemoryAddressViewHandle(Class&lt;?&gt; carrier, long alignmentMask,
313                                                  ByteOrder byteOrder, long offset, long[] strides) {
314         if (!carrier.isPrimitive() || carrier == void.class || carrier == boolean.class) {
315             throw new IllegalArgumentException(&quot;Invalid carrier: &quot; + carrier.getName());
316         }
317         long size = Wrapper.forPrimitiveType(carrier).bitWidth() / 8;
318         boolean be = byteOrder == ByteOrder.BIG_ENDIAN;
319 
320         Map&lt;Integer, MethodHandle&gt; carrierFactory = ADDRESS_FACTORIES.get(carrier);
321         MethodHandle fac = carrierFactory.computeIfAbsent(strides.length,
<span class="line-modified">322                 dims -&gt; new AddressVarHandleGenerator(carrier, dims)</span>
323                             .generateHandleFactory());
324 
325         try {
<span class="line-modified">326             return (VarHandle)fac.invoke(be, size, offset, alignmentMask, strides);</span>
327         } catch (Throwable ex) {
328             throw new IllegalStateException(ex);
329         }
330     }
331 

















































































































































































































































332 //    /**
333 //     * A helper program to generate the VarHandleGuards class with a set of
334 //     * static guard methods each of which corresponds to a particular shape and
335 //     * performs a type check of the symbolic type descriptor with the VarHandle
336 //     * type descriptor before linking/invoking to the underlying operation as
337 //     * characterized by the operation member name on the VarForm of the
338 //     * VarHandle.
339 //     * &lt;p&gt;
340 //     * The generated class essentially encapsulates pre-compiled LambdaForms,
341 //     * one for each method, for the most set of common method signatures.
342 //     * This reduces static initialization costs, footprint costs, and circular
343 //     * dependencies that may arise if a class is generated per LambdaForm.
344 //     * &lt;p&gt;
345 //     * A maximum of L*T*S methods will be generated where L is the number of
346 //     * access modes kinds (or unique operation signatures) and T is the number
347 //     * of variable types and S is the number of shapes (such as instance field,
348 //     * static field, or array access).
349 //     * If there are 4 unique operation signatures, 5 basic types (Object, int,
350 //     * long, float, double), and 3 shapes then a maximum of 60 methods will be
351 //     * generated.  However, the number is likely to be less since there
352 //     * be duplicate signatures.
353 //     * &lt;p&gt;
354 //     * Each method is annotated with @LambdaForm.Compiled to inform the runtime
355 //     * that such methods should be treated as if a method of a class that is the
356 //     * result of compiling a LambdaForm.  Annotation of such methods is
357 //     * important for correct evaluation of certain assertions and method return
358 //     * type profiling in HotSpot.
359 //     */
360 //    public static class GuardMethodGenerator {
361 //
362 //        static final String GUARD_METHOD_SIG_TEMPLATE = &quot;&lt;RETURN&gt; &lt;NAME&gt;_&lt;SIGNATURE&gt;(&lt;PARAMS&gt;)&quot;;
363 //
364 //        static final String GUARD_METHOD_TEMPLATE =
365 //                &quot;@ForceInline\n&quot; +
366 //                &quot;@LambdaForm.Compiled\n&quot; +
367 //                &quot;final static &lt;METHOD&gt; throws Throwable {\n&quot; +
<span class="line-modified">368 //                &quot;    if (handle.vform.methodType_table[ad.type] == ad.symbolicMethodType) {\n&quot; +</span>
369 //                &quot;        &lt;RESULT_ERASED&gt;MethodHandle.linkToStatic(&lt;LINK_TO_STATIC_ARGS&gt;);&lt;RETURN_ERASED&gt;\n&quot; +
370 //                &quot;    }\n&quot; +
371 //                &quot;    else {\n&quot; +
372 //                &quot;        MethodHandle mh = handle.getMethodHandle(ad.mode);\n&quot; +
373 //                &quot;        &lt;RETURN&gt;mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(&lt;LINK_TO_INVOKER_ARGS&gt;);\n&quot; +
374 //                &quot;    }\n&quot; +
375 //                &quot;}&quot;;
376 //
377 //        static final String GUARD_METHOD_TEMPLATE_V =
378 //                &quot;@ForceInline\n&quot; +
379 //                &quot;@LambdaForm.Compiled\n&quot; +
380 //                &quot;final static &lt;METHOD&gt; throws Throwable {\n&quot; +
<span class="line-modified">381 //                &quot;    if (handle.vform.methodType_table[ad.type] == ad.symbolicMethodType) {\n&quot; +</span>
382 //                &quot;        MethodHandle.linkToStatic(&lt;LINK_TO_STATIC_ARGS&gt;);\n&quot; +
383 //                &quot;    }\n&quot; +
<span class="line-modified">384 //                &quot;    else if (handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodType) {\n&quot; +</span>
385 //                &quot;        MethodHandle.linkToStatic(&lt;LINK_TO_STATIC_ARGS&gt;);\n&quot; +
386 //                &quot;    }\n&quot; +
387 //                &quot;    else {\n&quot; +
388 //                &quot;        MethodHandle mh = handle.getMethodHandle(ad.mode);\n&quot; +
389 //                &quot;        mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(&lt;LINK_TO_INVOKER_ARGS&gt;);\n&quot; +
390 //                &quot;    }\n&quot; +
391 //                &quot;}&quot;;
392 //
393 //        // A template for deriving the operations
394 //        // could be supported by annotating VarHandle directly with the
395 //        // operation kind and shape
396 //        interface VarHandleTemplate {
397 //            Object get();
398 //
399 //            void set(Object value);
400 //
401 //            boolean compareAndSet(Object actualValue, Object expectedValue);
402 //
403 //            Object compareAndExchange(Object actualValue, Object expectedValue);
404 //
</pre>
</td>
<td>
<hr />
<pre>
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.lang.invoke;
 27 
 28 import sun.invoke.util.Wrapper;
 29 
<span class="line-added"> 30 import java.lang.reflect.Constructor;</span>
 31 import java.lang.reflect.Field;
<span class="line-added"> 32 import java.lang.reflect.Method;</span>
 33 import java.lang.reflect.Modifier;
 34 import java.nio.ByteOrder;
<span class="line-added"> 35 import java.util.ArrayList;</span>
<span class="line-added"> 36 import java.util.List;</span>
 37 import java.util.Map;
<span class="line-added"> 38 import java.util.Objects;</span>
 39 import java.util.concurrent.ConcurrentHashMap;
 40 import java.util.concurrent.ConcurrentMap;
<span class="line-added"> 41 import java.util.stream.Stream;</span>
 42 
 43 import static java.lang.invoke.MethodHandleStatics.UNSAFE;
<span class="line-added"> 44 import static java.lang.invoke.MethodHandleStatics.VAR_HANDLE_IDENTITY_ADAPT;</span>
<span class="line-added"> 45 import static java.lang.invoke.MethodHandleStatics.newIllegalArgumentException;</span>
 46 
 47 final class VarHandles {
 48 
 49     static ClassValue&lt;ConcurrentMap&lt;Integer, MethodHandle&gt;&gt; ADDRESS_FACTORIES = new ClassValue&lt;&gt;() {
 50         @Override
 51         protected ConcurrentMap&lt;Integer, MethodHandle&gt; computeValue(Class&lt;?&gt; type) {
 52             return new ConcurrentHashMap&lt;&gt;();
 53         }
 54     };
 55 
 56     static VarHandle makeFieldHandle(MemberName f, Class&lt;?&gt; refc, Class&lt;?&gt; type, boolean isWriteAllowedOnFinalFields) {
 57         if (!f.isStatic()) {
 58             long foffset = MethodHandleNatives.objectFieldOffset(f);
 59             if (!type.isPrimitive()) {
<span class="line-modified"> 60                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
 61                        ? new VarHandleReferences.FieldInstanceReadOnly(refc, foffset, type)
<span class="line-modified"> 62                        : new VarHandleReferences.FieldInstanceReadWrite(refc, foffset, type));</span>
 63             }
 64             else if (type == boolean.class) {
<span class="line-modified"> 65                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
 66                        ? new VarHandleBooleans.FieldInstanceReadOnly(refc, foffset)
<span class="line-modified"> 67                        : new VarHandleBooleans.FieldInstanceReadWrite(refc, foffset));</span>
 68             }
 69             else if (type == byte.class) {
<span class="line-modified"> 70                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
 71                        ? new VarHandleBytes.FieldInstanceReadOnly(refc, foffset)
<span class="line-modified"> 72                        : new VarHandleBytes.FieldInstanceReadWrite(refc, foffset));</span>
 73             }
 74             else if (type == short.class) {
<span class="line-modified"> 75                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
 76                        ? new VarHandleShorts.FieldInstanceReadOnly(refc, foffset)
<span class="line-modified"> 77                        : new VarHandleShorts.FieldInstanceReadWrite(refc, foffset));</span>
 78             }
 79             else if (type == char.class) {
<span class="line-modified"> 80                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
 81                        ? new VarHandleChars.FieldInstanceReadOnly(refc, foffset)
<span class="line-modified"> 82                        : new VarHandleChars.FieldInstanceReadWrite(refc, foffset));</span>
 83             }
 84             else if (type == int.class) {
<span class="line-modified"> 85                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
 86                        ? new VarHandleInts.FieldInstanceReadOnly(refc, foffset)
<span class="line-modified"> 87                        : new VarHandleInts.FieldInstanceReadWrite(refc, foffset));</span>
 88             }
 89             else if (type == long.class) {
<span class="line-modified"> 90                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
 91                        ? new VarHandleLongs.FieldInstanceReadOnly(refc, foffset)
<span class="line-modified"> 92                        : new VarHandleLongs.FieldInstanceReadWrite(refc, foffset));</span>
 93             }
 94             else if (type == float.class) {
<span class="line-modified"> 95                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
 96                        ? new VarHandleFloats.FieldInstanceReadOnly(refc, foffset)
<span class="line-modified"> 97                        : new VarHandleFloats.FieldInstanceReadWrite(refc, foffset));</span>
 98             }
 99             else if (type == double.class) {
<span class="line-modified">100                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
101                        ? new VarHandleDoubles.FieldInstanceReadOnly(refc, foffset)
<span class="line-modified">102                        : new VarHandleDoubles.FieldInstanceReadWrite(refc, foffset));</span>
103             }
104             else {
105                 throw new UnsupportedOperationException();
106             }
107         }
108         else {
109             // TODO This is not lazy on first invocation
110             // and might cause some circular initialization issues
111 
112             // Replace with something similar to direct method handles
113             // where a barrier is used then elided after use
114 
115             if (UNSAFE.shouldBeInitialized(refc))
116                 UNSAFE.ensureClassInitialized(refc);
117 
118             Object base = MethodHandleNatives.staticFieldBase(f);
119             long foffset = MethodHandleNatives.staticFieldOffset(f);
120             if (!type.isPrimitive()) {
<span class="line-modified">121                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
122                        ? new VarHandleReferences.FieldStaticReadOnly(base, foffset, type)
<span class="line-modified">123                        : new VarHandleReferences.FieldStaticReadWrite(base, foffset, type));</span>
124             }
125             else if (type == boolean.class) {
<span class="line-modified">126                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
127                        ? new VarHandleBooleans.FieldStaticReadOnly(base, foffset)
<span class="line-modified">128                        : new VarHandleBooleans.FieldStaticReadWrite(base, foffset));</span>
129             }
130             else if (type == byte.class) {
<span class="line-modified">131                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
132                        ? new VarHandleBytes.FieldStaticReadOnly(base, foffset)
<span class="line-modified">133                        : new VarHandleBytes.FieldStaticReadWrite(base, foffset));</span>
134             }
135             else if (type == short.class) {
<span class="line-modified">136                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
137                        ? new VarHandleShorts.FieldStaticReadOnly(base, foffset)
<span class="line-modified">138                        : new VarHandleShorts.FieldStaticReadWrite(base, foffset));</span>
139             }
140             else if (type == char.class) {
<span class="line-modified">141                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
142                        ? new VarHandleChars.FieldStaticReadOnly(base, foffset)
<span class="line-modified">143                        : new VarHandleChars.FieldStaticReadWrite(base, foffset));</span>
144             }
145             else if (type == int.class) {
<span class="line-modified">146                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
147                        ? new VarHandleInts.FieldStaticReadOnly(base, foffset)
<span class="line-modified">148                        : new VarHandleInts.FieldStaticReadWrite(base, foffset));</span>
149             }
150             else if (type == long.class) {
<span class="line-modified">151                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
152                        ? new VarHandleLongs.FieldStaticReadOnly(base, foffset)
<span class="line-modified">153                        : new VarHandleLongs.FieldStaticReadWrite(base, foffset));</span>
154             }
155             else if (type == float.class) {
<span class="line-modified">156                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
157                        ? new VarHandleFloats.FieldStaticReadOnly(base, foffset)
<span class="line-modified">158                        : new VarHandleFloats.FieldStaticReadWrite(base, foffset));</span>
159             }
160             else if (type == double.class) {
<span class="line-modified">161                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
162                        ? new VarHandleDoubles.FieldStaticReadOnly(base, foffset)
<span class="line-modified">163                        : new VarHandleDoubles.FieldStaticReadWrite(base, foffset));</span>
164             }
165             else {
166                 throw new UnsupportedOperationException();
167             }
168         }
169     }
170 
171     // Required by instance field handles
172     static Field getFieldFromReceiverAndOffset(Class&lt;?&gt; receiverType,
173                                                long offset,
174                                                Class&lt;?&gt; fieldType) {
175         for (Field f : receiverType.getDeclaredFields()) {
176             if (Modifier.isStatic(f.getModifiers())) continue;
177 
178             if (offset == UNSAFE.objectFieldOffset(f)) {
179                 assert f.getType() == fieldType;
180                 return f;
181             }
182         }
183         throw new InternalError(&quot;Field not found at offset&quot;);
</pre>
<hr />
<pre>
194 
195             if (offset == UNSAFE.staticFieldOffset(f)) {
196                 assert f.getType() == fieldType;
197                 return f;
198             }
199         }
200         throw new InternalError(&quot;Static field not found at offset&quot;);
201     }
202 
203     static VarHandle makeArrayElementHandle(Class&lt;?&gt; arrayClass) {
204         if (!arrayClass.isArray())
205             throw new IllegalArgumentException(&quot;not an array: &quot; + arrayClass);
206 
207         Class&lt;?&gt; componentType = arrayClass.getComponentType();
208 
209         int aoffset = UNSAFE.arrayBaseOffset(arrayClass);
210         int ascale = UNSAFE.arrayIndexScale(arrayClass);
211         int ashift = 31 - Integer.numberOfLeadingZeros(ascale);
212 
213         if (!componentType.isPrimitive()) {
<span class="line-modified">214             return maybeAdapt(new VarHandleReferences.Array(aoffset, ashift, arrayClass));</span>
215         }
216         else if (componentType == boolean.class) {
<span class="line-modified">217             return maybeAdapt(new VarHandleBooleans.Array(aoffset, ashift));</span>
218         }
219         else if (componentType == byte.class) {
<span class="line-modified">220             return maybeAdapt(new VarHandleBytes.Array(aoffset, ashift));</span>
221         }
222         else if (componentType == short.class) {
<span class="line-modified">223             return maybeAdapt(new VarHandleShorts.Array(aoffset, ashift));</span>
224         }
225         else if (componentType == char.class) {
<span class="line-modified">226             return maybeAdapt(new VarHandleChars.Array(aoffset, ashift));</span>
227         }
228         else if (componentType == int.class) {
<span class="line-modified">229             return maybeAdapt(new VarHandleInts.Array(aoffset, ashift));</span>
230         }
231         else if (componentType == long.class) {
<span class="line-modified">232             return maybeAdapt(new VarHandleLongs.Array(aoffset, ashift));</span>
233         }
234         else if (componentType == float.class) {
<span class="line-modified">235             return maybeAdapt(new VarHandleFloats.Array(aoffset, ashift));</span>
236         }
237         else if (componentType == double.class) {
<span class="line-modified">238             return maybeAdapt(new VarHandleDoubles.Array(aoffset, ashift));</span>
239         }
240         else {
241             throw new UnsupportedOperationException();
242         }
243     }
244 
245     static VarHandle byteArrayViewHandle(Class&lt;?&gt; viewArrayClass,
246                                          boolean be) {
247         if (!viewArrayClass.isArray())
248             throw new IllegalArgumentException(&quot;not an array: &quot; + viewArrayClass);
249 
250         Class&lt;?&gt; viewComponentType = viewArrayClass.getComponentType();
251 
252         if (viewComponentType == long.class) {
<span class="line-modified">253             return maybeAdapt(new VarHandleByteArrayAsLongs.ArrayHandle(be));</span>
254         }
255         else if (viewComponentType == int.class) {
<span class="line-modified">256             return maybeAdapt(new VarHandleByteArrayAsInts.ArrayHandle(be));</span>
257         }
258         else if (viewComponentType == short.class) {
<span class="line-modified">259             return maybeAdapt(new VarHandleByteArrayAsShorts.ArrayHandle(be));</span>
260         }
261         else if (viewComponentType == char.class) {
<span class="line-modified">262             return maybeAdapt(new VarHandleByteArrayAsChars.ArrayHandle(be));</span>
263         }
264         else if (viewComponentType == double.class) {
<span class="line-modified">265             return maybeAdapt(new VarHandleByteArrayAsDoubles.ArrayHandle(be));</span>
266         }
267         else if (viewComponentType == float.class) {
<span class="line-modified">268             return maybeAdapt(new VarHandleByteArrayAsFloats.ArrayHandle(be));</span>
269         }
270 
271         throw new UnsupportedOperationException();
272     }
273 
274     static VarHandle makeByteBufferViewHandle(Class&lt;?&gt; viewArrayClass,
275                                               boolean be) {
276         if (!viewArrayClass.isArray())
277             throw new IllegalArgumentException(&quot;not an array: &quot; + viewArrayClass);
278 
279         Class&lt;?&gt; viewComponentType = viewArrayClass.getComponentType();
280 
281         if (viewComponentType == long.class) {
<span class="line-modified">282             return maybeAdapt(new VarHandleByteArrayAsLongs.ByteBufferHandle(be));</span>
283         }
284         else if (viewComponentType == int.class) {
<span class="line-modified">285             return maybeAdapt(new VarHandleByteArrayAsInts.ByteBufferHandle(be));</span>
286         }
287         else if (viewComponentType == short.class) {
<span class="line-modified">288             return maybeAdapt(new VarHandleByteArrayAsShorts.ByteBufferHandle(be));</span>
289         }
290         else if (viewComponentType == char.class) {
<span class="line-modified">291             return maybeAdapt(new VarHandleByteArrayAsChars.ByteBufferHandle(be));</span>
292         }
293         else if (viewComponentType == double.class) {
<span class="line-modified">294             return maybeAdapt(new VarHandleByteArrayAsDoubles.ByteBufferHandle(be));</span>
295         }
296         else if (viewComponentType == float.class) {
<span class="line-modified">297             return maybeAdapt(new VarHandleByteArrayAsFloats.ByteBufferHandle(be));</span>
298         }
299 
300         throw new UnsupportedOperationException();
301     }
302 
303     /**
304      * Creates a memory access VarHandle.
305      *
306      * Resulting VarHandle will take a memory address as first argument,
307      * and a certain number of coordinate {@code long} parameters, depending on the length
308      * of the {@code strides} argument array.
309      *
310      * Coordinates are multiplied with corresponding scale factors ({@code strides}) and added
311      * to a single fixed offset to compute an effective offset from the given MemoryAddress for the access.
312      *
313      * @param carrier the Java carrier type.
314      * @param alignmentMask alignment requirement to be checked upon access. In bytes. Expressed as a mask.
315      * @param byteOrder the byte order.
316      * @param offset a constant offset for the access.
317      * @param strides the scale factors with which to multiply given access coordinates.
318      * @return the created VarHandle.
319      */
320     static VarHandle makeMemoryAddressViewHandle(Class&lt;?&gt; carrier, long alignmentMask,
321                                                  ByteOrder byteOrder, long offset, long[] strides) {
322         if (!carrier.isPrimitive() || carrier == void.class || carrier == boolean.class) {
323             throw new IllegalArgumentException(&quot;Invalid carrier: &quot; + carrier.getName());
324         }
325         long size = Wrapper.forPrimitiveType(carrier).bitWidth() / 8;
326         boolean be = byteOrder == ByteOrder.BIG_ENDIAN;
327 
328         Map&lt;Integer, MethodHandle&gt; carrierFactory = ADDRESS_FACTORIES.get(carrier);
329         MethodHandle fac = carrierFactory.computeIfAbsent(strides.length,
<span class="line-modified">330                 dims -&gt; new MemoryAccessVarHandleGenerator(carrier, dims)</span>
331                             .generateHandleFactory());
332 
333         try {
<span class="line-modified">334             return maybeAdapt((VarHandle)fac.invoke(be, size, offset, alignmentMask, strides));</span>
335         } catch (Throwable ex) {
336             throw new IllegalStateException(ex);
337         }
338     }
339 
<span class="line-added">340     private static VarHandle maybeAdapt(VarHandle target) {</span>
<span class="line-added">341         if (!VAR_HANDLE_IDENTITY_ADAPT) return target;</span>
<span class="line-added">342         target = filterValue(target,</span>
<span class="line-added">343                         MethodHandles.identity(target.varType()), MethodHandles.identity(target.varType()));</span>
<span class="line-added">344         MethodType mtype = target.accessModeType(VarHandle.AccessMode.GET).dropParameterTypes(0, 1);</span>
<span class="line-added">345         for (int i = 0 ; i &lt; mtype.parameterCount() ; i++) {</span>
<span class="line-added">346             target = filterCoordinates(target, i, MethodHandles.identity(mtype.parameterType(i)));</span>
<span class="line-added">347         }</span>
<span class="line-added">348         return target;</span>
<span class="line-added">349     }</span>
<span class="line-added">350 </span>
<span class="line-added">351     public static VarHandle filterValue(VarHandle target, MethodHandle filterToTarget, MethodHandle filterFromTarget) {</span>
<span class="line-added">352         Objects.nonNull(target);</span>
<span class="line-added">353         Objects.nonNull(filterToTarget);</span>
<span class="line-added">354         Objects.nonNull(filterFromTarget);</span>
<span class="line-added">355         //check that from/to filters do not throw checked exceptions</span>
<span class="line-added">356         noCheckedExceptions(filterToTarget);</span>
<span class="line-added">357         noCheckedExceptions(filterFromTarget);</span>
<span class="line-added">358 </span>
<span class="line-added">359         //check that from/to filters have right signatures</span>
<span class="line-added">360         if (filterFromTarget.type().parameterCount() != 1) {</span>
<span class="line-added">361             throw newIllegalArgumentException(&quot;filterFromTarget filter type has wrong arity&quot;, filterFromTarget.type());</span>
<span class="line-added">362         } else if (filterToTarget.type().parameterCount() != 1) {</span>
<span class="line-added">363             throw newIllegalArgumentException(&quot;filterToTarget filter type has wrong arity&quot;, filterFromTarget.type());</span>
<span class="line-added">364         } else if (filterFromTarget.type().parameterType(0) != filterToTarget.type().returnType() ||</span>
<span class="line-added">365                 filterToTarget.type().parameterType(0) != filterFromTarget.type().returnType()) {</span>
<span class="line-added">366             throw newIllegalArgumentException(&quot;filterFromTarget and filterToTarget filter types do not match&quot;, filterFromTarget.type(), filterToTarget.type());</span>
<span class="line-added">367         } else if (target.varType() != filterFromTarget.type().parameterType(0)) {</span>
<span class="line-added">368             throw newIllegalArgumentException(&quot;filterFromTarget filter type does not match target var handle type&quot;, filterFromTarget.type(), target.varType());</span>
<span class="line-added">369         } else if (target.varType() != filterToTarget.type().returnType()) {</span>
<span class="line-added">370             throw newIllegalArgumentException(&quot;filterFromTarget filter type does not match target var handle type&quot;, filterToTarget.type(), target.varType());</span>
<span class="line-added">371         }</span>
<span class="line-added">372 </span>
<span class="line-added">373         return new IndirectVarHandle(target, filterFromTarget.type().returnType(), target.coordinateTypes().toArray(new Class&lt;?&gt;[0]),</span>
<span class="line-added">374                 (mode, modeHandle) -&gt; {</span>
<span class="line-added">375                     int lastParameterPos = modeHandle.type().parameterCount() - 1;</span>
<span class="line-added">376                     return switch (mode.at) {</span>
<span class="line-added">377                         case GET -&gt; MethodHandles.filterReturnValue(modeHandle, filterFromTarget);</span>
<span class="line-added">378                         case SET -&gt; MethodHandles.filterArgument(modeHandle, lastParameterPos, filterToTarget);</span>
<span class="line-added">379                         case GET_AND_UPDATE -&gt; {</span>
<span class="line-added">380                             MethodHandle adapter = MethodHandles.filterReturnValue(modeHandle, filterFromTarget);</span>
<span class="line-added">381                             yield MethodHandles.filterArgument(adapter, lastParameterPos, filterToTarget);</span>
<span class="line-added">382                         }</span>
<span class="line-added">383                         case COMPARE_AND_EXCHANGE -&gt; {</span>
<span class="line-added">384                             MethodHandle adapter = MethodHandles.filterReturnValue(modeHandle, filterFromTarget);</span>
<span class="line-added">385                             adapter = MethodHandles.filterArgument(adapter, lastParameterPos, filterToTarget);</span>
<span class="line-added">386                             yield MethodHandles.filterArgument(adapter, lastParameterPos - 1, filterToTarget);</span>
<span class="line-added">387                         }</span>
<span class="line-added">388                         case COMPARE_AND_SET -&gt; {</span>
<span class="line-added">389                             MethodHandle adapter = MethodHandles.filterArgument(modeHandle, lastParameterPos, filterToTarget);</span>
<span class="line-added">390                             yield MethodHandles.filterArgument(adapter, lastParameterPos - 1, filterToTarget);</span>
<span class="line-added">391                         }</span>
<span class="line-added">392                     };</span>
<span class="line-added">393                 });</span>
<span class="line-added">394     }</span>
<span class="line-added">395 </span>
<span class="line-added">396     public static VarHandle filterCoordinates(VarHandle target, int pos, MethodHandle... filters) {</span>
<span class="line-added">397         Objects.nonNull(target);</span>
<span class="line-added">398         Objects.nonNull(filters);</span>
<span class="line-added">399 </span>
<span class="line-added">400         List&lt;Class&lt;?&gt;&gt; targetCoordinates = target.coordinateTypes();</span>
<span class="line-added">401         if (pos &lt; 0 || pos &gt;= targetCoordinates.size()) {</span>
<span class="line-added">402             throw newIllegalArgumentException(&quot;Invalid position &quot; + pos + &quot; for coordinate types&quot;, targetCoordinates);</span>
<span class="line-added">403         } else if (pos + filters.length &gt; targetCoordinates.size()) {</span>
<span class="line-added">404             throw new IllegalArgumentException(&quot;Too many filters&quot;);</span>
<span class="line-added">405         }</span>
<span class="line-added">406 </span>
<span class="line-added">407         if (filters.length == 0) return target;</span>
<span class="line-added">408 </span>
<span class="line-added">409         List&lt;Class&lt;?&gt;&gt; newCoordinates = new ArrayList&lt;&gt;(targetCoordinates);</span>
<span class="line-added">410         for (int i = 0 ; i &lt; filters.length ; i++) {</span>
<span class="line-added">411             noCheckedExceptions(filters[i]);</span>
<span class="line-added">412             MethodType filterType = filters[i].type();</span>
<span class="line-added">413             if (filterType.parameterCount() != 1) {</span>
<span class="line-added">414                 throw newIllegalArgumentException(&quot;Invalid filter type &quot; + filterType);</span>
<span class="line-added">415             } else if (newCoordinates.get(pos + i) != filterType.returnType()) {</span>
<span class="line-added">416                 throw newIllegalArgumentException(&quot;Invalid filter type &quot; + filterType + &quot; for coordinate type &quot; + newCoordinates.get(i));</span>
<span class="line-added">417             }</span>
<span class="line-added">418             newCoordinates.set(pos + i, filters[i].type().parameterType(0));</span>
<span class="line-added">419         }</span>
<span class="line-added">420 </span>
<span class="line-added">421         return new IndirectVarHandle(target, target.varType(), newCoordinates.toArray(new Class&lt;?&gt;[0]),</span>
<span class="line-added">422                 (mode, modeHandle) -&gt; MethodHandles.filterArguments(modeHandle, 1 + pos, filters));</span>
<span class="line-added">423     }</span>
<span class="line-added">424 </span>
<span class="line-added">425     public static VarHandle insertCoordinates(VarHandle target, int pos, Object... values) {</span>
<span class="line-added">426         Objects.nonNull(target);</span>
<span class="line-added">427         Objects.nonNull(values);</span>
<span class="line-added">428 </span>
<span class="line-added">429         List&lt;Class&lt;?&gt;&gt; targetCoordinates = target.coordinateTypes();</span>
<span class="line-added">430         if (pos &lt; 0 || pos &gt;= targetCoordinates.size()) {</span>
<span class="line-added">431             throw newIllegalArgumentException(&quot;Invalid position &quot; + pos + &quot; for coordinate types&quot;, targetCoordinates);</span>
<span class="line-added">432         } else if (pos + values.length &gt; targetCoordinates.size()) {</span>
<span class="line-added">433             throw new IllegalArgumentException(&quot;Too many values&quot;);</span>
<span class="line-added">434         }</span>
<span class="line-added">435 </span>
<span class="line-added">436         if (values.length == 0) return target;</span>
<span class="line-added">437 </span>
<span class="line-added">438         List&lt;Class&lt;?&gt;&gt; newCoordinates = new ArrayList&lt;&gt;(targetCoordinates);</span>
<span class="line-added">439         for (int i = 0 ; i &lt; values.length ; i++) {</span>
<span class="line-added">440             Class&lt;?&gt; pt = newCoordinates.get(pos);</span>
<span class="line-added">441             if (pt.isPrimitive()) {</span>
<span class="line-added">442                 Wrapper w = Wrapper.forPrimitiveType(pt);</span>
<span class="line-added">443                 w.convert(values[i], pt);</span>
<span class="line-added">444             } else {</span>
<span class="line-added">445                 pt.cast(values[i]);</span>
<span class="line-added">446             }</span>
<span class="line-added">447             newCoordinates.remove(pos);</span>
<span class="line-added">448         }</span>
<span class="line-added">449 </span>
<span class="line-added">450         return new IndirectVarHandle(target, target.varType(), newCoordinates.toArray(new Class&lt;?&gt;[0]),</span>
<span class="line-added">451                 (mode, modeHandle) -&gt; MethodHandles.insertArguments(modeHandle, 1 + pos, values));</span>
<span class="line-added">452     }</span>
<span class="line-added">453 </span>
<span class="line-added">454     public static VarHandle permuteCoordinates(VarHandle target, List&lt;Class&lt;?&gt;&gt; newCoordinates, int... reorder) {</span>
<span class="line-added">455         Objects.nonNull(target);</span>
<span class="line-added">456         Objects.nonNull(newCoordinates);</span>
<span class="line-added">457         Objects.nonNull(reorder);</span>
<span class="line-added">458 </span>
<span class="line-added">459         List&lt;Class&lt;?&gt;&gt; targetCoordinates = target.coordinateTypes();</span>
<span class="line-added">460         MethodHandles.permuteArgumentChecks(reorder,</span>
<span class="line-added">461                 MethodType.methodType(void.class, newCoordinates),</span>
<span class="line-added">462                 MethodType.methodType(void.class, targetCoordinates));</span>
<span class="line-added">463 </span>
<span class="line-added">464         return new IndirectVarHandle(target, target.varType(), newCoordinates.toArray(new Class&lt;?&gt;[0]),</span>
<span class="line-added">465                 (mode, modeHandle) -&gt;</span>
<span class="line-added">466                         MethodHandles.permuteArguments(modeHandle,</span>
<span class="line-added">467                                 methodTypeFor(mode.at, modeHandle.type(), targetCoordinates, newCoordinates),</span>
<span class="line-added">468                                 reorderArrayFor(mode.at, newCoordinates, reorder)));</span>
<span class="line-added">469     }</span>
<span class="line-added">470 </span>
<span class="line-added">471     private static int numTrailingArgs(VarHandle.AccessType at) {</span>
<span class="line-added">472         return switch (at) {</span>
<span class="line-added">473             case GET -&gt; 0;</span>
<span class="line-added">474             case GET_AND_UPDATE, SET -&gt; 1;</span>
<span class="line-added">475             case COMPARE_AND_SET, COMPARE_AND_EXCHANGE -&gt; 2;</span>
<span class="line-added">476         };</span>
<span class="line-added">477     }</span>
<span class="line-added">478 </span>
<span class="line-added">479     private static int[] reorderArrayFor(VarHandle.AccessType at, List&lt;Class&lt;?&gt;&gt; newCoordinates, int[] reorder) {</span>
<span class="line-added">480         int numTrailingArgs = numTrailingArgs(at);</span>
<span class="line-added">481         int[] adjustedReorder = new int[reorder.length + 1 + numTrailingArgs];</span>
<span class="line-added">482         adjustedReorder[0] = 0;</span>
<span class="line-added">483         for (int i = 0 ; i &lt; reorder.length ; i++) {</span>
<span class="line-added">484             adjustedReorder[i + 1] = reorder[i] + 1;</span>
<span class="line-added">485         }</span>
<span class="line-added">486         for (int i = 0 ; i &lt; numTrailingArgs ; i++) {</span>
<span class="line-added">487             adjustedReorder[i + reorder.length + 1] = i + newCoordinates.size() + 1;</span>
<span class="line-added">488         }</span>
<span class="line-added">489         return adjustedReorder;</span>
<span class="line-added">490     }</span>
<span class="line-added">491 </span>
<span class="line-added">492     private static MethodType methodTypeFor(VarHandle.AccessType at, MethodType oldType, List&lt;Class&lt;?&gt;&gt; oldCoordinates, List&lt;Class&lt;?&gt;&gt; newCoordinates) {</span>
<span class="line-added">493         int numTrailingArgs = numTrailingArgs(at);</span>
<span class="line-added">494         MethodType adjustedType = MethodType.methodType(oldType.returnType(), oldType.parameterType(0));</span>
<span class="line-added">495         adjustedType = adjustedType.appendParameterTypes(newCoordinates);</span>
<span class="line-added">496         for (int i = 0 ; i &lt; numTrailingArgs ; i++) {</span>
<span class="line-added">497             adjustedType = adjustedType.appendParameterTypes(oldType.parameterType(1 + oldCoordinates.size() + i));</span>
<span class="line-added">498         }</span>
<span class="line-added">499         return adjustedType;</span>
<span class="line-added">500     }</span>
<span class="line-added">501 </span>
<span class="line-added">502     public static VarHandle collectCoordinates(VarHandle target, int pos, MethodHandle filter) {</span>
<span class="line-added">503         Objects.nonNull(target);</span>
<span class="line-added">504         Objects.nonNull(filter);</span>
<span class="line-added">505         noCheckedExceptions(filter);</span>
<span class="line-added">506 </span>
<span class="line-added">507         List&lt;Class&lt;?&gt;&gt; targetCoordinates = target.coordinateTypes();</span>
<span class="line-added">508         if (pos &lt; 0 || pos &gt;= targetCoordinates.size()) {</span>
<span class="line-added">509             throw newIllegalArgumentException(&quot;Invalid position &quot; + pos + &quot; for coordinate types&quot;, targetCoordinates);</span>
<span class="line-added">510         } else if (filter.type().returnType() == void.class) {</span>
<span class="line-added">511             throw newIllegalArgumentException(&quot;Invalid filter type &quot; + filter.type() + &quot; ; filter cannot be void&quot;);</span>
<span class="line-added">512         } else if (filter.type().returnType() != targetCoordinates.get(pos)) {</span>
<span class="line-added">513             throw newIllegalArgumentException(&quot;Invalid filter type &quot; + filter.type() + &quot; for coordinate type &quot; + targetCoordinates.get(pos));</span>
<span class="line-added">514         }</span>
<span class="line-added">515 </span>
<span class="line-added">516         List&lt;Class&lt;?&gt;&gt; newCoordinates = new ArrayList&lt;&gt;(targetCoordinates);</span>
<span class="line-added">517         newCoordinates.remove(pos);</span>
<span class="line-added">518         newCoordinates.addAll(pos, filter.type().parameterList());</span>
<span class="line-added">519 </span>
<span class="line-added">520         return new IndirectVarHandle(target, target.varType(), newCoordinates.toArray(new Class&lt;?&gt;[0]),</span>
<span class="line-added">521                 (mode, modeHandle) -&gt; MethodHandles.collectArguments(modeHandle, 1 + pos, filter));</span>
<span class="line-added">522     }</span>
<span class="line-added">523 </span>
<span class="line-added">524     public static VarHandle dropCoordinates(VarHandle target, int pos, Class&lt;?&gt;... valueTypes) {</span>
<span class="line-added">525         Objects.nonNull(target);</span>
<span class="line-added">526         Objects.nonNull(valueTypes);</span>
<span class="line-added">527 </span>
<span class="line-added">528         List&lt;Class&lt;?&gt;&gt; targetCoordinates = target.coordinateTypes();</span>
<span class="line-added">529         if (pos &lt; 0 || pos &gt; targetCoordinates.size()) {</span>
<span class="line-added">530             throw newIllegalArgumentException(&quot;Invalid position &quot; + pos + &quot; for coordinate types&quot;, targetCoordinates);</span>
<span class="line-added">531         }</span>
<span class="line-added">532 </span>
<span class="line-added">533         if (valueTypes.length == 0) return target;</span>
<span class="line-added">534 </span>
<span class="line-added">535         List&lt;Class&lt;?&gt;&gt; newCoordinates = new ArrayList&lt;&gt;(targetCoordinates);</span>
<span class="line-added">536         newCoordinates.addAll(pos, List.of(valueTypes));</span>
<span class="line-added">537 </span>
<span class="line-added">538         return new IndirectVarHandle(target, target.varType(), newCoordinates.toArray(new Class&lt;?&gt;[0]),</span>
<span class="line-added">539                 (mode, modeHandle) -&gt; MethodHandles.dropArguments(modeHandle, 1 + pos, valueTypes));</span>
<span class="line-added">540     }</span>
<span class="line-added">541 </span>
<span class="line-added">542     private static void noCheckedExceptions(MethodHandle handle) {</span>
<span class="line-added">543         if (handle instanceof DirectMethodHandle) {</span>
<span class="line-added">544             DirectMethodHandle directHandle = (DirectMethodHandle)handle;</span>
<span class="line-added">545             MethodHandleInfo info = MethodHandles.Lookup.IMPL_LOOKUP.revealDirect(directHandle);</span>
<span class="line-added">546             Class&lt;?&gt;[] exceptionTypes = switch (info.getReferenceKind()) {</span>
<span class="line-added">547                 case MethodHandleInfo.REF_invokeInterface, MethodHandleInfo.REF_invokeSpecial,</span>
<span class="line-added">548                         MethodHandleInfo.REF_invokeStatic, MethodHandleInfo.REF_invokeVirtual -&gt;</span>
<span class="line-added">549                         info.reflectAs(Method.class, MethodHandles.Lookup.IMPL_LOOKUP).getExceptionTypes();</span>
<span class="line-added">550                 case MethodHandleInfo.REF_newInvokeSpecial -&gt;</span>
<span class="line-added">551                         info.reflectAs(Constructor.class, MethodHandles.Lookup.IMPL_LOOKUP).getExceptionTypes();</span>
<span class="line-added">552                 case MethodHandleInfo.REF_getField, MethodHandleInfo.REF_getStatic,</span>
<span class="line-added">553                         MethodHandleInfo.REF_putField, MethodHandleInfo.REF_putStatic -&gt; null;</span>
<span class="line-added">554                 default -&gt; throw new AssertionError(&quot;Cannot get here&quot;);</span>
<span class="line-added">555             };</span>
<span class="line-added">556             if (exceptionTypes != null) {</span>
<span class="line-added">557                 if (Stream.of(exceptionTypes).anyMatch(VarHandles::isCheckedException)) {</span>
<span class="line-added">558                     throw newIllegalArgumentException(&quot;Cannot adapt a var handle with a method handle which throws checked exceptions&quot;);</span>
<span class="line-added">559                 }</span>
<span class="line-added">560             }</span>
<span class="line-added">561         } else if (handle instanceof DelegatingMethodHandle) {</span>
<span class="line-added">562             noCheckedExceptions(((DelegatingMethodHandle)handle).getTarget());</span>
<span class="line-added">563         } else {</span>
<span class="line-added">564             //bound</span>
<span class="line-added">565             BoundMethodHandle boundHandle = (BoundMethodHandle)handle;</span>
<span class="line-added">566             for (int i = 0 ; i &lt; boundHandle.fieldCount() ; i++) {</span>
<span class="line-added">567                 Object arg = boundHandle.arg(i);</span>
<span class="line-added">568                 if (arg instanceof MethodHandle){</span>
<span class="line-added">569                     noCheckedExceptions((MethodHandle) arg);</span>
<span class="line-added">570                 }</span>
<span class="line-added">571             }</span>
<span class="line-added">572         }</span>
<span class="line-added">573     }</span>
<span class="line-added">574 </span>
<span class="line-added">575     private static boolean isCheckedException(Class&lt;?&gt; clazz) {</span>
<span class="line-added">576         return Throwable.class.isAssignableFrom(clazz) &amp;&amp;</span>
<span class="line-added">577                 !RuntimeException.class.isAssignableFrom(clazz) &amp;&amp;</span>
<span class="line-added">578                 !Error.class.isAssignableFrom(clazz);</span>
<span class="line-added">579     }</span>
<span class="line-added">580 </span>
581 //    /**
582 //     * A helper program to generate the VarHandleGuards class with a set of
583 //     * static guard methods each of which corresponds to a particular shape and
584 //     * performs a type check of the symbolic type descriptor with the VarHandle
585 //     * type descriptor before linking/invoking to the underlying operation as
586 //     * characterized by the operation member name on the VarForm of the
587 //     * VarHandle.
588 //     * &lt;p&gt;
589 //     * The generated class essentially encapsulates pre-compiled LambdaForms,
590 //     * one for each method, for the most set of common method signatures.
591 //     * This reduces static initialization costs, footprint costs, and circular
592 //     * dependencies that may arise if a class is generated per LambdaForm.
593 //     * &lt;p&gt;
594 //     * A maximum of L*T*S methods will be generated where L is the number of
595 //     * access modes kinds (or unique operation signatures) and T is the number
596 //     * of variable types and S is the number of shapes (such as instance field,
597 //     * static field, or array access).
598 //     * If there are 4 unique operation signatures, 5 basic types (Object, int,
599 //     * long, float, double), and 3 shapes then a maximum of 60 methods will be
600 //     * generated.  However, the number is likely to be less since there
601 //     * be duplicate signatures.
602 //     * &lt;p&gt;
603 //     * Each method is annotated with @LambdaForm.Compiled to inform the runtime
604 //     * that such methods should be treated as if a method of a class that is the
605 //     * result of compiling a LambdaForm.  Annotation of such methods is
606 //     * important for correct evaluation of certain assertions and method return
607 //     * type profiling in HotSpot.
608 //     */
609 //    public static class GuardMethodGenerator {
610 //
611 //        static final String GUARD_METHOD_SIG_TEMPLATE = &quot;&lt;RETURN&gt; &lt;NAME&gt;_&lt;SIGNATURE&gt;(&lt;PARAMS&gt;)&quot;;
612 //
613 //        static final String GUARD_METHOD_TEMPLATE =
614 //                &quot;@ForceInline\n&quot; +
615 //                &quot;@LambdaForm.Compiled\n&quot; +
616 //                &quot;final static &lt;METHOD&gt; throws Throwable {\n&quot; +
<span class="line-modified">617 //                &quot;    if (handle.isDirect() &amp;&amp; handle.vform.methodType_table[ad.type] == ad.symbolicMethodType) {\n&quot; +</span>
618 //                &quot;        &lt;RESULT_ERASED&gt;MethodHandle.linkToStatic(&lt;LINK_TO_STATIC_ARGS&gt;);&lt;RETURN_ERASED&gt;\n&quot; +
619 //                &quot;    }\n&quot; +
620 //                &quot;    else {\n&quot; +
621 //                &quot;        MethodHandle mh = handle.getMethodHandle(ad.mode);\n&quot; +
622 //                &quot;        &lt;RETURN&gt;mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(&lt;LINK_TO_INVOKER_ARGS&gt;);\n&quot; +
623 //                &quot;    }\n&quot; +
624 //                &quot;}&quot;;
625 //
626 //        static final String GUARD_METHOD_TEMPLATE_V =
627 //                &quot;@ForceInline\n&quot; +
628 //                &quot;@LambdaForm.Compiled\n&quot; +
629 //                &quot;final static &lt;METHOD&gt; throws Throwable {\n&quot; +
<span class="line-modified">630 //                &quot;    if (handle.isDirect() &amp;&amp; handle.vform.methodType_table[ad.type] == ad.symbolicMethodType) {\n&quot; +</span>
631 //                &quot;        MethodHandle.linkToStatic(&lt;LINK_TO_STATIC_ARGS&gt;);\n&quot; +
632 //                &quot;    }\n&quot; +
<span class="line-modified">633 //                &quot;    else if (handle.isDirect() &amp;&amp; handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodType) {\n&quot; +</span>
634 //                &quot;        MethodHandle.linkToStatic(&lt;LINK_TO_STATIC_ARGS&gt;);\n&quot; +
635 //                &quot;    }\n&quot; +
636 //                &quot;    else {\n&quot; +
637 //                &quot;        MethodHandle mh = handle.getMethodHandle(ad.mode);\n&quot; +
638 //                &quot;        mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(&lt;LINK_TO_INVOKER_ARGS&gt;);\n&quot; +
639 //                &quot;    }\n&quot; +
640 //                &quot;}&quot;;
641 //
642 //        // A template for deriving the operations
643 //        // could be supported by annotating VarHandle directly with the
644 //        // operation kind and shape
645 //        interface VarHandleTemplate {
646 //            Object get();
647 //
648 //            void set(Object value);
649 //
650 //            boolean compareAndSet(Object actualValue, Object expectedValue);
651 //
652 //            Object compareAndExchange(Object actualValue, Object expectedValue);
653 //
</pre>
</td>
</tr>
</table>
<center><a href="VarHandleGuards.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="X-VarHandle.java.template.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
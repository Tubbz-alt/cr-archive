<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/lang/invoke/StringConcatFactory.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang.invoke;
  27 
  28 import jdk.internal.access.JavaLangAccess;
  29 import jdk.internal.access.SharedSecrets;
<a name="1" id="anc1"></a><span class="line-removed">  30 import jdk.internal.misc.Unsafe;</span>
<span class="line-removed">  31 import jdk.internal.misc.VM;</span>
<span class="line-removed">  32 import jdk.internal.org.objectweb.asm.ClassWriter;</span>
<span class="line-removed">  33 import jdk.internal.org.objectweb.asm.Label;</span>
<span class="line-removed">  34 import jdk.internal.org.objectweb.asm.MethodVisitor;</span>
<span class="line-removed">  35 import jdk.internal.org.objectweb.asm.Opcodes;</span>
  36 import jdk.internal.vm.annotation.Stable;
  37 import sun.invoke.util.Wrapper;
  38 
  39 import java.lang.invoke.MethodHandles.Lookup;
  40 import java.util.ArrayList;
  41 import java.util.Arrays;
  42 import java.util.List;
  43 import java.util.Objects;
  44 import java.util.concurrent.ConcurrentHashMap;
  45 import java.util.concurrent.ConcurrentMap;
  46 import java.util.function.Function;
  47 
<a name="2" id="anc2"></a><span class="line-removed">  48 import static java.lang.invoke.MethodHandles.lookup;</span>
  49 import static java.lang.invoke.MethodType.methodType;
<a name="3" id="anc3"></a><span class="line-removed">  50 import static java.lang.invoke.MethodHandles.Lookup.ClassOption.*;</span>
<span class="line-removed">  51 import static jdk.internal.org.objectweb.asm.Opcodes.*;</span>
  52 
  53 /**
  54  * &lt;p&gt;Methods to facilitate the creation of String concatenation methods, that
  55  * can be used to efficiently concatenate a known number of arguments of known
  56  * types, possibly after type adaptation and partial evaluation of arguments.
  57  * These methods are typically used as &lt;em&gt;bootstrap methods&lt;/em&gt; for {@code
  58  * invokedynamic} call sites, to support the &lt;em&gt;string concatenation&lt;/em&gt;
  59  * feature of the Java Programming Language.
  60  *
  61  * &lt;p&gt;Indirect access to the behavior specified by the provided {@code
  62  * MethodHandle} proceeds in order through two phases:
  63  *
  64  * &lt;ol&gt;
  65  *     &lt;li&gt;&lt;em&gt;Linkage&lt;/em&gt; occurs when the methods in this class are invoked.
  66  * They take as arguments a method type describing the concatenated arguments
  67  * count and types, and optionally the String &lt;em&gt;recipe&lt;/em&gt;, plus the
  68  * constants that participate in the String concatenation. The details on
  69  * accepted recipe shapes are described further below. Linkage may involve
  70  * dynamically loading a new class that implements the expected concatenation
  71  * behavior. The {@code CallSite} holds the {@code MethodHandle} pointing to the
  72  * exact concatenation method. The concatenation methods may be shared among
  73  * different {@code CallSite}s, e.g. if linkage methods produce them as pure
  74  * functions.&lt;/li&gt;
  75  *
  76  * &lt;li&gt;&lt;em&gt;Invocation&lt;/em&gt; occurs when a generated concatenation method is
  77  * invoked with the exact dynamic arguments. This may occur many times for a
  78  * single concatenation method. The method referenced by the behavior {@code
  79  * MethodHandle} is invoked with the static arguments and any additional dynamic
  80  * arguments provided on invocation, as if by {@link MethodHandle#invoke(Object...)}.&lt;/li&gt;
  81  * &lt;/ol&gt;
  82  *
  83  * &lt;p&gt; This class provides two forms of linkage methods: a simple version
  84  * ({@link #makeConcat(java.lang.invoke.MethodHandles.Lookup, String,
  85  * MethodType)}) using only the dynamic arguments, and an advanced version
  86  * ({@link #makeConcatWithConstants(java.lang.invoke.MethodHandles.Lookup,
  87  * String, MethodType, String, Object...)} using the advanced forms of capturing
  88  * the constant arguments. The advanced strategy can produce marginally better
  89  * invocation bytecode, at the expense of exploding the number of shapes of
  90  * string concatenation methods present at runtime, because those shapes would
  91  * include constant static arguments as well.
  92  *
  93  * @author Aleksey Shipilev
  94  * @author Remi Forax
  95  * @author Peter Levart
  96  *
  97  * @apiNote
  98  * &lt;p&gt;There is a JVM limit (classfile structural constraint): no method
  99  * can call with more than 255 slots. This limits the number of static and
 100  * dynamic arguments one can pass to bootstrap method. Since there are potential
 101  * concatenation strategies that use {@code MethodHandle} combinators, we need
 102  * to reserve a few empty slots on the parameter lists to capture the
 103  * temporal results. This is why bootstrap methods in this factory do not accept
 104  * more than 200 argument slots. Users requiring more than 200 argument slots in
 105  * concatenation are expected to split the large concatenation in smaller
 106  * expressions.
 107  *
 108  * @since 9
 109  */
 110 public final class StringConcatFactory {
 111 
 112     /**
 113      * Tag used to demarcate an ordinary argument.
 114      */
 115     private static final char TAG_ARG = &#39;\u0001&#39;;
 116 
 117     /**
 118      * Tag used to demarcate a constant.
 119      */
 120     private static final char TAG_CONST = &#39;\u0002&#39;;
 121 
 122     /**
 123      * Maximum number of argument slots in String Concat call.
 124      *
 125      * While the maximum number of argument slots that indy call can handle is 253,
 126      * we do not use all those slots, to let the strategies with MethodHandle
 127      * combinators to use some arguments.
 128      */
 129     private static final int MAX_INDY_CONCAT_ARG_SLOTS = 200;
 130 
<a name="4" id="anc4"></a><span class="line-removed"> 131     /**</span>
<span class="line-removed"> 132      * Concatenation strategy to use. See {@link Strategy} for possible options.</span>
<span class="line-removed"> 133      * This option is controllable with -Djava.lang.invoke.stringConcat JDK option.</span>
<span class="line-removed"> 134      *</span>
<span class="line-removed"> 135      * Defaults to MH_INLINE_SIZED_EXACT if not set.</span>
<span class="line-removed"> 136      */</span>
<span class="line-removed"> 137     private static final Strategy STRATEGY;</span>
<span class="line-removed"> 138 </span>
 139     private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
 140 
<a name="5" id="anc5"></a><span class="line-removed"> 141     private enum Strategy {</span>
<span class="line-removed"> 142         /**</span>
<span class="line-removed"> 143          * Bytecode generator, calling into {@link java.lang.StringBuilder}.</span>
<span class="line-removed"> 144          */</span>
<span class="line-removed"> 145         BC_SB,</span>
<span class="line-removed"> 146 </span>
<span class="line-removed"> 147         /**</span>
<span class="line-removed"> 148          * Bytecode generator, calling into {@link java.lang.StringBuilder};</span>
<span class="line-removed"> 149          * but trying to estimate the required storage.</span>
<span class="line-removed"> 150          */</span>
<span class="line-removed"> 151         BC_SB_SIZED,</span>
<span class="line-removed"> 152 </span>
<span class="line-removed"> 153         /**</span>
<span class="line-removed"> 154          * Bytecode generator, calling into {@link java.lang.StringBuilder};</span>
<span class="line-removed"> 155          * but computing the required storage exactly.</span>
<span class="line-removed"> 156          */</span>
<span class="line-removed"> 157         BC_SB_SIZED_EXACT,</span>
<span class="line-removed"> 158 </span>
<span class="line-removed"> 159         /**</span>
<span class="line-removed"> 160          * MethodHandle-based generator, that in the end calls into {@link java.lang.StringBuilder}.</span>
<span class="line-removed"> 161          * This strategy also tries to estimate the required storage.</span>
<span class="line-removed"> 162          */</span>
<span class="line-removed"> 163         MH_SB_SIZED,</span>
<span class="line-removed"> 164 </span>
<span class="line-removed"> 165         /**</span>
<span class="line-removed"> 166          * MethodHandle-based generator, that in the end calls into {@link java.lang.StringBuilder}.</span>
<span class="line-removed"> 167          * This strategy also estimate the required storage exactly.</span>
<span class="line-removed"> 168          */</span>
<span class="line-removed"> 169         MH_SB_SIZED_EXACT,</span>
<span class="line-removed"> 170 </span>
<span class="line-removed"> 171         /**</span>
<span class="line-removed"> 172          * MethodHandle-based generator, that constructs its own byte[] array from</span>
<span class="line-removed"> 173          * the arguments. It computes the required storage exactly.</span>
<span class="line-removed"> 174          */</span>
<span class="line-removed"> 175         MH_INLINE_SIZED_EXACT</span>
<span class="line-removed"> 176     }</span>
<span class="line-removed"> 177 </span>
<span class="line-removed"> 178     /**</span>
<span class="line-removed"> 179      * Enables debugging: this may print debugging messages, perform additional (non-neutral for performance)</span>
<span class="line-removed"> 180      * checks, etc.</span>
<span class="line-removed"> 181      */</span>
<span class="line-removed"> 182     private static final boolean DEBUG;</span>
<span class="line-removed"> 183 </span>
<span class="line-removed"> 184     static {</span>
<span class="line-removed"> 185         final String strategy =</span>
<span class="line-removed"> 186                 VM.getSavedProperty(&quot;java.lang.invoke.stringConcat&quot;);</span>
<span class="line-removed"> 187         STRATEGY = (strategy == null) ? null : Strategy.valueOf(strategy);</span>
<span class="line-removed"> 188 </span>
<span class="line-removed"> 189         if (STRATEGY == null || STRATEGY == Strategy.MH_INLINE_SIZED_EXACT) {</span>
<span class="line-removed"> 190             // Force initialization of default strategy:</span>
<span class="line-removed"> 191             Unsafe.getUnsafe().ensureClassInitialized(MethodHandleInlineCopyStrategy.class);</span>
<span class="line-removed"> 192         }</span>
<span class="line-removed"> 193 </span>
<span class="line-removed"> 194         DEBUG = Boolean.parseBoolean(</span>
<span class="line-removed"> 195                 VM.getSavedProperty(&quot;java.lang.invoke.stringConcat.debug&quot;));</span>
<span class="line-removed"> 196     }</span>
<span class="line-removed"> 197 </span>
<span class="line-removed"> 198     /**</span>
<span class="line-removed"> 199      * Cache key is a composite of:</span>
<span class="line-removed"> 200      *   - class name, that lets to disambiguate stubs, to avoid excess sharing</span>
<span class="line-removed"> 201      *   - method type, describing the dynamic arguments for concatenation</span>
<span class="line-removed"> 202      *   - concat recipe, describing the constants and concat shape</span>
<span class="line-removed"> 203      */</span>
<span class="line-removed"> 204     private static final class Key {</span>
<span class="line-removed"> 205         final String className;</span>
<span class="line-removed"> 206         final MethodType mt;</span>
<span class="line-removed"> 207         final Recipe recipe;</span>
<span class="line-removed"> 208 </span>
<span class="line-removed"> 209         public Key(String className, MethodType mt, Recipe recipe) {</span>
<span class="line-removed"> 210             this.className = className;</span>
<span class="line-removed"> 211             this.mt = mt;</span>
<span class="line-removed"> 212             this.recipe = recipe;</span>
<span class="line-removed"> 213         }</span>
<span class="line-removed"> 214 </span>
<span class="line-removed"> 215         @Override</span>
<span class="line-removed"> 216         public boolean equals(Object o) {</span>
<span class="line-removed"> 217             if (this == o) return true;</span>
<span class="line-removed"> 218             if (o == null || getClass() != o.getClass()) return false;</span>
<span class="line-removed"> 219 </span>
<span class="line-removed"> 220             Key key = (Key) o;</span>
<span class="line-removed"> 221 </span>
<span class="line-removed"> 222             if (!className.equals(key.className)) return false;</span>
<span class="line-removed"> 223             if (!mt.equals(key.mt)) return false;</span>
<span class="line-removed"> 224             if (!recipe.equals(key.recipe)) return false;</span>
<span class="line-removed"> 225             return true;</span>
<span class="line-removed"> 226         }</span>
<span class="line-removed"> 227 </span>
<span class="line-removed"> 228         @Override</span>
<span class="line-removed"> 229         public int hashCode() {</span>
<span class="line-removed"> 230             int result = className.hashCode();</span>
<span class="line-removed"> 231             result = 31 * result + mt.hashCode();</span>
<span class="line-removed"> 232             result = 31 * result + recipe.hashCode();</span>
<span class="line-removed"> 233             return result;</span>
<span class="line-removed"> 234         }</span>
<span class="line-removed"> 235     }</span>
<span class="line-removed"> 236 </span>
 237     /**
 238      * Parses the recipe string, and produces a traversable collection of
 239      * {@link java.lang.invoke.StringConcatFactory.RecipeElement}-s for generator
 240      * strategies. Notably, this class parses out the constants from the recipe
 241      * and from other static arguments.
 242      */
 243     private static final class Recipe {
 244         private final List&lt;RecipeElement&gt; elements;
 245 
 246         public Recipe(String src, Object[] constants) {
 247             List&lt;RecipeElement&gt; el = new ArrayList&lt;&gt;();
 248 
 249             int constC = 0;
 250             int argC = 0;
 251 
 252             StringBuilder acc = new StringBuilder();
 253 
 254             for (int i = 0; i &lt; src.length(); i++) {
 255                 char c = src.charAt(i);
 256 
 257                 if (c == TAG_CONST || c == TAG_ARG) {
 258                     // Detected a special tag, flush all accumulated characters
 259                     // as a constant first:
 260                     if (acc.length() &gt; 0) {
 261                         el.add(new RecipeElement(acc.toString()));
 262                         acc.setLength(0);
 263                     }
 264                     if (c == TAG_CONST) {
 265                         Object cnst = constants[constC++];
 266                         el.add(new RecipeElement(cnst));
 267                     } else if (c == TAG_ARG) {
 268                         el.add(new RecipeElement(argC++));
 269                     }
 270                 } else {
 271                     // Not a special character, this is a constant embedded into
 272                     // the recipe itself.
 273                     acc.append(c);
 274                 }
 275             }
 276 
 277             // Flush the remaining characters as constant:
 278             if (acc.length() &gt; 0) {
 279                 el.add(new RecipeElement(acc.toString()));
 280             }
 281 
 282             elements = el;
 283         }
 284 
 285         public List&lt;RecipeElement&gt; getElements() {
 286             return elements;
 287         }
 288 
 289         @Override
 290         public boolean equals(Object o) {
 291             if (this == o) return true;
 292             if (o == null || getClass() != o.getClass()) return false;
 293 
 294             Recipe recipe = (Recipe) o;
 295             return elements.equals(recipe.elements);
 296         }
 297 
 298         @Override
 299         public String toString() {
 300             return &quot;Recipe{&quot; +
 301                     &quot;elements=&quot; + elements +
 302                     &#39;}&#39;;
 303         }
 304 
 305         @Override
 306         public int hashCode() {
 307             return elements.hashCode();
 308         }
 309     }
 310 
 311     private static final class RecipeElement {
 312         private final String value;
 313         private final int argPos;
 314         private final char tag;
 315 
 316         public RecipeElement(Object cnst) {
 317             this.value = String.valueOf(Objects.requireNonNull(cnst));
 318             this.argPos = -1;
 319             this.tag = TAG_CONST;
 320         }
 321 
 322         public RecipeElement(int arg) {
 323             this.value = null;
 324             this.argPos = arg;
 325             this.tag = TAG_ARG;
 326         }
 327 
 328         public String getValue() {
 329             assert (tag == TAG_CONST);
 330             return value;
 331         }
 332 
 333         public int getArgPos() {
 334             assert (tag == TAG_ARG);
 335             return argPos;
 336         }
 337 
 338         public char getTag() {
 339             return tag;
 340         }
 341 
 342         @Override
 343         public boolean equals(Object o) {
 344             if (this == o) return true;
 345             if (o == null || getClass() != o.getClass()) return false;
 346 
 347             RecipeElement that = (RecipeElement) o;
 348 
 349             if (this.tag != that.tag) return false;
 350             if (this.tag == TAG_CONST &amp;&amp; (!value.equals(that.value))) return false;
 351             if (this.tag == TAG_ARG &amp;&amp; (argPos != that.argPos)) return false;
 352             return true;
 353         }
 354 
 355         @Override
 356         public String toString() {
 357             return &quot;RecipeElement{&quot; +
 358                     &quot;value=&#39;&quot; + value + &#39;\&#39;&#39; +
 359                     &quot;, argPos=&quot; + argPos +
 360                     &quot;, tag=&quot; + tag +
 361                     &#39;}&#39;;
 362         }
 363 
 364         @Override
 365         public int hashCode() {
 366             return (int)tag;
 367         }
 368     }
 369 
 370     // StringConcatFactory bootstrap methods are startup sensitive, and may be
 371     // special cased in java.lang.invokeBootstrapMethodInvoker to ensure
 372     // methods are invoked with exact type information to avoid generating
 373     // code for runtime checks. Take care any changes or additions here are
 374     // reflected there as appropriate.
 375 
 376     /**
 377      * Facilitates the creation of optimized String concatenation methods, that
 378      * can be used to efficiently concatenate a known number of arguments of
 379      * known types, possibly after type adaptation and partial evaluation of
 380      * arguments. Typically used as a &lt;em&gt;bootstrap method&lt;/em&gt; for {@code
 381      * invokedynamic} call sites, to support the &lt;em&gt;string concatenation&lt;/em&gt;
 382      * feature of the Java Programming Language.
 383      *
 384      * &lt;p&gt;When the target of the {@code CallSite} returned from this method is
 385      * invoked, it returns the result of String concatenation, taking all
 386      * function arguments passed to the linkage method as inputs for
 387      * concatenation. The target signature is given by {@code concatType}.
 388      * For a target accepting:
 389      * &lt;ul&gt;
 390      *     &lt;li&gt;zero inputs, concatenation results in an empty string;&lt;/li&gt;
 391      *     &lt;li&gt;one input, concatenation results in the single
 392      *     input converted as per JLS 5.1.11 &quot;String Conversion&quot;; otherwise&lt;/li&gt;
 393      *     &lt;li&gt;two or more inputs, the inputs are concatenated as per
 394      *     requirements stated in JLS 15.18.1 &quot;String Concatenation Operator +&quot;.
 395      *     The inputs are converted as per JLS 5.1.11 &quot;String Conversion&quot;,
 396      *     and combined from left to right.&lt;/li&gt;
 397      * &lt;/ul&gt;
 398      *
 399      * &lt;p&gt;Assume the linkage arguments are as follows:
 400      *
 401      * &lt;ul&gt;
 402      *     &lt;li&gt;{@code concatType}, describing the {@code CallSite} signature&lt;/li&gt;
 403      * &lt;/ul&gt;
 404      *
 405      * &lt;p&gt;Then the following linkage invariants must hold:
 406      *
 407      * &lt;ul&gt;
 408      *     &lt;li&gt;The number of parameter slots in {@code concatType} is
 409      *         less than or equal to 200&lt;/li&gt;
 410      *     &lt;li&gt;The return type in {@code concatType} is assignable from {@link java.lang.String}&lt;/li&gt;
 411      * &lt;/ul&gt;
 412      *
 413      * @param lookup   Represents a lookup context with the accessibility
 414      *                 privileges of the caller. Specifically, the lookup
 415      *                 context must have
 416      *                 {@linkplain MethodHandles.Lookup#hasFullPrivilegeAccess()
 417      *                 full privilege access}.
 418      *                 When used with {@code invokedynamic}, this is stacked
 419      *                 automatically by the VM.
 420      * @param name     The name of the method to implement. This name is
 421      *                 arbitrary, and has no meaning for this linkage method.
 422      *                 When used with {@code invokedynamic}, this is provided by
 423      *                 the {@code NameAndType} of the {@code InvokeDynamic}
 424      *                 structure and is stacked automatically by the VM.
 425      * @param concatType The expected signature of the {@code CallSite}.  The
 426      *                   parameter types represent the types of concatenation
 427      *                   arguments; the return type is always assignable from {@link
 428      *                   java.lang.String}.  When used with {@code invokedynamic},
 429      *                   this is provided by the {@code NameAndType} of the {@code
 430      *                   InvokeDynamic} structure and is stacked automatically by
 431      *                   the VM.
 432      * @return a CallSite whose target can be used to perform String
 433      * concatenation, with dynamic concatenation arguments described by the given
 434      * {@code concatType}.
 435      * @throws StringConcatException If any of the linkage invariants described
 436      *                               here are violated, or the lookup context
 437      *                               does not have private access privileges.
 438      * @throws NullPointerException If any of the incoming arguments is null.
 439      *                              This will never happen when a bootstrap method
 440      *                              is called with invokedynamic.
 441      *
 442      * @jls  5.1.11 String Conversion
 443      * @jls 15.18.1 String Concatenation Operator +
 444      */
 445     public static CallSite makeConcat(MethodHandles.Lookup lookup,
 446                                       String name,
 447                                       MethodType concatType) throws StringConcatException {
<a name="6" id="anc6"></a><span class="line-removed"> 448         if (DEBUG) {</span>
<span class="line-removed"> 449             System.out.println(&quot;StringConcatFactory &quot; + STRATEGY + &quot; is here for &quot; + concatType);</span>
<span class="line-removed"> 450         }</span>
<span class="line-removed"> 451 </span>
 452         return doStringConcat(lookup, name, concatType, true, null);
 453     }
 454 
 455     /**
 456      * Facilitates the creation of optimized String concatenation methods, that
 457      * can be used to efficiently concatenate a known number of arguments of
 458      * known types, possibly after type adaptation and partial evaluation of
 459      * arguments. Typically used as a &lt;em&gt;bootstrap method&lt;/em&gt; for {@code
 460      * invokedynamic} call sites, to support the &lt;em&gt;string concatenation&lt;/em&gt;
 461      * feature of the Java Programming Language.
 462      *
 463      * &lt;p&gt;When the target of the {@code CallSite} returned from this method is
 464      * invoked, it returns the result of String concatenation, taking all
 465      * function arguments and constants passed to the linkage method as inputs for
 466      * concatenation. The target signature is given by {@code concatType}, and
 467      * does not include constants.
 468      * For a target accepting:
 469      * &lt;ul&gt;
 470      *     &lt;li&gt;zero inputs, concatenation results in an empty string;&lt;/li&gt;
 471      *     &lt;li&gt;one input, concatenation results in the single
 472      *     input converted as per JLS 5.1.11 &quot;String Conversion&quot;; otherwise&lt;/li&gt;
 473      *     &lt;li&gt;two or more inputs, the inputs are concatenated as per
 474      *     requirements stated in JLS 15.18.1 &quot;String Concatenation Operator +&quot;.
 475      *     The inputs are converted as per JLS 5.1.11 &quot;String Conversion&quot;,
 476      *     and combined from left to right.&lt;/li&gt;
 477      * &lt;/ul&gt;
 478      *
 479      * &lt;p&gt;The concatenation &lt;em&gt;recipe&lt;/em&gt; is a String description for the way to
 480      * construct a concatenated String from the arguments and constants. The
 481      * recipe is processed from left to right, and each character represents an
 482      * input to concatenation. Recipe characters mean:
 483      *
 484      * &lt;ul&gt;
 485      *
 486      *   &lt;li&gt;&lt;em&gt;\1 (Unicode point 0001)&lt;/em&gt;: an ordinary argument. This
 487      *   input is passed through dynamic argument, and is provided during the
 488      *   concatenation method invocation. This input can be null.&lt;/li&gt;
 489      *
 490      *   &lt;li&gt;&lt;em&gt;\2 (Unicode point 0002):&lt;/em&gt; a constant. This input passed
 491      *   through static bootstrap argument. This constant can be any value
 492      *   representable in constant pool. If necessary, the factory would call
 493      *   {@code toString} to perform a one-time String conversion.&lt;/li&gt;
 494      *
 495      *   &lt;li&gt;&lt;em&gt;Any other char value:&lt;/em&gt; a single character constant.&lt;/li&gt;
 496      * &lt;/ul&gt;
 497      *
 498      * &lt;p&gt;Assume the linkage arguments are as follows:
 499      *
 500      * &lt;ul&gt;
 501      *   &lt;li&gt;{@code concatType}, describing the {@code CallSite} signature&lt;/li&gt;
 502      *   &lt;li&gt;{@code recipe}, describing the String recipe&lt;/li&gt;
 503      *   &lt;li&gt;{@code constants}, the vararg array of constants&lt;/li&gt;
 504      * &lt;/ul&gt;
 505      *
 506      * &lt;p&gt;Then the following linkage invariants must hold:
 507      *
 508      * &lt;ul&gt;
 509      *   &lt;li&gt;The number of parameter slots in {@code concatType} is less than
 510      *       or equal to 200&lt;/li&gt;
 511      *
 512      *   &lt;li&gt;The parameter count in {@code concatType} is equal to number of \1 tags
 513      *   in {@code recipe}&lt;/li&gt;
 514      *
 515      *   &lt;li&gt;The return type in {@code concatType} is assignable
 516      *   from {@link java.lang.String}, and matches the return type of the
 517      *   returned {@link MethodHandle}&lt;/li&gt;
 518      *
 519      *   &lt;li&gt;The number of elements in {@code constants} is equal to number of \2
 520      *   tags in {@code recipe}&lt;/li&gt;
 521      * &lt;/ul&gt;
 522      *
 523      * @param lookup    Represents a lookup context with the accessibility
 524      *                  privileges of the caller. Specifically, the lookup
 525      *                  context must have
 526      *                  {@linkplain MethodHandles.Lookup#hasFullPrivilegeAccess()
 527      *                  full privilege access}.
 528      *                  When used with {@code invokedynamic}, this is stacked
 529      *                  automatically by the VM.
 530      * @param name      The name of the method to implement. This name is
 531      *                  arbitrary, and has no meaning for this linkage method.
 532      *                  When used with {@code invokedynamic}, this is provided
 533      *                  by the {@code NameAndType} of the {@code InvokeDynamic}
 534      *                  structure and is stacked automatically by the VM.
 535      * @param concatType The expected signature of the {@code CallSite}.  The
 536      *                  parameter types represent the types of dynamic concatenation
 537      *                  arguments; the return type is always assignable from {@link
 538      *                  java.lang.String}.  When used with {@code
 539      *                  invokedynamic}, this is provided by the {@code
 540      *                  NameAndType} of the {@code InvokeDynamic} structure and
 541      *                  is stacked automatically by the VM.
 542      * @param recipe    Concatenation recipe, described above.
 543      * @param constants A vararg parameter representing the constants passed to
 544      *                  the linkage method.
 545      * @return a CallSite whose target can be used to perform String
 546      * concatenation, with dynamic concatenation arguments described by the given
 547      * {@code concatType}.
 548      * @throws StringConcatException If any of the linkage invariants described
 549      *                               here are violated, or the lookup context
 550      *                               does not have private access privileges.
 551      * @throws NullPointerException If any of the incoming arguments is null, or
 552      *                              any constant in {@code recipe} is null.
 553      *                              This will never happen when a bootstrap method
 554      *                              is called with invokedynamic.
 555      * @apiNote Code generators have three distinct ways to process a constant
 556      * string operand S in a string concatenation expression.  First, S can be
 557      * materialized as a reference (using ldc) and passed as an ordinary argument
 558      * (recipe &#39;\1&#39;). Or, S can be stored in the constant pool and passed as a
 559      * constant (recipe &#39;\2&#39;) . Finally, if S contains neither of the recipe
 560      * tag characters (&#39;\1&#39;, &#39;\2&#39;) then S can be interpolated into the recipe
 561      * itself, causing its characters to be inserted into the result.
 562      *
 563      * @jls  5.1.11 String Conversion
 564      * @jls 15.18.1 String Concatenation Operator +
 565      */
 566     public static CallSite makeConcatWithConstants(MethodHandles.Lookup lookup,
 567                                                    String name,
 568                                                    MethodType concatType,
 569                                                    String recipe,
 570                                                    Object... constants) throws StringConcatException {
<a name="7" id="anc7"></a><span class="line-removed"> 571         if (DEBUG) {</span>
<span class="line-removed"> 572             System.out.println(&quot;StringConcatFactory &quot; + STRATEGY + &quot; is here for &quot; + concatType + &quot;, {&quot; + recipe + &quot;}, &quot; + Arrays.toString(constants));</span>
<span class="line-removed"> 573         }</span>
<span class="line-removed"> 574 </span>
 575         return doStringConcat(lookup, name, concatType, false, recipe, constants);
 576     }
 577 
 578     private static CallSite doStringConcat(MethodHandles.Lookup lookup,
 579                                            String name,
 580                                            MethodType concatType,
 581                                            boolean generateRecipe,
 582                                            String recipe,
 583                                            Object... constants) throws StringConcatException {
 584         Objects.requireNonNull(lookup, &quot;Lookup is null&quot;);
 585         Objects.requireNonNull(name, &quot;Name is null&quot;);
 586         Objects.requireNonNull(concatType, &quot;Concat type is null&quot;);
 587         Objects.requireNonNull(constants, &quot;Constants are null&quot;);
 588 
 589         for (Object o : constants) {
 590             Objects.requireNonNull(o, &quot;Cannot accept null constants&quot;);
 591         }
 592 
 593         if ((lookup.lookupModes() &amp; MethodHandles.Lookup.PRIVATE) == 0) {
 594             throw new StringConcatException(&quot;Invalid caller: &quot; +
 595                     lookup.lookupClass().getName());
 596         }
 597 
 598         int cCount = 0;
 599         int oCount = 0;
 600         if (generateRecipe) {
 601             // Mock the recipe to reuse the concat generator code
 602             char[] value = new char[concatType.parameterCount()];
 603             Arrays.fill(value, TAG_ARG);
 604             recipe = new String(value);
 605             oCount = concatType.parameterCount();
 606         } else {
 607             Objects.requireNonNull(recipe, &quot;Recipe is null&quot;);
 608 
 609             for (int i = 0; i &lt; recipe.length(); i++) {
 610                 char c = recipe.charAt(i);
 611                 if (c == TAG_CONST) cCount++;
 612                 if (c == TAG_ARG)   oCount++;
 613             }
 614         }
 615 
 616         if (oCount != concatType.parameterCount()) {
 617             throw new StringConcatException(
 618                     &quot;Mismatched number of concat arguments: recipe wants &quot; +
 619                             oCount +
 620                             &quot; arguments, but signature provides &quot; +
 621                             concatType.parameterCount());
 622         }
 623 
 624         if (cCount != constants.length) {
 625             throw new StringConcatException(
 626                     &quot;Mismatched number of concat constants: recipe wants &quot; +
 627                             cCount +
 628                             &quot; constants, but only &quot; +
 629                             constants.length +
 630                             &quot; are passed&quot;);
 631         }
 632 
 633         if (!concatType.returnType().isAssignableFrom(String.class)) {
 634             throw new StringConcatException(
 635                     &quot;The return type should be compatible with String, but it is &quot; +
 636                             concatType.returnType());
 637         }
 638 
 639         if (concatType.parameterSlotCount() &gt; MAX_INDY_CONCAT_ARG_SLOTS) {
 640             throw new StringConcatException(&quot;Too many concat argument slots: &quot; +
 641                     concatType.parameterSlotCount() +
 642                     &quot;, can only accept &quot; +
 643                     MAX_INDY_CONCAT_ARG_SLOTS);
 644         }
 645 
<a name="8" id="anc8"></a><span class="line-removed"> 646         MethodType mt = adaptType(concatType);</span>
 647         Recipe rec = new Recipe(recipe, constants);
<a name="9" id="anc9"></a><span class="line-modified"> 648         MethodHandle mh = generate(lookup, mt, rec);</span>
 649         return new ConstantCallSite(mh.asType(concatType));
 650     }
 651 
<a name="10" id="anc10"></a><span class="line-removed"> 652     /**</span>
<span class="line-removed"> 653      * Adapt method type to an API we are going to use.</span>
<span class="line-removed"> 654      *</span>
<span class="line-removed"> 655      * This strips the concrete classes from the signatures, thus preventing</span>
<span class="line-removed"> 656      * class leakage when we cache the concatenation stubs.</span>
<span class="line-removed"> 657      *</span>
<span class="line-removed"> 658      * @param args actual argument types</span>
<span class="line-removed"> 659      * @return argument types the strategy is going to use</span>
<span class="line-removed"> 660      */</span>
<span class="line-removed"> 661     private static MethodType adaptType(MethodType args) {</span>
<span class="line-removed"> 662         Class&lt;?&gt;[] ptypes = null;</span>
<span class="line-removed"> 663         for (int i = 0; i &lt; args.parameterCount(); i++) {</span>
<span class="line-removed"> 664             Class&lt;?&gt; ptype = args.parameterType(i);</span>
<span class="line-removed"> 665             if (!ptype.isPrimitive() &amp;&amp;</span>
<span class="line-removed"> 666                     ptype != String.class &amp;&amp;</span>
<span class="line-removed"> 667                     ptype != Object.class) { // truncate to Object</span>
<span class="line-removed"> 668                 if (ptypes == null) {</span>
<span class="line-removed"> 669                     ptypes = args.parameterArray();</span>
<span class="line-removed"> 670                 }</span>
<span class="line-removed"> 671                 ptypes[i] = Object.class;</span>
<span class="line-removed"> 672             }</span>
<span class="line-removed"> 673             // else other primitives or String or Object (unchanged)</span>
<span class="line-removed"> 674         }</span>
<span class="line-removed"> 675         return (ptypes != null)</span>
<span class="line-removed"> 676                 ? MethodType.methodType(args.returnType(), ptypes)</span>
<span class="line-removed"> 677                 : args;</span>
<span class="line-removed"> 678     }</span>
<span class="line-removed"> 679 </span>
 680     private static MethodHandle generate(Lookup lookup, MethodType mt, Recipe recipe) throws StringConcatException {
 681         try {
<a name="11" id="anc11"></a><span class="line-modified"> 682             if (STRATEGY == null) {</span>
<span class="line-removed"> 683                 return MethodHandleInlineCopyStrategy.generate(mt, recipe);</span>
<span class="line-removed"> 684             }</span>
<span class="line-removed"> 685             switch (STRATEGY) {</span>
<span class="line-removed"> 686                 case BC_SB:</span>
<span class="line-removed"> 687                     return BytecodeStringBuilderStrategy.generate(lookup, mt, recipe, Mode.DEFAULT);</span>
<span class="line-removed"> 688                 case BC_SB_SIZED:</span>
<span class="line-removed"> 689                     return BytecodeStringBuilderStrategy.generate(lookup, mt, recipe, Mode.SIZED);</span>
<span class="line-removed"> 690                 case BC_SB_SIZED_EXACT:</span>
<span class="line-removed"> 691                     return BytecodeStringBuilderStrategy.generate(lookup, mt, recipe, Mode.SIZED_EXACT);</span>
<span class="line-removed"> 692                 case MH_SB_SIZED:</span>
<span class="line-removed"> 693                     return MethodHandleStringBuilderStrategy.generate(mt, recipe, Mode.SIZED);</span>
<span class="line-removed"> 694                 case MH_SB_SIZED_EXACT:</span>
<span class="line-removed"> 695                     return MethodHandleStringBuilderStrategy.generate(mt, recipe, Mode.SIZED_EXACT);</span>
<span class="line-removed"> 696                 case MH_INLINE_SIZED_EXACT:</span>
<span class="line-removed"> 697                     return MethodHandleInlineCopyStrategy.generate(mt, recipe);</span>
<span class="line-removed"> 698                 default:</span>
<span class="line-removed"> 699                     throw new StringConcatException(&quot;Concatenation strategy &quot; + STRATEGY + &quot; is not implemented&quot;);</span>
<span class="line-removed"> 700             }</span>
 701         } catch (Error | StringConcatException e) {
 702             // Pass through any error or existing StringConcatException
 703             throw e;
 704         } catch (Throwable t) {
 705             throw new StringConcatException(&quot;Generator failed&quot;, t);
 706         }
 707     }
 708 
<a name="12" id="anc12"></a><span class="line-removed"> 709     private enum Mode {</span>
<span class="line-removed"> 710         DEFAULT(false, false),</span>
<span class="line-removed"> 711         SIZED(true, false),</span>
<span class="line-removed"> 712         SIZED_EXACT(true, true);</span>
<span class="line-removed"> 713 </span>
<span class="line-removed"> 714         private final boolean sized;</span>
<span class="line-removed"> 715         private final boolean exact;</span>
<span class="line-removed"> 716 </span>
<span class="line-removed"> 717         Mode(boolean sized, boolean exact) {</span>
<span class="line-removed"> 718             this.sized = sized;</span>
<span class="line-removed"> 719             this.exact = exact;</span>
<span class="line-removed"> 720         }</span>
<span class="line-removed"> 721 </span>
<span class="line-removed"> 722         boolean isSized() {</span>
<span class="line-removed"> 723             return sized;</span>
<span class="line-removed"> 724         }</span>
<span class="line-removed"> 725 </span>
<span class="line-removed"> 726         boolean isExact() {</span>
<span class="line-removed"> 727             return exact;</span>
<span class="line-removed"> 728         }</span>
<span class="line-removed"> 729     }</span>
 730 
 731     /**
<a name="13" id="anc13"></a><span class="line-modified"> 732      * Bytecode StringBuilder strategy.</span>
<span class="line-modified"> 733      *</span>
<span class="line-modified"> 734      * &lt;p&gt;This strategy operates in three modes, gated by {@link Mode}.</span>
<span class="line-modified"> 735      *</span>
<span class="line-modified"> 736      * &lt;p&gt;&lt;b&gt;{@link Strategy#BC_SB}: &quot;bytecode StringBuilder&quot;.&lt;/b&gt;</span>
<span class="line-removed"> 737      *</span>
<span class="line-removed"> 738      * &lt;p&gt;This strategy spins up the bytecode that has the same StringBuilder</span>
<span class="line-removed"> 739      * chain javac would otherwise emit. This strategy uses only the public API,</span>
<span class="line-removed"> 740      * and comes as the baseline for the current JDK behavior. On other words,</span>
<span class="line-removed"> 741      * this strategy moves the javac generated bytecode to runtime. The</span>
<span class="line-removed"> 742      * generated bytecode is loaded via Lookup::defineClass, but with</span>
<span class="line-removed"> 743      * the caller class coming from the BSM -- in other words, the protection</span>
<span class="line-removed"> 744      * guarantees are inherited from the method where invokedynamic was</span>
<span class="line-removed"> 745      * originally called. This means, among other things, that the bytecode is</span>
<span class="line-removed"> 746      * verified for all non-JDK uses.</span>
<span class="line-removed"> 747      *</span>
<span class="line-removed"> 748      * &lt;p&gt;&lt;b&gt;{@link Strategy#BC_SB_SIZED}: &quot;bytecode StringBuilder, but</span>
<span class="line-removed"> 749      * sized&quot;.&lt;/b&gt;</span>
<span class="line-removed"> 750      *</span>
<span class="line-removed"> 751      * &lt;p&gt;This strategy acts similarly to {@link Strategy#BC_SB}, but it also</span>
<span class="line-removed"> 752      * tries to guess the capacity required for StringBuilder to accept all</span>
<span class="line-removed"> 753      * arguments without resizing. This strategy only makes an educated guess:</span>
<span class="line-removed"> 754      * it only guesses the space required for known types (e.g. primitives and</span>
<span class="line-removed"> 755      * Strings), but does not otherwise convert arguments. Therefore, the</span>
<span class="line-removed"> 756      * capacity estimate may be wrong, and StringBuilder may have to</span>
<span class="line-removed"> 757      * transparently resize or trim when doing the actual concatenation. While</span>
<span class="line-removed"> 758      * this does not constitute a correctness issue (in the end, that what BC_SB</span>
<span class="line-removed"> 759      * has to do anyway), this does pose a potential performance problem.</span>
<span class="line-removed"> 760      *</span>
<span class="line-removed"> 761      * &lt;p&gt;&lt;b&gt;{@link Strategy#BC_SB_SIZED_EXACT}: &quot;bytecode StringBuilder, but</span>
<span class="line-removed"> 762      * sized exactly&quot;.&lt;/b&gt;</span>
<span class="line-removed"> 763      *</span>
<span class="line-removed"> 764      * &lt;p&gt;This strategy improves on @link Strategy#BC_SB_SIZED}, by first</span>
<span class="line-removed"> 765      * converting all arguments to String in order to get the exact capacity</span>
<span class="line-removed"> 766      * StringBuilder should have. The conversion is done via the public</span>
<span class="line-removed"> 767      * String.valueOf and/or Object.toString methods, and does not touch any</span>
<span class="line-removed"> 768      * private String API.</span>
 769      */
<a name="14" id="anc14"></a><span class="line-modified"> 770     private static final class BytecodeStringBuilderStrategy {</span>
<span class="line-removed"> 771         static final int CLASSFILE_VERSION = 52;</span>
<span class="line-removed"> 772         static final String METHOD_NAME = &quot;concat&quot;;</span>
<span class="line-removed"> 773 </span>
<span class="line-removed"> 774         private static final ConcurrentMap&lt;Key, MethodHandle&gt; CACHE;</span>
<span class="line-removed"> 775 </span>
<span class="line-removed"> 776         /**</span>
<span class="line-removed"> 777          * Enables caching of strategy stubs. This may improve the linkage time by reusing the generated</span>
<span class="line-removed"> 778          * code, at the expense of contaminating the profiles.</span>
<span class="line-removed"> 779          */</span>
<span class="line-removed"> 780         private static final boolean CACHE_ENABLE;</span>
<span class="line-removed"> 781 </span>
<span class="line-removed"> 782         /**</span>
<span class="line-removed"> 783          * Dump generated classes to disk, for debugging purposes.</span>
<span class="line-removed"> 784          */</span>
<span class="line-removed"> 785         private static final ProxyClassesDumper DUMPER;</span>
<span class="line-removed"> 786 </span>
<span class="line-removed"> 787         static {</span>
<span class="line-removed"> 788             CACHE_ENABLE = Boolean.parseBoolean(</span>
<span class="line-removed"> 789                     VM.getSavedProperty(&quot;java.lang.invoke.stringConcat.cache&quot;));</span>
<span class="line-removed"> 790             CACHE = CACHE_ENABLE ? new ConcurrentHashMap&lt;&gt;() : null;</span>
<span class="line-removed"> 791 </span>
<span class="line-removed"> 792             final String dumpPath =</span>
<span class="line-removed"> 793                     VM.getSavedProperty(&quot;java.lang.invoke.stringConcat.dumpClasses&quot;);</span>
<span class="line-removed"> 794 </span>
<span class="line-removed"> 795             DUMPER = (dumpPath == null) ? null : ProxyClassesDumper.getInstance(dumpPath);</span>
<span class="line-removed"> 796         }</span>
 797 
<a name="15" id="anc15"></a><span class="line-modified"> 798         private BytecodeStringBuilderStrategy() {</span>
<span class="line-modified"> 799             // no instantiation</span>
<span class="line-modified"> 800         }</span>
<span class="line-modified"> 801 </span>
<span class="line-modified"> 802         private static MethodHandle generate(Lookup lookup, MethodType args, Recipe recipe, Mode mode) throws Exception {</span>
<span class="line-modified"> 803             String className = getClassName(lookup.lookupClass());</span>
<span class="line-modified"> 804             Key key = null;</span>
<span class="line-modified"> 805             if (CACHE_ENABLE) {</span>
<span class="line-removed"> 806                 key = new Key(className, args, recipe);</span>
<span class="line-removed"> 807                 MethodHandle mh = CACHE.get(key);</span>
<span class="line-removed"> 808                 if (mh != null) {</span>
<span class="line-removed"> 809                     return mh;</span>
<span class="line-removed"> 810                 }</span>
<span class="line-removed"> 811             }</span>
<span class="line-removed"> 812 </span>
<span class="line-removed"> 813             ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS + ClassWriter.COMPUTE_FRAMES);</span>
<span class="line-removed"> 814 </span>
<span class="line-removed"> 815             cw.visit(CLASSFILE_VERSION,</span>
<span class="line-removed"> 816                     ACC_SUPER + ACC_PUBLIC + ACC_FINAL + ACC_SYNTHETIC,</span>
<span class="line-removed"> 817                     className,</span>
<span class="line-removed"> 818                     null,</span>
<span class="line-removed"> 819                     &quot;java/lang/Object&quot;,</span>
<span class="line-removed"> 820                     null</span>
<span class="line-removed"> 821             );</span>
<span class="line-removed"> 822 </span>
<span class="line-removed"> 823             MethodVisitor mv = cw.visitMethod(</span>
<span class="line-removed"> 824                     ACC_PUBLIC + ACC_STATIC + ACC_FINAL,</span>
<span class="line-removed"> 825                     METHOD_NAME,</span>
<span class="line-removed"> 826                     args.toMethodDescriptorString(),</span>
<span class="line-removed"> 827                     null,</span>
<span class="line-removed"> 828                     null);</span>
<span class="line-removed"> 829 </span>
<span class="line-removed"> 830             // use of @ForceInline no longer has any effect</span>
<span class="line-removed"> 831             mv.visitAnnotation(&quot;Ljdk/internal/vm/annotation/ForceInline;&quot;, true);</span>
<span class="line-removed"> 832             mv.visitCode();</span>
<span class="line-removed"> 833 </span>
<span class="line-removed"> 834             Class&lt;?&gt;[] arr = args.parameterArray();</span>
<span class="line-removed"> 835             boolean[] guaranteedNonNull = new boolean[arr.length];</span>
<span class="line-removed"> 836 </span>
<span class="line-removed"> 837             if (mode.isExact()) {</span>
<span class="line-removed"> 838                 /*</span>
<span class="line-removed"> 839                     In exact mode, we need to convert all arguments to their String representations,</span>
<span class="line-removed"> 840                     as this allows to compute their String sizes exactly. We cannot use private</span>
<span class="line-removed"> 841                     methods for primitives in here, therefore we need to convert those as well.</span>
<span class="line-removed"> 842 </span>
<span class="line-removed"> 843                     We also record what arguments are guaranteed to be non-null as the result</span>
<span class="line-removed"> 844                     of the conversion. String.valueOf does the null checks for us. The only</span>
<span class="line-removed"> 845                     corner case to take care of is String.valueOf(Object) returning null itself.</span>
<span class="line-removed"> 846 </span>
<span class="line-removed"> 847                     Also, if any conversion happened, then the slot indices in the incoming</span>
<span class="line-removed"> 848                     arguments are not equal to the final local maps. The only case this may break</span>
<span class="line-removed"> 849                     is when converting 2-slot long/double argument to 1-slot String. Therefore,</span>
<span class="line-removed"> 850                     we get away with tracking modified offset, since no conversion can overwrite</span>
<span class="line-removed"> 851                     the upcoming the argument.</span>
<span class="line-removed"> 852                  */</span>
<span class="line-removed"> 853 </span>
<span class="line-removed"> 854                 int off = 0;</span>
<span class="line-removed"> 855                 int modOff = 0;</span>
<span class="line-removed"> 856                 for (int c = 0; c &lt; arr.length; c++) {</span>
<span class="line-removed"> 857                     Class&lt;?&gt; cl = arr[c];</span>
<span class="line-removed"> 858                     if (cl == String.class) {</span>
<span class="line-removed"> 859                         if (off != modOff) {</span>
<span class="line-removed"> 860                             mv.visitIntInsn(getLoadOpcode(cl), off);</span>
<span class="line-removed"> 861                             mv.visitIntInsn(ASTORE, modOff);</span>
<span class="line-removed"> 862                         }</span>
<span class="line-removed"> 863                     } else {</span>
<span class="line-removed"> 864                         mv.visitIntInsn(getLoadOpcode(cl), off);</span>
<span class="line-removed"> 865                         mv.visitMethodInsn(</span>
<span class="line-removed"> 866                                 INVOKESTATIC,</span>
<span class="line-removed"> 867                                 &quot;java/lang/String&quot;,</span>
<span class="line-removed"> 868                                 &quot;valueOf&quot;,</span>
<span class="line-removed"> 869                                 getStringValueOfDesc(cl),</span>
<span class="line-removed"> 870                                 false</span>
<span class="line-removed"> 871                         );</span>
<span class="line-removed"> 872                         mv.visitIntInsn(ASTORE, modOff);</span>
<span class="line-removed"> 873                         arr[c] = String.class;</span>
<span class="line-removed"> 874                         guaranteedNonNull[c] = cl.isPrimitive();</span>
<span class="line-removed"> 875                     }</span>
<span class="line-removed"> 876                     off += getParameterSize(cl);</span>
<span class="line-removed"> 877                     modOff += getParameterSize(String.class);</span>
<span class="line-removed"> 878                 }</span>
<span class="line-removed"> 879             }</span>
<span class="line-removed"> 880 </span>
<span class="line-removed"> 881             if (mode.isSized()) {</span>
<span class="line-removed"> 882                 /*</span>
<span class="line-removed"> 883                     When operating in sized mode (this includes exact mode), it makes sense to make</span>
<span class="line-removed"> 884                     StringBuilder append chains look familiar to OptimizeStringConcat. For that, we</span>
<span class="line-removed"> 885                     need to do null-checks early, not make the append chain shape simpler.</span>
<span class="line-removed"> 886                  */</span>
<span class="line-removed"> 887 </span>
<span class="line-removed"> 888                 int off = 0;</span>
<span class="line-removed"> 889                 for (RecipeElement el : recipe.getElements()) {</span>
<span class="line-removed"> 890                     switch (el.getTag()) {</span>
<span class="line-removed"> 891                         case TAG_CONST:</span>
<span class="line-removed"> 892                             // Guaranteed non-null, no null check required.</span>
<span class="line-removed"> 893                             break;</span>
<span class="line-removed"> 894                         case TAG_ARG:</span>
<span class="line-removed"> 895                             // Null-checks are needed only for String arguments, and when a previous stage</span>
<span class="line-removed"> 896                             // did not do implicit null-checks. If a String is null, we eagerly replace it</span>
<span class="line-removed"> 897                             // with &quot;null&quot; constant. Note, we omit Objects here, because we don&#39;t call</span>
<span class="line-removed"> 898                             // .length() on them down below.</span>
<span class="line-removed"> 899                             int ac = el.getArgPos();</span>
<span class="line-removed"> 900                             Class&lt;?&gt; cl = arr[ac];</span>
<span class="line-removed"> 901                             if (cl == String.class &amp;&amp; !guaranteedNonNull[ac]) {</span>
<span class="line-removed"> 902                                 Label l0 = new Label();</span>
<span class="line-removed"> 903                                 mv.visitIntInsn(ALOAD, off);</span>
<span class="line-removed"> 904                                 mv.visitJumpInsn(IFNONNULL, l0);</span>
<span class="line-removed"> 905                                 mv.visitLdcInsn(&quot;null&quot;);</span>
<span class="line-removed"> 906                                 mv.visitIntInsn(ASTORE, off);</span>
<span class="line-removed"> 907                                 mv.visitLabel(l0);</span>
<span class="line-removed"> 908                             }</span>
<span class="line-removed"> 909                             off += getParameterSize(cl);</span>
<span class="line-removed"> 910                             break;</span>
<span class="line-removed"> 911                         default:</span>
<span class="line-removed"> 912                             throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());</span>
<span class="line-removed"> 913                     }</span>
<span class="line-removed"> 914                 }</span>
<span class="line-removed"> 915             }</span>
<span class="line-removed"> 916 </span>
<span class="line-removed"> 917             // Prepare StringBuilder instance</span>
<span class="line-removed"> 918             mv.visitTypeInsn(NEW, &quot;java/lang/StringBuilder&quot;);</span>
<span class="line-removed"> 919             mv.visitInsn(DUP);</span>
<span class="line-removed"> 920 </span>
<span class="line-removed"> 921             if (mode.isSized()) {</span>
<span class="line-removed"> 922                 /*</span>
<span class="line-removed"> 923                     Sized mode requires us to walk through the arguments, and estimate the final length.</span>
<span class="line-removed"> 924                     In exact mode, this will operate on Strings only. This code would accumulate the</span>
<span class="line-removed"> 925                     final length on stack.</span>
<span class="line-removed"> 926                  */</span>
<span class="line-removed"> 927                 int len = 0;</span>
<span class="line-removed"> 928                 int off = 0;</span>
<span class="line-removed"> 929 </span>
<span class="line-removed"> 930                 mv.visitInsn(ICONST_0);</span>
<span class="line-removed"> 931 </span>
<span class="line-removed"> 932                 for (RecipeElement el : recipe.getElements()) {</span>
<span class="line-removed"> 933                     switch (el.getTag()) {</span>
<span class="line-removed"> 934                         case TAG_CONST:</span>
<span class="line-removed"> 935                             len += el.getValue().length();</span>
<span class="line-removed"> 936                             break;</span>
<span class="line-removed"> 937                         case TAG_ARG:</span>
<span class="line-removed"> 938                             /*</span>
<span class="line-removed"> 939                                 If an argument is String, then we can call .length() on it. Sized/Exact modes have</span>
<span class="line-removed"> 940                                 converted arguments for us. If an argument is primitive, we can provide a guess</span>
<span class="line-removed"> 941                                 for its String representation size.</span>
<span class="line-removed"> 942                             */</span>
<span class="line-removed"> 943                             Class&lt;?&gt; cl = arr[el.getArgPos()];</span>
<span class="line-removed"> 944                             if (cl == String.class) {</span>
<span class="line-removed"> 945                                 mv.visitIntInsn(ALOAD, off);</span>
<span class="line-removed"> 946                                 mv.visitMethodInsn(</span>
<span class="line-removed"> 947                                         INVOKEVIRTUAL,</span>
<span class="line-removed"> 948                                         &quot;java/lang/String&quot;,</span>
<span class="line-removed"> 949                                         &quot;length&quot;,</span>
<span class="line-removed"> 950                                         &quot;()I&quot;,</span>
<span class="line-removed"> 951                                         false</span>
<span class="line-removed"> 952                                 );</span>
<span class="line-removed"> 953                                 mv.visitInsn(IADD);</span>
<span class="line-removed"> 954                             } else if (cl.isPrimitive()) {</span>
<span class="line-removed"> 955                                 len += estimateSize(cl);</span>
<span class="line-removed"> 956                             }</span>
<span class="line-removed"> 957                             off += getParameterSize(cl);</span>
<span class="line-removed"> 958                             break;</span>
<span class="line-removed"> 959                         default:</span>
<span class="line-removed"> 960                             throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());</span>
<span class="line-removed"> 961                     }</span>
<span class="line-removed"> 962                 }</span>
<span class="line-removed"> 963 </span>
<span class="line-removed"> 964                 // Constants have non-zero length, mix in</span>
<span class="line-removed"> 965                 if (len &gt; 0) {</span>
<span class="line-removed"> 966                     iconst(mv, len);</span>
<span class="line-removed"> 967                     mv.visitInsn(IADD);</span>
<span class="line-removed"> 968                 }</span>
<span class="line-removed"> 969 </span>
<span class="line-removed"> 970                 mv.visitMethodInsn(</span>
<span class="line-removed"> 971                         INVOKESPECIAL,</span>
<span class="line-removed"> 972                         &quot;java/lang/StringBuilder&quot;,</span>
<span class="line-removed"> 973                         &quot;&lt;init&gt;&quot;,</span>
<span class="line-removed"> 974                         &quot;(I)V&quot;,</span>
<span class="line-removed"> 975                         false</span>
<span class="line-removed"> 976                 );</span>
<span class="line-removed"> 977             } else {</span>
<span class="line-removed"> 978                 mv.visitMethodInsn(</span>
<span class="line-removed"> 979                         INVOKESPECIAL,</span>
<span class="line-removed"> 980                         &quot;java/lang/StringBuilder&quot;,</span>
<span class="line-removed"> 981                         &quot;&lt;init&gt;&quot;,</span>
<span class="line-removed"> 982                         &quot;()V&quot;,</span>
<span class="line-removed"> 983                         false</span>
<span class="line-removed"> 984                 );</span>
<span class="line-removed"> 985             }</span>
<span class="line-removed"> 986 </span>
<span class="line-removed"> 987             // At this point, we have a blank StringBuilder on stack, fill it in with .append calls.</span>
<span class="line-removed"> 988             {</span>
<span class="line-removed"> 989                 int off = 0;</span>
<span class="line-removed"> 990                 for (RecipeElement el : recipe.getElements()) {</span>
<span class="line-removed"> 991                     String desc;</span>
<span class="line-removed"> 992                     switch (el.getTag()) {</span>
<span class="line-removed"> 993                         case TAG_CONST:</span>
<span class="line-removed"> 994                             mv.visitLdcInsn(el.getValue());</span>
<span class="line-removed"> 995                             desc = getSBAppendDesc(String.class);</span>
<span class="line-removed"> 996                             break;</span>
<span class="line-removed"> 997                         case TAG_ARG:</span>
<span class="line-removed"> 998                             Class&lt;?&gt; cl = arr[el.getArgPos()];</span>
<span class="line-removed"> 999                             mv.visitVarInsn(getLoadOpcode(cl), off);</span>
<span class="line-removed">1000                             off += getParameterSize(cl);</span>
<span class="line-removed">1001                             desc = getSBAppendDesc(cl);</span>
<span class="line-removed">1002                             break;</span>
<span class="line-removed">1003                         default:</span>
<span class="line-removed">1004                             throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());</span>
<span class="line-removed">1005                     }</span>
<span class="line-removed">1006 </span>
<span class="line-removed">1007                     mv.visitMethodInsn(</span>
<span class="line-removed">1008                             INVOKEVIRTUAL,</span>
<span class="line-removed">1009                             &quot;java/lang/StringBuilder&quot;,</span>
<span class="line-removed">1010                             &quot;append&quot;,</span>
<span class="line-removed">1011                             desc,</span>
<span class="line-removed">1012                             false</span>
<span class="line-removed">1013                     );</span>
<span class="line-removed">1014                 }</span>
<span class="line-removed">1015             }</span>
1016 
<a name="16" id="anc16"></a><span class="line-modified">1017             if (DEBUG &amp;&amp; mode.isExact()) {</span>
<span class="line-removed">1018                 /*</span>
<span class="line-removed">1019                     Exactness checks compare the final StringBuilder.capacity() with a resulting</span>
<span class="line-removed">1020                     String.length(). If these values disagree, that means StringBuilder had to perform</span>
<span class="line-removed">1021                     storage trimming, which defeats the purpose of exact strategies.</span>
<span class="line-removed">1022                  */</span>
<span class="line-removed">1023 </span>
<span class="line-removed">1024                 /*</span>
<span class="line-removed">1025                    The logic for this check is as follows:</span>
<span class="line-removed">1026 </span>
<span class="line-removed">1027                      Stack before:     Op:</span>
<span class="line-removed">1028                       (SB)              dup, dup</span>
<span class="line-removed">1029                       (SB, SB, SB)      capacity()</span>
<span class="line-removed">1030                       (int, SB, SB)     swap</span>
<span class="line-removed">1031                       (SB, int, SB)     toString()</span>
<span class="line-removed">1032                       (S, int, SB)      length()</span>
<span class="line-removed">1033                       (int, int, SB)    if_icmpeq</span>
<span class="line-removed">1034                       (SB)              &lt;end&gt;</span>
<span class="line-removed">1035 </span>
<span class="line-removed">1036                    Note that it leaves the same StringBuilder on exit, like the one on enter.</span>
<span class="line-removed">1037                  */</span>
<span class="line-removed">1038 </span>
<span class="line-removed">1039                 mv.visitInsn(DUP);</span>
<span class="line-removed">1040                 mv.visitInsn(DUP);</span>
<span class="line-removed">1041 </span>
<span class="line-removed">1042                 mv.visitMethodInsn(</span>
<span class="line-removed">1043                         INVOKEVIRTUAL,</span>
<span class="line-removed">1044                         &quot;java/lang/StringBuilder&quot;,</span>
<span class="line-removed">1045                         &quot;capacity&quot;,</span>
<span class="line-removed">1046                         &quot;()I&quot;,</span>
<span class="line-removed">1047                         false</span>
<span class="line-removed">1048                 );</span>
<span class="line-removed">1049 </span>
<span class="line-removed">1050                 mv.visitInsn(SWAP);</span>
<span class="line-removed">1051 </span>
<span class="line-removed">1052                 mv.visitMethodInsn(</span>
<span class="line-removed">1053                         INVOKEVIRTUAL,</span>
<span class="line-removed">1054                         &quot;java/lang/StringBuilder&quot;,</span>
<span class="line-removed">1055                         &quot;toString&quot;,</span>
<span class="line-removed">1056                         &quot;()Ljava/lang/String;&quot;,</span>
<span class="line-removed">1057                         false</span>
<span class="line-removed">1058                 );</span>
<span class="line-removed">1059 </span>
<span class="line-removed">1060                 mv.visitMethodInsn(</span>
<span class="line-removed">1061                         INVOKEVIRTUAL,</span>
<span class="line-removed">1062                         &quot;java/lang/String&quot;,</span>
<span class="line-removed">1063                         &quot;length&quot;,</span>
<span class="line-removed">1064                         &quot;()I&quot;,</span>
<span class="line-removed">1065                         false</span>
<span class="line-removed">1066                 );</span>
<span class="line-removed">1067 </span>
<span class="line-removed">1068                 Label l0 = new Label();</span>
<span class="line-removed">1069                 mv.visitJumpInsn(IF_ICMPEQ, l0);</span>
<span class="line-removed">1070 </span>
<span class="line-removed">1071                 mv.visitTypeInsn(NEW, &quot;java/lang/AssertionError&quot;);</span>
<span class="line-removed">1072                 mv.visitInsn(DUP);</span>
<span class="line-removed">1073                 mv.visitLdcInsn(&quot;Failed exactness check&quot;);</span>
<span class="line-removed">1074                 mv.visitMethodInsn(INVOKESPECIAL,</span>
<span class="line-removed">1075                         &quot;java/lang/AssertionError&quot;,</span>
<span class="line-removed">1076                         &quot;&lt;init&gt;&quot;,</span>
<span class="line-removed">1077                         &quot;(Ljava/lang/Object;)V&quot;,</span>
<span class="line-removed">1078                         false);</span>
<span class="line-removed">1079                 mv.visitInsn(ATHROW);</span>
<span class="line-removed">1080 </span>
<span class="line-removed">1081                 mv.visitLabel(l0);</span>
<span class="line-removed">1082             }</span>
1083 
<a name="17" id="anc17"></a><span class="line-modified">1084             mv.visitMethodInsn(</span>
<span class="line-modified">1085                     INVOKEVIRTUAL,</span>
<span class="line-modified">1086                     &quot;java/lang/StringBuilder&quot;,</span>
<span class="line-modified">1087                     &quot;toString&quot;,</span>
<span class="line-removed">1088                     &quot;()Ljava/lang/String;&quot;,</span>
<span class="line-removed">1089                     false</span>
<span class="line-removed">1090             );</span>
1091 
<a name="18" id="anc18"></a><span class="line-modified">1092             mv.visitInsn(ARETURN);</span>




1093 
<a name="19" id="anc19"></a><span class="line-modified">1094             mv.visitMaxs(-1, -1);</span>
<span class="line-modified">1095             mv.visitEnd();</span>
<span class="line-modified">1096             cw.visitEnd();</span>


1097 
<a name="20" id="anc20"></a><span class="line-removed">1098             byte[] classBytes = cw.toByteArray();</span>
<span class="line-removed">1099             try {</span>
<span class="line-removed">1100                 Class&lt;?&gt; innerClass = lookup.defineHiddenClass(classBytes, true, STRONG).lookupClass();</span>
<span class="line-removed">1101                 dumpIfEnabled(className, classBytes);</span>
<span class="line-removed">1102                 MethodHandle mh = lookup.findStatic(innerClass, METHOD_NAME, args);</span>
<span class="line-removed">1103                 if (CACHE_ENABLE) {</span>
<span class="line-removed">1104                     CACHE.put(key, mh);</span>
1105                 }
<a name="21" id="anc21"></a><span class="line-removed">1106                 return mh;</span>
<span class="line-removed">1107             } catch (Exception e) {</span>
<span class="line-removed">1108                 dumpIfEnabled(className + &quot;$$FAILED&quot;, classBytes);</span>
<span class="line-removed">1109                 throw new StringConcatException(&quot;Exception while spinning the class&quot;, e);</span>
<span class="line-removed">1110             }</span>
<span class="line-removed">1111         }</span>
<span class="line-removed">1112 </span>
<span class="line-removed">1113         /**</span>
<span class="line-removed">1114          * The generated class is in the same package as the host class as</span>
<span class="line-removed">1115          * it&#39;s the implementation of the string concatenation for the host</span>
<span class="line-removed">1116          * class.</span>
<span class="line-removed">1117          *</span>
<span class="line-removed">1118          * When cache is enabled, we want to cache as much as we can.</span>
<span class="line-removed">1119          */</span>
<span class="line-removed">1120         private static String getClassName(Class&lt;?&gt; hostClass) {</span>
<span class="line-removed">1121             if (CACHE_ENABLE) {</span>
<span class="line-removed">1122                 String pkgName = hostClass.getPackageName();</span>
<span class="line-removed">1123                 return (!pkgName.isEmpty() ? pkgName.replace(&#39;.&#39;, &#39;/&#39;) + &quot;/&quot; : &quot;&quot;) + &quot;Stubs$$StringConcat&quot;;</span>
<span class="line-removed">1124             } else {</span>
<span class="line-removed">1125                 String name = hostClass.isHidden() ? hostClass.getName().replace(&#39;/&#39;, &#39;_&#39;)</span>
<span class="line-removed">1126                         : hostClass.getName();</span>
<span class="line-removed">1127                 return name.replace(&#39;.&#39;, &#39;/&#39;) + &quot;$$StringConcat&quot;;</span>
<span class="line-removed">1128             }</span>
<span class="line-removed">1129         }</span>
<span class="line-removed">1130 </span>
<span class="line-removed">1131         private static void dumpIfEnabled(String name, byte[] bytes) {</span>
<span class="line-removed">1132             if (DUMPER != null) {</span>
<span class="line-removed">1133                 DUMPER.dumpClass(name, bytes);</span>
1134             }
<a name="22" id="anc22"></a>
1135         }
1136 
<a name="23" id="anc23"></a><span class="line-modified">1137         private static String getSBAppendDesc(Class&lt;?&gt; cl) {</span>
<span class="line-modified">1138             if (cl.isPrimitive()) {</span>
<span class="line-modified">1139                 if (cl == Integer.TYPE || cl == Byte.TYPE || cl == Short.TYPE) {</span>
<span class="line-modified">1140                     return &quot;(I)Ljava/lang/StringBuilder;&quot;;</span>
<span class="line-modified">1141                 } else if (cl == Boolean.TYPE) {</span>
<span class="line-modified">1142                     return &quot;(Z)Ljava/lang/StringBuilder;&quot;;</span>
<span class="line-modified">1143                 } else if (cl == Character.TYPE) {</span>
<span class="line-modified">1144                     return &quot;(C)Ljava/lang/StringBuilder;&quot;;</span>
<span class="line-modified">1145                 } else if (cl == Double.TYPE) {</span>
<span class="line-modified">1146                     return &quot;(D)Ljava/lang/StringBuilder;&quot;;</span>
<span class="line-removed">1147                 } else if (cl == Float.TYPE) {</span>
<span class="line-removed">1148                     return &quot;(F)Ljava/lang/StringBuilder;&quot;;</span>
<span class="line-removed">1149                 } else if (cl == Long.TYPE) {</span>
<span class="line-removed">1150                     return &quot;(J)Ljava/lang/StringBuilder;&quot;;</span>
<span class="line-removed">1151                 } else {</span>
<span class="line-removed">1152                     throw new IllegalStateException(&quot;Unhandled primitive StringBuilder.append: &quot; + cl);</span>
1153                 }
<a name="24" id="anc24"></a><span class="line-modified">1154             } else if (cl == String.class) {</span>
<span class="line-modified">1155                 return &quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;;</span>
<span class="line-removed">1156             } else {</span>
<span class="line-removed">1157                 return &quot;(Ljava/lang/Object;)Ljava/lang/StringBuilder;&quot;;</span>
1158             }
1159         }
1160 
<a name="25" id="anc25"></a><span class="line-modified">1161         private static String getStringValueOfDesc(Class&lt;?&gt; cl) {</span>
<span class="line-modified">1162             if (cl.isPrimitive()) {</span>
<span class="line-modified">1163                 if (cl == Integer.TYPE || cl == Byte.TYPE || cl == Short.TYPE) {</span>
<span class="line-removed">1164                     return &quot;(I)Ljava/lang/String;&quot;;</span>
<span class="line-removed">1165                 } else if (cl == Boolean.TYPE) {</span>
<span class="line-removed">1166                     return &quot;(Z)Ljava/lang/String;&quot;;</span>
<span class="line-removed">1167                 } else if (cl == Character.TYPE) {</span>
<span class="line-removed">1168                     return &quot;(C)Ljava/lang/String;&quot;;</span>
<span class="line-removed">1169                 } else if (cl == Double.TYPE) {</span>
<span class="line-removed">1170                     return &quot;(D)Ljava/lang/String;&quot;;</span>
<span class="line-removed">1171                 } else if (cl == Float.TYPE) {</span>
<span class="line-removed">1172                     return &quot;(F)Ljava/lang/String;&quot;;</span>
<span class="line-removed">1173                 } else if (cl == Long.TYPE) {</span>
<span class="line-removed">1174                     return &quot;(J)Ljava/lang/String;&quot;;</span>
<span class="line-removed">1175                 } else {</span>
<span class="line-removed">1176                     throw new IllegalStateException(&quot;Unhandled String.valueOf: &quot; + cl);</span>
<span class="line-removed">1177                 }</span>
<span class="line-removed">1178             } else if (cl == String.class) {</span>
<span class="line-removed">1179                 return &quot;(Ljava/lang/String;)Ljava/lang/String;&quot;;</span>
<span class="line-removed">1180             } else {</span>
<span class="line-removed">1181                 return &quot;(Ljava/lang/Object;)Ljava/lang/String;&quot;;</span>
<span class="line-removed">1182             }</span>
<span class="line-removed">1183         }</span>
1184 
<a name="26" id="anc26"></a><span class="line-modified">1185         /**</span>
<span class="line-modified">1186          * The following method is copied from</span>
<span class="line-removed">1187          * org.objectweb.asm.commons.InstructionAdapter. Part of ASM: a very small</span>
<span class="line-removed">1188          * and fast Java bytecode manipulation framework.</span>
<span class="line-removed">1189          * Copyright (c) 2000-2005 INRIA, France Telecom All rights reserved.</span>
<span class="line-removed">1190          */</span>
<span class="line-removed">1191         private static void iconst(MethodVisitor mv, final int cst) {</span>
<span class="line-removed">1192             if (cst &gt;= -1 &amp;&amp; cst &lt;= 5) {</span>
<span class="line-removed">1193                 mv.visitInsn(Opcodes.ICONST_0 + cst);</span>
<span class="line-removed">1194             } else if (cst &gt;= Byte.MIN_VALUE &amp;&amp; cst &lt;= Byte.MAX_VALUE) {</span>
<span class="line-removed">1195                 mv.visitIntInsn(Opcodes.BIPUSH, cst);</span>
<span class="line-removed">1196             } else if (cst &gt;= Short.MIN_VALUE &amp;&amp; cst &lt;= Short.MAX_VALUE) {</span>
<span class="line-removed">1197                 mv.visitIntInsn(Opcodes.SIPUSH, cst);</span>
<span class="line-removed">1198             } else {</span>
<span class="line-removed">1199                 mv.visitLdcInsn(cst);</span>
<span class="line-removed">1200             }</span>
<span class="line-removed">1201         }</span>
1202 
<a name="27" id="anc27"></a><span class="line-modified">1203         private static int getLoadOpcode(Class&lt;?&gt; c) {</span>
<span class="line-removed">1204             if (c == Void.TYPE) {</span>
<span class="line-removed">1205                 throw new InternalError(&quot;Unexpected void type of load opcode&quot;);</span>
<span class="line-removed">1206             }</span>
<span class="line-removed">1207             return ILOAD + getOpcodeOffset(c);</span>
<span class="line-removed">1208         }</span>
1209 
<a name="28" id="anc28"></a><span class="line-modified">1210         private static int getOpcodeOffset(Class&lt;?&gt; c) {</span>
<span class="line-removed">1211             if (c.isPrimitive()) {</span>
<span class="line-removed">1212                 if (c == Long.TYPE) {</span>
<span class="line-removed">1213                     return 1;</span>
<span class="line-removed">1214                 } else if (c == Float.TYPE) {</span>
<span class="line-removed">1215                     return 2;</span>
<span class="line-removed">1216                 } else if (c == Double.TYPE) {</span>
<span class="line-removed">1217                     return 3;</span>
<span class="line-removed">1218                 }</span>
<span class="line-removed">1219                 return 0;</span>
<span class="line-removed">1220             } else {</span>
<span class="line-removed">1221                 return 4;</span>
<span class="line-removed">1222             }</span>
<span class="line-removed">1223         }</span>
1224 
<a name="29" id="anc29"></a><span class="line-modified">1225         private static int getParameterSize(Class&lt;?&gt; c) {</span>
<span class="line-modified">1226             if (c == Void.TYPE) {</span>
<span class="line-modified">1227                 return 0;</span>
<span class="line-removed">1228             } else if (c == Long.TYPE || c == Double.TYPE) {</span>
<span class="line-removed">1229                 return 2;</span>
<span class="line-removed">1230             }</span>
<span class="line-removed">1231             return 1;</span>
<span class="line-removed">1232         }</span>
<span class="line-removed">1233     }</span>
1234 
<a name="30" id="anc30"></a><span class="line-modified">1235     /**</span>
<span class="line-modified">1236      * MethodHandle StringBuilder strategy.</span>
<span class="line-modified">1237      *</span>
<span class="line-modified">1238      * &lt;p&gt;This strategy operates in two modes, gated by {@link Mode}.</span>
<span class="line-modified">1239      *</span>
<span class="line-modified">1240      * &lt;p&gt;&lt;b&gt;{@link Strategy#MH_SB_SIZED}: &quot;MethodHandles StringBuilder,</span>
<span class="line-modified">1241      * sized&quot;.&lt;/b&gt;</span>
<span class="line-modified">1242      *</span>
<span class="line-modified">1243      * &lt;p&gt;This strategy avoids spinning up the bytecode by building the</span>
<span class="line-removed">1244      * computation on MethodHandle combinators. The computation is built with</span>
<span class="line-removed">1245      * public MethodHandle APIs, resolved from a public Lookup sequence, and</span>
<span class="line-removed">1246      * ends up calling the public StringBuilder API. Therefore, this strategy</span>
<span class="line-removed">1247      * does not use any private API at all since everything is handled under</span>
<span class="line-removed">1248      * cover by java.lang.invoke APIs.</span>
<span class="line-removed">1249      *</span>
<span class="line-removed">1250      * &lt;p&gt;&lt;b&gt;{@link Strategy#MH_SB_SIZED_EXACT}: &quot;MethodHandles StringBuilder,</span>
<span class="line-removed">1251      * sized exactly&quot;.&lt;/b&gt;</span>
<span class="line-removed">1252      *</span>
<span class="line-removed">1253      * &lt;p&gt;This strategy improves on @link Strategy#MH_SB_SIZED}, by first</span>
<span class="line-removed">1254      * converting all arguments to String in order to get the exact capacity</span>
<span class="line-removed">1255      * StringBuilder should have. The conversion is done via the public</span>
<span class="line-removed">1256      * String.valueOf and/or Object.toString methods, and does not touch any</span>
<span class="line-removed">1257      * private String API.</span>
<span class="line-removed">1258      */</span>
<span class="line-removed">1259     private static final class MethodHandleStringBuilderStrategy {</span>
<span class="line-removed">1260         private MethodHandleStringBuilderStrategy() {</span>
<span class="line-removed">1261             // no instantiation</span>
<span class="line-removed">1262         }</span>
1263 
<a name="31" id="anc31"></a><span class="line-modified">1264         private static MethodHandle generate(MethodType mt, Recipe recipe, Mode mode) throws Exception {</span>
<span class="line-modified">1265             int pc = mt.parameterCount();</span>
<span class="line-removed">1266 </span>
<span class="line-removed">1267             Class&lt;?&gt;[] ptypes = mt.parameterArray();</span>
<span class="line-removed">1268             MethodHandle[] filters = new MethodHandle[ptypes.length];</span>
<span class="line-removed">1269             for (int i = 0; i &lt; ptypes.length; i++) {</span>
<span class="line-removed">1270                 MethodHandle filter;</span>
<span class="line-removed">1271                 switch (mode) {</span>
<span class="line-removed">1272                     case SIZED:</span>
<span class="line-removed">1273                         // In sized mode, we convert all references and floats/doubles</span>
<span class="line-removed">1274                         // to String: there is no specialization for different</span>
<span class="line-removed">1275                         // classes in StringBuilder API, and it will convert to</span>
<span class="line-removed">1276                         // String internally anyhow.</span>
<span class="line-removed">1277                         filter = Stringifiers.forMost(ptypes[i]);</span>
<span class="line-removed">1278                         break;</span>
<span class="line-removed">1279                     case SIZED_EXACT:</span>
<span class="line-removed">1280                         // In exact mode, we convert everything to String:</span>
<span class="line-removed">1281                         // this helps to compute the storage exactly.</span>
<span class="line-removed">1282                         filter = Stringifiers.forAny(ptypes[i]);</span>
<span class="line-removed">1283                         break;</span>
<span class="line-removed">1284                     default:</span>
<span class="line-removed">1285                         throw new StringConcatException(&quot;Not supported&quot;);</span>
<span class="line-removed">1286                 }</span>
<span class="line-removed">1287                 if (filter != null) {</span>
<span class="line-removed">1288                     filters[i] = filter;</span>
<span class="line-removed">1289                     ptypes[i] = filter.type().returnType();</span>
<span class="line-removed">1290                 }</span>
<span class="line-removed">1291             }</span>
1292 
<a name="32" id="anc32"></a><span class="line-modified">1293             MethodHandle[] lengthers = new MethodHandle[pc];</span>
<span class="line-modified">1294 </span>
<span class="line-modified">1295             // Figure out lengths: constants&#39; lengths can be deduced on the spot.</span>
<span class="line-modified">1296             // All reference arguments were filtered to String in the combinators below, so we can</span>
<span class="line-modified">1297             // call the usual String.length(). Primitive values string sizes can be estimated.</span>
<span class="line-removed">1298             int initial = 0;</span>
<span class="line-removed">1299             for (RecipeElement el : recipe.getElements()) {</span>
<span class="line-removed">1300                 switch (el.getTag()) {</span>
<span class="line-removed">1301                     case TAG_CONST:</span>
<span class="line-removed">1302                         initial += el.getValue().length();</span>
<span class="line-removed">1303                         break;</span>
<span class="line-removed">1304                     case TAG_ARG:</span>
<span class="line-removed">1305                         final int i = el.getArgPos();</span>
<span class="line-removed">1306                         Class&lt;?&gt; type = ptypes[i];</span>
<span class="line-removed">1307                         if (type.isPrimitive()) {</span>
<span class="line-removed">1308                             MethodHandle est = MethodHandles.constant(int.class, estimateSize(type));</span>
<span class="line-removed">1309                             est = MethodHandles.dropArguments(est, 0, type);</span>
<span class="line-removed">1310                             lengthers[i] = est;</span>
<span class="line-removed">1311                         } else {</span>
<span class="line-removed">1312                             lengthers[i] = STRING_LENGTH;</span>
<span class="line-removed">1313                         }</span>
<span class="line-removed">1314                         break;</span>
<span class="line-removed">1315                     default:</span>
<span class="line-removed">1316                         throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());</span>
1317                 }
<a name="33" id="anc33"></a><span class="line-modified">1318             }</span>
<span class="line-modified">1319 </span>
<span class="line-modified">1320             // Create (StringBuilder, &lt;args&gt;) shape for appending:</span>
<span class="line-modified">1321             MethodHandle builder = MethodHandles.dropArguments(MethodHandles.identity(StringBuilder.class), 1, ptypes);</span>
<span class="line-modified">1322 </span>
<span class="line-modified">1323             // Compose append calls. This is done in reverse because the application order is</span>
<span class="line-modified">1324             // reverse as well.</span>
<span class="line-modified">1325             List&lt;RecipeElement&gt; elements = recipe.getElements();</span>
<span class="line-modified">1326             for (int i = elements.size() - 1; i &gt;= 0; i--) {</span>
<span class="line-modified">1327                 RecipeElement el = elements.get(i);</span>
<span class="line-modified">1328                 MethodHandle appender;</span>
<span class="line-removed">1329                 switch (el.getTag()) {</span>
<span class="line-removed">1330                     case TAG_CONST:</span>
<span class="line-removed">1331                         MethodHandle mh = appender(adaptToStringBuilder(String.class));</span>
<span class="line-removed">1332                         appender = MethodHandles.insertArguments(mh, 1, el.getValue());</span>
<span class="line-removed">1333                         break;</span>
<span class="line-removed">1334                     case TAG_ARG:</span>
<span class="line-removed">1335                         int ac = el.getArgPos();</span>
<span class="line-removed">1336                         appender = appender(ptypes[ac]);</span>
<span class="line-removed">1337 </span>
<span class="line-removed">1338                         // Insert dummy arguments to match the prefix in the signature.</span>
<span class="line-removed">1339                         // The actual appender argument will be the ac-ith argument.</span>
<span class="line-removed">1340                         if (ac != 0) {</span>
<span class="line-removed">1341                             appender = MethodHandles.dropArguments(appender, 1, Arrays.copyOf(ptypes, ac));</span>
<span class="line-removed">1342                         }</span>
<span class="line-removed">1343                         break;</span>
<span class="line-removed">1344                     default:</span>
<span class="line-removed">1345                         throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());</span>
1346                 }
<a name="34" id="anc34"></a><span class="line-modified">1347                 builder = MethodHandles.foldArguments(builder, appender);</span>
<span class="line-modified">1348             }</span>
<span class="line-removed">1349 </span>
<span class="line-removed">1350             // Build the sub-tree that adds the sizes and produces a StringBuilder:</span>
<span class="line-removed">1351 </span>
<span class="line-removed">1352             // a) Start with the reducer that accepts all arguments, plus one</span>
<span class="line-removed">1353             //    slot for the initial value. Inject the initial value right away.</span>
<span class="line-removed">1354             //    This produces (&lt;ints&gt;)int shape:</span>
<span class="line-removed">1355             MethodHandle sum = getReducerFor(pc + 1);</span>
<span class="line-removed">1356             MethodHandle adder = MethodHandles.insertArguments(sum, 0, initial);</span>
<span class="line-removed">1357 </span>
<span class="line-removed">1358             // b) Apply lengthers to transform arguments to lengths, producing (&lt;args&gt;)int</span>
<span class="line-removed">1359             adder = MethodHandles.filterArguments(adder, 0, lengthers);</span>
<span class="line-removed">1360 </span>
<span class="line-removed">1361             // c) Instantiate StringBuilder (&lt;args&gt;)int -&gt; (&lt;args&gt;)StringBuilder</span>
<span class="line-removed">1362             MethodHandle newBuilder = MethodHandles.filterReturnValue(adder, NEW_STRING_BUILDER);</span>
<span class="line-removed">1363 </span>
<span class="line-removed">1364             // d) Fold in StringBuilder constructor, this produces (&lt;args&gt;)StringBuilder</span>
<span class="line-removed">1365             MethodHandle mh = MethodHandles.foldArguments(builder, newBuilder);</span>
<span class="line-removed">1366 </span>
<span class="line-removed">1367             // Convert non-primitive arguments to Strings</span>
<span class="line-removed">1368             mh = MethodHandles.filterArguments(mh, 0, filters);</span>
<span class="line-removed">1369 </span>
<span class="line-removed">1370             // Convert (&lt;args&gt;)StringBuilder to (&lt;args&gt;)String</span>
<span class="line-removed">1371             if (DEBUG &amp;&amp; mode.isExact()) {</span>
<span class="line-removed">1372                 mh = MethodHandles.filterReturnValue(mh, BUILDER_TO_STRING_CHECKED);</span>
<span class="line-removed">1373             } else {</span>
<span class="line-removed">1374                 mh = MethodHandles.filterReturnValue(mh, BUILDER_TO_STRING);</span>
1375             }
<a name="35" id="anc35"></a><span class="line-removed">1376 </span>
<span class="line-removed">1377             return mh;</span>
<span class="line-removed">1378         }</span>
<span class="line-removed">1379 </span>
<span class="line-removed">1380         private static MethodHandle getReducerFor(int cnt) {</span>
<span class="line-removed">1381             return SUMMERS.computeIfAbsent(cnt, SUMMER);</span>
1382         }
1383 
<a name="36" id="anc36"></a><span class="line-modified">1384         private static MethodHandle appender(Class&lt;?&gt; appendType) {</span>
<span class="line-modified">1385             MethodHandle appender = lookupVirtual(MethodHandles.publicLookup(), StringBuilder.class, &quot;append&quot;,</span>
<span class="line-modified">1386                     StringBuilder.class, adaptToStringBuilder(appendType));</span>


















































1387 
<a name="37" id="anc37"></a><span class="line-modified">1388             // appenders should return void, this would not modify the target signature during folding</span>
<span class="line-modified">1389             MethodType nt = MethodType.methodType(void.class, StringBuilder.class, appendType);</span>
<span class="line-modified">1390             return appender.asType(nt);</span>
<span class="line-removed">1391         }</span>
1392 
<a name="38" id="anc38"></a><span class="line-modified">1393         private static String toStringChecked(StringBuilder sb) {</span>
<span class="line-modified">1394             String s = sb.toString();</span>
<span class="line-modified">1395             if (s.length() != sb.capacity()) {</span>
<span class="line-removed">1396                 throw new AssertionError(&quot;Exactness check failed: result length = &quot; + s.length() + &quot;, buffer capacity = &quot; + sb.capacity());</span>
1397             }
<a name="39" id="anc39"></a><span class="line-removed">1398             return s;</span>
<span class="line-removed">1399         }</span>
<span class="line-removed">1400 </span>
<span class="line-removed">1401         private static int sum(int v1, int v2) {</span>
<span class="line-removed">1402             return v1 + v2;</span>
1403         }
1404 
<a name="40" id="anc40"></a><span class="line-modified">1405         private static int sum(int v1, int v2, int v3) {</span>
<span class="line-modified">1406             return v1 + v2 + v3;</span>
<span class="line-modified">1407         }</span>
<span class="line-modified">1408 </span>
<span class="line-modified">1409         private static int sum(int v1, int v2, int v3, int v4) {</span>
<span class="line-modified">1410             return v1 + v2 + v3 + v4;</span>
<span class="line-modified">1411         }</span>
<span class="line-modified">1412 </span>
<span class="line-modified">1413         private static int sum(int v1, int v2, int v3, int v4, int v5) {</span>
<span class="line-modified">1414             return v1 + v2 + v3 + v4 + v5;</span>
<span class="line-removed">1415         }</span>
<span class="line-removed">1416 </span>
<span class="line-removed">1417         private static int sum(int v1, int v2, int v3, int v4, int v5, int v6) {</span>
<span class="line-removed">1418             return v1 + v2 + v3 + v4 + v5 + v6;</span>
<span class="line-removed">1419         }</span>
<span class="line-removed">1420 </span>
<span class="line-removed">1421         private static int sum(int v1, int v2, int v3, int v4, int v5, int v6, int v7) {</span>
<span class="line-removed">1422             return v1 + v2 + v3 + v4 + v5 + v6 + v7;</span>
<span class="line-removed">1423         }</span>
<span class="line-removed">1424 </span>
<span class="line-removed">1425         private static int sum(int v1, int v2, int v3, int v4, int v5, int v6, int v7, int v8) {</span>
<span class="line-removed">1426             return v1 + v2 + v3 + v4 + v5 + v6 + v7 + v8;</span>
1427         }
1428 
<a name="41" id="anc41"></a><span class="line-modified">1429         private static int sum(int initial, int[] vs) {</span>
<span class="line-removed">1430             int sum = initial;</span>
<span class="line-removed">1431             for (int v : vs) {</span>
<span class="line-removed">1432                 sum += v;</span>
<span class="line-removed">1433             }</span>
<span class="line-removed">1434             return sum;</span>
<span class="line-removed">1435         }</span>
1436 
<a name="42" id="anc42"></a><span class="line-modified">1437         private static final Lookup MHSBS_LOOKUP = lookup();</span>
<span class="line-modified">1438 </span>
<span class="line-modified">1439         private static final ConcurrentMap&lt;Integer, MethodHandle&gt; SUMMERS;</span>
<span class="line-removed">1440 </span>
<span class="line-removed">1441         // This one is deliberately non-lambdified to optimize startup time:</span>
<span class="line-removed">1442         private static final Function&lt;Integer, MethodHandle&gt; SUMMER = new Function&lt;Integer, MethodHandle&gt;() {</span>
<span class="line-removed">1443             @Override</span>
<span class="line-removed">1444             public MethodHandle apply(Integer cnt) {</span>
<span class="line-removed">1445                 if (cnt == 1) {</span>
<span class="line-removed">1446                     return MethodHandles.identity(int.class);</span>
<span class="line-removed">1447                 } else if (cnt &lt;= 8) {</span>
<span class="line-removed">1448                     // Variable-arity collectors are not as efficient as small-count methods,</span>
<span class="line-removed">1449                     // unroll some initial sizes.</span>
<span class="line-removed">1450                     Class&lt;?&gt;[] cls = new Class&lt;?&gt;[cnt];</span>
<span class="line-removed">1451                     Arrays.fill(cls, int.class);</span>
<span class="line-removed">1452                     return lookupStatic(MHSBS_LOOKUP, MethodHandleStringBuilderStrategy.class, &quot;sum&quot;, int.class, cls);</span>
<span class="line-removed">1453                 } else {</span>
<span class="line-removed">1454                     return lookupStatic(MHSBS_LOOKUP, MethodHandleStringBuilderStrategy.class, &quot;sum&quot;, int.class, int.class, int[].class)</span>
<span class="line-removed">1455                             .asCollector(int[].class, cnt - 1);</span>
<span class="line-removed">1456                 }</span>
<span class="line-removed">1457             }</span>
<span class="line-removed">1458         };</span>
<span class="line-removed">1459 </span>
<span class="line-removed">1460         private static final MethodHandle NEW_STRING_BUILDER, STRING_LENGTH, BUILDER_TO_STRING, BUILDER_TO_STRING_CHECKED;</span>
<span class="line-removed">1461 </span>
<span class="line-removed">1462         static {</span>
<span class="line-removed">1463             SUMMERS = new ConcurrentHashMap&lt;&gt;();</span>
<span class="line-removed">1464             Lookup publicLookup = MethodHandles.publicLookup();</span>
<span class="line-removed">1465             NEW_STRING_BUILDER = lookupConstructor(publicLookup, StringBuilder.class, int.class);</span>
<span class="line-removed">1466             STRING_LENGTH = lookupVirtual(publicLookup, String.class, &quot;length&quot;, int.class);</span>
<span class="line-removed">1467             BUILDER_TO_STRING = lookupVirtual(publicLookup, StringBuilder.class, &quot;toString&quot;, String.class);</span>
<span class="line-removed">1468             if (DEBUG) {</span>
<span class="line-removed">1469                 BUILDER_TO_STRING_CHECKED = lookupStatic(MHSBS_LOOKUP, MethodHandleStringBuilderStrategy.class,</span>
<span class="line-removed">1470                         &quot;toStringChecked&quot;, String.class, StringBuilder.class);</span>
<span class="line-removed">1471             } else {</span>
<span class="line-removed">1472                 BUILDER_TO_STRING_CHECKED = null;</span>
<span class="line-removed">1473             }</span>
1474         }
1475 
<a name="43" id="anc43"></a>
1476     }
1477 
<a name="44" id="anc44"></a><span class="line-modified">1478 </span>
<span class="line-modified">1479     /**</span>
<span class="line-modified">1480      * &lt;p&gt;&lt;b&gt;{@link Strategy#MH_INLINE_SIZED_EXACT}: &quot;MethodHandles inline,</span>
<span class="line-removed">1481      * sized exactly&quot;.&lt;/b&gt;</span>
<span class="line-removed">1482      *</span>
<span class="line-removed">1483      * &lt;p&gt;This strategy replicates what StringBuilders are doing: it builds the</span>
<span class="line-removed">1484      * byte[] array on its own and passes that byte[] array to String</span>
<span class="line-removed">1485      * constructor. This strategy requires access to some private APIs in JDK,</span>
<span class="line-removed">1486      * most notably, the read-only Integer/Long.stringSize methods that measure</span>
<span class="line-removed">1487      * the character length of the integers, and the private String constructor</span>
<span class="line-removed">1488      * that accepts byte[] arrays without copying. While this strategy assumes a</span>
<span class="line-removed">1489      * particular implementation details for String, this opens the door for</span>
<span class="line-removed">1490      * building a very optimal concatenation sequence. This is the only strategy</span>
<span class="line-removed">1491      * that requires porting if there are private JDK changes occur.</span>
<span class="line-removed">1492      */</span>
<span class="line-removed">1493     private static final class MethodHandleInlineCopyStrategy {</span>
<span class="line-removed">1494         private MethodHandleInlineCopyStrategy() {</span>
<span class="line-removed">1495             // no instantiation</span>
1496         }
<a name="45" id="anc45"></a>


1497 
<a name="46" id="anc46"></a><span class="line-modified">1498         static MethodHandle generate(MethodType mt, Recipe recipe) throws Throwable {</span>
<span class="line-modified">1499 </span>
<span class="line-modified">1500             // Fast-path two-argument Object + Object concatenations</span>
<span class="line-removed">1501             if (recipe.getElements().size() == 2) {</span>
<span class="line-removed">1502                 // Two object arguments</span>
<span class="line-removed">1503                 if (mt.parameterCount() == 2 &amp;&amp;</span>
<span class="line-removed">1504                     !mt.parameterType(0).isPrimitive() &amp;&amp;</span>
<span class="line-removed">1505                     !mt.parameterType(1).isPrimitive() &amp;&amp;</span>
<span class="line-removed">1506                     recipe.getElements().get(0).getTag() == TAG_ARG &amp;&amp;</span>
<span class="line-removed">1507                     recipe.getElements().get(1).getTag() == TAG_ARG) {</span>
<span class="line-removed">1508 </span>
<span class="line-removed">1509                     return simpleConcat();</span>
<span class="line-removed">1510 </span>
<span class="line-removed">1511                 } else if (mt.parameterCount() == 1 &amp;&amp;</span>
<span class="line-removed">1512                            !mt.parameterType(0).isPrimitive()) {</span>
<span class="line-removed">1513                     // One Object argument, one constant</span>
<span class="line-removed">1514                     MethodHandle mh = simpleConcat();</span>
<span class="line-removed">1515 </span>
<span class="line-removed">1516                     if (recipe.getElements().get(0).getTag() == TAG_CONST &amp;&amp;</span>
<span class="line-removed">1517                         recipe.getElements().get(1).getTag() == TAG_ARG) {</span>
<span class="line-removed">1518                         // First recipe element is a constant</span>
<span class="line-removed">1519                         return MethodHandles.insertArguments(mh, 0,</span>
<span class="line-removed">1520                                 recipe.getElements().get(0).getValue());</span>
<span class="line-removed">1521 </span>
<span class="line-removed">1522                     } else if (recipe.getElements().get(1).getTag() == TAG_CONST &amp;&amp;</span>
<span class="line-removed">1523                                recipe.getElements().get(0).getTag() == TAG_ARG) {</span>
<span class="line-removed">1524                         // Second recipe element is a constant</span>
<span class="line-removed">1525                         return MethodHandles.insertArguments(mh, 1,</span>
<span class="line-removed">1526                                 recipe.getElements().get(1).getValue());</span>
<span class="line-removed">1527 </span>
<span class="line-removed">1528                     }</span>
<span class="line-removed">1529                 }</span>
<span class="line-removed">1530                 // else... fall-through to slow-path</span>
<span class="line-removed">1531             }</span>
<span class="line-removed">1532 </span>
<span class="line-removed">1533             // Create filters and obtain filtered parameter types. Filters would be used in the beginning</span>
<span class="line-removed">1534             // to convert the incoming arguments into the arguments we can process (e.g. Objects -&gt; Strings).</span>
<span class="line-removed">1535             // The filtered argument type list is used all over in the combinators below.</span>
<span class="line-removed">1536             Class&lt;?&gt;[] ptypes = mt.parameterArray();</span>
<span class="line-removed">1537             MethodHandle[] filters = null;</span>
<span class="line-removed">1538             for (int i = 0; i &lt; ptypes.length; i++) {</span>
<span class="line-removed">1539                 MethodHandle filter = Stringifiers.forMost(ptypes[i]);</span>
<span class="line-removed">1540                 if (filter != null) {</span>
<span class="line-removed">1541                     if (filters == null) {</span>
<span class="line-removed">1542                         filters = new MethodHandle[ptypes.length];</span>
<span class="line-removed">1543                     }</span>
<span class="line-removed">1544                     filters[i] = filter;</span>
<span class="line-removed">1545                     ptypes[i] = filter.type().returnType();</span>
<span class="line-removed">1546                 }</span>
<span class="line-removed">1547             }</span>
<span class="line-removed">1548 </span>
<span class="line-removed">1549             // Start building the combinator tree. The tree &quot;starts&quot; with (&lt;parameters&gt;)String, and &quot;finishes&quot;</span>
<span class="line-removed">1550             // with the (byte[], long)String shape to invoke newString in StringConcatHelper. The combinators are</span>
<span class="line-removed">1551             // assembled bottom-up, which makes the code arguably hard to read.</span>
<span class="line-removed">1552 </span>
<span class="line-removed">1553             // Drop all remaining parameter types, leave only helper arguments:</span>
<span class="line-removed">1554             MethodHandle mh;</span>
<span class="line-removed">1555 </span>
<span class="line-removed">1556             mh = MethodHandles.dropArguments(newString(), 2, ptypes);</span>
<span class="line-removed">1557 </span>
<span class="line-removed">1558             long initialLengthCoder = INITIAL_CODER;</span>
<span class="line-removed">1559 </span>
<span class="line-removed">1560             // Mix in prependers. This happens when (byte[], long) = (storage, indexCoder) is already</span>
<span class="line-removed">1561             // known from the combinators below. We are assembling the string backwards, so the index coded</span>
<span class="line-removed">1562             // into indexCoder is the *ending* index.</span>
<span class="line-removed">1563 </span>
<span class="line-removed">1564             // We need one prepender per argument, but also need to fold in constants. We do so by greedily</span>
<span class="line-removed">1565             // create prependers that fold in surrounding constants into the argument prepender. This reduces</span>
<span class="line-removed">1566             // the number of unique MH combinator tree shapes we&#39;ll create in an application.</span>
<span class="line-removed">1567             String prefixConstant = null, suffixConstant = null;</span>
<span class="line-removed">1568             int pos = -1;</span>
<span class="line-removed">1569             for (RecipeElement el : recipe.getElements()) {</span>
<span class="line-removed">1570                 // Do the prepend, and put &quot;new&quot; index at index 1</span>
<span class="line-removed">1571                 switch (el.getTag()) {</span>
<span class="line-removed">1572                     case TAG_CONST: {</span>
<span class="line-removed">1573                         String constantValue = el.getValue();</span>
<span class="line-removed">1574 </span>
<span class="line-removed">1575                         // Eagerly update the initialLengthCoder value</span>
<span class="line-removed">1576                         initialLengthCoder = (long)mixer(String.class).invoke(initialLengthCoder, constantValue);</span>
<span class="line-removed">1577 </span>
<span class="line-removed">1578                         if (pos &lt; 0) {</span>
<span class="line-removed">1579                             // Collecting into prefixConstant</span>
<span class="line-removed">1580                             prefixConstant = prefixConstant == null ? constantValue : prefixConstant + constantValue;</span>
<span class="line-removed">1581                         } else {</span>
<span class="line-removed">1582                             // Collecting into suffixConstant</span>
<span class="line-removed">1583                             suffixConstant = suffixConstant == null ? constantValue : suffixConstant + constantValue;</span>
<span class="line-removed">1584                         }</span>
<span class="line-removed">1585                         break;</span>
<span class="line-removed">1586                     }</span>
<span class="line-removed">1587                     case TAG_ARG: {</span>
<span class="line-removed">1588 </span>
<span class="line-removed">1589                         if (pos &gt;= 0) {</span>
<span class="line-removed">1590                             // Flush the previous non-constant arg with any prefix/suffix constant</span>
<span class="line-removed">1591                             mh = MethodHandles.filterArgumentsWithCombiner(</span>
<span class="line-removed">1592                                 mh, 1,</span>
<span class="line-removed">1593                                 prepender(prefixConstant, ptypes[pos], suffixConstant),</span>
<span class="line-removed">1594                                 1, 0, // indexCoder, storage</span>
<span class="line-removed">1595                                 2 + pos  // selected argument</span>
<span class="line-removed">1596                             );</span>
<span class="line-removed">1597                             prefixConstant = suffixConstant = null;</span>
<span class="line-removed">1598                         }</span>
<span class="line-removed">1599                         // Mark the pos of next non-constant arg</span>
<span class="line-removed">1600                         pos = el.getArgPos();</span>
<span class="line-removed">1601                         break;</span>
<span class="line-removed">1602                     }</span>
<span class="line-removed">1603                     default:</span>
<span class="line-removed">1604                         throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());</span>
<span class="line-removed">1605                 }</span>
<span class="line-removed">1606             }</span>
<span class="line-removed">1607 </span>
<span class="line-removed">1608             // Insert any trailing args, constants</span>
<span class="line-removed">1609             if (pos &gt;= 0) {</span>
<span class="line-removed">1610                 mh = MethodHandles.filterArgumentsWithCombiner(</span>
<span class="line-removed">1611                     mh, 1,</span>
<span class="line-removed">1612                     prepender(prefixConstant, ptypes[pos], suffixConstant),</span>
<span class="line-removed">1613                     1, 0, // indexCoder, storage</span>
<span class="line-removed">1614                     2 + pos  // selected argument</span>
<span class="line-removed">1615                 );</span>
<span class="line-removed">1616             } else if (prefixConstant != null) {</span>
<span class="line-removed">1617                 assert (suffixConstant == null);</span>
<span class="line-removed">1618                 // Sole prefixConstant can only happen if there were no non-constant arguments</span>
<span class="line-removed">1619                 mh = MethodHandles.filterArgumentsWithCombiner(</span>
<span class="line-removed">1620                     mh, 1,</span>
<span class="line-removed">1621                     MethodHandles.insertArguments(prepender(null, String.class, null), 2, prefixConstant),</span>
<span class="line-removed">1622                     1, 0 // indexCoder, storage</span>
<span class="line-removed">1623                 );</span>
<span class="line-removed">1624             }</span>
<span class="line-removed">1625 </span>
<span class="line-removed">1626             // Fold in byte[] instantiation at argument 0</span>
<span class="line-removed">1627             mh = MethodHandles.foldArgumentsWithCombiner(mh, 0, newArray(),</span>
<span class="line-removed">1628                     1 // index</span>
<span class="line-removed">1629             );</span>
<span class="line-removed">1630 </span>
<span class="line-removed">1631             // Start combining length and coder mixers.</span>
<span class="line-removed">1632             //</span>
<span class="line-removed">1633             // Length is easy: constant lengths can be computed on the spot, and all non-constant</span>
<span class="line-removed">1634             // shapes have been either converted to Strings, or explicit methods for getting the</span>
<span class="line-removed">1635             // string length out of primitives are provided.</span>
<span class="line-removed">1636             //</span>
<span class="line-removed">1637             // Coders are more interesting. Only Object, String and char arguments (and constants)</span>
<span class="line-removed">1638             // can have non-Latin1 encoding. It is easier to blindly convert constants to String,</span>
<span class="line-removed">1639             // and deduce the coder from there. Arguments would be either converted to Strings</span>
<span class="line-removed">1640             // during the initial filtering, or handled by specializations in MIXERS.</span>
<span class="line-removed">1641             //</span>
<span class="line-removed">1642             // The method handle shape before all mixers are combined in is:</span>
<span class="line-removed">1643             //   (long, &lt;args&gt;)String = (&quot;indexCoder&quot;, &lt;args&gt;)</span>
<span class="line-removed">1644             //</span>
<span class="line-removed">1645             // We will bind the initialLengthCoder value to the last mixer (the one that will be</span>
<span class="line-removed">1646             // executed first), then fold that in. This leaves the shape after all mixers are</span>
<span class="line-removed">1647             // combined in as:</span>
<span class="line-removed">1648             //   (&lt;args&gt;)String = (&lt;args&gt;)</span>
<span class="line-removed">1649 </span>
<span class="line-removed">1650             int ac = -1;</span>
<span class="line-removed">1651             MethodHandle mix = null;</span>
<span class="line-removed">1652             for (RecipeElement el : recipe.getElements()) {</span>
<span class="line-removed">1653                 switch (el.getTag()) {</span>
<span class="line-removed">1654                     case TAG_CONST:</span>
<span class="line-removed">1655                         // Constants already handled in the code above</span>
<span class="line-removed">1656                         break;</span>
<span class="line-removed">1657                     case TAG_ARG:</span>
<span class="line-removed">1658                         if (ac &gt;= 0) {</span>
<span class="line-removed">1659                             // Compute new &quot;index&quot; in-place using old value plus the appropriate argument.</span>
<span class="line-removed">1660                             mh = MethodHandles.filterArgumentsWithCombiner(mh, 0, mix,</span>
<span class="line-removed">1661                                     0, // old-index</span>
<span class="line-removed">1662                                     1 + ac // selected argument</span>
<span class="line-removed">1663                             );</span>
<span class="line-removed">1664                         }</span>
<span class="line-removed">1665 </span>
<span class="line-removed">1666                         ac = el.getArgPos();</span>
<span class="line-removed">1667                         Class&lt;?&gt; argClass = ptypes[ac];</span>
<span class="line-removed">1668                         mix = mixer(argClass);</span>
<span class="line-removed">1669 </span>
<span class="line-removed">1670                         break;</span>
<span class="line-removed">1671                     default:</span>
<span class="line-removed">1672                         throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());</span>
<span class="line-removed">1673                 }</span>
<span class="line-removed">1674             }</span>
<span class="line-removed">1675 </span>
<span class="line-removed">1676             // Insert the initialLengthCoder value into the final mixer, then</span>
<span class="line-removed">1677             // fold that into the base method handle</span>
<span class="line-removed">1678             if (ac &gt;= 0) {</span>
<span class="line-removed">1679                 mix = MethodHandles.insertArguments(mix, 0, initialLengthCoder);</span>
<span class="line-removed">1680                 mh = MethodHandles.foldArgumentsWithCombiner(mh, 0, mix,</span>
<span class="line-removed">1681                         1 + ac // selected argument</span>
<span class="line-removed">1682                 );</span>
<span class="line-removed">1683             } else {</span>
<span class="line-removed">1684                 // No mixer (constants only concat), insert initialLengthCoder directly</span>
<span class="line-removed">1685                 mh = MethodHandles.insertArguments(mh, 0, initialLengthCoder);</span>
<span class="line-removed">1686             }</span>
<span class="line-removed">1687 </span>
<span class="line-removed">1688             // The method handle shape here is (&lt;args&gt;).</span>
<span class="line-removed">1689 </span>
<span class="line-removed">1690             // Apply filters, converting the arguments:</span>
<span class="line-removed">1691             if (filters != null) {</span>
<span class="line-removed">1692                 mh = MethodHandles.filterArguments(mh, 0, filters);</span>
<span class="line-removed">1693             }</span>
1694 
<a name="47" id="anc47"></a><span class="line-modified">1695             return mh;</span>






1696         }
<a name="48" id="anc48"></a>
1697 
<a name="49" id="anc49"></a><span class="line-modified">1698         private static MethodHandle prepender(String prefix, Class&lt;?&gt; cl, String suffix) {</span>


1699             return MethodHandles.insertArguments(
<a name="50" id="anc50"></a><span class="line-modified">1700                     MethodHandles.insertArguments(</span>
<span class="line-removed">1701                         PREPENDERS.computeIfAbsent(cl, PREPEND), 2, prefix), 3, suffix);</span>
1702         }
<a name="51" id="anc51"></a>
1703 
<a name="52" id="anc52"></a><span class="line-modified">1704         private static MethodHandle mixer(Class&lt;?&gt; cl) {</span>
<span class="line-modified">1705             return MIXERS.computeIfAbsent(cl, MIX);</span>


1706         }
<a name="53" id="anc53"></a>
1707 
<a name="54" id="anc54"></a><span class="line-modified">1708         // This one is deliberately non-lambdified to optimize startup time:</span>
<span class="line-modified">1709         private static final Function&lt;Class&lt;?&gt;, MethodHandle&gt; PREPEND = new Function&lt;&gt;() {</span>
<span class="line-modified">1710             @Override</span>
<span class="line-modified">1711             public MethodHandle apply(Class&lt;?&gt; c) {</span>
<span class="line-removed">1712                 return JLA.stringConcatHelper(&quot;prepend&quot;,</span>
<span class="line-removed">1713                             methodType(long.class, long.class, byte[].class,</span>
<span class="line-removed">1714                                        String.class, Wrapper.asPrimitiveType(c), String.class));</span>
<span class="line-removed">1715             }</span>
<span class="line-removed">1716         };</span>
<span class="line-removed">1717 </span>
<span class="line-removed">1718         // This one is deliberately non-lambdified to optimize startup time:</span>
<span class="line-removed">1719         private static final Function&lt;Class&lt;?&gt;, MethodHandle&gt; MIX = new Function&lt;&gt;() {</span>
<span class="line-removed">1720             @Override</span>
<span class="line-removed">1721             public MethodHandle apply(Class&lt;?&gt; c) {</span>
<span class="line-removed">1722                 return JLA.stringConcatHelper(&quot;mix&quot;, methodType(long.class, long.class, Wrapper.asPrimitiveType(c)));</span>
<span class="line-removed">1723             }</span>
<span class="line-removed">1724         };</span>
<span class="line-removed">1725 </span>
<span class="line-removed">1726         private @Stable static MethodHandle SIMPLE_CONCAT;</span>
<span class="line-removed">1727         private static MethodHandle simpleConcat() {</span>
<span class="line-removed">1728             if (SIMPLE_CONCAT == null) {</span>
<span class="line-removed">1729                 SIMPLE_CONCAT = JLA.stringConcatHelper(&quot;simpleConcat&quot;, methodType(String.class, Object.class, Object.class));</span>
<span class="line-removed">1730             }</span>
<span class="line-removed">1731             return SIMPLE_CONCAT;</span>
1732         }
<a name="55" id="anc55"></a>

1733 
<a name="56" id="anc56"></a><span class="line-modified">1734         private @Stable static MethodHandle NEW_STRING;</span>
<span class="line-modified">1735         private static MethodHandle newString() {</span>
<span class="line-modified">1736             MethodHandle mh = NEW_STRING;</span>
<span class="line-modified">1737             if (mh == null) {</span>
<span class="line-modified">1738                 NEW_STRING = mh =</span>
1739                     JLA.stringConcatHelper(&quot;newString&quot;, methodType(String.class, byte[].class, long.class));
<a name="57" id="anc57"></a><span class="line-removed">1740             }</span>
<span class="line-removed">1741             return mh;</span>
<span class="line-removed">1742         }</span>
<span class="line-removed">1743         private @Stable static MethodHandle NEW_ARRAY;</span>
<span class="line-removed">1744         private static MethodHandle newArray() {</span>
<span class="line-removed">1745             MethodHandle mh = NEW_ARRAY;</span>
<span class="line-removed">1746             if (mh == null) {</span>
<span class="line-removed">1747                 NEW_ARRAY = mh =</span>
<span class="line-removed">1748                     JLA.stringConcatHelper(&quot;newArray&quot;, methodType(byte[].class, long.class));</span>
<span class="line-removed">1749             }</span>
<span class="line-removed">1750             return mh;</span>
1751         }
<a name="58" id="anc58"></a>

1752 
<a name="59" id="anc59"></a><span class="line-modified">1753         private static final ConcurrentMap&lt;Class&lt;?&gt;, MethodHandle&gt; PREPENDERS;</span>
<span class="line-modified">1754         private static final ConcurrentMap&lt;Class&lt;?&gt;, MethodHandle&gt; MIXERS;</span>
<span class="line-modified">1755         private static final long INITIAL_CODER;</span>







1756 
<a name="60" id="anc60"></a><span class="line-modified">1757         static {</span>
<span class="line-modified">1758             INITIAL_CODER = JLA.stringConcatInitialCoder();</span>
<span class="line-modified">1759             PREPENDERS = new ConcurrentHashMap&lt;&gt;();</span>
<span class="line-modified">1760             MIXERS = new ConcurrentHashMap&lt;&gt;();</span>


1761         }
<a name="61" id="anc61"></a>
1762     }
1763 
1764     /**
<a name="62" id="anc62"></a><span class="line-modified">1765      * Public gateways to public &quot;stringify&quot; methods. These methods have the form String apply(T obj), and normally</span>
<span class="line-modified">1766      * delegate to {@code String.valueOf}, depending on argument&#39;s type.</span>

1767      */
<a name="63" id="anc63"></a><span class="line-modified">1768     private static final class Stringifiers {</span>
<span class="line-modified">1769         private Stringifiers() {</span>
<span class="line-modified">1770             // no instantiation</span>
<span class="line-modified">1771         }</span>
<span class="line-modified">1772 </span>
<span class="line-modified">1773         private static final MethodHandle OBJECT_INSTANCE =</span>
<span class="line-modified">1774                 JLA.stringConcatHelper(&quot;stringOf&quot;, methodType(String.class, Object.class));</span>
<span class="line-modified">1775 </span>
<span class="line-modified">1776         private static class FloatStringifiers {</span>
<span class="line-modified">1777             private static final MethodHandle FLOAT_INSTANCE =</span>




1778                     lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, float.class);
<a name="64" id="anc64"></a><span class="line-removed">1779 </span>
<span class="line-removed">1780             private static final MethodHandle DOUBLE_INSTANCE =</span>
<span class="line-removed">1781                     lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, double.class);</span>
1782         }
<a name="65" id="anc65"></a><span class="line-modified">1783 </span>
<span class="line-modified">1784         private static class StringifierAny extends ClassValue&lt;MethodHandle&gt; {</span>
<span class="line-modified">1785 </span>
<span class="line-modified">1786             private static final ClassValue&lt;MethodHandle&gt; INSTANCE = new StringifierAny();</span>
<span class="line-modified">1787 </span>
<span class="line-modified">1788             @Override</span>
<span class="line-modified">1789             protected MethodHandle computeValue(Class&lt;?&gt; cl) {</span>
<span class="line-modified">1790                 if (cl == byte.class || cl == short.class || cl == int.class) {</span>
<span class="line-removed">1791                     return lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, int.class);</span>
<span class="line-removed">1792                 } else if (cl == boolean.class) {</span>
<span class="line-removed">1793                     return lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, boolean.class);</span>
<span class="line-removed">1794                 } else if (cl == char.class) {</span>
<span class="line-removed">1795                     return lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, char.class);</span>
<span class="line-removed">1796                 } else if (cl == long.class) {</span>
<span class="line-removed">1797                     return lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, long.class);</span>
<span class="line-removed">1798                 } else {</span>
<span class="line-removed">1799                     MethodHandle mh = forMost(cl);</span>
<span class="line-removed">1800                     if (mh != null) {</span>
<span class="line-removed">1801                         return mh;</span>
<span class="line-removed">1802                     } else {</span>
<span class="line-removed">1803                         throw new IllegalStateException(&quot;Unknown class: &quot; + cl);</span>
<span class="line-removed">1804                     }</span>
<span class="line-removed">1805                 }</span>
<span class="line-removed">1806             }</span>
<span class="line-removed">1807         }</span>
<span class="line-removed">1808 </span>
<span class="line-removed">1809         /**</span>
<span class="line-removed">1810          * Returns a stringifier for references and floats/doubles only.</span>
<span class="line-removed">1811          * Always returns null for other primitives.</span>
<span class="line-removed">1812          *</span>
<span class="line-removed">1813          * @param t class to stringify</span>
<span class="line-removed">1814          * @return stringifier; null, if not available</span>
<span class="line-removed">1815          */</span>
<span class="line-removed">1816         static MethodHandle forMost(Class&lt;?&gt; t) {</span>
<span class="line-removed">1817             if (!t.isPrimitive()) {</span>
<span class="line-removed">1818                 return OBJECT_INSTANCE;</span>
<span class="line-removed">1819             } else if (t == float.class) {</span>
<span class="line-removed">1820                 return FloatStringifiers.FLOAT_INSTANCE;</span>
<span class="line-removed">1821             } else if (t == double.class) {</span>
<span class="line-removed">1822                 return FloatStringifiers.DOUBLE_INSTANCE;</span>
<span class="line-removed">1823             }</span>
<span class="line-removed">1824             return null;</span>
<span class="line-removed">1825         }</span>
<span class="line-removed">1826 </span>
<span class="line-removed">1827         /**</span>
<span class="line-removed">1828          * Returns a stringifier for any type. Never returns null.</span>
<span class="line-removed">1829          *</span>
<span class="line-removed">1830          * @param t class to stringify</span>
<span class="line-removed">1831          * @return stringifier</span>
<span class="line-removed">1832          */</span>
<span class="line-removed">1833         static MethodHandle forAny(Class&lt;?&gt; t) {</span>
<span class="line-removed">1834             return StringifierAny.INSTANCE.get(t);</span>
1835         }
<a name="66" id="anc66"></a>
1836     }
1837 
<a name="67" id="anc67"></a><span class="line-modified">1838     /* ------------------------------- Common utilities ------------------------------------ */</span>



1839 
<a name="68" id="anc68"></a><span class="line-modified">1840     static MethodHandle lookupStatic(Lookup lookup, Class&lt;?&gt; refc, String name, Class&lt;?&gt; rtype, Class&lt;?&gt;... ptypes) {</span>
<span class="line-modified">1841         try {</span>
<span class="line-modified">1842             return lookup.findStatic(refc, name, MethodType.methodType(rtype, ptypes));</span>
<span class="line-modified">1843         } catch (NoSuchMethodException | IllegalAccessException e) {</span>
<span class="line-modified">1844             throw new AssertionError(e);</span>
<span class="line-removed">1845         }</span>
1846     }
1847 
<a name="69" id="anc69"></a><span class="line-modified">1848     static MethodHandle lookupVirtual(Lookup lookup, Class&lt;?&gt; refc, String name, Class&lt;?&gt; rtype, Class&lt;?&gt;... ptypes) {</span>
<span class="line-modified">1849         try {</span>
<span class="line-modified">1850             return lookup.findVirtual(refc, name, MethodType.methodType(rtype, ptypes));</span>
<span class="line-modified">1851         } catch (NoSuchMethodException | IllegalAccessException e) {</span>
<span class="line-modified">1852             throw new AssertionError(e);</span>
<span class="line-modified">1853         }</span>










1854     }
1855 
<a name="70" id="anc70"></a><span class="line-modified">1856     static MethodHandle lookupConstructor(Lookup lookup, Class&lt;?&gt; refc, Class&lt;?&gt; ptypes) {</span>

1857         try {
<a name="71" id="anc71"></a><span class="line-modified">1858             return lookup.findConstructor(refc, MethodType.methodType(void.class, ptypes));</span>
1859         } catch (NoSuchMethodException | IllegalAccessException e) {
1860             throw new AssertionError(e);
1861         }
1862     }
1863 
<a name="72" id="anc72"></a><span class="line-removed">1864     static int estimateSize(Class&lt;?&gt; cl) {</span>
<span class="line-removed">1865         if (cl == Integer.TYPE) {</span>
<span class="line-removed">1866             return 11; // &quot;-2147483648&quot;</span>
<span class="line-removed">1867         } else if (cl == Boolean.TYPE) {</span>
<span class="line-removed">1868             return 5; // &quot;false&quot;</span>
<span class="line-removed">1869         } else if (cl == Byte.TYPE) {</span>
<span class="line-removed">1870             return 4; // &quot;-128&quot;</span>
<span class="line-removed">1871         } else if (cl == Character.TYPE) {</span>
<span class="line-removed">1872             return 1; // duh</span>
<span class="line-removed">1873         } else if (cl == Short.TYPE) {</span>
<span class="line-removed">1874             return 6; // &quot;-32768&quot;</span>
<span class="line-removed">1875         } else if (cl == Double.TYPE) {</span>
<span class="line-removed">1876             return 26; // apparently, no larger than this, see FloatingDecimal.BinaryToASCIIBuffer.buffer</span>
<span class="line-removed">1877         } else if (cl == Float.TYPE) {</span>
<span class="line-removed">1878             return 26; // apparently, no larger than this, see FloatingDecimal.BinaryToASCIIBuffer.buffer</span>
<span class="line-removed">1879         } else if (cl == Long.TYPE)  {</span>
<span class="line-removed">1880             return 20; // &quot;-9223372036854775808&quot;</span>
<span class="line-removed">1881         } else {</span>
<span class="line-removed">1882             throw new IllegalArgumentException(&quot;Cannot estimate the size for &quot; + cl);</span>
<span class="line-removed">1883         }</span>
<span class="line-removed">1884     }</span>
<span class="line-removed">1885 </span>
<span class="line-removed">1886     static Class&lt;?&gt; adaptToStringBuilder(Class&lt;?&gt; c) {</span>
<span class="line-removed">1887         if (c.isPrimitive()) {</span>
<span class="line-removed">1888             if (c == Byte.TYPE || c == Short.TYPE) {</span>
<span class="line-removed">1889                 return int.class;</span>
<span class="line-removed">1890             }</span>
<span class="line-removed">1891         } else {</span>
<span class="line-removed">1892             if (c != String.class) {</span>
<span class="line-removed">1893                 return Object.class;</span>
<span class="line-removed">1894             }</span>
<span class="line-removed">1895         }</span>
<span class="line-removed">1896         return c;</span>
<span class="line-removed">1897     }</span>
<span class="line-removed">1898 </span>
1899     private StringConcatFactory() {
1900         // no instantiation
1901     }
<a name="73" id="anc73"></a><span class="line-removed">1902 </span>
1903 }
<a name="74" id="anc74"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="74" type="hidden" />
</body>
</html>
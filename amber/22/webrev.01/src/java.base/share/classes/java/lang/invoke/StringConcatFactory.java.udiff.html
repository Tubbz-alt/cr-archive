<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.base/share/classes/java/lang/invoke/StringConcatFactory.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MethodHandles.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="VarForm.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/StringConcatFactory.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -25,16 +25,10 @@</span>
  
  package java.lang.invoke;
  
  import jdk.internal.access.JavaLangAccess;
  import jdk.internal.access.SharedSecrets;
<span class="udiff-line-removed">- import jdk.internal.misc.Unsafe;</span>
<span class="udiff-line-removed">- import jdk.internal.misc.VM;</span>
<span class="udiff-line-removed">- import jdk.internal.org.objectweb.asm.ClassWriter;</span>
<span class="udiff-line-removed">- import jdk.internal.org.objectweb.asm.Label;</span>
<span class="udiff-line-removed">- import jdk.internal.org.objectweb.asm.MethodVisitor;</span>
<span class="udiff-line-removed">- import jdk.internal.org.objectweb.asm.Opcodes;</span>
  import jdk.internal.vm.annotation.Stable;
  import sun.invoke.util.Wrapper;
  
  import java.lang.invoke.MethodHandles.Lookup;
  import java.util.ArrayList;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -43,14 +37,11 @@</span>
  import java.util.Objects;
  import java.util.concurrent.ConcurrentHashMap;
  import java.util.concurrent.ConcurrentMap;
  import java.util.function.Function;
  
<span class="udiff-line-removed">- import static java.lang.invoke.MethodHandles.lookup;</span>
  import static java.lang.invoke.MethodType.methodType;
<span class="udiff-line-removed">- import static java.lang.invoke.MethodHandles.Lookup.ClassOption.*;</span>
<span class="udiff-line-removed">- import static jdk.internal.org.objectweb.asm.Opcodes.*;</span>
  
  /**
   * &lt;p&gt;Methods to facilitate the creation of String concatenation methods, that
   * can be used to efficiently concatenate a known number of arguments of known
   * types, possibly after type adaptation and partial evaluation of arguments.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -126,116 +117,12 @@</span>
       * we do not use all those slots, to let the strategies with MethodHandle
       * combinators to use some arguments.
       */
      private static final int MAX_INDY_CONCAT_ARG_SLOTS = 200;
  
<span class="udiff-line-removed">-     /**</span>
<span class="udiff-line-removed">-      * Concatenation strategy to use. See {@link Strategy} for possible options.</span>
<span class="udiff-line-removed">-      * This option is controllable with -Djava.lang.invoke.stringConcat JDK option.</span>
<span class="udiff-line-removed">-      *</span>
<span class="udiff-line-removed">-      * Defaults to MH_INLINE_SIZED_EXACT if not set.</span>
<span class="udiff-line-removed">-      */</span>
<span class="udiff-line-removed">-     private static final Strategy STRATEGY;</span>
<span class="udiff-line-removed">- </span>
      private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
  
<span class="udiff-line-removed">-     private enum Strategy {</span>
<span class="udiff-line-removed">-         /**</span>
<span class="udiff-line-removed">-          * Bytecode generator, calling into {@link java.lang.StringBuilder}.</span>
<span class="udiff-line-removed">-          */</span>
<span class="udiff-line-removed">-         BC_SB,</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         /**</span>
<span class="udiff-line-removed">-          * Bytecode generator, calling into {@link java.lang.StringBuilder};</span>
<span class="udiff-line-removed">-          * but trying to estimate the required storage.</span>
<span class="udiff-line-removed">-          */</span>
<span class="udiff-line-removed">-         BC_SB_SIZED,</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         /**</span>
<span class="udiff-line-removed">-          * Bytecode generator, calling into {@link java.lang.StringBuilder};</span>
<span class="udiff-line-removed">-          * but computing the required storage exactly.</span>
<span class="udiff-line-removed">-          */</span>
<span class="udiff-line-removed">-         BC_SB_SIZED_EXACT,</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         /**</span>
<span class="udiff-line-removed">-          * MethodHandle-based generator, that in the end calls into {@link java.lang.StringBuilder}.</span>
<span class="udiff-line-removed">-          * This strategy also tries to estimate the required storage.</span>
<span class="udiff-line-removed">-          */</span>
<span class="udiff-line-removed">-         MH_SB_SIZED,</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         /**</span>
<span class="udiff-line-removed">-          * MethodHandle-based generator, that in the end calls into {@link java.lang.StringBuilder}.</span>
<span class="udiff-line-removed">-          * This strategy also estimate the required storage exactly.</span>
<span class="udiff-line-removed">-          */</span>
<span class="udiff-line-removed">-         MH_SB_SIZED_EXACT,</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         /**</span>
<span class="udiff-line-removed">-          * MethodHandle-based generator, that constructs its own byte[] array from</span>
<span class="udiff-line-removed">-          * the arguments. It computes the required storage exactly.</span>
<span class="udiff-line-removed">-          */</span>
<span class="udiff-line-removed">-         MH_INLINE_SIZED_EXACT</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     /**</span>
<span class="udiff-line-removed">-      * Enables debugging: this may print debugging messages, perform additional (non-neutral for performance)</span>
<span class="udiff-line-removed">-      * checks, etc.</span>
<span class="udiff-line-removed">-      */</span>
<span class="udiff-line-removed">-     private static final boolean DEBUG;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     static {</span>
<span class="udiff-line-removed">-         final String strategy =</span>
<span class="udiff-line-removed">-                 VM.getSavedProperty(&quot;java.lang.invoke.stringConcat&quot;);</span>
<span class="udiff-line-removed">-         STRATEGY = (strategy == null) ? null : Strategy.valueOf(strategy);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         if (STRATEGY == null || STRATEGY == Strategy.MH_INLINE_SIZED_EXACT) {</span>
<span class="udiff-line-removed">-             // Force initialization of default strategy:</span>
<span class="udiff-line-removed">-             Unsafe.getUnsafe().ensureClassInitialized(MethodHandleInlineCopyStrategy.class);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         DEBUG = Boolean.parseBoolean(</span>
<span class="udiff-line-removed">-                 VM.getSavedProperty(&quot;java.lang.invoke.stringConcat.debug&quot;));</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     /**</span>
<span class="udiff-line-removed">-      * Cache key is a composite of:</span>
<span class="udiff-line-removed">-      *   - class name, that lets to disambiguate stubs, to avoid excess sharing</span>
<span class="udiff-line-removed">-      *   - method type, describing the dynamic arguments for concatenation</span>
<span class="udiff-line-removed">-      *   - concat recipe, describing the constants and concat shape</span>
<span class="udiff-line-removed">-      */</span>
<span class="udiff-line-removed">-     private static final class Key {</span>
<span class="udiff-line-removed">-         final String className;</span>
<span class="udiff-line-removed">-         final MethodType mt;</span>
<span class="udiff-line-removed">-         final Recipe recipe;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         public Key(String className, MethodType mt, Recipe recipe) {</span>
<span class="udiff-line-removed">-             this.className = className;</span>
<span class="udiff-line-removed">-             this.mt = mt;</span>
<span class="udiff-line-removed">-             this.recipe = recipe;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         @Override</span>
<span class="udiff-line-removed">-         public boolean equals(Object o) {</span>
<span class="udiff-line-removed">-             if (this == o) return true;</span>
<span class="udiff-line-removed">-             if (o == null || getClass() != o.getClass()) return false;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             Key key = (Key) o;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             if (!className.equals(key.className)) return false;</span>
<span class="udiff-line-removed">-             if (!mt.equals(key.mt)) return false;</span>
<span class="udiff-line-removed">-             if (!recipe.equals(key.recipe)) return false;</span>
<span class="udiff-line-removed">-             return true;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         @Override</span>
<span class="udiff-line-removed">-         public int hashCode() {</span>
<span class="udiff-line-removed">-             int result = className.hashCode();</span>
<span class="udiff-line-removed">-             result = 31 * result + mt.hashCode();</span>
<span class="udiff-line-removed">-             result = 31 * result + recipe.hashCode();</span>
<span class="udiff-line-removed">-             return result;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
      /**
       * Parses the recipe string, and produces a traversable collection of
       * {@link java.lang.invoke.StringConcatFactory.RecipeElement}-s for generator
       * strategies. Notably, this class parses out the constants from the recipe
       * and from other static arguments.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -443,14 +330,10 @@</span>
       * @jls 15.18.1 String Concatenation Operator +
       */
      public static CallSite makeConcat(MethodHandles.Lookup lookup,
                                        String name,
                                        MethodType concatType) throws StringConcatException {
<span class="udiff-line-removed">-         if (DEBUG) {</span>
<span class="udiff-line-removed">-             System.out.println(&quot;StringConcatFactory &quot; + STRATEGY + &quot; is here for &quot; + concatType);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
          return doStringConcat(lookup, name, concatType, true, null);
      }
  
      /**
       * Facilitates the creation of optimized String concatenation methods, that
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -566,14 +449,10 @@</span>
      public static CallSite makeConcatWithConstants(MethodHandles.Lookup lookup,
                                                     String name,
                                                     MethodType concatType,
                                                     String recipe,
                                                     Object... constants) throws StringConcatException {
<span class="udiff-line-removed">-         if (DEBUG) {</span>
<span class="udiff-line-removed">-             System.out.println(&quot;StringConcatFactory &quot; + STRATEGY + &quot; is here for &quot; + concatType + &quot;, {&quot; + recipe + &quot;}, &quot; + Arrays.toString(constants));</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
          return doStringConcat(lookup, name, concatType, false, recipe, constants);
      }
  
      private static CallSite doStringConcat(MethodHandles.Lookup lookup,
                                             String name,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -641,1263 +520,369 @@</span>
                      concatType.parameterSlotCount() +
                      &quot;, can only accept &quot; +
                      MAX_INDY_CONCAT_ARG_SLOTS);
          }
  
<span class="udiff-line-removed">-         MethodType mt = adaptType(concatType);</span>
          Recipe rec = new Recipe(recipe, constants);
<span class="udiff-line-modified-removed">-         MethodHandle mh = generate(lookup, mt, rec);</span>
<span class="udiff-line-modified-added">+         MethodHandle mh = generate(lookup, concatType, rec);</span>
          return new ConstantCallSite(mh.asType(concatType));
      }
  
<span class="udiff-line-removed">-     /**</span>
<span class="udiff-line-removed">-      * Adapt method type to an API we are going to use.</span>
<span class="udiff-line-removed">-      *</span>
<span class="udiff-line-removed">-      * This strips the concrete classes from the signatures, thus preventing</span>
<span class="udiff-line-removed">-      * class leakage when we cache the concatenation stubs.</span>
<span class="udiff-line-removed">-      *</span>
<span class="udiff-line-removed">-      * @param args actual argument types</span>
<span class="udiff-line-removed">-      * @return argument types the strategy is going to use</span>
<span class="udiff-line-removed">-      */</span>
<span class="udiff-line-removed">-     private static MethodType adaptType(MethodType args) {</span>
<span class="udiff-line-removed">-         Class&lt;?&gt;[] ptypes = null;</span>
<span class="udiff-line-removed">-         for (int i = 0; i &lt; args.parameterCount(); i++) {</span>
<span class="udiff-line-removed">-             Class&lt;?&gt; ptype = args.parameterType(i);</span>
<span class="udiff-line-removed">-             if (!ptype.isPrimitive() &amp;&amp;</span>
<span class="udiff-line-removed">-                     ptype != String.class &amp;&amp;</span>
<span class="udiff-line-removed">-                     ptype != Object.class) { // truncate to Object</span>
<span class="udiff-line-removed">-                 if (ptypes == null) {</span>
<span class="udiff-line-removed">-                     ptypes = args.parameterArray();</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-                 ptypes[i] = Object.class;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             // else other primitives or String or Object (unchanged)</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         return (ptypes != null)</span>
<span class="udiff-line-removed">-                 ? MethodType.methodType(args.returnType(), ptypes)</span>
<span class="udiff-line-removed">-                 : args;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
      private static MethodHandle generate(Lookup lookup, MethodType mt, Recipe recipe) throws StringConcatException {
          try {
<span class="udiff-line-modified-removed">-             if (STRATEGY == null) {</span>
<span class="udiff-line-removed">-                 return MethodHandleInlineCopyStrategy.generate(mt, recipe);</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             switch (STRATEGY) {</span>
<span class="udiff-line-removed">-                 case BC_SB:</span>
<span class="udiff-line-removed">-                     return BytecodeStringBuilderStrategy.generate(lookup, mt, recipe, Mode.DEFAULT);</span>
<span class="udiff-line-removed">-                 case BC_SB_SIZED:</span>
<span class="udiff-line-removed">-                     return BytecodeStringBuilderStrategy.generate(lookup, mt, recipe, Mode.SIZED);</span>
<span class="udiff-line-removed">-                 case BC_SB_SIZED_EXACT:</span>
<span class="udiff-line-removed">-                     return BytecodeStringBuilderStrategy.generate(lookup, mt, recipe, Mode.SIZED_EXACT);</span>
<span class="udiff-line-removed">-                 case MH_SB_SIZED:</span>
<span class="udiff-line-removed">-                     return MethodHandleStringBuilderStrategy.generate(mt, recipe, Mode.SIZED);</span>
<span class="udiff-line-removed">-                 case MH_SB_SIZED_EXACT:</span>
<span class="udiff-line-removed">-                     return MethodHandleStringBuilderStrategy.generate(mt, recipe, Mode.SIZED_EXACT);</span>
<span class="udiff-line-removed">-                 case MH_INLINE_SIZED_EXACT:</span>
<span class="udiff-line-removed">-                     return MethodHandleInlineCopyStrategy.generate(mt, recipe);</span>
<span class="udiff-line-removed">-                 default:</span>
<span class="udiff-line-removed">-                     throw new StringConcatException(&quot;Concatenation strategy &quot; + STRATEGY + &quot; is not implemented&quot;);</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-modified-added">+             return generateMHInlineCopy(mt, recipe);</span>
          } catch (Error | StringConcatException e) {
              // Pass through any error or existing StringConcatException
              throw e;
          } catch (Throwable t) {
              throw new StringConcatException(&quot;Generator failed&quot;, t);
          }
      }
  
<span class="udiff-line-removed">-     private enum Mode {</span>
<span class="udiff-line-removed">-         DEFAULT(false, false),</span>
<span class="udiff-line-removed">-         SIZED(true, false),</span>
<span class="udiff-line-removed">-         SIZED_EXACT(true, true);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         private final boolean sized;</span>
<span class="udiff-line-removed">-         private final boolean exact;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         Mode(boolean sized, boolean exact) {</span>
<span class="udiff-line-removed">-             this.sized = sized;</span>
<span class="udiff-line-removed">-             this.exact = exact;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         boolean isSized() {</span>
<span class="udiff-line-removed">-             return sized;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         boolean isExact() {</span>
<span class="udiff-line-removed">-             return exact;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-     }</span>
  
      /**
<span class="udiff-line-modified-removed">-      * Bytecode StringBuilder strategy.</span>
<span class="udiff-line-modified-removed">-      *</span>
<span class="udiff-line-modified-removed">-      * &lt;p&gt;This strategy operates in three modes, gated by {@link Mode}.</span>
<span class="udiff-line-modified-removed">-      *</span>
<span class="udiff-line-modified-removed">-      * &lt;p&gt;&lt;b&gt;{@link Strategy#BC_SB}: &quot;bytecode StringBuilder&quot;.&lt;/b&gt;</span>
<span class="udiff-line-removed">-      *</span>
<span class="udiff-line-removed">-      * &lt;p&gt;This strategy spins up the bytecode that has the same StringBuilder</span>
<span class="udiff-line-removed">-      * chain javac would otherwise emit. This strategy uses only the public API,</span>
<span class="udiff-line-removed">-      * and comes as the baseline for the current JDK behavior. On other words,</span>
<span class="udiff-line-removed">-      * this strategy moves the javac generated bytecode to runtime. The</span>
<span class="udiff-line-removed">-      * generated bytecode is loaded via Lookup::defineClass, but with</span>
<span class="udiff-line-removed">-      * the caller class coming from the BSM -- in other words, the protection</span>
<span class="udiff-line-removed">-      * guarantees are inherited from the method where invokedynamic was</span>
<span class="udiff-line-removed">-      * originally called. This means, among other things, that the bytecode is</span>
<span class="udiff-line-removed">-      * verified for all non-JDK uses.</span>
<span class="udiff-line-removed">-      *</span>
<span class="udiff-line-removed">-      * &lt;p&gt;&lt;b&gt;{@link Strategy#BC_SB_SIZED}: &quot;bytecode StringBuilder, but</span>
<span class="udiff-line-removed">-      * sized&quot;.&lt;/b&gt;</span>
<span class="udiff-line-removed">-      *</span>
<span class="udiff-line-removed">-      * &lt;p&gt;This strategy acts similarly to {@link Strategy#BC_SB}, but it also</span>
<span class="udiff-line-removed">-      * tries to guess the capacity required for StringBuilder to accept all</span>
<span class="udiff-line-removed">-      * arguments without resizing. This strategy only makes an educated guess:</span>
<span class="udiff-line-removed">-      * it only guesses the space required for known types (e.g. primitives and</span>
<span class="udiff-line-removed">-      * Strings), but does not otherwise convert arguments. Therefore, the</span>
<span class="udiff-line-removed">-      * capacity estimate may be wrong, and StringBuilder may have to</span>
<span class="udiff-line-removed">-      * transparently resize or trim when doing the actual concatenation. While</span>
<span class="udiff-line-removed">-      * this does not constitute a correctness issue (in the end, that what BC_SB</span>
<span class="udiff-line-removed">-      * has to do anyway), this does pose a potential performance problem.</span>
<span class="udiff-line-removed">-      *</span>
<span class="udiff-line-removed">-      * &lt;p&gt;&lt;b&gt;{@link Strategy#BC_SB_SIZED_EXACT}: &quot;bytecode StringBuilder, but</span>
<span class="udiff-line-removed">-      * sized exactly&quot;.&lt;/b&gt;</span>
<span class="udiff-line-removed">-      *</span>
<span class="udiff-line-removed">-      * &lt;p&gt;This strategy improves on @link Strategy#BC_SB_SIZED}, by first</span>
<span class="udiff-line-removed">-      * converting all arguments to String in order to get the exact capacity</span>
<span class="udiff-line-removed">-      * StringBuilder should have. The conversion is done via the public</span>
<span class="udiff-line-removed">-      * String.valueOf and/or Object.toString methods, and does not touch any</span>
<span class="udiff-line-removed">-      * private String API.</span>
<span class="udiff-line-modified-added">+      * &lt;p&gt;This strategy replicates what StringBuilders are doing: it builds the</span>
<span class="udiff-line-modified-added">+      * byte[] array on its own and passes that byte[] array to String</span>
<span class="udiff-line-modified-added">+      * constructor. This strategy requires access to some private APIs in JDK,</span>
<span class="udiff-line-modified-added">+      * most notably, the private String constructor that accepts byte[] arrays</span>
<span class="udiff-line-modified-added">+      * without copying.</span>
       */
<span class="udiff-line-modified-removed">-     private static final class BytecodeStringBuilderStrategy {</span>
<span class="udiff-line-removed">-         static final int CLASSFILE_VERSION = 52;</span>
<span class="udiff-line-removed">-         static final String METHOD_NAME = &quot;concat&quot;;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         private static final ConcurrentMap&lt;Key, MethodHandle&gt; CACHE;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         /**</span>
<span class="udiff-line-removed">-          * Enables caching of strategy stubs. This may improve the linkage time by reusing the generated</span>
<span class="udiff-line-removed">-          * code, at the expense of contaminating the profiles.</span>
<span class="udiff-line-removed">-          */</span>
<span class="udiff-line-removed">-         private static final boolean CACHE_ENABLE;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         /**</span>
<span class="udiff-line-removed">-          * Dump generated classes to disk, for debugging purposes.</span>
<span class="udiff-line-removed">-          */</span>
<span class="udiff-line-removed">-         private static final ProxyClassesDumper DUMPER;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         static {</span>
<span class="udiff-line-removed">-             CACHE_ENABLE = Boolean.parseBoolean(</span>
<span class="udiff-line-removed">-                     VM.getSavedProperty(&quot;java.lang.invoke.stringConcat.cache&quot;));</span>
<span class="udiff-line-removed">-             CACHE = CACHE_ENABLE ? new ConcurrentHashMap&lt;&gt;() : null;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             final String dumpPath =</span>
<span class="udiff-line-removed">-                     VM.getSavedProperty(&quot;java.lang.invoke.stringConcat.dumpClasses&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             DUMPER = (dumpPath == null) ? null : ProxyClassesDumper.getInstance(dumpPath);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-modified-added">+     private static MethodHandle generateMHInlineCopy(MethodType mt, Recipe recipe) throws Throwable {</span>
  
<span class="udiff-line-modified-removed">-         private BytecodeStringBuilderStrategy() {</span>
<span class="udiff-line-modified-removed">-             // no instantiation</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-         private static MethodHandle generate(Lookup lookup, MethodType args, Recipe recipe, Mode mode) throws Exception {</span>
<span class="udiff-line-modified-removed">-             String className = getClassName(lookup.lookupClass());</span>
<span class="udiff-line-modified-removed">-             Key key = null;</span>
<span class="udiff-line-modified-removed">-             if (CACHE_ENABLE) {</span>
<span class="udiff-line-removed">-                 key = new Key(className, args, recipe);</span>
<span class="udiff-line-removed">-                 MethodHandle mh = CACHE.get(key);</span>
<span class="udiff-line-removed">-                 if (mh != null) {</span>
<span class="udiff-line-removed">-                     return mh;</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS + ClassWriter.COMPUTE_FRAMES);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             cw.visit(CLASSFILE_VERSION,</span>
<span class="udiff-line-removed">-                     ACC_SUPER + ACC_PUBLIC + ACC_FINAL + ACC_SYNTHETIC,</span>
<span class="udiff-line-removed">-                     className,</span>
<span class="udiff-line-removed">-                     null,</span>
<span class="udiff-line-removed">-                     &quot;java/lang/Object&quot;,</span>
<span class="udiff-line-removed">-                     null</span>
<span class="udiff-line-removed">-             );</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             MethodVisitor mv = cw.visitMethod(</span>
<span class="udiff-line-removed">-                     ACC_PUBLIC + ACC_STATIC + ACC_FINAL,</span>
<span class="udiff-line-removed">-                     METHOD_NAME,</span>
<span class="udiff-line-removed">-                     args.toMethodDescriptorString(),</span>
<span class="udiff-line-removed">-                     null,</span>
<span class="udiff-line-removed">-                     null);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             // use of @ForceInline no longer has any effect</span>
<span class="udiff-line-removed">-             mv.visitAnnotation(&quot;Ljdk/internal/vm/annotation/ForceInline;&quot;, true);</span>
<span class="udiff-line-removed">-             mv.visitCode();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             Class&lt;?&gt;[] arr = args.parameterArray();</span>
<span class="udiff-line-removed">-             boolean[] guaranteedNonNull = new boolean[arr.length];</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             if (mode.isExact()) {</span>
<span class="udiff-line-removed">-                 /*</span>
<span class="udiff-line-removed">-                     In exact mode, we need to convert all arguments to their String representations,</span>
<span class="udiff-line-removed">-                     as this allows to compute their String sizes exactly. We cannot use private</span>
<span class="udiff-line-removed">-                     methods for primitives in here, therefore we need to convert those as well.</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                     We also record what arguments are guaranteed to be non-null as the result</span>
<span class="udiff-line-removed">-                     of the conversion. String.valueOf does the null checks for us. The only</span>
<span class="udiff-line-removed">-                     corner case to take care of is String.valueOf(Object) returning null itself.</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                     Also, if any conversion happened, then the slot indices in the incoming</span>
<span class="udiff-line-removed">-                     arguments are not equal to the final local maps. The only case this may break</span>
<span class="udiff-line-removed">-                     is when converting 2-slot long/double argument to 1-slot String. Therefore,</span>
<span class="udiff-line-removed">-                     we get away with tracking modified offset, since no conversion can overwrite</span>
<span class="udiff-line-removed">-                     the upcoming the argument.</span>
<span class="udiff-line-removed">-                  */</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                 int off = 0;</span>
<span class="udiff-line-removed">-                 int modOff = 0;</span>
<span class="udiff-line-removed">-                 for (int c = 0; c &lt; arr.length; c++) {</span>
<span class="udiff-line-removed">-                     Class&lt;?&gt; cl = arr[c];</span>
<span class="udiff-line-removed">-                     if (cl == String.class) {</span>
<span class="udiff-line-removed">-                         if (off != modOff) {</span>
<span class="udiff-line-removed">-                             mv.visitIntInsn(getLoadOpcode(cl), off);</span>
<span class="udiff-line-removed">-                             mv.visitIntInsn(ASTORE, modOff);</span>
<span class="udiff-line-removed">-                         }</span>
<span class="udiff-line-removed">-                     } else {</span>
<span class="udiff-line-removed">-                         mv.visitIntInsn(getLoadOpcode(cl), off);</span>
<span class="udiff-line-removed">-                         mv.visitMethodInsn(</span>
<span class="udiff-line-removed">-                                 INVOKESTATIC,</span>
<span class="udiff-line-removed">-                                 &quot;java/lang/String&quot;,</span>
<span class="udiff-line-removed">-                                 &quot;valueOf&quot;,</span>
<span class="udiff-line-removed">-                                 getStringValueOfDesc(cl),</span>
<span class="udiff-line-removed">-                                 false</span>
<span class="udiff-line-removed">-                         );</span>
<span class="udiff-line-removed">-                         mv.visitIntInsn(ASTORE, modOff);</span>
<span class="udiff-line-removed">-                         arr[c] = String.class;</span>
<span class="udiff-line-removed">-                         guaranteedNonNull[c] = cl.isPrimitive();</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                     off += getParameterSize(cl);</span>
<span class="udiff-line-removed">-                     modOff += getParameterSize(String.class);</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             if (mode.isSized()) {</span>
<span class="udiff-line-removed">-                 /*</span>
<span class="udiff-line-removed">-                     When operating in sized mode (this includes exact mode), it makes sense to make</span>
<span class="udiff-line-removed">-                     StringBuilder append chains look familiar to OptimizeStringConcat. For that, we</span>
<span class="udiff-line-removed">-                     need to do null-checks early, not make the append chain shape simpler.</span>
<span class="udiff-line-removed">-                  */</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                 int off = 0;</span>
<span class="udiff-line-removed">-                 for (RecipeElement el : recipe.getElements()) {</span>
<span class="udiff-line-removed">-                     switch (el.getTag()) {</span>
<span class="udiff-line-removed">-                         case TAG_CONST:</span>
<span class="udiff-line-removed">-                             // Guaranteed non-null, no null check required.</span>
<span class="udiff-line-removed">-                             break;</span>
<span class="udiff-line-removed">-                         case TAG_ARG:</span>
<span class="udiff-line-removed">-                             // Null-checks are needed only for String arguments, and when a previous stage</span>
<span class="udiff-line-removed">-                             // did not do implicit null-checks. If a String is null, we eagerly replace it</span>
<span class="udiff-line-removed">-                             // with &quot;null&quot; constant. Note, we omit Objects here, because we don&#39;t call</span>
<span class="udiff-line-removed">-                             // .length() on them down below.</span>
<span class="udiff-line-removed">-                             int ac = el.getArgPos();</span>
<span class="udiff-line-removed">-                             Class&lt;?&gt; cl = arr[ac];</span>
<span class="udiff-line-removed">-                             if (cl == String.class &amp;&amp; !guaranteedNonNull[ac]) {</span>
<span class="udiff-line-removed">-                                 Label l0 = new Label();</span>
<span class="udiff-line-removed">-                                 mv.visitIntInsn(ALOAD, off);</span>
<span class="udiff-line-removed">-                                 mv.visitJumpInsn(IFNONNULL, l0);</span>
<span class="udiff-line-removed">-                                 mv.visitLdcInsn(&quot;null&quot;);</span>
<span class="udiff-line-removed">-                                 mv.visitIntInsn(ASTORE, off);</span>
<span class="udiff-line-removed">-                                 mv.visitLabel(l0);</span>
<span class="udiff-line-removed">-                             }</span>
<span class="udiff-line-removed">-                             off += getParameterSize(cl);</span>
<span class="udiff-line-removed">-                             break;</span>
<span class="udiff-line-removed">-                         default:</span>
<span class="udiff-line-removed">-                             throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             // Prepare StringBuilder instance</span>
<span class="udiff-line-removed">-             mv.visitTypeInsn(NEW, &quot;java/lang/StringBuilder&quot;);</span>
<span class="udiff-line-removed">-             mv.visitInsn(DUP);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             if (mode.isSized()) {</span>
<span class="udiff-line-removed">-                 /*</span>
<span class="udiff-line-removed">-                     Sized mode requires us to walk through the arguments, and estimate the final length.</span>
<span class="udiff-line-removed">-                     In exact mode, this will operate on Strings only. This code would accumulate the</span>
<span class="udiff-line-removed">-                     final length on stack.</span>
<span class="udiff-line-removed">-                  */</span>
<span class="udiff-line-removed">-                 int len = 0;</span>
<span class="udiff-line-removed">-                 int off = 0;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                 mv.visitInsn(ICONST_0);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                 for (RecipeElement el : recipe.getElements()) {</span>
<span class="udiff-line-removed">-                     switch (el.getTag()) {</span>
<span class="udiff-line-removed">-                         case TAG_CONST:</span>
<span class="udiff-line-removed">-                             len += el.getValue().length();</span>
<span class="udiff-line-removed">-                             break;</span>
<span class="udiff-line-removed">-                         case TAG_ARG:</span>
<span class="udiff-line-removed">-                             /*</span>
<span class="udiff-line-removed">-                                 If an argument is String, then we can call .length() on it. Sized/Exact modes have</span>
<span class="udiff-line-removed">-                                 converted arguments for us. If an argument is primitive, we can provide a guess</span>
<span class="udiff-line-removed">-                                 for its String representation size.</span>
<span class="udiff-line-removed">-                             */</span>
<span class="udiff-line-removed">-                             Class&lt;?&gt; cl = arr[el.getArgPos()];</span>
<span class="udiff-line-removed">-                             if (cl == String.class) {</span>
<span class="udiff-line-removed">-                                 mv.visitIntInsn(ALOAD, off);</span>
<span class="udiff-line-removed">-                                 mv.visitMethodInsn(</span>
<span class="udiff-line-removed">-                                         INVOKEVIRTUAL,</span>
<span class="udiff-line-removed">-                                         &quot;java/lang/String&quot;,</span>
<span class="udiff-line-removed">-                                         &quot;length&quot;,</span>
<span class="udiff-line-removed">-                                         &quot;()I&quot;,</span>
<span class="udiff-line-removed">-                                         false</span>
<span class="udiff-line-removed">-                                 );</span>
<span class="udiff-line-removed">-                                 mv.visitInsn(IADD);</span>
<span class="udiff-line-removed">-                             } else if (cl.isPrimitive()) {</span>
<span class="udiff-line-removed">-                                 len += estimateSize(cl);</span>
<span class="udiff-line-removed">-                             }</span>
<span class="udiff-line-removed">-                             off += getParameterSize(cl);</span>
<span class="udiff-line-removed">-                             break;</span>
<span class="udiff-line-removed">-                         default:</span>
<span class="udiff-line-removed">-                             throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                 // Constants have non-zero length, mix in</span>
<span class="udiff-line-removed">-                 if (len &gt; 0) {</span>
<span class="udiff-line-removed">-                     iconst(mv, len);</span>
<span class="udiff-line-removed">-                     mv.visitInsn(IADD);</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                 mv.visitMethodInsn(</span>
<span class="udiff-line-removed">-                         INVOKESPECIAL,</span>
<span class="udiff-line-removed">-                         &quot;java/lang/StringBuilder&quot;,</span>
<span class="udiff-line-removed">-                         &quot;&lt;init&gt;&quot;,</span>
<span class="udiff-line-removed">-                         &quot;(I)V&quot;,</span>
<span class="udiff-line-removed">-                         false</span>
<span class="udiff-line-removed">-                 );</span>
<span class="udiff-line-removed">-             } else {</span>
<span class="udiff-line-removed">-                 mv.visitMethodInsn(</span>
<span class="udiff-line-removed">-                         INVOKESPECIAL,</span>
<span class="udiff-line-removed">-                         &quot;java/lang/StringBuilder&quot;,</span>
<span class="udiff-line-removed">-                         &quot;&lt;init&gt;&quot;,</span>
<span class="udiff-line-removed">-                         &quot;()V&quot;,</span>
<span class="udiff-line-removed">-                         false</span>
<span class="udiff-line-removed">-                 );</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             // At this point, we have a blank StringBuilder on stack, fill it in with .append calls.</span>
<span class="udiff-line-removed">-             {</span>
<span class="udiff-line-removed">-                 int off = 0;</span>
<span class="udiff-line-removed">-                 for (RecipeElement el : recipe.getElements()) {</span>
<span class="udiff-line-removed">-                     String desc;</span>
<span class="udiff-line-removed">-                     switch (el.getTag()) {</span>
<span class="udiff-line-removed">-                         case TAG_CONST:</span>
<span class="udiff-line-removed">-                             mv.visitLdcInsn(el.getValue());</span>
<span class="udiff-line-removed">-                             desc = getSBAppendDesc(String.class);</span>
<span class="udiff-line-removed">-                             break;</span>
<span class="udiff-line-removed">-                         case TAG_ARG:</span>
<span class="udiff-line-removed">-                             Class&lt;?&gt; cl = arr[el.getArgPos()];</span>
<span class="udiff-line-removed">-                             mv.visitVarInsn(getLoadOpcode(cl), off);</span>
<span class="udiff-line-removed">-                             off += getParameterSize(cl);</span>
<span class="udiff-line-removed">-                             desc = getSBAppendDesc(cl);</span>
<span class="udiff-line-removed">-                             break;</span>
<span class="udiff-line-removed">-                         default:</span>
<span class="udiff-line-removed">-                             throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                     mv.visitMethodInsn(</span>
<span class="udiff-line-removed">-                             INVOKEVIRTUAL,</span>
<span class="udiff-line-removed">-                             &quot;java/lang/StringBuilder&quot;,</span>
<span class="udiff-line-removed">-                             &quot;append&quot;,</span>
<span class="udiff-line-removed">-                             desc,</span>
<span class="udiff-line-removed">-                             false</span>
<span class="udiff-line-removed">-                     );</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-modified-added">+         // Fast-path two-argument Object + Object concatenations</span>
<span class="udiff-line-modified-added">+         if (recipe.getElements().size() == 2) {</span>
<span class="udiff-line-modified-added">+             // Two object arguments</span>
<span class="udiff-line-modified-added">+             if (mt.parameterCount() == 2 &amp;&amp;</span>
<span class="udiff-line-modified-added">+                     !mt.parameterType(0).isPrimitive() &amp;&amp;</span>
<span class="udiff-line-modified-added">+                     !mt.parameterType(1).isPrimitive() &amp;&amp;</span>
<span class="udiff-line-modified-added">+                     recipe.getElements().get(0).getTag() == TAG_ARG &amp;&amp;</span>
<span class="udiff-line-modified-added">+                     recipe.getElements().get(1).getTag() == TAG_ARG) {</span>
  
<span class="udiff-line-modified-removed">-             if (DEBUG &amp;&amp; mode.isExact()) {</span>
<span class="udiff-line-removed">-                 /*</span>
<span class="udiff-line-removed">-                     Exactness checks compare the final StringBuilder.capacity() with a resulting</span>
<span class="udiff-line-removed">-                     String.length(). If these values disagree, that means StringBuilder had to perform</span>
<span class="udiff-line-removed">-                     storage trimming, which defeats the purpose of exact strategies.</span>
<span class="udiff-line-removed">-                  */</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                 /*</span>
<span class="udiff-line-removed">-                    The logic for this check is as follows:</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                      Stack before:     Op:</span>
<span class="udiff-line-removed">-                       (SB)              dup, dup</span>
<span class="udiff-line-removed">-                       (SB, SB, SB)      capacity()</span>
<span class="udiff-line-removed">-                       (int, SB, SB)     swap</span>
<span class="udiff-line-removed">-                       (SB, int, SB)     toString()</span>
<span class="udiff-line-removed">-                       (S, int, SB)      length()</span>
<span class="udiff-line-removed">-                       (int, int, SB)    if_icmpeq</span>
<span class="udiff-line-removed">-                       (SB)              &lt;end&gt;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                    Note that it leaves the same StringBuilder on exit, like the one on enter.</span>
<span class="udiff-line-removed">-                  */</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                 mv.visitInsn(DUP);</span>
<span class="udiff-line-removed">-                 mv.visitInsn(DUP);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                 mv.visitMethodInsn(</span>
<span class="udiff-line-removed">-                         INVOKEVIRTUAL,</span>
<span class="udiff-line-removed">-                         &quot;java/lang/StringBuilder&quot;,</span>
<span class="udiff-line-removed">-                         &quot;capacity&quot;,</span>
<span class="udiff-line-removed">-                         &quot;()I&quot;,</span>
<span class="udiff-line-removed">-                         false</span>
<span class="udiff-line-removed">-                 );</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                 mv.visitInsn(SWAP);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                 mv.visitMethodInsn(</span>
<span class="udiff-line-removed">-                         INVOKEVIRTUAL,</span>
<span class="udiff-line-removed">-                         &quot;java/lang/StringBuilder&quot;,</span>
<span class="udiff-line-removed">-                         &quot;toString&quot;,</span>
<span class="udiff-line-removed">-                         &quot;()Ljava/lang/String;&quot;,</span>
<span class="udiff-line-removed">-                         false</span>
<span class="udiff-line-removed">-                 );</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                 mv.visitMethodInsn(</span>
<span class="udiff-line-removed">-                         INVOKEVIRTUAL,</span>
<span class="udiff-line-removed">-                         &quot;java/lang/String&quot;,</span>
<span class="udiff-line-removed">-                         &quot;length&quot;,</span>
<span class="udiff-line-removed">-                         &quot;()I&quot;,</span>
<span class="udiff-line-removed">-                         false</span>
<span class="udiff-line-removed">-                 );</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                 Label l0 = new Label();</span>
<span class="udiff-line-removed">-                 mv.visitJumpInsn(IF_ICMPEQ, l0);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                 mv.visitTypeInsn(NEW, &quot;java/lang/AssertionError&quot;);</span>
<span class="udiff-line-removed">-                 mv.visitInsn(DUP);</span>
<span class="udiff-line-removed">-                 mv.visitLdcInsn(&quot;Failed exactness check&quot;);</span>
<span class="udiff-line-removed">-                 mv.visitMethodInsn(INVOKESPECIAL,</span>
<span class="udiff-line-removed">-                         &quot;java/lang/AssertionError&quot;,</span>
<span class="udiff-line-removed">-                         &quot;&lt;init&gt;&quot;,</span>
<span class="udiff-line-removed">-                         &quot;(Ljava/lang/Object;)V&quot;,</span>
<span class="udiff-line-removed">-                         false);</span>
<span class="udiff-line-removed">-                 mv.visitInsn(ATHROW);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                 mv.visitLabel(l0);</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-modified-added">+                 return simpleConcat();</span>
  
<span class="udiff-line-modified-removed">-             mv.visitMethodInsn(</span>
<span class="udiff-line-modified-removed">-                     INVOKEVIRTUAL,</span>
<span class="udiff-line-modified-removed">-                     &quot;java/lang/StringBuilder&quot;,</span>
<span class="udiff-line-modified-removed">-                     &quot;toString&quot;,</span>
<span class="udiff-line-removed">-                     &quot;()Ljava/lang/String;&quot;,</span>
<span class="udiff-line-removed">-                     false</span>
<span class="udiff-line-removed">-             );</span>
<span class="udiff-line-modified-added">+             } else if (mt.parameterCount() == 1 &amp;&amp;</span>
<span class="udiff-line-modified-added">+                     !mt.parameterType(0).isPrimitive()) {</span>
<span class="udiff-line-modified-added">+                 // One Object argument, one constant</span>
<span class="udiff-line-modified-added">+                 MethodHandle mh = simpleConcat();</span>
  
<span class="udiff-line-modified-removed">-             mv.visitInsn(ARETURN);</span>
<span class="udiff-line-modified-added">+                 if (recipe.getElements().get(0).getTag() == TAG_CONST &amp;&amp;</span>
<span class="udiff-line-added">+                         recipe.getElements().get(1).getTag() == TAG_ARG) {</span>
<span class="udiff-line-added">+                     // First recipe element is a constant</span>
<span class="udiff-line-added">+                     return MethodHandles.insertArguments(mh, 0,</span>
<span class="udiff-line-added">+                             recipe.getElements().get(0).getValue());</span>
  
<span class="udiff-line-modified-removed">-             mv.visitMaxs(-1, -1);</span>
<span class="udiff-line-modified-removed">-             mv.visitEnd();</span>
<span class="udiff-line-modified-removed">-             cw.visitEnd();</span>
<span class="udiff-line-modified-added">+                 } else if (recipe.getElements().get(1).getTag() == TAG_CONST &amp;&amp;</span>
<span class="udiff-line-modified-added">+                         recipe.getElements().get(0).getTag() == TAG_ARG) {</span>
<span class="udiff-line-modified-added">+                     // Second recipe element is a constant</span>
<span class="udiff-line-added">+                     return MethodHandles.insertArguments(mh, 1,</span>
<span class="udiff-line-added">+                             recipe.getElements().get(1).getValue());</span>
  
<span class="udiff-line-removed">-             byte[] classBytes = cw.toByteArray();</span>
<span class="udiff-line-removed">-             try {</span>
<span class="udiff-line-removed">-                 Class&lt;?&gt; innerClass = lookup.defineHiddenClass(classBytes, true, STRONG).lookupClass();</span>
<span class="udiff-line-removed">-                 dumpIfEnabled(className, classBytes);</span>
<span class="udiff-line-removed">-                 MethodHandle mh = lookup.findStatic(innerClass, METHOD_NAME, args);</span>
<span class="udiff-line-removed">-                 if (CACHE_ENABLE) {</span>
<span class="udiff-line-removed">-                     CACHE.put(key, mh);</span>
                  }
<span class="udiff-line-removed">-                 return mh;</span>
<span class="udiff-line-removed">-             } catch (Exception e) {</span>
<span class="udiff-line-removed">-                 dumpIfEnabled(className + &quot;$$FAILED&quot;, classBytes);</span>
<span class="udiff-line-removed">-                 throw new StringConcatException(&quot;Exception while spinning the class&quot;, e);</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         /**</span>
<span class="udiff-line-removed">-          * The generated class is in the same package as the host class as</span>
<span class="udiff-line-removed">-          * it&#39;s the implementation of the string concatenation for the host</span>
<span class="udiff-line-removed">-          * class.</span>
<span class="udiff-line-removed">-          *</span>
<span class="udiff-line-removed">-          * When cache is enabled, we want to cache as much as we can.</span>
<span class="udiff-line-removed">-          */</span>
<span class="udiff-line-removed">-         private static String getClassName(Class&lt;?&gt; hostClass) {</span>
<span class="udiff-line-removed">-             if (CACHE_ENABLE) {</span>
<span class="udiff-line-removed">-                 String pkgName = hostClass.getPackageName();</span>
<span class="udiff-line-removed">-                 return (!pkgName.isEmpty() ? pkgName.replace(&#39;.&#39;, &#39;/&#39;) + &quot;/&quot; : &quot;&quot;) + &quot;Stubs$$StringConcat&quot;;</span>
<span class="udiff-line-removed">-             } else {</span>
<span class="udiff-line-removed">-                 String name = hostClass.isHidden() ? hostClass.getName().replace(&#39;/&#39;, &#39;_&#39;)</span>
<span class="udiff-line-removed">-                         : hostClass.getName();</span>
<span class="udiff-line-removed">-                 return name.replace(&#39;.&#39;, &#39;/&#39;) + &quot;$$StringConcat&quot;;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         private static void dumpIfEnabled(String name, byte[] bytes) {</span>
<span class="udiff-line-removed">-             if (DUMPER != null) {</span>
<span class="udiff-line-removed">-                 DUMPER.dumpClass(name, bytes);</span>
              }
<span class="udiff-line-added">+             // else... fall-through to slow-path</span>
          }
  
<span class="udiff-line-modified-removed">-         private static String getSBAppendDesc(Class&lt;?&gt; cl) {</span>
<span class="udiff-line-modified-removed">-             if (cl.isPrimitive()) {</span>
<span class="udiff-line-modified-removed">-                 if (cl == Integer.TYPE || cl == Byte.TYPE || cl == Short.TYPE) {</span>
<span class="udiff-line-modified-removed">-                     return &quot;(I)Ljava/lang/StringBuilder;&quot;;</span>
<span class="udiff-line-modified-removed">-                 } else if (cl == Boolean.TYPE) {</span>
<span class="udiff-line-modified-removed">-                     return &quot;(Z)Ljava/lang/StringBuilder;&quot;;</span>
<span class="udiff-line-modified-removed">-                 } else if (cl == Character.TYPE) {</span>
<span class="udiff-line-modified-removed">-                     return &quot;(C)Ljava/lang/StringBuilder;&quot;;</span>
<span class="udiff-line-modified-removed">-                 } else if (cl == Double.TYPE) {</span>
<span class="udiff-line-modified-removed">-                     return &quot;(D)Ljava/lang/StringBuilder;&quot;;</span>
<span class="udiff-line-removed">-                 } else if (cl == Float.TYPE) {</span>
<span class="udiff-line-removed">-                     return &quot;(F)Ljava/lang/StringBuilder;&quot;;</span>
<span class="udiff-line-removed">-                 } else if (cl == Long.TYPE) {</span>
<span class="udiff-line-removed">-                     return &quot;(J)Ljava/lang/StringBuilder;&quot;;</span>
<span class="udiff-line-removed">-                 } else {</span>
<span class="udiff-line-removed">-                     throw new IllegalStateException(&quot;Unhandled primitive StringBuilder.append: &quot; + cl);</span>
<span class="udiff-line-modified-added">+         // Create filters and obtain filtered parameter types. Filters would be used in the beginning</span>
<span class="udiff-line-modified-added">+         // to convert the incoming arguments into the arguments we can process (e.g. Objects -&gt; Strings).</span>
<span class="udiff-line-modified-added">+         // The filtered argument type list is used all over in the combinators below.</span>
<span class="udiff-line-modified-added">+         Class&lt;?&gt;[] ptypes = mt.parameterArray();</span>
<span class="udiff-line-modified-added">+         MethodHandle[] filters = null;</span>
<span class="udiff-line-modified-added">+         for (int i = 0; i &lt; ptypes.length; i++) {</span>
<span class="udiff-line-modified-added">+             MethodHandle filter = stringifierFor(ptypes[i]);</span>
<span class="udiff-line-modified-added">+             if (filter != null) {</span>
<span class="udiff-line-modified-added">+                 if (filters == null) {</span>
<span class="udiff-line-modified-added">+                     filters = new MethodHandle[ptypes.length];</span>
                  }
<span class="udiff-line-modified-removed">-             } else if (cl == String.class) {</span>
<span class="udiff-line-modified-removed">-                 return &quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;;</span>
<span class="udiff-line-removed">-             } else {</span>
<span class="udiff-line-removed">-                 return &quot;(Ljava/lang/Object;)Ljava/lang/StringBuilder;&quot;;</span>
<span class="udiff-line-modified-added">+                 filters[i] = filter;</span>
<span class="udiff-line-modified-added">+                 ptypes[i] = filter.type().returnType();</span>
              }
          }
  
<span class="udiff-line-modified-removed">-         private static String getStringValueOfDesc(Class&lt;?&gt; cl) {</span>
<span class="udiff-line-modified-removed">-             if (cl.isPrimitive()) {</span>
<span class="udiff-line-modified-removed">-                 if (cl == Integer.TYPE || cl == Byte.TYPE || cl == Short.TYPE) {</span>
<span class="udiff-line-removed">-                     return &quot;(I)Ljava/lang/String;&quot;;</span>
<span class="udiff-line-removed">-                 } else if (cl == Boolean.TYPE) {</span>
<span class="udiff-line-removed">-                     return &quot;(Z)Ljava/lang/String;&quot;;</span>
<span class="udiff-line-removed">-                 } else if (cl == Character.TYPE) {</span>
<span class="udiff-line-removed">-                     return &quot;(C)Ljava/lang/String;&quot;;</span>
<span class="udiff-line-removed">-                 } else if (cl == Double.TYPE) {</span>
<span class="udiff-line-removed">-                     return &quot;(D)Ljava/lang/String;&quot;;</span>
<span class="udiff-line-removed">-                 } else if (cl == Float.TYPE) {</span>
<span class="udiff-line-removed">-                     return &quot;(F)Ljava/lang/String;&quot;;</span>
<span class="udiff-line-removed">-                 } else if (cl == Long.TYPE) {</span>
<span class="udiff-line-removed">-                     return &quot;(J)Ljava/lang/String;&quot;;</span>
<span class="udiff-line-removed">-                 } else {</span>
<span class="udiff-line-removed">-                     throw new IllegalStateException(&quot;Unhandled String.valueOf: &quot; + cl);</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-             } else if (cl == String.class) {</span>
<span class="udiff-line-removed">-                 return &quot;(Ljava/lang/String;)Ljava/lang/String;&quot;;</span>
<span class="udiff-line-removed">-             } else {</span>
<span class="udiff-line-removed">-                 return &quot;(Ljava/lang/Object;)Ljava/lang/String;&quot;;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-modified-added">+         // Start building the combinator tree. The tree &quot;starts&quot; with (&lt;parameters&gt;)String, and &quot;finishes&quot;</span>
<span class="udiff-line-modified-added">+         // with the (byte[], long)String shape to invoke newString in StringConcatHelper. The combinators are</span>
<span class="udiff-line-modified-added">+         // assembled bottom-up, which makes the code arguably hard to read.</span>
  
<span class="udiff-line-modified-removed">-         /**</span>
<span class="udiff-line-modified-removed">-          * The following method is copied from</span>
<span class="udiff-line-removed">-          * org.objectweb.asm.commons.InstructionAdapter. Part of ASM: a very small</span>
<span class="udiff-line-removed">-          * and fast Java bytecode manipulation framework.</span>
<span class="udiff-line-removed">-          * Copyright (c) 2000-2005 INRIA, France Telecom All rights reserved.</span>
<span class="udiff-line-removed">-          */</span>
<span class="udiff-line-removed">-         private static void iconst(MethodVisitor mv, final int cst) {</span>
<span class="udiff-line-removed">-             if (cst &gt;= -1 &amp;&amp; cst &lt;= 5) {</span>
<span class="udiff-line-removed">-                 mv.visitInsn(Opcodes.ICONST_0 + cst);</span>
<span class="udiff-line-removed">-             } else if (cst &gt;= Byte.MIN_VALUE &amp;&amp; cst &lt;= Byte.MAX_VALUE) {</span>
<span class="udiff-line-removed">-                 mv.visitIntInsn(Opcodes.BIPUSH, cst);</span>
<span class="udiff-line-removed">-             } else if (cst &gt;= Short.MIN_VALUE &amp;&amp; cst &lt;= Short.MAX_VALUE) {</span>
<span class="udiff-line-removed">-                 mv.visitIntInsn(Opcodes.SIPUSH, cst);</span>
<span class="udiff-line-removed">-             } else {</span>
<span class="udiff-line-removed">-                 mv.visitLdcInsn(cst);</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-modified-added">+         // Drop all remaining parameter types, leave only helper arguments:</span>
<span class="udiff-line-modified-added">+         MethodHandle mh;</span>
  
<span class="udiff-line-modified-removed">-         private static int getLoadOpcode(Class&lt;?&gt; c) {</span>
<span class="udiff-line-removed">-             if (c == Void.TYPE) {</span>
<span class="udiff-line-removed">-                 throw new InternalError(&quot;Unexpected void type of load opcode&quot;);</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             return ILOAD + getOpcodeOffset(c);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-modified-added">+         mh = MethodHandles.dropArguments(newString(), 2, ptypes);</span>
  
<span class="udiff-line-modified-removed">-         private static int getOpcodeOffset(Class&lt;?&gt; c) {</span>
<span class="udiff-line-removed">-             if (c.isPrimitive()) {</span>
<span class="udiff-line-removed">-                 if (c == Long.TYPE) {</span>
<span class="udiff-line-removed">-                     return 1;</span>
<span class="udiff-line-removed">-                 } else if (c == Float.TYPE) {</span>
<span class="udiff-line-removed">-                     return 2;</span>
<span class="udiff-line-removed">-                 } else if (c == Double.TYPE) {</span>
<span class="udiff-line-removed">-                     return 3;</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-                 return 0;</span>
<span class="udiff-line-removed">-             } else {</span>
<span class="udiff-line-removed">-                 return 4;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-modified-added">+         long initialLengthCoder = INITIAL_CODER;</span>
  
<span class="udiff-line-modified-removed">-         private static int getParameterSize(Class&lt;?&gt; c) {</span>
<span class="udiff-line-modified-removed">-             if (c == Void.TYPE) {</span>
<span class="udiff-line-modified-removed">-                 return 0;</span>
<span class="udiff-line-removed">-             } else if (c == Long.TYPE || c == Double.TYPE) {</span>
<span class="udiff-line-removed">-                 return 2;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             return 1;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+         // Mix in prependers. This happens when (byte[], long) = (storage, indexCoder) is already</span>
<span class="udiff-line-modified-added">+         // known from the combinators below. We are assembling the string backwards, so the index coded</span>
<span class="udiff-line-modified-added">+         // into indexCoder is the *ending* index.</span>
  
<span class="udiff-line-modified-removed">-     /**</span>
<span class="udiff-line-modified-removed">-      * MethodHandle StringBuilder strategy.</span>
<span class="udiff-line-modified-removed">-      *</span>
<span class="udiff-line-modified-removed">-      * &lt;p&gt;This strategy operates in two modes, gated by {@link Mode}.</span>
<span class="udiff-line-modified-removed">-      *</span>
<span class="udiff-line-modified-removed">-      * &lt;p&gt;&lt;b&gt;{@link Strategy#MH_SB_SIZED}: &quot;MethodHandles StringBuilder,</span>
<span class="udiff-line-modified-removed">-      * sized&quot;.&lt;/b&gt;</span>
<span class="udiff-line-modified-removed">-      *</span>
<span class="udiff-line-modified-removed">-      * &lt;p&gt;This strategy avoids spinning up the bytecode by building the</span>
<span class="udiff-line-removed">-      * computation on MethodHandle combinators. The computation is built with</span>
<span class="udiff-line-removed">-      * public MethodHandle APIs, resolved from a public Lookup sequence, and</span>
<span class="udiff-line-removed">-      * ends up calling the public StringBuilder API. Therefore, this strategy</span>
<span class="udiff-line-removed">-      * does not use any private API at all since everything is handled under</span>
<span class="udiff-line-removed">-      * cover by java.lang.invoke APIs.</span>
<span class="udiff-line-removed">-      *</span>
<span class="udiff-line-removed">-      * &lt;p&gt;&lt;b&gt;{@link Strategy#MH_SB_SIZED_EXACT}: &quot;MethodHandles StringBuilder,</span>
<span class="udiff-line-removed">-      * sized exactly&quot;.&lt;/b&gt;</span>
<span class="udiff-line-removed">-      *</span>
<span class="udiff-line-removed">-      * &lt;p&gt;This strategy improves on @link Strategy#MH_SB_SIZED}, by first</span>
<span class="udiff-line-removed">-      * converting all arguments to String in order to get the exact capacity</span>
<span class="udiff-line-removed">-      * StringBuilder should have. The conversion is done via the public</span>
<span class="udiff-line-removed">-      * String.valueOf and/or Object.toString methods, and does not touch any</span>
<span class="udiff-line-removed">-      * private String API.</span>
<span class="udiff-line-removed">-      */</span>
<span class="udiff-line-removed">-     private static final class MethodHandleStringBuilderStrategy {</span>
<span class="udiff-line-removed">-         private MethodHandleStringBuilderStrategy() {</span>
<span class="udiff-line-removed">-             // no instantiation</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-modified-added">+         // We need one prepender per argument, but also need to fold in constants. We do so by greedily</span>
<span class="udiff-line-modified-added">+         // create prependers that fold in surrounding constants into the argument prepender. This reduces</span>
<span class="udiff-line-modified-added">+         // the number of unique MH combinator tree shapes we&#39;ll create in an application.</span>
<span class="udiff-line-modified-added">+         String constant = null;</span>
<span class="udiff-line-modified-added">+         for (RecipeElement el : recipe.getElements()) {</span>
<span class="udiff-line-modified-added">+             // Do the prepend, and put &quot;new&quot; index at index 1</span>
<span class="udiff-line-modified-added">+             switch (el.getTag()) {</span>
<span class="udiff-line-modified-added">+                 case TAG_CONST: {</span>
<span class="udiff-line-modified-added">+                     String constantValue = el.getValue();</span>
  
<span class="udiff-line-modified-removed">-         private static MethodHandle generate(MethodType mt, Recipe recipe, Mode mode) throws Exception {</span>
<span class="udiff-line-modified-removed">-             int pc = mt.parameterCount();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             Class&lt;?&gt;[] ptypes = mt.parameterArray();</span>
<span class="udiff-line-removed">-             MethodHandle[] filters = new MethodHandle[ptypes.length];</span>
<span class="udiff-line-removed">-             for (int i = 0; i &lt; ptypes.length; i++) {</span>
<span class="udiff-line-removed">-                 MethodHandle filter;</span>
<span class="udiff-line-removed">-                 switch (mode) {</span>
<span class="udiff-line-removed">-                     case SIZED:</span>
<span class="udiff-line-removed">-                         // In sized mode, we convert all references and floats/doubles</span>
<span class="udiff-line-removed">-                         // to String: there is no specialization for different</span>
<span class="udiff-line-removed">-                         // classes in StringBuilder API, and it will convert to</span>
<span class="udiff-line-removed">-                         // String internally anyhow.</span>
<span class="udiff-line-removed">-                         filter = Stringifiers.forMost(ptypes[i]);</span>
<span class="udiff-line-removed">-                         break;</span>
<span class="udiff-line-removed">-                     case SIZED_EXACT:</span>
<span class="udiff-line-removed">-                         // In exact mode, we convert everything to String:</span>
<span class="udiff-line-removed">-                         // this helps to compute the storage exactly.</span>
<span class="udiff-line-removed">-                         filter = Stringifiers.forAny(ptypes[i]);</span>
<span class="udiff-line-removed">-                         break;</span>
<span class="udiff-line-removed">-                     default:</span>
<span class="udiff-line-removed">-                         throw new StringConcatException(&quot;Not supported&quot;);</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-                 if (filter != null) {</span>
<span class="udiff-line-removed">-                     filters[i] = filter;</span>
<span class="udiff-line-removed">-                     ptypes[i] = filter.type().returnType();</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-modified-added">+                     // Eagerly update the initialLengthCoder value</span>
<span class="udiff-line-modified-added">+                     initialLengthCoder = JLA.stringConcatMix(initialLengthCoder, constantValue);</span>
  
<span class="udiff-line-modified-removed">-             MethodHandle[] lengthers = new MethodHandle[pc];</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-             // Figure out lengths: constants&#39; lengths can be deduced on the spot.</span>
<span class="udiff-line-modified-removed">-             // All reference arguments were filtered to String in the combinators below, so we can</span>
<span class="udiff-line-modified-removed">-             // call the usual String.length(). Primitive values string sizes can be estimated.</span>
<span class="udiff-line-removed">-             int initial = 0;</span>
<span class="udiff-line-removed">-             for (RecipeElement el : recipe.getElements()) {</span>
<span class="udiff-line-removed">-                 switch (el.getTag()) {</span>
<span class="udiff-line-removed">-                     case TAG_CONST:</span>
<span class="udiff-line-removed">-                         initial += el.getValue().length();</span>
<span class="udiff-line-removed">-                         break;</span>
<span class="udiff-line-removed">-                     case TAG_ARG:</span>
<span class="udiff-line-removed">-                         final int i = el.getArgPos();</span>
<span class="udiff-line-removed">-                         Class&lt;?&gt; type = ptypes[i];</span>
<span class="udiff-line-removed">-                         if (type.isPrimitive()) {</span>
<span class="udiff-line-removed">-                             MethodHandle est = MethodHandles.constant(int.class, estimateSize(type));</span>
<span class="udiff-line-removed">-                             est = MethodHandles.dropArguments(est, 0, type);</span>
<span class="udiff-line-removed">-                             lengthers[i] = est;</span>
<span class="udiff-line-removed">-                         } else {</span>
<span class="udiff-line-removed">-                             lengthers[i] = STRING_LENGTH;</span>
<span class="udiff-line-removed">-                         }</span>
<span class="udiff-line-removed">-                         break;</span>
<span class="udiff-line-removed">-                     default:</span>
<span class="udiff-line-removed">-                         throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());</span>
<span class="udiff-line-modified-added">+                     // Collecting into a single constant that we&#39;ll either fold</span>
<span class="udiff-line-modified-added">+                     // into the next argument prepender, or into the newArray</span>
<span class="udiff-line-modified-added">+                     // combinator</span>
<span class="udiff-line-modified-added">+                     constant = constant == null ? constantValue : constant + constantValue;</span>
<span class="udiff-line-modified-added">+                     break;</span>
                  }
<span class="udiff-line-modified-removed">-             }</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-             // Create (StringBuilder, &lt;args&gt;) shape for appending:</span>
<span class="udiff-line-modified-removed">-             MethodHandle builder = MethodHandles.dropArguments(MethodHandles.identity(StringBuilder.class), 1, ptypes);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-             // Compose append calls. This is done in reverse because the application order is</span>
<span class="udiff-line-modified-removed">-             // reverse as well.</span>
<span class="udiff-line-modified-removed">-             List&lt;RecipeElement&gt; elements = recipe.getElements();</span>
<span class="udiff-line-modified-removed">-             for (int i = elements.size() - 1; i &gt;= 0; i--) {</span>
<span class="udiff-line-modified-removed">-                 RecipeElement el = elements.get(i);</span>
<span class="udiff-line-modified-removed">-                 MethodHandle appender;</span>
<span class="udiff-line-removed">-                 switch (el.getTag()) {</span>
<span class="udiff-line-removed">-                     case TAG_CONST:</span>
<span class="udiff-line-removed">-                         MethodHandle mh = appender(adaptToStringBuilder(String.class));</span>
<span class="udiff-line-removed">-                         appender = MethodHandles.insertArguments(mh, 1, el.getValue());</span>
<span class="udiff-line-removed">-                         break;</span>
<span class="udiff-line-removed">-                     case TAG_ARG:</span>
<span class="udiff-line-removed">-                         int ac = el.getArgPos();</span>
<span class="udiff-line-removed">-                         appender = appender(ptypes[ac]);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                         // Insert dummy arguments to match the prefix in the signature.</span>
<span class="udiff-line-removed">-                         // The actual appender argument will be the ac-ith argument.</span>
<span class="udiff-line-removed">-                         if (ac != 0) {</span>
<span class="udiff-line-removed">-                             appender = MethodHandles.dropArguments(appender, 1, Arrays.copyOf(ptypes, ac));</span>
<span class="udiff-line-removed">-                         }</span>
<span class="udiff-line-removed">-                         break;</span>
<span class="udiff-line-removed">-                     default:</span>
<span class="udiff-line-removed">-                         throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());</span>
<span class="udiff-line-modified-added">+                 case TAG_ARG: {</span>
<span class="udiff-line-modified-added">+                     // Add prepender, along with any prefix constant</span>
<span class="udiff-line-modified-added">+                     int pos = el.getArgPos();</span>
<span class="udiff-line-modified-added">+                     mh = MethodHandles.filterArgumentsWithCombiner(</span>
<span class="udiff-line-modified-added">+                             mh, 1,</span>
<span class="udiff-line-modified-added">+                             prepender(constant, ptypes[pos]),</span>
<span class="udiff-line-modified-added">+                             1, 0, // indexCoder, storage</span>
<span class="udiff-line-modified-added">+                             2 + pos  // selected argument</span>
<span class="udiff-line-modified-added">+                     );</span>
<span class="udiff-line-modified-added">+                     constant = null;</span>
<span class="udiff-line-modified-added">+                     break;</span>
                  }
<span class="udiff-line-modified-removed">-                 builder = MethodHandles.foldArguments(builder, appender);</span>
<span class="udiff-line-modified-removed">-             }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             // Build the sub-tree that adds the sizes and produces a StringBuilder:</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             // a) Start with the reducer that accepts all arguments, plus one</span>
<span class="udiff-line-removed">-             //    slot for the initial value. Inject the initial value right away.</span>
<span class="udiff-line-removed">-             //    This produces (&lt;ints&gt;)int shape:</span>
<span class="udiff-line-removed">-             MethodHandle sum = getReducerFor(pc + 1);</span>
<span class="udiff-line-removed">-             MethodHandle adder = MethodHandles.insertArguments(sum, 0, initial);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             // b) Apply lengthers to transform arguments to lengths, producing (&lt;args&gt;)int</span>
<span class="udiff-line-removed">-             adder = MethodHandles.filterArguments(adder, 0, lengthers);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             // c) Instantiate StringBuilder (&lt;args&gt;)int -&gt; (&lt;args&gt;)StringBuilder</span>
<span class="udiff-line-removed">-             MethodHandle newBuilder = MethodHandles.filterReturnValue(adder, NEW_STRING_BUILDER);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             // d) Fold in StringBuilder constructor, this produces (&lt;args&gt;)StringBuilder</span>
<span class="udiff-line-removed">-             MethodHandle mh = MethodHandles.foldArguments(builder, newBuilder);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             // Convert non-primitive arguments to Strings</span>
<span class="udiff-line-removed">-             mh = MethodHandles.filterArguments(mh, 0, filters);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             // Convert (&lt;args&gt;)StringBuilder to (&lt;args&gt;)String</span>
<span class="udiff-line-removed">-             if (DEBUG &amp;&amp; mode.isExact()) {</span>
<span class="udiff-line-removed">-                 mh = MethodHandles.filterReturnValue(mh, BUILDER_TO_STRING_CHECKED);</span>
<span class="udiff-line-removed">-             } else {</span>
<span class="udiff-line-removed">-                 mh = MethodHandles.filterReturnValue(mh, BUILDER_TO_STRING);</span>
<span class="udiff-line-modified-added">+                 default:</span>
<span class="udiff-line-modified-added">+                     throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());</span>
              }
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             return mh;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         private static MethodHandle getReducerFor(int cnt) {</span>
<span class="udiff-line-removed">-             return SUMMERS.computeIfAbsent(cnt, SUMMER);</span>
          }
  
<span class="udiff-line-modified-removed">-         private static MethodHandle appender(Class&lt;?&gt; appendType) {</span>
<span class="udiff-line-modified-removed">-             MethodHandle appender = lookupVirtual(MethodHandles.publicLookup(), StringBuilder.class, &quot;append&quot;,</span>
<span class="udiff-line-modified-removed">-                     StringBuilder.class, adaptToStringBuilder(appendType));</span>
<span class="udiff-line-modified-added">+         // Fold in byte[] instantiation at argument 0</span>
<span class="udiff-line-modified-added">+         MethodHandle newArrayCombinator;</span>
<span class="udiff-line-modified-added">+         if (constant != null) {</span>
<span class="udiff-line-added">+             // newArray variant that deals with prepending the trailing constant</span>
<span class="udiff-line-added">+             //</span>
<span class="udiff-line-added">+             // initialLengthCoder has been adjusted to have the correct coder</span>
<span class="udiff-line-added">+             // and length already, but to avoid binding an extra variable to</span>
<span class="udiff-line-added">+             // the method handle we now adjust the length to be correct for the</span>
<span class="udiff-line-added">+             // first prepender above, while adjusting for the missing length of</span>
<span class="udiff-line-added">+             // the constant in StringConcatHelper</span>
<span class="udiff-line-added">+             initialLengthCoder -= constant.length();</span>
<span class="udiff-line-added">+             newArrayCombinator = newArrayWithSuffix(constant);</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             newArrayCombinator = newArray();</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         mh = MethodHandles.foldArgumentsWithCombiner(mh, 0, newArrayCombinator,</span>
<span class="udiff-line-added">+                 1 // index</span>
<span class="udiff-line-added">+         );</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // Start combining length and coder mixers.</span>
<span class="udiff-line-added">+         //</span>
<span class="udiff-line-added">+         // Length is easy: constant lengths can be computed on the spot, and all non-constant</span>
<span class="udiff-line-added">+         // shapes have been either converted to Strings, or explicit methods for getting the</span>
<span class="udiff-line-added">+         // string length out of primitives are provided.</span>
<span class="udiff-line-added">+         //</span>
<span class="udiff-line-added">+         // Coders are more interesting. Only Object, String and char arguments (and constants)</span>
<span class="udiff-line-added">+         // can have non-Latin1 encoding. It is easier to blindly convert constants to String,</span>
<span class="udiff-line-added">+         // and deduce the coder from there. Arguments would be either converted to Strings</span>
<span class="udiff-line-added">+         // during the initial filtering, or handled by specializations in MIXERS.</span>
<span class="udiff-line-added">+         //</span>
<span class="udiff-line-added">+         // The method handle shape before all mixers are combined in is:</span>
<span class="udiff-line-added">+         //   (long, &lt;args&gt;)String = (&quot;indexCoder&quot;, &lt;args&gt;)</span>
<span class="udiff-line-added">+         //</span>
<span class="udiff-line-added">+         // We will bind the initialLengthCoder value to the last mixer (the one that will be</span>
<span class="udiff-line-added">+         // executed first), then fold that in. This leaves the shape after all mixers are</span>
<span class="udiff-line-added">+         // combined in as:</span>
<span class="udiff-line-added">+         //   (&lt;args&gt;)String = (&lt;args&gt;)</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         int ac = -1;</span>
<span class="udiff-line-added">+         MethodHandle mix = null;</span>
<span class="udiff-line-added">+         for (RecipeElement el : recipe.getElements()) {</span>
<span class="udiff-line-added">+             switch (el.getTag()) {</span>
<span class="udiff-line-added">+                 case TAG_CONST:</span>
<span class="udiff-line-added">+                     // Constants already handled in the code above</span>
<span class="udiff-line-added">+                     break;</span>
<span class="udiff-line-added">+                 case TAG_ARG:</span>
<span class="udiff-line-added">+                     if (ac &gt;= 0) {</span>
<span class="udiff-line-added">+                         // Compute new &quot;index&quot; in-place using old value plus the appropriate argument.</span>
<span class="udiff-line-added">+                         mh = MethodHandles.filterArgumentsWithCombiner(mh, 0, mix,</span>
<span class="udiff-line-added">+                                 0, // old-index</span>
<span class="udiff-line-added">+                                 1 + ac // selected argument</span>
<span class="udiff-line-added">+                         );</span>
<span class="udiff-line-added">+                     }</span>
  
<span class="udiff-line-modified-removed">-             // appenders should return void, this would not modify the target signature during folding</span>
<span class="udiff-line-modified-removed">-             MethodType nt = MethodType.methodType(void.class, StringBuilder.class, appendType);</span>
<span class="udiff-line-modified-removed">-             return appender.asType(nt);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-modified-added">+                     ac = el.getArgPos();</span>
<span class="udiff-line-modified-added">+                     Class&lt;?&gt; argClass = ptypes[ac];</span>
<span class="udiff-line-modified-added">+                     mix = mixer(argClass);</span>
  
<span class="udiff-line-modified-removed">-         private static String toStringChecked(StringBuilder sb) {</span>
<span class="udiff-line-modified-removed">-             String s = sb.toString();</span>
<span class="udiff-line-modified-removed">-             if (s.length() != sb.capacity()) {</span>
<span class="udiff-line-removed">-                 throw new AssertionError(&quot;Exactness check failed: result length = &quot; + s.length() + &quot;, buffer capacity = &quot; + sb.capacity());</span>
<span class="udiff-line-modified-added">+                     break;</span>
<span class="udiff-line-modified-added">+                 default:</span>
<span class="udiff-line-modified-added">+                     throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());</span>
              }
<span class="udiff-line-removed">-             return s;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         private static int sum(int v1, int v2) {</span>
<span class="udiff-line-removed">-             return v1 + v2;</span>
          }
  
<span class="udiff-line-modified-removed">-         private static int sum(int v1, int v2, int v3) {</span>
<span class="udiff-line-modified-removed">-             return v1 + v2 + v3;</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-         private static int sum(int v1, int v2, int v3, int v4) {</span>
<span class="udiff-line-modified-removed">-             return v1 + v2 + v3 + v4;</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-         private static int sum(int v1, int v2, int v3, int v4, int v5) {</span>
<span class="udiff-line-modified-removed">-             return v1 + v2 + v3 + v4 + v5;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         private static int sum(int v1, int v2, int v3, int v4, int v5, int v6) {</span>
<span class="udiff-line-removed">-             return v1 + v2 + v3 + v4 + v5 + v6;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         private static int sum(int v1, int v2, int v3, int v4, int v5, int v6, int v7) {</span>
<span class="udiff-line-removed">-             return v1 + v2 + v3 + v4 + v5 + v6 + v7;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         private static int sum(int v1, int v2, int v3, int v4, int v5, int v6, int v7, int v8) {</span>
<span class="udiff-line-removed">-             return v1 + v2 + v3 + v4 + v5 + v6 + v7 + v8;</span>
<span class="udiff-line-modified-added">+         // Insert the initialLengthCoder value into the final mixer, then</span>
<span class="udiff-line-modified-added">+         // fold that into the base method handle</span>
<span class="udiff-line-modified-added">+         if (ac &gt;= 0) {</span>
<span class="udiff-line-modified-added">+             mix = MethodHandles.insertArguments(mix, 0, initialLengthCoder);</span>
<span class="udiff-line-modified-added">+             mh = MethodHandles.foldArgumentsWithCombiner(mh, 0, mix,</span>
<span class="udiff-line-modified-added">+                     1 + ac // selected argument</span>
<span class="udiff-line-modified-added">+             );</span>
<span class="udiff-line-modified-added">+         } else {</span>
<span class="udiff-line-modified-added">+             // No mixer (constants only concat), insert initialLengthCoder directly</span>
<span class="udiff-line-modified-added">+             mh = MethodHandles.insertArguments(mh, 0, initialLengthCoder);</span>
          }
  
<span class="udiff-line-modified-removed">-         private static int sum(int initial, int[] vs) {</span>
<span class="udiff-line-removed">-             int sum = initial;</span>
<span class="udiff-line-removed">-             for (int v : vs) {</span>
<span class="udiff-line-removed">-                 sum += v;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             return sum;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-modified-added">+         // The method handle shape here is (&lt;args&gt;).</span>
  
<span class="udiff-line-modified-removed">-         private static final Lookup MHSBS_LOOKUP = lookup();</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-         private static final ConcurrentMap&lt;Integer, MethodHandle&gt; SUMMERS;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // This one is deliberately non-lambdified to optimize startup time:</span>
<span class="udiff-line-removed">-         private static final Function&lt;Integer, MethodHandle&gt; SUMMER = new Function&lt;Integer, MethodHandle&gt;() {</span>
<span class="udiff-line-removed">-             @Override</span>
<span class="udiff-line-removed">-             public MethodHandle apply(Integer cnt) {</span>
<span class="udiff-line-removed">-                 if (cnt == 1) {</span>
<span class="udiff-line-removed">-                     return MethodHandles.identity(int.class);</span>
<span class="udiff-line-removed">-                 } else if (cnt &lt;= 8) {</span>
<span class="udiff-line-removed">-                     // Variable-arity collectors are not as efficient as small-count methods,</span>
<span class="udiff-line-removed">-                     // unroll some initial sizes.</span>
<span class="udiff-line-removed">-                     Class&lt;?&gt;[] cls = new Class&lt;?&gt;[cnt];</span>
<span class="udiff-line-removed">-                     Arrays.fill(cls, int.class);</span>
<span class="udiff-line-removed">-                     return lookupStatic(MHSBS_LOOKUP, MethodHandleStringBuilderStrategy.class, &quot;sum&quot;, int.class, cls);</span>
<span class="udiff-line-removed">-                 } else {</span>
<span class="udiff-line-removed">-                     return lookupStatic(MHSBS_LOOKUP, MethodHandleStringBuilderStrategy.class, &quot;sum&quot;, int.class, int.class, int[].class)</span>
<span class="udiff-line-removed">-                             .asCollector(int[].class, cnt - 1);</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-         };</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         private static final MethodHandle NEW_STRING_BUILDER, STRING_LENGTH, BUILDER_TO_STRING, BUILDER_TO_STRING_CHECKED;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         static {</span>
<span class="udiff-line-removed">-             SUMMERS = new ConcurrentHashMap&lt;&gt;();</span>
<span class="udiff-line-removed">-             Lookup publicLookup = MethodHandles.publicLookup();</span>
<span class="udiff-line-removed">-             NEW_STRING_BUILDER = lookupConstructor(publicLookup, StringBuilder.class, int.class);</span>
<span class="udiff-line-removed">-             STRING_LENGTH = lookupVirtual(publicLookup, String.class, &quot;length&quot;, int.class);</span>
<span class="udiff-line-removed">-             BUILDER_TO_STRING = lookupVirtual(publicLookup, StringBuilder.class, &quot;toString&quot;, String.class);</span>
<span class="udiff-line-removed">-             if (DEBUG) {</span>
<span class="udiff-line-removed">-                 BUILDER_TO_STRING_CHECKED = lookupStatic(MHSBS_LOOKUP, MethodHandleStringBuilderStrategy.class,</span>
<span class="udiff-line-removed">-                         &quot;toStringChecked&quot;, String.class, StringBuilder.class);</span>
<span class="udiff-line-removed">-             } else {</span>
<span class="udiff-line-removed">-                 BUILDER_TO_STRING_CHECKED = null;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-modified-added">+         // Apply filters, converting the arguments:</span>
<span class="udiff-line-modified-added">+         if (filters != null) {</span>
<span class="udiff-line-modified-added">+             mh = MethodHandles.filterArguments(mh, 0, filters);</span>
          }
  
<span class="udiff-line-added">+         return mh;</span>
      }
  
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     /**</span>
<span class="udiff-line-modified-removed">-      * &lt;p&gt;&lt;b&gt;{@link Strategy#MH_INLINE_SIZED_EXACT}: &quot;MethodHandles inline,</span>
<span class="udiff-line-removed">-      * sized exactly&quot;.&lt;/b&gt;</span>
<span class="udiff-line-removed">-      *</span>
<span class="udiff-line-removed">-      * &lt;p&gt;This strategy replicates what StringBuilders are doing: it builds the</span>
<span class="udiff-line-removed">-      * byte[] array on its own and passes that byte[] array to String</span>
<span class="udiff-line-removed">-      * constructor. This strategy requires access to some private APIs in JDK,</span>
<span class="udiff-line-removed">-      * most notably, the read-only Integer/Long.stringSize methods that measure</span>
<span class="udiff-line-removed">-      * the character length of the integers, and the private String constructor</span>
<span class="udiff-line-removed">-      * that accepts byte[] arrays without copying. While this strategy assumes a</span>
<span class="udiff-line-removed">-      * particular implementation details for String, this opens the door for</span>
<span class="udiff-line-removed">-      * building a very optimal concatenation sequence. This is the only strategy</span>
<span class="udiff-line-removed">-      * that requires porting if there are private JDK changes occur.</span>
<span class="udiff-line-removed">-      */</span>
<span class="udiff-line-removed">-     private static final class MethodHandleInlineCopyStrategy {</span>
<span class="udiff-line-removed">-         private MethodHandleInlineCopyStrategy() {</span>
<span class="udiff-line-removed">-             // no instantiation</span>
<span class="udiff-line-modified-added">+     private static MethodHandle prepender(String prefix, Class&lt;?&gt; cl) {</span>
<span class="udiff-line-modified-added">+         if (prefix == null) {</span>
<span class="udiff-line-modified-added">+             return NULL_PREPENDERS.computeIfAbsent(cl, NULL_PREPEND);</span>
          }
<span class="udiff-line-added">+         return MethodHandles.insertArguments(</span>
<span class="udiff-line-added">+                         PREPENDERS.computeIfAbsent(cl, PREPEND), 3, prefix);</span>
<span class="udiff-line-added">+     }</span>
  
<span class="udiff-line-modified-removed">-         static MethodHandle generate(MethodType mt, Recipe recipe) throws Throwable {</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-             // Fast-path two-argument Object + Object concatenations</span>
<span class="udiff-line-removed">-             if (recipe.getElements().size() == 2) {</span>
<span class="udiff-line-removed">-                 // Two object arguments</span>
<span class="udiff-line-removed">-                 if (mt.parameterCount() == 2 &amp;&amp;</span>
<span class="udiff-line-removed">-                     !mt.parameterType(0).isPrimitive() &amp;&amp;</span>
<span class="udiff-line-removed">-                     !mt.parameterType(1).isPrimitive() &amp;&amp;</span>
<span class="udiff-line-removed">-                     recipe.getElements().get(0).getTag() == TAG_ARG &amp;&amp;</span>
<span class="udiff-line-removed">-                     recipe.getElements().get(1).getTag() == TAG_ARG) {</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                     return simpleConcat();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                 } else if (mt.parameterCount() == 1 &amp;&amp;</span>
<span class="udiff-line-removed">-                            !mt.parameterType(0).isPrimitive()) {</span>
<span class="udiff-line-removed">-                     // One Object argument, one constant</span>
<span class="udiff-line-removed">-                     MethodHandle mh = simpleConcat();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                     if (recipe.getElements().get(0).getTag() == TAG_CONST &amp;&amp;</span>
<span class="udiff-line-removed">-                         recipe.getElements().get(1).getTag() == TAG_ARG) {</span>
<span class="udiff-line-removed">-                         // First recipe element is a constant</span>
<span class="udiff-line-removed">-                         return MethodHandles.insertArguments(mh, 0,</span>
<span class="udiff-line-removed">-                                 recipe.getElements().get(0).getValue());</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                     } else if (recipe.getElements().get(1).getTag() == TAG_CONST &amp;&amp;</span>
<span class="udiff-line-removed">-                                recipe.getElements().get(0).getTag() == TAG_ARG) {</span>
<span class="udiff-line-removed">-                         // Second recipe element is a constant</span>
<span class="udiff-line-removed">-                         return MethodHandles.insertArguments(mh, 1,</span>
<span class="udiff-line-removed">-                                 recipe.getElements().get(1).getValue());</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-                 // else... fall-through to slow-path</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             // Create filters and obtain filtered parameter types. Filters would be used in the beginning</span>
<span class="udiff-line-removed">-             // to convert the incoming arguments into the arguments we can process (e.g. Objects -&gt; Strings).</span>
<span class="udiff-line-removed">-             // The filtered argument type list is used all over in the combinators below.</span>
<span class="udiff-line-removed">-             Class&lt;?&gt;[] ptypes = mt.parameterArray();</span>
<span class="udiff-line-removed">-             MethodHandle[] filters = null;</span>
<span class="udiff-line-removed">-             for (int i = 0; i &lt; ptypes.length; i++) {</span>
<span class="udiff-line-removed">-                 MethodHandle filter = Stringifiers.forMost(ptypes[i]);</span>
<span class="udiff-line-removed">-                 if (filter != null) {</span>
<span class="udiff-line-removed">-                     if (filters == null) {</span>
<span class="udiff-line-removed">-                         filters = new MethodHandle[ptypes.length];</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                     filters[i] = filter;</span>
<span class="udiff-line-removed">-                     ptypes[i] = filter.type().returnType();</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             // Start building the combinator tree. The tree &quot;starts&quot; with (&lt;parameters&gt;)String, and &quot;finishes&quot;</span>
<span class="udiff-line-removed">-             // with the (byte[], long)String shape to invoke newString in StringConcatHelper. The combinators are</span>
<span class="udiff-line-removed">-             // assembled bottom-up, which makes the code arguably hard to read.</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             // Drop all remaining parameter types, leave only helper arguments:</span>
<span class="udiff-line-removed">-             MethodHandle mh;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             mh = MethodHandles.dropArguments(newString(), 2, ptypes);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             long initialLengthCoder = INITIAL_CODER;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             // Mix in prependers. This happens when (byte[], long) = (storage, indexCoder) is already</span>
<span class="udiff-line-removed">-             // known from the combinators below. We are assembling the string backwards, so the index coded</span>
<span class="udiff-line-removed">-             // into indexCoder is the *ending* index.</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             // We need one prepender per argument, but also need to fold in constants. We do so by greedily</span>
<span class="udiff-line-removed">-             // create prependers that fold in surrounding constants into the argument prepender. This reduces</span>
<span class="udiff-line-removed">-             // the number of unique MH combinator tree shapes we&#39;ll create in an application.</span>
<span class="udiff-line-removed">-             String prefixConstant = null, suffixConstant = null;</span>
<span class="udiff-line-removed">-             int pos = -1;</span>
<span class="udiff-line-removed">-             for (RecipeElement el : recipe.getElements()) {</span>
<span class="udiff-line-removed">-                 // Do the prepend, and put &quot;new&quot; index at index 1</span>
<span class="udiff-line-removed">-                 switch (el.getTag()) {</span>
<span class="udiff-line-removed">-                     case TAG_CONST: {</span>
<span class="udiff-line-removed">-                         String constantValue = el.getValue();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                         // Eagerly update the initialLengthCoder value</span>
<span class="udiff-line-removed">-                         initialLengthCoder = (long)mixer(String.class).invoke(initialLengthCoder, constantValue);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                         if (pos &lt; 0) {</span>
<span class="udiff-line-removed">-                             // Collecting into prefixConstant</span>
<span class="udiff-line-removed">-                             prefixConstant = prefixConstant == null ? constantValue : prefixConstant + constantValue;</span>
<span class="udiff-line-removed">-                         } else {</span>
<span class="udiff-line-removed">-                             // Collecting into suffixConstant</span>
<span class="udiff-line-removed">-                             suffixConstant = suffixConstant == null ? constantValue : suffixConstant + constantValue;</span>
<span class="udiff-line-removed">-                         }</span>
<span class="udiff-line-removed">-                         break;</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                     case TAG_ARG: {</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                         if (pos &gt;= 0) {</span>
<span class="udiff-line-removed">-                             // Flush the previous non-constant arg with any prefix/suffix constant</span>
<span class="udiff-line-removed">-                             mh = MethodHandles.filterArgumentsWithCombiner(</span>
<span class="udiff-line-removed">-                                 mh, 1,</span>
<span class="udiff-line-removed">-                                 prepender(prefixConstant, ptypes[pos], suffixConstant),</span>
<span class="udiff-line-removed">-                                 1, 0, // indexCoder, storage</span>
<span class="udiff-line-removed">-                                 2 + pos  // selected argument</span>
<span class="udiff-line-removed">-                             );</span>
<span class="udiff-line-removed">-                             prefixConstant = suffixConstant = null;</span>
<span class="udiff-line-removed">-                         }</span>
<span class="udiff-line-removed">-                         // Mark the pos of next non-constant arg</span>
<span class="udiff-line-removed">-                         pos = el.getArgPos();</span>
<span class="udiff-line-removed">-                         break;</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                     default:</span>
<span class="udiff-line-removed">-                         throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             // Insert any trailing args, constants</span>
<span class="udiff-line-removed">-             if (pos &gt;= 0) {</span>
<span class="udiff-line-removed">-                 mh = MethodHandles.filterArgumentsWithCombiner(</span>
<span class="udiff-line-removed">-                     mh, 1,</span>
<span class="udiff-line-removed">-                     prepender(prefixConstant, ptypes[pos], suffixConstant),</span>
<span class="udiff-line-removed">-                     1, 0, // indexCoder, storage</span>
<span class="udiff-line-removed">-                     2 + pos  // selected argument</span>
<span class="udiff-line-removed">-                 );</span>
<span class="udiff-line-removed">-             } else if (prefixConstant != null) {</span>
<span class="udiff-line-removed">-                 assert (suffixConstant == null);</span>
<span class="udiff-line-removed">-                 // Sole prefixConstant can only happen if there were no non-constant arguments</span>
<span class="udiff-line-removed">-                 mh = MethodHandles.filterArgumentsWithCombiner(</span>
<span class="udiff-line-removed">-                     mh, 1,</span>
<span class="udiff-line-removed">-                     MethodHandles.insertArguments(prepender(null, String.class, null), 2, prefixConstant),</span>
<span class="udiff-line-removed">-                     1, 0 // indexCoder, storage</span>
<span class="udiff-line-removed">-                 );</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             // Fold in byte[] instantiation at argument 0</span>
<span class="udiff-line-removed">-             mh = MethodHandles.foldArgumentsWithCombiner(mh, 0, newArray(),</span>
<span class="udiff-line-removed">-                     1 // index</span>
<span class="udiff-line-removed">-             );</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             // Start combining length and coder mixers.</span>
<span class="udiff-line-removed">-             //</span>
<span class="udiff-line-removed">-             // Length is easy: constant lengths can be computed on the spot, and all non-constant</span>
<span class="udiff-line-removed">-             // shapes have been either converted to Strings, or explicit methods for getting the</span>
<span class="udiff-line-removed">-             // string length out of primitives are provided.</span>
<span class="udiff-line-removed">-             //</span>
<span class="udiff-line-removed">-             // Coders are more interesting. Only Object, String and char arguments (and constants)</span>
<span class="udiff-line-removed">-             // can have non-Latin1 encoding. It is easier to blindly convert constants to String,</span>
<span class="udiff-line-removed">-             // and deduce the coder from there. Arguments would be either converted to Strings</span>
<span class="udiff-line-removed">-             // during the initial filtering, or handled by specializations in MIXERS.</span>
<span class="udiff-line-removed">-             //</span>
<span class="udiff-line-removed">-             // The method handle shape before all mixers are combined in is:</span>
<span class="udiff-line-removed">-             //   (long, &lt;args&gt;)String = (&quot;indexCoder&quot;, &lt;args&gt;)</span>
<span class="udiff-line-removed">-             //</span>
<span class="udiff-line-removed">-             // We will bind the initialLengthCoder value to the last mixer (the one that will be</span>
<span class="udiff-line-removed">-             // executed first), then fold that in. This leaves the shape after all mixers are</span>
<span class="udiff-line-removed">-             // combined in as:</span>
<span class="udiff-line-removed">-             //   (&lt;args&gt;)String = (&lt;args&gt;)</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             int ac = -1;</span>
<span class="udiff-line-removed">-             MethodHandle mix = null;</span>
<span class="udiff-line-removed">-             for (RecipeElement el : recipe.getElements()) {</span>
<span class="udiff-line-removed">-                 switch (el.getTag()) {</span>
<span class="udiff-line-removed">-                     case TAG_CONST:</span>
<span class="udiff-line-removed">-                         // Constants already handled in the code above</span>
<span class="udiff-line-removed">-                         break;</span>
<span class="udiff-line-removed">-                     case TAG_ARG:</span>
<span class="udiff-line-removed">-                         if (ac &gt;= 0) {</span>
<span class="udiff-line-removed">-                             // Compute new &quot;index&quot; in-place using old value plus the appropriate argument.</span>
<span class="udiff-line-removed">-                             mh = MethodHandles.filterArgumentsWithCombiner(mh, 0, mix,</span>
<span class="udiff-line-removed">-                                     0, // old-index</span>
<span class="udiff-line-removed">-                                     1 + ac // selected argument</span>
<span class="udiff-line-removed">-                             );</span>
<span class="udiff-line-removed">-                         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                         ac = el.getArgPos();</span>
<span class="udiff-line-removed">-                         Class&lt;?&gt; argClass = ptypes[ac];</span>
<span class="udiff-line-removed">-                         mix = mixer(argClass);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                         break;</span>
<span class="udiff-line-removed">-                     default:</span>
<span class="udiff-line-removed">-                         throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             // Insert the initialLengthCoder value into the final mixer, then</span>
<span class="udiff-line-removed">-             // fold that into the base method handle</span>
<span class="udiff-line-removed">-             if (ac &gt;= 0) {</span>
<span class="udiff-line-removed">-                 mix = MethodHandles.insertArguments(mix, 0, initialLengthCoder);</span>
<span class="udiff-line-removed">-                 mh = MethodHandles.foldArgumentsWithCombiner(mh, 0, mix,</span>
<span class="udiff-line-removed">-                         1 + ac // selected argument</span>
<span class="udiff-line-removed">-                 );</span>
<span class="udiff-line-removed">-             } else {</span>
<span class="udiff-line-removed">-                 // No mixer (constants only concat), insert initialLengthCoder directly</span>
<span class="udiff-line-removed">-                 mh = MethodHandles.insertArguments(mh, 0, initialLengthCoder);</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             // The method handle shape here is (&lt;args&gt;).</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             // Apply filters, converting the arguments:</span>
<span class="udiff-line-removed">-             if (filters != null) {</span>
<span class="udiff-line-removed">-                 mh = MethodHandles.filterArguments(mh, 0, filters);</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-modified-added">+     private static MethodHandle mixer(Class&lt;?&gt; cl) {</span>
<span class="udiff-line-modified-added">+         return MIXERS.computeIfAbsent(cl, MIX);</span>
<span class="udiff-line-modified-added">+     }</span>
  
<span class="udiff-line-modified-removed">-             return mh;</span>
<span class="udiff-line-modified-added">+     // These are deliberately not lambdas to optimize startup time:</span>
<span class="udiff-line-added">+     private static final Function&lt;Class&lt;?&gt;, MethodHandle&gt; PREPEND = new Function&lt;&gt;() {</span>
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         public MethodHandle apply(Class&lt;?&gt; c) {</span>
<span class="udiff-line-added">+             return JLA.stringConcatHelper(&quot;prepend&quot;,</span>
<span class="udiff-line-added">+                     methodType(long.class, long.class, byte[].class,</span>
<span class="udiff-line-added">+                             Wrapper.asPrimitiveType(c), String.class));</span>
          }
<span class="udiff-line-added">+     };</span>
  
<span class="udiff-line-modified-removed">-         private static MethodHandle prepender(String prefix, Class&lt;?&gt; cl, String suffix) {</span>
<span class="udiff-line-modified-added">+     private static final Function&lt;Class&lt;?&gt;, MethodHandle&gt; NULL_PREPEND = new Function&lt;&gt;() {</span>
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         public MethodHandle apply(Class&lt;?&gt; c) {</span>
              return MethodHandles.insertArguments(
<span class="udiff-line-modified-removed">-                     MethodHandles.insertArguments(</span>
<span class="udiff-line-removed">-                         PREPENDERS.computeIfAbsent(cl, PREPEND), 2, prefix), 3, suffix);</span>
<span class="udiff-line-modified-added">+                             PREPENDERS.computeIfAbsent(c, PREPEND), 3, (String)null);</span>
          }
<span class="udiff-line-added">+     };</span>
  
<span class="udiff-line-modified-removed">-         private static MethodHandle mixer(Class&lt;?&gt; cl) {</span>
<span class="udiff-line-modified-removed">-             return MIXERS.computeIfAbsent(cl, MIX);</span>
<span class="udiff-line-modified-added">+     private static final Function&lt;Class&lt;?&gt;, MethodHandle&gt; MIX = new Function&lt;&gt;() {</span>
<span class="udiff-line-modified-added">+         @Override</span>
<span class="udiff-line-added">+         public MethodHandle apply(Class&lt;?&gt; c) {</span>
<span class="udiff-line-added">+             return JLA.stringConcatHelper(&quot;mix&quot;, methodType(long.class, long.class, Wrapper.asPrimitiveType(c)));</span>
          }
<span class="udiff-line-added">+     };</span>
  
<span class="udiff-line-modified-removed">-         // This one is deliberately non-lambdified to optimize startup time:</span>
<span class="udiff-line-modified-removed">-         private static final Function&lt;Class&lt;?&gt;, MethodHandle&gt; PREPEND = new Function&lt;&gt;() {</span>
<span class="udiff-line-modified-removed">-             @Override</span>
<span class="udiff-line-modified-removed">-             public MethodHandle apply(Class&lt;?&gt; c) {</span>
<span class="udiff-line-removed">-                 return JLA.stringConcatHelper(&quot;prepend&quot;,</span>
<span class="udiff-line-removed">-                             methodType(long.class, long.class, byte[].class,</span>
<span class="udiff-line-removed">-                                        String.class, Wrapper.asPrimitiveType(c), String.class));</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-         };</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // This one is deliberately non-lambdified to optimize startup time:</span>
<span class="udiff-line-removed">-         private static final Function&lt;Class&lt;?&gt;, MethodHandle&gt; MIX = new Function&lt;&gt;() {</span>
<span class="udiff-line-removed">-             @Override</span>
<span class="udiff-line-removed">-             public MethodHandle apply(Class&lt;?&gt; c) {</span>
<span class="udiff-line-removed">-                 return JLA.stringConcatHelper(&quot;mix&quot;, methodType(long.class, long.class, Wrapper.asPrimitiveType(c)));</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-         };</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         private @Stable static MethodHandle SIMPLE_CONCAT;</span>
<span class="udiff-line-removed">-         private static MethodHandle simpleConcat() {</span>
<span class="udiff-line-removed">-             if (SIMPLE_CONCAT == null) {</span>
<span class="udiff-line-removed">-                 SIMPLE_CONCAT = JLA.stringConcatHelper(&quot;simpleConcat&quot;, methodType(String.class, Object.class, Object.class));</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             return SIMPLE_CONCAT;</span>
<span class="udiff-line-modified-added">+     private @Stable static MethodHandle SIMPLE_CONCAT;</span>
<span class="udiff-line-modified-added">+     private static MethodHandle simpleConcat() {</span>
<span class="udiff-line-modified-added">+         if (SIMPLE_CONCAT == null) {</span>
<span class="udiff-line-modified-added">+             SIMPLE_CONCAT = JLA.stringConcatHelper(&quot;simpleConcat&quot;, methodType(String.class, Object.class, Object.class));</span>
          }
<span class="udiff-line-added">+         return SIMPLE_CONCAT;</span>
<span class="udiff-line-added">+     }</span>
  
<span class="udiff-line-modified-removed">-         private @Stable static MethodHandle NEW_STRING;</span>
<span class="udiff-line-modified-removed">-         private static MethodHandle newString() {</span>
<span class="udiff-line-modified-removed">-             MethodHandle mh = NEW_STRING;</span>
<span class="udiff-line-modified-removed">-             if (mh == null) {</span>
<span class="udiff-line-modified-removed">-                 NEW_STRING = mh =</span>
<span class="udiff-line-modified-added">+     private @Stable static MethodHandle NEW_STRING;</span>
<span class="udiff-line-modified-added">+     private static MethodHandle newString() {</span>
<span class="udiff-line-modified-added">+         MethodHandle mh = NEW_STRING;</span>
<span class="udiff-line-modified-added">+         if (mh == null) {</span>
<span class="udiff-line-modified-added">+             NEW_STRING = mh =</span>
                      JLA.stringConcatHelper(&quot;newString&quot;, methodType(String.class, byte[].class, long.class));
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             return mh;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         private @Stable static MethodHandle NEW_ARRAY;</span>
<span class="udiff-line-removed">-         private static MethodHandle newArray() {</span>
<span class="udiff-line-removed">-             MethodHandle mh = NEW_ARRAY;</span>
<span class="udiff-line-removed">-             if (mh == null) {</span>
<span class="udiff-line-removed">-                 NEW_ARRAY = mh =</span>
<span class="udiff-line-removed">-                     JLA.stringConcatHelper(&quot;newArray&quot;, methodType(byte[].class, long.class));</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             return mh;</span>
          }
<span class="udiff-line-added">+         return mh;</span>
<span class="udiff-line-added">+     }</span>
  
<span class="udiff-line-modified-removed">-         private static final ConcurrentMap&lt;Class&lt;?&gt;, MethodHandle&gt; PREPENDERS;</span>
<span class="udiff-line-modified-removed">-         private static final ConcurrentMap&lt;Class&lt;?&gt;, MethodHandle&gt; MIXERS;</span>
<span class="udiff-line-modified-removed">-         private static final long INITIAL_CODER;</span>
<span class="udiff-line-modified-added">+     private @Stable static MethodHandle NEW_ARRAY_SUFFIX;</span>
<span class="udiff-line-modified-added">+     private static MethodHandle newArrayWithSuffix(String suffix) {</span>
<span class="udiff-line-modified-added">+         MethodHandle mh = NEW_ARRAY_SUFFIX;</span>
<span class="udiff-line-added">+         if (mh == null) {</span>
<span class="udiff-line-added">+             NEW_ARRAY_SUFFIX = mh =</span>
<span class="udiff-line-added">+                     JLA.stringConcatHelper(&quot;newArrayWithSuffix&quot;,</span>
<span class="udiff-line-added">+                             methodType(byte[].class, String.class, long.class));</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         return MethodHandles.insertArguments(mh, 0, suffix);</span>
<span class="udiff-line-added">+     }</span>
  
<span class="udiff-line-modified-removed">-         static {</span>
<span class="udiff-line-modified-removed">-             INITIAL_CODER = JLA.stringConcatInitialCoder();</span>
<span class="udiff-line-modified-removed">-             PREPENDERS = new ConcurrentHashMap&lt;&gt;();</span>
<span class="udiff-line-modified-removed">-             MIXERS = new ConcurrentHashMap&lt;&gt;();</span>
<span class="udiff-line-modified-added">+     private @Stable static MethodHandle NEW_ARRAY;</span>
<span class="udiff-line-modified-added">+     private static MethodHandle newArray() {</span>
<span class="udiff-line-modified-added">+         MethodHandle mh = NEW_ARRAY;</span>
<span class="udiff-line-modified-added">+         if (mh == null) {</span>
<span class="udiff-line-added">+             NEW_ARRAY = mh =</span>
<span class="udiff-line-added">+                     JLA.stringConcatHelper(&quot;newArray&quot;, methodType(byte[].class, long.class));</span>
          }
<span class="udiff-line-added">+         return mh;</span>
      }
  
      /**
<span class="udiff-line-modified-removed">-      * Public gateways to public &quot;stringify&quot; methods. These methods have the form String apply(T obj), and normally</span>
<span class="udiff-line-modified-removed">-      * delegate to {@code String.valueOf}, depending on argument&#39;s type.</span>
<span class="udiff-line-modified-added">+      * Public gateways to public &quot;stringify&quot; methods. These methods have the</span>
<span class="udiff-line-modified-added">+      * form String apply(T obj), and normally delegate to {@code String.valueOf},</span>
<span class="udiff-line-added">+      * depending on argument&#39;s type.</span>
       */
<span class="udiff-line-modified-removed">-     private static final class Stringifiers {</span>
<span class="udiff-line-modified-removed">-         private Stringifiers() {</span>
<span class="udiff-line-modified-removed">-             // no instantiation</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-         private static final MethodHandle OBJECT_INSTANCE =</span>
<span class="udiff-line-modified-removed">-                 JLA.stringConcatHelper(&quot;stringOf&quot;, methodType(String.class, Object.class));</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-         private static class FloatStringifiers {</span>
<span class="udiff-line-modified-removed">-             private static final MethodHandle FLOAT_INSTANCE =</span>
<span class="udiff-line-modified-added">+     private @Stable static MethodHandle OBJECT_STRINGIFIER;</span>
<span class="udiff-line-modified-added">+     private static MethodHandle objectStringifier() {</span>
<span class="udiff-line-modified-added">+         MethodHandle mh = OBJECT_STRINGIFIER;</span>
<span class="udiff-line-modified-added">+         if (mh == null) {</span>
<span class="udiff-line-modified-added">+             OBJECT_STRINGIFIER = mh =</span>
<span class="udiff-line-modified-added">+                     JLA.stringConcatHelper(&quot;stringOf&quot;, methodType(String.class, Object.class));</span>
<span class="udiff-line-modified-added">+         }</span>
<span class="udiff-line-modified-added">+         return mh;</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+     private @Stable static MethodHandle FLOAT_STRINGIFIER;</span>
<span class="udiff-line-added">+     private static MethodHandle floatStringifier() {</span>
<span class="udiff-line-added">+         MethodHandle mh = FLOAT_STRINGIFIER;</span>
<span class="udiff-line-added">+         if (mh == null) {</span>
<span class="udiff-line-added">+             FLOAT_STRINGIFIER = mh =</span>
                      lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, float.class);
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             private static final MethodHandle DOUBLE_INSTANCE =</span>
<span class="udiff-line-removed">-                     lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, double.class);</span>
          }
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-         private static class StringifierAny extends ClassValue&lt;MethodHandle&gt; {</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-             private static final ClassValue&lt;MethodHandle&gt; INSTANCE = new StringifierAny();</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-             @Override</span>
<span class="udiff-line-modified-removed">-             protected MethodHandle computeValue(Class&lt;?&gt; cl) {</span>
<span class="udiff-line-modified-removed">-                 if (cl == byte.class || cl == short.class || cl == int.class) {</span>
<span class="udiff-line-removed">-                     return lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, int.class);</span>
<span class="udiff-line-removed">-                 } else if (cl == boolean.class) {</span>
<span class="udiff-line-removed">-                     return lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, boolean.class);</span>
<span class="udiff-line-removed">-                 } else if (cl == char.class) {</span>
<span class="udiff-line-removed">-                     return lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, char.class);</span>
<span class="udiff-line-removed">-                 } else if (cl == long.class) {</span>
<span class="udiff-line-removed">-                     return lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, long.class);</span>
<span class="udiff-line-removed">-                 } else {</span>
<span class="udiff-line-removed">-                     MethodHandle mh = forMost(cl);</span>
<span class="udiff-line-removed">-                     if (mh != null) {</span>
<span class="udiff-line-removed">-                         return mh;</span>
<span class="udiff-line-removed">-                     } else {</span>
<span class="udiff-line-removed">-                         throw new IllegalStateException(&quot;Unknown class: &quot; + cl);</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         /**</span>
<span class="udiff-line-removed">-          * Returns a stringifier for references and floats/doubles only.</span>
<span class="udiff-line-removed">-          * Always returns null for other primitives.</span>
<span class="udiff-line-removed">-          *</span>
<span class="udiff-line-removed">-          * @param t class to stringify</span>
<span class="udiff-line-removed">-          * @return stringifier; null, if not available</span>
<span class="udiff-line-removed">-          */</span>
<span class="udiff-line-removed">-         static MethodHandle forMost(Class&lt;?&gt; t) {</span>
<span class="udiff-line-removed">-             if (!t.isPrimitive()) {</span>
<span class="udiff-line-removed">-                 return OBJECT_INSTANCE;</span>
<span class="udiff-line-removed">-             } else if (t == float.class) {</span>
<span class="udiff-line-removed">-                 return FloatStringifiers.FLOAT_INSTANCE;</span>
<span class="udiff-line-removed">-             } else if (t == double.class) {</span>
<span class="udiff-line-removed">-                 return FloatStringifiers.DOUBLE_INSTANCE;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             return null;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         /**</span>
<span class="udiff-line-removed">-          * Returns a stringifier for any type. Never returns null.</span>
<span class="udiff-line-removed">-          *</span>
<span class="udiff-line-removed">-          * @param t class to stringify</span>
<span class="udiff-line-removed">-          * @return stringifier</span>
<span class="udiff-line-removed">-          */</span>
<span class="udiff-line-removed">-         static MethodHandle forAny(Class&lt;?&gt; t) {</span>
<span class="udiff-line-removed">-             return StringifierAny.INSTANCE.get(t);</span>
<span class="udiff-line-modified-added">+         return mh;</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+     private @Stable static MethodHandle DOUBLE_STRINGIFIER;</span>
<span class="udiff-line-modified-added">+     private static MethodHandle doubleStringifier() {</span>
<span class="udiff-line-modified-added">+         MethodHandle mh = DOUBLE_STRINGIFIER;</span>
<span class="udiff-line-modified-added">+         if (mh == null) {</span>
<span class="udiff-line-modified-added">+             DOUBLE_STRINGIFIER = mh =</span>
<span class="udiff-line-modified-added">+                     lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, double.class);</span>
          }
<span class="udiff-line-added">+         return mh;</span>
      }
  
<span class="udiff-line-modified-removed">-     /* ------------------------------- Common utilities ------------------------------------ */</span>
<span class="udiff-line-modified-added">+     private static final ConcurrentMap&lt;Class&lt;?&gt;, MethodHandle&gt; PREPENDERS;</span>
<span class="udiff-line-added">+     private static final ConcurrentMap&lt;Class&lt;?&gt;, MethodHandle&gt; NULL_PREPENDERS;</span>
<span class="udiff-line-added">+     private static final ConcurrentMap&lt;Class&lt;?&gt;, MethodHandle&gt; MIXERS;</span>
<span class="udiff-line-added">+     private static final long INITIAL_CODER;</span>
  
<span class="udiff-line-modified-removed">-     static MethodHandle lookupStatic(Lookup lookup, Class&lt;?&gt; refc, String name, Class&lt;?&gt; rtype, Class&lt;?&gt;... ptypes) {</span>
<span class="udiff-line-modified-removed">-         try {</span>
<span class="udiff-line-modified-removed">-             return lookup.findStatic(refc, name, MethodType.methodType(rtype, ptypes));</span>
<span class="udiff-line-modified-removed">-         } catch (NoSuchMethodException | IllegalAccessException e) {</span>
<span class="udiff-line-modified-removed">-             throw new AssertionError(e);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-modified-added">+     static {</span>
<span class="udiff-line-modified-added">+         INITIAL_CODER = JLA.stringConcatInitialCoder();</span>
<span class="udiff-line-modified-added">+         PREPENDERS = new ConcurrentHashMap&lt;&gt;();</span>
<span class="udiff-line-modified-added">+         NULL_PREPENDERS = new ConcurrentHashMap&lt;&gt;();</span>
<span class="udiff-line-modified-added">+         MIXERS = new ConcurrentHashMap&lt;&gt;();</span>
      }
  
<span class="udiff-line-modified-removed">-     static MethodHandle lookupVirtual(Lookup lookup, Class&lt;?&gt; refc, String name, Class&lt;?&gt; rtype, Class&lt;?&gt;... ptypes) {</span>
<span class="udiff-line-modified-removed">-         try {</span>
<span class="udiff-line-modified-removed">-             return lookup.findVirtual(refc, name, MethodType.methodType(rtype, ptypes));</span>
<span class="udiff-line-modified-removed">-         } catch (NoSuchMethodException | IllegalAccessException e) {</span>
<span class="udiff-line-modified-removed">-             throw new AssertionError(e);</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-added">+     /**</span>
<span class="udiff-line-modified-added">+      * Returns a stringifier for references and floats/doubles only.</span>
<span class="udiff-line-modified-added">+      * Always returns null for other primitives.</span>
<span class="udiff-line-modified-added">+      *</span>
<span class="udiff-line-modified-added">+      * @param t class to stringify</span>
<span class="udiff-line-modified-added">+      * @return stringifier; null, if not available</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     private static MethodHandle stringifierFor(Class&lt;?&gt; t) {</span>
<span class="udiff-line-added">+         if (!t.isPrimitive()) {</span>
<span class="udiff-line-added">+             return objectStringifier();</span>
<span class="udiff-line-added">+         } else if (t == float.class) {</span>
<span class="udiff-line-added">+             return floatStringifier();</span>
<span class="udiff-line-added">+         } else if (t == double.class) {</span>
<span class="udiff-line-added">+             return doubleStringifier();</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         return null;</span>
      }
  
<span class="udiff-line-modified-removed">-     static MethodHandle lookupConstructor(Lookup lookup, Class&lt;?&gt; refc, Class&lt;?&gt; ptypes) {</span>
<span class="udiff-line-modified-added">+     private static MethodHandle lookupStatic(Lookup lookup, Class&lt;?&gt; refc, String name,</span>
<span class="udiff-line-added">+                                      Class&lt;?&gt; rtype, Class&lt;?&gt;... ptypes) {</span>
          try {
<span class="udiff-line-modified-removed">-             return lookup.findConstructor(refc, MethodType.methodType(void.class, ptypes));</span>
<span class="udiff-line-modified-added">+             return lookup.findStatic(refc, name, MethodType.methodType(rtype, ptypes));</span>
          } catch (NoSuchMethodException | IllegalAccessException e) {
              throw new AssertionError(e);
          }
      }
  
<span class="udiff-line-removed">-     static int estimateSize(Class&lt;?&gt; cl) {</span>
<span class="udiff-line-removed">-         if (cl == Integer.TYPE) {</span>
<span class="udiff-line-removed">-             return 11; // &quot;-2147483648&quot;</span>
<span class="udiff-line-removed">-         } else if (cl == Boolean.TYPE) {</span>
<span class="udiff-line-removed">-             return 5; // &quot;false&quot;</span>
<span class="udiff-line-removed">-         } else if (cl == Byte.TYPE) {</span>
<span class="udiff-line-removed">-             return 4; // &quot;-128&quot;</span>
<span class="udiff-line-removed">-         } else if (cl == Character.TYPE) {</span>
<span class="udiff-line-removed">-             return 1; // duh</span>
<span class="udiff-line-removed">-         } else if (cl == Short.TYPE) {</span>
<span class="udiff-line-removed">-             return 6; // &quot;-32768&quot;</span>
<span class="udiff-line-removed">-         } else if (cl == Double.TYPE) {</span>
<span class="udiff-line-removed">-             return 26; // apparently, no larger than this, see FloatingDecimal.BinaryToASCIIBuffer.buffer</span>
<span class="udiff-line-removed">-         } else if (cl == Float.TYPE) {</span>
<span class="udiff-line-removed">-             return 26; // apparently, no larger than this, see FloatingDecimal.BinaryToASCIIBuffer.buffer</span>
<span class="udiff-line-removed">-         } else if (cl == Long.TYPE)  {</span>
<span class="udiff-line-removed">-             return 20; // &quot;-9223372036854775808&quot;</span>
<span class="udiff-line-removed">-         } else {</span>
<span class="udiff-line-removed">-             throw new IllegalArgumentException(&quot;Cannot estimate the size for &quot; + cl);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     static Class&lt;?&gt; adaptToStringBuilder(Class&lt;?&gt; c) {</span>
<span class="udiff-line-removed">-         if (c.isPrimitive()) {</span>
<span class="udiff-line-removed">-             if (c == Byte.TYPE || c == Short.TYPE) {</span>
<span class="udiff-line-removed">-                 return int.class;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-         } else {</span>
<span class="udiff-line-removed">-             if (c != String.class) {</span>
<span class="udiff-line-removed">-                 return Object.class;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         return c;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
      private StringConcatFactory() {
          // no instantiation
      }
<span class="udiff-line-removed">- </span>
  }
</pre>
<center><a href="MethodHandles.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="VarForm.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
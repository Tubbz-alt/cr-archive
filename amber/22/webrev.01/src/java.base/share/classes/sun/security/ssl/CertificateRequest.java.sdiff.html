<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/ssl/CertificateRequest.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../nio/ch/FileChannelImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SSLExtension.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/CertificateRequest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
183             }
184 
185             if (listLen &gt; 0) {
186                 this.authorities = new LinkedList&lt;&gt;();
187                 while (listLen &gt; 0) {
188                     // opaque DistinguishedName&lt;1..2^16-1&gt;;
189                     byte[] encoded = Record.getBytes16(m);
190                     listLen -= (2 + encoded.length);
191                     authorities.add(encoded);
192                 }
193             } else {
194                 this.authorities = Collections.emptyList();
195             }
196         }
197 
198         String[] getKeyTypes() {
199             return  ClientCertificateType.getKeyTypes(types);
200         }
201 
202         X500Principal[] getAuthorities() {
<span class="line-modified">203             List&lt;X500Principal&gt; principals =</span>
<span class="line-modified">204                     new ArrayList&lt;&gt;(authorities.size());</span>
205             for (byte[] encoded : authorities) {
<span class="line-modified">206                 X500Principal principal = new X500Principal(encoded);</span>
<span class="line-removed">207                 principals.add(principal);</span>
208             }
209 
<span class="line-modified">210             return principals.toArray(new X500Principal[0]);</span>
211         }
212 
213         @Override
214         public SSLHandshake handshakeType() {
215             return SSLHandshake.CERTIFICATE_REQUEST;
216         }
217 
218         @Override
219         public int messageLength() {
220             int len = 1 + types.length + 2;
221             for (byte[] encoded : authorities) {
222                 len += encoded.length + 2;
223             }
224             return len;
225         }
226 
227         @Override
228         public void send(HandshakeOutStream hos) throws IOException {
229             hos.putBytes8(types);
230 
</pre>
<hr />
<pre>
487             }
488 
489             if (listLen &gt; 0) {
490                 this.authorities = new LinkedList&lt;&gt;();
491                 while (listLen &gt; 0) {
492                     // opaque DistinguishedName&lt;1..2^16-1&gt;;
493                     byte[] encoded = Record.getBytes16(m);
494                     listLen -= (2 + encoded.length);
495                     authorities.add(encoded);
496                 }
497             } else {
498                 this.authorities = Collections.emptyList();
499             }
500         }
501 
502         String[] getKeyTypes() {
503             return ClientCertificateType.getKeyTypes(types);
504         }
505 
506         X500Principal[] getAuthorities() {
<span class="line-modified">507             List&lt;X500Principal&gt; principals =</span>
<span class="line-modified">508                     new ArrayList&lt;&gt;(authorities.size());</span>
509             for (byte[] encoded : authorities) {
<span class="line-modified">510                 X500Principal principal = new X500Principal(encoded);</span>
<span class="line-removed">511                 principals.add(principal);</span>
512             }
513 
<span class="line-modified">514             return principals.toArray(new X500Principal[0]);</span>
515         }
516 
517         @Override
518         public SSLHandshake handshakeType() {
519             return SSLHandshake.CERTIFICATE_REQUEST;
520         }
521 
522         @Override
523         public int messageLength() {
524             int len = 1 + types.length + 2 + (algorithmIds.length &lt;&lt; 1) + 2;
525             for (byte[] encoded : authorities) {
526                 len += encoded.length + 2;
527             }
528             return len;
529         }
530 
531         @Override
532         public void send(HandshakeOutStream hos) throws IOException {
533             hos.putBytes8(types);
534 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
183             }
184 
185             if (listLen &gt; 0) {
186                 this.authorities = new LinkedList&lt;&gt;();
187                 while (listLen &gt; 0) {
188                     // opaque DistinguishedName&lt;1..2^16-1&gt;;
189                     byte[] encoded = Record.getBytes16(m);
190                     listLen -= (2 + encoded.length);
191                     authorities.add(encoded);
192                 }
193             } else {
194                 this.authorities = Collections.emptyList();
195             }
196         }
197 
198         String[] getKeyTypes() {
199             return  ClientCertificateType.getKeyTypes(types);
200         }
201 
202         X500Principal[] getAuthorities() {
<span class="line-modified">203             X500Principal[] principals = new X500Principal[authorities.size()];</span>
<span class="line-modified">204             int i = 0;</span>
205             for (byte[] encoded : authorities) {
<span class="line-modified">206                 principals[i++] = new X500Principal(encoded);</span>

207             }
208 
<span class="line-modified">209             return principals;</span>
210         }
211 
212         @Override
213         public SSLHandshake handshakeType() {
214             return SSLHandshake.CERTIFICATE_REQUEST;
215         }
216 
217         @Override
218         public int messageLength() {
219             int len = 1 + types.length + 2;
220             for (byte[] encoded : authorities) {
221                 len += encoded.length + 2;
222             }
223             return len;
224         }
225 
226         @Override
227         public void send(HandshakeOutStream hos) throws IOException {
228             hos.putBytes8(types);
229 
</pre>
<hr />
<pre>
486             }
487 
488             if (listLen &gt; 0) {
489                 this.authorities = new LinkedList&lt;&gt;();
490                 while (listLen &gt; 0) {
491                     // opaque DistinguishedName&lt;1..2^16-1&gt;;
492                     byte[] encoded = Record.getBytes16(m);
493                     listLen -= (2 + encoded.length);
494                     authorities.add(encoded);
495                 }
496             } else {
497                 this.authorities = Collections.emptyList();
498             }
499         }
500 
501         String[] getKeyTypes() {
502             return ClientCertificateType.getKeyTypes(types);
503         }
504 
505         X500Principal[] getAuthorities() {
<span class="line-modified">506             X500Principal[] principals = new X500Principal[authorities.size()];</span>
<span class="line-modified">507             int i = 0;</span>
508             for (byte[] encoded : authorities) {
<span class="line-modified">509                 principals[i++] = new X500Principal(encoded);</span>

510             }
511 
<span class="line-modified">512             return principals;</span>
513         }
514 
515         @Override
516         public SSLHandshake handshakeType() {
517             return SSLHandshake.CERTIFICATE_REQUEST;
518         }
519 
520         @Override
521         public int messageLength() {
522             int len = 1 + types.length + 2 + (algorithmIds.length &lt;&lt; 1) + 2;
523             for (byte[] encoded : authorities) {
524                 len += encoded.length + 2;
525             }
526             return len;
527         }
528 
529         @Override
530         public void send(HandshakeOutStream hos) throws IOException {
531             hos.putBytes8(types);
532 
</pre>
</td>
</tr>
</table>
<center><a href="../../nio/ch/FileChannelImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SSLExtension.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
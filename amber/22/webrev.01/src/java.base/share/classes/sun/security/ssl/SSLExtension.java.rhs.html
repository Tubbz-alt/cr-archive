<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/security/ssl/SSLExtension.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.io.IOException;
 29 import java.nio.ByteBuffer;
 30 import java.text.MessageFormat;
 31 import java.util.Collection;
 32 import java.util.Collections;
 33 import java.util.LinkedList;
 34 import java.util.Locale;
 35 import sun.security.ssl.SSLHandshake.HandshakeMessage;
 36 import sun.security.util.HexDumpEncoder;
 37 
 38 enum SSLExtension implements SSLStringizer {
 39     // Extensions defined in RFC 6066
 40     CH_SERVER_NAME          (0x0000,  &quot;server_name&quot;,
 41                                 SSLHandshake.CLIENT_HELLO,
 42                                 ProtocolVersion.PROTOCOLS_TO_13,
 43                                 ServerNameExtension.chNetworkProducer,
 44                                 ServerNameExtension.chOnLoadConsumer,
 45                                 null,
 46                                 null,
 47                                 null,
 48                                 ServerNameExtension.chStringizer),
 49     SH_SERVER_NAME          (0x0000, &quot;server_name&quot;,
 50                                 SSLHandshake.SERVER_HELLO,
 51                                 ProtocolVersion.PROTOCOLS_TO_12,
 52                                 ServerNameExtension.shNetworkProducer,
 53                                 ServerNameExtension.shOnLoadConsumer,
 54                                 null,
 55                                 null,
 56                                 null,
 57                                 ServerNameExtension.shStringizer),
 58     EE_SERVER_NAME          (0x0000, &quot;server_name&quot;,
 59                                 SSLHandshake.ENCRYPTED_EXTENSIONS,
 60                                 ProtocolVersion.PROTOCOLS_OF_13,
 61                                 ServerNameExtension.eeNetworkProducer,
 62                                 ServerNameExtension.eeOnLoadConsumer,
 63                                 null,
 64                                 null,
 65                                 null,
 66                                 ServerNameExtension.shStringizer),
 67     CH_MAX_FRAGMENT_LENGTH (0x0001, &quot;max_fragment_length&quot;,
 68                                 SSLHandshake.CLIENT_HELLO,
 69                                 ProtocolVersion.PROTOCOLS_TO_13,
 70                                 MaxFragExtension.chNetworkProducer,
 71                                 MaxFragExtension.chOnLoadConsumer,
 72                                 null,
 73                                 null,
 74                                 null,
 75                                 MaxFragExtension.maxFragLenStringizer),
 76     SH_MAX_FRAGMENT_LENGTH (0x0001, &quot;max_fragment_length&quot;,
 77                                 SSLHandshake.SERVER_HELLO,
 78                                 ProtocolVersion.PROTOCOLS_TO_12,
 79                                 MaxFragExtension.shNetworkProducer,
 80                                 MaxFragExtension.shOnLoadConsumer,
 81                                 null,
 82                                 MaxFragExtension.shOnTradeConsumer,
 83                                 null,
 84                                 MaxFragExtension.maxFragLenStringizer),
 85     EE_MAX_FRAGMENT_LENGTH (0x0001, &quot;max_fragment_length&quot;,
 86                                 SSLHandshake.ENCRYPTED_EXTENSIONS,
 87                                 ProtocolVersion.PROTOCOLS_OF_13,
 88                                 MaxFragExtension.eeNetworkProducer,
 89                                 MaxFragExtension.eeOnLoadConsumer,
 90                                 null,
 91                                 MaxFragExtension.eeOnTradeConsumer,
 92                                 null,
 93                                 MaxFragExtension.maxFragLenStringizer),
 94     CLIENT_CERTIFICATE_URL  (0x0002, &quot;client_certificate_url&quot;),
 95     TRUSTED_CA_KEYS         (0x0003, &quot;trusted_ca_keys&quot;),
 96     TRUNCATED_HMAC          (0x0004, &quot;truncated_hmac&quot;),
 97 
 98     CH_STATUS_REQUEST       (0x0005, &quot;status_request&quot;,
 99                                 SSLHandshake.CLIENT_HELLO,
100                                 ProtocolVersion.PROTOCOLS_TO_13,
101                                 CertStatusExtension.chNetworkProducer,
102                                 CertStatusExtension.chOnLoadConsumer,
103                                 null,
104                                 null,
105                                 null,
106                                 CertStatusExtension.certStatusReqStringizer),
107     SH_STATUS_REQUEST       (0x0005, &quot;status_request&quot;,
108                                 SSLHandshake.SERVER_HELLO,
109                                 ProtocolVersion.PROTOCOLS_TO_12,
110                                 CertStatusExtension.shNetworkProducer,
111                                 CertStatusExtension.shOnLoadConsumer,
112                                 null,
113                                 null,
114                                 null,
115                                 CertStatusExtension.certStatusReqStringizer),
116     CR_STATUS_REQUEST       (0x0005, &quot;status_request&quot;),
117     CT_STATUS_REQUEST       (0x0005, &quot;status_request&quot;,
118                                 SSLHandshake.CERTIFICATE,
119                                 ProtocolVersion.PROTOCOLS_OF_13,
120                                 CertStatusExtension.ctNetworkProducer,
121                                 CertStatusExtension.ctOnLoadConsumer,
122                                 null,
123                                 null,
124                                 null,
125                                 CertStatusExtension.certStatusRespStringizer),
126 
127     // extensions defined in RFC 4681
128     USER_MAPPING            (0x0006, &quot;user_mapping&quot;),
129 
130     // extensions defined in RFC 5878
131     CLIENT_AUTHZ            (0x0007, &quot;client_authz&quot;),
132     SERVER_AUTHZ            (0x0008, &quot;server_authz&quot;),
133 
134     // extensions defined in RFC 5081
135     CERT_TYPE               (0x0009, &quot;cert_type&quot;),
136 
137     // extensions defined in RFC 4492 (ECC)
138     CH_SUPPORTED_GROUPS     (0x000A, &quot;supported_groups&quot;,
139                                 SSLHandshake.CLIENT_HELLO,
140                                 ProtocolVersion.PROTOCOLS_TO_13,
141                                 SupportedGroupsExtension.chNetworkProducer,
142                                 SupportedGroupsExtension.chOnLoadConsumer,
143                                 null,
144                                 null,
145                                 SupportedGroupsExtension.chOnTradAbsence,
146                                 SupportedGroupsExtension.sgsStringizer),
147     EE_SUPPORTED_GROUPS     (0x000A, &quot;supported_groups&quot;,
148                                 SSLHandshake.ENCRYPTED_EXTENSIONS,
149                                 ProtocolVersion.PROTOCOLS_OF_13,
150                                 SupportedGroupsExtension.eeNetworkProducer,
151                                 SupportedGroupsExtension.eeOnLoadConsumer,
152                                 null,
153                                 null,
154                                 null,
155                                 SupportedGroupsExtension.sgsStringizer),
156 
157     CH_EC_POINT_FORMATS     (0x000B, &quot;ec_point_formats&quot;,
158                                 SSLHandshake.CLIENT_HELLO,
159                                 ProtocolVersion.PROTOCOLS_TO_12,
160                                 ECPointFormatsExtension.chNetworkProducer,
161                                 ECPointFormatsExtension.chOnLoadConsumer,
162                                 null,
163                                 null,
164                                 null,
165                                 ECPointFormatsExtension.epfStringizer),
166     SH_EC_POINT_FORMATS     (0x000B, &quot;ec_point_formats&quot;,
167                                 SSLHandshake.SERVER_HELLO,
168                                 ProtocolVersion.PROTOCOLS_TO_12,
169                                 null,   // not use of the producer
170                                 ECPointFormatsExtension.shOnLoadConsumer,
171                                 null,
172                                 null,
173                                 null,
174                                 ECPointFormatsExtension.epfStringizer),
175 
176     // extensions defined in RFC 5054
177     SRP                     (0x000C, &quot;srp&quot;),
178 
179     // extensions defined in RFC 5246
180     CH_SIGNATURE_ALGORITHMS (0x000D, &quot;signature_algorithms&quot;,
181                                 SSLHandshake.CLIENT_HELLO,
182                                 ProtocolVersion.PROTOCOLS_12_13,
183                                 SignatureAlgorithmsExtension.chNetworkProducer,
184                                 SignatureAlgorithmsExtension.chOnLoadConsumer,
185                                 SignatureAlgorithmsExtension.chOnLoadAbsence,
186                                 SignatureAlgorithmsExtension.chOnTradeConsumer,
187                                 SignatureAlgorithmsExtension.chOnTradeAbsence,
188                                 SignatureAlgorithmsExtension.ssStringizer),
189     CR_SIGNATURE_ALGORITHMS (0x000D, &quot;signature_algorithms&quot;,
190                                 SSLHandshake.CERTIFICATE_REQUEST,
191                                 ProtocolVersion.PROTOCOLS_OF_13,
192                                 SignatureAlgorithmsExtension.crNetworkProducer,
193                                 SignatureAlgorithmsExtension.crOnLoadConsumer,
194                                 SignatureAlgorithmsExtension.crOnLoadAbsence,
195                                 SignatureAlgorithmsExtension.crOnTradeConsumer,
196                                 null,
197                                 SignatureAlgorithmsExtension.ssStringizer),
198 
199     CH_SIGNATURE_ALGORITHMS_CERT (0x0032, &quot;signature_algorithms_cert&quot;,
200                                 SSLHandshake.CLIENT_HELLO,
201                                 ProtocolVersion.PROTOCOLS_12_13,
202                                 CertSignAlgsExtension.chNetworkProducer,
203                                 CertSignAlgsExtension.chOnLoadConsumer,
204                                 null,
205                                 CertSignAlgsExtension.chOnTradeConsumer,
206                                 null,
207                                 CertSignAlgsExtension.ssStringizer),
208     CR_SIGNATURE_ALGORITHMS_CERT (0x0032, &quot;signature_algorithms_cert&quot;,
209                                 SSLHandshake.CERTIFICATE_REQUEST,
210                                 ProtocolVersion.PROTOCOLS_OF_13,
211                                 CertSignAlgsExtension.crNetworkProducer,
212                                 CertSignAlgsExtension.crOnLoadConsumer,
213                                 null,
214                                 CertSignAlgsExtension.crOnTradeConsumer,
215                                 null,
216                                 CertSignAlgsExtension.ssStringizer),
217 
218     // extensions defined in RFC 5764
219     USE_SRTP                (0x000E, &quot;use_srtp&quot;),
220 
221     // extensions defined in RFC 6520
222     HEARTBEAT               (0x000E, &quot;heartbeat&quot;),
223 
224     // extension defined in RFC 7301 (ALPN)
225     CH_ALPN                 (0x0010, &quot;application_layer_protocol_negotiation&quot;,
226                                 SSLHandshake.CLIENT_HELLO,
227                                 ProtocolVersion.PROTOCOLS_TO_13,
228                                 AlpnExtension.chNetworkProducer,
229                                 AlpnExtension.chOnLoadConsumer,
230                                 AlpnExtension.chOnLoadAbsence,
231                                 null,
232                                 null,
233                                 AlpnExtension.alpnStringizer),
234     SH_ALPN                 (0x0010, &quot;application_layer_protocol_negotiation&quot;,
235                                 SSLHandshake.SERVER_HELLO,
236                                 ProtocolVersion.PROTOCOLS_TO_12,
237                                 AlpnExtension.shNetworkProducer,
238                                 AlpnExtension.shOnLoadConsumer,
239                                 AlpnExtension.shOnLoadAbsence,
240                                 null,
241                                 null,
242                                 AlpnExtension.alpnStringizer),
243     EE_ALPN                 (0x0010, &quot;application_layer_protocol_negotiation&quot;,
244                                 SSLHandshake.ENCRYPTED_EXTENSIONS,
245                                 ProtocolVersion.PROTOCOLS_OF_13,
246                                 AlpnExtension.shNetworkProducer,
247                                 AlpnExtension.shOnLoadConsumer,
248                                 AlpnExtension.shOnLoadAbsence,
249                                 null,
250                                 null,
251                                 AlpnExtension.alpnStringizer),
252 
253     // extensions defined in RFC 6961
254     CH_STATUS_REQUEST_V2    (0x0011, &quot;status_request_v2&quot;,
255                                 SSLHandshake.CLIENT_HELLO,
256                                 ProtocolVersion.PROTOCOLS_TO_12,
257                                 CertStatusExtension.chV2NetworkProducer,
258                                 CertStatusExtension.chV2OnLoadConsumer,
259                                 null,
260                                 null,
261                                 null,
262                                 CertStatusExtension.certStatusReqV2Stringizer),
263     SH_STATUS_REQUEST_V2    (0x0011, &quot;status_request_v2&quot;,
264                                 SSLHandshake.SERVER_HELLO,
265                                 ProtocolVersion.PROTOCOLS_TO_12,
266                                 CertStatusExtension.shV2NetworkProducer,
267                                 CertStatusExtension.shV2OnLoadConsumer,
268                                 null,
269                                 null,
270                                 null,
271                                 CertStatusExtension.certStatusReqV2Stringizer),
272 
273     // extensions defined in RFC 6962
274     SIGNED_CERT_TIMESTAMP   (0x0012, &quot;signed_certificate_timestamp&quot;),
275 
276     // extensions defined in RFC 7250
277     CLIENT_CERT_TYPE        (0x0013, &quot;padding&quot;),
278     SERVER_CERT_TYPE        (0x0014, &quot;server_certificate_type&quot;),
279 
280     // extensions defined in RFC 7685
281     PADDING                 (0x0015, &quot;client_certificate_type&quot;),
282 
283     // extensions defined in RFC 7366
284     ENCRYPT_THEN_MAC        (0x0016, &quot;encrypt_then_mac&quot;),
285 
286     // extensions defined in RFC 7627
287     CH_EXTENDED_MASTER_SECRET  (0x0017, &quot;extended_master_secret&quot;,
288                                 SSLHandshake.CLIENT_HELLO,
289                                 ProtocolVersion.PROTOCOLS_TO_12,
290                                 ExtendedMasterSecretExtension.chNetworkProducer,
291                                 ExtendedMasterSecretExtension.chOnLoadConsumer,
292                                 ExtendedMasterSecretExtension.chOnLoadAbsence,
293                                 null,
294                                 null,
295                                 ExtendedMasterSecretExtension.emsStringizer),
296     SH_EXTENDED_MASTER_SECRET  (0x0017, &quot;extended_master_secret&quot;,
297                                 SSLHandshake.SERVER_HELLO,
298                                 ProtocolVersion.PROTOCOLS_TO_12,
299                                 ExtendedMasterSecretExtension.shNetworkProducer,
300                                 ExtendedMasterSecretExtension.shOnLoadConsumer,
301                                 ExtendedMasterSecretExtension.shOnLoadAbsence,
302                                 null,
303                                 null,
304                                 ExtendedMasterSecretExtension.emsStringizer),
305 
306     // extensions defined in RFC draft-ietf-tokbind-negotiation
307     TOKEN_BINDING           (0x0018, &quot;token_binding &quot;),
308 
309     // extensions defined in RFC 7924
310     CACHED_INFO             (0x0019, &quot;cached_info&quot;),
311 
312     // extensions defined in RFC 5077
313     CH_SESSION_TICKET       (0x0023, &quot;session_ticket&quot;,
314             SSLHandshake.CLIENT_HELLO,
315             ProtocolVersion.PROTOCOLS_10_12,
316             SessionTicketExtension.chNetworkProducer,
317             SessionTicketExtension.chOnLoadConsumer,
318             null,
319             null,
320             null,
321             SessionTicketExtension.steStringizer),
322             //null),
323 
324     SH_SESSION_TICKET       (0x0023, &quot;session_ticket&quot;,
325             SSLHandshake.SERVER_HELLO,
326             ProtocolVersion.PROTOCOLS_10_12,
327             SessionTicketExtension.shNetworkProducer,
328             SessionTicketExtension.shOnLoadConsumer,
329             null,
330             null,
331             null,
332             SessionTicketExtension.steStringizer),
333             //null),
334 
335     // extensions defined in TLS 1.3
336     CH_EARLY_DATA           (0x002A, &quot;early_data&quot;),
337     EE_EARLY_DATA           (0x002A, &quot;early_data&quot;),
338     NST_EARLY_DATA          (0x002A, &quot;early_data&quot;),
339 
340     CH_SUPPORTED_VERSIONS   (0x002B, &quot;supported_versions&quot;,
341                                 SSLHandshake.CLIENT_HELLO,
342                                 ProtocolVersion.PROTOCOLS_TO_13,
343                                 SupportedVersionsExtension.chNetworkProducer,
344                                 SupportedVersionsExtension.chOnLoadConsumer,
345                                 null,
346                                 null,
347                                 null,
348                                 SupportedVersionsExtension.chStringizer),
349     SH_SUPPORTED_VERSIONS   (0x002B, &quot;supported_versions&quot;,
350                                 SSLHandshake.SERVER_HELLO,
351                                         // and HelloRetryRequest
352                                 ProtocolVersion.PROTOCOLS_OF_13,
353                                 SupportedVersionsExtension.shNetworkProducer,
354                                 SupportedVersionsExtension.shOnLoadConsumer,
355                                 null,
356                                 null,
357                                 null,
358                                 SupportedVersionsExtension.shStringizer),
359     HRR_SUPPORTED_VERSIONS  (0x002B, &quot;supported_versions&quot;,
360                                 SSLHandshake.HELLO_RETRY_REQUEST,
361                                 ProtocolVersion.PROTOCOLS_OF_13,
362                                 SupportedVersionsExtension.hrrNetworkProducer,
363                                 SupportedVersionsExtension.hrrOnLoadConsumer,
364                                 null,
365                                 null,
366                                 null,
367                                 SupportedVersionsExtension.hrrStringizer),
368     MH_SUPPORTED_VERSIONS   (0x002B, &quot;supported_versions&quot;,
369                                 SSLHandshake.MESSAGE_HASH,
370                                 ProtocolVersion.PROTOCOLS_OF_13,
371                                 SupportedVersionsExtension.hrrReproducer,
372                                 null, null, null,
373                                 null,
374                                 SupportedVersionsExtension.hrrStringizer),
375 
376     CH_COOKIE               (0x002C, &quot;cookie&quot;,
377                                 SSLHandshake.CLIENT_HELLO,
378                                 ProtocolVersion.PROTOCOLS_OF_13,
379                                 CookieExtension.chNetworkProducer,
380                                 CookieExtension.chOnLoadConsumer,
381                                 null,
382                                 CookieExtension.chOnTradeConsumer,
383                                 null,
384                                 CookieExtension.cookieStringizer),
385     HRR_COOKIE              (0x002C, &quot;cookie&quot;,
386                                 SSLHandshake.HELLO_RETRY_REQUEST,
387                                 ProtocolVersion.PROTOCOLS_OF_13,
388                                 CookieExtension.hrrNetworkProducer,
389                                 CookieExtension.hrrOnLoadConsumer,
390                                 null, null,
391                                 null,
392                                 CookieExtension.cookieStringizer),
393     MH_COOKIE               (0x002C, &quot;cookie&quot;,
394                                 SSLHandshake.MESSAGE_HASH,
395                                 ProtocolVersion.PROTOCOLS_OF_13,
396                                 CookieExtension.hrrNetworkReproducer,
397                                 null, null, null,
398                                 null,
399                                 CookieExtension.cookieStringizer),
400 
401     PSK_KEY_EXCHANGE_MODES  (0x002D, &quot;psk_key_exchange_modes&quot;,
402                                 SSLHandshake.CLIENT_HELLO,
403                                 ProtocolVersion.PROTOCOLS_OF_13,
404                                 PskKeyExchangeModesExtension.chNetworkProducer,
405                                 PskKeyExchangeModesExtension.chOnLoadConsumer,
406                                 PskKeyExchangeModesExtension.chOnLoadAbsence,
407                                 null,
408                                 PskKeyExchangeModesExtension.chOnTradeAbsence,
409                                 PskKeyExchangeModesExtension.pkemStringizer),
<a name="1" id="anc1"></a><span class="line-modified">410 </span>
<span class="line-added">411     CH_CERTIFICATE_AUTHORITIES (0x002F, &quot;certificate_authorities&quot;,</span>
<span class="line-added">412                                 SSLHandshake.CLIENT_HELLO,</span>
<span class="line-added">413                                 ProtocolVersion.PROTOCOLS_OF_13,</span>
<span class="line-added">414                                 CertificateAuthoritiesExtension.chNetworkProducer,</span>
<span class="line-added">415                                 CertificateAuthoritiesExtension.chOnLoadConsumer,</span>
<span class="line-added">416                                 null,</span>
<span class="line-added">417                                 null,</span>
<span class="line-added">418                                 null,</span>
<span class="line-added">419                                 CertificateAuthoritiesExtension.ssStringizer),</span>
<span class="line-added">420 </span>
<span class="line-added">421     CR_CERTIFICATE_AUTHORITIES (0x002F, &quot;certificate_authorities&quot;,</span>
<span class="line-added">422                                 SSLHandshake.CERTIFICATE_REQUEST,</span>
<span class="line-added">423                                 ProtocolVersion.PROTOCOLS_OF_13,</span>
<span class="line-added">424                                 CertificateAuthoritiesExtension.crNetworkProducer,</span>
<span class="line-added">425                                 CertificateAuthoritiesExtension.crOnLoadConsumer,</span>
<span class="line-added">426                                 null,</span>
<span class="line-added">427                                 null,</span>
<span class="line-added">428                                 null,</span>
<span class="line-added">429                                 CertificateAuthoritiesExtension.ssStringizer),</span>
<span class="line-added">430 </span>
431     OID_FILTERS             (0x0030, &quot;oid_filters&quot;),
432     POST_HANDSHAKE_AUTH     (0x0030, &quot;post_handshake_auth&quot;),
433 
434     CH_KEY_SHARE            (0x0033, &quot;key_share&quot;,
435                                 SSLHandshake.CLIENT_HELLO,
436                                 ProtocolVersion.PROTOCOLS_OF_13,
437                                 KeyShareExtension.chNetworkProducer,
438                                 KeyShareExtension.chOnLoadConsumer,
439                                 null,
440                                 null,
441                                 KeyShareExtension.chOnTradAbsence,
442                                 KeyShareExtension.chStringizer),
443     SH_KEY_SHARE            (0x0033, &quot;key_share&quot;,
444                                 SSLHandshake.SERVER_HELLO,
445                                 ProtocolVersion.PROTOCOLS_OF_13,
446                                 KeyShareExtension.shNetworkProducer,
447                                 KeyShareExtension.shOnLoadConsumer,
448                                 KeyShareExtension.shOnLoadAbsence,
449                                 null,
450                                 null,
451                                 KeyShareExtension.shStringizer),
452     HRR_KEY_SHARE           (0x0033, &quot;key_share&quot;,
453                                 SSLHandshake.HELLO_RETRY_REQUEST,
454                                 ProtocolVersion.PROTOCOLS_OF_13,
455                                 KeyShareExtension.hrrNetworkProducer,
456                                 KeyShareExtension.hrrOnLoadConsumer,
457                                 null, null, null,
458                                 KeyShareExtension.hrrStringizer),
459     MH_KEY_SHARE            (0x0033, &quot;key_share&quot;,
460                                 SSLHandshake.MESSAGE_HASH,
461                                 ProtocolVersion.PROTOCOLS_OF_13,
462                                 KeyShareExtension.hrrNetworkReproducer,
463                                 null, null, null, null,
464                                 KeyShareExtension.hrrStringizer),
465 
466     // Extensions defined in RFC 5746
467     CH_RENEGOTIATION_INFO   (0xff01, &quot;renegotiation_info&quot;,
468                                 SSLHandshake.CLIENT_HELLO,
469                                 ProtocolVersion.PROTOCOLS_TO_12,
470                                 RenegoInfoExtension.chNetworkProducer,
471                                 RenegoInfoExtension.chOnLoadConsumer,
472                                 RenegoInfoExtension.chOnLoadAbsence,
473                                 null,
474                                 null,
475                                 RenegoInfoExtension.rniStringizer),
476     SH_RENEGOTIATION_INFO   (0xff01, &quot;renegotiation_info&quot;,
477                                 SSLHandshake.SERVER_HELLO,
478                                 ProtocolVersion.PROTOCOLS_TO_12,
479                                 RenegoInfoExtension.shNetworkProducer,
480                                 RenegoInfoExtension.shOnLoadConsumer,
481                                 RenegoInfoExtension.shOnLoadAbsence,
482                                 null,
483                                 null,
484                                 RenegoInfoExtension.rniStringizer),
485 
486     // TLS 1.3 PSK extension must be last
487     CH_PRE_SHARED_KEY       (0x0029, &quot;pre_shared_key&quot;,
488                                 SSLHandshake.CLIENT_HELLO,
489                                 ProtocolVersion.PROTOCOLS_OF_13,
490                                 PreSharedKeyExtension.chNetworkProducer,
491                                 PreSharedKeyExtension.chOnLoadConsumer,
492                                 PreSharedKeyExtension.chOnLoadAbsence,
493                                 PreSharedKeyExtension.chOnTradeConsumer,
494                                 PreSharedKeyExtension.chOnTradAbsence,
495                                 PreSharedKeyExtension.chStringizer),
496     SH_PRE_SHARED_KEY       (0x0029, &quot;pre_shared_key&quot;,
497                                 SSLHandshake.SERVER_HELLO,
498                                 ProtocolVersion.PROTOCOLS_OF_13,
499                                 PreSharedKeyExtension.shNetworkProducer,
500                                 PreSharedKeyExtension.shOnLoadConsumer,
501                                 PreSharedKeyExtension.shOnLoadAbsence,
502                                 null, null,
503                                 PreSharedKeyExtension.shStringizer);
504 
505     final int id;
506     final SSLHandshake handshakeType;
507     final String name;
508     final ProtocolVersion[] supportedProtocols;
509 
510     /*
511      * networkProducer: produces outbound handshake data.
512      *
513      * onLoadConsumer:  parses inbound data.  It may not be appropriate
514      *                  to act until all of the message inputs have
515      *                  been parsed.  (e.g. parsing keyShares and choosing
516      *                  a local value without having seen the SupportedGroups
517      *                  extension.)
518      *
519      * onLoadAbsence:   if a missing message needs special handling
520      *                  during the load phase.
521      *
522      * onTradeConsumer: act on the parsed message once all inbound data has
523      *                  been traded and parsed.
524      *
525      * onTradeAbsence:  if a missing message needs special handling
526      *                  during the trade phase.
527      */
528     final HandshakeProducer networkProducer;
529     final ExtensionConsumer onLoadConsumer;
530     final HandshakeAbsence  onLoadAbsence;
531     final HandshakeConsumer onTradeConsumer;
532     final HandshakeAbsence  onTradeAbsence;
533     final SSLStringizer stringizer;
534 
535     // known but unsupported extension
536     private SSLExtension(int id, String name) {
537         this.id = id;
538         this.handshakeType = SSLHandshake.NOT_APPLICABLE;
539         this.name = name;
540         this.supportedProtocols = new ProtocolVersion[0];
541         this.networkProducer = null;
542         this.onLoadConsumer = null;
543         this.onLoadAbsence = null;
544         this.onTradeConsumer = null;
545         this.onTradeAbsence = null;
546         this.stringizer = null;
547     }
548 
549     // supported extension
550     private SSLExtension(int id, String name, SSLHandshake handshakeType,
551             ProtocolVersion[] supportedProtocols,
552             HandshakeProducer producer,
553             ExtensionConsumer onLoadConsumer, HandshakeAbsence onLoadAbsence,
554             HandshakeConsumer onTradeConsumer, HandshakeAbsence onTradeAbsence,
555             SSLStringizer stringize) {
556         this.id = id;
557         this.handshakeType = handshakeType;
558         this.name = name;
559         this.supportedProtocols = supportedProtocols;
560         this.networkProducer = producer;
561         this.onLoadConsumer = onLoadConsumer;
562         this.onLoadAbsence = onLoadAbsence;
563         this.onTradeConsumer = onTradeConsumer;
564         this.onTradeAbsence = onTradeAbsence;
565         this.stringizer = stringize;
566     }
567 
568     static SSLExtension valueOf(SSLHandshake handshakeType, int extensionType) {
569         for (SSLExtension ext : SSLExtension.values()) {
570             if (ext.id == extensionType &amp;&amp;
571                     ext.handshakeType == handshakeType) {
572                 return ext;
573             }
574         }
575 
576         return null;
577     }
578 
579     static String nameOf(int extensionType) {
580         for (SSLExtension ext : SSLExtension.values()) {
581             if (ext.id == extensionType) {
582                 return ext.name;
583             }
584         }
585 
586         return &quot;unknown extension&quot;;
587     }
588 
589     static boolean isConsumable(int extensionType) {
590         for (SSLExtension ext : SSLExtension.values()) {
591             if (ext.id == extensionType &amp;&amp;
592                     ext.onLoadConsumer != null) {
593                 return true;
594             }
595         }
596 
597         return false;
598     }
599 
600     public byte[] produce(ConnectionContext context,
601             HandshakeMessage message) throws IOException {
602         if (networkProducer != null) {
603             return networkProducer.produce(context, message);
604         } else {
605             throw new UnsupportedOperationException(
606                     &quot;Not yet supported extension producing.&quot;);
607         }
608     }
609 
610     public void consumeOnLoad(ConnectionContext context,
611             HandshakeMessage message, ByteBuffer buffer) throws IOException {
612         if (onLoadConsumer != null) {
613             onLoadConsumer.consume(context, message, buffer);
614         } else {
615             throw new UnsupportedOperationException(
616                     &quot;Not yet supported extension loading.&quot;);
617         }
618     }
619 
620     public void consumeOnTrade(ConnectionContext context,
621             HandshakeMessage message) throws IOException {
622         if (onTradeConsumer != null) {
623             onTradeConsumer.consume(context, message);
624         } else {
625             throw new UnsupportedOperationException(
626                     &quot;Not yet supported extension processing.&quot;);
627         }
628     }
629 
630     void absentOnLoad(ConnectionContext context,
631             HandshakeMessage message) throws IOException {
632         if (onLoadAbsence != null) {
633             onLoadAbsence.absent(context, message);
634         } else {
635             throw new UnsupportedOperationException(
636                     &quot;Not yet supported extension absence processing.&quot;);
637         }
638     }
639 
640     void absentOnTrade(ConnectionContext context,
641             HandshakeMessage message) throws IOException {
642         if (onTradeAbsence != null) {
643             onTradeAbsence.absent(context, message);
644         } else {
645             throw new UnsupportedOperationException(
646                     &quot;Not yet supported extension absence processing.&quot;);
647         }
648     }
649 
650     public boolean isAvailable(ProtocolVersion protocolVersion) {
651         for (int i = 0; i &lt; supportedProtocols.length; i++) {
652             if (supportedProtocols[i] == protocolVersion) {
653                 return true;
654             }
655         }
656 
657         return false;
658     }
659 
660     @Override
661     public String toString() {
662         return name;
663     }
664 
665     @Override
666     public String toString(
667             HandshakeContext handshakeContext, ByteBuffer byteBuffer) {
668         MessageFormat messageFormat = new MessageFormat(
669             &quot;\&quot;{0} ({1})\&quot;: &#39;{&#39;\n&quot; +
670             &quot;{2}\n&quot; +
671             &quot;&#39;}&#39;&quot;,
672             Locale.ENGLISH);
673 
674         String extData;
675         if (stringizer == null) {
676             HexDumpEncoder hexEncoder = new HexDumpEncoder();
677             String encoded = hexEncoder.encode(byteBuffer.duplicate());
678             extData = encoded;
679         } else {
680             extData = stringizer.toString(handshakeContext, byteBuffer);
681         }
682 
683         Object[] messageFields = {
684             this.name,
685             this.id,
686             Utilities.indent(extData)
687         };
688 
689         return messageFormat.format(messageFields);
690     }
691 
692     //////////////////////////////////////////////////////
693     // Nested extension, consumer and producer interfaces.
694 
695     static interface ExtensionConsumer {
696         void consume(ConnectionContext context,
697                 HandshakeMessage message, ByteBuffer buffer) throws IOException;
698     }
699 
700     /**
701      * A (transparent) specification of extension data.
702      *
703      * This interface contains no methods or constants. Its only purpose is to
704      * group all extension data.  All extension data should implement this
705      * interface if the data is expected to handle in the following handshake
706      * processes.
707      */
708     static interface SSLExtensionSpec {
709         // blank
710     }
711 
712     // Default enabled client extensions.
713     static final class ClientExtensions {
714         static final Collection&lt;SSLExtension&gt; defaults;
715 
716         static {
717             Collection&lt;SSLExtension&gt; extensions = new LinkedList&lt;&gt;();
718             for (SSLExtension extension : SSLExtension.values()) {
719                 if (extension.handshakeType != SSLHandshake.NOT_APPLICABLE) {
720                     extensions.add(extension);
721                 }
722             }
723 
724             // Switch off SNI extention?
725             boolean enableExtension =
726                 Utilities.getBooleanProperty(&quot;jsse.enableSNIExtension&quot;, true);
727             if (!enableExtension) {
728                 extensions.remove(CH_SERVER_NAME);
729             }
730 
731             // To switch off the max_fragment_length extension.
732             //
733             // Note that &quot;jsse.enableMFLNExtension&quot; is the CSR approved
734             // property name.  However, &quot;jsse.enableMFLExtension&quot; was used
735             // in the original implementation.  Temporarily, if either of
736             // the two properties set to true, the extension is switch on.
737             // We may remove the &quot;jsse.enableMFLExtension&quot; property in the
738             // future.  Please don&#39;t continue to use the misspelling property.
739             enableExtension =
740                 Utilities.getBooleanProperty(
741                         &quot;jsse.enableMFLNExtension&quot;, false) ||
742                 Utilities.getBooleanProperty(
743                         &quot;jsse.enableMFLExtension&quot;, false);
744             if (!enableExtension) {
745                 extensions.remove(CH_MAX_FRAGMENT_LENGTH);
746             }
747 
<a name="2" id="anc2"></a><span class="line-added">748             // To switch on certificate_authorities extension in ClientHello.</span>
<span class="line-added">749             //</span>
<span class="line-added">750             // Note: Please be careful to enable this extension in ClientHello.</span>
<span class="line-added">751             //</span>
<span class="line-added">752             // In practice, if the server certificate cannot be validated by</span>
<span class="line-added">753             // the underlying programs, the user may manually check the</span>
<span class="line-added">754             // certificate in order to access the service.  The certificate</span>
<span class="line-added">755             // could be accepted manually, and the handshake continues.  For</span>
<span class="line-added">756             // example, the browsers provide the manual option to accept</span>
<span class="line-added">757             // untrusted server certificate. If this extension is enabled in</span>
<span class="line-added">758             // the ClientHello handshake message, and the server&#39;s certificate</span>
<span class="line-added">759             // does not chain back to any of the CAs in the extension, then the</span>
<span class="line-added">760             // server will terminate the handshake and close the connection.</span>
<span class="line-added">761             // There is no chance for the client to perform the manual check.</span>
<span class="line-added">762             // Therefore, enabling this extension in ClientHello may lead to</span>
<span class="line-added">763             // unexpected compatibility issues for such cases.</span>
<span class="line-added">764             //</span>
<span class="line-added">765             // According to TLS 1.3 specification [RFC 8446] the maximum size</span>
<span class="line-added">766             // of the certificate_authorities extension is 2^16 bytes.  The</span>
<span class="line-added">767             // maximum TLS record size is 2^14 bytes.  If the handshake</span>
<span class="line-added">768             // message is bigger than maximum TLS record size, it should be</span>
<span class="line-added">769             // splitted into several records.  In fact, some server</span>
<span class="line-added">770             // implementations do not allow ClientHello messages bigger than</span>
<span class="line-added">771             // the maximum TLS record size and will immediately abort the</span>
<span class="line-added">772             // connection with a fatal alert.  Therefore, if the client trusts</span>
<span class="line-added">773             // too many certificate authorities, there may be unexpected</span>
<span class="line-added">774             // interoperability issues.</span>
<span class="line-added">775             //</span>
<span class="line-added">776             // Furthermore, if the client trusts more CAs such that it exceeds</span>
<span class="line-added">777             // the size limit of the extension, enabling this extension in</span>
<span class="line-added">778             // client side does not really make sense any longer as there is</span>
<span class="line-added">779             // no way to indicate the server certificate selection accurately.</span>
<span class="line-added">780             //</span>
<span class="line-added">781             // In general, a server does not use multiple certificates issued</span>
<span class="line-added">782             // from different CAs.  It is not expected to use this extension a</span>
<span class="line-added">783             // lot in practice.  When there is a need to use this extension</span>
<span class="line-added">784             // in ClientHello handshake message, please take care of the</span>
<span class="line-added">785             // potential compatibility and interoperability issues above.</span>
<span class="line-added">786             enableExtension = Utilities.getBooleanProperty(</span>
<span class="line-added">787                     &quot;jdk.tls.client.enableCAExtension&quot;, false);</span>
<span class="line-added">788             if (!enableExtension) {</span>
<span class="line-added">789                 extensions.remove(CH_CERTIFICATE_AUTHORITIES);</span>
<span class="line-added">790             }</span>
<span class="line-added">791 </span>
792             defaults = Collections.unmodifiableCollection(extensions);
793         }
794     }
795 
796     // Default enabled server extensions.
797     static final class ServerExtensions {
798         static final Collection&lt;SSLExtension&gt; defaults;
799 
800         static {
801             Collection&lt;SSLExtension&gt; extensions = new LinkedList&lt;&gt;();
802             for (SSLExtension extension : SSLExtension.values()) {
803                 if (extension.handshakeType != SSLHandshake.NOT_APPLICABLE) {
804                     extensions.add(extension);
805                 }
806             }
807 
808             defaults = Collections.unmodifiableCollection(extensions);
809         }
810     }
811 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/unix/native/libnio/fs/UnixNativeDispatcher.c</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2008, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #include &lt;stdio.h&gt;
  27 #include &lt;stdlib.h&gt;
  28 #include &lt;limits.h&gt;
  29 #include &lt;fcntl.h&gt;
  30 #include &lt;dirent.h&gt;
  31 #include &lt;unistd.h&gt;
  32 #include &lt;errno.h&gt;
  33 #include &lt;dlfcn.h&gt;
  34 #include &lt;sys/types.h&gt;
  35 #include &lt;sys/stat.h&gt;
  36 #ifdef MACOSX
  37 #include &lt;sys/param.h&gt;
  38 #include &lt;sys/mount.h&gt;
  39 #else
  40 #include &lt;sys/statvfs.h&gt;
  41 #endif
  42 #include &lt;sys/time.h&gt;
  43 
  44 /* For POSIX-compliant getpwuid_r */
  45 #include &lt;pwd.h&gt;
  46 #include &lt;grp.h&gt;
  47 
  48 #ifdef __linux__
  49 #include &lt;sys/syscall.h&gt;
  50 #endif
  51 
  52 #if defined(__linux__) || defined(_AIX)
  53 #include &lt;string.h&gt;
  54 #endif
  55 
  56 #ifdef _ALLBSD_SOURCE
  57 #include &lt;string.h&gt;
  58 
  59 #define stat64 stat
  60 #ifndef MACOSX
  61 #define statvfs64 statvfs
  62 #endif
  63 
  64 #define open64 open
  65 #define fstat64 fstat
  66 #define lstat64 lstat
  67 #define readdir64 readdir
  68 #endif
  69 
  70 #include &quot;jni.h&quot;
  71 #include &quot;jni_util.h&quot;
  72 #include &quot;jlong.h&quot;
  73 
  74 #include &quot;sun_nio_fs_UnixNativeDispatcher.h&quot;
  75 
  76 #if defined(_AIX)
  77   #define DIR DIR64
  78   #define dirent dirent64
  79   #define opendir opendir64
  80   #define readdir readdir64
  81   #define closedir closedir64
  82 #endif
  83 
  84 /**
  85  * Size of password or group entry when not available via sysconf
  86  */
  87 #define ENT_BUF_SIZE   1024
  88 
  89 #define RESTARTABLE(_cmd, _result) do { \
  90   do { \
  91     _result = _cmd; \
  92   } while((_result == -1) &amp;&amp; (errno == EINTR)); \
  93 } while(0)
  94 
  95 #define RESTARTABLE_RETURN_PTR(_cmd, _result) do { \
  96   do { \
  97     _result = _cmd; \
  98   } while((_result == NULL) &amp;&amp; (errno == EINTR)); \
  99 } while(0)
 100 
 101 static jfieldID attrs_st_mode;
 102 static jfieldID attrs_st_ino;
 103 static jfieldID attrs_st_dev;
 104 static jfieldID attrs_st_rdev;
 105 static jfieldID attrs_st_nlink;
 106 static jfieldID attrs_st_uid;
 107 static jfieldID attrs_st_gid;
 108 static jfieldID attrs_st_size;
 109 static jfieldID attrs_st_atime_sec;
 110 static jfieldID attrs_st_atime_nsec;
 111 static jfieldID attrs_st_mtime_sec;
 112 static jfieldID attrs_st_mtime_nsec;
 113 static jfieldID attrs_st_ctime_sec;
 114 static jfieldID attrs_st_ctime_nsec;
 115 
 116 #ifdef _DARWIN_FEATURE_64_BIT_INODE
 117 static jfieldID attrs_st_birthtime_sec;
 118 #endif
 119 
 120 static jfieldID attrs_f_frsize;
 121 static jfieldID attrs_f_blocks;
 122 static jfieldID attrs_f_bfree;
 123 static jfieldID attrs_f_bavail;
 124 
 125 static jfieldID entry_name;
 126 static jfieldID entry_dir;
 127 static jfieldID entry_fstype;
 128 static jfieldID entry_options;
 129 static jfieldID entry_dev;
 130 
 131 /**
 132  * System calls that may not be available at run time.
 133  */
 134 typedef int openat64_func(int, const char *, int, ...);
 135 typedef int fstatat64_func(int, const char *, struct stat64 *, int);
 136 typedef int unlinkat_func(int, const char*, int);
 137 typedef int renameat_func(int, const char*, int, const char*);
 138 typedef int futimesat_func(int, const char *, const struct timeval *);
 139 typedef int futimens_func(int, const struct timespec *);
 140 typedef int lutimes_func(const char *, const struct timeval *);
 141 typedef DIR* fdopendir_func(int);
 142 
 143 static openat64_func* my_openat64_func = NULL;
 144 static fstatat64_func* my_fstatat64_func = NULL;
 145 static unlinkat_func* my_unlinkat_func = NULL;
 146 static renameat_func* my_renameat_func = NULL;
 147 static futimesat_func* my_futimesat_func = NULL;
 148 static futimens_func* my_futimens_func = NULL;
 149 static lutimes_func* my_lutimes_func = NULL;
 150 static fdopendir_func* my_fdopendir_func = NULL;
 151 
 152 /**
 153  * fstatat missing from glibc on Linux.
 154  */
 155 #if defined(__linux__) &amp;&amp; (defined(__i386) || defined(__arm__))
 156 #define FSTATAT64_SYSCALL_AVAILABLE
 157 static int fstatat64_wrapper(int dfd, const char *path,
 158                              struct stat64 *statbuf, int flag)
 159 {
 160     #ifndef __NR_fstatat64
 161     #define __NR_fstatat64  300
 162     #endif
 163     return syscall(__NR_fstatat64, dfd, path, statbuf, flag);
 164 }
 165 #endif
 166 
 167 #if defined(__linux__) &amp;&amp; defined(_LP64) &amp;&amp; defined(__NR_newfstatat)
 168 #define FSTATAT64_SYSCALL_AVAILABLE
 169 static int fstatat64_wrapper(int dfd, const char *path,
 170                              struct stat64 *statbuf, int flag)
 171 {
 172     return syscall(__NR_newfstatat, dfd, path, statbuf, flag);
 173 }
 174 #endif
 175 
 176 /**
 177  * Call this to throw an internal UnixException when a system/library
 178  * call fails
 179  */
 180 static void throwUnixException(JNIEnv* env, int errnum) {
 181     jobject x = JNU_NewObjectByName(env, &quot;sun/nio/fs/UnixException&quot;,
 182         &quot;(I)V&quot;, errnum);
 183     if (x != NULL) {
 184         (*env)-&gt;Throw(env, x);
 185     }
 186 }
 187 
 188 /**
 189  * Initialization
 190  */
 191 JNIEXPORT jint JNICALL
 192 Java_sun_nio_fs_UnixNativeDispatcher_init(JNIEnv* env, jclass this)
 193 {
 194     jint capabilities = 0;
 195     jclass clazz;
 196 
 197     clazz = (*env)-&gt;FindClass(env, &quot;sun/nio/fs/UnixFileAttributes&quot;);
 198     CHECK_NULL_RETURN(clazz, 0);
 199     attrs_st_mode = (*env)-&gt;GetFieldID(env, clazz, &quot;st_mode&quot;, &quot;I&quot;);
 200     CHECK_NULL_RETURN(attrs_st_mode, 0);
 201     attrs_st_ino = (*env)-&gt;GetFieldID(env, clazz, &quot;st_ino&quot;, &quot;J&quot;);
 202     CHECK_NULL_RETURN(attrs_st_ino, 0);
 203     attrs_st_dev = (*env)-&gt;GetFieldID(env, clazz, &quot;st_dev&quot;, &quot;J&quot;);
 204     CHECK_NULL_RETURN(attrs_st_dev, 0);
 205     attrs_st_rdev = (*env)-&gt;GetFieldID(env, clazz, &quot;st_rdev&quot;, &quot;J&quot;);
 206     CHECK_NULL_RETURN(attrs_st_rdev, 0);
 207     attrs_st_nlink = (*env)-&gt;GetFieldID(env, clazz, &quot;st_nlink&quot;, &quot;I&quot;);
 208     CHECK_NULL_RETURN(attrs_st_nlink, 0);
 209     attrs_st_uid = (*env)-&gt;GetFieldID(env, clazz, &quot;st_uid&quot;, &quot;I&quot;);
 210     CHECK_NULL_RETURN(attrs_st_uid, 0);
 211     attrs_st_gid = (*env)-&gt;GetFieldID(env, clazz, &quot;st_gid&quot;, &quot;I&quot;);
 212     CHECK_NULL_RETURN(attrs_st_gid, 0);
 213     attrs_st_size = (*env)-&gt;GetFieldID(env, clazz, &quot;st_size&quot;, &quot;J&quot;);
 214     CHECK_NULL_RETURN(attrs_st_size, 0);
 215     attrs_st_atime_sec = (*env)-&gt;GetFieldID(env, clazz, &quot;st_atime_sec&quot;, &quot;J&quot;);
 216     CHECK_NULL_RETURN(attrs_st_atime_sec, 0);
 217     attrs_st_atime_nsec = (*env)-&gt;GetFieldID(env, clazz, &quot;st_atime_nsec&quot;, &quot;J&quot;);
 218     CHECK_NULL_RETURN(attrs_st_atime_nsec, 0);
 219     attrs_st_mtime_sec = (*env)-&gt;GetFieldID(env, clazz, &quot;st_mtime_sec&quot;, &quot;J&quot;);
 220     CHECK_NULL_RETURN(attrs_st_mtime_sec, 0);
 221     attrs_st_mtime_nsec = (*env)-&gt;GetFieldID(env, clazz, &quot;st_mtime_nsec&quot;, &quot;J&quot;);
 222     CHECK_NULL_RETURN(attrs_st_mtime_nsec, 0);
 223     attrs_st_ctime_sec = (*env)-&gt;GetFieldID(env, clazz, &quot;st_ctime_sec&quot;, &quot;J&quot;);
 224     CHECK_NULL_RETURN(attrs_st_ctime_sec, 0);
 225     attrs_st_ctime_nsec = (*env)-&gt;GetFieldID(env, clazz, &quot;st_ctime_nsec&quot;, &quot;J&quot;);
 226     CHECK_NULL_RETURN(attrs_st_ctime_nsec, 0);
 227 
 228 #ifdef _DARWIN_FEATURE_64_BIT_INODE
 229     attrs_st_birthtime_sec = (*env)-&gt;GetFieldID(env, clazz, &quot;st_birthtime_sec&quot;, &quot;J&quot;);
 230     CHECK_NULL_RETURN(attrs_st_birthtime_sec, 0);
 231 #endif
 232 
 233     clazz = (*env)-&gt;FindClass(env, &quot;sun/nio/fs/UnixFileStoreAttributes&quot;);
 234     CHECK_NULL_RETURN(clazz, 0);
 235     attrs_f_frsize = (*env)-&gt;GetFieldID(env, clazz, &quot;f_frsize&quot;, &quot;J&quot;);
 236     CHECK_NULL_RETURN(attrs_f_frsize, 0);
 237     attrs_f_blocks = (*env)-&gt;GetFieldID(env, clazz, &quot;f_blocks&quot;, &quot;J&quot;);
 238     CHECK_NULL_RETURN(attrs_f_blocks, 0);
 239     attrs_f_bfree = (*env)-&gt;GetFieldID(env, clazz, &quot;f_bfree&quot;, &quot;J&quot;);
 240     CHECK_NULL_RETURN(attrs_f_bfree, 0);
 241     attrs_f_bavail = (*env)-&gt;GetFieldID(env, clazz, &quot;f_bavail&quot;, &quot;J&quot;);
 242     CHECK_NULL_RETURN(attrs_f_bavail, 0);
 243 
 244     clazz = (*env)-&gt;FindClass(env, &quot;sun/nio/fs/UnixMountEntry&quot;);
 245     CHECK_NULL_RETURN(clazz, 0);
 246     entry_name = (*env)-&gt;GetFieldID(env, clazz, &quot;name&quot;, &quot;[B&quot;);
 247     CHECK_NULL_RETURN(entry_name, 0);
 248     entry_dir = (*env)-&gt;GetFieldID(env, clazz, &quot;dir&quot;, &quot;[B&quot;);
 249     CHECK_NULL_RETURN(entry_dir, 0);
 250     entry_fstype = (*env)-&gt;GetFieldID(env, clazz, &quot;fstype&quot;, &quot;[B&quot;);
 251     CHECK_NULL_RETURN(entry_fstype, 0);
 252     entry_options = (*env)-&gt;GetFieldID(env, clazz, &quot;opts&quot;, &quot;[B&quot;);
 253     CHECK_NULL_RETURN(entry_options, 0);
 254     entry_dev = (*env)-&gt;GetFieldID(env, clazz, &quot;dev&quot;, &quot;J&quot;);
 255     CHECK_NULL_RETURN(entry_dev, 0);
 256 
 257     /* system calls that might not be available at run time */
 258 
 259 #if defined(_ALLBSD_SOURCE)
 260     my_openat64_func = (openat64_func*)dlsym(RTLD_DEFAULT, &quot;openat&quot;);
 261     my_fstatat64_func = (fstatat64_func*)dlsym(RTLD_DEFAULT, &quot;fstatat&quot;);
 262 #else
 263     my_openat64_func = (openat64_func*) dlsym(RTLD_DEFAULT, &quot;openat64&quot;);
 264     my_fstatat64_func = (fstatat64_func*) dlsym(RTLD_DEFAULT, &quot;fstatat64&quot;);
 265 #endif
 266     my_unlinkat_func = (unlinkat_func*) dlsym(RTLD_DEFAULT, &quot;unlinkat&quot;);
 267     my_renameat_func = (renameat_func*) dlsym(RTLD_DEFAULT, &quot;renameat&quot;);
 268 #ifndef _ALLBSD_SOURCE
 269     my_futimesat_func = (futimesat_func*) dlsym(RTLD_DEFAULT, &quot;futimesat&quot;);
 270     my_lutimes_func = (lutimes_func*) dlsym(RTLD_DEFAULT, &quot;lutimes&quot;);
 271 #endif
 272     my_futimens_func = (futimens_func*) dlsym(RTLD_DEFAULT, &quot;futimens&quot;);
 273 #if defined(_AIX)
 274     my_fdopendir_func = (fdopendir_func*) dlsym(RTLD_DEFAULT, &quot;fdopendir64&quot;);
 275 #else
 276     my_fdopendir_func = (fdopendir_func*) dlsym(RTLD_DEFAULT, &quot;fdopendir&quot;);
 277 #endif
 278 
 279 #if defined(FSTATAT64_SYSCALL_AVAILABLE)
 280     /* fstatat64 missing from glibc */
 281     if (my_fstatat64_func == NULL)
 282         my_fstatat64_func = (fstatat64_func*)&amp;fstatat64_wrapper;
 283 #endif
 284 
 285     /* supports futimes or futimesat, futimens, and/or lutimes */
 286 
 287 #ifdef _ALLBSD_SOURCE
 288     capabilities |= sun_nio_fs_UnixNativeDispatcher_SUPPORTS_FUTIMES;
 289     capabilities |= sun_nio_fs_UnixNativeDispatcher_SUPPORTS_LUTIMES;
 290 #else
 291     if (my_futimesat_func != NULL)
 292         capabilities |= sun_nio_fs_UnixNativeDispatcher_SUPPORTS_FUTIMES;
 293     if (my_lutimes_func != NULL)
 294         capabilities |= sun_nio_fs_UnixNativeDispatcher_SUPPORTS_LUTIMES;
 295 #endif
 296     if (my_futimens_func != NULL)
 297         capabilities |= sun_nio_fs_UnixNativeDispatcher_SUPPORTS_FUTIMENS;
 298 
 299     /* supports openat, etc. */
 300 
 301     if (my_openat64_func != NULL &amp;&amp;  my_fstatat64_func != NULL &amp;&amp;
 302         my_unlinkat_func != NULL &amp;&amp; my_renameat_func != NULL &amp;&amp;
 303         my_futimesat_func != NULL &amp;&amp; my_fdopendir_func != NULL)
 304     {
 305         capabilities |= sun_nio_fs_UnixNativeDispatcher_SUPPORTS_OPENAT;
 306     }
 307 
 308     /* supports file birthtime */
 309 
 310 #ifdef _DARWIN_FEATURE_64_BIT_INODE
 311     capabilities |= sun_nio_fs_UnixNativeDispatcher_SUPPORTS_BIRTHTIME;
 312 #endif
 313 
 314     return capabilities;
 315 }
 316 
 317 JNIEXPORT jbyteArray JNICALL
 318 Java_sun_nio_fs_UnixNativeDispatcher_getcwd(JNIEnv* env, jclass this) {
 319     jbyteArray result = NULL;
 320     char buf[PATH_MAX+1];
 321 
 322     /* EINTR not listed as a possible error */
 323     char* cwd = getcwd(buf, sizeof(buf));
 324     if (cwd == NULL) {
 325         throwUnixException(env, errno);
 326     } else {
 327         jsize len = (jsize)strlen(buf);
 328         result = (*env)-&gt;NewByteArray(env, len);
 329         if (result != NULL) {
 330             (*env)-&gt;SetByteArrayRegion(env, result, 0, len, (jbyte*)buf);
 331         }
 332     }
 333     return result;
 334 }
 335 
 336 JNIEXPORT jbyteArray
 337 Java_sun_nio_fs_UnixNativeDispatcher_strerror(JNIEnv* env, jclass this, jint error)
 338 {
 339     char tmpbuf[1024];
 340     jsize len;
 341     jbyteArray bytes;
 342 
 343     getErrorString((int)errno, tmpbuf, sizeof(tmpbuf));
 344     len = strlen(tmpbuf);
 345     bytes = (*env)-&gt;NewByteArray(env, len);
 346     if (bytes != NULL) {
 347         (*env)-&gt;SetByteArrayRegion(env, bytes, 0, len, (jbyte*)tmpbuf);
 348     }
 349     return bytes;
 350 }
 351 
 352 JNIEXPORT jint
 353 Java_sun_nio_fs_UnixNativeDispatcher_dup(JNIEnv* env, jclass this, jint fd) {
 354 
 355     int res = -1;
 356 
 357     RESTARTABLE(dup((int)fd), res);
 358     if (res == -1) {
 359         throwUnixException(env, errno);
 360     }
 361     return (jint)res;
 362 }
 363 
 364 JNIEXPORT void JNICALL
 365 Java_sun_nio_fs_UnixNativeDispatcher_rewind(JNIEnv* env, jclass this, jlong stream)
 366 {
 367     FILE* fp = jlong_to_ptr(stream);
 368     int saved_errno;
 369 
 370     errno = 0;
 371     rewind(fp);
 372     saved_errno = errno;
 373     if (ferror(fp)) {
 374         throwUnixException(env, saved_errno);
 375     }
 376 }
 377 
 378 /**
 379  * This function returns line length without NUL terminator or -1 on EOF.
 380  */
 381 JNIEXPORT jint JNICALL
 382 Java_sun_nio_fs_UnixNativeDispatcher_getlinelen(JNIEnv* env, jclass this, jlong stream)
 383 {
 384     FILE* fp = jlong_to_ptr(stream);
 385     size_t lineSize = 0;
 386     char * lineBuffer = NULL;
 387     int saved_errno;
 388 
 389     ssize_t res = getline(&amp;lineBuffer, &amp;lineSize, fp);
 390     saved_errno = errno;
 391 
 392     /* Should free lineBuffer no matter result, according to man page */
 393     if (lineBuffer != NULL)
 394         free(lineBuffer);
 395 
 396     if (feof(fp))
 397         return -1;
 398 
 399     /* On successfull return res &gt;= 0, otherwise res is -1 */
 400     if (res == -1)
 401         throwUnixException(env, saved_errno);
 402 
 403     if (res &gt; INT_MAX)
 404         throwUnixException(env, EOVERFLOW);
 405 
 406     return (jint)res;
 407 }
 408 
 409 JNIEXPORT jint JNICALL
 410 Java_sun_nio_fs_UnixNativeDispatcher_open0(JNIEnv* env, jclass this,
 411     jlong pathAddress, jint oflags, jint mode)
 412 {
 413     jint fd;
 414     const char* path = (const char*)jlong_to_ptr(pathAddress);
 415 
 416     RESTARTABLE(open64(path, (int)oflags, (mode_t)mode), fd);
 417     if (fd == -1) {
 418         throwUnixException(env, errno);
 419     }
 420     return fd;
 421 }
 422 
 423 JNIEXPORT jint JNICALL
 424 Java_sun_nio_fs_UnixNativeDispatcher_openat0(JNIEnv* env, jclass this, jint dfd,
 425     jlong pathAddress, jint oflags, jint mode)
 426 {
 427     jint fd;
 428     const char* path = (const char*)jlong_to_ptr(pathAddress);
 429 
 430     if (my_openat64_func == NULL) {
 431         JNU_ThrowInternalError(env, &quot;should not reach here&quot;);
 432         return -1;
 433     }
 434 
 435     RESTARTABLE((*my_openat64_func)(dfd, path, (int)oflags, (mode_t)mode), fd);
 436     if (fd == -1) {
 437         throwUnixException(env, errno);
 438     }
 439     return fd;
 440 }
 441 
 442 JNIEXPORT void JNICALL
 443 Java_sun_nio_fs_UnixNativeDispatcher_close0(JNIEnv* env, jclass this, jint fd) {
 444     int res;
 445 
 446 #if defined(_AIX)
 447     /* AIX allows close to be restarted after EINTR */
 448     RESTARTABLE(close((int)fd), res);
 449 #else
 450     res = close((int)fd);
 451 #endif
 452     if (res == -1 &amp;&amp; errno != EINTR) {
 453         throwUnixException(env, errno);
 454     }
 455 }
 456 
 457 JNIEXPORT jint JNICALL
 458 Java_sun_nio_fs_UnixNativeDispatcher_read(JNIEnv* env, jclass this, jint fd,
 459     jlong address, jint nbytes)
 460 {
 461     ssize_t n;
 462     void* bufp = jlong_to_ptr(address);
 463     RESTARTABLE(read((int)fd, bufp, (size_t)nbytes), n);
 464     if (n == -1) {
 465         throwUnixException(env, errno);
 466     }
 467     return (jint)n;
 468 }
 469 
 470 JNIEXPORT jint JNICALL
 471 Java_sun_nio_fs_UnixNativeDispatcher_write(JNIEnv* env, jclass this, jint fd,
 472     jlong address, jint nbytes)
 473 {
 474     ssize_t n;
 475     void* bufp = jlong_to_ptr(address);
 476     RESTARTABLE(write((int)fd, bufp, (size_t)nbytes), n);
 477     if (n == -1) {
 478         throwUnixException(env, errno);
 479     }
 480     return (jint)n;
 481 }
 482 
 483 /**
 484  * Copy stat64 members into sun.nio.fs.UnixFileAttributes
 485  */
 486 static void prepAttributes(JNIEnv* env, struct stat64* buf, jobject attrs) {
 487     (*env)-&gt;SetIntField(env, attrs, attrs_st_mode, (jint)buf-&gt;st_mode);
 488     (*env)-&gt;SetLongField(env, attrs, attrs_st_ino, (jlong)buf-&gt;st_ino);
 489     (*env)-&gt;SetLongField(env, attrs, attrs_st_dev, (jlong)buf-&gt;st_dev);
 490     (*env)-&gt;SetLongField(env, attrs, attrs_st_rdev, (jlong)buf-&gt;st_rdev);
 491     (*env)-&gt;SetIntField(env, attrs, attrs_st_nlink, (jint)buf-&gt;st_nlink);
 492     (*env)-&gt;SetIntField(env, attrs, attrs_st_uid, (jint)buf-&gt;st_uid);
 493     (*env)-&gt;SetIntField(env, attrs, attrs_st_gid, (jint)buf-&gt;st_gid);
 494     (*env)-&gt;SetLongField(env, attrs, attrs_st_size, (jlong)buf-&gt;st_size);
 495     (*env)-&gt;SetLongField(env, attrs, attrs_st_atime_sec, (jlong)buf-&gt;st_atime);
 496     (*env)-&gt;SetLongField(env, attrs, attrs_st_mtime_sec, (jlong)buf-&gt;st_mtime);
 497     (*env)-&gt;SetLongField(env, attrs, attrs_st_ctime_sec, (jlong)buf-&gt;st_ctime);
 498 
 499 #ifdef _DARWIN_FEATURE_64_BIT_INODE
 500     (*env)-&gt;SetLongField(env, attrs, attrs_st_birthtime_sec, (jlong)buf-&gt;st_birthtime);
 501 #endif
 502 
 503 #ifndef MACOSX
 504     (*env)-&gt;SetLongField(env, attrs, attrs_st_atime_nsec, (jlong)buf-&gt;st_atim.tv_nsec);
 505     (*env)-&gt;SetLongField(env, attrs, attrs_st_mtime_nsec, (jlong)buf-&gt;st_mtim.tv_nsec);
 506     (*env)-&gt;SetLongField(env, attrs, attrs_st_ctime_nsec, (jlong)buf-&gt;st_ctim.tv_nsec);
 507 #else
 508     (*env)-&gt;SetLongField(env, attrs, attrs_st_atime_nsec, (jlong)buf-&gt;st_atimespec.tv_nsec);
 509     (*env)-&gt;SetLongField(env, attrs, attrs_st_mtime_nsec, (jlong)buf-&gt;st_mtimespec.tv_nsec);
 510     (*env)-&gt;SetLongField(env, attrs, attrs_st_ctime_nsec, (jlong)buf-&gt;st_ctimespec.tv_nsec);
 511 #endif
 512 }
 513 
 514 JNIEXPORT void JNICALL
 515 Java_sun_nio_fs_UnixNativeDispatcher_stat0(JNIEnv* env, jclass this,
 516     jlong pathAddress, jobject attrs)
 517 {
 518     int err;
 519     struct stat64 buf;
 520     const char* path = (const char*)jlong_to_ptr(pathAddress);
 521 
 522     RESTARTABLE(stat64(path, &amp;buf), err);
 523     if (err == -1) {
 524         throwUnixException(env, errno);
 525     } else {
 526         prepAttributes(env, &amp;buf, attrs);
 527     }
 528 }
 529 
 530 JNIEXPORT jint JNICALL
 531 Java_sun_nio_fs_UnixNativeDispatcher_stat1(JNIEnv* env, jclass this, jlong pathAddress) {
 532     int err;
 533     struct stat64 buf;
 534     const char* path = (const char*)jlong_to_ptr(pathAddress);
 535 
 536     RESTARTABLE(stat64(path, &amp;buf), err);
 537     if (err == -1) {
 538         return 0;
 539     } else {
 540         return (jint)buf.st_mode;
 541     }
 542 }
 543 
 544 JNIEXPORT void JNICALL
 545 Java_sun_nio_fs_UnixNativeDispatcher_lstat0(JNIEnv* env, jclass this,
 546     jlong pathAddress, jobject attrs)
 547 {
 548     int err;
 549     struct stat64 buf;
 550     const char* path = (const char*)jlong_to_ptr(pathAddress);
 551 
 552     RESTARTABLE(lstat64(path, &amp;buf), err);
 553     if (err == -1) {
 554         throwUnixException(env, errno);
 555     } else {
 556         prepAttributes(env, &amp;buf, attrs);
 557     }
 558 }
 559 
 560 JNIEXPORT void JNICALL
 561 Java_sun_nio_fs_UnixNativeDispatcher_fstat(JNIEnv* env, jclass this, jint fd,
 562     jobject attrs)
 563 {
 564     int err;
 565     struct stat64 buf;
 566 
 567     RESTARTABLE(fstat64((int)fd, &amp;buf), err);
 568     if (err == -1) {
 569         throwUnixException(env, errno);
 570     } else {
 571         prepAttributes(env, &amp;buf, attrs);
 572     }
 573 }
 574 
 575 JNIEXPORT void JNICALL
 576 Java_sun_nio_fs_UnixNativeDispatcher_fstatat0(JNIEnv* env, jclass this, jint dfd,
 577     jlong pathAddress, jint flag, jobject attrs)
 578 {
 579     int err;
 580     struct stat64 buf;
 581     const char* path = (const char*)jlong_to_ptr(pathAddress);
 582 
 583     if (my_fstatat64_func == NULL) {
 584         JNU_ThrowInternalError(env, &quot;should not reach here&quot;);
 585         return;
 586     }
 587     RESTARTABLE((*my_fstatat64_func)((int)dfd, path, &amp;buf, (int)flag), err);
 588     if (err == -1) {
 589         throwUnixException(env, errno);
 590     } else {
 591         prepAttributes(env, &amp;buf, attrs);
 592     }
 593 }
 594 
 595 JNIEXPORT void JNICALL
 596 Java_sun_nio_fs_UnixNativeDispatcher_chmod0(JNIEnv* env, jclass this,
 597     jlong pathAddress, jint mode)
 598 {
 599     int err;
 600     const char* path = (const char*)jlong_to_ptr(pathAddress);
 601 
 602     RESTARTABLE(chmod(path, (mode_t)mode), err);
 603     if (err == -1) {
 604         throwUnixException(env, errno);
 605     }
 606 }
 607 
 608 JNIEXPORT void JNICALL
 609 Java_sun_nio_fs_UnixNativeDispatcher_fchmod(JNIEnv* env, jclass this, jint filedes,
 610     jint mode)
 611 {
 612     int err;
 613 
 614     RESTARTABLE(fchmod((int)filedes, (mode_t)mode), err);
 615     if (err == -1) {
 616         throwUnixException(env, errno);
 617     }
 618 }
 619 
 620 
 621 JNIEXPORT void JNICALL
 622 Java_sun_nio_fs_UnixNativeDispatcher_chown0(JNIEnv* env, jclass this,
 623     jlong pathAddress, jint uid, jint gid)
 624 {
 625     int err;
 626     const char* path = (const char*)jlong_to_ptr(pathAddress);
 627 
 628     RESTARTABLE(chown(path, (uid_t)uid, (gid_t)gid), err);
 629     if (err == -1) {
 630         throwUnixException(env, errno);
 631     }
 632 }
 633 
 634 JNIEXPORT void JNICALL
 635 Java_sun_nio_fs_UnixNativeDispatcher_lchown0(JNIEnv* env, jclass this, jlong pathAddress, jint uid, jint gid)
 636 {
 637     int err;
 638     const char* path = (const char*)jlong_to_ptr(pathAddress);
 639 
 640     RESTARTABLE(lchown(path, (uid_t)uid, (gid_t)gid), err);
 641     if (err == -1) {
 642         throwUnixException(env, errno);
 643     }
 644 }
 645 
 646 JNIEXPORT void JNICALL
 647 Java_sun_nio_fs_UnixNativeDispatcher_fchown(JNIEnv* env, jclass this, jint filedes, jint uid, jint gid)
 648 {
 649     int err;
 650 
 651     RESTARTABLE(fchown(filedes, (uid_t)uid, (gid_t)gid), err);
 652     if (err == -1) {
 653         throwUnixException(env, errno);
 654     }
 655 }
 656 
 657 JNIEXPORT void JNICALL
 658 Java_sun_nio_fs_UnixNativeDispatcher_utimes0(JNIEnv* env, jclass this,
 659     jlong pathAddress, jlong accessTime, jlong modificationTime)
 660 {
 661     int err;
 662     struct timeval times[2];
 663     const char* path = (const char*)jlong_to_ptr(pathAddress);
 664 
 665     times[0].tv_sec = accessTime / 1000000;
 666     times[0].tv_usec = accessTime % 1000000;
 667 
 668     times[1].tv_sec = modificationTime / 1000000;
 669     times[1].tv_usec = modificationTime % 1000000;
 670 
 671     RESTARTABLE(utimes(path, &amp;times[0]), err);
 672     if (err == -1) {
 673         throwUnixException(env, errno);
 674     }
 675 }
 676 
 677 JNIEXPORT void JNICALL
 678 Java_sun_nio_fs_UnixNativeDispatcher_futimes(JNIEnv* env, jclass this, jint filedes,
 679     jlong accessTime, jlong modificationTime)
 680 {
 681     struct timeval times[2];
 682     int err = 0;
 683 
 684     times[0].tv_sec = accessTime / 1000000;
 685     times[0].tv_usec = accessTime % 1000000;
 686 
 687     times[1].tv_sec = modificationTime / 1000000;
 688     times[1].tv_usec = modificationTime % 1000000;
 689 
 690 #ifdef _ALLBSD_SOURCE
 691     RESTARTABLE(futimes(filedes, &amp;times[0]), err);
 692 #else
 693     if (my_futimesat_func == NULL) {
 694         JNU_ThrowInternalError(env, &quot;my_futimesat_func is NULL&quot;);
 695         return;
 696     }
 697     RESTARTABLE((*my_futimesat_func)(filedes, NULL, &amp;times[0]), err);
 698 #endif
 699     if (err == -1) {
 700         throwUnixException(env, errno);
 701     }
 702 }
 703 
 704 JNIEXPORT void JNICALL
 705 Java_sun_nio_fs_UnixNativeDispatcher_futimens(JNIEnv* env, jclass this, jint filedes,
 706     jlong accessTime, jlong modificationTime)
 707 {
 708     struct timespec times[2];
 709     int err = 0;
 710 
 711     times[0].tv_sec = accessTime / 1000000000;
 712     times[0].tv_nsec = accessTime % 1000000000;
 713 
 714     times[1].tv_sec = modificationTime / 1000000000;
 715     times[1].tv_nsec = modificationTime % 1000000000;
 716 
 717     if (my_futimens_func == NULL) {
 718         JNU_ThrowInternalError(env, &quot;my_futimens_func is NULL&quot;);
 719         return;
 720     }
 721     RESTARTABLE((*my_futimens_func)(filedes, &amp;times[0]), err);
 722     if (err == -1) {
 723         throwUnixException(env, errno);
 724     }
 725 }
 726 
 727 JNIEXPORT void JNICALL
 728 Java_sun_nio_fs_UnixNativeDispatcher_lutimes0(JNIEnv* env, jclass this,
 729     jlong pathAddress, jlong accessTime, jlong modificationTime)
 730 {
 731     int err;
 732     struct timeval times[2];
 733     const char* path = (const char*)jlong_to_ptr(pathAddress);
 734 
 735     times[0].tv_sec = accessTime / 1000000;
 736     times[0].tv_usec = accessTime % 1000000;
 737 
 738     times[1].tv_sec = modificationTime / 1000000;
 739     times[1].tv_usec = modificationTime % 1000000;
 740 
 741 #ifdef _ALLBSD_SOURCE
 742     RESTARTABLE(lutimes(path, &amp;times[0]), err);
 743 #else
 744     if (my_lutimes_func == NULL) {
 745         JNU_ThrowInternalError(env, &quot;my_lutimes_func is NULL&quot;);
 746         return;
 747     }
 748     RESTARTABLE((*my_lutimes_func)(path, &amp;times[0]), err);
 749 #endif
 750     if (err == -1) {
 751         throwUnixException(env, errno);
 752     }
 753 }
 754 
 755 JNIEXPORT jlong JNICALL
 756 Java_sun_nio_fs_UnixNativeDispatcher_opendir0(JNIEnv* env, jclass this,
 757     jlong pathAddress)
 758 {
 759     DIR* dir;
 760     const char* path = (const char*)jlong_to_ptr(pathAddress);
 761 
 762     /* EINTR not listed as a possible error */
 763     dir = opendir(path);
 764     if (dir == NULL) {
 765         throwUnixException(env, errno);
 766     }
 767     return ptr_to_jlong(dir);
 768 }
 769 
 770 JNIEXPORT jlong JNICALL
 771 Java_sun_nio_fs_UnixNativeDispatcher_fdopendir(JNIEnv* env, jclass this, int dfd) {
 772     DIR* dir;
 773 
 774     if (my_fdopendir_func == NULL) {
 775         JNU_ThrowInternalError(env, &quot;should not reach here&quot;);
 776         return (jlong)-1;
 777     }
 778 
 779     /* EINTR not listed as a possible error */
 780     dir = (*my_fdopendir_func)((int)dfd);
 781     if (dir == NULL) {
 782         throwUnixException(env, errno);
 783     }
 784     return ptr_to_jlong(dir);
 785 }
 786 
 787 JNIEXPORT void JNICALL
 788 Java_sun_nio_fs_UnixNativeDispatcher_closedir(JNIEnv* env, jclass this, jlong dir) {
 789     DIR* dirp = jlong_to_ptr(dir);
 790 
 791     if (closedir(dirp) == -1 &amp;&amp; errno != EINTR) {
 792         throwUnixException(env, errno);
 793     }
 794 }
 795 
 796 JNIEXPORT jbyteArray JNICALL
 797 Java_sun_nio_fs_UnixNativeDispatcher_readdir(JNIEnv* env, jclass this, jlong value) {
 798     DIR* dirp = jlong_to_ptr(value);
 799     struct dirent* ptr;
 800 
 801     errno = 0;
 802     ptr = readdir(dirp);
 803     if (ptr == NULL) {
 804         if (errno != 0) {
 805             throwUnixException(env, errno);
 806         }
 807         return NULL;
 808     } else {
 809         jsize len = strlen(ptr-&gt;d_name);
 810         jbyteArray bytes = (*env)-&gt;NewByteArray(env, len);
 811         if (bytes != NULL) {
 812             (*env)-&gt;SetByteArrayRegion(env, bytes, 0, len, (jbyte*)(ptr-&gt;d_name));
 813         }
 814         return bytes;
 815     }
 816 }
 817 
 818 JNIEXPORT void JNICALL
 819 Java_sun_nio_fs_UnixNativeDispatcher_mkdir0(JNIEnv* env, jclass this,
 820     jlong pathAddress, jint mode)
 821 {
 822     const char* path = (const char*)jlong_to_ptr(pathAddress);
 823 
 824     /* EINTR not listed as a possible error */
 825     if (mkdir(path, (mode_t)mode) == -1) {
 826         throwUnixException(env, errno);
 827     }
 828 }
 829 
 830 JNIEXPORT void JNICALL
 831 Java_sun_nio_fs_UnixNativeDispatcher_rmdir0(JNIEnv* env, jclass this,
 832     jlong pathAddress)
 833 {
 834     const char* path = (const char*)jlong_to_ptr(pathAddress);
 835 
 836     /* EINTR not listed as a possible error */
 837     if (rmdir(path) == -1) {
 838         throwUnixException(env, errno);
 839     }
 840 }
 841 
 842 JNIEXPORT void JNICALL
 843 Java_sun_nio_fs_UnixNativeDispatcher_link0(JNIEnv* env, jclass this,
 844     jlong existingAddress, jlong newAddress)
 845 {
 846     int err;
 847     const char* existing = (const char*)jlong_to_ptr(existingAddress);
 848     const char* newname = (const char*)jlong_to_ptr(newAddress);
 849 
 850     RESTARTABLE(link(existing, newname), err);
 851     if (err == -1) {
 852         throwUnixException(env, errno);
 853     }
 854 }
 855 
 856 
 857 JNIEXPORT void JNICALL
 858 Java_sun_nio_fs_UnixNativeDispatcher_unlink0(JNIEnv* env, jclass this,
 859     jlong pathAddress)
 860 {
 861     const char* path = (const char*)jlong_to_ptr(pathAddress);
 862 
 863     /* EINTR not listed as a possible error */
 864     if (unlink(path) == -1) {
 865         throwUnixException(env, errno);
 866     }
 867 }
 868 
 869 JNIEXPORT void JNICALL
 870 Java_sun_nio_fs_UnixNativeDispatcher_unlinkat0(JNIEnv* env, jclass this, jint dfd,
 871                                                jlong pathAddress, jint flags)
 872 {
 873     const char* path = (const char*)jlong_to_ptr(pathAddress);
 874 
 875     if (my_unlinkat_func == NULL) {
 876         JNU_ThrowInternalError(env, &quot;should not reach here&quot;);
 877         return;
 878     }
 879 
 880     /* EINTR not listed as a possible error */
 881     if ((*my_unlinkat_func)((int)dfd, path, (int)flags) == -1) {
 882         throwUnixException(env, errno);
 883     }
 884 }
 885 
 886 JNIEXPORT void JNICALL
 887 Java_sun_nio_fs_UnixNativeDispatcher_rename0(JNIEnv* env, jclass this,
 888     jlong fromAddress, jlong toAddress)
 889 {
 890     const char* from = (const char*)jlong_to_ptr(fromAddress);
 891     const char* to = (const char*)jlong_to_ptr(toAddress);
 892 
 893     /* EINTR not listed as a possible error */
 894     if (rename(from, to) == -1) {
 895         throwUnixException(env, errno);
 896     }
 897 }
 898 
 899 JNIEXPORT void JNICALL
 900 Java_sun_nio_fs_UnixNativeDispatcher_renameat0(JNIEnv* env, jclass this,
 901     jint fromfd, jlong fromAddress, jint tofd, jlong toAddress)
 902 {
 903     const char* from = (const char*)jlong_to_ptr(fromAddress);
 904     const char* to = (const char*)jlong_to_ptr(toAddress);
 905 
 906     if (my_renameat_func == NULL) {
 907         JNU_ThrowInternalError(env, &quot;should not reach here&quot;);
 908         return;
 909     }
 910 
 911     /* EINTR not listed as a possible error */
 912     if ((*my_renameat_func)((int)fromfd, from, (int)tofd, to) == -1) {
 913         throwUnixException(env, errno);
 914     }
 915 }
 916 
 917 JNIEXPORT void JNICALL
 918 Java_sun_nio_fs_UnixNativeDispatcher_symlink0(JNIEnv* env, jclass this,
 919     jlong targetAddress, jlong linkAddress)
 920 {
 921     const char* target = (const char*)jlong_to_ptr(targetAddress);
 922     const char* link = (const char*)jlong_to_ptr(linkAddress);
 923 
 924     /* EINTR not listed as a possible error */
 925     if (symlink(target, link) == -1) {
 926         throwUnixException(env, errno);
 927     }
 928 }
 929 
 930 JNIEXPORT jbyteArray JNICALL
 931 Java_sun_nio_fs_UnixNativeDispatcher_readlink0(JNIEnv* env, jclass this,
 932     jlong pathAddress)
 933 {
 934     jbyteArray result = NULL;
 935     char target[PATH_MAX+1];
 936     const char* path = (const char*)jlong_to_ptr(pathAddress);
 937 
 938     /* EINTR not listed as a possible error */
 939     int n = readlink(path, target, sizeof(target));
 940     if (n == -1) {
 941         throwUnixException(env, errno);
 942     } else {
 943         jsize len;
 944         if (n == sizeof(target)) {
 945             /* Traditionally readlink(2) should not return more than */
 946             /* PATH_MAX bytes (no terminating null byte is appended). */
 947             throwUnixException(env, ENAMETOOLONG);
 948             return NULL;
 949         }
 950         target[n] = &#39;\0&#39;;
 951         len = (jsize)strlen(target);
 952         result = (*env)-&gt;NewByteArray(env, len);
 953         if (result != NULL) {
 954             (*env)-&gt;SetByteArrayRegion(env, result, 0, len, (jbyte*)target);
 955         }
 956     }
 957     return result;
 958 }
 959 
 960 JNIEXPORT jbyteArray JNICALL
 961 Java_sun_nio_fs_UnixNativeDispatcher_realpath0(JNIEnv* env, jclass this,
 962     jlong pathAddress)
 963 {
 964     jbyteArray result = NULL;
 965     char resolved[PATH_MAX+1];
 966     const char* path = (const char*)jlong_to_ptr(pathAddress);
 967 
 968     /* EINTR not listed as a possible error */
 969     if (realpath(path, resolved) == NULL) {
 970         throwUnixException(env, errno);
 971     } else {
 972         jsize len = (jsize)strlen(resolved);
 973         result = (*env)-&gt;NewByteArray(env, len);
 974         if (result != NULL) {
 975             (*env)-&gt;SetByteArrayRegion(env, result, 0, len, (jbyte*)resolved);
 976         }
 977     }
 978     return result;
 979 }
 980 
 981 JNIEXPORT void JNICALL
 982 Java_sun_nio_fs_UnixNativeDispatcher_access0(JNIEnv* env, jclass this,
 983     jlong pathAddress, jint amode)
 984 {
 985     int err;
 986     const char* path = (const char*)jlong_to_ptr(pathAddress);
 987 
 988     RESTARTABLE(access(path, (int)amode), err);
 989     if (err == -1) {
 990         throwUnixException(env, errno);
 991     }
 992 }
 993 
 994 JNIEXPORT jboolean JNICALL
 995 Java_sun_nio_fs_UnixNativeDispatcher_exists0(JNIEnv* env, jclass this, jlong pathAddress) {
 996     int err;
 997     const char* path = (const char*)jlong_to_ptr(pathAddress);
 998     RESTARTABLE(access(path, F_OK), err);
 999     return (err == 0) ? JNI_TRUE : JNI_FALSE;
1000 }
1001 
1002 JNIEXPORT void JNICALL
1003 Java_sun_nio_fs_UnixNativeDispatcher_statvfs0(JNIEnv* env, jclass this,
1004     jlong pathAddress, jobject attrs)
1005 {
1006     int err;
1007 #ifdef MACOSX
1008     struct statfs buf;
1009 #else
1010     struct statvfs64 buf;
1011 #endif
1012     const char* path = (const char*)jlong_to_ptr(pathAddress);
1013 
1014 #ifdef MACOSX
1015     RESTARTABLE(statfs(path, &amp;buf), err);
1016 #else
1017     RESTARTABLE(statvfs64(path, &amp;buf), err);
1018 #endif
1019     if (err == -1) {
1020         throwUnixException(env, errno);
1021     } else {
1022 #ifdef _AIX
1023         /* AIX returns ULONG_MAX in buf.f_blocks for the /proc file system. */
1024         /* This is too big for a Java signed long and fools various tests.  */
1025         if (buf.f_blocks == ULONG_MAX) {
1026             buf.f_blocks = 0;
1027         }
1028         /* The number of free or available blocks can never exceed the total number of blocks */
1029         if (buf.f_blocks == 0) {
1030             buf.f_bfree = 0;
1031             buf.f_bavail = 0;
1032         }
1033 #endif
1034 #ifdef MACOSX
1035         (*env)-&gt;SetLongField(env, attrs, attrs_f_frsize, long_to_jlong(buf.f_bsize));
1036 #else
1037         (*env)-&gt;SetLongField(env, attrs, attrs_f_frsize, long_to_jlong(buf.f_frsize));
1038 #endif
1039         (*env)-&gt;SetLongField(env, attrs, attrs_f_blocks, long_to_jlong(buf.f_blocks));
1040         (*env)-&gt;SetLongField(env, attrs, attrs_f_bfree,  long_to_jlong(buf.f_bfree));
1041         (*env)-&gt;SetLongField(env, attrs, attrs_f_bavail, long_to_jlong(buf.f_bavail));
1042     }
1043 }
1044 
1045 JNIEXPORT void JNICALL
1046 Java_sun_nio_fs_UnixNativeDispatcher_mknod0(JNIEnv* env, jclass this,
1047     jlong pathAddress, jint mode, jlong dev)
1048 {
1049     int err;
1050     const char* path = (const char*)jlong_to_ptr(pathAddress);
1051 
1052     RESTARTABLE(mknod(path, (mode_t)mode, (dev_t)dev), err);
1053     if (err == -1) {
1054         throwUnixException(env, errno);
1055     }
1056 }
1057 
1058 JNIEXPORT jbyteArray JNICALL
1059 Java_sun_nio_fs_UnixNativeDispatcher_getpwuid(JNIEnv* env, jclass this, jint uid)
1060 {
1061     jbyteArray result = NULL;
1062     int buflen;
1063     char* pwbuf;
1064 
1065     /* allocate buffer for password record */
1066     buflen = (int)sysconf(_SC_GETPW_R_SIZE_MAX);
1067     if (buflen == -1)
1068         buflen = ENT_BUF_SIZE;
1069     pwbuf = (char*)malloc(buflen);
1070     if (pwbuf == NULL) {
1071         JNU_ThrowOutOfMemoryError(env, &quot;native heap&quot;);
1072     } else {
1073         struct passwd pwent;
1074         struct passwd* p = NULL;
1075         int res = 0;
1076 
1077         errno = 0;
1078         RESTARTABLE(getpwuid_r((uid_t)uid, &amp;pwent, pwbuf, (size_t)buflen, &amp;p), res);
1079 
1080         if (res != 0 || p == NULL || p-&gt;pw_name == NULL || *(p-&gt;pw_name) == &#39;\0&#39;) {
1081             /* not found or error */
1082             if (errno == 0)
1083                 errno = ENOENT;
1084             throwUnixException(env, errno);
1085         } else {
1086             jsize len = strlen(p-&gt;pw_name);
1087             result = (*env)-&gt;NewByteArray(env, len);
1088             if (result != NULL) {
1089                 (*env)-&gt;SetByteArrayRegion(env, result, 0, len, (jbyte*)(p-&gt;pw_name));
1090             }
1091         }
1092         free(pwbuf);
1093     }
1094 
1095     return result;
1096 }
1097 
1098 
1099 JNIEXPORT jbyteArray JNICALL
1100 Java_sun_nio_fs_UnixNativeDispatcher_getgrgid(JNIEnv* env, jclass this, jint gid)
1101 {
1102     jbyteArray result = NULL;
1103     int buflen;
1104     int retry;
1105 
1106     /* initial size of buffer for group record */
1107     buflen = (int)sysconf(_SC_GETGR_R_SIZE_MAX);
1108     if (buflen == -1)
1109         buflen = ENT_BUF_SIZE;
1110 
1111     do {
1112         struct group grent;
1113         struct group* g = NULL;
1114         int res = 0;
1115 
1116         char* grbuf = (char*)malloc(buflen);
1117         if (grbuf == NULL) {
1118             JNU_ThrowOutOfMemoryError(env, &quot;native heap&quot;);
1119             return NULL;
1120         }
1121 
1122         errno = 0;
1123         RESTARTABLE(getgrgid_r((gid_t)gid, &amp;grent, grbuf, (size_t)buflen, &amp;g), res);
1124 
1125         retry = 0;
1126         if (res != 0 || g == NULL || g-&gt;gr_name == NULL || *(g-&gt;gr_name) == &#39;\0&#39;) {
1127             /* not found or error */
1128             if (errno == ERANGE) {
1129                 /* insufficient buffer size so need larger buffer */
1130                 buflen += ENT_BUF_SIZE;
1131                 retry = 1;
1132             } else {
1133                 if (errno == 0)
1134                     errno = ENOENT;
1135                 throwUnixException(env, errno);
1136             }
1137         } else {
1138             jsize len = strlen(g-&gt;gr_name);
1139             result = (*env)-&gt;NewByteArray(env, len);
1140             if (result != NULL) {
1141                 (*env)-&gt;SetByteArrayRegion(env, result, 0, len, (jbyte*)(g-&gt;gr_name));
1142             }
1143         }
1144 
1145         free(grbuf);
1146 
1147     } while (retry);
1148 
1149     return result;
1150 }
1151 
1152 JNIEXPORT jint JNICALL
1153 Java_sun_nio_fs_UnixNativeDispatcher_getpwnam0(JNIEnv* env, jclass this,
1154     jlong nameAddress)
1155 {
1156     jint uid = -1;
1157     int buflen;
1158     char* pwbuf;
1159 
1160     /* allocate buffer for password record */
1161     buflen = (int)sysconf(_SC_GETPW_R_SIZE_MAX);
1162     if (buflen == -1)
1163         buflen = ENT_BUF_SIZE;
1164     pwbuf = (char*)malloc(buflen);
1165     if (pwbuf == NULL) {
1166         JNU_ThrowOutOfMemoryError(env, &quot;native heap&quot;);
1167     } else {
1168         struct passwd pwent;
1169         struct passwd* p = NULL;
1170         int res = 0;
1171         const char* name = (const char*)jlong_to_ptr(nameAddress);
1172 
1173         errno = 0;
1174         RESTARTABLE(getpwnam_r(name, &amp;pwent, pwbuf, (size_t)buflen, &amp;p), res);
1175 
1176         if (res != 0 || p == NULL || p-&gt;pw_name == NULL || *(p-&gt;pw_name) == &#39;\0&#39;) {
1177             /* not found or error */
1178             if (errno != 0 &amp;&amp; errno != ENOENT &amp;&amp; errno != ESRCH &amp;&amp;
1179                 errno != EBADF &amp;&amp; errno != EPERM)
1180             {
1181                 throwUnixException(env, errno);
1182             }
1183         } else {
1184             uid = p-&gt;pw_uid;
1185         }
1186         free(pwbuf);
1187     }
1188 
1189     return uid;
1190 }
1191 
1192 JNIEXPORT jint JNICALL
1193 Java_sun_nio_fs_UnixNativeDispatcher_getgrnam0(JNIEnv* env, jclass this,
1194     jlong nameAddress)
1195 {
1196     jint gid = -1;
1197     int buflen, retry;
1198 
1199     /* initial size of buffer for group record */
1200     buflen = (int)sysconf(_SC_GETGR_R_SIZE_MAX);
1201     if (buflen == -1)
1202         buflen = ENT_BUF_SIZE;
1203 
1204     do {
1205         struct group grent;
1206         struct group* g = NULL;
1207         int res = 0;
1208         char *grbuf;
1209         const char* name = (const char*)jlong_to_ptr(nameAddress);
1210 
1211         grbuf = (char*)malloc(buflen);
1212         if (grbuf == NULL) {
1213             JNU_ThrowOutOfMemoryError(env, &quot;native heap&quot;);
1214             return -1;
1215         }
1216 
1217         errno = 0;
1218         RESTARTABLE(getgrnam_r(name, &amp;grent, grbuf, (size_t)buflen, &amp;g), res);
1219 
1220         retry = 0;
1221         if (res != 0 || g == NULL || g-&gt;gr_name == NULL || *(g-&gt;gr_name) == &#39;\0&#39;) {
1222             /* not found or error */
1223             if (errno != 0 &amp;&amp; errno != ENOENT &amp;&amp; errno != ESRCH &amp;&amp;
1224                 errno != EBADF &amp;&amp; errno != EPERM)
1225             {
1226                 if (errno == ERANGE) {
1227                     /* insufficient buffer size so need larger buffer */
1228                     buflen += ENT_BUF_SIZE;
1229                     retry = 1;
1230                 } else {
1231                     throwUnixException(env, errno);
1232                 }
1233             }
1234         } else {
1235             gid = g-&gt;gr_gid;
1236         }
1237 
1238         free(grbuf);
1239 
1240     } while (retry);
1241 
1242     return gid;
1243 }
    </pre>
  </body>
</html>
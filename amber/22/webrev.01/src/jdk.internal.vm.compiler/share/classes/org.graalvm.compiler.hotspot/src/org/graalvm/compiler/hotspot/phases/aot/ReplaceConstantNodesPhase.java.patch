diff a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/phases/aot/ReplaceConstantNodesPhase.java b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/phases/aot/ReplaceConstantNodesPhase.java
--- a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/phases/aot/ReplaceConstantNodesPhase.java
+++ b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/phases/aot/ReplaceConstantNodesPhase.java
@@ -26,10 +26,11 @@
 
 import static org.graalvm.compiler.core.common.cfg.AbstractControlFlowGraph.strictlyDominates;
 import static org.graalvm.compiler.hotspot.nodes.aot.LoadMethodCountersNode.getLoadMethodCountersNodes;
 import static org.graalvm.compiler.nodes.ConstantNode.getConstantNodes;
 
+import java.lang.ref.Reference;
 import java.util.HashSet;
 import java.util.List;
 
 import jdk.internal.vm.compiler.collections.EconomicMap;
 import jdk.internal.vm.compiler.collections.Equivalence;
@@ -80,20 +81,22 @@
 import jdk.vm.ci.meta.ResolvedJavaType;
 
 public class ReplaceConstantNodesPhase extends BasePhase<CoreProviders> {
 
     private final boolean verifyFingerprints;
+    private final boolean allowResolution;
 
     static Class<?> characterCacheClass = Character.class.getDeclaredClasses()[0];
     static Class<?> byteCacheClass = Byte.class.getDeclaredClasses()[0];
     static Class<?> shortCacheClass = Short.class.getDeclaredClasses()[0];
     static Class<?> integerCacheClass = Integer.class.getDeclaredClasses()[0];
     static Class<?> longCacheClass = Long.class.getDeclaredClasses()[0];
 
     static class ClassInfo {
 
         private ResolvedJavaType stringType;
+        private ResolvedJavaType referenceType;
         private final HashSet<ResolvedJavaType> builtIns = new HashSet<>();
 
         ClassInfo(MetaAccessProvider metaAccessProvider) {
             builtIns.add(metaAccessProvider.lookupJavaType(Boolean.class));
 
@@ -111,10 +114,11 @@
 
             assert "java.lang.Long$LongCache".equals(longCacheClass.getName());
             builtIns.add(metaAccessProvider.lookupJavaType(longCacheClass));
 
             stringType = metaAccessProvider.lookupJavaType(String.class);
+            referenceType = metaAccessProvider.lookupJavaType(Reference.class);
         }
     }
 
     private static boolean isReplacementNode(Node n) {
         // @formatter:off
@@ -311,12 +315,14 @@
      * Try to find dominating node doing the resolution that can be reused.
      *
      * @param graph
      * @param node {@link ConstantNode} containing a {@link HotSpotResolvedJavaType} that needs
      *            resolution.
+     * @return return true if all usages of the node have been replaced
      */
-    private static void tryToReplaceWithExisting(StructuredGraph graph, ConstantNode node) {
+    private static boolean tryToReplaceWithExisting(StructuredGraph graph, ConstantNode node) {
+        boolean allUsagesReplaced = true;
         ScheduleResult schedule = graph.getLastSchedule();
         NodeMap<Block> nodeToBlock = schedule.getNodeToBlockMap();
         BlockMap<List<Node>> blockToNodes = schedule.getBlockToNodesMap();
 
         EconomicMap<Block, Node> blockToExisting = EconomicMap.create(Equivalence.IDENTITY);
@@ -345,81 +351,130 @@
             if (!replaced) {
                 // Look for dominating blocks that have existing nodes
                 for (Block d : blockToExisting.getKeys()) {
                     if (strictlyDominates(d, b)) {
                         use.replaceFirstInput(node, blockToExisting.get(d));
+                        replaced = true;
                         break;
                     }
                 }
             }
+            if (!replaced && allUsagesReplaced) {
+                allUsagesReplaced = false;
+            }
         }
+        return allUsagesReplaced;
     }
 
     /**
-     * Replace the uses of a constant with either {@link LoadConstantIndirectlyNode} or
-     * {@link ResolveConstantNode}.
+     * Replace the uses of a constant with {@link ResolveConstantNode}.
      *
      * @param graph
      * @param stateMapper
      * @param node {@link ConstantNode} containing a {@link HotSpotResolvedJavaType} that needs
      *            resolution.
      */
     private static void replaceWithResolution(StructuredGraph graph, FrameStateMapperClosure stateMapper, ConstantNode node, ClassInfo classInfo) {
         HotSpotMetaspaceConstant metaspaceConstant = (HotSpotMetaspaceConstant) node.asConstant();
         HotSpotResolvedJavaType type = (HotSpotResolvedJavaType) metaspaceConstant.asResolvedJavaType();
-        ResolvedJavaType topMethodHolder = graph.method().getDeclaringClass();
-        ValueNode replacement;
 
-        if (type.isArray() && type.getComponentType().isPrimitive()) {
-            // Special case for primitive arrays. The AOT runtime pre-resolves them, so we may
-            // omit the resolution call.
+        FixedWithNextNode fixedReplacement;
+        if (classInfo.builtIns.contains(type)) {
+            // Special case of klass constants that come from {@link BoxingSnippets}.
+            fixedReplacement = graph.add(new ResolveConstantNode(node, HotSpotConstantLoadAction.INITIALIZE));
+        } else {
+            fixedReplacement = graph.add(new ResolveConstantNode(node));
+        }
+        insertReplacement(graph, stateMapper, node, fixedReplacement);
+        node.replaceAtUsages(fixedReplacement, n -> !isReplacementNode(n));
+    }
+
+    /**
+     * Replace the uses of a constant with either {@link LoadConstantIndirectlyNode} if possible.
+     *
+     * @param graph
+     * @param node {@link ConstantNode} containing a {@link HotSpotResolvedJavaType} that needs
+     *            resolution.
+     * @return return true if all usages of the node have been replaced
+     */
+    private static boolean replaceWithLoad(StructuredGraph graph, ConstantNode node, ClassInfo classInfo) {
+        HotSpotMetaspaceConstant metaspaceConstant = (HotSpotMetaspaceConstant) node.asConstant();
+        HotSpotResolvedJavaType type = (HotSpotResolvedJavaType) metaspaceConstant.asResolvedJavaType();
+        ResolvedJavaType topMethodHolder = graph.method().getDeclaringClass();
+        ValueNode replacement = null;
+        if ((type.isArray() && type.getComponentType().isPrimitive()) || type.equals(classInfo.referenceType)) {
+            // Special case for primitive arrays and j.l.ref.Reference.
+            // The AOT runtime pre-resolves them, so we may omit the resolution call.
             replacement = graph.addOrUnique(new LoadConstantIndirectlyNode(node));
         } else if (type.equals(topMethodHolder) || (type.isAssignableFrom(topMethodHolder) && !type.isInterface())) {
             // If it's a supertype of or the same class that declares the top method, we are
             // guaranteed to have it resolved already. If it's an interface, we just test for
             // equality.
             replacement = graph.addOrUnique(new LoadConstantIndirectlyNode(node));
-        } else {
-            FixedWithNextNode fixedReplacement;
-            if (classInfo.builtIns.contains(type)) {
-                // Special case of klass constants that come from {@link BoxingSnippets}.
-                fixedReplacement = graph.add(new ResolveConstantNode(node, HotSpotConstantLoadAction.INITIALIZE));
-            } else {
-                fixedReplacement = graph.add(new ResolveConstantNode(node));
+        }
+        if (replacement != null) {
+            node.replaceAtUsages(replacement, n -> !isReplacementNode(n));
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * Verify that {@link ConstantNode} containing a {@link HotSpotResolvedJavaType} has a valid
+     * fingerprint.
+     *
+     * @param node {@link ConstantNode} containing a {@link HotSpotResolvedJavaType}.
+     */
+    private void verifyFingerprint(ConstantNode node) {
+        HotSpotMetaspaceConstant metaspaceConstant = (HotSpotMetaspaceConstant) node.asConstant();
+        HotSpotResolvedJavaType type = (HotSpotResolvedJavaType) metaspaceConstant.asResolvedJavaType();
+        if (type != null) {
+            assert !metaspaceConstant.isCompressed() : "No support for replacing compressed metaspace constants";
+            if (verifyFingerprints && checkForBadFingerprint(type)) {
+                throw new GraalError("Type with bad fingerprint: " + type);
             }
-            insertReplacement(graph, stateMapper, node, fixedReplacement);
-            replacement = fixedReplacement;
         }
-        node.replaceAtUsages(replacement, n -> !isReplacementNode(n));
     }
 
     /**
      * Replace {@link ConstantNode} containing a {@link HotSpotResolvedJavaType} with indirection.
      *
      * @param graph
      * @param stateMapper
      * @param node {@link ConstantNode} containing a {@link HotSpotResolvedJavaType} that needs
      *            resolution.
      */
-    private void handleHotSpotMetaspaceConstant(StructuredGraph graph, FrameStateMapperClosure stateMapper, ConstantNode node, ClassInfo classInfo) {
+    private static void handleHotSpotMetaspaceConstant(StructuredGraph graph, FrameStateMapperClosure stateMapper, ConstantNode node, ClassInfo classInfo) {
         HotSpotMetaspaceConstant metaspaceConstant = (HotSpotMetaspaceConstant) node.asConstant();
         HotSpotResolvedJavaType type = (HotSpotResolvedJavaType) metaspaceConstant.asResolvedJavaType();
-
         if (type != null) {
-            if (verifyFingerprints && checkForBadFingerprint(type)) {
-                throw new GraalError("Type with bad fingerprint: " + type);
-            }
-            assert !metaspaceConstant.isCompressed() : "No support for replacing compressed metaspace constants";
-            tryToReplaceWithExisting(graph, node);
-            if (anyUsagesNeedReplacement(node)) {
+            if (!tryToReplaceWithExisting(graph, node) && !replaceWithLoad(graph, node, classInfo)) {
                 replaceWithResolution(graph, stateMapper, node, classInfo);
             }
         } else {
             throw new GraalError("Unsupported metaspace constant type: " + type);
         }
     }
 
+    /**
+     * Replace {@link ConstantNode} containing a {@link HotSpotResolvedJavaType} with a load. This
+     * variant handles only constants that don't require resolution.
+     *
+     * @param graph
+     * @param node {@link ConstantNode} containing a {@link HotSpotResolvedJavaType} that needs
+     *            resolution.
+     */
+    private static void handleHotSpotMetaspaceConstantWithoutResolution(StructuredGraph graph, ConstantNode node, ClassInfo classInfo) {
+        HotSpotMetaspaceConstant metaspaceConstant = (HotSpotMetaspaceConstant) node.asConstant();
+        HotSpotResolvedJavaType type = (HotSpotResolvedJavaType) metaspaceConstant.asResolvedJavaType();
+        if (type != null) {
+            replaceWithLoad(graph, node, classInfo);
+        } else {
+            throw new GraalError("Unsupported metaspace constant type: " + type);
+        }
+    }
+
     /**
      * Replace an object constant with an indirect load {@link ResolveConstantNode}. Currently we
      * support only strings.
      *
      * @param graph
@@ -480,46 +535,68 @@
     /**
      * Replace object and klass constants with resolution nodes or reuse preceding initializations.
      *
      * @param graph
      * @param stateMapper
+     * @param classInfo
      */
     private void replaceKlassesAndObjects(StructuredGraph graph, FrameStateMapperClosure stateMapper, ClassInfo classInfo) {
         new SchedulePhase(SchedulingStrategy.LATEST_OUT_OF_LOOPS, true).apply(graph, false);
 
         for (ConstantNode node : getConstantNodes(graph)) {
             Constant constant = node.asConstant();
             if (constant instanceof HotSpotMetaspaceConstant && anyUsagesNeedReplacement(node)) {
+                verifyFingerprint(node);
                 handleHotSpotMetaspaceConstant(graph, stateMapper, node, classInfo);
             } else if (constant instanceof HotSpotObjectConstant && anyUsagesNeedReplacement(node)) {
                 handleHotSpotObjectConstant(graph, stateMapper, node, classInfo);
             }
         }
     }
 
+    /**
+     * Replace well-known klass constants with indirect loads.
+     *
+     * @param graph
+     * @param classInfo
+     */
+    private static void replaceKlassesWithoutResolution(StructuredGraph graph, ClassInfo classInfo) {
+        for (ConstantNode node : getConstantNodes(graph)) {
+            Constant constant = node.asConstant();
+            if (constant instanceof HotSpotMetaspaceConstant && anyUsagesNeedReplacement(node)) {
+                handleHotSpotMetaspaceConstantWithoutResolution(graph, node, classInfo);
+            }
+        }
+    }
+
     @Override
     protected void run(StructuredGraph graph, CoreProviders context) {
-        FrameStateMapperClosure stateMapper = new FrameStateMapperClosure(graph);
-        ReentrantNodeIterator.apply(stateMapper, graph.start(), null);
+        if (allowResolution) {
+            FrameStateMapperClosure stateMapper = new FrameStateMapperClosure(graph);
+            ReentrantNodeIterator.apply(stateMapper, graph.start(), null);
 
-        // Replace LoadMethodCountersNode with ResolveMethodAndLoadCountersNode, expose klass
-        // constants.
-        replaceLoadMethodCounters(graph, stateMapper, context);
+            // Replace LoadMethodCountersNode with ResolveMethodAndLoadCountersNode, expose klass
+            // constants.
+            replaceLoadMethodCounters(graph, stateMapper, context);
 
-        // Replace object and klass constants (including the ones added in the previous pass) with
-        // resolution nodes.
-        replaceKlassesAndObjects(graph, stateMapper, new ClassInfo(context.getMetaAccess()));
+            // Replace object and klass constants (including the ones added in the previous pass)
+            // with resolution nodes.
+            replaceKlassesAndObjects(graph, stateMapper, new ClassInfo(context.getMetaAccess()));
+        } else {
+            replaceKlassesWithoutResolution(graph, new ClassInfo(context.getMetaAccess()));
+        }
     }
 
     @Override
     public boolean checkContract() {
         return false;
     }
 
-    public ReplaceConstantNodesPhase() {
-        this(true);
+    public ReplaceConstantNodesPhase(boolean allowResolution) {
+        this(allowResolution, true);
     }
 
-    public ReplaceConstantNodesPhase(boolean verifyFingerprints) {
+    public ReplaceConstantNodesPhase(boolean allowResolution, boolean verifyFingerprints) {
+        this.allowResolution = allowResolution;
         this.verifyFingerprints = verifyFingerprints;
     }
 }

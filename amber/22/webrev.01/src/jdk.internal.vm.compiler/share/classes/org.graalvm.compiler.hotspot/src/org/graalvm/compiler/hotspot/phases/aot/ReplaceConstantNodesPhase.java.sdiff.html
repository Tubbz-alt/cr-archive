<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/phases/aot/ReplaceConstantNodesPhase.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../meta/HotSpotSuitesProvider.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../../../../../jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/markup/HtmlStyle.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/phases/aot/ReplaceConstantNodesPhase.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot.phases.aot;
 26 
 27 import static org.graalvm.compiler.core.common.cfg.AbstractControlFlowGraph.strictlyDominates;
 28 import static org.graalvm.compiler.hotspot.nodes.aot.LoadMethodCountersNode.getLoadMethodCountersNodes;
 29 import static org.graalvm.compiler.nodes.ConstantNode.getConstantNodes;
 30 

 31 import java.util.HashSet;
 32 import java.util.List;
 33 
 34 import jdk.internal.vm.compiler.collections.EconomicMap;
 35 import jdk.internal.vm.compiler.collections.Equivalence;
 36 import org.graalvm.compiler.core.common.cfg.BlockMap;
 37 import org.graalvm.compiler.core.common.type.ObjectStamp;
 38 import org.graalvm.compiler.core.common.type.Stamp;
 39 import org.graalvm.compiler.core.common.type.StampFactory;
 40 import org.graalvm.compiler.debug.GraalError;
 41 import org.graalvm.compiler.graph.Node;
 42 import org.graalvm.compiler.graph.NodeMap;
 43 import org.graalvm.compiler.hotspot.meta.HotSpotConstantLoadAction;
 44 import org.graalvm.compiler.hotspot.nodes.aot.InitializeKlassNode;
 45 import org.graalvm.compiler.hotspot.nodes.aot.LoadConstantIndirectlyFixedNode;
 46 import org.graalvm.compiler.hotspot.nodes.aot.LoadConstantIndirectlyNode;
 47 import org.graalvm.compiler.hotspot.nodes.aot.LoadMethodCountersNode;
 48 import org.graalvm.compiler.hotspot.nodes.aot.ResolveConstantNode;
 49 import org.graalvm.compiler.hotspot.nodes.aot.ResolveDynamicConstantNode;
 50 import org.graalvm.compiler.hotspot.nodes.aot.ResolveMethodAndLoadCountersNode;
</pre>
<hr />
<pre>
 65 import org.graalvm.compiler.nodes.spi.CoreProviders;
 66 import org.graalvm.compiler.phases.BasePhase;
 67 import org.graalvm.compiler.phases.graph.ReentrantNodeIterator;
 68 import org.graalvm.compiler.phases.graph.ReentrantNodeIterator.NodeIteratorClosure;
 69 import org.graalvm.compiler.phases.schedule.SchedulePhase;
 70 import org.graalvm.compiler.phases.schedule.SchedulePhase.SchedulingStrategy;
 71 
 72 import jdk.vm.ci.code.BytecodeFrame;
 73 import jdk.vm.ci.hotspot.HotSpotMetaspaceConstant;
 74 import jdk.vm.ci.hotspot.HotSpotObjectConstant;
 75 import jdk.vm.ci.hotspot.HotSpotResolvedJavaType;
 76 import jdk.vm.ci.hotspot.HotSpotResolvedObjectType;
 77 import jdk.vm.ci.meta.Constant;
 78 import jdk.vm.ci.meta.ConstantReflectionProvider;
 79 import jdk.vm.ci.meta.MetaAccessProvider;
 80 import jdk.vm.ci.meta.ResolvedJavaType;
 81 
 82 public class ReplaceConstantNodesPhase extends BasePhase&lt;CoreProviders&gt; {
 83 
 84     private final boolean verifyFingerprints;

 85 
 86     static Class&lt;?&gt; characterCacheClass = Character.class.getDeclaredClasses()[0];
 87     static Class&lt;?&gt; byteCacheClass = Byte.class.getDeclaredClasses()[0];
 88     static Class&lt;?&gt; shortCacheClass = Short.class.getDeclaredClasses()[0];
 89     static Class&lt;?&gt; integerCacheClass = Integer.class.getDeclaredClasses()[0];
 90     static Class&lt;?&gt; longCacheClass = Long.class.getDeclaredClasses()[0];
 91 
 92     static class ClassInfo {
 93 
 94         private ResolvedJavaType stringType;

 95         private final HashSet&lt;ResolvedJavaType&gt; builtIns = new HashSet&lt;&gt;();
 96 
 97         ClassInfo(MetaAccessProvider metaAccessProvider) {
 98             builtIns.add(metaAccessProvider.lookupJavaType(Boolean.class));
 99 
100             assert &quot;java.lang.Character$CharacterCache&quot;.equals(characterCacheClass.getName());
101             builtIns.add(metaAccessProvider.lookupJavaType(characterCacheClass));
102 
103             assert &quot;java.lang.Byte$ByteCache&quot;.equals(byteCacheClass.getName());
104             builtIns.add(metaAccessProvider.lookupJavaType(byteCacheClass));
105 
106             assert &quot;java.lang.Short$ShortCache&quot;.equals(shortCacheClass.getName());
107             builtIns.add(metaAccessProvider.lookupJavaType(shortCacheClass));
108 
109             assert &quot;java.lang.Integer$IntegerCache&quot;.equals(integerCacheClass.getName());
110             builtIns.add(metaAccessProvider.lookupJavaType(integerCacheClass));
111 
112             assert &quot;java.lang.Long$LongCache&quot;.equals(longCacheClass.getName());
113             builtIns.add(metaAccessProvider.lookupJavaType(longCacheClass));
114 
115             stringType = metaAccessProvider.lookupJavaType(String.class);

116         }
117     }
118 
119     private static boolean isReplacementNode(Node n) {
120         // @formatter:off
121         return n instanceof LoadConstantIndirectlyNode      ||
122                 n instanceof LoadConstantIndirectlyFixedNode ||
123                 n instanceof ResolveDynamicConstantNode      ||
124                 n instanceof ResolveConstantNode             ||
125                 n instanceof InitializeKlassNode;
126         // @formatter:on
127     }
128 
129     private static boolean anyUsagesNeedReplacement(ConstantNode node) {
130         return node.usages().filter(n -&gt; !isReplacementNode(n)).isNotEmpty();
131     }
132 
133     private static boolean anyUsagesNeedReplacement(LoadMethodCountersNode node) {
134         return node.usages().filter(n -&gt; !(n instanceof ResolveMethodAndLoadCountersNode)).isNotEmpty();
135     }
</pre>
<hr />
<pre>
296 
297         FrameStateMapperClosure(StructuredGraph graph) {
298             reachingStates = new NodeMap&lt;&gt;(graph);
299         }
300 
301         public FrameState getState(Node n) {
302             return reachingStates.get(n);
303         }
304 
305         public void addState(Node n, FrameState s) {
306             reachingStates.setAndGrow(n, s);
307         }
308     }
309 
310     /**
311      * Try to find dominating node doing the resolution that can be reused.
312      *
313      * @param graph
314      * @param node {@link ConstantNode} containing a {@link HotSpotResolvedJavaType} that needs
315      *            resolution.

316      */
<span class="line-modified">317     private static void tryToReplaceWithExisting(StructuredGraph graph, ConstantNode node) {</span>

318         ScheduleResult schedule = graph.getLastSchedule();
319         NodeMap&lt;Block&gt; nodeToBlock = schedule.getNodeToBlockMap();
320         BlockMap&lt;List&lt;Node&gt;&gt; blockToNodes = schedule.getBlockToNodesMap();
321 
322         EconomicMap&lt;Block, Node&gt; blockToExisting = EconomicMap.create(Equivalence.IDENTITY);
323         for (Node n : node.usages().filter(n -&gt; isReplacementNode(n))) {
324             blockToExisting.put(nodeToBlock.get(n), n);
325         }
326         for (Node use : node.usages().filter(n -&gt; !isReplacementNode(n)).snapshot()) {
327             boolean replaced = false;
328             Block b = nodeToBlock.get(use);
329             Node e = blockToExisting.get(b);
330             if (e != null) {
331                 // There is an initialization or resolution in the same block as the use, look if
332                 // the use is scheduled after it.
333                 for (Node n : blockToNodes.get(b)) {
334                     if (n.equals(use)) {
335                         // Usage is before initialization, can&#39;t use it
336                         break;
337                     }
338                     if (n.equals(e)) {
339                         use.replaceFirstInput(node, e);
340                         replaced = true;
341                         break;
342                     }
343                 }
344             }
345             if (!replaced) {
346                 // Look for dominating blocks that have existing nodes
347                 for (Block d : blockToExisting.getKeys()) {
348                     if (strictlyDominates(d, b)) {
349                         use.replaceFirstInput(node, blockToExisting.get(d));

350                         break;
351                     }
352                 }
353             }



354         }

355     }
356 
357     /**
<span class="line-modified">358      * Replace the uses of a constant with either {@link LoadConstantIndirectlyNode} or</span>
<span class="line-removed">359      * {@link ResolveConstantNode}.</span>
360      *
361      * @param graph
362      * @param stateMapper
363      * @param node {@link ConstantNode} containing a {@link HotSpotResolvedJavaType} that needs
364      *            resolution.
365      */
366     private static void replaceWithResolution(StructuredGraph graph, FrameStateMapperClosure stateMapper, ConstantNode node, ClassInfo classInfo) {
367         HotSpotMetaspaceConstant metaspaceConstant = (HotSpotMetaspaceConstant) node.asConstant();
368         HotSpotResolvedJavaType type = (HotSpotResolvedJavaType) metaspaceConstant.asResolvedJavaType();
<span class="line-removed">369         ResolvedJavaType topMethodHolder = graph.method().getDeclaringClass();</span>
<span class="line-removed">370         ValueNode replacement;</span>
371 
<span class="line-modified">372         if (type.isArray() &amp;&amp; type.getComponentType().isPrimitive()) {</span>
<span class="line-modified">373             // Special case for primitive arrays. The AOT runtime pre-resolves them, so we may</span>
<span class="line-modified">374             // omit the resolution call.</span>
























375             replacement = graph.addOrUnique(new LoadConstantIndirectlyNode(node));
376         } else if (type.equals(topMethodHolder) || (type.isAssignableFrom(topMethodHolder) &amp;&amp; !type.isInterface())) {
377             // If it&#39;s a supertype of or the same class that declares the top method, we are
378             // guaranteed to have it resolved already. If it&#39;s an interface, we just test for
379             // equality.
380             replacement = graph.addOrUnique(new LoadConstantIndirectlyNode(node));
<span class="line-modified">381         } else {</span>
<span class="line-modified">382             FixedWithNextNode fixedReplacement;</span>
<span class="line-modified">383             if (classInfo.builtIns.contains(type)) {</span>
<span class="line-modified">384                 // Special case of klass constants that come from {@link BoxingSnippets}.</span>
<span class="line-modified">385                 fixedReplacement = graph.add(new ResolveConstantNode(node, HotSpotConstantLoadAction.INITIALIZE));</span>
<span class="line-modified">386             } else {</span>
<span class="line-modified">387                 fixedReplacement = graph.add(new ResolveConstantNode(node));</span>














388             }
<span class="line-removed">389             insertReplacement(graph, stateMapper, node, fixedReplacement);</span>
<span class="line-removed">390             replacement = fixedReplacement;</span>
391         }
<span class="line-removed">392         node.replaceAtUsages(replacement, n -&gt; !isReplacementNode(n));</span>
393     }
394 
395     /**
396      * Replace {@link ConstantNode} containing a {@link HotSpotResolvedJavaType} with indirection.
397      *
398      * @param graph
399      * @param stateMapper
400      * @param node {@link ConstantNode} containing a {@link HotSpotResolvedJavaType} that needs
401      *            resolution.
402      */
<span class="line-modified">403     private void handleHotSpotMetaspaceConstant(StructuredGraph graph, FrameStateMapperClosure stateMapper, ConstantNode node, ClassInfo classInfo) {</span>
404         HotSpotMetaspaceConstant metaspaceConstant = (HotSpotMetaspaceConstant) node.asConstant();
405         HotSpotResolvedJavaType type = (HotSpotResolvedJavaType) metaspaceConstant.asResolvedJavaType();
<span class="line-removed">406 </span>
407         if (type != null) {
<span class="line-modified">408             if (verifyFingerprints &amp;&amp; checkForBadFingerprint(type)) {</span>
<span class="line-removed">409                 throw new GraalError(&quot;Type with bad fingerprint: &quot; + type);</span>
<span class="line-removed">410             }</span>
<span class="line-removed">411             assert !metaspaceConstant.isCompressed() : &quot;No support for replacing compressed metaspace constants&quot;;</span>
<span class="line-removed">412             tryToReplaceWithExisting(graph, node);</span>
<span class="line-removed">413             if (anyUsagesNeedReplacement(node)) {</span>
414                 replaceWithResolution(graph, stateMapper, node, classInfo);
415             }
416         } else {
417             throw new GraalError(&quot;Unsupported metaspace constant type: &quot; + type);
418         }
419     }
420 


















421     /**
422      * Replace an object constant with an indirect load {@link ResolveConstantNode}. Currently we
423      * support only strings.
424      *
425      * @param graph
426      * @param stateMapper
427      * @param node {@link ConstantNode} containing a {@link HotSpotObjectConstant} that needs
428      *            resolution.
429      */
430     private static void handleHotSpotObjectConstant(StructuredGraph graph, FrameStateMapperClosure stateMapper, ConstantNode node, ClassInfo classInfo) {
431         HotSpotObjectConstant constant = (HotSpotObjectConstant) node.asJavaConstant();
432         HotSpotResolvedJavaType type = (HotSpotResolvedJavaType) constant.getType();
433         if (type.equals(classInfo.stringType)) {
434             assert !constant.isCompressed() : &quot;No support for replacing compressed oop constants&quot;;
435             FixedWithNextNode replacement = graph.add(new ResolveConstantNode(node));
436             insertReplacement(graph, stateMapper, node, replacement);
437             node.replaceAtUsages(replacement, n -&gt; !(n instanceof ResolveConstantNode));
438         } else {
439             throw new GraalError(&quot;Unsupported object constant type: &quot; + type);
440         }
</pre>
<hr />
<pre>
465      *
466      * @param graph
467      * @param stateMapper
468      * @param context
469      */
470     private static void replaceLoadMethodCounters(StructuredGraph graph, FrameStateMapperClosure stateMapper, CoreProviders context) {
471         new SchedulePhase(SchedulingStrategy.LATEST_OUT_OF_LOOPS, true).apply(graph, false);
472 
473         for (LoadMethodCountersNode node : getLoadMethodCountersNodes(graph)) {
474             if (anyUsagesNeedReplacement(node)) {
475                 handleLoadMethodCounters(graph, stateMapper, node, context);
476             }
477         }
478     }
479 
480     /**
481      * Replace object and klass constants with resolution nodes or reuse preceding initializations.
482      *
483      * @param graph
484      * @param stateMapper

485      */
486     private void replaceKlassesAndObjects(StructuredGraph graph, FrameStateMapperClosure stateMapper, ClassInfo classInfo) {
487         new SchedulePhase(SchedulingStrategy.LATEST_OUT_OF_LOOPS, true).apply(graph, false);
488 
489         for (ConstantNode node : getConstantNodes(graph)) {
490             Constant constant = node.asConstant();
491             if (constant instanceof HotSpotMetaspaceConstant &amp;&amp; anyUsagesNeedReplacement(node)) {

492                 handleHotSpotMetaspaceConstant(graph, stateMapper, node, classInfo);
493             } else if (constant instanceof HotSpotObjectConstant &amp;&amp; anyUsagesNeedReplacement(node)) {
494                 handleHotSpotObjectConstant(graph, stateMapper, node, classInfo);
495             }
496         }
497     }
498 















499     @Override
500     protected void run(StructuredGraph graph, CoreProviders context) {
<span class="line-modified">501         FrameStateMapperClosure stateMapper = new FrameStateMapperClosure(graph);</span>
<span class="line-modified">502         ReentrantNodeIterator.apply(stateMapper, graph.start(), null);</span>

503 
<span class="line-modified">504         // Replace LoadMethodCountersNode with ResolveMethodAndLoadCountersNode, expose klass</span>
<span class="line-modified">505         // constants.</span>
<span class="line-modified">506         replaceLoadMethodCounters(graph, stateMapper, context);</span>
507 
<span class="line-modified">508         // Replace object and klass constants (including the ones added in the previous pass) with</span>
<span class="line-modified">509         // resolution nodes.</span>
<span class="line-modified">510         replaceKlassesAndObjects(graph, stateMapper, new ClassInfo(context.getMetaAccess()));</span>



511     }
512 
513     @Override
514     public boolean checkContract() {
515         return false;
516     }
517 
<span class="line-modified">518     public ReplaceConstantNodesPhase() {</span>
<span class="line-modified">519         this(true);</span>
520     }
521 
<span class="line-modified">522     public ReplaceConstantNodesPhase(boolean verifyFingerprints) {</span>

523         this.verifyFingerprints = verifyFingerprints;
524     }
525 }
</pre>
</td>
<td>
<hr />
<pre>
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot.phases.aot;
 26 
 27 import static org.graalvm.compiler.core.common.cfg.AbstractControlFlowGraph.strictlyDominates;
 28 import static org.graalvm.compiler.hotspot.nodes.aot.LoadMethodCountersNode.getLoadMethodCountersNodes;
 29 import static org.graalvm.compiler.nodes.ConstantNode.getConstantNodes;
 30 
<span class="line-added"> 31 import java.lang.ref.Reference;</span>
 32 import java.util.HashSet;
 33 import java.util.List;
 34 
 35 import jdk.internal.vm.compiler.collections.EconomicMap;
 36 import jdk.internal.vm.compiler.collections.Equivalence;
 37 import org.graalvm.compiler.core.common.cfg.BlockMap;
 38 import org.graalvm.compiler.core.common.type.ObjectStamp;
 39 import org.graalvm.compiler.core.common.type.Stamp;
 40 import org.graalvm.compiler.core.common.type.StampFactory;
 41 import org.graalvm.compiler.debug.GraalError;
 42 import org.graalvm.compiler.graph.Node;
 43 import org.graalvm.compiler.graph.NodeMap;
 44 import org.graalvm.compiler.hotspot.meta.HotSpotConstantLoadAction;
 45 import org.graalvm.compiler.hotspot.nodes.aot.InitializeKlassNode;
 46 import org.graalvm.compiler.hotspot.nodes.aot.LoadConstantIndirectlyFixedNode;
 47 import org.graalvm.compiler.hotspot.nodes.aot.LoadConstantIndirectlyNode;
 48 import org.graalvm.compiler.hotspot.nodes.aot.LoadMethodCountersNode;
 49 import org.graalvm.compiler.hotspot.nodes.aot.ResolveConstantNode;
 50 import org.graalvm.compiler.hotspot.nodes.aot.ResolveDynamicConstantNode;
 51 import org.graalvm.compiler.hotspot.nodes.aot.ResolveMethodAndLoadCountersNode;
</pre>
<hr />
<pre>
 66 import org.graalvm.compiler.nodes.spi.CoreProviders;
 67 import org.graalvm.compiler.phases.BasePhase;
 68 import org.graalvm.compiler.phases.graph.ReentrantNodeIterator;
 69 import org.graalvm.compiler.phases.graph.ReentrantNodeIterator.NodeIteratorClosure;
 70 import org.graalvm.compiler.phases.schedule.SchedulePhase;
 71 import org.graalvm.compiler.phases.schedule.SchedulePhase.SchedulingStrategy;
 72 
 73 import jdk.vm.ci.code.BytecodeFrame;
 74 import jdk.vm.ci.hotspot.HotSpotMetaspaceConstant;
 75 import jdk.vm.ci.hotspot.HotSpotObjectConstant;
 76 import jdk.vm.ci.hotspot.HotSpotResolvedJavaType;
 77 import jdk.vm.ci.hotspot.HotSpotResolvedObjectType;
 78 import jdk.vm.ci.meta.Constant;
 79 import jdk.vm.ci.meta.ConstantReflectionProvider;
 80 import jdk.vm.ci.meta.MetaAccessProvider;
 81 import jdk.vm.ci.meta.ResolvedJavaType;
 82 
 83 public class ReplaceConstantNodesPhase extends BasePhase&lt;CoreProviders&gt; {
 84 
 85     private final boolean verifyFingerprints;
<span class="line-added"> 86     private final boolean allowResolution;</span>
 87 
 88     static Class&lt;?&gt; characterCacheClass = Character.class.getDeclaredClasses()[0];
 89     static Class&lt;?&gt; byteCacheClass = Byte.class.getDeclaredClasses()[0];
 90     static Class&lt;?&gt; shortCacheClass = Short.class.getDeclaredClasses()[0];
 91     static Class&lt;?&gt; integerCacheClass = Integer.class.getDeclaredClasses()[0];
 92     static Class&lt;?&gt; longCacheClass = Long.class.getDeclaredClasses()[0];
 93 
 94     static class ClassInfo {
 95 
 96         private ResolvedJavaType stringType;
<span class="line-added"> 97         private ResolvedJavaType referenceType;</span>
 98         private final HashSet&lt;ResolvedJavaType&gt; builtIns = new HashSet&lt;&gt;();
 99 
100         ClassInfo(MetaAccessProvider metaAccessProvider) {
101             builtIns.add(metaAccessProvider.lookupJavaType(Boolean.class));
102 
103             assert &quot;java.lang.Character$CharacterCache&quot;.equals(characterCacheClass.getName());
104             builtIns.add(metaAccessProvider.lookupJavaType(characterCacheClass));
105 
106             assert &quot;java.lang.Byte$ByteCache&quot;.equals(byteCacheClass.getName());
107             builtIns.add(metaAccessProvider.lookupJavaType(byteCacheClass));
108 
109             assert &quot;java.lang.Short$ShortCache&quot;.equals(shortCacheClass.getName());
110             builtIns.add(metaAccessProvider.lookupJavaType(shortCacheClass));
111 
112             assert &quot;java.lang.Integer$IntegerCache&quot;.equals(integerCacheClass.getName());
113             builtIns.add(metaAccessProvider.lookupJavaType(integerCacheClass));
114 
115             assert &quot;java.lang.Long$LongCache&quot;.equals(longCacheClass.getName());
116             builtIns.add(metaAccessProvider.lookupJavaType(longCacheClass));
117 
118             stringType = metaAccessProvider.lookupJavaType(String.class);
<span class="line-added">119             referenceType = metaAccessProvider.lookupJavaType(Reference.class);</span>
120         }
121     }
122 
123     private static boolean isReplacementNode(Node n) {
124         // @formatter:off
125         return n instanceof LoadConstantIndirectlyNode      ||
126                 n instanceof LoadConstantIndirectlyFixedNode ||
127                 n instanceof ResolveDynamicConstantNode      ||
128                 n instanceof ResolveConstantNode             ||
129                 n instanceof InitializeKlassNode;
130         // @formatter:on
131     }
132 
133     private static boolean anyUsagesNeedReplacement(ConstantNode node) {
134         return node.usages().filter(n -&gt; !isReplacementNode(n)).isNotEmpty();
135     }
136 
137     private static boolean anyUsagesNeedReplacement(LoadMethodCountersNode node) {
138         return node.usages().filter(n -&gt; !(n instanceof ResolveMethodAndLoadCountersNode)).isNotEmpty();
139     }
</pre>
<hr />
<pre>
300 
301         FrameStateMapperClosure(StructuredGraph graph) {
302             reachingStates = new NodeMap&lt;&gt;(graph);
303         }
304 
305         public FrameState getState(Node n) {
306             return reachingStates.get(n);
307         }
308 
309         public void addState(Node n, FrameState s) {
310             reachingStates.setAndGrow(n, s);
311         }
312     }
313 
314     /**
315      * Try to find dominating node doing the resolution that can be reused.
316      *
317      * @param graph
318      * @param node {@link ConstantNode} containing a {@link HotSpotResolvedJavaType} that needs
319      *            resolution.
<span class="line-added">320      * @return return true if all usages of the node have been replaced</span>
321      */
<span class="line-modified">322     private static boolean tryToReplaceWithExisting(StructuredGraph graph, ConstantNode node) {</span>
<span class="line-added">323         boolean allUsagesReplaced = true;</span>
324         ScheduleResult schedule = graph.getLastSchedule();
325         NodeMap&lt;Block&gt; nodeToBlock = schedule.getNodeToBlockMap();
326         BlockMap&lt;List&lt;Node&gt;&gt; blockToNodes = schedule.getBlockToNodesMap();
327 
328         EconomicMap&lt;Block, Node&gt; blockToExisting = EconomicMap.create(Equivalence.IDENTITY);
329         for (Node n : node.usages().filter(n -&gt; isReplacementNode(n))) {
330             blockToExisting.put(nodeToBlock.get(n), n);
331         }
332         for (Node use : node.usages().filter(n -&gt; !isReplacementNode(n)).snapshot()) {
333             boolean replaced = false;
334             Block b = nodeToBlock.get(use);
335             Node e = blockToExisting.get(b);
336             if (e != null) {
337                 // There is an initialization or resolution in the same block as the use, look if
338                 // the use is scheduled after it.
339                 for (Node n : blockToNodes.get(b)) {
340                     if (n.equals(use)) {
341                         // Usage is before initialization, can&#39;t use it
342                         break;
343                     }
344                     if (n.equals(e)) {
345                         use.replaceFirstInput(node, e);
346                         replaced = true;
347                         break;
348                     }
349                 }
350             }
351             if (!replaced) {
352                 // Look for dominating blocks that have existing nodes
353                 for (Block d : blockToExisting.getKeys()) {
354                     if (strictlyDominates(d, b)) {
355                         use.replaceFirstInput(node, blockToExisting.get(d));
<span class="line-added">356                         replaced = true;</span>
357                         break;
358                     }
359                 }
360             }
<span class="line-added">361             if (!replaced &amp;&amp; allUsagesReplaced) {</span>
<span class="line-added">362                 allUsagesReplaced = false;</span>
<span class="line-added">363             }</span>
364         }
<span class="line-added">365         return allUsagesReplaced;</span>
366     }
367 
368     /**
<span class="line-modified">369      * Replace the uses of a constant with {@link ResolveConstantNode}.</span>

370      *
371      * @param graph
372      * @param stateMapper
373      * @param node {@link ConstantNode} containing a {@link HotSpotResolvedJavaType} that needs
374      *            resolution.
375      */
376     private static void replaceWithResolution(StructuredGraph graph, FrameStateMapperClosure stateMapper, ConstantNode node, ClassInfo classInfo) {
377         HotSpotMetaspaceConstant metaspaceConstant = (HotSpotMetaspaceConstant) node.asConstant();
378         HotSpotResolvedJavaType type = (HotSpotResolvedJavaType) metaspaceConstant.asResolvedJavaType();


379 
<span class="line-modified">380         FixedWithNextNode fixedReplacement;</span>
<span class="line-modified">381         if (classInfo.builtIns.contains(type)) {</span>
<span class="line-modified">382             // Special case of klass constants that come from {@link BoxingSnippets}.</span>
<span class="line-added">383             fixedReplacement = graph.add(new ResolveConstantNode(node, HotSpotConstantLoadAction.INITIALIZE));</span>
<span class="line-added">384         } else {</span>
<span class="line-added">385             fixedReplacement = graph.add(new ResolveConstantNode(node));</span>
<span class="line-added">386         }</span>
<span class="line-added">387         insertReplacement(graph, stateMapper, node, fixedReplacement);</span>
<span class="line-added">388         node.replaceAtUsages(fixedReplacement, n -&gt; !isReplacementNode(n));</span>
<span class="line-added">389     }</span>
<span class="line-added">390 </span>
<span class="line-added">391     /**</span>
<span class="line-added">392      * Replace the uses of a constant with either {@link LoadConstantIndirectlyNode} if possible.</span>
<span class="line-added">393      *</span>
<span class="line-added">394      * @param graph</span>
<span class="line-added">395      * @param node {@link ConstantNode} containing a {@link HotSpotResolvedJavaType} that needs</span>
<span class="line-added">396      *            resolution.</span>
<span class="line-added">397      * @return return true if all usages of the node have been replaced</span>
<span class="line-added">398      */</span>
<span class="line-added">399     private static boolean replaceWithLoad(StructuredGraph graph, ConstantNode node, ClassInfo classInfo) {</span>
<span class="line-added">400         HotSpotMetaspaceConstant metaspaceConstant = (HotSpotMetaspaceConstant) node.asConstant();</span>
<span class="line-added">401         HotSpotResolvedJavaType type = (HotSpotResolvedJavaType) metaspaceConstant.asResolvedJavaType();</span>
<span class="line-added">402         ResolvedJavaType topMethodHolder = graph.method().getDeclaringClass();</span>
<span class="line-added">403         ValueNode replacement = null;</span>
<span class="line-added">404         if ((type.isArray() &amp;&amp; type.getComponentType().isPrimitive()) || type.equals(classInfo.referenceType)) {</span>
<span class="line-added">405             // Special case for primitive arrays and j.l.ref.Reference.</span>
<span class="line-added">406             // The AOT runtime pre-resolves them, so we may omit the resolution call.</span>
407             replacement = graph.addOrUnique(new LoadConstantIndirectlyNode(node));
408         } else if (type.equals(topMethodHolder) || (type.isAssignableFrom(topMethodHolder) &amp;&amp; !type.isInterface())) {
409             // If it&#39;s a supertype of or the same class that declares the top method, we are
410             // guaranteed to have it resolved already. If it&#39;s an interface, we just test for
411             // equality.
412             replacement = graph.addOrUnique(new LoadConstantIndirectlyNode(node));
<span class="line-modified">413         }</span>
<span class="line-modified">414         if (replacement != null) {</span>
<span class="line-modified">415             node.replaceAtUsages(replacement, n -&gt; !isReplacementNode(n));</span>
<span class="line-modified">416             return true;</span>
<span class="line-modified">417         }</span>
<span class="line-modified">418         return false;</span>
<span class="line-modified">419     }</span>
<span class="line-added">420 </span>
<span class="line-added">421     /**</span>
<span class="line-added">422      * Verify that {@link ConstantNode} containing a {@link HotSpotResolvedJavaType} has a valid</span>
<span class="line-added">423      * fingerprint.</span>
<span class="line-added">424      *</span>
<span class="line-added">425      * @param node {@link ConstantNode} containing a {@link HotSpotResolvedJavaType}.</span>
<span class="line-added">426      */</span>
<span class="line-added">427     private void verifyFingerprint(ConstantNode node) {</span>
<span class="line-added">428         HotSpotMetaspaceConstant metaspaceConstant = (HotSpotMetaspaceConstant) node.asConstant();</span>
<span class="line-added">429         HotSpotResolvedJavaType type = (HotSpotResolvedJavaType) metaspaceConstant.asResolvedJavaType();</span>
<span class="line-added">430         if (type != null) {</span>
<span class="line-added">431             assert !metaspaceConstant.isCompressed() : &quot;No support for replacing compressed metaspace constants&quot;;</span>
<span class="line-added">432             if (verifyFingerprints &amp;&amp; checkForBadFingerprint(type)) {</span>
<span class="line-added">433                 throw new GraalError(&quot;Type with bad fingerprint: &quot; + type);</span>
434             }


435         }

436     }
437 
438     /**
439      * Replace {@link ConstantNode} containing a {@link HotSpotResolvedJavaType} with indirection.
440      *
441      * @param graph
442      * @param stateMapper
443      * @param node {@link ConstantNode} containing a {@link HotSpotResolvedJavaType} that needs
444      *            resolution.
445      */
<span class="line-modified">446     private static void handleHotSpotMetaspaceConstant(StructuredGraph graph, FrameStateMapperClosure stateMapper, ConstantNode node, ClassInfo classInfo) {</span>
447         HotSpotMetaspaceConstant metaspaceConstant = (HotSpotMetaspaceConstant) node.asConstant();
448         HotSpotResolvedJavaType type = (HotSpotResolvedJavaType) metaspaceConstant.asResolvedJavaType();

449         if (type != null) {
<span class="line-modified">450             if (!tryToReplaceWithExisting(graph, node) &amp;&amp; !replaceWithLoad(graph, node, classInfo)) {</span>





451                 replaceWithResolution(graph, stateMapper, node, classInfo);
452             }
453         } else {
454             throw new GraalError(&quot;Unsupported metaspace constant type: &quot; + type);
455         }
456     }
457 
<span class="line-added">458     /**</span>
<span class="line-added">459      * Replace {@link ConstantNode} containing a {@link HotSpotResolvedJavaType} with a load. This</span>
<span class="line-added">460      * variant handles only constants that don&#39;t require resolution.</span>
<span class="line-added">461      *</span>
<span class="line-added">462      * @param graph</span>
<span class="line-added">463      * @param node {@link ConstantNode} containing a {@link HotSpotResolvedJavaType} that needs</span>
<span class="line-added">464      *            resolution.</span>
<span class="line-added">465      */</span>
<span class="line-added">466     private static void handleHotSpotMetaspaceConstantWithoutResolution(StructuredGraph graph, ConstantNode node, ClassInfo classInfo) {</span>
<span class="line-added">467         HotSpotMetaspaceConstant metaspaceConstant = (HotSpotMetaspaceConstant) node.asConstant();</span>
<span class="line-added">468         HotSpotResolvedJavaType type = (HotSpotResolvedJavaType) metaspaceConstant.asResolvedJavaType();</span>
<span class="line-added">469         if (type != null) {</span>
<span class="line-added">470             replaceWithLoad(graph, node, classInfo);</span>
<span class="line-added">471         } else {</span>
<span class="line-added">472             throw new GraalError(&quot;Unsupported metaspace constant type: &quot; + type);</span>
<span class="line-added">473         }</span>
<span class="line-added">474     }</span>
<span class="line-added">475 </span>
476     /**
477      * Replace an object constant with an indirect load {@link ResolveConstantNode}. Currently we
478      * support only strings.
479      *
480      * @param graph
481      * @param stateMapper
482      * @param node {@link ConstantNode} containing a {@link HotSpotObjectConstant} that needs
483      *            resolution.
484      */
485     private static void handleHotSpotObjectConstant(StructuredGraph graph, FrameStateMapperClosure stateMapper, ConstantNode node, ClassInfo classInfo) {
486         HotSpotObjectConstant constant = (HotSpotObjectConstant) node.asJavaConstant();
487         HotSpotResolvedJavaType type = (HotSpotResolvedJavaType) constant.getType();
488         if (type.equals(classInfo.stringType)) {
489             assert !constant.isCompressed() : &quot;No support for replacing compressed oop constants&quot;;
490             FixedWithNextNode replacement = graph.add(new ResolveConstantNode(node));
491             insertReplacement(graph, stateMapper, node, replacement);
492             node.replaceAtUsages(replacement, n -&gt; !(n instanceof ResolveConstantNode));
493         } else {
494             throw new GraalError(&quot;Unsupported object constant type: &quot; + type);
495         }
</pre>
<hr />
<pre>
520      *
521      * @param graph
522      * @param stateMapper
523      * @param context
524      */
525     private static void replaceLoadMethodCounters(StructuredGraph graph, FrameStateMapperClosure stateMapper, CoreProviders context) {
526         new SchedulePhase(SchedulingStrategy.LATEST_OUT_OF_LOOPS, true).apply(graph, false);
527 
528         for (LoadMethodCountersNode node : getLoadMethodCountersNodes(graph)) {
529             if (anyUsagesNeedReplacement(node)) {
530                 handleLoadMethodCounters(graph, stateMapper, node, context);
531             }
532         }
533     }
534 
535     /**
536      * Replace object and klass constants with resolution nodes or reuse preceding initializations.
537      *
538      * @param graph
539      * @param stateMapper
<span class="line-added">540      * @param classInfo</span>
541      */
542     private void replaceKlassesAndObjects(StructuredGraph graph, FrameStateMapperClosure stateMapper, ClassInfo classInfo) {
543         new SchedulePhase(SchedulingStrategy.LATEST_OUT_OF_LOOPS, true).apply(graph, false);
544 
545         for (ConstantNode node : getConstantNodes(graph)) {
546             Constant constant = node.asConstant();
547             if (constant instanceof HotSpotMetaspaceConstant &amp;&amp; anyUsagesNeedReplacement(node)) {
<span class="line-added">548                 verifyFingerprint(node);</span>
549                 handleHotSpotMetaspaceConstant(graph, stateMapper, node, classInfo);
550             } else if (constant instanceof HotSpotObjectConstant &amp;&amp; anyUsagesNeedReplacement(node)) {
551                 handleHotSpotObjectConstant(graph, stateMapper, node, classInfo);
552             }
553         }
554     }
555 
<span class="line-added">556     /**</span>
<span class="line-added">557      * Replace well-known klass constants with indirect loads.</span>
<span class="line-added">558      *</span>
<span class="line-added">559      * @param graph</span>
<span class="line-added">560      * @param classInfo</span>
<span class="line-added">561      */</span>
<span class="line-added">562     private static void replaceKlassesWithoutResolution(StructuredGraph graph, ClassInfo classInfo) {</span>
<span class="line-added">563         for (ConstantNode node : getConstantNodes(graph)) {</span>
<span class="line-added">564             Constant constant = node.asConstant();</span>
<span class="line-added">565             if (constant instanceof HotSpotMetaspaceConstant &amp;&amp; anyUsagesNeedReplacement(node)) {</span>
<span class="line-added">566                 handleHotSpotMetaspaceConstantWithoutResolution(graph, node, classInfo);</span>
<span class="line-added">567             }</span>
<span class="line-added">568         }</span>
<span class="line-added">569     }</span>
<span class="line-added">570 </span>
571     @Override
572     protected void run(StructuredGraph graph, CoreProviders context) {
<span class="line-modified">573         if (allowResolution) {</span>
<span class="line-modified">574             FrameStateMapperClosure stateMapper = new FrameStateMapperClosure(graph);</span>
<span class="line-added">575             ReentrantNodeIterator.apply(stateMapper, graph.start(), null);</span>
576 
<span class="line-modified">577             // Replace LoadMethodCountersNode with ResolveMethodAndLoadCountersNode, expose klass</span>
<span class="line-modified">578             // constants.</span>
<span class="line-modified">579             replaceLoadMethodCounters(graph, stateMapper, context);</span>
580 
<span class="line-modified">581             // Replace object and klass constants (including the ones added in the previous pass)</span>
<span class="line-modified">582             // with resolution nodes.</span>
<span class="line-modified">583             replaceKlassesAndObjects(graph, stateMapper, new ClassInfo(context.getMetaAccess()));</span>
<span class="line-added">584         } else {</span>
<span class="line-added">585             replaceKlassesWithoutResolution(graph, new ClassInfo(context.getMetaAccess()));</span>
<span class="line-added">586         }</span>
587     }
588 
589     @Override
590     public boolean checkContract() {
591         return false;
592     }
593 
<span class="line-modified">594     public ReplaceConstantNodesPhase(boolean allowResolution) {</span>
<span class="line-modified">595         this(allowResolution, true);</span>
596     }
597 
<span class="line-modified">598     public ReplaceConstantNodesPhase(boolean allowResolution, boolean verifyFingerprints) {</span>
<span class="line-added">599         this.allowResolution = allowResolution;</span>
600         this.verifyFingerprints = verifyFingerprints;
601     }
602 }
</pre>
</td>
</tr>
</table>
<center><a href="../../meta/HotSpotSuitesProvider.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../../../../../jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/markup/HtmlStyle.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
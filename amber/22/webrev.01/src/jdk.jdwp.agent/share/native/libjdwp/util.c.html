<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.jdwp.agent/share/native/libjdwp/util.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #include &lt;ctype.h&gt;
  27 
  28 #include &quot;util.h&quot;
  29 #include &quot;utf_util.h&quot;
  30 #include &quot;transport.h&quot;
  31 #include &quot;eventHandler.h&quot;
  32 #include &quot;threadControl.h&quot;
  33 #include &quot;outStream.h&quot;
  34 #include &quot;inStream.h&quot;
  35 #include &quot;invoker.h&quot;
  36 #include &quot;signature.h&quot;
  37 
  38 
  39 /* Global data area */
  40 BackendGlobalData *gdata = NULL;
  41 
  42 /* Forward declarations */
  43 static jboolean isInterface(jclass clazz);
  44 static jboolean isArrayClass(jclass clazz);
  45 static char * getPropertyUTF8(JNIEnv *env, char *propertyName);
  46 
  47 /* Save an object reference for use later (create a NewGlobalRef) */
  48 void
  49 saveGlobalRef(JNIEnv *env, jobject obj, jobject *pobj)
  50 {
  51     jobject newobj;
  52 
  53     if ( pobj == NULL ) {
  54         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;saveGlobalRef pobj&quot;);
  55     }
  56     if ( *pobj != NULL ) {
  57         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;saveGlobalRef *pobj&quot;);
  58     }
  59     if ( env == NULL ) {
  60         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;saveGlobalRef env&quot;);
  61     }
  62     if ( obj == NULL ) {
  63         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;saveGlobalRef obj&quot;);
  64     }
  65     newobj = JNI_FUNC_PTR(env,NewGlobalRef)(env, obj);
  66     if ( newobj == NULL ) {
  67         EXIT_ERROR(AGENT_ERROR_NULL_POINTER,&quot;NewGlobalRef&quot;);
  68     }
  69     *pobj = newobj;
  70 }
  71 
  72 /* Toss a previously saved object reference */
  73 void
  74 tossGlobalRef(JNIEnv *env, jobject *pobj)
  75 {
  76     jobject obj;
  77 
  78     if ( pobj == NULL ) {
  79         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;tossGlobalRef pobj&quot;);
  80     }
  81     obj = *pobj;
  82     if ( env == NULL ) {
  83         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;tossGlobalRef env&quot;);
  84     }
  85     if ( obj == NULL ) {
  86         EXIT_ERROR(AGENT_ERROR_NULL_POINTER,&quot;tossGlobalRef obj&quot;);
  87     }
  88     JNI_FUNC_PTR(env,DeleteGlobalRef)(env, obj);
  89     *pobj = NULL;
  90 }
  91 
  92 jclass
  93 findClass(JNIEnv *env, const char * name)
  94 {
  95     jclass x;
  96 
  97     if ( env == NULL ) {
  98         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;findClass env&quot;);
  99     }
 100     if ( name == NULL || name[0] == 0 ) {
 101         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;findClass name&quot;);
 102     }
 103     x = JNI_FUNC_PTR(env,FindClass)(env, name);
 104     if (x == NULL) {
 105         ERROR_MESSAGE((&quot;JDWP Can&#39;t find class %s&quot;, name));
 106         EXIT_ERROR(AGENT_ERROR_NULL_POINTER,NULL);
 107     }
 108     if ( JNI_FUNC_PTR(env,ExceptionOccurred)(env) ) {
 109         ERROR_MESSAGE((&quot;JDWP Exception occurred finding class %s&quot;, name));
 110         EXIT_ERROR(AGENT_ERROR_NULL_POINTER,NULL);
 111     }
 112     return x;
 113 }
 114 
 115 jmethodID
 116 getMethod(JNIEnv *env, jclass clazz, const char * name, const char *signature)
 117 {
 118     jmethodID method;
 119 
 120     if ( env == NULL ) {
 121         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;getMethod env&quot;);
 122     }
 123     if ( clazz == NULL ) {
 124         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;getMethod clazz&quot;);
 125     }
 126     if ( name == NULL || name[0] == 0 ) {
 127         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;getMethod name&quot;);
 128     }
 129     if ( signature == NULL || signature[0] == 0 ) {
 130         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;getMethod signature&quot;);
 131     }
 132     method = JNI_FUNC_PTR(env,GetMethodID)(env, clazz, name, signature);
 133     if (method == NULL) {
 134         ERROR_MESSAGE((&quot;JDWP Can&#39;t find method %s with signature %s&quot;,
 135                                 name, signature));
 136         EXIT_ERROR(AGENT_ERROR_NULL_POINTER,NULL);
 137     }
 138     if ( JNI_FUNC_PTR(env,ExceptionOccurred)(env) ) {
 139         ERROR_MESSAGE((&quot;JDWP Exception occurred finding method %s with signature %s&quot;,
 140                                 name, signature));
 141         EXIT_ERROR(AGENT_ERROR_NULL_POINTER,NULL);
 142     }
 143     return method;
 144 }
 145 
 146 static jmethodID
 147 getStaticMethod(JNIEnv *env, jclass clazz, const char * name, const char *signature)
 148 {
 149     jmethodID method;
 150 
 151     if ( env == NULL ) {
 152         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;getStaticMethod env&quot;);
 153     }
 154     if ( clazz == NULL ) {
 155         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;getStaticMethod clazz&quot;);
 156     }
 157     if ( name == NULL || name[0] == 0 ) {
 158         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;getStaticMethod name&quot;);
 159     }
 160     if ( signature == NULL || signature[0] == 0 ) {
 161         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;getStaticMethod signature&quot;);
 162     }
 163     method = JNI_FUNC_PTR(env,GetStaticMethodID)(env, clazz, name, signature);
 164     if (method == NULL) {
 165         ERROR_MESSAGE((&quot;JDWP Can&#39;t find method %s with signature %s&quot;,
 166                                 name, signature));
 167         EXIT_ERROR(AGENT_ERROR_NULL_POINTER,NULL);
 168     }
 169     if ( JNI_FUNC_PTR(env,ExceptionOccurred)(env) ) {
 170         ERROR_MESSAGE((&quot;JDWP Exception occurred finding method %s with signature %s&quot;,
 171                                 name, signature));
 172         EXIT_ERROR(AGENT_ERROR_NULL_POINTER,NULL);
 173     }
 174     return method;
 175 }
 176 
 177 
 178 
 179 void
 180 util_initialize(JNIEnv *env)
 181 {
 182     WITH_LOCAL_REFS(env, 6) {
 183 
 184         jvmtiError error;
 185         jclass localClassClass;
 186         jclass localThreadClass;
 187         jclass localThreadGroupClass;
 188         jclass localClassLoaderClass;
 189         jclass localStringClass;
 190         jclass localSystemClass;
 191         jclass localPropertiesClass;
 192         jclass localVMSupportClass;
 193         jobject localAgentProperties;
 194         jmethodID getAgentProperties;
 195         jint groupCount;
 196         jthreadGroup *groups;
 197         jthreadGroup localSystemThreadGroup;
 198 
 199         /* Find some standard classes */
 200 
 201         localClassClass         = findClass(env,&quot;java/lang/Class&quot;);
 202         localThreadClass        = findClass(env,&quot;java/lang/Thread&quot;);
 203         localThreadGroupClass   = findClass(env,&quot;java/lang/ThreadGroup&quot;);
 204         localClassLoaderClass   = findClass(env,&quot;java/lang/ClassLoader&quot;);
 205         localStringClass        = findClass(env,&quot;java/lang/String&quot;);
 206         localSystemClass        = findClass(env,&quot;java/lang/System&quot;);
 207         localPropertiesClass    = findClass(env,&quot;java/util/Properties&quot;);
 208 
 209         /* Save references */
 210 
 211         saveGlobalRef(env, localClassClass,       &amp;(gdata-&gt;classClass));
 212         saveGlobalRef(env, localThreadClass,      &amp;(gdata-&gt;threadClass));
 213         saveGlobalRef(env, localThreadGroupClass, &amp;(gdata-&gt;threadGroupClass));
 214         saveGlobalRef(env, localClassLoaderClass, &amp;(gdata-&gt;classLoaderClass));
 215         saveGlobalRef(env, localStringClass,      &amp;(gdata-&gt;stringClass));
 216         saveGlobalRef(env, localSystemClass,      &amp;(gdata-&gt;systemClass));
 217 
 218         /* Find some standard methods */
 219 
 220         gdata-&gt;threadConstructor =
 221                 getMethod(env, gdata-&gt;threadClass,
 222                     &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/ThreadGroup;Ljava/lang/String;)V&quot;);
 223         gdata-&gt;threadSetDaemon =
 224                 getMethod(env, gdata-&gt;threadClass, &quot;setDaemon&quot;, &quot;(Z)V&quot;);
 225         gdata-&gt;threadResume =
 226                 getMethod(env, gdata-&gt;threadClass, &quot;resume&quot;, &quot;()V&quot;);
 227         gdata-&gt;systemGetProperty =
 228                 getStaticMethod(env, gdata-&gt;systemClass,
 229                     &quot;getProperty&quot;, &quot;(Ljava/lang/String;)Ljava/lang/String;&quot;);
 230         gdata-&gt;setProperty =
 231                 getMethod(env, localPropertiesClass,
 232                     &quot;setProperty&quot;, &quot;(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/Object;&quot;);
 233 
 234         /* Find the system thread group */
 235 
 236         groups = NULL;
 237         groupCount = 0;
 238         error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetTopThreadGroups)
 239                     (gdata-&gt;jvmti, &amp;groupCount, &amp;groups);
 240         if (error != JVMTI_ERROR_NONE ) {
 241             EXIT_ERROR(error, &quot;Can&#39;t get system thread group&quot;);
 242         }
 243         if ( groupCount == 0 ) {
 244             EXIT_ERROR(AGENT_ERROR_NULL_POINTER, &quot;Can&#39;t get system thread group&quot;);
 245         }
 246         localSystemThreadGroup = groups[0];
 247         saveGlobalRef(env, localSystemThreadGroup, &amp;(gdata-&gt;systemThreadGroup));
 248 
 249         /* Get some basic Java property values we will need at some point */
 250         gdata-&gt;property_java_version
 251                         = getPropertyUTF8(env, &quot;java.version&quot;);
 252         gdata-&gt;property_java_vm_name
 253                         = getPropertyUTF8(env, &quot;java.vm.name&quot;);
 254         gdata-&gt;property_java_vm_info
 255                         = getPropertyUTF8(env, &quot;java.vm.info&quot;);
 256         gdata-&gt;property_java_class_path
 257                         = getPropertyUTF8(env, &quot;java.class.path&quot;);
 258         gdata-&gt;property_sun_boot_library_path
 259                         = getPropertyUTF8(env, &quot;sun.boot.library.path&quot;);
 260         gdata-&gt;property_path_separator
 261                         = getPropertyUTF8(env, &quot;path.separator&quot;);
 262         gdata-&gt;property_user_dir
 263                         = getPropertyUTF8(env, &quot;user.dir&quot;);
 264 
 265         /* Get agent properties: invoke VMSupport.getAgentProperties */
 266         localVMSupportClass = JNI_FUNC_PTR(env,FindClass)
 267                                           (env, &quot;jdk/internal/vm/VMSupport&quot;);
 268         if (localVMSupportClass == NULL) {
 269             gdata-&gt;agent_properties = NULL;
 270             if (JNI_FUNC_PTR(env,ExceptionOccurred)(env)) {
 271                 JNI_FUNC_PTR(env,ExceptionClear)(env);
 272             }
 273         } else {
 274             getAgentProperties  =
 275                 getStaticMethod(env, localVMSupportClass,
 276                                 &quot;getAgentProperties&quot;, &quot;()Ljava/util/Properties;&quot;);
 277             localAgentProperties =
 278                 JNI_FUNC_PTR(env,CallStaticObjectMethod)
 279                             (env, localVMSupportClass, getAgentProperties);
 280             saveGlobalRef(env, localAgentProperties, &amp;(gdata-&gt;agent_properties));
 281             if (JNI_FUNC_PTR(env,ExceptionOccurred)(env)) {
 282                 JNI_FUNC_PTR(env,ExceptionClear)(env);
 283                 EXIT_ERROR(AGENT_ERROR_INTERNAL,
 284                     &quot;Exception occurred calling VMSupport.getAgentProperties&quot;);
 285             }
 286         }
 287 
 288     } END_WITH_LOCAL_REFS(env);
 289 
 290 }
 291 
 292 void
 293 util_reset(void)
 294 {
 295 }
 296 
 297 jboolean
 298 isObjectTag(jbyte tag) {
 299     return (tag == JDWP_TAG(OBJECT)) ||
 300            (tag == JDWP_TAG(STRING)) ||
 301            (tag == JDWP_TAG(THREAD)) ||
 302            (tag == JDWP_TAG(THREAD_GROUP)) ||
 303            (tag == JDWP_TAG(CLASS_LOADER)) ||
 304            (tag == JDWP_TAG(CLASS_OBJECT)) ||
 305            (tag == JDWP_TAG(ARRAY));
 306 }
 307 
 308 jbyte
 309 specificTypeKey(JNIEnv *env, jobject object)
 310 {
 311     if (object == NULL) {
 312         return JDWP_TAG(OBJECT);
 313     } else if (JNI_FUNC_PTR(env,IsInstanceOf)(env, object, gdata-&gt;stringClass)) {
 314         return JDWP_TAG(STRING);
 315     } else if (JNI_FUNC_PTR(env,IsInstanceOf)(env, object, gdata-&gt;threadClass)) {
 316         return JDWP_TAG(THREAD);
 317     } else if (JNI_FUNC_PTR(env,IsInstanceOf)(env, object, gdata-&gt;threadGroupClass)) {
 318         return JDWP_TAG(THREAD_GROUP);
 319     } else if (JNI_FUNC_PTR(env,IsInstanceOf)(env, object, gdata-&gt;classLoaderClass)) {
 320         return JDWP_TAG(CLASS_LOADER);
 321     } else if (JNI_FUNC_PTR(env,IsInstanceOf)(env, object, gdata-&gt;classClass)) {
 322         return JDWP_TAG(CLASS_OBJECT);
 323     } else {
 324         jboolean classIsArray;
 325 
 326         WITH_LOCAL_REFS(env, 1) {
 327             jclass clazz;
 328             clazz = JNI_FUNC_PTR(env,GetObjectClass)(env, object);
 329             classIsArray = isArrayClass(clazz);
 330         } END_WITH_LOCAL_REFS(env);
 331 
 332         return (classIsArray ? JDWP_TAG(ARRAY) : JDWP_TAG(OBJECT));
 333     }
 334 }
 335 
 336 static void
 337 writeFieldValue(JNIEnv *env, PacketOutputStream *out, jobject object,
 338                 jfieldID field)
 339 {
 340     jclass clazz;
 341     char *signature = NULL;
 342     jvmtiError error;
 343     jbyte typeKey;
 344 
 345     clazz = JNI_FUNC_PTR(env,GetObjectClass)(env, object);
 346     error = fieldSignature(clazz, field, NULL, &amp;signature, NULL);
 347     if (error != JVMTI_ERROR_NONE) {
 348         outStream_setError(out, map2jdwpError(error));
 349         return;
 350     }
 351     typeKey = jdwpTag(signature);
 352     jvmtiDeallocate(signature);
 353 
 354     if (isReferenceTag(typeKey)) {
 355 
 356         jobject value = JNI_FUNC_PTR(env,GetObjectField)(env, object, field);
 357         (void)outStream_writeByte(out, specificTypeKey(env, value));
 358         (void)outStream_writeObjectRef(env, out, value);
 359         return;
 360 
 361     }
 362 
 363     /*
 364      * For primitive types, the type key is bounced back as is.
 365      */
 366 
 367     (void)outStream_writeByte(out, typeKey);
 368 
 369     switch (typeKey) {
 370         case JDWP_TAG(BYTE):
 371             (void)outStream_writeByte(out,
 372                       JNI_FUNC_PTR(env,GetByteField)(env, object, field));
 373             break;
 374 
 375         case JDWP_TAG(CHAR):
 376             (void)outStream_writeChar(out,
 377                       JNI_FUNC_PTR(env,GetCharField)(env, object, field));
 378             break;
 379 
 380         case JDWP_TAG(FLOAT):
 381             (void)outStream_writeFloat(out,
 382                       JNI_FUNC_PTR(env,GetFloatField)(env, object, field));
 383             break;
 384 
 385         case JDWP_TAG(DOUBLE):
 386             (void)outStream_writeDouble(out,
 387                       JNI_FUNC_PTR(env,GetDoubleField)(env, object, field));
 388             break;
 389 
 390         case JDWP_TAG(INT):
 391             (void)outStream_writeInt(out,
 392                       JNI_FUNC_PTR(env,GetIntField)(env, object, field));
 393             break;
 394 
 395         case JDWP_TAG(LONG):
 396             (void)outStream_writeLong(out,
 397                       JNI_FUNC_PTR(env,GetLongField)(env, object, field));
 398             break;
 399 
 400         case JDWP_TAG(SHORT):
 401             (void)outStream_writeShort(out,
 402                       JNI_FUNC_PTR(env,GetShortField)(env, object, field));
 403             break;
 404 
 405         case JDWP_TAG(BOOLEAN):
 406             (void)outStream_writeBoolean(out,
 407                       JNI_FUNC_PTR(env,GetBooleanField)(env, object, field));
 408             break;
 409     }
 410 }
 411 
 412 static void
 413 writeStaticFieldValue(JNIEnv *env, PacketOutputStream *out, jclass clazz,
 414                       jfieldID field)
 415 {
 416     jvmtiError error;
 417     char *signature = NULL;
 418     jbyte typeKey;
 419 
 420     error = fieldSignature(clazz, field, NULL, &amp;signature, NULL);
 421     if (error != JVMTI_ERROR_NONE) {
 422         outStream_setError(out, map2jdwpError(error));
 423         return;
 424     }
 425     typeKey = jdwpTag(signature);
 426     jvmtiDeallocate(signature);
 427 
 428 
 429     if (isReferenceTag(typeKey)) {
 430 
 431         jobject value = JNI_FUNC_PTR(env,GetStaticObjectField)(env, clazz, field);
 432         (void)outStream_writeByte(out, specificTypeKey(env, value));
 433         (void)outStream_writeObjectRef(env, out, value);
 434 
 435         return;
 436     }
 437 
 438     /*
 439      * For primitive types, the type key is bounced back as is.
 440      */
 441     (void)outStream_writeByte(out, typeKey);
 442     switch (typeKey) {
 443         case JDWP_TAG(BYTE):
 444             (void)outStream_writeByte(out,
 445                       JNI_FUNC_PTR(env,GetStaticByteField)(env, clazz, field));
 446             break;
 447 
 448         case JDWP_TAG(CHAR):
 449             (void)outStream_writeChar(out,
 450                       JNI_FUNC_PTR(env,GetStaticCharField)(env, clazz, field));
 451             break;
 452 
 453         case JDWP_TAG(FLOAT):
 454             (void)outStream_writeFloat(out,
 455                       JNI_FUNC_PTR(env,GetStaticFloatField)(env, clazz, field));
 456             break;
 457 
 458         case JDWP_TAG(DOUBLE):
 459             (void)outStream_writeDouble(out,
 460                       JNI_FUNC_PTR(env,GetStaticDoubleField)(env, clazz, field));
 461             break;
 462 
 463         case JDWP_TAG(INT):
 464             (void)outStream_writeInt(out,
 465                       JNI_FUNC_PTR(env,GetStaticIntField)(env, clazz, field));
 466             break;
 467 
 468         case JDWP_TAG(LONG):
 469             (void)outStream_writeLong(out,
 470                       JNI_FUNC_PTR(env,GetStaticLongField)(env, clazz, field));
 471             break;
 472 
 473         case JDWP_TAG(SHORT):
 474             (void)outStream_writeShort(out,
 475                       JNI_FUNC_PTR(env,GetStaticShortField)(env, clazz, field));
 476             break;
 477 
 478         case JDWP_TAG(BOOLEAN):
 479             (void)outStream_writeBoolean(out,
 480                       JNI_FUNC_PTR(env,GetStaticBooleanField)(env, clazz, field));
 481             break;
 482     }
 483 }
 484 
 485 void
 486 sharedGetFieldValues(PacketInputStream *in, PacketOutputStream *out,
 487                      jboolean isStatic)
 488 {
 489     JNIEnv *env = getEnv();
 490     jint length;
 491     jobject object;
 492     jclass clazz;
 493 
 494     object = NULL;
 495     clazz  = NULL;
 496 
 497     if (isStatic) {
 498         clazz = inStream_readClassRef(env, in);
 499     } else {
 500         object = inStream_readObjectRef(env, in);
 501     }
 502 
 503     length = inStream_readInt(in);
 504     if (inStream_error(in)) {
 505         return;
 506     }
 507 
 508     WITH_LOCAL_REFS(env, length + 1) { /* +1 for class with instance fields */
 509 
 510         int i;
 511 
 512         (void)outStream_writeInt(out, length);
 513         for (i = 0; (i &lt; length) &amp;&amp; !outStream_error(out); i++) {
 514             jfieldID field = inStream_readFieldID(in);
 515 
 516             if (isStatic) {
 517                 writeStaticFieldValue(env, out, clazz, field);
 518             } else {
 519                 writeFieldValue(env, out, object, field);
 520             }
 521         }
 522 
 523     } END_WITH_LOCAL_REFS(env);
 524 }
 525 
 526 jboolean
 527 sharedInvoke(PacketInputStream *in, PacketOutputStream *out)
 528 {
 529     jvalue *arguments = NULL;
 530     jint options;
 531     jvmtiError error;
 532     jbyte invokeType;
 533     jclass clazz;
 534     jmethodID method;
 535     jint argumentCount;
 536     jobject instance;
 537     jthread thread;
 538     JNIEnv *env;
 539 
 540     /*
 541      * Instance methods start with the instance, thread and class,
 542      * and statics and constructors start with the class and then the
 543      * thread.
 544      */
 545     env = getEnv();
 546     if (inStream_command(in) == JDWP_COMMAND(ObjectReference, InvokeMethod)) {
 547         instance = inStream_readObjectRef(env, in);
 548         thread = inStream_readThreadRef(env, in);
 549         clazz = inStream_readClassRef(env, in);
 550     } else { /* static method or constructor */
 551         instance = NULL;
 552         clazz = inStream_readClassRef(env, in);
 553         thread = inStream_readThreadRef(env, in);
 554     }
 555 
 556     /*
 557      * ... and the rest of the packet is identical for all commands
 558      */
 559     method = inStream_readMethodID(in);
 560     argumentCount = inStream_readInt(in);
 561     if (inStream_error(in)) {
 562         return JNI_TRUE;
 563     }
 564 
 565     /* If count == 0, don&#39;t try and allocate 0 bytes, you&#39;ll get NULL */
 566     if ( argumentCount &gt; 0 ) {
 567         int i;
 568         /*LINTED*/
 569         arguments = jvmtiAllocate(argumentCount * (jint)sizeof(*arguments));
 570         if (arguments == NULL) {
 571             outStream_setError(out, JDWP_ERROR(OUT_OF_MEMORY));
 572             return JNI_TRUE;
 573         }
 574         for (i = 0; (i &lt; argumentCount) &amp;&amp; !inStream_error(in); i++) {
 575             arguments[i] = inStream_readValue(in);
 576         }
 577         if (inStream_error(in)) {
 578             return JNI_TRUE;
 579         }
 580     }
 581 
 582     options = inStream_readInt(in);
 583     if (inStream_error(in)) {
 584         if ( arguments != NULL ) {
 585             jvmtiDeallocate(arguments);
 586         }
 587         return JNI_TRUE;
 588     }
 589 
 590     if (inStream_command(in) == JDWP_COMMAND(ClassType, NewInstance)) {
 591         invokeType = INVOKE_CONSTRUCTOR;
 592     } else if (inStream_command(in) == JDWP_COMMAND(ClassType, InvokeMethod)) {
 593         invokeType = INVOKE_STATIC;
 594     } else if (inStream_command(in) == JDWP_COMMAND(InterfaceType, InvokeMethod)) {
 595         invokeType = INVOKE_STATIC;
 596     } else if (inStream_command(in) == JDWP_COMMAND(ObjectReference, InvokeMethod)) {
 597         invokeType = INVOKE_INSTANCE;
 598     } else {
 599         outStream_setError(out, JDWP_ERROR(INTERNAL));
 600         if ( arguments != NULL ) {
 601             jvmtiDeallocate(arguments);
 602         }
 603         return JNI_TRUE;
 604     }
 605 
 606     /*
 607      * Request the invoke. If there are no errors in the request,
 608      * the interrupting thread will actually do the invoke and a
 609      * reply will be generated subsequently, so we don&#39;t reply here.
 610      */
 611     error = invoker_requestInvoke(invokeType, (jbyte)options, inStream_id(in),
 612                                   thread, clazz, method,
 613                                   instance, arguments, argumentCount);
 614     if (error != JVMTI_ERROR_NONE) {
 615         outStream_setError(out, map2jdwpError(error));
 616         if ( arguments != NULL ) {
 617             jvmtiDeallocate(arguments);
 618         }
 619         return JNI_TRUE;
 620     }
 621 
 622     return JNI_FALSE;   /* Don&#39;t reply */
 623 }
 624 
 625 jint
 626 uniqueID(void)
 627 {
 628     static jint currentID = 0;
 629     return currentID++;
 630 }
 631 
 632 int
 633 filterDebugThreads(jthread *threads, int count)
 634 {
 635     int i;
 636     int current;
 637 
 638     /* Squish out all of the debugger-spawned threads */
 639     for (i = 0, current = 0; i &lt; count; i++) {
 640         jthread thread = threads[i];
 641         if (!threadControl_isDebugThread(thread)) {
 642             if (i &gt; current) {
 643                 threads[current] = thread;
 644             }
 645             current++;
 646         }
 647     }
 648     return current;
 649 }
 650 
 651 jbyte
 652 referenceTypeTag(jclass clazz)
 653 {
 654     jbyte tag;
 655 
 656     if (isInterface(clazz)) {
 657         tag = JDWP_TYPE_TAG(INTERFACE);
 658     } else if (isArrayClass(clazz)) {
 659         tag = JDWP_TYPE_TAG(ARRAY);
 660     } else {
 661         tag = JDWP_TYPE_TAG(CLASS);
 662     }
 663 
 664     return tag;
 665 }
 666 
 667 /**
 668  * Get field modifiers
 669  */
 670 jvmtiError
 671 fieldModifiers(jclass clazz, jfieldID field, jint *pmodifiers)
 672 {
 673     jvmtiError error;
 674 
 675     *pmodifiers = 0;
 676     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetFieldModifiers)
 677             (gdata-&gt;jvmti, clazz, field, pmodifiers);
 678     return error;
 679 }
 680 
 681 /**
 682  * Get method modifiers
 683  */
 684 jvmtiError
 685 methodModifiers(jmethodID method, jint *pmodifiers)
 686 {
 687     jvmtiError error;
 688 
 689     *pmodifiers = 0;
 690     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetMethodModifiers)
 691             (gdata-&gt;jvmti, method, pmodifiers);
 692     return error;
 693 }
 694 
 695 /* Returns a local ref to the declaring class for a method, or NULL. */
 696 jvmtiError
 697 methodClass(jmethodID method, jclass *pclazz)
 698 {
 699     jvmtiError error;
 700 
 701     *pclazz = NULL;
 702     error = FUNC_PTR(gdata-&gt;jvmti,GetMethodDeclaringClass)
 703                                 (gdata-&gt;jvmti, method, pclazz);
 704     return error;
 705 }
 706 
 707 /* Returns a local ref to the declaring class for a method, or NULL. */
 708 jvmtiError
 709 methodLocation(jmethodID method, jlocation *ploc1, jlocation *ploc2)
 710 {
 711     jvmtiError error;
 712 
 713     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetMethodLocation)
 714                                 (gdata-&gt;jvmti, method, ploc1, ploc2);
 715     return error;
 716 }
 717 
 718 /**
 719  * Get method signature
 720  */
 721 jvmtiError
 722 methodSignature(jmethodID method,
 723         char **pname, char **psignature, char **pgeneric_signature)
 724 {
 725     jvmtiError error;
 726     char *name = NULL;
 727     char *signature = NULL;
 728     char *generic_signature = NULL;
 729 
 730     error = FUNC_PTR(gdata-&gt;jvmti,GetMethodName)
 731             (gdata-&gt;jvmti, method, &amp;name, &amp;signature, &amp;generic_signature);
 732 
 733     if ( pname != NULL ) {
 734         *pname = name;
 735     } else if ( name != NULL )  {
 736         jvmtiDeallocate(name);
 737     }
 738     if ( psignature != NULL ) {
 739         *psignature = signature;
 740     } else if ( signature != NULL ) {
 741         jvmtiDeallocate(signature);
 742     }
 743     if ( pgeneric_signature != NULL ) {
 744         *pgeneric_signature = generic_signature;
 745     } else if ( generic_signature != NULL )  {
 746         jvmtiDeallocate(generic_signature);
 747     }
 748     return error;
 749 }
 750 
 751 /*
 752  * Get the return type key of the method
 753  *     V or B C D F I J S Z L  [
 754  */
 755 jvmtiError
 756 methodReturnType(jmethodID method, char *typeKey)
 757 {
 758     char       *signature;
 759     jvmtiError  error;
 760 
 761     signature = NULL;
 762     error     = methodSignature(method, NULL, &amp;signature, NULL);
 763     if (error == JVMTI_ERROR_NONE) {
 764         if (signature == NULL ) {
 765             error = AGENT_ERROR_INVALID_TAG;
 766         } else {
 767             char * xx;
 768 
 769             xx = strchr(signature, &#39;)&#39;);
 770             if (xx == NULL || *(xx + 1) == 0) {
 771                 error = AGENT_ERROR_INVALID_TAG;
 772             } else {
 773                *typeKey = *(xx + 1);
 774             }
 775             jvmtiDeallocate(signature);
 776         }
 777     }
 778     return error;
 779 }
 780 
 781 
 782 /**
 783  * Return class loader for a class (must be inside a WITH_LOCAL_REFS)
 784  */
 785 jvmtiError
 786 classLoader(jclass clazz, jobject *pclazz)
 787 {
 788     jvmtiError error;
 789 
 790     *pclazz = NULL;
 791     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetClassLoader)
 792             (gdata-&gt;jvmti, clazz, pclazz);
 793     return error;
 794 }
 795 
 796 /**
 797  * Get field signature
 798  */
 799 jvmtiError
 800 fieldSignature(jclass clazz, jfieldID field,
 801         char **pname, char **psignature, char **pgeneric_signature)
 802 {
 803     jvmtiError error;
 804     char *name = NULL;
 805     char *signature = NULL;
 806     char *generic_signature = NULL;
 807 
 808     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetFieldName)
 809             (gdata-&gt;jvmti, clazz, field, &amp;name, &amp;signature, &amp;generic_signature);
 810 
 811     if ( pname != NULL ) {
 812         *pname = name;
 813     } else if ( name != NULL )  {
 814         jvmtiDeallocate(name);
 815     }
 816     if ( psignature != NULL ) {
 817         *psignature = signature;
 818     } else if ( signature != NULL )  {
 819         jvmtiDeallocate(signature);
 820     }
 821     if ( pgeneric_signature != NULL ) {
 822         *pgeneric_signature = generic_signature;
 823     } else if ( generic_signature != NULL )  {
 824         jvmtiDeallocate(generic_signature);
 825     }
 826     return error;
 827 }
 828 
 829 JNIEnv *
 830 getEnv(void)
 831 {
 832     JNIEnv *env = NULL;
 833     jint rc;
 834 
 835     rc = FUNC_PTR(gdata-&gt;jvm,GetEnv)
 836                 (gdata-&gt;jvm, (void **)&amp;env, JNI_VERSION_1_2);
 837     if (rc != JNI_OK) {
 838         ERROR_MESSAGE((&quot;JDWP Unable to get JNI 1.2 environment, jvm-&gt;GetEnv() return code = %d&quot;,
 839                 rc));
 840         EXIT_ERROR(AGENT_ERROR_NO_JNI_ENV,NULL);
 841     }
 842     return env;
 843 }
 844 
 845 jvmtiError
 846 spawnNewThread(jvmtiStartFunction func, void *arg, char *name)
 847 {
 848     JNIEnv *env = getEnv();
 849     jvmtiError error;
 850 
 851     LOG_MISC((&quot;Spawning new thread: %s&quot;, name));
 852 
 853     WITH_LOCAL_REFS(env, 3) {
 854 
 855         jthread thread;
 856         jstring nameString;
 857 
 858         nameString = JNI_FUNC_PTR(env,NewStringUTF)(env, name);
 859         if (JNI_FUNC_PTR(env,ExceptionOccurred)(env)) {
 860             JNI_FUNC_PTR(env,ExceptionClear)(env);
 861             error = AGENT_ERROR_OUT_OF_MEMORY;
 862             goto err;
 863         }
 864 
 865         thread = JNI_FUNC_PTR(env,NewObject)
 866                         (env, gdata-&gt;threadClass, gdata-&gt;threadConstructor,
 867                                    gdata-&gt;systemThreadGroup, nameString);
 868         if (JNI_FUNC_PTR(env,ExceptionOccurred)(env)) {
 869             JNI_FUNC_PTR(env,ExceptionClear)(env);
 870             error = AGENT_ERROR_OUT_OF_MEMORY;
 871             goto err;
 872         }
 873 
 874         /*
 875          * Make the debugger thread a daemon
 876          */
 877         JNI_FUNC_PTR(env,CallVoidMethod)
 878                         (env, thread, gdata-&gt;threadSetDaemon, JNI_TRUE);
 879         if (JNI_FUNC_PTR(env,ExceptionOccurred)(env)) {
 880             JNI_FUNC_PTR(env,ExceptionClear)(env);
 881             error = AGENT_ERROR_JNI_EXCEPTION;
 882             goto err;
 883         }
 884 
 885         error = threadControl_addDebugThread(thread);
 886         if (error == JVMTI_ERROR_NONE) {
 887             /*
 888              * Debugger threads need cycles in all sorts of strange
 889              * situations (e.g. infinite cpu-bound loops), so give the
 890              * thread a high priority. Note that if the VM has an application
 891              * thread running at the max priority, there is still a chance
 892              * that debugger threads will be starved. (There needs to be
 893              * a way to give debugger threads a priority higher than any
 894              * application thread).
 895              */
 896             error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,RunAgentThread)
 897                         (gdata-&gt;jvmti, thread, func, arg,
 898                                         JVMTI_THREAD_MAX_PRIORITY);
 899         }
 900 
 901         err: ;
 902 
 903     } END_WITH_LOCAL_REFS(env);
 904 
 905     return error;
 906 }
 907 
 908 jvmtiError
 909 jvmtiGetCapabilities(jvmtiCapabilities *caps)
 910 {
 911     if ( gdata-&gt;vmDead ) {
 912         return AGENT_ERROR_VM_DEAD;
 913     }
 914     if (!gdata-&gt;haveCachedJvmtiCapabilities) {
 915         jvmtiError error;
 916 
 917         error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetCapabilities)
 918                         (gdata-&gt;jvmti, &amp;(gdata-&gt;cachedJvmtiCapabilities));
 919         if (error != JVMTI_ERROR_NONE) {
 920             return error;
 921         }
 922         gdata-&gt;haveCachedJvmtiCapabilities = JNI_TRUE;
 923     }
 924 
 925     *caps = gdata-&gt;cachedJvmtiCapabilities;
 926 
 927     return JVMTI_ERROR_NONE;
 928 }
 929 
 930 static jint
 931 jvmtiVersion(void)
 932 {
 933     if (gdata-&gt;cachedJvmtiVersion == 0) {
 934         jvmtiError error;
 935         error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetVersionNumber)
 936                         (gdata-&gt;jvmti, &amp;(gdata-&gt;cachedJvmtiVersion));
 937         if (error != JVMTI_ERROR_NONE) {
 938             EXIT_ERROR(error, &quot;on getting the JVMTI version number&quot;);
 939         }
 940     }
 941     return gdata-&gt;cachedJvmtiVersion;
 942 }
 943 
 944 jint
 945 jvmtiMajorVersion(void)
 946 {
 947     return (jvmtiVersion() &amp; JVMTI_VERSION_MASK_MAJOR)
 948                     &gt;&gt; JVMTI_VERSION_SHIFT_MAJOR;
 949 }
 950 
 951 jint
 952 jvmtiMinorVersion(void)
 953 {
 954     return (jvmtiVersion() &amp; JVMTI_VERSION_MASK_MINOR)
 955                     &gt;&gt; JVMTI_VERSION_SHIFT_MINOR;
 956 }
 957 
 958 jint
 959 jvmtiMicroVersion(void)
 960 {
 961     return (jvmtiVersion() &amp; JVMTI_VERSION_MASK_MICRO)
 962                     &gt;&gt; JVMTI_VERSION_SHIFT_MICRO;
 963 }
 964 
 965 jboolean
 966 canSuspendResumeThreadLists(void)
 967 {
 968     jvmtiError error;
 969     jvmtiCapabilities cap;
 970 
 971     error = jvmtiGetCapabilities(&amp;cap);
 972     return (error == JVMTI_ERROR_NONE &amp;&amp; cap.can_suspend);
 973 }
 974 
 975 jvmtiError
 976 getSourceDebugExtension(jclass clazz, char **extensionPtr)
 977 {
 978     return JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetSourceDebugExtension)
 979                 (gdata-&gt;jvmti, clazz, extensionPtr);
 980 }
 981 
 982 
 983 static void
 984 handleInterrupt(void)
 985 {
 986     /*
 987      * An interrupt is handled:
 988      *
 989      * 1) for running application threads by deferring the interrupt
 990      * until the current event handler has concluded.
 991      *
 992      * 2) for debugger threads by ignoring the interrupt; this is the
 993      * most robust solution since debugger threads don&#39;t use interrupts
 994      * to signal any condition.
 995      *
 996      * 3) for application threads that have not started or already
 997      * ended by ignoring the interrupt. In the former case, the application
 998      * is relying on timing to determine whether or not the thread sees
 999      * the interrupt; in the latter case, the interrupt is meaningless.
1000      */
1001     jthread thread = threadControl_currentThread();
1002     if ((thread != NULL) &amp;&amp; (!threadControl_isDebugThread(thread))) {
1003         threadControl_setPendingInterrupt(thread);
1004     }
1005 }
1006 
1007 static jvmtiError
1008 ignore_vm_death(jvmtiError error)
1009 {
1010     if (error == JVMTI_ERROR_WRONG_PHASE) {
1011         LOG_MISC((&quot;VM_DEAD, in debugMonitor*()?&quot;));
1012         return JVMTI_ERROR_NONE; /* JVMTI does this, not JVMDI? */
1013     }
1014     return error;
1015 }
1016 
1017 void
1018 debugMonitorEnter(jrawMonitorID monitor)
1019 {
1020     jvmtiError error;
1021     while (JNI_TRUE) {
1022         error = FUNC_PTR(gdata-&gt;jvmti,RawMonitorEnter)
1023                         (gdata-&gt;jvmti, monitor);
1024         error = ignore_vm_death(error);
1025         if (error == JVMTI_ERROR_INTERRUPT) {
1026             handleInterrupt();
1027         } else {
1028             break;
1029         }
1030     }
1031     if (error != JVMTI_ERROR_NONE) {
1032         EXIT_ERROR(error, &quot;on raw monitor enter&quot;);
1033     }
1034 }
1035 
1036 void
1037 debugMonitorExit(jrawMonitorID monitor)
1038 {
1039     jvmtiError error;
1040 
1041     error = FUNC_PTR(gdata-&gt;jvmti,RawMonitorExit)
1042                 (gdata-&gt;jvmti, monitor);
1043     error = ignore_vm_death(error);
1044     if (error != JVMTI_ERROR_NONE) {
1045         EXIT_ERROR(error, &quot;on raw monitor exit&quot;);
1046     }
1047 }
1048 
1049 void
1050 debugMonitorWait(jrawMonitorID monitor)
1051 {
1052     jvmtiError error;
1053     error = FUNC_PTR(gdata-&gt;jvmti,RawMonitorWait)
1054         (gdata-&gt;jvmti, monitor, ((jlong)(-1)));
1055 
1056     /*
1057      * According to the JLS (17.8), here we have
1058      * either :
1059      * a- been notified
1060      * b- gotten a suprious wakeup
1061      * c- been interrupted
1062      * If both a and c have happened, the VM must choose
1063      * which way to return - a or c.  If it chooses c
1064      * then the notify is gone - either to some other
1065      * thread that is also waiting, or it is dropped
1066      * on the floor.
1067      *
1068      * a is what we expect.  b won&#39;t hurt us any -
1069      * callers should be programmed to handle
1070      * spurious wakeups.  In case of c,
1071      * then the interrupt has been cleared, but
1072      * we don&#39;t want to consume it.  It came from
1073      * user code and is intended for user code, not us.
1074      * So, we will remember that the interrupt has
1075      * occurred and re-activate it when this thread
1076      * goes back into user code.
1077      * That being said, what do we do here?  Since
1078      * we could have been notified too, here we will
1079      * just pretend that we have been.  It won&#39;t hurt
1080      * anything to return in the same way as if
1081      * we were notified since callers have to be able to
1082      * handle spurious wakeups anyway.
1083      */
1084     if (error == JVMTI_ERROR_INTERRUPT) {
1085         handleInterrupt();
1086         error = JVMTI_ERROR_NONE;
1087     }
1088     error = ignore_vm_death(error);
1089     if (error != JVMTI_ERROR_NONE) {
1090         EXIT_ERROR(error, &quot;on raw monitor wait&quot;);
1091     }
1092 }
1093 
1094 void
1095 debugMonitorTimedWait(jrawMonitorID monitor, jlong millis)
1096 {
1097     jvmtiError error;
1098     error = FUNC_PTR(gdata-&gt;jvmti,RawMonitorWait)
1099         (gdata-&gt;jvmti, monitor, millis);
1100     if (error == JVMTI_ERROR_INTERRUPT) {
1101         /* See comment above */
1102         handleInterrupt();
1103         error = JVMTI_ERROR_NONE;
1104     }
1105     error = ignore_vm_death(error);
1106     if (error != JVMTI_ERROR_NONE) {
1107         EXIT_ERROR(error, &quot;on raw monitor timed wait&quot;);
1108     }
1109 }
1110 
1111 void
1112 debugMonitorNotify(jrawMonitorID monitor)
1113 {
1114     jvmtiError error;
1115 
1116     error = FUNC_PTR(gdata-&gt;jvmti,RawMonitorNotify)
1117                 (gdata-&gt;jvmti, monitor);
1118     error = ignore_vm_death(error);
1119     if (error != JVMTI_ERROR_NONE) {
1120         EXIT_ERROR(error, &quot;on raw monitor notify&quot;);
1121     }
1122 }
1123 
1124 void
1125 debugMonitorNotifyAll(jrawMonitorID monitor)
1126 {
1127     jvmtiError error;
1128 
1129     error = FUNC_PTR(gdata-&gt;jvmti,RawMonitorNotifyAll)
1130                 (gdata-&gt;jvmti, monitor);
1131     error = ignore_vm_death(error);
1132     if (error != JVMTI_ERROR_NONE) {
1133         EXIT_ERROR(error, &quot;on raw monitor notify all&quot;);
1134     }
1135 }
1136 
1137 jrawMonitorID
1138 debugMonitorCreate(char *name)
1139 {
1140     jrawMonitorID monitor;
1141     jvmtiError error;
1142 
1143     error = FUNC_PTR(gdata-&gt;jvmti,CreateRawMonitor)
1144                 (gdata-&gt;jvmti, name, &amp;monitor);
1145     if (error != JVMTI_ERROR_NONE) {
1146         EXIT_ERROR(error, &quot;on creation of a raw monitor&quot;);
1147     }
1148     return monitor;
1149 }
1150 
1151 void
1152 debugMonitorDestroy(jrawMonitorID monitor)
1153 {
1154     jvmtiError error;
1155 
1156     error = FUNC_PTR(gdata-&gt;jvmti,DestroyRawMonitor)
1157                 (gdata-&gt;jvmti, monitor);
1158     error = ignore_vm_death(error);
1159     if (error != JVMTI_ERROR_NONE) {
1160         EXIT_ERROR(error, &quot;on destruction of raw monitor&quot;);
1161     }
1162 }
1163 
1164 /**
1165  * Return array of all threads (must be inside a WITH_LOCAL_REFS)
1166  */
1167 jthread *
1168 allThreads(jint *count)
1169 {
1170     jthread *threads;
1171     jvmtiError error;
1172 
1173     *count = 0;
1174     threads = NULL;
1175     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetAllThreads)
1176                 (gdata-&gt;jvmti, count, &amp;threads);
1177     if (error == AGENT_ERROR_OUT_OF_MEMORY) {
1178         return NULL; /* Let caller deal with no memory? */
1179     }
1180     if (error != JVMTI_ERROR_NONE) {
1181         EXIT_ERROR(error, &quot;getting all threads&quot;);
1182     }
1183     return threads;
1184 }
1185 
1186 /**
1187  * Fill the passed in structure with thread group info.
1188  * name field is JVMTI allocated.  parent is global ref.
1189  */
1190 void
1191 threadGroupInfo(jthreadGroup group, jvmtiThreadGroupInfo *info)
1192 {
1193     jvmtiError error;
1194 
1195     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetThreadGroupInfo)
1196                 (gdata-&gt;jvmti, group, info);
1197     if (error != JVMTI_ERROR_NONE) {
1198         EXIT_ERROR(error, &quot;on getting thread group info&quot;);
1199     }
1200 }
1201 
1202 /**
1203  * Return class signature string
1204  */
1205 jvmtiError
1206 classSignature(jclass clazz, char **psignature, char **pgeneric_signature)
1207 {
1208     jvmtiError error;
1209     char *signature = NULL;
1210 
1211     /*
1212      * pgeneric_signature can be NULL, and GetClassSignature
1213      * accepts NULL.
1214      */
1215     error = FUNC_PTR(gdata-&gt;jvmti,GetClassSignature)
1216                 (gdata-&gt;jvmti, clazz, &amp;signature, pgeneric_signature);
1217 
1218     if ( psignature != NULL ) {
1219         *psignature = signature;
1220     } else if ( signature != NULL )  {
1221         jvmtiDeallocate(signature);
1222     }
1223     return error;
1224 }
1225 
1226 /* Get class name (not signature) */
1227 char *
1228 getClassname(jclass clazz)
1229 {
1230     char *classname;
1231 
1232     classname = NULL;
1233     if ( clazz != NULL ) {
1234         if (classSignature(clazz, &amp;classname, NULL) != JVMTI_ERROR_NONE) {
1235             classname = NULL;
1236         } else {
1237             /* Convert in place */
1238             convertSignatureToClassname(classname);
1239         }
1240     }
1241     return classname; /* Caller must free this memory */
1242 }
1243 
1244 void
1245 writeGenericSignature(PacketOutputStream *out, char *genericSignature)
1246 {
1247     if (genericSignature == NULL) {
1248         (void)outStream_writeString(out, &quot;&quot;);
1249     } else {
1250         (void)outStream_writeString(out, genericSignature);
1251     }
1252 }
1253 
1254 jint
1255 classStatus(jclass clazz)
1256 {
1257     jint status;
1258     jvmtiError error;
1259 
1260     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetClassStatus)
1261                 (gdata-&gt;jvmti, clazz, &amp;status);
1262     if (error != JVMTI_ERROR_NONE) {
1263         EXIT_ERROR(error, &quot;on getting class status&quot;);
1264     }
1265     return status;
1266 }
1267 
1268 static jboolean
1269 isArrayClass(jclass clazz)
1270 {
1271     jboolean isArray = JNI_FALSE;
1272     jvmtiError error;
1273 
1274     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,IsArrayClass)
1275                 (gdata-&gt;jvmti, clazz, &amp;isArray);
1276     if (error != JVMTI_ERROR_NONE) {
1277         EXIT_ERROR(error, &quot;on checking for an array class&quot;);
1278     }
1279     return isArray;
1280 }
1281 
1282 static jboolean
1283 isInterface(jclass clazz)
1284 {
1285     jboolean isInterface = JNI_FALSE;
1286     jvmtiError error;
1287 
1288     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,IsInterface)
1289                 (gdata-&gt;jvmti, clazz, &amp;isInterface);
1290     if (error != JVMTI_ERROR_NONE) {
1291         EXIT_ERROR(error, &quot;on checking for an interface&quot;);
1292     }
1293     return isInterface;
1294 }
1295 
1296 jvmtiError
1297 isFieldSynthetic(jclass clazz, jfieldID field, jboolean *psynthetic)
1298 {
1299     jvmtiError error;
1300 
1301     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,IsFieldSynthetic)
1302                 (gdata-&gt;jvmti, clazz, field, psynthetic);
1303     if ( error == JVMTI_ERROR_MUST_POSSESS_CAPABILITY ) {
1304         /* If the query is not supported, we assume it is not synthetic. */
1305         *psynthetic = JNI_FALSE;
1306         return JVMTI_ERROR_NONE;
1307     }
1308     return error;
1309 }
1310 
1311 jvmtiError
1312 isMethodSynthetic(jmethodID method, jboolean *psynthetic)
1313 {
1314     jvmtiError error;
1315 
1316     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,IsMethodSynthetic)
1317                 (gdata-&gt;jvmti, method, psynthetic);
1318     if ( error == JVMTI_ERROR_MUST_POSSESS_CAPABILITY ) {
1319         /* If the query is not supported, we assume it is not synthetic. */
1320         *psynthetic = JNI_FALSE;
1321         return JVMTI_ERROR_NONE;
1322     }
1323     return error;
1324 }
1325 
1326 jboolean
1327 isMethodNative(jmethodID method)
1328 {
1329     jboolean isNative = JNI_FALSE;
1330     jvmtiError error;
1331 
1332     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,IsMethodNative)
1333                 (gdata-&gt;jvmti, method, &amp;isNative);
1334     if (error != JVMTI_ERROR_NONE) {
1335         EXIT_ERROR(error, &quot;on checking for a native interface&quot;);
1336     }
1337     return isNative;
1338 }
1339 
1340 jboolean
1341 isSameObject(JNIEnv *env, jobject o1, jobject o2)
1342 {
1343     if ( o1==o2 ) {
1344         return JNI_TRUE;
1345     }
1346     return FUNC_PTR(env,IsSameObject)(env, o1, o2);
1347 }
1348 
1349 jint
1350 objectHashCode(jobject object)
1351 {
1352     jint hashCode = 0;
1353     jvmtiError error;
1354 
1355     if ( object!=NULL ) {
1356         error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetObjectHashCode)
1357                     (gdata-&gt;jvmti, object, &amp;hashCode);
1358         if (error != JVMTI_ERROR_NONE) {
1359             EXIT_ERROR(error, &quot;on getting an object hash code&quot;);
1360         }
1361     }
1362     return hashCode;
1363 }
1364 
1365 /* Get all implemented interfaces (must be inside a WITH_LOCAL_REFS) */
1366 jvmtiError
1367 allInterfaces(jclass clazz, jclass **ppinterfaces, jint *pcount)
1368 {
1369     jvmtiError error;
1370 
1371     *pcount = 0;
1372     *ppinterfaces = NULL;
1373     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetImplementedInterfaces)
1374                 (gdata-&gt;jvmti, clazz, pcount, ppinterfaces);
1375     return error;
1376 }
1377 
1378 /* Get all loaded classes (must be inside a WITH_LOCAL_REFS) */
1379 jvmtiError
1380 allLoadedClasses(jclass **ppclasses, jint *pcount)
1381 {
1382     jvmtiError error;
1383 
1384     *pcount = 0;
1385     *ppclasses = NULL;
1386     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetLoadedClasses)
1387                 (gdata-&gt;jvmti, pcount, ppclasses);
1388     return error;
1389 }
1390 
1391 /* Get all loaded classes for a loader (must be inside a WITH_LOCAL_REFS) */
1392 jvmtiError
1393 allClassLoaderClasses(jobject loader, jclass **ppclasses, jint *pcount)
1394 {
1395     jvmtiError error;
1396 
1397     *pcount = 0;
1398     *ppclasses = NULL;
1399     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetClassLoaderClasses)
1400                 (gdata-&gt;jvmti, loader, pcount, ppclasses);
1401     return error;
1402 }
1403 
1404 static jboolean
1405 is_a_nested_class(char *outer_sig, int outer_sig_len, char *sig, int sep)
1406 {
1407     char *inner;
1408 
1409     /* Assumed outer class signature is  &quot;LOUTERCLASSNAME;&quot;
1410      *         inner class signature is  &quot;LOUTERCLASSNAME$INNERNAME;&quot;
1411      *
1412      * INNERNAME can take the form:
1413      *    [0-9][1-9]*        anonymous class somewhere in the file
1414      *    [0-9][1-9]*NAME    local class somewhere in the OUTER class
1415      *    NAME               nested class in OUTER
1416      *
1417      * If NAME itself contains a $ (sep) then classname is further nested
1418      *    inside another class.
1419      *
1420      */
1421 
1422     /* Check prefix first */
1423     if ( strncmp(sig, outer_sig, outer_sig_len-1) != 0 ) {
1424         return JNI_FALSE;
1425     }
1426 
1427     /* Prefix must be followed by a $ (sep) */
1428     if ( sig[outer_sig_len-1] != sep ) {
1429         return JNI_FALSE;  /* No sep follows the match, must not be nested. */
1430     }
1431 
1432     /* Walk past any digits, if we reach the end, must be pure anonymous */
1433     inner = sig + outer_sig_len;
1434 #if 1 /* We want to return local classes */
1435     while ( *inner &amp;&amp; isdigit(*inner) ) {
1436         inner++;
1437     }
1438     /* But anonymous class names can&#39;t be trusted. */
1439     if ( *inner == &#39;;&#39; ) {
1440         return JNI_FALSE;  /* A pure anonymous class */
1441     }
1442 #else
1443     if ( *inner &amp;&amp; isdigit(*inner) ) {
1444         return JNI_FALSE;  /* A pure anonymous or local class */
1445     }
1446 #endif
1447 
1448     /* Nested deeper? */
1449     if ( strchr(inner, sep) != NULL ) {
1450         return JNI_FALSE;  /* Nested deeper than we want? */
1451     }
1452     return JNI_TRUE;
1453 }
1454 
1455 /* Get all nested classes for a class (must be inside a WITH_LOCAL_REFS) */
1456 jvmtiError
1457 allNestedClasses(jclass parent_clazz, jclass **ppnested, jint *pcount)
1458 {
1459     jvmtiError error;
1460     jobject parent_loader;
1461     jclass *classes;
1462     char *signature;
1463     size_t len;
1464     jint count;
1465     jint ncount;
1466     int i;
1467 
1468     *ppnested   = NULL;
1469     *pcount     = 0;
1470 
1471     parent_loader = NULL;
1472     classes       = NULL;
1473     signature     = NULL;
1474     count         = 0;
1475     ncount        = 0;
1476 
1477     error = classLoader(parent_clazz, &amp;parent_loader);
1478     if (error != JVMTI_ERROR_NONE) {
1479         return error;
1480     }
1481     error = classSignature(parent_clazz, &amp;signature, NULL);
1482     if (error != JVMTI_ERROR_NONE) {
1483         return error;
1484     }
1485     len = strlen(signature);
1486 
1487     error = allClassLoaderClasses(parent_loader, &amp;classes, &amp;count);
1488     if ( error != JVMTI_ERROR_NONE ) {
1489         jvmtiDeallocate(signature);
1490         return error;
1491     }
1492 
1493     for (i=0; i&lt;count; i++) {
1494         jclass clazz;
1495         char *candidate_signature;
1496 
1497         clazz = classes[i];
1498         candidate_signature = NULL;
1499         error = classSignature(clazz, &amp;candidate_signature, NULL);
1500         if (error != JVMTI_ERROR_NONE) {
1501             break;
1502         }
1503 
1504         if ( is_a_nested_class(signature, (int)len, candidate_signature, &#39;$&#39;) ||
1505              is_a_nested_class(signature, (int)len, candidate_signature, &#39;#&#39;) ) {
1506             /* Float nested classes to top */
1507             classes[i] = classes[ncount];
1508             classes[ncount++] = clazz;
1509         }
1510         jvmtiDeallocate(candidate_signature);
1511     }
1512 
1513     jvmtiDeallocate(signature);
1514 
1515     if ( count != 0 &amp;&amp;  ncount == 0 ) {
1516         jvmtiDeallocate(classes);
1517         classes = NULL;
1518     }
1519 
1520     *ppnested = classes;
1521     *pcount = ncount;
1522     return error;
1523 }
1524 
1525 void
1526 createLocalRefSpace(JNIEnv *env, jint capacity)
1527 {
1528     /*
1529      * Save current exception since it might get overwritten by
1530      * the calls below. Note we must depend on space in the existing
1531      * frame because asking for a new frame may generate an exception.
1532      */
1533     jobject throwable = JNI_FUNC_PTR(env,ExceptionOccurred)(env);
1534 
1535     /*
1536      * Use the current frame if necessary; otherwise create a new one
1537      */
1538     if (JNI_FUNC_PTR(env,PushLocalFrame)(env, capacity) &lt; 0) {
1539         EXIT_ERROR(AGENT_ERROR_OUT_OF_MEMORY,&quot;PushLocalFrame: Unable to push JNI frame&quot;);
1540     }
1541 
1542     /*
1543      * TO DO: This could be more efficient if it used EnsureLocalCapacity,
1544      * but that would not work if two functions on the call stack
1545      * use this function. We would need to either track reserved
1546      * references on a per-thread basis or come up with a convention
1547      * that would prevent two functions from depending on this function
1548      * at the same time.
1549      */
1550 
1551     /*
1552      * Restore exception state from before call
1553      */
1554     if (throwable != NULL) {
1555         JNI_FUNC_PTR(env,Throw)(env, throwable);
1556     } else {
1557         JNI_FUNC_PTR(env,ExceptionClear)(env);
1558     }
1559 }
1560 
1561 jboolean
1562 isClass(jobject object)
1563 {
1564     JNIEnv *env = getEnv();
1565     return JNI_FUNC_PTR(env,IsInstanceOf)(env, object, gdata-&gt;classClass);
1566 }
1567 
1568 jboolean
1569 isThread(jobject object)
1570 {
1571     JNIEnv *env = getEnv();
1572     return JNI_FUNC_PTR(env,IsInstanceOf)(env, object, gdata-&gt;threadClass);
1573 }
1574 
1575 jboolean
1576 isThreadGroup(jobject object)
1577 {
1578     JNIEnv *env = getEnv();
1579     return JNI_FUNC_PTR(env,IsInstanceOf)(env, object, gdata-&gt;threadGroupClass);
1580 }
1581 
1582 jboolean
1583 isString(jobject object)
1584 {
1585     JNIEnv *env = getEnv();
1586     return JNI_FUNC_PTR(env,IsInstanceOf)(env, object, gdata-&gt;stringClass);
1587 }
1588 
1589 jboolean
1590 isClassLoader(jobject object)
1591 {
1592     JNIEnv *env = getEnv();
1593     return JNI_FUNC_PTR(env,IsInstanceOf)(env, object, gdata-&gt;classLoaderClass);
1594 }
1595 
1596 jboolean
1597 isArray(jobject object)
1598 {
1599     JNIEnv *env = getEnv();
1600     jboolean is;
1601 
1602     WITH_LOCAL_REFS(env, 1) {
1603         jclass clazz;
1604         clazz = JNI_FUNC_PTR(env,GetObjectClass)(env, object);
1605         is = isArrayClass(clazz);
1606     } END_WITH_LOCAL_REFS(env);
1607 
1608     return is;
1609 }
1610 
1611 /**
1612  * Return property value as jstring
1613  */
1614 static jstring
1615 getPropertyValue(JNIEnv *env, char *propertyName)
1616 {
1617     jstring valueString;
1618     jstring nameString;
1619 
1620     valueString = NULL;
1621 
1622     /* Create new String object to hold the property name */
1623     nameString = JNI_FUNC_PTR(env,NewStringUTF)(env, propertyName);
1624     if (JNI_FUNC_PTR(env,ExceptionOccurred)(env)) {
1625         JNI_FUNC_PTR(env,ExceptionClear)(env);
1626         /* NULL will be returned below */
1627     } else {
1628         /* Call valueString = System.getProperty(nameString) */
1629         valueString = JNI_FUNC_PTR(env,CallStaticObjectMethod)
1630             (env, gdata-&gt;systemClass, gdata-&gt;systemGetProperty, nameString);
1631         if (JNI_FUNC_PTR(env,ExceptionOccurred)(env)) {
1632             JNI_FUNC_PTR(env,ExceptionClear)(env);
1633             valueString = NULL;
1634         }
1635     }
1636     return valueString;
1637 }
1638 
1639 /**
1640  * Set an agent property
1641  */
1642 void
1643 setAgentPropertyValue(JNIEnv *env, char *propertyName, char* propertyValue)
1644 {
1645     jstring nameString;
1646     jstring valueString;
1647 
1648     if (gdata-&gt;agent_properties == NULL) {
1649         /* VMSupport doesn&#39;t exist; so ignore */
1650         return;
1651     }
1652 
1653     /* Create jstrings for property name and value */
1654     nameString = JNI_FUNC_PTR(env,NewStringUTF)(env, propertyName);
1655     if (nameString != NULL) {
1656         /* convert the value to UTF8 */
1657         int len;
1658         char *utf8value;
1659         int utf8maxSize;
1660 
1661         len = (int)strlen(propertyValue);
1662         utf8maxSize = len * 4 + 1;
1663         utf8value = (char *)jvmtiAllocate(utf8maxSize);
1664         if (utf8value != NULL) {
1665             utf8FromPlatform(propertyValue, len, (jbyte *)utf8value, utf8maxSize);
1666             valueString = JNI_FUNC_PTR(env, NewStringUTF)(env, utf8value);
1667             jvmtiDeallocate(utf8value);
1668 
1669             if (valueString != NULL) {
1670                 /* invoke Properties.setProperty */
1671                 JNI_FUNC_PTR(env,CallObjectMethod)
1672                     (env, gdata-&gt;agent_properties,
1673                      gdata-&gt;setProperty,
1674                      nameString, valueString);
1675             }
1676         }
1677     }
1678     if (JNI_FUNC_PTR(env,ExceptionOccurred)(env)) {
1679         JNI_FUNC_PTR(env,ExceptionClear)(env);
1680     }
1681 }
1682 
1683 /**
1684  * Return property value as JDWP allocated string in UTF8 encoding
1685  */
1686 static char *
1687 getPropertyUTF8(JNIEnv *env, char *propertyName)
1688 {
1689     jvmtiError  error;
1690     char       *value;
1691 
1692     value = NULL;
1693     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetSystemProperty)
1694                 (gdata-&gt;jvmti, (const char *)propertyName, &amp;value);
1695     if (error != JVMTI_ERROR_NONE) {
1696         jstring valueString;
1697 
1698         value = NULL;
1699         valueString = getPropertyValue(env, propertyName);
1700 
1701         if (valueString != NULL) {
1702             const char *utf;
1703 
1704             /* Get the UTF8 encoding for this property value string */
1705             utf = JNI_FUNC_PTR(env,GetStringUTFChars)(env, valueString, NULL);
1706             /* Make a copy for returning, release the JNI copy */
1707             value = jvmtiAllocate((int)strlen(utf) + 1);
1708             if (value != NULL) {
1709                 (void)strcpy(value, utf);
1710             }
1711             JNI_FUNC_PTR(env,ReleaseStringUTFChars)(env, valueString, utf);
1712         }
1713     }
1714     if ( value == NULL ) {
1715         ERROR_MESSAGE((&quot;JDWP Can&#39;t get property value for %s&quot;, propertyName));
1716         EXIT_ERROR(AGENT_ERROR_NULL_POINTER,NULL);
1717     }
1718     return value;
1719 }
1720 
1721 jboolean
1722 isMethodObsolete(jmethodID method)
1723 {
1724     jvmtiError error;
1725     jboolean obsolete = JNI_TRUE;
1726 
1727     if ( method != NULL ) {
1728         error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,IsMethodObsolete)
1729                     (gdata-&gt;jvmti, method, &amp;obsolete);
1730         if (error != JVMTI_ERROR_NONE) {
1731             obsolete = JNI_TRUE;
1732         }
1733     }
1734     return obsolete;
1735 }
1736 
1737 /* Get the jvmti environment to be used with tags */
1738 jvmtiEnv *
1739 getSpecialJvmti(void)
1740 {
1741     jvmtiEnv  *jvmti;
1742     jvmtiError error;
1743     int        rc;
1744 
1745     /* Get one time use JVMTI Env */
1746     jvmtiCapabilities caps;
1747 
1748     rc = JVM_FUNC_PTR(gdata-&gt;jvm,GetEnv)
1749                      (gdata-&gt;jvm, (void **)&amp;jvmti, JVMTI_VERSION_1);
1750     if (rc != JNI_OK) {
1751         return NULL;
1752     }
1753     (void)memset(&amp;caps, 0, (int)sizeof(caps));
1754     caps.can_tag_objects = 1;
1755     error = JVMTI_FUNC_PTR(jvmti,AddCapabilities)(jvmti, &amp;caps);
1756     if ( error != JVMTI_ERROR_NONE ) {
1757         return NULL;
1758     }
1759     return jvmti;
1760 }
1761 
1762 void
1763 writeCodeLocation(PacketOutputStream *out, jclass clazz,
1764                        jmethodID method, jlocation location)
1765 {
1766     jbyte tag;
1767 
1768     if (clazz != NULL) {
1769         tag = referenceTypeTag(clazz);
1770     } else {
1771         tag = JDWP_TYPE_TAG(CLASS);
1772     }
1773     (void)outStream_writeByte(out, tag);
1774     (void)outStream_writeObjectRef(getEnv(), out, clazz);
1775     (void)outStream_writeMethodID(out, isMethodObsolete(method)?NULL:method);
1776     (void)outStream_writeLocation(out, location);
1777 }
1778 
1779 void *
1780 jvmtiAllocate(jint numBytes)
1781 {
1782     void *ptr;
1783     jvmtiError error;
1784     if ( numBytes == 0 ) {
1785         return NULL;
1786     }
1787     error = FUNC_PTR(gdata-&gt;jvmti,Allocate)
1788                 (gdata-&gt;jvmti, numBytes, (unsigned char**)&amp;ptr);
1789     if (error != JVMTI_ERROR_NONE ) {
1790         EXIT_ERROR(error, &quot;Can&#39;t allocate jvmti memory&quot;);
1791     }
1792     return ptr;
1793 }
1794 
1795 void
1796 jvmtiDeallocate(void *ptr)
1797 {
1798     jvmtiError error;
1799     if ( ptr == NULL ) {
1800         return;
1801     }
1802     error = FUNC_PTR(gdata-&gt;jvmti,Deallocate)
1803                 (gdata-&gt;jvmti, ptr);
1804     if (error != JVMTI_ERROR_NONE ) {
1805         EXIT_ERROR(error, &quot;Can&#39;t deallocate jvmti memory&quot;);
1806     }
1807 }
1808 
1809 /* Rarely needed, transport library uses JDWP errors, only use? */
1810 jvmtiError
1811 map2jvmtiError(jdwpError error)
1812 {
1813     switch ( error ) {
1814         case JDWP_ERROR(NONE):
1815             return JVMTI_ERROR_NONE;
1816         case JDWP_ERROR(INVALID_THREAD):
1817             return JVMTI_ERROR_INVALID_THREAD;
1818         case JDWP_ERROR(INVALID_THREAD_GROUP):
1819             return JVMTI_ERROR_INVALID_THREAD_GROUP;
1820         case JDWP_ERROR(INVALID_PRIORITY):
1821             return JVMTI_ERROR_INVALID_PRIORITY;
1822         case JDWP_ERROR(THREAD_NOT_SUSPENDED):
1823             return JVMTI_ERROR_THREAD_NOT_SUSPENDED;
1824         case JDWP_ERROR(THREAD_SUSPENDED):
1825             return JVMTI_ERROR_THREAD_SUSPENDED;
1826         case JDWP_ERROR(INVALID_OBJECT):
1827             return JVMTI_ERROR_INVALID_OBJECT;
1828         case JDWP_ERROR(INVALID_CLASS):
1829             return JVMTI_ERROR_INVALID_CLASS;
1830         case JDWP_ERROR(CLASS_NOT_PREPARED):
1831             return JVMTI_ERROR_CLASS_NOT_PREPARED;
1832         case JDWP_ERROR(INVALID_METHODID):
1833             return JVMTI_ERROR_INVALID_METHODID;
1834         case JDWP_ERROR(INVALID_LOCATION):
1835             return JVMTI_ERROR_INVALID_LOCATION;
1836         case JDWP_ERROR(INVALID_FIELDID):
1837             return JVMTI_ERROR_INVALID_FIELDID;
1838         case JDWP_ERROR(INVALID_FRAMEID):
1839             return AGENT_ERROR_INVALID_FRAMEID;
1840         case JDWP_ERROR(NO_MORE_FRAMES):
1841             return JVMTI_ERROR_NO_MORE_FRAMES;
1842         case JDWP_ERROR(OPAQUE_FRAME):
1843             return JVMTI_ERROR_OPAQUE_FRAME;
1844         case JDWP_ERROR(NOT_CURRENT_FRAME):
1845             return AGENT_ERROR_NOT_CURRENT_FRAME;
1846         case JDWP_ERROR(TYPE_MISMATCH):
1847             return JVMTI_ERROR_TYPE_MISMATCH;
1848         case JDWP_ERROR(INVALID_SLOT):
1849             return JVMTI_ERROR_INVALID_SLOT;
1850         case JDWP_ERROR(DUPLICATE):
1851             return JVMTI_ERROR_DUPLICATE;
1852         case JDWP_ERROR(NOT_FOUND):
1853             return JVMTI_ERROR_NOT_FOUND;
1854         case JDWP_ERROR(INVALID_MONITOR):
1855             return JVMTI_ERROR_INVALID_MONITOR;
1856         case JDWP_ERROR(NOT_MONITOR_OWNER):
1857             return JVMTI_ERROR_NOT_MONITOR_OWNER;
1858         case JDWP_ERROR(INTERRUPT):
1859             return JVMTI_ERROR_INTERRUPT;
1860         case JDWP_ERROR(INVALID_CLASS_FORMAT):
1861             return JVMTI_ERROR_INVALID_CLASS_FORMAT;
1862         case JDWP_ERROR(CIRCULAR_CLASS_DEFINITION):
1863             return JVMTI_ERROR_CIRCULAR_CLASS_DEFINITION;
1864         case JDWP_ERROR(FAILS_VERIFICATION):
1865             return JVMTI_ERROR_FAILS_VERIFICATION;
1866         case JDWP_ERROR(ADD_METHOD_NOT_IMPLEMENTED):
1867             return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_ADDED;
1868         case JDWP_ERROR(SCHEMA_CHANGE_NOT_IMPLEMENTED):
1869             return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_SCHEMA_CHANGED;
1870         case JDWP_ERROR(INVALID_TYPESTATE):
1871             return JVMTI_ERROR_INVALID_TYPESTATE;
1872         case JDWP_ERROR(HIERARCHY_CHANGE_NOT_IMPLEMENTED):
1873             return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_HIERARCHY_CHANGED;
1874         case JDWP_ERROR(DELETE_METHOD_NOT_IMPLEMENTED):
1875             return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_DELETED;
1876         case JDWP_ERROR(UNSUPPORTED_VERSION):
1877             return JVMTI_ERROR_UNSUPPORTED_VERSION;
1878         case JDWP_ERROR(NAMES_DONT_MATCH):
1879             return JVMTI_ERROR_NAMES_DONT_MATCH;
1880         case JDWP_ERROR(CLASS_MODIFIERS_CHANGE_NOT_IMPLEMENTED):
1881             return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_MODIFIERS_CHANGED;
1882         case JDWP_ERROR(METHOD_MODIFIERS_CHANGE_NOT_IMPLEMENTED):
1883             return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_MODIFIERS_CHANGED;
1884         case JDWP_ERROR(CLASS_ATTRIBUTE_CHANGE_NOT_IMPLEMENTED):
1885             return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
1886         case JDWP_ERROR(NOT_IMPLEMENTED):
1887             return JVMTI_ERROR_NOT_AVAILABLE;
1888         case JDWP_ERROR(NULL_POINTER):
1889             return JVMTI_ERROR_NULL_POINTER;
1890         case JDWP_ERROR(ABSENT_INFORMATION):
1891             return JVMTI_ERROR_ABSENT_INFORMATION;
1892         case JDWP_ERROR(INVALID_EVENT_TYPE):
1893             return JVMTI_ERROR_INVALID_EVENT_TYPE;
1894         case JDWP_ERROR(ILLEGAL_ARGUMENT):
1895             return JVMTI_ERROR_ILLEGAL_ARGUMENT;
1896         case JDWP_ERROR(OUT_OF_MEMORY):
1897             return JVMTI_ERROR_OUT_OF_MEMORY;
1898         case JDWP_ERROR(ACCESS_DENIED):
1899             return JVMTI_ERROR_ACCESS_DENIED;
1900         case JDWP_ERROR(VM_DEAD):
1901             return JVMTI_ERROR_WRONG_PHASE;
1902         case JDWP_ERROR(UNATTACHED_THREAD):
1903             return JVMTI_ERROR_UNATTACHED_THREAD;
1904         case JDWP_ERROR(INVALID_TAG):
1905             return AGENT_ERROR_INVALID_TAG;
1906         case JDWP_ERROR(ALREADY_INVOKING):
1907             return AGENT_ERROR_ALREADY_INVOKING;
1908         case JDWP_ERROR(INVALID_INDEX):
1909             return AGENT_ERROR_INVALID_INDEX;
1910         case JDWP_ERROR(INVALID_LENGTH):
1911             return AGENT_ERROR_INVALID_LENGTH;
1912         case JDWP_ERROR(INVALID_STRING):
1913             return AGENT_ERROR_INVALID_STRING;
1914         case JDWP_ERROR(INVALID_CLASS_LOADER):
1915             return AGENT_ERROR_INVALID_CLASS_LOADER;
1916         case JDWP_ERROR(INVALID_ARRAY):
1917             return AGENT_ERROR_INVALID_ARRAY;
1918         case JDWP_ERROR(TRANSPORT_LOAD):
1919             return AGENT_ERROR_TRANSPORT_LOAD;
1920         case JDWP_ERROR(TRANSPORT_INIT):
1921             return AGENT_ERROR_TRANSPORT_INIT;
1922         case JDWP_ERROR(NATIVE_METHOD):
1923             return AGENT_ERROR_NATIVE_METHOD;
1924         case JDWP_ERROR(INVALID_COUNT):
1925             return AGENT_ERROR_INVALID_COUNT;
1926         case JDWP_ERROR(INTERNAL):
1927             return AGENT_ERROR_JDWP_INTERNAL;
1928     }
1929     return AGENT_ERROR_INTERNAL;
1930 }
1931 
1932 static jvmtiEvent index2jvmti[EI_max-EI_min+1];
1933 static jdwpEvent  index2jdwp [EI_max-EI_min+1];
1934 
1935 void
1936 eventIndexInit(void)
1937 {
1938     (void)memset(index2jvmti, 0, (int)sizeof(index2jvmti));
1939     (void)memset(index2jdwp,  0, (int)sizeof(index2jdwp));
1940 
1941     index2jvmti[EI_SINGLE_STEP        -EI_min] = JVMTI_EVENT_SINGLE_STEP;
1942     index2jvmti[EI_BREAKPOINT         -EI_min] = JVMTI_EVENT_BREAKPOINT;
1943     index2jvmti[EI_FRAME_POP          -EI_min] = JVMTI_EVENT_FRAME_POP;
1944     index2jvmti[EI_EXCEPTION          -EI_min] = JVMTI_EVENT_EXCEPTION;
1945     index2jvmti[EI_THREAD_START       -EI_min] = JVMTI_EVENT_THREAD_START;
1946     index2jvmti[EI_THREAD_END         -EI_min] = JVMTI_EVENT_THREAD_END;
1947     index2jvmti[EI_CLASS_PREPARE      -EI_min] = JVMTI_EVENT_CLASS_PREPARE;
1948     index2jvmti[EI_GC_FINISH          -EI_min] = JVMTI_EVENT_GARBAGE_COLLECTION_FINISH;
1949     index2jvmti[EI_CLASS_LOAD         -EI_min] = JVMTI_EVENT_CLASS_LOAD;
1950     index2jvmti[EI_FIELD_ACCESS       -EI_min] = JVMTI_EVENT_FIELD_ACCESS;
1951     index2jvmti[EI_FIELD_MODIFICATION -EI_min] = JVMTI_EVENT_FIELD_MODIFICATION;
1952     index2jvmti[EI_EXCEPTION_CATCH    -EI_min] = JVMTI_EVENT_EXCEPTION_CATCH;
1953     index2jvmti[EI_METHOD_ENTRY       -EI_min] = JVMTI_EVENT_METHOD_ENTRY;
1954     index2jvmti[EI_METHOD_EXIT        -EI_min] = JVMTI_EVENT_METHOD_EXIT;
1955     index2jvmti[EI_MONITOR_CONTENDED_ENTER      -EI_min] = JVMTI_EVENT_MONITOR_CONTENDED_ENTER;
1956     index2jvmti[EI_MONITOR_CONTENDED_ENTERED    -EI_min] = JVMTI_EVENT_MONITOR_CONTENDED_ENTERED;
1957     index2jvmti[EI_MONITOR_WAIT       -EI_min] = JVMTI_EVENT_MONITOR_WAIT;
1958     index2jvmti[EI_MONITOR_WAITED     -EI_min] = JVMTI_EVENT_MONITOR_WAITED;
1959     index2jvmti[EI_VM_INIT            -EI_min] = JVMTI_EVENT_VM_INIT;
1960     index2jvmti[EI_VM_DEATH           -EI_min] = JVMTI_EVENT_VM_DEATH;
1961 
1962     index2jdwp[EI_SINGLE_STEP         -EI_min] = JDWP_EVENT(SINGLE_STEP);
1963     index2jdwp[EI_BREAKPOINT          -EI_min] = JDWP_EVENT(BREAKPOINT);
1964     index2jdwp[EI_FRAME_POP           -EI_min] = JDWP_EVENT(FRAME_POP);
1965     index2jdwp[EI_EXCEPTION           -EI_min] = JDWP_EVENT(EXCEPTION);
1966     index2jdwp[EI_THREAD_START        -EI_min] = JDWP_EVENT(THREAD_START);
1967     index2jdwp[EI_THREAD_END          -EI_min] = JDWP_EVENT(THREAD_END);
1968     index2jdwp[EI_CLASS_PREPARE       -EI_min] = JDWP_EVENT(CLASS_PREPARE);
1969     index2jdwp[EI_GC_FINISH           -EI_min] = JDWP_EVENT(CLASS_UNLOAD);
1970     index2jdwp[EI_CLASS_LOAD          -EI_min] = JDWP_EVENT(CLASS_LOAD);
1971     index2jdwp[EI_FIELD_ACCESS        -EI_min] = JDWP_EVENT(FIELD_ACCESS);
1972     index2jdwp[EI_FIELD_MODIFICATION  -EI_min] = JDWP_EVENT(FIELD_MODIFICATION);
1973     index2jdwp[EI_EXCEPTION_CATCH     -EI_min] = JDWP_EVENT(EXCEPTION_CATCH);
1974     index2jdwp[EI_METHOD_ENTRY        -EI_min] = JDWP_EVENT(METHOD_ENTRY);
1975     index2jdwp[EI_METHOD_EXIT         -EI_min] = JDWP_EVENT(METHOD_EXIT);
1976     index2jdwp[EI_MONITOR_CONTENDED_ENTER             -EI_min] = JDWP_EVENT(MONITOR_CONTENDED_ENTER);
1977     index2jdwp[EI_MONITOR_CONTENDED_ENTERED           -EI_min] = JDWP_EVENT(MONITOR_CONTENDED_ENTERED);
1978     index2jdwp[EI_MONITOR_WAIT        -EI_min] = JDWP_EVENT(MONITOR_WAIT);
1979     index2jdwp[EI_MONITOR_WAITED      -EI_min] = JDWP_EVENT(MONITOR_WAITED);
1980     index2jdwp[EI_VM_INIT             -EI_min] = JDWP_EVENT(VM_INIT);
1981     index2jdwp[EI_VM_DEATH            -EI_min] = JDWP_EVENT(VM_DEATH);
1982 }
1983 
1984 jdwpEvent
1985 eventIndex2jdwp(EventIndex i)
1986 {
1987     if ( i &lt; EI_min || i &gt; EI_max ) {
1988         EXIT_ERROR(AGENT_ERROR_INVALID_INDEX,&quot;bad EventIndex&quot;);
1989     }
1990     return index2jdwp[i-EI_min];
1991 }
1992 
1993 jvmtiEvent
1994 eventIndex2jvmti(EventIndex i)
1995 {
1996     if ( i &lt; EI_min || i &gt; EI_max ) {
1997         EXIT_ERROR(AGENT_ERROR_INVALID_INDEX,&quot;bad EventIndex&quot;);
1998     }
1999     return index2jvmti[i-EI_min];
2000 }
2001 
2002 EventIndex
2003 jdwp2EventIndex(jdwpEvent eventType)
2004 {
2005     switch ( eventType ) {
2006         case JDWP_EVENT(SINGLE_STEP):
2007             return EI_SINGLE_STEP;
2008         case JDWP_EVENT(BREAKPOINT):
2009             return EI_BREAKPOINT;
2010         case JDWP_EVENT(FRAME_POP):
2011             return EI_FRAME_POP;
2012         case JDWP_EVENT(EXCEPTION):
2013             return EI_EXCEPTION;
2014         case JDWP_EVENT(THREAD_START):
2015             return EI_THREAD_START;
2016         case JDWP_EVENT(THREAD_END):
2017             return EI_THREAD_END;
2018         case JDWP_EVENT(CLASS_PREPARE):
2019             return EI_CLASS_PREPARE;
2020         case JDWP_EVENT(CLASS_UNLOAD):
2021             return EI_GC_FINISH;
2022         case JDWP_EVENT(CLASS_LOAD):
2023             return EI_CLASS_LOAD;
2024         case JDWP_EVENT(FIELD_ACCESS):
2025             return EI_FIELD_ACCESS;
2026         case JDWP_EVENT(FIELD_MODIFICATION):
2027             return EI_FIELD_MODIFICATION;
2028         case JDWP_EVENT(EXCEPTION_CATCH):
2029             return EI_EXCEPTION_CATCH;
2030         case JDWP_EVENT(METHOD_ENTRY):
2031             return EI_METHOD_ENTRY;
2032         case JDWP_EVENT(METHOD_EXIT):
2033             return EI_METHOD_EXIT;
2034         case JDWP_EVENT(METHOD_EXIT_WITH_RETURN_VALUE):
2035             return EI_METHOD_EXIT;
2036         case JDWP_EVENT(MONITOR_CONTENDED_ENTER):
2037             return EI_MONITOR_CONTENDED_ENTER;
2038         case JDWP_EVENT(MONITOR_CONTENDED_ENTERED):
2039             return EI_MONITOR_CONTENDED_ENTERED;
2040         case JDWP_EVENT(MONITOR_WAIT):
2041             return EI_MONITOR_WAIT;
2042         case JDWP_EVENT(MONITOR_WAITED):
2043             return EI_MONITOR_WAITED;
2044         case JDWP_EVENT(VM_INIT):
2045             return EI_VM_INIT;
2046         case JDWP_EVENT(VM_DEATH):
2047             return EI_VM_DEATH;
2048         default:
2049             break;
2050     }
2051 
2052     /*
2053      * Event type not recognized - don&#39;t exit with error as caller
2054      * may wish to return error to debugger.
2055      */
2056     return (EventIndex)0;
2057 }
2058 
2059 EventIndex
2060 jvmti2EventIndex(jvmtiEvent kind)
2061 {
2062     switch ( kind ) {
2063         case JVMTI_EVENT_SINGLE_STEP:
2064             return EI_SINGLE_STEP;
2065         case JVMTI_EVENT_BREAKPOINT:
2066             return EI_BREAKPOINT;
2067         case JVMTI_EVENT_FRAME_POP:
2068             return EI_FRAME_POP;
2069         case JVMTI_EVENT_EXCEPTION:
2070             return EI_EXCEPTION;
2071         case JVMTI_EVENT_THREAD_START:
2072             return EI_THREAD_START;
2073         case JVMTI_EVENT_THREAD_END:
2074             return EI_THREAD_END;
2075         case JVMTI_EVENT_CLASS_PREPARE:
2076             return EI_CLASS_PREPARE;
2077         case JVMTI_EVENT_GARBAGE_COLLECTION_FINISH:
2078             return EI_GC_FINISH;
2079         case JVMTI_EVENT_CLASS_LOAD:
2080             return EI_CLASS_LOAD;
2081         case JVMTI_EVENT_FIELD_ACCESS:
2082             return EI_FIELD_ACCESS;
2083         case JVMTI_EVENT_FIELD_MODIFICATION:
2084             return EI_FIELD_MODIFICATION;
2085         case JVMTI_EVENT_EXCEPTION_CATCH:
2086             return EI_EXCEPTION_CATCH;
2087         case JVMTI_EVENT_METHOD_ENTRY:
2088             return EI_METHOD_ENTRY;
2089         case JVMTI_EVENT_METHOD_EXIT:
2090             return EI_METHOD_EXIT;
2091         /*
2092          * There is no JVMTI_EVENT_METHOD_EXIT_WITH_RETURN_VALUE.
2093          * The normal JVMTI_EVENT_METHOD_EXIT always contains the return value.
2094          */
2095         case JVMTI_EVENT_MONITOR_CONTENDED_ENTER:
2096             return EI_MONITOR_CONTENDED_ENTER;
2097         case JVMTI_EVENT_MONITOR_CONTENDED_ENTERED:
2098             return EI_MONITOR_CONTENDED_ENTERED;
2099         case JVMTI_EVENT_MONITOR_WAIT:
2100             return EI_MONITOR_WAIT;
2101         case JVMTI_EVENT_MONITOR_WAITED:
2102             return EI_MONITOR_WAITED;
2103         case JVMTI_EVENT_VM_INIT:
2104             return EI_VM_INIT;
2105         case JVMTI_EVENT_VM_DEATH:
2106             return EI_VM_DEATH;
2107         default:
2108             EXIT_ERROR(AGENT_ERROR_INVALID_INDEX,&quot;JVMTI to EventIndex mapping&quot;);
2109             break;
2110     }
2111     return (EventIndex)0;
2112 }
2113 
2114 /* This routine is commonly used, maps jvmti and agent errors to the best
2115  *    jdwp error code we can map to.
2116  */
2117 jdwpError
2118 map2jdwpError(jvmtiError error)
2119 {
2120     switch ( (int)error ) {
2121         case JVMTI_ERROR_NONE:
2122             return JDWP_ERROR(NONE);
2123         case AGENT_ERROR_INVALID_THREAD:
2124         case JVMTI_ERROR_INVALID_THREAD:
2125             return JDWP_ERROR(INVALID_THREAD);
2126         case JVMTI_ERROR_INVALID_THREAD_GROUP:
2127             return JDWP_ERROR(INVALID_THREAD_GROUP);
2128         case JVMTI_ERROR_INVALID_PRIORITY:
2129             return JDWP_ERROR(INVALID_PRIORITY);
2130         case JVMTI_ERROR_THREAD_NOT_SUSPENDED:
2131             return JDWP_ERROR(THREAD_NOT_SUSPENDED);
2132         case JVMTI_ERROR_THREAD_SUSPENDED:
2133             return JDWP_ERROR(THREAD_SUSPENDED);
2134         case JVMTI_ERROR_THREAD_NOT_ALIVE:
2135             return JDWP_ERROR(INVALID_THREAD);
2136         case AGENT_ERROR_INVALID_OBJECT:
2137         case JVMTI_ERROR_INVALID_OBJECT:
2138             return JDWP_ERROR(INVALID_OBJECT);
2139         case JVMTI_ERROR_INVALID_CLASS:
2140             return JDWP_ERROR(INVALID_CLASS);
2141         case JVMTI_ERROR_CLASS_NOT_PREPARED:
2142             return JDWP_ERROR(CLASS_NOT_PREPARED);
2143         case JVMTI_ERROR_INVALID_METHODID:
2144             return JDWP_ERROR(INVALID_METHODID);
2145         case JVMTI_ERROR_INVALID_LOCATION:
2146             return JDWP_ERROR(INVALID_LOCATION);
2147         case JVMTI_ERROR_INVALID_FIELDID:
2148             return JDWP_ERROR(INVALID_FIELDID);
2149         case AGENT_ERROR_NO_MORE_FRAMES:
2150         case JVMTI_ERROR_NO_MORE_FRAMES:
2151             return JDWP_ERROR(NO_MORE_FRAMES);
2152         case JVMTI_ERROR_OPAQUE_FRAME:
2153             return JDWP_ERROR(OPAQUE_FRAME);
2154         case JVMTI_ERROR_TYPE_MISMATCH:
2155             return JDWP_ERROR(TYPE_MISMATCH);
2156         case JVMTI_ERROR_INVALID_SLOT:
2157             return JDWP_ERROR(INVALID_SLOT);
2158         case JVMTI_ERROR_DUPLICATE:
2159             return JDWP_ERROR(DUPLICATE);
2160         case JVMTI_ERROR_NOT_FOUND:
2161             return JDWP_ERROR(NOT_FOUND);
2162         case JVMTI_ERROR_INVALID_MONITOR:
2163             return JDWP_ERROR(INVALID_MONITOR);
2164         case JVMTI_ERROR_NOT_MONITOR_OWNER:
2165             return JDWP_ERROR(NOT_MONITOR_OWNER);
2166         case JVMTI_ERROR_INTERRUPT:
2167             return JDWP_ERROR(INTERRUPT);
2168         case JVMTI_ERROR_INVALID_CLASS_FORMAT:
2169             return JDWP_ERROR(INVALID_CLASS_FORMAT);
2170         case JVMTI_ERROR_CIRCULAR_CLASS_DEFINITION:
2171             return JDWP_ERROR(CIRCULAR_CLASS_DEFINITION);
2172         case JVMTI_ERROR_FAILS_VERIFICATION:
2173             return JDWP_ERROR(FAILS_VERIFICATION);
2174         case JVMTI_ERROR_INVALID_TYPESTATE:
2175             return JDWP_ERROR(INVALID_TYPESTATE);
2176         case JVMTI_ERROR_UNSUPPORTED_VERSION:
2177             return JDWP_ERROR(UNSUPPORTED_VERSION);
2178         case JVMTI_ERROR_NAMES_DONT_MATCH:
2179             return JDWP_ERROR(NAMES_DONT_MATCH);
2180         case AGENT_ERROR_NULL_POINTER:
2181         case JVMTI_ERROR_NULL_POINTER:
2182             return JDWP_ERROR(NULL_POINTER);
2183         case JVMTI_ERROR_ABSENT_INFORMATION:
2184             return JDWP_ERROR(ABSENT_INFORMATION);
2185         case AGENT_ERROR_INVALID_EVENT_TYPE:
2186         case JVMTI_ERROR_INVALID_EVENT_TYPE:
2187             return JDWP_ERROR(INVALID_EVENT_TYPE);
2188         case AGENT_ERROR_ILLEGAL_ARGUMENT:
2189         case JVMTI_ERROR_ILLEGAL_ARGUMENT:
2190             return JDWP_ERROR(ILLEGAL_ARGUMENT);
2191         case JVMTI_ERROR_OUT_OF_MEMORY:
2192         case AGENT_ERROR_OUT_OF_MEMORY:
2193             return JDWP_ERROR(OUT_OF_MEMORY);
2194         case JVMTI_ERROR_ACCESS_DENIED:
2195             return JDWP_ERROR(ACCESS_DENIED);
2196         case JVMTI_ERROR_WRONG_PHASE:
2197         case AGENT_ERROR_VM_DEAD:
2198         case AGENT_ERROR_NO_JNI_ENV:
2199             return JDWP_ERROR(VM_DEAD);
2200         case AGENT_ERROR_JNI_EXCEPTION:
2201         case JVMTI_ERROR_UNATTACHED_THREAD:
2202             return JDWP_ERROR(UNATTACHED_THREAD);
2203         case JVMTI_ERROR_NOT_AVAILABLE:
2204         case JVMTI_ERROR_MUST_POSSESS_CAPABILITY:
2205             return JDWP_ERROR(NOT_IMPLEMENTED);
2206         case JVMTI_ERROR_UNSUPPORTED_REDEFINITION_HIERARCHY_CHANGED:
2207             return JDWP_ERROR(HIERARCHY_CHANGE_NOT_IMPLEMENTED);
2208         case JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_DELETED:
2209             return JDWP_ERROR(DELETE_METHOD_NOT_IMPLEMENTED);
2210         case JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_ADDED:
2211             return JDWP_ERROR(ADD_METHOD_NOT_IMPLEMENTED);
2212         case JVMTI_ERROR_UNSUPPORTED_REDEFINITION_SCHEMA_CHANGED:
2213             return JDWP_ERROR(SCHEMA_CHANGE_NOT_IMPLEMENTED);
2214         case JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_MODIFIERS_CHANGED:
2215             return JDWP_ERROR(CLASS_MODIFIERS_CHANGE_NOT_IMPLEMENTED);
2216         case JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_MODIFIERS_CHANGED:
2217             return JDWP_ERROR(METHOD_MODIFIERS_CHANGE_NOT_IMPLEMENTED);
2218         case JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED:
2219             return JDWP_ERROR(CLASS_ATTRIBUTE_CHANGE_NOT_IMPLEMENTED);
2220         case AGENT_ERROR_NOT_CURRENT_FRAME:
2221             return JDWP_ERROR(NOT_CURRENT_FRAME);
2222         case AGENT_ERROR_INVALID_TAG:
2223             return JDWP_ERROR(INVALID_TAG);
2224         case AGENT_ERROR_ALREADY_INVOKING:
2225             return JDWP_ERROR(ALREADY_INVOKING);
2226         case AGENT_ERROR_INVALID_INDEX:
2227             return JDWP_ERROR(INVALID_INDEX);
2228         case AGENT_ERROR_INVALID_LENGTH:
2229             return JDWP_ERROR(INVALID_LENGTH);
2230         case AGENT_ERROR_INVALID_STRING:
2231             return JDWP_ERROR(INVALID_STRING);
2232         case AGENT_ERROR_INVALID_CLASS_LOADER:
2233             return JDWP_ERROR(INVALID_CLASS_LOADER);
2234         case AGENT_ERROR_INVALID_ARRAY:
2235             return JDWP_ERROR(INVALID_ARRAY);
2236         case AGENT_ERROR_TRANSPORT_LOAD:
2237             return JDWP_ERROR(TRANSPORT_LOAD);
2238         case AGENT_ERROR_TRANSPORT_INIT:
2239             return JDWP_ERROR(TRANSPORT_INIT);
2240         case AGENT_ERROR_NATIVE_METHOD:
2241             return JDWP_ERROR(NATIVE_METHOD);
2242         case AGENT_ERROR_INVALID_COUNT:
2243             return JDWP_ERROR(INVALID_COUNT);
2244         case AGENT_ERROR_INVALID_FRAMEID:
2245             return JDWP_ERROR(INVALID_FRAMEID);
2246         case JVMTI_ERROR_INTERNAL:
2247         case JVMTI_ERROR_INVALID_ENVIRONMENT:
2248         case AGENT_ERROR_INTERNAL:
2249         case AGENT_ERROR_JVMTI_INTERNAL:
2250         case AGENT_ERROR_JDWP_INTERNAL:
2251             return JDWP_ERROR(INTERNAL);
2252         default:
2253             break;
2254     }
2255     return JDWP_ERROR(INTERNAL);
2256 }
2257 
2258 jint
2259 map2jdwpSuspendStatus(jint state)
2260 {
2261     jint status = 0;
2262     if ( ( state &amp; JVMTI_THREAD_STATE_SUSPENDED ) != 0 )  {
2263         status = JDWP_SUSPEND_STATUS(SUSPENDED);
2264     }
2265     return status;
2266 }
2267 
2268 jdwpThreadStatus
2269 map2jdwpThreadStatus(jint state)
2270 {
2271     jdwpThreadStatus status;
2272 
2273     status = (jdwpThreadStatus)(-1);
2274 
2275     if ( ! ( state &amp; JVMTI_THREAD_STATE_ALIVE ) ) {
2276         if ( state &amp; JVMTI_THREAD_STATE_TERMINATED ) {
2277             status = JDWP_THREAD_STATUS(ZOMBIE);
2278         } else {
2279             /* FIXUP? New JDWP #define for not started? */
2280             status = (jdwpThreadStatus)(-1);
2281         }
2282     } else {
2283         if ( state &amp; JVMTI_THREAD_STATE_SLEEPING ) {
2284             status = JDWP_THREAD_STATUS(SLEEPING);
2285         } else if ( state &amp; JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER ) {
2286             status = JDWP_THREAD_STATUS(MONITOR);
2287         } else if ( state &amp; JVMTI_THREAD_STATE_WAITING ) {
2288             status = JDWP_THREAD_STATUS(WAIT);
2289         } else if ( state &amp; JVMTI_THREAD_STATE_RUNNABLE ) {
2290             status = JDWP_THREAD_STATUS(RUNNING);
2291         }
2292     }
2293     return status;
2294 }
2295 
2296 jint
2297 map2jdwpClassStatus(jint classStatus)
2298 {
2299     jint status = 0;
2300     if ( ( classStatus &amp; JVMTI_CLASS_STATUS_VERIFIED ) != 0 ) {
2301         status |= JDWP_CLASS_STATUS(VERIFIED);
2302     }
2303     if ( ( classStatus &amp; JVMTI_CLASS_STATUS_PREPARED ) != 0 ) {
2304         status |= JDWP_CLASS_STATUS(PREPARED);
2305     }
2306     if ( ( classStatus &amp; JVMTI_CLASS_STATUS_INITIALIZED ) != 0 ) {
2307         status |= JDWP_CLASS_STATUS(INITIALIZED);
2308     }
2309     if ( ( classStatus &amp; JVMTI_CLASS_STATUS_ERROR ) != 0 ) {
2310         status |= JDWP_CLASS_STATUS(ERROR);
2311     }
2312     return status;
2313 }
2314 
2315 void
2316 log_debugee_location(const char *func,
2317         jthread thread, jmethodID method, jlocation location)
2318 {
2319     int logging_locations = LOG_TEST(JDWP_LOG_LOC);
2320 
2321     if ( logging_locations ) {
2322         char *method_name;
2323         char *class_sig;
2324         jvmtiError error;
2325         jvmtiThreadInfo info;
2326         jint state;
2327 
2328         /* Get thread information */
2329         info.name = NULL;
2330         error = FUNC_PTR(gdata-&gt;jvmti,GetThreadInfo)
2331                                 (gdata-&gt;jvmti, thread, &amp;info);
2332         if ( error != JVMTI_ERROR_NONE) {
2333             info.name = NULL;
2334         }
2335         error = FUNC_PTR(gdata-&gt;jvmti,GetThreadState)
2336                                 (gdata-&gt;jvmti, thread, &amp;state);
2337         if ( error != JVMTI_ERROR_NONE) {
2338             state = 0;
2339         }
2340 
2341         /* Get method if necessary */
2342         if ( method==NULL ) {
2343             error = FUNC_PTR(gdata-&gt;jvmti,GetFrameLocation)
2344                         (gdata-&gt;jvmti, thread, 0, &amp;method, &amp;location);
2345             if ( error != JVMTI_ERROR_NONE ) {
2346                 method = NULL;
2347                 location = 0;
2348             }
2349         }
2350 
2351         /* Get method name */
2352         method_name = NULL;
2353         if ( method != NULL ) {
2354             error = methodSignature(method, &amp;method_name, NULL, NULL);
2355             if ( error != JVMTI_ERROR_NONE ) {
2356                 method_name = NULL;
2357             }
2358         }
2359 
2360         /* Get class signature */
2361         class_sig = NULL;
2362         if ( method != NULL ) {
2363             jclass clazz;
2364 
2365             error = methodClass(method, &amp;clazz);
2366             if ( error == JVMTI_ERROR_NONE ) {
2367                 error = classSignature(clazz, &amp;class_sig, NULL);
2368                 if ( error != JVMTI_ERROR_NONE ) {
2369                     class_sig = NULL;
2370                 }
2371             }
2372         }
2373 
2374         /* Issue log message */
2375         LOG_LOC((&quot;%s: debugee: thread=%p(%s:0x%x),method=%p(%s@%d;%s)&quot;,
2376                 func,
2377                 thread, info.name==NULL ? &quot;?&quot; : info.name, state,
2378                 method, method_name==NULL ? &quot;?&quot; : method_name,
2379                 (int)location, class_sig==NULL ? &quot;?&quot; : class_sig));
2380 
2381         /* Free memory */
2382         if ( class_sig != NULL ) {
2383             jvmtiDeallocate(class_sig);
2384         }
2385         if ( method_name != NULL ) {
2386             jvmtiDeallocate(method_name);
2387         }
2388         if ( info.name != NULL ) {
2389             jvmtiDeallocate(info.name);
2390         }
2391     }
2392 }
2393 
2394 /* ********************************************************************* */
2395 /* JDK 6.0: Use of new Heap Iteration functions */
2396 /* ********************************************************************* */
2397 
2398 /* ********************************************************************* */
2399 /* Instances */
2400 
2401 /* Structure to hold class instances heap iteration data (arg user_data) */
2402 typedef struct ClassInstancesData {
2403     jint         instCount;
2404     jint         maxInstances;
2405     jlong        objTag;
2406     jvmtiError   error;
2407 } ClassInstancesData;
2408 
2409 /* Callback for instance object tagging (heap_reference_callback). */
2410 static jint JNICALL
2411 cbObjectTagInstance(jvmtiHeapReferenceKind reference_kind,
2412      const jvmtiHeapReferenceInfo* reference_info, jlong class_tag,
2413      jlong referrer_class_tag, jlong size,
2414      jlong* tag_ptr, jlong* referrer_tag_ptr, jint length, void* user_data)
2415 {
2416     ClassInstancesData  *data;
2417 
2418     /* Check data structure */
2419     data = (ClassInstancesData*)user_data;
2420     if (data == NULL) {
2421         return JVMTI_VISIT_ABORT;
2422     }
2423 
2424     /* If we have tagged enough objects, just abort */
2425     if ( data-&gt;maxInstances != 0 &amp;&amp; data-&gt;instCount &gt;= data-&gt;maxInstances ) {
2426         return JVMTI_VISIT_ABORT;
2427     }
2428 
2429     /* If tagged already, just continue */
2430     if ( (*tag_ptr) != (jlong)0 ) {
2431         return JVMTI_VISIT_OBJECTS;
2432     }
2433 
2434     /* Tag the object so we don&#39;t count it again, and so we can retrieve it */
2435     (*tag_ptr) = data-&gt;objTag;
2436     data-&gt;instCount++;
2437     return JVMTI_VISIT_OBJECTS;
2438 }
2439 
2440 /* Get instances for one class */
2441 jvmtiError
2442 classInstances(jclass klass, ObjectBatch *instances, int maxInstances)
2443 {
2444     ClassInstancesData data;
2445     jvmtiHeapCallbacks heap_callbacks;
2446     jvmtiError         error;
2447     jvmtiEnv          *jvmti;
2448 
2449     /* Check interface assumptions */
2450 
2451     if (klass == NULL) {
2452         return AGENT_ERROR_INVALID_OBJECT;
2453     }
2454 
2455     if ( maxInstances &lt; 0 || instances == NULL) {
2456         return AGENT_ERROR_ILLEGAL_ARGUMENT;
2457     }
2458 
2459     /* Initialize return information */
2460     instances-&gt;count   = 0;
2461     instances-&gt;objects = NULL;
2462 
2463     /* Get jvmti environment to use */
2464     jvmti = getSpecialJvmti();
2465     if ( jvmti == NULL ) {
2466         return AGENT_ERROR_INTERNAL;
2467     }
2468 
2469     /* Setup data to passed around the callbacks */
2470     data.instCount    = 0;
2471     data.maxInstances = maxInstances;
2472     data.objTag       = (jlong)1;
2473     data.error        = JVMTI_ERROR_NONE;
2474 
2475     /* Clear out callbacks structure */
2476     (void)memset(&amp;heap_callbacks,0,sizeof(heap_callbacks));
2477 
2478     /* Set the callbacks we want */
2479     heap_callbacks.heap_reference_callback = &amp;cbObjectTagInstance;
2480 
2481     /* Follow references, no initiating object, just this class, all objects */
2482     error = JVMTI_FUNC_PTR(jvmti,FollowReferences)
2483                  (jvmti, 0, klass, NULL, &amp;heap_callbacks, &amp;data);
2484     if ( error == JVMTI_ERROR_NONE ) {
2485         error = data.error;
2486     }
2487 
2488     /* Get all the instances now that they are tagged */
2489     if ( error == JVMTI_ERROR_NONE ) {
2490         error = JVMTI_FUNC_PTR(jvmti,GetObjectsWithTags)
2491                       (jvmti, 1, &amp;(data.objTag), &amp;(instances-&gt;count),
2492                        &amp;(instances-&gt;objects), NULL);
2493         /* Verify we got the count we expected */
2494         if ( data.instCount != instances-&gt;count ) {
2495             error = AGENT_ERROR_INTERNAL;
2496         }
2497     }
2498 
2499     /* Dispose of any special jvmti environment */
2500     (void)JVMTI_FUNC_PTR(jvmti,DisposeEnvironment)(jvmti);
2501     return error;
2502 }
2503 
2504 /* ********************************************************************* */
2505 /* Instance counts. */
2506 
2507 /* Macros to convert a class or instance tag to an index and back again */
2508 #define INDEX2CLASSTAG(i)      ((jlong)((i)+1))
2509 #define CLASSTAG2INDEX(t)      (((int)(t))-1)
2510 #define JLONG_ABS(x)           (((x)&lt;(jlong)0)?-(x):(x))
2511 
2512 /* Structure to hold class count heap traversal data (arg user_data) */
2513 typedef struct ClassCountData {
2514     int          classCount;
2515     jlong       *counts;
2516     jlong        negObjTag;
2517     jvmtiError   error;
2518 } ClassCountData;
2519 
2520 /* Two different cbObjectCounter&#39;s, one for FollowReferences, one for
2521  *    IterateThroughHeap. Pick a card, any card.
2522  */
2523 
2524 /* Callback for object count heap traversal (heap_reference_callback) */
2525 static jint JNICALL
2526 cbObjectCounterFromRef(jvmtiHeapReferenceKind reference_kind,
2527      const jvmtiHeapReferenceInfo* reference_info, jlong class_tag,
2528      jlong referrer_class_tag, jlong size,
2529      jlong* tag_ptr, jlong* referrer_tag_ptr, jint length, void* user_data)
2530 {
2531     ClassCountData  *data;
2532     int              index;
2533     jlong            jindex;
2534     jlong            tag;
2535 
2536     /* Check data structure */
2537     data = (ClassCountData*)user_data;
2538     if (data == NULL) {
2539         return JVMTI_VISIT_ABORT;
2540     }
2541 
2542     /* Classes with no class_tag should have been filtered out. */
2543     if ( class_tag == (jlong)0 ) {
2544         data-&gt;error = AGENT_ERROR_INTERNAL;
2545         return JVMTI_VISIT_ABORT;
2546     }
2547 
2548     /* Class tag not one we really want (jclass not in supplied list) */
2549     if ( class_tag == data-&gt;negObjTag ) {
2550         return JVMTI_VISIT_OBJECTS;
2551     }
2552 
2553     /* If object tag is negative, just continue, we counted it */
2554     tag = (*tag_ptr);
2555     if ( tag &lt; (jlong)0 ) {
2556         return JVMTI_VISIT_OBJECTS;
2557     }
2558 
2559     /* Tag the object with a negative value just so we don&#39;t count it again */
2560     if ( tag == (jlong)0 ) {
2561         /* This object had no tag value, so we give it the negObjTag value */
2562         (*tag_ptr) = data-&gt;negObjTag;
2563     } else {
2564         /* If this object had a positive tag value, it must be one of the
2565          *    jclass objects we tagged. We need to preserve the value of
2566          *    this tag for later objects that might have this as a class
2567          *    tag, so we just make the existing tag value negative.
2568          */
2569         (*tag_ptr) = -tag;
2570     }
2571 
2572     /* Absolute value of class tag is an index into the counts[] array */
2573     jindex = JLONG_ABS(class_tag);
2574     index = CLASSTAG2INDEX(jindex);
2575     if (index &lt; 0 || index &gt;= data-&gt;classCount) {
2576         data-&gt;error = AGENT_ERROR_ILLEGAL_ARGUMENT;
2577         return JVMTI_VISIT_ABORT;
2578     }
2579 
2580     /* Bump instance count on this class */
2581     data-&gt;counts[index]++;
2582     return JVMTI_VISIT_OBJECTS;
2583 }
2584 
2585 /* Callback for instance count heap traversal (heap_iteration_callback) */
2586 static jint JNICALL
2587 cbObjectCounter(jlong class_tag, jlong size, jlong* tag_ptr, jint length,
2588                         void* user_data)
2589 {
2590     ClassCountData  *data;
2591     int              index;
2592 
2593     /* Check data structure */
2594     data = (ClassCountData*)user_data;
2595     if (data == NULL) {
2596         return JVMTI_VISIT_ABORT;
2597     }
2598 
2599     /* Classes with no tag should be filtered out. */
2600     if ( class_tag == (jlong)0 ) {
2601         data-&gt;error = AGENT_ERROR_INTERNAL;
2602         return JVMTI_VISIT_ABORT;
2603     }
2604 
2605     /* Class tag is actually an index into data arrays */
2606     index = CLASSTAG2INDEX(class_tag);
2607     if (index &lt; 0 || index &gt;= data-&gt;classCount) {
2608         data-&gt;error = AGENT_ERROR_ILLEGAL_ARGUMENT;
2609         return JVMTI_VISIT_ABORT;
2610     }
2611 
2612     /* Bump instance count on this class */
2613     data-&gt;counts[index]++;
2614     return JVMTI_VISIT_OBJECTS;
2615 }
2616 
2617 /* Get instance counts for a set of classes */
2618 jvmtiError
2619 classInstanceCounts(jint classCount, jclass *classes, jlong *counts)
2620 {
2621     jvmtiHeapCallbacks heap_callbacks;
2622     ClassCountData     data;
2623     jvmtiError         error;
2624     jvmtiEnv          *jvmti;
2625     int                i;
2626 
2627     /* Check interface assumptions */
2628     if ( classes == NULL || classCount &lt;= 0 || counts == NULL ) {
2629         return AGENT_ERROR_ILLEGAL_ARGUMENT;
2630     }
2631 
2632     /* Initialize return information */
2633     for ( i = 0 ; i &lt; classCount ; i++ ) {
2634         counts[i] = (jlong)0;
2635     }
2636 
2637     /* Get jvmti environment to use */
2638     jvmti = getSpecialJvmti();
2639     if ( jvmti == NULL ) {
2640         return AGENT_ERROR_INTERNAL;
2641     }
2642 
2643     /* Setup class data structure */
2644     data.error        = JVMTI_ERROR_NONE;
2645     data.classCount   = classCount;
2646     data.counts       = counts;
2647 
2648     error = JVMTI_ERROR_NONE;
2649     /* Set tags on classes, use index in classes[] as the tag value. */
2650     error             = JVMTI_ERROR_NONE;
2651     for ( i = 0 ; i &lt; classCount ; i++ ) {
2652         if (classes[i] != NULL) {
2653             jlong tag;
2654 
2655             tag = INDEX2CLASSTAG(i);
2656             error = JVMTI_FUNC_PTR(jvmti,SetTag) (jvmti, classes[i], tag);
2657             if ( error != JVMTI_ERROR_NONE ) {
2658                 break;
2659             }
2660         }
2661     }
2662 
2663     /* Traverse heap, two ways to do this for instance counts. */
2664     if ( error == JVMTI_ERROR_NONE ) {
2665 
2666         /* Clear out callbacks structure */
2667         (void)memset(&amp;heap_callbacks,0,sizeof(heap_callbacks));
2668 
2669         /* Check debug flags to see how to do this. */
2670         if ( (gdata-&gt;debugflags &amp; USE_ITERATE_THROUGH_HEAP) == 0 ) {
2671 
2672             /* Using FollowReferences only gives us live objects, but we
2673              *   need to tag the objects to avoid counting them twice since
2674              *   the callback is per reference.
2675              *   The jclass objects have been tagged with their index in the
2676              *   supplied list, and that tag may flip to negative if it
2677              *   is also an object of interest.
2678              *   All other objects being counted that weren&#39;t in the
2679              *   supplied classes list will have a negative classCount
2680              *   tag value. So all objects counted will have negative tags.
2681              *   If the absolute tag value is an index in the supplied
2682              *   list, then it&#39;s one of the supplied classes.
2683              */
2684             data.negObjTag = -INDEX2CLASSTAG(classCount);
2685 
2686             /* Setup callbacks, only using object reference callback */
2687             heap_callbacks.heap_reference_callback = &amp;cbObjectCounterFromRef;
2688 
2689             /* Follow references, no initiating object, tagged classes only */
2690             error = JVMTI_FUNC_PTR(jvmti,FollowReferences)
2691                           (jvmti, JVMTI_HEAP_FILTER_CLASS_UNTAGGED,
2692                            NULL, NULL, &amp;heap_callbacks, &amp;data);
2693 
2694         } else {
2695 
2696             /* Using IterateThroughHeap means that we will visit each object
2697              *   once, so no special tag tricks here. Just simple counting.
2698              *   However in this case the object might not be live, so we do
2699              *   a GC beforehand to make sure we minimize this.
2700              */
2701 
2702             /* FIXUP: Need some kind of trigger here to avoid excessive GC&#39;s? */
2703             error = JVMTI_FUNC_PTR(jvmti,ForceGarbageCollection)(jvmti);
2704             if ( error != JVMTI_ERROR_NONE ) {
2705 
2706                 /* Setup callbacks, just need object callback */
2707                 heap_callbacks.heap_iteration_callback = &amp;cbObjectCounter;
2708 
2709                 /* Iterate through entire heap, tagged classes only */
2710                 error = JVMTI_FUNC_PTR(jvmti,IterateThroughHeap)
2711                               (jvmti, JVMTI_HEAP_FILTER_CLASS_UNTAGGED,
2712                                NULL, &amp;heap_callbacks, &amp;data);
2713 
2714             }
2715         }
2716 
2717         /* Use data error if needed */
2718         if ( error == JVMTI_ERROR_NONE ) {
2719             error = data.error;
2720         }
2721 
2722     }
2723 
2724     /* Dispose of any special jvmti environment */
2725     (void)JVMTI_FUNC_PTR(jvmti,DisposeEnvironment)(jvmti);
2726     return error;
2727 }
2728 
2729 /* ********************************************************************* */
2730 /* Referrers */
2731 
2732 /* Structure to hold object referrer heap traversal data (arg user_data) */
2733 typedef struct ReferrerData {
2734   int        refCount;
2735   int        maxObjects;
2736   jlong      refTag;
2737   jlong      objTag;
2738   jboolean   selfRef;
2739   jvmtiError error;
2740 } ReferrerData;
2741 
2742 /* Callback for referrers object tagging (heap_reference_callback). */
2743 static jint JNICALL
2744 cbObjectTagReferrer(jvmtiHeapReferenceKind reference_kind,
2745      const jvmtiHeapReferenceInfo* reference_info, jlong class_tag,
2746      jlong referrer_class_tag, jlong size,
2747      jlong* tag_ptr, jlong* referrer_tag_ptr, jint length, void* user_data)
2748 {
2749     ReferrerData  *data;
2750 
2751     /* Check data structure */
2752     data = (ReferrerData*)user_data;
2753     if (data == NULL) {
2754         return JVMTI_VISIT_ABORT;
2755     }
2756 
2757     /* If we have tagged enough objects, just abort */
2758     if ( data-&gt;maxObjects != 0 &amp;&amp; data-&gt;refCount &gt;= data-&gt;maxObjects ) {
2759         return JVMTI_VISIT_ABORT;
2760     }
2761 
2762     /* If not of interest, just continue */
2763     if ( (*tag_ptr) != data-&gt;objTag ) {
2764         return JVMTI_VISIT_OBJECTS;
2765     }
2766 
2767     /* Self reference that we haven&#39;t counted? */
2768     if ( tag_ptr == referrer_tag_ptr ) {
2769         if ( data-&gt;selfRef == JNI_FALSE ) {
2770             data-&gt;selfRef = JNI_TRUE;
2771             data-&gt;refCount++;
2772         }
2773         return JVMTI_VISIT_OBJECTS;
2774     }
2775 
2776     /* If the referrer can be tagged, and hasn&#39;t been tagged, tag it */
2777     if ( referrer_tag_ptr != NULL ) {
2778         if ( (*referrer_tag_ptr) == (jlong)0 ) {
2779             *referrer_tag_ptr = data-&gt;refTag;
2780             data-&gt;refCount++;
2781         }
2782     }
2783     return JVMTI_VISIT_OBJECTS;
2784 }
2785 
2786 /* Heap traversal to find referrers of an object */
2787 jvmtiError
2788 objectReferrers(jobject obj, ObjectBatch *referrers, int maxObjects)
2789 {
2790     jvmtiHeapCallbacks heap_callbacks;
2791     ReferrerData       data;
2792     jvmtiError         error;
2793     jvmtiEnv          *jvmti;
2794 
2795     /* Check interface assumptions */
2796     if (obj == NULL) {
2797         return AGENT_ERROR_INVALID_OBJECT;
2798     }
2799     if (referrers == NULL || maxObjects &lt; 0 ) {
2800         return AGENT_ERROR_ILLEGAL_ARGUMENT;
2801     }
2802 
2803     /* Initialize return information */
2804     referrers-&gt;count = 0;
2805     referrers-&gt;objects = NULL;
2806 
2807     /* Get jvmti environment to use */
2808     jvmti = getSpecialJvmti();
2809     if ( jvmti == NULL ) {
2810         return AGENT_ERROR_INTERNAL;
2811     }
2812 
2813     /* Fill in the data structure passed around the callbacks */
2814     data.refCount   = 0;
2815     data.maxObjects = maxObjects;
2816     data.objTag     = (jlong)1;
2817     data.refTag     = (jlong)2;
2818     data.selfRef    = JNI_FALSE;
2819     data.error      = JVMTI_ERROR_NONE;
2820 
2821     /* Tag the object of interest */
2822     error = JVMTI_FUNC_PTR(jvmti,SetTag) (jvmti, obj, data.objTag);
2823 
2824     /* No need to go any further if we can&#39;t tag the object */
2825     if ( error == JVMTI_ERROR_NONE ) {
2826 
2827         /* Clear out callbacks structure */
2828         (void)memset(&amp;heap_callbacks,0,sizeof(heap_callbacks));
2829 
2830         /* Setup callbacks we want */
2831         heap_callbacks.heap_reference_callback = &amp;cbObjectTagReferrer;
2832 
2833         /* Follow references, no initiating object, all classes, 1 tagged objs */
2834         error = JVMTI_FUNC_PTR(jvmti,FollowReferences)
2835                       (jvmti, JVMTI_HEAP_FILTER_UNTAGGED,
2836                        NULL, NULL, &amp;heap_callbacks, &amp;data);
2837 
2838         /* Use data error if needed */
2839         if ( error == JVMTI_ERROR_NONE ) {
2840             error = data.error;
2841         }
2842 
2843     }
2844 
2845     /* Watch out for self-reference */
2846     if ( error == JVMTI_ERROR_NONE &amp;&amp; data.selfRef == JNI_TRUE ) {
2847         /* Tag itself as a referer */
2848         error = JVMTI_FUNC_PTR(jvmti,SetTag) (jvmti, obj, data.refTag);
2849     }
2850 
2851     /* Get the jobjects for the tagged referrer objects.  */
2852     if ( error == JVMTI_ERROR_NONE ) {
2853         error = JVMTI_FUNC_PTR(jvmti,GetObjectsWithTags)
2854                     (jvmti, 1, &amp;(data.refTag), &amp;(referrers-&gt;count),
2855                           &amp;(referrers-&gt;objects), NULL);
2856         /* Verify we got the count we expected */
2857         if ( data.refCount != referrers-&gt;count ) {
2858             error = AGENT_ERROR_INTERNAL;
2859         }
2860     }
2861 
2862     /* Dispose of any special jvmti environment */
2863     (void)JVMTI_FUNC_PTR(jvmti,DisposeEnvironment)(jvmti);
2864     return error;
2865 }
    </pre>
  </body>
</html>
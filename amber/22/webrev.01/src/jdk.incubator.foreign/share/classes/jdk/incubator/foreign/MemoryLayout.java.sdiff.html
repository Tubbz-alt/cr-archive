<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayout.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MemoryHandles.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MemorySegment.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayout.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 24  *
 25  */
 26 package jdk.incubator.foreign;
 27 
 28 import jdk.internal.foreign.LayoutPath;
 29 import jdk.internal.foreign.LayoutPath.PathElementImpl.PathKind;
 30 import jdk.internal.foreign.Utils;
 31 
 32 import java.lang.constant.Constable;
 33 import java.lang.constant.DynamicConstantDesc;
 34 import java.lang.invoke.VarHandle;
 35 import java.nio.ByteOrder;
 36 import java.util.EnumSet;
 37 import java.util.List;
 38 import java.util.Objects;
 39 import java.util.Optional;
 40 import java.util.OptionalLong;
 41 import java.util.Set;
 42 import java.util.function.Function;
 43 import java.util.function.UnaryOperator;

 44 
 45 /**
 46  * A memory layout can be used to describe the contents of a memory segment in a &lt;em&gt;language neutral&lt;/em&gt; fashion.
 47  * There are two leaves in the layout hierarchy, &lt;em&gt;value layouts&lt;/em&gt;, which are used to represent values of given size and kind (see
 48  * {@link ValueLayout}) and &lt;em&gt;padding layouts&lt;/em&gt; which are used, as the name suggests, to represent a portion of a memory
 49  * segment whose contents should be ignored, and which are primarily present for alignment reasons (see {@link MemoryLayout#ofPaddingBits(long)}).
 50  * Some common value layout constants are defined in the {@link MemoryLayouts} class.
 51  * &lt;p&gt;
 52  * More complex layouts can be derived from simpler ones: a &lt;em&gt;sequence layout&lt;/em&gt; denotes a repetition of one or more
 53  * element layout (see {@link SequenceLayout}); a &lt;em&gt;group layout&lt;/em&gt; denotes an aggregation of (typically) heterogeneous
 54  * member layouts (see {@link GroupLayout}).
 55  * &lt;p&gt;
 56  * All implementations of this interface must be &lt;a href=&quot;{@docRoot}/java.base/java/lang/doc-files/ValueBased.html&quot;&gt;value-based&lt;/a&gt;;
 57  * use of identity-sensitive operations (including reference equality ({@code ==}), identity hash code, or synchronization) on
 58  * instances of {@code MemoryLayout} may have unpredictable results and should be avoided. The {@code equals} method should
 59  * be used for comparisons.
 60  * &lt;p&gt;
 61  * Non-platform classes should not implement {@linkplain MemoryLayout} directly.
 62  *
 63  * &lt;h2&gt;&lt;a id = &quot;layout-align&quot;&gt;Size, alignment and byte order&lt;/a&gt;&lt;/h2&gt;
 64  *
 65  * All layouts have a size; layout size for value and padding layouts is always explicitly denoted; this means that a layout description
 66  * always has the same size in bits, regardless of the platform in which it is used. For derived layouts, the size is computed
 67  * as follows:
 68  * &lt;ul&gt;
 69  *     &lt;li&gt;for a &lt;em&gt;finite&lt;/em&gt; sequence layout &lt;em&gt;S&lt;/em&gt; whose element layout is &lt;em&gt;E&lt;/em&gt; and size is L,
 70  *     the size of &lt;em&gt;S&lt;/em&gt; is that of &lt;em&gt;E&lt;/em&gt;, multiplied by &lt;em&gt;L&lt;/em&gt;&lt;/li&gt;
 71  *     &lt;li&gt;the size of an &lt;em&gt;unbounded&lt;/em&gt; sequence layout is &lt;em&gt;unknown&lt;/em&gt;&lt;/li&gt;
 72  *     &lt;li&gt;for a group layout &lt;em&gt;G&lt;/em&gt; with member layouts &lt;em&gt;M1&lt;/em&gt;, &lt;em&gt;M2&lt;/em&gt;, ... &lt;em&gt;Mn&lt;/em&gt; whose sizes are
 73  *     &lt;em&gt;S1&lt;/em&gt;, &lt;em&gt;S2&lt;/em&gt;, ... &lt;em&gt;Sn&lt;/em&gt;, respectively, the size of &lt;em&gt;G&lt;/em&gt; is either &lt;em&gt;S1 + S2 + ... + Sn&lt;/em&gt; or
 74  *     &lt;em&gt;max(S1, S2, ... Sn)&lt;/em&gt; depending on whether the group is a &lt;em&gt;struct&lt;/em&gt; or an &lt;em&gt;union&lt;/em&gt;, respectively&lt;/li&gt;
 75  * &lt;/ul&gt;
 76  * &lt;p&gt;
 77  * Furthermore, all layouts feature a &lt;em&gt;natural alignment&lt;/em&gt; which can be inferred as follows:
 78  * &lt;ul&gt;
<span class="line-modified"> 79  *     &lt;li&gt;for value and padding layout &lt;em&gt;L&lt;/em&gt; whose size is &lt;em&gt;N&lt;/em&gt;, the natural alignment of &lt;em&gt;L&lt;/em&gt; is &lt;em&gt;N&lt;/em&gt;&lt;/li&gt;</span>



 80  *     &lt;li&gt;for a sequence layout &lt;em&gt;S&lt;/em&gt; whose element layout is &lt;em&gt;E&lt;/em&gt;, the natural alignment of &lt;em&gt;S&lt;/em&gt; is that of &lt;em&gt;E&lt;/em&gt;&lt;/li&gt;
 81  *     &lt;li&gt;for a group layout &lt;em&gt;G&lt;/em&gt; with member layouts &lt;em&gt;M1&lt;/em&gt;, &lt;em&gt;M2&lt;/em&gt;, ... &lt;em&gt;Mn&lt;/em&gt; whose alignments are
 82  *     &lt;em&gt;A1&lt;/em&gt;, &lt;em&gt;A2&lt;/em&gt;, ... &lt;em&gt;An&lt;/em&gt;, respectively, the natural alignment of &lt;em&gt;G&lt;/em&gt; is &lt;em&gt;max(A1, A2 ... An)&lt;/em&gt;&lt;/li&gt;
 83  * &lt;/ul&gt;
 84  * A layout&#39;s natural alignment can be overridden if needed (see {@link MemoryLayout#withBitAlignment(long)}), which can be useful to describe
 85  * hyper-aligned layouts.
 86  * &lt;p&gt;
 87  * All value layouts have an &lt;em&gt;explicit&lt;/em&gt; byte order (see {@link java.nio.ByteOrder}) which is set when the layout is created.
 88  *
 89  * &lt;h2&gt;&lt;a id = &quot;layout-paths&quot;&gt;Layout paths&lt;/a&gt;&lt;/h2&gt;
 90  *
 91  * A &lt;em&gt;layout path&lt;/em&gt; originates from a &lt;em&gt;root&lt;/em&gt; layout (typically a group or a sequence layout) and terminates
 92  * at a layout nested within the root layout - this is the layout &lt;em&gt;selected&lt;/em&gt; by the layout path.
 93  * Layout paths are typically expressed as a sequence of one or more {@link PathElement} instances.
 94  * &lt;p&gt;
 95  * Layout paths are for example useful in order to obtain offsets of arbitrarily nested layouts inside another layout
 96  * (see {@link MemoryLayout#offset(PathElement...)}), to quickly obtain a memory access handle corresponding to the selected
 97  * layout (see {@link MemoryLayout#varHandle(Class, PathElement...)}), to select an arbitrarily nested layout inside
 98  * another layout (see {@link MemoryLayout#select(PathElement...)}, or to transform a nested layout element inside
 99  * another layout (see {@link MemoryLayout#map(UnaryOperator, PathElement...)}).
</pre>
<hr />
<pre>
112  * &lt;blockquote&gt;&lt;pre&gt;{@code
113 long valueOffset = seq.addOffset(PathElement.sequenceElement(), PathElement.groupElement(&quot;value&quot;));
114  * }&lt;/pre&gt;&lt;/blockquote&gt;
115  *
116  * Similarly, we can select the member layout named {@code value}, as follows:
117  * &lt;blockquote&gt;&lt;pre&gt;{@code
118 MemoryLayout value = seq.select(PathElement.sequenceElement(), PathElement.groupElement(&quot;value&quot;));
119  * }&lt;/pre&gt;&lt;/blockquote&gt;
120  *
121  * And, we can also replace the layout named {@code value} with another layout, as follows:
122  * &lt;blockquote&gt;&lt;pre&gt;{@code
123 MemoryLayout newSeq = seq.map(l -&gt; MemoryLayout.ofPadding(32), PathElement.sequenceElement(), PathElement.groupElement(&quot;value&quot;));
124  * }&lt;/pre&gt;&lt;/blockquote&gt;
125  *
126  * That is, the above declaration is identical to the following, more verbose one:
127  * &lt;blockquote&gt;&lt;pre&gt;{@code
128 MemoryLayout newSeq = MemoryLayout.ofSequence(5,
129     MemoryLayout.ofStruct(
130         MemoryLayout.ofPaddingBits(32),
131         MemoryLayout.ofPaddingBits(32)



















132 ));
133  * }&lt;/pre&gt;&lt;/blockquote&gt;
134  *
135  * Layout paths can feature one or more &lt;em&gt;free dimensions&lt;/em&gt;. For instance, a layout path traversing
136  * an unspecified sequence element (that is, where one of the path component was obtained with the
137  * {@link PathElement#sequenceElement()} method) features an additional free dimension, which will have to be bound at runtime.
138  * This is important when obtaining memory access var handle from layouts, as in the following code:
139  *
140  * &lt;blockquote&gt;&lt;pre&gt;{@code
141 VarHandle valueHandle = seq.map(int.class, PathElement.sequenceElement(), PathElement.groupElement(&quot;value&quot;));
142  * }&lt;/pre&gt;&lt;/blockquote&gt;
143  *
144  * Since the layout path {@code seq} constructed in the above example features exactly one free dimension,
145  * it follows that the memory access var handle {@code valueHandle} will feature an extra {@code long}
146  * access coordinate.
147  *







148  * @apiNote In the future, if the Java language permits, {@link MemoryLayout}
149  * may become a {@code sealed} interface, which would prohibit subclassing except by
150  * explicitly permitted types.
151  *
152  * @implSpec
153  * Implementations of this class are immutable and thread-safe.
154  */
155 public interface MemoryLayout extends Constable {
156 
157     /**
158      * Returns an {@link Optional} containing the nominal descriptor for this
159      * layout, if one can be constructed, or an empty {@link Optional}
160      * if one cannot be constructed.
161      *
162      * @return An {@link Optional} containing the resulting nominal descriptor,
163      * or an empty {@link Optional} if one cannot be constructed.
164      */
165     @Override
166     Optional&lt;? extends DynamicConstantDesc&lt;? extends MemoryLayout&gt;&gt; describeConstable();
167 
</pre>
<hr />
<pre>
181      *
182      * @return the layout size, in bits.
183      * @throws UnsupportedOperationException if the layout is, or contains, a sequence layout with unspecified size (see {@link SequenceLayout}).
184      */
185     long bitSize();
186 
187     /**
188      * Computes the layout size, in bytes.
189      *
190      * @return the layout size, in bytes.
191      * @throws UnsupportedOperationException if the layout is, or contains, a sequence layout with unspecified size (see {@link SequenceLayout}),
192      * or if {@code bitSize()} is not a multiple of 8.
193      */
194     default long byteSize() {
195         return Utils.bitsToBytesOrThrow(bitSize(),
196                 () -&gt; new UnsupportedOperationException(&quot;Cannot compute byte size; bit size is not a multiple of 8&quot;));
197     }
198 
199     /**
200      * Return the &lt;em&gt;name&lt;/em&gt; (if any) associated with this layout.





201      *
202      * @return the layout &lt;em&gt;name&lt;/em&gt; (if any).
203      * @see MemoryLayout#withName(String)
204      */
205     Optional&lt;String&gt; name();
206 
207     /**
208      * Creates a new layout which features the desired layout &lt;em&gt;name&lt;/em&gt;.





209      *
210      * @param name the layout name.
211      * @return a new layout which is the same as this layout, except for the &lt;em&gt;name&lt;/em&gt; associated to it.
212      * @see MemoryLayout#name()
213      */
214     MemoryLayout withName(String name);
215 
216     /**
217      * Returns the alignment constraint associated with this layout, expressed in bits. Layout alignment defines a power
218      * of two {@code A} which is the bit-wise alignment of the layout. If {@code A &lt;= 8} then {@code A/8} is the number of
219      * bytes that must be aligned for any pointer that correctly points to this layout. Thus:
220      *
221      * &lt;ul&gt;
222      * &lt;li&gt;{@code A=8} means unaligned (in the usual sense), which is common in packets.&lt;/li&gt;
223      * &lt;li&gt;{@code A=64} means word aligned (on LP64), {@code A=32} int aligned, {@code A=16} short aligned, etc.&lt;/li&gt;
224      * &lt;li&gt;{@code A=512} is the most strict alignment required by the x86/SV ABI (for AVX-512 data).&lt;/li&gt;
225      * &lt;/ul&gt;
226      *
227      * If no explicit alignment constraint was set on this layout (see {@link #withBitAlignment(long)}),
228      * then this method returns the &lt;a href=&quot;#layout-align&quot;&gt;natural alignment&lt;/a&gt; constraint (in bits) associated with this layout.
</pre>
<hr />
<pre>
245      * If no explicit alignment constraint was set on this layout (see {@link #withBitAlignment(long)}),
246      * then this method returns the &lt;a href=&quot;#layout-align&quot;&gt;natural alignment&lt;/a&gt; constraint (in bytes) associated with this layout.
247      *
248      * @return the layout alignment constraint, in bytes.
249      * @throws UnsupportedOperationException if {@code bitAlignment()} is not a multiple of 8.
250      */
251     default long byteAlignment() {
252         return Utils.bitsToBytesOrThrow(bitAlignment(),
253                 () -&gt; new UnsupportedOperationException(&quot;Cannot compute byte alignment; bit alignment is not a multiple of 8&quot;));
254     }
255 
256     /**
257      * Creates a new layout which features the desired alignment constraint.
258      *
259      * @param bitAlignment the layout alignment constraint, expressed in bits.
260      * @return a new layout which is the same as this layout, except for the alignment constraint associated to it.
261      * @throws IllegalArgumentException if {@code bitAlignment} is not a power of two, or if it&#39;s less than than 8.
262      */
263     MemoryLayout withBitAlignment(long bitAlignment);
264 


























265     /**
266      * Computes the offset, in bits, of the layout selected by a given layout path, where the path is considered rooted in this
267      * layout.
268      *
269      * @apiNote if the layout path has one (or more) free dimensions,
270      * the offset is computed as if all the indices corresponding to such dimensions were set to {@code 0}.
271      *
272      * @param elements the layout path elements.
273      * @return The offset, in bits, of the layout selected by the layout path in {@code elements}.
274      * @throws IllegalArgumentException if the layout path does not select any layout nested in this layout, or if the
275      * layout path contains one or more path elements that select multiple sequence element indices
276      * (see {@link PathElement#sequenceElement()} and {@link PathElement#sequenceElement(long, long)}).
277      * @throws UnsupportedOperationException if one of the layouts traversed by the layout path has unspecified size.
278      */
279     default long offset(PathElement... elements) {
280         return computePathOp(LayoutPath.rootPath(this, MemoryLayout::bitSize), LayoutPath::offset, EnumSet.of(PathKind.SEQUENCE_ELEMENT, PathKind.SEQUENCE_RANGE), elements);
281     }
282 
283     /**
284      * Creates a memory access var handle that can be used to dereference memory at the layout selected by a given layout path,
</pre>
<hr />
<pre>
328      * or if the layout path contains one or more path elements that select one or more sequence element indices
329      * (see {@link PathElement#sequenceElement(long)} and {@link PathElement#sequenceElement(long, long)}).
330      */
331     default MemoryLayout map(UnaryOperator&lt;MemoryLayout&gt; op, PathElement... elements) {
332         return computePathOp(LayoutPath.rootPath(this, l -&gt; 0L), path -&gt; path.map(op),
333                 EnumSet.of(PathKind.SEQUENCE_ELEMENT_INDEX, PathKind.SEQUENCE_RANGE), elements);
334     }
335 
336     private static &lt;Z&gt; Z computePathOp(LayoutPath path, Function&lt;LayoutPath, Z&gt; finalizer,
337                                        Set&lt;LayoutPath.PathElementImpl.PathKind&gt; badKinds, PathElement... elements) {
338         for (PathElement e : elements) {
339             LayoutPath.PathElementImpl pathElem = (LayoutPath.PathElementImpl)e;
340             if (badKinds.contains(pathElem.kind())) {
341                 throw new IllegalArgumentException(String.format(&quot;Invalid %s selection in layout path&quot;, pathElem.kind().description()));
342             }
343             path = pathElem.apply(path);
344         }
345         return finalizer.apply(path);
346     }
347 






348     /**
349      * Instances of this class are used to form &lt;a href=&quot;MemoryLayout.html#layout-paths&quot;&gt;&lt;em&gt;layout paths&lt;/em&gt;&lt;/a&gt;. There
350      * are two kinds of path elements: &lt;em&gt;group path elements&lt;/em&gt; and &lt;em&gt;sequence path elements&lt;/em&gt;. Group
351      * path elements are used to select a given named member layout within a {@link GroupLayout}. Sequence
352      * path elements are used to select a sequence element layout within a {@link SequenceLayout}; selection
353      * of sequence element layout can be &lt;em&gt;explicit&lt;/em&gt; (see {@link PathElement#sequenceElement(long)}) or
354      * &lt;em&gt;implicit&lt;/em&gt; (see {@link PathElement#sequenceElement()}). When a path uses one or more implicit
355      * sequence path elements, it acquires additional &lt;em&gt;free dimensions&lt;/em&gt;.
356      * &lt;p&gt;
357      * Non-platform classes should not implement {@linkplain PathElement} directly.
358      *
359      * @apiNote In the future, if the Java language permits, {@link PathElement}
360      * may become a {@code sealed} interface, which would prohibit subclassing except by
361      * explicitly permitted types.
362      *
363      * @implSpec
364      * Implementations of this interface are immutable and thread-safe.
365      */
366     interface PathElement {
367 
</pre>
<hr />
<pre>
431 
432         /**
433          * Returns a path element which selects an unspecified element layout from a given sequence layout.
434          * If a path with free dimensions {@code n} is combined with the path element returned by this method,
435          * the number of free dimensions of the resulting path will be {@code 1 + n}.
436          *
437          * @return a path element which selects an unspecified sequence element layout.
438          */
439         static PathElement sequenceElement() {
440             return new LayoutPath.PathElementImpl(LayoutPath.PathElementImpl.PathKind.SEQUENCE_ELEMENT,
441                                                   LayoutPath::sequenceElement);
442         }
443     }
444 
445     /**
446      * Compares the specified object with this layout for equality. Returns {@code true} if and only if the specified
447      * object is also a layout, and it is equal to this layout. Two layouts are considered equal if they are of
448      * the same kind, have the same size, name and alignment constraints. Furthermore, depending on the layout kind, additional
449      * conditions must be satisfied:
450      * &lt;ul&gt;
<span class="line-modified">451      *     &lt;li&gt;two value layouts are considered equal if they have the same endianness (see {@link ValueLayout#order()})&lt;/li&gt;</span>
452      *     &lt;li&gt;two sequence layouts are considered equal if they have the same element count (see {@link SequenceLayout#elementCount()}), and
453      *     if their element layouts (see {@link SequenceLayout#elementLayout()}) are also equal&lt;/li&gt;
454      *     &lt;li&gt;two group layouts are considered equal if they are of the same kind (see {@link GroupLayout#isStruct()},
455      *     {@link GroupLayout#isUnion()}) and if their member layouts (see {@link GroupLayout#memberLayouts()}) are also equal&lt;/li&gt;
456      * &lt;/ul&gt;
457      *
458      * @param that the object to be compared for equality with this layout.
459      * @return {@code true} if the specified object is equal to this layout.
460      */
461     boolean equals(Object that);
462 
463     /**
464      * Returns the hash code value for this layout.
465      *
466      * @return the hash code value for this layout.
467      */
468     int hashCode();
469 
470     /**
471      * Returns a string representation of this layout.
</pre>
<hr />
<pre>
526 
527     /**
528      * Create a new &lt;em&gt;struct&lt;/em&gt; group layout with given member layouts.
529      *
530      * @param elements The member layouts of the &lt;em&gt;struct&lt;/em&gt; group layout.
531      * @return a new &lt;em&gt;struct&lt;/em&gt; group layout with given member layouts.
532      */
533     static GroupLayout ofStruct(MemoryLayout... elements) {
534         return new GroupLayout(GroupLayout.Kind.STRUCT, List.of(elements));
535     }
536 
537     /**
538      * Create a new &lt;em&gt;union&lt;/em&gt; group layout with given member layouts.
539      *
540      * @param elements The member layouts of the &lt;em&gt;union&lt;/em&gt; layout.
541      * @return a new &lt;em&gt;union&lt;/em&gt; group layout with given member layouts.
542      */
543     static GroupLayout ofUnion(MemoryLayout... elements) {
544         return new GroupLayout(GroupLayout.Kind.UNION, List.of(elements));
545     }





546 }
</pre>
</td>
<td>
<hr />
<pre>
 24  *
 25  */
 26 package jdk.incubator.foreign;
 27 
 28 import jdk.internal.foreign.LayoutPath;
 29 import jdk.internal.foreign.LayoutPath.PathElementImpl.PathKind;
 30 import jdk.internal.foreign.Utils;
 31 
 32 import java.lang.constant.Constable;
 33 import java.lang.constant.DynamicConstantDesc;
 34 import java.lang.invoke.VarHandle;
 35 import java.nio.ByteOrder;
 36 import java.util.EnumSet;
 37 import java.util.List;
 38 import java.util.Objects;
 39 import java.util.Optional;
 40 import java.util.OptionalLong;
 41 import java.util.Set;
 42 import java.util.function.Function;
 43 import java.util.function.UnaryOperator;
<span class="line-added"> 44 import java.util.stream.Stream;</span>
 45 
 46 /**
 47  * A memory layout can be used to describe the contents of a memory segment in a &lt;em&gt;language neutral&lt;/em&gt; fashion.
 48  * There are two leaves in the layout hierarchy, &lt;em&gt;value layouts&lt;/em&gt;, which are used to represent values of given size and kind (see
 49  * {@link ValueLayout}) and &lt;em&gt;padding layouts&lt;/em&gt; which are used, as the name suggests, to represent a portion of a memory
 50  * segment whose contents should be ignored, and which are primarily present for alignment reasons (see {@link MemoryLayout#ofPaddingBits(long)}).
 51  * Some common value layout constants are defined in the {@link MemoryLayouts} class.
 52  * &lt;p&gt;
 53  * More complex layouts can be derived from simpler ones: a &lt;em&gt;sequence layout&lt;/em&gt; denotes a repetition of one or more
 54  * element layout (see {@link SequenceLayout}); a &lt;em&gt;group layout&lt;/em&gt; denotes an aggregation of (typically) heterogeneous
 55  * member layouts (see {@link GroupLayout}).
 56  * &lt;p&gt;
 57  * All implementations of this interface must be &lt;a href=&quot;{@docRoot}/java.base/java/lang/doc-files/ValueBased.html&quot;&gt;value-based&lt;/a&gt;;
 58  * use of identity-sensitive operations (including reference equality ({@code ==}), identity hash code, or synchronization) on
 59  * instances of {@code MemoryLayout} may have unpredictable results and should be avoided. The {@code equals} method should
 60  * be used for comparisons.
 61  * &lt;p&gt;
 62  * Non-platform classes should not implement {@linkplain MemoryLayout} directly.
 63  *
 64  * &lt;h2&gt;&lt;a id = &quot;layout-align&quot;&gt;Size, alignment and byte order&lt;/a&gt;&lt;/h2&gt;
 65  *
 66  * All layouts have a size; layout size for value and padding layouts is always explicitly denoted; this means that a layout description
 67  * always has the same size in bits, regardless of the platform in which it is used. For derived layouts, the size is computed
 68  * as follows:
 69  * &lt;ul&gt;
 70  *     &lt;li&gt;for a &lt;em&gt;finite&lt;/em&gt; sequence layout &lt;em&gt;S&lt;/em&gt; whose element layout is &lt;em&gt;E&lt;/em&gt; and size is L,
 71  *     the size of &lt;em&gt;S&lt;/em&gt; is that of &lt;em&gt;E&lt;/em&gt;, multiplied by &lt;em&gt;L&lt;/em&gt;&lt;/li&gt;
 72  *     &lt;li&gt;the size of an &lt;em&gt;unbounded&lt;/em&gt; sequence layout is &lt;em&gt;unknown&lt;/em&gt;&lt;/li&gt;
 73  *     &lt;li&gt;for a group layout &lt;em&gt;G&lt;/em&gt; with member layouts &lt;em&gt;M1&lt;/em&gt;, &lt;em&gt;M2&lt;/em&gt;, ... &lt;em&gt;Mn&lt;/em&gt; whose sizes are
 74  *     &lt;em&gt;S1&lt;/em&gt;, &lt;em&gt;S2&lt;/em&gt;, ... &lt;em&gt;Sn&lt;/em&gt;, respectively, the size of &lt;em&gt;G&lt;/em&gt; is either &lt;em&gt;S1 + S2 + ... + Sn&lt;/em&gt; or
 75  *     &lt;em&gt;max(S1, S2, ... Sn)&lt;/em&gt; depending on whether the group is a &lt;em&gt;struct&lt;/em&gt; or an &lt;em&gt;union&lt;/em&gt;, respectively&lt;/li&gt;
 76  * &lt;/ul&gt;
 77  * &lt;p&gt;
 78  * Furthermore, all layouts feature a &lt;em&gt;natural alignment&lt;/em&gt; which can be inferred as follows:
 79  * &lt;ul&gt;
<span class="line-modified"> 80  *     &lt;li&gt;for a padding layout &lt;em&gt;L&lt;/em&gt;, the natural alignment is 1, regardless of its size; that is, in the absence</span>
<span class="line-added"> 81  *     of an explicit alignment constraint, a padding layout should not affect the alignment constraint of the group</span>
<span class="line-added"> 82  *     layout it is nested into&lt;/li&gt;</span>
<span class="line-added"> 83  *     &lt;li&gt;for a value layout &lt;em&gt;L&lt;/em&gt; whose size is &lt;em&gt;N&lt;/em&gt;, the natural alignment of &lt;em&gt;L&lt;/em&gt; is &lt;em&gt;N&lt;/em&gt;&lt;/li&gt;</span>
 84  *     &lt;li&gt;for a sequence layout &lt;em&gt;S&lt;/em&gt; whose element layout is &lt;em&gt;E&lt;/em&gt;, the natural alignment of &lt;em&gt;S&lt;/em&gt; is that of &lt;em&gt;E&lt;/em&gt;&lt;/li&gt;
 85  *     &lt;li&gt;for a group layout &lt;em&gt;G&lt;/em&gt; with member layouts &lt;em&gt;M1&lt;/em&gt;, &lt;em&gt;M2&lt;/em&gt;, ... &lt;em&gt;Mn&lt;/em&gt; whose alignments are
 86  *     &lt;em&gt;A1&lt;/em&gt;, &lt;em&gt;A2&lt;/em&gt;, ... &lt;em&gt;An&lt;/em&gt;, respectively, the natural alignment of &lt;em&gt;G&lt;/em&gt; is &lt;em&gt;max(A1, A2 ... An)&lt;/em&gt;&lt;/li&gt;
 87  * &lt;/ul&gt;
 88  * A layout&#39;s natural alignment can be overridden if needed (see {@link MemoryLayout#withBitAlignment(long)}), which can be useful to describe
 89  * hyper-aligned layouts.
 90  * &lt;p&gt;
 91  * All value layouts have an &lt;em&gt;explicit&lt;/em&gt; byte order (see {@link java.nio.ByteOrder}) which is set when the layout is created.
 92  *
 93  * &lt;h2&gt;&lt;a id = &quot;layout-paths&quot;&gt;Layout paths&lt;/a&gt;&lt;/h2&gt;
 94  *
 95  * A &lt;em&gt;layout path&lt;/em&gt; originates from a &lt;em&gt;root&lt;/em&gt; layout (typically a group or a sequence layout) and terminates
 96  * at a layout nested within the root layout - this is the layout &lt;em&gt;selected&lt;/em&gt; by the layout path.
 97  * Layout paths are typically expressed as a sequence of one or more {@link PathElement} instances.
 98  * &lt;p&gt;
 99  * Layout paths are for example useful in order to obtain offsets of arbitrarily nested layouts inside another layout
100  * (see {@link MemoryLayout#offset(PathElement...)}), to quickly obtain a memory access handle corresponding to the selected
101  * layout (see {@link MemoryLayout#varHandle(Class, PathElement...)}), to select an arbitrarily nested layout inside
102  * another layout (see {@link MemoryLayout#select(PathElement...)}, or to transform a nested layout element inside
103  * another layout (see {@link MemoryLayout#map(UnaryOperator, PathElement...)}).
</pre>
<hr />
<pre>
116  * &lt;blockquote&gt;&lt;pre&gt;{@code
117 long valueOffset = seq.addOffset(PathElement.sequenceElement(), PathElement.groupElement(&quot;value&quot;));
118  * }&lt;/pre&gt;&lt;/blockquote&gt;
119  *
120  * Similarly, we can select the member layout named {@code value}, as follows:
121  * &lt;blockquote&gt;&lt;pre&gt;{@code
122 MemoryLayout value = seq.select(PathElement.sequenceElement(), PathElement.groupElement(&quot;value&quot;));
123  * }&lt;/pre&gt;&lt;/blockquote&gt;
124  *
125  * And, we can also replace the layout named {@code value} with another layout, as follows:
126  * &lt;blockquote&gt;&lt;pre&gt;{@code
127 MemoryLayout newSeq = seq.map(l -&gt; MemoryLayout.ofPadding(32), PathElement.sequenceElement(), PathElement.groupElement(&quot;value&quot;));
128  * }&lt;/pre&gt;&lt;/blockquote&gt;
129  *
130  * That is, the above declaration is identical to the following, more verbose one:
131  * &lt;blockquote&gt;&lt;pre&gt;{@code
132 MemoryLayout newSeq = MemoryLayout.ofSequence(5,
133     MemoryLayout.ofStruct(
134         MemoryLayout.ofPaddingBits(32),
135         MemoryLayout.ofPaddingBits(32)
<span class="line-added">136 ));</span>
<span class="line-added">137  * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">138  *</span>
<span class="line-added">139  * Similarly, we can select the member layout named {@code value}, as follows:</span>
<span class="line-added">140  * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-added">141 MemoryLayout value = seq.select(PathElement.sequenceElement(), PathElement.groupElement(&quot;value&quot;));</span>
<span class="line-added">142  * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">143  *</span>
<span class="line-added">144  * And, we can also replace the layout named {@code value} with another layout, as follows:</span>
<span class="line-added">145  * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-added">146 MemoryLayout newSeq = seq.map(l -&gt; MemoryLayout.ofPadding(32), PathElement.sequenceElement(), PathElement.groupElement(&quot;value&quot;));</span>
<span class="line-added">147  * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">148  *</span>
<span class="line-added">149  * That is, the above declaration is identical to the following, more verbose one:</span>
<span class="line-added">150  * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-added">151 MemoryLayout newSeq = MemoryLayout.ofSequence(5,</span>
<span class="line-added">152     MemoryLayout.ofStruct(</span>
<span class="line-added">153         MemoryLayout.ofPaddingBits(32),</span>
<span class="line-added">154         MemoryLayout.ofPaddingBits(32)</span>
155 ));
156  * }&lt;/pre&gt;&lt;/blockquote&gt;
157  *
158  * Layout paths can feature one or more &lt;em&gt;free dimensions&lt;/em&gt;. For instance, a layout path traversing
159  * an unspecified sequence element (that is, where one of the path component was obtained with the
160  * {@link PathElement#sequenceElement()} method) features an additional free dimension, which will have to be bound at runtime.
161  * This is important when obtaining memory access var handle from layouts, as in the following code:
162  *
163  * &lt;blockquote&gt;&lt;pre&gt;{@code
164 VarHandle valueHandle = seq.map(int.class, PathElement.sequenceElement(), PathElement.groupElement(&quot;value&quot;));
165  * }&lt;/pre&gt;&lt;/blockquote&gt;
166  *
167  * Since the layout path {@code seq} constructed in the above example features exactly one free dimension,
168  * it follows that the memory access var handle {@code valueHandle} will feature an extra {@code long}
169  * access coordinate.
170  *
<span class="line-added">171  * &lt;h2&gt;Layout attributes&lt;/h2&gt;</span>
<span class="line-added">172  *</span>
<span class="line-added">173  * Layouts can be optionally associated with one or more &lt;em&gt;attributes&lt;/em&gt;. A layout attribute forms a &lt;em&gt;name/value&lt;/em&gt;</span>
<span class="line-added">174  * pair, where the name is a {@link String} and the value is a {@link Constable}. The most common form of layout attribute</span>
<span class="line-added">175  * is the &lt;em&gt;layout name&lt;/em&gt; (see {@link #LAYOUT_NAME}), a custom name that can be associated to memory layouts and that can be referred to when</span>
<span class="line-added">176  * constructing &lt;a href=&quot;MemoryLayout.html#layout-paths&quot;&gt;&lt;em&gt;layout paths&lt;/em&gt;&lt;/a&gt;.</span>
<span class="line-added">177  *</span>
178  * @apiNote In the future, if the Java language permits, {@link MemoryLayout}
179  * may become a {@code sealed} interface, which would prohibit subclassing except by
180  * explicitly permitted types.
181  *
182  * @implSpec
183  * Implementations of this class are immutable and thread-safe.
184  */
185 public interface MemoryLayout extends Constable {
186 
187     /**
188      * Returns an {@link Optional} containing the nominal descriptor for this
189      * layout, if one can be constructed, or an empty {@link Optional}
190      * if one cannot be constructed.
191      *
192      * @return An {@link Optional} containing the resulting nominal descriptor,
193      * or an empty {@link Optional} if one cannot be constructed.
194      */
195     @Override
196     Optional&lt;? extends DynamicConstantDesc&lt;? extends MemoryLayout&gt;&gt; describeConstable();
197 
</pre>
<hr />
<pre>
211      *
212      * @return the layout size, in bits.
213      * @throws UnsupportedOperationException if the layout is, or contains, a sequence layout with unspecified size (see {@link SequenceLayout}).
214      */
215     long bitSize();
216 
217     /**
218      * Computes the layout size, in bytes.
219      *
220      * @return the layout size, in bytes.
221      * @throws UnsupportedOperationException if the layout is, or contains, a sequence layout with unspecified size (see {@link SequenceLayout}),
222      * or if {@code bitSize()} is not a multiple of 8.
223      */
224     default long byteSize() {
225         return Utils.bitsToBytesOrThrow(bitSize(),
226                 () -&gt; new UnsupportedOperationException(&quot;Cannot compute byte size; bit size is not a multiple of 8&quot;));
227     }
228 
229     /**
230      * Return the &lt;em&gt;name&lt;/em&gt; (if any) associated with this layout.
<span class="line-added">231      * &lt;p&gt;</span>
<span class="line-added">232      * This is equivalent to the following code:</span>
<span class="line-added">233      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-added">234     attribute(LAYOUT_NAME).map(String.class::cast);</span>
<span class="line-added">235      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
236      *
237      * @return the layout &lt;em&gt;name&lt;/em&gt; (if any).
238      * @see MemoryLayout#withName(String)
239      */
240     Optional&lt;String&gt; name();
241 
242     /**
243      * Creates a new layout which features the desired layout &lt;em&gt;name&lt;/em&gt;.
<span class="line-added">244      * &lt;p&gt;</span>
<span class="line-added">245      * This is equivalent to the following code:</span>
<span class="line-added">246      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-added">247     withAttribute(LAYOUT_NAME, name);</span>
<span class="line-added">248      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
249      *
250      * @param name the layout name.
251      * @return a new layout which is the same as this layout, except for the &lt;em&gt;name&lt;/em&gt; associated to it.
252      * @see MemoryLayout#name()
253      */
254     MemoryLayout withName(String name);
255 
256     /**
257      * Returns the alignment constraint associated with this layout, expressed in bits. Layout alignment defines a power
258      * of two {@code A} which is the bit-wise alignment of the layout. If {@code A &lt;= 8} then {@code A/8} is the number of
259      * bytes that must be aligned for any pointer that correctly points to this layout. Thus:
260      *
261      * &lt;ul&gt;
262      * &lt;li&gt;{@code A=8} means unaligned (in the usual sense), which is common in packets.&lt;/li&gt;
263      * &lt;li&gt;{@code A=64} means word aligned (on LP64), {@code A=32} int aligned, {@code A=16} short aligned, etc.&lt;/li&gt;
264      * &lt;li&gt;{@code A=512} is the most strict alignment required by the x86/SV ABI (for AVX-512 data).&lt;/li&gt;
265      * &lt;/ul&gt;
266      *
267      * If no explicit alignment constraint was set on this layout (see {@link #withBitAlignment(long)}),
268      * then this method returns the &lt;a href=&quot;#layout-align&quot;&gt;natural alignment&lt;/a&gt; constraint (in bits) associated with this layout.
</pre>
<hr />
<pre>
285      * If no explicit alignment constraint was set on this layout (see {@link #withBitAlignment(long)}),
286      * then this method returns the &lt;a href=&quot;#layout-align&quot;&gt;natural alignment&lt;/a&gt; constraint (in bytes) associated with this layout.
287      *
288      * @return the layout alignment constraint, in bytes.
289      * @throws UnsupportedOperationException if {@code bitAlignment()} is not a multiple of 8.
290      */
291     default long byteAlignment() {
292         return Utils.bitsToBytesOrThrow(bitAlignment(),
293                 () -&gt; new UnsupportedOperationException(&quot;Cannot compute byte alignment; bit alignment is not a multiple of 8&quot;));
294     }
295 
296     /**
297      * Creates a new layout which features the desired alignment constraint.
298      *
299      * @param bitAlignment the layout alignment constraint, expressed in bits.
300      * @return a new layout which is the same as this layout, except for the alignment constraint associated to it.
301      * @throws IllegalArgumentException if {@code bitAlignment} is not a power of two, or if it&#39;s less than than 8.
302      */
303     MemoryLayout withBitAlignment(long bitAlignment);
304 
<span class="line-added">305     /**</span>
<span class="line-added">306      * Returns the attribute with the given name (if it exists).</span>
<span class="line-added">307      *</span>
<span class="line-added">308      * @param name the attribute name</span>
<span class="line-added">309      * @return the attribute with the given name (if it exists).</span>
<span class="line-added">310      */</span>
<span class="line-added">311     Optional&lt;Constable&gt; attribute(String name);</span>
<span class="line-added">312 </span>
<span class="line-added">313     /**</span>
<span class="line-added">314      * Returns a new memory layout which features the same attributes as this layout, plus the newly specified attribute.</span>
<span class="line-added">315      * If this layout already contains an attribute with the same name, the existing attribute value is overwritten in the returned</span>
<span class="line-added">316      * layout.</span>
<span class="line-added">317      *</span>
<span class="line-added">318      * @param name the attribute name.</span>
<span class="line-added">319      * @param value the attribute value.</span>
<span class="line-added">320      * @return a new memory layout which features the same attributes as this layout, plus the newly specified attribute.</span>
<span class="line-added">321      */</span>
<span class="line-added">322     MemoryLayout withAttribute(String name, Constable value);</span>
<span class="line-added">323 </span>
<span class="line-added">324     /**</span>
<span class="line-added">325      * Returns a stream of the attribute names associated with this layout.</span>
<span class="line-added">326      *</span>
<span class="line-added">327      * @return a stream of the attribute names associated with this layout.</span>
<span class="line-added">328      */</span>
<span class="line-added">329     Stream&lt;String&gt; attributes();</span>
<span class="line-added">330 </span>
331     /**
332      * Computes the offset, in bits, of the layout selected by a given layout path, where the path is considered rooted in this
333      * layout.
334      *
335      * @apiNote if the layout path has one (or more) free dimensions,
336      * the offset is computed as if all the indices corresponding to such dimensions were set to {@code 0}.
337      *
338      * @param elements the layout path elements.
339      * @return The offset, in bits, of the layout selected by the layout path in {@code elements}.
340      * @throws IllegalArgumentException if the layout path does not select any layout nested in this layout, or if the
341      * layout path contains one or more path elements that select multiple sequence element indices
342      * (see {@link PathElement#sequenceElement()} and {@link PathElement#sequenceElement(long, long)}).
343      * @throws UnsupportedOperationException if one of the layouts traversed by the layout path has unspecified size.
344      */
345     default long offset(PathElement... elements) {
346         return computePathOp(LayoutPath.rootPath(this, MemoryLayout::bitSize), LayoutPath::offset, EnumSet.of(PathKind.SEQUENCE_ELEMENT, PathKind.SEQUENCE_RANGE), elements);
347     }
348 
349     /**
350      * Creates a memory access var handle that can be used to dereference memory at the layout selected by a given layout path,
</pre>
<hr />
<pre>
394      * or if the layout path contains one or more path elements that select one or more sequence element indices
395      * (see {@link PathElement#sequenceElement(long)} and {@link PathElement#sequenceElement(long, long)}).
396      */
397     default MemoryLayout map(UnaryOperator&lt;MemoryLayout&gt; op, PathElement... elements) {
398         return computePathOp(LayoutPath.rootPath(this, l -&gt; 0L), path -&gt; path.map(op),
399                 EnumSet.of(PathKind.SEQUENCE_ELEMENT_INDEX, PathKind.SEQUENCE_RANGE), elements);
400     }
401 
402     private static &lt;Z&gt; Z computePathOp(LayoutPath path, Function&lt;LayoutPath, Z&gt; finalizer,
403                                        Set&lt;LayoutPath.PathElementImpl.PathKind&gt; badKinds, PathElement... elements) {
404         for (PathElement e : elements) {
405             LayoutPath.PathElementImpl pathElem = (LayoutPath.PathElementImpl)e;
406             if (badKinds.contains(pathElem.kind())) {
407                 throw new IllegalArgumentException(String.format(&quot;Invalid %s selection in layout path&quot;, pathElem.kind().description()));
408             }
409             path = pathElem.apply(path);
410         }
411         return finalizer.apply(path);
412     }
413 
<span class="line-added">414     /**</span>
<span class="line-added">415      * Is this a padding layout (e.g. a layout created from {@link #ofPaddingBits(long)}) ?</span>
<span class="line-added">416      * @return true, if this layout is a padding layout.</span>
<span class="line-added">417      */</span>
<span class="line-added">418     boolean isPadding();</span>
<span class="line-added">419 </span>
420     /**
421      * Instances of this class are used to form &lt;a href=&quot;MemoryLayout.html#layout-paths&quot;&gt;&lt;em&gt;layout paths&lt;/em&gt;&lt;/a&gt;. There
422      * are two kinds of path elements: &lt;em&gt;group path elements&lt;/em&gt; and &lt;em&gt;sequence path elements&lt;/em&gt;. Group
423      * path elements are used to select a given named member layout within a {@link GroupLayout}. Sequence
424      * path elements are used to select a sequence element layout within a {@link SequenceLayout}; selection
425      * of sequence element layout can be &lt;em&gt;explicit&lt;/em&gt; (see {@link PathElement#sequenceElement(long)}) or
426      * &lt;em&gt;implicit&lt;/em&gt; (see {@link PathElement#sequenceElement()}). When a path uses one or more implicit
427      * sequence path elements, it acquires additional &lt;em&gt;free dimensions&lt;/em&gt;.
428      * &lt;p&gt;
429      * Non-platform classes should not implement {@linkplain PathElement} directly.
430      *
431      * @apiNote In the future, if the Java language permits, {@link PathElement}
432      * may become a {@code sealed} interface, which would prohibit subclassing except by
433      * explicitly permitted types.
434      *
435      * @implSpec
436      * Implementations of this interface are immutable and thread-safe.
437      */
438     interface PathElement {
439 
</pre>
<hr />
<pre>
503 
504         /**
505          * Returns a path element which selects an unspecified element layout from a given sequence layout.
506          * If a path with free dimensions {@code n} is combined with the path element returned by this method,
507          * the number of free dimensions of the resulting path will be {@code 1 + n}.
508          *
509          * @return a path element which selects an unspecified sequence element layout.
510          */
511         static PathElement sequenceElement() {
512             return new LayoutPath.PathElementImpl(LayoutPath.PathElementImpl.PathKind.SEQUENCE_ELEMENT,
513                                                   LayoutPath::sequenceElement);
514         }
515     }
516 
517     /**
518      * Compares the specified object with this layout for equality. Returns {@code true} if and only if the specified
519      * object is also a layout, and it is equal to this layout. Two layouts are considered equal if they are of
520      * the same kind, have the same size, name and alignment constraints. Furthermore, depending on the layout kind, additional
521      * conditions must be satisfied:
522      * &lt;ul&gt;
<span class="line-modified">523      *     &lt;li&gt;two value layouts are considered equal if they have the same byte order (see {@link ValueLayout#order()})&lt;/li&gt;</span>
524      *     &lt;li&gt;two sequence layouts are considered equal if they have the same element count (see {@link SequenceLayout#elementCount()}), and
525      *     if their element layouts (see {@link SequenceLayout#elementLayout()}) are also equal&lt;/li&gt;
526      *     &lt;li&gt;two group layouts are considered equal if they are of the same kind (see {@link GroupLayout#isStruct()},
527      *     {@link GroupLayout#isUnion()}) and if their member layouts (see {@link GroupLayout#memberLayouts()}) are also equal&lt;/li&gt;
528      * &lt;/ul&gt;
529      *
530      * @param that the object to be compared for equality with this layout.
531      * @return {@code true} if the specified object is equal to this layout.
532      */
533     boolean equals(Object that);
534 
535     /**
536      * Returns the hash code value for this layout.
537      *
538      * @return the hash code value for this layout.
539      */
540     int hashCode();
541 
542     /**
543      * Returns a string representation of this layout.
</pre>
<hr />
<pre>
598 
599     /**
600      * Create a new &lt;em&gt;struct&lt;/em&gt; group layout with given member layouts.
601      *
602      * @param elements The member layouts of the &lt;em&gt;struct&lt;/em&gt; group layout.
603      * @return a new &lt;em&gt;struct&lt;/em&gt; group layout with given member layouts.
604      */
605     static GroupLayout ofStruct(MemoryLayout... elements) {
606         return new GroupLayout(GroupLayout.Kind.STRUCT, List.of(elements));
607     }
608 
609     /**
610      * Create a new &lt;em&gt;union&lt;/em&gt; group layout with given member layouts.
611      *
612      * @param elements The member layouts of the &lt;em&gt;union&lt;/em&gt; layout.
613      * @return a new &lt;em&gt;union&lt;/em&gt; group layout with given member layouts.
614      */
615     static GroupLayout ofUnion(MemoryLayout... elements) {
616         return new GroupLayout(GroupLayout.Kind.UNION, List.of(elements));
617     }
<span class="line-added">618 </span>
<span class="line-added">619     /**</span>
<span class="line-added">620      * Attribute name used to specify the &lt;em&gt;name&lt;/em&gt; property of a memory layout (see {@link #name()} and {@link #withName(String)}).</span>
<span class="line-added">621      */</span>
<span class="line-added">622     String LAYOUT_NAME = &quot;layout/name&quot;;</span>
623 }
</pre>
</td>
</tr>
</table>
<center><a href="MemoryHandles.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MemorySegment.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
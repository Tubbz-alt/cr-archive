diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayout.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayout.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayout.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayout.java
@@ -39,10 +39,11 @@
 import java.util.Optional;
 import java.util.OptionalLong;
 import java.util.Set;
 import java.util.function.Function;
 import java.util.function.UnaryOperator;
+import java.util.stream.Stream;
 
 /**
  * A memory layout can be used to describe the contents of a memory segment in a <em>language neutral</em> fashion.
  * There are two leaves in the layout hierarchy, <em>value layouts</em>, which are used to represent values of given size and kind (see
  * {@link ValueLayout}) and <em>padding layouts</em> which are used, as the name suggests, to represent a portion of a memory
@@ -74,11 +75,14 @@
  *     <em>max(S1, S2, ... Sn)</em> depending on whether the group is a <em>struct</em> or an <em>union</em>, respectively</li>
  * </ul>
  * <p>
  * Furthermore, all layouts feature a <em>natural alignment</em> which can be inferred as follows:
  * <ul>
- *     <li>for value and padding layout <em>L</em> whose size is <em>N</em>, the natural alignment of <em>L</em> is <em>N</em></li>
+ *     <li>for a padding layout <em>L</em>, the natural alignment is 1, regardless of its size; that is, in the absence
+ *     of an explicit alignment constraint, a padding layout should not affect the alignment constraint of the group
+ *     layout it is nested into</li>
+ *     <li>for a value layout <em>L</em> whose size is <em>N</em>, the natural alignment of <em>L</em> is <em>N</em></li>
  *     <li>for a sequence layout <em>S</em> whose element layout is <em>E</em>, the natural alignment of <em>S</em> is that of <em>E</em></li>
  *     <li>for a group layout <em>G</em> with member layouts <em>M1</em>, <em>M2</em>, ... <em>Mn</em> whose alignments are
  *     <em>A1</em>, <em>A2</em>, ... <em>An</em>, respectively, the natural alignment of <em>G</em> is <em>max(A1, A2 ... An)</em></li>
  * </ul>
  * A layout's natural alignment can be overridden if needed (see {@link MemoryLayout#withBitAlignment(long)}), which can be useful to describe
@@ -127,10 +131,29 @@
  * <blockquote><pre>{@code
 MemoryLayout newSeq = MemoryLayout.ofSequence(5,
     MemoryLayout.ofStruct(
         MemoryLayout.ofPaddingBits(32),
         MemoryLayout.ofPaddingBits(32)
+));
+ * }</pre></blockquote>
+ *
+ * Similarly, we can select the member layout named {@code value}, as follows:
+ * <blockquote><pre>{@code
+MemoryLayout value = seq.select(PathElement.sequenceElement(), PathElement.groupElement("value"));
+ * }</pre></blockquote>
+ *
+ * And, we can also replace the layout named {@code value} with another layout, as follows:
+ * <blockquote><pre>{@code
+MemoryLayout newSeq = seq.map(l -> MemoryLayout.ofPadding(32), PathElement.sequenceElement(), PathElement.groupElement("value"));
+ * }</pre></blockquote>
+ *
+ * That is, the above declaration is identical to the following, more verbose one:
+ * <blockquote><pre>{@code
+MemoryLayout newSeq = MemoryLayout.ofSequence(5,
+    MemoryLayout.ofStruct(
+        MemoryLayout.ofPaddingBits(32),
+        MemoryLayout.ofPaddingBits(32)
 ));
  * }</pre></blockquote>
  *
  * Layout paths can feature one or more <em>free dimensions</em>. For instance, a layout path traversing
  * an unspecified sequence element (that is, where one of the path component was obtained with the
@@ -143,10 +166,17 @@
  *
  * Since the layout path {@code seq} constructed in the above example features exactly one free dimension,
  * it follows that the memory access var handle {@code valueHandle} will feature an extra {@code long}
  * access coordinate.
  *
+ * <h2>Layout attributes</h2>
+ *
+ * Layouts can be optionally associated with one or more <em>attributes</em>. A layout attribute forms a <em>name/value</em>
+ * pair, where the name is a {@link String} and the value is a {@link Constable}. The most common form of layout attribute
+ * is the <em>layout name</em> (see {@link #LAYOUT_NAME}), a custom name that can be associated to memory layouts and that can be referred to when
+ * constructing <a href="MemoryLayout.html#layout-paths"><em>layout paths</em></a>.
+ *
  * @apiNote In the future, if the Java language permits, {@link MemoryLayout}
  * may become a {@code sealed} interface, which would prohibit subclassing except by
  * explicitly permitted types.
  *
  * @implSpec
@@ -196,18 +226,28 @@
                 () -> new UnsupportedOperationException("Cannot compute byte size; bit size is not a multiple of 8"));
     }
 
     /**
      * Return the <em>name</em> (if any) associated with this layout.
+     * <p>
+     * This is equivalent to the following code:
+     * <blockquote><pre>{@code
+    attribute(LAYOUT_NAME).map(String.class::cast);
+     * }</pre></blockquote>
      *
      * @return the layout <em>name</em> (if any).
      * @see MemoryLayout#withName(String)
      */
     Optional<String> name();
 
     /**
      * Creates a new layout which features the desired layout <em>name</em>.
+     * <p>
+     * This is equivalent to the following code:
+     * <blockquote><pre>{@code
+    withAttribute(LAYOUT_NAME, name);
+     * }</pre></blockquote>
      *
      * @param name the layout name.
      * @return a new layout which is the same as this layout, except for the <em>name</em> associated to it.
      * @see MemoryLayout#name()
      */
@@ -260,10 +300,36 @@
      * @return a new layout which is the same as this layout, except for the alignment constraint associated to it.
      * @throws IllegalArgumentException if {@code bitAlignment} is not a power of two, or if it's less than than 8.
      */
     MemoryLayout withBitAlignment(long bitAlignment);
 
+    /**
+     * Returns the attribute with the given name (if it exists).
+     *
+     * @param name the attribute name
+     * @return the attribute with the given name (if it exists).
+     */
+    Optional<Constable> attribute(String name);
+
+    /**
+     * Returns a new memory layout which features the same attributes as this layout, plus the newly specified attribute.
+     * If this layout already contains an attribute with the same name, the existing attribute value is overwritten in the returned
+     * layout.
+     *
+     * @param name the attribute name.
+     * @param value the attribute value.
+     * @return a new memory layout which features the same attributes as this layout, plus the newly specified attribute.
+     */
+    MemoryLayout withAttribute(String name, Constable value);
+
+    /**
+     * Returns a stream of the attribute names associated with this layout.
+     *
+     * @return a stream of the attribute names associated with this layout.
+     */
+    Stream<String> attributes();
+
     /**
      * Computes the offset, in bits, of the layout selected by a given layout path, where the path is considered rooted in this
      * layout.
      *
      * @apiNote if the layout path has one (or more) free dimensions,
@@ -343,10 +409,16 @@
             path = pathElem.apply(path);
         }
         return finalizer.apply(path);
     }
 
+    /**
+     * Is this a padding layout (e.g. a layout created from {@link #ofPaddingBits(long)}) ?
+     * @return true, if this layout is a padding layout.
+     */
+    boolean isPadding();
+
     /**
      * Instances of this class are used to form <a href="MemoryLayout.html#layout-paths"><em>layout paths</em></a>. There
      * are two kinds of path elements: <em>group path elements</em> and <em>sequence path elements</em>. Group
      * path elements are used to select a given named member layout within a {@link GroupLayout}. Sequence
      * path elements are used to select a sequence element layout within a {@link SequenceLayout}; selection
@@ -446,11 +518,11 @@
      * Compares the specified object with this layout for equality. Returns {@code true} if and only if the specified
      * object is also a layout, and it is equal to this layout. Two layouts are considered equal if they are of
      * the same kind, have the same size, name and alignment constraints. Furthermore, depending on the layout kind, additional
      * conditions must be satisfied:
      * <ul>
-     *     <li>two value layouts are considered equal if they have the same endianness (see {@link ValueLayout#order()})</li>
+     *     <li>two value layouts are considered equal if they have the same byte order (see {@link ValueLayout#order()})</li>
      *     <li>two sequence layouts are considered equal if they have the same element count (see {@link SequenceLayout#elementCount()}), and
      *     if their element layouts (see {@link SequenceLayout#elementLayout()}) are also equal</li>
      *     <li>two group layouts are considered equal if they are of the same kind (see {@link GroupLayout#isStruct()},
      *     {@link GroupLayout#isUnion()}) and if their member layouts (see {@link GroupLayout#memberLayouts()}) are also equal</li>
      * </ul>
@@ -541,6 +613,11 @@
      * @return a new <em>union</em> group layout with given member layouts.
      */
     static GroupLayout ofUnion(MemoryLayout... elements) {
         return new GroupLayout(GroupLayout.Kind.UNION, List.of(elements));
     }
+
+    /**
+     * Attribute name used to specify the <em>name</em> property of a memory layout (see {@link #name()} and {@link #withName(String)}).
+     */
+    String LAYOUT_NAME = "layout/name";
 }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="GroupLayout.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MemoryHandles.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 27,17 ***</span>
  package jdk.incubator.foreign;
  
  import jdk.internal.foreign.MemoryAddressImpl;
  
  /**
<span class="line-modified">!  * A memory address encodes an offset within a given {@link MemorySegment}. Memory addresses are typically obtained</span>
<span class="line-modified">!  * using the {@link MemorySegment#baseAddress()} method; such addresses can then be adjusted as required,</span>
<span class="line-modified">!  * using {@link MemoryAddress#addOffset(long)}.</span>
   * &lt;p&gt;
<span class="line-modified">!  * A memory address is typically used as the first argument in a memory access var handle call, to perform some operation</span>
<span class="line-modified">!  * on the underlying memory backing a given memory segment. Since a memory address is always associated with a memory segment,</span>
<span class="line-modified">!  * such access operations are always subject to spatial and temporal checks as enforced by the address&#39; owning memory region.</span>
   * &lt;p&gt;
   * All implementations of this interface must be &lt;a href=&quot;{@docRoot}/java.base/java/lang/doc-files/ValueBased.html&quot;&gt;value-based&lt;/a&gt;;
   * use of identity-sensitive operations (including reference equality ({@code ==}), identity hash code, or synchronization) on
   * instances of {@code MemoryAddress} may have unpredictable results and should be avoided. The {@code equals} method should
   * be used for comparisons.
<span class="line-new-header">--- 27,20 ---</span>
  package jdk.incubator.foreign;
  
  import jdk.internal.foreign.MemoryAddressImpl;
  
  /**
<span class="line-modified">!  * A memory address models a reference into a memory location. Memory addresses are typically obtained using the</span>
<span class="line-modified">!  * {@link MemorySegment#baseAddress()} method; such addresses are said to be &lt;em&gt;checked&lt;/em&gt;, and can be expressed</span>
<span class="line-modified">!  * as &lt;em&gt;offsets&lt;/em&gt; into some underlying memory segment (see {@link #segment()} and {@link #segmentOffset()}).</span>
<span class="line-added">+  * Since checked memory addresses feature both spatial and temporal bounds, these addresses can &lt;em&gt;safely&lt;/em&gt; be</span>
<span class="line-added">+  * dereferenced using a memory access var handle (see {@link MemoryHandles}).</span>
   * &lt;p&gt;
<span class="line-modified">!  * If an address does not have any associated segment, it is said to be &lt;em&gt;unchecked&lt;/em&gt;. Unchecked memory</span>
<span class="line-modified">!  * addresses do not feature known spatial or temporal bounds; as such, attempting a memory dereference operation</span>
<span class="line-modified">!  * using an unchecked memory address will result in a runtime exception. Unchecked addresses can be obtained</span>
<span class="line-added">+  * e.g. by calling the {@link #ofLong(long)} method.</span>
   * &lt;p&gt;
   * All implementations of this interface must be &lt;a href=&quot;{@docRoot}/java.base/java/lang/doc-files/ValueBased.html&quot;&gt;value-based&lt;/a&gt;;
   * use of identity-sensitive operations (including reference equality ({@code ==}), identity hash code, or synchronization) on
   * instances of {@code MemoryAddress} may have unpredictable results and should be avoided. The {@code equals} method should
   * be used for comparisons.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 58,31 ***</span>
       * @return a new memory address with given offset from current one.
       */
      MemoryAddress addOffset(long offset);
  
      /**
<span class="line-modified">!      * The offset of this memory address into the underlying segment.</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * @return the offset</span>
       */
<span class="line-modified">!     long offset();</span>
  
      /**
<span class="line-modified">!      * The memory segment this address belongs to.</span>
<span class="line-modified">!      * @return The memory segment this address belongs to.</span>
       */
      MemorySegment segment();
  
      /**
       * Compares the specified object with this address for equality. Returns {@code true} if and only if the specified
       * object is also an address, and it refers to the same memory location as this address.
       *
       * @apiNote two addresses might be considered equal despite their associated segments differ. This
       * can happen, for instance, if the segment associated with one address is a &lt;em&gt;slice&lt;/em&gt;
       * (see {@link MemorySegment#asSlice(long, long)}) of the segment associated with the other address. Moreover,
       * two addresses might be considered equals despite differences in the temporal bounds associated with their
<span class="line-modified">!      * corresponding segments (this is possible, for example, as a result of calls to {@link MemorySegment#acquire()}).</span>
       *
       * @param that the object to be compared for equality with this address.
       * @return {@code true} if the specified object is equal to this address.
       */
      @Override
<span class="line-new-header">--- 61,48 ---</span>
       * @return a new memory address with given offset from current one.
       */
      MemoryAddress addOffset(long offset);
  
      /**
<span class="line-modified">!      * Returns the offset of this memory address into the underlying segment (if any).</span>
<span class="line-modified">!      * @return the offset of this memory address into the underlying segment (if any).</span>
<span class="line-modified">!      * @throws UnsupportedOperationException if no segment is associated with this memory address,</span>
<span class="line-added">+      * e.g. if {@code segment() == null}.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     long segmentOffset();</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Returns the raw long value associated to this memory address.</span>
<span class="line-added">+      * @return The raw long value associated to this memory address.</span>
<span class="line-added">+      * @throws UnsupportedOperationException if this memory address is associated with an heap segment.</span>
       */
<span class="line-modified">!     long toRawLongValue();</span>
  
      /**
<span class="line-modified">!      * Returns the memory segment (if any) this address belongs to.</span>
<span class="line-modified">!      * @return The memory segment this address belongs to, or {@code null} if no such segment exists.</span>
       */
      MemorySegment segment();
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Reinterpret this address as an offset into the provided segment.</span>
<span class="line-added">+      * @param segment the segment to be rebased</span>
<span class="line-added">+      * @return a new address pointing to the same memory location through the provided segment</span>
<span class="line-added">+      * @throws IllegalArgumentException if the provided segment is not a valid rebase target for this address. This</span>
<span class="line-added">+      * can happen, for instance, if an heap-based addressed is rebased to an off-heap memory segment.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     MemoryAddress rebase(MemorySegment segment);</span>
<span class="line-added">+ </span>
      /**
       * Compares the specified object with this address for equality. Returns {@code true} if and only if the specified
       * object is also an address, and it refers to the same memory location as this address.
       *
       * @apiNote two addresses might be considered equal despite their associated segments differ. This
       * can happen, for instance, if the segment associated with one address is a &lt;em&gt;slice&lt;/em&gt;
       * (see {@link MemorySegment#asSlice(long, long)}) of the segment associated with the other address. Moreover,
       * two addresses might be considered equals despite differences in the temporal bounds associated with their
<span class="line-modified">!      * corresponding segments.</span>
       *
       * @param that the object to be compared for equality with this address.
       * @return {@code true} if the specified object is equal to this address.
       */
      @Override
</pre>
<hr />
<pre>
<span class="line-old-header">*** 98,20 ***</span>
      /**
       * Perform bulk copy from source address to target address. More specifically, the bytes at addresses {@code src}
       * through {@code src.addOffset(bytes - 1)} are copied into addresses {@code dst} through {@code dst.addOffset(bytes - 1)}.
       * If the source and address ranges overlap, then the copying is performed as if the bytes at addresses {@code src}
       * through {@code src.addOffset(bytes - 1)} were first copied into a temporary segment with size {@code bytes},
<span class="line-modified">!      * and then the contents of the temporary segment were copied into the bytes at addresses {@code dst} through {@code dst.addOffset(bytes - 1)}.</span>
       * @param src the source address.
       * @param dst the target address.
       * @param bytes the number of bytes to be copied.
       * @throws IndexOutOfBoundsException if {@code bytes &lt; 0}, or if it is greater than the size of the segments
       * associated with either {@code src} or {@code dst}.
       * @throws IllegalStateException if either the source address or the target address belong to memory segments
       * which have been already closed, or if access occurs from a thread other than the thread owning either segment.
<span class="line-modified">!      * @throws UnsupportedOperationException if {@code dst} is associated with a read-only segment (see {@link MemorySegment#isReadOnly()}).</span>
       */
      static void copy(MemoryAddress src, MemoryAddress dst, long bytes) {
          MemoryAddressImpl.copy((MemoryAddressImpl)src, (MemoryAddressImpl)dst, bytes);
      }
  
  }
<span class="line-new-header">--- 118,46 ---</span>
      /**
       * Perform bulk copy from source address to target address. More specifically, the bytes at addresses {@code src}
       * through {@code src.addOffset(bytes - 1)} are copied into addresses {@code dst} through {@code dst.addOffset(bytes - 1)}.
       * If the source and address ranges overlap, then the copying is performed as if the bytes at addresses {@code src}
       * through {@code src.addOffset(bytes - 1)} were first copied into a temporary segment with size {@code bytes},
<span class="line-modified">!      * and then the contents of the temporary segment were copied into the bytes at addresses {@code dst} through</span>
<span class="line-added">+      * {@code dst.addOffset(bytes - 1)}.</span>
<span class="line-added">+      * &lt;p&gt;</span>
<span class="line-added">+      * The result of a bulk copy is unspecified if, in the uncommon case, the source and target address ranges do not</span>
<span class="line-added">+      * overlap, but refer to overlapping regions of the same backing storage using different addresses.  For example,</span>
<span class="line-added">+      * this may occur if the same file is {@link MemorySegment#mapFromPath mapped} to two segments.</span>
<span class="line-added">+      *</span>
       * @param src the source address.
       * @param dst the target address.
       * @param bytes the number of bytes to be copied.
       * @throws IndexOutOfBoundsException if {@code bytes &lt; 0}, or if it is greater than the size of the segments
       * associated with either {@code src} or {@code dst}.
       * @throws IllegalStateException if either the source address or the target address belong to memory segments
       * which have been already closed, or if access occurs from a thread other than the thread owning either segment.
<span class="line-modified">!      * @throws UnsupportedOperationException if either {@code src} or {@code dst} do not feature required access modes;</span>
<span class="line-added">+      * more specifically, {@code src} should be associated with a segment with {@link MemorySegment#READ} access mode,</span>
<span class="line-added">+      * while {@code dst} should be associated with a segment with {@link MemorySegment#WRITE} access mode.</span>
       */
      static void copy(MemoryAddress src, MemoryAddress dst, long bytes) {
          MemoryAddressImpl.copy((MemoryAddressImpl)src, (MemoryAddressImpl)dst, bytes);
      }
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * The &lt;em&gt;unchecked&lt;/em&gt; memory address instance modelling the {@code NULL} address. This address is &lt;em&gt;not&lt;/em&gt; backed by</span>
<span class="line-added">+      * a memory segment and hence it cannot be dereferenced.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     MemoryAddress NULL = new MemoryAddressImpl( 0L);</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Obtain a new &lt;em&gt;unchecked&lt;/em&gt; memory address instance from given long address. The returned address is &lt;em&gt;not&lt;/em&gt; backed by</span>
<span class="line-added">+      * a memory segment and hence it cannot be dereferenced.</span>
<span class="line-added">+      * @param value the long address.</span>
<span class="line-added">+      * @return the new memory address instance.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     static MemoryAddress ofLong(long value) {</span>
<span class="line-added">+         return value == 0 ?</span>
<span class="line-added">+                 NULL :</span>
<span class="line-added">+                 new MemoryAddressImpl(value);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
  }
</pre>
<center><a href="GroupLayout.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MemoryHandles.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/VM.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 package sun.jvm.hotspot.runtime;
  26 
  27 import java.io.*;
  28 import java.net.*;
  29 import java.util.*;
  30 import java.util.regex.*;
  31 import sun.jvm.hotspot.code.*;
  32 import sun.jvm.hotspot.c1.*;
  33 import sun.jvm.hotspot.code.*;
  34 import sun.jvm.hotspot.debugger.*;
  35 import sun.jvm.hotspot.interpreter.*;
  36 import sun.jvm.hotspot.memory.*;
  37 import sun.jvm.hotspot.oops.*;
  38 import sun.jvm.hotspot.types.*;
  39 import sun.jvm.hotspot.utilities.*;
  40 import sun.jvm.hotspot.runtime.*;
  41 import sun.jvm.hotspot.classfile.*;
  42 import sun.jvm.hotspot.utilities.Observable;
  43 import sun.jvm.hotspot.utilities.Observer;
  44 
  45 /** &lt;P&gt; This class encapsulates the global state of the VM; the
  46     universe, object heap, interpreter, etc. It is a Singleton and
  47     must be initialized with a call to initialize() before calling
  48     getVM(). &lt;/P&gt;
  49 
  50     &lt;P&gt; Many auxiliary classes (i.e., most of the VMObjects) keep
  51     needed field offsets in the form of static Field objects. In a
  52     debugging system, the VM might be shutdown and re-initialized (on
  53     a differently-configured build, i.e., 32- vs. 64-bit), and all old
  54     cached state (including fields and field offsets) must be
  55     flushed. &lt;/P&gt;
  56 
  57     &lt;P&gt; An Observer pattern is used to implement the initialization of
  58     such classes. Each such class, in its static initializer,
  59     registers an Observer with the VM class via
  60     VM.registerVMInitializedObserver(). This Observer is guaranteed to
  61     be notified whenever the VM is initialized (or re-initialized). To
  62     implement the first-time initialization, the observer is also
  63     notified when it registers itself with the VM. (For bootstrapping
  64     reasons, this implies that the constructor of VM can not
  65     instantiate any such objects, since VM.soleInstance will not have
  66     been set yet. This is a bootstrapping issue which may have to be
  67     revisited later.) &lt;/P&gt;
  68 */
  69 
  70 public class VM {
  71   private static VM    soleInstance;
  72   private static List&lt;Observer&gt; vmInitializedObservers = new ArrayList&lt;&gt;();
  73   private List&lt;Observer&gt; vmResumedObservers   = new ArrayList&lt;&gt;();
  74   private List&lt;Observer&gt; vmSuspendedObservers = new ArrayList&lt;&gt;();
  75   private TypeDataBase db;
  76   private boolean      isBigEndian;
  77   /** This is only present if in a debugging system */
  78   private JVMDebugger  debugger;
  79   private long         stackBias;
  80   private long         logAddressSize;
  81   private Universe     universe;
  82   private ObjectHeap   heap;
  83   private SystemDictionary dict;
  84   private ClassLoaderDataGraph cldGraph;
  85   private Threads      threads;
  86   private ObjectSynchronizer synchronizer;
  87   private JNIHandles   handles;
  88   private Interpreter  interpreter;
  89   private StubRoutines stubRoutines;
  90   private FileMapInfo  fileMapInfo;
  91   private Bytes        bytes;
  92 
  93   /** Flag indicating if JVMTI support is included in the build */
  94   private boolean      isJvmtiSupported;
  95   /** Flags indicating whether we are attached to a core, C1, or C2 build */
  96   private boolean      usingClientCompiler;
  97   private boolean      usingServerCompiler;
  98   /** alignment constants */
  99   private boolean      isLP64;
 100   private int          bytesPerLong;
 101   private int          bytesPerWord;
 102   private int          objectAlignmentInBytes;
 103   private int          minObjAlignmentInBytes;
 104   private int          logMinObjAlignmentInBytes;
 105   private int          heapWordSize;
 106   private int          heapOopSize;
 107   private int          klassPtrSize;
 108   private int          oopSize;
 109   /** -XX flags (value origin) */
 110   public static int    Flags_DEFAULT;
 111   public static int    Flags_COMMAND_LINE;
 112   public static int    Flags_ENVIRON_VAR;
 113   public static int    Flags_CONFIG_FILE;
 114   public static int    Flags_MANAGEMENT;
 115   public static int    Flags_ERGONOMIC;
 116   public static int    Flags_ATTACH_ON_DEMAND;
 117   public static int    Flags_INTERNAL;
 118   public static int    Flags_JIMAGE_RESOURCE;
 119   private static int   Flags_VALUE_ORIGIN_MASK;
 120   private static int   Flags_ORIG_COMMAND_LINE;
 121   /** This is only present in a non-core build */
 122   private CodeCache    codeCache;
 123   /** This is only present in a C1 build */
 124   private Runtime1     runtime1;
 125   /** These constants come from globalDefinitions.hpp */
 126   private int          invocationEntryBCI;
 127   private ReversePtrs  revPtrs;
 128   private VMRegImpl    vmregImpl;
 129   private int          reserveForAllocationPrefetch;
 130 
 131   // System.getProperties from debuggee VM
 132   private Properties   sysProps;
 133 
 134   // VM version strings come from Abstract_VM_Version class
 135   private String       vmRelease;
 136   private String       vmInternalInfo;
 137 
 138   private Flag[] commandLineFlags;
 139   private Map&lt;String, Flag&gt; flagsMap;
 140 
 141   private static Type intType;
 142   private static Type uintType;
 143   private static Type intxType;
 144   private static Type uintxType;
 145   private static Type sizetType;
 146   private static Type uint64tType;
 147   private static CIntegerType boolType;
 148   private Boolean sharingEnabled;
 149   private Boolean compressedOopsEnabled;
 150   private Boolean compressedKlassPointersEnabled;
 151 
 152   // command line flags supplied to VM - see struct JVMFlag in jvmFlag.hpp
 153   public static final class Flag {
 154      private String type;
 155      private String name;
 156      private Address addr;
 157      private int flags;
 158 
 159      private Flag(String type, String name, Address addr, int flags) {
 160         this.type = type;
 161         this.name = name;
 162         this.addr = addr;
 163         this.flags = flags;
 164      }
 165 
 166      public String getType() {
 167         return type;
 168      }
 169 
 170      public String getName() {
 171         return name;
 172      }
 173 
 174      public Address getAddress() {
 175         return addr;
 176      }
 177 
 178      public int getOrigin() {
 179         return flags &amp; Flags_VALUE_ORIGIN_MASK;
 180      }
 181 
 182      // See JVMFlag::print_origin() in HotSpot
 183      public String getOriginString() {
 184         var origin = flags &amp; Flags_VALUE_ORIGIN_MASK;
 185         if (origin == Flags_DEFAULT) {
 186             return &quot;default&quot;;
 187         } else if (origin == Flags_COMMAND_LINE) {
 188             return &quot;command line&quot;;
 189         } else if (origin == Flags_ENVIRON_VAR) {
 190             return &quot;environment&quot;;
 191         } else if (origin == Flags_CONFIG_FILE) {
 192             return &quot;config file&quot;;
 193         } else if (origin == Flags_MANAGEMENT) {
 194             return &quot;management&quot;;
 195         } else if (origin == Flags_ERGONOMIC) {
 196             String result = &quot;&quot;;
 197             if ((flags &amp; Flags_ORIG_COMMAND_LINE) == Flags_ORIG_COMMAND_LINE) {
 198                 result = &quot;command line, &quot;;
 199             }
 200             return result + &quot;ergonomic&quot;;
 201         } else if (origin == Flags_ATTACH_ON_DEMAND) {
 202             return &quot;attach&quot;;
 203         } else if (origin == Flags_INTERNAL) {
 204             return &quot;internal&quot;;
 205         } else if (origin == Flags_JIMAGE_RESOURCE) {
 206             return &quot;jimage&quot;;
 207         } else {
 208             throw new IllegalStateException(
 209                 &quot;Unknown flag origin &quot; + origin + &quot; is detected in &quot; + name);
 210         }
 211      }
 212 
 213      public boolean isBool() {
 214         return type.equals(&quot;bool&quot;);
 215      }
 216 
 217      public boolean getBool() {
 218         if (Assert.ASSERTS_ENABLED) {
 219            Assert.that(isBool(), &quot;not a bool flag!&quot;);
 220         }
 221         return addr.getCIntegerAt(0, boolType.getSize(), boolType.isUnsigned()) != 0;
 222      }
 223 
 224      public boolean isInt() {
 225         return type.equals(&quot;int&quot;);
 226      }
 227 
 228      public long getInt() {
 229         if (Assert.ASSERTS_ENABLED) {
 230            Assert.that(isInt(), &quot;not an int flag!&quot;);
 231         }
 232         return addr.getCIntegerAt(0, intType.getSize(), false);
 233      }
 234 
 235      public boolean isUInt() {
 236         return type.equals(&quot;uint&quot;);
 237      }
 238 
 239      public long getUInt() {
 240         if (Assert.ASSERTS_ENABLED) {
 241            Assert.that(isUInt(), &quot;not a uint flag!&quot;);
 242         }
 243         return addr.getCIntegerAt(0, uintType.getSize(), false);
 244      }
 245 
 246      public boolean isIntx() {
 247         return type.equals(&quot;intx&quot;);
 248      }
 249 
 250      public long getIntx() {
 251         if (Assert.ASSERTS_ENABLED) {
 252            Assert.that(isIntx(), &quot;not an intx flag!&quot;);
 253         }
 254         return addr.getCIntegerAt(0, intxType.getSize(), false);
 255      }
 256 
 257      public boolean isUIntx() {
 258         return type.equals(&quot;uintx&quot;);
 259      }
 260 
 261      public long getUIntx() {
 262         if (Assert.ASSERTS_ENABLED) {
 263            Assert.that(isUIntx(), &quot;not a uintx flag!&quot;);
 264         }
 265         return addr.getCIntegerAt(0, uintxType.getSize(), true);
 266      }
 267 
 268      public boolean isSizet() {
 269         return type.equals(&quot;size_t&quot;);
 270      }
 271 
 272      public long getSizet() {
 273         if (Assert.ASSERTS_ENABLED) {
 274            Assert.that(isSizet(), &quot;not a size_t flag!&quot;);
 275         }
 276         return addr.getCIntegerAt(0, sizetType.getSize(), true);
 277      }
 278 
 279      public boolean isCcstr() {
 280         return type.equals(&quot;ccstr&quot;);
 281      }
 282 
 283      public String getCcstr() {
 284         if (Assert.ASSERTS_ENABLED) {
 285            Assert.that(isCcstr(), &quot;not a ccstr flag!&quot;);
 286         }
 287         return CStringUtilities.getString(addr.getAddressAt(0));
 288      }
 289 
 290      public boolean isCcstrlist() {
 291         return type.equals(&quot;ccstrlist&quot;);
 292      }
 293 
 294      public String getCcstrlist() {
 295         if (Assert.ASSERTS_ENABLED) {
 296            Assert.that(isCcstrlist(), &quot;not a ccstrlist flag!&quot;);
 297         }
 298         return CStringUtilities.getString(addr.getAddressAt(0));
 299      }
 300 
 301      public boolean isDouble() {
 302         return type.equals(&quot;double&quot;);
 303      }
 304 
 305      public double getDouble() {
 306         if (Assert.ASSERTS_ENABLED) {
 307            Assert.that(isDouble(), &quot;not a double flag!&quot;);
 308         }
 309         return addr.getJDoubleAt(0);
 310      }
 311 
 312      public boolean isUint64t() {
 313         return type.equals(&quot;uint64_t&quot;);
 314      }
 315 
 316      public long getUint64t() {
 317         if (Assert.ASSERTS_ENABLED) {
 318            Assert.that(isUint64t(), &quot;not an uint64_t flag!&quot;);
 319         }
 320         return addr.getCIntegerAt(0, uint64tType.getSize(), true);
 321      }
 322 
 323      public String getValue() {
 324         if (isBool()) {
 325            return Boolean.toString(getBool());
 326         } else if (isInt()) {
 327            return Long.toString(getInt());
 328         } else if (isUInt()) {
 329            return Long.toString(getUInt());
 330         } else if (isIntx()) {
 331            return Long.toString(getIntx());
 332         } else if (isUIntx()) {
 333            return Long.toUnsignedString(getUIntx());
 334         } else if (isSizet()) {
 335            return Long.toUnsignedString(getSizet());
 336         } else if (isCcstr()) {
 337            var str = getCcstr();
 338            if (str != null) {
 339                str = &quot;\&quot;&quot; + str + &quot;\&quot;&quot;;
 340            }
 341            return str;
 342         } else if (isCcstrlist()) {
 343            var str = getCcstrlist();
 344            if (str != null) {
 345                str = &quot;\&quot;&quot; + str + &quot;\&quot;&quot;;
 346            }
 347            return str;
 348         } else if (isDouble()) {
 349            return Double.toString(getDouble());
 350         } else if (isUint64t()) {
 351            return Long.toUnsignedString(getUint64t());
 352         } else {
 353            throw new WrongTypeException(&quot;Unknown type: &quot; + type + &quot; (&quot; + name + &quot;)&quot;);
 354         }
 355      }
 356   };
 357 
 358   private static void checkVMVersion(String vmRelease) {
 359      if (System.getProperty(&quot;sun.jvm.hotspot.runtime.VM.disableVersionCheck&quot;) == null) {
 360         // read sa build version.
 361         String versionProp = &quot;sun.jvm.hotspot.runtime.VM.saBuildVersion&quot;;
 362         String saVersion = saProps.getProperty(versionProp);
 363         if (saVersion == null)
 364            throw new RuntimeException(&quot;Missing property &quot; + versionProp);
 365 
 366         // Strip nonproduct VM version substring (note: saVersion doesn&#39;t have it).
 367         String vmVersion = vmRelease.replaceAll(&quot;(-fastdebug)|(-debug)|(-jvmg)|(-optimized)|(-profiled)&quot;,&quot;&quot;);
 368 
 369         if (saVersion.equals(vmVersion)) {
 370            // Exact match
 371            return;
 372         }
 373         if (saVersion.indexOf(&#39;-&#39;) == saVersion.lastIndexOf(&#39;-&#39;) &amp;&amp;
 374             vmVersion.indexOf(&#39;-&#39;) == vmVersion.lastIndexOf(&#39;-&#39;)) {
 375            // Throw exception if different release versions:
 376            // &lt;major&gt;.&lt;minor&gt;-b&lt;n&gt;
 377            throw new VMVersionMismatchException(saVersion, vmRelease);
 378         } else {
 379            // Otherwise print warning to allow mismatch not release versions
 380            // during development.
 381            System.err.println(&quot;WARNING: Hotspot VM version &quot; + vmRelease +
 382                               &quot; does not match with SA version &quot; + saVersion +
 383                               &quot;.&quot; + &quot; You may see unexpected results. &quot;);
 384         }
 385      } else {
 386         System.err.println(&quot;WARNING: You have disabled SA and VM version check. You may be &quot;  +
 387                            &quot;using incompatible version of SA and you may see unexpected &quot; +
 388                            &quot;results.&quot;);
 389      }
 390   }
 391 
 392   private static final boolean disableDerivedPointerTableCheck;
 393   private static final Properties saProps;
 394 
 395   static {
 396      saProps = new Properties();
 397      URL url = null;
 398      try {
 399        saProps.load(VM.class.getResourceAsStream(&quot;/sa.properties&quot;));
 400      } catch (Exception e) {
 401        System.err.println(&quot;Unable to load properties  &quot; +
 402                                   (url == null ? &quot;null&quot; : url.toString()) +
 403                                   &quot;: &quot; + e.getMessage());
 404      }
 405 
 406      disableDerivedPointerTableCheck = System.getProperty(&quot;sun.jvm.hotspot.runtime.VM.disableDerivedPointerTableCheck&quot;) != null;
 407   }
 408 
 409   private VM(TypeDataBase db, JVMDebugger debugger, boolean isBigEndian) {
 410     this.db          = db;
 411     this.debugger    = debugger;
 412     this.isBigEndian = isBigEndian;
 413 
 414     // Note that we don&#39;t construct universe, heap, threads,
 415     // interpreter, or stubRoutines here (any more).  The current
 416     // initialization mechanisms require that the VM be completely set
 417     // up (i.e., out of its constructor, with soleInstance assigned)
 418     // before their static initializers are run.
 419 
 420     if (db.getAddressSize() == 4) {
 421       logAddressSize = 2;
 422     } else if (db.getAddressSize() == 8) {
 423       logAddressSize = 3;
 424     } else {
 425       throw new RuntimeException(&quot;Address size &quot; + db.getAddressSize() + &quot; not yet supported&quot;);
 426     }
 427 
 428     // read VM version info
 429     try {
 430        Type vmVersion = db.lookupType(&quot;Abstract_VM_Version&quot;);
 431        Address releaseAddr = vmVersion.getAddressField(&quot;_s_vm_release&quot;).getValue();
 432        vmRelease = CStringUtilities.getString(releaseAddr);
 433        Address vmInternalInfoAddr = vmVersion.getAddressField(&quot;_s_internal_vm_info_string&quot;).getValue();
 434        vmInternalInfo = CStringUtilities.getString(vmInternalInfoAddr);
 435 
 436        Type threadLocalAllocBuffer = db.lookupType(&quot;ThreadLocalAllocBuffer&quot;);
 437        CIntegerType intType = (CIntegerType) db.lookupType(&quot;int&quot;);
 438        CIntegerField reserveForAllocationPrefetchField = threadLocalAllocBuffer.getCIntegerField(&quot;_reserve_for_allocation_prefetch&quot;);
 439        reserveForAllocationPrefetch = (int)reserveForAllocationPrefetchField.getCInteger(intType);
 440     } catch (Exception exp) {
 441        throw new RuntimeException(&quot;can&#39;t determine target&#39;s VM version : &quot; + exp.getMessage());
 442     }
 443 
 444     checkVMVersion(vmRelease);
 445 
 446     stackBias    = db.lookupIntConstant(&quot;STACK_BIAS&quot;).intValue();
 447     invocationEntryBCI = db.lookupIntConstant(&quot;InvocationEntryBci&quot;).intValue();
 448 
 449     // We infer the presence of JVMTI from the presence of the InstanceKlass::_breakpoints field.
 450     {
 451       Type type = db.lookupType(&quot;InstanceKlass&quot;);
 452       if (type.getField(&quot;_breakpoints&quot;, false, false) == null) {
 453         isJvmtiSupported = false;
 454       } else {
 455         isJvmtiSupported = true;
 456       }
 457     }
 458 
 459     // We infer the presence of C1 or C2 from a couple of fields we
 460     // already have present in the type database
 461     {
 462       Type type = db.lookupType(&quot;Method&quot;);
 463       if (type.getField(&quot;_from_compiled_entry&quot;, false, false) == null) {
 464         // Neither C1 nor C2 is present
 465         usingClientCompiler = false;
 466         usingServerCompiler = false;
 467       } else {
 468         // Determine whether C2 is present
 469         if (db.lookupType(&quot;Matcher&quot;, false) != null) {
 470           usingServerCompiler = true;
 471         } else {
 472           usingClientCompiler = true;
 473         }
 474       }
 475     }
 476 
 477     if (debugger != null) {
 478       isLP64 = debugger.getMachineDescription().isLP64();
 479     }
 480     bytesPerLong = db.lookupIntConstant(&quot;BytesPerLong&quot;).intValue();
 481     bytesPerWord = db.lookupIntConstant(&quot;BytesPerWord&quot;).intValue();
 482     heapWordSize = db.lookupIntConstant(&quot;HeapWordSize&quot;).intValue();
 483     Flags_DEFAULT = db.lookupIntConstant(&quot;JVMFlag::DEFAULT&quot;).intValue();
 484     Flags_COMMAND_LINE = db.lookupIntConstant(&quot;JVMFlag::COMMAND_LINE&quot;).intValue();
 485     Flags_ENVIRON_VAR = db.lookupIntConstant(&quot;JVMFlag::ENVIRON_VAR&quot;).intValue();
 486     Flags_CONFIG_FILE = db.lookupIntConstant(&quot;JVMFlag::CONFIG_FILE&quot;).intValue();
 487     Flags_MANAGEMENT = db.lookupIntConstant(&quot;JVMFlag::MANAGEMENT&quot;).intValue();
 488     Flags_ERGONOMIC = db.lookupIntConstant(&quot;JVMFlag::ERGONOMIC&quot;).intValue();
 489     Flags_ATTACH_ON_DEMAND = db.lookupIntConstant(&quot;JVMFlag::ATTACH_ON_DEMAND&quot;).intValue();
 490     Flags_INTERNAL = db.lookupIntConstant(&quot;JVMFlag::INTERNAL&quot;).intValue();
 491     Flags_JIMAGE_RESOURCE = db.lookupIntConstant(&quot;JVMFlag::JIMAGE_RESOURCE&quot;).intValue();
 492     Flags_VALUE_ORIGIN_MASK = db.lookupIntConstant(&quot;JVMFlag::VALUE_ORIGIN_MASK&quot;).intValue();
 493     Flags_ORIG_COMMAND_LINE = db.lookupIntConstant(&quot;JVMFlag::ORIG_COMMAND_LINE&quot;).intValue();
 494     oopSize  = db.lookupIntConstant(&quot;oopSize&quot;).intValue();
 495 
 496     intType = db.lookupType(&quot;int&quot;);
 497     uintType = db.lookupType(&quot;uint&quot;);
 498     intxType = db.lookupType(&quot;intx&quot;);
 499     uintxType = db.lookupType(&quot;uintx&quot;);
 500     sizetType = db.lookupType(&quot;size_t&quot;);
 501     uint64tType = db.lookupType(&quot;uint64_t&quot;);
 502     boolType = (CIntegerType) db.lookupType(&quot;bool&quot;);
 503 
 504     minObjAlignmentInBytes = getObjectAlignmentInBytes();
 505     if (minObjAlignmentInBytes == 8) {
 506       logMinObjAlignmentInBytes = 3;
 507     } else if (minObjAlignmentInBytes == 16) {
 508       logMinObjAlignmentInBytes = 4;
 509     } else {
 510       throw new RuntimeException(&quot;Object alignment &quot; + minObjAlignmentInBytes + &quot; not yet supported&quot;);
 511     }
 512 
 513     if (isCompressedOopsEnabled()) {
 514       // Size info for oops within java objects is fixed
 515       heapOopSize = (int)getIntSize();
 516     } else {
 517       heapOopSize = (int)getOopSize();
 518     }
 519 
 520     if (isCompressedKlassPointersEnabled()) {
 521       klassPtrSize = (int)getIntSize();
 522     } else {
 523       klassPtrSize = (int)getOopSize(); // same as an oop
 524     }
 525   }
 526 
 527   /** This could be used by a reflective runtime system */
 528   public static void initialize(TypeDataBase db, boolean isBigEndian) {
 529     if (soleInstance != null) {
 530       throw new RuntimeException(&quot;Attempt to initialize VM twice&quot;);
 531     }
 532     soleInstance = new VM(db, null, isBigEndian);
 533     for (Iterator iter = vmInitializedObservers.iterator(); iter.hasNext(); ) {
 534       ((Observer) iter.next()).update(null, null);
 535     }
 536   }
 537 
 538   /** This is used by the debugging system */
 539   public static void initialize(TypeDataBase db, JVMDebugger debugger) {
 540     if (soleInstance != null) {
 541       // Using multiple SA Tool classes in the same process creates a call here.
 542       return;
 543     }
 544     soleInstance = new VM(db, debugger, debugger.getMachineDescription().isBigEndian());
 545 
 546     for (Iterator iter = vmInitializedObservers.iterator(); iter.hasNext(); ) {
 547       ((Observer) iter.next()).update(null, null);
 548     }
 549 
 550     debugger.putHeapConst(soleInstance.getHeapOopSize(), soleInstance.getKlassPtrSize(),
 551                           CompressedOops.getBase(), CompressedOops.getShift(),
 552                           CompressedKlassPointers.getBase(), CompressedKlassPointers.getShift());
 553   }
 554 
 555   /** This is used by the debugging system */
 556   public static void shutdown() {
 557     soleInstance = null;
 558   }
 559 
 560   /** This is used by both the debugger and any runtime system. It is
 561       the basic mechanism by which classes which mimic underlying VM
 562       functionality cause themselves to be initialized. The given
 563       observer will be notified (with arguments (null, null)) when the
 564       VM is re-initialized, as well as when it registers itself with
 565       the VM. */
 566   public static void registerVMInitializedObserver(Observer o) {
 567     vmInitializedObservers.add(o);
 568     o.update(null, null);
 569   }
 570 
 571   /** This is the primary accessor used by both the debugger and any
 572       potential runtime system */
 573   public static VM getVM() {
 574     if (soleInstance == null) {
 575       throw new RuntimeException(&quot;VM.initialize() was not yet called&quot;);
 576     }
 577     return soleInstance;
 578   }
 579 
 580   /** This is only used by the debugging system. The given observer
 581       will be notified if the underlying VM resumes execution. NOTE
 582       that the given observer is not triggered if the VM is currently
 583       running and therefore differs in behavior from {@link
 584       #registerVMInitializedObserver} (because of the possibility of
 585       race conditions if the observer is added while the VM is being
 586       suspended or resumed).  */
 587   public void registerVMResumedObserver(Observer o) {
 588     vmResumedObservers.add(o);
 589   }
 590 
 591   /** This is only used by the debugging system. The given observer
 592       will be notified if the underlying VM suspends execution. NOTE
 593       that the given observer is not triggered if the VM is currently
 594       suspended and therefore differs in behavior from {@link
 595       #registerVMInitializedObserver} (because of the possibility of
 596       race conditions if the observer is added while the VM is being
 597       suspended or resumed).  */
 598   public void registerVMSuspendedObserver(Observer o) {
 599     vmSuspendedObservers.add(o);
 600   }
 601 
 602   /** This is only used by the debugging system. Informs all
 603       registered resumption observers that the VM has been resumed.
 604       The application is responsible for actually having performed the
 605       resumption. No OopHandles must be used after this point, as they
 606       may move in the target address space due to garbage
 607       collection. */
 608   public void fireVMResumed() {
 609     for (Iterator iter = vmResumedObservers.iterator(); iter.hasNext(); ) {
 610       ((Observer) iter.next()).update(null, null);
 611     }
 612   }
 613 
 614   /** This is only used by the debugging system. Informs all
 615       registered suspension observers that the VM has been suspended.
 616       The application is responsible for actually having performed the
 617       suspension. Garbage collection must be forbidden at this point;
 618       for example, a JPDA-level suspension is not adequate since the
 619       VM thread may still be running. */
 620   public void fireVMSuspended() {
 621     for (Iterator iter = vmSuspendedObservers.iterator(); iter.hasNext(); ) {
 622       ((Observer) iter.next()).update(null, null);
 623     }
 624   }
 625 
 626   /** Returns the OS this VM is running on. Notice that by delegating
 627       to the debugger we can transparently support remote
 628       debugging. */
 629   public String getOS() {
 630     if (debugger != null) {
 631       return debugger.getOS();
 632     }
 633     return PlatformInfo.getOS();
 634   }
 635 
 636   /** Returns the CPU this VM is running on. Notice that by delegating
 637       to the debugger we can transparently support remote
 638       debugging. */
 639   public String getCPU() {
 640     if (debugger != null) {
 641       return debugger.getCPU();
 642     }
 643     return PlatformInfo.getCPU();
 644   }
 645 
 646   public Type lookupType(String cTypeName) {
 647     return db.lookupType(cTypeName);
 648   }
 649 
 650   public Integer lookupIntConstant(String name) {
 651     return db.lookupIntConstant(name);
 652   }
 653 
 654   // Convenience function for conversions
 655   static public long getAddressValue(Address addr) {
 656     return VM.getVM().getDebugger().getAddressValue(addr);
 657   }
 658 
 659   public long getAddressSize() {
 660     return db.getAddressSize();
 661   }
 662 
 663   public long getOopSize() {
 664     return oopSize;
 665   }
 666 
 667   public long getLogAddressSize() {
 668     return logAddressSize;
 669   }
 670 
 671   public long getIntSize() {
 672     return db.getJIntType().getSize();
 673   }
 674 
 675   /** NOTE: this offset is in BYTES in this system! */
 676   public long getStackBias() {
 677     return stackBias;
 678   }
 679 
 680   /** Indicates whether the underlying machine supports the LP64 data
 681       model. This is needed for conditionalizing code in a few places */
 682   public boolean isLP64() {
 683     if (Assert.ASSERTS_ENABLED) {
 684       Assert.that(isDebugging(), &quot;Debugging system only for now&quot;);
 685     }
 686     return isLP64;
 687   }
 688 
 689   /** Get bytes-per-long == long/double natural alignment. */
 690   public int getBytesPerLong() {
 691     return bytesPerLong;
 692   }
 693 
 694   public int getBytesPerWord() {
 695     return bytesPerWord;
 696   }
 697 
 698   /** Get minimum object alignment in bytes. */
 699   public int getMinObjAlignmentInBytes() {
 700     return minObjAlignmentInBytes;
 701   }
 702   public int getLogMinObjAlignmentInBytes() {
 703     return logMinObjAlignmentInBytes;
 704   }
 705 
 706   public int getHeapWordSize() {
 707     return heapWordSize;
 708   }
 709 
 710   public int getHeapOopSize() {
 711     return heapOopSize;
 712   }
 713 
 714   public int getKlassPtrSize() {
 715     return klassPtrSize;
 716   }
 717   /** Utility routine for getting data structure alignment correct */
 718   public long alignUp(long size, long alignment) {
 719     return (size + alignment - 1) &amp; ~(alignment - 1);
 720   }
 721 
 722   /** Utility routine for getting data structure alignment correct */
 723   public long alignDown(long size, long alignment) {
 724     return size &amp; ~(alignment - 1);
 725   }
 726 
 727   /** Utility routine for building an int from two &quot;unsigned&quot; 16-bit
 728       shorts */
 729   public int buildIntFromShorts(short low, short high) {
 730     return (((int) high) &lt;&lt; 16) | (((int) low) &amp; 0xFFFF);
 731   }
 732 
 733   /** Utility routine for building a long from two &quot;unsigned&quot; 32-bit
 734       ints in &lt;b&gt;platform-dependent&lt;/b&gt; order */
 735   public long buildLongFromIntsPD(int oneHalf, int otherHalf) {
 736     if (isBigEndian) {
 737       return (((long) otherHalf) &lt;&lt; 32) | (((long) oneHalf) &amp; 0x00000000FFFFFFFFL);
 738     } else{
 739       return (((long) oneHalf) &lt;&lt; 32) | (((long) otherHalf) &amp; 0x00000000FFFFFFFFL);
 740     }
 741   }
 742 
 743   public TypeDataBase getTypeDataBase() {
 744     return db;
 745   }
 746 
 747   public Universe    getUniverse() {
 748     if (universe == null) {
 749       universe = new Universe();
 750     }
 751     return universe;
 752   }
 753 
 754   public ObjectHeap  getObjectHeap() {
 755     if (heap == null) {
 756       heap = new ObjectHeap(db);
 757     }
 758     return heap;
 759   }
 760 
 761   public SystemDictionary getSystemDictionary() {
 762     if (dict == null) {
 763       dict = new SystemDictionary();
 764     }
 765     return dict;
 766   }
 767 
 768   public ClassLoaderDataGraph getClassLoaderDataGraph() {
 769     if (cldGraph == null) {
 770       cldGraph = new ClassLoaderDataGraph();
 771     }
 772     return cldGraph;
 773   }
 774 
 775   public Threads     getThreads() {
 776     if (threads == null) {
 777       threads = new Threads();
 778     }
 779     return threads;
 780   }
 781 
 782   public ObjectSynchronizer getObjectSynchronizer() {
 783     if (synchronizer == null) {
 784       synchronizer = new ObjectSynchronizer();
 785     }
 786     return synchronizer;
 787   }
 788 
 789   public JNIHandles getJNIHandles() {
 790     if (handles == null) {
 791       handles = new JNIHandles();
 792     }
 793     return handles;
 794   }
 795 
 796   public Interpreter getInterpreter() {
 797     if (interpreter == null) {
 798       interpreter = new Interpreter();
 799     }
 800     return interpreter;
 801   }
 802 
 803   public StubRoutines getStubRoutines() {
 804     if (stubRoutines == null) {
 805       stubRoutines = new StubRoutines();
 806     }
 807     return stubRoutines;
 808   }
 809 
 810   public VMRegImpl getVMRegImplInfo() {
 811     if (vmregImpl == null) {
 812       vmregImpl = new VMRegImpl();
 813     }
 814     return vmregImpl;
 815   }
 816 
 817   public FileMapInfo getFileMapInfo() {
 818     if (!isSharingEnabled()) {
 819       return null;
 820     }
 821     if (fileMapInfo == null) {
 822       fileMapInfo = new FileMapInfo();
 823     }
 824     return fileMapInfo;
 825   }
 826 
 827   public Bytes getBytes() {
 828     if (bytes == null) {
 829       bytes = new Bytes(debugger.getMachineDescription());
 830     }
 831     return bytes;
 832   }
 833 
 834   /** Returns true if this is a isBigEndian, false otherwise */
 835   public boolean isBigEndian() {
 836     return isBigEndian;
 837   }
 838 
 839   /** Returns true if JVMTI is supported, false otherwise */
 840   public boolean isJvmtiSupported() {
 841     return isJvmtiSupported;
 842   }
 843 
 844   /** Returns true if this is a &quot;core&quot; build, false if either C1 or C2
 845       is present */
 846   public boolean isCore() {
 847     return (!(usingClientCompiler || usingServerCompiler));
 848   }
 849 
 850   /** Returns true if this is a C1 build, false otherwise */
 851   public boolean isClientCompiler() {
 852     return usingClientCompiler;
 853   }
 854 
 855   /** Returns true if this is a C2 build, false otherwise */
 856   public boolean isServerCompiler() {
 857     return usingServerCompiler;
 858   }
 859 
 860   /** Returns true if C2 derived pointer table should be used, false otherwise */
 861   public boolean useDerivedPointerTable() {
 862     return !disableDerivedPointerTableCheck;
 863   }
 864 
 865   /** Returns the code cache; should not be used if is core build */
 866   public CodeCache getCodeCache() {
 867     if (Assert.ASSERTS_ENABLED) {
 868       Assert.that(!isCore(), &quot;noncore builds only&quot;);
 869     }
 870     if (codeCache == null) {
 871       codeCache = new CodeCache();
 872     }
 873     return codeCache;
 874   }
 875 
 876   /** Should only be called for C1 builds */
 877   public Runtime1 getRuntime1() {
 878     if (Assert.ASSERTS_ENABLED) {
 879       Assert.that(isClientCompiler(), &quot;C1 builds only&quot;);
 880     }
 881     if (runtime1 == null) {
 882       runtime1 = new Runtime1();
 883     }
 884     return runtime1;
 885   }
 886 
 887   /** Test to see whether we&#39;re in debugging mode (NOTE: this really
 888       should not be tested by this code; currently only used in
 889       StackFrameStream) */
 890   public boolean isDebugging() {
 891     return (debugger != null);
 892   }
 893 
 894   /** This is only used by the debugging (i.e., non-runtime) system */
 895   public JVMDebugger getDebugger() {
 896     if (debugger == null) {
 897       throw new RuntimeException(&quot;Attempt to use debugger in runtime system&quot;);
 898     }
 899     return debugger;
 900   }
 901 
 902   /** Indicates whether a given program counter is in Java code. This
 903       includes but is not spanned by the interpreter and code cache.
 904       Only used in the debugging system, for implementing
 905       JavaThread.currentFrameGuess() on x86. */
 906   public boolean isJavaPCDbg(Address addr) {
 907     // FIXME: this is not a complete enough set: must include areas
 908     // like vtable stubs
 909     return (getInterpreter().contains(addr) ||
 910             getCodeCache().contains(addr));
 911   }
 912 
 913   /** FIXME: figure out where to stick this */
 914   public int getInvocationEntryBCI() {
 915     return invocationEntryBCI;
 916   }
 917 
 918   // FIXME: figure out where to stick this
 919   public boolean wizardMode() {
 920     return true;
 921   }
 922 
 923   public ReversePtrs getRevPtrs() {
 924     return revPtrs;
 925   }
 926 
 927   public void setRevPtrs(ReversePtrs rp) {
 928     revPtrs = rp;
 929   }
 930 
 931   // returns null, if not available.
 932   public String getVMRelease() {
 933     return vmRelease;
 934   }
 935 
 936   // returns null, if not available.
 937   public String getVMInternalInfo() {
 938     return vmInternalInfo;
 939   }
 940 
 941   public int getReserveForAllocationPrefetch() {
 942     return reserveForAllocationPrefetch;
 943   }
 944 
 945   public boolean isSharingEnabled() {
 946     if (sharingEnabled == null) {
 947       Flag flag = getCommandLineFlag(&quot;UseSharedSpaces&quot;);
 948       sharingEnabled = (flag == null)? Boolean.FALSE :
 949           (flag.getBool()? Boolean.TRUE: Boolean.FALSE);
 950     }
 951     return sharingEnabled.booleanValue();
 952   }
 953 
 954   public boolean isCompressedOopsEnabled() {
 955     if (compressedOopsEnabled == null) {
 956         Flag flag = getCommandLineFlag(&quot;UseCompressedOops&quot;);
 957         compressedOopsEnabled = (flag == null) ? Boolean.FALSE:
 958              (flag.getBool()? Boolean.TRUE: Boolean.FALSE);
 959     }
 960     return compressedOopsEnabled.booleanValue();
 961   }
 962 
 963   public boolean isCompressedKlassPointersEnabled() {
 964     if (compressedKlassPointersEnabled == null) {
 965         Flag flag = getCommandLineFlag(&quot;UseCompressedClassPointers&quot;);
 966         compressedKlassPointersEnabled = (flag == null) ? Boolean.FALSE:
 967              (flag.getBool()? Boolean.TRUE: Boolean.FALSE);
 968     }
 969     return compressedKlassPointersEnabled.booleanValue();
 970   }
 971 
 972   public int getObjectAlignmentInBytes() {
 973     if (objectAlignmentInBytes == 0) {
 974         Flag flag = getCommandLineFlag(&quot;ObjectAlignmentInBytes&quot;);
 975         objectAlignmentInBytes = (flag == null) ? 8 : (int)flag.getIntx();
 976     }
 977     return objectAlignmentInBytes;
 978   }
 979 
 980   /** Indicates whether Thread-Local Allocation Buffers are used */
 981   public boolean getUseTLAB() {
 982       Flag flag = getCommandLineFlag(&quot;UseTLAB&quot;);
 983       return (flag == null) ? false: flag.getBool();
 984   }
 985 
 986   public boolean getCommandLineBooleanFlag(String name) {
 987     Flag flag = getCommandLineFlag(name);
 988     return (flag == null) ? Boolean.FALSE:
 989       (flag.getBool()? Boolean.TRUE: Boolean.FALSE);
 990   }
 991 
 992   // returns null, if not available.
 993   public Flag[] getCommandLineFlags() {
 994     if (commandLineFlags == null) {
 995        readCommandLineFlags();
 996     }
 997 
 998     return commandLineFlags;
 999   }
1000 
1001   public Flag getCommandLineFlag(String name) {
1002     if (flagsMap == null) {
1003       flagsMap = new HashMap&lt;&gt;();
1004       Flag[] flags = getCommandLineFlags();
1005       for (int i = 0; i &lt; flags.length; i++) {
1006         flagsMap.put(flags[i].getName(), flags[i]);
1007       }
1008     }
1009     return (Flag) flagsMap.get(name);
1010   }
1011 
1012   private void readCommandLineFlags() {
1013     // get command line flags
1014     TypeDataBase db = getTypeDataBase();
1015     Type flagType = db.lookupType(&quot;JVMFlag&quot;);
1016     int numFlags = (int) flagType.getCIntegerField(&quot;numFlags&quot;).getValue();
1017     // NOTE: last flag contains null values.
1018     commandLineFlags = new Flag[numFlags - 1];
1019 
1020     Address flagAddr = flagType.getAddressField(&quot;flags&quot;).getValue();
1021 
1022     AddressField typeFld = flagType.getAddressField(&quot;_type&quot;);
1023     AddressField nameFld = flagType.getAddressField(&quot;_name&quot;);
1024     AddressField addrFld = flagType.getAddressField(&quot;_addr&quot;);
1025     CIntField flagsFld = new CIntField(flagType.getCIntegerField(&quot;_flags&quot;), 0);
1026 
1027     long flagSize = flagType.getSize(); // sizeof(Flag)
1028 
1029     // NOTE: last flag contains null values.
1030     for (int f = 0; f &lt; numFlags - 1; f++) {
1031       String type = CStringUtilities.getString(typeFld.getValue(flagAddr));
1032       String name = CStringUtilities.getString(nameFld.getValue(flagAddr));
1033       Address addr = addrFld.getValue(flagAddr);
1034       int flags = (int)flagsFld.getValue(flagAddr);
1035       commandLineFlags[f] = new Flag(type, name, addr, flags);
1036       flagAddr = flagAddr.addOffsetTo(flagSize);
1037     }
1038 
1039     // sort flags by name
1040     Arrays.sort(commandLineFlags, new Comparator&lt;&gt;() {
1041         public int compare(Flag f1, Flag f2) {
1042           return f1.getName().compareTo(f2.getName());
1043         }
1044       });
1045   }
1046 
1047   public String getSystemProperty(String key) {
1048     Properties props = getSystemProperties();
1049     return (props != null)? props.getProperty(key) : null;
1050   }
1051 
1052   public Properties getSystemProperties() {
1053     if (sysProps == null) {
1054        readSystemProperties();
1055     }
1056     return sysProps;
1057   }
1058 
1059   private void readSystemProperties() {
1060     final InstanceKlass systemKls = getSystemDictionary().getSystemKlass();
1061     systemKls.iterateStaticFields(new DefaultOopVisitor() {
1062         ObjectReader objReader = new ObjectReader();
1063         public void doOop(sun.jvm.hotspot.oops.OopField field, boolean isVMField) {
1064           if (field.getID().getName().equals(&quot;props&quot;)) {
1065             try {
1066               sysProps = (Properties) objReader.readObject(field.getValue(getObj()));
1067             } catch (Exception e) {
1068               e.printStackTrace();
1069             }
1070           }
1071         }
1072       });
1073   }
1074 }
    </pre>
  </body>
</html>
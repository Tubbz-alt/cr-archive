<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/oops/InstanceKlass.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 package sun.jvm.hotspot.oops;
  26 
  27 import java.io.*;
  28 import java.util.*;
  29 import sun.jvm.hotspot.classfile.ClassLoaderData;
  30 import sun.jvm.hotspot.debugger.*;
  31 import sun.jvm.hotspot.memory.*;
  32 import sun.jvm.hotspot.memory.Dictionary;
  33 import sun.jvm.hotspot.runtime.*;
  34 import sun.jvm.hotspot.types.*;
  35 import sun.jvm.hotspot.utilities.*;
  36 import sun.jvm.hotspot.utilities.Observable;
  37 import sun.jvm.hotspot.utilities.Observer;
  38 
  39 // An InstanceKlass is the VM level representation of a Java class.
  40 
  41 public class InstanceKlass extends Klass {
  42   static {
  43     VM.registerVMInitializedObserver(new Observer() {
  44         public void update(Observable o, Object data) {
  45           initialize(VM.getVM().getTypeDataBase());
  46         }
  47       });
  48   }
  49 
  50   // field offset constants
  51   private static int ACCESS_FLAGS_OFFSET;
  52   private static int NAME_INDEX_OFFSET;
  53   private static int SIGNATURE_INDEX_OFFSET;
  54   private static int INITVAL_INDEX_OFFSET;
  55   private static int LOW_OFFSET;
  56   private static int HIGH_OFFSET;
  57   private static int FIELD_SLOTS;
  58   private static short FIELDINFO_TAG_SIZE;
  59   private static short FIELDINFO_TAG_MASK;
  60   private static short FIELDINFO_TAG_OFFSET;
  61 
  62   // ClassState constants
  63   private static int CLASS_STATE_ALLOCATED;
  64   private static int CLASS_STATE_LOADED;
  65   private static int CLASS_STATE_LINKED;
  66   private static int CLASS_STATE_BEING_INITIALIZED;
  67   private static int CLASS_STATE_FULLY_INITIALIZED;
  68   private static int CLASS_STATE_INITIALIZATION_ERROR;
  69 
  70   // _misc_flags constants
  71   private static int MISC_REWRITTEN;
  72   private static int MISC_HAS_NONSTATIC_FIELDS;
  73   private static int MISC_SHOULD_VERIFY_CLASS;
  74   private static int MISC_IS_UNSAFE_ANONYMOUS;
  75   private static int MISC_IS_CONTENDED;
  76   private static int MISC_HAS_NONSTATIC_CONCRETE_METHODS;
  77   private static int MISC_DECLARES_NONSTATIC_CONCRETE_METHODS;
  78   private static int MISC_HAS_BEEN_REDEFINED;
  79   private static int MISC_HAS_PASSED_FINGERPRINT_CHECK;
  80   private static int MISC_IS_SCRATCH_CLASS;
  81   private static int MISC_IS_SHARED_BOOT_CLASS;
  82   private static int MISC_IS_SHARED_PLATFORM_CLASS;
  83   private static int MISC_IS_SHARED_APP_CLASS;
  84 
  85   private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {
  86     Type type            = db.lookupType(&quot;InstanceKlass&quot;);
  87     arrayKlasses         = new MetadataField(type.getAddressField(&quot;_array_klasses&quot;), 0);
  88     methods              = type.getAddressField(&quot;_methods&quot;);
  89     defaultMethods       = type.getAddressField(&quot;_default_methods&quot;);
  90     methodOrdering       = type.getAddressField(&quot;_method_ordering&quot;);
  91     localInterfaces      = type.getAddressField(&quot;_local_interfaces&quot;);
  92     transitiveInterfaces = type.getAddressField(&quot;_transitive_interfaces&quot;);
  93     fields               = type.getAddressField(&quot;_fields&quot;);
  94     javaFieldsCount      = new CIntField(type.getCIntegerField(&quot;_java_fields_count&quot;), 0);
  95     constants            = new MetadataField(type.getAddressField(&quot;_constants&quot;), 0);
  96     sourceDebugExtension = type.getAddressField(&quot;_source_debug_extension&quot;);
  97     innerClasses         = type.getAddressField(&quot;_inner_classes&quot;);
  98     nonstaticFieldSize   = new CIntField(type.getCIntegerField(&quot;_nonstatic_field_size&quot;), 0);
  99     staticFieldSize      = new CIntField(type.getCIntegerField(&quot;_static_field_size&quot;), 0);
 100     staticOopFieldCount  = new CIntField(type.getCIntegerField(&quot;_static_oop_field_count&quot;), 0);
 101     nonstaticOopMapSize  = new CIntField(type.getCIntegerField(&quot;_nonstatic_oop_map_size&quot;), 0);
 102     isMarkedDependent    = new CIntField(type.getCIntegerField(&quot;_is_marked_dependent&quot;), 0);
 103     initState            = new CIntField(type.getCIntegerField(&quot;_init_state&quot;), 0);
 104     itableLen            = new CIntField(type.getCIntegerField(&quot;_itable_len&quot;), 0);
 105     if (VM.getVM().isJvmtiSupported()) {
 106       breakpoints        = type.getAddressField(&quot;_breakpoints&quot;);
 107     }
 108     miscFlags            = new CIntField(type.getCIntegerField(&quot;_misc_flags&quot;), 0);
 109     headerSize           = type.getSize();
 110 
 111     // read field offset constants
 112     ACCESS_FLAGS_OFFSET            = db.lookupIntConstant(&quot;FieldInfo::access_flags_offset&quot;).intValue();
 113     NAME_INDEX_OFFSET              = db.lookupIntConstant(&quot;FieldInfo::name_index_offset&quot;).intValue();
 114     SIGNATURE_INDEX_OFFSET         = db.lookupIntConstant(&quot;FieldInfo::signature_index_offset&quot;).intValue();
 115     INITVAL_INDEX_OFFSET           = db.lookupIntConstant(&quot;FieldInfo::initval_index_offset&quot;).intValue();
 116     LOW_OFFSET                     = db.lookupIntConstant(&quot;FieldInfo::low_packed_offset&quot;).intValue();
 117     HIGH_OFFSET                    = db.lookupIntConstant(&quot;FieldInfo::high_packed_offset&quot;).intValue();
 118     FIELD_SLOTS                    = db.lookupIntConstant(&quot;FieldInfo::field_slots&quot;).intValue();
 119     FIELDINFO_TAG_SIZE             = db.lookupIntConstant(&quot;FIELDINFO_TAG_SIZE&quot;).shortValue();
 120     FIELDINFO_TAG_MASK             = db.lookupIntConstant(&quot;FIELDINFO_TAG_MASK&quot;).shortValue();
 121     FIELDINFO_TAG_OFFSET           = db.lookupIntConstant(&quot;FIELDINFO_TAG_OFFSET&quot;).shortValue();
 122 
 123     // read ClassState constants
 124     CLASS_STATE_ALLOCATED = db.lookupIntConstant(&quot;InstanceKlass::allocated&quot;).intValue();
 125     CLASS_STATE_LOADED = db.lookupIntConstant(&quot;InstanceKlass::loaded&quot;).intValue();
 126     CLASS_STATE_LINKED = db.lookupIntConstant(&quot;InstanceKlass::linked&quot;).intValue();
 127     CLASS_STATE_BEING_INITIALIZED = db.lookupIntConstant(&quot;InstanceKlass::being_initialized&quot;).intValue();
 128     CLASS_STATE_FULLY_INITIALIZED = db.lookupIntConstant(&quot;InstanceKlass::fully_initialized&quot;).intValue();
 129     CLASS_STATE_INITIALIZATION_ERROR = db.lookupIntConstant(&quot;InstanceKlass::initialization_error&quot;).intValue();
 130 
 131     MISC_REWRITTEN                    = db.lookupIntConstant(&quot;InstanceKlass::_misc_rewritten&quot;).intValue();
 132     MISC_HAS_NONSTATIC_FIELDS         = db.lookupIntConstant(&quot;InstanceKlass::_misc_has_nonstatic_fields&quot;).intValue();
 133     MISC_SHOULD_VERIFY_CLASS          = db.lookupIntConstant(&quot;InstanceKlass::_misc_should_verify_class&quot;).intValue();
 134     MISC_IS_UNSAFE_ANONYMOUS          = db.lookupIntConstant(&quot;InstanceKlass::_misc_is_unsafe_anonymous&quot;).intValue();
 135     MISC_IS_CONTENDED                 = db.lookupIntConstant(&quot;InstanceKlass::_misc_is_contended&quot;).intValue();
 136     MISC_HAS_NONSTATIC_CONCRETE_METHODS      = db.lookupIntConstant(&quot;InstanceKlass::_misc_has_nonstatic_concrete_methods&quot;).intValue();
 137     MISC_DECLARES_NONSTATIC_CONCRETE_METHODS = db.lookupIntConstant(&quot;InstanceKlass::_misc_declares_nonstatic_concrete_methods&quot;).intValue();
 138     MISC_HAS_BEEN_REDEFINED           = db.lookupIntConstant(&quot;InstanceKlass::_misc_has_been_redefined&quot;).intValue();
 139     MISC_HAS_PASSED_FINGERPRINT_CHECK = db.lookupIntConstant(&quot;InstanceKlass::_misc_has_passed_fingerprint_check&quot;).intValue();
 140     MISC_IS_SCRATCH_CLASS             = db.lookupIntConstant(&quot;InstanceKlass::_misc_is_scratch_class&quot;).intValue();
 141     MISC_IS_SHARED_BOOT_CLASS         = db.lookupIntConstant(&quot;InstanceKlass::_misc_is_shared_boot_class&quot;).intValue();
 142     MISC_IS_SHARED_PLATFORM_CLASS     = db.lookupIntConstant(&quot;InstanceKlass::_misc_is_shared_platform_class&quot;).intValue();
 143     MISC_IS_SHARED_APP_CLASS          = db.lookupIntConstant(&quot;InstanceKlass::_misc_is_shared_app_class&quot;).intValue();
 144   }
 145 
 146   public InstanceKlass(Address addr) {
 147     super(addr);
 148     if (getJavaFieldsCount() != getAllFieldsCount()) {
 149       // Exercise the injected field logic
 150       for (int i = getJavaFieldsCount(); i &lt; getAllFieldsCount(); i++) {
 151         getFieldName(i);
 152         getFieldSignature(i);
 153       }
 154     }
 155   }
 156 
 157   private static MetadataField arrayKlasses;
 158   private static AddressField  methods;
 159   private static AddressField  defaultMethods;
 160   private static AddressField  methodOrdering;
 161   private static AddressField  localInterfaces;
 162   private static AddressField  transitiveInterfaces;
 163   private static AddressField fields;
 164   private static CIntField javaFieldsCount;
 165   private static MetadataField constants;
 166   private static AddressField  sourceDebugExtension;
 167   private static AddressField  innerClasses;
 168   private static CIntField nonstaticFieldSize;
 169   private static CIntField staticFieldSize;
 170   private static CIntField staticOopFieldCount;
 171   private static CIntField nonstaticOopMapSize;
 172   private static CIntField isMarkedDependent;
 173   private static CIntField initState;
 174   private static CIntField itableLen;
 175   private static AddressField breakpoints;
 176   private static CIntField miscFlags;
 177 
 178   // type safe enum for ClassState from instanceKlass.hpp
 179   public static class ClassState {
 180      public static final ClassState ALLOCATED    = new ClassState(&quot;allocated&quot;);
 181      public static final ClassState LOADED       = new ClassState(&quot;loaded&quot;);
 182      public static final ClassState LINKED       = new ClassState(&quot;linked&quot;);
 183      public static final ClassState BEING_INITIALIZED      = new ClassState(&quot;beingInitialized&quot;);
 184      public static final ClassState FULLY_INITIALIZED    = new ClassState(&quot;fullyInitialized&quot;);
 185      public static final ClassState INITIALIZATION_ERROR = new ClassState(&quot;initializationError&quot;);
 186 
 187      private ClassState(String value) {
 188         this.value = value;
 189      }
 190 
 191      public String toString() {
 192         return value;
 193      }
 194 
 195      private String value;
 196   }
 197 
 198   public int  getInitStateAsInt() { return (int) initState.getValue(this); }
 199   public ClassState getInitState() {
 200      int state = getInitStateAsInt();
 201      if (state == CLASS_STATE_ALLOCATED) {
 202         return ClassState.ALLOCATED;
 203      } else if (state == CLASS_STATE_LOADED) {
 204         return ClassState.LOADED;
 205      } else if (state == CLASS_STATE_LINKED) {
 206         return ClassState.LINKED;
 207      } else if (state == CLASS_STATE_BEING_INITIALIZED) {
 208         return ClassState.BEING_INITIALIZED;
 209      } else if (state == CLASS_STATE_FULLY_INITIALIZED) {
 210         return ClassState.FULLY_INITIALIZED;
 211      } else if (state == CLASS_STATE_INITIALIZATION_ERROR) {
 212         return ClassState.INITIALIZATION_ERROR;
 213      } else {
 214         throw new RuntimeException(&quot;should not reach here&quot;);
 215      }
 216   }
 217 
 218   // initialization state quaries
 219   public boolean isLoaded() {
 220      return getInitStateAsInt() &gt;= CLASS_STATE_LOADED;
 221   }
 222 
 223   public boolean isLinked() {
 224      return getInitStateAsInt() &gt;= CLASS_STATE_LINKED;
 225   }
 226 
 227   public boolean isInitialized() {
 228      return getInitStateAsInt() == CLASS_STATE_FULLY_INITIALIZED;
 229   }
 230 
 231   public boolean isNotInitialized() {
 232      return getInitStateAsInt() &lt; CLASS_STATE_BEING_INITIALIZED;
 233   }
 234 
 235   public boolean isBeingInitialized() {
 236      return getInitStateAsInt() == CLASS_STATE_BEING_INITIALIZED;
 237   }
 238 
 239   public boolean isInErrorState() {
 240      return getInitStateAsInt() == CLASS_STATE_INITIALIZATION_ERROR;
 241   }
 242 
 243   public int getClassStatus() {
 244      int result = 0;
 245      if (isLinked()) {
 246         result |= JVMDIClassStatus.VERIFIED | JVMDIClassStatus.PREPARED;
 247      }
 248 
 249      if (isInitialized()) {
 250         if (Assert.ASSERTS_ENABLED) {
 251            Assert.that(isLinked(), &quot;Class status is not consistent&quot;);
 252         }
 253         result |= JVMDIClassStatus.INITIALIZED;
 254      }
 255 
 256      if (isInErrorState()) {
 257         result |= JVMDIClassStatus.ERROR;
 258      }
 259      return result;
 260   }
 261 
 262   // Byteside of the header
 263   private static long headerSize;
 264 
 265   public long getObjectSize(Oop object) {
 266     return getSizeHelper() * VM.getVM().getAddressSize();
 267   }
 268 
 269   public long getSize() { // in number of bytes
 270     long wordLength = VM.getVM().getBytesPerWord();
 271     long size = getHeaderSize() +
 272                 (getVtableLen() +
 273                  getItableLen() +
 274                  getNonstaticOopMapSize()) * wordLength;
 275     if (isInterface()) {
 276       size += wordLength;
 277     }
 278     if (isUnsafeAnonymous()) {
 279       size += wordLength;
 280     }
 281     if (hasStoredFingerprint()) {
 282       size += 8; // uint64_t
 283     }
 284     return alignSize(size);
 285   }
 286 
 287   private int getMiscFlags() {
 288     return (int) miscFlags.getValue(this);
 289   }
 290 
 291   public boolean isUnsafeAnonymous() {
 292     return (getMiscFlags() &amp; MISC_IS_UNSAFE_ANONYMOUS) != 0;
 293   }
 294 
 295   public static boolean shouldStoreFingerprint() {
 296     VM vm = VM.getVM();
 297     if (vm.getCommandLineBooleanFlag(&quot;EnableJVMCI&quot;) &amp;&amp; !vm.getCommandLineBooleanFlag(&quot;UseJVMCICompiler&quot;)) {
 298       return true;
 299     }
 300     if (vm.getCommandLineBooleanFlag(&quot;DumpSharedSpaces&quot;)) {
 301       return true;
 302     }
 303     return false;
 304   }
 305 
 306   public boolean hasStoredFingerprint() {
 307     return shouldStoreFingerprint() || isShared();
 308   }
 309 
 310   public static long getHeaderSize() { return headerSize; }
 311 
 312   public short getFieldAccessFlags(int index) {
 313     return getFields().at(index * FIELD_SLOTS + ACCESS_FLAGS_OFFSET);
 314   }
 315 
 316   public short getFieldNameIndex(int index) {
 317     if (index &gt;= getJavaFieldsCount()) throw new IndexOutOfBoundsException(&quot;not a Java field;&quot;);
 318     return getFields().at(index * FIELD_SLOTS + NAME_INDEX_OFFSET);
 319   }
 320 
 321   public Symbol getFieldName(int index) {
 322     int nameIndex = getFields().at(index * FIELD_SLOTS + NAME_INDEX_OFFSET);
 323     if (index &lt; getJavaFieldsCount()) {
 324       return getConstants().getSymbolAt(nameIndex);
 325     } else {
 326       return vmSymbols.symbolAt(nameIndex);
 327     }
 328   }
 329 
 330   public short getFieldSignatureIndex(int index) {
 331     if (index &gt;= getJavaFieldsCount()) throw new IndexOutOfBoundsException(&quot;not a Java field;&quot;);
 332     return getFields().at(index * FIELD_SLOTS + SIGNATURE_INDEX_OFFSET);
 333   }
 334 
 335   public Symbol getFieldSignature(int index) {
 336     int signatureIndex = getFields().at(index * FIELD_SLOTS + SIGNATURE_INDEX_OFFSET);
 337     if (index &lt; getJavaFieldsCount()) {
 338       return getConstants().getSymbolAt(signatureIndex);
 339     } else {
 340       return vmSymbols.symbolAt(signatureIndex);
 341     }
 342   }
 343 
 344   public short getFieldGenericSignatureIndex(int index) {
 345     // int len = getFields().length();
 346     int allFieldsCount = getAllFieldsCount();
 347     int generic_signature_slot = allFieldsCount * FIELD_SLOTS;
 348     for (int i = 0; i &lt; allFieldsCount; i++) {
 349       short flags = getFieldAccessFlags(i);
 350       AccessFlags access = new AccessFlags(flags);
 351       if (i == index) {
 352         if (access.fieldHasGenericSignature()) {
 353            return getFields().at(generic_signature_slot);
 354         } else {
 355           return 0;
 356         }
 357       } else {
 358         if (access.fieldHasGenericSignature()) {
 359           generic_signature_slot ++;
 360         }
 361       }
 362     }
 363     return 0;
 364   }
 365 
 366   public Symbol getFieldGenericSignature(int index) {
 367     short genericSignatureIndex = getFieldGenericSignatureIndex(index);
 368     if (genericSignatureIndex != 0)  {
 369       return getConstants().getSymbolAt(genericSignatureIndex);
 370     }
 371     return null;
 372   }
 373 
 374   public short getFieldInitialValueIndex(int index) {
 375     if (index &gt;= getJavaFieldsCount()) throw new IndexOutOfBoundsException(&quot;not a Java field;&quot;);
 376     return getFields().at(index * FIELD_SLOTS + INITVAL_INDEX_OFFSET);
 377   }
 378 
 379   public int getFieldOffset(int index) {
 380     U2Array fields = getFields();
 381     short lo = fields.at(index * FIELD_SLOTS + LOW_OFFSET);
 382     short hi = fields.at(index * FIELD_SLOTS + HIGH_OFFSET);
 383     if ((lo &amp; FIELDINFO_TAG_MASK) == FIELDINFO_TAG_OFFSET) {
 384       return VM.getVM().buildIntFromShorts(lo, hi) &gt;&gt; FIELDINFO_TAG_SIZE;
 385     }
 386     throw new RuntimeException(&quot;should not reach here&quot;);
 387   }
 388 
 389   // Accessors for declared fields
 390   public Klass     getArrayKlasses()        { return (Klass)        arrayKlasses.getValue(this); }
 391   public MethodArray  getMethods()              { return new MethodArray(methods.getValue(getAddress())); }
 392 
 393   public MethodArray  getDefaultMethods() {
 394     if (defaultMethods != null) {
 395       Address addr = defaultMethods.getValue(getAddress());
 396       if ((addr != null) &amp;&amp; (addr.getAddressAt(0) != null)) {
 397         return new MethodArray(addr);
 398       } else {
 399         return null;
 400       }
 401     } else {
 402       return null;
 403     }
 404   }
 405 
 406   public KlassArray   getLocalInterfaces()      { return new KlassArray(localInterfaces.getValue(getAddress())); }
 407   public KlassArray   getTransitiveInterfaces() { return new KlassArray(transitiveInterfaces.getValue(getAddress())); }
 408   public int       getJavaFieldsCount()     { return                (int) javaFieldsCount.getValue(this); }
 409   public int       getAllFieldsCount()      {
 410     int len = getFields().length();
 411     int allFieldsCount = 0;
 412     for (; allFieldsCount*FIELD_SLOTS &lt; len; allFieldsCount++) {
 413       short flags = getFieldAccessFlags(allFieldsCount);
 414       AccessFlags access = new AccessFlags(flags);
 415       if (access.fieldHasGenericSignature()) {
 416         len --;
 417       }
 418     }
 419     return allFieldsCount;
 420   }
 421   public ConstantPool getConstants()        { return (ConstantPool) constants.getValue(this); }
 422   public Symbol    getSourceFileName()      { return                getConstants().getSourceFileName(); }
 423   public String    getSourceDebugExtension(){ return                CStringUtilities.getString(sourceDebugExtension.getValue(getAddress())); }
 424   public long      getNonstaticFieldSize()  { return                nonstaticFieldSize.getValue(this); }
 425   public long      getStaticOopFieldCount() { return                staticOopFieldCount.getValue(this); }
 426   public long      getNonstaticOopMapSize() { return                nonstaticOopMapSize.getValue(this); }
 427   public boolean   getIsMarkedDependent()   { return                isMarkedDependent.getValue(this) != 0; }
 428   public long      getItableLen()           { return                itableLen.getValue(this); }
 429   public long      majorVersion()           { return                getConstants().majorVersion(); }
 430   public long      minorVersion()           { return                getConstants().minorVersion(); }
 431   public Symbol    getGenericSignature()    { return                getConstants().getGenericSignature(); }
 432 
 433   // &quot;size helper&quot; == instance size in words
 434   public long getSizeHelper() {
 435     int lh = getLayoutHelper();
 436     if (Assert.ASSERTS_ENABLED) {
 437       Assert.that(lh &gt; 0, &quot;layout helper initialized for instance class&quot;);
 438     }
 439     return lh / VM.getVM().getAddressSize();
 440   }
 441 
 442   // same as enum InnerClassAttributeOffset in VM code.
 443   private static class InnerClassAttributeOffset {
 444     // from JVM spec. &quot;InnerClasses&quot; attribute
 445     public static int innerClassInnerClassInfoOffset;
 446     public static int innerClassOuterClassInfoOffset;
 447     public static int innerClassInnerNameOffset;
 448     public static int innerClassAccessFlagsOffset;
 449     public static int innerClassNextOffset;
 450     static {
 451       VM.registerVMInitializedObserver(new Observer() {
 452           public void update(Observable o, Object data) {
 453               initialize(VM.getVM().getTypeDataBase());
 454           }
 455       });
 456     }
 457 
 458     private static synchronized void initialize(TypeDataBase db) {
 459       innerClassInnerClassInfoOffset = db.lookupIntConstant(
 460           &quot;InstanceKlass::inner_class_inner_class_info_offset&quot;).intValue();
 461       innerClassOuterClassInfoOffset = db.lookupIntConstant(
 462           &quot;InstanceKlass::inner_class_outer_class_info_offset&quot;).intValue();
 463       innerClassInnerNameOffset = db.lookupIntConstant(
 464           &quot;InstanceKlass::inner_class_inner_name_offset&quot;).intValue();
 465       innerClassAccessFlagsOffset = db.lookupIntConstant(
 466           &quot;InstanceKlass::inner_class_access_flags_offset&quot;).intValue();
 467       innerClassNextOffset = db.lookupIntConstant(
 468           &quot;InstanceKlass::inner_class_next_offset&quot;).intValue();
 469     }
 470   }
 471 
 472   private static class EnclosingMethodAttributeOffset {
 473     public static int enclosingMethodAttributeSize;
 474     static {
 475       VM.registerVMInitializedObserver(new Observer() {
 476           public void update(Observable o, Object data) {
 477               initialize(VM.getVM().getTypeDataBase());
 478           }
 479       });
 480     }
 481     private static synchronized void initialize(TypeDataBase db) {
 482       enclosingMethodAttributeSize = db.lookupIntConstant(&quot;InstanceKlass::enclosing_method_attribute_size&quot;).intValue();
 483     }
 484   }
 485 
 486   // refer to compute_modifier_flags in VM code.
 487   public long computeModifierFlags() {
 488     long access = getAccessFlags();
 489     // But check if it happens to be member class.
 490     U2Array innerClassList = getInnerClasses();
 491     int length = (innerClassList == null)? 0 : (int) innerClassList.length();
 492     if (length &gt; 0) {
 493        if (Assert.ASSERTS_ENABLED) {
 494           Assert.that(length % InnerClassAttributeOffset.innerClassNextOffset == 0 ||
 495                       length % InnerClassAttributeOffset.innerClassNextOffset == EnclosingMethodAttributeOffset.enclosingMethodAttributeSize,
 496                       &quot;just checking&quot;);
 497        }
 498        for (int i = 0; i &lt; length; i += InnerClassAttributeOffset.innerClassNextOffset) {
 499           if (i == length - EnclosingMethodAttributeOffset.enclosingMethodAttributeSize) {
 500               break;
 501           }
 502           int ioff = innerClassList.at(i +
 503                          InnerClassAttributeOffset.innerClassInnerClassInfoOffset);
 504           // &#39;ioff&#39; can be zero.
 505           // refer to JVM spec. section 4.7.5.
 506           if (ioff != 0) {
 507              // only look at classes that are already loaded
 508              // since we are looking for the flags for our self.
 509              Symbol name = getConstants().getKlassNameAt(ioff);
 510 
 511              if (name.equals(getName())) {
 512                 // This is really a member class
 513                 access = innerClassList.at(i +
 514                         InnerClassAttributeOffset.innerClassAccessFlagsOffset);
 515                 break;
 516              }
 517           }
 518        } // for inner classes
 519     }
 520 
 521     // Remember to strip ACC_SUPER bit
 522     return (access &amp; (~JVM_ACC_SUPER)) &amp; JVM_ACC_WRITTEN_FLAGS;
 523   }
 524 
 525 
 526   // whether given Symbol is name of an inner/nested Klass of this Klass?
 527   // anonymous and local classes are excluded.
 528   public boolean isInnerClassName(Symbol sym) {
 529     return isInInnerClasses(sym, false);
 530   }
 531 
 532   // whether given Symbol is name of an inner/nested Klass of this Klass?
 533   // anonymous classes excluded, but local classes are included.
 534   public boolean isInnerOrLocalClassName(Symbol sym) {
 535     return isInInnerClasses(sym, true);
 536   }
 537 
 538   private boolean isInInnerClasses(Symbol sym, boolean includeLocals) {
 539     U2Array innerClassList = getInnerClasses();
 540     int length = ( innerClassList == null)? 0 : (int) innerClassList.length();
 541     if (length &gt; 0) {
 542        if (Assert.ASSERTS_ENABLED) {
 543          Assert.that(length % InnerClassAttributeOffset.innerClassNextOffset == 0 ||
 544                      length % InnerClassAttributeOffset.innerClassNextOffset == EnclosingMethodAttributeOffset.enclosingMethodAttributeSize,
 545                      &quot;just checking&quot;);
 546        }
 547        for (int i = 0; i &lt; length; i += InnerClassAttributeOffset.innerClassNextOffset) {
 548          if (i == length - EnclosingMethodAttributeOffset.enclosingMethodAttributeSize) {
 549              break;
 550          }
 551          int ioff = innerClassList.at(i +
 552                         InnerClassAttributeOffset.innerClassInnerClassInfoOffset);
 553          // &#39;ioff&#39; can be zero.
 554          // refer to JVM spec. section 4.7.5.
 555          if (ioff != 0) {
 556             Symbol innerName = getConstants().getKlassNameAt(ioff);
 557             Symbol myname = getName();
 558             int ooff = innerClassList.at(i +
 559                         InnerClassAttributeOffset.innerClassOuterClassInfoOffset);
 560             // for anonymous classes inner_name_index of InnerClasses
 561             // attribute is zero.
 562             int innerNameIndex = innerClassList.at(i +
 563                         InnerClassAttributeOffset.innerClassInnerNameOffset);
 564             // if this is not a member (anonymous, local etc.), &#39;ooff&#39; will be zero
 565             // refer to JVM spec. section 4.7.5.
 566             if (ooff == 0) {
 567                if (includeLocals) {
 568                   // does it looks like my local class?
 569                   if (innerName.equals(sym) &amp;&amp;
 570                      innerName.asString().startsWith(myname.asString())) {
 571                      // exclude anonymous classes.
 572                      return (innerNameIndex != 0);
 573                   }
 574                }
 575             } else {
 576                Symbol outerName = getConstants().getKlassNameAt(ooff);
 577 
 578                // include only if current class is outer class.
 579                if (outerName.equals(myname) &amp;&amp; innerName.equals(sym)) {
 580                   return true;
 581                }
 582            }
 583          }
 584        } // for inner classes
 585        return false;
 586     } else {
 587        return false;
 588     }
 589   }
 590 
 591   public boolean implementsInterface(Klass k) {
 592     if (Assert.ASSERTS_ENABLED) {
 593       Assert.that(k.isInterface(), &quot;should not reach here&quot;);
 594     }
 595     KlassArray interfaces =  getTransitiveInterfaces();
 596     final int len = interfaces.length();
 597     for (int i = 0; i &lt; len; i++) {
 598       if (interfaces.getAt(i).equals(k)) return true;
 599     }
 600     return false;
 601   }
 602 
 603   boolean computeSubtypeOf(Klass k) {
 604     if (k.isInterface()) {
 605       return implementsInterface(k);
 606     } else {
 607       return super.computeSubtypeOf(k);
 608     }
 609   }
 610 
 611   public void printValueOn(PrintStream tty) {
 612     tty.print(&quot;InstanceKlass for &quot; + getName().asString());
 613   }
 614 
 615   public void iterateFields(MetadataVisitor visitor) {
 616     super.iterateFields(visitor);
 617     visitor.doMetadata(arrayKlasses, true);
 618     // visitor.doOop(methods, true);
 619     // visitor.doOop(localInterfaces, true);
 620     // visitor.doOop(transitiveInterfaces, true);
 621       visitor.doCInt(nonstaticFieldSize, true);
 622       visitor.doCInt(staticFieldSize, true);
 623       visitor.doCInt(staticOopFieldCount, true);
 624       visitor.doCInt(nonstaticOopMapSize, true);
 625       visitor.doCInt(isMarkedDependent, true);
 626       visitor.doCInt(initState, true);
 627       visitor.doCInt(itableLen, true);
 628     }
 629 
 630   /*
 631    *  Visit the static fields of this InstanceKlass with the obj of
 632    *  the visitor set to the oop holding the fields, which is
 633    *  currently the java mirror.
 634    */
 635   public void iterateStaticFields(OopVisitor visitor) {
 636     visitor.setObj(getJavaMirror());
 637     visitor.prologue();
 638     iterateStaticFieldsInternal(visitor);
 639     visitor.epilogue();
 640 
 641   }
 642 
 643   void iterateStaticFieldsInternal(OopVisitor visitor) {
 644     int length = getJavaFieldsCount();
 645     for (int index = 0; index &lt; length; index++) {
 646       short accessFlags    = getFieldAccessFlags(index);
 647       FieldType   type   = new FieldType(getFieldSignature(index));
 648       AccessFlags access = new AccessFlags(accessFlags);
 649       if (access.isStatic()) {
 650         visitField(visitor, type, index);
 651       }
 652     }
 653   }
 654 
 655   public Klass getJavaSuper() {
 656     return getSuper();
 657   }
 658 
 659   public static class StaticField {
 660     public AccessFlags flags;
 661     public Field field;
 662 
 663     StaticField(Field field, AccessFlags flags) {
 664       this.field = field;
 665       this.flags = flags;
 666     }
 667   }
 668 
 669   public Field[] getStaticFields() {
 670     U2Array fields = getFields();
 671     int length = getJavaFieldsCount();
 672     ArrayList&lt;Field&gt; result = new ArrayList&lt;&gt;();
 673     for (int index = 0; index &lt; length; index++) {
 674       Field f = newField(index);
 675       if (f.isStatic()) {
 676         result.add(f);
 677       }
 678     }
 679     return result.toArray(new Field[result.size()]);
 680   }
 681 
 682   public void iterateNonStaticFields(OopVisitor visitor, Oop obj) {
 683     if (getSuper() != null) {
 684       ((InstanceKlass) getSuper()).iterateNonStaticFields(visitor, obj);
 685     }
 686     int length = getJavaFieldsCount();
 687     for (int index = 0; index &lt; length; index++) {
 688       short accessFlags    = getFieldAccessFlags(index);
 689       FieldType   type   = new FieldType(getFieldSignature(index));
 690       AccessFlags access = new AccessFlags(accessFlags);
 691       if (!access.isStatic()) {
 692         visitField(visitor, type, index);
 693       }
 694     }
 695   }
 696 
 697   /** Field access by name. */
 698   public Field findLocalField(String name, String sig) {
 699     int length = getJavaFieldsCount();
 700     for (int i = 0; i &lt; length; i++) {
 701       Symbol f_name = getFieldName(i);
 702       Symbol f_sig  = getFieldSignature(i);
 703       if (f_name.equals(name) &amp;&amp; f_sig.equals(sig)) {
 704         return newField(i);
 705       }
 706     }
 707 
 708     return null;
 709   }
 710 
 711   /** Find field in direct superinterfaces. */
 712   public Field findInterfaceField(String name, String sig) {
 713     KlassArray interfaces = getLocalInterfaces();
 714     int n = interfaces.length();
 715     for (int i = 0; i &lt; n; i++) {
 716       InstanceKlass intf1 = (InstanceKlass) interfaces.getAt(i);
 717       if (Assert.ASSERTS_ENABLED) {
 718         Assert.that(intf1.isInterface(), &quot;just checking type&quot;);
 719      }
 720       // search for field in current interface
 721       Field f = intf1.findLocalField(name, sig);
 722       if (f != null) {
 723         if (Assert.ASSERTS_ENABLED) {
 724           Assert.that(f.getAccessFlagsObj().isStatic(), &quot;interface field must be static&quot;);
 725         }
 726         return f;
 727       }
 728       // search for field in direct superinterfaces
 729       f = intf1.findInterfaceField(name, sig);
 730       if (f != null) return f;
 731     }
 732     // otherwise field lookup fails
 733     return null;
 734   }
 735 
 736   /** Find field according to JVM spec 5.4.3.2, returns the klass in
 737       which the field is defined. */
 738   public Field findField(String name, String sig) {
 739     // search order according to newest JVM spec (5.4.3.2, p.167).
 740     // 1) search for field in current klass
 741     Field f = findLocalField(name, sig);
 742     if (f != null) return f;
 743 
 744     // 2) search for field recursively in direct superinterfaces
 745     f = findInterfaceField(name, sig);
 746     if (f != null) return f;
 747 
 748     // 3) apply field lookup recursively if superclass exists
 749     InstanceKlass supr = (InstanceKlass) getSuper();
 750     if (supr != null) return supr.findField(name, sig);
 751 
 752     // 4) otherwise field lookup fails
 753     return null;
 754   }
 755 
 756   /** Find field according to JVM spec 5.4.3.2, returns the klass in
 757       which the field is defined (retained only for backward
 758       compatibility with jdbx) */
 759   public Field findFieldDbg(String name, String sig) {
 760     return findField(name, sig);
 761   }
 762 
 763   /** Get field by its index in the fields array. Only designed for
 764       use in a debugging system. */
 765   public Field getFieldByIndex(int fieldIndex) {
 766     return newField(fieldIndex);
 767   }
 768 
 769 
 770     /** Return a List of SA Fields for the fields declared in this class.
 771         Inherited fields are not included.
 772         Return an empty list if there are no fields declared in this class.
 773         Only designed for use in a debugging system. */
 774     public List&lt;Field&gt; getImmediateFields() {
 775         // A list of Fields for each field declared in this class/interface,
 776         // not including inherited fields.
 777         int length = getJavaFieldsCount();
 778         List&lt;Field&gt; immediateFields = new ArrayList&lt;&gt;(length);
 779         for (int index = 0; index &lt; length; index++) {
 780             immediateFields.add(getFieldByIndex(index));
 781         }
 782 
 783         return immediateFields;
 784     }
 785 
 786     /** Return a List of SA Fields for all the java fields in this class,
 787         including all inherited fields.  This includes hidden
 788         fields.  Thus the returned list can contain fields with
 789         the same name.
 790         Return an empty list if there are no fields.
 791         Only designed for use in a debugging system. */
 792     public List&lt;Field&gt; getAllFields() {
 793         // Contains a Field for each field in this class, including immediate
 794         // fields and inherited fields.
 795         List&lt;Field&gt; allFields = getImmediateFields();
 796 
 797         // transitiveInterfaces contains all interfaces implemented
 798         // by this class and its superclass chain with no duplicates.
 799 
 800         KlassArray interfaces = getTransitiveInterfaces();
 801         int n = interfaces.length();
 802         for (int i = 0; i &lt; n; i++) {
 803             InstanceKlass intf1 = (InstanceKlass) interfaces.getAt(i);
 804             if (Assert.ASSERTS_ENABLED) {
 805                 Assert.that(intf1.isInterface(), &quot;just checking type&quot;);
 806             }
 807             allFields.addAll(intf1.getImmediateFields());
 808         }
 809 
 810         // Get all fields in the superclass, recursively.  But, don&#39;t
 811         // include fields in interfaces implemented by superclasses;
 812         // we already have all those.
 813         if (!isInterface()) {
 814             InstanceKlass supr;
 815             if  ( (supr = (InstanceKlass) getSuper()) != null) {
 816                 allFields.addAll(supr.getImmediateFields());
 817             }
 818         }
 819 
 820         return allFields;
 821     }
 822 
 823 
 824     /** Return a List of SA Methods declared directly in this class/interface.
 825         Return an empty list if there are none, or if this isn&#39;t a class/
 826         interface.
 827     */
 828     public List&lt;Method&gt; getImmediateMethods() {
 829       // Contains a Method for each method declared in this class/interface
 830       // not including inherited methods.
 831 
 832       MethodArray methods = getMethods();
 833       int length = methods.length();
 834       Method[] tmp = new Method[length];
 835 
 836       IntArray methodOrdering = getMethodOrdering();
 837       if (methodOrdering.length() != length) {
 838          // no ordering info present
 839          for (int index = 0; index &lt; length; index++) {
 840             tmp[index] = methods.at(index);
 841          }
 842       } else {
 843          for (int index = 0; index &lt; length; index++) {
 844             int originalIndex = methodOrdering.at(index);
 845             tmp[originalIndex] = methods.at(index);
 846          }
 847       }
 848 
 849       return Arrays.asList(tmp);
 850     }
 851 
 852     /** Return a List containing an SA InstanceKlass for each
 853         interface named in this class&#39;s &#39;implements&#39; clause.
 854     */
 855     public List&lt;Klass&gt; getDirectImplementedInterfaces() {
 856         // Contains an InstanceKlass for each interface in this classes
 857         // &#39;implements&#39; clause.
 858 
 859         KlassArray interfaces = getLocalInterfaces();
 860         int length = interfaces.length();
 861         List&lt;Klass&gt; directImplementedInterfaces = new ArrayList&lt;&gt;(length);
 862 
 863         for (int index = 0; index &lt; length; index ++) {
 864             directImplementedInterfaces.add(interfaces.getAt(index));
 865         }
 866 
 867         return directImplementedInterfaces;
 868     }
 869 
 870   public Klass arrayKlassImpl(boolean orNull, int n) {
 871     // FIXME: in reflective system this would need to change to
 872     // actually allocate
 873     if (getArrayKlasses() == null) { return null; }
 874     ObjArrayKlass oak = (ObjArrayKlass) getArrayKlasses();
 875     if (orNull) {
 876       return oak.arrayKlassOrNull(n);
 877     }
 878     return oak.arrayKlass(n);
 879   }
 880 
 881   public Klass arrayKlassImpl(boolean orNull) {
 882     return arrayKlassImpl(orNull, 1);
 883   }
 884 
 885   public String signature() {
 886      return &quot;L&quot; + super.signature() + &quot;;&quot;;
 887   }
 888 
 889   /** Find method in vtable. */
 890   public Method findMethod(String name, String sig) {
 891     return findMethod(getMethods(), name, sig);
 892   }
 893 
 894   /** Breakpoint support (see methods on Method* for details) */
 895   public BreakpointInfo getBreakpoints() {
 896     if (!VM.getVM().isJvmtiSupported()) {
 897       return null;
 898     }
 899     Address addr = getAddress().getAddressAt(breakpoints.getOffset());
 900     return (BreakpointInfo) VMObjectFactory.newObject(BreakpointInfo.class, addr);
 901   }
 902 
 903   public IntArray  getMethodOrdering() {
 904     Address addr = getAddress().getAddressAt(methodOrdering.getOffset());
 905     return (IntArray) VMObjectFactory.newObject(IntArray.class, addr);
 906   }
 907 
 908   public U2Array getFields() {
 909     Address addr = getAddress().getAddressAt(fields.getOffset());
 910     return (U2Array) VMObjectFactory.newObject(U2Array.class, addr);
 911   }
 912 
 913   public U2Array getInnerClasses() {
 914     Address addr = getAddress().getAddressAt(innerClasses.getOffset());
 915     return (U2Array) VMObjectFactory.newObject(U2Array.class, addr);
 916   }
 917 
 918 
 919   //----------------------------------------------------------------------
 920   // Internals only below this point
 921   //
 922 
 923   private void visitField(OopVisitor visitor, FieldType type, int index) {
 924     Field f = newField(index);
 925     if (type.isOop()) {
 926       visitor.doOop((OopField) f, false);
 927       return;
 928     }
 929     if (type.isByte()) {
 930       visitor.doByte((ByteField) f, false);
 931       return;
 932     }
 933     if (type.isChar()) {
 934       visitor.doChar((CharField) f, false);
 935       return;
 936     }
 937     if (type.isDouble()) {
 938       visitor.doDouble((DoubleField) f, false);
 939       return;
 940     }
 941     if (type.isFloat()) {
 942       visitor.doFloat((FloatField) f, false);
 943       return;
 944     }
 945     if (type.isInt()) {
 946       visitor.doInt((IntField) f, false);
 947       return;
 948     }
 949     if (type.isLong()) {
 950       visitor.doLong((LongField) f, false);
 951       return;
 952     }
 953     if (type.isShort()) {
 954       visitor.doShort((ShortField) f, false);
 955       return;
 956     }
 957     if (type.isBoolean()) {
 958       visitor.doBoolean((BooleanField) f, false);
 959       return;
 960     }
 961   }
 962 
 963   // Creates new field from index in fields TypeArray
 964   private Field newField(int index) {
 965     FieldType type = new FieldType(getFieldSignature(index));
 966     if (type.isOop()) {
 967      if (VM.getVM().isCompressedOopsEnabled()) {
 968         return new NarrowOopField(this, index);
 969      } else {
 970         return new OopField(this, index);
 971      }
 972     }
 973     if (type.isByte()) {
 974       return new ByteField(this, index);
 975     }
 976     if (type.isChar()) {
 977       return new CharField(this, index);
 978     }
 979     if (type.isDouble()) {
 980       return new DoubleField(this, index);
 981     }
 982     if (type.isFloat()) {
 983       return new FloatField(this, index);
 984     }
 985     if (type.isInt()) {
 986       return new IntField(this, index);
 987     }
 988     if (type.isLong()) {
 989       return new LongField(this, index);
 990     }
 991     if (type.isShort()) {
 992       return new ShortField(this, index);
 993     }
 994     if (type.isBoolean()) {
 995       return new BooleanField(this, index);
 996     }
 997     throw new RuntimeException(&quot;Illegal field type at index &quot; + index);
 998   }
 999 
1000   private static Method findMethod(MethodArray methods, String name, String signature) {
1001     int index = linearSearch(methods, name, signature);
1002     if (index != -1) {
1003       return methods.at(index);
1004     } else {
1005       return null;
1006     }
1007   }
1008 
1009   private static int linearSearch(MethodArray methods, String name, String signature) {
1010     int len = (int) methods.length();
1011     for (int index = 0; index &lt; len; index++) {
1012       Method m = methods.at(index);
1013       if (m.getSignature().equals(signature) &amp;&amp; m.getName().equals(name)) {
1014         return index;
1015       }
1016     }
1017     return -1;
1018   }
1019 
1020   public void dumpReplayData(PrintStream out) {
1021     ConstantPool cp = getConstants();
1022 
1023     // Try to record related loaded classes
1024     Klass sub = getSubklassKlass();
1025     while (sub != null) {
1026         if (sub instanceof InstanceKlass) {
1027             out.println(&quot;instanceKlass &quot; + sub.getName().asString());
1028         }
1029         sub = sub.getNextSiblingKlass();
1030     }
1031 
1032     final int length = (int) cp.getLength();
1033     out.print(&quot;ciInstanceKlass &quot; + getName().asString() + &quot; &quot; + (isLinked() ? 1 : 0) + &quot; &quot; + (isInitialized() ? 1 : 0) + &quot; &quot; + length);
1034     for (int index = 1; index &lt; length; index++) {
1035       out.print(&quot; &quot; + cp.getTags().at(index));
1036     }
1037     out.println();
1038     if (isInitialized()) {
1039       Field[] staticFields = getStaticFields();
1040       for (int i = 0; i &lt; staticFields.length; i++) {
1041         Field f = staticFields[i];
1042         Oop mirror = getJavaMirror();
1043         if (f.isFinal() &amp;&amp; !f.hasInitialValue()) {
1044           out.print(&quot;staticfield &quot; + getName().asString() + &quot; &quot; +
1045                     OopUtilities.escapeString(f.getID().getName()) + &quot; &quot; +
1046                     f.getFieldType().getSignature().asString() + &quot; &quot;);
1047           if (f instanceof ByteField) {
1048             ByteField bf = (ByteField)f;
1049             out.println(bf.getValue(mirror));
1050           } else if (f instanceof BooleanField) {
1051             BooleanField bf = (BooleanField)f;
1052             out.println(bf.getValue(mirror) ? 1 : 0);
1053           } else if (f instanceof ShortField) {
1054             ShortField bf = (ShortField)f;
1055             out.println(bf.getValue(mirror));
1056           } else if (f instanceof CharField) {
1057             CharField bf = (CharField)f;
1058             out.println(bf.getValue(mirror) &amp; 0xffff);
1059           } else if (f instanceof IntField) {
1060             IntField bf = (IntField)f;
1061             out.println(bf.getValue(mirror));
1062           } else  if (f instanceof LongField) {
1063             LongField bf = (LongField)f;
1064             out.println(bf.getValue(mirror));
1065           } else if (f instanceof FloatField) {
1066             FloatField bf = (FloatField)f;
1067             out.println(Float.floatToRawIntBits(bf.getValue(mirror)));
1068           } else if (f instanceof DoubleField) {
1069             DoubleField bf = (DoubleField)f;
1070             out.println(Double.doubleToRawLongBits(bf.getValue(mirror)));
1071           } else if (f instanceof OopField) {
1072             OopField bf = (OopField)f;
1073 
1074             Oop value = bf.getValue(mirror);
1075             if (value == null) {
1076               out.println(&quot;null&quot;);
1077             } else if (value.isInstance()) {
1078               Instance inst = (Instance)value;
1079               if (inst.isA(SystemDictionary.getStringKlass())) {
1080                 out.println(&quot;\&quot;&quot; + OopUtilities.stringOopToEscapedString(inst) + &quot;\&quot;&quot;);
1081               } else {
1082                 out.println(inst.getKlass().getName().asString());
1083               }
1084             } else if (value.isObjArray()) {
1085               ObjArray oa = (ObjArray)value;
1086               Klass ek = (ObjArrayKlass)oa.getKlass();
1087               out.println(oa.getLength() + &quot; &quot; + ek.getName().asString());
1088             } else if (value.isTypeArray()) {
1089               TypeArray ta = (TypeArray)value;
1090               out.println(ta.getLength());
1091             } else {
1092               out.println(value);
1093             }
1094           }
1095         }
1096       }
1097     }
1098   }
1099 }
    </pre>
  </body>
</html>
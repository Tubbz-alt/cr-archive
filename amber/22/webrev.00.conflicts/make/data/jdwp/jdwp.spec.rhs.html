<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames make/data/jdwp/jdwp.spec</title>
    <link rel="stylesheet" href="../../../style.css" />
    <script type="text/javascript" src="../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 JDWP &quot;Java(tm) Debug Wire Protocol&quot;
  27 (CommandSet VirtualMachine=1
  28     (Command Version=1
  29         &quot;Returns the JDWP version implemented by the target VM. &quot;
  30         &quot;The version string format is implementation dependent. &quot;
  31         (Out
  32         )
  33         (Reply
  34             (string description &quot;Text information on the VM version&quot;)
  35             (int    jdwpMajor   &quot;Major JDWP Version number&quot;)
  36             (int    jdwpMinor   &quot;Minor JDWP Version number&quot;)
  37             (string vmVersion   &quot;Target VM JRE version, as in the java.version property&quot;)
  38             (string vmName      &quot;Target VM name, as in the java.vm.name property&quot;)
  39         )
  40         (ErrorSet
  41             (Error VM_DEAD)
  42         )
  43     )
  44     (Command ClassesBySignature=2
  45         &quot;Returns reference types for all the classes loaded by the target VM &quot;
  46         &quot;which match the given signature. &quot;
  47         &quot;Multple reference types will be returned if two or more class &quot;
  48         &quot;loaders have loaded a class of the same name. &quot;
  49         &quot;The search is confined to loaded classes only; no attempt is made &quot;
  50         &quot;to load a class of the given signature. &quot;
  51         (Out
  52             (string signature &quot;JNI signature of the class to find &quot;
  53                               &quot;(for example, \&quot;Ljava/lang/String;\&quot;). &quot;
  54             )
  55         )
  56         (Reply
  57             (Repeat classes &quot;Number of reference types that follow.&quot;
  58                 (Group ClassInfo
  59                     (byte refTypeTag  &quot;&lt;a href=\&quot;#JDWP_TypeTag\&quot;&gt;Kind&lt;/a&gt; &quot;
  60                                       &quot;of following reference type. &quot;)
  61                     (referenceTypeID typeID &quot;Matching loaded reference type&quot;)
  62                     (int status &quot;The current class &quot;
  63                                 &quot;&lt;a href=\&quot;#JDWP_ClassStatus\&quot;&gt;status.&lt;/a&gt; &quot;)
  64                 )
  65             )
  66         )
  67         (ErrorSet
  68             (Error VM_DEAD)
  69         )
  70     )
  71     (Command AllClasses=3
  72         &quot;Returns reference types for all classes currently loaded by the &quot;
  73         &quot;target VM. &quot;
  74         &quot;See &lt;a href=\&quot;../jvmti.html#GetLoadedClasses\&quot;&gt;JVM TI GetLoadedClasses&lt;/a&gt;.&quot;
  75         (Out
  76         )
  77         (Reply
  78             (Repeat classes &quot;Number of reference types that follow.&quot;
  79                 (Group ClassInfo
  80                     (byte refTypeTag  &quot;&lt;a href=\&quot;#JDWP_TypeTag\&quot;&gt;Kind&lt;/a&gt; &quot;
  81                                       &quot;of following reference type. &quot;)
  82                     (referenceTypeID typeID &quot;Loaded reference type&quot;)
  83                     (string signature
  84                                 &quot;The JNI signature of the loaded reference type&quot;)
  85                     (int status &quot;The current class &quot;
  86                                 &quot;&lt;a href=\&quot;#JDWP_ClassStatus\&quot;&gt;status.&lt;/a&gt; &quot;)
  87                 )
  88             )
  89         )
  90         (ErrorSet
  91             (Error VM_DEAD)
  92         )
  93     )
  94     (Command AllThreads=4
  95         &quot;Returns all threads currently running in the target VM . &quot;
  96         &quot;The returned list contains threads created through &quot;
  97         &quot;java.lang.Thread, all native threads attached to &quot;
  98         &quot;the target VM through JNI, and system threads created &quot;
  99         &quot;by the target VM. Threads that have not yet been started &quot;
 100         &quot;and threads that have completed their execution are not &quot;
 101         &quot;included in the returned list. &quot;
 102         (Out
 103         )
 104         (Reply
 105             (Repeat threads &quot;Number of threads that follow.&quot;
 106                 (threadObject thread &quot;A running thread&quot;)
 107             )
 108         )
 109         (ErrorSet
 110             (Error VM_DEAD)
 111         )
 112     )
 113     (Command TopLevelThreadGroups=5
 114         &quot;Returns all thread groups that do not have a parent. This command &quot;
 115         &quot;may be used as the first step in building a tree (or trees) of the &quot;
 116         &quot;existing thread groups.&quot;
 117         (Out
 118         )
 119         (Reply
 120             (Repeat groups &quot;Number of thread groups that follow.&quot;
 121                 (threadGroupObject group &quot;A top level thread group&quot;)
 122             )
 123         )
 124         (ErrorSet
 125             (Error VM_DEAD)
 126         )
 127     )
 128     (Command Dispose=6
 129         &quot;Invalidates this virtual machine mirror. &quot;
 130         &quot;The communication channel to the target VM is closed, and &quot;
 131         &quot;the target VM prepares to accept another subsequent connection &quot;
 132         &quot;from this debugger or another debugger, including the &quot;
 133         &quot;following tasks: &quot;
 134         &quot;&lt;ul&gt;&quot;
 135         &quot;&lt;li&gt;All event requests are cancelled. &quot;
 136         &quot;&lt;li&gt;All threads suspended by the thread-level &quot;
 137         &quot;&lt;a href=\&quot;#JDWP_ThreadReference_Resume\&quot;&gt;resume&lt;/a&gt; command &quot;
 138         &quot;or the VM-level &quot;
 139         &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_Resume\&quot;&gt;resume&lt;/a&gt; command &quot;
 140         &quot;are resumed as many times as necessary for them to run. &quot;
 141         &quot;&lt;li&gt;Garbage collection is re-enabled in all cases where it was &quot;
 142         &quot;&lt;a href=\&quot;#JDWP_ObjectReference_DisableCollection\&quot;&gt;disabled&lt;/a&gt; &quot;
 143         &quot;&lt;/ul&gt;&quot;
 144         &quot;Any current method invocations executing in the target VM &quot;
 145         &quot;are continued after the disconnection. Upon completion of any such &quot;
 146         &quot;method invocation, the invoking thread continues from the &quot;
 147         &quot;location where it was originally stopped. &quot;
 148         &quot;&lt;p&gt;&quot;
 149         &quot;Resources originating in  &quot;
 150         &quot;this VirtualMachine (ObjectReferences, ReferenceTypes, etc.) &quot;
 151         &quot;will become invalid. &quot;
 152         (Out
 153         )
 154         (Reply
 155         )
 156         (ErrorSet
 157         )
 158     )
 159     (Command IDSizes=7
 160         &quot;Returns the sizes of variably-sized data types in the target VM.&quot;
 161         &quot;The returned values indicate the number of bytes used by the &quot;
 162         &quot;identifiers in command and reply packets.&quot;
 163         (Out
 164         )
 165         (Reply
 166             (int fieldIDSize &quot;fieldID size in bytes &quot;)
 167             (int methodIDSize &quot;methodID size in bytes &quot;)
 168             (int objectIDSize &quot;objectID size in bytes &quot;)
 169             (int referenceTypeIDSize &quot;referenceTypeID size in bytes &quot;)
 170             (int frameIDSize &quot;frameID size in bytes &quot;)
 171         )
 172         (ErrorSet
 173             (Error VM_DEAD)
 174         )
 175     )
 176     (Command Suspend=8
 177         &quot;Suspends the execution of the application running in the target &quot;
 178         &quot;VM. All Java threads currently running will be suspended. &quot;
 179         &quot;&lt;p&gt;&quot;
 180         &quot;Unlike java.lang.Thread.suspend, &quot;
 181         &quot;suspends of both the virtual machine and individual threads are &quot;
 182         &quot;counted. Before a thread will run again, it must be resumed through &quot;
 183         &quot;the &lt;a href=\&quot;#JDWP_VirtualMachine_Resume\&quot;&gt;VM-level resume&lt;/a&gt; command &quot;
 184         &quot;or the &lt;a href=\&quot;#JDWP_ThreadReference_Resume\&quot;&gt;thread-level resume&lt;/a&gt; command &quot;
 185         &quot;the same number of times it has been suspended. &quot;
 186         (Out
 187         )
 188         (Reply
 189         )
 190         (ErrorSet
 191             (Error VM_DEAD)
 192         )
 193     )
 194     (Command Resume=9
 195         &quot;Resumes execution of the application after the suspend &quot;
 196         &quot;command or an event has stopped it. &quot;
 197         &quot;Suspensions of the Virtual Machine and individual threads are &quot;
 198         &quot;counted. If a particular thread is suspended n times, it must &quot;
 199         &quot;resumed n times before it will continue. &quot;
 200         (Out
 201         )
 202         (Reply
 203         )
 204         (ErrorSet
 205         )
 206     )
 207     (Command Exit=10
 208         &quot;Terminates the target VM with the given exit code. &quot;
 209         &quot;On some platforms, the exit code might be truncated, for &quot;
 210         &quot;example, to the low order 8 bits. &quot;
 211         &quot;All ids previously returned from the target VM become invalid. &quot;
 212         &quot;Threads running in the VM are abruptly terminated. &quot;
 213         &quot;A thread death exception is not thrown and &quot;
 214         &quot;finally blocks are not run.&quot;
 215         (Out
 216             (int exitCode &quot;the exit code&quot;)
 217         )
 218         (Reply
 219         )
 220         (ErrorSet
 221         )
 222     )
 223     (Command CreateString=11
 224         &quot;Creates a new string object in the target VM and returns &quot;
 225         &quot;its id. &quot;
 226         (Out
 227             (string utf &quot;UTF-8 characters to use in the created string. &quot;)
 228         )
 229         (Reply
 230             (stringObject stringObject
 231                 &quot;Created string (instance of java.lang.String) &quot;)
 232         )
 233         (ErrorSet
 234             (Error VM_DEAD)
 235         )
 236     )
 237     (Command Capabilities=12
 238         &quot;Retrieve this VM&#39;s capabilities. The capabilities are returned &quot;
 239         &quot;as booleans, each indicating the presence or absence of a &quot;
 240         &quot;capability. The commands associated with each capability will &quot;
 241         &quot;return the NOT_IMPLEMENTED error if the cabability is not &quot;
 242         &quot;available.&quot;
 243         (Out
 244         )
 245         (Reply
 246             (boolean canWatchFieldModification
 247                      &quot;Can the VM watch field modification, and therefore &quot;
 248                      &quot;can it send the Modification Watchpoint Event?&quot;)
 249             (boolean canWatchFieldAccess
 250                      &quot;Can the VM watch field access, and therefore &quot;
 251                      &quot;can it send the Access Watchpoint Event?&quot;)
 252             (boolean canGetBytecodes
 253                      &quot;Can the VM get the bytecodes of a given method? &quot;)
 254             (boolean canGetSyntheticAttribute
 255                      &quot;Can the VM determine whether a field or method is &quot;
 256                      &quot;synthetic? (that is, can the VM determine if the &quot;
 257                      &quot;method or the field was invented by the compiler?) &quot;)
 258             (boolean canGetOwnedMonitorInfo
 259                      &quot;Can the VM get the owned monitors infornation for &quot;
 260                      &quot;a thread?&quot;)
 261             (boolean canGetCurrentContendedMonitor
 262                      &quot;Can the VM get the current contended monitor of a thread?&quot;)
 263             (boolean canGetMonitorInfo
 264                      &quot;Can the VM get the monitor information for a given object? &quot;)
 265         )
 266         (ErrorSet
 267             (Error VM_DEAD)
 268         )
 269     )
 270     (Command ClassPaths=13
 271         &quot;Retrieve the classpath and bootclasspath of the target VM. &quot;
 272         &quot;If the classpath is not defined, returns an empty list. If the &quot;
 273         &quot;bootclasspath is not defined returns an empty list.&quot;
 274         (Out
 275         )
 276         (Reply
 277             (string baseDir &quot;Base directory used to resolve relative &quot;
 278                             &quot;paths in either of the following lists.&quot;)
 279             (Repeat classpaths &quot;Number of paths in classpath.&quot;
 280                 (string path &quot;One component of classpath&quot;) )
 281             (Repeat bootclasspaths &quot;Number of paths in bootclasspath.&quot;
 282                 (string path &quot;One component of bootclasspath&quot;) )
 283         )
 284         (ErrorSet
 285             (Error VM_DEAD)
 286         )
 287     )
 288     (Command DisposeObjects=14
 289         &quot;Releases a list of object IDs. For each object in the list, the &quot;
 290         &quot;following applies. &quot;
 291         &quot;The count of references held by the back-end (the reference &quot;
 292         &quot;count) will be decremented by refCnt. &quot;
 293         &quot;If thereafter the reference count is less than &quot;
 294         &quot;or equal to zero, the ID is freed. &quot;
 295         &quot;Any back-end resources associated with the freed ID may &quot;
 296         &quot;be freed, and if garbage collection was &quot;
 297         &quot;disabled for the object, it will be re-enabled. &quot;
 298         &quot;The sender of this command &quot;
 299         &quot;promises that no further commands will be sent &quot;
 300         &quot;referencing a freed ID.
 301         &quot;&lt;p&gt;&quot;
 302         &quot;Use of this command is not required. If it is not sent, &quot;
 303         &quot;resources associated with each ID will be freed by the back-end &quot;
 304         &quot;at some time after the corresponding object is garbage collected. &quot;
 305         &quot;It is most useful to use this command to reduce the load on the &quot;
 306         &quot;back-end if a very large number of &quot;
 307         &quot;objects has been retrieved from the back-end (a large array, &quot;
 308         &quot;for example) but may not be garbage collected any time soon. &quot;
 309         &quot;&lt;p&gt;&quot;
 310         &quot;IDs may be re-used by the back-end after they &quot;
 311         &quot;have been freed with this command.&quot;
 312         &quot;This description assumes reference counting, &quot;
 313         &quot;a back-end may use any implementation which operates &quot;
 314         &quot;equivalently. &quot;
 315         (Out
 316             (Repeat requests &quot;Number of object dispose requests that follow&quot;
 317                 (Group Request
 318                     (object object &quot;The object ID&quot;)
 319                     (int refCnt &quot;The number of times this object ID has been &quot;
 320                                 &quot;part of a packet received from the back-end. &quot;
 321                                 &quot;An accurate count prevents the object ID &quot;
 322                                 &quot;from being freed on the back-end if &quot;
 323                                 &quot;it is part of an incoming packet, not yet &quot;
 324                                 &quot;handled by the front-end.&quot;)
 325                 )
 326             )
 327         )
 328         (Reply
 329         )
 330         (ErrorSet
 331         )
 332     )
 333     (Command HoldEvents=15
 334         &quot;Tells the target VM to stop sending events. Events are not discarded; &quot;
 335         &quot;they are held until a subsequent ReleaseEvents command is sent. &quot;
 336         &quot;This command is useful to control the number of events sent &quot;
 337         &quot;to the debugger VM in situations where very large numbers of events &quot;
 338         &quot;are generated. &quot;
 339         &quot;While events are held by the debugger back-end, application &quot;
 340         &quot;execution may be frozen by the debugger back-end to prevent &quot;
 341         &quot;buffer overflows on the back end.
 342         &quot;Responses to commands are never held and are not affected by this
 343         &quot;command. If events are already being held, this command is &quot;
 344         &quot;ignored.&quot;
 345         (Out
 346         )
 347         (Reply
 348         )
 349         (ErrorSet
 350         )
 351     )
 352     (Command ReleaseEvents=16
 353         &quot;Tells the target VM to continue sending events. This command is &quot;
 354         &quot;used to restore normal activity after a HoldEvents command. If &quot;
 355         &quot;there is no current HoldEvents command in effect, this command is &quot;
 356         &quot;ignored.&quot;
 357         (Out
 358         )
 359         (Reply
 360         )
 361         (ErrorSet
 362         )
 363     )
 364     (Command CapabilitiesNew=17
 365         &quot;Retrieve all of this VM&#39;s capabilities. The capabilities are returned &quot;
 366         &quot;as booleans, each indicating the presence or absence of a &quot;
 367         &quot;capability. The commands associated with each capability will &quot;
 368         &quot;return the NOT_IMPLEMENTED error if the cabability is not &quot;
 369         &quot;available.&quot;
 370         &quot;Since JDWP version 1.4.&quot;
 371         (Out
 372         )
 373         (Reply
 374             (boolean canWatchFieldModification
 375                      &quot;Can the VM watch field modification, and therefore &quot;
 376                      &quot;can it send the Modification Watchpoint Event?&quot;)
 377             (boolean canWatchFieldAccess
 378                      &quot;Can the VM watch field access, and therefore &quot;
 379                      &quot;can it send the Access Watchpoint Event?&quot;)
 380             (boolean canGetBytecodes
 381                      &quot;Can the VM get the bytecodes of a given method? &quot;)
 382             (boolean canGetSyntheticAttribute
 383                      &quot;Can the VM determine whether a field or method is &quot;
 384                      &quot;synthetic? (that is, can the VM determine if the &quot;
 385                      &quot;method or the field was invented by the compiler?) &quot;)
 386             (boolean canGetOwnedMonitorInfo
 387                      &quot;Can the VM get the owned monitors infornation for &quot;
 388                      &quot;a thread?&quot;)
 389             (boolean canGetCurrentContendedMonitor
 390                      &quot;Can the VM get the current contended monitor of a thread?&quot;)
 391             (boolean canGetMonitorInfo
 392                      &quot;Can the VM get the monitor information for a given object? &quot;)
 393             (boolean canRedefineClasses
 394                      &quot;Can the VM redefine classes?&quot;)
 395             (boolean canAddMethod
 396                      &quot;Can the VM add methods when redefining &quot;
 397                      &quot;classes?&quot;)
 398             (boolean canUnrestrictedlyRedefineClasses
 399                      &quot;Can the VM redefine classes &quot;
 400                      &quot;in ways that are normally restricted?&quot;)
 401             (boolean canPopFrames
 402                      &quot;Can the VM pop stack frames?&quot;)
 403             (boolean canUseInstanceFilters
 404                      &quot;Can the VM filter events by specific object?&quot;)
 405             (boolean canGetSourceDebugExtension
 406                      &quot;Can the VM get the source debug extension?&quot;)
 407             (boolean canRequestVMDeathEvent
 408                      &quot;Can the VM request VM death events?&quot;)
 409             (boolean canSetDefaultStratum
 410                      &quot;Can the VM set a default stratum?&quot;)
 411             (boolean canGetInstanceInfo
 412                      &quot;Can the VM return instances, counts of instances of classes &quot;
 413                      &quot;and referring objects?&quot;)
 414             (boolean canRequestMonitorEvents
 415                      &quot;Can the VM request monitor events?&quot;)
 416             (boolean canGetMonitorFrameInfo
 417                      &quot;Can the VM get monitors with frame depth info?&quot;)
 418             (boolean canUseSourceNameFilters
 419                      &quot;Can the VM filter class prepare events by source name?&quot;)
 420             (boolean canGetConstantPool
 421                      &quot;Can the VM return the constant pool information?&quot;)
 422             (boolean canForceEarlyReturn
 423                      &quot;Can the VM force early return from a method?&quot;)
 424             (boolean reserved22
 425                      &quot;Reserved for future capability&quot;)
 426             (boolean reserved23
 427                      &quot;Reserved for future capability&quot;)
 428             (boolean reserved24
 429                      &quot;Reserved for future capability&quot;)
 430             (boolean reserved25
 431                      &quot;Reserved for future capability&quot;)
 432             (boolean reserved26
 433                      &quot;Reserved for future capability&quot;)
 434             (boolean reserved27
 435                      &quot;Reserved for future capability&quot;)
 436             (boolean reserved28
 437                      &quot;Reserved for future capability&quot;)
 438             (boolean reserved29
 439                      &quot;Reserved for future capability&quot;)
 440             (boolean reserved30
 441                      &quot;Reserved for future capability&quot;)
 442             (boolean reserved31
 443                      &quot;Reserved for future capability&quot;)
 444             (boolean reserved32
 445                      &quot;Reserved for future capability&quot;)
 446         )
 447         (ErrorSet
 448             (Error VM_DEAD)
 449         )
 450     )
 451     (Command RedefineClasses=18
 452         &quot;Installs new class definitions. &quot;
 453         &quot;If there are active stack frames in methods of the redefined classes in the &quot;
 454         &quot;target VM then those active frames continue to run the bytecodes of the &quot;
 455         &quot;original method. These methods are considered obsolete - see &quot;
 456         &quot;&lt;a href=\&quot;#JDWP_Method_IsObsolete\&quot;&gt;IsObsolete&lt;/a&gt;. The methods in the &quot;
 457         &quot;redefined classes will be used for new invokes in the target VM. &quot;
 458         &quot;The original method ID refers to the redefined method. &quot;
 459         &quot;All breakpoints in the redefined classes are cleared.&quot;
 460         &quot;If resetting of stack frames is desired, the &quot;
 461         &quot;&lt;a href=\&quot;#JDWP_StackFrame_PopFrames\&quot;&gt;PopFrames&lt;/a&gt; command can be used &quot;
 462         &quot;to pop frames with obsolete methods.&quot;
 463         &quot;&lt;p&gt;&quot;
<a name="1" id="anc1"></a><span class="line-added"> 464 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span>
 465         &quot;Unless the canUnrestrictedlyRedefineClasses capability is present &quot;
 466         &quot;the redefinition must follow the restrictions described in &quot;
 467         &quot;&lt;a href=\&quot;../jvmti.html#RedefineClasses\&quot;&gt;JVM TI RedefineClasses&lt;/a&gt;.&quot;
<a name="2" id="anc2"></a><span class="line-added"> 468 =======</span>
<span class="line-added"> 469         &quot;Unless the canUnrestrictedlyRedefineClasses capability is present the following &quot;</span>
<span class="line-added"> 470         &quot;redefinitions are restricted: &quot;</span>
<span class="line-added"> 471         &quot;&lt;ul&gt;&quot;</span>
<span class="line-added"> 472         &quot;&lt;li&gt;changing the schema (the fields)&lt;/li&gt;&quot;</span>
<span class="line-added"> 473         &quot;&lt;li&gt;changing the hierarchy (superclasses, interfaces)&lt;/li&gt;&quot;</span>
<span class="line-added"> 474         &quot;&lt;li&gt;deleting a method&lt;/li&gt;&quot;</span>
<span class="line-added"> 475         &quot;&lt;li&gt;changing class modifiers&lt;/li&gt;&quot;</span>
<span class="line-added"> 476         &quot;&lt;li&gt;changing method modifiers&lt;/li&gt;&quot;</span>
<span class="line-added"> 477         &quot;&lt;li&gt;changing the &lt;code&gt;NestHost&lt;/code&gt;, &lt;code&gt;NestMembers&lt;/code&gt;, &lt;code&gt;PermittedSubclasses&lt;/code&gt;, or &lt;code&gt;Record&lt;/code&gt; class attributes&lt;/li&gt;&quot;</span>
<span class="line-added"> 478         &quot;&lt;/ul&gt;&quot;</span>
<span class="line-added"> 479 &gt;&gt;&gt;&gt;&gt;&gt;&gt; 926ea22b56c80bf0e4ce5f1d92bc1d31ac91e978</span>
 480         &quot;&lt;p&gt;&quot;
 481         &quot;Requires canRedefineClasses capability - see &quot;
 482         &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;. &quot;
 483         &quot;In addition to the canRedefineClasses capability, the target VM must &quot;
 484         &quot;have the canAddMethod capability to add methods when redefining classes, &quot;
 485         &quot;or the canUnrestrictedlyRedefineClasses capability to redefine classes in ways &quot;
 486         &quot;that are normally restricted.&quot;
 487         (Out
 488             (Repeat classes &quot;Number of reference types that follow.&quot;
 489                 (Group ClassDef
 490                     (referenceType refType &quot;The reference type.&quot;)
 491                     (Repeat classfile &quot;Number of bytes defining class (below)&quot;
 492                          (byte classbyte &quot;byte in JVM class file &quot;
 493                                          &quot;format.&quot;)
 494                     )
 495                 )
 496             )
 497         )
 498         (Reply
 499         )
 500         (ErrorSet
 501             (Error INVALID_CLASS    &quot;One of the refTypes is not the ID of a reference &quot;
 502                                     &quot;type.&quot;)
 503             (Error INVALID_OBJECT   &quot;One of the refTypes is not a known ID.&quot;)
 504             (Error UNSUPPORTED_VERSION)
 505             (Error INVALID_CLASS_FORMAT)
 506             (Error CIRCULAR_CLASS_DEFINITION)
 507             (Error FAILS_VERIFICATION)
 508             (Error NAMES_DONT_MATCH)
 509             (Error NOT_IMPLEMENTED  &quot;No aspect of this functionality is implemented &quot;
 510                                     &quot;(CapabilitiesNew.canRedefineClasses is false)&quot;)
 511             (Error ADD_METHOD_NOT_IMPLEMENTED)
 512             (Error SCHEMA_CHANGE_NOT_IMPLEMENTED)
 513             (Error HIERARCHY_CHANGE_NOT_IMPLEMENTED)
 514             (Error DELETE_METHOD_NOT_IMPLEMENTED)
 515             (Error CLASS_MODIFIERS_CHANGE_NOT_IMPLEMENTED)
 516             (Error METHOD_MODIFIERS_CHANGE_NOT_IMPLEMENTED)
 517             (Error CLASS_ATTRIBUTE_CHANGE_NOT_IMPLEMENTED)
 518             (Error VM_DEAD)
 519         )
 520     )
 521     (Command SetDefaultStratum=19
 522         &quot;Set the default stratum. Requires canSetDefaultStratum capability - see &quot;
 523         &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;.&quot;
 524         (Out
 525             (string stratumID &quot;default stratum, or empty string to use &quot;
 526                               &quot;reference type default.&quot;)
 527         )
 528         (Reply
 529         )
 530         (ErrorSet
 531             (Error NOT_IMPLEMENTED)
 532             (Error VM_DEAD)
 533         )
 534     )
 535     (Command AllClassesWithGeneric=20
 536         &quot;Returns reference types for all classes currently loaded by the &quot;
 537         &quot;target VM.  &quot;
 538         &quot;Both the JNI signature and the generic signature are &quot;
 539         &quot;returned for each class.  &quot;
 540         &quot;Generic signatures are described in the signature attribute &quot;
 541         &quot;section in &quot;
 542         &quot;&lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;. &quot;
 543         &quot;Since JDWP version 1.5.&quot;
 544         (Out
 545         )
 546         (Reply
 547             (Repeat classes &quot;Number of reference types that follow.&quot;
 548                 (Group ClassInfo
 549                     (byte refTypeTag  &quot;&lt;a href=\&quot;#JDWP_TypeTag\&quot;&gt;Kind&lt;/a&gt; &quot;
 550                                       &quot;of following reference type. &quot;)
 551                     (referenceTypeID typeID &quot;Loaded reference type&quot;)
 552                     (string signature
 553                                 &quot;The JNI signature of the loaded reference type.&quot;)
 554                     (string genericSignature
 555                                 &quot;The generic signature of the loaded reference type &quot;
 556                                 &quot;or an empty string if there is none.&quot;)
 557                     (int status &quot;The current class &quot;
 558                                 &quot;&lt;a href=\&quot;#JDWP_ClassStatus\&quot;&gt;status.&lt;/a&gt; &quot;)
 559                 )
 560             )
 561         )
 562         (ErrorSet
 563             (Error VM_DEAD)
 564         )
 565     )
 566 
 567     (Command InstanceCounts=21
 568         &quot;Returns the number of instances of each reference type in the input list. &quot;
 569         &quot;Only instances that are reachable for the purposes of &quot;
 570         &quot;garbage collection are counted.  If a reference type is invalid, &quot;
 571         &quot;eg. it has been unloaded, zero is returned for its instance count.&quot;
 572         &quot;&lt;p&gt;Since JDWP version 1.6. Requires canGetInstanceInfo capability - see &quot;
 573         &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;.&quot;
 574         (Out
 575             (Repeat refTypesCount &quot;Number of reference types that follow.    Must be non-negative.&quot;
 576                 (referenceType refType &quot;A reference type ID.&quot;)
 577             )
 578           )
 579         (Reply
 580             (Repeat counts &quot;The number of counts that follow.&quot;
 581               (long instanceCount &quot;The number of instances for the corresponding reference type &quot;
 582                                   &quot;in &#39;Out Data&#39;.&quot;)
 583             )
 584         )
 585         (ErrorSet
 586             (Error ILLEGAL_ARGUMENT   &quot;refTypesCount is less than zero.&quot;)
 587             (Error NOT_IMPLEMENTED)
 588             (Error VM_DEAD)
 589         )
 590     )
 591     (Command AllModules=22
 592         &quot;Returns all modules in the target VM.&quot;
 593         &quot;&lt;p&gt;Since JDWP version 9.&quot;
 594         (Out
 595         )
 596         (Reply
 597             (Repeat modules &quot;The number of the modules that follow.&quot;
 598                 (moduleID module &quot;One of the modules.&quot;)
 599             )
 600         )
 601         (ErrorSet
 602             (Error NOT_IMPLEMENTED)
 603             (Error VM_DEAD)
 604         )
 605     )
 606 )
 607 
 608 (CommandSet ReferenceType=2
 609     (Command Signature=1
 610         &quot;Returns the type signature of a reference type. &quot;
 611         &quot;Type signature formats are the same as specified in &quot;
 612         &quot;&lt;a href=\&quot;../jvmti.html#GetClassSignature\&quot;&gt;JVM TI GetClassSignature&lt;/a&gt;.&quot;
 613         (Out
 614             (referenceType refType &quot;The reference type ID.&quot;)
 615         )
 616         (Reply
 617             (string signature
 618                 &quot;The JNI signature for the reference type.&quot;)
 619         )
 620         (ErrorSet
 621             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
 622                                      &quot;type.&quot;)
 623             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
 624             (Error VM_DEAD)
 625         )
 626     )
 627     (Command ClassLoader=2
 628         &quot;Returns the instance of java.lang.ClassLoader which loaded &quot;
 629         &quot;a given reference type. If the reference type was loaded by the &quot;
 630         &quot;system class loader, the returned object ID is null.&quot;
 631         (Out
 632             (referenceType refType &quot;The reference type ID.&quot;)
 633         )
 634         (Reply
 635             (classLoaderObject classLoader &quot;The class loader for the reference type. &quot;)
 636         )
 637         (ErrorSet
 638             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
 639                                      &quot;type.&quot;)
 640             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
 641             (Error VM_DEAD)
 642         )
 643     )
 644     (Command Modifiers=3
 645         &quot;Returns the modifiers (also known as access flags) for a reference type. &quot;
 646         &quot;The returned bit mask contains information on the declaration &quot;
 647         &quot;of the reference type. If the reference type is an array or &quot;
 648         &quot;a primitive class (for example, java.lang.Integer.TYPE), the &quot;
 649         &quot;value of the returned bit mask is undefined.&quot;
 650         (Out
 651             (referenceType refType &quot;The reference type ID.&quot;)
 652         )
 653         (Reply
 654             (int modBits &quot;Modifier bits as defined in Chapter 4 of &quot;
 655                          &quot;&lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;&quot;)
 656         )
 657         (ErrorSet
 658             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
 659                                      &quot;type.&quot;)
 660             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
 661             (Error VM_DEAD)
 662         )
 663     )
 664     (Command Fields=4
 665         &quot;Returns information for each field in a reference type. &quot;
 666         &quot;Inherited fields are not included. &quot;
 667         &quot;The field list will include any synthetic fields created &quot;
 668         &quot;by the compiler. &quot;
 669         &quot;Fields are returned in the order they occur in the class file.&quot;
 670         (Out
 671             (referenceType refType &quot;The reference type ID.&quot;)
 672         )
 673         (Reply
 674             (Repeat declared &quot;Number of declared fields.&quot;
 675                 (Group FieldInfo
 676                     (field fieldID &quot;Field ID.&quot;)
 677                     (string name &quot;Name of field.&quot;)
 678                     (string signature &quot;JNI Signature of field.&quot;)
 679                     (int modBits &quot;The modifier bit flags (also known as access flags) &quot;
 680                                  &quot;which provide additional information on the  &quot;
 681                                  &quot;field declaration. Individual flag values are &quot;
 682                                  &quot;defined in Chapter 4 of &quot;
 683                                  &quot;&lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;. &quot;
 684                                  &quot;In addition, The &lt;code&gt;0xf0000000&lt;/code&gt; bit identifies &quot;
 685                                  &quot;the field as synthetic, if the synthetic attribute &quot;
 686                                  &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_Capabilities\&quot;&gt;capability&lt;/a&gt; is available.&quot;)
 687                 )
 688             )
 689         )
 690         (ErrorSet
 691             (Error CLASS_NOT_PREPARED)
 692             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
 693                                      &quot;type.&quot;)
 694             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
 695             (Error VM_DEAD)
 696         )
 697     )
 698     (Command Methods=5
 699         &quot;Returns information for each method in a reference type. &quot;
 700         &quot;Inherited methods are not included. The list of methods will &quot;
 701         &quot;include constructors (identified with the name \&quot;&amp;lt;init&amp;gt;\&quot;), &quot;
 702         &quot;the initialization method (identified with the name \&quot;&amp;lt;clinit&amp;gt;\&quot;) &quot;
 703         &quot;if present, and any synthetic methods created by the compiler. &quot;
 704         &quot;Methods are returned in the order they occur in the class file.&quot;
 705         (Out
 706             (referenceType refType &quot;The reference type ID.&quot;)
 707         )
 708         (Reply
 709             (Repeat declared &quot;Number of declared methods.&quot;
 710                 (Group MethodInfo
 711                     (method methodID &quot;Method ID.&quot;)
 712                     (string name &quot;Name of method.&quot;)
 713                     (string signature &quot;JNI signature of method.&quot;)
 714                     (int modBits &quot;The modifier bit flags (also known as access flags) &quot;
 715                                  &quot;which provide additional information on the  &quot;
 716                                  &quot;method declaration. Individual flag values are &quot;
 717                                  &quot;defined in Chapter 4 of &quot;
 718                                  &quot;&lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;. &quot;
 719                                  &quot;In addition, The &lt;code&gt;0xf0000000&lt;/code&gt; bit identifies &quot;
 720                                  &quot;the method as synthetic, if the synthetic attribute &quot;
 721                                  &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_Capabilities\&quot;&gt;capability&lt;/a&gt; is available.&quot;)
 722                 )
 723             )
 724         )
 725         (ErrorSet
 726             (Error CLASS_NOT_PREPARED)
 727             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
 728                                      &quot;type.&quot;)
 729             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
 730             (Error VM_DEAD)
 731         )
 732     )
 733     (Command GetValues=6
 734         &quot;Returns the value of one or more static fields of the &quot;
 735         &quot;reference type. Each field must be member of the reference type &quot;
 736         &quot;or one of its superclasses, superinterfaces, or implemented interfaces. &quot;
 737         &quot;Access control is not enforced; for example, the values of private &quot;
 738         &quot;fields can be obtained.&quot;
 739         (Out
 740             (referenceType refType &quot;The reference type ID.&quot;)
 741             (Repeat fields &quot;The number of values to get&quot;
 742                 (Group Field
 743                     (field fieldID &quot;A field to get&quot;)
 744                 )
 745             )
 746         )
 747         (Reply
 748             (Repeat values &quot;The number of values returned, always equal to fields, &quot;
 749                            &quot;the number of values to get.&quot;
 750                 (value value &quot;The field value&quot;)
 751             )
 752         )
 753         (ErrorSet
 754             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
 755                                      &quot;type.&quot;)
 756             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
 757             (Error INVALID_FIELDID)
 758             (Error VM_DEAD)
 759         )
 760     )
 761     (Command SourceFile=7
 762         &quot;Returns the name of source file in which a reference type was &quot;
 763         &quot;declared. &quot;
 764         (Out
 765             (referenceType refType &quot;The reference type ID.&quot;)
 766         )
 767         (Reply
 768             (string sourceFile &quot;The source file name. No path information &quot;
 769                                &quot;for the file is included&quot;)
 770         )
 771         (ErrorSet
 772             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
 773                                      &quot;type.&quot;)
 774             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
 775             (Error ABSENT_INFORMATION &quot;The source file attribute is absent.&quot;)
 776             (Error VM_DEAD)
 777         )
 778     )
 779     (Command NestedTypes=8
 780         &quot;Returns the classes and interfaces directly nested within this type.&quot;
 781         &quot;Types further nested within those types are not included. &quot;
 782         (Out
 783             (referenceType refType &quot;The reference type ID.&quot;)
 784         )
 785         (Reply
 786             (Repeat classes &quot;The number of nested classes and interfaces&quot;
 787                 (Group TypeInfo
 788                     (byte refTypeTag  &quot;&lt;a href=\&quot;#JDWP_TypeTag\&quot;&gt;Kind&lt;/a&gt; &quot;
 789                                       &quot;of following reference type. &quot;)
 790                     (referenceTypeID typeID &quot;The nested class or interface ID.&quot;)
 791                 )
 792             )
 793         )
 794         (ErrorSet
 795             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
 796                                      &quot;type.&quot;)
 797             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
 798             (Error VM_DEAD)
 799         )
 800     )
 801     (Command Status=9
 802         &quot;Returns the current status of the reference type. The status &quot;
 803         &quot;indicates the extent to which the reference type has been &quot;
 804         &quot;initialized, as described in section 2.1.6 of &quot;
 805         &quot;&lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;. &quot;
 806         &quot;If the class is linked the PREPARED and VERIFIED bits in the returned status bits &quot;
 807         &quot;will be set. If the class is initialized the INITIALIZED bit in the returned &quot;
 808         &quot;status bits will be set. If an error occured during initialization then the &quot;
 809         &quot;ERROR bit in the returned status bits will be set. &quot;
 810         &quot;The returned status bits are undefined for array types and for &quot;
 811         &quot;primitive classes (such as java.lang.Integer.TYPE). &quot;
 812         (Out
 813             (referenceType refType &quot;The reference type ID.&quot;)
 814         )
 815         (Reply
 816             (int status &quot;&lt;a href=\&quot;#JDWP_ClassStatus\&quot;&gt;Status&lt;/a&gt; bits:&quot;
 817                         &quot;See &lt;a href=\&quot;#JDWP_ClassStatus\&quot;&gt;JDWP.ClassStatus&lt;/a&gt;&quot;)
 818         )
 819         (ErrorSet
 820             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
 821                                      &quot;type.&quot;)
 822             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
 823             (Error VM_DEAD)
 824         )
 825     )
 826     (Command Interfaces=10
 827         &quot;Returns the interfaces declared as implemented by this class. &quot;
 828         &quot;Interfaces indirectly implemented (extended by the implemented &quot;
 829         &quot;interface or implemented by a superclass) are not included.&quot;
 830         (Out
 831             (referenceType refType &quot;The reference type ID.&quot;)
 832         )
 833         (Reply
 834             (Repeat interfaces &quot;The number of implemented interfaces&quot;
 835                 (interfaceType interfaceType &quot;implemented interface.&quot;)
 836             )
 837         )
 838         (ErrorSet
 839             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
 840                                      &quot;type.&quot;)
 841             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
 842             (Error VM_DEAD)
 843         )
 844     )
 845     (Command ClassObject=11
 846         &quot;Returns the class object corresponding to this type. &quot;
 847         (Out
 848             (referenceType refType &quot;The reference type ID.&quot;)
 849         )
 850         (Reply
 851             (classObject classObject &quot;class object.&quot;)
 852         )
 853         (ErrorSet
 854             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
 855                                      &quot;type.&quot;)
 856             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
 857             (Error VM_DEAD)
 858         )
 859     )
 860     (Command SourceDebugExtension=12
 861         &quot;Returns the value of the SourceDebugExtension attribute. &quot;
 862         &quot;Since JDWP version 1.4. Requires canGetSourceDebugExtension capability - see &quot;
 863         &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;.&quot;
 864         (Out
 865             (referenceType refType &quot;The reference type ID.&quot;)
 866         )
 867         (Reply
 868             (string extension &quot;extension attribute&quot;)
 869         )
 870         (ErrorSet
 871             (Error INVALID_CLASS      &quot;refType is not the ID of a reference &quot;
 872                                       &quot;type.&quot;)
 873             (Error INVALID_OBJECT     &quot;refType is not a known ID.&quot;)
 874             (Error ABSENT_INFORMATION &quot;If the extension is not specified.&quot;)
 875             (Error NOT_IMPLEMENTED)
 876             (Error VM_DEAD)
 877         )
 878     )
 879     (Command SignatureWithGeneric=13
 880         &quot;Returns the JNI signature of a reference type along with the &quot;
 881         &quot;generic signature if there is one.  &quot;
 882         &quot;Generic signatures are described in the signature attribute &quot;
 883         &quot;section in &quot;
 884         &quot;&lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;. &quot;
 885         &quot;Since JDWP version 1.5.&quot;
 886         (Out
 887             (referenceType refType &quot;The reference type ID.&quot;)
 888         )
 889         (Reply
 890             (string signature
 891                 &quot;The JNI signature for the reference type.&quot;)
 892             (string genericSignature
 893                 &quot;The generic signature for the reference type or an empty &quot;
 894                 &quot;string if there is none.&quot;)
 895         )
 896         (ErrorSet
 897             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
 898                                      &quot;type.&quot;)
 899             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
 900             (Error VM_DEAD)
 901         )
 902     )
 903     (Command FieldsWithGeneric=14
 904         &quot;Returns information, including the generic signature if any, &quot;
 905         &quot;for each field in a reference type. &quot;
 906         &quot;Inherited fields are not included. &quot;
 907         &quot;The field list will include any synthetic fields created &quot;
 908         &quot;by the compiler. &quot;
 909         &quot;Fields are returned in the order they occur in the class file.  &quot;
 910         &quot;Generic signatures are described in the signature attribute &quot;
 911         &quot;section in &quot;
 912         &quot;&lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;. &quot;
 913         &quot;Since JDWP version 1.5.&quot;
 914         (Out
 915             (referenceType refType &quot;The reference type ID.&quot;)
 916         )
 917         (Reply
 918             (Repeat declared &quot;Number of declared fields.&quot;
 919                 (Group FieldInfo
 920                     (field fieldID &quot;Field ID.&quot;)
 921                     (string name &quot;The name of the field.&quot;)
 922                     (string signature &quot;The JNI signature of the field.&quot;)
 923                     (string genericSignature &quot;The generic signature of the &quot;
 924                                              &quot;field, or an empty string if there is none.&quot;)
 925                     (int modBits &quot;The modifier bit flags (also known as access flags) &quot;
 926                                  &quot;which provide additional information on the  &quot;
 927                                  &quot;field declaration. Individual flag values are &quot;
 928                                  &quot;defined in Chapter 4 of &quot;
 929                                  &quot;&lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;. &quot;
 930                                  &quot;In addition, The &lt;code&gt;0xf0000000&lt;/code&gt; bit identifies &quot;
 931                                  &quot;the field as synthetic, if the synthetic attribute &quot;
 932                                  &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_Capabilities\&quot;&gt;capability&lt;/a&gt; is available.&quot;)
 933                 )
 934             )
 935         )
 936         (ErrorSet
 937             (Error CLASS_NOT_PREPARED)
 938             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
 939                                      &quot;type.&quot;)
 940             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
 941             (Error VM_DEAD)
 942         )
 943     )
 944     (Command MethodsWithGeneric=15
 945         &quot;Returns information, including the generic signature if any, &quot;
 946         &quot;for each method in a reference type. &quot;
 947         &quot;Inherited methodss are not included. The list of methods will &quot;
 948         &quot;include constructors (identified with the name \&quot;&amp;lt;init&amp;gt;\&quot;), &quot;
 949         &quot;the initialization method (identified with the name \&quot;&amp;lt;clinit&amp;gt;\&quot;) &quot;
 950         &quot;if present, and any synthetic methods created by the compiler. &quot;
 951         &quot;Methods are returned in the order they occur in the class file.  &quot;
 952         &quot;Generic signatures are described in the signature attribute &quot;
 953         &quot;section in &quot;
 954         &quot;&lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;. &quot;
 955         &quot;Since JDWP version 1.5.&quot;
 956         (Out
 957             (referenceType refType &quot;The reference type ID.&quot;)
 958         )
 959         (Reply
 960             (Repeat declared &quot;Number of declared methods.&quot;
 961                 (Group MethodInfo
 962                     (method methodID &quot;Method ID.&quot;)
 963                     (string name &quot;The name of the method.&quot;)
 964                     (string signature &quot;The JNI signature of the method.&quot;)
 965                     (string genericSignature &quot;The generic signature of the method, or &quot;
 966                                              &quot;an empty string if there is none.&quot;)
 967                     (int modBits &quot;The modifier bit flags (also known as access flags) &quot;
 968                                  &quot;which provide additional information on the  &quot;
 969                                  &quot;method declaration. Individual flag values are &quot;
 970                                  &quot;defined in Chapter 4 of &quot;
 971                                  &quot;&lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;. &quot;
 972                                  &quot;In addition, The &lt;code&gt;0xf0000000&lt;/code&gt; bit identifies &quot;
 973                                  &quot;the method as synthetic, if the synthetic attribute &quot;
 974                                  &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_Capabilities\&quot;&gt;capability&lt;/a&gt; is available.&quot;)
 975                 )
 976             )
 977         )
 978         (ErrorSet
 979             (Error CLASS_NOT_PREPARED)
 980             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
 981                                      &quot;type.&quot;)
 982             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
 983             (Error VM_DEAD)
 984         )
 985     )
 986     (Command Instances=16
 987         &quot;Returns instances of this reference type. &quot;
 988         &quot;Only instances that are reachable for the purposes of &quot;
 989         &quot;garbage collection are returned. &quot;
 990         &quot;&lt;p&gt;Since JDWP version 1.6. Requires canGetInstanceInfo capability - see &quot;
 991         &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;.&quot;
 992         (Out
 993             (referenceType refType &quot;The reference type ID.&quot;)
 994             (int maxInstances &quot;Maximum number of instances to return.  Must be non-negative. &quot;
 995                               &quot;If zero, all instances are returned.&quot;)
 996         )
 997         (Reply
 998             (Repeat instances &quot;The number of instances that follow.&quot;
 999                  (tagged-object instance &quot;An instance of this reference type.&quot;)
1000              )
1001         )
1002         (ErrorSet
1003             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
1004                                      &quot;type.&quot;)
1005             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
1006             (Error ILLEGAL_ARGUMENT  &quot;maxInstances is less than zero.&quot;)
1007             (Error NOT_IMPLEMENTED)
1008             (Error VM_DEAD)
1009         )
1010     )
1011     (Command ClassFileVersion=17
1012         &quot;Returns the class file major and minor version numbers, as defined in the class &quot;
1013         &quot;file format of the Java Virtual Machine specification. &quot;
1014          &quot;&lt;p&gt;Since JDWP version 1.6. &quot;
1015         (Out
1016             (referenceType refType &quot;The class.&quot;)
1017         )
1018         (Reply
1019             (int majorVersion &quot;Major version number&quot;)
1020             (int minorVersion &quot;Minor version number&quot;)
1021         )
1022         (ErrorSet
1023             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
1024                                      &quot;type.&quot;)
1025             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
1026             (Error ABSENT_INFORMATION &quot;The class file version information is &quot;
1027                                       &quot;absent for primitive and array types.&quot;)
1028             (Error VM_DEAD)
1029         )
1030     )
1031     (Command ConstantPool=18
1032         &quot;Return the raw bytes of the constant pool in the format of the &quot;
1033         &quot;constant_pool item of the Class File Format in &quot;
1034         &quot;&lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;. &quot;
1035         &quot;&lt;p&gt;Since JDWP version 1.6. Requires canGetConstantPool capability - see &quot;
1036         &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;.&quot;&quot;
1037         (Out
1038             (referenceType refType &quot;The class.&quot;)
1039         )
1040         (Reply
1041             (int count &quot;Total number of constant pool entries plus one. This &quot;
1042                        &quot;corresponds to the constant_pool_count item of the &quot;
1043                        &quot;Class File Format in &quot;
1044                        &quot;&lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;. &quot;)
1045             (Repeat bytes
1046                 (byte cpbytes &quot;Raw bytes of constant pool&quot;)
1047             )
1048         )
1049         (ErrorSet
1050             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
1051                                      &quot;type.&quot;)
1052             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
1053             (Error NOT_IMPLEMENTED   &quot;If the target virtual machine does not &quot;
1054                                      &quot;support the retrieval of constant pool information.&quot;)
1055             (Error ABSENT_INFORMATION &quot;The Constant Pool information is &quot;
1056                                       &quot;absent for primitive and array types.&quot;)
1057             (Error VM_DEAD)
1058         )
1059     )
1060     (Command Module=19
1061         &quot;Returns the module that this reference type belongs to.&quot;
1062         &quot;&lt;p&gt;Since JDWP version 9.&quot;
1063         (Out
1064             (referenceType refType &quot;The reference type.&quot;)
1065         )
1066         (Reply
1067             (moduleID module &quot;The module this reference type belongs to.&quot;)
1068         )
1069         (ErrorSet
1070             (Error INVALID_CLASS   &quot;refType is not the ID of a reference type.&quot;)
1071             (Error INVALID_OBJECT  &quot;refType is not a known ID.&quot;)
1072             (Error NOT_IMPLEMENTED)
1073             (Error VM_DEAD)
1074         )
1075     )
1076 )
1077 (CommandSet ClassType=3
1078     (Command Superclass=1
1079         &quot;Returns the immediate superclass of a class.&quot;
1080         (Out
1081             (classType clazz &quot;The class type ID.&quot;)
1082         )
1083         (Reply
1084             (classType superclass
1085                 &quot;The superclass (null if the class ID for java.lang.Object is specified).&quot;)
1086         )
1087         (ErrorSet
1088             (Error INVALID_CLASS     &quot;clazz is not the ID of a class.&quot;)
1089             (Error INVALID_OBJECT    &quot;clazz is not a known ID.&quot;)
1090             (Error VM_DEAD)
1091         )
1092     )
1093     (Command SetValues=2
1094         &quot;Sets the value of one or more static fields. &quot;
1095         &quot;Each field must be member of the class type &quot;
1096         &quot;or one of its superclasses, superinterfaces, or implemented interfaces. &quot;
1097         &quot;Access control is not enforced; for example, the values of private &quot;
1098         &quot;fields can be set. Final fields cannot be set.&quot;
1099         &quot;For primitive values, the value&#39;s type must match the &quot;
1100         &quot;field&#39;s type exactly. For object values, there must exist a &quot;
1101         &quot;widening reference conversion from the value&#39;s type to the
1102         &quot;field&#39;s type and the field&#39;s type must be loaded. &quot;
1103         (Out
1104             (classType clazz &quot;The class type ID.&quot;)
1105             (Repeat values &quot;The number of fields to set.&quot;
1106                 (Group FieldValue &quot;A Field/Value pair.&quot;
1107                     (field fieldID &quot;Field to set.&quot;)
1108                     (untagged-value value &quot;Value to put in the field.&quot;)
1109                 )
1110             )
1111         )
1112         (Reply &quot;none&quot;
1113         )
1114         (ErrorSet
1115             (Error INVALID_CLASS     &quot;clazz is not the ID of a class.&quot;)
1116             (Error CLASS_NOT_PREPARED)
1117             (Error INVALID_OBJECT    &quot;clazz is not a known ID or a value of an &quot;
1118                                      &quot;object field is not a known ID.&quot;)
1119             (Error INVALID_FIELDID)
1120             (Error VM_DEAD)
1121         )
1122     )
1123     (Command InvokeMethod=3
1124         &quot;Invokes a static method. &quot;
1125         &quot;The method must be member of the class type &quot;
1126         &quot;or one of its superclasses. &quot;
1127         &quot;Access control is not enforced; for example, private &quot;
1128         &quot;methods can be invoked.&quot;
1129         &quot;&lt;p&gt;&quot;
1130         &quot;The method invocation will occur in the specified thread. &quot;
1131         &quot;Method invocation can occur only if the specified thread &quot;
1132         &quot;has been suspended by an event. &quot;
1133         &quot;Method invocation is not supported &quot;
1134         &quot;when the target VM has been suspended by the front-end. &quot;
1135         &quot;&lt;p&gt;&quot;
1136         &quot;The specified method is invoked with the arguments in the specified &quot;
1137         &quot;argument list. &quot;
1138         &quot;The method invocation is synchronous; the reply packet is not &quot;
1139         &quot;sent until the invoked method returns in the target VM. &quot;
1140         &quot;The return value (possibly the void value) is &quot;
1141         &quot;included in the reply packet. &quot;
1142         &quot;If the invoked method throws an exception, the &quot;
1143         &quot;exception object ID is set in the reply packet; otherwise, the &quot;
1144         &quot;exception object ID is null. &quot;
1145         &quot;&lt;p&gt;&quot;
1146         &quot;For primitive arguments, the argument value&#39;s type must match the &quot;
1147         &quot;argument&#39;s type exactly. For object arguments, there must exist a &quot;
1148         &quot;widening reference conversion from the argument value&#39;s type to the &quot;
1149         &quot;argument&#39;s type and the argument&#39;s type must be loaded. &quot;
1150         &quot;&lt;p&gt;&quot;
1151         &quot;By default, all threads in the target VM are resumed while &quot;
1152         &quot;the method is being invoked if they were previously &quot;
1153         &quot;suspended by an event or by command. &quot;
1154         &quot;This is done to prevent the deadlocks &quot;
1155         &quot;that will occur if any of the threads own monitors &quot;
1156         &quot;that will be needed by the invoked method. It is possible that &quot;
1157         &quot;breakpoints or other events might occur during the invocation. &quot;
1158         &quot;Note, however, that this implicit resume acts exactly like &quot;
1159         &quot;the ThreadReference resume command, so if the thread&#39;s suspend &quot;
1160         &quot;count is greater than 1, it will remain in a suspended state &quot;
1161         &quot;during the invocation. By default, when the invocation completes, &quot;
1162         &quot;all threads in the target VM are suspended, regardless their state &quot;
1163         &quot;before the invocation. &quot;
1164         &quot;&lt;p&gt;&quot;
1165         &quot;The resumption of other threads during the invoke can be prevented &quot;
1166         &quot;by specifying the INVOKE_SINGLE_THREADED &quot;
1167         &quot;bit flag in the &lt;code&gt;options&lt;/code&gt; field; however, &quot;
1168         &quot;there is no protection against or recovery from the deadlocks &quot;
1169         &quot;described above, so this option should be used with great caution. &quot;
1170         &quot;Only the specified thread will be resumed (as described for all &quot;
1171         &quot;threads above). Upon completion of a single threaded invoke, the invoking thread &quot;
1172         &quot;will be suspended once again. Note that any threads started during &quot;
1173         &quot;the single threaded invocation will not be suspended when the &quot;
1174         &quot;invocation completes. &quot;
1175         &quot;&lt;p&gt;&quot;
1176         &quot;If the target VM is disconnected during the invoke (for example, through &quot;
1177         &quot;the VirtualMachine dispose command) the method invocation continues. &quot;
1178         (Out
1179             (classType clazz &quot;The class type ID.&quot;)
1180             (threadObject thread &quot;The thread in which to invoke.&quot;)
1181             (method methodID &quot;The method to invoke.&quot;)
1182             (Repeat arguments
1183                 (value arg &quot;The argument value.&quot;)
1184             )
1185             (int options &quot;Invocation &lt;a href=\&quot;#JDWP_InvokeOptions\&quot;&gt;options&lt;/a&gt;&quot;)
1186         )
1187         (Reply
1188             (value returnValue &quot;The returned value.&quot;)
1189             (tagged-object exception &quot;The thrown exception.&quot;)
1190         )
1191         (ErrorSet
1192             (Error INVALID_CLASS     &quot;clazz is not the ID of a class.&quot;)
1193             (Error INVALID_OBJECT    &quot;clazz is not a known ID.&quot;)
1194             (Error INVALID_METHODID  &quot;methodID is not the ID of a static method in &quot;
1195                                      &quot;this class type or one of its superclasses.&quot;)
1196             (Error INVALID_THREAD)
1197             (Error THREAD_NOT_SUSPENDED)
1198             (Error VM_DEAD)
1199         )
1200     )
1201     (Command NewInstance=4
1202         &quot;Creates a new object of this type, invoking the specified &quot;
1203         &quot;constructor. The constructor method ID must be a member of &quot;
1204         &quot;the class type.&quot;
1205         &quot;&lt;p&gt;&quot;
1206         &quot;Instance creation will occur in the specified thread. &quot;
1207         &quot;Instance creation can occur only if the specified thread &quot;
1208         &quot;has been suspended by an event. &quot;
1209         &quot;Method invocation is not supported &quot;
1210         &quot;when the target VM has been suspended by the front-end. &quot;
1211         &quot;&lt;p&gt;&quot;
1212         &quot;The specified constructor is invoked with the arguments in the specified &quot;
1213         &quot;argument list. &quot;
1214         &quot;The constructor invocation is synchronous; the reply packet is not &quot;
1215         &quot;sent until the invoked method returns in the target VM. &quot;
1216         &quot;The return value (possibly the void value) is &quot;
1217         &quot;included in the reply packet. &quot;
1218         &quot;If the constructor throws an exception, the &quot;
1219         &quot;exception object ID is set in the reply packet; otherwise, the &quot;
1220         &quot;exception object ID is null. &quot;
1221         &quot;&lt;p&gt;&quot;
1222         &quot;For primitive arguments, the argument value&#39;s type must match the &quot;
1223         &quot;argument&#39;s type exactly. For object arguments, there must exist a &quot;
1224         &quot;widening reference conversion from the argument value&#39;s type to the &quot;
1225         &quot;argument&#39;s type and the argument&#39;s type must be loaded. &quot;
1226         &quot;&lt;p&gt;&quot;
1227         &quot;By default, all threads in the target VM are resumed while &quot;
1228         &quot;the method is being invoked if they were previously &quot;
1229         &quot;suspended by an event or by command. &quot;
1230         &quot;This is done to prevent the deadlocks &quot;
1231         &quot;that will occur if any of the threads own monitors &quot;
1232         &quot;that will be needed by the invoked method. It is possible that &quot;
1233         &quot;breakpoints or other events might occur during the invocation. &quot;
1234         &quot;Note, however, that this implicit resume acts exactly like &quot;
1235         &quot;the ThreadReference resume command, so if the thread&#39;s suspend &quot;
1236         &quot;count is greater than 1, it will remain in a suspended state &quot;
1237         &quot;during the invocation. By default, when the invocation completes, &quot;
1238         &quot;all threads in the target VM are suspended, regardless their state &quot;
1239         &quot;before the invocation. &quot;
1240         &quot;&lt;p&gt;&quot;
1241         &quot;The resumption of other threads during the invoke can be prevented &quot;
1242         &quot;by specifying the INVOKE_SINGLE_THREADED &quot;
1243         &quot;bit flag in the &lt;code&gt;options&lt;/code&gt; field; however, &quot;
1244         &quot;there is no protection against or recovery from the deadlocks &quot;
1245         &quot;described above, so this option should be used with great caution. &quot;
1246         &quot;Only the specified thread will be resumed (as described for all &quot;
1247         &quot;threads above). Upon completion of a single threaded invoke, the invoking thread &quot;
1248         &quot;will be suspended once again. Note that any threads started during &quot;
1249         &quot;the single threaded invocation will not be suspended when the &quot;
1250         &quot;invocation completes. &quot;
1251         &quot;&lt;p&gt;&quot;
1252         &quot;If the target VM is disconnected during the invoke (for example, through &quot;
1253         &quot;the VirtualMachine dispose command) the method invocation continues. &quot;
1254         (Out
1255             (classType clazz &quot;The class type ID.&quot;)
1256             (threadObject thread &quot;The thread in which to invoke the constructor.&quot;)
1257             (method methodID &quot;The constructor to invoke.&quot;)
1258             (Repeat arguments
1259                 (value arg &quot;The argument value.&quot;)
1260             )
1261             (int options &quot;Constructor invocation &lt;a href=\&quot;#JDWP_InvokeOptions\&quot;&gt;options&lt;/a&gt;&quot;)
1262         )
1263         (Reply
1264             (tagged-object newObject &quot;The newly created object, or null &quot;
1265                                      &quot;if the constructor threw an exception.&quot;)
1266             (tagged-object exception &quot;The thrown exception, if any; otherwise, null.&quot;)
1267         )
1268         (ErrorSet
1269             (Error INVALID_CLASS     &quot;clazz is not the ID of a class.&quot;)
1270             (Error INVALID_OBJECT    &quot;clazz is not a known ID or a value of an &quot;
1271                                      &quot;object parameter is not a known ID..&quot;)
1272             (Error INVALID_METHODID  &quot;methodID is not the ID of a method.&quot;)
1273             (Error INVALID_OBJECT)
1274             (Error INVALID_THREAD)
1275             (Error THREAD_NOT_SUSPENDED)
1276             (Error VM_DEAD)
1277         )
1278     )
1279 )
1280 (CommandSet ArrayType=4
1281     (Command NewInstance=1
1282         &quot;Creates a new array object of this type with a given length.&quot;
1283         (Out
1284             (arrayType arrType &quot;The array type of the new instance.&quot;)
1285             (int length &quot;The length of the array.&quot;)
1286         )
1287         (Reply
1288             (tagged-object newArray &quot;The newly created array object. &quot;)
1289         )
1290         (ErrorSet
1291             (Error INVALID_ARRAY)
1292             (Error INVALID_OBJECT)
1293             (Error VM_DEAD)
1294         )
1295     )
1296 )
1297 (CommandSet InterfaceType=5
1298     (Command InvokeMethod=1
1299         &quot;Invokes a static method. &quot;
1300         &quot;The method must not be a static initializer. &quot;
1301         &quot;The method must be a member of the interface type. &quot;
1302         &quot;&lt;p&gt;Since JDWP version 1.8 &quot;
1303         &quot;&lt;p&gt;&quot;
1304         &quot;The method invocation will occur in the specified thread. &quot;
1305         &quot;Method invocation can occur only if the specified thread &quot;
1306         &quot;has been suspended by an event. &quot;
1307         &quot;Method invocation is not supported &quot;
1308         &quot;when the target VM has been suspended by the front-end. &quot;
1309         &quot;&lt;p&gt;&quot;
1310         &quot;The specified method is invoked with the arguments in the specified &quot;
1311         &quot;argument list. &quot;
1312         &quot;The method invocation is synchronous; the reply packet is not &quot;
1313         &quot;sent until the invoked method returns in the target VM. &quot;
1314         &quot;The return value (possibly the void value) is &quot;
1315         &quot;included in the reply packet. &quot;
1316         &quot;If the invoked method throws an exception, the &quot;
1317         &quot;exception object ID is set in the reply packet; otherwise, the &quot;
1318         &quot;exception object ID is null. &quot;
1319         &quot;&lt;p&gt;&quot;
1320         &quot;For primitive arguments, the argument value&#39;s type must match the &quot;
1321         &quot;argument&#39;s type exactly. For object arguments, there must exist a &quot;
1322         &quot;widening reference conversion from the argument value&#39;s type to the &quot;
1323         &quot;argument&#39;s type and the argument&#39;s type must be loaded. &quot;
1324         &quot;&lt;p&gt;&quot;
1325         &quot;By default, all threads in the target VM are resumed while &quot;
1326         &quot;the method is being invoked if they were previously &quot;
1327         &quot;suspended by an event or by a command. &quot;
1328         &quot;This is done to prevent the deadlocks &quot;
1329         &quot;that will occur if any of the threads own monitors &quot;
1330         &quot;that will be needed by the invoked method. It is possible that &quot;
1331         &quot;breakpoints or other events might occur during the invocation. &quot;
1332         &quot;Note, however, that this implicit resume acts exactly like &quot;
1333         &quot;the ThreadReference resume command, so if the thread&#39;s suspend &quot;
1334         &quot;count is greater than 1, it will remain in a suspended state &quot;
1335         &quot;during the invocation. By default, when the invocation completes, &quot;
1336         &quot;all threads in the target VM are suspended, regardless their state &quot;
1337         &quot;before the invocation. &quot;
1338         &quot;&lt;p&gt;&quot;
1339         &quot;The resumption of other threads during the invoke can be prevented &quot;
1340         &quot;by specifying the INVOKE_SINGLE_THREADED &quot;
1341         &quot;bit flag in the &lt;code&gt;options&lt;/code&gt; field; however, &quot;
1342         &quot;there is no protection against or recovery from the deadlocks &quot;
1343         &quot;described above, so this option should be used with great caution. &quot;
1344         &quot;Only the specified thread will be resumed (as described for all &quot;
1345         &quot;threads above). Upon completion of a single threaded invoke, the invoking thread &quot;
1346         &quot;will be suspended once again. Note that any threads started during &quot;
1347         &quot;the single threaded invocation will not be suspended when the &quot;
1348         &quot;invocation completes. &quot;
1349         &quot;&lt;p&gt;&quot;
1350         &quot;If the target VM is disconnected during the invoke (for example, through &quot;
1351         &quot;the VirtualMachine dispose command) the method invocation continues. &quot;
1352         (Out
1353             (interfaceType clazz &quot;The interface type ID.&quot;)
1354             (threadObject thread &quot;The thread in which to invoke.&quot;)
1355             (method methodID &quot;The method to invoke.&quot;)
1356             (Repeat arguments
1357                 (value arg &quot;The argument value.&quot;)
1358             )
1359             (int options &quot;Invocation &lt;a href=\&quot;#JDWP_InvokeOptions\&quot;&gt;options&lt;/a&gt;&quot;)
1360         )
1361         (Reply
1362             (value returnValue &quot;The returned value.&quot;)
1363             (tagged-object exception &quot;The thrown exception.&quot;)
1364         )
1365         (ErrorSet
1366             (Error INVALID_CLASS     &quot;clazz is not the ID of an interface.&quot;)
1367             (Error INVALID_OBJECT    &quot;clazz is not a known ID.&quot;)
1368             (Error INVALID_METHODID  &quot;methodID is not the ID of a static method in this &quot;
1369                                      &quot;interface type or is the ID of a static initializer.&quot;)
1370             (Error INVALID_THREAD)
1371             (Error THREAD_NOT_SUSPENDED)
1372             (Error VM_DEAD)
1373         )
1374     )
1375 )
1376 (CommandSet Method=6
1377     (Command LineTable=1
1378         &quot;Returns line number information for the method, if present. &quot;
1379         &quot;The line table maps source line numbers to the initial code index &quot;
1380         &quot;of the line. The line table &quot;
1381         &quot;is ordered by code index (from lowest to highest). The line number &quot;
1382         &quot;information is constant unless a new class definition is installed &quot;
1383         &quot;using &lt;a href=\&quot;#JDWP_VirtualMachine_RedefineClasses\&quot;&gt;RedefineClasses&lt;/a&gt;.&quot;
1384         (Out
1385             (referenceType refType &quot;The class.&quot;)
1386             (method methodID &quot;The method.&quot;)
1387         )
1388         (Reply
1389             (long start &quot;Lowest valid code index for the method, &gt;=0, or -1 if the method is native &quot;)
1390             (long end &quot;Highest valid code index for the method, &gt;=0, or -1 if the method is native&quot;)
1391             (Repeat lines &quot;The number of entries in the line table for this method.&quot;
1392                 (Group LineInfo
1393                     (long lineCodeIndex &quot;Initial code index of the line, &quot;
1394                                         &quot;start &amp;lt;= lineCodeIndex &amp;lt; end&quot;)
1395                     (int lineNumber &quot;Line number.&quot;)
1396                 )
1397             )
1398         )
1399         (ErrorSet
1400             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
1401                                      &quot;type.&quot;)
1402             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
1403             (Error INVALID_METHODID  &quot;methodID is not the ID of a method.&quot;)
1404             (Error VM_DEAD)
1405         )
1406     )
1407     (Command VariableTable=2
1408         &quot;Returns variable information for the method. The variable table &quot;
1409         &quot;includes arguments and locals declared within the method. For &quot;
1410         &quot;instance methods, the \&quot;this\&quot; reference is included in the &quot;
1411         &quot;table. Also, synthetic variables may be present. &quot;
1412         (Out
1413             (referenceType refType &quot;The class.&quot;)
1414             (method methodID &quot;The method.&quot;)
1415         )
1416         (Reply
1417             (int argCnt &quot;The number of words in the frame used by arguments. &quot;
1418                         &quot;Eight-byte arguments use two words; all others use one. &quot;)
1419             (Repeat slots &quot;The number of variables.&quot;
1420                 (Group SlotInfo &quot;Information about the variable.&quot;
1421                     (long codeIndex
1422                         &quot;First code index at which the variable is visible (unsigned). &quot;
1423                         &quot;Used in conjunction with &lt;code&gt;length&lt;/code&gt;. &quot;
1424                         &quot;The variable can be get or set only when the current &quot;
1425                         &quot;&lt;code&gt;codeIndex&lt;/code&gt; &amp;lt;= current frame code index &amp;lt; &lt;code&gt;codeIndex + length&lt;/code&gt; &quot;)
1426                     (string name &quot;The variable&#39;s name.&quot;)
1427                     (string signature &quot;The variable type&#39;s JNI signature.&quot;)
1428                     (int length
1429                         &quot;Unsigned value used in conjunction with &lt;code&gt;codeIndex&lt;/code&gt;. &quot;
1430                         &quot;The variable can be get or set only when the current &quot;
1431                         &quot;&lt;code&gt;codeIndex&lt;/code&gt; &amp;lt;= current frame code index &amp;lt; &lt;code&gt;code index + length&lt;/code&gt; &quot;)
1432                     (int slot &quot;The local variable&#39;s index in its frame&quot;)
1433                 )
1434             )
1435         )
1436         (ErrorSet
1437             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
1438                                      &quot;type.&quot;)
1439             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
1440             (Error INVALID_METHODID  &quot;methodID is not the ID of a method.&quot;)
1441             (Error ABSENT_INFORMATION &quot;there is no variable information for the method.&quot;)
1442             (Error VM_DEAD)
1443         )
1444     )
1445     (Command Bytecodes=3
1446         &quot;Retrieve the method&#39;s bytecodes as defined in &quot;
1447         &quot;&lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;. &quot;
1448         &quot;Requires canGetBytecodes capability - see &quot;
1449         &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;.&quot;
1450         (Out
1451             (referenceType refType &quot;The class.&quot;)
1452             (method methodID &quot;The method.&quot;)
1453         )
1454         (Reply
1455             (Repeat bytes
1456                 (byte bytecode &quot;A Java bytecode.&quot;)
1457             )
1458         )
1459         (ErrorSet
1460             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
1461                                      &quot;type.&quot;)
1462             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
1463             (Error INVALID_METHODID  &quot;methodID is not the ID of a method.&quot;)
1464             (Error NOT_IMPLEMENTED   &quot;If the target virtual machine does not &quot;
1465                                      &quot;support the retrieval of bytecodes.&quot;)
1466             (Error VM_DEAD)
1467         )
1468     )
1469     (Command IsObsolete=4
1470         &quot;Determine if this method is obsolete. A method is obsolete if it has been replaced &quot;
1471         &quot;by a non-equivalent method using the &quot;
1472         &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_RedefineClasses\&quot;&gt;RedefineClasses&lt;/a&gt; command. &quot;
1473         &quot;The original and redefined methods are considered equivalent if their bytecodes are &quot;
1474         &quot;the same except for indices into the constant pool and the referenced constants are &quot;
1475         &quot;equal.&quot;
1476         (Out
1477             (referenceType refType &quot;The class.&quot;)
1478             (method methodID &quot;The method.&quot;)
1479         )
1480         (Reply
1481             (boolean isObsolete    &quot;true if this method has been replaced&quot;
1482                                    &quot;by a non-equivalent method using&quot;
1483                                    &quot;the RedefineClasses command.&quot;)
1484         )
1485         (ErrorSet
1486             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
1487                                      &quot;type.&quot;)
1488             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
1489             (Error INVALID_METHODID  &quot;methodID is not the ID of a method.&quot;)
1490             (Error NOT_IMPLEMENTED   &quot;If the target virtual machine does &quot;
1491                                      &quot;not support this query.&quot;)
1492             (Error VM_DEAD)
1493         )
1494     )
1495     (Command VariableTableWithGeneric=5
1496         &quot;Returns variable information for the method, including &quot;
1497         &quot;generic signatures for the variables. The variable table &quot;
1498         &quot;includes arguments and locals declared within the method. For &quot;
1499         &quot;instance methods, the \&quot;this\&quot; reference is included in the &quot;
1500         &quot;table. Also, synthetic variables may be present. &quot;
1501         &quot;Generic signatures are described in the signature attribute &quot;
1502         &quot;section in &quot;
1503         &quot;&lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;. &quot;
1504         &quot;Since JDWP version 1.5.&quot;
1505         (Out
1506             (referenceType refType &quot;The class.&quot;)
1507             (method methodID &quot;The method.&quot;)
1508         )
1509         (Reply
1510             (int argCnt &quot;The number of words in the frame used by arguments. &quot;
1511                         &quot;Eight-byte arguments use two words; all others use one. &quot;)
1512             (Repeat slots &quot;The number of variables.&quot;
1513                 (Group SlotInfo &quot;Information about the variable.&quot;
1514                     (long codeIndex
1515                         &quot;First code index at which the variable is visible (unsigned). &quot;
1516                         &quot;Used in conjunction with &lt;code&gt;length&lt;/code&gt;. &quot;
1517                         &quot;The variable can be get or set only when the current &quot;
1518                         &quot;&lt;code&gt;codeIndex&lt;/code&gt; &amp;lt;= current frame code index &amp;lt; &lt;code&gt;codeIndex + length&lt;/code&gt; &quot;)
1519                     (string name &quot;The variable&#39;s name.&quot;)
1520                     (string signature &quot;The variable type&#39;s JNI signature.&quot;)
1521                     (string genericSignature &quot;The variable type&#39;s generic &quot;
1522                          &quot;signature or an empty string if there is none.&quot;)
1523                     (int length
1524                         &quot;Unsigned value used in conjunction with &lt;code&gt;codeIndex&lt;/code&gt;. &quot;
1525                         &quot;The variable can be get or set only when the current &quot;
1526                         &quot;&lt;code&gt;codeIndex&lt;/code&gt; &amp;lt;= current frame code index &amp;lt; &lt;code&gt;code index + length&lt;/code&gt; &quot;)
1527                     (int slot &quot;The local variable&#39;s index in its frame&quot;)
1528                 )
1529             )
1530         )
1531         (ErrorSet
1532             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
1533                                      &quot;type.&quot;)
1534             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
1535             (Error INVALID_METHODID  &quot;methodID is not the ID of a method.&quot;)
1536             (Error ABSENT_INFORMATION &quot;there is no variable information for the method.&quot;)
1537             (Error VM_DEAD)
1538         )
1539     )
1540 
1541 )
1542 (CommandSet Field=8
1543 )
1544 (CommandSet ObjectReference=9
1545     (Command ReferenceType=1
1546         &quot;Returns the runtime type of the object. &quot;
1547         &quot;The runtime type will be a class or an array. &quot;
1548         (Out
1549             (object object &quot;The object ID&quot;)
1550         )
1551         (Reply
1552             (byte refTypeTag  &quot;&lt;a href=\&quot;#JDWP_TypeTag\&quot;&gt;Kind&lt;/a&gt; &quot;
1553                               &quot;of following reference type. &quot;)
1554             (referenceTypeID typeID &quot;The runtime reference type.&quot;)
1555         )
1556         (ErrorSet
1557             (Error INVALID_OBJECT)
1558             (Error VM_DEAD)
1559         )
1560     )
1561     (Command GetValues=2
1562         &quot;Returns the value of one or more instance fields. &quot;
1563         &quot;Each field must be member of the object&#39;s type &quot;
1564         &quot;or one of its superclasses, superinterfaces, or implemented interfaces. &quot;
1565         &quot;Access control is not enforced; for example, the values of private &quot;
1566         &quot;fields can be obtained.&quot;
1567         (Out
1568             (object object &quot;The object ID&quot;)
1569             (Repeat fields &quot;The number of values to get&quot;
1570                 (Group Field
1571                     (field fieldID &quot;Field to get.&quot;)
1572                 )
1573             )
1574         )
1575         (Reply
1576             (Repeat values &quot;The number of values returned, always equal to &#39;fields&#39;, &quot;
1577                            &quot;the number of values to get. Field values are ordered &quot;
1578                            &quot;in the reply in the same order as corresponding fieldIDs &quot;
1579                            &quot;in the command.&quot;
1580                 (value value &quot;The field value&quot;)
1581             )
1582         )
1583         (ErrorSet
1584             (Error INVALID_OBJECT)
1585             (Error INVALID_FIELDID)
1586             (Error VM_DEAD)
1587         )
1588     )
1589     (Command SetValues=3
1590         &quot;Sets the value of one or more instance fields. &quot;
1591         &quot;Each field must be member of the object&#39;s type &quot;
1592         &quot;or one of its superclasses, superinterfaces, or implemented interfaces. &quot;
1593         &quot;Access control is not enforced; for example, the values of private &quot;
1594         &quot;fields can be set. &quot;
1595         &quot;For primitive values, the value&#39;s type must match the &quot;
1596         &quot;field&#39;s type exactly. For object values, there must be a &quot;
1597         &quot;widening reference conversion from the value&#39;s type to the
1598         &quot;field&#39;s type and the field&#39;s type must be loaded. &quot;
1599         (Out
1600             (object object &quot;The object ID&quot;)
1601             (Repeat values &quot;The number of fields to set.&quot;
1602                 (Group FieldValue &quot;A Field/Value pair.&quot;
1603                     (field fieldID &quot;Field to set.&quot;)
1604                     (untagged-value value &quot;Value to put in the field.&quot;)
1605                 )
1606             )
1607         )
1608         (Reply &quot;none&quot;
1609         )
1610         (ErrorSet
1611             (Error INVALID_OBJECT)
1612             (Error INVALID_FIELDID)
1613             (Error VM_DEAD)
1614         )
1615     )
1616     (Command MonitorInfo=5
1617         &quot;Returns monitor information for an object. All threads int the VM must &quot;
1618         &quot;be suspended.&quot;
1619         &quot;Requires canGetMonitorInfo capability - see &quot;
1620         &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;.&quot;
1621         (Out
1622             (object object &quot;The object ID&quot;)
1623         )
1624         (Reply
1625             (threadObject owner &quot;The monitor owner, or null if it is not currently owned.&quot;)
1626             (int entryCount &quot;The number of times the monitor has been entered.&quot;)
1627             (Repeat waiters &quot;The number of threads that are waiting for the monitor &quot;
1628                             &quot;0 if there is no current owner&quot;
1629                 (threadObject thread &quot;A thread waiting for this monitor.&quot;)
1630             )
1631         )
1632         (ErrorSet
1633             (Error INVALID_OBJECT)
1634             (Error NOT_IMPLEMENTED)
1635             (Error VM_DEAD)
1636         )
1637     )
1638     (Command InvokeMethod=6
1639         &quot;Invokes a instance method. &quot;
1640         &quot;The method must be member of the object&#39;s type &quot;
1641         &quot;or one of its superclasses, superinterfaces, or implemented interfaces. &quot;
1642         &quot;Access control is not enforced; for example, private &quot;
1643         &quot;methods can be invoked.&quot;
1644         &quot;&lt;p&gt;&quot;
1645         &quot;The method invocation will occur in the specified thread. &quot;
1646         &quot;Method invocation can occur only if the specified thread &quot;
1647         &quot;has been suspended by an event. &quot;
1648         &quot;Method invocation is not supported &quot;
1649         &quot;when the target VM has been suspended by the front-end. &quot;
1650         &quot;&lt;p&gt;&quot;
1651         &quot;The specified method is invoked with the arguments in the specified &quot;
1652         &quot;argument list. &quot;
1653         &quot;The method invocation is synchronous; the reply packet is not &quot;
1654         &quot;sent until the invoked method returns in the target VM. &quot;
1655         &quot;The return value (possibly the void value) is &quot;
1656         &quot;included in the reply packet. &quot;
1657         &quot;If the invoked method throws an exception, the &quot;
1658         &quot;exception object ID is set in the reply packet; otherwise, the &quot;
1659         &quot;exception object ID is null. &quot;
1660         &quot;&lt;p&gt;&quot;
1661         &quot;For primitive arguments, the argument value&#39;s type must match the &quot;
1662         &quot;argument&#39;s type exactly. For object arguments, there must be a &quot;
1663         &quot;widening reference conversion from the argument value&#39;s type to the &quot;
1664         &quot;argument&#39;s type and the argument&#39;s type must be loaded. &quot;
1665         &quot;&lt;p&gt;&quot;
1666         &quot;By default, all threads in the target VM are resumed while &quot;
1667         &quot;the method is being invoked if they were previously &quot;
1668         &quot;suspended by an event or by a command. &quot;
1669         &quot;This is done to prevent the deadlocks &quot;
1670         &quot;that will occur if any of the threads own monitors &quot;
1671         &quot;that will be needed by the invoked method. It is possible that &quot;
1672         &quot;breakpoints or other events might occur during the invocation. &quot;
1673         &quot;Note, however, that this implicit resume acts exactly like &quot;
1674         &quot;the ThreadReference resume command, so if the thread&#39;s suspend &quot;
1675         &quot;count is greater than 1, it will remain in a suspended state &quot;
1676         &quot;during the invocation. By default, when the invocation completes, &quot;
1677         &quot;all threads in the target VM are suspended, regardless their state &quot;
1678         &quot;before the invocation. &quot;
1679         &quot;&lt;p&gt;&quot;
1680         &quot;The resumption of other threads during the invoke can be prevented &quot;
1681         &quot;by specifying the INVOKE_SINGLE_THREADED &quot;
1682         &quot;bit flag in the &lt;code&gt;options&lt;/code&gt; field; however, &quot;
1683         &quot;there is no protection against or recovery from the deadlocks &quot;
1684         &quot;described above, so this option should be used with great caution. &quot;
1685         &quot;Only the specified thread will be resumed (as described for all &quot;
1686         &quot;threads above). Upon completion of a single threaded invoke, the invoking thread &quot;
1687         &quot;will be suspended once again. Note that any threads started during &quot;
1688         &quot;the single threaded invocation will not be suspended when the &quot;
1689         &quot;invocation completes. &quot;
1690         &quot;&lt;p&gt;&quot;
1691         &quot;If the target VM is disconnected during the invoke (for example, through &quot;
1692         &quot;the VirtualMachine dispose command) the method invocation continues. &quot;
1693         (Out
1694             (object object &quot;The object ID&quot;)
1695             (threadObject thread &quot;The thread in which to invoke.&quot;)
1696             (classType clazz &quot;The class type.&quot;)
1697             (method methodID &quot;The method to invoke.&quot;)
1698             (Repeat arguments &quot;The number of arguments.&quot;
1699                 (value arg &quot;The argument value.&quot;)
1700             )
1701             (int options &quot;Invocation &lt;a href=\&quot;#JDWP_InvokeOptions\&quot;&gt;options&lt;/a&gt;&quot;)
1702         )
1703         (Reply
1704             (value returnValue &quot;The returned value, or null if an exception is thrown.&quot;)
1705             (tagged-object exception &quot;The thrown exception, if any.&quot;)
1706         )
1707         (ErrorSet
1708             (Error INVALID_OBJECT)
1709             (Error INVALID_CLASS     &quot;clazz is not the ID of a reference &quot;
1710                                      &quot;type.&quot;)
1711             (Error INVALID_METHODID  &quot;methodID is not the ID of an instance method &quot;
1712                                      &quot;in this object&#39;s type or one of its superclasses, &quot;
1713                                      &quot;superinterfaces, or implemented interfaces.&quot;)
1714             (Error INVALID_THREAD)
1715             (Error THREAD_NOT_SUSPENDED)
1716             (Error VM_DEAD)
1717         )
1718     )
1719     (Command DisableCollection=7
1720         &quot;Prevents garbage collection for the given object. By &quot;
1721         &quot;default all objects in back-end replies may be &quot;
1722         &quot;collected at any time the target VM is running. A call to &quot;
1723         &quot;this command guarantees that the object will not be &quot;
1724         &quot;collected. The &quot;
1725         &quot;&lt;a href=\&quot;#JDWP_ObjectReference_EnableCollection\&quot;&gt;EnableCollection&lt;/a&gt; &quot;
1726         &quot;command can be used to &quot;
1727         &quot;allow collection once again. &quot;
1728         &quot;&lt;p&gt;&quot;
1729         &quot;Note that while the target VM is suspended, no garbage &quot;
1730         &quot;collection will occur because all threads are suspended. &quot;
1731         &quot;The typical examination of variables, fields, and arrays &quot;
1732         &quot;during the suspension is safe without explicitly disabling &quot;
1733         &quot;garbage collection. &quot;
1734         &quot;&lt;p&gt;&quot;
1735         &quot;This method should be used sparingly, as it alters the &quot;
1736         &quot;pattern of garbage collection in the target VM and, &quot;
1737         &quot;consequently, may result in application behavior under the &quot;
1738         &quot;debugger that differs from its non-debugged behavior. &quot;
1739         (Out
1740             (object object &quot;The object ID&quot;)
1741         )
1742         (Reply &quot;none&quot;
1743         )
1744         (ErrorSet
1745             (Error INVALID_OBJECT)
1746             (Error VM_DEAD)
1747         )
1748     )
1749     (Command EnableCollection=8
1750         &quot;Permits garbage collection for this object. By default all &quot;
1751         &quot;objects returned by JDWP may become unreachable in the target VM, &quot;
1752         &quot;and hence may be garbage collected. A call to this command is &quot;
1753         &quot;necessary only if garbage collection was previously disabled with &quot;
1754         &quot;the &lt;a href=\&quot;#JDWP_ObjectReference_DisableCollection\&quot;&gt;DisableCollection&lt;/a&gt; &quot;
1755         &quot;command.&quot;
1756         (Out
1757             (object object &quot;The object ID&quot;)
1758         )
1759         (Reply &quot;none&quot;
1760         )
1761         (ErrorSet
1762             (Error VM_DEAD)
1763         )
1764     )
1765     (Command IsCollected=9
1766         &quot;Determines whether an object has been garbage collected in the &quot;
1767         &quot;target VM. &quot;
1768         (Out
1769             (object object &quot;The object ID&quot;)
1770         )
1771         (Reply
1772             (boolean isCollected &quot;true if the object has been collected; false otherwise&quot;)
1773         )
1774         (ErrorSet
1775             (Error INVALID_OBJECT)
1776             (Error VM_DEAD)
1777         )
1778     )
1779     (Command ReferringObjects=10
1780         &quot;Returns objects that directly reference this object.  &quot;
1781         &quot;Only objects that are reachable for the purposes &quot;
1782         &quot;of garbage collection are returned. &quot;
1783         &quot;Note that an object can also be referenced in other ways, &quot;
1784         &quot;such as from a local variable in a stack frame, or from a JNI global &quot;
1785         &quot;reference.  Such non-object referrers are not returned by this command. &quot;
1786         &quot;&lt;p&gt;Since JDWP version 1.6. Requires canGetInstanceInfo capability - see &quot;
1787         &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;.&quot;
1788         (Out
1789             (object object &quot;The object ID&quot;)
1790             (int maxReferrers &quot;Maximum number of referring objects to return. &quot;
1791                               &quot;Must be non-negative. If zero, all referring &quot;
1792                               &quot;objects are returned.&quot;)
1793         )
1794         (Reply
1795             (Repeat referringObjects &quot;The number of objects that follow.&quot;
1796                 (tagged-object instance &quot;An object that references this object.&quot;)
1797              )
1798         )
1799         (ErrorSet
1800             (Error INVALID_OBJECT    &quot;object is not a known ID.&quot;)
1801             (Error ILLEGAL_ARGUMENT  &quot;maxReferrers is less than zero.&quot;)
1802             (Error NOT_IMPLEMENTED)
1803             (Error VM_DEAD)
1804         )
1805     )
1806 )
1807 
1808 (CommandSet StringReference=10
1809     (Command Value=1
1810         &quot;Returns the characters contained in the string. &quot;
1811         (Out
1812             (object stringObject &quot;The String object ID. &quot;)
1813         )
1814         (Reply
1815             (string stringValue &quot;UTF-8 representation of the string value.&quot;)
1816        )
1817         (ErrorSet
1818             (Error INVALID_STRING)
1819             (Error INVALID_OBJECT)
1820             (Error VM_DEAD)
1821         )
1822     )
1823 )
1824 (CommandSet ThreadReference=11
1825     (Command Name=1
1826         &quot;Returns the thread name. &quot;
1827         (Out
1828             (threadObject thread &quot;The thread object ID. &quot;)
1829         )
1830         (Reply
1831             (string threadName &quot;The thread name.&quot;)
1832         )
1833         (ErrorSet
1834             (Error INVALID_THREAD)
1835             (Error INVALID_OBJECT    &quot;thread is not a known ID.&quot;)
1836             (Error VM_DEAD)
1837         )
1838     )
1839     (Command Suspend=2
1840         &quot;Suspends the thread. &quot;
1841         &quot;&lt;p&gt;&quot;
1842         &quot;Unlike java.lang.Thread.suspend(), suspends of both &quot;
1843         &quot;the virtual machine and individual threads are counted. Before &quot;
1844         &quot;a thread will run again, it must be resumed the same number &quot;
1845         &quot;of times it has been suspended. &quot;
1846         &quot;&lt;p&gt;&quot;
1847         &quot;Suspending single threads with command has the same &quot;
1848         &quot;dangers java.lang.Thread.suspend(). If the suspended &quot;
1849         &quot;thread holds a monitor needed by another running thread, &quot;
1850         &quot;deadlock is possible in the target VM (at least until the &quot;
1851         &quot;suspended thread is resumed again). &quot;
1852         &quot;&lt;p&gt;&quot;
1853         &quot;The suspended thread is guaranteed to remain suspended until &quot;
1854         &quot;resumed through one of the JDI resume methods mentioned above; &quot;
1855         &quot;the application in the target VM cannot resume the suspended thread &quot;
1856         &quot;through {@link java.lang.Thread#resume}. &quot;
1857         &quot;&lt;p&gt;&quot;
1858         &quot;Note that this doesn&#39;t change the status of the thread (see the &quot;
1859         &quot;&lt;a href=\&quot;#JDWP_ThreadReference_Status\&quot;&gt;ThreadStatus&lt;/a&gt; command.) &quot;
1860         &quot;For example, if it was &quot;
1861         &quot;Running, it will still appear running to other threads. &quot;
1862         (Out
1863             (threadObject thread &quot;The thread object ID. &quot;)
1864         )
1865         (Reply &quot;none&quot;
1866         )
1867         (ErrorSet
1868             (Error INVALID_THREAD)
1869             (Error INVALID_OBJECT    &quot;thread is not a known ID.&quot;)
1870             (Error VM_DEAD)
1871         )
1872     )
1873     (Command Resume=3
1874         &quot;Resumes the execution of a given thread. If this thread was &quot;
1875         &quot;not previously suspended by the front-end, &quot;
1876         &quot;calling this command has no effect. &quot;
1877         &quot;Otherwise, the count of pending suspends on this thread is &quot;
1878         &quot;decremented. If it is decremented to 0, the thread will &quot;
1879         &quot;continue to execute. &quot;
1880         (Out
1881             (threadObject thread &quot;The thread object ID. &quot;)
1882         )
1883         (Reply &quot;none&quot;
1884         )
1885         (ErrorSet
1886             (Error INVALID_THREAD)
1887             (Error INVALID_OBJECT    &quot;thread is not a known ID.&quot;)
1888             (Error VM_DEAD)
1889         )
1890     )
1891     (Command Status=4
1892         &quot;Returns the current status of a thread. The thread status &quot;
1893         &quot;reply indicates the thread status the last time it was running. &quot;
1894         &quot;the suspend status provides information on the thread&#39;s &quot;
1895         &quot;suspension, if any.&quot;
1896         (Out
1897             (threadObject thread &quot;The thread object ID. &quot;)
1898         )
1899         (Reply
1900             (int threadStatus &quot;One of the thread status codes &quot;
1901                     &quot;See &lt;a href=\&quot;#JDWP_ThreadStatus\&quot;&gt;JDWP.ThreadStatus&lt;/a&gt;&quot;)
1902             (int suspendStatus &quot;One of the suspend status codes &quot;
1903                     &quot;See &lt;a href=\&quot;#JDWP_SuspendStatus\&quot;&gt;JDWP.SuspendStatus&lt;/a&gt;&quot;)
1904         )
1905         (ErrorSet
1906             (Error INVALID_THREAD)
1907             (Error INVALID_OBJECT    &quot;thread is not a known ID.&quot;)
1908             (Error VM_DEAD)
1909         )
1910     )
1911     (Command ThreadGroup=5
1912         &quot;Returns the thread group that contains a given thread. &quot;
1913         (Out
1914             (threadObject thread &quot;The thread object ID. &quot;)
1915         )
1916         (Reply
1917             (threadGroupObject group &quot;The thread group of this thread. &quot;)
1918         )
1919         (ErrorSet
1920             (Error INVALID_THREAD)
1921             (Error INVALID_OBJECT    &quot;thread is not a known ID.&quot;)
1922             (Error VM_DEAD)
1923         )
1924     )
1925     (Command Frames=6
1926         &quot;Returns the current call stack of a suspended thread. &quot;
1927         &quot;The sequence of frames starts with &quot;
1928         &quot;the currently executing frame, followed by its caller, &quot;
1929         &quot;and so on. The thread must be suspended, and the returned &quot;
1930         &quot;frameID is valid only while the thread is suspended. &quot;
1931         (Out
1932             (threadObject thread &quot;The thread object ID. &quot;)
1933             (int startFrame &quot;The index of the first frame to retrieve.&quot;)
1934             (int length
1935                         &quot;The count of frames to retrieve &quot;
1936                         &quot;(-1 means all remaining). &quot;)
1937         )
1938         (Reply
1939             (Repeat frames &quot;The number of frames retreived&quot;
1940                 (Group Frame
1941                     (frame frameID &quot;The ID of this frame. &quot;)
1942                     (location location &quot;The current location of this frame&quot;)
1943                 )
1944             )
1945         )
1946         (ErrorSet
1947             (Error INVALID_THREAD)
1948             (Error INVALID_OBJECT    &quot;thread is not a known ID.&quot;)
1949             (Error VM_DEAD)
1950         )
1951     )
1952     (Command FrameCount=7
1953         &quot;Returns the count of frames on this thread&#39;s stack. &quot;
1954         &quot;The thread must be suspended, and the returned &quot;
1955         &quot;count is valid only while the thread is suspended. &quot;
1956         &quot;Returns JDWP.Error.errorThreadNotSuspended if not suspended. &quot;
1957         (Out
1958             (threadObject thread &quot;The thread object ID. &quot;)
1959         )
1960         (Reply
1961             (int frameCount &quot;The count of frames on this thread&#39;s stack. &quot;)
1962         )
1963         (ErrorSet
1964             (Error INVALID_THREAD)
1965             (Error INVALID_OBJECT    &quot;thread is not a known ID.&quot;)
1966             (Error VM_DEAD)
1967         )
1968     )
1969     (Command OwnedMonitors=8
1970         &quot;Returns the objects whose monitors have been entered by this thread. &quot;
1971         &quot;The thread must be suspended, and the returned information is &quot;
1972         &quot;relevant only while the thread is suspended. &quot;
1973         &quot;Requires canGetOwnedMonitorInfo capability - see &quot;
1974         &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;.&quot;
1975         (Out
1976             (threadObject thread &quot;The thread object ID. &quot;)
1977         )
1978         (Reply
1979             (Repeat owned &quot;The number of owned monitors&quot;
1980                 (tagged-object monitor &quot;An owned monitor&quot;)
1981             )
1982         )
1983         (ErrorSet
1984             (Error INVALID_THREAD)
1985             (Error INVALID_OBJECT    &quot;thread is not a known ID.&quot;)
1986             (Error NOT_IMPLEMENTED)
1987             (Error VM_DEAD)
1988         )
1989     )
1990     (Command CurrentContendedMonitor=9
1991         &quot;Returns the object, if any, for which this thread is waiting. The &quot;
1992         &quot;thread may be waiting to enter a monitor, or it may be waiting, via &quot;
1993         &quot;the java.lang.Object.wait method, for another thread to invoke the &quot;
1994         &quot;notify method. &quot;
1995         &quot;The thread must be suspended, and the returned information is &quot;
1996         &quot;relevant only while the thread is suspended. &quot;
1997         &quot;Requires canGetCurrentContendedMonitor capability - see &quot;
1998         &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;.&quot;
1999         (Out
2000             (threadObject thread &quot;The thread object ID. &quot;)
2001         )
2002         (Reply
2003             (tagged-object monitor &quot;The contended monitor, or null if &quot;
2004                                    &quot;there is no current contended monitor. &quot;)
2005         )
2006         (ErrorSet
2007             (Error INVALID_THREAD)
2008             (Error INVALID_OBJECT    &quot;thread is not a known ID.&quot;)
2009             (Error NOT_IMPLEMENTED)
2010             (Error VM_DEAD)
2011         )
2012     )
2013     (Command Stop=10
2014         &quot;Stops the thread with an asynchronous exception. &quot;
2015         (Out
2016             (threadObject thread &quot;The thread object ID. &quot;)
2017             (object throwable &quot;Asynchronous exception. This object must &quot;
2018                               &quot;be an instance of java.lang.Throwable or a subclass&quot;)
2019         )
2020         (Reply &quot;none&quot;
2021         )
2022         (ErrorSet
2023             (Error INVALID_THREAD)
2024             (Error INVALID_OBJECT &quot;If thread is not a known ID or the asynchronous &quot;
2025                                   &quot;exception has been garbage collected.&quot;)
2026             (Error VM_DEAD)
2027         )
2028     )
2029     (Command Interrupt=11
2030         &quot;Interrupt the thread, as if done by java.lang.Thread.interrupt &quot;
2031         (Out
2032             (threadObject thread &quot;The thread object ID. &quot;)
2033         )
2034         (Reply &quot;none&quot;
2035         )
2036         (ErrorSet
2037             (Error INVALID_THREAD)
2038             (Error INVALID_OBJECT    &quot;thread is not a known ID.&quot;)
2039             (Error VM_DEAD)
2040         )
2041     )
2042     (Command SuspendCount=12
2043         &quot;Get the suspend count for this thread. The suspend count is the  &quot;
2044         &quot;number of times the thread has been suspended through the &quot;
2045         &quot;thread-level or VM-level suspend commands without a corresponding resume &quot;
2046         (Out
2047             (threadObject thread &quot;The thread object ID. &quot;)
2048         )
2049         (Reply
2050             (int suspendCount &quot;The number of outstanding suspends of this thread. &quot;)
2051         )
2052         (ErrorSet
2053             (Error INVALID_THREAD)
2054             (Error INVALID_OBJECT    &quot;thread is not a known ID.&quot;)
2055             (Error VM_DEAD)
2056         )
2057     )
2058     (Command OwnedMonitorsStackDepthInfo=13
2059         &quot;Returns monitor objects owned by the thread, along with stack depth at which &quot;
2060         &quot;the monitor was acquired. Returns stack depth of -1  if &quot;
2061         &quot;the implementation cannot determine the stack depth &quot;
2062         &quot;(e.g., for monitors acquired by JNI MonitorEnter).&quot;
2063         &quot;The thread must be suspended, and the returned information is &quot;
2064         &quot;relevant only while the thread is suspended. &quot;
2065         &quot;Requires canGetMonitorFrameInfo capability - see &quot;
2066         &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;. &quot;
2067         &quot;&lt;p&gt;Since JDWP version 1.6. &quot;
2068 
2069         (Out
2070             (threadObject thread &quot;The thread object ID. &quot;)
2071         )
2072         (Reply
2073             (Repeat owned &quot;The number of owned monitors&quot;
2074                (Group monitor
2075                   (tagged-object monitor &quot;An owned monitor&quot;)
2076                   (int stack_depth &quot;Stack depth location where monitor was acquired&quot;)
2077                )
2078             )
2079         )
2080         (ErrorSet
2081             (Error INVALID_THREAD)
2082             (Error INVALID_OBJECT    &quot;thread is not a known ID.&quot;)
2083             (Error NOT_IMPLEMENTED)
2084             (Error VM_DEAD)
2085         )
2086     )
2087     (Command ForceEarlyReturn=14
2088         &quot;Force a method to return before it reaches a return &quot;
2089         &quot;statement.  &quot;
2090         &quot;&lt;p&gt;&quot;
2091         &quot;The method which will return early is referred to as the &quot;
2092         &quot;called method. The called method is the current method (as &quot;
2093         &quot;defined by the Frames section in &quot;
2094         &quot;&lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;) &quot;
2095         &quot;for the specified thread at the time this command &quot;
2096         &quot;is received. &quot;
2097         &quot;&lt;p&gt;&quot;
2098         &quot;The specified thread must be suspended. &quot;
2099         &quot;The return occurs when execution of Java programming &quot;
2100         &quot;language code is resumed on this thread. Between sending this &quot;
2101         &quot;command and resumption of thread execution, the &quot;
2102         &quot;state of the stack is undefined. &quot;
2103         &quot;&lt;p&gt;&quot;
2104         &quot;No further instructions are executed in the called &quot;
2105         &quot;method. Specifically, finally blocks are not executed. Note: &quot;
2106         &quot;this can cause inconsistent states in the application. &quot;
2107         &quot;&lt;p&gt;&quot;
2108         &quot;A lock acquired by calling the called method (if it is a &quot;
2109         &quot;synchronized method) and locks acquired by entering &quot;
2110         &quot;synchronized blocks within the called method are &quot;
2111         &quot;released. Note: this does not apply to JNI locks or &quot;
2112         &quot;java.util.concurrent.locks locks. &quot;
2113         &quot;&lt;p&gt;&quot;
2114         &quot;Events, such as MethodExit, are generated as they would be in &quot;
2115         &quot;a normal return. &quot;
2116         &quot;&lt;p&gt;&quot;
2117         &quot;The called method must be a non-native Java programming &quot;
2118         &quot;language method. Forcing return on a thread with only one &quot;
2119         &quot;frame on the stack causes the thread to exit when resumed. &quot;
2120         &quot;&lt;p&gt;&quot;
2121         &quot;For void methods, the value must be a void value. &quot;
2122         &quot;For methods that return primitive values, the value&#39;s type must &quot;
2123         &quot;match the return type exactly.  For object values, there must be a &quot;
2124         &quot;widening reference conversion from the value&#39;s type to the &quot;
2125         &quot;return type type and the return type must be loaded. &quot;
2126         &quot;&lt;p&gt;&quot;
2127         &quot;Since JDWP version 1.6. Requires canForceEarlyReturn capability - see &quot;
2128         &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;.&quot;
2129         (Out
2130             (threadObject thread &quot;The thread object ID. &quot;)
2131             (value value &quot;The value to return. &quot;)
2132         )
2133         (Reply &quot;none&quot;
2134         )
2135         (ErrorSet
2136             (Error INVALID_THREAD)
2137             (Error INVALID_OBJECT    &quot;Thread or value is not a known ID.&quot;)
2138             (Error THREAD_NOT_SUSPENDED)
2139             (Error THREAD_NOT_ALIVE)
2140             (Error OPAQUE_FRAME      &quot;Attempted to return early from &quot;
2141                                      &quot;a frame corresponding to a native &quot;
2142                                      &quot;method. Or the implementation is &quot;
2143                                      &quot;unable to provide this functionality &quot;
2144                                      &quot;on this frame.&quot;)
2145             (Error NO_MORE_FRAMES)
2146             (Error NOT_IMPLEMENTED)
2147             (Error TYPE_MISMATCH   &quot;Value is not an appropriate type for the &quot;
2148                                    &quot;return value of the method.&quot;)
2149             (Error VM_DEAD)
2150         )
2151     )
2152 
2153 )
2154 (CommandSet ThreadGroupReference=12
2155     (Command Name=1
2156         &quot;Returns the thread group name. &quot;
2157         (Out
2158             (threadGroupObject group &quot;The thread group object ID. &quot;)
2159         )
2160         (Reply
2161             (string groupName &quot;The thread group&#39;s name.&quot;)
2162         )
2163         (ErrorSet
2164             (Error INVALID_THREAD_GROUP)
2165             (Error INVALID_OBJECT    &quot;group is not a known ID.&quot;)
2166             (Error VM_DEAD)
2167         )
2168     )
2169     (Command Parent=2
2170         &quot;Returns the thread group, if any, which contains a given thread group. &quot;
2171         (Out
2172             (threadGroupObject group &quot;The thread group object ID. &quot;)
2173         )
2174         (Reply
2175             (threadGroupObject parentGroup &quot;The parent thread group object, or &quot;
2176                                            &quot;null if the given thread group &quot;
2177                                            &quot;is a top-level thread group&quot;)
2178         )
2179         (ErrorSet
2180             (Error INVALID_THREAD_GROUP)
2181             (Error INVALID_OBJECT    &quot;group is not a known ID.&quot;)
2182             (Error VM_DEAD)
2183         )
2184     )
2185     (Command Children=3
2186         &quot;Returns the live threads and active thread groups directly contained &quot;
2187         &quot;in this thread group. Threads and thread groups in child &quot;
2188         &quot;thread groups are not included. &quot;
2189         &quot;A thread is alive if it has been started and has not yet been stopped. &quot;
2190         &quot;See &lt;a href=../../api/java.base/java/lang/ThreadGroup.html&gt;java.lang.ThreadGroup &lt;/a&gt;
2191         &quot;for information about active ThreadGroups.
2192         (Out
2193             (threadGroupObject group &quot;The thread group object ID. &quot;)
2194         )
2195         (Reply
2196             (Repeat childThreads &quot;The number of live child threads. &quot;
2197                 (threadObject childThread &quot;A direct child thread ID. &quot;)
2198             )
2199             (Repeat childGroups &quot;The number of active child thread groups. &quot;
2200                 (threadGroupObject childGroup &quot;A direct child thread group ID. &quot;)
2201             )
2202         )
2203         (ErrorSet
2204             (Error INVALID_THREAD_GROUP)
2205             (Error INVALID_OBJECT    &quot;group is not a known ID.&quot;)
2206             (Error VM_DEAD)
2207         )
2208     )
2209 )
2210 (CommandSet ArrayReference=13
2211     (Command Length=1
2212         &quot;Returns the number of components in a given array. &quot;
2213         (Out
2214             (arrayObject arrayObject &quot;The array object ID. &quot;)
2215         )
2216         (Reply
2217             (int arrayLength &quot;The length of the array.&quot;)
2218         )
2219         (ErrorSet
2220             (Error INVALID_OBJECT    &quot;arrayObject is not a known ID.&quot;)
2221             (Error INVALID_ARRAY)
2222             (Error VM_DEAD)
2223         )
2224     )
2225     (Command GetValues=2
2226         &quot;Returns a range of array components. The specified range must &quot;
2227         &quot;be within the bounds of the array. &quot;
2228         (Out
2229             (arrayObject arrayObject &quot;The array object ID. &quot;)
2230             (int firstIndex &quot;The first index to retrieve.&quot;)
2231             (int length &quot;The number of components to retrieve.&quot;)
2232         )
2233         (Reply
2234             (typed-sequence values &quot;The retrieved values. If the values &quot;
2235                                    &quot;are objects, they are tagged-values; &quot;
2236                                    &quot;otherwise, they are untagged-values&quot;)
2237         )
2238         (ErrorSet
2239             (Error INVALID_LENGTH &quot;If index is beyond the end of this array.&quot;)
2240             (Error INVALID_OBJECT    &quot;arrayObject is not a known ID.&quot;)
2241             (Error INVALID_ARRAY)
2242             (Error VM_DEAD)
2243         )
2244     )
2245     (Command SetValues=3
2246         &quot;Sets a range of array components. The specified range must &quot;
2247         &quot;be within the bounds of the array. &quot;
2248         &quot;For primitive values, each value&#39;s type must match the &quot;
2249         &quot;array component type exactly. For object values, there must be a &quot;
2250         &quot;widening reference conversion from the value&#39;s type to the
2251         &quot;array component type and the array component type must be loaded. &quot;
2252         (Out
2253             (arrayObject arrayObject &quot;The array object ID. &quot;)
2254             (int firstIndex &quot;The first index to set.&quot;)
2255             (Repeat values &quot;The number of values to set. &quot;
2256                 (untagged-value value &quot;A value to set. &quot;)
2257             )
2258         )
2259         (Reply &quot;none&quot;
2260         )
2261         (ErrorSet
2262             (Error INVALID_LENGTH &quot;If index is beyond the end of this array.&quot;)
2263             (Error INVALID_OBJECT    &quot;arrayObject is not a known ID.&quot;)
2264             (Error INVALID_ARRAY)
2265             (Error VM_DEAD)
2266         )
2267     )
2268 )
2269 (CommandSet ClassLoaderReference=14
2270     (Command VisibleClasses=1
2271         &quot;Returns a list of all classes which this class loader can find &quot;
2272         &quot;by name via &lt;code&gt;ClassLoader::loadClass&lt;/code&gt;, &quot;
2273         &quot;&lt;code&gt;Class::forName&lt;/code&gt; and bytecode linkage. That is, &quot;
2274         &quot;all classes for which this class loader has been recorded as an &quot;
2275         &quot;&lt;i&gt;initiating&lt;/i&gt; loader. The list contains each &quot;
2276         &quot;reference type created by this loader and any types for which &quot;
2277         &quot;loading was delegated by this class loader to another class loader. &quot;
2278         &quot;&lt;p&gt;&quot;
2279         &quot;The visible class list has useful properties with respect to &quot;
2280         &quot;the type namespace. A particular type name will occur at most &quot;
2281         &quot;once in the list. Each field or variable declared with that &quot;
2282         &quot;type name in a class defined by &quot;
2283         &quot;this class loader must be resolved to that single type. &quot;
2284         &quot;&lt;p&gt;&quot;
2285         &quot;No ordering of the returned list is guaranteed. &quot;
2286         &quot;&lt;p&gt;&quot;
2287         &quot;See &lt;a href=\&quot;../jvmti.html#GetClassLoaderClasses\&quot;&gt;JVM TI GetClassLoaderClasses&lt;/a&gt;. &quot;
2288         (Out
2289             (classLoaderObject classLoaderObject &quot;The class loader object ID. &quot;)
2290         )
2291         (Reply
2292             (Repeat classes &quot;The number of visible classes. &quot;
2293                 (Group ClassInfo
2294                     (byte refTypeTag  &quot;&lt;a href=\&quot;#JDWP_TypeTag\&quot;&gt;Kind&lt;/a&gt; &quot;
2295                                       &quot;of following reference type. &quot;)
2296                     (referenceTypeID typeID
2297                         &quot;A class visible to this class loader.&quot;)
2298                 )
2299             )
2300         )
2301         (ErrorSet
2302             (Error INVALID_OBJECT)
2303             (Error INVALID_CLASS_LOADER)
2304             (Error VM_DEAD)
2305         )
2306     )
2307 )
2308 (CommandSet EventRequest=15
2309     (Command Set=1
2310         &quot;Set an event request. When the event described by this request &quot;
2311         &quot;occurs, an &lt;a href=\&quot;#JDWP_Event\&quot;&gt;event&lt;/a&gt; is sent from the &quot;
2312         &quot;target VM. If an event occurs that has not been requested then it is not sent &quot;
2313         &quot;from the target VM. The two exceptions to this are the VM Start Event and &quot;
2314         &quot;the VM Death Event which are automatically generated events - see &quot;
2315         &quot;&lt;a href=\&quot;#JDWP_Event_Composite\&quot;&gt;Composite Command&lt;/a&gt; for further details.&quot;
2316         (Out
2317             (byte eventKind &quot;Event kind to request. &quot;
2318                       &quot;See &lt;a href=\&quot;#JDWP_EventKind\&quot;&gt;JDWP.EventKind&lt;/a&gt; &quot;
2319                       &quot;for a complete list of events that can be requested; &quot;
2320                       &quot;some events may require a capability in order to be requested. &quot;
2321                       )
2322             (byte suspendPolicy
2323                       &quot;What threads are suspended when this event occurs? &quot;
2324                       &quot;Note that the order of events and command replies &quot;
2325                       &quot;accurately reflects the order in which threads are &quot;
2326                       &quot;suspended and resumed. For example, if a &quot;
2327                       &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_Resume\&quot;&gt;VM-wide resume&lt;/a&gt; &quot;
2328                       &quot;is processed before an event occurs which suspends the &quot;
2329                       &quot;VM, the reply to the resume command will be written to &quot;
2330                       &quot;the transport before the suspending event.&quot;)
2331             (Repeat modifiers &quot;Constraints used to control the number &quot;
2332                               &quot;of generated events.&quot;
2333                               &quot;Modifiers specify additional tests that &quot;
2334                               &quot;an event must satisfy before it is placed &quot;
2335                               &quot;in the event queue. Events are filtered by &quot;
2336                               &quot;applying each modifier to an event in the &quot;
2337                               &quot;order they are specified in this collection &quot;
2338                               &quot;Only events that satisfy all modifiers &quot;
2339                               &quot;are reported. A value of 0 means there are no &quot;
2340                               &quot;modifiers in the request.&quot;
2341                               &quot;&lt;p&gt;&quot;
2342                               &quot;Filtering can improve &quot;
2343                               &quot;debugger performance dramatically by
2344                               &quot;reducing the &quot;
2345                               &quot;amount of event traffic sent from the &quot;
2346                               &quot;target VM to the debugger VM. &quot;
2347                 (Select Modifier
2348                     (byte modKind &quot;Modifier kind&quot;)
2349                     (Alt Count=1
2350                         &quot;Limit the requested event to be reported at most once after a &quot;
2351                         &quot;given number of occurrences.  The event is not reported &quot;
2352                         &quot;the first &lt;code&gt;count - 1&lt;/code&gt; times this filter is reached. &quot;
2353                         &quot;To request a one-off event, call this method with a count of 1. &quot;
2354                         &quot;&lt;p&gt;&quot;
2355                         &quot;Once the count reaches 0, any subsequent filters in this request &quot;
2356                         &quot;are applied. If none of those filters cause the event to be &quot;
2357                         &quot;suppressed, the event is reported. Otherwise, the event is not &quot;
2358                         &quot;reported. In either case subsequent events are never reported for &quot;
2359                         &quot;this request. &quot;
2360                         &quot;This modifier can be used with any event kind.&quot;
2361 
2362                         (int count &quot;Count before event. One for one-off.&quot;)
2363                     )
2364                     (Alt Conditional=2 &quot;Conditional on expression&quot;
2365                         (int exprID &quot;For the future&quot;)
2366                     )
2367                     (Alt ThreadOnly=3
2368                         &quot;Restricts reported events to &quot;
2369                         &quot;those in the given thread. &quot;
2370                         &quot;This modifier can be used with any event kind &quot;
2371                         &quot;except for class unload. &quot;
2372 
2373                         (threadObject thread &quot;Required thread&quot;)
2374                     )
2375                     (Alt ClassOnly=4
2376                         &quot;For class prepare events, restricts the events &quot;
2377                         &quot;generated by this request to be the &quot;
2378                         &quot;preparation of the given reference type and any subtypes. &quot;
2379                         &quot;For monitor wait and waited events, restricts the events &quot;
2380                         &quot;generated by this request to those whose monitor object &quot;
2381                         &quot;is of the given reference type or any of its subtypes. &quot;
2382                         &quot;For other events, restricts the events generated &quot;
2383                         &quot;by this request to those &quot;
2384                         &quot;whose location is in the given reference type or any of its subtypes. &quot;
2385                         &quot;An event will be generated for any location in a reference type that can &quot;
2386                         &quot;be safely cast to the given reference type. &quot;
2387                         &quot;This modifier can be used with any event kind except &quot;
2388                         &quot;class unload, thread start, and thread end. &quot;
2389 
2390                         (referenceType clazz &quot;Required class&quot;)
2391                     )
2392                     (Alt ClassMatch=5
2393                         &quot;Restricts reported events to those for classes whose name &quot;
2394                         &quot;matches the given restricted regular expression. &quot;
2395                         &quot;For class prepare events, the prepared class name &quot;
2396                         &quot;is matched. For class unload events, the &quot;
2397                         &quot;unloaded class name is matched. For monitor wait &quot;
2398                         &quot;and waited events, the name of the class of the &quot;
2399                         &quot;monitor object is matched. For other events, &quot;
2400                         &quot;the class name of the event&#39;s location is matched. &quot;
2401                         &quot;This modifier can be used with any event kind except &quot;
2402                         &quot;thread start and thread end. &quot;
2403 
2404                         (string classPattern &quot;Required class pattern. &quot;
2405                                 &quot;Matches are limited to exact matches of the &quot;
2406                                 &quot;given class pattern and matches of patterns that &quot;
2407                                 &quot;begin or end with &#39;*&#39;; for example, &quot;
2408                                 &quot;\&quot;*.Foo\&quot; or \&quot;java.*\&quot;. &quot;
2409                         )
2410 
2411                     )
2412                     (Alt ClassExclude=6
2413                         &quot;Restricts reported events to those for classes whose name &quot;
2414                         &quot;does not match the given restricted regular expression. &quot;
2415                         &quot;For class prepare events, the prepared class name &quot;
2416                         &quot;is matched. For class unload events, the &quot;
2417                         &quot;unloaded class name is matched. For monitor wait and &quot;
2418                         &quot;waited events, the name of the class of the monitor &quot;
2419                         &quot;object is matched. For other events, &quot;
2420                         &quot;the class name of the event&#39;s location is matched. &quot;
2421                         &quot;This modifier can be used with any event kind except &quot;
2422                         &quot;thread start and thread end. &quot;
2423 
2424                         (string classPattern &quot;Disallowed class pattern. &quot;
2425                                 &quot;Matches are limited to exact matches of the &quot;
2426                                 &quot;given class pattern and matches of patterns that &quot;
2427                                 &quot;begin or end with &#39;*&#39;; for example, &quot;
2428                                 &quot;\&quot;*.Foo\&quot; or \&quot;java.*\&quot;. &quot;
2429                         )
2430                     )
2431                     (Alt LocationOnly=7
2432                         &quot;Restricts reported events to those that occur at &quot;
2433                         &quot;the given location. &quot;
2434                         &quot;This modifier can be used with &quot;
2435                         &quot;breakpoint, field access, field modification, &quot;
2436                         &quot;step, and exception event kinds. &quot;
2437 
2438                         (location loc &quot;Required location&quot;)
2439                     )
2440                     (Alt ExceptionOnly=8
2441                         &quot;Restricts reported exceptions by their class and &quot;
2442                         &quot;whether they are caught or uncaught. &quot;
2443                         &quot;This modifier can be used with &quot;
2444                         &quot;exception event kinds only. &quot;
2445 
2446                         (referenceType exceptionOrNull
2447                                 &quot;Exception to report. Null (0) means report &quot;
2448                                 &quot;exceptions of all types. &quot;
2449                                 &quot;A non-null type restricts the reported exception &quot;
2450                                 &quot;events to exceptions of the given type or &quot;
2451                                 &quot;any of its subtypes. &quot;
2452                         )
2453                         (boolean caught &quot;Report caught exceptions&quot;)
2454                         (boolean uncaught &quot;Report uncaught exceptions. &quot;
2455                                 &quot;Note that it &quot;
2456                                 &quot;is not always possible to determine whether an &quot;
2457                                 &quot;exception is caught or uncaught at the time it is &quot;
2458                                 &quot;thrown. See the exception event catch location under &quot;
2459                                 &quot;&lt;a href=\&quot;#JDWP_Event_Composite\&quot;&gt;composite events&lt;/a&gt; &quot;
2460                                 &quot;for more information. &quot;
2461                         )
2462 
2463                     )
2464                     (Alt FieldOnly=9
2465                         &quot;Restricts reported events to those that occur for &quot;
2466                         &quot;a given field. &quot;
2467                         &quot;This modifier can be used with &quot;
2468                         &quot;field access and field modification event kinds only. &quot;
2469 
2470                         (referenceType declaring &quot;Type in which field is declared.&quot;)
2471                         (field fieldID &quot;Required field&quot;)
2472                     )
2473                     (Alt Step=10
2474                         &quot;Restricts reported step events &quot;
2475                         &quot;to those which satisfy &quot;
2476                         &quot;depth and size constraints. &quot;
2477                         &quot;This modifier can be used with &quot;
2478                         &quot;step event kinds only. &quot;
2479 
2480                         (threadObject thread &quot;Thread in which to step&quot;)
2481                         (int size &quot;size of each step. &quot;
2482                            &quot;See &lt;a href=\&quot;#JDWP_StepSize\&quot;&gt;JDWP.StepSize&lt;/a&gt;&quot;)
2483                         (int depth &quot;relative call stack limit. &quot;
2484                            &quot;See &lt;a href=\&quot;#JDWP_StepDepth\&quot;&gt;JDWP.StepDepth&lt;/a&gt;&quot;)
2485                     )
2486                     (Alt InstanceOnly=11
2487                         &quot;Restricts reported events to those whose &quot;
2488                         &quot;active &#39;this&#39; object is the given object. &quot;
2489                         &quot;Match value is the null object for static methods. &quot;
2490                         &quot;This modifier can be used with any event kind &quot;
2491                         &quot;except class prepare, class unload, thread start, &quot;
2492                         &quot;and thread end. Introduced in JDWP version 1.4.&quot;
2493 
2494                         (object instance &quot;Required &#39;this&#39; object&quot;)
2495                     )
2496                     (Alt SourceNameMatch=12
2497                         &quot;Restricts reported class prepare events to those &quot;
2498                         &quot;for reference types which have a source name &quot;
2499                         &quot;which matches the given restricted regular expression. &quot;
2500                         &quot;The source names are determined by the reference type&#39;s &quot;
2501                         &quot;&lt;a href=\&quot;#JDWP_ReferenceType_SourceDebugExtension\&quot;&gt; &quot;
2502                         &quot;SourceDebugExtension&lt;/a&gt;. &quot;
2503                         &quot;This modifier can only be used with class prepare &quot;
2504                         &quot;events. &quot;
2505                         &quot;Since JDWP version 1.6. Requires the canUseSourceNameFilters &quot;
2506                         &quot;capability - see &quot;
2507                         &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;.&quot;
2508 
2509                         (string sourceNamePattern &quot;Required source name pattern. &quot;
2510                                 &quot;Matches are limited to exact matches of the &quot;
2511                                 &quot;given pattern and matches of patterns that &quot;
2512                                 &quot;begin or end with &#39;*&#39;; for example, &quot;
2513                                 &quot;\&quot;*.Foo\&quot; or \&quot;java.*\&quot;. &quot;
2514                         )
2515                     )
2516 
2517                 )
2518             )
2519         )
2520         (Reply
2521             (int requestID &quot;ID of created request&quot;)
2522         )
2523         (ErrorSet
2524             (Error INVALID_THREAD)
2525             (Error INVALID_CLASS)
2526             (Error INVALID_STRING)
2527             (Error INVALID_OBJECT)
2528             (Error INVALID_COUNT)
2529             (Error INVALID_FIELDID)
2530             (Error INVALID_METHODID)
2531             (Error INVALID_LOCATION)
2532             (Error INVALID_EVENT_TYPE)
2533             (Error NOT_IMPLEMENTED)
2534             (Error VM_DEAD)
2535         )
2536     )
2537     (Command Clear=2
2538         &quot;Clear an event request. See &lt;a href=\&quot;#JDWP_EventKind\&quot;&gt;JDWP.EventKind&lt;/a&gt; &quot;
2539         &quot;for a complete list of events that can be cleared. Only the event request matching &quot;
2540         &quot;the specified event kind and requestID is cleared. If there isn&#39;t a matching event &quot;
2541         &quot;request the command is a no-op and does not result in an error. Automatically &quot;
2542         &quot;generated events do not have a corresponding event request and may not be cleared &quot;
2543         &quot;using this command.&quot;
2544         (Out
2545             (byte eventKind &quot;Event kind to clear&quot;)
2546             (int requestID &quot;ID of request to clear&quot;)
2547         )
2548         (Reply &quot;none&quot;
2549         )
2550         (ErrorSet
2551             (Error VM_DEAD)
2552             (Error INVALID_EVENT_TYPE)
2553         )
2554     )
2555     (Command ClearAllBreakpoints=3
2556         &quot;Removes all set breakpoints, a no-op if there are no breakpoints set.&quot;
2557         (Out &quot;none&quot;
2558         )
2559         (Reply &quot;none&quot;
2560         )
2561         (ErrorSet
2562             (Error VM_DEAD)
2563         )
2564     )
2565 )
2566 (CommandSet StackFrame=16
2567     (Command GetValues=1
2568         &quot;Returns the value of one or more local variables in a &quot;
2569         &quot;given frame. Each variable must be visible at the frame&#39;s code index. &quot;
2570         &quot;Even if local variable information is not available, values can &quot;
2571         &quot;be retrieved if the front-end is able to &quot;
2572         &quot;determine the correct local variable index. (Typically, this &quot;
2573         &quot;index can be determined for method arguments from the method &quot;
2574         &quot;signature without access to the local variable table information.) &quot;
2575         (Out
2576             (threadObject thread &quot;The frame&#39;s thread. &quot;)
2577             (frame frame &quot;The frame ID. &quot;)
2578             (Repeat slots &quot;The number of values to get. &quot;
2579                 (Group SlotInfo
2580                     (int slot &quot;The local variable&#39;s index in the frame. &quot;)
2581                     (byte sigbyte &quot;A &lt;a href=\&quot;#JDWP_Tag\&quot;&gt;tag&lt;/a&gt; &quot;
2582                                   &quot;identifying the type of the variable &quot;)
2583                 )
2584             )
2585         )
2586         (Reply
2587             (Repeat values &quot;The number of values retrieved, always equal to slots, &quot;
2588                            &quot;the number of values to get.&quot;
2589                 (value slotValue &quot;The value of the local variable. &quot;)
2590             )
2591         )
2592         (ErrorSet
2593             (Error INVALID_THREAD)
2594             (Error INVALID_OBJECT)
2595             (Error INVALID_FRAMEID)
2596             (Error INVALID_SLOT)
2597             (Error VM_DEAD)
2598         )
2599     )
2600     (Command SetValues=2
2601         &quot;Sets the value of one or more local variables. &quot;
2602         &quot;Each variable must be visible at the current frame code index. &quot;
2603         &quot;For primitive values, the value&#39;s type must match the &quot;
2604         &quot;variable&#39;s type exactly. For object values, there must be a &quot;
2605         &quot;widening reference conversion from the value&#39;s type to the
2606         &quot;variable&#39;s type and the variable&#39;s type must be loaded. &quot;
2607         &quot;&lt;p&gt;&quot;
2608         &quot;Even if local variable information is not available, values can &quot;
2609         &quot;be set, if the front-end is able to &quot;
2610         &quot;determine the correct local variable index. (Typically, this
2611         &quot;index can be determined for method arguments from the method &quot;
2612         &quot;signature without access to the local variable table information.) &quot;
2613         (Out
2614             (threadObject thread &quot;The frame&#39;s thread. &quot;)
2615             (frame frame &quot;The frame ID. &quot;)
2616             (Repeat slotValues &quot;The number of values to set. &quot;
2617                 (Group SlotInfo
2618                     (int slot &quot;The slot ID. &quot;)
2619                     (value slotValue &quot;The value to set. &quot;)
2620                 )
2621             )
2622         )
2623         (Reply &quot;none&quot;
2624         )
2625         (ErrorSet
2626             (Error INVALID_THREAD)
2627             (Error INVALID_OBJECT)
2628             (Error INVALID_FRAMEID)
2629             (Error VM_DEAD)
2630         )
2631     )
2632     (Command ThisObject=3
2633         &quot;Returns the value of the &#39;this&#39; reference for this frame. &quot;
2634         &quot;If the frame&#39;s method is static or native, the reply &quot;
2635         &quot;will contain the null object reference. &quot;
2636         (Out
2637             (threadObject thread &quot;The frame&#39;s thread. &quot;)
2638             (frame frame &quot;The frame ID. &quot;)
2639         )
2640         (Reply
2641             (tagged-object objectThis &quot;The &#39;this&#39; object for this frame. &quot;)
2642         )
2643         (ErrorSet
2644             (Error INVALID_THREAD)
2645             (Error INVALID_OBJECT)
2646             (Error INVALID_FRAMEID)
2647             (Error VM_DEAD)
2648         )
2649     )
2650     (Command PopFrames=4
2651         &quot;Pop the top-most stack frames of the thread stack, up to, and including &#39;frame&#39;. &quot;
2652         &quot;The thread must be suspended to perform this command. &quot;
2653         &quot;The top-most stack frames are discarded and the stack frame previous to &#39;frame&#39; &quot;
2654         &quot;becomes the current frame. The operand stack is restored -- the argument values &quot;
2655         &quot;are added back and if the invoke was not &lt;code&gt;invokestatic&lt;/code&gt;, &quot;
2656         &quot;&lt;code&gt;objectref&lt;/code&gt; is added back as well. The Java virtual machine &quot;
2657         &quot;program counter is restored to the opcode of the invoke instruction.&quot;
2658         &quot;&lt;p&gt;&quot;
2659         &quot;Since JDWP version 1.4. Requires canPopFrames capability - see &quot;
2660         &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;.&quot;
2661         (Out
2662             (threadObject thread &quot;The thread object ID. &quot;)
2663             (frame frame &quot;The frame ID. &quot;)
2664         )
2665         (Reply &quot;none&quot;
2666         )
2667         (ErrorSet
2668             (Error INVALID_THREAD)
2669             (Error INVALID_OBJECT    &quot;thread is not a known ID.&quot;)
2670             (Error INVALID_FRAMEID)
2671             (Error THREAD_NOT_SUSPENDED)
2672             (Error NO_MORE_FRAMES)
2673             (Error INVALID_FRAMEID)
2674             (Error NOT_IMPLEMENTED)
2675             (Error VM_DEAD)
2676         )
2677     )
2678 )
2679 (CommandSet ClassObjectReference=17
2680     (Command ReflectedType = 1
2681         &quot;Returns the reference type reflected by this class object.&quot;
2682         (Out
2683             (classObject classObject &quot;The class object. &quot;)
2684         )
2685         (Reply
2686             (byte refTypeTag  &quot;&lt;a href=\&quot;#JDWP_TypeTag\&quot;&gt;Kind&lt;/a&gt; &quot;
2687                               &quot;of following reference type. &quot;)
2688             (referenceTypeID typeID &quot;reflected reference type&quot;)
2689         )
2690         (ErrorSet
2691             (Error INVALID_OBJECT)
2692             (Error VM_DEAD)
2693         )
2694     )
2695 )
2696 (CommandSet ModuleReference=18
2697     (Command Name=1
2698         &quot;Returns the name of this module.&quot;
2699         &quot;&lt;p&gt;Since JDWP version 9.&quot;
2700         (Out
2701             (moduleID module &quot;This module.&quot;)
2702         )
2703         (Reply
2704             (string name  &quot;The module&#39;s name.&quot;)
2705         )
2706         (ErrorSet
2707             (Error INVALID_MODULE)
2708             (Error NOT_IMPLEMENTED)
2709             (Error VM_DEAD)
2710         )
2711     )
2712     (Command ClassLoader=2
2713         &quot;Returns the class loader of this module.&quot;
2714         &quot;&lt;p&gt;Since JDWP version 9.&quot;
2715         (Out
2716             (moduleID module &quot;This module.&quot;)
2717         )
2718         (Reply
2719             (classLoaderObject classLoader  &quot;The module&#39;s class loader.&quot;)
2720         )
2721         (ErrorSet
2722             (Error INVALID_MODULE)
2723             (Error NOT_IMPLEMENTED)
2724             (Error VM_DEAD)
2725         )
2726     )
2727 )
2728 (CommandSet Event=64
2729     (Command Composite=100
2730         &quot;Several events may occur at a given time in the target VM. &quot;
2731         &quot;For example, there may be more than one breakpoint request &quot;
2732         &quot;for a given location &quot;
2733         &quot;or you might single step to the same location as a &quot;
2734         &quot;breakpoint request.  These events are delivered &quot;
2735         &quot;together as a composite event.  For uniformity, a &quot;
2736         &quot;composite event is always used &quot;
2737         &quot;to deliver events, even if there is only one event to report. &quot;
2738         &quot;&lt;P&gt;&quot;
2739         &quot;The events that are grouped in a composite event are restricted in the &quot;
2740         &quot;following ways: &quot;
2741         &quot;&lt;UL&gt;&quot;
2742         &quot;&lt;LI&gt;Only with other thread start events for the same thread:&quot;
2743         &quot;    &lt;UL&gt;&quot;
2744         &quot;    &lt;LI&gt;Thread Start Event&quot;
2745         &quot;    &lt;/UL&gt;&quot;
2746         &quot;&lt;LI&gt;Only with other thread death events for the same thread:&quot;
2747         &quot;    &lt;UL&gt;&quot;
2748         &quot;    &lt;LI&gt;Thread Death Event&quot;
2749         &quot;    &lt;/UL&gt;&quot;
2750         &quot;&lt;LI&gt;Only with other class prepare events for the same class:&quot;
2751         &quot;    &lt;UL&gt;&quot;
2752         &quot;    &lt;LI&gt;Class Prepare Event&quot;
2753         &quot;    &lt;/UL&gt;&quot;
2754         &quot;&lt;LI&gt;Only with other class unload events for the same class:&quot;
2755         &quot;    &lt;UL&gt;&quot;
2756         &quot;    &lt;LI&gt;Class Unload Event&quot;
2757         &quot;    &lt;/UL&gt;&quot;
2758         &quot;&lt;LI&gt;Only with other access watchpoint events for the same field access:&quot;
2759         &quot;    &lt;UL&gt;&quot;
2760         &quot;    &lt;LI&gt;Access Watchpoint Event&quot;
2761         &quot;    &lt;/UL&gt;&quot;
2762         &quot;&lt;LI&gt;Only with other modification watchpoint events for the same field &quot;
2763         &quot;modification:&quot;
2764         &quot;    &lt;UL&gt;&quot;
2765         &quot;    &lt;LI&gt;Modification Watchpoint Event&quot;
2766         &quot;    &lt;/UL&gt;&quot;
2767         &quot;&lt;LI&gt;Only with other Monitor contended enter events for the same monitor object: &quot;
2768         &quot;    &lt;UL&gt;&quot;
2769         &quot;    &lt;LI&gt;Monitor Contended Enter Event&quot;
2770         &quot;    &lt;/UL&gt;&quot;
2771         &quot;&lt;LI&gt;Only with other Monitor contended entered events for the same monitor object: &quot;
2772         &quot;    &lt;UL&gt;&quot;
2773         &quot;    &lt;LI&gt;Monitor Contended Entered Event&quot;
2774         &quot;    &lt;/UL&gt;&quot;
2775         &quot;&lt;LI&gt;Only with other Monitor wait events for the same monitor object: &quot;
2776         &quot;    &lt;UL&gt;&quot;
2777         &quot;    &lt;LI&gt;Monitor Wait Event&quot;
2778         &quot;    &lt;/UL&gt;&quot;
2779         &quot;&lt;LI&gt;Only with other Monitor waited events for the same monitor object: &quot;
2780         &quot;    &lt;UL&gt;&quot;
2781         &quot;    &lt;LI&gt;Monitor Waited Event&quot;
2782         &quot;    &lt;/UL&gt;&quot;
2783         &quot;&lt;LI&gt;Only with other ExceptionEvents for the same exception occurrance:&quot;
2784         &quot;    &lt;UL&gt;&quot;
2785         &quot;    &lt;LI&gt;ExceptionEvent&quot;
2786         &quot;    &lt;/UL&gt;&quot;
2787         &quot;&lt;LI&gt;Only with other members of this group, at the same location &quot;
2788         &quot;and in the same thread: &quot;
2789         &quot;    &lt;UL&gt;&quot;
2790         &quot;    &lt;LI&gt;Breakpoint Event&quot;
2791         &quot;    &lt;LI&gt;Step Event&quot;
2792         &quot;    &lt;LI&gt;Method Entry Event&quot;
2793         &quot;    &lt;LI&gt;Method Exit Event&quot;
2794         &quot;    &lt;/UL&gt;&quot;
2795         &quot;&lt;/UL&gt;&quot;
2796         &quot;&lt;P&gt;&quot;
2797         &quot;The VM Start Event and VM Death Event are automatically generated events. &quot;
2798         &quot;This means they do not need to be requested using the &quot;
2799         &quot;&lt;a href=\&quot;#JDWP_EventRequest_Set\&quot;&gt;EventRequest.Set&lt;/a&gt; command. &quot;
2800         &quot;The VM Start event signals the completion of VM initialization. The VM Death &quot;
2801         &quot;event signals the termination of the VM.&quot;
2802         &quot;If there is a debugger connected at the time when an automatically generated &quot;
2803         &quot;event occurs it is sent from the target VM. Automatically generated events may &quot;
2804         &quot;also be requested using the EventRequest.Set command and thus multiple events &quot;
2805         &quot;of the same event kind will be sent from the target VM when an event occurs.&quot;
2806         &quot;Automatically generated events are sent with the requestID field &quot;
2807         &quot;in the Event Data set to 0. The value of the suspendPolicy field in the &quot;
2808         &quot;Event Data depends on the event. For the automatically generated VM Start &quot;
2809         &quot;Event the value of suspendPolicy is not defined and is therefore implementation &quot;
2810         &quot;or configuration specific. In the Sun implementation, for example, the &quot;
2811         &quot;suspendPolicy is specified as an option to the JDWP agent at launch-time.&quot;
2812         &quot;The automatically generated VM Death Event will have the suspendPolicy set to &quot;
2813         &quot;NONE.&quot;
2814 
2815        (Event &quot;Generated event&quot;
2816             (byte suspendPolicy
2817                 &quot;Which threads where suspended by this composite event?&quot;)
2818             (Repeat events &quot;Events in set.&quot;
2819                 (Select Events
2820                     (byte eventKind &quot;Event kind selector&quot;)
2821                     (Alt VMStart=JDWP.EventKind.VM_START
2822                         &quot;Notification of initialization of a target VM.  This event is &quot;
2823                         &quot;received before the main thread is started and before any &quot;
2824                         &quot;application code has been executed. Before this event occurs &quot;
2825                         &quot;a significant amount of system code has executed and a number &quot;
2826                         &quot;of system classes have been loaded. &quot;
2827                         &quot;This event is always generated by the target VM, even &quot;
2828                         &quot;if not explicitly requested.&quot;
2829 
2830                      (int requestID
2831                              &quot;Request that generated event (or 0 if this &quot;
2832                              &quot;event is automatically generated.&quot;)
2833                         (threadObject thread &quot;Initial thread&quot;)
2834                     )
2835                     (Alt SingleStep=JDWP.EventKind.SINGLE_STEP
2836                         &quot;Notification of step completion in the target VM. The step event &quot;
2837                         &quot;is generated before the code at its location is executed. &quot;
2838 
2839                         (int requestID &quot;Request that generated event&quot;)
2840                         (threadObject thread &quot;Stepped thread&quot;)
2841                         (location location &quot;Location stepped to&quot;)
2842                     )
2843                     (Alt Breakpoint=JDWP.EventKind.BREAKPOINT
2844                         &quot;Notification of a breakpoint in the target VM. The breakpoint event &quot;
2845                         &quot;is generated before the code at its location is executed. &quot;
2846 
2847                         (int requestID &quot;Request that generated event&quot;)
2848                         (threadObject thread &quot;Thread which hit breakpoint&quot;)
2849                         (location location &quot;Location hit&quot;)
2850                     )
2851                     (Alt MethodEntry=JDWP.EventKind.METHOD_ENTRY
2852                          &quot;Notification of a method invocation in the target VM. This event &quot;
2853                          &quot;is generated before any code in the invoked method has executed. &quot;
2854                          &quot;Method entry events are generated for both native and non-native &quot;
2855                          &quot;methods. &quot;
2856                          &quot;&lt;P&gt;&quot;
2857                          &quot;In some VMs method entry events can occur for a particular thread &quot;
2858                          &quot;before its thread start event occurs if methods are called &quot;
2859                          &quot;as part of the thread&#39;s initialization. &quot;
2860 
2861                         (int requestID &quot;Request that generated event&quot;)
2862                         (threadObject thread &quot;Thread which entered method&quot;)
2863                         (location location &quot;The initial executable location in the method.&quot;)
2864                     )
2865                     (Alt MethodExit=JDWP.EventKind.METHOD_EXIT
2866                          &quot;Notification of a method return in the target VM. This event &quot;
2867                          &quot;is generated after all code in the method has executed, but the &quot;
2868                          &quot;location of this event is the last executed location in the method. &quot;
2869                          &quot;Method exit events are generated for both native and non-native &quot;
2870                          &quot;methods. Method exit events are not generated if the method terminates &quot;
2871                          &quot;with a thrown exception. &quot;
2872 
2873                         (int requestID &quot;Request that generated event&quot;)
2874                         (threadObject thread &quot;Thread which exited method&quot;)
2875                         (location location &quot;Location of exit&quot;)
2876                     )
2877                     (Alt MethodExitWithReturnValue=JDWP.EventKind.METHOD_EXIT_WITH_RETURN_VALUE
2878                          &quot;Notification of a method return in the target VM. This event &quot;
2879                          &quot;is generated after all code in the method has executed, but the &quot;
2880                          &quot;location of this event is the last executed location in the method. &quot;
2881                          &quot;Method exit events are generated for both native and non-native &quot;
2882                          &quot;methods. Method exit events are not generated if the method terminates &quot;
2883                          &quot;with a thrown exception. &lt;p&gt;Since JDWP version 1.6. &quot;
2884 
2885                         (int requestID &quot;Request that generated event&quot;)
2886                         (threadObject thread &quot;Thread which exited method&quot;)
2887                         (location location &quot;Location of exit&quot;)
2888                         (value value &quot;Value that will be returned by the method&quot;)
2889                     )
2890                     (Alt MonitorContendedEnter=JDWP.EventKind.MONITOR_CONTENDED_ENTER
2891                          &quot;Notification that a thread in the target VM is attempting &quot;
2892                          &quot;to enter a monitor that is already acquired by another thread. &quot;
2893                          &quot;Requires canRequestMonitorEvents capability - see &quot;
2894                          &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;. &quot;
2895                          &quot;&lt;p&gt;Since JDWP version 1.6. &quot;
2896 
2897                         (int requestID
2898                                 &quot;Request that generated event&quot;)
2899                         (threadObject thread &quot;Thread which is trying to enter the monitor&quot;)
2900                         (tagged-object object &quot;Monitor object reference&quot;)
2901                         (location location &quot;Location of contended monitor enter&quot;)
2902                     )
2903                     (Alt MonitorContendedEntered=JDWP.EventKind.MONITOR_CONTENDED_ENTERED
2904                          &quot;Notification of a thread in the target VM is entering a monitor &quot;
2905                          &quot;after waiting for it to be released by another thread. &quot;
2906                          &quot;Requires canRequestMonitorEvents capability - see &quot;
2907                          &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;. &quot;
2908                          &quot;&lt;p&gt;Since JDWP version 1.6. &quot;
2909 
2910                         (int requestID
2911                                 &quot;Request that generated event&quot;)
2912                         (threadObject thread &quot;Thread which entered monitor&quot;)
2913                         (tagged-object object &quot;Monitor object reference&quot;)
2914                         (location location &quot;Location of contended monitor enter&quot;)
2915                     )
2916                     (Alt MonitorWait=JDWP.EventKind.MONITOR_WAIT
2917                          &quot;Notification of a thread about to wait on a monitor object. &quot;
2918                          &quot;Requires canRequestMonitorEvents capability - see &quot;
2919                          &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;. &quot;
2920                          &quot;&lt;p&gt;Since JDWP version 1.6. &quot;
2921 
2922                         (int requestID
2923                                 &quot;Request that generated event&quot;)
2924                         (threadObject thread &quot;Thread which is about to wait&quot;)
2925                         (tagged-object object &quot;Monitor object reference&quot;)
2926                         (location location &quot;Location at which the wait will occur&quot;)
2927                         (long     timeout  &quot;Thread wait time in milliseconds&quot;)
2928                     )
2929                     (Alt MonitorWaited=JDWP.EventKind.MONITOR_WAITED
2930                          &quot;Notification that a thread in the target VM has finished waiting on &quot;
2931                          &quot;Requires canRequestMonitorEvents capability - see &quot;
2932                          &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;. &quot;
2933                          &quot;a monitor object. &quot;
2934                          &quot;&lt;p&gt;Since JDWP version 1.6. &quot;
2935 
2936                         (int requestID
2937                                 &quot;Request that generated event&quot;)
2938                         (threadObject thread &quot;Thread which waited&quot;)
2939                         (tagged-object object &quot;Monitor object reference&quot;)
2940                         (location location &quot;Location at which the wait occured&quot;)
2941                         (boolean  timed_out &quot;True if timed out&quot;)
2942                     )
2943                     (Alt Exception=JDWP.EventKind.EXCEPTION
2944                          &quot;Notification of an exception in the target VM. &quot;
2945                          &quot;If the exception is thrown from a non-native method, &quot;
2946                          &quot;the exception event is generated at the location where the &quot;
2947                          &quot;exception is thrown. &quot;
2948                          &quot;If the exception is thrown from a native method, the exception event &quot;
2949                          &quot;is generated at the first non-native location reached after the exception &quot;
2950                          &quot;is thrown. &quot;
2951 
2952                         (int requestID &quot;Request that generated event&quot;)
2953                         (threadObject thread &quot;Thread with exception&quot;)
2954                         (location location &quot;Location of exception throw &quot;
2955                         &quot;(or first non-native location after throw if thrown from a native method)&quot;)
2956                         (tagged-object exception &quot;Thrown exception&quot;)
2957                         (location catchLocation
2958                             &quot;Location of catch, or 0 if not caught. An exception &quot;
2959                             &quot;is considered to be caught if, at the point of the throw, the &quot;
2960                             &quot;current location is dynamically enclosed in a try statement that &quot;
2961                             &quot;handles the exception. (See the JVM specification for details). &quot;
2962                             &quot;If there is such a try statement, the catch location is the &quot;
2963                             &quot;first location in the appropriate catch clause. &quot;
2964                             &quot;&lt;p&gt;&quot;
2965                             &quot;If there are native methods in the call stack at the time of the &quot;
2966                             &quot;exception, there are important restrictions to note about the &quot;
2967                             &quot;returned catch location. In such cases, &quot;
2968                             &quot;it is not possible to predict whether an exception will be handled &quot;
2969                             &quot;by some native method on the call stack. &quot;
2970                             &quot;Thus, it is possible that exceptions considered uncaught &quot;
2971                             &quot;here will, in fact, be handled by a native method and not cause &quot;
2972                             &quot;termination of the target VM. Furthermore, it cannot be assumed that the &quot;
2973                             &quot;catch location returned here will ever be reached by the throwing &quot;
2974                             &quot;thread. If there is &quot;
2975                             &quot;a native frame between the current location and the catch location, &quot;
2976                             &quot;the exception might be handled and cleared in that native method &quot;
2977                             &quot;instead. &quot;
2978                             &quot;&lt;p&gt;&quot;
2979                             &quot;Note that compilers can generate try-catch blocks in some cases &quot;
2980                             &quot;where they are not explicit in the source code; for example, &quot;
2981                             &quot;the code generated for &lt;code&gt;synchronized&lt;/code&gt; and &quot;
2982                             &quot;&lt;code&gt;finally&lt;/code&gt; blocks can contain implicit try-catch blocks. &quot;
2983                             &quot;If such an implicitly generated try-catch is &quot;
2984                             &quot;present on the call stack at the time of the throw, the exception &quot;
2985                             &quot;will be considered caught even though it appears to be uncaught from &quot;
2986                             &quot;examination of the source code. &quot;
2987                         )
2988                     )
2989                     (Alt ThreadStart=JDWP.EventKind.THREAD_START
2990                         &quot;Notification of a new running thread in the target VM. &quot;
2991                         &quot;The new thread can be the result of a call to &quot;
2992                         &quot;&lt;code&gt;java.lang.Thread.start&lt;/code&gt; or the result of &quot;
2993                         &quot;attaching a new thread to the VM though JNI. The &quot;
2994                         &quot;notification is generated by the new thread some time before &quot;
2995                         &quot;its execution starts. &quot;
2996                         &quot;Because of this timing, it is possible to receive other events &quot;
2997                         &quot;for the thread before this event is received. (Notably, &quot;
2998                         &quot;Method Entry Events and Method Exit Events might occur &quot;
2999                         &quot;during thread initialization. &quot;
3000                         &quot;It is also possible for the &quot;
3001                         &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_AllThreads\&quot;&gt;VirtualMachine AllThreads&lt;/a&gt; &quot;
3002                         &quot;command to return &quot;
3003                         &quot;a thread before its thread start event is received. &quot;
3004                         &quot;&lt;p&gt;&quot;
3005                         &quot;Note that this event gives no information &quot;
3006                         &quot;about the creation of the thread object which may have happened &quot;
3007                         &quot;much earlier, depending on the VM being debugged. &quot;
3008 
3009                         (int requestID &quot;Request that generated event&quot;)
3010                         (threadObject thread &quot;Started thread&quot;)
3011                     )
3012                     (Alt ThreadDeath=JDWP.EventKind.THREAD_DEATH
3013                         &quot;Notification of a completed thread in the target VM. The &quot;
3014                         &quot;notification is generated by the dying thread before it terminates. &quot;
3015                         &quot;Because of this timing, it is possible &quot;
3016                         &quot;for {@link VirtualMachine#allThreads} to return this thread &quot;
3017                         &quot;after this event is received. &quot;
3018                         &quot;&lt;p&gt;&quot;
3019                         &quot;Note that this event gives no information &quot;
3020                         &quot;about the lifetime of the thread object. It may or may not be collected &quot;
3021                         &quot;soon depending on what references exist in the target VM. &quot;
3022 
3023                         (int requestID &quot;Request that generated event&quot;)
3024                         (threadObject thread &quot;Ending thread&quot;)
3025                     )
3026                     (Alt ClassPrepare=JDWP.EventKind.CLASS_PREPARE
3027                         &quot;Notification of a class prepare in the target VM. See the JVM &quot;
3028                         &quot;specification for a definition of class preparation. Class prepare &quot;
3029                         &quot;events are not generated for primtiive classes (for example, &quot;
3030                         &quot;java.lang.Integer.TYPE). &quot;
3031 
3032                         (int requestID &quot;Request that generated event&quot;)
3033                         (threadObject thread &quot;Preparing thread. &quot;
3034                              &quot;In rare cases, this event may occur in a debugger system &quot;
3035                              &quot;thread within the target VM. Debugger threads take precautions &quot;
3036                              &quot;to prevent these events, but they cannot be avoided under some &quot;
3037                              &quot;conditions, especially for some subclasses of &quot;
3038                              &quot;java.lang.Error. &quot;
3039                              &quot;If the event was generated by a debugger system thread, the &quot;
3040                              &quot;value returned by this method is null, and if the requested  &quot;
3041                              &quot;&lt;a href=\&quot;#JDWP_SuspendPolicy\&quot;&gt;suspend policy&lt;/a&gt; &quot;
3042                              &quot;for the event was EVENT_THREAD &quot;
3043                              &quot;all threads will be suspended instead, and the &quot;
3044                              &quot;composite event&#39;s suspend policy will reflect this change. &quot;
3045                              &quot;&lt;p&gt;&quot;
3046                              &quot;Note that the discussion above does not apply to system threads &quot;
3047                              &quot;created by the target VM during its normal (non-debug) operation. &quot;
3048                         )
3049                         (byte refTypeTag  &quot;Kind of reference type. &quot;
3050                            &quot;See &lt;a href=\&quot;#JDWP_TypeTag\&quot;&gt;JDWP.TypeTag&lt;/a&gt;&quot;)
3051                         (referenceTypeID typeID &quot;Type being prepared&quot;)
3052                         (string signature &quot;Type signature&quot;)
3053                         (int status &quot;Status of type. &quot;
3054                          &quot;See &lt;a href=\&quot;#JDWP_ClassStatus\&quot;&gt;JDWP.ClassStatus&lt;/a&gt;&quot;)
3055                     )
3056                     (Alt ClassUnload=JDWP.EventKind.CLASS_UNLOAD
3057                          &quot;Notification of a class unload in the target VM. &quot;
3058                          &quot;&lt;p&gt;&quot;
3059                          &quot;There are severe constraints on the debugger back-end during &quot;
3060                          &quot;garbage collection, so unload information is greatly limited. &quot;
3061 
3062                         (int requestID &quot;Request that generated event&quot;)
3063                         (string signature &quot;Type signature&quot;)
3064                     )
3065                     (Alt FieldAccess=JDWP.EventKind.FIELD_ACCESS
3066                         &quot;Notification of a field access in the target VM. &quot;
3067                         &quot;Field modifications &quot;
3068                         &quot;are not considered field accesses. &quot;
3069                         &quot;Requires canWatchFieldAccess capability - see &quot;
3070                         &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;.&quot;
3071 
3072                       (int requestID &quot;Request that generated event&quot;)
3073                         (threadObject thread &quot;Accessing thread&quot;)
3074                         (location location &quot;Location of access&quot;)
3075                         (byte refTypeTag  &quot;Kind of reference type. &quot;
3076                            &quot;See &lt;a href=\&quot;#JDWP_TypeTag\&quot;&gt;JDWP.TypeTag&lt;/a&gt;&quot;)
3077                         (referenceTypeID typeID &quot;Type of field&quot;)
3078                         (field fieldID &quot;Field being accessed&quot;)
3079                         (tagged-object object
3080                                 &quot;Object being accessed (null=0 for statics&quot;)
3081                     )
3082                     (Alt FieldModification=JDWP.EventKind.FIELD_MODIFICATION
3083                         &quot;Notification of a field modification in the target VM. &quot;
3084                         &quot;Requires canWatchFieldModification capability - see &quot;
3085                         &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;.&quot;
3086 
3087                         (int requestID &quot;Request that generated event&quot;)
3088                         (threadObject thread &quot;Modifying thread&quot;)
3089                         (location location &quot;Location of modify&quot;)
3090                         (byte refTypeTag  &quot;Kind of reference type. &quot;
3091                            &quot;See &lt;a href=\&quot;#JDWP_TypeTag\&quot;&gt;JDWP.TypeTag&lt;/a&gt;&quot;)
3092                         (referenceTypeID typeID &quot;Type of field&quot;)
3093                         (field fieldID &quot;Field being modified&quot;)
3094                         (tagged-object object
3095                                 &quot;Object being modified (null=0 for statics&quot;)
3096                         (value valueToBe &quot;Value to be assigned&quot;)
3097                     )
3098                     (Alt VMDeath=JDWP.EventKind.VM_DEATH
3099                         (int requestID
3100                                 &quot;Request that generated event&quot;)
3101                     )
3102                 )
3103             )
3104         )
3105     )
3106 )
3107 (ConstantSet Error
3108     (Constant NONE                   =0   &quot;No error has occurred.&quot;)
3109     (Constant INVALID_THREAD         =10  &quot;Passed thread is null, is not a valid thread or has exited.&quot;)
3110     (Constant INVALID_THREAD_GROUP   =11  &quot;Thread group invalid.&quot;)
3111     (Constant INVALID_PRIORITY       =12  &quot;Invalid priority.&quot;)
3112     (Constant THREAD_NOT_SUSPENDED   =13  &quot;If the specified thread has not been &quot;
3113                                           &quot;suspended by an event.&quot;)
3114     (Constant THREAD_SUSPENDED       =14  &quot;Thread already suspended.&quot;)
3115     (Constant THREAD_NOT_ALIVE       =15  &quot;Thread has not been started or is now dead.&quot;)
3116 
3117     (Constant INVALID_OBJECT         =20  &quot;If this reference type has been unloaded &quot;
3118                                           &quot;and garbage collected.&quot;)
3119     (Constant INVALID_CLASS          =21  &quot;Invalid class.&quot;)
3120     (Constant CLASS_NOT_PREPARED     =22  &quot;Class has been loaded but not yet prepared.&quot;)
3121     (Constant INVALID_METHODID       =23  &quot;Invalid method.&quot;)
3122     (Constant INVALID_LOCATION       =24  &quot;Invalid location.&quot;)
3123     (Constant INVALID_FIELDID        =25  &quot;Invalid field.&quot;)
3124     (Constant INVALID_FRAMEID        =30  &quot;Invalid jframeID.&quot;)
3125     (Constant NO_MORE_FRAMES         =31  &quot;There are no more Java or JNI frames on the &quot;
3126                                           &quot;call stack.&quot;)
3127     (Constant OPAQUE_FRAME           =32  &quot;Information about the frame is not available.&quot;)
3128     (Constant NOT_CURRENT_FRAME      =33  &quot;Operation can only be performed on current frame.&quot;)
3129     (Constant TYPE_MISMATCH          =34  &quot;The variable is not an appropriate type for &quot;
3130                                           &quot;the function used.&quot;)
3131     (Constant INVALID_SLOT           =35  &quot;Invalid slot.&quot;)
3132     (Constant DUPLICATE              =40  &quot;Item already set.&quot;)
3133     (Constant NOT_FOUND              =41  &quot;Desired element not found.&quot;)
3134     (Constant INVALID_MODULE         =42  &quot;Invalid module.&quot;)
3135     (Constant INVALID_MONITOR        =50  &quot;Invalid monitor.&quot;)
3136     (Constant NOT_MONITOR_OWNER      =51  &quot;This thread doesn&#39;t own the monitor.&quot;)
3137     (Constant INTERRUPT              =52  &quot;The call has been interrupted before completion.&quot;)
3138     (Constant INVALID_CLASS_FORMAT   =60  &quot;The virtual machine attempted to read a class &quot;
3139                                           &quot;file and determined that the file is malformed &quot;
3140                                           &quot;or otherwise cannot be interpreted as a class file.&quot;)
3141     (Constant CIRCULAR_CLASS_DEFINITION
3142                                      =61  &quot;A circularity has been detected while &quot;
3143                                           &quot;initializing a class.&quot;)
3144     (Constant FAILS_VERIFICATION     =62  &quot;The verifier detected that a class file, &quot;
3145                                           &quot;though well formed, contained some sort of &quot;
3146                                           &quot;internal inconsistency or security problem.&quot;)
3147     (Constant ADD_METHOD_NOT_IMPLEMENTED
3148                                      =63  &quot;Adding methods has not been implemented.&quot;)
3149     (Constant SCHEMA_CHANGE_NOT_IMPLEMENTED
3150                                      =64  &quot;Schema change has not been implemented.&quot;)
3151     (Constant INVALID_TYPESTATE      =65  &quot;The state of the thread has been modified, &quot;
3152                                           &quot;and is now inconsistent.&quot;)
3153     (Constant HIERARCHY_CHANGE_NOT_IMPLEMENTED
3154                                      =66  &quot;A direct superclass is different for the new class &quot;
3155                                           &quot;version, or the set of directly implemented &quot;
3156                                           &quot;interfaces is different &quot;
3157                                           &quot;and canUnrestrictedlyRedefineClasses is false.&quot;)
3158     (Constant DELETE_METHOD_NOT_IMPLEMENTED
3159                                      =67  &quot;The new class version does not declare a method &quot;
3160                                           &quot;declared in the old class version &quot;
3161                                           &quot;and canUnrestrictedlyRedefineClasses is false.&quot;)
3162     (Constant UNSUPPORTED_VERSION    =68  &quot;A class file has a version number not supported &quot;
3163                                           &quot;by this VM.&quot;)
3164     (Constant NAMES_DONT_MATCH       =69  &quot;The class name defined in the new class file is &quot;
3165                                           &quot;different from the name in the old class object.&quot;)
3166     (Constant CLASS_MODIFIERS_CHANGE_NOT_IMPLEMENTED
3167                                      =70  &quot;The new class version has different modifiers and &quot;
3168                                           &quot;canUnrestrictedlyRedefineClasses is false.&quot;)
3169     (Constant METHOD_MODIFIERS_CHANGE_NOT_IMPLEMENTED
3170                                      =71  &quot;A method in the new class version has &quot;
3171                                           &quot;different modifiers &quot;
3172                                           &quot;than its counterpart in the old class version and &quot;
3173                                           &quot;canUnrestrictedlyRedefineClasses is false.&quot;)
3174     (Constant CLASS_ATTRIBUTE_CHANGE_NOT_IMPLEMENTED
3175                                      =72  &quot;The new class version has a different NestHost, &quot;
<a name="3" id="anc3"></a><span class="line-modified">3176                                           &quot;NestMembers, PermittedSubclasses, or Record class attribute &quot;</span>
<span class="line-modified">3177                                           &quot;and canUnrestrictedlyRedefineClasses is false.&quot;)</span>
3178     (Constant NOT_IMPLEMENTED        =99  &quot;The functionality is not implemented in &quot;
3179                                           &quot;this virtual machine.&quot;)
3180     (Constant NULL_POINTER           =100 &quot;Invalid pointer.&quot;)
3181     (Constant ABSENT_INFORMATION     =101 &quot;Desired information is not available.&quot;)
3182     (Constant INVALID_EVENT_TYPE     =102 &quot;The specified event type id is not recognized.&quot;)
3183     (Constant ILLEGAL_ARGUMENT       =103 &quot;Illegal argument.&quot;)
3184     (Constant OUT_OF_MEMORY          =110 &quot;The function needed to allocate memory and &quot;
3185                                           &quot;no more memory was available for allocation.&quot;)
3186     (Constant ACCESS_DENIED          =111 &quot;Debugging has not been enabled in this &quot;
3187                                           &quot;virtual machine. JVMTI cannot be used.&quot;)
3188     (Constant VM_DEAD                =112 &quot;The virtual machine is not running.&quot;)
3189     (Constant INTERNAL               =113 &quot;An unexpected internal error has occurred.&quot;)
3190     (Constant UNATTACHED_THREAD      =115 &quot;The thread being used to call this function &quot;
3191                                           &quot;is not attached to the virtual machine. &quot;
3192                                           &quot;Calls must be made from attached threads.&quot;)
3193     (Constant INVALID_TAG            =500 &quot;object type id or class tag.&quot;)
3194     (Constant ALREADY_INVOKING       =502 &quot;Previous invoke not complete.&quot;)
3195     (Constant INVALID_INDEX          =503 &quot;Index is invalid.&quot;)
3196     (Constant INVALID_LENGTH         =504 &quot;The length is invalid.&quot;)
3197     (Constant INVALID_STRING         =506 &quot;The string is invalid.&quot;)
3198     (Constant INVALID_CLASS_LOADER   =507 &quot;The class loader is invalid.&quot;)
3199     (Constant INVALID_ARRAY          =508 &quot;The array is invalid.&quot;)
3200     (Constant TRANSPORT_LOAD         =509 &quot;Unable to load the transport.&quot;)
3201     (Constant TRANSPORT_INIT         =510 &quot;Unable to initialize the transport.&quot;)
3202     (Constant NATIVE_METHOD          =511  )
3203     (Constant INVALID_COUNT          =512 &quot;The count is invalid.&quot;)
3204 )
3205 (ConstantSet EventKind
3206     (Constant SINGLE_STEP            =1   )
3207     (Constant BREAKPOINT             =2   )
3208     (Constant FRAME_POP              =3   )
3209     (Constant EXCEPTION              =4   )
3210     (Constant USER_DEFINED           =5   )
3211     (Constant THREAD_START           =6   )
3212     (Constant THREAD_DEATH           =7   )
3213     (Constant THREAD_END             =7   &quot;obsolete - was used in jvmdi&quot;)
3214     (Constant CLASS_PREPARE          =8   )
3215     (Constant CLASS_UNLOAD           =9   )
3216     (Constant CLASS_LOAD             =10  )
3217     (Constant FIELD_ACCESS           =20  )
3218     (Constant FIELD_MODIFICATION     =21  )
3219     (Constant EXCEPTION_CATCH        =30  )
3220     (Constant METHOD_ENTRY           =40  )
3221     (Constant METHOD_EXIT            =41  )
3222     (Constant METHOD_EXIT_WITH_RETURN_VALUE =42  )
3223     (Constant MONITOR_CONTENDED_ENTER          =43  )
3224     (Constant MONITOR_CONTENDED_ENTERED        =44 )
3225     (Constant MONITOR_WAIT           =45 )
3226     (Constant MONITOR_WAITED         =46 )
3227     (Constant VM_START               =90  )
3228     (Constant VM_INIT                =90  &quot;obsolete - was used in jvmdi&quot;)
3229     (Constant VM_DEATH               =99  )
3230     (Constant VM_DISCONNECTED        =100 &quot;Never sent across JDWP&quot;)
3231 )
3232 
3233 (ConstantSet ThreadStatus
3234     (Constant ZOMBIE                 =0  )
3235     (Constant RUNNING                =1  )
3236     (Constant SLEEPING               =2  )
3237     (Constant MONITOR                =3  )
3238     (Constant WAIT                   =4  )
3239 )
3240 
3241 (ConstantSet SuspendStatus
3242     (Constant SUSPEND_STATUS_SUSPENDED = 0x1 )
3243 )
3244 (ConstantSet ClassStatus
3245     (Constant VERIFIED               =1  )
3246     (Constant PREPARED               =2  )
3247     (Constant INITIALIZED            =4  )
3248     (Constant ERROR                  =8  )
3249 )
3250 (ConstantSet TypeTag
3251     (Constant CLASS=1 &quot;ReferenceType is a class. &quot;)
3252     (Constant INTERFACE=2 &quot;ReferenceType is an interface. &quot;)
3253     (Constant ARRAY=3 &quot;ReferenceType is an array. &quot;)
3254 )
3255 (ConstantSet Tag
3256     (Constant ARRAY = &#39;[&#39; &quot;&#39;[&#39; - an array object (objectID size). &quot;)
3257     (Constant BYTE = &#39;B&#39; &quot;&#39;B&#39; - a byte value (1 byte).&quot;)
3258     (Constant CHAR = &#39;C&#39; &quot;&#39;C&#39; - a character value (2 bytes).&quot;)
3259     (Constant OBJECT = &#39;L&#39; &quot;&#39;L&#39; - an object (objectID size).&quot;)
3260     (Constant FLOAT = &#39;F&#39; &quot;&#39;F&#39; - a float value (4 bytes).&quot;)
3261     (Constant DOUBLE = &#39;D&#39; &quot;&#39;D&#39; - a double value (8 bytes).&quot;)
3262     (Constant INT = &#39;I&#39; &quot;&#39;I&#39; - an int value (4 bytes).&quot;)
3263     (Constant LONG = &#39;J&#39; &quot;&#39;J&#39; - a long value (8 bytes).&quot;)
3264     (Constant SHORT = &#39;S&#39; &quot;&#39;S&#39; - a short value (2 bytes).&quot;)
3265     (Constant VOID = &#39;V&#39; &quot;&#39;V&#39; - a void value (no bytes).&quot;)
3266     (Constant BOOLEAN = &#39;Z&#39; &quot;&#39;Z&#39; - a boolean value (1 byte).&quot;)
3267     (Constant STRING = &#39;s&#39; &quot;&#39;s&#39; - a String object (objectID size). &quot;)
3268     (Constant THREAD = &#39;t&#39; &quot;&#39;t&#39; - a Thread object (objectID size). &quot;)
3269     (Constant THREAD_GROUP = &#39;g&#39;
3270         &quot;&#39;g&#39; - a ThreadGroup object (objectID size). &quot;)
3271     (Constant CLASS_LOADER = &#39;l&#39;
3272         &quot;&#39;l&#39; - a ClassLoader object (objectID size). &quot;)
3273     (Constant CLASS_OBJECT = &#39;c&#39;
3274         &quot;&#39;c&#39; - a class object object (objectID size). &quot;)
3275 )
3276 
3277 (ConstantSet StepDepth
3278     (Constant INTO = 0
3279         &quot;Step into any method calls that occur before the end of the step. &quot;)
3280     (Constant OVER = 1
3281         &quot;Step over any method calls that occur before the end of the step. &quot;)
3282     (Constant OUT = 2
3283         &quot;Step out of the current method. &quot;)
3284 )
3285 
3286 (ConstantSet StepSize
3287     (Constant MIN = 0
3288         &quot;Step by the minimum possible amount (often a bytecode instruction). &quot;)
3289     (Constant LINE = 1
3290         &quot;Step to the next source line unless there is no line number information in which case a MIN step is done instead.&quot;)
3291 )
3292 
3293 (ConstantSet SuspendPolicy
3294     (Constant NONE = 0
3295         &quot;Suspend no threads when this event is encountered. &quot;)
3296     (Constant EVENT_THREAD = 1
3297         &quot;Suspend the event thread when this event is encountered. &quot;)
3298     (Constant ALL = 2
3299         &quot;Suspend all threads when this event is encountered. &quot;)
3300 )
3301 
3302 (ConstantSet InvokeOptions
3303     &quot;The invoke options are a combination of zero or more of the following bit flags:&quot;
3304     (Constant INVOKE_SINGLE_THREADED = 0x01
3305         &quot;otherwise, all threads started. &quot;)
3306     (Constant INVOKE_NONVIRTUAL = 0x02
3307         &quot;otherwise, normal virtual invoke (instance methods only)&quot;)
3308 )
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/jdk/nio/zipfs/testng/util/ZipFsBaseTest.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 package util;
 25 
 26 import org.testng.annotations.DataProvider;
 27 
 28 import java.io.File;
 29 import java.io.IOException;
 30 import java.io.InputStream;
 31 import java.nio.charset.StandardCharsets;
 32 import java.nio.file.FileSystem;
 33 import java.nio.file.FileSystems;
 34 import java.nio.file.Files;
 35 import java.nio.file.Path;
 36 import java.security.SecureRandom;
 37 import java.util.Arrays;
 38 import java.util.Comparator;
 39 import java.util.Map;
 40 import java.util.stream.Stream;
 41 import java.util.zip.ZipEntry;
 42 import java.util.zip.ZipFile;
 43 
 44 import static java.lang.String.format;
 45 import static java.util.stream.Collectors.joining;
 46 import static org.testng.Assert.*;
 47 
 48 public class ZipFsBaseTest {
 49 
 50     protected static final Path HERE = Path.of(&quot;.&quot;);
 51     // Enable for permissions output
 52     protected static final boolean DEBUG = false;
 53     private static final SecureRandom random = new SecureRandom();
 54 
 55     /**
 56      * DataProvider used to specify the Zip FS properties to use when creating
 57      * the Zip File along with the compression method used
 58      *
 59      * @return Zip FS properties and compression method used by the tests
 60      */
 61     @DataProvider(name = &quot;zipfsMap&quot;)
 62     protected Object[][] zipfsMap() {
 63         return new Object[][]{
 64                 {Map.of(&quot;create&quot;, &quot;true&quot;), ZipEntry.DEFLATED},
 65                 {Map.of(&quot;create&quot;, &quot;true&quot;, &quot;noCompression&quot;, &quot;true&quot;),
 66                         ZipEntry.STORED},
 67                 {Map.of(&quot;create&quot;, &quot;true&quot;, &quot;noCompression&quot;, &quot;false&quot;),
 68                         ZipEntry.DEFLATED}
 69         };
 70     }
 71 
 72     /*
 73      * DataProvider used to verify that an entry can be copied or moved within
 74      * a Zip file system using a different compression from when the entry
 75      * was first created
 76      */
 77     @DataProvider(name = &quot;copyMoveMap&quot;)
 78     protected Object[][] copyMoveMap() {
 79         return new Object[][]{
 80                 {Map.of(&quot;create&quot;, &quot;true&quot;), ZipEntry.DEFLATED, ZipEntry.STORED},
 81                 {Map.of(&quot;create&quot;, &quot;true&quot;, &quot;noCompression&quot;, &quot;true&quot;),
 82                         ZipEntry.STORED, ZipEntry.DEFLATED},
 83                 {Map.of(&quot;create&quot;, &quot;true&quot;, &quot;noCompression&quot;, &quot;false&quot;),
 84                         ZipEntry.DEFLATED, ZipEntry.STORED}
 85         };
 86     }
 87 
 88     /**
 89      * DataProvider with the compression methods to be used for a given test run
 90      *
 91      * @return Compression methods to test with
 92      */
 93     @DataProvider(name = &quot;compressionMethods&quot;)
 94     protected Object[][] compressionMethods() {
 95         return new Object[][]{
 96                 {ZipEntry.DEFLATED},
 97                 {ZipEntry.STORED}
 98         };
 99     }
100 
101     /**
102      * Utility method to return a formatted String of the key:value entries for
103      * a Map
104      *
105      * @param env Map to format
106      * @return Formatted string of the Map entries
107      */
108     private static String formatMap(Map&lt;String, ?&gt; env) {
109         return env.entrySet().stream()
110                 .map(e -&gt; format(&quot;(%s:%s)&quot;, e.getKey(), e.getValue()))
111                 .collect(joining(&quot;, &quot;));
112     }
113 
114     /**
115      * Generate a temporary file Path
116      *
117      * @param dir    Directory used to create the path
118      * @param prefix The prefix string used to create the path
119      * @param suffix The suffix string used to create the path
120      * @return Path that was generated
121      */
122     protected static Path generatePath(Path dir, String prefix, String suffix) {
123         long n = random.nextLong();
124         String s = prefix + Long.toUnsignedString(n) + suffix;
125         Path name = dir.getFileSystem().getPath(s);
126         // the generated name should be a simple file name
127         if (name.getParent() != null)
128             throw new IllegalArgumentException(&quot;Invalid prefix or suffix&quot;);
129         return dir.resolve(name);
130     }
131 
132     /**
133      * Verify that the given path is a Zip file containing exactly the
134      * given entries.
135      */
136     protected static void verify(Path zipfile, Entry... entries) throws IOException {
137         // check entries with Zip API
138         try (ZipFile zf = new ZipFile(zipfile.toFile())) {
139             // check entry count
140             assertEquals(entries.length, zf.size());
141 
142             // Check compression method and content of each entry
143             for (Entry e : entries) {
144                 ZipEntry ze = zf.getEntry(e.name);
145                 assertNotNull(ze);
146                 if (DEBUG) {
147                     System.out.printf(&quot;Entry Name: %s, method: %s, Expected Method: %s%n&quot;,
148                             e.name, ze.getMethod(), e.method);
149                 }
150                 assertEquals(e.method, ze.getMethod());
151                 try (InputStream in = zf.getInputStream(ze)) {
152                     byte[] bytes = in.readAllBytes();
153                     if (DEBUG) {
154                         System.out.printf(&quot;bytes= %s, actual=%s%n&quot;,
155                                 new String(bytes), new String(e.bytes));
156                     }
157 
158                     assertTrue(Arrays.equals(bytes, e.bytes));
159                 }
160             }
161         }
162 
163         // Check entries with FileSystem API
164         try (FileSystem fs = FileSystems.newFileSystem(zipfile)) {
165             // cCheck entry count
166             Path top = fs.getPath(&quot;/&quot;);
167             long count = Files.find(top, Integer.MAX_VALUE,
168                     (path, attrs) -&gt; attrs.isRegularFile()).count();
169             assertEquals(entries.length, count);
170 
171             // Check content of each entry
172             for (Entry e : entries) {
173                 Path file = fs.getPath(e.name);
174                 if (DEBUG) {
175                     System.out.printf(&quot;Entry name = %s, bytes= %s, actual=%s%n&quot;, e.name,
176                             new String(Files.readAllBytes(file)), new String(e.bytes));
177                 }
178                 assertEquals(Files.readAllBytes(file), e.bytes);
179             }
180         }
181     }
182 
183     /**
184      * Create a Zip File System using the specified properties and a Zip file
185      * with the specified number of entries
186      *
187      * @param zipFile Path to the Zip File to create/update
188      * @param env     Properties used for creating the Zip Filesystem
189      * @param source  The path of the file to add to the Zip File
190      * @throws IOException If an error occurs while creating/updating the Zip file
191      */
192     protected void zip(Path zipFile, Map&lt;String, String&gt; env, Path source) throws IOException {
193         if (DEBUG) {
194             System.out.printf(&quot;File:%s, adding:%s%n&quot;, zipFile.toAbsolutePath(), source);
195         }
196         try (FileSystem zipfs =
197                      FileSystems.newFileSystem(zipFile, env)) {
198             Files.copy(source, zipfs.getPath(source.getFileName().toString()));
199         }
200     }
201 
202     /**
203      * Create a Zip File System using the specified properties and a Zip file
204      * with the specified number of entries
205      *
206      * @param zipFile Path to the Zip File to create
207      * @param env     Properties used for creating the Zip Filesystem
208      * @param entries The entries to add to the Zip File
209      * @throws IOException If an error occurs while creating the Zip file
210      */
211     protected void zip(Path zipFile, Map&lt;String, ?&gt; env,
212                     Entry... entries) throws IOException {
213         if (DEBUG) {
214             System.out.printf(&quot;Creating file: %s, env: %s%n&quot;, zipFile, formatMap(env));
215         }
216         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env)) {
217             for (Entry e : entries) {
218                 Path path = zipfs.getPath(e.name);
219                 if (path.getParent() != null) {
220                     Files.createDirectories(path.getParent());
221                 }
222                 Files.write(path, e.bytes);
223             }
224         }
225     }
226 
227     /**
228      * Recursively remove a Directory
229      *
230      * @param dir Directory to delete
231      * @throws IOException If an error occurs
232      */
233     protected static void rmdir(Path dir) throws IOException {
234         // Nothing to do if the the file does not exist
235         if (!Files.exists(dir)) {
236             return;
237         }
238         try (Stream&lt;Path&gt; walk = Files.walk(dir)) {
239             walk.sorted(Comparator.reverseOrder())
240                     .map(Path::toFile)
241                     .peek(System.out::println)
242                     .forEach(File::delete);
243         }
244     }
245 
246     /**
247      * Represents an entry in a Zip file. An entry encapsulates a name, a
248      * compression method, and its contents/data.
249      */
250     public static class Entry {
251         public final String name;
252         public final int method;
253         public final byte[] bytes;
254 
255         public Entry(String name, int method, String contents) {
256             this.name = name;
257             this.method = method;
258             this.bytes = contents.getBytes(StandardCharsets.UTF_8);
259         }
260 
261         public static Entry of(String name, int method, String contents) {
262             return new Entry(name, method, contents);
263         }
264 
265         /**
266          * Returns a new Entry with the same name and compression method as this
267          * Entry but with the given content.
268          */
269         public Entry content(String contents) {
270             return new Entry(name, method, contents);
271         }
272     }
273 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/langtools/tools/javac/parser/StringFoldingPosTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2020, Google LLC. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 8134007 8035787
 27  * @summary folded string literals should have correct start and end positions
 28  */
 29 
 30 import com.sun.source.tree.CompilationUnitTree;
 31 import com.sun.source.tree.LiteralTree;
 32 import com.sun.source.tree.Tree;
 33 import com.sun.source.util.JavacTask;
 34 import com.sun.source.util.SourcePositions;
 35 import com.sun.source.util.TreeScanner;
 36 import com.sun.source.util.Trees;
 37 
 38 import java.io.IOException;
 39 import java.net.URI;
 40 import java.util.Arrays;
 41 
 42 import javax.tools.JavaCompiler;
 43 import javax.tools.JavaFileObject;
 44 import javax.tools.SimpleJavaFileObject;
 45 import javax.tools.ToolProvider;
 46 
 47 public class StringFoldingPosTest {
 48     private final JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
 49 
 50     public static void main(String[] args) throws IOException {
 51         StringFoldingPosTest t = new StringFoldingPosTest();
 52         JavaFileObject source =
 53                 t.makeSource(
 54                         &quot;C&quot;, &quot;class C {String X=\&quot;F\&quot; + \&quot;O\&quot; + \&quot;L\&quot; + \&quot;D\&quot; + \&quot;E\&quot; + \&quot;D\&quot;;}&quot;);
 55         t.run(source, &quot;FOLDED&quot;, 18, 51);
 56         source =
 57                 t.makeSource(
 58                         &quot;C&quot;,
 59                         &quot;class C {String X=(\&quot;F\&quot; + \&quot;O\&quot;) + (\&quot;L\&quot; + \&quot;D\&quot;) + (\&quot;E\&quot; + \&quot;D\&quot;);}&quot;);
 60         t.run(source, &quot;FO&quot;, 19, 28);
 61         t.run(source, &quot;LD&quot;, 33, 42);
 62         t.run(source, &quot;ED&quot;, 47, 56);
 63     }
 64 
 65     private static JavaFileObject makeSource(String name, String code) {
 66         return new SimpleJavaFileObject(
 67                 URI.create(
 68                         &quot;file:/&quot; + name.replace(&#39;.&#39;, &#39;/&#39;) + JavaFileObject.Kind.SOURCE.extension),
 69                 JavaFileObject.Kind.SOURCE) {
 70             @Override
 71             public CharSequence getCharContent(boolean ignoreEncodingErrors) {
 72                 return code;
 73             }
 74         };
 75     }
 76 
 77     private void run(
 78             JavaFileObject source,
 79             String expectedLiteral,
 80             long expectedStartPos,
 81             long expectedEndPos)
 82             throws IOException {
 83         JavacTask ct =
 84                 (JavacTask) compiler.getTask(null, null, null, null, null, Arrays.asList(source));
 85         SourcePositions positions = Trees.instance(ct).getSourcePositions();
 86         Iterable&lt;? extends CompilationUnitTree&gt; trees = ct.parse();
 87         boolean[] found = {false};
 88         for (CompilationUnitTree tree : trees) {
 89             new TreeScanner&lt;Void, Void&gt;() {
 90                 @Override
 91                 public Void visitLiteral(LiteralTree literal, Void v) {
 92                     if (literal.getKind() == Tree.Kind.STRING_LITERAL
 93                             &amp;&amp; literal.getValue().equals(expectedLiteral)) {
 94                         long startPos = positions.getStartPosition(tree, literal);
 95                         long endPos = positions.getEndPosition(tree, literal);
 96                         if (startPos != expectedStartPos) {
 97                             throw new AssertionError(
 98                                     &quot;Expected start position &quot;
 99                                             + expectedStartPos
100                                             + &quot;, but was &quot;
101                                             + startPos);
102                         }
103                         if (endPos != expectedEndPos) {
104                             throw new AssertionError(
105                                     &quot;Expected end position &quot;
106                                             + expectedEndPos
107                                             + &quot;, but was &quot;
108                                             + endPos);
109                         }
110                         found[0] = true;
111                     }
112                     return null;
113                 }
114             }.scan(trees, null);
115         }
116         if (found[0]) {
117             return;
118         }
119         throw new AssertionError(&quot;Expected string literal &quot; + expectedLiteral + &quot; not found&quot;);
120     }
121 }
    </pre>
  </body>
</html>
diff a/make/jdk/src/classes/build/tools/generatelsrequivmaps/EquivMapsGenerator.java b/make/jdk/src/classes/build/tools/generatelsrequivmaps/EquivMapsGenerator.java
--- a/make/jdk/src/classes/build/tools/generatelsrequivmaps/EquivMapsGenerator.java
+++ b/make/jdk/src/classes/build/tools/generatelsrequivmaps/EquivMapsGenerator.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2012, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -31,14 +31,16 @@
 import java.nio.file.Files;
 import java.nio.file.Paths;
 import java.time.ZoneId;
 import java.time.ZonedDateTime;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
 import java.util.TreeMap;
+import java.util.stream.Collectors;
 
 /**
  * This tool reads the IANA Language Subtag Registry data file downloaded from
  * http://www.iana.org/assignments/language-subtag-registry, which is specified
  * in the command line and generates a .java source file as specified in
@@ -73,36 +75,53 @@
 
     private static void readLSRfile(String filename) throws Exception {
         String type = null;
         String tag = null;
         String preferred = null;
+        String prefix = null;
 
         for (String line : Files.readAllLines(Paths.get(filename),
                                               Charset.forName("UTF-8"))) {
             line = line.toLowerCase(Locale.ROOT);
-            int index = line.indexOf(' ')+1;
+            int index = line.indexOf(' ') + 1;
             if (line.startsWith("file-date:")) {
                 LSRrevisionDate = line.substring(index);
             } else if (line.startsWith("type:")) {
                 type = line.substring(index);
             } else if (line.startsWith("tag:") || line.startsWith("subtag:")) {
                 tag = line.substring(index);
-            } else if (line.startsWith("preferred-value:")
-                       && !type.equals("extlang")) {
+            } else if (line.startsWith("preferred-value:")) {
                 preferred = line.substring(index);
-                processDeprecatedData(type, tag, preferred);
+            } else if (line.startsWith("prefix:")) {
+                prefix = line.substring(index);
             } else if (line.equals("%%")) {
+                processDeprecatedData(type, tag, preferred, prefix);
                 type = null;
                 tag = null;
+                preferred = null;
+                prefix = null;
             }
         }
+
+        // Last entry
+        processDeprecatedData(type, tag, preferred, prefix);
     }
 
     private static void processDeprecatedData(String type,
                                               String tag,
-                                              String preferred) {
+                                              String preferred,
+                                              String prefix) {
         StringBuilder sb;
+
+        if (type == null || tag == null || preferred == null) {
+            return;
+        }
+
+        if (type.equals("extlang") && prefix != null) {
+            tag = prefix + "-" + tag;
+        }
+
         if (type.equals("region") || type.equals("variant")) {
             if (!initialRegionVariantMap.containsKey(preferred)) {
                 sb = new StringBuilder("-");
                 sb.append(preferred);
                 sb.append(",-");
@@ -111,11 +130,11 @@
             } else {
                 throw new RuntimeException("New case, need implementation."
                     + " A region/variant subtag \"" + preferred
                     + "\" is registered for more than one subtags.");
             }
-        } else { // language, grandfahered, and redundant
+        } else { // language, extlang, grandfathered, and redundant
             if (!initialLanguageMap.containsKey(preferred)) {
                 sb = new StringBuilder(preferred);
                 sb.append(',');
                 sb.append(tag);
                 initialLanguageMap.put(preferred, sb);
@@ -129,11 +148,16 @@
     }
 
     private static void generateEquivalentMap() {
         String[] subtags;
         for (String preferred : initialLanguageMap.keySet()) {
-            subtags = initialLanguageMap.get(preferred).toString().split(",");
+            // There are cases where the same tag may appear in two entries, e.g.,
+            // "yue" is defined both as extlang and redundant. Remove the dup.
+            subtags = Arrays.stream(initialLanguageMap.get(preferred).toString().split(","))
+                    .distinct()
+                    .collect(Collectors.toList())
+                    .toArray(new String[0]);
 
             if (subtags.length == 2) {
                 sortedLanguageMap1.put(subtags[0], subtags[1]);
                 sortedLanguageMap1.put(subtags[1], subtags[0]);
             } else if (subtags.length > 2) {
@@ -213,14 +237,11 @@
         + "final class LocaleEquivalentMaps {\n\n"
         + "    static final Map<String, String> singleEquivMap;\n"
         + "    static final Map<String, String[]> multiEquivsMap;\n"
         + "    static final Map<String, String> regionVariantEquivMap;\n\n"
         + "    static {\n"
-        + "        singleEquivMap = new HashMap<>();\n"
-        + "        multiEquivsMap = new HashMap<>();\n"
-        + "        regionVariantEquivMap = new HashMap<>();\n\n"
-        + "        // This is an auto-generated file and should not be manually edited.\n";
+        + "        singleEquivMap = new HashMap<>(";
 
     private static final String footerText =
         "    }\n\n"
         + "}";
 
@@ -240,10 +261,16 @@
 
         try (BufferedWriter writer = Files.newBufferedWriter(
                 Paths.get(fileName))) {
             writer.write(getOpenJDKCopyright());
             writer.write(headerText
+                + (int)(sortedLanguageMap1.size() / 0.75f + 1) + ");\n"
+                + "        multiEquivsMap = new HashMap<>("
+                + (int)(sortedLanguageMap2.size() / 0.75f + 1) + ");\n"
+                + "        regionVariantEquivMap = new HashMap<>("
+                + (int)(sortedRegionVariantMap.size() / 0.75f + 1) + ");\n\n"
+                + "        // This is an auto-generated file and should not be manually edited.\n"
                 + "        //   LSR Revision: " + LSRrevisionDate);
             writer.newLine();
 
             for (String key : sortedLanguageMap1.keySet()) {
                 String value = sortedLanguageMap1.get(key);

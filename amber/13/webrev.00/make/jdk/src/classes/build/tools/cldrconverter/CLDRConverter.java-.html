<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old make/jdk/src/classes/build/tools/cldrconverter/CLDRConverter.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package build.tools.cldrconverter;
  27 
  28 import build.tools.cldrconverter.BundleGenerator.BundleType;
  29 import java.io.File;
  30 import java.io.IOException;
  31 import java.io.UncheckedIOException;
  32 import java.nio.file.*;
  33 import java.text.MessageFormat;
  34 import java.time.*;
  35 import java.util.*;
  36 import java.util.ResourceBundle.Control;
  37 import java.util.logging.Level;
  38 import java.util.logging.Logger;
  39 import java.util.stream.Collectors;
  40 import java.util.stream.IntStream;
  41 import java.util.stream.Stream;
  42 import javax.xml.parsers.SAXParser;
  43 import javax.xml.parsers.SAXParserFactory;
  44 import org.xml.sax.SAXNotRecognizedException;
  45 import org.xml.sax.SAXNotSupportedException;
  46 
  47 
  48 /**
  49  * Converts locale data from &quot;Locale Data Markup Language&quot; format to
  50  * JRE resource bundle format. LDML is the format used by the Common
  51  * Locale Data Repository maintained by the Unicode Consortium.
  52  */
  53 public class CLDRConverter {
  54 
  55     static final String LDML_DTD_SYSTEM_ID = &quot;http://www.unicode.org/cldr/dtd/2.0/ldml.dtd&quot;;
  56     static final String SPPL_LDML_DTD_SYSTEM_ID = &quot;http://www.unicode.org/cldr/dtd/2.0/ldmlSupplemental.dtd&quot;;
  57     static final String BCP47_LDML_DTD_SYSTEM_ID = &quot;http://www.unicode.org/cldr/dtd/2.0/ldmlBCP47.dtd&quot;;
  58 
  59 
  60     private static String CLDR_BASE;
  61     static String LOCAL_LDML_DTD;
  62     static String LOCAL_SPPL_LDML_DTD;
  63     static String LOCAL_BCP47_LDML_DTD;
  64     private static String SOURCE_FILE_DIR;
  65     private static String SPPL_SOURCE_FILE;
  66     private static String SPPL_META_SOURCE_FILE;
  67     private static String NUMBERING_SOURCE_FILE;
  68     private static String METAZONES_SOURCE_FILE;
  69     private static String LIKELYSUBTAGS_SOURCE_FILE;
  70     private static String TIMEZONE_SOURCE_FILE;
  71     private static String WINZONES_SOURCE_FILE;
  72     private static String PLURALS_SOURCE_FILE;
  73     static String DESTINATION_DIR = &quot;build/gensrc&quot;;
  74 
  75     static final String LOCALE_NAME_PREFIX = &quot;locale.displayname.&quot;;
  76     static final String LOCALE_SEPARATOR = LOCALE_NAME_PREFIX + &quot;separator&quot;;
  77     static final String LOCALE_KEYTYPE = LOCALE_NAME_PREFIX + &quot;keytype&quot;;
  78     static final String LOCALE_KEY_PREFIX = LOCALE_NAME_PREFIX + &quot;key.&quot;;
  79     static final String LOCALE_TYPE_PREFIX = LOCALE_NAME_PREFIX + &quot;type.&quot;;
  80     static final String LOCALE_TYPE_PREFIX_CA = LOCALE_TYPE_PREFIX + &quot;ca.&quot;;
  81     static final String CURRENCY_SYMBOL_PREFIX = &quot;currency.symbol.&quot;;
  82     static final String CURRENCY_NAME_PREFIX = &quot;currency.displayname.&quot;;
  83     static final String CALENDAR_NAME_PREFIX = &quot;calendarname.&quot;;
  84     static final String CALENDAR_FIRSTDAY_PREFIX = &quot;firstDay.&quot;;
  85     static final String CALENDAR_MINDAYS_PREFIX = &quot;minDays.&quot;;
  86     static final String TIMEZONE_ID_PREFIX = &quot;timezone.id.&quot;;
  87     static final String EXEMPLAR_CITY_PREFIX = &quot;timezone.excity.&quot;;
  88     static final String ZONE_NAME_PREFIX = &quot;timezone.displayname.&quot;;
  89     static final String METAZONE_ID_PREFIX = &quot;metazone.id.&quot;;
  90     static final String PARENT_LOCALE_PREFIX = &quot;parentLocale.&quot;;
  91     static final String META_EMPTY_ZONE_NAME = &quot;EMPTY_ZONE&quot;;
  92     static final String[] EMPTY_ZONE = {&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;};
  93     static final String META_ETCUTC_ZONE_NAME = &quot;ETC_UTC&quot;;
  94 
  95     private static SupplementDataParseHandler handlerSuppl;
  96     private static LikelySubtagsParseHandler handlerLikelySubtags;
  97     private static WinZonesParseHandler handlerWinZones;
  98     static PluralsParseHandler handlerPlurals;
  99     static SupplementalMetadataParseHandler handlerSupplMeta;
 100     static NumberingSystemsParseHandler handlerNumbering;
 101     static MetaZonesParseHandler handlerMetaZones;
 102     static TimeZoneParseHandler handlerTimeZone;
 103     private static BundleGenerator bundleGenerator;
 104 
 105     // java.base module related
 106     static boolean isBaseModule = false;
 107     static final Set&lt;Locale&gt; BASE_LOCALES = new HashSet&lt;&gt;();
 108 
 109     // &quot;parentLocales&quot; map
 110     private static final Map&lt;String, SortedSet&lt;String&gt;&gt; parentLocalesMap = new HashMap&lt;&gt;();
 111     private static final ResourceBundle.Control defCon =
 112         ResourceBundle.Control.getControl(ResourceBundle.Control.FORMAT_DEFAULT);
 113 
 114     private static Set&lt;String&gt; AVAILABLE_TZIDS;
 115     private static String zoneNameTempFile;
 116     private static String tzDataDir;
 117     private static final Map&lt;String, String&gt; canonicalTZMap = new HashMap&lt;&gt;();
 118 
 119     static enum DraftType {
 120         UNCONFIRMED,
 121         PROVISIONAL,
 122         CONTRIBUTED,
 123         APPROVED;
 124 
 125         private static final Map&lt;String, DraftType&gt; map = new HashMap&lt;&gt;();
 126         static {
 127             for (DraftType dt : values()) {
 128                 map.put(dt.getKeyword(), dt);
 129             }
 130         }
 131         static private DraftType defaultType = CONTRIBUTED;
 132 
 133         private final String keyword;
 134 
 135         private DraftType() {
 136             keyword = this.name().toLowerCase(Locale.ROOT);
 137 
 138         }
 139 
 140         static DraftType forKeyword(String keyword) {
 141             return map.get(keyword);
 142         }
 143 
 144         static DraftType getDefault() {
 145             return defaultType;
 146         }
 147 
 148         static void setDefault(String keyword) {
 149             defaultType = Objects.requireNonNull(forKeyword(keyword));
 150         }
 151 
 152         String getKeyword() {
 153             return keyword;
 154         }
 155     }
 156 
 157     static boolean USE_UTF8 = false;
 158     private static boolean verbose;
 159 
 160     private CLDRConverter() {
 161        // no instantiation
 162     }
 163 
 164     @SuppressWarnings(&quot;AssignmentToForLoopParameter&quot;)
 165     public static void main(String[] args) throws Exception {
 166         if (args.length != 0) {
 167             String currentArg = null;
 168             try {
 169                 for (int i = 0; i &lt; args.length; i++) {
 170                     currentArg = args[i];
 171                     switch (currentArg) {
 172                     case &quot;-draft&quot;:
 173                         String draftDataType = args[++i];
 174                         try {
 175                             DraftType.setDefault(draftDataType);
 176                         } catch (NullPointerException e) {
 177                             severe(&quot;Error: incorrect draft value: %s%n&quot;, draftDataType);
 178                             System.exit(1);
 179                         }
 180                         info(&quot;Using the specified data type: %s%n&quot;, draftDataType);
 181                         break;
 182 
 183                     case &quot;-base&quot;:
 184                         // base directory for input files
 185                         CLDR_BASE = args[++i];
 186                         if (!CLDR_BASE.endsWith(&quot;/&quot;)) {
 187                             CLDR_BASE += &quot;/&quot;;
 188                         }
 189                         break;
 190 
 191                     case &quot;-baselocales&quot;:
 192                         // base locales
 193                         setupBaseLocales(args[++i]);
 194                         break;
 195 
 196                     case &quot;-basemodule&quot;:
 197                         // indicates java.base module resource generation
 198                         isBaseModule = true;
 199                         break;
 200 
 201                     case &quot;-o&quot;:
 202                         // output directory
 203                         DESTINATION_DIR = args[++i];
 204                         break;
 205 
 206                     case &quot;-utf8&quot;:
 207                         USE_UTF8 = true;
 208                         break;
 209 
 210                     case &quot;-verbose&quot;:
 211                         verbose = true;
 212                         break;
 213 
 214                     case &quot;-zntempfile&quot;:
 215                         zoneNameTempFile = args[++i];
 216                         break;
 217 
 218                     case &quot;-tzdatadir&quot;:
 219                         tzDataDir = args[++i];
 220                         break;
 221 
 222                     case &quot;-help&quot;:
 223                         usage();
 224                         System.exit(0);
 225                         break;
 226 
 227                     default:
 228                         throw new RuntimeException();
 229                     }
 230                 }
 231             } catch (RuntimeException e) {
 232                 severe(&quot;unknown or imcomplete arg(s): &quot; + currentArg);
 233                 usage();
 234                 System.exit(1);
 235             }
 236         }
 237 
 238         // Set up path names
 239         LOCAL_LDML_DTD = CLDR_BASE + &quot;/dtd/ldml.dtd&quot;;
 240         LOCAL_SPPL_LDML_DTD = CLDR_BASE + &quot;/dtd/ldmlSupplemental.dtd&quot;;
 241         LOCAL_BCP47_LDML_DTD = CLDR_BASE + &quot;/dtd/ldmlBCP47.dtd&quot;;
 242         SOURCE_FILE_DIR = CLDR_BASE + &quot;/main&quot;;
 243         SPPL_SOURCE_FILE = CLDR_BASE + &quot;/supplemental/supplementalData.xml&quot;;
 244         LIKELYSUBTAGS_SOURCE_FILE = CLDR_BASE + &quot;/supplemental/likelySubtags.xml&quot;;
 245         NUMBERING_SOURCE_FILE = CLDR_BASE + &quot;/supplemental/numberingSystems.xml&quot;;
 246         METAZONES_SOURCE_FILE = CLDR_BASE + &quot;/supplemental/metaZones.xml&quot;;
 247         TIMEZONE_SOURCE_FILE = CLDR_BASE + &quot;/bcp47/timezone.xml&quot;;
 248         SPPL_META_SOURCE_FILE = CLDR_BASE + &quot;/supplemental/supplementalMetadata.xml&quot;;
 249         WINZONES_SOURCE_FILE = CLDR_BASE + &quot;/supplemental/windowsZones.xml&quot;;
 250         PLURALS_SOURCE_FILE = CLDR_BASE + &quot;/supplemental/plurals.xml&quot;;
 251 
 252         if (BASE_LOCALES.isEmpty()) {
 253             setupBaseLocales(&quot;en-US&quot;);
 254         }
 255 
 256         bundleGenerator = new ResourceBundleGenerator();
 257 
 258         // Parse data independent of locales
 259         parseSupplemental();
 260         parseBCP47();
 261 
 262         List&lt;Bundle&gt; bundles = readBundleList();
 263         convertBundles(bundles);
 264 
 265         if (isBaseModule) {
 266             // Generate java.time.format.ZoneName.java
 267             generateZoneName();
 268 
 269             // Generate Windows tzmappings
 270             generateWindowsTZMappings();
 271 
 272             // Generate Plural rules
 273             generatePluralRules();
 274         }
 275     }
 276 
 277     private static void usage() {
 278         errout(&quot;Usage: java CLDRConverter [options]%n&quot;
 279                 + &quot;\t-help          output this usage message and exit%n&quot;
 280                 + &quot;\t-verbose       output information%n&quot;
 281                 + &quot;\t-draft [contributed | approved | provisional | unconfirmed]%n&quot;
 282                 + &quot;\t\t       draft level for using data (default: contributed)%n&quot;
 283                 + &quot;\t-base dir      base directory for CLDR input files%n&quot;
 284                 + &quot;\t-basemodule    generates bundles that go into java.base module%n&quot;
 285                 + &quot;\t-baselocales loc(,loc)*      locales that go into the base module%n&quot;
 286                 + &quot;\t-o dir         output directory (default: ./build/gensrc)%n&quot;
 287                 + &quot;\t-zntempfile    template file for java.time.format.ZoneName.java%n&quot;
 288                 + &quot;\t-tzdatadir     tzdata directory for java.time.format.ZoneName.java%n&quot;
 289                 + &quot;\t-utf8          use UTF-8 rather than \\uxxxx (for debug)%n&quot;);
 290     }
 291 
 292     static void info(String fmt, Object... args) {
 293         if (verbose) {
 294             System.out.printf(fmt, args);
 295         }
 296     }
 297 
 298     static void info(String msg) {
 299         if (verbose) {
 300             System.out.println(msg);
 301         }
 302     }
 303 
 304     static void warning(String fmt, Object... args) {
 305         System.err.print(&quot;Warning: &quot;);
 306         System.err.printf(fmt, args);
 307     }
 308 
 309     static void warning(String msg) {
 310         System.err.print(&quot;Warning: &quot;);
 311         errout(msg);
 312     }
 313 
 314     static void severe(String fmt, Object... args) {
 315         System.err.print(&quot;Error: &quot;);
 316         System.err.printf(fmt, args);
 317     }
 318 
 319     static void severe(String msg) {
 320         System.err.print(&quot;Error: &quot;);
 321         errout(msg);
 322     }
 323 
 324     private static void errout(String msg) {
 325         if (msg.contains(&quot;%n&quot;)) {
 326             System.err.printf(msg);
 327         } else {
 328             System.err.println(msg);
 329         }
 330     }
 331 
 332     /**
 333      * Configure the parser to allow access to DTDs on the file system.
 334      */
 335     private static void enableFileAccess(SAXParser parser) throws SAXNotSupportedException {
 336         try {
 337             parser.setProperty(&quot;http://javax.xml.XMLConstants/property/accessExternalDTD&quot;, &quot;file&quot;);
 338         } catch (SAXNotRecognizedException ignore) {
 339             // property requires &gt;= JAXP 1.5
 340         }
 341     }
 342 
 343     private static List&lt;Bundle&gt; readBundleList() throws Exception {
 344         List&lt;Bundle&gt; retList = new ArrayList&lt;&gt;();
 345         Path path = FileSystems.getDefault().getPath(SOURCE_FILE_DIR);
 346         try (DirectoryStream&lt;Path&gt; dirStr = Files.newDirectoryStream(path)) {
 347             for (Path entry : dirStr) {
 348                 String fileName = entry.getFileName().toString();
 349                 if (fileName.endsWith(&quot;.xml&quot;)) {
 350                     String id = fileName.substring(0, fileName.indexOf(&#39;.&#39;));
 351                     Locale cldrLoc = Locale.forLanguageTag(toLanguageTag(id));
 352                     StringBuilder sb = getCandLocales(cldrLoc);
 353                     if (sb.indexOf(&quot;root&quot;) == -1) {
 354                         sb.append(&quot;root&quot;);
 355                     }
 356                     retList.add(new Bundle(id, sb.toString(), null, null));
 357                 }
 358             }
 359         }
 360 
 361         // Sort the bundles based on id. This will make sure all the parent bundles are
 362         // processed first, e.g., for en_GB bundle, en_001, and &quot;root&quot; comes before
 363         // en_GB. In order for &quot;root&quot; to come at the beginning, &quot;root&quot; is replaced with
 364         // empty string on comparison.
 365         retList.sort((o1, o2) -&gt; {
 366             String id1 = o1.getID();
 367             String id2 = o2.getID();
 368             if(id1.equals(&quot;root&quot;)) {
 369                 id1 = &quot;&quot;;
 370             }
 371             if(id2.equals(&quot;root&quot;)) {
 372                 id2 = &quot;&quot;;
 373             }
 374             return id1.compareTo(id2);
 375         });
 376         return retList;
 377     }
 378 
 379     private static final Map&lt;String, Map&lt;String, Object&gt;&gt; cldrBundles = new HashMap&lt;&gt;();
 380 
 381     private static Map&lt;String, SortedSet&lt;String&gt;&gt; metaInfo = new HashMap&lt;&gt;();
 382 
 383     static {
 384         // For generating information on supported locales.
 385         metaInfo.put(&quot;AvailableLocales&quot;, new TreeSet&lt;&gt;());
 386     }
 387 
 388     static Map&lt;String, Object&gt; getCLDRBundle(String id) throws Exception {
 389         Map&lt;String, Object&gt; bundle = cldrBundles.get(id);
 390         if (bundle != null) {
 391             return bundle;
 392         }
 393         File file = new File(SOURCE_FILE_DIR + File.separator + id + &quot;.xml&quot;);
 394         if (!file.exists()) {
 395             // Skip if the file doesn&#39;t exist.
 396             return Collections.emptyMap();
 397         }
 398 
 399         info(&quot;..... main directory .....&quot;);
 400         LDMLParseHandler handler = new LDMLParseHandler(id);
 401         parseLDMLFile(file, handler);
 402 
 403         bundle = handler.getData();
 404         cldrBundles.put(id, bundle);
 405 
 406         if (id.equals(&quot;root&quot;)) {
 407             // Calendar data (firstDayOfWeek &amp; minDaysInFirstWeek)
 408             bundle = handlerSuppl.getData(&quot;root&quot;);
 409             if (bundle != null) {
 410                 //merge two maps into one map
 411                 Map&lt;String, Object&gt; temp = cldrBundles.remove(id);
 412                 bundle.putAll(temp);
 413                 cldrBundles.put(id, bundle);
 414             }
 415         }
 416         return bundle;
 417     }
 418 
 419     // Parsers for data in &quot;supplemental&quot; directory
 420     //
 421     private static void parseSupplemental() throws Exception {
 422         // Parse SupplementalData file and store the information in the HashMap
 423         // Calendar information such as firstDay and minDay are stored in
 424         // supplementalData.xml as of CLDR1.4. Individual territory is listed
 425         // with its ISO 3166 country code while default is listed using UNM49
 426         // region and composition numerical code (001 for World.)
 427         //
 428         // SupplementalData file also provides the &quot;parent&quot; locales which
 429         // are othrwise not to be fallen back. Process them here as well.
 430         //
 431         handlerSuppl = new SupplementDataParseHandler();
 432         parseLDMLFile(new File(SPPL_SOURCE_FILE), handlerSuppl);
 433         Map&lt;String, Object&gt; parentData = handlerSuppl.getData(&quot;root&quot;);
 434         parentData.keySet().stream()
 435                 .filter(key -&gt; key.startsWith(PARENT_LOCALE_PREFIX))
 436                 .forEach(key -&gt; {
 437                 parentLocalesMap.put(key, new TreeSet(
 438                     Arrays.asList(((String)parentData.get(key)).split(&quot; &quot;))));
 439             });
 440 
 441         // Parse numberingSystems to get digit zero character information.
 442         handlerNumbering = new NumberingSystemsParseHandler();
 443         parseLDMLFile(new File(NUMBERING_SOURCE_FILE), handlerNumbering);
 444 
 445         // Parse metaZones to create mappings between Olson tzids and CLDR meta zone names
 446         handlerMetaZones = new MetaZonesParseHandler();
 447         parseLDMLFile(new File(METAZONES_SOURCE_FILE), handlerMetaZones);
 448 
 449         // Parse likelySubtags
 450         handlerLikelySubtags = new LikelySubtagsParseHandler();
 451         parseLDMLFile(new File(LIKELYSUBTAGS_SOURCE_FILE), handlerLikelySubtags);
 452 
 453         // Parse supplementalMetadata
 454         // Currently interested in deprecated time zone ids and language aliases.
 455         handlerSupplMeta = new SupplementalMetadataParseHandler();
 456         parseLDMLFile(new File(SPPL_META_SOURCE_FILE), handlerSupplMeta);
 457 
 458         // Parse windowsZones
 459         handlerWinZones = new WinZonesParseHandler();
 460         parseLDMLFile(new File(WINZONES_SOURCE_FILE), handlerWinZones);
 461 
 462         // Parse plurals
 463         handlerPlurals = new PluralsParseHandler();
 464         parseLDMLFile(new File(PLURALS_SOURCE_FILE), handlerPlurals);
 465     }
 466 
 467     // Parsers for data in &quot;bcp47&quot; directory
 468     //
 469     private static void parseBCP47() throws Exception {
 470         // Parse timezone
 471         handlerTimeZone = new TimeZoneParseHandler();
 472         parseLDMLFile(new File(TIMEZONE_SOURCE_FILE), handlerTimeZone);
 473 
 474         // canonical tz name map
 475         // alias -&gt; primary
 476         handlerTimeZone.getData().forEach((k, v) -&gt; {
 477             String[] ids = ((String)v).split(&quot;\\s&quot;);
 478             for (int i = 1; i &lt; ids.length; i++) {
 479                 canonicalTZMap.put(ids[i], ids[0]);
 480             }
 481         });
 482     }
 483 
 484     private static void parseLDMLFile(File srcfile, AbstractLDMLHandler handler) throws Exception {
 485         info(&quot;..... Parsing &quot; + srcfile.getName() + &quot; .....&quot;);
 486         SAXParserFactory pf = SAXParserFactory.newInstance();
 487         pf.setValidating(true);
 488         SAXParser parser = pf.newSAXParser();
 489         enableFileAccess(parser);
 490         parser.parse(srcfile, handler);
 491     }
 492 
 493     private static StringBuilder getCandLocales(Locale cldrLoc) {
 494         List&lt;Locale&gt; candList = getCandidateLocales(cldrLoc);
 495         StringBuilder sb = new StringBuilder();
 496         for (Locale loc : candList) {
 497             if (!loc.equals(Locale.ROOT)) {
 498                 sb.append(toLocaleName(loc.toLanguageTag()));
 499                 sb.append(&quot;,&quot;);
 500             }
 501         }
 502         return sb;
 503     }
 504 
 505     private static List&lt;Locale&gt; getCandidateLocales(Locale cldrLoc) {
 506         List&lt;Locale&gt; candList = new ArrayList&lt;&gt;();
 507         candList = applyParentLocales(&quot;&quot;, defCon.getCandidateLocales(&quot;&quot;,  cldrLoc));
 508         return candList;
 509     }
 510 
 511     private static void convertBundles(List&lt;Bundle&gt; bundles) throws Exception {
 512         // parent locales map. The mappings are put in base metaInfo file
 513         // for now.
 514         if (isBaseModule) {
 515             metaInfo.putAll(parentLocalesMap);
 516         }
 517 
 518         for (Bundle bundle : bundles) {
 519             // Get the target map, which contains all the data that should be
 520             // visible for the bundle&#39;s locale
 521 
 522             Map&lt;String, Object&gt; targetMap = bundle.getTargetMap();
 523 
 524             EnumSet&lt;Bundle.Type&gt; bundleTypes = bundle.getBundleTypes();
 525 
 526             if (bundle.isRoot()) {
 527                 // Add DateTimePatternChars because CLDR no longer supports localized patterns.
 528                 targetMap.put(&quot;DateTimePatternChars&quot;, &quot;GyMdkHmsSEDFwWahKzZ&quot;);
 529             }
 530 
 531             // Now the map contains just the entries that need to be in the resources bundles.
 532             // Go ahead and generate them.
 533             if (bundleTypes.contains(Bundle.Type.LOCALENAMES)) {
 534                 Map&lt;String, Object&gt; localeNamesMap = extractLocaleNames(targetMap, bundle.getID());
 535                 if (!localeNamesMap.isEmpty() || bundle.isRoot()) {
 536                     bundleGenerator.generateBundle(&quot;util&quot;, &quot;LocaleNames&quot;, bundle.getJavaID(), true, localeNamesMap, BundleType.OPEN);
 537                 }
 538             }
 539             if (bundleTypes.contains(Bundle.Type.CURRENCYNAMES)) {
 540                 Map&lt;String, Object&gt; currencyNamesMap = extractCurrencyNames(targetMap, bundle.getID(), bundle.getCurrencies());
 541                 if (!currencyNamesMap.isEmpty() || bundle.isRoot()) {
 542                     bundleGenerator.generateBundle(&quot;util&quot;, &quot;CurrencyNames&quot;, bundle.getJavaID(), true, currencyNamesMap, BundleType.OPEN);
 543                 }
 544             }
 545             if (bundleTypes.contains(Bundle.Type.TIMEZONENAMES)) {
 546                 Map&lt;String, Object&gt; zoneNamesMap = extractZoneNames(targetMap, bundle.getID());
 547                 if (!zoneNamesMap.isEmpty() || bundle.isRoot()) {
 548                     bundleGenerator.generateBundle(&quot;util&quot;, &quot;TimeZoneNames&quot;, bundle.getJavaID(), true, zoneNamesMap, BundleType.TIMEZONE);
 549                 }
 550             }
 551             if (bundleTypes.contains(Bundle.Type.CALENDARDATA)) {
 552                 Map&lt;String, Object&gt; calendarDataMap = extractCalendarData(targetMap, bundle.getID());
 553                 if (!calendarDataMap.isEmpty() || bundle.isRoot()) {
 554                     bundleGenerator.generateBundle(&quot;util&quot;, &quot;CalendarData&quot;, bundle.getJavaID(), true, calendarDataMap, BundleType.PLAIN);
 555                 }
 556             }
 557             if (bundleTypes.contains(Bundle.Type.FORMATDATA)) {
 558                 Map&lt;String, Object&gt; formatDataMap = extractFormatData(targetMap, bundle.getID());
 559                 if (!formatDataMap.isEmpty() || bundle.isRoot()) {
 560                     bundleGenerator.generateBundle(&quot;text&quot;, &quot;FormatData&quot;, bundle.getJavaID(), true, formatDataMap, BundleType.PLAIN);
 561                 }
 562             }
 563 
 564             // For AvailableLocales
 565             metaInfo.get(&quot;AvailableLocales&quot;).add(toLanguageTag(bundle.getID()));
 566             addLikelySubtags(metaInfo, &quot;AvailableLocales&quot;, bundle.getID());
 567         }
 568         bundleGenerator.generateMetaInfo(metaInfo);
 569     }
 570 
 571     static final Map&lt;String, String&gt; aliases = new HashMap&lt;&gt;();
 572 
 573     /**
 574      * Translate the aliases into the real entries in the bundle map.
 575      */
 576     static void handleAliases(Map&lt;String, Object&gt; bundleMap) {
 577         Set bundleKeys = bundleMap.keySet();
 578         try {
 579             for (String key : aliases.keySet()) {
 580                 String targetKey = aliases.get(key);
 581                 if (bundleKeys.contains(targetKey)) {
 582                     bundleMap.putIfAbsent(key, bundleMap.get(targetKey));
 583                 }
 584             }
 585         } catch (Exception ex) {
 586             Logger.getLogger(CLDRConverter.class.getName()).log(Level.SEVERE, null, ex);
 587         }
 588     }
 589 
 590     /*
 591      * Returns the language portion of the given id.
 592      * If id is &quot;root&quot;, &quot;&quot; is returned.
 593      */
 594     static String getLanguageCode(String id) {
 595         return &quot;root&quot;.equals(id) ? &quot;&quot; : Locale.forLanguageTag(id.replaceAll(&quot;_&quot;, &quot;-&quot;)).getLanguage();
 596     }
 597 
 598     /**
 599      * Examine if the id includes the country (territory) code. If it does, it returns
 600      * the country code.
 601      * Otherwise, it returns null. eg. when the id is &quot;zh_Hans_SG&quot;, it return &quot;SG&quot;.
 602      * It does NOT return UN M.49 code, e.g., &#39;001&#39;, as those three digit numbers cannot
 603      * be translated into package names.
 604      */
 605     static String getCountryCode(String id) {
 606         String rgn = getRegionCode(id);
 607         return rgn.length() == 2 ? rgn: null;
 608     }
 609 
 610     /**
 611      * Examine if the id includes the region code. If it does, it returns
 612      * the region code.
 613      * Otherwise, it returns null. eg. when the id is &quot;zh_Hans_SG&quot;, it return &quot;SG&quot;.
 614      * It DOES return UN M.49 code, e.g., &#39;001&#39;, as well as ISO 3166 two letter country codes.
 615      */
 616     static String getRegionCode(String id) {
 617         return Locale.forLanguageTag(id.replaceAll(&quot;_&quot;, &quot;-&quot;)).getCountry();
 618     }
 619 
 620     private static class KeyComparator implements Comparator&lt;String&gt; {
 621         static KeyComparator INSTANCE = new KeyComparator();
 622 
 623         private KeyComparator() {
 624         }
 625 
 626         @Override
 627         public int compare(String o1, String o2) {
 628             int len1 = o1.length();
 629             int len2 = o2.length();
 630             if (!isDigit(o1.charAt(0)) &amp;&amp; !isDigit(o2.charAt(0))) {
 631                 // Shorter string comes first unless either starts with a digit.
 632                 if (len1 &lt; len2) {
 633                     return -1;
 634                 }
 635                 if (len1 &gt; len2) {
 636                     return 1;
 637                 }
 638             }
 639             return o1.compareTo(o2);
 640         }
 641 
 642         private boolean isDigit(char c) {
 643             return c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;;
 644         }
 645     }
 646 
 647     private static Map&lt;String, Object&gt; extractLocaleNames(Map&lt;String, Object&gt; map, String id) {
 648         Map&lt;String, Object&gt; localeNames = new TreeMap&lt;&gt;(KeyComparator.INSTANCE);
 649         for (String key : map.keySet()) {
 650             if (key.startsWith(LOCALE_NAME_PREFIX)) {
 651                 switch (key) {
 652                     case LOCALE_SEPARATOR:
 653                         localeNames.put(&quot;ListCompositionPattern&quot;, map.get(key));
 654                         break;
 655                     case LOCALE_KEYTYPE:
 656                         localeNames.put(&quot;ListKeyTypePattern&quot;, map.get(key));
 657                         break;
 658                     default:
 659                         localeNames.put(key.substring(LOCALE_NAME_PREFIX.length()), map.get(key));
 660                         break;
 661                 }
 662             }
 663         }
 664 
 665         if (id.equals(&quot;root&quot;)) {
 666             // Add display name pattern, which is not in CLDR
 667             localeNames.put(&quot;DisplayNamePattern&quot;, &quot;{0,choice,0#|1#{1}|2#{1} ({2})}&quot;);
 668         }
 669 
 670         return localeNames;
 671     }
 672 
 673     @SuppressWarnings(&quot;AssignmentToForLoopParameter&quot;)
 674     private static Map&lt;String, Object&gt; extractCurrencyNames(Map&lt;String, Object&gt; map, String id, String names)
 675             throws Exception {
 676         Map&lt;String, Object&gt; currencyNames = new TreeMap&lt;&gt;(KeyComparator.INSTANCE);
 677         for (String key : map.keySet()) {
 678             if (key.startsWith(CURRENCY_NAME_PREFIX)) {
 679                 currencyNames.put(key.substring(CURRENCY_NAME_PREFIX.length()), map.get(key));
 680             } else if (key.startsWith(CURRENCY_SYMBOL_PREFIX)) {
 681                 currencyNames.put(key.substring(CURRENCY_SYMBOL_PREFIX.length()), map.get(key));
 682             }
 683         }
 684         return currencyNames;
 685     }
 686 
 687     private static Map&lt;String, Object&gt; extractZoneNames(Map&lt;String, Object&gt; map, String id) {
 688         Map&lt;String, Object&gt; names = new TreeMap&lt;&gt;(KeyComparator.INSTANCE);
 689 
 690         getAvailableZoneIds().stream().forEach(tzid -&gt; {
 691             // If the tzid is deprecated, get the data for the replacement id
 692             String tzKey = Optional.ofNullable((String)handlerSupplMeta.get(tzid))
 693                                    .orElse(tzid);
 694             Object data = map.get(TIMEZONE_ID_PREFIX + tzKey);
 695 
 696             if (data instanceof String[]) {
 697                 // Hack for UTC. UTC is an alias to Etc/UTC in CLDR
 698                 if (tzid.equals(&quot;Etc/UTC&quot;) &amp;&amp; !map.containsKey(TIMEZONE_ID_PREFIX + &quot;UTC&quot;)) {
 699                     names.put(METAZONE_ID_PREFIX + META_ETCUTC_ZONE_NAME, data);
 700                     names.put(tzid, META_ETCUTC_ZONE_NAME);
 701                     names.put(&quot;UTC&quot;, META_ETCUTC_ZONE_NAME);
 702                 } else {
 703                     names.put(tzid, data);
 704                 }
 705             } else {
 706                 String meta = handlerMetaZones.get(tzKey);
 707                 if (meta != null) {
 708                     String metaKey = METAZONE_ID_PREFIX + meta;
 709                     data = map.get(metaKey);
 710                     if (data instanceof String[]) {
 711                         // Keep the metazone prefix here.
 712                         names.put(metaKey, data);
 713                         names.put(tzid, meta);
 714                     }
 715                 }
 716             }
 717         });
 718 
 719         // exemplar cities.
 720         Map&lt;String, Object&gt; exCities = map.entrySet().stream()
 721             .filter(e -&gt; e.getKey().startsWith(CLDRConverter.EXEMPLAR_CITY_PREFIX))
 722             .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
 723         names.putAll(exCities);
 724 
 725         // If there&#39;s no UTC entry at this point, add an empty one
 726         if (!names.isEmpty() &amp;&amp; !names.containsKey(&quot;UTC&quot;)) {
 727             names.putIfAbsent(METAZONE_ID_PREFIX + META_EMPTY_ZONE_NAME, EMPTY_ZONE);
 728             names.put(&quot;UTC&quot;, META_EMPTY_ZONE_NAME);
 729         }
 730 
 731         // Finally some compatibility stuff
 732         ZoneId.SHORT_IDS.entrySet().stream()
 733             .filter(e -&gt; !names.containsKey(e.getKey()) &amp;&amp; names.containsKey(e.getValue()))
 734             .forEach(e -&gt; {
 735                 names.put(e.getKey(), names.get(e.getValue()));
 736             });
 737 
 738         return names;
 739     }
 740 
 741     /**
 742      * Extracts the language independent calendar data. Each of the two keys,
 743      * &quot;firstDayOfWeek&quot; and &quot;minimalDaysInFirstWeek&quot; has a string value consists of
 744      * one or multiple occurrences of:
 745      *  i: rg1 rg2 ... rgn;
 746      * where &quot;i&quot; is the data for the following regions (delimited by a space) after
 747      * &quot;:&quot;, and ends with a &quot;;&quot;.
 748      */
 749     private static Map&lt;String, Object&gt; extractCalendarData(Map&lt;String, Object&gt; map, String id) {
 750         Map&lt;String, Object&gt; calendarData = new LinkedHashMap&lt;&gt;();
 751         if (id.equals(&quot;root&quot;)) {
 752             calendarData.put(&quot;firstDayOfWeek&quot;,
 753                 IntStream.range(1, 8)
 754                     .mapToObj(String::valueOf)
 755                     .filter(d -&gt; map.keySet().contains(CALENDAR_FIRSTDAY_PREFIX + d))
 756                     .map(d -&gt; d + &quot;: &quot; + map.get(CALENDAR_FIRSTDAY_PREFIX + d))
 757                     .collect(Collectors.joining(&quot;;&quot;)));
 758             calendarData.put(&quot;minimalDaysInFirstWeek&quot;,
 759                 IntStream.range(0, 7)
 760                     .mapToObj(String::valueOf)
 761                     .filter(d -&gt; map.keySet().contains(CALENDAR_MINDAYS_PREFIX + d))
 762                     .map(d -&gt; d + &quot;: &quot; + map.get(CALENDAR_MINDAYS_PREFIX + d))
 763                     .collect(Collectors.joining(&quot;;&quot;)));
 764         }
 765         return calendarData;
 766     }
 767 
 768     static final String[] FORMAT_DATA_ELEMENTS = {
 769         &quot;MonthNames&quot;,
 770         &quot;standalone.MonthNames&quot;,
 771         &quot;MonthAbbreviations&quot;,
 772         &quot;standalone.MonthAbbreviations&quot;,
 773         &quot;MonthNarrows&quot;,
 774         &quot;standalone.MonthNarrows&quot;,
 775         &quot;DayNames&quot;,
 776         &quot;standalone.DayNames&quot;,
 777         &quot;DayAbbreviations&quot;,
 778         &quot;standalone.DayAbbreviations&quot;,
 779         &quot;DayNarrows&quot;,
 780         &quot;standalone.DayNarrows&quot;,
 781         &quot;QuarterNames&quot;,
 782         &quot;standalone.QuarterNames&quot;,
 783         &quot;QuarterAbbreviations&quot;,
 784         &quot;standalone.QuarterAbbreviations&quot;,
 785         &quot;QuarterNarrows&quot;,
 786         &quot;standalone.QuarterNarrows&quot;,
 787         &quot;AmPmMarkers&quot;,
 788         &quot;narrow.AmPmMarkers&quot;,
 789         &quot;abbreviated.AmPmMarkers&quot;,
 790         &quot;long.Eras&quot;,
 791         &quot;Eras&quot;,
 792         &quot;narrow.Eras&quot;,
 793         &quot;field.era&quot;,
 794         &quot;field.year&quot;,
 795         &quot;field.month&quot;,
 796         &quot;field.week&quot;,
 797         &quot;field.weekday&quot;,
 798         &quot;field.dayperiod&quot;,
 799         &quot;field.hour&quot;,
 800         &quot;timezone.hourFormat&quot;,
 801         &quot;timezone.gmtFormat&quot;,
 802         &quot;timezone.gmtZeroFormat&quot;,
 803         &quot;timezone.regionFormat&quot;,
 804         &quot;timezone.regionFormat.daylight&quot;,
 805         &quot;timezone.regionFormat.standard&quot;,
 806         &quot;field.minute&quot;,
 807         &quot;field.second&quot;,
 808         &quot;field.zone&quot;,
 809         &quot;TimePatterns&quot;,
 810         &quot;DatePatterns&quot;,
 811         &quot;DateTimePatterns&quot;,
 812         &quot;DateTimePatternChars&quot;
 813     };
 814 
 815     private static Map&lt;String, Object&gt; extractFormatData(Map&lt;String, Object&gt; map, String id) {
 816         Map&lt;String, Object&gt; formatData = new LinkedHashMap&lt;&gt;();
 817         for (CalendarType calendarType : CalendarType.values()) {
 818             if (calendarType == CalendarType.GENERIC) {
 819                 continue;
 820             }
 821             String prefix = calendarType.keyElementName();
 822             for (String element : FORMAT_DATA_ELEMENTS) {
 823                 String key = prefix + element;
 824                 copyIfPresent(map, &quot;java.time.&quot; + key, formatData);
 825                 copyIfPresent(map, key, formatData);
 826             }
 827         }
 828 
 829         for (String key : map.keySet()) {
 830             // Copy available calendar names
 831             if (key.startsWith(CLDRConverter.LOCALE_TYPE_PREFIX_CA)) {
 832                 String type = key.substring(CLDRConverter.LOCALE_TYPE_PREFIX_CA.length());
 833                 for (CalendarType calendarType : CalendarType.values()) {
 834                     if (calendarType == CalendarType.GENERIC) {
 835                         continue;
 836                     }
 837                     if (type.equals(calendarType.lname())) {
 838                         Object value = map.get(key);
 839                         String dataKey = key.replace(LOCALE_TYPE_PREFIX_CA,
 840                                 CALENDAR_NAME_PREFIX);
 841                         formatData.put(dataKey, value);
 842                         String ukey = CALENDAR_NAME_PREFIX + calendarType.uname();
 843                         if (!dataKey.equals(ukey)) {
 844                             formatData.put(ukey, value);
 845                         }
 846                     }
 847                 }
 848             }
 849         }
 850 
 851         copyIfPresent(map, &quot;DefaultNumberingSystem&quot;, formatData);
 852 
 853         @SuppressWarnings(&quot;unchecked&quot;)
 854         List&lt;String&gt; numberingScripts = (List&lt;String&gt;) map.remove(&quot;numberingScripts&quot;);
 855         if (numberingScripts != null) {
 856             for (String script : numberingScripts) {
 857                 copyIfPresent(map, script + &quot;.NumberElements&quot;, formatData);
 858                 copyIfPresent(map, script + &quot;.NumberPatterns&quot;, formatData);
 859             }
 860         } else {
 861             copyIfPresent(map, &quot;NumberElements&quot;, formatData);
 862             copyIfPresent(map, &quot;NumberPatterns&quot;, formatData);
 863         }
 864         copyIfPresent(map, &quot;short.CompactNumberPatterns&quot;, formatData);
 865         copyIfPresent(map, &quot;long.CompactNumberPatterns&quot;, formatData);
 866 
 867         // put extra number elements for available scripts into formatData, if it is &quot;root&quot;
 868         if (id.equals(&quot;root&quot;)) {
 869             handlerNumbering.keySet().stream()
 870                 .filter(k -&gt; !numberingScripts.contains(k))
 871                 .forEach(k -&gt; {
 872                     String[] ne = (String[])map.get(&quot;latn.NumberElements&quot;);
 873                     String[] neNew = Arrays.copyOf(ne, ne.length);
 874                     neNew[4] = handlerNumbering.get(k).substring(0, 1);
 875                     formatData.put(k + &quot;.NumberElements&quot;, neNew);
 876                 });
 877         }
 878         return formatData;
 879     }
 880 
 881     private static void copyIfPresent(Map&lt;String, Object&gt; src, String key, Map&lt;String, Object&gt; dest) {
 882         Object value = src.get(key);
 883         if (value != null) {
 884             dest.put(key, value);
 885         }
 886     }
 887 
 888     // --- code below here is adapted from java.util.Properties ---
 889     private static final String specialSaveCharsJava = &quot;\&quot;&quot;;
 890     private static final String specialSaveCharsProperties = &quot;=: \t\r\n\f#!&quot;;
 891 
 892     /*
 893      * Converts unicodes to encoded &amp;#92;uxxxx
 894      * and writes out any of the characters in specialSaveChars
 895      * with a preceding slash
 896      */
 897     static String saveConvert(String theString, boolean useJava) {
 898         if (theString == null) {
 899             return &quot;&quot;;
 900         }
 901 
 902         String specialSaveChars;
 903         if (useJava) {
 904             specialSaveChars = specialSaveCharsJava;
 905         } else {
 906             specialSaveChars = specialSaveCharsProperties;
 907         }
 908         boolean escapeSpace = false;
 909 
 910         int len = theString.length();
 911         StringBuilder outBuffer = new StringBuilder(len * 2);
 912         Formatter formatter = new Formatter(outBuffer, Locale.ROOT);
 913 
 914         for (int x = 0; x &lt; len; x++) {
 915             char aChar = theString.charAt(x);
 916             switch (aChar) {
 917             case &#39; &#39;:
 918                 if (x == 0 || escapeSpace) {
 919                     outBuffer.append(&#39;\\&#39;);
 920                 }
 921                 outBuffer.append(&#39; &#39;);
 922                 break;
 923             case &#39;\\&#39;:
 924                 outBuffer.append(&#39;\\&#39;);
 925                 outBuffer.append(&#39;\\&#39;);
 926                 break;
 927             case &#39;\t&#39;:
 928                 outBuffer.append(&#39;\\&#39;);
 929                 outBuffer.append(&#39;t&#39;);
 930                 break;
 931             case &#39;\n&#39;:
 932                 outBuffer.append(&#39;\\&#39;);
 933                 outBuffer.append(&#39;n&#39;);
 934                 break;
 935             case &#39;\r&#39;:
 936                 outBuffer.append(&#39;\\&#39;);
 937                 outBuffer.append(&#39;r&#39;);
 938                 break;
 939             case &#39;\f&#39;:
 940                 outBuffer.append(&#39;\\&#39;);
 941                 outBuffer.append(&#39;f&#39;);
 942                 break;
 943             default:
 944                 if (aChar &lt; 0x0020 || (!USE_UTF8 &amp;&amp; aChar &gt; 0x007e)) {
 945                     formatter.format(&quot;\\u%04x&quot;, (int)aChar);
 946                 } else {
 947                     if (specialSaveChars.indexOf(aChar) != -1) {
 948                         outBuffer.append(&#39;\\&#39;);
 949                     }
 950                     outBuffer.append(aChar);
 951                 }
 952             }
 953         }
 954         return outBuffer.toString();
 955     }
 956 
 957     private static String toLanguageTag(String locName) {
 958         if (locName.indexOf(&#39;_&#39;) == -1) {
 959             return locName;
 960         }
 961         String tag = locName.replaceAll(&quot;_&quot;, &quot;-&quot;);
 962         Locale loc = Locale.forLanguageTag(tag);
 963         return loc.toLanguageTag();
 964     }
 965 
 966     private static void addLikelySubtags(Map&lt;String, SortedSet&lt;String&gt;&gt; metaInfo, String category, String id) {
 967         String likelySubtag = handlerLikelySubtags.get(id);
 968         if (likelySubtag != null) {
 969             // Remove Script for now
 970             metaInfo.get(category).add(toLanguageTag(likelySubtag).replaceFirst(&quot;-[A-Z][a-z]{3}&quot;, &quot;&quot;));
 971         }
 972     }
 973 
 974     private static String toLocaleName(String tag) {
 975         if (tag.indexOf(&#39;-&#39;) == -1) {
 976             return tag;
 977         }
 978         return tag.replaceAll(&quot;-&quot;, &quot;_&quot;);
 979     }
 980 
 981     private static void setupBaseLocales(String localeList) {
 982         Arrays.stream(localeList.split(&quot;,&quot;))
 983             .map(Locale::forLanguageTag)
 984             .map(l -&gt; Control.getControl(Control.FORMAT_DEFAULT)
 985                              .getCandidateLocales(&quot;&quot;, l))
 986             .forEach(BASE_LOCALES::addAll);
 987     }
 988 
 989     // applying parent locale rules to the passed candidates list
 990     // This has to match with the one in sun.util.cldr.CLDRLocaleProviderAdapter
 991     private static Map&lt;Locale, Locale&gt; childToParentLocaleMap = null;
 992     private static List&lt;Locale&gt; applyParentLocales(String baseName, List&lt;Locale&gt; candidates) {
 993         if (Objects.isNull(childToParentLocaleMap)) {
 994             childToParentLocaleMap = new HashMap&lt;&gt;();
 995             parentLocalesMap.keySet().forEach(key -&gt; {
 996                 String parent = key.substring(PARENT_LOCALE_PREFIX.length()).replaceAll(&quot;_&quot;, &quot;-&quot;);
 997                 parentLocalesMap.get(key).stream().forEach(child -&gt; {
 998                     childToParentLocaleMap.put(Locale.forLanguageTag(child),
 999                         &quot;root&quot;.equals(parent) ? Locale.ROOT : Locale.forLanguageTag(parent));
1000                 });
1001             });
1002         }
1003 
1004         // check irregular parents
1005         for (int i = 0; i &lt; candidates.size(); i++) {
1006             Locale l = candidates.get(i);
1007             Locale p = childToParentLocaleMap.get(l);
1008             if (!l.equals(Locale.ROOT) &amp;&amp;
1009                 Objects.nonNull(p) &amp;&amp;
1010                 !candidates.get(i+1).equals(p)) {
1011                 List&lt;Locale&gt; applied = candidates.subList(0, i+1);
1012                 applied.addAll(applyParentLocales(baseName, defCon.getCandidateLocales(baseName, p)));
1013                 return applied;
1014             }
1015         }
1016 
1017         return candidates;
1018     }
1019 
1020     private static void generateZoneName() throws Exception {
1021         Files.createDirectories(Paths.get(DESTINATION_DIR, &quot;java&quot;, &quot;time&quot;, &quot;format&quot;));
1022         Files.write(Paths.get(DESTINATION_DIR, &quot;java&quot;, &quot;time&quot;, &quot;format&quot;, &quot;ZoneName.java&quot;),
1023             Files.lines(Paths.get(zoneNameTempFile))
1024                 .flatMap(l -&gt; {
1025                     if (l.equals(&quot;%%%%ZIDMAP%%%%&quot;)) {
1026                         return zidMapEntry();
1027                     } else if (l.equals(&quot;%%%%MZONEMAP%%%%&quot;)) {
1028                         return handlerMetaZones.mzoneMapEntry();
1029                     } else if (l.equals(&quot;%%%%DEPRECATED%%%%&quot;)) {
1030                         return handlerSupplMeta.deprecatedMap();
1031                     } else if (l.equals(&quot;%%%%TZDATALINK%%%%&quot;)) {
1032                         return tzDataLinkEntry();
1033                     } else {
1034                         return Stream.of(l);
1035                     }
1036                 })
1037                 .collect(Collectors.toList()),
1038             StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
1039     }
1040 
1041     // This method assumes handlerMetaZones is already initialized
1042     private static Set&lt;String&gt; getAvailableZoneIds() {
1043         assert handlerMetaZones != null;
1044         if (AVAILABLE_TZIDS == null) {
1045             AVAILABLE_TZIDS = new HashSet&lt;&gt;(ZoneId.getAvailableZoneIds());
1046             AVAILABLE_TZIDS.addAll(handlerMetaZones.keySet());
1047             AVAILABLE_TZIDS.remove(MetaZonesParseHandler.NO_METAZONE_KEY);
1048         }
1049 
1050         return AVAILABLE_TZIDS;
1051     }
1052 
1053     private static Stream&lt;String&gt; zidMapEntry() {
1054         return getAvailableZoneIds().stream()
1055                 .map(id -&gt; {
1056                     String canonId = canonicalTZMap.getOrDefault(id, id);
1057                     String meta = handlerMetaZones.get(canonId);
1058                     String zone001 = handlerMetaZones.zidMap().get(meta);
1059                     return zone001 == null ? &quot;&quot; :
1060                             String.format(&quot;        \&quot;%s\&quot;, \&quot;%s\&quot;, \&quot;%s\&quot;,&quot;,
1061                                             id, meta, zone001);
1062                 })
1063                 .filter(s -&gt; !s.isEmpty())
1064                 .sorted();
1065     }
1066 
1067     private static Stream&lt;String&gt; tzDataLinkEntry() {
1068         try {
1069             return Files.walk(Paths.get(tzDataDir), 1)
1070                 .filter(p -&gt; !Files.isDirectory(p))
1071                 .flatMap(CLDRConverter::extractLinks)
1072                 .sorted();
1073         } catch (IOException e) {
1074             throw new UncheckedIOException(e);
1075         }
1076     }
1077 
1078     private static Stream&lt;String&gt; extractLinks(Path tzFile) {
1079         try {
1080             return Files.lines(tzFile)
1081                 .filter(l -&gt; l.startsWith(&quot;Link&quot;))
1082                 .map(l -&gt; l.replaceFirst(&quot;^Link[\\s]+(\\S+)\\s+(\\S+).*&quot;,
1083                                          &quot;        \&quot;$2\&quot;, \&quot;$1\&quot;,&quot;));
1084         } catch (IOException e) {
1085             throw new UncheckedIOException(e);
1086         }
1087     }
1088 
1089     // Generate tzmappings for Windows. The format is:
1090     //
1091     // (Windows Zone Name):(REGION):(Java TZID)
1092     //
1093     // where:
1094     //   Windows Zone Name: arbitrary time zone name string used in Windows
1095     //   REGION: ISO3166 or UN M.49 code
1096     //   Java TZID: Java&#39;s time zone ID
1097     //
1098     // Note: the entries are alphabetically sorted, *except* the &quot;world&quot; region
1099     // code, i.e., &quot;001&quot;. It should be the last entry for the same windows time
1100     // zone name entries. (cf. TimeZone_md.c)
1101     private static void generateWindowsTZMappings() throws Exception {
1102         Files.createDirectories(Paths.get(DESTINATION_DIR, &quot;windows&quot;, &quot;conf&quot;));
1103         Files.write(Paths.get(DESTINATION_DIR, &quot;windows&quot;, &quot;conf&quot;, &quot;tzmappings&quot;),
1104             handlerWinZones.keySet().stream()
1105                 .map(k -&gt; k + &quot;:&quot; + handlerWinZones.get(k) + &quot;:&quot;)
1106                 .sorted(new Comparator&lt;String&gt;() {
1107                     public int compare(String t1, String t2) {
1108                         String[] s1 = t1.split(&quot;:&quot;);
1109                         String[] s2 = t2.split(&quot;:&quot;);
1110                         if (s1[0].equals(s2[0])) {
1111                             if (s1[1].equals(&quot;001&quot;)) {
1112                                 return 1;
1113                             } else if (s2[1].equals(&quot;001&quot;)) {
1114                                 return -1;
1115                             } else {
1116                                 return s1[1].compareTo(s2[1]);
1117                             }
1118                         } else {
1119                             return s1[0].compareTo(s2[0]);
1120                         }
1121                     }
1122                 })
1123                 .collect(Collectors.toList()),
1124             StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
1125     }
1126 
1127     /**
1128      * Generate ResourceBundle source file for plural rules. The generated
1129      * class is {@code sun.text.resources.PluralRules} which has one public
1130      * two dimensional array {@code rulesArray}. Each array element consists
1131      * of two elements that designate the locale and the locale&#39;s plural rules
1132      * string. The latter has the syntax from Unicode Consortium&#39;s
1133      * &lt;a href=&quot;http://unicode.org/reports/tr35/tr35-numbers.html#Plural_rules_syntax&quot;&gt;
1134      * Plural rules syntax&lt;/a&gt;. {@code samples} and {@code &quot;other&quot;} are being ommited.
1135      *
1136      * @throws Exception
1137      */
1138     private static void generatePluralRules() throws Exception {
1139         Files.createDirectories(Paths.get(DESTINATION_DIR, &quot;sun&quot;, &quot;text&quot;, &quot;resources&quot;));
1140         Files.write(Paths.get(DESTINATION_DIR, &quot;sun&quot;, &quot;text&quot;, &quot;resources&quot;, &quot;PluralRules.java&quot;),
1141             Stream.concat(
1142                 Stream.concat(
1143                     Stream.of(
1144                         &quot;package sun.text.resources;&quot;,
1145                         &quot;public final class PluralRules {&quot;,
1146                         &quot;    public static final String[][] rulesArray = {&quot;
1147                     ),
1148                     pluralRulesStream().sorted()
1149                 ),
1150                 Stream.of(
1151                     &quot;    };&quot;,
1152                     &quot;}&quot;
1153                 )
1154             )
1155             .collect(Collectors.toList()),
1156         StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
1157     }
1158 
1159     private static Stream&lt;String&gt; pluralRulesStream() {
1160         return handlerPlurals.getData().entrySet().stream()
1161             .filter(e -&gt; !((Map&lt;String, String&gt;)e.getValue()).isEmpty())
1162             .map(e -&gt; {
1163                 String loc = e.getKey();
1164                 Map&lt;String, String&gt; rules = (Map&lt;String, String&gt;)e.getValue();
1165                 return &quot;        {\&quot;&quot; + loc + &quot;\&quot;, \&quot;&quot; +
1166                     rules.entrySet().stream()
1167                         .map(rule -&gt; rule.getKey() + &quot;:&quot; + rule.getValue().replaceFirst(&quot;@.*&quot;, &quot;&quot;))
1168                         .map(String::trim)
1169                         .collect(Collectors.joining(&quot;;&quot;)) + &quot;\&quot;},&quot;;
1170             });
1171     }
1172 
1173     // for debug
1174     static void dumpMap(Map&lt;String, Object&gt; map) {
1175         map.entrySet().stream()
1176             .sorted(Map.Entry.comparingByKey())
1177             .map(e -&gt; {
1178                 Object val = e.getValue();
1179                 String valStr = null;
1180 
1181                 if (val instanceof String[]) {
1182                     valStr = Arrays.asList((String[])val).toString();
1183                 } else if (val != null) {
1184                     valStr = val.toString();
1185                 }
1186                 return e.getKey() + &quot; = &quot; + valStr;
1187             })
1188             .forEach(System.out::println);
1189     }
1190 }
1191 
    </pre>
  </body>
</html>
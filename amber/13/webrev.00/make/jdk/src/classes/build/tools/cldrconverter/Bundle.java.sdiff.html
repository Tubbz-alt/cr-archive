<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff make/jdk/src/classes/build/tools/cldrconverter/Bundle.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../netbeans/jmx/build.xml.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="CLDRConverter.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>make/jdk/src/classes/build/tools/cldrconverter/Bundle.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
174     EnumSet&lt;Type&gt; getBundleTypes() {
175         return bundleTypes;
176     }
177 
178     String getCurrencies() {
179         return currencies;
180     }
181 
182     /**
183      * Generate a map that contains all the data that should be
184      * visible for the bundle&#39;s locale
185      */
186     Map&lt;String, Object&gt; getTargetMap() throws Exception {
187         if (targetMap != null) {
188             return targetMap;
189         }
190 
191         String[] cldrBundles = getCLDRPath().split(&quot;,&quot;);
192 
193         // myMap contains resources for id.

194         Map&lt;String, Object&gt; myMap = new HashMap&lt;&gt;();
195         int index;
196         for (index = 0; index &lt; cldrBundles.length; index++) {
197             if (cldrBundles[index].equals(id)) {
198                 myMap.putAll(CLDRConverter.getCLDRBundle(cldrBundles[index]));
199                 break;
200             }
201         }
202 
203         // parentsMap contains resources from id&#39;s parents.
204         Map&lt;String, Object&gt; parentsMap = new HashMap&lt;&gt;();
205         for (int i = cldrBundles.length - 1; i &gt; index; i--) {
206             if (!(&quot;no&quot;.equals(cldrBundles[i]) || cldrBundles[i].startsWith(&quot;no_&quot;))) {
207                 parentsMap.putAll(CLDRConverter.getCLDRBundle(cldrBundles[i]));
208             }
209         }
210         // Duplicate myMap as parentsMap for &quot;root&quot; so that the
211         // fallback works. This is a hack, though.
212         if (&quot;root&quot;.equals(cldrBundles[0])) {
213             assert parentsMap.isEmpty();
214             parentsMap.putAll(myMap);
215         }
216 
217         // merge individual strings into arrays
218 
219         // if myMap has any of the NumberPatterns/NumberElements members, create a
220         // complete array of patterns/elements.
221         @SuppressWarnings(&quot;unchecked&quot;)
222         List&lt;String&gt; scripts = (List&lt;String&gt;) myMap.get(&quot;numberingScripts&quot;);
223         if (scripts != null) {
224             for (String script : scripts) {
225                 myMap.put(script + &quot;.NumberPatterns&quot;,
226                         createNumberArray(myMap, parentsMap, NUMBER_PATTERN_KEYS, script));
227                 myMap.put(script + &quot;.NumberElements&quot;,
228                         createNumberArray(myMap, parentsMap, NUMBER_ELEMENT_KEYS, script));
229             }
230         }
231 
232         for (String k : COMPACT_NUMBER_PATTERN_KEYS) {

233             List&lt;String&gt; patterns = (List&lt;String&gt;) myMap.remove(k);
234             if (patterns != null) {
235                 // Convert the map value from List&lt;String&gt; to String[], replacing any missing
236                 // entry from the parents map, if any.

237                 final List&lt;String&gt; pList = (List&lt;String&gt;)parentsMap.get(k);
238                 int size = patterns.size();
239                 int psize = pList != null ? pList.size() : 0;
240                 String[] arrPatterns = IntStream.range(0, Math.max(size, psize))
241                     .mapToObj(i -&gt; {
242                         String pattern;
243                         // first try itself.
244                         if (i &lt; size) {
245                             pattern = patterns.get(i);
246                             if (!pattern.isEmpty()) {
247                                 return &quot;{&quot; + pattern + &quot;}&quot;;
248                             }
249                         }
250                         // if not found, try parent
251                         if (i &lt; psize) {
252                             pattern = pList.get(i);
253                             if (!pattern.isEmpty()) {
254                                 return &quot;{&quot; + pattern + &quot;}&quot;;
255                             }
256                         }
</pre>
<hr />
<pre>
269         if (&quot;root&quot;.equals(id)) {
270             parentsMap = null;
271         }
272 
273         for (CalendarType calendarType : CalendarType.values()) {
274             String calendarPrefix = calendarType.keyElementName();
275             // handle multiple inheritance for month and day names
276             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;MonthNames&quot;);
277             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;MonthAbbreviations&quot;);
278             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;MonthNarrows&quot;);
279             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;DayNames&quot;);
280             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;DayAbbreviations&quot;);
281             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;DayNarrows&quot;);
282             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;AmPmMarkers&quot;);
283             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;narrow.AmPmMarkers&quot;);
284             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;abbreviated.AmPmMarkers&quot;);
285             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;QuarterNames&quot;);
286             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;QuarterAbbreviations&quot;);
287             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;QuarterNarrows&quot;);
288 
<span class="line-modified">289             adjustEraNames(myMap, calendarType);</span>
290 
291             handleDateTimeFormatPatterns(TIME_PATTERN_KEYS, myMap, parentsMap, calendarType, &quot;TimePatterns&quot;);
292             handleDateTimeFormatPatterns(DATE_PATTERN_KEYS, myMap, parentsMap, calendarType, &quot;DatePatterns&quot;);
293             handleDateTimeFormatPatterns(DATETIME_PATTERN_KEYS, myMap, parentsMap, calendarType, &quot;DateTimePatterns&quot;);
294         }
295 
296         // First, weed out any empty timezone or metazone names from myMap.
297         for (Iterator&lt;String&gt; it = myMap.keySet().iterator(); it.hasNext();) {
298             String key = it.next();
299             if (key.startsWith(CLDRConverter.TIMEZONE_ID_PREFIX)
300                     || key.startsWith(CLDRConverter.METAZONE_ID_PREFIX)) {
301                 @SuppressWarnings(&quot;unchecked&quot;)
302                 Map&lt;String, String&gt; nameMap = (Map&lt;String, String&gt;) myMap.get(key);
303                 if (nameMap.isEmpty()) {
304                     // Some zones have only exemplarCity, which become empty.
305                     // Remove those from the map.
306                     it.remove();
307                     continue;
308                 }
309             }
</pre>
<hr />
<pre>
393         if (format != null) {
394             map.remove(formatMapKey);
395             map.put(key, format);
396             if (fillInElements(parents, formatMapKey, format)) {
397                 map.remove(key);
398             }
399         }
400         String standaloneMapKey = key + &quot;/stand-alone&quot;;
401         Object standalone = map.get(standaloneMapKey);
402         if (standalone != null) {
403             map.remove(standaloneMapKey);
404             String standaloneResourceKey = &quot;standalone.&quot; + key;
405             map.put(standaloneResourceKey, standalone);
406             if (fillInElements(parents, standaloneMapKey, standalone)) {
407                 map.remove(standaloneResourceKey);
408             }
409         }
410     }
411 
412     /**
<span class="line-modified">413      * Fills in any empty elements with its parent element. Returns true if the resulting array is</span>
<span class="line-modified">414      * identical to its parent array.</span>

415      *
416      * @param parents
417      * @param key
418      * @param value
419      * @return true if the resulting array is identical to its parent array.
420      */
421     private boolean fillInElements(Map&lt;String, Object&gt; parents, String key, Object value) {
422         if (parents == null) {
423             return false;
424         }
425         if (value instanceof String[]) {
<span class="line-modified">426             Object pvalue = parents.get(key);</span>
427             if (pvalue != null &amp;&amp; pvalue instanceof String[]) {
428                 String[] strings = (String[]) value;
429                 String[] pstrings = (String[]) pvalue;
430                 for (int i = 0; i &lt; strings.length; i++) {
431                     if (strings[i] == null || strings[i].length() == 0) {
432                         strings[i] = pstrings[i];
433                     }
434                 }
435                 return Arrays.equals(strings, pstrings);
436             }
437         }
438         return false;
439     }
440 
441     /*
442      * Adjusts String[] for era names because JRE&#39;s Calendars use different
443      * ERA value indexes in the Buddhist, Japanese Imperial, and Islamic calendars.
444      */
<span class="line-modified">445     private void adjustEraNames(Map&lt;String, Object&gt; map, CalendarType type) {</span>
446         String[][] eraNames = new String[ERA_KEYS.length][];
447         String[] realKeys = new String[ERA_KEYS.length];
448         int index = 0;
449         for (String key : ERA_KEYS) {
450             String realKey = type.keyElementName() + key;
451             String[] value = (String[]) map.get(realKey);
452             if (value != null) {



453                 switch (type) {
454                 case GREGORIAN:
455                     break;
456 
457                 case JAPANESE:
458                     {
459                         String[] newValue = new String[value.length + 1];
460                         String[] julianEras = (String[]) map.get(key);
461                         if (julianEras != null &amp;&amp; julianEras.length &gt;= 2) {
462                             newValue[0] = julianEras[1];
463                         } else {
464                             newValue[0] = &quot;&quot;;
465                         }
466                         System.arraycopy(value, 0, newValue, 1, value.length);
467                         value = newValue;
468 
469                         // fix up &#39;Reiwa&#39; era, which can be missing in some locales
470                         if (value[value.length - 1] == null) {
471                             value[value.length - 1] = (key.startsWith(&quot;narrow.&quot;) ? &quot;R&quot; : &quot;Reiwa&quot;);
472                         }
</pre>
</td>
<td>
<hr />
<pre>
174     EnumSet&lt;Type&gt; getBundleTypes() {
175         return bundleTypes;
176     }
177 
178     String getCurrencies() {
179         return currencies;
180     }
181 
182     /**
183      * Generate a map that contains all the data that should be
184      * visible for the bundle&#39;s locale
185      */
186     Map&lt;String, Object&gt; getTargetMap() throws Exception {
187         if (targetMap != null) {
188             return targetMap;
189         }
190 
191         String[] cldrBundles = getCLDRPath().split(&quot;,&quot;);
192 
193         // myMap contains resources for id.
<span class="line-added">194         @SuppressWarnings(&quot;unchecked&quot;)</span>
195         Map&lt;String, Object&gt; myMap = new HashMap&lt;&gt;();
196         int index;
197         for (index = 0; index &lt; cldrBundles.length; index++) {
198             if (cldrBundles[index].equals(id)) {
199                 myMap.putAll(CLDRConverter.getCLDRBundle(cldrBundles[index]));
200                 break;
201             }
202         }
203 
204         // parentsMap contains resources from id&#39;s parents.
205         Map&lt;String, Object&gt; parentsMap = new HashMap&lt;&gt;();
206         for (int i = cldrBundles.length - 1; i &gt; index; i--) {
207             if (!(&quot;no&quot;.equals(cldrBundles[i]) || cldrBundles[i].startsWith(&quot;no_&quot;))) {
208                 parentsMap.putAll(CLDRConverter.getCLDRBundle(cldrBundles[i]));
209             }
210         }
211         // Duplicate myMap as parentsMap for &quot;root&quot; so that the
212         // fallback works. This is a hack, though.
213         if (&quot;root&quot;.equals(cldrBundles[0])) {
214             assert parentsMap.isEmpty();
215             parentsMap.putAll(myMap);
216         }
217 
218         // merge individual strings into arrays
219 
220         // if myMap has any of the NumberPatterns/NumberElements members, create a
221         // complete array of patterns/elements.
222         @SuppressWarnings(&quot;unchecked&quot;)
223         List&lt;String&gt; scripts = (List&lt;String&gt;) myMap.get(&quot;numberingScripts&quot;);
224         if (scripts != null) {
225             for (String script : scripts) {
226                 myMap.put(script + &quot;.NumberPatterns&quot;,
227                         createNumberArray(myMap, parentsMap, NUMBER_PATTERN_KEYS, script));
228                 myMap.put(script + &quot;.NumberElements&quot;,
229                         createNumberArray(myMap, parentsMap, NUMBER_ELEMENT_KEYS, script));
230             }
231         }
232 
233         for (String k : COMPACT_NUMBER_PATTERN_KEYS) {
<span class="line-added">234             @SuppressWarnings(&quot;unchecked&quot;)</span>
235             List&lt;String&gt; patterns = (List&lt;String&gt;) myMap.remove(k);
236             if (patterns != null) {
237                 // Convert the map value from List&lt;String&gt; to String[], replacing any missing
238                 // entry from the parents map, if any.
<span class="line-added">239                 @SuppressWarnings(&quot;unchecked&quot;)</span>
240                 final List&lt;String&gt; pList = (List&lt;String&gt;)parentsMap.get(k);
241                 int size = patterns.size();
242                 int psize = pList != null ? pList.size() : 0;
243                 String[] arrPatterns = IntStream.range(0, Math.max(size, psize))
244                     .mapToObj(i -&gt; {
245                         String pattern;
246                         // first try itself.
247                         if (i &lt; size) {
248                             pattern = patterns.get(i);
249                             if (!pattern.isEmpty()) {
250                                 return &quot;{&quot; + pattern + &quot;}&quot;;
251                             }
252                         }
253                         // if not found, try parent
254                         if (i &lt; psize) {
255                             pattern = pList.get(i);
256                             if (!pattern.isEmpty()) {
257                                 return &quot;{&quot; + pattern + &quot;}&quot;;
258                             }
259                         }
</pre>
<hr />
<pre>
272         if (&quot;root&quot;.equals(id)) {
273             parentsMap = null;
274         }
275 
276         for (CalendarType calendarType : CalendarType.values()) {
277             String calendarPrefix = calendarType.keyElementName();
278             // handle multiple inheritance for month and day names
279             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;MonthNames&quot;);
280             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;MonthAbbreviations&quot;);
281             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;MonthNarrows&quot;);
282             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;DayNames&quot;);
283             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;DayAbbreviations&quot;);
284             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;DayNarrows&quot;);
285             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;AmPmMarkers&quot;);
286             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;narrow.AmPmMarkers&quot;);
287             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;abbreviated.AmPmMarkers&quot;);
288             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;QuarterNames&quot;);
289             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;QuarterAbbreviations&quot;);
290             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;QuarterNarrows&quot;);
291 
<span class="line-modified">292             adjustEraNames(myMap, parentsMap, calendarType);</span>
293 
294             handleDateTimeFormatPatterns(TIME_PATTERN_KEYS, myMap, parentsMap, calendarType, &quot;TimePatterns&quot;);
295             handleDateTimeFormatPatterns(DATE_PATTERN_KEYS, myMap, parentsMap, calendarType, &quot;DatePatterns&quot;);
296             handleDateTimeFormatPatterns(DATETIME_PATTERN_KEYS, myMap, parentsMap, calendarType, &quot;DateTimePatterns&quot;);
297         }
298 
299         // First, weed out any empty timezone or metazone names from myMap.
300         for (Iterator&lt;String&gt; it = myMap.keySet().iterator(); it.hasNext();) {
301             String key = it.next();
302             if (key.startsWith(CLDRConverter.TIMEZONE_ID_PREFIX)
303                     || key.startsWith(CLDRConverter.METAZONE_ID_PREFIX)) {
304                 @SuppressWarnings(&quot;unchecked&quot;)
305                 Map&lt;String, String&gt; nameMap = (Map&lt;String, String&gt;) myMap.get(key);
306                 if (nameMap.isEmpty()) {
307                     // Some zones have only exemplarCity, which become empty.
308                     // Remove those from the map.
309                     it.remove();
310                     continue;
311                 }
312             }
</pre>
<hr />
<pre>
396         if (format != null) {
397             map.remove(formatMapKey);
398             map.put(key, format);
399             if (fillInElements(parents, formatMapKey, format)) {
400                 map.remove(key);
401             }
402         }
403         String standaloneMapKey = key + &quot;/stand-alone&quot;;
404         Object standalone = map.get(standaloneMapKey);
405         if (standalone != null) {
406             map.remove(standaloneMapKey);
407             String standaloneResourceKey = &quot;standalone.&quot; + key;
408             map.put(standaloneResourceKey, standalone);
409             if (fillInElements(parents, standaloneMapKey, standalone)) {
410                 map.remove(standaloneResourceKey);
411             }
412         }
413     }
414 
415     /**
<span class="line-modified">416      * Fills in any empty elements with its parent element, falling back to</span>
<span class="line-modified">417      * aliased one if parent element is not found. Returns true if the resulting</span>
<span class="line-added">418      * array is identical to its parent array.</span>
419      *
420      * @param parents
421      * @param key
422      * @param value
423      * @return true if the resulting array is identical to its parent array.
424      */
425     private boolean fillInElements(Map&lt;String, Object&gt; parents, String key, Object value) {
426         if (parents == null) {
427             return false;
428         }
429         if (value instanceof String[]) {
<span class="line-modified">430             Object pvalue = parents.getOrDefault(key, parents.get(CLDRConverter.aliases.get(key)));</span>
431             if (pvalue != null &amp;&amp; pvalue instanceof String[]) {
432                 String[] strings = (String[]) value;
433                 String[] pstrings = (String[]) pvalue;
434                 for (int i = 0; i &lt; strings.length; i++) {
435                     if (strings[i] == null || strings[i].length() == 0) {
436                         strings[i] = pstrings[i];
437                     }
438                 }
439                 return Arrays.equals(strings, pstrings);
440             }
441         }
442         return false;
443     }
444 
445     /*
446      * Adjusts String[] for era names because JRE&#39;s Calendars use different
447      * ERA value indexes in the Buddhist, Japanese Imperial, and Islamic calendars.
448      */
<span class="line-modified">449     private void adjustEraNames(Map&lt;String, Object&gt; map, Map&lt;String, Object&gt; pMap, CalendarType type) {</span>
450         String[][] eraNames = new String[ERA_KEYS.length][];
451         String[] realKeys = new String[ERA_KEYS.length];
452         int index = 0;
453         for (String key : ERA_KEYS) {
454             String realKey = type.keyElementName() + key;
455             String[] value = (String[]) map.get(realKey);
456             if (value != null) {
<span class="line-added">457                 // first fill in missing elements from parents map.</span>
<span class="line-added">458                 fillInElements(pMap, realKey, value);</span>
<span class="line-added">459 </span>
460                 switch (type) {
461                 case GREGORIAN:
462                     break;
463 
464                 case JAPANESE:
465                     {
466                         String[] newValue = new String[value.length + 1];
467                         String[] julianEras = (String[]) map.get(key);
468                         if (julianEras != null &amp;&amp; julianEras.length &gt;= 2) {
469                             newValue[0] = julianEras[1];
470                         } else {
471                             newValue[0] = &quot;&quot;;
472                         }
473                         System.arraycopy(value, 0, newValue, 1, value.length);
474                         value = newValue;
475 
476                         // fix up &#39;Reiwa&#39; era, which can be missing in some locales
477                         if (value[value.length - 1] == null) {
478                             value[value.length - 1] = (key.startsWith(&quot;narrow.&quot;) ? &quot;R&quot; : &quot;Reiwa&quot;);
479                         }
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../netbeans/jmx/build.xml.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="CLDRConverter.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
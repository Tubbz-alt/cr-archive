<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/jdk/internal/misc/Unsafe.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../logger/LoggerWrapper.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../module/ModuleHashes.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/jdk/internal/misc/Unsafe.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 866 
 867         copySwapMemory0(srcBase, srcOffset, destBase, destOffset, bytes, elemSize);
 868     }
 869 
 870     private void copySwapMemoryChecks(Object srcBase, long srcOffset,
 871                                       Object destBase, long destOffset,
 872                                       long bytes, long elemSize) {
 873         checkSize(bytes);
 874 
 875         if (elemSize != 2 &amp;&amp; elemSize != 4 &amp;&amp; elemSize != 8) {
 876             throw invalidInput();
 877         }
 878         if (bytes % elemSize != 0) {
 879             throw invalidInput();
 880         }
 881 
 882         checkPrimitivePointer(srcBase, srcOffset);
 883         checkPrimitivePointer(destBase, destOffset);
 884     }
 885 
<span class="line-modified"> 886    /**</span>
 887      * Copies all elements from one block of memory to another block, byte swapping the
 888      * elements on the fly.
 889      *
 890      * This provides a &lt;em&gt;single-register&lt;/em&gt; addressing mode, as
 891      * discussed in {@link #getInt(Object,long)}.
 892      *
 893      * Equivalent to {@code copySwapMemory(null, srcAddress, null, destAddress, bytes, elemSize)}.
 894      */
 895     public void copySwapMemory(long srcAddress, long destAddress, long bytes, long elemSize) {
 896         copySwapMemory(null, srcAddress, null, destAddress, bytes, elemSize);
 897     }
 898 
 899     /**
 900      * Disposes of a block of native memory, as obtained from {@link
 901      * #allocateMemory} or {@link #reallocateMemory}.  The address passed to
 902      * this method may be null, in which case no action is taken.
 903      *
 904      * &lt;em&gt;Note:&lt;/em&gt; It is the responsibility of the caller to make
 905      * sure arguments are checked before the methods are called. While
 906      * some rudimentary checks are performed on the input, the checks
</pre>
<hr />
<pre>
2207 
2208     /** Acquire version of {@link #getFloatVolatile(Object, long)} */
2209     @HotSpotIntrinsicCandidate
2210     public final float getFloatAcquire(Object o, long offset) {
2211         return getFloatVolatile(o, offset);
2212     }
2213 
2214     /** Acquire version of {@link #getLongVolatile(Object, long)} */
2215     @HotSpotIntrinsicCandidate
2216     public final long getLongAcquire(Object o, long offset) {
2217         return getLongVolatile(o, offset);
2218     }
2219 
2220     /** Acquire version of {@link #getDoubleVolatile(Object, long)} */
2221     @HotSpotIntrinsicCandidate
2222     public final double getDoubleAcquire(Object o, long offset) {
2223         return getDoubleVolatile(o, offset);
2224     }
2225 
2226     /*
<span class="line-modified">2227       * Versions of {@link #putReferenceVolatile(Object, long, Object)}</span>
<span class="line-modified">2228       * that do not guarantee immediate visibility of the store to</span>
<span class="line-modified">2229       * other threads. This method is generally only useful if the</span>
<span class="line-modified">2230       * underlying field is a Java volatile (or if an array cell, one</span>
<span class="line-modified">2231       * that is otherwise only accessed using volatile accesses).</span>
<span class="line-modified">2232       *</span>
<span class="line-modified">2233       * Corresponds to C11 atomic_store_explicit(..., memory_order_release).</span>
<span class="line-modified">2234       */</span>
2235 
2236     /** Release version of {@link #putReferenceVolatile(Object, long, Object)} */
2237     @HotSpotIntrinsicCandidate
2238     public final void putReferenceRelease(Object o, long offset, Object x) {
2239         putReferenceVolatile(o, offset, x);
2240     }
2241 
2242     /** Release version of {@link #putBooleanVolatile(Object, long, boolean)} */
2243     @HotSpotIntrinsicCandidate
2244     public final void putBooleanRelease(Object o, long offset, boolean x) {
2245         putBooleanVolatile(o, offset, x);
2246     }
2247 
2248     /** Release version of {@link #putByteVolatile(Object, long, byte)} */
2249     @HotSpotIntrinsicCandidate
2250     public final void putByteRelease(Object o, long offset, byte x) {
2251         putByteVolatile(o, offset, x);
2252     }
2253 
2254     /** Release version of {@link #putShortVolatile(Object, long, short)} */
</pre>
</td>
<td>
<hr />
<pre>
 866 
 867         copySwapMemory0(srcBase, srcOffset, destBase, destOffset, bytes, elemSize);
 868     }
 869 
 870     private void copySwapMemoryChecks(Object srcBase, long srcOffset,
 871                                       Object destBase, long destOffset,
 872                                       long bytes, long elemSize) {
 873         checkSize(bytes);
 874 
 875         if (elemSize != 2 &amp;&amp; elemSize != 4 &amp;&amp; elemSize != 8) {
 876             throw invalidInput();
 877         }
 878         if (bytes % elemSize != 0) {
 879             throw invalidInput();
 880         }
 881 
 882         checkPrimitivePointer(srcBase, srcOffset);
 883         checkPrimitivePointer(destBase, destOffset);
 884     }
 885 
<span class="line-modified"> 886     /**</span>
 887      * Copies all elements from one block of memory to another block, byte swapping the
 888      * elements on the fly.
 889      *
 890      * This provides a &lt;em&gt;single-register&lt;/em&gt; addressing mode, as
 891      * discussed in {@link #getInt(Object,long)}.
 892      *
 893      * Equivalent to {@code copySwapMemory(null, srcAddress, null, destAddress, bytes, elemSize)}.
 894      */
 895     public void copySwapMemory(long srcAddress, long destAddress, long bytes, long elemSize) {
 896         copySwapMemory(null, srcAddress, null, destAddress, bytes, elemSize);
 897     }
 898 
 899     /**
 900      * Disposes of a block of native memory, as obtained from {@link
 901      * #allocateMemory} or {@link #reallocateMemory}.  The address passed to
 902      * this method may be null, in which case no action is taken.
 903      *
 904      * &lt;em&gt;Note:&lt;/em&gt; It is the responsibility of the caller to make
 905      * sure arguments are checked before the methods are called. While
 906      * some rudimentary checks are performed on the input, the checks
</pre>
<hr />
<pre>
2207 
2208     /** Acquire version of {@link #getFloatVolatile(Object, long)} */
2209     @HotSpotIntrinsicCandidate
2210     public final float getFloatAcquire(Object o, long offset) {
2211         return getFloatVolatile(o, offset);
2212     }
2213 
2214     /** Acquire version of {@link #getLongVolatile(Object, long)} */
2215     @HotSpotIntrinsicCandidate
2216     public final long getLongAcquire(Object o, long offset) {
2217         return getLongVolatile(o, offset);
2218     }
2219 
2220     /** Acquire version of {@link #getDoubleVolatile(Object, long)} */
2221     @HotSpotIntrinsicCandidate
2222     public final double getDoubleAcquire(Object o, long offset) {
2223         return getDoubleVolatile(o, offset);
2224     }
2225 
2226     /*
<span class="line-modified">2227      * Versions of {@link #putReferenceVolatile(Object, long, Object)}</span>
<span class="line-modified">2228      * that do not guarantee immediate visibility of the store to</span>
<span class="line-modified">2229      * other threads. This method is generally only useful if the</span>
<span class="line-modified">2230      * underlying field is a Java volatile (or if an array cell, one</span>
<span class="line-modified">2231      * that is otherwise only accessed using volatile accesses).</span>
<span class="line-modified">2232      *</span>
<span class="line-modified">2233      * Corresponds to C11 atomic_store_explicit(..., memory_order_release).</span>
<span class="line-modified">2234      */</span>
2235 
2236     /** Release version of {@link #putReferenceVolatile(Object, long, Object)} */
2237     @HotSpotIntrinsicCandidate
2238     public final void putReferenceRelease(Object o, long offset, Object x) {
2239         putReferenceVolatile(o, offset, x);
2240     }
2241 
2242     /** Release version of {@link #putBooleanVolatile(Object, long, boolean)} */
2243     @HotSpotIntrinsicCandidate
2244     public final void putBooleanRelease(Object o, long offset, boolean x) {
2245         putBooleanVolatile(o, offset, x);
2246     }
2247 
2248     /** Release version of {@link #putByteVolatile(Object, long, byte)} */
2249     @HotSpotIntrinsicCandidate
2250     public final void putByteRelease(Object o, long offset, byte x) {
2251         putByteVolatile(o, offset, x);
2252     }
2253 
2254     /** Release version of {@link #putShortVolatile(Object, long, short)} */
</pre>
</td>
</tr>
</table>
<center><a href="../logger/LoggerWrapper.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../module/ModuleHashes.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
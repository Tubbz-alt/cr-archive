<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/lang/Class.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="Character.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ClassLoader.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/Class.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 137,16 ***</span>
   *                            &quot; is &quot; + obj.getClass().getName());
   *     }
   * &lt;/pre&gt;&lt;/blockquote&gt;
   *
   * &lt;p&gt; It is also possible to get the {@code Class} object for a named
<span class="line-modified">!  * type (or for void) using a class literal.  See Section 15.8.2 of</span>
<span class="line-modified">!  * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.</span>
   * For example:
   *
   * &lt;blockquote&gt;
<span class="line-modified">!  *     {@code System.out.println(&quot;The name of class Foo is: &quot;+Foo.class.getName());}</span>
   * &lt;/blockquote&gt;
   *
   * @param &lt;T&gt; the type of the class modeled by this {@code Class}
   * object.  For example, the type of {@code String.class} is {@code
   * Class&lt;String&gt;}.  Use {@code Class&lt;?&gt;} if the class being modeled is
<span class="line-new-header">--- 137,16 ---</span>
   *                            &quot; is &quot; + obj.getClass().getName());
   *     }
   * &lt;/pre&gt;&lt;/blockquote&gt;
   *
   * &lt;p&gt; It is also possible to get the {@code Class} object for a named
<span class="line-modified">!  * type (or for void) using a class literal.  See Section {@jls</span>
<span class="line-modified">!  * 15.8.2} of &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.</span>
   * For example:
   *
   * &lt;blockquote&gt;
<span class="line-modified">!  *     {@code System.out.println(&quot;The name of class Foo is: &quot; + Foo.class.getName());}</span>
   * &lt;/blockquote&gt;
   *
   * @param &lt;T&gt; the type of the class modeled by this {@code Class}
   * object.  For example, the type of {@code String.class} is {@code
   * Class&lt;String&gt;}.  Use {@code Class&lt;?&gt;} if the class being modeled is
</pre>
<hr />
<pre>
<span class="line-old-header">*** 191,11 ***</span>
       * primitive type, this method returns the name of the primitive type.  If
       * this {@code Class} object represents void this method returns
       * &quot;void&quot;. If this {@code Class} object represents an array type,
       * this method returns &quot;class &quot; followed by {@code getName}.
       *
<span class="line-modified">!      * @return a string representation of this class object.</span>
       */
      public String toString() {
          return (isInterface() ? &quot;interface &quot; : (isPrimitive() ? &quot;&quot; : &quot;class &quot;))
              + getName();
      }
<span class="line-new-header">--- 191,11 ---</span>
       * primitive type, this method returns the name of the primitive type.  If
       * this {@code Class} object represents void this method returns
       * &quot;void&quot;. If this {@code Class} object represents an array type,
       * this method returns &quot;class &quot; followed by {@code getName}.
       *
<span class="line-modified">!      * @return a string representation of this {@code Class} object.</span>
       */
      public String toString() {
          return (isInterface() ? &quot;interface &quot; : (isPrimitive() ? &quot;&quot; : &quot;class &quot;))
              + getName();
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 205,11 ***</span>
       * information about modifiers and type parameters.
       *
       * The string is formatted as a list of type modifiers, if any,
       * followed by the kind of type (empty string for primitive types
       * and {@code class}, {@code enum}, {@code interface},
<span class="line-modified">!      * &lt;code&gt;&amp;#64;&lt;/code&gt;{@code interface}, or {@code record} as appropriate), followed</span>
       * by the type&#39;s name, followed by an angle-bracketed
       * comma-separated list of the type&#39;s type parameters, if any,
       * including informative bounds on the type parameters, if any.
       *
       * A space is used to separate modifiers from one another and to
<span class="line-new-header">--- 205,11 ---</span>
       * information about modifiers and type parameters.
       *
       * The string is formatted as a list of type modifiers, if any,
       * followed by the kind of type (empty string for primitive types
       * and {@code class}, {@code enum}, {@code interface},
<span class="line-modified">!      * {@code @interface}, or {@code record} as appropriate), followed</span>
       * by the type&#39;s name, followed by an angle-bracketed
       * comma-separated list of the type&#39;s type parameters, if any,
       * including informative bounds on the type parameters, if any.
       *
       * A space is used to separate modifiers from one another and to
</pre>
<hr />
<pre>
<span class="line-old-header">*** 374,18 ***</span>
       *  {@code Class.forName(&quot;Foo&quot;, true, this.getClass().getClassLoader())}
       * &lt;/blockquote&gt;
       *
       * Note that this method throws errors related to loading, linking
       * or initializing as specified in Sections {@jls 12.2}, {@jls
<span class="line-modified">!      * 12.3}, and {@jls 12.4} of &lt;em&gt;The Java Language</span>
<span class="line-modified">!      * Specification&lt;/em&gt;.</span>
       * Note that this method does not check whether the requested class
       * is accessible to its caller.
       *
       * @param name       fully qualified name of the desired class
<span class="line-modified">!      * @param initialize if {@code true} the class will be initialized (which implies linking).</span>
<span class="line-modified">!      *                   See Section {@jls 12.4} of &lt;em&gt;The Java Language Specification&lt;/em&gt;.</span>
       * @param loader     class loader from which the class must be loaded
       * @return           class object representing the desired class
       *
       * @throws    LinkageError if the linkage fails
       * @throws    ExceptionInInitializerError if the initialization provoked
<span class="line-new-header">--- 374,21 ---</span>
       *  {@code Class.forName(&quot;Foo&quot;, true, this.getClass().getClassLoader())}
       * &lt;/blockquote&gt;
       *
       * Note that this method throws errors related to loading, linking
       * or initializing as specified in Sections {@jls 12.2}, {@jls
<span class="line-modified">!      * 12.3}, and {@jls 12.4} of &lt;cite&gt;The Java&amp;trade; Language</span>
<span class="line-modified">!      * Specification&lt;/cite&gt;.</span>
       * Note that this method does not check whether the requested class
       * is accessible to its caller.
       *
       * @param name       fully qualified name of the desired class
<span class="line-modified">! </span>
<span class="line-modified">!      * @param initialize if {@code true} the class will be initialized</span>
<span class="line-added">+      *                   (which implies linking). See Section {@jls</span>
<span class="line-added">+      *                   12.4} of &lt;cite&gt;The Java&amp;trade; Language</span>
<span class="line-added">+      *                   Specification&lt;/cite&gt;.</span>
       * @param loader     class loader from which the class must be loaded
       * @return           class object representing the desired class
       *
       * @throws    LinkageError if the linkage fails
       * @throws    ExceptionInInitializerError if the initialization provoked
</pre>
<hr />
<pre>
<span class="line-old-header">*** 658,12 ***</span>
       * {@code false}.
       *
       * &lt;p&gt; Specifically, this method tests whether the type represented by the
       * specified {@code Class} parameter can be converted to the type
       * represented by this {@code Class} object via an identity conversion
<span class="line-modified">!      * or via a widening reference conversion. See &lt;em&gt;The Java Language</span>
<span class="line-modified">!      * Specification&lt;/em&gt;, sections {@jls 5.1.1} and {@jls 5.1.4},</span>
       * for details.
       *
       * @param     cls the {@code Class} object to be checked
       * @return    the {@code boolean} value indicating whether objects of the
       *            type {@code cls} can be assigned to objects of this class
<span class="line-new-header">--- 661,12 ---</span>
       * {@code false}.
       *
       * &lt;p&gt; Specifically, this method tests whether the type represented by the
       * specified {@code Class} parameter can be converted to the type
       * represented by this {@code Class} object via an identity conversion
<span class="line-modified">!      * or via a widening reference conversion. See &lt;cite&gt;The Java&amp;trade; Language</span>
<span class="line-modified">!      * Specification&lt;/cite&gt;, sections {@jls 5.1.1} and {@jls 5.1.4},</span>
       * for details.
       *
       * @param     cls the {@code Class} object to be checked
       * @return    the {@code boolean} value indicating whether objects of the
       *            type {@code cls} can be assigned to objects of this class
</pre>
<hr />
<pre>
<span class="line-old-header">*** 674,24 ***</span>
      @HotSpotIntrinsicCandidate
      public native boolean isAssignableFrom(Class&lt;?&gt; cls);
  
  
      /**
<span class="line-modified">!      * Determines if the specified {@code Class} object represents an</span>
       * interface type.
       *
<span class="line-modified">!      * @return  {@code true} if this object represents an interface;</span>
       *          {@code false} otherwise.
       */
      @HotSpotIntrinsicCandidate
      public native boolean isInterface();
  
  
      /**
       * Determines if this {@code Class} object represents an array class.
       *
<span class="line-modified">!      * @return  {@code true} if this object represents an array class;</span>
       *          {@code false} otherwise.
       * @since   1.1
       */
      @HotSpotIntrinsicCandidate
      public native boolean isArray();
<span class="line-new-header">--- 677,24 ---</span>
      @HotSpotIntrinsicCandidate
      public native boolean isAssignableFrom(Class&lt;?&gt; cls);
  
  
      /**
<span class="line-modified">!      * Determines if this {@code Class} object represents an</span>
       * interface type.
       *
<span class="line-modified">!      * @return  {@code true} if this {@code Class} object represents an interface;</span>
       *          {@code false} otherwise.
       */
      @HotSpotIntrinsicCandidate
      public native boolean isInterface();
  
  
      /**
       * Determines if this {@code Class} object represents an array class.
       *
<span class="line-modified">!      * @return  {@code true} if this {@code Class} object represents an array class;</span>
       *          {@code false} otherwise.
       * @since   1.1
       */
      @HotSpotIntrinsicCandidate
      public native boolean isArray();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 731,11 ***</span>
      /**
       * Returns true if this {@code Class} object represents an annotation
       * type.  Note that if this method returns true, {@link #isInterface()}
       * would also return true, as all annotation types are also interfaces.
       *
<span class="line-modified">!      * @return {@code true} if this class object represents an annotation</span>
       *      type; {@code false} otherwise
       * @since 1.5
       */
      public boolean isAnnotation() {
          return (getModifiers() &amp; ANNOTATION) != 0;
<span class="line-new-header">--- 734,11 ---</span>
      /**
       * Returns true if this {@code Class} object represents an annotation
       * type.  Note that if this method returns true, {@link #isInterface()}
       * would also return true, as all annotation types are also interfaces.
       *
<span class="line-modified">!      * @return {@code true} if this {@code Class} object represents an annotation</span>
       *      type; {@code false} otherwise
       * @since 1.5
       */
      public boolean isAnnotation() {
          return (getModifiers() &amp; ANNOTATION) != 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 743,11 ***</span>
  
      /**
       * Returns {@code true} if this class is a synthetic class;
       * returns {@code false} otherwise.
       * @return {@code true} if and only if this class is a synthetic class as
<span class="line-modified">!      *         defined by the Java Language Specification.</span>
       * @jls 13.1 The Form of a Binary
       * @since 1.5
       */
      public boolean isSynthetic() {
          return (getModifiers() &amp; SYNTHETIC) != 0;
<span class="line-new-header">--- 746,11 ---</span>
  
      /**
       * Returns {@code true} if this class is a synthetic class;
       * returns {@code false} otherwise.
       * @return {@code true} if and only if this class is a synthetic class as
<span class="line-modified">!      *         defined by &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.</span>
       * @jls 13.1 The Form of a Binary
       * @since 1.5
       */
      public boolean isSynthetic() {
          return (getModifiers() &amp; SYNTHETIC) != 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 756,20 ***</span>
      /**
       * Returns the  name of the entity (class, interface, array class,
       * primitive type, or void) represented by this {@code Class} object,
       * as a {@code String}.
       *
<span class="line-modified">!      * &lt;p&gt; If this class object represents a reference type that is not an</span>
<span class="line-modified">!      * array type then the binary name of the class is returned, as specified</span>
<span class="line-modified">!      * by</span>
<span class="line-modified">!      * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.</span>
       *
<span class="line-modified">!      * &lt;p&gt; If this class object represents a primitive type or void, then the</span>
       * name returned is a {@code String} equal to the Java language
       * keyword corresponding to the primitive type or void.
       *
<span class="line-modified">!      * &lt;p&gt; If this class object represents a class of arrays, then the internal</span>
       * form of the name consists of the name of the element type preceded by
       * one or more &#39;{@code [}&#39; characters representing the depth of the array
       * nesting.  The encoding of element type names is as follows:
       *
       * &lt;blockquote&gt;&lt;table class=&quot;striped&quot;&gt;
<span class="line-new-header">--- 759,20 ---</span>
      /**
       * Returns the  name of the entity (class, interface, array class,
       * primitive type, or void) represented by this {@code Class} object,
       * as a {@code String}.
       *
<span class="line-modified">!      * &lt;p&gt; If this {@code Class} object represents a reference type that is</span>
<span class="line-modified">!      * not an array type then the binary name of the class is</span>
<span class="line-modified">!      * returned, as specified by &lt;cite&gt;The Java&amp;trade; Language</span>
<span class="line-modified">!      * Specification&lt;/cite&gt;.</span>
       *
<span class="line-modified">!      * &lt;p&gt; If this {@code Class} object represents a primitive type or void, then the</span>
       * name returned is a {@code String} equal to the Java language
       * keyword corresponding to the primitive type or void.
       *
<span class="line-modified">!      * &lt;p&gt; If this {@code Class} object represents a class of arrays, then the internal</span>
       * form of the name consists of the name of the element type preceded by
       * one or more &#39;{@code [}&#39; characters representing the depth of the array
       * nesting.  The encoding of element type names is as follows:
       *
       * &lt;blockquote&gt;&lt;table class=&quot;striped&quot;&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 805,11 ***</span>
       * (new int[3][4][5][6][7][8][9]).getClass().getName()
       *     returns &quot;[[[[[[[I&quot;
       * &lt;/pre&gt;&lt;/blockquote&gt;
       *
       * @return  the name of the class or interface
<span class="line-modified">!      *          represented by this object.</span>
       */
      public String getName() {
          String name = this.name;
          return name != null ? name : initClassName();
      }
<span class="line-new-header">--- 808,11 ---</span>
       * (new int[3][4][5][6][7][8][9]).getClass().getName()
       *     returns &quot;[[[[[[[I&quot;
       * &lt;/pre&gt;&lt;/blockquote&gt;
       *
       * @return  the name of the class or interface
<span class="line-modified">!      *          represented by this {@code Class} object.</span>
       */
      public String getName() {
          String name = this.name;
          return name != null ? name : initClassName();
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 823,15 ***</span>
       * Returns the class loader for the class.  Some implementations may use
       * null to represent the bootstrap class loader. This method will return
       * null in such implementations if this class was loaded by the bootstrap
       * class loader.
       *
<span class="line-modified">!      * &lt;p&gt;If this object</span>
       * represents a primitive type or void, null is returned.
       *
       * @return  the class loader that loaded the class or interface
<span class="line-modified">!      *          represented by this object.</span>
       * @throws  SecurityException
       *          if a security manager is present, and the caller&#39;s class loader
       *          is not {@code null} and is not the same as or an ancestor of the
       *          class loader for the class whose class loader is requested,
       *          and the caller does not have the
<span class="line-new-header">--- 826,15 ---</span>
       * Returns the class loader for the class.  Some implementations may use
       * null to represent the bootstrap class loader. This method will return
       * null in such implementations if this class was loaded by the bootstrap
       * class loader.
       *
<span class="line-modified">!      * &lt;p&gt;If this {@code Class} object</span>
       * represents a primitive type or void, null is returned.
       *
       * @return  the class loader that loaded the class or interface
<span class="line-modified">!      *          represented by this {@code Class} object.</span>
       * @throws  SecurityException
       *          if a security manager is present, and the caller&#39;s class loader
       *          is not {@code null} and is not the same as or an ancestor of the
       *          class loader for the class whose class loader is requested,
       *          and the caller does not have the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 894,12 ***</span>
       *
       * @return an array of {@code TypeVariable} objects that represent
       *     the type variables declared by this generic declaration
       * @throws java.lang.reflect.GenericSignatureFormatError if the generic
       *     signature of this generic declaration does not conform to
<span class="line-modified">!      *     the format specified in</span>
<span class="line-modified">!      *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;</span>
       * @since 1.5
       */
      @SuppressWarnings(&quot;unchecked&quot;)
      public TypeVariable&lt;Class&lt;T&gt;&gt;[] getTypeParameters() {
          ClassRepository info = getGenericInfo();
<span class="line-new-header">--- 897,12 ---</span>
       *
       * @return an array of {@code TypeVariable} objects that represent
       *     the type variables declared by this generic declaration
       * @throws java.lang.reflect.GenericSignatureFormatError if the generic
       *     signature of this generic declaration does not conform to
<span class="line-modified">!      *     the format specified in section {@jvms 4.7.9} of</span>
<span class="line-modified">!      *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;,</span>
       * @since 1.5
       */
      @SuppressWarnings(&quot;unchecked&quot;)
      public TypeVariable&lt;Class&lt;T&gt;&gt;[] getTypeParameters() {
          ClassRepository info = getGenericInfo();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 913,47 ***</span>
      /**
       * Returns the {@code Class} representing the direct superclass of the
       * entity (class, interface, primitive type or void) represented by
       * this {@code Class}.  If this {@code Class} represents either the
       * {@code Object} class, an interface, a primitive type, or void, then
<span class="line-modified">!      * null is returned.  If this object represents an array class then the</span>
<span class="line-modified">!      * {@code Class} object representing the {@code Object} class is</span>
       * returned.
       *
<span class="line-modified">!      * @return the direct superclass of the class represented by this object</span>
       */
      @HotSpotIntrinsicCandidate
      public native Class&lt;? super T&gt; getSuperclass();
  
  
      /**
       * Returns the {@code Type} representing the direct superclass of
       * the entity (class, interface, primitive type or void) represented by
<span class="line-modified">!      * this {@code Class}.</span>
       *
       * &lt;p&gt;If the superclass is a parameterized type, the {@code Type}
       * object returned must accurately reflect the actual type
       * arguments used in the source code. The parameterized type
       * representing the superclass is created if it had not been
       * created before. See the declaration of {@link
       * java.lang.reflect.ParameterizedType ParameterizedType} for the
       * semantics of the creation process for parameterized types.  If
<span class="line-modified">!      * this {@code Class} represents either the {@code Object}</span>
       * class, an interface, a primitive type, or void, then null is
<span class="line-modified">!      * returned.  If this object represents an array class then the</span>
<span class="line-modified">!      * {@code Class} object representing the {@code Object} class is</span>
       * returned.
       *
       * @throws java.lang.reflect.GenericSignatureFormatError if the generic
       *     class signature does not conform to the format specified in
<span class="line-modified">!      *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;</span>
       * @throws TypeNotPresentException if the generic superclass
       *     refers to a non-existent type declaration
       * @throws java.lang.reflect.MalformedParameterizedTypeException if the
       *     generic superclass refers to a parameterized type that cannot be
       *     instantiated  for any reason
<span class="line-modified">!      * @return the direct superclass of the class represented by this object</span>
       * @since 1.5
       */
      public Type getGenericSuperclass() {
          ClassRepository info = getGenericInfo();
          if (info == null) {
<span class="line-new-header">--- 916,48 ---</span>
      /**
       * Returns the {@code Class} representing the direct superclass of the
       * entity (class, interface, primitive type or void) represented by
       * this {@code Class}.  If this {@code Class} represents either the
       * {@code Object} class, an interface, a primitive type, or void, then
<span class="line-modified">!      * null is returned.  If this {@code Class} object represents an array class</span>
<span class="line-modified">!      * then the {@code Class} object representing the {@code Object} class is</span>
       * returned.
       *
<span class="line-modified">!      * @return the direct superclass of the class represented by this {@code Class} object</span>
       */
      @HotSpotIntrinsicCandidate
      public native Class&lt;? super T&gt; getSuperclass();
  
  
      /**
       * Returns the {@code Type} representing the direct superclass of
       * the entity (class, interface, primitive type or void) represented by
<span class="line-modified">!      * this {@code Class} object.</span>
       *
       * &lt;p&gt;If the superclass is a parameterized type, the {@code Type}
       * object returned must accurately reflect the actual type
       * arguments used in the source code. The parameterized type
       * representing the superclass is created if it had not been
       * created before. See the declaration of {@link
       * java.lang.reflect.ParameterizedType ParameterizedType} for the
       * semantics of the creation process for parameterized types.  If
<span class="line-modified">!      * this {@code Class} object represents either the {@code Object}</span>
       * class, an interface, a primitive type, or void, then null is
<span class="line-modified">!      * returned.  If this {@code Class} object represents an array class</span>
<span class="line-modified">!      * then the {@code Class} object representing the {@code Object} class is</span>
       * returned.
       *
       * @throws java.lang.reflect.GenericSignatureFormatError if the generic
       *     class signature does not conform to the format specified in
<span class="line-modified">!      *     section {@jvms 4.7.9} of &lt;cite&gt;The Java&amp;trade; Virtual</span>
<span class="line-added">+      *     Machine Specification&lt;/cite&gt;</span>
       * @throws TypeNotPresentException if the generic superclass
       *     refers to a non-existent type declaration
       * @throws java.lang.reflect.MalformedParameterizedTypeException if the
       *     generic superclass refers to a parameterized type that cannot be
       *     instantiated  for any reason
<span class="line-modified">!      * @return the direct superclass of the class represented by this {@code Class} object</span>
       * @since 1.5
       */
      public Type getGenericSuperclass() {
          ClassRepository info = getGenericInfo();
          if (info == null) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1038,17 ***</span>
      // cached package name
      private transient String packageName;
  
      /**
       * Returns the interfaces directly implemented by the class or interface
<span class="line-modified">!      * represented by this object.</span>
       *
<span class="line-modified">!      * &lt;p&gt;If this object represents a class, the return value is an array</span>
       * containing objects representing all interfaces directly implemented by
       * the class.  The order of the interface objects in the array corresponds
       * to the order of the interface names in the {@code implements} clause of
<span class="line-modified">!      * the declaration of the class represented by this object.  For example,</span>
       * given the declaration:
       * &lt;blockquote&gt;
       * {@code class Shimmer implements FloorWax, DessertTopping { ... }}
       * &lt;/blockquote&gt;
       * suppose the value of {@code s} is an instance of
<span class="line-new-header">--- 1042,17 ---</span>
      // cached package name
      private transient String packageName;
  
      /**
       * Returns the interfaces directly implemented by the class or interface
<span class="line-modified">!      * represented by this {@code Class} object.</span>
       *
<span class="line-modified">!      * &lt;p&gt;If this {@code Class} object represents a class, the return value is an array</span>
       * containing objects representing all interfaces directly implemented by
       * the class.  The order of the interface objects in the array corresponds
       * to the order of the interface names in the {@code implements} clause of
<span class="line-modified">!      * the declaration of the class represented by this {@code Class} object.  For example,</span>
       * given the declaration:
       * &lt;blockquote&gt;
       * {@code class Shimmer implements FloorWax, DessertTopping { ... }}
       * &lt;/blockquote&gt;
       * suppose the value of {@code s} is an instance of
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1062,20 ***</span>
       * {@code s.getClass().getInterfaces()[1]}
       * &lt;/blockquote&gt;
       * is the {@code Class} object that represents interface
       * {@code DessertTopping}.
       *
<span class="line-modified">!      * &lt;p&gt;If this object represents an interface, the array contains objects</span>
       * representing all interfaces directly extended by the interface.  The
       * order of the interface objects in the array corresponds to the order of
       * the interface names in the {@code extends} clause of the declaration of
<span class="line-modified">!      * the interface represented by this object.</span>
       *
<span class="line-modified">!      * &lt;p&gt;If this object represents a class or interface that implements no</span>
       * interfaces, the method returns an array of length 0.
       *
<span class="line-modified">!      * &lt;p&gt;If this object represents a primitive type or void, the method</span>
       * returns an array of length 0.
       *
       * &lt;p&gt;If this {@code Class} object represents an array type, the
       * interfaces {@code Cloneable} and {@code java.io.Serializable} are
       * returned in that order.
<span class="line-new-header">--- 1066,20 ---</span>
       * {@code s.getClass().getInterfaces()[1]}
       * &lt;/blockquote&gt;
       * is the {@code Class} object that represents interface
       * {@code DessertTopping}.
       *
<span class="line-modified">!      * &lt;p&gt;If this {@code Class} object represents an interface, the array contains objects</span>
       * representing all interfaces directly extended by the interface.  The
       * order of the interface objects in the array corresponds to the order of
       * the interface names in the {@code extends} clause of the declaration of
<span class="line-modified">!      * the interface represented by this {@code Class} object.</span>
       *
<span class="line-modified">!      * &lt;p&gt;If this {@code Class} object represents a class or interface that implements no</span>
       * interfaces, the method returns an array of length 0.
       *
<span class="line-modified">!      * &lt;p&gt;If this {@code Class} object represents a primitive type or void, the method</span>
       * returns an array of length 0.
       *
       * &lt;p&gt;If this {@code Class} object represents an array type, the
       * interfaces {@code Cloneable} and {@code java.io.Serializable} are
       * returned in that order.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1106,47 ***</span>
      private native Class&lt;?&gt;[] getInterfaces0();
  
      /**
       * Returns the {@code Type}s representing the interfaces
       * directly implemented by the class or interface represented by
<span class="line-modified">!      * this object.</span>
       *
       * &lt;p&gt;If a superinterface is a parameterized type, the
       * {@code Type} object returned for it must accurately reflect
       * the actual type arguments used in the source code. The
       * parameterized type representing each superinterface is created
       * if it had not been created before. See the declaration of
       * {@link java.lang.reflect.ParameterizedType ParameterizedType}
       * for the semantics of the creation process for parameterized
       * types.
       *
<span class="line-modified">!      * &lt;p&gt;If this object represents a class, the return value is an array</span>
       * containing objects representing all interfaces directly implemented by
       * the class.  The order of the interface objects in the array corresponds
       * to the order of the interface names in the {@code implements} clause of
<span class="line-modified">!      * the declaration of the class represented by this object.</span>
       *
<span class="line-modified">!      * &lt;p&gt;If this object represents an interface, the array contains objects</span>
       * representing all interfaces directly extended by the interface.  The
       * order of the interface objects in the array corresponds to the order of
       * the interface names in the {@code extends} clause of the declaration of
<span class="line-modified">!      * the interface represented by this object.</span>
       *
<span class="line-modified">!      * &lt;p&gt;If this object represents a class or interface that implements no</span>
       * interfaces, the method returns an array of length 0.
       *
<span class="line-modified">!      * &lt;p&gt;If this object represents a primitive type or void, the method</span>
       * returns an array of length 0.
       *
       * &lt;p&gt;If this {@code Class} object represents an array type, the
       * interfaces {@code Cloneable} and {@code java.io.Serializable} are
       * returned in that order.
       *
       * @throws java.lang.reflect.GenericSignatureFormatError
<span class="line-modified">!      *     if the generic class signature does not conform to the format</span>
<span class="line-modified">!      *     specified in</span>
<span class="line-modified">!      *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;</span>
       * @throws TypeNotPresentException if any of the generic
       *     superinterfaces refers to a non-existent type declaration
       * @throws java.lang.reflect.MalformedParameterizedTypeException
       *     if any of the generic superinterfaces refer to a parameterized
       *     type that cannot be instantiated for any reason
<span class="line-new-header">--- 1110,47 ---</span>
      private native Class&lt;?&gt;[] getInterfaces0();
  
      /**
       * Returns the {@code Type}s representing the interfaces
       * directly implemented by the class or interface represented by
<span class="line-modified">!      * this {@code Class} object.</span>
       *
       * &lt;p&gt;If a superinterface is a parameterized type, the
       * {@code Type} object returned for it must accurately reflect
       * the actual type arguments used in the source code. The
       * parameterized type representing each superinterface is created
       * if it had not been created before. See the declaration of
       * {@link java.lang.reflect.ParameterizedType ParameterizedType}
       * for the semantics of the creation process for parameterized
       * types.
       *
<span class="line-modified">!      * &lt;p&gt;If this {@code Class} object represents a class, the return value is an array</span>
       * containing objects representing all interfaces directly implemented by
       * the class.  The order of the interface objects in the array corresponds
       * to the order of the interface names in the {@code implements} clause of
<span class="line-modified">!      * the declaration of the class represented by this {@code Class} object.</span>
       *
<span class="line-modified">!      * &lt;p&gt;If this {@code Class} object represents an interface, the array contains objects</span>
       * representing all interfaces directly extended by the interface.  The
       * order of the interface objects in the array corresponds to the order of
       * the interface names in the {@code extends} clause of the declaration of
<span class="line-modified">!      * the interface represented by this {@code Class} object.</span>
       *
<span class="line-modified">!      * &lt;p&gt;If this {@code Class} object represents a class or interface that implements no</span>
       * interfaces, the method returns an array of length 0.
       *
<span class="line-modified">!      * &lt;p&gt;If this {@code Class} object represents a primitive type or void, the method</span>
       * returns an array of length 0.
       *
       * &lt;p&gt;If this {@code Class} object represents an array type, the
       * interfaces {@code Cloneable} and {@code java.io.Serializable} are
       * returned in that order.
       *
       * @throws java.lang.reflect.GenericSignatureFormatError
<span class="line-modified">!      *     if the generic class signature does not conform to the</span>
<span class="line-modified">!      *     format specified in section {@jvms 4.7.9} of &lt;cite&gt;The</span>
<span class="line-modified">!      *     Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;</span>
       * @throws TypeNotPresentException if any of the generic
       *     superinterfaces refers to a non-existent type declaration
       * @throws java.lang.reflect.MalformedParameterizedTypeException
       *     if any of the generic superinterfaces refer to a parameterized
       *     type that cannot be instantiated for any reason
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1190,21 ***</span>
       * using the methods of class {@code Modifier}.
       *
       * &lt;p&gt; If the underlying class is an array class, then its
       * {@code public}, {@code private} and {@code protected}
       * modifiers are the same as those of its component type.  If this
<span class="line-modified">!      * {@code Class} represents a primitive type or void, its</span>
       * {@code public} modifier is always {@code true}, and its
       * {@code protected} and {@code private} modifiers are always
<span class="line-modified">!      * {@code false}. If this object represents an array class, a</span>
       * primitive type or void, then its {@code final} modifier is always
       * {@code true} and its interface modifier is always
       * {@code false}. The values of its other modifiers are not determined
       * by this specification.
       *
<span class="line-modified">!      * &lt;p&gt; The modifier encodings are defined in &lt;em&gt;The Java Virtual Machine</span>
<span class="line-modified">!      * Specification&lt;/em&gt;, table 4.1.</span>
       *
       * @return the {@code int} representing the modifiers for this class
       * @see     java.lang.reflect.Modifier
       * @since 1.1
       */
<span class="line-new-header">--- 1194,21 ---</span>
       * using the methods of class {@code Modifier}.
       *
       * &lt;p&gt; If the underlying class is an array class, then its
       * {@code public}, {@code private} and {@code protected}
       * modifiers are the same as those of its component type.  If this
<span class="line-modified">!      * {@code Class} object represents a primitive type or void, its</span>
       * {@code public} modifier is always {@code true}, and its
       * {@code protected} and {@code private} modifiers are always
<span class="line-modified">!      * {@code false}. If this {@code Class} object represents an array class, a</span>
       * primitive type or void, then its {@code final} modifier is always
       * {@code true} and its interface modifier is always
       * {@code false}. The values of its other modifiers are not determined
       * by this specification.
       *
<span class="line-modified">!      * &lt;p&gt; The modifier encodings are defined in section {@jvms 4.1}</span>
<span class="line-modified">!      * of &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;.</span>
       *
       * @return the {@code int} representing the modifiers for this class
       * @see     java.lang.reflect.Modifier
       * @since 1.1
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1214,11 ***</span>
  
      /**
       * Gets the signers of this class.
       *
       * @return  the signers of this class, or null if there are no signers.  In
<span class="line-modified">!      *          particular, this method returns null if this object represents</span>
       *          a primitive type or void.
       * @since   1.1
       */
      public native Object[] getSigners();
  
<span class="line-new-header">--- 1218,11 ---</span>
  
      /**
       * Gets the signers of this class.
       *
       * @return  the signers of this class, or null if there are no signers.  In
<span class="line-modified">!      *          particular, this method returns null if this {@code Class} object represents</span>
       *          a primitive type or void.
       * @since   1.1
       */
      public native Object[] getSigners();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1608,15 ***</span>
          }
          return getName();
      }
  
      /**
<span class="line-modified">!      * Returns the canonical name of the underlying class as</span>
<span class="line-modified">!      * defined by the Java Language Specification.  Returns null if</span>
<span class="line-modified">!      * the underlying class does not have a canonical name (i.e., if</span>
<span class="line-modified">!      * it is a local or anonymous class or an array whose component</span>
<span class="line-modified">!      * type does not have a canonical name).</span>
       * @return the canonical name of the underlying class if it exists, and
       * {@code null} otherwise.
       * @since 1.5
       */
      public String getCanonicalName() {
<span class="line-new-header">--- 1612,15 ---</span>
          }
          return getName();
      }
  
      /**
<span class="line-modified">!      * Returns the canonical name of the underlying class as defined</span>
<span class="line-modified">!      * by &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;, section</span>
<span class="line-modified">!      * {@jls 6.7}.  Returns null if the underlying class does not have</span>
<span class="line-modified">!      * a canonical name (i.e., if it is a local or anonymous class or</span>
<span class="line-modified">!      * an array whose component type does not have a canonical name).</span>
       * @return the canonical name of the underlying class if it exists, and
       * {@code null} otherwise.
       * @since 1.5
       */
      public String getCanonicalName() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1926,11 ***</span>
       * all the public constructors of the class represented by this
       * {@code Class} object.  An array of length 0 is returned if the
       * class has no public constructors, or if the class is an array class, or
       * if the class reflects a primitive type or void.
       *
<span class="line-modified">!      * Note that while this method returns an array of {@code</span>
       * Constructor&lt;T&gt;} objects (that is an array of constructors from
       * this class), the return type of this method is {@code
       * Constructor&lt;?&gt;[]} and &lt;em&gt;not&lt;/em&gt; {@code Constructor&lt;T&gt;[]} as
       * might be expected.  This less informative return type is
       * necessary since after being returned from this method, the
<span class="line-new-header">--- 1930,12 ---</span>
       * all the public constructors of the class represented by this
       * {@code Class} object.  An array of length 0 is returned if the
       * class has no public constructors, or if the class is an array class, or
       * if the class reflects a primitive type or void.
       *
<span class="line-modified">!      * @apiNote</span>
<span class="line-added">+      * While this method returns an array of {@code</span>
       * Constructor&lt;T&gt;} objects (that is an array of constructors from
       * this class), the return type of this method is {@code
       * Constructor&lt;?&gt;[]} and &lt;em&gt;not&lt;/em&gt; {@code Constructor&lt;T&gt;[]} as
       * might be expected.  This less informative return type is
       * necessary since after being returned from this method, the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1965,11 ***</span>
       * field of the class or interface represented by this {@code Class}
       * object. The {@code name} parameter is a {@code String} specifying the
       * simple name of the desired field.
       *
       * &lt;p&gt; The field to be reflected is determined by the algorithm that
<span class="line-modified">!      * follows.  Let C be the class or interface represented by this object:</span>
       *
       * &lt;OL&gt;
       * &lt;LI&gt; If C declares a public field with the name specified, that is the
       *      field to be reflected.&lt;/LI&gt;
       * &lt;LI&gt; If no field was found in step 1 above, this algorithm is applied
<span class="line-new-header">--- 1970,11 ---</span>
       * field of the class or interface represented by this {@code Class}
       * object. The {@code name} parameter is a {@code String} specifying the
       * simple name of the desired field.
       *
       * &lt;p&gt; The field to be reflected is determined by the algorithm that
<span class="line-modified">!      * follows.  Let C be the class or interface represented by this {@code Class} object:</span>
       *
       * &lt;OL&gt;
       * &lt;LI&gt; If C declares a public field with the name specified, that is the
       *      field to be reflected.&lt;/LI&gt;
       * &lt;LI&gt; If no field was found in step 1 above, this algorithm is applied
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2399,11 ***</span>
       * class has a default constructor, it is included in the returned array.
       * This method returns an array of length 0 if this {@code Class}
       * object represents an interface, a primitive type, an array class, or
       * void.
       *
<span class="line-modified">!      * &lt;p&gt; See &lt;em&gt;The Java Language Specification&lt;/em&gt;, section {@jls 8.2}.</span>
       *
       * @return  the array of {@code Constructor} objects representing all the
       *          declared constructors of this class
       * @throws  SecurityException
       *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
<span class="line-new-header">--- 2404,12 ---</span>
       * class has a default constructor, it is included in the returned array.
       * This method returns an array of length 0 if this {@code Class}
       * object represents an interface, a primitive type, an array class, or
       * void.
       *
<span class="line-modified">!      * &lt;p&gt; See &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;,</span>
<span class="line-added">+      * section {@jls 8.2}.</span>
       *
       * @return  the array of {@code Constructor} objects representing all the
       *          declared constructors of this class
       * @throws  SecurityException
       *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2649,13 ***</span>
       * caller&#39;s module.
       *
       * &lt;p&gt; Otherwise, if this class is not in a named module then the rules for
       * searching resources associated with a given class are implemented by the
       * defining {@linkplain ClassLoader class loader} of the class.  This method
<span class="line-modified">!      * delegates to this object&#39;s class loader.  If this object was loaded by</span>
<span class="line-modified">!      * the bootstrap class loader, the method delegates to {@link</span>
<span class="line-modified">!      * ClassLoader#getSystemResourceAsStream}.</span>
       *
       * &lt;p&gt; Before delegation, an absolute resource name is constructed from the
       * given resource name using this algorithm:
       *
       * &lt;ul&gt;
<span class="line-new-header">--- 2655,13 ---</span>
       * caller&#39;s module.
       *
       * &lt;p&gt; Otherwise, if this class is not in a named module then the rules for
       * searching resources associated with a given class are implemented by the
       * defining {@linkplain ClassLoader class loader} of the class.  This method
<span class="line-modified">!      * delegates to this {@code Class} object&#39;s class loader.</span>
<span class="line-modified">!      * If this {@code Class} object was loaded by the bootstrap class loader,</span>
<span class="line-modified">!      * the method delegates to {@link ClassLoader#getSystemResourceAsStream}.</span>
       *
       * &lt;p&gt; Before delegation, an absolute resource name is constructed from the
       * given resource name using this algorithm:
       *
       * &lt;ul&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2747,13 ***</span>
       * caller&#39;s module.
       *
       * &lt;p&gt; Otherwise, if this class is not in a named module then the rules for
       * searching resources associated with a given class are implemented by the
       * defining {@linkplain ClassLoader class loader} of the class.  This method
<span class="line-modified">!      * delegates to this object&#39;s class loader. If this object was loaded by</span>
<span class="line-modified">!      * the bootstrap class loader, the method delegates to {@link</span>
<span class="line-modified">!      * ClassLoader#getSystemResource}.</span>
       *
       * &lt;p&gt; Before delegation, an absolute resource name is constructed from the
       * given resource name using this algorithm:
       *
       * &lt;ul&gt;
<span class="line-new-header">--- 2753,13 ---</span>
       * caller&#39;s module.
       *
       * &lt;p&gt; Otherwise, if this class is not in a named module then the rules for
       * searching resources associated with a given class are implemented by the
       * defining {@linkplain ClassLoader class loader} of the class.  This method
<span class="line-modified">!      * delegates to this {@code Class} object&#39;s class loader.</span>
<span class="line-modified">!      * If this {@code Class} object was loaded by the bootstrap class loader,</span>
<span class="line-modified">!      * the method delegates to {@link ClassLoader#getSystemResource}.</span>
       *
       * &lt;p&gt; Before delegation, an absolute resource name is constructed from the
       * given resource name using this algorithm:
       *
       * &lt;ul&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3536,13 ***</span>
       * status pertains to this class, the most recent setting for the most
       * specific pertinent package default assertion status is returned;
       * otherwise, if this class is not a system class (i.e., it has a
       * class loader) its class loader&#39;s default assertion status is returned;
       * otherwise, the system class default assertion status is returned.
<span class="line-modified">!      * &lt;p&gt;</span>
       * Few programmers will have any need for this method; it is provided
<span class="line-modified">!      * for the benefit of the JRE itself.  (It allows a class to determine at</span>
       * the time that it is initialized whether assertions should be enabled.)
       * Note that this method is not guaranteed to return the actual
       * assertion status that was (or will be) associated with the specified
       * class when it was (or will be) initialized.
       *
<span class="line-new-header">--- 3542,14 ---</span>
       * status pertains to this class, the most recent setting for the most
       * specific pertinent package default assertion status is returned;
       * otherwise, if this class is not a system class (i.e., it has a
       * class loader) its class loader&#39;s default assertion status is returned;
       * otherwise, the system class default assertion status is returned.
<span class="line-modified">!      *</span>
<span class="line-added">+      * @apiNote</span>
       * Few programmers will have any need for this method; it is provided
<span class="line-modified">!      * for the benefit of the JDK itself.  (It allows a class to determine at</span>
       * the time that it is initialized whether assertions should be enabled.)
       * Note that this method is not guaranteed to return the actual
       * assertion status that was (or will be) associated with the specified
       * class when it was (or will be) initialized.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3649,12 ***</span>
      /**
       * Returns the elements of this enum class or null if this
       * Class object does not represent an enum type.
       *
       * @return an array containing the values comprising the enum class
<span class="line-modified">!      *     represented by this Class object in the order they&#39;re</span>
<span class="line-modified">!      *     declared, or null if this Class object does not</span>
       *     represent an enum type
       * @since 1.5
       */
      public T[] getEnumConstants() {
          T[] values = getEnumConstantsShared();
<span class="line-new-header">--- 3656,12 ---</span>
      /**
       * Returns the elements of this enum class or null if this
       * Class object does not represent an enum type.
       *
       * @return an array containing the values comprising the enum class
<span class="line-modified">!      *     represented by this {@code Class} object in the order they&#39;re</span>
<span class="line-modified">!      *     declared, or null if this {@code Class} object does not</span>
       *     represent an enum type
       * @since 1.5
       */
      public T[] getEnumConstants() {
          T[] values = getEnumConstantsShared();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3743,21 ***</span>
  
      /**
       * Casts this {@code Class} object to represent a subclass of the class
       * represented by the specified class object.  Checks that the cast
       * is valid, and throws a {@code ClassCastException} if it is not.  If
<span class="line-modified">!      * this method succeeds, it always returns a reference to this class object.</span>
       *
       * &lt;p&gt;This method is useful when a client needs to &quot;narrow&quot; the type of
       * a {@code Class} object to pass it to an API that restricts the
       * {@code Class} objects that it is willing to accept.  A cast would
       * generate a compile-time warning, as the correctness of the cast
       * could not be checked at runtime (because generic types are implemented
       * by erasure).
       *
<span class="line-modified">!      * @param &lt;U&gt; the type to cast this class object to</span>
<span class="line-modified">!      * @param clazz the class of the type to cast this class object to</span>
       * @return this {@code Class} object, cast to represent a subclass of
       *    the specified class object.
       * @throws ClassCastException if this {@code Class} object does not
       *    represent a subclass of the specified class (here &quot;subclass&quot; includes
       *    the class itself).
<span class="line-new-header">--- 3750,21 ---</span>
  
      /**
       * Casts this {@code Class} object to represent a subclass of the class
       * represented by the specified class object.  Checks that the cast
       * is valid, and throws a {@code ClassCastException} if it is not.  If
<span class="line-modified">!      * this method succeeds, it always returns a reference to this {@code Class} object.</span>
       *
       * &lt;p&gt;This method is useful when a client needs to &quot;narrow&quot; the type of
       * a {@code Class} object to pass it to an API that restricts the
       * {@code Class} objects that it is willing to accept.  A cast would
       * generate a compile-time warning, as the correctness of the cast
       * could not be checked at runtime (because generic types are implemented
       * by erasure).
       *
<span class="line-modified">!      * @param &lt;U&gt; the type to cast this {@code Class} object to</span>
<span class="line-modified">!      * @param clazz the class of the type to cast this {@code Class} object to</span>
       * @return this {@code Class} object, cast to represent a subclass of
       *    the specified class object.
       * @throws ClassCastException if this {@code Class} object does not
       *    represent a subclass of the specified class (here &quot;subclass&quot; includes
       *    the class itself).
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3770,13 ***</span>
<span class="line-new-header">--- 3777,18 ---</span>
          else
              throw new ClassCastException(this.toString());
      }
  
      /**
<span class="line-added">+      * {@inheritDoc}</span>
<span class="line-added">+      * &lt;p&gt;Note that any annotation returned by this method is a</span>
<span class="line-added">+      * declaration annotation.</span>
<span class="line-added">+      *</span>
       * @throws NullPointerException {@inheritDoc}
       * @since 1.5
       */
<span class="line-added">+     @Override</span>
      @SuppressWarnings(&quot;unchecked&quot;)
      public &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass) {
          Objects.requireNonNull(annotationClass);
  
          return (A) annotationData().annotations.get(annotationClass);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3791,10 ***</span>
<span class="line-new-header">--- 3803,14 ---</span>
      public boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) {
          return GenericDeclaration.super.isAnnotationPresent(annotationClass);
      }
  
      /**
<span class="line-added">+      * {@inheritDoc}</span>
<span class="line-added">+      * &lt;p&gt;Note that any annotations returned by this method are</span>
<span class="line-added">+      * declaration annotations.</span>
<span class="line-added">+      *</span>
       * @throws NullPointerException {@inheritDoc}
       * @since 1.8
       */
      @Override
      public &lt;A extends Annotation&gt; A[] getAnnotationsByType(Class&lt;A&gt; annotationClass) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3805,17 ***</span>
<span class="line-new-header">--- 3821,26 ---</span>
                                                            this,
                                                            annotationClass);
      }
  
      /**
<span class="line-added">+      * {@inheritDoc}</span>
<span class="line-added">+      * &lt;p&gt;Note that any annotations returned by this method are</span>
<span class="line-added">+      * declaration annotations.</span>
<span class="line-added">+      *</span>
       * @since 1.5
       */
<span class="line-added">+     @Override</span>
      public Annotation[] getAnnotations() {
          return AnnotationParser.toArray(annotationData().annotations);
      }
  
      /**
<span class="line-added">+      * {@inheritDoc}</span>
<span class="line-added">+      * &lt;p&gt;Note that any annotation returned by this method is a</span>
<span class="line-added">+      * declaration annotation.</span>
<span class="line-added">+      *</span>
       * @throws NullPointerException {@inheritDoc}
       * @since 1.8
       */
      @Override
      @SuppressWarnings(&quot;unchecked&quot;)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3824,10 ***</span>
<span class="line-new-header">--- 3849,14 ---</span>
  
          return (A) annotationData().declaredAnnotations.get(annotationClass);
      }
  
      /**
<span class="line-added">+      * {@inheritDoc}</span>
<span class="line-added">+      * &lt;p&gt;Note that any annotations returned by this method are</span>
<span class="line-added">+      * declaration annotations.</span>
<span class="line-added">+      *</span>
       * @throws NullPointerException {@inheritDoc}
       * @since 1.8
       */
      @Override
      public &lt;A extends Annotation&gt; A[] getDeclaredAnnotationsByType(Class&lt;A&gt; annotationClass) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3836,12 ***</span>
<span class="line-new-header">--- 3865,17 ---</span>
          return AnnotationSupport.getDirectlyAndIndirectlyPresent(annotationData().declaredAnnotations,
                                                                   annotationClass);
      }
  
      /**
<span class="line-added">+      * {@inheritDoc}</span>
<span class="line-added">+      * &lt;p&gt;Note that any annotations returned by this method are</span>
<span class="line-added">+      * declaration annotations.</span>
<span class="line-added">+      *</span>
       * @since 1.5
       */
<span class="line-added">+     @Override</span>
      public Annotation[] getDeclaredAnnotations()  {
          return AnnotationParser.toArray(annotationData().declaredAnnotations);
      }
  
      // annotation data that might get invalidated when JVM TI RedefineClasses() is called
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4023,14 ***</span>
       * a member of the nest by the nest host, then it is considered to belong
       * to its own nest and {@code this} is returned as the host.
       *
       * @apiNote A {@code class} file of version 55.0 or greater may record the
       * host of the nest to which it belongs by using the {@code NestHost}
<span class="line-modified">!      * attribute (JVMS 4.7.28). Alternatively, a {@code class} file of</span>
       * version 55.0 or greater may act as a nest host by enumerating the nest&#39;s
       * other members with the
<span class="line-modified">!      * {@code NestMembers} attribute (JVMS 4.7.29).</span>
       * A {@code class} file of version 54.0 or lower does not use these
       * attributes.
       *
       * @return the nest host of this class or interface
       *
<span class="line-new-header">--- 4057,14 ---</span>
       * a member of the nest by the nest host, then it is considered to belong
       * to its own nest and {@code this} is returned as the host.
       *
       * @apiNote A {@code class} file of version 55.0 or greater may record the
       * host of the nest to which it belongs by using the {@code NestHost}
<span class="line-modified">!      * attribute (JVMS {@jvms 4.7.28}). Alternatively, a {@code class} file of</span>
       * version 55.0 or greater may act as a nest host by enumerating the nest&#39;s
       * other members with the
<span class="line-modified">!      * {@code NestMembers} attribute (JVMS {@jvms 4.7.29}).</span>
       * A {@code class} file of version 54.0 or lower does not use these
       * attributes.
       *
       * @return the nest host of this class or interface
       *
</pre>
<center><a href="Character.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ClassLoader.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
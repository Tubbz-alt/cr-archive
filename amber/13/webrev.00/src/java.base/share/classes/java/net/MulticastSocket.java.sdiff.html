<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/net/MulticastSocket.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="Inet4Address.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="NetPermission.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/net/MulticastSocket.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
641      *         the underlying protocol, such as a TCP error.
642      * @return The multicast {@code NetworkInterface} currently set. A placeholder
643      *         NetworkInterface is returned when there is no interface set; it has
644      *         a single InetAddress to represent any local address.
645      * @see    #setNetworkInterface(NetworkInterface)
646      * @since  1.4
647      */
648     public NetworkInterface getNetworkInterface() throws SocketException {
649         NetworkInterface ni
650             = (NetworkInterface)getImpl().getOption(SocketOptions.IP_MULTICAST_IF2);
651         if (ni == null) {
652             InetAddress[] addrs = new InetAddress[1];
653             addrs[0] = InetAddress.anyLocalAddress();
654             return new NetworkInterface(addrs[0].getHostName(), 0, addrs);
655         } else {
656             return ni;
657         }
658     }
659 
660     /**
<span class="line-modified">661      * Disable/Enable local loopback of multicast datagrams</span>
662      * The option is used by the platform&#39;s networking code as a hint
663      * for setting whether multicast data will be looped back to
664      * the local socket.
665      *
666      * &lt;p&gt;Because this option is a hint, applications that want to
667      * verify what loopback mode is set to should call
668      * {@link #getLoopbackMode()}
669      * @param      disable {@code true} to disable the LoopbackMode
670      * @throws     SocketException if an error occurs while setting the value
671      * @since      1.4
672      * @deprecated Use {@link #setOption(SocketOption, Object)} with
673      *             {@link java.net.StandardSocketOptions#IP_MULTICAST_LOOP}
674      *             instead. The loopback mode is enabled by default,
675      *             {@code MulticastSocket.setOption(StandardSocketOptions.IP_MULTICAST_LOOP, false)}
676      *             disables it.
677      * @see        #getLoopbackMode
678      */
679     @Deprecated(since=&quot;14&quot;)
680     public void setLoopbackMode(boolean disable) throws SocketException {
681         getImpl().setOption(SocketOptions.IP_MULTICAST_LOOP, Boolean.valueOf(disable));
682     }
683 
684     /**
685      * Get the setting for local loopback of multicast datagrams.
686      *
687      * @throws     SocketException if an error occurs while getting the value
688      * @return     true if the LoopbackMode has been disabled
689      * @since      1.4
690      * @deprecated Use {@link #getOption(SocketOption)} with
691      *             {@link java.net.StandardSocketOptions#IP_MULTICAST_LOOP}
692      *             instead.
693      * @see        #setLoopbackMode
694      */
695     @Deprecated(since=&quot;14&quot;)
696     public boolean getLoopbackMode() throws SocketException {
697         return ((Boolean)getImpl().getOption(SocketOptions.IP_MULTICAST_LOOP)).booleanValue();
698     }
699 
700     /**
<span class="line-modified">701      * Sends a datagram packet to the destination, with a TTL (time-</span>
<span class="line-modified">702      * to-live) other than the default for the socket.  This method</span>
703      * need only be used in instances where a particular TTL is desired;
704      * otherwise it is preferable to set a TTL once on the socket, and
705      * use that default TTL for all packets.  This method does &lt;B&gt;not
706      * &lt;/B&gt; alter the default TTL for the socket. Its behavior may be
707      * affected by {@code setInterface}.
708      *
709      * &lt;p&gt;If there is a security manager, this method first performs some
710      * security checks. First, if {@code p.getAddress().isMulticastAddress()}
711      * is true, this method calls the
712      * security manager&#39;s {@code checkMulticast} method
713      * with {@code p.getAddress()} and {@code ttl} as its arguments.
714      * If the evaluation of that expression is false,
715      * this method instead calls the security manager&#39;s
716      * {@code checkConnect} method with arguments
717      * {@code p.getAddress().getHostAddress()} and
718      * {@code p.getPort()}. Each call to a security manager method
719      * could result in a SecurityException if the operation is not allowed.
720      *
721      * @param p is the packet to be sent. The packet should contain
722      * the destination multicast ip address and the data to be sent.
</pre>
<hr />
<pre>
791                                                         &quot; differ&quot;);
792                         }
793                     }
794                     byte dttl = getTTL();
795                     try {
796                         if (ttl != dttl) {
797                             // set the ttl
798                             getImpl().setTTL(ttl);
799                         }
800                         // call the datagram method to send
801                         getImpl().send(p);
802                     } finally {
803                         // set it back to default
804                         if (ttl != dttl) {
805                             getImpl().setTTL(dttl);
806                         }
807                     }
808                 } // synch p
809             }  //synch ttl
810     } //method
<span class="line-removed">811 </span>
<span class="line-removed">812     private static Set&lt;SocketOption&lt;?&gt;&gt; options;</span>
<span class="line-removed">813     private static boolean optionsSet = false;</span>
<span class="line-removed">814 </span>
<span class="line-removed">815     @Override</span>
<span class="line-removed">816     public Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() {</span>
<span class="line-removed">817         synchronized (MulticastSocket.class) {</span>
<span class="line-removed">818             if (optionsSet) {</span>
<span class="line-removed">819                 return options;</span>
<span class="line-removed">820             }</span>
<span class="line-removed">821             try {</span>
<span class="line-removed">822                 DatagramSocketImpl impl = getImpl();</span>
<span class="line-removed">823                 options = Collections.unmodifiableSet(impl.supportedOptions());</span>
<span class="line-removed">824             } catch (SocketException ex) {</span>
<span class="line-removed">825                 options = Collections.emptySet();</span>
<span class="line-removed">826             }</span>
<span class="line-removed">827             optionsSet = true;</span>
<span class="line-removed">828             return options;</span>
<span class="line-removed">829         }</span>
<span class="line-removed">830     }</span>
831 }
</pre>
</td>
<td>
<hr />
<pre>
641      *         the underlying protocol, such as a TCP error.
642      * @return The multicast {@code NetworkInterface} currently set. A placeholder
643      *         NetworkInterface is returned when there is no interface set; it has
644      *         a single InetAddress to represent any local address.
645      * @see    #setNetworkInterface(NetworkInterface)
646      * @since  1.4
647      */
648     public NetworkInterface getNetworkInterface() throws SocketException {
649         NetworkInterface ni
650             = (NetworkInterface)getImpl().getOption(SocketOptions.IP_MULTICAST_IF2);
651         if (ni == null) {
652             InetAddress[] addrs = new InetAddress[1];
653             addrs[0] = InetAddress.anyLocalAddress();
654             return new NetworkInterface(addrs[0].getHostName(), 0, addrs);
655         } else {
656             return ni;
657         }
658     }
659 
660     /**
<span class="line-modified">661      * Disable/Enable local loopback of multicast datagrams.</span>
662      * The option is used by the platform&#39;s networking code as a hint
663      * for setting whether multicast data will be looped back to
664      * the local socket.
665      *
666      * &lt;p&gt;Because this option is a hint, applications that want to
667      * verify what loopback mode is set to should call
668      * {@link #getLoopbackMode()}
669      * @param      disable {@code true} to disable the LoopbackMode
670      * @throws     SocketException if an error occurs while setting the value
671      * @since      1.4
672      * @deprecated Use {@link #setOption(SocketOption, Object)} with
673      *             {@link java.net.StandardSocketOptions#IP_MULTICAST_LOOP}
674      *             instead. The loopback mode is enabled by default,
675      *             {@code MulticastSocket.setOption(StandardSocketOptions.IP_MULTICAST_LOOP, false)}
676      *             disables it.
677      * @see        #getLoopbackMode
678      */
679     @Deprecated(since=&quot;14&quot;)
680     public void setLoopbackMode(boolean disable) throws SocketException {
681         getImpl().setOption(SocketOptions.IP_MULTICAST_LOOP, Boolean.valueOf(disable));
682     }
683 
684     /**
685      * Get the setting for local loopback of multicast datagrams.
686      *
687      * @throws     SocketException if an error occurs while getting the value
688      * @return     true if the LoopbackMode has been disabled
689      * @since      1.4
690      * @deprecated Use {@link #getOption(SocketOption)} with
691      *             {@link java.net.StandardSocketOptions#IP_MULTICAST_LOOP}
692      *             instead.
693      * @see        #setLoopbackMode
694      */
695     @Deprecated(since=&quot;14&quot;)
696     public boolean getLoopbackMode() throws SocketException {
697         return ((Boolean)getImpl().getOption(SocketOptions.IP_MULTICAST_LOOP)).booleanValue();
698     }
699 
700     /**
<span class="line-modified">701      * Sends a datagram packet to the destination, with a TTL (time-to-live)</span>
<span class="line-modified">702      * other than the default for the socket.  This method</span>
703      * need only be used in instances where a particular TTL is desired;
704      * otherwise it is preferable to set a TTL once on the socket, and
705      * use that default TTL for all packets.  This method does &lt;B&gt;not
706      * &lt;/B&gt; alter the default TTL for the socket. Its behavior may be
707      * affected by {@code setInterface}.
708      *
709      * &lt;p&gt;If there is a security manager, this method first performs some
710      * security checks. First, if {@code p.getAddress().isMulticastAddress()}
711      * is true, this method calls the
712      * security manager&#39;s {@code checkMulticast} method
713      * with {@code p.getAddress()} and {@code ttl} as its arguments.
714      * If the evaluation of that expression is false,
715      * this method instead calls the security manager&#39;s
716      * {@code checkConnect} method with arguments
717      * {@code p.getAddress().getHostAddress()} and
718      * {@code p.getPort()}. Each call to a security manager method
719      * could result in a SecurityException if the operation is not allowed.
720      *
721      * @param p is the packet to be sent. The packet should contain
722      * the destination multicast ip address and the data to be sent.
</pre>
<hr />
<pre>
791                                                         &quot; differ&quot;);
792                         }
793                     }
794                     byte dttl = getTTL();
795                     try {
796                         if (ttl != dttl) {
797                             // set the ttl
798                             getImpl().setTTL(ttl);
799                         }
800                         // call the datagram method to send
801                         getImpl().send(p);
802                     } finally {
803                         // set it back to default
804                         if (ttl != dttl) {
805                             getImpl().setTTL(dttl);
806                         }
807                     }
808                 } // synch p
809             }  //synch ttl
810     } //method




















811 }
</pre>
</td>
</tr>
</table>
<center><a href="Inet4Address.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="NetPermission.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
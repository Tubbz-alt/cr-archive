<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/lang/StrictMath.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang;
  27 
  28 import java.util.Random;
  29 import jdk.internal.math.DoubleConsts;
  30 import jdk.internal.HotSpotIntrinsicCandidate;
  31 
  32 /**
  33  * The class {@code StrictMath} contains methods for performing basic
  34  * numeric operations such as the elementary exponential, logarithm,
  35  * square root, and trigonometric functions.
  36  *
  37  * &lt;p&gt;To help ensure portability of Java programs, the definitions of
  38  * some of the numeric functions in this package require that they
  39  * produce the same results as certain published algorithms. These
  40  * algorithms are available from the well-known network library
  41  * {@code netlib} as the package &quot;Freely Distributable Math
  42  * Library,&quot; &lt;a
  43  * href=&quot;https://www.netlib.org/fdlibm/&quot;&gt;{@code fdlibm}&lt;/a&gt;. These
  44  * algorithms, which are written in the C programming language, are
  45  * then to be understood as executed with all floating-point
  46  * operations following the rules of Java floating-point arithmetic.
  47  *
  48  * &lt;p&gt;The Java math library is defined with respect to
  49  * {@code fdlibm} version 5.3. Where {@code fdlibm} provides
  50  * more than one definition for a function (such as
  51  * {@code acos}), use the &quot;IEEE 754 core function&quot; version
  52  * (residing in a file whose name begins with the letter
  53  * {@code e}).  The methods which require {@code fdlibm}
  54  * semantics are {@code sin}, {@code cos}, {@code tan},
  55  * {@code asin}, {@code acos}, {@code atan},
  56  * {@code exp}, {@code log}, {@code log10},
  57  * {@code cbrt}, {@code atan2}, {@code pow},
  58  * {@code sinh}, {@code cosh}, {@code tanh},
  59  * {@code hypot}, {@code expm1}, and {@code log1p}.
  60  *
  61  * &lt;p&gt;
  62  * The platform uses signed two&#39;s complement integer arithmetic with
  63  * int and long primitive types.  The developer should choose
  64  * the primitive type to ensure that arithmetic operations consistently
  65  * produce correct results, which in some cases means the operations
  66  * will not overflow the range of values of the computation.
  67  * The best practice is to choose the primitive type and algorithm to avoid
  68  * overflow. In cases where the size is {@code int} or {@code long} and
  69  * overflow errors need to be detected, the methods {@code addExact},
  70  * {@code subtractExact}, {@code multiplyExact}, {@code toIntExact},
  71  * {@code incrementExact}, {@code decrementExact} and {@code negateExact}
  72  * throw an {@code ArithmeticException} when the results overflow.
  73  * For the arithmetic operations divide and absolute value, overflow
  74  * occurs only with a specific minimum or maximum value and
  75  * should be checked against the minimum or maximum as appropriate.
  76  *
  77  * @author  unascribed
  78  * @author  Joseph D. Darcy
  79  * @since   1.3
  80  */
  81 
  82 public final class StrictMath {
  83 
  84     /**
  85      * Don&#39;t let anyone instantiate this class.
  86      */
  87     private StrictMath() {}
  88 
  89     /**
  90      * The {@code double} value that is closer than any other to
  91      * &lt;i&gt;e&lt;/i&gt;, the base of the natural logarithms.
  92      */
  93     public static final double E = 2.7182818284590452354;
  94 
  95     /**
  96      * The {@code double} value that is closer than any other to
  97      * &lt;i&gt;pi&lt;/i&gt;, the ratio of the circumference of a circle to its
  98      * diameter.
  99      */
 100     public static final double PI = 3.14159265358979323846;
 101 
 102     /**
 103      * Constant by which to multiply an angular value in degrees to obtain an
 104      * angular value in radians.
 105      */
 106     private static final double DEGREES_TO_RADIANS = 0.017453292519943295;
 107 
 108     /**
 109      * Constant by which to multiply an angular value in radians to obtain an
 110      * angular value in degrees.
 111      */
 112 
 113     private static final double RADIANS_TO_DEGREES = 57.29577951308232;
 114 
 115     /**
 116      * Returns the trigonometric sine of an angle. Special cases:
 117      * &lt;ul&gt;&lt;li&gt;If the argument is NaN or an infinity, then the
 118      * result is NaN.
 119      * &lt;li&gt;If the argument is zero, then the result is a zero with the
 120      * same sign as the argument.&lt;/ul&gt;
 121      *
 122      * @param   a   an angle, in radians.
 123      * @return  the sine of the argument.
 124      */
 125     public static native double sin(double a);
 126 
 127     /**
 128      * Returns the trigonometric cosine of an angle. Special cases:
 129      * &lt;ul&gt;&lt;li&gt;If the argument is NaN or an infinity, then the
 130      * result is NaN.&lt;/ul&gt;
 131      *
 132      * @param   a   an angle, in radians.
 133      * @return  the cosine of the argument.
 134      */
 135     public static native double cos(double a);
 136 
 137     /**
 138      * Returns the trigonometric tangent of an angle. Special cases:
 139      * &lt;ul&gt;&lt;li&gt;If the argument is NaN or an infinity, then the result
 140      * is NaN.
 141      * &lt;li&gt;If the argument is zero, then the result is a zero with the
 142      * same sign as the argument.&lt;/ul&gt;
 143      *
 144      * @param   a   an angle, in radians.
 145      * @return  the tangent of the argument.
 146      */
 147     public static native double tan(double a);
 148 
 149     /**
 150      * Returns the arc sine of a value; the returned angle is in the
 151      * range -&lt;i&gt;pi&lt;/i&gt;/2 through &lt;i&gt;pi&lt;/i&gt;/2.  Special cases:
 152      * &lt;ul&gt;&lt;li&gt;If the argument is NaN or its absolute value is greater
 153      * than 1, then the result is NaN.
 154      * &lt;li&gt;If the argument is zero, then the result is a zero with the
 155      * same sign as the argument.&lt;/ul&gt;
 156      *
 157      * @param   a   the value whose arc sine is to be returned.
 158      * @return  the arc sine of the argument.
 159      */
 160     public static native double asin(double a);
 161 
 162     /**
 163      * Returns the arc cosine of a value; the returned angle is in the
 164      * range 0.0 through &lt;i&gt;pi&lt;/i&gt;.  Special case:
 165      * &lt;ul&gt;&lt;li&gt;If the argument is NaN or its absolute value is greater
 166      * than 1, then the result is NaN.&lt;/ul&gt;
 167      *
 168      * @param   a   the value whose arc cosine is to be returned.
 169      * @return  the arc cosine of the argument.
 170      */
 171     public static native double acos(double a);
 172 
 173     /**
 174      * Returns the arc tangent of a value; the returned angle is in the
 175      * range -&lt;i&gt;pi&lt;/i&gt;/2 through &lt;i&gt;pi&lt;/i&gt;/2.  Special cases:
 176      * &lt;ul&gt;&lt;li&gt;If the argument is NaN, then the result is NaN.
 177      * &lt;li&gt;If the argument is zero, then the result is a zero with the
 178      * same sign as the argument.&lt;/ul&gt;
 179      *
 180      * @param   a   the value whose arc tangent is to be returned.
 181      * @return  the arc tangent of the argument.
 182      */
 183     public static native double atan(double a);
 184 
 185     /**
 186      * Converts an angle measured in degrees to an approximately
 187      * equivalent angle measured in radians.  The conversion from
 188      * degrees to radians is generally inexact.
 189      *
 190      * @param   angdeg   an angle, in degrees
 191      * @return  the measurement of the angle {@code angdeg}
 192      *          in radians.
 193      */
 194     public static strictfp double toRadians(double angdeg) {
 195         // Do not delegate to Math.toRadians(angdeg) because
 196         // this method has the strictfp modifier.
 197         return angdeg * DEGREES_TO_RADIANS;
 198     }
 199 
 200     /**
 201      * Converts an angle measured in radians to an approximately
 202      * equivalent angle measured in degrees.  The conversion from
 203      * radians to degrees is generally inexact; users should
 204      * &lt;i&gt;not&lt;/i&gt; expect {@code cos(toRadians(90.0))} to exactly
 205      * equal {@code 0.0}.
 206      *
 207      * @param   angrad   an angle, in radians
 208      * @return  the measurement of the angle {@code angrad}
 209      *          in degrees.
 210      */
 211     public static strictfp double toDegrees(double angrad) {
 212         // Do not delegate to Math.toDegrees(angrad) because
 213         // this method has the strictfp modifier.
 214         return angrad * RADIANS_TO_DEGREES;
 215     }
 216 
 217     /**
 218      * Returns Euler&#39;s number &lt;i&gt;e&lt;/i&gt; raised to the power of a
 219      * {@code double} value. Special cases:
 220      * &lt;ul&gt;&lt;li&gt;If the argument is NaN, the result is NaN.
 221      * &lt;li&gt;If the argument is positive infinity, then the result is
 222      * positive infinity.
 223      * &lt;li&gt;If the argument is negative infinity, then the result is
 224      * positive zero.&lt;/ul&gt;
 225      *
 226      * @param   a   the exponent to raise &lt;i&gt;e&lt;/i&gt; to.
 227      * @return  the value &lt;i&gt;e&lt;/i&gt;&lt;sup&gt;{@code a}&lt;/sup&gt;,
 228      *          where &lt;i&gt;e&lt;/i&gt; is the base of the natural logarithms.
 229      */
 230     public static double exp(double a) {
 231         return FdLibm.Exp.compute(a);
 232     }
 233 
 234     /**
 235      * Returns the natural logarithm (base &lt;i&gt;e&lt;/i&gt;) of a {@code double}
 236      * value. Special cases:
 237      * &lt;ul&gt;&lt;li&gt;If the argument is NaN or less than zero, then the result
 238      * is NaN.
 239      * &lt;li&gt;If the argument is positive infinity, then the result is
 240      * positive infinity.
 241      * &lt;li&gt;If the argument is positive zero or negative zero, then the
 242      * result is negative infinity.&lt;/ul&gt;
 243      *
 244      * @param   a   a value
 245      * @return  the value ln&amp;nbsp;{@code a}, the natural logarithm of
 246      *          {@code a}.
 247      */
 248     public static native double log(double a);
 249 
 250     /**
 251      * Returns the base 10 logarithm of a {@code double} value.
 252      * Special cases:
 253      *
 254      * &lt;ul&gt;&lt;li&gt;If the argument is NaN or less than zero, then the result
 255      * is NaN.
 256      * &lt;li&gt;If the argument is positive infinity, then the result is
 257      * positive infinity.
 258      * &lt;li&gt;If the argument is positive zero or negative zero, then the
 259      * result is negative infinity.
 260      * &lt;li&gt; If the argument is equal to 10&lt;sup&gt;&lt;i&gt;n&lt;/i&gt;&lt;/sup&gt; for
 261      * integer &lt;i&gt;n&lt;/i&gt;, then the result is &lt;i&gt;n&lt;/i&gt;.
 262      * &lt;/ul&gt;
 263      *
 264      * @param   a   a value
 265      * @return  the base 10 logarithm of  {@code a}.
 266      * @since 1.5
 267      */
 268     public static native double log10(double a);
 269 
 270     /**
 271      * Returns the correctly rounded positive square root of a
 272      * {@code double} value.
 273      * Special cases:
 274      * &lt;ul&gt;&lt;li&gt;If the argument is NaN or less than zero, then the result
 275      * is NaN.
 276      * &lt;li&gt;If the argument is positive infinity, then the result is positive
 277      * infinity.
 278      * &lt;li&gt;If the argument is positive zero or negative zero, then the
 279      * result is the same as the argument.&lt;/ul&gt;
 280      * Otherwise, the result is the {@code double} value closest to
 281      * the true mathematical square root of the argument value.
 282      *
 283      * @param   a   a value.
 284      * @return  the positive square root of {@code a}.
 285      */
 286     @HotSpotIntrinsicCandidate
 287     public static native double sqrt(double a);
 288 
 289     /**
 290      * Returns the cube root of a {@code double} value.  For
 291      * positive finite {@code x}, {@code cbrt(-x) ==
 292      * -cbrt(x)}; that is, the cube root of a negative value is
 293      * the negative of the cube root of that value&#39;s magnitude.
 294      * Special cases:
 295      *
 296      * &lt;ul&gt;
 297      *
 298      * &lt;li&gt;If the argument is NaN, then the result is NaN.
 299      *
 300      * &lt;li&gt;If the argument is infinite, then the result is an infinity
 301      * with the same sign as the argument.
 302      *
 303      * &lt;li&gt;If the argument is zero, then the result is a zero with the
 304      * same sign as the argument.
 305      *
 306      * &lt;/ul&gt;
 307      *
 308      * @param   a   a value.
 309      * @return  the cube root of {@code a}.
 310      * @since 1.5
 311      */
 312     public static double cbrt(double a) {
 313         return FdLibm.Cbrt.compute(a);
 314     }
 315 
 316     /**
 317      * Computes the remainder operation on two arguments as prescribed
 318      * by the IEEE 754 standard.
 319      * The remainder value is mathematically equal to
 320      * &lt;code&gt;f1&amp;nbsp;-&amp;nbsp;f2&lt;/code&gt;&amp;nbsp;&amp;times;&amp;nbsp;&lt;i&gt;n&lt;/i&gt;,
 321      * where &lt;i&gt;n&lt;/i&gt; is the mathematical integer closest to the exact
 322      * mathematical value of the quotient {@code f1/f2}, and if two
 323      * mathematical integers are equally close to {@code f1/f2},
 324      * then &lt;i&gt;n&lt;/i&gt; is the integer that is even. If the remainder is
 325      * zero, its sign is the same as the sign of the first argument.
 326      * Special cases:
 327      * &lt;ul&gt;&lt;li&gt;If either argument is NaN, or the first argument is infinite,
 328      * or the second argument is positive zero or negative zero, then the
 329      * result is NaN.
 330      * &lt;li&gt;If the first argument is finite and the second argument is
 331      * infinite, then the result is the same as the first argument.&lt;/ul&gt;
 332      *
 333      * @param   f1   the dividend.
 334      * @param   f2   the divisor.
 335      * @return  the remainder when {@code f1} is divided by
 336      *          {@code f2}.
 337      */
 338     public static native double IEEEremainder(double f1, double f2);
 339 
 340     /**
 341      * Returns the smallest (closest to negative infinity)
 342      * {@code double} value that is greater than or equal to the
 343      * argument and is equal to a mathematical integer. Special cases:
 344      * &lt;ul&gt;&lt;li&gt;If the argument value is already equal to a
 345      * mathematical integer, then the result is the same as the
 346      * argument.  &lt;li&gt;If the argument is NaN or an infinity or
 347      * positive zero or negative zero, then the result is the same as
 348      * the argument.  &lt;li&gt;If the argument value is less than zero but
 349      * greater than -1.0, then the result is negative zero.&lt;/ul&gt; Note
 350      * that the value of {@code StrictMath.ceil(x)} is exactly the
 351      * value of {@code -StrictMath.floor(-x)}.
 352      *
 353      * @param   a   a value.
 354      * @return  the smallest (closest to negative infinity)
 355      *          floating-point value that is greater than or equal to
 356      *          the argument and is equal to a mathematical integer.
 357      */
 358     public static double ceil(double a) {
 359         return floorOrCeil(a, -0.0, 1.0, 1.0);
 360     }
 361 
 362     /**
 363      * Returns the largest (closest to positive infinity)
 364      * {@code double} value that is less than or equal to the
 365      * argument and is equal to a mathematical integer. Special cases:
 366      * &lt;ul&gt;&lt;li&gt;If the argument value is already equal to a
 367      * mathematical integer, then the result is the same as the
 368      * argument.  &lt;li&gt;If the argument is NaN or an infinity or
 369      * positive zero or negative zero, then the result is the same as
 370      * the argument.&lt;/ul&gt;
 371      *
 372      * @param   a   a value.
 373      * @return  the largest (closest to positive infinity)
 374      *          floating-point value that less than or equal to the argument
 375      *          and is equal to a mathematical integer.
 376      */
 377     public static double floor(double a) {
 378         return floorOrCeil(a, -1.0, 0.0, -1.0);
 379     }
 380 
 381     /**
 382      * Internal method to share logic between floor and ceil.
 383      *
 384      * @param a the value to be floored or ceiled
 385      * @param negativeBoundary result for values in (-1, 0)
 386      * @param positiveBoundary result for values in (0, 1)
 387      * @param increment value to add when the argument is non-integral
 388      */
 389     private static double floorOrCeil(double a,
 390                                       double negativeBoundary,
 391                                       double positiveBoundary,
 392                                       double sign) {
 393         int exponent = Math.getExponent(a);
 394 
 395         if (exponent &lt; 0) {
 396             /*
 397              * Absolute value of argument is less than 1.
 398              * floorOrceil(-0.0) =&gt; -0.0
 399              * floorOrceil(+0.0) =&gt; +0.0
 400              */
 401             return ((a == 0.0) ? a :
 402                     ( (a &lt; 0.0) ?  negativeBoundary : positiveBoundary) );
 403         } else if (exponent &gt;= 52) {
 404             /*
 405              * Infinity, NaN, or a value so large it must be integral.
 406              */
 407             return a;
 408         }
 409         // Else the argument is either an integral value already XOR it
 410         // has to be rounded to one.
 411         assert exponent &gt;= 0 &amp;&amp; exponent &lt;= 51;
 412 
 413         long doppel = Double.doubleToRawLongBits(a);
 414         long mask   = DoubleConsts.SIGNIF_BIT_MASK &gt;&gt; exponent;
 415 
 416         if ( (mask &amp; doppel) == 0L )
 417             return a; // integral value
 418         else {
 419             double result = Double.longBitsToDouble(doppel &amp; (~mask));
 420             if (sign*a &gt; 0.0)
 421                 result = result + sign;
 422             return result;
 423         }
 424     }
 425 
 426     /**
 427      * Returns the {@code double} value that is closest in value
 428      * to the argument and is equal to a mathematical integer. If two
 429      * {@code double} values that are mathematical integers are
 430      * equally close to the value of the argument, the result is the
 431      * integer value that is even. Special cases:
 432      * &lt;ul&gt;&lt;li&gt;If the argument value is already equal to a mathematical
 433      * integer, then the result is the same as the argument.
 434      * &lt;li&gt;If the argument is NaN or an infinity or positive zero or negative
 435      * zero, then the result is the same as the argument.&lt;/ul&gt;
 436      *
 437      * @param   a   a value.
 438      * @return  the closest floating-point value to {@code a} that is
 439      *          equal to a mathematical integer.
 440      * @author Joseph D. Darcy
 441      */
 442     public static double rint(double a) {
 443         /*
 444          * If the absolute value of a is not less than 2^52, it
 445          * is either a finite integer (the double format does not have
 446          * enough significand bits for a number that large to have any
 447          * fractional portion), an infinity, or a NaN.  In any of
 448          * these cases, rint of the argument is the argument.
 449          *
 450          * Otherwise, the sum (twoToThe52 + a ) will properly round
 451          * away any fractional portion of a since ulp(twoToThe52) ==
 452          * 1.0; subtracting out twoToThe52 from this sum will then be
 453          * exact and leave the rounded integer portion of a.
 454          *
 455          * This method does *not* need to be declared strictfp to get
 456          * fully reproducible results.  Whether or not a method is
 457          * declared strictfp can only make a difference in the
 458          * returned result if some operation would overflow or
 459          * underflow with strictfp semantics.  The operation
 460          * (twoToThe52 + a ) cannot overflow since large values of a
 461          * are screened out; the add cannot underflow since twoToThe52
 462          * is too large.  The subtraction ((twoToThe52 + a ) -
 463          * twoToThe52) will be exact as discussed above and thus
 464          * cannot overflow or meaningfully underflow.  Finally, the
 465          * last multiply in the return statement is by plus or minus
 466          * 1.0, which is exact too.
 467          */
 468         double twoToThe52 = (double)(1L &lt;&lt; 52); // 2^52
 469         double sign = Math.copySign(1.0, a); // preserve sign info
 470         a = Math.abs(a);
 471 
 472         if (a &lt; twoToThe52) { // E_min &lt;= ilogb(a) &lt;= 51
 473             a = ((twoToThe52 + a ) - twoToThe52);
 474         }
 475 
 476         return sign * a; // restore original sign
 477     }
 478 
 479     /**
 480      * Returns the angle &lt;i&gt;theta&lt;/i&gt; from the conversion of rectangular
 481      * coordinates ({@code x},&amp;nbsp;{@code y}) to polar
 482      * coordinates (r,&amp;nbsp;&lt;i&gt;theta&lt;/i&gt;).
 483      * This method computes the phase &lt;i&gt;theta&lt;/i&gt; by computing an arc tangent
 484      * of {@code y/x} in the range of -&lt;i&gt;pi&lt;/i&gt; to &lt;i&gt;pi&lt;/i&gt;. Special
 485      * cases:
 486      * &lt;ul&gt;&lt;li&gt;If either argument is NaN, then the result is NaN.
 487      * &lt;li&gt;If the first argument is positive zero and the second argument
 488      * is positive, or the first argument is positive and finite and the
 489      * second argument is positive infinity, then the result is positive
 490      * zero.
 491      * &lt;li&gt;If the first argument is negative zero and the second argument
 492      * is positive, or the first argument is negative and finite and the
 493      * second argument is positive infinity, then the result is negative zero.
 494      * &lt;li&gt;If the first argument is positive zero and the second argument
 495      * is negative, or the first argument is positive and finite and the
 496      * second argument is negative infinity, then the result is the
 497      * {@code double} value closest to &lt;i&gt;pi&lt;/i&gt;.
 498      * &lt;li&gt;If the first argument is negative zero and the second argument
 499      * is negative, or the first argument is negative and finite and the
 500      * second argument is negative infinity, then the result is the
 501      * {@code double} value closest to -&lt;i&gt;pi&lt;/i&gt;.
 502      * &lt;li&gt;If the first argument is positive and the second argument is
 503      * positive zero or negative zero, or the first argument is positive
 504      * infinity and the second argument is finite, then the result is the
 505      * {@code double} value closest to &lt;i&gt;pi&lt;/i&gt;/2.
 506      * &lt;li&gt;If the first argument is negative and the second argument is
 507      * positive zero or negative zero, or the first argument is negative
 508      * infinity and the second argument is finite, then the result is the
 509      * {@code double} value closest to -&lt;i&gt;pi&lt;/i&gt;/2.
 510      * &lt;li&gt;If both arguments are positive infinity, then the result is the
 511      * {@code double} value closest to &lt;i&gt;pi&lt;/i&gt;/4.
 512      * &lt;li&gt;If the first argument is positive infinity and the second argument
 513      * is negative infinity, then the result is the {@code double}
 514      * value closest to 3*&lt;i&gt;pi&lt;/i&gt;/4.
 515      * &lt;li&gt;If the first argument is negative infinity and the second argument
 516      * is positive infinity, then the result is the {@code double} value
 517      * closest to -&lt;i&gt;pi&lt;/i&gt;/4.
 518      * &lt;li&gt;If both arguments are negative infinity, then the result is the
 519      * {@code double} value closest to -3*&lt;i&gt;pi&lt;/i&gt;/4.&lt;/ul&gt;
 520      *
 521      * @param   y   the ordinate coordinate
 522      * @param   x   the abscissa coordinate
 523      * @return  the &lt;i&gt;theta&lt;/i&gt; component of the point
 524      *          (&lt;i&gt;r&lt;/i&gt;,&amp;nbsp;&lt;i&gt;theta&lt;/i&gt;)
 525      *          in polar coordinates that corresponds to the point
 526      *          (&lt;i&gt;x&lt;/i&gt;,&amp;nbsp;&lt;i&gt;y&lt;/i&gt;) in Cartesian coordinates.
 527      */
 528     public static native double atan2(double y, double x);
 529 
 530     /**
 531      * Returns the value of the first argument raised to the power of the
 532      * second argument. Special cases:
 533      *
 534      * &lt;ul&gt;&lt;li&gt;If the second argument is positive or negative zero, then the
 535      * result is 1.0.
 536      * &lt;li&gt;If the second argument is 1.0, then the result is the same as the
 537      * first argument.
 538      * &lt;li&gt;If the second argument is NaN, then the result is NaN.
 539      * &lt;li&gt;If the first argument is NaN and the second argument is nonzero,
 540      * then the result is NaN.
 541      *
 542      * &lt;li&gt;If
 543      * &lt;ul&gt;
 544      * &lt;li&gt;the absolute value of the first argument is greater than 1
 545      * and the second argument is positive infinity, or
 546      * &lt;li&gt;the absolute value of the first argument is less than 1 and
 547      * the second argument is negative infinity,
 548      * &lt;/ul&gt;
 549      * then the result is positive infinity.
 550      *
 551      * &lt;li&gt;If
 552      * &lt;ul&gt;
 553      * &lt;li&gt;the absolute value of the first argument is greater than 1 and
 554      * the second argument is negative infinity, or
 555      * &lt;li&gt;the absolute value of the
 556      * first argument is less than 1 and the second argument is positive
 557      * infinity,
 558      * &lt;/ul&gt;
 559      * then the result is positive zero.
 560      *
 561      * &lt;li&gt;If the absolute value of the first argument equals 1 and the
 562      * second argument is infinite, then the result is NaN.
 563      *
 564      * &lt;li&gt;If
 565      * &lt;ul&gt;
 566      * &lt;li&gt;the first argument is positive zero and the second argument
 567      * is greater than zero, or
 568      * &lt;li&gt;the first argument is positive infinity and the second
 569      * argument is less than zero,
 570      * &lt;/ul&gt;
 571      * then the result is positive zero.
 572      *
 573      * &lt;li&gt;If
 574      * &lt;ul&gt;
 575      * &lt;li&gt;the first argument is positive zero and the second argument
 576      * is less than zero, or
 577      * &lt;li&gt;the first argument is positive infinity and the second
 578      * argument is greater than zero,
 579      * &lt;/ul&gt;
 580      * then the result is positive infinity.
 581      *
 582      * &lt;li&gt;If
 583      * &lt;ul&gt;
 584      * &lt;li&gt;the first argument is negative zero and the second argument
 585      * is greater than zero but not a finite odd integer, or
 586      * &lt;li&gt;the first argument is negative infinity and the second
 587      * argument is less than zero but not a finite odd integer,
 588      * &lt;/ul&gt;
 589      * then the result is positive zero.
 590      *
 591      * &lt;li&gt;If
 592      * &lt;ul&gt;
 593      * &lt;li&gt;the first argument is negative zero and the second argument
 594      * is a positive finite odd integer, or
 595      * &lt;li&gt;the first argument is negative infinity and the second
 596      * argument is a negative finite odd integer,
 597      * &lt;/ul&gt;
 598      * then the result is negative zero.
 599      *
 600      * &lt;li&gt;If
 601      * &lt;ul&gt;
 602      * &lt;li&gt;the first argument is negative zero and the second argument
 603      * is less than zero but not a finite odd integer, or
 604      * &lt;li&gt;the first argument is negative infinity and the second
 605      * argument is greater than zero but not a finite odd integer,
 606      * &lt;/ul&gt;
 607      * then the result is positive infinity.
 608      *
 609      * &lt;li&gt;If
 610      * &lt;ul&gt;
 611      * &lt;li&gt;the first argument is negative zero and the second argument
 612      * is a negative finite odd integer, or
 613      * &lt;li&gt;the first argument is negative infinity and the second
 614      * argument is a positive finite odd integer,
 615      * &lt;/ul&gt;
 616      * then the result is negative infinity.
 617      *
 618      * &lt;li&gt;If the first argument is finite and less than zero
 619      * &lt;ul&gt;
 620      * &lt;li&gt; if the second argument is a finite even integer, the
 621      * result is equal to the result of raising the absolute value of
 622      * the first argument to the power of the second argument
 623      *
 624      * &lt;li&gt;if the second argument is a finite odd integer, the result
 625      * is equal to the negative of the result of raising the absolute
 626      * value of the first argument to the power of the second
 627      * argument
 628      *
 629      * &lt;li&gt;if the second argument is finite and not an integer, then
 630      * the result is NaN.
 631      * &lt;/ul&gt;
 632      *
 633      * &lt;li&gt;If both arguments are integers, then the result is exactly equal
 634      * to the mathematical result of raising the first argument to the power
 635      * of the second argument if that result can in fact be represented
 636      * exactly as a {@code double} value.&lt;/ul&gt;
 637      *
 638      * &lt;p&gt;(In the foregoing descriptions, a floating-point value is
 639      * considered to be an integer if and only if it is finite and a
 640      * fixed point of the method {@link #ceil ceil} or,
 641      * equivalently, a fixed point of the method {@link #floor
 642      * floor}. A value is a fixed point of a one-argument
 643      * method if and only if the result of applying the method to the
 644      * value is equal to the value.)
 645      *
 646      * @param   a   base.
 647      * @param   b   the exponent.
 648      * @return  the value {@code a}&lt;sup&gt;{@code b}&lt;/sup&gt;.
 649      */
 650     public static double pow(double a, double b) {
 651         return FdLibm.Pow.compute(a, b);
 652     }
 653 
 654     /**
 655      * Returns the closest {@code int} to the argument, with ties
 656      * rounding to positive infinity.
 657      *
 658      * &lt;p&gt;Special cases:
 659      * &lt;ul&gt;&lt;li&gt;If the argument is NaN, the result is 0.
 660      * &lt;li&gt;If the argument is negative infinity or any value less than or
 661      * equal to the value of {@code Integer.MIN_VALUE}, the result is
 662      * equal to the value of {@code Integer.MIN_VALUE}.
 663      * &lt;li&gt;If the argument is positive infinity or any value greater than or
 664      * equal to the value of {@code Integer.MAX_VALUE}, the result is
 665      * equal to the value of {@code Integer.MAX_VALUE}.&lt;/ul&gt;
 666      *
 667      * @param   a   a floating-point value to be rounded to an integer.
 668      * @return  the value of the argument rounded to the nearest
 669      *          {@code int} value.
 670      * @see     java.lang.Integer#MAX_VALUE
 671      * @see     java.lang.Integer#MIN_VALUE
 672      */
 673     public static int round(float a) {
 674         return Math.round(a);
 675     }
 676 
 677     /**
 678      * Returns the closest {@code long} to the argument, with ties
 679      * rounding to positive infinity.
 680      *
 681      * &lt;p&gt;Special cases:
 682      * &lt;ul&gt;&lt;li&gt;If the argument is NaN, the result is 0.
 683      * &lt;li&gt;If the argument is negative infinity or any value less than or
 684      * equal to the value of {@code Long.MIN_VALUE}, the result is
 685      * equal to the value of {@code Long.MIN_VALUE}.
 686      * &lt;li&gt;If the argument is positive infinity or any value greater than or
 687      * equal to the value of {@code Long.MAX_VALUE}, the result is
 688      * equal to the value of {@code Long.MAX_VALUE}.&lt;/ul&gt;
 689      *
 690      * @param   a  a floating-point value to be rounded to a
 691      *          {@code long}.
 692      * @return  the value of the argument rounded to the nearest
 693      *          {@code long} value.
 694      * @see     java.lang.Long#MAX_VALUE
 695      * @see     java.lang.Long#MIN_VALUE
 696      */
 697     public static long round(double a) {
 698         return Math.round(a);
 699     }
 700 
 701     private static final class RandomNumberGeneratorHolder {
 702         static final Random randomNumberGenerator = new Random();
 703     }
 704 
 705     /**
 706      * Returns a {@code double} value with a positive sign, greater
 707      * than or equal to {@code 0.0} and less than {@code 1.0}.
 708      * Returned values are chosen pseudorandomly with (approximately)
 709      * uniform distribution from that range.
 710      *
 711      * &lt;p&gt;When this method is first called, it creates a single new
 712      * pseudorandom-number generator, exactly as if by the expression
 713      *
 714      * &lt;blockquote&gt;{@code new java.util.Random()}&lt;/blockquote&gt;
 715      *
 716      * This new pseudorandom-number generator is used thereafter for
 717      * all calls to this method and is used nowhere else.
 718      *
 719      * &lt;p&gt;This method is properly synchronized to allow correct use by
 720      * more than one thread. However, if many threads need to generate
 721      * pseudorandom numbers at a great rate, it may reduce contention
 722      * for each thread to have its own pseudorandom-number generator.
 723      *
 724      * @return  a pseudorandom {@code double} greater than or equal
 725      * to {@code 0.0} and less than {@code 1.0}.
 726      * @see Random#nextDouble()
 727      */
 728     public static double random() {
 729         return RandomNumberGeneratorHolder.randomNumberGenerator.nextDouble();
 730     }
 731 
 732     /**
 733      * Returns the sum of its arguments,
 734      * throwing an exception if the result overflows an {@code int}.
 735      *
 736      * @param x the first value
 737      * @param y the second value
 738      * @return the result
 739      * @throws ArithmeticException if the result overflows an int
 740      * @see Math#addExact(int,int)
 741      * @since 1.8
 742      */
 743     public static int addExact(int x, int y) {
 744         return Math.addExact(x, y);
 745     }
 746 
 747     /**
 748      * Returns the sum of its arguments,
 749      * throwing an exception if the result overflows a {@code long}.
 750      *
 751      * @param x the first value
 752      * @param y the second value
 753      * @return the result
 754      * @throws ArithmeticException if the result overflows a long
 755      * @see Math#addExact(long,long)
 756      * @since 1.8
 757      */
 758     public static long addExact(long x, long y) {
 759         return Math.addExact(x, y);
 760     }
 761 
 762     /**
 763      * Returns the difference of the arguments,
 764      * throwing an exception if the result overflows an {@code int}.
 765      *
 766      * @param x the first value
 767      * @param y the second value to subtract from the first
 768      * @return the result
 769      * @throws ArithmeticException if the result overflows an int
 770      * @see Math#subtractExact(int,int)
 771      * @since 1.8
 772      */
 773     public static int subtractExact(int x, int y) {
 774         return Math.subtractExact(x, y);
 775     }
 776 
 777     /**
 778      * Returns the difference of the arguments,
 779      * throwing an exception if the result overflows a {@code long}.
 780      *
 781      * @param x the first value
 782      * @param y the second value to subtract from the first
 783      * @return the result
 784      * @throws ArithmeticException if the result overflows a long
 785      * @see Math#subtractExact(long,long)
 786      * @since 1.8
 787      */
 788     public static long subtractExact(long x, long y) {
 789         return Math.subtractExact(x, y);
 790     }
 791 
 792     /**
 793      * Returns the product of the arguments,
 794      * throwing an exception if the result overflows an {@code int}.
 795      *
 796      * @param x the first value
 797      * @param y the second value
 798      * @return the result
 799      * @throws ArithmeticException if the result overflows an int
 800      * @see Math#multiplyExact(int,int)
 801      * @since 1.8
 802      */
 803     public static int multiplyExact(int x, int y) {
 804         return Math.multiplyExact(x, y);
 805     }
 806 
 807     /**
 808      * Returns the product of the arguments, throwing an exception if the result
 809      * overflows a {@code long}.
 810      *
 811      * @param x the first value
 812      * @param y the second value
 813      * @return the result
 814      * @throws ArithmeticException if the result overflows a long
 815      * @see Math#multiplyExact(long,int)
 816      * @since 9
 817      */
 818     public static long multiplyExact(long x, int y) {
 819         return Math.multiplyExact(x, y);
 820     }
 821 
 822     /**
 823      * Returns the product of the arguments,
 824      * throwing an exception if the result overflows a {@code long}.
 825      *
 826      * @param x the first value
 827      * @param y the second value
 828      * @return the result
 829      * @throws ArithmeticException if the result overflows a long
 830      * @see Math#multiplyExact(long,long)
 831      * @since 1.8
 832      */
 833     public static long multiplyExact(long x, long y) {
 834         return Math.multiplyExact(x, y);
 835     }
 836 
 837     /**
 838      * Returns the argument incremented by one,
 839      * throwing an exception if the result overflows an {@code int}.
 840      * The overflow only occurs for {@linkplain Integer#MAX_VALUE the maximum value}.
 841      *
 842      * @param a the value to increment
 843      * @return the result
 844      * @throws ArithmeticException if the result overflows an int
 845      * @see Math#incrementExact(int)
 846      * @since 14
 847      */
 848     public static int incrementExact(int a) {
 849         return Math.incrementExact(a);
 850     }
 851 
 852     /**
 853      * Returns the argument incremented by one,
 854      * throwing an exception if the result overflows a {@code long}.
 855      * The overflow only occurs for {@linkplain Long#MAX_VALUE the maximum value}.
 856      *
 857      * @param a the value to increment
 858      * @return the result
 859      * @throws ArithmeticException if the result overflows a long
 860      * @see Math#incrementExact(long)
 861      * @since 14
 862      */
 863     public static long incrementExact(long a) {
 864         return Math.incrementExact(a);
 865     }
 866 
 867     /**
 868      * Returns the argument decremented by one,
 869      * throwing an exception if the result overflows an {@code int}.
 870      * The overflow only occurs for {@linkplain Integer#MIN_VALUE the minimum value}.
 871      *
 872      * @param a the value to decrement
 873      * @return the result
 874      * @throws ArithmeticException if the result overflows an int
 875      * @see Math#decrementExact(int)
 876      * @since 14
 877      */
 878     public static int decrementExact(int a) {
 879         return Math.decrementExact(a);
 880     }
 881 
 882     /**
 883      * Returns the argument decremented by one,
 884      * throwing an exception if the result overflows a {@code long}.
 885      * The overflow only occurs for {@linkplain Long#MIN_VALUE the minimum value}.
 886      *
 887      * @param a the value to decrement
 888      * @return the result
 889      * @throws ArithmeticException if the result overflows a long
 890      * @see Math#decrementExact(long)
 891      * @since 14
 892      */
 893     public static long decrementExact(long a) {
 894         return Math.decrementExact(a);
 895     }
 896 
 897     /**
 898      * Returns the negation of the argument,
 899      * throwing an exception if the result overflows an {@code int}.
 900      * The overflow only occurs for {@linkplain Integer#MIN_VALUE the minimum value}.
 901      *
 902      * @param a the value to negate
 903      * @return the result
 904      * @throws ArithmeticException if the result overflows an int
 905      * @see Math#negateExact(int)
 906      * @since 14
 907      */
 908     public static int negateExact(int a) {
 909         return Math.negateExact(a);
 910     }
 911 
 912     /**
 913      * Returns the negation of the argument,
 914      * throwing an exception if the result overflows a {@code long}.
 915      * The overflow only occurs for {@linkplain Long#MIN_VALUE the minimum value}.
 916      *
 917      * @param a the value to negate
 918      * @return the result
 919      * @throws ArithmeticException if the result overflows a long
 920      * @see Math#negateExact(long)
 921      * @since 14
 922      */
 923     public static long negateExact(long a) {
 924         return Math.negateExact(a);
 925     }
 926 
 927     /**
 928      * Returns the value of the {@code long} argument, throwing an exception
 929      * if the value overflows an {@code int}.
 930      *
 931      * @param value the long value
 932      * @return the argument as an int
 933      * @throws ArithmeticException if the {@code argument} overflows an int
 934      * @see Math#toIntExact(long)
 935      * @since 1.8
 936      */
 937     public static int toIntExact(long value) {
 938         return Math.toIntExact(value);
 939     }
 940 
 941     /**
 942      * Returns the exact mathematical product of the arguments.
 943      *
 944      * @param x the first value
 945      * @param y the second value
 946      * @return the result
 947      * @see Math#multiplyFull(int,int)
 948      * @since 9
 949      */
 950     public static long multiplyFull(int x, int y) {
 951         return Math.multiplyFull(x, y);
 952     }
 953 
 954     /**
 955      * Returns as a {@code long} the most significant 64 bits of the 128-bit
 956      * product of two 64-bit factors.
 957      *
 958      * @param x the first value
 959      * @param y the second value
 960      * @return the result
 961      * @see Math#multiplyHigh(long,long)
 962      * @since 9
 963      */
 964     public static long multiplyHigh(long x, long y) {
 965         return Math.multiplyHigh(x, y);
 966     }
 967 
 968     /**
 969      * Returns the largest (closest to positive infinity)
 970      * {@code int} value that is less than or equal to the algebraic quotient.
 971      * There is one special case, if the dividend is the
 972      * {@linkplain Integer#MIN_VALUE Integer.MIN_VALUE} and the divisor is {@code -1},
 973      * then integer overflow occurs and
 974      * the result is equal to the {@code Integer.MIN_VALUE}.
 975      * &lt;p&gt;
 976      * See {@link Math#floorDiv(int, int) Math.floorDiv} for examples and
 977      * a comparison to the integer division {@code /} operator.
 978      *
 979      * @param x the dividend
 980      * @param y the divisor
 981      * @return the largest (closest to positive infinity)
 982      * {@code int} value that is less than or equal to the algebraic quotient.
 983      * @throws ArithmeticException if the divisor {@code y} is zero
 984      * @see Math#floorDiv(int, int)
 985      * @see Math#floor(double)
 986      * @since 1.8
 987      */
 988     public static int floorDiv(int x, int y) {
 989         return Math.floorDiv(x, y);
 990     }
 991 
 992     /**
 993      * Returns the largest (closest to positive infinity)
 994      * {@code long} value that is less than or equal to the algebraic quotient.
 995      * There is one special case, if the dividend is the
 996      * {@linkplain Long#MIN_VALUE Long.MIN_VALUE} and the divisor is {@code -1},
 997      * then integer overflow occurs and
 998      * the result is equal to {@code Long.MIN_VALUE}.
 999      * &lt;p&gt;
1000      * See {@link Math#floorDiv(int, int) Math.floorDiv} for examples and
1001      * a comparison to the integer division {@code /} operator.
1002      *
1003      * @param x the dividend
1004      * @param y the divisor
1005      * @return the largest (closest to positive infinity)
1006      * {@code int} value that is less than or equal to the algebraic quotient.
1007      * @throws ArithmeticException if the divisor {@code y} is zero
1008      * @see Math#floorDiv(long, int)
1009      * @see Math#floor(double)
1010      * @since 9
1011      */
1012     public static long floorDiv(long x, int y) {
1013         return Math.floorDiv(x, y);
1014     }
1015 
1016     /**
1017      * Returns the largest (closest to positive infinity)
1018      * {@code long} value that is less than or equal to the algebraic quotient.
1019      * There is one special case, if the dividend is the
1020      * {@linkplain Long#MIN_VALUE Long.MIN_VALUE} and the divisor is {@code -1},
1021      * then integer overflow occurs and
1022      * the result is equal to the {@code Long.MIN_VALUE}.
1023      * &lt;p&gt;
1024      * See {@link Math#floorDiv(int, int) Math.floorDiv} for examples and
1025      * a comparison to the integer division {@code /} operator.
1026      *
1027      * @param x the dividend
1028      * @param y the divisor
1029      * @return the largest (closest to positive infinity)
1030      * {@code long} value that is less than or equal to the algebraic quotient.
1031      * @throws ArithmeticException if the divisor {@code y} is zero
1032      * @see Math#floorDiv(long, long)
1033      * @see Math#floor(double)
1034      * @since 1.8
1035      */
1036     public static long floorDiv(long x, long y) {
1037         return Math.floorDiv(x, y);
1038     }
1039 
1040     /**
1041      * Returns the floor modulus of the {@code int} arguments.
1042      * &lt;p&gt;
1043      * The floor modulus is {@code x - (floorDiv(x, y) * y)},
1044      * has the same sign as the divisor {@code y}, and
1045      * is in the range of {@code -abs(y) &lt; r &lt; +abs(y)}.
1046      * &lt;p&gt;
1047      * The relationship between {@code floorDiv} and {@code floorMod} is such that:
1048      * &lt;ul&gt;
1049      *   &lt;li&gt;{@code floorDiv(x, y) * y + floorMod(x, y) == x}
1050      * &lt;/ul&gt;
1051      * &lt;p&gt;
1052      * See {@link Math#floorMod(int, int) Math.floorMod} for examples and
1053      * a comparison to the {@code %} operator.
1054      *
1055      * @param x the dividend
1056      * @param y the divisor
1057      * @return the floor modulus {@code x - (floorDiv(x, y) * y)}
1058      * @throws ArithmeticException if the divisor {@code y} is zero
1059      * @see Math#floorMod(int, int)
1060      * @see StrictMath#floorDiv(int, int)
1061      * @since 1.8
1062      */
1063     public static int floorMod(int x, int y) {
1064         return Math.floorMod(x , y);
1065     }
1066 
1067     /**
1068      * Returns the floor modulus of the {@code long} and {@code int} arguments.
1069      * &lt;p&gt;
1070      * The floor modulus is {@code x - (floorDiv(x, y) * y)},
1071      * has the same sign as the divisor {@code y}, and
1072      * is in the range of {@code -abs(y) &lt; r &lt; +abs(y)}.
1073      *
1074      * &lt;p&gt;
1075      * The relationship between {@code floorDiv} and {@code floorMod} is such that:
1076      * &lt;ul&gt;
1077      *   &lt;li&gt;{@code floorDiv(x, y) * y + floorMod(x, y) == x}
1078      * &lt;/ul&gt;
1079      * &lt;p&gt;
1080      * See {@link Math#floorMod(int, int) Math.floorMod} for examples and
1081      * a comparison to the {@code %} operator.
1082      *
1083      * @param x the dividend
1084      * @param y the divisor
1085      * @return the floor modulus {@code x - (floorDiv(x, y) * y)}
1086      * @throws ArithmeticException if the divisor {@code y} is zero
1087      * @see Math#floorMod(long, int)
1088      * @see StrictMath#floorDiv(long, int)
1089      * @since 9
1090      */
1091     public static int floorMod(long x, int y) {
1092         return Math.floorMod(x , y);
1093     }
1094 
1095     /**
1096      * Returns the floor modulus of the {@code long} arguments.
1097      * &lt;p&gt;
1098      * The floor modulus is {@code x - (floorDiv(x, y) * y)},
1099      * has the same sign as the divisor {@code y}, and
1100      * is in the range of {@code -abs(y) &lt; r &lt; +abs(y)}.
1101      * &lt;p&gt;
1102      * The relationship between {@code floorDiv} and {@code floorMod} is such that:
1103      * &lt;ul&gt;
1104      *   &lt;li&gt;{@code floorDiv(x, y) * y + floorMod(x, y) == x}
1105      * &lt;/ul&gt;
1106      * &lt;p&gt;
1107      * See {@link Math#floorMod(int, int) Math.floorMod} for examples and
1108      * a comparison to the {@code %} operator.
1109      *
1110      * @param x the dividend
1111      * @param y the divisor
1112      * @return the floor modulus {@code x - (floorDiv(x, y) * y)}
1113      * @throws ArithmeticException if the divisor {@code y} is zero
1114      * @see Math#floorMod(long, long)
1115      * @see StrictMath#floorDiv(long, long)
1116      * @since 1.8
1117      */
1118     public static long floorMod(long x, long y) {
1119         return Math.floorMod(x, y);
1120     }
1121 
1122     /**
1123      * Returns the absolute value of an {@code int} value.
1124      * If the argument is not negative, the argument is returned.
1125      * If the argument is negative, the negation of the argument is returned.
1126      *
<a name="2" id="anc2"></a><span class="line-modified">1127      * &lt;p&gt;Note that if the argument is equal to the value of {@link</span>
<span class="line-modified">1128      * Integer#MIN_VALUE}, the most negative representable {@code int}</span>
<span class="line-modified">1129      * value, the result is that same value, which is negative. In</span>
<span class="line-modified">1130      * contrast, the {@link StrictMath#absExact(int)} method throws an</span>
<span class="line-added">1131      * {@code ArithmeticException} for this value.</span>
1132      *
1133      * @param   a   the  argument whose absolute value is to be determined.
1134      * @return  the absolute value of the argument.
<a name="3" id="anc3"></a><span class="line-added">1135      * @see Math#absExact(int)</span>
1136      */
1137     public static int abs(int a) {
1138         return Math.abs(a);
1139     }
1140 
<a name="4" id="anc4"></a><span class="line-added">1141     /**</span>
<span class="line-added">1142      * Returns the mathematical absolute value of an {@code int} value</span>
<span class="line-added">1143      * if it is exactly representable as an {@code int}, throwing</span>
<span class="line-added">1144      * {@code ArithmeticException} if the result overflows the</span>
<span class="line-added">1145      * positive {@code int} range.</span>
<span class="line-added">1146      *</span>
<span class="line-added">1147      * &lt;p&gt;Since the range of two&#39;s complement integers is asymmetric</span>
<span class="line-added">1148      * with one additional negative value (JLS {@jls 4.2.1}), the</span>
<span class="line-added">1149      * mathematical absolute value of {@link Integer#MIN_VALUE}</span>
<span class="line-added">1150      * overflows the positive {@code int} range, so an exception is</span>
<span class="line-added">1151      * thrown for that argument.</span>
<span class="line-added">1152      *</span>
<span class="line-added">1153      * @param  a  the argument whose absolute value is to be determined</span>
<span class="line-added">1154      * @return the absolute value of the argument, unless overflow occurs</span>
<span class="line-added">1155      * @throws ArithmeticException if the argument is {@link Integer#MIN_VALUE}</span>
<span class="line-added">1156      * @see Math#abs(int)</span>
<span class="line-added">1157      * @see Math#absExact(int)</span>
<span class="line-added">1158      * @since 15</span>
<span class="line-added">1159      */</span>
<span class="line-added">1160     public static int absExact(int a) {</span>
<span class="line-added">1161         return Math.absExact(a);</span>
<span class="line-added">1162     }</span>
<span class="line-added">1163 </span>
1164     /**
1165      * Returns the absolute value of a {@code long} value.
1166      * If the argument is not negative, the argument is returned.
1167      * If the argument is negative, the negation of the argument is returned.
1168      *
<a name="5" id="anc5"></a><span class="line-modified">1169      * &lt;p&gt;Note that if the argument is equal to the value of {@link</span>
<span class="line-modified">1170      * Long#MIN_VALUE}, the most negative representable {@code long}</span>
<span class="line-modified">1171      * value, the result is that same value, which is negative. In</span>
<span class="line-modified">1172      * contrast, the {@link StrictMath#absExact(long)} method throws</span>
<span class="line-added">1173      * an {@code ArithmeticException} for this value.</span>
1174      *
1175      * @param   a   the  argument whose absolute value is to be determined.
1176      * @return  the absolute value of the argument.
<a name="6" id="anc6"></a><span class="line-added">1177      * @see Math#absExact(long)</span>
1178      */
1179     public static long abs(long a) {
1180         return Math.abs(a);
1181     }
1182 
<a name="7" id="anc7"></a><span class="line-added">1183     /**</span>
<span class="line-added">1184      * Returns the mathematical absolute value of an {@code long} value</span>
<span class="line-added">1185      * if it is exactly representable as an {@code long}, throwing</span>
<span class="line-added">1186      * {@code ArithmeticException} if the result overflows the</span>
<span class="line-added">1187      * positive {@code long} range.</span>
<span class="line-added">1188      *</span>
<span class="line-added">1189      * &lt;p&gt;Since the range of two&#39;s complement integers is asymmetric</span>
<span class="line-added">1190      * with one additional negative value (JLS {@jls 4.2.1}), the</span>
<span class="line-added">1191      * mathematical absolute value of {@link Long#MIN_VALUE} overflows</span>
<span class="line-added">1192      * the positive {@code long} range, so an exception is thrown for</span>
<span class="line-added">1193      * that argument.</span>
<span class="line-added">1194      *</span>
<span class="line-added">1195      * @param  a  the argument whose absolute value is to be determined</span>
<span class="line-added">1196      * @return the absolute value of the argument, unless overflow occurs</span>
<span class="line-added">1197      * @throws ArithmeticException if the argument is {@link Long#MIN_VALUE}</span>
<span class="line-added">1198      * @see Math#abs(long)</span>
<span class="line-added">1199      * @see Math#absExact(long)</span>
<span class="line-added">1200      * @since 15</span>
<span class="line-added">1201      */</span>
<span class="line-added">1202     public static long absExact(long a) {</span>
<span class="line-added">1203         return Math.absExact(a);</span>
<span class="line-added">1204     }</span>
<span class="line-added">1205 </span>
1206     /**
1207      * Returns the absolute value of a {@code float} value.
1208      * If the argument is not negative, the argument is returned.
1209      * If the argument is negative, the negation of the argument is returned.
1210      * Special cases:
1211      * &lt;ul&gt;&lt;li&gt;If the argument is positive zero or negative zero, the
1212      * result is positive zero.
1213      * &lt;li&gt;If the argument is infinite, the result is positive infinity.
1214      * &lt;li&gt;If the argument is NaN, the result is NaN.&lt;/ul&gt;
1215      *
1216      * @apiNote As implied by the above, one valid implementation of
1217      * this method is given by the expression below which computes a
1218      * {@code float} with the same exponent and significand as the
1219      * argument but with a guaranteed zero sign bit indicating a
1220      * positive value: &lt;br&gt;
1221      * {@code Float.intBitsToFloat(0x7fffffff &amp; Float.floatToRawIntBits(a))}
1222      *
1223      * @param   a   the argument whose absolute value is to be determined
1224      * @return  the absolute value of the argument.
1225      */
1226     public static float abs(float a) {
1227         return Math.abs(a);
1228     }
1229 
1230     /**
1231      * Returns the absolute value of a {@code double} value.
1232      * If the argument is not negative, the argument is returned.
1233      * If the argument is negative, the negation of the argument is returned.
1234      * Special cases:
1235      * &lt;ul&gt;&lt;li&gt;If the argument is positive zero or negative zero, the result
1236      * is positive zero.
1237      * &lt;li&gt;If the argument is infinite, the result is positive infinity.
1238      * &lt;li&gt;If the argument is NaN, the result is NaN.&lt;/ul&gt;
1239      *
1240      * @apiNote As implied by the above, one valid implementation of
1241      * this method is given by the expression below which computes a
1242      * {@code double} with the same exponent and significand as the
1243      * argument but with a guaranteed zero sign bit indicating a
1244      * positive value: &lt;br&gt;
1245      * {@code Double.longBitsToDouble((Double.doubleToRawLongBits(a)&lt;&lt;1)&gt;&gt;&gt;1)}
1246      *
1247      * @param   a   the argument whose absolute value is to be determined
1248      * @return  the absolute value of the argument.
1249      */
1250     public static double abs(double a) {
1251         return Math.abs(a);
1252     }
1253 
1254     /**
1255      * Returns the greater of two {@code int} values. That is, the
1256      * result is the argument closer to the value of
1257      * {@link Integer#MAX_VALUE}. If the arguments have the same value,
1258      * the result is that same value.
1259      *
1260      * @param   a   an argument.
1261      * @param   b   another argument.
1262      * @return  the larger of {@code a} and {@code b}.
1263      */
1264     @HotSpotIntrinsicCandidate
1265     public static int max(int a, int b) {
1266         return Math.max(a, b);
1267     }
1268 
1269     /**
1270      * Returns the greater of two {@code long} values. That is, the
1271      * result is the argument closer to the value of
1272      * {@link Long#MAX_VALUE}. If the arguments have the same value,
1273      * the result is that same value.
1274      *
1275      * @param   a   an argument.
1276      * @param   b   another argument.
1277      * @return  the larger of {@code a} and {@code b}.
<a name="8" id="anc8"></a><span class="line-modified">1278      */</span>
1279     public static long max(long a, long b) {
1280         return Math.max(a, b);
1281     }
1282 
1283     /**
1284      * Returns the greater of two {@code float} values.  That is,
1285      * the result is the argument closer to positive infinity. If the
1286      * arguments have the same value, the result is that same
1287      * value. If either value is NaN, then the result is NaN.  Unlike
1288      * the numerical comparison operators, this method considers
1289      * negative zero to be strictly smaller than positive zero. If one
1290      * argument is positive zero and the other negative zero, the
1291      * result is positive zero.
1292      *
1293      * @param   a   an argument.
1294      * @param   b   another argument.
1295      * @return  the larger of {@code a} and {@code b}.
1296      */
1297     @HotSpotIntrinsicCandidate
1298     public static float max(float a, float b) {
1299         return Math.max(a, b);
1300     }
1301 
1302     /**
1303      * Returns the greater of two {@code double} values.  That
1304      * is, the result is the argument closer to positive infinity. If
1305      * the arguments have the same value, the result is that same
1306      * value. If either value is NaN, then the result is NaN.  Unlike
1307      * the numerical comparison operators, this method considers
1308      * negative zero to be strictly smaller than positive zero. If one
1309      * argument is positive zero and the other negative zero, the
1310      * result is positive zero.
1311      *
1312      * @param   a   an argument.
1313      * @param   b   another argument.
1314      * @return  the larger of {@code a} and {@code b}.
1315      */
1316     @HotSpotIntrinsicCandidate
1317     public static double max(double a, double b) {
1318         return Math.max(a, b);
1319     }
1320 
1321     /**
1322      * Returns the smaller of two {@code int} values. That is,
1323      * the result the argument closer to the value of
1324      * {@link Integer#MIN_VALUE}.  If the arguments have the same
1325      * value, the result is that same value.
1326      *
1327      * @param   a   an argument.
1328      * @param   b   another argument.
1329      * @return  the smaller of {@code a} and {@code b}.
1330      */
1331     @HotSpotIntrinsicCandidate
1332     public static int min(int a, int b) {
1333         return Math.min(a, b);
1334     }
1335 
1336     /**
1337      * Returns the smaller of two {@code long} values. That is,
1338      * the result is the argument closer to the value of
1339      * {@link Long#MIN_VALUE}. If the arguments have the same
1340      * value, the result is that same value.
1341      *
1342      * @param   a   an argument.
1343      * @param   b   another argument.
1344      * @return  the smaller of {@code a} and {@code b}.
1345      */
1346     public static long min(long a, long b) {
1347         return Math.min(a, b);
1348     }
1349 
1350     /**
1351      * Returns the smaller of two {@code float} values.  That is,
1352      * the result is the value closer to negative infinity. If the
1353      * arguments have the same value, the result is that same
1354      * value. If either value is NaN, then the result is NaN.  Unlike
1355      * the numerical comparison operators, this method considers
1356      * negative zero to be strictly smaller than positive zero.  If
1357      * one argument is positive zero and the other is negative zero,
1358      * the result is negative zero.
1359      *
1360      * @param   a   an argument.
1361      * @param   b   another argument.
1362      * @return  the smaller of {@code a} and {@code b.}
1363      */
1364     @HotSpotIntrinsicCandidate
1365     public static float min(float a, float b) {
1366         return Math.min(a, b);
1367     }
1368 
1369     /**
1370      * Returns the smaller of two {@code double} values.  That
1371      * is, the result is the value closer to negative infinity. If the
1372      * arguments have the same value, the result is that same
1373      * value. If either value is NaN, then the result is NaN.  Unlike
1374      * the numerical comparison operators, this method considers
1375      * negative zero to be strictly smaller than positive zero. If one
1376      * argument is positive zero and the other is negative zero, the
1377      * result is negative zero.
1378      *
1379      * @param   a   an argument.
1380      * @param   b   another argument.
1381      * @return  the smaller of {@code a} and {@code b}.
1382      */
1383     @HotSpotIntrinsicCandidate
1384     public static double min(double a, double b) {
1385         return Math.min(a, b);
1386     }
1387 
1388     /**
1389      * Returns the fused multiply add of the three arguments; that is,
1390      * returns the exact product of the first two arguments summed
1391      * with the third argument and then rounded once to the nearest
1392      * {@code double}.
1393      *
1394      * The rounding is done using the {@linkplain
1395      * java.math.RoundingMode#HALF_EVEN round to nearest even
1396      * rounding mode}.
1397      *
1398      * In contrast, if {@code a * b + c} is evaluated as a regular
1399      * floating-point expression, two rounding errors are involved,
1400      * the first for the multiply operation, the second for the
1401      * addition operation.
1402      *
1403      * &lt;p&gt;Special cases:
1404      * &lt;ul&gt;
1405      * &lt;li&gt; If any argument is NaN, the result is NaN.
1406      *
1407      * &lt;li&gt; If one of the first two arguments is infinite and the
1408      * other is zero, the result is NaN.
1409      *
1410      * &lt;li&gt; If the exact product of the first two arguments is infinite
1411      * (in other words, at least one of the arguments is infinite and
1412      * the other is neither zero nor NaN) and the third argument is an
1413      * infinity of the opposite sign, the result is NaN.
1414      *
1415      * &lt;/ul&gt;
1416      *
1417      * &lt;p&gt;Note that {@code fusedMac(a, 1.0, c)} returns the same
1418      * result as ({@code a + c}).  However,
1419      * {@code fusedMac(a, b, +0.0)} does &lt;em&gt;not&lt;/em&gt; always return the
1420      * same result as ({@code a * b}) since
1421      * {@code fusedMac(-0.0, +0.0, +0.0)} is {@code +0.0} while
1422      * ({@code -0.0 * +0.0}) is {@code -0.0}; {@code fusedMac(a, b, -0.0)} is
1423      * equivalent to ({@code a * b}) however.
1424      *
1425      * @apiNote This method corresponds to the fusedMultiplyAdd
1426      * operation defined in IEEE 754-2008.
1427      *
1428      * @param a a value
1429      * @param b a value
1430      * @param c a value
1431      *
1432      * @return (&lt;i&gt;a&lt;/i&gt;&amp;nbsp;&amp;times;&amp;nbsp;&lt;i&gt;b&lt;/i&gt;&amp;nbsp;+&amp;nbsp;&lt;i&gt;c&lt;/i&gt;)
1433      * computed, as if with unlimited range and precision, and rounded
1434      * once to the nearest {@code double} value
1435      *
1436      * @since 9
1437      */
1438     public static double fma(double a, double b, double c) {
1439         return Math.fma(a, b, c);
1440     }
1441 
1442     /**
1443      * Returns the fused multiply add of the three arguments; that is,
1444      * returns the exact product of the first two arguments summed
1445      * with the third argument and then rounded once to the nearest
1446      * {@code float}.
1447      *
1448      * The rounding is done using the {@linkplain
1449      * java.math.RoundingMode#HALF_EVEN round to nearest even
1450      * rounding mode}.
1451      *
1452      * In contrast, if {@code a * b + c} is evaluated as a regular
1453      * floating-point expression, two rounding errors are involved,
1454      * the first for the multiply operation, the second for the
1455      * addition operation.
1456      *
1457      * &lt;p&gt;Special cases:
1458      * &lt;ul&gt;
1459      * &lt;li&gt; If any argument is NaN, the result is NaN.
1460      *
1461      * &lt;li&gt; If one of the first two arguments is infinite and the
1462      * other is zero, the result is NaN.
1463      *
1464      * &lt;li&gt; If the exact product of the first two arguments is infinite
1465      * (in other words, at least one of the arguments is infinite and
1466      * the other is neither zero nor NaN) and the third argument is an
1467      * infinity of the opposite sign, the result is NaN.
1468      *
1469      * &lt;/ul&gt;
1470      *
1471      * &lt;p&gt;Note that {@code fma(a, 1.0f, c)} returns the same
1472      * result as ({@code a + c}).  However,
1473      * {@code fma(a, b, +0.0f)} does &lt;em&gt;not&lt;/em&gt; always return the
1474      * same result as ({@code a * b}) since
1475      * {@code fma(-0.0f, +0.0f, +0.0f)} is {@code +0.0f} while
1476      * ({@code -0.0f * +0.0f}) is {@code -0.0f}; {@code fma(a, b, -0.0f)} is
1477      * equivalent to ({@code a * b}) however.
1478      *
1479      * @apiNote This method corresponds to the fusedMultiplyAdd
1480      * operation defined in IEEE 754-2008.
1481      *
1482      * @param a a value
1483      * @param b a value
1484      * @param c a value
1485      *
1486      * @return (&lt;i&gt;a&lt;/i&gt;&amp;nbsp;&amp;times;&amp;nbsp;&lt;i&gt;b&lt;/i&gt;&amp;nbsp;+&amp;nbsp;&lt;i&gt;c&lt;/i&gt;)
1487      * computed, as if with unlimited range and precision, and rounded
1488      * once to the nearest {@code float} value
1489      *
1490      * @since 9
1491      */
1492     public static float fma(float a, float b, float c) {
1493         return Math.fma(a, b, c);
1494     }
1495 
1496     /**
1497      * Returns the size of an ulp of the argument.  An ulp, unit in
1498      * the last place, of a {@code double} value is the positive
1499      * distance between this floating-point value and the {@code
1500      * double} value next larger in magnitude.  Note that for non-NaN
1501      * &lt;i&gt;x&lt;/i&gt;, &lt;code&gt;ulp(-&lt;i&gt;x&lt;/i&gt;) == ulp(&lt;i&gt;x&lt;/i&gt;)&lt;/code&gt;.
1502      *
1503      * &lt;p&gt;Special Cases:
1504      * &lt;ul&gt;
1505      * &lt;li&gt; If the argument is NaN, then the result is NaN.
1506      * &lt;li&gt; If the argument is positive or negative infinity, then the
1507      * result is positive infinity.
1508      * &lt;li&gt; If the argument is positive or negative zero, then the result is
1509      * {@code Double.MIN_VALUE}.
1510      * &lt;li&gt; If the argument is &amp;plusmn;{@code Double.MAX_VALUE}, then
1511      * the result is equal to 2&lt;sup&gt;971&lt;/sup&gt;.
1512      * &lt;/ul&gt;
1513      *
1514      * @param d the floating-point value whose ulp is to be returned
1515      * @return the size of an ulp of the argument
1516      * @author Joseph D. Darcy
1517      * @since 1.5
1518      */
1519     public static double ulp(double d) {
1520         return Math.ulp(d);
1521     }
1522 
1523     /**
1524      * Returns the size of an ulp of the argument.  An ulp, unit in
1525      * the last place, of a {@code float} value is the positive
1526      * distance between this floating-point value and the {@code
1527      * float} value next larger in magnitude.  Note that for non-NaN
1528      * &lt;i&gt;x&lt;/i&gt;, &lt;code&gt;ulp(-&lt;i&gt;x&lt;/i&gt;) == ulp(&lt;i&gt;x&lt;/i&gt;)&lt;/code&gt;.
1529      *
1530      * &lt;p&gt;Special Cases:
1531      * &lt;ul&gt;
1532      * &lt;li&gt; If the argument is NaN, then the result is NaN.
1533      * &lt;li&gt; If the argument is positive or negative infinity, then the
1534      * result is positive infinity.
1535      * &lt;li&gt; If the argument is positive or negative zero, then the result is
1536      * {@code Float.MIN_VALUE}.
1537      * &lt;li&gt; If the argument is &amp;plusmn;{@code Float.MAX_VALUE}, then
1538      * the result is equal to 2&lt;sup&gt;104&lt;/sup&gt;.
1539      * &lt;/ul&gt;
1540      *
1541      * @param f the floating-point value whose ulp is to be returned
1542      * @return the size of an ulp of the argument
1543      * @author Joseph D. Darcy
1544      * @since 1.5
1545      */
1546     public static float ulp(float f) {
1547         return Math.ulp(f);
1548     }
1549 
1550     /**
1551      * Returns the signum function of the argument; zero if the argument
1552      * is zero, 1.0 if the argument is greater than zero, -1.0 if the
1553      * argument is less than zero.
1554      *
1555      * &lt;p&gt;Special Cases:
1556      * &lt;ul&gt;
1557      * &lt;li&gt; If the argument is NaN, then the result is NaN.
1558      * &lt;li&gt; If the argument is positive zero or negative zero, then the
1559      *      result is the same as the argument.
1560      * &lt;/ul&gt;
1561      *
1562      * @param d the floating-point value whose signum is to be returned
1563      * @return the signum function of the argument
1564      * @author Joseph D. Darcy
1565      * @since 1.5
1566      */
1567     public static double signum(double d) {
1568         return Math.signum(d);
1569     }
1570 
1571     /**
1572      * Returns the signum function of the argument; zero if the argument
1573      * is zero, 1.0f if the argument is greater than zero, -1.0f if the
1574      * argument is less than zero.
1575      *
1576      * &lt;p&gt;Special Cases:
1577      * &lt;ul&gt;
1578      * &lt;li&gt; If the argument is NaN, then the result is NaN.
1579      * &lt;li&gt; If the argument is positive zero or negative zero, then the
1580      *      result is the same as the argument.
1581      * &lt;/ul&gt;
1582      *
1583      * @param f the floating-point value whose signum is to be returned
1584      * @return the signum function of the argument
1585      * @author Joseph D. Darcy
1586      * @since 1.5
1587      */
1588     public static float signum(float f) {
1589         return Math.signum(f);
1590     }
1591 
1592     /**
1593      * Returns the hyperbolic sine of a {@code double} value.
1594      * The hyperbolic sine of &lt;i&gt;x&lt;/i&gt; is defined to be
1595      * (&lt;i&gt;e&lt;sup&gt;x&lt;/sup&gt;&amp;nbsp;-&amp;nbsp;e&lt;sup&gt;-x&lt;/sup&gt;&lt;/i&gt;)/2
1596      * where &lt;i&gt;e&lt;/i&gt; is {@linkplain Math#E Euler&#39;s number}.
1597      *
1598      * &lt;p&gt;Special cases:
1599      * &lt;ul&gt;
1600      *
1601      * &lt;li&gt;If the argument is NaN, then the result is NaN.
1602      *
1603      * &lt;li&gt;If the argument is infinite, then the result is an infinity
1604      * with the same sign as the argument.
1605      *
1606      * &lt;li&gt;If the argument is zero, then the result is a zero with the
1607      * same sign as the argument.
1608      *
1609      * &lt;/ul&gt;
1610      *
1611      * @param   x The number whose hyperbolic sine is to be returned.
1612      * @return  The hyperbolic sine of {@code x}.
1613      * @since 1.5
1614      */
1615     public static native double sinh(double x);
1616 
1617     /**
1618      * Returns the hyperbolic cosine of a {@code double} value.
1619      * The hyperbolic cosine of &lt;i&gt;x&lt;/i&gt; is defined to be
1620      * (&lt;i&gt;e&lt;sup&gt;x&lt;/sup&gt;&amp;nbsp;+&amp;nbsp;e&lt;sup&gt;-x&lt;/sup&gt;&lt;/i&gt;)/2
1621      * where &lt;i&gt;e&lt;/i&gt; is {@linkplain Math#E Euler&#39;s number}.
1622      *
1623      * &lt;p&gt;Special cases:
1624      * &lt;ul&gt;
1625      *
1626      * &lt;li&gt;If the argument is NaN, then the result is NaN.
1627      *
1628      * &lt;li&gt;If the argument is infinite, then the result is positive
1629      * infinity.
1630      *
1631      * &lt;li&gt;If the argument is zero, then the result is {@code 1.0}.
1632      *
1633      * &lt;/ul&gt;
1634      *
1635      * @param   x The number whose hyperbolic cosine is to be returned.
1636      * @return  The hyperbolic cosine of {@code x}.
1637      * @since 1.5
1638      */
1639     public static native double cosh(double x);
1640 
1641     /**
1642      * Returns the hyperbolic tangent of a {@code double} value.
1643      * The hyperbolic tangent of &lt;i&gt;x&lt;/i&gt; is defined to be
1644      * (&lt;i&gt;e&lt;sup&gt;x&lt;/sup&gt;&amp;nbsp;-&amp;nbsp;e&lt;sup&gt;-x&lt;/sup&gt;&lt;/i&gt;)/(&lt;i&gt;e&lt;sup&gt;x&lt;/sup&gt;&amp;nbsp;+&amp;nbsp;e&lt;sup&gt;-x&lt;/sup&gt;&lt;/i&gt;),
1645      * in other words, {@linkplain Math#sinh
1646      * sinh(&lt;i&gt;x&lt;/i&gt;)}/{@linkplain Math#cosh cosh(&lt;i&gt;x&lt;/i&gt;)}.  Note
1647      * that the absolute value of the exact tanh is always less than
1648      * 1.
1649      *
1650      * &lt;p&gt;Special cases:
1651      * &lt;ul&gt;
1652      *
1653      * &lt;li&gt;If the argument is NaN, then the result is NaN.
1654      *
1655      * &lt;li&gt;If the argument is zero, then the result is a zero with the
1656      * same sign as the argument.
1657      *
1658      * &lt;li&gt;If the argument is positive infinity, then the result is
1659      * {@code +1.0}.
1660      *
1661      * &lt;li&gt;If the argument is negative infinity, then the result is
1662      * {@code -1.0}.
1663      *
1664      * &lt;/ul&gt;
1665      *
1666      * @param   x The number whose hyperbolic tangent is to be returned.
1667      * @return  The hyperbolic tangent of {@code x}.
1668      * @since 1.5
1669      */
1670     public static native double tanh(double x);
1671 
1672     /**
1673      * Returns sqrt(&lt;i&gt;x&lt;/i&gt;&lt;sup&gt;2&lt;/sup&gt;&amp;nbsp;+&lt;i&gt;y&lt;/i&gt;&lt;sup&gt;2&lt;/sup&gt;)
1674      * without intermediate overflow or underflow.
1675      *
1676      * &lt;p&gt;Special cases:
1677      * &lt;ul&gt;
1678      *
1679      * &lt;li&gt; If either argument is infinite, then the result
1680      * is positive infinity.
1681      *
1682      * &lt;li&gt; If either argument is NaN and neither argument is infinite,
1683      * then the result is NaN.
1684      *
1685      * &lt;/ul&gt;
1686      *
1687      * @param x a value
1688      * @param y a value
1689      * @return sqrt(&lt;i&gt;x&lt;/i&gt;&lt;sup&gt;2&lt;/sup&gt;&amp;nbsp;+&lt;i&gt;y&lt;/i&gt;&lt;sup&gt;2&lt;/sup&gt;)
1690      * without intermediate overflow or underflow
1691      * @since 1.5
1692      */
1693     public static double hypot(double x, double y) {
1694         return FdLibm.Hypot.compute(x, y);
1695     }
1696 
1697     /**
1698      * Returns &lt;i&gt;e&lt;/i&gt;&lt;sup&gt;x&lt;/sup&gt;&amp;nbsp;-1.  Note that for values of
1699      * &lt;i&gt;x&lt;/i&gt; near 0, the exact sum of
1700      * {@code expm1(x)}&amp;nbsp;+&amp;nbsp;1 is much closer to the true
1701      * result of &lt;i&gt;e&lt;/i&gt;&lt;sup&gt;x&lt;/sup&gt; than {@code exp(x)}.
1702      *
1703      * &lt;p&gt;Special cases:
1704      * &lt;ul&gt;
1705      * &lt;li&gt;If the argument is NaN, the result is NaN.
1706      *
1707      * &lt;li&gt;If the argument is positive infinity, then the result is
1708      * positive infinity.
1709      *
1710      * &lt;li&gt;If the argument is negative infinity, then the result is
1711      * -1.0.
1712      *
1713      * &lt;li&gt;If the argument is zero, then the result is a zero with the
1714      * same sign as the argument.
1715      *
1716      * &lt;/ul&gt;
1717      *
1718      * @param   x   the exponent to raise &lt;i&gt;e&lt;/i&gt; to in the computation of
1719      *              &lt;i&gt;e&lt;/i&gt;&lt;sup&gt;{@code x}&lt;/sup&gt;&amp;nbsp;-1.
1720      * @return  the value &lt;i&gt;e&lt;/i&gt;&lt;sup&gt;{@code x}&lt;/sup&gt;&amp;nbsp;-&amp;nbsp;1.
1721      * @since 1.5
1722      */
1723     public static native double expm1(double x);
1724 
1725     /**
1726      * Returns the natural logarithm of the sum of the argument and 1.
1727      * Note that for small values {@code x}, the result of
1728      * {@code log1p(x)} is much closer to the true result of ln(1
1729      * + {@code x}) than the floating-point evaluation of
1730      * {@code log(1.0+x)}.
1731      *
1732      * &lt;p&gt;Special cases:
1733      * &lt;ul&gt;
1734      *
1735      * &lt;li&gt;If the argument is NaN or less than -1, then the result is
1736      * NaN.
1737      *
1738      * &lt;li&gt;If the argument is positive infinity, then the result is
1739      * positive infinity.
1740      *
1741      * &lt;li&gt;If the argument is negative one, then the result is
1742      * negative infinity.
1743      *
1744      * &lt;li&gt;If the argument is zero, then the result is a zero with the
1745      * same sign as the argument.
1746      *
1747      * &lt;/ul&gt;
1748      *
1749      * @param   x   a value
1750      * @return the value ln({@code x}&amp;nbsp;+&amp;nbsp;1), the natural
1751      * log of {@code x}&amp;nbsp;+&amp;nbsp;1
1752      * @since 1.5
1753      */
1754     public static native double log1p(double x);
1755 
1756     /**
1757      * Returns the first floating-point argument with the sign of the
1758      * second floating-point argument.  For this method, a NaN
1759      * {@code sign} argument is always treated as if it were
1760      * positive.
1761      *
1762      * @param magnitude  the parameter providing the magnitude of the result
1763      * @param sign   the parameter providing the sign of the result
1764      * @return a value with the magnitude of {@code magnitude}
1765      * and the sign of {@code sign}.
1766      * @since 1.6
1767      */
1768     public static double copySign(double magnitude, double sign) {
1769         return Math.copySign(magnitude, (Double.isNaN(sign)?1.0d:sign));
1770     }
1771 
1772     /**
1773      * Returns the first floating-point argument with the sign of the
1774      * second floating-point argument.  For this method, a NaN
1775      * {@code sign} argument is always treated as if it were
1776      * positive.
1777      *
1778      * @param magnitude  the parameter providing the magnitude of the result
1779      * @param sign   the parameter providing the sign of the result
1780      * @return a value with the magnitude of {@code magnitude}
1781      * and the sign of {@code sign}.
1782      * @since 1.6
1783      */
1784     public static float copySign(float magnitude, float sign) {
1785         return Math.copySign(magnitude, (Float.isNaN(sign)?1.0f:sign));
1786     }
1787     /**
1788      * Returns the unbiased exponent used in the representation of a
1789      * {@code float}.  Special cases:
1790      *
1791      * &lt;ul&gt;
1792      * &lt;li&gt;If the argument is NaN or infinite, then the result is
1793      * {@link Float#MAX_EXPONENT} + 1.
1794      * &lt;li&gt;If the argument is zero or subnormal, then the result is
1795      * {@link Float#MIN_EXPONENT} -1.
1796      * &lt;/ul&gt;
1797      * @param f a {@code float} value
1798      * @return the unbiased exponent of the argument
1799      * @since 1.6
1800      */
1801     public static int getExponent(float f) {
1802         return Math.getExponent(f);
1803     }
1804 
1805     /**
1806      * Returns the unbiased exponent used in the representation of a
1807      * {@code double}.  Special cases:
1808      *
1809      * &lt;ul&gt;
1810      * &lt;li&gt;If the argument is NaN or infinite, then the result is
1811      * {@link Double#MAX_EXPONENT} + 1.
1812      * &lt;li&gt;If the argument is zero or subnormal, then the result is
1813      * {@link Double#MIN_EXPONENT} -1.
1814      * &lt;/ul&gt;
1815      * @param d a {@code double} value
1816      * @return the unbiased exponent of the argument
1817      * @since 1.6
1818      */
1819     public static int getExponent(double d) {
1820         return Math.getExponent(d);
1821     }
1822 
1823     /**
1824      * Returns the floating-point number adjacent to the first
1825      * argument in the direction of the second argument.  If both
1826      * arguments compare as equal the second argument is returned.
1827      *
1828      * &lt;p&gt;Special cases:
1829      * &lt;ul&gt;
1830      * &lt;li&gt; If either argument is a NaN, then NaN is returned.
1831      *
1832      * &lt;li&gt; If both arguments are signed zeros, {@code direction}
1833      * is returned unchanged (as implied by the requirement of
1834      * returning the second argument if the arguments compare as
1835      * equal).
1836      *
1837      * &lt;li&gt; If {@code start} is
1838      * &amp;plusmn;{@link Double#MIN_VALUE} and {@code direction}
1839      * has a value such that the result should have a smaller
1840      * magnitude, then a zero with the same sign as {@code start}
1841      * is returned.
1842      *
1843      * &lt;li&gt; If {@code start} is infinite and
1844      * {@code direction} has a value such that the result should
1845      * have a smaller magnitude, {@link Double#MAX_VALUE} with the
1846      * same sign as {@code start} is returned.
1847      *
1848      * &lt;li&gt; If {@code start} is equal to &amp;plusmn;
1849      * {@link Double#MAX_VALUE} and {@code direction} has a
1850      * value such that the result should have a larger magnitude, an
1851      * infinity with same sign as {@code start} is returned.
1852      * &lt;/ul&gt;
1853      *
1854      * @param start  starting floating-point value
1855      * @param direction value indicating which of
1856      * {@code start}&#39;s neighbors or {@code start} should
1857      * be returned
1858      * @return The floating-point number adjacent to {@code start} in the
1859      * direction of {@code direction}.
1860      * @since 1.6
1861      */
1862     public static double nextAfter(double start, double direction) {
1863         return Math.nextAfter(start, direction);
1864     }
1865 
1866     /**
1867      * Returns the floating-point number adjacent to the first
1868      * argument in the direction of the second argument.  If both
1869      * arguments compare as equal a value equivalent to the second argument
1870      * is returned.
1871      *
1872      * &lt;p&gt;Special cases:
1873      * &lt;ul&gt;
1874      * &lt;li&gt; If either argument is a NaN, then NaN is returned.
1875      *
1876      * &lt;li&gt; If both arguments are signed zeros, a value equivalent
1877      * to {@code direction} is returned.
1878      *
1879      * &lt;li&gt; If {@code start} is
1880      * &amp;plusmn;{@link Float#MIN_VALUE} and {@code direction}
1881      * has a value such that the result should have a smaller
1882      * magnitude, then a zero with the same sign as {@code start}
1883      * is returned.
1884      *
1885      * &lt;li&gt; If {@code start} is infinite and
1886      * {@code direction} has a value such that the result should
1887      * have a smaller magnitude, {@link Float#MAX_VALUE} with the
1888      * same sign as {@code start} is returned.
1889      *
1890      * &lt;li&gt; If {@code start} is equal to &amp;plusmn;
1891      * {@link Float#MAX_VALUE} and {@code direction} has a
1892      * value such that the result should have a larger magnitude, an
1893      * infinity with same sign as {@code start} is returned.
1894      * &lt;/ul&gt;
1895      *
1896      * @param start  starting floating-point value
1897      * @param direction value indicating which of
1898      * {@code start}&#39;s neighbors or {@code start} should
1899      * be returned
1900      * @return The floating-point number adjacent to {@code start} in the
1901      * direction of {@code direction}.
1902      * @since 1.6
1903      */
1904     public static float nextAfter(float start, double direction) {
1905         return Math.nextAfter(start, direction);
1906     }
1907 
1908     /**
1909      * Returns the floating-point value adjacent to {@code d} in
1910      * the direction of positive infinity.  This method is
1911      * semantically equivalent to {@code nextAfter(d,
1912      * Double.POSITIVE_INFINITY)}; however, a {@code nextUp}
1913      * implementation may run faster than its equivalent
1914      * {@code nextAfter} call.
1915      *
1916      * &lt;p&gt;Special Cases:
1917      * &lt;ul&gt;
1918      * &lt;li&gt; If the argument is NaN, the result is NaN.
1919      *
1920      * &lt;li&gt; If the argument is positive infinity, the result is
1921      * positive infinity.
1922      *
1923      * &lt;li&gt; If the argument is zero, the result is
1924      * {@link Double#MIN_VALUE}
1925      *
1926      * &lt;/ul&gt;
1927      *
1928      * @param d starting floating-point value
1929      * @return The adjacent floating-point value closer to positive
1930      * infinity.
1931      * @since 1.6
1932      */
1933     public static double nextUp(double d) {
1934         return Math.nextUp(d);
1935     }
1936 
1937     /**
1938      * Returns the floating-point value adjacent to {@code f} in
1939      * the direction of positive infinity.  This method is
1940      * semantically equivalent to {@code nextAfter(f,
1941      * Float.POSITIVE_INFINITY)}; however, a {@code nextUp}
1942      * implementation may run faster than its equivalent
1943      * {@code nextAfter} call.
1944      *
1945      * &lt;p&gt;Special Cases:
1946      * &lt;ul&gt;
1947      * &lt;li&gt; If the argument is NaN, the result is NaN.
1948      *
1949      * &lt;li&gt; If the argument is positive infinity, the result is
1950      * positive infinity.
1951      *
1952      * &lt;li&gt; If the argument is zero, the result is
1953      * {@link Float#MIN_VALUE}
1954      *
1955      * &lt;/ul&gt;
1956      *
1957      * @param f starting floating-point value
1958      * @return The adjacent floating-point value closer to positive
1959      * infinity.
1960      * @since 1.6
1961      */
1962     public static float nextUp(float f) {
1963         return Math.nextUp(f);
1964     }
1965 
1966     /**
1967      * Returns the floating-point value adjacent to {@code d} in
1968      * the direction of negative infinity.  This method is
1969      * semantically equivalent to {@code nextAfter(d,
1970      * Double.NEGATIVE_INFINITY)}; however, a
1971      * {@code nextDown} implementation may run faster than its
1972      * equivalent {@code nextAfter} call.
1973      *
1974      * &lt;p&gt;Special Cases:
1975      * &lt;ul&gt;
1976      * &lt;li&gt; If the argument is NaN, the result is NaN.
1977      *
1978      * &lt;li&gt; If the argument is negative infinity, the result is
1979      * negative infinity.
1980      *
1981      * &lt;li&gt; If the argument is zero, the result is
1982      * {@code -Double.MIN_VALUE}
1983      *
1984      * &lt;/ul&gt;
1985      *
1986      * @param d  starting floating-point value
1987      * @return The adjacent floating-point value closer to negative
1988      * infinity.
1989      * @since 1.8
1990      */
1991     public static double nextDown(double d) {
1992         return Math.nextDown(d);
1993     }
1994 
1995     /**
1996      * Returns the floating-point value adjacent to {@code f} in
1997      * the direction of negative infinity.  This method is
1998      * semantically equivalent to {@code nextAfter(f,
1999      * Float.NEGATIVE_INFINITY)}; however, a
2000      * {@code nextDown} implementation may run faster than its
2001      * equivalent {@code nextAfter} call.
2002      *
2003      * &lt;p&gt;Special Cases:
2004      * &lt;ul&gt;
2005      * &lt;li&gt; If the argument is NaN, the result is NaN.
2006      *
2007      * &lt;li&gt; If the argument is negative infinity, the result is
2008      * negative infinity.
2009      *
2010      * &lt;li&gt; If the argument is zero, the result is
2011      * {@code -Float.MIN_VALUE}
2012      *
2013      * &lt;/ul&gt;
2014      *
2015      * @param f  starting floating-point value
2016      * @return The adjacent floating-point value closer to negative
2017      * infinity.
2018      * @since 1.8
2019      */
2020     public static float nextDown(float f) {
2021         return Math.nextDown(f);
2022     }
2023 
2024     /**
2025      * Returns {@code d} &amp;times;
2026      * 2&lt;sup&gt;{@code scaleFactor}&lt;/sup&gt; rounded as if performed
2027      * by a single correctly rounded floating-point multiply to a
2028      * member of the double value set.  See the Java
2029      * Language Specification for a discussion of floating-point
2030      * value sets.  If the exponent of the result is between {@link
2031      * Double#MIN_EXPONENT} and {@link Double#MAX_EXPONENT}, the
2032      * answer is calculated exactly.  If the exponent of the result
2033      * would be larger than {@code Double.MAX_EXPONENT}, an
2034      * infinity is returned.  Note that if the result is subnormal,
2035      * precision may be lost; that is, when {@code scalb(x, n)}
2036      * is subnormal, {@code scalb(scalb(x, n), -n)} may not equal
2037      * &lt;i&gt;x&lt;/i&gt;.  When the result is non-NaN, the result has the same
2038      * sign as {@code d}.
2039      *
2040      * &lt;p&gt;Special cases:
2041      * &lt;ul&gt;
2042      * &lt;li&gt; If the first argument is NaN, NaN is returned.
2043      * &lt;li&gt; If the first argument is infinite, then an infinity of the
2044      * same sign is returned.
2045      * &lt;li&gt; If the first argument is zero, then a zero of the same
2046      * sign is returned.
2047      * &lt;/ul&gt;
2048      *
2049      * @param d number to be scaled by a power of two.
2050      * @param scaleFactor power of 2 used to scale {@code d}
2051      * @return {@code d} &amp;times; 2&lt;sup&gt;{@code scaleFactor}&lt;/sup&gt;
2052      * @since 1.6
2053      */
2054     public static double scalb(double d, int scaleFactor) {
2055         return Math.scalb(d, scaleFactor);
2056     }
2057 
2058     /**
2059      * Returns {@code f} &amp;times;
2060      * 2&lt;sup&gt;{@code scaleFactor}&lt;/sup&gt; rounded as if performed
2061      * by a single correctly rounded floating-point multiply to a
2062      * member of the float value set.  See the Java
2063      * Language Specification for a discussion of floating-point
2064      * value sets.  If the exponent of the result is between {@link
2065      * Float#MIN_EXPONENT} and {@link Float#MAX_EXPONENT}, the
2066      * answer is calculated exactly.  If the exponent of the result
2067      * would be larger than {@code Float.MAX_EXPONENT}, an
2068      * infinity is returned.  Note that if the result is subnormal,
2069      * precision may be lost; that is, when {@code scalb(x, n)}
2070      * is subnormal, {@code scalb(scalb(x, n), -n)} may not equal
2071      * &lt;i&gt;x&lt;/i&gt;.  When the result is non-NaN, the result has the same
2072      * sign as {@code f}.
2073      *
2074      * &lt;p&gt;Special cases:
2075      * &lt;ul&gt;
2076      * &lt;li&gt; If the first argument is NaN, NaN is returned.
2077      * &lt;li&gt; If the first argument is infinite, then an infinity of the
2078      * same sign is returned.
2079      * &lt;li&gt; If the first argument is zero, then a zero of the same
2080      * sign is returned.
2081      * &lt;/ul&gt;
2082      *
2083      * @param f number to be scaled by a power of two.
2084      * @param scaleFactor power of 2 used to scale {@code f}
2085      * @return {@code f} &amp;times; 2&lt;sup&gt;{@code scaleFactor}&lt;/sup&gt;
2086      * @since 1.6
2087      */
2088     public static float scalb(float f, int scaleFactor) {
2089         return Math.scalb(f, scaleFactor);
2090     }
2091 }
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/java/util/SimpleTimeZone.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 /*
  27  * (C) Copyright Taligent, Inc. 1996 - All Rights Reserved
  28  * (C) Copyright IBM Corp. 1996 - All Rights Reserved
  29  *
  30  *   The original version of this source code and documentation is copyrighted
  31  * and owned by Taligent, Inc., a wholly-owned subsidiary of IBM. These
  32  * materials are provided under terms of a License Agreement between Taligent
  33  * and Sun. This technology is protected by multiple US and International
  34  * patents. This notice and attribution to Taligent may not be removed.
  35  *   Taligent is a registered trademark of Taligent, Inc.
  36  *
  37  */
  38 
  39 package java.util;
  40 
  41 import java.io.ObjectInputStream;
  42 import java.io.ObjectOutputStream;
  43 import java.io.IOException;
  44 import java.io.InvalidObjectException;
  45 import sun.util.calendar.CalendarSystem;
  46 import sun.util.calendar.CalendarUtils;
  47 import sun.util.calendar.BaseCalendar;
  48 import sun.util.calendar.Gregorian;
  49 
  50 /**
  51  * {@code SimpleTimeZone} is a concrete subclass of {@code TimeZone}
  52  * that represents a time zone for use with a Gregorian calendar.
  53  * The class holds an offset from GMT, called &lt;em&gt;raw offset&lt;/em&gt;, and start
  54  * and end rules for a daylight saving time schedule.  Since it only holds
  55  * single values for each, it cannot handle historical changes in the offset
  56  * from GMT and the daylight saving schedule, except that the {@link
  57  * #setStartYear setStartYear} method can specify the year when the daylight
  58  * saving time schedule starts in effect.
  59  * &lt;p&gt;
  60  * To construct a {@code SimpleTimeZone} with a daylight saving time
  61  * schedule, the schedule can be described with a set of rules,
  62  * &lt;em&gt;start-rule&lt;/em&gt; and &lt;em&gt;end-rule&lt;/em&gt;. A day when daylight saving time
  63  * starts or ends is specified by a combination of &lt;em&gt;month&lt;/em&gt;,
  64  * &lt;em&gt;day-of-month&lt;/em&gt;, and &lt;em&gt;day-of-week&lt;/em&gt; values. The &lt;em&gt;month&lt;/em&gt;
  65  * value is represented by a Calendar {@link Calendar#MONTH MONTH} field
  66  * value, such as {@link Calendar#MARCH}. The &lt;em&gt;day-of-week&lt;/em&gt; value is
  67  * represented by a Calendar {@link Calendar#DAY_OF_WEEK DAY_OF_WEEK} value,
  68  * such as {@link Calendar#SUNDAY SUNDAY}. The meanings of value combinations
  69  * are as follows.
  70  *
  71  * &lt;ul&gt;
  72  * &lt;li&gt;&lt;b&gt;Exact day of month&lt;/b&gt;&lt;br&gt;
  73  * To specify an exact day of month, set the &lt;em&gt;month&lt;/em&gt; and
  74  * &lt;em&gt;day-of-month&lt;/em&gt; to an exact value, and &lt;em&gt;day-of-week&lt;/em&gt; to zero. For
  75  * example, to specify March 1, set the &lt;em&gt;month&lt;/em&gt; to {@link Calendar#MARCH
  76  * MARCH}, &lt;em&gt;day-of-month&lt;/em&gt; to 1, and &lt;em&gt;day-of-week&lt;/em&gt; to 0.&lt;/li&gt;
  77  *
  78  * &lt;li&gt;&lt;b&gt;Day of week on or after day of month&lt;/b&gt;&lt;br&gt;
  79  * To specify a day of week on or after an exact day of month, set the
  80  * &lt;em&gt;month&lt;/em&gt; to an exact month value, &lt;em&gt;day-of-month&lt;/em&gt; to the day on
  81  * or after which the rule is applied, and &lt;em&gt;day-of-week&lt;/em&gt; to a negative {@link
  82  * Calendar#DAY_OF_WEEK DAY_OF_WEEK} field value. For example, to specify the
  83  * second Sunday of April, set &lt;em&gt;month&lt;/em&gt; to {@link Calendar#APRIL APRIL},
  84  * &lt;em&gt;day-of-month&lt;/em&gt; to 8, and &lt;em&gt;day-of-week&lt;/em&gt; to {@code -}{@link
  85  * Calendar#SUNDAY SUNDAY}.&lt;/li&gt;
  86  *
  87  * &lt;li&gt;&lt;b&gt;Day of week on or before day of month&lt;/b&gt;&lt;br&gt;
  88  * To specify a day of the week on or before an exact day of the month, set
  89  * &lt;em&gt;day-of-month&lt;/em&gt; and &lt;em&gt;day-of-week&lt;/em&gt; to a negative value. For
  90  * example, to specify the last Wednesday on or before the 21st of March, set
  91  * &lt;em&gt;month&lt;/em&gt; to {@link Calendar#MARCH MARCH}, &lt;em&gt;day-of-month&lt;/em&gt; is -21
  92  * and &lt;em&gt;day-of-week&lt;/em&gt; is {@code -}{@link Calendar#WEDNESDAY WEDNESDAY}. &lt;/li&gt;
  93  *
  94  * &lt;li&gt;&lt;b&gt;Last day-of-week of month&lt;/b&gt;&lt;br&gt;
  95  * To specify, the last day-of-week of the month, set &lt;em&gt;day-of-week&lt;/em&gt; to a
  96  * {@link Calendar#DAY_OF_WEEK DAY_OF_WEEK} value and &lt;em&gt;day-of-month&lt;/em&gt; to
  97  * -1. For example, to specify the last Sunday of October, set &lt;em&gt;month&lt;/em&gt;
  98  * to {@link Calendar#OCTOBER OCTOBER}, &lt;em&gt;day-of-week&lt;/em&gt; to {@link
  99  * Calendar#SUNDAY SUNDAY} and &lt;em&gt;day-of-month&lt;/em&gt; to -1.  &lt;/li&gt;
 100  *
 101  * &lt;/ul&gt;
 102  * The time of the day at which daylight saving time starts or ends is
 103  * specified by a millisecond value within the day. There are three kinds of
 104  * &lt;em&gt;mode&lt;/em&gt;s to specify the time: {@link #WALL_TIME}, {@link
 105  * #STANDARD_TIME} and {@link #UTC_TIME}. For example, if daylight
 106  * saving time ends
 107  * at 2:00 am in the wall clock time, it can be specified by 7200000
 108  * milliseconds in the {@link #WALL_TIME} mode. In this case, the wall clock time
 109  * for an &lt;em&gt;end-rule&lt;/em&gt; means the same thing as the daylight time.
 110  * &lt;p&gt;
 111  * The following are examples of parameters for constructing time zone objects.
 112  * &lt;pre&gt;&lt;code&gt;
 113  *      // Base GMT offset: -8:00
 114  *      // DST starts:      at 2:00am in standard time
 115  *      //                  on the first Sunday in April
 116  *      // DST ends:        at 2:00am in daylight time
 117  *      //                  on the last Sunday in October
 118  *      // Save:            1 hour
 119  *      SimpleTimeZone(-28800000,
 120  *                     &quot;America/Los_Angeles&quot;,
 121  *                     Calendar.APRIL, 1, -Calendar.SUNDAY,
 122  *                     7200000,
 123  *                     Calendar.OCTOBER, -1, Calendar.SUNDAY,
 124  *                     7200000,
 125  *                     3600000)
 126  *
 127  *      // Base GMT offset: +1:00
 128  *      // DST starts:      at 1:00am in UTC time
 129  *      //                  on the last Sunday in March
 130  *      // DST ends:        at 1:00am in UTC time
 131  *      //                  on the last Sunday in October
 132  *      // Save:            1 hour
 133  *      SimpleTimeZone(3600000,
 134  *                     &quot;Europe/Paris&quot;,
 135  *                     Calendar.MARCH, -1, Calendar.SUNDAY,
 136  *                     3600000, SimpleTimeZone.UTC_TIME,
 137  *                     Calendar.OCTOBER, -1, Calendar.SUNDAY,
 138  *                     3600000, SimpleTimeZone.UTC_TIME,
 139  *                     3600000)
 140  * &lt;/code&gt;&lt;/pre&gt;
 141  * These parameter rules are also applicable to the set rule methods, such as
 142  * {@code setStartRule}.
 143  *
 144  * @since 1.1
 145  * @see      Calendar
 146  * @see      GregorianCalendar
 147  * @see      TimeZone
 148  * @author   David Goldsmith, Mark Davis, Chen-Lieh Huang, Alan Liu
 149  */
 150 
 151 public class SimpleTimeZone extends TimeZone {
 152     /**
 153      * Constructs a SimpleTimeZone with the given base time zone offset from GMT
 154      * and time zone ID with no daylight saving time schedule.
 155      *
 156      * @param rawOffset  The base time zone offset in milliseconds to GMT.
 157      * @param ID         The time zone name that is given to this instance.
 158      */
 159     public SimpleTimeZone(int rawOffset, String ID)
 160     {
 161         this.rawOffset = rawOffset;
 162         setID (ID);
 163         dstSavings = millisPerHour; // In case user sets rules later
 164     }
 165 
 166     /**
 167      * Constructs a SimpleTimeZone with the given base time zone offset from
 168      * GMT, time zone ID, and rules for starting and ending the daylight
 169      * time.
 170      * Both {@code startTime} and {@code endTime} are specified to be
 171      * represented in the wall clock time. The amount of daylight saving is
 172      * assumed to be 3600000 milliseconds (i.e., one hour). This constructor is
 173      * equivalent to:
 174      * &lt;pre&gt;&lt;code&gt;
 175      *     SimpleTimeZone(rawOffset,
 176      *                    ID,
 177      *                    startMonth,
 178      *                    startDay,
 179      *                    startDayOfWeek,
 180      *                    startTime,
 181      *                    SimpleTimeZone.{@link #WALL_TIME},
 182      *                    endMonth,
 183      *                    endDay,
 184      *                    endDayOfWeek,
 185      *                    endTime,
 186      *                    SimpleTimeZone.{@link #WALL_TIME},
 187      *                    3600000)
 188      * &lt;/code&gt;&lt;/pre&gt;
 189      *
 190      * @param rawOffset       The given base time zone offset from GMT.
 191      * @param ID              The time zone ID which is given to this object.
 192      * @param startMonth      The daylight saving time starting month. Month is
 193      *                        a {@link Calendar#MONTH MONTH} field value (0-based. e.g., 0
 194      *                        for January).
 195      * @param startDay        The day of the month on which the daylight saving time starts.
 196      *                        See the class description for the special cases of this parameter.
 197      * @param startDayOfWeek  The daylight saving time starting day-of-week.
 198      *                        See the class description for the special cases of this parameter.
 199      * @param startTime       The daylight saving time starting time in local wall clock
 200      *                        time (in milliseconds within the day), which is local
 201      *                        standard time in this case.
 202      * @param endMonth        The daylight saving time ending month. Month is
 203      *                        a {@link Calendar#MONTH MONTH} field
 204      *                        value (0-based. e.g., 9 for October).
 205      * @param endDay          The day of the month on which the daylight saving time ends.
 206      *                        See the class description for the special cases of this parameter.
 207      * @param endDayOfWeek    The daylight saving time ending day-of-week.
 208      *                        See the class description for the special cases of this parameter.
 209      * @param endTime         The daylight saving ending time in local wall clock time,
 210      *                        (in milliseconds within the day) which is local daylight
 211      *                        time in this case.
 212      * @throws    IllegalArgumentException if the month, day, dayOfWeek, or time
 213      * parameters are out of range for the start or end rule
 214      */
 215     public SimpleTimeZone(int rawOffset, String ID,
 216                           int startMonth, int startDay, int startDayOfWeek, int startTime,
 217                           int endMonth, int endDay, int endDayOfWeek, int endTime)
 218     {
 219         this(rawOffset, ID,
 220              startMonth, startDay, startDayOfWeek, startTime, WALL_TIME,
 221              endMonth, endDay, endDayOfWeek, endTime, WALL_TIME,
 222              millisPerHour);
 223     }
 224 
 225     /**
 226      * Constructs a SimpleTimeZone with the given base time zone offset from
 227      * GMT, time zone ID, and rules for starting and ending the daylight
 228      * time.
 229      * Both {@code startTime} and {@code endTime} are assumed to be
 230      * represented in the wall clock time. This constructor is equivalent to:
 231      * &lt;pre&gt;&lt;code&gt;
 232      *     SimpleTimeZone(rawOffset,
 233      *                    ID,
 234      *                    startMonth,
 235      *                    startDay,
 236      *                    startDayOfWeek,
 237      *                    startTime,
 238      *                    SimpleTimeZone.{@link #WALL_TIME},
 239      *                    endMonth,
 240      *                    endDay,
 241      *                    endDayOfWeek,
 242      *                    endTime,
 243      *                    SimpleTimeZone.{@link #WALL_TIME},
 244      *                    dstSavings)
 245      * &lt;/code&gt;&lt;/pre&gt;
 246      *
 247      * @param rawOffset       The given base time zone offset from GMT.
 248      * @param ID              The time zone ID which is given to this object.
 249      * @param startMonth      The daylight saving time starting month. Month is
 250      *                        a {@link Calendar#MONTH MONTH} field
 251      *                        value (0-based. e.g., 0 for January).
 252      * @param startDay        The day of the month on which the daylight saving time starts.
 253      *                        See the class description for the special cases of this parameter.
 254      * @param startDayOfWeek  The daylight saving time starting day-of-week.
 255      *                        See the class description for the special cases of this parameter.
 256      * @param startTime       The daylight saving time starting time in local wall clock
 257      *                        time, which is local standard time in this case.
 258      * @param endMonth        The daylight saving time ending month. Month is
 259      *                        a {@link Calendar#MONTH MONTH} field
 260      *                        value (0-based. e.g., 9 for October).
 261      * @param endDay          The day of the month on which the daylight saving time ends.
 262      *                        See the class description for the special cases of this parameter.
 263      * @param endDayOfWeek    The daylight saving time ending day-of-week.
 264      *                        See the class description for the special cases of this parameter.
 265      * @param endTime         The daylight saving ending time in local wall clock time,
 266      *                        which is local daylight time in this case.
 267      * @param dstSavings      The amount of time in milliseconds saved during
 268      *                        daylight saving time.
 269      * @throws    IllegalArgumentException if the month, day, dayOfWeek, or time
 270      * parameters are out of range for the start or end rule
 271      * @since 1.2
 272      */
 273     public SimpleTimeZone(int rawOffset, String ID,
 274                           int startMonth, int startDay, int startDayOfWeek, int startTime,
 275                           int endMonth, int endDay, int endDayOfWeek, int endTime,
 276                           int dstSavings)
 277     {
 278         this(rawOffset, ID,
 279              startMonth, startDay, startDayOfWeek, startTime, WALL_TIME,
 280              endMonth, endDay, endDayOfWeek, endTime, WALL_TIME,
 281              dstSavings);
 282     }
 283 
 284     /**
 285      * Constructs a SimpleTimeZone with the given base time zone offset from
 286      * GMT, time zone ID, and rules for starting and ending the daylight
 287      * time.
 288      * This constructor takes the full set of the start and end rules
 289      * parameters, including modes of {@code startTime} and
 290      * {@code endTime}. The mode specifies either {@link #WALL_TIME wall
 291      * time} or {@link #STANDARD_TIME standard time} or {@link #UTC_TIME UTC
 292      * time}.
 293      *
 294      * @param rawOffset       The given base time zone offset from GMT.
 295      * @param ID              The time zone ID which is given to this object.
 296      * @param startMonth      The daylight saving time starting month. Month is
 297      *                        a {@link Calendar#MONTH MONTH} field
 298      *                        value (0-based. e.g., 0 for January).
 299      * @param startDay        The day of the month on which the daylight saving time starts.
 300      *                        See the class description for the special cases of this parameter.
 301      * @param startDayOfWeek  The daylight saving time starting day-of-week.
 302      *                        See the class description for the special cases of this parameter.
 303      * @param startTime       The daylight saving time starting time in the time mode
 304      *                        specified by {@code startTimeMode}.
 305      * @param startTimeMode   The mode of the start time specified by startTime.
 306      * @param endMonth        The daylight saving time ending month. Month is
 307      *                        a {@link Calendar#MONTH MONTH} field
 308      *                        value (0-based. e.g., 9 for October).
 309      * @param endDay          The day of the month on which the daylight saving time ends.
 310      *                        See the class description for the special cases of this parameter.
 311      * @param endDayOfWeek    The daylight saving time ending day-of-week.
 312      *                        See the class description for the special cases of this parameter.
 313      * @param endTime         The daylight saving ending time in time mode
 314      *                        specified by {@code endTimeMode}.
 315      * @param endTimeMode     The mode of the end time specified by endTime
 316      * @param dstSavings      The amount of time in milliseconds saved during
 317      *                        daylight saving time.
 318      *
 319      * @throws    IllegalArgumentException if the month, day, dayOfWeek, time more, or
 320      * time parameters are out of range for the start or end rule, or if a time mode
 321      * value is invalid.
 322      *
 323      * @see #WALL_TIME
 324      * @see #STANDARD_TIME
 325      * @see #UTC_TIME
 326      *
 327      * @since 1.4
 328      */
 329     public SimpleTimeZone(int rawOffset, String ID,
 330                           int startMonth, int startDay, int startDayOfWeek,
 331                           int startTime, int startTimeMode,
 332                           int endMonth, int endDay, int endDayOfWeek,
 333                           int endTime, int endTimeMode,
 334                           int dstSavings) {
 335 
 336         setID(ID);
 337         this.rawOffset      = rawOffset;
 338         this.startMonth     = startMonth;
 339         this.startDay       = startDay;
 340         this.startDayOfWeek = startDayOfWeek;
 341         this.startTime      = startTime;
 342         this.startTimeMode  = startTimeMode;
 343         this.endMonth       = endMonth;
 344         this.endDay         = endDay;
 345         this.endDayOfWeek   = endDayOfWeek;
 346         this.endTime        = endTime;
 347         this.endTimeMode    = endTimeMode;
 348         this.dstSavings     = dstSavings;
 349 
 350         // this.useDaylight is set by decodeRules
 351         decodeRules();
 352         if (dstSavings &lt;= 0) {
 353             throw new IllegalArgumentException(&quot;Illegal daylight saving value: &quot; + dstSavings);
 354         }
 355     }
 356 
 357     /**
 358      * Sets the daylight saving time starting year.
 359      *
 360      * @param year  The daylight saving starting year.
 361      */
 362     public void setStartYear(int year)
 363     {
 364         startYear = year;
 365         invalidateCache();
 366     }
 367 
 368     /**
 369      * Sets the daylight saving time start rule. For example, if daylight saving
 370      * time starts on the first Sunday in April at 2 am in local wall clock
 371      * time, you can set the start rule by calling:
 372      * &lt;pre&gt;{@code setStartRule(Calendar.APRIL, 1, Calendar.SUNDAY, 2*60*60*1000);}&lt;/pre&gt;
 373      *
 374      * @param startMonth      The daylight saving time starting month. Month is
 375      *                        a {@link Calendar#MONTH MONTH} field
 376      *                        value (0-based. e.g., 0 for January).
 377      * @param startDay        The day of the month on which the daylight saving time starts.
 378      *                        See the class description for the special cases of this parameter.
 379      * @param startDayOfWeek  The daylight saving time starting day-of-week.
 380      *                        See the class description for the special cases of this parameter.
 381      * @param startTime       The daylight saving time starting time in local wall clock
 382      *                        time, which is local standard time in this case.
 383      * @throws    IllegalArgumentException if the {@code startMonth}, {@code startDay},
 384      * {@code startDayOfWeek}, or {@code startTime} parameters are out of range
 385      */
 386     public void setStartRule(int startMonth, int startDay, int startDayOfWeek, int startTime)
 387     {
 388         this.startMonth = startMonth;
 389         this.startDay = startDay;
 390         this.startDayOfWeek = startDayOfWeek;
 391         this.startTime = startTime;
 392         startTimeMode = WALL_TIME;
 393         decodeStartRule();
 394         invalidateCache();
 395     }
 396 
 397     /**
 398      * Sets the daylight saving time start rule to a fixed date within a month.
 399      * This method is equivalent to:
 400      * &lt;pre&gt;{@code setStartRule(startMonth, startDay, 0, startTime)}&lt;/pre&gt;
 401      *
 402      * @param startMonth      The daylight saving time starting month. Month is
 403      *                        a {@link Calendar#MONTH MONTH} field
 404      *                        value (0-based. e.g., 0 for January).
 405      * @param startDay        The day of the month on which the daylight saving time starts.
 406      * @param startTime       The daylight saving time starting time in local wall clock
 407      *                        time, which is local standard time in this case.
 408      *                        See the class description for the special cases of this parameter.
 409      * @throws    IllegalArgumentException if the {@code startMonth},
 410      * {@code startDayOfMonth}, or {@code startTime} parameters are out of range
 411      * @since 1.2
 412      */
 413     public void setStartRule(int startMonth, int startDay, int startTime) {
 414         setStartRule(startMonth, startDay, 0, startTime);
 415     }
 416 
 417     /**
 418      * Sets the daylight saving time start rule to a weekday before or after the given date within
 419      * a month, e.g., the first Monday on or after the 8th.
 420      *
 421      * @param startMonth      The daylight saving time starting month. Month is
 422      *                        a {@link Calendar#MONTH MONTH} field
 423      *                        value (0-based. e.g., 0 for January).
 424      * @param startDay        The day of the month on which the daylight saving time starts.
 425      * @param startDayOfWeek  The daylight saving time starting day-of-week.
 426      * @param startTime       The daylight saving time starting time in local wall clock
 427      *                        time, which is local standard time in this case.
 428      * @param after           If true, this rule selects the first {@code dayOfWeek} on or
 429      *                        &lt;em&gt;after&lt;/em&gt; {@code dayOfMonth}.  If false, this rule
 430      *                        selects the last {@code dayOfWeek} on or &lt;em&gt;before&lt;/em&gt;
 431      *                        {@code dayOfMonth}.
 432      * @throws    IllegalArgumentException if the {@code startMonth}, {@code startDay},
 433      * {@code startDayOfWeek}, or {@code startTime} parameters are out of range
 434      * @since 1.2
 435      */
 436     public void setStartRule(int startMonth, int startDay, int startDayOfWeek,
 437                              int startTime, boolean after)
 438     {
 439         // TODO: this method doesn&#39;t check the initial values of dayOfMonth or dayOfWeek.
 440         if (after) {
 441             setStartRule(startMonth, startDay, -startDayOfWeek, startTime);
 442         } else {
 443             setStartRule(startMonth, -startDay, -startDayOfWeek, startTime);
 444         }
 445     }
 446 
 447     /**
 448      * Sets the daylight saving time end rule. For example, if daylight saving time
 449      * ends on the last Sunday in October at 2 am in wall clock time,
 450      * you can set the end rule by calling:
 451      * {@code setEndRule(Calendar.OCTOBER, -1, Calendar.SUNDAY, 2*60*60*1000);}
 452      *
 453      * @param endMonth        The daylight saving time ending month. Month is
 454      *                        a {@link Calendar#MONTH MONTH} field
 455      *                        value (0-based. e.g., 9 for October).
 456      * @param endDay          The day of the month on which the daylight saving time ends.
 457      *                        See the class description for the special cases of this parameter.
 458      * @param endDayOfWeek    The daylight saving time ending day-of-week.
 459      *                        See the class description for the special cases of this parameter.
 460      * @param endTime         The daylight saving ending time in local wall clock time,
 461      *                        (in milliseconds within the day) which is local daylight
 462      *                        time in this case.
 463      * @throws    IllegalArgumentException if the {@code endMonth}, {@code endDay},
 464      * {@code endDayOfWeek}, or {@code endTime} parameters are out of range
 465      */
 466     public void setEndRule(int endMonth, int endDay, int endDayOfWeek,
 467                            int endTime)
 468     {
 469         this.endMonth = endMonth;
 470         this.endDay = endDay;
 471         this.endDayOfWeek = endDayOfWeek;
 472         this.endTime = endTime;
 473         this.endTimeMode = WALL_TIME;
 474         decodeEndRule();
 475         invalidateCache();
 476     }
 477 
 478     /**
 479      * Sets the daylight saving time end rule to a fixed date within a month.
 480      * This method is equivalent to:
 481      * &lt;pre&gt;{@code setEndRule(endMonth, endDay, 0, endTime)}&lt;/pre&gt;
 482      *
 483      * @param endMonth        The daylight saving time ending month. Month is
 484      *                        a {@link Calendar#MONTH MONTH} field
 485      *                        value (0-based. e.g., 9 for October).
 486      * @param endDay          The day of the month on which the daylight saving time ends.
 487      * @param endTime         The daylight saving ending time in local wall clock time,
 488      *                        (in milliseconds within the day) which is local daylight
 489      *                        time in this case.
 490      * @throws    IllegalArgumentException the {@code endMonth}, {@code endDay},
 491      * or {@code endTime} parameters are out of range
 492      * @since 1.2
 493      */
 494     public void setEndRule(int endMonth, int endDay, int endTime)
 495     {
 496         setEndRule(endMonth, endDay, 0, endTime);
 497     }
 498 
 499     /**
 500      * Sets the daylight saving time end rule to a weekday before or after the given date within
 501      * a month, e.g., the first Monday on or after the 8th.
 502      *
 503      * @param endMonth        The daylight saving time ending month. Month is
 504      *                        a {@link Calendar#MONTH MONTH} field
 505      *                        value (0-based. e.g., 9 for October).
 506      * @param endDay          The day of the month on which the daylight saving time ends.
 507      * @param endDayOfWeek    The daylight saving time ending day-of-week.
 508      * @param endTime         The daylight saving ending time in local wall clock time,
 509      *                        (in milliseconds within the day) which is local daylight
 510      *                        time in this case.
 511      * @param after           If true, this rule selects the first {@code endDayOfWeek} on
 512      *                        or &lt;em&gt;after&lt;/em&gt; {@code endDay}.  If false, this rule
 513      *                        selects the last {@code endDayOfWeek} on or before
 514      *                        {@code endDay} of the month.
 515      * @throws    IllegalArgumentException the {@code endMonth}, {@code endDay},
 516      * {@code endDayOfWeek}, or {@code endTime} parameters are out of range
 517      * @since 1.2
 518      */
 519     public void setEndRule(int endMonth, int endDay, int endDayOfWeek, int endTime, boolean after)
 520     {
 521         if (after) {
 522             setEndRule(endMonth, endDay, -endDayOfWeek, endTime);
 523         } else {
 524             setEndRule(endMonth, -endDay, -endDayOfWeek, endTime);
 525         }
 526     }
 527 
 528     /**
 529      * Returns the offset of this time zone from UTC at the given
 530      * time. If daylight saving time is in effect at the given time,
 531      * the offset value is adjusted with the amount of daylight
 532      * saving.
 533      *
 534      * @param date the time at which the time zone offset is found
 535      * @return the amount of time in milliseconds to add to UTC to get
 536      * local time.
 537      * @since 1.4
 538      */
 539     public int getOffset(long date) {
 540         return getOffsets(date, null);
 541     }
 542 
 543     /**
 544      * @see TimeZone#getOffsets
 545      */
 546     int getOffsets(long date, int[] offsets) {
 547         int offset = rawOffset;
 548 
 549       computeOffset:
 550         if (useDaylight) {
 551             Cache cache = this.cache;
 552             if (cache != null) {
 553                 if (date &gt;= cache.start &amp;&amp; date &lt; cache.end) {
 554                     offset += dstSavings;
 555                     break computeOffset;
 556                 }
 557             }
 558             BaseCalendar cal = date &gt;= GregorianCalendar.DEFAULT_GREGORIAN_CUTOVER ?
 559                 gcal : (BaseCalendar) CalendarSystem.forName(&quot;julian&quot;);
 560             BaseCalendar.Date cdate = (BaseCalendar.Date) cal.newCalendarDate(TimeZone.NO_TIMEZONE);
 561             // Get the year in local time
 562             cal.getCalendarDate(date + rawOffset, cdate);
 563             int year = cdate.getNormalizedYear();
 564             if (year &gt;= startYear) {
 565                 // Clear time elements for the transition calculations
 566                 cdate.setTimeOfDay(0, 0, 0, 0);
 567                 offset = getOffset(cal, cdate, year, date);
 568             }
 569         }
 570 
 571         if (offsets != null) {
 572             offsets[0] = rawOffset;
 573             offsets[1] = offset - rawOffset;
 574         }
 575         return offset;
 576     }
 577 
 578    /**
 579      * Returns the difference in milliseconds between local time and
 580      * UTC, taking into account both the raw offset and the effect of
 581      * daylight saving, for the specified date and time.  This method
 582      * assumes that the start and end month are distinct.  It also
 583      * uses a default {@link GregorianCalendar} object as its
 584      * underlying calendar, such as for determining leap years.  Do
 585      * not use the result of this method with a calendar other than a
 586      * default {@code GregorianCalendar}.
 587      *
 588      * &lt;p&gt;&lt;em&gt;Note:  In general, clients should use
 589      * {@code Calendar.get(ZONE_OFFSET) + Calendar.get(DST_OFFSET)}
 590      * instead of calling this method.&lt;/em&gt;
 591      *
 592      * @param era       The era of the given date.
 593      * @param year      The year in the given date.
 594      * @param month     The month in the given date. Month is 0-based. e.g.,
 595      *                  0 for January.
 596      * @param day       The day-in-month of the given date.
 597      * @param dayOfWeek The day-of-week of the given date.
 598      * @param millis    The milliseconds in day in &lt;em&gt;standard&lt;/em&gt; local time.
 599      * @return          The milliseconds to add to UTC to get local time.
 600      * @throws          IllegalArgumentException the {@code era},
 601      *                  {@code month}, {@code day}, {@code dayOfWeek},
 602      *                  or {@code millis} parameters are out of range
 603      */
 604     public int getOffset(int era, int year, int month, int day, int dayOfWeek,
 605                          int millis)
 606     {
 607         if (era != GregorianCalendar.AD &amp;&amp; era != GregorianCalendar.BC) {
 608             throw new IllegalArgumentException(&quot;Illegal era &quot; + era);
 609         }
 610 
 611         int y = year;
 612         if (era == GregorianCalendar.BC) {
 613             // adjust y with the GregorianCalendar-style year numbering.
 614             y = 1 - y;
 615         }
 616 
 617         // If the year isn&#39;t representable with the 64-bit long
 618         // integer in milliseconds, convert the year to an
 619         // equivalent year. This is required to pass some JCK test cases
 620         // which are actually useless though because the specified years
 621         // can&#39;t be supported by the Java time system.
 622         if (y &gt;= 292278994) {
 623             y = 2800 + y % 2800;
 624         } else if (y &lt;= -292269054) {
 625             // y %= 28 also produces an equivalent year, but positive
 626             // year numbers would be convenient to use the UNIX cal
 627             // command.
 628             y = (int) CalendarUtils.mod((long) y, 28);
 629         }
 630 
 631         // convert year to its 1-based month value
 632         int m = month + 1;
 633 
 634         // First, calculate time as a Gregorian date.
 635         BaseCalendar cal = gcal;
 636         BaseCalendar.Date cdate = (BaseCalendar.Date) cal.newCalendarDate(TimeZone.NO_TIMEZONE);
 637         cdate.setDate(y, m, day);
 638         long time = cal.getTime(cdate); // normalize cdate
 639         time += millis - rawOffset; // UTC time
 640 
 641         // If the time value represents a time before the default
 642         // Gregorian cutover, recalculate time using the Julian
 643         // calendar system. For the Julian calendar system, the
 644         // normalized year numbering is ..., -2 (BCE 2), -1 (BCE 1),
 645         // 1, 2 ... which is different from the GregorianCalendar
 646         // style year numbering (..., -1, 0 (BCE 1), 1, 2, ...).
 647         if (time &lt; GregorianCalendar.DEFAULT_GREGORIAN_CUTOVER) {
 648             cal = (BaseCalendar) CalendarSystem.forName(&quot;julian&quot;);
 649             cdate = (BaseCalendar.Date) cal.newCalendarDate(TimeZone.NO_TIMEZONE);
 650             cdate.setNormalizedDate(y, m, day);
 651             time = cal.getTime(cdate) + millis - rawOffset;
 652         }
 653 
 654         if ((cdate.getNormalizedYear() != y)
 655             || (cdate.getMonth() != m)
 656             || (cdate.getDayOfMonth() != day)
 657             // The validation should be cdate.getDayOfWeek() ==
 658             // dayOfWeek. However, we don&#39;t check dayOfWeek for
 659             // compatibility.
 660             || (dayOfWeek &lt; Calendar.SUNDAY || dayOfWeek &gt; Calendar.SATURDAY)
 661             || (millis &lt; 0 || millis &gt;= (24*60*60*1000))) {
 662             throw new IllegalArgumentException();
 663         }
 664 
 665         if (!useDaylight || year &lt; startYear || era != GregorianCalendar.CE) {
 666             return rawOffset;
 667         }
 668 
 669         return getOffset(cal, cdate, y, time);
 670     }
 671 
 672     private int getOffset(BaseCalendar cal, BaseCalendar.Date cdate, int year, long time) {
 673         Cache cache = this.cache;
 674         if (cache != null) {
 675             if (time &gt;= cache.start &amp;&amp; time &lt; cache.end) {
 676                 return rawOffset + dstSavings;
 677             }
 678             if (year == cache.year) {
 679                 return rawOffset;
 680             }
 681         }
 682 
 683         long start = getStart(cal, cdate, year);
 684         long end = getEnd(cal, cdate, year);
 685         int offset = rawOffset;
 686         if (start &lt;= end) {
 687             if (time &gt;= start &amp;&amp; time &lt; end) {
 688                 offset += dstSavings;
 689             }
 690             this.cache = new Cache(year, start, end);
 691         } else {
 692             if (time &lt; end) {
 693                 // TODO: support Gregorian cutover. The previous year
 694                 // may be in the other calendar system.
 695                 start = getStart(cal, cdate, year - 1);
 696                 if (time &gt;= start) {
 697                     offset += dstSavings;
 698                 }
 699             } else if (time &gt;= start) {
 700                 // TODO: support Gregorian cutover. The next year
 701                 // may be in the other calendar system.
 702                 end = getEnd(cal, cdate, year + 1);
 703                 if (time &lt; end) {
 704                     offset += dstSavings;
 705                 }
 706             }
 707             if (start &lt;= end) {
 708                 this.cache = new Cache((long) startYear - 1, start, end);
 709             }
 710         }
 711         return offset;
 712     }
 713 
 714     private long getStart(BaseCalendar cal, BaseCalendar.Date cdate, int year) {
 715         int time = startTime;
 716         if (startTimeMode != UTC_TIME) {
 717             time -= rawOffset;
 718         }
 719         return getTransition(cal, cdate, startMode, year, startMonth, startDay,
 720                              startDayOfWeek, time);
 721     }
 722 
 723     private long getEnd(BaseCalendar cal, BaseCalendar.Date cdate, int year) {
 724         int time = endTime;
 725         if (endTimeMode != UTC_TIME) {
 726             time -= rawOffset;
 727         }
 728         if (endTimeMode == WALL_TIME) {
 729             time -= dstSavings;
 730         }
 731         return getTransition(cal, cdate, endMode, year, endMonth, endDay,
 732                                         endDayOfWeek, time);
 733     }
 734 
 735     private long getTransition(BaseCalendar cal, BaseCalendar.Date cdate,
 736                                int mode, int year, int month, int dayOfMonth,
 737                                int dayOfWeek, int timeOfDay) {
 738         cdate.setNormalizedYear(year);
 739         cdate.setMonth(month + 1);
 740         switch (mode) {
 741         case DOM_MODE:
 742             cdate.setDayOfMonth(dayOfMonth);
 743             break;
 744 
 745         case DOW_IN_MONTH_MODE:
 746             cdate.setDayOfMonth(1);
 747             if (dayOfMonth &lt; 0) {
 748                 cdate.setDayOfMonth(cal.getMonthLength(cdate));
 749             }
 750             cdate = (BaseCalendar.Date) cal.getNthDayOfWeek(dayOfMonth, dayOfWeek, cdate);
 751             break;
 752 
 753         case DOW_GE_DOM_MODE:
 754             cdate.setDayOfMonth(dayOfMonth);
 755             cdate = (BaseCalendar.Date) cal.getNthDayOfWeek(1, dayOfWeek, cdate);
 756             break;
 757 
 758         case DOW_LE_DOM_MODE:
 759             cdate.setDayOfMonth(dayOfMonth);
 760             cdate = (BaseCalendar.Date) cal.getNthDayOfWeek(-1, dayOfWeek, cdate);
 761             break;
 762         }
 763         return cal.getTime(cdate) + timeOfDay;
 764     }
 765 
 766     /**
 767      * Gets the GMT offset for this time zone.
 768      * @return the GMT offset value in milliseconds
 769      * @see #setRawOffset
 770      */
 771     public int getRawOffset()
 772     {
 773         // The given date will be taken into account while
 774         // we have the historical time zone data in place.
 775         return rawOffset;
 776     }
 777 
 778     /**
 779      * Sets the base time zone offset to GMT.
 780      * This is the offset to add to UTC to get local time.
 781      * @see #getRawOffset
 782      */
 783     public void setRawOffset(int offsetMillis)
 784     {
 785         this.rawOffset = offsetMillis;
 786     }
 787 
 788     /**
 789      * Sets the amount of time in milliseconds that the clock is advanced
 790      * during daylight saving time.
 791      * @param millisSavedDuringDST the number of milliseconds the time is
 792      * advanced with respect to standard time when the daylight saving time rules
 793      * are in effect. A positive number, typically one hour (3600000).
 794      * @see #getDSTSavings
 795      * @since 1.2
 796      */
 797     public void setDSTSavings(int millisSavedDuringDST) {
 798         if (millisSavedDuringDST &lt;= 0) {
 799             throw new IllegalArgumentException(&quot;Illegal daylight saving value: &quot;
 800                                                + millisSavedDuringDST);
 801         }
 802         dstSavings = millisSavedDuringDST;
 803     }
 804 
 805     /**
 806      * Returns the amount of time in milliseconds that the clock is
 807      * advanced during daylight saving time.
 808      *
 809      * @return the number of milliseconds the time is advanced with
 810      * respect to standard time when the daylight saving rules are in
 811      * effect, or 0 (zero) if this time zone doesn&#39;t observe daylight
 812      * saving time.
 813      *
 814      * @see #setDSTSavings
 815      * @since 1.2
 816      */
 817     public int getDSTSavings() {
 818         return useDaylight ? dstSavings : 0;
 819     }
 820 
 821     /**
 822      * Queries if this time zone uses daylight saving time.
 823      * @return true if this time zone uses daylight saving time;
 824      * false otherwise.
 825      */
 826     public boolean useDaylightTime()
 827     {
 828         return useDaylight;
 829     }
 830 
 831     /**
 832      * Returns {@code true} if this {@code SimpleTimeZone} observes
 833      * Daylight Saving Time. This method is equivalent to {@link
 834      * #useDaylightTime()}.
 835      *
 836      * @return {@code true} if this {@code SimpleTimeZone} observes
 837      * Daylight Saving Time; {@code false} otherwise.
 838      * @since 1.7
 839      */
 840     @Override
 841     public boolean observesDaylightTime() {
 842         return useDaylightTime();
 843     }
 844 
 845     /**
 846      * Queries if the given date is in daylight saving time.
 847      * @return true if daylight saving time is in effective at the
 848      * given date; false otherwise.
 849      */
 850     public boolean inDaylightTime(Date date)
 851     {
 852         return (getOffset(date.getTime()) != rawOffset);
 853     }
 854 
 855     /**
 856      * Returns a clone of this {@code SimpleTimeZone} instance.
 857      * @return a clone of this instance.
 858      */
 859     public Object clone()
 860     {
 861         return super.clone();
 862     }
 863 
 864     /**
 865      * Generates the hash code for the SimpleDateFormat object.
 866      * @return the hash code for this object
 867      */
 868     public int hashCode()
 869     {
 870         return startMonth ^ startDay ^ startDayOfWeek ^ startTime ^
 871             endMonth ^ endDay ^ endDayOfWeek ^ endTime ^ rawOffset;
 872     }
 873 
 874     /**
 875      * Compares the equality of two {@code SimpleTimeZone} objects.
 876      *
 877      * @param obj  The {@code SimpleTimeZone} object to be compared with.
 878      * @return     True if the given {@code obj} is the same as this
 879      *             {@code SimpleTimeZone} object; false otherwise.
 880      */
 881     public boolean equals(Object obj)
 882     {
 883         if (this == obj) {
 884             return true;
 885         }
 886         if (!(obj instanceof SimpleTimeZone)) {
 887             return false;
 888         }
 889 
 890         SimpleTimeZone that = (SimpleTimeZone) obj;
 891 
 892         return getID().equals(that.getID()) &amp;&amp;
 893             hasSameRules(that);
 894     }
 895 
 896     /**
 897      * Returns {@code true} if this zone has the same rules and offset as another zone.
 898      * @param other the TimeZone object to be compared with
 899      * @return {@code true} if the given zone is a SimpleTimeZone and has the
 900      * same rules and offset as this one
 901      * @since 1.2
 902      */
 903     public boolean hasSameRules(TimeZone other) {
 904         if (this == other) {
 905             return true;
 906         }
 907         if (!(other instanceof SimpleTimeZone)) {
 908             return false;
 909         }
 910         SimpleTimeZone that = (SimpleTimeZone) other;
 911         return rawOffset == that.rawOffset &amp;&amp;
 912             useDaylight == that.useDaylight &amp;&amp;
 913             (!useDaylight
 914              // Only check rules if using DST
 915              || (dstSavings == that.dstSavings &amp;&amp;
 916                  startMode == that.startMode &amp;&amp;
 917                  startMonth == that.startMonth &amp;&amp;
 918                  startDay == that.startDay &amp;&amp;
 919                  startDayOfWeek == that.startDayOfWeek &amp;&amp;
 920                  startTime == that.startTime &amp;&amp;
 921                  startTimeMode == that.startTimeMode &amp;&amp;
 922                  endMode == that.endMode &amp;&amp;
 923                  endMonth == that.endMonth &amp;&amp;
 924                  endDay == that.endDay &amp;&amp;
 925                  endDayOfWeek == that.endDayOfWeek &amp;&amp;
 926                  endTime == that.endTime &amp;&amp;
 927                  endTimeMode == that.endTimeMode &amp;&amp;
 928                  startYear == that.startYear));
 929     }
 930 
 931     /**
 932      * Returns a string representation of this time zone.
 933      * @return a string representation of this time zone.
 934      */
 935     public String toString() {
 936         return getClass().getName() +
 937             &quot;[id=&quot; + getID() +
 938             &quot;,offset=&quot; + rawOffset +
 939             &quot;,dstSavings=&quot; + dstSavings +
 940             &quot;,useDaylight=&quot; + useDaylight +
 941             &quot;,startYear=&quot; + startYear +
 942             &quot;,startMode=&quot; + startMode +
 943             &quot;,startMonth=&quot; + startMonth +
 944             &quot;,startDay=&quot; + startDay +
 945             &quot;,startDayOfWeek=&quot; + startDayOfWeek +
 946             &quot;,startTime=&quot; + startTime +
 947             &quot;,startTimeMode=&quot; + startTimeMode +
 948             &quot;,endMode=&quot; + endMode +
 949             &quot;,endMonth=&quot; + endMonth +
 950             &quot;,endDay=&quot; + endDay +
 951             &quot;,endDayOfWeek=&quot; + endDayOfWeek +
 952             &quot;,endTime=&quot; + endTime +
 953             &quot;,endTimeMode=&quot; + endTimeMode + &#39;]&#39;;
 954     }
 955 
 956     // =======================privates===============================
 957 
 958     /**
 959      * The month in which daylight saving time starts.  This value must be
 960      * between {@code Calendar.JANUARY} and
 961      * {@code Calendar.DECEMBER} inclusive.  This value must not equal
 962      * {@code endMonth}.
 963      * &lt;p&gt;If {@code useDaylight} is false, this value is ignored.
 964      * @serial
 965      */
 966     private int startMonth;
 967 
 968     /**
 969      * This field has two possible interpretations:
 970      * &lt;dl&gt;
 971      * &lt;dt&gt;{@code startMode == DOW_IN_MONTH}&lt;/dt&gt;
 972      * &lt;dd&gt;
 973      * {@code startDay} indicates the day of the month of
 974      * {@code startMonth} on which daylight
 975      * saving time starts, from 1 to 28, 30, or 31, depending on the
 976      * {@code startMonth}.
 977      * &lt;/dd&gt;
 978      * &lt;dt&gt;{@code startMode != DOW_IN_MONTH}&lt;/dt&gt;
 979      * &lt;dd&gt;
 980      * {@code startDay} indicates which {@code startDayOfWeek} in the
 981      * month {@code startMonth} daylight
 982      * saving time starts on.  For example, a value of +1 and a
 983      * {@code startDayOfWeek} of {@code Calendar.SUNDAY} indicates the
 984      * first Sunday of {@code startMonth}.  Likewise, +2 would indicate the
 985      * second Sunday, and -1 the last Sunday.  A value of 0 is illegal.
 986      * &lt;/dd&gt;
 987      * &lt;/dl&gt;
 988      * &lt;p&gt;If {@code useDaylight} is false, this value is ignored.
 989      * @serial
 990      */
 991     private int startDay;
 992 
 993     /**
 994      * The day of the week on which daylight saving time starts.  This value
 995      * must be between {@code Calendar.SUNDAY} and
 996      * {@code Calendar.SATURDAY} inclusive.
 997      * &lt;p&gt;If {@code useDaylight} is false or
 998      * {@code startMode == DAY_OF_MONTH}, this value is ignored.
 999      * @serial
1000      */
1001     private int startDayOfWeek;
1002 
1003     /**
1004      * The time in milliseconds after midnight at which daylight saving
1005      * time starts.  This value is expressed as wall time, standard time,
1006      * or UTC time, depending on the setting of {@code startTimeMode}.
1007      * &lt;p&gt;If {@code useDaylight} is false, this value is ignored.
1008      * @serial
1009      */
1010     private int startTime;
1011 
1012     /**
1013      * The format of startTime, either WALL_TIME, STANDARD_TIME, or UTC_TIME.
1014      * @serial
1015      * @since 1.3
1016      */
1017     private int startTimeMode;
1018 
1019     /**
1020      * The month in which daylight saving time ends.  This value must be
1021      * between {@code Calendar.JANUARY} and
1022      * {@code Calendar.UNDECIMBER}.  This value must not equal
1023      * {@code startMonth}.
1024      * &lt;p&gt;If {@code useDaylight} is false, this value is ignored.
1025      * @serial
1026      */
1027     private int endMonth;
1028 
1029     /**
1030      * This field has two possible interpretations:
1031      * &lt;dl&gt;
1032      * &lt;dt&gt;{@code endMode == DOW_IN_MONTH}&lt;/dt&gt;
1033      * &lt;dd&gt;
1034      * {@code endDay} indicates the day of the month of
1035      * {@code endMonth} on which daylight
1036      * saving time ends, from 1 to 28, 30, or 31, depending on the
1037      * {@code endMonth}.
1038      * &lt;/dd&gt;
1039      * &lt;dt&gt;{@code endMode != DOW_IN_MONTH}&lt;/dt&gt;
1040      * &lt;dd&gt;
1041      * {@code endDay} indicates which {@code endDayOfWeek} in th
1042      * month {@code endMonth} daylight
1043      * saving time ends on.  For example, a value of +1 and a
1044      * {@code endDayOfWeek} of {@code Calendar.SUNDAY} indicates the
1045      * first Sunday of {@code endMonth}.  Likewise, +2 would indicate the
1046      * second Sunday, and -1 the last Sunday.  A value of 0 is illegal.
1047      * &lt;/dd&gt;
1048      * &lt;/dl&gt;
1049      * &lt;p&gt;If {@code useDaylight} is false, this value is ignored.
1050      * @serial
1051      */
1052     private int endDay;
1053 
1054     /**
1055      * The day of the week on which daylight saving time ends.  This value
1056      * must be between {@code Calendar.SUNDAY} and
1057      * {@code Calendar.SATURDAY} inclusive.
1058      * &lt;p&gt;If {@code useDaylight} is false or
1059      * {@code endMode == DAY_OF_MONTH}, this value is ignored.
1060      * @serial
1061      */
1062     private int endDayOfWeek;
1063 
1064     /**
1065      * The time in milliseconds after midnight at which daylight saving
1066      * time ends.  This value is expressed as wall time, standard time,
1067      * or UTC time, depending on the setting of {@code endTimeMode}.
1068      * &lt;p&gt;If {@code useDaylight} is false, this value is ignored.
1069      * @serial
1070      */
1071     private int endTime;
1072 
1073     /**
1074      * The format of endTime, either {@code WALL_TIME},
1075      * {@code STANDARD_TIME}, or {@code UTC_TIME}.
1076      * @serial
1077      * @since 1.3
1078      */
1079     private int endTimeMode;
1080 
1081     /**
1082      * The year in which daylight saving time is first observed.  This is an {@link GregorianCalendar#AD AD}
1083      * value.  If this value is less than 1 then daylight saving time is observed
1084      * for all {@code AD} years.
1085      * &lt;p&gt;If {@code useDaylight} is false, this value is ignored.
1086      * @serial
1087      */
1088     private int startYear;
1089 
1090     /**
1091      * The offset in milliseconds between this zone and GMT.  Negative offsets
1092      * are to the west of Greenwich.  To obtain local &lt;em&gt;standard&lt;/em&gt; time,
1093      * add the offset to GMT time.  To obtain local wall time it may also be
1094      * necessary to add {@code dstSavings}.
1095      * @serial
1096      */
1097     private int rawOffset;
1098 
1099     /**
1100      * A boolean value which is true if and only if this zone uses daylight
1101      * saving time.  If this value is false, several other fields are ignored.
1102      * @serial
1103      */
1104     private boolean useDaylight=false; // indicate if this time zone uses DST
1105 
1106     private static final int millisPerHour = 60*60*1000;
1107     private static final int millisPerDay  = 24*millisPerHour;
1108 
1109     /**
1110      * This field was serialized in JDK 1.1, so we have to keep it that way
1111      * to maintain serialization compatibility. However, there&#39;s no need to
1112      * recreate the array each time we create a new time zone.
1113      * @serial An array of bytes containing the values {31, 28, 31, 30, 31, 30,
1114      * 31, 31, 30, 31, 30, 31}.  This is ignored as of the Java 2 platform v1.2, however, it must
1115      * be streamed out for compatibility with JDK 1.1.
1116      */
1117     private final byte monthLength[] = staticMonthLength;
1118     private static final byte staticMonthLength[] = {31,28,31,30,31,30,31,31,30,31,30,31};
1119     private static final byte staticLeapMonthLength[] = {31,29,31,30,31,30,31,31,30,31,30,31};
1120 
1121     /**
1122      * Variables specifying the mode of the start rule.  Takes the following
1123      * values:
1124      * &lt;dl&gt;
1125      * &lt;dt&gt;{@code DOM_MODE}&lt;/dt&gt;
1126      * &lt;dd&gt;
1127      * Exact day of week; e.g., March 1.
1128      * &lt;/dd&gt;
1129      * &lt;dt&gt;{@code DOW_IN_MONTH_MODE}&lt;/dt&gt;
1130      * &lt;dd&gt;
1131      * Day of week in month; e.g., last Sunday in March.
1132      * &lt;/dd&gt;
1133      * &lt;dt&gt;{@code DOW_GE_DOM_MODE}&lt;/dt&gt;
1134      * &lt;dd&gt;
1135      * Day of week after day of month; e.g., Sunday on or after March 15.
1136      * &lt;/dd&gt;
1137      * &lt;dt&gt;{@code DOW_LE_DOM_MODE}&lt;/dt&gt;
1138      * &lt;dd&gt;
1139      * Day of week before day of month; e.g., Sunday on or before March 15.
1140      * &lt;/dd&gt;
1141      * &lt;/dl&gt;
1142      * The setting of this field affects the interpretation of the
1143      * {@code startDay} field.
1144      * &lt;p&gt;If {@code useDaylight} is false, this value is ignored.
1145      * @serial
1146      * @since 1.1.4
1147      */
1148     private int startMode;
1149 
1150     /**
1151      * Variables specifying the mode of the end rule.  Takes the following
1152      * values:
1153      * &lt;dl&gt;
1154      * &lt;dt&gt;{@code DOM_MODE}&lt;/dt&gt;
1155      * &lt;dd&gt;
1156      * Exact day of week; e.g., March 1.
1157      * &lt;/dd&gt;
1158      * &lt;dt&gt;{@code DOW_IN_MONTH_MODE}&lt;/dt&gt;
1159      * &lt;dd&gt;
1160      * Day of week in month; e.g., last Sunday in March.
1161      * &lt;/dd&gt;
1162      * &lt;dt&gt;{@code DOW_GE_DOM_MODE}&lt;/dt&gt;
1163      * &lt;dd&gt;
1164      * Day of week after day of month; e.g., Sunday on or after March 15.
1165      * &lt;/dd&gt;
1166      * &lt;dt&gt;{@code DOW_LE_DOM_MODE}&lt;/dt&gt;
1167      * &lt;dd&gt;
1168      * Day of week before day of month; e.g., Sunday on or before March 15.
1169      * &lt;/dd&gt;
1170      * &lt;/dl&gt;
1171      * The setting of this field affects the interpretation of the
1172      * {@code endDay} field.
1173      * &lt;p&gt;If {@code useDaylight} is false, this value is ignored.
1174      * @serial
1175      * @since 1.1.4
1176      */
1177     private int endMode;
1178 
1179     /**
1180      * A positive value indicating the amount of time saved during DST in
1181      * milliseconds.
1182      * Typically one hour (3600000); sometimes 30 minutes (1800000).
1183      * &lt;p&gt;If {@code useDaylight} is false, this value is ignored.
1184      * @serial
1185      * @since 1.1.4
1186      */
1187     private int dstSavings;
1188 
1189     private static final Gregorian gcal = CalendarSystem.getGregorianCalendar();
1190 
1191     /**
1192      * Cache values representing a single period of daylight saving
1193      * time. Cache.start is the start time (inclusive) of daylight
1194      * saving time and Cache.end is the end time (exclusive).
1195      *
1196      * Cache.year has a year value if both Cache.start and Cache.end are
1197      * in the same year. Cache.year is set to startYear - 1 if
1198      * Cache.start and Cache.end are in different years.
1199      * Cache.year is a long to support Integer.MIN_VALUE - 1 (JCK requirement).
1200      */
1201     private static final class Cache {
1202         final long year;
1203         final long start;
1204         final long end;
1205 
1206         Cache(long year, long start, long end) {
1207             this.year = year;
1208             this.start = start;
1209             this.end = end;
1210         }
1211     }
1212 
1213     private transient volatile Cache cache;
1214 
1215     /**
1216      * Constants specifying values of startMode and endMode.
1217      */
1218     private static final int DOM_MODE          = 1; // Exact day of month, &quot;Mar 1&quot;
1219     private static final int DOW_IN_MONTH_MODE = 2; // Day of week in month, &quot;lastSun&quot;
1220     private static final int DOW_GE_DOM_MODE   = 3; // Day of week after day of month, &quot;Sun&gt;=15&quot;
1221     private static final int DOW_LE_DOM_MODE   = 4; // Day of week before day of month, &quot;Sun&lt;=21&quot;
1222 
1223     /**
1224      * Constant for a mode of start or end time specified as wall clock
1225      * time.  Wall clock time is standard time for the onset rule, and
1226      * daylight time for the end rule.
1227      * @since 1.4
1228      */
1229     public static final int WALL_TIME = 0; // Zero for backward compatibility
1230 
1231     /**
1232      * Constant for a mode of start or end time specified as standard time.
1233      * @since 1.4
1234      */
1235     public static final int STANDARD_TIME = 1;
1236 
1237     /**
1238      * Constant for a mode of start or end time specified as UTC. European
1239      * Union rules are specified as UTC time, for example.
1240      * @since 1.4
1241      */
1242     public static final int UTC_TIME = 2;
1243 
1244     // Proclaim compatibility with 1.1
1245     @java.io.Serial
1246     static final long serialVersionUID = -403250971215465050L;
1247 
1248     // the internal serial version which says which version was written
1249     // - 0 (default) for version up to JDK 1.1.3
1250     // - 1 for version from JDK 1.1.4, which includes 3 new fields
1251     // - 2 for JDK 1.3, which includes 2 new fields
1252     static final int currentSerialVersion = 2;
1253 
1254     /**
1255      * The version of the serialized data on the stream.  Possible values:
1256      * &lt;dl&gt;
1257      * &lt;dt&gt;&lt;b&gt;0&lt;/b&gt; or not present on stream&lt;/dt&gt;
1258      * &lt;dd&gt;
1259      * JDK 1.1.3 or earlier.
1260      * &lt;/dd&gt;
1261      * &lt;dt&gt;&lt;b&gt;1&lt;/b&gt;&lt;/dt&gt;
1262      * &lt;dd&gt;
1263      * JDK 1.1.4 or later.  Includes three new fields: {@code startMode},
1264      * {@code endMode}, and {@code dstSavings}.
1265      * &lt;/dd&gt;
1266      * &lt;dt&gt;&lt;b&gt;2&lt;/b&gt;&lt;/dt&gt;
1267      * &lt;dd&gt;
1268      * JDK 1.3 or later.  Includes two new fields: {@code startTimeMode}
1269      * and {@code endTimeMode}.
1270      * &lt;/dd&gt;
1271      * &lt;/dl&gt;
1272      * When streaming out this class, the most recent format
1273      * and the highest allowable {@code serialVersionOnStream}
1274      * is written.
1275      * @serial
1276      * @since 1.1.4
1277      */
1278     private int serialVersionOnStream = currentSerialVersion;
1279 
1280     // Maximum number of rules.
1281     private static final int MAX_RULE_NUM = 6;
1282 
1283     private void invalidateCache() {
1284         cache = null;
1285     }
1286 
1287     //----------------------------------------------------------------------
1288     // Rule representation
1289     //
1290     // We represent the following flavors of rules:
1291     //       5        the fifth of the month
1292     //       lastSun  the last Sunday in the month
1293     //       lastMon  the last Monday in the month
1294     //       Sun&gt;=8   first Sunday on or after the eighth
1295     //       Sun&lt;=25  last Sunday on or before the 25th
1296     // This is further complicated by the fact that we need to remain
1297     // backward compatible with the 1.1 FCS.  Finally, we need to minimize
1298     // API changes.  In order to satisfy these requirements, we support
1299     // three representation systems, and we translate between them.
1300     //
1301     // INTERNAL REPRESENTATION
1302     // This is the format SimpleTimeZone objects take after construction or
1303     // streaming in is complete.  Rules are represented directly, using an
1304     // unencoded format.  We will discuss the start rule only below; the end
1305     // rule is analogous.
1306     //   startMode      Takes on enumerated values DAY_OF_MONTH,
1307     //                  DOW_IN_MONTH, DOW_AFTER_DOM, or DOW_BEFORE_DOM.
1308     //   startDay       The day of the month, or for DOW_IN_MONTH mode, a
1309     //                  value indicating which DOW, such as +1 for first,
1310     //                  +2 for second, -1 for last, etc.
1311     //   startDayOfWeek The day of the week.  Ignored for DAY_OF_MONTH.
1312     //
1313     // ENCODED REPRESENTATION
1314     // This is the format accepted by the constructor and by setStartRule()
1315     // and setEndRule().  It uses various combinations of positive, negative,
1316     // and zero values to encode the different rules.  This representation
1317     // allows us to specify all the different rule flavors without altering
1318     // the API.
1319     //   MODE              startMonth    startDay    startDayOfWeek
1320     //   DOW_IN_MONTH_MODE &gt;=0           !=0         &gt;0
1321     //   DOM_MODE          &gt;=0           &gt;0          ==0
1322     //   DOW_GE_DOM_MODE   &gt;=0           &gt;0          &lt;0
1323     //   DOW_LE_DOM_MODE   &gt;=0           &lt;0          &lt;0
1324     //   (no DST)          don&#39;t care    ==0         don&#39;t care
1325     //
1326     // STREAMED REPRESENTATION
1327     // We must retain binary compatibility with the 1.1 FCS.  The 1.1 code only
1328     // handles DOW_IN_MONTH_MODE and non-DST mode, the latter indicated by the
1329     // flag useDaylight.  When we stream an object out, we translate into an
1330     // approximate DOW_IN_MONTH_MODE representation so the object can be parsed
1331     // and used by 1.1 code.  Following that, we write out the full
1332     // representation separately so that contemporary code can recognize and
1333     // parse it.  The full representation is written in a &quot;packed&quot; format,
1334     // consisting of a version number, a length, and an array of bytes.  Future
1335     // versions of this class may specify different versions.  If they wish to
1336     // include additional data, they should do so by storing them after the
1337     // packed representation below.
1338     //----------------------------------------------------------------------
1339 
1340     /**
1341      * Given a set of encoded rules in startDay and startDayOfMonth, decode
1342      * them and set the startMode appropriately.  Do the same for endDay and
1343      * endDayOfMonth.  Upon entry, the day of week variables may be zero or
1344      * negative, in order to indicate special modes.  The day of month
1345      * variables may also be negative.  Upon exit, the mode variables will be
1346      * set, and the day of week and day of month variables will be positive.
1347      * This method also recognizes a startDay or endDay of zero as indicating
1348      * no DST.
1349      */
1350     private void decodeRules()
1351     {
1352         decodeStartRule();
1353         decodeEndRule();
1354     }
1355 
1356     /**
1357      * Decode the start rule and validate the parameters.  The parameters are
1358      * expected to be in encoded form, which represents the various rule modes
1359      * by negating or zeroing certain values.  Representation formats are:
1360      * &lt;p&gt;
1361      * &lt;pre&gt;
1362      *            DOW_IN_MONTH  DOM    DOW&gt;=DOM  DOW&lt;=DOM  no DST
1363      *            ------------  -----  --------  --------  ----------
1364      * month       0..11        same    same      same     don&#39;t care
1365      * day        -5..5         1..31   1..31    -1..-31   0
1366      * dayOfWeek   1..7         0      -1..-7    -1..-7    don&#39;t care
1367      * time        0..ONEDAY    same    same      same     don&#39;t care
1368      * &lt;/pre&gt;
1369      * The range for month does not include UNDECIMBER since this class is
1370      * really specific to GregorianCalendar, which does not use that month.
1371      * The range for time includes ONEDAY (vs. ending at ONEDAY-1) because the
1372      * end rule is an exclusive limit point.  That is, the range of times that
1373      * are in DST include those &gt;= the start and &lt; the end.  For this reason,
1374      * it should be possible to specify an end of ONEDAY in order to include the
1375      * entire day.  Although this is equivalent to time 0 of the following day,
1376      * it&#39;s not always possible to specify that, for example, on December 31.
1377      * While arguably the start range should still be 0..ONEDAY-1, we keep
1378      * the start and end ranges the same for consistency.
1379      */
1380     private void decodeStartRule() {
1381         useDaylight = (startDay != 0) &amp;&amp; (endDay != 0);
1382         if (startDay != 0) {
1383             if (startMonth &lt; Calendar.JANUARY || startMonth &gt; Calendar.DECEMBER) {
1384                 throw new IllegalArgumentException(
1385                         &quot;Illegal start month &quot; + startMonth);
1386             }
1387             if (startTime &lt; 0 || startTime &gt; millisPerDay) {
1388                 throw new IllegalArgumentException(
1389                         &quot;Illegal start time &quot; + startTime);
1390             }
1391             if (startDayOfWeek == 0) {
1392                 startMode = DOM_MODE;
1393             } else {
1394                 if (startDayOfWeek &gt; 0) {
1395                     startMode = DOW_IN_MONTH_MODE;
1396                 } else {
1397                     startDayOfWeek = -startDayOfWeek;
1398                     if (startDay &gt; 0) {
1399                         startMode = DOW_GE_DOM_MODE;
1400                     } else {
1401                         startDay = -startDay;
1402                         startMode = DOW_LE_DOM_MODE;
1403                     }
1404                 }
1405                 if (startDayOfWeek &gt; Calendar.SATURDAY) {
1406                     throw new IllegalArgumentException(
1407                            &quot;Illegal start day of week &quot; + startDayOfWeek);
1408                 }
1409             }
1410             if (startMode == DOW_IN_MONTH_MODE) {
1411                 if (startDay &lt; -5 || startDay &gt; 5) {
1412                     throw new IllegalArgumentException(
1413                             &quot;Illegal start day of week in month &quot; + startDay);
1414                 }
1415             } else if (startDay &lt; 1 || startDay &gt; staticMonthLength[startMonth]) {
1416                 throw new IllegalArgumentException(
1417                         &quot;Illegal start day &quot; + startDay);
1418             }
1419         }
1420     }
1421 
1422     /**
1423      * Decode the end rule and validate the parameters.  This method is exactly
1424      * analogous to decodeStartRule().
1425      * @see decodeStartRule
1426      */
1427     private void decodeEndRule() {
1428         useDaylight = (startDay != 0) &amp;&amp; (endDay != 0);
1429         if (endDay != 0) {
1430             if (endMonth &lt; Calendar.JANUARY || endMonth &gt; Calendar.DECEMBER) {
1431                 throw new IllegalArgumentException(
1432                         &quot;Illegal end month &quot; + endMonth);
1433             }
1434             if (endTime &lt; 0 || endTime &gt; millisPerDay) {
1435                 throw new IllegalArgumentException(
1436                         &quot;Illegal end time &quot; + endTime);
1437             }
1438             if (endDayOfWeek == 0) {
1439                 endMode = DOM_MODE;
1440             } else {
1441                 if (endDayOfWeek &gt; 0) {
1442                     endMode = DOW_IN_MONTH_MODE;
1443                 } else {
1444                     endDayOfWeek = -endDayOfWeek;
1445                     if (endDay &gt; 0) {
1446                         endMode = DOW_GE_DOM_MODE;
1447                     } else {
1448                         endDay = -endDay;
1449                         endMode = DOW_LE_DOM_MODE;
1450                     }
1451                 }
1452                 if (endDayOfWeek &gt; Calendar.SATURDAY) {
1453                     throw new IllegalArgumentException(
1454                            &quot;Illegal end day of week &quot; + endDayOfWeek);
1455                 }
1456             }
1457             if (endMode == DOW_IN_MONTH_MODE) {
1458                 if (endDay &lt; -5 || endDay &gt; 5) {
1459                     throw new IllegalArgumentException(
1460                             &quot;Illegal end day of week in month &quot; + endDay);
1461                 }
1462             } else if (endDay &lt; 1 || endDay &gt; staticMonthLength[endMonth]) {
1463                 throw new IllegalArgumentException(
1464                         &quot;Illegal end day &quot; + endDay);
1465             }
1466         }
1467     }
1468 
1469     /**
1470      * Make rules compatible to 1.1 FCS code.  Since 1.1 FCS code only understands
1471      * day-of-week-in-month rules, we must modify other modes of rules to their
1472      * approximate equivalent in 1.1 FCS terms.  This method is used when streaming
1473      * out objects of this class.  After it is called, the rules will be modified,
1474      * with a possible loss of information.  startMode and endMode will NOT be
1475      * altered, even though semantically they should be set to DOW_IN_MONTH_MODE,
1476      * since the rule modification is only intended to be temporary.
1477      */
1478     private void makeRulesCompatible()
1479     {
1480         switch (startMode) {
1481         case DOM_MODE:
1482             startDay = 1 + (startDay / 7);
1483             startDayOfWeek = Calendar.SUNDAY;
1484             break;
1485 
1486         case DOW_GE_DOM_MODE:
1487             // A day-of-month of 1 is equivalent to DOW_IN_MONTH_MODE
1488             // that is, Sun&gt;=1 == firstSun.
1489             if (startDay != 1) {
1490                 startDay = 1 + (startDay / 7);
1491             }
1492             break;
1493 
1494         case DOW_LE_DOM_MODE:
1495             if (startDay &gt;= 30) {
1496                 startDay = -1;
1497             } else {
1498                 startDay = 1 + (startDay / 7);
1499             }
1500             break;
1501         }
1502 
1503         switch (endMode) {
1504         case DOM_MODE:
1505             endDay = 1 + (endDay / 7);
1506             endDayOfWeek = Calendar.SUNDAY;
1507             break;
1508 
1509         case DOW_GE_DOM_MODE:
1510             // A day-of-month of 1 is equivalent to DOW_IN_MONTH_MODE
1511             // that is, Sun&gt;=1 == firstSun.
1512             if (endDay != 1) {
1513                 endDay = 1 + (endDay / 7);
1514             }
1515             break;
1516 
1517         case DOW_LE_DOM_MODE:
1518             if (endDay &gt;= 30) {
1519                 endDay = -1;
1520             } else {
1521                 endDay = 1 + (endDay / 7);
1522             }
1523             break;
1524         }
1525 
1526         /*
1527          * Adjust the start and end times to wall time.  This works perfectly
1528          * well unless it pushes into the next or previous day.  If that
1529          * happens, we attempt to adjust the day rule somewhat crudely.  The day
1530          * rules have been forced into DOW_IN_MONTH mode already, so we change
1531          * the day of week to move forward or back by a day.  It&#39;s possible to
1532          * make a more refined adjustment of the original rules first, but in
1533          * most cases this extra effort will go to waste once we adjust the day
1534          * rules anyway.
1535          */
1536         switch (startTimeMode) {
1537         case UTC_TIME:
1538             startTime += rawOffset;
1539             break;
1540         }
1541         while (startTime &lt; 0) {
1542             startTime += millisPerDay;
1543             startDayOfWeek = 1 + ((startDayOfWeek+5) % 7); // Back 1 day
1544         }
1545         while (startTime &gt;= millisPerDay) {
1546             startTime -= millisPerDay;
1547             startDayOfWeek = 1 + (startDayOfWeek % 7); // Forward 1 day
1548         }
1549 
1550         switch (endTimeMode) {
1551         case UTC_TIME:
1552             endTime += rawOffset + dstSavings;
1553             break;
1554         case STANDARD_TIME:
1555             endTime += dstSavings;
1556         }
1557         while (endTime &lt; 0) {
1558             endTime += millisPerDay;
1559             endDayOfWeek = 1 + ((endDayOfWeek+5) % 7); // Back 1 day
1560         }
1561         while (endTime &gt;= millisPerDay) {
1562             endTime -= millisPerDay;
1563             endDayOfWeek = 1 + (endDayOfWeek % 7); // Forward 1 day
1564         }
1565     }
1566 
1567     /**
1568      * Pack the start and end rules into an array of bytes.  Only pack
1569      * data which is not preserved by makeRulesCompatible.
1570      */
1571     private byte[] packRules()
1572     {
1573         byte[] rules = new byte[MAX_RULE_NUM];
1574         rules[0] = (byte)startDay;
1575         rules[1] = (byte)startDayOfWeek;
1576         rules[2] = (byte)endDay;
1577         rules[3] = (byte)endDayOfWeek;
1578 
1579         // As of serial version 2, include time modes
1580         rules[4] = (byte)startTimeMode;
1581         rules[5] = (byte)endTimeMode;
1582 
1583         return rules;
1584     }
1585 
1586     /**
1587      * Given an array of bytes produced by packRules, interpret them
1588      * as the start and end rules.
1589      */
1590     private void unpackRules(byte[] rules)
1591     {
1592         startDay       = rules[0];
1593         startDayOfWeek = rules[1];
1594         endDay         = rules[2];
1595         endDayOfWeek   = rules[3];
1596 
1597         // As of serial version 2, include time modes
1598         if (rules.length &gt;= MAX_RULE_NUM) {
1599             startTimeMode = rules[4];
1600             endTimeMode   = rules[5];
1601         }
1602     }
1603 
1604     /**
1605      * Pack the start and end times into an array of bytes.  This is required
1606      * as of serial version 2.
1607      */
1608     private int[] packTimes() {
1609         int[] times = new int[2];
1610         times[0] = startTime;
1611         times[1] = endTime;
1612         return times;
1613     }
1614 
1615     /**
1616      * Unpack the start and end times from an array of bytes.  This is required
1617      * as of serial version 2.
1618      */
1619     private void unpackTimes(int[] times) {
1620         startTime = times[0];
1621         endTime = times[1];
1622     }
1623 
1624     /**
1625      * Save the state of this object to a stream (i.e., serialize it).
1626      *
1627      * @serialData We write out two formats, a JDK 1.1 compatible format, using
1628      * {@code DOW_IN_MONTH_MODE} rules, in the required section, followed
1629      * by the full rules, in packed format, in the optional section.  The
1630      * optional section will be ignored by JDK 1.1 code upon stream in.
1631      * &lt;p&gt; Contents of the optional section: The length of a byte array is
1632      * emitted (int); this is 4 as of this release. The byte array of the given
1633      * length is emitted. The contents of the byte array are the true values of
1634      * the fields {@code startDay}, {@code startDayOfWeek},
1635      * {@code endDay}, and {@code endDayOfWeek}.  The values of these
1636      * fields in the required section are approximate values suited to the rule
1637      * mode {@code DOW_IN_MONTH_MODE}, which is the only mode recognized by
1638      * JDK 1.1.
1639      */
1640     @java.io.Serial
1641     private void writeObject(ObjectOutputStream stream)
1642          throws IOException
1643     {
1644         // Construct a binary rule
1645         byte[] rules = packRules();
1646         int[] times = packTimes();
1647 
1648         // Convert to 1.1 FCS rules.  This step may cause us to lose information.
1649         makeRulesCompatible();
1650 
1651         // Write out the 1.1 FCS rules
1652         stream.defaultWriteObject();
1653 
1654         // Write out the binary rules in the optional data area of the stream.
1655         stream.writeInt(rules.length);
1656         stream.write(rules);
1657         stream.writeObject(times);
1658 
1659         // Recover the original rules.  This recovers the information lost
1660         // by makeRulesCompatible.
1661         unpackRules(rules);
1662         unpackTimes(times);
1663     }
1664 
1665     /**
1666      * Reconstitute this object from a stream (i.e., deserialize it).
1667      *
1668      * We handle both JDK 1.1
1669      * binary formats and full formats with a packed byte array.
1670      */
1671     @java.io.Serial
1672     private void readObject(ObjectInputStream stream)
1673          throws IOException, ClassNotFoundException
1674     {
1675         stream.defaultReadObject();
1676 
1677         if (serialVersionOnStream &lt; 1) {
1678             // Fix a bug in the 1.1 SimpleTimeZone code -- namely,
1679             // startDayOfWeek and endDayOfWeek were usually uninitialized.  We can&#39;t do
1680             // too much, so we assume SUNDAY, which actually works most of the time.
1681             if (startDayOfWeek == 0) {
1682                 startDayOfWeek = Calendar.SUNDAY;
1683             }
1684             if (endDayOfWeek == 0) {
1685                 endDayOfWeek = Calendar.SUNDAY;
1686             }
1687 
1688             // The variables dstSavings, startMode, and endMode are post-1.1, so they
1689             // won&#39;t be present if we&#39;re reading from a 1.1 stream.  Fix them up.
1690             startMode = endMode = DOW_IN_MONTH_MODE;
1691             dstSavings = millisPerHour;
1692         } else {
1693             // For 1.1.4, in addition to the 3 new instance variables, we also
1694             // store the actual rules (which have not be made compatible with 1.1)
1695             // in the optional area.  Read them in here and parse them.
1696             int length = stream.readInt();
1697             if (length &lt;= MAX_RULE_NUM) {
1698                 byte[] rules = new byte[length];
1699                 stream.readFully(rules);
1700                 unpackRules(rules);
1701             } else {
1702                 throw new InvalidObjectException(&quot;Too many rules: &quot; + length);
1703             }
1704         }
1705 
1706         if (serialVersionOnStream &gt;= 2) {
1707             int[] times = (int[]) stream.readObject();
1708             unpackTimes(times);
1709         }
1710 
1711         serialVersionOnStream = currentSerialVersion;
1712     }
1713 }
    </pre>
  </body>
</html>
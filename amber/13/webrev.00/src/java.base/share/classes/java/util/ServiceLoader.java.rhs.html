<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/util/ServiceLoader.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.util;
  27 
  28 import java.io.BufferedReader;
  29 import java.io.IOException;
  30 import java.io.InputStream;
  31 import java.io.InputStreamReader;
  32 import java.lang.reflect.Constructor;
  33 import java.lang.reflect.InvocationTargetException;
  34 import java.lang.reflect.Method;
  35 import java.lang.reflect.Modifier;
  36 import java.net.URL;
  37 import java.net.URLConnection;
  38 import java.security.AccessControlContext;
  39 import java.security.AccessController;
  40 import java.security.PrivilegedAction;
  41 import java.security.PrivilegedActionException;
  42 import java.security.PrivilegedExceptionAction;
  43 import java.util.function.Consumer;
  44 import java.util.function.Supplier;
  45 import java.util.stream.Stream;
  46 import java.util.stream.StreamSupport;
  47 
  48 import sun.nio.cs.UTF_8;
  49 
  50 import jdk.internal.loader.BootLoader;
  51 import jdk.internal.loader.ClassLoaders;
  52 import jdk.internal.access.JavaLangAccess;
  53 import jdk.internal.access.SharedSecrets;
  54 import jdk.internal.misc.VM;
  55 import jdk.internal.module.ServicesCatalog;
  56 import jdk.internal.module.ServicesCatalog.ServiceProvider;
  57 import jdk.internal.reflect.CallerSensitive;
  58 import jdk.internal.reflect.Reflection;
  59 
  60 /**
  61  * A facility to load implementations of a service.
  62  *
  63  * &lt;p&gt; A &lt;i&gt;service&lt;/i&gt; is a well-known interface or class for which zero, one,
  64  * or many service providers exist. A &lt;i&gt;service provider&lt;/i&gt; (or just
  65  * &lt;i&gt;provider&lt;/i&gt;) is a class that implements or subclasses the well-known
  66  * interface or class. A {@code ServiceLoader} is an object that locates and
  67  * loads service providers deployed in the run time environment at a time of an
  68  * application&#39;s choosing. Application code refers only to the service, not to
  69  * service providers, and is assumed to be capable of choosing between multiple
  70  * service providers (based on the functionality they expose through the service),
  71  * and handling the possibility that no service providers are located.
  72  *
  73  * &lt;h2&gt; Obtaining a service loader &lt;/h2&gt;
  74  *
  75  * &lt;p&gt; An application obtains a service loader for a given service by invoking
  76  * one of the static {@code load} methods of {@code ServiceLoader}. If the
  77  * application is a module, then its module declaration must have a &lt;i&gt;uses&lt;/i&gt;
  78  * directive that specifies the service; this helps to locate providers and ensure
  79  * they will execute reliably. In addition, if the application module does not
  80  * contain the service, then its module declaration must have a &lt;i&gt;requires&lt;/i&gt;
  81  * directive that specifies the module which exports the service. It is strongly
  82  * recommended that the application module does &lt;b&gt;not&lt;/b&gt; require modules which
  83  * contain providers of the service.
  84  *
  85  * &lt;p&gt; A service loader can be used to locate and instantiate providers of the
  86  * service by means of the {@link #iterator() iterator} method. {@code ServiceLoader}
  87  * also defines the {@link #stream() stream} method to obtain a stream of providers
  88  * that can be inspected and filtered without instantiating them.
  89  *
  90  * &lt;p&gt; As an example, suppose the service is {@code com.example.CodecFactory}, an
  91  * interface that defines methods for producing encoders and decoders:
  92  *
  93  * &lt;pre&gt;{@code
  94  *     package com.example;
  95  *     public interface CodecFactory {
  96  *         Encoder getEncoder(String encodingName);
  97  *         Decoder getDecoder(String encodingName);
  98  *     }
  99  * }&lt;/pre&gt;
 100  *
 101  * &lt;p&gt; The following code obtains a service loader for the {@code CodecFactory}
 102  * service, then uses its iterator (created automatically by the enhanced-for
 103  * loop) to yield instances of the service providers that are located:
 104  *
 105  * &lt;pre&gt;{@code
 106  *     ServiceLoader&lt;CodecFactory&gt; loader = ServiceLoader.load(CodecFactory.class);
 107  *     for (CodecFactory factory : loader) {
 108  *         Encoder enc = factory.getEncoder(&quot;PNG&quot;);
 109  *         if (enc != null)
 110  *             ... use enc to encode a PNG file
 111  *             break;
 112  *         }
 113  * }&lt;/pre&gt;
 114  *
 115  * &lt;p&gt; If this code resides in a module, then in order to refer to the
 116  * {@code com.example.CodecFactory} interface, the module declaration would
 117  * require the module which exports the interface. The module declaration would
 118  * also specify use of {@code com.example.CodecFactory}:
 119  * &lt;pre&gt;{@code
 120  *     requires com.example.codec.core;
 121  *     uses com.example.CodecFactory;
 122  * }&lt;/pre&gt;
 123  *
 124  * &lt;p&gt; Sometimes an application may wish to inspect a service provider before
 125  * instantiating it, in order to determine if an instance of that service
 126  * provider would be useful. For example, a service provider for {@code
 127  * CodecFactory} that is capable of producing a &quot;PNG&quot; encoder may be annotated
 128  * with {@code @PNG}. The following code uses service loader&#39;s {@code stream}
 129  * method to yield instances of {@code Provider&lt;CodecFactory&gt;} in contrast to
 130  * how the iterator yields instances of {@code CodecFactory}:
 131  * &lt;pre&gt;{@code
 132  *     ServiceLoader&lt;CodecFactory&gt; loader = ServiceLoader.load(CodecFactory.class);
 133  *     Set&lt;CodecFactory&gt; pngFactories = loader
 134  *            .stream()                                              // Note a below
 135  *            .filter(p -&gt; p.type().isAnnotationPresent(PNG.class))  // Note b
 136  *            .map(Provider::get)                                    // Note c
 137  *            .collect(Collectors.toSet());
 138  * }&lt;/pre&gt;
 139  * &lt;ol type=&quot;a&quot;&gt;
 140  *   &lt;li&gt; A stream of {@code Provider&lt;CodecFactory&gt;} objects &lt;/li&gt;
 141  *   &lt;li&gt; {@code p.type()} yields a {@code Class&lt;CodecFactory&gt;} &lt;/li&gt;
 142  *   &lt;li&gt; {@code get()} yields an instance of {@code CodecFactory} &lt;/li&gt;
 143  * &lt;/ol&gt;
 144  *
 145  * &lt;h2&gt; Designing services &lt;/h2&gt;
 146  *
 147  * &lt;p&gt; A service is a single type, usually an interface or abstract class. A
 148  * concrete class can be used, but this is not recommended. The type may have
 149  * any accessibility. The methods of a service are highly domain-specific, so
 150  * this API specification cannot give concrete advice about their form or
 151  * function. However, there are two general guidelines:
 152  * &lt;ol&gt;
 153  *   &lt;li&gt;&lt;p&gt; A service should declare as many methods as needed to allow service
 154  *   providers to communicate their domain-specific properties and other
 155  *   quality-of-implementation factors. An application which obtains a service
 156  *   loader for the service may then invoke these methods on each instance of
 157  *   a service provider, in order to choose the best provider for the
 158  *   application. &lt;/p&gt;&lt;/li&gt;
 159  *   &lt;li&gt;&lt;p&gt; A service should express whether its service providers are intended
 160  *   to be direct implementations of the service or to be an indirection
 161  *   mechanism such as a &quot;proxy&quot; or a &quot;factory&quot;. Service providers tend to be
 162  *   indirection mechanisms when domain-specific objects are relatively
 163  *   expensive to instantiate; in this case, the service should be designed
 164  *   so that service providers are abstractions which create the &quot;real&quot;
 165  *   implementation on demand. For example, the {@code CodecFactory} service
 166  *   expresses through its name that its service providers are factories
 167  *   for codecs, rather than codecs themselves, because it may be expensive
 168  *   or complicated to produce certain codecs. &lt;/p&gt;&lt;/li&gt;
 169  * &lt;/ol&gt;
 170  *
 171  * &lt;h2&gt; &lt;a id=&quot;developing-service-providers&quot;&gt;Developing service providers&lt;/a&gt; &lt;/h2&gt;
 172  *
 173  * &lt;p&gt; A service provider is a single type, usually a concrete class. An
 174  * interface or abstract class is permitted because it may declare a static
 175  * provider method, discussed later. The type must be public and must not be
 176  * an inner class.
 177  *
 178  * &lt;p&gt; A service provider and its supporting code may be developed in a module,
 179  * which is then deployed on the application module path or in a modular
 180  * image. Alternatively, a service provider and its supporting code may be
 181  * packaged as a JAR file and deployed on the application class path. The
 182  * advantage of developing a service provider in a module is that the provider
 183  * can be fully encapsulated to hide all details of its implementation.
 184  *
 185  * &lt;p&gt; An application that obtains a service loader for a given service is
 186  * indifferent to whether providers of the service are deployed in modules or
 187  * packaged as JAR files. The application instantiates service providers via
 188  * the service loader&#39;s iterator, or via {@link Provider Provider} objects in
 189  * the service loader&#39;s stream, without knowledge of the service providers&#39;
 190  * locations.
 191  *
 192  * &lt;h2&gt; Deploying service providers as modules &lt;/h2&gt;
 193  *
 194  * &lt;p&gt; A service provider that is developed in a module must be specified in a
 195  * &lt;i&gt;provides&lt;/i&gt; directive in the module declaration. The provides directive
 196  * specifies both the service and the service provider; this helps to locate the
 197  * provider when another module, with a &lt;i&gt;uses&lt;/i&gt; directive for the service,
 198  * obtains a service loader for the service. It is strongly recommended that the
 199  * module does not export the package containing the service provider. There is
 200  * no support for a module specifying, in a &lt;i&gt;provides&lt;/i&gt; directive, a service
 201  * provider in another module.
<a name="2" id="anc2"></a><span class="line-modified"> 202  *</span>
 203  * &lt;p&gt; A service provider that is developed in a module has no control over when
 204  * it is instantiated, since that occurs at the behest of the application, but it
 205  * does have control over how it is instantiated:
 206  *
 207  * &lt;ul&gt;
 208  *
 209  *   &lt;li&gt; If the service provider declares a provider method, then the service
 210  *   loader invokes that method to obtain an instance of the service provider. A
 211  *   provider method is a public static method named &quot;provider&quot; with no formal
 212  *   parameters and a return type that is assignable to the service&#39;s interface
 213  *   or class.
 214  *   &lt;p&gt; In this case, the service provider itself need not be assignable to the
 215  *   service&#39;s interface or class. &lt;/li&gt;
 216  *
 217  *   &lt;li&gt; If the service provider does not declare a provider method, then the
 218  *   service provider is instantiated directly, via its provider constructor. A
 219  *   provider constructor is a public constructor with no formal parameters.
 220  *   &lt;p&gt; In this case, the service provider must be assignable to the service&#39;s
 221  *   interface or class &lt;/li&gt;
 222  *
 223  * &lt;/ul&gt;
 224  *
 225  * &lt;p&gt; A service provider that is deployed as an
 226  * {@linkplain java.lang.module.ModuleDescriptor#isAutomatic automatic module} on
 227  * the application module path must have a provider constructor. There is no
 228  * support for a provider method in this case.
 229  *
 230  * &lt;p&gt; As an example, suppose a module specifies the following directives:
 231  * &lt;pre&gt;{@code
 232  *     provides com.example.CodecFactory with com.example.impl.StandardCodecs;
 233  *     provides com.example.CodecFactory with com.example.impl.ExtendedCodecsFactory;
 234  * }&lt;/pre&gt;
 235  *
 236  * &lt;p&gt; where
 237  *
 238  * &lt;ul&gt;
 239  *   &lt;li&gt; {@code com.example.CodecFactory} is the two-method service from
 240  *   earlier. &lt;/li&gt;
 241  *
 242  *   &lt;li&gt; {@code com.example.impl.StandardCodecs} is a public class that implements
 243  *   {@code CodecFactory} and has a public no-args constructor. &lt;/li&gt;
 244  *
 245  *   &lt;li&gt; {@code com.example.impl.ExtendedCodecsFactory} is a public class that
 246  *   does not implement CodecFactory, but it declares a public static no-args
 247  *   method named &quot;provider&quot; with a return type of {@code CodecFactory}. &lt;/li&gt;
 248  * &lt;/ul&gt;
 249  *
 250  * &lt;p&gt; A service loader will instantiate {@code StandardCodecs} via its
 251  * constructor, and will instantiate {@code ExtendedCodecsFactory} by invoking
 252  * its {@code provider} method. The requirement that the provider constructor or
 253  * provider method is public helps to document the intent that the class (that is,
 254  * the service provider) will be instantiated by an entity (that is, a service
 255  * loader) which is outside the class&#39;s package.
 256  *
 257  * &lt;h2&gt; Deploying service providers on the class path &lt;/h2&gt;
 258  *
 259  * A service provider that is packaged as a JAR file for the class path is
 260  * identified by placing a &lt;i&gt;provider-configuration file&lt;/i&gt; in the resource
 261  * directory {@code META-INF/services}. The name of the provider-configuration
 262  * file is the fully qualified binary name of the service. The provider-configuration
 263  * file contains a list of fully qualified binary names of service providers, one
 264  * per line.
 265  *
 266  * &lt;p&gt; For example, suppose the service provider
 267  * {@code com.example.impl.StandardCodecs} is packaged in a JAR file for the
 268  * class path. The JAR file will contain a provider-configuration file named:
 269  *
 270  * &lt;blockquote&gt;{@code
 271  *     META-INF/services/com.example.CodecFactory
 272  * }&lt;/blockquote&gt;
 273  *
 274  * that contains the line:
 275  *
 276  * &lt;blockquote&gt;{@code
 277  *     com.example.impl.StandardCodecs # Standard codecs
 278  * }&lt;/blockquote&gt;
 279  *
 280  * &lt;p&gt;&lt;a id=&quot;format&quot;&gt;The provider-configuration file must be encoded in UTF-8. &lt;/a&gt;
 281  * Space and tab characters surrounding each service provider&#39;s name, as well as
 282  * blank lines, are ignored. The comment character is {@code &#39;#&#39;}
 283  * ({@code &#39;&amp;#92;u0023&#39;} &lt;span style=&quot;font-size:smaller;&quot;&gt;NUMBER SIGN&lt;/span&gt;);
 284  * on each line all characters following the first comment character are ignored.
 285  * If a service provider class name is listed more than once in a
 286  * provider-configuration file then the duplicate is ignored. If a service
 287  * provider class is named in more than one configuration file then the duplicate
 288  * is ignored.
 289  *
 290  * &lt;p&gt; A service provider that is mentioned in a provider-configuration file may
 291  * be located in the same JAR file as the provider-configuration file or in a
 292  * different JAR file. The service provider must be visible from the class loader
 293  * that is initially queried to locate the provider-configuration file; this is
 294  * not necessarily the class loader which ultimately locates the
 295  * provider-configuration file.
 296  *
 297  * &lt;h2&gt; Timing of provider discovery &lt;/h2&gt;
 298  *
 299  * &lt;p&gt; Service providers are loaded and instantiated lazily, that is, on demand.
 300  * A service loader maintains a cache of the providers that have been loaded so
 301  * far. Each invocation of the {@code iterator} method returns an {@code Iterator}
 302  * that first yields all of the elements cached from previous iteration, in
 303  * instantiation order, and then lazily locates and instantiates any remaining
 304  * providers, adding each one to the cache in turn. Similarly, each invocation
 305  * of the stream method returns a {@code Stream} that first processes all
 306  * providers loaded by previous stream operations, in load order, and then lazily
 307  * locates any remaining providers. Caches are cleared via the {@link #reload
 308  * reload} method.
 309  *
 310  * &lt;h2&gt; &lt;a id=&quot;errors&quot;&gt;Errors&lt;/a&gt; &lt;/h2&gt;
 311  *
 312  * &lt;p&gt; When using the service loader&#39;s {@code iterator}, the {@link
 313  * Iterator#hasNext() hasNext} and {@link Iterator#next() next} methods will
 314  * fail with {@link ServiceConfigurationError} if an error occurs locating,
 315  * loading or instantiating a service provider. When processing the service
 316  * loader&#39;s stream then {@code ServiceConfigurationError} may be thrown by any
 317  * method that causes a service provider to be located or loaded.
 318  *
 319  * &lt;p&gt; When loading or instantiating a service provider in a module, {@code
 320  * ServiceConfigurationError} can be thrown for the following reasons:
 321  *
 322  * &lt;ul&gt;
 323  *
 324  *   &lt;li&gt; The service provider cannot be loaded. &lt;/li&gt;
 325  *
 326  *   &lt;li&gt; The service provider does not declare a provider method, and either
 327  *   it is not assignable to the service&#39;s interface/class or does not have a
 328  *   provider constructor. &lt;/li&gt;
 329  *
 330  *   &lt;li&gt; The service provider declares a public static no-args method named
 331  *   &quot;provider&quot; with a return type that is not assignable to the service&#39;s
 332  *   interface or class. &lt;/li&gt;
 333  *
 334  *   &lt;li&gt; The service provider class file has more than one public static
 335  *   no-args method named &quot;{@code provider}&quot;. &lt;/li&gt;
 336  *
 337  *   &lt;li&gt; The service provider declares a provider method and it fails by
 338  *   returning {@code null} or throwing an exception. &lt;/li&gt;
 339  *
 340  *   &lt;li&gt; The service provider does not declare a provider method, and its
 341  *   provider constructor fails by throwing an exception. &lt;/li&gt;
 342  *
 343  * &lt;/ul&gt;
 344  *
 345  * &lt;p&gt; When reading a provider-configuration file, or loading or instantiating
 346  * a provider class named in a provider-configuration file, then {@code
 347  * ServiceConfigurationError} can be thrown for the following reasons:
 348  *
 349  * &lt;ul&gt;
 350  *
 351  *   &lt;li&gt; The format of the provider-configuration file violates the &lt;a
 352  *   href=&quot;ServiceLoader.html#format&quot;&gt;format&lt;/a&gt; specified above; &lt;/li&gt;
 353  *
 354  *   &lt;li&gt; An {@link IOException IOException} occurs while reading the
 355  *   provider-configuration file; &lt;/li&gt;
 356  *
 357  *   &lt;li&gt; A service provider cannot be loaded; &lt;/li&gt;
 358  *
 359  *   &lt;li&gt; A service provider is not assignable to the service&#39;s interface or
 360  *   class, or does not define a provider constructor, or cannot be
 361  *   instantiated. &lt;/li&gt;
 362  *
 363  * &lt;/ul&gt;
 364  *
 365  * &lt;h2&gt; Security &lt;/h2&gt;
 366  *
 367  * &lt;p&gt; Service loaders always execute in the security context of the caller
 368  * of the iterator or stream methods and may also be restricted by the security
 369  * context of the caller that created the service loader.
 370  * Trusted system code should typically invoke the methods in this class, and
 371  * the methods of the iterators which they return, from within a privileged
 372  * security context.
 373  *
 374  * &lt;h2&gt; Concurrency &lt;/h2&gt;
 375  *
 376  * &lt;p&gt; Instances of this class are not safe for use by multiple concurrent
 377  * threads.
 378  *
 379  * &lt;h3&gt; Null handling &lt;/h3&gt;
 380  *
 381  * &lt;p&gt; Unless otherwise specified, passing a {@code null} argument to any
 382  * method in this class will cause a {@link NullPointerException} to be thrown.
 383  *
 384  * @param  &lt;S&gt;
 385  *         The type of the service to be loaded by this loader
 386  *
 387  * @author Mark Reinhold
 388  * @since 1.6
 389  * @revised 9
 390  * @spec JPMS
 391  */
 392 
 393 public final class ServiceLoader&lt;S&gt;
 394     implements Iterable&lt;S&gt;
 395 {
 396     // The class or interface representing the service being loaded
 397     private final Class&lt;S&gt; service;
 398 
 399     // The class of the service type
 400     private final String serviceName;
 401 
 402     // The module layer used to locate providers; null when locating
 403     // providers using a class loader
 404     private final ModuleLayer layer;
 405 
 406     // The class loader used to locate, load, and instantiate providers;
 407     // null when locating provider using a module layer
 408     private final ClassLoader loader;
 409 
 410     // The access control context taken when the ServiceLoader is created
 411     private final AccessControlContext acc;
 412 
 413     // The lazy-lookup iterator for iterator operations
 414     private Iterator&lt;Provider&lt;S&gt;&gt; lookupIterator1;
 415     private final List&lt;S&gt; instantiatedProviders = new ArrayList&lt;&gt;();
 416 
 417     // The lazy-lookup iterator for stream operations
 418     private Iterator&lt;Provider&lt;S&gt;&gt; lookupIterator2;
 419     private final List&lt;Provider&lt;S&gt;&gt; loadedProviders = new ArrayList&lt;&gt;();
 420     private boolean loadedAllProviders; // true when all providers loaded
 421 
 422     // Incremented when reload is called
 423     private int reloadCount;
 424 
 425     private static JavaLangAccess LANG_ACCESS;
 426     static {
 427         LANG_ACCESS = SharedSecrets.getJavaLangAccess();
 428     }
 429 
 430     /**
 431      * Represents a service provider located by {@code ServiceLoader}.
 432      *
 433      * &lt;p&gt; When using a loader&#39;s {@link ServiceLoader#stream() stream()} method
 434      * then the elements are of type {@code Provider}. This allows processing
 435      * to select or filter on the provider class without instantiating the
 436      * provider. &lt;/p&gt;
 437      *
 438      * @param  &lt;S&gt; The service type
 439      * @since 9
 440      * @spec JPMS
 441      */
 442     public static interface Provider&lt;S&gt; extends Supplier&lt;S&gt; {
 443         /**
 444          * Returns the provider type. There is no guarantee that this type is
 445          * accessible or that it has a public no-args constructor. The {@link
 446          * #get() get()} method should be used to obtain the provider instance.
 447          *
 448          * &lt;p&gt; When a module declares that the provider class is created by a
 449          * provider factory then this method returns the return type of its
 450          * public static &quot;{@code provider()}&quot; method.
 451          *
 452          * @return The provider type
 453          */
 454         Class&lt;? extends S&gt; type();
 455 
 456         /**
 457          * Returns an instance of the provider.
 458          *
 459          * @return An instance of the provider.
 460          *
 461          * @throws ServiceConfigurationError
 462          *         If the service provider cannot be instantiated, or in the
 463          *         case of a provider factory, the public static
 464          *         &quot;{@code provider()}&quot; method returns {@code null} or throws
 465          *         an error or exception. The {@code ServiceConfigurationError}
 466          *         will carry an appropriate cause where possible.
 467          */
 468         @Override S get();
 469     }
 470 
 471     /**
 472      * Initializes a new instance of this class for locating service providers
 473      * in a module layer.
 474      *
 475      * @throws ServiceConfigurationError
 476      *         If {@code svc} is not accessible to {@code caller} or the caller
 477      *         module does not use the service type.
 478      */
 479     private ServiceLoader(Class&lt;?&gt; caller, ModuleLayer layer, Class&lt;S&gt; svc) {
 480         Objects.requireNonNull(caller);
 481         Objects.requireNonNull(layer);
 482         Objects.requireNonNull(svc);
 483         checkCaller(caller, svc);
 484 
 485         this.service = svc;
 486         this.serviceName = svc.getName();
 487         this.layer = layer;
 488         this.loader = null;
 489         this.acc = (System.getSecurityManager() != null)
 490                 ? AccessController.getContext()
 491                 : null;
 492     }
 493 
 494     /**
 495      * Initializes a new instance of this class for locating service providers
 496      * via a class loader.
 497      *
 498      * @throws ServiceConfigurationError
 499      *         If {@code svc} is not accessible to {@code caller} or the caller
 500      *         module does not use the service type.
 501      */
 502     private ServiceLoader(Class&lt;?&gt; caller, Class&lt;S&gt; svc, ClassLoader cl) {
 503         Objects.requireNonNull(svc);
 504 
 505         if (VM.isBooted()) {
 506             checkCaller(caller, svc);
 507             if (cl == null) {
 508                 cl = ClassLoader.getSystemClassLoader();
 509             }
 510         } else {
 511 
 512             // if we get here then it means that ServiceLoader is being used
 513             // before the VM initialization has completed. At this point then
 514             // only code in the java.base should be executing.
 515             Module callerModule = caller.getModule();
 516             Module base = Object.class.getModule();
 517             Module svcModule = svc.getModule();
 518             if (callerModule != base || svcModule != base) {
 519                 fail(svc, &quot;not accessible to &quot; + callerModule + &quot; during VM init&quot;);
 520             }
 521 
 522             // restricted to boot loader during startup
 523             cl = null;
 524         }
 525 
 526         this.service = svc;
 527         this.serviceName = svc.getName();
 528         this.layer = null;
 529         this.loader = cl;
 530         this.acc = (System.getSecurityManager() != null)
 531                 ? AccessController.getContext()
 532                 : null;
 533     }
 534 
 535     /**
 536      * Initializes a new instance of this class for locating service providers
 537      * via a class loader.
 538      *
 539      * @apiNote For use by ResourceBundle
 540      *
 541      * @throws ServiceConfigurationError
 542      *         If the caller module does not use the service type.
 543      */
 544     private ServiceLoader(Module callerModule, Class&lt;S&gt; svc, ClassLoader cl) {
 545         if (!callerModule.canUse(svc)) {
 546             fail(svc, callerModule + &quot; does not declare `uses`&quot;);
 547         }
 548 
 549         this.service = Objects.requireNonNull(svc);
 550         this.serviceName = svc.getName();
 551         this.layer = null;
 552         this.loader = cl;
 553         this.acc = (System.getSecurityManager() != null)
 554                 ? AccessController.getContext()
 555                 : null;
 556     }
 557 
 558     /**
 559      * Checks that the given service type is accessible to types in the given
 560      * module, and check that the module declares that it uses the service type.
 561      */
 562     private static void checkCaller(Class&lt;?&gt; caller, Class&lt;?&gt; svc) {
 563         if (caller == null) {
 564             fail(svc, &quot;no caller to check if it declares `uses`&quot;);
 565         }
 566 
 567         // Check access to the service type
 568         Module callerModule = caller.getModule();
 569         int mods = svc.getModifiers();
 570         if (!Reflection.verifyMemberAccess(caller, svc, null, mods)) {
 571             fail(svc, &quot;service type not accessible to &quot; + callerModule);
 572         }
 573 
 574         // If the caller is in a named module then it should &quot;uses&quot; the
 575         // service type
 576         if (!callerModule.canUse(svc)) {
 577             fail(svc, callerModule + &quot; does not declare `uses`&quot;);
 578         }
 579     }
 580 
 581     private static void fail(Class&lt;?&gt; service, String msg, Throwable cause)
 582         throws ServiceConfigurationError
 583     {
 584         throw new ServiceConfigurationError(service.getName() + &quot;: &quot; + msg,
 585                                             cause);
 586     }
 587 
 588     private static void fail(Class&lt;?&gt; service, String msg)
 589         throws ServiceConfigurationError
 590     {
 591         throw new ServiceConfigurationError(service.getName() + &quot;: &quot; + msg);
 592     }
 593 
 594     private static void fail(Class&lt;?&gt; service, URL u, int line, String msg)
 595         throws ServiceConfigurationError
 596     {
 597         fail(service, u + &quot;:&quot; + line + &quot;: &quot; + msg);
 598     }
 599 
 600     /**
 601      * Returns {@code true} if the provider is in an explicit module
 602      */
 603     private boolean inExplicitModule(Class&lt;?&gt; clazz) {
 604         Module module = clazz.getModule();
 605         return module.isNamed() &amp;&amp; !module.getDescriptor().isAutomatic();
 606     }
 607 
 608     /**
 609      * Returns the public static &quot;provider&quot; method if found.
 610      *
 611      * @throws ServiceConfigurationError if there is an error finding the
 612      *         provider method or there is more than one public static
 613      *         provider method
 614      */
 615     private Method findStaticProviderMethod(Class&lt;?&gt; clazz) {
 616         List&lt;Method&gt; methods = null;
 617         try {
 618             methods = LANG_ACCESS.getDeclaredPublicMethods(clazz, &quot;provider&quot;);
 619         } catch (Throwable x) {
 620             fail(service, &quot;Unable to get public provider() method&quot;, x);
 621         }
 622         if (methods.isEmpty()) {
 623             // does not declare a public provider method
 624             return null;
 625         }
 626 
 627         // locate the static methods, can be at most one
 628         Method result = null;
 629         for (Method method : methods) {
 630             int mods = method.getModifiers();
 631             assert Modifier.isPublic(mods);
 632             if (Modifier.isStatic(mods)) {
 633                 if (result != null) {
 634                     fail(service, clazz + &quot; declares more than one&quot;
 635                          + &quot; public static provider() method&quot;);
 636                 }
 637                 result = method;
 638             }
 639         }
 640         if (result != null) {
 641             Method m = result;
 642             PrivilegedAction&lt;Void&gt; pa = () -&gt; {
 643                 m.setAccessible(true);
 644                 return null;
 645             };
 646             AccessController.doPrivileged(pa);
 647         }
 648         return result;
 649     }
 650 
 651     /**
 652      * Returns the public no-arg constructor of a class.
 653      *
 654      * @throws ServiceConfigurationError if the class does not have
 655      *         public no-arg constructor
 656      */
 657     private Constructor&lt;?&gt; getConstructor(Class&lt;?&gt; clazz) {
 658         PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt; pa
 659             = new PrivilegedExceptionAction&lt;&gt;() {
 660                 @Override
 661                 public Constructor&lt;?&gt; run() throws Exception {
 662                     Constructor&lt;?&gt; ctor = clazz.getConstructor();
 663                     if (inExplicitModule(clazz))
 664                         ctor.setAccessible(true);
 665                     return ctor;
 666                 }
 667             };
 668         Constructor&lt;?&gt; ctor = null;
 669         try {
 670             ctor = AccessController.doPrivileged(pa);
 671         } catch (Throwable x) {
 672             if (x instanceof PrivilegedActionException)
 673                 x = x.getCause();
 674             String cn = clazz.getName();
 675             fail(service, cn + &quot; Unable to get public no-arg constructor&quot;, x);
 676         }
 677         return ctor;
 678     }
 679 
 680     /**
 681      * A Provider implementation that supports invoking, with reduced
 682      * permissions, the static factory to obtain the provider or the
 683      * provider&#39;s no-arg constructor.
 684      */
 685     private static class ProviderImpl&lt;S&gt; implements Provider&lt;S&gt; {
 686         final Class&lt;S&gt; service;
 687         final Class&lt;? extends S&gt; type;
 688         final Method factoryMethod;  // factory method or null
 689         final Constructor&lt;? extends S&gt; ctor; // public no-args constructor or null
 690         final AccessControlContext acc;
 691 
 692         ProviderImpl(Class&lt;S&gt; service,
 693                      Class&lt;? extends S&gt; type,
 694                      Method factoryMethod,
 695                      AccessControlContext acc) {
 696             this.service = service;
 697             this.type = type;
 698             this.factoryMethod = factoryMethod;
 699             this.ctor = null;
 700             this.acc = acc;
 701         }
 702 
 703         ProviderImpl(Class&lt;S&gt; service,
 704                      Class&lt;? extends S&gt; type,
 705                      Constructor&lt;? extends S&gt; ctor,
 706                      AccessControlContext acc) {
 707             this.service = service;
 708             this.type = type;
 709             this.factoryMethod = null;
 710             this.ctor = ctor;
 711             this.acc = acc;
 712         }
 713 
 714         @Override
 715         public Class&lt;? extends S&gt; type() {
 716             return type;
 717         }
 718 
 719         @Override
 720         public S get() {
 721             if (factoryMethod != null) {
 722                 return invokeFactoryMethod();
 723             } else {
 724                 return newInstance();
 725             }
 726         }
 727 
 728         /**
 729          * Invokes the provider&#39;s &quot;provider&quot; method to instantiate a provider.
 730          * When running with a security manager then the method runs with
 731          * permissions that are restricted by the security context of whatever
 732          * created this loader.
 733          */
 734         private S invokeFactoryMethod() {
 735             Object result = null;
 736             Throwable exc = null;
 737             if (acc == null) {
 738                 try {
 739                     result = factoryMethod.invoke(null);
 740                 } catch (Throwable x) {
 741                     exc = x;
 742                 }
 743             } else {
 744                 PrivilegedExceptionAction&lt;?&gt; pa = new PrivilegedExceptionAction&lt;&gt;() {
 745                     @Override
 746                     public Object run() throws Exception {
 747                         return factoryMethod.invoke(null);
 748                     }
 749                 };
 750                 // invoke factory method with permissions restricted by acc
 751                 try {
 752                     result = AccessController.doPrivileged(pa, acc);
 753                 } catch (Throwable x) {
 754                     if (x instanceof PrivilegedActionException)
 755                         x = x.getCause();
 756                     exc = x;
 757                 }
 758             }
 759             if (exc != null) {
 760                 if (exc instanceof InvocationTargetException)
 761                     exc = exc.getCause();
 762                 fail(service, factoryMethod + &quot; failed&quot;, exc);
 763             }
 764             if (result == null) {
 765                 fail(service, factoryMethod + &quot; returned null&quot;);
 766             }
 767             @SuppressWarnings(&quot;unchecked&quot;)
 768             S p = (S) result;
 769             return p;
 770         }
 771 
 772         /**
 773          * Invokes Constructor::newInstance to instantiate a provider. When running
 774          * with a security manager then the constructor runs with permissions that
 775          * are restricted by the security context of whatever created this loader.
 776          */
 777         private S newInstance() {
 778             S p = null;
 779             Throwable exc = null;
 780             if (acc == null) {
 781                 try {
 782                     p = ctor.newInstance();
 783                 } catch (Throwable x) {
 784                     exc = x;
 785                 }
 786             } else {
 787                 PrivilegedExceptionAction&lt;S&gt; pa = new PrivilegedExceptionAction&lt;&gt;() {
 788                     @Override
 789                     public S run() throws Exception {
 790                         return ctor.newInstance();
 791                     }
 792                 };
 793                 // invoke constructor with permissions restricted by acc
 794                 try {
 795                     p = AccessController.doPrivileged(pa, acc);
 796                 } catch (Throwable x) {
 797                     if (x instanceof PrivilegedActionException)
 798                         x = x.getCause();
 799                     exc = x;
 800                 }
 801             }
 802             if (exc != null) {
 803                 if (exc instanceof InvocationTargetException)
 804                     exc = exc.getCause();
 805                 String cn = ctor.getDeclaringClass().getName();
 806                 fail(service,
 807                      &quot;Provider &quot; + cn + &quot; could not be instantiated&quot;, exc);
 808             }
 809             return p;
 810         }
 811 
 812         // For now, equals/hashCode uses the access control context to ensure
 813         // that two Providers created with different contexts are not equal
 814         // when running with a security manager.
 815 
 816         @Override
 817         public int hashCode() {
 818             return Objects.hash(service, type, acc);
 819         }
 820 
 821         @Override
 822         public boolean equals(Object ob) {
 823             if (!(ob instanceof ProviderImpl))
 824                 return false;
 825             @SuppressWarnings(&quot;unchecked&quot;)
 826             ProviderImpl&lt;?&gt; that = (ProviderImpl&lt;?&gt;)ob;
 827             return this.service == that.service
 828                     &amp;&amp; this.type == that.type
 829                     &amp;&amp; Objects.equals(this.acc, that.acc);
 830         }
 831     }
 832 
 833     /**
 834      * Loads a service provider in a module.
 835      *
 836      * Returns {@code null} if the service provider&#39;s module doesn&#39;t read
 837      * the module with the service type.
 838      *
 839      * @throws ServiceConfigurationError if the class cannot be loaded or
 840      *         isn&#39;t the expected sub-type (or doesn&#39;t define a provider
 841      *         factory method that returns the expected type)
 842      */
 843     private Provider&lt;S&gt; loadProvider(ServiceProvider provider) {
 844         Module module = provider.module();
 845         if (!module.canRead(service.getModule())) {
 846             // module does not read the module with the service type
 847             return null;
 848         }
 849 
 850         String cn = provider.providerName();
 851         Class&lt;?&gt; clazz = null;
 852         if (acc == null) {
 853             try {
 854                 clazz = Class.forName(module, cn);
 855             } catch (LinkageError e) {
 856                 fail(service, &quot;Unable to load &quot; + cn, e);
 857             }
 858         } else {
 859             PrivilegedExceptionAction&lt;Class&lt;?&gt;&gt; pa = () -&gt; Class.forName(module, cn);
 860             try {
 861                 clazz = AccessController.doPrivileged(pa);
 862             } catch (Throwable x) {
 863                 if (x instanceof PrivilegedActionException)
 864                     x = x.getCause();
 865                 fail(service, &quot;Unable to load &quot; + cn, x);
 866                 return null;
 867             }
 868         }
 869         if (clazz == null) {
 870             fail(service, &quot;Provider &quot; + cn + &quot; not found&quot;);
 871         }
 872 
 873         int mods = clazz.getModifiers();
 874         if (!Modifier.isPublic(mods)) {
 875             fail(service, clazz + &quot; is not public&quot;);
 876         }
 877 
 878         // if provider in explicit module then check for static factory method
 879         if (inExplicitModule(clazz)) {
 880             Method factoryMethod = findStaticProviderMethod(clazz);
 881             if (factoryMethod != null) {
 882                 Class&lt;?&gt; returnType = factoryMethod.getReturnType();
 883                 if (!service.isAssignableFrom(returnType)) {
 884                     fail(service, factoryMethod + &quot; return type not a subtype&quot;);
 885                 }
 886 
 887                 @SuppressWarnings(&quot;unchecked&quot;)
 888                 Class&lt;? extends S&gt; type = (Class&lt;? extends S&gt;) returnType;
 889                 return new ProviderImpl&lt;S&gt;(service, type, factoryMethod, acc);
 890             }
 891         }
 892 
 893         // no factory method so must be a subtype
 894         if (!service.isAssignableFrom(clazz)) {
 895             fail(service, clazz.getName() + &quot; not a subtype&quot;);
 896         }
 897 
 898         @SuppressWarnings(&quot;unchecked&quot;)
 899         Class&lt;? extends S&gt; type = (Class&lt;? extends S&gt;) clazz;
 900         @SuppressWarnings(&quot;unchecked&quot;)
 901         Constructor&lt;? extends S&gt; ctor = (Constructor&lt;? extends S&gt; ) getConstructor(clazz);
 902         return new ProviderImpl&lt;S&gt;(service, type, ctor, acc);
 903     }
 904 
 905     /**
 906      * Implements lazy service provider lookup of service providers that
 907      * are provided by modules in a module layer (or parent layers)
 908      */
 909     private final class LayerLookupIterator&lt;T&gt;
 910         implements Iterator&lt;Provider&lt;T&gt;&gt;
 911     {
 912         Deque&lt;ModuleLayer&gt; stack = new ArrayDeque&lt;&gt;();
 913         Set&lt;ModuleLayer&gt; visited = new HashSet&lt;&gt;();
 914         Iterator&lt;ServiceProvider&gt; iterator;
 915 
 916         Provider&lt;T&gt; nextProvider;
 917         ServiceConfigurationError nextError;
 918 
 919         LayerLookupIterator() {
 920             visited.add(layer);
 921             stack.push(layer);
 922         }
 923 
 924         private Iterator&lt;ServiceProvider&gt; providers(ModuleLayer layer) {
 925             ServicesCatalog catalog = LANG_ACCESS.getServicesCatalog(layer);
 926             return catalog.findServices(serviceName).iterator();
 927         }
 928 
 929         @Override
 930         public boolean hasNext() {
 931             while (nextProvider == null &amp;&amp; nextError == null) {
 932                 // get next provider to load
 933                 while (iterator == null || !iterator.hasNext()) {
 934                     // next layer (DFS order)
 935                     if (stack.isEmpty())
 936                         return false;
 937 
 938                     ModuleLayer layer = stack.pop();
 939                     List&lt;ModuleLayer&gt; parents = layer.parents();
 940                     for (int i = parents.size() - 1; i &gt;= 0; i--) {
 941                         ModuleLayer parent = parents.get(i);
 942                         if (visited.add(parent)) {
 943                             stack.push(parent);
 944                         }
 945                     }
 946                     iterator = providers(layer);
 947                 }
 948 
 949                 // attempt to load provider
 950                 ServiceProvider provider = iterator.next();
 951                 try {
 952                     @SuppressWarnings(&quot;unchecked&quot;)
 953                     Provider&lt;T&gt; next = (Provider&lt;T&gt;) loadProvider(provider);
 954                     nextProvider = next;
 955                 } catch (ServiceConfigurationError e) {
 956                     nextError = e;
 957                 }
 958             }
 959             return true;
 960         }
 961 
 962         @Override
 963         public Provider&lt;T&gt; next() {
 964             if (!hasNext())
 965                 throw new NoSuchElementException();
 966 
 967             Provider&lt;T&gt; provider = nextProvider;
 968             if (provider != null) {
 969                 nextProvider = null;
 970                 return provider;
 971             } else {
 972                 ServiceConfigurationError e = nextError;
 973                 assert e != null;
 974                 nextError = null;
 975                 throw e;
 976             }
 977         }
 978     }
 979 
 980     /**
 981      * Implements lazy service provider lookup of service providers that
 982      * are provided by modules defined to a class loader or to modules in
 983      * layers with a module defined to the class loader.
 984      */
 985     private final class ModuleServicesLookupIterator&lt;T&gt;
 986         implements Iterator&lt;Provider&lt;T&gt;&gt;
 987     {
 988         ClassLoader currentLoader;
 989         Iterator&lt;ServiceProvider&gt; iterator;
 990 
 991         Provider&lt;T&gt; nextProvider;
 992         ServiceConfigurationError nextError;
 993 
 994         ModuleServicesLookupIterator() {
 995             this.currentLoader = loader;
 996             this.iterator = iteratorFor(loader);
 997         }
 998 
 999         /**
1000          * Returns iterator to iterate over the implementations of {@code
1001          * service} in the given layer.
1002          */
1003         private List&lt;ServiceProvider&gt; providers(ModuleLayer layer) {
1004             ServicesCatalog catalog = LANG_ACCESS.getServicesCatalog(layer);
1005             return catalog.findServices(serviceName);
1006         }
1007 
1008         /**
1009          * Returns the class loader that a module is defined to
1010          */
1011         private ClassLoader loaderFor(Module module) {
1012             SecurityManager sm = System.getSecurityManager();
1013             if (sm == null) {
1014                 return module.getClassLoader();
1015             } else {
1016                 PrivilegedAction&lt;ClassLoader&gt; pa = module::getClassLoader;
1017                 return AccessController.doPrivileged(pa);
1018             }
1019         }
1020 
1021         /**
1022          * Returns an iterator to iterate over the implementations of {@code
1023          * service} in modules defined to the given class loader or in custom
1024          * layers with a module defined to this class loader.
1025          */
1026         private Iterator&lt;ServiceProvider&gt; iteratorFor(ClassLoader loader) {
1027             // modules defined to the class loader
1028             ServicesCatalog catalog;
1029             if (loader == null) {
1030                 catalog = BootLoader.getServicesCatalog();
1031             } else {
1032                 catalog = ServicesCatalog.getServicesCatalogOrNull(loader);
1033             }
1034             List&lt;ServiceProvider&gt; providers;
1035             if (catalog == null) {
1036                 providers = List.of();
1037             } else {
1038                 providers = catalog.findServices(serviceName);
1039             }
1040 
1041             // modules in layers that define modules to the class loader
1042             ClassLoader platformClassLoader = ClassLoaders.platformClassLoader();
1043             if (loader == null || loader == platformClassLoader) {
1044                 return providers.iterator();
1045             } else {
1046                 List&lt;ServiceProvider&gt; allProviders = new ArrayList&lt;&gt;(providers);
1047                 Iterator&lt;ModuleLayer&gt; iterator = LANG_ACCESS.layers(loader).iterator();
1048                 while (iterator.hasNext()) {
1049                     ModuleLayer layer = iterator.next();
1050                     for (ServiceProvider sp : providers(layer)) {
1051                         ClassLoader l = loaderFor(sp.module());
1052                         if (l != null &amp;&amp; l != platformClassLoader) {
1053                             allProviders.add(sp);
1054                         }
1055                     }
1056                 }
1057                 return allProviders.iterator();
1058             }
1059         }
1060 
1061         @Override
1062         public boolean hasNext() {
1063             while (nextProvider == null &amp;&amp; nextError == null) {
1064                 // get next provider to load
1065                 while (!iterator.hasNext()) {
1066                     if (currentLoader == null) {
1067                         return false;
1068                     } else {
1069                         currentLoader = currentLoader.getParent();
1070                         iterator = iteratorFor(currentLoader);
1071                     }
1072                 }
1073 
1074                 // attempt to load provider
1075                 ServiceProvider provider = iterator.next();
1076                 try {
1077                     @SuppressWarnings(&quot;unchecked&quot;)
1078                     Provider&lt;T&gt; next = (Provider&lt;T&gt;) loadProvider(provider);
1079                     nextProvider = next;
1080                 } catch (ServiceConfigurationError e) {
1081                     nextError = e;
1082                 }
1083             }
1084             return true;
1085         }
1086 
1087         @Override
1088         public Provider&lt;T&gt; next() {
1089             if (!hasNext())
1090                 throw new NoSuchElementException();
1091 
1092             Provider&lt;T&gt; provider = nextProvider;
1093             if (provider != null) {
1094                 nextProvider = null;
1095                 return provider;
1096             } else {
1097                 ServiceConfigurationError e = nextError;
1098                 assert e != null;
1099                 nextError = null;
1100                 throw e;
1101             }
1102         }
1103     }
1104 
1105     /**
1106      * Implements lazy service provider lookup where the service providers are
1107      * configured via service configuration files. Service providers in named
1108      * modules are silently ignored by this lookup iterator.
1109      */
1110     private final class LazyClassPathLookupIterator&lt;T&gt;
1111         implements Iterator&lt;Provider&lt;T&gt;&gt;
1112     {
1113         static final String PREFIX = &quot;META-INF/services/&quot;;
1114 
1115         Set&lt;String&gt; providerNames = new HashSet&lt;&gt;();  // to avoid duplicates
1116         Enumeration&lt;URL&gt; configs;
1117         Iterator&lt;String&gt; pending;
1118 
1119         Provider&lt;T&gt; nextProvider;
1120         ServiceConfigurationError nextError;
1121 
1122         LazyClassPathLookupIterator() { }
1123 
1124         /**
1125          * Parse a single line from the given configuration file, adding the
1126          * name on the line to set of names if not already seen.
1127          */
1128         private int parseLine(URL u, BufferedReader r, int lc, Set&lt;String&gt; names)
1129             throws IOException
1130         {
1131             String ln = r.readLine();
1132             if (ln == null) {
1133                 return -1;
1134             }
1135             int ci = ln.indexOf(&#39;#&#39;);
1136             if (ci &gt;= 0) ln = ln.substring(0, ci);
1137             ln = ln.trim();
1138             int n = ln.length();
1139             if (n != 0) {
1140                 if ((ln.indexOf(&#39; &#39;) &gt;= 0) || (ln.indexOf(&#39;\t&#39;) &gt;= 0))
1141                     fail(service, u, lc, &quot;Illegal configuration-file syntax&quot;);
1142                 int cp = ln.codePointAt(0);
1143                 if (!Character.isJavaIdentifierStart(cp))
1144                     fail(service, u, lc, &quot;Illegal provider-class name: &quot; + ln);
1145                 int start = Character.charCount(cp);
1146                 for (int i = start; i &lt; n; i += Character.charCount(cp)) {
1147                     cp = ln.codePointAt(i);
1148                     if (!Character.isJavaIdentifierPart(cp) &amp;&amp; (cp != &#39;.&#39;))
1149                         fail(service, u, lc, &quot;Illegal provider-class name: &quot; + ln);
1150                 }
1151                 if (providerNames.add(ln)) {
1152                     names.add(ln);
1153                 }
1154             }
1155             return lc + 1;
1156         }
1157 
1158         /**
1159          * Parse the content of the given URL as a provider-configuration file.
1160          */
1161         private Iterator&lt;String&gt; parse(URL u) {
1162             Set&lt;String&gt; names = new LinkedHashSet&lt;&gt;(); // preserve insertion order
1163             try {
1164                 URLConnection uc = u.openConnection();
1165                 uc.setUseCaches(false);
1166                 try (InputStream in = uc.getInputStream();
1167                      BufferedReader r
1168                          = new BufferedReader(new InputStreamReader(in, UTF_8.INSTANCE)))
1169                 {
1170                     int lc = 1;
1171                     while ((lc = parseLine(u, r, lc, names)) &gt;= 0);
1172                 }
1173             } catch (IOException x) {
1174                 fail(service, &quot;Error accessing configuration file&quot;, x);
1175             }
1176             return names.iterator();
1177         }
1178 
1179         /**
1180          * Loads and returns the next provider class.
1181          */
1182         private Class&lt;?&gt; nextProviderClass() {
1183             if (configs == null) {
1184                 try {
1185                     String fullName = PREFIX + service.getName();
1186                     if (loader == null) {
1187                         configs = ClassLoader.getSystemResources(fullName);
1188                     } else if (loader == ClassLoaders.platformClassLoader()) {
1189                         // The platform classloader doesn&#39;t have a class path,
1190                         // but the boot loader might.
1191                         if (BootLoader.hasClassPath()) {
1192                             configs = BootLoader.findResources(fullName);
1193                         } else {
1194                             configs = Collections.emptyEnumeration();
1195                         }
1196                     } else {
1197                         configs = loader.getResources(fullName);
1198                     }
1199                 } catch (IOException x) {
1200                     fail(service, &quot;Error locating configuration files&quot;, x);
1201                 }
1202             }
1203             while ((pending == null) || !pending.hasNext()) {
1204                 if (!configs.hasMoreElements()) {
1205                     return null;
1206                 }
1207                 pending = parse(configs.nextElement());
1208             }
1209             String cn = pending.next();
1210             try {
1211                 return Class.forName(cn, false, loader);
1212             } catch (ClassNotFoundException x) {
1213                 fail(service, &quot;Provider &quot; + cn + &quot; not found&quot;);
1214                 return null;
1215             }
1216         }
1217 
1218         @SuppressWarnings(&quot;unchecked&quot;)
1219         private boolean hasNextService() {
1220             while (nextProvider == null &amp;&amp; nextError == null) {
1221                 try {
1222                     Class&lt;?&gt; clazz = nextProviderClass();
1223                     if (clazz == null)
1224                         return false;
1225 
1226                     if (clazz.getModule().isNamed()) {
1227                         // ignore class if in named module
1228                         continue;
1229                     }
1230 
1231                     if (service.isAssignableFrom(clazz)) {
1232                         Class&lt;? extends S&gt; type = (Class&lt;? extends S&gt;) clazz;
1233                         Constructor&lt;? extends S&gt; ctor
1234                             = (Constructor&lt;? extends S&gt;)getConstructor(clazz);
1235                         ProviderImpl&lt;S&gt; p = new ProviderImpl&lt;S&gt;(service, type, ctor, acc);
1236                         nextProvider = (ProviderImpl&lt;T&gt;) p;
1237                     } else {
1238                         fail(service, clazz.getName() + &quot; not a subtype&quot;);
1239                     }
1240                 } catch (ServiceConfigurationError e) {
1241                     nextError = e;
1242                 }
1243             }
1244             return true;
1245         }
1246 
1247         private Provider&lt;T&gt; nextService() {
1248             if (!hasNextService())
1249                 throw new NoSuchElementException();
1250 
1251             Provider&lt;T&gt; provider = nextProvider;
1252             if (provider != null) {
1253                 nextProvider = null;
1254                 return provider;
1255             } else {
1256                 ServiceConfigurationError e = nextError;
1257                 assert e != null;
1258                 nextError = null;
1259                 throw e;
1260             }
1261         }
1262 
1263         @Override
1264         public boolean hasNext() {
1265             if (acc == null) {
1266                 return hasNextService();
1267             } else {
1268                 PrivilegedAction&lt;Boolean&gt; action = new PrivilegedAction&lt;&gt;() {
1269                     public Boolean run() { return hasNextService(); }
1270                 };
1271                 return AccessController.doPrivileged(action, acc);
1272             }
1273         }
1274 
1275         @Override
1276         public Provider&lt;T&gt; next() {
1277             if (acc == null) {
1278                 return nextService();
1279             } else {
1280                 PrivilegedAction&lt;Provider&lt;T&gt;&gt; action = new PrivilegedAction&lt;&gt;() {
1281                     public Provider&lt;T&gt; run() { return nextService(); }
1282                 };
1283                 return AccessController.doPrivileged(action, acc);
1284             }
1285         }
1286     }
1287 
1288     /**
1289      * Returns a new lookup iterator.
1290      */
1291     private Iterator&lt;Provider&lt;S&gt;&gt; newLookupIterator() {
1292         assert layer == null || loader == null;
1293         if (layer != null) {
1294             return new LayerLookupIterator&lt;&gt;();
1295         } else {
1296             Iterator&lt;Provider&lt;S&gt;&gt; first = new ModuleServicesLookupIterator&lt;&gt;();
1297             Iterator&lt;Provider&lt;S&gt;&gt; second = new LazyClassPathLookupIterator&lt;&gt;();
1298             return new Iterator&lt;Provider&lt;S&gt;&gt;() {
1299                 @Override
1300                 public boolean hasNext() {
1301                     return (first.hasNext() || second.hasNext());
1302                 }
1303                 @Override
1304                 public Provider&lt;S&gt; next() {
1305                     if (first.hasNext()) {
1306                         return first.next();
1307                     } else if (second.hasNext()) {
1308                         return second.next();
1309                     } else {
1310                         throw new NoSuchElementException();
1311                     }
1312                 }
1313             };
1314         }
1315     }
1316 
1317     /**
1318      * Returns an iterator to lazily load and instantiate the available
1319      * providers of this loader&#39;s service.
1320      *
1321      * &lt;p&gt; To achieve laziness the actual work of locating and instantiating
1322      * providers is done by the iterator itself. Its {@link Iterator#hasNext
1323      * hasNext} and {@link Iterator#next next} methods can therefore throw a
1324      * {@link ServiceConfigurationError} for any of the reasons specified in
1325      * the &lt;a href=&quot;#errors&quot;&gt;Errors&lt;/a&gt; section above. To write robust code it
1326      * is only necessary to catch {@code ServiceConfigurationError} when using
1327      * the iterator. If an error is thrown then subsequent invocations of the
1328      * iterator will make a best effort to locate and instantiate the next
1329      * available provider, but in general such recovery cannot be guaranteed.
1330      *
1331      * &lt;p&gt; Caching: The iterator returned by this method first yields all of
1332      * the elements of the provider cache, in the order that they were loaded.
1333      * It then lazily loads and instantiates any remaining service providers,
1334      * adding each one to the cache in turn. If this loader&#39;s provider caches are
1335      * cleared by invoking the {@link #reload() reload} method then existing
1336      * iterators for this service loader should be discarded.
1337      * The {@code  hasNext} and {@code next} methods of the iterator throw {@link
1338      * java.util.ConcurrentModificationException ConcurrentModificationException}
1339      * if used after the provider cache has been cleared.
1340      *
1341      * &lt;p&gt; The iterator returned by this method does not support removal.
1342      * Invoking its {@link java.util.Iterator#remove() remove} method will
1343      * cause an {@link UnsupportedOperationException} to be thrown.
1344      *
1345      * @apiNote Throwing an error in these cases may seem extreme.  The rationale
1346      * for this behavior is that a malformed provider-configuration file, like a
1347      * malformed class file, indicates a serious problem with the way the Java
1348      * virtual machine is configured or is being used.  As such it is preferable
1349      * to throw an error rather than try to recover or, even worse, fail silently.
1350      *
1351      * @return  An iterator that lazily loads providers for this loader&#39;s
1352      *          service
1353      *
1354      * @revised 9
1355      * @spec JPMS
1356      */
1357     public Iterator&lt;S&gt; iterator() {
1358 
1359         // create lookup iterator if needed
1360         if (lookupIterator1 == null) {
1361             lookupIterator1 = newLookupIterator();
1362         }
1363 
1364         return new Iterator&lt;S&gt;() {
1365 
1366             // record reload count
1367             final int expectedReloadCount = ServiceLoader.this.reloadCount;
1368 
1369             // index into the cached providers list
1370             int index;
1371 
1372             /**
1373              * Throws ConcurrentModificationException if the list of cached
1374              * providers has been cleared by reload.
1375              */
1376             private void checkReloadCount() {
1377                 if (ServiceLoader.this.reloadCount != expectedReloadCount)
1378                     throw new ConcurrentModificationException();
1379             }
1380 
1381             @Override
1382             public boolean hasNext() {
1383                 checkReloadCount();
1384                 if (index &lt; instantiatedProviders.size())
1385                     return true;
1386                 return lookupIterator1.hasNext();
1387             }
1388 
1389             @Override
1390             public S next() {
1391                 checkReloadCount();
1392                 S next;
1393                 if (index &lt; instantiatedProviders.size()) {
1394                     next = instantiatedProviders.get(index);
1395                 } else {
1396                     next = lookupIterator1.next().get();
1397                     instantiatedProviders.add(next);
1398                 }
1399                 index++;
1400                 return next;
1401             }
1402 
1403         };
1404     }
1405 
1406     /**
1407      * Returns a stream to lazily load available providers of this loader&#39;s
1408      * service. The stream elements are of type {@link Provider Provider}, the
1409      * {@code Provider}&#39;s {@link Provider#get() get} method must be invoked to
1410      * get or instantiate the provider.
1411      *
1412      * &lt;p&gt; To achieve laziness the actual work of locating providers is done
1413      * when processing the stream. If a service provider cannot be loaded for any
1414      * of the reasons specified in the &lt;a href=&quot;#errors&quot;&gt;Errors&lt;/a&gt; section
1415      * above then {@link ServiceConfigurationError} is thrown by whatever method
1416      * caused the service provider to be loaded. &lt;/p&gt;
1417      *
1418      * &lt;p&gt; Caching: When processing the stream then providers that were previously
1419      * loaded by stream operations are processed first, in load order. It then
1420      * lazily loads any remaining service providers. If this loader&#39;s provider
1421      * caches are cleared by invoking the {@link #reload() reload} method then
1422      * existing streams for this service loader should be discarded. The returned
1423      * stream&#39;s source {@link Spliterator spliterator} is &lt;em&gt;fail-fast&lt;/em&gt; and
1424      * will throw {@link ConcurrentModificationException} if the provider cache
1425      * has been cleared. &lt;/p&gt;
1426      *
1427      * &lt;p&gt; The following examples demonstrate usage. The first example creates
1428      * a stream of {@code CodecFactory} objects, the second example is the same
1429      * except that it sorts the providers by provider class name (and so locate
1430      * all providers).
1431      * &lt;pre&gt;{@code
1432      *    Stream&lt;CodecFactory&gt; providers = ServiceLoader.load(CodecFactory.class)
1433      *            .stream()
1434      *            .map(Provider::get);
1435      *
1436      *    Stream&lt;CodecFactory&gt; providers = ServiceLoader.load(CodecFactory.class)
1437      *            .stream()
1438      *            .sorted(Comparator.comparing(p -&gt; p.type().getName()))
1439      *            .map(Provider::get);
1440      * }&lt;/pre&gt;
1441      *
1442      * @return  A stream that lazily loads providers for this loader&#39;s service
1443      *
1444      * @since 9
1445      * @spec JPMS
1446      */
1447     public Stream&lt;Provider&lt;S&gt;&gt; stream() {
1448         // use cached providers as the source when all providers loaded
1449         if (loadedAllProviders) {
1450             return loadedProviders.stream();
1451         }
1452 
1453         // create lookup iterator if needed
1454         if (lookupIterator2 == null) {
1455             lookupIterator2 = newLookupIterator();
1456         }
1457 
1458         // use lookup iterator and cached providers as source
1459         Spliterator&lt;Provider&lt;S&gt;&gt; s = new ProviderSpliterator&lt;&gt;(lookupIterator2);
1460         return StreamSupport.stream(s, false);
1461     }
1462 
1463     private class ProviderSpliterator&lt;T&gt; implements Spliterator&lt;Provider&lt;T&gt;&gt; {
1464         final int expectedReloadCount = ServiceLoader.this.reloadCount;
1465         final Iterator&lt;Provider&lt;T&gt;&gt; iterator;
1466         int index;
1467 
1468         ProviderSpliterator(Iterator&lt;Provider&lt;T&gt;&gt; iterator) {
1469             this.iterator = iterator;
1470         }
1471 
1472         @Override
1473         public Spliterator&lt;Provider&lt;T&gt;&gt; trySplit() {
1474             return null;
1475         }
1476 
1477         @Override
1478         @SuppressWarnings(&quot;unchecked&quot;)
1479         public boolean tryAdvance(Consumer&lt;? super Provider&lt;T&gt;&gt; action) {
1480             if (ServiceLoader.this.reloadCount != expectedReloadCount)
1481                 throw new ConcurrentModificationException();
1482             Provider&lt;T&gt; next = null;
1483             if (index &lt; loadedProviders.size()) {
1484                 next = (Provider&lt;T&gt;) loadedProviders.get(index++);
1485             } else if (iterator.hasNext()) {
1486                 next = iterator.next();
1487                 loadedProviders.add((Provider&lt;S&gt;)next);
1488                 index++;
1489             } else {
1490                 loadedAllProviders = true;
1491             }
1492             if (next != null) {
1493                 action.accept(next);
1494                 return true;
1495             } else {
1496                 return false;
1497             }
1498         }
1499 
1500         @Override
1501         public int characteristics() {
1502             // not IMMUTABLE as structural interference possible
1503             // not NOTNULL so that the characteristics are a subset of the
1504             // characteristics when all Providers have been located.
1505             return Spliterator.ORDERED;
1506         }
1507 
1508         @Override
1509         public long estimateSize() {
1510             return Long.MAX_VALUE;
1511         }
1512     }
1513 
1514     /**
1515      * Creates a new service loader for the given service type, class
1516      * loader, and caller.
1517      *
1518      * @param  &lt;S&gt; the class of the service type
1519      *
1520      * @param  service
1521      *         The interface or abstract class representing the service
1522      *
1523      * @param  loader
1524      *         The class loader to be used to load provider-configuration files
1525      *         and provider classes, or {@code null} if the system class
1526      *         loader (or, failing that, the bootstrap class loader) is to be
1527      *         used
1528      *
1529      * @param  callerModule
1530      *         The caller&#39;s module for which a new service loader is created
1531      *
1532      * @return A new service loader
1533      */
1534     static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service,
1535                                      ClassLoader loader,
1536                                      Module callerModule)
1537     {
1538         return new ServiceLoader&lt;&gt;(callerModule, service, loader);
1539     }
1540 
1541     /**
1542      * Creates a new service loader for the given service. The service loader
1543      * uses the given class loader as the starting point to locate service
1544      * providers for the service. The service loader&#39;s {@link #iterator()
1545      * iterator} and {@link #stream() stream} locate providers in both named
1546      * and unnamed modules, as follows:
1547      *
1548      * &lt;ul&gt;
1549      *   &lt;li&gt; &lt;p&gt; Step 1: Locate providers in named modules. &lt;/p&gt;
1550      *
1551      *   &lt;p&gt; Service providers are located in all named modules of the class
1552      *   loader or to any class loader reachable via parent delegation. &lt;/p&gt;
1553      *
1554      *   &lt;p&gt; In addition, if the class loader is not the bootstrap or {@linkplain
1555      *   ClassLoader#getPlatformClassLoader() platform class loader}, then service
1556      *   providers may be located in the named modules of other class loaders.
1557      *   Specifically, if the class loader, or any class loader reachable via
1558      *   parent delegation, has a module in a {@linkplain ModuleLayer module
1559      *   layer}, then service providers in all modules in the module layer are
1560      *   located.  &lt;/p&gt;
1561      *
1562      *   &lt;p&gt; For example, suppose there is a module layer where each module is
1563      *   in its own class loader (see {@link ModuleLayer#defineModulesWithManyLoaders
1564      *   defineModulesWithManyLoaders}). If this {@code ServiceLoader.load} method
1565      *   is invoked to locate providers using any of the class loaders created for
1566      *   the module layer, then it will locate all of the providers in the module
1567      *   layer, irrespective of their defining class loader. &lt;/p&gt;
1568      *
1569      *   &lt;p&gt; Ordering: The service loader will first locate any service providers
1570      *   in modules defined to the class loader, then its parent class loader,
1571      *   its parent parent, and so on to the bootstrap class loader. If a class
1572      *   loader has modules in a module layer then all providers in that module
1573      *   layer are located (irrespective of their class loader) before the
1574      *   providers in the parent class loader are located. The ordering of
1575      *   modules in same class loader, or the ordering of modules in a module
1576      *   layer, is not defined. &lt;/p&gt;
1577      *
1578      *   &lt;p&gt; If a module declares more than one provider then the providers
1579      *   are located in the order that its module descriptor {@linkplain
1580      *   java.lang.module.ModuleDescriptor.Provides#providers() lists the
1581      *   providers}. Providers added dynamically by instrumentation agents (see
1582      *   {@link java.lang.instrument.Instrumentation#redefineModule redefineModule})
1583      *   are always located after providers declared by the module. &lt;/p&gt; &lt;/li&gt;
1584      *
1585      *   &lt;li&gt; &lt;p&gt; Step 2: Locate providers in unnamed modules. &lt;/p&gt;
1586      *
1587      *   &lt;p&gt; Service providers in unnamed modules are located if their class names
1588      *   are listed in provider-configuration files located by the class loader&#39;s
1589      *   {@link ClassLoader#getResources(String) getResources} method. &lt;/p&gt;
1590      *
1591      *   &lt;p&gt; The ordering is based on the order that the class loader&#39;s {@code
1592      *   getResources} method finds the service configuration files and within
1593      *   that, the order that the class names are listed in the file. &lt;/p&gt;
1594      *
1595      *   &lt;p&gt; In a provider-configuration file, any mention of a service provider
1596      *   that is deployed in a named module is ignored. This is to avoid
1597      *   duplicates that would otherwise arise when a named module has both a
1598      *   &lt;i&gt;provides&lt;/i&gt; directive and a provider-configuration file that mention
1599      *   the same service provider. &lt;/p&gt;
1600      *
1601      *   &lt;p&gt; The provider class must be visible to the class loader. &lt;/p&gt; &lt;/li&gt;
1602      *
1603      * &lt;/ul&gt;
1604      *
1605      * @apiNote If the class path of the class loader includes remote network
1606      * URLs then those URLs may be dereferenced in the process of searching for
1607      * provider-configuration files.
1608      *
1609      * &lt;p&gt; This activity is normal, although it may cause puzzling entries to be
1610      * created in web-server logs.  If a web server is not configured correctly,
1611      * however, then this activity may cause the provider-loading algorithm to fail
1612      * spuriously.
1613      *
1614      * &lt;p&gt; A web server should return an HTTP 404 (Not Found) response when a
1615      * requested resource does not exist.  Sometimes, however, web servers are
1616      * erroneously configured to return an HTTP 200 (OK) response along with a
1617      * helpful HTML error page in such cases.  This will cause a {@link
1618      * ServiceConfigurationError} to be thrown when this class attempts to parse
1619      * the HTML page as a provider-configuration file.  The best solution to this
1620      * problem is to fix the misconfigured web server to return the correct
1621      * response code (HTTP 404) along with the HTML error page.
1622      *
1623      * @param  &lt;S&gt; the class of the service type
1624      *
1625      * @param  service
1626      *         The interface or abstract class representing the service
1627      *
1628      * @param  loader
1629      *         The class loader to be used to load provider-configuration files
1630      *         and provider classes, or {@code null} if the system class
1631      *         loader (or, failing that, the bootstrap class loader) is to be
1632      *         used
1633      *
1634      * @return A new service loader
1635      *
1636      * @throws ServiceConfigurationError
1637      *         if the service type is not accessible to the caller or the
1638      *         caller is in an explicit module and its module descriptor does
1639      *         not declare that it uses {@code service}
1640      *
1641      * @revised 9
1642      * @spec JPMS
1643      */
1644     @CallerSensitive
1645     public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service,
1646                                             ClassLoader loader)
1647     {
1648         return new ServiceLoader&lt;&gt;(Reflection.getCallerClass(), service, loader);
1649     }
1650 
1651     /**
1652      * Creates a new service loader for the given service type, using the
1653      * current thread&#39;s {@linkplain java.lang.Thread#getContextClassLoader
1654      * context class loader}.
1655      *
1656      * &lt;p&gt; An invocation of this convenience method of the form
1657      * &lt;pre&gt;{@code
1658      *     ServiceLoader.load(service)
1659      * }&lt;/pre&gt;
1660      *
1661      * is equivalent to
1662      *
1663      * &lt;pre&gt;{@code
1664      *     ServiceLoader.load(service, Thread.currentThread().getContextClassLoader())
1665      * }&lt;/pre&gt;
1666      *
1667      * @apiNote Service loader objects obtained with this method should not be
1668      * cached VM-wide. For example, different applications in the same VM may
1669      * have different thread context class loaders. A lookup by one application
1670      * may locate a service provider that is only visible via its thread
1671      * context class loader and so is not suitable to be located by the other
1672      * application. Memory leaks can also arise. A thread local may be suited
1673      * to some applications.
1674      *
1675      * @param  &lt;S&gt; the class of the service type
1676      *
1677      * @param  service
1678      *         The interface or abstract class representing the service
1679      *
1680      * @return A new service loader
1681      *
1682      * @throws ServiceConfigurationError
1683      *         if the service type is not accessible to the caller or the
1684      *         caller is in an explicit module and its module descriptor does
1685      *         not declare that it uses {@code service}
1686      *
1687      * @revised 9
1688      * @spec JPMS
1689      */
1690     @CallerSensitive
1691     public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service) {
1692         ClassLoader cl = Thread.currentThread().getContextClassLoader();
1693         return new ServiceLoader&lt;&gt;(Reflection.getCallerClass(), service, cl);
1694     }
1695 
1696     /**
1697      * Creates a new service loader for the given service type, using the
1698      * {@linkplain ClassLoader#getPlatformClassLoader() platform class loader}.
1699      *
1700      * &lt;p&gt; This convenience method is equivalent to: &lt;/p&gt;
1701      *
1702      * &lt;pre&gt;{@code
1703      *     ServiceLoader.load(service, ClassLoader.getPlatformClassLoader())
1704      * }&lt;/pre&gt;
1705      *
1706      * &lt;p&gt; This method is intended for use when only installed providers are
1707      * desired.  The resulting service will only find and load providers that
1708      * have been installed into the current Java virtual machine; providers on
1709      * the application&#39;s module path or class path will be ignored.
1710      *
1711      * @param  &lt;S&gt; the class of the service type
1712      *
1713      * @param  service
1714      *         The interface or abstract class representing the service
1715      *
1716      * @return A new service loader
1717      *
1718      * @throws ServiceConfigurationError
1719      *         if the service type is not accessible to the caller or the
1720      *         caller is in an explicit module and its module descriptor does
1721      *         not declare that it uses {@code service}
1722      *
1723      * @revised 9
1724      * @spec JPMS
1725      */
1726     @CallerSensitive
1727     public static &lt;S&gt; ServiceLoader&lt;S&gt; loadInstalled(Class&lt;S&gt; service) {
1728         ClassLoader cl = ClassLoader.getPlatformClassLoader();
1729         return new ServiceLoader&lt;&gt;(Reflection.getCallerClass(), service, cl);
1730     }
1731 
1732     /**
1733      * Creates a new service loader for the given service type to load service
1734      * providers from modules in the given module layer and its ancestors. It
1735      * does not locate providers in unnamed modules. The ordering that the service
1736      * loader&#39;s {@link #iterator() iterator} and {@link #stream() stream} locate
1737      * providers and yield elements is as follows:
1738      *
1739      * &lt;ul&gt;
1740      *   &lt;li&gt;&lt;p&gt; Providers are located in a module layer before locating providers
1741      *   in parent layers. Traversal of parent layers is depth-first with each
1742      *   layer visited at most once. For example, suppose L0 is the boot layer, L1
1743      *   and L2 are modules layers with L0 as their parent. Now suppose that L3 is
1744      *   created with L1 and L2 as the parents (in that order). Using a service
1745      *   loader to locate providers with L3 as the context will locate providers
1746      *   in the following order: L3, L1, L0, L2. &lt;/p&gt;&lt;/li&gt;
1747      *
1748      *   &lt;li&gt;&lt;p&gt; If a module declares more than one provider then the providers
1749      *   are located in the order that its module descriptor
1750      *   {@linkplain java.lang.module.ModuleDescriptor.Provides#providers()
1751      *   lists the providers}. Providers added dynamically by instrumentation
1752      *   agents are always located after providers declared by the module. &lt;/p&gt;&lt;/li&gt;
1753      *
1754      *   &lt;li&gt;&lt;p&gt; The ordering of modules in a module layer is not defined. &lt;/p&gt;&lt;/li&gt;
1755      * &lt;/ul&gt;
1756      *
1757      * @apiNote Unlike the other load methods defined here, the service type
1758      * is the second parameter. The reason for this is to avoid source
1759      * compatibility issues for code that uses {@code load(S, null)}.
1760      *
1761      * @param  &lt;S&gt; the class of the service type
1762      *
1763      * @param  layer
1764      *         The module layer
1765      *
1766      * @param  service
1767      *         The interface or abstract class representing the service
1768      *
1769      * @return A new service loader
1770      *
1771      * @throws ServiceConfigurationError
1772      *         if the service type is not accessible to the caller or the
1773      *         caller is in an explicit module and its module descriptor does
1774      *         not declare that it uses {@code service}
1775      *
1776      * @since 9
1777      * @spec JPMS
1778      */
1779     @CallerSensitive
1780     public static &lt;S&gt; ServiceLoader&lt;S&gt; load(ModuleLayer layer, Class&lt;S&gt; service) {
1781         return new ServiceLoader&lt;&gt;(Reflection.getCallerClass(), layer, service);
1782     }
1783 
1784     /**
1785      * Load the first available service provider of this loader&#39;s service. This
1786      * convenience method is equivalent to invoking the {@link #iterator()
1787      * iterator()} method and obtaining the first element. It therefore
1788      * returns the first element from the provider cache if possible, it
1789      * otherwise attempts to load and instantiate the first provider.
1790      *
1791      * &lt;p&gt; The following example loads the first available service provider. If
1792      * no service providers are located then it uses a default implementation.
1793      * &lt;pre&gt;{@code
1794      *    CodecFactory factory = ServiceLoader.load(CodecFactory.class)
1795      *                                        .findFirst()
1796      *                                        .orElse(DEFAULT_CODECSET_FACTORY);
1797      * }&lt;/pre&gt;
1798      * @return The first service provider or empty {@code Optional} if no
1799      *         service providers are located
1800      *
1801      * @throws ServiceConfigurationError
1802      *         If a provider class cannot be loaded for any of the reasons
1803      *         specified in the &lt;a href=&quot;#errors&quot;&gt;Errors&lt;/a&gt; section above.
1804      *
1805      * @since 9
1806      * @spec JPMS
1807      */
1808     public Optional&lt;S&gt; findFirst() {
1809         Iterator&lt;S&gt; iterator = iterator();
1810         if (iterator.hasNext()) {
1811             return Optional.of(iterator.next());
1812         } else {
1813             return Optional.empty();
1814         }
1815     }
1816 
1817     /**
1818      * Clear this loader&#39;s provider cache so that all providers will be
1819      * reloaded.
1820      *
1821      * &lt;p&gt; After invoking this method, subsequent invocations of the {@link
1822      * #iterator() iterator} or {@link #stream() stream} methods will lazily
1823      * locate providers (and instantiate in the case of {@code iterator})
1824      * from scratch, just as is done by a newly-created service loader.
1825      *
1826      * &lt;p&gt; This method is intended for use in situations in which new service
1827      * providers can be installed into a running Java virtual machine.
1828      */
1829     public void reload() {
1830         lookupIterator1 = null;
1831         instantiatedProviders.clear();
1832 
1833         lookupIterator2 = null;
1834         loadedProviders.clear();
1835         loadedAllProviders = false;
1836 
1837         // increment count to allow CME be thrown
1838         reloadCount++;
1839     }
1840 
1841     /**
1842      * Returns a string describing this service.
1843      *
1844      * @return  A descriptive string
1845      */
1846     public String toString() {
1847         return &quot;java.util.ServiceLoader[&quot; + service.getName() + &quot;]&quot;;
1848     }
1849 
1850 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/net/URL.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1995, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.net;
  27 
  28 import java.io.File;
  29 import java.io.IOException;
  30 import java.io.InputStream;
  31 import java.net.spi.URLStreamHandlerProvider;
  32 import java.nio.file.Path;
  33 import java.security.AccessController;
  34 import java.security.PrivilegedAction;
  35 import java.util.Hashtable;
  36 import java.io.InvalidObjectException;
  37 import java.io.ObjectStreamException;
  38 import java.io.ObjectStreamField;
  39 import java.io.ObjectInputStream.GetField;
  40 import java.util.Iterator;
  41 import java.util.Locale;
  42 import java.util.NoSuchElementException;
  43 import java.util.ServiceConfigurationError;
  44 import java.util.ServiceLoader;
  45 
  46 import jdk.internal.access.JavaNetURLAccess;
  47 import jdk.internal.access.SharedSecrets;
  48 import jdk.internal.misc.VM;
  49 import sun.net.util.IPAddressUtil;
  50 import sun.security.util.SecurityConstants;
  51 import sun.security.action.GetPropertyAction;
  52 
  53 /**
  54  * Class {@code URL} represents a Uniform Resource
  55  * Locator, a pointer to a &quot;resource&quot; on the World
  56  * Wide Web. A resource can be something as simple as a file or a
  57  * directory, or it can be a reference to a more complicated object,
  58  * such as a query to a database or to a search engine. More
  59  * information on the types of URLs and their formats can be found at:
  60  * &lt;a href=
  61  * &quot;http://web.archive.org/web/20051219043731/http://archive.ncsa.uiuc.edu/SDG/Software/Mosaic/Demo/url-primer.html&quot;&gt;
  62  * &lt;i&gt;Types of URL&lt;/i&gt;&lt;/a&gt;
  63  * &lt;p&gt;
  64  * In general, a URL can be broken into several parts. Consider the
  65  * following example:
  66  * &lt;blockquote&gt;&lt;pre&gt;
  67  *     http://www.example.com/docs/resource1.html
  68  * &lt;/pre&gt;&lt;/blockquote&gt;
  69  * &lt;p&gt;
  70  * The URL above indicates that the protocol to use is
  71  * {@code http} (HyperText Transfer Protocol) and that the
  72  * information resides on a host machine named
  73  * {@code www.example.com}. The information on that host
  74  * machine is named {@code /docs/resource1.html}. The exact
  75  * meaning of this name on the host machine is both protocol
  76  * dependent and host dependent. The information normally resides in
  77  * a file, but it could be generated on the fly. This component of
  78  * the URL is called the &lt;i&gt;path&lt;/i&gt; component.
  79  * &lt;p&gt;
  80  * A URL can optionally specify a &quot;port&quot;, which is the
  81  * port number to which the TCP connection is made on the remote host
  82  * machine. If the port is not specified, the default port for
  83  * the protocol is used instead. For example, the default port for
  84  * {@code http} is {@code 80}. An alternative port could be
  85  * specified as:
  86  * &lt;blockquote&gt;&lt;pre&gt;
  87  *     http://www.example.com:1080/docs/resource1.html
  88  * &lt;/pre&gt;&lt;/blockquote&gt;
  89  * &lt;p&gt;
  90  * The syntax of {@code URL} is defined by  &lt;a
  91  * href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2396: Uniform
  92  * Resource Identifiers (URI): Generic Syntax&lt;/i&gt;&lt;/a&gt;, amended by &lt;a
  93  * href=&quot;http://www.ietf.org/rfc/rfc2732.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2732: Format for
  94  * Literal IPv6 Addresses in URLs&lt;/i&gt;&lt;/a&gt;. The Literal IPv6 address format
  95  * also supports scope_ids. The syntax and usage of scope_ids is described
  96  * &lt;a href=&quot;Inet6Address.html#scoped&quot;&gt;here&lt;/a&gt;.
  97  * &lt;p&gt;
  98  * A URL may have appended to it a &quot;fragment&quot;, also known
  99  * as a &quot;ref&quot; or a &quot;reference&quot;. The fragment is indicated by the sharp
 100  * sign character &quot;#&quot; followed by more characters. For example,
 101  * &lt;blockquote&gt;&lt;pre&gt;
 102  *     http://www.example.com/index.html#chapter1
 103  * &lt;/pre&gt;&lt;/blockquote&gt;
 104  * &lt;p&gt;
 105  * This fragment is not technically part of the URL. Rather, it
 106  * indicates that after the specified resource is retrieved, the
 107  * application is specifically interested in that part of the
 108  * document that has the tag {@code chapter1} attached to it. The
 109  * meaning of a tag is resource specific.
 110  * &lt;p&gt;
 111  * An application can also specify a &quot;relative URL&quot;,
 112  * which contains only enough information to reach the resource
 113  * relative to another URL. Relative URLs are frequently used within
 114  * HTML pages. For example, if the contents of the URL:
 115  * &lt;blockquote&gt;&lt;pre&gt;
 116  *     http://www.example.com/index.html
 117  * &lt;/pre&gt;&lt;/blockquote&gt;
 118  * contained within it the relative URL:
 119  * &lt;blockquote&gt;&lt;pre&gt;
 120  *     FAQ.html
 121  * &lt;/pre&gt;&lt;/blockquote&gt;
 122  * it would be a shorthand for:
 123  * &lt;blockquote&gt;&lt;pre&gt;
 124  *     http://www.example.com/FAQ.html
 125  * &lt;/pre&gt;&lt;/blockquote&gt;
 126  * &lt;p&gt;
 127  * The relative URL need not specify all the components of a URL. If
 128  * the protocol, host name, or port number is missing, the value is
 129  * inherited from the fully specified URL. The file component must be
 130  * specified. The optional fragment is not inherited.
 131  * &lt;p&gt;
 132  * The URL class does not itself encode or decode any URL components
 133  * according to the escaping mechanism defined in RFC2396. It is the
 134  * responsibility of the caller to encode any fields, which need to be
 135  * escaped prior to calling URL, and also to decode any escaped fields,
 136  * that are returned from URL. Furthermore, because URL has no knowledge
 137  * of URL escaping, it does not recognise equivalence between the encoded
 138  * or decoded form of the same URL. For example, the two URLs:&lt;br&gt;
 139  * &lt;pre&gt;    http://foo.com/hello world/ and http://foo.com/hello%20world&lt;/pre&gt;
 140  * would be considered not equal to each other.
 141  * &lt;p&gt;
 142  * Note, the {@link java.net.URI} class does perform escaping of its
 143  * component fields in certain circumstances. The recommended way
 144  * to manage the encoding and decoding of URLs is to use {@link java.net.URI},
 145  * and to convert between these two classes using {@link #toURI()} and
 146  * {@link URI#toURL()}.
 147  * &lt;p&gt;
 148  * The {@link URLEncoder} and {@link URLDecoder} classes can also be
 149  * used, but only for HTML form encoding, which is not the same
 150  * as the encoding scheme defined in RFC2396.
 151  *
 152  * @apiNote
 153  *
 154  * Applications working with file paths and file URIs should take great
 155  * care to use the appropriate methods to convert between the two.
 156  * The {@link Path#of(URI)} factory method and the {@link File#File(URI)}
 157  * constructor can be used to create {@link Path} or {@link File}
 158  * objects from a file URI. {@link Path#toUri()} and {@link File#toURI()}
 159  * can be used to create a {@link URI} from a file path, which can be
 160  * converted to URL using {@link URI#toURL()}.
 161  * Applications should never try to {@linkplain #URL(String, String, String)
 162  * construct} or {@linkplain #URL(String) parse} a {@code URL}
 163  * from the direct string representation of a {@code File} or {@code Path}
 164  * instance.
 165  * &lt;p&gt;
 166  * Some components of a URL or URI, such as &lt;i&gt;userinfo&lt;/i&gt;, may
 167  * be abused to construct misleading URLs or URIs. Applications
 168  * that deal with URLs or URIs should take into account
 169  * the recommendations advised in &lt;a
 170  * href=&quot;https://tools.ietf.org/html/rfc3986#section-7&quot;&gt;RFC3986,
 171  * Section 7, Security Considerations&lt;/a&gt;.
 172  *
 173  * @author  James Gosling
 174  * @since 1.0
 175  */
 176 public final class URL implements java.io.Serializable {
 177 
 178     static final String BUILTIN_HANDLERS_PREFIX = &quot;sun.net.www.protocol&quot;;
 179     @java.io.Serial
 180     static final long serialVersionUID = -7627629688361524110L;
 181 
 182     /**
 183      * The property which specifies the package prefix list to be scanned
 184      * for protocol handlers.  The value of this property (if any) should
 185      * be a vertical bar delimited list of package names to search through
 186      * for a protocol handler to load.  The policy of this class is that
 187      * all protocol handlers will be in a class called &lt;protocolname&gt;.Handler,
 188      * and each package in the list is examined in turn for a matching
 189      * handler.  If none are found (or the property is not specified), the
 190      * default package prefix, sun.net.www.protocol, is used.  The search
 191      * proceeds from the first package in the list to the last and stops
 192      * when a match is found.
 193      */
 194     private static final String protocolPathProp = &quot;java.protocol.handler.pkgs&quot;;
 195 
 196     /**
 197      * The protocol to use (ftp, http, nntp, ... etc.) .
 198      * @serial
 199      */
 200     private String protocol;
 201 
 202     /**
 203      * The host name to connect to.
 204      * @serial
 205      */
 206     private String host;
 207 
 208     /**
 209      * The protocol port to connect to.
 210      * @serial
 211      */
 212     private int port = -1;
 213 
 214     /**
 215      * The specified file name on that host. {@code file} is
 216      * defined as {@code path[?query]}
 217      * @serial
 218      */
 219     private String file;
 220 
 221     /**
 222      * The query part of this URL.
 223      */
 224     private transient String query;
 225 
 226     /**
 227      * The authority part of this URL.
 228      * @serial
 229      */
 230     private String authority;
 231 
 232     /**
 233      * The path part of this URL.
 234      */
 235     private transient String path;
 236 
 237     /**
 238      * The userinfo part of this URL.
 239      */
 240     private transient String userInfo;
 241 
 242     /**
 243      * # reference.
 244      * @serial
 245      */
 246     private String ref;
 247 
 248     /**
 249      * The host&#39;s IP address, used in equals and hashCode.
 250      * Computed on demand. An uninitialized or unknown hostAddress is null.
 251      */
 252     transient InetAddress hostAddress;
 253 
 254     /**
 255      * The URLStreamHandler for this URL.
 256      */
 257     transient URLStreamHandler handler;
 258 
 259     /* Our hash code.
 260      * @serial
 261      */
 262     private int hashCode = -1;
 263 
 264     private transient UrlDeserializedState tempState;
 265 
 266     /**
 267      * Creates a {@code URL} object from the specified
 268      * {@code protocol}, {@code host}, {@code port}
 269      * number, and {@code file}.&lt;p&gt;
 270      *
 271      * {@code host} can be expressed as a host name or a literal
 272      * IP address. If IPv6 literal address is used, it should be
 273      * enclosed in square brackets ({@code &#39;[&#39;} and {@code &#39;]&#39;}), as
 274      * specified by &lt;a
 275      * href=&quot;http://www.ietf.org/rfc/rfc2732.txt&quot;&gt;RFC&amp;nbsp;2732&lt;/a&gt;;
 276      * However, the literal IPv6 address format defined in &lt;a
 277      * href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2373: IP
 278      * Version 6 Addressing Architecture&lt;/i&gt;&lt;/a&gt; is also accepted.&lt;p&gt;
 279      *
 280      * Specifying a {@code port} number of {@code -1}
 281      * indicates that the URL should use the default port for the
 282      * protocol.&lt;p&gt;
 283      *
 284      * If this is the first URL object being created with the specified
 285      * protocol, a &lt;i&gt;stream protocol handler&lt;/i&gt; object, an instance of
 286      * class {@code URLStreamHandler}, is created for that protocol:
 287      * &lt;ol&gt;
 288      * &lt;li&gt;If the application has previously set up an instance of
 289      *     {@code URLStreamHandlerFactory} as the stream handler factory,
 290      *     then the {@code createURLStreamHandler} method of that instance
 291      *     is called with the protocol string as an argument to create the
 292      *     stream protocol handler.
 293      * &lt;li&gt;If no {@code URLStreamHandlerFactory} has yet been set up,
 294      *     or if the factory&#39;s {@code createURLStreamHandler} method
 295      *     returns {@code null}, then the {@linkplain java.util.ServiceLoader
 296      *     ServiceLoader} mechanism is used to locate {@linkplain
 297      *     java.net.spi.URLStreamHandlerProvider URLStreamHandlerProvider}
 298      *     implementations using the system class
 299      *     loader. The order that providers are located is implementation
 300      *     specific, and an implementation is free to cache the located
 301      *     providers. A {@linkplain java.util.ServiceConfigurationError
 302      *     ServiceConfigurationError}, {@code Error} or {@code RuntimeException}
 303      *     thrown from the {@code createURLStreamHandler}, if encountered, will
 304      *     be propagated to the calling thread. The {@code
 305      *     createURLStreamHandler} method of each provider, if instantiated, is
 306      *     invoked, with the protocol string, until a provider returns non-null,
 307      *     or all providers have been exhausted.
 308      * &lt;li&gt;If the previous step fails to find a protocol handler, the
 309      *     constructor reads the value of the system property:
 310      *     &lt;blockquote&gt;{@systemProperty
 311      *         java.protocol.handler.pkgs
 312      *     }&lt;/blockquote&gt;
 313      *     If the value of that system property is not {@code null},
 314      *     it is interpreted as a list of packages separated by a vertical
 315      *     slash character &#39;{@code |}&#39;. The constructor tries to load
 316      *     the class named:
 317      *     &lt;blockquote&gt;{@code
 318      *         &lt;package&gt;.&lt;protocol&gt;.Handler
 319      *     }&lt;/blockquote&gt;
 320      *     where {@code &lt;package&gt;} is replaced by the name of the package
 321      *     and {@code &lt;protocol&gt;} is replaced by the name of the protocol.
 322      *     If this class does not exist, or if the class exists but it is not
 323      *     a subclass of {@code URLStreamHandler}, then the next package
 324      *     in the list is tried.
 325      * &lt;li&gt;If the previous step fails to find a protocol handler, then the
 326      *     constructor tries to load a built-in protocol handler.
 327      *     If this class does not exist, or if the class exists but it is not a
 328      *     subclass of {@code URLStreamHandler}, then a
 329      *     {@code MalformedURLException} is thrown.
 330      * &lt;/ol&gt;
 331      *
 332      * &lt;p&gt;Protocol handlers for the following protocols are guaranteed
 333      * to exist on the search path:
 334      * &lt;ul&gt;
 335      * &lt;li&gt;{@code http}&lt;/li&gt;
 336      * &lt;li&gt;{@code https}&lt;/li&gt;
 337      * &lt;li&gt;{@code file}&lt;/li&gt;
 338      * &lt;li&gt;{@code jar}&lt;/li&gt;
 339      * &lt;/ul&gt;
 340      * Protocol handlers for additional protocols may also be  available.
 341      * Some protocol handlers, for example those used for loading platform
 342      * classes or classes on the class path, may not be overridden. The details
 343      * of such restrictions, and when those restrictions apply (during
 344      * initialization of the runtime for example), are implementation specific
 345      * and therefore not specified
 346      *
 347      * &lt;p&gt;No validation of the inputs is performed by this constructor.
 348      *
 349      * @param      protocol   the name of the protocol to use.
 350      * @param      host       the name of the host.
 351      * @param      port       the port number on the host.
 352      * @param      file       the file on the host
 353      * @throws     MalformedURLException  if an unknown protocol or the port
 354      *                  is a negative number other than -1
 355      * @see        java.lang.System#getProperty(java.lang.String)
 356      * @see        java.net.URL#setURLStreamHandlerFactory(
 357      *                  java.net.URLStreamHandlerFactory)
 358      * @see        java.net.URLStreamHandler
 359      * @see        java.net.URLStreamHandlerFactory#createURLStreamHandler(
 360      *                  java.lang.String)
 361      */
 362     public URL(String protocol, String host, int port, String file)
 363         throws MalformedURLException
 364     {
 365         this(protocol, host, port, file, null);
 366     }
 367 
 368     /**
 369      * Creates a URL from the specified {@code protocol}
 370      * name, {@code host} name, and {@code file} name. The
 371      * default port for the specified protocol is used.
 372      * &lt;p&gt;
 373      * This constructor is equivalent to the four-argument
 374      * constructor with the only difference of using the
 375      * default port for the specified protocol.
 376      *
 377      * No validation of the inputs is performed by this constructor.
 378      *
 379      * @param      protocol   the name of the protocol to use.
 380      * @param      host       the name of the host.
 381      * @param      file       the file on the host.
 382      * @throws     MalformedURLException  if an unknown protocol is specified.
 383      * @see        java.net.URL#URL(java.lang.String, java.lang.String,
 384      *                  int, java.lang.String)
 385      */
 386     public URL(String protocol, String host, String file)
 387             throws MalformedURLException {
 388         this(protocol, host, -1, file);
 389     }
 390 
 391     /**
 392      * Creates a {@code URL} object from the specified
 393      * {@code protocol}, {@code host}, {@code port}
 394      * number, {@code file}, and {@code handler}. Specifying
 395      * a {@code port} number of {@code -1} indicates that
 396      * the URL should use the default port for the protocol. Specifying
 397      * a {@code handler} of {@code null} indicates that the URL
 398      * should use a default stream handler for the protocol, as outlined
 399      * for:
 400      *     java.net.URL#URL(java.lang.String, java.lang.String, int,
 401      *                      java.lang.String)
 402      *
 403      * &lt;p&gt;If the handler is not null and there is a security manager,
 404      * the security manager&#39;s {@code checkPermission}
 405      * method is called with a
 406      * {@code NetPermission(&quot;specifyStreamHandler&quot;)} permission.
 407      * This may result in a SecurityException.
 408      *
 409      * No validation of the inputs is performed by this constructor.
 410      *
 411      * @param      protocol   the name of the protocol to use.
 412      * @param      host       the name of the host.
 413      * @param      port       the port number on the host.
 414      * @param      file       the file on the host
 415      * @param      handler    the stream handler for the URL.
 416      * @throws     MalformedURLException  if an unknown protocol or the port
<a name="2" id="anc2"></a><span class="line-modified"> 417      *                    is a negative number other than -1</span>
 418      * @throws     SecurityException
 419      *        if a security manager exists and its
 420      *        {@code checkPermission} method doesn&#39;t allow
 421      *        specifying a stream handler explicitly.
 422      * @see        java.lang.System#getProperty(java.lang.String)
 423      * @see        java.net.URL#setURLStreamHandlerFactory(
 424      *                  java.net.URLStreamHandlerFactory)
 425      * @see        java.net.URLStreamHandler
 426      * @see        java.net.URLStreamHandlerFactory#createURLStreamHandler(
 427      *                  java.lang.String)
 428      * @see        SecurityManager#checkPermission
 429      * @see        java.net.NetPermission
 430      */
 431     public URL(String protocol, String host, int port, String file,
 432                URLStreamHandler handler) throws MalformedURLException {
 433         if (handler != null) {
 434             SecurityManager sm = System.getSecurityManager();
 435             if (sm != null) {
 436                 // check for permission to specify a handler
 437                 checkSpecifyHandler(sm);
 438             }
 439         }
 440 
 441         protocol = toLowerCase(protocol);
 442         this.protocol = protocol;
 443         if (host != null) {
 444 
 445             /**
 446              * if host is a literal IPv6 address,
 447              * we will make it conform to RFC 2732
 448              */
 449             if (host.indexOf(&#39;:&#39;) &gt;= 0 &amp;&amp; !host.startsWith(&quot;[&quot;)) {
 450                 host = &quot;[&quot;+host+&quot;]&quot;;
 451             }
 452             this.host = host;
 453 
 454             if (port &lt; -1) {
 455                 throw new MalformedURLException(&quot;Invalid port number :&quot; +
 456                                                     port);
 457             }
 458             this.port = port;
 459             authority = (port == -1) ? host : host + &quot;:&quot; + port;
 460         }
 461 
 462         int index = file.indexOf(&#39;#&#39;);
 463         this.ref = index &lt; 0 ? null : file.substring(index + 1);
 464         file = index &lt; 0 ? file : file.substring(0, index);
 465         int q = file.lastIndexOf(&#39;?&#39;);
 466         if (q != -1) {
 467             this.query = file.substring(q + 1);
 468             this.path = file.substring(0, q);
 469             this.file = path + &quot;?&quot; + query;
 470         } else {
 471             this.path = file;
 472             this.file = path;
 473         }
 474 
 475         // Note: we don&#39;t do full validation of the URL here. Too risky to change
 476         // right now, but worth considering for future reference. -br
 477         if (handler == null &amp;&amp;
 478             (handler = getURLStreamHandler(protocol)) == null) {
 479             throw new MalformedURLException(&quot;unknown protocol: &quot; + protocol);
 480         }
 481         this.handler = handler;
 482         if (host != null &amp;&amp; isBuiltinStreamHandler(handler)) {
 483             String s = IPAddressUtil.checkExternalForm(this);
 484             if (s != null) {
 485                 throw new MalformedURLException(s);
 486             }
 487         }
 488         if (&quot;jar&quot;.equalsIgnoreCase(protocol)) {
 489             if (handler instanceof sun.net.www.protocol.jar.Handler) {
 490                 // URL.openConnection() would throw a confusing exception
 491                 // so generate a better exception here instead.
 492                 String s = ((sun.net.www.protocol.jar.Handler) handler).checkNestedProtocol(file);
 493                 if (s != null) {
 494                     throw new MalformedURLException(s);
 495                 }
 496             }
 497         }
 498     }
 499 
 500     /**
 501      * Creates a {@code URL} object from the {@code String}
 502      * representation.
 503      * &lt;p&gt;
 504      * This constructor is equivalent to a call to the two-argument
 505      * constructor with a {@code null} first argument.
 506      *
 507      * @param      spec   the {@code String} to parse as a URL.
 508      * @throws     MalformedURLException  if no protocol is specified, or an
 509      *               unknown protocol is found, or {@code spec} is {@code null},
 510      *               or the parsed URL fails to comply with the specific syntax
 511      *               of the associated protocol.
 512      * @see        java.net.URL#URL(java.net.URL, java.lang.String)
 513      */
 514     public URL(String spec) throws MalformedURLException {
 515         this(null, spec);
 516     }
 517 
 518     /**
 519      * Creates a URL by parsing the given spec within a specified context.
 520      *
 521      * The new URL is created from the given context URL and the spec
 522      * argument as described in
 523      * RFC2396 &amp;quot;Uniform Resource Identifiers : Generic * Syntax&amp;quot; :
 524      * &lt;blockquote&gt;&lt;pre&gt;
 525      *          &amp;lt;scheme&amp;gt;://&amp;lt;authority&amp;gt;&amp;lt;path&amp;gt;?&amp;lt;query&amp;gt;#&amp;lt;fragment&amp;gt;
 526      * &lt;/pre&gt;&lt;/blockquote&gt;
 527      * The reference is parsed into the scheme, authority, path, query and
 528      * fragment parts. If the path component is empty and the scheme,
 529      * authority, and query components are undefined, then the new URL is a
 530      * reference to the current document. Otherwise, the fragment and query
 531      * parts present in the spec are used in the new URL.
 532      * &lt;p&gt;
 533      * If the scheme component is defined in the given spec and does not match
 534      * the scheme of the context, then the new URL is created as an absolute
 535      * URL based on the spec alone. Otherwise the scheme component is inherited
 536      * from the context URL.
 537      * &lt;p&gt;
 538      * If the authority component is present in the spec then the spec is
 539      * treated as absolute and the spec authority and path will replace the
 540      * context authority and path. If the authority component is absent in the
 541      * spec then the authority of the new URL will be inherited from the
 542      * context.
 543      * &lt;p&gt;
 544      * If the spec&#39;s path component begins with a slash character
 545      * &amp;quot;/&amp;quot; then the
 546      * path is treated as absolute and the spec path replaces the context path.
 547      * &lt;p&gt;
 548      * Otherwise, the path is treated as a relative path and is appended to the
 549      * context path, as described in RFC2396. Also, in this case,
 550      * the path is canonicalized through the removal of directory
 551      * changes made by occurrences of &amp;quot;..&amp;quot; and &amp;quot;.&amp;quot;.
 552      * &lt;p&gt;
 553      * For a more detailed description of URL parsing, refer to RFC2396.
 554      *
 555      * @param      context   the context in which to parse the specification.
 556      * @param      spec      the {@code String} to parse as a URL.
 557      * @throws     MalformedURLException  if no protocol is specified, or an
 558      *               unknown protocol is found, or {@code spec} is {@code null},
 559      *               or the parsed URL fails to comply with the specific syntax
 560      *               of the associated protocol.
 561      * @see        java.net.URL#URL(java.lang.String, java.lang.String,
 562      *                  int, java.lang.String)
 563      * @see        java.net.URLStreamHandler
 564      * @see        java.net.URLStreamHandler#parseURL(java.net.URL,
 565      *                  java.lang.String, int, int)
 566      */
 567     public URL(URL context, String spec) throws MalformedURLException {
 568         this(context, spec, null);
 569     }
 570 
 571     /**
 572      * Creates a URL by parsing the given spec with the specified handler
 573      * within a specified context. If the handler is null, the parsing
 574      * occurs as with the two argument constructor.
 575      *
 576      * @param      context   the context in which to parse the specification.
 577      * @param      spec      the {@code String} to parse as a URL.
 578      * @param      handler   the stream handler for the URL.
 579      * @throws     MalformedURLException  if no protocol is specified, or an
 580      *               unknown protocol is found, or {@code spec} is {@code null},
 581      *               or the parsed URL fails to comply with the specific syntax
 582      *               of the associated protocol.
 583      * @throws     SecurityException
 584      *        if a security manager exists and its
 585      *        {@code checkPermission} method doesn&#39;t allow
 586      *        specifying a stream handler.
 587      * @see        java.net.URL#URL(java.lang.String, java.lang.String,
 588      *                  int, java.lang.String)
 589      * @see        java.net.URLStreamHandler
 590      * @see        java.net.URLStreamHandler#parseURL(java.net.URL,
 591      *                  java.lang.String, int, int)
 592      */
 593     public URL(URL context, String spec, URLStreamHandler handler)
 594         throws MalformedURLException
 595     {
 596         String original = spec;
 597         int i, limit, c;
 598         int start = 0;
 599         String newProtocol = null;
 600         boolean aRef=false;
 601         boolean isRelative = false;
 602 
 603         // Check for permission to specify a handler
 604         if (handler != null) {
 605             SecurityManager sm = System.getSecurityManager();
 606             if (sm != null) {
 607                 checkSpecifyHandler(sm);
 608             }
 609         }
 610 
 611         try {
 612             limit = spec.length();
 613             while ((limit &gt; 0) &amp;&amp; (spec.charAt(limit - 1) &lt;= &#39; &#39;)) {
 614                 limit--;        //eliminate trailing whitespace
 615             }
 616             while ((start &lt; limit) &amp;&amp; (spec.charAt(start) &lt;= &#39; &#39;)) {
 617                 start++;        // eliminate leading whitespace
 618             }
 619 
 620             if (spec.regionMatches(true, start, &quot;url:&quot;, 0, 4)) {
 621                 start += 4;
 622             }
 623             if (start &lt; spec.length() &amp;&amp; spec.charAt(start) == &#39;#&#39;) {
 624                 /* we&#39;re assuming this is a ref relative to the context URL.
 625                  * This means protocols cannot start w/ &#39;#&#39;, but we must parse
 626                  * ref URL&#39;s like: &quot;hello:there&quot; w/ a &#39;:&#39; in them.
 627                  */
 628                 aRef=true;
 629             }
 630             for (i = start ; !aRef &amp;&amp; (i &lt; limit) &amp;&amp;
 631                      ((c = spec.charAt(i)) != &#39;/&#39;) ; i++) {
 632                 if (c == &#39;:&#39;) {
 633                     String s = toLowerCase(spec.substring(start, i));
 634                     if (isValidProtocol(s)) {
 635                         newProtocol = s;
 636                         start = i + 1;
 637                     }
 638                     break;
 639                 }
 640             }
 641 
 642             // Only use our context if the protocols match.
 643             protocol = newProtocol;
 644             if ((context != null) &amp;&amp; ((newProtocol == null) ||
 645                             newProtocol.equalsIgnoreCase(context.protocol))) {
 646                 // inherit the protocol handler from the context
 647                 // if not specified to the constructor
 648                 if (handler == null) {
 649                     handler = context.handler;
 650                 }
 651 
 652                 // If the context is a hierarchical URL scheme and the spec
 653                 // contains a matching scheme then maintain backwards
 654                 // compatibility and treat it as if the spec didn&#39;t contain
 655                 // the scheme; see 5.2.3 of RFC2396
 656                 if (context.path != null &amp;&amp; context.path.startsWith(&quot;/&quot;))
 657                     newProtocol = null;
 658 
 659                 if (newProtocol == null) {
 660                     protocol = context.protocol;
 661                     authority = context.authority;
 662                     userInfo = context.userInfo;
 663                     host = context.host;
 664                     port = context.port;
 665                     file = context.file;
 666                     path = context.path;
 667                     isRelative = true;
 668                 }
 669             }
 670 
 671             if (protocol == null) {
 672                 throw new MalformedURLException(&quot;no protocol: &quot;+original);
 673             }
 674 
 675             // Get the protocol handler if not specified or the protocol
 676             // of the context could not be used
 677             if (handler == null &amp;&amp;
 678                 (handler = getURLStreamHandler(protocol)) == null) {
 679                 throw new MalformedURLException(&quot;unknown protocol: &quot;+protocol);
 680             }
 681 
 682             this.handler = handler;
 683 
 684             i = spec.indexOf(&#39;#&#39;, start);
 685             if (i &gt;= 0) {
 686                 ref = spec.substring(i + 1, limit);
 687                 limit = i;
 688             }
 689 
 690             /*
 691              * Handle special case inheritance of query and fragment
 692              * implied by RFC2396 section 5.2.2.
 693              */
 694             if (isRelative &amp;&amp; start == limit) {
 695                 query = context.query;
 696                 if (ref == null) {
 697                     ref = context.ref;
 698                 }
 699             }
 700 
 701             handler.parseURL(this, spec, start, limit);
 702 
 703         } catch(MalformedURLException e) {
 704             throw e;
 705         } catch(Exception e) {
 706             MalformedURLException exception = new MalformedURLException(e.getMessage());
 707             exception.initCause(e);
 708             throw exception;
 709         }
 710     }
 711 
 712     /**
 713      * Creates a URL from a URI, as if by invoking {@code uri.toURL()}.
 714      *
 715      * @see java.net.URI#toURL()
 716      */
 717     static URL fromURI(URI uri) throws MalformedURLException {
 718         if (!uri.isAbsolute()) {
 719             throw new IllegalArgumentException(&quot;URI is not absolute&quot;);
 720         }
 721         String protocol = uri.getScheme();
 722 
 723         // In general we need to go via Handler.parseURL, but for the jrt
 724         // protocol we enforce that the Handler is not overrideable and can
 725         // optimize URI to URL conversion.
 726         //
 727         // Case-sensitive comparison for performance; malformed protocols will
 728         // be handled correctly by the slow path.
 729         if (protocol.equals(&quot;jrt&quot;) &amp;&amp; !uri.isOpaque()
 730                 &amp;&amp; uri.getRawFragment() == null) {
 731 
 732             String query = uri.getRawQuery();
 733             String path = uri.getRawPath();
 734             String file = (query == null) ? path : path + &quot;?&quot; + query;
 735 
 736             // URL represent undefined host as empty string while URI use null
 737             String host = uri.getHost();
 738             if (host == null) {
 739                 host = &quot;&quot;;
 740             }
 741 
 742             int port = uri.getPort();
 743 
 744             return new URL(&quot;jrt&quot;, host, port, file, null);
 745         } else {
 746             return new URL((URL)null, uri.toString(), null);
 747         }
 748     }
 749 
 750     /*
 751      * Returns true if specified string is a valid protocol name.
 752      */
 753     private boolean isValidProtocol(String protocol) {
 754         int len = protocol.length();
 755         if (len &lt; 1)
 756             return false;
 757         char c = protocol.charAt(0);
 758         if (!Character.isLetter(c))
 759             return false;
 760         for (int i = 1; i &lt; len; i++) {
 761             c = protocol.charAt(i);
 762             if (!Character.isLetterOrDigit(c) &amp;&amp; c != &#39;.&#39; &amp;&amp; c != &#39;+&#39; &amp;&amp;
 763                 c != &#39;-&#39;) {
 764                 return false;
 765             }
 766         }
 767         return true;
 768     }
 769 
 770     /*
 771      * Checks for permission to specify a stream handler.
 772      */
 773     private void checkSpecifyHandler(SecurityManager sm) {
 774         sm.checkPermission(SecurityConstants.SPECIFY_HANDLER_PERMISSION);
 775     }
 776 
 777     /**
 778      * Sets the fields of the URL. This is not a public method so that
 779      * only URLStreamHandlers can modify URL fields. URLs are
 780      * otherwise constant.
 781      *
 782      * @param protocol the name of the protocol to use
 783      * @param host the name of the host
<a name="3" id="anc3"></a><span class="line-modified"> 784      * @param port the port number on the host</span>
 785      * @param file the file on the host
 786      * @param ref the internal reference in the URL
 787      */
 788     void set(String protocol, String host, int port,
 789              String file, String ref) {
 790         synchronized (this) {
 791             this.protocol = protocol;
 792             this.host = host;
 793             authority = port == -1 ? host : host + &quot;:&quot; + port;
 794             this.port = port;
 795             this.file = file;
 796             this.ref = ref;
 797             /* This is very important. We must recompute this after the
 798              * URL has been changed. */
 799             hashCode = -1;
 800             hostAddress = null;
 801             int q = file.lastIndexOf(&#39;?&#39;);
 802             if (q != -1) {
 803                 query = file.substring(q+1);
 804                 path = file.substring(0, q);
 805             } else
 806                 path = file;
 807         }
 808     }
 809 
 810     /**
 811      * Sets the specified 8 fields of the URL. This is not a public method so
 812      * that only URLStreamHandlers can modify URL fields. URLs are otherwise
 813      * constant.
 814      *
 815      * @param protocol the name of the protocol to use
 816      * @param host the name of the host
 817      * @param port the port number on the host
 818      * @param authority the authority part for the url
 819      * @param userInfo the username and password
 820      * @param path the file on the host
 821      * @param ref the internal reference in the URL
 822      * @param query the query part of this URL
 823      * @since 1.3
 824      */
 825     void set(String protocol, String host, int port,
 826              String authority, String userInfo, String path,
 827              String query, String ref) {
 828         synchronized (this) {
 829             this.protocol = protocol;
 830             this.host = host;
 831             this.port = port;
 832             this.file = query == null ? path : path + &quot;?&quot; + query;
 833             this.userInfo = userInfo;
 834             this.path = path;
 835             this.ref = ref;
 836             /* This is very important. We must recompute this after the
 837              * URL has been changed. */
 838             hashCode = -1;
 839             hostAddress = null;
 840             this.query = query;
 841             this.authority = authority;
 842         }
 843     }
 844 
 845     /**
 846      * Gets the query part of this {@code URL}.
 847      *
 848      * @return  the query part of this {@code URL},
 849      * or &lt;CODE&gt;null&lt;/CODE&gt; if one does not exist
 850      * @since 1.3
 851      */
 852     public String getQuery() {
 853         return query;
 854     }
 855 
 856     /**
 857      * Gets the path part of this {@code URL}.
 858      *
 859      * @return  the path part of this {@code URL}, or an
 860      * empty string if one does not exist
 861      * @since 1.3
 862      */
 863     public String getPath() {
 864         return path;
 865     }
 866 
 867     /**
 868      * Gets the userInfo part of this {@code URL}.
 869      *
 870      * @return  the userInfo part of this {@code URL}, or
 871      * &lt;CODE&gt;null&lt;/CODE&gt; if one does not exist
 872      * @since 1.3
 873      */
 874     public String getUserInfo() {
 875         return userInfo;
 876     }
 877 
 878     /**
 879      * Gets the authority part of this {@code URL}.
 880      *
 881      * @return  the authority part of this {@code URL}
 882      * @since 1.3
 883      */
 884     public String getAuthority() {
 885         return authority;
 886     }
 887 
 888     /**
 889      * Gets the port number of this {@code URL}.
 890      *
 891      * @return  the port number, or -1 if the port is not set
 892      */
 893     public int getPort() {
 894         return port;
 895     }
 896 
 897     /**
 898      * Gets the default port number of the protocol associated
 899      * with this {@code URL}. If the URL scheme or the URLStreamHandler
 900      * for the URL do not define a default port number,
 901      * then -1 is returned.
 902      *
 903      * @return  the port number
 904      * @since 1.4
 905      */
 906     public int getDefaultPort() {
 907         return handler.getDefaultPort();
 908     }
 909 
 910     /**
 911      * Gets the protocol name of this {@code URL}.
 912      *
 913      * @return  the protocol of this {@code URL}.
 914      */
 915     public String getProtocol() {
 916         return protocol;
 917     }
 918 
 919     /**
 920      * Gets the host name of this {@code URL}, if applicable.
 921      * The format of the host conforms to RFC 2732, i.e. for a
 922      * literal IPv6 address, this method will return the IPv6 address
 923      * enclosed in square brackets ({@code &#39;[&#39;} and {@code &#39;]&#39;}).
 924      *
 925      * @return  the host name of this {@code URL}.
 926      */
 927     public String getHost() {
 928         return host;
 929     }
 930 
 931     /**
 932      * Gets the file name of this {@code URL}.
 933      * The returned file portion will be
 934      * the same as &lt;CODE&gt;getPath()&lt;/CODE&gt;, plus the concatenation of
 935      * the value of &lt;CODE&gt;getQuery()&lt;/CODE&gt;, if any. If there is
 936      * no query portion, this method and &lt;CODE&gt;getPath()&lt;/CODE&gt; will
 937      * return identical results.
 938      *
 939      * @return  the file name of this {@code URL},
 940      * or an empty string if one does not exist
 941      */
 942     public String getFile() {
 943         return file;
 944     }
 945 
 946     /**
 947      * Gets the anchor (also known as the &quot;reference&quot;) of this
 948      * {@code URL}.
 949      *
 950      * @return  the anchor (also known as the &quot;reference&quot;) of this
 951      *          {@code URL}, or &lt;CODE&gt;null&lt;/CODE&gt; if one does not exist
 952      */
 953     public String getRef() {
 954         return ref;
 955     }
 956 
 957     /**
 958      * Compares this URL for equality with another object.&lt;p&gt;
 959      *
 960      * If the given object is not a URL then this method immediately returns
 961      * {@code false}.&lt;p&gt;
 962      *
 963      * Two URL objects are equal if they have the same protocol, reference
 964      * equivalent hosts, have the same port number on the host, and the same
 965      * file and fragment of the file.&lt;p&gt;
 966      *
 967      * Two hosts are considered equivalent if both host names can be resolved
 968      * into the same IP addresses; else if either host name can&#39;t be
 969      * resolved, the host names must be equal without regard to case; or both
 970      * host names equal to null.&lt;p&gt;
 971      *
 972      * Since hosts comparison requires name resolution, this operation is a
 973      * blocking operation. &lt;p&gt;
 974      *
 975      * Note: The defined behavior for {@code equals} is known to
 976      * be inconsistent with virtual hosting in HTTP.
 977      *
 978      * @param   obj   the URL to compare against.
 979      * @return  {@code true} if the objects are the same;
 980      *          {@code false} otherwise.
 981      */
 982     public boolean equals(Object obj) {
 983         if (!(obj instanceof URL))
 984             return false;
 985         URL u2 = (URL)obj;
 986 
 987         return handler.equals(this, u2);
 988     }
 989 
 990     /**
 991      * Creates an integer suitable for hash table indexing.&lt;p&gt;
 992      *
 993      * The hash code is based upon all the URL components relevant for URL
 994      * comparison. As such, this operation is a blocking operation.
 995      *
 996      * @return  a hash code for this {@code URL}.
 997      */
 998     public synchronized int hashCode() {
 999         if (hashCode != -1)
1000             return hashCode;
1001 
1002         hashCode = handler.hashCode(this);
1003         return hashCode;
1004     }
1005 
1006     /**
1007      * Compares two URLs, excluding the fragment component.&lt;p&gt;
1008      *
1009      * Returns {@code true} if this {@code URL} and the
1010      * {@code other} argument are equal without taking the
1011      * fragment component into consideration.
1012      *
1013      * @param   other   the {@code URL} to compare against.
1014      * @return  {@code true} if they reference the same remote object;
1015      *          {@code false} otherwise.
1016      */
1017     public boolean sameFile(URL other) {
1018         return handler.sameFile(this, other);
1019     }
1020 
1021     /**
1022      * Constructs a string representation of this {@code URL}. The
1023      * string is created by calling the {@code toExternalForm}
1024      * method of the stream protocol handler for this object.
1025      *
1026      * @return  a string representation of this object.
1027      * @see     java.net.URL#URL(java.lang.String, java.lang.String, int,
1028      *                  java.lang.String)
1029      * @see     java.net.URLStreamHandler#toExternalForm(java.net.URL)
1030      */
1031     public String toString() {
1032         return toExternalForm();
1033     }
1034 
1035     /**
1036      * Constructs a string representation of this {@code URL}. The
1037      * string is created by calling the {@code toExternalForm}
1038      * method of the stream protocol handler for this object.
1039      *
1040      * @return  a string representation of this object.
1041      * @see     java.net.URL#URL(java.lang.String, java.lang.String,
1042      *                  int, java.lang.String)
1043      * @see     java.net.URLStreamHandler#toExternalForm(java.net.URL)
1044      */
1045     public String toExternalForm() {
1046         return handler.toExternalForm(this);
1047     }
1048 
1049     /**
1050      * Returns a {@link java.net.URI} equivalent to this URL.
1051      * This method functions in the same way as {@code new URI (this.toString())}.
1052      * &lt;p&gt;Note, any URL instance that complies with RFC 2396 can be converted
1053      * to a URI. However, some URLs that are not strictly in compliance
1054      * can not be converted to a URI.
1055      *
1056      * @throws    URISyntaxException if this URL is not formatted strictly according to
1057      *            RFC2396 and cannot be converted to a URI.
1058      *
1059      * @return    a URI instance equivalent to this URL.
1060      * @since 1.5
1061      */
1062     public URI toURI() throws URISyntaxException {
1063         URI uri = new URI(toString());
1064         if (authority != null &amp;&amp; isBuiltinStreamHandler(handler)) {
1065             String s = IPAddressUtil.checkAuthority(this);
1066             if (s != null) throw new URISyntaxException(authority, s);
1067         }
1068         return uri;
1069     }
1070 
1071     /**
1072      * Returns a {@link java.net.URLConnection URLConnection} instance that
1073      * represents a connection to the remote object referred to by the
1074      * {@code URL}.
1075      *
1076      * &lt;P&gt;A new instance of {@linkplain java.net.URLConnection URLConnection} is
1077      * created every time when invoking the
1078      * {@linkplain java.net.URLStreamHandler#openConnection(URL)
1079      * URLStreamHandler.openConnection(URL)} method of the protocol handler for
1080      * this URL.&lt;/P&gt;
1081      *
1082      * &lt;P&gt;It should be noted that a URLConnection instance does not establish
1083      * the actual network connection on creation. This will happen only when
1084      * calling {@linkplain java.net.URLConnection#connect() URLConnection.connect()}.&lt;/P&gt;
1085      *
1086      * &lt;P&gt;If for the URL&#39;s protocol (such as HTTP or JAR), there
1087      * exists a public, specialized URLConnection subclass belonging
1088      * to one of the following packages or one of their subpackages:
1089      * java.lang, java.io, java.util, java.net, the connection
1090      * returned will be of that subclass. For example, for HTTP an
1091      * HttpURLConnection will be returned, and for JAR a
1092      * JarURLConnection will be returned.&lt;/P&gt;
1093      *
1094      * @return     a {@link java.net.URLConnection URLConnection} linking
1095      *             to the URL.
1096      * @throws     IOException  if an I/O exception occurs.
1097      * @see        java.net.URL#URL(java.lang.String, java.lang.String,
1098      *             int, java.lang.String)
1099      */
1100     public URLConnection openConnection() throws java.io.IOException {
1101         return handler.openConnection(this);
1102     }
1103 
1104     /**
1105      * Same as {@link #openConnection()}, except that the connection will be
1106      * made through the specified proxy; Protocol handlers that do not
1107      * support proxying will ignore the proxy parameter and make a
1108      * normal connection.
1109      *
1110      * Invoking this method preempts the system&#39;s default
1111      * {@link java.net.ProxySelector ProxySelector} settings.
1112      *
1113      * @param      proxy the Proxy through which this connection
1114      *             will be made. If direct connection is desired,
1115      *             Proxy.NO_PROXY should be specified.
1116      * @return     a {@code URLConnection} to the URL.
1117      * @throws     IOException  if an I/O exception occurs.
1118      * @throws     SecurityException if a security manager is present
1119      *             and the caller doesn&#39;t have permission to connect
1120      *             to the proxy.
1121      * @throws     IllegalArgumentException will be thrown if proxy is null,
1122      *             or proxy has the wrong type
1123      * @throws     UnsupportedOperationException if the subclass that
1124      *             implements the protocol handler doesn&#39;t support
1125      *             this method.
1126      * @see        java.net.URL#URL(java.lang.String, java.lang.String,
1127      *             int, java.lang.String)
1128      * @see        java.net.URLConnection
1129      * @see        java.net.URLStreamHandler#openConnection(java.net.URL,
1130      *             java.net.Proxy)
1131      * @since      1.5
1132      */
1133     public URLConnection openConnection(Proxy proxy)
1134         throws java.io.IOException {
1135         if (proxy == null) {
1136             throw new IllegalArgumentException(&quot;proxy can not be null&quot;);
1137         }
1138 
1139         // Create a copy of Proxy as a security measure
1140         Proxy p = proxy == Proxy.NO_PROXY ? Proxy.NO_PROXY : sun.net.ApplicationProxy.create(proxy);
1141         SecurityManager sm = System.getSecurityManager();
1142         if (p.type() != Proxy.Type.DIRECT &amp;&amp; sm != null) {
1143             InetSocketAddress epoint = (InetSocketAddress) p.address();
1144             if (epoint.isUnresolved())
1145                 sm.checkConnect(epoint.getHostName(), epoint.getPort());
1146             else
1147                 sm.checkConnect(epoint.getAddress().getHostAddress(),
1148                                 epoint.getPort());
1149         }
1150         return handler.openConnection(this, p);
1151     }
1152 
1153     /**
1154      * Opens a connection to this {@code URL} and returns an
1155      * {@code InputStream} for reading from that connection. This
1156      * method is a shorthand for:
1157      * &lt;blockquote&gt;&lt;pre&gt;
1158      *     openConnection().getInputStream()
1159      * &lt;/pre&gt;&lt;/blockquote&gt;
1160      *
1161      * @return     an input stream for reading from the URL connection.
1162      * @throws     IOException  if an I/O exception occurs.
1163      * @see        java.net.URL#openConnection()
1164      * @see        java.net.URLConnection#getInputStream()
1165      */
1166     public final InputStream openStream() throws java.io.IOException {
1167         return openConnection().getInputStream();
1168     }
1169 
1170     /**
1171      * Gets the contents of this URL. This method is a shorthand for:
1172      * &lt;blockquote&gt;&lt;pre&gt;
1173      *     openConnection().getContent()
1174      * &lt;/pre&gt;&lt;/blockquote&gt;
1175      *
1176      * @return     the contents of this URL.
1177      * @throws     IOException  if an I/O exception occurs.
1178      * @see        java.net.URLConnection#getContent()
1179      */
1180     public final Object getContent() throws java.io.IOException {
1181         return openConnection().getContent();
1182     }
1183 
1184     /**
1185      * Gets the contents of this URL. This method is a shorthand for:
1186      * &lt;blockquote&gt;&lt;pre&gt;
1187      *     openConnection().getContent(classes)
1188      * &lt;/pre&gt;&lt;/blockquote&gt;
1189      *
1190      * @param classes an array of Java types
1191      * @return     the content object of this URL that is the first match of
1192      *               the types specified in the classes array.
1193      *               null if none of the requested types are supported.
1194      * @throws     IOException  if an I/O exception occurs.
1195      * @see        java.net.URLConnection#getContent(Class[])
1196      * @since 1.3
1197      */
1198     public final Object getContent(Class&lt;?&gt;[] classes)
1199     throws java.io.IOException {
1200         return openConnection().getContent(classes);
1201     }
1202 
1203     /**
1204      * The URLStreamHandler factory.
1205      */
1206     private static volatile URLStreamHandlerFactory factory;
1207 
1208     /**
1209      * Sets an application&#39;s {@code URLStreamHandlerFactory}.
1210      * This method can be called at most once in a given Java Virtual
1211      * Machine.
1212      *
1213      *&lt;p&gt; The {@code URLStreamHandlerFactory} instance is used to
1214      *construct a stream protocol handler from a protocol name.
1215      *
1216      * &lt;p&gt; If there is a security manager, this method first calls
1217      * the security manager&#39;s {@code checkSetFactory} method
1218      * to ensure the operation is allowed.
1219      * This could result in a SecurityException.
1220      *
1221      * @param      fac   the desired factory.
1222      * @throws     Error  if the application has already set a factory.
1223      * @throws     SecurityException  if a security manager exists and its
1224      *             {@code checkSetFactory} method doesn&#39;t allow
1225      *             the operation.
1226      * @see        java.net.URL#URL(java.lang.String, java.lang.String,
1227      *             int, java.lang.String)
1228      * @see        java.net.URLStreamHandlerFactory
1229      * @see        SecurityManager#checkSetFactory
1230      */
1231     public static void setURLStreamHandlerFactory(URLStreamHandlerFactory fac) {
1232         synchronized (streamHandlerLock) {
1233             if (factory != null) {
1234                 throw new Error(&quot;factory already defined&quot;);
1235             }
1236             SecurityManager security = System.getSecurityManager();
1237             if (security != null) {
1238                 security.checkSetFactory();
1239             }
1240             handlers.clear();
1241 
1242             // safe publication of URLStreamHandlerFactory with volatile write
1243             factory = fac;
1244         }
1245     }
1246 
1247     private static final URLStreamHandlerFactory defaultFactory = new DefaultFactory();
1248 
1249     private static class DefaultFactory implements URLStreamHandlerFactory {
1250         private static String PREFIX = &quot;sun.net.www.protocol.&quot;;
1251 
1252         public URLStreamHandler createURLStreamHandler(String protocol) {
1253             // Avoid using reflection during bootstrap
1254             switch (protocol) {
1255                 case &quot;file&quot;:
1256                     return new sun.net.www.protocol.file.Handler();
1257                 case &quot;jar&quot;:
1258                     return new sun.net.www.protocol.jar.Handler();
1259                 case &quot;jrt&quot;:
1260                     return new sun.net.www.protocol.jrt.Handler();
1261             }
1262             String name = PREFIX + protocol + &quot;.Handler&quot;;
1263             try {
1264                 Object o = Class.forName(name).getDeclaredConstructor().newInstance();
1265                 return (URLStreamHandler)o;
1266             } catch (Exception e) {
1267                 // For compatibility, all Exceptions are ignored.
1268                 // any number of exceptions can get thrown here
1269             }
1270             return null;
1271         }
1272     }
1273 
1274     private static URLStreamHandler lookupViaProperty(String protocol) {
1275         String packagePrefixList =
1276                 GetPropertyAction.privilegedGetProperty(protocolPathProp);
1277         if (packagePrefixList == null) {
1278             // not set
1279             return null;
1280         }
1281 
1282         String[] packagePrefixes = packagePrefixList.split(&quot;\\|&quot;);
1283         URLStreamHandler handler = null;
1284         for (int i=0; handler == null &amp;&amp; i&lt;packagePrefixes.length; i++) {
1285             String packagePrefix = packagePrefixes[i].trim();
1286             try {
1287                 String clsName = packagePrefix + &quot;.&quot; + protocol + &quot;.Handler&quot;;
1288                 Class&lt;?&gt; cls = null;
1289                 try {
1290                     cls = Class.forName(clsName);
1291                 } catch (ClassNotFoundException e) {
1292                     ClassLoader cl = ClassLoader.getSystemClassLoader();
1293                     if (cl != null) {
1294                         cls = cl.loadClass(clsName);
1295                     }
1296                 }
1297                 if (cls != null) {
1298                     @SuppressWarnings(&quot;deprecation&quot;)
1299                     Object tmp = cls.newInstance();
1300                     handler = (URLStreamHandler)tmp;
1301                 }
1302             } catch (Exception e) {
1303                 // any number of exceptions can get thrown here
1304             }
1305         }
1306         return handler;
1307     }
1308 
1309     private static Iterator&lt;URLStreamHandlerProvider&gt; providers() {
1310         return new Iterator&lt;&gt;() {
1311 
1312             ClassLoader cl = ClassLoader.getSystemClassLoader();
1313             ServiceLoader&lt;URLStreamHandlerProvider&gt; sl =
1314                     ServiceLoader.load(URLStreamHandlerProvider.class, cl);
1315             Iterator&lt;URLStreamHandlerProvider&gt; i = sl.iterator();
1316 
1317             URLStreamHandlerProvider next = null;
1318 
1319             private boolean getNext() {
1320                 while (next == null) {
1321                     try {
1322                         if (!i.hasNext())
1323                             return false;
1324                         next = i.next();
1325                     } catch (ServiceConfigurationError sce) {
1326                         if (sce.getCause() instanceof SecurityException) {
1327                             // Ignore security exceptions
1328                             continue;
1329                         }
1330                         throw sce;
1331                     }
1332                 }
1333                 return true;
1334             }
1335 
1336             public boolean hasNext() {
1337                 return getNext();
1338             }
1339 
1340             public URLStreamHandlerProvider next() {
1341                 if (!getNext())
1342                     throw new NoSuchElementException();
1343                 URLStreamHandlerProvider n = next;
1344                 next = null;
1345                 return n;
1346             }
1347         };
1348     }
1349 
1350     // Thread-local gate to prevent recursive provider lookups
1351     private static ThreadLocal&lt;Object&gt; gate = new ThreadLocal&lt;&gt;();
1352 
1353     private static URLStreamHandler lookupViaProviders(final String protocol) {
1354         if (gate.get() != null)
1355             throw new Error(&quot;Circular loading of URL stream handler providers detected&quot;);
1356 
1357         gate.set(gate);
1358         try {
1359             return AccessController.doPrivileged(
1360                 new PrivilegedAction&lt;&gt;() {
1361                     public URLStreamHandler run() {
1362                         Iterator&lt;URLStreamHandlerProvider&gt; itr = providers();
1363                         while (itr.hasNext()) {
1364                             URLStreamHandlerProvider f = itr.next();
1365                             URLStreamHandler h = f.createURLStreamHandler(protocol);
1366                             if (h != null)
1367                                 return h;
1368                         }
1369                         return null;
1370                     }
1371                 });
1372         } finally {
1373             gate.set(null);
1374         }
1375     }
1376 
1377     /**
1378      * Returns the protocol in lower case. Special cases known protocols
1379      * to avoid loading locale classes during startup.
1380      */
1381     static String toLowerCase(String protocol) {
1382         if (protocol.equals(&quot;jrt&quot;) || protocol.equals(&quot;file&quot;) || protocol.equals(&quot;jar&quot;)) {
1383             return protocol;
1384         } else {
1385             return protocol.toLowerCase(Locale.ROOT);
1386         }
1387     }
1388 
1389     /**
1390      * Non-overrideable protocols: &quot;jrt&quot; and &quot;file&quot;
1391      *
1392      * Character-based comparison for performance reasons; also ensures
1393      * case-insensitive comparison in a locale-independent fashion.
1394      */
1395     static boolean isOverrideable(String protocol) {
1396         if (protocol.length() == 3) {
1397             if ((Character.toLowerCase(protocol.charAt(0)) == &#39;j&#39;) &amp;&amp;
1398                     (Character.toLowerCase(protocol.charAt(1)) == &#39;r&#39;) &amp;&amp;
1399                     (Character.toLowerCase(protocol.charAt(2)) == &#39;t&#39;)) {
1400                 return false;
1401             }
1402         } else if (protocol.length() == 4) {
1403             if ((Character.toLowerCase(protocol.charAt(0)) == &#39;f&#39;) &amp;&amp;
1404                     (Character.toLowerCase(protocol.charAt(1)) == &#39;i&#39;) &amp;&amp;
1405                     (Character.toLowerCase(protocol.charAt(2)) == &#39;l&#39;) &amp;&amp;
1406                     (Character.toLowerCase(protocol.charAt(3)) == &#39;e&#39;)) {
1407                 return false;
1408             }
1409         }
1410         return true;
1411     }
1412 
1413     /**
1414      * A table of protocol handlers.
1415      */
1416     static Hashtable&lt;String,URLStreamHandler&gt; handlers = new Hashtable&lt;&gt;();
1417     private static final Object streamHandlerLock = new Object();
1418 
1419     /**
1420      * Returns the Stream Handler.
1421      * @param protocol the protocol to use
1422      */
1423     static URLStreamHandler getURLStreamHandler(String protocol) {
1424 
1425         URLStreamHandler handler = handlers.get(protocol);
1426 
1427         if (handler != null) {
1428             return handler;
1429         }
1430 
1431         URLStreamHandlerFactory fac;
1432         boolean checkedWithFactory = false;
1433         boolean overrideableProtocol = isOverrideable(protocol);
1434 
1435         if (overrideableProtocol &amp;&amp; VM.isBooted()) {
1436             // Use the factory (if any). Volatile read makes
1437             // URLStreamHandlerFactory appear fully initialized to current thread.
1438             fac = factory;
1439             if (fac != null) {
1440                 handler = fac.createURLStreamHandler(protocol);
1441                 checkedWithFactory = true;
1442             }
1443 
1444             if (handler == null &amp;&amp; !protocol.equalsIgnoreCase(&quot;jar&quot;)) {
1445                 handler = lookupViaProviders(protocol);
1446             }
1447 
1448             if (handler == null) {
1449                 handler = lookupViaProperty(protocol);
1450             }
1451         }
1452 
1453         if (handler == null) {
1454             // Try the built-in protocol handler
1455             handler = defaultFactory.createURLStreamHandler(protocol);
1456         }
1457 
1458         synchronized (streamHandlerLock) {
1459             URLStreamHandler handler2 = null;
1460 
1461             // Check again with hashtable just in case another
1462             // thread created a handler since we last checked
1463             handler2 = handlers.get(protocol);
1464 
1465             if (handler2 != null) {
1466                 return handler2;
1467             }
1468 
1469             // Check with factory if another thread set a
1470             // factory since our last check
1471             if (overrideableProtocol &amp;&amp; !checkedWithFactory &amp;&amp;
1472                 (fac = factory) != null) {
1473                 handler2 = fac.createURLStreamHandler(protocol);
1474             }
1475 
1476             if (handler2 != null) {
1477                 // The handler from the factory must be given more
1478                 // importance. Discard the default handler that
1479                 // this thread created.
1480                 handler = handler2;
1481             }
1482 
1483             // Insert this handler into the hashtable
1484             if (handler != null) {
1485                 handlers.put(protocol, handler);
1486             }
1487         }
1488         return handler;
1489     }
1490 
1491     /**
1492      * @serialField    protocol String
1493      *
1494      * @serialField    host String
1495      *
1496      * @serialField    port int
1497      *
1498      * @serialField    authority String
1499      *
1500      * @serialField    file String
1501      *
1502      * @serialField    ref String
1503      *
1504      * @serialField    hashCode int
1505      *
1506      */
1507     @java.io.Serial
1508     private static final ObjectStreamField[] serialPersistentFields = {
1509         new ObjectStreamField(&quot;protocol&quot;, String.class),
1510         new ObjectStreamField(&quot;host&quot;, String.class),
1511         new ObjectStreamField(&quot;port&quot;, int.class),
1512         new ObjectStreamField(&quot;authority&quot;, String.class),
1513         new ObjectStreamField(&quot;file&quot;, String.class),
1514         new ObjectStreamField(&quot;ref&quot;, String.class),
1515         new ObjectStreamField(&quot;hashCode&quot;, int.class), };
1516 
1517     /**
1518      * WriteObject is called to save the state of the URL to an
1519      * ObjectOutputStream. The handler is not saved since it is
1520      * specific to this system.
1521      *
1522      * @serialData the default write object value. When read back in,
1523      * the reader must ensure that calling getURLStreamHandler with
1524      * the protocol variable returns a valid URLStreamHandler and
1525      * throw an IOException if it does not.
1526      */
1527     @java.io.Serial
1528     private synchronized void writeObject(java.io.ObjectOutputStream s)
1529         throws IOException
1530     {
1531         s.defaultWriteObject(); // write the fields
1532     }
1533 
1534     /**
1535      * readObject is called to restore the state of the URL from the
1536      * stream.  It reads the components of the URL and finds the local
1537      * stream handler.
1538      */
1539     @java.io.Serial
1540     private synchronized void readObject(java.io.ObjectInputStream s)
1541             throws IOException, ClassNotFoundException {
1542         GetField gf = s.readFields();
1543         String protocol = (String)gf.get(&quot;protocol&quot;, null);
1544         if (getURLStreamHandler(protocol) == null) {
1545             throw new IOException(&quot;unknown protocol: &quot; + protocol);
1546         }
1547         String host = (String)gf.get(&quot;host&quot;, null);
1548         int port = gf.get(&quot;port&quot;, -1);
1549         String authority = (String)gf.get(&quot;authority&quot;, null);
1550         String file = (String)gf.get(&quot;file&quot;, null);
1551         String ref = (String)gf.get(&quot;ref&quot;, null);
1552         int hashCode = gf.get(&quot;hashCode&quot;, -1);
1553         if (authority == null
1554                 &amp;&amp; ((host != null &amp;&amp; !host.isEmpty()) || port != -1)) {
1555             if (host == null)
1556                 host = &quot;&quot;;
1557             authority = (port == -1) ? host : host + &quot;:&quot; + port;
1558         }
1559         tempState = new UrlDeserializedState(protocol, host, port, authority,
1560                file, ref, hashCode);
1561     }
1562 
1563     /**
1564      * Replaces the de-serialized object with an URL object.
1565      *
1566      * @return a newly created object from deserialized data
1567      *
1568      * @throws ObjectStreamException if a new object replacing this
1569      * object could not be created
1570      */
1571    @java.io.Serial
1572    private Object readResolve() throws ObjectStreamException {
1573 
1574         URLStreamHandler handler = null;
1575         // already been checked in readObject
1576         handler = getURLStreamHandler(tempState.getProtocol());
1577 
1578         URL replacementURL = null;
1579         if (isBuiltinStreamHandler(handler.getClass().getName())) {
1580             replacementURL = fabricateNewURL();
1581         } else {
1582             replacementURL = setDeserializedFields(handler);
1583         }
1584         return replacementURL;
1585     }
1586 
1587     private URL setDeserializedFields(URLStreamHandler handler) {
1588         URL replacementURL;
1589         String userInfo = null;
1590         String protocol = tempState.getProtocol();
1591         String host = tempState.getHost();
1592         int port = tempState.getPort();
1593         String authority = tempState.getAuthority();
1594         String file = tempState.getFile();
1595         String ref = tempState.getRef();
1596         int hashCode = tempState.getHashCode();
1597 
1598 
1599         // Construct authority part
1600         if (authority == null
1601             &amp;&amp; ((host != null &amp;&amp; !host.isEmpty()) || port != -1)) {
1602             if (host == null)
1603                 host = &quot;&quot;;
1604             authority = (port == -1) ? host : host + &quot;:&quot; + port;
1605 
1606             // Handle hosts with userInfo in them
1607             int at = host.lastIndexOf(&#39;@&#39;);
1608             if (at != -1) {
1609                 userInfo = host.substring(0, at);
1610                 host = host.substring(at+1);
1611             }
1612         } else if (authority != null) {
1613             // Construct user info part
1614             int ind = authority.indexOf(&#39;@&#39;);
1615             if (ind != -1)
1616                 userInfo = authority.substring(0, ind);
1617         }
1618 
1619         // Construct path and query part
1620         String path = null;
1621         String query = null;
1622         if (file != null) {
1623             // Fix: only do this if hierarchical?
1624             int q = file.lastIndexOf(&#39;?&#39;);
1625             if (q != -1) {
1626                 query = file.substring(q+1);
1627                 path = file.substring(0, q);
1628             } else
1629                 path = file;
1630         }
1631 
1632         // Set the object fields.
1633         this.protocol = protocol;
1634         this.host = host;
1635         this.port = port;
1636         this.file = file;
1637         this.authority = authority;
1638         this.ref = ref;
1639         this.hashCode = hashCode;
1640         this.handler = handler;
1641         this.query = query;
1642         this.path = path;
1643         this.userInfo = userInfo;
1644         replacementURL = this;
1645         return replacementURL;
1646     }
1647 
1648     private URL fabricateNewURL()
1649                 throws InvalidObjectException {
1650         // create URL string from deserialized object
1651         URL replacementURL = null;
1652         String urlString = tempState.reconstituteUrlString();
1653 
1654         try {
1655             replacementURL = new URL(urlString);
1656         } catch (MalformedURLException mEx) {
1657             resetState();
1658             InvalidObjectException invoEx = new InvalidObjectException(
1659                     &quot;Malformed URL:  &quot; + urlString);
1660             invoEx.initCause(mEx);
1661             throw invoEx;
1662         }
1663         replacementURL.setSerializedHashCode(tempState.getHashCode());
1664         resetState();
1665         return replacementURL;
1666     }
1667 
1668     boolean isBuiltinStreamHandler(URLStreamHandler handler) {
1669        Class&lt;?&gt; handlerClass = handler.getClass();
1670        return isBuiltinStreamHandler(handlerClass.getName())
1671                  || VM.isSystemDomainLoader(handlerClass.getClassLoader());
1672     }
1673 
1674     private boolean isBuiltinStreamHandler(String handlerClassName) {
1675         return (handlerClassName.startsWith(BUILTIN_HANDLERS_PREFIX));
1676     }
1677 
1678     private void resetState() {
1679         this.protocol = null;
1680         this.host = null;
1681         this.port = -1;
1682         this.file = null;
1683         this.authority = null;
1684         this.ref = null;
1685         this.hashCode = -1;
1686         this.handler = null;
1687         this.query = null;
1688         this.path = null;
1689         this.userInfo = null;
1690         this.tempState = null;
1691     }
1692 
1693     private void setSerializedHashCode(int hc) {
1694         this.hashCode = hc;
1695     }
1696 
1697     static {
1698         SharedSecrets.setJavaNetURLAccess(
1699                 new JavaNetURLAccess() {
1700                     @Override
1701                     public URLStreamHandler getHandler(URL u) {
1702                         return u.handler;
1703                     }
1704                 }
1705         );
1706     }
1707 }
1708 
1709 final class UrlDeserializedState {
1710     private final String protocol;
1711     private final String host;
1712     private final int port;
1713     private final String authority;
1714     private final String file;
1715     private final String ref;
1716     private final int hashCode;
1717 
1718     public UrlDeserializedState(String protocol,
1719                                 String host, int port,
1720                                 String authority, String file,
1721                                 String ref, int hashCode) {
1722         this.protocol = protocol;
1723         this.host = host;
1724         this.port = port;
1725         this.authority = authority;
1726         this.file = file;
1727         this.ref = ref;
1728         this.hashCode = hashCode;
1729     }
1730 
1731     String getProtocol() {
1732         return protocol;
1733     }
1734 
1735     String getHost() {
1736         return host;
1737     }
1738 
1739     String getAuthority () {
1740         return authority;
1741     }
1742 
1743     int getPort() {
1744         return port;
1745     }
1746 
1747     String getFile () {
1748         return file;
1749     }
1750 
1751     String getRef () {
1752         return ref;
1753     }
1754 
1755     int getHashCode () {
1756         return hashCode;
1757     }
1758 
1759     String reconstituteUrlString() {
1760 
1761         // pre-compute length of StringBuffer
1762         int len = protocol.length() + 1;
1763         if (authority != null &amp;&amp; !authority.isEmpty())
1764             len += 2 + authority.length();
1765         if (file != null) {
1766             len += file.length();
1767         }
1768         if (ref != null)
1769             len += 1 + ref.length();
1770         StringBuilder result = new StringBuilder(len);
1771         result.append(protocol);
1772         result.append(&quot;:&quot;);
1773         if (authority != null &amp;&amp; !authority.isEmpty()) {
1774             result.append(&quot;//&quot;);
1775             result.append(authority);
1776         }
1777         if (file != null) {
1778             result.append(file);
1779         }
1780         if (ref != null) {
1781             result.append(&quot;#&quot;);
1782             result.append(ref);
1783         }
1784         return result.toString();
1785     }
1786 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
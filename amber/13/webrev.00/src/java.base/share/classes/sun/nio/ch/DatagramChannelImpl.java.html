<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/sun/nio/ch/DatagramChannelImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.nio.ch;
  27 
  28 import java.io.FileDescriptor;
  29 import java.io.IOException;
  30 import java.io.UncheckedIOException;
  31 import java.lang.invoke.MethodHandles;
  32 import java.lang.invoke.VarHandle;
  33 import java.lang.ref.Cleaner.Cleanable;
  34 import java.lang.reflect.Method;
  35 import java.net.DatagramSocket;
  36 import java.net.Inet4Address;
  37 import java.net.Inet6Address;
  38 import java.net.InetAddress;
  39 import java.net.InetSocketAddress;
  40 import java.net.NetworkInterface;
  41 import java.net.PortUnreachableException;
  42 import java.net.ProtocolFamily;
  43 import java.net.SocketAddress;
  44 import java.net.SocketException;
  45 import java.net.SocketOption;
  46 import java.net.SocketTimeoutException;
  47 import java.net.StandardProtocolFamily;
  48 import java.net.StandardSocketOptions;
  49 import java.nio.ByteBuffer;
  50 import java.nio.channels.AlreadyBoundException;
  51 import java.nio.channels.AlreadyConnectedException;
  52 import java.nio.channels.AsynchronousCloseException;
  53 import java.nio.channels.ClosedChannelException;
  54 import java.nio.channels.DatagramChannel;
  55 import java.nio.channels.IllegalBlockingModeException;
  56 import java.nio.channels.MembershipKey;
  57 import java.nio.channels.NotYetConnectedException;
  58 import java.nio.channels.SelectionKey;
  59 import java.nio.channels.spi.AbstractSelectableChannel;
  60 import java.nio.channels.spi.SelectorProvider;
  61 import java.security.AccessController;
  62 import java.security.PrivilegedExceptionAction;
  63 import java.util.Collections;
  64 import java.util.HashMap;
  65 import java.util.HashSet;
  66 import java.util.Map;
  67 import java.util.Objects;
  68 import java.util.Set;
  69 import java.util.concurrent.locks.ReentrantLock;
  70 import java.util.function.Consumer;
  71 
  72 import jdk.internal.ref.CleanerFactory;
  73 import sun.net.ResourceManager;
  74 import sun.net.ext.ExtendedSocketOptions;
  75 import sun.net.util.IPAddressUtil;
  76 
  77 /**
  78  * An implementation of DatagramChannels.
  79  */
  80 
  81 class DatagramChannelImpl
  82     extends DatagramChannel
  83     implements SelChImpl
  84 {
  85     // Used to make native read and write calls
  86     private static final NativeDispatcher nd = new DatagramDispatcher();
  87 
  88     // true if interruptible (can be false to emulate legacy DatagramSocket)
  89     private final boolean interruptible;
  90 
  91     // The protocol family of the socket
  92     private final ProtocolFamily family;
  93 
  94     // Our file descriptor
  95     private final FileDescriptor fd;
  96     private final int fdVal;
  97 
  98     // Native sockaddrs and cached InetSocketAddress for receive, protected by readLock
  99     private NativeSocketAddress sourceSockAddr;
 100     private NativeSocketAddress cachedSockAddr;
 101     private InetSocketAddress cachedInetSocketAddress;
 102 
 103     // Native sockaddr and cached objects for send, protected by writeLock
 104     private final NativeSocketAddress targetSockAddr;
 105     private InetSocketAddress previousTarget;
 106     private int previousSockAddrLength;
 107 
 108     // Cleaner to close file descriptor and free native socket address
 109     private final Cleanable cleaner;
 110 
 111     // Lock held by current reading or connecting thread
 112     private final ReentrantLock readLock = new ReentrantLock();
 113 
 114     // Lock held by current writing or connecting thread
 115     private final ReentrantLock writeLock = new ReentrantLock();
 116 
 117     // Lock held by any thread that modifies the state fields declared below
 118     // DO NOT invoke a blocking I/O operation while holding this lock!
 119     private final Object stateLock = new Object();
 120 
 121     // -- The following fields are protected by stateLock
 122 
 123     // State (does not necessarily increase monotonically)
 124     private static final int ST_UNCONNECTED = 0;
 125     private static final int ST_CONNECTED = 1;
 126     private static final int ST_CLOSING = 2;
 127     private static final int ST_CLOSED = 3;
 128     private int state;
 129 
 130     // IDs of native threads doing reads and writes, for signalling
 131     private long readerThread;
 132     private long writerThread;
 133 
 134     // Local and remote (connected) address
 135     private InetSocketAddress localAddress;
 136     private InetSocketAddress remoteAddress;
 137 
 138     // Local address prior to connecting
 139     private InetSocketAddress initialLocalAddress;
 140 
 141     // Socket adaptor, created lazily
 142     private static final VarHandle SOCKET;
 143     static {
 144         try {
 145             MethodHandles.Lookup l = MethodHandles.lookup();
 146             SOCKET = l.findVarHandle(DatagramChannelImpl.class, &quot;socket&quot;, DatagramSocket.class);
 147         } catch (Exception e) {
 148             throw new InternalError(e);
 149         }
 150     }
 151     private volatile DatagramSocket socket;
 152 
 153     // Multicast support
 154     private MembershipRegistry registry;
 155 
 156     // set true when socket is bound and SO_REUSEADDRESS is emulated
 157     private boolean reuseAddressEmulated;
 158 
 159     // set true/false when socket is already bound and SO_REUSEADDR is emulated
 160     private boolean isReuseAddress;
 161 
 162     // -- End of fields protected by stateLock
 163 
 164 
 165     DatagramChannelImpl(SelectorProvider sp, boolean interruptible) throws IOException {
 166         this(sp, (Net.isIPv6Available()
 167                 ? StandardProtocolFamily.INET6
 168                 : StandardProtocolFamily.INET),
 169                 interruptible);
 170     }
 171 
 172     DatagramChannelImpl(SelectorProvider sp, ProtocolFamily family, boolean interruptible)
 173         throws IOException
 174     {
 175         super(sp);
 176 
 177         Objects.requireNonNull(family, &quot;&#39;family&#39; is null&quot;);
 178         if ((family != StandardProtocolFamily.INET) &amp;&amp;
 179                 (family != StandardProtocolFamily.INET6)) {
 180             throw new UnsupportedOperationException(&quot;Protocol family not supported&quot;);
 181         }
 182         if (family == StandardProtocolFamily.INET6 &amp;&amp; !Net.isIPv6Available()) {
 183             throw new UnsupportedOperationException(&quot;IPv6 not available&quot;);
 184         }
 185 
 186         FileDescriptor fd = null;
 187         NativeSocketAddress[] sockAddrs = null;
 188 
 189         ResourceManager.beforeUdpCreate();
 190         boolean initialized = false;
 191         try {
 192             this.interruptible = interruptible;
 193             this.family = family;
 194             this.fd = fd = Net.socket(family, false);
 195             this.fdVal = IOUtil.fdVal(fd);
 196 
 197             sockAddrs = NativeSocketAddress.allocate(3);
 198             readLock.lock();
 199             try {
 200                 this.sourceSockAddr = sockAddrs[0];
 201                 this.cachedSockAddr = sockAddrs[1];
 202             } finally {
 203                 readLock.unlock();
 204             }
 205             this.targetSockAddr = sockAddrs[2];
 206 
 207             initialized = true;
 208         } finally {
 209             if (!initialized) {
 210                 if (sockAddrs != null) NativeSocketAddress.freeAll(sockAddrs);
 211                 if (fd != null) nd.close(fd);
 212                 ResourceManager.afterUdpClose();
 213             }
 214         }
 215 
 216         Runnable releaser = releaserFor(fd, sockAddrs);
 217         this.cleaner = CleanerFactory.cleaner().register(this, releaser);
 218     }
 219 
 220     DatagramChannelImpl(SelectorProvider sp, FileDescriptor fd)
 221         throws IOException
 222     {
 223         super(sp);
 224 
 225         NativeSocketAddress[] sockAddrs = null;
 226 
 227         ResourceManager.beforeUdpCreate();
 228         boolean initialized = false;
 229         try {
 230             this.interruptible = true;
 231             this.family = Net.isIPv6Available()
 232                     ? StandardProtocolFamily.INET6
 233                     : StandardProtocolFamily.INET;
 234             this.fd = fd;
 235             this.fdVal = IOUtil.fdVal(fd);
 236 
 237             sockAddrs = NativeSocketAddress.allocate(3);
 238             readLock.lock();
 239             try {
 240                 this.sourceSockAddr = sockAddrs[0];
 241                 this.cachedSockAddr = sockAddrs[1];
 242             } finally {
 243                 readLock.unlock();
 244             }
 245             this.targetSockAddr = sockAddrs[2];
 246 
 247             initialized = true;
 248         } finally {
 249             if (!initialized) {
 250                 if (sockAddrs != null) NativeSocketAddress.freeAll(sockAddrs);
 251                 nd.close(fd);
 252                 ResourceManager.afterUdpClose();
 253             }
 254         }
 255 
 256         Runnable releaser = releaserFor(fd, sockAddrs);
 257         this.cleaner = CleanerFactory.cleaner().register(this, releaser);
 258 
 259         synchronized (stateLock) {
 260             this.localAddress = Net.localAddress(fd);
 261         }
 262     }
 263 
 264     // @throws ClosedChannelException if channel is closed
 265     private void ensureOpen() throws ClosedChannelException {
 266         if (!isOpen())
 267             throw new ClosedChannelException();
 268     }
 269 
 270     @Override
 271     public DatagramSocket socket() {
 272         DatagramSocket socket = this.socket;
 273         if (socket == null) {
 274             socket = DatagramSocketAdaptor.create(this);
 275             if (!SOCKET.compareAndSet(this, null, socket)) {
 276                 socket = this.socket;
 277             }
 278         }
 279         return socket;
 280     }
 281 
 282     @Override
 283     public SocketAddress getLocalAddress() throws IOException {
 284         synchronized (stateLock) {
 285             ensureOpen();
 286             // Perform security check before returning address
 287             return Net.getRevealedLocalAddress(localAddress);
 288         }
 289     }
 290 
 291     @Override
 292     public SocketAddress getRemoteAddress() throws IOException {
 293         synchronized (stateLock) {
 294             ensureOpen();
 295             return remoteAddress;
 296         }
 297     }
 298 
 299     /**
 300      * Returns the protocol family to specify to set/getSocketOption for the
 301      * given socket option.
 302      */
 303     private ProtocolFamily familyFor(SocketOption&lt;?&gt; name) {
 304         assert Thread.holdsLock(stateLock);
 305 
 306         // unspecified (most options)
 307         if (SocketOptionRegistry.findOption(name, Net.UNSPEC) != null)
 308             return Net.UNSPEC;
 309 
 310         // IPv4 socket
 311         if (family == StandardProtocolFamily.INET)
 312             return StandardProtocolFamily.INET;
 313 
 314         // IPv6 socket that is unbound
 315         if (localAddress == null)
 316             return StandardProtocolFamily.INET6;
 317 
 318         // IPv6 socket bound to wildcard or IPv6 address
 319         InetAddress address = localAddress.getAddress();
 320         if (address.isAnyLocalAddress() || (address instanceof Inet6Address))
 321             return StandardProtocolFamily.INET6;
 322 
 323         // IPv6 socket bound to IPv4 address
 324         if (Net.canUseIPv6OptionsWithIPv4LocalAddress()) {
 325             // IPV6_XXX options can be used
 326             return StandardProtocolFamily.INET6;
 327         } else {
 328             // IPV6_XXX options cannot be used
 329             return StandardProtocolFamily.INET;
 330         }
 331     }
 332 
 333     @Override
 334     public &lt;T&gt; DatagramChannel setOption(SocketOption&lt;T&gt; name, T value)
 335         throws IOException
 336     {
 337         Objects.requireNonNull(name);
 338         if (!supportedOptions().contains(name))
 339             throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);
 340         if (!name.type().isInstance(value))
 341             throw new IllegalArgumentException(&quot;Invalid value &#39;&quot; + value + &quot;&#39;&quot;);
 342 
 343         synchronized (stateLock) {
 344             ensureOpen();
 345 
 346             ProtocolFamily family = familyFor(name);
 347 
 348             // Some platforms require both IPV6_XXX and IP_XXX socket options to
 349             // be set when the channel&#39;s socket is IPv6 and it is used to send
 350             // IPv4 multicast datagrams. The IP_XXX socket options are set on a
 351             // best effort basis.
 352             boolean needToSetIPv4Option = (family != Net.UNSPEC)
 353                     &amp;&amp; (this.family == StandardProtocolFamily.INET6)
 354                     &amp;&amp; Net.shouldSetBothIPv4AndIPv6Options();
 355 
 356             // outgoing multicast interface
 357             if (name == StandardSocketOptions.IP_MULTICAST_IF) {
 358                 assert family != Net.UNSPEC;
 359                 NetworkInterface interf = (NetworkInterface) value;
 360                 if (family == StandardProtocolFamily.INET6) {
 361                     int index = interf.getIndex();
 362                     if (index == -1)
 363                         throw new IOException(&quot;Network interface cannot be identified&quot;);
 364                     Net.setInterface6(fd, index);
 365                 }
 366                 if (family == StandardProtocolFamily.INET || needToSetIPv4Option) {
 367                     // need IPv4 address to identify interface
 368                     Inet4Address target = Net.anyInet4Address(interf);
 369                     if (target != null) {
 370                         try {
 371                             Net.setInterface4(fd, Net.inet4AsInt(target));
 372                         } catch (IOException ioe) {
 373                             if (family == StandardProtocolFamily.INET) throw ioe;
 374                         }
 375                     } else if (family == StandardProtocolFamily.INET) {
 376                         throw new IOException(&quot;Network interface not configured for IPv4&quot;);
 377                     }
 378                 }
 379                 return this;
 380             }
 381 
 382             // SO_REUSEADDR needs special handling as it may be emulated
 383             if (name == StandardSocketOptions.SO_REUSEADDR
 384                 &amp;&amp; Net.useExclusiveBind() &amp;&amp; localAddress != null) {
 385                 reuseAddressEmulated = true;
 386                 this.isReuseAddress = (Boolean)value;
 387             }
 388 
 389             // remaining options don&#39;t need any special handling
 390             Net.setSocketOption(fd, family, name, value);
 391             if (needToSetIPv4Option &amp;&amp; family != StandardProtocolFamily.INET) {
 392                 try {
 393                     Net.setSocketOption(fd, StandardProtocolFamily.INET, name, value);
 394                 } catch (IOException ignore) { }
 395             }
 396 
 397             return this;
 398         }
 399     }
 400 
 401     @Override
 402     @SuppressWarnings(&quot;unchecked&quot;)
 403     public &lt;T&gt; T getOption(SocketOption&lt;T&gt; name)
 404         throws IOException
 405     {
 406         Objects.requireNonNull(name);
 407         if (!supportedOptions().contains(name))
 408             throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);
 409 
 410         synchronized (stateLock) {
 411             ensureOpen();
 412 
 413             ProtocolFamily family = familyFor(name);
 414 
 415             if (name == StandardSocketOptions.IP_MULTICAST_IF) {
 416                 if (family == StandardProtocolFamily.INET) {
 417                     int address = Net.getInterface4(fd);
 418                     if (address == 0)
 419                         return null;    // default interface
 420 
 421                     InetAddress ia = Net.inet4FromInt(address);
 422                     NetworkInterface ni = NetworkInterface.getByInetAddress(ia);
 423                     if (ni == null)
 424                         throw new IOException(&quot;Unable to map address to interface&quot;);
 425                     return (T) ni;
 426                 } else {
 427                     int index = Net.getInterface6(fd);
 428                     if (index == 0)
 429                         return null;    // default interface
 430 
 431                     NetworkInterface ni = NetworkInterface.getByIndex(index);
 432                     if (ni == null)
 433                         throw new IOException(&quot;Unable to map index to interface&quot;);
 434                     return (T) ni;
 435                 }
 436             }
 437 
 438             if (name == StandardSocketOptions.SO_REUSEADDR &amp;&amp; reuseAddressEmulated) {
 439                 return (T) Boolean.valueOf(isReuseAddress);
 440             }
 441 
 442             // no special handling
 443             return (T) Net.getSocketOption(fd, family, name);
 444         }
 445     }
 446 
 447     private static class DefaultOptionsHolder {
 448         static final Set&lt;SocketOption&lt;?&gt;&gt; defaultOptions = defaultOptions();
 449 
 450         private static Set&lt;SocketOption&lt;?&gt;&gt; defaultOptions() {
 451             HashSet&lt;SocketOption&lt;?&gt;&gt; set = new HashSet&lt;&gt;();
 452             set.add(StandardSocketOptions.SO_SNDBUF);
 453             set.add(StandardSocketOptions.SO_RCVBUF);
 454             set.add(StandardSocketOptions.SO_REUSEADDR);
 455             if (Net.isReusePortAvailable()) {
 456                 set.add(StandardSocketOptions.SO_REUSEPORT);
 457             }
 458             set.add(StandardSocketOptions.SO_BROADCAST);
 459             set.add(StandardSocketOptions.IP_TOS);
 460             set.add(StandardSocketOptions.IP_MULTICAST_IF);
 461             set.add(StandardSocketOptions.IP_MULTICAST_TTL);
 462             set.add(StandardSocketOptions.IP_MULTICAST_LOOP);
 463             set.addAll(ExtendedSocketOptions.datagramSocketOptions());
 464             return Collections.unmodifiableSet(set);
 465         }
 466     }
 467 
 468     @Override
 469     public final Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() {
 470         return DefaultOptionsHolder.defaultOptions;
 471     }
 472 
 473     /**
 474      * Marks the beginning of a read operation that might block.
 475      *
 476      * @param blocking true if configured blocking
 477      * @param mustBeConnected true if the socket must be connected
 478      * @return remote address if connected
 479      * @throws ClosedChannelException if the channel is closed
 480      * @throws NotYetConnectedException if mustBeConnected and not connected
 481      * @throws IOException if socket not bound and cannot be bound
 482      */
 483     private SocketAddress beginRead(boolean blocking, boolean mustBeConnected)
 484         throws IOException
 485     {
 486         if (blocking &amp;&amp; interruptible) {
 487             // set hook for Thread.interrupt
 488             begin();
 489         }
 490         SocketAddress remote;
 491         synchronized (stateLock) {
 492             ensureOpen();
 493             remote = remoteAddress;
 494             if ((remote == null) &amp;&amp; mustBeConnected)
 495                 throw new NotYetConnectedException();
 496             if (localAddress == null)
 497                 bindInternal(null);
 498             if (blocking)
 499                 readerThread = NativeThread.current();
 500         }
 501         return remote;
 502     }
 503 
 504     /**
 505      * Marks the end of a read operation that may have blocked.
 506      *
 507      * @throws AsynchronousCloseException if the channel was closed asynchronously
 508      */
 509     private void endRead(boolean blocking, boolean completed)
 510         throws AsynchronousCloseException
 511     {
 512         if (blocking) {
 513             synchronized (stateLock) {
 514                 readerThread = 0;
 515                 if (state == ST_CLOSING) {
 516                     tryFinishClose();
 517                 }
 518             }
 519             if (interruptible) {
 520                 // remove hook for Thread.interrupt (may throw AsynchronousCloseException)
 521                 end(completed);
 522             } else if (!completed &amp;&amp; !isOpen()) {
 523                 throw new AsynchronousCloseException();
 524             }
 525         }
 526     }
 527 
 528     @Override
 529     public SocketAddress receive(ByteBuffer dst) throws IOException {
 530         if (dst.isReadOnly())
 531             throw new IllegalArgumentException(&quot;Read-only buffer&quot;);
 532         readLock.lock();
 533         try {
 534             boolean blocking = isBlocking();
 535             SocketAddress sender = null;
 536             try {
 537                 SocketAddress remote = beginRead(blocking, false);
 538                 boolean connected = (remote != null);
 539                 SecurityManager sm = System.getSecurityManager();
 540                 if (connected || (sm == null)) {
 541                     // connected or no security manager
 542                     int n = receive(dst, connected);
 543                     if (blocking) {
 544                         while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {
 545                             park(Net.POLLIN);
 546                             n = receive(dst, connected);
 547                         }
 548                     }
 549                     if (n &gt;= 0) {
 550                         // sender address is in socket address buffer
 551                         sender = sourceSocketAddress();
 552                     }
 553                 } else {
 554                     // security manager and unconnected
 555                     sender = untrustedReceive(dst);
 556                 }
 557                 return sender;
 558             } finally {
 559                 endRead(blocking, (sender != null));
 560             }
 561         } finally {
 562             readLock.unlock();
 563         }
 564     }
 565 
 566     /**
 567      * Receives a datagram into an untrusted buffer. When there is a security
 568      * manager set, and the socket is not connected, datagrams have to be received
 569      * into a buffer that is not accessible to the user. The datagram is copied
 570      * into the user&#39;s buffer when the sender address is accepted by the security
 571      * manager.
 572      */
 573     private SocketAddress untrustedReceive(ByteBuffer dst) throws IOException {
 574         SecurityManager sm = System.getSecurityManager();
 575         assert readLock.isHeldByCurrentThread()
 576                 &amp;&amp; sm != null &amp;&amp; remoteAddress == null;
 577 
 578         ByteBuffer bb = Util.getTemporaryDirectBuffer(dst.remaining());
 579         try {
 580             boolean blocking = isBlocking();
 581             for (;;) {
 582                 int n = receive(bb, false);
 583                 if (blocking) {
 584                     while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {
 585                         park(Net.POLLIN);
 586                         n = receive(bb, false);
 587                     }
 588                 }
 589                 if (n &gt;= 0) {
 590                     // sender address is in socket address buffer
 591                     InetSocketAddress isa = sourceSocketAddress();
 592                     try {
 593                         sm.checkAccept(isa.getAddress().getHostAddress(), isa.getPort());
 594                         bb.flip();
 595                         dst.put(bb);
 596                         return isa;
 597                     } catch (SecurityException se) {
 598                         // ignore datagram
 599                         bb.clear();
 600                     }
 601                 } else {
 602                     return null;
 603                 }
 604             }
 605         } finally {
 606             Util.releaseTemporaryDirectBuffer(bb);
 607         }
 608     }
 609 
 610     /**
 611      * Receives a datagram into the given buffer.
 612      *
 613      * @apiNote This method is for use by the socket adaptor. The buffer is
 614      * assumed to be trusted, meaning it is not accessible to user code.
 615      *
 616      * @throws IllegalBlockingModeException if the channel is non-blocking
 617      * @throws SocketTimeoutException if the timeout elapses
 618      */
 619     SocketAddress blockingReceive(ByteBuffer dst, long nanos) throws IOException {
 620         readLock.lock();
 621         try {
 622             ensureOpen();
 623             if (!isBlocking())
 624                 throw new IllegalBlockingModeException();
 625             SecurityManager sm = System.getSecurityManager();
 626             boolean connected = isConnected();
 627             SocketAddress sender;
 628             do {
 629                 if (nanos &gt; 0) {
 630                     sender = trustedBlockingReceive(dst, nanos);
 631                 } else {
 632                     sender = trustedBlockingReceive(dst);
 633                 }
 634                 // check sender when security manager set and not connected
 635                 if (sm != null &amp;&amp; !connected) {
 636                     InetSocketAddress isa = (InetSocketAddress) sender;
 637                     try {
 638                         sm.checkAccept(isa.getAddress().getHostAddress(), isa.getPort());
 639                     } catch (SecurityException e) {
 640                         sender = null;
 641                     }
 642                 }
 643             } while (sender == null);
 644             return sender;
 645         } finally {
 646             readLock.unlock();
 647         }
 648     }
 649 
 650     /**
 651      * Receives a datagram into given buffer. This method is used to support
 652      * the socket adaptor. The buffer is assumed to be trusted.
 653      * @throws SocketTimeoutException if the timeout elapses
 654      */
 655     private SocketAddress trustedBlockingReceive(ByteBuffer dst)
 656         throws IOException
 657     {
 658         assert readLock.isHeldByCurrentThread() &amp;&amp; isBlocking();
 659         SocketAddress sender = null;
 660         try {
 661             SocketAddress remote = beginRead(true, false);
 662             boolean connected = (remote != null);
 663             int n = receive(dst, connected);
 664             while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {
 665                 park(Net.POLLIN);
 666                 n = receive(dst, connected);
 667             }
 668             if (n &gt;= 0) {
 669                 // sender address is in socket address buffer
 670                 sender = sourceSocketAddress();
 671             }
 672             return sender;
 673         } finally {
 674             endRead(true, (sender != null));
 675         }
 676     }
 677 
 678     /**
 679      * Receives a datagram into given buffer with a timeout. This method is
 680      * used to support the socket adaptor. The buffer is assumed to be trusted.
 681      * @throws SocketTimeoutException if the timeout elapses
 682      */
 683     private SocketAddress trustedBlockingReceive(ByteBuffer dst, long nanos)
 684         throws IOException
 685     {
 686         assert readLock.isHeldByCurrentThread() &amp;&amp; isBlocking();
 687         SocketAddress sender = null;
 688         try {
 689             SocketAddress remote = beginRead(true, false);
 690             boolean connected = (remote != null);
 691 
 692             // change socket to non-blocking
 693             lockedConfigureBlocking(false);
 694             try {
 695                 long startNanos = System.nanoTime();
 696                 int n = receive(dst, connected);
 697                 while (n == IOStatus.UNAVAILABLE &amp;&amp; isOpen()) {
 698                     long remainingNanos = nanos - (System.nanoTime() - startNanos);
 699                     if (remainingNanos &lt;= 0) {
 700                         throw new SocketTimeoutException(&quot;Receive timed out&quot;);
 701                     }
 702                     park(Net.POLLIN, remainingNanos);
 703                     n = receive(dst, connected);
 704                 }
 705                 if (n &gt;= 0) {
 706                     // sender address is in socket address buffer
 707                     sender = sourceSocketAddress();
 708                 }
 709                 return sender;
 710             } finally {
 711                 // restore socket to blocking mode (if channel is open)
 712                 tryLockedConfigureBlocking(true);
 713             }
 714         } finally {
 715             endRead(true, (sender != null));
 716         }
 717     }
 718 
 719     private int receive(ByteBuffer dst, boolean connected) throws IOException {
 720         int pos = dst.position();
 721         int lim = dst.limit();
 722         assert (pos &lt;= lim);
 723         int rem = (pos &lt;= lim ? lim - pos : 0);
 724         if (dst instanceof DirectBuffer &amp;&amp; rem &gt; 0)
 725             return receiveIntoNativeBuffer(dst, rem, pos, connected);
 726 
 727         // Substitute a native buffer. If the supplied buffer is empty
 728         // we must instead use a nonempty buffer, otherwise the call
 729         // will not block waiting for a datagram on some platforms.
 730         int newSize = Math.max(rem, 1);
 731         ByteBuffer bb = Util.getTemporaryDirectBuffer(newSize);
 732         try {
 733             int n = receiveIntoNativeBuffer(bb, newSize, 0, connected);
 734             bb.flip();
 735             if (n &gt; 0 &amp;&amp; rem &gt; 0)
 736                 dst.put(bb);
 737             return n;
 738         } finally {
 739             Util.releaseTemporaryDirectBuffer(bb);
 740         }
 741     }
 742 
 743     private int receiveIntoNativeBuffer(ByteBuffer bb, int rem, int pos,
 744                                         boolean connected)
 745         throws IOException
 746     {
 747         int n = receive0(fd,
 748                          ((DirectBuffer)bb).address() + pos, rem,
 749                          sourceSockAddr.address(),
 750                          connected);
 751         if (n &gt; 0)
 752             bb.position(pos + n);
 753         return n;
 754     }
 755 
 756     /**
 757      * Return an InetSocketAddress to represent the source/sender socket address
 758      * in sourceSockAddr. Returns the cached InetSocketAddress if the source
 759      * address is the same as the cached address.
 760      */
 761     private InetSocketAddress sourceSocketAddress() throws IOException {
 762         assert readLock.isHeldByCurrentThread();
 763         if (cachedInetSocketAddress != null &amp;&amp; sourceSockAddr.equals(cachedSockAddr)) {
 764             return cachedInetSocketAddress;
 765         }
 766         InetSocketAddress isa = sourceSockAddr.decode();
 767         // swap sourceSockAddr and cachedSockAddr
 768         NativeSocketAddress tmp = cachedSockAddr;
 769         cachedSockAddr = sourceSockAddr;
 770         sourceSockAddr = tmp;
 771         cachedInetSocketAddress = isa;
 772         return isa;
 773     }
 774 
 775     @Override
 776     public int send(ByteBuffer src, SocketAddress target)
 777         throws IOException
 778     {
 779         Objects.requireNonNull(src);
 780         InetSocketAddress isa = Net.checkAddress(target, family);
 781 
 782         writeLock.lock();
 783         try {
 784             boolean blocking = isBlocking();
 785             int n;
 786             boolean completed = false;
 787             try {
 788                 SocketAddress remote = beginWrite(blocking, false);
 789                 if (remote != null) {
 790                     // connected
 791                     if (!target.equals(remote)) {
 792                         throw new AlreadyConnectedException();
 793                     }
 794                     n = IOUtil.write(fd, src, -1, nd);
 795                     if (blocking) {
 796                         while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {
 797                             park(Net.POLLOUT);
 798                             n = IOUtil.write(fd, src, -1, nd);
 799                         }
 800                     }
 801                     completed = (n &gt; 0);
 802                 } else {
 803                     // not connected
 804                     SecurityManager sm = System.getSecurityManager();
 805                     InetAddress ia = isa.getAddress();
 806                     if (sm != null) {
 807                         if (ia.isMulticastAddress()) {
 808                             sm.checkMulticast(ia);
 809                         } else {
 810                             sm.checkConnect(ia.getHostAddress(), isa.getPort());
 811                         }
 812                     }
 813                     if (ia.isLinkLocalAddress())
 814                         isa = IPAddressUtil.toScopedAddress(isa);
 815                     if (isa.getPort() == 0)
 816                         throw new SocketException(&quot;Can&#39;t send to port 0&quot;);
 817                     n = send(fd, src, isa);
 818                     if (blocking) {
 819                         while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {
 820                             park(Net.POLLOUT);
 821                             n = send(fd, src, isa);
 822                         }
 823                     }
 824                     completed = (n &gt;= 0);
 825                 }
 826             } finally {
 827                 endWrite(blocking, completed);
 828             }
 829             assert n &gt;= 0 || n == IOStatus.UNAVAILABLE;
 830             return IOStatus.normalize(n);
 831         } finally {
 832             writeLock.unlock();
 833         }
 834     }
 835 
 836     /**
 837      * Sends a datagram from the bytes in given buffer.
 838      *
 839      * @apiNote This method is for use by the socket adaptor.
 840      *
 841      * @throws IllegalBlockingModeException if the channel is non-blocking
 842      */
 843     void blockingSend(ByteBuffer src, SocketAddress target) throws IOException {
 844         writeLock.lock();
 845         try {
 846             ensureOpen();
 847             if (!isBlocking())
 848                 throw new IllegalBlockingModeException();
 849             send(src, target);
 850         } finally {
 851             writeLock.unlock();
 852         }
 853     }
 854 
 855     private int send(FileDescriptor fd, ByteBuffer src, InetSocketAddress target)
 856         throws IOException
 857     {
 858         if (src instanceof DirectBuffer)
 859             return sendFromNativeBuffer(fd, src, target);
 860 
 861         // Substitute a native buffer
 862         int pos = src.position();
 863         int lim = src.limit();
 864         assert (pos &lt;= lim);
 865         int rem = (pos &lt;= lim ? lim - pos : 0);
 866 
 867         ByteBuffer bb = Util.getTemporaryDirectBuffer(rem);
 868         try {
 869             bb.put(src);
 870             bb.flip();
 871             // Do not update src until we see how many bytes were written
 872             src.position(pos);
 873 
 874             int n = sendFromNativeBuffer(fd, bb, target);
 875             if (n &gt; 0) {
 876                 // now update src
 877                 src.position(pos + n);
 878             }
 879             return n;
 880         } finally {
 881             Util.releaseTemporaryDirectBuffer(bb);
 882         }
 883     }
 884 
 885     private int sendFromNativeBuffer(FileDescriptor fd, ByteBuffer bb,
 886                                      InetSocketAddress target)
 887         throws IOException
 888     {
 889         int pos = bb.position();
 890         int lim = bb.limit();
 891         assert (pos &lt;= lim);
 892         int rem = (pos &lt;= lim ? lim - pos : 0);
 893 
 894         int written;
 895         try {
 896             int addressLen = targetSocketAddress(target);
 897             written = send0(fd, ((DirectBuffer)bb).address() + pos, rem,
 898                             targetSockAddr.address(), addressLen);
 899         } catch (PortUnreachableException pue) {
 900             if (isConnected())
 901                 throw pue;
 902             written = rem;
 903         }
 904         if (written &gt; 0)
 905             bb.position(pos + written);
 906         return written;
 907     }
 908 
 909     /**
 910      * Encodes the given InetSocketAddress into targetSockAddr, returning the
 911      * length of the sockaddr structure (sizeof struct sockaddr or sockaddr6).
 912      */
 913     private int targetSocketAddress(InetSocketAddress isa) {
 914         assert writeLock.isHeldByCurrentThread();
 915         // Nothing to do if target address is already in the buffer. Use
 916         // identity rather than equals as Inet6Address.equals ignores scope_id.
 917         if (isa == previousTarget)
 918             return previousSockAddrLength;
 919         previousTarget = null;
 920         int len = targetSockAddr.encode(family, isa);
 921         previousTarget = isa;
 922         previousSockAddrLength = len;
 923         return len;
 924     }
 925 
 926     @Override
 927     public int read(ByteBuffer buf) throws IOException {
 928         Objects.requireNonNull(buf);
 929 
 930         readLock.lock();
 931         try {
 932             boolean blocking = isBlocking();
 933             int n = 0;
 934             try {
 935                 beginRead(blocking, true);
 936                 n = IOUtil.read(fd, buf, -1, nd);
 937                 if (blocking) {
 938                     while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {
 939                         park(Net.POLLIN);
 940                         n = IOUtil.read(fd, buf, -1, nd);
 941                     }
 942                 }
 943             } finally {
 944                 endRead(blocking, n &gt; 0);
 945                 assert IOStatus.check(n);
 946             }
 947             return IOStatus.normalize(n);
 948         } finally {
 949             readLock.unlock();
 950         }
 951     }
 952 
 953     @Override
 954     public long read(ByteBuffer[] dsts, int offset, int length)
 955         throws IOException
 956     {
 957         Objects.checkFromIndexSize(offset, length, dsts.length);
 958 
 959         readLock.lock();
 960         try {
 961             boolean blocking = isBlocking();
 962             long n = 0;
 963             try {
 964                 beginRead(blocking, true);
 965                 n = IOUtil.read(fd, dsts, offset, length, nd);
 966                 if (blocking) {
 967                     while (IOStatus.okayToRetry(n)  &amp;&amp; isOpen()) {
 968                         park(Net.POLLIN);
 969                         n = IOUtil.read(fd, dsts, offset, length, nd);
 970                     }
 971                 }
 972             } finally {
 973                 endRead(blocking, n &gt; 0);
 974                 assert IOStatus.check(n);
 975             }
 976             return IOStatus.normalize(n);
 977         } finally {
 978             readLock.unlock();
 979         }
 980     }
 981 
 982     /**
 983      * Marks the beginning of a write operation that might block.
 984      * @param blocking true if configured blocking
 985      * @param mustBeConnected true if the socket must be connected
 986      * @return remote address if connected
 987      * @throws ClosedChannelException if the channel is closed
 988      * @throws NotYetConnectedException if mustBeConnected and not connected
 989      * @throws IOException if socket not bound and cannot be bound
 990      */
 991     private SocketAddress beginWrite(boolean blocking, boolean mustBeConnected)
 992         throws IOException
 993     {
 994         if (blocking &amp;&amp; interruptible) {
 995             // set hook for Thread.interrupt
 996             begin();
 997         }
 998         SocketAddress remote;
 999         synchronized (stateLock) {
1000             ensureOpen();
1001             remote = remoteAddress;
1002             if ((remote == null) &amp;&amp; mustBeConnected)
1003                 throw new NotYetConnectedException();
1004             if (localAddress == null)
1005                 bindInternal(null);
1006             if (blocking)
1007                 writerThread = NativeThread.current();
1008         }
1009         return remote;
1010     }
1011 
1012     /**
1013      * Marks the end of a write operation that may have blocked.
1014      *
1015      * @throws AsynchronousCloseException if the channel was closed asynchronously
1016      */
1017     private void endWrite(boolean blocking, boolean completed)
1018         throws AsynchronousCloseException
1019     {
1020         if (blocking) {
1021             synchronized (stateLock) {
1022                 writerThread = 0;
1023                 if (state == ST_CLOSING) {
1024                     tryFinishClose();
1025                 }
1026             }
1027 
1028             if (interruptible) {
1029                 // remove hook for Thread.interrupt (may throw AsynchronousCloseException)
1030                 end(completed);
1031             } else if (!completed &amp;&amp; !isOpen()) {
1032                 throw new AsynchronousCloseException();
1033             }
1034         }
1035     }
1036 
1037     @Override
1038     public int write(ByteBuffer buf) throws IOException {
1039         Objects.requireNonNull(buf);
1040 
1041         writeLock.lock();
1042         try {
1043             boolean blocking = isBlocking();
1044             int n = 0;
1045             try {
1046                 beginWrite(blocking, true);
1047                 n = IOUtil.write(fd, buf, -1, nd);
1048                 if (blocking) {
1049                     while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {
1050                         park(Net.POLLOUT);
1051                         n = IOUtil.write(fd, buf, -1, nd);
1052                     }
1053                 }
1054             } finally {
1055                 endWrite(blocking, n &gt; 0);
1056                 assert IOStatus.check(n);
1057             }
1058             return IOStatus.normalize(n);
1059         } finally {
1060             writeLock.unlock();
1061         }
1062     }
1063 
1064     @Override
1065     public long write(ByteBuffer[] srcs, int offset, int length)
1066         throws IOException
1067     {
1068         Objects.checkFromIndexSize(offset, length, srcs.length);
1069 
1070         writeLock.lock();
1071         try {
1072             boolean blocking = isBlocking();
1073             long n = 0;
1074             try {
1075                 beginWrite(blocking, true);
1076                 n = IOUtil.write(fd, srcs, offset, length, nd);
1077                 if (blocking) {
1078                     while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {
1079                         park(Net.POLLOUT);
1080                         n = IOUtil.write(fd, srcs, offset, length, nd);
1081                     }
1082                 }
1083             } finally {
1084                 endWrite(blocking, n &gt; 0);
1085                 assert IOStatus.check(n);
1086             }
1087             return IOStatus.normalize(n);
1088         } finally {
1089             writeLock.unlock();
1090         }
1091     }
1092 
1093     @Override
1094     protected void implConfigureBlocking(boolean block) throws IOException {
1095         readLock.lock();
1096         try {
1097             writeLock.lock();
1098             try {
1099                 lockedConfigureBlocking(block);
1100             } finally {
1101                 writeLock.unlock();
1102             }
1103         } finally {
1104             readLock.unlock();
1105         }
1106     }
1107 
1108     /**
1109      * Adjusts the blocking mode. readLock or writeLock must already be held.
1110      */
1111     private void lockedConfigureBlocking(boolean block) throws IOException {
1112         assert readLock.isHeldByCurrentThread() || writeLock.isHeldByCurrentThread();
1113         synchronized (stateLock) {
1114             ensureOpen();
1115             IOUtil.configureBlocking(fd, block);
1116         }
1117     }
1118 
1119     /**
1120      * Adjusts the blocking mode if the channel is open. readLock or writeLock
1121      * must already be held.
1122      *
1123      * @return {@code true} if the blocking mode was adjusted, {@code false} if
1124      *         the blocking mode was not adjusted because the channel is closed
1125      */
1126     private boolean tryLockedConfigureBlocking(boolean block) throws IOException {
1127         assert readLock.isHeldByCurrentThread() || writeLock.isHeldByCurrentThread();
1128         synchronized (stateLock) {
1129             if (isOpen()) {
1130                 IOUtil.configureBlocking(fd, block);
1131                 return true;
1132             } else {
1133                 return false;
1134             }
1135         }
1136     }
1137 
1138     InetSocketAddress localAddress() {
1139         synchronized (stateLock) {
1140             return localAddress;
1141         }
1142     }
1143 
1144     InetSocketAddress remoteAddress() {
1145         synchronized (stateLock) {
1146             return remoteAddress;
1147         }
1148     }
1149 
1150     @Override
1151     public DatagramChannel bind(SocketAddress local) throws IOException {
1152         readLock.lock();
1153         try {
1154             writeLock.lock();
1155             try {
1156                 synchronized (stateLock) {
1157                     ensureOpen();
1158                     if (localAddress != null)
1159                         throw new AlreadyBoundException();
1160                     bindInternal(local);
1161                 }
1162             } finally {
1163                 writeLock.unlock();
1164             }
1165         } finally {
1166             readLock.unlock();
1167         }
1168         return this;
1169     }
1170 
1171     private void bindInternal(SocketAddress local) throws IOException {
1172         assert Thread.holdsLock(stateLock )&amp;&amp; (localAddress == null);
1173 
1174         InetSocketAddress isa;
1175         if (local == null) {
1176             // only Inet4Address allowed with IPv4 socket
1177             if (family == StandardProtocolFamily.INET) {
1178                 isa = new InetSocketAddress(InetAddress.getByName(&quot;0.0.0.0&quot;), 0);
1179             } else {
1180                 isa = new InetSocketAddress(0);
1181             }
1182         } else {
1183             isa = Net.checkAddress(local, family);
1184         }
1185         SecurityManager sm = System.getSecurityManager();
1186         if (sm != null)
1187             sm.checkListen(isa.getPort());
1188 
1189         Net.bind(family, fd, isa.getAddress(), isa.getPort());
1190         localAddress = Net.localAddress(fd);
1191     }
1192 
1193     @Override
1194     public boolean isConnected() {
1195         synchronized (stateLock) {
1196             return (state == ST_CONNECTED);
1197         }
1198     }
1199 
1200     @Override
1201     public DatagramChannel connect(SocketAddress sa) throws IOException {
1202         return connect(sa, true);
1203     }
1204 
1205     /**
1206      * Connects the channel&#39;s socket.
1207      *
1208      * @param sa the remote address to which this channel is to be connected
1209      * @param check true to check if the channel is already connected.
1210      */
1211     DatagramChannel connect(SocketAddress sa, boolean check) throws IOException {
1212         InetSocketAddress isa = Net.checkAddress(sa, family);
1213         SecurityManager sm = System.getSecurityManager();
1214         if (sm != null) {
1215             InetAddress ia = isa.getAddress();
1216             if (ia.isMulticastAddress()) {
1217                 sm.checkMulticast(ia);
1218             } else {
1219                 sm.checkConnect(ia.getHostAddress(), isa.getPort());
1220                 sm.checkAccept(ia.getHostAddress(), isa.getPort());
1221             }
1222         }
1223 
1224         readLock.lock();
1225         try {
1226             writeLock.lock();
1227             try {
1228                 synchronized (stateLock) {
1229                     ensureOpen();
1230                     if (check &amp;&amp; state == ST_CONNECTED)
1231                         throw new AlreadyConnectedException();
1232                     if (isa.getPort() == 0)
1233                         throw new SocketException(&quot;Can&#39;t connect to port 0&quot;);
1234 
1235                     // ensure that the socket is bound
1236                     if (localAddress == null) {
1237                         bindInternal(null);
1238                     }
1239 
1240                     // capture local address before connect
1241                     initialLocalAddress = localAddress;
1242 
1243                     int n = Net.connect(family,
1244                                         fd,
1245                                         isa.getAddress(),
1246                                         isa.getPort());
1247                     if (n &lt;= 0)
1248                         throw new Error();      // Can&#39;t happen
1249 
1250                     // connected
1251                     remoteAddress = isa;
1252                     state = ST_CONNECTED;
1253 
1254                     // refresh local address
1255                     localAddress = Net.localAddress(fd);
1256 
1257                     // flush any packets already received.
1258                     boolean blocking = isBlocking();
1259                     if (blocking) {
1260                         IOUtil.configureBlocking(fd, false);
1261                     }
1262                     try {
1263                         ByteBuffer buf = ByteBuffer.allocate(100);
1264                         while (receive(buf, false) &gt;= 0) {
1265                             buf.clear();
1266                         }
1267                     } finally {
1268                         if (blocking) {
1269                             IOUtil.configureBlocking(fd, true);
1270                         }
1271                     }
1272                 }
1273             } finally {
1274                 writeLock.unlock();
1275             }
1276         } finally {
1277             readLock.unlock();
1278         }
1279         return this;
1280     }
1281 
1282     @Override
1283     public DatagramChannel disconnect() throws IOException {
1284         readLock.lock();
1285         try {
1286             writeLock.lock();
1287             try {
1288                 synchronized (stateLock) {
1289                     if (!isOpen() || (state != ST_CONNECTED))
1290                         return this;
1291 
1292                     // disconnect socket
1293                     boolean isIPv6 = (family == StandardProtocolFamily.INET6);
1294                     disconnect0(fd, isIPv6);
1295 
1296                     // no longer connected
1297                     remoteAddress = null;
1298                     state = ST_UNCONNECTED;
1299 
1300                     // refresh localAddress, should be same as it was prior to connect
1301                     localAddress = Net.localAddress(fd);
1302                     try {
1303                         if (!localAddress.equals(initialLocalAddress)) {
1304                             // Workaround connect(2) issues on Linux and macOS
1305                             repairSocket(initialLocalAddress);
1306                             assert (localAddress != null)
1307                                     &amp;&amp; localAddress.equals(Net.localAddress(fd))
1308                                     &amp;&amp; localAddress.equals(initialLocalAddress);
1309                         }
1310                     } finally {
1311                         initialLocalAddress = null;
1312                     }
1313                 }
1314             } finally {
1315                 writeLock.unlock();
1316             }
1317         } finally {
1318             readLock.unlock();
1319         }
1320         return this;
1321     }
1322 
1323     /**
1324      * &quot;Repair&quot; the channel&#39;s socket after a disconnect that didn&#39;t restore the
1325      * local address.
1326      *
1327      * On Linux, connect(2) dissolves the association but changes the local port
1328      * to 0 when it was initially bound to an ephemeral port. The workaround here
1329      * is to rebind to the original port.
1330      *
1331      * On macOS, connect(2) dissolves the association but rebinds the socket to
1332      * the wildcard address when it was initially bound to a specific address.
1333      * The workaround here is to re-create the socket.
1334      */
1335     private void repairSocket(InetSocketAddress target)
1336         throws IOException
1337     {
1338         assert Thread.holdsLock(stateLock);
1339 
1340         // Linux: try to bind the socket to the original address/port
1341         if (localAddress.getPort() == 0) {
1342             assert localAddress.getAddress().equals(target.getAddress());
1343             Net.bind(family, fd, target.getAddress(), target.getPort());
1344             localAddress = Net.localAddress(fd);
1345             return;
1346         }
1347 
1348         // capture the value of all existing socket options
1349         Map&lt;SocketOption&lt;?&gt;, Object&gt; map = new HashMap&lt;&gt;();
1350         for (SocketOption&lt;?&gt; option : supportedOptions()) {
1351             Object value = getOption(option);
1352             if (value != null) {
1353                 map.put(option, value);
1354             }
1355         }
1356 
1357         // macOS: re-create the socket.
1358         FileDescriptor newfd = Net.socket(family, false);
1359         try {
1360             // copy the socket options that are protocol family agnostic
1361             for (Map.Entry&lt;SocketOption&lt;?&gt;, Object&gt; e : map.entrySet()) {
1362                 SocketOption&lt;?&gt; option = e.getKey();
1363                 if (SocketOptionRegistry.findOption(option, Net.UNSPEC) != null) {
1364                     Object value = e.getValue();
1365                     try {
1366                         Net.setSocketOption(newfd, Net.UNSPEC, option, value);
1367                     } catch (IOException ignore) { }
1368                 }
1369             }
1370 
1371             // copy the blocking mode
1372             if (!isBlocking()) {
1373                 IOUtil.configureBlocking(newfd, false);
1374             }
1375 
1376             // dup this channel&#39;s socket to the new socket. If this succeeds then
1377             // fd will reference the new socket. If it fails then it will still
1378             // reference the old socket.
1379             nd.dup(newfd, fd);
1380         } finally {
1381             // release the file descriptor
1382             nd.close(newfd);
1383         }
1384 
1385         // bind to the original local address
1386         try {
1387             Net.bind(family, fd, target.getAddress(), target.getPort());
1388         } catch (IOException ioe) {
1389             // bind failed, socket is left unbound
1390             localAddress = null;
1391             throw ioe;
1392         }
1393 
1394         // restore local address
1395         localAddress = Net.localAddress(fd);
1396 
1397         // restore all socket options (including those set in first pass)
1398         for (Map.Entry&lt;SocketOption&lt;?&gt;, Object&gt; e : map.entrySet()) {
1399             @SuppressWarnings(&quot;unchecked&quot;)
1400             SocketOption&lt;Object&gt; option = (SocketOption&lt;Object&gt;) e.getKey();
1401             Object value = e.getValue();
1402             try {
1403                 setOption(option, value);
1404             } catch (IOException ignore) { }
1405         }
1406 
1407         // restore multicast group membership
1408         MembershipRegistry registry = this.registry;
1409         if (registry != null) {
1410             registry.forEach(k -&gt; {
1411                 if (k instanceof MembershipKeyImpl.Type6) {
1412                     MembershipKeyImpl.Type6 key6 = (MembershipKeyImpl.Type6) k;
1413                     Net.join6(fd, key6.groupAddress(), key6.index(), key6.source());
1414                 } else {
1415                     MembershipKeyImpl.Type4 key4 = (MembershipKeyImpl.Type4) k;
1416                     Net.join4(fd, key4.groupAddress(), key4.interfaceAddress(), key4.source());
1417                 }
1418             });
1419         }
1420 
1421         // reset registration in all Selectors that this channel is registered with
1422         AbstractSelectableChannels.forEach(this, SelectionKeyImpl::reset);
1423     }
1424 
1425     /**
1426      * Defines static methods to access AbstractSelectableChannel non-public members.
1427      */
1428     private static class AbstractSelectableChannels {
1429         private static final Method FOREACH;
1430         static {
1431             try {
1432                 PrivilegedExceptionAction&lt;Method&gt; pae = () -&gt; {
1433                     Method m = AbstractSelectableChannel.class.getDeclaredMethod(&quot;forEach&quot;, Consumer.class);
1434                     m.setAccessible(true);
1435                     return m;
1436                 };
1437                 FOREACH = AccessController.doPrivileged(pae);
1438             } catch (Exception e) {
1439                 throw new InternalError(e);
1440             }
1441         }
1442         static void forEach(AbstractSelectableChannel ch, Consumer&lt;SelectionKeyImpl&gt; action) {
1443             try {
1444                 FOREACH.invoke(ch, action);
1445             } catch (Exception e) {
1446                 throw new InternalError(e);
1447             }
1448         }
1449     }
1450 
1451     /**
1452      * Joins channel&#39;s socket to the given group/interface and
1453      * optional source address.
1454      */
1455     private MembershipKey innerJoin(InetAddress group,
1456                                     NetworkInterface interf,
1457                                     InetAddress source)
1458         throws IOException
1459     {
1460         if (!group.isMulticastAddress())
1461             throw new IllegalArgumentException(&quot;Group not a multicast address&quot;);
1462 
1463         // check multicast address is compatible with this socket
1464         if (group instanceof Inet4Address) {
1465             if (family == StandardProtocolFamily.INET6 &amp;&amp; !Net.canIPv6SocketJoinIPv4Group())
1466                 throw new IllegalArgumentException(&quot;IPv6 socket cannot join IPv4 multicast group&quot;);
1467         } else if (group instanceof Inet6Address) {
1468             if (family != StandardProtocolFamily.INET6)
1469                 throw new IllegalArgumentException(&quot;Only IPv6 sockets can join IPv6 multicast group&quot;);
1470         } else {
1471             throw new IllegalArgumentException(&quot;Address type not supported&quot;);
1472         }
1473 
1474         // check source address
1475         if (source != null) {
1476             if (source.isAnyLocalAddress())
1477                 throw new IllegalArgumentException(&quot;Source address is a wildcard address&quot;);
1478             if (source.isMulticastAddress())
1479                 throw new IllegalArgumentException(&quot;Source address is multicast address&quot;);
1480             if (source.getClass() != group.getClass())
1481                 throw new IllegalArgumentException(&quot;Source address is different type to group&quot;);
1482         }
1483 
1484         SecurityManager sm = System.getSecurityManager();
1485         if (sm != null)
1486             sm.checkMulticast(group);
1487 
1488         synchronized (stateLock) {
1489             ensureOpen();
1490 
1491             // check the registry to see if we are already a member of the group
1492             if (registry == null) {
1493                 registry = new MembershipRegistry();
1494             } else {
1495                 // return existing membership key
1496                 MembershipKey key = registry.checkMembership(group, interf, source);
1497                 if (key != null)
1498                     return key;
1499             }
1500 
1501             MembershipKeyImpl key;
1502             if ((family == StandardProtocolFamily.INET6) &amp;&amp;
1503                 ((group instanceof Inet6Address) || Net.canJoin6WithIPv4Group()))
1504             {
1505                 int index = interf.getIndex();
1506                 if (index == -1)
1507                     throw new IOException(&quot;Network interface cannot be identified&quot;);
1508 
1509                 // need multicast and source address as byte arrays
1510                 byte[] groupAddress = Net.inet6AsByteArray(group);
1511                 byte[] sourceAddress = (source == null) ? null :
1512                     Net.inet6AsByteArray(source);
1513 
1514                 // join the group
1515                 int n = Net.join6(fd, groupAddress, index, sourceAddress);
1516                 if (n == IOStatus.UNAVAILABLE)
1517                     throw new UnsupportedOperationException();
1518 
1519                 key = new MembershipKeyImpl.Type6(this, group, interf, source,
1520                                                   groupAddress, index, sourceAddress);
1521 
1522             } else {
1523                 // need IPv4 address to identify interface
1524                 Inet4Address target = Net.anyInet4Address(interf);
1525                 if (target == null)
1526                     throw new IOException(&quot;Network interface not configured for IPv4&quot;);
1527 
1528                 int groupAddress = Net.inet4AsInt(group);
1529                 int targetAddress = Net.inet4AsInt(target);
1530                 int sourceAddress = (source == null) ? 0 : Net.inet4AsInt(source);
1531 
1532                 // join the group
1533                 int n = Net.join4(fd, groupAddress, targetAddress, sourceAddress);
1534                 if (n == IOStatus.UNAVAILABLE)
1535                     throw new UnsupportedOperationException();
1536 
1537                 key = new MembershipKeyImpl.Type4(this, group, interf, source,
1538                                                   groupAddress, targetAddress, sourceAddress);
1539             }
1540 
1541             registry.add(key);
1542             return key;
1543         }
1544     }
1545 
1546     @Override
1547     public MembershipKey join(InetAddress group,
1548                               NetworkInterface interf)
1549         throws IOException
1550     {
1551         return innerJoin(group, interf, null);
1552     }
1553 
1554     @Override
1555     public MembershipKey join(InetAddress group,
1556                               NetworkInterface interf,
1557                               InetAddress source)
1558         throws IOException
1559     {
1560         Objects.requireNonNull(source);
1561         return innerJoin(group, interf, source);
1562     }
1563 
1564     // package-private
1565     void drop(MembershipKeyImpl key) {
1566         assert key.channel() == this;
1567 
1568         synchronized (stateLock) {
1569             if (!key.isValid())
1570                 return;
1571 
1572             try {
1573                 if (key instanceof MembershipKeyImpl.Type6) {
1574                     MembershipKeyImpl.Type6 key6 =
1575                         (MembershipKeyImpl.Type6)key;
1576                     Net.drop6(fd, key6.groupAddress(), key6.index(), key6.source());
1577                 } else {
1578                     MembershipKeyImpl.Type4 key4 = (MembershipKeyImpl.Type4)key;
1579                     Net.drop4(fd, key4.groupAddress(), key4.interfaceAddress(),
1580                         key4.source());
1581                 }
1582             } catch (IOException ioe) {
1583                 // should not happen
1584                 throw new AssertionError(ioe);
1585             }
1586 
1587             key.invalidate();
1588             registry.remove(key);
1589         }
1590     }
1591 
1592     /**
1593      * Finds an existing membership of a multicast group. Returns null if this
1594      * channel&#39;s socket is not a member of the group.
1595      *
1596      * @apiNote This method is for use by the socket adaptor
1597      */
1598     MembershipKey findMembership(InetAddress group, NetworkInterface interf) {
1599         synchronized (stateLock) {
1600             if (registry != null) {
1601                 return registry.checkMembership(group, interf, null);
1602             } else {
1603                 return null;
1604             }
1605         }
1606     }
1607 
1608     /**
1609      * Block datagrams from the given source.
1610      */
1611     void block(MembershipKeyImpl key, InetAddress source)
1612         throws IOException
1613     {
1614         assert key.channel() == this;
1615         assert key.sourceAddress() == null;
1616 
1617         synchronized (stateLock) {
1618             if (!key.isValid())
1619                 throw new IllegalStateException(&quot;key is no longer valid&quot;);
1620             if (source.isAnyLocalAddress())
1621                 throw new IllegalArgumentException(&quot;Source address is a wildcard address&quot;);
1622             if (source.isMulticastAddress())
1623                 throw new IllegalArgumentException(&quot;Source address is multicast address&quot;);
1624             if (source.getClass() != key.group().getClass())
1625                 throw new IllegalArgumentException(&quot;Source address is different type to group&quot;);
1626 
1627             int n;
1628             if (key instanceof MembershipKeyImpl.Type6) {
1629                  MembershipKeyImpl.Type6 key6 =
1630                     (MembershipKeyImpl.Type6)key;
1631                 n = Net.block6(fd, key6.groupAddress(), key6.index(),
1632                                Net.inet6AsByteArray(source));
1633             } else {
1634                 MembershipKeyImpl.Type4 key4 =
1635                     (MembershipKeyImpl.Type4)key;
1636                 n = Net.block4(fd, key4.groupAddress(), key4.interfaceAddress(),
1637                                Net.inet4AsInt(source));
1638             }
1639             if (n == IOStatus.UNAVAILABLE) {
1640                 // ancient kernel
1641                 throw new UnsupportedOperationException();
1642             }
1643         }
1644     }
1645 
1646     /**
1647      * Unblock the given source.
1648      */
1649     void unblock(MembershipKeyImpl key, InetAddress source) {
1650         assert key.channel() == this;
1651         assert key.sourceAddress() == null;
1652 
1653         synchronized (stateLock) {
1654             if (!key.isValid())
1655                 throw new IllegalStateException(&quot;key is no longer valid&quot;);
1656 
1657             try {
1658                 if (key instanceof MembershipKeyImpl.Type6) {
1659                     MembershipKeyImpl.Type6 key6 =
1660                         (MembershipKeyImpl.Type6)key;
1661                     Net.unblock6(fd, key6.groupAddress(), key6.index(),
1662                                  Net.inet6AsByteArray(source));
1663                 } else {
1664                     MembershipKeyImpl.Type4 key4 =
1665                         (MembershipKeyImpl.Type4)key;
1666                     Net.unblock4(fd, key4.groupAddress(), key4.interfaceAddress(),
1667                                  Net.inet4AsInt(source));
1668                 }
1669             } catch (IOException ioe) {
1670                 // should not happen
1671                 throw new AssertionError(ioe);
1672             }
1673         }
1674     }
1675 
1676     /**
1677      * Closes the socket if there are no I/O operations in progress and the
1678      * channel is not registered with a Selector.
1679      */
1680     private boolean tryClose() throws IOException {
1681         assert Thread.holdsLock(stateLock) &amp;&amp; state == ST_CLOSING;
1682         if ((readerThread == 0) &amp;&amp; (writerThread == 0) &amp;&amp; !isRegistered()) {
1683             state = ST_CLOSED;
1684             try {
1685                 // close socket
1686                 cleaner.clean();
1687             } catch (UncheckedIOException ioe) {
1688                 throw ioe.getCause();
1689             }
1690             return true;
1691         } else {
1692             return false;
1693         }
1694     }
1695 
1696     /**
1697      * Invokes tryClose to attempt to close the socket.
1698      *
1699      * This method is used for deferred closing by I/O and Selector operations.
1700      */
1701     private void tryFinishClose() {
1702         try {
1703             tryClose();
1704         } catch (IOException ignore) { }
1705     }
1706 
1707     /**
1708      * Closes this channel when configured in blocking mode.
1709      *
1710      * If there is an I/O operation in progress then the socket is pre-closed
1711      * and the I/O threads signalled, in which case the final close is deferred
1712      * until all I/O operations complete.
1713      */
1714     private void implCloseBlockingMode() throws IOException {
1715         synchronized (stateLock) {
1716             assert state &lt; ST_CLOSING;
1717             state = ST_CLOSING;
1718 
1719             // if member of any multicast groups then invalidate the keys
1720             if (registry != null)
1721                 registry.invalidateAll();
1722 
1723             if (!tryClose()) {
1724                 long reader = readerThread;
1725                 long writer = writerThread;
1726                 if (reader != 0 || writer != 0) {
1727                     nd.preClose(fd);
1728                     if (reader != 0)
1729                         NativeThread.signal(reader);
1730                     if (writer != 0)
1731                         NativeThread.signal(writer);
1732                 }
1733             }
1734         }
1735     }
1736 
1737     /**
1738      * Closes this channel when configured in non-blocking mode.
1739      *
1740      * If the channel is registered with a Selector then the close is deferred
1741      * until the channel is flushed from all Selectors.
1742      */
1743     private void implCloseNonBlockingMode() throws IOException {
1744         synchronized (stateLock) {
1745             assert state &lt; ST_CLOSING;
1746             state = ST_CLOSING;
1747 
1748             // if member of any multicast groups then invalidate the keys
1749             if (registry != null)
1750                 registry.invalidateAll();
1751         }
1752 
1753         // wait for any read/write operations to complete before trying to close
1754         readLock.lock();
1755         readLock.unlock();
1756         writeLock.lock();
1757         writeLock.unlock();
1758         synchronized (stateLock) {
1759             if (state == ST_CLOSING) {
1760                 tryClose();
1761             }
1762         }
1763     }
1764 
1765     /**
1766      * Invoked by implCloseChannel to close the channel.
1767      */
1768     @Override
1769     protected void implCloseSelectableChannel() throws IOException {
1770         assert !isOpen();
1771         if (isBlocking()) {
1772             implCloseBlockingMode();
1773         } else {
1774             implCloseNonBlockingMode();
1775         }
1776     }
1777 
1778     @Override
1779     public void kill() {
1780         synchronized (stateLock) {
1781             if (state == ST_CLOSING) {
1782                 tryFinishClose();
1783             }
1784         }
1785     }
1786 
1787     /**
1788      * Translates native poll revent set into a ready operation set
1789      */
1790     public boolean translateReadyOps(int ops, int initialOps, SelectionKeyImpl ski) {
1791         int intOps = ski.nioInterestOps();
1792         int oldOps = ski.nioReadyOps();
1793         int newOps = initialOps;
1794 
1795         if ((ops &amp; Net.POLLNVAL) != 0) {
1796             // This should only happen if this channel is pre-closed while a
1797             // selection operation is in progress
1798             // ## Throw an error if this channel has not been pre-closed
1799             return false;
1800         }
1801 
1802         if ((ops &amp; (Net.POLLERR | Net.POLLHUP)) != 0) {
1803             newOps = intOps;
1804             ski.nioReadyOps(newOps);
1805             return (newOps &amp; ~oldOps) != 0;
1806         }
1807 
1808         if (((ops &amp; Net.POLLIN) != 0) &amp;&amp;
1809             ((intOps &amp; SelectionKey.OP_READ) != 0))
1810             newOps |= SelectionKey.OP_READ;
1811 
1812         if (((ops &amp; Net.POLLOUT) != 0) &amp;&amp;
1813             ((intOps &amp; SelectionKey.OP_WRITE) != 0))
1814             newOps |= SelectionKey.OP_WRITE;
1815 
1816         ski.nioReadyOps(newOps);
1817         return (newOps &amp; ~oldOps) != 0;
1818     }
1819 
1820     public boolean translateAndUpdateReadyOps(int ops, SelectionKeyImpl ski) {
1821         return translateReadyOps(ops, ski.nioReadyOps(), ski);
1822     }
1823 
1824     public boolean translateAndSetReadyOps(int ops, SelectionKeyImpl ski) {
1825         return translateReadyOps(ops, 0, ski);
1826     }
1827 
1828     /**
1829      * Translates an interest operation set into a native poll event set
1830      */
1831     public int translateInterestOps(int ops) {
1832         int newOps = 0;
1833         if ((ops &amp; SelectionKey.OP_READ) != 0)
1834             newOps |= Net.POLLIN;
1835         if ((ops &amp; SelectionKey.OP_WRITE) != 0)
1836             newOps |= Net.POLLOUT;
1837         if ((ops &amp; SelectionKey.OP_CONNECT) != 0)
1838             newOps |= Net.POLLIN;
1839         return newOps;
1840     }
1841 
1842     public FileDescriptor getFD() {
1843         return fd;
1844     }
1845 
1846     public int getFDVal() {
1847         return fdVal;
1848     }
1849 
1850     /**
1851      * Returns an action to release the given file descriptor and socket addresses.
1852      */
1853     private static Runnable releaserFor(FileDescriptor fd, NativeSocketAddress... sockAddrs) {
1854         return () -&gt; {
1855             try {
1856                 nd.close(fd);
1857             } catch (IOException ioe) {
1858                 throw new UncheckedIOException(ioe);
1859             } finally {
1860                 // decrement socket count and release memory
1861                 ResourceManager.afterUdpClose();
1862                 NativeSocketAddress.freeAll(sockAddrs);
1863             }
1864         };
1865     }
1866 
1867     // -- Native methods --
1868 
1869     private static native void disconnect0(FileDescriptor fd, boolean isIPv6)
1870         throws IOException;
1871 
1872     private static native int receive0(FileDescriptor fd, long address, int len,
1873                                        long senderAddress, boolean connected)
1874         throws IOException;
1875 
1876     private static native int send0(FileDescriptor fd, long address, int len,
1877                                     long targetAddress, int targetAddressLen)
1878         throws IOException;
1879 
1880     static {
1881         IOUtil.load();
1882     }
1883 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/sun/security/tools/keytool/Main.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.tools.keytool;
  27 
  28 import java.io.*;
  29 import java.nio.file.Files;
  30 import java.nio.file.Path;
  31 import java.security.AlgorithmParameters;
  32 import java.security.CodeSigner;
  33 import java.security.CryptoPrimitive;
  34 import java.security.KeyStore;
  35 import java.security.KeyStoreException;
  36 import java.security.MessageDigest;
  37 import java.security.Key;
  38 import java.security.PublicKey;
  39 import java.security.PrivateKey;
  40 import java.security.SecureRandom;
  41 import java.security.Signature;
  42 import java.security.Timestamp;
  43 import java.security.UnrecoverableEntryException;
  44 import java.security.UnrecoverableKeyException;
  45 import java.security.Principal;
  46 import java.security.cert.Certificate;
  47 import java.security.cert.CertificateFactory;
  48 import java.security.cert.CertStoreException;
  49 import java.security.cert.CRL;
  50 import java.security.cert.X509Certificate;
  51 import java.security.cert.CertificateException;
  52 import java.security.cert.URICertStoreParameters;
  53 
  54 
  55 import java.security.interfaces.ECKey;
  56 import java.security.spec.AlgorithmParameterSpec;
  57 import java.security.spec.ECParameterSpec;
  58 import java.text.Collator;
  59 import java.text.MessageFormat;
  60 import java.util.*;
  61 import java.util.function.BiFunction;
  62 import java.util.jar.JarEntry;
  63 import java.util.jar.JarFile;
  64 import java.math.BigInteger;
  65 import java.net.URI;
  66 import java.net.URL;
  67 import java.net.URLClassLoader;
  68 import java.security.cert.CertStore;
  69 
  70 import java.security.cert.X509CRL;
  71 import java.security.cert.X509CRLEntry;
  72 import java.security.cert.X509CRLSelector;
  73 import javax.security.auth.x500.X500Principal;
  74 import java.util.Base64;
  75 
  76 import sun.security.pkcs12.PKCS12KeyStore;
  77 import sun.security.util.ECKeySizeParameterSpec;
  78 import sun.security.util.KeyUtil;
  79 import sun.security.util.NamedCurve;
  80 import sun.security.util.ObjectIdentifier;
  81 import sun.security.pkcs10.PKCS10;
  82 import sun.security.pkcs10.PKCS10Attribute;
  83 import sun.security.provider.X509Factory;
  84 import sun.security.provider.certpath.ssl.SSLServerCertStore;
  85 import sun.security.util.Password;
  86 import sun.security.util.SecurityProperties;
  87 import sun.security.util.SecurityProviderConstants;
  88 import sun.security.util.SignatureUtil;
  89 import javax.crypto.KeyGenerator;
  90 import javax.crypto.SecretKey;
  91 import javax.crypto.SecretKeyFactory;
  92 import javax.crypto.spec.PBEKeySpec;
  93 
  94 import sun.security.pkcs.PKCS9Attribute;
  95 import sun.security.tools.KeyStoreUtil;
  96 import sun.security.tools.PathList;
  97 import sun.security.util.DerValue;
  98 import sun.security.util.Pem;
  99 import sun.security.x509.*;
 100 
 101 import static java.security.KeyStore.*;
 102 import java.security.Security;
 103 import static sun.security.tools.keytool.Main.Command.*;
 104 import static sun.security.tools.keytool.Main.Option.*;
 105 import sun.security.util.DisabledAlgorithmConstraints;
 106 
 107 /**
 108  * This tool manages keystores.
 109  *
 110  * @author Jan Luehe
 111  *
 112  *
 113  * @see java.security.KeyStore
 114  * @see sun.security.provider.KeyProtector
 115  * @see sun.security.provider.JavaKeyStore
 116  *
 117  * @since 1.2
 118  */
 119 public final class Main {
 120 
 121     private static final byte[] CRLF = new byte[] {&#39;\r&#39;, &#39;\n&#39;};
 122 
 123     private boolean debug = false;
 124     private Command command = null;
 125     private String sigAlgName = null;
 126     private String keyAlgName = null;
 127     private boolean verbose = false;
 128     private int keysize = -1;
 129     private String groupName = null;
 130     private boolean rfc = false;
 131     private long validity = (long)90;
 132     private String alias = null;
 133     private String dname = null;
 134     private String dest = null;
 135     private String filename = null;
 136     private String infilename = null;
 137     private String outfilename = null;
 138     private String srcksfname = null;
 139 
 140     // User-specified providers are added before any command is called.
 141     // However, they are not removed before the end of the main() method.
 142     // If you&#39;re calling KeyTool.main() directly in your own Java program,
 143     // please programtically add any providers you need and do not specify
 144     // them through the command line.
 145 
 146     private Set&lt;Pair &lt;String, String&gt;&gt; providers = null;
 147     private Set&lt;Pair &lt;String, String&gt;&gt; providerClasses = null;
 148     private String storetype = null;
 149     private String srcProviderName = null;
 150     private String providerName = null;
 151     private String pathlist = null;
 152     private char[] storePass = null;
 153     private char[] storePassNew = null;
 154     private char[] keyPass = null;
 155     private char[] keyPassNew = null;
 156     private char[] newPass = null;
 157     private char[] destKeyPass = null;
 158     private char[] srckeyPass = null;
 159     private String ksfname = null;
 160     private File ksfile = null;
 161     private InputStream ksStream = null; // keystore stream
 162     private String sslserver = null;
 163     private String jarfile = null;
 164     private KeyStore keyStore = null;
 165     private boolean token = false;
 166     private boolean nullStream = false;
 167     private boolean kssave = false;
 168     private boolean noprompt = false;
 169     private boolean trustcacerts = false;
 170     private boolean protectedPath = false;
 171     private boolean srcprotectedPath = false;
 172     private boolean cacerts = false;
 173     private boolean nowarn = false;
 174     private KeyStore caks = null; // &quot;cacerts&quot; keystore
 175     private char[] srcstorePass = null;
 176     private String srcstoretype = null;
 177     private Set&lt;char[]&gt; passwords = new HashSet&lt;&gt;();
 178     private String startDate = null;
 179 
 180     private boolean tlsInfo = false;
 181 
 182     private List&lt;String&gt; ids = new ArrayList&lt;&gt;();   // used in GENCRL
 183     private List&lt;String&gt; v3ext = new ArrayList&lt;&gt;();
 184 
 185     // In-place importkeystore is special.
 186     // A backup is needed, and no need to prompt for deststorepass.
 187     private boolean inplaceImport = false;
 188     private String inplaceBackupName = null;
 189 
 190     // Warnings on weak algorithms etc
 191     private List&lt;String&gt; weakWarnings = new ArrayList&lt;&gt;();
 192 
 193     private static final DisabledAlgorithmConstraints DISABLED_CHECK =
 194             new DisabledAlgorithmConstraints(
 195                     DisabledAlgorithmConstraints.PROPERTY_CERTPATH_DISABLED_ALGS);
 196 
 197     private static final Set&lt;CryptoPrimitive&gt; SIG_PRIMITIVE_SET = Collections
 198             .unmodifiableSet(EnumSet.of(CryptoPrimitive.SIGNATURE));
 199     private boolean isPasswordlessKeyStore = false;
 200 
 201     enum Command {
 202         CERTREQ(&quot;Generates.a.certificate.request&quot;,
 203             ALIAS, SIGALG, FILEOUT, KEYPASS, KEYSTORE, DNAME,
 204             EXT, STOREPASS, STORETYPE, PROVIDERNAME, ADDPROVIDER,
 205             PROVIDERCLASS, PROVIDERPATH, V, PROTECTED),
 206         CHANGEALIAS(&quot;Changes.an.entry.s.alias&quot;,
 207             ALIAS, DESTALIAS, KEYPASS, KEYSTORE, CACERTS, STOREPASS,
 208             STORETYPE, PROVIDERNAME, ADDPROVIDER, PROVIDERCLASS,
 209             PROVIDERPATH, V, PROTECTED),
 210         DELETE(&quot;Deletes.an.entry&quot;,
 211             ALIAS, KEYSTORE, CACERTS, STOREPASS, STORETYPE,
 212             PROVIDERNAME, ADDPROVIDER, PROVIDERCLASS,
 213             PROVIDERPATH, V, PROTECTED),
 214         EXPORTCERT(&quot;Exports.certificate&quot;,
 215             RFC, ALIAS, FILEOUT, KEYSTORE, CACERTS, STOREPASS,
 216             STORETYPE, PROVIDERNAME, ADDPROVIDER, PROVIDERCLASS,
 217             PROVIDERPATH, V, PROTECTED),
 218         GENKEYPAIR(&quot;Generates.a.key.pair&quot;,
 219             ALIAS, KEYALG, KEYSIZE, CURVENAME, SIGALG, DNAME,
 220             STARTDATE, EXT, VALIDITY, KEYPASS, KEYSTORE,
 221             STOREPASS, STORETYPE, PROVIDERNAME, ADDPROVIDER,
 222             PROVIDERCLASS, PROVIDERPATH, V, PROTECTED),
 223         GENSECKEY(&quot;Generates.a.secret.key&quot;,
 224             ALIAS, KEYPASS, KEYALG, KEYSIZE, KEYSTORE,
 225             STOREPASS, STORETYPE, PROVIDERNAME, ADDPROVIDER,
 226             PROVIDERCLASS, PROVIDERPATH, V, PROTECTED),
 227         GENCERT(&quot;Generates.certificate.from.a.certificate.request&quot;,
 228             RFC, INFILE, OUTFILE, ALIAS, SIGALG, DNAME,
 229             STARTDATE, EXT, VALIDITY, KEYPASS, KEYSTORE,
 230             STOREPASS, STORETYPE, PROVIDERNAME, ADDPROVIDER,
 231             PROVIDERCLASS, PROVIDERPATH, V, PROTECTED),
 232         IMPORTCERT(&quot;Imports.a.certificate.or.a.certificate.chain&quot;,
 233             NOPROMPT, TRUSTCACERTS, PROTECTED, ALIAS, FILEIN,
 234             KEYPASS, KEYSTORE, CACERTS, STOREPASS, STORETYPE,
 235             PROVIDERNAME, ADDPROVIDER, PROVIDERCLASS,
 236             PROVIDERPATH, V),
 237         IMPORTPASS(&quot;Imports.a.password&quot;,
 238             ALIAS, KEYPASS, KEYALG, KEYSIZE, KEYSTORE,
 239             STOREPASS, STORETYPE, PROVIDERNAME, ADDPROVIDER,
 240             PROVIDERCLASS, PROVIDERPATH, V, PROTECTED),
 241         IMPORTKEYSTORE(&quot;Imports.one.or.all.entries.from.another.keystore&quot;,
 242             SRCKEYSTORE, DESTKEYSTORE, SRCSTORETYPE,
 243             DESTSTORETYPE, SRCSTOREPASS, DESTSTOREPASS,
 244             SRCPROTECTED, DESTPROTECTED, SRCPROVIDERNAME, DESTPROVIDERNAME,
 245             SRCALIAS, DESTALIAS, SRCKEYPASS, DESTKEYPASS,
 246             NOPROMPT, ADDPROVIDER, PROVIDERCLASS, PROVIDERPATH,
 247             V),
 248         KEYPASSWD(&quot;Changes.the.key.password.of.an.entry&quot;,
 249             ALIAS, KEYPASS, NEW, KEYSTORE, STOREPASS,
 250             STORETYPE, PROVIDERNAME, ADDPROVIDER, PROVIDERCLASS,
 251             PROVIDERPATH, V),
 252         LIST(&quot;Lists.entries.in.a.keystore&quot;,
 253             RFC, ALIAS, KEYSTORE, CACERTS, STOREPASS, STORETYPE,
 254             PROVIDERNAME, ADDPROVIDER, PROVIDERCLASS,
 255             PROVIDERPATH, V, PROTECTED),
 256         PRINTCERT(&quot;Prints.the.content.of.a.certificate&quot;,
 257             RFC, FILEIN, SSLSERVER, JARFILE,
 258             PROVIDERNAME, ADDPROVIDER, PROVIDERCLASS,
 259             PROVIDERPATH, V),
 260         PRINTCERTREQ(&quot;Prints.the.content.of.a.certificate.request&quot;,
 261             FILEIN, V),
 262         PRINTCRL(&quot;Prints.the.content.of.a.CRL.file&quot;,
 263             FILEIN, V),
 264         STOREPASSWD(&quot;Changes.the.store.password.of.a.keystore&quot;,
 265             NEW, KEYSTORE, CACERTS, STOREPASS, STORETYPE, PROVIDERNAME,
 266             ADDPROVIDER, PROVIDERCLASS, PROVIDERPATH, V),
 267         SHOWINFO(&quot;showinfo.command.help&quot;,
 268             TLS, V),
 269 
 270         // Undocumented start here, KEYCLONE is used a marker in -help;
 271 
 272         KEYCLONE(&quot;Clones.a.key.entry&quot;,
 273             ALIAS, DESTALIAS, KEYPASS, NEW, STORETYPE,
 274             KEYSTORE, STOREPASS, PROVIDERNAME, ADDPROVIDER,
 275             PROVIDERCLASS, PROVIDERPATH, V),
 276         SELFCERT(&quot;Generates.a.self.signed.certificate&quot;,
 277             ALIAS, SIGALG, DNAME, STARTDATE, EXT, VALIDITY, KEYPASS,
 278             STORETYPE, KEYSTORE, STOREPASS, PROVIDERNAME,
 279             ADDPROVIDER, PROVIDERCLASS, PROVIDERPATH, V),
 280         GENCRL(&quot;Generates.CRL&quot;,
 281             RFC, FILEOUT, ID,
 282             ALIAS, SIGALG, KEYPASS, KEYSTORE,
 283             STOREPASS, STORETYPE, PROVIDERNAME, ADDPROVIDER,
 284             PROVIDERCLASS, PROVIDERPATH, V, PROTECTED),
 285         IDENTITYDB(&quot;Imports.entries.from.a.JDK.1.1.x.style.identity.database&quot;,
 286             FILEIN, STORETYPE, KEYSTORE, STOREPASS, PROVIDERNAME,
 287             ADDPROVIDER, PROVIDERCLASS, PROVIDERPATH, V);
 288 
 289         final String description;
 290         final Option[] options;
 291         final String name;
 292 
 293         String altName;     // &quot;genkey&quot; is altName for &quot;genkeypair&quot;
 294 
 295         Command(String d, Option... o) {
 296             description = d;
 297             options = o;
 298             name = &quot;-&quot; + name().toLowerCase(Locale.ENGLISH);
 299         }
 300         @Override
 301         public String toString() {
 302             return name;
 303         }
 304         public String getAltName() {
 305             return altName;
 306         }
 307         public void setAltName(String altName) {
 308             this.altName = altName;
 309         }
 310         public static Command getCommand(String cmd) {
 311             for (Command c: Command.values()) {
 312                 if (collator.compare(cmd, c.name) == 0
 313                         || (c.altName != null
 314                             &amp;&amp; collator.compare(cmd, c.altName) == 0)) {
 315                     return c;
 316                 }
 317             }
 318             return null;
 319         }
 320     };
 321 
 322     static {
 323         Command.GENKEYPAIR.setAltName(&quot;-genkey&quot;);
 324         Command.IMPORTCERT.setAltName(&quot;-import&quot;);
 325         Command.EXPORTCERT.setAltName(&quot;-export&quot;);
 326         Command.IMPORTPASS.setAltName(&quot;-importpassword&quot;);
 327     }
 328 
 329     // If an option is allowed multiple times, remember to record it
 330     // in the optionsSet.contains() block in parseArgs().
 331     enum Option {
 332         ALIAS(&quot;alias&quot;, &quot;&lt;alias&gt;&quot;, &quot;alias.name.of.the.entry.to.process&quot;),
 333         CURVENAME(&quot;groupname&quot;, &quot;&lt;name&gt;&quot;, &quot;groupname.option.help&quot;),
 334         DESTALIAS(&quot;destalias&quot;, &quot;&lt;alias&gt;&quot;, &quot;destination.alias&quot;),
 335         DESTKEYPASS(&quot;destkeypass&quot;, &quot;&lt;arg&gt;&quot;, &quot;destination.key.password&quot;),
 336         DESTKEYSTORE(&quot;destkeystore&quot;, &quot;&lt;keystore&gt;&quot;, &quot;destination.keystore.name&quot;),
 337         DESTPROTECTED(&quot;destprotected&quot;, null, &quot;destination.keystore.password.protected&quot;),
 338         DESTPROVIDERNAME(&quot;destprovidername&quot;, &quot;&lt;name&gt;&quot;, &quot;destination.keystore.provider.name&quot;),
 339         DESTSTOREPASS(&quot;deststorepass&quot;, &quot;&lt;arg&gt;&quot;, &quot;destination.keystore.password&quot;),
 340         DESTSTORETYPE(&quot;deststoretype&quot;, &quot;&lt;type&gt;&quot;, &quot;destination.keystore.type&quot;),
 341         DNAME(&quot;dname&quot;, &quot;&lt;name&gt;&quot;, &quot;distinguished.name&quot;),
 342         EXT(&quot;ext&quot;, &quot;&lt;value&gt;&quot;, &quot;X.509.extension&quot;),
 343         FILEOUT(&quot;file&quot;, &quot;&lt;file&gt;&quot;, &quot;output.file.name&quot;),
 344         FILEIN(&quot;file&quot;, &quot;&lt;file&gt;&quot;, &quot;input.file.name&quot;),
 345         ID(&quot;id&quot;, &quot;&lt;id:reason&gt;&quot;, &quot;Serial.ID.of.cert.to.revoke&quot;),
 346         INFILE(&quot;infile&quot;, &quot;&lt;file&gt;&quot;, &quot;input.file.name&quot;),
 347         KEYALG(&quot;keyalg&quot;, &quot;&lt;alg&gt;&quot;, &quot;key.algorithm.name&quot;),
 348         KEYPASS(&quot;keypass&quot;, &quot;&lt;arg&gt;&quot;, &quot;key.password&quot;),
 349         KEYSIZE(&quot;keysize&quot;, &quot;&lt;size&gt;&quot;, &quot;key.bit.size&quot;),
 350         KEYSTORE(&quot;keystore&quot;, &quot;&lt;keystore&gt;&quot;, &quot;keystore.name&quot;),
 351         CACERTS(&quot;cacerts&quot;, null, &quot;access.the.cacerts.keystore&quot;),
 352         NEW(&quot;new&quot;, &quot;&lt;arg&gt;&quot;, &quot;new.password&quot;),
 353         NOPROMPT(&quot;noprompt&quot;, null, &quot;do.not.prompt&quot;),
 354         OUTFILE(&quot;outfile&quot;, &quot;&lt;file&gt;&quot;, &quot;output.file.name&quot;),
 355         PROTECTED(&quot;protected&quot;, null, &quot;password.through.protected.mechanism&quot;),
 356         PROVIDERCLASS(&quot;providerclass&quot;, &quot;&lt;class&gt;\n[-providerarg &lt;arg&gt;]&quot;, &quot;provider.class.option&quot;),
 357         ADDPROVIDER(&quot;addprovider&quot;, &quot;&lt;name&gt;\n[-providerarg &lt;arg&gt;]&quot;, &quot;addprovider.option&quot;),
 358         PROVIDERNAME(&quot;providername&quot;, &quot;&lt;name&gt;&quot;, &quot;provider.name&quot;),
 359         PROVIDERPATH(&quot;providerpath&quot;, &quot;&lt;list&gt;&quot;, &quot;provider.classpath&quot;),
 360         RFC(&quot;rfc&quot;, null, &quot;output.in.RFC.style&quot;),
 361         SIGALG(&quot;sigalg&quot;, &quot;&lt;alg&gt;&quot;, &quot;signature.algorithm.name&quot;),
 362         SRCALIAS(&quot;srcalias&quot;, &quot;&lt;alias&gt;&quot;, &quot;source.alias&quot;),
 363         SRCKEYPASS(&quot;srckeypass&quot;, &quot;&lt;arg&gt;&quot;, &quot;source.key.password&quot;),
 364         SRCKEYSTORE(&quot;srckeystore&quot;, &quot;&lt;keystore&gt;&quot;, &quot;source.keystore.name&quot;),
 365         SRCPROTECTED(&quot;srcprotected&quot;, null, &quot;source.keystore.password.protected&quot;),
 366         SRCPROVIDERNAME(&quot;srcprovidername&quot;, &quot;&lt;name&gt;&quot;, &quot;source.keystore.provider.name&quot;),
 367         SRCSTOREPASS(&quot;srcstorepass&quot;, &quot;&lt;arg&gt;&quot;, &quot;source.keystore.password&quot;),
 368         SRCSTORETYPE(&quot;srcstoretype&quot;, &quot;&lt;type&gt;&quot;, &quot;source.keystore.type&quot;),
 369         SSLSERVER(&quot;sslserver&quot;, &quot;&lt;server[:port]&gt;&quot;, &quot;SSL.server.host.and.port&quot;),
 370         JARFILE(&quot;jarfile&quot;, &quot;&lt;file&gt;&quot;, &quot;signed.jar.file&quot;),
 371         STARTDATE(&quot;startdate&quot;, &quot;&lt;date&gt;&quot;, &quot;certificate.validity.start.date.time&quot;),
 372         STOREPASS(&quot;storepass&quot;, &quot;&lt;arg&gt;&quot;, &quot;keystore.password&quot;),
 373         STORETYPE(&quot;storetype&quot;, &quot;&lt;type&gt;&quot;, &quot;keystore.type&quot;),
 374         TLS(&quot;tls&quot;, null, &quot;tls.option.help&quot;),
 375         TRUSTCACERTS(&quot;trustcacerts&quot;, null, &quot;trust.certificates.from.cacerts&quot;),
 376         V(&quot;v&quot;, null, &quot;verbose.output&quot;),
 377         VALIDITY(&quot;validity&quot;, &quot;&lt;days&gt;&quot;, &quot;validity.number.of.days&quot;);
 378 
 379         final String name, arg, description;
 380         Option(String name, String arg, String description) {
 381             this.name = name;
 382             this.arg = arg;
 383             this.description = description;
 384         }
 385         @Override
 386         public String toString() {
 387             return &quot;-&quot; + name;
 388         }
 389     };
 390 
 391     private static final String NONE = &quot;NONE&quot;;
 392     private static final String P11KEYSTORE = &quot;PKCS11&quot;;
 393     private static final String P12KEYSTORE = &quot;PKCS12&quot;;
 394     private static final String keyAlias = &quot;mykey&quot;;
 395 
 396     // for i18n
 397     private static final java.util.ResourceBundle rb =
 398         java.util.ResourceBundle.getBundle(
 399             &quot;sun.security.tools.keytool.Resources&quot;);
 400     private static final Collator collator = Collator.getInstance();
 401     static {
 402         // this is for case insensitive string comparisons
 403         collator.setStrength(Collator.PRIMARY);
 404     };
 405 
 406     private Main() { }
 407 
 408     public static void main(String[] args) throws Exception {
 409         Main kt = new Main();
 410         kt.run(args, System.out);
 411     }
 412 
 413     private void run(String[] args, PrintStream out) throws Exception {
 414         try {
 415             args = parseArgs(args);
 416             if (command != null) {
 417                 doCommands(out);
 418             }
 419         } catch (Exception e) {
 420             System.out.println(rb.getString(&quot;keytool.error.&quot;) + e);
 421             if (verbose) {
 422                 e.printStackTrace(System.out);
 423             }
 424             if (!debug) {
 425                 System.exit(1);
 426             } else {
 427                 throw e;
 428             }
 429         } finally {
 430             printWeakWarnings(false);
 431             for (char[] pass : passwords) {
 432                 if (pass != null) {
 433                     Arrays.fill(pass, &#39; &#39;);
 434                     pass = null;
 435                 }
 436             }
 437 
 438             if (ksStream != null) {
 439                 ksStream.close();
 440             }
 441         }
 442     }
 443 
 444     /**
 445      * Parse command line arguments.
 446      */
 447     String[] parseArgs(String[] args) throws Exception {
 448 
 449         int i=0;
 450         boolean help = args.length == 0;
 451 
 452         String confFile = null;
 453 
 454         // Records all commands and options set. Used to check dups.
 455         Set&lt;String&gt; optionsSet = new HashSet&lt;&gt;();
 456 
 457         for (i=0; i &lt; args.length; i++) {
 458             String flags = args[i];
 459             if (flags.startsWith(&quot;-&quot;)) {
 460                 String lowerFlags = flags.toLowerCase(Locale.ROOT);
 461                 if (optionsSet.contains(lowerFlags)) {
 462                     switch (lowerFlags) {
 463                         case &quot;-ext&quot;:
 464                         case &quot;-id&quot;:
 465                         case &quot;-provider&quot;:
 466                         case &quot;-addprovider&quot;:
 467                         case &quot;-providerclass&quot;:
 468                         case &quot;-providerarg&quot;:
 469                             // These options are allowed multiple times
 470                             break;
 471                         default:
 472                             weakWarnings.add(String.format(
 473                                     rb.getString(&quot;option.1.set.twice&quot;),
 474                                     lowerFlags));
 475                     }
 476                 } else {
 477                     optionsSet.add(lowerFlags);
 478                 }
 479                 if (collator.compare(flags, &quot;-conf&quot;) == 0) {
 480                     if (i == args.length - 1) {
 481                         errorNeedArgument(flags);
 482                     }
 483                     confFile = args[++i];
 484                 } else {
 485                     Command c = Command.getCommand(flags);
 486                     if (c != null) {
 487                         if (command == null) {
 488                             command = c;
 489                         } else {
 490                             throw new Exception(String.format(
 491                                     rb.getString(&quot;multiple.commands.1.2&quot;),
 492                                     command.name, c.name));
 493                         }
 494                     }
 495                 }
 496             }
 497         }
 498 
 499         if (confFile != null &amp;&amp; command != null) {
 500             args = KeyStoreUtil.expandArgs(&quot;keytool&quot;, confFile,
 501                     command.toString(),
 502                     command.getAltName(), args);
 503         }
 504 
 505         debug = Arrays.stream(args).anyMatch(
 506                 x -&gt; collator.compare(x, &quot;-debug&quot;) == 0);
 507 
 508         if (debug) {
 509             // No need to localize debug output
 510             System.out.println(&quot;Command line args: &quot; +
 511                     Arrays.toString(args));
 512         }
 513 
 514         for (i=0; (i &lt; args.length) &amp;&amp; args[i].startsWith(&quot;-&quot;); i++) {
 515 
 516             String flags = args[i];
 517 
 518             // Check if the last option needs an arg
 519             if (i == args.length - 1) {
 520                 for (Option option: Option.values()) {
 521                     // Only options with an arg need to be checked
 522                     if (collator.compare(flags, option.toString()) == 0) {
 523                         if (option.arg != null) errorNeedArgument(flags);
 524                         break;
 525                     }
 526                 }
 527             }
 528 
 529             /*
 530              * Check modifiers
 531              */
 532             String modifier = null;
 533             int pos = flags.indexOf(&#39;:&#39;);
 534             if (pos &gt; 0) {
 535                 modifier = flags.substring(pos+1);
 536                 flags = flags.substring(0, pos);
 537             }
 538 
 539             /*
 540              * command modes
 541              */
 542             Command c = Command.getCommand(flags);
 543 
 544             if (c != null) {
 545                 command = c;
 546             } else if (collator.compare(flags, &quot;--help&quot;) == 0 ||
 547                        collator.compare(flags, &quot;-h&quot;) == 0 ||
 548                        collator.compare(flags, &quot;-?&quot;) == 0 ||
 549                        // -help: legacy.
 550                        collator.compare(flags, &quot;-help&quot;) == 0) {
 551                 help = true;
 552             } else if (collator.compare(flags, &quot;-conf&quot;) == 0) {
 553                 i++;
 554             } else if (collator.compare(flags, &quot;-nowarn&quot;) == 0) {
 555                 nowarn = true;
 556             } else if (collator.compare(flags, &quot;-keystore&quot;) == 0) {
 557                 ksfname = args[++i];
 558                 if (new File(ksfname).getCanonicalPath().equals(
 559                         new File(KeyStoreUtil.getCacerts()).getCanonicalPath())) {
 560                     System.err.println(rb.getString(&quot;warning.cacerts.option&quot;));
 561                 }
 562             } else if (collator.compare(flags, &quot;-destkeystore&quot;) == 0) {
 563                 ksfname = args[++i];
 564             } else if (collator.compare(flags, &quot;-cacerts&quot;) == 0) {
 565                 cacerts = true;
 566             } else if (collator.compare(flags, &quot;-storepass&quot;) == 0 ||
 567                     collator.compare(flags, &quot;-deststorepass&quot;) == 0) {
 568                 storePass = getPass(modifier, args[++i]);
 569                 passwords.add(storePass);
 570             } else if (collator.compare(flags, &quot;-storetype&quot;) == 0 ||
 571                     collator.compare(flags, &quot;-deststoretype&quot;) == 0) {
 572                 storetype = KeyStoreUtil.niceStoreTypeName(args[++i]);
 573             } else if (collator.compare(flags, &quot;-srcstorepass&quot;) == 0) {
 574                 srcstorePass = getPass(modifier, args[++i]);
 575                 passwords.add(srcstorePass);
 576             } else if (collator.compare(flags, &quot;-srcstoretype&quot;) == 0) {
 577                 srcstoretype = KeyStoreUtil.niceStoreTypeName(args[++i]);
 578             } else if (collator.compare(flags, &quot;-srckeypass&quot;) == 0) {
 579                 srckeyPass = getPass(modifier, args[++i]);
 580                 passwords.add(srckeyPass);
 581             } else if (collator.compare(flags, &quot;-srcprovidername&quot;) == 0) {
 582                 srcProviderName = args[++i];
 583             } else if (collator.compare(flags, &quot;-providername&quot;) == 0 ||
 584                     collator.compare(flags, &quot;-destprovidername&quot;) == 0) {
 585                 providerName = args[++i];
 586             } else if (collator.compare(flags, &quot;-providerpath&quot;) == 0) {
 587                 pathlist = args[++i];
 588             } else if (collator.compare(flags, &quot;-keypass&quot;) == 0) {
 589                 keyPass = getPass(modifier, args[++i]);
 590                 passwords.add(keyPass);
 591             } else if (collator.compare(flags, &quot;-new&quot;) == 0) {
 592                 newPass = getPass(modifier, args[++i]);
 593                 passwords.add(newPass);
 594             } else if (collator.compare(flags, &quot;-destkeypass&quot;) == 0) {
 595                 destKeyPass = getPass(modifier, args[++i]);
 596                 passwords.add(destKeyPass);
 597             } else if (collator.compare(flags, &quot;-alias&quot;) == 0 ||
 598                     collator.compare(flags, &quot;-srcalias&quot;) == 0) {
 599                 alias = args[++i];
 600             } else if (collator.compare(flags, &quot;-dest&quot;) == 0 ||
 601                     collator.compare(flags, &quot;-destalias&quot;) == 0) {
 602                 dest = args[++i];
 603             } else if (collator.compare(flags, &quot;-dname&quot;) == 0) {
 604                 dname = args[++i];
 605             } else if (collator.compare(flags, &quot;-keysize&quot;) == 0) {
 606                 keysize = Integer.parseInt(args[++i]);
 607             } else if (collator.compare(flags, &quot;-groupname&quot;) == 0) {
 608                 groupName = args[++i];
 609             } else if (collator.compare(flags, &quot;-keyalg&quot;) == 0) {
 610                 keyAlgName = args[++i];
 611             } else if (collator.compare(flags, &quot;-sigalg&quot;) == 0) {
 612                 sigAlgName = args[++i];
 613             } else if (collator.compare(flags, &quot;-startdate&quot;) == 0) {
 614                 startDate = args[++i];
 615             } else if (collator.compare(flags, &quot;-validity&quot;) == 0) {
 616                 validity = Long.parseLong(args[++i]);
 617             } else if (collator.compare(flags, &quot;-ext&quot;) == 0) {
 618                 v3ext.add(args[++i]);
 619             } else if (collator.compare(flags, &quot;-id&quot;) == 0) {
 620                 ids.add(args[++i]);
 621             } else if (collator.compare(flags, &quot;-file&quot;) == 0) {
 622                 filename = args[++i];
 623             } else if (collator.compare(flags, &quot;-infile&quot;) == 0) {
 624                 infilename = args[++i];
 625             } else if (collator.compare(flags, &quot;-outfile&quot;) == 0) {
 626                 outfilename = args[++i];
 627             } else if (collator.compare(flags, &quot;-sslserver&quot;) == 0) {
 628                 sslserver = args[++i];
 629             } else if (collator.compare(flags, &quot;-jarfile&quot;) == 0) {
 630                 jarfile = args[++i];
 631             } else if (collator.compare(flags, &quot;-srckeystore&quot;) == 0) {
 632                 srcksfname = args[++i];
 633             } else if (collator.compare(flags, &quot;-provider&quot;) == 0 ||
 634                         collator.compare(flags, &quot;-providerclass&quot;) == 0) {
 635                 if (providerClasses == null) {
 636                     providerClasses = new HashSet&lt;Pair &lt;String, String&gt;&gt; (3);
 637                 }
 638                 String providerClass = args[++i];
 639                 String providerArg = null;
 640 
 641                 if (args.length &gt; (i+1)) {
 642                     flags = args[i+1];
 643                     if (collator.compare(flags, &quot;-providerarg&quot;) == 0) {
 644                         if (args.length == (i+2)) errorNeedArgument(flags);
 645                         providerArg = args[i+2];
 646                         i += 2;
 647                     }
 648                 }
 649                 providerClasses.add(
 650                         Pair.of(providerClass, providerArg));
 651             } else if (collator.compare(flags, &quot;-addprovider&quot;) == 0) {
 652                 if (providers == null) {
 653                     providers = new HashSet&lt;Pair &lt;String, String&gt;&gt; (3);
 654                 }
 655                 String provider = args[++i];
 656                 String providerArg = null;
 657 
 658                 if (args.length &gt; (i+1)) {
 659                     flags = args[i+1];
 660                     if (collator.compare(flags, &quot;-providerarg&quot;) == 0) {
 661                         if (args.length == (i+2)) errorNeedArgument(flags);
 662                         providerArg = args[i+2];
 663                         i += 2;
 664                     }
 665                 }
 666                 providers.add(
 667                         Pair.of(provider, providerArg));
 668             }
 669 
 670             /*
 671              * options
 672              */
 673             else if (collator.compare(flags, &quot;-v&quot;) == 0) {
 674                 verbose = true;
 675             } else if (collator.compare(flags, &quot;-debug&quot;) == 0) {
 676                 // Already processed
 677             } else if (collator.compare(flags, &quot;-rfc&quot;) == 0) {
 678                 rfc = true;
 679             } else if (collator.compare(flags, &quot;-noprompt&quot;) == 0) {
 680                 noprompt = true;
 681             } else if (collator.compare(flags, &quot;-trustcacerts&quot;) == 0) {
 682                 trustcacerts = true;
 683             } else if (collator.compare(flags, &quot;-protected&quot;) == 0 ||
 684                     collator.compare(flags, &quot;-destprotected&quot;) == 0) {
 685                 protectedPath = true;
 686             } else if (collator.compare(flags, &quot;-srcprotected&quot;) == 0) {
 687                 srcprotectedPath = true;
 688             } else if (collator.compare(flags, &quot;-tls&quot;) == 0) {
 689                 tlsInfo = true;
 690             } else  {
 691                 System.err.println(rb.getString(&quot;Illegal.option.&quot;) + flags);
 692                 tinyHelp();
 693             }
 694         }
 695 
 696         if (i&lt;args.length) {
 697             System.err.println(rb.getString(&quot;Illegal.option.&quot;) + args[i]);
 698             tinyHelp();
 699         }
 700 
 701         if (command == null) {
 702             if (help) {
 703                 usage();
 704             } else {
 705                 System.err.println(rb.getString(&quot;Usage.error.no.command.provided&quot;));
 706                 tinyHelp();
 707             }
 708         } else if (help) {
 709             usage();
 710             command = null;
 711         }
 712 
 713         return args;
 714     }
 715 
 716     boolean isKeyStoreRelated(Command cmd) {
 717         return cmd != PRINTCERT &amp;&amp; cmd != PRINTCERTREQ &amp;&amp; cmd != SHOWINFO;
 718     }
 719 
 720     /**
 721      * Execute the commands.
 722      */
 723     void doCommands(PrintStream out) throws Exception {
 724 
 725         if (cacerts) {
 726             if (ksfname != null || storetype != null) {
 727                 throw new IllegalArgumentException(rb.getString
 728                         (&quot;the.keystore.or.storetype.option.cannot.be.used.with.the.cacerts.option&quot;));
 729             }
 730             ksfname = KeyStoreUtil.getCacerts();
 731         }
 732 
 733         if (P11KEYSTORE.equalsIgnoreCase(storetype) ||
 734                 KeyStoreUtil.isWindowsKeyStore(storetype)) {
 735             token = true;
 736             if (ksfname == null) {
 737                 ksfname = NONE;
 738             }
 739         }
 740         if (NONE.equals(ksfname)) {
 741             nullStream = true;
 742         }
 743 
 744         if (token &amp;&amp; !nullStream) {
 745             System.err.println(MessageFormat.format(rb.getString
 746                 (&quot;.keystore.must.be.NONE.if.storetype.is.{0}&quot;), storetype));
 747             System.err.println();
 748             tinyHelp();
 749         }
 750 
 751         if (token &amp;&amp;
 752             (command == KEYPASSWD || command == STOREPASSWD)) {
 753             throw new UnsupportedOperationException(MessageFormat.format(rb.getString
 754                         (&quot;.storepasswd.and.keypasswd.commands.not.supported.if.storetype.is.{0}&quot;), storetype));
 755         }
 756 
 757         if (token &amp;&amp; (keyPass != null || newPass != null || destKeyPass != null)) {
 758             throw new IllegalArgumentException(MessageFormat.format(rb.getString
 759                 (&quot;.keypass.and.new.can.not.be.specified.if.storetype.is.{0}&quot;), storetype));
 760         }
 761 
 762         if (protectedPath) {
 763             if (storePass != null || keyPass != null ||
 764                     newPass != null || destKeyPass != null) {
 765                 throw new IllegalArgumentException(rb.getString
 766                         (&quot;if.protected.is.specified.then.storepass.keypass.and.new.must.not.be.specified&quot;));
 767             }
 768         }
 769 
 770         if (srcprotectedPath) {
 771             if (srcstorePass != null || srckeyPass != null) {
 772                 throw new IllegalArgumentException(rb.getString
 773                         (&quot;if.srcprotected.is.specified.then.srcstorepass.and.srckeypass.must.not.be.specified&quot;));
 774             }
 775         }
 776 
 777         if (KeyStoreUtil.isWindowsKeyStore(storetype)) {
 778             if (storePass != null || keyPass != null ||
 779                     newPass != null || destKeyPass != null) {
 780                 throw new IllegalArgumentException(rb.getString
 781                         (&quot;if.keystore.is.not.password.protected.then.storepass.keypass.and.new.must.not.be.specified&quot;));
 782             }
 783         }
 784 
 785         if (KeyStoreUtil.isWindowsKeyStore(srcstoretype)) {
 786             if (srcstorePass != null || srckeyPass != null) {
 787                 throw new IllegalArgumentException(rb.getString
 788                         (&quot;if.source.keystore.is.not.password.protected.then.srcstorepass.and.srckeypass.must.not.be.specified&quot;));
 789             }
 790         }
 791 
 792         if (validity &lt;= (long)0) {
 793             throw new Exception
 794                 (rb.getString(&quot;Validity.must.be.greater.than.zero&quot;));
 795         }
 796 
 797         // Try to load and install specified provider
 798         if (providers != null) {
 799             for (Pair&lt;String, String&gt; provider : providers) {
 800                 try {
 801                     KeyStoreUtil.loadProviderByName(
 802                             provider.fst, provider.snd);
 803                     if (debug) {
 804                         System.out.println(&quot;loadProviderByName: &quot; + provider.fst);
 805                     }
 806                 } catch (IllegalArgumentException e) {
 807                     throw new Exception(String.format(rb.getString(
 808                             &quot;provider.name.not.found&quot;), provider.fst));
 809                 }
 810             }
 811         }
 812         if (providerClasses != null) {
 813             ClassLoader cl = null;
 814             if (pathlist != null) {
 815                 String path = null;
 816                 path = PathList.appendPath(
 817                         path, System.getProperty(&quot;java.class.path&quot;));
 818                 path = PathList.appendPath(
 819                         path, System.getProperty(&quot;env.class.path&quot;));
 820                 path = PathList.appendPath(path, pathlist);
 821 
 822                 URL[] urls = PathList.pathToURLs(path);
 823                 cl = new URLClassLoader(urls);
 824             } else {
 825                 cl = ClassLoader.getSystemClassLoader();
 826             }
 827             for (Pair&lt;String, String&gt; provider : providerClasses) {
 828                 try {
 829                     KeyStoreUtil.loadProviderByClass(
 830                             provider.fst, provider.snd, cl);
 831                     if (debug) {
 832                         System.out.println(&quot;loadProviderByClass: &quot; + provider.fst);
 833                     }
 834                 } catch (ClassCastException cce) {
 835                     throw new Exception(String.format(rb.getString(
 836                             &quot;provclass.not.a.provider&quot;), provider.fst));
 837                 } catch (IllegalArgumentException e) {
 838                     throw new Exception(String.format(rb.getString(
 839                             &quot;provider.class.not.found&quot;), provider.fst), e.getCause());
 840                 }
 841             }
 842         }
 843 
 844         if (command == LIST &amp;&amp; verbose &amp;&amp; rfc) {
 845             System.err.println(rb.getString
 846                 (&quot;Must.not.specify.both.v.and.rfc.with.list.command&quot;));
 847             tinyHelp();
 848         }
 849 
 850         // Make sure provided passwords are at least 6 characters long
 851         if (command == GENKEYPAIR &amp;&amp; keyPass!=null &amp;&amp; keyPass.length &lt; 6) {
 852             throw new Exception(rb.getString
 853                 (&quot;Key.password.must.be.at.least.6.characters&quot;));
 854         }
 855         if (newPass != null &amp;&amp; newPass.length &lt; 6) {
 856             throw new Exception(rb.getString
 857                 (&quot;New.password.must.be.at.least.6.characters&quot;));
 858         }
 859         if (destKeyPass != null &amp;&amp; destKeyPass.length &lt; 6) {
 860             throw new Exception(rb.getString
 861                 (&quot;New.password.must.be.at.least.6.characters&quot;));
 862         }
 863 
 864         // Set this before inplaceImport check so we can compare name.
 865         if (ksfname == null) {
 866             ksfname = System.getProperty(&quot;user.home&quot;) + File.separator
 867                     + &quot;.keystore&quot;;
 868         }
 869 
 870         KeyStore srcKeyStore = null;
 871         if (command == IMPORTKEYSTORE) {
 872             inplaceImport = inplaceImportCheck();
 873             if (inplaceImport) {
 874                 // We load srckeystore first so we have srcstorePass that
 875                 // can be assigned to storePass
 876                 srcKeyStore = loadSourceKeyStore();
 877                 if (storePass == null) {
 878                     storePass = srcstorePass;
 879                 }
 880             }
 881         }
 882 
 883         // Check if keystore exists.
 884         // If no keystore has been specified at the command line, try to use
 885         // the default, which is located in $HOME/.keystore.
 886         // No need to check if isKeyStoreRelated(command) is false.
 887 
 888         // DO NOT open the existing keystore if this is an in-place import.
 889         // The keystore should be created as brand new.
 890         if (isKeyStoreRelated(command) &amp;&amp; !nullStream &amp;&amp; !inplaceImport) {
 891             try {
 892                 ksfile = new File(ksfname);
 893                 // Check if keystore file is empty
 894                 if (ksfile.exists() &amp;&amp; ksfile.length() == 0) {
 895                     throw new Exception(rb.getString
 896                             (&quot;Keystore.file.exists.but.is.empty.&quot;) + ksfname);
 897                 }
 898                 ksStream = new FileInputStream(ksfile);
 899             } catch (FileNotFoundException e) {
 900                 // These commands do not need the keystore to be existing.
 901                 // Either it will create a new one or the keystore is
 902                 // optional (i.e. PRINTCRL).
 903                 if (command != GENKEYPAIR &amp;&amp;
 904                         command != GENSECKEY &amp;&amp;
 905                         command != IDENTITYDB &amp;&amp;
 906                         command != IMPORTCERT &amp;&amp;
 907                         command != IMPORTPASS &amp;&amp;
 908                         command != IMPORTKEYSTORE &amp;&amp;
 909                         command != PRINTCRL) {
 910                     throw new Exception(rb.getString
 911                             (&quot;Keystore.file.does.not.exist.&quot;) + ksfname);
 912                 }
 913             }
 914         }
 915 
 916         if ((command == KEYCLONE || command == CHANGEALIAS)
 917                 &amp;&amp; dest == null) {
 918             dest = getAlias(&quot;destination&quot;);
 919             if (&quot;&quot;.equals(dest)) {
 920                 throw new Exception(rb.getString
 921                         (&quot;Must.specify.destination.alias&quot;));
 922             }
 923         }
 924 
 925         if (command == DELETE &amp;&amp; alias == null) {
 926             alias = getAlias(null);
 927             if (&quot;&quot;.equals(alias)) {
 928                 throw new Exception(rb.getString(&quot;Must.specify.alias&quot;));
 929             }
 930         }
 931 
 932         // Create new keystore
 933         // Probe for keystore type when filename is available
 934         if (ksfile != null &amp;&amp; ksStream != null &amp;&amp; providerName == null &amp;&amp;
 935                 storetype == null &amp;&amp; !inplaceImport) {
 936             keyStore = KeyStore.getInstance(ksfile, storePass);
 937             storetype = keyStore.getType();
 938             if (storetype.equalsIgnoreCase(&quot;pkcs12&quot;)) {
 939                 isPasswordlessKeyStore = PKCS12KeyStore.isPasswordless(ksfile);
 940             }
 941         } else {
 942             if (storetype == null) {
 943                 storetype = KeyStore.getDefaultType();
 944             }
 945             if (providerName == null) {
 946                 keyStore = KeyStore.getInstance(storetype);
 947             } else {
 948                 keyStore = KeyStore.getInstance(storetype, providerName);
 949             }
 950             // When creating a new pkcs12 file, Do not prompt for storepass
 951             // if certProtectionAlgorithm and macAlgorithm are both NONE.
 952             if (storetype.equalsIgnoreCase(&quot;pkcs12&quot;)) {
 953                 isPasswordlessKeyStore =
 954                         &quot;NONE&quot;.equals(SecurityProperties.privilegedGetOverridable(
 955                                 &quot;keystore.pkcs12.certProtectionAlgorithm&quot;))
 956                         &amp;&amp; &quot;NONE&quot;.equals(SecurityProperties.privilegedGetOverridable(
 957                                 &quot;keystore.pkcs12.macAlgorithm&quot;));
 958             }
 959 
 960             /*
 961              * Load the keystore data.
 962              *
 963              * At this point, it&#39;s OK if no keystore password has been provided.
 964              * We want to make sure that we can load the keystore data, i.e.,
 965              * the keystore data has the right format. If we cannot load the
 966              * keystore, why bother asking the user for his or her password?
 967              * Only if we were able to load the keystore, and no keystore
 968              * password has been provided, will we prompt the user for the
 969              * keystore password to verify the keystore integrity.
 970              * This means that the keystore is loaded twice: first load operation
 971              * checks the keystore format, second load operation verifies the
 972              * keystore integrity.
 973              *
 974              * If the keystore password has already been provided (at the
 975              * command line), however, the keystore is loaded only once, and the
 976              * keystore format and integrity are checked &quot;at the same time&quot;.
 977              *
 978              * Null stream keystores are loaded later.
 979              */
 980             if (!nullStream) {
 981                 if (inplaceImport) {
 982                     keyStore.load(null, storePass);
 983                 } else {
 984                     keyStore.load(ksStream, storePass);
 985                 }
 986                 if (ksStream != null) {
 987                     ksStream.close();
 988                 }
 989             }
 990         }
 991 
 992         if (P12KEYSTORE.equalsIgnoreCase(storetype) &amp;&amp; command == KEYPASSWD) {
 993             throw new UnsupportedOperationException(rb.getString
 994                     (&quot;.keypasswd.commands.not.supported.if.storetype.is.PKCS12&quot;));
 995         }
 996 
 997         // All commands that create or modify the keystore require a keystore
 998         // password.
 999 
1000         if (nullStream &amp;&amp; storePass != null) {
1001             keyStore.load(null, storePass);
1002         } else if (!nullStream &amp;&amp; storePass != null) {
1003             // If we are creating a new non nullStream-based keystore,
1004             // insist that the password be at least 6 characters
1005             if (ksStream == null &amp;&amp; storePass.length &lt; 6) {
1006                 throw new Exception(rb.getString
1007                         (&quot;Keystore.password.must.be.at.least.6.characters&quot;));
1008             }
1009         } else if (storePass == null) {
1010             if (!protectedPath &amp;&amp; !KeyStoreUtil.isWindowsKeyStore(storetype)
1011                     &amp;&amp; isKeyStoreRelated(command)
1012                     &amp;&amp; !isPasswordlessKeyStore) {
1013                 if (command == CERTREQ ||
1014                         command == DELETE ||
1015                         command == GENKEYPAIR ||
1016                         command == GENSECKEY ||
1017                         command == IMPORTCERT ||
1018                         command == IMPORTPASS ||
1019                         command == IMPORTKEYSTORE ||
1020                         command == KEYCLONE ||
1021                         command == CHANGEALIAS ||
1022                         command == SELFCERT ||
1023                         command == STOREPASSWD ||
1024                         command == KEYPASSWD ||
1025                         command == IDENTITYDB) {
1026                     int count = 0;
1027                     do {
1028                         if (command == IMPORTKEYSTORE) {
1029                             System.err.print
1030                                     (rb.getString(&quot;Enter.destination.keystore.password.&quot;));
1031                         } else {
1032                             System.err.print
1033                                     (rb.getString(&quot;Enter.keystore.password.&quot;));
1034                         }
1035                         System.err.flush();
1036                         storePass = Password.readPassword(System.in);
1037                         passwords.add(storePass);
1038 
1039                         // If we are creating a new non nullStream-based keystore,
1040                         // insist that the password be at least 6 characters
1041                         if (!nullStream &amp;&amp; (storePass == null || storePass.length &lt; 6)) {
1042                             System.err.println(rb.getString
1043                                     (&quot;Keystore.password.is.too.short.must.be.at.least.6.characters&quot;));
1044                             storePass = null;
1045                         }
1046 
1047                         // If the keystore file does not exist and needs to be
1048                         // created, the storepass should be prompted twice.
1049                         if (storePass != null &amp;&amp; !nullStream &amp;&amp; ksStream == null) {
1050                             System.err.print(rb.getString(&quot;Re.enter.new.password.&quot;));
1051                             char[] storePassAgain = Password.readPassword(System.in);
1052                             passwords.add(storePassAgain);
1053                             if (!Arrays.equals(storePass, storePassAgain)) {
1054                                 System.err.println
1055                                         (rb.getString(&quot;They.don.t.match.Try.again&quot;));
1056                                 storePass = null;
1057                             }
1058                         }
1059 
1060                         count++;
1061                     } while ((storePass == null) &amp;&amp; count &lt; 3);
1062 
1063 
1064                     if (storePass == null) {
1065                         System.err.println
1066                                 (rb.getString(&quot;Too.many.failures.try.later&quot;));
1067                         return;
1068                     }
1069                 } else {
1070                     // here we have EXPORTCERT and LIST (info valid until STOREPASSWD)
1071                     if (command != PRINTCRL) {
1072                         System.err.print(rb.getString(&quot;Enter.keystore.password.&quot;));
1073                         System.err.flush();
1074                         storePass = Password.readPassword(System.in);
1075                         passwords.add(storePass);
1076                     }
1077                 }
1078             }
1079 
1080             // Now load a nullStream-based keystore,
1081             // or verify the integrity of an input stream-based keystore
1082             if (nullStream) {
1083                 keyStore.load(null, storePass);
1084             } else if (ksStream != null) {
1085                 ksStream = new FileInputStream(ksfile);
1086                 keyStore.load(ksStream, storePass);
1087                 ksStream.close();
1088             }
1089         }
1090 
1091         if (storePass != null &amp;&amp; P12KEYSTORE.equalsIgnoreCase(storetype)) {
1092             MessageFormat form = new MessageFormat(rb.getString(
1093                 &quot;Warning.Different.store.and.key.passwords.not.supported.for.PKCS12.KeyStores.Ignoring.user.specified.command.value.&quot;));
1094             if (keyPass != null &amp;&amp; !Arrays.equals(storePass, keyPass)) {
1095                 Object[] source = {&quot;-keypass&quot;};
1096                 System.err.println(form.format(source));
1097                 keyPass = storePass;
1098             }
1099             if (destKeyPass != null &amp;&amp; !Arrays.equals(storePass, destKeyPass)) {
1100                 Object[] source = {&quot;-destkeypass&quot;};
1101                 System.err.println(form.format(source));
1102                 destKeyPass = storePass;
1103             }
1104         }
1105 
1106         // -trustcacerts can only be specified on -importcert.
1107         // Reset it so that warnings on CA cert will remain for
1108         // -printcert, etc.
1109         if (command != IMPORTCERT) {
1110             trustcacerts = false;
1111         }
1112 
1113         if (trustcacerts) {
1114             caks = KeyStoreUtil.getCacertsKeyStore();
1115         }
1116 
1117         // Perform the specified command
1118         if (command == CERTREQ) {
1119             if (filename != null) {
1120                 try (PrintStream ps = new PrintStream(new FileOutputStream
1121                                                       (filename))) {
1122                     doCertReq(alias, sigAlgName, ps);
1123                 }
1124             } else {
1125                 doCertReq(alias, sigAlgName, out);
1126             }
1127             if (verbose &amp;&amp; filename != null) {
1128                 MessageFormat form = new MessageFormat(rb.getString
1129                         (&quot;Certification.request.stored.in.file.filename.&quot;));
1130                 Object[] source = {filename};
1131                 System.err.println(form.format(source));
1132                 System.err.println(rb.getString(&quot;Submit.this.to.your.CA&quot;));
1133             }
1134         } else if (command == DELETE) {
1135             doDeleteEntry(alias);
1136             kssave = true;
1137         } else if (command == EXPORTCERT) {
1138             if (filename != null) {
1139                 try (PrintStream ps = new PrintStream(new FileOutputStream
1140                                                    (filename))) {
1141                     doExportCert(alias, ps);
1142                 }
1143             } else {
1144                 doExportCert(alias, out);
1145             }
1146             if (filename != null) {
1147                 MessageFormat form = new MessageFormat(rb.getString
1148                         (&quot;Certificate.stored.in.file.filename.&quot;));
1149                 Object[] source = {filename};
1150                 System.err.println(form.format(source));
1151             }
1152         } else if (command == GENKEYPAIR) {
1153             if (keyAlgName == null) {
1154                 throw new Exception(rb.getString(
1155                         &quot;keyalg.option.missing.error&quot;));
1156             }
1157             doGenKeyPair(alias, dname, keyAlgName, keysize, groupName, sigAlgName);
1158             kssave = true;
1159         } else if (command == GENSECKEY) {
1160             if (keyAlgName == null) {
1161                 throw new Exception(rb.getString(
1162                         &quot;keyalg.option.missing.error&quot;));
1163             }
1164             doGenSecretKey(alias, keyAlgName, keysize);
1165             kssave = true;
1166         } else if (command == IMPORTPASS) {
1167             if (keyAlgName == null) {
1168                 keyAlgName = &quot;PBE&quot;;
1169             }
1170             // password is stored as a secret key
1171             doGenSecretKey(alias, keyAlgName, keysize);
1172             kssave = true;
1173         } else if (command == IDENTITYDB) {
1174             if (filename != null) {
1175                 try (InputStream inStream = new FileInputStream(filename)) {
1176                     doImportIdentityDatabase(inStream);
1177                 }
1178             } else {
1179                 doImportIdentityDatabase(System.in);
1180             }
1181         } else if (command == IMPORTCERT) {
1182             InputStream inStream = System.in;
1183             if (filename != null) {
1184                 inStream = new FileInputStream(filename);
1185             }
1186             String importAlias = (alias!=null)?alias:keyAlias;
1187             try {
1188                 if (keyStore.entryInstanceOf(
1189                         importAlias, KeyStore.PrivateKeyEntry.class)) {
1190                     kssave = installReply(importAlias, inStream);
1191                     if (kssave) {
1192                         System.err.println(rb.getString
1193                             (&quot;Certificate.reply.was.installed.in.keystore&quot;));
1194                     } else {
1195                         System.err.println(rb.getString
1196                             (&quot;Certificate.reply.was.not.installed.in.keystore&quot;));
1197                     }
1198                 } else if (!keyStore.containsAlias(importAlias) ||
1199                         keyStore.entryInstanceOf(importAlias,
1200                             KeyStore.TrustedCertificateEntry.class)) {
1201                     kssave = addTrustedCert(importAlias, inStream);
1202                     if (kssave) {
1203                         System.err.println(rb.getString
1204                             (&quot;Certificate.was.added.to.keystore&quot;));
1205                     } else {
1206                         System.err.println(rb.getString
1207                             (&quot;Certificate.was.not.added.to.keystore&quot;));
1208                     }
1209                 }
1210             } finally {
1211                 if (inStream != System.in) {
1212                     inStream.close();
1213                 }
1214             }
1215         } else if (command == IMPORTKEYSTORE) {
1216             // When not in-place import, srcKeyStore is not loaded yet.
1217             if (srcKeyStore == null) {
1218                 srcKeyStore = loadSourceKeyStore();
1219             }
1220             doImportKeyStore(srcKeyStore);
1221             kssave = true;
1222         } else if (command == KEYCLONE) {
1223             keyPassNew = newPass;
1224 
1225             // added to make sure only key can go thru
1226             if (alias == null) {
1227                 alias = keyAlias;
1228             }
1229             if (keyStore.containsAlias(alias) == false) {
1230                 MessageFormat form = new MessageFormat
1231                     (rb.getString(&quot;Alias.alias.does.not.exist&quot;));
1232                 Object[] source = {alias};
1233                 throw new Exception(form.format(source));
1234             }
1235             if (!keyStore.entryInstanceOf(alias, KeyStore.PrivateKeyEntry.class)) {
1236                 MessageFormat form = new MessageFormat(rb.getString(
1237                         &quot;Alias.alias.references.an.entry.type.that.is.not.a.private.key.entry.The.keyclone.command.only.supports.cloning.of.private.key&quot;));
1238                 Object[] source = {alias};
1239                 throw new Exception(form.format(source));
1240             }
1241 
1242             doCloneEntry(alias, dest, true);  // Now everything can be cloned
1243             kssave = true;
1244         } else if (command == CHANGEALIAS) {
1245             if (alias == null) {
1246                 alias = keyAlias;
1247             }
1248             doCloneEntry(alias, dest, false);
1249             // in PKCS11, clone a PrivateKeyEntry will delete the old one
1250             if (keyStore.containsAlias(alias)) {
1251                 doDeleteEntry(alias);
1252             }
1253             kssave = true;
1254         } else if (command == KEYPASSWD) {
1255             keyPassNew = newPass;
1256             doChangeKeyPasswd(alias);
1257             kssave = true;
1258         } else if (command == LIST) {
1259             if (storePass == null
1260                     &amp;&amp; !KeyStoreUtil.isWindowsKeyStore(storetype)
1261                     &amp;&amp; !isPasswordlessKeyStore) {
1262                 printNoIntegrityWarning();
1263             }
1264 
1265             if (alias != null) {
1266                 doPrintEntry(rb.getString(&quot;the.certificate&quot;), alias, out);
1267             } else {
1268                 doPrintEntries(out);
1269             }
1270         } else if (command == PRINTCERT) {
1271             doPrintCert(out);
1272         } else if (command == SELFCERT) {
1273             doSelfCert(alias, dname, sigAlgName);
1274             kssave = true;
1275         } else if (command == STOREPASSWD) {
1276             doChangeStorePasswd();
1277             kssave = true;
1278         } else if (command == GENCERT) {
1279             if (alias == null) {
1280                 alias = keyAlias;
1281             }
1282             InputStream inStream = System.in;
1283             if (infilename != null) {
1284                 inStream = new FileInputStream(infilename);
1285             }
1286             PrintStream ps = null;
1287             if (outfilename != null) {
1288                 ps = new PrintStream(new FileOutputStream(outfilename));
1289                 out = ps;
1290             }
1291             try {
1292                 doGenCert(alias, sigAlgName, inStream, out);
1293             } finally {
1294                 if (inStream != System.in) {
1295                     inStream.close();
1296                 }
1297                 if (ps != null) {
1298                     ps.close();
1299                 }
1300             }
1301         } else if (command == GENCRL) {
1302             if (alias == null) {
1303                 alias = keyAlias;
1304             }
1305             if (filename != null) {
1306                 try (PrintStream ps =
1307                          new PrintStream(new FileOutputStream(filename))) {
1308                     doGenCRL(ps);
1309                 }
1310             } else {
1311                 doGenCRL(out);
1312             }
1313         } else if (command == PRINTCERTREQ) {
1314             if (filename != null) {
1315                 try (InputStream inStream = new FileInputStream(filename)) {
1316                     doPrintCertReq(inStream, out);
1317                 }
1318             } else {
1319                 doPrintCertReq(System.in, out);
1320             }
1321         } else if (command == PRINTCRL) {
1322             doPrintCRL(filename, out);
1323         } else if (command == SHOWINFO) {
1324             doShowInfo();
1325         }
1326 
1327         // If we need to save the keystore, do so.
1328         if (kssave) {
1329             if (verbose) {
1330                 MessageFormat form = new MessageFormat
1331                         (rb.getString(&quot;.Storing.ksfname.&quot;));
1332                 Object[] source = {nullStream ? &quot;keystore&quot; : ksfname};
1333                 System.err.println(form.format(source));
1334             }
1335 
1336             if (token) {
1337                 keyStore.store(null, null);
1338             } else {
1339                 char[] pass = (storePassNew!=null) ? storePassNew : storePass;
1340                 if (nullStream) {
1341                     keyStore.store(null, pass);
1342                 } else {
1343                     ByteArrayOutputStream bout = new ByteArrayOutputStream();
1344                     keyStore.store(bout, pass);
1345                     try (FileOutputStream fout = new FileOutputStream(ksfname)) {
1346                         fout.write(bout.toByteArray());
1347                     }
1348                 }
1349             }
1350         }
1351 
1352         if (isKeyStoreRelated(command)
1353                 &amp;&amp; !token &amp;&amp; !nullStream &amp;&amp; ksfname != null) {
1354 
1355             // JKS storetype warning on the final result keystore
1356             File f = new File(ksfname);
1357             char[] pass = (storePassNew!=null) ? storePassNew : storePass;
1358             if (f.exists()) {
1359                 // Probe for real type. A JKS can be loaded as PKCS12 because
1360                 // DualFormat support, vice versa.
1361                 String realType = storetype;
1362                 try {
1363                     keyStore = KeyStore.getInstance(f, pass);
1364                     realType = keyStore.getType();
1365                     if (realType.equalsIgnoreCase(&quot;JKS&quot;)
1366                             || realType.equalsIgnoreCase(&quot;JCEKS&quot;)) {
1367                         boolean allCerts = true;
1368                         for (String a : Collections.list(keyStore.aliases())) {
1369                             if (!keyStore.entryInstanceOf(
1370                                     a, TrustedCertificateEntry.class)) {
1371                                 allCerts = false;
1372                                 break;
1373                             }
1374                         }
1375                         // Don&#39;t warn for &quot;cacerts&quot; style keystore.
1376                         if (!allCerts) {
1377                             weakWarnings.add(String.format(
1378                                     rb.getString(&quot;jks.storetype.warning&quot;),
1379                                     realType, ksfname));
1380                         }
1381                     }
1382                 } catch (KeyStoreException e) {
1383                     // Probing not supported, therefore cannot be JKS or JCEKS.
1384                     // Skip the legacy type warning at all.
1385                 }
1386                 if (inplaceImport) {
1387                     String realSourceStoreType = srcstoretype;
1388                     try {
1389                         realSourceStoreType = KeyStore.getInstance(
1390                                 new File(inplaceBackupName), srcstorePass).getType();
1391                     } catch (KeyStoreException e) {
1392                         // Probing not supported. Assuming srcstoretype.
1393                     }
1394                     String format =
1395                             realType.equalsIgnoreCase(realSourceStoreType) ?
1396                             rb.getString(&quot;backup.keystore.warning&quot;) :
1397                             rb.getString(&quot;migrate.keystore.warning&quot;);
1398                     weakWarnings.add(
1399                             String.format(format,
1400                                     srcksfname,
1401                                     realSourceStoreType,
1402                                     inplaceBackupName,
1403                                     realType));
1404                 }
1405             }
1406         }
1407     }
1408 
1409     /**
1410      * Generate a certificate: Read PKCS10 request from in, and print
1411      * certificate to out. Use alias as CA, sigAlgName as the signature
1412      * type.
1413      */
1414     private void doGenCert(String alias, String sigAlgName, InputStream in, PrintStream out)
1415             throws Exception {
1416 
1417 
1418         if (keyStore.containsAlias(alias) == false) {
1419             MessageFormat form = new MessageFormat
1420                     (rb.getString(&quot;Alias.alias.does.not.exist&quot;));
1421             Object[] source = {alias};
1422             throw new Exception(form.format(source));
1423         }
1424         Certificate signerCert = keyStore.getCertificate(alias);
1425         byte[] encoded = signerCert.getEncoded();
1426         X509CertImpl signerCertImpl = new X509CertImpl(encoded);
1427         X509CertInfo signerCertInfo = (X509CertInfo)signerCertImpl.get(
1428                 X509CertImpl.NAME + &quot;.&quot; + X509CertImpl.INFO);
1429         X500Name issuer = (X500Name)signerCertInfo.get(X509CertInfo.SUBJECT + &quot;.&quot; +
1430                                            X509CertInfo.DN_NAME);
1431 
1432         Date firstDate = getStartDate(startDate);
1433         Date lastDate = new Date();
1434         lastDate.setTime(firstDate.getTime() + validity*1000L*24L*60L*60L);
1435         CertificateValidity interval = new CertificateValidity(firstDate,
1436                                                                lastDate);
1437 
1438         PrivateKey privateKey =
1439                 (PrivateKey)recoverKey(alias, storePass, keyPass).fst;
1440         if (sigAlgName == null) {
1441             sigAlgName = getCompatibleSigAlgName(privateKey);
1442         }
1443         Signature signature = Signature.getInstance(sigAlgName);
1444         AlgorithmParameterSpec params = AlgorithmId
1445                 .getDefaultAlgorithmParameterSpec(sigAlgName, privateKey);
1446 
1447         SignatureUtil.initSignWithParam(signature, privateKey, params, null);
1448 
1449         X509CertInfo info = new X509CertInfo();
1450         AlgorithmId algID = AlgorithmId.getWithParameterSpec(sigAlgName, params);
1451         info.set(X509CertInfo.VALIDITY, interval);
1452         info.set(X509CertInfo.SERIAL_NUMBER,
1453                 CertificateSerialNumber.newRandom64bit(new SecureRandom()));
1454         info.set(X509CertInfo.VERSION,
1455                     new CertificateVersion(CertificateVersion.V3));
1456         info.set(X509CertInfo.ALGORITHM_ID,
1457                     new CertificateAlgorithmId(algID));
1458         info.set(X509CertInfo.ISSUER, issuer);
1459 
1460         BufferedReader reader = new BufferedReader(new InputStreamReader(in));
1461         boolean canRead = false;
1462         StringBuffer sb = new StringBuffer();
1463         while (true) {
1464             String s = reader.readLine();
1465             if (s == null) break;
1466             // OpenSSL does not use NEW
1467             //if (s.startsWith(&quot;-----BEGIN NEW CERTIFICATE REQUEST-----&quot;)) {
1468             if (s.startsWith(&quot;-----BEGIN&quot;) &amp;&amp; s.indexOf(&quot;REQUEST&quot;) &gt;= 0) {
1469                 canRead = true;
1470             //} else if (s.startsWith(&quot;-----END NEW CERTIFICATE REQUEST-----&quot;)) {
1471             } else if (s.startsWith(&quot;-----END&quot;) &amp;&amp; s.indexOf(&quot;REQUEST&quot;) &gt;= 0) {
1472                 break;
1473             } else if (canRead) {
1474                 sb.append(s);
1475             }
1476         }
1477         byte[] rawReq = Pem.decode(new String(sb));
1478         PKCS10 req = new PKCS10(rawReq);
1479 
1480         checkWeak(rb.getString(&quot;the.certificate.request&quot;), req);
1481 
1482         info.set(X509CertInfo.KEY, new CertificateX509Key(req.getSubjectPublicKeyInfo()));
1483         info.set(X509CertInfo.SUBJECT,
1484                     dname==null?req.getSubjectName():new X500Name(dname));
1485         CertificateExtensions reqex = null;
1486         Iterator&lt;PKCS10Attribute&gt; attrs = req.getAttributes().getAttributes().iterator();
1487         while (attrs.hasNext()) {
1488             PKCS10Attribute attr = attrs.next();
1489             if (attr.getAttributeId().equals(PKCS9Attribute.EXTENSION_REQUEST_OID)) {
1490                 reqex = (CertificateExtensions)attr.getAttributeValue();
1491             }
1492         }
1493         CertificateExtensions ext = createV3Extensions(
1494                 reqex,
1495                 null,
1496                 v3ext,
1497                 req.getSubjectPublicKeyInfo(),
1498                 signerCert.getPublicKey());
1499         info.set(X509CertInfo.EXTENSIONS, ext);
1500         X509CertImpl cert = new X509CertImpl(info);
1501         cert.sign(privateKey, params, sigAlgName, null);
1502         dumpCert(cert, out);
1503         for (Certificate ca: keyStore.getCertificateChain(alias)) {
1504             if (ca instanceof X509Certificate) {
1505                 X509Certificate xca = (X509Certificate)ca;
1506                 if (!KeyStoreUtil.isSelfSigned(xca)) {
1507                     dumpCert(xca, out);
1508                 }
1509             }
1510         }
1511 
1512         checkWeak(rb.getString(&quot;the.issuer&quot;), keyStore.getCertificateChain(alias));
1513         checkWeak(rb.getString(&quot;the.generated.certificate&quot;), cert);
1514     }
1515 
1516     private void doGenCRL(PrintStream out)
1517             throws Exception {
1518         if (ids == null) {
1519             throw new Exception(&quot;Must provide -id when -gencrl&quot;);
1520         }
1521         Certificate signerCert = keyStore.getCertificate(alias);
1522         byte[] encoded = signerCert.getEncoded();
1523         X509CertImpl signerCertImpl = new X509CertImpl(encoded);
1524         X509CertInfo signerCertInfo = (X509CertInfo)signerCertImpl.get(
1525                 X509CertImpl.NAME + &quot;.&quot; + X509CertImpl.INFO);
1526         X500Name owner = (X500Name)signerCertInfo.get(X509CertInfo.SUBJECT + &quot;.&quot; +
1527                                                       X509CertInfo.DN_NAME);
1528 
1529         Date firstDate = getStartDate(startDate);
1530         Date lastDate = (Date) firstDate.clone();
1531         lastDate.setTime(lastDate.getTime() + validity*1000*24*60*60);
1532         CertificateValidity interval = new CertificateValidity(firstDate,
1533                                                                lastDate);
1534 
1535 
1536         PrivateKey privateKey =
1537                 (PrivateKey)recoverKey(alias, storePass, keyPass).fst;
1538         if (sigAlgName == null) {
1539             sigAlgName = getCompatibleSigAlgName(privateKey);
1540         }
1541 
1542         X509CRLEntry[] badCerts = new X509CRLEntry[ids.size()];
1543         for (int i=0; i&lt;ids.size(); i++) {
1544             String id = ids.get(i);
1545             int d = id.indexOf(&#39;:&#39;);
1546             if (d &gt;= 0) {
1547                 CRLExtensions ext = new CRLExtensions();
1548                 ext.set(&quot;Reason&quot;, new CRLReasonCodeExtension(Integer.parseInt(id.substring(d+1))));
1549                 badCerts[i] = new X509CRLEntryImpl(new BigInteger(id.substring(0, d)),
1550                         firstDate, ext);
1551             } else {
1552                 badCerts[i] = new X509CRLEntryImpl(new BigInteger(ids.get(i)), firstDate);
1553             }
1554         }
1555         X509CRLImpl crl = new X509CRLImpl(owner, firstDate, lastDate, badCerts);
1556         crl.sign(privateKey, sigAlgName);
1557         if (rfc) {
1558             out.println(&quot;-----BEGIN X509 CRL-----&quot;);
1559             out.println(Base64.getMimeEncoder(64, CRLF).encodeToString(crl.getEncodedInternal()));
1560             out.println(&quot;-----END X509 CRL-----&quot;);
1561         } else {
1562             out.write(crl.getEncodedInternal());
1563         }
1564         checkWeak(rb.getString(&quot;the.generated.crl&quot;), crl, privateKey);
1565     }
1566 
1567     /**
1568      * Creates a PKCS#10 cert signing request, corresponding to the
1569      * keys (and name) associated with a given alias.
1570      */
1571     private void doCertReq(String alias, String sigAlgName, PrintStream out)
1572         throws Exception
1573     {
1574         if (alias == null) {
1575             alias = keyAlias;
1576         }
1577 
1578         Pair&lt;Key,char[]&gt; objs = recoverKey(alias, storePass, keyPass);
1579         PrivateKey privKey = (PrivateKey)objs.fst;
1580         if (keyPass == null) {
1581             keyPass = objs.snd;
1582         }
1583 
1584         Certificate cert = keyStore.getCertificate(alias);
1585         if (cert == null) {
1586             MessageFormat form = new MessageFormat
1587                 (rb.getString(&quot;alias.has.no.public.key.certificate.&quot;));
1588             Object[] source = {alias};
1589             throw new Exception(form.format(source));
1590         }
1591         PKCS10 request = new PKCS10(cert.getPublicKey());
1592         CertificateExtensions ext = createV3Extensions(null, null, v3ext, cert.getPublicKey(), null);
1593         // Attribute name is not significant
1594         request.getAttributes().setAttribute(X509CertInfo.EXTENSIONS,
1595                 new PKCS10Attribute(PKCS9Attribute.EXTENSION_REQUEST_OID, ext));
1596 
1597         // Construct a Signature object, so that we can sign the request
1598         if (sigAlgName == null) {
1599             sigAlgName = getCompatibleSigAlgName(privKey);
1600         }
1601 
1602         Signature signature = Signature.getInstance(sigAlgName);
1603         AlgorithmParameterSpec params = AlgorithmId
1604                 .getDefaultAlgorithmParameterSpec(sigAlgName, privKey);
1605         SignatureUtil.initSignWithParam(signature, privKey, params, null);
1606 
1607         X500Name subject = dname == null?
1608                 new X500Name(((X509Certificate)cert).getSubjectDN().toString()):
1609                 new X500Name(dname);
1610 
1611         // Sign the request and base-64 encode it
1612         request.encodeAndSign(subject, signature);
1613         request.print(out);
1614 
1615         checkWeak(rb.getString(&quot;the.generated.certificate.request&quot;), request);
1616     }
1617 
1618     /**
1619      * Deletes an entry from the keystore.
1620      */
1621     private void doDeleteEntry(String alias) throws Exception {
1622         if (keyStore.containsAlias(alias) == false) {
1623             MessageFormat form = new MessageFormat
1624                 (rb.getString(&quot;Alias.alias.does.not.exist&quot;));
1625             Object[] source = {alias};
1626             throw new Exception(form.format(source));
1627         }
1628         keyStore.deleteEntry(alias);
1629     }
1630 
1631     /**
1632      * Exports a certificate from the keystore.
1633      */
1634     private void doExportCert(String alias, PrintStream out)
1635         throws Exception
1636     {
1637         if (storePass == null
1638                 &amp;&amp; !KeyStoreUtil.isWindowsKeyStore(storetype)
1639                 &amp;&amp; !isPasswordlessKeyStore) {
1640             printNoIntegrityWarning();
1641         }
1642         if (alias == null) {
1643             alias = keyAlias;
1644         }
1645         if (keyStore.containsAlias(alias) == false) {
1646             MessageFormat form = new MessageFormat
1647                 (rb.getString(&quot;Alias.alias.does.not.exist&quot;));
1648             Object[] source = {alias};
1649             throw new Exception(form.format(source));
1650         }
1651 
1652         X509Certificate cert = (X509Certificate)keyStore.getCertificate(alias);
1653         if (cert == null) {
1654             MessageFormat form = new MessageFormat
1655                 (rb.getString(&quot;Alias.alias.has.no.certificate&quot;));
1656             Object[] source = {alias};
1657             throw new Exception(form.format(source));
1658         }
1659         dumpCert(cert, out);
1660         checkWeak(rb.getString(&quot;the.certificate&quot;), cert);
1661     }
1662 
1663     /**
1664      * Prompt the user for a keypass when generating a key entry.
1665      * @param alias the entry we will set password for
1666      * @param orig the original entry of doing a dup, null if generate new
1667      * @param origPass the password to copy from if user press ENTER
1668      */
1669     private char[] promptForKeyPass(String alias, String orig, char[] origPass) throws Exception{
1670         if (origPass != null &amp;&amp; P12KEYSTORE.equalsIgnoreCase(storetype)) {
1671             return origPass;
1672         } else if (!token &amp;&amp; !protectedPath) {
1673             // Prompt for key password
1674             int count;
1675             for (count = 0; count &lt; 3; count++) {
1676                 MessageFormat form = new MessageFormat(rb.getString
1677                         (&quot;Enter.key.password.for.alias.&quot;));
1678                 Object[] source = {alias};
1679                 System.err.print(form.format(source));
1680                 if (origPass != null) {
1681                     System.err.println();
1682                     if (orig == null) {
1683                         System.err.print(rb.getString
1684                                 (&quot;.RETURN.if.same.as.keystore.password.&quot;));
1685                     } else {
1686                         form = new MessageFormat(rb.getString
1687                                 (&quot;.RETURN.if.same.as.for.otherAlias.&quot;));
1688                         Object[] src = {orig};
1689                         System.err.print(form.format(src));
1690                     }
1691                 }
1692                 System.err.flush();
1693                 char[] entered = Password.readPassword(System.in);
1694                 passwords.add(entered);
1695                 if (entered == null &amp;&amp; origPass != null) {
1696                     return origPass;
1697                 } else if (entered != null &amp;&amp; entered.length &gt;= 6) {
1698                     System.err.print(rb.getString(&quot;Re.enter.new.password.&quot;));
1699                     char[] passAgain = Password.readPassword(System.in);
1700                     passwords.add(passAgain);
1701                     if (!Arrays.equals(entered, passAgain)) {
1702                         System.err.println
1703                             (rb.getString(&quot;They.don.t.match.Try.again&quot;));
1704                         continue;
1705                     }
1706                     return entered;
1707                 } else {
1708                     System.err.println(rb.getString
1709                         (&quot;Key.password.is.too.short.must.be.at.least.6.characters&quot;));
1710                 }
1711             }
1712             if (count == 3) {
1713                 if (command == KEYCLONE) {
1714                     throw new Exception(rb.getString
1715                         (&quot;Too.many.failures.Key.entry.not.cloned&quot;));
1716                 } else {
1717                     throw new Exception(rb.getString
1718                             (&quot;Too.many.failures.key.not.added.to.keystore&quot;));
1719                 }
1720             }
1721         }
1722         return null;    // PKCS11, MSCAPI, or -protected
1723     }
1724 
1725     /*
1726      * Prompt the user for the password credential to be stored.
1727      */
1728     private char[] promptForCredential() throws Exception {
1729         // Handle password supplied via stdin
1730         if (System.console() == null) {
1731             char[] importPass = Password.readPassword(System.in);
1732             passwords.add(importPass);
1733             return importPass;
1734         }
1735 
1736         int count;
1737         for (count = 0; count &lt; 3; count++) {
1738             System.err.print(
1739                 rb.getString(&quot;Enter.the.password.to.be.stored.&quot;));
1740             System.err.flush();
1741             char[] entered = Password.readPassword(System.in);
1742             passwords.add(entered);
1743             System.err.print(rb.getString(&quot;Re.enter.password.&quot;));
1744             char[] passAgain = Password.readPassword(System.in);
1745             passwords.add(passAgain);
1746             if (!Arrays.equals(entered, passAgain)) {
1747                 System.err.println(rb.getString(&quot;They.don.t.match.Try.again&quot;));
1748                 continue;
1749             }
1750             return entered;
1751         }
1752 
1753         if (count == 3) {
1754             throw new Exception(rb.getString
1755                 (&quot;Too.many.failures.key.not.added.to.keystore&quot;));
1756         }
1757 
1758         return null;
1759     }
1760 
1761     /**
1762      * Creates a new secret key.
1763      */
1764     private void doGenSecretKey(String alias, String keyAlgName,
1765                               int keysize)
1766         throws Exception
1767     {
1768         if (alias == null) {
1769             alias = keyAlias;
1770         }
1771         if (keyStore.containsAlias(alias)) {
1772             MessageFormat form = new MessageFormat(rb.getString
1773                 (&quot;Secret.key.not.generated.alias.alias.already.exists&quot;));
1774             Object[] source = {alias};
1775             throw new Exception(form.format(source));
1776         }
1777 
1778         // Use the keystore&#39;s default PBE algorithm for entry protection
1779         boolean useDefaultPBEAlgorithm = true;
1780         SecretKey secKey = null;
1781 
1782         if (keyAlgName.toUpperCase(Locale.ENGLISH).startsWith(&quot;PBE&quot;)) {
1783             SecretKeyFactory factory = SecretKeyFactory.getInstance(&quot;PBE&quot;);
1784 
1785             // User is prompted for PBE credential
1786             secKey =
1787                 factory.generateSecret(new PBEKeySpec(promptForCredential()));
1788 
1789             // Check whether a specific PBE algorithm was specified
1790             if (!&quot;PBE&quot;.equalsIgnoreCase(keyAlgName)) {
1791                 useDefaultPBEAlgorithm = false;
1792             }
1793 
1794             if (verbose) {
1795                 MessageFormat form = new MessageFormat(rb.getString(
1796                     &quot;Generated.keyAlgName.secret.key&quot;));
1797                 Object[] source =
1798                     {useDefaultPBEAlgorithm ? &quot;PBE&quot; : secKey.getAlgorithm()};
1799                 System.err.println(form.format(source));
1800             }
1801         } else {
1802             KeyGenerator keygen = KeyGenerator.getInstance(keyAlgName);
1803             if (keysize == -1) {
1804                 if (&quot;DES&quot;.equalsIgnoreCase(keyAlgName)) {
1805                     keysize = 56;
1806                 } else if (&quot;DESede&quot;.equalsIgnoreCase(keyAlgName)) {
1807                     keysize = 168;
1808                 } else {
1809                     throw new Exception(rb.getString
1810                         (&quot;Please.provide.keysize.for.secret.key.generation&quot;));
1811                 }
1812             }
1813             keygen.init(keysize);
1814             secKey = keygen.generateKey();
1815 
1816             MessageFormat form = new MessageFormat(rb.getString
1817                 (&quot;Generated.keysize.bit.keyAlgName.secret.key&quot;));
1818             Object[] source = {keysize,
1819                                 secKey.getAlgorithm()};
1820             System.err.println(form.format(source));
1821         }
1822 
1823         if (keyPass == null) {
1824             keyPass = promptForKeyPass(alias, null, storePass);
1825         }
1826 
1827         if (useDefaultPBEAlgorithm) {
1828             keyStore.setKeyEntry(alias, secKey, keyPass, null);
1829         } else {
1830             keyStore.setEntry(alias, new KeyStore.SecretKeyEntry(secKey),
1831                 new KeyStore.PasswordProtection(keyPass, keyAlgName, null));
1832         }
1833     }
1834 
1835     /**
1836      * If no signature algorithm was specified at the command line,
1837      * we choose one that is compatible with the selected private key
1838      */
1839     private static String getCompatibleSigAlgName(PrivateKey key)
1840             throws Exception {
1841         String result = AlgorithmId.getDefaultSigAlgForKey(key);
1842         if (result != null) {
1843             return result;
1844         } else {
1845             throw new Exception(rb.getString
1846                     (&quot;Cannot.derive.signature.algorithm&quot;));
1847         }
1848     }
1849 
1850     /**
1851      * Creates a new key pair and self-signed certificate.
1852      */
1853     private void doGenKeyPair(String alias, String dname, String keyAlgName,
1854                               int keysize, String groupName, String sigAlgName)
1855         throws Exception
1856     {
1857         if (groupName != null) {
1858             if (keysize != -1) {
1859                 throw new Exception(rb.getString(&quot;groupname.keysize.coexist&quot;));
1860             }
1861         } else {
1862             if (keysize == -1) {
1863                 if (&quot;EC&quot;.equalsIgnoreCase(keyAlgName)) {
1864                     keysize = SecurityProviderConstants.DEF_EC_KEY_SIZE;
1865                 } else if (&quot;RSA&quot;.equalsIgnoreCase(keyAlgName)) {
1866                     keysize = SecurityProviderConstants.DEF_RSA_KEY_SIZE;
1867                 } else if (&quot;DSA&quot;.equalsIgnoreCase(keyAlgName)) {
1868                     keysize = SecurityProviderConstants.DEF_DSA_KEY_SIZE;
1869                 }
1870             } else {
1871                 if (&quot;EC&quot;.equalsIgnoreCase(keyAlgName)) {
1872                     weakWarnings.add(String.format(
1873                             rb.getString(&quot;deprecate.keysize.for.ec&quot;),
1874                             ecGroupNameForSize(keysize)));
1875                 }
1876             }
1877         }
1878 
1879         if (alias == null) {
1880             alias = keyAlias;
1881         }
1882 
1883         if (keyStore.containsAlias(alias)) {
1884             MessageFormat form = new MessageFormat(rb.getString
1885                 (&quot;Key.pair.not.generated.alias.alias.already.exists&quot;));
1886             Object[] source = {alias};
1887             throw new Exception(form.format(source));
1888         }
1889 
1890         CertAndKeyGen keypair =
1891                 new CertAndKeyGen(keyAlgName, sigAlgName, providerName);
1892 
1893 
1894         // If DN is provided, parse it. Otherwise, prompt the user for it.
1895         X500Name x500Name;
1896         if (dname == null) {
1897             printWeakWarnings(true);
1898             x500Name = getX500Name();
1899         } else {
1900             x500Name = new X500Name(dname);
1901         }
1902 
1903         if (groupName != null) {
1904             keypair.generate(groupName);
1905         } else {
1906             // This covers keysize both specified and unspecified
1907             keypair.generate(keysize);
1908         }
1909 
1910         PrivateKey privKey = keypair.getPrivateKey();
1911 
1912         CertificateExtensions ext = createV3Extensions(
1913                 null,
1914                 null,
1915                 v3ext,
1916                 keypair.getPublicKeyAnyway(),
1917                 null);
1918 
1919         X509Certificate[] chain = new X509Certificate[1];
1920         chain[0] = keypair.getSelfCertificate(
1921                 x500Name, getStartDate(startDate), validity*24L*60L*60L, ext);
1922 
1923         MessageFormat form = new MessageFormat(rb.getString
1924             (&quot;Generating.keysize.bit.keyAlgName.key.pair.and.self.signed.certificate.sigAlgName.with.a.validity.of.validality.days.for&quot;));
1925         Object[] source = {
1926                 groupName == null ? keysize : KeyUtil.getKeySize(privKey),
1927                 fullDisplayAlgName(privKey),
1928                 chain[0].getSigAlgName(),
1929                 validity,
1930                 x500Name};
1931         System.err.println(form.format(source));
1932 
1933         if (keyPass == null) {
1934             keyPass = promptForKeyPass(alias, null, storePass);
1935         }
1936         checkWeak(rb.getString(&quot;the.generated.certificate&quot;), chain[0]);
1937         keyStore.setKeyEntry(alias, privKey, keyPass, chain);
1938     }
1939 
1940     private String ecGroupNameForSize(int size) throws Exception {
1941         AlgorithmParameters ap = AlgorithmParameters.getInstance(&quot;EC&quot;);
1942         ap.init(new ECKeySizeParameterSpec(size));
1943         // The following line assumes the toString value is &quot;name (oid)&quot;
1944         return ap.toString().split(&quot; &quot;)[0];
1945     }
1946 
1947     /**
1948      * Clones an entry
1949      * @param orig original alias
1950      * @param dest destination alias
1951      * @changePassword if the password can be changed
1952      */
1953     private void doCloneEntry(String orig, String dest, boolean changePassword)
1954         throws Exception
1955     {
1956         if (orig == null) {
1957             orig = keyAlias;
1958         }
1959 
1960         if (keyStore.containsAlias(dest)) {
1961             MessageFormat form = new MessageFormat
1962                 (rb.getString(&quot;Destination.alias.dest.already.exists&quot;));
1963             Object[] source = {dest};
1964             throw new Exception(form.format(source));
1965         }
1966 
1967         Pair&lt;Entry,char[]&gt; objs = recoverEntry(keyStore, orig, storePass, keyPass);
1968         Entry entry = objs.fst;
1969         keyPass = objs.snd;
1970 
1971         PasswordProtection pp = null;
1972 
1973         if (keyPass != null) {  // protected
1974             if (!changePassword || P12KEYSTORE.equalsIgnoreCase(storetype)) {
1975                 keyPassNew = keyPass;
1976             } else {
1977                 if (keyPassNew == null) {
1978                     keyPassNew = promptForKeyPass(dest, orig, keyPass);
1979                 }
1980             }
1981             pp = new PasswordProtection(keyPassNew);
1982         }
1983         keyStore.setEntry(dest, entry, pp);
1984     }
1985 
1986     /**
1987      * Changes a key password.
1988      */
1989     private void doChangeKeyPasswd(String alias) throws Exception
1990     {
1991 
1992         if (alias == null) {
1993             alias = keyAlias;
1994         }
1995         Pair&lt;Key,char[]&gt; objs = recoverKey(alias, storePass, keyPass);
1996         Key privKey = objs.fst;
1997         if (keyPass == null) {
1998             keyPass = objs.snd;
1999         }
2000 
2001         if (keyPassNew == null) {
2002             MessageFormat form = new MessageFormat
2003                 (rb.getString(&quot;key.password.for.alias.&quot;));
2004             Object[] source = {alias};
2005             keyPassNew = getNewPasswd(form.format(source), keyPass);
2006         }
2007         keyStore.setKeyEntry(alias, privKey, keyPassNew,
2008                              keyStore.getCertificateChain(alias));
2009     }
2010 
2011     /**
2012      * Imports a JDK 1.1-style identity database. We can only store one
2013      * certificate per identity, because we use the identity&#39;s name as the
2014      * alias (which references a keystore entry), and aliases must be unique.
2015      */
2016     private void doImportIdentityDatabase(InputStream in)
2017         throws Exception
2018     {
2019         System.err.println(rb.getString
2020             (&quot;No.entries.from.identity.database.added&quot;));
2021     }
2022 
2023     /**
2024      * Prints a single keystore entry.
2025      */
2026     private void doPrintEntry(String label, String alias, PrintStream out)
2027         throws Exception
2028     {
2029         if (keyStore.containsAlias(alias) == false) {
2030             MessageFormat form = new MessageFormat
2031                 (rb.getString(&quot;Alias.alias.does.not.exist&quot;));
2032             Object[] source = {alias};
2033             throw new Exception(form.format(source));
2034         }
2035 
2036         if (verbose || rfc || debug) {
2037             MessageFormat form = new MessageFormat
2038                 (rb.getString(&quot;Alias.name.alias&quot;));
2039             Object[] source = {alias};
2040             out.println(form.format(source));
2041 
2042             if (!token) {
2043                 form = new MessageFormat(rb.getString
2044                     (&quot;Creation.date.keyStore.getCreationDate.alias.&quot;));
2045                 Object[] src = {keyStore.getCreationDate(alias)};
2046                 out.println(form.format(src));
2047             }
2048         } else {
2049             if (!token) {
2050                 MessageFormat form = new MessageFormat
2051                     (rb.getString(&quot;alias.keyStore.getCreationDate.alias.&quot;));
2052                 Object[] source = {alias, keyStore.getCreationDate(alias)};
2053                 out.print(form.format(source));
2054             } else {
2055                 MessageFormat form = new MessageFormat
2056                     (rb.getString(&quot;alias.&quot;));
2057                 Object[] source = {alias};
2058                 out.print(form.format(source));
2059             }
2060         }
2061 
2062         if (keyStore.entryInstanceOf(alias, KeyStore.SecretKeyEntry.class)) {
2063             if (verbose || rfc || debug) {
2064                 Object[] source = {&quot;SecretKeyEntry&quot;};
2065                 out.println(new MessageFormat(
2066                         rb.getString(&quot;Entry.type.type.&quot;)).format(source));
2067             } else {
2068                 out.println(&quot;SecretKeyEntry, &quot;);
2069             }
2070         } else if (keyStore.entryInstanceOf(alias, KeyStore.PrivateKeyEntry.class)) {
2071             if (verbose || rfc || debug) {
2072                 Object[] source = {&quot;PrivateKeyEntry&quot;};
2073                 out.println(new MessageFormat(
2074                         rb.getString(&quot;Entry.type.type.&quot;)).format(source));
2075             } else {
2076                 out.println(&quot;PrivateKeyEntry, &quot;);
2077             }
2078 
2079             // Get the chain
2080             Certificate[] chain = keyStore.getCertificateChain(alias);
2081             if (chain != null) {
2082                 if (verbose || rfc || debug) {
2083                     out.println(rb.getString
2084                         (&quot;Certificate.chain.length.&quot;) + chain.length);
2085                     for (int i = 0; i &lt; chain.length; i ++) {
2086                         MessageFormat form = new MessageFormat
2087                                 (rb.getString(&quot;Certificate.i.1.&quot;));
2088                         Object[] source = {(i + 1)};
2089                         out.println(form.format(source));
2090                         if (verbose &amp;&amp; (chain[i] instanceof X509Certificate)) {
2091                             printX509Cert((X509Certificate)(chain[i]), out);
2092                         } else if (debug) {
2093                             out.println(chain[i].toString());
2094                         } else {
2095                             dumpCert(chain[i], out);
2096                         }
2097                         checkWeak(label, chain[i]);
2098                     }
2099                 } else {
2100                     // Print the digest of the user cert only
2101                     out.println
2102                         (rb.getString(&quot;Certificate.fingerprint.SHA.256.&quot;) +
2103                         getCertFingerPrint(&quot;SHA-256&quot;, chain[0]));
2104                     checkWeak(label, chain);
2105                 }
2106             } else {
2107                 out.println(rb.getString
2108                         (&quot;Certificate.chain.length.&quot;) + 0);
2109             }
2110         } else if (keyStore.entryInstanceOf(alias,
2111                 KeyStore.TrustedCertificateEntry.class)) {
2112             // We have a trusted certificate entry
2113             Certificate cert = keyStore.getCertificate(alias);
2114             Object[] source = {&quot;trustedCertEntry&quot;};
2115             String mf = new MessageFormat(
2116                     rb.getString(&quot;Entry.type.type.&quot;)).format(source) + &quot;\n&quot;;
2117             if (verbose &amp;&amp; (cert instanceof X509Certificate)) {
2118                 out.println(mf);
2119                 printX509Cert((X509Certificate)cert, out);
2120             } else if (rfc) {
2121                 out.println(mf);
2122                 dumpCert(cert, out);
2123             } else if (debug) {
2124                 out.println(cert.toString());
2125             } else {
2126                 out.println(&quot;trustedCertEntry, &quot;);
2127                 out.println(rb.getString(&quot;Certificate.fingerprint.SHA.256.&quot;)
2128                             + getCertFingerPrint(&quot;SHA-256&quot;, cert));
2129             }
2130             checkWeak(label, cert);
2131         } else {
2132             out.println(rb.getString(&quot;Unknown.Entry.Type&quot;));
2133         }
2134     }
2135 
2136     boolean inplaceImportCheck() throws Exception {
2137         if (P11KEYSTORE.equalsIgnoreCase(srcstoretype) ||
2138                 KeyStoreUtil.isWindowsKeyStore(srcstoretype)) {
2139             return false;
2140         }
2141 
2142         if (srcksfname != null) {
2143             File srcksfile = new File(srcksfname);
2144             if (srcksfile.exists() &amp;&amp; srcksfile.length() == 0) {
2145                 throw new Exception(rb.getString
2146                         (&quot;Source.keystore.file.exists.but.is.empty.&quot;) +
2147                         srcksfname);
2148             }
2149             if (srcksfile.getCanonicalFile()
2150                     .equals(new File(ksfname).getCanonicalFile())) {
2151                 return true;
2152             } else {
2153                 // Informational, especially if destkeystore is not
2154                 // provided, which default to ~/.keystore.
2155                 System.err.println(String.format(rb.getString(
2156                         &quot;importing.keystore.status&quot;), srcksfname, ksfname));
2157                 return false;
2158             }
2159         } else {
2160             throw new Exception(rb.getString
2161                     (&quot;Please.specify.srckeystore&quot;));
2162         }
2163     }
2164 
2165     /**
2166      * Load the srckeystore from a stream, used in -importkeystore
2167      * @return the src KeyStore
2168      */
2169     KeyStore loadSourceKeyStore() throws Exception {
2170 
2171         InputStream is = null;
2172         File srcksfile = null;
2173         boolean srcIsPasswordless = false;
2174 
2175         if (P11KEYSTORE.equalsIgnoreCase(srcstoretype) ||
2176                 KeyStoreUtil.isWindowsKeyStore(srcstoretype)) {
2177             if (!NONE.equals(srcksfname)) {
2178                 System.err.println(MessageFormat.format(rb.getString
2179                     (&quot;.keystore.must.be.NONE.if.storetype.is.{0}&quot;), srcstoretype));
2180                 System.err.println();
2181                 tinyHelp();
2182             }
2183         } else {
2184             srcksfile = new File(srcksfname);
2185             is = new FileInputStream(srcksfile);
2186         }
2187 
2188         KeyStore store;
2189         try {
2190             // Probe for keystore type when filename is available
2191             if (srcksfile != null &amp;&amp; is != null &amp;&amp; srcProviderName == null &amp;&amp;
2192                     srcstoretype == null) {
2193                 store = KeyStore.getInstance(srcksfile, srcstorePass);
2194                 srcstoretype = store.getType();
2195                 if (srcstoretype.equalsIgnoreCase(&quot;pkcs12&quot;)) {
2196                     srcIsPasswordless = PKCS12KeyStore.isPasswordless(srcksfile);
2197                 }
2198             } else {
2199                 if (srcstoretype == null) {
2200                     srcstoretype = KeyStore.getDefaultType();
2201                 }
2202                 if (srcProviderName == null) {
2203                     store = KeyStore.getInstance(srcstoretype);
2204                 } else {
2205                     store = KeyStore.getInstance(srcstoretype, srcProviderName);
2206                 }
2207             }
2208 
2209             if (srcstorePass == null
2210                     &amp;&amp; !srcprotectedPath
2211                     &amp;&amp; !KeyStoreUtil.isWindowsKeyStore(srcstoretype)
2212                     &amp;&amp; !srcIsPasswordless) {
2213                 System.err.print(rb.getString(&quot;Enter.source.keystore.password.&quot;));
2214                 System.err.flush();
2215                 srcstorePass = Password.readPassword(System.in);
2216                 passwords.add(srcstorePass);
2217             }
2218 
2219             // always let keypass be storepass when using pkcs12
2220             if (P12KEYSTORE.equalsIgnoreCase(srcstoretype)) {
2221                 if (srckeyPass != null &amp;&amp; srcstorePass != null &amp;&amp;
2222                         !Arrays.equals(srcstorePass, srckeyPass)) {
2223                     MessageFormat form = new MessageFormat(rb.getString(
2224                         &quot;Warning.Different.store.and.key.passwords.not.supported.for.PKCS12.KeyStores.Ignoring.user.specified.command.value.&quot;));
2225                     Object[] source = {&quot;-srckeypass&quot;};
2226                     System.err.println(form.format(source));
2227                     srckeyPass = srcstorePass;
2228                 }
2229             }
2230 
2231             store.load(is, srcstorePass);   // &quot;is&quot; already null in PKCS11
2232         } finally {
2233             if (is != null) {
2234                 is.close();
2235             }
2236         }
2237 
2238         if (srcstorePass == null
2239                 &amp;&amp; !srcIsPasswordless
2240                 &amp;&amp; !KeyStoreUtil.isWindowsKeyStore(srcstoretype)) {
2241             // anti refactoring, copied from printNoIntegrityWarning(),
2242             // but change 2 lines
2243             System.err.println();
2244             System.err.println(rb.getString
2245                 (&quot;.WARNING.WARNING.WARNING.&quot;));
2246             System.err.println(rb.getString
2247                 (&quot;.The.integrity.of.the.information.stored.in.the.srckeystore.&quot;));
2248             System.err.println(rb.getString
2249                 (&quot;.WARNING.WARNING.WARNING.&quot;));
2250             System.err.println();
2251         }
2252 
2253         return store;
2254     }
2255 
2256     /**
2257      * import all keys and certs from importkeystore.
2258      * keep alias unchanged if no name conflict, otherwise, prompt.
2259      * keep keypass unchanged for keys
2260      */
2261     private void doImportKeyStore(KeyStore srcKS) throws Exception {
2262 
2263         if (alias != null) {
2264             doImportKeyStoreSingle(srcKS, alias);
2265         } else {
2266             if (dest != null || srckeyPass != null) {
2267                 throw new Exception(rb.getString(
2268                         &quot;if.alias.not.specified.destalias.and.srckeypass.must.not.be.specified&quot;));
2269             }
2270             doImportKeyStoreAll(srcKS);
2271         }
2272 
2273         if (inplaceImport) {
2274             // Backup to file.old or file.old2...
2275             // The keystore is not rewritten yet now.
2276             for (int n = 1; /* forever */; n++) {
2277                 inplaceBackupName = srcksfname + &quot;.old&quot; + (n == 1 ? &quot;&quot; : n);
2278                 File bkFile = new File(inplaceBackupName);
2279                 if (!bkFile.exists()) {
2280                     Files.copy(Path.of(srcksfname), bkFile.toPath());
2281                     break;
2282                 }
2283             }
2284 
2285         }
2286 
2287         /*
2288          * Information display rule of -importkeystore
2289          * 1. inside single, shows failure
2290          * 2. inside all, shows sucess
2291          * 3. inside all where there is a failure, prompt for continue
2292          * 4. at the final of all, shows summary
2293          */
2294     }
2295 
2296     /**
2297      * Import a single entry named alias from srckeystore
2298      * @return  1 if the import action succeed
2299      *          0 if user choose to ignore an alias-dumplicated entry
2300      *          2 if setEntry throws Exception
2301      */
2302     private int doImportKeyStoreSingle(KeyStore srckeystore, String alias)
2303             throws Exception {
2304 
2305         String newAlias = (dest==null) ? alias : dest;
2306 
2307         if (keyStore.containsAlias(newAlias)) {
2308             Object[] source = {alias};
2309             if (noprompt) {
2310                 System.err.println(new MessageFormat(rb.getString(
2311                         &quot;Warning.Overwriting.existing.alias.alias.in.destination.keystore&quot;)).format(source));
2312             } else {
2313                 String reply = getYesNoReply(new MessageFormat(rb.getString(
2314                         &quot;Existing.entry.alias.alias.exists.overwrite.no.&quot;)).format(source));
2315                 if (&quot;NO&quot;.equals(reply)) {
2316                     newAlias = inputStringFromStdin(rb.getString
2317                             (&quot;Enter.new.alias.name.RETURN.to.cancel.import.for.this.entry.&quot;));
2318                     if (&quot;&quot;.equals(newAlias)) {
2319                         System.err.println(new MessageFormat(rb.getString(
2320                                 &quot;Entry.for.alias.alias.not.imported.&quot;)).format(
2321                                 source));
2322                         return 0;
2323                     }
2324                 }
2325             }
2326         }
2327 
2328         Pair&lt;Entry,char[]&gt; objs = recoverEntry(srckeystore, alias, srcstorePass, srckeyPass);
2329         Entry entry = objs.fst;
2330 
2331         PasswordProtection pp = null;
2332 
2333         // According to keytool.html, &quot;The destination entry will be protected
2334         // using destkeypass. If destkeypass is not provided, the destination
2335         // entry will be protected with the source entry password.&quot;
2336         // so always try to protect with destKeyPass.
2337         char[] newPass = null;
2338         if (destKeyPass != null) {
2339             newPass = destKeyPass;
2340             pp = new PasswordProtection(destKeyPass);
2341         } else if (objs.snd != null) {
2342             newPass = P12KEYSTORE.equalsIgnoreCase(storetype) ?
2343                     storePass : objs.snd;
2344             pp = new PasswordProtection(newPass);
2345         }
2346 
2347         try {
2348             Certificate c = srckeystore.getCertificate(alias);
2349             if (c != null) {
2350                 checkWeak(&quot;&lt;&quot; + newAlias + &quot;&gt;&quot;, c);
2351             }
2352             keyStore.setEntry(newAlias, entry, pp);
2353             // Place the check so that only successful imports are blocked.
2354             // For example, we don&#39;t block a failed SecretEntry import.
2355             if (P12KEYSTORE.equalsIgnoreCase(storetype)) {
2356                 if (newPass != null &amp;&amp; !Arrays.equals(newPass, storePass)) {
2357                     throw new Exception(rb.getString(
2358                             &quot;The.destination.pkcs12.keystore.has.different.storepass.and.keypass.Please.retry.with.destkeypass.specified.&quot;));
2359                 }
2360             }
2361             return 1;
2362         } catch (KeyStoreException kse) {
2363             Object[] source2 = {alias, kse.toString()};
2364             MessageFormat form = new MessageFormat(rb.getString(
2365                     &quot;Problem.importing.entry.for.alias.alias.exception.Entry.for.alias.alias.not.imported.&quot;));
2366             System.err.println(form.format(source2));
2367             return 2;
2368         }
2369     }
2370 
2371     private void doImportKeyStoreAll(KeyStore srckeystore) throws Exception {
2372 
2373         int ok = 0;
2374         int count = srckeystore.size();
2375         for (Enumeration&lt;String&gt; e = srckeystore.aliases();
2376                                         e.hasMoreElements(); ) {
2377             String alias = e.nextElement();
2378             int result = doImportKeyStoreSingle(srckeystore, alias);
2379             if (result == 1) {
2380                 ok++;
2381                 Object[] source = {alias};
2382                 MessageFormat form = new MessageFormat(rb.getString(&quot;Entry.for.alias.alias.successfully.imported.&quot;));
2383                 System.err.println(form.format(source));
2384             } else if (result == 2) {
2385                 if (!noprompt) {
2386                     String reply = getYesNoReply(&quot;Do you want to quit the import process? [no]:  &quot;);
2387                     if (&quot;YES&quot;.equals(reply)) {
2388                         break;
2389                     }
2390                 }
2391             }
2392         }
2393         Object[] source = {ok, count-ok};
2394         MessageFormat form = new MessageFormat(rb.getString(
2395                 &quot;Import.command.completed.ok.entries.successfully.imported.fail.entries.failed.or.cancelled&quot;));
2396         System.err.println(form.format(source));
2397     }
2398 
2399     /**
2400      * Prints all keystore entries.
2401      */
2402     private void doPrintEntries(PrintStream out)
2403         throws Exception
2404     {
2405         out.println(rb.getString(&quot;Keystore.type.&quot;) + keyStore.getType());
2406         out.println(rb.getString(&quot;Keystore.provider.&quot;) +
2407                 keyStore.getProvider().getName());
2408         out.println();
2409 
2410         MessageFormat form;
2411         form = (keyStore.size() == 1) ?
2412                 new MessageFormat(rb.getString
2413                         (&quot;Your.keystore.contains.keyStore.size.entry&quot;)) :
2414                 new MessageFormat(rb.getString
2415                         (&quot;Your.keystore.contains.keyStore.size.entries&quot;));
2416         Object[] source = {keyStore.size()};
2417         out.println(form.format(source));
2418         out.println();
2419 
2420         List&lt;String&gt; aliases = Collections.list(keyStore.aliases());
2421         aliases.sort(String::compareTo);
2422         for (String alias : aliases) {
2423             doPrintEntry(&quot;&lt;&quot; + alias + &quot;&gt;&quot;, alias, out);
2424             if (verbose || rfc) {
2425                 out.println(rb.getString(&quot;NEWLINE&quot;));
2426                 out.println(rb.getString
2427                         (&quot;STAR&quot;));
2428                 out.println(rb.getString
2429                         (&quot;STARNN&quot;));
2430             }
2431         }
2432     }
2433 
2434     private static &lt;T&gt; Iterable&lt;T&gt; e2i(final Enumeration&lt;T&gt; e) {
2435         return new Iterable&lt;T&gt;() {
2436             @Override
2437             public Iterator&lt;T&gt; iterator() {
2438                 return new Iterator&lt;T&gt;() {
2439                     @Override
2440                     public boolean hasNext() {
2441                         return e.hasMoreElements();
2442                     }
2443                     @Override
2444                     public T next() {
2445                         return e.nextElement();
2446                     }
2447                     public void remove() {
2448                         throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);
2449                     }
2450                 };
2451             }
2452         };
2453     }
2454 
2455     /**
2456      * Loads CRLs from a source. This method is also called in JarSigner.
2457      * @param src the source, which means System.in if null, or a URI,
2458      *        or a bare file path name
2459      */
2460     public static Collection&lt;? extends CRL&gt; loadCRLs(String src) throws Exception {
2461         InputStream in = null;
2462         URI uri = null;
2463         if (src == null) {
2464             in = System.in;
2465         } else {
2466             try {
2467                 uri = new URI(src);
2468                 if (uri.getScheme().equals(&quot;ldap&quot;)) {
2469                     // No input stream for LDAP
2470                 } else {
2471                     in = uri.toURL().openStream();
2472                 }
2473             } catch (Exception e) {
2474                 try {
2475                     in = new FileInputStream(src);
2476                 } catch (Exception e2) {
2477                     if (uri == null || uri.getScheme() == null) {
2478                         throw e2;   // More likely a bare file path
2479                     } else {
2480                         throw e;    // More likely a protocol or network problem
2481                     }
2482                 }
2483             }
2484         }
2485         if (in != null) {
2486             try {
2487                 // Read the full stream before feeding to X509Factory,
2488                 // otherwise, keytool -gencrl | keytool -printcrl
2489                 // might not work properly, since -gencrl is slow
2490                 // and there&#39;s no data in the pipe at the beginning.
2491                 ByteArrayOutputStream bout = new ByteArrayOutputStream();
2492                 byte[] b = new byte[4096];
2493                 while (true) {
2494                     int len = in.read(b);
2495                     if (len &lt; 0) break;
2496                     bout.write(b, 0, len);
2497                 }
2498                 return CertificateFactory.getInstance(&quot;X509&quot;).generateCRLs(
2499                         new ByteArrayInputStream(bout.toByteArray()));
2500             } finally {
2501                 if (in != System.in) {
2502                     in.close();
2503                 }
2504             }
2505         } else {    // must be LDAP, and uri is not null
2506             URICertStoreParameters params =
2507                 new URICertStoreParameters(uri);
2508             CertStore s = CertStore.getInstance(&quot;LDAP&quot;, params);
2509             return s.getCRLs(new X509CRLSelector());
2510         }
2511     }
2512 
2513     /**
2514      * Returns CRLs described in a X509Certificate&#39;s CRLDistributionPoints
2515      * Extension. Only those containing a general name of type URI are read.
2516      */
2517     public static List&lt;CRL&gt; readCRLsFromCert(X509Certificate cert)
2518             throws Exception {
2519         List&lt;CRL&gt; crls = new ArrayList&lt;&gt;();
2520         CRLDistributionPointsExtension ext =
2521                 X509CertImpl.toImpl(cert).getCRLDistributionPointsExtension();
2522         if (ext == null) return crls;
2523         List&lt;DistributionPoint&gt; distPoints =
2524                 ext.get(CRLDistributionPointsExtension.POINTS);
2525         for (DistributionPoint o: distPoints) {
2526             GeneralNames names = o.getFullName();
2527             if (names != null) {
2528                 for (GeneralName name: names.names()) {
2529                     if (name.getType() == GeneralNameInterface.NAME_URI) {
2530                         URIName uriName = (URIName)name.getName();
2531                         for (CRL crl: loadCRLs(uriName.getName())) {
2532                             if (crl instanceof X509CRL) {
2533                                 crls.add((X509CRL)crl);
2534                             }
2535                         }
2536                         break;  // Different name should point to same CRL
2537                     }
2538                 }
2539             }
2540         }
2541         return crls;
2542     }
2543 
2544     private static String verifyCRL(KeyStore ks, CRL crl)
2545             throws Exception {
2546         X509CRLImpl xcrl = (X509CRLImpl)crl;
2547         X500Principal issuer = xcrl.getIssuerX500Principal();
2548         for (String s: e2i(ks.aliases())) {
2549             Certificate cert = ks.getCertificate(s);
2550             if (cert instanceof X509Certificate) {
2551                 X509Certificate xcert = (X509Certificate)cert;
2552                 if (xcert.getSubjectX500Principal().equals(issuer)) {
2553                     try {
2554                         ((X509CRLImpl)crl).verify(cert.getPublicKey());
2555                         return s;
2556                     } catch (Exception e) {
2557                     }
2558                 }
2559             }
2560         }
2561         return null;
2562     }
2563 
2564     private void doPrintCRL(String src, PrintStream out)
2565             throws Exception {
2566         for (CRL crl: loadCRLs(src)) {
2567             printCRL(crl, out);
2568             String issuer = null;
2569             Certificate signer = null;
2570             if (caks != null) {
2571                 issuer = verifyCRL(caks, crl);
2572                 if (issuer != null) {
2573                     signer = caks.getCertificate(issuer);
2574                     out.printf(rb.getString(
2575                             &quot;verified.by.s.in.s.weak&quot;),
2576                             issuer,
2577                             &quot;cacerts&quot;,
2578                             withWeak(signer.getPublicKey()));
2579                     out.println();
2580                 }
2581             }
2582             if (issuer == null &amp;&amp; keyStore != null) {
2583                 issuer = verifyCRL(keyStore, crl);
2584                 if (issuer != null) {
2585                     signer = keyStore.getCertificate(issuer);
2586                     out.printf(rb.getString(
2587                             &quot;verified.by.s.in.s.weak&quot;),
2588                             issuer,
2589                             &quot;keystore&quot;,
2590                             withWeak(signer.getPublicKey()));
2591                     out.println();
2592                 }
2593             }
2594             if (issuer == null) {
2595                 out.println(rb.getString
2596                         (&quot;STAR&quot;));
2597                 out.println(rb.getString
2598                         (&quot;warning.not.verified.make.sure.keystore.is.correct&quot;));
2599                 out.println(rb.getString
2600                         (&quot;STARNN&quot;));
2601             }
2602             checkWeak(rb.getString(&quot;the.crl&quot;), crl, signer == null ? null : signer.getPublicKey());
2603         }
2604     }
2605 
2606     private void printCRL(CRL crl, PrintStream out)
2607             throws Exception {
2608         X509CRL xcrl = (X509CRL)crl;
2609         if (rfc) {
2610             out.println(&quot;-----BEGIN X509 CRL-----&quot;);
2611             out.println(Base64.getMimeEncoder(64, CRLF).encodeToString(xcrl.getEncoded()));
2612             out.println(&quot;-----END X509 CRL-----&quot;);
2613         } else {
2614             String s;
2615             if (crl instanceof X509CRLImpl) {
2616                 X509CRLImpl x509crl = (X509CRLImpl) crl;
2617                 s = x509crl.toStringWithAlgName(withWeak(&quot;&quot; + x509crl.getSigAlgId()));
2618             } else {
2619                 s = crl.toString();
2620             }
2621             out.println(s);
2622         }
2623     }
2624 
2625     private void doPrintCertReq(InputStream in, PrintStream out)
2626             throws Exception {
2627 
2628         BufferedReader reader = new BufferedReader(new InputStreamReader(in));
2629         StringBuffer sb = new StringBuffer();
2630         boolean started = false;
2631         while (true) {
2632             String s = reader.readLine();
2633             if (s == null) break;
2634             if (!started) {
2635                 if (s.startsWith(&quot;-----&quot;)) {
2636                     started = true;
2637                 }
2638             } else {
2639                 if (s.startsWith(&quot;-----&quot;)) {
2640                     break;
2641                 }
2642                 sb.append(s);
2643             }
2644         }
2645         PKCS10 req = new PKCS10(Pem.decode(new String(sb)));
2646 
2647         PublicKey pkey = req.getSubjectPublicKeyInfo();
2648         out.printf(rb.getString(&quot;PKCS.10.with.weak&quot;),
2649                 req.getSubjectName(),
2650                 pkey.getFormat(),
2651                 withWeak(pkey),
2652                 withWeak(req.getSigAlg()));
2653         for (PKCS10Attribute attr: req.getAttributes().getAttributes()) {
2654             ObjectIdentifier oid = attr.getAttributeId();
2655             if (oid.equals(PKCS9Attribute.EXTENSION_REQUEST_OID)) {
2656                 CertificateExtensions exts = (CertificateExtensions)attr.getAttributeValue();
2657                 if (exts != null) {
2658                     printExtensions(rb.getString(&quot;Extension.Request.&quot;), exts, out);
2659                 }
2660             } else {
2661                 out.println(&quot;Attribute: &quot; + attr.getAttributeId());
2662                 PKCS9Attribute pkcs9Attr =
2663                         new PKCS9Attribute(attr.getAttributeId(),
2664                                            attr.getAttributeValue());
2665                 out.print(pkcs9Attr.getName() + &quot;: &quot;);
2666                 Object attrVal = attr.getAttributeValue();
2667                 out.println(attrVal instanceof String[] ?
2668                             Arrays.toString((String[]) attrVal) :
2669                             attrVal);
2670             }
2671         }
2672         if (debug) {
2673             out.println(req);   // Just to see more, say, public key length...
2674         }
2675         checkWeak(rb.getString(&quot;the.certificate.request&quot;), req);
2676     }
2677 
2678     /**
2679      * Reads a certificate (or certificate chain) and prints its contents in
2680      * a human readable format.
2681      */
2682     private void printCertFromStream(InputStream in, PrintStream out)
2683         throws Exception
2684     {
2685         Collection&lt;? extends Certificate&gt; c = null;
2686         try {
2687             c = generateCertificates(in);
2688         } catch (CertificateException ce) {
2689             throw new Exception(rb.getString(&quot;Failed.to.parse.input&quot;), ce);
2690         }
2691         if (c.isEmpty()) {
2692             throw new Exception(rb.getString(&quot;Empty.input&quot;));
2693         }
2694         Certificate[] certs = c.toArray(new Certificate[c.size()]);
2695         for (int i=0; i&lt;certs.length; i++) {
2696             X509Certificate x509Cert = null;
2697             try {
2698                 x509Cert = (X509Certificate)certs[i];
2699             } catch (ClassCastException cce) {
2700                 throw new Exception(rb.getString(&quot;Not.X.509.certificate&quot;));
2701             }
2702             if (certs.length &gt; 1) {
2703                 MessageFormat form = new MessageFormat
2704                         (rb.getString(&quot;Certificate.i.1.&quot;));
2705                 Object[] source = {i + 1};
2706                 out.println(form.format(source));
2707             }
2708             if (rfc)
2709                 dumpCert(x509Cert, out);
2710             else
2711                 printX509Cert(x509Cert, out);
2712             if (i &lt; (certs.length-1)) {
2713                 out.println();
2714             }
2715             checkWeak(oneInMany(rb.getString(&quot;the.certificate&quot;), i, certs.length), x509Cert);
2716         }
2717     }
2718 
2719     private void doShowInfo() throws Exception {
2720         if (tlsInfo) {
2721             ShowInfo.tls(verbose);
2722         } else {
2723             System.out.println(rb.getString(&quot;showinfo.no.option&quot;));
2724         }
2725     }
2726 
2727     private Collection&lt;? extends Certificate&gt; generateCertificates(InputStream in)
2728             throws CertificateException, IOException {
2729         byte[] data = in.readAllBytes();
2730         try {
2731             return CertificateFactory.getInstance(&quot;X.509&quot;)
2732                     .generateCertificates(new ByteArrayInputStream(data));
2733         } catch (CertificateException e) {
2734             if (providerName != null) {
2735                 try {
2736                     return CertificateFactory.getInstance(&quot;X.509&quot;, providerName)
2737                             .generateCertificates(new ByteArrayInputStream(data));
2738                 } catch (Exception e2) {
2739                     e.addSuppressed(e2);
2740                 }
2741             }
2742             throw e;
2743         }
2744     }
2745 
2746     private Certificate generateCertificate(InputStream in)
2747             throws CertificateException, IOException {
2748         byte[] data = in.readAllBytes();
2749         try {
2750             return CertificateFactory.getInstance(&quot;X.509&quot;)
2751                     .generateCertificate(new ByteArrayInputStream(data));
2752         } catch (CertificateException e) {
2753             if (providerName != null) {
2754                 try {
2755                     return CertificateFactory.getInstance(&quot;X.509&quot;, providerName)
2756                             .generateCertificate(new ByteArrayInputStream(data));
2757                 } catch (Exception e2) {
2758                     e.addSuppressed(e2);
2759                 }
2760             }
2761             throw e;
2762         }
2763     }
2764 
2765     private static String oneInMany(String label, int i, int num) {
2766         if (num == 1) {
2767             return label;
2768         } else {
2769             return String.format(rb.getString(&quot;one.in.many&quot;), label, i+1, num);
2770         }
2771     }
2772 
2773     private void doPrintCert(final PrintStream out) throws Exception {
2774         if (jarfile != null) {
2775             // reset &quot;jdk.certpath.disabledAlgorithms&quot; security property
2776             // to be able to read jars which were signed with weak algorithms
2777             Security.setProperty(DisabledAlgorithmConstraints.PROPERTY_JAR_DISABLED_ALGS, &quot;&quot;);
2778 
2779             JarFile jf = new JarFile(jarfile, true);
2780             Enumeration&lt;JarEntry&gt; entries = jf.entries();
2781             Set&lt;CodeSigner&gt; ss = new HashSet&lt;&gt;();
2782             byte[] buffer = new byte[8192];
2783             int pos = 0;
2784             while (entries.hasMoreElements()) {
2785                 JarEntry je = entries.nextElement();
2786                 try (InputStream is = jf.getInputStream(je)) {
2787                     while (is.read(buffer) != -1) {
2788                         // we just read. this will throw a SecurityException
2789                         // if a signature/digest check fails. This also
2790                         // populate the signers
2791                     }
2792                 }
2793                 CodeSigner[] signers = je.getCodeSigners();
2794                 if (signers != null) {
2795                     for (CodeSigner signer: signers) {
2796                         if (!ss.contains(signer)) {
2797                             ss.add(signer);
2798                             out.printf(rb.getString(&quot;Signer.d.&quot;), ++pos);
2799                             out.println();
2800                             out.println();
2801                             out.println(rb.getString(&quot;Signature.&quot;));
2802                             out.println();
2803 
2804                             List&lt;? extends Certificate&gt; certs
2805                                     = signer.getSignerCertPath().getCertificates();
2806                             int cc = 0;
2807                             for (Certificate cert: certs) {
2808                                 X509Certificate x = (X509Certificate)cert;
2809                                 if (rfc) {
2810                                     out.println(rb.getString(&quot;Certificate.owner.&quot;) + x.getSubjectDN() + &quot;\n&quot;);
2811                                     dumpCert(x, out);
2812                                 } else {
2813                                     printX509Cert(x, out);
2814                                 }
2815                                 out.println();
2816                                 checkWeak(oneInMany(rb.getString(&quot;the.certificate&quot;), cc++, certs.size()), x);
2817                             }
2818                             Timestamp ts = signer.getTimestamp();
2819                             if (ts != null) {
2820                                 out.println(rb.getString(&quot;Timestamp.&quot;));
2821                                 out.println();
2822                                 certs = ts.getSignerCertPath().getCertificates();
2823                                 cc = 0;
2824                                 for (Certificate cert: certs) {
2825                                     X509Certificate x = (X509Certificate)cert;
2826                                     if (rfc) {
2827                                         out.println(rb.getString(&quot;Certificate.owner.&quot;) + x.getSubjectDN() + &quot;\n&quot;);
2828                                         dumpCert(x, out);
2829                                     } else {
2830                                         printX509Cert(x, out);
2831                                     }
2832                                     out.println();
2833                                     checkWeak(oneInMany(rb.getString(&quot;the.tsa.certificate&quot;), cc++, certs.size()), x);
2834                                 }
2835                             }
2836                         }
2837                     }
2838                 }
2839             }
2840             jf.close();
2841             if (ss.isEmpty()) {
2842                 out.println(rb.getString(&quot;Not.a.signed.jar.file&quot;));
2843             }
2844         } else if (sslserver != null) {
2845             CertStore cs = SSLServerCertStore.getInstance(new URI(&quot;https://&quot; + sslserver));
2846             Collection&lt;? extends Certificate&gt; chain;
2847             try {
2848                 chain = cs.getCertificates(null);
2849                 if (chain.isEmpty()) {
2850                     // If the certs are not retrieved, we consider it an error
2851                     // even if the URL connection is successful.
2852                     throw new Exception(rb.getString(
2853                                         &quot;No.certificate.from.the.SSL.server&quot;));
2854                 }
2855             } catch (CertStoreException cse) {
2856                 if (cse.getCause() instanceof IOException) {
2857                     throw new Exception(rb.getString(
2858                                         &quot;No.certificate.from.the.SSL.server&quot;),
2859                                         cse.getCause());
2860                 } else {
2861                     throw cse;
2862                 }
2863             }
2864 
2865             int i = 0;
2866             for (Certificate cert : chain) {
2867                 try {
2868                     if (rfc) {
2869                         dumpCert(cert, out);
2870                     } else {
2871                         out.println(&quot;Certificate #&quot; + i);
2872                         out.println(&quot;====================================&quot;);
2873                         printX509Cert((X509Certificate)cert, out);
2874                         out.println();
2875                     }
2876                     checkWeak(oneInMany(rb.getString(&quot;the.certificate&quot;), i++, chain.size()), cert);
2877                 } catch (Exception e) {
2878                     if (debug) {
2879                         e.printStackTrace();
2880                     }
2881                 }
2882             }
2883         } else {
2884             if (filename != null) {
2885                 try (FileInputStream inStream = new FileInputStream(filename)) {
2886                     printCertFromStream(inStream, out);
2887                 }
2888             } else {
2889                 printCertFromStream(System.in, out);
2890             }
2891         }
2892     }
2893 
2894     private void doChangeStorePasswd() throws Exception {
2895         storePassNew = newPass;
2896         if (storePassNew == null) {
2897             storePassNew = getNewPasswd(&quot;keystore password&quot;, storePass);
2898         }
2899         if (P12KEYSTORE.equalsIgnoreCase(storetype)) {
2900             // When storetype is PKCS12, we need to change all keypass as well
2901             for (String alias : Collections.list(keyStore.aliases())) {
2902                 if (!keyStore.isCertificateEntry(alias)) {
2903                     // keyPass should be either null or same with storePass,
2904                     // but keep it in case one day we want to &quot;normalize&quot;
2905                     // a PKCS12 keystore having different passwords.
2906                     Pair&lt;Entry, char[]&gt; objs
2907                             = recoverEntry(keyStore, alias, storePass, keyPass);
2908                     keyStore.setEntry(alias, objs.fst,
2909                             new PasswordProtection(storePassNew));
2910                 }
2911             }
2912         }
2913     }
2914 
2915     /**
2916      * Creates a self-signed certificate, and stores it as a single-element
2917      * certificate chain.
2918      */
2919     private void doSelfCert(String alias, String dname, String sigAlgName)
2920         throws Exception
2921     {
2922         if (alias == null) {
2923             alias = keyAlias;
2924         }
2925 
2926         Pair&lt;Key,char[]&gt; objs = recoverKey(alias, storePass, keyPass);
2927         PrivateKey privKey = (PrivateKey)objs.fst;
2928         if (keyPass == null)
2929             keyPass = objs.snd;
2930 
2931         // Determine the signature algorithm
2932         if (sigAlgName == null) {
2933             sigAlgName = getCompatibleSigAlgName(privKey);
2934         }
2935 
2936         // Get the old certificate
2937         Certificate oldCert = keyStore.getCertificate(alias);
2938         if (oldCert == null) {
2939             MessageFormat form = new MessageFormat
2940                 (rb.getString(&quot;alias.has.no.public.key&quot;));
2941             Object[] source = {alias};
2942             throw new Exception(form.format(source));
2943         }
2944         if (!(oldCert instanceof X509Certificate)) {
2945             MessageFormat form = new MessageFormat
2946                 (rb.getString(&quot;alias.has.no.X.509.certificate&quot;));
2947             Object[] source = {alias};
2948             throw new Exception(form.format(source));
2949         }
2950 
2951         // convert to X509CertImpl, so that we can modify selected fields
2952         // (no public APIs available yet)
2953         byte[] encoded = oldCert.getEncoded();
2954         X509CertImpl certImpl = new X509CertImpl(encoded);
2955         X509CertInfo certInfo = (X509CertInfo)certImpl.get(X509CertImpl.NAME
2956                                                            + &quot;.&quot; +
2957                                                            X509CertImpl.INFO);
2958 
2959         // Extend its validity
2960         Date firstDate = getStartDate(startDate);
2961         Date lastDate = new Date();
2962         lastDate.setTime(firstDate.getTime() + validity*1000L*24L*60L*60L);
2963         CertificateValidity interval = new CertificateValidity(firstDate,
2964                                                                lastDate);
2965         certInfo.set(X509CertInfo.VALIDITY, interval);
2966 
2967         // Make new serial number
2968         certInfo.set(X509CertInfo.SERIAL_NUMBER,
2969                 CertificateSerialNumber.newRandom64bit(new SecureRandom()));
2970 
2971         // Set owner and issuer fields
2972         X500Name owner;
2973         if (dname == null) {
2974             // Get the owner name from the certificate
2975             owner = (X500Name)certInfo.get(X509CertInfo.SUBJECT + &quot;.&quot; +
2976                                            X509CertInfo.DN_NAME);
2977         } else {
2978             // Use the owner name specified at the command line
2979             owner = new X500Name(dname);
2980             certInfo.set(X509CertInfo.SUBJECT + &quot;.&quot; +
2981                          X509CertInfo.DN_NAME, owner);
2982         }
2983         // Make issuer same as owner (self-signed!)
2984         certInfo.set(X509CertInfo.ISSUER + &quot;.&quot; +
2985                      X509CertInfo.DN_NAME, owner);
2986 
2987         // The inner and outer signature algorithms have to match.
2988         // The way we achieve that is really ugly, but there seems to be no
2989         // other solution: We first sign the cert, then retrieve the
2990         // outer sigalg and use it to set the inner sigalg
2991         X509CertImpl newCert = new X509CertImpl(certInfo);
2992         AlgorithmParameterSpec params = AlgorithmId
2993                 .getDefaultAlgorithmParameterSpec(sigAlgName, privKey);
2994         newCert.sign(privKey, params, sigAlgName, null);
2995         AlgorithmId sigAlgid = (AlgorithmId)newCert.get(X509CertImpl.SIG_ALG);
2996         certInfo.set(CertificateAlgorithmId.NAME + &quot;.&quot; +
2997                      CertificateAlgorithmId.ALGORITHM, sigAlgid);
2998 
2999         certInfo.set(X509CertInfo.VERSION,
3000                         new CertificateVersion(CertificateVersion.V3));
3001 
3002         CertificateExtensions ext = createV3Extensions(
3003                 null,
3004                 (CertificateExtensions)certInfo.get(X509CertInfo.EXTENSIONS),
3005                 v3ext,
3006                 oldCert.getPublicKey(),
3007                 null);
3008         certInfo.set(X509CertInfo.EXTENSIONS, ext);
3009         // Sign the new certificate
3010         newCert = new X509CertImpl(certInfo);
3011         newCert.sign(privKey, params, sigAlgName, null);
3012 
3013         // Store the new certificate as a single-element certificate chain
3014         keyStore.setKeyEntry(alias, privKey,
3015                              (keyPass != null) ? keyPass : storePass,
3016                              new Certificate[] { newCert } );
3017 
3018         if (verbose) {
3019             System.err.println(rb.getString(&quot;New.certificate.self.signed.&quot;));
3020             System.err.print(newCert.toString());
3021             System.err.println();
3022         }
3023     }
3024 
3025     /**
3026      * Processes a certificate reply from a certificate authority.
3027      *
3028      * &lt;p&gt;Builds a certificate chain on top of the certificate reply,
3029      * using trusted certificates from the keystore. The chain is complete
3030      * after a self-signed certificate has been encountered. The self-signed
3031      * certificate is considered a root certificate authority, and is stored
3032      * at the end of the chain.
3033      *
3034      * &lt;p&gt;The newly generated chain replaces the old chain associated with the
3035      * key entry.
3036      *
3037      * @return true if the certificate reply was installed, otherwise false.
3038      */
3039     private boolean installReply(String alias, InputStream in)
3040         throws Exception
3041     {
3042         if (alias == null) {
3043             alias = keyAlias;
3044         }
3045 
3046         Pair&lt;Key,char[]&gt; objs = recoverKey(alias, storePass, keyPass);
3047         PrivateKey privKey = (PrivateKey)objs.fst;
3048         if (keyPass == null) {
3049             keyPass = objs.snd;
3050         }
3051 
3052         Certificate userCert = keyStore.getCertificate(alias);
3053         if (userCert == null) {
3054             MessageFormat form = new MessageFormat
3055                 (rb.getString(&quot;alias.has.no.public.key.certificate.&quot;));
3056             Object[] source = {alias};
3057             throw new Exception(form.format(source));
3058         }
3059 
3060         // Read the certificates in the reply
3061         Collection&lt;? extends Certificate&gt; c = generateCertificates(in);
3062         if (c.isEmpty()) {
3063             throw new Exception(rb.getString(&quot;Reply.has.no.certificates&quot;));
3064         }
3065         Certificate[] replyCerts = c.toArray(new Certificate[c.size()]);
3066         Certificate[] newChain;
3067         if (replyCerts.length == 1) {
3068             // single-cert reply
3069             newChain = establishCertChain(userCert, replyCerts[0]);
3070         } else {
3071             // cert-chain reply (e.g., PKCS#7)
3072             newChain = validateReply(alias, userCert, replyCerts);
3073         }
3074 
3075         // Now store the newly established chain in the keystore. The new
3076         // chain replaces the old one. The chain can be null if user chooses no.
3077         if (newChain != null) {
3078             keyStore.setKeyEntry(alias, privKey,
3079                                  (keyPass != null) ? keyPass : storePass,
3080                                  newChain);
3081             return true;
3082         } else {
3083             return false;
3084         }
3085     }
3086 
3087     /**
3088      * Imports a certificate and adds it to the list of trusted certificates.
3089      *
3090      * @return true if the certificate was added, otherwise false.
3091      */
3092     private boolean addTrustedCert(String alias, InputStream in)
3093         throws Exception
3094     {
3095         if (alias == null) {
3096             throw new Exception(rb.getString(&quot;Must.specify.alias&quot;));
3097         }
3098         if (keyStore.containsAlias(alias)) {
3099             MessageFormat form = new MessageFormat(rb.getString
3100                 (&quot;Certificate.not.imported.alias.alias.already.exists&quot;));
3101             Object[] source = {alias};
3102             throw new Exception(form.format(source));
3103         }
3104 
3105         // Read the certificate
3106         X509Certificate cert = null;
3107         try {
3108             cert = (X509Certificate)generateCertificate(in);
3109         } catch (ClassCastException | CertificateException ce) {
3110             throw new Exception(rb.getString(&quot;Input.not.an.X.509.certificate&quot;));
3111         }
3112 
3113         if (noprompt) {
3114             checkWeak(rb.getString(&quot;the.input&quot;), cert);
3115             keyStore.setCertificateEntry(alias, cert);
3116             return true;
3117         }
3118 
3119         // if certificate is self-signed, make sure it verifies
3120         boolean selfSigned = false;
3121         if (KeyStoreUtil.isSelfSigned(cert)) {
3122             cert.verify(cert.getPublicKey());
3123             selfSigned = true;
3124         }
3125 
3126         // check if cert already exists in keystore
3127         String reply = null;
3128         String trustalias = keyStore.getCertificateAlias(cert);
3129         if (trustalias != null) {
3130             MessageFormat form = new MessageFormat(rb.getString
3131                 (&quot;Certificate.already.exists.in.keystore.under.alias.trustalias.&quot;));
3132             Object[] source = {trustalias};
3133             System.err.println(form.format(source));
3134             checkWeak(rb.getString(&quot;the.input&quot;), cert);
3135             printWeakWarnings(true);
3136             reply = getYesNoReply
3137                 (rb.getString(&quot;Do.you.still.want.to.add.it.no.&quot;));
3138         } else if (selfSigned) {
3139             if (trustcacerts &amp;&amp; (caks != null) &amp;&amp;
3140                     ((trustalias=caks.getCertificateAlias(cert)) != null)) {
3141                 MessageFormat form = new MessageFormat(rb.getString
3142                         (&quot;Certificate.already.exists.in.system.wide.CA.keystore.under.alias.trustalias.&quot;));
3143                 Object[] source = {trustalias};
3144                 System.err.println(form.format(source));
3145                 checkWeak(rb.getString(&quot;the.input&quot;), cert);
3146                 printWeakWarnings(true);
3147                 reply = getYesNoReply
3148                         (rb.getString(&quot;Do.you.still.want.to.add.it.to.your.own.keystore.no.&quot;));
3149             }
3150             if (trustalias == null) {
3151                 // Print the cert and ask user if they really want to add
3152                 // it to their keystore
3153                 printX509Cert(cert, System.out);
3154                 checkWeak(rb.getString(&quot;the.input&quot;), cert);
3155                 printWeakWarnings(true);
3156                 reply = getYesNoReply
3157                         (rb.getString(&quot;Trust.this.certificate.no.&quot;));
3158             }
3159         }
3160         if (reply != null) {
3161             if (&quot;YES&quot;.equals(reply)) {
3162                 keyStore.setCertificateEntry(alias, cert);
3163                 return true;
3164             } else {
3165                 return false;
3166             }
3167         }
3168 
3169         // Not found in this keystore and not self-signed
3170         // Try to establish trust chain
3171         try {
3172             Certificate[] chain = establishCertChain(null, cert);
3173             if (chain != null) {
3174                 keyStore.setCertificateEntry(alias, cert);
3175                 return true;
3176             }
3177         } catch (Exception e) {
3178             // Print the cert and ask user if they really want to add it to
3179             // their keystore
3180             printX509Cert(cert, System.out);
3181             checkWeak(rb.getString(&quot;the.input&quot;), cert);
3182             printWeakWarnings(true);
3183             reply = getYesNoReply
3184                 (rb.getString(&quot;Trust.this.certificate.no.&quot;));
3185             if (&quot;YES&quot;.equals(reply)) {
3186                 keyStore.setCertificateEntry(alias, cert);
3187                 return true;
3188             } else {
3189                 return false;
3190             }
3191         }
3192 
3193         return false;
3194     }
3195 
3196     /**
3197      * Prompts user for new password. New password must be different from
3198      * old one.
3199      *
3200      * @param prompt the message that gets prompted on the screen
3201      * @param oldPasswd the current (i.e., old) password
3202      */
3203     private char[] getNewPasswd(String prompt, char[] oldPasswd)
3204         throws Exception
3205     {
3206         char[] entered = null;
3207         char[] reentered = null;
3208 
3209         for (int count = 0; count &lt; 3; count++) {
3210             MessageFormat form = new MessageFormat
3211                 (rb.getString(&quot;New.prompt.&quot;));
3212             Object[] source = {prompt};
3213             System.err.print(form.format(source));
3214             entered = Password.readPassword(System.in);
3215             passwords.add(entered);
3216             if (entered == null || entered.length &lt; 6) {
3217                 System.err.println(rb.getString
3218                     (&quot;Password.is.too.short.must.be.at.least.6.characters&quot;));
3219             } else if (Arrays.equals(entered, oldPasswd)) {
3220                 System.err.println(rb.getString(&quot;Passwords.must.differ&quot;));
3221             } else {
3222                 form = new MessageFormat
3223                         (rb.getString(&quot;Re.enter.new.prompt.&quot;));
3224                 Object[] src = {prompt};
3225                 System.err.print(form.format(src));
3226                 reentered = Password.readPassword(System.in);
3227                 passwords.add(reentered);
3228                 if (!Arrays.equals(entered, reentered)) {
3229                     System.err.println
3230                         (rb.getString(&quot;They.don.t.match.Try.again&quot;));
3231                 } else {
3232                     Arrays.fill(reentered, &#39; &#39;);
3233                     return entered;
3234                 }
3235             }
3236             if (entered != null) {
3237                 Arrays.fill(entered, &#39; &#39;);
3238                 entered = null;
3239             }
3240             if (reentered != null) {
3241                 Arrays.fill(reentered, &#39; &#39;);
3242                 reentered = null;
3243             }
3244         }
3245         throw new Exception(rb.getString(&quot;Too.many.failures.try.later&quot;));
3246     }
3247 
3248     /**
3249      * Prompts user for alias name.
3250      * @param prompt the {0} of &quot;Enter {0} alias name:  &quot; in prompt line
3251      * @return the string entered by the user, without the \n at the end
3252      */
3253     private String getAlias(String prompt) throws Exception {
3254         if (prompt != null) {
3255             MessageFormat form = new MessageFormat
3256                 (rb.getString(&quot;Enter.prompt.alias.name.&quot;));
3257             Object[] source = {prompt};
3258             System.err.print(form.format(source));
3259         } else {
3260             System.err.print(rb.getString(&quot;Enter.alias.name.&quot;));
3261         }
3262         return (new BufferedReader(new InputStreamReader(
3263                                         System.in))).readLine();
3264     }
3265 
3266     /**
3267      * Prompts user for an input string from the command line (System.in)
3268      * @prompt the prompt string printed
3269      * @return the string entered by the user, without the \n at the end
3270      */
3271     private String inputStringFromStdin(String prompt) throws Exception {
3272         System.err.print(prompt);
3273         return (new BufferedReader(new InputStreamReader(
3274                                         System.in))).readLine();
3275     }
3276 
3277     /**
3278      * Prompts user for key password. User may select to choose the same
3279      * password (&lt;code&gt;otherKeyPass&lt;/code&gt;) as for &lt;code&gt;otherAlias&lt;/code&gt;.
3280      */
3281     private char[] getKeyPasswd(String alias, String otherAlias,
3282                                 char[] otherKeyPass)
3283         throws Exception
3284     {
3285         int count = 0;
3286         char[] keyPass = null;
3287 
3288         do {
3289             if (otherKeyPass != null) {
3290                 MessageFormat form = new MessageFormat(rb.getString
3291                         (&quot;Enter.key.password.for.alias.&quot;));
3292                 Object[] source = {alias};
3293                 System.err.println(form.format(source));
3294 
3295                 form = new MessageFormat(rb.getString
3296                         (&quot;.RETURN.if.same.as.for.otherAlias.&quot;));
3297                 Object[] src = {otherAlias};
3298                 System.err.print(form.format(src));
3299             } else {
3300                 MessageFormat form = new MessageFormat(rb.getString
3301                         (&quot;Enter.key.password.for.alias.&quot;));
3302                 Object[] source = {alias};
3303                 System.err.print(form.format(source));
3304             }
3305             System.err.flush();
3306             keyPass = Password.readPassword(System.in);
3307             passwords.add(keyPass);
3308             if (keyPass == null) {
3309                 keyPass = otherKeyPass;
3310             }
3311             count++;
3312         } while ((keyPass == null) &amp;&amp; count &lt; 3);
3313 
3314         if (keyPass == null) {
3315             throw new Exception(rb.getString(&quot;Too.many.failures.try.later&quot;));
3316         }
3317 
3318         return keyPass;
3319     }
3320 
3321     private String withWeak(String alg) {
3322         if (DISABLED_CHECK.permits(SIG_PRIMITIVE_SET, alg, null)) {
3323             return alg;
3324         } else {
3325             return String.format(rb.getString(&quot;with.weak&quot;), alg);
3326         }
3327     }
3328 
3329     private String fullDisplayAlgName(Key key) {
3330         String result = key.getAlgorithm();
3331         if (key instanceof ECKey) {
3332             ECParameterSpec paramSpec = ((ECKey) key).getParams();
3333             if (paramSpec instanceof NamedCurve) {
3334                 result += &quot; (&quot; + paramSpec.toString().split(&quot; &quot;)[0] + &quot;)&quot;;
3335             }
3336         }
3337         return result;
3338     }
3339 
3340     private String withWeak(Key key) {
3341         int kLen = KeyUtil.getKeySize(key);
3342         String displayAlg = fullDisplayAlgName(key);
3343         if (DISABLED_CHECK.permits(SIG_PRIMITIVE_SET, key)) {
3344             if (kLen &gt;= 0) {
3345                 return String.format(rb.getString(&quot;key.bit&quot;), kLen, displayAlg);
3346             } else {
3347                 return String.format(rb.getString(&quot;unknown.size.1&quot;), displayAlg);
3348             }
3349         } else {
3350             return String.format(rb.getString(&quot;key.bit.weak&quot;), kLen, displayAlg);
3351         }
3352     }
3353 
3354     /**
3355      * Prints a certificate in a human readable format.
3356      */
3357     private void printX509Cert(X509Certificate cert, PrintStream out)
3358         throws Exception
3359     {
3360 
3361         MessageFormat form = new MessageFormat
3362                 (rb.getString(&quot;.PATTERN.printX509Cert.with.weak&quot;));
3363         PublicKey pkey = cert.getPublicKey();
3364         String sigName = cert.getSigAlgName();
3365         // No need to warn about sigalg of a trust anchor
3366         if (!isTrustedCert(cert)) {
3367             sigName = withWeak(sigName);
3368         }
3369         Object[] source = {cert.getSubjectDN().toString(),
3370                         cert.getIssuerDN().toString(),
3371                         cert.getSerialNumber().toString(16),
3372                         cert.getNotBefore().toString(),
3373                         cert.getNotAfter().toString(),
3374                         getCertFingerPrint(&quot;SHA-1&quot;, cert),
3375                         getCertFingerPrint(&quot;SHA-256&quot;, cert),
3376                         sigName,
3377                         withWeak(pkey),
3378                         cert.getVersion()
3379                         };
3380         out.println(form.format(source));
3381 
3382         if (cert instanceof X509CertImpl) {
3383             X509CertImpl impl = (X509CertImpl)cert;
3384             X509CertInfo certInfo = (X509CertInfo)impl.get(X509CertImpl.NAME
3385                                                            + &quot;.&quot; +
3386                                                            X509CertImpl.INFO);
3387             CertificateExtensions exts = (CertificateExtensions)
3388                     certInfo.get(X509CertInfo.EXTENSIONS);
3389             if (exts != null) {
3390                 printExtensions(rb.getString(&quot;Extensions.&quot;), exts, out);
3391             }
3392         }
3393     }
3394 
3395     private static void printExtensions(String title, CertificateExtensions exts, PrintStream out)
3396             throws Exception {
3397         int extnum = 0;
3398         Iterator&lt;Extension&gt; i1 = exts.getAllExtensions().iterator();
3399         Iterator&lt;Extension&gt; i2 = exts.getUnparseableExtensions().values().iterator();
3400         while (i1.hasNext() || i2.hasNext()) {
3401             Extension ext = i1.hasNext()?i1.next():i2.next();
3402             if (extnum == 0) {
3403                 out.println();
3404                 out.println(title);
3405                 out.println();
3406             }
3407             out.print(&quot;#&quot;+(++extnum)+&quot;: &quot;+ ext);
3408             if (ext.getClass() == Extension.class) {
3409                 byte[] v = ext.getExtensionValue();
3410                 if (v.length == 0) {
3411                     out.println(rb.getString(&quot;.Empty.value.&quot;));
3412                 } else {
3413                     new sun.security.util.HexDumpEncoder().encodeBuffer(ext.getExtensionValue(), out);
3414                     out.println();
3415                 }
3416             }
3417             out.println();
3418         }
3419     }
3420 
3421     /**
3422      * Locates a signer for a given certificate from a given keystore and
3423      * returns the signer&#39;s certificate.
3424      * @param cert the certificate whose signer is searched, not null
3425      * @param ks the keystore to search with, not null
3426      * @return &lt;code&gt;cert&lt;/code&gt; itself if it&#39;s already inside &lt;code&gt;ks&lt;/code&gt;,
3427      * or a certificate inside &lt;code&gt;ks&lt;/code&gt; who signs &lt;code&gt;cert&lt;/code&gt;,
3428      * or null otherwise. A label is added.
3429      */
3430     private static Pair&lt;String,Certificate&gt;
3431             getSigner(Certificate cert, KeyStore ks) throws Exception {
3432         if (ks.getCertificateAlias(cert) != null) {
3433             return new Pair&lt;&gt;(&quot;&quot;, cert);
3434         }
3435         for (Enumeration&lt;String&gt; aliases = ks.aliases();
3436                 aliases.hasMoreElements(); ) {
3437             String name = aliases.nextElement();
3438             Certificate trustedCert = ks.getCertificate(name);
3439             if (trustedCert != null) {
3440                 try {
3441                     cert.verify(trustedCert.getPublicKey());
3442                     return new Pair&lt;&gt;(name, trustedCert);
3443                 } catch (Exception e) {
3444                     // Not verified, skip to the next one
3445                 }
3446             }
3447         }
3448         return null;
3449     }
3450 
3451     /**
3452      * Gets an X.500 name suitable for inclusion in a certification request.
3453      */
3454     private X500Name getX500Name() throws IOException {
3455         BufferedReader in;
3456         in = new BufferedReader(new InputStreamReader(System.in));
3457         String commonName = &quot;Unknown&quot;;
3458         String organizationalUnit = &quot;Unknown&quot;;
3459         String organization = &quot;Unknown&quot;;
3460         String city = &quot;Unknown&quot;;
3461         String state = &quot;Unknown&quot;;
3462         String country = &quot;Unknown&quot;;
3463         X500Name name;
3464         String userInput = null;
3465 
3466         int maxRetry = 20;
3467         do {
3468             if (maxRetry-- &lt; 0) {
3469                 throw new RuntimeException(rb.getString(
3470                         &quot;Too.many.retries.program.terminated&quot;));
3471             }
3472             commonName = inputString(in,
3473                     rb.getString(&quot;What.is.your.first.and.last.name.&quot;),
3474                     commonName);
3475             organizationalUnit = inputString(in,
3476                     rb.getString
3477                         (&quot;What.is.the.name.of.your.organizational.unit.&quot;),
3478                     organizationalUnit);
3479             organization = inputString(in,
3480                     rb.getString(&quot;What.is.the.name.of.your.organization.&quot;),
3481                     organization);
3482             city = inputString(in,
3483                     rb.getString(&quot;What.is.the.name.of.your.City.or.Locality.&quot;),
3484                     city);
3485             state = inputString(in,
3486                     rb.getString(&quot;What.is.the.name.of.your.State.or.Province.&quot;),
3487                     state);
3488             country = inputString(in,
3489                     rb.getString
3490                         (&quot;What.is.the.two.letter.country.code.for.this.unit.&quot;),
3491                     country);
3492             name = new X500Name(commonName, organizationalUnit, organization,
3493                                 city, state, country);
3494             MessageFormat form = new MessageFormat
3495                 (rb.getString(&quot;Is.name.correct.&quot;));
3496             Object[] source = {name};
3497             userInput = inputString
3498                 (in, form.format(source), rb.getString(&quot;no&quot;));
3499         } while (collator.compare(userInput, rb.getString(&quot;yes&quot;)) != 0 &amp;&amp;
3500                  collator.compare(userInput, rb.getString(&quot;y&quot;)) != 0);
3501 
3502         System.err.println();
3503         return name;
3504     }
3505 
3506     private String inputString(BufferedReader in, String prompt,
3507                                String defaultValue)
3508         throws IOException
3509     {
3510         System.err.println(prompt);
3511         MessageFormat form = new MessageFormat
3512                 (rb.getString(&quot;.defaultValue.&quot;));
3513         Object[] source = {defaultValue};
3514         System.err.print(form.format(source));
3515         System.err.flush();
3516 
3517         String value = in.readLine();
3518         if (value == null || collator.compare(value, &quot;&quot;) == 0) {
3519             value = defaultValue;
3520         }
3521         return value;
3522     }
3523 
3524     /**
3525      * Writes an X.509 certificate in base64 or binary encoding to an output
3526      * stream.
3527      */
3528     private void dumpCert(Certificate cert, PrintStream out)
3529         throws IOException, CertificateException
3530     {
3531         if (rfc) {
3532             out.println(X509Factory.BEGIN_CERT);
3533             out.println(Base64.getMimeEncoder(64, CRLF).encodeToString(cert.getEncoded()));
3534             out.println(X509Factory.END_CERT);
3535         } else {
3536             out.write(cert.getEncoded()); // binary
3537         }
3538     }
3539 
3540     /**
3541      * Converts a byte to hex digit and writes to the supplied buffer
3542      */
3543     private void byte2hex(byte b, StringBuffer buf) {
3544         char[] hexChars = { &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;,
3545                             &#39;9&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39; };
3546         int high = ((b &amp; 0xf0) &gt;&gt; 4);
3547         int low = (b &amp; 0x0f);
3548         buf.append(hexChars[high]);
3549         buf.append(hexChars[low]);
3550     }
3551 
3552     /**
3553      * Converts a byte array to hex string
3554      */
3555     private String toHexString(byte[] block) {
3556         StringBuffer buf = new StringBuffer();
3557         int len = block.length;
3558         for (int i = 0; i &lt; len; i++) {
3559              byte2hex(block[i], buf);
3560              if (i &lt; len-1) {
3561                  buf.append(&quot;:&quot;);
3562              }
3563         }
3564         return buf.toString();
3565     }
3566 
3567     /**
3568      * Recovers (private) key associated with given alias.
3569      *
3570      * @return an array of objects, where the 1st element in the array is the
3571      * recovered private key, and the 2nd element is the password used to
3572      * recover it.
3573      */
3574     private Pair&lt;Key,char[]&gt; recoverKey(String alias, char[] storePass,
3575                                        char[] keyPass)
3576         throws Exception
3577     {
3578         Key key = null;
3579 
3580         if (KeyStoreUtil.isWindowsKeyStore(storetype)) {
3581             key = keyStore.getKey(alias, null);
3582             return Pair.of(key, null);
3583         }
3584 
3585         if (keyStore.containsAlias(alias) == false) {
3586             MessageFormat form = new MessageFormat
3587                 (rb.getString(&quot;Alias.alias.does.not.exist&quot;));
3588             Object[] source = {alias};
3589             throw new Exception(form.format(source));
3590         }
3591         if (!keyStore.entryInstanceOf(alias, KeyStore.PrivateKeyEntry.class) &amp;&amp;
3592                 !keyStore.entryInstanceOf(alias, KeyStore.SecretKeyEntry.class)) {
3593             MessageFormat form = new MessageFormat
3594                 (rb.getString(&quot;Alias.alias.has.no.key&quot;));
3595             Object[] source = {alias};
3596             throw new Exception(form.format(source));
3597         }
3598 
3599         if (keyPass == null) {
3600             // Try to recover the key using the keystore password
3601             if (storePass != null) {
3602                 try {
3603                     key = keyStore.getKey(alias, storePass);
3604                     passwords.add(storePass);
3605                     return Pair.of(key, storePass);
3606                 } catch (UnrecoverableKeyException e) {
3607                     if (token) {
3608                         throw e;
3609                     }
3610                 }
3611             }
3612             // prompt user for key password
3613             keyPass = getKeyPasswd(alias, null, null);
3614             key = keyStore.getKey(alias, keyPass);
3615             return Pair.of(key, keyPass);
3616         } else {
3617             key = keyStore.getKey(alias, keyPass);
3618             return Pair.of(key, keyPass);
3619         }
3620     }
3621 
3622     /**
3623      * Recovers entry associated with given alias.
3624      *
3625      * @return an array of objects, where the 1st element in the array is the
3626      * recovered entry, and the 2nd element is the password used to
3627      * recover it (null if no password).
3628      */
3629     private Pair&lt;Entry,char[]&gt; recoverEntry(KeyStore ks,
3630                             String alias,
3631                             char[] pstore,
3632                             char[] pkey) throws Exception {
3633 
3634         if (!ks.containsAlias(alias)) {
3635             MessageFormat form = new MessageFormat(
3636                     rb.getString(&quot;Alias.alias.does.not.exist&quot;));
3637             Object[] source = {alias};
3638             throw new Exception(form.format(source));
3639         }
3640 
3641         // Step 1: First attempt to access entry without key password
3642         // (PKCS11 entry or trusted certificate entry, for example).
3643         // If fail, go next.
3644         try {
3645             Entry entry = ks.getEntry(alias, null);
3646             return Pair.of(entry, null);
3647         } catch (UnrecoverableEntryException une) {
3648             if(P11KEYSTORE.equalsIgnoreCase(ks.getType()) ||
3649                     KeyStoreUtil.isWindowsKeyStore(ks.getType())) {
3650                 // should not happen, but a possibility
3651                 throw une;
3652             }
3653         }
3654 
3655         // entry is protected
3656 
3657         // Step 2: try pkey if not null. If fail, fail.
3658         if (pkey != null) {
3659             PasswordProtection pp = new PasswordProtection(pkey);
3660             Entry entry = ks.getEntry(alias, pp);
3661             return Pair.of(entry, pkey);
3662         }
3663 
3664         // Step 3: try pstore if not null. If fail, go next.
3665         if (pstore != null) {
3666             try {
3667                 PasswordProtection pp = new PasswordProtection(pstore);
3668                 Entry entry = ks.getEntry(alias, pp);
3669                 return Pair.of(entry, pstore);
3670             } catch (UnrecoverableEntryException une) {
3671                 if (P12KEYSTORE.equalsIgnoreCase(ks.getType())) {
3672                     // P12 keystore currently does not support separate
3673                     // store and entry passwords. We will not prompt for
3674                     // entry password.
3675                     throw une;
3676                 }
3677             }
3678         }
3679 
3680         // Step 4: prompt for entry password
3681         pkey = getKeyPasswd(alias, null, null);
3682         PasswordProtection pp = new PasswordProtection(pkey);
3683         Entry entry = ks.getEntry(alias, pp);
3684         return Pair.of(entry, pkey);
3685     }
3686 
3687     /**
3688      * Gets the requested finger print of the certificate.
3689      */
3690     private String getCertFingerPrint(String mdAlg, Certificate cert)
3691         throws Exception
3692     {
3693         byte[] encCertInfo = cert.getEncoded();
3694         MessageDigest md = MessageDigest.getInstance(mdAlg);
3695         byte[] digest = md.digest(encCertInfo);
3696         return toHexString(digest);
3697     }
3698 
3699     /**
3700      * Prints warning about missing integrity check.
3701      */
3702     private void printNoIntegrityWarning() {
3703         System.err.println();
3704         System.err.println(rb.getString
3705             (&quot;.WARNING.WARNING.WARNING.&quot;));
3706         System.err.println(rb.getString
3707             (&quot;.The.integrity.of.the.information.stored.in.your.keystore.&quot;));
3708         System.err.println(rb.getString
3709             (&quot;.WARNING.WARNING.WARNING.&quot;));
3710         System.err.println();
3711     }
3712 
3713     /**
3714      * Validates chain in certification reply, and returns the ordered
3715      * elements of the chain (with user certificate first, and root
3716      * certificate last in the array).
3717      *
3718      * @param alias the alias name
3719      * @param userCert the user certificate of the alias
3720      * @param replyCerts the chain provided in the reply
3721      */
3722     private Certificate[] validateReply(String alias,
3723                                         Certificate userCert,
3724                                         Certificate[] replyCerts)
3725         throws Exception
3726     {
3727 
3728         checkWeak(rb.getString(&quot;reply&quot;), replyCerts);
3729 
3730         // order the certs in the reply (bottom-up).
3731         // we know that all certs in the reply are of type X.509, because
3732         // we parsed them using an X.509 certificate factory
3733         int i;
3734         PublicKey userPubKey = userCert.getPublicKey();
3735 
3736         // Remove duplicated certificates.
3737         HashSet&lt;Certificate&gt; nodup = new HashSet&lt;&gt;(Arrays.asList(replyCerts));
3738         replyCerts = nodup.toArray(new Certificate[nodup.size()]);
3739 
3740         for (i=0; i&lt;replyCerts.length; i++) {
3741             if (userPubKey.equals(replyCerts[i].getPublicKey())) {
3742                 break;
3743             }
3744         }
3745         if (i == replyCerts.length) {
3746             MessageFormat form = new MessageFormat(rb.getString
3747                 (&quot;Certificate.reply.does.not.contain.public.key.for.alias.&quot;));
3748             Object[] source = {alias};
3749             throw new Exception(form.format(source));
3750         }
3751 
3752         Certificate tmpCert = replyCerts[0];
3753         replyCerts[0] = replyCerts[i];
3754         replyCerts[i] = tmpCert;
3755 
3756         X509Certificate thisCert = (X509Certificate)replyCerts[0];
3757 
3758         for (i=1; i &lt; replyCerts.length-1; i++) {
3759             // find a cert in the reply who signs thisCert
3760             int j;
3761             for (j=i; j&lt;replyCerts.length; j++) {
3762                 if (KeyStoreUtil.signedBy(thisCert, (X509Certificate)replyCerts[j])) {
3763                     tmpCert = replyCerts[i];
3764                     replyCerts[i] = replyCerts[j];
3765                     replyCerts[j] = tmpCert;
3766                     thisCert = (X509Certificate)replyCerts[i];
3767                     break;
3768                 }
3769             }
3770             if (j == replyCerts.length) {
3771                 throw new Exception
3772                     (rb.getString(&quot;Incomplete.certificate.chain.in.reply&quot;));
3773             }
3774         }
3775 
3776         if (noprompt) {
3777             return replyCerts;
3778         }
3779 
3780         // do we trust the cert at the top?
3781         Certificate topCert = replyCerts[replyCerts.length-1];
3782         boolean fromKeyStore = true;
3783         Pair&lt;String,Certificate&gt; root = getSigner(topCert, keyStore);
3784         if (root == null &amp;&amp; trustcacerts &amp;&amp; caks != null) {
3785             root = getSigner(topCert, caks);
3786             fromKeyStore = false;
3787         }
3788         if (root == null) {
3789             System.err.println();
3790             System.err.println
3791                     (rb.getString(&quot;Top.level.certificate.in.reply.&quot;));
3792             printX509Cert((X509Certificate)topCert, System.out);
3793             System.err.println();
3794             System.err.print(rb.getString(&quot;.is.not.trusted.&quot;));
3795             printWeakWarnings(true);
3796             String reply = getYesNoReply
3797                     (rb.getString(&quot;Install.reply.anyway.no.&quot;));
3798             if (&quot;NO&quot;.equals(reply)) {
3799                 return null;
3800             }
3801         } else {
3802             if (root.snd != topCert) {
3803                 // append the root CA cert to the chain
3804                 Certificate[] tmpCerts =
3805                     new Certificate[replyCerts.length+1];
3806                 System.arraycopy(replyCerts, 0, tmpCerts, 0,
3807                                  replyCerts.length);
3808                 tmpCerts[tmpCerts.length-1] = root.snd;
3809                 replyCerts = tmpCerts;
3810                 checkWeak(String.format(fromKeyStore
3811                                 ? rb.getString(&quot;alias.in.keystore&quot;)
3812                                 : rb.getString(&quot;alias.in.cacerts&quot;),
3813                                         root.fst),
3814                           root.snd);
3815             }
3816         }
3817         return replyCerts;
3818     }
3819 
3820     /**
3821      * Establishes a certificate chain (using trusted certificates in the
3822      * keystore and cacerts), starting with the reply (certToVerify)
3823      * and ending at a self-signed certificate found in the keystore.
3824      *
3825      * @param userCert optional existing certificate, mostly likely be the
3826      *                 original self-signed cert created by -genkeypair.
3827      *                 It must have the same public key as certToVerify
3828      *                 but cannot be the same cert.
3829      * @param certToVerify the starting certificate to build the chain
3830      * @returns the established chain, might be null if user decides not
3831      */
3832     private Certificate[] establishCertChain(Certificate userCert,
3833                                              Certificate certToVerify)
3834         throws Exception
3835     {
3836         if (userCert != null) {
3837             // Make sure that the public key of the certificate reply matches
3838             // the original public key in the keystore
3839             PublicKey origPubKey = userCert.getPublicKey();
3840             PublicKey replyPubKey = certToVerify.getPublicKey();
3841             if (!origPubKey.equals(replyPubKey)) {
3842                 throw new Exception(rb.getString
3843                         (&quot;Public.keys.in.reply.and.keystore.don.t.match&quot;));
3844             }
3845 
3846             // If the two certs are identical, we&#39;re done: no need to import
3847             // anything
3848             if (certToVerify.equals(userCert)) {
3849                 throw new Exception(rb.getString
3850                         (&quot;Certificate.reply.and.certificate.in.keystore.are.identical&quot;));
3851             }
3852         }
3853 
3854         // Build a hash table of all certificates in the keystore.
3855         // Use the subject distinguished name as the key into the hash table.
3856         // All certificates associated with the same subject distinguished
3857         // name are stored in the same hash table entry as a vector.
3858         Hashtable&lt;Principal, Vector&lt;Pair&lt;String,X509Certificate&gt;&gt;&gt; certs = null;
3859         if (keyStore.size() &gt; 0) {
3860             certs = new Hashtable&lt;&gt;(11);
3861             keystorecerts2Hashtable(keyStore, certs);
3862         }
3863         if (trustcacerts) {
3864             if (caks!=null &amp;&amp; caks.size()&gt;0) {
3865                 if (certs == null) {
3866                     certs = new Hashtable&lt;&gt;(11);
3867                 }
3868                 keystorecerts2Hashtable(caks, certs);
3869             }
3870         }
3871 
3872         // start building chain
3873         Vector&lt;Pair&lt;String,X509Certificate&gt;&gt; chain = new Vector&lt;&gt;(2);
3874         if (buildChain(
3875                 new Pair&lt;&gt;(rb.getString(&quot;the.input&quot;),
3876                            (X509Certificate) certToVerify),
3877                 chain, certs)) {
3878             for (Pair&lt;String,X509Certificate&gt; p : chain) {
3879                 checkWeak(p.fst, p.snd);
3880             }
3881             Certificate[] newChain =
3882                     new Certificate[chain.size()];
3883             // buildChain() returns chain with self-signed root-cert first and
3884             // user-cert last, so we need to invert the chain before we store
3885             // it
3886             int j=0;
3887             for (int i=chain.size()-1; i&gt;=0; i--) {
3888                 newChain[j] = chain.elementAt(i).snd;
3889                 j++;
3890             }
3891             return newChain;
3892         } else {
3893             throw new Exception
3894                 (rb.getString(&quot;Failed.to.establish.chain.from.reply&quot;));
3895         }
3896     }
3897 
3898     /**
3899      * Recursively tries to establish chain from pool of certs starting from
3900      * certToVerify until a self-signed cert is found, and fill the certs found
3901      * into chain. Each cert in the chain signs the next one.
3902      *
3903      * This method is able to recover from an error, say, if certToVerify
3904      * is signed by certA but certA has no issuer in certs and itself is not
3905      * self-signed, the method can try another certB that also signs
3906      * certToVerify and look for signer of certB, etc, etc.
3907      *
3908      * Each cert in chain comes with a label showing its origin. The label is
3909      * used in the warning message when the cert is considered a risk.
3910      *
3911      * @param certToVerify the cert that needs to be verified.
3912      * @param chain the chain that&#39;s being built.
3913      * @param certs the pool of trusted certs
3914      *
3915      * @return true if successful, false otherwise.
3916      */
3917     private boolean buildChain(Pair&lt;String,X509Certificate&gt; certToVerify,
3918             Vector&lt;Pair&lt;String,X509Certificate&gt;&gt; chain,
3919             Hashtable&lt;Principal, Vector&lt;Pair&lt;String,X509Certificate&gt;&gt;&gt; certs) {
3920         if (KeyStoreUtil.isSelfSigned(certToVerify.snd)) {
3921             // reached self-signed root cert;
3922             // no verification needed because it&#39;s trusted.
3923             chain.addElement(certToVerify);
3924             return true;
3925         }
3926 
3927         Principal issuer = certToVerify.snd.getIssuerDN();
3928 
3929         // Get the issuer&#39;s certificate(s)
3930         Vector&lt;Pair&lt;String,X509Certificate&gt;&gt; vec = certs.get(issuer);
3931         if (vec == null) {
3932             return false;
3933         }
3934 
3935         // Try out each certificate in the vector, until we find one
3936         // whose public key verifies the signature of the certificate
3937         // in question.
3938         for (Enumeration&lt;Pair&lt;String,X509Certificate&gt;&gt; issuerCerts = vec.elements();
3939                 issuerCerts.hasMoreElements(); ) {
3940             Pair&lt;String,X509Certificate&gt; issuerCert = issuerCerts.nextElement();
3941             PublicKey issuerPubKey = issuerCert.snd.getPublicKey();
3942             try {
3943                 certToVerify.snd.verify(issuerPubKey);
3944             } catch (Exception e) {
3945                 continue;
3946             }
3947             if (buildChain(issuerCert, chain, certs)) {
3948                 chain.addElement(certToVerify);
3949                 return true;
3950             }
3951         }
3952         return false;
3953     }
3954 
3955     /**
3956      * Prompts user for yes/no decision.
3957      *
3958      * @return the user&#39;s decision, can only be &quot;YES&quot; or &quot;NO&quot;
3959      */
3960     private String getYesNoReply(String prompt)
3961         throws IOException
3962     {
3963         String reply = null;
3964         int maxRetry = 20;
3965         do {
3966             if (maxRetry-- &lt; 0) {
3967                 throw new RuntimeException(rb.getString(
3968                         &quot;Too.many.retries.program.terminated&quot;));
3969             }
3970             System.err.print(prompt);
3971             System.err.flush();
3972             reply = (new BufferedReader(new InputStreamReader
3973                                         (System.in))).readLine();
3974             if (reply == null ||
3975                 collator.compare(reply, &quot;&quot;) == 0 ||
3976                 collator.compare(reply, rb.getString(&quot;n&quot;)) == 0 ||
3977                 collator.compare(reply, rb.getString(&quot;no&quot;)) == 0) {
3978                 reply = &quot;NO&quot;;
3979             } else if (collator.compare(reply, rb.getString(&quot;y&quot;)) == 0 ||
3980                        collator.compare(reply, rb.getString(&quot;yes&quot;)) == 0) {
3981                 reply = &quot;YES&quot;;
3982             } else {
3983                 System.err.println(rb.getString(&quot;Wrong.answer.try.again&quot;));
3984                 reply = null;
3985             }
3986         } while (reply == null);
3987         return reply;
3988     }
3989 
3990     /**
3991      * Stores the (leaf) certificates of a keystore in a hashtable.
3992      * All certs belonging to the same CA are stored in a vector that
3993      * in turn is stored in the hashtable, keyed by the CA&#39;s subject DN.
3994      * Each cert comes with a string label that shows its origin and alias.
3995      */
3996     private void keystorecerts2Hashtable(KeyStore ks,
3997                 Hashtable&lt;Principal, Vector&lt;Pair&lt;String,X509Certificate&gt;&gt;&gt; hash)
3998         throws Exception {
3999 
4000         for (Enumeration&lt;String&gt; aliases = ks.aliases();
4001                                         aliases.hasMoreElements(); ) {
4002             String alias = aliases.nextElement();
4003             Certificate cert = ks.getCertificate(alias);
4004             if (cert != null) {
4005                 Principal subjectDN = ((X509Certificate)cert).getSubjectDN();
4006                 Pair&lt;String,X509Certificate&gt; pair = new Pair&lt;&gt;(
4007                         String.format(
4008                                 rb.getString(ks == caks ?
4009                                         &quot;alias.in.cacerts&quot; :
4010                                         &quot;alias.in.keystore&quot;),
4011                                 alias),
4012                         (X509Certificate)cert);
4013                 Vector&lt;Pair&lt;String,X509Certificate&gt;&gt; vec = hash.get(subjectDN);
4014                 if (vec == null) {
4015                     vec = new Vector&lt;&gt;();
4016                     vec.addElement(pair);
4017                 } else {
4018                     if (!vec.contains(pair)) {
4019                         vec.addElement(pair);
4020                     }
4021                 }
4022                 hash.put(subjectDN, vec);
4023             }
4024         }
4025     }
4026 
4027     /**
4028      * Returns the issue time that&#39;s specified the -startdate option
4029      * @param s the value of -startdate option
4030      */
4031     private static Date getStartDate(String s) throws IOException {
4032         Calendar c = new GregorianCalendar();
4033         if (s != null) {
4034             IOException ioe = new IOException(
4035                     rb.getString(&quot;Illegal.startdate.value&quot;));
4036             int len = s.length();
4037             if (len == 0) {
4038                 throw ioe;
4039             }
4040             if (s.charAt(0) == &#39;-&#39; || s.charAt(0) == &#39;+&#39;) {
4041                 // Form 1: ([+-]nnn[ymdHMS])+
4042                 int start = 0;
4043                 while (start &lt; len) {
4044                     int sign = 0;
4045                     switch (s.charAt(start)) {
4046                         case &#39;+&#39;: sign = 1; break;
4047                         case &#39;-&#39;: sign = -1; break;
4048                         default: throw ioe;
4049                     }
4050                     int i = start+1;
4051                     for (; i&lt;len; i++) {
4052                         char ch = s.charAt(i);
4053                         if (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) break;
4054                     }
4055                     if (i == start+1) throw ioe;
4056                     int number = Integer.parseInt(s.substring(start+1, i));
4057                     if (i &gt;= len) throw ioe;
4058                     int unit = 0;
4059                     switch (s.charAt(i)) {
4060                         case &#39;y&#39;: unit = Calendar.YEAR; break;
4061                         case &#39;m&#39;: unit = Calendar.MONTH; break;
4062                         case &#39;d&#39;: unit = Calendar.DATE; break;
4063                         case &#39;H&#39;: unit = Calendar.HOUR; break;
4064                         case &#39;M&#39;: unit = Calendar.MINUTE; break;
4065                         case &#39;S&#39;: unit = Calendar.SECOND; break;
4066                         default: throw ioe;
4067                     }
4068                     c.add(unit, sign * number);
4069                     start = i + 1;
4070                 }
4071             } else  {
4072                 // Form 2: [yyyy/mm/dd] [HH:MM:SS]
4073                 String date = null, time = null;
4074                 if (len == 19) {
4075                     date = s.substring(0, 10);
4076                     time = s.substring(11);
4077                     if (s.charAt(10) != &#39; &#39;)
4078                         throw ioe;
4079                 } else if (len == 10) {
4080                     date = s;
4081                 } else if (len == 8) {
4082                     time = s;
4083                 } else {
4084                     throw ioe;
4085                 }
4086                 if (date != null) {
4087                     if (date.matches(&quot;\\d\\d\\d\\d\\/\\d\\d\\/\\d\\d&quot;)) {
4088                         c.set(Integer.valueOf(date.substring(0, 4)),
4089                                 Integer.valueOf(date.substring(5, 7))-1,
4090                                 Integer.valueOf(date.substring(8, 10)));
4091                     } else {
4092                         throw ioe;
4093                     }
4094                 }
4095                 if (time != null) {
4096                     if (time.matches(&quot;\\d\\d:\\d\\d:\\d\\d&quot;)) {
4097                         c.set(Calendar.HOUR_OF_DAY, Integer.valueOf(time.substring(0, 2)));
4098                         c.set(Calendar.MINUTE, Integer.valueOf(time.substring(3, 5)));
4099                         c.set(Calendar.SECOND, Integer.valueOf(time.substring(6, 8)));
4100                         c.set(Calendar.MILLISECOND, 0);
4101                     } else {
4102                         throw ioe;
4103                     }
4104                 }
4105             }
4106         }
4107         return c.getTime();
4108     }
4109 
4110     /**
4111      * Match a command with a command set. The match can be exact, or
4112      * partial, or case-insensitive.
4113      *
4114      * @param s the command provided by user
4115      * @param list the legal command set. If there is a null, commands after it
4116      *      are regarded experimental, which means they are supported but their
4117      *      existence should not be revealed to user.
4118      * @return the position of a single match, or -1 if none matched
4119      * @throws Exception if s is ambiguous
4120      */
4121     private static int oneOf(String s, String... list) throws Exception {
4122 
4123         // First, if there is an exact match, returns it.
4124         int res = oneOfMatch((a,b) -&gt; a.equals(b), s, list);
4125         if (res &gt;= 0) {
4126             return res;
4127         }
4128 
4129         // Second, if there is one single camelCase or prefix match, returns it.
4130         // This regex substitution removes all lowercase letters not at the
4131         // beginning, so &quot;keyCertSign&quot; becomes &quot;kCS&quot;.
4132         res = oneOfMatch((a,b) -&gt; a.equals(b.replaceAll(&quot;(?&lt;!^)[a-z]&quot;, &quot;&quot;))
4133                 || b.startsWith(a), s, list);
4134         if (res &gt;= 0) {
4135             return res;
4136         }
4137 
4138         // Finally, retry the 2nd step ignoring case
4139         return oneOfMatch((a,b) -&gt; a.equalsIgnoreCase(b.replaceAll(&quot;(?&lt;!^)[a-z]&quot;, &quot;&quot;))
4140                 || b.toUpperCase(Locale.ROOT).startsWith(a.toUpperCase(Locale.ROOT)),
4141                 s, list);
4142     }
4143 
4144     /**
4145      * Match a command with a command set.
4146      *
4147      * @param matcher a BiFunction which returns {@code true} if the 1st
4148      *               argument (user input) matches the 2nd one (full command)
4149      * @param s the command provided by user
4150      * @param list the legal command set
4151      * @return the position of a single match, or -1 if none matched
4152      * @throws Exception if s is ambiguous
4153      */
4154     private static int oneOfMatch(BiFunction&lt;String,String,Boolean&gt; matcher,
4155             String s, String... list) throws Exception {
4156         int[] match = new int[list.length];
4157         int nmatch = 0;
4158         int experiment = Integer.MAX_VALUE;
4159         for (int i = 0; i&lt;list.length; i++) {
4160             String one = list[i];
4161             if (one == null) {
4162                 experiment = i;
4163                 continue;
4164             }
4165             if (matcher.apply(s, one)) {
4166                 match[nmatch++] = i;
4167             }
4168         }
4169         if (nmatch == 0) {
4170             return -1;
4171         } else if (nmatch == 1) {
4172             return match[0];
4173         } else {
4174             // If multiple matches is in experimental commands, ignore them
4175             if (match[1] &gt; experiment) {
4176                 return match[0];
4177             }
4178             StringBuilder sb = new StringBuilder();
4179             MessageFormat form = new MessageFormat(rb.getString
4180                     (&quot;command.{0}.is.ambiguous.&quot;));
4181             Object[] source = {s};
4182             sb.append(form.format(source));
4183             sb.append(&quot;\n    &quot;);
4184             for (int i=0; i&lt;nmatch &amp;&amp; match[i]&lt;experiment; i++) {
4185                 sb.append(&#39; &#39;);
4186                 sb.append(list[match[i]]);
4187             }
4188             throw new Exception(sb.toString());
4189         }
4190     }
4191 
4192     /**
4193      * Create a GeneralName object from known types
4194      * @param t one of 5 known types
4195      * @param v value
4196      * @return which one
4197      */
4198     private GeneralName createGeneralName(String t, String v)
4199             throws Exception {
4200         GeneralNameInterface gn;
4201         int p = oneOf(t, &quot;EMAIL&quot;, &quot;URI&quot;, &quot;DNS&quot;, &quot;IP&quot;, &quot;OID&quot;);
4202         if (p &lt; 0) {
4203             throw new Exception(rb.getString(
4204                     &quot;Unrecognized.GeneralName.type.&quot;) + t);
4205         }
4206         switch (p) {
4207             case 0: gn = new RFC822Name(v); break;
4208             case 1: gn = new URIName(v); break;
4209             case 2: gn = new DNSName(v); break;
4210             case 3: gn = new IPAddressName(v); break;
4211             default: gn = new OIDName(v); break; //4
4212         }
4213         return new GeneralName(gn);
4214     }
4215 
4216     private static final String[] extSupported = {
4217                         &quot;BasicConstraints&quot;,
4218                         &quot;KeyUsage&quot;,
4219                         &quot;ExtendedKeyUsage&quot;,
4220                         &quot;SubjectAlternativeName&quot;,
4221                         &quot;IssuerAlternativeName&quot;,
4222                         &quot;SubjectInfoAccess&quot;,
4223                         &quot;AuthorityInfoAccess&quot;,
4224                         null,
4225                         &quot;CRLDistributionPoints&quot;,
4226     };
4227 
4228     private ObjectIdentifier findOidForExtName(String type)
4229             throws Exception {
4230         switch (oneOf(type, extSupported)) {
4231             case 0: return PKIXExtensions.BasicConstraints_Id;
4232             case 1: return PKIXExtensions.KeyUsage_Id;
4233             case 2: return PKIXExtensions.ExtendedKeyUsage_Id;
4234             case 3: return PKIXExtensions.SubjectAlternativeName_Id;
4235             case 4: return PKIXExtensions.IssuerAlternativeName_Id;
4236             case 5: return PKIXExtensions.SubjectInfoAccess_Id;
4237             case 6: return PKIXExtensions.AuthInfoAccess_Id;
4238             case 8: return PKIXExtensions.CRLDistributionPoints_Id;
4239             default: return new ObjectIdentifier(type);
4240         }
4241     }
4242 
4243     // Add an extension into a CertificateExtensions, always using OID as key
4244     private static void setExt(CertificateExtensions result, Extension ex)
4245             throws IOException {
4246         result.set(ex.getId(), ex);
4247     }
4248 
4249     /**
4250      * Create X509v3 extensions from a string representation. Note that the
4251      * SubjectKeyIdentifierExtension will always be created non-critical besides
4252      * the extension requested in the &lt;code&gt;extstr&lt;/code&gt; argument.
4253      *
4254      * @param requestedEx the requested extensions, can be null, used for -gencert
4255      * @param existingEx the original extensions, can be null, used for -selfcert
4256      * @param extstrs -ext values, Read keytool doc
4257      * @param pkey the public key for the certificate
4258      * @param akey the public key for the authority (issuer)
4259      * @return the created CertificateExtensions
4260      */
4261     private CertificateExtensions createV3Extensions(
4262             CertificateExtensions requestedEx,
4263             CertificateExtensions existingEx,
4264             List &lt;String&gt; extstrs,
4265             PublicKey pkey,
4266             PublicKey akey) throws Exception {
4267 
4268         // By design, inside a CertificateExtensions object, all known
4269         // extensions uses name (say, &quot;BasicConstraints&quot;) as key and
4270         // a child Extension type (say, &quot;BasicConstraintsExtension&quot;)
4271         // as value, unknown extensions uses OID as key and bare
4272         // Extension object as value. This works fine inside JDK.
4273         //
4274         // However, in keytool, there is no way to prevent people
4275         // using OID in -ext, either as a new extension, or in a
4276         // honored value. Thus here we (ab)use CertificateExtensions
4277         // by always using OID as key and value can be of any type.
4278 
4279         if (existingEx != null &amp;&amp; requestedEx != null) {
4280             // This should not happen
4281             throw new Exception(&quot;One of request and original should be null.&quot;);
4282         }
4283         // A new extensions always using OID as key
4284         CertificateExtensions result = new CertificateExtensions();
4285         if (existingEx != null) {
4286             for (Extension ex: existingEx.getAllExtensions()) {
4287                 setExt(result, ex);
4288             }
4289         }
4290         try {
4291             // name{:critical}{=value}
4292             // Honoring requested extensions
4293             if (requestedEx != null) {
4294                 // The existing requestedEx might use names as keys,
4295                 // translate to all-OID first.
4296                 CertificateExtensions request2 = new CertificateExtensions();
4297                 for (sun.security.x509.Extension ex: requestedEx.getAllExtensions()) {
4298                     request2.set(ex.getId(), ex);
4299                 }
4300                 for(String extstr: extstrs) {
4301                     if (extstr.toLowerCase(Locale.ENGLISH).startsWith(&quot;honored=&quot;)) {
4302                         List&lt;String&gt; list = Arrays.asList(
4303                                 extstr.toLowerCase(Locale.ENGLISH).substring(8).split(&quot;,&quot;));
4304                         // First check existence of &quot;all&quot;
4305                         if (list.contains(&quot;all&quot;)) {
4306                             for (Extension ex: request2.getAllExtensions()) {
4307                                 setExt(result, ex);
4308                             }
4309                         }
4310                         // one by one for others
4311                         for (String item: list) {
4312                             if (item.equals(&quot;all&quot;)) continue;
4313 
4314                             // add or remove
4315                             boolean add;
4316                             // -1, unchanged, 0 critical, 1 non-critical
4317                             int action = -1;
4318                             String type = null;
4319                             if (item.startsWith(&quot;-&quot;)) {
4320                                 add = false;
4321                                 type = item.substring(1);
4322                             } else {
4323                                 add = true;
4324                                 int colonpos = item.indexOf(&#39;:&#39;);
4325                                 if (colonpos &gt;= 0) {
4326                                     type = item.substring(0, colonpos);
4327                                     action = oneOf(item.substring(colonpos+1),
4328                                             &quot;critical&quot;, &quot;non-critical&quot;);
4329                                     if (action == -1) {
4330                                         throw new Exception(rb.getString
4331                                             (&quot;Illegal.value.&quot;) + item);
4332                                     }
4333                                 } else {
4334                                     type = item;
4335                                 }
4336                             }
4337                             String n = findOidForExtName(type).toString();
4338                             if (add) {
4339                                 Extension e = request2.get(n);
4340                                 if (!e.isCritical() &amp;&amp; action == 0
4341                                         || e.isCritical() &amp;&amp; action == 1) {
4342                                     e = Extension.newExtension(
4343                                             e.getExtensionId(),
4344                                             !e.isCritical(),
4345                                             e.getExtensionValue());
4346                                 }
4347                                 setExt(result, e);
4348                             } else {
4349                                 result.delete(n);
4350                             }
4351                         }
4352                         break;
4353                     }
4354                 }
4355             }
4356             for(String extstr: extstrs) {
4357                 String name, value;
4358                 boolean isCritical = false;
4359 
4360                 int eqpos = extstr.indexOf(&#39;=&#39;);
4361                 if (eqpos &gt;= 0) {
4362                     name = extstr.substring(0, eqpos);
4363                     value = extstr.substring(eqpos+1);
4364                 } else {
4365                     name = extstr;
4366                     value = null;
4367                 }
4368 
4369                 int colonpos = name.indexOf(&#39;:&#39;);
4370                 if (colonpos &gt;= 0) {
4371                     if (oneOf(name.substring(colonpos+1), &quot;critical&quot;) == 0) {
4372                         isCritical = true;
4373                     }
4374                     name = name.substring(0, colonpos);
4375                 }
4376 
4377                 if (name.equalsIgnoreCase(&quot;honored&quot;)) {
4378                     continue;
4379                 }
4380                 int exttype = oneOf(name, extSupported);
4381                 switch (exttype) {
4382                     case 0:     // BC
4383                         int pathLen = -1;
4384                         boolean isCA = false;
4385                         if (value == null) {
4386                             isCA = true;
4387                         } else {
4388                             try {   // the abbr format
4389                                 pathLen = Integer.parseInt(value);
4390                                 isCA = true;
4391                             } catch (NumberFormatException ufe) {
4392                                 // ca:true,pathlen:1
4393                                 for (String part: value.split(&quot;,&quot;)) {
4394                                     String[] nv = part.split(&quot;:&quot;);
4395                                     if (nv.length != 2) {
4396                                         throw new Exception(rb.getString
4397                                                 (&quot;Illegal.value.&quot;) + extstr);
4398                                     } else {
4399                                         if (nv[0].equalsIgnoreCase(&quot;ca&quot;)) {
4400                                             isCA = Boolean.parseBoolean(nv[1]);
4401                                         } else if (nv[0].equalsIgnoreCase(&quot;pathlen&quot;)) {
4402                                             pathLen = Integer.parseInt(nv[1]);
4403                                         } else {
4404                                             throw new Exception(rb.getString
4405                                                 (&quot;Illegal.value.&quot;) + extstr);
4406                                         }
4407                                     }
4408                                 }
4409                             }
4410                         }
4411                         setExt(result, new BasicConstraintsExtension(isCritical, isCA,
4412                                 pathLen));
4413                         break;
4414                     case 1:     // KU
4415                         if(value != null) {
4416                             boolean[] ok = new boolean[9];
4417                             for (String s: value.split(&quot;,&quot;)) {
4418                                 int p = oneOf(s,
4419                                        &quot;digitalSignature&quot;,  // (0),
4420                                        &quot;nonRepudiation&quot;,    // (1)
4421                                        &quot;keyEncipherment&quot;,   // (2),
4422                                        &quot;dataEncipherment&quot;,  // (3),
4423                                        &quot;keyAgreement&quot;,      // (4),
4424                                        &quot;keyCertSign&quot;,       // (5),
4425                                        &quot;cRLSign&quot;,           // (6),
4426                                        &quot;encipherOnly&quot;,      // (7),
4427                                        &quot;decipherOnly&quot;,      // (8)
4428                                        &quot;contentCommitment&quot;  // also (1)
4429                                        );
4430                                 if (p &lt; 0) {
4431                                     throw new Exception(rb.getString(&quot;Unknown.keyUsage.type.&quot;) + s);
4432                                 }
4433                                 if (p == 9) p = 1;
4434                                 ok[p] = true;
4435                             }
4436                             KeyUsageExtension kue = new KeyUsageExtension(ok);
4437                             // The above KeyUsageExtension constructor does not
4438                             // allow isCritical value, so...
4439                             setExt(result, Extension.newExtension(
4440                                     kue.getExtensionId(),
4441                                     isCritical,
4442                                     kue.getExtensionValue()));
4443                         } else {
4444                             throw new Exception(rb.getString
4445                                     (&quot;Illegal.value.&quot;) + extstr);
4446                         }
4447                         break;
4448                     case 2:     // EKU
4449                         if(value != null) {
4450                             Vector&lt;ObjectIdentifier&gt; v = new Vector&lt;&gt;();
4451                             for (String s: value.split(&quot;,&quot;)) {
4452                                 int p = oneOf(s,
4453                                         &quot;anyExtendedKeyUsage&quot;,
4454                                         &quot;serverAuth&quot;,       //1
4455                                         &quot;clientAuth&quot;,       //2
4456                                         &quot;codeSigning&quot;,      //3
4457                                         &quot;emailProtection&quot;,  //4
4458                                         &quot;&quot;,                 //5
4459                                         &quot;&quot;,                 //6
4460                                         &quot;&quot;,                 //7
4461                                         &quot;timeStamping&quot;,     //8
4462                                         &quot;OCSPSigning&quot;       //9
4463                                        );
4464                                 if (p &lt; 0) {
4465                                     try {
4466                                         v.add(new ObjectIdentifier(s));
4467                                     } catch (Exception e) {
4468                                         throw new Exception(rb.getString(
4469                                                 &quot;Unknown.extendedkeyUsage.type.&quot;) + s);
4470                                     }
4471                                 } else if (p == 0) {
4472                                     v.add(new ObjectIdentifier(&quot;2.5.29.37.0&quot;));
4473                                 } else {
4474                                     v.add(new ObjectIdentifier(&quot;1.3.6.1.5.5.7.3.&quot; + p));
4475                                 }
4476                             }
4477                             setExt(result, new ExtendedKeyUsageExtension(isCritical, v));
4478                         } else {
4479                             throw new Exception(rb.getString
4480                                     (&quot;Illegal.value.&quot;) + extstr);
4481                         }
4482                         break;
4483                     case 3:     // SAN
4484                     case 4:     // IAN
4485                         if(value != null) {
4486                             String[] ps = value.split(&quot;,&quot;);
4487                             GeneralNames gnames = new GeneralNames();
4488                             for(String item: ps) {
4489                                 colonpos = item.indexOf(&#39;:&#39;);
4490                                 if (colonpos &lt; 0) {
4491                                     throw new Exception(&quot;Illegal item &quot; + item + &quot; in &quot; + extstr);
4492                                 }
4493                                 String t = item.substring(0, colonpos);
4494                                 String v = item.substring(colonpos+1);
4495                                 gnames.add(createGeneralName(t, v));
4496                             }
4497                             if (exttype == 3) {
4498                                 setExt(result, new SubjectAlternativeNameExtension(
4499                                         isCritical, gnames));
4500                             } else {
4501                                 setExt(result, new IssuerAlternativeNameExtension(
4502                                         isCritical, gnames));
4503                             }
4504                         } else {
4505                             throw new Exception(rb.getString
4506                                     (&quot;Illegal.value.&quot;) + extstr);
4507                         }
4508                         break;
4509                     case 5:     // SIA, always non-critical
4510                     case 6:     // AIA, always non-critical
4511                         if (isCritical) {
4512                             throw new Exception(rb.getString(
4513                                     &quot;This.extension.cannot.be.marked.as.critical.&quot;) + extstr);
4514                         }
4515                         if(value != null) {
4516                             List&lt;AccessDescription&gt; accessDescriptions =
4517                                     new ArrayList&lt;&gt;();
4518                             String[] ps = value.split(&quot;,&quot;);
4519                             for(String item: ps) {
4520                                 colonpos = item.indexOf(&#39;:&#39;);
4521                                 int colonpos2 = item.indexOf(&#39;:&#39;, colonpos+1);
4522                                 if (colonpos &lt; 0 || colonpos2 &lt; 0) {
4523                                     throw new Exception(rb.getString
4524                                             (&quot;Illegal.value.&quot;) + extstr);
4525                                 }
4526                                 String m = item.substring(0, colonpos);
4527                                 String t = item.substring(colonpos+1, colonpos2);
4528                                 String v = item.substring(colonpos2+1);
4529                                 int p = oneOf(m,
4530                                         &quot;&quot;,
4531                                         &quot;ocsp&quot;,         //1
4532                                         &quot;caIssuers&quot;,    //2
4533                                         &quot;timeStamping&quot;, //3
4534                                         &quot;&quot;,
4535                                         &quot;caRepository&quot;  //5
4536                                         );
4537                                 ObjectIdentifier oid;
4538                                 if (p &lt; 0) {
4539                                     try {
4540                                         oid = new ObjectIdentifier(m);
4541                                     } catch (Exception e) {
4542                                         throw new Exception(rb.getString(
4543                                                 &quot;Unknown.AccessDescription.type.&quot;) + m);
4544                                     }
4545                                 } else {
4546                                     oid = new ObjectIdentifier(&quot;1.3.6.1.5.5.7.48.&quot; + p);
4547                                 }
4548                                 accessDescriptions.add(new AccessDescription(
4549                                         oid, createGeneralName(t, v)));
4550                             }
4551                             if (exttype == 5) {
4552                                 setExt(result, new SubjectInfoAccessExtension(accessDescriptions));
4553                             } else {
4554                                 setExt(result, new AuthorityInfoAccessExtension(accessDescriptions));
4555                             }
4556                         } else {
4557                             throw new Exception(rb.getString
4558                                     (&quot;Illegal.value.&quot;) + extstr);
4559                         }
4560                         break;
4561                     case 8: // CRL, experimental, only support 1 distributionpoint
4562                         if(value != null) {
4563                             String[] ps = value.split(&quot;,&quot;);
4564                             GeneralNames gnames = new GeneralNames();
4565                             for(String item: ps) {
4566                                 colonpos = item.indexOf(&#39;:&#39;);
4567                                 if (colonpos &lt; 0) {
4568                                     throw new Exception(&quot;Illegal item &quot; + item + &quot; in &quot; + extstr);
4569                                 }
4570                                 String t = item.substring(0, colonpos);
4571                                 String v = item.substring(colonpos+1);
4572                                 gnames.add(createGeneralName(t, v));
4573                             }
4574                             setExt(result, new CRLDistributionPointsExtension(
4575                                     isCritical, Collections.singletonList(
4576                                     new DistributionPoint(gnames, null, null))));
4577                         } else {
4578                             throw new Exception(rb.getString
4579                                     (&quot;Illegal.value.&quot;) + extstr);
4580                         }
4581                         break;
4582                     case -1:
4583                         ObjectIdentifier oid = new ObjectIdentifier(name);
4584                         byte[] data = null;
4585                         if (value != null) {
4586                             data = new byte[value.length() / 2 + 1];
4587                             int pos = 0;
4588                             for (char c: value.toCharArray()) {
4589                                 int hex;
4590                                 if (c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;) {
4591                                     hex = c - &#39;0&#39; ;
4592                                 } else if (c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;F&#39;) {
4593                                     hex = c - &#39;A&#39; + 10;
4594                                 } else if (c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;f&#39;) {
4595                                     hex = c - &#39;a&#39; + 10;
4596                                 } else {
4597                                     continue;
4598                                 }
4599                                 if (pos % 2 == 0) {
4600                                     data[pos/2] = (byte)(hex &lt;&lt; 4);
4601                                 } else {
4602                                     data[pos/2] += hex;
4603                                 }
4604                                 pos++;
4605                             }
4606                             if (pos % 2 != 0) {
4607                                 throw new Exception(rb.getString(
4608                                         &quot;Odd.number.of.hex.digits.found.&quot;) + extstr);
4609                             }
4610                             data = Arrays.copyOf(data, pos/2);
4611                         } else {
4612                             data = new byte[0];
4613                         }
4614                         setExt(result, new Extension(oid, isCritical,
4615                                 new DerValue(DerValue.tag_OctetString, data)
4616                                         .toByteArray()));
4617                         break;
4618                     default:
4619                         throw new Exception(rb.getString(
4620                                 &quot;Unknown.extension.type.&quot;) + extstr);
4621                 }
4622             }
4623             // always non-critical
4624             setExt(result, new SubjectKeyIdentifierExtension(
4625                     new KeyIdentifier(pkey).getIdentifier()));
4626             if (akey != null &amp;&amp; !pkey.equals(akey)) {
4627                 setExt(result, new AuthorityKeyIdentifierExtension(
4628                                 new KeyIdentifier(akey), null, null));
4629             }
4630         } catch(IOException e) {
4631             throw new RuntimeException(e);
4632         }
4633         return result;
4634     }
4635 
4636     private boolean isTrustedCert(Certificate cert) throws KeyStoreException {
4637         if (caks != null &amp;&amp; caks.getCertificateAlias(cert) != null) {
4638             return true;
4639         } else {
4640             String inKS = keyStore.getCertificateAlias(cert);
4641             return inKS != null &amp;&amp; keyStore.isCertificateEntry(inKS);
4642         }
4643     }
4644 
4645     private void checkWeak(String label, String sigAlg, Key key) {
4646 
4647         if (sigAlg != null &amp;&amp; !DISABLED_CHECK.permits(
4648                 SIG_PRIMITIVE_SET, sigAlg, null)) {
4649             weakWarnings.add(String.format(
4650                     rb.getString(&quot;whose.sigalg.risk&quot;), label, sigAlg));
4651         }
4652         if (key != null &amp;&amp; !DISABLED_CHECK.permits(SIG_PRIMITIVE_SET, key)) {
4653             weakWarnings.add(String.format(
4654                     rb.getString(&quot;whose.key.risk&quot;),
4655                     label,
4656                     String.format(rb.getString(&quot;key.bit&quot;),
4657                             KeyUtil.getKeySize(key), fullDisplayAlgName(key))));
4658         }
4659     }
4660 
4661     private void checkWeak(String label, Certificate[] certs)
4662             throws KeyStoreException {
4663         for (int i = 0; i &lt; certs.length; i++) {
4664             Certificate cert = certs[i];
4665             if (cert instanceof X509Certificate) {
4666                 X509Certificate xc = (X509Certificate)cert;
4667                 String fullLabel = label;
4668                 if (certs.length &gt; 1) {
4669                     fullLabel = oneInMany(label, i, certs.length);
4670                 }
4671                 checkWeak(fullLabel, xc);
4672             }
4673         }
4674     }
4675 
4676     private void checkWeak(String label, Certificate cert)
4677             throws KeyStoreException {
4678         if (cert instanceof X509Certificate) {
4679             X509Certificate xc = (X509Certificate)cert;
4680             // No need to check the sigalg of a trust anchor
4681             String sigAlg = isTrustedCert(cert) ? null : xc.getSigAlgName();
4682             checkWeak(label, sigAlg, xc.getPublicKey());
4683         }
4684     }
4685 
4686     private void checkWeak(String label, PKCS10 p10) {
4687         checkWeak(label, p10.getSigAlg(), p10.getSubjectPublicKeyInfo());
4688     }
4689 
4690     private void checkWeak(String label, CRL crl, Key key) {
4691         if (crl instanceof X509CRLImpl) {
4692             X509CRLImpl impl = (X509CRLImpl)crl;
4693             checkWeak(label, impl.getSigAlgName(), key);
4694         }
4695     }
4696 
4697     private void printWeakWarnings(boolean newLine) {
4698         if (!weakWarnings.isEmpty() &amp;&amp; !nowarn) {
4699             System.err.println(&quot;\nWarning:&quot;);
4700             for (String warning : weakWarnings) {
4701                 System.err.println(warning);
4702             }
4703             if (newLine) {
4704                 // When calling before a yes/no prompt, add a new line
4705                 System.err.println();
4706             }
4707         }
4708         weakWarnings.clear();
4709     }
4710 
4711     /**
4712      * Prints the usage of this tool.
4713      */
4714     private void usage() {
4715         if (command != null) {
4716             System.err.println(&quot;keytool &quot; + command +
4717                     rb.getString(&quot;.OPTION.&quot;));
4718             System.err.println();
4719             System.err.println(rb.getString(command.description));
4720             System.err.println();
4721             System.err.println(rb.getString(&quot;Options.&quot;));
4722             System.err.println();
4723 
4724             // Left and right sides of the options list. Both might
4725             // contain &quot;\n&quot; and span multiple lines
4726             String[] left = new String[command.options.length];
4727             String[] right = new String[command.options.length];
4728 
4729             // Length of left side of options list
4730             int lenLeft = 0;
4731 
4732             for (int j = 0; j &lt; command.options.length; j++) {
4733                 Option opt = command.options[j];
4734                 left[j] = opt.toString();
4735                 if (opt.arg != null) {
4736                     left[j] += &quot; &quot; + opt.arg;
4737                 }
4738                 String[] lefts = left[j].split(&quot;\n&quot;);
4739                 for (String s : lefts) {
4740                     if (s.length() &gt; lenLeft) {
4741                         lenLeft = s.length();
4742                     }
4743                 }
4744                 right[j] = rb.getString(opt.description);
4745             }
4746             for (int j = 0; j &lt; left.length; j++) {
4747                 String[] lefts = left[j].split(&quot;\n&quot;);
4748                 String[] rights = right[j].split(&quot;\n&quot;);
4749                 for (int i = 0; i &lt; lefts.length &amp;&amp; i &lt; rights.length; i++) {
4750                     String s1 = i &lt; lefts.length ? lefts[i] : &quot;&quot;;
4751                     String s2 = i &lt; rights.length ? rights[i] : &quot;&quot;;
4752                     if (i == 0) {
4753                         System.err.printf(&quot; %-&quot; + lenLeft + &quot;s  %s\n&quot;, s1, s2);
4754                     } else {
4755                         System.err.printf(&quot;   %-&quot; + lenLeft + &quot;s  %s\n&quot;, s1, s2);
4756                     }
4757                 }
4758             }
4759             System.err.println();
4760             System.err.println(rb.getString(
4761                     &quot;Use.keytool.help.for.all.available.commands&quot;));
4762         } else {
4763             System.err.println(rb.getString(
4764                     &quot;Key.and.Certificate.Management.Tool&quot;));
4765             System.err.println();
4766             System.err.println(rb.getString(&quot;Commands.&quot;));
4767             System.err.println();
4768             for (Command c: Command.values()) {
4769                 if (c == KEYCLONE) break;
4770                 System.err.printf(&quot; %-20s%s\n&quot;, c, rb.getString(c.description));
4771             }
4772             System.err.println();
4773             System.err.println(rb.getString(
4774                     &quot;Use.keytool.help.for.all.available.commands&quot;));
4775             System.err.println(rb.getString(
4776                     &quot;Use.keytool.command.name.help.for.usage.of.command.name&quot;));
4777         }
4778     }
4779 
4780     private void tinyHelp() {
4781         usage();
4782         if (debug) {
4783             throw new RuntimeException(&quot;NO BIG ERROR, SORRY&quot;);
4784         } else {
4785             System.exit(1);
4786         }
4787     }
4788 
4789     private void errorNeedArgument(String flag) {
4790         Object[] source = {flag};
4791         System.err.println(new MessageFormat(
4792                 rb.getString(&quot;Command.option.flag.needs.an.argument.&quot;)).format(source));
4793         tinyHelp();
4794     }
4795 
4796     private char[] getPass(String modifier, String arg) {
4797         char[] output = KeyStoreUtil.getPassWithModifier(modifier, arg, rb);
4798         if (output != null) return output;
4799         tinyHelp();
4800         return null;    // Useless, tinyHelp() already exits.
4801     }
4802 }
4803 
4804 // This class is exactly the same as com.sun.tools.javac.util.Pair,
4805 // it&#39;s copied here since the original one is not included in JRE.
4806 class Pair&lt;A, B&gt; {
4807 
4808     public final A fst;
4809     public final B snd;
4810 
4811     public Pair(A fst, B snd) {
4812         this.fst = fst;
4813         this.snd = snd;
4814     }
4815 
4816     public String toString() {
4817         return &quot;Pair[&quot; + fst + &quot;,&quot; + snd + &quot;]&quot;;
4818     }
4819 
4820     public boolean equals(Object other) {
4821         return
4822             other instanceof Pair &amp;&amp;
4823             Objects.equals(fst, ((Pair)other).fst) &amp;&amp;
4824             Objects.equals(snd, ((Pair)other).snd);
4825     }
4826 
4827     public int hashCode() {
4828         if (fst == null) return (snd == null) ? 0 : snd.hashCode() + 1;
4829         else if (snd == null) return fst.hashCode() + 2;
4830         else return fst.hashCode() * 17 + snd.hashCode();
4831     }
4832 
4833     public static &lt;A,B&gt; Pair&lt;A,B&gt; of(A a, B b) {
4834         return new Pair&lt;&gt;(a,b);
4835     }
4836 }
4837 
    </pre>
  </body>
</html>
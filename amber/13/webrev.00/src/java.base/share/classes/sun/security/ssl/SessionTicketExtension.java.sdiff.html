<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/ssl/SessionTicketExtension.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="ServerNameExtension.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SignatureAlgorithmsExtension.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/SessionTicketExtension.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
220         static int getSessionTimeout(HandshakeContext hc) {
221             return hc.sslContext.engineGetServerSessionContext().
222                     getSessionTimeout() * 1000;
223         }
224     }
225 
226     /**
227      * This class contains the session state that is in the session ticket.
228      * Using the key associated with the ticket, the class encrypts and
229      * decrypts the data, but does not interpret the data.
230      */
231     static final class SessionTicketSpec implements SSLExtensionSpec {
232         private static final int GCM_TAG_LEN = 128;
233         ByteBuffer data;
234         static final ByteBuffer zero = ByteBuffer.wrap(new byte[0]);
235 
236         SessionTicketSpec() {
237             data = zero;
238         }
239 
<span class="line-modified">240         SessionTicketSpec(byte[] b) throws IOException {</span>
<span class="line-modified">241             this(ByteBuffer.wrap(b));</span>
242         }
243 
<span class="line-modified">244         SessionTicketSpec(ByteBuffer buf) throws IOException {</span>

245             if (buf == null) {
<span class="line-modified">246                 throw new SSLProtocolException(</span>
<span class="line-modified">247                         &quot;SessionTicket buffer too small&quot;);</span>

248             }
249             if (buf.remaining() &gt; 65536) {
<span class="line-modified">250                 throw new SSLProtocolException(</span>
<span class="line-modified">251                         &quot;SessionTicket buffer too large. &quot; + buf.remaining());</span>

252             }
253 
254             data = buf;
255         }
256 
257         public byte[] encrypt(HandshakeContext hc, SSLSessionImpl session) {
258             byte[] encrypted;
259 
260             if (!hc.handshakeSession.isStatelessable(hc)) {
261                 return new byte[0];
262             }
263 
264             try {
265                 StatelessKey key = KeyState.getCurrentKey(hc);
266                 byte[] iv = new byte[16];
267 
268                 SecureRandom random = hc.sslContext.getSecureRandom();
269                 random.nextBytes(iv);
270                 Cipher c = Cipher.getInstance(&quot;AES/GCM/NoPadding&quot;);
271                 c.init(Cipher.ENCRYPT_MODE, key.key,
</pre>
<hr />
<pre>
349                 return &quot;&lt;empty&gt;&quot;;
350             }
351 
352             MessageFormat messageFormat = new MessageFormat(
353                     &quot;  \&quot;ticket\&quot; : &#39;{&#39;\n&quot; +
354                             &quot;{0}\n&quot; +
355                             &quot;  &#39;}&#39;&quot;,
356                     Locale.ENGLISH);
357             HexDumpEncoder hexEncoder = new HexDumpEncoder();
358 
359             Object[] messageFields = {
360                     Utilities.indent(hexEncoder.encode(data.duplicate()),
361                             &quot;    &quot;),
362             };
363 
364             return messageFormat.format(messageFields);
365         }
366     }
367 
368     static final class SessionTicketStringizer implements SSLStringizer {
<span class="line-removed">369         SessionTicketStringizer() {}</span>
<span class="line-removed">370 </span>
371         @Override
<span class="line-modified">372         public String toString(ByteBuffer buffer) {</span>
373             try {
<span class="line-modified">374                 return new SessionTicketSpec(buffer).toString();</span>
375             } catch (IOException e) {
376                 return e.getMessage();
377             }
378         }
379     }
380 
381     private static final class T12CHSessionTicketProducer
382             extends SupportedGroups implements HandshakeProducer {
383         T12CHSessionTicketProducer() {
384         }
385 
386         @Override
387         public byte[] produce(ConnectionContext context,
388                 HandshakeMessage message) throws IOException {
389 
390             ClientHandshakeContext chc = (ClientHandshakeContext)context;
391 
392             // If the context does not allow stateless tickets, exit
393             if (!((SSLSessionContextImpl)chc.sslContext.
394                     engineGetClientSessionContext()).statelessEnabled()) {
</pre>
<hr />
<pre>
438             // Skip consumption if we are already in stateless resumption
439             if (shc.statelessResumption) {
440                 return;
441             }
442             // If the context does not allow stateless tickets, exit
443             SSLSessionContextImpl cache = (SSLSessionContextImpl)shc.sslContext
444                     .engineGetServerSessionContext();
445             if (!cache.statelessEnabled()) {
446                 return;
447             }
448 
449             if (buffer.remaining() == 0) {
450                 shc.statelessResumption = true;
451                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
452                     SSLLogger.fine(&quot;Client accepts session tickets.&quot;);
453                 }
454                 return;
455             }
456 
457             // Parse the extension.
<span class="line-modified">458             SessionTicketSpec spec;</span>
<span class="line-removed">459             try {</span>
<span class="line-removed">460                  spec = new SessionTicketSpec(buffer);</span>
<span class="line-removed">461             } catch (IOException | RuntimeException e) {</span>
<span class="line-removed">462                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {</span>
<span class="line-removed">463                     SSLLogger.fine(&quot;SessionTicket data invalid. Doing full &quot; +</span>
<span class="line-removed">464                             &quot;handshake.&quot;);</span>
<span class="line-removed">465                 }</span>
<span class="line-removed">466                 return;</span>
<span class="line-removed">467             }</span>
468             ByteBuffer b = spec.decrypt(shc);
469             if (b != null) {
470                 shc.resumingSession = new SSLSessionImpl(shc, b);
471                 shc.isResumption = true;
472                 shc.statelessResumption = true;
473                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
474                     SSLLogger.fine(&quot;Valid stateless session ticket found&quot;);
475                 }
476             }
477         }
478     }
479 
480 
481     private static final class T12SHSessionTicketProducer
482             extends SupportedGroups implements HandshakeProducer {
483         T12SHSessionTicketProducer() {
484         }
485 
486         @Override
487         public byte[] produce(ConnectionContext context,
</pre>
<hr />
<pre>
514 
515         @Override
516         public void consume(ConnectionContext context,
517                 HandshakeMessage message, ByteBuffer buffer)
518                 throws IOException {
519             ClientHandshakeContext chc = (ClientHandshakeContext) context;
520 
521             // Skip if extension is not provided
522             if (!chc.sslConfig.isAvailable(SH_SESSION_TICKET)) {
523                 chc.statelessResumption = false;
524                 return;
525             }
526 
527             // If the context does not allow stateless tickets, exit
528             if (!((SSLSessionContextImpl)chc.sslContext.
529                     engineGetClientSessionContext()).statelessEnabled()) {
530                 chc.statelessResumption = false;
531                 return;
532             }
533 
<span class="line-modified">534             try {</span>
<span class="line-modified">535                 if (new SessionTicketSpec(buffer) == null) {</span>
<span class="line-removed">536                     return;</span>
<span class="line-removed">537                 }</span>
<span class="line-removed">538                 chc.statelessResumption = true;</span>
<span class="line-removed">539             } catch (IOException e) {</span>
<span class="line-removed">540                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, e);</span>
<span class="line-removed">541             }</span>
542         }
543     }
544 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
220         static int getSessionTimeout(HandshakeContext hc) {
221             return hc.sslContext.engineGetServerSessionContext().
222                     getSessionTimeout() * 1000;
223         }
224     }
225 
226     /**
227      * This class contains the session state that is in the session ticket.
228      * Using the key associated with the ticket, the class encrypts and
229      * decrypts the data, but does not interpret the data.
230      */
231     static final class SessionTicketSpec implements SSLExtensionSpec {
232         private static final int GCM_TAG_LEN = 128;
233         ByteBuffer data;
234         static final ByteBuffer zero = ByteBuffer.wrap(new byte[0]);
235 
236         SessionTicketSpec() {
237             data = zero;
238         }
239 
<span class="line-modified">240         SessionTicketSpec(HandshakeContext hc, byte[] b) throws IOException {</span>
<span class="line-modified">241             this(hc, ByteBuffer.wrap(b));</span>
242         }
243 
<span class="line-modified">244         SessionTicketSpec(HandshakeContext hc,</span>
<span class="line-added">245                 ByteBuffer buf) throws IOException {</span>
246             if (buf == null) {
<span class="line-modified">247                 throw hc.conContext.fatal(Alert.DECODE_ERROR,</span>
<span class="line-modified">248                         new SSLProtocolException(</span>
<span class="line-added">249                     &quot;SessionTicket buffer too small&quot;));</span>
250             }
251             if (buf.remaining() &gt; 65536) {
<span class="line-modified">252                 throw hc.conContext.fatal(Alert.DECODE_ERROR,</span>
<span class="line-modified">253                         new SSLProtocolException(</span>
<span class="line-added">254                     &quot;SessionTicket buffer too large. &quot; + buf.remaining()));</span>
255             }
256 
257             data = buf;
258         }
259 
260         public byte[] encrypt(HandshakeContext hc, SSLSessionImpl session) {
261             byte[] encrypted;
262 
263             if (!hc.handshakeSession.isStatelessable(hc)) {
264                 return new byte[0];
265             }
266 
267             try {
268                 StatelessKey key = KeyState.getCurrentKey(hc);
269                 byte[] iv = new byte[16];
270 
271                 SecureRandom random = hc.sslContext.getSecureRandom();
272                 random.nextBytes(iv);
273                 Cipher c = Cipher.getInstance(&quot;AES/GCM/NoPadding&quot;);
274                 c.init(Cipher.ENCRYPT_MODE, key.key,
</pre>
<hr />
<pre>
352                 return &quot;&lt;empty&gt;&quot;;
353             }
354 
355             MessageFormat messageFormat = new MessageFormat(
356                     &quot;  \&quot;ticket\&quot; : &#39;{&#39;\n&quot; +
357                             &quot;{0}\n&quot; +
358                             &quot;  &#39;}&#39;&quot;,
359                     Locale.ENGLISH);
360             HexDumpEncoder hexEncoder = new HexDumpEncoder();
361 
362             Object[] messageFields = {
363                     Utilities.indent(hexEncoder.encode(data.duplicate()),
364                             &quot;    &quot;),
365             };
366 
367             return messageFormat.format(messageFields);
368         }
369     }
370 
371     static final class SessionTicketStringizer implements SSLStringizer {


372         @Override
<span class="line-modified">373         public String toString(HandshakeContext hc, ByteBuffer buffer) {</span>
374             try {
<span class="line-modified">375                 return new SessionTicketSpec(hc, buffer).toString();</span>
376             } catch (IOException e) {
377                 return e.getMessage();
378             }
379         }
380     }
381 
382     private static final class T12CHSessionTicketProducer
383             extends SupportedGroups implements HandshakeProducer {
384         T12CHSessionTicketProducer() {
385         }
386 
387         @Override
388         public byte[] produce(ConnectionContext context,
389                 HandshakeMessage message) throws IOException {
390 
391             ClientHandshakeContext chc = (ClientHandshakeContext)context;
392 
393             // If the context does not allow stateless tickets, exit
394             if (!((SSLSessionContextImpl)chc.sslContext.
395                     engineGetClientSessionContext()).statelessEnabled()) {
</pre>
<hr />
<pre>
439             // Skip consumption if we are already in stateless resumption
440             if (shc.statelessResumption) {
441                 return;
442             }
443             // If the context does not allow stateless tickets, exit
444             SSLSessionContextImpl cache = (SSLSessionContextImpl)shc.sslContext
445                     .engineGetServerSessionContext();
446             if (!cache.statelessEnabled()) {
447                 return;
448             }
449 
450             if (buffer.remaining() == 0) {
451                 shc.statelessResumption = true;
452                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
453                     SSLLogger.fine(&quot;Client accepts session tickets.&quot;);
454                 }
455                 return;
456             }
457 
458             // Parse the extension.
<span class="line-modified">459             SessionTicketSpec spec = new SessionTicketSpec(shc, buffer);</span>









460             ByteBuffer b = spec.decrypt(shc);
461             if (b != null) {
462                 shc.resumingSession = new SSLSessionImpl(shc, b);
463                 shc.isResumption = true;
464                 shc.statelessResumption = true;
465                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
466                     SSLLogger.fine(&quot;Valid stateless session ticket found&quot;);
467                 }
468             }
469         }
470     }
471 
472 
473     private static final class T12SHSessionTicketProducer
474             extends SupportedGroups implements HandshakeProducer {
475         T12SHSessionTicketProducer() {
476         }
477 
478         @Override
479         public byte[] produce(ConnectionContext context,
</pre>
<hr />
<pre>
506 
507         @Override
508         public void consume(ConnectionContext context,
509                 HandshakeMessage message, ByteBuffer buffer)
510                 throws IOException {
511             ClientHandshakeContext chc = (ClientHandshakeContext) context;
512 
513             // Skip if extension is not provided
514             if (!chc.sslConfig.isAvailable(SH_SESSION_TICKET)) {
515                 chc.statelessResumption = false;
516                 return;
517             }
518 
519             // If the context does not allow stateless tickets, exit
520             if (!((SSLSessionContextImpl)chc.sslContext.
521                     engineGetClientSessionContext()).statelessEnabled()) {
522                 chc.statelessResumption = false;
523                 return;
524             }
525 
<span class="line-modified">526             SessionTicketSpec spec = new SessionTicketSpec(chc, buffer);</span>
<span class="line-modified">527             chc.statelessResumption = true;</span>






528         }
529     }
530 }
</pre>
</td>
</tr>
</table>
<center><a href="ServerNameExtension.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SignatureAlgorithmsExtension.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
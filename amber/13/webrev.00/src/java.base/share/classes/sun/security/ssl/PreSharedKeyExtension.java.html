<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/sun/security/ssl/PreSharedKeyExtension.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package sun.security.ssl;
 26 
 27 import java.io.IOException;
 28 import java.nio.ByteBuffer;
 29 import java.security.*;
 30 import java.text.MessageFormat;
 31 import java.util.List;
 32 import java.util.ArrayList;
 33 import java.util.Locale;
 34 import java.util.Arrays;
 35 import java.util.Collection;
 36 import javax.crypto.Mac;
 37 import javax.crypto.SecretKey;
 38 import javax.net.ssl.SSLPeerUnverifiedException;
 39 import javax.net.ssl.SSLProtocolException;
 40 import static sun.security.ssl.ClientAuthType.CLIENT_AUTH_REQUIRED;
 41 import sun.security.ssl.ClientHello.ClientHelloMessage;
 42 import sun.security.ssl.SSLExtension.ExtensionConsumer;
 43 import sun.security.ssl.SSLExtension.SSLExtensionSpec;
 44 import sun.security.ssl.SSLHandshake.HandshakeMessage;
 45 import sun.security.ssl.SessionTicketExtension.SessionTicketSpec;
 46 import sun.security.util.HexDumpEncoder;
 47 
 48 import static sun.security.ssl.SSLExtension.*;
 49 
 50 /**
 51  * Pack of the &quot;pre_shared_key&quot; extension.
 52  */
 53 final class PreSharedKeyExtension {
 54     static final HandshakeProducer chNetworkProducer =
 55             new CHPreSharedKeyProducer();
 56     static final ExtensionConsumer chOnLoadConsumer =
 57             new CHPreSharedKeyConsumer();
 58     static final HandshakeAbsence chOnLoadAbsence =
 59             new CHPreSharedKeyOnLoadAbsence();
 60     static final HandshakeConsumer chOnTradeConsumer =
 61             new CHPreSharedKeyUpdate();
 62     static final HandshakeAbsence chOnTradAbsence =
 63             new CHPreSharedKeyOnTradeAbsence();
 64     static final SSLStringizer chStringizer =
 65             new CHPreSharedKeyStringizer();
 66 
 67     static final HandshakeProducer shNetworkProducer =
 68             new SHPreSharedKeyProducer();
 69     static final ExtensionConsumer shOnLoadConsumer =
 70             new SHPreSharedKeyConsumer();
 71     static final HandshakeAbsence shOnLoadAbsence =
 72             new SHPreSharedKeyAbsence();
 73     static final SSLStringizer shStringizer =
 74             new SHPreSharedKeyStringizer();
 75 
 76     private static final class PskIdentity {
 77         final byte[] identity;
 78         final int obfuscatedAge;
 79 
 80         PskIdentity(byte[] identity, int obfuscatedAge) {
 81             this.identity = identity;
 82             this.obfuscatedAge = obfuscatedAge;
 83         }
 84 
 85         int getEncodedLength() {
 86             return 2 + identity.length + 4;
 87         }
 88 
 89         void writeEncoded(ByteBuffer m) throws IOException {
 90             Record.putBytes16(m, identity);
 91             Record.putInt32(m, obfuscatedAge);
 92         }
 93 
 94         @Override
 95         public String toString() {
 96             return &quot;{&quot; + Utilities.toHexString(identity) + &quot;, &quot; +
 97                 obfuscatedAge + &quot;}&quot;;
 98         }
 99     }
100 
101     private static final
102             class CHPreSharedKeySpec implements SSLExtensionSpec {
103         final List&lt;PskIdentity&gt; identities;
104         final List&lt;byte[]&gt; binders;
105 
106         CHPreSharedKeySpec(List&lt;PskIdentity&gt; identities, List&lt;byte[]&gt; binders) {
107             this.identities = identities;
108             this.binders = binders;
109         }
110 
111         CHPreSharedKeySpec(HandshakeContext hc,
112                 ByteBuffer m) throws IOException {
113             // struct {
114             //     PskIdentity identities&lt;7..2^16-1&gt;;
115             //     PskBinderEntry binders&lt;33..2^16-1&gt;;
116             // } OfferedPsks;
117             if (m.remaining() &lt; 44) {
118                 throw hc.conContext.fatal(Alert.DECODE_ERROR,
119                         new SSLProtocolException(
120                     &quot;Invalid pre_shared_key extension: &quot; +
121                     &quot;insufficient data (length=&quot; + m.remaining() + &quot;)&quot;));
122             }
123 
124             int idEncodedLength = Record.getInt16(m);
125             if (idEncodedLength &lt; 7) {
126                 throw hc.conContext.fatal(Alert.DECODE_ERROR,
127                         new SSLProtocolException(
128                     &quot;Invalid pre_shared_key extension: &quot; +
129                     &quot;insufficient identities (length=&quot; + idEncodedLength + &quot;)&quot;));
130             }
131 
132             identities = new ArrayList&lt;&gt;();
133             int idReadLength = 0;
134             while (idReadLength &lt; idEncodedLength) {
135                 byte[] id = Record.getBytes16(m);
136                 if (id.length &lt; 1) {
137                     throw hc.conContext.fatal(Alert.DECODE_ERROR,
138                             new SSLProtocolException(
139                         &quot;Invalid pre_shared_key extension: &quot; +
140                         &quot;insufficient identity (length=&quot; + id.length + &quot;)&quot;));
141                 }
142                 int obfuscatedTicketAge = Record.getInt32(m);
143 
144                 PskIdentity pskId = new PskIdentity(id, obfuscatedTicketAge);
145                 identities.add(pskId);
146                 idReadLength += pskId.getEncodedLength();
147             }
148 
149             if (m.remaining() &lt; 35) {
150                 throw hc.conContext.fatal(Alert.DECODE_ERROR,
151                         new SSLProtocolException(
152                     &quot;Invalid pre_shared_key extension: &quot; +
153                     &quot;insufficient binders data (length=&quot; +
154                     m.remaining() + &quot;)&quot;));
155             }
156 
157             int bindersEncodedLen = Record.getInt16(m);
158             if (bindersEncodedLen &lt; 33) {
159                 throw hc.conContext.fatal(Alert.DECODE_ERROR,
160                         new SSLProtocolException(
161                     &quot;Invalid pre_shared_key extension: &quot; +
162                     &quot;insufficient binders (length=&quot; +
163                     bindersEncodedLen + &quot;)&quot;));
164             }
165 
166             binders = new ArrayList&lt;&gt;();
167             int bindersReadLength = 0;
168             while (bindersReadLength &lt; bindersEncodedLen) {
169                 byte[] binder = Record.getBytes8(m);
170                 if (binder.length &lt; 32) {
171                     throw hc.conContext.fatal(Alert.DECODE_ERROR,
172                             new SSLProtocolException(
173                         &quot;Invalid pre_shared_key extension: &quot; +
174                         &quot;insufficient binder entry (length=&quot; +
175                         binder.length + &quot;)&quot;));
176                 }
177                 binders.add(binder);
178                 bindersReadLength += 1 + binder.length;
179             }
180         }
181 
182         int getIdsEncodedLength() {
183             int idEncodedLength = 0;
184             for (PskIdentity curId : identities) {
185                 idEncodedLength += curId.getEncodedLength();
186             }
187 
188             return idEncodedLength;
189         }
190 
191         int getBindersEncodedLength() {
192             int binderEncodedLength = 0;
193             for (byte[] curBinder : binders) {
194                 binderEncodedLength += 1 + curBinder.length;
195             }
196 
197             return binderEncodedLength;
198         }
199 
200         byte[] getEncoded() throws IOException {
201             int idsEncodedLength = getIdsEncodedLength();
202             int bindersEncodedLength = getBindersEncodedLength();
203             int encodedLength = 4 + idsEncodedLength + bindersEncodedLength;
204             byte[] buffer = new byte[encodedLength];
205             ByteBuffer m = ByteBuffer.wrap(buffer);
206             Record.putInt16(m, idsEncodedLength);
207             for (PskIdentity curId : identities) {
208                 curId.writeEncoded(m);
209             }
210             Record.putInt16(m, bindersEncodedLength);
211             for (byte[] curBinder : binders) {
212                 Record.putBytes8(m, curBinder);
213             }
214 
215             return buffer;
216         }
217 
218         @Override
219         public String toString() {
220             MessageFormat messageFormat = new MessageFormat(
221                 &quot;\&quot;PreSharedKey\&quot;: &#39;{&#39;\n&quot; +
222                 &quot;  \&quot;identities\&quot;: &#39;{&#39;\n&quot; +
223                 &quot;{0}\n&quot; +
224                 &quot;  &#39;}&#39;&quot; +
225                 &quot;  \&quot;binders\&quot;: \&quot;{1}\&quot;,\n&quot; +
226                 &quot;&#39;}&#39;&quot;,
227                 Locale.ENGLISH);
228 
229             Object[] messageFields = {
230                 Utilities.indent(identitiesString()),
231                 Utilities.indent(bindersString())
232             };
233 
234             return messageFormat.format(messageFields);
235         }
236 
237         String identitiesString() {
238             HexDumpEncoder hexEncoder = new HexDumpEncoder();
239 
240             StringBuilder result = new StringBuilder();
241             for (PskIdentity curId : identities) {
242                 result.append(&quot;  {\n&quot;+ Utilities.indent(
243                         hexEncoder.encode(curId.identity), &quot;    &quot;) +
244                         &quot;\n  }\n&quot;);
245             }
246 
247             return result.toString();
248         }
249 
250         String bindersString() {
251             StringBuilder result = new StringBuilder();
252             for (byte[] curBinder : binders) {
253                 result.append(&quot;{&quot; + Utilities.toHexString(curBinder) + &quot;}\n&quot;);
254             }
255 
256             return result.toString();
257         }
258     }
259 
260     private static final
261             class CHPreSharedKeyStringizer implements SSLStringizer {
262         @Override
263         public String toString(HandshakeContext hc, ByteBuffer buffer) {
264             try {
265                 return (new CHPreSharedKeySpec(hc, buffer)).toString();
266             } catch (Exception ex) {
267                 // For debug logging only, so please swallow exceptions.
268                 return ex.getMessage();
269             }
270         }
271     }
272 
273     private static final
274             class SHPreSharedKeySpec implements SSLExtensionSpec {
275         final int selectedIdentity;
276 
277         SHPreSharedKeySpec(int selectedIdentity) {
278             this.selectedIdentity = selectedIdentity;
279         }
280 
281         SHPreSharedKeySpec(HandshakeContext hc,
282                 ByteBuffer m) throws IOException {
283             if (m.remaining() &lt; 2) {
284                 throw hc.conContext.fatal(Alert.DECODE_ERROR,
285                         new SSLProtocolException(
286                     &quot;Invalid pre_shared_key extension: &quot; +
287                     &quot;insufficient selected_identity (length=&quot; +
288                     m.remaining() + &quot;)&quot;));
289             }
290             this.selectedIdentity = Record.getInt16(m);
291         }
292 
293         byte[] getEncoded() {
294             return new byte[] {
295                 (byte)((selectedIdentity &gt;&gt; 8) &amp; 0xFF),
296                 (byte)(selectedIdentity &amp; 0xFF)
297             };
298         }
299 
300         @Override
301         public String toString() {
302             MessageFormat messageFormat = new MessageFormat(
303                 &quot;\&quot;PreSharedKey\&quot;: &#39;{&#39;\n&quot; +
304                 &quot;  \&quot;selected_identity\&quot;      : \&quot;{0}\&quot;,\n&quot; +
305                 &quot;&#39;}&#39;&quot;,
306                 Locale.ENGLISH);
307 
308             Object[] messageFields = {
309                 Utilities.byte16HexString(selectedIdentity)
310             };
311 
312             return messageFormat.format(messageFields);
313         }
314     }
315 
316     private static final
317             class SHPreSharedKeyStringizer implements SSLStringizer {
318         @Override
319         public String toString(HandshakeContext hc, ByteBuffer buffer) {
320             try {
321                 return (new SHPreSharedKeySpec(hc, buffer)).toString();
322             } catch (Exception ex) {
323                 // For debug logging only, so please swallow exceptions.
324                 return ex.getMessage();
325             }
326         }
327     }
328 
329     private static final
330             class CHPreSharedKeyConsumer implements ExtensionConsumer {
331         // Prevent instantiation of this class.
332         private CHPreSharedKeyConsumer() {
333             // blank
334         }
335 
336         @Override
337         public void consume(ConnectionContext context,
338                             HandshakeMessage message,
339                             ByteBuffer buffer) throws IOException {
340             ClientHelloMessage clientHello = (ClientHelloMessage) message;
341             ServerHandshakeContext shc = (ServerHandshakeContext)context;
342             // Is it a supported and enabled extension?
343             if (!shc.sslConfig.isAvailable(SSLExtension.CH_PRE_SHARED_KEY)) {
344                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
345                     SSLLogger.fine(
346                             &quot;Ignore unavailable pre_shared_key extension&quot;);
347                 }
348                 return;     // ignore the extension
349             }
350 
351             // Parse the extension.
352             CHPreSharedKeySpec pskSpec = new CHPreSharedKeySpec(shc, buffer);
353 
354             // The &quot;psk_key_exchange_modes&quot; extension should have been loaded.
355             if (!shc.handshakeExtensions.containsKey(
356                     SSLExtension.PSK_KEY_EXCHANGE_MODES)) {
357                 throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
358                         &quot;Client sent PSK but not PSK modes, or the PSK &quot; +
359                         &quot;extension is not the last extension&quot;);
360             }
361 
362             // error if id and binder lists are not the same length
363             if (pskSpec.identities.size() != pskSpec.binders.size()) {
364                 throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
365                         &quot;PSK extension has incorrect number of binders&quot;);
366             }
367 
368             if (shc.isResumption) {     // resumingSession may not be set
369                 SSLSessionContextImpl sessionCache = (SSLSessionContextImpl)
370                         shc.sslContext.engineGetServerSessionContext();
371                 int idIndex = 0;
372                 SSLSessionImpl s = null;
373 
374                 for (PskIdentity requestedId : pskSpec.identities) {
375                     // If we are keeping state, see if the identity is in the cache
376                     if (requestedId.identity.length == SessionId.MAX_LENGTH) {
377                         s = sessionCache.get(requestedId.identity);
378                     }
379                     // See if the identity is a stateless ticket
380                     if (s == null &amp;&amp;
381                             requestedId.identity.length &gt; SessionId.MAX_LENGTH &amp;&amp;
382                             sessionCache.statelessEnabled()) {
383                         ByteBuffer b =
384                             new SessionTicketSpec(shc, requestedId.identity).
385                                         decrypt(shc);
386                         if (b != null) {
387                             try {
388                                 s = new SSLSessionImpl(shc, b);
389                             } catch (IOException | RuntimeException e) {
390                                 s = null;
391                             }
392                         }
393                         if (b == null || s == null) {
394                             if (SSLLogger.isOn &amp;&amp;
395                                     SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
396                                 SSLLogger.fine(
397                                         &quot;Stateless session ticket invalid&quot;);
398                             }
399                         }
400                     }
401 
402                     if (s != null &amp;&amp; canRejoin(clientHello, shc, s)) {
403                         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
404                             SSLLogger.fine(&quot;Resuming session: &quot;, s);
405                         }
406 
407                         // binder will be checked later
408                         shc.resumingSession = s;
409                         shc.handshakeExtensions.put(SH_PRE_SHARED_KEY,
410                             new SHPreSharedKeySpec(idIndex));   // for the index
411                         break;
412                     }
413 
414                     ++idIndex;
415                 }
416 
417                 if (idIndex == pskSpec.identities.size()) {
418                     // no resumable session
419                     shc.isResumption = false;
420                     shc.resumingSession = null;
421                 }
422             }
423             // update the context
424             shc.handshakeExtensions.put(
425                 SSLExtension.CH_PRE_SHARED_KEY, pskSpec);
426         }
427     }
428 
429     private static boolean canRejoin(ClientHelloMessage clientHello,
430         ServerHandshakeContext shc, SSLSessionImpl s) {
431 
432         boolean result = s.isRejoinable() &amp;&amp; (s.getPreSharedKey() != null);
433 
434         // Check protocol version
435         if (result &amp;&amp; s.getProtocolVersion() != shc.negotiatedProtocol) {
436             if (SSLLogger.isOn &amp;&amp;
437                 SSLLogger.isOn(&quot;ssl,handshake,verbose&quot;)) {
438 
439                 SSLLogger.finest(&quot;Can&#39;t resume, incorrect protocol version&quot;);
440             }
441             result = false;
442         }
443 
444         // Make sure that the server handshake context&#39;s localSupportedSignAlgs
445         // field is populated.  This is particularly important when
446         // client authentication was used in an initial session and it is
447         // now being resumed.
448         if (shc.localSupportedSignAlgs == null) {
449             shc.localSupportedSignAlgs =
450                     SignatureScheme.getSupportedAlgorithms(
451                             shc.algorithmConstraints, shc.activeProtocols);
452         }
453 
454         // Validate the required client authentication.
455         if (result &amp;&amp;
456             (shc.sslConfig.clientAuthType == CLIENT_AUTH_REQUIRED)) {
457             try {
458                 s.getPeerPrincipal();
459             } catch (SSLPeerUnverifiedException e) {
460                 if (SSLLogger.isOn &amp;&amp;
461                         SSLLogger.isOn(&quot;ssl,handshake,verbose&quot;)) {
462                     SSLLogger.finest(
463                         &quot;Can&#39;t resume, &quot; +
464                         &quot;client authentication is required&quot;);
465                 }
466                 result = false;
467             }
468 
469             // Make sure the list of supported signature algorithms matches
470             Collection&lt;SignatureScheme&gt; sessionSigAlgs =
471                 s.getLocalSupportedSignatureSchemes();
472             if (result &amp;&amp;
473                 !shc.localSupportedSignAlgs.containsAll(sessionSigAlgs)) {
474 
475                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
476                     SSLLogger.fine(&quot;Can&#39;t resume. Session uses different &quot; +
477                         &quot;signature algorithms&quot;);
478                 }
479                 result = false;
480             }
481         }
482 
483         // ensure that the endpoint identification algorithm matches the
484         // one in the session
485         String identityAlg = shc.sslConfig.identificationProtocol;
486         if (result &amp;&amp; identityAlg != null) {
487             String sessionIdentityAlg = s.getIdentificationProtocol();
488             if (!identityAlg.equalsIgnoreCase(sessionIdentityAlg)) {
489                 if (SSLLogger.isOn &amp;&amp;
490                     SSLLogger.isOn(&quot;ssl,handshake,verbose&quot;)) {
491 
492                     SSLLogger.finest(&quot;Can&#39;t resume, endpoint id&quot; +
493                         &quot; algorithm does not match, requested: &quot; +
494                         identityAlg + &quot;, cached: &quot; + sessionIdentityAlg);
495                 }
496                 result = false;
497             }
498         }
499 
500         // Ensure cipher suite can be negotiated
501         if (result &amp;&amp; (!shc.isNegotiable(s.getSuite()) ||
502             !clientHello.cipherSuites.contains(s.getSuite()))) {
503             if (SSLLogger.isOn &amp;&amp;
504                     SSLLogger.isOn(&quot;ssl,handshake,verbose&quot;)) {
505                 SSLLogger.finest(
506                     &quot;Can&#39;t resume, unavailable session cipher suite&quot;);
507             }
508             result = false;
509         }
510 
511         return result;
512     }
513 
514     private static final
515             class CHPreSharedKeyUpdate implements HandshakeConsumer {
516         // Prevent instantiation of this class.
517         private CHPreSharedKeyUpdate() {
518             // blank
519         }
520 
521         @Override
522         public void consume(ConnectionContext context,
523                 HandshakeMessage message) throws IOException {
524             ServerHandshakeContext shc = (ServerHandshakeContext)context;
525             if (!shc.isResumption || shc.resumingSession == null) {
526                 // not resuming---nothing to do
527                 return;
528             }
529 
530             CHPreSharedKeySpec chPsk = (CHPreSharedKeySpec)
531                     shc.handshakeExtensions.get(SSLExtension.CH_PRE_SHARED_KEY);
532             SHPreSharedKeySpec shPsk = (SHPreSharedKeySpec)
533                     shc.handshakeExtensions.get(SSLExtension.SH_PRE_SHARED_KEY);
534             if (chPsk == null || shPsk == null) {
535                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
536                         &quot;Required extensions are unavailable&quot;);
537             }
538 
539             byte[] binder = chPsk.binders.get(shPsk.selectedIdentity);
540 
541             // set up PSK binder hash
542             HandshakeHash pskBinderHash = shc.handshakeHash.copy();
543             byte[] lastMessage = pskBinderHash.removeLastReceived();
544             ByteBuffer messageBuf = ByteBuffer.wrap(lastMessage);
545             // skip the type and length
546             messageBuf.position(4);
547             // read to find the beginning of the binders
548             ClientHelloMessage.readPartial(shc.conContext, messageBuf);
549             int length = messageBuf.position();
550             messageBuf.position(0);
551             pskBinderHash.receive(messageBuf, length);
552 
553             checkBinder(shc, shc.resumingSession, pskBinderHash, binder);
554         }
555     }
556 
557     private static void checkBinder(ServerHandshakeContext shc,
558             SSLSessionImpl session,
559             HandshakeHash pskBinderHash, byte[] binder) throws IOException {
560         SecretKey psk = session.getPreSharedKey();
561         if (psk == null) {
562             throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
563                     &quot;Session has no PSK&quot;);
564         }
565 
566         SecretKey binderKey = deriveBinderKey(shc, psk, session);
567         byte[] computedBinder =
568                 computeBinder(shc, binderKey, session, pskBinderHash);
569         if (!Arrays.equals(binder, computedBinder)) {
570             throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
571                     &quot;Incorect PSK binder value&quot;);
572         }
573     }
574 
575     // Class that produces partial messages used to compute binder hash
576     static final class PartialClientHelloMessage extends HandshakeMessage {
577 
578         private final ClientHello.ClientHelloMessage msg;
579         private final CHPreSharedKeySpec psk;
580 
581         PartialClientHelloMessage(HandshakeContext ctx,
582                                   ClientHello.ClientHelloMessage msg,
583                                   CHPreSharedKeySpec psk) {
584             super(ctx);
585 
586             this.msg = msg;
587             this.psk = psk;
588         }
589 
590         @Override
591         SSLHandshake handshakeType() {
592             return msg.handshakeType();
593         }
594 
595         private int pskTotalLength() {
596             return psk.getIdsEncodedLength() +
597                 psk.getBindersEncodedLength() + 8;
598         }
599 
600         @Override
601         int messageLength() {
602 
603             if (msg.extensions.get(SSLExtension.CH_PRE_SHARED_KEY) != null) {
604                 return msg.messageLength();
605             } else {
606                 return msg.messageLength() + pskTotalLength();
607             }
608         }
609 
610         @Override
611         void send(HandshakeOutStream hos) throws IOException {
612             msg.sendCore(hos);
613 
614             // complete extensions
615             int extsLen = msg.extensions.length();
616             if (msg.extensions.get(SSLExtension.CH_PRE_SHARED_KEY) == null) {
617                 extsLen += pskTotalLength();
618             }
619             hos.putInt16(extsLen - 2);
620             // write the complete extensions
621             for (SSLExtension ext : SSLExtension.values()) {
622                 byte[] extData = msg.extensions.get(ext);
623                 if (extData == null) {
624                     continue;
625                 }
626                 // the PSK could be there from an earlier round
627                 if (ext == SSLExtension.CH_PRE_SHARED_KEY) {
628                     continue;
629                 }
630                 int extID = ext.id;
631                 hos.putInt16(extID);
632                 hos.putBytes16(extData);
633             }
634 
635             // partial PSK extension
636             int extID = SSLExtension.CH_PRE_SHARED_KEY.id;
637             hos.putInt16(extID);
638             byte[] encodedPsk = psk.getEncoded();
639             hos.putInt16(encodedPsk.length);
640             hos.write(encodedPsk, 0, psk.getIdsEncodedLength() + 2);
641         }
642     }
643 
644     private static final
645             class CHPreSharedKeyProducer implements HandshakeProducer {
646         // Prevent instantiation of this class.
647         private CHPreSharedKeyProducer() {
648             // blank
649         }
650 
651         @Override
652         public byte[] produce(ConnectionContext context,
653                 HandshakeMessage message) throws IOException {
654 
655             // The producing happens in client side only.
656             ClientHandshakeContext chc = (ClientHandshakeContext)context;
657             if (!chc.isResumption || chc.resumingSession == null) {
658                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
659                     SSLLogger.fine(&quot;No session to resume.&quot;);
660                 }
661                 return null;
662             }
663 
664             // Make sure the list of supported signature algorithms matches
665             Collection&lt;SignatureScheme&gt; sessionSigAlgs =
666                 chc.resumingSession.getLocalSupportedSignatureSchemes();
667             if (!chc.localSupportedSignAlgs.containsAll(sessionSigAlgs)) {
668                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
669                     SSLLogger.fine(&quot;Existing session uses different &quot; +
670                         &quot;signature algorithms&quot;);
671                 }
672                 return null;
673             }
674 
675             // The session must have a pre-shared key
676             SecretKey psk = chc.resumingSession.getPreSharedKey();
677             if (psk == null) {
678                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
679                     SSLLogger.fine(&quot;Existing session has no PSK.&quot;);
680                 }
681                 return null;
682             }
683 
684             // The PSK ID can only be used in one connections, but this method
685             // may be called twice in a connection if the server sends HRR.
686             // ID is saved in the context so it can be used in the second call.
687             if (chc.pskIdentity == null) {
688                 chc.pskIdentity = chc.resumingSession.consumePskIdentity();
689             }
690 
691             if (chc.pskIdentity == null) {
692                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
693                     SSLLogger.fine(
694                         &quot;PSK has no identity, or identity was already used&quot;);
695                 }
696                 return null;
697             }
698 
699             //The session cannot be used again. Remove it from the cache.
700             SSLSessionContextImpl sessionCache = (SSLSessionContextImpl)
701                 chc.sslContext.engineGetClientSessionContext();
702             sessionCache.remove(chc.resumingSession.getSessionId());
703 
704             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
705                 SSLLogger.fine(
706                     &quot;Found resumable session. Preparing PSK message.&quot;);
707             }
708 
709             List&lt;PskIdentity&gt; identities = new ArrayList&lt;&gt;();
710             int ageMillis = (int)(System.currentTimeMillis() -
711                     chc.resumingSession.getTicketCreationTime());
712             int obfuscatedAge =
713                     ageMillis + chc.resumingSession.getTicketAgeAdd();
714             identities.add(new PskIdentity(chc.pskIdentity, obfuscatedAge));
715 
716             SecretKey binderKey =
717                     deriveBinderKey(chc, psk, chc.resumingSession);
718             ClientHelloMessage clientHello = (ClientHelloMessage)message;
719             CHPreSharedKeySpec pskPrototype = createPskPrototype(
720                 chc.resumingSession.getSuite().hashAlg.hashLength, identities);
721             HandshakeHash pskBinderHash = chc.handshakeHash.copy();
722 
723             byte[] binder = computeBinder(chc, binderKey, pskBinderHash,
724                     chc.resumingSession, chc, clientHello, pskPrototype);
725 
726             List&lt;byte[]&gt; binders = new ArrayList&lt;&gt;();
727             binders.add(binder);
728 
729             CHPreSharedKeySpec pskMessage =
730                     new CHPreSharedKeySpec(identities, binders);
731             chc.handshakeExtensions.put(CH_PRE_SHARED_KEY, pskMessage);
732             return pskMessage.getEncoded();
733         }
734 
735         private CHPreSharedKeySpec createPskPrototype(
736                 int hashLength, List&lt;PskIdentity&gt; identities) {
737             List&lt;byte[]&gt; binders = new ArrayList&lt;&gt;();
738             byte[] binderProto = new byte[hashLength];
739             int i = identities.size();
740             while (i-- &gt; 0) {
741                 binders.add(binderProto);
742             }
743 
744             return new CHPreSharedKeySpec(identities, binders);
745         }
746     }
747 
748     private static byte[] computeBinder(
749             HandshakeContext context, SecretKey binderKey,
750             SSLSessionImpl session,
751             HandshakeHash pskBinderHash) throws IOException {
752 
753         pskBinderHash.determine(
754                 session.getProtocolVersion(), session.getSuite());
755         pskBinderHash.update();
756         byte[] digest = pskBinderHash.digest();
757 
758         return computeBinder(context, binderKey, session, digest);
759     }
760 
761     private static byte[] computeBinder(
762             HandshakeContext context, SecretKey binderKey,
763             HandshakeHash hash, SSLSessionImpl session,
764             HandshakeContext ctx, ClientHello.ClientHelloMessage hello,
765             CHPreSharedKeySpec pskPrototype) throws IOException {
766 
767         PartialClientHelloMessage partialMsg =
768                 new PartialClientHelloMessage(ctx, hello, pskPrototype);
769 
770         SSLEngineOutputRecord record = new SSLEngineOutputRecord(hash);
771         HandshakeOutStream hos = new HandshakeOutStream(record);
772         partialMsg.write(hos);
773 
774         hash.determine(session.getProtocolVersion(), session.getSuite());
775         hash.update();
776         byte[] digest = hash.digest();
777 
778         return computeBinder(context, binderKey, session, digest);
779     }
780 
781     private static byte[] computeBinder(HandshakeContext context,
782             SecretKey binderKey,
783             SSLSessionImpl session, byte[] digest) throws IOException {
784         try {
785             CipherSuite.HashAlg hashAlg = session.getSuite().hashAlg;
786             HKDF hkdf = new HKDF(hashAlg.name);
787             byte[] label = (&quot;tls13 finished&quot;).getBytes();
788             byte[] hkdfInfo = SSLSecretDerivation.createHkdfInfo(
789                     label, new byte[0], hashAlg.hashLength);
790             SecretKey finishedKey = hkdf.expand(
791                     binderKey, hkdfInfo, hashAlg.hashLength, &quot;TlsBinderKey&quot;);
792 
793             String hmacAlg =
794                 &quot;Hmac&quot; + hashAlg.name.replace(&quot;-&quot;, &quot;&quot;);
795             try {
796                 Mac hmac = Mac.getInstance(hmacAlg);
797                 hmac.init(finishedKey);
798                 return hmac.doFinal(digest);
799             } catch (NoSuchAlgorithmException | InvalidKeyException ex) {
800                 throw context.conContext.fatal(Alert.INTERNAL_ERROR, ex);
801             }
802         } catch (GeneralSecurityException ex) {
803             throw context.conContext.fatal(Alert.INTERNAL_ERROR, ex);
804         }
805     }
806 
807     private static SecretKey deriveBinderKey(HandshakeContext context,
808             SecretKey psk, SSLSessionImpl session) throws IOException {
809         try {
810             CipherSuite.HashAlg hashAlg = session.getSuite().hashAlg;
811             HKDF hkdf = new HKDF(hashAlg.name);
812             byte[] zeros = new byte[hashAlg.hashLength];
813             SecretKey earlySecret = hkdf.extract(zeros, psk, &quot;TlsEarlySecret&quot;);
814 
815             byte[] label = (&quot;tls13 res binder&quot;).getBytes();
816             MessageDigest md = MessageDigest.getInstance(hashAlg.name);
817             byte[] hkdfInfo = SSLSecretDerivation.createHkdfInfo(
818                     label, md.digest(new byte[0]), hashAlg.hashLength);
819             return hkdf.expand(earlySecret,
820                     hkdfInfo, hashAlg.hashLength, &quot;TlsBinderKey&quot;);
821         } catch (GeneralSecurityException ex) {
822             throw context.conContext.fatal(Alert.INTERNAL_ERROR, ex);
823         }
824     }
825 
826     private static final
827             class CHPreSharedKeyOnLoadAbsence implements HandshakeAbsence {
828         @Override
829         public void absent(ConnectionContext context,
830                            HandshakeMessage message) throws IOException {
831 
832             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
833                 SSLLogger.fine(
834                 &quot;Handling pre_shared_key absence.&quot;);
835             }
836 
837             ServerHandshakeContext shc = (ServerHandshakeContext)context;
838 
839             // Resumption is only determined by PSK, when enabled
840             shc.resumingSession = null;
841             shc.isResumption = false;
842         }
843     }
844 
845     /**
846      * The absence processing if the extension is not present in
847      * a ClientHello handshake message.
848      */
849     private static final class CHPreSharedKeyOnTradeAbsence
850             implements HandshakeAbsence {
851         @Override
852         public void absent(ConnectionContext context,
853                 HandshakeMessage message) throws IOException {
854             // The producing happens in server side only.
855             ServerHandshakeContext shc = (ServerHandshakeContext)context;
856 
857             // A client is considered to be attempting to negotiate using this
858             // specification if the ClientHello contains a &quot;supported_versions&quot;
859             // extension with 0x0304 contained in its body.  Such a ClientHello
860             // message MUST meet the following requirements:
861             //   -  If not containing a &quot;pre_shared_key&quot; extension, it MUST
862             //      contain both a &quot;signature_algorithms&quot; extension and a
863             //      &quot;supported_groups&quot; extension.
864             if (shc.negotiatedProtocol.useTLS13PlusSpec() &amp;&amp;
865                     (!shc.handshakeExtensions.containsKey(
866                             SSLExtension.CH_SIGNATURE_ALGORITHMS) ||
867                      !shc.handshakeExtensions.containsKey(
868                             SSLExtension.CH_SUPPORTED_GROUPS))) {
869                 throw shc.conContext.fatal(Alert.MISSING_EXTENSION,
870                     &quot;No supported_groups or signature_algorithms extension &quot; +
871                     &quot;when pre_shared_key extension is not present&quot;);
872             }
873         }
874     }
875 
876     private static final
877             class SHPreSharedKeyConsumer implements ExtensionConsumer {
878         // Prevent instantiation of this class.
879         private SHPreSharedKeyConsumer() {
880             // blank
881         }
882 
883         @Override
884         public void consume(ConnectionContext context,
885             HandshakeMessage message, ByteBuffer buffer) throws IOException {
886             // The consuming happens in client side only.
887             ClientHandshakeContext chc = (ClientHandshakeContext)context;
888 
889             // Is it a response of the specific request?
890             if (!chc.handshakeExtensions.containsKey(
891                     SSLExtension.CH_PRE_SHARED_KEY)) {
892                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
893                     &quot;Server sent unexpected pre_shared_key extension&quot;);
894             }
895 
896             SHPreSharedKeySpec shPsk = new SHPreSharedKeySpec(chc, buffer);
897             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
898                 SSLLogger.fine(
899                     &quot;Received pre_shared_key extension: &quot;, shPsk);
900             }
901 
902             if (shPsk.selectedIdentity != 0) {
903                 throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
904                     &quot;Selected identity index is not in correct range.&quot;);
905             }
906 
907             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
908                 SSLLogger.fine(
909                         &quot;Resuming session: &quot;, chc.resumingSession);
910             }
911         }
912     }
913 
914     private static final
915             class SHPreSharedKeyAbsence implements HandshakeAbsence {
916         @Override
917         public void absent(ConnectionContext context,
918                 HandshakeMessage message) throws IOException {
919             ClientHandshakeContext chc = (ClientHandshakeContext)context;
920 
921             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
922                 SSLLogger.fine(&quot;Handling pre_shared_key absence.&quot;);
923             }
924 
925             // The server refused to resume, or the client did not
926             // request 1.3 resumption.
927             chc.resumingSession = null;
928             chc.isResumption = false;
929         }
930     }
931 
932     private static final
933             class SHPreSharedKeyProducer implements HandshakeProducer {
934         // Prevent instantiation of this class.
935         private SHPreSharedKeyProducer() {
936             // blank
937         }
938 
939         @Override
940         public byte[] produce(ConnectionContext context,
941                 HandshakeMessage message) throws IOException {
942             ServerHandshakeContext shc = (ServerHandshakeContext)context;
943             SHPreSharedKeySpec psk = (SHPreSharedKeySpec)
944                     shc.handshakeExtensions.get(SH_PRE_SHARED_KEY);
945             if (psk == null) {
946                 return null;
947             }
948 
949             return psk.getEncoded();
950         }
951     }
952 }
    </pre>
  </body>
</html>
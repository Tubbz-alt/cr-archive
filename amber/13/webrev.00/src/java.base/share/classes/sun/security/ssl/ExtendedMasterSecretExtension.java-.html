<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/sun/security/ssl/ExtendedMasterSecretExtension.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2017, Red Hat, Inc. and/or its affiliates.
  3  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.  Oracle designates this
  9  * particular file as subject to the &quot;Classpath&quot; exception as provided
 10  * by Oracle in the LICENSE file that accompanied this code.
 11  *
 12  * This code is distributed in the hope that it will be useful, but WITHOUT
 13  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 14  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 15  * version 2 for more details (a copy is included in the LICENSE file that
 16  * accompanied this code).
 17  *
 18  * You should have received a copy of the GNU General Public License version
 19  * 2 along with this work; if not, write to the Free Software Foundation,
 20  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 21  *
 22  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 23  * or visit www.oracle.com if you need additional information or have any
 24  * questions.
 25  */
 26 
 27 package sun.security.ssl;
 28 
 29 import java.io.IOException;
 30 import java.nio.ByteBuffer;
 31 import javax.net.ssl.SSLProtocolException;
 32 import static sun.security.ssl.SSLExtension.CH_EXTENDED_MASTER_SECRET;
 33 import sun.security.ssl.SSLExtension.ExtensionConsumer;
 34 import static sun.security.ssl.SSLExtension.SH_EXTENDED_MASTER_SECRET;
 35 import sun.security.ssl.SSLExtension.SSLExtensionSpec;
 36 import sun.security.ssl.SSLHandshake.HandshakeMessage;
 37 
 38 /**
 39  * Pack of the &quot;extended_master_secret&quot; extensions [RFC 7627].
 40  */
 41 final class ExtendedMasterSecretExtension {
 42     static final HandshakeProducer chNetworkProducer =
 43             new CHExtendedMasterSecretProducer();
 44     static final ExtensionConsumer chOnLoadConsumer =
 45             new CHExtendedMasterSecretConsumer();
 46     static final HandshakeAbsence chOnLoadAbsence =
 47             new CHExtendedMasterSecretAbsence();
 48 
 49     static final HandshakeProducer shNetworkProducer =
 50             new SHExtendedMasterSecretProducer();
 51     static final ExtensionConsumer shOnLoadConsumer =
 52             new SHExtendedMasterSecretConsumer();
 53     static final HandshakeAbsence shOnLoadAbsence =
 54             new SHExtendedMasterSecretAbsence();
 55 
 56     static final SSLStringizer emsStringizer =
 57             new ExtendedMasterSecretStringizer();
 58 
 59     /**
 60      * The &quot;extended_master_secret&quot; extension.
 61      */
 62     static final class ExtendedMasterSecretSpec implements SSLExtensionSpec {
 63         // A nominal object that does not holding any real renegotiation info.
 64         static final ExtendedMasterSecretSpec NOMINAL =
 65                 new ExtendedMasterSecretSpec();
 66 
 67         private ExtendedMasterSecretSpec() {
 68             // blank
 69         }
 70 
 71         private ExtendedMasterSecretSpec(ByteBuffer m) throws IOException {
 72             // Parse the extension.
 73             if (m.hasRemaining()) {
 74                 throw new SSLProtocolException(
 75                     &quot;Invalid extended_master_secret extension data: &quot; +
 76                     &quot;not empty&quot;);
 77             }
 78         }
 79 
 80         @Override
 81         public String toString() {
 82             return &quot;&lt;empty&gt;&quot;;
 83         }
 84     }
 85 
 86     private static final
 87             class ExtendedMasterSecretStringizer implements SSLStringizer {
 88         @Override
 89         public String toString(ByteBuffer buffer) {
 90             try {
 91                 return (new ExtendedMasterSecretSpec(buffer)).toString();
 92             } catch (IOException ioe) {
 93                 // For debug logging only, so please swallow exceptions.
 94                 return ioe.getMessage();
 95             }
 96         }
 97     }
 98 
 99     /**
100      * Network data producer of a &quot;extended_master_secret&quot; extension in
101      * the ClientHello handshake message.
102      */
103     private static final
104             class CHExtendedMasterSecretProducer implements HandshakeProducer {
105         // Prevent instantiation of this class.
106         private CHExtendedMasterSecretProducer() {
107             // blank
108         }
109 
110         @Override
111         public byte[] produce(ConnectionContext context,
112                 HandshakeMessage message) throws IOException {
113             // The producing happens in client side only.
114             ClientHandshakeContext chc = (ClientHandshakeContext)context;
115 
116             // Is it a supported and enabled extension?
117             if (!chc.sslConfig.isAvailable(CH_EXTENDED_MASTER_SECRET) ||
118                     !SSLConfiguration.useExtendedMasterSecret ||
119                     !chc.conContext.protocolVersion.useTLS10PlusSpec()) {
120                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
121                     SSLLogger.fine(
122                         &quot;Ignore unavailable extended_master_secret extension&quot;);
123                 }
124 
125                 return null;
126             }
127 
128             if (chc.handshakeSession == null ||
129                     chc.handshakeSession.useExtendedMasterSecret) {
130                 byte[] extData = new byte[0];
131                 chc.handshakeExtensions.put(CH_EXTENDED_MASTER_SECRET,
132                         ExtendedMasterSecretSpec.NOMINAL);
133 
134                 return extData;
135             }
136 
137             return null;
138         }
139     }
140 
141     /**
142      * Network data producer of a &quot;extended_master_secret&quot; extension in
143      * the ServerHello handshake message.
144      */
145     private static final
146             class CHExtendedMasterSecretConsumer implements ExtensionConsumer {
147         // Prevent instantiation of this class.
148         private CHExtendedMasterSecretConsumer() {
149             // blank
150         }
151 
152         @Override
153         public void consume(ConnectionContext context,
154             HandshakeMessage message, ByteBuffer buffer) throws IOException {
155 
156             // The consuming happens in server side only.
157             ServerHandshakeContext shc = (ServerHandshakeContext)context;
158 
159             // Is it a supported and enabled extension?
160             if (!shc.sslConfig.isAvailable(CH_EXTENDED_MASTER_SECRET) ||
161                     !SSLConfiguration.useExtendedMasterSecret ||
162                     !shc.negotiatedProtocol.useTLS10PlusSpec()) {
163                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
164                     SSLLogger.fine(&quot;Ignore unavailable extension: &quot; +
165                             CH_EXTENDED_MASTER_SECRET.name);
166                 }
167                 return;     // ignore the extension
168             }
169 
170             // Parse the extension.
171             ExtendedMasterSecretSpec spec;
172             try {
173                 spec = new ExtendedMasterSecretSpec(buffer);
174             } catch (IOException ioe) {
175                 throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, ioe);
176             }
177 
178             if (shc.isResumption &amp;&amp; shc.resumingSession != null &amp;&amp;
179                     !shc.resumingSession.useExtendedMasterSecret) {
180                 // For abbreviated handshake request, If the original
181                 // session did not use the &quot;extended_master_secret&quot;
182                 // extension but the new ClientHello contains the
183                 // extension, then the server MUST NOT perform the
184                 // abbreviated handshake.  Instead, it SHOULD continue
185                 // with a full handshake.
186                 shc.isResumption = false;
187                 shc.resumingSession = null;
188                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
189                     SSLLogger.fine(
190                         &quot;abort session resumption which did not use &quot; +
191                         &quot;Extended Master Secret extension&quot;);
192                 }
193             }
194 
195             // Update the context.
196             //
197             shc.handshakeExtensions.put(
198                 CH_EXTENDED_MASTER_SECRET, ExtendedMasterSecretSpec.NOMINAL);
199 
200             // No impact on session resumption.
201         }
202     }
203 
204     /**
205      * The absence processing if a &quot;extended_master_secret&quot; extension is
206      * not present in the ClientHello handshake message.
207      */
208     private static final
209             class CHExtendedMasterSecretAbsence implements HandshakeAbsence {
210         @Override
211         public void absent(ConnectionContext context,
212                 HandshakeMessage message) throws IOException {
213             // The producing happens in server side only.
214             ServerHandshakeContext shc = (ServerHandshakeContext)context;
215 
216             // Is it a supported and enabled extension?
217             if (!shc.sslConfig.isAvailable(CH_EXTENDED_MASTER_SECRET) ||
218                     !SSLConfiguration.useExtendedMasterSecret) {
219                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
220                     SSLLogger.fine(&quot;Ignore unavailable extension: &quot; +
221                             CH_EXTENDED_MASTER_SECRET.name);
222                 }
223                 return;     // ignore the extension
224             }
225 
226             if (shc.negotiatedProtocol.useTLS10PlusSpec() &amp;&amp;
227                     !SSLConfiguration.allowLegacyMasterSecret) {
228                 // For full handshake, if the server receives a ClientHello
229                 // without the extension, it SHOULD abort the handshake if
230                 // it does not wish to interoperate with legacy clients.
231                 //
232                 // As if extended master extension is required for full
233                 // handshake, it MUST be used in abbreviated handshake too.
234                 throw shc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
235                     &quot;Extended Master Secret extension is required&quot;);
236             }
237 
238             if (shc.isResumption &amp;&amp; shc.resumingSession != null) {
239                 if (shc.resumingSession.useExtendedMasterSecret) {
240                     // For abbreviated handshake request, if the original
241                     // session used the &quot;extended_master_secret&quot; extension
242                     // but the new ClientHello does not contain it, the
243                     // server MUST abort the abbreviated handshake.
244                     throw shc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
245                             &quot;Missing Extended Master Secret extension &quot; +
246                             &quot;on session resumption&quot;);
247                 } else {
248                     // For abbreviated handshake request, if neither the
249                     // original session nor the new ClientHello uses the
250                     // extension, the server SHOULD abort the handshake.
251                     if (!SSLConfiguration.allowLegacyResumption) {
252                         throw shc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
253                             &quot;Missing Extended Master Secret extension &quot; +
254                             &quot;on session resumption&quot;);
255                     } else {  // Otherwise, continue with a full handshake.
256                         shc.isResumption = false;
257                         shc.resumingSession = null;
258                         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
259                             SSLLogger.fine(
260                                 &quot;abort session resumption, &quot; +
261                                 &quot;missing Extended Master Secret extension&quot;);
262                         }
263                     }
264                 }
265             }
266         }
267     }
268 
269     /**
270      * Network data producer of a &quot;extended_master_secret&quot; extension in
271      * the ServerHello handshake message.
272      */
273     private static final
274             class SHExtendedMasterSecretProducer implements HandshakeProducer {
275         // Prevent instantiation of this class.
276         private SHExtendedMasterSecretProducer() {
277             // blank
278         }
279 
280         @Override
281         public byte[] produce(ConnectionContext context,
282                 HandshakeMessage message) throws IOException {
283             // The producing happens in server side only.
284             ServerHandshakeContext shc = (ServerHandshakeContext)context;
285 
286             if (shc.handshakeSession.useExtendedMasterSecret) {
287                 byte[] extData = new byte[0];
288                 shc.handshakeExtensions.put(SH_EXTENDED_MASTER_SECRET,
289                         ExtendedMasterSecretSpec.NOMINAL);
290 
291                 return extData;
292             }
293 
294             return null;
295         }
296     }
297 
298     /**
299      * Network data consumer of a &quot;extended_master_secret&quot; extension in
300      * the ServerHello handshake message.
301      */
302     private static final
303             class SHExtendedMasterSecretConsumer implements ExtensionConsumer {
304         // Prevent instantiation of this class.
305         private SHExtendedMasterSecretConsumer() {
306             // blank
307         }
308 
309         @Override
310         public void consume(ConnectionContext context,
311             HandshakeMessage message, ByteBuffer buffer) throws IOException {
312             // The producing happens in client side only.
313             ClientHandshakeContext chc = (ClientHandshakeContext)context;
314 
315             // In response to the client extended_master_secret extension
316             // request, which is mandatory for ClientHello message.
317             ExtendedMasterSecretSpec requstedSpec = (ExtendedMasterSecretSpec)
318                     chc.handshakeExtensions.get(CH_EXTENDED_MASTER_SECRET);
319             if (requstedSpec == null) {
320                 throw chc.conContext.fatal(Alert.UNSUPPORTED_EXTENSION,
321                         &quot;Server sent the extended_master_secret &quot; +
322                         &quot;extension improperly&quot;);
323             }
324 
325             // Parse the extension.
326             ExtendedMasterSecretSpec spec;
327             try {
328                 spec = new ExtendedMasterSecretSpec(buffer);
329             } catch (IOException ioe) {
330                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, ioe);
331             }
332 
333             if (chc.isResumption &amp;&amp; chc.resumingSession != null &amp;&amp;
334                     !chc.resumingSession.useExtendedMasterSecret) {
335                 throw chc.conContext.fatal(Alert.UNSUPPORTED_EXTENSION,
336                         &quot;Server sent an unexpected extended_master_secret &quot; +
337                         &quot;extension on session resumption&quot;);
338             }
339 
340             // Update the context.
341             chc.handshakeExtensions.put(
342                 SH_EXTENDED_MASTER_SECRET, ExtendedMasterSecretSpec.NOMINAL);
343 
344             // No impact on session resumption.
345         }
346     }
347 
348     /**
349      * The absence processing if a &quot;extended_master_secret&quot; extension is
350      * not present in the ServerHello handshake message.
351      */
352     private static final
353             class SHExtendedMasterSecretAbsence implements HandshakeAbsence {
354         @Override
355         public void absent(ConnectionContext context,
356                 HandshakeMessage message) throws IOException {
357             // The producing happens in client side only.
358             ClientHandshakeContext chc = (ClientHandshakeContext)context;
359 
360             if (SSLConfiguration.useExtendedMasterSecret &amp;&amp;
361                     !SSLConfiguration.allowLegacyMasterSecret) {
362                 // For full handshake, if a client receives a ServerHello
363                 // without the extension, it SHOULD abort the handshake if
364                 // it does not wish to interoperate with legacy servers.
365                 throw chc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
366                         &quot;Extended Master Secret extension is required&quot;);
367             }
368 
369             if (chc.isResumption &amp;&amp; chc.resumingSession != null) {
370                 if (chc.resumingSession.useExtendedMasterSecret) {
371                     // For abbreviated handshake, if the original session used
372                     // the &quot;extended_master_secret&quot; extension but the new
373                     // ServerHello does not contain the extension, the client
374                     // MUST abort the handshake.
375                     throw chc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
376                             &quot;Missing Extended Master Secret extension &quot; +
377                             &quot;on session resumption&quot;);
378                 } else if (SSLConfiguration.useExtendedMasterSecret &amp;&amp;
379                         !SSLConfiguration.allowLegacyResumption &amp;&amp;
380                         chc.negotiatedProtocol.useTLS10PlusSpec()) {
381                     // Unlikely, abbreviated handshake should be discarded.
382                     throw chc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
383                         &quot;Extended Master Secret extension is required&quot;);
384                 }
385             }
386         }
387     }
388 }
389 
    </pre>
  </body>
</html>
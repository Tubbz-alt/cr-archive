<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/sun/security/ssl/CertSignAlgsExtension.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.io.IOException;
 29 import java.nio.ByteBuffer;
 30 import java.util.List;
 31 import sun.security.ssl.SSLExtension.ExtensionConsumer;
 32 import sun.security.ssl.SSLHandshake.HandshakeMessage;
 33 import sun.security.ssl.SignatureAlgorithmsExtension.SignatureSchemesSpec;
 34 
 35 /**
 36  * Pack of the &quot;signature_algorithms_cert&quot; extensions.
 37  */
 38 final class CertSignAlgsExtension {
 39     static final HandshakeProducer chNetworkProducer =
 40             new CHCertSignatureSchemesProducer();
 41     static final ExtensionConsumer chOnLoadConsumer =
 42             new CHCertSignatureSchemesConsumer();
 43     static final HandshakeConsumer chOnTradeConsumer =
 44             new CHCertSignatureSchemesUpdate();
 45 
 46     static final HandshakeProducer crNetworkProducer =
 47             new CRCertSignatureSchemesProducer();
 48     static final ExtensionConsumer crOnLoadConsumer =
 49             new CRCertSignatureSchemesConsumer();
 50     static final HandshakeConsumer crOnTradeConsumer =
 51             new CRCertSignatureSchemesUpdate();
 52 
 53     static final SSLStringizer ssStringizer =
 54             new CertSignatureSchemesStringizer();
 55 
 56     private static final
 57             class CertSignatureSchemesStringizer implements SSLStringizer {
 58         @Override
 59         public String toString(ByteBuffer buffer) {
 60             try {
 61                 return (new SignatureSchemesSpec(buffer)).toString();
 62             } catch (IOException ioe) {
 63                 // For debug logging only, so please swallow exceptions.
 64                 return ioe.getMessage();
 65             }
 66         }
 67     }
 68 
 69     /**
 70      * Network data producer of a &quot;signature_algorithms_cert&quot; extension in
 71      * the ClientHello handshake message.
 72      */
 73     private static final
 74             class CHCertSignatureSchemesProducer implements HandshakeProducer {
 75         // Prevent instantiation of this class.
 76         private CHCertSignatureSchemesProducer() {
 77             // blank
 78         }
 79 
 80         @Override
 81         public byte[] produce(ConnectionContext context,
 82                 HandshakeMessage message) throws IOException {
 83             // The producing happens in client side only.
 84             ClientHandshakeContext chc = (ClientHandshakeContext)context;
 85 
 86             // Is it a supported and enabled extension?
 87             if (!chc.sslConfig.isAvailable(
 88                     SSLExtension.CH_SIGNATURE_ALGORITHMS_CERT)) {
 89                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 90                     SSLLogger.fine(
 91                             &quot;Ignore unavailable &quot; +
 92                             &quot;signature_algorithms_cert extension&quot;);
 93                 }
 94 
 95                 return null;    // ignore the extension
 96             }
 97 
 98             // Produce the extension.
 99             if (chc.localSupportedSignAlgs == null) {
100                 chc.localSupportedSignAlgs =
101                     SignatureScheme.getSupportedAlgorithms(
102                             chc.algorithmConstraints, chc.activeProtocols);
103             }
104 
105             int vectorLen = SignatureScheme.sizeInRecord() *
106                     chc.localSupportedSignAlgs.size();
107             byte[] extData = new byte[vectorLen + 2];
108             ByteBuffer m = ByteBuffer.wrap(extData);
109             Record.putInt16(m, vectorLen);
110             for (SignatureScheme ss : chc.localSupportedSignAlgs) {
111                 Record.putInt16(m, ss.id);
112             }
113 
114             // Update the context.
115             chc.handshakeExtensions.put(
116                     SSLExtension.CH_SIGNATURE_ALGORITHMS_CERT,
117                     new SignatureSchemesSpec(chc.localSupportedSignAlgs));
118 
119             return extData;
120         }
121     }
122 
123     /**
124      * Network data consumer of a &quot;signature_algorithms_cert&quot; extension in
125      * the ClientHello handshake message.
126      */
127     private static final
128             class CHCertSignatureSchemesConsumer implements ExtensionConsumer {
129         // Prevent instantiation of this class.
130         private CHCertSignatureSchemesConsumer() {
131             // blank
132         }
133 
134         @Override
135         public void consume(ConnectionContext context,
136             HandshakeMessage message, ByteBuffer buffer) throws IOException {
137             // The consuming happens in server side only.
138             ServerHandshakeContext shc = (ServerHandshakeContext)context;
139 
140             // Is it a supported and enabled extension?
141             if (!shc.sslConfig.isAvailable(
142                     SSLExtension.CH_SIGNATURE_ALGORITHMS_CERT)) {
143                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
144                     SSLLogger.fine(
145                             &quot;Ignore unavailable &quot; +
146                             &quot;signature_algorithms_cert extension&quot;);
147                 }
148                 return;     // ignore the extension
149             }
150 
151             // Parse the extension.
152             SignatureSchemesSpec spec;
153             try {
154                 spec = new SignatureSchemesSpec(buffer);
155             } catch (IOException ioe) {
156                 throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, ioe);
157             }
158 
159             // Update the context.
160             shc.handshakeExtensions.put(
161                     SSLExtension.CH_SIGNATURE_ALGORITHMS_CERT, spec);
162 
163             // No impact on session resumption.
164         }
165     }
166 
167     /**
168      * After session creation consuming of a &quot;signature_algorithms_cert&quot;
169      * extension in the ClientHello handshake message.
170      */
171     private static final class CHCertSignatureSchemesUpdate
172             implements HandshakeConsumer {
173         // Prevent instantiation of this class.
174         private CHCertSignatureSchemesUpdate() {
175             // blank
176         }
177 
178         @Override
179         public void consume(ConnectionContext context,
180                 HandshakeMessage message) throws IOException {
181             // The consuming happens in server side only.
182             ServerHandshakeContext shc = (ServerHandshakeContext)context;
183 
184             SignatureSchemesSpec spec = (SignatureSchemesSpec)
185                     shc.handshakeExtensions.get(
186                             SSLExtension.CH_SIGNATURE_ALGORITHMS_CERT);
187             if (spec == null) {
188                 // Ignore, no signature_algorithms_cert extension requested.
189                 return;
190             }
191 
192             // update the context
193             List&lt;SignatureScheme&gt; schemes =
194                     SignatureScheme.getSupportedAlgorithms(
195                             shc.algorithmConstraints, shc.negotiatedProtocol,
196                             spec.signatureSchemes);
197             shc.peerRequestedCertSignSchemes = schemes;
198             shc.handshakeSession.setPeerSupportedSignatureAlgorithms(schemes);
199 
200             if (!shc.isResumption &amp;&amp; shc.negotiatedProtocol.useTLS13PlusSpec()) {
201                 if (shc.sslConfig.clientAuthType !=
202                         ClientAuthType.CLIENT_AUTH_NONE) {
203                     shc.handshakeProducers.putIfAbsent(
204                             SSLHandshake.CERTIFICATE_REQUEST.id,
205                             SSLHandshake.CERTIFICATE_REQUEST);
206                 }
207                 shc.handshakeProducers.put(SSLHandshake.CERTIFICATE.id,
208                         SSLHandshake.CERTIFICATE);
209                 shc.handshakeProducers.putIfAbsent(
210                         SSLHandshake.CERTIFICATE_VERIFY.id,
211                         SSLHandshake.CERTIFICATE_VERIFY);
212             }
213         }
214     }
215 
216     /**
217      * Network data producer of a &quot;signature_algorithms_cert&quot; extension in
218      * the CertificateRequest handshake message.
219      */
220     private static final
221             class CRCertSignatureSchemesProducer implements HandshakeProducer {
222         // Prevent instantiation of this class.
223         private CRCertSignatureSchemesProducer() {
224             // blank
225         }
226 
227         @Override
228         public byte[] produce(ConnectionContext context,
229                 HandshakeMessage message) throws IOException {
230             // The producing happens in server side only.
231             ServerHandshakeContext shc = (ServerHandshakeContext)context;
232 
233             // Is it a supported and enabled extension?
234             if (!shc.sslConfig.isAvailable(
235                     SSLExtension.CH_SIGNATURE_ALGORITHMS_CERT)) {
236                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
237                     SSLLogger.fine(
238                             &quot;Ignore unavailable &quot; +
239                             &quot;signature_algorithms_cert extension&quot;);
240                 }
241                 return null;    // ignore the extension
242             }
243 
244             // Produce the extension.
245             List&lt;SignatureScheme&gt; sigAlgs =
246                     SignatureScheme.getSupportedAlgorithms(
247                             shc.algorithmConstraints,
248                             List.of(shc.negotiatedProtocol));
249 
250             int vectorLen = SignatureScheme.sizeInRecord() * sigAlgs.size();
251             byte[] extData = new byte[vectorLen + 2];
252             ByteBuffer m = ByteBuffer.wrap(extData);
253             Record.putInt16(m, vectorLen);
254             for (SignatureScheme ss : sigAlgs) {
255                 Record.putInt16(m, ss.id);
256             }
257 
258             // Update the context.
259             shc.handshakeExtensions.put(
260                     SSLExtension.CR_SIGNATURE_ALGORITHMS_CERT,
261                     new SignatureSchemesSpec(shc.localSupportedSignAlgs));
262 
263             return extData;
264         }
265     }
266 
267     /**
268      * Network data consumer of a &quot;signature_algorithms_cert&quot; extension in
269      * the CertificateRequest handshake message.
270      */
271     private static final
272             class CRCertSignatureSchemesConsumer implements ExtensionConsumer {
273         // Prevent instantiation of this class.
274         private CRCertSignatureSchemesConsumer() {
275             // blank
276         }
277         @Override
278         public void consume(ConnectionContext context,
279             HandshakeMessage message, ByteBuffer buffer) throws IOException {
280             // The consuming happens in client side only.
281             ClientHandshakeContext chc = (ClientHandshakeContext)context;
282 
283             // Is it a supported and enabled extension?
284             if (!chc.sslConfig.isAvailable(
285                     SSLExtension.CH_SIGNATURE_ALGORITHMS_CERT)) {
286                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
287                     SSLLogger.fine(
288                             &quot;Ignore unavailable &quot; +
289                             &quot;signature_algorithms_cert extension&quot;);
290                 }
291                 return;     // ignore the extension
292             }
293 
294             // Parse the extension.
295             SignatureSchemesSpec spec;
296             try {
297                 spec = new SignatureSchemesSpec(buffer);
298             } catch (IOException ioe) {
299                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, ioe);
300             }
301 
302             // Update the context.
303             chc.handshakeExtensions.put(
304                     SSLExtension.CR_SIGNATURE_ALGORITHMS_CERT, spec);
305 
306             // No impact on session resumption.
307         }
308     }
309 
310     /**
311      * After session creation consuming of a &quot;signature_algorithms_cert&quot;
312      * extension in the CertificateRequest handshake message.
313      */
314     private static final class CRCertSignatureSchemesUpdate
315             implements HandshakeConsumer {
316         // Prevent instantiation of this class.
317         private CRCertSignatureSchemesUpdate() {
318             // blank
319         }
320 
321         @Override
322         public void consume(ConnectionContext context,
323                 HandshakeMessage message) throws IOException {
324             // The consuming happens in client side only.
325             ClientHandshakeContext chc = (ClientHandshakeContext)context;
326 
327             SignatureSchemesSpec spec = (SignatureSchemesSpec)
328                     chc.handshakeExtensions.get(
329                             SSLExtension.CR_SIGNATURE_ALGORITHMS_CERT);
330             if (spec == null) {
331                 // Ignore, no &quot;signature_algorithms_cert&quot; extension requested.
332                 return;
333             }
334 
335             // update the context
336             List&lt;SignatureScheme&gt; schemes =
337                     SignatureScheme.getSupportedAlgorithms(
338                             chc.algorithmConstraints, chc.negotiatedProtocol,
339                             spec.signatureSchemes);
340             chc.peerRequestedCertSignSchemes = schemes;
341             chc.handshakeSession.setPeerSupportedSignatureAlgorithms(schemes);
342         }
343     }
344 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/sun/security/ssl/SignatureAlgorithmsExtension.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.io.IOException;
 29 import java.nio.ByteBuffer;
 30 import java.text.MessageFormat;
 31 import java.util.Arrays;
 32 import java.util.LinkedList;
 33 import java.util.List;
 34 import java.util.Locale;
 35 import javax.net.ssl.SSLProtocolException;
 36 import sun.security.ssl.SSLExtension.ExtensionConsumer;
 37 import sun.security.ssl.SSLExtension.SSLExtensionSpec;
 38 import sun.security.ssl.SSLHandshake.HandshakeMessage;
 39 
 40 /**
 41  * Pack of the &quot;signature_algorithms&quot; extensions [RFC 5246].
 42  */
 43 final class SignatureAlgorithmsExtension {
 44     static final HandshakeProducer chNetworkProducer =
 45             new CHSignatureSchemesProducer();
 46     static final ExtensionConsumer chOnLoadConsumer =
 47             new CHSignatureSchemesConsumer();
 48     static final HandshakeAbsence chOnLoadAbsence =
 49             new CHSignatureSchemesOnLoadAbsence();
 50     static final HandshakeConsumer chOnTradeConsumer =
 51             new CHSignatureSchemesUpdate();
 52     static final HandshakeAbsence chOnTradeAbsence =
 53             new CHSignatureSchemesOnTradeAbsence();
 54 
 55     static final HandshakeProducer crNetworkProducer =
 56             new CRSignatureSchemesProducer();
 57     static final ExtensionConsumer crOnLoadConsumer =
 58             new CRSignatureSchemesConsumer();
 59     static final HandshakeAbsence crOnLoadAbsence =
 60             new CRSignatureSchemesAbsence();
 61     static final HandshakeConsumer crOnTradeConsumer =
 62             new CRSignatureSchemesUpdate();
 63 
 64     static final SSLStringizer ssStringizer =
 65             new SignatureSchemesStringizer();
 66 
 67     /**
 68      * The &quot;signature_algorithms&quot; extension.
 69      */
 70     static final class SignatureSchemesSpec implements SSLExtensionSpec {
 71         final int[] signatureSchemes;
 72 
 73         SignatureSchemesSpec(List&lt;SignatureScheme&gt; schemes) {
 74             if (schemes != null) {
 75                 signatureSchemes = new int[schemes.size()];
 76                 int i = 0;
 77                 for (SignatureScheme scheme : schemes) {
 78                     signatureSchemes[i++] = scheme.id;
 79                 }
 80             } else {
 81                 this.signatureSchemes = new int[0];
 82             }
 83         }
 84 
 85         SignatureSchemesSpec(ByteBuffer buffer) throws IOException {
 86             if (buffer.remaining() &lt; 2) {      // 2: the length of the list
 87                 throw new SSLProtocolException(
 88                     &quot;Invalid signature_algorithms: insufficient data&quot;);
 89             }
 90 
 91             byte[] algs = Record.getBytes16(buffer);
 92             if (buffer.hasRemaining()) {
 93                 throw new SSLProtocolException(
 94                     &quot;Invalid signature_algorithms: unknown extra data&quot;);
 95             }
 96 
 97             if (algs == null || algs.length == 0 || (algs.length &amp; 0x01) != 0) {
 98                 throw new SSLProtocolException(
 99                     &quot;Invalid signature_algorithms: incomplete data&quot;);
100             }
101 
102             int[] schemes = new int[algs.length / 2];
103             for (int i = 0, j = 0; i &lt; algs.length;) {
104                 byte hash = algs[i++];
105                 byte sign = algs[i++];
106                 schemes[j++] = ((hash &amp; 0xFF) &lt;&lt; 8) | (sign &amp; 0xFF);
107             }
108 
109             this.signatureSchemes = schemes;
110         }
111 
112         @Override
113         public String toString() {
114             MessageFormat messageFormat = new MessageFormat(
115                 &quot;\&quot;signature schemes\&quot;: &#39;[&#39;{0}&#39;]&#39;&quot;, Locale.ENGLISH);
116 
117             if (signatureSchemes == null || signatureSchemes.length == 0) {
118                 Object[] messageFields = {
119                         &quot;&lt;no supported signature schemes specified&gt;&quot;
120                     };
121                 return messageFormat.format(messageFields);
122             } else {
123                 StringBuilder builder = new StringBuilder(512);
124                 boolean isFirst = true;
125                 for (int pv : signatureSchemes) {
126                     if (isFirst) {
127                         isFirst = false;
128                     } else {
129                         builder.append(&quot;, &quot;);
130                     }
131 
132                     builder.append(SignatureScheme.nameOf(pv));
133                 }
134 
135                 Object[] messageFields = {
136                         builder.toString()
137                     };
138 
139                 return messageFormat.format(messageFields);
140             }
141         }
142     }
143 
144     private static final
145             class SignatureSchemesStringizer implements SSLStringizer {
146         @Override
147         public String toString(ByteBuffer buffer) {
148             try {
149                 return (new SignatureSchemesSpec(buffer)).toString();
150             } catch (IOException ioe) {
151                 // For debug logging only, so please swallow exceptions.
152                 return ioe.getMessage();
153             }
154         }
155     }
156 
157     /**
158      * Network data producer of a &quot;signature_algorithms&quot; extension in
159      * the ClientHello handshake message.
160      */
161     private static final
162             class CHSignatureSchemesProducer implements HandshakeProducer {
163         // Prevent instantiation of this class.
164         private CHSignatureSchemesProducer() {
165             // blank
166         }
167 
168         @Override
169         public byte[] produce(ConnectionContext context,
170                 HandshakeMessage message) throws IOException {
171             // The producing happens in client side only.
172             ClientHandshakeContext chc = (ClientHandshakeContext)context;
173 
174             // Is it a supported and enabled extension?
175             if (!chc.sslConfig.isAvailable(
176                     SSLExtension.CH_SIGNATURE_ALGORITHMS)) {
177                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
178                     SSLLogger.fine(
179                         &quot;Ignore unavailable signature_algorithms extension&quot;);
180                 }
181                 return null;
182             }
183 
184             // Produce the extension.
185             if (chc.localSupportedSignAlgs == null) {
186                 chc.localSupportedSignAlgs =
187                     SignatureScheme.getSupportedAlgorithms(
188                             chc.algorithmConstraints, chc.activeProtocols);
189             }
190 
191             int vectorLen = SignatureScheme.sizeInRecord() *
192                     chc.localSupportedSignAlgs.size();
193             byte[] extData = new byte[vectorLen + 2];
194             ByteBuffer m = ByteBuffer.wrap(extData);
195             Record.putInt16(m, vectorLen);
196             for (SignatureScheme ss : chc.localSupportedSignAlgs) {
197                 Record.putInt16(m, ss.id);
198             }
199 
200             // Update the context.
201             chc.handshakeExtensions.put(
202                     SSLExtension.CH_SIGNATURE_ALGORITHMS,
203                     new SignatureSchemesSpec(chc.localSupportedSignAlgs));
204 
205             return extData;
206         }
207     }
208 
209     /**
210      * Network data consumer of a &quot;signature_algorithms&quot; extension in
211      * the ClientHello handshake message.
212      */
213     private static final
214             class CHSignatureSchemesConsumer implements ExtensionConsumer {
215         // Prevent instantiation of this class.
216         private CHSignatureSchemesConsumer() {
217             // blank
218         }
219 
220         @Override
221         public void consume(ConnectionContext context,
222             HandshakeMessage message, ByteBuffer buffer) throws IOException {
223             // The consuming happens in server side only.
224             ServerHandshakeContext shc = (ServerHandshakeContext)context;
225 
226             // Is it a supported and enabled extension?
227             if (!shc.sslConfig.isAvailable(
228                     SSLExtension.CH_SIGNATURE_ALGORITHMS)) {
229                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
230                     SSLLogger.fine(
231                         &quot;Ignore unavailable signature_algorithms extension&quot;);
232                 }
233                 return;     // ignore the extension
234             }
235 
236             // Parse the extension.
237             SignatureSchemesSpec spec;
238             try {
239                 spec = new SignatureSchemesSpec(buffer);
240             } catch (IOException ioe) {
241                 throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, ioe);
242             }
243 
244             // Update the context.
245             shc.handshakeExtensions.put(
246                     SSLExtension.CH_SIGNATURE_ALGORITHMS, spec);
247 
248             // No impact on session resumption.
249         }
250     }
251 
252     /**
253      * After session creation consuming of a &quot;signature_algorithms&quot;
254      * extension in the ClientHello handshake message.
255      */
256     private static final class CHSignatureSchemesUpdate
257             implements HandshakeConsumer {
258         // Prevent instantiation of this class.
259         private CHSignatureSchemesUpdate() {
260             // blank
261         }
262 
263         @Override
264         public void consume(ConnectionContext context,
265                 HandshakeMessage message) throws IOException {
266             // The consuming happens in server side only.
267             ServerHandshakeContext shc = (ServerHandshakeContext)context;
268 
269             SignatureSchemesSpec spec =
270                     (SignatureSchemesSpec)shc.handshakeExtensions.get(
271                             SSLExtension.CH_SIGNATURE_ALGORITHMS);
272             if (spec == null) {
273                 // Ignore, no &quot;signature_algorithms&quot; extension requested.
274                 return;
275             }
276 
277             // update the context
278             List&lt;SignatureScheme&gt; sss =
279                     SignatureScheme.getSupportedAlgorithms(
280                             shc.algorithmConstraints, shc.negotiatedProtocol,
281                             spec.signatureSchemes);
282             shc.peerRequestedSignatureSchemes = sss;
283 
284             // If no &quot;signature_algorithms_cert&quot; extension is present, then
285             // the &quot;signature_algorithms&quot; extension also applies to
286             // signatures appearing in certificates.
287             SignatureSchemesSpec certSpec =
288                     (SignatureSchemesSpec)shc.handshakeExtensions.get(
289                             SSLExtension.CH_SIGNATURE_ALGORITHMS_CERT);
290             if (certSpec == null) {
291                 shc.peerRequestedCertSignSchemes = sss;
292                 shc.handshakeSession.setPeerSupportedSignatureAlgorithms(sss);
293             }
294 
295             if (!shc.isResumption &amp;&amp;
296                     shc.negotiatedProtocol.useTLS13PlusSpec()) {
297                 if (shc.sslConfig.clientAuthType !=
298                         ClientAuthType.CLIENT_AUTH_NONE) {
299                     shc.handshakeProducers.putIfAbsent(
300                             SSLHandshake.CERTIFICATE_REQUEST.id,
301                             SSLHandshake.CERTIFICATE_REQUEST);
302                 }
303                 shc.handshakeProducers.put(
304                         SSLHandshake.CERTIFICATE.id,
305                         SSLHandshake.CERTIFICATE);
306                 shc.handshakeProducers.putIfAbsent(
307                         SSLHandshake.CERTIFICATE_VERIFY.id,
308                         SSLHandshake.CERTIFICATE_VERIFY);
309             }
310         }
311     }
312 
313     /**
314      * The absence processing if a &quot;signature_algorithms&quot; extension is
315      * not present in the ClientHello handshake message.
316      */
317     private static final
318             class CHSignatureSchemesOnLoadAbsence implements HandshakeAbsence {
319         @Override
320         public void absent(ConnectionContext context,
321                 HandshakeMessage message) throws IOException {
322             // The consuming happens in server side only.
323             ServerHandshakeContext shc = (ServerHandshakeContext)context;
324 
325             // This is a mandatory extension for certificate authentication
326             // in TLS 1.3.
327             //
328             // We may support the server authentication other than X.509
329             // certificate later.
330             if (shc.negotiatedProtocol.useTLS13PlusSpec()) {
331                 throw shc.conContext.fatal(Alert.MISSING_EXTENSION,
332                     &quot;No mandatory signature_algorithms extension in the &quot; +
333                     &quot;received CertificateRequest handshake message&quot;);
334             }
335         }
336     }
337 
338     /**
339      * The absence processing if a &quot;signature_algorithms&quot; extension is
340      * not present in the ClientHello handshake message.
341      */
342     private static final
343             class CHSignatureSchemesOnTradeAbsence implements HandshakeAbsence {
344         @Override
345         public void absent(ConnectionContext context,
346                 HandshakeMessage message) throws IOException {
347             // The consuming happens in server side only.
348             ServerHandshakeContext shc = (ServerHandshakeContext)context;
349 
350             if (shc.negotiatedProtocol.useTLS12PlusSpec()) {
351                 // Use default hash and signature algorithm:
352                 //      {sha1,rsa}
353                 //      {sha1,dsa}
354                 //      {sha1,ecdsa}
355                 // Per RFC 5246, If the client supports only the default hash
356                 // and signature algorithms, it MAY omit the
357                 // signature_algorithms extension.  If the client does not
358                 // support the default algorithms, or supports other hash
359                 // and signature algorithms (and it is willing to use them
360                 // for verifying messages sent by the server, i.e., server
361                 // certificates and server key exchange), it MUST send the
362                 // signature_algorithms extension, listing the algorithms it
363                 // is willing to accept.
364                 List&lt;SignatureScheme&gt; schemes = Arrays.asList(
365                         SignatureScheme.RSA_PKCS1_SHA1,
366                         SignatureScheme.DSA_SHA1,
367                         SignatureScheme.ECDSA_SHA1
368                 );
369 
370                 shc.peerRequestedSignatureSchemes = schemes;
371                 if (shc.peerRequestedCertSignSchemes == null ||
372                         shc.peerRequestedCertSignSchemes.isEmpty()) {
373                     shc.peerRequestedCertSignSchemes = schemes;
374                 }
375 
376                 // Use the default peer signature algorithms.
377                 shc.handshakeSession.setUseDefaultPeerSignAlgs();
378             }
379         }
380     }
381 
382     /**
383      * Network data producer of a &quot;signature_algorithms&quot; extension in
384      * the CertificateRequest handshake message.
385      */
386     private static final
387             class CRSignatureSchemesProducer implements HandshakeProducer {
388         // Prevent instantiation of this class.
389         private CRSignatureSchemesProducer() {
390             // blank
391         }
392 
393         @Override
394         public byte[] produce(ConnectionContext context,
395                 HandshakeMessage message) throws IOException {
396             // The producing happens in server side only.
397             ServerHandshakeContext shc = (ServerHandshakeContext)context;
398 
399             // Is it a supported and enabled extension?
400             //
401             // Note that this is a mandatory extension for CertificateRequest
402             // handshake message in TLS 1.3.
403             if (!shc.sslConfig.isAvailable(
404                     SSLExtension.CR_SIGNATURE_ALGORITHMS)) {
405                 throw shc.conContext.fatal(Alert.MISSING_EXTENSION,
406                         &quot;No available signature_algorithms extension &quot; +
407                         &quot;for client certificate authentication&quot;);
408             }
409 
410             // Produce the extension.
411             List&lt;SignatureScheme&gt; sigAlgs =
412                     SignatureScheme.getSupportedAlgorithms(
413                             shc.algorithmConstraints,
414                             List.of(shc.negotiatedProtocol));
415 
416             int vectorLen = SignatureScheme.sizeInRecord() * sigAlgs.size();
417             byte[] extData = new byte[vectorLen + 2];
418             ByteBuffer m = ByteBuffer.wrap(extData);
419             Record.putInt16(m, vectorLen);
420             for (SignatureScheme ss : sigAlgs) {
421                 Record.putInt16(m, ss.id);
422             }
423 
424             // Update the context.
425             shc.handshakeExtensions.put(
426                     SSLExtension.CR_SIGNATURE_ALGORITHMS,
427                     new SignatureSchemesSpec(shc.localSupportedSignAlgs));
428 
429             return extData;
430         }
431     }
432 
433     /**
434      * Network data consumer of a &quot;signature_algorithms&quot; extension in
435      * the CertificateRequest handshake message.
436      */
437     private static final
438             class CRSignatureSchemesConsumer implements ExtensionConsumer {
439         // Prevent instantiation of this class.
440         private CRSignatureSchemesConsumer() {
441             // blank
442         }
443         @Override
444         public void consume(ConnectionContext context,
445             HandshakeMessage message, ByteBuffer buffer) throws IOException {
446             // The consuming happens in client side only.
447             ClientHandshakeContext chc = (ClientHandshakeContext)context;
448 
449             // Is it a supported and enabled extension?
450             //
451             // Note that this is a mandatory extension for CertificateRequest
452             // handshake message in TLS 1.3.
453             if (!chc.sslConfig.isAvailable(
454                     SSLExtension.CR_SIGNATURE_ALGORITHMS)) {
455                 throw chc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
456                         &quot;No available signature_algorithms extension &quot; +
457                         &quot;for client certificate authentication&quot;);
458             }
459 
460             // Parse the extension.
461             SignatureSchemesSpec spec;
462             try {
463                 spec = new SignatureSchemesSpec(buffer);
464             } catch (IOException ioe) {
465                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, ioe);
466             }
467 
468             List&lt;SignatureScheme&gt; knownSignatureSchemes = new LinkedList&lt;&gt;();
469             for (int id : spec.signatureSchemes) {
470                 SignatureScheme ss = SignatureScheme.valueOf(id);
471                 if (ss != null) {
472                     knownSignatureSchemes.add(ss);
473                 }
474             }
475 
476             // Update the context.
477             // chc.peerRequestedSignatureSchemes = knownSignatureSchemes;
478             chc.handshakeExtensions.put(
479                     SSLExtension.CR_SIGNATURE_ALGORITHMS, spec);
480 
481             // No impact on session resumption.
482         }
483     }
484 
485     /**
486      * After session creation consuming of a &quot;signature_algorithms&quot;
487      * extension in the CertificateRequest handshake message.
488      */
489     private static final class CRSignatureSchemesUpdate
490             implements HandshakeConsumer {
491         // Prevent instantiation of this class.
492         private CRSignatureSchemesUpdate() {
493             // blank
494         }
495 
496         @Override
497         public void consume(ConnectionContext context,
498                 HandshakeMessage message) throws IOException {
499             // The consuming happens in client side only.
500             ClientHandshakeContext chc = (ClientHandshakeContext)context;
501 
502             SignatureSchemesSpec spec =
503                     (SignatureSchemesSpec)chc.handshakeExtensions.get(
504                             SSLExtension.CR_SIGNATURE_ALGORITHMS);
505             if (spec == null) {
506                 // Ignore, no &quot;signature_algorithms&quot; extension requested.
507                 return;
508             }
509 
510             // update the context
511             List&lt;SignatureScheme&gt; sss =
512                     SignatureScheme.getSupportedAlgorithms(
513                             chc.algorithmConstraints, chc.negotiatedProtocol,
514                             spec.signatureSchemes);
515             chc.peerRequestedSignatureSchemes = sss;
516 
517             // If no &quot;signature_algorithms_cert&quot; extension is present, then
518             // the &quot;signature_algorithms&quot; extension also applies to
519             // signatures appearing in certificates.
520             SignatureSchemesSpec certSpec =
521                     (SignatureSchemesSpec)chc.handshakeExtensions.get(
522                             SSLExtension.CR_SIGNATURE_ALGORITHMS_CERT);
523             if (certSpec == null) {
524                 chc.peerRequestedCertSignSchemes = sss;
525                 chc.handshakeSession.setPeerSupportedSignatureAlgorithms(sss);
526             }
527         }
528     }
529 
530     /**
531      * The absence processing if a &quot;signature_algorithms&quot; extension is
532      * not present in the CertificateRequest handshake message.
533      */
534     private static final
535             class CRSignatureSchemesAbsence implements HandshakeAbsence {
536         @Override
537         public void absent(ConnectionContext context,
538                 HandshakeMessage message) throws IOException {
539             // The consuming happens in client side only.
540             ClientHandshakeContext chc = (ClientHandshakeContext)context;
541 
542             // This is a mandatory extension for CertificateRequest handshake
543             // message in TLS 1.3.
544             throw chc.conContext.fatal(Alert.MISSING_EXTENSION,
545                     &quot;No mandatory signature_algorithms extension in the &quot; +
546                     &quot;received CertificateRequest handshake message&quot;);
547         }
548     }
549 }
    </pre>
  </body>
</html>
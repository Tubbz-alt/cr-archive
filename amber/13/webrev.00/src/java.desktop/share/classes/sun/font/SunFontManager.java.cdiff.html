<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.desktop/share/classes/sun/font/SunFontManager.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../awt/ComponentFactory.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="TrueTypeFont.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/classes/sun/font/SunFontManager.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2008, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2008, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 37,11 ***</span>
  import java.security.PrivilegedAction;
  import java.util.ArrayList;
  import java.util.HashMap;
  import java.util.HashSet;
  import java.util.Hashtable;
<span class="line-removed">- import java.util.Iterator;</span>
  import java.util.List;
  import java.util.Locale;
  import java.util.Map;
  import java.util.NoSuchElementException;
  import java.util.StringTokenizer;
<span class="line-new-header">--- 37,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 129,29 ***</span>
          }
      }
  
      private static Font2DHandle FONT_HANDLE_NULL = new Font2DHandle(null);
  
<span class="line-modified">!      public static final int FONTFORMAT_NONE = -1;</span>
<span class="line-modified">!      public static final int FONTFORMAT_TRUETYPE = 0;</span>
<span class="line-modified">!      public static final int FONTFORMAT_TYPE1 = 1;</span>
<span class="line-modified">!      public static final int FONTFORMAT_TTC = 2;</span>
<span class="line-modified">!      public static final int FONTFORMAT_COMPOSITE = 3;</span>
<span class="line-modified">!      public static final int FONTFORMAT_NATIVE = 4;</span>
<span class="line-modified">! </span>
<span class="line-modified">!      /* Pool of 20 font file channels chosen because some UTF-8 locale</span>
<span class="line-modified">!       * composite fonts can use up to 16 platform fonts (including the</span>
<span class="line-modified">!       * Lucida fall back). This should prevent channel thrashing when</span>
<span class="line-modified">!       * dealing with one of these fonts.</span>
<span class="line-modified">!       * The pool array stores the fonts, rather than directly referencing</span>
<span class="line-modified">!       * the channels, as the font needs to do the open/close work.</span>
<span class="line-modified">!       */</span>
<span class="line-modified">!      // MACOSX begin -- need to access these in subclass</span>
<span class="line-modified">!      protected static final int CHANNELPOOLSIZE = 20;</span>
<span class="line-modified">!      protected FileFont[] fontFileCache = new FileFont[CHANNELPOOLSIZE];</span>
<span class="line-modified">!      // MACOSX end</span>
<span class="line-modified">!      private int lastPoolIndex = 0;</span>
  
      /* Need to implement a simple linked list scheme for fast
       * traversal and lookup.
       * Also want to &quot;fast path&quot; dialog so there&#39;s minimal overhead.
       */
<span class="line-new-header">--- 128,29 ---</span>
          }
      }
  
      private static Font2DHandle FONT_HANDLE_NULL = new Font2DHandle(null);
  
<span class="line-modified">!     public static final int FONTFORMAT_NONE = -1;</span>
<span class="line-modified">!     public static final int FONTFORMAT_TRUETYPE = 0;</span>
<span class="line-modified">!     public static final int FONTFORMAT_TYPE1 = 1;</span>
<span class="line-modified">!     public static final int FONTFORMAT_TTC = 2;</span>
<span class="line-modified">!     public static final int FONTFORMAT_COMPOSITE = 3;</span>
<span class="line-modified">!     public static final int FONTFORMAT_NATIVE = 4;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     /* Pool of 20 font file channels chosen because some UTF-8 locale</span>
<span class="line-modified">!      * composite fonts can use up to 16 platform fonts (including the</span>
<span class="line-modified">!      * Lucida fall back). This should prevent channel thrashing when</span>
<span class="line-modified">!      * dealing with one of these fonts.</span>
<span class="line-modified">!      * The pool array stores the fonts, rather than directly referencing</span>
<span class="line-modified">!      * the channels, as the font needs to do the open/close work.</span>
<span class="line-modified">!      */</span>
<span class="line-modified">!     // MACOSX begin -- need to access these in subclass</span>
<span class="line-modified">!     protected static final int CHANNELPOOLSIZE = 20;</span>
<span class="line-modified">!     protected FileFont[] fontFileCache = new FileFont[CHANNELPOOLSIZE];</span>
<span class="line-modified">!     // MACOSX end</span>
<span class="line-modified">!     private int lastPoolIndex = 0;</span>
  
      /* Need to implement a simple linked list scheme for fast
       * traversal and lookup.
       * Also want to &quot;fast path&quot; dialog so there&#39;s minimal overhead.
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 161,23 ***</span>
       * variants.
       */
      private int maxCompFont = 0;
      private CompositeFont [] compFonts = new CompositeFont[20];
      private ConcurrentHashMap&lt;String, CompositeFont&gt;
<span class="line-modified">!         compositeFonts = new ConcurrentHashMap&lt;String, CompositeFont&gt;();</span>
      private ConcurrentHashMap&lt;String, PhysicalFont&gt;
<span class="line-modified">!         physicalFonts = new ConcurrentHashMap&lt;String, PhysicalFont&gt;();</span>
      private ConcurrentHashMap&lt;String, PhysicalFont&gt;
<span class="line-modified">!         registeredFonts = new ConcurrentHashMap&lt;String, PhysicalFont&gt;();</span>
  
      /* given a full name find the Font. Remind: there&#39;s duplication
       * here in that this contains the content of compositeFonts +
       * physicalFonts.
       */
      // MACOSX begin -- need to access this in subclass
      protected ConcurrentHashMap&lt;String, Font2D&gt;
<span class="line-modified">!         fullNameToFont = new ConcurrentHashMap&lt;String, Font2D&gt;();</span>
      // MACOSX end
  
      /* TrueType fonts have localised names. Support searching all
       * of these before giving up on a name.
       */
<span class="line-new-header">--- 160,23 ---</span>
       * variants.
       */
      private int maxCompFont = 0;
      private CompositeFont [] compFonts = new CompositeFont[20];
      private ConcurrentHashMap&lt;String, CompositeFont&gt;
<span class="line-modified">!         compositeFonts = new ConcurrentHashMap&lt;&gt;();</span>
      private ConcurrentHashMap&lt;String, PhysicalFont&gt;
<span class="line-modified">!         physicalFonts = new ConcurrentHashMap&lt;&gt;();</span>
      private ConcurrentHashMap&lt;String, PhysicalFont&gt;
<span class="line-modified">!         registeredFonts = new ConcurrentHashMap&lt;&gt;();</span>
  
      /* given a full name find the Font. Remind: there&#39;s duplication
       * here in that this contains the content of compositeFonts +
       * physicalFonts.
       */
      // MACOSX begin -- need to access this in subclass
      protected ConcurrentHashMap&lt;String, Font2D&gt;
<span class="line-modified">!         fullNameToFont = new ConcurrentHashMap&lt;&gt;();</span>
      // MACOSX end
  
      /* TrueType fonts have localised names. Support searching all
       * of these before giving up on a name.
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 264,38 ***</span>
       * have them collected more frequently to reclaim storage.
       */
      private static int maxSoftRefCnt = 10;
  
      static {
  
<span class="line-modified">!         java.security.AccessController.doPrivileged(</span>
<span class="line-modified">!                                     new java.security.PrivilegedAction&lt;Object&gt;() {</span>
<span class="line-modified">! </span>
<span class="line-removed">-            public Object run() {</span>
<span class="line-removed">-                FontManagerNativeLibrary.load();</span>
<span class="line-removed">- </span>
<span class="line-removed">-                // JNI throws an exception if a class/method/field is not found,</span>
<span class="line-removed">-                // so there&#39;s no need to do anything explicit here.</span>
<span class="line-removed">-                initIDs();</span>
<span class="line-removed">- </span>
<span class="line-removed">-                switch (StrikeCache.nativeAddressSize) {</span>
<span class="line-removed">-                case 8: longAddresses = true; break;</span>
<span class="line-removed">-                case 4: longAddresses = false; break;</span>
<span class="line-removed">-                default: throw new RuntimeException(&quot;Unexpected address size&quot;);</span>
<span class="line-removed">-                }</span>
<span class="line-removed">- </span>
<span class="line-removed">-                noType1Font =</span>
<span class="line-removed">-                    &quot;true&quot;.equals(System.getProperty(&quot;sun.java2d.noType1Font&quot;));</span>
<span class="line-removed">-                jreLibDirName =</span>
<span class="line-removed">-                    System.getProperty(&quot;java.home&quot;,&quot;&quot;) + File.separator + &quot;lib&quot;;</span>
<span class="line-removed">-                jreFontDirName = jreLibDirName + File.separator + &quot;fonts&quot;;</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 maxSoftRefCnt =</span>
<span class="line-removed">-                     Integer.getInteger(&quot;sun.java2d.font.maxSoftRefs&quot;, 10);</span>
  
<span class="line-modified">!                return null;</span>
<span class="line-modified">!            }</span>
          });
      }
  
      /**
       * If the module image layout changes the location of JDK fonts,
<span class="line-new-header">--- 263,31 ---</span>
       * have them collected more frequently to reclaim storage.
       */
      private static int maxSoftRefCnt = 10;
  
      static {
<span class="line-added">+         AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {</span>
<span class="line-added">+             public Void run() {</span>
<span class="line-added">+                 FontManagerNativeLibrary.load();</span>
<span class="line-added">+ </span>
<span class="line-added">+                 // JNI throws an exception if a class/method/field is not found,</span>
<span class="line-added">+                 // so there&#39;s no need to do anything explicit here.</span>
<span class="line-added">+                 initIDs();</span>
<span class="line-added">+ </span>
<span class="line-added">+                 switch (StrikeCache.nativeAddressSize) {</span>
<span class="line-added">+                 case 8: longAddresses = true; break;</span>
<span class="line-added">+                 case 4: longAddresses = false; break;</span>
<span class="line-added">+                 default: throw new RuntimeException(&quot;Unexpected address size&quot;);</span>
<span class="line-added">+                 }</span>
  
<span class="line-modified">!                 noType1Font = &quot;true&quot;.equals(System.getProperty(&quot;sun.java2d.noType1Font&quot;));</span>
<span class="line-modified">!                 jreLibDirName = System.getProperty(&quot;java.home&quot;,&quot;&quot;) + File.separator + &quot;lib&quot;;</span>
<span class="line-modified">!                 jreFontDirName = jreLibDirName + File.separator + &quot;fonts&quot;;</span>
  
<span class="line-modified">!                 maxSoftRefCnt = Integer.getInteger(&quot;sun.java2d.font.maxSoftRefs&quot;, 10);</span>
<span class="line-modified">!                 return null;</span>
<span class="line-added">+             }</span>
          });
      }
  
      /**
       * If the module image layout changes the location of JDK fonts,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 311,196 ***</span>
      }
  
      /* Initialise ptrs used by JNI methods */
      private static native void initIDs();
  
<span class="line-removed">-     @SuppressWarnings(&quot;unchecked&quot;)</span>
      protected SunFontManager() {
<span class="line-modified">! </span>
<span class="line-modified">!         java.security.AccessController.doPrivileged(</span>
<span class="line-modified">!                 new java.security.PrivilegedAction&lt;Object&gt;() {</span>
<span class="line-modified">!                     public Object run() {</span>
<span class="line-modified">!                         File badFontFile =</span>
<span class="line-modified">!                             new File(jreFontDirName + File.separator +</span>
<span class="line-modified">!                                      &quot;badfonts.txt&quot;);</span>
<span class="line-modified">!                         if (badFontFile.exists()) {</span>
<span class="line-modified">!                             FileInputStream fis = null;</span>
<span class="line-modified">!                             try {</span>
<span class="line-modified">!                                 badFonts = new ArrayList&lt;&gt;();</span>
<span class="line-modified">!                                 fis = new FileInputStream(badFontFile);</span>
<span class="line-modified">!                                 InputStreamReader isr = new InputStreamReader(fis);</span>
<span class="line-modified">!                                 BufferedReader br = new BufferedReader(isr);</span>
<span class="line-modified">!                                 while (true) {</span>
<span class="line-removed">-                                     String name = br.readLine();</span>
<span class="line-removed">-                                     if (name == null) {</span>
<span class="line-removed">-                                         break;</span>
<span class="line-removed">-                                     } else {</span>
<span class="line-removed">-                                         if (FontUtilities.debugFonts()) {</span>
<span class="line-removed">-                                             FontUtilities.getLogger().warning(&quot;read bad font: &quot; +</span>
<span class="line-removed">-                                                            name);</span>
<span class="line-removed">-                                         }</span>
<span class="line-removed">-                                         badFonts.add(name);</span>
<span class="line-removed">-                                     }</span>
<span class="line-removed">-                                 }</span>
<span class="line-removed">-                             } catch (IOException e) {</span>
<span class="line-removed">-                                 try {</span>
<span class="line-removed">-                                     if (fis != null) {</span>
<span class="line-removed">-                                         fis.close();</span>
<span class="line-removed">-                                     }</span>
<span class="line-removed">-                                 } catch (IOException ioe) {</span>
                                  }
                              }
                          }
  
<span class="line-modified">!                         /* Here we get the fonts in jre/lib/fonts and register</span>
<span class="line-modified">!                          * them so they are always available and preferred over</span>
<span class="line-modified">!                          * other fonts. This needs to be registered before the</span>
<span class="line-modified">!                          * composite fonts as otherwise some native font that</span>
<span class="line-modified">!                          * corresponds may be found as we don&#39;t have a way to</span>
<span class="line-modified">!                          * handle two fonts of the same name, so the JRE one</span>
<span class="line-modified">!                          * must be the first one registered. Pass &quot;true&quot; to</span>
<span class="line-modified">!                          * registerFonts method as on-screen these JRE fonts</span>
<span class="line-modified">!                          * always go through the JDK rasteriser.</span>
<span class="line-modified">!                          */</span>
<span class="line-modified">!                         if (FontUtilities.isLinux) {</span>
<span class="line-modified">!                             /* Linux font configuration uses these fonts */</span>
<span class="line-modified">!                             registerFontDir(jreFontDirName);</span>
<span class="line-modified">!                         }</span>
<span class="line-modified">!                         registerFontsInDir(jreFontDirName, true, Font2D.JRE_RANK,</span>
<span class="line-modified">!                                            true, false);</span>
  
<span class="line-modified">!                         /* Create the font configuration and get any font path</span>
<span class="line-modified">!                          * that might be specified.</span>
<span class="line-modified">!                          */</span>
<span class="line-modified">!                         fontConfig = createFontConfiguration();</span>
<span class="line-modified">! </span>
<span class="line-modified">!                         String[] fontInfo = getDefaultPlatformFont();</span>
<span class="line-modified">!                         defaultFontName = fontInfo[0];</span>
<span class="line-modified">!                         defaultFontFileName = fontInfo[1];</span>
<span class="line-modified">! </span>
<span class="line-modified">!                         String extraFontPath = fontConfig.getExtraFontPath();</span>
<span class="line-modified">! </span>
<span class="line-modified">!                         /* In prior releases the debugging font path replaced</span>
<span class="line-modified">!                          * all normally located font directories except for the</span>
<span class="line-modified">!                          * JRE fonts dir. This directory is still always located</span>
<span class="line-modified">!                          * and placed at the head of the path but as an</span>
<span class="line-modified">!                          * augmentation to the previous behaviour the</span>
<span class="line-modified">!                          * changes below allow you to additionally append to</span>
<span class="line-modified">!                          * the font path by starting with append: or prepend by</span>
<span class="line-modified">!                          * starting with a prepend: sign. Eg: to append</span>
<span class="line-modified">!                          * -Dsun.java2d.fontpath=append:/usr/local/myfonts</span>
<span class="line-modified">!                          * and to prepend</span>
<span class="line-modified">!                          * -Dsun.java2d.fontpath=prepend:/usr/local/myfonts Disp</span>
<span class="line-modified">!                          *</span>
<span class="line-modified">!                          * If there is an appendedfontpath it in the font</span>
<span class="line-modified">!                          * configuration it is used instead of searching the</span>
<span class="line-modified">!                          * system for dirs.</span>
<span class="line-modified">!                          * The behaviour of append and prepend is then similar</span>
<span class="line-modified">!                          * to the normal case. ie it goes after what</span>
<span class="line-modified">!                          * you prepend and * before what you append. If the</span>
<span class="line-modified">!                          * sun.java2d.fontpath property is used, but it</span>
<span class="line-modified">!                          * neither the append or prepend syntaxes is used then</span>
<span class="line-modified">!                          * as except for the JRE dir the path is replaced and it</span>
<span class="line-modified">!                          * is up to you to make sure that all the right</span>
<span class="line-modified">!                          * directories are located. This is platform and</span>
<span class="line-modified">!                          * locale-specific so its almost impossible to get</span>
<span class="line-modified">!                          * right, so it should be used with caution.</span>
<span class="line-modified">!                          */</span>
<span class="line-modified">!                         boolean prependToPath = false;</span>
<span class="line-modified">!                         boolean appendToPath = false;</span>
<span class="line-modified">!                         String dbgFontPath =</span>
<span class="line-modified">!                             System.getProperty(&quot;sun.java2d.fontpath&quot;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!                         if (dbgFontPath != null) {</span>
<span class="line-modified">!                             if (dbgFontPath.startsWith(&quot;prepend:&quot;)) {</span>
<span class="line-modified">!                                 prependToPath = true;</span>
<span class="line-modified">!                                 dbgFontPath =</span>
<span class="line-modified">!                                     dbgFontPath.substring(&quot;prepend:&quot;.length());</span>
<span class="line-modified">!                             } else if (dbgFontPath.startsWith(&quot;append:&quot;)) {</span>
<span class="line-modified">!                                 appendToPath = true;</span>
<span class="line-modified">!                                 dbgFontPath =</span>
<span class="line-modified">!                                     dbgFontPath.substring(&quot;append:&quot;.length());</span>
<span class="line-modified">!                             }</span>
<span class="line-removed">-                         }</span>
  
<span class="line-modified">!                         if (FontUtilities.debugFonts()) {</span>
<span class="line-modified">!                             PlatformLogger logger = FontUtilities.getLogger();</span>
<span class="line-modified">!                             logger.info(&quot;JRE font directory: &quot; + jreFontDirName);</span>
<span class="line-modified">!                             logger.info(&quot;Extra font path: &quot; + extraFontPath);</span>
<span class="line-modified">!                             logger.info(&quot;Debug font path: &quot; + dbgFontPath);</span>
<span class="line-modified">!                         }</span>
  
<span class="line-modified">!                         if (dbgFontPath != null) {</span>
<span class="line-modified">!                             /* In debugging mode we register all the paths</span>
<span class="line-modified">!                              * Caution: this is a very expensive call on Solaris:-</span>
<span class="line-modified">!                              */</span>
<span class="line-modified">!                             fontPath = getPlatformFontPath(noType1Font);</span>
  
<span class="line-modified">!                             if (extraFontPath != null) {</span>
<span class="line-modified">!                                 fontPath =</span>
<span class="line-modified">!                                     extraFontPath + File.pathSeparator + fontPath;</span>
<span class="line-modified">!                             }</span>
<span class="line-modified">!                             if (appendToPath) {</span>
<span class="line-modified">!                                 fontPath =</span>
<span class="line-modified">!                                     fontPath + File.pathSeparator + dbgFontPath;</span>
<span class="line-modified">!                             } else if (prependToPath) {</span>
<span class="line-modified">!                                 fontPath =</span>
<span class="line-modified">!                                     dbgFontPath + File.pathSeparator + fontPath;</span>
<span class="line-modified">!                             } else {</span>
<span class="line-modified">!                                 fontPath = dbgFontPath;</span>
<span class="line-modified">!                             }</span>
<span class="line-modified">!                             registerFontDirs(fontPath);</span>
<span class="line-modified">!                         } else if (extraFontPath != null) {</span>
<span class="line-modified">!                             /* If the font configuration contains an</span>
<span class="line-modified">!                              * &quot;appendedfontpath&quot; entry, it is interpreted as a</span>
<span class="line-modified">!                              * set of locations that should always be registered.</span>
<span class="line-modified">!                              * It may be additional to locations normally found</span>
<span class="line-modified">!                              * for that place, or it may be locations that need</span>
<span class="line-modified">!                              * to have all their paths registered to locate all</span>
<span class="line-modified">!                              * the needed platform names.</span>
<span class="line-modified">!                              * This is typically when the same .TTF file is</span>
<span class="line-modified">!                              * referenced from multiple font.dir files and all</span>
<span class="line-modified">!                              * of these must be read to find all the native</span>
<span class="line-modified">!                              * (XLFD) names for the font, so that X11 font APIs</span>
<span class="line-modified">!                              * can be used for as many code points as possible.</span>
<span class="line-removed">-                              */</span>
<span class="line-removed">-                             registerFontDirs(extraFontPath);</span>
<span class="line-removed">-                         }</span>
  
<span class="line-modified">!                         /* On Solaris, we need to register the Japanese TrueType</span>
<span class="line-modified">!                          * directory so that we can find the corresponding</span>
<span class="line-modified">!                          * bitmap fonts. This could be done by listing the</span>
<span class="line-modified">!                          * directory in the font configuration file, but we</span>
<span class="line-modified">!                          * don&#39;t want to confuse users with this quirk. There</span>
<span class="line-modified">!                          * are no bitmap fonts for other writing systems that</span>
<span class="line-modified">!                          * correspond to TrueType fonts and have matching XLFDs.</span>
<span class="line-modified">!                          * We need to register the bitmap fonts only in</span>
<span class="line-modified">!                          * environments where they&#39;re on the X font path, i.e.,</span>
<span class="line-modified">!                          * in the Japanese locale. Note that if the X Toolkit</span>
<span class="line-modified">!                          * is in use the font path isn&#39;t set up by JDK, but</span>
<span class="line-modified">!                          * users of a JA locale should have it</span>
<span class="line-modified">!                          * set up already by their login environment.</span>
<span class="line-modified">!                          */</span>
<span class="line-modified">!                         if (FontUtilities.isSolaris &amp;&amp; Locale.JAPAN.equals(Locale.getDefault())) {</span>
<span class="line-modified">!                             registerFontDir(&quot;/usr/openwin/lib/locale/ja/X11/fonts/TT&quot;);</span>
<span class="line-modified">!                         }</span>
  
<span class="line-modified">!                         initCompositeFonts(fontConfig, null);</span>
  
<span class="line-modified">!                         return null;</span>
<span class="line-modified">!                     }</span>
<span class="line-modified">!                 });</span>
  
          boolean platformFont = AccessController.doPrivileged(
<span class="line-modified">!                         new PrivilegedAction&lt;Boolean&gt;() {</span>
<span class="line-modified">!                                 public Boolean run() {</span>
<span class="line-modified">!                                         String prop =</span>
<span class="line-modified">!                                                 System.getProperty(&quot;java2d.font.usePlatformFont&quot;);</span>
<span class="line-modified">!                                         String env = System.getenv(&quot;JAVA2D_USEPLATFORMFONT&quot;);</span>
<span class="line-modified">!                                         return &quot;true&quot;.equals(prop) || env != null;</span>
<span class="line-modified">!                                 }</span>
<span class="line-removed">-                         });</span>
  
          if (platformFont) {
              usePlatformFontMetrics = true;
              System.out.println(&quot;Enabling platform font metrics for win32. This is an unsupported option.&quot;);
              System.out.println(&quot;This yields incorrect composite font metrics as reported by 1.1.x releases.&quot;);
<span class="line-new-header">--- 303,177 ---</span>
      }
  
      /* Initialise ptrs used by JNI methods */
      private static native void initIDs();
  
      protected SunFontManager() {
<span class="line-modified">!         AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {</span>
<span class="line-modified">!             public Void run() {</span>
<span class="line-modified">!                 File badFontFile =</span>
<span class="line-modified">!                     new File(jreFontDirName + File.separator + &quot;badfonts.txt&quot;);</span>
<span class="line-modified">!                 if (badFontFile.exists()) {</span>
<span class="line-modified">!                     badFonts = new ArrayList&lt;&gt;();</span>
<span class="line-modified">!                     try (FileInputStream fis = new FileInputStream(badFontFile);</span>
<span class="line-modified">!                          BufferedReader br = new BufferedReader(new InputStreamReader(fis))) {</span>
<span class="line-modified">!                         while (true) {</span>
<span class="line-modified">!                             String name = br.readLine();</span>
<span class="line-modified">!                             if (name == null) {</span>
<span class="line-modified">!                                 break;</span>
<span class="line-modified">!                             } else {</span>
<span class="line-modified">!                                 if (FontUtilities.debugFonts()) {</span>
<span class="line-modified">!                                     FontUtilities.getLogger().warning(&quot;read bad font: &quot; + name);</span>
                                  }
<span class="line-added">+                                 badFonts.add(name);</span>
                              }
                          }
<span class="line-added">+                     } catch (IOException e) {</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
  
<span class="line-modified">!                 /* Here we get the fonts in jre/lib/fonts and register</span>
<span class="line-modified">!                  * them so they are always available and preferred over</span>
<span class="line-modified">!                  * other fonts. This needs to be registered before the</span>
<span class="line-modified">!                  * composite fonts as otherwise some native font that</span>
<span class="line-modified">!                  * corresponds may be found as we don&#39;t have a way to</span>
<span class="line-modified">!                  * handle two fonts of the same name, so the JRE one</span>
<span class="line-modified">!                  * must be the first one registered. Pass &quot;true&quot; to</span>
<span class="line-modified">!                  * registerFonts method as on-screen these JRE fonts</span>
<span class="line-modified">!                  * always go through the JDK rasteriser.</span>
<span class="line-modified">!                  */</span>
<span class="line-modified">!                 if (FontUtilities.isLinux) {</span>
<span class="line-modified">!                     /* Linux font configuration uses these fonts */</span>
<span class="line-modified">!                     registerFontDir(jreFontDirName);</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!                 registerFontsInDir(jreFontDirName, true, Font2D.JRE_RANK,</span>
<span class="line-modified">!                                    true, false);</span>
  
<span class="line-modified">!                 /* Create the font configuration and get any font path</span>
<span class="line-modified">!                  * that might be specified.</span>
<span class="line-modified">!                  */</span>
<span class="line-modified">!                 fontConfig = createFontConfiguration();</span>
<span class="line-modified">! </span>
<span class="line-modified">!                 String[] fontInfo = getDefaultPlatformFont();</span>
<span class="line-modified">!                 defaultFontName = fontInfo[0];</span>
<span class="line-modified">!                 defaultFontFileName = fontInfo[1];</span>
<span class="line-modified">! </span>
<span class="line-modified">!                 String extraFontPath = fontConfig.getExtraFontPath();</span>
<span class="line-modified">! </span>
<span class="line-modified">!                 /* In prior releases the debugging font path replaced</span>
<span class="line-modified">!                  * all normally located font directories except for the</span>
<span class="line-modified">!                  * JRE fonts dir. This directory is still always located</span>
<span class="line-modified">!                  * and placed at the head of the path but as an</span>
<span class="line-modified">!                  * augmentation to the previous behaviour the</span>
<span class="line-modified">!                  * changes below allow you to additionally append to</span>
<span class="line-modified">!                  * the font path by starting with append: or prepend by</span>
<span class="line-modified">!                  * starting with a prepend: sign. Eg: to append</span>
<span class="line-modified">!                  * -Dsun.java2d.fontpath=append:/usr/local/myfonts</span>
<span class="line-modified">!                  * and to prepend</span>
<span class="line-modified">!                  * -Dsun.java2d.fontpath=prepend:/usr/local/myfonts Disp</span>
<span class="line-modified">!                  *</span>
<span class="line-modified">!                  * If there is an appendedfontpath it in the font</span>
<span class="line-modified">!                  * configuration it is used instead of searching the</span>
<span class="line-modified">!                  * system for dirs.</span>
<span class="line-modified">!                  * The behaviour of append and prepend is then similar</span>
<span class="line-modified">!                  * to the normal case. ie it goes after what</span>
<span class="line-modified">!                  * you prepend and * before what you append. If the</span>
<span class="line-modified">!                  * sun.java2d.fontpath property is used, but it</span>
<span class="line-modified">!                  * neither the append or prepend syntaxes is used then</span>
<span class="line-modified">!                  * as except for the JRE dir the path is replaced and it</span>
<span class="line-modified">!                  * is up to you to make sure that all the right</span>
<span class="line-modified">!                  * directories are located. This is platform and</span>
<span class="line-modified">!                  * locale-specific so its almost impossible to get</span>
<span class="line-modified">!                  * right, so it should be used with caution.</span>
<span class="line-modified">!                  */</span>
<span class="line-modified">!                 boolean prependToPath = false;</span>
<span class="line-modified">!                 boolean appendToPath = false;</span>
<span class="line-modified">!                 String dbgFontPath = System.getProperty(&quot;sun.java2d.fontpath&quot;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!                 if (dbgFontPath != null) {</span>
<span class="line-modified">!                     if (dbgFontPath.startsWith(&quot;prepend:&quot;)) {</span>
<span class="line-modified">!                         prependToPath = true;</span>
<span class="line-modified">!                         dbgFontPath =</span>
<span class="line-modified">!                             dbgFontPath.substring(&quot;prepend:&quot;.length());</span>
<span class="line-modified">!                     } else if (dbgFontPath.startsWith(&quot;append:&quot;)) {</span>
<span class="line-modified">!                         appendToPath = true;</span>
<span class="line-modified">!                         dbgFontPath =</span>
<span class="line-modified">!                             dbgFontPath.substring(&quot;append:&quot;.length());</span>
<span class="line-modified">!                     }</span>
<span class="line-modified">!                 }</span>
  
<span class="line-modified">!                 if (FontUtilities.debugFonts()) {</span>
<span class="line-modified">!                     PlatformLogger logger = FontUtilities.getLogger();</span>
<span class="line-modified">!                     logger.info(&quot;JRE font directory: &quot; + jreFontDirName);</span>
<span class="line-modified">!                     logger.info(&quot;Extra font path: &quot; + extraFontPath);</span>
<span class="line-modified">!                     logger.info(&quot;Debug font path: &quot; + dbgFontPath);</span>
<span class="line-modified">!                 }</span>
  
<span class="line-modified">!                 if (dbgFontPath != null) {</span>
<span class="line-modified">!                     /* In debugging mode we register all the paths</span>
<span class="line-modified">!                      * Caution: this is a very expensive call on Solaris:-</span>
<span class="line-modified">!                      */</span>
<span class="line-modified">!                     fontPath = getPlatformFontPath(noType1Font);</span>
  
<span class="line-modified">!                     if (extraFontPath != null) {</span>
<span class="line-modified">!                         fontPath = extraFontPath + File.pathSeparator + fontPath;</span>
<span class="line-modified">!                     }</span>
<span class="line-modified">!                     if (appendToPath) {</span>
<span class="line-modified">!                         fontPath += File.pathSeparator + dbgFontPath;</span>
<span class="line-modified">!                     } else if (prependToPath) {</span>
<span class="line-modified">!                         fontPath = dbgFontPath + File.pathSeparator + fontPath;</span>
<span class="line-modified">!                     } else {</span>
<span class="line-modified">!                         fontPath = dbgFontPath;</span>
<span class="line-modified">!                     }</span>
<span class="line-modified">!                     registerFontDirs(fontPath);</span>
<span class="line-modified">!                 } else if (extraFontPath != null) {</span>
<span class="line-modified">!                     /* If the font configuration contains an</span>
<span class="line-modified">!                      * &quot;appendedfontpath&quot; entry, it is interpreted as a</span>
<span class="line-modified">!                      * set of locations that should always be registered.</span>
<span class="line-modified">!                      * It may be additional to locations normally found</span>
<span class="line-modified">!                      * for that place, or it may be locations that need</span>
<span class="line-modified">!                      * to have all their paths registered to locate all</span>
<span class="line-modified">!                      * the needed platform names.</span>
<span class="line-modified">!                      * This is typically when the same .TTF file is</span>
<span class="line-modified">!                      * referenced from multiple font.dir files and all</span>
<span class="line-modified">!                      * of these must be read to find all the native</span>
<span class="line-modified">!                      * (XLFD) names for the font, so that X11 font APIs</span>
<span class="line-modified">!                      * can be used for as many code points as possible.</span>
<span class="line-modified">!                      */</span>
<span class="line-modified">!                     registerFontDirs(extraFontPath);</span>
<span class="line-modified">!                 }</span>
  
<span class="line-modified">!                 /* On Solaris, we need to register the Japanese TrueType</span>
<span class="line-modified">!                  * directory so that we can find the corresponding</span>
<span class="line-modified">!                  * bitmap fonts. This could be done by listing the</span>
<span class="line-modified">!                  * directory in the font configuration file, but we</span>
<span class="line-modified">!                  * don&#39;t want to confuse users with this quirk. There</span>
<span class="line-modified">!                  * are no bitmap fonts for other writing systems that</span>
<span class="line-modified">!                  * correspond to TrueType fonts and have matching XLFDs.</span>
<span class="line-modified">!                  * We need to register the bitmap fonts only in</span>
<span class="line-modified">!                  * environments where they&#39;re on the X font path, i.e.,</span>
<span class="line-modified">!                  * in the Japanese locale. Note that if the X Toolkit</span>
<span class="line-modified">!                  * is in use the font path isn&#39;t set up by JDK, but</span>
<span class="line-modified">!                  * users of a JA locale should have it</span>
<span class="line-modified">!                  * set up already by their login environment.</span>
<span class="line-modified">!                  */</span>
<span class="line-modified">!                 if (FontUtilities.isSolaris &amp;&amp; Locale.JAPAN.equals(Locale.getDefault())) {</span>
<span class="line-modified">!                     registerFontDir(&quot;/usr/openwin/lib/locale/ja/X11/fonts/TT&quot;);</span>
<span class="line-modified">!                 }</span>
  
<span class="line-modified">!                 initCompositeFonts(fontConfig, null);</span>
  
<span class="line-modified">!                 return null;</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!         });</span>
  
          boolean platformFont = AccessController.doPrivileged(
<span class="line-modified">!             new PrivilegedAction&lt;Boolean&gt;() {</span>
<span class="line-modified">!                     public Boolean run() {</span>
<span class="line-modified">!                         String prop = System.getProperty(&quot;java2d.font.usePlatformFont&quot;);</span>
<span class="line-modified">!                         String env = System.getenv(&quot;JAVA2D_USEPLATFORMFONT&quot;);</span>
<span class="line-modified">!                         return &quot;true&quot;.equals(prop) || env != null;</span>
<span class="line-modified">!                     }</span>
<span class="line-modified">!             });</span>
  
          if (platformFont) {
              usePlatformFontMetrics = true;
              System.out.println(&quot;Enabling platform font metrics for win32. This is an unsupported option.&quot;);
              System.out.println(&quot;This yields incorrect composite font metrics as reported by 1.1.x releases.&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 820,14 ***</span>
              this.fontRank = rank;
          }
      }
  
      private final ConcurrentHashMap&lt;String, FontRegistrationInfo&gt;
<span class="line-modified">!         deferredFontFiles =</span>
<span class="line-removed">-         new ConcurrentHashMap&lt;String, FontRegistrationInfo&gt;();</span>
      private final ConcurrentHashMap&lt;String, Font2DHandle&gt;
<span class="line-modified">!         initialisedFonts = new ConcurrentHashMap&lt;String, Font2DHandle&gt;();</span>
  
      /* Remind: possibly enhance initialiseDeferredFonts() to be
       * optionally given a name and a style and it could stop when it
       * finds that font - but this would be a problem if two of the
       * fonts reference the same font face name (cf the Solaris
<span class="line-new-header">--- 793,13 ---</span>
              this.fontRank = rank;
          }
      }
  
      private final ConcurrentHashMap&lt;String, FontRegistrationInfo&gt;
<span class="line-modified">!         deferredFontFiles = new ConcurrentHashMap&lt;&gt;();</span>
      private final ConcurrentHashMap&lt;String, Font2DHandle&gt;
<span class="line-modified">!         initialisedFonts = new ConcurrentHashMap&lt;&gt;();</span>
  
      /* Remind: possibly enhance initialiseDeferredFonts() to be
       * optionally given a name and a style and it could stop when it
       * finds that font - but this would be a problem if two of the
       * fonts reference the same font face name (cf the Solaris
</pre>
<hr />
<pre>
<span class="line-old-header">*** 865,15 ***</span>
          if (noOtherJREFontFiles) {
              return null;
          }
          synchronized (jreFontDirName) {
              if (jreOtherFontFiles == null) {
<span class="line-modified">!                 HashSet&lt;String&gt; otherFontFiles = new HashSet&lt;String&gt;();</span>
                  for (String deferredFile : deferredFontFiles.keySet()) {
                      File file = new File(deferredFile);
                      String dir = file.getParent();
<span class="line-removed">-                     String fname = file.getName();</span>
                      /* skip names which aren&#39;t absolute, aren&#39;t in the JRE
                       * directory, or are known Lucida fonts.
                       */
                      if (dir == null || !dir.equals(jreFontDirName)) {
                          continue;
<span class="line-new-header">--- 837,14 ---</span>
          if (noOtherJREFontFiles) {
              return null;
          }
          synchronized (jreFontDirName) {
              if (jreOtherFontFiles == null) {
<span class="line-modified">!                 HashSet&lt;String&gt; otherFontFiles = new HashSet&lt;&gt;();</span>
                  for (String deferredFile : deferredFontFiles.keySet()) {
                      File file = new File(deferredFile);
                      String dir = file.getParent();
                      /* skip names which aren&#39;t absolute, aren&#39;t in the JRE
                       * directory, or are known Lucida fonts.
                       */
                      if (dir == null || !dir.equals(jreFontDirName)) {
                          continue;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1004,12 ***</span>
              return regFont;
          }
  
          PhysicalFont physicalFont = null;
          try {
<span class="line-removed">-             String name;</span>
<span class="line-removed">- </span>
              switch (fontFormat) {
  
              case FONTFORMAT_TRUETYPE:
                  int fn = 0;
                  TrueTypeFont ttf;
<span class="line-new-header">--- 975,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1171,12 ***</span>
          if (noType1) {
              filter = ttFilter;
          } else {
              filter = new TTorT1Filter();
          }
<span class="line-modified">!         return (String[])AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() {</span>
<span class="line-modified">!             public Object run() {</span>
                  if (pathDirs.length == 1) {
                      File dir = new File(pathDirs[0]);
                      String[] files = dir.list(filter);
                      if (files == null) {
                          return new String[0];
<span class="line-new-header">--- 1140,12 ---</span>
          if (noType1) {
              filter = ttFilter;
          } else {
              filter = new TTorT1Filter();
          }
<span class="line-modified">!         return AccessController.doPrivileged(new PrivilegedAction&lt;String[]&gt;() {</span>
<span class="line-modified">!             public String[] run() {</span>
                  if (pathDirs.length == 1) {
                      File dir = new File(pathDirs[0]);
                      String[] files = dir.list(filter);
                      if (files == null) {
                          return new String[0];
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1184,18 ***</span>
                      for (int f=0; f&lt;files.length; f++) {
                          files[f] = files[f].toLowerCase();
                      }
                      return files;
                  } else {
<span class="line-modified">!                     ArrayList&lt;String&gt; fileList = new ArrayList&lt;String&gt;();</span>
                      for (int i = 0; i&lt; pathDirs.length; i++) {
                          File dir = new File(pathDirs[i]);
                          String[] files = dir.list(filter);
                          if (files == null) {
                              continue;
                          }
<span class="line-modified">!                         for (int f=0; f&lt;files.length ; f++) {</span>
                              fileList.add(files[f].toLowerCase());
                          }
                      }
                      return fileList.toArray(STR_ARRAY);
                  }
<span class="line-new-header">--- 1153,18 ---</span>
                      for (int f=0; f&lt;files.length; f++) {
                          files[f] = files[f].toLowerCase();
                      }
                      return files;
                  } else {
<span class="line-modified">!                     ArrayList&lt;String&gt; fileList = new ArrayList&lt;&gt;();</span>
                      for (int i = 0; i&lt; pathDirs.length; i++) {
                          File dir = new File(pathDirs[i]);
                          String[] files = dir.list(filter);
                          if (files == null) {
                              continue;
                          }
<span class="line-modified">!                         for (int f = 0; f &lt; files.length ; f++) {</span>
                              fileList.add(files[f].toLowerCase());
                          }
                      }
                      return fileList.toArray(STR_ARRAY);
                  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1248,19 ***</span>
                          fontToFileMap.remove(&quot;david regular&quot;);
                          fontToFileMap.put(&quot;david&quot;, file);
                      }
                  } else {
                      if (unmappedFontNames == null) {
<span class="line-modified">!                         unmappedFontNames = new ArrayList&lt;String&gt;();</span>
                      }
                      unmappedFontNames.add(font);
                  }
              }
          }
  
          if (unmappedFontNames != null) {
<span class="line-modified">!             HashSet&lt;String&gt; unmappedFontFiles = new HashSet&lt;String&gt;();</span>
  
              /* Every font key in fontToFileMap ought to correspond to a
               * font key in fontToFamilyNameMap. Entries that don&#39;t seem
               * to correspond are likely fonts that were named differently
               * by GDI than in the registry. One known cause of this is when
<span class="line-new-header">--- 1217,19 ---</span>
                          fontToFileMap.remove(&quot;david regular&quot;);
                          fontToFileMap.put(&quot;david&quot;, file);
                      }
                  } else {
                      if (unmappedFontNames == null) {
<span class="line-modified">!                         unmappedFontNames = new ArrayList&lt;&gt;();</span>
                      }
                      unmappedFontNames.add(font);
                  }
              }
          }
  
          if (unmappedFontNames != null) {
<span class="line-modified">!             HashSet&lt;String&gt; unmappedFontFiles = new HashSet&lt;&gt;();</span>
  
              /* Every font key in fontToFileMap ought to correspond to a
               * font key in fontToFamilyNameMap. Entries that don&#39;t seem
               * to correspond are likely fonts that were named differently
               * by GDI than in the registry. One known cause of this is when
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1311,11 ***</span>
  
                  /* getFontFilesFromPath() returns all lower case names.
                   * To compare we also need lower case
                   * versions of the names from the registry.
                   */
<span class="line-modified">!                 ArrayList&lt;String&gt; registryFiles = new ArrayList&lt;String&gt;();</span>
  
                  for (String regFile : fontToFileMap.values()) {
                      registryFiles.add(regFile.toLowerCase());
                  }
                  /* We don&#39;t look for Type1 files here as windows will
<span class="line-new-header">--- 1280,11 ---</span>
  
                  /* getFontFilesFromPath() returns all lower case names.
                   * To compare we also need lower case
                   * versions of the names from the registry.
                   */
<span class="line-modified">!                 ArrayList&lt;String&gt; registryFiles = new ArrayList&lt;&gt;();</span>
  
                  for (String regFile : fontToFileMap.values()) {
                      registryFiles.add(regFile.toLowerCase());
                  }
                  /* We don&#39;t look for Type1 files here as windows will
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1380,11 ***</span>
          }
          /* getFontFilesFromPath() returns all lower case names.
           * To compare we also need lower case
           * versions of the names from the registry.
           */
<span class="line-modified">!         ArrayList&lt;String&gt; registryFiles = new ArrayList&lt;String&gt;();</span>
          for (String regFile : fontToFileMap.values()) {
              registryFiles.add(regFile.toLowerCase());
          }
  
          /* To avoid any issues with concurrent modification, create
<span class="line-new-header">--- 1349,11 ---</span>
          }
          /* getFontFilesFromPath() returns all lower case names.
           * To compare we also need lower case
           * versions of the names from the registry.
           */
<span class="line-modified">!         ArrayList&lt;String&gt; registryFiles = new ArrayList&lt;&gt;();</span>
          for (String regFile : fontToFileMap.values()) {
              registryFiles.add(regFile.toLowerCase());
          }
  
          /* To avoid any issues with concurrent modification, create
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1407,26 ***</span>
                  PhysicalFont f = registerFontFile(getPathName(pathFile));
                  if (f == null) {
                      continue;
                  }
                  if (fontToFileMap2 == null) {
<span class="line-modified">!                     fontToFileMap2 = new HashMap&lt;String,String&gt;(fontToFileMap);</span>
<span class="line-modified">!                     fontToFamilyNameMap2 =</span>
<span class="line-modified">!                         new HashMap&lt;String,String&gt;(fontToFamilyNameMap);</span>
<span class="line-removed">-                     familyToFontListMap2 = new</span>
<span class="line-removed">-                         HashMap&lt;String,ArrayList&lt;String&gt;&gt;(familyToFontListMap);</span>
                  }
                  String fontName = f.getFontName(null);
                  String family = f.getFamilyName(null);
                  String familyLC = family.toLowerCase();
                  fontToFamilyNameMap2.put(fontName, family);
                  fontToFileMap2.put(fontName, pathFile);
                  ArrayList&lt;String&gt; fonts = familyToFontListMap2.get(familyLC);
                  if (fonts == null) {
<span class="line-modified">!                     fonts = new ArrayList&lt;String&gt;();</span>
                  } else {
<span class="line-modified">!                     fonts = new ArrayList&lt;String&gt;(fonts);</span>
                  }
                  fonts.add(fontName);
                  familyToFontListMap2.put(familyLC, fonts);
              }
          }
<span class="line-new-header">--- 1376,24 ---</span>
                  PhysicalFont f = registerFontFile(getPathName(pathFile));
                  if (f == null) {
                      continue;
                  }
                  if (fontToFileMap2 == null) {
<span class="line-modified">!                     fontToFileMap2 = new HashMap&lt;&gt;(fontToFileMap);</span>
<span class="line-modified">!                     fontToFamilyNameMap2 = new HashMap&lt;&gt;(fontToFamilyNameMap);</span>
<span class="line-modified">!                     familyToFontListMap2 = new HashMap&lt;&gt;(familyToFontListMap);</span>
                  }
                  String fontName = f.getFontName(null);
                  String family = f.getFamilyName(null);
                  String familyLC = family.toLowerCase();
                  fontToFamilyNameMap2.put(fontName, family);
                  fontToFileMap2.put(fontName, pathFile);
                  ArrayList&lt;String&gt; fonts = familyToFontListMap2.get(familyLC);
                  if (fonts == null) {
<span class="line-modified">!                     fonts = new ArrayList&lt;&gt;();</span>
                  } else {
<span class="line-modified">!                     fonts = new ArrayList&lt;&gt;(fonts);</span>
                  }
                  fonts.add(fontName);
                  familyToFontListMap2.put(familyLC, fonts);
              }
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1500,11 ***</span>
  
      /**
       * default implementation does nothing.
       */
      public HashMap&lt;String, FamilyDescription&gt; populateHardcodedFileNameMap() {
<span class="line-modified">!         return new HashMap&lt;String, FamilyDescription&gt;(0);</span>
      }
  
      Font2D findFontFromPlatformMap(String lcName, int style) {
          if (platformFontMap == null) {
              platformFontMap = populateHardcodedFileNameMap();
<span class="line-new-header">--- 1467,11 ---</span>
  
      /**
       * default implementation does nothing.
       */
      public HashMap&lt;String, FamilyDescription&gt; populateHardcodedFileNameMap() {
<span class="line-modified">!         return new HashMap&lt;&gt;(0);</span>
      }
  
      Font2D findFontFromPlatformMap(String lcName, int style) {
          if (platformFontMap == null) {
              platformFontMap = populateHardcodedFileNameMap();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1595,25 ***</span>
  
          /* Some of these may be null,as not all styles have to exist */
          final String[] files = {
              plainFile, boldFile, italicFile, boldItalicFile } ;
  
<span class="line-modified">!         failure = java.security.AccessController.doPrivileged(</span>
<span class="line-modified">!                  new java.security.PrivilegedAction&lt;Boolean&gt;() {</span>
<span class="line-modified">!                      public Boolean run() {</span>
<span class="line-modified">!                          for (int i=0; i&lt;files.length; i++) {</span>
<span class="line-modified">!                              if (files[i] == null) {</span>
<span class="line-removed">-                                  continue;</span>
<span class="line-removed">-                              }</span>
<span class="line-removed">-                              File f = new File(files[i]);</span>
<span class="line-removed">-                              if (!f.exists()) {</span>
<span class="line-removed">-                                  return Boolean.TRUE;</span>
<span class="line-removed">-                              }</span>
<span class="line-removed">-                          }</span>
<span class="line-removed">-                          return Boolean.FALSE;</span>
                       }
<span class="line-modified">!                  });</span>
  
          if (failure) {
              if (FontUtilities.isLogging()) {
                  FontUtilities.getLogger().
                      info(&quot;Hardcoded file missing looking for &quot; + lcName);
<span class="line-new-header">--- 1562,24 ---</span>
  
          /* Some of these may be null,as not all styles have to exist */
          final String[] files = {
              plainFile, boldFile, italicFile, boldItalicFile } ;
  
<span class="line-modified">!         failure = AccessController.doPrivileged(new PrivilegedAction&lt;Boolean&gt;() {</span>
<span class="line-modified">!              public Boolean run() {</span>
<span class="line-modified">!                  for (int i=0; i&lt;files.length; i++) {</span>
<span class="line-modified">!                      if (files[i] == null) {</span>
<span class="line-modified">!                          continue;</span>
                       }
<span class="line-modified">!                      File f = new File(files[i]);</span>
<span class="line-added">+                      if (!f.exists()) {</span>
<span class="line-added">+                          return Boolean.TRUE;</span>
<span class="line-added">+                      }</span>
<span class="line-added">+                  }</span>
<span class="line-added">+                  return Boolean.FALSE;</span>
<span class="line-added">+              }</span>
<span class="line-added">+          });</span>
  
          if (failure) {
              if (FontUtilities.isLogging()) {
                  FontUtilities.getLogger().
                      info(&quot;Hardcoded file missing looking for &quot; + lcName);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1675,13 ***</span>
      private synchronized HashMap&lt;String,String&gt; getFullNameToFileMap() {
          if (fontToFileMap == null) {
  
              pathDirs = getPlatformFontDirs(noType1Font);
  
<span class="line-modified">!             fontToFileMap = new HashMap&lt;String,String&gt;(100);</span>
<span class="line-modified">!             fontToFamilyNameMap = new HashMap&lt;String,String&gt;(100);</span>
<span class="line-modified">!             familyToFontListMap = new HashMap&lt;String,ArrayList&lt;String&gt;&gt;(50);</span>
              populateFontFileNameMap(fontToFileMap,
                                      fontToFamilyNameMap,
                                      familyToFontListMap,
                                      Locale.ENGLISH);
              if (FontUtilities.isWindows) {
<span class="line-new-header">--- 1641,13 ---</span>
      private synchronized HashMap&lt;String,String&gt; getFullNameToFileMap() {
          if (fontToFileMap == null) {
  
              pathDirs = getPlatformFontDirs(noType1Font);
  
<span class="line-modified">!             fontToFileMap = new HashMap&lt;&gt;(100);</span>
<span class="line-modified">!             fontToFamilyNameMap = new HashMap&lt;&gt;(100);</span>
<span class="line-modified">!             familyToFontListMap = new HashMap&lt;&gt;(50);</span>
              populateFontFileNameMap(fontToFileMap,
                                      fontToFamilyNameMap,
                                      familyToFontListMap,
                                      Locale.ENGLISH);
              if (FontUtilities.isWindows) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1718,11 ***</span>
              return null;
          }
          checkForUnreferencedFontFiles();
          /* This odd code with TreeMap is used to preserve a historical
           * behaviour wrt the sorting order .. */
<span class="line-modified">!         ArrayList&lt;String&gt; fontNames = new ArrayList&lt;String&gt;();</span>
          for (ArrayList&lt;String&gt; a : familyToFontListMap.values()) {
              for (String s : a) {
                  fontNames.add(s);
              }
          }
<span class="line-new-header">--- 1684,11 ---</span>
              return null;
          }
          checkForUnreferencedFontFiles();
          /* This odd code with TreeMap is used to preserve a historical
           * behaviour wrt the sorting order .. */
<span class="line-modified">!         ArrayList&lt;String&gt; fontNames = new ArrayList&lt;&gt;();</span>
          for (ArrayList&lt;String&gt; a : familyToFontListMap.values()) {
              for (String s : a) {
                  fontNames.add(s);
              }
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1797,14 ***</span>
          if (f.isAbsolute()) {
              return s;
          } else if (pathDirs.length==1) {
              return pathDirs[0] + File.separator + s;
          } else {
<span class="line-modified">!             String path = java.security.AccessController.doPrivileged(</span>
<span class="line-modified">!                  new java.security.PrivilegedAction&lt;String&gt;() {</span>
                       public String run() {
<span class="line-modified">!                          for (int p=0; p&lt;pathDirs.length; p++) {</span>
                               File f = new File(pathDirs[p] +File.separator+ s);
                               if (f.exists()) {
                                   return f.getAbsolutePath();
                               }
                           }
<span class="line-new-header">--- 1763,14 ---</span>
          if (f.isAbsolute()) {
              return s;
          } else if (pathDirs.length==1) {
              return pathDirs[0] + File.separator + s;
          } else {
<span class="line-modified">!             String path = AccessController.doPrivileged(</span>
<span class="line-modified">!                  new PrivilegedAction&lt;String&gt;() {</span>
                       public String run() {
<span class="line-modified">!                          for (int p = 0; p &lt; pathDirs.length; p++) {</span>
                               File f = new File(pathDirs[p] +File.separator+ s);
                               if (f.exists()) {
                                   return f.getAbsolutePath();
                               }
                           }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1928,11 ***</span>
          }
          return font;
      }
  
      private ConcurrentHashMap&lt;String, Font2D&gt; fontNameCache =
<span class="line-modified">!         new ConcurrentHashMap&lt;String, Font2D&gt;();</span>
  
      /*
       * The client supplies a name and a style.
       * The name could be a family name, or a full name.
       * A font may exist with the specified style, or it may
<span class="line-new-header">--- 1894,11 ---</span>
          }
          return font;
      }
  
      private ConcurrentHashMap&lt;String, Font2D&gt; fontNameCache =
<span class="line-modified">!         new ConcurrentHashMap&lt;&gt;();</span>
  
      /*
       * The client supplies a name and a style.
       * The name could be a family name, or a full name.
       * A font may exist with the specified style, or it may
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2298,11 ***</span>
  
      public Font2D[] createFont2D(File fontFile, int fontFormat, boolean all,
                                   boolean isCopy, CreatedFontTracker tracker)
      throws FontFormatException {
  
<span class="line-modified">!         List&lt;Font2D&gt; fList = new ArrayList&lt;Font2D&gt;();</span>
          int cnt = 1;
          String fontFilePath = fontFile.getPath();
          FileFont font2D = null;
          final File fFile = fontFile;
          final CreatedFontTracker _tracker = tracker;
<span class="line-new-header">--- 2264,11 ---</span>
  
      public Font2D[] createFont2D(File fontFile, int fontFormat, boolean all,
                                   boolean isCopy, CreatedFontTracker tracker)
      throws FontFormatException {
  
<span class="line-modified">!         List&lt;Font2D&gt; fList = new ArrayList&lt;&gt;();</span>
          int cnt = 1;
          String fontFilePath = fontFile.getPath();
          FileFont font2D = null;
          final File fFile = fontFile;
          final CreatedFontTracker _tracker = tracker;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2341,19 ***</span>
              default:
                  throw new FontFormatException(&quot;Unrecognised Font Format&quot;);
              }
          } catch (FontFormatException e) {
              if (isCopy) {
<span class="line-modified">!                 java.security.AccessController.doPrivileged(</span>
<span class="line-modified">!                      new java.security.PrivilegedAction&lt;Object&gt;() {</span>
<span class="line-modified">!                           public Object run() {</span>
<span class="line-modified">!                               if (_tracker != null) {</span>
<span class="line-modified">!                                   _tracker.subBytes((int)fFile.length());</span>
<span class="line-modified">!                               }</span>
<span class="line-modified">!                               fFile.delete();</span>
<span class="line-modified">!                               return null;</span>
<span class="line-removed">-                           }</span>
                  });
              }
              throw(e);
          }
          if (isCopy) {
<span class="line-new-header">--- 2307,18 ---</span>
              default:
                  throw new FontFormatException(&quot;Unrecognised Font Format&quot;);
              }
          } catch (FontFormatException e) {
              if (isCopy) {
<span class="line-modified">!                 AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {</span>
<span class="line-modified">!                     public Void run() {</span>
<span class="line-modified">!                         if (_tracker != null) {</span>
<span class="line-modified">!                             _tracker.subBytes((int)fFile.length());</span>
<span class="line-modified">!                         }</span>
<span class="line-modified">!                         fFile.delete();</span>
<span class="line-modified">!                         return null;</span>
<span class="line-modified">!                     }</span>
                  });
              }
              throw(e);
          }
          if (isCopy) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2365,39 ***</span>
                  }
                  tmpFontFiles.add(fontFile);
  
                  if (fileCloser == null) {
                      final Runnable fileCloserRunnable = new Runnable() {
<span class="line-modified">!                       public void run() {</span>
<span class="line-modified">!                          java.security.AccessController.doPrivileged(</span>
<span class="line-modified">!                          new java.security.PrivilegedAction&lt;Object&gt;() {</span>
<span class="line-modified">!                          public Object run() {</span>
<span class="line-modified">! </span>
<span class="line-modified">!                             for (int i=0;i&lt;CHANNELPOOLSIZE;i++) {</span>
<span class="line-modified">!                                 if (fontFileCache[i] != null) {</span>
<span class="line-modified">!                                     try {</span>
<span class="line-modified">!                                         fontFileCache[i].close();</span>
<span class="line-modified">!                                     } catch (Exception e) {</span>
                                      }
<span class="line-modified">!                                 }</span>
<span class="line-modified">!                             }</span>
<span class="line-modified">!                             if (tmpFontFiles != null) {</span>
<span class="line-modified">!                                 File[] files = new File[tmpFontFiles.size()];</span>
<span class="line-modified">!                                 files = tmpFontFiles.toArray(files);</span>
<span class="line-modified">!                                 for (int f=0; f&lt;files.length;f++) {</span>
<span class="line-modified">!                                     try {</span>
<span class="line-modified">!                                         files[f].delete();</span>
<span class="line-modified">!                                     } catch (Exception e) {</span>
                                      }
                                  }
<span class="line-modified">!                             }</span>
<span class="line-modified">! </span>
<span class="line-removed">-                             return null;</span>
<span class="line-removed">-                           }</span>
<span class="line-removed">- </span>
<span class="line-removed">-                           });</span>
<span class="line-removed">-                       }</span>
                      };
                      AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
                          ThreadGroup rootTG = ThreadGroupUtils.getRootThreadGroup();
                          fileCloser = new Thread(rootTG, fileCloserRunnable,
                                                  &quot;FileCloser&quot;, 0, false);
<span class="line-new-header">--- 2330,35 ---</span>
                  }
                  tmpFontFiles.add(fontFile);
  
                  if (fileCloser == null) {
                      final Runnable fileCloserRunnable = new Runnable() {
<span class="line-modified">!                         public void run() {</span>
<span class="line-modified">!                             AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {</span>
<span class="line-modified">!                                 public Void run() {</span>
<span class="line-modified">!                                     for (int i = 0;i &lt; CHANNELPOOLSIZE; i++) {</span>
<span class="line-modified">!                                         if (fontFileCache[i] != null) {</span>
<span class="line-modified">!                                             try {</span>
<span class="line-modified">!                                                 fontFileCache[i].close();</span>
<span class="line-modified">!                                             } catch (Exception e) {</span>
<span class="line-modified">!                                             }</span>
<span class="line-modified">!                                         }</span>
                                      }
<span class="line-modified">!                                     if (tmpFontFiles != null) {</span>
<span class="line-modified">!                                         File[] files = new File[tmpFontFiles.size()];</span>
<span class="line-modified">!                                         files = tmpFontFiles.toArray(files);</span>
<span class="line-modified">!                                         for (int f=0; f&lt;files.length;f++) {</span>
<span class="line-modified">!                                             try {</span>
<span class="line-modified">!                                                 files[f].delete();</span>
<span class="line-modified">!                                             } catch (Exception e) {</span>
<span class="line-modified">!                                             }</span>
<span class="line-modified">!                                         }</span>
                                      }
<span class="line-added">+                                     return null;</span>
                                  }
<span class="line-modified">!                             });</span>
<span class="line-modified">!                         }</span>
                      };
                      AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
                          ThreadGroup rootTG = ThreadGroupUtils.getRootThreadGroup();
                          fileCloser = new Thread(rootTG, fileCloserRunnable,
                                                  &quot;FileCloser&quot;, 0, false);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2553,11 ***</span>
  
      private synchronized void loadLocaleNames() {
          if (localeFullNamesToFont != null) {
              return;
          }
<span class="line-modified">!         localeFullNamesToFont = new HashMap&lt;String, TrueTypeFont&gt;();</span>
          Font2D[] fonts = getRegisteredFonts();
          for (int i=0; i&lt;fonts.length; i++) {
              if (fonts[i] instanceof TrueTypeFont) {
                  TrueTypeFont ttf = (TrueTypeFont)fonts[i];
                  String[] fullNames = ttf.getAllFullNames();
<span class="line-new-header">--- 2514,11 ---</span>
  
      private synchronized void loadLocaleNames() {
          if (localeFullNamesToFont != null) {
              return;
          }
<span class="line-modified">!         localeFullNamesToFont = new HashMap&lt;&gt;();</span>
          Font2D[] fonts = getRegisteredFonts();
          for (int i=0; i&lt;fonts.length; i++) {
              if (fonts[i] instanceof TrueTypeFont) {
                  TrueTypeFont ttf = (TrueTypeFont)fonts[i];
                  String[] fullNames = ttf.getAllFullNames();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2773,11 ***</span>
             Locale l = getSystemStartupLocale();
             SunFontManager fontManager = SunFontManager.getInstance();
             String[] installedFamilies =
                 fontManager.getInstalledFontFamilyNames(l);
             Font[] installedFonts = fontManager.getAllInstalledFonts();
<span class="line-modified">!            HashSet&lt;String&gt; names = new HashSet&lt;String&gt;();</span>
             for (int i=0; i&lt;installedFamilies.length; i++) {
                 names.add(installedFamilies[i].toLowerCase(l));
             }
             for (int i=0; i&lt;installedFonts.length; i++) {
                 names.add(installedFonts[i].getFontName(l).toLowerCase(l));
<span class="line-new-header">--- 2734,11 ---</span>
             Locale l = getSystemStartupLocale();
             SunFontManager fontManager = SunFontManager.getInstance();
             String[] installedFamilies =
                 fontManager.getInstalledFontFamilyNames(l);
             Font[] installedFonts = fontManager.getAllInstalledFonts();
<span class="line-modified">!            HashSet&lt;String&gt; names = new HashSet&lt;&gt;();</span>
             for (int i=0; i&lt;installedFamilies.length; i++) {
                 names.add(installedFamilies[i].toLowerCase(l));
             }
             for (int i=0; i&lt;installedFonts.length; i++) {
                 names.add(installedFonts[i].getFontName(l).toLowerCase(l));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2935,11 ***</span>
          }
  
          String path = getPlatformFontPath(noType1Fonts);
          StringTokenizer parser =
              new StringTokenizer(path, File.pathSeparator);
<span class="line-modified">!         ArrayList&lt;String&gt; pathList = new ArrayList&lt;String&gt;();</span>
          try {
              while (parser.hasMoreTokens()) {
                  pathList.add(parser.nextToken());
              }
          } catch (NoSuchElementException e) {
<span class="line-new-header">--- 2896,11 ---</span>
          }
  
          String path = getPlatformFontPath(noType1Fonts);
          StringTokenizer parser =
              new StringTokenizer(path, File.pathSeparator);
<span class="line-modified">!         ArrayList&lt;String&gt; pathList = new ArrayList&lt;&gt;();</span>
          try {
              while (parser.hasMoreTokens()) {
                  pathList.add(parser.nextToken());
              }
          } catch (NoSuchElementException e) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3065,13 ***</span>
                  FontUtilities.getLogger()
                              .info(&quot;SunGraphicsEnvironment.loadFonts() called&quot;);
              }
              initialiseDeferredFonts();
  
<span class="line-modified">!             java.security.AccessController.doPrivileged(</span>
<span class="line-modified">!                                     new java.security.PrivilegedAction&lt;Object&gt;() {</span>
<span class="line-removed">-                 public Object run() {</span>
                      if (fontPath == null) {
                          fontPath = getPlatformFontPath(noType1Font);
                          registerFontDirs(fontPath);
                      }
                      if (fontPath != null) {
<span class="line-new-header">--- 3026,12 ---</span>
                  FontUtilities.getLogger()
                              .info(&quot;SunGraphicsEnvironment.loadFonts() called&quot;);
              }
              initialiseDeferredFonts();
  
<span class="line-modified">!             AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {</span>
<span class="line-modified">!                 public Void run() {</span>
                      if (fontPath == null) {
                          fontPath = getPlatformFontPath(noType1Font);
                          registerFontDirs(fontPath);
                      }
                      if (fontPath != null) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3182,13 ***</span>
          synchronized (this) {
              if (FontUtilities.debugFonts()) {
                  Thread.dumpStack();
                  FontUtilities.getLogger().info(&quot;loadAllFontFiles() called&quot;);
              }
<span class="line-modified">!             java.security.AccessController.doPrivileged(</span>
<span class="line-modified">!                                     new java.security.PrivilegedAction&lt;Object&gt;() {</span>
<span class="line-removed">-                 public Object run() {</span>
                      if (fontPath == null) {
                          fontPath = getPlatformFontPath(noType1Font);
                      }
                      if (fontPath != null) {
                          // this will find all fonts including those already
<span class="line-new-header">--- 3142,12 ---</span>
          synchronized (this) {
              if (FontUtilities.debugFonts()) {
                  Thread.dumpStack();
                  FontUtilities.getLogger().info(&quot;loadAllFontFiles() called&quot;);
              }
<span class="line-modified">!             AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {</span>
<span class="line-modified">!                 public Void run() {</span>
                      if (fontPath == null) {
                          fontPath = getPlatformFontPath(noType1Font);
                      }
                      if (fontPath != null) {
                          // this will find all fonts including those already
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3373,11 ***</span>
       * Only one thread should be able to add to this set so we don&#39;t
       * synchronize.
       */
      protected void addToMissingFontFileList(String fileName) {
          if (missingFontFiles == null) {
<span class="line-modified">!             missingFontFiles = new HashSet&lt;String&gt;();</span>
          }
          missingFontFiles.add(fileName);
      }
  
      /*
<span class="line-new-header">--- 3332,11 ---</span>
       * Only one thread should be able to add to this set so we don&#39;t
       * synchronize.
       */
      protected void addToMissingFontFileList(String fileName) {
          if (missingFontFiles == null) {
<span class="line-modified">!             missingFontFiles = new HashSet&lt;&gt;();</span>
          }
          missingFontFiles.add(fileName);
      }
  
      /*
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3540,13 ***</span>
  
      // Provides an aperture to add native font family names to the map
      protected void addNativeFontFamilyNames(TreeMap&lt;String, String&gt; familyNames, Locale requestedLocale) { }
  
      public void register1dot0Fonts() {
<span class="line-modified">!         java.security.AccessController.doPrivileged(</span>
<span class="line-modified">!                             new java.security.PrivilegedAction&lt;Object&gt;() {</span>
<span class="line-removed">-             public Object run() {</span>
                  String type1Dir = &quot;/usr/openwin/lib/X11/fonts/Type1&quot;;
                  registerFontsInDir(type1Dir, true, Font2D.TYPE1_RANK,
                                     false, false);
                  return null;
              }
<span class="line-new-header">--- 3499,12 ---</span>
  
      // Provides an aperture to add native font family names to the map
      protected void addNativeFontFamilyNames(TreeMap&lt;String, String&gt; familyNames, Locale requestedLocale) { }
  
      public void register1dot0Fonts() {
<span class="line-modified">!         AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {</span>
<span class="line-modified">!             public Void run() {</span>
                  String type1Dir = &quot;/usr/openwin/lib/X11/fonts/Type1&quot;;
                  registerFontsInDir(type1Dir, true, Font2D.TYPE1_RANK,
                                     false, false);
                  return null;
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3581,36 ***</span>
       * on windows and uses that if set.
       */
      private static Locale systemLocale = null;
      private static Locale getSystemStartupLocale() {
          if (systemLocale == null) {
<span class="line-modified">!             systemLocale = (Locale)</span>
<span class="line-modified">!                 java.security.AccessController.doPrivileged(</span>
<span class="line-modified">!                                     new java.security.PrivilegedAction&lt;Object&gt;() {</span>
<span class="line-modified">!             public Object run() {</span>
<span class="line-modified">!                 /* On windows the system locale may be different than the</span>
<span class="line-modified">!                  * user locale. This is an unsupported configuration, but</span>
<span class="line-modified">!                  * in that case we want to return a dummy locale that will</span>
<span class="line-modified">!                  * never cause a match in the usage of this API. This is</span>
<span class="line-modified">!                  * important because Windows documents that the family</span>
<span class="line-modified">!                  * names of fonts are enumerated using the language of</span>
<span class="line-modified">!                  * the system locale. BY returning a dummy locale in that</span>
<span class="line-modified">!                  * case we do not use the platform API which would not</span>
<span class="line-modified">!                  * return us the names we want.</span>
<span class="line-modified">!                  */</span>
<span class="line-modified">!                 String fileEncoding = System.getProperty(&quot;file.encoding&quot;, &quot;&quot;);</span>
<span class="line-modified">!                 String sysEncoding = System.getProperty(&quot;sun.jnu.encoding&quot;);</span>
<span class="line-modified">!                 if (sysEncoding != null &amp;&amp; !sysEncoding.equals(fileEncoding)) {</span>
<span class="line-removed">-                     return Locale.ROOT;</span>
<span class="line-removed">-                 }</span>
  
<span class="line-modified">!                 String language = System.getProperty(&quot;user.language&quot;, &quot;en&quot;);</span>
<span class="line-modified">!                 String country  = System.getProperty(&quot;user.country&quot;,&quot;&quot;);</span>
<span class="line-modified">!                 String variant  = System.getProperty(&quot;user.variant&quot;,&quot;&quot;);</span>
<span class="line-modified">!                 return new Locale(language, country, variant);</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!         });</span>
          }
          return systemLocale;
      }
  
      void addToPool(FileFont font) {
<span class="line-new-header">--- 3539,34 ---</span>
       * on windows and uses that if set.
       */
      private static Locale systemLocale = null;
      private static Locale getSystemStartupLocale() {
          if (systemLocale == null) {
<span class="line-modified">!             systemLocale = AccessController.doPrivileged(new PrivilegedAction&lt;Locale&gt;() {</span>
<span class="line-modified">!                 public Locale run() {</span>
<span class="line-modified">!                     /* On windows the system locale may be different than the</span>
<span class="line-modified">!                      * user locale. This is an unsupported configuration, but</span>
<span class="line-modified">!                      * in that case we want to return a dummy locale that will</span>
<span class="line-modified">!                      * never cause a match in the usage of this API. This is</span>
<span class="line-modified">!                      * important because Windows documents that the family</span>
<span class="line-modified">!                      * names of fonts are enumerated using the language of</span>
<span class="line-modified">!                      * the system locale. BY returning a dummy locale in that</span>
<span class="line-modified">!                      * case we do not use the platform API which would not</span>
<span class="line-modified">!                      * return us the names we want.</span>
<span class="line-modified">!                      */</span>
<span class="line-modified">!                     String fileEncoding = System.getProperty(&quot;file.encoding&quot;, &quot;&quot;);</span>
<span class="line-modified">!                     String sysEncoding = System.getProperty(&quot;sun.jnu.encoding&quot;);</span>
<span class="line-modified">!                     if (sysEncoding != null &amp;&amp; !sysEncoding.equals(fileEncoding)) {</span>
<span class="line-modified">!                         return Locale.ROOT;</span>
<span class="line-modified">!                     }</span>
  
<span class="line-modified">!                     String language = System.getProperty(&quot;user.language&quot;, &quot;en&quot;);</span>
<span class="line-modified">!                     String country  = System.getProperty(&quot;user.country&quot;,&quot;&quot;);</span>
<span class="line-modified">!                     String variant  = System.getProperty(&quot;user.variant&quot;,&quot;&quot;);</span>
<span class="line-modified">!                     return new Locale(language, country, variant);</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!             });</span>
          }
          return systemLocale;
      }
  
      void addToPool(FileFont font) {
</pre>
<center><a href="../awt/ComponentFactory.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="TrueTypeFont.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/java.desktop/share/classes/sun/font/SunFontManager.java b/src/java.desktop/share/classes/sun/font/SunFontManager.java
--- a/src/java.desktop/share/classes/sun/font/SunFontManager.java
+++ b/src/java.desktop/share/classes/sun/font/SunFontManager.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2008, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -37,11 +37,10 @@
 import java.security.PrivilegedAction;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Hashtable;
-import java.util.Iterator;
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
 import java.util.NoSuchElementException;
 import java.util.StringTokenizer;
@@ -129,29 +128,29 @@
         }
     }
 
     private static Font2DHandle FONT_HANDLE_NULL = new Font2DHandle(null);
 
-     public static final int FONTFORMAT_NONE = -1;
-     public static final int FONTFORMAT_TRUETYPE = 0;
-     public static final int FONTFORMAT_TYPE1 = 1;
-     public static final int FONTFORMAT_TTC = 2;
-     public static final int FONTFORMAT_COMPOSITE = 3;
-     public static final int FONTFORMAT_NATIVE = 4;
-
-     /* Pool of 20 font file channels chosen because some UTF-8 locale
-      * composite fonts can use up to 16 platform fonts (including the
-      * Lucida fall back). This should prevent channel thrashing when
-      * dealing with one of these fonts.
-      * The pool array stores the fonts, rather than directly referencing
-      * the channels, as the font needs to do the open/close work.
-      */
-     // MACOSX begin -- need to access these in subclass
-     protected static final int CHANNELPOOLSIZE = 20;
-     protected FileFont[] fontFileCache = new FileFont[CHANNELPOOLSIZE];
-     // MACOSX end
-     private int lastPoolIndex = 0;
+    public static final int FONTFORMAT_NONE = -1;
+    public static final int FONTFORMAT_TRUETYPE = 0;
+    public static final int FONTFORMAT_TYPE1 = 1;
+    public static final int FONTFORMAT_TTC = 2;
+    public static final int FONTFORMAT_COMPOSITE = 3;
+    public static final int FONTFORMAT_NATIVE = 4;
+
+    /* Pool of 20 font file channels chosen because some UTF-8 locale
+     * composite fonts can use up to 16 platform fonts (including the
+     * Lucida fall back). This should prevent channel thrashing when
+     * dealing with one of these fonts.
+     * The pool array stores the fonts, rather than directly referencing
+     * the channels, as the font needs to do the open/close work.
+     */
+    // MACOSX begin -- need to access these in subclass
+    protected static final int CHANNELPOOLSIZE = 20;
+    protected FileFont[] fontFileCache = new FileFont[CHANNELPOOLSIZE];
+    // MACOSX end
+    private int lastPoolIndex = 0;
 
     /* Need to implement a simple linked list scheme for fast
      * traversal and lookup.
      * Also want to "fast path" dialog so there's minimal overhead.
      */
@@ -161,23 +160,23 @@
      * variants.
      */
     private int maxCompFont = 0;
     private CompositeFont [] compFonts = new CompositeFont[20];
     private ConcurrentHashMap<String, CompositeFont>
-        compositeFonts = new ConcurrentHashMap<String, CompositeFont>();
+        compositeFonts = new ConcurrentHashMap<>();
     private ConcurrentHashMap<String, PhysicalFont>
-        physicalFonts = new ConcurrentHashMap<String, PhysicalFont>();
+        physicalFonts = new ConcurrentHashMap<>();
     private ConcurrentHashMap<String, PhysicalFont>
-        registeredFonts = new ConcurrentHashMap<String, PhysicalFont>();
+        registeredFonts = new ConcurrentHashMap<>();
 
     /* given a full name find the Font. Remind: there's duplication
      * here in that this contains the content of compositeFonts +
      * physicalFonts.
      */
     // MACOSX begin -- need to access this in subclass
     protected ConcurrentHashMap<String, Font2D>
-        fullNameToFont = new ConcurrentHashMap<String, Font2D>();
+        fullNameToFont = new ConcurrentHashMap<>();
     // MACOSX end
 
     /* TrueType fonts have localised names. Support searching all
      * of these before giving up on a name.
      */
@@ -264,38 +263,31 @@
      * have them collected more frequently to reclaim storage.
      */
     private static int maxSoftRefCnt = 10;
 
     static {
+        AccessController.doPrivileged(new PrivilegedAction<Void>() {
+            public Void run() {
+                FontManagerNativeLibrary.load();
+
+                // JNI throws an exception if a class/method/field is not found,
+                // so there's no need to do anything explicit here.
+                initIDs();
+
+                switch (StrikeCache.nativeAddressSize) {
+                case 8: longAddresses = true; break;
+                case 4: longAddresses = false; break;
+                default: throw new RuntimeException("Unexpected address size");
+                }
 
-        java.security.AccessController.doPrivileged(
-                                    new java.security.PrivilegedAction<Object>() {
-
-           public Object run() {
-               FontManagerNativeLibrary.load();
-
-               // JNI throws an exception if a class/method/field is not found,
-               // so there's no need to do anything explicit here.
-               initIDs();
-
-               switch (StrikeCache.nativeAddressSize) {
-               case 8: longAddresses = true; break;
-               case 4: longAddresses = false; break;
-               default: throw new RuntimeException("Unexpected address size");
-               }
-
-               noType1Font =
-                   "true".equals(System.getProperty("sun.java2d.noType1Font"));
-               jreLibDirName =
-                   System.getProperty("java.home","") + File.separator + "lib";
-               jreFontDirName = jreLibDirName + File.separator + "fonts";
-
-                maxSoftRefCnt =
-                    Integer.getInteger("sun.java2d.font.maxSoftRefs", 10);
+                noType1Font = "true".equals(System.getProperty("sun.java2d.noType1Font"));
+                jreLibDirName = System.getProperty("java.home","") + File.separator + "lib";
+                jreFontDirName = jreLibDirName + File.separator + "fonts";
 
-               return null;
-           }
+                maxSoftRefCnt = Integer.getInteger("sun.java2d.font.maxSoftRefs", 10);
+                return null;
+            }
         });
     }
 
     /**
      * If the module image layout changes the location of JDK fonts,
@@ -311,196 +303,177 @@
     }
 
     /* Initialise ptrs used by JNI methods */
     private static native void initIDs();
 
-    @SuppressWarnings("unchecked")
     protected SunFontManager() {
-
-        java.security.AccessController.doPrivileged(
-                new java.security.PrivilegedAction<Object>() {
-                    public Object run() {
-                        File badFontFile =
-                            new File(jreFontDirName + File.separator +
-                                     "badfonts.txt");
-                        if (badFontFile.exists()) {
-                            FileInputStream fis = null;
-                            try {
-                                badFonts = new ArrayList<>();
-                                fis = new FileInputStream(badFontFile);
-                                InputStreamReader isr = new InputStreamReader(fis);
-                                BufferedReader br = new BufferedReader(isr);
-                                while (true) {
-                                    String name = br.readLine();
-                                    if (name == null) {
-                                        break;
-                                    } else {
-                                        if (FontUtilities.debugFonts()) {
-                                            FontUtilities.getLogger().warning("read bad font: " +
-                                                           name);
-                                        }
-                                        badFonts.add(name);
-                                    }
-                                }
-                            } catch (IOException e) {
-                                try {
-                                    if (fis != null) {
-                                        fis.close();
-                                    }
-                                } catch (IOException ioe) {
+        AccessController.doPrivileged(new PrivilegedAction<Void>() {
+            public Void run() {
+                File badFontFile =
+                    new File(jreFontDirName + File.separator + "badfonts.txt");
+                if (badFontFile.exists()) {
+                    badFonts = new ArrayList<>();
+                    try (FileInputStream fis = new FileInputStream(badFontFile);
+                         BufferedReader br = new BufferedReader(new InputStreamReader(fis))) {
+                        while (true) {
+                            String name = br.readLine();
+                            if (name == null) {
+                                break;
+                            } else {
+                                if (FontUtilities.debugFonts()) {
+                                    FontUtilities.getLogger().warning("read bad font: " + name);
                                 }
+                                badFonts.add(name);
                             }
                         }
+                    } catch (IOException e) {
+                    }
+                }
 
-                        /* Here we get the fonts in jre/lib/fonts and register
-                         * them so they are always available and preferred over
-                         * other fonts. This needs to be registered before the
-                         * composite fonts as otherwise some native font that
-                         * corresponds may be found as we don't have a way to
-                         * handle two fonts of the same name, so the JRE one
-                         * must be the first one registered. Pass "true" to
-                         * registerFonts method as on-screen these JRE fonts
-                         * always go through the JDK rasteriser.
-                         */
-                        if (FontUtilities.isLinux) {
-                            /* Linux font configuration uses these fonts */
-                            registerFontDir(jreFontDirName);
-                        }
-                        registerFontsInDir(jreFontDirName, true, Font2D.JRE_RANK,
-                                           true, false);
+                /* Here we get the fonts in jre/lib/fonts and register
+                 * them so they are always available and preferred over
+                 * other fonts. This needs to be registered before the
+                 * composite fonts as otherwise some native font that
+                 * corresponds may be found as we don't have a way to
+                 * handle two fonts of the same name, so the JRE one
+                 * must be the first one registered. Pass "true" to
+                 * registerFonts method as on-screen these JRE fonts
+                 * always go through the JDK rasteriser.
+                 */
+                if (FontUtilities.isLinux) {
+                    /* Linux font configuration uses these fonts */
+                    registerFontDir(jreFontDirName);
+                }
+                registerFontsInDir(jreFontDirName, true, Font2D.JRE_RANK,
+                                   true, false);
 
-                        /* Create the font configuration and get any font path
-                         * that might be specified.
-                         */
-                        fontConfig = createFontConfiguration();
-
-                        String[] fontInfo = getDefaultPlatformFont();
-                        defaultFontName = fontInfo[0];
-                        defaultFontFileName = fontInfo[1];
-
-                        String extraFontPath = fontConfig.getExtraFontPath();
-
-                        /* In prior releases the debugging font path replaced
-                         * all normally located font directories except for the
-                         * JRE fonts dir. This directory is still always located
-                         * and placed at the head of the path but as an
-                         * augmentation to the previous behaviour the
-                         * changes below allow you to additionally append to
-                         * the font path by starting with append: or prepend by
-                         * starting with a prepend: sign. Eg: to append
-                         * -Dsun.java2d.fontpath=append:/usr/local/myfonts
-                         * and to prepend
-                         * -Dsun.java2d.fontpath=prepend:/usr/local/myfonts Disp
-                         *
-                         * If there is an appendedfontpath it in the font
-                         * configuration it is used instead of searching the
-                         * system for dirs.
-                         * The behaviour of append and prepend is then similar
-                         * to the normal case. ie it goes after what
-                         * you prepend and * before what you append. If the
-                         * sun.java2d.fontpath property is used, but it
-                         * neither the append or prepend syntaxes is used then
-                         * as except for the JRE dir the path is replaced and it
-                         * is up to you to make sure that all the right
-                         * directories are located. This is platform and
-                         * locale-specific so its almost impossible to get
-                         * right, so it should be used with caution.
-                         */
-                        boolean prependToPath = false;
-                        boolean appendToPath = false;
-                        String dbgFontPath =
-                            System.getProperty("sun.java2d.fontpath");
-
-                        if (dbgFontPath != null) {
-                            if (dbgFontPath.startsWith("prepend:")) {
-                                prependToPath = true;
-                                dbgFontPath =
-                                    dbgFontPath.substring("prepend:".length());
-                            } else if (dbgFontPath.startsWith("append:")) {
-                                appendToPath = true;
-                                dbgFontPath =
-                                    dbgFontPath.substring("append:".length());
-                            }
-                        }
+                /* Create the font configuration and get any font path
+                 * that might be specified.
+                 */
+                fontConfig = createFontConfiguration();
+
+                String[] fontInfo = getDefaultPlatformFont();
+                defaultFontName = fontInfo[0];
+                defaultFontFileName = fontInfo[1];
+
+                String extraFontPath = fontConfig.getExtraFontPath();
+
+                /* In prior releases the debugging font path replaced
+                 * all normally located font directories except for the
+                 * JRE fonts dir. This directory is still always located
+                 * and placed at the head of the path but as an
+                 * augmentation to the previous behaviour the
+                 * changes below allow you to additionally append to
+                 * the font path by starting with append: or prepend by
+                 * starting with a prepend: sign. Eg: to append
+                 * -Dsun.java2d.fontpath=append:/usr/local/myfonts
+                 * and to prepend
+                 * -Dsun.java2d.fontpath=prepend:/usr/local/myfonts Disp
+                 *
+                 * If there is an appendedfontpath it in the font
+                 * configuration it is used instead of searching the
+                 * system for dirs.
+                 * The behaviour of append and prepend is then similar
+                 * to the normal case. ie it goes after what
+                 * you prepend and * before what you append. If the
+                 * sun.java2d.fontpath property is used, but it
+                 * neither the append or prepend syntaxes is used then
+                 * as except for the JRE dir the path is replaced and it
+                 * is up to you to make sure that all the right
+                 * directories are located. This is platform and
+                 * locale-specific so its almost impossible to get
+                 * right, so it should be used with caution.
+                 */
+                boolean prependToPath = false;
+                boolean appendToPath = false;
+                String dbgFontPath = System.getProperty("sun.java2d.fontpath");
+
+                if (dbgFontPath != null) {
+                    if (dbgFontPath.startsWith("prepend:")) {
+                        prependToPath = true;
+                        dbgFontPath =
+                            dbgFontPath.substring("prepend:".length());
+                    } else if (dbgFontPath.startsWith("append:")) {
+                        appendToPath = true;
+                        dbgFontPath =
+                            dbgFontPath.substring("append:".length());
+                    }
+                }
 
-                        if (FontUtilities.debugFonts()) {
-                            PlatformLogger logger = FontUtilities.getLogger();
-                            logger.info("JRE font directory: " + jreFontDirName);
-                            logger.info("Extra font path: " + extraFontPath);
-                            logger.info("Debug font path: " + dbgFontPath);
-                        }
+                if (FontUtilities.debugFonts()) {
+                    PlatformLogger logger = FontUtilities.getLogger();
+                    logger.info("JRE font directory: " + jreFontDirName);
+                    logger.info("Extra font path: " + extraFontPath);
+                    logger.info("Debug font path: " + dbgFontPath);
+                }
 
-                        if (dbgFontPath != null) {
-                            /* In debugging mode we register all the paths
-                             * Caution: this is a very expensive call on Solaris:-
-                             */
-                            fontPath = getPlatformFontPath(noType1Font);
+                if (dbgFontPath != null) {
+                    /* In debugging mode we register all the paths
+                     * Caution: this is a very expensive call on Solaris:-
+                     */
+                    fontPath = getPlatformFontPath(noType1Font);
 
-                            if (extraFontPath != null) {
-                                fontPath =
-                                    extraFontPath + File.pathSeparator + fontPath;
-                            }
-                            if (appendToPath) {
-                                fontPath =
-                                    fontPath + File.pathSeparator + dbgFontPath;
-                            } else if (prependToPath) {
-                                fontPath =
-                                    dbgFontPath + File.pathSeparator + fontPath;
-                            } else {
-                                fontPath = dbgFontPath;
-                            }
-                            registerFontDirs(fontPath);
-                        } else if (extraFontPath != null) {
-                            /* If the font configuration contains an
-                             * "appendedfontpath" entry, it is interpreted as a
-                             * set of locations that should always be registered.
-                             * It may be additional to locations normally found
-                             * for that place, or it may be locations that need
-                             * to have all their paths registered to locate all
-                             * the needed platform names.
-                             * This is typically when the same .TTF file is
-                             * referenced from multiple font.dir files and all
-                             * of these must be read to find all the native
-                             * (XLFD) names for the font, so that X11 font APIs
-                             * can be used for as many code points as possible.
-                             */
-                            registerFontDirs(extraFontPath);
-                        }
+                    if (extraFontPath != null) {
+                        fontPath = extraFontPath + File.pathSeparator + fontPath;
+                    }
+                    if (appendToPath) {
+                        fontPath += File.pathSeparator + dbgFontPath;
+                    } else if (prependToPath) {
+                        fontPath = dbgFontPath + File.pathSeparator + fontPath;
+                    } else {
+                        fontPath = dbgFontPath;
+                    }
+                    registerFontDirs(fontPath);
+                } else if (extraFontPath != null) {
+                    /* If the font configuration contains an
+                     * "appendedfontpath" entry, it is interpreted as a
+                     * set of locations that should always be registered.
+                     * It may be additional to locations normally found
+                     * for that place, or it may be locations that need
+                     * to have all their paths registered to locate all
+                     * the needed platform names.
+                     * This is typically when the same .TTF file is
+                     * referenced from multiple font.dir files and all
+                     * of these must be read to find all the native
+                     * (XLFD) names for the font, so that X11 font APIs
+                     * can be used for as many code points as possible.
+                     */
+                    registerFontDirs(extraFontPath);
+                }
 
-                        /* On Solaris, we need to register the Japanese TrueType
-                         * directory so that we can find the corresponding
-                         * bitmap fonts. This could be done by listing the
-                         * directory in the font configuration file, but we
-                         * don't want to confuse users with this quirk. There
-                         * are no bitmap fonts for other writing systems that
-                         * correspond to TrueType fonts and have matching XLFDs.
-                         * We need to register the bitmap fonts only in
-                         * environments where they're on the X font path, i.e.,
-                         * in the Japanese locale. Note that if the X Toolkit
-                         * is in use the font path isn't set up by JDK, but
-                         * users of a JA locale should have it
-                         * set up already by their login environment.
-                         */
-                        if (FontUtilities.isSolaris && Locale.JAPAN.equals(Locale.getDefault())) {
-                            registerFontDir("/usr/openwin/lib/locale/ja/X11/fonts/TT");
-                        }
+                /* On Solaris, we need to register the Japanese TrueType
+                 * directory so that we can find the corresponding
+                 * bitmap fonts. This could be done by listing the
+                 * directory in the font configuration file, but we
+                 * don't want to confuse users with this quirk. There
+                 * are no bitmap fonts for other writing systems that
+                 * correspond to TrueType fonts and have matching XLFDs.
+                 * We need to register the bitmap fonts only in
+                 * environments where they're on the X font path, i.e.,
+                 * in the Japanese locale. Note that if the X Toolkit
+                 * is in use the font path isn't set up by JDK, but
+                 * users of a JA locale should have it
+                 * set up already by their login environment.
+                 */
+                if (FontUtilities.isSolaris && Locale.JAPAN.equals(Locale.getDefault())) {
+                    registerFontDir("/usr/openwin/lib/locale/ja/X11/fonts/TT");
+                }
 
-                        initCompositeFonts(fontConfig, null);
+                initCompositeFonts(fontConfig, null);
 
-                        return null;
-                    }
-                });
+                return null;
+            }
+        });
 
         boolean platformFont = AccessController.doPrivileged(
-                        new PrivilegedAction<Boolean>() {
-                                public Boolean run() {
-                                        String prop =
-                                                System.getProperty("java2d.font.usePlatformFont");
-                                        String env = System.getenv("JAVA2D_USEPLATFORMFONT");
-                                        return "true".equals(prop) || env != null;
-                                }
-                        });
+            new PrivilegedAction<Boolean>() {
+                    public Boolean run() {
+                        String prop = System.getProperty("java2d.font.usePlatformFont");
+                        String env = System.getenv("JAVA2D_USEPLATFORMFONT");
+                        return "true".equals(prop) || env != null;
+                    }
+            });
 
         if (platformFont) {
             usePlatformFontMetrics = true;
             System.out.println("Enabling platform font metrics for win32. This is an unsupported option.");
             System.out.println("This yields incorrect composite font metrics as reported by 1.1.x releases.");
@@ -820,14 +793,13 @@
             this.fontRank = rank;
         }
     }
 
     private final ConcurrentHashMap<String, FontRegistrationInfo>
-        deferredFontFiles =
-        new ConcurrentHashMap<String, FontRegistrationInfo>();
+        deferredFontFiles = new ConcurrentHashMap<>();
     private final ConcurrentHashMap<String, Font2DHandle>
-        initialisedFonts = new ConcurrentHashMap<String, Font2DHandle>();
+        initialisedFonts = new ConcurrentHashMap<>();
 
     /* Remind: possibly enhance initialiseDeferredFonts() to be
      * optionally given a name and a style and it could stop when it
      * finds that font - but this would be a problem if two of the
      * fonts reference the same font face name (cf the Solaris
@@ -865,15 +837,14 @@
         if (noOtherJREFontFiles) {
             return null;
         }
         synchronized (jreFontDirName) {
             if (jreOtherFontFiles == null) {
-                HashSet<String> otherFontFiles = new HashSet<String>();
+                HashSet<String> otherFontFiles = new HashSet<>();
                 for (String deferredFile : deferredFontFiles.keySet()) {
                     File file = new File(deferredFile);
                     String dir = file.getParent();
-                    String fname = file.getName();
                     /* skip names which aren't absolute, aren't in the JRE
                      * directory, or are known Lucida fonts.
                      */
                     if (dir == null || !dir.equals(jreFontDirName)) {
                         continue;
@@ -1004,12 +975,10 @@
             return regFont;
         }
 
         PhysicalFont physicalFont = null;
         try {
-            String name;
-
             switch (fontFormat) {
 
             case FONTFORMAT_TRUETYPE:
                 int fn = 0;
                 TrueTypeFont ttf;
@@ -1171,12 +1140,12 @@
         if (noType1) {
             filter = ttFilter;
         } else {
             filter = new TTorT1Filter();
         }
-        return (String[])AccessController.doPrivileged(new PrivilegedAction<Object>() {
-            public Object run() {
+        return AccessController.doPrivileged(new PrivilegedAction<String[]>() {
+            public String[] run() {
                 if (pathDirs.length == 1) {
                     File dir = new File(pathDirs[0]);
                     String[] files = dir.list(filter);
                     if (files == null) {
                         return new String[0];
@@ -1184,18 +1153,18 @@
                     for (int f=0; f<files.length; f++) {
                         files[f] = files[f].toLowerCase();
                     }
                     return files;
                 } else {
-                    ArrayList<String> fileList = new ArrayList<String>();
+                    ArrayList<String> fileList = new ArrayList<>();
                     for (int i = 0; i< pathDirs.length; i++) {
                         File dir = new File(pathDirs[i]);
                         String[] files = dir.list(filter);
                         if (files == null) {
                             continue;
                         }
-                        for (int f=0; f<files.length ; f++) {
+                        for (int f = 0; f < files.length ; f++) {
                             fileList.add(files[f].toLowerCase());
                         }
                     }
                     return fileList.toArray(STR_ARRAY);
                 }
@@ -1248,19 +1217,19 @@
                         fontToFileMap.remove("david regular");
                         fontToFileMap.put("david", file);
                     }
                 } else {
                     if (unmappedFontNames == null) {
-                        unmappedFontNames = new ArrayList<String>();
+                        unmappedFontNames = new ArrayList<>();
                     }
                     unmappedFontNames.add(font);
                 }
             }
         }
 
         if (unmappedFontNames != null) {
-            HashSet<String> unmappedFontFiles = new HashSet<String>();
+            HashSet<String> unmappedFontFiles = new HashSet<>();
 
             /* Every font key in fontToFileMap ought to correspond to a
              * font key in fontToFamilyNameMap. Entries that don't seem
              * to correspond are likely fonts that were named differently
              * by GDI than in the registry. One known cause of this is when
@@ -1311,11 +1280,11 @@
 
                 /* getFontFilesFromPath() returns all lower case names.
                  * To compare we also need lower case
                  * versions of the names from the registry.
                  */
-                ArrayList<String> registryFiles = new ArrayList<String>();
+                ArrayList<String> registryFiles = new ArrayList<>();
 
                 for (String regFile : fontToFileMap.values()) {
                     registryFiles.add(regFile.toLowerCase());
                 }
                 /* We don't look for Type1 files here as windows will
@@ -1380,11 +1349,11 @@
         }
         /* getFontFilesFromPath() returns all lower case names.
          * To compare we also need lower case
          * versions of the names from the registry.
          */
-        ArrayList<String> registryFiles = new ArrayList<String>();
+        ArrayList<String> registryFiles = new ArrayList<>();
         for (String regFile : fontToFileMap.values()) {
             registryFiles.add(regFile.toLowerCase());
         }
 
         /* To avoid any issues with concurrent modification, create
@@ -1407,26 +1376,24 @@
                 PhysicalFont f = registerFontFile(getPathName(pathFile));
                 if (f == null) {
                     continue;
                 }
                 if (fontToFileMap2 == null) {
-                    fontToFileMap2 = new HashMap<String,String>(fontToFileMap);
-                    fontToFamilyNameMap2 =
-                        new HashMap<String,String>(fontToFamilyNameMap);
-                    familyToFontListMap2 = new
-                        HashMap<String,ArrayList<String>>(familyToFontListMap);
+                    fontToFileMap2 = new HashMap<>(fontToFileMap);
+                    fontToFamilyNameMap2 = new HashMap<>(fontToFamilyNameMap);
+                    familyToFontListMap2 = new HashMap<>(familyToFontListMap);
                 }
                 String fontName = f.getFontName(null);
                 String family = f.getFamilyName(null);
                 String familyLC = family.toLowerCase();
                 fontToFamilyNameMap2.put(fontName, family);
                 fontToFileMap2.put(fontName, pathFile);
                 ArrayList<String> fonts = familyToFontListMap2.get(familyLC);
                 if (fonts == null) {
-                    fonts = new ArrayList<String>();
+                    fonts = new ArrayList<>();
                 } else {
-                    fonts = new ArrayList<String>(fonts);
+                    fonts = new ArrayList<>(fonts);
                 }
                 fonts.add(fontName);
                 familyToFontListMap2.put(familyLC, fonts);
             }
         }
@@ -1500,11 +1467,11 @@
 
     /**
      * default implementation does nothing.
      */
     public HashMap<String, FamilyDescription> populateHardcodedFileNameMap() {
-        return new HashMap<String, FamilyDescription>(0);
+        return new HashMap<>(0);
     }
 
     Font2D findFontFromPlatformMap(String lcName, int style) {
         if (platformFontMap == null) {
             platformFontMap = populateHardcodedFileNameMap();
@@ -1595,25 +1562,24 @@
 
         /* Some of these may be null,as not all styles have to exist */
         final String[] files = {
             plainFile, boldFile, italicFile, boldItalicFile } ;
 
-        failure = java.security.AccessController.doPrivileged(
-                 new java.security.PrivilegedAction<Boolean>() {
-                     public Boolean run() {
-                         for (int i=0; i<files.length; i++) {
-                             if (files[i] == null) {
-                                 continue;
-                             }
-                             File f = new File(files[i]);
-                             if (!f.exists()) {
-                                 return Boolean.TRUE;
-                             }
-                         }
-                         return Boolean.FALSE;
+        failure = AccessController.doPrivileged(new PrivilegedAction<Boolean>() {
+             public Boolean run() {
+                 for (int i=0; i<files.length; i++) {
+                     if (files[i] == null) {
+                         continue;
                      }
-                 });
+                     File f = new File(files[i]);
+                     if (!f.exists()) {
+                         return Boolean.TRUE;
+                     }
+                 }
+                 return Boolean.FALSE;
+             }
+         });
 
         if (failure) {
             if (FontUtilities.isLogging()) {
                 FontUtilities.getLogger().
                     info("Hardcoded file missing looking for " + lcName);
@@ -1675,13 +1641,13 @@
     private synchronized HashMap<String,String> getFullNameToFileMap() {
         if (fontToFileMap == null) {
 
             pathDirs = getPlatformFontDirs(noType1Font);
 
-            fontToFileMap = new HashMap<String,String>(100);
-            fontToFamilyNameMap = new HashMap<String,String>(100);
-            familyToFontListMap = new HashMap<String,ArrayList<String>>(50);
+            fontToFileMap = new HashMap<>(100);
+            fontToFamilyNameMap = new HashMap<>(100);
+            familyToFontListMap = new HashMap<>(50);
             populateFontFileNameMap(fontToFileMap,
                                     fontToFamilyNameMap,
                                     familyToFontListMap,
                                     Locale.ENGLISH);
             if (FontUtilities.isWindows) {
@@ -1718,11 +1684,11 @@
             return null;
         }
         checkForUnreferencedFontFiles();
         /* This odd code with TreeMap is used to preserve a historical
          * behaviour wrt the sorting order .. */
-        ArrayList<String> fontNames = new ArrayList<String>();
+        ArrayList<String> fontNames = new ArrayList<>();
         for (ArrayList<String> a : familyToFontListMap.values()) {
             for (String s : a) {
                 fontNames.add(s);
             }
         }
@@ -1797,14 +1763,14 @@
         if (f.isAbsolute()) {
             return s;
         } else if (pathDirs.length==1) {
             return pathDirs[0] + File.separator + s;
         } else {
-            String path = java.security.AccessController.doPrivileged(
-                 new java.security.PrivilegedAction<String>() {
+            String path = AccessController.doPrivileged(
+                 new PrivilegedAction<String>() {
                      public String run() {
-                         for (int p=0; p<pathDirs.length; p++) {
+                         for (int p = 0; p < pathDirs.length; p++) {
                              File f = new File(pathDirs[p] +File.separator+ s);
                              if (f.exists()) {
                                  return f.getAbsolutePath();
                              }
                          }
@@ -1928,11 +1894,11 @@
         }
         return font;
     }
 
     private ConcurrentHashMap<String, Font2D> fontNameCache =
-        new ConcurrentHashMap<String, Font2D>();
+        new ConcurrentHashMap<>();
 
     /*
      * The client supplies a name and a style.
      * The name could be a family name, or a full name.
      * A font may exist with the specified style, or it may
@@ -2298,11 +2264,11 @@
 
     public Font2D[] createFont2D(File fontFile, int fontFormat, boolean all,
                                  boolean isCopy, CreatedFontTracker tracker)
     throws FontFormatException {
 
-        List<Font2D> fList = new ArrayList<Font2D>();
+        List<Font2D> fList = new ArrayList<>();
         int cnt = 1;
         String fontFilePath = fontFile.getPath();
         FileFont font2D = null;
         final File fFile = fontFile;
         final CreatedFontTracker _tracker = tracker;
@@ -2341,19 +2307,18 @@
             default:
                 throw new FontFormatException("Unrecognised Font Format");
             }
         } catch (FontFormatException e) {
             if (isCopy) {
-                java.security.AccessController.doPrivileged(
-                     new java.security.PrivilegedAction<Object>() {
-                          public Object run() {
-                              if (_tracker != null) {
-                                  _tracker.subBytes((int)fFile.length());
-                              }
-                              fFile.delete();
-                              return null;
-                          }
+                AccessController.doPrivileged(new PrivilegedAction<Void>() {
+                    public Void run() {
+                        if (_tracker != null) {
+                            _tracker.subBytes((int)fFile.length());
+                        }
+                        fFile.delete();
+                        return null;
+                    }
                 });
             }
             throw(e);
         }
         if (isCopy) {
@@ -2365,39 +2330,35 @@
                 }
                 tmpFontFiles.add(fontFile);
 
                 if (fileCloser == null) {
                     final Runnable fileCloserRunnable = new Runnable() {
-                      public void run() {
-                         java.security.AccessController.doPrivileged(
-                         new java.security.PrivilegedAction<Object>() {
-                         public Object run() {
-
-                            for (int i=0;i<CHANNELPOOLSIZE;i++) {
-                                if (fontFileCache[i] != null) {
-                                    try {
-                                        fontFileCache[i].close();
-                                    } catch (Exception e) {
+                        public void run() {
+                            AccessController.doPrivileged(new PrivilegedAction<Void>() {
+                                public Void run() {
+                                    for (int i = 0;i < CHANNELPOOLSIZE; i++) {
+                                        if (fontFileCache[i] != null) {
+                                            try {
+                                                fontFileCache[i].close();
+                                            } catch (Exception e) {
+                                            }
+                                        }
                                     }
-                                }
-                            }
-                            if (tmpFontFiles != null) {
-                                File[] files = new File[tmpFontFiles.size()];
-                                files = tmpFontFiles.toArray(files);
-                                for (int f=0; f<files.length;f++) {
-                                    try {
-                                        files[f].delete();
-                                    } catch (Exception e) {
+                                    if (tmpFontFiles != null) {
+                                        File[] files = new File[tmpFontFiles.size()];
+                                        files = tmpFontFiles.toArray(files);
+                                        for (int f=0; f<files.length;f++) {
+                                            try {
+                                                files[f].delete();
+                                            } catch (Exception e) {
+                                            }
+                                        }
                                     }
+                                    return null;
                                 }
-                            }
-
-                            return null;
-                          }
-
-                          });
-                      }
+                            });
+                        }
                     };
                     AccessController.doPrivileged((PrivilegedAction<Void>) () -> {
                         ThreadGroup rootTG = ThreadGroupUtils.getRootThreadGroup();
                         fileCloser = new Thread(rootTG, fileCloserRunnable,
                                                 "FileCloser", 0, false);
@@ -2553,11 +2514,11 @@
 
     private synchronized void loadLocaleNames() {
         if (localeFullNamesToFont != null) {
             return;
         }
-        localeFullNamesToFont = new HashMap<String, TrueTypeFont>();
+        localeFullNamesToFont = new HashMap<>();
         Font2D[] fonts = getRegisteredFonts();
         for (int i=0; i<fonts.length; i++) {
             if (fonts[i] instanceof TrueTypeFont) {
                 TrueTypeFont ttf = (TrueTypeFont)fonts[i];
                 String[] fullNames = ttf.getAllFullNames();
@@ -2773,11 +2734,11 @@
            Locale l = getSystemStartupLocale();
            SunFontManager fontManager = SunFontManager.getInstance();
            String[] installedFamilies =
                fontManager.getInstalledFontFamilyNames(l);
            Font[] installedFonts = fontManager.getAllInstalledFonts();
-           HashSet<String> names = new HashSet<String>();
+           HashSet<String> names = new HashSet<>();
            for (int i=0; i<installedFamilies.length; i++) {
                names.add(installedFamilies[i].toLowerCase(l));
            }
            for (int i=0; i<installedFonts.length; i++) {
                names.add(installedFonts[i].getFontName(l).toLowerCase(l));
@@ -2935,11 +2896,11 @@
         }
 
         String path = getPlatformFontPath(noType1Fonts);
         StringTokenizer parser =
             new StringTokenizer(path, File.pathSeparator);
-        ArrayList<String> pathList = new ArrayList<String>();
+        ArrayList<String> pathList = new ArrayList<>();
         try {
             while (parser.hasMoreTokens()) {
                 pathList.add(parser.nextToken());
             }
         } catch (NoSuchElementException e) {
@@ -3065,13 +3026,12 @@
                 FontUtilities.getLogger()
                             .info("SunGraphicsEnvironment.loadFonts() called");
             }
             initialiseDeferredFonts();
 
-            java.security.AccessController.doPrivileged(
-                                    new java.security.PrivilegedAction<Object>() {
-                public Object run() {
+            AccessController.doPrivileged(new PrivilegedAction<Void>() {
+                public Void run() {
                     if (fontPath == null) {
                         fontPath = getPlatformFontPath(noType1Font);
                         registerFontDirs(fontPath);
                     }
                     if (fontPath != null) {
@@ -3182,13 +3142,12 @@
         synchronized (this) {
             if (FontUtilities.debugFonts()) {
                 Thread.dumpStack();
                 FontUtilities.getLogger().info("loadAllFontFiles() called");
             }
-            java.security.AccessController.doPrivileged(
-                                    new java.security.PrivilegedAction<Object>() {
-                public Object run() {
+            AccessController.doPrivileged(new PrivilegedAction<Void>() {
+                public Void run() {
                     if (fontPath == null) {
                         fontPath = getPlatformFontPath(noType1Font);
                     }
                     if (fontPath != null) {
                         // this will find all fonts including those already
@@ -3373,11 +3332,11 @@
      * Only one thread should be able to add to this set so we don't
      * synchronize.
      */
     protected void addToMissingFontFileList(String fileName) {
         if (missingFontFiles == null) {
-            missingFontFiles = new HashSet<String>();
+            missingFontFiles = new HashSet<>();
         }
         missingFontFiles.add(fileName);
     }
 
     /*
@@ -3540,13 +3499,12 @@
 
     // Provides an aperture to add native font family names to the map
     protected void addNativeFontFamilyNames(TreeMap<String, String> familyNames, Locale requestedLocale) { }
 
     public void register1dot0Fonts() {
-        java.security.AccessController.doPrivileged(
-                            new java.security.PrivilegedAction<Object>() {
-            public Object run() {
+        AccessController.doPrivileged(new PrivilegedAction<Void>() {
+            public Void run() {
                 String type1Dir = "/usr/openwin/lib/X11/fonts/Type1";
                 registerFontsInDir(type1Dir, true, Font2D.TYPE1_RANK,
                                    false, false);
                 return null;
             }
@@ -3581,36 +3539,34 @@
      * on windows and uses that if set.
      */
     private static Locale systemLocale = null;
     private static Locale getSystemStartupLocale() {
         if (systemLocale == null) {
-            systemLocale = (Locale)
-                java.security.AccessController.doPrivileged(
-                                    new java.security.PrivilegedAction<Object>() {
-            public Object run() {
-                /* On windows the system locale may be different than the
-                 * user locale. This is an unsupported configuration, but
-                 * in that case we want to return a dummy locale that will
-                 * never cause a match in the usage of this API. This is
-                 * important because Windows documents that the family
-                 * names of fonts are enumerated using the language of
-                 * the system locale. BY returning a dummy locale in that
-                 * case we do not use the platform API which would not
-                 * return us the names we want.
-                 */
-                String fileEncoding = System.getProperty("file.encoding", "");
-                String sysEncoding = System.getProperty("sun.jnu.encoding");
-                if (sysEncoding != null && !sysEncoding.equals(fileEncoding)) {
-                    return Locale.ROOT;
-                }
+            systemLocale = AccessController.doPrivileged(new PrivilegedAction<Locale>() {
+                public Locale run() {
+                    /* On windows the system locale may be different than the
+                     * user locale. This is an unsupported configuration, but
+                     * in that case we want to return a dummy locale that will
+                     * never cause a match in the usage of this API. This is
+                     * important because Windows documents that the family
+                     * names of fonts are enumerated using the language of
+                     * the system locale. BY returning a dummy locale in that
+                     * case we do not use the platform API which would not
+                     * return us the names we want.
+                     */
+                    String fileEncoding = System.getProperty("file.encoding", "");
+                    String sysEncoding = System.getProperty("sun.jnu.encoding");
+                    if (sysEncoding != null && !sysEncoding.equals(fileEncoding)) {
+                        return Locale.ROOT;
+                    }
 
-                String language = System.getProperty("user.language", "en");
-                String country  = System.getProperty("user.country","");
-                String variant  = System.getProperty("user.variant","");
-                return new Locale(language, country, variant);
-            }
-        });
+                    String language = System.getProperty("user.language", "en");
+                    String country  = System.getProperty("user.country","");
+                    String variant  = System.getProperty("user.variant","");
+                    return new Locale(language, country, variant);
+                }
+            });
         }
         return systemLocale;
     }
 
     void addToPool(FileFont font) {

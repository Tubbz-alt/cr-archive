<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/aarch64/interp_masm_aarch64.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="interp_masm_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/interp_masm_aarch64.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
245   void record_item_in_profile_helper(Register item, Register mdp,
246                                      Register reg2, int start_row, Label&amp; done, int total_rows,
247                                      OffsetFunction item_offset_fn, OffsetFunction item_count_offset_fn,
248                                      int non_profiled_offset);
249 
250   void update_mdp_by_offset(Register mdp_in, int offset_of_offset);
251   void update_mdp_by_offset(Register mdp_in, Register reg, int offset_of_disp);
252   void update_mdp_by_constant(Register mdp_in, int constant);
253   void update_mdp_for_ret(Register return_bci);
254 
255   // narrow int return value
256   void narrow(Register result);
257 
258   void profile_taken_branch(Register mdp, Register bumped_count);
259   void profile_not_taken_branch(Register mdp);
260   void profile_call(Register mdp);
261   void profile_final_call(Register mdp);
262   void profile_virtual_call(Register receiver, Register mdp,
263                             Register scratch2,
264                             bool receiver_can_be_null = false);
<span class="line-removed">265   void profile_called_method(Register method, Register mdp, Register reg2) NOT_JVMCI_RETURN;</span>
266   void profile_ret(Register return_bci, Register mdp);
267   void profile_null_seen(Register mdp);
268   void profile_typecheck(Register mdp, Register klass, Register scratch);
269   void profile_typecheck_failed(Register mdp);
270   void profile_switch_default(Register mdp);
271   void profile_switch_case(Register index_in_scratch, Register mdp,
272                            Register scratch2);
273 
274   void profile_obj_type(Register obj, const Address&amp; mdo_addr);
275   void profile_arguments_type(Register mdp, Register callee, Register tmp, bool is_virtual);
276   void profile_return_type(Register mdp, Register ret, Register tmp);
277   void profile_parameters_type(Register mdp, Register tmp1, Register tmp2);
278 
279   // Debugging
280   // only if +VerifyOops &amp;&amp; state == atos
281   void verify_oop(Register reg, TosState state = atos);
282   // only if +VerifyFPU  &amp;&amp; (state == ftos || state == dtos)
283   void verify_FPU(int stack_depth, TosState state = ftos);
284 
285   typedef enum { NotifyJVMTI, SkipNotifyJVMTI } NotifyMethodExitMode;
</pre>
</td>
<td>
<hr />
<pre>
245   void record_item_in_profile_helper(Register item, Register mdp,
246                                      Register reg2, int start_row, Label&amp; done, int total_rows,
247                                      OffsetFunction item_offset_fn, OffsetFunction item_count_offset_fn,
248                                      int non_profiled_offset);
249 
250   void update_mdp_by_offset(Register mdp_in, int offset_of_offset);
251   void update_mdp_by_offset(Register mdp_in, Register reg, int offset_of_disp);
252   void update_mdp_by_constant(Register mdp_in, int constant);
253   void update_mdp_for_ret(Register return_bci);
254 
255   // narrow int return value
256   void narrow(Register result);
257 
258   void profile_taken_branch(Register mdp, Register bumped_count);
259   void profile_not_taken_branch(Register mdp);
260   void profile_call(Register mdp);
261   void profile_final_call(Register mdp);
262   void profile_virtual_call(Register receiver, Register mdp,
263                             Register scratch2,
264                             bool receiver_can_be_null = false);

265   void profile_ret(Register return_bci, Register mdp);
266   void profile_null_seen(Register mdp);
267   void profile_typecheck(Register mdp, Register klass, Register scratch);
268   void profile_typecheck_failed(Register mdp);
269   void profile_switch_default(Register mdp);
270   void profile_switch_case(Register index_in_scratch, Register mdp,
271                            Register scratch2);
272 
273   void profile_obj_type(Register obj, const Address&amp; mdo_addr);
274   void profile_arguments_type(Register mdp, Register callee, Register tmp, bool is_virtual);
275   void profile_return_type(Register mdp, Register ret, Register tmp);
276   void profile_parameters_type(Register mdp, Register tmp1, Register tmp2);
277 
278   // Debugging
279   // only if +VerifyOops &amp;&amp; state == atos
280   void verify_oop(Register reg, TosState state = atos);
281   // only if +VerifyFPU  &amp;&amp; (state == ftos || state == dtos)
282   void verify_FPU(int stack_depth, TosState state = ftos);
283 
284   typedef enum { NotifyJVMTI, SkipNotifyJVMTI } NotifyMethodExitMode;
</pre>
</td>
</tr>
</table>
<center><a href="interp_masm_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
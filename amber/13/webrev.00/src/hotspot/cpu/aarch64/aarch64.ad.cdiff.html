<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/cpu/aarch64/aarch64.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../../../demo/share/jfc/TableExample/TableSorter.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="assembler_aarch64.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/aarch64.ad</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1025,10 ***</span>
<span class="line-new-header">--- 1025,17 ---</span>
      // count one adr and one far branch instruction
      return 4 * NativeInstruction::instruction_size;
    }
  };
  
<span class="line-added">+ class Node::PD {</span>
<span class="line-added">+ public:</span>
<span class="line-added">+   enum NodeFlags {</span>
<span class="line-added">+     _last_flag = Node::_last_flag</span>
<span class="line-added">+   };</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
   bool is_CAS(int opcode, bool maybe_volatile);
  
    // predicates controlling emit of ldr&lt;x&gt;/ldar&lt;x&gt; and associated dmb
  
    bool unnecessary_acquire(const Node *barrier);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1049,10 ***</span>
<span class="line-new-header">--- 1056,21 ---</span>
  
  source %{
  
    // Derived RegMask with conditionally allocatable registers
  
<span class="line-added">+   void PhaseOutput::pd_perform_mach_node_analysis() {</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   int MachNode::pd_alignment_required() const {</span>
<span class="line-added">+     return 1;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   int MachNode::compute_padding(int current_offset) const {</span>
<span class="line-added">+     return 0;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    RegMask _ANY_REG32_mask;
    RegMask _ANY_REG_mask;
    RegMask _PTR_REG_mask;
    RegMask _NO_SPECIAL_REG32_mask;
    RegMask _NO_SPECIAL_REG_mask;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1543,11 ***</span>
    st-&gt;print(&quot;BREAKPOINT&quot;);
  }
  #endif
  
  void MachBreakpointNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<span class="line-modified">!   MacroAssembler _masm(&amp;cbuf);</span>
    __ brk(0);
  }
  
  uint MachBreakpointNode::size(PhaseRegAlloc *ra_) const {
    return MachNode::size(ra_);
<span class="line-new-header">--- 1561,11 ---</span>
    st-&gt;print(&quot;BREAKPOINT&quot;);
  }
  #endif
  
  void MachBreakpointNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<span class="line-modified">!   C2_MacroAssembler _masm(&amp;cbuf);</span>
    __ brk(0);
  }
  
  uint MachBreakpointNode::size(PhaseRegAlloc *ra_) const {
    return MachNode::size(ra_);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1560,11 ***</span>
      st-&gt;print(&quot;nop \t# %d bytes pad for loops and calls&quot;, _count);
    }
  #endif
  
    void MachNopNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc*) const {
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      for (int i = 0; i &lt; _count; i++) {
        __ nop();
      }
    }
  
<span class="line-new-header">--- 1578,11 ---</span>
      st-&gt;print(&quot;nop \t# %d bytes pad for loops and calls&quot;, _count);
    }
  #endif
  
    void MachNopNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc*) const {
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      for (int i = 0; i &lt; _count; i++) {
        __ nop();
      }
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1573,11 ***</span>
    }
  
  //=============================================================================
  const RegMask&amp; MachConstantBaseNode::_out_RegMask = RegMask::Empty;
  
<span class="line-modified">! int Compile::ConstantTable::calculate_table_base_offset() const {</span>
    return 0;  // absolute addressing, no offset
  }
  
  bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
  void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
<span class="line-new-header">--- 1591,11 ---</span>
    }
  
  //=============================================================================
  const RegMask&amp; MachConstantBaseNode::_out_RegMask = RegMask::Empty;
  
<span class="line-modified">! int ConstantTable::calculate_table_base_offset() const {</span>
    return 0;  // absolute addressing, no offset
  }
  
  bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
  void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1600,13 ***</span>
  
  #ifndef PRODUCT
  void MachPrologNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
    Compile* C = ra_-&gt;C;
  
<span class="line-modified">!   int framesize = C-&gt;frame_slots() &lt;&lt; LogBytesPerInt;</span>
  
<span class="line-modified">!   if (C-&gt;need_stack_bang(framesize))</span>
      st-&gt;print(&quot;# stack bang size=%d\n\t&quot;, framesize);
  
    if (framesize &lt; ((1 &lt;&lt; 9) + 2 * wordSize)) {
      st-&gt;print(&quot;sub  sp, sp, #%d\n\t&quot;, framesize);
      st-&gt;print(&quot;stp  rfp, lr, [sp, #%d]&quot;, framesize - 2 * wordSize);
<span class="line-new-header">--- 1618,13 ---</span>
  
  #ifndef PRODUCT
  void MachPrologNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
    Compile* C = ra_-&gt;C;
  
<span class="line-modified">!   int framesize = C-&gt;output()-&gt;frame_slots() &lt;&lt; LogBytesPerInt;</span>
  
<span class="line-modified">!   if (C-&gt;output()-&gt;need_stack_bang(framesize))</span>
      st-&gt;print(&quot;# stack bang size=%d\n\t&quot;, framesize);
  
    if (framesize &lt; ((1 &lt;&lt; 9) + 2 * wordSize)) {
      st-&gt;print(&quot;sub  sp, sp, #%d\n\t&quot;, framesize);
      st-&gt;print(&quot;stp  rfp, lr, [sp, #%d]&quot;, framesize - 2 * wordSize);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1620,14 ***</span>
  }
  #endif
  
  void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
    Compile* C = ra_-&gt;C;
<span class="line-modified">!   MacroAssembler _masm(&amp;cbuf);</span>
  
    // n.b. frame size includes space for return pc and rfp
<span class="line-modified">!   const long framesize = C-&gt;frame_size_in_bytes();</span>
    assert(framesize%(2*wordSize) == 0, &quot;must preserve 2*wordSize alignment&quot;);
  
    // insert a nop at the start of the prolog so we can patch in a
    // branch if we need to invalidate the method later
    __ nop();
<span class="line-new-header">--- 1638,14 ---</span>
  }
  #endif
  
  void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
    Compile* C = ra_-&gt;C;
<span class="line-modified">!   C2_MacroAssembler _masm(&amp;cbuf);</span>
  
    // n.b. frame size includes space for return pc and rfp
<span class="line-modified">!   const long framesize = C-&gt;output()-&gt;frame_size_in_bytes();</span>
    assert(framesize%(2*wordSize) == 0, &quot;must preserve 2*wordSize alignment&quot;);
  
    // insert a nop at the start of the prolog so we can patch in a
    // branch if we need to invalidate the method later
    __ nop();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1641,26 ***</span>
      __ clinit_barrier(rscratch2, rscratch1, &amp;L_skip_barrier);
      __ far_jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub()));
      __ bind(L_skip_barrier);
    }
  
<span class="line-modified">!   int bangsize = C-&gt;bang_size_in_bytes();</span>
<span class="line-modified">!   if (C-&gt;need_stack_bang(bangsize) &amp;&amp; UseStackBanging)</span>
      __ generate_stack_overflow_check(bangsize);
  
    __ build_frame(framesize);
  
    if (VerifyStackAtCalls) {
      Unimplemented();
    }
  
<span class="line-modified">!   C-&gt;set_frame_complete(cbuf.insts_size());</span>
  
    if (C-&gt;has_mach_constant_base_node()) {
      // NOTE: We set the table base offset here because users might be
      // emitted before MachConstantBaseNode.
<span class="line-modified">!     Compile::ConstantTable&amp; constant_table = C-&gt;constant_table();</span>
      constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
    }
  }
  
  uint MachPrologNode::size(PhaseRegAlloc* ra_) const
<span class="line-new-header">--- 1659,26 ---</span>
      __ clinit_barrier(rscratch2, rscratch1, &amp;L_skip_barrier);
      __ far_jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub()));
      __ bind(L_skip_barrier);
    }
  
<span class="line-modified">!   int bangsize = C-&gt;output()-&gt;bang_size_in_bytes();</span>
<span class="line-modified">!   if (C-&gt;output()-&gt;need_stack_bang(bangsize) &amp;&amp; UseStackBanging)</span>
      __ generate_stack_overflow_check(bangsize);
  
    __ build_frame(framesize);
  
    if (VerifyStackAtCalls) {
      Unimplemented();
    }
  
<span class="line-modified">!   C-&gt;output()-&gt;set_frame_complete(cbuf.insts_size());</span>
  
    if (C-&gt;has_mach_constant_base_node()) {
      // NOTE: We set the table base offset here because users might be
      // emitted before MachConstantBaseNode.
<span class="line-modified">!     ConstantTable&amp; constant_table = C-&gt;output()-&gt;constant_table();</span>
      constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
    }
  }
  
  uint MachPrologNode::size(PhaseRegAlloc* ra_) const
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1677,11 ***</span>
  //=============================================================================
  
  #ifndef PRODUCT
  void MachEpilogNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
    Compile* C = ra_-&gt;C;
<span class="line-modified">!   int framesize = C-&gt;frame_slots() &lt;&lt; LogBytesPerInt;</span>
  
    st-&gt;print(&quot;# pop frame %d\n\t&quot;,framesize);
  
    if (framesize == 0) {
      st-&gt;print(&quot;ldp  lr, rfp, [sp],#%d\n\t&quot;, (2 * wordSize));
<span class="line-new-header">--- 1695,11 ---</span>
  //=============================================================================
  
  #ifndef PRODUCT
  void MachEpilogNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
    Compile* C = ra_-&gt;C;
<span class="line-modified">!   int framesize = C-&gt;output()-&gt;frame_slots() &lt;&lt; LogBytesPerInt;</span>
  
    st-&gt;print(&quot;# pop frame %d\n\t&quot;,framesize);
  
    if (framesize == 0) {
      st-&gt;print(&quot;ldp  lr, rfp, [sp],#%d\n\t&quot;, (2 * wordSize));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1694,29 ***</span>
      st-&gt;print(&quot;ldp  lr, rfp, [sp],#%d\n\t&quot;, (2 * wordSize));
    }
  
    if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
      st-&gt;print(&quot;# touch polling page\n\t&quot;);
<span class="line-modified">!     st-&gt;print(&quot;mov  rscratch1, #0x%lx\n\t&quot;, p2i(os::get_polling_page()));</span>
      st-&gt;print(&quot;ldr zr, [rscratch1]&quot;);
    }
  }
  #endif
  
  void MachEpilogNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
    Compile* C = ra_-&gt;C;
<span class="line-modified">!   MacroAssembler _masm(&amp;cbuf);</span>
<span class="line-modified">!   int framesize = C-&gt;frame_slots() &lt;&lt; LogBytesPerInt;</span>
  
    __ remove_frame(framesize);
  
    if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
      __ reserved_stack_check();
    }
  
    if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
<span class="line-modified">!     __ read_polling_page(rscratch1, os::get_polling_page(), relocInfo::poll_return_type);</span>
    }
  }
  
  uint MachEpilogNode::size(PhaseRegAlloc *ra_) const {
    // Variable size. Determine dynamically.
<span class="line-new-header">--- 1712,29 ---</span>
      st-&gt;print(&quot;ldp  lr, rfp, [sp],#%d\n\t&quot;, (2 * wordSize));
    }
  
    if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
      st-&gt;print(&quot;# touch polling page\n\t&quot;);
<span class="line-modified">!     st-&gt;print(&quot;ldr rscratch1, [rthread],#polling_page_offset\n\t&quot;);</span>
      st-&gt;print(&quot;ldr zr, [rscratch1]&quot;);
    }
  }
  #endif
  
  void MachEpilogNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
    Compile* C = ra_-&gt;C;
<span class="line-modified">!   C2_MacroAssembler _masm(&amp;cbuf);</span>
<span class="line-modified">!   int framesize = C-&gt;output()-&gt;frame_slots() &lt;&lt; LogBytesPerInt;</span>
  
    __ remove_frame(framesize);
  
    if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
      __ reserved_stack_check();
    }
  
    if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
<span class="line-modified">!     __ fetch_and_read_polling_page(rscratch1, relocInfo::poll_return_type);</span>
    }
  }
  
  uint MachEpilogNode::size(PhaseRegAlloc *ra_) const {
    // Variable size. Determine dynamically.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1730,18 ***</span>
  
  const Pipeline * MachEpilogNode::pipeline() const {
    return MachNode::pipeline_class();
  }
  
<span class="line-removed">- // This method seems to be obsolete. It is declared in machnode.hpp</span>
<span class="line-removed">- // and defined in all *.ad files, but it is never called. Should we</span>
<span class="line-removed">- // get rid of it?</span>
<span class="line-removed">- int MachEpilogNode::safepoint_offset() const {</span>
<span class="line-removed">-   assert(do_polling(), &quot;no return for this epilog node&quot;);</span>
<span class="line-removed">-   return 4;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  //=============================================================================
  
  // Figure out which register class each belongs in: rc_int, rc_float or
  // rc_stack.
  enum RC { rc_bad, rc_int, rc_float, rc_stack };
<span class="line-new-header">--- 1748,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1804,11 ***</span>
  
    if (bottom_type()-&gt;isa_vect() != NULL) {
      uint ireg = ideal_reg();
      assert(ireg == Op_VecD || ireg == Op_VecX, &quot;must be 64 bit or 128 bit vector&quot;);
      if (cbuf) {
<span class="line-modified">!       MacroAssembler _masm(cbuf);</span>
        assert((src_lo_rc != rc_int &amp;&amp; dst_lo_rc != rc_int), &quot;sanity&quot;);
        if (src_lo_rc == rc_stack &amp;&amp; dst_lo_rc == rc_stack) {
          // stack-&gt;stack
          assert((src_offset &amp; 7) == 0 &amp;&amp; (dst_offset &amp; 7) == 0, &quot;unaligned stack offset&quot;);
          if (ireg == Op_VecD) {
<span class="line-new-header">--- 1814,11 ---</span>
  
    if (bottom_type()-&gt;isa_vect() != NULL) {
      uint ireg = ideal_reg();
      assert(ireg == Op_VecD || ireg == Op_VecX, &quot;must be 64 bit or 128 bit vector&quot;);
      if (cbuf) {
<span class="line-modified">!       C2_MacroAssembler _masm(cbuf);</span>
        assert((src_lo_rc != rc_int &amp;&amp; dst_lo_rc != rc_int), &quot;sanity&quot;);
        if (src_lo_rc == rc_stack &amp;&amp; dst_lo_rc == rc_stack) {
          // stack-&gt;stack
          assert((src_offset &amp; 7) == 0 &amp;&amp; (dst_offset &amp; 7) == 0, &quot;unaligned stack offset&quot;);
          if (ireg == Op_VecD) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1832,19 ***</span>
        } else {
          ShouldNotReachHere();
        }
      }
    } else if (cbuf) {
<span class="line-modified">!     MacroAssembler _masm(cbuf);</span>
      switch (src_lo_rc) {
      case rc_int:
        if (dst_lo_rc == rc_int) {  // gpr --&gt; gpr copy
          if (is64) {
              __ mov(as_Register(Matcher::_regEncode[dst_lo]),
                     as_Register(Matcher::_regEncode[src_lo]));
          } else {
<span class="line-modified">!             MacroAssembler _masm(cbuf);</span>
              __ movw(as_Register(Matcher::_regEncode[dst_lo]),
                      as_Register(Matcher::_regEncode[src_lo]));
          }
        } else if (dst_lo_rc == rc_float) { // gpr --&gt; fpr copy
          if (is64) {
<span class="line-new-header">--- 1842,19 ---</span>
        } else {
          ShouldNotReachHere();
        }
      }
    } else if (cbuf) {
<span class="line-modified">!     C2_MacroAssembler _masm(cbuf);</span>
      switch (src_lo_rc) {
      case rc_int:
        if (dst_lo_rc == rc_int) {  // gpr --&gt; gpr copy
          if (is64) {
              __ mov(as_Register(Matcher::_regEncode[dst_lo]),
                     as_Register(Matcher::_regEncode[src_lo]));
          } else {
<span class="line-modified">!             C2_MacroAssembler _masm(cbuf);</span>
              __ movw(as_Register(Matcher::_regEncode[dst_lo]),
                      as_Register(Matcher::_regEncode[src_lo]));
          }
        } else if (dst_lo_rc == rc_float) { // gpr --&gt; fpr copy
          if (is64) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1950,11 ***</span>
              Matcher::regName[reg], offset);
  }
  #endif
  
  void BoxLockNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<span class="line-modified">!   MacroAssembler _masm(&amp;cbuf);</span>
  
    int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
    int reg    = ra_-&gt;get_encode(this);
  
    if (Assembler::operand_valid_for_add_sub_immediate(offset)) {
<span class="line-new-header">--- 1960,11 ---</span>
              Matcher::regName[reg], offset);
  }
  #endif
  
  void BoxLockNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<span class="line-modified">!   C2_MacroAssembler _masm(&amp;cbuf);</span>
  
    int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
    int reg    = ra_-&gt;get_encode(this);
  
    if (Assembler::operand_valid_for_add_sub_immediate(offset)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1989,11 ***</span>
  #endif
  
  void MachUEPNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
  {
    // This is the unverified entry point.
<span class="line-modified">!   MacroAssembler _masm(&amp;cbuf);</span>
  
    __ cmp_klass(j_rarg0, rscratch2, rscratch1);
    Label skip;
    // TODO
    // can we avoid this skip and still use a reloc?
<span class="line-new-header">--- 1999,11 ---</span>
  #endif
  
  void MachUEPNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
  {
    // This is the unverified entry point.
<span class="line-modified">!   C2_MacroAssembler _masm(&amp;cbuf);</span>
  
    __ cmp_klass(j_rarg0, rscratch2, rscratch1);
    Label skip;
    // TODO
    // can we avoid this skip and still use a reloc?
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2016,11 ***</span>
  {
    // mov rscratch1 #exception_blob_entry_point
    // br rscratch1
    // Note that the code buffer&#39;s insts_mark is always relative to insts.
    // That&#39;s why we must use the macroassembler to generate a handler.
<span class="line-modified">!   MacroAssembler _masm(&amp;cbuf);</span>
    address base = __ start_a_stub(size_exception_handler());
    if (base == NULL) {
      ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
      return 0;  // CodeBuffer::expand failed
    }
<span class="line-new-header">--- 2026,11 ---</span>
  {
    // mov rscratch1 #exception_blob_entry_point
    // br rscratch1
    // Note that the code buffer&#39;s insts_mark is always relative to insts.
    // That&#39;s why we must use the macroassembler to generate a handler.
<span class="line-modified">!   C2_MacroAssembler _masm(&amp;cbuf);</span>
    address base = __ start_a_stub(size_exception_handler());
    if (base == NULL) {
      ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
      return 0;  // CodeBuffer::expand failed
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2034,11 ***</span>
  // Emit deopt handler code.
  int HandlerImpl::emit_deopt_handler(CodeBuffer&amp; cbuf)
  {
    // Note that the code buffer&#39;s insts_mark is always relative to insts.
    // That&#39;s why we must use the macroassembler to generate a handler.
<span class="line-modified">!   MacroAssembler _masm(&amp;cbuf);</span>
    address base = __ start_a_stub(size_deopt_handler());
    if (base == NULL) {
      ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
      return 0;  // CodeBuffer::expand failed
    }
<span class="line-new-header">--- 2044,11 ---</span>
  // Emit deopt handler code.
  int HandlerImpl::emit_deopt_handler(CodeBuffer&amp; cbuf)
  {
    // Note that the code buffer&#39;s insts_mark is always relative to insts.
    // That&#39;s why we must use the macroassembler to generate a handler.
<span class="line-modified">!   C2_MacroAssembler _masm(&amp;cbuf);</span>
    address base = __ start_a_stub(size_deopt_handler());
    if (base == NULL) {
      ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
      return 0;  // CodeBuffer::expand failed
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2355,14 ***</span>
    return true;
  }
  
  const bool Matcher::convi2l_type_required = false;
  
  // Should the Matcher clone shifts on addressing modes, expecting them
  // to be subsumed into complex addressing expressions or compute them
  // into registers?
<span class="line-modified">! bool Matcher::clone_address_expressions(AddPNode* m, Matcher::MStack&amp; mstack, VectorSet&amp; address_visited) {</span>
    if (clone_base_plus_offset_address(m, mstack, address_visited)) {
      return true;
    }
  
    Node *off = m-&gt;in(AddPNode::Offset);
<span class="line-new-header">--- 2365,23 ---</span>
    return true;
  }
  
  const bool Matcher::convi2l_type_required = false;
  
<span class="line-added">+ // Should the matcher clone input &#39;m&#39; of node &#39;n&#39;?</span>
<span class="line-added">+ bool Matcher::pd_clone_node(Node* n, Node* m, Matcher::MStack&amp; mstack) {</span>
<span class="line-added">+   if (is_vshift_con_pattern(n, m)) { // ShiftV src (ShiftCntV con)</span>
<span class="line-added">+     mstack.push(m, Visit);           // m = ShiftCntV</span>
<span class="line-added">+     return true;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return false;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  // Should the Matcher clone shifts on addressing modes, expecting them
  // to be subsumed into complex addressing expressions or compute them
  // into registers?
<span class="line-modified">! bool Matcher::pd_clone_address_expressions(AddPNode* m, Matcher::MStack&amp; mstack, VectorSet&amp; address_visited) {</span>
    if (clone_base_plus_offset_address(m, mstack, address_visited)) {
      return true;
    }
  
    Node *off = m-&gt;in(AddPNode::Offset);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2401,11 ***</span>
  void Compile::reshape_address(AddPNode* addp) {
  }
  
  
  #define MOV_VOLATILE(REG, BASE, INDEX, SCALE, DISP, SCRATCH, INSN)      \
<span class="line-modified">!   MacroAssembler _masm(&amp;cbuf);                                          \</span>
    {                                                                     \
      guarantee(INDEX == -1, &quot;mode not permitted for volatile&quot;);          \
      guarantee(DISP == 0, &quot;mode not permitted for volatile&quot;);            \
      guarantee(SCALE == 0, &quot;mode not permitted for volatile&quot;);           \
      __ INSN(REG, as_Register(BASE));                                    \
<span class="line-new-header">--- 2420,11 ---</span>
  void Compile::reshape_address(AddPNode* addp) {
  }
  
  
  #define MOV_VOLATILE(REG, BASE, INDEX, SCALE, DISP, SCRATCH, INSN)      \
<span class="line-modified">!   C2_MacroAssembler _masm(&amp;cbuf);                                       \</span>
    {                                                                     \
      guarantee(INDEX == -1, &quot;mode not permitted for volatile&quot;);          \
      guarantee(DISP == 0, &quot;mode not permitted for volatile&quot;);            \
      guarantee(SCALE == 0, &quot;mode not permitted for volatile&quot;);           \
      __ INSN(REG, as_Register(BASE));                                    \
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2446,11 ***</span>
                                    MacroAssembler::SIMD_RegVariant T, const Address &amp;adr);
  
    // Used for all non-volatile memory accesses.  The use of
    // $mem-&gt;opcode() to discover whether this pattern uses sign-extended
    // offsets is something of a kludge.
<span class="line-modified">!   static void loadStore(MacroAssembler masm, mem_insn insn,</span>
                          Register reg, int opcode,
                          Register base, int index, int scale, int disp,
                          int size_in_memory)
    {
      Address addr = mem2address(opcode, base, index, scale, disp);
<span class="line-new-header">--- 2465,11 ---</span>
                                    MacroAssembler::SIMD_RegVariant T, const Address &amp;adr);
  
    // Used for all non-volatile memory accesses.  The use of
    // $mem-&gt;opcode() to discover whether this pattern uses sign-extended
    // offsets is something of a kludge.
<span class="line-modified">!   static void loadStore(C2_MacroAssembler masm, mem_insn insn,</span>
                          Register reg, int opcode,
                          Register base, int index, int scale, int disp,
                          int size_in_memory)
    {
      Address addr = mem2address(opcode, base, index, scale, disp);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2465,11 ***</span>
        addr = masm.legitimize_address(addr, size_in_memory, rscratch1);
      }
      (masm.*insn)(reg, addr);
    }
  
<span class="line-modified">!   static void loadStore(MacroAssembler masm, mem_float_insn insn,</span>
                          FloatRegister reg, int opcode,
                          Register base, int index, int size, int disp,
                          int size_in_memory)
    {
      Address::extend scale;
<span class="line-new-header">--- 2484,11 ---</span>
        addr = masm.legitimize_address(addr, size_in_memory, rscratch1);
      }
      (masm.*insn)(reg, addr);
    }
  
<span class="line-modified">!   static void loadStore(C2_MacroAssembler masm, mem_float_insn insn,</span>
                          FloatRegister reg, int opcode,
                          Register base, int index, int size, int disp,
                          int size_in_memory)
    {
      Address::extend scale;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2496,11 ***</span>
        assert(disp == 0, &quot;unsupported address mode: disp = %d&quot;, disp);
        (masm.*insn)(reg, Address(base, as_Register(index), scale));
      }
    }
  
<span class="line-modified">!   static void loadStore(MacroAssembler masm, mem_vector_insn insn,</span>
                          FloatRegister reg, MacroAssembler::SIMD_RegVariant T,
                          int opcode, Register base, int index, int size, int disp)
    {
      if (index == -1) {
        (masm.*insn)(reg, T, Address(base, disp));
<span class="line-new-header">--- 2515,11 ---</span>
        assert(disp == 0, &quot;unsupported address mode: disp = %d&quot;, disp);
        (masm.*insn)(reg, Address(base, as_Register(index), scale));
      }
    }
  
<span class="line-modified">!   static void loadStore(C2_MacroAssembler masm, mem_vector_insn insn,</span>
                          FloatRegister reg, MacroAssembler::SIMD_RegVariant T,
                          int opcode, Register base, int index, int size, int disp)
    {
      if (index == -1) {
        (masm.*insn)(reg, T, Address(base, disp));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2549,172 ***</span>
    // fields in an order, so that the adlc can build the emit functions
    // automagically
  
    // catch all for unimplemented encodings
    enc_class enc_unimplemented %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      __ unimplemented(&quot;C2 catch all&quot;);
    %}
  
    // BEGIN Non-volatile memory access
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_ldrsbw(iRegI dst, memory1 mem) %{
      Register dst_reg = as_Register($dst$$reg);
<span class="line-modified">!     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrsbw, dst_reg, $mem-&gt;opcode(),</span>
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 1);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_ldrsb(iRegI dst, memory1 mem) %{
      Register dst_reg = as_Register($dst$$reg);
<span class="line-modified">!     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrsb, dst_reg, $mem-&gt;opcode(),</span>
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 1);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_ldrb(iRegI dst, memory1 mem) %{
      Register dst_reg = as_Register($dst$$reg);
<span class="line-modified">!     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrb, dst_reg, $mem-&gt;opcode(),</span>
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 1);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_ldrb(iRegL dst, memory1 mem) %{
      Register dst_reg = as_Register($dst$$reg);
<span class="line-modified">!     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrb, dst_reg, $mem-&gt;opcode(),</span>
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 1);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_ldrshw(iRegI dst, memory2 mem) %{
      Register dst_reg = as_Register($dst$$reg);
<span class="line-modified">!     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrshw, dst_reg, $mem-&gt;opcode(),</span>
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 2);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_ldrsh(iRegI dst, memory2 mem) %{
      Register dst_reg = as_Register($dst$$reg);
<span class="line-modified">!     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrsh, dst_reg, $mem-&gt;opcode(),</span>
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 2);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_ldrh(iRegI dst, memory2 mem) %{
      Register dst_reg = as_Register($dst$$reg);
<span class="line-modified">!     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrh, dst_reg, $mem-&gt;opcode(),</span>
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 2);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_ldrh(iRegL dst, memory2 mem) %{
      Register dst_reg = as_Register($dst$$reg);
<span class="line-modified">!     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrh, dst_reg, $mem-&gt;opcode(),</span>
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 2);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_ldrw(iRegI dst, memory4 mem) %{
      Register dst_reg = as_Register($dst$$reg);
<span class="line-modified">!     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrw, dst_reg, $mem-&gt;opcode(),</span>
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_ldrw(iRegL dst, memory4 mem) %{
      Register dst_reg = as_Register($dst$$reg);
<span class="line-modified">!     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrw, dst_reg, $mem-&gt;opcode(),</span>
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_ldrsw(iRegL dst, memory4 mem) %{
      Register dst_reg = as_Register($dst$$reg);
<span class="line-modified">!     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrsw, dst_reg, $mem-&gt;opcode(),</span>
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_ldr(iRegL dst, memory8 mem) %{
      Register dst_reg = as_Register($dst$$reg);
<span class="line-modified">!     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldr, dst_reg, $mem-&gt;opcode(),</span>
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 8);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_ldrs(vRegF dst, memory4 mem) %{
      FloatRegister dst_reg = as_FloatRegister($dst$$reg);
<span class="line-modified">!     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrs, dst_reg, $mem-&gt;opcode(),</span>
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_ldrd(vRegD dst, memory8 mem) %{
      FloatRegister dst_reg = as_FloatRegister($dst$$reg);
<span class="line-modified">!     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrd, dst_reg, $mem-&gt;opcode(),</span>
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 8);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_strb(iRegI src, memory1 mem) %{
      Register src_reg = as_Register($src$$reg);
<span class="line-modified">!     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::strb, src_reg, $mem-&gt;opcode(),</span>
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 1);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_strb0(memory1 mem) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      loadStore(_masm, &amp;MacroAssembler::strb, zr, $mem-&gt;opcode(),
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 1);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_strh(iRegI src, memory2 mem) %{
      Register src_reg = as_Register($src$$reg);
<span class="line-modified">!     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::strh, src_reg, $mem-&gt;opcode(),</span>
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 2);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_strh0(memory2 mem) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      loadStore(_masm, &amp;MacroAssembler::strh, zr, $mem-&gt;opcode(),
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 2);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_strw(iRegI src, memory4 mem) %{
      Register src_reg = as_Register($src$$reg);
<span class="line-modified">!     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::strw, src_reg, $mem-&gt;opcode(),</span>
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_strw0(memory4 mem) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      loadStore(_masm, &amp;MacroAssembler::strw, zr, $mem-&gt;opcode(),
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
<span class="line-new-header">--- 2568,172 ---</span>
    // fields in an order, so that the adlc can build the emit functions
    // automagically
  
    // catch all for unimplemented encodings
    enc_class enc_unimplemented %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      __ unimplemented(&quot;C2 catch all&quot;);
    %}
  
    // BEGIN Non-volatile memory access
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_ldrsbw(iRegI dst, memory1 mem) %{
      Register dst_reg = as_Register($dst$$reg);
<span class="line-modified">!     loadStore(C2_MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrsbw, dst_reg, $mem-&gt;opcode(),</span>
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 1);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_ldrsb(iRegI dst, memory1 mem) %{
      Register dst_reg = as_Register($dst$$reg);
<span class="line-modified">!     loadStore(C2_MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrsb, dst_reg, $mem-&gt;opcode(),</span>
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 1);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_ldrb(iRegI dst, memory1 mem) %{
      Register dst_reg = as_Register($dst$$reg);
<span class="line-modified">!     loadStore(C2_MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrb, dst_reg, $mem-&gt;opcode(),</span>
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 1);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_ldrb(iRegL dst, memory1 mem) %{
      Register dst_reg = as_Register($dst$$reg);
<span class="line-modified">!     loadStore(C2_MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrb, dst_reg, $mem-&gt;opcode(),</span>
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 1);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_ldrshw(iRegI dst, memory2 mem) %{
      Register dst_reg = as_Register($dst$$reg);
<span class="line-modified">!     loadStore(C2_MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrshw, dst_reg, $mem-&gt;opcode(),</span>
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 2);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_ldrsh(iRegI dst, memory2 mem) %{
      Register dst_reg = as_Register($dst$$reg);
<span class="line-modified">!     loadStore(C2_MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrsh, dst_reg, $mem-&gt;opcode(),</span>
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 2);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_ldrh(iRegI dst, memory2 mem) %{
      Register dst_reg = as_Register($dst$$reg);
<span class="line-modified">!     loadStore(C2_MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrh, dst_reg, $mem-&gt;opcode(),</span>
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 2);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_ldrh(iRegL dst, memory2 mem) %{
      Register dst_reg = as_Register($dst$$reg);
<span class="line-modified">!     loadStore(C2_MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrh, dst_reg, $mem-&gt;opcode(),</span>
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 2);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_ldrw(iRegI dst, memory4 mem) %{
      Register dst_reg = as_Register($dst$$reg);
<span class="line-modified">!     loadStore(C2_MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrw, dst_reg, $mem-&gt;opcode(),</span>
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_ldrw(iRegL dst, memory4 mem) %{
      Register dst_reg = as_Register($dst$$reg);
<span class="line-modified">!     loadStore(C2_MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrw, dst_reg, $mem-&gt;opcode(),</span>
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_ldrsw(iRegL dst, memory4 mem) %{
      Register dst_reg = as_Register($dst$$reg);
<span class="line-modified">!     loadStore(C2_MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrsw, dst_reg, $mem-&gt;opcode(),</span>
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_ldr(iRegL dst, memory8 mem) %{
      Register dst_reg = as_Register($dst$$reg);
<span class="line-modified">!     loadStore(C2_MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldr, dst_reg, $mem-&gt;opcode(),</span>
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 8);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_ldrs(vRegF dst, memory4 mem) %{
      FloatRegister dst_reg = as_FloatRegister($dst$$reg);
<span class="line-modified">!     loadStore(C2_MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrs, dst_reg, $mem-&gt;opcode(),</span>
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_ldrd(vRegD dst, memory8 mem) %{
      FloatRegister dst_reg = as_FloatRegister($dst$$reg);
<span class="line-modified">!     loadStore(C2_MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrd, dst_reg, $mem-&gt;opcode(),</span>
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 8);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_strb(iRegI src, memory1 mem) %{
      Register src_reg = as_Register($src$$reg);
<span class="line-modified">!     loadStore(C2_MacroAssembler(&amp;cbuf), &amp;MacroAssembler::strb, src_reg, $mem-&gt;opcode(),</span>
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 1);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_strb0(memory1 mem) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      loadStore(_masm, &amp;MacroAssembler::strb, zr, $mem-&gt;opcode(),
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 1);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_strh(iRegI src, memory2 mem) %{
      Register src_reg = as_Register($src$$reg);
<span class="line-modified">!     loadStore(C2_MacroAssembler(&amp;cbuf), &amp;MacroAssembler::strh, src_reg, $mem-&gt;opcode(),</span>
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 2);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_strh0(memory2 mem) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      loadStore(_masm, &amp;MacroAssembler::strh, zr, $mem-&gt;opcode(),
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 2);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_strw(iRegI src, memory4 mem) %{
      Register src_reg = as_Register($src$$reg);
<span class="line-modified">!     loadStore(C2_MacroAssembler(&amp;cbuf), &amp;MacroAssembler::strw, src_reg, $mem-&gt;opcode(),</span>
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_strw0(memory4 mem) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      loadStore(_masm, &amp;MacroAssembler::strw, zr, $mem-&gt;opcode(),
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2722,47 ***</span>
    enc_class aarch64_enc_str(iRegL src, memory8 mem) %{
      Register src_reg = as_Register($src$$reg);
      // we sometimes get asked to store the stack pointer into the
      // current thread -- we cannot do that directly on AArch64
      if (src_reg == r31_sp) {
<span class="line-modified">!       MacroAssembler _masm(&amp;cbuf);</span>
        assert(as_Register($mem$$base) == rthread, &quot;unexpected store for sp&quot;);
        __ mov(rscratch2, sp);
        src_reg = rscratch2;
      }
<span class="line-modified">!     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::str, src_reg, $mem-&gt;opcode(),</span>
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 8);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_str0(memory8 mem) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      loadStore(_masm, &amp;MacroAssembler::str, zr, $mem-&gt;opcode(),
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 8);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_strs(vRegF src, memory4 mem) %{
      FloatRegister src_reg = as_FloatRegister($src$$reg);
<span class="line-modified">!     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::strs, src_reg, $mem-&gt;opcode(),</span>
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_strd(vRegD src, memory8 mem) %{
      FloatRegister src_reg = as_FloatRegister($src$$reg);
<span class="line-modified">!     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::strd, src_reg, $mem-&gt;opcode(),</span>
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 8);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_strw_immn(immN src, memory1 mem) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      address con = (address)$src$$constant;
      // need to do this the hard way until we can manage relocs
      // for 32 bit constants
      __ movoop(rscratch2, (jobject)con);
      if (con) __ encode_heap_oop_not_null(rscratch2);
<span class="line-new-header">--- 2741,47 ---</span>
    enc_class aarch64_enc_str(iRegL src, memory8 mem) %{
      Register src_reg = as_Register($src$$reg);
      // we sometimes get asked to store the stack pointer into the
      // current thread -- we cannot do that directly on AArch64
      if (src_reg == r31_sp) {
<span class="line-modified">!       C2_MacroAssembler _masm(&amp;cbuf);</span>
        assert(as_Register($mem$$base) == rthread, &quot;unexpected store for sp&quot;);
        __ mov(rscratch2, sp);
        src_reg = rscratch2;
      }
<span class="line-modified">!     loadStore(C2_MacroAssembler(&amp;cbuf), &amp;MacroAssembler::str, src_reg, $mem-&gt;opcode(),</span>
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 8);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_str0(memory8 mem) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      loadStore(_masm, &amp;MacroAssembler::str, zr, $mem-&gt;opcode(),
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 8);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_strs(vRegF src, memory4 mem) %{
      FloatRegister src_reg = as_FloatRegister($src$$reg);
<span class="line-modified">!     loadStore(C2_MacroAssembler(&amp;cbuf), &amp;MacroAssembler::strs, src_reg, $mem-&gt;opcode(),</span>
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_strd(vRegD src, memory8 mem) %{
      FloatRegister src_reg = as_FloatRegister($src$$reg);
<span class="line-modified">!     loadStore(C2_MacroAssembler(&amp;cbuf), &amp;MacroAssembler::strd, src_reg, $mem-&gt;opcode(),</span>
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 8);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_strw_immn(immN src, memory1 mem) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      address con = (address)$src$$constant;
      // need to do this the hard way until we can manage relocs
      // for 32 bit constants
      __ movoop(rscratch2, (jobject)con);
      if (con) __ encode_heap_oop_not_null(rscratch2);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2771,11 ***</span>
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_strw_immnk(immN src, memory4 mem) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      address con = (address)$src$$constant;
      // need to do this the hard way until we can manage relocs
      // for 32 bit constants
      __ movoop(rscratch2, (jobject)con);
      __ encode_klass_not_null(rscratch2);
<span class="line-new-header">--- 2790,11 ---</span>
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_strw_immnk(immN src, memory4 mem) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      address con = (address)$src$$constant;
      // need to do this the hard way until we can manage relocs
      // for 32 bit constants
      __ movoop(rscratch2, (jobject)con);
      __ encode_klass_not_null(rscratch2);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2784,52 ***</span>
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_strb0_ordered(memory4 mem) %{
<span class="line-modified">!       MacroAssembler _masm(&amp;cbuf);</span>
        __ membar(Assembler::StoreStore);
        loadStore(_masm, &amp;MacroAssembler::strb, zr, $mem-&gt;opcode(),
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 1);
    %}
  
    // END Non-volatile memory access
  
    // Vector loads and stores
    enc_class aarch64_enc_ldrvS(vecD dst, memory mem) %{
      FloatRegister dst_reg = as_FloatRegister($dst$$reg);
<span class="line-modified">!     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldr, dst_reg, MacroAssembler::S,</span>
         $mem-&gt;opcode(), as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);
    %}
  
    enc_class aarch64_enc_ldrvD(vecD dst, memory mem) %{
      FloatRegister dst_reg = as_FloatRegister($dst$$reg);
<span class="line-modified">!     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldr, dst_reg, MacroAssembler::D,</span>
         $mem-&gt;opcode(), as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);
    %}
  
    enc_class aarch64_enc_ldrvQ(vecX dst, memory mem) %{
      FloatRegister dst_reg = as_FloatRegister($dst$$reg);
<span class="line-modified">!     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldr, dst_reg, MacroAssembler::Q,</span>
         $mem-&gt;opcode(), as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);
    %}
  
    enc_class aarch64_enc_strvS(vecD src, memory mem) %{
      FloatRegister src_reg = as_FloatRegister($src$$reg);
<span class="line-modified">!     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::str, src_reg, MacroAssembler::S,</span>
         $mem-&gt;opcode(), as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);
    %}
  
    enc_class aarch64_enc_strvD(vecD src, memory mem) %{
      FloatRegister src_reg = as_FloatRegister($src$$reg);
<span class="line-modified">!     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::str, src_reg, MacroAssembler::D,</span>
         $mem-&gt;opcode(), as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);
    %}
  
    enc_class aarch64_enc_strvQ(vecX src, memory mem) %{
      FloatRegister src_reg = as_FloatRegister($src$$reg);
<span class="line-modified">!     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::str, src_reg, MacroAssembler::Q,</span>
         $mem-&gt;opcode(), as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);
    %}
  
    // volatile loads and stores
  
<span class="line-new-header">--- 2803,52 ---</span>
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_strb0_ordered(memory4 mem) %{
<span class="line-modified">!       C2_MacroAssembler _masm(&amp;cbuf);</span>
        __ membar(Assembler::StoreStore);
        loadStore(_masm, &amp;MacroAssembler::strb, zr, $mem-&gt;opcode(),
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 1);
    %}
  
    // END Non-volatile memory access
  
    // Vector loads and stores
    enc_class aarch64_enc_ldrvS(vecD dst, memory mem) %{
      FloatRegister dst_reg = as_FloatRegister($dst$$reg);
<span class="line-modified">!     loadStore(C2_MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldr, dst_reg, MacroAssembler::S,</span>
         $mem-&gt;opcode(), as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);
    %}
  
    enc_class aarch64_enc_ldrvD(vecD dst, memory mem) %{
      FloatRegister dst_reg = as_FloatRegister($dst$$reg);
<span class="line-modified">!     loadStore(C2_MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldr, dst_reg, MacroAssembler::D,</span>
         $mem-&gt;opcode(), as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);
    %}
  
    enc_class aarch64_enc_ldrvQ(vecX dst, memory mem) %{
      FloatRegister dst_reg = as_FloatRegister($dst$$reg);
<span class="line-modified">!     loadStore(C2_MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldr, dst_reg, MacroAssembler::Q,</span>
         $mem-&gt;opcode(), as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);
    %}
  
    enc_class aarch64_enc_strvS(vecD src, memory mem) %{
      FloatRegister src_reg = as_FloatRegister($src$$reg);
<span class="line-modified">!     loadStore(C2_MacroAssembler(&amp;cbuf), &amp;MacroAssembler::str, src_reg, MacroAssembler::S,</span>
         $mem-&gt;opcode(), as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);
    %}
  
    enc_class aarch64_enc_strvD(vecD src, memory mem) %{
      FloatRegister src_reg = as_FloatRegister($src$$reg);
<span class="line-modified">!     loadStore(C2_MacroAssembler(&amp;cbuf), &amp;MacroAssembler::str, src_reg, MacroAssembler::D,</span>
         $mem-&gt;opcode(), as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);
    %}
  
    enc_class aarch64_enc_strvQ(vecX src, memory mem) %{
      FloatRegister src_reg = as_FloatRegister($src$$reg);
<span class="line-modified">!     loadStore(C2_MacroAssembler(&amp;cbuf), &amp;MacroAssembler::str, src_reg, MacroAssembler::Q,</span>
         $mem-&gt;opcode(), as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);
    %}
  
    // volatile loads and stores
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2927,43 ***</span>
    enc_class aarch64_enc_stlr(iRegL src, memory mem) %{
      Register src_reg = as_Register($src$$reg);
      // we sometimes get asked to store the stack pointer into the
      // current thread -- we cannot do that directly on AArch64
      if (src_reg == r31_sp) {
<span class="line-modified">!         MacroAssembler _masm(&amp;cbuf);</span>
        assert(as_Register($mem$$base) == rthread, &quot;unexpected store for sp&quot;);
        __ mov(rscratch2, sp);
        src_reg = rscratch2;
      }
      MOV_VOLATILE(src_reg, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp,
                   rscratch1, stlr);
    %}
  
    enc_class aarch64_enc_fstlrs(vRegF src, memory mem) %{
      {
<span class="line-modified">!       MacroAssembler _masm(&amp;cbuf);</span>
        FloatRegister src_reg = as_FloatRegister($src$$reg);
        __ fmovs(rscratch2, src_reg);
      }
      MOV_VOLATILE(rscratch2, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp,
                   rscratch1, stlrw);
    %}
  
    enc_class aarch64_enc_fstlrd(vRegD src, memory mem) %{
      {
<span class="line-modified">!       MacroAssembler _masm(&amp;cbuf);</span>
        FloatRegister src_reg = as_FloatRegister($src$$reg);
        __ fmovd(rscratch2, src_reg);
      }
      MOV_VOLATILE(rscratch2, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp,
                   rscratch1, stlr);
    %}
  
    // synchronized read/update encodings
  
    enc_class aarch64_enc_ldaxr(iRegL dst, memory8 mem) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      Register dst_reg = as_Register($dst$$reg);
      Register base = as_Register($mem$$base);
      int index = $mem$$index;
      int scale = $mem$$scale;
      int disp = $mem$$disp;
<span class="line-new-header">--- 2946,43 ---</span>
    enc_class aarch64_enc_stlr(iRegL src, memory mem) %{
      Register src_reg = as_Register($src$$reg);
      // we sometimes get asked to store the stack pointer into the
      // current thread -- we cannot do that directly on AArch64
      if (src_reg == r31_sp) {
<span class="line-modified">!       C2_MacroAssembler _masm(&amp;cbuf);</span>
        assert(as_Register($mem$$base) == rthread, &quot;unexpected store for sp&quot;);
        __ mov(rscratch2, sp);
        src_reg = rscratch2;
      }
      MOV_VOLATILE(src_reg, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp,
                   rscratch1, stlr);
    %}
  
    enc_class aarch64_enc_fstlrs(vRegF src, memory mem) %{
      {
<span class="line-modified">!       C2_MacroAssembler _masm(&amp;cbuf);</span>
        FloatRegister src_reg = as_FloatRegister($src$$reg);
        __ fmovs(rscratch2, src_reg);
      }
      MOV_VOLATILE(rscratch2, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp,
                   rscratch1, stlrw);
    %}
  
    enc_class aarch64_enc_fstlrd(vRegD src, memory mem) %{
      {
<span class="line-modified">!       C2_MacroAssembler _masm(&amp;cbuf);</span>
        FloatRegister src_reg = as_FloatRegister($src$$reg);
        __ fmovd(rscratch2, src_reg);
      }
      MOV_VOLATILE(rscratch2, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp,
                   rscratch1, stlr);
    %}
  
    // synchronized read/update encodings
  
    enc_class aarch64_enc_ldaxr(iRegL dst, memory8 mem) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register dst_reg = as_Register($dst$$reg);
      Register base = as_Register($mem$$base);
      int index = $mem$$index;
      int scale = $mem$$scale;
      int disp = $mem$$disp;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2988,11 ***</span>
        }
      }
    %}
  
    enc_class aarch64_enc_stlxr(iRegLNoSp src, memory8 mem) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      Register src_reg = as_Register($src$$reg);
      Register base = as_Register($mem$$base);
      int index = $mem$$index;
      int scale = $mem$$scale;
      int disp = $mem$$disp;
<span class="line-new-header">--- 3007,11 ---</span>
        }
      }
    %}
  
    enc_class aarch64_enc_stlxr(iRegLNoSp src, memory8 mem) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register src_reg = as_Register($src$$reg);
      Register base = as_Register($mem$$base);
      int index = $mem$$index;
      int scale = $mem$$scale;
      int disp = $mem$$disp;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3018,35 ***</span>
      }
      __ cmpw(rscratch1, zr);
    %}
  
    enc_class aarch64_enc_cmpxchg(memory mem, iRegLNoSp oldval, iRegLNoSp newval) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      guarantee($mem$$index == -1 &amp;&amp; $mem$$disp == 0, &quot;impossible encoding&quot;);
      __ cmpxchg($mem$$base$$Register, $oldval$$Register, $newval$$Register,
                 Assembler::xword, /*acquire*/ false, /*release*/ true,
                 /*weak*/ false, noreg);
    %}
  
    enc_class aarch64_enc_cmpxchgw(memory mem, iRegINoSp oldval, iRegINoSp newval) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      guarantee($mem$$index == -1 &amp;&amp; $mem$$disp == 0, &quot;impossible encoding&quot;);
      __ cmpxchg($mem$$base$$Register, $oldval$$Register, $newval$$Register,
                 Assembler::word, /*acquire*/ false, /*release*/ true,
                 /*weak*/ false, noreg);
    %}
  
    enc_class aarch64_enc_cmpxchgs(memory mem, iRegINoSp oldval, iRegINoSp newval) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      guarantee($mem$$index == -1 &amp;&amp; $mem$$disp == 0, &quot;impossible encoding&quot;);
      __ cmpxchg($mem$$base$$Register, $oldval$$Register, $newval$$Register,
                 Assembler::halfword, /*acquire*/ false, /*release*/ true,
                 /*weak*/ false, noreg);
    %}
  
    enc_class aarch64_enc_cmpxchgb(memory mem, iRegINoSp oldval, iRegINoSp newval) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      guarantee($mem$$index == -1 &amp;&amp; $mem$$disp == 0, &quot;impossible encoding&quot;);
      __ cmpxchg($mem$$base$$Register, $oldval$$Register, $newval$$Register,
                 Assembler::byte, /*acquire*/ false, /*release*/ true,
                 /*weak*/ false, noreg);
    %}
<span class="line-new-header">--- 3037,35 ---</span>
      }
      __ cmpw(rscratch1, zr);
    %}
  
    enc_class aarch64_enc_cmpxchg(memory mem, iRegLNoSp oldval, iRegLNoSp newval) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      guarantee($mem$$index == -1 &amp;&amp; $mem$$disp == 0, &quot;impossible encoding&quot;);
      __ cmpxchg($mem$$base$$Register, $oldval$$Register, $newval$$Register,
                 Assembler::xword, /*acquire*/ false, /*release*/ true,
                 /*weak*/ false, noreg);
    %}
  
    enc_class aarch64_enc_cmpxchgw(memory mem, iRegINoSp oldval, iRegINoSp newval) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      guarantee($mem$$index == -1 &amp;&amp; $mem$$disp == 0, &quot;impossible encoding&quot;);
      __ cmpxchg($mem$$base$$Register, $oldval$$Register, $newval$$Register,
                 Assembler::word, /*acquire*/ false, /*release*/ true,
                 /*weak*/ false, noreg);
    %}
  
    enc_class aarch64_enc_cmpxchgs(memory mem, iRegINoSp oldval, iRegINoSp newval) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      guarantee($mem$$index == -1 &amp;&amp; $mem$$disp == 0, &quot;impossible encoding&quot;);
      __ cmpxchg($mem$$base$$Register, $oldval$$Register, $newval$$Register,
                 Assembler::halfword, /*acquire*/ false, /*release*/ true,
                 /*weak*/ false, noreg);
    %}
  
    enc_class aarch64_enc_cmpxchgb(memory mem, iRegINoSp oldval, iRegINoSp newval) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      guarantee($mem$$index == -1 &amp;&amp; $mem$$disp == 0, &quot;impossible encoding&quot;);
      __ cmpxchg($mem$$base$$Register, $oldval$$Register, $newval$$Register,
                 Assembler::byte, /*acquire*/ false, /*release*/ true,
                 /*weak*/ false, noreg);
    %}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3055,52 ***</span>
    // The only difference between aarch64_enc_cmpxchg and
    // aarch64_enc_cmpxchg_acq is that we use load-acquire in the
    // CompareAndSwap sequence to serve as a barrier on acquiring a
    // lock.
    enc_class aarch64_enc_cmpxchg_acq(memory mem, iRegLNoSp oldval, iRegLNoSp newval) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      guarantee($mem$$index == -1 &amp;&amp; $mem$$disp == 0, &quot;impossible encoding&quot;);
      __ cmpxchg($mem$$base$$Register, $oldval$$Register, $newval$$Register,
                 Assembler::xword, /*acquire*/ true, /*release*/ true,
                 /*weak*/ false, noreg);
    %}
  
    enc_class aarch64_enc_cmpxchgw_acq(memory mem, iRegINoSp oldval, iRegINoSp newval) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      guarantee($mem$$index == -1 &amp;&amp; $mem$$disp == 0, &quot;impossible encoding&quot;);
      __ cmpxchg($mem$$base$$Register, $oldval$$Register, $newval$$Register,
                 Assembler::word, /*acquire*/ true, /*release*/ true,
                 /*weak*/ false, noreg);
    %}
  
    enc_class aarch64_enc_cmpxchgs_acq(memory mem, iRegINoSp oldval, iRegINoSp newval) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      guarantee($mem$$index == -1 &amp;&amp; $mem$$disp == 0, &quot;impossible encoding&quot;);
      __ cmpxchg($mem$$base$$Register, $oldval$$Register, $newval$$Register,
                 Assembler::halfword, /*acquire*/ true, /*release*/ true,
                 /*weak*/ false, noreg);
    %}
  
    enc_class aarch64_enc_cmpxchgb_acq(memory mem, iRegINoSp oldval, iRegINoSp newval) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      guarantee($mem$$index == -1 &amp;&amp; $mem$$disp == 0, &quot;impossible encoding&quot;);
      __ cmpxchg($mem$$base$$Register, $oldval$$Register, $newval$$Register,
                 Assembler::byte, /*acquire*/ true, /*release*/ true,
                 /*weak*/ false, noreg);
    %}
  
    // auxiliary used for CompareAndSwapX to set result register
    enc_class aarch64_enc_cset_eq(iRegINoSp res) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      Register res_reg = as_Register($res$$reg);
      __ cset(res_reg, Assembler::EQ);
    %}
  
    // prefetch encodings
  
    enc_class aarch64_enc_prefetchw(memory mem) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      Register base = as_Register($mem$$base);
      int index = $mem$$index;
      int scale = $mem$$scale;
      int disp = $mem$$disp;
      if (index == -1) {
<span class="line-new-header">--- 3074,52 ---</span>
    // The only difference between aarch64_enc_cmpxchg and
    // aarch64_enc_cmpxchg_acq is that we use load-acquire in the
    // CompareAndSwap sequence to serve as a barrier on acquiring a
    // lock.
    enc_class aarch64_enc_cmpxchg_acq(memory mem, iRegLNoSp oldval, iRegLNoSp newval) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      guarantee($mem$$index == -1 &amp;&amp; $mem$$disp == 0, &quot;impossible encoding&quot;);
      __ cmpxchg($mem$$base$$Register, $oldval$$Register, $newval$$Register,
                 Assembler::xword, /*acquire*/ true, /*release*/ true,
                 /*weak*/ false, noreg);
    %}
  
    enc_class aarch64_enc_cmpxchgw_acq(memory mem, iRegINoSp oldval, iRegINoSp newval) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      guarantee($mem$$index == -1 &amp;&amp; $mem$$disp == 0, &quot;impossible encoding&quot;);
      __ cmpxchg($mem$$base$$Register, $oldval$$Register, $newval$$Register,
                 Assembler::word, /*acquire*/ true, /*release*/ true,
                 /*weak*/ false, noreg);
    %}
  
    enc_class aarch64_enc_cmpxchgs_acq(memory mem, iRegINoSp oldval, iRegINoSp newval) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      guarantee($mem$$index == -1 &amp;&amp; $mem$$disp == 0, &quot;impossible encoding&quot;);
      __ cmpxchg($mem$$base$$Register, $oldval$$Register, $newval$$Register,
                 Assembler::halfword, /*acquire*/ true, /*release*/ true,
                 /*weak*/ false, noreg);
    %}
  
    enc_class aarch64_enc_cmpxchgb_acq(memory mem, iRegINoSp oldval, iRegINoSp newval) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      guarantee($mem$$index == -1 &amp;&amp; $mem$$disp == 0, &quot;impossible encoding&quot;);
      __ cmpxchg($mem$$base$$Register, $oldval$$Register, $newval$$Register,
                 Assembler::byte, /*acquire*/ true, /*release*/ true,
                 /*weak*/ false, noreg);
    %}
  
    // auxiliary used for CompareAndSwapX to set result register
    enc_class aarch64_enc_cset_eq(iRegINoSp res) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register res_reg = as_Register($res$$reg);
      __ cset(res_reg, Assembler::EQ);
    %}
  
    // prefetch encodings
  
    enc_class aarch64_enc_prefetchw(memory mem) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register base = as_Register($mem$$base);
      int index = $mem$$index;
      int scale = $mem$$scale;
      int disp = $mem$$disp;
      if (index == -1) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3117,33 ***</span>
    %}
  
    /// mov envcodings
  
    enc_class aarch64_enc_movw_imm(iRegI dst, immI src) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      u_int32_t con = (u_int32_t)$src$$constant;
      Register dst_reg = as_Register($dst$$reg);
      if (con == 0) {
        __ movw(dst_reg, zr);
      } else {
        __ movw(dst_reg, con);
      }
    %}
  
    enc_class aarch64_enc_mov_imm(iRegL dst, immL src) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      Register dst_reg = as_Register($dst$$reg);
      u_int64_t con = (u_int64_t)$src$$constant;
      if (con == 0) {
        __ mov(dst_reg, zr);
      } else {
        __ mov(dst_reg, con);
      }
    %}
  
    enc_class aarch64_enc_mov_p(iRegP dst, immP src) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      Register dst_reg = as_Register($dst$$reg);
      address con = (address)$src$$constant;
      if (con == NULL || con == (address)1) {
        ShouldNotReachHere();
      } else {
<span class="line-new-header">--- 3136,33 ---</span>
    %}
  
    /// mov envcodings
  
    enc_class aarch64_enc_movw_imm(iRegI dst, immI src) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      u_int32_t con = (u_int32_t)$src$$constant;
      Register dst_reg = as_Register($dst$$reg);
      if (con == 0) {
        __ movw(dst_reg, zr);
      } else {
        __ movw(dst_reg, con);
      }
    %}
  
    enc_class aarch64_enc_mov_imm(iRegL dst, immL src) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register dst_reg = as_Register($dst$$reg);
      u_int64_t con = (u_int64_t)$src$$constant;
      if (con == 0) {
        __ mov(dst_reg, zr);
      } else {
        __ mov(dst_reg, con);
      }
    %}
  
    enc_class aarch64_enc_mov_p(iRegP dst, immP src) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register dst_reg = as_Register($dst$$reg);
      address con = (address)$src$$constant;
      if (con == NULL || con == (address)1) {
        ShouldNotReachHere();
      } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3164,37 ***</span>
        }
      }
    %}
  
    enc_class aarch64_enc_mov_p0(iRegP dst, immP0 src) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      Register dst_reg = as_Register($dst$$reg);
      __ mov(dst_reg, zr);
    %}
  
    enc_class aarch64_enc_mov_p1(iRegP dst, immP_1 src) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      Register dst_reg = as_Register($dst$$reg);
      __ mov(dst_reg, (u_int64_t)1);
    %}
  
<span class="line-removed">-   enc_class aarch64_enc_mov_poll_page(iRegP dst, immPollPage src) %{</span>
<span class="line-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="line-removed">-     address page = (address)$src$$constant;</span>
<span class="line-removed">-     Register dst_reg = as_Register($dst$$reg);</span>
<span class="line-removed">-     unsigned long off;</span>
<span class="line-removed">-     __ adrp(dst_reg, Address(page, relocInfo::poll_type), off);</span>
<span class="line-removed">-     assert(off == 0, &quot;assumed offset == 0&quot;);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">- </span>
    enc_class aarch64_enc_mov_byte_map_base(iRegP dst, immByteMapBase src) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      __ load_byte_map_base($dst$$Register);
    %}
  
    enc_class aarch64_enc_mov_n(iRegN dst, immN src) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      Register dst_reg = as_Register($dst$$reg);
      address con = (address)$src$$constant;
      if (con == NULL) {
        ShouldNotReachHere();
      } else {
<span class="line-new-header">--- 3183,28 ---</span>
        }
      }
    %}
  
    enc_class aarch64_enc_mov_p0(iRegP dst, immP0 src) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register dst_reg = as_Register($dst$$reg);
      __ mov(dst_reg, zr);
    %}
  
    enc_class aarch64_enc_mov_p1(iRegP dst, immP_1 src) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register dst_reg = as_Register($dst$$reg);
      __ mov(dst_reg, (u_int64_t)1);
    %}
  
    enc_class aarch64_enc_mov_byte_map_base(iRegP dst, immByteMapBase src) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      __ load_byte_map_base($dst$$Register);
    %}
  
    enc_class aarch64_enc_mov_n(iRegN dst, immN src) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register dst_reg = as_Register($dst$$reg);
      address con = (address)$src$$constant;
      if (con == NULL) {
        ShouldNotReachHere();
      } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3203,17 ***</span>
        __ set_narrow_oop(dst_reg, (jobject)con);
      }
    %}
  
    enc_class aarch64_enc_mov_n0(iRegN dst, immN0 src) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      Register dst_reg = as_Register($dst$$reg);
      __ mov(dst_reg, zr);
    %}
  
    enc_class aarch64_enc_mov_nk(iRegN dst, immNKlass src) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      Register dst_reg = as_Register($dst$$reg);
      address con = (address)$src$$constant;
      if (con == NULL) {
        ShouldNotReachHere();
      } else {
<span class="line-new-header">--- 3213,17 ---</span>
        __ set_narrow_oop(dst_reg, (jobject)con);
      }
    %}
  
    enc_class aarch64_enc_mov_n0(iRegN dst, immN0 src) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register dst_reg = as_Register($dst$$reg);
      __ mov(dst_reg, zr);
    %}
  
    enc_class aarch64_enc_mov_nk(iRegN dst, immNKlass src) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register dst_reg = as_Register($dst$$reg);
      address con = (address)$src$$constant;
      if (con == NULL) {
        ShouldNotReachHere();
      } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3224,11 ***</span>
    %}
  
    // arithmetic encodings
  
    enc_class aarch64_enc_addsubw_imm(iRegI dst, iRegI src1, immIAddSub src2) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      Register dst_reg = as_Register($dst$$reg);
      Register src_reg = as_Register($src1$$reg);
      int32_t con = (int32_t)$src2$$constant;
      // add has primary == 0, subtract has primary == 1
      if ($primary) { con = -con; }
<span class="line-new-header">--- 3234,11 ---</span>
    %}
  
    // arithmetic encodings
  
    enc_class aarch64_enc_addsubw_imm(iRegI dst, iRegI src1, immIAddSub src2) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register dst_reg = as_Register($dst$$reg);
      Register src_reg = as_Register($src1$$reg);
      int32_t con = (int32_t)$src2$$constant;
      // add has primary == 0, subtract has primary == 1
      if ($primary) { con = -con; }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3238,11 ***</span>
        __ addw(dst_reg, src_reg, con);
      }
    %}
  
    enc_class aarch64_enc_addsub_imm(iRegL dst, iRegL src1, immLAddSub src2) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      Register dst_reg = as_Register($dst$$reg);
      Register src_reg = as_Register($src1$$reg);
      int32_t con = (int32_t)$src2$$constant;
      // add has primary == 0, subtract has primary == 1
      if ($primary) { con = -con; }
<span class="line-new-header">--- 3248,11 ---</span>
        __ addw(dst_reg, src_reg, con);
      }
    %}
  
    enc_class aarch64_enc_addsub_imm(iRegL dst, iRegL src1, immLAddSub src2) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register dst_reg = as_Register($dst$$reg);
      Register src_reg = as_Register($src1$$reg);
      int32_t con = (int32_t)$src2$$constant;
      // add has primary == 0, subtract has primary == 1
      if ($primary) { con = -con; }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3252,78 ***</span>
        __ add(dst_reg, src_reg, con);
      }
    %}
  
    enc_class aarch64_enc_divw(iRegI dst, iRegI src1, iRegI src2) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
     Register dst_reg = as_Register($dst$$reg);
     Register src1_reg = as_Register($src1$$reg);
     Register src2_reg = as_Register($src2$$reg);
      __ corrected_idivl(dst_reg, src1_reg, src2_reg, false, rscratch1);
    %}
  
    enc_class aarch64_enc_div(iRegI dst, iRegI src1, iRegI src2) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
     Register dst_reg = as_Register($dst$$reg);
     Register src1_reg = as_Register($src1$$reg);
     Register src2_reg = as_Register($src2$$reg);
      __ corrected_idivq(dst_reg, src1_reg, src2_reg, false, rscratch1);
    %}
  
    enc_class aarch64_enc_modw(iRegI dst, iRegI src1, iRegI src2) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
     Register dst_reg = as_Register($dst$$reg);
     Register src1_reg = as_Register($src1$$reg);
     Register src2_reg = as_Register($src2$$reg);
      __ corrected_idivl(dst_reg, src1_reg, src2_reg, true, rscratch1);
    %}
  
    enc_class aarch64_enc_mod(iRegI dst, iRegI src1, iRegI src2) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
     Register dst_reg = as_Register($dst$$reg);
     Register src1_reg = as_Register($src1$$reg);
     Register src2_reg = as_Register($src2$$reg);
      __ corrected_idivq(dst_reg, src1_reg, src2_reg, true, rscratch1);
    %}
  
    // compare instruction encodings
  
    enc_class aarch64_enc_cmpw(iRegI src1, iRegI src2) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      Register reg1 = as_Register($src1$$reg);
      Register reg2 = as_Register($src2$$reg);
      __ cmpw(reg1, reg2);
    %}
  
    enc_class aarch64_enc_cmpw_imm_addsub(iRegI src1, immIAddSub src2) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      Register reg = as_Register($src1$$reg);
      int32_t val = $src2$$constant;
      if (val &gt;= 0) {
        __ subsw(zr, reg, val);
      } else {
        __ addsw(zr, reg, -val);
      }
    %}
  
    enc_class aarch64_enc_cmpw_imm(iRegI src1, immI src2) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      Register reg1 = as_Register($src1$$reg);
      u_int32_t val = (u_int32_t)$src2$$constant;
      __ movw(rscratch1, val);
      __ cmpw(reg1, rscratch1);
    %}
  
    enc_class aarch64_enc_cmp(iRegL src1, iRegL src2) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      Register reg1 = as_Register($src1$$reg);
      Register reg2 = as_Register($src2$$reg);
      __ cmp(reg1, reg2);
    %}
  
    enc_class aarch64_enc_cmp_imm_addsub(iRegL src1, immL12 src2) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      Register reg = as_Register($src1$$reg);
      int64_t val = $src2$$constant;
      if (val &gt;= 0) {
        __ subs(zr, reg, val);
      } else if (val != -val) {
<span class="line-new-header">--- 3262,78 ---</span>
        __ add(dst_reg, src_reg, con);
      }
    %}
  
    enc_class aarch64_enc_divw(iRegI dst, iRegI src1, iRegI src2) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
     Register dst_reg = as_Register($dst$$reg);
     Register src1_reg = as_Register($src1$$reg);
     Register src2_reg = as_Register($src2$$reg);
      __ corrected_idivl(dst_reg, src1_reg, src2_reg, false, rscratch1);
    %}
  
    enc_class aarch64_enc_div(iRegI dst, iRegI src1, iRegI src2) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
     Register dst_reg = as_Register($dst$$reg);
     Register src1_reg = as_Register($src1$$reg);
     Register src2_reg = as_Register($src2$$reg);
      __ corrected_idivq(dst_reg, src1_reg, src2_reg, false, rscratch1);
    %}
  
    enc_class aarch64_enc_modw(iRegI dst, iRegI src1, iRegI src2) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
     Register dst_reg = as_Register($dst$$reg);
     Register src1_reg = as_Register($src1$$reg);
     Register src2_reg = as_Register($src2$$reg);
      __ corrected_idivl(dst_reg, src1_reg, src2_reg, true, rscratch1);
    %}
  
    enc_class aarch64_enc_mod(iRegI dst, iRegI src1, iRegI src2) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
     Register dst_reg = as_Register($dst$$reg);
     Register src1_reg = as_Register($src1$$reg);
     Register src2_reg = as_Register($src2$$reg);
      __ corrected_idivq(dst_reg, src1_reg, src2_reg, true, rscratch1);
    %}
  
    // compare instruction encodings
  
    enc_class aarch64_enc_cmpw(iRegI src1, iRegI src2) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register reg1 = as_Register($src1$$reg);
      Register reg2 = as_Register($src2$$reg);
      __ cmpw(reg1, reg2);
    %}
  
    enc_class aarch64_enc_cmpw_imm_addsub(iRegI src1, immIAddSub src2) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register reg = as_Register($src1$$reg);
      int32_t val = $src2$$constant;
      if (val &gt;= 0) {
        __ subsw(zr, reg, val);
      } else {
        __ addsw(zr, reg, -val);
      }
    %}
  
    enc_class aarch64_enc_cmpw_imm(iRegI src1, immI src2) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register reg1 = as_Register($src1$$reg);
      u_int32_t val = (u_int32_t)$src2$$constant;
      __ movw(rscratch1, val);
      __ cmpw(reg1, rscratch1);
    %}
  
    enc_class aarch64_enc_cmp(iRegL src1, iRegL src2) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register reg1 = as_Register($src1$$reg);
      Register reg2 = as_Register($src2$$reg);
      __ cmp(reg1, reg2);
    %}
  
    enc_class aarch64_enc_cmp_imm_addsub(iRegL src1, immL12 src2) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register reg = as_Register($src1$$reg);
      int64_t val = $src2$$constant;
      if (val &gt;= 0) {
        __ subs(zr, reg, val);
      } else if (val != -val) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3334,57 ***</span>
        __ subs(zr, reg, rscratch1);
      }
    %}
  
    enc_class aarch64_enc_cmp_imm(iRegL src1, immL src2) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      Register reg1 = as_Register($src1$$reg);
      u_int64_t val = (u_int64_t)$src2$$constant;
      __ mov(rscratch1, val);
      __ cmp(reg1, rscratch1);
    %}
  
    enc_class aarch64_enc_cmpp(iRegP src1, iRegP src2) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      Register reg1 = as_Register($src1$$reg);
      Register reg2 = as_Register($src2$$reg);
      __ cmp(reg1, reg2);
    %}
  
    enc_class aarch64_enc_cmpn(iRegN src1, iRegN src2) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      Register reg1 = as_Register($src1$$reg);
      Register reg2 = as_Register($src2$$reg);
      __ cmpw(reg1, reg2);
    %}
  
    enc_class aarch64_enc_testp(iRegP src) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      Register reg = as_Register($src$$reg);
      __ cmp(reg, zr);
    %}
  
    enc_class aarch64_enc_testn(iRegN src) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      Register reg = as_Register($src$$reg);
      __ cmpw(reg, zr);
    %}
  
    enc_class aarch64_enc_b(label lbl) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      Label *L = $lbl$$label;
      __ b(*L);
    %}
  
    enc_class aarch64_enc_br_con(cmpOp cmp, label lbl) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      Label *L = $lbl$$label;
      __ br ((Assembler::Condition)$cmp$$cmpcode, *L);
    %}
  
    enc_class aarch64_enc_br_conU(cmpOpU cmp, label lbl) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      Label *L = $lbl$$label;
      __ br ((Assembler::Condition)$cmp$$cmpcode, *L);
    %}
  
    enc_class aarch64_enc_partial_subtype_check(iRegP sub, iRegP super, iRegP temp, iRegP result)
<span class="line-new-header">--- 3344,57 ---</span>
        __ subs(zr, reg, rscratch1);
      }
    %}
  
    enc_class aarch64_enc_cmp_imm(iRegL src1, immL src2) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register reg1 = as_Register($src1$$reg);
      u_int64_t val = (u_int64_t)$src2$$constant;
      __ mov(rscratch1, val);
      __ cmp(reg1, rscratch1);
    %}
  
    enc_class aarch64_enc_cmpp(iRegP src1, iRegP src2) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register reg1 = as_Register($src1$$reg);
      Register reg2 = as_Register($src2$$reg);
      __ cmp(reg1, reg2);
    %}
  
    enc_class aarch64_enc_cmpn(iRegN src1, iRegN src2) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register reg1 = as_Register($src1$$reg);
      Register reg2 = as_Register($src2$$reg);
      __ cmpw(reg1, reg2);
    %}
  
    enc_class aarch64_enc_testp(iRegP src) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register reg = as_Register($src$$reg);
      __ cmp(reg, zr);
    %}
  
    enc_class aarch64_enc_testn(iRegN src) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register reg = as_Register($src$$reg);
      __ cmpw(reg, zr);
    %}
  
    enc_class aarch64_enc_b(label lbl) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Label *L = $lbl$$label;
      __ b(*L);
    %}
  
    enc_class aarch64_enc_br_con(cmpOp cmp, label lbl) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Label *L = $lbl$$label;
      __ br ((Assembler::Condition)$cmp$$cmpcode, *L);
    %}
  
    enc_class aarch64_enc_br_conU(cmpOpU cmp, label lbl) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Label *L = $lbl$$label;
      __ br ((Assembler::Condition)$cmp$$cmpcode, *L);
    %}
  
    enc_class aarch64_enc_partial_subtype_check(iRegP sub, iRegP super, iRegP temp, iRegP result)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3393,22 ***</span>
       Register super_reg = as_Register($super$$reg);
       Register temp_reg = as_Register($temp$$reg);
       Register result_reg = as_Register($result$$reg);
  
       Label miss;
<span class="line-modified">!      MacroAssembler _masm(&amp;cbuf);</span>
       __ check_klass_subtype_slow_path(sub_reg, super_reg, temp_reg, result_reg,
                                       NULL, &amp;miss,
                                       /*set_cond_codes:*/ true);
       if ($primary) {
         __ mov(result_reg, zr);
       }
       __ bind(miss);
    %}
  
    enc_class aarch64_enc_java_static_call(method meth) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
  
      address addr = (address)$meth$$method;
      address call;
      if (!_method) {
        // A call to a runtime wrapper, e.g. new, new_typeArray_Java, uncommon_trap.
<span class="line-new-header">--- 3403,22 ---</span>
       Register super_reg = as_Register($super$$reg);
       Register temp_reg = as_Register($temp$$reg);
       Register result_reg = as_Register($result$$reg);
  
       Label miss;
<span class="line-modified">!      C2_MacroAssembler _masm(&amp;cbuf);</span>
       __ check_klass_subtype_slow_path(sub_reg, super_reg, temp_reg, result_reg,
                                       NULL, &amp;miss,
                                       /*set_cond_codes:*/ true);
       if ($primary) {
         __ mov(result_reg, zr);
       }
       __ bind(miss);
    %}
  
    enc_class aarch64_enc_java_static_call(method meth) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
  
      address addr = (address)$meth$$method;
      address call;
      if (!_method) {
        // A call to a runtime wrapper, e.g. new, new_typeArray_Java, uncommon_trap.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3431,29 ***</span>
        return;
      }
    %}
  
    enc_class aarch64_enc_java_dynamic_call(method meth) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      int method_index = resolved_method_index(cbuf);
      address call = __ ic_call((address)$meth$$method, method_index);
      if (call == NULL) {
        ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
        return;
      }
    %}
  
    enc_class aarch64_enc_call_epilog() %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      if (VerifyStackAtCalls) {
        // Check that stack depth is unchanged: find majik cookie on stack
        __ call_Unimplemented();
      }
    %}
  
    enc_class aarch64_enc_java_to_runtime(method meth) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
  
      // some calls to generated routines (arraycopy code) are scheduled
      // by C2 as runtime calls. if so we can call them using a br (they
      // will be in a reachable segment) otherwise we have to use a blr
      // which loads the absolute address into a register.
<span class="line-new-header">--- 3441,29 ---</span>
        return;
      }
    %}
  
    enc_class aarch64_enc_java_dynamic_call(method meth) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      int method_index = resolved_method_index(cbuf);
      address call = __ ic_call((address)$meth$$method, method_index);
      if (call == NULL) {
        ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
        return;
      }
    %}
  
    enc_class aarch64_enc_call_epilog() %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      if (VerifyStackAtCalls) {
        // Check that stack depth is unchanged: find majik cookie on stack
        __ call_Unimplemented();
      }
    %}
  
    enc_class aarch64_enc_java_to_runtime(method meth) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
  
      // some calls to generated routines (arraycopy code) are scheduled
      // by C2 as runtime calls. if so we can call them using a br (they
      // will be in a reachable segment) otherwise we have to use a blr
      // which loads the absolute address into a register.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3476,37 ***</span>
        __ add(sp, sp, 2 * wordSize);
      }
    %}
  
    enc_class aarch64_enc_rethrow() %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      __ far_jump(RuntimeAddress(OptoRuntime::rethrow_stub()));
    %}
  
    enc_class aarch64_enc_ret() %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      __ ret(lr);
    %}
  
    enc_class aarch64_enc_tail_call(iRegP jump_target) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      Register target_reg = as_Register($jump_target$$reg);
      __ br(target_reg);
    %}
  
    enc_class aarch64_enc_tail_jmp(iRegP jump_target) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      Register target_reg = as_Register($jump_target$$reg);
      // exception oop should be in r0
      // ret addr has been popped into lr
      // callee expects it in r3
      __ mov(r3, lr);
      __ br(target_reg);
    %}
  
    enc_class aarch64_enc_fast_lock(iRegP object, iRegP box, iRegP tmp, iRegP tmp2) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      Register oop = as_Register($object$$reg);
      Register box = as_Register($box$$reg);
      Register disp_hdr = as_Register($tmp$$reg);
      Register tmp = as_Register($tmp2$$reg);
      Label cont;
<span class="line-new-header">--- 3486,37 ---</span>
        __ add(sp, sp, 2 * wordSize);
      }
    %}
  
    enc_class aarch64_enc_rethrow() %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      __ far_jump(RuntimeAddress(OptoRuntime::rethrow_stub()));
    %}
  
    enc_class aarch64_enc_ret() %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      __ ret(lr);
    %}
  
    enc_class aarch64_enc_tail_call(iRegP jump_target) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register target_reg = as_Register($jump_target$$reg);
      __ br(target_reg);
    %}
  
    enc_class aarch64_enc_tail_jmp(iRegP jump_target) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register target_reg = as_Register($jump_target$$reg);
      // exception oop should be in r0
      // ret addr has been popped into lr
      // callee expects it in r3
      __ mov(r3, lr);
      __ br(target_reg);
    %}
  
    enc_class aarch64_enc_fast_lock(iRegP object, iRegP box, iRegP tmp, iRegP tmp2) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register oop = as_Register($object$$reg);
      Register box = as_Register($box$$reg);
      Register disp_hdr = as_Register($tmp$$reg);
      Register tmp = as_Register($tmp2$$reg);
      Label cont;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3580,11 ***</span>
      // flag == EQ indicates success
      // flag == NE indicates failure
    %}
  
    enc_class aarch64_enc_fast_unlock(iRegP object, iRegP box, iRegP tmp, iRegP tmp2) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      Register oop = as_Register($object$$reg);
      Register box = as_Register($box$$reg);
      Register disp_hdr = as_Register($tmp$$reg);
      Register tmp = as_Register($tmp2$$reg);
      Label cont;
<span class="line-new-header">--- 3590,11 ---</span>
      // flag == EQ indicates success
      // flag == NE indicates failure
    %}
  
    enc_class aarch64_enc_fast_unlock(iRegP object, iRegP box, iRegP tmp, iRegP tmp2) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register oop = as_Register($object$$reg);
      Register box = as_Register($box$$reg);
      Register disp_hdr = as_Register($tmp$$reg);
      Register tmp = as_Register($tmp2$$reg);
      Label cont;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4376,21 ***</span>
    op_cost(0);
    format %{ %}
    interface(CONST_INTER);
  %}
  
<span class="line-removed">- // Polling Page Pointer Immediate</span>
<span class="line-removed">- operand immPollPage()</span>
<span class="line-removed">- %{</span>
<span class="line-removed">-   predicate((address)n-&gt;get_ptr() == os::get_polling_page());</span>
<span class="line-removed">-   match(ConP);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   op_cost(0);</span>
<span class="line-removed">-   format %{ %}</span>
<span class="line-removed">-   interface(CONST_INTER);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
  // Card Table Byte Map Base
  operand immByteMapBase()
  %{
    // Get base of card map
    predicate(BarrierSet::barrier_set()-&gt;is_a(BarrierSet::CardTableBarrierSet) &amp;&amp;
<span class="line-new-header">--- 4386,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7183,24 ***</span>
    ins_encode(aarch64_enc_mov_p1(dst, con));
  
    ins_pipe(ialu_imm);
  %}
  
<span class="line-removed">- // Load Poll Page Constant</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct loadConPollPage(iRegPNoSp dst, immPollPage con)</span>
<span class="line-removed">- %{</span>
<span class="line-removed">-   match(Set dst con);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   ins_cost(INSN_COST);</span>
<span class="line-removed">-   format %{ &quot;adr  $dst, $con\t# Poll Page Ptr&quot; %}</span>
<span class="line-removed">- </span>
<span class="line-removed">-   ins_encode(aarch64_enc_mov_poll_page(dst, con));</span>
<span class="line-removed">- </span>
<span class="line-removed">-   ins_pipe(ialu_imm);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
  // Load Byte Map Base Constant
  
  instruct loadByteMapBase(iRegPNoSp dst, immByteMapBase con)
  %{
    match(Set dst con);
<span class="line-new-header">--- 7182,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8073,11 ***</span>
              &quot;cnt    $tmp, $tmp\t# vector (8B)\n\t&quot;
              &quot;addv   $tmp, $tmp\t# vector (8B)\n\t&quot;
              &quot;mov    $dst, $tmp\t# vector (1D)&quot; %}
    ins_encode %{
      FloatRegister tmp_reg = as_FloatRegister($tmp$$reg);
<span class="line-modified">!     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrs, tmp_reg, $mem-&gt;opcode(),</span>
                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);
      __ cnt($tmp$$FloatRegister, __ T8B, $tmp$$FloatRegister);
      __ addv($tmp$$FloatRegister, __ T8B, $tmp$$FloatRegister);
      __ mov($dst$$Register, $tmp$$FloatRegister, __ T1D, 0);
    %}
<span class="line-new-header">--- 8058,11 ---</span>
              &quot;cnt    $tmp, $tmp\t# vector (8B)\n\t&quot;
              &quot;addv   $tmp, $tmp\t# vector (8B)\n\t&quot;
              &quot;mov    $dst, $tmp\t# vector (1D)&quot; %}
    ins_encode %{
      FloatRegister tmp_reg = as_FloatRegister($tmp$$reg);
<span class="line-modified">!     loadStore(C2_MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrs, tmp_reg, $mem-&gt;opcode(),</span>
                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);
      __ cnt($tmp$$FloatRegister, __ T8B, $tmp$$FloatRegister);
      __ addv($tmp$$FloatRegister, __ T8B, $tmp$$FloatRegister);
      __ mov($dst$$Register, $tmp$$FloatRegister, __ T1D, 0);
    %}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8116,11 ***</span>
              &quot;cnt    $tmp, $tmp\t# vector (8B)\n\t&quot;
              &quot;addv   $tmp, $tmp\t# vector (8B)\n\t&quot;
              &quot;mov    $dst, $tmp\t# vector (1D)&quot; %}
    ins_encode %{
      FloatRegister tmp_reg = as_FloatRegister($tmp$$reg);
<span class="line-modified">!     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrd, tmp_reg, $mem-&gt;opcode(),</span>
                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 8);
      __ cnt($tmp$$FloatRegister, __ T8B, $tmp$$FloatRegister);
      __ addv($tmp$$FloatRegister, __ T8B, $tmp$$FloatRegister);
      __ mov($dst$$Register, $tmp$$FloatRegister, __ T1D, 0);
    %}
<span class="line-new-header">--- 8101,11 ---</span>
              &quot;cnt    $tmp, $tmp\t# vector (8B)\n\t&quot;
              &quot;addv   $tmp, $tmp\t# vector (8B)\n\t&quot;
              &quot;mov    $dst, $tmp\t# vector (1D)&quot; %}
    ins_encode %{
      FloatRegister tmp_reg = as_FloatRegister($tmp$$reg);
<span class="line-modified">!     loadStore(C2_MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrd, tmp_reg, $mem-&gt;opcode(),</span>
                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 8);
      __ cnt($tmp$$FloatRegister, __ T8B, $tmp$$FloatRegister);
      __ addv($tmp$$FloatRegister, __ T8B, $tmp$$FloatRegister);
      __ mov($dst$$Register, $tmp$$FloatRegister, __ T1D, 0);
    %}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 14934,36 ***</span>
    ins_short_branch(1);
  %}
  
  instruct cmpL_branch_bit(cmpOpEqNe cmp, iRegL op1, immL op2, immL0 op3, label labl) %{
    match(If cmp (CmpL (AndL op1 op2) op3));
<span class="line-modified">!   predicate(is_power_of_2(n-&gt;in(2)-&gt;in(1)-&gt;in(2)-&gt;get_long()));</span>
    effect(USE labl);
  
    ins_cost(BRANCH_COST);
    format %{ &quot;tb$cmp   $op1, $op2, $labl&quot; %}
    ins_encode %{
      Label* L = $labl$$label;
      Assembler::Condition cond = (Assembler::Condition)$cmp$$cmpcode;
<span class="line-modified">!     int bit = exact_log2($op2$$constant);</span>
      __ tbr(cond, $op1$$Register, bit, *L);
    %}
    ins_pipe(pipe_cmp_branch);
    ins_short_branch(1);
  %}
  
  instruct cmpI_branch_bit(cmpOpEqNe cmp, iRegIorL2I op1, immI op2, immI0 op3, label labl) %{
    match(If cmp (CmpI (AndI op1 op2) op3));
<span class="line-modified">!   predicate(is_power_of_2(n-&gt;in(2)-&gt;in(1)-&gt;in(2)-&gt;get_int()));</span>
    effect(USE labl);
  
    ins_cost(BRANCH_COST);
    format %{ &quot;tb$cmp   $op1, $op2, $labl&quot; %}
    ins_encode %{
      Label* L = $labl$$label;
      Assembler::Condition cond = (Assembler::Condition)$cmp$$cmpcode;
<span class="line-modified">!     int bit = exact_log2($op2$$constant);</span>
      __ tbr(cond, $op1$$Register, bit, *L);
    %}
    ins_pipe(pipe_cmp_branch);
    ins_short_branch(1);
  %}
<span class="line-new-header">--- 14919,36 ---</span>
    ins_short_branch(1);
  %}
  
  instruct cmpL_branch_bit(cmpOpEqNe cmp, iRegL op1, immL op2, immL0 op3, label labl) %{
    match(If cmp (CmpL (AndL op1 op2) op3));
<span class="line-modified">!   predicate(is_power_of_2((julong)n-&gt;in(2)-&gt;in(1)-&gt;in(2)-&gt;get_long()));</span>
    effect(USE labl);
  
    ins_cost(BRANCH_COST);
    format %{ &quot;tb$cmp   $op1, $op2, $labl&quot; %}
    ins_encode %{
      Label* L = $labl$$label;
      Assembler::Condition cond = (Assembler::Condition)$cmp$$cmpcode;
<span class="line-modified">!     int bit = exact_log2_long($op2$$constant);</span>
      __ tbr(cond, $op1$$Register, bit, *L);
    %}
    ins_pipe(pipe_cmp_branch);
    ins_short_branch(1);
  %}
  
  instruct cmpI_branch_bit(cmpOpEqNe cmp, iRegIorL2I op1, immI op2, immI0 op3, label labl) %{
    match(If cmp (CmpI (AndI op1 op2) op3));
<span class="line-modified">!   predicate(is_power_of_2((juint)n-&gt;in(2)-&gt;in(1)-&gt;in(2)-&gt;get_int()));</span>
    effect(USE labl);
  
    ins_cost(BRANCH_COST);
    format %{ &quot;tb$cmp   $op1, $op2, $labl&quot; %}
    ins_encode %{
      Label* L = $labl$$label;
      Assembler::Condition cond = (Assembler::Condition)$cmp$$cmpcode;
<span class="line-modified">!     int bit = exact_log2((juint)$op2$$constant);</span>
      __ tbr(cond, $op1$$Register, bit, *L);
    %}
    ins_pipe(pipe_cmp_branch);
    ins_short_branch(1);
  %}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 14999,35 ***</span>
    ins_pipe(pipe_cmp_branch);
  %}
  
  instruct far_cmpL_branch_bit(cmpOpEqNe cmp, iRegL op1, immL op2, immL0 op3, label labl) %{
    match(If cmp (CmpL (AndL op1 op2) op3));
<span class="line-modified">!   predicate(is_power_of_2(n-&gt;in(2)-&gt;in(1)-&gt;in(2)-&gt;get_long()));</span>
    effect(USE labl);
  
    ins_cost(BRANCH_COST);
    format %{ &quot;tb$cmp   $op1, $op2, $labl&quot; %}
    ins_encode %{
      Label* L = $labl$$label;
      Assembler::Condition cond = (Assembler::Condition)$cmp$$cmpcode;
<span class="line-modified">!     int bit = exact_log2($op2$$constant);</span>
      __ tbr(cond, $op1$$Register, bit, *L, /*far*/true);
    %}
    ins_pipe(pipe_cmp_branch);
  %}
  
  instruct far_cmpI_branch_bit(cmpOpEqNe cmp, iRegIorL2I op1, immI op2, immI0 op3, label labl) %{
    match(If cmp (CmpI (AndI op1 op2) op3));
<span class="line-modified">!   predicate(is_power_of_2(n-&gt;in(2)-&gt;in(1)-&gt;in(2)-&gt;get_int()));</span>
    effect(USE labl);
  
    ins_cost(BRANCH_COST);
    format %{ &quot;tb$cmp   $op1, $op2, $labl&quot; %}
    ins_encode %{
      Label* L = $labl$$label;
      Assembler::Condition cond = (Assembler::Condition)$cmp$$cmpcode;
<span class="line-modified">!     int bit = exact_log2($op2$$constant);</span>
      __ tbr(cond, $op1$$Register, bit, *L, /*far*/true);
    %}
    ins_pipe(pipe_cmp_branch);
  %}
  
<span class="line-new-header">--- 14984,35 ---</span>
    ins_pipe(pipe_cmp_branch);
  %}
  
  instruct far_cmpL_branch_bit(cmpOpEqNe cmp, iRegL op1, immL op2, immL0 op3, label labl) %{
    match(If cmp (CmpL (AndL op1 op2) op3));
<span class="line-modified">!   predicate(is_power_of_2((julong)n-&gt;in(2)-&gt;in(1)-&gt;in(2)-&gt;get_long()));</span>
    effect(USE labl);
  
    ins_cost(BRANCH_COST);
    format %{ &quot;tb$cmp   $op1, $op2, $labl&quot; %}
    ins_encode %{
      Label* L = $labl$$label;
      Assembler::Condition cond = (Assembler::Condition)$cmp$$cmpcode;
<span class="line-modified">!     int bit = exact_log2_long($op2$$constant);</span>
      __ tbr(cond, $op1$$Register, bit, *L, /*far*/true);
    %}
    ins_pipe(pipe_cmp_branch);
  %}
  
  instruct far_cmpI_branch_bit(cmpOpEqNe cmp, iRegIorL2I op1, immI op2, immI0 op3, label labl) %{
    match(If cmp (CmpI (AndI op1 op2) op3));
<span class="line-modified">!   predicate(is_power_of_2((juint)n-&gt;in(2)-&gt;in(1)-&gt;in(2)-&gt;get_int()));</span>
    effect(USE labl);
  
    ins_cost(BRANCH_COST);
    format %{ &quot;tb$cmp   $op1, $op2, $labl&quot; %}
    ins_encode %{
      Label* L = $labl$$label;
      Assembler::Condition cond = (Assembler::Condition)$cmp$$cmpcode;
<span class="line-modified">!     int bit = exact_log2((juint)$op2$$constant);</span>
      __ tbr(cond, $op1$$Register, bit, *L, /*far*/true);
    %}
    ins_pipe(pipe_cmp_branch);
  %}
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 16053,18 ***</span>
    match(Set dst (AddReductionVI src1 src2));
    ins_cost(INSN_COST);
    effect(TEMP tmp, TEMP tmp2);
    format %{ &quot;umov  $tmp, $src2, S, 0\n\t&quot;
              &quot;umov  $tmp2, $src2, S, 1\n\t&quot;
<span class="line-modified">!             &quot;addw  $dst, $src1, $tmp\n\t&quot;</span>
<span class="line-modified">!             &quot;addw  $dst, $dst, $tmp2\t add reduction2i&quot;</span>
    %}
    ins_encode %{
      __ umov($tmp$$Register, as_FloatRegister($src2$$reg), __ S, 0);
      __ umov($tmp2$$Register, as_FloatRegister($src2$$reg), __ S, 1);
<span class="line-modified">!     __ addw($dst$$Register, $src1$$Register, $tmp$$Register);</span>
<span class="line-modified">!     __ addw($dst$$Register, $dst$$Register, $tmp2$$Register);</span>
    %}
    ins_pipe(pipe_class_default);
  %}
  
  instruct reduce_add4I(iRegINoSp dst, iRegIorL2I src1, vecX src2, vecX tmp, iRegINoSp tmp2)
<span class="line-new-header">--- 16038,18 ---</span>
    match(Set dst (AddReductionVI src1 src2));
    ins_cost(INSN_COST);
    effect(TEMP tmp, TEMP tmp2);
    format %{ &quot;umov  $tmp, $src2, S, 0\n\t&quot;
              &quot;umov  $tmp2, $src2, S, 1\n\t&quot;
<span class="line-modified">!             &quot;addw  $tmp, $src1, $tmp\n\t&quot;</span>
<span class="line-modified">!             &quot;addw  $dst, $tmp, $tmp2\t# add reduction2I&quot;</span>
    %}
    ins_encode %{
      __ umov($tmp$$Register, as_FloatRegister($src2$$reg), __ S, 0);
      __ umov($tmp2$$Register, as_FloatRegister($src2$$reg), __ S, 1);
<span class="line-modified">!     __ addw($tmp$$Register, $src1$$Register, $tmp$$Register);</span>
<span class="line-modified">!     __ addw($dst$$Register, $tmp$$Register, $tmp2$$Register);</span>
    %}
    ins_pipe(pipe_class_default);
  %}
  
  instruct reduce_add4I(iRegINoSp dst, iRegIorL2I src1, vecX src2, vecX tmp, iRegINoSp tmp2)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 16072,11 ***</span>
    match(Set dst (AddReductionVI src1 src2));
    ins_cost(INSN_COST);
    effect(TEMP tmp, TEMP tmp2);
    format %{ &quot;addv  $tmp, T4S, $src2\n\t&quot;
              &quot;umov  $tmp2, $tmp, S, 0\n\t&quot;
<span class="line-modified">!             &quot;addw  $dst, $tmp2, $src1\t add reduction4i&quot;</span>
    %}
    ins_encode %{
      __ addv(as_FloatRegister($tmp$$reg), __ T4S,
              as_FloatRegister($src2$$reg));
      __ umov($tmp2$$Register, as_FloatRegister($tmp$$reg), __ S, 0);
<span class="line-new-header">--- 16057,11 ---</span>
    match(Set dst (AddReductionVI src1 src2));
    ins_cost(INSN_COST);
    effect(TEMP tmp, TEMP tmp2);
    format %{ &quot;addv  $tmp, T4S, $src2\n\t&quot;
              &quot;umov  $tmp2, $tmp, S, 0\n\t&quot;
<span class="line-modified">!             &quot;addw  $dst, $tmp2, $src1\t# add reduction4I&quot;</span>
    %}
    ins_encode %{
      __ addv(as_FloatRegister($tmp$$reg), __ T4S,
              as_FloatRegister($src2$$reg));
      __ umov($tmp2$$Register, as_FloatRegister($tmp$$reg), __ S, 0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 16091,11 ***</span>
    ins_cost(INSN_COST);
    effect(TEMP tmp, TEMP dst);
    format %{ &quot;umov  $tmp, $src2, S, 0\n\t&quot;
              &quot;mul   $dst, $tmp, $src1\n\t&quot;
              &quot;umov  $tmp, $src2, S, 1\n\t&quot;
<span class="line-modified">!             &quot;mul   $dst, $tmp, $dst\t mul reduction2i\n\t&quot;</span>
    %}
    ins_encode %{
      __ umov($tmp$$Register, as_FloatRegister($src2$$reg), __ S, 0);
      __ mul($dst$$Register, $tmp$$Register, $src1$$Register);
      __ umov($tmp$$Register, as_FloatRegister($src2$$reg), __ S, 1);
<span class="line-new-header">--- 16076,11 ---</span>
    ins_cost(INSN_COST);
    effect(TEMP tmp, TEMP dst);
    format %{ &quot;umov  $tmp, $src2, S, 0\n\t&quot;
              &quot;mul   $dst, $tmp, $src1\n\t&quot;
              &quot;umov  $tmp, $src2, S, 1\n\t&quot;
<span class="line-modified">!             &quot;mul   $dst, $tmp, $dst\t# mul reduction2I&quot;</span>
    %}
    ins_encode %{
      __ umov($tmp$$Register, as_FloatRegister($src2$$reg), __ S, 0);
      __ mul($dst$$Register, $tmp$$Register, $src1$$Register);
      __ umov($tmp$$Register, as_FloatRegister($src2$$reg), __ S, 1);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 16112,11 ***</span>
    format %{ &quot;ins   $tmp, $src2, 0, 1\n\t&quot;
              &quot;mul   $tmp, $tmp, $src2\n\t&quot;
              &quot;umov  $tmp2, $tmp, S, 0\n\t&quot;
              &quot;mul   $dst, $tmp2, $src1\n\t&quot;
              &quot;umov  $tmp2, $tmp, S, 1\n\t&quot;
<span class="line-modified">!             &quot;mul   $dst, $tmp2, $dst\t mul reduction4i\n\t&quot;</span>
    %}
    ins_encode %{
      __ ins(as_FloatRegister($tmp$$reg), __ D,
             as_FloatRegister($src2$$reg), 0, 1);
      __ mulv(as_FloatRegister($tmp$$reg), __ T2S,
<span class="line-new-header">--- 16097,11 ---</span>
    format %{ &quot;ins   $tmp, $src2, 0, 1\n\t&quot;
              &quot;mul   $tmp, $tmp, $src2\n\t&quot;
              &quot;umov  $tmp2, $tmp, S, 0\n\t&quot;
              &quot;mul   $dst, $tmp2, $src1\n\t&quot;
              &quot;umov  $tmp2, $tmp, S, 1\n\t&quot;
<span class="line-modified">!             &quot;mul   $dst, $tmp2, $dst\t# mul reduction4I&quot;</span>
    %}
    ins_encode %{
      __ ins(as_FloatRegister($tmp$$reg), __ D,
             as_FloatRegister($src2$$reg), 0, 1);
      __ mulv(as_FloatRegister($tmp$$reg), __ T2S,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 16134,11 ***</span>
    match(Set dst (AddReductionVF src1 src2));
    ins_cost(INSN_COST);
    effect(TEMP tmp, TEMP dst);
    format %{ &quot;fadds $dst, $src1, $src2\n\t&quot;
              &quot;ins   $tmp, S, $src2, 0, 1\n\t&quot;
<span class="line-modified">!             &quot;fadds $dst, $dst, $tmp\t add reduction2f&quot;</span>
    %}
    ins_encode %{
      __ fadds(as_FloatRegister($dst$$reg),
               as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));
      __ ins(as_FloatRegister($tmp$$reg), __ S,
<span class="line-new-header">--- 16119,11 ---</span>
    match(Set dst (AddReductionVF src1 src2));
    ins_cost(INSN_COST);
    effect(TEMP tmp, TEMP dst);
    format %{ &quot;fadds $dst, $src1, $src2\n\t&quot;
              &quot;ins   $tmp, S, $src2, 0, 1\n\t&quot;
<span class="line-modified">!             &quot;fadds $dst, $dst, $tmp\t# add reduction2F&quot;</span>
    %}
    ins_encode %{
      __ fadds(as_FloatRegister($dst$$reg),
               as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));
      __ ins(as_FloatRegister($tmp$$reg), __ S,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 16158,11 ***</span>
              &quot;ins   $tmp, S, $src2, 0, 1\n\t&quot;
              &quot;fadds $dst, $dst, $tmp\n\t&quot;
              &quot;ins   $tmp, S, $src2, 0, 2\n\t&quot;
              &quot;fadds $dst, $dst, $tmp\n\t&quot;
              &quot;ins   $tmp, S, $src2, 0, 3\n\t&quot;
<span class="line-modified">!             &quot;fadds $dst, $dst, $tmp\t add reduction4f&quot;</span>
    %}
    ins_encode %{
      __ fadds(as_FloatRegister($dst$$reg),
               as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));
      __ ins(as_FloatRegister($tmp$$reg), __ S,
<span class="line-new-header">--- 16143,11 ---</span>
              &quot;ins   $tmp, S, $src2, 0, 1\n\t&quot;
              &quot;fadds $dst, $dst, $tmp\n\t&quot;
              &quot;ins   $tmp, S, $src2, 0, 2\n\t&quot;
              &quot;fadds $dst, $dst, $tmp\n\t&quot;
              &quot;ins   $tmp, S, $src2, 0, 3\n\t&quot;
<span class="line-modified">!             &quot;fadds $dst, $dst, $tmp\t# add reduction4F&quot;</span>
    %}
    ins_encode %{
      __ fadds(as_FloatRegister($dst$$reg),
               as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));
      __ ins(as_FloatRegister($tmp$$reg), __ S,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 16186,11 ***</span>
    match(Set dst (MulReductionVF src1 src2));
    ins_cost(INSN_COST);
    effect(TEMP tmp, TEMP dst);
    format %{ &quot;fmuls $dst, $src1, $src2\n\t&quot;
              &quot;ins   $tmp, S, $src2, 0, 1\n\t&quot;
<span class="line-modified">!             &quot;fmuls $dst, $dst, $tmp\t add reduction4f&quot;</span>
    %}
    ins_encode %{
      __ fmuls(as_FloatRegister($dst$$reg),
               as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));
      __ ins(as_FloatRegister($tmp$$reg), __ S,
<span class="line-new-header">--- 16171,11 ---</span>
    match(Set dst (MulReductionVF src1 src2));
    ins_cost(INSN_COST);
    effect(TEMP tmp, TEMP dst);
    format %{ &quot;fmuls $dst, $src1, $src2\n\t&quot;
              &quot;ins   $tmp, S, $src2, 0, 1\n\t&quot;
<span class="line-modified">!             &quot;fmuls $dst, $dst, $tmp\t# mul reduction2F&quot;</span>
    %}
    ins_encode %{
      __ fmuls(as_FloatRegister($dst$$reg),
               as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));
      __ ins(as_FloatRegister($tmp$$reg), __ S,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 16210,11 ***</span>
              &quot;ins   $tmp, S, $src2, 0, 1\n\t&quot;
              &quot;fmuls $dst, $dst, $tmp\n\t&quot;
              &quot;ins   $tmp, S, $src2, 0, 2\n\t&quot;
              &quot;fmuls $dst, $dst, $tmp\n\t&quot;
              &quot;ins   $tmp, S, $src2, 0, 3\n\t&quot;
<span class="line-modified">!             &quot;fmuls $dst, $dst, $tmp\t add reduction4f&quot;</span>
    %}
    ins_encode %{
      __ fmuls(as_FloatRegister($dst$$reg),
               as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));
      __ ins(as_FloatRegister($tmp$$reg), __ S,
<span class="line-new-header">--- 16195,11 ---</span>
              &quot;ins   $tmp, S, $src2, 0, 1\n\t&quot;
              &quot;fmuls $dst, $dst, $tmp\n\t&quot;
              &quot;ins   $tmp, S, $src2, 0, 2\n\t&quot;
              &quot;fmuls $dst, $dst, $tmp\n\t&quot;
              &quot;ins   $tmp, S, $src2, 0, 3\n\t&quot;
<span class="line-modified">!             &quot;fmuls $dst, $dst, $tmp\t# mul reduction4F&quot;</span>
    %}
    ins_encode %{
      __ fmuls(as_FloatRegister($dst$$reg),
               as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));
      __ ins(as_FloatRegister($tmp$$reg), __ S,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 16238,11 ***</span>
    match(Set dst (AddReductionVD src1 src2));
    ins_cost(INSN_COST);
    effect(TEMP tmp, TEMP dst);
    format %{ &quot;faddd $dst, $src1, $src2\n\t&quot;
              &quot;ins   $tmp, D, $src2, 0, 1\n\t&quot;
<span class="line-modified">!             &quot;faddd $dst, $dst, $tmp\t add reduction2d&quot;</span>
    %}
    ins_encode %{
      __ faddd(as_FloatRegister($dst$$reg),
               as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));
      __ ins(as_FloatRegister($tmp$$reg), __ D,
<span class="line-new-header">--- 16223,11 ---</span>
    match(Set dst (AddReductionVD src1 src2));
    ins_cost(INSN_COST);
    effect(TEMP tmp, TEMP dst);
    format %{ &quot;faddd $dst, $src1, $src2\n\t&quot;
              &quot;ins   $tmp, D, $src2, 0, 1\n\t&quot;
<span class="line-modified">!             &quot;faddd $dst, $dst, $tmp\t# add reduction2D&quot;</span>
    %}
    ins_encode %{
      __ faddd(as_FloatRegister($dst$$reg),
               as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));
      __ ins(as_FloatRegister($tmp$$reg), __ D,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 16258,11 ***</span>
    match(Set dst (MulReductionVD src1 src2));
    ins_cost(INSN_COST);
    effect(TEMP tmp, TEMP dst);
    format %{ &quot;fmuld $dst, $src1, $src2\n\t&quot;
              &quot;ins   $tmp, D, $src2, 0, 1\n\t&quot;
<span class="line-modified">!             &quot;fmuld $dst, $dst, $tmp\t add reduction2d&quot;</span>
    %}
    ins_encode %{
      __ fmuld(as_FloatRegister($dst$$reg),
               as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));
      __ ins(as_FloatRegister($tmp$$reg), __ D,
<span class="line-new-header">--- 16243,11 ---</span>
    match(Set dst (MulReductionVD src1 src2));
    ins_cost(INSN_COST);
    effect(TEMP tmp, TEMP dst);
    format %{ &quot;fmuld $dst, $src1, $src2\n\t&quot;
              &quot;ins   $tmp, D, $src2, 0, 1\n\t&quot;
<span class="line-modified">!             &quot;fmuld $dst, $dst, $tmp\t# mul reduction2D&quot;</span>
    %}
    ins_encode %{
      __ fmuld(as_FloatRegister($dst$$reg),
               as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));
      __ ins(as_FloatRegister($tmp$$reg), __ D,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 16278,11 ***</span>
    match(Set dst (MaxReductionV src1 src2));
    ins_cost(INSN_COST);
    effect(TEMP_DEF dst, TEMP tmp);
    format %{ &quot;fmaxs $dst, $src1, $src2\n\t&quot;
              &quot;ins   $tmp, S, $src2, 0, 1\n\t&quot;
<span class="line-modified">!             &quot;fmaxs $dst, $dst, $tmp\t max reduction2F&quot; %}</span>
    ins_encode %{
      __ fmaxs(as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));
      __ ins(as_FloatRegister($tmp$$reg), __ S, as_FloatRegister($src2$$reg), 0, 1);
      __ fmaxs(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
    %}
<span class="line-new-header">--- 16263,11 ---</span>
    match(Set dst (MaxReductionV src1 src2));
    ins_cost(INSN_COST);
    effect(TEMP_DEF dst, TEMP tmp);
    format %{ &quot;fmaxs $dst, $src1, $src2\n\t&quot;
              &quot;ins   $tmp, S, $src2, 0, 1\n\t&quot;
<span class="line-modified">!             &quot;fmaxs $dst, $dst, $tmp\t# max reduction2F&quot; %}</span>
    ins_encode %{
      __ fmaxs(as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));
      __ ins(as_FloatRegister($tmp$$reg), __ S, as_FloatRegister($src2$$reg), 0, 1);
      __ fmaxs(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
    %}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 16293,11 ***</span>
    predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;element_basic_type() == T_FLOAT);
    match(Set dst (MaxReductionV src1 src2));
    ins_cost(INSN_COST);
    effect(TEMP_DEF dst);
    format %{ &quot;fmaxv $dst, T4S, $src2\n\t&quot;
<span class="line-modified">!             &quot;fmaxs $dst, $dst, $src1\t max reduction4F&quot; %}</span>
    ins_encode %{
      __ fmaxv(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($src2$$reg));
      __ fmaxs(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));
    %}
    ins_pipe(pipe_class_default);
<span class="line-new-header">--- 16278,11 ---</span>
    predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;element_basic_type() == T_FLOAT);
    match(Set dst (MaxReductionV src1 src2));
    ins_cost(INSN_COST);
    effect(TEMP_DEF dst);
    format %{ &quot;fmaxv $dst, T4S, $src2\n\t&quot;
<span class="line-modified">!             &quot;fmaxs $dst, $dst, $src1\t# max reduction4F&quot; %}</span>
    ins_encode %{
      __ fmaxv(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($src2$$reg));
      __ fmaxs(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));
    %}
    ins_pipe(pipe_class_default);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 16308,11 ***</span>
    match(Set dst (MaxReductionV src1 src2));
    ins_cost(INSN_COST);
    effect(TEMP_DEF dst, TEMP tmp);
    format %{ &quot;fmaxd $dst, $src1, $src2\n\t&quot;
              &quot;ins   $tmp, D, $src2, 0, 1\n\t&quot;
<span class="line-modified">!             &quot;fmaxd $dst, $dst, $tmp\t max reduction2D&quot; %}</span>
    ins_encode %{
      __ fmaxd(as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));
      __ ins(as_FloatRegister($tmp$$reg), __ D, as_FloatRegister($src2$$reg), 0, 1);
      __ fmaxd(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
    %}
<span class="line-new-header">--- 16293,11 ---</span>
    match(Set dst (MaxReductionV src1 src2));
    ins_cost(INSN_COST);
    effect(TEMP_DEF dst, TEMP tmp);
    format %{ &quot;fmaxd $dst, $src1, $src2\n\t&quot;
              &quot;ins   $tmp, D, $src2, 0, 1\n\t&quot;
<span class="line-modified">!             &quot;fmaxd $dst, $dst, $tmp\t# max reduction2D&quot; %}</span>
    ins_encode %{
      __ fmaxd(as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));
      __ ins(as_FloatRegister($tmp$$reg), __ D, as_FloatRegister($src2$$reg), 0, 1);
      __ fmaxd(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
    %}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 16324,11 ***</span>
    match(Set dst (MinReductionV src1 src2));
    ins_cost(INSN_COST);
    effect(TEMP_DEF dst, TEMP tmp);
    format %{ &quot;fmins $dst, $src1, $src2\n\t&quot;
              &quot;ins   $tmp, S, $src2, 0, 1\n\t&quot;
<span class="line-modified">!             &quot;fmins $dst, $dst, $tmp\t min reduction2F&quot; %}</span>
    ins_encode %{
      __ fmins(as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));
      __ ins(as_FloatRegister($tmp$$reg), __ S, as_FloatRegister($src2$$reg), 0, 1);
      __ fmins(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
    %}
<span class="line-new-header">--- 16309,11 ---</span>
    match(Set dst (MinReductionV src1 src2));
    ins_cost(INSN_COST);
    effect(TEMP_DEF dst, TEMP tmp);
    format %{ &quot;fmins $dst, $src1, $src2\n\t&quot;
              &quot;ins   $tmp, S, $src2, 0, 1\n\t&quot;
<span class="line-modified">!             &quot;fmins $dst, $dst, $tmp\t# min reduction2F&quot; %}</span>
    ins_encode %{
      __ fmins(as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));
      __ ins(as_FloatRegister($tmp$$reg), __ S, as_FloatRegister($src2$$reg), 0, 1);
      __ fmins(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
    %}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 16339,11 ***</span>
    predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;element_basic_type() == T_FLOAT);
    match(Set dst (MinReductionV src1 src2));
    ins_cost(INSN_COST);
    effect(TEMP_DEF dst);
    format %{ &quot;fminv $dst, T4S, $src2\n\t&quot;
<span class="line-modified">!             &quot;fmins $dst, $dst, $src1\t min reduction4F&quot; %}</span>
    ins_encode %{
      __ fminv(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($src2$$reg));
      __ fmins(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));
    %}
    ins_pipe(pipe_class_default);
<span class="line-new-header">--- 16324,11 ---</span>
    predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;element_basic_type() == T_FLOAT);
    match(Set dst (MinReductionV src1 src2));
    ins_cost(INSN_COST);
    effect(TEMP_DEF dst);
    format %{ &quot;fminv $dst, T4S, $src2\n\t&quot;
<span class="line-modified">!             &quot;fmins $dst, $dst, $src1\t# min reduction4F&quot; %}</span>
    ins_encode %{
      __ fminv(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($src2$$reg));
      __ fmins(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));
    %}
    ins_pipe(pipe_class_default);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 16354,11 ***</span>
    match(Set dst (MinReductionV src1 src2));
    ins_cost(INSN_COST);
    effect(TEMP_DEF dst, TEMP tmp);
    format %{ &quot;fmind $dst, $src1, $src2\n\t&quot;
              &quot;ins   $tmp, D, $src2, 0, 1\n\t&quot;
<span class="line-modified">!             &quot;fmind $dst, $dst, $tmp\t min reduction2D&quot; %}</span>
    ins_encode %{
      __ fmind(as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));
      __ ins(as_FloatRegister($tmp$$reg), __ D, as_FloatRegister($src2$$reg), 0, 1);
      __ fmind(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
    %}
<span class="line-new-header">--- 16339,11 ---</span>
    match(Set dst (MinReductionV src1 src2));
    ins_cost(INSN_COST);
    effect(TEMP_DEF dst, TEMP tmp);
    format %{ &quot;fmind $dst, $src1, $src2\n\t&quot;
              &quot;ins   $tmp, D, $src2, 0, 1\n\t&quot;
<span class="line-modified">!             &quot;fmind $dst, $dst, $tmp\t# min reduction2D&quot; %}</span>
    ins_encode %{
      __ fmind(as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));
      __ ins(as_FloatRegister($tmp$$reg), __ D, as_FloatRegister($src2$$reg), 0, 1);
      __ fmind(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
    %}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 16964,11 ***</span>
  
  instruct vmuladdS2I(vecX dst, vecX src1, vecX src2, vecX tmp) %{
    predicate(n-&gt;in(1)-&gt;bottom_type()-&gt;is_vect()-&gt;element_basic_type() == T_SHORT);
    match(Set dst (MulAddVS2VI src1 src2));
    ins_cost(INSN_COST);
<span class="line-modified">!   effect(TEMP tmp);</span>
    format %{ &quot;smullv  $tmp, $src1, $src2\t# vector (4H)\n\t&quot;
              &quot;smullv  $dst, $src1, $src2\t# vector (8H)\n\t&quot;
              &quot;addpv   $dst, $tmp, $dst\t# vector (4S)\n\t&quot; %}
    ins_encode %{
      __ smullv(as_FloatRegister($tmp$$reg), __ T4H,
<span class="line-new-header">--- 16949,11 ---</span>
  
  instruct vmuladdS2I(vecX dst, vecX src1, vecX src2, vecX tmp) %{
    predicate(n-&gt;in(1)-&gt;bottom_type()-&gt;is_vect()-&gt;element_basic_type() == T_SHORT);
    match(Set dst (MulAddVS2VI src1 src2));
    ins_cost(INSN_COST);
<span class="line-modified">!   effect(TEMP_DEF dst, TEMP tmp);</span>
    format %{ &quot;smullv  $tmp, $src1, $src2\t# vector (4H)\n\t&quot;
              &quot;smullv  $dst, $src1, $src2\t# vector (8H)\n\t&quot;
              &quot;addpv   $dst, $tmp, $dst\t# vector (4S)\n\t&quot; %}
    ins_encode %{
      __ smullv(as_FloatRegister($tmp$$reg), __ T4H,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 18032,10 ***</span>
<span class="line-new-header">--- 18017,48 ---</span>
      }
    %}
    ins_pipe(vdop_fp128);
  %}
  
<span class="line-added">+ instruct vpopcount4I(vecX dst, vecX src) %{</span>
<span class="line-added">+   predicate(UsePopCountInstruction &amp;&amp; n-&gt;as_Vector()-&gt;length() == 4);</span>
<span class="line-added">+   match(Set dst (PopCountVI src));</span>
<span class="line-added">+   format %{</span>
<span class="line-added">+     &quot;cnt     $dst, $src\t# vector (16B)\n\t&quot;</span>
<span class="line-added">+     &quot;uaddlp  $dst, $dst\t# vector (16B)\n\t&quot;</span>
<span class="line-added">+     &quot;uaddlp  $dst, $dst\t# vector (8H)&quot;</span>
<span class="line-added">+   %}</span>
<span class="line-added">+   ins_encode %{</span>
<span class="line-added">+      __ cnt(as_FloatRegister($dst$$reg), __ T16B,</span>
<span class="line-added">+             as_FloatRegister($src$$reg));</span>
<span class="line-added">+      __ uaddlp(as_FloatRegister($dst$$reg), __ T16B,</span>
<span class="line-added">+                as_FloatRegister($dst$$reg));</span>
<span class="line-added">+      __ uaddlp(as_FloatRegister($dst$$reg), __ T8H,</span>
<span class="line-added">+                as_FloatRegister($dst$$reg));</span>
<span class="line-added">+   %}</span>
<span class="line-added">+   ins_pipe(pipe_class_default);</span>
<span class="line-added">+ %}</span>
<span class="line-added">+ </span>
<span class="line-added">+ instruct vpopcount2I(vecD dst, vecD src) %{</span>
<span class="line-added">+   predicate(UsePopCountInstruction &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);</span>
<span class="line-added">+   match(Set dst (PopCountVI src));</span>
<span class="line-added">+   format %{</span>
<span class="line-added">+     &quot;cnt     $dst, $src\t# vector (8B)\n\t&quot;</span>
<span class="line-added">+     &quot;uaddlp  $dst, $dst\t# vector (8B)\n\t&quot;</span>
<span class="line-added">+     &quot;uaddlp  $dst, $dst\t# vector (4H)&quot;</span>
<span class="line-added">+   %}</span>
<span class="line-added">+   ins_encode %{</span>
<span class="line-added">+      __ cnt(as_FloatRegister($dst$$reg), __ T8B,</span>
<span class="line-added">+             as_FloatRegister($src$$reg));</span>
<span class="line-added">+      __ uaddlp(as_FloatRegister($dst$$reg), __ T8B,</span>
<span class="line-added">+                as_FloatRegister($dst$$reg));</span>
<span class="line-added">+      __ uaddlp(as_FloatRegister($dst$$reg), __ T4H,</span>
<span class="line-added">+                as_FloatRegister($dst$$reg));</span>
<span class="line-added">+   %}</span>
<span class="line-added">+   ins_pipe(pipe_class_default);</span>
<span class="line-added">+ %}</span>
<span class="line-added">+ </span>
  //----------PEEPHOLE RULES-----------------------------------------------------
  // These must follow all instruction definitions as they use the names
  // defined in the instructions definitions.
  //
  // peepmatch ( root_instr_name [preceding_instruction]* );
</pre>
<center><a href="../../../demo/share/jfc/TableExample/TableSorter.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="assembler_aarch64.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
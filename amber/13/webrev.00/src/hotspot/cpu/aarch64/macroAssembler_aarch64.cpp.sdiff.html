<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="interp_masm_aarch64.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_aarch64.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  37 #include &quot;compiler/disassembler.hpp&quot;
  38 #include &quot;memory/resourceArea.hpp&quot;
  39 #include &quot;memory/universe.hpp&quot;
  40 #include &quot;nativeInst_aarch64.hpp&quot;
  41 #include &quot;oops/accessDecorators.hpp&quot;
  42 #include &quot;oops/compressedOops.inline.hpp&quot;
  43 #include &quot;oops/klass.inline.hpp&quot;
  44 #include &quot;runtime/biasedLocking.hpp&quot;
  45 #include &quot;runtime/icache.hpp&quot;
  46 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  47 #include &quot;runtime/jniHandles.inline.hpp&quot;
  48 #include &quot;runtime/sharedRuntime.hpp&quot;
  49 #include &quot;runtime/thread.hpp&quot;
  50 #include &quot;utilities/powerOfTwo.hpp&quot;
  51 #ifdef COMPILER1
  52 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  53 #endif
  54 #ifdef COMPILER2
  55 #include &quot;oops/oop.hpp&quot;
  56 #include &quot;opto/compile.hpp&quot;
<span class="line-removed">  57 #include &quot;opto/intrinsicnode.hpp&quot;</span>
  58 #include &quot;opto/node.hpp&quot;

  59 #endif
  60 
  61 #ifdef PRODUCT
  62 #define BLOCK_COMMENT(str) /* nothing */
  63 #define STOP(error) stop(error)
  64 #else
  65 #define BLOCK_COMMENT(str) block_comment(str)
  66 #define STOP(error) block_comment(error); stop(error)
  67 #endif
  68 
  69 #define BIND(label) bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
  70 
  71 // Patch any kind of instruction; there may be several instructions.
  72 // Return the total length (in bytes) of the instructions.
  73 int MacroAssembler::pd_patch_instruction_size(address branch, address target) {
  74   int instructions = 1;
  75   assert((uint64_t)target &lt; (1ul &lt;&lt; 48), &quot;48-bit overflow in address constant&quot;);
  76   long offset = (target - branch) &gt;&gt; 2;
  77   unsigned insn = *(unsigned*)branch;
  78   if ((Instruction_aarch64::extract(insn, 29, 24) &amp; 0b111011) == 0b011000) {
</pre>
<hr />
<pre>
 274       ShouldNotReachHere();
 275     }
 276   } else if (Instruction_aarch64::extract(insn, 31, 23) == 0b110100101) {
 277     u_int32_t *insns = (u_int32_t *)insn_addr;
 278     // Move wide constant: movz, movk, movk.  See movptr().
 279     assert(nativeInstruction_at(insns+1)-&gt;is_movk(), &quot;wrong insns in patch&quot;);
 280     assert(nativeInstruction_at(insns+2)-&gt;is_movk(), &quot;wrong insns in patch&quot;);
 281     return address(u_int64_t(Instruction_aarch64::extract(insns[0], 20, 5))
 282                    + (u_int64_t(Instruction_aarch64::extract(insns[1], 20, 5)) &lt;&lt; 16)
 283                    + (u_int64_t(Instruction_aarch64::extract(insns[2], 20, 5)) &lt;&lt; 32));
 284   } else if (Instruction_aarch64::extract(insn, 31, 22) == 0b1011100101 &amp;&amp;
 285              Instruction_aarch64::extract(insn, 4, 0) == 0b11111) {
 286     return 0;
 287   } else {
 288     ShouldNotReachHere();
 289   }
 290   return address(((uint64_t)insn_addr + (offset &lt;&lt; 2)));
 291 }
 292 
 293 void MacroAssembler::safepoint_poll(Label&amp; slow_path) {
<span class="line-modified"> 294   if (SafepointMechanism::uses_thread_local_poll()) {</span>
<span class="line-modified"> 295     ldr(rscratch1, Address(rthread, Thread::polling_page_offset()));</span>
<span class="line-removed"> 296     tbnz(rscratch1, exact_log2(SafepointMechanism::poll_bit()), slow_path);</span>
<span class="line-removed"> 297   } else {</span>
<span class="line-removed"> 298     unsigned long offset;</span>
<span class="line-removed"> 299     adrp(rscratch1, ExternalAddress(SafepointSynchronize::address_of_state()), offset);</span>
<span class="line-removed"> 300     ldrw(rscratch1, Address(rscratch1, offset));</span>
<span class="line-removed"> 301     assert(SafepointSynchronize::_not_synchronized == 0, &quot;rewrite this code&quot;);</span>
<span class="line-removed"> 302     cbnz(rscratch1, slow_path);</span>
<span class="line-removed"> 303   }</span>
 304 }
 305 
 306 // Just like safepoint_poll, but use an acquiring load for thread-
 307 // local polling.
 308 //
 309 // We need an acquire here to ensure that any subsequent load of the
 310 // global SafepointSynchronize::_state flag is ordered after this load
 311 // of the local Thread::_polling page.  We don&#39;t want this poll to
 312 // return false (i.e. not safepointing) and a later poll of the global
 313 // SafepointSynchronize::_state spuriously to return true.
 314 //
 315 // This is to avoid a race when we&#39;re in a native-&gt;Java transition
 316 // racing the code which wakes up from a safepoint.
 317 //
 318 void MacroAssembler::safepoint_poll_acquire(Label&amp; slow_path) {
<span class="line-modified"> 319   if (SafepointMechanism::uses_thread_local_poll()) {</span>
<span class="line-modified"> 320     lea(rscratch1, Address(rthread, Thread::polling_page_offset()));</span>
<span class="line-modified"> 321     ldar(rscratch1, rscratch1);</span>
<span class="line-removed"> 322     tbnz(rscratch1, exact_log2(SafepointMechanism::poll_bit()), slow_path);</span>
<span class="line-removed"> 323   } else {</span>
<span class="line-removed"> 324     safepoint_poll(slow_path);</span>
<span class="line-removed"> 325   }</span>
 326 }
 327 
 328 void MacroAssembler::reset_last_Java_frame(bool clear_fp) {
 329   // we must set sp to zero to clear frame
 330   str(zr, Address(rthread, JavaThread::last_Java_sp_offset()));
 331 
 332   // must clear fp, so that compiled frames are not confused; it is
 333   // possible that we need it only for debugging
 334   if (clear_fp) {
 335     str(zr, Address(rthread, JavaThread::last_Java_fp_offset()));
 336   }
 337 
 338   // Always clear the pc because it could have been set by make_walkable()
 339   str(zr, Address(rthread, JavaThread::last_Java_pc_offset()));
 340 }
 341 
 342 // Calls to C land
 343 //
 344 // When entering C land, the rfp, &amp; resp of the last Java frame have to be recorded
 345 // in the (thread-local) JavaThread object. When leaving C land, the last Java fp
</pre>
<hr />
<pre>
 728 
 729 // Maybe emit a call via a trampoline.  If the code cache is small
 730 // trampolines won&#39;t be emitted.
 731 
 732 address MacroAssembler::trampoline_call(Address entry, CodeBuffer *cbuf) {
 733   assert(JavaThread::current()-&gt;is_Compiler_thread(), &quot;just checking&quot;);
 734   assert(entry.rspec().type() == relocInfo::runtime_call_type
 735          || entry.rspec().type() == relocInfo::opt_virtual_call_type
 736          || entry.rspec().type() == relocInfo::static_call_type
 737          || entry.rspec().type() == relocInfo::virtual_call_type, &quot;wrong reloc type&quot;);
 738 
 739   // We need a trampoline if branches are far.
 740   if (far_branches()) {
 741     bool in_scratch_emit_size = false;
 742 #ifdef COMPILER2
 743     // We don&#39;t want to emit a trampoline if C2 is generating dummy
 744     // code during its branch shortening phase.
 745     CompileTask* task = ciEnv::current()-&gt;task();
 746     in_scratch_emit_size =
 747       (task != NULL &amp;&amp; is_c2_compile(task-&gt;comp_level()) &amp;&amp;
<span class="line-modified"> 748        Compile::current()-&gt;in_scratch_emit_size());</span>
 749 #endif
 750     if (!in_scratch_emit_size) {
 751       address stub = emit_trampoline_stub(offset(), entry.target());
 752       if (stub == NULL) {
 753         return NULL; // CodeCache is full
 754       }
 755     }
 756   }
 757 
 758   if (cbuf) cbuf-&gt;set_insts_mark();
 759   relocate(entry.rspec());
 760   if (!far_branches()) {
 761     bl(entry.target());
 762   } else {
 763     bl(pc());
 764   }
 765   // just need to return a non-null address
 766   return pc();
 767 }
 768 
</pre>
<hr />
<pre>
4288   bind(loop);
4289   lea(tmp, Address(tmp, -os::vm_page_size()));
4290   subsw(size, size, rscratch1);
4291   str(size, Address(tmp));
4292   br(Assembler::GT, loop);
4293 
4294   // Bang down shadow pages too.
4295   // At this point, (tmp-0) is the last address touched, so don&#39;t
4296   // touch it again.  (It was touched as (tmp-pagesize) but then tmp
4297   // was post-decremented.)  Skip this address by starting at i=1, and
4298   // touch a few more pages below.  N.B.  It is important to touch all
4299   // the way down to and including i=StackShadowPages.
4300   for (int i = 0; i &lt; (int)(JavaThread::stack_shadow_zone_size() / os::vm_page_size()) - 1; i++) {
4301     // this could be any sized move but this is can be a debugging crumb
4302     // so the bigger the better.
4303     lea(tmp, Address(tmp, -os::vm_page_size()));
4304     str(size, Address(tmp));
4305   }
4306 }
4307 
<span class="line-removed">4308 </span>
4309 // Move the address of the polling page into dest.
<span class="line-modified">4310 void MacroAssembler::get_polling_page(Register dest, address page, relocInfo::relocType rtype) {</span>
<span class="line-modified">4311   if (SafepointMechanism::uses_thread_local_poll()) {</span>
<span class="line-removed">4312     ldr(dest, Address(rthread, Thread::polling_page_offset()));</span>
<span class="line-removed">4313   } else {</span>
<span class="line-removed">4314     unsigned long off;</span>
<span class="line-removed">4315     adrp(dest, Address(page, rtype), off);</span>
<span class="line-removed">4316     assert(off == 0, &quot;polling page must be page aligned&quot;);</span>
<span class="line-removed">4317   }</span>
4318 }
4319 
4320 // Move the address of the polling page into r, then read the polling
4321 // page.
<span class="line-modified">4322 address MacroAssembler::read_polling_page(Register r, address page, relocInfo::relocType rtype) {</span>
<span class="line-modified">4323   get_polling_page(r, page, rtype);</span>
4324   return read_polling_page(r, rtype);
4325 }
4326 
4327 // Read the polling page.  The address of the polling page must
4328 // already be in r.
4329 address MacroAssembler::read_polling_page(Register r, relocInfo::relocType rtype) {
4330   InstructionMark im(this);
4331   code_section()-&gt;relocate(inst_mark(), rtype);
4332   ldrw(zr, Address(r, 0));
4333   return inst_mark();
4334 }
4335 
4336 void MacroAssembler::adrp(Register reg1, const Address &amp;dest, unsigned long &amp;byte_offset) {
4337   relocInfo::relocType rtype = dest.rspec().reloc()-&gt;type();
4338   unsigned long low_page = (unsigned long)CodeCache::low_bound() &gt;&gt; 12;
4339   unsigned long high_page = (unsigned long)(CodeCache::high_bound()-1) &gt;&gt; 12;
4340   unsigned long dest_page = (unsigned long)dest.target() &gt;&gt; 12;
4341   long offset_low = dest_page - low_page;
4342   long offset_high = dest_page - high_page;
4343 
</pre>
<hr />
<pre>
4396     }
4397   }
4398 }
4399 
4400 void MacroAssembler::remove_frame(int framesize) {
4401   assert(framesize &gt; 0, &quot;framesize must be &gt; 0&quot;);
4402   if (framesize &lt; ((1 &lt;&lt; 9) + 2 * wordSize)) {
4403     ldp(rfp, lr, Address(sp, framesize - 2 * wordSize));
4404     add(sp, sp, framesize);
4405   } else {
4406     if (framesize &lt; ((1 &lt;&lt; 12) + 2 * wordSize))
4407       add(sp, sp, framesize - 2 * wordSize);
4408     else {
4409       mov(rscratch1, framesize - 2 * wordSize);
4410       add(sp, sp, rscratch1);
4411     }
4412     ldp(rfp, lr, Address(post(sp, 2 * wordSize)));
4413   }
4414 }
4415 
<span class="line-removed">4416 #ifdef COMPILER2</span>
<span class="line-removed">4417 typedef void (MacroAssembler::* chr_insn)(Register Rt, const Address &amp;adr);</span>
<span class="line-removed">4418 </span>
<span class="line-removed">4419 // Search for str1 in str2 and return index or -1</span>
<span class="line-removed">4420 void MacroAssembler::string_indexof(Register str2, Register str1,</span>
<span class="line-removed">4421                                     Register cnt2, Register cnt1,</span>
<span class="line-removed">4422                                     Register tmp1, Register tmp2,</span>
<span class="line-removed">4423                                     Register tmp3, Register tmp4,</span>
<span class="line-removed">4424                                     Register tmp5, Register tmp6,</span>
<span class="line-removed">4425                                     int icnt1, Register result, int ae) {</span>
<span class="line-removed">4426   // NOTE: tmp5, tmp6 can be zr depending on specific method version</span>
<span class="line-removed">4427   Label LINEARSEARCH, LINEARSTUB, LINEAR_MEDIUM, DONE, NOMATCH, MATCH;</span>
<span class="line-removed">4428 </span>
<span class="line-removed">4429   Register ch1 = rscratch1;</span>
<span class="line-removed">4430   Register ch2 = rscratch2;</span>
<span class="line-removed">4431   Register cnt1tmp = tmp1;</span>
<span class="line-removed">4432   Register cnt2tmp = tmp2;</span>
<span class="line-removed">4433   Register cnt1_neg = cnt1;</span>
<span class="line-removed">4434   Register cnt2_neg = cnt2;</span>
<span class="line-removed">4435   Register result_tmp = tmp4;</span>
<span class="line-removed">4436 </span>
<span class="line-removed">4437   bool isL = ae == StrIntrinsicNode::LL;</span>
<span class="line-removed">4438 </span>
<span class="line-removed">4439   bool str1_isL = ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UL;</span>
<span class="line-removed">4440   bool str2_isL = ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::LU;</span>
<span class="line-removed">4441   int str1_chr_shift = str1_isL ? 0:1;</span>
<span class="line-removed">4442   int str2_chr_shift = str2_isL ? 0:1;</span>
<span class="line-removed">4443   int str1_chr_size = str1_isL ? 1:2;</span>
<span class="line-removed">4444   int str2_chr_size = str2_isL ? 1:2;</span>
<span class="line-removed">4445   chr_insn str1_load_1chr = str1_isL ? (chr_insn)&amp;MacroAssembler::ldrb :</span>
<span class="line-removed">4446                                       (chr_insn)&amp;MacroAssembler::ldrh;</span>
<span class="line-removed">4447   chr_insn str2_load_1chr = str2_isL ? (chr_insn)&amp;MacroAssembler::ldrb :</span>
<span class="line-removed">4448                                       (chr_insn)&amp;MacroAssembler::ldrh;</span>
<span class="line-removed">4449   chr_insn load_2chr = isL ? (chr_insn)&amp;MacroAssembler::ldrh : (chr_insn)&amp;MacroAssembler::ldrw;</span>
<span class="line-removed">4450   chr_insn load_4chr = isL ? (chr_insn)&amp;MacroAssembler::ldrw : (chr_insn)&amp;MacroAssembler::ldr;</span>
<span class="line-removed">4451 </span>
<span class="line-removed">4452   // Note, inline_string_indexOf() generates checks:</span>
<span class="line-removed">4453   // if (substr.count &gt; string.count) return -1;</span>
<span class="line-removed">4454   // if (substr.count == 0) return 0;</span>
<span class="line-removed">4455 </span>
<span class="line-removed">4456   // We have two strings, a source string in str2, cnt2 and a pattern string</span>
<span class="line-removed">4457   // in str1, cnt1. Find the 1st occurence of pattern in source or return -1.</span>
<span class="line-removed">4458 </span>
<span class="line-removed">4459   // For larger pattern and source we use a simplified Boyer Moore algorithm.</span>
<span class="line-removed">4460   // With a small pattern and source we use linear scan.</span>
<span class="line-removed">4461 </span>
<span class="line-removed">4462   if (icnt1 == -1) {</span>
<span class="line-removed">4463     sub(result_tmp, cnt2, cnt1);</span>
<span class="line-removed">4464     cmp(cnt1, (u1)8);             // Use Linear Scan if cnt1 &lt; 8 || cnt1 &gt;= 256</span>
<span class="line-removed">4465     br(LT, LINEARSEARCH);</span>
<span class="line-removed">4466     dup(v0, T16B, cnt1); // done in separate FPU pipeline. Almost no penalty</span>
<span class="line-removed">4467     subs(zr, cnt1, 256);</span>
<span class="line-removed">4468     lsr(tmp1, cnt2, 2);</span>
<span class="line-removed">4469     ccmp(cnt1, tmp1, 0b0000, LT); // Source must be 4 * pattern for BM</span>
<span class="line-removed">4470     br(GE, LINEARSTUB);</span>
<span class="line-removed">4471   }</span>
<span class="line-removed">4472 </span>
<span class="line-removed">4473 // The Boyer Moore alogorithm is based on the description here:-</span>
<span class="line-removed">4474 //</span>
<span class="line-removed">4475 // http://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm</span>
<span class="line-removed">4476 //</span>
<span class="line-removed">4477 // This describes and algorithm with 2 shift rules. The &#39;Bad Character&#39; rule</span>
<span class="line-removed">4478 // and the &#39;Good Suffix&#39; rule.</span>
<span class="line-removed">4479 //</span>
<span class="line-removed">4480 // These rules are essentially heuristics for how far we can shift the</span>
<span class="line-removed">4481 // pattern along the search string.</span>
<span class="line-removed">4482 //</span>
<span class="line-removed">4483 // The implementation here uses the &#39;Bad Character&#39; rule only because of the</span>
<span class="line-removed">4484 // complexity of initialisation for the &#39;Good Suffix&#39; rule.</span>
<span class="line-removed">4485 //</span>
<span class="line-removed">4486 // This is also known as the Boyer-Moore-Horspool algorithm:-</span>
<span class="line-removed">4487 //</span>
<span class="line-removed">4488 // http://en.wikipedia.org/wiki/Boyer-Moore-Horspool_algorithm</span>
<span class="line-removed">4489 //</span>
<span class="line-removed">4490 // This particular implementation has few java-specific optimizations.</span>
<span class="line-removed">4491 //</span>
<span class="line-removed">4492 // #define ASIZE 256</span>
<span class="line-removed">4493 //</span>
<span class="line-removed">4494 //    int bm(unsigned char *x, int m, unsigned char *y, int n) {</span>
<span class="line-removed">4495 //       int i, j;</span>
<span class="line-removed">4496 //       unsigned c;</span>
<span class="line-removed">4497 //       unsigned char bc[ASIZE];</span>
<span class="line-removed">4498 //</span>
<span class="line-removed">4499 //       /* Preprocessing */</span>
<span class="line-removed">4500 //       for (i = 0; i &lt; ASIZE; ++i)</span>
<span class="line-removed">4501 //          bc[i] = m;</span>
<span class="line-removed">4502 //       for (i = 0; i &lt; m - 1; ) {</span>
<span class="line-removed">4503 //          c = x[i];</span>
<span class="line-removed">4504 //          ++i;</span>
<span class="line-removed">4505 //          // c &lt; 256 for Latin1 string, so, no need for branch</span>
<span class="line-removed">4506 //          #ifdef PATTERN_STRING_IS_LATIN1</span>
<span class="line-removed">4507 //          bc[c] = m - i;</span>
<span class="line-removed">4508 //          #else</span>
<span class="line-removed">4509 //          if (c &lt; ASIZE) bc[c] = m - i;</span>
<span class="line-removed">4510 //          #endif</span>
<span class="line-removed">4511 //       }</span>
<span class="line-removed">4512 //</span>
<span class="line-removed">4513 //       /* Searching */</span>
<span class="line-removed">4514 //       j = 0;</span>
<span class="line-removed">4515 //       while (j &lt;= n - m) {</span>
<span class="line-removed">4516 //          c = y[i+j];</span>
<span class="line-removed">4517 //          if (x[m-1] == c)</span>
<span class="line-removed">4518 //            for (i = m - 2; i &gt;= 0 &amp;&amp; x[i] == y[i + j]; --i);</span>
<span class="line-removed">4519 //          if (i &lt; 0) return j;</span>
<span class="line-removed">4520 //          // c &lt; 256 for Latin1 string, so, no need for branch</span>
<span class="line-removed">4521 //          #ifdef SOURCE_STRING_IS_LATIN1</span>
<span class="line-removed">4522 //          // LL case: (c&lt; 256) always true. Remove branch</span>
<span class="line-removed">4523 //          j += bc[y[j+m-1]];</span>
<span class="line-removed">4524 //          #endif</span>
<span class="line-removed">4525 //          #ifndef PATTERN_STRING_IS_UTF</span>
<span class="line-removed">4526 //          // UU case: need if (c&lt;ASIZE) check. Skip 1 character if not.</span>
<span class="line-removed">4527 //          if (c &lt; ASIZE)</span>
<span class="line-removed">4528 //            j += bc[y[j+m-1]];</span>
<span class="line-removed">4529 //          else</span>
<span class="line-removed">4530 //            j += 1</span>
<span class="line-removed">4531 //          #endif</span>
<span class="line-removed">4532 //          #ifdef PATTERN_IS_LATIN1_AND_SOURCE_IS_UTF</span>
<span class="line-removed">4533 //          // UL case: need if (c&lt;ASIZE) check. Skip &lt;pattern length&gt; if not.</span>
<span class="line-removed">4534 //          if (c &lt; ASIZE)</span>
<span class="line-removed">4535 //            j += bc[y[j+m-1]];</span>
<span class="line-removed">4536 //          else</span>
<span class="line-removed">4537 //            j += m</span>
<span class="line-removed">4538 //          #endif</span>
<span class="line-removed">4539 //       }</span>
<span class="line-removed">4540 //    }</span>
<span class="line-removed">4541 </span>
<span class="line-removed">4542   if (icnt1 == -1) {</span>
<span class="line-removed">4543     Label BCLOOP, BCSKIP, BMLOOPSTR2, BMLOOPSTR1, BMSKIP, BMADV, BMMATCH,</span>
<span class="line-removed">4544         BMLOOPSTR1_LASTCMP, BMLOOPSTR1_CMP, BMLOOPSTR1_AFTER_LOAD, BM_INIT_LOOP;</span>
<span class="line-removed">4545     Register cnt1end = tmp2;</span>
<span class="line-removed">4546     Register str2end = cnt2;</span>
<span class="line-removed">4547     Register skipch = tmp2;</span>
<span class="line-removed">4548 </span>
<span class="line-removed">4549     // str1 length is &gt;=8, so, we can read at least 1 register for cases when</span>
<span class="line-removed">4550     // UTF-&gt;Latin1 conversion is not needed(8 LL or 4UU) and half register for</span>
<span class="line-removed">4551     // UL case. We&#39;ll re-read last character in inner pre-loop code to have</span>
<span class="line-removed">4552     // single outer pre-loop load</span>
<span class="line-removed">4553     const int firstStep = isL ? 7 : 3;</span>
<span class="line-removed">4554 </span>
<span class="line-removed">4555     const int ASIZE = 256;</span>
<span class="line-removed">4556     const int STORED_BYTES = 32; // amount of bytes stored per instruction</span>
<span class="line-removed">4557     sub(sp, sp, ASIZE);</span>
<span class="line-removed">4558     mov(tmp5, ASIZE/STORED_BYTES); // loop iterations</span>
<span class="line-removed">4559     mov(ch1, sp);</span>
<span class="line-removed">4560     BIND(BM_INIT_LOOP);</span>
<span class="line-removed">4561       stpq(v0, v0, Address(post(ch1, STORED_BYTES)));</span>
<span class="line-removed">4562       subs(tmp5, tmp5, 1);</span>
<span class="line-removed">4563       br(GT, BM_INIT_LOOP);</span>
<span class="line-removed">4564 </span>
<span class="line-removed">4565       sub(cnt1tmp, cnt1, 1);</span>
<span class="line-removed">4566       mov(tmp5, str2);</span>
<span class="line-removed">4567       add(str2end, str2, result_tmp, LSL, str2_chr_shift);</span>
<span class="line-removed">4568       sub(ch2, cnt1, 1);</span>
<span class="line-removed">4569       mov(tmp3, str1);</span>
<span class="line-removed">4570     BIND(BCLOOP);</span>
<span class="line-removed">4571       (this-&gt;*str1_load_1chr)(ch1, Address(post(tmp3, str1_chr_size)));</span>
<span class="line-removed">4572       if (!str1_isL) {</span>
<span class="line-removed">4573         subs(zr, ch1, ASIZE);</span>
<span class="line-removed">4574         br(HS, BCSKIP);</span>
<span class="line-removed">4575       }</span>
<span class="line-removed">4576       strb(ch2, Address(sp, ch1));</span>
<span class="line-removed">4577     BIND(BCSKIP);</span>
<span class="line-removed">4578       subs(ch2, ch2, 1);</span>
<span class="line-removed">4579       br(GT, BCLOOP);</span>
<span class="line-removed">4580 </span>
<span class="line-removed">4581       add(tmp6, str1, cnt1, LSL, str1_chr_shift); // address after str1</span>
<span class="line-removed">4582       if (str1_isL == str2_isL) {</span>
<span class="line-removed">4583         // load last 8 bytes (8LL/4UU symbols)</span>
<span class="line-removed">4584         ldr(tmp6, Address(tmp6, -wordSize));</span>
<span class="line-removed">4585       } else {</span>
<span class="line-removed">4586         ldrw(tmp6, Address(tmp6, -wordSize/2)); // load last 4 bytes(4 symbols)</span>
<span class="line-removed">4587         // convert Latin1 to UTF. We&#39;ll have to wait until load completed, but</span>
<span class="line-removed">4588         // it&#39;s still faster than per-character loads+checks</span>
<span class="line-removed">4589         lsr(tmp3, tmp6, BitsPerByte * (wordSize/2 - str1_chr_size)); // str1[N-1]</span>
<span class="line-removed">4590         ubfx(ch1, tmp6, 8, 8); // str1[N-2]</span>
<span class="line-removed">4591         ubfx(ch2, tmp6, 16, 8); // str1[N-3]</span>
<span class="line-removed">4592         andr(tmp6, tmp6, 0xFF); // str1[N-4]</span>
<span class="line-removed">4593         orr(ch2, ch1, ch2, LSL, 16);</span>
<span class="line-removed">4594         orr(tmp6, tmp6, tmp3, LSL, 48);</span>
<span class="line-removed">4595         orr(tmp6, tmp6, ch2, LSL, 16);</span>
<span class="line-removed">4596       }</span>
<span class="line-removed">4597     BIND(BMLOOPSTR2);</span>
<span class="line-removed">4598       (this-&gt;*str2_load_1chr)(skipch, Address(str2, cnt1tmp, Address::lsl(str2_chr_shift)));</span>
<span class="line-removed">4599       sub(cnt1tmp, cnt1tmp, firstStep); // cnt1tmp is positive here, because cnt1 &gt;= 8</span>
<span class="line-removed">4600       if (str1_isL == str2_isL) {</span>
<span class="line-removed">4601         // re-init tmp3. It&#39;s for free because it&#39;s executed in parallel with</span>
<span class="line-removed">4602         // load above. Alternative is to initialize it before loop, but it&#39;ll</span>
<span class="line-removed">4603         // affect performance on in-order systems with 2 or more ld/st pipelines</span>
<span class="line-removed">4604         lsr(tmp3, tmp6, BitsPerByte * (wordSize - str1_chr_size));</span>
<span class="line-removed">4605       }</span>
<span class="line-removed">4606       if (!isL) { // UU/UL case</span>
<span class="line-removed">4607         lsl(ch2, cnt1tmp, 1); // offset in bytes</span>
<span class="line-removed">4608       }</span>
<span class="line-removed">4609       cmp(tmp3, skipch);</span>
<span class="line-removed">4610       br(NE, BMSKIP);</span>
<span class="line-removed">4611       ldr(ch2, Address(str2, isL ? cnt1tmp : ch2));</span>
<span class="line-removed">4612       mov(ch1, tmp6);</span>
<span class="line-removed">4613       if (isL) {</span>
<span class="line-removed">4614         b(BMLOOPSTR1_AFTER_LOAD);</span>
<span class="line-removed">4615       } else {</span>
<span class="line-removed">4616         sub(cnt1tmp, cnt1tmp, 1); // no need to branch for UU/UL case. cnt1 &gt;= 8</span>
<span class="line-removed">4617         b(BMLOOPSTR1_CMP);</span>
<span class="line-removed">4618       }</span>
<span class="line-removed">4619     BIND(BMLOOPSTR1);</span>
<span class="line-removed">4620       (this-&gt;*str1_load_1chr)(ch1, Address(str1, cnt1tmp, Address::lsl(str1_chr_shift)));</span>
<span class="line-removed">4621       (this-&gt;*str2_load_1chr)(ch2, Address(str2, cnt1tmp, Address::lsl(str2_chr_shift)));</span>
<span class="line-removed">4622     BIND(BMLOOPSTR1_AFTER_LOAD);</span>
<span class="line-removed">4623       subs(cnt1tmp, cnt1tmp, 1);</span>
<span class="line-removed">4624       br(LT, BMLOOPSTR1_LASTCMP);</span>
<span class="line-removed">4625     BIND(BMLOOPSTR1_CMP);</span>
<span class="line-removed">4626       cmp(ch1, ch2);</span>
<span class="line-removed">4627       br(EQ, BMLOOPSTR1);</span>
<span class="line-removed">4628     BIND(BMSKIP);</span>
<span class="line-removed">4629       if (!isL) {</span>
<span class="line-removed">4630         // if we&#39;ve met UTF symbol while searching Latin1 pattern, then we can</span>
<span class="line-removed">4631         // skip cnt1 symbols</span>
<span class="line-removed">4632         if (str1_isL != str2_isL) {</span>
<span class="line-removed">4633           mov(result_tmp, cnt1);</span>
<span class="line-removed">4634         } else {</span>
<span class="line-removed">4635           mov(result_tmp, 1);</span>
<span class="line-removed">4636         }</span>
<span class="line-removed">4637         subs(zr, skipch, ASIZE);</span>
<span class="line-removed">4638         br(HS, BMADV);</span>
<span class="line-removed">4639       }</span>
<span class="line-removed">4640       ldrb(result_tmp, Address(sp, skipch)); // load skip distance</span>
<span class="line-removed">4641     BIND(BMADV);</span>
<span class="line-removed">4642       sub(cnt1tmp, cnt1, 1);</span>
<span class="line-removed">4643       add(str2, str2, result_tmp, LSL, str2_chr_shift);</span>
<span class="line-removed">4644       cmp(str2, str2end);</span>
<span class="line-removed">4645       br(LE, BMLOOPSTR2);</span>
<span class="line-removed">4646       add(sp, sp, ASIZE);</span>
<span class="line-removed">4647       b(NOMATCH);</span>
<span class="line-removed">4648     BIND(BMLOOPSTR1_LASTCMP);</span>
<span class="line-removed">4649       cmp(ch1, ch2);</span>
<span class="line-removed">4650       br(NE, BMSKIP);</span>
<span class="line-removed">4651     BIND(BMMATCH);</span>
<span class="line-removed">4652       sub(result, str2, tmp5);</span>
<span class="line-removed">4653       if (!str2_isL) lsr(result, result, 1);</span>
<span class="line-removed">4654       add(sp, sp, ASIZE);</span>
<span class="line-removed">4655       b(DONE);</span>
<span class="line-removed">4656 </span>
<span class="line-removed">4657     BIND(LINEARSTUB);</span>
<span class="line-removed">4658     cmp(cnt1, (u1)16); // small patterns still should be handled by simple algorithm</span>
<span class="line-removed">4659     br(LT, LINEAR_MEDIUM);</span>
<span class="line-removed">4660     mov(result, zr);</span>
<span class="line-removed">4661     RuntimeAddress stub = NULL;</span>
<span class="line-removed">4662     if (isL) {</span>
<span class="line-removed">4663       stub = RuntimeAddress(StubRoutines::aarch64::string_indexof_linear_ll());</span>
<span class="line-removed">4664       assert(stub.target() != NULL, &quot;string_indexof_linear_ll stub has not been generated&quot;);</span>
<span class="line-removed">4665     } else if (str1_isL) {</span>
<span class="line-removed">4666       stub = RuntimeAddress(StubRoutines::aarch64::string_indexof_linear_ul());</span>
<span class="line-removed">4667        assert(stub.target() != NULL, &quot;string_indexof_linear_ul stub has not been generated&quot;);</span>
<span class="line-removed">4668     } else {</span>
<span class="line-removed">4669       stub = RuntimeAddress(StubRoutines::aarch64::string_indexof_linear_uu());</span>
<span class="line-removed">4670       assert(stub.target() != NULL, &quot;string_indexof_linear_uu stub has not been generated&quot;);</span>
<span class="line-removed">4671     }</span>
<span class="line-removed">4672     trampoline_call(stub);</span>
<span class="line-removed">4673     b(DONE);</span>
<span class="line-removed">4674   }</span>
<span class="line-removed">4675 </span>
<span class="line-removed">4676   BIND(LINEARSEARCH);</span>
<span class="line-removed">4677   {</span>
<span class="line-removed">4678     Label DO1, DO2, DO3;</span>
<span class="line-removed">4679 </span>
<span class="line-removed">4680     Register str2tmp = tmp2;</span>
<span class="line-removed">4681     Register first = tmp3;</span>
<span class="line-removed">4682 </span>
<span class="line-removed">4683     if (icnt1 == -1)</span>
<span class="line-removed">4684     {</span>
<span class="line-removed">4685         Label DOSHORT, FIRST_LOOP, STR2_NEXT, STR1_LOOP, STR1_NEXT;</span>
<span class="line-removed">4686 </span>
<span class="line-removed">4687         cmp(cnt1, u1(str1_isL == str2_isL ? 4 : 2));</span>
<span class="line-removed">4688         br(LT, DOSHORT);</span>
<span class="line-removed">4689       BIND(LINEAR_MEDIUM);</span>
<span class="line-removed">4690         (this-&gt;*str1_load_1chr)(first, Address(str1));</span>
<span class="line-removed">4691         lea(str1, Address(str1, cnt1, Address::lsl(str1_chr_shift)));</span>
<span class="line-removed">4692         sub(cnt1_neg, zr, cnt1, LSL, str1_chr_shift);</span>
<span class="line-removed">4693         lea(str2, Address(str2, result_tmp, Address::lsl(str2_chr_shift)));</span>
<span class="line-removed">4694         sub(cnt2_neg, zr, result_tmp, LSL, str2_chr_shift);</span>
<span class="line-removed">4695 </span>
<span class="line-removed">4696       BIND(FIRST_LOOP);</span>
<span class="line-removed">4697         (this-&gt;*str2_load_1chr)(ch2, Address(str2, cnt2_neg));</span>
<span class="line-removed">4698         cmp(first, ch2);</span>
<span class="line-removed">4699         br(EQ, STR1_LOOP);</span>
<span class="line-removed">4700       BIND(STR2_NEXT);</span>
<span class="line-removed">4701         adds(cnt2_neg, cnt2_neg, str2_chr_size);</span>
<span class="line-removed">4702         br(LE, FIRST_LOOP);</span>
<span class="line-removed">4703         b(NOMATCH);</span>
<span class="line-removed">4704 </span>
<span class="line-removed">4705       BIND(STR1_LOOP);</span>
<span class="line-removed">4706         adds(cnt1tmp, cnt1_neg, str1_chr_size);</span>
<span class="line-removed">4707         add(cnt2tmp, cnt2_neg, str2_chr_size);</span>
<span class="line-removed">4708         br(GE, MATCH);</span>
<span class="line-removed">4709 </span>
<span class="line-removed">4710       BIND(STR1_NEXT);</span>
<span class="line-removed">4711         (this-&gt;*str1_load_1chr)(ch1, Address(str1, cnt1tmp));</span>
<span class="line-removed">4712         (this-&gt;*str2_load_1chr)(ch2, Address(str2, cnt2tmp));</span>
<span class="line-removed">4713         cmp(ch1, ch2);</span>
<span class="line-removed">4714         br(NE, STR2_NEXT);</span>
<span class="line-removed">4715         adds(cnt1tmp, cnt1tmp, str1_chr_size);</span>
<span class="line-removed">4716         add(cnt2tmp, cnt2tmp, str2_chr_size);</span>
<span class="line-removed">4717         br(LT, STR1_NEXT);</span>
<span class="line-removed">4718         b(MATCH);</span>
<span class="line-removed">4719 </span>
<span class="line-removed">4720       BIND(DOSHORT);</span>
<span class="line-removed">4721       if (str1_isL == str2_isL) {</span>
<span class="line-removed">4722         cmp(cnt1, (u1)2);</span>
<span class="line-removed">4723         br(LT, DO1);</span>
<span class="line-removed">4724         br(GT, DO3);</span>
<span class="line-removed">4725       }</span>
<span class="line-removed">4726     }</span>
<span class="line-removed">4727 </span>
<span class="line-removed">4728     if (icnt1 == 4) {</span>
<span class="line-removed">4729       Label CH1_LOOP;</span>
<span class="line-removed">4730 </span>
<span class="line-removed">4731         (this-&gt;*load_4chr)(ch1, str1);</span>
<span class="line-removed">4732         sub(result_tmp, cnt2, 4);</span>
<span class="line-removed">4733         lea(str2, Address(str2, result_tmp, Address::lsl(str2_chr_shift)));</span>
<span class="line-removed">4734         sub(cnt2_neg, zr, result_tmp, LSL, str2_chr_shift);</span>
<span class="line-removed">4735 </span>
<span class="line-removed">4736       BIND(CH1_LOOP);</span>
<span class="line-removed">4737         (this-&gt;*load_4chr)(ch2, Address(str2, cnt2_neg));</span>
<span class="line-removed">4738         cmp(ch1, ch2);</span>
<span class="line-removed">4739         br(EQ, MATCH);</span>
<span class="line-removed">4740         adds(cnt2_neg, cnt2_neg, str2_chr_size);</span>
<span class="line-removed">4741         br(LE, CH1_LOOP);</span>
<span class="line-removed">4742         b(NOMATCH);</span>
<span class="line-removed">4743       }</span>
<span class="line-removed">4744 </span>
<span class="line-removed">4745     if ((icnt1 == -1 &amp;&amp; str1_isL == str2_isL) || icnt1 == 2) {</span>
<span class="line-removed">4746       Label CH1_LOOP;</span>
<span class="line-removed">4747 </span>
<span class="line-removed">4748       BIND(DO2);</span>
<span class="line-removed">4749         (this-&gt;*load_2chr)(ch1, str1);</span>
<span class="line-removed">4750         if (icnt1 == 2) {</span>
<span class="line-removed">4751           sub(result_tmp, cnt2, 2);</span>
<span class="line-removed">4752         }</span>
<span class="line-removed">4753         lea(str2, Address(str2, result_tmp, Address::lsl(str2_chr_shift)));</span>
<span class="line-removed">4754         sub(cnt2_neg, zr, result_tmp, LSL, str2_chr_shift);</span>
<span class="line-removed">4755       BIND(CH1_LOOP);</span>
<span class="line-removed">4756         (this-&gt;*load_2chr)(ch2, Address(str2, cnt2_neg));</span>
<span class="line-removed">4757         cmp(ch1, ch2);</span>
<span class="line-removed">4758         br(EQ, MATCH);</span>
<span class="line-removed">4759         adds(cnt2_neg, cnt2_neg, str2_chr_size);</span>
<span class="line-removed">4760         br(LE, CH1_LOOP);</span>
<span class="line-removed">4761         b(NOMATCH);</span>
<span class="line-removed">4762     }</span>
<span class="line-removed">4763 </span>
<span class="line-removed">4764     if ((icnt1 == -1 &amp;&amp; str1_isL == str2_isL) || icnt1 == 3) {</span>
<span class="line-removed">4765       Label FIRST_LOOP, STR2_NEXT, STR1_LOOP;</span>
<span class="line-removed">4766 </span>
<span class="line-removed">4767       BIND(DO3);</span>
<span class="line-removed">4768         (this-&gt;*load_2chr)(first, str1);</span>
<span class="line-removed">4769         (this-&gt;*str1_load_1chr)(ch1, Address(str1, 2*str1_chr_size));</span>
<span class="line-removed">4770         if (icnt1 == 3) {</span>
<span class="line-removed">4771           sub(result_tmp, cnt2, 3);</span>
<span class="line-removed">4772         }</span>
<span class="line-removed">4773         lea(str2, Address(str2, result_tmp, Address::lsl(str2_chr_shift)));</span>
<span class="line-removed">4774         sub(cnt2_neg, zr, result_tmp, LSL, str2_chr_shift);</span>
<span class="line-removed">4775       BIND(FIRST_LOOP);</span>
<span class="line-removed">4776         (this-&gt;*load_2chr)(ch2, Address(str2, cnt2_neg));</span>
<span class="line-removed">4777         cmpw(first, ch2);</span>
<span class="line-removed">4778         br(EQ, STR1_LOOP);</span>
<span class="line-removed">4779       BIND(STR2_NEXT);</span>
<span class="line-removed">4780         adds(cnt2_neg, cnt2_neg, str2_chr_size);</span>
<span class="line-removed">4781         br(LE, FIRST_LOOP);</span>
<span class="line-removed">4782         b(NOMATCH);</span>
<span class="line-removed">4783 </span>
<span class="line-removed">4784       BIND(STR1_LOOP);</span>
<span class="line-removed">4785         add(cnt2tmp, cnt2_neg, 2*str2_chr_size);</span>
<span class="line-removed">4786         (this-&gt;*str2_load_1chr)(ch2, Address(str2, cnt2tmp));</span>
<span class="line-removed">4787         cmp(ch1, ch2);</span>
<span class="line-removed">4788         br(NE, STR2_NEXT);</span>
<span class="line-removed">4789         b(MATCH);</span>
<span class="line-removed">4790     }</span>
<span class="line-removed">4791 </span>
<span class="line-removed">4792     if (icnt1 == -1 || icnt1 == 1) {</span>
<span class="line-removed">4793       Label CH1_LOOP, HAS_ZERO, DO1_SHORT, DO1_LOOP;</span>
<span class="line-removed">4794 </span>
<span class="line-removed">4795       BIND(DO1);</span>
<span class="line-removed">4796         (this-&gt;*str1_load_1chr)(ch1, str1);</span>
<span class="line-removed">4797         cmp(cnt2, (u1)8);</span>
<span class="line-removed">4798         br(LT, DO1_SHORT);</span>
<span class="line-removed">4799 </span>
<span class="line-removed">4800         sub(result_tmp, cnt2, 8/str2_chr_size);</span>
<span class="line-removed">4801         sub(cnt2_neg, zr, result_tmp, LSL, str2_chr_shift);</span>
<span class="line-removed">4802         mov(tmp3, str2_isL ? 0x0101010101010101 : 0x0001000100010001);</span>
<span class="line-removed">4803         lea(str2, Address(str2, result_tmp, Address::lsl(str2_chr_shift)));</span>
<span class="line-removed">4804 </span>
<span class="line-removed">4805         if (str2_isL) {</span>
<span class="line-removed">4806           orr(ch1, ch1, ch1, LSL, 8);</span>
<span class="line-removed">4807         }</span>
<span class="line-removed">4808         orr(ch1, ch1, ch1, LSL, 16);</span>
<span class="line-removed">4809         orr(ch1, ch1, ch1, LSL, 32);</span>
<span class="line-removed">4810       BIND(CH1_LOOP);</span>
<span class="line-removed">4811         ldr(ch2, Address(str2, cnt2_neg));</span>
<span class="line-removed">4812         eor(ch2, ch1, ch2);</span>
<span class="line-removed">4813         sub(tmp1, ch2, tmp3);</span>
<span class="line-removed">4814         orr(tmp2, ch2, str2_isL ? 0x7f7f7f7f7f7f7f7f : 0x7fff7fff7fff7fff);</span>
<span class="line-removed">4815         bics(tmp1, tmp1, tmp2);</span>
<span class="line-removed">4816         br(NE, HAS_ZERO);</span>
<span class="line-removed">4817         adds(cnt2_neg, cnt2_neg, 8);</span>
<span class="line-removed">4818         br(LT, CH1_LOOP);</span>
<span class="line-removed">4819 </span>
<span class="line-removed">4820         cmp(cnt2_neg, (u1)8);</span>
<span class="line-removed">4821         mov(cnt2_neg, 0);</span>
<span class="line-removed">4822         br(LT, CH1_LOOP);</span>
<span class="line-removed">4823         b(NOMATCH);</span>
<span class="line-removed">4824 </span>
<span class="line-removed">4825       BIND(HAS_ZERO);</span>
<span class="line-removed">4826         rev(tmp1, tmp1);</span>
<span class="line-removed">4827         clz(tmp1, tmp1);</span>
<span class="line-removed">4828         add(cnt2_neg, cnt2_neg, tmp1, LSR, 3);</span>
<span class="line-removed">4829         b(MATCH);</span>
<span class="line-removed">4830 </span>
<span class="line-removed">4831       BIND(DO1_SHORT);</span>
<span class="line-removed">4832         mov(result_tmp, cnt2);</span>
<span class="line-removed">4833         lea(str2, Address(str2, cnt2, Address::lsl(str2_chr_shift)));</span>
<span class="line-removed">4834         sub(cnt2_neg, zr, cnt2, LSL, str2_chr_shift);</span>
<span class="line-removed">4835       BIND(DO1_LOOP);</span>
<span class="line-removed">4836         (this-&gt;*str2_load_1chr)(ch2, Address(str2, cnt2_neg));</span>
<span class="line-removed">4837         cmpw(ch1, ch2);</span>
<span class="line-removed">4838         br(EQ, MATCH);</span>
<span class="line-removed">4839         adds(cnt2_neg, cnt2_neg, str2_chr_size);</span>
<span class="line-removed">4840         br(LT, DO1_LOOP);</span>
<span class="line-removed">4841     }</span>
<span class="line-removed">4842   }</span>
<span class="line-removed">4843   BIND(NOMATCH);</span>
<span class="line-removed">4844     mov(result, -1);</span>
<span class="line-removed">4845     b(DONE);</span>
<span class="line-removed">4846   BIND(MATCH);</span>
<span class="line-removed">4847     add(result, result_tmp, cnt2_neg, ASR, str2_chr_shift);</span>
<span class="line-removed">4848   BIND(DONE);</span>
<span class="line-removed">4849 }</span>
<span class="line-removed">4850 </span>
<span class="line-removed">4851 typedef void (MacroAssembler::* chr_insn)(Register Rt, const Address &amp;adr);</span>
<span class="line-removed">4852 typedef void (MacroAssembler::* uxt_insn)(Register Rd, Register Rn);</span>
<span class="line-removed">4853 </span>
<span class="line-removed">4854 void MacroAssembler::string_indexof_char(Register str1, Register cnt1,</span>
<span class="line-removed">4855                                          Register ch, Register result,</span>
<span class="line-removed">4856                                          Register tmp1, Register tmp2, Register tmp3)</span>
<span class="line-removed">4857 {</span>
<span class="line-removed">4858   Label CH1_LOOP, HAS_ZERO, DO1_SHORT, DO1_LOOP, MATCH, NOMATCH, DONE;</span>
<span class="line-removed">4859   Register cnt1_neg = cnt1;</span>
<span class="line-removed">4860   Register ch1 = rscratch1;</span>
<span class="line-removed">4861   Register result_tmp = rscratch2;</span>
<span class="line-removed">4862 </span>
<span class="line-removed">4863   cbz(cnt1, NOMATCH);</span>
<span class="line-removed">4864 </span>
<span class="line-removed">4865   cmp(cnt1, (u1)4);</span>
<span class="line-removed">4866   br(LT, DO1_SHORT);</span>
<span class="line-removed">4867 </span>
<span class="line-removed">4868   orr(ch, ch, ch, LSL, 16);</span>
<span class="line-removed">4869   orr(ch, ch, ch, LSL, 32);</span>
<span class="line-removed">4870 </span>
<span class="line-removed">4871   sub(cnt1, cnt1, 4);</span>
<span class="line-removed">4872   mov(result_tmp, cnt1);</span>
<span class="line-removed">4873   lea(str1, Address(str1, cnt1, Address::uxtw(1)));</span>
<span class="line-removed">4874   sub(cnt1_neg, zr, cnt1, LSL, 1);</span>
<span class="line-removed">4875 </span>
<span class="line-removed">4876   mov(tmp3, 0x0001000100010001);</span>
<span class="line-removed">4877 </span>
<span class="line-removed">4878   BIND(CH1_LOOP);</span>
<span class="line-removed">4879     ldr(ch1, Address(str1, cnt1_neg));</span>
<span class="line-removed">4880     eor(ch1, ch, ch1);</span>
<span class="line-removed">4881     sub(tmp1, ch1, tmp3);</span>
<span class="line-removed">4882     orr(tmp2, ch1, 0x7fff7fff7fff7fff);</span>
<span class="line-removed">4883     bics(tmp1, tmp1, tmp2);</span>
<span class="line-removed">4884     br(NE, HAS_ZERO);</span>
<span class="line-removed">4885     adds(cnt1_neg, cnt1_neg, 8);</span>
<span class="line-removed">4886     br(LT, CH1_LOOP);</span>
<span class="line-removed">4887 </span>
<span class="line-removed">4888     cmp(cnt1_neg, (u1)8);</span>
<span class="line-removed">4889     mov(cnt1_neg, 0);</span>
<span class="line-removed">4890     br(LT, CH1_LOOP);</span>
<span class="line-removed">4891     b(NOMATCH);</span>
<span class="line-removed">4892 </span>
<span class="line-removed">4893   BIND(HAS_ZERO);</span>
<span class="line-removed">4894     rev(tmp1, tmp1);</span>
<span class="line-removed">4895     clz(tmp1, tmp1);</span>
<span class="line-removed">4896     add(cnt1_neg, cnt1_neg, tmp1, LSR, 3);</span>
<span class="line-removed">4897     b(MATCH);</span>
<span class="line-removed">4898 </span>
<span class="line-removed">4899   BIND(DO1_SHORT);</span>
<span class="line-removed">4900     mov(result_tmp, cnt1);</span>
<span class="line-removed">4901     lea(str1, Address(str1, cnt1, Address::uxtw(1)));</span>
<span class="line-removed">4902     sub(cnt1_neg, zr, cnt1, LSL, 1);</span>
<span class="line-removed">4903   BIND(DO1_LOOP);</span>
<span class="line-removed">4904     ldrh(ch1, Address(str1, cnt1_neg));</span>
<span class="line-removed">4905     cmpw(ch, ch1);</span>
<span class="line-removed">4906     br(EQ, MATCH);</span>
<span class="line-removed">4907     adds(cnt1_neg, cnt1_neg, 2);</span>
<span class="line-removed">4908     br(LT, DO1_LOOP);</span>
<span class="line-removed">4909   BIND(NOMATCH);</span>
<span class="line-removed">4910     mov(result, -1);</span>
<span class="line-removed">4911     b(DONE);</span>
<span class="line-removed">4912   BIND(MATCH);</span>
<span class="line-removed">4913     add(result, result_tmp, cnt1_neg, ASR, 1);</span>
<span class="line-removed">4914   BIND(DONE);</span>
<span class="line-removed">4915 }</span>
<span class="line-removed">4916 </span>
<span class="line-removed">4917 // Compare strings.</span>
<span class="line-removed">4918 void MacroAssembler::string_compare(Register str1, Register str2,</span>
<span class="line-removed">4919     Register cnt1, Register cnt2, Register result, Register tmp1, Register tmp2,</span>
<span class="line-removed">4920     FloatRegister vtmp1, FloatRegister vtmp2, FloatRegister vtmp3, int ae) {</span>
<span class="line-removed">4921   Label DONE, SHORT_LOOP, SHORT_STRING, SHORT_LAST, TAIL, STUB,</span>
<span class="line-removed">4922       DIFFERENCE, NEXT_WORD, SHORT_LOOP_TAIL, SHORT_LAST2, SHORT_LAST_INIT,</span>
<span class="line-removed">4923       SHORT_LOOP_START, TAIL_CHECK;</span>
<span class="line-removed">4924 </span>
<span class="line-removed">4925   bool isLL = ae == StrIntrinsicNode::LL;</span>
<span class="line-removed">4926   bool isLU = ae == StrIntrinsicNode::LU;</span>
<span class="line-removed">4927   bool isUL = ae == StrIntrinsicNode::UL;</span>
<span class="line-removed">4928 </span>
<span class="line-removed">4929   // The stub threshold for LL strings is: 72 (64 + 8) chars</span>
<span class="line-removed">4930   // UU: 36 chars, or 72 bytes (valid for the 64-byte large loop with prefetch)</span>
<span class="line-removed">4931   // LU/UL: 24 chars, or 48 bytes (valid for the 16-character loop at least)</span>
<span class="line-removed">4932   const u1 stub_threshold = isLL ? 72 : ((isLU || isUL) ? 24 : 36);</span>
<span class="line-removed">4933 </span>
<span class="line-removed">4934   bool str1_isL = isLL || isLU;</span>
<span class="line-removed">4935   bool str2_isL = isLL || isUL;</span>
<span class="line-removed">4936 </span>
<span class="line-removed">4937   int str1_chr_shift = str1_isL ? 0 : 1;</span>
<span class="line-removed">4938   int str2_chr_shift = str2_isL ? 0 : 1;</span>
<span class="line-removed">4939   int str1_chr_size = str1_isL ? 1 : 2;</span>
<span class="line-removed">4940   int str2_chr_size = str2_isL ? 1 : 2;</span>
<span class="line-removed">4941   int minCharsInWord = isLL ? wordSize : wordSize/2;</span>
<span class="line-removed">4942 </span>
<span class="line-removed">4943   FloatRegister vtmpZ = vtmp1, vtmp = vtmp2;</span>
<span class="line-removed">4944   chr_insn str1_load_chr = str1_isL ? (chr_insn)&amp;MacroAssembler::ldrb :</span>
<span class="line-removed">4945                                       (chr_insn)&amp;MacroAssembler::ldrh;</span>
<span class="line-removed">4946   chr_insn str2_load_chr = str2_isL ? (chr_insn)&amp;MacroAssembler::ldrb :</span>
<span class="line-removed">4947                                       (chr_insn)&amp;MacroAssembler::ldrh;</span>
<span class="line-removed">4948   uxt_insn ext_chr = isLL ? (uxt_insn)&amp;MacroAssembler::uxtbw :</span>
<span class="line-removed">4949                             (uxt_insn)&amp;MacroAssembler::uxthw;</span>
<span class="line-removed">4950 </span>
<span class="line-removed">4951   BLOCK_COMMENT(&quot;string_compare {&quot;);</span>
<span class="line-removed">4952 </span>
<span class="line-removed">4953   // Bizzarely, the counts are passed in bytes, regardless of whether they</span>
<span class="line-removed">4954   // are L or U strings, however the result is always in characters.</span>
<span class="line-removed">4955   if (!str1_isL) asrw(cnt1, cnt1, 1);</span>
<span class="line-removed">4956   if (!str2_isL) asrw(cnt2, cnt2, 1);</span>
<span class="line-removed">4957 </span>
<span class="line-removed">4958   // Compute the minimum of the string lengths and save the difference.</span>
<span class="line-removed">4959   subsw(result, cnt1, cnt2);</span>
<span class="line-removed">4960   cselw(cnt2, cnt1, cnt2, Assembler::LE); // min</span>
<span class="line-removed">4961 </span>
<span class="line-removed">4962   // A very short string</span>
<span class="line-removed">4963   cmpw(cnt2, minCharsInWord);</span>
<span class="line-removed">4964   br(Assembler::LE, SHORT_STRING);</span>
<span class="line-removed">4965 </span>
<span class="line-removed">4966   // Compare longwords</span>
<span class="line-removed">4967   // load first parts of strings and finish initialization while loading</span>
<span class="line-removed">4968   {</span>
<span class="line-removed">4969     if (str1_isL == str2_isL) { // LL or UU</span>
<span class="line-removed">4970       ldr(tmp1, Address(str1));</span>
<span class="line-removed">4971       cmp(str1, str2);</span>
<span class="line-removed">4972       br(Assembler::EQ, DONE);</span>
<span class="line-removed">4973       ldr(tmp2, Address(str2));</span>
<span class="line-removed">4974       cmp(cnt2, stub_threshold);</span>
<span class="line-removed">4975       br(GE, STUB);</span>
<span class="line-removed">4976       subsw(cnt2, cnt2, minCharsInWord);</span>
<span class="line-removed">4977       br(EQ, TAIL_CHECK);</span>
<span class="line-removed">4978       lea(str2, Address(str2, cnt2, Address::uxtw(str2_chr_shift)));</span>
<span class="line-removed">4979       lea(str1, Address(str1, cnt2, Address::uxtw(str1_chr_shift)));</span>
<span class="line-removed">4980       sub(cnt2, zr, cnt2, LSL, str2_chr_shift);</span>
<span class="line-removed">4981     } else if (isLU) {</span>
<span class="line-removed">4982       ldrs(vtmp, Address(str1));</span>
<span class="line-removed">4983       ldr(tmp2, Address(str2));</span>
<span class="line-removed">4984       cmp(cnt2, stub_threshold);</span>
<span class="line-removed">4985       br(GE, STUB);</span>
<span class="line-removed">4986       subw(cnt2, cnt2, 4);</span>
<span class="line-removed">4987       eor(vtmpZ, T16B, vtmpZ, vtmpZ);</span>
<span class="line-removed">4988       lea(str1, Address(str1, cnt2, Address::uxtw(str1_chr_shift)));</span>
<span class="line-removed">4989       lea(str2, Address(str2, cnt2, Address::uxtw(str2_chr_shift)));</span>
<span class="line-removed">4990       zip1(vtmp, T8B, vtmp, vtmpZ);</span>
<span class="line-removed">4991       sub(cnt1, zr, cnt2, LSL, str1_chr_shift);</span>
<span class="line-removed">4992       sub(cnt2, zr, cnt2, LSL, str2_chr_shift);</span>
<span class="line-removed">4993       add(cnt1, cnt1, 4);</span>
<span class="line-removed">4994       fmovd(tmp1, vtmp);</span>
<span class="line-removed">4995     } else { // UL case</span>
<span class="line-removed">4996       ldr(tmp1, Address(str1));</span>
<span class="line-removed">4997       ldrs(vtmp, Address(str2));</span>
<span class="line-removed">4998       cmp(cnt2, stub_threshold);</span>
<span class="line-removed">4999       br(GE, STUB);</span>
<span class="line-removed">5000       subw(cnt2, cnt2, 4);</span>
<span class="line-removed">5001       lea(str1, Address(str1, cnt2, Address::uxtw(str1_chr_shift)));</span>
<span class="line-removed">5002       eor(vtmpZ, T16B, vtmpZ, vtmpZ);</span>
<span class="line-removed">5003       lea(str2, Address(str2, cnt2, Address::uxtw(str2_chr_shift)));</span>
<span class="line-removed">5004       sub(cnt1, zr, cnt2, LSL, str1_chr_shift);</span>
<span class="line-removed">5005       zip1(vtmp, T8B, vtmp, vtmpZ);</span>
<span class="line-removed">5006       sub(cnt2, zr, cnt2, LSL, str2_chr_shift);</span>
<span class="line-removed">5007       add(cnt1, cnt1, 8);</span>
<span class="line-removed">5008       fmovd(tmp2, vtmp);</span>
<span class="line-removed">5009     }</span>
<span class="line-removed">5010     adds(cnt2, cnt2, isUL ? 4 : 8);</span>
<span class="line-removed">5011     br(GE, TAIL);</span>
<span class="line-removed">5012     eor(rscratch2, tmp1, tmp2);</span>
<span class="line-removed">5013     cbnz(rscratch2, DIFFERENCE);</span>
<span class="line-removed">5014     // main loop</span>
<span class="line-removed">5015     bind(NEXT_WORD);</span>
<span class="line-removed">5016     if (str1_isL == str2_isL) {</span>
<span class="line-removed">5017       ldr(tmp1, Address(str1, cnt2));</span>
<span class="line-removed">5018       ldr(tmp2, Address(str2, cnt2));</span>
<span class="line-removed">5019       adds(cnt2, cnt2, 8);</span>
<span class="line-removed">5020     } else if (isLU) {</span>
<span class="line-removed">5021       ldrs(vtmp, Address(str1, cnt1));</span>
<span class="line-removed">5022       ldr(tmp2, Address(str2, cnt2));</span>
<span class="line-removed">5023       add(cnt1, cnt1, 4);</span>
<span class="line-removed">5024       zip1(vtmp, T8B, vtmp, vtmpZ);</span>
<span class="line-removed">5025       fmovd(tmp1, vtmp);</span>
<span class="line-removed">5026       adds(cnt2, cnt2, 8);</span>
<span class="line-removed">5027     } else { // UL</span>
<span class="line-removed">5028       ldrs(vtmp, Address(str2, cnt2));</span>
<span class="line-removed">5029       ldr(tmp1, Address(str1, cnt1));</span>
<span class="line-removed">5030       zip1(vtmp, T8B, vtmp, vtmpZ);</span>
<span class="line-removed">5031       add(cnt1, cnt1, 8);</span>
<span class="line-removed">5032       fmovd(tmp2, vtmp);</span>
<span class="line-removed">5033       adds(cnt2, cnt2, 4);</span>
<span class="line-removed">5034     }</span>
<span class="line-removed">5035     br(GE, TAIL);</span>
<span class="line-removed">5036 </span>
<span class="line-removed">5037     eor(rscratch2, tmp1, tmp2);</span>
<span class="line-removed">5038     cbz(rscratch2, NEXT_WORD);</span>
<span class="line-removed">5039     b(DIFFERENCE);</span>
<span class="line-removed">5040     bind(TAIL);</span>
<span class="line-removed">5041     eor(rscratch2, tmp1, tmp2);</span>
<span class="line-removed">5042     cbnz(rscratch2, DIFFERENCE);</span>
<span class="line-removed">5043     // Last longword.  In the case where length == 4 we compare the</span>
<span class="line-removed">5044     // same longword twice, but that&#39;s still faster than another</span>
<span class="line-removed">5045     // conditional branch.</span>
<span class="line-removed">5046     if (str1_isL == str2_isL) {</span>
<span class="line-removed">5047       ldr(tmp1, Address(str1));</span>
<span class="line-removed">5048       ldr(tmp2, Address(str2));</span>
<span class="line-removed">5049     } else if (isLU) {</span>
<span class="line-removed">5050       ldrs(vtmp, Address(str1));</span>
<span class="line-removed">5051       ldr(tmp2, Address(str2));</span>
<span class="line-removed">5052       zip1(vtmp, T8B, vtmp, vtmpZ);</span>
<span class="line-removed">5053       fmovd(tmp1, vtmp);</span>
<span class="line-removed">5054     } else { // UL</span>
<span class="line-removed">5055       ldrs(vtmp, Address(str2));</span>
<span class="line-removed">5056       ldr(tmp1, Address(str1));</span>
<span class="line-removed">5057       zip1(vtmp, T8B, vtmp, vtmpZ);</span>
<span class="line-removed">5058       fmovd(tmp2, vtmp);</span>
<span class="line-removed">5059     }</span>
<span class="line-removed">5060     bind(TAIL_CHECK);</span>
<span class="line-removed">5061     eor(rscratch2, tmp1, tmp2);</span>
<span class="line-removed">5062     cbz(rscratch2, DONE);</span>
<span class="line-removed">5063 </span>
<span class="line-removed">5064     // Find the first different characters in the longwords and</span>
<span class="line-removed">5065     // compute their difference.</span>
<span class="line-removed">5066     bind(DIFFERENCE);</span>
<span class="line-removed">5067     rev(rscratch2, rscratch2);</span>
<span class="line-removed">5068     clz(rscratch2, rscratch2);</span>
<span class="line-removed">5069     andr(rscratch2, rscratch2, isLL ? -8 : -16);</span>
<span class="line-removed">5070     lsrv(tmp1, tmp1, rscratch2);</span>
<span class="line-removed">5071     (this-&gt;*ext_chr)(tmp1, tmp1);</span>
<span class="line-removed">5072     lsrv(tmp2, tmp2, rscratch2);</span>
<span class="line-removed">5073     (this-&gt;*ext_chr)(tmp2, tmp2);</span>
<span class="line-removed">5074     subw(result, tmp1, tmp2);</span>
<span class="line-removed">5075     b(DONE);</span>
<span class="line-removed">5076   }</span>
<span class="line-removed">5077 </span>
<span class="line-removed">5078   bind(STUB);</span>
<span class="line-removed">5079     RuntimeAddress stub = NULL;</span>
<span class="line-removed">5080     switch(ae) {</span>
<span class="line-removed">5081       case StrIntrinsicNode::LL:</span>
<span class="line-removed">5082         stub = RuntimeAddress(StubRoutines::aarch64::compare_long_string_LL());</span>
<span class="line-removed">5083         break;</span>
<span class="line-removed">5084       case StrIntrinsicNode::UU:</span>
<span class="line-removed">5085         stub = RuntimeAddress(StubRoutines::aarch64::compare_long_string_UU());</span>
<span class="line-removed">5086         break;</span>
<span class="line-removed">5087       case StrIntrinsicNode::LU:</span>
<span class="line-removed">5088         stub = RuntimeAddress(StubRoutines::aarch64::compare_long_string_LU());</span>
<span class="line-removed">5089         break;</span>
<span class="line-removed">5090       case StrIntrinsicNode::UL:</span>
<span class="line-removed">5091         stub = RuntimeAddress(StubRoutines::aarch64::compare_long_string_UL());</span>
<span class="line-removed">5092         break;</span>
<span class="line-removed">5093       default:</span>
<span class="line-removed">5094         ShouldNotReachHere();</span>
<span class="line-removed">5095      }</span>
<span class="line-removed">5096     assert(stub.target() != NULL, &quot;compare_long_string stub has not been generated&quot;);</span>
<span class="line-removed">5097     trampoline_call(stub);</span>
<span class="line-removed">5098     b(DONE);</span>
<span class="line-removed">5099 </span>
<span class="line-removed">5100   bind(SHORT_STRING);</span>
<span class="line-removed">5101   // Is the minimum length zero?</span>
<span class="line-removed">5102   cbz(cnt2, DONE);</span>
<span class="line-removed">5103   // arrange code to do most branches while loading and loading next characters</span>
<span class="line-removed">5104   // while comparing previous</span>
<span class="line-removed">5105   (this-&gt;*str1_load_chr)(tmp1, Address(post(str1, str1_chr_size)));</span>
<span class="line-removed">5106   subs(cnt2, cnt2, 1);</span>
<span class="line-removed">5107   br(EQ, SHORT_LAST_INIT);</span>
<span class="line-removed">5108   (this-&gt;*str2_load_chr)(cnt1, Address(post(str2, str2_chr_size)));</span>
<span class="line-removed">5109   b(SHORT_LOOP_START);</span>
<span class="line-removed">5110   bind(SHORT_LOOP);</span>
<span class="line-removed">5111   subs(cnt2, cnt2, 1);</span>
<span class="line-removed">5112   br(EQ, SHORT_LAST);</span>
<span class="line-removed">5113   bind(SHORT_LOOP_START);</span>
<span class="line-removed">5114   (this-&gt;*str1_load_chr)(tmp2, Address(post(str1, str1_chr_size)));</span>
<span class="line-removed">5115   (this-&gt;*str2_load_chr)(rscratch1, Address(post(str2, str2_chr_size)));</span>
<span class="line-removed">5116   cmp(tmp1, cnt1);</span>
<span class="line-removed">5117   br(NE, SHORT_LOOP_TAIL);</span>
<span class="line-removed">5118   subs(cnt2, cnt2, 1);</span>
<span class="line-removed">5119   br(EQ, SHORT_LAST2);</span>
<span class="line-removed">5120   (this-&gt;*str1_load_chr)(tmp1, Address(post(str1, str1_chr_size)));</span>
<span class="line-removed">5121   (this-&gt;*str2_load_chr)(cnt1, Address(post(str2, str2_chr_size)));</span>
<span class="line-removed">5122   cmp(tmp2, rscratch1);</span>
<span class="line-removed">5123   br(EQ, SHORT_LOOP);</span>
<span class="line-removed">5124   sub(result, tmp2, rscratch1);</span>
<span class="line-removed">5125   b(DONE);</span>
<span class="line-removed">5126   bind(SHORT_LOOP_TAIL);</span>
<span class="line-removed">5127   sub(result, tmp1, cnt1);</span>
<span class="line-removed">5128   b(DONE);</span>
<span class="line-removed">5129   bind(SHORT_LAST2);</span>
<span class="line-removed">5130   cmp(tmp2, rscratch1);</span>
<span class="line-removed">5131   br(EQ, DONE);</span>
<span class="line-removed">5132   sub(result, tmp2, rscratch1);</span>
<span class="line-removed">5133 </span>
<span class="line-removed">5134   b(DONE);</span>
<span class="line-removed">5135   bind(SHORT_LAST_INIT);</span>
<span class="line-removed">5136   (this-&gt;*str2_load_chr)(cnt1, Address(post(str2, str2_chr_size)));</span>
<span class="line-removed">5137   bind(SHORT_LAST);</span>
<span class="line-removed">5138   cmp(tmp1, cnt1);</span>
<span class="line-removed">5139   br(EQ, DONE);</span>
<span class="line-removed">5140   sub(result, tmp1, cnt1);</span>
<span class="line-removed">5141 </span>
<span class="line-removed">5142   bind(DONE);</span>
<span class="line-removed">5143 </span>
<span class="line-removed">5144   BLOCK_COMMENT(&quot;} string_compare&quot;);</span>
<span class="line-removed">5145 }</span>
<span class="line-removed">5146 #endif // COMPILER2</span>
5147 
5148 // This method checks if provided byte array contains byte with highest bit set.
5149 void MacroAssembler::has_negatives(Register ary1, Register len, Register result) {
5150     // Simple and most common case of aligned small array which is not at the
5151     // end of memory page is placed here. All other cases are in stub.
5152     Label LOOP, END, STUB, STUB_LONG, SET_RESULT, DONE;
5153     const uint64_t UPPER_BIT_MASK=0x8080808080808080;
5154     assert_different_registers(ary1, len, result);
5155 
5156     cmpw(len, 0);
5157     br(LE, SET_RESULT);
5158     cmpw(len, 4 * wordSize);
5159     br(GE, STUB_LONG); // size &gt; 32 then go to stub
5160 
5161     int shift = 64 - exact_log2(os::vm_page_size());
5162     lsl(rscratch1, ary1, shift);
5163     mov(rscratch2, (size_t)(4 * wordSize) &lt;&lt; shift);
5164     adds(rscratch2, rscratch1, rscratch2);  // At end of page?
5165     br(CS, STUB); // at the end of page then go to stub
5166     subs(len, len, wordSize);
</pre>
</td>
<td>
<hr />
<pre>
  37 #include &quot;compiler/disassembler.hpp&quot;
  38 #include &quot;memory/resourceArea.hpp&quot;
  39 #include &quot;memory/universe.hpp&quot;
  40 #include &quot;nativeInst_aarch64.hpp&quot;
  41 #include &quot;oops/accessDecorators.hpp&quot;
  42 #include &quot;oops/compressedOops.inline.hpp&quot;
  43 #include &quot;oops/klass.inline.hpp&quot;
  44 #include &quot;runtime/biasedLocking.hpp&quot;
  45 #include &quot;runtime/icache.hpp&quot;
  46 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  47 #include &quot;runtime/jniHandles.inline.hpp&quot;
  48 #include &quot;runtime/sharedRuntime.hpp&quot;
  49 #include &quot;runtime/thread.hpp&quot;
  50 #include &quot;utilities/powerOfTwo.hpp&quot;
  51 #ifdef COMPILER1
  52 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  53 #endif
  54 #ifdef COMPILER2
  55 #include &quot;oops/oop.hpp&quot;
  56 #include &quot;opto/compile.hpp&quot;

  57 #include &quot;opto/node.hpp&quot;
<span class="line-added">  58 #include &quot;opto/output.hpp&quot;</span>
  59 #endif
  60 
  61 #ifdef PRODUCT
  62 #define BLOCK_COMMENT(str) /* nothing */
  63 #define STOP(error) stop(error)
  64 #else
  65 #define BLOCK_COMMENT(str) block_comment(str)
  66 #define STOP(error) block_comment(error); stop(error)
  67 #endif
  68 
  69 #define BIND(label) bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
  70 
  71 // Patch any kind of instruction; there may be several instructions.
  72 // Return the total length (in bytes) of the instructions.
  73 int MacroAssembler::pd_patch_instruction_size(address branch, address target) {
  74   int instructions = 1;
  75   assert((uint64_t)target &lt; (1ul &lt;&lt; 48), &quot;48-bit overflow in address constant&quot;);
  76   long offset = (target - branch) &gt;&gt; 2;
  77   unsigned insn = *(unsigned*)branch;
  78   if ((Instruction_aarch64::extract(insn, 29, 24) &amp; 0b111011) == 0b011000) {
</pre>
<hr />
<pre>
 274       ShouldNotReachHere();
 275     }
 276   } else if (Instruction_aarch64::extract(insn, 31, 23) == 0b110100101) {
 277     u_int32_t *insns = (u_int32_t *)insn_addr;
 278     // Move wide constant: movz, movk, movk.  See movptr().
 279     assert(nativeInstruction_at(insns+1)-&gt;is_movk(), &quot;wrong insns in patch&quot;);
 280     assert(nativeInstruction_at(insns+2)-&gt;is_movk(), &quot;wrong insns in patch&quot;);
 281     return address(u_int64_t(Instruction_aarch64::extract(insns[0], 20, 5))
 282                    + (u_int64_t(Instruction_aarch64::extract(insns[1], 20, 5)) &lt;&lt; 16)
 283                    + (u_int64_t(Instruction_aarch64::extract(insns[2], 20, 5)) &lt;&lt; 32));
 284   } else if (Instruction_aarch64::extract(insn, 31, 22) == 0b1011100101 &amp;&amp;
 285              Instruction_aarch64::extract(insn, 4, 0) == 0b11111) {
 286     return 0;
 287   } else {
 288     ShouldNotReachHere();
 289   }
 290   return address(((uint64_t)insn_addr + (offset &lt;&lt; 2)));
 291 }
 292 
 293 void MacroAssembler::safepoint_poll(Label&amp; slow_path) {
<span class="line-modified"> 294   ldr(rscratch1, Address(rthread, Thread::polling_page_offset()));</span>
<span class="line-modified"> 295   tbnz(rscratch1, exact_log2(SafepointMechanism::poll_bit()), slow_path);</span>








 296 }
 297 
 298 // Just like safepoint_poll, but use an acquiring load for thread-
 299 // local polling.
 300 //
 301 // We need an acquire here to ensure that any subsequent load of the
 302 // global SafepointSynchronize::_state flag is ordered after this load
 303 // of the local Thread::_polling page.  We don&#39;t want this poll to
 304 // return false (i.e. not safepointing) and a later poll of the global
 305 // SafepointSynchronize::_state spuriously to return true.
 306 //
 307 // This is to avoid a race when we&#39;re in a native-&gt;Java transition
 308 // racing the code which wakes up from a safepoint.
 309 //
 310 void MacroAssembler::safepoint_poll_acquire(Label&amp; slow_path) {
<span class="line-modified"> 311   lea(rscratch1, Address(rthread, Thread::polling_page_offset()));</span>
<span class="line-modified"> 312   ldar(rscratch1, rscratch1);</span>
<span class="line-modified"> 313   tbnz(rscratch1, exact_log2(SafepointMechanism::poll_bit()), slow_path);</span>




 314 }
 315 
 316 void MacroAssembler::reset_last_Java_frame(bool clear_fp) {
 317   // we must set sp to zero to clear frame
 318   str(zr, Address(rthread, JavaThread::last_Java_sp_offset()));
 319 
 320   // must clear fp, so that compiled frames are not confused; it is
 321   // possible that we need it only for debugging
 322   if (clear_fp) {
 323     str(zr, Address(rthread, JavaThread::last_Java_fp_offset()));
 324   }
 325 
 326   // Always clear the pc because it could have been set by make_walkable()
 327   str(zr, Address(rthread, JavaThread::last_Java_pc_offset()));
 328 }
 329 
 330 // Calls to C land
 331 //
 332 // When entering C land, the rfp, &amp; resp of the last Java frame have to be recorded
 333 // in the (thread-local) JavaThread object. When leaving C land, the last Java fp
</pre>
<hr />
<pre>
 716 
 717 // Maybe emit a call via a trampoline.  If the code cache is small
 718 // trampolines won&#39;t be emitted.
 719 
 720 address MacroAssembler::trampoline_call(Address entry, CodeBuffer *cbuf) {
 721   assert(JavaThread::current()-&gt;is_Compiler_thread(), &quot;just checking&quot;);
 722   assert(entry.rspec().type() == relocInfo::runtime_call_type
 723          || entry.rspec().type() == relocInfo::opt_virtual_call_type
 724          || entry.rspec().type() == relocInfo::static_call_type
 725          || entry.rspec().type() == relocInfo::virtual_call_type, &quot;wrong reloc type&quot;);
 726 
 727   // We need a trampoline if branches are far.
 728   if (far_branches()) {
 729     bool in_scratch_emit_size = false;
 730 #ifdef COMPILER2
 731     // We don&#39;t want to emit a trampoline if C2 is generating dummy
 732     // code during its branch shortening phase.
 733     CompileTask* task = ciEnv::current()-&gt;task();
 734     in_scratch_emit_size =
 735       (task != NULL &amp;&amp; is_c2_compile(task-&gt;comp_level()) &amp;&amp;
<span class="line-modified"> 736        Compile::current()-&gt;output()-&gt;in_scratch_emit_size());</span>
 737 #endif
 738     if (!in_scratch_emit_size) {
 739       address stub = emit_trampoline_stub(offset(), entry.target());
 740       if (stub == NULL) {
 741         return NULL; // CodeCache is full
 742       }
 743     }
 744   }
 745 
 746   if (cbuf) cbuf-&gt;set_insts_mark();
 747   relocate(entry.rspec());
 748   if (!far_branches()) {
 749     bl(entry.target());
 750   } else {
 751     bl(pc());
 752   }
 753   // just need to return a non-null address
 754   return pc();
 755 }
 756 
</pre>
<hr />
<pre>
4276   bind(loop);
4277   lea(tmp, Address(tmp, -os::vm_page_size()));
4278   subsw(size, size, rscratch1);
4279   str(size, Address(tmp));
4280   br(Assembler::GT, loop);
4281 
4282   // Bang down shadow pages too.
4283   // At this point, (tmp-0) is the last address touched, so don&#39;t
4284   // touch it again.  (It was touched as (tmp-pagesize) but then tmp
4285   // was post-decremented.)  Skip this address by starting at i=1, and
4286   // touch a few more pages below.  N.B.  It is important to touch all
4287   // the way down to and including i=StackShadowPages.
4288   for (int i = 0; i &lt; (int)(JavaThread::stack_shadow_zone_size() / os::vm_page_size()) - 1; i++) {
4289     // this could be any sized move but this is can be a debugging crumb
4290     // so the bigger the better.
4291     lea(tmp, Address(tmp, -os::vm_page_size()));
4292     str(size, Address(tmp));
4293   }
4294 }
4295 

4296 // Move the address of the polling page into dest.
<span class="line-modified">4297 void MacroAssembler::get_polling_page(Register dest, relocInfo::relocType rtype) {</span>
<span class="line-modified">4298   ldr(dest, Address(rthread, Thread::polling_page_offset()));</span>






4299 }
4300 
4301 // Move the address of the polling page into r, then read the polling
4302 // page.
<span class="line-modified">4303 address MacroAssembler::fetch_and_read_polling_page(Register r, relocInfo::relocType rtype) {</span>
<span class="line-modified">4304   get_polling_page(r, rtype);</span>
4305   return read_polling_page(r, rtype);
4306 }
4307 
4308 // Read the polling page.  The address of the polling page must
4309 // already be in r.
4310 address MacroAssembler::read_polling_page(Register r, relocInfo::relocType rtype) {
4311   InstructionMark im(this);
4312   code_section()-&gt;relocate(inst_mark(), rtype);
4313   ldrw(zr, Address(r, 0));
4314   return inst_mark();
4315 }
4316 
4317 void MacroAssembler::adrp(Register reg1, const Address &amp;dest, unsigned long &amp;byte_offset) {
4318   relocInfo::relocType rtype = dest.rspec().reloc()-&gt;type();
4319   unsigned long low_page = (unsigned long)CodeCache::low_bound() &gt;&gt; 12;
4320   unsigned long high_page = (unsigned long)(CodeCache::high_bound()-1) &gt;&gt; 12;
4321   unsigned long dest_page = (unsigned long)dest.target() &gt;&gt; 12;
4322   long offset_low = dest_page - low_page;
4323   long offset_high = dest_page - high_page;
4324 
</pre>
<hr />
<pre>
4377     }
4378   }
4379 }
4380 
4381 void MacroAssembler::remove_frame(int framesize) {
4382   assert(framesize &gt; 0, &quot;framesize must be &gt; 0&quot;);
4383   if (framesize &lt; ((1 &lt;&lt; 9) + 2 * wordSize)) {
4384     ldp(rfp, lr, Address(sp, framesize - 2 * wordSize));
4385     add(sp, sp, framesize);
4386   } else {
4387     if (framesize &lt; ((1 &lt;&lt; 12) + 2 * wordSize))
4388       add(sp, sp, framesize - 2 * wordSize);
4389     else {
4390       mov(rscratch1, framesize - 2 * wordSize);
4391       add(sp, sp, rscratch1);
4392     }
4393     ldp(rfp, lr, Address(post(sp, 2 * wordSize)));
4394   }
4395 }
4396 



























































































































































































































































































































































































































































































































































































































































































































































4397 
4398 // This method checks if provided byte array contains byte with highest bit set.
4399 void MacroAssembler::has_negatives(Register ary1, Register len, Register result) {
4400     // Simple and most common case of aligned small array which is not at the
4401     // end of memory page is placed here. All other cases are in stub.
4402     Label LOOP, END, STUB, STUB_LONG, SET_RESULT, DONE;
4403     const uint64_t UPPER_BIT_MASK=0x8080808080808080;
4404     assert_different_registers(ary1, len, result);
4405 
4406     cmpw(len, 0);
4407     br(LE, SET_RESULT);
4408     cmpw(len, 4 * wordSize);
4409     br(GE, STUB_LONG); // size &gt; 32 then go to stub
4410 
4411     int shift = 64 - exact_log2(os::vm_page_size());
4412     lsl(rscratch1, ary1, shift);
4413     mov(rscratch2, (size_t)(4 * wordSize) &lt;&lt; shift);
4414     adds(rscratch2, rscratch1, rscratch2);  // At end of page?
4415     br(CS, STUB); // at the end of page then go to stub
4416     subs(len, len, wordSize);
</pre>
</td>
</tr>
</table>
<center><a href="interp_masm_aarch64.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_aarch64.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/sparc/macroAssembler_sparc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="interp_masm_sparc.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_sparc.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/sparc/macroAssembler_sparc.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
  32 #include &quot;interpreter/interpreter.hpp&quot;
  33 #include &quot;memory/resourceArea.hpp&quot;
  34 #include &quot;memory/universe.hpp&quot;
  35 #include &quot;oops/accessDecorators.hpp&quot;
  36 #include &quot;oops/compressedOops.hpp&quot;
  37 #include &quot;oops/klass.inline.hpp&quot;
  38 #include &quot;prims/methodHandles.hpp&quot;
  39 #include &quot;runtime/biasedLocking.hpp&quot;
  40 #include &quot;runtime/flags/flagSetting.hpp&quot;
  41 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  42 #include &quot;runtime/jniHandles.inline.hpp&quot;
  43 #include &quot;runtime/objectMonitor.hpp&quot;
  44 #include &quot;runtime/os.inline.hpp&quot;
  45 #include &quot;runtime/safepoint.hpp&quot;
  46 #include &quot;runtime/safepointMechanism.hpp&quot;
  47 #include &quot;runtime/sharedRuntime.hpp&quot;
  48 #include &quot;runtime/stubRoutines.hpp&quot;
  49 #include &quot;utilities/align.hpp&quot;
  50 #include &quot;utilities/macros.hpp&quot;
  51 #include &quot;utilities/powerOfTwo.hpp&quot;
<span class="line-removed">  52 #ifdef COMPILER2</span>
<span class="line-removed">  53 #include &quot;opto/intrinsicnode.hpp&quot;</span>
<span class="line-removed">  54 #endif</span>
  55 
  56 #ifdef PRODUCT
  57 #define BLOCK_COMMENT(str) /* nothing */
  58 #define STOP(error) stop(error)
  59 #else
  60 #define BLOCK_COMMENT(str) block_comment(str)
  61 #define STOP(error) block_comment(error); stop(error)
  62 #endif
  63 
  64 // Convert the raw encoding form into the form expected by the
  65 // constructor for Address.
  66 Address Address::make_raw(int base, int index, int scale, int disp, relocInfo::relocType disp_reloc) {
  67   assert(scale == 0, &quot;not supported&quot;);
  68   RelocationHolder rspec;
  69   if (disp_reloc != relocInfo::none) {
  70     rspec = Relocation::spec_simple(disp_reloc);
  71   }
  72 
  73   Register rindex = as_Register(index);
  74   if (rindex != G0) {
</pre>
<hr />
<pre>
 222   Address a(temp, addrlit.low10() + offset);  // Add the offset to the displacement.
 223   jmpl(a.base(), a.disp(), d);
 224 }
 225 
 226 void MacroAssembler::jump(const AddressLiteral&amp; addrlit, Register temp, int offset, const char* file, int line) {
 227   jumpl(addrlit, temp, G0, offset, file, line);
 228 }
 229 
 230 
 231 // Conditional breakpoint (for assertion checks in assembly code)
 232 void MacroAssembler::breakpoint_trap(Condition c, CC cc) {
 233   trap(c, cc, G0, ST_RESERVED_FOR_USER_0);
 234 }
 235 
 236 // We want to use ST_BREAKPOINT here, but the debugger is confused by it.
 237 void MacroAssembler::breakpoint_trap() {
 238   trap(ST_RESERVED_FOR_USER_0);
 239 }
 240 
 241 void MacroAssembler::safepoint_poll(Label&amp; slow_path, bool a, Register thread_reg, Register temp_reg) {
<span class="line-modified"> 242   if (SafepointMechanism::uses_thread_local_poll()) {</span>
<span class="line-modified"> 243     ldx(Address(thread_reg, Thread::polling_page_offset()), temp_reg, 0);</span>
<span class="line-modified"> 244     // Armed page has poll bit set.</span>
<span class="line-modified"> 245     and3(temp_reg, SafepointMechanism::poll_bit(), temp_reg);</span>
<span class="line-removed"> 246     br_notnull(temp_reg, a, Assembler::pn, slow_path);</span>
<span class="line-removed"> 247   } else {</span>
<span class="line-removed"> 248     AddressLiteral sync_state(SafepointSynchronize::address_of_state());</span>
<span class="line-removed"> 249 </span>
<span class="line-removed"> 250     load_contents(sync_state, temp_reg);</span>
<span class="line-removed"> 251     cmp(temp_reg, SafepointSynchronize::_not_synchronized);</span>
<span class="line-removed"> 252     br(Assembler::notEqual, a, Assembler::pn, slow_path);</span>
<span class="line-removed"> 253   }</span>
 254 }
 255 
 256 void MacroAssembler::enter() {
 257   Unimplemented();
 258 }
 259 
 260 void MacroAssembler::leave() {
 261   Unimplemented();
 262 }
 263 
 264 // Calls to C land
 265 
 266 #ifdef ASSERT
 267 // a hook for debugging
 268 static Thread* reinitialize_thread() {
 269   return Thread::current();
 270 }
 271 #else
 272 #define reinitialize_thread Thread::current
 273 #endif
</pre>
<hr />
<pre>
3419       }
3420     } else {
3421       // shift/mov src into dst.
3422       assert (LogKlassAlignmentInBytes == CompressedKlassPointers::shift() || CompressedKlassPointers::shift() == 0, &quot;decode alg wrong&quot;);
3423       sllx(src, CompressedKlassPointers::shift(), dst);
3424     }
3425   }
3426 }
3427 
3428 void MacroAssembler::reinit_heapbase() {
3429   if (UseCompressedOops || UseCompressedClassPointers) {
3430     if (Universe::heap() != NULL) {
3431       set((intptr_t)CompressedOops::ptrs_base(), G6_heapbase);
3432     } else {
3433       AddressLiteral base(CompressedOops::ptrs_base_addr());
3434       load_ptr_contents(base, G6_heapbase);
3435     }
3436   }
3437 }
3438 
<span class="line-removed">3439 #ifdef COMPILER2</span>
<span class="line-removed">3440 </span>
<span class="line-removed">3441 // Compress char[] to byte[] by compressing 16 bytes at once. Return 0 on failure.</span>
<span class="line-removed">3442 void MacroAssembler::string_compress_16(Register src, Register dst, Register cnt, Register result,</span>
<span class="line-removed">3443                                         Register tmp1, Register tmp2, Register tmp3, Register tmp4,</span>
<span class="line-removed">3444                                         FloatRegister ftmp1, FloatRegister ftmp2, FloatRegister ftmp3, Label&amp; Ldone) {</span>
<span class="line-removed">3445   Label Lloop, Lslow;</span>
<span class="line-removed">3446   assert(UseVIS &gt;= 3, &quot;VIS3 is required&quot;);</span>
<span class="line-removed">3447   assert_different_registers(src, dst, cnt, tmp1, tmp2, tmp3, tmp4, result);</span>
<span class="line-removed">3448   assert_different_registers(ftmp1, ftmp2, ftmp3);</span>
<span class="line-removed">3449 </span>
<span class="line-removed">3450   // Check if cnt &gt;= 8 (= 16 bytes)</span>
<span class="line-removed">3451   cmp(cnt, 8);</span>
<span class="line-removed">3452   br(Assembler::less, false, Assembler::pn, Lslow);</span>
<span class="line-removed">3453   delayed()-&gt;mov(cnt, result); // copy count</span>
<span class="line-removed">3454 </span>
<span class="line-removed">3455   // Check for 8-byte alignment of src and dst</span>
<span class="line-removed">3456   or3(src, dst, tmp1);</span>
<span class="line-removed">3457   andcc(tmp1, 7, G0);</span>
<span class="line-removed">3458   br(Assembler::notZero, false, Assembler::pn, Lslow);</span>
<span class="line-removed">3459   delayed()-&gt;nop();</span>
<span class="line-removed">3460 </span>
<span class="line-removed">3461   // Set mask for bshuffle instruction</span>
<span class="line-removed">3462   Register mask = tmp4;</span>
<span class="line-removed">3463   set(0x13579bdf, mask);</span>
<span class="line-removed">3464   bmask(mask, G0, G0);</span>
<span class="line-removed">3465 </span>
<span class="line-removed">3466   // Set mask to 0xff00 ff00 ff00 ff00 to check for non-latin1 characters</span>
<span class="line-removed">3467   Assembler::sethi(0xff00fc00, mask); // mask = 0x0000 0000 ff00 fc00</span>
<span class="line-removed">3468   add(mask, 0x300, mask);             // mask = 0x0000 0000 ff00 ff00</span>
<span class="line-removed">3469   sllx(mask, 32, tmp1);               // tmp1 = 0xff00 ff00 0000 0000</span>
<span class="line-removed">3470   or3(mask, tmp1, mask);              // mask = 0xff00 ff00 ff00 ff00</span>
<span class="line-removed">3471 </span>
<span class="line-removed">3472   // Load first 8 bytes</span>
<span class="line-removed">3473   ldx(src, 0, tmp1);</span>
<span class="line-removed">3474 </span>
<span class="line-removed">3475   bind(Lloop);</span>
<span class="line-removed">3476   // Load next 8 bytes</span>
<span class="line-removed">3477   ldx(src, 8, tmp2);</span>
<span class="line-removed">3478 </span>
<span class="line-removed">3479   // Check for non-latin1 character by testing if the most significant byte of a char is set.</span>
<span class="line-removed">3480   // Although we have to move the data between integer and floating point registers, this is</span>
<span class="line-removed">3481   // still faster than the corresponding VIS instructions (ford/fand/fcmpd).</span>
<span class="line-removed">3482   or3(tmp1, tmp2, tmp3);</span>
<span class="line-removed">3483   btst(tmp3, mask);</span>
<span class="line-removed">3484   // annul zeroing if branch is not taken to preserve original count</span>
<span class="line-removed">3485   brx(Assembler::notZero, true, Assembler::pn, Ldone);</span>
<span class="line-removed">3486   delayed()-&gt;mov(G0, result); // 0 - failed</span>
<span class="line-removed">3487 </span>
<span class="line-removed">3488   // Move bytes into float register</span>
<span class="line-removed">3489   movxtod(tmp1, ftmp1);</span>
<span class="line-removed">3490   movxtod(tmp2, ftmp2);</span>
<span class="line-removed">3491 </span>
<span class="line-removed">3492   // Compress by copying one byte per char from ftmp1 and ftmp2 to ftmp3</span>
<span class="line-removed">3493   bshuffle(ftmp1, ftmp2, ftmp3);</span>
<span class="line-removed">3494   stf(FloatRegisterImpl::D, ftmp3, dst, 0);</span>
<span class="line-removed">3495 </span>
<span class="line-removed">3496   // Increment addresses and decrement count</span>
<span class="line-removed">3497   inc(src, 16);</span>
<span class="line-removed">3498   inc(dst, 8);</span>
<span class="line-removed">3499   dec(cnt, 8);</span>
<span class="line-removed">3500 </span>
<span class="line-removed">3501   cmp(cnt, 8);</span>
<span class="line-removed">3502   // annul LDX if branch is not taken to prevent access past end of string</span>
<span class="line-removed">3503   br(Assembler::greaterEqual, true, Assembler::pt, Lloop);</span>
<span class="line-removed">3504   delayed()-&gt;ldx(src, 0, tmp1);</span>
<span class="line-removed">3505 </span>
<span class="line-removed">3506   // Fallback to slow version</span>
<span class="line-removed">3507   bind(Lslow);</span>
<span class="line-removed">3508 }</span>
<span class="line-removed">3509 </span>
<span class="line-removed">3510 // Compress char[] to byte[]. Return 0 on failure.</span>
<span class="line-removed">3511 void MacroAssembler::string_compress(Register src, Register dst, Register cnt, Register result, Register tmp, Label&amp; Ldone) {</span>
<span class="line-removed">3512   Label Lloop;</span>
<span class="line-removed">3513   assert_different_registers(src, dst, cnt, tmp, result);</span>
<span class="line-removed">3514 </span>
<span class="line-removed">3515   lduh(src, 0, tmp);</span>
<span class="line-removed">3516 </span>
<span class="line-removed">3517   bind(Lloop);</span>
<span class="line-removed">3518   inc(src, sizeof(jchar));</span>
<span class="line-removed">3519   cmp(tmp, 0xff);</span>
<span class="line-removed">3520   // annul zeroing if branch is not taken to preserve original count</span>
<span class="line-removed">3521   br(Assembler::greater, true, Assembler::pn, Ldone); // don&#39;t check xcc</span>
<span class="line-removed">3522   delayed()-&gt;mov(G0, result); // 0 - failed</span>
<span class="line-removed">3523   deccc(cnt);</span>
<span class="line-removed">3524   stb(tmp, dst, 0);</span>
<span class="line-removed">3525   inc(dst);</span>
<span class="line-removed">3526   // annul LDUH if branch is not taken to prevent access past end of string</span>
<span class="line-removed">3527   br(Assembler::notZero, true, Assembler::pt, Lloop);</span>
<span class="line-removed">3528   delayed()-&gt;lduh(src, 0, tmp); // hoisted</span>
<span class="line-removed">3529 }</span>
<span class="line-removed">3530 </span>
<span class="line-removed">3531 // Inflate byte[] to char[] by inflating 16 bytes at once.</span>
<span class="line-removed">3532 void MacroAssembler::string_inflate_16(Register src, Register dst, Register cnt, Register tmp,</span>
<span class="line-removed">3533                                        FloatRegister ftmp1, FloatRegister ftmp2, FloatRegister ftmp3, FloatRegister ftmp4, Label&amp; Ldone) {</span>
<span class="line-removed">3534   Label Lloop, Lslow;</span>
<span class="line-removed">3535   assert(UseVIS &gt;= 3, &quot;VIS3 is required&quot;);</span>
<span class="line-removed">3536   assert_different_registers(src, dst, cnt, tmp);</span>
<span class="line-removed">3537   assert_different_registers(ftmp1, ftmp2, ftmp3, ftmp4);</span>
<span class="line-removed">3538 </span>
<span class="line-removed">3539   // Check if cnt &gt;= 8 (= 16 bytes)</span>
<span class="line-removed">3540   cmp(cnt, 8);</span>
<span class="line-removed">3541   br(Assembler::less, false, Assembler::pn, Lslow);</span>
<span class="line-removed">3542   delayed()-&gt;nop();</span>
<span class="line-removed">3543 </span>
<span class="line-removed">3544   // Check for 8-byte alignment of src and dst</span>
<span class="line-removed">3545   or3(src, dst, tmp);</span>
<span class="line-removed">3546   andcc(tmp, 7, G0);</span>
<span class="line-removed">3547   br(Assembler::notZero, false, Assembler::pn, Lslow);</span>
<span class="line-removed">3548   // Initialize float register to zero</span>
<span class="line-removed">3549   FloatRegister zerof = ftmp4;</span>
<span class="line-removed">3550   delayed()-&gt;fzero(FloatRegisterImpl::D, zerof);</span>
<span class="line-removed">3551 </span>
<span class="line-removed">3552   // Load first 8 bytes</span>
<span class="line-removed">3553   ldf(FloatRegisterImpl::D, src, 0, ftmp1);</span>
<span class="line-removed">3554 </span>
<span class="line-removed">3555   bind(Lloop);</span>
<span class="line-removed">3556   inc(src, 8);</span>
<span class="line-removed">3557   dec(cnt, 8);</span>
<span class="line-removed">3558 </span>
<span class="line-removed">3559   // Inflate the string by interleaving each byte from the source array</span>
<span class="line-removed">3560   // with a zero byte and storing the result in the destination array.</span>
<span class="line-removed">3561   fpmerge(zerof, ftmp1-&gt;successor(), ftmp2);</span>
<span class="line-removed">3562   stf(FloatRegisterImpl::D, ftmp2, dst, 8);</span>
<span class="line-removed">3563   fpmerge(zerof, ftmp1, ftmp3);</span>
<span class="line-removed">3564   stf(FloatRegisterImpl::D, ftmp3, dst, 0);</span>
<span class="line-removed">3565 </span>
<span class="line-removed">3566   inc(dst, 16);</span>
<span class="line-removed">3567 </span>
<span class="line-removed">3568   cmp(cnt, 8);</span>
<span class="line-removed">3569   // annul LDX if branch is not taken to prevent access past end of string</span>
<span class="line-removed">3570   br(Assembler::greaterEqual, true, Assembler::pt, Lloop);</span>
<span class="line-removed">3571   delayed()-&gt;ldf(FloatRegisterImpl::D, src, 0, ftmp1);</span>
<span class="line-removed">3572 </span>
<span class="line-removed">3573   // Fallback to slow version</span>
<span class="line-removed">3574   bind(Lslow);</span>
<span class="line-removed">3575 }</span>
<span class="line-removed">3576 </span>
<span class="line-removed">3577 // Inflate byte[] to char[].</span>
<span class="line-removed">3578 void MacroAssembler::string_inflate(Register src, Register dst, Register cnt, Register tmp, Label&amp; Ldone) {</span>
<span class="line-removed">3579   Label Loop;</span>
<span class="line-removed">3580   assert_different_registers(src, dst, cnt, tmp);</span>
<span class="line-removed">3581 </span>
<span class="line-removed">3582   ldub(src, 0, tmp);</span>
<span class="line-removed">3583   bind(Loop);</span>
<span class="line-removed">3584   inc(src);</span>
<span class="line-removed">3585   deccc(cnt);</span>
<span class="line-removed">3586   sth(tmp, dst, 0);</span>
<span class="line-removed">3587   inc(dst, sizeof(jchar));</span>
<span class="line-removed">3588   // annul LDUB if branch is not taken to prevent access past end of string</span>
<span class="line-removed">3589   br(Assembler::notZero, true, Assembler::pt, Loop);</span>
<span class="line-removed">3590   delayed()-&gt;ldub(src, 0, tmp); // hoisted</span>
<span class="line-removed">3591 }</span>
<span class="line-removed">3592 </span>
<span class="line-removed">3593 void MacroAssembler::string_compare(Register str1, Register str2,</span>
<span class="line-removed">3594                                     Register cnt1, Register cnt2,</span>
<span class="line-removed">3595                                     Register tmp1, Register tmp2,</span>
<span class="line-removed">3596                                     Register result, int ae) {</span>
<span class="line-removed">3597   Label Ldone, Lloop;</span>
<span class="line-removed">3598   assert_different_registers(str1, str2, cnt1, cnt2, tmp1, result);</span>
<span class="line-removed">3599   int stride1, stride2;</span>
<span class="line-removed">3600 </span>
<span class="line-removed">3601   // Note: Making use of the fact that compareTo(a, b) == -compareTo(b, a)</span>
<span class="line-removed">3602   // we interchange str1 and str2 in the UL case and negate the result.</span>
<span class="line-removed">3603   // Like this, str1 is always latin1 encoded, expect for the UU case.</span>
<span class="line-removed">3604 </span>
<span class="line-removed">3605   if (ae == StrIntrinsicNode::LU || ae == StrIntrinsicNode::UL) {</span>
<span class="line-removed">3606     srl(cnt2, 1, cnt2);</span>
<span class="line-removed">3607   }</span>
<span class="line-removed">3608 </span>
<span class="line-removed">3609   // See if the lengths are different, and calculate min in cnt1.</span>
<span class="line-removed">3610   // Save diff in case we need it for a tie-breaker.</span>
<span class="line-removed">3611   Label Lskip;</span>
<span class="line-removed">3612   Register diff = tmp1;</span>
<span class="line-removed">3613   subcc(cnt1, cnt2, diff);</span>
<span class="line-removed">3614   br(Assembler::greater, true, Assembler::pt, Lskip);</span>
<span class="line-removed">3615   // cnt2 is shorter, so use its count:</span>
<span class="line-removed">3616   delayed()-&gt;mov(cnt2, cnt1);</span>
<span class="line-removed">3617   bind(Lskip);</span>
<span class="line-removed">3618 </span>
<span class="line-removed">3619   // Rename registers</span>
<span class="line-removed">3620   Register limit1 = cnt1;</span>
<span class="line-removed">3621   Register limit2 = limit1;</span>
<span class="line-removed">3622   Register chr1   = result;</span>
<span class="line-removed">3623   Register chr2   = cnt2;</span>
<span class="line-removed">3624   if (ae == StrIntrinsicNode::LU || ae == StrIntrinsicNode::UL) {</span>
<span class="line-removed">3625     // We need an additional register to keep track of two limits</span>
<span class="line-removed">3626     assert_different_registers(str1, str2, cnt1, cnt2, tmp1, tmp2, result);</span>
<span class="line-removed">3627     limit2 = tmp2;</span>
<span class="line-removed">3628   }</span>
<span class="line-removed">3629 </span>
<span class="line-removed">3630   // Is the minimum length zero?</span>
<span class="line-removed">3631   cmp(limit1, (int)0); // use cast to resolve overloading ambiguity</span>
<span class="line-removed">3632   br(Assembler::equal, true, Assembler::pn, Ldone);</span>
<span class="line-removed">3633   // result is difference in lengths</span>
<span class="line-removed">3634   if (ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed">3635     delayed()-&gt;sra(diff, 1, result);  // Divide by 2 to get number of chars</span>
<span class="line-removed">3636   } else {</span>
<span class="line-removed">3637     delayed()-&gt;mov(diff, result);</span>
<span class="line-removed">3638   }</span>
<span class="line-removed">3639 </span>
<span class="line-removed">3640   // Load first characters</span>
<span class="line-removed">3641   if (ae == StrIntrinsicNode::LL) {</span>
<span class="line-removed">3642     stride1 = stride2 = sizeof(jbyte);</span>
<span class="line-removed">3643     ldub(str1, 0, chr1);</span>
<span class="line-removed">3644     ldub(str2, 0, chr2);</span>
<span class="line-removed">3645   } else if (ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed">3646     stride1 = stride2 = sizeof(jchar);</span>
<span class="line-removed">3647     lduh(str1, 0, chr1);</span>
<span class="line-removed">3648     lduh(str2, 0, chr2);</span>
<span class="line-removed">3649   } else {</span>
<span class="line-removed">3650     stride1 = sizeof(jbyte);</span>
<span class="line-removed">3651     stride2 = sizeof(jchar);</span>
<span class="line-removed">3652     ldub(str1, 0, chr1);</span>
<span class="line-removed">3653     lduh(str2, 0, chr2);</span>
<span class="line-removed">3654   }</span>
<span class="line-removed">3655 </span>
<span class="line-removed">3656   // Compare first characters</span>
<span class="line-removed">3657   subcc(chr1, chr2, chr1);</span>
<span class="line-removed">3658   br(Assembler::notZero, false, Assembler::pt, Ldone);</span>
<span class="line-removed">3659   assert(chr1 == result, &quot;result must be pre-placed&quot;);</span>
<span class="line-removed">3660   delayed()-&gt;nop();</span>
<span class="line-removed">3661 </span>
<span class="line-removed">3662   // Check if the strings start at same location</span>
<span class="line-removed">3663   cmp(str1, str2);</span>
<span class="line-removed">3664   brx(Assembler::equal, true, Assembler::pn, Ldone);</span>
<span class="line-removed">3665   delayed()-&gt;mov(G0, result);  // result is zero</span>
<span class="line-removed">3666 </span>
<span class="line-removed">3667   // We have no guarantee that on 64 bit the higher half of limit is 0</span>
<span class="line-removed">3668   signx(limit1);</span>
<span class="line-removed">3669 </span>
<span class="line-removed">3670   // Get limit</span>
<span class="line-removed">3671   if (ae == StrIntrinsicNode::LU || ae == StrIntrinsicNode::UL) {</span>
<span class="line-removed">3672     sll(limit1, 1, limit2);</span>
<span class="line-removed">3673     subcc(limit2, stride2, chr2);</span>
<span class="line-removed">3674   }</span>
<span class="line-removed">3675   subcc(limit1, stride1, chr1);</span>
<span class="line-removed">3676   br(Assembler::zero, true, Assembler::pn, Ldone);</span>
<span class="line-removed">3677   // result is difference in lengths</span>
<span class="line-removed">3678   if (ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed">3679     delayed()-&gt;sra(diff, 1, result);  // Divide by 2 to get number of chars</span>
<span class="line-removed">3680   } else {</span>
<span class="line-removed">3681     delayed()-&gt;mov(diff, result);</span>
<span class="line-removed">3682   }</span>
<span class="line-removed">3683 </span>
<span class="line-removed">3684   // Shift str1 and str2 to the end of the arrays, negate limit</span>
<span class="line-removed">3685   add(str1, limit1, str1);</span>
<span class="line-removed">3686   add(str2, limit2, str2);</span>
<span class="line-removed">3687   neg(chr1, limit1);  // limit1 = -(limit1-stride1)</span>
<span class="line-removed">3688   if (ae == StrIntrinsicNode::LU || ae == StrIntrinsicNode::UL) {</span>
<span class="line-removed">3689     neg(chr2, limit2);  // limit2 = -(limit2-stride2)</span>
<span class="line-removed">3690   }</span>
<span class="line-removed">3691 </span>
<span class="line-removed">3692   // Compare the rest of the characters</span>
<span class="line-removed">3693   load_sized_value(Address(str1, limit1), chr1, (ae == StrIntrinsicNode::UU) ? 2 : 1, false);</span>
<span class="line-removed">3694 </span>
<span class="line-removed">3695   bind(Lloop);</span>
<span class="line-removed">3696   load_sized_value(Address(str2, limit2), chr2, (ae == StrIntrinsicNode::LL) ? 1 : 2, false);</span>
<span class="line-removed">3697 </span>
<span class="line-removed">3698   subcc(chr1, chr2, chr1);</span>
<span class="line-removed">3699   br(Assembler::notZero, false, Assembler::pt, Ldone);</span>
<span class="line-removed">3700   assert(chr1 == result, &quot;result must be pre-placed&quot;);</span>
<span class="line-removed">3701   delayed()-&gt;inccc(limit1, stride1);</span>
<span class="line-removed">3702   if (ae == StrIntrinsicNode::LU || ae == StrIntrinsicNode::UL) {</span>
<span class="line-removed">3703     inccc(limit2, stride2);</span>
<span class="line-removed">3704   }</span>
<span class="line-removed">3705 </span>
<span class="line-removed">3706   // annul LDUB if branch is not taken to prevent access past end of string</span>
<span class="line-removed">3707   br(Assembler::notZero, true, Assembler::pt, Lloop);</span>
<span class="line-removed">3708   delayed()-&gt;load_sized_value(Address(str1, limit1), chr1, (ae == StrIntrinsicNode::UU) ? 2 : 1, false);</span>
<span class="line-removed">3709 </span>
<span class="line-removed">3710   // If strings are equal up to min length, return the length difference.</span>
<span class="line-removed">3711   if (ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed">3712     // Divide by 2 to get number of chars</span>
<span class="line-removed">3713     sra(diff, 1, result);</span>
<span class="line-removed">3714   } else {</span>
<span class="line-removed">3715     mov(diff, result);</span>
<span class="line-removed">3716   }</span>
<span class="line-removed">3717 </span>
<span class="line-removed">3718   // Otherwise, return the difference between the first mismatched chars.</span>
<span class="line-removed">3719   bind(Ldone);</span>
<span class="line-removed">3720   if(ae == StrIntrinsicNode::UL) {</span>
<span class="line-removed">3721     // Negate result (see note above)</span>
<span class="line-removed">3722     neg(result);</span>
<span class="line-removed">3723   }</span>
<span class="line-removed">3724 }</span>
<span class="line-removed">3725 </span>
<span class="line-removed">3726 void MacroAssembler::array_equals(bool is_array_equ, Register ary1, Register ary2,</span>
<span class="line-removed">3727                                   Register limit, Register tmp, Register result, bool is_byte) {</span>
<span class="line-removed">3728   Label Ldone, Lloop, Lremaining;</span>
<span class="line-removed">3729   assert_different_registers(ary1, ary2, limit, tmp, result);</span>
<span class="line-removed">3730 </span>
<span class="line-removed">3731   int length_offset  = arrayOopDesc::length_offset_in_bytes();</span>
<span class="line-removed">3732   int base_offset    = arrayOopDesc::base_offset_in_bytes(is_byte ? T_BYTE : T_CHAR);</span>
<span class="line-removed">3733   assert(base_offset % 8 == 0, &quot;Base offset must be 8-byte aligned&quot;);</span>
<span class="line-removed">3734 </span>
<span class="line-removed">3735   if (is_array_equ) {</span>
<span class="line-removed">3736     // return true if the same array</span>
<span class="line-removed">3737     cmp(ary1, ary2);</span>
<span class="line-removed">3738     brx(Assembler::equal, true, Assembler::pn, Ldone);</span>
<span class="line-removed">3739     delayed()-&gt;mov(1, result);  // equal</span>
<span class="line-removed">3740 </span>
<span class="line-removed">3741     br_null(ary1, true, Assembler::pn, Ldone);</span>
<span class="line-removed">3742     delayed()-&gt;clr(result);     // not equal</span>
<span class="line-removed">3743 </span>
<span class="line-removed">3744     br_null(ary2, true, Assembler::pn, Ldone);</span>
<span class="line-removed">3745     delayed()-&gt;clr(result);     // not equal</span>
<span class="line-removed">3746 </span>
<span class="line-removed">3747     // load the lengths of arrays</span>
<span class="line-removed">3748     ld(Address(ary1, length_offset), limit);</span>
<span class="line-removed">3749     ld(Address(ary2, length_offset), tmp);</span>
<span class="line-removed">3750 </span>
<span class="line-removed">3751     // return false if the two arrays are not equal length</span>
<span class="line-removed">3752     cmp(limit, tmp);</span>
<span class="line-removed">3753     br(Assembler::notEqual, true, Assembler::pn, Ldone);</span>
<span class="line-removed">3754     delayed()-&gt;clr(result);     // not equal</span>
<span class="line-removed">3755   }</span>
<span class="line-removed">3756 </span>
<span class="line-removed">3757   cmp_zero_and_br(Assembler::zero, limit, Ldone, true, Assembler::pn);</span>
<span class="line-removed">3758   delayed()-&gt;mov(1, result); // zero-length arrays are equal</span>
<span class="line-removed">3759 </span>
<span class="line-removed">3760   if (is_array_equ) {</span>
<span class="line-removed">3761     // load array addresses</span>
<span class="line-removed">3762     add(ary1, base_offset, ary1);</span>
<span class="line-removed">3763     add(ary2, base_offset, ary2);</span>
<span class="line-removed">3764     // set byte count</span>
<span class="line-removed">3765     if (!is_byte) {</span>
<span class="line-removed">3766       sll(limit, exact_log2(sizeof(jchar)), limit);</span>
<span class="line-removed">3767     }</span>
<span class="line-removed">3768   } else {</span>
<span class="line-removed">3769     // We have no guarantee that on 64 bit the higher half of limit is 0</span>
<span class="line-removed">3770     signx(limit);</span>
<span class="line-removed">3771   }</span>
<span class="line-removed">3772 </span>
<span class="line-removed">3773 #ifdef ASSERT</span>
<span class="line-removed">3774   // Sanity check for doubleword (8-byte) alignment of ary1 and ary2.</span>
<span class="line-removed">3775   // Guaranteed on 64-bit systems (see arrayOopDesc::header_size_in_bytes()).</span>
<span class="line-removed">3776   Label Laligned;</span>
<span class="line-removed">3777   or3(ary1, ary2, tmp);</span>
<span class="line-removed">3778   andcc(tmp, 7, tmp);</span>
<span class="line-removed">3779   br_null_short(tmp, Assembler::pn, Laligned);</span>
<span class="line-removed">3780   STOP(&quot;First array element is not 8-byte aligned.&quot;);</span>
<span class="line-removed">3781   should_not_reach_here();</span>
<span class="line-removed">3782   bind(Laligned);</span>
<span class="line-removed">3783 #endif</span>
<span class="line-removed">3784 </span>
<span class="line-removed">3785   // Shift ary1 and ary2 to the end of the arrays, negate limit</span>
<span class="line-removed">3786   add(ary1, limit, ary1);</span>
<span class="line-removed">3787   add(ary2, limit, ary2);</span>
<span class="line-removed">3788   neg(limit, limit);</span>
<span class="line-removed">3789 </span>
<span class="line-removed">3790   // MAIN LOOP</span>
<span class="line-removed">3791   // Load and compare array elements of size &#39;byte_width&#39; until the elements are not</span>
<span class="line-removed">3792   // equal or we reached the end of the arrays. If the size of the arrays is not a</span>
<span class="line-removed">3793   // multiple of &#39;byte_width&#39;, we simply read over the end of the array, bail out and</span>
<span class="line-removed">3794   // compare the remaining bytes below by skipping the garbage bytes.</span>
<span class="line-removed">3795   ldx(ary1, limit, result);</span>
<span class="line-removed">3796   bind(Lloop);</span>
<span class="line-removed">3797   ldx(ary2, limit, tmp);</span>
<span class="line-removed">3798   inccc(limit, 8);</span>
<span class="line-removed">3799   // Bail out if we reached the end (but still do the comparison)</span>
<span class="line-removed">3800   br(Assembler::positive, false, Assembler::pn, Lremaining);</span>
<span class="line-removed">3801   delayed()-&gt;cmp(result, tmp);</span>
<span class="line-removed">3802   // Check equality of elements</span>
<span class="line-removed">3803   brx(Assembler::equal, false, Assembler::pt, target(Lloop));</span>
<span class="line-removed">3804   delayed()-&gt;ldx(ary1, limit, result);</span>
<span class="line-removed">3805 </span>
<span class="line-removed">3806   ba(Ldone);</span>
<span class="line-removed">3807   delayed()-&gt;clr(result); // not equal</span>
<span class="line-removed">3808 </span>
<span class="line-removed">3809   // TAIL COMPARISON</span>
<span class="line-removed">3810   // We got here because we reached the end of the arrays. &#39;limit&#39; is the number of</span>
<span class="line-removed">3811   // garbage bytes we may have compared by reading over the end of the arrays. Shift</span>
<span class="line-removed">3812   // out the garbage and compare the remaining elements.</span>
<span class="line-removed">3813   bind(Lremaining);</span>
<span class="line-removed">3814   // Optimistic shortcut: elements potentially including garbage are equal</span>
<span class="line-removed">3815   brx(Assembler::equal, true, Assembler::pt, target(Ldone));</span>
<span class="line-removed">3816   delayed()-&gt;mov(1, result); // equal</span>
<span class="line-removed">3817   // Shift &#39;limit&#39; bytes to the right and compare</span>
<span class="line-removed">3818   sll(limit, 3, limit); // bytes to bits</span>
<span class="line-removed">3819   srlx(result, limit, result);</span>
<span class="line-removed">3820   srlx(tmp, limit, tmp);</span>
<span class="line-removed">3821   cmp(result, tmp);</span>
<span class="line-removed">3822   clr(result);</span>
<span class="line-removed">3823   movcc(Assembler::equal, false, xcc, 1, result);</span>
<span class="line-removed">3824 </span>
<span class="line-removed">3825   bind(Ldone);</span>
<span class="line-removed">3826 }</span>
<span class="line-removed">3827 </span>
<span class="line-removed">3828 void MacroAssembler::has_negatives(Register inp, Register size, Register result, Register t2, Register t3, Register t4, Register t5) {</span>
<span class="line-removed">3829 </span>
<span class="line-removed">3830   // test for negative bytes in input string of a given size</span>
<span class="line-removed">3831   // result 1 if found, 0 otherwise.</span>
<span class="line-removed">3832 </span>
<span class="line-removed">3833   Label Lcore, Ltail, Lreturn, Lcore_rpt;</span>
<span class="line-removed">3834 </span>
<span class="line-removed">3835   assert_different_registers(inp, size, t2, t3, t4, t5, result);</span>
<span class="line-removed">3836 </span>
<span class="line-removed">3837   Register i     = result;  // result used as integer index i until very end</span>
<span class="line-removed">3838   Register lmask = t2;      // t2 is aliased to lmask</span>
<span class="line-removed">3839 </span>
<span class="line-removed">3840   // INITIALIZATION</span>
<span class="line-removed">3841   // ===========================================================</span>
<span class="line-removed">3842   // initialize highbits mask -&gt; lmask = 0x8080808080808080  (8B/64b)</span>
<span class="line-removed">3843   // compute unaligned offset -&gt; i</span>
<span class="line-removed">3844   // compute core end index   -&gt; t5</span>
<span class="line-removed">3845   Assembler::sethi(0x80808000, t2);   //! sethi macro fails to emit optimal</span>
<span class="line-removed">3846   add(t2, 0x80, t2);</span>
<span class="line-removed">3847   sllx(t2, 32, t3);</span>
<span class="line-removed">3848   or3(t3, t2, lmask);                 // 0x8080808080808080 -&gt; lmask</span>
<span class="line-removed">3849   sra(size,0,size);</span>
<span class="line-removed">3850   andcc(inp, 0x7, i);                 // unaligned offset -&gt; i</span>
<span class="line-removed">3851   br(Assembler::zero, true, Assembler::pn, Lcore); // starts 8B aligned?</span>
<span class="line-removed">3852   delayed()-&gt;add(size, -8, t5);       // (annuled) core end index -&gt; t5</span>
<span class="line-removed">3853 </span>
<span class="line-removed">3854   // ===========================================================</span>
<span class="line-removed">3855 </span>
<span class="line-removed">3856   // UNALIGNED HEAD</span>
<span class="line-removed">3857   // ===========================================================</span>
<span class="line-removed">3858   // * unaligned head handling: grab aligned 8B containing unaligned inp(ut)</span>
<span class="line-removed">3859   // * obliterate (ignore) bytes outside string by shifting off reg ends</span>
<span class="line-removed">3860   // * compare with bitmask, short circuit return true if one or more high</span>
<span class="line-removed">3861   //   bits set.</span>
<span class="line-removed">3862   cmp(size, 0);</span>
<span class="line-removed">3863   br(Assembler::zero, true, Assembler::pn, Lreturn); // short-circuit?</span>
<span class="line-removed">3864   delayed()-&gt;mov(0,result);      // annuled so i not clobbered for following</span>
<span class="line-removed">3865   neg(i, t4);</span>
<span class="line-removed">3866   add(i, size, t5);</span>
<span class="line-removed">3867   ldx(inp, t4, t3);  // raw aligned 8B containing unaligned head -&gt; t3</span>
<span class="line-removed">3868   mov(8, t4);</span>
<span class="line-removed">3869   sub(t4, t5, t4);</span>
<span class="line-removed">3870   sra(t4, 31, t5);</span>
<span class="line-removed">3871   andn(t4, t5, t5);</span>
<span class="line-removed">3872   add(i, t5, t4);</span>
<span class="line-removed">3873   sll(t5, 3, t5);</span>
<span class="line-removed">3874   sll(t4, 3, t4);   // # bits to shift right, left -&gt; t5,t4</span>
<span class="line-removed">3875   srlx(t3, t5, t3);</span>
<span class="line-removed">3876   sllx(t3, t4, t3); // bytes outside string in 8B header obliterated -&gt; t3</span>
<span class="line-removed">3877   andcc(lmask, t3, G0);</span>
<span class="line-removed">3878   brx(Assembler::notZero, true, Assembler::pn, Lreturn); // short circuit?</span>
<span class="line-removed">3879   delayed()-&gt;mov(1,result);      // annuled so i not clobbered for following</span>
<span class="line-removed">3880   add(size, -8, t5);             // core end index -&gt; t5</span>
<span class="line-removed">3881   mov(8, t4);</span>
<span class="line-removed">3882   sub(t4, i, i);                 // # bytes examined in unalgn head (&lt;8) -&gt; i</span>
<span class="line-removed">3883   // ===========================================================</span>
<span class="line-removed">3884 </span>
<span class="line-removed">3885   // ALIGNED CORE</span>
<span class="line-removed">3886   // ===========================================================</span>
<span class="line-removed">3887   // * iterate index i over aligned 8B sections of core, comparing with</span>
<span class="line-removed">3888   //   bitmask, short circuit return true if one or more high bits set</span>
<span class="line-removed">3889   // t5 contains core end index/loop limit which is the index</span>
<span class="line-removed">3890   //     of the MSB of last (unaligned) 8B fully contained in the string.</span>
<span class="line-removed">3891   // inp   contains address of first byte in string/array</span>
<span class="line-removed">3892   // lmask contains 8B high bit mask for comparison</span>
<span class="line-removed">3893   // i     contains next index to be processed (adr. inp+i is on 8B boundary)</span>
<span class="line-removed">3894   bind(Lcore);</span>
<span class="line-removed">3895   cmp_and_br_short(i, t5, Assembler::greater, Assembler::pn, Ltail);</span>
<span class="line-removed">3896   bind(Lcore_rpt);</span>
<span class="line-removed">3897   ldx(inp, i, t3);</span>
<span class="line-removed">3898   andcc(t3, lmask, G0);</span>
<span class="line-removed">3899   brx(Assembler::notZero, true, Assembler::pn, Lreturn);</span>
<span class="line-removed">3900   delayed()-&gt;mov(1, result);    // annuled so i not clobbered for following</span>
<span class="line-removed">3901   add(i, 8, i);</span>
<span class="line-removed">3902   cmp_and_br_short(i, t5, Assembler::lessEqual, Assembler::pn, Lcore_rpt);</span>
<span class="line-removed">3903   // ===========================================================</span>
<span class="line-removed">3904 </span>
<span class="line-removed">3905   // ALIGNED TAIL (&lt;8B)</span>
<span class="line-removed">3906   // ===========================================================</span>
<span class="line-removed">3907   // handle aligned tail of 7B or less as complete 8B, obliterating end of</span>
<span class="line-removed">3908   // string bytes by shifting them off end, compare what&#39;s left with bitmask</span>
<span class="line-removed">3909   // inp   contains address of first byte in string/array</span>
<span class="line-removed">3910   // lmask contains 8B high bit mask for comparison</span>
<span class="line-removed">3911   // i     contains next index to be processed (adr. inp+i is on 8B boundary)</span>
<span class="line-removed">3912   bind(Ltail);</span>
<span class="line-removed">3913   subcc(size, i, t4);   // # of remaining bytes in string -&gt; t4</span>
<span class="line-removed">3914   // return 0 if no more remaining bytes</span>
<span class="line-removed">3915   br(Assembler::lessEqual, true, Assembler::pn, Lreturn);</span>
<span class="line-removed">3916   delayed()-&gt;mov(0, result); // annuled so i not clobbered for following</span>
<span class="line-removed">3917   ldx(inp, i, t3);       // load final 8B (aligned) containing tail -&gt; t3</span>
<span class="line-removed">3918   mov(8, t5);</span>
<span class="line-removed">3919   sub(t5, t4, t4);</span>
<span class="line-removed">3920   mov(0, result);        // ** i clobbered at this point</span>
<span class="line-removed">3921   sll(t4, 3, t4);        // bits beyond end of string          -&gt; t4</span>
<span class="line-removed">3922   srlx(t3, t4, t3);      // bytes beyond end now obliterated   -&gt; t3</span>
<span class="line-removed">3923   andcc(lmask, t3, G0);</span>
<span class="line-removed">3924   movcc(Assembler::notZero, false, xcc,  1, result);</span>
<span class="line-removed">3925   bind(Lreturn);</span>
<span class="line-removed">3926 }</span>
<span class="line-removed">3927 </span>
<span class="line-removed">3928 #endif</span>
<span class="line-removed">3929 </span>
<span class="line-removed">3930 </span>
3931 // Use BIS for zeroing (count is in bytes).
3932 void MacroAssembler::bis_zeroing(Register to, Register count, Register temp, Label&amp; Ldone) {
3933   assert(UseBlockZeroing &amp;&amp; VM_Version::has_blk_zeroing(), &quot;only works with BIS zeroing&quot;);
3934   Register end = count;
3935   int cache_line_size = VM_Version::prefetch_data_size();
3936   assert(cache_line_size &gt; 0, &quot;cache line size should be known for this code&quot;);
3937   // Minimum count when BIS zeroing can be used since
3938   // it needs membar which is expensive.
3939   int block_zero_size  = MAX2(cache_line_size*3, (int)BlockZeroingLowLimit);
3940 
3941   Label small_loop;
3942   // Check if count is negative (dead code) or zero.
3943   // Note, count uses 64bit in 64 bit VM.
3944   cmp_and_brx_short(count, 0, Assembler::lessEqual, Assembler::pn, Ldone);
3945 
3946   // Use BIS zeroing only for big arrays since it requires membar.
3947   if (Assembler::is_simm13(block_zero_size)) { // &lt; 4096
3948     cmp(count, block_zero_size);
3949   } else {
3950     set(block_zero_size, temp);
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
  32 #include &quot;interpreter/interpreter.hpp&quot;
  33 #include &quot;memory/resourceArea.hpp&quot;
  34 #include &quot;memory/universe.hpp&quot;
  35 #include &quot;oops/accessDecorators.hpp&quot;
  36 #include &quot;oops/compressedOops.hpp&quot;
  37 #include &quot;oops/klass.inline.hpp&quot;
  38 #include &quot;prims/methodHandles.hpp&quot;
  39 #include &quot;runtime/biasedLocking.hpp&quot;
  40 #include &quot;runtime/flags/flagSetting.hpp&quot;
  41 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  42 #include &quot;runtime/jniHandles.inline.hpp&quot;
  43 #include &quot;runtime/objectMonitor.hpp&quot;
  44 #include &quot;runtime/os.inline.hpp&quot;
  45 #include &quot;runtime/safepoint.hpp&quot;
  46 #include &quot;runtime/safepointMechanism.hpp&quot;
  47 #include &quot;runtime/sharedRuntime.hpp&quot;
  48 #include &quot;runtime/stubRoutines.hpp&quot;
  49 #include &quot;utilities/align.hpp&quot;
  50 #include &quot;utilities/macros.hpp&quot;
  51 #include &quot;utilities/powerOfTwo.hpp&quot;



  52 
  53 #ifdef PRODUCT
  54 #define BLOCK_COMMENT(str) /* nothing */
  55 #define STOP(error) stop(error)
  56 #else
  57 #define BLOCK_COMMENT(str) block_comment(str)
  58 #define STOP(error) block_comment(error); stop(error)
  59 #endif
  60 
  61 // Convert the raw encoding form into the form expected by the
  62 // constructor for Address.
  63 Address Address::make_raw(int base, int index, int scale, int disp, relocInfo::relocType disp_reloc) {
  64   assert(scale == 0, &quot;not supported&quot;);
  65   RelocationHolder rspec;
  66   if (disp_reloc != relocInfo::none) {
  67     rspec = Relocation::spec_simple(disp_reloc);
  68   }
  69 
  70   Register rindex = as_Register(index);
  71   if (rindex != G0) {
</pre>
<hr />
<pre>
 219   Address a(temp, addrlit.low10() + offset);  // Add the offset to the displacement.
 220   jmpl(a.base(), a.disp(), d);
 221 }
 222 
 223 void MacroAssembler::jump(const AddressLiteral&amp; addrlit, Register temp, int offset, const char* file, int line) {
 224   jumpl(addrlit, temp, G0, offset, file, line);
 225 }
 226 
 227 
 228 // Conditional breakpoint (for assertion checks in assembly code)
 229 void MacroAssembler::breakpoint_trap(Condition c, CC cc) {
 230   trap(c, cc, G0, ST_RESERVED_FOR_USER_0);
 231 }
 232 
 233 // We want to use ST_BREAKPOINT here, but the debugger is confused by it.
 234 void MacroAssembler::breakpoint_trap() {
 235   trap(ST_RESERVED_FOR_USER_0);
 236 }
 237 
 238 void MacroAssembler::safepoint_poll(Label&amp; slow_path, bool a, Register thread_reg, Register temp_reg) {
<span class="line-modified"> 239   ldx(Address(thread_reg, Thread::polling_page_offset()), temp_reg, 0);</span>
<span class="line-modified"> 240   // Armed page has poll bit set.</span>
<span class="line-modified"> 241   and3(temp_reg, SafepointMechanism::poll_bit(), temp_reg);</span>
<span class="line-modified"> 242   br_notnull(temp_reg, a, Assembler::pn, slow_path);</span>








 243 }
 244 
 245 void MacroAssembler::enter() {
 246   Unimplemented();
 247 }
 248 
 249 void MacroAssembler::leave() {
 250   Unimplemented();
 251 }
 252 
 253 // Calls to C land
 254 
 255 #ifdef ASSERT
 256 // a hook for debugging
 257 static Thread* reinitialize_thread() {
 258   return Thread::current();
 259 }
 260 #else
 261 #define reinitialize_thread Thread::current
 262 #endif
</pre>
<hr />
<pre>
3408       }
3409     } else {
3410       // shift/mov src into dst.
3411       assert (LogKlassAlignmentInBytes == CompressedKlassPointers::shift() || CompressedKlassPointers::shift() == 0, &quot;decode alg wrong&quot;);
3412       sllx(src, CompressedKlassPointers::shift(), dst);
3413     }
3414   }
3415 }
3416 
3417 void MacroAssembler::reinit_heapbase() {
3418   if (UseCompressedOops || UseCompressedClassPointers) {
3419     if (Universe::heap() != NULL) {
3420       set((intptr_t)CompressedOops::ptrs_base(), G6_heapbase);
3421     } else {
3422       AddressLiteral base(CompressedOops::ptrs_base_addr());
3423       load_ptr_contents(base, G6_heapbase);
3424     }
3425   }
3426 }
3427 












































































































































































































































































































































































































































































































3428 // Use BIS for zeroing (count is in bytes).
3429 void MacroAssembler::bis_zeroing(Register to, Register count, Register temp, Label&amp; Ldone) {
3430   assert(UseBlockZeroing &amp;&amp; VM_Version::has_blk_zeroing(), &quot;only works with BIS zeroing&quot;);
3431   Register end = count;
3432   int cache_line_size = VM_Version::prefetch_data_size();
3433   assert(cache_line_size &gt; 0, &quot;cache line size should be known for this code&quot;);
3434   // Minimum count when BIS zeroing can be used since
3435   // it needs membar which is expensive.
3436   int block_zero_size  = MAX2(cache_line_size*3, (int)BlockZeroingLowLimit);
3437 
3438   Label small_loop;
3439   // Check if count is negative (dead code) or zero.
3440   // Note, count uses 64bit in 64 bit VM.
3441   cmp_and_brx_short(count, 0, Assembler::lessEqual, Assembler::pn, Ldone);
3442 
3443   // Use BIS zeroing only for big arrays since it requires membar.
3444   if (Assembler::is_simm13(block_zero_size)) { // &lt; 4096
3445     cmp(count, block_zero_size);
3446   } else {
3447     set(block_zero_size, temp);
</pre>
</td>
</tr>
</table>
<center><a href="interp_masm_sparc.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_sparc.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
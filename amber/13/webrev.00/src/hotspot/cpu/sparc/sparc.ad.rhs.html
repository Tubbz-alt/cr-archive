<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/sparc/sparc.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>    1 //
<a name="1" id="anc1"></a><span class="line-modified">    2 // Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.</span>
    3 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    4 //
    5 // This code is free software; you can redistribute it and/or modify it
    6 // under the terms of the GNU General Public License version 2 only, as
    7 // published by the Free Software Foundation.
    8 //
    9 // This code is distributed in the hope that it will be useful, but WITHOUT
   10 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   11 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   12 // version 2 for more details (a copy is included in the LICENSE file that
   13 // accompanied this code).
   14 //
   15 // You should have received a copy of the GNU General Public License version
   16 // 2 along with this work; if not, write to the Free Software Foundation,
   17 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   18 //
   19 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   20 // or visit www.oracle.com if you need additional information or have any
   21 // questions.
   22 //
   23 //
   24 
   25 // SPARC Architecture Description File
   26 
   27 //----------REGISTER DEFINITION BLOCK------------------------------------------
   28 // This information is used by the matcher and the register allocator to
   29 // describe individual registers and classes of registers within the target
   30 // archtecture.
   31 register %{
   32 //----------Architecture Description Register Definitions----------------------
   33 // General Registers
   34 // &quot;reg_def&quot;  name ( register save type, C convention save type,
   35 //                   ideal register type, encoding, vm name );
   36 // Register Save Types:
   37 //
   38 // NS  = No-Save:       The register allocator assumes that these registers
   39 //                      can be used without saving upon entry to the method, &amp;
   40 //                      that they do not need to be saved at call sites.
   41 //
   42 // SOC = Save-On-Call:  The register allocator assumes that these registers
   43 //                      can be used without saving upon entry to the method,
   44 //                      but that they must be saved at call sites.
   45 //
   46 // SOE = Save-On-Entry: The register allocator assumes that these registers
   47 //                      must be saved before using them upon entry to the
   48 //                      method, but they do not need to be saved at call
   49 //                      sites.
   50 //
   51 // AS  = Always-Save:   The register allocator assumes that these registers
   52 //                      must be saved before using them upon entry to the
   53 //                      method, &amp; that they must be saved at call sites.
   54 //
   55 // Ideal Register Type is used to determine how to save &amp; restore a
   56 // register.  Op_RegI will get spilled with LoadI/StoreI, Op_RegP will get
   57 // spilled with LoadP/StoreP.  If the register supports both, use Op_RegI.
   58 //
   59 // The encoding number is the actual bit-pattern placed into the opcodes.
   60 
   61 
   62 // ----------------------------
   63 // Integer/Long Registers
   64 // ----------------------------
   65 
   66 // Need to expose the hi/lo aspect of 64-bit registers
   67 // This register set is used for both the 64-bit build and
   68 // the 32-bit build with 1-register longs.
   69 
   70 // Global Registers 0-7
   71 reg_def R_G0H( NS,  NS, Op_RegI,128, G0-&gt;as_VMReg()-&gt;next());
   72 reg_def R_G0 ( NS,  NS, Op_RegI,  0, G0-&gt;as_VMReg());
   73 reg_def R_G1H(SOC, SOC, Op_RegI,129, G1-&gt;as_VMReg()-&gt;next());
   74 reg_def R_G1 (SOC, SOC, Op_RegI,  1, G1-&gt;as_VMReg());
   75 reg_def R_G2H( NS,  NS, Op_RegI,130, G2-&gt;as_VMReg()-&gt;next());
   76 reg_def R_G2 ( NS,  NS, Op_RegI,  2, G2-&gt;as_VMReg());
   77 reg_def R_G3H(SOC, SOC, Op_RegI,131, G3-&gt;as_VMReg()-&gt;next());
   78 reg_def R_G3 (SOC, SOC, Op_RegI,  3, G3-&gt;as_VMReg());
   79 reg_def R_G4H(SOC, SOC, Op_RegI,132, G4-&gt;as_VMReg()-&gt;next());
   80 reg_def R_G4 (SOC, SOC, Op_RegI,  4, G4-&gt;as_VMReg());
   81 reg_def R_G5H(SOC, SOC, Op_RegI,133, G5-&gt;as_VMReg()-&gt;next());
   82 reg_def R_G5 (SOC, SOC, Op_RegI,  5, G5-&gt;as_VMReg());
   83 reg_def R_G6H( NS,  NS, Op_RegI,134, G6-&gt;as_VMReg()-&gt;next());
   84 reg_def R_G6 ( NS,  NS, Op_RegI,  6, G6-&gt;as_VMReg());
   85 reg_def R_G7H( NS,  NS, Op_RegI,135, G7-&gt;as_VMReg()-&gt;next());
   86 reg_def R_G7 ( NS,  NS, Op_RegI,  7, G7-&gt;as_VMReg());
   87 
   88 // Output Registers 0-7
   89 reg_def R_O0H(SOC, SOC, Op_RegI,136, O0-&gt;as_VMReg()-&gt;next());
   90 reg_def R_O0 (SOC, SOC, Op_RegI,  8, O0-&gt;as_VMReg());
   91 reg_def R_O1H(SOC, SOC, Op_RegI,137, O1-&gt;as_VMReg()-&gt;next());
   92 reg_def R_O1 (SOC, SOC, Op_RegI,  9, O1-&gt;as_VMReg());
   93 reg_def R_O2H(SOC, SOC, Op_RegI,138, O2-&gt;as_VMReg()-&gt;next());
   94 reg_def R_O2 (SOC, SOC, Op_RegI, 10, O2-&gt;as_VMReg());
   95 reg_def R_O3H(SOC, SOC, Op_RegI,139, O3-&gt;as_VMReg()-&gt;next());
   96 reg_def R_O3 (SOC, SOC, Op_RegI, 11, O3-&gt;as_VMReg());
   97 reg_def R_O4H(SOC, SOC, Op_RegI,140, O4-&gt;as_VMReg()-&gt;next());
   98 reg_def R_O4 (SOC, SOC, Op_RegI, 12, O4-&gt;as_VMReg());
   99 reg_def R_O5H(SOC, SOC, Op_RegI,141, O5-&gt;as_VMReg()-&gt;next());
  100 reg_def R_O5 (SOC, SOC, Op_RegI, 13, O5-&gt;as_VMReg());
  101 reg_def R_SPH( NS,  NS, Op_RegI,142, SP-&gt;as_VMReg()-&gt;next());
  102 reg_def R_SP ( NS,  NS, Op_RegI, 14, SP-&gt;as_VMReg());
  103 reg_def R_O7H(SOC, SOC, Op_RegI,143, O7-&gt;as_VMReg()-&gt;next());
  104 reg_def R_O7 (SOC, SOC, Op_RegI, 15, O7-&gt;as_VMReg());
  105 
  106 // Local Registers 0-7
  107 reg_def R_L0H( NS,  NS, Op_RegI,144, L0-&gt;as_VMReg()-&gt;next());
  108 reg_def R_L0 ( NS,  NS, Op_RegI, 16, L0-&gt;as_VMReg());
  109 reg_def R_L1H( NS,  NS, Op_RegI,145, L1-&gt;as_VMReg()-&gt;next());
  110 reg_def R_L1 ( NS,  NS, Op_RegI, 17, L1-&gt;as_VMReg());
  111 reg_def R_L2H( NS,  NS, Op_RegI,146, L2-&gt;as_VMReg()-&gt;next());
  112 reg_def R_L2 ( NS,  NS, Op_RegI, 18, L2-&gt;as_VMReg());
  113 reg_def R_L3H( NS,  NS, Op_RegI,147, L3-&gt;as_VMReg()-&gt;next());
  114 reg_def R_L3 ( NS,  NS, Op_RegI, 19, L3-&gt;as_VMReg());
  115 reg_def R_L4H( NS,  NS, Op_RegI,148, L4-&gt;as_VMReg()-&gt;next());
  116 reg_def R_L4 ( NS,  NS, Op_RegI, 20, L4-&gt;as_VMReg());
  117 reg_def R_L5H( NS,  NS, Op_RegI,149, L5-&gt;as_VMReg()-&gt;next());
  118 reg_def R_L5 ( NS,  NS, Op_RegI, 21, L5-&gt;as_VMReg());
  119 reg_def R_L6H( NS,  NS, Op_RegI,150, L6-&gt;as_VMReg()-&gt;next());
  120 reg_def R_L6 ( NS,  NS, Op_RegI, 22, L6-&gt;as_VMReg());
  121 reg_def R_L7H( NS,  NS, Op_RegI,151, L7-&gt;as_VMReg()-&gt;next());
  122 reg_def R_L7 ( NS,  NS, Op_RegI, 23, L7-&gt;as_VMReg());
  123 
  124 // Input Registers 0-7
  125 reg_def R_I0H( NS,  NS, Op_RegI,152, I0-&gt;as_VMReg()-&gt;next());
  126 reg_def R_I0 ( NS,  NS, Op_RegI, 24, I0-&gt;as_VMReg());
  127 reg_def R_I1H( NS,  NS, Op_RegI,153, I1-&gt;as_VMReg()-&gt;next());
  128 reg_def R_I1 ( NS,  NS, Op_RegI, 25, I1-&gt;as_VMReg());
  129 reg_def R_I2H( NS,  NS, Op_RegI,154, I2-&gt;as_VMReg()-&gt;next());
  130 reg_def R_I2 ( NS,  NS, Op_RegI, 26, I2-&gt;as_VMReg());
  131 reg_def R_I3H( NS,  NS, Op_RegI,155, I3-&gt;as_VMReg()-&gt;next());
  132 reg_def R_I3 ( NS,  NS, Op_RegI, 27, I3-&gt;as_VMReg());
  133 reg_def R_I4H( NS,  NS, Op_RegI,156, I4-&gt;as_VMReg()-&gt;next());
  134 reg_def R_I4 ( NS,  NS, Op_RegI, 28, I4-&gt;as_VMReg());
  135 reg_def R_I5H( NS,  NS, Op_RegI,157, I5-&gt;as_VMReg()-&gt;next());
  136 reg_def R_I5 ( NS,  NS, Op_RegI, 29, I5-&gt;as_VMReg());
  137 reg_def R_FPH( NS,  NS, Op_RegI,158, FP-&gt;as_VMReg()-&gt;next());
  138 reg_def R_FP ( NS,  NS, Op_RegI, 30, FP-&gt;as_VMReg());
  139 reg_def R_I7H( NS,  NS, Op_RegI,159, I7-&gt;as_VMReg()-&gt;next());
  140 reg_def R_I7 ( NS,  NS, Op_RegI, 31, I7-&gt;as_VMReg());
  141 
  142 // ----------------------------
  143 // Float/Double Registers
  144 // ----------------------------
  145 
  146 // Float Registers
  147 reg_def R_F0 ( SOC, SOC, Op_RegF,  0, F0-&gt;as_VMReg());
  148 reg_def R_F1 ( SOC, SOC, Op_RegF,  1, F1-&gt;as_VMReg());
  149 reg_def R_F2 ( SOC, SOC, Op_RegF,  2, F2-&gt;as_VMReg());
  150 reg_def R_F3 ( SOC, SOC, Op_RegF,  3, F3-&gt;as_VMReg());
  151 reg_def R_F4 ( SOC, SOC, Op_RegF,  4, F4-&gt;as_VMReg());
  152 reg_def R_F5 ( SOC, SOC, Op_RegF,  5, F5-&gt;as_VMReg());
  153 reg_def R_F6 ( SOC, SOC, Op_RegF,  6, F6-&gt;as_VMReg());
  154 reg_def R_F7 ( SOC, SOC, Op_RegF,  7, F7-&gt;as_VMReg());
  155 reg_def R_F8 ( SOC, SOC, Op_RegF,  8, F8-&gt;as_VMReg());
  156 reg_def R_F9 ( SOC, SOC, Op_RegF,  9, F9-&gt;as_VMReg());
  157 reg_def R_F10( SOC, SOC, Op_RegF, 10, F10-&gt;as_VMReg());
  158 reg_def R_F11( SOC, SOC, Op_RegF, 11, F11-&gt;as_VMReg());
  159 reg_def R_F12( SOC, SOC, Op_RegF, 12, F12-&gt;as_VMReg());
  160 reg_def R_F13( SOC, SOC, Op_RegF, 13, F13-&gt;as_VMReg());
  161 reg_def R_F14( SOC, SOC, Op_RegF, 14, F14-&gt;as_VMReg());
  162 reg_def R_F15( SOC, SOC, Op_RegF, 15, F15-&gt;as_VMReg());
  163 reg_def R_F16( SOC, SOC, Op_RegF, 16, F16-&gt;as_VMReg());
  164 reg_def R_F17( SOC, SOC, Op_RegF, 17, F17-&gt;as_VMReg());
  165 reg_def R_F18( SOC, SOC, Op_RegF, 18, F18-&gt;as_VMReg());
  166 reg_def R_F19( SOC, SOC, Op_RegF, 19, F19-&gt;as_VMReg());
  167 reg_def R_F20( SOC, SOC, Op_RegF, 20, F20-&gt;as_VMReg());
  168 reg_def R_F21( SOC, SOC, Op_RegF, 21, F21-&gt;as_VMReg());
  169 reg_def R_F22( SOC, SOC, Op_RegF, 22, F22-&gt;as_VMReg());
  170 reg_def R_F23( SOC, SOC, Op_RegF, 23, F23-&gt;as_VMReg());
  171 reg_def R_F24( SOC, SOC, Op_RegF, 24, F24-&gt;as_VMReg());
  172 reg_def R_F25( SOC, SOC, Op_RegF, 25, F25-&gt;as_VMReg());
  173 reg_def R_F26( SOC, SOC, Op_RegF, 26, F26-&gt;as_VMReg());
  174 reg_def R_F27( SOC, SOC, Op_RegF, 27, F27-&gt;as_VMReg());
  175 reg_def R_F28( SOC, SOC, Op_RegF, 28, F28-&gt;as_VMReg());
  176 reg_def R_F29( SOC, SOC, Op_RegF, 29, F29-&gt;as_VMReg());
  177 reg_def R_F30( SOC, SOC, Op_RegF, 30, F30-&gt;as_VMReg());
  178 reg_def R_F31( SOC, SOC, Op_RegF, 31, F31-&gt;as_VMReg());
  179 
  180 // Double Registers
  181 // The rules of ADL require that double registers be defined in pairs.
  182 // Each pair must be two 32-bit values, but not necessarily a pair of
  183 // single float registers.  In each pair, ADLC-assigned register numbers
  184 // must be adjacent, with the lower number even.  Finally, when the
  185 // CPU stores such a register pair to memory, the word associated with
  186 // the lower ADLC-assigned number must be stored to the lower address.
  187 
  188 // These definitions specify the actual bit encodings of the sparc
  189 // double fp register numbers.  FloatRegisterImpl in register_sparc.hpp
  190 // wants 0-63, so we have to convert every time we want to use fp regs
  191 // with the macroassembler, using reg_to_DoubleFloatRegister_object().
  192 // 255 is a flag meaning &quot;don&#39;t go here&quot;.
  193 // I believe we can&#39;t handle callee-save doubles D32 and up until
  194 // the place in the sparc stack crawler that asserts on the 255 is
  195 // fixed up.
  196 reg_def R_D32 (SOC, SOC, Op_RegD,  1, F32-&gt;as_VMReg());
  197 reg_def R_D32x(SOC, SOC, Op_RegD,255, F32-&gt;as_VMReg()-&gt;next());
  198 reg_def R_D34 (SOC, SOC, Op_RegD,  3, F34-&gt;as_VMReg());
  199 reg_def R_D34x(SOC, SOC, Op_RegD,255, F34-&gt;as_VMReg()-&gt;next());
  200 reg_def R_D36 (SOC, SOC, Op_RegD,  5, F36-&gt;as_VMReg());
  201 reg_def R_D36x(SOC, SOC, Op_RegD,255, F36-&gt;as_VMReg()-&gt;next());
  202 reg_def R_D38 (SOC, SOC, Op_RegD,  7, F38-&gt;as_VMReg());
  203 reg_def R_D38x(SOC, SOC, Op_RegD,255, F38-&gt;as_VMReg()-&gt;next());
  204 reg_def R_D40 (SOC, SOC, Op_RegD,  9, F40-&gt;as_VMReg());
  205 reg_def R_D40x(SOC, SOC, Op_RegD,255, F40-&gt;as_VMReg()-&gt;next());
  206 reg_def R_D42 (SOC, SOC, Op_RegD, 11, F42-&gt;as_VMReg());
  207 reg_def R_D42x(SOC, SOC, Op_RegD,255, F42-&gt;as_VMReg()-&gt;next());
  208 reg_def R_D44 (SOC, SOC, Op_RegD, 13, F44-&gt;as_VMReg());
  209 reg_def R_D44x(SOC, SOC, Op_RegD,255, F44-&gt;as_VMReg()-&gt;next());
  210 reg_def R_D46 (SOC, SOC, Op_RegD, 15, F46-&gt;as_VMReg());
  211 reg_def R_D46x(SOC, SOC, Op_RegD,255, F46-&gt;as_VMReg()-&gt;next());
  212 reg_def R_D48 (SOC, SOC, Op_RegD, 17, F48-&gt;as_VMReg());
  213 reg_def R_D48x(SOC, SOC, Op_RegD,255, F48-&gt;as_VMReg()-&gt;next());
  214 reg_def R_D50 (SOC, SOC, Op_RegD, 19, F50-&gt;as_VMReg());
  215 reg_def R_D50x(SOC, SOC, Op_RegD,255, F50-&gt;as_VMReg()-&gt;next());
  216 reg_def R_D52 (SOC, SOC, Op_RegD, 21, F52-&gt;as_VMReg());
  217 reg_def R_D52x(SOC, SOC, Op_RegD,255, F52-&gt;as_VMReg()-&gt;next());
  218 reg_def R_D54 (SOC, SOC, Op_RegD, 23, F54-&gt;as_VMReg());
  219 reg_def R_D54x(SOC, SOC, Op_RegD,255, F54-&gt;as_VMReg()-&gt;next());
  220 reg_def R_D56 (SOC, SOC, Op_RegD, 25, F56-&gt;as_VMReg());
  221 reg_def R_D56x(SOC, SOC, Op_RegD,255, F56-&gt;as_VMReg()-&gt;next());
  222 reg_def R_D58 (SOC, SOC, Op_RegD, 27, F58-&gt;as_VMReg());
  223 reg_def R_D58x(SOC, SOC, Op_RegD,255, F58-&gt;as_VMReg()-&gt;next());
  224 reg_def R_D60 (SOC, SOC, Op_RegD, 29, F60-&gt;as_VMReg());
  225 reg_def R_D60x(SOC, SOC, Op_RegD,255, F60-&gt;as_VMReg()-&gt;next());
  226 reg_def R_D62 (SOC, SOC, Op_RegD, 31, F62-&gt;as_VMReg());
  227 reg_def R_D62x(SOC, SOC, Op_RegD,255, F62-&gt;as_VMReg()-&gt;next());
  228 
  229 
  230 // ----------------------------
  231 // Special Registers
  232 // Condition Codes Flag Registers
  233 // I tried to break out ICC and XCC but it&#39;s not very pretty.
  234 // Every Sparc instruction which defs/kills one also kills the other.
  235 // Hence every compare instruction which defs one kind of flags ends
  236 // up needing a kill of the other.
  237 reg_def CCR (SOC, SOC,  Op_RegFlags, 0, VMRegImpl::Bad());
  238 
  239 reg_def FCC0(SOC, SOC,  Op_RegFlags, 0, VMRegImpl::Bad());
  240 reg_def FCC1(SOC, SOC,  Op_RegFlags, 1, VMRegImpl::Bad());
  241 reg_def FCC2(SOC, SOC,  Op_RegFlags, 2, VMRegImpl::Bad());
  242 reg_def FCC3(SOC, SOC,  Op_RegFlags, 3, VMRegImpl::Bad());
  243 
  244 // ----------------------------
  245 // Specify the enum values for the registers.  These enums are only used by the
  246 // OptoReg &quot;class&quot;. We can convert these enum values at will to VMReg when needed
  247 // for visibility to the rest of the vm. The order of this enum influences the
  248 // register allocator so having the freedom to set this order and not be stuck
  249 // with the order that is natural for the rest of the vm is worth it.
  250 alloc_class chunk0(
  251   R_L0,R_L0H, R_L1,R_L1H, R_L2,R_L2H, R_L3,R_L3H, R_L4,R_L4H, R_L5,R_L5H, R_L6,R_L6H, R_L7,R_L7H,
  252   R_G0,R_G0H, R_G1,R_G1H, R_G2,R_G2H, R_G3,R_G3H, R_G4,R_G4H, R_G5,R_G5H, R_G6,R_G6H, R_G7,R_G7H,
  253   R_O7,R_O7H, R_SP,R_SPH, R_O0,R_O0H, R_O1,R_O1H, R_O2,R_O2H, R_O3,R_O3H, R_O4,R_O4H, R_O5,R_O5H,
  254   R_I0,R_I0H, R_I1,R_I1H, R_I2,R_I2H, R_I3,R_I3H, R_I4,R_I4H, R_I5,R_I5H, R_FP,R_FPH, R_I7,R_I7H);
  255 
  256 // Note that a register is not allocatable unless it is also mentioned
  257 // in a widely-used reg_class below.  Thus, R_G7 and R_G0 are outside i_reg.
  258 
  259 alloc_class chunk1(
  260   // The first registers listed here are those most likely to be used
  261   // as temporaries.  We move F0..F7 away from the front of the list,
  262   // to reduce the likelihood of interferences with parameters and
  263   // return values.  Likewise, we avoid using F0/F1 for parameters,
  264   // since they are used for return values.
  265   // This FPU fine-tuning is worth about 1% on the SPEC geomean.
  266   R_F8 ,R_F9 ,R_F10,R_F11,R_F12,R_F13,R_F14,R_F15,
  267   R_F16,R_F17,R_F18,R_F19,R_F20,R_F21,R_F22,R_F23,
  268   R_F24,R_F25,R_F26,R_F27,R_F28,R_F29,R_F30,R_F31,
  269   R_F0 ,R_F1 ,R_F2 ,R_F3 ,R_F4 ,R_F5 ,R_F6 ,R_F7 , // used for arguments and return values
  270   R_D32,R_D32x,R_D34,R_D34x,R_D36,R_D36x,R_D38,R_D38x,
  271   R_D40,R_D40x,R_D42,R_D42x,R_D44,R_D44x,R_D46,R_D46x,
  272   R_D48,R_D48x,R_D50,R_D50x,R_D52,R_D52x,R_D54,R_D54x,
  273   R_D56,R_D56x,R_D58,R_D58x,R_D60,R_D60x,R_D62,R_D62x);
  274 
  275 alloc_class chunk2(CCR, FCC0, FCC1, FCC2, FCC3);
  276 
  277 //----------Architecture Description Register Classes--------------------------
  278 // Several register classes are automatically defined based upon information in
  279 // this architecture description.
  280 // 1) reg_class inline_cache_reg           ( as defined in frame section )
  281 // 2) reg_class interpreter_method_oop_reg ( as defined in frame section )
  282 // 3) reg_class stack_slots( /* one chunk of stack-based &quot;registers&quot; */ )
  283 //
  284 
  285 // G0 is not included in integer class since it has special meaning.
  286 reg_class g0_reg(R_G0);
  287 
  288 // ----------------------------
  289 // Integer Register Classes
  290 // ----------------------------
  291 // Exclusions from i_reg:
  292 // R_G0: hardwired zero
  293 // R_G2: reserved by HotSpot to the TLS register (invariant within Java)
  294 // R_G6: reserved by Solaris ABI to tools
  295 // R_G7: reserved by Solaris ABI to libthread
  296 // R_O7: Used as a temp in many encodings
  297 reg_class int_reg(R_G1,R_G3,R_G4,R_G5,R_O0,R_O1,R_O2,R_O3,R_O4,R_O5,R_L0,R_L1,R_L2,R_L3,R_L4,R_L5,R_L6,R_L7,R_I0,R_I1,R_I2,R_I3,R_I4,R_I5);
  298 
  299 // Class for all integer registers, except the G registers.  This is used for
  300 // encodings which use G registers as temps.  The regular inputs to such
  301 // instructions use a &quot;notemp_&quot; prefix, as a hack to ensure that the allocator
  302 // will not put an input into a temp register.
  303 reg_class notemp_int_reg(R_O0,R_O1,R_O2,R_O3,R_O4,R_O5,R_L0,R_L1,R_L2,R_L3,R_L4,R_L5,R_L6,R_L7,R_I0,R_I1,R_I2,R_I3,R_I4,R_I5);
  304 
  305 reg_class g1_regI(R_G1);
  306 reg_class g3_regI(R_G3);
  307 reg_class g4_regI(R_G4);
  308 reg_class o0_regI(R_O0);
  309 reg_class o7_regI(R_O7);
  310 
  311 // ----------------------------
  312 // Pointer Register Classes
  313 // ----------------------------
  314 // 64-bit build means 64-bit pointers means hi/lo pairs
  315 reg_class ptr_reg(            R_G1H,R_G1,             R_G3H,R_G3, R_G4H,R_G4, R_G5H,R_G5,
  316                   R_O0H,R_O0, R_O1H,R_O1, R_O2H,R_O2, R_O3H,R_O3, R_O4H,R_O4, R_O5H,R_O5,
  317                   R_L0H,R_L0, R_L1H,R_L1, R_L2H,R_L2, R_L3H,R_L3, R_L4H,R_L4, R_L5H,R_L5, R_L6H,R_L6, R_L7H,R_L7,
  318                   R_I0H,R_I0, R_I1H,R_I1, R_I2H,R_I2, R_I3H,R_I3, R_I4H,R_I4, R_I5H,R_I5 );
  319 // Lock encodings use G3 and G4 internally
  320 reg_class lock_ptr_reg(       R_G1H,R_G1,                                     R_G5H,R_G5,
  321                   R_O0H,R_O0, R_O1H,R_O1, R_O2H,R_O2, R_O3H,R_O3, R_O4H,R_O4, R_O5H,R_O5,
  322                   R_L0H,R_L0, R_L1H,R_L1, R_L2H,R_L2, R_L3H,R_L3, R_L4H,R_L4, R_L5H,R_L5, R_L6H,R_L6, R_L7H,R_L7,
  323                   R_I0H,R_I0, R_I1H,R_I1, R_I2H,R_I2, R_I3H,R_I3, R_I4H,R_I4, R_I5H,R_I5 );
  324 // Special class for storeP instructions, which can store SP or RPC to TLS.
  325 // It is also used for memory addressing, allowing direct TLS addressing.
  326 reg_class sp_ptr_reg(         R_G1H,R_G1, R_G2H,R_G2, R_G3H,R_G3, R_G4H,R_G4, R_G5H,R_G5,
  327                   R_O0H,R_O0, R_O1H,R_O1, R_O2H,R_O2, R_O3H,R_O3, R_O4H,R_O4, R_O5H,R_O5, R_SPH,R_SP,
  328                   R_L0H,R_L0, R_L1H,R_L1, R_L2H,R_L2, R_L3H,R_L3, R_L4H,R_L4, R_L5H,R_L5, R_L6H,R_L6, R_L7H,R_L7,
  329                   R_I0H,R_I0, R_I1H,R_I1, R_I2H,R_I2, R_I3H,R_I3, R_I4H,R_I4, R_I5H,R_I5, R_FPH,R_FP );
  330 // R_L7 is the lowest-priority callee-save (i.e., NS) register
  331 // We use it to save R_G2 across calls out of Java.
  332 reg_class l7_regP(R_L7H,R_L7);
  333 
  334 // Other special pointer regs
  335 reg_class g1_regP(R_G1H,R_G1);
  336 reg_class g2_regP(R_G2H,R_G2);
  337 reg_class g3_regP(R_G3H,R_G3);
  338 reg_class g4_regP(R_G4H,R_G4);
  339 reg_class g5_regP(R_G5H,R_G5);
  340 reg_class i0_regP(R_I0H,R_I0);
  341 reg_class o0_regP(R_O0H,R_O0);
  342 reg_class o1_regP(R_O1H,R_O1);
  343 reg_class o2_regP(R_O2H,R_O2);
  344 reg_class o7_regP(R_O7H,R_O7);
  345 
  346 
  347 // ----------------------------
  348 // Long Register Classes
  349 // ----------------------------
  350 // Longs in 1 register.  Aligned adjacent hi/lo pairs.
  351 // Note:  O7 is never in this class; it is sometimes used as an encoding temp.
  352 reg_class long_reg(             R_G1H,R_G1,             R_G3H,R_G3, R_G4H,R_G4, R_G5H,R_G5
  353                    ,R_O0H,R_O0, R_O1H,R_O1, R_O2H,R_O2, R_O3H,R_O3, R_O4H,R_O4, R_O5H,R_O5
  354 // 64-bit, longs in 1 register: use all 64-bit integer registers
  355                    ,R_L0H,R_L0, R_L1H,R_L1, R_L2H,R_L2, R_L3H,R_L3, R_L4H,R_L4, R_L5H,R_L5, R_L6H,R_L6, R_L7H,R_L7
  356                    ,R_I0H,R_I0, R_I1H,R_I1, R_I2H,R_I2, R_I3H,R_I3, R_I4H,R_I4, R_I5H,R_I5
  357                   );
  358 
  359 reg_class g1_regL(R_G1H,R_G1);
  360 reg_class g3_regL(R_G3H,R_G3);
  361 reg_class o2_regL(R_O2H,R_O2);
  362 reg_class o7_regL(R_O7H,R_O7);
  363 
  364 // ----------------------------
  365 // Special Class for Condition Code Flags Register
  366 reg_class int_flags(CCR);
  367 reg_class float_flags(FCC0,FCC1,FCC2,FCC3);
  368 reg_class float_flag0(FCC0);
  369 
  370 
  371 // ----------------------------
  372 // Float Point Register Classes
  373 // ----------------------------
  374 // Skip F30/F31, they are reserved for mem-mem copies
  375 reg_class sflt_reg(R_F0,R_F1,R_F2,R_F3,R_F4,R_F5,R_F6,R_F7,R_F8,R_F9,R_F10,R_F11,R_F12,R_F13,R_F14,R_F15,R_F16,R_F17,R_F18,R_F19,R_F20,R_F21,R_F22,R_F23,R_F24,R_F25,R_F26,R_F27,R_F28,R_F29);
  376 
  377 // Paired floating point registers--they show up in the same order as the floats,
  378 // but they are used with the &quot;Op_RegD&quot; type, and always occur in even/odd pairs.
  379 reg_class dflt_reg(R_F0, R_F1, R_F2, R_F3, R_F4, R_F5, R_F6, R_F7, R_F8, R_F9, R_F10,R_F11,R_F12,R_F13,R_F14,R_F15,
  380                    R_F16,R_F17,R_F18,R_F19,R_F20,R_F21,R_F22,R_F23,R_F24,R_F25,R_F26,R_F27,R_F28,R_F29,
  381                    /* Use extra V9 double registers; this AD file does not support V8 */
  382                    R_D32,R_D32x,R_D34,R_D34x,R_D36,R_D36x,R_D38,R_D38x,R_D40,R_D40x,R_D42,R_D42x,R_D44,R_D44x,R_D46,R_D46x,
  383                    R_D48,R_D48x,R_D50,R_D50x,R_D52,R_D52x,R_D54,R_D54x,R_D56,R_D56x,R_D58,R_D58x,R_D60,R_D60x,R_D62,R_D62x
  384                    );
  385 
  386 // Paired floating point registers--they show up in the same order as the floats,
  387 // but they are used with the &quot;Op_RegD&quot; type, and always occur in even/odd pairs.
  388 // This class is usable for mis-aligned loads as happen in I2C adapters.
  389 reg_class dflt_low_reg(R_F0, R_F1, R_F2, R_F3, R_F4, R_F5, R_F6, R_F7, R_F8, R_F9, R_F10,R_F11,R_F12,R_F13,R_F14,R_F15,
  390                    R_F16,R_F17,R_F18,R_F19,R_F20,R_F21,R_F22,R_F23,R_F24,R_F25,R_F26,R_F27,R_F28,R_F29);
  391 %}
  392 
  393 //----------DEFINITION BLOCK---------------------------------------------------
  394 // Define name --&gt; value mappings to inform the ADLC of an integer valued name
  395 // Current support includes integer values in the range [0, 0x7FFFFFFF]
  396 // Format:
  397 //        int_def  &lt;name&gt;         ( &lt;int_value&gt;, &lt;expression&gt;);
  398 // Generated Code in ad_&lt;arch&gt;.hpp
  399 //        #define  &lt;name&gt;   (&lt;expression&gt;)
  400 //        // value == &lt;int_value&gt;
  401 // Generated code in ad_&lt;arch&gt;.cpp adlc_verification()
  402 //        assert( &lt;name&gt; == &lt;int_value&gt;, &quot;Expect (&lt;expression&gt;) to equal &lt;int_value&gt;&quot;);
  403 //
  404 definitions %{
  405 // The default cost (of an ALU instruction).
  406   int_def DEFAULT_COST      (    100,     100);
  407   int_def HUGE_COST         (1000000, 1000000);
  408 
  409 // Memory refs are twice as expensive as run-of-the-mill.
  410   int_def MEMORY_REF_COST   (    200, DEFAULT_COST * 2);
  411 
  412 // Branches are even more expensive.
  413   int_def BRANCH_COST       (    300, DEFAULT_COST * 3);
  414   int_def CALL_COST         (    300, DEFAULT_COST * 3);
  415 %}
  416 
  417 
  418 //----------SOURCE BLOCK-------------------------------------------------------
  419 // This is a block of C++ code which provides values, functions, and
  420 // definitions necessary in the rest of the architecture description
  421 source_hpp %{
  422 // Header information of the source block.
  423 // Method declarations/definitions which are used outside
  424 // the ad-scope can conveniently be defined here.
  425 //
  426 // To keep related declarations/definitions/uses close together,
  427 // we switch between source %{ }% and source_hpp %{ }% freely as needed.
  428 
  429 // Must be visible to the DFA in dfa_sparc.cpp
  430 extern bool can_branch_register( Node *bol, Node *cmp );
  431 
  432 extern bool use_block_zeroing(Node* count);
  433 
  434 // Macros to extract hi &amp; lo halves from a long pair.
  435 // G0 is not part of any long pair, so assert on that.
  436 // Prevents accidentally using G1 instead of G0.
  437 #define LONG_HI_REG(x) (x)
  438 #define LONG_LO_REG(x) (x)
  439 
  440 class CallStubImpl {
  441 
  442   //--------------------------------------------------------------
  443   //---&lt;  Used for optimization in Compile::Shorten_branches  &gt;---
  444   //--------------------------------------------------------------
  445 
  446  public:
  447   // Size of call trampoline stub.
  448   static uint size_call_trampoline() {
  449     return 0; // no call trampolines on this platform
  450   }
  451 
  452   // number of relocations needed by a call trampoline stub
  453   static uint reloc_call_trampoline() {
  454     return 0; // no call trampolines on this platform
  455   }
  456 };
  457 
  458 class HandlerImpl {
  459 
  460  public:
  461 
  462   static int emit_exception_handler(CodeBuffer &amp;cbuf);
  463   static int emit_deopt_handler(CodeBuffer&amp; cbuf);
  464 
  465   static uint size_exception_handler() {
  466     return ( NativeJump::instruction_size ); // sethi;jmp;nop
  467   }
  468 
  469   static uint size_deopt_handler() {
  470     return ( 4+  NativeJump::instruction_size ); // save;sethi;jmp;restore
  471   }
  472 };
  473 
<a name="2" id="anc2"></a><span class="line-added">  474 class Node::PD {</span>
<span class="line-added">  475 public:</span>
<span class="line-added">  476   enum NodeFlags {</span>
<span class="line-added">  477     _last_flag = Node::_last_flag</span>
<span class="line-added">  478   };</span>
<span class="line-added">  479 };</span>
<span class="line-added">  480 </span>
  481 %}
  482 
  483 source %{
  484 #define __ _masm.
  485 
  486 // tertiary op of a LoadP or StoreP encoding
  487 #define REGP_OP true
  488 
  489 static FloatRegister reg_to_SingleFloatRegister_object(int register_encoding);
  490 static FloatRegister reg_to_DoubleFloatRegister_object(int register_encoding);
  491 static Register reg_to_register_object(int register_encoding);
  492 
<a name="3" id="anc3"></a><span class="line-added">  493 void PhaseOutput::pd_perform_mach_node_analysis() {</span>
<span class="line-added">  494 }</span>
<span class="line-added">  495 </span>
<span class="line-added">  496 int MachNode::pd_alignment_required() const {</span>
<span class="line-added">  497   return 1;</span>
<span class="line-added">  498 }</span>
<span class="line-added">  499 </span>
<span class="line-added">  500 int MachNode::compute_padding(int current_offset) const {</span>
<span class="line-added">  501   return 0;</span>
<span class="line-added">  502 }</span>
<span class="line-added">  503 </span>
  504 // Used by the DFA in dfa_sparc.cpp.
  505 // Check for being able to use a V9 branch-on-register.  Requires a
  506 // compare-vs-zero, equal/not-equal, of a value which was zero- or sign-
  507 // extended.  Doesn&#39;t work following an integer ADD, for example, because of
  508 // overflow (-1 incremented yields 0 plus a carry in the high-order word).  On
  509 // 32-bit V9 systems, interrupts currently blow away the high-order 32 bits and
  510 // replace them with zero, which could become sign-extension in a different OS
  511 // release.  There&#39;s no obvious reason why an interrupt will ever fill these
  512 // bits with non-zero junk (the registers are reloaded with standard LD
  513 // instructions which either zero-fill or sign-fill).
  514 bool can_branch_register( Node *bol, Node *cmp ) {
  515   if( !BranchOnRegister ) return false;
  516   if( cmp-&gt;Opcode() == Op_CmpP )
  517     return true;  // No problems with pointer compares
  518   if( cmp-&gt;Opcode() == Op_CmpL )
  519     return true;  // No problems with long compares
  520 
  521   if( !SparcV9RegsHiBitsZero ) return false;
  522   if( bol-&gt;as_Bool()-&gt;_test._test != BoolTest::ne &amp;&amp;
  523       bol-&gt;as_Bool()-&gt;_test._test != BoolTest::eq )
  524      return false;
  525 
  526   // Check for comparing against a &#39;safe&#39; value.  Any operation which
  527   // clears out the high word is safe.  Thus, loads and certain shifts
  528   // are safe, as are non-negative constants.  Any operation which
  529   // preserves zero bits in the high word is safe as long as each of its
  530   // inputs are safe.  Thus, phis and bitwise booleans are safe if their
  531   // inputs are safe.  At present, the only important case to recognize
  532   // seems to be loads.  Constants should fold away, and shifts &amp;
  533   // logicals can use the &#39;cc&#39; forms.
  534   Node *x = cmp-&gt;in(1);
  535   if( x-&gt;is_Load() ) return true;
  536   if( x-&gt;is_Phi() ) {
  537     for( uint i = 1; i &lt; x-&gt;req(); i++ )
  538       if( !x-&gt;in(i)-&gt;is_Load() )
  539         return false;
  540     return true;
  541   }
  542   return false;
  543 }
  544 
  545 bool use_block_zeroing(Node* count) {
  546   // Use BIS for zeroing if count is not constant
  547   // or it is &gt;= BlockZeroingLowLimit.
  548   return UseBlockZeroing &amp;&amp; (count-&gt;find_intptr_t_con(BlockZeroingLowLimit) &gt;= BlockZeroingLowLimit);
  549 }
  550 
  551 // ****************************************************************************
  552 
  553 // REQUIRED FUNCTIONALITY
  554 
  555 // !!!!! Special hack to get all type of calls to specify the byte offset
  556 //       from the start of the call to the point where the return address
  557 //       will point.
  558 //       The &quot;return address&quot; is the address of the call instruction, plus 8.
  559 
  560 int MachCallStaticJavaNode::ret_addr_offset() {
  561   int offset = NativeCall::instruction_size;  // call; delay slot
  562   if (_method_handle_invoke)
  563     offset += 4;  // restore SP
  564   return offset;
  565 }
  566 
  567 int MachCallDynamicJavaNode::ret_addr_offset() {
  568   int vtable_index = this-&gt;_vtable_index;
  569   if (vtable_index &lt; 0) {
  570     // must be invalid_vtable_index, not nonvirtual_vtable_index
  571     assert(vtable_index == Method::invalid_vtable_index, &quot;correct sentinel value&quot;);
  572     return (NativeMovConstReg::instruction_size +
  573            NativeCall::instruction_size);  // sethi; setlo; call; delay slot
  574   } else {
  575     assert(!UseInlineCaches, &quot;expect vtable calls only if not using ICs&quot;);
  576     int entry_offset = in_bytes(Klass::vtable_start_offset()) + vtable_index*vtableEntry::size_in_bytes();
  577     int v_off = entry_offset + vtableEntry::method_offset_in_bytes();
  578     int klass_load_size;
  579     if (UseCompressedClassPointers) {
  580       assert(Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
  581       klass_load_size = MacroAssembler::instr_size_for_decode_klass_not_null() + 1*BytesPerInstWord;
  582     } else {
  583       klass_load_size = 1*BytesPerInstWord;
  584     }
  585     if (Assembler::is_simm13(v_off)) {
  586       return klass_load_size +
  587              (2*BytesPerInstWord +           // ld_ptr, ld_ptr
  588              NativeCall::instruction_size);  // call; delay slot
  589     } else {
  590       return klass_load_size +
  591              (4*BytesPerInstWord +           // set_hi, set, ld_ptr, ld_ptr
  592              NativeCall::instruction_size);  // call; delay slot
  593     }
  594   }
  595 }
  596 
  597 int MachCallRuntimeNode::ret_addr_offset() {
  598   if (MacroAssembler::is_far_target(entry_point())) {
  599     return NativeFarCall::instruction_size;
  600   } else {
  601     return NativeCall::instruction_size;
  602   }
  603 }
  604 
  605 // Indicate if the safepoint node needs the polling page as an input.
  606 // Since Sparc does not have absolute addressing, it does.
  607 bool SafePointNode::needs_polling_address_input() {
  608   return true;
  609 }
  610 
  611 // emit an interrupt that is caught by the debugger (for debugging compiler)
  612 void emit_break(CodeBuffer &amp;cbuf) {
<a name="4" id="anc4"></a><span class="line-modified">  613   C2_MacroAssembler _masm(&amp;cbuf);</span>
  614   __ breakpoint_trap();
  615 }
  616 
  617 #ifndef PRODUCT
  618 void MachBreakpointNode::format( PhaseRegAlloc *, outputStream *st ) const {
  619   st-&gt;print(&quot;TA&quot;);
  620 }
  621 #endif
  622 
  623 void MachBreakpointNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  624   emit_break(cbuf);
  625 }
  626 
  627 uint MachBreakpointNode::size(PhaseRegAlloc *ra_) const {
  628   return MachNode::size(ra_);
  629 }
  630 
  631 // Traceable jump
  632 void  emit_jmpl(CodeBuffer &amp;cbuf, int jump_target) {
<a name="5" id="anc5"></a><span class="line-modified">  633   C2_MacroAssembler _masm(&amp;cbuf);</span>
  634   Register rdest = reg_to_register_object(jump_target);
  635   __ JMP(rdest, 0);
  636   __ delayed()-&gt;nop();
  637 }
  638 
  639 // Traceable jump and set exception pc
  640 void  emit_jmpl_set_exception_pc(CodeBuffer &amp;cbuf, int jump_target) {
<a name="6" id="anc6"></a><span class="line-modified">  641   C2_MacroAssembler _masm(&amp;cbuf);</span>
  642   Register rdest = reg_to_register_object(jump_target);
  643   __ JMP(rdest, 0);
  644   __ delayed()-&gt;add(O7, frame::pc_return_offset, Oissuing_pc );
  645 }
  646 
  647 void emit_nop(CodeBuffer &amp;cbuf) {
<a name="7" id="anc7"></a><span class="line-modified">  648   C2_MacroAssembler _masm(&amp;cbuf);</span>
  649   __ nop();
  650 }
  651 
  652 void emit_illtrap(CodeBuffer &amp;cbuf) {
<a name="8" id="anc8"></a><span class="line-modified">  653   C2_MacroAssembler _masm(&amp;cbuf);</span>
  654   __ illtrap(0);
  655 }
  656 
  657 
  658 intptr_t get_offset_from_base(const MachNode* n, const TypePtr* atype, int disp32) {
  659   assert(n-&gt;rule() != loadUB_rule, &quot;&quot;);
  660 
  661   intptr_t offset = 0;
  662   const TypePtr *adr_type = TYPE_PTR_SENTINAL;  // Check for base==RegI, disp==immP
  663   const Node* addr = n-&gt;get_base_and_disp(offset, adr_type);
  664   assert(adr_type == (const TypePtr*)-1, &quot;VerifyOops: no support for sparc operands with base==RegI, disp==immP&quot;);
  665   assert(addr != NULL &amp;&amp; addr != (Node*)-1, &quot;invalid addr&quot;);
  666   assert(addr-&gt;bottom_type()-&gt;isa_oopptr() == atype, &quot;&quot;);
  667   atype = atype-&gt;add_offset(offset);
  668   assert(disp32 == offset, &quot;wrong disp32&quot;);
  669   return atype-&gt;_offset;
  670 }
  671 
  672 
  673 intptr_t get_offset_from_base_2(const MachNode* n, const TypePtr* atype, int disp32) {
  674   assert(n-&gt;rule() != loadUB_rule, &quot;&quot;);
  675 
  676   intptr_t offset = 0;
  677   Node* addr = n-&gt;in(2);
  678   assert(addr-&gt;bottom_type()-&gt;isa_oopptr() == atype, &quot;&quot;);
  679   if (addr-&gt;is_Mach() &amp;&amp; addr-&gt;as_Mach()-&gt;ideal_Opcode() == Op_AddP) {
  680     Node* a = addr-&gt;in(2/*AddPNode::Address*/);
  681     Node* o = addr-&gt;in(3/*AddPNode::Offset*/);
  682     offset = o-&gt;is_Con() ? o-&gt;bottom_type()-&gt;is_intptr_t()-&gt;get_con() : Type::OffsetBot;
  683     atype = a-&gt;bottom_type()-&gt;is_ptr()-&gt;add_offset(offset);
  684     assert(atype-&gt;isa_oop_ptr(), &quot;still an oop&quot;);
  685   }
  686   offset = atype-&gt;is_ptr()-&gt;_offset;
  687   if (offset != Type::OffsetBot)  offset += disp32;
  688   return offset;
  689 }
  690 
  691 static inline jlong replicate_immI(int con, int count, int width) {
  692   // Load a constant replicated &quot;count&quot; times with width &quot;width&quot;
  693   assert(count*width == 8 &amp;&amp; width &lt;= 4, &quot;sanity&quot;);
  694   int bit_width = width * 8;
  695   jlong val = con;
  696   val &amp;= (((jlong) 1) &lt;&lt; bit_width) - 1;  // mask off sign bits
  697   for (int i = 0; i &lt; count - 1; i++) {
  698     val |= (val &lt;&lt; bit_width);
  699   }
  700   return val;
  701 }
  702 
  703 static inline jlong replicate_immF(float con) {
  704   // Replicate float con 2 times and pack into vector.
  705   int val = *((int*)&amp;con);
  706   jlong lval = val;
  707   lval = (lval &lt;&lt; 32) | (lval &amp; 0xFFFFFFFFl);
  708   return lval;
  709 }
  710 
  711 // Standard Sparc opcode form2 field breakdown
  712 static inline void emit2_19(CodeBuffer &amp;cbuf, int f30, int f29, int f25, int f22, int f20, int f19, int f0 ) {
  713   f0 &amp;= (1&lt;&lt;19)-1;     // Mask displacement to 19 bits
  714   int op = (f30 &lt;&lt; 30) |
  715            (f29 &lt;&lt; 29) |
  716            (f25 &lt;&lt; 25) |
  717            (f22 &lt;&lt; 22) |
  718            (f20 &lt;&lt; 20) |
  719            (f19 &lt;&lt; 19) |
  720            (f0  &lt;&lt;  0);
  721   cbuf.insts()-&gt;emit_int32(op);
  722 }
  723 
  724 // Standard Sparc opcode form2 field breakdown
  725 static inline void emit2_22(CodeBuffer &amp;cbuf, int f30, int f25, int f22, int f0 ) {
  726   f0 &gt;&gt;= 10;           // Drop 10 bits
  727   f0 &amp;= (1&lt;&lt;22)-1;     // Mask displacement to 22 bits
  728   int op = (f30 &lt;&lt; 30) |
  729            (f25 &lt;&lt; 25) |
  730            (f22 &lt;&lt; 22) |
  731            (f0  &lt;&lt;  0);
  732   cbuf.insts()-&gt;emit_int32(op);
  733 }
  734 
  735 // Standard Sparc opcode form3 field breakdown
  736 static inline void emit3(CodeBuffer &amp;cbuf, int f30, int f25, int f19, int f14, int f5, int f0 ) {
  737   int op = (f30 &lt;&lt; 30) |
  738            (f25 &lt;&lt; 25) |
  739            (f19 &lt;&lt; 19) |
  740            (f14 &lt;&lt; 14) |
  741            (f5  &lt;&lt;  5) |
  742            (f0  &lt;&lt;  0);
  743   cbuf.insts()-&gt;emit_int32(op);
  744 }
  745 
  746 // Standard Sparc opcode form3 field breakdown
  747 static inline void emit3_simm13(CodeBuffer &amp;cbuf, int f30, int f25, int f19, int f14, int simm13 ) {
  748   simm13 &amp;= (1&lt;&lt;13)-1; // Mask to 13 bits
  749   int op = (f30 &lt;&lt; 30) |
  750            (f25 &lt;&lt; 25) |
  751            (f19 &lt;&lt; 19) |
  752            (f14 &lt;&lt; 14) |
  753            (1   &lt;&lt; 13) | // bit to indicate immediate-mode
  754            (simm13&lt;&lt;0);
  755   cbuf.insts()-&gt;emit_int32(op);
  756 }
  757 
  758 static inline void emit3_simm10(CodeBuffer &amp;cbuf, int f30, int f25, int f19, int f14, int simm10 ) {
  759   simm10 &amp;= (1&lt;&lt;10)-1; // Mask to 10 bits
  760   emit3_simm13(cbuf,f30,f25,f19,f14,simm10);
  761 }
  762 
  763 #ifdef ASSERT
  764 // Helper function for VerifyOops in emit_form3_mem_reg
  765 void verify_oops_warning(const MachNode *n, int ideal_op, int mem_op) {
  766   warning(&quot;VerifyOops encountered unexpected instruction:&quot;);
  767   n-&gt;dump(2);
  768   warning(&quot;Instruction has ideal_Opcode==Op_%s and op_ld==Op_%s \n&quot;, NodeClassNames[ideal_op], NodeClassNames[mem_op]);
  769 }
  770 #endif
  771 
  772 
  773 void emit_form3_mem_reg(CodeBuffer &amp;cbuf, PhaseRegAlloc* ra, const MachNode* n, int primary, int tertiary,
  774                         int src1_enc, int disp32, int src2_enc, int dst_enc) {
  775 
  776 #ifdef ASSERT
  777   // The following code implements the +VerifyOops feature.
  778   // It verifies oop values which are loaded into or stored out of
  779   // the current method activation.  +VerifyOops complements techniques
  780   // like ScavengeALot, because it eagerly inspects oops in transit,
  781   // as they enter or leave the stack, as opposed to ScavengeALot,
  782   // which inspects oops &quot;at rest&quot;, in the stack or heap, at safepoints.
  783   // For this reason, +VerifyOops can sometimes detect bugs very close
  784   // to their point of creation.  It can also serve as a cross-check
  785   // on the validity of oop maps, when used toegether with ScavengeALot.
  786 
  787   // It would be good to verify oops at other points, especially
  788   // when an oop is used as a base pointer for a load or store.
  789   // This is presently difficult, because it is hard to know when
  790   // a base address is biased or not.  (If we had such information,
  791   // it would be easy and useful to make a two-argument version of
  792   // verify_oop which unbiases the base, and performs verification.)
  793 
  794   assert((uint)tertiary == 0xFFFFFFFF || tertiary == REGP_OP, &quot;valid tertiary&quot;);
  795   bool is_verified_oop_base  = false;
  796   bool is_verified_oop_load  = false;
  797   bool is_verified_oop_store = false;
  798   int tmp_enc = -1;
  799   if (VerifyOops &amp;&amp; src1_enc != R_SP_enc) {
  800     // classify the op, mainly for an assert check
  801     int st_op = 0, ld_op = 0;
  802     switch (primary) {
  803     case Assembler::stb_op3:  st_op = Op_StoreB; break;
  804     case Assembler::sth_op3:  st_op = Op_StoreC; break;
  805     case Assembler::stx_op3:  // may become StoreP or stay StoreI or StoreD0
  806     case Assembler::stw_op3:  st_op = Op_StoreI; break;
  807     case Assembler::std_op3:  st_op = Op_StoreL; break;
  808     case Assembler::stf_op3:  st_op = Op_StoreF; break;
  809     case Assembler::stdf_op3: st_op = Op_StoreD; break;
  810 
  811     case Assembler::ldsb_op3: ld_op = Op_LoadB; break;
  812     case Assembler::ldub_op3: ld_op = Op_LoadUB; break;
  813     case Assembler::lduh_op3: ld_op = Op_LoadUS; break;
  814     case Assembler::ldsh_op3: ld_op = Op_LoadS; break;
  815     case Assembler::ldx_op3:  // may become LoadP or stay LoadI
  816     case Assembler::ldsw_op3: // may become LoadP or stay LoadI
  817     case Assembler::lduw_op3: ld_op = Op_LoadI; break;
  818     case Assembler::ldd_op3:  ld_op = Op_LoadL; break;
  819     case Assembler::ldf_op3:  ld_op = Op_LoadF; break;
  820     case Assembler::lddf_op3: ld_op = Op_LoadD; break;
  821     case Assembler::prefetch_op3: ld_op = Op_LoadI; break;
  822 
  823     default: ShouldNotReachHere();
  824     }
  825     if (tertiary == REGP_OP) {
  826       if      (st_op == Op_StoreI)  st_op = Op_StoreP;
  827       else if (ld_op == Op_LoadI)   ld_op = Op_LoadP;
  828       else                          ShouldNotReachHere();
  829       if (st_op) {
  830         // a store
  831         // inputs are (0:control, 1:memory, 2:address, 3:value)
  832         Node* n2 = n-&gt;in(3);
  833         if (n2 != NULL) {
  834           const Type* t = n2-&gt;bottom_type();
  835           is_verified_oop_store = t-&gt;isa_oop_ptr() ? (t-&gt;is_ptr()-&gt;_offset==0) : false;
  836         }
  837       } else {
  838         // a load
  839         const Type* t = n-&gt;bottom_type();
  840         is_verified_oop_load = t-&gt;isa_oop_ptr() ? (t-&gt;is_ptr()-&gt;_offset==0) : false;
  841       }
  842     }
  843 
  844     if (ld_op) {
  845       // a Load
  846       // inputs are (0:control, 1:memory, 2:address)
  847       if (!(n-&gt;ideal_Opcode()==ld_op)       &amp;&amp; // Following are special cases
  848           !(n-&gt;ideal_Opcode()==Op_LoadPLocked &amp;&amp; ld_op==Op_LoadP) &amp;&amp;
  849           !(n-&gt;ideal_Opcode()==Op_LoadI     &amp;&amp; ld_op==Op_LoadF) &amp;&amp;
  850           !(n-&gt;ideal_Opcode()==Op_LoadF     &amp;&amp; ld_op==Op_LoadI) &amp;&amp;
  851           !(n-&gt;ideal_Opcode()==Op_LoadRange &amp;&amp; ld_op==Op_LoadI) &amp;&amp;
  852           !(n-&gt;ideal_Opcode()==Op_LoadKlass &amp;&amp; ld_op==Op_LoadP) &amp;&amp;
  853           !(n-&gt;ideal_Opcode()==Op_LoadL     &amp;&amp; ld_op==Op_LoadI) &amp;&amp;
  854           !(n-&gt;ideal_Opcode()==Op_LoadL_unaligned &amp;&amp; ld_op==Op_LoadI) &amp;&amp;
  855           !(n-&gt;ideal_Opcode()==Op_LoadD_unaligned &amp;&amp; ld_op==Op_LoadF) &amp;&amp;
  856           !(n-&gt;ideal_Opcode()==Op_ConvI2F   &amp;&amp; ld_op==Op_LoadF) &amp;&amp;
  857           !(n-&gt;ideal_Opcode()==Op_ConvI2D   &amp;&amp; ld_op==Op_LoadF) &amp;&amp;
  858           !(n-&gt;ideal_Opcode()==Op_PrefetchAllocation &amp;&amp; ld_op==Op_LoadI) &amp;&amp;
  859           !(n-&gt;ideal_Opcode()==Op_LoadVector &amp;&amp; ld_op==Op_LoadD) &amp;&amp;
  860           !(n-&gt;rule() == loadUB_rule)) {
  861         verify_oops_warning(n, n-&gt;ideal_Opcode(), ld_op);
  862       }
  863     } else if (st_op) {
  864       // a Store
  865       // inputs are (0:control, 1:memory, 2:address, 3:value)
  866       if (!(n-&gt;ideal_Opcode()==st_op)    &amp;&amp; // Following are special cases
  867           !(n-&gt;ideal_Opcode()==Op_StoreCM &amp;&amp; st_op==Op_StoreB) &amp;&amp;
  868           !(n-&gt;ideal_Opcode()==Op_StoreI &amp;&amp; st_op==Op_StoreF) &amp;&amp;
  869           !(n-&gt;ideal_Opcode()==Op_StoreF &amp;&amp; st_op==Op_StoreI) &amp;&amp;
  870           !(n-&gt;ideal_Opcode()==Op_StoreL &amp;&amp; st_op==Op_StoreI) &amp;&amp;
  871           !(n-&gt;ideal_Opcode()==Op_StoreVector &amp;&amp; st_op==Op_StoreD) &amp;&amp;
  872           !(n-&gt;ideal_Opcode()==Op_StoreD &amp;&amp; st_op==Op_StoreI &amp;&amp; n-&gt;rule() == storeD0_rule)) {
  873         verify_oops_warning(n, n-&gt;ideal_Opcode(), st_op);
  874       }
  875     }
  876 
  877     if (src2_enc == R_G0_enc &amp;&amp; n-&gt;rule() != loadUB_rule &amp;&amp; n-&gt;ideal_Opcode() != Op_StoreCM ) {
  878       Node* addr = n-&gt;in(2);
  879       if (!(addr-&gt;is_Mach() &amp;&amp; addr-&gt;as_Mach()-&gt;ideal_Opcode() == Op_AddP)) {
  880         const TypeOopPtr* atype = addr-&gt;bottom_type()-&gt;isa_instptr();  // %%% oopptr?
  881         if (atype != NULL) {
  882           intptr_t offset = get_offset_from_base(n, atype, disp32);
  883           intptr_t offset_2 = get_offset_from_base_2(n, atype, disp32);
  884           if (offset != offset_2) {
  885             get_offset_from_base(n, atype, disp32);
  886             get_offset_from_base_2(n, atype, disp32);
  887           }
  888           assert(offset == offset_2, &quot;different offsets&quot;);
  889           if (offset == disp32) {
  890             // we now know that src1 is a true oop pointer
  891             is_verified_oop_base = true;
  892             if (ld_op &amp;&amp; src1_enc == dst_enc &amp;&amp; ld_op != Op_LoadF &amp;&amp; ld_op != Op_LoadD) {
  893               if( primary == Assembler::ldd_op3 ) {
  894                 is_verified_oop_base = false; // Cannot &#39;ldd&#39; into O7
  895               } else {
  896                 tmp_enc = dst_enc;
  897                 dst_enc = R_O7_enc; // Load into O7; preserve source oop
  898                 assert(src1_enc != dst_enc, &quot;&quot;);
  899               }
  900             }
  901           }
  902           if (st_op &amp;&amp; (( offset == oopDesc::klass_offset_in_bytes())
  903                        || offset == oopDesc::mark_offset_in_bytes())) {
  904                       // loading the mark should not be allowed either, but
  905                       // we don&#39;t check this since it conflicts with InlineObjectHash
  906                       // usage of LoadINode to get the mark. We could keep the
  907                       // check if we create a new LoadMarkNode
  908             // but do not verify the object before its header is initialized
  909             ShouldNotReachHere();
  910           }
  911         }
  912       }
  913     }
  914   }
  915 #endif
  916 
  917   uint instr = (Assembler::ldst_op &lt;&lt; 30)
  918              | (dst_enc        &lt;&lt; 25)
  919              | (primary        &lt;&lt; 19)
  920              | (src1_enc       &lt;&lt; 14);
  921 
  922   uint index = src2_enc;
  923   int disp = disp32;
  924 
  925   if (src1_enc == R_SP_enc || src1_enc == R_FP_enc) {
  926     disp += STACK_BIAS;
  927     // Check that stack offset fits, load into O7 if not
  928     if (!Assembler::is_simm13(disp)) {
<a name="9" id="anc9"></a><span class="line-modified">  929       C2_MacroAssembler _masm(&amp;cbuf);</span>
  930       __ set(disp, O7);
  931       if (index != R_G0_enc) {
  932         __ add(O7, reg_to_register_object(index), O7);
  933       }
  934       index = R_O7_enc;
  935       disp = 0;
  936     }
  937   }
  938 
  939   if( disp == 0 ) {
  940     // use reg-reg form
  941     // bit 13 is already zero
  942     instr |= index;
  943   } else {
  944     // use reg-imm form
  945     instr |= 0x00002000;          // set bit 13 to one
  946     instr |= disp &amp; 0x1FFF;
  947   }
  948 
  949   cbuf.insts()-&gt;emit_int32(instr);
  950 
  951 #ifdef ASSERT
  952   if (VerifyOops) {
<a name="10" id="anc10"></a><span class="line-modified">  953     C2_MacroAssembler _masm(&amp;cbuf);</span>
  954     if (is_verified_oop_base) {
  955       __ verify_oop(reg_to_register_object(src1_enc));
  956     }
  957     if (is_verified_oop_store) {
  958       __ verify_oop(reg_to_register_object(dst_enc));
  959     }
  960     if (tmp_enc != -1) {
  961       __ mov(O7, reg_to_register_object(tmp_enc));
  962     }
  963     if (is_verified_oop_load) {
  964       __ verify_oop(reg_to_register_object(dst_enc));
  965     }
  966   }
  967 #endif
  968 }
  969 
  970 void emit_call_reloc(CodeBuffer &amp;cbuf, intptr_t entry_point, RelocationHolder const&amp; rspec, bool preserve_g2 = false) {
  971   // The method which records debug information at every safepoint
  972   // expects the call to be the first instruction in the snippet as
  973   // it creates a PcDesc structure which tracks the offset of a call
  974   // from the start of the codeBlob. This offset is computed as
  975   // code_end() - code_begin() of the code which has been emitted
  976   // so far.
  977   // In this particular case we have skirted around the problem by
  978   // putting the &quot;mov&quot; instruction in the delay slot but the problem
  979   // may bite us again at some other point and a cleaner/generic
  980   // solution using relocations would be needed.
<a name="11" id="anc11"></a><span class="line-modified">  981   C2_MacroAssembler _masm(&amp;cbuf);</span>
  982   __ set_inst_mark();
  983 
  984   // We flush the current window just so that there is a valid stack copy
  985   // the fact that the current window becomes active again instantly is
  986   // not a problem there is nothing live in it.
  987 
  988 #ifdef ASSERT
  989   int startpos = __ offset();
  990 #endif /* ASSERT */
  991 
  992   __ call((address)entry_point, rspec);
  993 
  994   if (preserve_g2)   __ delayed()-&gt;mov(G2, L7);
  995   else __ delayed()-&gt;nop();
  996 
  997   if (preserve_g2)   __ mov(L7, G2);
  998 
  999 #ifdef ASSERT
 1000   if (preserve_g2 &amp;&amp; (VerifyCompiledCode || VerifyOops)) {
 1001     // Trash argument dump slots.
 1002     __ set(0xb0b8ac0db0b8ac0d, G1);
 1003     __ mov(G1, G5);
 1004     __ stx(G1, SP, STACK_BIAS + 0x80);
 1005     __ stx(G1, SP, STACK_BIAS + 0x88);
 1006     __ stx(G1, SP, STACK_BIAS + 0x90);
 1007     __ stx(G1, SP, STACK_BIAS + 0x98);
 1008     __ stx(G1, SP, STACK_BIAS + 0xA0);
 1009     __ stx(G1, SP, STACK_BIAS + 0xA8);
 1010   }
 1011 #endif /*ASSERT*/
 1012 }
 1013 
 1014 //=============================================================================
 1015 // REQUIRED FUNCTIONALITY for encoding
 1016 void emit_lo(CodeBuffer &amp;cbuf, int val) {  }
 1017 void emit_hi(CodeBuffer &amp;cbuf, int val) {  }
 1018 
 1019 
 1020 //=============================================================================
 1021 const RegMask&amp; MachConstantBaseNode::_out_RegMask = PTR_REG_mask();
 1022 
<a name="12" id="anc12"></a><span class="line-modified"> 1023 int ConstantTable::calculate_table_base_offset() const {</span>
 1024   if (UseRDPCForConstantTableBase) {
 1025     // The table base offset might be less but then it fits into
 1026     // simm13 anyway and we are good (cf. MachConstantBaseNode::emit).
 1027     return Assembler::min_simm13();
 1028   } else {
 1029     int offset = -(size() / 2);
 1030     if (!Assembler::is_simm13(offset)) {
 1031       offset = Assembler::min_simm13();
 1032     }
 1033     return offset;
 1034   }
 1035 }
 1036 
 1037 bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
 1038 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
 1039   ShouldNotReachHere();
 1040 }
 1041 
 1042 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
 1043   Compile* C = ra_-&gt;C;
<a name="13" id="anc13"></a><span class="line-modified"> 1044   ConstantTable&amp; constant_table = C-&gt;output()-&gt;constant_table();</span>
<span class="line-modified"> 1045   C2_MacroAssembler _masm(&amp;cbuf);</span>
 1046 
 1047   Register r = as_Register(ra_-&gt;get_encode(this));
 1048   CodeSection* consts_section = __ code()-&gt;consts();
 1049   int consts_size = consts_section-&gt;align_at_start(consts_section-&gt;size());
 1050   assert(constant_table.size() == consts_size, &quot;must be: %d == %d&quot;, constant_table.size(), consts_size);
 1051 
 1052   if (UseRDPCForConstantTableBase) {
 1053     // For the following RDPC logic to work correctly the consts
 1054     // section must be allocated right before the insts section.  This
 1055     // assert checks for that.  The layout and the SECT_* constants
 1056     // are defined in src/share/vm/asm/codeBuffer.hpp.
 1057     assert(CodeBuffer::SECT_CONSTS + 1 == CodeBuffer::SECT_INSTS, &quot;must be&quot;);
 1058     int insts_offset = __ offset();
 1059 
 1060     // Layout:
 1061     //
 1062     // |----------- consts section ------------|----------- insts section -----------...
 1063     // |------ constant table -----|- padding -|------------------x----
 1064     //                                                            \ current PC (RDPC instruction)
 1065     // |&lt;------------- consts_size -----------&gt;|&lt;- insts_offset -&gt;|
 1066     //                                                            \ table base
 1067     // The table base offset is later added to the load displacement
 1068     // so it has to be negative.
 1069     int table_base_offset = -(consts_size + insts_offset);
 1070     int disp;
 1071 
 1072     // If the displacement from the current PC to the constant table
 1073     // base fits into simm13 we set the constant table base to the
 1074     // current PC.
 1075     if (Assembler::is_simm13(table_base_offset)) {
 1076       constant_table.set_table_base_offset(table_base_offset);
 1077       disp = 0;
 1078     } else {
 1079       // Otherwise we set the constant table base offset to the
 1080       // maximum negative displacement of load instructions to keep
 1081       // the disp as small as possible:
 1082       //
 1083       // |&lt;------------- consts_size -----------&gt;|&lt;- insts_offset -&gt;|
 1084       // |&lt;--------- min_simm13 ---------&gt;|&lt;-------- disp ---------&gt;|
 1085       //                                  \ table base
 1086       table_base_offset = Assembler::min_simm13();
 1087       constant_table.set_table_base_offset(table_base_offset);
 1088       disp = (consts_size + insts_offset) + table_base_offset;
 1089     }
 1090 
 1091     __ rdpc(r);
 1092 
 1093     if (disp == 0) {
 1094       // Emitting an additional &#39;nop&#39; instruction in order not to cause a code
 1095       // size adjustment in the code following the table setup (if the instruction
 1096       // immediately following after this section is a CTI).
 1097       __ nop();
 1098     }
 1099     else {
 1100       assert(r != O7, &quot;need temporary&quot;);
 1101       __ sub(r, __ ensure_simm13_or_reg(disp, O7), r);
 1102     }
 1103   }
 1104   else {
 1105     // Materialize the constant table base.
 1106     address baseaddr = consts_section-&gt;start() + -(constant_table.table_base_offset());
 1107     RelocationHolder rspec = internal_word_Relocation::spec(baseaddr);
 1108     AddressLiteral base(baseaddr, rspec);
 1109     __ set(base, r);
 1110   }
 1111 }
 1112 
 1113 uint MachConstantBaseNode::size(PhaseRegAlloc*) const {
 1114   if (UseRDPCForConstantTableBase) {
 1115     // This is really the worst case but generally it&#39;s only 1 instruction.
 1116     return (1 /*rdpc*/ + 1 /*sub*/ + MacroAssembler::worst_case_insts_for_set()) * BytesPerInstWord;
 1117   } else {
 1118     return MacroAssembler::worst_case_insts_for_set() * BytesPerInstWord;
 1119   }
 1120 }
 1121 
 1122 #ifndef PRODUCT
 1123 void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
 1124   char reg[128];
 1125   ra_-&gt;dump_register(this, reg);
 1126   if (UseRDPCForConstantTableBase) {
 1127     st-&gt;print(&quot;RDPC   %s\t! constant table base&quot;, reg);
 1128   } else {
 1129     st-&gt;print(&quot;SET    &amp;constanttable,%s\t! constant table base&quot;, reg);
 1130   }
 1131 }
 1132 #endif
 1133 
 1134 
 1135 //=============================================================================
 1136 
 1137 #ifndef PRODUCT
 1138 void MachPrologNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
 1139   Compile* C = ra_-&gt;C;
 1140 
 1141   for (int i = 0; i &lt; OptoPrologueNops; i++) {
 1142     st-&gt;print_cr(&quot;NOP&quot;); st-&gt;print(&quot;\t&quot;);
 1143   }
 1144 
 1145   if( VerifyThread ) {
 1146     st-&gt;print_cr(&quot;Verify_Thread&quot;); st-&gt;print(&quot;\t&quot;);
 1147   }
 1148 
<a name="14" id="anc14"></a><span class="line-modified"> 1149   size_t framesize = C-&gt;output()-&gt;frame_size_in_bytes();</span>
<span class="line-modified"> 1150   int bangsize = C-&gt;output()-&gt;bang_size_in_bytes();</span>
 1151 
 1152   // Calls to C2R adapters often do not accept exceptional returns.
 1153   // We require that their callers must bang for them.  But be careful, because
 1154   // some VM calls (such as call site linkage) can use several kilobytes of
 1155   // stack.  But the stack safety zone should account for that.
 1156   // See bugs 4446381, 4468289, 4497237.
<a name="15" id="anc15"></a><span class="line-modified"> 1157   if (C-&gt;output()-&gt;need_stack_bang(bangsize)) {</span>
 1158     st-&gt;print_cr(&quot;! stack bang (%d bytes)&quot;, bangsize); st-&gt;print(&quot;\t&quot;);
 1159   }
 1160 
 1161   if (Assembler::is_simm13(-framesize)) {
 1162     st-&gt;print   (&quot;SAVE   R_SP,-&quot; SIZE_FORMAT &quot;,R_SP&quot;,framesize);
 1163   } else {
 1164     st-&gt;print_cr(&quot;SETHI  R_SP,hi%%(-&quot; SIZE_FORMAT &quot;),R_G3&quot;,framesize); st-&gt;print(&quot;\t&quot;);
 1165     st-&gt;print_cr(&quot;ADD    R_G3,lo%%(-&quot; SIZE_FORMAT &quot;),R_G3&quot;,framesize); st-&gt;print(&quot;\t&quot;);
 1166     st-&gt;print   (&quot;SAVE   R_SP,R_G3,R_SP&quot;);
 1167   }
 1168 
 1169 }
 1170 #endif
 1171 
 1172 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1173   Compile* C = ra_-&gt;C;
<a name="16" id="anc16"></a><span class="line-modified"> 1174   C2_MacroAssembler _masm(&amp;cbuf);</span>
 1175 
 1176   for (int i = 0; i &lt; OptoPrologueNops; i++) {
 1177     __ nop();
 1178   }
 1179 
 1180   __ verify_thread();
 1181 
<a name="17" id="anc17"></a><span class="line-modified"> 1182   size_t framesize = C-&gt;output()-&gt;frame_size_in_bytes();</span>
 1183   assert(framesize &gt;= 16*wordSize, &quot;must have room for reg. save area&quot;);
 1184   assert(framesize%(2*wordSize) == 0, &quot;must preserve 2*wordSize alignment&quot;);
<a name="18" id="anc18"></a><span class="line-modified"> 1185   int bangsize = C-&gt;output()-&gt;bang_size_in_bytes();</span>
 1186 
 1187   // Calls to C2R adapters often do not accept exceptional returns.
 1188   // We require that their callers must bang for them.  But be careful, because
 1189   // some VM calls (such as call site linkage) can use several kilobytes of
 1190   // stack.  But the stack safety zone should account for that.
 1191   // See bugs 4446381, 4468289, 4497237.
<a name="19" id="anc19"></a><span class="line-modified"> 1192   if (C-&gt;output()-&gt;need_stack_bang(bangsize)) {</span>
 1193     __ generate_stack_overflow_check(bangsize);
 1194   }
 1195 
 1196   if (Assembler::is_simm13(-framesize)) {
 1197     __ save(SP, -framesize, SP);
 1198   } else {
 1199     __ sethi(-framesize &amp; ~0x3ff, G3);
 1200     __ add(G3, -framesize &amp; 0x3ff, G3);
 1201     __ save(SP, G3, SP);
 1202   }
<a name="20" id="anc20"></a><span class="line-modified"> 1203   C-&gt;output()-&gt;set_frame_complete( __ offset() );</span>
 1204 
 1205   if (!UseRDPCForConstantTableBase &amp;&amp; C-&gt;has_mach_constant_base_node()) {
 1206     // NOTE: We set the table base offset here because users might be
 1207     // emitted before MachConstantBaseNode.
<a name="21" id="anc21"></a><span class="line-modified"> 1208     ConstantTable&amp; constant_table = C-&gt;output()-&gt;constant_table();</span>
 1209     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
 1210   }
 1211 }
 1212 
 1213 uint MachPrologNode::size(PhaseRegAlloc *ra_) const {
 1214   return MachNode::size(ra_);
 1215 }
 1216 
 1217 int MachPrologNode::reloc() const {
 1218   return 10; // a large enough number
 1219 }
 1220 
 1221 //=============================================================================
 1222 #ifndef PRODUCT
 1223 void MachEpilogNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
 1224   Compile* C = ra_-&gt;C;
 1225 
 1226   if(do_polling() &amp;&amp; ra_-&gt;C-&gt;is_method_compilation()) {
<a name="22" id="anc22"></a><span class="line-modified"> 1227     st-&gt;print(&quot;LDX    [R_G2 + #poll_offset],L0\t! Load local polling address\n\t&quot;);</span>




 1228     st-&gt;print(&quot;LDX    [L0],G0\t!Poll for Safepointing\n\t&quot;);
 1229   }
 1230 
 1231   if(do_polling()) {
 1232     if (UseCBCond &amp;&amp; !ra_-&gt;C-&gt;is_method_compilation()) {
 1233       st-&gt;print(&quot;NOP\n\t&quot;);
 1234     }
 1235     st-&gt;print(&quot;RET\n\t&quot;);
 1236   }
 1237 
 1238   st-&gt;print(&quot;RESTORE&quot;);
 1239 }
 1240 #endif
 1241 
 1242 void MachEpilogNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<a name="23" id="anc23"></a><span class="line-modified"> 1243   C2_MacroAssembler _masm(&amp;cbuf);</span>
 1244   Compile* C = ra_-&gt;C;
 1245 
 1246   __ verify_thread();
 1247 
 1248   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
 1249     __ reserved_stack_check();
 1250   }
 1251 
 1252   // If this does safepoint polling, then do it here
 1253   if(do_polling() &amp;&amp; ra_-&gt;C-&gt;is_method_compilation()) {
<a name="24" id="anc24"></a><span class="line-modified"> 1254     __ ld_ptr(Address(G2_thread, Thread::polling_page_offset()), L0);</span>





 1255     __ relocate(relocInfo::poll_return_type);
 1256     __ ld_ptr(L0, 0, G0);
 1257   }
 1258 
 1259   // If this is a return, then stuff the restore in the delay slot
 1260   if(do_polling()) {
 1261     if (UseCBCond &amp;&amp; !ra_-&gt;C-&gt;is_method_compilation()) {
 1262       // Insert extra padding for the case when the epilogue is preceded by
 1263       // a cbcond jump, which can&#39;t be followed by a CTI instruction
 1264       __ nop();
 1265     }
 1266     __ ret();
 1267     __ delayed()-&gt;restore();
 1268   } else {
 1269     __ restore();
 1270   }
 1271 }
 1272 
 1273 uint MachEpilogNode::size(PhaseRegAlloc *ra_) const {
 1274   return MachNode::size(ra_);
 1275 }
 1276 
 1277 int MachEpilogNode::reloc() const {
 1278   return 16; // a large enough number
 1279 }
 1280 
 1281 const Pipeline * MachEpilogNode::pipeline() const {
 1282   return MachNode::pipeline_class();
 1283 }
 1284 
<a name="25" id="anc25"></a>





 1285 //=============================================================================
 1286 
 1287 // Figure out which register class each belongs in: rc_int, rc_float, rc_stack
 1288 enum RC { rc_bad, rc_int, rc_float, rc_stack };
 1289 static enum RC rc_class( OptoReg::Name reg ) {
 1290   if (!OptoReg::is_valid(reg)) return rc_bad;
 1291   if (OptoReg::is_stack(reg)) return rc_stack;
 1292   VMReg r = OptoReg::as_VMReg(reg);
 1293   if (r-&gt;is_Register()) return rc_int;
 1294   assert(r-&gt;is_FloatRegister(), &quot;must be&quot;);
 1295   return rc_float;
 1296 }
 1297 
 1298 #ifndef PRODUCT
 1299 ATTRIBUTE_PRINTF(2, 3)
 1300 static void print_helper(outputStream* st, const char* format, ...) {
 1301   const int tab_size = 8;
 1302   if (st-&gt;position() &gt; tab_size) {
 1303     st-&gt;cr();
 1304     st-&gt;sp();
 1305   }
 1306   va_list ap;
 1307   va_start(ap, format);
 1308   st-&gt;vprint(format, ap);
 1309   va_end(ap);
 1310 }
 1311 #endif // !PRODUCT
 1312 
 1313 static void impl_helper(const MachNode* mach, CodeBuffer* cbuf, PhaseRegAlloc* ra, bool is_load, int offset, int reg, int opcode, const char *op_str, outputStream* st) {
 1314   if (cbuf) {
 1315     emit_form3_mem_reg(*cbuf, ra, mach, opcode, -1, R_SP_enc, offset, 0, Matcher::_regEncode[reg]);
 1316   }
 1317 #ifndef PRODUCT
 1318   else {
 1319     if (is_load) {
 1320       print_helper(st, &quot;%s   [R_SP + #%d],R_%s\t! spill&quot;, op_str, offset, OptoReg::regname(reg));
 1321     } else {
 1322       print_helper(st, &quot;%s   R_%s,[R_SP + #%d]\t! spill&quot;, op_str, OptoReg::regname(reg), offset);
 1323     }
 1324   }
 1325 #endif
 1326 }
 1327 
 1328 static void impl_mov_helper(CodeBuffer *cbuf, int src, int dst, int op1, int op2, const char *op_str, outputStream* st) {
 1329   if (cbuf) {
 1330     emit3(*cbuf, Assembler::arith_op, Matcher::_regEncode[dst], op1, 0, op2, Matcher::_regEncode[src]);
 1331   }
 1332 #ifndef PRODUCT
 1333   else {
 1334     print_helper(st, &quot;%s  R_%s,R_%s\t! spill&quot;, op_str, OptoReg::regname(src), OptoReg::regname(dst));
 1335   }
 1336 #endif
 1337 }
 1338 
 1339 static void mach_spill_copy_implementation_helper(const MachNode* mach,
 1340                                                   CodeBuffer *cbuf,
 1341                                                   PhaseRegAlloc *ra_,
 1342                                                   outputStream* st) {
 1343   // Get registers to move
 1344   OptoReg::Name src_second = ra_-&gt;get_reg_second(mach-&gt;in(1));
 1345   OptoReg::Name src_first  = ra_-&gt;get_reg_first(mach-&gt;in(1));
 1346   OptoReg::Name dst_second = ra_-&gt;get_reg_second(mach);
 1347   OptoReg::Name dst_first  = ra_-&gt;get_reg_first(mach);
 1348 
 1349   enum RC src_second_rc = rc_class(src_second);
 1350   enum RC src_first_rc  = rc_class(src_first);
 1351   enum RC dst_second_rc = rc_class(dst_second);
 1352   enum RC dst_first_rc  = rc_class(dst_first);
 1353 
 1354   assert(OptoReg::is_valid(src_first) &amp;&amp; OptoReg::is_valid(dst_first), &quot;must move at least 1 register&quot;);
 1355 
 1356   if (src_first == dst_first &amp;&amp; src_second == dst_second) {
 1357     return; // Self copy, no move
 1358   }
 1359 
 1360   // --------------------------------------
 1361   // Check for mem-mem move.  Load into unused float registers and fall into
 1362   // the float-store case.
 1363   if (src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_stack) {
 1364     int offset = ra_-&gt;reg2offset(src_first);
 1365     // Further check for aligned-adjacent pair, so we can use a double load
 1366     if ((src_first&amp;1) == 0 &amp;&amp; src_first+1 == src_second) {
 1367       src_second    = OptoReg::Name(R_F31_num);
 1368       src_second_rc = rc_float;
 1369       impl_helper(mach, cbuf, ra_, true, offset, R_F30_num, Assembler::lddf_op3, &quot;LDDF&quot;, st);
 1370     } else {
 1371       impl_helper(mach, cbuf, ra_, true, offset, R_F30_num, Assembler::ldf_op3, &quot;LDF &quot;, st);
 1372     }
 1373     src_first    = OptoReg::Name(R_F30_num);
 1374     src_first_rc = rc_float;
 1375   }
 1376 
 1377   if( src_second_rc == rc_stack &amp;&amp; dst_second_rc == rc_stack ) {
 1378     int offset = ra_-&gt;reg2offset(src_second);
 1379     impl_helper(mach, cbuf, ra_, true, offset, R_F31_num, Assembler::ldf_op3, &quot;LDF &quot;, st);
 1380     src_second    = OptoReg::Name(R_F31_num);
 1381     src_second_rc = rc_float;
 1382   }
 1383 
 1384   // --------------------------------------
 1385   // Check for float-&gt;int copy; requires a trip through memory
 1386   if (src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_int &amp;&amp; UseVIS &lt; 3) {
 1387     int offset = frame::register_save_words*wordSize;
 1388     if (cbuf) {
 1389       emit3_simm13(*cbuf, Assembler::arith_op, R_SP_enc, Assembler::sub_op3, R_SP_enc, 16);
 1390       impl_helper(mach, cbuf, ra_, false, offset, src_first,  Assembler::stf_op3, &quot;STF &quot;, st);
 1391       impl_helper(mach, cbuf, ra_,  true, offset, dst_first, Assembler::lduw_op3, &quot;LDUW&quot;, st);
 1392       emit3_simm13(*cbuf, Assembler::arith_op, R_SP_enc, Assembler::add_op3, R_SP_enc, 16);
 1393     }
 1394 #ifndef PRODUCT
 1395     else {
 1396       print_helper(st, &quot;SUB    R_SP,16,R_SP&quot;);
 1397       impl_helper(mach, cbuf, ra_, false, offset, src_first,  Assembler::stf_op3, &quot;STF &quot;, st);
 1398       impl_helper(mach, cbuf, ra_,  true, offset, dst_first, Assembler::lduw_op3, &quot;LDUW&quot;, st);
 1399       print_helper(st, &quot;ADD    R_SP,16,R_SP&quot;);
 1400     }
 1401 #endif
 1402   }
 1403 
 1404   // Check for float-&gt;int copy on T4
 1405   if (src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_int &amp;&amp; UseVIS &gt;= 3) {
 1406     // Further check for aligned-adjacent pair, so we can use a double move
 1407     if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp; (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1408       impl_mov_helper(cbuf, src_first, dst_first, Assembler::mftoi_op3, Assembler::mdtox_opf, &quot;MOVDTOX&quot;, st);
 1409       return;
 1410     }
 1411     impl_mov_helper(cbuf, src_first, dst_first, Assembler::mftoi_op3, Assembler::mstouw_opf, &quot;MOVSTOUW&quot;, st);
 1412   }
 1413   // Check for int-&gt;float copy on T4
 1414   if (src_first_rc == rc_int &amp;&amp; dst_first_rc == rc_float &amp;&amp; UseVIS &gt;= 3) {
 1415     // Further check for aligned-adjacent pair, so we can use a double move
 1416     if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp; (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1417       impl_mov_helper(cbuf, src_first, dst_first, Assembler::mftoi_op3, Assembler::mxtod_opf, &quot;MOVXTOD&quot;, st);
 1418       return;
 1419     }
 1420     impl_mov_helper(cbuf, src_first, dst_first, Assembler::mftoi_op3, Assembler::mwtos_opf, &quot;MOVWTOS&quot;, st);
 1421   }
 1422 
 1423   // --------------------------------------
 1424   // In the 32-bit 1-reg-longs build ONLY, I see mis-aligned long destinations.
 1425   // In such cases, I have to do the big-endian swap.  For aligned targets, the
 1426   // hardware does the flop for me.  Doubles are always aligned, so no problem
 1427   // there.  Misaligned sources only come from native-long-returns (handled
 1428   // special below).
 1429 
 1430   // --------------------------------------
 1431   // Check for integer reg-reg copy
 1432   if (src_first_rc == rc_int &amp;&amp; dst_first_rc == rc_int) {
 1433     // Else normal reg-reg copy
 1434     assert(src_second != dst_first, &quot;smashed second before evacuating it&quot;);
 1435     impl_mov_helper(cbuf, src_first, dst_first, Assembler::or_op3, 0, &quot;MOV  &quot;, st);
 1436     assert((src_first &amp; 1) == 0 &amp;&amp; (dst_first &amp; 1) == 0, &quot;never move second-halves of int registers&quot;);
 1437     // This moves an aligned adjacent pair.
 1438     // See if we are done.
 1439     if (src_first + 1 == src_second &amp;&amp; dst_first + 1 == dst_second) {
 1440       return;
 1441     }
 1442   }
 1443 
 1444   // Check for integer store
 1445   if (src_first_rc == rc_int &amp;&amp; dst_first_rc == rc_stack) {
 1446     int offset = ra_-&gt;reg2offset(dst_first);
 1447     // Further check for aligned-adjacent pair, so we can use a double store
 1448     if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp; (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1449       impl_helper(mach, cbuf, ra_, false, offset, src_first, Assembler::stx_op3, &quot;STX &quot;, st);
 1450       return;
 1451     }
 1452     impl_helper(mach, cbuf, ra_, false, offset, src_first, Assembler::stw_op3, &quot;STW &quot;, st);
 1453   }
 1454 
 1455   // Check for integer load
 1456   if (dst_first_rc == rc_int &amp;&amp; src_first_rc == rc_stack) {
 1457     int offset = ra_-&gt;reg2offset(src_first);
 1458     // Further check for aligned-adjacent pair, so we can use a double load
 1459     if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp; (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1460       impl_helper(mach, cbuf, ra_, true, offset, dst_first, Assembler::ldx_op3, &quot;LDX &quot;, st);
 1461       return;
 1462     }
 1463     impl_helper(mach, cbuf, ra_, true, offset, dst_first, Assembler::lduw_op3, &quot;LDUW&quot;, st);
 1464   }
 1465 
 1466   // Check for float reg-reg copy
 1467   if (src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_float) {
 1468     // Further check for aligned-adjacent pair, so we can use a double move
 1469     if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp; (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1470       impl_mov_helper(cbuf, src_first, dst_first, Assembler::fpop1_op3, Assembler::fmovd_opf, &quot;FMOVD&quot;, st);
 1471       return;
 1472     }
 1473     impl_mov_helper(cbuf, src_first, dst_first, Assembler::fpop1_op3, Assembler::fmovs_opf, &quot;FMOVS&quot;, st);
 1474   }
 1475 
 1476   // Check for float store
 1477   if (src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_stack) {
 1478     int offset = ra_-&gt;reg2offset(dst_first);
 1479     // Further check for aligned-adjacent pair, so we can use a double store
 1480     if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp; (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1481       impl_helper(mach, cbuf, ra_, false, offset, src_first, Assembler::stdf_op3, &quot;STDF&quot;, st);
 1482       return;
 1483     }
 1484     impl_helper(mach, cbuf, ra_, false, offset, src_first, Assembler::stf_op3, &quot;STF &quot;, st);
 1485   }
 1486 
 1487   // Check for float load
 1488   if (dst_first_rc == rc_float &amp;&amp; src_first_rc == rc_stack) {
 1489     int offset = ra_-&gt;reg2offset(src_first);
 1490     // Further check for aligned-adjacent pair, so we can use a double load
 1491     if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp; (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1492       impl_helper(mach, cbuf, ra_, true, offset, dst_first, Assembler::lddf_op3, &quot;LDDF&quot;, st);
 1493       return;
 1494     }
 1495     impl_helper(mach, cbuf, ra_, true, offset, dst_first, Assembler::ldf_op3, &quot;LDF &quot;, st);
 1496   }
 1497 
 1498   // --------------------------------------------------------------------
 1499   // Check for hi bits still needing moving.  Only happens for misaligned
 1500   // arguments to native calls.
 1501   if (src_second == dst_second) {
 1502     return; // Self copy; no move
 1503   }
 1504   assert(src_second_rc != rc_bad &amp;&amp; dst_second_rc != rc_bad, &quot;src_second &amp; dst_second cannot be Bad&quot;);
 1505 
 1506   Unimplemented();
 1507 }
 1508 
 1509 uint MachSpillCopyNode::implementation(CodeBuffer *cbuf,
 1510                                        PhaseRegAlloc *ra_,
 1511                                        bool do_size,
 1512                                        outputStream* st) const {
 1513   assert(!do_size, &quot;not supported&quot;);
 1514   mach_spill_copy_implementation_helper(this, cbuf, ra_, st);
 1515   return 0;
 1516 }
 1517 
 1518 #ifndef PRODUCT
 1519 void MachSpillCopyNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
 1520   implementation( NULL, ra_, false, st );
 1521 }
 1522 #endif
 1523 
 1524 void MachSpillCopyNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1525   implementation( &amp;cbuf, ra_, false, NULL );
 1526 }
 1527 
 1528 uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
 1529   return MachNode::size(ra_);
 1530 }
 1531 
 1532 //=============================================================================
 1533 #ifndef PRODUCT
 1534 void MachNopNode::format(PhaseRegAlloc *, outputStream *st) const {
 1535   st-&gt;print(&quot;NOP \t# %d bytes pad for loops and calls&quot;, 4 * _count);
 1536 }
 1537 #endif
 1538 
 1539 void MachNopNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *) const {
<a name="26" id="anc26"></a><span class="line-modified"> 1540   C2_MacroAssembler _masm(&amp;cbuf);</span>
 1541   for (int i = 0; i &lt; _count; i += 1) {
 1542     __ nop();
 1543   }
 1544 }
 1545 
 1546 uint MachNopNode::size(PhaseRegAlloc *ra_) const {
 1547   return 4 * _count;
 1548 }
 1549 
 1550 
 1551 //=============================================================================
 1552 #ifndef PRODUCT
 1553 void BoxLockNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
 1554   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1555   int reg = ra_-&gt;get_reg_first(this);
 1556   st-&gt;print(&quot;LEA    [R_SP+#%d+BIAS],%s&quot;,offset,Matcher::regName[reg]);
 1557 }
 1558 #endif
 1559 
 1560 void BoxLockNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<a name="27" id="anc27"></a><span class="line-modified"> 1561   C2_MacroAssembler _masm(&amp;cbuf);</span>
 1562   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem()) + STACK_BIAS;
 1563   int reg = ra_-&gt;get_encode(this);
 1564 
 1565   if (Assembler::is_simm13(offset)) {
 1566      __ add(SP, offset, reg_to_register_object(reg));
 1567   } else {
 1568      __ set(offset, O7);
 1569      __ add(SP, O7, reg_to_register_object(reg));
 1570   }
 1571 }
 1572 
 1573 uint BoxLockNode::size(PhaseRegAlloc *ra_) const {
 1574   // BoxLockNode is not a MachNode, so we can&#39;t just call MachNode::size(ra_)
 1575   assert(ra_ == ra_-&gt;C-&gt;regalloc(), &quot;sanity&quot;);
<a name="28" id="anc28"></a><span class="line-modified"> 1576   return ra_-&gt;C-&gt;output()-&gt;scratch_emit_size(this);</span>
 1577 }
 1578 
 1579 //=============================================================================
 1580 #ifndef PRODUCT
 1581 void MachUEPNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
 1582   st-&gt;print_cr(&quot;\nUEP:&quot;);
 1583   if (UseCompressedClassPointers) {
 1584     assert(Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
 1585     st-&gt;print_cr(&quot;\tLDUW   [R_O0 + oopDesc::klass_offset_in_bytes],R_G5\t! Inline cache check - compressed klass&quot;);
 1586     if (CompressedKlassPointers::base() != 0) {
 1587       st-&gt;print_cr(&quot;\tSET    CompressedKlassPointers::base,R_G6_heap_base&quot;);
 1588       if (CompressedKlassPointers::shift() != 0) {
 1589         st-&gt;print_cr(&quot;\tSLL    R_G5,CompressedKlassPointers::shift,R_G5&quot;);
 1590       }
 1591       st-&gt;print_cr(&quot;\tADD    R_G5,R_G6_heap_base,R_G5&quot;);
 1592       st-&gt;print_cr(&quot;\tSET    CompressedOops::ptrs_base,R_G6_heap_base&quot;);
 1593     } else {
 1594       st-&gt;print_cr(&quot;\tSLL    R_G5,CompressedKlassPointers::shift,R_G5&quot;);
 1595     }
 1596   } else {
 1597     st-&gt;print_cr(&quot;\tLDX    [R_O0 + oopDesc::klass_offset_in_bytes],R_G5\t! Inline cache check&quot;);
 1598   }
 1599   st-&gt;print_cr(&quot;\tCMP    R_G5,R_G3&quot; );
 1600   st-&gt;print   (&quot;\tTne    xcc,R_G0+ST_RESERVED_FOR_USER_0+2&quot;);
 1601 }
 1602 #endif
 1603 
 1604 void MachUEPNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<a name="29" id="anc29"></a><span class="line-modified"> 1605   C2_MacroAssembler _masm(&amp;cbuf);</span>
 1606   Register G5_ic_reg  = reg_to_register_object(Matcher::inline_cache_reg_encode());
 1607   Register temp_reg   = G3;
 1608   assert( G5_ic_reg != temp_reg, &quot;conflicting registers&quot; );
 1609 
 1610   // Load klass from receiver
 1611   __ load_klass(O0, temp_reg);
 1612   // Compare against expected klass
 1613   __ cmp(temp_reg, G5_ic_reg);
 1614   // Branch to miss code, checks xcc or icc depending
 1615   __ trap(Assembler::notEqual, Assembler::ptr_cc, G0, ST_RESERVED_FOR_USER_0+2);
 1616 }
 1617 
 1618 uint MachUEPNode::size(PhaseRegAlloc *ra_) const {
 1619   return MachNode::size(ra_);
 1620 }
 1621 
 1622 
 1623 //=============================================================================
 1624 
 1625 
 1626 // Emit exception handler code.
 1627 int HandlerImpl::emit_exception_handler(CodeBuffer&amp; cbuf) {
 1628   Register temp_reg = G3;
 1629   AddressLiteral exception_blob(OptoRuntime::exception_blob()-&gt;entry_point());
<a name="30" id="anc30"></a><span class="line-modified"> 1630   C2_MacroAssembler _masm(&amp;cbuf);</span>
 1631 
 1632   address base = __ start_a_stub(size_exception_handler());
 1633   if (base == NULL) {
 1634     ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 1635     return 0;  // CodeBuffer::expand failed
 1636   }
 1637 
 1638   int offset = __ offset();
 1639 
 1640   __ JUMP(exception_blob, temp_reg, 0); // sethi;jmp
 1641   __ delayed()-&gt;nop();
 1642 
 1643   assert(__ offset() - offset &lt;= (int) size_exception_handler(), &quot;overflow&quot;);
 1644 
 1645   __ end_a_stub();
 1646 
 1647   return offset;
 1648 }
 1649 
 1650 int HandlerImpl::emit_deopt_handler(CodeBuffer&amp; cbuf) {
 1651   // Can&#39;t use any of the current frame&#39;s registers as we may have deopted
 1652   // at a poll and everything (including G3) can be live.
 1653   Register temp_reg = L0;
 1654   AddressLiteral deopt_blob(SharedRuntime::deopt_blob()-&gt;unpack());
<a name="31" id="anc31"></a><span class="line-modified"> 1655   C2_MacroAssembler _masm(&amp;cbuf);</span>
 1656 
 1657   address base = __ start_a_stub(size_deopt_handler());
 1658   if (base == NULL) {
 1659     ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 1660     return 0;  // CodeBuffer::expand failed
 1661   }
 1662 
 1663   int offset = __ offset();
 1664   __ save_frame(0);
 1665   __ JUMP(deopt_blob, temp_reg, 0); // sethi;jmp
 1666   __ delayed()-&gt;restore();
 1667 
 1668   assert(__ offset() - offset &lt;= (int) size_deopt_handler(), &quot;overflow&quot;);
 1669 
 1670   __ end_a_stub();
 1671   return offset;
 1672 
 1673 }
 1674 
 1675 // Given a register encoding, produce a Integer Register object
 1676 static Register reg_to_register_object(int register_encoding) {
 1677   assert(L5-&gt;encoding() == R_L5_enc &amp;&amp; G1-&gt;encoding() == R_G1_enc, &quot;right coding&quot;);
 1678   return as_Register(register_encoding);
 1679 }
 1680 
 1681 // Given a register encoding, produce a single-precision Float Register object
 1682 static FloatRegister reg_to_SingleFloatRegister_object(int register_encoding) {
 1683   assert(F5-&gt;encoding(FloatRegisterImpl::S) == R_F5_enc &amp;&amp; F12-&gt;encoding(FloatRegisterImpl::S) == R_F12_enc, &quot;right coding&quot;);
 1684   return as_SingleFloatRegister(register_encoding);
 1685 }
 1686 
 1687 // Given a register encoding, produce a double-precision Float Register object
 1688 static FloatRegister reg_to_DoubleFloatRegister_object(int register_encoding) {
 1689   assert(F4-&gt;encoding(FloatRegisterImpl::D) == R_F4_enc, &quot;right coding&quot;);
 1690   assert(F32-&gt;encoding(FloatRegisterImpl::D) == R_D32_enc, &quot;right coding&quot;);
 1691   return as_DoubleFloatRegister(register_encoding);
 1692 }
 1693 
 1694 const bool Matcher::match_rule_supported(int opcode) {
 1695   if (!has_match_rule(opcode))
 1696     return false;
 1697 
 1698   switch (opcode) {
 1699   case Op_CountLeadingZerosI:
 1700   case Op_CountLeadingZerosL:
 1701   case Op_CountTrailingZerosI:
 1702   case Op_CountTrailingZerosL:
 1703   case Op_PopCountI:
 1704   case Op_PopCountL:
 1705     if (!UsePopCountInstruction)
 1706       return false;
 1707   case Op_CompareAndSwapL:
 1708   case Op_CompareAndSwapP:
 1709     if (!VM_Version::supports_cx8())
 1710       return false;
 1711     break;
 1712   }
 1713 
 1714   return true;  // Per default match rules are supported.
 1715 }
 1716 
 1717 const bool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType bt) {
 1718 
 1719   // TODO
 1720   // identify extra cases that we might want to provide match rules for
 1721   // e.g. Op_ vector nodes and other intrinsics while guarding with vlen
 1722   bool ret_value = match_rule_supported(opcode);
 1723   // Add rules here.
 1724 
 1725   return ret_value;  // Per default match rules are supported.
 1726 }
 1727 
 1728 const bool Matcher::has_predicated_vectors(void) {
 1729   return false;
 1730 }
 1731 
 1732 const int Matcher::float_pressure(int default_pressure_threshold) {
 1733   return default_pressure_threshold;
 1734 }
 1735 
 1736 int Matcher::regnum_to_fpu_offset(int regnum) {
 1737   return regnum - 32; // The FP registers are in the second chunk
 1738 }
 1739 
 1740 #ifdef ASSERT
 1741 address last_rethrow = NULL;  // debugging aid for Rethrow encoding
 1742 #endif
 1743 
 1744 // Vector width in bytes
 1745 const int Matcher::vector_width_in_bytes(BasicType bt) {
 1746   assert(MaxVectorSize == 8, &quot;&quot;);
 1747   return 8;
 1748 }
 1749 
 1750 // Vector ideal reg
 1751 const uint Matcher::vector_ideal_reg(int size) {
 1752   assert(MaxVectorSize == 8, &quot;&quot;);
 1753   return Op_RegD;
 1754 }
 1755 
 1756 const uint Matcher::vector_shift_count_ideal_reg(int size) {
 1757   fatal(&quot;vector shift is not supported&quot;);
 1758   return Node::NotAMachineReg;
 1759 }
 1760 
 1761 // Limits on vector size (number of elements) loaded into vector.
 1762 const int Matcher::max_vector_size(const BasicType bt) {
 1763   assert(is_java_primitive(bt), &quot;only primitive type vectors&quot;);
 1764   return vector_width_in_bytes(bt)/type2aelembytes(bt);
 1765 }
 1766 
 1767 const int Matcher::min_vector_size(const BasicType bt) {
 1768   return max_vector_size(bt); // Same as max.
 1769 }
 1770 
 1771 // SPARC doesn&#39;t support misaligned vectors store/load.
 1772 const bool Matcher::misaligned_vectors_ok() {
 1773   return false;
 1774 }
 1775 
 1776 // Current (2013) SPARC platforms need to read original key
 1777 // to construct decryption expanded key
 1778 const bool Matcher::pass_original_key_for_aes() {
 1779   return true;
 1780 }
 1781 
 1782 // NOTE: All currently supported SPARC HW provides fast conversion.
 1783 const bool Matcher::convL2FSupported(void) { return true; }
 1784 
 1785 // Is this branch offset short enough that a short branch can be used?
 1786 //
 1787 // NOTE: If the platform does not provide any short branch variants, then
 1788 //       this method should return false for offset 0.
 1789 bool Matcher::is_short_branch_offset(int rule, int br_size, int offset) {
 1790   // The passed offset is relative to address of the branch.
 1791   // Don&#39;t need to adjust the offset.
 1792   return UseCBCond &amp;&amp; Assembler::is_simm12(offset);
 1793 }
 1794 
 1795 const bool Matcher::isSimpleConstant64(jlong value) {
 1796   // Will one (StoreL ConL) be cheaper than two (StoreI ConI)?.
 1797   // Depends on optimizations in MacroAssembler::setx.
 1798   int hi = (int)(value &gt;&gt; 32);
 1799   int lo = (int)(value &amp; ~0);
 1800   return (hi == 0) || (hi == -1) || (lo == 0);
 1801 }
 1802 
 1803 // No scaling for the parameter the ClearArray node.
 1804 const bool Matcher::init_array_count_is_in_bytes = true;
 1805 
 1806 // No additional cost for CMOVL.
 1807 const int Matcher::long_cmove_cost() { return 0; }
 1808 
 1809 // CMOVF/CMOVD are expensive on e.g., T4 and SPARC64.
 1810 const int Matcher::float_cmove_cost() {
 1811   return VM_Version::has_fast_cmove() ? 0 : ConditionalMoveLimit;
 1812 }
 1813 
 1814 // Does the CPU require late expand (see block.cpp for description of late expand)?
 1815 const bool Matcher::require_postalloc_expand = false;
 1816 
 1817 // Do we need to mask the count passed to shift instructions or does
 1818 // the cpu only look at the lower 5/6 bits anyway?
 1819 const bool Matcher::need_masked_shift_count = false;
 1820 
 1821 // No support for generic vector operands.
 1822 const bool Matcher::supports_generic_vector_operands  = false;
 1823 
 1824 MachOper* Matcher::specialize_generic_vector_operand(MachOper* original_opnd, uint ideal_reg, bool is_temp) {
 1825   ShouldNotReachHere(); // generic vector operands not supported
 1826   return NULL;
 1827 }
 1828 
 1829 bool Matcher::is_generic_reg2reg_move(MachNode* m) {
 1830   ShouldNotReachHere();  // generic vector operands not supported
 1831   return false;
 1832 }
 1833 
 1834 bool Matcher::is_generic_vector(MachOper* opnd)  {
 1835   ShouldNotReachHere();  // generic vector operands not supported
 1836   return false;
 1837 }
 1838 
 1839 bool Matcher::narrow_oop_use_complex_address() {
 1840   assert(UseCompressedOops, &quot;only for compressed oops code&quot;);
 1841   return false;
 1842 }
 1843 
 1844 bool Matcher::narrow_klass_use_complex_address() {
 1845   assert(UseCompressedClassPointers, &quot;only for compressed klass code&quot;);
 1846   return false;
 1847 }
 1848 
 1849 bool Matcher::const_oop_prefer_decode() {
 1850   // TODO: Check if loading ConP from TOC in heap-based mode is better:
 1851   // Prefer ConN+DecodeN over ConP in simple compressed oops mode.
 1852   // return CompressedOops::base() == NULL;
 1853   return true;
 1854 }
 1855 
 1856 bool Matcher::const_klass_prefer_decode() {
 1857   // TODO: Check if loading ConP from TOC in heap-based mode is better:
 1858   // Prefer ConNKlass+DecodeNKlass over ConP in simple compressed klass mode.
 1859   // return CompressedKlassPointers::base() == NULL;
 1860   return true;
 1861 }
 1862 
 1863 // Is it better to copy float constants, or load them directly from memory?
 1864 // Intel can load a float constant from a direct address, requiring no
 1865 // extra registers.  Most RISCs will have to materialize an address into a
 1866 // register first, so they would do better to copy the constant from stack.
 1867 const bool Matcher::rematerialize_float_constants = false;
 1868 
 1869 // If CPU can load and store mis-aligned doubles directly then no fixup is
 1870 // needed.  Else we split the double into 2 integer pieces and move it
 1871 // piece-by-piece.  Only happens when passing doubles into C code as the
 1872 // Java calling convention forces doubles to be aligned.
 1873 const bool Matcher::misaligned_doubles_ok = true;
 1874 
 1875 // No-op on SPARC.
 1876 void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {
 1877 }
 1878 
 1879 // Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.
 1880 const bool Matcher::strict_fp_requires_explicit_rounding = false;
 1881 
 1882 // Are floats converted to double when stored to stack during deoptimization?
 1883 // Sparc does not handle callee-save floats.
 1884 bool Matcher::float_in_double() { return false; }
 1885 
 1886 // Do ints take an entire long register or just half?
 1887 // Note that we if-def off of _LP64.
 1888 // The relevant question is how the int is callee-saved.  In _LP64
 1889 // the whole long is written but de-opt&#39;ing will have to extract
 1890 // the relevant 32 bits, in not-_LP64 only the low 32 bits is written.
 1891 const bool Matcher::int_in_long = true;
 1892 
 1893 // Return whether or not this register is ever used as an argument.  This
 1894 // function is used on startup to build the trampoline stubs in generateOptoStub.
 1895 // Registers not mentioned will be killed by the VM call in the trampoline, and
 1896 // arguments in those registers not be available to the callee.
 1897 bool Matcher::can_be_java_arg( int reg ) {
 1898   // Standard sparc 6 args in registers
 1899   if( reg == R_I0_num ||
 1900       reg == R_I1_num ||
 1901       reg == R_I2_num ||
 1902       reg == R_I3_num ||
 1903       reg == R_I4_num ||
 1904       reg == R_I5_num ) return true;
 1905   // 64-bit builds can pass 64-bit pointers and longs in
 1906   // the high I registers
 1907   if( reg == R_I0H_num ||
 1908       reg == R_I1H_num ||
 1909       reg == R_I2H_num ||
 1910       reg == R_I3H_num ||
 1911       reg == R_I4H_num ||
 1912       reg == R_I5H_num ) return true;
 1913 
 1914   if ((UseCompressedOops) &amp;&amp; (reg == R_G6_num || reg == R_G6H_num)) {
 1915     return true;
 1916   }
 1917 
 1918   // A few float args in registers
 1919   if( reg &gt;= R_F0_num &amp;&amp; reg &lt;= R_F7_num ) return true;
 1920 
 1921   return false;
 1922 }
 1923 
 1924 bool Matcher::is_spillable_arg( int reg ) {
 1925   return can_be_java_arg(reg);
 1926 }
 1927 
 1928 bool Matcher::use_asm_for_ldiv_by_con( jlong divisor ) {
 1929   // Use hardware SDIVX instruction when it is
 1930   // faster than a code which use multiply.
 1931   return VM_Version::has_fast_idiv();
 1932 }
 1933 
 1934 // Register for DIVI projection of divmodI
 1935 RegMask Matcher::divI_proj_mask() {
 1936   ShouldNotReachHere();
 1937   return RegMask();
 1938 }
 1939 
 1940 // Register for MODI projection of divmodI
 1941 RegMask Matcher::modI_proj_mask() {
 1942   ShouldNotReachHere();
 1943   return RegMask();
 1944 }
 1945 
 1946 // Register for DIVL projection of divmodL
 1947 RegMask Matcher::divL_proj_mask() {
 1948   ShouldNotReachHere();
 1949   return RegMask();
 1950 }
 1951 
 1952 // Register for MODL projection of divmodL
 1953 RegMask Matcher::modL_proj_mask() {
 1954   ShouldNotReachHere();
 1955   return RegMask();
 1956 }
 1957 
 1958 const RegMask Matcher::method_handle_invoke_SP_save_mask() {
 1959   return L7_REGP_mask();
 1960 }
 1961 
 1962 
 1963 const bool Matcher::convi2l_type_required = true;
 1964 
<a name="32" id="anc32"></a><span class="line-added"> 1965 // Should the matcher clone input &#39;m&#39; of node &#39;n&#39;?</span>
<span class="line-added"> 1966 bool Matcher::pd_clone_node(Node* n, Node* m, Matcher::MStack&amp; mstack) {</span>
<span class="line-added"> 1967   return false;</span>
<span class="line-added"> 1968 }</span>
<span class="line-added"> 1969 </span>
 1970 // Should the Matcher clone shifts on addressing modes, expecting them
 1971 // to be subsumed into complex addressing expressions or compute them
 1972 // into registers?
<a name="33" id="anc33"></a><span class="line-modified"> 1973 bool Matcher::pd_clone_address_expressions(AddPNode* m, Matcher::MStack&amp; mstack, VectorSet&amp; address_visited) {</span>
 1974   return clone_base_plus_offset_address(m, mstack, address_visited);
 1975 }
 1976 
 1977 void Compile::reshape_address(AddPNode* addp) {
 1978 }
 1979 
 1980 %}
 1981 
 1982 
 1983 // The intptr_t operand types, defined by textual substitution.
 1984 // (Cf. opto/type.hpp.  This lets us avoid many, many other ifdefs.)
 1985 #define immX      immL
 1986 #define immX13    immL13
 1987 #define immX13m7  immL13m7
 1988 #define iRegX     iRegL
 1989 #define g1RegX    g1RegL
 1990 
 1991 //----------ENCODING BLOCK-----------------------------------------------------
 1992 // This block specifies the encoding classes used by the compiler to output
 1993 // byte streams.  Encoding classes are parameterized macros used by
 1994 // Machine Instruction Nodes in order to generate the bit encoding of the
 1995 // instruction.  Operands specify their base encoding interface with the
 1996 // interface keyword.  There are currently supported four interfaces,
 1997 // REG_INTER, CONST_INTER, MEMORY_INTER, &amp; COND_INTER.  REG_INTER causes an
 1998 // operand to generate a function which returns its register number when
 1999 // queried.   CONST_INTER causes an operand to generate a function which
 2000 // returns the value of the constant when queried.  MEMORY_INTER causes an
 2001 // operand to generate four functions which return the Base Register, the
 2002 // Index Register, the Scale Value, and the Offset Value of the operand when
 2003 // queried.  COND_INTER causes an operand to generate six functions which
 2004 // return the encoding code (ie - encoding bits for the instruction)
 2005 // associated with each basic boolean condition for a conditional instruction.
 2006 //
 2007 // Instructions specify two basic values for encoding.  Again, a function
 2008 // is available to check if the constant displacement is an oop. They use the
 2009 // ins_encode keyword to specify their encoding classes (which must be
 2010 // a sequence of enc_class names, and their parameters, specified in
 2011 // the encoding block), and they use the
 2012 // opcode keyword to specify, in order, their primary, secondary, and
 2013 // tertiary opcode.  Only the opcode sections which a particular instruction
 2014 // needs for encoding need to be specified.
 2015 encode %{
 2016   enc_class enc_untested %{
 2017 #ifdef ASSERT
<a name="34" id="anc34"></a><span class="line-modified"> 2018     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2019     __ untested(&quot;encoding&quot;);
 2020 #endif
 2021   %}
 2022 
 2023   enc_class form3_mem_reg( memory mem, iRegI dst ) %{
 2024     emit_form3_mem_reg(cbuf, ra_, this, $primary, $tertiary,
 2025                        $mem$$base, $mem$$disp, $mem$$index, $dst$$reg);
 2026   %}
 2027 
 2028   enc_class simple_form3_mem_reg( memory mem, iRegI dst ) %{
 2029     emit_form3_mem_reg(cbuf, ra_, this, $primary, -1,
 2030                        $mem$$base, $mem$$disp, $mem$$index, $dst$$reg);
 2031   %}
 2032 
 2033   enc_class form3_mem_prefetch_read( memory mem ) %{
 2034     emit_form3_mem_reg(cbuf, ra_, this, $primary, -1,
 2035                        $mem$$base, $mem$$disp, $mem$$index, 0/*prefetch function many-reads*/);
 2036   %}
 2037 
 2038   enc_class form3_mem_prefetch_write( memory mem ) %{
 2039     emit_form3_mem_reg(cbuf, ra_, this, $primary, -1,
 2040                        $mem$$base, $mem$$disp, $mem$$index, 2/*prefetch function many-writes*/);
 2041   %}
 2042 
 2043   enc_class form3_mem_reg_long_unaligned_marshal( memory mem, iRegL reg ) %{
 2044     assert(Assembler::is_simm13($mem$$disp  ), &quot;need disp and disp+4&quot;);
 2045     assert(Assembler::is_simm13($mem$$disp+4), &quot;need disp and disp+4&quot;);
 2046     guarantee($mem$$index == R_G0_enc, &quot;double index?&quot;);
 2047     emit_form3_mem_reg(cbuf, ra_, this, $primary, -1, $mem$$base, $mem$$disp+4, R_G0_enc, R_O7_enc );
 2048     emit_form3_mem_reg(cbuf, ra_, this, $primary, -1, $mem$$base, $mem$$disp,   R_G0_enc, $reg$$reg );
 2049     emit3_simm13( cbuf, Assembler::arith_op, $reg$$reg, Assembler::sllx_op3, $reg$$reg, 0x1020 );
 2050     emit3( cbuf, Assembler::arith_op, $reg$$reg, Assembler::or_op3, $reg$$reg, 0, R_O7_enc );
 2051   %}
 2052 
 2053   enc_class form3_mem_reg_double_unaligned( memory mem, RegD_low reg ) %{
 2054     assert(Assembler::is_simm13($mem$$disp  ), &quot;need disp and disp+4&quot;);
 2055     assert(Assembler::is_simm13($mem$$disp+4), &quot;need disp and disp+4&quot;);
 2056     guarantee($mem$$index == R_G0_enc, &quot;double index?&quot;);
 2057     // Load long with 2 instructions
 2058     emit_form3_mem_reg(cbuf, ra_, this, $primary, -1, $mem$$base, $mem$$disp,   R_G0_enc, $reg$$reg+0 );
 2059     emit_form3_mem_reg(cbuf, ra_, this, $primary, -1, $mem$$base, $mem$$disp+4, R_G0_enc, $reg$$reg+1 );
 2060   %}
 2061 
 2062   //%%% form3_mem_plus_4_reg is a hack--get rid of it
 2063   enc_class form3_mem_plus_4_reg( memory mem, iRegI dst ) %{
 2064     guarantee($mem$$disp, &quot;cannot offset a reg-reg operand by 4&quot;);
 2065     emit_form3_mem_reg(cbuf, ra_, this, $primary, -1, $mem$$base, $mem$$disp + 4, $mem$$index, $dst$$reg);
 2066   %}
 2067 
 2068   enc_class form3_g0_rs2_rd_move( iRegI rs2, iRegI rd ) %{
 2069     // Encode a reg-reg copy.  If it is useless, then empty encoding.
 2070     if( $rs2$$reg != $rd$$reg )
 2071       emit3( cbuf, Assembler::arith_op, $rd$$reg, Assembler::or_op3, 0, 0, $rs2$$reg );
 2072   %}
 2073 
 2074   // Target lo half of long
 2075   enc_class form3_g0_rs2_rd_move_lo( iRegI rs2, iRegL rd ) %{
 2076     // Encode a reg-reg copy.  If it is useless, then empty encoding.
 2077     if( $rs2$$reg != LONG_LO_REG($rd$$reg) )
 2078       emit3( cbuf, Assembler::arith_op, LONG_LO_REG($rd$$reg), Assembler::or_op3, 0, 0, $rs2$$reg );
 2079   %}
 2080 
 2081   // Source lo half of long
 2082   enc_class form3_g0_rs2_rd_move_lo2( iRegL rs2, iRegI rd ) %{
 2083     // Encode a reg-reg copy.  If it is useless, then empty encoding.
 2084     if( LONG_LO_REG($rs2$$reg) != $rd$$reg )
 2085       emit3( cbuf, Assembler::arith_op, $rd$$reg, Assembler::or_op3, 0, 0, LONG_LO_REG($rs2$$reg) );
 2086   %}
 2087 
 2088   // Target hi half of long
 2089   enc_class form3_rs1_rd_copysign_hi( iRegI rs1, iRegL rd ) %{
 2090     emit3_simm13( cbuf, Assembler::arith_op, $rd$$reg, Assembler::sra_op3, $rs1$$reg, 31 );
 2091   %}
 2092 
 2093   // Source lo half of long, and leave it sign extended.
 2094   enc_class form3_rs1_rd_signextend_lo1( iRegL rs1, iRegI rd ) %{
 2095     // Sign extend low half
 2096     emit3( cbuf, Assembler::arith_op, $rd$$reg, Assembler::sra_op3, $rs1$$reg, 0, 0 );
 2097   %}
 2098 
 2099   // Source hi half of long, and leave it sign extended.
 2100   enc_class form3_rs1_rd_copy_hi1( iRegL rs1, iRegI rd ) %{
 2101     // Shift high half to low half
 2102     emit3_simm13( cbuf, Assembler::arith_op, $rd$$reg, Assembler::srlx_op3, $rs1$$reg, 32 );
 2103   %}
 2104 
 2105   // Source hi half of long
 2106   enc_class form3_g0_rs2_rd_move_hi2( iRegL rs2, iRegI rd ) %{
 2107     // Encode a reg-reg copy.  If it is useless, then empty encoding.
 2108     if( LONG_HI_REG($rs2$$reg) != $rd$$reg )
 2109       emit3( cbuf, Assembler::arith_op, $rd$$reg, Assembler::or_op3, 0, 0, LONG_HI_REG($rs2$$reg) );
 2110   %}
 2111 
 2112   enc_class form3_rs1_rs2_rd( iRegI rs1, iRegI rs2, iRegI rd ) %{
 2113     emit3( cbuf, $secondary, $rd$$reg, $primary, $rs1$$reg, 0, $rs2$$reg );
 2114   %}
 2115 
 2116   enc_class enc_to_bool( iRegI src, iRegI dst ) %{
 2117     emit3       ( cbuf, Assembler::arith_op,         0, Assembler::subcc_op3, 0, 0, $src$$reg );
 2118     emit3_simm13( cbuf, Assembler::arith_op, $dst$$reg, Assembler::addc_op3 , 0, 0 );
 2119   %}
 2120 
 2121   enc_class enc_ltmask( iRegI p, iRegI q, iRegI dst ) %{
 2122     emit3       ( cbuf, Assembler::arith_op,         0, Assembler::subcc_op3, $p$$reg, 0, $q$$reg );
 2123     // clear if nothing else is happening
 2124     emit3_simm13( cbuf, Assembler::arith_op, $dst$$reg, Assembler::or_op3, 0,  0 );
 2125     // blt,a,pn done
 2126     emit2_19    ( cbuf, Assembler::branch_op, 1/*annul*/, Assembler::less, Assembler::bp_op2, Assembler::icc, 0/*predict not taken*/, 2 );
 2127     // mov dst,-1 in delay slot
 2128     emit3_simm13( cbuf, Assembler::arith_op, $dst$$reg, Assembler::or_op3, 0, -1 );
 2129   %}
 2130 
 2131   enc_class form3_rs1_imm5_rd( iRegI rs1, immU5 imm5, iRegI rd ) %{
 2132     emit3_simm13( cbuf, $secondary, $rd$$reg, $primary, $rs1$$reg, $imm5$$constant &amp; 0x1F );
 2133   %}
 2134 
 2135   enc_class form3_sd_rs1_imm6_rd( iRegL rs1, immU6 imm6, iRegL rd ) %{
 2136     emit3_simm13( cbuf, $secondary, $rd$$reg, $primary, $rs1$$reg, ($imm6$$constant &amp; 0x3F) | 0x1000 );
 2137   %}
 2138 
 2139   enc_class form3_sd_rs1_rs2_rd( iRegL rs1, iRegI rs2, iRegL rd ) %{
 2140     emit3( cbuf, $secondary, $rd$$reg, $primary, $rs1$$reg, 0x80, $rs2$$reg );
 2141   %}
 2142 
 2143   enc_class form3_rs1_simm13_rd( iRegI rs1, immI13 simm13, iRegI rd ) %{
 2144     emit3_simm13( cbuf, $secondary, $rd$$reg, $primary, $rs1$$reg, $simm13$$constant );
 2145   %}
 2146 
 2147   enc_class move_return_pc_to_o1() %{
 2148     emit3_simm13( cbuf, Assembler::arith_op, R_O1_enc, Assembler::add_op3, R_O7_enc, frame::pc_return_offset );
 2149   %}
 2150 
 2151   /* %%% merge with enc_to_bool */
 2152   enc_class enc_convP2B( iRegI dst, iRegP src ) %{
<a name="35" id="anc35"></a><span class="line-modified"> 2153     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2154 
 2155     Register   src_reg = reg_to_register_object($src$$reg);
 2156     Register   dst_reg = reg_to_register_object($dst$$reg);
 2157     __ movr(Assembler::rc_nz, src_reg, 1, dst_reg);
 2158   %}
 2159 
 2160   enc_class enc_cadd_cmpLTMask( iRegI p, iRegI q, iRegI y, iRegI tmp ) %{
 2161     // (Set p (AddI (AndI (CmpLTMask p q) y) (SubI p q)))
<a name="36" id="anc36"></a><span class="line-modified"> 2162     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2163 
 2164     Register   p_reg = reg_to_register_object($p$$reg);
 2165     Register   q_reg = reg_to_register_object($q$$reg);
 2166     Register   y_reg = reg_to_register_object($y$$reg);
 2167     Register tmp_reg = reg_to_register_object($tmp$$reg);
 2168 
 2169     __ subcc( p_reg, q_reg,   p_reg );
 2170     __ add  ( p_reg, y_reg, tmp_reg );
 2171     __ movcc( Assembler::less, false, Assembler::icc, tmp_reg, p_reg );
 2172   %}
 2173 
 2174   enc_class form_d2i_helper(regD src, regF dst) %{
 2175     // fcmp %fcc0,$src,$src
 2176     emit3( cbuf, Assembler::arith_op , Assembler::fcc0, Assembler::fpop2_op3, $src$$reg, Assembler::fcmpd_opf, $src$$reg );
 2177     // branch %fcc0 not-nan, predict taken
 2178     emit2_19( cbuf, Assembler::branch_op, 0/*annul*/, Assembler::f_ordered, Assembler::fbp_op2, Assembler::fcc0, 1/*predict taken*/, 4 );
 2179     // fdtoi $src,$dst
 2180     emit3( cbuf, Assembler::arith_op , $dst$$reg, Assembler::fpop1_op3,         0, Assembler::fdtoi_opf, $src$$reg );
 2181     // fitos $dst,$dst (if nan)
 2182     emit3( cbuf, Assembler::arith_op , $dst$$reg, Assembler::fpop1_op3,         0, Assembler::fitos_opf, $dst$$reg );
 2183     // clear $dst (if nan)
 2184     emit3( cbuf, Assembler::arith_op , $dst$$reg, Assembler::fpop1_op3, $dst$$reg, Assembler::fsubs_opf, $dst$$reg );
 2185     // carry on here...
 2186   %}
 2187 
 2188   enc_class form_d2l_helper(regD src, regD dst) %{
 2189     // fcmp %fcc0,$src,$src  check for NAN
 2190     emit3( cbuf, Assembler::arith_op , Assembler::fcc0, Assembler::fpop2_op3, $src$$reg, Assembler::fcmpd_opf, $src$$reg );
 2191     // branch %fcc0 not-nan, predict taken
 2192     emit2_19( cbuf, Assembler::branch_op, 0/*annul*/, Assembler::f_ordered, Assembler::fbp_op2, Assembler::fcc0, 1/*predict taken*/, 4 );
 2193     // fdtox $src,$dst   convert in delay slot
 2194     emit3( cbuf, Assembler::arith_op , $dst$$reg, Assembler::fpop1_op3,         0, Assembler::fdtox_opf, $src$$reg );
 2195     // fxtod $dst,$dst  (if nan)
 2196     emit3( cbuf, Assembler::arith_op , $dst$$reg, Assembler::fpop1_op3,         0, Assembler::fxtod_opf, $dst$$reg );
 2197     // clear $dst (if nan)
 2198     emit3( cbuf, Assembler::arith_op , $dst$$reg, Assembler::fpop1_op3, $dst$$reg, Assembler::fsubd_opf, $dst$$reg );
 2199     // carry on here...
 2200   %}
 2201 
 2202   enc_class form_f2i_helper(regF src, regF dst) %{
 2203     // fcmps %fcc0,$src,$src
 2204     emit3( cbuf, Assembler::arith_op , Assembler::fcc0, Assembler::fpop2_op3, $src$$reg, Assembler::fcmps_opf, $src$$reg );
 2205     // branch %fcc0 not-nan, predict taken
 2206     emit2_19( cbuf, Assembler::branch_op, 0/*annul*/, Assembler::f_ordered, Assembler::fbp_op2, Assembler::fcc0, 1/*predict taken*/, 4 );
 2207     // fstoi $src,$dst
 2208     emit3( cbuf, Assembler::arith_op , $dst$$reg, Assembler::fpop1_op3,         0, Assembler::fstoi_opf, $src$$reg );
 2209     // fitos $dst,$dst (if nan)
 2210     emit3( cbuf, Assembler::arith_op , $dst$$reg, Assembler::fpop1_op3,         0, Assembler::fitos_opf, $dst$$reg );
 2211     // clear $dst (if nan)
 2212     emit3( cbuf, Assembler::arith_op , $dst$$reg, Assembler::fpop1_op3, $dst$$reg, Assembler::fsubs_opf, $dst$$reg );
 2213     // carry on here...
 2214   %}
 2215 
 2216   enc_class form_f2l_helper(regF src, regD dst) %{
 2217     // fcmps %fcc0,$src,$src
 2218     emit3( cbuf, Assembler::arith_op , Assembler::fcc0, Assembler::fpop2_op3, $src$$reg, Assembler::fcmps_opf, $src$$reg );
 2219     // branch %fcc0 not-nan, predict taken
 2220     emit2_19( cbuf, Assembler::branch_op, 0/*annul*/, Assembler::f_ordered, Assembler::fbp_op2, Assembler::fcc0, 1/*predict taken*/, 4 );
 2221     // fstox $src,$dst
 2222     emit3( cbuf, Assembler::arith_op , $dst$$reg, Assembler::fpop1_op3,         0, Assembler::fstox_opf, $src$$reg );
 2223     // fxtod $dst,$dst (if nan)
 2224     emit3( cbuf, Assembler::arith_op , $dst$$reg, Assembler::fpop1_op3,         0, Assembler::fxtod_opf, $dst$$reg );
 2225     // clear $dst (if nan)
 2226     emit3( cbuf, Assembler::arith_op , $dst$$reg, Assembler::fpop1_op3, $dst$$reg, Assembler::fsubd_opf, $dst$$reg );
 2227     // carry on here...
 2228   %}
 2229 
 2230   enc_class form3_opf_rs2F_rdF(regF rs2, regF rd) %{ emit3(cbuf,$secondary,$rd$$reg,$primary,0,$tertiary,$rs2$$reg); %}
 2231   enc_class form3_opf_rs2F_rdD(regF rs2, regD rd) %{ emit3(cbuf,$secondary,$rd$$reg,$primary,0,$tertiary,$rs2$$reg); %}
 2232   enc_class form3_opf_rs2D_rdF(regD rs2, regF rd) %{ emit3(cbuf,$secondary,$rd$$reg,$primary,0,$tertiary,$rs2$$reg); %}
 2233   enc_class form3_opf_rs2D_rdD(regD rs2, regD rd) %{ emit3(cbuf,$secondary,$rd$$reg,$primary,0,$tertiary,$rs2$$reg); %}
 2234 
 2235   enc_class form3_opf_rs2D_lo_rdF(regD rs2, regF rd) %{ emit3(cbuf,$secondary,$rd$$reg,$primary,0,$tertiary,$rs2$$reg+1); %}
 2236 
 2237   enc_class form3_opf_rs2D_hi_rdD_hi(regD rs2, regD rd) %{ emit3(cbuf,$secondary,$rd$$reg,$primary,0,$tertiary,$rs2$$reg); %}
 2238   enc_class form3_opf_rs2D_lo_rdD_lo(regD rs2, regD rd) %{ emit3(cbuf,$secondary,$rd$$reg+1,$primary,0,$tertiary,$rs2$$reg+1); %}
 2239 
 2240   enc_class form3_opf_rs1F_rs2F_rdF( regF rs1, regF rs2, regF rd ) %{
 2241     emit3( cbuf, $secondary, $rd$$reg, $primary, $rs1$$reg, $tertiary, $rs2$$reg );
 2242   %}
 2243 
 2244   enc_class form3_opf_rs1D_rs2D_rdD( regD rs1, regD rs2, regD rd ) %{
 2245     emit3( cbuf, $secondary, $rd$$reg, $primary, $rs1$$reg, $tertiary, $rs2$$reg );
 2246   %}
 2247 
 2248   enc_class form3_opf_rs1F_rs2F_fcc( regF rs1, regF rs2, flagsRegF fcc ) %{
 2249     emit3( cbuf, $secondary, $fcc$$reg, $primary, $rs1$$reg, $tertiary, $rs2$$reg );
 2250   %}
 2251 
 2252   enc_class form3_opf_rs1D_rs2D_fcc( regD rs1, regD rs2, flagsRegF fcc ) %{
 2253     emit3( cbuf, $secondary, $fcc$$reg, $primary, $rs1$$reg, $tertiary, $rs2$$reg );
 2254   %}
 2255 
 2256   enc_class form3_convI2F(regF rs2, regF rd) %{
 2257     emit3(cbuf,Assembler::arith_op,$rd$$reg,Assembler::fpop1_op3,0,$secondary,$rs2$$reg);
 2258   %}
 2259 
 2260   // Encloding class for traceable jumps
 2261   enc_class form_jmpl(g3RegP dest) %{
 2262     emit_jmpl(cbuf, $dest$$reg);
 2263   %}
 2264 
 2265   enc_class form_jmpl_set_exception_pc(g1RegP dest) %{
 2266     emit_jmpl_set_exception_pc(cbuf, $dest$$reg);
 2267   %}
 2268 
 2269   enc_class form2_nop() %{
 2270     emit_nop(cbuf);
 2271   %}
 2272 
 2273   enc_class form2_illtrap() %{
 2274     emit_illtrap(cbuf);
 2275   %}
 2276 
 2277 
 2278   // Compare longs and convert into -1, 0, 1.
 2279   enc_class cmpl_flag( iRegL src1, iRegL src2, iRegI dst ) %{
 2280     // CMP $src1,$src2
 2281     emit3( cbuf, Assembler::arith_op, 0, Assembler::subcc_op3, $src1$$reg, 0, $src2$$reg );
 2282     // blt,a,pn done
 2283     emit2_19( cbuf, Assembler::branch_op, 1/*annul*/, Assembler::less   , Assembler::bp_op2, Assembler::xcc, 0/*predict not taken*/, 5 );
 2284     // mov dst,-1 in delay slot
 2285     emit3_simm13( cbuf, Assembler::arith_op, $dst$$reg, Assembler::or_op3, 0, -1 );
 2286     // bgt,a,pn done
 2287     emit2_19( cbuf, Assembler::branch_op, 1/*annul*/, Assembler::greater, Assembler::bp_op2, Assembler::xcc, 0/*predict not taken*/, 3 );
 2288     // mov dst,1 in delay slot
 2289     emit3_simm13( cbuf, Assembler::arith_op, $dst$$reg, Assembler::or_op3, 0,  1 );
 2290     // CLR    $dst
 2291     emit3( cbuf, Assembler::arith_op, $dst$$reg, Assembler::or_op3 , 0, 0, 0 );
 2292   %}
 2293 
 2294   enc_class enc_PartialSubtypeCheck() %{
<a name="37" id="anc37"></a><span class="line-modified"> 2295     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2296     __ call(StubRoutines::Sparc::partial_subtype_check(), relocInfo::runtime_call_type);
 2297     __ delayed()-&gt;nop();
 2298   %}
 2299 
 2300   enc_class enc_bp( label labl, cmpOp cmp, flagsReg cc ) %{
<a name="38" id="anc38"></a><span class="line-modified"> 2301     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2302     Label* L = $labl$$label;
 2303     Assembler::Predict predict_taken =
 2304       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 2305 
 2306     __ bp( (Assembler::Condition)($cmp$$cmpcode), false, Assembler::icc, predict_taken, *L);
 2307     __ delayed()-&gt;nop();
 2308   %}
 2309 
 2310   enc_class enc_bpr( label labl, cmpOp_reg cmp, iRegI op1 ) %{
<a name="39" id="anc39"></a><span class="line-modified"> 2311     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2312     Label* L = $labl$$label;
 2313     Assembler::Predict predict_taken =
 2314       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 2315 
 2316     __ bpr( (Assembler::RCondition)($cmp$$cmpcode), false, predict_taken, as_Register($op1$$reg), *L);
 2317     __ delayed()-&gt;nop();
 2318   %}
 2319 
 2320   enc_class enc_cmov_reg( cmpOp cmp, iRegI dst, iRegI src, immI pcc) %{
 2321     int op = (Assembler::arith_op &lt;&lt; 30) |
 2322              ($dst$$reg &lt;&lt; 25) |
 2323              (Assembler::movcc_op3 &lt;&lt; 19) |
 2324              (1 &lt;&lt; 18) |                    // cc2 bit for &#39;icc&#39;
 2325              ($cmp$$cmpcode &lt;&lt; 14) |
 2326              (0 &lt;&lt; 13) |                    // select register move
 2327              ($pcc$$constant &lt;&lt; 11) |       // cc1, cc0 bits for &#39;icc&#39; or &#39;xcc&#39;
 2328              ($src$$reg &lt;&lt; 0);
 2329     cbuf.insts()-&gt;emit_int32(op);
 2330   %}
 2331 
 2332   enc_class enc_cmov_imm( cmpOp cmp, iRegI dst, immI11 src, immI pcc ) %{
 2333     int simm11 = $src$$constant &amp; ((1&lt;&lt;11)-1); // Mask to 11 bits
 2334     int op = (Assembler::arith_op &lt;&lt; 30) |
 2335              ($dst$$reg &lt;&lt; 25) |
 2336              (Assembler::movcc_op3 &lt;&lt; 19) |
 2337              (1 &lt;&lt; 18) |                    // cc2 bit for &#39;icc&#39;
 2338              ($cmp$$cmpcode &lt;&lt; 14) |
 2339              (1 &lt;&lt; 13) |                    // select immediate move
 2340              ($pcc$$constant &lt;&lt; 11) |       // cc1, cc0 bits for &#39;icc&#39;
 2341              (simm11 &lt;&lt; 0);
 2342     cbuf.insts()-&gt;emit_int32(op);
 2343   %}
 2344 
 2345   enc_class enc_cmov_reg_f( cmpOpF cmp, iRegI dst, iRegI src, flagsRegF fcc ) %{
 2346     int op = (Assembler::arith_op &lt;&lt; 30) |
 2347              ($dst$$reg &lt;&lt; 25) |
 2348              (Assembler::movcc_op3 &lt;&lt; 19) |
 2349              (0 &lt;&lt; 18) |                    // cc2 bit for &#39;fccX&#39;
 2350              ($cmp$$cmpcode &lt;&lt; 14) |
 2351              (0 &lt;&lt; 13) |                    // select register move
 2352              ($fcc$$reg &lt;&lt; 11) |            // cc1, cc0 bits for fcc0-fcc3
 2353              ($src$$reg &lt;&lt; 0);
 2354     cbuf.insts()-&gt;emit_int32(op);
 2355   %}
 2356 
 2357   enc_class enc_cmov_imm_f( cmpOp cmp, iRegI dst, immI11 src, flagsRegF fcc ) %{
 2358     int simm11 = $src$$constant &amp; ((1&lt;&lt;11)-1); // Mask to 11 bits
 2359     int op = (Assembler::arith_op &lt;&lt; 30) |
 2360              ($dst$$reg &lt;&lt; 25) |
 2361              (Assembler::movcc_op3 &lt;&lt; 19) |
 2362              (0 &lt;&lt; 18) |                    // cc2 bit for &#39;fccX&#39;
 2363              ($cmp$$cmpcode &lt;&lt; 14) |
 2364              (1 &lt;&lt; 13) |                    // select immediate move
 2365              ($fcc$$reg &lt;&lt; 11) |            // cc1, cc0 bits for fcc0-fcc3
 2366              (simm11 &lt;&lt; 0);
 2367     cbuf.insts()-&gt;emit_int32(op);
 2368   %}
 2369 
 2370   enc_class enc_cmovf_reg( cmpOp cmp, regD dst, regD src, immI pcc ) %{
 2371     int op = (Assembler::arith_op &lt;&lt; 30) |
 2372              ($dst$$reg &lt;&lt; 25) |
 2373              (Assembler::fpop2_op3 &lt;&lt; 19) |
 2374              (0 &lt;&lt; 18) |
 2375              ($cmp$$cmpcode &lt;&lt; 14) |
 2376              (1 &lt;&lt; 13) |                    // select register move
 2377              ($pcc$$constant &lt;&lt; 11) |       // cc1-cc0 bits for &#39;icc&#39; or &#39;xcc&#39;
 2378              ($primary &lt;&lt; 5) |              // select single, double or quad
 2379              ($src$$reg &lt;&lt; 0);
 2380     cbuf.insts()-&gt;emit_int32(op);
 2381   %}
 2382 
 2383   enc_class enc_cmovff_reg( cmpOpF cmp, flagsRegF fcc, regD dst, regD src ) %{
 2384     int op = (Assembler::arith_op &lt;&lt; 30) |
 2385              ($dst$$reg &lt;&lt; 25) |
 2386              (Assembler::fpop2_op3 &lt;&lt; 19) |
 2387              (0 &lt;&lt; 18) |
 2388              ($cmp$$cmpcode &lt;&lt; 14) |
 2389              ($fcc$$reg &lt;&lt; 11) |            // cc2-cc0 bits for &#39;fccX&#39;
 2390              ($primary &lt;&lt; 5) |              // select single, double or quad
 2391              ($src$$reg &lt;&lt; 0);
 2392     cbuf.insts()-&gt;emit_int32(op);
 2393   %}
 2394 
 2395   // Used by the MIN/MAX encodings.  Same as a CMOV, but
 2396   // the condition comes from opcode-field instead of an argument.
 2397   enc_class enc_cmov_reg_minmax( iRegI dst, iRegI src ) %{
 2398     int op = (Assembler::arith_op &lt;&lt; 30) |
 2399              ($dst$$reg &lt;&lt; 25) |
 2400              (Assembler::movcc_op3 &lt;&lt; 19) |
 2401              (1 &lt;&lt; 18) |                    // cc2 bit for &#39;icc&#39;
 2402              ($primary &lt;&lt; 14) |
 2403              (0 &lt;&lt; 13) |                    // select register move
 2404              (0 &lt;&lt; 11) |                    // cc1, cc0 bits for &#39;icc&#39;
 2405              ($src$$reg &lt;&lt; 0);
 2406     cbuf.insts()-&gt;emit_int32(op);
 2407   %}
 2408 
 2409   enc_class enc_cmov_reg_minmax_long( iRegL dst, iRegL src ) %{
 2410     int op = (Assembler::arith_op &lt;&lt; 30) |
 2411              ($dst$$reg &lt;&lt; 25) |
 2412              (Assembler::movcc_op3 &lt;&lt; 19) |
 2413              (6 &lt;&lt; 16) |                    // cc2 bit for &#39;xcc&#39;
 2414              ($primary &lt;&lt; 14) |
 2415              (0 &lt;&lt; 13) |                    // select register move
 2416              (0 &lt;&lt; 11) |                    // cc1, cc0 bits for &#39;icc&#39;
 2417              ($src$$reg &lt;&lt; 0);
 2418     cbuf.insts()-&gt;emit_int32(op);
 2419   %}
 2420 
 2421   enc_class Set13( immI13 src, iRegI rd ) %{
 2422     emit3_simm13( cbuf, Assembler::arith_op, $rd$$reg, Assembler::or_op3, 0, $src$$constant );
 2423   %}
 2424 
 2425   enc_class SetHi22( immI src, iRegI rd ) %{
 2426     emit2_22( cbuf, Assembler::branch_op, $rd$$reg, Assembler::sethi_op2, $src$$constant );
 2427   %}
 2428 
 2429   enc_class Set32( immI src, iRegI rd ) %{
<a name="40" id="anc40"></a><span class="line-modified"> 2430     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2431     __ set($src$$constant, reg_to_register_object($rd$$reg));
 2432   %}
 2433 
 2434   enc_class call_epilog %{
 2435     if( VerifyStackAtCalls ) {
<a name="41" id="anc41"></a><span class="line-modified"> 2436       C2_MacroAssembler _masm(&amp;cbuf);</span>
<span class="line-modified"> 2437       int framesize = ra_-&gt;C-&gt;output()-&gt;frame_size_in_bytes();</span>
 2438       Register temp_reg = G3;
 2439       __ add(SP, framesize, temp_reg);
 2440       __ cmp(temp_reg, FP);
 2441       __ breakpoint_trap(Assembler::notEqual, Assembler::ptr_cc);
 2442     }
 2443   %}
 2444 
 2445   // Long values come back from native calls in O0:O1 in the 32-bit VM, copy the value
 2446   // to G1 so the register allocator will not have to deal with the misaligned register
 2447   // pair.
 2448   enc_class adjust_long_from_native_call %{
 2449   %}
 2450 
 2451   enc_class Java_To_Runtime (method meth) %{    // CALL Java_To_Runtime
 2452     // CALL directly to the runtime
 2453     // The user of this is responsible for ensuring that R_L7 is empty (killed).
 2454     emit_call_reloc(cbuf, $meth$$method, runtime_call_Relocation::spec(), /*preserve_g2=*/true);
 2455   %}
 2456 
 2457   enc_class preserve_SP %{
<a name="42" id="anc42"></a><span class="line-modified"> 2458     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2459     __ mov(SP, L7_mh_SP_save);
 2460   %}
 2461 
 2462   enc_class restore_SP %{
<a name="43" id="anc43"></a><span class="line-modified"> 2463     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2464     __ mov(L7_mh_SP_save, SP);
 2465   %}
 2466 
 2467   enc_class Java_Static_Call (method meth) %{    // JAVA STATIC CALL
 2468     // CALL to fixup routine.  Fixup routine uses ScopeDesc info to determine
 2469     // who we intended to call.
 2470     if (!_method) {
 2471       emit_call_reloc(cbuf, $meth$$method, runtime_call_Relocation::spec());
 2472     } else {
 2473       int method_index = resolved_method_index(cbuf);
 2474       RelocationHolder rspec = _optimized_virtual ? opt_virtual_call_Relocation::spec(method_index)
 2475                                                   : static_call_Relocation::spec(method_index);
 2476       emit_call_reloc(cbuf, $meth$$method, rspec);
 2477 
 2478       // Emit stub for static call.
 2479       address stub = CompiledStaticCall::emit_to_interp_stub(cbuf);
 2480       if (stub == NULL) {
 2481         ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 2482         return;
 2483       }
 2484     }
 2485   %}
 2486 
 2487   enc_class Java_Dynamic_Call (method meth) %{    // JAVA DYNAMIC CALL
<a name="44" id="anc44"></a><span class="line-modified"> 2488     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2489     __ set_inst_mark();
 2490     int vtable_index = this-&gt;_vtable_index;
 2491     // MachCallDynamicJavaNode::ret_addr_offset uses this same test
 2492     if (vtable_index &lt; 0) {
 2493       // must be invalid_vtable_index, not nonvirtual_vtable_index
 2494       assert(vtable_index == Method::invalid_vtable_index, &quot;correct sentinel value&quot;);
 2495       Register G5_ic_reg = reg_to_register_object(Matcher::inline_cache_reg_encode());
 2496       assert(G5_ic_reg == G5_inline_cache_reg, &quot;G5_inline_cache_reg used in assemble_ic_buffer_code()&quot;);
 2497       assert(G5_ic_reg == G5_megamorphic_method, &quot;G5_megamorphic_method used in megamorphic call stub&quot;);
 2498       __ ic_call((address)$meth$$method, /*emit_delay=*/true, resolved_method_index(cbuf));
 2499     } else {
 2500       assert(!UseInlineCaches, &quot;expect vtable calls only if not using ICs&quot;);
 2501       // Just go thru the vtable
 2502       // get receiver klass (receiver already checked for non-null)
 2503       // If we end up going thru a c2i adapter interpreter expects method in G5
 2504       int off = __ offset();
 2505       __ load_klass(O0, G3_scratch);
 2506       int klass_load_size;
 2507       if (UseCompressedClassPointers) {
 2508         assert(Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
 2509         klass_load_size = MacroAssembler::instr_size_for_decode_klass_not_null() + 1*BytesPerInstWord;
 2510       } else {
 2511         klass_load_size = 1*BytesPerInstWord;
 2512       }
 2513       int entry_offset = in_bytes(Klass::vtable_start_offset()) + vtable_index*vtableEntry::size_in_bytes();
 2514       int v_off = entry_offset + vtableEntry::method_offset_in_bytes();
 2515       if (Assembler::is_simm13(v_off)) {
 2516         __ ld_ptr(G3, v_off, G5_method);
 2517       } else {
 2518         // Generate 2 instructions
 2519         __ Assembler::sethi(v_off &amp; ~0x3ff, G5_method);
 2520         __ or3(G5_method, v_off &amp; 0x3ff, G5_method);
 2521         // ld_ptr, set_hi, set
 2522         assert(__ offset() - off == klass_load_size + 2*BytesPerInstWord,
 2523                &quot;Unexpected instruction size(s)&quot;);
 2524         __ ld_ptr(G3, G5_method, G5_method);
 2525       }
 2526       // NOTE: for vtable dispatches, the vtable entry will never be null.
 2527       // However it may very well end up in handle_wrong_method if the
 2528       // method is abstract for the particular class.
 2529       __ ld_ptr(G5_method, in_bytes(Method::from_compiled_offset()), G3_scratch);
 2530       // jump to target (either compiled code or c2iadapter)
 2531       __ jmpl(G3_scratch, G0, O7);
 2532       __ delayed()-&gt;nop();
 2533     }
 2534   %}
 2535 
 2536   enc_class Java_Compiled_Call (method meth) %{    // JAVA COMPILED CALL
<a name="45" id="anc45"></a><span class="line-modified"> 2537     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2538 
 2539     Register G5_ic_reg = reg_to_register_object(Matcher::inline_cache_reg_encode());
 2540     Register temp_reg = G3;   // caller must kill G3!  We cannot reuse G5_ic_reg here because
 2541                               // we might be calling a C2I adapter which needs it.
 2542 
 2543     assert(temp_reg != G5_ic_reg, &quot;conflicting registers&quot;);
 2544     // Load nmethod
 2545     __ ld_ptr(G5_ic_reg, in_bytes(Method::from_compiled_offset()), temp_reg);
 2546 
 2547     // CALL to compiled java, indirect the contents of G3
 2548     __ set_inst_mark();
 2549     __ callr(temp_reg, G0);
 2550     __ delayed()-&gt;nop();
 2551   %}
 2552 
 2553 enc_class idiv_reg(iRegIsafe src1, iRegIsafe src2, iRegIsafe dst) %{
<a name="46" id="anc46"></a><span class="line-modified"> 2554     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2555     Register Rdividend = reg_to_register_object($src1$$reg);
 2556     Register Rdivisor = reg_to_register_object($src2$$reg);
 2557     Register Rresult = reg_to_register_object($dst$$reg);
 2558 
 2559     __ sra(Rdivisor, 0, Rdivisor);
 2560     __ sra(Rdividend, 0, Rdividend);
 2561     __ sdivx(Rdividend, Rdivisor, Rresult);
 2562 %}
 2563 
 2564 enc_class idiv_imm(iRegIsafe src1, immI13 imm, iRegIsafe dst) %{
<a name="47" id="anc47"></a><span class="line-modified"> 2565     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2566 
 2567     Register Rdividend = reg_to_register_object($src1$$reg);
 2568     int divisor = $imm$$constant;
 2569     Register Rresult = reg_to_register_object($dst$$reg);
 2570 
 2571     __ sra(Rdividend, 0, Rdividend);
 2572     __ sdivx(Rdividend, divisor, Rresult);
 2573 %}
 2574 
 2575 enc_class enc_mul_hi(iRegIsafe dst, iRegIsafe src1, iRegIsafe src2) %{
<a name="48" id="anc48"></a><span class="line-modified"> 2576     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2577     Register Rsrc1 = reg_to_register_object($src1$$reg);
 2578     Register Rsrc2 = reg_to_register_object($src2$$reg);
 2579     Register Rdst  = reg_to_register_object($dst$$reg);
 2580 
 2581     __ sra( Rsrc1, 0, Rsrc1 );
 2582     __ sra( Rsrc2, 0, Rsrc2 );
 2583     __ mulx( Rsrc1, Rsrc2, Rdst );
 2584     __ srlx( Rdst, 32, Rdst );
 2585 %}
 2586 
 2587 enc_class irem_reg(iRegIsafe src1, iRegIsafe src2, iRegIsafe dst, o7RegL scratch) %{
<a name="49" id="anc49"></a><span class="line-modified"> 2588     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2589     Register Rdividend = reg_to_register_object($src1$$reg);
 2590     Register Rdivisor = reg_to_register_object($src2$$reg);
 2591     Register Rresult = reg_to_register_object($dst$$reg);
 2592     Register Rscratch = reg_to_register_object($scratch$$reg);
 2593 
 2594     assert(Rdividend != Rscratch, &quot;&quot;);
 2595     assert(Rdivisor  != Rscratch, &quot;&quot;);
 2596 
 2597     __ sra(Rdividend, 0, Rdividend);
 2598     __ sra(Rdivisor, 0, Rdivisor);
 2599     __ sdivx(Rdividend, Rdivisor, Rscratch);
 2600     __ mulx(Rscratch, Rdivisor, Rscratch);
 2601     __ sub(Rdividend, Rscratch, Rresult);
 2602 %}
 2603 
 2604 enc_class irem_imm(iRegIsafe src1, immI13 imm, iRegIsafe dst, o7RegL scratch) %{
<a name="50" id="anc50"></a><span class="line-modified"> 2605     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2606 
 2607     Register Rdividend = reg_to_register_object($src1$$reg);
 2608     int divisor = $imm$$constant;
 2609     Register Rresult = reg_to_register_object($dst$$reg);
 2610     Register Rscratch = reg_to_register_object($scratch$$reg);
 2611 
 2612     assert(Rdividend != Rscratch, &quot;&quot;);
 2613 
 2614     __ sra(Rdividend, 0, Rdividend);
 2615     __ sdivx(Rdividend, divisor, Rscratch);
 2616     __ mulx(Rscratch, divisor, Rscratch);
 2617     __ sub(Rdividend, Rscratch, Rresult);
 2618 %}
 2619 
 2620 enc_class fabss (sflt_reg dst, sflt_reg src) %{
<a name="51" id="anc51"></a><span class="line-modified"> 2621     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2622 
 2623     FloatRegister Fdst = reg_to_SingleFloatRegister_object($dst$$reg);
 2624     FloatRegister Fsrc = reg_to_SingleFloatRegister_object($src$$reg);
 2625 
 2626     __ fabs(FloatRegisterImpl::S, Fsrc, Fdst);
 2627 %}
 2628 
 2629 enc_class fabsd (dflt_reg dst, dflt_reg src) %{
<a name="52" id="anc52"></a><span class="line-modified"> 2630     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2631 
 2632     FloatRegister Fdst = reg_to_DoubleFloatRegister_object($dst$$reg);
 2633     FloatRegister Fsrc = reg_to_DoubleFloatRegister_object($src$$reg);
 2634 
 2635     __ fabs(FloatRegisterImpl::D, Fsrc, Fdst);
 2636 %}
 2637 
 2638 enc_class fnegd (dflt_reg dst, dflt_reg src) %{
<a name="53" id="anc53"></a><span class="line-modified"> 2639     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2640 
 2641     FloatRegister Fdst = reg_to_DoubleFloatRegister_object($dst$$reg);
 2642     FloatRegister Fsrc = reg_to_DoubleFloatRegister_object($src$$reg);
 2643 
 2644     __ fneg(FloatRegisterImpl::D, Fsrc, Fdst);
 2645 %}
 2646 
 2647 enc_class fsqrts (sflt_reg dst, sflt_reg src) %{
<a name="54" id="anc54"></a><span class="line-modified"> 2648     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2649 
 2650     FloatRegister Fdst = reg_to_SingleFloatRegister_object($dst$$reg);
 2651     FloatRegister Fsrc = reg_to_SingleFloatRegister_object($src$$reg);
 2652 
 2653     __ fsqrt(FloatRegisterImpl::S, Fsrc, Fdst);
 2654 %}
 2655 
 2656 enc_class fsqrtd (dflt_reg dst, dflt_reg src) %{
<a name="55" id="anc55"></a><span class="line-modified"> 2657     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2658 
 2659     FloatRegister Fdst = reg_to_DoubleFloatRegister_object($dst$$reg);
 2660     FloatRegister Fsrc = reg_to_DoubleFloatRegister_object($src$$reg);
 2661 
 2662     __ fsqrt(FloatRegisterImpl::D, Fsrc, Fdst);
 2663 %}
 2664 
 2665 
 2666 enc_class fmadds (sflt_reg dst, sflt_reg a, sflt_reg b, sflt_reg c) %{
<a name="56" id="anc56"></a><span class="line-modified"> 2667     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2668 
 2669     FloatRegister Frd = reg_to_SingleFloatRegister_object($dst$$reg);
 2670     FloatRegister Fra = reg_to_SingleFloatRegister_object($a$$reg);
 2671     FloatRegister Frb = reg_to_SingleFloatRegister_object($b$$reg);
 2672     FloatRegister Frc = reg_to_SingleFloatRegister_object($c$$reg);
 2673 
 2674     __ fmadd(FloatRegisterImpl::S, Fra, Frb, Frc, Frd);
 2675 %}
 2676 
 2677 enc_class fmaddd (dflt_reg dst, dflt_reg a, dflt_reg b, dflt_reg c) %{
<a name="57" id="anc57"></a><span class="line-modified"> 2678     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2679 
 2680     FloatRegister Frd = reg_to_DoubleFloatRegister_object($dst$$reg);
 2681     FloatRegister Fra = reg_to_DoubleFloatRegister_object($a$$reg);
 2682     FloatRegister Frb = reg_to_DoubleFloatRegister_object($b$$reg);
 2683     FloatRegister Frc = reg_to_DoubleFloatRegister_object($c$$reg);
 2684 
 2685     __ fmadd(FloatRegisterImpl::D, Fra, Frb, Frc, Frd);
 2686 %}
 2687 
 2688 enc_class fmsubs (sflt_reg dst, sflt_reg a, sflt_reg b, sflt_reg c) %{
<a name="58" id="anc58"></a><span class="line-modified"> 2689     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2690 
 2691     FloatRegister Frd = reg_to_SingleFloatRegister_object($dst$$reg);
 2692     FloatRegister Fra = reg_to_SingleFloatRegister_object($a$$reg);
 2693     FloatRegister Frb = reg_to_SingleFloatRegister_object($b$$reg);
 2694     FloatRegister Frc = reg_to_SingleFloatRegister_object($c$$reg);
 2695 
 2696     __ fmsub(FloatRegisterImpl::S, Fra, Frb, Frc, Frd);
 2697 %}
 2698 
 2699 enc_class fmsubd (dflt_reg dst, dflt_reg a, dflt_reg b, dflt_reg c) %{
<a name="59" id="anc59"></a><span class="line-modified"> 2700     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2701 
 2702     FloatRegister Frd = reg_to_DoubleFloatRegister_object($dst$$reg);
 2703     FloatRegister Fra = reg_to_DoubleFloatRegister_object($a$$reg);
 2704     FloatRegister Frb = reg_to_DoubleFloatRegister_object($b$$reg);
 2705     FloatRegister Frc = reg_to_DoubleFloatRegister_object($c$$reg);
 2706 
 2707     __ fmsub(FloatRegisterImpl::D, Fra, Frb, Frc, Frd);
 2708 %}
 2709 
 2710 enc_class fnmadds (sflt_reg dst, sflt_reg a, sflt_reg b, sflt_reg c) %{
<a name="60" id="anc60"></a><span class="line-modified"> 2711     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2712 
 2713     FloatRegister Frd = reg_to_SingleFloatRegister_object($dst$$reg);
 2714     FloatRegister Fra = reg_to_SingleFloatRegister_object($a$$reg);
 2715     FloatRegister Frb = reg_to_SingleFloatRegister_object($b$$reg);
 2716     FloatRegister Frc = reg_to_SingleFloatRegister_object($c$$reg);
 2717 
 2718     __ fnmadd(FloatRegisterImpl::S, Fra, Frb, Frc, Frd);
 2719 %}
 2720 
 2721 enc_class fnmaddd (dflt_reg dst, dflt_reg a, dflt_reg b, dflt_reg c) %{
<a name="61" id="anc61"></a><span class="line-modified"> 2722     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2723 
 2724     FloatRegister Frd = reg_to_DoubleFloatRegister_object($dst$$reg);
 2725     FloatRegister Fra = reg_to_DoubleFloatRegister_object($a$$reg);
 2726     FloatRegister Frb = reg_to_DoubleFloatRegister_object($b$$reg);
 2727     FloatRegister Frc = reg_to_DoubleFloatRegister_object($c$$reg);
 2728 
 2729     __ fnmadd(FloatRegisterImpl::D, Fra, Frb, Frc, Frd);
 2730 %}
 2731 
 2732 enc_class fnmsubs (sflt_reg dst, sflt_reg a, sflt_reg b, sflt_reg c) %{
<a name="62" id="anc62"></a><span class="line-modified"> 2733     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2734 
 2735     FloatRegister Frd = reg_to_SingleFloatRegister_object($dst$$reg);
 2736     FloatRegister Fra = reg_to_SingleFloatRegister_object($a$$reg);
 2737     FloatRegister Frb = reg_to_SingleFloatRegister_object($b$$reg);
 2738     FloatRegister Frc = reg_to_SingleFloatRegister_object($c$$reg);
 2739 
 2740     __ fnmsub(FloatRegisterImpl::S, Fra, Frb, Frc, Frd);
 2741 %}
 2742 
 2743 enc_class fnmsubd (dflt_reg dst, dflt_reg a, dflt_reg b, dflt_reg c) %{
<a name="63" id="anc63"></a><span class="line-modified"> 2744     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2745 
 2746     FloatRegister Frd = reg_to_DoubleFloatRegister_object($dst$$reg);
 2747     FloatRegister Fra = reg_to_DoubleFloatRegister_object($a$$reg);
 2748     FloatRegister Frb = reg_to_DoubleFloatRegister_object($b$$reg);
 2749     FloatRegister Frc = reg_to_DoubleFloatRegister_object($c$$reg);
 2750 
 2751     __ fnmsub(FloatRegisterImpl::D, Fra, Frb, Frc, Frd);
 2752 %}
 2753 
 2754 
 2755 enc_class fmovs (dflt_reg dst, dflt_reg src) %{
<a name="64" id="anc64"></a><span class="line-modified"> 2756     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2757 
 2758     FloatRegister Fdst = reg_to_SingleFloatRegister_object($dst$$reg);
 2759     FloatRegister Fsrc = reg_to_SingleFloatRegister_object($src$$reg);
 2760 
 2761     __ fmov(FloatRegisterImpl::S, Fsrc, Fdst);
 2762 %}
 2763 
 2764 enc_class fmovd (dflt_reg dst, dflt_reg src) %{
<a name="65" id="anc65"></a><span class="line-modified"> 2765     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2766 
 2767     FloatRegister Fdst = reg_to_DoubleFloatRegister_object($dst$$reg);
 2768     FloatRegister Fsrc = reg_to_DoubleFloatRegister_object($src$$reg);
 2769 
 2770     __ fmov(FloatRegisterImpl::D, Fsrc, Fdst);
 2771 %}
 2772 
 2773 enc_class Fast_Lock(iRegP oop, iRegP box, o7RegP scratch, iRegP scratch2) %{
<a name="66" id="anc66"></a><span class="line-modified"> 2774     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2775 
 2776     Register Roop  = reg_to_register_object($oop$$reg);
 2777     Register Rbox  = reg_to_register_object($box$$reg);
 2778     Register Rscratch = reg_to_register_object($scratch$$reg);
 2779     Register Rmark =    reg_to_register_object($scratch2$$reg);
 2780 
 2781     assert(Roop  != Rscratch, &quot;&quot;);
 2782     assert(Roop  != Rmark, &quot;&quot;);
 2783     assert(Rbox  != Rscratch, &quot;&quot;);
 2784     assert(Rbox  != Rmark, &quot;&quot;);
 2785 
 2786     __ compiler_lock_object(Roop, Rmark, Rbox, Rscratch, _counters, UseBiasedLocking &amp;&amp; !UseOptoBiasInlining);
 2787 %}
 2788 
 2789 enc_class Fast_Unlock(iRegP oop, iRegP box, o7RegP scratch, iRegP scratch2) %{
<a name="67" id="anc67"></a><span class="line-modified"> 2790     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2791 
 2792     Register Roop  = reg_to_register_object($oop$$reg);
 2793     Register Rbox  = reg_to_register_object($box$$reg);
 2794     Register Rscratch = reg_to_register_object($scratch$$reg);
 2795     Register Rmark =    reg_to_register_object($scratch2$$reg);
 2796 
 2797     assert(Roop  != Rscratch, &quot;&quot;);
 2798     assert(Roop  != Rmark, &quot;&quot;);
 2799     assert(Rbox  != Rscratch, &quot;&quot;);
 2800     assert(Rbox  != Rmark, &quot;&quot;);
 2801 
 2802     __ compiler_unlock_object(Roop, Rmark, Rbox, Rscratch, UseBiasedLocking &amp;&amp; !UseOptoBiasInlining);
 2803   %}
 2804 
 2805   enc_class enc_cas( iRegP mem, iRegP old, iRegP new ) %{
<a name="68" id="anc68"></a><span class="line-modified"> 2806     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2807     Register Rmem = reg_to_register_object($mem$$reg);
 2808     Register Rold = reg_to_register_object($old$$reg);
 2809     Register Rnew = reg_to_register_object($new$$reg);
 2810 
 2811     __ cas_ptr(Rmem, Rold, Rnew); // Swap(*Rmem,Rnew) if *Rmem == Rold
 2812     __ cmp( Rold, Rnew );
 2813   %}
 2814 
 2815   enc_class enc_casx( iRegP mem, iRegL old, iRegL new) %{
 2816     Register Rmem = reg_to_register_object($mem$$reg);
 2817     Register Rold = reg_to_register_object($old$$reg);
 2818     Register Rnew = reg_to_register_object($new$$reg);
 2819 
<a name="69" id="anc69"></a><span class="line-modified"> 2820     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2821     __ mov(Rnew, O7);
 2822     __ casx(Rmem, Rold, O7);
 2823     __ cmp( Rold, O7 );
 2824   %}
 2825 
 2826   // raw int cas, used for compareAndSwap
 2827   enc_class enc_casi( iRegP mem, iRegL old, iRegL new) %{
 2828     Register Rmem = reg_to_register_object($mem$$reg);
 2829     Register Rold = reg_to_register_object($old$$reg);
 2830     Register Rnew = reg_to_register_object($new$$reg);
 2831 
<a name="70" id="anc70"></a><span class="line-modified"> 2832     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2833     __ mov(Rnew, O7);
 2834     __ cas(Rmem, Rold, O7);
 2835     __ cmp( Rold, O7 );
 2836   %}
 2837 
 2838   // raw int cas without using tmp register for compareAndExchange
 2839   enc_class enc_casi_exch( iRegP mem, iRegL old, iRegL new) %{
 2840     Register Rmem = reg_to_register_object($mem$$reg);
 2841     Register Rold = reg_to_register_object($old$$reg);
 2842     Register Rnew = reg_to_register_object($new$$reg);
 2843 
<a name="71" id="anc71"></a><span class="line-modified"> 2844     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2845     __ cas(Rmem, Rold, Rnew);
 2846   %}
 2847 
 2848   // 64-bit cas without using tmp register for compareAndExchange
 2849   enc_class enc_casx_exch( iRegP mem, iRegL old, iRegL new) %{
 2850     Register Rmem = reg_to_register_object($mem$$reg);
 2851     Register Rold = reg_to_register_object($old$$reg);
 2852     Register Rnew = reg_to_register_object($new$$reg);
 2853 
<a name="72" id="anc72"></a><span class="line-modified"> 2854     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2855     __ casx(Rmem, Rold, Rnew);
 2856   %}
 2857 
 2858   enc_class enc_lflags_ne_to_boolean( iRegI res ) %{
 2859     Register Rres = reg_to_register_object($res$$reg);
 2860 
<a name="73" id="anc73"></a><span class="line-modified"> 2861     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2862     __ mov(1, Rres);
 2863     __ movcc( Assembler::notEqual, false, Assembler::xcc, G0, Rres );
 2864   %}
 2865 
 2866   enc_class enc_iflags_ne_to_boolean( iRegI res ) %{
 2867     Register Rres = reg_to_register_object($res$$reg);
 2868 
<a name="74" id="anc74"></a><span class="line-modified"> 2869     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2870     __ mov(1, Rres);
 2871     __ movcc( Assembler::notEqual, false, Assembler::icc, G0, Rres );
 2872   %}
 2873 
 2874   enc_class floating_cmp ( iRegP dst, regF src1, regF src2 ) %{
<a name="75" id="anc75"></a><span class="line-modified"> 2875     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2876     Register Rdst = reg_to_register_object($dst$$reg);
 2877     FloatRegister Fsrc1 = $primary ? reg_to_SingleFloatRegister_object($src1$$reg)
 2878                                      : reg_to_DoubleFloatRegister_object($src1$$reg);
 2879     FloatRegister Fsrc2 = $primary ? reg_to_SingleFloatRegister_object($src2$$reg)
 2880                                      : reg_to_DoubleFloatRegister_object($src2$$reg);
 2881 
 2882     // Convert condition code fcc0 into -1,0,1; unordered reports less-than (-1)
 2883     __ float_cmp( $primary, -1, Fsrc1, Fsrc2, Rdst);
 2884   %}
 2885 
 2886   enc_class enc_rethrow() %{
 2887     cbuf.set_insts_mark();
 2888     Register temp_reg = G3;
 2889     AddressLiteral rethrow_stub(OptoRuntime::rethrow_stub());
 2890     assert(temp_reg != reg_to_register_object(R_I0_num), &quot;temp must not break oop_reg&quot;);
<a name="76" id="anc76"></a><span class="line-modified"> 2891     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2892 #ifdef ASSERT
 2893     __ save_frame(0);
 2894     AddressLiteral last_rethrow_addrlit(&amp;last_rethrow);
 2895     __ sethi(last_rethrow_addrlit, L1);
 2896     Address addr(L1, last_rethrow_addrlit.low10());
 2897     __ rdpc(L2);
 2898     __ inc(L2, 3 * BytesPerInstWord);  // skip this &amp; 2 more insns to point at jump_to
 2899     __ st_ptr(L2, addr);
 2900     __ restore();
 2901 #endif
 2902     __ JUMP(rethrow_stub, temp_reg, 0); // sethi;jmp
 2903     __ delayed()-&gt;nop();
 2904   %}
 2905 
 2906   enc_class emit_mem_nop() %{
 2907     // Generates the instruction LDUXA [o6,g0],#0x82,g0
 2908     cbuf.insts()-&gt;emit_int32((unsigned int) 0xc0839040);
 2909   %}
 2910 
 2911   enc_class emit_fadd_nop() %{
 2912     // Generates the instruction FMOVS f31,f31
 2913     cbuf.insts()-&gt;emit_int32((unsigned int) 0xbfa0003f);
 2914   %}
 2915 
 2916   enc_class emit_br_nop() %{
 2917     // Generates the instruction BPN,PN .
 2918     cbuf.insts()-&gt;emit_int32((unsigned int) 0x00400000);
 2919   %}
 2920 
 2921   enc_class enc_membar_acquire %{
<a name="77" id="anc77"></a><span class="line-modified"> 2922     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2923     __ membar( Assembler::Membar_mask_bits(Assembler::LoadStore | Assembler::LoadLoad) );
 2924   %}
 2925 
 2926   enc_class enc_membar_release %{
<a name="78" id="anc78"></a><span class="line-modified"> 2927     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2928     __ membar( Assembler::Membar_mask_bits(Assembler::LoadStore | Assembler::StoreStore) );
 2929   %}
 2930 
 2931   enc_class enc_membar_volatile %{
<a name="79" id="anc79"></a><span class="line-modified"> 2932     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2933     __ membar( Assembler::Membar_mask_bits(Assembler::StoreLoad) );
 2934   %}
 2935 
 2936 %}
 2937 
 2938 //----------FRAME--------------------------------------------------------------
 2939 // Definition of frame structure and management information.
 2940 //
 2941 //  S T A C K   L A Y O U T    Allocators stack-slot number
 2942 //                             |   (to get allocators register number
 2943 //  G  Owned by    |        |  v    add VMRegImpl::stack0)
 2944 //  r   CALLER     |        |
 2945 //  o     |        +--------+      pad to even-align allocators stack-slot
 2946 //  w     V        |  pad0  |        numbers; owned by CALLER
 2947 //  t   -----------+--------+----&gt; Matcher::_in_arg_limit, unaligned
 2948 //  h     ^        |   in   |  5
 2949 //        |        |  args  |  4   Holes in incoming args owned by SELF
 2950 //  |     |        |        |  3
 2951 //  |     |        +--------+
 2952 //  V     |        | old out|      Empty on Intel, window on Sparc
 2953 //        |    old |preserve|      Must be even aligned.
 2954 //        |     SP-+--------+----&gt; Matcher::_old_SP, 8 (or 16 in LP64)-byte aligned
 2955 //        |        |   in   |  3   area for Intel ret address
 2956 //     Owned by    |preserve|      Empty on Sparc.
 2957 //       SELF      +--------+
 2958 //        |        |  pad2  |  2   pad to align old SP
 2959 //        |        +--------+  1
 2960 //        |        | locks  |  0
 2961 //        |        +--------+----&gt; VMRegImpl::stack0, 8 (or 16 in LP64)-byte aligned
 2962 //        |        |  pad1  | 11   pad to align new SP
 2963 //        |        +--------+
 2964 //        |        |        | 10
 2965 //        |        | spills |  9   spills
 2966 //        V        |        |  8   (pad0 slot for callee)
 2967 //      -----------+--------+----&gt; Matcher::_out_arg_limit, unaligned
 2968 //        ^        |  out   |  7
 2969 //        |        |  args  |  6   Holes in outgoing args owned by CALLEE
 2970 //     Owned by    +--------+
 2971 //      CALLEE     | new out|  6   Empty on Intel, window on Sparc
 2972 //        |    new |preserve|      Must be even-aligned.
 2973 //        |     SP-+--------+----&gt; Matcher::_new_SP, even aligned
 2974 //        |        |        |
 2975 //
 2976 // Note 1: Only region 8-11 is determined by the allocator.  Region 0-5 is
 2977 //         known from SELF&#39;s arguments and the Java calling convention.
 2978 //         Region 6-7 is determined per call site.
 2979 // Note 2: If the calling convention leaves holes in the incoming argument
 2980 //         area, those holes are owned by SELF.  Holes in the outgoing area
 2981 //         are owned by the CALLEE.  Holes should not be nessecary in the
 2982 //         incoming area, as the Java calling convention is completely under
 2983 //         the control of the AD file.  Doubles can be sorted and packed to
 2984 //         avoid holes.  Holes in the outgoing arguments may be necessary for
 2985 //         varargs C calling conventions.
 2986 // Note 3: Region 0-3 is even aligned, with pad2 as needed.  Region 3-5 is
 2987 //         even aligned with pad0 as needed.
 2988 //         Region 6 is even aligned.  Region 6-7 is NOT even aligned;
 2989 //         region 6-11 is even aligned; it may be padded out more so that
 2990 //         the region from SP to FP meets the minimum stack alignment.
 2991 
 2992 frame %{
 2993   // What direction does stack grow in (assumed to be same for native &amp; Java)
 2994   stack_direction(TOWARDS_LOW);
 2995 
 2996   // These two registers define part of the calling convention
 2997   // between compiled code and the interpreter.
 2998   inline_cache_reg(R_G5);                // Inline Cache Register or Method* for I2C
 2999   interpreter_method_oop_reg(R_G5);      // Method Oop Register when calling interpreter
 3000 
 3001   // Optional: name the operand used by cisc-spilling to access [stack_pointer + offset]
 3002   cisc_spilling_operand_name(indOffset);
 3003 
 3004   // Number of stack slots consumed by a Monitor enter
 3005   sync_stack_slots(2);
 3006 
 3007   // Compiled code&#39;s Frame Pointer
 3008   frame_pointer(R_SP);
 3009 
 3010   // Stack alignment requirement
 3011   stack_alignment(StackAlignmentInBytes);
 3012   //  LP64: Alignment size in bytes (128-bit -&gt; 16 bytes)
 3013   // !LP64: Alignment size in bytes (64-bit  -&gt;  8 bytes)
 3014 
 3015   // Number of stack slots between incoming argument block and the start of
 3016   // a new frame.  The PROLOG must add this many slots to the stack.  The
 3017   // EPILOG must remove this many slots.
 3018   in_preserve_stack_slots(0);
 3019 
 3020   // Number of outgoing stack slots killed above the out_preserve_stack_slots
 3021   // for calls to C.  Supports the var-args backing area for register parms.
 3022   // ADLC doesn&#39;t support parsing expressions, so I folded the math by hand.
 3023   // (callee_register_argument_save_area_words (6) + callee_aggregate_return_pointer_words (0)) * 2-stack-slots-per-word
 3024   varargs_C_out_slots_killed(12);
 3025 
 3026   // The after-PROLOG location of the return address.  Location of
 3027   // return address specifies a type (REG or STACK) and a number
 3028   // representing the register number (i.e. - use a register name) or
 3029   // stack slot.
 3030   return_addr(REG R_I7);          // Ret Addr is in register I7
 3031 
 3032   // Body of function which returns an OptoRegs array locating
 3033   // arguments either in registers or in stack slots for calling
 3034   // java
 3035   calling_convention %{
 3036     (void) SharedRuntime::java_calling_convention(sig_bt, regs, length, is_outgoing);
 3037 
 3038   %}
 3039 
 3040   // Body of function which returns an OptoRegs array locating
 3041   // arguments either in registers or in stack slots for calling
 3042   // C.
 3043   c_calling_convention %{
 3044     // This is obviously always outgoing
 3045     (void) SharedRuntime::c_calling_convention(sig_bt, regs, /*regs2=*/NULL, length);
 3046   %}
 3047 
 3048   // Location of native (C/C++) and interpreter return values.  This is specified to
 3049   // be the  same as Java.  In the 32-bit VM, long values are actually returned from
 3050   // native calls in O0:O1 and returned to the interpreter in I0:I1.  The copying
 3051   // to and from the register pairs is done by the appropriate call and epilog
 3052   // opcodes.  This simplifies the register allocator.
 3053   c_return_value %{
 3054     assert( ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL, &quot;only return normal values&quot; );
 3055     static int lo_out[Op_RegL+1] = { OptoReg::Bad, OptoReg::Bad, R_O0_num,     R_O0_num,     R_O0_num,     R_F0_num,     R_F0_num, R_O0_num };
 3056     static int hi_out[Op_RegL+1] = { OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, R_O0H_num,    OptoReg::Bad, R_F1_num, R_O0H_num};
 3057     static int lo_in [Op_RegL+1] = { OptoReg::Bad, OptoReg::Bad, R_I0_num,     R_I0_num,     R_I0_num,     R_F0_num,     R_F0_num, R_I0_num };
 3058     static int hi_in [Op_RegL+1] = { OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, R_I0H_num,    OptoReg::Bad, R_F1_num, R_I0H_num};
 3059     return OptoRegPair( (is_outgoing?hi_out:hi_in)[ideal_reg],
 3060                         (is_outgoing?lo_out:lo_in)[ideal_reg] );
 3061   %}
 3062 
 3063   // Location of compiled Java return values.  Same as C
 3064   return_value %{
 3065     assert( ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL, &quot;only return normal values&quot; );
 3066     static int lo_out[Op_RegL+1] = { OptoReg::Bad, OptoReg::Bad, R_O0_num,     R_O0_num,     R_O0_num,     R_F0_num,     R_F0_num, R_O0_num };
 3067     static int hi_out[Op_RegL+1] = { OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, R_O0H_num,    OptoReg::Bad, R_F1_num, R_O0H_num};
 3068     static int lo_in [Op_RegL+1] = { OptoReg::Bad, OptoReg::Bad, R_I0_num,     R_I0_num,     R_I0_num,     R_F0_num,     R_F0_num, R_I0_num };
 3069     static int hi_in [Op_RegL+1] = { OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, R_I0H_num,    OptoReg::Bad, R_F1_num, R_I0H_num};
 3070     return OptoRegPair( (is_outgoing?hi_out:hi_in)[ideal_reg],
 3071                         (is_outgoing?lo_out:lo_in)[ideal_reg] );
 3072   %}
 3073 
 3074 %}
 3075 
 3076 
 3077 //----------ATTRIBUTES---------------------------------------------------------
 3078 //----------Operand Attributes-------------------------------------------------
 3079 op_attrib op_cost(1);          // Required cost attribute
 3080 
 3081 //----------Instruction Attributes---------------------------------------------
 3082 ins_attrib ins_cost(DEFAULT_COST); // Required cost attribute
 3083 ins_attrib ins_size(32);           // Required size attribute (in bits)
 3084 
 3085 // avoid_back_to_back attribute is an expression that must return
 3086 // one of the following values defined in MachNode:
 3087 // AVOID_NONE   - instruction can be placed anywhere
 3088 // AVOID_BEFORE - instruction cannot be placed after an
 3089 //                instruction with MachNode::AVOID_AFTER
 3090 // AVOID_AFTER  - the next instruction cannot be the one
 3091 //                with MachNode::AVOID_BEFORE
 3092 // AVOID_BEFORE_AND_AFTER - BEFORE and AFTER attributes at
 3093 //                          the same time
 3094 ins_attrib ins_avoid_back_to_back(MachNode::AVOID_NONE);
 3095 
 3096 ins_attrib ins_short_branch(0);    // Required flag: is this instruction a
 3097                                    // non-matching short branch variant of some
 3098                                                             // long branch?
 3099 
 3100 //----------OPERANDS-----------------------------------------------------------
 3101 // Operand definitions must precede instruction definitions for correct parsing
 3102 // in the ADLC because operands constitute user defined types which are used in
 3103 // instruction definitions.
 3104 
 3105 //----------Simple Operands----------------------------------------------------
 3106 // Immediate Operands
 3107 // Integer Immediate: 32-bit
 3108 operand immI() %{
 3109   match(ConI);
 3110 
 3111   op_cost(0);
 3112   // formats are generated automatically for constants and base registers
 3113   format %{ %}
 3114   interface(CONST_INTER);
 3115 %}
 3116 
 3117 // Integer Immediate: 0-bit
 3118 operand immI0() %{
 3119   predicate(n-&gt;get_int() == 0);
 3120   match(ConI);
 3121   op_cost(0);
 3122 
 3123   format %{ %}
 3124   interface(CONST_INTER);
 3125 %}
 3126 
 3127 // Integer Immediate: 5-bit
 3128 operand immI5() %{
 3129   predicate(Assembler::is_simm5(n-&gt;get_int()));
 3130   match(ConI);
 3131   op_cost(0);
 3132   format %{ %}
 3133   interface(CONST_INTER);
 3134 %}
 3135 
 3136 // Integer Immediate: 8-bit
 3137 operand immI8() %{
 3138   predicate(Assembler::is_simm8(n-&gt;get_int()));
 3139   match(ConI);
 3140   op_cost(0);
 3141   format %{ %}
 3142   interface(CONST_INTER);
 3143 %}
 3144 
 3145 // Integer Immediate: the value 10
 3146 operand immI10() %{
 3147   predicate(n-&gt;get_int() == 10);
 3148   match(ConI);
 3149   op_cost(0);
 3150 
 3151   format %{ %}
 3152   interface(CONST_INTER);
 3153 %}
 3154 
 3155 // Integer Immediate: 11-bit
 3156 operand immI11() %{
 3157   predicate(Assembler::is_simm11(n-&gt;get_int()));
 3158   match(ConI);
 3159   op_cost(0);
 3160   format %{ %}
 3161   interface(CONST_INTER);
 3162 %}
 3163 
 3164 // Integer Immediate: 13-bit
 3165 operand immI13() %{
 3166   predicate(Assembler::is_simm13(n-&gt;get_int()));
 3167   match(ConI);
 3168   op_cost(0);
 3169 
 3170   format %{ %}
 3171   interface(CONST_INTER);
 3172 %}
 3173 
 3174 // Integer Immediate: 13-bit minus 7
 3175 operand immI13m7() %{
 3176   predicate((-4096 &lt; n-&gt;get_int()) &amp;&amp; ((n-&gt;get_int() + 7) &lt;= 4095));
 3177   match(ConI);
 3178   op_cost(0);
 3179 
 3180   format %{ %}
 3181   interface(CONST_INTER);
 3182 %}
 3183 
 3184 // Integer Immediate: 16-bit
 3185 operand immI16() %{
 3186   predicate(Assembler::is_simm16(n-&gt;get_int()));
 3187   match(ConI);
 3188   op_cost(0);
 3189   format %{ %}
 3190   interface(CONST_INTER);
 3191 %}
 3192 
 3193 // Integer Immediate: the values 1-31
 3194 operand immI_1_31() %{
 3195   predicate(n-&gt;get_int() &gt;= 1 &amp;&amp; n-&gt;get_int() &lt;= 31);
 3196   match(ConI);
 3197   op_cost(0);
 3198 
 3199   format %{ %}
 3200   interface(CONST_INTER);
 3201 %}
 3202 
 3203 // Integer Immediate: the values 32-63
 3204 operand immI_32_63() %{
 3205   predicate(n-&gt;get_int() &gt;= 32 &amp;&amp; n-&gt;get_int() &lt;= 63);
 3206   match(ConI);
 3207   op_cost(0);
 3208 
 3209   format %{ %}
 3210   interface(CONST_INTER);
 3211 %}
 3212 
 3213 // Immediates for special shifts (sign extend)
 3214 
 3215 // Integer Immediate: the value 16
 3216 operand immI_16() %{
 3217   predicate(n-&gt;get_int() == 16);
 3218   match(ConI);
 3219   op_cost(0);
 3220 
 3221   format %{ %}
 3222   interface(CONST_INTER);
 3223 %}
 3224 
 3225 // Integer Immediate: the value 24
 3226 operand immI_24() %{
 3227   predicate(n-&gt;get_int() == 24);
 3228   match(ConI);
 3229   op_cost(0);
 3230 
 3231   format %{ %}
 3232   interface(CONST_INTER);
 3233 %}
 3234 // Integer Immediate: the value 255
 3235 operand immI_255() %{
 3236   predicate( n-&gt;get_int() == 255 );
 3237   match(ConI);
 3238   op_cost(0);
 3239 
 3240   format %{ %}
 3241   interface(CONST_INTER);
 3242 %}
 3243 
 3244 // Integer Immediate: the value 65535
 3245 operand immI_65535() %{
 3246   predicate(n-&gt;get_int() == 65535);
 3247   match(ConI);
 3248   op_cost(0);
 3249 
 3250   format %{ %}
 3251   interface(CONST_INTER);
 3252 %}
 3253 
 3254 // Integer Immediate: the values 0-31
 3255 operand immU5() %{
 3256   predicate(n-&gt;get_int() &gt;= 0 &amp;&amp; n-&gt;get_int() &lt;= 31);
 3257   match(ConI);
 3258   op_cost(0);
 3259 
 3260   format %{ %}
 3261   interface(CONST_INTER);
 3262 %}
 3263 
 3264 // Integer Immediate: 6-bit
 3265 operand immU6() %{
 3266   predicate(n-&gt;get_int() &gt;= 0 &amp;&amp; n-&gt;get_int() &lt;= 63);
 3267   match(ConI);
 3268   op_cost(0);
 3269   format %{ %}
 3270   interface(CONST_INTER);
 3271 %}
 3272 
 3273 // Unsigned Integer Immediate: 12-bit (non-negative that fits in simm13)
 3274 operand immU12() %{
 3275   predicate((0 &lt;= n-&gt;get_int()) &amp;&amp; Assembler::is_simm13(n-&gt;get_int()));
 3276   match(ConI);
 3277   op_cost(0);
 3278 
 3279   format %{ %}
 3280   interface(CONST_INTER);
 3281 %}
 3282 
 3283 // Unsigned Long Immediate: 12-bit (non-negative that fits in simm13)
 3284 operand immUL12() %{
 3285   predicate((0 &lt;= n-&gt;get_long()) &amp;&amp; (n-&gt;get_long() == (int)n-&gt;get_long()) &amp;&amp; Assembler::is_simm13((int)n-&gt;get_long()));
 3286   match(ConL);
 3287   op_cost(0);
 3288 
 3289   format %{ %}
 3290   interface(CONST_INTER);
 3291 %}
 3292 
 3293 // Integer Immediate non-negative
 3294 operand immU31()
 3295 %{
 3296   predicate(n-&gt;get_int() &gt;= 0);
 3297   match(ConI);
 3298 
 3299   op_cost(0);
 3300   format %{ %}
 3301   interface(CONST_INTER);
 3302 %}
 3303 
 3304 // Long Immediate: the value FF
 3305 operand immL_FF() %{
 3306   predicate( n-&gt;get_long() == 0xFFL );
 3307   match(ConL);
 3308   op_cost(0);
 3309 
 3310   format %{ %}
 3311   interface(CONST_INTER);
 3312 %}
 3313 
 3314 // Long Immediate: the value FFFF
 3315 operand immL_FFFF() %{
 3316   predicate( n-&gt;get_long() == 0xFFFFL );
 3317   match(ConL);
 3318   op_cost(0);
 3319 
 3320   format %{ %}
 3321   interface(CONST_INTER);
 3322 %}
 3323 
 3324 // Pointer Immediate: 32 or 64-bit
 3325 operand immP() %{
 3326   match(ConP);
 3327 
 3328   op_cost(5);
 3329   // formats are generated automatically for constants and base registers
 3330   format %{ %}
 3331   interface(CONST_INTER);
 3332 %}
 3333 
 3334 // Pointer Immediate: 64-bit
 3335 operand immP_set() %{
 3336   predicate(!VM_Version::has_fast_ld());
 3337   match(ConP);
 3338 
 3339   op_cost(5);
 3340   // formats are generated automatically for constants and base registers
 3341   format %{ %}
 3342   interface(CONST_INTER);
 3343 %}
 3344 
 3345 // Pointer Immediate: 64-bit
 3346 // From Niagara2 processors on a load should be better than materializing.
 3347 operand immP_load() %{
 3348   predicate(VM_Version::has_fast_ld() &amp;&amp; (n-&gt;bottom_type()-&gt;isa_oop_ptr() || (MacroAssembler::insts_for_set(n-&gt;get_ptr()) &gt; 3)));
 3349   match(ConP);
 3350 
 3351   op_cost(5);
 3352   // formats are generated automatically for constants and base registers
 3353   format %{ %}
 3354   interface(CONST_INTER);
 3355 %}
 3356 
 3357 // Pointer Immediate: 64-bit
 3358 operand immP_no_oop_cheap() %{
 3359   predicate(VM_Version::has_fast_ld() &amp;&amp; !n-&gt;bottom_type()-&gt;isa_oop_ptr() &amp;&amp; (MacroAssembler::insts_for_set(n-&gt;get_ptr()) &lt;= 3));
 3360   match(ConP);
 3361 
 3362   op_cost(5);
 3363   // formats are generated automatically for constants and base registers
 3364   format %{ %}
 3365   interface(CONST_INTER);
 3366 %}
 3367 
 3368 operand immP13() %{
 3369   predicate((-4096 &lt; n-&gt;get_ptr()) &amp;&amp; (n-&gt;get_ptr() &lt;= 4095));
 3370   match(ConP);
 3371   op_cost(0);
 3372 
 3373   format %{ %}
 3374   interface(CONST_INTER);
 3375 %}
 3376 
 3377 operand immP0() %{
 3378   predicate(n-&gt;get_ptr() == 0);
 3379   match(ConP);
 3380   op_cost(0);
 3381 
 3382   format %{ %}
 3383   interface(CONST_INTER);
 3384 %}
 3385 
<a name="80" id="anc80"></a>








 3386 // Pointer Immediate
 3387 operand immN()
 3388 %{
 3389   match(ConN);
 3390 
 3391   op_cost(10);
 3392   format %{ %}
 3393   interface(CONST_INTER);
 3394 %}
 3395 
 3396 operand immNKlass()
 3397 %{
 3398   match(ConNKlass);
 3399 
 3400   op_cost(10);
 3401   format %{ %}
 3402   interface(CONST_INTER);
 3403 %}
 3404 
 3405 // NULL Pointer Immediate
 3406 operand immN0()
 3407 %{
 3408   predicate(n-&gt;get_narrowcon() == 0);
 3409   match(ConN);
 3410 
 3411   op_cost(0);
 3412   format %{ %}
 3413   interface(CONST_INTER);
 3414 %}
 3415 
 3416 operand immL() %{
 3417   match(ConL);
 3418   op_cost(40);
 3419   // formats are generated automatically for constants and base registers
 3420   format %{ %}
 3421   interface(CONST_INTER);
 3422 %}
 3423 
 3424 operand immL0() %{
 3425   predicate(n-&gt;get_long() == 0L);
 3426   match(ConL);
 3427   op_cost(0);
 3428   // formats are generated automatically for constants and base registers
 3429   format %{ %}
 3430   interface(CONST_INTER);
 3431 %}
 3432 
 3433 // Integer Immediate: 5-bit
 3434 operand immL5() %{
 3435   predicate(n-&gt;get_long() == (int)n-&gt;get_long() &amp;&amp; Assembler::is_simm5((int)n-&gt;get_long()));
 3436   match(ConL);
 3437   op_cost(0);
 3438   format %{ %}
 3439   interface(CONST_INTER);
 3440 %}
 3441 
 3442 // Long Immediate: 13-bit
 3443 operand immL13() %{
 3444   predicate((-4096L &lt; n-&gt;get_long()) &amp;&amp; (n-&gt;get_long() &lt;= 4095L));
 3445   match(ConL);
 3446   op_cost(0);
 3447 
 3448   format %{ %}
 3449   interface(CONST_INTER);
 3450 %}
 3451 
 3452 // Long Immediate: 13-bit minus 7
 3453 operand immL13m7() %{
 3454   predicate((-4096L &lt; n-&gt;get_long()) &amp;&amp; ((n-&gt;get_long() + 7L) &lt;= 4095L));
 3455   match(ConL);
 3456   op_cost(0);
 3457 
 3458   format %{ %}
 3459   interface(CONST_INTER);
 3460 %}
 3461 
 3462 // Long Immediate: low 32-bit mask
 3463 operand immL_32bits() %{
 3464   predicate(n-&gt;get_long() == 0xFFFFFFFFL);
 3465   match(ConL);
 3466   op_cost(0);
 3467 
 3468   format %{ %}
 3469   interface(CONST_INTER);
 3470 %}
 3471 
 3472 // Long Immediate: cheap (materialize in &lt;= 3 instructions)
 3473 operand immL_cheap() %{
 3474   predicate(!VM_Version::has_fast_ld() || MacroAssembler::insts_for_set64(n-&gt;get_long()) &lt;= 3);
 3475   match(ConL);
 3476   op_cost(0);
 3477 
 3478   format %{ %}
 3479   interface(CONST_INTER);
 3480 %}
 3481 
 3482 // Long Immediate: expensive (materialize in &gt; 3 instructions)
 3483 operand immL_expensive() %{
 3484   predicate(VM_Version::has_fast_ld() &amp;&amp; MacroAssembler::insts_for_set64(n-&gt;get_long()) &gt; 3);
 3485   match(ConL);
 3486   op_cost(0);
 3487 
 3488   format %{ %}
 3489   interface(CONST_INTER);
 3490 %}
 3491 
 3492 // Double Immediate
 3493 operand immD() %{
 3494   match(ConD);
 3495 
 3496   op_cost(40);
 3497   format %{ %}
 3498   interface(CONST_INTER);
 3499 %}
 3500 
 3501 // Double Immediate: +0.0d
 3502 operand immD0() %{
 3503   predicate(jlong_cast(n-&gt;getd()) == 0);
 3504   match(ConD);
 3505 
 3506   op_cost(0);
 3507   format %{ %}
 3508   interface(CONST_INTER);
 3509 %}
 3510 
 3511 // Float Immediate
 3512 operand immF() %{
 3513   match(ConF);
 3514 
 3515   op_cost(20);
 3516   format %{ %}
 3517   interface(CONST_INTER);
 3518 %}
 3519 
 3520 // Float Immediate: +0.0f
 3521 operand immF0() %{
 3522   predicate(jint_cast(n-&gt;getf()) == 0);
 3523   match(ConF);
 3524 
 3525   op_cost(0);
 3526   format %{ %}
 3527   interface(CONST_INTER);
 3528 %}
 3529 
 3530 // Integer Register Operands
 3531 // Integer Register
 3532 operand iRegI() %{
 3533   constraint(ALLOC_IN_RC(int_reg));
 3534   match(RegI);
 3535 
 3536   match(notemp_iRegI);
 3537   match(g1RegI);
 3538   match(o0RegI);
 3539   match(iRegIsafe);
 3540 
 3541   format %{ %}
 3542   interface(REG_INTER);
 3543 %}
 3544 
 3545 operand notemp_iRegI() %{
 3546   constraint(ALLOC_IN_RC(notemp_int_reg));
 3547   match(RegI);
 3548 
 3549   match(o0RegI);
 3550 
 3551   format %{ %}
 3552   interface(REG_INTER);
 3553 %}
 3554 
 3555 operand o0RegI() %{
 3556   constraint(ALLOC_IN_RC(o0_regI));
 3557   match(iRegI);
 3558 
 3559   format %{ %}
 3560   interface(REG_INTER);
 3561 %}
 3562 
 3563 // Pointer Register
 3564 operand iRegP() %{
 3565   constraint(ALLOC_IN_RC(ptr_reg));
 3566   match(RegP);
 3567 
 3568   match(lock_ptr_RegP);
 3569   match(g1RegP);
 3570   match(g2RegP);
 3571   match(g3RegP);
 3572   match(g4RegP);
 3573   match(i0RegP);
 3574   match(o0RegP);
 3575   match(o1RegP);
 3576   match(l7RegP);
 3577 
 3578   format %{ %}
 3579   interface(REG_INTER);
 3580 %}
 3581 
 3582 operand sp_ptr_RegP() %{
 3583   constraint(ALLOC_IN_RC(sp_ptr_reg));
 3584   match(RegP);
 3585   match(iRegP);
 3586 
 3587   format %{ %}
 3588   interface(REG_INTER);
 3589 %}
 3590 
 3591 operand lock_ptr_RegP() %{
 3592   constraint(ALLOC_IN_RC(lock_ptr_reg));
 3593   match(RegP);
 3594   match(i0RegP);
 3595   match(o0RegP);
 3596   match(o1RegP);
 3597   match(l7RegP);
 3598 
 3599   format %{ %}
 3600   interface(REG_INTER);
 3601 %}
 3602 
 3603 operand g1RegP() %{
 3604   constraint(ALLOC_IN_RC(g1_regP));
 3605   match(iRegP);
 3606 
 3607   format %{ %}
 3608   interface(REG_INTER);
 3609 %}
 3610 
 3611 operand g2RegP() %{
 3612   constraint(ALLOC_IN_RC(g2_regP));
 3613   match(iRegP);
 3614 
 3615   format %{ %}
 3616   interface(REG_INTER);
 3617 %}
 3618 
 3619 operand g3RegP() %{
 3620   constraint(ALLOC_IN_RC(g3_regP));
 3621   match(iRegP);
 3622 
 3623   format %{ %}
 3624   interface(REG_INTER);
 3625 %}
 3626 
 3627 operand g1RegI() %{
 3628   constraint(ALLOC_IN_RC(g1_regI));
 3629   match(iRegI);
 3630 
 3631   format %{ %}
 3632   interface(REG_INTER);
 3633 %}
 3634 
 3635 operand g3RegI() %{
 3636   constraint(ALLOC_IN_RC(g3_regI));
 3637   match(iRegI);
 3638 
 3639   format %{ %}
 3640   interface(REG_INTER);
 3641 %}
 3642 
 3643 operand g4RegI() %{
 3644   constraint(ALLOC_IN_RC(g4_regI));
 3645   match(iRegI);
 3646 
 3647   format %{ %}
 3648   interface(REG_INTER);
 3649 %}
 3650 
 3651 operand g4RegP() %{
 3652   constraint(ALLOC_IN_RC(g4_regP));
 3653   match(iRegP);
 3654 
 3655   format %{ %}
 3656   interface(REG_INTER);
 3657 %}
 3658 
 3659 operand i0RegP() %{
 3660   constraint(ALLOC_IN_RC(i0_regP));
 3661   match(iRegP);
 3662 
 3663   format %{ %}
 3664   interface(REG_INTER);
 3665 %}
 3666 
 3667 operand o0RegP() %{
 3668   constraint(ALLOC_IN_RC(o0_regP));
 3669   match(iRegP);
 3670 
 3671   format %{ %}
 3672   interface(REG_INTER);
 3673 %}
 3674 
 3675 operand o1RegP() %{
 3676   constraint(ALLOC_IN_RC(o1_regP));
 3677   match(iRegP);
 3678 
 3679   format %{ %}
 3680   interface(REG_INTER);
 3681 %}
 3682 
 3683 operand o2RegP() %{
 3684   constraint(ALLOC_IN_RC(o2_regP));
 3685   match(iRegP);
 3686 
 3687   format %{ %}
 3688   interface(REG_INTER);
 3689 %}
 3690 
 3691 operand o7RegP() %{
 3692   constraint(ALLOC_IN_RC(o7_regP));
 3693   match(iRegP);
 3694 
 3695   format %{ %}
 3696   interface(REG_INTER);
 3697 %}
 3698 
 3699 operand l7RegP() %{
 3700   constraint(ALLOC_IN_RC(l7_regP));
 3701   match(iRegP);
 3702 
 3703   format %{ %}
 3704   interface(REG_INTER);
 3705 %}
 3706 
 3707 operand o7RegI() %{
 3708   constraint(ALLOC_IN_RC(o7_regI));
 3709   match(iRegI);
 3710 
 3711   format %{ %}
 3712   interface(REG_INTER);
 3713 %}
 3714 
 3715 operand iRegN() %{
 3716   constraint(ALLOC_IN_RC(int_reg));
 3717   match(RegN);
 3718 
 3719   format %{ %}
 3720   interface(REG_INTER);
 3721 %}
 3722 
 3723 // Long Register
 3724 operand iRegL() %{
 3725   constraint(ALLOC_IN_RC(long_reg));
 3726   match(RegL);
 3727 
 3728   format %{ %}
 3729   interface(REG_INTER);
 3730 %}
 3731 
 3732 operand o2RegL() %{
 3733   constraint(ALLOC_IN_RC(o2_regL));
 3734   match(iRegL);
 3735 
 3736   format %{ %}
 3737   interface(REG_INTER);
 3738 %}
 3739 
 3740 operand o7RegL() %{
 3741   constraint(ALLOC_IN_RC(o7_regL));
 3742   match(iRegL);
 3743 
 3744   format %{ %}
 3745   interface(REG_INTER);
 3746 %}
 3747 
 3748 operand g1RegL() %{
 3749   constraint(ALLOC_IN_RC(g1_regL));
 3750   match(iRegL);
 3751 
 3752   format %{ %}
 3753   interface(REG_INTER);
 3754 %}
 3755 
 3756 operand g3RegL() %{
 3757   constraint(ALLOC_IN_RC(g3_regL));
 3758   match(iRegL);
 3759 
 3760   format %{ %}
 3761   interface(REG_INTER);
 3762 %}
 3763 
 3764 // Int Register safe
 3765 // This is 64bit safe
 3766 operand iRegIsafe() %{
 3767   constraint(ALLOC_IN_RC(long_reg));
 3768 
 3769   match(iRegI);
 3770 
 3771   format %{ %}
 3772   interface(REG_INTER);
 3773 %}
 3774 
 3775 // Condition Code Flag Register
 3776 operand flagsReg() %{
 3777   constraint(ALLOC_IN_RC(int_flags));
 3778   match(RegFlags);
 3779 
 3780   format %{ &quot;ccr&quot; %} // both ICC and XCC
 3781   interface(REG_INTER);
 3782 %}
 3783 
 3784 // Condition Code Register, unsigned comparisons.
 3785 operand flagsRegU() %{
 3786   constraint(ALLOC_IN_RC(int_flags));
 3787   match(RegFlags);
 3788 
 3789   format %{ &quot;icc_U&quot; %}
 3790   interface(REG_INTER);
 3791 %}
 3792 
 3793 // Condition Code Register, pointer comparisons.
 3794 operand flagsRegP() %{
 3795   constraint(ALLOC_IN_RC(int_flags));
 3796   match(RegFlags);
 3797 
 3798   format %{ &quot;xcc_P&quot; %}
 3799   interface(REG_INTER);
 3800 %}
 3801 
 3802 // Condition Code Register, long comparisons.
 3803 operand flagsRegL() %{
 3804   constraint(ALLOC_IN_RC(int_flags));
 3805   match(RegFlags);
 3806 
 3807   format %{ &quot;xcc_L&quot; %}
 3808   interface(REG_INTER);
 3809 %}
 3810 
 3811 // Condition Code Register, unsigned long comparisons.
 3812 operand flagsRegUL() %{
 3813   constraint(ALLOC_IN_RC(int_flags));
 3814   match(RegFlags);
 3815 
 3816   format %{ &quot;xcc_UL&quot; %}
 3817   interface(REG_INTER);
 3818 %}
 3819 
 3820 // Condition Code Register, floating comparisons, unordered same as &quot;less&quot;.
 3821 operand flagsRegF() %{
 3822   constraint(ALLOC_IN_RC(float_flags));
 3823   match(RegFlags);
 3824   match(flagsRegF0);
 3825 
 3826   format %{ %}
 3827   interface(REG_INTER);
 3828 %}
 3829 
 3830 operand flagsRegF0() %{
 3831   constraint(ALLOC_IN_RC(float_flag0));
 3832   match(RegFlags);
 3833 
 3834   format %{ %}
 3835   interface(REG_INTER);
 3836 %}
 3837 
 3838 
 3839 // Condition Code Flag Register used by long compare
 3840 operand flagsReg_long_LTGE() %{
 3841   constraint(ALLOC_IN_RC(int_flags));
 3842   match(RegFlags);
 3843   format %{ &quot;icc_LTGE&quot; %}
 3844   interface(REG_INTER);
 3845 %}
 3846 operand flagsReg_long_EQNE() %{
 3847   constraint(ALLOC_IN_RC(int_flags));
 3848   match(RegFlags);
 3849   format %{ &quot;icc_EQNE&quot; %}
 3850   interface(REG_INTER);
 3851 %}
 3852 operand flagsReg_long_LEGT() %{
 3853   constraint(ALLOC_IN_RC(int_flags));
 3854   match(RegFlags);
 3855   format %{ &quot;icc_LEGT&quot; %}
 3856   interface(REG_INTER);
 3857 %}
 3858 
 3859 
 3860 operand regD() %{
 3861   constraint(ALLOC_IN_RC(dflt_reg));
 3862   match(RegD);
 3863 
 3864   match(regD_low);
 3865 
 3866   format %{ %}
 3867   interface(REG_INTER);
 3868 %}
 3869 
 3870 operand regF() %{
 3871   constraint(ALLOC_IN_RC(sflt_reg));
 3872   match(RegF);
 3873 
 3874   format %{ %}
 3875   interface(REG_INTER);
 3876 %}
 3877 
 3878 operand regD_low() %{
 3879   constraint(ALLOC_IN_RC(dflt_low_reg));
 3880   match(regD);
 3881 
 3882   format %{ %}
 3883   interface(REG_INTER);
 3884 %}
 3885 
 3886 // Special Registers
 3887 
 3888 // Method Register
 3889 operand inline_cache_regP(iRegP reg) %{
 3890   constraint(ALLOC_IN_RC(g5_regP)); // G5=inline_cache_reg but uses 2 bits instead of 1
 3891   match(reg);
 3892   format %{ %}
 3893   interface(REG_INTER);
 3894 %}
 3895 
 3896 operand interpreter_method_oop_regP(iRegP reg) %{
 3897   constraint(ALLOC_IN_RC(g5_regP)); // G5=interpreter_method_oop_reg but uses 2 bits instead of 1
 3898   match(reg);
 3899   format %{ %}
 3900   interface(REG_INTER);
 3901 %}
 3902 
 3903 
 3904 //----------Complex Operands---------------------------------------------------
 3905 // Indirect Memory Reference
 3906 operand indirect(sp_ptr_RegP reg) %{
 3907   constraint(ALLOC_IN_RC(sp_ptr_reg));
 3908   match(reg);
 3909 
 3910   op_cost(100);
 3911   format %{ &quot;[$reg]&quot; %}
 3912   interface(MEMORY_INTER) %{
 3913     base($reg);
 3914     index(0x0);
 3915     scale(0x0);
 3916     disp(0x0);
 3917   %}
 3918 %}
 3919 
 3920 // Indirect with simm13 Offset
 3921 operand indOffset13(sp_ptr_RegP reg, immX13 offset) %{
 3922   constraint(ALLOC_IN_RC(sp_ptr_reg));
 3923   match(AddP reg offset);
 3924 
 3925   op_cost(100);
 3926   format %{ &quot;[$reg + $offset]&quot; %}
 3927   interface(MEMORY_INTER) %{
 3928     base($reg);
 3929     index(0x0);
 3930     scale(0x0);
 3931     disp($offset);
 3932   %}
 3933 %}
 3934 
 3935 // Indirect with simm13 Offset minus 7
 3936 operand indOffset13m7(sp_ptr_RegP reg, immX13m7 offset) %{
 3937   constraint(ALLOC_IN_RC(sp_ptr_reg));
 3938   match(AddP reg offset);
 3939 
 3940   op_cost(100);
 3941   format %{ &quot;[$reg + $offset]&quot; %}
 3942   interface(MEMORY_INTER) %{
 3943     base($reg);
 3944     index(0x0);
 3945     scale(0x0);
 3946     disp($offset);
 3947   %}
 3948 %}
 3949 
 3950 // Note:  Intel has a swapped version also, like this:
 3951 //operand indOffsetX(iRegI reg, immP offset) %{
 3952 //  constraint(ALLOC_IN_RC(int_reg));
 3953 //  match(AddP offset reg);
 3954 //
 3955 //  op_cost(100);
 3956 //  format %{ &quot;[$reg + $offset]&quot; %}
 3957 //  interface(MEMORY_INTER) %{
 3958 //    base($reg);
 3959 //    index(0x0);
 3960 //    scale(0x0);
 3961 //    disp($offset);
 3962 //  %}
 3963 //%}
 3964 //// However, it doesn&#39;t make sense for SPARC, since
 3965 // we have no particularly good way to embed oops in
 3966 // single instructions.
 3967 
 3968 // Indirect with Register Index
 3969 operand indIndex(iRegP addr, iRegX index) %{
 3970   constraint(ALLOC_IN_RC(ptr_reg));
 3971   match(AddP addr index);
 3972 
 3973   op_cost(100);
 3974   format %{ &quot;[$addr + $index]&quot; %}
 3975   interface(MEMORY_INTER) %{
 3976     base($addr);
 3977     index($index);
 3978     scale(0x0);
 3979     disp(0x0);
 3980   %}
 3981 %}
 3982 
 3983 //----------Special Memory Operands--------------------------------------------
 3984 // Stack Slot Operand - This operand is used for loading and storing temporary
 3985 //                      values on the stack where a match requires a value to
 3986 //                      flow through memory.
 3987 operand stackSlotI(sRegI reg) %{
 3988   constraint(ALLOC_IN_RC(stack_slots));
 3989   op_cost(100);
 3990   //match(RegI);
 3991   format %{ &quot;[$reg]&quot; %}
 3992   interface(MEMORY_INTER) %{
 3993     base(0xE);   // R_SP
 3994     index(0x0);
 3995     scale(0x0);
 3996     disp($reg);  // Stack Offset
 3997   %}
 3998 %}
 3999 
 4000 operand stackSlotP(sRegP reg) %{
 4001   constraint(ALLOC_IN_RC(stack_slots));
 4002   op_cost(100);
 4003   //match(RegP);
 4004   format %{ &quot;[$reg]&quot; %}
 4005   interface(MEMORY_INTER) %{
 4006     base(0xE);   // R_SP
 4007     index(0x0);
 4008     scale(0x0);
 4009     disp($reg);  // Stack Offset
 4010   %}
 4011 %}
 4012 
 4013 operand stackSlotF(sRegF reg) %{
 4014   constraint(ALLOC_IN_RC(stack_slots));
 4015   op_cost(100);
 4016   //match(RegF);
 4017   format %{ &quot;[$reg]&quot; %}
 4018   interface(MEMORY_INTER) %{
 4019     base(0xE);   // R_SP
 4020     index(0x0);
 4021     scale(0x0);
 4022     disp($reg);  // Stack Offset
 4023   %}
 4024 %}
 4025 operand stackSlotD(sRegD reg) %{
 4026   constraint(ALLOC_IN_RC(stack_slots));
 4027   op_cost(100);
 4028   //match(RegD);
 4029   format %{ &quot;[$reg]&quot; %}
 4030   interface(MEMORY_INTER) %{
 4031     base(0xE);   // R_SP
 4032     index(0x0);
 4033     scale(0x0);
 4034     disp($reg);  // Stack Offset
 4035   %}
 4036 %}
 4037 operand stackSlotL(sRegL reg) %{
 4038   constraint(ALLOC_IN_RC(stack_slots));
 4039   op_cost(100);
 4040   //match(RegL);
 4041   format %{ &quot;[$reg]&quot; %}
 4042   interface(MEMORY_INTER) %{
 4043     base(0xE);   // R_SP
 4044     index(0x0);
 4045     scale(0x0);
 4046     disp($reg);  // Stack Offset
 4047   %}
 4048 %}
 4049 
 4050 // Operands for expressing Control Flow
 4051 // NOTE:  Label is a predefined operand which should not be redefined in
 4052 //        the AD file.  It is generically handled within the ADLC.
 4053 
 4054 //----------Conditional Branch Operands----------------------------------------
 4055 // Comparison Op  - This is the operation of the comparison, and is limited to
 4056 //                  the following set of codes:
 4057 //                  L (&lt;), LE (&lt;=), G (&gt;), GE (&gt;=), E (==), NE (!=)
 4058 //
 4059 // Other attributes of the comparison, such as unsignedness, are specified
 4060 // by the comparison instruction that sets a condition code flags register.
 4061 // That result is represented by a flags operand whose subtype is appropriate
 4062 // to the unsignedness (etc.) of the comparison.
 4063 //
 4064 // Later, the instruction which matches both the Comparison Op (a Bool) and
 4065 // the flags (produced by the Cmp) specifies the coding of the comparison op
 4066 // by matching a specific subtype of Bool operand below, such as cmpOpU.
 4067 
 4068 operand cmpOp() %{
 4069   match(Bool);
 4070 
 4071   format %{ &quot;&quot; %}
 4072   interface(COND_INTER) %{
 4073     equal(0x1);
 4074     not_equal(0x9);
 4075     less(0x3);
 4076     greater_equal(0xB);
 4077     less_equal(0x2);
 4078     greater(0xA);
 4079     overflow(0x7);
 4080     no_overflow(0xF);
 4081   %}
 4082 %}
 4083 
 4084 // Comparison Op, unsigned
 4085 operand cmpOpU() %{
 4086   match(Bool);
 4087   predicate(n-&gt;as_Bool()-&gt;_test._test != BoolTest::overflow &amp;&amp;
 4088             n-&gt;as_Bool()-&gt;_test._test != BoolTest::no_overflow);
 4089 
 4090   format %{ &quot;u&quot; %}
 4091   interface(COND_INTER) %{
 4092     equal(0x1);
 4093     not_equal(0x9);
 4094     less(0x5);
 4095     greater_equal(0xD);
 4096     less_equal(0x4);
 4097     greater(0xC);
 4098     overflow(0x7);
 4099     no_overflow(0xF);
 4100   %}
 4101 %}
 4102 
 4103 // Comparison Op, pointer (same as unsigned)
 4104 operand cmpOpP() %{
 4105   match(Bool);
 4106   predicate(n-&gt;as_Bool()-&gt;_test._test != BoolTest::overflow &amp;&amp;
 4107             n-&gt;as_Bool()-&gt;_test._test != BoolTest::no_overflow);
 4108 
 4109   format %{ &quot;p&quot; %}
 4110   interface(COND_INTER) %{
 4111     equal(0x1);
 4112     not_equal(0x9);
 4113     less(0x5);
 4114     greater_equal(0xD);
 4115     less_equal(0x4);
 4116     greater(0xC);
 4117     overflow(0x7);
 4118     no_overflow(0xF);
 4119   %}
 4120 %}
 4121 
 4122 // Comparison Op, branch-register encoding
 4123 operand cmpOp_reg() %{
 4124   match(Bool);
 4125   predicate(n-&gt;as_Bool()-&gt;_test._test != BoolTest::overflow &amp;&amp;
 4126             n-&gt;as_Bool()-&gt;_test._test != BoolTest::no_overflow);
 4127 
 4128   format %{ &quot;&quot; %}
 4129   interface(COND_INTER) %{
 4130     equal        (0x1);
 4131     not_equal    (0x5);
 4132     less         (0x3);
 4133     greater_equal(0x7);
 4134     less_equal   (0x2);
 4135     greater      (0x6);
 4136     overflow(0x7); // not supported
 4137     no_overflow(0xF); // not supported
 4138   %}
 4139 %}
 4140 
 4141 // Comparison Code, floating, unordered same as less
 4142 operand cmpOpF() %{
 4143   match(Bool);
 4144   predicate(n-&gt;as_Bool()-&gt;_test._test != BoolTest::overflow &amp;&amp;
 4145             n-&gt;as_Bool()-&gt;_test._test != BoolTest::no_overflow);
 4146 
 4147   format %{ &quot;fl&quot; %}
 4148   interface(COND_INTER) %{
 4149     equal(0x9);
 4150     not_equal(0x1);
 4151     less(0x3);
 4152     greater_equal(0xB);
 4153     less_equal(0xE);
 4154     greater(0x6);
 4155 
 4156     overflow(0x7); // not supported
 4157     no_overflow(0xF); // not supported
 4158   %}
 4159 %}
 4160 
 4161 // Used by long compare
 4162 operand cmpOp_commute() %{
 4163   match(Bool);
 4164   predicate(n-&gt;as_Bool()-&gt;_test._test != BoolTest::overflow &amp;&amp;
 4165             n-&gt;as_Bool()-&gt;_test._test != BoolTest::no_overflow);
 4166 
 4167   format %{ &quot;&quot; %}
 4168   interface(COND_INTER) %{
 4169     equal(0x1);
 4170     not_equal(0x9);
 4171     less(0xA);
 4172     greater_equal(0x2);
 4173     less_equal(0xB);
 4174     greater(0x3);
 4175     overflow(0x7);
 4176     no_overflow(0xF);
 4177   %}
 4178 %}
 4179 
 4180 //----------OPERAND CLASSES----------------------------------------------------
 4181 // Operand Classes are groups of operands that are used to simplify
 4182 // instruction definitions by not requiring the AD writer to specify separate
 4183 // instructions for every form of operand when the instruction accepts
 4184 // multiple operand types with the same basic encoding and format.  The classic
 4185 // case of this is memory operands.
 4186 opclass memory( indirect, indOffset13, indIndex );
 4187 opclass indIndexMemory( indIndex );
 4188 
 4189 //----------PIPELINE-----------------------------------------------------------
 4190 pipeline %{
 4191 
 4192 //----------ATTRIBUTES---------------------------------------------------------
 4193 attributes %{
 4194   fixed_size_instructions;           // Fixed size instructions
 4195   branch_has_delay_slot;             // Branch has delay slot following
 4196   max_instructions_per_bundle = 4;   // Up to 4 instructions per bundle
 4197   instruction_unit_size = 4;         // An instruction is 4 bytes long
 4198   instruction_fetch_unit_size = 16;  // The processor fetches one line
 4199   instruction_fetch_units = 1;       // of 16 bytes
 4200 
 4201   // List of nop instructions
 4202   nops( Nop_A0, Nop_A1, Nop_MS, Nop_FA, Nop_BR );
 4203 %}
 4204 
 4205 //----------RESOURCES----------------------------------------------------------
 4206 // Resources are the functional units available to the machine
 4207 resources(A0, A1, MS, BR, FA, FM, IDIV, FDIV, IALU = A0 | A1);
 4208 
 4209 //----------PIPELINE DESCRIPTION-----------------------------------------------
 4210 // Pipeline Description specifies the stages in the machine&#39;s pipeline
 4211 
 4212 pipe_desc(A, P, F, B, I, J, S, R, E, C, M, W, X, T, D);
 4213 
 4214 //----------PIPELINE CLASSES---------------------------------------------------
 4215 // Pipeline Classes describe the stages in which input and output are
 4216 // referenced by the hardware pipeline.
 4217 
 4218 // Integer ALU reg-reg operation
 4219 pipe_class ialu_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
 4220     single_instruction;
 4221     dst   : E(write);
 4222     src1  : R(read);
 4223     src2  : R(read);
 4224     IALU  : R;
 4225 %}
 4226 
 4227 // Integer ALU reg-reg long operation
 4228 pipe_class ialu_reg_reg_2(iRegL dst, iRegL src1, iRegL src2) %{
 4229     instruction_count(2);
 4230     dst   : E(write);
 4231     src1  : R(read);
 4232     src2  : R(read);
 4233     IALU  : R;
 4234     IALU  : R;
 4235 %}
 4236 
 4237 // Integer ALU reg-reg long dependent operation
 4238 pipe_class ialu_reg_reg_2_dep(iRegL dst, iRegL src1, iRegL src2, flagsReg cr) %{
 4239     instruction_count(1); multiple_bundles;
 4240     dst   : E(write);
 4241     src1  : R(read);
 4242     src2  : R(read);
 4243     cr    : E(write);
 4244     IALU  : R(2);
 4245 %}
 4246 
 4247 // Integer ALU reg-imm operaion
 4248 pipe_class ialu_reg_imm(iRegI dst, iRegI src1, immI13 src2) %{
 4249     single_instruction;
 4250     dst   : E(write);
 4251     src1  : R(read);
 4252     IALU  : R;
 4253 %}
 4254 
 4255 // Integer ALU reg-reg operation with condition code
 4256 pipe_class ialu_cc_reg_reg(iRegI dst, iRegI src1, iRegI src2, flagsReg cr) %{
 4257     single_instruction;
 4258     dst   : E(write);
 4259     cr    : E(write);
 4260     src1  : R(read);
 4261     src2  : R(read);
 4262     IALU  : R;
 4263 %}
 4264 
 4265 // Integer ALU reg-imm operation with condition code
 4266 pipe_class ialu_cc_reg_imm(iRegI dst, iRegI src1, immI13 src2, flagsReg cr) %{
 4267     single_instruction;
 4268     dst   : E(write);
 4269     cr    : E(write);
 4270     src1  : R(read);
 4271     IALU  : R;
 4272 %}
 4273 
 4274 // Integer ALU zero-reg operation
 4275 pipe_class ialu_zero_reg(iRegI dst, immI0 zero, iRegI src2) %{
 4276     single_instruction;
 4277     dst   : E(write);
 4278     src2  : R(read);
 4279     IALU  : R;
 4280 %}
 4281 
 4282 // Integer ALU zero-reg operation with condition code only
 4283 pipe_class ialu_cconly_zero_reg(flagsReg cr, iRegI src) %{
 4284     single_instruction;
 4285     cr    : E(write);
 4286     src   : R(read);
 4287     IALU  : R;
 4288 %}
 4289 
 4290 // Integer ALU reg-reg operation with condition code only
 4291 pipe_class ialu_cconly_reg_reg(flagsReg cr, iRegI src1, iRegI src2) %{
 4292     single_instruction;
 4293     cr    : E(write);
 4294     src1  : R(read);
 4295     src2  : R(read);
 4296     IALU  : R;
 4297 %}
 4298 
 4299 // Integer ALU reg-imm operation with condition code only
 4300 pipe_class ialu_cconly_reg_imm(flagsReg cr, iRegI src1, immI13 src2) %{
 4301     single_instruction;
 4302     cr    : E(write);
 4303     src1  : R(read);
 4304     IALU  : R;
 4305 %}
 4306 
 4307 // Integer ALU reg-reg-zero operation with condition code only
 4308 pipe_class ialu_cconly_reg_reg_zero(flagsReg cr, iRegI src1, iRegI src2, immI0 zero) %{
 4309     single_instruction;
 4310     cr    : E(write);
 4311     src1  : R(read);
 4312     src2  : R(read);
 4313     IALU  : R;
 4314 %}
 4315 
 4316 // Integer ALU reg-imm-zero operation with condition code only
 4317 pipe_class ialu_cconly_reg_imm_zero(flagsReg cr, iRegI src1, immI13 src2, immI0 zero) %{
 4318     single_instruction;
 4319     cr    : E(write);
 4320     src1  : R(read);
 4321     IALU  : R;
 4322 %}
 4323 
 4324 // Integer ALU reg-reg operation with condition code, src1 modified
 4325 pipe_class ialu_cc_rwreg_reg(flagsReg cr, iRegI src1, iRegI src2) %{
 4326     single_instruction;
 4327     cr    : E(write);
 4328     src1  : E(write);
 4329     src1  : R(read);
 4330     src2  : R(read);
 4331     IALU  : R;
 4332 %}
 4333 
 4334 // Integer ALU reg-imm operation with condition code, src1 modified
 4335 pipe_class ialu_cc_rwreg_imm(flagsReg cr, iRegI src1, immI13 src2) %{
 4336     single_instruction;
 4337     cr    : E(write);
 4338     src1  : E(write);
 4339     src1  : R(read);
 4340     IALU  : R;
 4341 %}
 4342 
 4343 pipe_class cmpL_reg(iRegI dst, iRegL src1, iRegL src2, flagsReg cr ) %{
 4344     multiple_bundles;
 4345     dst   : E(write)+4;
 4346     cr    : E(write);
 4347     src1  : R(read);
 4348     src2  : R(read);
 4349     IALU  : R(3);
 4350     BR    : R(2);
 4351 %}
 4352 
 4353 // Integer ALU operation
 4354 pipe_class ialu_none(iRegI dst) %{
 4355     single_instruction;
 4356     dst   : E(write);
 4357     IALU  : R;
 4358 %}
 4359 
 4360 // Integer ALU reg operation
 4361 pipe_class ialu_reg(iRegI dst, iRegI src) %{
 4362     single_instruction; may_have_no_code;
 4363     dst   : E(write);
 4364     src   : R(read);
 4365     IALU  : R;
 4366 %}
 4367 
 4368 // Integer ALU reg conditional operation
 4369 // This instruction has a 1 cycle stall, and cannot execute
 4370 // in the same cycle as the instruction setting the condition
 4371 // code. We kludge this by pretending to read the condition code
 4372 // 1 cycle earlier, and by marking the functional units as busy
 4373 // for 2 cycles with the result available 1 cycle later than
 4374 // is really the case.
 4375 pipe_class ialu_reg_flags( iRegI op2_out, iRegI op2_in, iRegI op1, flagsReg cr ) %{
 4376     single_instruction;
 4377     op2_out : C(write);
 4378     op1     : R(read);
 4379     cr      : R(read);       // This is really E, with a 1 cycle stall
 4380     BR      : R(2);
 4381     MS      : R(2);
 4382 %}
 4383 
 4384 pipe_class ialu_clr_and_mover( iRegI dst, iRegP src ) %{
 4385     instruction_count(1); multiple_bundles;
 4386     dst     : C(write)+1;
 4387     src     : R(read)+1;
 4388     IALU    : R(1);
 4389     BR      : E(2);
 4390     MS      : E(2);
 4391 %}
 4392 
 4393 // Integer ALU reg operation
 4394 pipe_class ialu_move_reg_L_to_I(iRegI dst, iRegL src) %{
 4395     single_instruction; may_have_no_code;
 4396     dst   : E(write);
 4397     src   : R(read);
 4398     IALU  : R;
 4399 %}
 4400 pipe_class ialu_move_reg_I_to_L(iRegL dst, iRegI src) %{
 4401     single_instruction; may_have_no_code;
 4402     dst   : E(write);
 4403     src   : R(read);
 4404     IALU  : R;
 4405 %}
 4406 
 4407 // Two integer ALU reg operations
 4408 pipe_class ialu_reg_2(iRegL dst, iRegL src) %{
 4409     instruction_count(2);
 4410     dst   : E(write);
 4411     src   : R(read);
 4412     A0    : R;
 4413     A1    : R;
 4414 %}
 4415 
 4416 // Two integer ALU reg operations
 4417 pipe_class ialu_move_reg_L_to_L(iRegL dst, iRegL src) %{
 4418     instruction_count(2); may_have_no_code;
 4419     dst   : E(write);
 4420     src   : R(read);
 4421     A0    : R;
 4422     A1    : R;
 4423 %}
 4424 
 4425 // Integer ALU imm operation
 4426 pipe_class ialu_imm(iRegI dst, immI13 src) %{
 4427     single_instruction;
 4428     dst   : E(write);
 4429     IALU  : R;
 4430 %}
 4431 
 4432 // Integer ALU reg-reg with carry operation
 4433 pipe_class ialu_reg_reg_cy(iRegI dst, iRegI src1, iRegI src2, iRegI cy) %{
 4434     single_instruction;
 4435     dst   : E(write);
 4436     src1  : R(read);
 4437     src2  : R(read);
 4438     IALU  : R;
 4439 %}
 4440 
 4441 // Integer ALU cc operation
 4442 pipe_class ialu_cc(iRegI dst, flagsReg cc) %{
 4443     single_instruction;
 4444     dst   : E(write);
 4445     cc    : R(read);
 4446     IALU  : R;
 4447 %}
 4448 
 4449 // Integer ALU cc / second IALU operation
 4450 pipe_class ialu_reg_ialu( iRegI dst, iRegI src ) %{
 4451     instruction_count(1); multiple_bundles;
 4452     dst   : E(write)+1;
 4453     src   : R(read);
 4454     IALU  : R;
 4455 %}
 4456 
 4457 // Integer ALU cc / second IALU operation
 4458 pipe_class ialu_reg_reg_ialu( iRegI dst, iRegI p, iRegI q ) %{
 4459     instruction_count(1); multiple_bundles;
 4460     dst   : E(write)+1;
 4461     p     : R(read);
 4462     q     : R(read);
 4463     IALU  : R;
 4464 %}
 4465 
 4466 // Integer ALU hi-lo-reg operation
 4467 pipe_class ialu_hi_lo_reg(iRegI dst, immI src) %{
 4468     instruction_count(1); multiple_bundles;
 4469     dst   : E(write)+1;
 4470     IALU  : R(2);
 4471 %}
 4472 
 4473 // Float ALU hi-lo-reg operation (with temp)
 4474 pipe_class ialu_hi_lo_reg_temp(regF dst, immF src, g3RegP tmp) %{
 4475     instruction_count(1); multiple_bundles;
 4476     dst   : E(write)+1;
 4477     IALU  : R(2);
 4478 %}
 4479 
 4480 // Long Constant
 4481 pipe_class loadConL( iRegL dst, immL src ) %{
 4482     instruction_count(2); multiple_bundles;
 4483     dst   : E(write)+1;
 4484     IALU  : R(2);
 4485     IALU  : R(2);
 4486 %}
 4487 
 4488 // Pointer Constant
 4489 pipe_class loadConP( iRegP dst, immP src ) %{
 4490     instruction_count(0); multiple_bundles;
 4491     fixed_latency(6);
 4492 %}
 4493 
<a name="81" id="anc81"></a>





 4494 // Long Constant small
 4495 pipe_class loadConLlo( iRegL dst, immL src ) %{
 4496     instruction_count(2);
 4497     dst   : E(write);
 4498     IALU  : R;
 4499     IALU  : R;
 4500 %}
 4501 
 4502 // [PHH] This is wrong for 64-bit.  See LdImmF/D.
 4503 pipe_class loadConFD(regF dst, immF src, g3RegP tmp) %{
 4504     instruction_count(1); multiple_bundles;
 4505     src   : R(read);
 4506     dst   : M(write)+1;
 4507     IALU  : R;
 4508     MS    : E;
 4509 %}
 4510 
 4511 // Integer ALU nop operation
 4512 pipe_class ialu_nop() %{
 4513     single_instruction;
 4514     IALU  : R;
 4515 %}
 4516 
 4517 // Integer ALU nop operation
 4518 pipe_class ialu_nop_A0() %{
 4519     single_instruction;
 4520     A0    : R;
 4521 %}
 4522 
 4523 // Integer ALU nop operation
 4524 pipe_class ialu_nop_A1() %{
 4525     single_instruction;
 4526     A1    : R;
 4527 %}
 4528 
 4529 // Integer Multiply reg-reg operation
 4530 pipe_class imul_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
 4531     single_instruction;
 4532     dst   : E(write);
 4533     src1  : R(read);
 4534     src2  : R(read);
 4535     MS    : R(5);
 4536 %}
 4537 
 4538 // Integer Multiply reg-imm operation
 4539 pipe_class imul_reg_imm(iRegI dst, iRegI src1, immI13 src2) %{
 4540     single_instruction;
 4541     dst   : E(write);
 4542     src1  : R(read);
 4543     MS    : R(5);
 4544 %}
 4545 
 4546 pipe_class mulL_reg_reg(iRegL dst, iRegL src1, iRegL src2) %{
 4547     single_instruction;
 4548     dst   : E(write)+4;
 4549     src1  : R(read);
 4550     src2  : R(read);
 4551     MS    : R(6);
 4552 %}
 4553 
 4554 pipe_class mulL_reg_imm(iRegL dst, iRegL src1, immL13 src2) %{
 4555     single_instruction;
 4556     dst   : E(write)+4;
 4557     src1  : R(read);
 4558     MS    : R(6);
 4559 %}
 4560 
 4561 // Integer Divide reg-reg
 4562 pipe_class sdiv_reg_reg(iRegI dst, iRegI src1, iRegI src2, iRegI temp, flagsReg cr) %{
 4563     instruction_count(1); multiple_bundles;
 4564     dst   : E(write);
 4565     temp  : E(write);
 4566     src1  : R(read);
 4567     src2  : R(read);
 4568     temp  : R(read);
 4569     MS    : R(38);
 4570 %}
 4571 
 4572 // Integer Divide reg-imm
 4573 pipe_class sdiv_reg_imm(iRegI dst, iRegI src1, immI13 src2, iRegI temp, flagsReg cr) %{
 4574     instruction_count(1); multiple_bundles;
 4575     dst   : E(write);
 4576     temp  : E(write);
 4577     src1  : R(read);
 4578     temp  : R(read);
 4579     MS    : R(38);
 4580 %}
 4581 
 4582 // Long Divide
 4583 pipe_class divL_reg_reg(iRegL dst, iRegL src1, iRegL src2) %{
 4584     dst  : E(write)+71;
 4585     src1 : R(read);
 4586     src2 : R(read)+1;
 4587     MS   : R(70);
 4588 %}
 4589 
 4590 pipe_class divL_reg_imm(iRegL dst, iRegL src1, immL13 src2) %{
 4591     dst  : E(write)+71;
 4592     src1 : R(read);
 4593     MS   : R(70);
 4594 %}
 4595 
 4596 // Floating Point Add Float
 4597 pipe_class faddF_reg_reg(regF dst, regF src1, regF src2) %{
 4598     single_instruction;
 4599     dst   : X(write);
 4600     src1  : E(read);
 4601     src2  : E(read);
 4602     FA    : R;
 4603 %}
 4604 
 4605 // Floating Point Add Double
 4606 pipe_class faddD_reg_reg(regD dst, regD src1, regD src2) %{
 4607     single_instruction;
 4608     dst   : X(write);
 4609     src1  : E(read);
 4610     src2  : E(read);
 4611     FA    : R;
 4612 %}
 4613 
 4614 // Floating Point Conditional Move based on integer flags
 4615 pipe_class int_conditional_float_move (cmpOp cmp, flagsReg cr, regF dst, regF src) %{
 4616     single_instruction;
 4617     dst   : X(write);
 4618     src   : E(read);
 4619     cr    : R(read);
 4620     FA    : R(2);
 4621     BR    : R(2);
 4622 %}
 4623 
 4624 // Floating Point Conditional Move based on integer flags
 4625 pipe_class int_conditional_double_move (cmpOp cmp, flagsReg cr, regD dst, regD src) %{
 4626     single_instruction;
 4627     dst   : X(write);
 4628     src   : E(read);
 4629     cr    : R(read);
 4630     FA    : R(2);
 4631     BR    : R(2);
 4632 %}
 4633 
 4634 // Floating Point Multiply Float
 4635 pipe_class fmulF_reg_reg(regF dst, regF src1, regF src2) %{
 4636     single_instruction;
 4637     dst   : X(write);
 4638     src1  : E(read);
 4639     src2  : E(read);
 4640     FM    : R;
 4641 %}
 4642 
 4643 // Floating Point Multiply Double
 4644 pipe_class fmulD_reg_reg(regD dst, regD src1, regD src2) %{
 4645     single_instruction;
 4646     dst   : X(write);
 4647     src1  : E(read);
 4648     src2  : E(read);
 4649     FM    : R;
 4650 %}
 4651 
 4652 // Floating Point Divide Float
 4653 pipe_class fdivF_reg_reg(regF dst, regF src1, regF src2) %{
 4654     single_instruction;
 4655     dst   : X(write);
 4656     src1  : E(read);
 4657     src2  : E(read);
 4658     FM    : R;
 4659     FDIV  : C(14);
 4660 %}
 4661 
 4662 // Floating Point Divide Double
 4663 pipe_class fdivD_reg_reg(regD dst, regD src1, regD src2) %{
 4664     single_instruction;
 4665     dst   : X(write);
 4666     src1  : E(read);
 4667     src2  : E(read);
 4668     FM    : R;
 4669     FDIV  : C(17);
 4670 %}
 4671 
 4672 // Fused floating-point multiply-add float.
 4673 pipe_class fmaF_regx4(regF dst, regF src1, regF src2, regF src3) %{
 4674     single_instruction;
 4675     dst   : X(write);
 4676     src1  : E(read);
 4677     src2  : E(read);
 4678     src3  : E(read);
 4679     FM    : R;
 4680 %}
 4681 
 4682 // Fused gloating-point multiply-add double.
 4683 pipe_class fmaD_regx4(regD dst, regD src1, regD src2, regD src3) %{
 4684     single_instruction;
 4685     dst   : X(write);
 4686     src1  : E(read);
 4687     src2  : E(read);
 4688     src3  : E(read);
 4689     FM    : R;
 4690 %}
 4691 
 4692 // Floating Point Move/Negate/Abs Float
 4693 pipe_class faddF_reg(regF dst, regF src) %{
 4694     single_instruction;
 4695     dst   : W(write);
 4696     src   : E(read);
 4697     FA    : R(1);
 4698 %}
 4699 
 4700 // Floating Point Move/Negate/Abs Double
 4701 pipe_class faddD_reg(regD dst, regD src) %{
 4702     single_instruction;
 4703     dst   : W(write);
 4704     src   : E(read);
 4705     FA    : R;
 4706 %}
 4707 
 4708 // Floating Point Convert F-&gt;D
 4709 pipe_class fcvtF2D(regD dst, regF src) %{
 4710     single_instruction;
 4711     dst   : X(write);
 4712     src   : E(read);
 4713     FA    : R;
 4714 %}
 4715 
 4716 // Floating Point Convert I-&gt;D
 4717 pipe_class fcvtI2D(regD dst, regF src) %{
 4718     single_instruction;
 4719     dst   : X(write);
 4720     src   : E(read);
 4721     FA    : R;
 4722 %}
 4723 
 4724 // Floating Point Convert LHi-&gt;D
 4725 pipe_class fcvtLHi2D(regD dst, regD src) %{
 4726     single_instruction;
 4727     dst   : X(write);
 4728     src   : E(read);
 4729     FA    : R;
 4730 %}
 4731 
 4732 // Floating Point Convert L-&gt;D
 4733 pipe_class fcvtL2D(regD dst, regF src) %{
 4734     single_instruction;
 4735     dst   : X(write);
 4736     src   : E(read);
 4737     FA    : R;
 4738 %}
 4739 
 4740 // Floating Point Convert L-&gt;F
 4741 pipe_class fcvtL2F(regD dst, regF src) %{
 4742     single_instruction;
 4743     dst   : X(write);
 4744     src   : E(read);
 4745     FA    : R;
 4746 %}
 4747 
 4748 // Floating Point Convert D-&gt;F
 4749 pipe_class fcvtD2F(regD dst, regF src) %{
 4750     single_instruction;
 4751     dst   : X(write);
 4752     src   : E(read);
 4753     FA    : R;
 4754 %}
 4755 
 4756 // Floating Point Convert I-&gt;L
 4757 pipe_class fcvtI2L(regD dst, regF src) %{
 4758     single_instruction;
 4759     dst   : X(write);
 4760     src   : E(read);
 4761     FA    : R;
 4762 %}
 4763 
 4764 // Floating Point Convert D-&gt;F
 4765 pipe_class fcvtD2I(regF dst, regD src, flagsReg cr) %{
 4766     instruction_count(1); multiple_bundles;
 4767     dst   : X(write)+6;
 4768     src   : E(read);
 4769     FA    : R;
 4770 %}
 4771 
 4772 // Floating Point Convert D-&gt;L
 4773 pipe_class fcvtD2L(regD dst, regD src, flagsReg cr) %{
 4774     instruction_count(1); multiple_bundles;
 4775     dst   : X(write)+6;
 4776     src   : E(read);
 4777     FA    : R;
 4778 %}
 4779 
 4780 // Floating Point Convert F-&gt;I
 4781 pipe_class fcvtF2I(regF dst, regF src, flagsReg cr) %{
 4782     instruction_count(1); multiple_bundles;
 4783     dst   : X(write)+6;
 4784     src   : E(read);
 4785     FA    : R;
 4786 %}
 4787 
 4788 // Floating Point Convert F-&gt;L
 4789 pipe_class fcvtF2L(regD dst, regF src, flagsReg cr) %{
 4790     instruction_count(1); multiple_bundles;
 4791     dst   : X(write)+6;
 4792     src   : E(read);
 4793     FA    : R;
 4794 %}
 4795 
 4796 // Floating Point Convert I-&gt;F
 4797 pipe_class fcvtI2F(regF dst, regF src) %{
 4798     single_instruction;
 4799     dst   : X(write);
 4800     src   : E(read);
 4801     FA    : R;
 4802 %}
 4803 
 4804 // Floating Point Compare
 4805 pipe_class faddF_fcc_reg_reg_zero(flagsRegF cr, regF src1, regF src2, immI0 zero) %{
 4806     single_instruction;
 4807     cr    : X(write);
 4808     src1  : E(read);
 4809     src2  : E(read);
 4810     FA    : R;
 4811 %}
 4812 
 4813 // Floating Point Compare
 4814 pipe_class faddD_fcc_reg_reg_zero(flagsRegF cr, regD src1, regD src2, immI0 zero) %{
 4815     single_instruction;
 4816     cr    : X(write);
 4817     src1  : E(read);
 4818     src2  : E(read);
 4819     FA    : R;
 4820 %}
 4821 
 4822 // Floating Add Nop
 4823 pipe_class fadd_nop() %{
 4824     single_instruction;
 4825     FA  : R;
 4826 %}
 4827 
 4828 // Integer Store to Memory
 4829 pipe_class istore_mem_reg(memory mem, iRegI src) %{
 4830     single_instruction;
 4831     mem   : R(read);
 4832     src   : C(read);
 4833     MS    : R;
 4834 %}
 4835 
 4836 // Integer Store to Memory
 4837 pipe_class istore_mem_spORreg(memory mem, sp_ptr_RegP src) %{
 4838     single_instruction;
 4839     mem   : R(read);
 4840     src   : C(read);
 4841     MS    : R;
 4842 %}
 4843 
 4844 // Integer Store Zero to Memory
 4845 pipe_class istore_mem_zero(memory mem, immI0 src) %{
 4846     single_instruction;
 4847     mem   : R(read);
 4848     MS    : R;
 4849 %}
 4850 
 4851 // Special Stack Slot Store
 4852 pipe_class istore_stk_reg(stackSlotI stkSlot, iRegI src) %{
 4853     single_instruction;
 4854     stkSlot : R(read);
 4855     src     : C(read);
 4856     MS      : R;
 4857 %}
 4858 
 4859 // Special Stack Slot Store
 4860 pipe_class lstoreI_stk_reg(stackSlotL stkSlot, iRegI src) %{
 4861     instruction_count(2); multiple_bundles;
 4862     stkSlot : R(read);
 4863     src     : C(read);
 4864     MS      : R(2);
 4865 %}
 4866 
 4867 // Float Store
 4868 pipe_class fstoreF_mem_reg(memory mem, RegF src) %{
 4869     single_instruction;
 4870     mem : R(read);
 4871     src : C(read);
 4872     MS  : R;
 4873 %}
 4874 
 4875 // Float Store
 4876 pipe_class fstoreF_mem_zero(memory mem, immF0 src) %{
 4877     single_instruction;
 4878     mem : R(read);
 4879     MS  : R;
 4880 %}
 4881 
 4882 // Double Store
 4883 pipe_class fstoreD_mem_reg(memory mem, RegD src) %{
 4884     instruction_count(1);
 4885     mem : R(read);
 4886     src : C(read);
 4887     MS  : R;
 4888 %}
 4889 
 4890 // Double Store
 4891 pipe_class fstoreD_mem_zero(memory mem, immD0 src) %{
 4892     single_instruction;
 4893     mem : R(read);
 4894     MS  : R;
 4895 %}
 4896 
 4897 // Special Stack Slot Float Store
 4898 pipe_class fstoreF_stk_reg(stackSlotI stkSlot, RegF src) %{
 4899     single_instruction;
 4900     stkSlot : R(read);
 4901     src     : C(read);
 4902     MS      : R;
 4903 %}
 4904 
 4905 // Special Stack Slot Double Store
 4906 pipe_class fstoreD_stk_reg(stackSlotI stkSlot, RegD src) %{
 4907     single_instruction;
 4908     stkSlot : R(read);
 4909     src     : C(read);
 4910     MS      : R;
 4911 %}
 4912 
 4913 // Integer Load (when sign bit propagation not needed)
 4914 pipe_class iload_mem(iRegI dst, memory mem) %{
 4915     single_instruction;
 4916     mem : R(read);
 4917     dst : C(write);
 4918     MS  : R;
 4919 %}
 4920 
 4921 // Integer Load from stack operand
 4922 pipe_class iload_stkD(iRegI dst, stackSlotD mem ) %{
 4923     single_instruction;
 4924     mem : R(read);
 4925     dst : C(write);
 4926     MS  : R;
 4927 %}
 4928 
 4929 // Integer Load (when sign bit propagation or masking is needed)
 4930 pipe_class iload_mask_mem(iRegI dst, memory mem) %{
 4931     single_instruction;
 4932     mem : R(read);
 4933     dst : M(write);
 4934     MS  : R;
 4935 %}
 4936 
 4937 // Float Load
 4938 pipe_class floadF_mem(regF dst, memory mem) %{
 4939     single_instruction;
 4940     mem : R(read);
 4941     dst : M(write);
 4942     MS  : R;
 4943 %}
 4944 
 4945 // Float Load
 4946 pipe_class floadD_mem(regD dst, memory mem) %{
 4947     instruction_count(1); multiple_bundles; // Again, unaligned argument is only multiple case
 4948     mem : R(read);
 4949     dst : M(write);
 4950     MS  : R;
 4951 %}
 4952 
 4953 // Float Load
 4954 pipe_class floadF_stk(regF dst, stackSlotI stkSlot) %{
 4955     single_instruction;
 4956     stkSlot : R(read);
 4957     dst : M(write);
 4958     MS  : R;
 4959 %}
 4960 
 4961 // Float Load
 4962 pipe_class floadD_stk(regD dst, stackSlotI stkSlot) %{
 4963     single_instruction;
 4964     stkSlot : R(read);
 4965     dst : M(write);
 4966     MS  : R;
 4967 %}
 4968 
 4969 // Memory Nop
 4970 pipe_class mem_nop() %{
 4971     single_instruction;
 4972     MS  : R;
 4973 %}
 4974 
 4975 pipe_class sethi(iRegP dst, immI src) %{
 4976     single_instruction;
 4977     dst  : E(write);
 4978     IALU : R;
 4979 %}
 4980 
 4981 pipe_class loadPollP(iRegP poll) %{
 4982     single_instruction;
 4983     poll : R(read);
 4984     MS   : R;
 4985 %}
 4986 
 4987 pipe_class br(Universe br, label labl) %{
 4988     single_instruction_with_delay_slot;
 4989     BR  : R;
 4990 %}
 4991 
 4992 pipe_class br_cc(Universe br, cmpOp cmp, flagsReg cr, label labl) %{
 4993     single_instruction_with_delay_slot;
 4994     cr    : E(read);
 4995     BR    : R;
 4996 %}
 4997 
 4998 pipe_class br_reg(Universe br, cmpOp cmp, iRegI op1, label labl) %{
 4999     single_instruction_with_delay_slot;
 5000     op1 : E(read);
 5001     BR  : R;
 5002     MS  : R;
 5003 %}
 5004 
 5005 // Compare and branch
 5006 pipe_class cmp_br_reg_reg(Universe br, cmpOp cmp, iRegI src1, iRegI src2, label labl, flagsReg cr) %{
 5007     instruction_count(2); has_delay_slot;
 5008     cr    : E(write);
 5009     src1  : R(read);
 5010     src2  : R(read);
 5011     IALU  : R;
 5012     BR    : R;
 5013 %}
 5014 
 5015 // Compare and branch
 5016 pipe_class cmp_br_reg_imm(Universe br, cmpOp cmp, iRegI src1, immI13 src2, label labl, flagsReg cr) %{
 5017     instruction_count(2); has_delay_slot;
 5018     cr    : E(write);
 5019     src1  : R(read);
 5020     IALU  : R;
 5021     BR    : R;
 5022 %}
 5023 
 5024 // Compare and branch using cbcond
 5025 pipe_class cbcond_reg_reg(Universe br, cmpOp cmp, iRegI src1, iRegI src2, label labl) %{
 5026     single_instruction;
 5027     src1  : E(read);
 5028     src2  : E(read);
 5029     IALU  : R;
 5030     BR    : R;
 5031 %}
 5032 
 5033 // Compare and branch using cbcond
 5034 pipe_class cbcond_reg_imm(Universe br, cmpOp cmp, iRegI src1, immI5 src2, label labl) %{
 5035     single_instruction;
 5036     src1  : E(read);
 5037     IALU  : R;
 5038     BR    : R;
 5039 %}
 5040 
 5041 pipe_class br_fcc(Universe br, cmpOpF cc, flagsReg cr, label labl) %{
 5042     single_instruction_with_delay_slot;
 5043     cr    : E(read);
 5044     BR    : R;
 5045 %}
 5046 
 5047 pipe_class br_nop() %{
 5048     single_instruction;
 5049     BR  : R;
 5050 %}
 5051 
 5052 pipe_class simple_call(method meth) %{
 5053     instruction_count(2); multiple_bundles; force_serialization;
 5054     fixed_latency(100);
 5055     BR  : R(1);
 5056     MS  : R(1);
 5057     A0  : R(1);
 5058 %}
 5059 
 5060 pipe_class compiled_call(method meth) %{
 5061     instruction_count(1); multiple_bundles; force_serialization;
 5062     fixed_latency(100);
 5063     MS  : R(1);
 5064 %}
 5065 
 5066 pipe_class call(method meth) %{
 5067     instruction_count(0); multiple_bundles; force_serialization;
 5068     fixed_latency(100);
 5069 %}
 5070 
 5071 pipe_class tail_call(Universe ignore, label labl) %{
 5072     single_instruction; has_delay_slot;
 5073     fixed_latency(100);
 5074     BR  : R(1);
 5075     MS  : R(1);
 5076 %}
 5077 
 5078 pipe_class ret(Universe ignore) %{
 5079     single_instruction; has_delay_slot;
 5080     BR  : R(1);
 5081     MS  : R(1);
 5082 %}
 5083 
 5084 pipe_class ret_poll(g3RegP poll) %{
 5085     instruction_count(3); has_delay_slot;
 5086     poll : E(read);
 5087     MS   : R;
 5088 %}
 5089 
 5090 // The real do-nothing guy
 5091 pipe_class empty( ) %{
 5092     instruction_count(0);
 5093 %}
 5094 
 5095 pipe_class long_memory_op() %{
 5096     instruction_count(0); multiple_bundles; force_serialization;
 5097     fixed_latency(25);
 5098     MS  : R(1);
 5099 %}
 5100 
 5101 // Check-cast
 5102 pipe_class partial_subtype_check_pipe(Universe ignore, iRegP array, iRegP match ) %{
 5103     array : R(read);
 5104     match  : R(read);
 5105     IALU   : R(2);
 5106     BR     : R(2);
 5107     MS     : R;
 5108 %}
 5109 
 5110 // Convert FPU flags into +1,0,-1
 5111 pipe_class floating_cmp( iRegI dst, regF src1, regF src2 ) %{
 5112     src1  : E(read);
 5113     src2  : E(read);
 5114     dst   : E(write);
 5115     FA    : R;
 5116     MS    : R(2);
 5117     BR    : R(2);
 5118 %}
 5119 
 5120 // Compare for p &lt; q, and conditionally add y
 5121 pipe_class cadd_cmpltmask( iRegI p, iRegI q, iRegI y ) %{
 5122     p     : E(read);
 5123     q     : E(read);
 5124     y     : E(read);
 5125     IALU  : R(3)
 5126 %}
 5127 
 5128 // Perform a compare, then move conditionally in a branch delay slot.
 5129 pipe_class min_max( iRegI src2, iRegI srcdst ) %{
 5130     src2   : E(read);
 5131     srcdst : E(read);
 5132     IALU   : R;
 5133     BR     : R;
 5134 %}
 5135 
 5136 // Define the class for the Nop node
 5137 define %{
 5138    MachNop = ialu_nop;
 5139 %}
 5140 
 5141 %}
 5142 
 5143 //----------INSTRUCTIONS-------------------------------------------------------
 5144 
 5145 //------------Special Stack Slot instructions - no match rules-----------------
 5146 instruct stkI_to_regF(regF dst, stackSlotI src) %{
 5147   // No match rule to avoid chain rule match.
 5148   effect(DEF dst, USE src);
 5149   ins_cost(MEMORY_REF_COST);
 5150   format %{ &quot;LDF    $src,$dst\t! stkI to regF&quot; %}
 5151   opcode(Assembler::ldf_op3);
 5152   ins_encode(simple_form3_mem_reg(src, dst));
 5153   ins_pipe(floadF_stk);
 5154 %}
 5155 
 5156 instruct stkL_to_regD(regD dst, stackSlotL src) %{
 5157   // No match rule to avoid chain rule match.
 5158   effect(DEF dst, USE src);
 5159   ins_cost(MEMORY_REF_COST);
 5160   format %{ &quot;LDDF   $src,$dst\t! stkL to regD&quot; %}
 5161   opcode(Assembler::lddf_op3);
 5162   ins_encode(simple_form3_mem_reg(src, dst));
 5163   ins_pipe(floadD_stk);
 5164 %}
 5165 
 5166 instruct regF_to_stkI(stackSlotI dst, regF src) %{
 5167   // No match rule to avoid chain rule match.
 5168   effect(DEF dst, USE src);
 5169   ins_cost(MEMORY_REF_COST);
 5170   format %{ &quot;STF    $src,$dst\t! regF to stkI&quot; %}
 5171   opcode(Assembler::stf_op3);
 5172   ins_encode(simple_form3_mem_reg(dst, src));
 5173   ins_pipe(fstoreF_stk_reg);
 5174 %}
 5175 
 5176 instruct regD_to_stkL(stackSlotL dst, regD src) %{
 5177   // No match rule to avoid chain rule match.
 5178   effect(DEF dst, USE src);
 5179   ins_cost(MEMORY_REF_COST);
 5180   format %{ &quot;STDF   $src,$dst\t! regD to stkL&quot; %}
 5181   opcode(Assembler::stdf_op3);
 5182   ins_encode(simple_form3_mem_reg(dst, src));
 5183   ins_pipe(fstoreD_stk_reg);
 5184 %}
 5185 
 5186 instruct regI_to_stkLHi(stackSlotL dst, iRegI src) %{
 5187   effect(DEF dst, USE src);
 5188   ins_cost(MEMORY_REF_COST*2);
 5189   format %{ &quot;STW    $src,$dst.hi\t! long\n\t&quot;
 5190             &quot;STW    R_G0,$dst.lo&quot; %}
 5191   opcode(Assembler::stw_op3);
 5192   ins_encode(simple_form3_mem_reg(dst, src), form3_mem_plus_4_reg(dst, R_G0));
 5193   ins_pipe(lstoreI_stk_reg);
 5194 %}
 5195 
 5196 instruct regL_to_stkD(stackSlotD dst, iRegL src) %{
 5197   // No match rule to avoid chain rule match.
 5198   effect(DEF dst, USE src);
 5199   ins_cost(MEMORY_REF_COST);
 5200   format %{ &quot;STX    $src,$dst\t! regL to stkD&quot; %}
 5201   opcode(Assembler::stx_op3);
 5202   ins_encode(simple_form3_mem_reg( dst, src ) );
 5203   ins_pipe(istore_stk_reg);
 5204 %}
 5205 
 5206 //---------- Chain stack slots between similar types --------
 5207 
 5208 // Load integer from stack slot
 5209 instruct stkI_to_regI( iRegI dst, stackSlotI src ) %{
 5210   match(Set dst src);
 5211   ins_cost(MEMORY_REF_COST);
 5212 
 5213   format %{ &quot;LDUW   $src,$dst\t!stk&quot; %}
 5214   opcode(Assembler::lduw_op3);
 5215   ins_encode(simple_form3_mem_reg( src, dst ) );
 5216   ins_pipe(iload_mem);
 5217 %}
 5218 
 5219 // Store integer to stack slot
 5220 instruct regI_to_stkI( stackSlotI dst, iRegI src ) %{
 5221   match(Set dst src);
 5222   ins_cost(MEMORY_REF_COST);
 5223 
 5224   format %{ &quot;STW    $src,$dst\t!stk&quot; %}
 5225   opcode(Assembler::stw_op3);
 5226   ins_encode(simple_form3_mem_reg( dst, src ) );
 5227   ins_pipe(istore_mem_reg);
 5228 %}
 5229 
 5230 // Load long from stack slot
 5231 instruct stkL_to_regL( iRegL dst, stackSlotL src ) %{
 5232   match(Set dst src);
 5233 
 5234   ins_cost(MEMORY_REF_COST);
 5235   format %{ &quot;LDX    $src,$dst\t! long&quot; %}
 5236   opcode(Assembler::ldx_op3);
 5237   ins_encode(simple_form3_mem_reg( src, dst ) );
 5238   ins_pipe(iload_mem);
 5239 %}
 5240 
 5241 // Store long to stack slot
 5242 instruct regL_to_stkL(stackSlotL dst, iRegL src) %{
 5243   match(Set dst src);
 5244 
 5245   ins_cost(MEMORY_REF_COST);
 5246   format %{ &quot;STX    $src,$dst\t! long&quot; %}
 5247   opcode(Assembler::stx_op3);
 5248   ins_encode(simple_form3_mem_reg( dst, src ) );
 5249   ins_pipe(istore_mem_reg);
 5250 %}
 5251 
 5252 // Load pointer from stack slot, 64-bit encoding
 5253 instruct stkP_to_regP( iRegP dst, stackSlotP src ) %{
 5254   match(Set dst src);
 5255   ins_cost(MEMORY_REF_COST);
 5256   format %{ &quot;LDX    $src,$dst\t!ptr&quot; %}
 5257   opcode(Assembler::ldx_op3);
 5258   ins_encode(simple_form3_mem_reg( src, dst ) );
 5259   ins_pipe(iload_mem);
 5260 %}
 5261 
 5262 // Store pointer to stack slot
 5263 instruct regP_to_stkP(stackSlotP dst, iRegP src) %{
 5264   match(Set dst src);
 5265   ins_cost(MEMORY_REF_COST);
 5266   format %{ &quot;STX    $src,$dst\t!ptr&quot; %}
 5267   opcode(Assembler::stx_op3);
 5268   ins_encode(simple_form3_mem_reg( dst, src ) );
 5269   ins_pipe(istore_mem_reg);
 5270 %}
 5271 
 5272 //------------Special Nop instructions for bundling - no match rules-----------
 5273 // Nop using the A0 functional unit
 5274 instruct Nop_A0() %{
 5275   ins_cost(0);
 5276 
 5277   format %{ &quot;NOP    ! Alu Pipeline&quot; %}
 5278   opcode(Assembler::or_op3, Assembler::arith_op);
 5279   ins_encode( form2_nop() );
 5280   ins_pipe(ialu_nop_A0);
 5281 %}
 5282 
 5283 // Nop using the A1 functional unit
 5284 instruct Nop_A1( ) %{
 5285   ins_cost(0);
 5286 
 5287   format %{ &quot;NOP    ! Alu Pipeline&quot; %}
 5288   opcode(Assembler::or_op3, Assembler::arith_op);
 5289   ins_encode( form2_nop() );
 5290   ins_pipe(ialu_nop_A1);
 5291 %}
 5292 
 5293 // Nop using the memory functional unit
 5294 instruct Nop_MS( ) %{
 5295   ins_cost(0);
 5296 
 5297   format %{ &quot;NOP    ! Memory Pipeline&quot; %}
 5298   ins_encode( emit_mem_nop );
 5299   ins_pipe(mem_nop);
 5300 %}
 5301 
 5302 // Nop using the floating add functional unit
 5303 instruct Nop_FA( ) %{
 5304   ins_cost(0);
 5305 
 5306   format %{ &quot;NOP    ! Floating Add Pipeline&quot; %}
 5307   ins_encode( emit_fadd_nop );
 5308   ins_pipe(fadd_nop);
 5309 %}
 5310 
 5311 // Nop using the branch functional unit
 5312 instruct Nop_BR( ) %{
 5313   ins_cost(0);
 5314 
 5315   format %{ &quot;NOP    ! Branch Pipeline&quot; %}
 5316   ins_encode( emit_br_nop );
 5317   ins_pipe(br_nop);
 5318 %}
 5319 
 5320 //----------Load/Store/Move Instructions---------------------------------------
 5321 //----------Load Instructions--------------------------------------------------
 5322 // Load Byte (8bit signed)
 5323 instruct loadB(iRegI dst, memory mem) %{
 5324   match(Set dst (LoadB mem));
 5325   ins_cost(MEMORY_REF_COST);
 5326 
 5327   size(4);
 5328   format %{ &quot;LDSB   $mem,$dst\t! byte&quot; %}
 5329   ins_encode %{
 5330     __ ldsb($mem$$Address, $dst$$Register);
 5331   %}
 5332   ins_pipe(iload_mask_mem);
 5333 %}
 5334 
 5335 // Load Byte (8bit signed) into a Long Register
 5336 instruct loadB2L(iRegL dst, memory mem) %{
 5337   match(Set dst (ConvI2L (LoadB mem)));
 5338   ins_cost(MEMORY_REF_COST);
 5339 
 5340   size(4);
 5341   format %{ &quot;LDSB   $mem,$dst\t! byte -&gt; long&quot; %}
 5342   ins_encode %{
 5343     __ ldsb($mem$$Address, $dst$$Register);
 5344   %}
 5345   ins_pipe(iload_mask_mem);
 5346 %}
 5347 
 5348 // Load Unsigned Byte (8bit UNsigned) into an int reg
 5349 instruct loadUB(iRegI dst, memory mem) %{
 5350   match(Set dst (LoadUB mem));
 5351   ins_cost(MEMORY_REF_COST);
 5352 
 5353   size(4);
 5354   format %{ &quot;LDUB   $mem,$dst\t! ubyte&quot; %}
 5355   ins_encode %{
 5356     __ ldub($mem$$Address, $dst$$Register);
 5357   %}
 5358   ins_pipe(iload_mem);
 5359 %}
 5360 
 5361 // Load Unsigned Byte (8bit UNsigned) into a Long Register
 5362 instruct loadUB2L(iRegL dst, memory mem) %{
 5363   match(Set dst (ConvI2L (LoadUB mem)));
 5364   ins_cost(MEMORY_REF_COST);
 5365 
 5366   size(4);
 5367   format %{ &quot;LDUB   $mem,$dst\t! ubyte -&gt; long&quot; %}
 5368   ins_encode %{
 5369     __ ldub($mem$$Address, $dst$$Register);
 5370   %}
 5371   ins_pipe(iload_mem);
 5372 %}
 5373 
 5374 // Load Unsigned Byte (8 bit UNsigned) with 32-bit mask into Long Register
 5375 instruct loadUB2L_immI(iRegL dst, memory mem, immI mask) %{
 5376   match(Set dst (ConvI2L (AndI (LoadUB mem) mask)));
 5377   ins_cost(MEMORY_REF_COST + DEFAULT_COST);
 5378 
 5379   size(2*4);
 5380   format %{ &quot;LDUB   $mem,$dst\t# ubyte &amp; 32-bit mask -&gt; long\n\t&quot;
 5381             &quot;AND    $dst,right_n_bits($mask, 8),$dst&quot; %}
 5382   ins_encode %{
 5383     __ ldub($mem$$Address, $dst$$Register);
 5384     __ and3($dst$$Register, $mask$$constant &amp; right_n_bits(8), $dst$$Register);
 5385   %}
 5386   ins_pipe(iload_mem);
 5387 %}
 5388 
 5389 // Load Short (16bit signed)
 5390 instruct loadS(iRegI dst, memory mem) %{
 5391   match(Set dst (LoadS mem));
 5392   ins_cost(MEMORY_REF_COST);
 5393 
 5394   size(4);
 5395   format %{ &quot;LDSH   $mem,$dst\t! short&quot; %}
 5396   ins_encode %{
 5397     __ ldsh($mem$$Address, $dst$$Register);
 5398   %}
 5399   ins_pipe(iload_mask_mem);
 5400 %}
 5401 
 5402 // Load Short (16 bit signed) to Byte (8 bit signed)
 5403 instruct loadS2B(iRegI dst, indOffset13m7 mem, immI_24 twentyfour) %{
 5404   match(Set dst (RShiftI (LShiftI (LoadS mem) twentyfour) twentyfour));
 5405   ins_cost(MEMORY_REF_COST);
 5406 
 5407   size(4);
 5408 
 5409   format %{ &quot;LDSB   $mem+1,$dst\t! short -&gt; byte&quot; %}
 5410   ins_encode %{
 5411     __ ldsb($mem$$Address, $dst$$Register, 1);
 5412   %}
 5413   ins_pipe(iload_mask_mem);
 5414 %}
 5415 
 5416 // Load Short (16bit signed) into a Long Register
 5417 instruct loadS2L(iRegL dst, memory mem) %{
 5418   match(Set dst (ConvI2L (LoadS mem)));
 5419   ins_cost(MEMORY_REF_COST);
 5420 
 5421   size(4);
 5422   format %{ &quot;LDSH   $mem,$dst\t! short -&gt; long&quot; %}
 5423   ins_encode %{
 5424     __ ldsh($mem$$Address, $dst$$Register);
 5425   %}
 5426   ins_pipe(iload_mask_mem);
 5427 %}
 5428 
 5429 // Load Unsigned Short/Char (16bit UNsigned)
 5430 instruct loadUS(iRegI dst, memory mem) %{
 5431   match(Set dst (LoadUS mem));
 5432   ins_cost(MEMORY_REF_COST);
 5433 
 5434   size(4);
 5435   format %{ &quot;LDUH   $mem,$dst\t! ushort/char&quot; %}
 5436   ins_encode %{
 5437     __ lduh($mem$$Address, $dst$$Register);
 5438   %}
 5439   ins_pipe(iload_mem);
 5440 %}
 5441 
 5442 // Load Unsigned Short/Char (16 bit UNsigned) to Byte (8 bit signed)
 5443 instruct loadUS2B(iRegI dst, indOffset13m7 mem, immI_24 twentyfour) %{
 5444   match(Set dst (RShiftI (LShiftI (LoadUS mem) twentyfour) twentyfour));
 5445   ins_cost(MEMORY_REF_COST);
 5446 
 5447   size(4);
 5448   format %{ &quot;LDSB   $mem+1,$dst\t! ushort -&gt; byte&quot; %}
 5449   ins_encode %{
 5450     __ ldsb($mem$$Address, $dst$$Register, 1);
 5451   %}
 5452   ins_pipe(iload_mask_mem);
 5453 %}
 5454 
 5455 // Load Unsigned Short/Char (16bit UNsigned) into a Long Register
 5456 instruct loadUS2L(iRegL dst, memory mem) %{
 5457   match(Set dst (ConvI2L (LoadUS mem)));
 5458   ins_cost(MEMORY_REF_COST);
 5459 
 5460   size(4);
 5461   format %{ &quot;LDUH   $mem,$dst\t! ushort/char -&gt; long&quot; %}
 5462   ins_encode %{
 5463     __ lduh($mem$$Address, $dst$$Register);
 5464   %}
 5465   ins_pipe(iload_mem);
 5466 %}
 5467 
 5468 // Load Unsigned Short/Char (16bit UNsigned) with mask 0xFF into a Long Register
 5469 instruct loadUS2L_immI_255(iRegL dst, indOffset13m7 mem, immI_255 mask) %{
 5470   match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));
 5471   ins_cost(MEMORY_REF_COST);
 5472 
 5473   size(4);
 5474   format %{ &quot;LDUB   $mem+1,$dst\t! ushort/char &amp; 0xFF -&gt; long&quot; %}
 5475   ins_encode %{
 5476     __ ldub($mem$$Address, $dst$$Register, 1);  // LSB is index+1 on BE
 5477   %}
 5478   ins_pipe(iload_mem);
 5479 %}
 5480 
 5481 // Load Unsigned Short/Char (16bit UNsigned) with a 13-bit mask into a Long Register
 5482 instruct loadUS2L_immI13(iRegL dst, memory mem, immI13 mask) %{
 5483   match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));
 5484   ins_cost(MEMORY_REF_COST + DEFAULT_COST);
 5485 
 5486   size(2*4);
 5487   format %{ &quot;LDUH   $mem,$dst\t! ushort/char &amp; 13-bit mask -&gt; long\n\t&quot;
 5488             &quot;AND    $dst,$mask,$dst&quot; %}
 5489   ins_encode %{
 5490     Register Rdst = $dst$$Register;
 5491     __ lduh($mem$$Address, Rdst);
 5492     __ and3(Rdst, $mask$$constant, Rdst);
 5493   %}
 5494   ins_pipe(iload_mem);
 5495 %}
 5496 
 5497 // Load Unsigned Short/Char (16bit UNsigned) with a 32-bit mask into a Long Register
 5498 instruct loadUS2L_immI(iRegL dst, memory mem, immI mask, iRegL tmp) %{
 5499   match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));
 5500   effect(TEMP dst, TEMP tmp);
 5501   ins_cost(MEMORY_REF_COST + 2*DEFAULT_COST);
 5502 
 5503   format %{ &quot;LDUH   $mem,$dst\t! ushort/char &amp; 32-bit mask -&gt; long\n\t&quot;
 5504             &quot;SET    right_n_bits($mask, 16),$tmp\n\t&quot;
 5505             &quot;AND    $dst,$tmp,$dst&quot; %}
 5506   ins_encode %{
 5507     Register Rdst = $dst$$Register;
 5508     Register Rtmp = $tmp$$Register;
 5509     __ lduh($mem$$Address, Rdst);
 5510     __ set($mask$$constant &amp; right_n_bits(16), Rtmp);
 5511     __ and3(Rdst, Rtmp, Rdst);
 5512   %}
 5513   ins_pipe(iload_mem);
 5514 %}
 5515 
 5516 // Load Integer
 5517 instruct loadI(iRegI dst, memory mem) %{
 5518   match(Set dst (LoadI mem));
 5519   ins_cost(MEMORY_REF_COST);
 5520 
 5521   size(4);
 5522   format %{ &quot;LDUW   $mem,$dst\t! int&quot; %}
 5523   ins_encode %{
 5524     __ lduw($mem$$Address, $dst$$Register);
 5525   %}
 5526   ins_pipe(iload_mem);
 5527 %}
 5528 
 5529 // Load Integer to Byte (8 bit signed)
 5530 instruct loadI2B(iRegI dst, indOffset13m7 mem, immI_24 twentyfour) %{
 5531   match(Set dst (RShiftI (LShiftI (LoadI mem) twentyfour) twentyfour));
 5532   ins_cost(MEMORY_REF_COST);
 5533 
 5534   size(4);
 5535 
 5536   format %{ &quot;LDSB   $mem+3,$dst\t! int -&gt; byte&quot; %}
 5537   ins_encode %{
 5538     __ ldsb($mem$$Address, $dst$$Register, 3);
 5539   %}
 5540   ins_pipe(iload_mask_mem);
 5541 %}
 5542 
 5543 // Load Integer to Unsigned Byte (8 bit UNsigned)
 5544 instruct loadI2UB(iRegI dst, indOffset13m7 mem, immI_255 mask) %{
 5545   match(Set dst (AndI (LoadI mem) mask));
 5546   ins_cost(MEMORY_REF_COST);
 5547 
 5548   size(4);
 5549 
 5550   format %{ &quot;LDUB   $mem+3,$dst\t! int -&gt; ubyte&quot; %}
 5551   ins_encode %{
 5552     __ ldub($mem$$Address, $dst$$Register, 3);
 5553   %}
 5554   ins_pipe(iload_mask_mem);
 5555 %}
 5556 
 5557 // Load Integer to Short (16 bit signed)
 5558 instruct loadI2S(iRegI dst, indOffset13m7 mem, immI_16 sixteen) %{
 5559   match(Set dst (RShiftI (LShiftI (LoadI mem) sixteen) sixteen));
 5560   ins_cost(MEMORY_REF_COST);
 5561 
 5562   size(4);
 5563 
 5564   format %{ &quot;LDSH   $mem+2,$dst\t! int -&gt; short&quot; %}
 5565   ins_encode %{
 5566     __ ldsh($mem$$Address, $dst$$Register, 2);
 5567   %}
 5568   ins_pipe(iload_mask_mem);
 5569 %}
 5570 
 5571 // Load Integer to Unsigned Short (16 bit UNsigned)
 5572 instruct loadI2US(iRegI dst, indOffset13m7 mem, immI_65535 mask) %{
 5573   match(Set dst (AndI (LoadI mem) mask));
 5574   ins_cost(MEMORY_REF_COST);
 5575 
 5576   size(4);
 5577 
 5578   format %{ &quot;LDUH   $mem+2,$dst\t! int -&gt; ushort/char&quot; %}
 5579   ins_encode %{
 5580     __ lduh($mem$$Address, $dst$$Register, 2);
 5581   %}
 5582   ins_pipe(iload_mask_mem);
 5583 %}
 5584 
 5585 // Load Integer into a Long Register
 5586 instruct loadI2L(iRegL dst, memory mem) %{
 5587   match(Set dst (ConvI2L (LoadI mem)));
 5588   ins_cost(MEMORY_REF_COST);
 5589 
 5590   size(4);
 5591   format %{ &quot;LDSW   $mem,$dst\t! int -&gt; long&quot; %}
 5592   ins_encode %{
 5593     __ ldsw($mem$$Address, $dst$$Register);
 5594   %}
 5595   ins_pipe(iload_mask_mem);
 5596 %}
 5597 
 5598 // Load Integer with mask 0xFF into a Long Register
 5599 instruct loadI2L_immI_255(iRegL dst, indOffset13m7 mem, immI_255 mask) %{
 5600   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5601   ins_cost(MEMORY_REF_COST);
 5602 
 5603   size(4);
 5604   format %{ &quot;LDUB   $mem+3,$dst\t! int &amp; 0xFF -&gt; long&quot; %}
 5605   ins_encode %{
 5606     __ ldub($mem$$Address, $dst$$Register, 3);  // LSB is index+3 on BE
 5607   %}
 5608   ins_pipe(iload_mem);
 5609 %}
 5610 
 5611 // Load Integer with mask 0xFFFF into a Long Register
 5612 instruct loadI2L_immI_65535(iRegL dst, indOffset13m7 mem, immI_65535 mask) %{
 5613   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5614   ins_cost(MEMORY_REF_COST);
 5615 
 5616   size(4);
 5617   format %{ &quot;LDUH   $mem+2,$dst\t! int &amp; 0xFFFF -&gt; long&quot; %}
 5618   ins_encode %{
 5619     __ lduh($mem$$Address, $dst$$Register, 2);  // LSW is index+2 on BE
 5620   %}
 5621   ins_pipe(iload_mem);
 5622 %}
 5623 
 5624 // Load Integer with a 12-bit mask into a Long Register
 5625 instruct loadI2L_immU12(iRegL dst, memory mem, immU12 mask) %{
 5626   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5627   ins_cost(MEMORY_REF_COST + DEFAULT_COST);
 5628 
 5629   size(2*4);
 5630   format %{ &quot;LDUW   $mem,$dst\t! int &amp; 12-bit mask -&gt; long\n\t&quot;
 5631             &quot;AND    $dst,$mask,$dst&quot; %}
 5632   ins_encode %{
 5633     Register Rdst = $dst$$Register;
 5634     __ lduw($mem$$Address, Rdst);
 5635     __ and3(Rdst, $mask$$constant, Rdst);
 5636   %}
 5637   ins_pipe(iload_mem);
 5638 %}
 5639 
 5640 // Load Integer with a 31-bit mask into a Long Register
 5641 instruct loadI2L_immU31(iRegL dst, memory mem, immU31 mask, iRegL tmp) %{
 5642   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5643   effect(TEMP dst, TEMP tmp);
 5644   ins_cost(MEMORY_REF_COST + 2*DEFAULT_COST);
 5645 
 5646   format %{ &quot;LDUW   $mem,$dst\t! int &amp; 31-bit mask -&gt; long\n\t&quot;
 5647             &quot;SET    $mask,$tmp\n\t&quot;
 5648             &quot;AND    $dst,$tmp,$dst&quot; %}
 5649   ins_encode %{
 5650     Register Rdst = $dst$$Register;
 5651     Register Rtmp = $tmp$$Register;
 5652     __ lduw($mem$$Address, Rdst);
 5653     __ set($mask$$constant, Rtmp);
 5654     __ and3(Rdst, Rtmp, Rdst);
 5655   %}
 5656   ins_pipe(iload_mem);
 5657 %}
 5658 
 5659 // Load Unsigned Integer into a Long Register
 5660 instruct loadUI2L(iRegL dst, memory mem, immL_32bits mask) %{
 5661   match(Set dst (AndL (ConvI2L (LoadI mem)) mask));
 5662   ins_cost(MEMORY_REF_COST);
 5663 
 5664   size(4);
 5665   format %{ &quot;LDUW   $mem,$dst\t! uint -&gt; long&quot; %}
 5666   ins_encode %{
 5667     __ lduw($mem$$Address, $dst$$Register);
 5668   %}
 5669   ins_pipe(iload_mem);
 5670 %}
 5671 
 5672 // Load Long - aligned
 5673 instruct loadL(iRegL dst, memory mem ) %{
 5674   match(Set dst (LoadL mem));
 5675   ins_cost(MEMORY_REF_COST);
 5676 
 5677   size(4);
 5678   format %{ &quot;LDX    $mem,$dst\t! long&quot; %}
 5679   ins_encode %{
 5680     __ ldx($mem$$Address, $dst$$Register);
 5681   %}
 5682   ins_pipe(iload_mem);
 5683 %}
 5684 
 5685 // Load Long - UNaligned
 5686 instruct loadL_unaligned(iRegL dst, memory mem, o7RegI tmp) %{
 5687   match(Set dst (LoadL_unaligned mem));
 5688   effect(KILL tmp);
 5689   ins_cost(MEMORY_REF_COST*2+DEFAULT_COST);
 5690   format %{ &quot;LDUW   $mem+4,R_O7\t! misaligned long\n&quot;
 5691           &quot;\tLDUW   $mem  ,$dst\n&quot;
 5692           &quot;\tSLLX   #32, $dst, $dst\n&quot;
 5693           &quot;\tOR     $dst, R_O7, $dst&quot; %}
 5694   opcode(Assembler::lduw_op3);
 5695   ins_encode(form3_mem_reg_long_unaligned_marshal( mem, dst ));
 5696   ins_pipe(iload_mem);
 5697 %}
 5698 
 5699 // Load Range
 5700 instruct loadRange(iRegI dst, memory mem) %{
 5701   match(Set dst (LoadRange mem));
 5702   ins_cost(MEMORY_REF_COST);
 5703 
 5704   format %{ &quot;LDUW   $mem,$dst\t! range&quot; %}
 5705   opcode(Assembler::lduw_op3);
 5706   ins_encode(simple_form3_mem_reg( mem, dst ) );
 5707   ins_pipe(iload_mem);
 5708 %}
 5709 
 5710 // Load Integer into %f register (for fitos/fitod)
 5711 instruct loadI_freg(regF dst, memory mem) %{
 5712   match(Set dst (LoadI mem));
 5713   ins_cost(MEMORY_REF_COST);
 5714 
 5715   format %{ &quot;LDF    $mem,$dst\t! for fitos/fitod&quot; %}
 5716   opcode(Assembler::ldf_op3);
 5717   ins_encode(simple_form3_mem_reg( mem, dst ) );
 5718   ins_pipe(floadF_mem);
 5719 %}
 5720 
 5721 // Load Pointer
 5722 instruct loadP(iRegP dst, memory mem) %{
 5723   match(Set dst (LoadP mem));
 5724   ins_cost(MEMORY_REF_COST);
 5725   size(4);
 5726 
 5727   format %{ &quot;LDX    $mem,$dst\t! ptr&quot; %}
 5728   ins_encode %{
 5729     __ ldx($mem$$Address, $dst$$Register);
 5730   %}
 5731   ins_pipe(iload_mem);
 5732 %}
 5733 
 5734 // Load Compressed Pointer
 5735 instruct loadN(iRegN dst, memory mem) %{
 5736   match(Set dst (LoadN mem));
 5737   ins_cost(MEMORY_REF_COST);
 5738   size(4);
 5739 
 5740   format %{ &quot;LDUW   $mem,$dst\t! compressed ptr&quot; %}
 5741   ins_encode %{
 5742     __ lduw($mem$$Address, $dst$$Register);
 5743   %}
 5744   ins_pipe(iload_mem);
 5745 %}
 5746 
 5747 // Load Klass Pointer
 5748 instruct loadKlass(iRegP dst, memory mem) %{
 5749   match(Set dst (LoadKlass mem));
 5750   ins_cost(MEMORY_REF_COST);
 5751   size(4);
 5752 
 5753   format %{ &quot;LDX    $mem,$dst\t! klass ptr&quot; %}
 5754   ins_encode %{
 5755     __ ldx($mem$$Address, $dst$$Register);
 5756   %}
 5757   ins_pipe(iload_mem);
 5758 %}
 5759 
 5760 // Load narrow Klass Pointer
 5761 instruct loadNKlass(iRegN dst, memory mem) %{
 5762   match(Set dst (LoadNKlass mem));
 5763   ins_cost(MEMORY_REF_COST);
 5764   size(4);
 5765 
 5766   format %{ &quot;LDUW   $mem,$dst\t! compressed klass ptr&quot; %}
 5767   ins_encode %{
 5768     __ lduw($mem$$Address, $dst$$Register);
 5769   %}
 5770   ins_pipe(iload_mem);
 5771 %}
 5772 
 5773 // Load Double
 5774 instruct loadD(regD dst, memory mem) %{
 5775   match(Set dst (LoadD mem));
 5776   ins_cost(MEMORY_REF_COST);
 5777 
 5778   format %{ &quot;LDDF   $mem,$dst&quot; %}
 5779   opcode(Assembler::lddf_op3);
 5780   ins_encode(simple_form3_mem_reg( mem, dst ) );
 5781   ins_pipe(floadD_mem);
 5782 %}
 5783 
 5784 // Load Double - UNaligned
 5785 instruct loadD_unaligned(regD_low dst, memory mem ) %{
 5786   match(Set dst (LoadD_unaligned mem));
 5787   ins_cost(MEMORY_REF_COST*2+DEFAULT_COST);
 5788   format %{ &quot;LDF    $mem  ,$dst.hi\t! misaligned double\n&quot;
 5789           &quot;\tLDF    $mem+4,$dst.lo\t!&quot; %}
 5790   opcode(Assembler::ldf_op3);
 5791   ins_encode( form3_mem_reg_double_unaligned( mem, dst ));
 5792   ins_pipe(iload_mem);
 5793 %}
 5794 
 5795 // Load Float
 5796 instruct loadF(regF dst, memory mem) %{
 5797   match(Set dst (LoadF mem));
 5798   ins_cost(MEMORY_REF_COST);
 5799 
 5800   format %{ &quot;LDF    $mem,$dst&quot; %}
 5801   opcode(Assembler::ldf_op3);
 5802   ins_encode(simple_form3_mem_reg( mem, dst ) );
 5803   ins_pipe(floadF_mem);
 5804 %}
 5805 
 5806 // Load Constant
 5807 instruct loadConI( iRegI dst, immI src ) %{
 5808   match(Set dst src);
 5809   ins_cost(DEFAULT_COST * 3/2);
 5810   format %{ &quot;SET    $src,$dst&quot; %}
 5811   ins_encode( Set32(src, dst) );
 5812   ins_pipe(ialu_hi_lo_reg);
 5813 %}
 5814 
 5815 instruct loadConI13( iRegI dst, immI13 src ) %{
 5816   match(Set dst src);
 5817 
 5818   size(4);
 5819   format %{ &quot;MOV    $src,$dst&quot; %}
 5820   ins_encode( Set13( src, dst ) );
 5821   ins_pipe(ialu_imm);
 5822 %}
 5823 
 5824 instruct loadConP_set(iRegP dst, immP_set con) %{
 5825   match(Set dst con);
 5826   ins_cost(DEFAULT_COST * 3/2);
 5827   format %{ &quot;SET    $con,$dst\t! ptr&quot; %}
 5828   ins_encode %{
 5829     relocInfo::relocType constant_reloc = _opnds[1]-&gt;constant_reloc();
 5830       intptr_t val = $con$$constant;
 5831     if (constant_reloc == relocInfo::oop_type) {
 5832       __ set_oop_constant((jobject) val, $dst$$Register);
 5833     } else if (constant_reloc == relocInfo::metadata_type) {
 5834       __ set_metadata_constant((Metadata*)val, $dst$$Register);
 5835     } else {          // non-oop pointers, e.g. card mark base, heap top
 5836       assert(constant_reloc == relocInfo::none, &quot;unexpected reloc type&quot;);
 5837       __ set(val, $dst$$Register);
 5838     }
 5839   %}
 5840   ins_pipe(loadConP);
 5841 %}
 5842 
 5843 instruct loadConP_load(iRegP dst, immP_load con) %{
 5844   match(Set dst con);
 5845   ins_cost(MEMORY_REF_COST);
 5846   format %{ &quot;LD     [$constanttablebase + $constantoffset],$dst\t! load from constant table: ptr=$con&quot; %}
 5847   ins_encode %{
 5848     RegisterOrConstant con_offset = __ ensure_simm13_or_reg($constantoffset($con), $dst$$Register);
 5849     __ ld_ptr($constanttablebase, con_offset, $dst$$Register);
 5850   %}
 5851   ins_pipe(loadConP);
 5852 %}
 5853 
 5854 instruct loadConP_no_oop_cheap(iRegP dst, immP_no_oop_cheap con) %{
 5855   match(Set dst con);
 5856   ins_cost(DEFAULT_COST * 3/2);
 5857   format %{ &quot;SET    $con,$dst\t! non-oop ptr&quot; %}
 5858   ins_encode %{
 5859     if (_opnds[1]-&gt;constant_reloc() == relocInfo::metadata_type) {
 5860       __ set_metadata_constant((Metadata*)$con$$constant, $dst$$Register);
 5861     } else {
 5862       __ set($con$$constant, $dst$$Register);
 5863     }
 5864   %}
 5865   ins_pipe(loadConP);
 5866 %}
 5867 
 5868 instruct loadConP0(iRegP dst, immP0 src) %{
 5869   match(Set dst src);
 5870 
 5871   size(4);
 5872   format %{ &quot;CLR    $dst\t!ptr&quot; %}
 5873   ins_encode %{
 5874     __ clr($dst$$Register);
 5875   %}
 5876   ins_pipe(ialu_imm);
 5877 %}
 5878 
<a name="82" id="anc82"></a>










 5879 instruct loadConN0(iRegN dst, immN0 src) %{
 5880   match(Set dst src);
 5881 
 5882   size(4);
 5883   format %{ &quot;CLR    $dst\t! compressed NULL ptr&quot; %}
 5884   ins_encode %{
 5885     __ clr($dst$$Register);
 5886   %}
 5887   ins_pipe(ialu_imm);
 5888 %}
 5889 
 5890 instruct loadConN(iRegN dst, immN src) %{
 5891   match(Set dst src);
 5892   ins_cost(DEFAULT_COST * 3/2);
 5893   format %{ &quot;SET    $src,$dst\t! compressed ptr&quot; %}
 5894   ins_encode %{
 5895     Register dst = $dst$$Register;
 5896     __ set_narrow_oop((jobject)$src$$constant, dst);
 5897   %}
 5898   ins_pipe(ialu_hi_lo_reg);
 5899 %}
 5900 
 5901 instruct loadConNKlass(iRegN dst, immNKlass src) %{
 5902   match(Set dst src);
 5903   ins_cost(DEFAULT_COST * 3/2);
 5904   format %{ &quot;SET    $src,$dst\t! compressed klass ptr&quot; %}
 5905   ins_encode %{
 5906     Register dst = $dst$$Register;
 5907     __ set_narrow_klass((Klass*)$src$$constant, dst);
 5908   %}
 5909   ins_pipe(ialu_hi_lo_reg);
 5910 %}
 5911 
 5912 // Materialize long value (predicated by immL_cheap).
 5913 instruct loadConL_set64(iRegL dst, immL_cheap con, o7RegL tmp) %{
 5914   match(Set dst con);
 5915   effect(KILL tmp);
 5916   ins_cost(DEFAULT_COST * 3);
 5917   format %{ &quot;SET64   $con,$dst KILL $tmp\t! cheap long&quot; %}
 5918   ins_encode %{
 5919     __ set64($con$$constant, $dst$$Register, $tmp$$Register);
 5920   %}
 5921   ins_pipe(loadConL);
 5922 %}
 5923 
 5924 // Load long value from constant table (predicated by immL_expensive).
 5925 instruct loadConL_ldx(iRegL dst, immL_expensive con) %{
 5926   match(Set dst con);
 5927   ins_cost(MEMORY_REF_COST);
 5928   format %{ &quot;LDX     [$constanttablebase + $constantoffset],$dst\t! load from constant table: long=$con&quot; %}
 5929   ins_encode %{
 5930       RegisterOrConstant con_offset = __ ensure_simm13_or_reg($constantoffset($con), $dst$$Register);
 5931     __ ldx($constanttablebase, con_offset, $dst$$Register);
 5932   %}
 5933   ins_pipe(loadConL);
 5934 %}
 5935 
 5936 instruct loadConL0( iRegL dst, immL0 src ) %{
 5937   match(Set dst src);
 5938   ins_cost(DEFAULT_COST);
 5939   size(4);
 5940   format %{ &quot;CLR    $dst\t! long&quot; %}
 5941   ins_encode( Set13( src, dst ) );
 5942   ins_pipe(ialu_imm);
 5943 %}
 5944 
 5945 instruct loadConL13( iRegL dst, immL13 src ) %{
 5946   match(Set dst src);
 5947   ins_cost(DEFAULT_COST * 2);
 5948 
 5949   size(4);
 5950   format %{ &quot;MOV    $src,$dst\t! long&quot; %}
 5951   ins_encode( Set13( src, dst ) );
 5952   ins_pipe(ialu_imm);
 5953 %}
 5954 
 5955 instruct loadConF(regF dst, immF con, o7RegI tmp) %{
 5956   match(Set dst con);
 5957   effect(KILL tmp);
 5958   format %{ &quot;LDF    [$constanttablebase + $constantoffset],$dst\t! load from constant table: float=$con&quot; %}
 5959   ins_encode %{
 5960       RegisterOrConstant con_offset = __ ensure_simm13_or_reg($constantoffset($con), $tmp$$Register);
 5961     __ ldf(FloatRegisterImpl::S, $constanttablebase, con_offset, $dst$$FloatRegister);
 5962   %}
 5963   ins_pipe(loadConFD);
 5964 %}
 5965 
 5966 instruct loadConD(regD dst, immD con, o7RegI tmp) %{
 5967   match(Set dst con);
 5968   effect(KILL tmp);
 5969   format %{ &quot;LDDF   [$constanttablebase + $constantoffset],$dst\t! load from constant table: double=$con&quot; %}
 5970   ins_encode %{
 5971     // XXX This is a quick fix for 6833573.
 5972     //__ ldf(FloatRegisterImpl::D, $constanttablebase, $constantoffset($con), $dst$$FloatRegister);
 5973     RegisterOrConstant con_offset = __ ensure_simm13_or_reg($constantoffset($con), $tmp$$Register);
 5974     __ ldf(FloatRegisterImpl::D, $constanttablebase, con_offset, as_DoubleFloatRegister($dst$$reg));
 5975   %}
 5976   ins_pipe(loadConFD);
 5977 %}
 5978 
 5979 // Prefetch instructions for allocation.
 5980 // Must be safe to execute with invalid address (cannot fault).
 5981 
 5982 instruct prefetchAlloc( memory mem ) %{
 5983   predicate(AllocatePrefetchInstr == 0);
 5984   match( PrefetchAllocation mem );
 5985   ins_cost(MEMORY_REF_COST);
 5986 
 5987   format %{ &quot;PREFETCH $mem,2\t! Prefetch allocation&quot; %}
 5988   opcode(Assembler::prefetch_op3);
 5989   ins_encode( form3_mem_prefetch_write( mem ) );
 5990   ins_pipe(iload_mem);
 5991 %}
 5992 
 5993 // Use BIS instruction to prefetch for allocation.
 5994 // Could fault, need space at the end of TLAB.
 5995 instruct prefetchAlloc_bis( iRegP dst ) %{
 5996   predicate(AllocatePrefetchInstr == 1);
 5997   match( PrefetchAllocation dst );
 5998   ins_cost(MEMORY_REF_COST);
 5999   size(4);
 6000 
 6001   format %{ &quot;STXA   [$dst]\t! // Prefetch allocation using BIS&quot; %}
 6002   ins_encode %{
 6003     __ stxa(G0, $dst$$Register, G0, Assembler::ASI_ST_BLKINIT_PRIMARY);
 6004   %}
 6005   ins_pipe(istore_mem_reg);
 6006 %}
 6007 
 6008 // Next code is used for finding next cache line address to prefetch.
 6009 instruct cacheLineAdr( iRegP dst, iRegP src, immL13 mask ) %{
 6010   match(Set dst (CastX2P (AndL (CastP2X src) mask)));
 6011   ins_cost(DEFAULT_COST);
 6012   size(4);
 6013 
 6014   format %{ &quot;AND    $src,$mask,$dst\t! next cache line address&quot; %}
 6015   ins_encode %{
 6016     __ and3($src$$Register, $mask$$constant, $dst$$Register);
 6017   %}
 6018   ins_pipe(ialu_reg_imm);
 6019 %}
 6020 
 6021 //----------Store Instructions-------------------------------------------------
 6022 // Store Byte
 6023 instruct storeB(memory mem, iRegI src) %{
 6024   match(Set mem (StoreB mem src));
 6025   ins_cost(MEMORY_REF_COST);
 6026 
 6027   format %{ &quot;STB    $src,$mem\t! byte&quot; %}
 6028   opcode(Assembler::stb_op3);
 6029   ins_encode(simple_form3_mem_reg( mem, src ) );
 6030   ins_pipe(istore_mem_reg);
 6031 %}
 6032 
 6033 instruct storeB0(memory mem, immI0 src) %{
 6034   match(Set mem (StoreB mem src));
 6035   ins_cost(MEMORY_REF_COST);
 6036 
 6037   format %{ &quot;STB    $src,$mem\t! byte&quot; %}
 6038   opcode(Assembler::stb_op3);
 6039   ins_encode(simple_form3_mem_reg( mem, R_G0 ) );
 6040   ins_pipe(istore_mem_zero);
 6041 %}
 6042 
 6043 instruct storeCM0(memory mem, immI0 src) %{
 6044   match(Set mem (StoreCM mem src));
 6045   ins_cost(MEMORY_REF_COST);
 6046 
 6047   format %{ &quot;STB    $src,$mem\t! CMS card-mark byte 0&quot; %}
 6048   opcode(Assembler::stb_op3);
 6049   ins_encode(simple_form3_mem_reg( mem, R_G0 ) );
 6050   ins_pipe(istore_mem_zero);
 6051 %}
 6052 
 6053 // Store Char/Short
 6054 instruct storeC(memory mem, iRegI src) %{
 6055   match(Set mem (StoreC mem src));
 6056   ins_cost(MEMORY_REF_COST);
 6057 
 6058   format %{ &quot;STH    $src,$mem\t! short&quot; %}
 6059   opcode(Assembler::sth_op3);
 6060   ins_encode(simple_form3_mem_reg( mem, src ) );
 6061   ins_pipe(istore_mem_reg);
 6062 %}
 6063 
 6064 instruct storeC0(memory mem, immI0 src) %{
 6065   match(Set mem (StoreC mem src));
 6066   ins_cost(MEMORY_REF_COST);
 6067 
 6068   format %{ &quot;STH    $src,$mem\t! short&quot; %}
 6069   opcode(Assembler::sth_op3);
 6070   ins_encode(simple_form3_mem_reg( mem, R_G0 ) );
 6071   ins_pipe(istore_mem_zero);
 6072 %}
 6073 
 6074 // Store Integer
 6075 instruct storeI(memory mem, iRegI src) %{
 6076   match(Set mem (StoreI mem src));
 6077   ins_cost(MEMORY_REF_COST);
 6078 
 6079   format %{ &quot;STW    $src,$mem&quot; %}
 6080   opcode(Assembler::stw_op3);
 6081   ins_encode(simple_form3_mem_reg( mem, src ) );
 6082   ins_pipe(istore_mem_reg);
 6083 %}
 6084 
 6085 // Store Long
 6086 instruct storeL(memory mem, iRegL src) %{
 6087   match(Set mem (StoreL mem src));
 6088   ins_cost(MEMORY_REF_COST);
 6089   format %{ &quot;STX    $src,$mem\t! long&quot; %}
 6090   opcode(Assembler::stx_op3);
 6091   ins_encode(simple_form3_mem_reg( mem, src ) );
 6092   ins_pipe(istore_mem_reg);
 6093 %}
 6094 
 6095 instruct storeI0(memory mem, immI0 src) %{
 6096   match(Set mem (StoreI mem src));
 6097   ins_cost(MEMORY_REF_COST);
 6098 
 6099   format %{ &quot;STW    $src,$mem&quot; %}
 6100   opcode(Assembler::stw_op3);
 6101   ins_encode(simple_form3_mem_reg( mem, R_G0 ) );
 6102   ins_pipe(istore_mem_zero);
 6103 %}
 6104 
 6105 instruct storeL0(memory mem, immL0 src) %{
 6106   match(Set mem (StoreL mem src));
 6107   ins_cost(MEMORY_REF_COST);
 6108 
 6109   format %{ &quot;STX    $src,$mem&quot; %}
 6110   opcode(Assembler::stx_op3);
 6111   ins_encode(simple_form3_mem_reg( mem, R_G0 ) );
 6112   ins_pipe(istore_mem_zero);
 6113 %}
 6114 
 6115 // Store Integer from float register (used after fstoi)
 6116 instruct storeI_Freg(memory mem, regF src) %{
 6117   match(Set mem (StoreI mem src));
 6118   ins_cost(MEMORY_REF_COST);
 6119 
 6120   format %{ &quot;STF    $src,$mem\t! after fstoi/fdtoi&quot; %}
 6121   opcode(Assembler::stf_op3);
 6122   ins_encode(simple_form3_mem_reg( mem, src ) );
 6123   ins_pipe(fstoreF_mem_reg);
 6124 %}
 6125 
 6126 // Store Pointer
 6127 instruct storeP(memory dst, sp_ptr_RegP src) %{
 6128   match(Set dst (StoreP dst src));
 6129   ins_cost(MEMORY_REF_COST);
 6130 
 6131   format %{ &quot;STX    $src,$dst\t! ptr&quot; %}
 6132   opcode(Assembler::stx_op3, 0, REGP_OP);
 6133   ins_encode( form3_mem_reg( dst, src ) );
 6134   ins_pipe(istore_mem_spORreg);
 6135 %}
 6136 
 6137 instruct storeP0(memory dst, immP0 src) %{
 6138   match(Set dst (StoreP dst src));
 6139   ins_cost(MEMORY_REF_COST);
 6140 
 6141   format %{ &quot;STX    $src,$dst\t! ptr&quot; %}
 6142   opcode(Assembler::stx_op3, 0, REGP_OP);
 6143   ins_encode( form3_mem_reg( dst, R_G0 ) );
 6144   ins_pipe(istore_mem_zero);
 6145 %}
 6146 
 6147 // Store Compressed Pointer
 6148 instruct storeN(memory dst, iRegN src) %{
 6149    match(Set dst (StoreN dst src));
 6150    ins_cost(MEMORY_REF_COST);
 6151    size(4);
 6152 
 6153    format %{ &quot;STW    $src,$dst\t! compressed ptr&quot; %}
 6154    ins_encode %{
 6155      Register base = as_Register($dst$$base);
 6156      Register index = as_Register($dst$$index);
 6157      Register src = $src$$Register;
 6158      if (index != G0) {
 6159        __ stw(src, base, index);
 6160      } else {
 6161        __ stw(src, base, $dst$$disp);
 6162      }
 6163    %}
 6164    ins_pipe(istore_mem_spORreg);
 6165 %}
 6166 
 6167 instruct storeNKlass(memory dst, iRegN src) %{
 6168    match(Set dst (StoreNKlass dst src));
 6169    ins_cost(MEMORY_REF_COST);
 6170    size(4);
 6171 
 6172    format %{ &quot;STW    $src,$dst\t! compressed klass ptr&quot; %}
 6173    ins_encode %{
 6174      Register base = as_Register($dst$$base);
 6175      Register index = as_Register($dst$$index);
 6176      Register src = $src$$Register;
 6177      if (index != G0) {
 6178        __ stw(src, base, index);
 6179      } else {
 6180        __ stw(src, base, $dst$$disp);
 6181      }
 6182    %}
 6183    ins_pipe(istore_mem_spORreg);
 6184 %}
 6185 
 6186 instruct storeN0(memory dst, immN0 src) %{
 6187    match(Set dst (StoreN dst src));
 6188    ins_cost(MEMORY_REF_COST);
 6189    size(4);
 6190 
 6191    format %{ &quot;STW    $src,$dst\t! compressed ptr&quot; %}
 6192    ins_encode %{
 6193      Register base = as_Register($dst$$base);
 6194      Register index = as_Register($dst$$index);
 6195      if (index != G0) {
 6196        __ stw(0, base, index);
 6197      } else {
 6198        __ stw(0, base, $dst$$disp);
 6199      }
 6200    %}
 6201    ins_pipe(istore_mem_zero);
 6202 %}
 6203 
 6204 // Store Double
 6205 instruct storeD( memory mem, regD src) %{
 6206   match(Set mem (StoreD mem src));
 6207   ins_cost(MEMORY_REF_COST);
 6208 
 6209   format %{ &quot;STDF   $src,$mem&quot; %}
 6210   opcode(Assembler::stdf_op3);
 6211   ins_encode(simple_form3_mem_reg( mem, src ) );
 6212   ins_pipe(fstoreD_mem_reg);
 6213 %}
 6214 
 6215 instruct storeD0( memory mem, immD0 src) %{
 6216   match(Set mem (StoreD mem src));
 6217   ins_cost(MEMORY_REF_COST);
 6218 
 6219   format %{ &quot;STX    $src,$mem&quot; %}
 6220   opcode(Assembler::stx_op3);
 6221   ins_encode(simple_form3_mem_reg( mem, R_G0 ) );
 6222   ins_pipe(fstoreD_mem_zero);
 6223 %}
 6224 
 6225 // Store Float
 6226 instruct storeF( memory mem, regF src) %{
 6227   match(Set mem (StoreF mem src));
 6228   ins_cost(MEMORY_REF_COST);
 6229 
 6230   format %{ &quot;STF    $src,$mem&quot; %}
 6231   opcode(Assembler::stf_op3);
 6232   ins_encode(simple_form3_mem_reg( mem, src ) );
 6233   ins_pipe(fstoreF_mem_reg);
 6234 %}
 6235 
 6236 instruct storeF0( memory mem, immF0 src) %{
 6237   match(Set mem (StoreF mem src));
 6238   ins_cost(MEMORY_REF_COST);
 6239 
 6240   format %{ &quot;STW    $src,$mem\t! storeF0&quot; %}
 6241   opcode(Assembler::stw_op3);
 6242   ins_encode(simple_form3_mem_reg( mem, R_G0 ) );
 6243   ins_pipe(fstoreF_mem_zero);
 6244 %}
 6245 
 6246 // Convert oop pointer into compressed form
 6247 instruct encodeHeapOop(iRegN dst, iRegP src) %{
 6248   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() != TypePtr::NotNull);
 6249   match(Set dst (EncodeP src));
 6250   format %{ &quot;encode_heap_oop $src, $dst&quot; %}
 6251   ins_encode %{
 6252     __ encode_heap_oop($src$$Register, $dst$$Register);
 6253   %}
 6254   ins_avoid_back_to_back(CompressedOops::base() == NULL ? AVOID_NONE : AVOID_BEFORE);
 6255   ins_pipe(ialu_reg);
 6256 %}
 6257 
 6258 instruct encodeHeapOop_not_null(iRegN dst, iRegP src) %{
 6259   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull);
 6260   match(Set dst (EncodeP src));
 6261   format %{ &quot;encode_heap_oop_not_null $src, $dst&quot; %}
 6262   ins_encode %{
 6263     __ encode_heap_oop_not_null($src$$Register, $dst$$Register);
 6264   %}
 6265   ins_pipe(ialu_reg);
 6266 %}
 6267 
 6268 instruct decodeHeapOop(iRegP dst, iRegN src) %{
 6269   predicate(n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() != TypePtr::NotNull &amp;&amp;
 6270             n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() != TypePtr::Constant);
 6271   match(Set dst (DecodeN src));
 6272   format %{ &quot;decode_heap_oop $src, $dst&quot; %}
 6273   ins_encode %{
 6274     __ decode_heap_oop($src$$Register, $dst$$Register);
 6275   %}
 6276   ins_pipe(ialu_reg);
 6277 %}
 6278 
 6279 instruct decodeHeapOop_not_null(iRegP dst, iRegN src) %{
 6280   predicate(n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::NotNull ||
 6281             n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::Constant);
 6282   match(Set dst (DecodeN src));
 6283   format %{ &quot;decode_heap_oop_not_null $src, $dst&quot; %}
 6284   ins_encode %{
 6285     __ decode_heap_oop_not_null($src$$Register, $dst$$Register);
 6286   %}
 6287   ins_pipe(ialu_reg);
 6288 %}
 6289 
 6290 instruct encodeKlass_not_null(iRegN dst, iRegP src) %{
 6291   match(Set dst (EncodePKlass src));
 6292   format %{ &quot;encode_klass_not_null $src, $dst&quot; %}
 6293   ins_encode %{
 6294     __ encode_klass_not_null($src$$Register, $dst$$Register);
 6295   %}
 6296   ins_pipe(ialu_reg);
 6297 %}
 6298 
 6299 instruct decodeKlass_not_null(iRegP dst, iRegN src) %{
 6300   match(Set dst (DecodeNKlass src));
 6301   format %{ &quot;decode_klass_not_null $src, $dst&quot; %}
 6302   ins_encode %{
 6303     __ decode_klass_not_null($src$$Register, $dst$$Register);
 6304   %}
 6305   ins_pipe(ialu_reg);
 6306 %}
 6307 
 6308 //----------MemBar Instructions-----------------------------------------------
 6309 // Memory barrier flavors
 6310 
 6311 instruct membar_acquire() %{
 6312   match(MemBarAcquire);
 6313   match(LoadFence);
 6314   ins_cost(4*MEMORY_REF_COST);
 6315 
 6316   size(0);
 6317   format %{ &quot;MEMBAR-acquire&quot; %}
 6318   ins_encode( enc_membar_acquire );
 6319   ins_pipe(long_memory_op);
 6320 %}
 6321 
 6322 instruct membar_acquire_lock() %{
 6323   match(MemBarAcquireLock);
 6324   ins_cost(0);
 6325 
 6326   size(0);
 6327   format %{ &quot;!MEMBAR-acquire (CAS in prior FastLock so empty encoding)&quot; %}
 6328   ins_encode( );
 6329   ins_pipe(empty);
 6330 %}
 6331 
 6332 instruct membar_release() %{
 6333   match(MemBarRelease);
 6334   match(StoreFence);
 6335   ins_cost(4*MEMORY_REF_COST);
 6336 
 6337   size(0);
 6338   format %{ &quot;MEMBAR-release&quot; %}
 6339   ins_encode( enc_membar_release );
 6340   ins_pipe(long_memory_op);
 6341 %}
 6342 
 6343 instruct membar_release_lock() %{
 6344   match(MemBarReleaseLock);
 6345   ins_cost(0);
 6346 
 6347   size(0);
 6348   format %{ &quot;!MEMBAR-release (CAS in succeeding FastUnlock so empty encoding)&quot; %}
 6349   ins_encode( );
 6350   ins_pipe(empty);
 6351 %}
 6352 
 6353 instruct membar_volatile() %{
 6354   match(MemBarVolatile);
 6355   ins_cost(4*MEMORY_REF_COST);
 6356 
 6357   size(4);
 6358   format %{ &quot;MEMBAR-volatile&quot; %}
 6359   ins_encode( enc_membar_volatile );
 6360   ins_pipe(long_memory_op);
 6361 %}
 6362 
 6363 instruct unnecessary_membar_volatile() %{
 6364   match(MemBarVolatile);
 6365   predicate(Matcher::post_store_load_barrier(n));
 6366   ins_cost(0);
 6367 
 6368   size(0);
 6369   format %{ &quot;!MEMBAR-volatile (unnecessary so empty encoding)&quot; %}
 6370   ins_encode( );
 6371   ins_pipe(empty);
 6372 %}
 6373 
 6374 instruct membar_storestore() %{
 6375   match(MemBarStoreStore);
 6376   ins_cost(0);
 6377 
 6378   size(0);
 6379   format %{ &quot;!MEMBAR-storestore (empty encoding)&quot; %}
 6380   ins_encode( );
 6381   ins_pipe(empty);
 6382 %}
 6383 
 6384 //----------Register Move Instructions-----------------------------------------
 6385 instruct roundDouble_nop(regD dst) %{
 6386   match(Set dst (RoundDouble dst));
 6387   ins_cost(0);
 6388   // SPARC results are already &quot;rounded&quot; (i.e., normal-format IEEE)
 6389   ins_encode( );
 6390   ins_pipe(empty);
 6391 %}
 6392 
 6393 
 6394 instruct roundFloat_nop(regF dst) %{
 6395   match(Set dst (RoundFloat dst));
 6396   ins_cost(0);
 6397   // SPARC results are already &quot;rounded&quot; (i.e., normal-format IEEE)
 6398   ins_encode( );
 6399   ins_pipe(empty);
 6400 %}
 6401 
 6402 
 6403 // Cast Index to Pointer for unsafe natives
 6404 instruct castX2P(iRegX src, iRegP dst) %{
 6405   match(Set dst (CastX2P src));
 6406 
 6407   format %{ &quot;MOV    $src,$dst\t! IntX-&gt;Ptr&quot; %}
 6408   ins_encode( form3_g0_rs2_rd_move( src, dst ) );
 6409   ins_pipe(ialu_reg);
 6410 %}
 6411 
 6412 // Cast Pointer to Index for unsafe natives
 6413 instruct castP2X(iRegP src, iRegX dst) %{
 6414   match(Set dst (CastP2X src));
 6415 
 6416   format %{ &quot;MOV    $src,$dst\t! Ptr-&gt;IntX&quot; %}
 6417   ins_encode( form3_g0_rs2_rd_move( src, dst ) );
 6418   ins_pipe(ialu_reg);
 6419 %}
 6420 
 6421 instruct stfSSD(stackSlotD stkSlot, regD src) %{
 6422   // %%%% TO DO: Tell the coalescer that this kind of node is a copy!
 6423   match(Set stkSlot src);   // chain rule
 6424   ins_cost(MEMORY_REF_COST);
 6425   format %{ &quot;STDF   $src,$stkSlot\t!stk&quot; %}
 6426   opcode(Assembler::stdf_op3);
 6427   ins_encode(simple_form3_mem_reg(stkSlot, src));
 6428   ins_pipe(fstoreD_stk_reg);
 6429 %}
 6430 
 6431 instruct ldfSSD(regD dst, stackSlotD stkSlot) %{
 6432   // %%%% TO DO: Tell the coalescer that this kind of node is a copy!
 6433   match(Set dst stkSlot);   // chain rule
 6434   ins_cost(MEMORY_REF_COST);
 6435   format %{ &quot;LDDF   $stkSlot,$dst\t!stk&quot; %}
 6436   opcode(Assembler::lddf_op3);
 6437   ins_encode(simple_form3_mem_reg(stkSlot, dst));
 6438   ins_pipe(floadD_stk);
 6439 %}
 6440 
 6441 instruct stfSSF(stackSlotF stkSlot, regF src) %{
 6442   // %%%% TO DO: Tell the coalescer that this kind of node is a copy!
 6443   match(Set stkSlot src);   // chain rule
 6444   ins_cost(MEMORY_REF_COST);
 6445   format %{ &quot;STF   $src,$stkSlot\t!stk&quot; %}
 6446   opcode(Assembler::stf_op3);
 6447   ins_encode(simple_form3_mem_reg(stkSlot, src));
 6448   ins_pipe(fstoreF_stk_reg);
 6449 %}
 6450 
 6451 //----------Conditional Move---------------------------------------------------
 6452 // Conditional move
 6453 instruct cmovIP_reg(cmpOpP cmp, flagsRegP pcc, iRegI dst, iRegI src) %{
 6454   match(Set dst (CMoveI (Binary cmp pcc) (Binary dst src)));
 6455   ins_cost(150);
 6456   format %{ &quot;MOV$cmp $pcc,$src,$dst&quot; %}
 6457   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::ptr_cc)) );
 6458   ins_pipe(ialu_reg);
 6459 %}
 6460 
 6461 instruct cmovIP_imm(cmpOpP cmp, flagsRegP pcc, iRegI dst, immI11 src) %{
 6462   match(Set dst (CMoveI (Binary cmp pcc) (Binary dst src)));
 6463   ins_cost(140);
 6464   format %{ &quot;MOV$cmp $pcc,$src,$dst&quot; %}
 6465   ins_encode( enc_cmov_imm(cmp,dst,src, (Assembler::ptr_cc)) );
 6466   ins_pipe(ialu_imm);
 6467 %}
 6468 
 6469 instruct cmovII_reg(cmpOp cmp, flagsReg icc, iRegI dst, iRegI src) %{
 6470   match(Set dst (CMoveI (Binary cmp icc) (Binary dst src)));
 6471   ins_cost(150);
 6472   size(4);
 6473   format %{ &quot;MOV$cmp  $icc,$src,$dst&quot; %}
 6474   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::icc)) );
 6475   ins_pipe(ialu_reg);
 6476 %}
 6477 
 6478 instruct cmovII_imm(cmpOp cmp, flagsReg icc, iRegI dst, immI11 src) %{
 6479   match(Set dst (CMoveI (Binary cmp icc) (Binary dst src)));
 6480   ins_cost(140);
 6481   size(4);
 6482   format %{ &quot;MOV$cmp  $icc,$src,$dst&quot; %}
 6483   ins_encode( enc_cmov_imm(cmp,dst,src, (Assembler::icc)) );
 6484   ins_pipe(ialu_imm);
 6485 %}
 6486 
 6487 instruct cmovIIu_reg(cmpOpU cmp, flagsRegU icc, iRegI dst, iRegI src) %{
 6488   match(Set dst (CMoveI (Binary cmp icc) (Binary dst src)));
 6489   ins_cost(150);
 6490   size(4);
 6491   format %{ &quot;MOV$cmp  $icc,$src,$dst&quot; %}
 6492   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::icc)) );
 6493   ins_pipe(ialu_reg);
 6494 %}
 6495 
 6496 instruct cmovIIu_imm(cmpOpU cmp, flagsRegU icc, iRegI dst, immI11 src) %{
 6497   match(Set dst (CMoveI (Binary cmp icc) (Binary dst src)));
 6498   ins_cost(140);
 6499   size(4);
 6500   format %{ &quot;MOV$cmp  $icc,$src,$dst&quot; %}
 6501   ins_encode( enc_cmov_imm(cmp,dst,src, (Assembler::icc)) );
 6502   ins_pipe(ialu_imm);
 6503 %}
 6504 
 6505 instruct cmovIF_reg(cmpOpF cmp, flagsRegF fcc, iRegI dst, iRegI src) %{
 6506   match(Set dst (CMoveI (Binary cmp fcc) (Binary dst src)));
 6507   ins_cost(150);
 6508   size(4);
 6509   format %{ &quot;MOV$cmp $fcc,$src,$dst&quot; %}
 6510   ins_encode( enc_cmov_reg_f(cmp,dst,src, fcc) );
 6511   ins_pipe(ialu_reg);
 6512 %}
 6513 
 6514 instruct cmovIF_imm(cmpOpF cmp, flagsRegF fcc, iRegI dst, immI11 src) %{
 6515   match(Set dst (CMoveI (Binary cmp fcc) (Binary dst src)));
 6516   ins_cost(140);
 6517   size(4);
 6518   format %{ &quot;MOV$cmp $fcc,$src,$dst&quot; %}
 6519   ins_encode( enc_cmov_imm_f(cmp,dst,src, fcc) );
 6520   ins_pipe(ialu_imm);
 6521 %}
 6522 
 6523 // Conditional move for RegN. Only cmov(reg,reg).
 6524 instruct cmovNP_reg(cmpOpP cmp, flagsRegP pcc, iRegN dst, iRegN src) %{
 6525   match(Set dst (CMoveN (Binary cmp pcc) (Binary dst src)));
 6526   ins_cost(150);
 6527   format %{ &quot;MOV$cmp $pcc,$src,$dst&quot; %}
 6528   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::ptr_cc)) );
 6529   ins_pipe(ialu_reg);
 6530 %}
 6531 
 6532 // This instruction also works with CmpN so we don&#39;t need cmovNN_reg.
 6533 instruct cmovNI_reg(cmpOp cmp, flagsReg icc, iRegN dst, iRegN src) %{
 6534   match(Set dst (CMoveN (Binary cmp icc) (Binary dst src)));
 6535   ins_cost(150);
 6536   size(4);
 6537   format %{ &quot;MOV$cmp  $icc,$src,$dst&quot; %}
 6538   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::icc)) );
 6539   ins_pipe(ialu_reg);
 6540 %}
 6541 
 6542 // This instruction also works with CmpN so we don&#39;t need cmovNN_reg.
 6543 instruct cmovNIu_reg(cmpOpU cmp, flagsRegU icc, iRegN dst, iRegN src) %{
 6544   match(Set dst (CMoveN (Binary cmp icc) (Binary dst src)));
 6545   ins_cost(150);
 6546   size(4);
 6547   format %{ &quot;MOV$cmp  $icc,$src,$dst&quot; %}
 6548   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::icc)) );
 6549   ins_pipe(ialu_reg);
 6550 %}
 6551 
 6552 instruct cmovNF_reg(cmpOpF cmp, flagsRegF fcc, iRegN dst, iRegN src) %{
 6553   match(Set dst (CMoveN (Binary cmp fcc) (Binary dst src)));
 6554   ins_cost(150);
 6555   size(4);
 6556   format %{ &quot;MOV$cmp $fcc,$src,$dst&quot; %}
 6557   ins_encode( enc_cmov_reg_f(cmp,dst,src, fcc) );
 6558   ins_pipe(ialu_reg);
 6559 %}
 6560 
 6561 // Conditional move
 6562 instruct cmovPP_reg(cmpOpP cmp, flagsRegP pcc, iRegP dst, iRegP src) %{
 6563   match(Set dst (CMoveP (Binary cmp pcc) (Binary dst src)));
 6564   ins_cost(150);
 6565   format %{ &quot;MOV$cmp $pcc,$src,$dst\t! ptr&quot; %}
 6566   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::ptr_cc)) );
 6567   ins_pipe(ialu_reg);
 6568 %}
 6569 
 6570 instruct cmovPP_imm(cmpOpP cmp, flagsRegP pcc, iRegP dst, immP0 src) %{
 6571   match(Set dst (CMoveP (Binary cmp pcc) (Binary dst src)));
 6572   ins_cost(140);
 6573   format %{ &quot;MOV$cmp $pcc,$src,$dst\t! ptr&quot; %}
 6574   ins_encode( enc_cmov_imm(cmp,dst,src, (Assembler::ptr_cc)) );
 6575   ins_pipe(ialu_imm);
 6576 %}
 6577 
 6578 // This instruction also works with CmpN so we don&#39;t need cmovPN_reg.
 6579 instruct cmovPI_reg(cmpOp cmp, flagsReg icc, iRegP dst, iRegP src) %{
 6580   match(Set dst (CMoveP (Binary cmp icc) (Binary dst src)));
 6581   ins_cost(150);
 6582 
 6583   size(4);
 6584   format %{ &quot;MOV$cmp  $icc,$src,$dst\t! ptr&quot; %}
 6585   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::icc)) );
 6586   ins_pipe(ialu_reg);
 6587 %}
 6588 
 6589 instruct cmovPIu_reg(cmpOpU cmp, flagsRegU icc, iRegP dst, iRegP src) %{
 6590   match(Set dst (CMoveP (Binary cmp icc) (Binary dst src)));
 6591   ins_cost(150);
 6592 
 6593   size(4);
 6594   format %{ &quot;MOV$cmp  $icc,$src,$dst\t! ptr&quot; %}
 6595   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::icc)) );
 6596   ins_pipe(ialu_reg);
 6597 %}
 6598 
 6599 instruct cmovPI_imm(cmpOp cmp, flagsReg icc, iRegP dst, immP0 src) %{
 6600   match(Set dst (CMoveP (Binary cmp icc) (Binary dst src)));
 6601   ins_cost(140);
 6602 
 6603   size(4);
 6604   format %{ &quot;MOV$cmp  $icc,$src,$dst\t! ptr&quot; %}
 6605   ins_encode( enc_cmov_imm(cmp,dst,src, (Assembler::icc)) );
 6606   ins_pipe(ialu_imm);
 6607 %}
 6608 
 6609 instruct cmovPIu_imm(cmpOpU cmp, flagsRegU icc, iRegP dst, immP0 src) %{
 6610   match(Set dst (CMoveP (Binary cmp icc) (Binary dst src)));
 6611   ins_cost(140);
 6612 
 6613   size(4);
 6614   format %{ &quot;MOV$cmp  $icc,$src,$dst\t! ptr&quot; %}
 6615   ins_encode( enc_cmov_imm(cmp,dst,src, (Assembler::icc)) );
 6616   ins_pipe(ialu_imm);
 6617 %}
 6618 
 6619 instruct cmovPF_reg(cmpOpF cmp, flagsRegF fcc, iRegP dst, iRegP src) %{
 6620   match(Set dst (CMoveP (Binary cmp fcc) (Binary dst src)));
 6621   ins_cost(150);
 6622   size(4);
 6623   format %{ &quot;MOV$cmp $fcc,$src,$dst&quot; %}
 6624   ins_encode( enc_cmov_reg_f(cmp,dst,src, fcc) );
 6625   ins_pipe(ialu_imm);
 6626 %}
 6627 
 6628 instruct cmovPF_imm(cmpOpF cmp, flagsRegF fcc, iRegP dst, immP0 src) %{
 6629   match(Set dst (CMoveP (Binary cmp fcc) (Binary dst src)));
 6630   ins_cost(140);
 6631   size(4);
 6632   format %{ &quot;MOV$cmp $fcc,$src,$dst&quot; %}
 6633   ins_encode( enc_cmov_imm_f(cmp,dst,src, fcc) );
 6634   ins_pipe(ialu_imm);
 6635 %}
 6636 
 6637 // Conditional move
 6638 instruct cmovFP_reg(cmpOpP cmp, flagsRegP pcc, regF dst, regF src) %{
 6639   match(Set dst (CMoveF (Binary cmp pcc) (Binary dst src)));
 6640   ins_cost(150);
 6641   opcode(0x101);
 6642   format %{ &quot;FMOVD$cmp $pcc,$src,$dst&quot; %}
 6643   ins_encode( enc_cmovf_reg(cmp,dst,src, (Assembler::ptr_cc)) );
 6644   ins_pipe(int_conditional_float_move);
 6645 %}
 6646 
 6647 instruct cmovFI_reg(cmpOp cmp, flagsReg icc, regF dst, regF src) %{
 6648   match(Set dst (CMoveF (Binary cmp icc) (Binary dst src)));
 6649   ins_cost(150);
 6650 
 6651   size(4);
 6652   format %{ &quot;FMOVS$cmp $icc,$src,$dst&quot; %}
 6653   opcode(0x101);
 6654   ins_encode( enc_cmovf_reg(cmp,dst,src, (Assembler::icc)) );
 6655   ins_pipe(int_conditional_float_move);
 6656 %}
 6657 
 6658 instruct cmovFIu_reg(cmpOpU cmp, flagsRegU icc, regF dst, regF src) %{
 6659   match(Set dst (CMoveF (Binary cmp icc) (Binary dst src)));
 6660   ins_cost(150);
 6661 
 6662   size(4);
 6663   format %{ &quot;FMOVS$cmp $icc,$src,$dst&quot; %}
 6664   opcode(0x101);
 6665   ins_encode( enc_cmovf_reg(cmp,dst,src, (Assembler::icc)) );
 6666   ins_pipe(int_conditional_float_move);
 6667 %}
 6668 
 6669 // Conditional move,
 6670 instruct cmovFF_reg(cmpOpF cmp, flagsRegF fcc, regF dst, regF src) %{
 6671   match(Set dst (CMoveF (Binary cmp fcc) (Binary dst src)));
 6672   ins_cost(150);
 6673   size(4);
 6674   format %{ &quot;FMOVF$cmp $fcc,$src,$dst&quot; %}
 6675   opcode(0x1);
 6676   ins_encode( enc_cmovff_reg(cmp,fcc,dst,src) );
 6677   ins_pipe(int_conditional_double_move);
 6678 %}
 6679 
 6680 // Conditional move
 6681 instruct cmovDP_reg(cmpOpP cmp, flagsRegP pcc, regD dst, regD src) %{
 6682   match(Set dst (CMoveD (Binary cmp pcc) (Binary dst src)));
 6683   ins_cost(150);
 6684   size(4);
 6685   opcode(0x102);
 6686   format %{ &quot;FMOVD$cmp $pcc,$src,$dst&quot; %}
 6687   ins_encode( enc_cmovf_reg(cmp,dst,src, (Assembler::ptr_cc)) );
 6688   ins_pipe(int_conditional_double_move);
 6689 %}
 6690 
 6691 instruct cmovDI_reg(cmpOp cmp, flagsReg icc, regD dst, regD src) %{
 6692   match(Set dst (CMoveD (Binary cmp icc) (Binary dst src)));
 6693   ins_cost(150);
 6694 
 6695   size(4);
 6696   format %{ &quot;FMOVD$cmp $icc,$src,$dst&quot; %}
 6697   opcode(0x102);
 6698   ins_encode( enc_cmovf_reg(cmp,dst,src, (Assembler::icc)) );
 6699   ins_pipe(int_conditional_double_move);
 6700 %}
 6701 
 6702 instruct cmovDIu_reg(cmpOpU cmp, flagsRegU icc, regD dst, regD src) %{
 6703   match(Set dst (CMoveD (Binary cmp icc) (Binary dst src)));
 6704   ins_cost(150);
 6705 
 6706   size(4);
 6707   format %{ &quot;FMOVD$cmp $icc,$src,$dst&quot; %}
 6708   opcode(0x102);
 6709   ins_encode( enc_cmovf_reg(cmp,dst,src, (Assembler::icc)) );
 6710   ins_pipe(int_conditional_double_move);
 6711 %}
 6712 
 6713 // Conditional move,
 6714 instruct cmovDF_reg(cmpOpF cmp, flagsRegF fcc, regD dst, regD src) %{
 6715   match(Set dst (CMoveD (Binary cmp fcc) (Binary dst src)));
 6716   ins_cost(150);
 6717   size(4);
 6718   format %{ &quot;FMOVD$cmp $fcc,$src,$dst&quot; %}
 6719   opcode(0x2);
 6720   ins_encode( enc_cmovff_reg(cmp,fcc,dst,src) );
 6721   ins_pipe(int_conditional_double_move);
 6722 %}
 6723 
 6724 // Conditional move
 6725 instruct cmovLP_reg(cmpOpP cmp, flagsRegP pcc, iRegL dst, iRegL src) %{
 6726   match(Set dst (CMoveL (Binary cmp pcc) (Binary dst src)));
 6727   ins_cost(150);
 6728   format %{ &quot;MOV$cmp $pcc,$src,$dst\t! long&quot; %}
 6729   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::ptr_cc)) );
 6730   ins_pipe(ialu_reg);
 6731 %}
 6732 
 6733 instruct cmovLP_imm(cmpOpP cmp, flagsRegP pcc, iRegL dst, immI11 src) %{
 6734   match(Set dst (CMoveL (Binary cmp pcc) (Binary dst src)));
 6735   ins_cost(140);
 6736   format %{ &quot;MOV$cmp $pcc,$src,$dst\t! long&quot; %}
 6737   ins_encode( enc_cmov_imm(cmp,dst,src, (Assembler::ptr_cc)) );
 6738   ins_pipe(ialu_imm);
 6739 %}
 6740 
 6741 instruct cmovLI_reg(cmpOp cmp, flagsReg icc, iRegL dst, iRegL src) %{
 6742   match(Set dst (CMoveL (Binary cmp icc) (Binary dst src)));
 6743   ins_cost(150);
 6744 
 6745   size(4);
 6746   format %{ &quot;MOV$cmp  $icc,$src,$dst\t! long&quot; %}
 6747   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::icc)) );
 6748   ins_pipe(ialu_reg);
 6749 %}
 6750 
 6751 
 6752 instruct cmovLIu_reg(cmpOpU cmp, flagsRegU icc, iRegL dst, iRegL src) %{
 6753   match(Set dst (CMoveL (Binary cmp icc) (Binary dst src)));
 6754   ins_cost(150);
 6755 
 6756   size(4);
 6757   format %{ &quot;MOV$cmp  $icc,$src,$dst\t! long&quot; %}
 6758   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::icc)) );
 6759   ins_pipe(ialu_reg);
 6760 %}
 6761 
 6762 
 6763 instruct cmovLF_reg(cmpOpF cmp, flagsRegF fcc, iRegL dst, iRegL src) %{
 6764   match(Set dst (CMoveL (Binary cmp fcc) (Binary dst src)));
 6765   ins_cost(150);
 6766 
 6767   size(4);
 6768   format %{ &quot;MOV$cmp  $fcc,$src,$dst\t! long&quot; %}
 6769   ins_encode( enc_cmov_reg_f(cmp,dst,src, fcc) );
 6770   ins_pipe(ialu_reg);
 6771 %}
 6772 
 6773 
 6774 
 6775 //----------OS and Locking Instructions----------------------------------------
 6776 
 6777 // This name is KNOWN by the ADLC and cannot be changed.
 6778 // The ADLC forces a &#39;TypeRawPtr::BOTTOM&#39; output type
 6779 // for this guy.
 6780 instruct tlsLoadP(g2RegP dst) %{
 6781   match(Set dst (ThreadLocal));
 6782 
 6783   size(0);
 6784   ins_cost(0);
 6785   format %{ &quot;# TLS is in G2&quot; %}
 6786   ins_encode( /*empty encoding*/ );
 6787   ins_pipe(ialu_none);
 6788 %}
 6789 
 6790 instruct checkCastPP( iRegP dst ) %{
 6791   match(Set dst (CheckCastPP dst));
 6792 
 6793   size(0);
 6794   format %{ &quot;# checkcastPP of $dst&quot; %}
 6795   ins_encode( /*empty encoding*/ );
 6796   ins_pipe(empty);
 6797 %}
 6798 
 6799 
 6800 instruct castPP( iRegP dst ) %{
 6801   match(Set dst (CastPP dst));
 6802   format %{ &quot;# castPP of $dst&quot; %}
 6803   ins_encode( /*empty encoding*/ );
 6804   ins_pipe(empty);
 6805 %}
 6806 
 6807 instruct castII( iRegI dst ) %{
 6808   match(Set dst (CastII dst));
 6809   format %{ &quot;# castII of $dst&quot; %}
 6810   ins_encode( /*empty encoding*/ );
 6811   ins_cost(0);
 6812   ins_pipe(empty);
 6813 %}
 6814 
 6815 instruct castLL( iRegL dst ) %{
 6816   match(Set dst (CastLL dst));
 6817   format %{ &quot;# castLL of $dst&quot; %}
 6818   ins_encode( /*empty encoding*/ );
 6819   ins_cost(0);
 6820   ins_pipe(empty);
 6821 %}
 6822 
 6823 //----------Arithmetic Instructions--------------------------------------------
 6824 // Addition Instructions
 6825 // Register Addition
 6826 instruct addI_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
 6827   match(Set dst (AddI src1 src2));
 6828 
 6829   size(4);
 6830   format %{ &quot;ADD    $src1,$src2,$dst&quot; %}
 6831   ins_encode %{
 6832     __ add($src1$$Register, $src2$$Register, $dst$$Register);
 6833   %}
 6834   ins_pipe(ialu_reg_reg);
 6835 %}
 6836 
 6837 // Immediate Addition
 6838 instruct addI_reg_imm13(iRegI dst, iRegI src1, immI13 src2) %{
 6839   match(Set dst (AddI src1 src2));
 6840 
 6841   size(4);
 6842   format %{ &quot;ADD    $src1,$src2,$dst&quot; %}
 6843   opcode(Assembler::add_op3, Assembler::arith_op);
 6844   ins_encode( form3_rs1_simm13_rd( src1, src2, dst ) );
 6845   ins_pipe(ialu_reg_imm);
 6846 %}
 6847 
 6848 // Pointer Register Addition
 6849 instruct addP_reg_reg(iRegP dst, iRegP src1, iRegX src2) %{
 6850   match(Set dst (AddP src1 src2));
 6851 
 6852   size(4);
 6853   format %{ &quot;ADD    $src1,$src2,$dst&quot; %}
 6854   opcode(Assembler::add_op3, Assembler::arith_op);
 6855   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 6856   ins_pipe(ialu_reg_reg);
 6857 %}
 6858 
 6859 // Pointer Immediate Addition
 6860 instruct addP_reg_imm13(iRegP dst, iRegP src1, immX13 src2) %{
 6861   match(Set dst (AddP src1 src2));
 6862 
 6863   size(4);
 6864   format %{ &quot;ADD    $src1,$src2,$dst&quot; %}
 6865   opcode(Assembler::add_op3, Assembler::arith_op);
 6866   ins_encode( form3_rs1_simm13_rd( src1, src2, dst ) );
 6867   ins_pipe(ialu_reg_imm);
 6868 %}
 6869 
 6870 // Long Addition
 6871 instruct addL_reg_reg(iRegL dst, iRegL src1, iRegL src2) %{
 6872   match(Set dst (AddL src1 src2));
 6873 
 6874   size(4);
 6875   format %{ &quot;ADD    $src1,$src2,$dst\t! long&quot; %}
 6876   opcode(Assembler::add_op3, Assembler::arith_op);
 6877   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 6878   ins_pipe(ialu_reg_reg);
 6879 %}
 6880 
 6881 instruct addL_reg_imm13(iRegL dst, iRegL src1, immL13 con) %{
 6882   match(Set dst (AddL src1 con));
 6883 
 6884   size(4);
 6885   format %{ &quot;ADD    $src1,$con,$dst&quot; %}
 6886   opcode(Assembler::add_op3, Assembler::arith_op);
 6887   ins_encode( form3_rs1_simm13_rd( src1, con, dst ) );
 6888   ins_pipe(ialu_reg_imm);
 6889 %}
 6890 
 6891 //----------Conditional_store--------------------------------------------------
 6892 // Conditional-store of the updated heap-top.
 6893 // Used during allocation of the shared heap.
 6894 // Sets flags (EQ) on success.  Implemented with a CASA on Sparc.
 6895 
 6896 // LoadP-locked.  Same as a regular pointer load when used with a compare-swap
 6897 instruct loadPLocked(iRegP dst, memory mem) %{
 6898   match(Set dst (LoadPLocked mem));
 6899   ins_cost(MEMORY_REF_COST);
 6900 
 6901   format %{ &quot;LDX    $mem,$dst\t! ptr&quot; %}
 6902   opcode(Assembler::ldx_op3, 0, REGP_OP);
 6903   ins_encode( form3_mem_reg( mem, dst ) );
 6904   ins_pipe(iload_mem);
 6905 %}
 6906 
 6907 instruct storePConditional( iRegP heap_top_ptr, iRegP oldval, g3RegP newval, flagsRegP pcc ) %{
 6908   match(Set pcc (StorePConditional heap_top_ptr (Binary oldval newval)));
 6909   effect( KILL newval );
 6910   format %{ &quot;CASA   [$heap_top_ptr],$oldval,R_G3\t! If $oldval==[$heap_top_ptr] Then store R_G3 into [$heap_top_ptr], set R_G3=[$heap_top_ptr] in any case\n\t&quot;
 6911             &quot;CMP    R_G3,$oldval\t\t! See if we made progress&quot;  %}
 6912   ins_encode( enc_cas(heap_top_ptr,oldval,newval) );
 6913   ins_pipe( long_memory_op );
 6914 %}
 6915 
 6916 // Conditional-store of an int value.
 6917 instruct storeIConditional( iRegP mem_ptr, iRegI oldval, g3RegI newval, flagsReg icc ) %{
 6918   match(Set icc (StoreIConditional mem_ptr (Binary oldval newval)));
 6919   effect( KILL newval );
 6920   format %{ &quot;CASA   [$mem_ptr],$oldval,$newval\t! If $oldval==[$mem_ptr] Then store $newval into [$mem_ptr], set $newval=[$mem_ptr] in any case\n\t&quot;
 6921             &quot;CMP    $oldval,$newval\t\t! See if we made progress&quot;  %}
 6922   ins_encode( enc_cas(mem_ptr,oldval,newval) );
 6923   ins_pipe( long_memory_op );
 6924 %}
 6925 
 6926 // Conditional-store of a long value.
 6927 instruct storeLConditional( iRegP mem_ptr, iRegL oldval, g3RegL newval, flagsRegL xcc ) %{
 6928   match(Set xcc (StoreLConditional mem_ptr (Binary oldval newval)));
 6929   effect( KILL newval );
 6930   format %{ &quot;CASXA  [$mem_ptr],$oldval,$newval\t! If $oldval==[$mem_ptr] Then store $newval into [$mem_ptr], set $newval=[$mem_ptr] in any case\n\t&quot;
 6931             &quot;CMP    $oldval,$newval\t\t! See if we made progress&quot;  %}
 6932   ins_encode( enc_cas(mem_ptr,oldval,newval) );
 6933   ins_pipe( long_memory_op );
 6934 %}
 6935 
 6936 // No flag versions for CompareAndSwap{P,I,L} because matcher can&#39;t match them
 6937 
 6938 instruct compareAndSwapL_bool(iRegP mem_ptr, iRegL oldval, iRegL newval, iRegI res, o7RegI tmp1, flagsReg ccr ) %{
 6939   predicate(VM_Version::supports_cx8());
 6940   match(Set res (CompareAndSwapL mem_ptr (Binary oldval newval)));
 6941   match(Set res (WeakCompareAndSwapL mem_ptr (Binary oldval newval)));
 6942   effect( USE mem_ptr, KILL ccr, KILL tmp1);
 6943   format %{
 6944             &quot;MOV    $newval,O7\n\t&quot;
 6945             &quot;CASXA  [$mem_ptr],$oldval,O7\t! If $oldval==[$mem_ptr] Then store O7 into [$mem_ptr], set O7=[$mem_ptr] in any case\n\t&quot;
 6946             &quot;CMP    $oldval,O7\t\t! See if we made progress\n\t&quot;
 6947             &quot;MOV    1,$res\n\t&quot;
 6948             &quot;MOVne  xcc,R_G0,$res&quot;
 6949   %}
 6950   ins_encode( enc_casx(mem_ptr, oldval, newval),
 6951               enc_lflags_ne_to_boolean(res) );
 6952   ins_pipe( long_memory_op );
 6953 %}
 6954 
 6955 
 6956 instruct compareAndSwapI_bool(iRegP mem_ptr, iRegI oldval, iRegI newval, iRegI res, o7RegI tmp1, flagsReg ccr ) %{
 6957   match(Set res (CompareAndSwapI mem_ptr (Binary oldval newval)));
 6958   match(Set res (WeakCompareAndSwapI mem_ptr (Binary oldval newval)));
 6959   effect( USE mem_ptr, KILL ccr, KILL tmp1);
 6960   format %{
 6961             &quot;MOV    $newval,O7\n\t&quot;
 6962             &quot;CASA   [$mem_ptr],$oldval,O7\t! If $oldval==[$mem_ptr] Then store O7 into [$mem_ptr], set O7=[$mem_ptr] in any case\n\t&quot;
 6963             &quot;CMP    $oldval,O7\t\t! See if we made progress\n\t&quot;
 6964             &quot;MOV    1,$res\n\t&quot;
 6965             &quot;MOVne  icc,R_G0,$res&quot;
 6966   %}
 6967   ins_encode( enc_casi(mem_ptr, oldval, newval),
 6968               enc_iflags_ne_to_boolean(res) );
 6969   ins_pipe( long_memory_op );
 6970 %}
 6971 
 6972 instruct compareAndSwapP_bool(iRegP mem_ptr, iRegP oldval, iRegP newval, iRegI res, o7RegI tmp1, flagsReg ccr ) %{
 6973   predicate(VM_Version::supports_cx8());
 6974   match(Set res (CompareAndSwapP mem_ptr (Binary oldval newval)));
 6975   match(Set res (WeakCompareAndSwapP mem_ptr (Binary oldval newval)));
 6976   effect( USE mem_ptr, KILL ccr, KILL tmp1);
 6977   format %{
 6978             &quot;MOV    $newval,O7\n\t&quot;
 6979             &quot;CASA_PTR  [$mem_ptr],$oldval,O7\t! If $oldval==[$mem_ptr] Then store O7 into [$mem_ptr], set O7=[$mem_ptr] in any case\n\t&quot;
 6980             &quot;CMP    $oldval,O7\t\t! See if we made progress\n\t&quot;
 6981             &quot;MOV    1,$res\n\t&quot;
 6982             &quot;MOVne  xcc,R_G0,$res&quot;
 6983   %}
 6984   ins_encode( enc_casx(mem_ptr, oldval, newval),
 6985               enc_lflags_ne_to_boolean(res) );
 6986   ins_pipe( long_memory_op );
 6987 %}
 6988 
 6989 instruct compareAndSwapN_bool(iRegP mem_ptr, iRegN oldval, iRegN newval, iRegI res, o7RegI tmp1, flagsReg ccr ) %{
 6990   match(Set res (CompareAndSwapN mem_ptr (Binary oldval newval)));
 6991   match(Set res (WeakCompareAndSwapN mem_ptr (Binary oldval newval)));
 6992   effect( USE mem_ptr, KILL ccr, KILL tmp1);
 6993   format %{
 6994             &quot;MOV    $newval,O7\n\t&quot;
 6995             &quot;CASA   [$mem_ptr],$oldval,O7\t! If $oldval==[$mem_ptr] Then store O7 into [$mem_ptr], set O7=[$mem_ptr] in any case\n\t&quot;
 6996             &quot;CMP    $oldval,O7\t\t! See if we made progress\n\t&quot;
 6997             &quot;MOV    1,$res\n\t&quot;
 6998             &quot;MOVne  icc,R_G0,$res&quot;
 6999   %}
 7000   ins_encode( enc_casi(mem_ptr, oldval, newval),
 7001               enc_iflags_ne_to_boolean(res) );
 7002   ins_pipe( long_memory_op );
 7003 %}
 7004 
 7005 instruct compareAndExchangeI(iRegP mem_ptr, iRegI oldval, iRegI newval)
 7006 %{
 7007   match(Set newval (CompareAndExchangeI mem_ptr (Binary oldval newval)));
 7008   effect( USE mem_ptr );
 7009 
 7010   format %{
 7011             &quot;CASA   [$mem_ptr],$oldval,$newval\t! If $oldval==[$mem_ptr] Then store $newval into [$mem_ptr] and set $newval=[$mem_ptr]\n\t&quot;
 7012   %}
 7013   ins_encode( enc_casi_exch(mem_ptr, oldval, newval) );
 7014   ins_pipe( long_memory_op );
 7015 %}
 7016 
 7017 instruct compareAndExchangeL(iRegP mem_ptr, iRegL oldval, iRegL newval)
 7018 %{
 7019   match(Set newval (CompareAndExchangeL mem_ptr (Binary oldval newval)));
 7020   effect( USE mem_ptr );
 7021 
 7022   format %{
 7023             &quot;CASXA  [$mem_ptr],$oldval,$newval\t! If $oldval==[$mem_ptr] Then store $newval into [$mem_ptr] and set $newval=[$mem_ptr]\n\t&quot;
 7024   %}
 7025   ins_encode( enc_casx_exch(mem_ptr, oldval, newval) );
 7026   ins_pipe( long_memory_op );
 7027 %}
 7028 
 7029 instruct compareAndExchangeP(iRegP mem_ptr, iRegP oldval, iRegP newval)
 7030 %{
 7031   match(Set newval (CompareAndExchangeP mem_ptr (Binary oldval newval)));
 7032   effect( USE mem_ptr );
 7033 
 7034   format %{
 7035             &quot;CASXA  [$mem_ptr],$oldval,$newval\t! If $oldval==[$mem_ptr] Then store $newval into [$mem_ptr] and set $newval=[$mem_ptr]\n\t&quot;
 7036   %}
 7037   ins_encode( enc_casx_exch(mem_ptr, oldval, newval) );
 7038   ins_pipe( long_memory_op );
 7039 %}
 7040 
 7041 instruct compareAndExchangeN(iRegP mem_ptr, iRegN oldval, iRegN newval)
 7042 %{
 7043   match(Set newval (CompareAndExchangeN mem_ptr (Binary oldval newval)));
 7044   effect( USE mem_ptr );
 7045 
 7046   format %{
 7047             &quot;CASA   [$mem_ptr],$oldval,$newval\t! If $oldval==[$mem_ptr] Then store $newval into [$mem_ptr] and set $newval=[$mem_ptr]\n\t&quot;
 7048   %}
 7049   ins_encode( enc_casi_exch(mem_ptr, oldval, newval) );
 7050   ins_pipe( long_memory_op );
 7051 %}
 7052 
 7053 instruct xchgI( memory mem, iRegI newval) %{
 7054   match(Set newval (GetAndSetI mem newval));
 7055   format %{ &quot;SWAP  [$mem],$newval&quot; %}
 7056   size(4);
 7057   ins_encode %{
 7058     __ swap($mem$$Address, $newval$$Register);
 7059   %}
 7060   ins_pipe( long_memory_op );
 7061 %}
 7062 
 7063 
 7064 instruct xchgN( memory mem, iRegN newval) %{
 7065   match(Set newval (GetAndSetN mem newval));
 7066   format %{ &quot;SWAP  [$mem],$newval&quot; %}
 7067   size(4);
 7068   ins_encode %{
 7069     __ swap($mem$$Address, $newval$$Register);
 7070   %}
 7071   ins_pipe( long_memory_op );
 7072 %}
 7073 
 7074 //---------------------
 7075 // Subtraction Instructions
 7076 // Register Subtraction
 7077 instruct subI_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
 7078   match(Set dst (SubI src1 src2));
 7079 
 7080   size(4);
 7081   format %{ &quot;SUB    $src1,$src2,$dst&quot; %}
 7082   opcode(Assembler::sub_op3, Assembler::arith_op);
 7083   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7084   ins_pipe(ialu_reg_reg);
 7085 %}
 7086 
 7087 // Immediate Subtraction
 7088 instruct subI_reg_imm13(iRegI dst, iRegI src1, immI13 src2) %{
 7089   match(Set dst (SubI src1 src2));
 7090 
 7091   size(4);
 7092   format %{ &quot;SUB    $src1,$src2,$dst&quot; %}
 7093   opcode(Assembler::sub_op3, Assembler::arith_op);
 7094   ins_encode( form3_rs1_simm13_rd( src1, src2, dst ) );
 7095   ins_pipe(ialu_reg_imm);
 7096 %}
 7097 
 7098 instruct subI_zero_reg(iRegI dst, immI0 zero, iRegI src2) %{
 7099   match(Set dst (SubI zero src2));
 7100 
 7101   size(4);
 7102   format %{ &quot;NEG    $src2,$dst&quot; %}
 7103   opcode(Assembler::sub_op3, Assembler::arith_op);
 7104   ins_encode( form3_rs1_rs2_rd( R_G0, src2, dst ) );
 7105   ins_pipe(ialu_zero_reg);
 7106 %}
 7107 
 7108 // Long subtraction
 7109 instruct subL_reg_reg(iRegL dst, iRegL src1, iRegL src2) %{
 7110   match(Set dst (SubL src1 src2));
 7111 
 7112   size(4);
 7113   format %{ &quot;SUB    $src1,$src2,$dst\t! long&quot; %}
 7114   opcode(Assembler::sub_op3, Assembler::arith_op);
 7115   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7116   ins_pipe(ialu_reg_reg);
 7117 %}
 7118 
 7119 // Immediate Subtraction
 7120 instruct subL_reg_imm13(iRegL dst, iRegL src1, immL13 con) %{
 7121   match(Set dst (SubL src1 con));
 7122 
 7123   size(4);
 7124   format %{ &quot;SUB    $src1,$con,$dst\t! long&quot; %}
 7125   opcode(Assembler::sub_op3, Assembler::arith_op);
 7126   ins_encode( form3_rs1_simm13_rd( src1, con, dst ) );
 7127   ins_pipe(ialu_reg_imm);
 7128 %}
 7129 
 7130 // Long negation
 7131 instruct negL_reg_reg(iRegL dst, immL0 zero, iRegL src2) %{
 7132   match(Set dst (SubL zero src2));
 7133 
 7134   size(4);
 7135   format %{ &quot;NEG    $src2,$dst\t! long&quot; %}
 7136   opcode(Assembler::sub_op3, Assembler::arith_op);
 7137   ins_encode( form3_rs1_rs2_rd( R_G0, src2, dst ) );
 7138   ins_pipe(ialu_zero_reg);
 7139 %}
 7140 
 7141 // Multiplication Instructions
 7142 // Integer Multiplication
 7143 // Register Multiplication
 7144 instruct mulI_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
 7145   match(Set dst (MulI src1 src2));
 7146 
 7147   size(4);
 7148   format %{ &quot;MULX   $src1,$src2,$dst&quot; %}
 7149   opcode(Assembler::mulx_op3, Assembler::arith_op);
 7150   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7151   ins_pipe(imul_reg_reg);
 7152 %}
 7153 
 7154 // Immediate Multiplication
 7155 instruct mulI_reg_imm13(iRegI dst, iRegI src1, immI13 src2) %{
 7156   match(Set dst (MulI src1 src2));
 7157 
 7158   size(4);
 7159   format %{ &quot;MULX   $src1,$src2,$dst&quot; %}
 7160   opcode(Assembler::mulx_op3, Assembler::arith_op);
 7161   ins_encode( form3_rs1_simm13_rd( src1, src2, dst ) );
 7162   ins_pipe(imul_reg_imm);
 7163 %}
 7164 
 7165 instruct mulL_reg_reg(iRegL dst, iRegL src1, iRegL src2) %{
 7166   match(Set dst (MulL src1 src2));
 7167   ins_cost(DEFAULT_COST * 5);
 7168   size(4);
 7169   format %{ &quot;MULX   $src1,$src2,$dst\t! long&quot; %}
 7170   opcode(Assembler::mulx_op3, Assembler::arith_op);
 7171   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7172   ins_pipe(mulL_reg_reg);
 7173 %}
 7174 
 7175 // Immediate Multiplication
 7176 instruct mulL_reg_imm13(iRegL dst, iRegL src1, immL13 src2) %{
 7177   match(Set dst (MulL src1 src2));
 7178   ins_cost(DEFAULT_COST * 5);
 7179   size(4);
 7180   format %{ &quot;MULX   $src1,$src2,$dst&quot; %}
 7181   opcode(Assembler::mulx_op3, Assembler::arith_op);
 7182   ins_encode( form3_rs1_simm13_rd( src1, src2, dst ) );
 7183   ins_pipe(mulL_reg_imm);
 7184 %}
 7185 
 7186 // Integer Division
 7187 // Register Division
 7188 instruct divI_reg_reg(iRegI dst, iRegIsafe src1, iRegIsafe src2) %{
 7189   match(Set dst (DivI src1 src2));
 7190   ins_cost((2+71)*DEFAULT_COST);
 7191 
 7192   format %{ &quot;SRA     $src2,0,$src2\n\t&quot;
 7193             &quot;SRA     $src1,0,$src1\n\t&quot;
 7194             &quot;SDIVX   $src1,$src2,$dst&quot; %}
 7195   ins_encode( idiv_reg( src1, src2, dst ) );
 7196   ins_pipe(sdiv_reg_reg);
 7197 %}
 7198 
 7199 // Immediate Division
 7200 instruct divI_reg_imm13(iRegI dst, iRegIsafe src1, immI13 src2) %{
 7201   match(Set dst (DivI src1 src2));
 7202   ins_cost((2+71)*DEFAULT_COST);
 7203 
 7204   format %{ &quot;SRA     $src1,0,$src1\n\t&quot;
 7205             &quot;SDIVX   $src1,$src2,$dst&quot; %}
 7206   ins_encode( idiv_imm( src1, src2, dst ) );
 7207   ins_pipe(sdiv_reg_imm);
 7208 %}
 7209 
 7210 //----------Div-By-10-Expansion------------------------------------------------
 7211 // Extract hi bits of a 32x32-&gt;64 bit multiply.
 7212 // Expand rule only, not matched
 7213 instruct mul_hi(iRegIsafe dst, iRegIsafe src1, iRegIsafe src2 ) %{
 7214   effect( DEF dst, USE src1, USE src2 );
 7215   format %{ &quot;MULX   $src1,$src2,$dst\t! Used in div-by-10\n\t&quot;
 7216             &quot;SRLX   $dst,#32,$dst\t\t! Extract only hi word of result&quot; %}
 7217   ins_encode( enc_mul_hi(dst,src1,src2));
 7218   ins_pipe(sdiv_reg_reg);
 7219 %}
 7220 
 7221 // Magic constant, reciprocal of 10
 7222 instruct loadConI_x66666667(iRegIsafe dst) %{
 7223   effect( DEF dst );
 7224 
 7225   size(8);
 7226   format %{ &quot;SET    0x66666667,$dst\t! Used in div-by-10&quot; %}
 7227   ins_encode( Set32(0x66666667, dst) );
 7228   ins_pipe(ialu_hi_lo_reg);
 7229 %}
 7230 
 7231 // Register Shift Right Arithmetic Long by 32-63
 7232 instruct sra_31( iRegI dst, iRegI src ) %{
 7233   effect( DEF dst, USE src );
 7234   format %{ &quot;SRA    $src,31,$dst\t! Used in div-by-10&quot; %}
 7235   ins_encode( form3_rs1_rd_copysign_hi(src,dst) );
 7236   ins_pipe(ialu_reg_reg);
 7237 %}
 7238 
 7239 // Arithmetic Shift Right by 8-bit immediate
 7240 instruct sra_reg_2( iRegI dst, iRegI src ) %{
 7241   effect( DEF dst, USE src );
 7242   format %{ &quot;SRA    $src,2,$dst\t! Used in div-by-10&quot; %}
 7243   opcode(Assembler::sra_op3, Assembler::arith_op);
 7244   ins_encode( form3_rs1_simm13_rd( src, 0x2, dst ) );
 7245   ins_pipe(ialu_reg_imm);
 7246 %}
 7247 
 7248 // Integer DIV with 10
 7249 instruct divI_10( iRegI dst, iRegIsafe src, immI10 div ) %{
 7250   match(Set dst (DivI src div));
 7251   ins_cost((6+6)*DEFAULT_COST);
 7252   expand %{
 7253     iRegIsafe tmp1;               // Killed temps;
 7254     iRegIsafe tmp2;               // Killed temps;
 7255     iRegI tmp3;                   // Killed temps;
 7256     iRegI tmp4;                   // Killed temps;
 7257     loadConI_x66666667( tmp1 );   // SET  0x66666667 -&gt; tmp1
 7258     mul_hi( tmp2, src, tmp1 );    // MUL  hibits(src * tmp1) -&gt; tmp2
 7259     sra_31( tmp3, src );          // SRA  src,31 -&gt; tmp3
 7260     sra_reg_2( tmp4, tmp2 );      // SRA  tmp2,2 -&gt; tmp4
 7261     subI_reg_reg( dst,tmp4,tmp3); // SUB  tmp4 - tmp3 -&gt; dst
 7262   %}
 7263 %}
 7264 
 7265 // Register Long Division
 7266 instruct divL_reg_reg(iRegL dst, iRegL src1, iRegL src2) %{
 7267   match(Set dst (DivL src1 src2));
 7268   ins_cost(DEFAULT_COST*71);
 7269   size(4);
 7270   format %{ &quot;SDIVX  $src1,$src2,$dst\t! long&quot; %}
 7271   opcode(Assembler::sdivx_op3, Assembler::arith_op);
 7272   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7273   ins_pipe(divL_reg_reg);
 7274 %}
 7275 
 7276 // Register Long Division
 7277 instruct divL_reg_imm13(iRegL dst, iRegL src1, immL13 src2) %{
 7278   match(Set dst (DivL src1 src2));
 7279   ins_cost(DEFAULT_COST*71);
 7280   size(4);
 7281   format %{ &quot;SDIVX  $src1,$src2,$dst\t! long&quot; %}
 7282   opcode(Assembler::sdivx_op3, Assembler::arith_op);
 7283   ins_encode( form3_rs1_simm13_rd( src1, src2, dst ) );
 7284   ins_pipe(divL_reg_imm);
 7285 %}
 7286 
 7287 // Integer Remainder
 7288 // Register Remainder
 7289 instruct modI_reg_reg(iRegI dst, iRegIsafe src1, iRegIsafe src2, o7RegP temp, flagsReg ccr ) %{
 7290   match(Set dst (ModI src1 src2));
 7291   effect( KILL ccr, KILL temp);
 7292 
 7293   format %{ &quot;SREM   $src1,$src2,$dst&quot; %}
 7294   ins_encode( irem_reg(src1, src2, dst, temp) );
 7295   ins_pipe(sdiv_reg_reg);
 7296 %}
 7297 
 7298 // Immediate Remainder
 7299 instruct modI_reg_imm13(iRegI dst, iRegIsafe src1, immI13 src2, o7RegP temp, flagsReg ccr ) %{
 7300   match(Set dst (ModI src1 src2));
 7301   effect( KILL ccr, KILL temp);
 7302 
 7303   format %{ &quot;SREM   $src1,$src2,$dst&quot; %}
 7304   ins_encode( irem_imm(src1, src2, dst, temp) );
 7305   ins_pipe(sdiv_reg_imm);
 7306 %}
 7307 
 7308 // Register Long Remainder
 7309 instruct divL_reg_reg_1(iRegL dst, iRegL src1, iRegL src2) %{
 7310   effect(DEF dst, USE src1, USE src2);
 7311   size(4);
 7312   format %{ &quot;SDIVX  $src1,$src2,$dst\t! long&quot; %}
 7313   opcode(Assembler::sdivx_op3, Assembler::arith_op);
 7314   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7315   ins_pipe(divL_reg_reg);
 7316 %}
 7317 
 7318 // Register Long Division
 7319 instruct divL_reg_imm13_1(iRegL dst, iRegL src1, immL13 src2) %{
 7320   effect(DEF dst, USE src1, USE src2);
 7321   size(4);
 7322   format %{ &quot;SDIVX  $src1,$src2,$dst\t! long&quot; %}
 7323   opcode(Assembler::sdivx_op3, Assembler::arith_op);
 7324   ins_encode( form3_rs1_simm13_rd( src1, src2, dst ) );
 7325   ins_pipe(divL_reg_imm);
 7326 %}
 7327 
 7328 instruct mulL_reg_reg_1(iRegL dst, iRegL src1, iRegL src2) %{
 7329   effect(DEF dst, USE src1, USE src2);
 7330   size(4);
 7331   format %{ &quot;MULX   $src1,$src2,$dst\t! long&quot; %}
 7332   opcode(Assembler::mulx_op3, Assembler::arith_op);
 7333   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7334   ins_pipe(mulL_reg_reg);
 7335 %}
 7336 
 7337 // Immediate Multiplication
 7338 instruct mulL_reg_imm13_1(iRegL dst, iRegL src1, immL13 src2) %{
 7339   effect(DEF dst, USE src1, USE src2);
 7340   size(4);
 7341   format %{ &quot;MULX   $src1,$src2,$dst&quot; %}
 7342   opcode(Assembler::mulx_op3, Assembler::arith_op);
 7343   ins_encode( form3_rs1_simm13_rd( src1, src2, dst ) );
 7344   ins_pipe(mulL_reg_imm);
 7345 %}
 7346 
 7347 instruct subL_reg_reg_1(iRegL dst, iRegL src1, iRegL src2) %{
 7348   effect(DEF dst, USE src1, USE src2);
 7349   size(4);
 7350   format %{ &quot;SUB    $src1,$src2,$dst\t! long&quot; %}
 7351   opcode(Assembler::sub_op3, Assembler::arith_op);
 7352   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7353   ins_pipe(ialu_reg_reg);
 7354 %}
 7355 
 7356 instruct subL_reg_reg_2(iRegL dst, iRegL src1, iRegL src2) %{
 7357   effect(DEF dst, USE src1, USE src2);
 7358   size(4);
 7359   format %{ &quot;SUB    $src1,$src2,$dst\t! long&quot; %}
 7360   opcode(Assembler::sub_op3, Assembler::arith_op);
 7361   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7362   ins_pipe(ialu_reg_reg);
 7363 %}
 7364 
 7365 // Register Long Remainder
 7366 instruct modL_reg_reg(iRegL dst, iRegL src1, iRegL src2) %{
 7367   match(Set dst (ModL src1 src2));
 7368   ins_cost(DEFAULT_COST*(71 + 6 + 1));
 7369   expand %{
 7370     iRegL tmp1;
 7371     iRegL tmp2;
 7372     divL_reg_reg_1(tmp1, src1, src2);
 7373     mulL_reg_reg_1(tmp2, tmp1, src2);
 7374     subL_reg_reg_1(dst,  src1, tmp2);
 7375   %}
 7376 %}
 7377 
 7378 // Register Long Remainder
 7379 instruct modL_reg_imm13(iRegL dst, iRegL src1, immL13 src2) %{
 7380   match(Set dst (ModL src1 src2));
 7381   ins_cost(DEFAULT_COST*(71 + 6 + 1));
 7382   expand %{
 7383     iRegL tmp1;
 7384     iRegL tmp2;
 7385     divL_reg_imm13_1(tmp1, src1, src2);
 7386     mulL_reg_imm13_1(tmp2, tmp1, src2);
 7387     subL_reg_reg_2  (dst,  src1, tmp2);
 7388   %}
 7389 %}
 7390 
 7391 // Integer Shift Instructions
 7392 // Register Shift Left
 7393 instruct shlI_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
 7394   match(Set dst (LShiftI src1 src2));
 7395 
 7396   size(4);
 7397   format %{ &quot;SLL    $src1,$src2,$dst&quot; %}
 7398   opcode(Assembler::sll_op3, Assembler::arith_op);
 7399   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7400   ins_pipe(ialu_reg_reg);
 7401 %}
 7402 
 7403 // Register Shift Left Immediate
 7404 instruct shlI_reg_imm5(iRegI dst, iRegI src1, immU5 src2) %{
 7405   match(Set dst (LShiftI src1 src2));
 7406 
 7407   size(4);
 7408   format %{ &quot;SLL    $src1,$src2,$dst&quot; %}
 7409   opcode(Assembler::sll_op3, Assembler::arith_op);
 7410   ins_encode( form3_rs1_imm5_rd( src1, src2, dst ) );
 7411   ins_pipe(ialu_reg_imm);
 7412 %}
 7413 
 7414 // Register Shift Left
 7415 instruct shlL_reg_reg(iRegL dst, iRegL src1, iRegI src2) %{
 7416   match(Set dst (LShiftL src1 src2));
 7417 
 7418   size(4);
 7419   format %{ &quot;SLLX   $src1,$src2,$dst&quot; %}
 7420   opcode(Assembler::sllx_op3, Assembler::arith_op);
 7421   ins_encode( form3_sd_rs1_rs2_rd( src1, src2, dst ) );
 7422   ins_pipe(ialu_reg_reg);
 7423 %}
 7424 
 7425 // Register Shift Left Immediate
 7426 instruct shlL_reg_imm6(iRegL dst, iRegL src1, immU6 src2) %{
 7427   match(Set dst (LShiftL src1 src2));
 7428 
 7429   size(4);
 7430   format %{ &quot;SLLX   $src1,$src2,$dst&quot; %}
 7431   opcode(Assembler::sllx_op3, Assembler::arith_op);
 7432   ins_encode( form3_sd_rs1_imm6_rd( src1, src2, dst ) );
 7433   ins_pipe(ialu_reg_imm);
 7434 %}
 7435 
 7436 // Register Arithmetic Shift Right
 7437 instruct sarI_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
 7438   match(Set dst (RShiftI src1 src2));
 7439   size(4);
 7440   format %{ &quot;SRA    $src1,$src2,$dst&quot; %}
 7441   opcode(Assembler::sra_op3, Assembler::arith_op);
 7442   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7443   ins_pipe(ialu_reg_reg);
 7444 %}
 7445 
 7446 // Register Arithmetic Shift Right Immediate
 7447 instruct sarI_reg_imm5(iRegI dst, iRegI src1, immU5 src2) %{
 7448   match(Set dst (RShiftI src1 src2));
 7449 
 7450   size(4);
 7451   format %{ &quot;SRA    $src1,$src2,$dst&quot; %}
 7452   opcode(Assembler::sra_op3, Assembler::arith_op);
 7453   ins_encode( form3_rs1_imm5_rd( src1, src2, dst ) );
 7454   ins_pipe(ialu_reg_imm);
 7455 %}
 7456 
 7457 // Register Shift Right Arithmatic Long
 7458 instruct sarL_reg_reg(iRegL dst, iRegL src1, iRegI src2) %{
 7459   match(Set dst (RShiftL src1 src2));
 7460 
 7461   size(4);
 7462   format %{ &quot;SRAX   $src1,$src2,$dst&quot; %}
 7463   opcode(Assembler::srax_op3, Assembler::arith_op);
 7464   ins_encode( form3_sd_rs1_rs2_rd( src1, src2, dst ) );
 7465   ins_pipe(ialu_reg_reg);
 7466 %}
 7467 
 7468 // Register Shift Left Immediate
 7469 instruct sarL_reg_imm6(iRegL dst, iRegL src1, immU6 src2) %{
 7470   match(Set dst (RShiftL src1 src2));
 7471 
 7472   size(4);
 7473   format %{ &quot;SRAX   $src1,$src2,$dst&quot; %}
 7474   opcode(Assembler::srax_op3, Assembler::arith_op);
 7475   ins_encode( form3_sd_rs1_imm6_rd( src1, src2, dst ) );
 7476   ins_pipe(ialu_reg_imm);
 7477 %}
 7478 
 7479 // Register Shift Right
 7480 instruct shrI_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
 7481   match(Set dst (URShiftI src1 src2));
 7482 
 7483   size(4);
 7484   format %{ &quot;SRL    $src1,$src2,$dst&quot; %}
 7485   opcode(Assembler::srl_op3, Assembler::arith_op);
 7486   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7487   ins_pipe(ialu_reg_reg);
 7488 %}
 7489 
 7490 // Register Shift Right Immediate
 7491 instruct shrI_reg_imm5(iRegI dst, iRegI src1, immU5 src2) %{
 7492   match(Set dst (URShiftI src1 src2));
 7493 
 7494   size(4);
 7495   format %{ &quot;SRL    $src1,$src2,$dst&quot; %}
 7496   opcode(Assembler::srl_op3, Assembler::arith_op);
 7497   ins_encode( form3_rs1_imm5_rd( src1, src2, dst ) );
 7498   ins_pipe(ialu_reg_imm);
 7499 %}
 7500 
 7501 // Register Shift Right
 7502 instruct shrL_reg_reg(iRegL dst, iRegL src1, iRegI src2) %{
 7503   match(Set dst (URShiftL src1 src2));
 7504 
 7505   size(4);
 7506   format %{ &quot;SRLX   $src1,$src2,$dst&quot; %}
 7507   opcode(Assembler::srlx_op3, Assembler::arith_op);
 7508   ins_encode( form3_sd_rs1_rs2_rd( src1, src2, dst ) );
 7509   ins_pipe(ialu_reg_reg);
 7510 %}
 7511 
 7512 // Register Shift Right Immediate
 7513 instruct shrL_reg_imm6(iRegL dst, iRegL src1, immU6 src2) %{
 7514   match(Set dst (URShiftL src1 src2));
 7515 
 7516   size(4);
 7517   format %{ &quot;SRLX   $src1,$src2,$dst&quot; %}
 7518   opcode(Assembler::srlx_op3, Assembler::arith_op);
 7519   ins_encode( form3_sd_rs1_imm6_rd( src1, src2, dst ) );
 7520   ins_pipe(ialu_reg_imm);
 7521 %}
 7522 
 7523 // Register Shift Right Immediate with a CastP2X
 7524 instruct shrP_reg_imm6(iRegL dst, iRegP src1, immU6 src2) %{
 7525   match(Set dst (URShiftL (CastP2X src1) src2));
 7526   size(4);
 7527   format %{ &quot;SRLX   $src1,$src2,$dst\t! Cast ptr $src1 to long and shift&quot; %}
 7528   opcode(Assembler::srlx_op3, Assembler::arith_op);
 7529   ins_encode( form3_sd_rs1_imm6_rd( src1, src2, dst ) );
 7530   ins_pipe(ialu_reg_imm);
 7531 %}
 7532 
 7533 
 7534 //----------Floating Point Arithmetic Instructions-----------------------------
 7535 
 7536 //  Add float single precision
 7537 instruct addF_reg_reg(regF dst, regF src1, regF src2) %{
 7538   match(Set dst (AddF src1 src2));
 7539 
 7540   size(4);
 7541   format %{ &quot;FADDS  $src1,$src2,$dst&quot; %}
 7542   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fadds_opf);
 7543   ins_encode(form3_opf_rs1F_rs2F_rdF(src1, src2, dst));
 7544   ins_pipe(faddF_reg_reg);
 7545 %}
 7546 
 7547 //  Add float double precision
 7548 instruct addD_reg_reg(regD dst, regD src1, regD src2) %{
 7549   match(Set dst (AddD src1 src2));
 7550 
 7551   size(4);
 7552   format %{ &quot;FADDD  $src1,$src2,$dst&quot; %}
 7553   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::faddd_opf);
 7554   ins_encode(form3_opf_rs1D_rs2D_rdD(src1, src2, dst));
 7555   ins_pipe(faddD_reg_reg);
 7556 %}
 7557 
 7558 //  Sub float single precision
 7559 instruct subF_reg_reg(regF dst, regF src1, regF src2) %{
 7560   match(Set dst (SubF src1 src2));
 7561 
 7562   size(4);
 7563   format %{ &quot;FSUBS  $src1,$src2,$dst&quot; %}
 7564   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fsubs_opf);
 7565   ins_encode(form3_opf_rs1F_rs2F_rdF(src1, src2, dst));
 7566   ins_pipe(faddF_reg_reg);
 7567 %}
 7568 
 7569 //  Sub float double precision
 7570 instruct subD_reg_reg(regD dst, regD src1, regD src2) %{
 7571   match(Set dst (SubD src1 src2));
 7572 
 7573   size(4);
 7574   format %{ &quot;FSUBD  $src1,$src2,$dst&quot; %}
 7575   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fsubd_opf);
 7576   ins_encode(form3_opf_rs1D_rs2D_rdD(src1, src2, dst));
 7577   ins_pipe(faddD_reg_reg);
 7578 %}
 7579 
 7580 //  Mul float single precision
 7581 instruct mulF_reg_reg(regF dst, regF src1, regF src2) %{
 7582   match(Set dst (MulF src1 src2));
 7583 
 7584   size(4);
 7585   format %{ &quot;FMULS  $src1,$src2,$dst&quot; %}
 7586   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fmuls_opf);
 7587   ins_encode(form3_opf_rs1F_rs2F_rdF(src1, src2, dst));
 7588   ins_pipe(fmulF_reg_reg);
 7589 %}
 7590 
 7591 //  Mul float double precision
 7592 instruct mulD_reg_reg(regD dst, regD src1, regD src2) %{
 7593   match(Set dst (MulD src1 src2));
 7594 
 7595   size(4);
 7596   format %{ &quot;FMULD  $src1,$src2,$dst&quot; %}
 7597   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fmuld_opf);
 7598   ins_encode(form3_opf_rs1D_rs2D_rdD(src1, src2, dst));
 7599   ins_pipe(fmulD_reg_reg);
 7600 %}
 7601 
 7602 //  Div float single precision
 7603 instruct divF_reg_reg(regF dst, regF src1, regF src2) %{
 7604   match(Set dst (DivF src1 src2));
 7605 
 7606   size(4);
 7607   format %{ &quot;FDIVS  $src1,$src2,$dst&quot; %}
 7608   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fdivs_opf);
 7609   ins_encode(form3_opf_rs1F_rs2F_rdF(src1, src2, dst));
 7610   ins_pipe(fdivF_reg_reg);
 7611 %}
 7612 
 7613 //  Div float double precision
 7614 instruct divD_reg_reg(regD dst, regD src1, regD src2) %{
 7615   match(Set dst (DivD src1 src2));
 7616 
 7617   size(4);
 7618   format %{ &quot;FDIVD  $src1,$src2,$dst&quot; %}
 7619   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fdivd_opf);
 7620   ins_encode(form3_opf_rs1D_rs2D_rdD(src1, src2, dst));
 7621   ins_pipe(fdivD_reg_reg);
 7622 %}
 7623 
 7624 //  Absolute float double precision
 7625 instruct absD_reg(regD dst, regD src) %{
 7626   match(Set dst (AbsD src));
 7627 
 7628   format %{ &quot;FABSd  $src,$dst&quot; %}
 7629   ins_encode(fabsd(dst, src));
 7630   ins_pipe(faddD_reg);
 7631 %}
 7632 
 7633 //  Absolute float single precision
 7634 instruct absF_reg(regF dst, regF src) %{
 7635   match(Set dst (AbsF src));
 7636 
 7637   format %{ &quot;FABSs  $src,$dst&quot; %}
 7638   ins_encode(fabss(dst, src));
 7639   ins_pipe(faddF_reg);
 7640 %}
 7641 
 7642 instruct negF_reg(regF dst, regF src) %{
 7643   match(Set dst (NegF src));
 7644 
 7645   size(4);
 7646   format %{ &quot;FNEGs  $src,$dst&quot; %}
 7647   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fnegs_opf);
 7648   ins_encode(form3_opf_rs2F_rdF(src, dst));
 7649   ins_pipe(faddF_reg);
 7650 %}
 7651 
 7652 instruct negD_reg(regD dst, regD src) %{
 7653   match(Set dst (NegD src));
 7654 
 7655   format %{ &quot;FNEGd  $src,$dst&quot; %}
 7656   ins_encode(fnegd(dst, src));
 7657   ins_pipe(faddD_reg);
 7658 %}
 7659 
 7660 //  Sqrt float double precision
 7661 instruct sqrtF_reg_reg(regF dst, regF src) %{
 7662   match(Set dst (ConvD2F (SqrtD (ConvF2D src))));
 7663 
 7664   size(4);
 7665   format %{ &quot;FSQRTS $src,$dst&quot; %}
 7666   ins_encode(fsqrts(dst, src));
 7667   ins_pipe(fdivF_reg_reg);
 7668 %}
 7669 
 7670 //  Sqrt float double precision
 7671 instruct sqrtD_reg_reg(regD dst, regD src) %{
 7672   match(Set dst (SqrtD src));
 7673 
 7674   size(4);
 7675   format %{ &quot;FSQRTD $src,$dst&quot; %}
 7676   ins_encode(fsqrtd(dst, src));
 7677   ins_pipe(fdivD_reg_reg);
 7678 %}
 7679 
 7680 // Single/Double precision fused floating-point multiply-add (d = a * b + c).
 7681 instruct fmaF_regx4(regF dst, regF a, regF b, regF c) %{
 7682   predicate(UseFMA);
 7683   match(Set dst (FmaF c (Binary a b)));
 7684   format %{ &quot;fmadds $a,$b,$c,$dst\t# $dst = $a * $b + $c&quot; %}
 7685   ins_encode(fmadds(dst, a, b, c));
 7686   ins_pipe(fmaF_regx4);
 7687 %}
 7688 
 7689 instruct fmaD_regx4(regD dst, regD a, regD b, regD c) %{
 7690   predicate(UseFMA);
 7691   match(Set dst (FmaD c (Binary a b)));
 7692   format %{ &quot;fmaddd $a,$b,$c,$dst\t# $dst = $a * $b + $c&quot; %}
 7693   ins_encode(fmaddd(dst, a, b, c));
 7694   ins_pipe(fmaD_regx4);
 7695 %}
 7696 
 7697 // Additional patterns matching complement versions that we can map directly to
 7698 // variants of the fused multiply-add instructions.
 7699 
 7700 // Single/Double precision fused floating-point multiply-sub (d = a * b - c)
 7701 instruct fmsubF_regx4(regF dst, regF a, regF b, regF c) %{
 7702   predicate(UseFMA);
 7703   match(Set dst (FmaF (NegF c) (Binary a b)));
 7704   format %{ &quot;fmsubs $a,$b,$c,$dst\t# $dst = $a * $b - $c&quot; %}
 7705   ins_encode(fmsubs(dst, a, b, c));
 7706   ins_pipe(fmaF_regx4);
 7707 %}
 7708 
 7709 instruct fmsubD_regx4(regD dst, regD a, regD b, regD c) %{
 7710   predicate(UseFMA);
 7711   match(Set dst (FmaD (NegD c) (Binary a b)));
 7712   format %{ &quot;fmsubd $a,$b,$c,$dst\t# $dst = $a * $b - $c&quot; %}
 7713   ins_encode(fmsubd(dst, a, b, c));
 7714   ins_pipe(fmaD_regx4);
 7715 %}
 7716 
 7717 // Single/Double precision fused floating-point neg. multiply-add,
 7718 //      d = -1 * a * b - c = -(a * b + c)
 7719 instruct fnmaddF_regx4(regF dst, regF a, regF b, regF c) %{
 7720   predicate(UseFMA);
 7721   match(Set dst (FmaF (NegF c) (Binary (NegF a) b)));
 7722   match(Set dst (FmaF (NegF c) (Binary a (NegF b))));
 7723   format %{ &quot;fnmadds $a,$b,$c,$dst\t# $dst = -($a * $b + $c)&quot; %}
 7724   ins_encode(fnmadds(dst, a, b, c));
 7725   ins_pipe(fmaF_regx4);
 7726 %}
 7727 
 7728 instruct fnmaddD_regx4(regD dst, regD a, regD b, regD c) %{
 7729   predicate(UseFMA);
 7730   match(Set dst (FmaD (NegD c) (Binary (NegD a) b)));
 7731   match(Set dst (FmaD (NegD c) (Binary a (NegD b))));
 7732   format %{ &quot;fnmaddd $a,$b,$c,$dst\t# $dst = -($a * $b + $c)&quot; %}
 7733   ins_encode(fnmaddd(dst, a, b, c));
 7734   ins_pipe(fmaD_regx4);
 7735 %}
 7736 
 7737 // Single/Double precision fused floating-point neg. multiply-sub,
 7738 //      d = -1 * a * b + c = -(a * b - c)
 7739 instruct fnmsubF_regx4(regF dst, regF a, regF b, regF c) %{
 7740   predicate(UseFMA);
 7741   match(Set dst (FmaF c (Binary (NegF a) b)));
 7742   match(Set dst (FmaF c (Binary a (NegF b))));
 7743   format %{ &quot;fnmsubs $a,$b,$c,$dst\t# $dst = -($a * $b - $c)&quot; %}
 7744   ins_encode(fnmsubs(dst, a, b, c));
 7745   ins_pipe(fmaF_regx4);
 7746 %}
 7747 
 7748 instruct fnmsubD_regx4(regD dst, regD a, regD b, regD c) %{
 7749   predicate(UseFMA);
 7750   match(Set dst (FmaD c (Binary (NegD a) b)));
 7751   match(Set dst (FmaD c (Binary a (NegD b))));
 7752   format %{ &quot;fnmsubd $a,$b,$c,$dst\t# $dst = -($a * $b - $c)&quot; %}
 7753   ins_encode(fnmsubd(dst, a, b, c));
 7754   ins_pipe(fmaD_regx4);
 7755 %}
 7756 
 7757 //----------Logical Instructions-----------------------------------------------
 7758 // And Instructions
 7759 // Register And
 7760 instruct andI_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
 7761   match(Set dst (AndI src1 src2));
 7762 
 7763   size(4);
 7764   format %{ &quot;AND    $src1,$src2,$dst&quot; %}
 7765   opcode(Assembler::and_op3, Assembler::arith_op);
 7766   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7767   ins_pipe(ialu_reg_reg);
 7768 %}
 7769 
 7770 // Immediate And
 7771 instruct andI_reg_imm13(iRegI dst, iRegI src1, immI13 src2) %{
 7772   match(Set dst (AndI src1 src2));
 7773 
 7774   size(4);
 7775   format %{ &quot;AND    $src1,$src2,$dst&quot; %}
 7776   opcode(Assembler::and_op3, Assembler::arith_op);
 7777   ins_encode( form3_rs1_simm13_rd( src1, src2, dst ) );
 7778   ins_pipe(ialu_reg_imm);
 7779 %}
 7780 
 7781 // Register And Long
 7782 instruct andL_reg_reg(iRegL dst, iRegL src1, iRegL src2) %{
 7783   match(Set dst (AndL src1 src2));
 7784 
 7785   ins_cost(DEFAULT_COST);
 7786   size(4);
 7787   format %{ &quot;AND    $src1,$src2,$dst\t! long&quot; %}
 7788   opcode(Assembler::and_op3, Assembler::arith_op);
 7789   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7790   ins_pipe(ialu_reg_reg);
 7791 %}
 7792 
 7793 instruct andL_reg_imm13(iRegL dst, iRegL src1, immL13 con) %{
 7794   match(Set dst (AndL src1 con));
 7795 
 7796   ins_cost(DEFAULT_COST);
 7797   size(4);
 7798   format %{ &quot;AND    $src1,$con,$dst\t! long&quot; %}
 7799   opcode(Assembler::and_op3, Assembler::arith_op);
 7800   ins_encode( form3_rs1_simm13_rd( src1, con, dst ) );
 7801   ins_pipe(ialu_reg_imm);
 7802 %}
 7803 
 7804 // Or Instructions
 7805 // Register Or
 7806 instruct orI_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
 7807   match(Set dst (OrI src1 src2));
 7808 
 7809   size(4);
 7810   format %{ &quot;OR     $src1,$src2,$dst&quot; %}
 7811   opcode(Assembler::or_op3, Assembler::arith_op);
 7812   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7813   ins_pipe(ialu_reg_reg);
 7814 %}
 7815 
 7816 // Immediate Or
 7817 instruct orI_reg_imm13(iRegI dst, iRegI src1, immI13 src2) %{
 7818   match(Set dst (OrI src1 src2));
 7819 
 7820   size(4);
 7821   format %{ &quot;OR     $src1,$src2,$dst&quot; %}
 7822   opcode(Assembler::or_op3, Assembler::arith_op);
 7823   ins_encode( form3_rs1_simm13_rd( src1, src2, dst ) );
 7824   ins_pipe(ialu_reg_imm);
 7825 %}
 7826 
 7827 // Register Or Long
 7828 instruct orL_reg_reg(iRegL dst, iRegL src1, iRegL src2) %{
 7829   match(Set dst (OrL src1 src2));
 7830 
 7831   ins_cost(DEFAULT_COST);
 7832   size(4);
 7833   format %{ &quot;OR     $src1,$src2,$dst\t! long&quot; %}
 7834   opcode(Assembler::or_op3, Assembler::arith_op);
 7835   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7836   ins_pipe(ialu_reg_reg);
 7837 %}
 7838 
 7839 instruct orL_reg_imm13(iRegL dst, iRegL src1, immL13 con) %{
 7840   match(Set dst (OrL src1 con));
 7841   ins_cost(DEFAULT_COST*2);
 7842 
 7843   ins_cost(DEFAULT_COST);
 7844   size(4);
 7845   format %{ &quot;OR     $src1,$con,$dst\t! long&quot; %}
 7846   opcode(Assembler::or_op3, Assembler::arith_op);
 7847   ins_encode( form3_rs1_simm13_rd( src1, con, dst ) );
 7848   ins_pipe(ialu_reg_imm);
 7849 %}
 7850 
 7851 instruct orL_reg_castP2X(iRegL dst, iRegL src1, sp_ptr_RegP src2) %{
 7852   match(Set dst (OrL src1 (CastP2X src2)));
 7853 
 7854   ins_cost(DEFAULT_COST);
 7855   size(4);
 7856   format %{ &quot;OR     $src1,$src2,$dst\t! long&quot; %}
 7857   opcode(Assembler::or_op3, Assembler::arith_op);
 7858   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7859   ins_pipe(ialu_reg_reg);
 7860 %}
 7861 
 7862 // Xor Instructions
 7863 // Register Xor
 7864 instruct xorI_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
 7865   match(Set dst (XorI src1 src2));
 7866 
 7867   size(4);
 7868   format %{ &quot;XOR    $src1,$src2,$dst&quot; %}
 7869   opcode(Assembler::xor_op3, Assembler::arith_op);
 7870   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7871   ins_pipe(ialu_reg_reg);
 7872 %}
 7873 
 7874 // Immediate Xor
 7875 instruct xorI_reg_imm13(iRegI dst, iRegI src1, immI13 src2) %{
 7876   match(Set dst (XorI src1 src2));
 7877 
 7878   size(4);
 7879   format %{ &quot;XOR    $src1,$src2,$dst&quot; %}
 7880   opcode(Assembler::xor_op3, Assembler::arith_op);
 7881   ins_encode( form3_rs1_simm13_rd( src1, src2, dst ) );
 7882   ins_pipe(ialu_reg_imm);
 7883 %}
 7884 
 7885 // Register Xor Long
 7886 instruct xorL_reg_reg(iRegL dst, iRegL src1, iRegL src2) %{
 7887   match(Set dst (XorL src1 src2));
 7888 
 7889   ins_cost(DEFAULT_COST);
 7890   size(4);
 7891   format %{ &quot;XOR    $src1,$src2,$dst\t! long&quot; %}
 7892   opcode(Assembler::xor_op3, Assembler::arith_op);
 7893   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7894   ins_pipe(ialu_reg_reg);
 7895 %}
 7896 
 7897 instruct xorL_reg_imm13(iRegL dst, iRegL src1, immL13 con) %{
 7898   match(Set dst (XorL src1 con));
 7899 
 7900   ins_cost(DEFAULT_COST);
 7901   size(4);
 7902   format %{ &quot;XOR    $src1,$con,$dst\t! long&quot; %}
 7903   opcode(Assembler::xor_op3, Assembler::arith_op);
 7904   ins_encode( form3_rs1_simm13_rd( src1, con, dst ) );
 7905   ins_pipe(ialu_reg_imm);
 7906 %}
 7907 
 7908 //----------Convert to Boolean-------------------------------------------------
 7909 // Nice hack for 32-bit tests but doesn&#39;t work for
 7910 // 64-bit pointers.
 7911 instruct convI2B( iRegI dst, iRegI src, flagsReg ccr ) %{
 7912   match(Set dst (Conv2B src));
 7913   effect( KILL ccr );
 7914   ins_cost(DEFAULT_COST*2);
 7915   format %{ &quot;CMP    R_G0,$src\n\t&quot;
 7916             &quot;ADDX   R_G0,0,$dst&quot; %}
 7917   ins_encode( enc_to_bool( src, dst ) );
 7918   ins_pipe(ialu_reg_ialu);
 7919 %}
 7920 
 7921 instruct convP2B( iRegI dst, iRegP src ) %{
 7922   match(Set dst (Conv2B src));
 7923   ins_cost(DEFAULT_COST*2);
 7924   format %{ &quot;MOV    $src,$dst\n\t&quot;
 7925             &quot;MOVRNZ $src,1,$dst&quot; %}
 7926   ins_encode( form3_g0_rs2_rd_move( src, dst ), enc_convP2B( dst, src ) );
 7927   ins_pipe(ialu_clr_and_mover);
 7928 %}
 7929 
 7930 instruct cmpLTMask0( iRegI dst, iRegI src, immI0 zero, flagsReg ccr ) %{
 7931   match(Set dst (CmpLTMask src zero));
 7932   effect(KILL ccr);
 7933   size(4);
 7934   format %{ &quot;SRA    $src,#31,$dst\t# cmpLTMask0&quot; %}
 7935   ins_encode %{
 7936     __ sra($src$$Register, 31, $dst$$Register);
 7937   %}
 7938   ins_pipe(ialu_reg_imm);
 7939 %}
 7940 
 7941 instruct cmpLTMask_reg_reg( iRegI dst, iRegI p, iRegI q, flagsReg ccr ) %{
 7942   match(Set dst (CmpLTMask p q));
 7943   effect( KILL ccr );
 7944   ins_cost(DEFAULT_COST*4);
 7945   format %{ &quot;CMP    $p,$q\n\t&quot;
 7946             &quot;MOV    #0,$dst\n\t&quot;
 7947             &quot;BLT,a  .+8\n\t&quot;
 7948             &quot;MOV    #-1,$dst&quot; %}
 7949   ins_encode( enc_ltmask(p,q,dst) );
 7950   ins_pipe(ialu_reg_reg_ialu);
 7951 %}
 7952 
 7953 instruct cadd_cmpLTMask( iRegI p, iRegI q, iRegI y, iRegI tmp, flagsReg ccr ) %{
 7954   match(Set p (AddI (AndI (CmpLTMask p q) y) (SubI p q)));
 7955   effect(KILL ccr, TEMP tmp);
 7956   ins_cost(DEFAULT_COST*3);
 7957 
 7958   format %{ &quot;SUBcc  $p,$q,$p\t! p&#39; = p-q\n\t&quot;
 7959             &quot;ADD    $p,$y,$tmp\t! g3=p-q+y\n\t&quot;
 7960             &quot;MOVlt  $tmp,$p\t! p&#39; &lt; 0 ? p&#39;+y : p&#39;&quot; %}
 7961   ins_encode(enc_cadd_cmpLTMask(p, q, y, tmp));
 7962   ins_pipe(cadd_cmpltmask);
 7963 %}
 7964 
 7965 instruct and_cmpLTMask(iRegI p, iRegI q, iRegI y, flagsReg ccr) %{
 7966   match(Set p (AndI (CmpLTMask p q) y));
 7967   effect(KILL ccr);
 7968   ins_cost(DEFAULT_COST*3);
 7969 
 7970   format %{ &quot;CMP  $p,$q\n\t&quot;
 7971             &quot;MOV  $y,$p\n\t&quot;
 7972             &quot;MOVge G0,$p&quot; %}
 7973   ins_encode %{
 7974     __ cmp($p$$Register, $q$$Register);
 7975     __ mov($y$$Register, $p$$Register);
 7976     __ movcc(Assembler::greaterEqual, false, Assembler::icc, G0, $p$$Register);
 7977   %}
 7978   ins_pipe(ialu_reg_reg_ialu);
 7979 %}
 7980 
 7981 //-----------------------------------------------------------------
 7982 // Direct raw moves between float and general registers using VIS3.
 7983 
 7984 //  ins_pipe(faddF_reg);
 7985 instruct MoveF2I_reg_reg(iRegI dst, regF src) %{
 7986   predicate(UseVIS &gt;= 3);
 7987   match(Set dst (MoveF2I src));
 7988 
 7989   format %{ &quot;MOVSTOUW $src,$dst\t! MoveF2I&quot; %}
 7990   ins_encode %{
 7991     __ movstouw($src$$FloatRegister, $dst$$Register);
 7992   %}
 7993   ins_pipe(ialu_reg_reg);
 7994 %}
 7995 
 7996 instruct MoveI2F_reg_reg(regF dst, iRegI src) %{
 7997   predicate(UseVIS &gt;= 3);
 7998   match(Set dst (MoveI2F src));
 7999 
 8000   format %{ &quot;MOVWTOS $src,$dst\t! MoveI2F&quot; %}
 8001   ins_encode %{
 8002     __ movwtos($src$$Register, $dst$$FloatRegister);
 8003   %}
 8004   ins_pipe(ialu_reg_reg);
 8005 %}
 8006 
 8007 instruct MoveD2L_reg_reg(iRegL dst, regD src) %{
 8008   predicate(UseVIS &gt;= 3);
 8009   match(Set dst (MoveD2L src));
 8010 
 8011   format %{ &quot;MOVDTOX $src,$dst\t! MoveD2L&quot; %}
 8012   ins_encode %{
 8013     __ movdtox(as_DoubleFloatRegister($src$$reg), $dst$$Register);
 8014   %}
 8015   ins_pipe(ialu_reg_reg);
 8016 %}
 8017 
 8018 instruct MoveL2D_reg_reg(regD dst, iRegL src) %{
 8019   predicate(UseVIS &gt;= 3);
 8020   match(Set dst (MoveL2D src));
 8021 
 8022   format %{ &quot;MOVXTOD $src,$dst\t! MoveL2D&quot; %}
 8023   ins_encode %{
 8024     __ movxtod($src$$Register, as_DoubleFloatRegister($dst$$reg));
 8025   %}
 8026   ins_pipe(ialu_reg_reg);
 8027 %}
 8028 
 8029 
 8030 // Raw moves between float and general registers using stack.
 8031 
 8032 instruct MoveF2I_stack_reg(iRegI dst, stackSlotF src) %{
 8033   match(Set dst (MoveF2I src));
 8034   effect(DEF dst, USE src);
 8035   ins_cost(MEMORY_REF_COST);
 8036 
 8037   format %{ &quot;LDUW   $src,$dst\t! MoveF2I&quot; %}
 8038   opcode(Assembler::lduw_op3);
 8039   ins_encode(simple_form3_mem_reg( src, dst ) );
 8040   ins_pipe(iload_mem);
 8041 %}
 8042 
 8043 instruct MoveI2F_stack_reg(regF dst, stackSlotI src) %{
 8044   match(Set dst (MoveI2F src));
 8045   effect(DEF dst, USE src);
 8046   ins_cost(MEMORY_REF_COST);
 8047 
 8048   format %{ &quot;LDF    $src,$dst\t! MoveI2F&quot; %}
 8049   opcode(Assembler::ldf_op3);
 8050   ins_encode(simple_form3_mem_reg(src, dst));
 8051   ins_pipe(floadF_stk);
 8052 %}
 8053 
 8054 instruct MoveD2L_stack_reg(iRegL dst, stackSlotD src) %{
 8055   match(Set dst (MoveD2L src));
 8056   effect(DEF dst, USE src);
 8057   ins_cost(MEMORY_REF_COST);
 8058 
 8059   format %{ &quot;LDX    $src,$dst\t! MoveD2L&quot; %}
 8060   opcode(Assembler::ldx_op3);
 8061   ins_encode(simple_form3_mem_reg( src, dst ) );
 8062   ins_pipe(iload_mem);
 8063 %}
 8064 
 8065 instruct MoveL2D_stack_reg(regD dst, stackSlotL src) %{
 8066   match(Set dst (MoveL2D src));
 8067   effect(DEF dst, USE src);
 8068   ins_cost(MEMORY_REF_COST);
 8069 
 8070   format %{ &quot;LDDF   $src,$dst\t! MoveL2D&quot; %}
 8071   opcode(Assembler::lddf_op3);
 8072   ins_encode(simple_form3_mem_reg(src, dst));
 8073   ins_pipe(floadD_stk);
 8074 %}
 8075 
 8076 instruct MoveF2I_reg_stack(stackSlotI dst, regF src) %{
 8077   match(Set dst (MoveF2I src));
 8078   effect(DEF dst, USE src);
 8079   ins_cost(MEMORY_REF_COST);
 8080 
 8081   format %{ &quot;STF   $src,$dst\t! MoveF2I&quot; %}
 8082   opcode(Assembler::stf_op3);
 8083   ins_encode(simple_form3_mem_reg(dst, src));
 8084   ins_pipe(fstoreF_stk_reg);
 8085 %}
 8086 
 8087 instruct MoveI2F_reg_stack(stackSlotF dst, iRegI src) %{
 8088   match(Set dst (MoveI2F src));
 8089   effect(DEF dst, USE src);
 8090   ins_cost(MEMORY_REF_COST);
 8091 
 8092   format %{ &quot;STW    $src,$dst\t! MoveI2F&quot; %}
 8093   opcode(Assembler::stw_op3);
 8094   ins_encode(simple_form3_mem_reg( dst, src ) );
 8095   ins_pipe(istore_mem_reg);
 8096 %}
 8097 
 8098 instruct MoveD2L_reg_stack(stackSlotL dst, regD src) %{
 8099   match(Set dst (MoveD2L src));
 8100   effect(DEF dst, USE src);
 8101   ins_cost(MEMORY_REF_COST);
 8102 
 8103   format %{ &quot;STDF   $src,$dst\t! MoveD2L&quot; %}
 8104   opcode(Assembler::stdf_op3);
 8105   ins_encode(simple_form3_mem_reg(dst, src));
 8106   ins_pipe(fstoreD_stk_reg);
 8107 %}
 8108 
 8109 instruct MoveL2D_reg_stack(stackSlotD dst, iRegL src) %{
 8110   match(Set dst (MoveL2D src));
 8111   effect(DEF dst, USE src);
 8112   ins_cost(MEMORY_REF_COST);
 8113 
 8114   format %{ &quot;STX    $src,$dst\t! MoveL2D&quot; %}
 8115   opcode(Assembler::stx_op3);
 8116   ins_encode(simple_form3_mem_reg( dst, src ) );
 8117   ins_pipe(istore_mem_reg);
 8118 %}
 8119 
 8120 
 8121 //----------Arithmetic Conversion Instructions---------------------------------
 8122 // The conversions operations are all Alpha sorted.  Please keep it that way!
 8123 
 8124 instruct convD2F_reg(regF dst, regD src) %{
 8125   match(Set dst (ConvD2F src));
 8126   size(4);
 8127   format %{ &quot;FDTOS  $src,$dst&quot; %}
 8128   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fdtos_opf);
 8129   ins_encode(form3_opf_rs2D_rdF(src, dst));
 8130   ins_pipe(fcvtD2F);
 8131 %}
 8132 
 8133 
 8134 // Convert a double to an int in a float register.
 8135 // If the double is a NAN, stuff a zero in instead.
 8136 instruct convD2I_helper(regF dst, regD src, flagsRegF0 fcc0) %{
 8137   effect(DEF dst, USE src, KILL fcc0);
 8138   format %{ &quot;FCMPd  fcc0,$src,$src\t! check for NAN\n\t&quot;
 8139             &quot;FBO,pt fcc0,skip\t! branch on ordered, predict taken\n\t&quot;
 8140             &quot;FDTOI  $src,$dst\t! convert in delay slot\n\t&quot;
 8141             &quot;FITOS  $dst,$dst\t! change NaN/max-int to valid float\n\t&quot;
 8142             &quot;FSUBs  $dst,$dst,$dst\t! cleared only if nan\n&quot;
 8143       &quot;skip:&quot; %}
 8144   ins_encode(form_d2i_helper(src,dst));
 8145   ins_pipe(fcvtD2I);
 8146 %}
 8147 
 8148 instruct convD2I_stk(stackSlotI dst, regD src) %{
 8149   match(Set dst (ConvD2I src));
 8150   ins_cost(DEFAULT_COST*2 + MEMORY_REF_COST*2 + BRANCH_COST);
 8151   expand %{
 8152     regF tmp;
 8153     convD2I_helper(tmp, src);
 8154     regF_to_stkI(dst, tmp);
 8155   %}
 8156 %}
 8157 
 8158 instruct convD2I_reg(iRegI dst, regD src) %{
 8159   predicate(UseVIS &gt;= 3);
 8160   match(Set dst (ConvD2I src));
 8161   ins_cost(DEFAULT_COST*2 + BRANCH_COST);
 8162   expand %{
 8163     regF tmp;
 8164     convD2I_helper(tmp, src);
 8165     MoveF2I_reg_reg(dst, tmp);
 8166   %}
 8167 %}
 8168 
 8169 
 8170 // Convert a double to a long in a double register.
 8171 // If the double is a NAN, stuff a zero in instead.
 8172 instruct convD2L_helper(regD dst, regD src, flagsRegF0 fcc0) %{
 8173   effect(DEF dst, USE src, KILL fcc0);
 8174   format %{ &quot;FCMPd  fcc0,$src,$src\t! check for NAN\n\t&quot;
 8175             &quot;FBO,pt fcc0,skip\t! branch on ordered, predict taken\n\t&quot;
 8176             &quot;FDTOX  $src,$dst\t! convert in delay slot\n\t&quot;
 8177             &quot;FXTOD  $dst,$dst\t! change NaN/max-long to valid double\n\t&quot;
 8178             &quot;FSUBd  $dst,$dst,$dst\t! cleared only if nan\n&quot;
 8179       &quot;skip:&quot; %}
 8180   ins_encode(form_d2l_helper(src,dst));
 8181   ins_pipe(fcvtD2L);
 8182 %}
 8183 
 8184 instruct convD2L_stk(stackSlotL dst, regD src) %{
 8185   match(Set dst (ConvD2L src));
 8186   ins_cost(DEFAULT_COST*2 + MEMORY_REF_COST*2 + BRANCH_COST);
 8187   expand %{
 8188     regD tmp;
 8189     convD2L_helper(tmp, src);
 8190     regD_to_stkL(dst, tmp);
 8191   %}
 8192 %}
 8193 
 8194 instruct convD2L_reg(iRegL dst, regD src) %{
 8195   predicate(UseVIS &gt;= 3);
 8196   match(Set dst (ConvD2L src));
 8197   ins_cost(DEFAULT_COST*2 + BRANCH_COST);
 8198   expand %{
 8199     regD tmp;
 8200     convD2L_helper(tmp, src);
 8201     MoveD2L_reg_reg(dst, tmp);
 8202   %}
 8203 %}
 8204 
 8205 
 8206 instruct convF2D_reg(regD dst, regF src) %{
 8207   match(Set dst (ConvF2D src));
 8208   format %{ &quot;FSTOD  $src,$dst&quot; %}
 8209   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fstod_opf);
 8210   ins_encode(form3_opf_rs2F_rdD(src, dst));
 8211   ins_pipe(fcvtF2D);
 8212 %}
 8213 
 8214 
 8215 // Convert a float to an int in a float register.
 8216 // If the float is a NAN, stuff a zero in instead.
 8217 instruct convF2I_helper(regF dst, regF src, flagsRegF0 fcc0) %{
 8218   effect(DEF dst, USE src, KILL fcc0);
 8219   format %{ &quot;FCMPs  fcc0,$src,$src\t! check for NAN\n\t&quot;
 8220             &quot;FBO,pt fcc0,skip\t! branch on ordered, predict taken\n\t&quot;
 8221             &quot;FSTOI  $src,$dst\t! convert in delay slot\n\t&quot;
 8222             &quot;FITOS  $dst,$dst\t! change NaN/max-int to valid float\n\t&quot;
 8223             &quot;FSUBs  $dst,$dst,$dst\t! cleared only if nan\n&quot;
 8224       &quot;skip:&quot; %}
 8225   ins_encode(form_f2i_helper(src,dst));
 8226   ins_pipe(fcvtF2I);
 8227 %}
 8228 
 8229 instruct convF2I_stk(stackSlotI dst, regF src) %{
 8230   match(Set dst (ConvF2I src));
 8231   ins_cost(DEFAULT_COST*2 + MEMORY_REF_COST*2 + BRANCH_COST);
 8232   expand %{
 8233     regF tmp;
 8234     convF2I_helper(tmp, src);
 8235     regF_to_stkI(dst, tmp);
 8236   %}
 8237 %}
 8238 
 8239 instruct convF2I_reg(iRegI dst, regF src) %{
 8240   predicate(UseVIS &gt;= 3);
 8241   match(Set dst (ConvF2I src));
 8242   ins_cost(DEFAULT_COST*2 + BRANCH_COST);
 8243   expand %{
 8244     regF tmp;
 8245     convF2I_helper(tmp, src);
 8246     MoveF2I_reg_reg(dst, tmp);
 8247   %}
 8248 %}
 8249 
 8250 
 8251 // Convert a float to a long in a float register.
 8252 // If the float is a NAN, stuff a zero in instead.
 8253 instruct convF2L_helper(regD dst, regF src, flagsRegF0 fcc0) %{
 8254   effect(DEF dst, USE src, KILL fcc0);
 8255   format %{ &quot;FCMPs  fcc0,$src,$src\t! check for NAN\n\t&quot;
 8256             &quot;FBO,pt fcc0,skip\t! branch on ordered, predict taken\n\t&quot;
 8257             &quot;FSTOX  $src,$dst\t! convert in delay slot\n\t&quot;
 8258             &quot;FXTOD  $dst,$dst\t! change NaN/max-long to valid double\n\t&quot;
 8259             &quot;FSUBd  $dst,$dst,$dst\t! cleared only if nan\n&quot;
 8260       &quot;skip:&quot; %}
 8261   ins_encode(form_f2l_helper(src,dst));
 8262   ins_pipe(fcvtF2L);
 8263 %}
 8264 
 8265 instruct convF2L_stk(stackSlotL dst, regF src) %{
 8266   match(Set dst (ConvF2L src));
 8267   ins_cost(DEFAULT_COST*2 + MEMORY_REF_COST*2 + BRANCH_COST);
 8268   expand %{
 8269     regD tmp;
 8270     convF2L_helper(tmp, src);
 8271     regD_to_stkL(dst, tmp);
 8272   %}
 8273 %}
 8274 
 8275 instruct convF2L_reg(iRegL dst, regF src) %{
 8276   predicate(UseVIS &gt;= 3);
 8277   match(Set dst (ConvF2L src));
 8278   ins_cost(DEFAULT_COST*2 + BRANCH_COST);
 8279   expand %{
 8280     regD tmp;
 8281     convF2L_helper(tmp, src);
 8282     MoveD2L_reg_reg(dst, tmp);
 8283   %}
 8284 %}
 8285 
 8286 
 8287 instruct convI2D_helper(regD dst, regF tmp) %{
 8288   effect(USE tmp, DEF dst);
 8289   format %{ &quot;FITOD  $tmp,$dst&quot; %}
 8290   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fitod_opf);
 8291   ins_encode(form3_opf_rs2F_rdD(tmp, dst));
 8292   ins_pipe(fcvtI2D);
 8293 %}
 8294 
 8295 instruct convI2D_stk(stackSlotI src, regD dst) %{
 8296   match(Set dst (ConvI2D src));
 8297   ins_cost(DEFAULT_COST + MEMORY_REF_COST);
 8298   expand %{
 8299     regF tmp;
 8300     stkI_to_regF(tmp, src);
 8301     convI2D_helper(dst, tmp);
 8302   %}
 8303 %}
 8304 
 8305 instruct convI2D_reg(regD_low dst, iRegI src) %{
 8306   predicate(UseVIS &gt;= 3);
 8307   match(Set dst (ConvI2D src));
 8308   expand %{
 8309     regF tmp;
 8310     MoveI2F_reg_reg(tmp, src);
 8311     convI2D_helper(dst, tmp);
 8312   %}
 8313 %}
 8314 
 8315 instruct convI2D_mem(regD_low dst, memory mem) %{
 8316   match(Set dst (ConvI2D (LoadI mem)));
 8317   ins_cost(DEFAULT_COST + MEMORY_REF_COST);
 8318   format %{ &quot;LDF    $mem,$dst\n\t&quot;
 8319             &quot;FITOD  $dst,$dst&quot; %}
 8320   opcode(Assembler::ldf_op3, Assembler::fitod_opf);
 8321   ins_encode(simple_form3_mem_reg( mem, dst ), form3_convI2F(dst, dst));
 8322   ins_pipe(floadF_mem);
 8323 %}
 8324 
 8325 
 8326 instruct convI2F_helper(regF dst, regF tmp) %{
 8327   effect(DEF dst, USE tmp);
 8328   format %{ &quot;FITOS  $tmp,$dst&quot; %}
 8329   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fitos_opf);
 8330   ins_encode(form3_opf_rs2F_rdF(tmp, dst));
 8331   ins_pipe(fcvtI2F);
 8332 %}
 8333 
 8334 instruct convI2F_stk(regF dst, stackSlotI src) %{
 8335   match(Set dst (ConvI2F src));
 8336   ins_cost(DEFAULT_COST + MEMORY_REF_COST);
 8337   expand %{
 8338     regF tmp;
 8339     stkI_to_regF(tmp,src);
 8340     convI2F_helper(dst, tmp);
 8341   %}
 8342 %}
 8343 
 8344 instruct convI2F_reg(regF dst, iRegI src) %{
 8345   predicate(UseVIS &gt;= 3);
 8346   match(Set dst (ConvI2F src));
 8347   ins_cost(DEFAULT_COST);
 8348   expand %{
 8349     regF tmp;
 8350     MoveI2F_reg_reg(tmp, src);
 8351     convI2F_helper(dst, tmp);
 8352   %}
 8353 %}
 8354 
 8355 instruct convI2F_mem( regF dst, memory mem ) %{
 8356   match(Set dst (ConvI2F (LoadI mem)));
 8357   ins_cost(DEFAULT_COST + MEMORY_REF_COST);
 8358   format %{ &quot;LDF    $mem,$dst\n\t&quot;
 8359             &quot;FITOS  $dst,$dst&quot; %}
 8360   opcode(Assembler::ldf_op3, Assembler::fitos_opf);
 8361   ins_encode(simple_form3_mem_reg( mem, dst ), form3_convI2F(dst, dst));
 8362   ins_pipe(floadF_mem);
 8363 %}
 8364 
 8365 
 8366 instruct convI2L_reg(iRegL dst, iRegI src) %{
 8367   match(Set dst (ConvI2L src));
 8368   size(4);
 8369   format %{ &quot;SRA    $src,0,$dst\t! int-&gt;long&quot; %}
 8370   opcode(Assembler::sra_op3, Assembler::arith_op);
 8371   ins_encode( form3_rs1_rs2_rd( src, R_G0, dst ) );
 8372   ins_pipe(ialu_reg_reg);
 8373 %}
 8374 
 8375 // Zero-extend convert int to long
 8376 instruct convI2L_reg_zex(iRegL dst, iRegI src, immL_32bits mask ) %{
 8377   match(Set dst (AndL (ConvI2L src) mask) );
 8378   size(4);
 8379   format %{ &quot;SRL    $src,0,$dst\t! zero-extend int to long&quot; %}
 8380   opcode(Assembler::srl_op3, Assembler::arith_op);
 8381   ins_encode( form3_rs1_rs2_rd( src, R_G0, dst ) );
 8382   ins_pipe(ialu_reg_reg);
 8383 %}
 8384 
 8385 // Zero-extend long
 8386 instruct zerox_long(iRegL dst, iRegL src, immL_32bits mask ) %{
 8387   match(Set dst (AndL src mask) );
 8388   size(4);
 8389   format %{ &quot;SRL    $src,0,$dst\t! zero-extend long&quot; %}
 8390   opcode(Assembler::srl_op3, Assembler::arith_op);
 8391   ins_encode( form3_rs1_rs2_rd( src, R_G0, dst ) );
 8392   ins_pipe(ialu_reg_reg);
 8393 %}
 8394 
 8395 
 8396 //-----------
 8397 // Long to Double conversion using V8 opcodes.
 8398 // Still useful because cheetah traps and becomes
 8399 // amazingly slow for some common numbers.
 8400 
 8401 // Magic constant, 0x43300000
 8402 instruct loadConI_x43300000(iRegI dst) %{
 8403   effect(DEF dst);
 8404   size(4);
 8405   format %{ &quot;SETHI  HI(0x43300000),$dst\t! 2^52&quot; %}
 8406   ins_encode(SetHi22(0x43300000, dst));
 8407   ins_pipe(ialu_none);
 8408 %}
 8409 
 8410 // Magic constant, 0x41f00000
 8411 instruct loadConI_x41f00000(iRegI dst) %{
 8412   effect(DEF dst);
 8413   size(4);
 8414   format %{ &quot;SETHI  HI(0x41f00000),$dst\t! 2^32&quot; %}
 8415   ins_encode(SetHi22(0x41f00000, dst));
 8416   ins_pipe(ialu_none);
 8417 %}
 8418 
 8419 // Construct a double from two float halves
 8420 instruct regDHi_regDLo_to_regD(regD_low dst, regD_low src1, regD_low src2) %{
 8421   effect(DEF dst, USE src1, USE src2);
 8422   size(8);
 8423   format %{ &quot;FMOVS  $src1.hi,$dst.hi\n\t&quot;
 8424             &quot;FMOVS  $src2.lo,$dst.lo&quot; %}
 8425   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fmovs_opf);
 8426   ins_encode(form3_opf_rs2D_hi_rdD_hi(src1, dst), form3_opf_rs2D_lo_rdD_lo(src2, dst));
 8427   ins_pipe(faddD_reg_reg);
 8428 %}
 8429 
 8430 // Convert integer in high half of a double register (in the lower half of
 8431 // the double register file) to double
 8432 instruct convI2D_regDHi_regD(regD dst, regD_low src) %{
 8433   effect(DEF dst, USE src);
 8434   size(4);
 8435   format %{ &quot;FITOD  $src,$dst&quot; %}
 8436   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fitod_opf);
 8437   ins_encode(form3_opf_rs2D_rdD(src, dst));
 8438   ins_pipe(fcvtLHi2D);
 8439 %}
 8440 
 8441 // Add float double precision
 8442 instruct addD_regD_regD(regD dst, regD src1, regD src2) %{
 8443   effect(DEF dst, USE src1, USE src2);
 8444   size(4);
 8445   format %{ &quot;FADDD  $src1,$src2,$dst&quot; %}
 8446   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::faddd_opf);
 8447   ins_encode(form3_opf_rs1D_rs2D_rdD(src1, src2, dst));
 8448   ins_pipe(faddD_reg_reg);
 8449 %}
 8450 
 8451 // Sub float double precision
 8452 instruct subD_regD_regD(regD dst, regD src1, regD src2) %{
 8453   effect(DEF dst, USE src1, USE src2);
 8454   size(4);
 8455   format %{ &quot;FSUBD  $src1,$src2,$dst&quot; %}
 8456   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fsubd_opf);
 8457   ins_encode(form3_opf_rs1D_rs2D_rdD(src1, src2, dst));
 8458   ins_pipe(faddD_reg_reg);
 8459 %}
 8460 
 8461 // Mul float double precision
 8462 instruct mulD_regD_regD(regD dst, regD src1, regD src2) %{
 8463   effect(DEF dst, USE src1, USE src2);
 8464   size(4);
 8465   format %{ &quot;FMULD  $src1,$src2,$dst&quot; %}
 8466   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fmuld_opf);
 8467   ins_encode(form3_opf_rs1D_rs2D_rdD(src1, src2, dst));
 8468   ins_pipe(fmulD_reg_reg);
 8469 %}
 8470 
 8471 // Long to Double conversion using fast fxtof
 8472 instruct convL2D_helper(regD dst, regD tmp) %{
 8473   effect(DEF dst, USE tmp);
 8474   size(4);
 8475   format %{ &quot;FXTOD  $tmp,$dst&quot; %}
 8476   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fxtod_opf);
 8477   ins_encode(form3_opf_rs2D_rdD(tmp, dst));
 8478   ins_pipe(fcvtL2D);
 8479 %}
 8480 
 8481 instruct convL2D_stk_fast_fxtof(regD dst, stackSlotL src) %{
 8482   match(Set dst (ConvL2D src));
 8483   ins_cost(DEFAULT_COST + 3 * MEMORY_REF_COST);
 8484   expand %{
 8485     regD tmp;
 8486     stkL_to_regD(tmp, src);
 8487     convL2D_helper(dst, tmp);
 8488   %}
 8489 %}
 8490 
 8491 instruct convL2D_reg(regD dst, iRegL src) %{
 8492   predicate(UseVIS &gt;= 3);
 8493   match(Set dst (ConvL2D src));
 8494   expand %{
 8495     regD tmp;
 8496     MoveL2D_reg_reg(tmp, src);
 8497     convL2D_helper(dst, tmp);
 8498   %}
 8499 %}
 8500 
 8501 // Long to Float conversion using fast fxtof
 8502 instruct convL2F_helper(regF dst, regD tmp) %{
 8503   effect(DEF dst, USE tmp);
 8504   size(4);
 8505   format %{ &quot;FXTOS  $tmp,$dst&quot; %}
 8506   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fxtos_opf);
 8507   ins_encode(form3_opf_rs2D_rdF(tmp, dst));
 8508   ins_pipe(fcvtL2F);
 8509 %}
 8510 
 8511 instruct convL2F_stk_fast_fxtof(regF dst, stackSlotL src) %{
 8512   match(Set dst (ConvL2F src));
 8513   ins_cost(DEFAULT_COST + MEMORY_REF_COST);
 8514   expand %{
 8515     regD tmp;
 8516     stkL_to_regD(tmp, src);
 8517     convL2F_helper(dst, tmp);
 8518   %}
 8519 %}
 8520 
 8521 instruct convL2F_reg(regF dst, iRegL src) %{
 8522   predicate(UseVIS &gt;= 3);
 8523   match(Set dst (ConvL2F src));
 8524   ins_cost(DEFAULT_COST);
 8525   expand %{
 8526     regD tmp;
 8527     MoveL2D_reg_reg(tmp, src);
 8528     convL2F_helper(dst, tmp);
 8529   %}
 8530 %}
 8531 
 8532 //-----------
 8533 
 8534 instruct convL2I_reg(iRegI dst, iRegL src) %{
 8535   match(Set dst (ConvL2I src));
 8536   size(4);
 8537   format %{ &quot;SRA    $src,R_G0,$dst\t! long-&gt;int&quot; %}
 8538   ins_encode( form3_rs1_rd_signextend_lo1( src, dst ) );
 8539   ins_pipe(ialu_reg);
 8540 %}
 8541 
 8542 // Register Shift Right Immediate
 8543 instruct shrL_reg_imm6_L2I(iRegI dst, iRegL src, immI_32_63 cnt) %{
 8544   match(Set dst (ConvL2I (RShiftL src cnt)));
 8545 
 8546   size(4);
 8547   format %{ &quot;SRAX   $src,$cnt,$dst&quot; %}
 8548   opcode(Assembler::srax_op3, Assembler::arith_op);
 8549   ins_encode( form3_sd_rs1_imm6_rd( src, cnt, dst ) );
 8550   ins_pipe(ialu_reg_imm);
 8551 %}
 8552 
 8553 //----------Control Flow Instructions------------------------------------------
 8554 // Compare Instructions
 8555 // Compare Integers
 8556 instruct compI_iReg(flagsReg icc, iRegI op1, iRegI op2) %{
 8557   match(Set icc (CmpI op1 op2));
 8558   effect( DEF icc, USE op1, USE op2 );
 8559 
 8560   size(4);
 8561   format %{ &quot;CMP    $op1,$op2&quot; %}
 8562   opcode(Assembler::subcc_op3, Assembler::arith_op);
 8563   ins_encode( form3_rs1_rs2_rd( op1, op2, R_G0 ) );
 8564   ins_pipe(ialu_cconly_reg_reg);
 8565 %}
 8566 
 8567 instruct compU_iReg(flagsRegU icc, iRegI op1, iRegI op2) %{
 8568   match(Set icc (CmpU op1 op2));
 8569 
 8570   size(4);
 8571   format %{ &quot;CMP    $op1,$op2\t! unsigned&quot; %}
 8572   opcode(Assembler::subcc_op3, Assembler::arith_op);
 8573   ins_encode( form3_rs1_rs2_rd( op1, op2, R_G0 ) );
 8574   ins_pipe(ialu_cconly_reg_reg);
 8575 %}
 8576 
 8577 instruct compUL_iReg(flagsRegUL xcc, iRegL op1, iRegL op2) %{
 8578   match(Set xcc (CmpUL op1 op2));
 8579   effect(DEF xcc, USE op1, USE op2);
 8580 
 8581   size(4);
 8582   format %{ &quot;CMP    $op1,$op2\t! unsigned long&quot; %}
 8583   opcode(Assembler::subcc_op3, Assembler::arith_op);
 8584   ins_encode(form3_rs1_rs2_rd(op1, op2, R_G0));
 8585   ins_pipe(ialu_cconly_reg_reg);
 8586 %}
 8587 
 8588 instruct compI_iReg_imm13(flagsReg icc, iRegI op1, immI13 op2) %{
 8589   match(Set icc (CmpI op1 op2));
 8590   effect( DEF icc, USE op1 );
 8591 
 8592   size(4);
 8593   format %{ &quot;CMP    $op1,$op2&quot; %}
 8594   opcode(Assembler::subcc_op3, Assembler::arith_op);
 8595   ins_encode( form3_rs1_simm13_rd( op1, op2, R_G0 ) );
 8596   ins_pipe(ialu_cconly_reg_imm);
 8597 %}
 8598 
 8599 instruct testI_reg_reg( flagsReg icc, iRegI op1, iRegI op2, immI0 zero ) %{
 8600   match(Set icc (CmpI (AndI op1 op2) zero));
 8601 
 8602   size(4);
 8603   format %{ &quot;BTST   $op2,$op1&quot; %}
 8604   opcode(Assembler::andcc_op3, Assembler::arith_op);
 8605   ins_encode( form3_rs1_rs2_rd( op1, op2, R_G0 ) );
 8606   ins_pipe(ialu_cconly_reg_reg_zero);
 8607 %}
 8608 
 8609 instruct testI_reg_imm( flagsReg icc, iRegI op1, immI13 op2, immI0 zero ) %{
 8610   match(Set icc (CmpI (AndI op1 op2) zero));
 8611 
 8612   size(4);
 8613   format %{ &quot;BTST   $op2,$op1&quot; %}
 8614   opcode(Assembler::andcc_op3, Assembler::arith_op);
 8615   ins_encode( form3_rs1_simm13_rd( op1, op2, R_G0 ) );
 8616   ins_pipe(ialu_cconly_reg_imm_zero);
 8617 %}
 8618 
 8619 instruct compL_reg_reg(flagsRegL xcc, iRegL op1, iRegL op2 ) %{
 8620   match(Set xcc (CmpL op1 op2));
 8621   effect( DEF xcc, USE op1, USE op2 );
 8622 
 8623   size(4);
 8624   format %{ &quot;CMP    $op1,$op2\t\t! long&quot; %}
 8625   opcode(Assembler::subcc_op3, Assembler::arith_op);
 8626   ins_encode( form3_rs1_rs2_rd( op1, op2, R_G0 ) );
 8627   ins_pipe(ialu_cconly_reg_reg);
 8628 %}
 8629 
 8630 instruct compL_reg_con(flagsRegL xcc, iRegL op1, immL13 con) %{
 8631   match(Set xcc (CmpL op1 con));
 8632   effect( DEF xcc, USE op1, USE con );
 8633 
 8634   size(4);
 8635   format %{ &quot;CMP    $op1,$con\t\t! long&quot; %}
 8636   opcode(Assembler::subcc_op3, Assembler::arith_op);
 8637   ins_encode( form3_rs1_simm13_rd( op1, con, R_G0 ) );
 8638   ins_pipe(ialu_cconly_reg_reg);
 8639 %}
 8640 
 8641 instruct testL_reg_reg(flagsRegL xcc, iRegL op1, iRegL op2, immL0 zero) %{
 8642   match(Set xcc (CmpL (AndL op1 op2) zero));
 8643   effect( DEF xcc, USE op1, USE op2 );
 8644 
 8645   size(4);
 8646   format %{ &quot;BTST   $op1,$op2\t\t! long&quot; %}
 8647   opcode(Assembler::andcc_op3, Assembler::arith_op);
 8648   ins_encode( form3_rs1_rs2_rd( op1, op2, R_G0 ) );
 8649   ins_pipe(ialu_cconly_reg_reg);
 8650 %}
 8651 
 8652 // useful for checking the alignment of a pointer:
 8653 instruct testL_reg_con(flagsRegL xcc, iRegL op1, immL13 con, immL0 zero) %{
 8654   match(Set xcc (CmpL (AndL op1 con) zero));
 8655   effect( DEF xcc, USE op1, USE con );
 8656 
 8657   size(4);
 8658   format %{ &quot;BTST   $op1,$con\t\t! long&quot; %}
 8659   opcode(Assembler::andcc_op3, Assembler::arith_op);
 8660   ins_encode( form3_rs1_simm13_rd( op1, con, R_G0 ) );
 8661   ins_pipe(ialu_cconly_reg_reg);
 8662 %}
 8663 
 8664 instruct compU_iReg_imm13(flagsRegU icc, iRegI op1, immU12 op2 ) %{
 8665   match(Set icc (CmpU op1 op2));
 8666 
 8667   size(4);
 8668   format %{ &quot;CMP    $op1,$op2\t! unsigned&quot; %}
 8669   opcode(Assembler::subcc_op3, Assembler::arith_op);
 8670   ins_encode( form3_rs1_simm13_rd( op1, op2, R_G0 ) );
 8671   ins_pipe(ialu_cconly_reg_imm);
 8672 %}
 8673 
 8674 instruct compUL_iReg_imm13(flagsRegUL xcc, iRegL op1, immUL12 op2) %{
 8675   match(Set xcc (CmpUL op1 op2));
 8676   effect(DEF xcc, USE op1, USE op2);
 8677 
 8678   size(4);
 8679   format %{ &quot;CMP    $op1,$op2\t! unsigned long&quot; %}
 8680   opcode(Assembler::subcc_op3, Assembler::arith_op);
 8681   ins_encode(form3_rs1_simm13_rd(op1, op2, R_G0));
 8682   ins_pipe(ialu_cconly_reg_imm);
 8683 %}
 8684 
 8685 // Compare Pointers
 8686 instruct compP_iRegP(flagsRegP pcc, iRegP op1, iRegP op2 ) %{
 8687   match(Set pcc (CmpP op1 op2));
 8688 
 8689   size(4);
 8690   format %{ &quot;CMP    $op1,$op2\t! ptr&quot; %}
 8691   opcode(Assembler::subcc_op3, Assembler::arith_op);
 8692   ins_encode( form3_rs1_rs2_rd( op1, op2, R_G0 ) );
 8693   ins_pipe(ialu_cconly_reg_reg);
 8694 %}
 8695 
 8696 instruct compP_iRegP_imm13(flagsRegP pcc, iRegP op1, immP13 op2 ) %{
 8697   match(Set pcc (CmpP op1 op2));
 8698 
 8699   size(4);
 8700   format %{ &quot;CMP    $op1,$op2\t! ptr&quot; %}
 8701   opcode(Assembler::subcc_op3, Assembler::arith_op);
 8702   ins_encode( form3_rs1_simm13_rd( op1, op2, R_G0 ) );
 8703   ins_pipe(ialu_cconly_reg_imm);
 8704 %}
 8705 
 8706 // Compare Narrow oops
 8707 instruct compN_iRegN(flagsReg icc, iRegN op1, iRegN op2 ) %{
 8708   match(Set icc (CmpN op1 op2));
 8709 
 8710   size(4);
 8711   format %{ &quot;CMP    $op1,$op2\t! compressed ptr&quot; %}
 8712   opcode(Assembler::subcc_op3, Assembler::arith_op);
 8713   ins_encode( form3_rs1_rs2_rd( op1, op2, R_G0 ) );
 8714   ins_pipe(ialu_cconly_reg_reg);
 8715 %}
 8716 
 8717 instruct compN_iRegN_immN0(flagsReg icc, iRegN op1, immN0 op2 ) %{
 8718   match(Set icc (CmpN op1 op2));
 8719 
 8720   size(4);
 8721   format %{ &quot;CMP    $op1,$op2\t! compressed ptr&quot; %}
 8722   opcode(Assembler::subcc_op3, Assembler::arith_op);
 8723   ins_encode( form3_rs1_simm13_rd( op1, op2, R_G0 ) );
 8724   ins_pipe(ialu_cconly_reg_imm);
 8725 %}
 8726 
 8727 //----------Max and Min--------------------------------------------------------
 8728 // Min Instructions
 8729 // Conditional move for min
 8730 instruct cmovI_reg_lt( iRegI op2, iRegI op1, flagsReg icc ) %{
 8731   effect( USE_DEF op2, USE op1, USE icc );
 8732 
 8733   size(4);
 8734   format %{ &quot;MOVlt  icc,$op1,$op2\t! min&quot; %}
 8735   opcode(Assembler::less);
 8736   ins_encode( enc_cmov_reg_minmax(op2,op1) );
 8737   ins_pipe(ialu_reg_flags);
 8738 %}
 8739 
 8740 // Min Register with Register.
 8741 instruct minI_eReg(iRegI op1, iRegI op2) %{
 8742   match(Set op2 (MinI op1 op2));
 8743   ins_cost(DEFAULT_COST*2);
 8744   expand %{
 8745     flagsReg icc;
 8746     compI_iReg(icc,op1,op2);
 8747     cmovI_reg_lt(op2,op1,icc);
 8748   %}
 8749 %}
 8750 
 8751 // Max Instructions
 8752 // Conditional move for max
 8753 instruct cmovI_reg_gt( iRegI op2, iRegI op1, flagsReg icc ) %{
 8754   effect( USE_DEF op2, USE op1, USE icc );
 8755   format %{ &quot;MOVgt  icc,$op1,$op2\t! max&quot; %}
 8756   opcode(Assembler::greater);
 8757   ins_encode( enc_cmov_reg_minmax(op2,op1) );
 8758   ins_pipe(ialu_reg_flags);
 8759 %}
 8760 
 8761 // Max Register with Register
 8762 instruct maxI_eReg(iRegI op1, iRegI op2) %{
 8763   match(Set op2 (MaxI op1 op2));
 8764   ins_cost(DEFAULT_COST*2);
 8765   expand %{
 8766     flagsReg icc;
 8767     compI_iReg(icc,op1,op2);
 8768     cmovI_reg_gt(op2,op1,icc);
 8769   %}
 8770 %}
 8771 
 8772 
 8773 //----------Float Compares----------------------------------------------------
 8774 // Compare floating, generate condition code
 8775 instruct cmpF_cc(flagsRegF fcc, regF src1, regF src2) %{
 8776   match(Set fcc (CmpF src1 src2));
 8777 
 8778   size(4);
 8779   format %{ &quot;FCMPs  $fcc,$src1,$src2&quot; %}
 8780   opcode(Assembler::fpop2_op3, Assembler::arith_op, Assembler::fcmps_opf);
 8781   ins_encode( form3_opf_rs1F_rs2F_fcc( src1, src2, fcc ) );
 8782   ins_pipe(faddF_fcc_reg_reg_zero);
 8783 %}
 8784 
 8785 instruct cmpD_cc(flagsRegF fcc, regD src1, regD src2) %{
 8786   match(Set fcc (CmpD src1 src2));
 8787 
 8788   size(4);
 8789   format %{ &quot;FCMPd  $fcc,$src1,$src2&quot; %}
 8790   opcode(Assembler::fpop2_op3, Assembler::arith_op, Assembler::fcmpd_opf);
 8791   ins_encode( form3_opf_rs1D_rs2D_fcc( src1, src2, fcc ) );
 8792   ins_pipe(faddD_fcc_reg_reg_zero);
 8793 %}
 8794 
 8795 
 8796 // Compare floating, generate -1,0,1
 8797 instruct cmpF_reg(iRegI dst, regF src1, regF src2, flagsRegF0 fcc0) %{
 8798   match(Set dst (CmpF3 src1 src2));
 8799   effect(KILL fcc0);
 8800   ins_cost(DEFAULT_COST*3+BRANCH_COST*3);
 8801   format %{ &quot;fcmpl  $dst,$src1,$src2&quot; %}
 8802   // Primary = float
 8803   opcode( true );
 8804   ins_encode( floating_cmp( dst, src1, src2 ) );
 8805   ins_pipe( floating_cmp );
 8806 %}
 8807 
 8808 instruct cmpD_reg(iRegI dst, regD src1, regD src2, flagsRegF0 fcc0) %{
 8809   match(Set dst (CmpD3 src1 src2));
 8810   effect(KILL fcc0);
 8811   ins_cost(DEFAULT_COST*3+BRANCH_COST*3);
 8812   format %{ &quot;dcmpl  $dst,$src1,$src2&quot; %}
 8813   // Primary = double (not float)
 8814   opcode( false );
 8815   ins_encode( floating_cmp( dst, src1, src2 ) );
 8816   ins_pipe( floating_cmp );
 8817 %}
 8818 
 8819 //----------Branches---------------------------------------------------------
 8820 // Jump
 8821 // (compare &#39;operand indIndex&#39; and &#39;instruct addP_reg_reg&#39; above)
 8822 instruct jumpXtnd(iRegX switch_val, o7RegI table) %{
 8823   match(Jump switch_val);
 8824   effect(TEMP table);
 8825 
 8826   ins_cost(350);
 8827 
 8828   format %{  &quot;ADD    $constanttablebase, $constantoffset, O7\n\t&quot;
 8829              &quot;LD     [O7 + $switch_val], O7\n\t&quot;
 8830              &quot;JUMP   O7&quot; %}
 8831   ins_encode %{
 8832     // Calculate table address into a register.
 8833     Register table_reg;
 8834     Register label_reg = O7;
 8835     // If we are calculating the size of this instruction don&#39;t trust
 8836     // zero offsets because they might change when
 8837     // MachConstantBaseNode decides to optimize the constant table
 8838     // base.
<a name="83" id="anc83"></a><span class="line-modified"> 8839     if ((constant_offset() == 0) &amp;&amp; !Compile::current()-&gt;output()-&gt;in_scratch_emit_size()) {</span>
 8840       table_reg = $constanttablebase;
 8841     } else {
 8842       table_reg = O7;
 8843       RegisterOrConstant con_offset = __ ensure_simm13_or_reg($constantoffset, O7);
 8844       __ add($constanttablebase, con_offset, table_reg);
 8845     }
 8846 
 8847     // Jump to base address + switch value
 8848     __ ld_ptr(table_reg, $switch_val$$Register, label_reg);
 8849     __ jmp(label_reg, G0);
 8850     __ delayed()-&gt;nop();
 8851   %}
 8852   ins_pipe(ialu_reg_reg);
 8853 %}
 8854 
 8855 // Direct Branch.  Use V8 version with longer range.
 8856 instruct branch(label labl) %{
 8857   match(Goto);
 8858   effect(USE labl);
 8859 
 8860   size(8);
 8861   ins_cost(BRANCH_COST);
 8862   format %{ &quot;BA     $labl&quot; %}
 8863   ins_encode %{
 8864     Label* L = $labl$$label;
 8865     __ ba(*L);
 8866     __ delayed()-&gt;nop();
 8867   %}
 8868   ins_avoid_back_to_back(AVOID_BEFORE);
 8869   ins_pipe(br);
 8870 %}
 8871 
 8872 // Direct Branch, short with no delay slot
 8873 instruct branch_short(label labl) %{
 8874   match(Goto);
 8875   predicate(UseCBCond);
 8876   effect(USE labl);
 8877 
 8878   size(4); // Assuming no NOP inserted.
 8879   ins_cost(BRANCH_COST);
 8880   format %{ &quot;BA     $labl\t! short branch&quot; %}
 8881   ins_encode %{
 8882     Label* L = $labl$$label;
 8883     assert(__ use_cbcond(*L), &quot;back to back cbcond&quot;);
 8884     __ ba_short(*L);
 8885   %}
 8886   ins_short_branch(1);
 8887   ins_avoid_back_to_back(AVOID_BEFORE_AND_AFTER);
 8888   ins_pipe(cbcond_reg_imm);
 8889 %}
 8890 
 8891 // Conditional Direct Branch
 8892 instruct branchCon(cmpOp cmp, flagsReg icc, label labl) %{
 8893   match(If cmp icc);
 8894   effect(USE labl);
 8895 
 8896   size(8);
 8897   ins_cost(BRANCH_COST);
 8898   format %{ &quot;BP$cmp   $icc,$labl&quot; %}
 8899   // Prim = bits 24-22, Secnd = bits 31-30
 8900   ins_encode( enc_bp( labl, cmp, icc ) );
 8901   ins_avoid_back_to_back(AVOID_BEFORE);
 8902   ins_pipe(br_cc);
 8903 %}
 8904 
 8905 instruct branchConU(cmpOpU cmp, flagsRegU icc, label labl) %{
 8906   match(If cmp icc);
 8907   effect(USE labl);
 8908 
 8909   ins_cost(BRANCH_COST);
 8910   format %{ &quot;BP$cmp  $icc,$labl&quot; %}
 8911   // Prim = bits 24-22, Secnd = bits 31-30
 8912   ins_encode( enc_bp( labl, cmp, icc ) );
 8913   ins_avoid_back_to_back(AVOID_BEFORE);
 8914   ins_pipe(br_cc);
 8915 %}
 8916 
 8917 instruct branchConP(cmpOpP cmp, flagsRegP pcc, label labl) %{
 8918   match(If cmp pcc);
 8919   effect(USE labl);
 8920 
 8921   size(8);
 8922   ins_cost(BRANCH_COST);
 8923   format %{ &quot;BP$cmp  $pcc,$labl&quot; %}
 8924   ins_encode %{
 8925     Label* L = $labl$$label;
 8926     Assembler::Predict predict_taken =
 8927       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 8928 
 8929     __ bp( (Assembler::Condition)($cmp$$cmpcode), false, Assembler::ptr_cc, predict_taken, *L);
 8930     __ delayed()-&gt;nop();
 8931   %}
 8932   ins_avoid_back_to_back(AVOID_BEFORE);
 8933   ins_pipe(br_cc);
 8934 %}
 8935 
 8936 instruct branchConF(cmpOpF cmp, flagsRegF fcc, label labl) %{
 8937   match(If cmp fcc);
 8938   effect(USE labl);
 8939 
 8940   size(8);
 8941   ins_cost(BRANCH_COST);
 8942   format %{ &quot;FBP$cmp $fcc,$labl&quot; %}
 8943   ins_encode %{
 8944     Label* L = $labl$$label;
 8945     Assembler::Predict predict_taken =
 8946       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 8947 
 8948     __ fbp( (Assembler::Condition)($cmp$$cmpcode), false, (Assembler::CC)($fcc$$reg), predict_taken, *L);
 8949     __ delayed()-&gt;nop();
 8950   %}
 8951   ins_avoid_back_to_back(AVOID_BEFORE);
 8952   ins_pipe(br_fcc);
 8953 %}
 8954 
 8955 instruct branchLoopEnd(cmpOp cmp, flagsReg icc, label labl) %{
 8956   match(CountedLoopEnd cmp icc);
 8957   effect(USE labl);
 8958 
 8959   size(8);
 8960   ins_cost(BRANCH_COST);
 8961   format %{ &quot;BP$cmp   $icc,$labl\t! Loop end&quot; %}
 8962   // Prim = bits 24-22, Secnd = bits 31-30
 8963   ins_encode( enc_bp( labl, cmp, icc ) );
 8964   ins_avoid_back_to_back(AVOID_BEFORE);
 8965   ins_pipe(br_cc);
 8966 %}
 8967 
 8968 instruct branchLoopEndU(cmpOpU cmp, flagsRegU icc, label labl) %{
 8969   match(CountedLoopEnd cmp icc);
 8970   effect(USE labl);
 8971 
 8972   size(8);
 8973   ins_cost(BRANCH_COST);
 8974   format %{ &quot;BP$cmp  $icc,$labl\t! Loop end&quot; %}
 8975   // Prim = bits 24-22, Secnd = bits 31-30
 8976   ins_encode( enc_bp( labl, cmp, icc ) );
 8977   ins_avoid_back_to_back(AVOID_BEFORE);
 8978   ins_pipe(br_cc);
 8979 %}
 8980 
 8981 // Compare and branch instructions
 8982 instruct cmpI_reg_branch(cmpOp cmp, iRegI op1, iRegI op2, label labl, flagsReg icc) %{
 8983   match(If cmp (CmpI op1 op2));
 8984   effect(USE labl, KILL icc);
 8985 
 8986   size(12);
 8987   ins_cost(BRANCH_COST);
 8988   format %{ &quot;CMP    $op1,$op2\t! int\n\t&quot;
 8989             &quot;BP$cmp   $labl&quot; %}
 8990   ins_encode %{
 8991     Label* L = $labl$$label;
 8992     Assembler::Predict predict_taken =
 8993       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 8994     __ cmp($op1$$Register, $op2$$Register);
 8995     __ bp((Assembler::Condition)($cmp$$cmpcode), false, Assembler::icc, predict_taken, *L);
 8996     __ delayed()-&gt;nop();
 8997   %}
 8998   ins_pipe(cmp_br_reg_reg);
 8999 %}
 9000 
 9001 instruct cmpI_imm_branch(cmpOp cmp, iRegI op1, immI5 op2, label labl, flagsReg icc) %{
 9002   match(If cmp (CmpI op1 op2));
 9003   effect(USE labl, KILL icc);
 9004 
 9005   size(12);
 9006   ins_cost(BRANCH_COST);
 9007   format %{ &quot;CMP    $op1,$op2\t! int\n\t&quot;
 9008             &quot;BP$cmp   $labl&quot; %}
 9009   ins_encode %{
 9010     Label* L = $labl$$label;
 9011     Assembler::Predict predict_taken =
 9012       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9013     __ cmp($op1$$Register, $op2$$constant);
 9014     __ bp((Assembler::Condition)($cmp$$cmpcode), false, Assembler::icc, predict_taken, *L);
 9015     __ delayed()-&gt;nop();
 9016   %}
 9017   ins_pipe(cmp_br_reg_imm);
 9018 %}
 9019 
 9020 instruct cmpU_reg_branch(cmpOpU cmp, iRegI op1, iRegI op2, label labl, flagsRegU icc) %{
 9021   match(If cmp (CmpU op1 op2));
 9022   effect(USE labl, KILL icc);
 9023 
 9024   size(12);
 9025   ins_cost(BRANCH_COST);
 9026   format %{ &quot;CMP    $op1,$op2\t! unsigned\n\t&quot;
 9027             &quot;BP$cmp  $labl&quot; %}
 9028   ins_encode %{
 9029     Label* L = $labl$$label;
 9030     Assembler::Predict predict_taken =
 9031       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9032     __ cmp($op1$$Register, $op2$$Register);
 9033     __ bp((Assembler::Condition)($cmp$$cmpcode), false, Assembler::icc, predict_taken, *L);
 9034     __ delayed()-&gt;nop();
 9035   %}
 9036   ins_pipe(cmp_br_reg_reg);
 9037 %}
 9038 
 9039 instruct cmpU_imm_branch(cmpOpU cmp, iRegI op1, immI5 op2, label labl, flagsRegU icc) %{
 9040   match(If cmp (CmpU op1 op2));
 9041   effect(USE labl, KILL icc);
 9042 
 9043   size(12);
 9044   ins_cost(BRANCH_COST);
 9045   format %{ &quot;CMP    $op1,$op2\t! unsigned\n\t&quot;
 9046             &quot;BP$cmp  $labl&quot; %}
 9047   ins_encode %{
 9048     Label* L = $labl$$label;
 9049     Assembler::Predict predict_taken =
 9050       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9051     __ cmp($op1$$Register, $op2$$constant);
 9052     __ bp((Assembler::Condition)($cmp$$cmpcode), false, Assembler::icc, predict_taken, *L);
 9053     __ delayed()-&gt;nop();
 9054   %}
 9055   ins_pipe(cmp_br_reg_imm);
 9056 %}
 9057 
 9058 instruct cmpUL_reg_branch(cmpOpU cmp, iRegL op1, iRegL op2, label labl, flagsRegUL xcc) %{
 9059   match(If cmp (CmpUL op1 op2));
 9060   effect(USE labl, KILL xcc);
 9061 
 9062   size(12);
 9063   ins_cost(BRANCH_COST);
 9064   format %{ &quot;CMP    $op1,$op2\t! unsigned long\n\t&quot;
 9065             &quot;BP$cmp   $labl&quot; %}
 9066   ins_encode %{
 9067     Label* L = $labl$$label;
 9068     Assembler::Predict predict_taken =
 9069       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9070     __ cmp($op1$$Register, $op2$$Register);
 9071     __ bp((Assembler::Condition)($cmp$$cmpcode), false, Assembler::xcc, predict_taken, *L);
 9072     __ delayed()-&gt;nop();
 9073   %}
 9074   ins_pipe(cmp_br_reg_reg);
 9075 %}
 9076 
 9077 instruct cmpUL_imm_branch(cmpOpU cmp, iRegL op1, immL5 op2, label labl, flagsRegUL xcc) %{
 9078   match(If cmp (CmpUL op1 op2));
 9079   effect(USE labl, KILL xcc);
 9080 
 9081   size(12);
 9082   ins_cost(BRANCH_COST);
 9083   format %{ &quot;CMP    $op1,$op2\t! unsigned long\n\t&quot;
 9084             &quot;BP$cmp   $labl&quot; %}
 9085   ins_encode %{
 9086     Label* L = $labl$$label;
 9087     Assembler::Predict predict_taken =
 9088       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9089     __ cmp($op1$$Register, $op2$$constant);
 9090     __ bp((Assembler::Condition)($cmp$$cmpcode), false, Assembler::xcc, predict_taken, *L);
 9091     __ delayed()-&gt;nop();
 9092   %}
 9093   ins_pipe(cmp_br_reg_imm);
 9094 %}
 9095 
 9096 instruct cmpL_reg_branch(cmpOp cmp, iRegL op1, iRegL op2, label labl, flagsRegL xcc) %{
 9097   match(If cmp (CmpL op1 op2));
 9098   effect(USE labl, KILL xcc);
 9099 
 9100   size(12);
 9101   ins_cost(BRANCH_COST);
 9102   format %{ &quot;CMP    $op1,$op2\t! long\n\t&quot;
 9103             &quot;BP$cmp   $labl&quot; %}
 9104   ins_encode %{
 9105     Label* L = $labl$$label;
 9106     Assembler::Predict predict_taken =
 9107       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9108     __ cmp($op1$$Register, $op2$$Register);
 9109     __ bp((Assembler::Condition)($cmp$$cmpcode), false, Assembler::xcc, predict_taken, *L);
 9110     __ delayed()-&gt;nop();
 9111   %}
 9112   ins_pipe(cmp_br_reg_reg);
 9113 %}
 9114 
 9115 instruct cmpL_imm_branch(cmpOp cmp, iRegL op1, immL5 op2, label labl, flagsRegL xcc) %{
 9116   match(If cmp (CmpL op1 op2));
 9117   effect(USE labl, KILL xcc);
 9118 
 9119   size(12);
 9120   ins_cost(BRANCH_COST);
 9121   format %{ &quot;CMP    $op1,$op2\t! long\n\t&quot;
 9122             &quot;BP$cmp   $labl&quot; %}
 9123   ins_encode %{
 9124     Label* L = $labl$$label;
 9125     Assembler::Predict predict_taken =
 9126       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9127     __ cmp($op1$$Register, $op2$$constant);
 9128     __ bp((Assembler::Condition)($cmp$$cmpcode), false, Assembler::xcc, predict_taken, *L);
 9129     __ delayed()-&gt;nop();
 9130   %}
 9131   ins_pipe(cmp_br_reg_imm);
 9132 %}
 9133 
 9134 // Compare Pointers and branch
 9135 instruct cmpP_reg_branch(cmpOpP cmp, iRegP op1, iRegP op2, label labl, flagsRegP pcc) %{
 9136   match(If cmp (CmpP op1 op2));
 9137   effect(USE labl, KILL pcc);
 9138 
 9139   size(12);
 9140   ins_cost(BRANCH_COST);
 9141   format %{ &quot;CMP    $op1,$op2\t! ptr\n\t&quot;
 9142             &quot;B$cmp   $labl&quot; %}
 9143   ins_encode %{
 9144     Label* L = $labl$$label;
 9145     Assembler::Predict predict_taken =
 9146       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9147     __ cmp($op1$$Register, $op2$$Register);
 9148     __ bp((Assembler::Condition)($cmp$$cmpcode), false, Assembler::ptr_cc, predict_taken, *L);
 9149     __ delayed()-&gt;nop();
 9150   %}
 9151   ins_pipe(cmp_br_reg_reg);
 9152 %}
 9153 
 9154 instruct cmpP_null_branch(cmpOpP cmp, iRegP op1, immP0 null, label labl, flagsRegP pcc) %{
 9155   match(If cmp (CmpP op1 null));
 9156   effect(USE labl, KILL pcc);
 9157 
 9158   size(12);
 9159   ins_cost(BRANCH_COST);
 9160   format %{ &quot;CMP    $op1,0\t! ptr\n\t&quot;
 9161             &quot;B$cmp   $labl&quot; %}
 9162   ins_encode %{
 9163     Label* L = $labl$$label;
 9164     Assembler::Predict predict_taken =
 9165       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9166     __ cmp($op1$$Register, G0);
 9167     // bpr() is not used here since it has shorter distance.
 9168     __ bp((Assembler::Condition)($cmp$$cmpcode), false, Assembler::ptr_cc, predict_taken, *L);
 9169     __ delayed()-&gt;nop();
 9170   %}
 9171   ins_pipe(cmp_br_reg_reg);
 9172 %}
 9173 
 9174 instruct cmpN_reg_branch(cmpOp cmp, iRegN op1, iRegN op2, label labl, flagsReg icc) %{
 9175   match(If cmp (CmpN op1 op2));
 9176   effect(USE labl, KILL icc);
 9177 
 9178   size(12);
 9179   ins_cost(BRANCH_COST);
 9180   format %{ &quot;CMP    $op1,$op2\t! compressed ptr\n\t&quot;
 9181             &quot;BP$cmp   $labl&quot; %}
 9182   ins_encode %{
 9183     Label* L = $labl$$label;
 9184     Assembler::Predict predict_taken =
 9185       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9186     __ cmp($op1$$Register, $op2$$Register);
 9187     __ bp((Assembler::Condition)($cmp$$cmpcode), false, Assembler::icc, predict_taken, *L);
 9188     __ delayed()-&gt;nop();
 9189   %}
 9190   ins_pipe(cmp_br_reg_reg);
 9191 %}
 9192 
 9193 instruct cmpN_null_branch(cmpOp cmp, iRegN op1, immN0 null, label labl, flagsReg icc) %{
 9194   match(If cmp (CmpN op1 null));
 9195   effect(USE labl, KILL icc);
 9196 
 9197   size(12);
 9198   ins_cost(BRANCH_COST);
 9199   format %{ &quot;CMP    $op1,0\t! compressed ptr\n\t&quot;
 9200             &quot;BP$cmp   $labl&quot; %}
 9201   ins_encode %{
 9202     Label* L = $labl$$label;
 9203     Assembler::Predict predict_taken =
 9204       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9205     __ cmp($op1$$Register, G0);
 9206     __ bp((Assembler::Condition)($cmp$$cmpcode), false, Assembler::icc, predict_taken, *L);
 9207     __ delayed()-&gt;nop();
 9208   %}
 9209   ins_pipe(cmp_br_reg_reg);
 9210 %}
 9211 
 9212 // Loop back branch
 9213 instruct cmpI_reg_branchLoopEnd(cmpOp cmp, iRegI op1, iRegI op2, label labl, flagsReg icc) %{
 9214   match(CountedLoopEnd cmp (CmpI op1 op2));
 9215   effect(USE labl, KILL icc);
 9216 
 9217   size(12);
 9218   ins_cost(BRANCH_COST);
 9219   format %{ &quot;CMP    $op1,$op2\t! int\n\t&quot;
 9220             &quot;BP$cmp   $labl\t! Loop end&quot; %}
 9221   ins_encode %{
 9222     Label* L = $labl$$label;
 9223     Assembler::Predict predict_taken =
 9224       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9225     __ cmp($op1$$Register, $op2$$Register);
 9226     __ bp((Assembler::Condition)($cmp$$cmpcode), false, Assembler::icc, predict_taken, *L);
 9227     __ delayed()-&gt;nop();
 9228   %}
 9229   ins_pipe(cmp_br_reg_reg);
 9230 %}
 9231 
 9232 instruct cmpI_imm_branchLoopEnd(cmpOp cmp, iRegI op1, immI5 op2, label labl, flagsReg icc) %{
 9233   match(CountedLoopEnd cmp (CmpI op1 op2));
 9234   effect(USE labl, KILL icc);
 9235 
 9236   size(12);
 9237   ins_cost(BRANCH_COST);
 9238   format %{ &quot;CMP    $op1,$op2\t! int\n\t&quot;
 9239             &quot;BP$cmp   $labl\t! Loop end&quot; %}
 9240   ins_encode %{
 9241     Label* L = $labl$$label;
 9242     Assembler::Predict predict_taken =
 9243       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9244     __ cmp($op1$$Register, $op2$$constant);
 9245     __ bp((Assembler::Condition)($cmp$$cmpcode), false, Assembler::icc, predict_taken, *L);
 9246     __ delayed()-&gt;nop();
 9247   %}
 9248   ins_pipe(cmp_br_reg_imm);
 9249 %}
 9250 
 9251 // Short compare and branch instructions
 9252 instruct cmpI_reg_branch_short(cmpOp cmp, iRegI op1, iRegI op2, label labl, flagsReg icc) %{
 9253   match(If cmp (CmpI op1 op2));
 9254   predicate(UseCBCond);
 9255   effect(USE labl, KILL icc);
 9256 
 9257   size(4); // Assuming no NOP inserted.
 9258   ins_cost(BRANCH_COST);
 9259   format %{ &quot;CWB$cmp  $op1,$op2,$labl\t! int&quot; %}
 9260   ins_encode %{
 9261     Label* L = $labl$$label;
 9262     assert(__ use_cbcond(*L), &quot;back to back cbcond&quot;);
 9263     __ cbcond((Assembler::Condition)($cmp$$cmpcode), Assembler::icc, $op1$$Register, $op2$$Register, *L);
 9264   %}
 9265   ins_short_branch(1);
 9266   ins_avoid_back_to_back(AVOID_BEFORE_AND_AFTER);
 9267   ins_pipe(cbcond_reg_reg);
 9268 %}
 9269 
 9270 instruct cmpI_imm_branch_short(cmpOp cmp, iRegI op1, immI5 op2, label labl, flagsReg icc) %{
 9271   match(If cmp (CmpI op1 op2));
 9272   predicate(UseCBCond);
 9273   effect(USE labl, KILL icc);
 9274 
 9275   size(4); // Assuming no NOP inserted.
 9276   ins_cost(BRANCH_COST);
 9277   format %{ &quot;CWB$cmp  $op1,$op2,$labl\t! int&quot; %}
 9278   ins_encode %{
 9279     Label* L = $labl$$label;
 9280     assert(__ use_cbcond(*L), &quot;back to back cbcond&quot;);
 9281     __ cbcond((Assembler::Condition)($cmp$$cmpcode), Assembler::icc, $op1$$Register, $op2$$constant, *L);
 9282   %}
 9283   ins_short_branch(1);
 9284   ins_avoid_back_to_back(AVOID_BEFORE_AND_AFTER);
 9285   ins_pipe(cbcond_reg_imm);
 9286 %}
 9287 
 9288 instruct cmpU_reg_branch_short(cmpOpU cmp, iRegI op1, iRegI op2, label labl, flagsRegU icc) %{
 9289   match(If cmp (CmpU op1 op2));
 9290   predicate(UseCBCond);
 9291   effect(USE labl, KILL icc);
 9292 
 9293   size(4); // Assuming no NOP inserted.
 9294   ins_cost(BRANCH_COST);
 9295   format %{ &quot;CWB$cmp $op1,$op2,$labl\t! unsigned&quot; %}
 9296   ins_encode %{
 9297     Label* L = $labl$$label;
 9298     assert(__ use_cbcond(*L), &quot;back to back cbcond&quot;);
 9299     __ cbcond((Assembler::Condition)($cmp$$cmpcode), Assembler::icc, $op1$$Register, $op2$$Register, *L);
 9300   %}
 9301   ins_short_branch(1);
 9302   ins_avoid_back_to_back(AVOID_BEFORE_AND_AFTER);
 9303   ins_pipe(cbcond_reg_reg);
 9304 %}
 9305 
 9306 instruct cmpU_imm_branch_short(cmpOpU cmp, iRegI op1, immI5 op2, label labl, flagsRegU icc) %{
 9307   match(If cmp (CmpU op1 op2));
 9308   predicate(UseCBCond);
 9309   effect(USE labl, KILL icc);
 9310 
 9311   size(4); // Assuming no NOP inserted.
 9312   ins_cost(BRANCH_COST);
 9313   format %{ &quot;CWB$cmp $op1,$op2,$labl\t! unsigned&quot; %}
 9314   ins_encode %{
 9315     Label* L = $labl$$label;
 9316     assert(__ use_cbcond(*L), &quot;back to back cbcond&quot;);
 9317     __ cbcond((Assembler::Condition)($cmp$$cmpcode), Assembler::icc, $op1$$Register, $op2$$constant, *L);
 9318   %}
 9319   ins_short_branch(1);
 9320   ins_avoid_back_to_back(AVOID_BEFORE_AND_AFTER);
 9321   ins_pipe(cbcond_reg_imm);
 9322 %}
 9323 
 9324 instruct cmpUL_reg_branch_short(cmpOpU cmp, iRegL op1, iRegL op2, label labl, flagsRegUL xcc) %{
 9325   match(If cmp (CmpUL op1 op2));
 9326   predicate(UseCBCond);
 9327   effect(USE labl, KILL xcc);
 9328 
 9329   size(4);
 9330   ins_cost(BRANCH_COST);
 9331   format %{ &quot;CXB$cmp  $op1,$op2,$labl\t! unsigned long&quot; %}
 9332   ins_encode %{
 9333     Label* L = $labl$$label;
 9334     assert(__ use_cbcond(*L), &quot;back to back cbcond&quot;);
 9335     __ cbcond((Assembler::Condition)($cmp$$cmpcode), Assembler::xcc, $op1$$Register, $op2$$Register, *L);
 9336   %}
 9337   ins_short_branch(1);
 9338   ins_avoid_back_to_back(AVOID_BEFORE_AND_AFTER);
 9339   ins_pipe(cbcond_reg_reg);
 9340 %}
 9341 
 9342 instruct cmpUL_imm_branch_short(cmpOpU cmp, iRegL op1, immL5 op2, label labl, flagsRegUL xcc) %{
 9343   match(If cmp (CmpUL op1 op2));
 9344   predicate(UseCBCond);
 9345   effect(USE labl, KILL xcc);
 9346 
 9347   size(4);
 9348   ins_cost(BRANCH_COST);
 9349   format %{ &quot;CXB$cmp  $op1,$op2,$labl\t! unsigned long&quot; %}
 9350   ins_encode %{
 9351     Label* L = $labl$$label;
 9352     assert(__ use_cbcond(*L), &quot;back to back cbcond&quot;);
 9353     __ cbcond((Assembler::Condition)($cmp$$cmpcode), Assembler::xcc, $op1$$Register, $op2$$constant, *L);
 9354   %}
 9355   ins_short_branch(1);
 9356   ins_avoid_back_to_back(AVOID_BEFORE_AND_AFTER);
 9357   ins_pipe(cbcond_reg_imm);
 9358 %}
 9359 
 9360 instruct cmpL_reg_branch_short(cmpOp cmp, iRegL op1, iRegL op2, label labl, flagsRegL xcc) %{
 9361   match(If cmp (CmpL op1 op2));
 9362   predicate(UseCBCond);
 9363   effect(USE labl, KILL xcc);
 9364 
 9365   size(4); // Assuming no NOP inserted.
 9366   ins_cost(BRANCH_COST);
 9367   format %{ &quot;CXB$cmp  $op1,$op2,$labl\t! long&quot; %}
 9368   ins_encode %{
 9369     Label* L = $labl$$label;
 9370     assert(__ use_cbcond(*L), &quot;back to back cbcond&quot;);
 9371     __ cbcond((Assembler::Condition)($cmp$$cmpcode), Assembler::xcc, $op1$$Register, $op2$$Register, *L);
 9372   %}
 9373   ins_short_branch(1);
 9374   ins_avoid_back_to_back(AVOID_BEFORE_AND_AFTER);
 9375   ins_pipe(cbcond_reg_reg);
 9376 %}
 9377 
 9378 instruct cmpL_imm_branch_short(cmpOp cmp, iRegL op1, immL5 op2, label labl, flagsRegL xcc) %{
 9379   match(If cmp (CmpL op1 op2));
 9380   predicate(UseCBCond);
 9381   effect(USE labl, KILL xcc);
 9382 
 9383   size(4); // Assuming no NOP inserted.
 9384   ins_cost(BRANCH_COST);
 9385   format %{ &quot;CXB$cmp  $op1,$op2,$labl\t! long&quot; %}
 9386   ins_encode %{
 9387     Label* L = $labl$$label;
 9388     assert(__ use_cbcond(*L), &quot;back to back cbcond&quot;);
 9389     __ cbcond((Assembler::Condition)($cmp$$cmpcode), Assembler::xcc, $op1$$Register, $op2$$constant, *L);
 9390   %}
 9391   ins_short_branch(1);
 9392   ins_avoid_back_to_back(AVOID_BEFORE_AND_AFTER);
 9393   ins_pipe(cbcond_reg_imm);
 9394 %}
 9395 
 9396 // Compare Pointers and branch
 9397 instruct cmpP_reg_branch_short(cmpOpP cmp, iRegP op1, iRegP op2, label labl, flagsRegP pcc) %{
 9398   match(If cmp (CmpP op1 op2));
 9399   predicate(UseCBCond);
 9400   effect(USE labl, KILL pcc);
 9401 
 9402   size(4); // Assuming no NOP inserted.
 9403   ins_cost(BRANCH_COST);
 9404   format %{ &quot;CXB$cmp $op1,$op2,$labl\t! ptr&quot; %}
 9405   ins_encode %{
 9406     Label* L = $labl$$label;
 9407     assert(__ use_cbcond(*L), &quot;back to back cbcond&quot;);
 9408     __ cbcond((Assembler::Condition)($cmp$$cmpcode), Assembler::ptr_cc, $op1$$Register, $op2$$Register, *L);
 9409   %}
 9410   ins_short_branch(1);
 9411   ins_avoid_back_to_back(AVOID_BEFORE_AND_AFTER);
 9412   ins_pipe(cbcond_reg_reg);
 9413 %}
 9414 
 9415 instruct cmpP_null_branch_short(cmpOpP cmp, iRegP op1, immP0 null, label labl, flagsRegP pcc) %{
 9416   match(If cmp (CmpP op1 null));
 9417   predicate(UseCBCond);
 9418   effect(USE labl, KILL pcc);
 9419 
 9420   size(4); // Assuming no NOP inserted.
 9421   ins_cost(BRANCH_COST);
 9422   format %{ &quot;CXB$cmp $op1,0,$labl\t! ptr&quot; %}
 9423   ins_encode %{
 9424     Label* L = $labl$$label;
 9425     assert(__ use_cbcond(*L), &quot;back to back cbcond&quot;);
 9426     __ cbcond((Assembler::Condition)($cmp$$cmpcode), Assembler::ptr_cc, $op1$$Register, G0, *L);
 9427   %}
 9428   ins_short_branch(1);
 9429   ins_avoid_back_to_back(AVOID_BEFORE_AND_AFTER);
 9430   ins_pipe(cbcond_reg_reg);
 9431 %}
 9432 
 9433 instruct cmpN_reg_branch_short(cmpOp cmp, iRegN op1, iRegN op2, label labl, flagsReg icc) %{
 9434   match(If cmp (CmpN op1 op2));
 9435   predicate(UseCBCond);
 9436   effect(USE labl, KILL icc);
 9437 
 9438   size(4); // Assuming no NOP inserted.
 9439   ins_cost(BRANCH_COST);
 9440   format %{ &quot;CWB$cmp  $op1,$op2,$labl\t! compressed ptr&quot; %}
 9441   ins_encode %{
 9442     Label* L = $labl$$label;
 9443     assert(__ use_cbcond(*L), &quot;back to back cbcond&quot;);
 9444     __ cbcond((Assembler::Condition)($cmp$$cmpcode), Assembler::icc, $op1$$Register, $op2$$Register, *L);
 9445   %}
 9446   ins_short_branch(1);
 9447   ins_avoid_back_to_back(AVOID_BEFORE_AND_AFTER);
 9448   ins_pipe(cbcond_reg_reg);
 9449 %}
 9450 
 9451 instruct cmpN_null_branch_short(cmpOp cmp, iRegN op1, immN0 null, label labl, flagsReg icc) %{
 9452   match(If cmp (CmpN op1 null));
 9453   predicate(UseCBCond);
 9454   effect(USE labl, KILL icc);
 9455 
 9456   size(4); // Assuming no NOP inserted.
 9457   ins_cost(BRANCH_COST);
 9458   format %{ &quot;CWB$cmp  $op1,0,$labl\t! compressed ptr&quot; %}
 9459   ins_encode %{
 9460     Label* L = $labl$$label;
 9461     assert(__ use_cbcond(*L), &quot;back to back cbcond&quot;);
 9462     __ cbcond((Assembler::Condition)($cmp$$cmpcode), Assembler::icc, $op1$$Register, G0, *L);
 9463   %}
 9464   ins_short_branch(1);
 9465   ins_avoid_back_to_back(AVOID_BEFORE_AND_AFTER);
 9466   ins_pipe(cbcond_reg_reg);
 9467 %}
 9468 
 9469 // Loop back branch
 9470 instruct cmpI_reg_branchLoopEnd_short(cmpOp cmp, iRegI op1, iRegI op2, label labl, flagsReg icc) %{
 9471   match(CountedLoopEnd cmp (CmpI op1 op2));
 9472   predicate(UseCBCond);
 9473   effect(USE labl, KILL icc);
 9474 
 9475   size(4); // Assuming no NOP inserted.
 9476   ins_cost(BRANCH_COST);
 9477   format %{ &quot;CWB$cmp  $op1,$op2,$labl\t! Loop end&quot; %}
 9478   ins_encode %{
 9479     Label* L = $labl$$label;
 9480     assert(__ use_cbcond(*L), &quot;back to back cbcond&quot;);
 9481     __ cbcond((Assembler::Condition)($cmp$$cmpcode), Assembler::icc, $op1$$Register, $op2$$Register, *L);
 9482   %}
 9483   ins_short_branch(1);
 9484   ins_avoid_back_to_back(AVOID_BEFORE_AND_AFTER);
 9485   ins_pipe(cbcond_reg_reg);
 9486 %}
 9487 
 9488 instruct cmpI_imm_branchLoopEnd_short(cmpOp cmp, iRegI op1, immI5 op2, label labl, flagsReg icc) %{
 9489   match(CountedLoopEnd cmp (CmpI op1 op2));
 9490   predicate(UseCBCond);
 9491   effect(USE labl, KILL icc);
 9492 
 9493   size(4); // Assuming no NOP inserted.
 9494   ins_cost(BRANCH_COST);
 9495   format %{ &quot;CWB$cmp  $op1,$op2,$labl\t! Loop end&quot; %}
 9496   ins_encode %{
 9497     Label* L = $labl$$label;
 9498     assert(__ use_cbcond(*L), &quot;back to back cbcond&quot;);
 9499     __ cbcond((Assembler::Condition)($cmp$$cmpcode), Assembler::icc, $op1$$Register, $op2$$constant, *L);
 9500   %}
 9501   ins_short_branch(1);
 9502   ins_avoid_back_to_back(AVOID_BEFORE_AND_AFTER);
 9503   ins_pipe(cbcond_reg_imm);
 9504 %}
 9505 
 9506 // Branch-on-register tests all 64 bits.  We assume that values
 9507 // in 64-bit registers always remains zero or sign extended
 9508 // unless our code munges the high bits.  Interrupts can chop
 9509 // the high order bits to zero or sign at any time.
 9510 instruct branchCon_regI(cmpOp_reg cmp, iRegI op1, immI0 zero, label labl) %{
 9511   match(If cmp (CmpI op1 zero));
 9512   predicate(can_branch_register(_kids[0]-&gt;_leaf, _kids[1]-&gt;_leaf));
 9513   effect(USE labl);
 9514 
 9515   size(8);
 9516   ins_cost(BRANCH_COST);
 9517   format %{ &quot;BR$cmp   $op1,$labl&quot; %}
 9518   ins_encode( enc_bpr( labl, cmp, op1 ) );
 9519   ins_avoid_back_to_back(AVOID_BEFORE);
 9520   ins_pipe(br_reg);
 9521 %}
 9522 
 9523 instruct branchCon_regP(cmpOp_reg cmp, iRegP op1, immP0 null, label labl) %{
 9524   match(If cmp (CmpP op1 null));
 9525   predicate(can_branch_register(_kids[0]-&gt;_leaf, _kids[1]-&gt;_leaf));
 9526   effect(USE labl);
 9527 
 9528   size(8);
 9529   ins_cost(BRANCH_COST);
 9530   format %{ &quot;BR$cmp   $op1,$labl&quot; %}
 9531   ins_encode( enc_bpr( labl, cmp, op1 ) );
 9532   ins_avoid_back_to_back(AVOID_BEFORE);
 9533   ins_pipe(br_reg);
 9534 %}
 9535 
 9536 instruct branchCon_regL(cmpOp_reg cmp, iRegL op1, immL0 zero, label labl) %{
 9537   match(If cmp (CmpL op1 zero));
 9538   predicate(can_branch_register(_kids[0]-&gt;_leaf, _kids[1]-&gt;_leaf));
 9539   effect(USE labl);
 9540 
 9541   size(8);
 9542   ins_cost(BRANCH_COST);
 9543   format %{ &quot;BR$cmp   $op1,$labl&quot; %}
 9544   ins_encode( enc_bpr( labl, cmp, op1 ) );
 9545   ins_avoid_back_to_back(AVOID_BEFORE);
 9546   ins_pipe(br_reg);
 9547 %}
 9548 
 9549 
 9550 // ============================================================================
 9551 // Long Compare
 9552 //
 9553 // Currently we hold longs in 2 registers.  Comparing such values efficiently
 9554 // is tricky.  The flavor of compare used depends on whether we are testing
 9555 // for LT, LE, or EQ.  For a simple LT test we can check just the sign bit.
 9556 // The GE test is the negated LT test.  The LE test can be had by commuting
 9557 // the operands (yielding a GE test) and then negating; negate again for the
 9558 // GT test.  The EQ test is done by ORcc&#39;ing the high and low halves, and the
 9559 // NE test is negated from that.
 9560 
 9561 // Due to a shortcoming in the ADLC, it mixes up expressions like:
 9562 // (foo (CmpI (CmpL X Y) 0)) and (bar (CmpI (CmpL X 0L) 0)).  Note the
 9563 // difference between &#39;Y&#39; and &#39;0L&#39;.  The tree-matches for the CmpI sections
 9564 // are collapsed internally in the ADLC&#39;s dfa-gen code.  The match for
 9565 // (CmpI (CmpL X Y) 0) is silently replaced with (CmpI (CmpL X 0L) 0) and the
 9566 // foo match ends up with the wrong leaf.  One fix is to not match both
 9567 // reg-reg and reg-zero forms of long-compare.  This is unfortunate because
 9568 // both forms beat the trinary form of long-compare and both are very useful
 9569 // on Intel which has so few registers.
 9570 
 9571 instruct branchCon_long(cmpOp cmp, flagsRegL xcc, label labl) %{
 9572   match(If cmp xcc);
 9573   effect(USE labl);
 9574 
 9575   size(8);
 9576   ins_cost(BRANCH_COST);
 9577   format %{ &quot;BP$cmp   $xcc,$labl&quot; %}
 9578   ins_encode %{
 9579     Label* L = $labl$$label;
 9580     Assembler::Predict predict_taken =
 9581       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9582 
 9583     __ bp( (Assembler::Condition)($cmp$$cmpcode), false, Assembler::xcc, predict_taken, *L);
 9584     __ delayed()-&gt;nop();
 9585   %}
 9586   ins_avoid_back_to_back(AVOID_BEFORE);
 9587   ins_pipe(br_cc);
 9588 %}
 9589 
 9590 instruct branchConU_long(cmpOpU cmp, flagsRegUL xcc, label labl) %{
 9591   match(If cmp xcc);
 9592   effect(USE labl);
 9593 
 9594   size(8);
 9595   ins_cost(BRANCH_COST);
 9596   format %{ &quot;BP$cmp   $xcc,$labl&quot; %}
 9597   ins_encode %{
 9598     Label* L = $labl$$label;
 9599     Assembler::Predict predict_taken =
 9600       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9601 
 9602     __ bp((Assembler::Condition)($cmp$$cmpcode), false, Assembler::xcc, predict_taken, *L);
 9603     __ delayed()-&gt;nop();
 9604   %}
 9605   ins_avoid_back_to_back(AVOID_BEFORE);
 9606   ins_pipe(br_cc);
 9607 %}
 9608 
 9609 // Manifest a CmpL3 result in an integer register.  Very painful.
 9610 // This is the test to avoid.
 9611 instruct cmpL3_reg_reg(iRegI dst, iRegL src1, iRegL src2, flagsReg ccr ) %{
 9612   match(Set dst (CmpL3 src1 src2) );
 9613   effect( KILL ccr );
 9614   ins_cost(6*DEFAULT_COST);
 9615   size(24);
 9616   format %{ &quot;CMP    $src1,$src2\t\t! long\n&quot;
 9617           &quot;\tBLT,a,pn done\n&quot;
 9618           &quot;\tMOV    -1,$dst\t! delay slot\n&quot;
 9619           &quot;\tBGT,a,pn done\n&quot;
 9620           &quot;\tMOV    1,$dst\t! delay slot\n&quot;
 9621           &quot;\tCLR    $dst\n&quot;
 9622     &quot;done:&quot;     %}
 9623   ins_encode( cmpl_flag(src1,src2,dst) );
 9624   ins_pipe(cmpL_reg);
 9625 %}
 9626 
 9627 // Conditional move
 9628 instruct cmovLL_reg(cmpOp cmp, flagsRegL xcc, iRegL dst, iRegL src) %{
 9629   match(Set dst (CMoveL (Binary cmp xcc) (Binary dst src)));
 9630   ins_cost(150);
 9631   format %{ &quot;MOV$cmp  $xcc,$src,$dst\t! long&quot; %}
 9632   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::xcc)) );
 9633   ins_pipe(ialu_reg);
 9634 %}
 9635 
 9636 instruct cmovLL_imm(cmpOp cmp, flagsRegL xcc, iRegL dst, immL0 src) %{
 9637   match(Set dst (CMoveL (Binary cmp xcc) (Binary dst src)));
 9638   ins_cost(140);
 9639   format %{ &quot;MOV$cmp  $xcc,$src,$dst\t! long&quot; %}
 9640   ins_encode( enc_cmov_imm(cmp,dst,src, (Assembler::xcc)) );
 9641   ins_pipe(ialu_imm);
 9642 %}
 9643 
 9644 instruct cmovIL_reg(cmpOp cmp, flagsRegL xcc, iRegI dst, iRegI src) %{
 9645   match(Set dst (CMoveI (Binary cmp xcc) (Binary dst src)));
 9646   ins_cost(150);
 9647   format %{ &quot;MOV$cmp  $xcc,$src,$dst&quot; %}
 9648   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::xcc)) );
 9649   ins_pipe(ialu_reg);
 9650 %}
 9651 
 9652 instruct cmovIL_imm(cmpOp cmp, flagsRegL xcc, iRegI dst, immI11 src) %{
 9653   match(Set dst (CMoveI (Binary cmp xcc) (Binary dst src)));
 9654   ins_cost(140);
 9655   format %{ &quot;MOV$cmp  $xcc,$src,$dst&quot; %}
 9656   ins_encode( enc_cmov_imm(cmp,dst,src, (Assembler::xcc)) );
 9657   ins_pipe(ialu_imm);
 9658 %}
 9659 
 9660 instruct cmovNL_reg(cmpOp cmp, flagsRegL xcc, iRegN dst, iRegN src) %{
 9661   match(Set dst (CMoveN (Binary cmp xcc) (Binary dst src)));
 9662   ins_cost(150);
 9663   format %{ &quot;MOV$cmp  $xcc,$src,$dst&quot; %}
 9664   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::xcc)) );
 9665   ins_pipe(ialu_reg);
 9666 %}
 9667 
 9668 instruct cmovPL_reg(cmpOp cmp, flagsRegL xcc, iRegP dst, iRegP src) %{
 9669   match(Set dst (CMoveP (Binary cmp xcc) (Binary dst src)));
 9670   ins_cost(150);
 9671   format %{ &quot;MOV$cmp  $xcc,$src,$dst&quot; %}
 9672   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::xcc)) );
 9673   ins_pipe(ialu_reg);
 9674 %}
 9675 
 9676 instruct cmovPL_imm(cmpOp cmp, flagsRegL xcc, iRegP dst, immP0 src) %{
 9677   match(Set dst (CMoveP (Binary cmp xcc) (Binary dst src)));
 9678   ins_cost(140);
 9679   format %{ &quot;MOV$cmp  $xcc,$src,$dst&quot; %}
 9680   ins_encode( enc_cmov_imm(cmp,dst,src, (Assembler::xcc)) );
 9681   ins_pipe(ialu_imm);
 9682 %}
 9683 
 9684 instruct cmovFL_reg(cmpOp cmp, flagsRegL xcc, regF dst, regF src) %{
 9685   match(Set dst (CMoveF (Binary cmp xcc) (Binary dst src)));
 9686   ins_cost(150);
 9687   opcode(0x101);
 9688   format %{ &quot;FMOVS$cmp $xcc,$src,$dst&quot; %}
 9689   ins_encode( enc_cmovf_reg(cmp,dst,src, (Assembler::xcc)) );
 9690   ins_pipe(int_conditional_float_move);
 9691 %}
 9692 
 9693 instruct cmovDL_reg(cmpOp cmp, flagsRegL xcc, regD dst, regD src) %{
 9694   match(Set dst (CMoveD (Binary cmp xcc) (Binary dst src)));
 9695   ins_cost(150);
 9696   opcode(0x102);
 9697   format %{ &quot;FMOVD$cmp $xcc,$src,$dst&quot; %}
 9698   ins_encode( enc_cmovf_reg(cmp,dst,src, (Assembler::xcc)) );
 9699   ins_pipe(int_conditional_float_move);
 9700 %}
 9701 
 9702 // ============================================================================
 9703 // Safepoint Instruction
 9704 instruct safePoint_poll(iRegP poll) %{
 9705   match(SafePoint poll);
 9706   effect(USE poll);
 9707 
 9708   size(4);
 9709   format %{ &quot;LDX    [$poll],R_G0\t! Safepoint: poll for GC&quot; %}
 9710   ins_encode %{
 9711     __ relocate(relocInfo::poll_type);
 9712     __ ld_ptr($poll$$Register, 0, G0);
 9713   %}
 9714   ins_pipe(loadPollP);
 9715 %}
 9716 
 9717 // ============================================================================
 9718 // Call Instructions
 9719 // Call Java Static Instruction
 9720 instruct CallStaticJavaDirect( method meth ) %{
 9721   match(CallStaticJava);
 9722   predicate(! ((CallStaticJavaNode*)n)-&gt;is_method_handle_invoke());
 9723   effect(USE meth);
 9724 
 9725   size(8);
 9726   ins_cost(CALL_COST);
 9727   format %{ &quot;CALL,static  ; NOP ==&gt; &quot; %}
 9728   ins_encode( Java_Static_Call( meth ), call_epilog );
 9729   ins_avoid_back_to_back(AVOID_BEFORE);
 9730   ins_pipe(simple_call);
 9731 %}
 9732 
 9733 // Call Java Static Instruction (method handle version)
 9734 instruct CallStaticJavaHandle(method meth, l7RegP l7_mh_SP_save) %{
 9735   match(CallStaticJava);
 9736   predicate(((CallStaticJavaNode*)n)-&gt;is_method_handle_invoke());
 9737   effect(USE meth, KILL l7_mh_SP_save);
 9738 
 9739   size(16);
 9740   ins_cost(CALL_COST);
 9741   format %{ &quot;CALL,static/MethodHandle&quot; %}
 9742   ins_encode(preserve_SP, Java_Static_Call(meth), restore_SP, call_epilog);
 9743   ins_pipe(simple_call);
 9744 %}
 9745 
 9746 // Call Java Dynamic Instruction
 9747 instruct CallDynamicJavaDirect( method meth ) %{
 9748   match(CallDynamicJava);
 9749   effect(USE meth);
 9750 
 9751   ins_cost(CALL_COST);
 9752   format %{ &quot;SET    (empty),R_G5\n\t&quot;
 9753             &quot;CALL,dynamic  ; NOP ==&gt; &quot; %}
 9754   ins_encode( Java_Dynamic_Call( meth ), call_epilog );
 9755   ins_pipe(call);
 9756 %}
 9757 
 9758 // Call Runtime Instruction
 9759 instruct CallRuntimeDirect(method meth, l7RegP l7) %{
 9760   match(CallRuntime);
 9761   effect(USE meth, KILL l7);
 9762   ins_cost(CALL_COST);
 9763   format %{ &quot;CALL,runtime&quot; %}
 9764   ins_encode( Java_To_Runtime( meth ),
 9765               call_epilog, adjust_long_from_native_call );
 9766   ins_avoid_back_to_back(AVOID_BEFORE);
 9767   ins_pipe(simple_call);
 9768 %}
 9769 
 9770 // Call runtime without safepoint - same as CallRuntime
 9771 instruct CallLeafDirect(method meth, l7RegP l7) %{
 9772   match(CallLeaf);
 9773   effect(USE meth, KILL l7);
 9774   ins_cost(CALL_COST);
 9775   format %{ &quot;CALL,runtime leaf&quot; %}
 9776   ins_encode( Java_To_Runtime( meth ),
 9777               call_epilog,
 9778               adjust_long_from_native_call );
 9779   ins_avoid_back_to_back(AVOID_BEFORE);
 9780   ins_pipe(simple_call);
 9781 %}
 9782 
 9783 // Call runtime without safepoint - same as CallLeaf
 9784 instruct CallLeafNoFPDirect(method meth, l7RegP l7) %{
 9785   match(CallLeafNoFP);
 9786   effect(USE meth, KILL l7);
 9787   ins_cost(CALL_COST);
 9788   format %{ &quot;CALL,runtime leaf nofp&quot; %}
 9789   ins_encode( Java_To_Runtime( meth ),
 9790               call_epilog,
 9791               adjust_long_from_native_call );
 9792   ins_avoid_back_to_back(AVOID_BEFORE);
 9793   ins_pipe(simple_call);
 9794 %}
 9795 
 9796 // Tail Call; Jump from runtime stub to Java code.
 9797 // Also known as an &#39;interprocedural jump&#39;.
 9798 // Target of jump will eventually return to caller.
 9799 // TailJump below removes the return address.
 9800 instruct TailCalljmpInd(g3RegP jump_target, inline_cache_regP method_oop) %{
 9801   match(TailCall jump_target method_oop );
 9802 
 9803   ins_cost(CALL_COST);
 9804   format %{ &quot;Jmp     $jump_target  ; NOP \t! $method_oop holds method oop&quot; %}
 9805   ins_encode(form_jmpl(jump_target));
 9806   ins_avoid_back_to_back(AVOID_BEFORE);
 9807   ins_pipe(tail_call);
 9808 %}
 9809 
 9810 
 9811 // Return Instruction
 9812 instruct Ret() %{
 9813   match(Return);
 9814 
 9815   // The epilogue node did the ret already.
 9816   size(0);
 9817   format %{ &quot;! return&quot; %}
 9818   ins_encode();
 9819   ins_pipe(empty);
 9820 %}
 9821 
 9822 
 9823 // Tail Jump; remove the return address; jump to target.
 9824 // TailCall above leaves the return address around.
 9825 // TailJump is used in only one place, the rethrow_Java stub (fancy_jump=2).
 9826 // ex_oop (Exception Oop) is needed in %o0 at the jump. As there would be a
 9827 // &quot;restore&quot; before this instruction (in Epilogue), we need to materialize it
 9828 // in %i0.
 9829 instruct tailjmpInd(g1RegP jump_target, i0RegP ex_oop) %{
 9830   match( TailJump jump_target ex_oop );
 9831   ins_cost(CALL_COST);
 9832   format %{ &quot;! discard R_O7\n\t&quot;
 9833             &quot;Jmp     $jump_target  ; ADD O7,8,O1 \t! $ex_oop holds exc. oop&quot; %}
 9834   ins_encode(form_jmpl_set_exception_pc(jump_target));
 9835   // opcode(Assembler::jmpl_op3, Assembler::arith_op);
 9836   // The hack duplicates the exception oop into G3, so that CreateEx can use it there.
 9837   // ins_encode( form3_rs1_simm13_rd( jump_target, 0x00, R_G0 ), move_return_pc_to_o1() );
 9838   ins_avoid_back_to_back(AVOID_BEFORE);
 9839   ins_pipe(tail_call);
 9840 %}
 9841 
 9842 // Create exception oop: created by stack-crawling runtime code.
 9843 // Created exception is now available to this handler, and is setup
 9844 // just prior to jumping to this handler.  No code emitted.
 9845 instruct CreateException( o0RegP ex_oop )
 9846 %{
 9847   match(Set ex_oop (CreateEx));
 9848   ins_cost(0);
 9849 
 9850   size(0);
 9851   // use the following format syntax
 9852   format %{ &quot;! exception oop is in R_O0; no code emitted&quot; %}
 9853   ins_encode();
 9854   ins_pipe(empty);
 9855 %}
 9856 
 9857 
 9858 // Rethrow exception:
 9859 // The exception oop will come in the first argument position.
 9860 // Then JUMP (not call) to the rethrow stub code.
 9861 instruct RethrowException()
 9862 %{
 9863   match(Rethrow);
 9864   ins_cost(CALL_COST);
 9865 
 9866   // use the following format syntax
 9867   format %{ &quot;Jmp    rethrow_stub&quot; %}
 9868   ins_encode(enc_rethrow);
 9869   ins_avoid_back_to_back(AVOID_BEFORE);
 9870   ins_pipe(tail_call);
 9871 %}
 9872 
 9873 
 9874 // Die now
 9875 instruct ShouldNotReachHere( )
 9876 %{
 9877   match(Halt);
 9878   ins_cost(CALL_COST);
 9879 
 9880   size(4);
 9881   // Use the following format syntax
 9882   format %{ &quot;ILLTRAP   ; ShouldNotReachHere&quot; %}
 9883   ins_encode( form2_illtrap() );
 9884   ins_pipe(tail_call);
 9885 %}
 9886 
 9887 // ============================================================================
 9888 // The 2nd slow-half of a subtype check.  Scan the subklass&#39;s 2ndary superklass
 9889 // array for an instance of the superklass.  Set a hidden internal cache on a
 9890 // hit (cache is checked with exposed code in gen_subtype_check()).  Return
 9891 // not zero for a miss or zero for a hit.  The encoding ALSO sets flags.
 9892 instruct partialSubtypeCheck( o0RegP index, o1RegP sub, o2RegP super, flagsRegP pcc, o7RegP o7 ) %{
 9893   match(Set index (PartialSubtypeCheck sub super));
 9894   effect( KILL pcc, KILL o7 );
 9895   ins_cost(DEFAULT_COST*10);
 9896   format %{ &quot;CALL   PartialSubtypeCheck\n\tNOP&quot; %}
 9897   ins_encode( enc_PartialSubtypeCheck() );
 9898   ins_avoid_back_to_back(AVOID_BEFORE);
 9899   ins_pipe(partial_subtype_check_pipe);
 9900 %}
 9901 
 9902 instruct partialSubtypeCheck_vs_zero( flagsRegP pcc, o1RegP sub, o2RegP super, immP0 zero, o0RegP idx, o7RegP o7 ) %{
 9903   match(Set pcc (CmpP (PartialSubtypeCheck sub super) zero));
 9904   effect( KILL idx, KILL o7 );
 9905   ins_cost(DEFAULT_COST*10);
 9906   format %{ &quot;CALL   PartialSubtypeCheck\n\tNOP\t# (sets condition codes)&quot; %}
 9907   ins_encode( enc_PartialSubtypeCheck() );
 9908   ins_avoid_back_to_back(AVOID_BEFORE);
 9909   ins_pipe(partial_subtype_check_pipe);
 9910 %}
 9911 
 9912 
 9913 // ============================================================================
 9914 // inlined locking and unlocking
 9915 
 9916 instruct cmpFastLock(flagsRegP pcc, iRegP object, o1RegP box, iRegP scratch2, o7RegP scratch ) %{
 9917   match(Set pcc (FastLock object box));
 9918 
 9919   effect(TEMP scratch2, USE_KILL box, KILL scratch);
 9920   ins_cost(100);
 9921 
 9922   format %{ &quot;FASTLOCK  $object,$box\t! kills $box,$scratch,$scratch2&quot; %}
 9923   ins_encode( Fast_Lock(object, box, scratch, scratch2) );
 9924   ins_pipe(long_memory_op);
 9925 %}
 9926 
 9927 
 9928 instruct cmpFastUnlock(flagsRegP pcc, iRegP object, o1RegP box, iRegP scratch2, o7RegP scratch ) %{
 9929   match(Set pcc (FastUnlock object box));
 9930   effect(TEMP scratch2, USE_KILL box, KILL scratch);
 9931   ins_cost(100);
 9932 
 9933   format %{ &quot;FASTUNLOCK  $object,$box\t! kills $box,$scratch,$scratch2&quot; %}
 9934   ins_encode( Fast_Unlock(object, box, scratch, scratch2) );
 9935   ins_pipe(long_memory_op);
 9936 %}
 9937 
 9938 // The encodings are generic.
 9939 instruct clear_array(iRegX cnt, iRegP base, iRegX temp, Universe dummy, flagsReg ccr) %{
 9940   predicate(!use_block_zeroing(n-&gt;in(2)) );
 9941   match(Set dummy (ClearArray cnt base));
 9942   effect(TEMP temp, KILL ccr);
 9943   ins_cost(300);
 9944   format %{ &quot;MOV    $cnt,$temp\n&quot;
 9945     &quot;loop:   SUBcc  $temp,8,$temp\t! Count down a dword of bytes\n&quot;
 9946     &quot;        BRge   loop\t\t! Clearing loop\n&quot;
 9947     &quot;        STX    G0,[$base+$temp]\t! delay slot&quot; %}
 9948 
 9949   ins_encode %{
 9950     // Compiler ensures base is doubleword aligned and cnt is count of doublewords
 9951     Register nof_bytes_arg    = $cnt$$Register;
 9952     Register nof_bytes_tmp    = $temp$$Register;
 9953     Register base_pointer_arg = $base$$Register;
 9954 
 9955     Label loop;
 9956     __ mov(nof_bytes_arg, nof_bytes_tmp);
 9957 
 9958     // Loop and clear, walking backwards through the array.
 9959     // nof_bytes_tmp (if &gt;0) is always the number of bytes to zero
 9960     __ bind(loop);
 9961     __ deccc(nof_bytes_tmp, 8);
 9962     __ br(Assembler::greaterEqual, true, Assembler::pt, loop);
 9963     __ delayed()-&gt; stx(G0, base_pointer_arg, nof_bytes_tmp);
 9964     // %%%% this mini-loop must not cross a cache boundary!
 9965   %}
 9966   ins_pipe(long_memory_op);
 9967 %}
 9968 
 9969 instruct clear_array_bis(g1RegX cnt, o0RegP base, Universe dummy, flagsReg ccr) %{
 9970   predicate(use_block_zeroing(n-&gt;in(2)));
 9971   match(Set dummy (ClearArray cnt base));
 9972   effect(USE_KILL cnt, USE_KILL base, KILL ccr);
 9973   ins_cost(300);
 9974   format %{ &quot;CLEAR  [$base, $cnt]\t! ClearArray&quot; %}
 9975 
 9976   ins_encode %{
 9977 
 9978     assert(MinObjAlignmentInBytes &gt;= BytesPerLong, &quot;need alternate implementation&quot;);
 9979     Register to    = $base$$Register;
 9980     Register count = $cnt$$Register;
 9981 
 9982     Label Ldone;
 9983     __ nop(); // Separate short branches
 9984     // Use BIS for zeroing (temp is not used).
 9985     __ bis_zeroing(to, count, G0, Ldone);
 9986     __ bind(Ldone);
 9987 
 9988   %}
 9989   ins_pipe(long_memory_op);
 9990 %}
 9991 
 9992 instruct clear_array_bis_2(g1RegX cnt, o0RegP base, iRegX tmp, Universe dummy, flagsReg ccr) %{
 9993   predicate(use_block_zeroing(n-&gt;in(2)) &amp;&amp; !Assembler::is_simm13((int)BlockZeroingLowLimit));
 9994   match(Set dummy (ClearArray cnt base));
 9995   effect(TEMP tmp, USE_KILL cnt, USE_KILL base, KILL ccr);
 9996   ins_cost(300);
 9997   format %{ &quot;CLEAR  [$base, $cnt]\t! ClearArray&quot; %}
 9998 
 9999   ins_encode %{
10000 
10001     assert(MinObjAlignmentInBytes &gt;= BytesPerLong, &quot;need alternate implementation&quot;);
10002     Register to    = $base$$Register;
10003     Register count = $cnt$$Register;
10004     Register temp  = $tmp$$Register;
10005 
10006     Label Ldone;
10007     __ nop(); // Separate short branches
10008     // Use BIS for zeroing
10009     __ bis_zeroing(to, count, temp, Ldone);
10010     __ bind(Ldone);
10011 
10012   %}
10013   ins_pipe(long_memory_op);
10014 %}
10015 
10016 instruct string_compareL(o0RegP str1, o1RegP str2, g3RegI cnt1, g4RegI cnt2, notemp_iRegI result,
10017                          o7RegI tmp, flagsReg ccr) %{
10018   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
10019   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
10020   effect(USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL ccr, KILL tmp);
10021   ins_cost(300);
10022   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp&quot; %}
10023   ins_encode %{
10024     __ string_compare($str1$$Register, $str2$$Register,
10025                       $cnt1$$Register, $cnt2$$Register,
10026                       $tmp$$Register, $tmp$$Register,
10027                       $result$$Register, StrIntrinsicNode::LL);
10028   %}
10029   ins_pipe(long_memory_op);
10030 %}
10031 
10032 instruct string_compareU(o0RegP str1, o1RegP str2, g3RegI cnt1, g4RegI cnt2, notemp_iRegI result,
10033                          o7RegI tmp, flagsReg ccr) %{
10034   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
10035   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
10036   effect(USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL ccr, KILL tmp);
10037   ins_cost(300);
10038   format %{ &quot;String Compare char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp&quot; %}
10039   ins_encode %{
10040     __ string_compare($str1$$Register, $str2$$Register,
10041                       $cnt1$$Register, $cnt2$$Register,
10042                       $tmp$$Register, $tmp$$Register,
10043                       $result$$Register, StrIntrinsicNode::UU);
10044   %}
10045   ins_pipe(long_memory_op);
10046 %}
10047 
10048 instruct string_compareLU(o0RegP str1, o1RegP str2, g3RegI cnt1, g4RegI cnt2, notemp_iRegI result,
10049                           o7RegI tmp1, g1RegI tmp2, flagsReg ccr) %{
10050   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LU);
10051   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
10052   effect(USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL ccr, KILL tmp1, KILL tmp2);
10053   ins_cost(300);
10054   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1,$tmp2&quot; %}
10055   ins_encode %{
10056     __ string_compare($str1$$Register, $str2$$Register,
10057                       $cnt1$$Register, $cnt2$$Register,
10058                       $tmp1$$Register, $tmp2$$Register,
10059                       $result$$Register, StrIntrinsicNode::LU);
10060   %}
10061   ins_pipe(long_memory_op);
10062 %}
10063 
10064 instruct string_compareUL(o0RegP str1, o1RegP str2, g3RegI cnt1, g4RegI cnt2, notemp_iRegI result,
10065                           o7RegI tmp1, g1RegI tmp2, flagsReg ccr) %{
10066   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
10067   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
10068   effect(USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL ccr, KILL tmp1, KILL tmp2);
10069   ins_cost(300);
10070   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1,$tmp2&quot; %}
10071   ins_encode %{
10072     __ string_compare($str2$$Register, $str1$$Register,
10073                       $cnt2$$Register, $cnt1$$Register,
10074                       $tmp1$$Register, $tmp2$$Register,
10075                       $result$$Register, StrIntrinsicNode::UL);
10076   %}
10077   ins_pipe(long_memory_op);
10078 %}
10079 
10080 instruct string_equalsL(o0RegP str1, o1RegP str2, g3RegI cnt, notemp_iRegI result,
10081                         o7RegI tmp, flagsReg ccr) %{
10082   predicate(((StrEqualsNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
10083   match(Set result (StrEquals (Binary str1 str2) cnt));
10084   effect(USE_KILL str1, USE_KILL str2, USE_KILL cnt, KILL tmp, KILL ccr);
10085   ins_cost(300);
10086   format %{ &quot;String Equals byte[] $str1,$str2,$cnt -&gt; $result   // KILL $tmp&quot; %}
10087   ins_encode %{
10088     __ array_equals(false, $str1$$Register, $str2$$Register,
10089                     $cnt$$Register, $tmp$$Register,
10090                     $result$$Register, true /* byte */);
10091   %}
10092   ins_pipe(long_memory_op);
10093 %}
10094 
10095 instruct string_equalsU(o0RegP str1, o1RegP str2, g3RegI cnt, notemp_iRegI result,
10096                         o7RegI tmp, flagsReg ccr) %{
10097   predicate(((StrEqualsNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
10098   match(Set result (StrEquals (Binary str1 str2) cnt));
10099   effect(USE_KILL str1, USE_KILL str2, USE_KILL cnt, KILL tmp, KILL ccr);
10100   ins_cost(300);
10101   format %{ &quot;String Equals char[]  $str1,$str2,$cnt -&gt; $result   // KILL $tmp&quot; %}
10102   ins_encode %{
10103     __ array_equals(false, $str1$$Register, $str2$$Register,
10104                     $cnt$$Register, $tmp$$Register,
10105                     $result$$Register, false /* byte */);
10106   %}
10107   ins_pipe(long_memory_op);
10108 %}
10109 
10110 instruct array_equalsB(o0RegP ary1, o1RegP ary2, g3RegI tmp1, notemp_iRegI result,
10111                        o7RegI tmp2, flagsReg ccr) %{
10112   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
10113   match(Set result (AryEq ary1 ary2));
10114   effect(USE_KILL ary1, USE_KILL ary2, KILL tmp1, KILL tmp2, KILL ccr);
10115   ins_cost(300);
10116   format %{ &quot;Array Equals $ary1,$ary2 -&gt; $result   // KILL $tmp1,$tmp2&quot; %}
10117   ins_encode %{
10118     __ array_equals(true, $ary1$$Register, $ary2$$Register,
10119                     $tmp1$$Register, $tmp2$$Register,
10120                     $result$$Register, true /* byte */);
10121   %}
10122   ins_pipe(long_memory_op);
10123 %}
10124 
10125 instruct array_equalsC(o0RegP ary1, o1RegP ary2, g3RegI tmp1, notemp_iRegI result,
10126                        o7RegI tmp2, flagsReg ccr) %{
10127   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
10128   match(Set result (AryEq ary1 ary2));
10129   effect(USE_KILL ary1, USE_KILL ary2, KILL tmp1, KILL tmp2, KILL ccr);
10130   ins_cost(300);
10131   format %{ &quot;Array Equals $ary1,$ary2 -&gt; $result   // KILL $tmp1,$tmp2&quot; %}
10132   ins_encode %{
10133     __ array_equals(true, $ary1$$Register, $ary2$$Register,
10134                     $tmp1$$Register, $tmp2$$Register,
10135                     $result$$Register, false /* byte */);
10136   %}
10137   ins_pipe(long_memory_op);
10138 %}
10139 
10140 instruct has_negatives(o0RegP pAryR, g3RegI iSizeR, notemp_iRegI resultR,
10141                        iRegL tmp1L, iRegL tmp2L, iRegL tmp3L, iRegL tmp4L,
10142                        flagsReg ccr)
10143 %{
10144   match(Set resultR (HasNegatives pAryR iSizeR));
10145   effect(TEMP resultR, TEMP tmp1L, TEMP tmp2L, TEMP tmp3L, TEMP tmp4L, USE pAryR, USE iSizeR, KILL ccr);
10146   format %{ &quot;has negatives byte[] $pAryR,$iSizeR -&gt; $resultR // KILL $tmp1L,$tmp2L,$tmp3L,$tmp4L&quot; %}
10147   ins_encode %{
10148     __ has_negatives($pAryR$$Register, $iSizeR$$Register,
10149                      $resultR$$Register,
10150                      $tmp1L$$Register, $tmp2L$$Register,
10151                      $tmp3L$$Register, $tmp4L$$Register);
10152   %}
10153   ins_pipe(long_memory_op);
10154 %}
10155 
10156 // char[] to byte[] compression
10157 instruct string_compress(o0RegP src, o1RegP dst, g3RegI len, notemp_iRegI result, iRegL tmp, flagsReg ccr) %{
10158   predicate(UseVIS &lt; 3);
10159   match(Set result (StrCompressedCopy src (Binary dst len)));
10160   effect(TEMP result, TEMP tmp, USE_KILL src, USE_KILL dst, USE_KILL len, KILL ccr);
10161   ins_cost(300);
10162   format %{ &quot;String Compress $src,$dst,$len -&gt; $result    // KILL $tmp&quot; %}
10163   ins_encode %{
10164     Label Ldone;
10165     __ signx($len$$Register);
10166     __ cmp_zero_and_br(Assembler::zero, $len$$Register, Ldone, false, Assembler::pn);
10167     __ delayed()-&gt;mov($len$$Register, $result$$Register); // copy count
10168     __ string_compress($src$$Register, $dst$$Register, $len$$Register, $result$$Register, $tmp$$Register, Ldone);
10169     __ bind(Ldone);
10170   %}
10171   ins_pipe(long_memory_op);
10172 %}
10173 
10174 // fast char[] to byte[] compression using VIS instructions
10175 instruct string_compress_fast(o0RegP src, o1RegP dst, g3RegI len, notemp_iRegI result,
10176                               iRegL tmp1, iRegL tmp2, iRegL tmp3, iRegL tmp4,
10177                               regD ftmp1, regD ftmp2, regD ftmp3, flagsReg ccr) %{
10178   predicate(UseVIS &gt;= 3);
10179   match(Set result (StrCompressedCopy src (Binary dst len)));
10180   effect(TEMP result, TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP ftmp1, TEMP ftmp2, TEMP ftmp3, USE_KILL src, USE_KILL dst, USE_KILL len, KILL ccr);
10181   ins_cost(300);
10182   format %{ &quot;String Compress Fast $src,$dst,$len -&gt; $result    // KILL $tmp1,$tmp2,$tmp3,$tmp4,$ftmp1,$ftmp2,$ftmp3&quot; %}
10183   ins_encode %{
10184     Label Ldone;
10185     __ signx($len$$Register);
10186     __ string_compress_16($src$$Register, $dst$$Register, $len$$Register, $result$$Register,
10187                           $tmp1$$Register, $tmp2$$Register, $tmp3$$Register, $tmp4$$Register,
10188                           $ftmp1$$FloatRegister, $ftmp2$$FloatRegister, $ftmp3$$FloatRegister, Ldone);
10189     __ cmp_and_brx_short($len$$Register, 0, Assembler::equal, Assembler::pn, Ldone);
10190     __ string_compress($src$$Register, $dst$$Register, $len$$Register, $result$$Register, $tmp1$$Register, Ldone);
10191     __ bind(Ldone);
10192   %}
10193   ins_pipe(long_memory_op);
10194 %}
10195 
10196 // byte[] to char[] inflation
10197 instruct string_inflate(Universe dummy, o0RegP src, o1RegP dst, g3RegI len,
10198                         iRegL tmp, flagsReg ccr) %{
10199   match(Set dummy (StrInflatedCopy src (Binary dst len)));
10200   effect(TEMP tmp, USE_KILL src, USE_KILL dst, USE_KILL len, KILL ccr);
10201   ins_cost(300);
10202   format %{ &quot;String Inflate $src,$dst,$len    // KILL $tmp&quot; %}
10203   ins_encode %{
10204     Label Ldone;
10205     __ signx($len$$Register);
10206     __ cmp_and_brx_short($len$$Register, 0, Assembler::equal, Assembler::pn, Ldone);
10207     __ string_inflate($src$$Register, $dst$$Register, $len$$Register, $tmp$$Register, Ldone);
10208     __ bind(Ldone);
10209   %}
10210   ins_pipe(long_memory_op);
10211 %}
10212 
10213 // fast byte[] to char[] inflation using VIS instructions
10214 instruct string_inflate_fast(Universe dummy, o0RegP src, o1RegP dst, g3RegI len,
10215                              iRegL tmp, regD ftmp1, regD ftmp2, regD ftmp3, regD ftmp4, flagsReg ccr) %{
10216   predicate(UseVIS &gt;= 3);
10217   match(Set dummy (StrInflatedCopy src (Binary dst len)));
10218   effect(TEMP tmp, TEMP ftmp1, TEMP ftmp2, TEMP ftmp3, TEMP ftmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL ccr);
10219   ins_cost(300);
10220   format %{ &quot;String Inflate Fast $src,$dst,$len    // KILL $tmp,$ftmp1,$ftmp2,$ftmp3,$ftmp4&quot; %}
10221   ins_encode %{
10222     Label Ldone;
10223     __ signx($len$$Register);
10224     __ string_inflate_16($src$$Register, $dst$$Register, $len$$Register, $tmp$$Register,
10225                          $ftmp1$$FloatRegister, $ftmp2$$FloatRegister, $ftmp3$$FloatRegister, $ftmp4$$FloatRegister, Ldone);
10226     __ cmp_and_brx_short($len$$Register, 0, Assembler::equal, Assembler::pn, Ldone);
10227     __ string_inflate($src$$Register, $dst$$Register, $len$$Register, $tmp$$Register, Ldone);
10228     __ bind(Ldone);
10229   %}
10230   ins_pipe(long_memory_op);
10231 %}
10232 
10233 
10234 //---------- Zeros Count Instructions ------------------------------------------
10235 
10236 instruct countLeadingZerosI(iRegIsafe dst, iRegI src, iRegI tmp, flagsReg cr) %{
10237   predicate(UsePopCountInstruction);  // See Matcher::match_rule_supported
10238   match(Set dst (CountLeadingZerosI src));
10239   effect(TEMP dst, TEMP tmp, KILL cr);
10240 
10241   // x |= (x &gt;&gt; 1);
10242   // x |= (x &gt;&gt; 2);
10243   // x |= (x &gt;&gt; 4);
10244   // x |= (x &gt;&gt; 8);
10245   // x |= (x &gt;&gt; 16);
10246   // return (WORDBITS - popc(x));
10247   format %{ &quot;SRL     $src,1,$tmp\t! count leading zeros (int)\n\t&quot;
10248             &quot;SRL     $src,0,$dst\t! 32-bit zero extend\n\t&quot;
10249             &quot;OR      $dst,$tmp,$dst\n\t&quot;
10250             &quot;SRL     $dst,2,$tmp\n\t&quot;
10251             &quot;OR      $dst,$tmp,$dst\n\t&quot;
10252             &quot;SRL     $dst,4,$tmp\n\t&quot;
10253             &quot;OR      $dst,$tmp,$dst\n\t&quot;
10254             &quot;SRL     $dst,8,$tmp\n\t&quot;
10255             &quot;OR      $dst,$tmp,$dst\n\t&quot;
10256             &quot;SRL     $dst,16,$tmp\n\t&quot;
10257             &quot;OR      $dst,$tmp,$dst\n\t&quot;
10258             &quot;POPC    $dst,$dst\n\t&quot;
10259             &quot;MOV     32,$tmp\n\t&quot;
10260             &quot;SUB     $tmp,$dst,$dst&quot; %}
10261   ins_encode %{
10262     Register Rdst = $dst$$Register;
10263     Register Rsrc = $src$$Register;
10264     Register Rtmp = $tmp$$Register;
10265     __ srl(Rsrc, 1,    Rtmp);
10266     __ srl(Rsrc, 0,    Rdst);
10267     __ or3(Rdst, Rtmp, Rdst);
10268     __ srl(Rdst, 2,    Rtmp);
10269     __ or3(Rdst, Rtmp, Rdst);
10270     __ srl(Rdst, 4,    Rtmp);
10271     __ or3(Rdst, Rtmp, Rdst);
10272     __ srl(Rdst, 8,    Rtmp);
10273     __ or3(Rdst, Rtmp, Rdst);
10274     __ srl(Rdst, 16,   Rtmp);
10275     __ or3(Rdst, Rtmp, Rdst);
10276     __ popc(Rdst, Rdst);
10277     __ mov(BitsPerInt, Rtmp);
10278     __ sub(Rtmp, Rdst, Rdst);
10279   %}
10280   ins_pipe(ialu_reg);
10281 %}
10282 
10283 instruct countLeadingZerosL(iRegIsafe dst, iRegL src, iRegL tmp, flagsReg cr) %{
10284   predicate(UsePopCountInstruction);  // See Matcher::match_rule_supported
10285   match(Set dst (CountLeadingZerosL src));
10286   effect(TEMP dst, TEMP tmp, KILL cr);
10287 
10288   // x |= (x &gt;&gt; 1);
10289   // x |= (x &gt;&gt; 2);
10290   // x |= (x &gt;&gt; 4);
10291   // x |= (x &gt;&gt; 8);
10292   // x |= (x &gt;&gt; 16);
10293   // x |= (x &gt;&gt; 32);
10294   // return (WORDBITS - popc(x));
10295   format %{ &quot;SRLX    $src,1,$tmp\t! count leading zeros (long)\n\t&quot;
10296             &quot;OR      $src,$tmp,$dst\n\t&quot;
10297             &quot;SRLX    $dst,2,$tmp\n\t&quot;
10298             &quot;OR      $dst,$tmp,$dst\n\t&quot;
10299             &quot;SRLX    $dst,4,$tmp\n\t&quot;
10300             &quot;OR      $dst,$tmp,$dst\n\t&quot;
10301             &quot;SRLX    $dst,8,$tmp\n\t&quot;
10302             &quot;OR      $dst,$tmp,$dst\n\t&quot;
10303             &quot;SRLX    $dst,16,$tmp\n\t&quot;
10304             &quot;OR      $dst,$tmp,$dst\n\t&quot;
10305             &quot;SRLX    $dst,32,$tmp\n\t&quot;
10306             &quot;OR      $dst,$tmp,$dst\n\t&quot;
10307             &quot;POPC    $dst,$dst\n\t&quot;
10308             &quot;MOV     64,$tmp\n\t&quot;
10309             &quot;SUB     $tmp,$dst,$dst&quot; %}
10310   ins_encode %{
10311     Register Rdst = $dst$$Register;
10312     Register Rsrc = $src$$Register;
10313     Register Rtmp = $tmp$$Register;
10314     __ srlx(Rsrc, 1,    Rtmp);
10315     __ or3( Rsrc, Rtmp, Rdst);
10316     __ srlx(Rdst, 2,    Rtmp);
10317     __ or3( Rdst, Rtmp, Rdst);
10318     __ srlx(Rdst, 4,    Rtmp);
10319     __ or3( Rdst, Rtmp, Rdst);
10320     __ srlx(Rdst, 8,    Rtmp);
10321     __ or3( Rdst, Rtmp, Rdst);
10322     __ srlx(Rdst, 16,   Rtmp);
10323     __ or3( Rdst, Rtmp, Rdst);
10324     __ srlx(Rdst, 32,   Rtmp);
10325     __ or3( Rdst, Rtmp, Rdst);
10326     __ popc(Rdst, Rdst);
10327     __ mov(BitsPerLong, Rtmp);
10328     __ sub(Rtmp, Rdst, Rdst);
10329   %}
10330   ins_pipe(ialu_reg);
10331 %}
10332 
10333 instruct countTrailingZerosI(iRegIsafe dst, iRegI src, flagsReg cr) %{
10334   predicate(UsePopCountInstruction);  // See Matcher::match_rule_supported
10335   match(Set dst (CountTrailingZerosI src));
10336   effect(TEMP dst, KILL cr);
10337 
10338   // return popc(~x &amp; (x - 1));
10339   format %{ &quot;SUB     $src,1,$dst\t! count trailing zeros (int)\n\t&quot;
10340             &quot;ANDN    $dst,$src,$dst\n\t&quot;
10341             &quot;SRL     $dst,R_G0,$dst\n\t&quot;
10342             &quot;POPC    $dst,$dst&quot; %}
10343   ins_encode %{
10344     Register Rdst = $dst$$Register;
10345     Register Rsrc = $src$$Register;
10346     __ sub(Rsrc, 1, Rdst);
10347     __ andn(Rdst, Rsrc, Rdst);
10348     __ srl(Rdst, G0, Rdst);
10349     __ popc(Rdst, Rdst);
10350   %}
10351   ins_pipe(ialu_reg);
10352 %}
10353 
10354 instruct countTrailingZerosL(iRegIsafe dst, iRegL src, flagsReg cr) %{
10355   predicate(UsePopCountInstruction);  // See Matcher::match_rule_supported
10356   match(Set dst (CountTrailingZerosL src));
10357   effect(TEMP dst, KILL cr);
10358 
10359   // return popc(~x &amp; (x - 1));
10360   format %{ &quot;SUB     $src,1,$dst\t! count trailing zeros (long)\n\t&quot;
10361             &quot;ANDN    $dst,$src,$dst\n\t&quot;
10362             &quot;POPC    $dst,$dst&quot; %}
10363   ins_encode %{
10364     Register Rdst = $dst$$Register;
10365     Register Rsrc = $src$$Register;
10366     __ sub(Rsrc, 1, Rdst);
10367     __ andn(Rdst, Rsrc, Rdst);
10368     __ popc(Rdst, Rdst);
10369   %}
10370   ins_pipe(ialu_reg);
10371 %}
10372 
10373 
10374 //---------- Population Count Instructions -------------------------------------
10375 
10376 instruct popCountI(iRegIsafe dst, iRegI src) %{
10377   predicate(UsePopCountInstruction);
10378   match(Set dst (PopCountI src));
10379 
10380   format %{ &quot;SRL    $src, G0, $dst\t! clear upper word for 64 bit POPC\n\t&quot;
10381             &quot;POPC   $dst, $dst&quot; %}
10382   ins_encode %{
10383     __ srl($src$$Register, G0, $dst$$Register);
10384     __ popc($dst$$Register, $dst$$Register);
10385   %}
10386   ins_pipe(ialu_reg);
10387 %}
10388 
10389 // Note: Long.bitCount(long) returns an int.
10390 instruct popCountL(iRegIsafe dst, iRegL src) %{
10391   predicate(UsePopCountInstruction);
10392   match(Set dst (PopCountL src));
10393 
10394   format %{ &quot;POPC   $src, $dst&quot; %}
10395   ins_encode %{
10396     __ popc($src$$Register, $dst$$Register);
10397   %}
10398   ins_pipe(ialu_reg);
10399 %}
10400 
10401 
10402 // ============================================================================
10403 //------------Bytes reverse--------------------------------------------------
10404 
10405 instruct bytes_reverse_int(iRegI dst, stackSlotI src) %{
10406   match(Set dst (ReverseBytesI src));
10407 
10408   // Op cost is artificially doubled to make sure that load or store
10409   // instructions are preferred over this one which requires a spill
10410   // onto a stack slot.
10411   ins_cost(2*DEFAULT_COST + MEMORY_REF_COST);
10412   format %{ &quot;LDUWA  $src, $dst\t!asi=primary_little&quot; %}
10413 
10414   ins_encode %{
10415     __ set($src$$disp + STACK_BIAS, O7);
10416     __ lduwa($src$$base$$Register, O7, Assembler::ASI_PRIMARY_LITTLE, $dst$$Register);
10417   %}
10418   ins_pipe( iload_mem );
10419 %}
10420 
10421 instruct bytes_reverse_long(iRegL dst, stackSlotL src) %{
10422   match(Set dst (ReverseBytesL src));
10423 
10424   // Op cost is artificially doubled to make sure that load or store
10425   // instructions are preferred over this one which requires a spill
10426   // onto a stack slot.
10427   ins_cost(2*DEFAULT_COST + MEMORY_REF_COST);
10428   format %{ &quot;LDXA   $src, $dst\t!asi=primary_little&quot; %}
10429 
10430   ins_encode %{
10431     __ set($src$$disp + STACK_BIAS, O7);
10432     __ ldxa($src$$base$$Register, O7, Assembler::ASI_PRIMARY_LITTLE, $dst$$Register);
10433   %}
10434   ins_pipe( iload_mem );
10435 %}
10436 
10437 instruct bytes_reverse_unsigned_short(iRegI dst, stackSlotI src) %{
10438   match(Set dst (ReverseBytesUS src));
10439 
10440   // Op cost is artificially doubled to make sure that load or store
10441   // instructions are preferred over this one which requires a spill
10442   // onto a stack slot.
10443   ins_cost(2*DEFAULT_COST + MEMORY_REF_COST);
10444   format %{ &quot;LDUHA  $src, $dst\t!asi=primary_little\n\t&quot; %}
10445 
10446   ins_encode %{
10447     // the value was spilled as an int so bias the load
10448     __ set($src$$disp + STACK_BIAS + 2, O7);
10449     __ lduha($src$$base$$Register, O7, Assembler::ASI_PRIMARY_LITTLE, $dst$$Register);
10450   %}
10451   ins_pipe( iload_mem );
10452 %}
10453 
10454 instruct bytes_reverse_short(iRegI dst, stackSlotI src) %{
10455   match(Set dst (ReverseBytesS src));
10456 
10457   // Op cost is artificially doubled to make sure that load or store
10458   // instructions are preferred over this one which requires a spill
10459   // onto a stack slot.
10460   ins_cost(2*DEFAULT_COST + MEMORY_REF_COST);
10461   format %{ &quot;LDSHA  $src, $dst\t!asi=primary_little\n\t&quot; %}
10462 
10463   ins_encode %{
10464     // the value was spilled as an int so bias the load
10465     __ set($src$$disp + STACK_BIAS + 2, O7);
10466     __ ldsha($src$$base$$Register, O7, Assembler::ASI_PRIMARY_LITTLE, $dst$$Register);
10467   %}
10468   ins_pipe( iload_mem );
10469 %}
10470 
10471 // Load Integer reversed byte order
10472 instruct loadI_reversed(iRegI dst, indIndexMemory src) %{
10473   match(Set dst (ReverseBytesI (LoadI src)));
10474 
10475   ins_cost(DEFAULT_COST + MEMORY_REF_COST);
10476   size(4);
10477   format %{ &quot;LDUWA  $src, $dst\t!asi=primary_little&quot; %}
10478 
10479   ins_encode %{
10480     __ lduwa($src$$base$$Register, $src$$index$$Register, Assembler::ASI_PRIMARY_LITTLE, $dst$$Register);
10481   %}
10482   ins_pipe(iload_mem);
10483 %}
10484 
10485 // Load Long - aligned and reversed
10486 instruct loadL_reversed(iRegL dst, indIndexMemory src) %{
10487   match(Set dst (ReverseBytesL (LoadL src)));
10488 
10489   ins_cost(MEMORY_REF_COST);
10490   size(4);
10491   format %{ &quot;LDXA   $src, $dst\t!asi=primary_little&quot; %}
10492 
10493   ins_encode %{
10494     __ ldxa($src$$base$$Register, $src$$index$$Register, Assembler::ASI_PRIMARY_LITTLE, $dst$$Register);
10495   %}
10496   ins_pipe(iload_mem);
10497 %}
10498 
10499 // Load unsigned short / char reversed byte order
10500 instruct loadUS_reversed(iRegI dst, indIndexMemory src) %{
10501   match(Set dst (ReverseBytesUS (LoadUS src)));
10502 
10503   ins_cost(MEMORY_REF_COST);
10504   size(4);
10505   format %{ &quot;LDUHA  $src, $dst\t!asi=primary_little&quot; %}
10506 
10507   ins_encode %{
10508     __ lduha($src$$base$$Register, $src$$index$$Register, Assembler::ASI_PRIMARY_LITTLE, $dst$$Register);
10509   %}
10510   ins_pipe(iload_mem);
10511 %}
10512 
10513 // Load short reversed byte order
10514 instruct loadS_reversed(iRegI dst, indIndexMemory src) %{
10515   match(Set dst (ReverseBytesS (LoadS src)));
10516 
10517   ins_cost(MEMORY_REF_COST);
10518   size(4);
10519   format %{ &quot;LDSHA  $src, $dst\t!asi=primary_little&quot; %}
10520 
10521   ins_encode %{
10522     __ ldsha($src$$base$$Register, $src$$index$$Register, Assembler::ASI_PRIMARY_LITTLE, $dst$$Register);
10523   %}
10524   ins_pipe(iload_mem);
10525 %}
10526 
10527 // Store Integer reversed byte order
10528 instruct storeI_reversed(indIndexMemory dst, iRegI src) %{
10529   match(Set dst (StoreI dst (ReverseBytesI src)));
10530 
10531   ins_cost(MEMORY_REF_COST);
10532   size(4);
10533   format %{ &quot;STWA   $src, $dst\t!asi=primary_little&quot; %}
10534 
10535   ins_encode %{
10536     __ stwa($src$$Register, $dst$$base$$Register, $dst$$index$$Register, Assembler::ASI_PRIMARY_LITTLE);
10537   %}
10538   ins_pipe(istore_mem_reg);
10539 %}
10540 
10541 // Store Long reversed byte order
10542 instruct storeL_reversed(indIndexMemory dst, iRegL src) %{
10543   match(Set dst (StoreL dst (ReverseBytesL src)));
10544 
10545   ins_cost(MEMORY_REF_COST);
10546   size(4);
10547   format %{ &quot;STXA   $src, $dst\t!asi=primary_little&quot; %}
10548 
10549   ins_encode %{
10550     __ stxa($src$$Register, $dst$$base$$Register, $dst$$index$$Register, Assembler::ASI_PRIMARY_LITTLE);
10551   %}
10552   ins_pipe(istore_mem_reg);
10553 %}
10554 
10555 // Store unsighed short/char reversed byte order
10556 instruct storeUS_reversed(indIndexMemory dst, iRegI src) %{
10557   match(Set dst (StoreC dst (ReverseBytesUS src)));
10558 
10559   ins_cost(MEMORY_REF_COST);
10560   size(4);
10561   format %{ &quot;STHA   $src, $dst\t!asi=primary_little&quot; %}
10562 
10563   ins_encode %{
10564     __ stha($src$$Register, $dst$$base$$Register, $dst$$index$$Register, Assembler::ASI_PRIMARY_LITTLE);
10565   %}
10566   ins_pipe(istore_mem_reg);
10567 %}
10568 
10569 // Store short reversed byte order
10570 instruct storeS_reversed(indIndexMemory dst, iRegI src) %{
10571   match(Set dst (StoreC dst (ReverseBytesS src)));
10572 
10573   ins_cost(MEMORY_REF_COST);
10574   size(4);
10575   format %{ &quot;STHA   $src, $dst\t!asi=primary_little&quot; %}
10576 
10577   ins_encode %{
10578     __ stha($src$$Register, $dst$$base$$Register, $dst$$index$$Register, Assembler::ASI_PRIMARY_LITTLE);
10579   %}
10580   ins_pipe(istore_mem_reg);
10581 %}
10582 
10583 // ====================VECTOR INSTRUCTIONS=====================================
10584 
10585 // Load Aligned Packed values into a Double Register
10586 instruct loadV8(regD dst, memory mem) %{
10587   predicate(n-&gt;as_LoadVector()-&gt;memory_size() == 8);
10588   match(Set dst (LoadVector mem));
10589   ins_cost(MEMORY_REF_COST);
10590   size(4);
10591   format %{ &quot;LDDF   $mem,$dst\t! load vector (8 bytes)&quot; %}
10592   ins_encode %{
10593     __ ldf(FloatRegisterImpl::D, $mem$$Address, as_DoubleFloatRegister($dst$$reg));
10594   %}
10595   ins_pipe(floadD_mem);
10596 %}
10597 
10598 // Store Vector in Double register to memory
10599 instruct storeV8(memory mem, regD src) %{
10600   predicate(n-&gt;as_StoreVector()-&gt;memory_size() == 8);
10601   match(Set mem (StoreVector mem src));
10602   ins_cost(MEMORY_REF_COST);
10603   size(4);
10604   format %{ &quot;STDF   $src,$mem\t! store vector (8 bytes)&quot; %}
10605   ins_encode %{
10606     __ stf(FloatRegisterImpl::D, as_DoubleFloatRegister($src$$reg), $mem$$Address);
10607   %}
10608   ins_pipe(fstoreD_mem_reg);
10609 %}
10610 
10611 // Store Zero into vector in memory
10612 instruct storeV8B_zero(memory mem, immI0 zero) %{
10613   predicate(n-&gt;as_StoreVector()-&gt;memory_size() == 8);
10614   match(Set mem (StoreVector mem (ReplicateB zero)));
10615   ins_cost(MEMORY_REF_COST);
10616   size(4);
10617   format %{ &quot;STX    $zero,$mem\t! store zero vector (8 bytes)&quot; %}
10618   ins_encode %{
10619     __ stx(G0, $mem$$Address);
10620   %}
10621   ins_pipe(fstoreD_mem_zero);
10622 %}
10623 
10624 instruct storeV4S_zero(memory mem, immI0 zero) %{
10625   predicate(n-&gt;as_StoreVector()-&gt;memory_size() == 8);
10626   match(Set mem (StoreVector mem (ReplicateS zero)));
10627   ins_cost(MEMORY_REF_COST);
10628   size(4);
10629   format %{ &quot;STX    $zero,$mem\t! store zero vector (4 shorts)&quot; %}
10630   ins_encode %{
10631     __ stx(G0, $mem$$Address);
10632   %}
10633   ins_pipe(fstoreD_mem_zero);
10634 %}
10635 
10636 instruct storeV2I_zero(memory mem, immI0 zero) %{
10637   predicate(n-&gt;as_StoreVector()-&gt;memory_size() == 8);
10638   match(Set mem (StoreVector mem (ReplicateI zero)));
10639   ins_cost(MEMORY_REF_COST);
10640   size(4);
10641   format %{ &quot;STX    $zero,$mem\t! store zero vector (2 ints)&quot; %}
10642   ins_encode %{
10643     __ stx(G0, $mem$$Address);
10644   %}
10645   ins_pipe(fstoreD_mem_zero);
10646 %}
10647 
10648 instruct storeV2F_zero(memory mem, immF0 zero) %{
10649   predicate(n-&gt;as_StoreVector()-&gt;memory_size() == 8);
10650   match(Set mem (StoreVector mem (ReplicateF zero)));
10651   ins_cost(MEMORY_REF_COST);
10652   size(4);
10653   format %{ &quot;STX    $zero,$mem\t! store zero vector (2 floats)&quot; %}
10654   ins_encode %{
10655     __ stx(G0, $mem$$Address);
10656   %}
10657   ins_pipe(fstoreD_mem_zero);
10658 %}
10659 
10660 // Replicate scalar to packed byte values into Double register
10661 instruct Repl8B_reg(regD dst, iRegI src, iRegL tmp, o7RegL tmp2) %{
10662   predicate(n-&gt;as_Vector()-&gt;length() == 8 &amp;&amp; UseVIS &gt;= 3);
10663   match(Set dst (ReplicateB src));
10664   effect(DEF dst, USE src, TEMP tmp, KILL tmp2);
10665   format %{ &quot;SLLX  $src,56,$tmp\n\t&quot;
10666             &quot;SRLX  $tmp, 8,$tmp2\n\t&quot;
10667             &quot;OR    $tmp,$tmp2,$tmp\n\t&quot;
10668             &quot;SRLX  $tmp,16,$tmp2\n\t&quot;
10669             &quot;OR    $tmp,$tmp2,$tmp\n\t&quot;
10670             &quot;SRLX  $tmp,32,$tmp2\n\t&quot;
10671             &quot;OR    $tmp,$tmp2,$tmp\t! replicate8B\n\t&quot;
10672             &quot;MOVXTOD $tmp,$dst\t! MoveL2D&quot; %}
10673   ins_encode %{
10674     Register Rsrc = $src$$Register;
10675     Register Rtmp = $tmp$$Register;
10676     Register Rtmp2 = $tmp2$$Register;
10677     __ sllx(Rsrc,    56, Rtmp);
10678     __ srlx(Rtmp,     8, Rtmp2);
10679     __ or3 (Rtmp, Rtmp2, Rtmp);
10680     __ srlx(Rtmp,    16, Rtmp2);
10681     __ or3 (Rtmp, Rtmp2, Rtmp);
10682     __ srlx(Rtmp,    32, Rtmp2);
10683     __ or3 (Rtmp, Rtmp2, Rtmp);
10684     __ movxtod(Rtmp, as_DoubleFloatRegister($dst$$reg));
10685   %}
10686   ins_pipe(ialu_reg);
10687 %}
10688 
10689 // Replicate scalar to packed byte values into Double stack
10690 instruct Repl8B_stk(stackSlotD dst, iRegI src, iRegL tmp, o7RegL tmp2) %{
10691   predicate(n-&gt;as_Vector()-&gt;length() == 8 &amp;&amp; UseVIS &lt; 3);
10692   match(Set dst (ReplicateB src));
10693   effect(DEF dst, USE src, TEMP tmp, KILL tmp2);
10694   format %{ &quot;SLLX  $src,56,$tmp\n\t&quot;
10695             &quot;SRLX  $tmp, 8,$tmp2\n\t&quot;
10696             &quot;OR    $tmp,$tmp2,$tmp\n\t&quot;
10697             &quot;SRLX  $tmp,16,$tmp2\n\t&quot;
10698             &quot;OR    $tmp,$tmp2,$tmp\n\t&quot;
10699             &quot;SRLX  $tmp,32,$tmp2\n\t&quot;
10700             &quot;OR    $tmp,$tmp2,$tmp\t! replicate8B\n\t&quot;
10701             &quot;STX   $tmp,$dst\t! regL to stkD&quot; %}
10702   ins_encode %{
10703     Register Rsrc = $src$$Register;
10704     Register Rtmp = $tmp$$Register;
10705     Register Rtmp2 = $tmp2$$Register;
10706     __ sllx(Rsrc,    56, Rtmp);
10707     __ srlx(Rtmp,     8, Rtmp2);
10708     __ or3 (Rtmp, Rtmp2, Rtmp);
10709     __ srlx(Rtmp,    16, Rtmp2);
10710     __ or3 (Rtmp, Rtmp2, Rtmp);
10711     __ srlx(Rtmp,    32, Rtmp2);
10712     __ or3 (Rtmp, Rtmp2, Rtmp);
10713     __ set ($dst$$disp + STACK_BIAS, Rtmp2);
10714     __ stx (Rtmp, Rtmp2, $dst$$base$$Register);
10715   %}
10716   ins_pipe(ialu_reg);
10717 %}
10718 
10719 // Replicate scalar constant to packed byte values in Double register
10720 instruct Repl8B_immI(regD dst, immI13 con, o7RegI tmp) %{
10721   predicate(n-&gt;as_Vector()-&gt;length() == 8);
10722   match(Set dst (ReplicateB con));
10723   effect(KILL tmp);
10724   format %{ &quot;LDDF   [$constanttablebase + $constantoffset],$dst\t! load from constant table: Repl8B($con)&quot; %}
10725   ins_encode %{
10726     // XXX This is a quick fix for 6833573.
10727     //__ ldf(FloatRegisterImpl::D, $constanttablebase, $constantoffset(replicate_immI($con$$constant, 8, 1)), $dst$$FloatRegister);
10728     RegisterOrConstant con_offset = __ ensure_simm13_or_reg($constantoffset(replicate_immI($con$$constant, 8, 1)), $tmp$$Register);
10729     __ ldf(FloatRegisterImpl::D, $constanttablebase, con_offset, as_DoubleFloatRegister($dst$$reg));
10730   %}
10731   ins_pipe(loadConFD);
10732 %}
10733 
10734 // Replicate scalar to packed char/short values into Double register
10735 instruct Repl4S_reg(regD dst, iRegI src, iRegL tmp, o7RegL tmp2) %{
10736   predicate(n-&gt;as_Vector()-&gt;length() == 4 &amp;&amp; UseVIS &gt;= 3);
10737   match(Set dst (ReplicateS src));
10738   effect(DEF dst, USE src, TEMP tmp, KILL tmp2);
10739   format %{ &quot;SLLX  $src,48,$tmp\n\t&quot;
10740             &quot;SRLX  $tmp,16,$tmp2\n\t&quot;
10741             &quot;OR    $tmp,$tmp2,$tmp\n\t&quot;
10742             &quot;SRLX  $tmp,32,$tmp2\n\t&quot;
10743             &quot;OR    $tmp,$tmp2,$tmp\t! replicate4S\n\t&quot;
10744             &quot;MOVXTOD $tmp,$dst\t! MoveL2D&quot; %}
10745   ins_encode %{
10746     Register Rsrc = $src$$Register;
10747     Register Rtmp = $tmp$$Register;
10748     Register Rtmp2 = $tmp2$$Register;
10749     __ sllx(Rsrc,    48, Rtmp);
10750     __ srlx(Rtmp,    16, Rtmp2);
10751     __ or3 (Rtmp, Rtmp2, Rtmp);
10752     __ srlx(Rtmp,    32, Rtmp2);
10753     __ or3 (Rtmp, Rtmp2, Rtmp);
10754     __ movxtod(Rtmp, as_DoubleFloatRegister($dst$$reg));
10755   %}
10756   ins_pipe(ialu_reg);
10757 %}
10758 
10759 // Replicate scalar to packed char/short values into Double stack
10760 instruct Repl4S_stk(stackSlotD dst, iRegI src, iRegL tmp, o7RegL tmp2) %{
10761   predicate(n-&gt;as_Vector()-&gt;length() == 4 &amp;&amp; UseVIS &lt; 3);
10762   match(Set dst (ReplicateS src));
10763   effect(DEF dst, USE src, TEMP tmp, KILL tmp2);
10764   format %{ &quot;SLLX  $src,48,$tmp\n\t&quot;
10765             &quot;SRLX  $tmp,16,$tmp2\n\t&quot;
10766             &quot;OR    $tmp,$tmp2,$tmp\n\t&quot;
10767             &quot;SRLX  $tmp,32,$tmp2\n\t&quot;
10768             &quot;OR    $tmp,$tmp2,$tmp\t! replicate4S\n\t&quot;
10769             &quot;STX   $tmp,$dst\t! regL to stkD&quot; %}
10770   ins_encode %{
10771     Register Rsrc = $src$$Register;
10772     Register Rtmp = $tmp$$Register;
10773     Register Rtmp2 = $tmp2$$Register;
10774     __ sllx(Rsrc,    48, Rtmp);
10775     __ srlx(Rtmp,    16, Rtmp2);
10776     __ or3 (Rtmp, Rtmp2, Rtmp);
10777     __ srlx(Rtmp,    32, Rtmp2);
10778     __ or3 (Rtmp, Rtmp2, Rtmp);
10779     __ set ($dst$$disp + STACK_BIAS, Rtmp2);
10780     __ stx (Rtmp, Rtmp2, $dst$$base$$Register);
10781   %}
10782   ins_pipe(ialu_reg);
10783 %}
10784 
10785 // Replicate scalar constant to packed char/short values in Double register
10786 instruct Repl4S_immI(regD dst, immI con, o7RegI tmp) %{
10787   predicate(n-&gt;as_Vector()-&gt;length() == 4);
10788   match(Set dst (ReplicateS con));
10789   effect(KILL tmp);
10790   format %{ &quot;LDDF   [$constanttablebase + $constantoffset],$dst\t! load from constant table: Repl4S($con)&quot; %}
10791   ins_encode %{
10792     // XXX This is a quick fix for 6833573.
10793     //__ ldf(FloatRegisterImpl::D, $constanttablebase, $constantoffset(replicate_immI($con$$constant, 4, 2)), $dst$$FloatRegister);
10794     RegisterOrConstant con_offset = __ ensure_simm13_or_reg($constantoffset(replicate_immI($con$$constant, 4, 2)), $tmp$$Register);
10795     __ ldf(FloatRegisterImpl::D, $constanttablebase, con_offset, as_DoubleFloatRegister($dst$$reg));
10796   %}
10797   ins_pipe(loadConFD);
10798 %}
10799 
10800 // Replicate scalar to packed int values into Double register
10801 instruct Repl2I_reg(regD dst, iRegI src, iRegL tmp, o7RegL tmp2) %{
10802   predicate(n-&gt;as_Vector()-&gt;length() == 2 &amp;&amp; UseVIS &gt;= 3);
10803   match(Set dst (ReplicateI src));
10804   effect(DEF dst, USE src, TEMP tmp, KILL tmp2);
10805   format %{ &quot;SLLX  $src,32,$tmp\n\t&quot;
10806             &quot;SRLX  $tmp,32,$tmp2\n\t&quot;
10807             &quot;OR    $tmp,$tmp2,$tmp\t! replicate2I\n\t&quot;
10808             &quot;MOVXTOD $tmp,$dst\t! MoveL2D&quot; %}
10809   ins_encode %{
10810     Register Rsrc = $src$$Register;
10811     Register Rtmp = $tmp$$Register;
10812     Register Rtmp2 = $tmp2$$Register;
10813     __ sllx(Rsrc,    32, Rtmp);
10814     __ srlx(Rtmp,    32, Rtmp2);
10815     __ or3 (Rtmp, Rtmp2, Rtmp);
10816     __ movxtod(Rtmp, as_DoubleFloatRegister($dst$$reg));
10817   %}
10818   ins_pipe(ialu_reg);
10819 %}
10820 
10821 // Replicate scalar to packed int values into Double stack
10822 instruct Repl2I_stk(stackSlotD dst, iRegI src, iRegL tmp, o7RegL tmp2) %{
10823   predicate(n-&gt;as_Vector()-&gt;length() == 2 &amp;&amp; UseVIS &lt; 3);
10824   match(Set dst (ReplicateI src));
10825   effect(DEF dst, USE src, TEMP tmp, KILL tmp2);
10826   format %{ &quot;SLLX  $src,32,$tmp\n\t&quot;
10827             &quot;SRLX  $tmp,32,$tmp2\n\t&quot;
10828             &quot;OR    $tmp,$tmp2,$tmp\t! replicate2I\n\t&quot;
10829             &quot;STX   $tmp,$dst\t! regL to stkD&quot; %}
10830   ins_encode %{
10831     Register Rsrc = $src$$Register;
10832     Register Rtmp = $tmp$$Register;
10833     Register Rtmp2 = $tmp2$$Register;
10834     __ sllx(Rsrc,    32, Rtmp);
10835     __ srlx(Rtmp,    32, Rtmp2);
10836     __ or3 (Rtmp, Rtmp2, Rtmp);
10837     __ set ($dst$$disp + STACK_BIAS, Rtmp2);
10838     __ stx (Rtmp, Rtmp2, $dst$$base$$Register);
10839   %}
10840   ins_pipe(ialu_reg);
10841 %}
10842 
10843 // Replicate scalar zero constant to packed int values in Double register
10844 instruct Repl2I_immI(regD dst, immI con, o7RegI tmp) %{
10845   predicate(n-&gt;as_Vector()-&gt;length() == 2);
10846   match(Set dst (ReplicateI con));
10847   effect(KILL tmp);
10848   format %{ &quot;LDDF   [$constanttablebase + $constantoffset],$dst\t! load from constant table: Repl2I($con)&quot; %}
10849   ins_encode %{
10850     // XXX This is a quick fix for 6833573.
10851     //__ ldf(FloatRegisterImpl::D, $constanttablebase, $constantoffset(replicate_immI($con$$constant, 2, 4)), $dst$$FloatRegister);
10852     RegisterOrConstant con_offset = __ ensure_simm13_or_reg($constantoffset(replicate_immI($con$$constant, 2, 4)), $tmp$$Register);
10853     __ ldf(FloatRegisterImpl::D, $constanttablebase, con_offset, as_DoubleFloatRegister($dst$$reg));
10854   %}
10855   ins_pipe(loadConFD);
10856 %}
10857 
10858 // Replicate scalar to packed float values into Double stack
10859 instruct Repl2F_stk(stackSlotD dst, regF src) %{
10860   predicate(n-&gt;as_Vector()-&gt;length() == 2);
10861   match(Set dst (ReplicateF src));
10862   ins_cost(MEMORY_REF_COST*2);
10863   format %{ &quot;STF    $src,$dst.hi\t! packed2F\n\t&quot;
10864             &quot;STF    $src,$dst.lo&quot; %}
10865   opcode(Assembler::stf_op3);
10866   ins_encode(simple_form3_mem_reg(dst, src), form3_mem_plus_4_reg(dst, src));
10867   ins_pipe(fstoreF_stk_reg);
10868 %}
10869 
10870 // Replicate scalar zero constant to packed float values in Double register
10871 instruct Repl2F_immF(regD dst, immF con, o7RegI tmp) %{
10872   predicate(n-&gt;as_Vector()-&gt;length() == 2);
10873   match(Set dst (ReplicateF con));
10874   effect(KILL tmp);
10875   format %{ &quot;LDDF   [$constanttablebase + $constantoffset],$dst\t! load from constant table: Repl2F($con)&quot; %}
10876   ins_encode %{
10877     // XXX This is a quick fix for 6833573.
10878     //__ ldf(FloatRegisterImpl::D, $constanttablebase, $constantoffset(replicate_immF($con$$constant)), $dst$$FloatRegister);
10879     RegisterOrConstant con_offset = __ ensure_simm13_or_reg($constantoffset(replicate_immF($con$$constant)), $tmp$$Register);
10880     __ ldf(FloatRegisterImpl::D, $constanttablebase, con_offset, as_DoubleFloatRegister($dst$$reg));
10881   %}
10882   ins_pipe(loadConFD);
10883 %}
10884 
10885 //----------PEEPHOLE RULES-----------------------------------------------------
10886 // These must follow all instruction definitions as they use the names
10887 // defined in the instructions definitions.
10888 //
10889 // peepmatch ( root_instr_name [preceding_instruction]* );
10890 //
10891 // peepconstraint %{
10892 // (instruction_number.operand_name relational_op instruction_number.operand_name
10893 //  [, ...] );
10894 // // instruction numbers are zero-based using left to right order in peepmatch
10895 //
10896 // peepreplace ( instr_name  ( [instruction_number.operand_name]* ) );
10897 // // provide an instruction_number.operand_name for each operand that appears
10898 // // in the replacement instruction&#39;s match rule
10899 //
10900 // ---------VM FLAGS---------------------------------------------------------
10901 //
10902 // All peephole optimizations can be turned off using -XX:-OptoPeephole
10903 //
10904 // Each peephole rule is given an identifying number starting with zero and
10905 // increasing by one in the order seen by the parser.  An individual peephole
10906 // can be enabled, and all others disabled, by using -XX:OptoPeepholeAt=#
10907 // on the command-line.
10908 //
10909 // ---------CURRENT LIMITATIONS----------------------------------------------
10910 //
10911 // Only match adjacent instructions in same basic block
10912 // Only equality constraints
10913 // Only constraints between operands, not (0.dest_reg == EAX_enc)
10914 // Only one replacement instruction
10915 //
10916 // ---------EXAMPLE----------------------------------------------------------
10917 //
10918 // // pertinent parts of existing instructions in architecture description
10919 // instruct movI(eRegI dst, eRegI src) %{
10920 //   match(Set dst (CopyI src));
10921 // %}
10922 //
10923 // instruct incI_eReg(eRegI dst, immI1 src, eFlagsReg cr) %{
10924 //   match(Set dst (AddI dst src));
10925 //   effect(KILL cr);
10926 // %}
10927 //
10928 // // Change (inc mov) to lea
10929 // peephole %{
10930 //   // increment preceeded by register-register move
10931 //   peepmatch ( incI_eReg movI );
10932 //   // require that the destination register of the increment
10933 //   // match the destination register of the move
10934 //   peepconstraint ( 0.dst == 1.dst );
10935 //   // construct a replacement instruction that sets
10936 //   // the destination to ( move&#39;s source register + one )
10937 //   peepreplace ( incI_eReg_immI1( 0.dst 1.src 0.src ) );
10938 // %}
10939 //
10940 
10941 // // Change load of spilled value to only a spill
10942 // instruct storeI(memory mem, eRegI src) %{
10943 //   match(Set mem (StoreI mem src));
10944 // %}
10945 //
10946 // instruct loadI(eRegI dst, memory mem) %{
10947 //   match(Set dst (LoadI mem));
10948 // %}
10949 //
10950 // peephole %{
10951 //   peepmatch ( loadI storeI );
10952 //   peepconstraint ( 1.src == 0.dst, 1.mem == 0.mem );
10953 //   peepreplace ( storeI( 1.mem 1.mem 1.src ) );
10954 // %}
10955 
10956 //----------SMARTSPILL RULES---------------------------------------------------
10957 // These must follow all instruction definitions as they use the names
10958 // defined in the instructions definitions.
10959 //
10960 // SPARC will probably not have any of these rules due to RISC instruction set.
10961 
10962 //----------PIPELINE-----------------------------------------------------------
10963 // Rules which define the behavior of the target architectures pipeline.
<a name="84" id="anc84"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="84" type="hidden" />
</body>
</html>
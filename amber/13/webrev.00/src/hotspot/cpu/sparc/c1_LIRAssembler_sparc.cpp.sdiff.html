<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/sparc/c1_LIRAssembler_sparc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../s390/vm_version_s390.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="frame_sparc.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/sparc/c1_LIRAssembler_sparc.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
1411   assert(disp_reg != noreg || Assembler::is_simm13(disp_value), &quot;should have set this up&quot;);
1412   if (disp_reg == noreg) {
1413     offset = store(from_reg, src, disp_value, type, wide, unaligned);
1414   } else {
1415     assert(!unaligned, &quot;can&#39;t handle this&quot;);
1416     offset = store(from_reg, src, disp_reg, type, wide);
1417   }
1418 
1419   if (patch != NULL) {
1420     patching_epilog(patch, patch_code, src, info);
1421   }
1422 
1423   if (info != NULL) add_debug_info_for_null_check(offset, info);
1424 }
1425 
1426 
1427 void LIR_Assembler::return_op(LIR_Opr result) {
1428   if (StackReservedPages &gt; 0 &amp;&amp; compilation()-&gt;has_reserved_stack_access()) {
1429     __ reserved_stack_check();
1430   }
<span class="line-modified">1431   if (SafepointMechanism::uses_thread_local_poll()) {</span>
<span class="line-removed">1432     __ ld_ptr(Address(G2_thread, Thread::polling_page_offset()), L0);</span>
<span class="line-removed">1433   } else {</span>
<span class="line-removed">1434     __ set((intptr_t)os::get_polling_page(), L0);</span>
<span class="line-removed">1435   }</span>
1436   __ relocate(relocInfo::poll_return_type);
1437   __ ld_ptr(L0, 0, G0);
1438   __ ret();
1439   __ delayed()-&gt;restore();
1440 }
1441 
1442 
1443 int LIR_Assembler::safepoint_poll(LIR_Opr tmp, CodeEmitInfo* info) {
<span class="line-modified">1444   if (SafepointMechanism::uses_thread_local_poll()) {</span>
<span class="line-removed">1445     __ ld_ptr(Address(G2_thread, Thread::polling_page_offset()), tmp-&gt;as_register());</span>
<span class="line-removed">1446   } else {</span>
<span class="line-removed">1447     __ set((intptr_t)os::get_polling_page(), tmp-&gt;as_register());</span>
<span class="line-removed">1448   }</span>
1449   if (info != NULL) {
1450     add_debug_info_for_branch(info);
1451   }
1452   int offset = __ offset();
1453 
1454   __ relocate(relocInfo::poll_type);
1455   __ ld_ptr(tmp-&gt;as_register(), 0, G0);
1456   return offset;
1457 }
1458 
1459 
1460 void LIR_Assembler::emit_static_call_stub() {
1461   address call_pc = __ pc();
1462   address stub = __ start_a_stub(call_stub_size());
1463   if (stub == NULL) {
1464     bailout(&quot;static call stub overflow&quot;);
1465     return;
1466   }
1467 
1468   int start = __ offset();
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
1411   assert(disp_reg != noreg || Assembler::is_simm13(disp_value), &quot;should have set this up&quot;);
1412   if (disp_reg == noreg) {
1413     offset = store(from_reg, src, disp_value, type, wide, unaligned);
1414   } else {
1415     assert(!unaligned, &quot;can&#39;t handle this&quot;);
1416     offset = store(from_reg, src, disp_reg, type, wide);
1417   }
1418 
1419   if (patch != NULL) {
1420     patching_epilog(patch, patch_code, src, info);
1421   }
1422 
1423   if (info != NULL) add_debug_info_for_null_check(offset, info);
1424 }
1425 
1426 
1427 void LIR_Assembler::return_op(LIR_Opr result) {
1428   if (StackReservedPages &gt; 0 &amp;&amp; compilation()-&gt;has_reserved_stack_access()) {
1429     __ reserved_stack_check();
1430   }
<span class="line-modified">1431   __ ld_ptr(Address(G2_thread, Thread::polling_page_offset()), L0);</span>




1432   __ relocate(relocInfo::poll_return_type);
1433   __ ld_ptr(L0, 0, G0);
1434   __ ret();
1435   __ delayed()-&gt;restore();
1436 }
1437 
1438 
1439 int LIR_Assembler::safepoint_poll(LIR_Opr tmp, CodeEmitInfo* info) {
<span class="line-modified">1440   __ ld_ptr(Address(G2_thread, Thread::polling_page_offset()), tmp-&gt;as_register());</span>




1441   if (info != NULL) {
1442     add_debug_info_for_branch(info);
1443   }
1444   int offset = __ offset();
1445 
1446   __ relocate(relocInfo::poll_type);
1447   __ ld_ptr(tmp-&gt;as_register(), 0, G0);
1448   return offset;
1449 }
1450 
1451 
1452 void LIR_Assembler::emit_static_call_stub() {
1453   address call_pc = __ pc();
1454   address stub = __ start_a_stub(call_stub_size());
1455   if (stub == NULL) {
1456     bailout(&quot;static call stub overflow&quot;);
1457     return;
1458   }
1459 
1460   int start = __ offset();
</pre>
</td>
</tr>
</table>
<center><a href="../s390/vm_version_s390.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="frame_sparc.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/cpu/sparc/macroAssembler_sparc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="interp_masm_sparc.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_sparc.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/sparc/macroAssembler_sparc.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -47,13 +47,10 @@</span>
  #include &quot;runtime/sharedRuntime.hpp&quot;
  #include &quot;runtime/stubRoutines.hpp&quot;
  #include &quot;utilities/align.hpp&quot;
  #include &quot;utilities/macros.hpp&quot;
  #include &quot;utilities/powerOfTwo.hpp&quot;
<span class="udiff-line-removed">- #ifdef COMPILER2</span>
<span class="udiff-line-removed">- #include &quot;opto/intrinsicnode.hpp&quot;</span>
<span class="udiff-line-removed">- #endif</span>
  
  #ifdef PRODUCT
  #define BLOCK_COMMENT(str) /* nothing */
  #define STOP(error) stop(error)
  #else
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -237,22 +234,14 @@</span>
  void MacroAssembler::breakpoint_trap() {
    trap(ST_RESERVED_FOR_USER_0);
  }
  
  void MacroAssembler::safepoint_poll(Label&amp; slow_path, bool a, Register thread_reg, Register temp_reg) {
<span class="udiff-line-modified-removed">-   if (SafepointMechanism::uses_thread_local_poll()) {</span>
<span class="udiff-line-modified-removed">-     ldx(Address(thread_reg, Thread::polling_page_offset()), temp_reg, 0);</span>
<span class="udiff-line-modified-removed">-     // Armed page has poll bit set.</span>
<span class="udiff-line-modified-removed">-     and3(temp_reg, SafepointMechanism::poll_bit(), temp_reg);</span>
<span class="udiff-line-removed">-     br_notnull(temp_reg, a, Assembler::pn, slow_path);</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     AddressLiteral sync_state(SafepointSynchronize::address_of_state());</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     load_contents(sync_state, temp_reg);</span>
<span class="udiff-line-removed">-     cmp(temp_reg, SafepointSynchronize::_not_synchronized);</span>
<span class="udiff-line-removed">-     br(Assembler::notEqual, a, Assembler::pn, slow_path);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+   ldx(Address(thread_reg, Thread::polling_page_offset()), temp_reg, 0);</span>
<span class="udiff-line-modified-added">+   // Armed page has poll bit set.</span>
<span class="udiff-line-modified-added">+   and3(temp_reg, SafepointMechanism::poll_bit(), temp_reg);</span>
<span class="udiff-line-modified-added">+   br_notnull(temp_reg, a, Assembler::pn, slow_path);</span>
  }
  
  void MacroAssembler::enter() {
    Unimplemented();
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3434,502 +3423,10 @@</span>
        load_ptr_contents(base, G6_heapbase);
      }
    }
  }
  
<span class="udiff-line-removed">- #ifdef COMPILER2</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- // Compress char[] to byte[] by compressing 16 bytes at once. Return 0 on failure.</span>
<span class="udiff-line-removed">- void MacroAssembler::string_compress_16(Register src, Register dst, Register cnt, Register result,</span>
<span class="udiff-line-removed">-                                         Register tmp1, Register tmp2, Register tmp3, Register tmp4,</span>
<span class="udiff-line-removed">-                                         FloatRegister ftmp1, FloatRegister ftmp2, FloatRegister ftmp3, Label&amp; Ldone) {</span>
<span class="udiff-line-removed">-   Label Lloop, Lslow;</span>
<span class="udiff-line-removed">-   assert(UseVIS &gt;= 3, &quot;VIS3 is required&quot;);</span>
<span class="udiff-line-removed">-   assert_different_registers(src, dst, cnt, tmp1, tmp2, tmp3, tmp4, result);</span>
<span class="udiff-line-removed">-   assert_different_registers(ftmp1, ftmp2, ftmp3);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Check if cnt &gt;= 8 (= 16 bytes)</span>
<span class="udiff-line-removed">-   cmp(cnt, 8);</span>
<span class="udiff-line-removed">-   br(Assembler::less, false, Assembler::pn, Lslow);</span>
<span class="udiff-line-removed">-   delayed()-&gt;mov(cnt, result); // copy count</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Check for 8-byte alignment of src and dst</span>
<span class="udiff-line-removed">-   or3(src, dst, tmp1);</span>
<span class="udiff-line-removed">-   andcc(tmp1, 7, G0);</span>
<span class="udiff-line-removed">-   br(Assembler::notZero, false, Assembler::pn, Lslow);</span>
<span class="udiff-line-removed">-   delayed()-&gt;nop();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Set mask for bshuffle instruction</span>
<span class="udiff-line-removed">-   Register mask = tmp4;</span>
<span class="udiff-line-removed">-   set(0x13579bdf, mask);</span>
<span class="udiff-line-removed">-   bmask(mask, G0, G0);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Set mask to 0xff00 ff00 ff00 ff00 to check for non-latin1 characters</span>
<span class="udiff-line-removed">-   Assembler::sethi(0xff00fc00, mask); // mask = 0x0000 0000 ff00 fc00</span>
<span class="udiff-line-removed">-   add(mask, 0x300, mask);             // mask = 0x0000 0000 ff00 ff00</span>
<span class="udiff-line-removed">-   sllx(mask, 32, tmp1);               // tmp1 = 0xff00 ff00 0000 0000</span>
<span class="udiff-line-removed">-   or3(mask, tmp1, mask);              // mask = 0xff00 ff00 ff00 ff00</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Load first 8 bytes</span>
<span class="udiff-line-removed">-   ldx(src, 0, tmp1);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   bind(Lloop);</span>
<span class="udiff-line-removed">-   // Load next 8 bytes</span>
<span class="udiff-line-removed">-   ldx(src, 8, tmp2);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Check for non-latin1 character by testing if the most significant byte of a char is set.</span>
<span class="udiff-line-removed">-   // Although we have to move the data between integer and floating point registers, this is</span>
<span class="udiff-line-removed">-   // still faster than the corresponding VIS instructions (ford/fand/fcmpd).</span>
<span class="udiff-line-removed">-   or3(tmp1, tmp2, tmp3);</span>
<span class="udiff-line-removed">-   btst(tmp3, mask);</span>
<span class="udiff-line-removed">-   // annul zeroing if branch is not taken to preserve original count</span>
<span class="udiff-line-removed">-   brx(Assembler::notZero, true, Assembler::pn, Ldone);</span>
<span class="udiff-line-removed">-   delayed()-&gt;mov(G0, result); // 0 - failed</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Move bytes into float register</span>
<span class="udiff-line-removed">-   movxtod(tmp1, ftmp1);</span>
<span class="udiff-line-removed">-   movxtod(tmp2, ftmp2);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Compress by copying one byte per char from ftmp1 and ftmp2 to ftmp3</span>
<span class="udiff-line-removed">-   bshuffle(ftmp1, ftmp2, ftmp3);</span>
<span class="udiff-line-removed">-   stf(FloatRegisterImpl::D, ftmp3, dst, 0);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Increment addresses and decrement count</span>
<span class="udiff-line-removed">-   inc(src, 16);</span>
<span class="udiff-line-removed">-   inc(dst, 8);</span>
<span class="udiff-line-removed">-   dec(cnt, 8);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   cmp(cnt, 8);</span>
<span class="udiff-line-removed">-   // annul LDX if branch is not taken to prevent access past end of string</span>
<span class="udiff-line-removed">-   br(Assembler::greaterEqual, true, Assembler::pt, Lloop);</span>
<span class="udiff-line-removed">-   delayed()-&gt;ldx(src, 0, tmp1);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Fallback to slow version</span>
<span class="udiff-line-removed">-   bind(Lslow);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- // Compress char[] to byte[]. Return 0 on failure.</span>
<span class="udiff-line-removed">- void MacroAssembler::string_compress(Register src, Register dst, Register cnt, Register result, Register tmp, Label&amp; Ldone) {</span>
<span class="udiff-line-removed">-   Label Lloop;</span>
<span class="udiff-line-removed">-   assert_different_registers(src, dst, cnt, tmp, result);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   lduh(src, 0, tmp);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   bind(Lloop);</span>
<span class="udiff-line-removed">-   inc(src, sizeof(jchar));</span>
<span class="udiff-line-removed">-   cmp(tmp, 0xff);</span>
<span class="udiff-line-removed">-   // annul zeroing if branch is not taken to preserve original count</span>
<span class="udiff-line-removed">-   br(Assembler::greater, true, Assembler::pn, Ldone); // don&#39;t check xcc</span>
<span class="udiff-line-removed">-   delayed()-&gt;mov(G0, result); // 0 - failed</span>
<span class="udiff-line-removed">-   deccc(cnt);</span>
<span class="udiff-line-removed">-   stb(tmp, dst, 0);</span>
<span class="udiff-line-removed">-   inc(dst);</span>
<span class="udiff-line-removed">-   // annul LDUH if branch is not taken to prevent access past end of string</span>
<span class="udiff-line-removed">-   br(Assembler::notZero, true, Assembler::pt, Lloop);</span>
<span class="udiff-line-removed">-   delayed()-&gt;lduh(src, 0, tmp); // hoisted</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- // Inflate byte[] to char[] by inflating 16 bytes at once.</span>
<span class="udiff-line-removed">- void MacroAssembler::string_inflate_16(Register src, Register dst, Register cnt, Register tmp,</span>
<span class="udiff-line-removed">-                                        FloatRegister ftmp1, FloatRegister ftmp2, FloatRegister ftmp3, FloatRegister ftmp4, Label&amp; Ldone) {</span>
<span class="udiff-line-removed">-   Label Lloop, Lslow;</span>
<span class="udiff-line-removed">-   assert(UseVIS &gt;= 3, &quot;VIS3 is required&quot;);</span>
<span class="udiff-line-removed">-   assert_different_registers(src, dst, cnt, tmp);</span>
<span class="udiff-line-removed">-   assert_different_registers(ftmp1, ftmp2, ftmp3, ftmp4);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Check if cnt &gt;= 8 (= 16 bytes)</span>
<span class="udiff-line-removed">-   cmp(cnt, 8);</span>
<span class="udiff-line-removed">-   br(Assembler::less, false, Assembler::pn, Lslow);</span>
<span class="udiff-line-removed">-   delayed()-&gt;nop();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Check for 8-byte alignment of src and dst</span>
<span class="udiff-line-removed">-   or3(src, dst, tmp);</span>
<span class="udiff-line-removed">-   andcc(tmp, 7, G0);</span>
<span class="udiff-line-removed">-   br(Assembler::notZero, false, Assembler::pn, Lslow);</span>
<span class="udiff-line-removed">-   // Initialize float register to zero</span>
<span class="udiff-line-removed">-   FloatRegister zerof = ftmp4;</span>
<span class="udiff-line-removed">-   delayed()-&gt;fzero(FloatRegisterImpl::D, zerof);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Load first 8 bytes</span>
<span class="udiff-line-removed">-   ldf(FloatRegisterImpl::D, src, 0, ftmp1);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   bind(Lloop);</span>
<span class="udiff-line-removed">-   inc(src, 8);</span>
<span class="udiff-line-removed">-   dec(cnt, 8);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Inflate the string by interleaving each byte from the source array</span>
<span class="udiff-line-removed">-   // with a zero byte and storing the result in the destination array.</span>
<span class="udiff-line-removed">-   fpmerge(zerof, ftmp1-&gt;successor(), ftmp2);</span>
<span class="udiff-line-removed">-   stf(FloatRegisterImpl::D, ftmp2, dst, 8);</span>
<span class="udiff-line-removed">-   fpmerge(zerof, ftmp1, ftmp3);</span>
<span class="udiff-line-removed">-   stf(FloatRegisterImpl::D, ftmp3, dst, 0);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   inc(dst, 16);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   cmp(cnt, 8);</span>
<span class="udiff-line-removed">-   // annul LDX if branch is not taken to prevent access past end of string</span>
<span class="udiff-line-removed">-   br(Assembler::greaterEqual, true, Assembler::pt, Lloop);</span>
<span class="udiff-line-removed">-   delayed()-&gt;ldf(FloatRegisterImpl::D, src, 0, ftmp1);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Fallback to slow version</span>
<span class="udiff-line-removed">-   bind(Lslow);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- // Inflate byte[] to char[].</span>
<span class="udiff-line-removed">- void MacroAssembler::string_inflate(Register src, Register dst, Register cnt, Register tmp, Label&amp; Ldone) {</span>
<span class="udiff-line-removed">-   Label Loop;</span>
<span class="udiff-line-removed">-   assert_different_registers(src, dst, cnt, tmp);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   ldub(src, 0, tmp);</span>
<span class="udiff-line-removed">-   bind(Loop);</span>
<span class="udiff-line-removed">-   inc(src);</span>
<span class="udiff-line-removed">-   deccc(cnt);</span>
<span class="udiff-line-removed">-   sth(tmp, dst, 0);</span>
<span class="udiff-line-removed">-   inc(dst, sizeof(jchar));</span>
<span class="udiff-line-removed">-   // annul LDUB if branch is not taken to prevent access past end of string</span>
<span class="udiff-line-removed">-   br(Assembler::notZero, true, Assembler::pt, Loop);</span>
<span class="udiff-line-removed">-   delayed()-&gt;ldub(src, 0, tmp); // hoisted</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void MacroAssembler::string_compare(Register str1, Register str2,</span>
<span class="udiff-line-removed">-                                     Register cnt1, Register cnt2,</span>
<span class="udiff-line-removed">-                                     Register tmp1, Register tmp2,</span>
<span class="udiff-line-removed">-                                     Register result, int ae) {</span>
<span class="udiff-line-removed">-   Label Ldone, Lloop;</span>
<span class="udiff-line-removed">-   assert_different_registers(str1, str2, cnt1, cnt2, tmp1, result);</span>
<span class="udiff-line-removed">-   int stride1, stride2;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Note: Making use of the fact that compareTo(a, b) == -compareTo(b, a)</span>
<span class="udiff-line-removed">-   // we interchange str1 and str2 in the UL case and negate the result.</span>
<span class="udiff-line-removed">-   // Like this, str1 is always latin1 encoded, expect for the UU case.</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (ae == StrIntrinsicNode::LU || ae == StrIntrinsicNode::UL) {</span>
<span class="udiff-line-removed">-     srl(cnt2, 1, cnt2);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // See if the lengths are different, and calculate min in cnt1.</span>
<span class="udiff-line-removed">-   // Save diff in case we need it for a tie-breaker.</span>
<span class="udiff-line-removed">-   Label Lskip;</span>
<span class="udiff-line-removed">-   Register diff = tmp1;</span>
<span class="udiff-line-removed">-   subcc(cnt1, cnt2, diff);</span>
<span class="udiff-line-removed">-   br(Assembler::greater, true, Assembler::pt, Lskip);</span>
<span class="udiff-line-removed">-   // cnt2 is shorter, so use its count:</span>
<span class="udiff-line-removed">-   delayed()-&gt;mov(cnt2, cnt1);</span>
<span class="udiff-line-removed">-   bind(Lskip);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Rename registers</span>
<span class="udiff-line-removed">-   Register limit1 = cnt1;</span>
<span class="udiff-line-removed">-   Register limit2 = limit1;</span>
<span class="udiff-line-removed">-   Register chr1   = result;</span>
<span class="udiff-line-removed">-   Register chr2   = cnt2;</span>
<span class="udiff-line-removed">-   if (ae == StrIntrinsicNode::LU || ae == StrIntrinsicNode::UL) {</span>
<span class="udiff-line-removed">-     // We need an additional register to keep track of two limits</span>
<span class="udiff-line-removed">-     assert_different_registers(str1, str2, cnt1, cnt2, tmp1, tmp2, result);</span>
<span class="udiff-line-removed">-     limit2 = tmp2;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Is the minimum length zero?</span>
<span class="udiff-line-removed">-   cmp(limit1, (int)0); // use cast to resolve overloading ambiguity</span>
<span class="udiff-line-removed">-   br(Assembler::equal, true, Assembler::pn, Ldone);</span>
<span class="udiff-line-removed">-   // result is difference in lengths</span>
<span class="udiff-line-removed">-   if (ae == StrIntrinsicNode::UU) {</span>
<span class="udiff-line-removed">-     delayed()-&gt;sra(diff, 1, result);  // Divide by 2 to get number of chars</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     delayed()-&gt;mov(diff, result);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Load first characters</span>
<span class="udiff-line-removed">-   if (ae == StrIntrinsicNode::LL) {</span>
<span class="udiff-line-removed">-     stride1 = stride2 = sizeof(jbyte);</span>
<span class="udiff-line-removed">-     ldub(str1, 0, chr1);</span>
<span class="udiff-line-removed">-     ldub(str2, 0, chr2);</span>
<span class="udiff-line-removed">-   } else if (ae == StrIntrinsicNode::UU) {</span>
<span class="udiff-line-removed">-     stride1 = stride2 = sizeof(jchar);</span>
<span class="udiff-line-removed">-     lduh(str1, 0, chr1);</span>
<span class="udiff-line-removed">-     lduh(str2, 0, chr2);</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     stride1 = sizeof(jbyte);</span>
<span class="udiff-line-removed">-     stride2 = sizeof(jchar);</span>
<span class="udiff-line-removed">-     ldub(str1, 0, chr1);</span>
<span class="udiff-line-removed">-     lduh(str2, 0, chr2);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Compare first characters</span>
<span class="udiff-line-removed">-   subcc(chr1, chr2, chr1);</span>
<span class="udiff-line-removed">-   br(Assembler::notZero, false, Assembler::pt, Ldone);</span>
<span class="udiff-line-removed">-   assert(chr1 == result, &quot;result must be pre-placed&quot;);</span>
<span class="udiff-line-removed">-   delayed()-&gt;nop();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Check if the strings start at same location</span>
<span class="udiff-line-removed">-   cmp(str1, str2);</span>
<span class="udiff-line-removed">-   brx(Assembler::equal, true, Assembler::pn, Ldone);</span>
<span class="udiff-line-removed">-   delayed()-&gt;mov(G0, result);  // result is zero</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // We have no guarantee that on 64 bit the higher half of limit is 0</span>
<span class="udiff-line-removed">-   signx(limit1);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Get limit</span>
<span class="udiff-line-removed">-   if (ae == StrIntrinsicNode::LU || ae == StrIntrinsicNode::UL) {</span>
<span class="udiff-line-removed">-     sll(limit1, 1, limit2);</span>
<span class="udiff-line-removed">-     subcc(limit2, stride2, chr2);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   subcc(limit1, stride1, chr1);</span>
<span class="udiff-line-removed">-   br(Assembler::zero, true, Assembler::pn, Ldone);</span>
<span class="udiff-line-removed">-   // result is difference in lengths</span>
<span class="udiff-line-removed">-   if (ae == StrIntrinsicNode::UU) {</span>
<span class="udiff-line-removed">-     delayed()-&gt;sra(diff, 1, result);  // Divide by 2 to get number of chars</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     delayed()-&gt;mov(diff, result);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Shift str1 and str2 to the end of the arrays, negate limit</span>
<span class="udiff-line-removed">-   add(str1, limit1, str1);</span>
<span class="udiff-line-removed">-   add(str2, limit2, str2);</span>
<span class="udiff-line-removed">-   neg(chr1, limit1);  // limit1 = -(limit1-stride1)</span>
<span class="udiff-line-removed">-   if (ae == StrIntrinsicNode::LU || ae == StrIntrinsicNode::UL) {</span>
<span class="udiff-line-removed">-     neg(chr2, limit2);  // limit2 = -(limit2-stride2)</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Compare the rest of the characters</span>
<span class="udiff-line-removed">-   load_sized_value(Address(str1, limit1), chr1, (ae == StrIntrinsicNode::UU) ? 2 : 1, false);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   bind(Lloop);</span>
<span class="udiff-line-removed">-   load_sized_value(Address(str2, limit2), chr2, (ae == StrIntrinsicNode::LL) ? 1 : 2, false);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   subcc(chr1, chr2, chr1);</span>
<span class="udiff-line-removed">-   br(Assembler::notZero, false, Assembler::pt, Ldone);</span>
<span class="udiff-line-removed">-   assert(chr1 == result, &quot;result must be pre-placed&quot;);</span>
<span class="udiff-line-removed">-   delayed()-&gt;inccc(limit1, stride1);</span>
<span class="udiff-line-removed">-   if (ae == StrIntrinsicNode::LU || ae == StrIntrinsicNode::UL) {</span>
<span class="udiff-line-removed">-     inccc(limit2, stride2);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // annul LDUB if branch is not taken to prevent access past end of string</span>
<span class="udiff-line-removed">-   br(Assembler::notZero, true, Assembler::pt, Lloop);</span>
<span class="udiff-line-removed">-   delayed()-&gt;load_sized_value(Address(str1, limit1), chr1, (ae == StrIntrinsicNode::UU) ? 2 : 1, false);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // If strings are equal up to min length, return the length difference.</span>
<span class="udiff-line-removed">-   if (ae == StrIntrinsicNode::UU) {</span>
<span class="udiff-line-removed">-     // Divide by 2 to get number of chars</span>
<span class="udiff-line-removed">-     sra(diff, 1, result);</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     mov(diff, result);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Otherwise, return the difference between the first mismatched chars.</span>
<span class="udiff-line-removed">-   bind(Ldone);</span>
<span class="udiff-line-removed">-   if(ae == StrIntrinsicNode::UL) {</span>
<span class="udiff-line-removed">-     // Negate result (see note above)</span>
<span class="udiff-line-removed">-     neg(result);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void MacroAssembler::array_equals(bool is_array_equ, Register ary1, Register ary2,</span>
<span class="udiff-line-removed">-                                   Register limit, Register tmp, Register result, bool is_byte) {</span>
<span class="udiff-line-removed">-   Label Ldone, Lloop, Lremaining;</span>
<span class="udiff-line-removed">-   assert_different_registers(ary1, ary2, limit, tmp, result);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   int length_offset  = arrayOopDesc::length_offset_in_bytes();</span>
<span class="udiff-line-removed">-   int base_offset    = arrayOopDesc::base_offset_in_bytes(is_byte ? T_BYTE : T_CHAR);</span>
<span class="udiff-line-removed">-   assert(base_offset % 8 == 0, &quot;Base offset must be 8-byte aligned&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (is_array_equ) {</span>
<span class="udiff-line-removed">-     // return true if the same array</span>
<span class="udiff-line-removed">-     cmp(ary1, ary2);</span>
<span class="udiff-line-removed">-     brx(Assembler::equal, true, Assembler::pn, Ldone);</span>
<span class="udiff-line-removed">-     delayed()-&gt;mov(1, result);  // equal</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     br_null(ary1, true, Assembler::pn, Ldone);</span>
<span class="udiff-line-removed">-     delayed()-&gt;clr(result);     // not equal</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     br_null(ary2, true, Assembler::pn, Ldone);</span>
<span class="udiff-line-removed">-     delayed()-&gt;clr(result);     // not equal</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // load the lengths of arrays</span>
<span class="udiff-line-removed">-     ld(Address(ary1, length_offset), limit);</span>
<span class="udiff-line-removed">-     ld(Address(ary2, length_offset), tmp);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // return false if the two arrays are not equal length</span>
<span class="udiff-line-removed">-     cmp(limit, tmp);</span>
<span class="udiff-line-removed">-     br(Assembler::notEqual, true, Assembler::pn, Ldone);</span>
<span class="udiff-line-removed">-     delayed()-&gt;clr(result);     // not equal</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   cmp_zero_and_br(Assembler::zero, limit, Ldone, true, Assembler::pn);</span>
<span class="udiff-line-removed">-   delayed()-&gt;mov(1, result); // zero-length arrays are equal</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (is_array_equ) {</span>
<span class="udiff-line-removed">-     // load array addresses</span>
<span class="udiff-line-removed">-     add(ary1, base_offset, ary1);</span>
<span class="udiff-line-removed">-     add(ary2, base_offset, ary2);</span>
<span class="udiff-line-removed">-     // set byte count</span>
<span class="udiff-line-removed">-     if (!is_byte) {</span>
<span class="udiff-line-removed">-       sll(limit, exact_log2(sizeof(jchar)), limit);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     // We have no guarantee that on 64 bit the higher half of limit is 0</span>
<span class="udiff-line-removed">-     signx(limit);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #ifdef ASSERT</span>
<span class="udiff-line-removed">-   // Sanity check for doubleword (8-byte) alignment of ary1 and ary2.</span>
<span class="udiff-line-removed">-   // Guaranteed on 64-bit systems (see arrayOopDesc::header_size_in_bytes()).</span>
<span class="udiff-line-removed">-   Label Laligned;</span>
<span class="udiff-line-removed">-   or3(ary1, ary2, tmp);</span>
<span class="udiff-line-removed">-   andcc(tmp, 7, tmp);</span>
<span class="udiff-line-removed">-   br_null_short(tmp, Assembler::pn, Laligned);</span>
<span class="udiff-line-removed">-   STOP(&quot;First array element is not 8-byte aligned.&quot;);</span>
<span class="udiff-line-removed">-   should_not_reach_here();</span>
<span class="udiff-line-removed">-   bind(Laligned);</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Shift ary1 and ary2 to the end of the arrays, negate limit</span>
<span class="udiff-line-removed">-   add(ary1, limit, ary1);</span>
<span class="udiff-line-removed">-   add(ary2, limit, ary2);</span>
<span class="udiff-line-removed">-   neg(limit, limit);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // MAIN LOOP</span>
<span class="udiff-line-removed">-   // Load and compare array elements of size &#39;byte_width&#39; until the elements are not</span>
<span class="udiff-line-removed">-   // equal or we reached the end of the arrays. If the size of the arrays is not a</span>
<span class="udiff-line-removed">-   // multiple of &#39;byte_width&#39;, we simply read over the end of the array, bail out and</span>
<span class="udiff-line-removed">-   // compare the remaining bytes below by skipping the garbage bytes.</span>
<span class="udiff-line-removed">-   ldx(ary1, limit, result);</span>
<span class="udiff-line-removed">-   bind(Lloop);</span>
<span class="udiff-line-removed">-   ldx(ary2, limit, tmp);</span>
<span class="udiff-line-removed">-   inccc(limit, 8);</span>
<span class="udiff-line-removed">-   // Bail out if we reached the end (but still do the comparison)</span>
<span class="udiff-line-removed">-   br(Assembler::positive, false, Assembler::pn, Lremaining);</span>
<span class="udiff-line-removed">-   delayed()-&gt;cmp(result, tmp);</span>
<span class="udiff-line-removed">-   // Check equality of elements</span>
<span class="udiff-line-removed">-   brx(Assembler::equal, false, Assembler::pt, target(Lloop));</span>
<span class="udiff-line-removed">-   delayed()-&gt;ldx(ary1, limit, result);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   ba(Ldone);</span>
<span class="udiff-line-removed">-   delayed()-&gt;clr(result); // not equal</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // TAIL COMPARISON</span>
<span class="udiff-line-removed">-   // We got here because we reached the end of the arrays. &#39;limit&#39; is the number of</span>
<span class="udiff-line-removed">-   // garbage bytes we may have compared by reading over the end of the arrays. Shift</span>
<span class="udiff-line-removed">-   // out the garbage and compare the remaining elements.</span>
<span class="udiff-line-removed">-   bind(Lremaining);</span>
<span class="udiff-line-removed">-   // Optimistic shortcut: elements potentially including garbage are equal</span>
<span class="udiff-line-removed">-   brx(Assembler::equal, true, Assembler::pt, target(Ldone));</span>
<span class="udiff-line-removed">-   delayed()-&gt;mov(1, result); // equal</span>
<span class="udiff-line-removed">-   // Shift &#39;limit&#39; bytes to the right and compare</span>
<span class="udiff-line-removed">-   sll(limit, 3, limit); // bytes to bits</span>
<span class="udiff-line-removed">-   srlx(result, limit, result);</span>
<span class="udiff-line-removed">-   srlx(tmp, limit, tmp);</span>
<span class="udiff-line-removed">-   cmp(result, tmp);</span>
<span class="udiff-line-removed">-   clr(result);</span>
<span class="udiff-line-removed">-   movcc(Assembler::equal, false, xcc, 1, result);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   bind(Ldone);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void MacroAssembler::has_negatives(Register inp, Register size, Register result, Register t2, Register t3, Register t4, Register t5) {</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // test for negative bytes in input string of a given size</span>
<span class="udiff-line-removed">-   // result 1 if found, 0 otherwise.</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   Label Lcore, Ltail, Lreturn, Lcore_rpt;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   assert_different_registers(inp, size, t2, t3, t4, t5, result);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   Register i     = result;  // result used as integer index i until very end</span>
<span class="udiff-line-removed">-   Register lmask = t2;      // t2 is aliased to lmask</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // INITIALIZATION</span>
<span class="udiff-line-removed">-   // ===========================================================</span>
<span class="udiff-line-removed">-   // initialize highbits mask -&gt; lmask = 0x8080808080808080  (8B/64b)</span>
<span class="udiff-line-removed">-   // compute unaligned offset -&gt; i</span>
<span class="udiff-line-removed">-   // compute core end index   -&gt; t5</span>
<span class="udiff-line-removed">-   Assembler::sethi(0x80808000, t2);   //! sethi macro fails to emit optimal</span>
<span class="udiff-line-removed">-   add(t2, 0x80, t2);</span>
<span class="udiff-line-removed">-   sllx(t2, 32, t3);</span>
<span class="udiff-line-removed">-   or3(t3, t2, lmask);                 // 0x8080808080808080 -&gt; lmask</span>
<span class="udiff-line-removed">-   sra(size,0,size);</span>
<span class="udiff-line-removed">-   andcc(inp, 0x7, i);                 // unaligned offset -&gt; i</span>
<span class="udiff-line-removed">-   br(Assembler::zero, true, Assembler::pn, Lcore); // starts 8B aligned?</span>
<span class="udiff-line-removed">-   delayed()-&gt;add(size, -8, t5);       // (annuled) core end index -&gt; t5</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // ===========================================================</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // UNALIGNED HEAD</span>
<span class="udiff-line-removed">-   // ===========================================================</span>
<span class="udiff-line-removed">-   // * unaligned head handling: grab aligned 8B containing unaligned inp(ut)</span>
<span class="udiff-line-removed">-   // * obliterate (ignore) bytes outside string by shifting off reg ends</span>
<span class="udiff-line-removed">-   // * compare with bitmask, short circuit return true if one or more high</span>
<span class="udiff-line-removed">-   //   bits set.</span>
<span class="udiff-line-removed">-   cmp(size, 0);</span>
<span class="udiff-line-removed">-   br(Assembler::zero, true, Assembler::pn, Lreturn); // short-circuit?</span>
<span class="udiff-line-removed">-   delayed()-&gt;mov(0,result);      // annuled so i not clobbered for following</span>
<span class="udiff-line-removed">-   neg(i, t4);</span>
<span class="udiff-line-removed">-   add(i, size, t5);</span>
<span class="udiff-line-removed">-   ldx(inp, t4, t3);  // raw aligned 8B containing unaligned head -&gt; t3</span>
<span class="udiff-line-removed">-   mov(8, t4);</span>
<span class="udiff-line-removed">-   sub(t4, t5, t4);</span>
<span class="udiff-line-removed">-   sra(t4, 31, t5);</span>
<span class="udiff-line-removed">-   andn(t4, t5, t5);</span>
<span class="udiff-line-removed">-   add(i, t5, t4);</span>
<span class="udiff-line-removed">-   sll(t5, 3, t5);</span>
<span class="udiff-line-removed">-   sll(t4, 3, t4);   // # bits to shift right, left -&gt; t5,t4</span>
<span class="udiff-line-removed">-   srlx(t3, t5, t3);</span>
<span class="udiff-line-removed">-   sllx(t3, t4, t3); // bytes outside string in 8B header obliterated -&gt; t3</span>
<span class="udiff-line-removed">-   andcc(lmask, t3, G0);</span>
<span class="udiff-line-removed">-   brx(Assembler::notZero, true, Assembler::pn, Lreturn); // short circuit?</span>
<span class="udiff-line-removed">-   delayed()-&gt;mov(1,result);      // annuled so i not clobbered for following</span>
<span class="udiff-line-removed">-   add(size, -8, t5);             // core end index -&gt; t5</span>
<span class="udiff-line-removed">-   mov(8, t4);</span>
<span class="udiff-line-removed">-   sub(t4, i, i);                 // # bytes examined in unalgn head (&lt;8) -&gt; i</span>
<span class="udiff-line-removed">-   // ===========================================================</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // ALIGNED CORE</span>
<span class="udiff-line-removed">-   // ===========================================================</span>
<span class="udiff-line-removed">-   // * iterate index i over aligned 8B sections of core, comparing with</span>
<span class="udiff-line-removed">-   //   bitmask, short circuit return true if one or more high bits set</span>
<span class="udiff-line-removed">-   // t5 contains core end index/loop limit which is the index</span>
<span class="udiff-line-removed">-   //     of the MSB of last (unaligned) 8B fully contained in the string.</span>
<span class="udiff-line-removed">-   // inp   contains address of first byte in string/array</span>
<span class="udiff-line-removed">-   // lmask contains 8B high bit mask for comparison</span>
<span class="udiff-line-removed">-   // i     contains next index to be processed (adr. inp+i is on 8B boundary)</span>
<span class="udiff-line-removed">-   bind(Lcore);</span>
<span class="udiff-line-removed">-   cmp_and_br_short(i, t5, Assembler::greater, Assembler::pn, Ltail);</span>
<span class="udiff-line-removed">-   bind(Lcore_rpt);</span>
<span class="udiff-line-removed">-   ldx(inp, i, t3);</span>
<span class="udiff-line-removed">-   andcc(t3, lmask, G0);</span>
<span class="udiff-line-removed">-   brx(Assembler::notZero, true, Assembler::pn, Lreturn);</span>
<span class="udiff-line-removed">-   delayed()-&gt;mov(1, result);    // annuled so i not clobbered for following</span>
<span class="udiff-line-removed">-   add(i, 8, i);</span>
<span class="udiff-line-removed">-   cmp_and_br_short(i, t5, Assembler::lessEqual, Assembler::pn, Lcore_rpt);</span>
<span class="udiff-line-removed">-   // ===========================================================</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // ALIGNED TAIL (&lt;8B)</span>
<span class="udiff-line-removed">-   // ===========================================================</span>
<span class="udiff-line-removed">-   // handle aligned tail of 7B or less as complete 8B, obliterating end of</span>
<span class="udiff-line-removed">-   // string bytes by shifting them off end, compare what&#39;s left with bitmask</span>
<span class="udiff-line-removed">-   // inp   contains address of first byte in string/array</span>
<span class="udiff-line-removed">-   // lmask contains 8B high bit mask for comparison</span>
<span class="udiff-line-removed">-   // i     contains next index to be processed (adr. inp+i is on 8B boundary)</span>
<span class="udiff-line-removed">-   bind(Ltail);</span>
<span class="udiff-line-removed">-   subcc(size, i, t4);   // # of remaining bytes in string -&gt; t4</span>
<span class="udiff-line-removed">-   // return 0 if no more remaining bytes</span>
<span class="udiff-line-removed">-   br(Assembler::lessEqual, true, Assembler::pn, Lreturn);</span>
<span class="udiff-line-removed">-   delayed()-&gt;mov(0, result); // annuled so i not clobbered for following</span>
<span class="udiff-line-removed">-   ldx(inp, i, t3);       // load final 8B (aligned) containing tail -&gt; t3</span>
<span class="udiff-line-removed">-   mov(8, t5);</span>
<span class="udiff-line-removed">-   sub(t5, t4, t4);</span>
<span class="udiff-line-removed">-   mov(0, result);        // ** i clobbered at this point</span>
<span class="udiff-line-removed">-   sll(t4, 3, t4);        // bits beyond end of string          -&gt; t4</span>
<span class="udiff-line-removed">-   srlx(t3, t4, t3);      // bytes beyond end now obliterated   -&gt; t3</span>
<span class="udiff-line-removed">-   andcc(lmask, t3, G0);</span>
<span class="udiff-line-removed">-   movcc(Assembler::notZero, false, xcc,  1, result);</span>
<span class="udiff-line-removed">-   bind(Lreturn);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- </span>
  // Use BIS for zeroing (count is in bytes).
  void MacroAssembler::bis_zeroing(Register to, Register count, Register temp, Label&amp; Ldone) {
    assert(UseBlockZeroing &amp;&amp; VM_Version::has_blk_zeroing(), &quot;only works with BIS zeroing&quot;);
    Register end = count;
    int cache_line_size = VM_Version::prefetch_data_size();
</pre>
<center><a href="interp_masm_sparc.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_sparc.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
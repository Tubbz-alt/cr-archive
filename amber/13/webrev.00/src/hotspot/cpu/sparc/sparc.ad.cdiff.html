<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/cpu/sparc/sparc.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="sharedRuntime_sparc.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="templateTable_sparc.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/sparc/sparc.ad</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  //
<span class="line-modified">! // Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  //
  // This code is free software; you can redistribute it and/or modify it
  // under the terms of the GNU General Public License version 2 only, as
  // published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  //
<span class="line-modified">! // Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  //
  // This code is free software; you can redistribute it and/or modify it
  // under the terms of the GNU General Public License version 2 only, as
  // published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 469,10 ***</span>
<span class="line-new-header">--- 469,17 ---</span>
    static uint size_deopt_handler() {
      return ( 4+  NativeJump::instruction_size ); // save;sethi;jmp;restore
    }
  };
  
<span class="line-added">+ class Node::PD {</span>
<span class="line-added">+ public:</span>
<span class="line-added">+   enum NodeFlags {</span>
<span class="line-added">+     _last_flag = Node::_last_flag</span>
<span class="line-added">+   };</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
  %}
  
  source %{
  #define __ _masm.
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 481,10 ***</span>
<span class="line-new-header">--- 488,21 ---</span>
  
  static FloatRegister reg_to_SingleFloatRegister_object(int register_encoding);
  static FloatRegister reg_to_DoubleFloatRegister_object(int register_encoding);
  static Register reg_to_register_object(int register_encoding);
  
<span class="line-added">+ void PhaseOutput::pd_perform_mach_node_analysis() {</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ int MachNode::pd_alignment_required() const {</span>
<span class="line-added">+   return 1;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ int MachNode::compute_padding(int current_offset) const {</span>
<span class="line-added">+   return 0;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  // Used by the DFA in dfa_sparc.cpp.
  // Check for being able to use a V9 branch-on-register.  Requires a
  // compare-vs-zero, equal/not-equal, of a value which was zero- or sign-
  // extended.  Doesn&#39;t work following an integer ADD, for example, because of
  // overflow (-1 incremented yields 0 plus a carry in the high-order word).  On
</pre>
<hr />
<pre>
<span class="line-old-header">*** 590,11 ***</span>
    return true;
  }
  
  // emit an interrupt that is caught by the debugger (for debugging compiler)
  void emit_break(CodeBuffer &amp;cbuf) {
<span class="line-modified">!   MacroAssembler _masm(&amp;cbuf);</span>
    __ breakpoint_trap();
  }
  
  #ifndef PRODUCT
  void MachBreakpointNode::format( PhaseRegAlloc *, outputStream *st ) const {
<span class="line-new-header">--- 608,11 ---</span>
    return true;
  }
  
  // emit an interrupt that is caught by the debugger (for debugging compiler)
  void emit_break(CodeBuffer &amp;cbuf) {
<span class="line-modified">!   C2_MacroAssembler _masm(&amp;cbuf);</span>
    __ breakpoint_trap();
  }
  
  #ifndef PRODUCT
  void MachBreakpointNode::format( PhaseRegAlloc *, outputStream *st ) const {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 610,31 ***</span>
    return MachNode::size(ra_);
  }
  
  // Traceable jump
  void  emit_jmpl(CodeBuffer &amp;cbuf, int jump_target) {
<span class="line-modified">!   MacroAssembler _masm(&amp;cbuf);</span>
    Register rdest = reg_to_register_object(jump_target);
    __ JMP(rdest, 0);
    __ delayed()-&gt;nop();
  }
  
  // Traceable jump and set exception pc
  void  emit_jmpl_set_exception_pc(CodeBuffer &amp;cbuf, int jump_target) {
<span class="line-modified">!   MacroAssembler _masm(&amp;cbuf);</span>
    Register rdest = reg_to_register_object(jump_target);
    __ JMP(rdest, 0);
    __ delayed()-&gt;add(O7, frame::pc_return_offset, Oissuing_pc );
  }
  
  void emit_nop(CodeBuffer &amp;cbuf) {
<span class="line-modified">!   MacroAssembler _masm(&amp;cbuf);</span>
    __ nop();
  }
  
  void emit_illtrap(CodeBuffer &amp;cbuf) {
<span class="line-modified">!   MacroAssembler _masm(&amp;cbuf);</span>
    __ illtrap(0);
  }
  
  
  intptr_t get_offset_from_base(const MachNode* n, const TypePtr* atype, int disp32) {
<span class="line-new-header">--- 628,31 ---</span>
    return MachNode::size(ra_);
  }
  
  // Traceable jump
  void  emit_jmpl(CodeBuffer &amp;cbuf, int jump_target) {
<span class="line-modified">!   C2_MacroAssembler _masm(&amp;cbuf);</span>
    Register rdest = reg_to_register_object(jump_target);
    __ JMP(rdest, 0);
    __ delayed()-&gt;nop();
  }
  
  // Traceable jump and set exception pc
  void  emit_jmpl_set_exception_pc(CodeBuffer &amp;cbuf, int jump_target) {
<span class="line-modified">!   C2_MacroAssembler _masm(&amp;cbuf);</span>
    Register rdest = reg_to_register_object(jump_target);
    __ JMP(rdest, 0);
    __ delayed()-&gt;add(O7, frame::pc_return_offset, Oissuing_pc );
  }
  
  void emit_nop(CodeBuffer &amp;cbuf) {
<span class="line-modified">!   C2_MacroAssembler _masm(&amp;cbuf);</span>
    __ nop();
  }
  
  void emit_illtrap(CodeBuffer &amp;cbuf) {
<span class="line-modified">!   C2_MacroAssembler _masm(&amp;cbuf);</span>
    __ illtrap(0);
  }
  
  
  intptr_t get_offset_from_base(const MachNode* n, const TypePtr* atype, int disp32) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 906,11 ***</span>
  
    if (src1_enc == R_SP_enc || src1_enc == R_FP_enc) {
      disp += STACK_BIAS;
      // Check that stack offset fits, load into O7 if not
      if (!Assembler::is_simm13(disp)) {
<span class="line-modified">!       MacroAssembler _masm(&amp;cbuf);</span>
        __ set(disp, O7);
        if (index != R_G0_enc) {
          __ add(O7, reg_to_register_object(index), O7);
        }
        index = R_O7_enc;
<span class="line-new-header">--- 924,11 ---</span>
  
    if (src1_enc == R_SP_enc || src1_enc == R_FP_enc) {
      disp += STACK_BIAS;
      // Check that stack offset fits, load into O7 if not
      if (!Assembler::is_simm13(disp)) {
<span class="line-modified">!       C2_MacroAssembler _masm(&amp;cbuf);</span>
        __ set(disp, O7);
        if (index != R_G0_enc) {
          __ add(O7, reg_to_register_object(index), O7);
        }
        index = R_O7_enc;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 930,11 ***</span>
  
    cbuf.insts()-&gt;emit_int32(instr);
  
  #ifdef ASSERT
    if (VerifyOops) {
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      if (is_verified_oop_base) {
        __ verify_oop(reg_to_register_object(src1_enc));
      }
      if (is_verified_oop_store) {
        __ verify_oop(reg_to_register_object(dst_enc));
<span class="line-new-header">--- 948,11 ---</span>
  
    cbuf.insts()-&gt;emit_int32(instr);
  
  #ifdef ASSERT
    if (VerifyOops) {
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      if (is_verified_oop_base) {
        __ verify_oop(reg_to_register_object(src1_enc));
      }
      if (is_verified_oop_store) {
        __ verify_oop(reg_to_register_object(dst_enc));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 958,11 ***</span>
    // so far.
    // In this particular case we have skirted around the problem by
    // putting the &quot;mov&quot; instruction in the delay slot but the problem
    // may bite us again at some other point and a cleaner/generic
    // solution using relocations would be needed.
<span class="line-modified">!   MacroAssembler _masm(&amp;cbuf);</span>
    __ set_inst_mark();
  
    // We flush the current window just so that there is a valid stack copy
    // the fact that the current window becomes active again instantly is
    // not a problem there is nothing live in it.
<span class="line-new-header">--- 976,11 ---</span>
    // so far.
    // In this particular case we have skirted around the problem by
    // putting the &quot;mov&quot; instruction in the delay slot but the problem
    // may bite us again at some other point and a cleaner/generic
    // solution using relocations would be needed.
<span class="line-modified">!   C2_MacroAssembler _masm(&amp;cbuf);</span>
    __ set_inst_mark();
  
    // We flush the current window just so that there is a valid stack copy
    // the fact that the current window becomes active again instantly is
    // not a problem there is nothing live in it.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1000,11 ***</span>
  
  
  //=============================================================================
  const RegMask&amp; MachConstantBaseNode::_out_RegMask = PTR_REG_mask();
  
<span class="line-modified">! int Compile::ConstantTable::calculate_table_base_offset() const {</span>
    if (UseRDPCForConstantTableBase) {
      // The table base offset might be less but then it fits into
      // simm13 anyway and we are good (cf. MachConstantBaseNode::emit).
      return Assembler::min_simm13();
    } else {
<span class="line-new-header">--- 1018,11 ---</span>
  
  
  //=============================================================================
  const RegMask&amp; MachConstantBaseNode::_out_RegMask = PTR_REG_mask();
  
<span class="line-modified">! int ConstantTable::calculate_table_base_offset() const {</span>
    if (UseRDPCForConstantTableBase) {
      // The table base offset might be less but then it fits into
      // simm13 anyway and we are good (cf. MachConstantBaseNode::emit).
      return Assembler::min_simm13();
    } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1021,12 ***</span>
    ShouldNotReachHere();
  }
  
  void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
    Compile* C = ra_-&gt;C;
<span class="line-modified">!   Compile::ConstantTable&amp; constant_table = C-&gt;constant_table();</span>
<span class="line-modified">!   MacroAssembler _masm(&amp;cbuf);</span>
  
    Register r = as_Register(ra_-&gt;get_encode(this));
    CodeSection* consts_section = __ code()-&gt;consts();
    int consts_size = consts_section-&gt;align_at_start(consts_section-&gt;size());
    assert(constant_table.size() == consts_size, &quot;must be: %d == %d&quot;, constant_table.size(), consts_size);
<span class="line-new-header">--- 1039,12 ---</span>
    ShouldNotReachHere();
  }
  
  void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
    Compile* C = ra_-&gt;C;
<span class="line-modified">!   ConstantTable&amp; constant_table = C-&gt;output()-&gt;constant_table();</span>
<span class="line-modified">!   C2_MacroAssembler _masm(&amp;cbuf);</span>
  
    Register r = as_Register(ra_-&gt;get_encode(this));
    CodeSection* consts_section = __ code()-&gt;consts();
    int consts_size = consts_section-&gt;align_at_start(consts_section-&gt;size());
    assert(constant_table.size() == consts_size, &quot;must be: %d == %d&quot;, constant_table.size(), consts_size);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1126,19 ***</span>
  
    if( VerifyThread ) {
      st-&gt;print_cr(&quot;Verify_Thread&quot;); st-&gt;print(&quot;\t&quot;);
    }
  
<span class="line-modified">!   size_t framesize = C-&gt;frame_size_in_bytes();</span>
<span class="line-modified">!   int bangsize = C-&gt;bang_size_in_bytes();</span>
  
    // Calls to C2R adapters often do not accept exceptional returns.
    // We require that their callers must bang for them.  But be careful, because
    // some VM calls (such as call site linkage) can use several kilobytes of
    // stack.  But the stack safety zone should account for that.
    // See bugs 4446381, 4468289, 4497237.
<span class="line-modified">!   if (C-&gt;need_stack_bang(bangsize)) {</span>
      st-&gt;print_cr(&quot;! stack bang (%d bytes)&quot;, bangsize); st-&gt;print(&quot;\t&quot;);
    }
  
    if (Assembler::is_simm13(-framesize)) {
      st-&gt;print   (&quot;SAVE   R_SP,-&quot; SIZE_FORMAT &quot;,R_SP&quot;,framesize);
<span class="line-new-header">--- 1144,19 ---</span>
  
    if( VerifyThread ) {
      st-&gt;print_cr(&quot;Verify_Thread&quot;); st-&gt;print(&quot;\t&quot;);
    }
  
<span class="line-modified">!   size_t framesize = C-&gt;output()-&gt;frame_size_in_bytes();</span>
<span class="line-modified">!   int bangsize = C-&gt;output()-&gt;bang_size_in_bytes();</span>
  
    // Calls to C2R adapters often do not accept exceptional returns.
    // We require that their callers must bang for them.  But be careful, because
    // some VM calls (such as call site linkage) can use several kilobytes of
    // stack.  But the stack safety zone should account for that.
    // See bugs 4446381, 4468289, 4497237.
<span class="line-modified">!   if (C-&gt;output()-&gt;need_stack_bang(bangsize)) {</span>
      st-&gt;print_cr(&quot;! stack bang (%d bytes)&quot;, bangsize); st-&gt;print(&quot;\t&quot;);
    }
  
    if (Assembler::is_simm13(-framesize)) {
      st-&gt;print   (&quot;SAVE   R_SP,-&quot; SIZE_FORMAT &quot;,R_SP&quot;,framesize);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1151,45 ***</span>
  }
  #endif
  
  void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
    Compile* C = ra_-&gt;C;
<span class="line-modified">!   MacroAssembler _masm(&amp;cbuf);</span>
  
    for (int i = 0; i &lt; OptoPrologueNops; i++) {
      __ nop();
    }
  
    __ verify_thread();
  
<span class="line-modified">!   size_t framesize = C-&gt;frame_size_in_bytes();</span>
    assert(framesize &gt;= 16*wordSize, &quot;must have room for reg. save area&quot;);
    assert(framesize%(2*wordSize) == 0, &quot;must preserve 2*wordSize alignment&quot;);
<span class="line-modified">!   int bangsize = C-&gt;bang_size_in_bytes();</span>
  
    // Calls to C2R adapters often do not accept exceptional returns.
    // We require that their callers must bang for them.  But be careful, because
    // some VM calls (such as call site linkage) can use several kilobytes of
    // stack.  But the stack safety zone should account for that.
    // See bugs 4446381, 4468289, 4497237.
<span class="line-modified">!   if (C-&gt;need_stack_bang(bangsize)) {</span>
      __ generate_stack_overflow_check(bangsize);
    }
  
    if (Assembler::is_simm13(-framesize)) {
      __ save(SP, -framesize, SP);
    } else {
      __ sethi(-framesize &amp; ~0x3ff, G3);
      __ add(G3, -framesize &amp; 0x3ff, G3);
      __ save(SP, G3, SP);
    }
<span class="line-modified">!   C-&gt;set_frame_complete( __ offset() );</span>
  
    if (!UseRDPCForConstantTableBase &amp;&amp; C-&gt;has_mach_constant_base_node()) {
      // NOTE: We set the table base offset here because users might be
      // emitted before MachConstantBaseNode.
<span class="line-modified">!     Compile::ConstantTable&amp; constant_table = C-&gt;constant_table();</span>
      constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
    }
  }
  
  uint MachPrologNode::size(PhaseRegAlloc *ra_) const {
<span class="line-new-header">--- 1169,45 ---</span>
  }
  #endif
  
  void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
    Compile* C = ra_-&gt;C;
<span class="line-modified">!   C2_MacroAssembler _masm(&amp;cbuf);</span>
  
    for (int i = 0; i &lt; OptoPrologueNops; i++) {
      __ nop();
    }
  
    __ verify_thread();
  
<span class="line-modified">!   size_t framesize = C-&gt;output()-&gt;frame_size_in_bytes();</span>
    assert(framesize &gt;= 16*wordSize, &quot;must have room for reg. save area&quot;);
    assert(framesize%(2*wordSize) == 0, &quot;must preserve 2*wordSize alignment&quot;);
<span class="line-modified">!   int bangsize = C-&gt;output()-&gt;bang_size_in_bytes();</span>
  
    // Calls to C2R adapters often do not accept exceptional returns.
    // We require that their callers must bang for them.  But be careful, because
    // some VM calls (such as call site linkage) can use several kilobytes of
    // stack.  But the stack safety zone should account for that.
    // See bugs 4446381, 4468289, 4497237.
<span class="line-modified">!   if (C-&gt;output()-&gt;need_stack_bang(bangsize)) {</span>
      __ generate_stack_overflow_check(bangsize);
    }
  
    if (Assembler::is_simm13(-framesize)) {
      __ save(SP, -framesize, SP);
    } else {
      __ sethi(-framesize &amp; ~0x3ff, G3);
      __ add(G3, -framesize &amp; 0x3ff, G3);
      __ save(SP, G3, SP);
    }
<span class="line-modified">!   C-&gt;output()-&gt;set_frame_complete( __ offset() );</span>
  
    if (!UseRDPCForConstantTableBase &amp;&amp; C-&gt;has_mach_constant_base_node()) {
      // NOTE: We set the table base offset here because users might be
      // emitted before MachConstantBaseNode.
<span class="line-modified">!     ConstantTable&amp; constant_table = C-&gt;output()-&gt;constant_table();</span>
      constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
    }
  }
  
  uint MachPrologNode::size(PhaseRegAlloc *ra_) const {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1204,15 ***</span>
  #ifndef PRODUCT
  void MachEpilogNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
    Compile* C = ra_-&gt;C;
  
    if(do_polling() &amp;&amp; ra_-&gt;C-&gt;is_method_compilation()) {
<span class="line-modified">!     if (SafepointMechanism::uses_global_page_poll()) {</span>
<span class="line-removed">-       st-&gt;print(&quot;SETHI  #PollAddr,L0\t! Load Polling address\n\t&quot;);</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       st-&gt;print(&quot;LDX    [R_G2 + #poll_offset],L0\t! Load local polling address\n\t&quot;);</span>
<span class="line-removed">-     }</span>
      st-&gt;print(&quot;LDX    [L0],G0\t!Poll for Safepointing\n\t&quot;);
    }
  
    if(do_polling()) {
      if (UseCBCond &amp;&amp; !ra_-&gt;C-&gt;is_method_compilation()) {
<span class="line-new-header">--- 1222,11 ---</span>
  #ifndef PRODUCT
  void MachEpilogNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
    Compile* C = ra_-&gt;C;
  
    if(do_polling() &amp;&amp; ra_-&gt;C-&gt;is_method_compilation()) {
<span class="line-modified">!     st-&gt;print(&quot;LDX    [R_G2 + #poll_offset],L0\t! Load local polling address\n\t&quot;);</span>
      st-&gt;print(&quot;LDX    [L0],G0\t!Poll for Safepointing\n\t&quot;);
    }
  
    if(do_polling()) {
      if (UseCBCond &amp;&amp; !ra_-&gt;C-&gt;is_method_compilation()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1224,27 ***</span>
    st-&gt;print(&quot;RESTORE&quot;);
  }
  #endif
  
  void MachEpilogNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<span class="line-modified">!   MacroAssembler _masm(&amp;cbuf);</span>
    Compile* C = ra_-&gt;C;
  
    __ verify_thread();
  
    if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
      __ reserved_stack_check();
    }
  
    // If this does safepoint polling, then do it here
    if(do_polling() &amp;&amp; ra_-&gt;C-&gt;is_method_compilation()) {
<span class="line-modified">!     if (SafepointMechanism::uses_thread_local_poll()) {</span>
<span class="line-removed">-       __ ld_ptr(Address(G2_thread, Thread::polling_page_offset()), L0);</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       AddressLiteral polling_page(os::get_polling_page());</span>
<span class="line-removed">-       __ sethi(polling_page, L0);</span>
<span class="line-removed">-     }</span>
      __ relocate(relocInfo::poll_return_type);
      __ ld_ptr(L0, 0, G0);
    }
  
    // If this is a return, then stuff the restore in the delay slot
<span class="line-new-header">--- 1238,22 ---</span>
    st-&gt;print(&quot;RESTORE&quot;);
  }
  #endif
  
  void MachEpilogNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<span class="line-modified">!   C2_MacroAssembler _masm(&amp;cbuf);</span>
    Compile* C = ra_-&gt;C;
  
    __ verify_thread();
  
    if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
      __ reserved_stack_check();
    }
  
    // If this does safepoint polling, then do it here
    if(do_polling() &amp;&amp; ra_-&gt;C-&gt;is_method_compilation()) {
<span class="line-modified">!     __ ld_ptr(Address(G2_thread, Thread::polling_page_offset()), L0);</span>
      __ relocate(relocInfo::poll_return_type);
      __ ld_ptr(L0, 0, G0);
    }
  
    // If this is a return, then stuff the restore in the delay slot
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1271,16 ***</span>
  
  const Pipeline * MachEpilogNode::pipeline() const {
    return MachNode::pipeline_class();
  }
  
<span class="line-removed">- int MachEpilogNode::safepoint_offset() const {</span>
<span class="line-removed">-   assert(SafepointMechanism::uses_global_page_poll(), &quot;sanity&quot;);</span>
<span class="line-removed">-   assert( do_polling(), &quot;no return for this epilog node&quot;);</span>
<span class="line-removed">-   return MacroAssembler::insts_for_sethi(os::get_polling_page()) * BytesPerInstWord;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  //=============================================================================
  
  // Figure out which register class each belongs in: rc_int, rc_float, rc_stack
  enum RC { rc_bad, rc_int, rc_float, rc_stack };
  static enum RC rc_class( OptoReg::Name reg ) {
<span class="line-new-header">--- 1280,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1532,11 ***</span>
    st-&gt;print(&quot;NOP \t# %d bytes pad for loops and calls&quot;, 4 * _count);
  }
  #endif
  
  void MachNopNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *) const {
<span class="line-modified">!   MacroAssembler _masm(&amp;cbuf);</span>
    for (int i = 0; i &lt; _count; i += 1) {
      __ nop();
    }
  }
  
<span class="line-new-header">--- 1535,11 ---</span>
    st-&gt;print(&quot;NOP \t# %d bytes pad for loops and calls&quot;, 4 * _count);
  }
  #endif
  
  void MachNopNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *) const {
<span class="line-modified">!   C2_MacroAssembler _masm(&amp;cbuf);</span>
    for (int i = 0; i &lt; _count; i += 1) {
      __ nop();
    }
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1553,11 ***</span>
    st-&gt;print(&quot;LEA    [R_SP+#%d+BIAS],%s&quot;,offset,Matcher::regName[reg]);
  }
  #endif
  
  void BoxLockNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<span class="line-modified">!   MacroAssembler _masm(&amp;cbuf);</span>
    int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem()) + STACK_BIAS;
    int reg = ra_-&gt;get_encode(this);
  
    if (Assembler::is_simm13(offset)) {
       __ add(SP, offset, reg_to_register_object(reg));
<span class="line-new-header">--- 1556,11 ---</span>
    st-&gt;print(&quot;LEA    [R_SP+#%d+BIAS],%s&quot;,offset,Matcher::regName[reg]);
  }
  #endif
  
  void BoxLockNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<span class="line-modified">!   C2_MacroAssembler _masm(&amp;cbuf);</span>
    int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem()) + STACK_BIAS;
    int reg = ra_-&gt;get_encode(this);
  
    if (Assembler::is_simm13(offset)) {
       __ add(SP, offset, reg_to_register_object(reg));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1568,11 ***</span>
  }
  
  uint BoxLockNode::size(PhaseRegAlloc *ra_) const {
    // BoxLockNode is not a MachNode, so we can&#39;t just call MachNode::size(ra_)
    assert(ra_ == ra_-&gt;C-&gt;regalloc(), &quot;sanity&quot;);
<span class="line-modified">!   return ra_-&gt;C-&gt;scratch_emit_size(this);</span>
  }
  
  //=============================================================================
  #ifndef PRODUCT
  void MachUEPNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
<span class="line-new-header">--- 1571,11 ---</span>
  }
  
  uint BoxLockNode::size(PhaseRegAlloc *ra_) const {
    // BoxLockNode is not a MachNode, so we can&#39;t just call MachNode::size(ra_)
    assert(ra_ == ra_-&gt;C-&gt;regalloc(), &quot;sanity&quot;);
<span class="line-modified">!   return ra_-&gt;C-&gt;output()-&gt;scratch_emit_size(this);</span>
  }
  
  //=============================================================================
  #ifndef PRODUCT
  void MachUEPNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1597,11 ***</span>
    st-&gt;print   (&quot;\tTne    xcc,R_G0+ST_RESERVED_FOR_USER_0+2&quot;);
  }
  #endif
  
  void MachUEPNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<span class="line-modified">!   MacroAssembler _masm(&amp;cbuf);</span>
    Register G5_ic_reg  = reg_to_register_object(Matcher::inline_cache_reg_encode());
    Register temp_reg   = G3;
    assert( G5_ic_reg != temp_reg, &quot;conflicting registers&quot; );
  
    // Load klass from receiver
<span class="line-new-header">--- 1600,11 ---</span>
    st-&gt;print   (&quot;\tTne    xcc,R_G0+ST_RESERVED_FOR_USER_0+2&quot;);
  }
  #endif
  
  void MachUEPNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<span class="line-modified">!   C2_MacroAssembler _masm(&amp;cbuf);</span>
    Register G5_ic_reg  = reg_to_register_object(Matcher::inline_cache_reg_encode());
    Register temp_reg   = G3;
    assert( G5_ic_reg != temp_reg, &quot;conflicting registers&quot; );
  
    // Load klass from receiver
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1622,11 ***</span>
  
  // Emit exception handler code.
  int HandlerImpl::emit_exception_handler(CodeBuffer&amp; cbuf) {
    Register temp_reg = G3;
    AddressLiteral exception_blob(OptoRuntime::exception_blob()-&gt;entry_point());
<span class="line-modified">!   MacroAssembler _masm(&amp;cbuf);</span>
  
    address base = __ start_a_stub(size_exception_handler());
    if (base == NULL) {
      ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
      return 0;  // CodeBuffer::expand failed
<span class="line-new-header">--- 1625,11 ---</span>
  
  // Emit exception handler code.
  int HandlerImpl::emit_exception_handler(CodeBuffer&amp; cbuf) {
    Register temp_reg = G3;
    AddressLiteral exception_blob(OptoRuntime::exception_blob()-&gt;entry_point());
<span class="line-modified">!   C2_MacroAssembler _masm(&amp;cbuf);</span>
  
    address base = __ start_a_stub(size_exception_handler());
    if (base == NULL) {
      ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
      return 0;  // CodeBuffer::expand failed
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1647,11 ***</span>
  int HandlerImpl::emit_deopt_handler(CodeBuffer&amp; cbuf) {
    // Can&#39;t use any of the current frame&#39;s registers as we may have deopted
    // at a poll and everything (including G3) can be live.
    Register temp_reg = L0;
    AddressLiteral deopt_blob(SharedRuntime::deopt_blob()-&gt;unpack());
<span class="line-modified">!   MacroAssembler _masm(&amp;cbuf);</span>
  
    address base = __ start_a_stub(size_deopt_handler());
    if (base == NULL) {
      ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
      return 0;  // CodeBuffer::expand failed
<span class="line-new-header">--- 1650,11 ---</span>
  int HandlerImpl::emit_deopt_handler(CodeBuffer&amp; cbuf) {
    // Can&#39;t use any of the current frame&#39;s registers as we may have deopted
    // at a poll and everything (including G3) can be live.
    Register temp_reg = L0;
    AddressLiteral deopt_blob(SharedRuntime::deopt_blob()-&gt;unpack());
<span class="line-modified">!   C2_MacroAssembler _masm(&amp;cbuf);</span>
  
    address base = __ start_a_stub(size_deopt_handler());
    if (base == NULL) {
      ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
      return 0;  // CodeBuffer::expand failed
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1957,14 ***</span>
  }
  
  
  const bool Matcher::convi2l_type_required = true;
  
  // Should the Matcher clone shifts on addressing modes, expecting them
  // to be subsumed into complex addressing expressions or compute them
  // into registers?
<span class="line-modified">! bool Matcher::clone_address_expressions(AddPNode* m, Matcher::MStack&amp; mstack, VectorSet&amp; address_visited) {</span>
    return clone_base_plus_offset_address(m, mstack, address_visited);
  }
  
  void Compile::reshape_address(AddPNode* addp) {
  }
<span class="line-new-header">--- 1960,19 ---</span>
  }
  
  
  const bool Matcher::convi2l_type_required = true;
  
<span class="line-added">+ // Should the matcher clone input &#39;m&#39; of node &#39;n&#39;?</span>
<span class="line-added">+ bool Matcher::pd_clone_node(Node* n, Node* m, Matcher::MStack&amp; mstack) {</span>
<span class="line-added">+   return false;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  // Should the Matcher clone shifts on addressing modes, expecting them
  // to be subsumed into complex addressing expressions or compute them
  // into registers?
<span class="line-modified">! bool Matcher::pd_clone_address_expressions(AddPNode* m, Matcher::MStack&amp; mstack, VectorSet&amp; address_visited) {</span>
    return clone_base_plus_offset_address(m, mstack, address_visited);
  }
  
  void Compile::reshape_address(AddPNode* addp) {
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2005,11 ***</span>
  // tertiary opcode.  Only the opcode sections which a particular instruction
  // needs for encoding need to be specified.
  encode %{
    enc_class enc_untested %{
  #ifdef ASSERT
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      __ untested(&quot;encoding&quot;);
  #endif
    %}
  
    enc_class form3_mem_reg( memory mem, iRegI dst ) %{
<span class="line-new-header">--- 2013,11 ---</span>
  // tertiary opcode.  Only the opcode sections which a particular instruction
  // needs for encoding need to be specified.
  encode %{
    enc_class enc_untested %{
  #ifdef ASSERT
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      __ untested(&quot;encoding&quot;);
  #endif
    %}
  
    enc_class form3_mem_reg( memory mem, iRegI dst ) %{
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2140,20 ***</span>
      emit3_simm13( cbuf, Assembler::arith_op, R_O1_enc, Assembler::add_op3, R_O7_enc, frame::pc_return_offset );
    %}
  
    /* %%% merge with enc_to_bool */
    enc_class enc_convP2B( iRegI dst, iRegP src ) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
  
      Register   src_reg = reg_to_register_object($src$$reg);
      Register   dst_reg = reg_to_register_object($dst$$reg);
      __ movr(Assembler::rc_nz, src_reg, 1, dst_reg);
    %}
  
    enc_class enc_cadd_cmpLTMask( iRegI p, iRegI q, iRegI y, iRegI tmp ) %{
      // (Set p (AddI (AndI (CmpLTMask p q) y) (SubI p q)))
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
  
      Register   p_reg = reg_to_register_object($p$$reg);
      Register   q_reg = reg_to_register_object($q$$reg);
      Register   y_reg = reg_to_register_object($y$$reg);
      Register tmp_reg = reg_to_register_object($tmp$$reg);
<span class="line-new-header">--- 2148,20 ---</span>
      emit3_simm13( cbuf, Assembler::arith_op, R_O1_enc, Assembler::add_op3, R_O7_enc, frame::pc_return_offset );
    %}
  
    /* %%% merge with enc_to_bool */
    enc_class enc_convP2B( iRegI dst, iRegP src ) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
  
      Register   src_reg = reg_to_register_object($src$$reg);
      Register   dst_reg = reg_to_register_object($dst$$reg);
      __ movr(Assembler::rc_nz, src_reg, 1, dst_reg);
    %}
  
    enc_class enc_cadd_cmpLTMask( iRegI p, iRegI q, iRegI y, iRegI tmp ) %{
      // (Set p (AddI (AndI (CmpLTMask p q) y) (SubI p q)))
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
  
      Register   p_reg = reg_to_register_object($p$$reg);
      Register   q_reg = reg_to_register_object($q$$reg);
      Register   y_reg = reg_to_register_object($y$$reg);
      Register tmp_reg = reg_to_register_object($tmp$$reg);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2282,27 ***</span>
      // CLR    $dst
      emit3( cbuf, Assembler::arith_op, $dst$$reg, Assembler::or_op3 , 0, 0, 0 );
    %}
  
    enc_class enc_PartialSubtypeCheck() %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      __ call(StubRoutines::Sparc::partial_subtype_check(), relocInfo::runtime_call_type);
      __ delayed()-&gt;nop();
    %}
  
    enc_class enc_bp( label labl, cmpOp cmp, flagsReg cc ) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      Label* L = $labl$$label;
      Assembler::Predict predict_taken =
        cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
  
      __ bp( (Assembler::Condition)($cmp$$cmpcode), false, Assembler::icc, predict_taken, *L);
      __ delayed()-&gt;nop();
    %}
  
    enc_class enc_bpr( label labl, cmpOp_reg cmp, iRegI op1 ) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      Label* L = $labl$$label;
      Assembler::Predict predict_taken =
        cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
  
      __ bpr( (Assembler::RCondition)($cmp$$cmpcode), false, predict_taken, as_Register($op1$$reg), *L);
<span class="line-new-header">--- 2290,27 ---</span>
      // CLR    $dst
      emit3( cbuf, Assembler::arith_op, $dst$$reg, Assembler::or_op3 , 0, 0, 0 );
    %}
  
    enc_class enc_PartialSubtypeCheck() %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      __ call(StubRoutines::Sparc::partial_subtype_check(), relocInfo::runtime_call_type);
      __ delayed()-&gt;nop();
    %}
  
    enc_class enc_bp( label labl, cmpOp cmp, flagsReg cc ) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Label* L = $labl$$label;
      Assembler::Predict predict_taken =
        cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
  
      __ bp( (Assembler::Condition)($cmp$$cmpcode), false, Assembler::icc, predict_taken, *L);
      __ delayed()-&gt;nop();
    %}
  
    enc_class enc_bpr( label labl, cmpOp_reg cmp, iRegI op1 ) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Label* L = $labl$$label;
      Assembler::Predict predict_taken =
        cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
  
      __ bpr( (Assembler::RCondition)($cmp$$cmpcode), false, predict_taken, as_Register($op1$$reg), *L);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2417,18 ***</span>
    enc_class SetHi22( immI src, iRegI rd ) %{
      emit2_22( cbuf, Assembler::branch_op, $rd$$reg, Assembler::sethi_op2, $src$$constant );
    %}
  
    enc_class Set32( immI src, iRegI rd ) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      __ set($src$$constant, reg_to_register_object($rd$$reg));
    %}
  
    enc_class call_epilog %{
      if( VerifyStackAtCalls ) {
<span class="line-modified">!       MacroAssembler _masm(&amp;cbuf);</span>
<span class="line-modified">!       int framesize = ra_-&gt;C-&gt;frame_size_in_bytes();</span>
        Register temp_reg = G3;
        __ add(SP, framesize, temp_reg);
        __ cmp(temp_reg, FP);
        __ breakpoint_trap(Assembler::notEqual, Assembler::ptr_cc);
      }
<span class="line-new-header">--- 2425,18 ---</span>
    enc_class SetHi22( immI src, iRegI rd ) %{
      emit2_22( cbuf, Assembler::branch_op, $rd$$reg, Assembler::sethi_op2, $src$$constant );
    %}
  
    enc_class Set32( immI src, iRegI rd ) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      __ set($src$$constant, reg_to_register_object($rd$$reg));
    %}
  
    enc_class call_epilog %{
      if( VerifyStackAtCalls ) {
<span class="line-modified">!       C2_MacroAssembler _masm(&amp;cbuf);</span>
<span class="line-modified">!       int framesize = ra_-&gt;C-&gt;output()-&gt;frame_size_in_bytes();</span>
        Register temp_reg = G3;
        __ add(SP, framesize, temp_reg);
        __ cmp(temp_reg, FP);
        __ breakpoint_trap(Assembler::notEqual, Assembler::ptr_cc);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2445,16 ***</span>
      // The user of this is responsible for ensuring that R_L7 is empty (killed).
      emit_call_reloc(cbuf, $meth$$method, runtime_call_Relocation::spec(), /*preserve_g2=*/true);
    %}
  
    enc_class preserve_SP %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      __ mov(SP, L7_mh_SP_save);
    %}
  
    enc_class restore_SP %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      __ mov(L7_mh_SP_save, SP);
    %}
  
    enc_class Java_Static_Call (method meth) %{    // JAVA STATIC CALL
      // CALL to fixup routine.  Fixup routine uses ScopeDesc info to determine
<span class="line-new-header">--- 2453,16 ---</span>
      // The user of this is responsible for ensuring that R_L7 is empty (killed).
      emit_call_reloc(cbuf, $meth$$method, runtime_call_Relocation::spec(), /*preserve_g2=*/true);
    %}
  
    enc_class preserve_SP %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      __ mov(SP, L7_mh_SP_save);
    %}
  
    enc_class restore_SP %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      __ mov(L7_mh_SP_save, SP);
    %}
  
    enc_class Java_Static_Call (method meth) %{    // JAVA STATIC CALL
      // CALL to fixup routine.  Fixup routine uses ScopeDesc info to determine
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2475,11 ***</span>
        }
      }
    %}
  
    enc_class Java_Dynamic_Call (method meth) %{    // JAVA DYNAMIC CALL
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      __ set_inst_mark();
      int vtable_index = this-&gt;_vtable_index;
      // MachCallDynamicJavaNode::ret_addr_offset uses this same test
      if (vtable_index &lt; 0) {
        // must be invalid_vtable_index, not nonvirtual_vtable_index
<span class="line-new-header">--- 2483,11 ---</span>
        }
      }
    %}
  
    enc_class Java_Dynamic_Call (method meth) %{    // JAVA DYNAMIC CALL
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      __ set_inst_mark();
      int vtable_index = this-&gt;_vtable_index;
      // MachCallDynamicJavaNode::ret_addr_offset uses this same test
      if (vtable_index &lt; 0) {
        // must be invalid_vtable_index, not nonvirtual_vtable_index
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2524,11 ***</span>
        __ delayed()-&gt;nop();
      }
    %}
  
    enc_class Java_Compiled_Call (method meth) %{    // JAVA COMPILED CALL
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
  
      Register G5_ic_reg = reg_to_register_object(Matcher::inline_cache_reg_encode());
      Register temp_reg = G3;   // caller must kill G3!  We cannot reuse G5_ic_reg here because
                                // we might be calling a C2I adapter which needs it.
  
<span class="line-new-header">--- 2532,11 ---</span>
        __ delayed()-&gt;nop();
      }
    %}
  
    enc_class Java_Compiled_Call (method meth) %{    // JAVA COMPILED CALL
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
  
      Register G5_ic_reg = reg_to_register_object(Matcher::inline_cache_reg_encode());
      Register temp_reg = G3;   // caller must kill G3!  We cannot reuse G5_ic_reg here because
                                // we might be calling a C2I adapter which needs it.
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2541,33 ***</span>
      __ callr(temp_reg, G0);
      __ delayed()-&gt;nop();
    %}
  
  enc_class idiv_reg(iRegIsafe src1, iRegIsafe src2, iRegIsafe dst) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      Register Rdividend = reg_to_register_object($src1$$reg);
      Register Rdivisor = reg_to_register_object($src2$$reg);
      Register Rresult = reg_to_register_object($dst$$reg);
  
      __ sra(Rdivisor, 0, Rdivisor);
      __ sra(Rdividend, 0, Rdividend);
      __ sdivx(Rdividend, Rdivisor, Rresult);
  %}
  
  enc_class idiv_imm(iRegIsafe src1, immI13 imm, iRegIsafe dst) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
  
      Register Rdividend = reg_to_register_object($src1$$reg);
      int divisor = $imm$$constant;
      Register Rresult = reg_to_register_object($dst$$reg);
  
      __ sra(Rdividend, 0, Rdividend);
      __ sdivx(Rdividend, divisor, Rresult);
  %}
  
  enc_class enc_mul_hi(iRegIsafe dst, iRegIsafe src1, iRegIsafe src2) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      Register Rsrc1 = reg_to_register_object($src1$$reg);
      Register Rsrc2 = reg_to_register_object($src2$$reg);
      Register Rdst  = reg_to_register_object($dst$$reg);
  
      __ sra( Rsrc1, 0, Rsrc1 );
<span class="line-new-header">--- 2549,33 ---</span>
      __ callr(temp_reg, G0);
      __ delayed()-&gt;nop();
    %}
  
  enc_class idiv_reg(iRegIsafe src1, iRegIsafe src2, iRegIsafe dst) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register Rdividend = reg_to_register_object($src1$$reg);
      Register Rdivisor = reg_to_register_object($src2$$reg);
      Register Rresult = reg_to_register_object($dst$$reg);
  
      __ sra(Rdivisor, 0, Rdivisor);
      __ sra(Rdividend, 0, Rdividend);
      __ sdivx(Rdividend, Rdivisor, Rresult);
  %}
  
  enc_class idiv_imm(iRegIsafe src1, immI13 imm, iRegIsafe dst) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
  
      Register Rdividend = reg_to_register_object($src1$$reg);
      int divisor = $imm$$constant;
      Register Rresult = reg_to_register_object($dst$$reg);
  
      __ sra(Rdividend, 0, Rdividend);
      __ sdivx(Rdividend, divisor, Rresult);
  %}
  
  enc_class enc_mul_hi(iRegIsafe dst, iRegIsafe src1, iRegIsafe src2) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register Rsrc1 = reg_to_register_object($src1$$reg);
      Register Rsrc2 = reg_to_register_object($src2$$reg);
      Register Rdst  = reg_to_register_object($dst$$reg);
  
      __ sra( Rsrc1, 0, Rsrc1 );
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2575,11 ***</span>
      __ mulx( Rsrc1, Rsrc2, Rdst );
      __ srlx( Rdst, 32, Rdst );
  %}
  
  enc_class irem_reg(iRegIsafe src1, iRegIsafe src2, iRegIsafe dst, o7RegL scratch) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      Register Rdividend = reg_to_register_object($src1$$reg);
      Register Rdivisor = reg_to_register_object($src2$$reg);
      Register Rresult = reg_to_register_object($dst$$reg);
      Register Rscratch = reg_to_register_object($scratch$$reg);
  
<span class="line-new-header">--- 2583,11 ---</span>
      __ mulx( Rsrc1, Rsrc2, Rdst );
      __ srlx( Rdst, 32, Rdst );
  %}
  
  enc_class irem_reg(iRegIsafe src1, iRegIsafe src2, iRegIsafe dst, o7RegL scratch) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register Rdividend = reg_to_register_object($src1$$reg);
      Register Rdivisor = reg_to_register_object($src2$$reg);
      Register Rresult = reg_to_register_object($dst$$reg);
      Register Rscratch = reg_to_register_object($scratch$$reg);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2592,11 ***</span>
      __ mulx(Rscratch, Rdivisor, Rscratch);
      __ sub(Rdividend, Rscratch, Rresult);
  %}
  
  enc_class irem_imm(iRegIsafe src1, immI13 imm, iRegIsafe dst, o7RegL scratch) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
  
      Register Rdividend = reg_to_register_object($src1$$reg);
      int divisor = $imm$$constant;
      Register Rresult = reg_to_register_object($dst$$reg);
      Register Rscratch = reg_to_register_object($scratch$$reg);
<span class="line-new-header">--- 2600,11 ---</span>
      __ mulx(Rscratch, Rdivisor, Rscratch);
      __ sub(Rdividend, Rscratch, Rresult);
  %}
  
  enc_class irem_imm(iRegIsafe src1, immI13 imm, iRegIsafe dst, o7RegL scratch) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
  
      Register Rdividend = reg_to_register_object($src1$$reg);
      int divisor = $imm$$constant;
      Register Rresult = reg_to_register_object($dst$$reg);
      Register Rscratch = reg_to_register_object($scratch$$reg);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2608,134 ***</span>
      __ mulx(Rscratch, divisor, Rscratch);
      __ sub(Rdividend, Rscratch, Rresult);
  %}
  
  enc_class fabss (sflt_reg dst, sflt_reg src) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
  
      FloatRegister Fdst = reg_to_SingleFloatRegister_object($dst$$reg);
      FloatRegister Fsrc = reg_to_SingleFloatRegister_object($src$$reg);
  
      __ fabs(FloatRegisterImpl::S, Fsrc, Fdst);
  %}
  
  enc_class fabsd (dflt_reg dst, dflt_reg src) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
  
      FloatRegister Fdst = reg_to_DoubleFloatRegister_object($dst$$reg);
      FloatRegister Fsrc = reg_to_DoubleFloatRegister_object($src$$reg);
  
      __ fabs(FloatRegisterImpl::D, Fsrc, Fdst);
  %}
  
  enc_class fnegd (dflt_reg dst, dflt_reg src) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
  
      FloatRegister Fdst = reg_to_DoubleFloatRegister_object($dst$$reg);
      FloatRegister Fsrc = reg_to_DoubleFloatRegister_object($src$$reg);
  
      __ fneg(FloatRegisterImpl::D, Fsrc, Fdst);
  %}
  
  enc_class fsqrts (sflt_reg dst, sflt_reg src) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
  
      FloatRegister Fdst = reg_to_SingleFloatRegister_object($dst$$reg);
      FloatRegister Fsrc = reg_to_SingleFloatRegister_object($src$$reg);
  
      __ fsqrt(FloatRegisterImpl::S, Fsrc, Fdst);
  %}
  
  enc_class fsqrtd (dflt_reg dst, dflt_reg src) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
  
      FloatRegister Fdst = reg_to_DoubleFloatRegister_object($dst$$reg);
      FloatRegister Fsrc = reg_to_DoubleFloatRegister_object($src$$reg);
  
      __ fsqrt(FloatRegisterImpl::D, Fsrc, Fdst);
  %}
  
  
  enc_class fmadds (sflt_reg dst, sflt_reg a, sflt_reg b, sflt_reg c) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
  
      FloatRegister Frd = reg_to_SingleFloatRegister_object($dst$$reg);
      FloatRegister Fra = reg_to_SingleFloatRegister_object($a$$reg);
      FloatRegister Frb = reg_to_SingleFloatRegister_object($b$$reg);
      FloatRegister Frc = reg_to_SingleFloatRegister_object($c$$reg);
  
      __ fmadd(FloatRegisterImpl::S, Fra, Frb, Frc, Frd);
  %}
  
  enc_class fmaddd (dflt_reg dst, dflt_reg a, dflt_reg b, dflt_reg c) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
  
      FloatRegister Frd = reg_to_DoubleFloatRegister_object($dst$$reg);
      FloatRegister Fra = reg_to_DoubleFloatRegister_object($a$$reg);
      FloatRegister Frb = reg_to_DoubleFloatRegister_object($b$$reg);
      FloatRegister Frc = reg_to_DoubleFloatRegister_object($c$$reg);
  
      __ fmadd(FloatRegisterImpl::D, Fra, Frb, Frc, Frd);
  %}
  
  enc_class fmsubs (sflt_reg dst, sflt_reg a, sflt_reg b, sflt_reg c) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
  
      FloatRegister Frd = reg_to_SingleFloatRegister_object($dst$$reg);
      FloatRegister Fra = reg_to_SingleFloatRegister_object($a$$reg);
      FloatRegister Frb = reg_to_SingleFloatRegister_object($b$$reg);
      FloatRegister Frc = reg_to_SingleFloatRegister_object($c$$reg);
  
      __ fmsub(FloatRegisterImpl::S, Fra, Frb, Frc, Frd);
  %}
  
  enc_class fmsubd (dflt_reg dst, dflt_reg a, dflt_reg b, dflt_reg c) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
  
      FloatRegister Frd = reg_to_DoubleFloatRegister_object($dst$$reg);
      FloatRegister Fra = reg_to_DoubleFloatRegister_object($a$$reg);
      FloatRegister Frb = reg_to_DoubleFloatRegister_object($b$$reg);
      FloatRegister Frc = reg_to_DoubleFloatRegister_object($c$$reg);
  
      __ fmsub(FloatRegisterImpl::D, Fra, Frb, Frc, Frd);
  %}
  
  enc_class fnmadds (sflt_reg dst, sflt_reg a, sflt_reg b, sflt_reg c) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
  
      FloatRegister Frd = reg_to_SingleFloatRegister_object($dst$$reg);
      FloatRegister Fra = reg_to_SingleFloatRegister_object($a$$reg);
      FloatRegister Frb = reg_to_SingleFloatRegister_object($b$$reg);
      FloatRegister Frc = reg_to_SingleFloatRegister_object($c$$reg);
  
      __ fnmadd(FloatRegisterImpl::S, Fra, Frb, Frc, Frd);
  %}
  
  enc_class fnmaddd (dflt_reg dst, dflt_reg a, dflt_reg b, dflt_reg c) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
  
      FloatRegister Frd = reg_to_DoubleFloatRegister_object($dst$$reg);
      FloatRegister Fra = reg_to_DoubleFloatRegister_object($a$$reg);
      FloatRegister Frb = reg_to_DoubleFloatRegister_object($b$$reg);
      FloatRegister Frc = reg_to_DoubleFloatRegister_object($c$$reg);
  
      __ fnmadd(FloatRegisterImpl::D, Fra, Frb, Frc, Frd);
  %}
  
  enc_class fnmsubs (sflt_reg dst, sflt_reg a, sflt_reg b, sflt_reg c) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
  
      FloatRegister Frd = reg_to_SingleFloatRegister_object($dst$$reg);
      FloatRegister Fra = reg_to_SingleFloatRegister_object($a$$reg);
      FloatRegister Frb = reg_to_SingleFloatRegister_object($b$$reg);
      FloatRegister Frc = reg_to_SingleFloatRegister_object($c$$reg);
  
      __ fnmsub(FloatRegisterImpl::S, Fra, Frb, Frc, Frd);
  %}
  
  enc_class fnmsubd (dflt_reg dst, dflt_reg a, dflt_reg b, dflt_reg c) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
  
      FloatRegister Frd = reg_to_DoubleFloatRegister_object($dst$$reg);
      FloatRegister Fra = reg_to_DoubleFloatRegister_object($a$$reg);
      FloatRegister Frb = reg_to_DoubleFloatRegister_object($b$$reg);
      FloatRegister Frc = reg_to_DoubleFloatRegister_object($c$$reg);
<span class="line-new-header">--- 2616,134 ---</span>
      __ mulx(Rscratch, divisor, Rscratch);
      __ sub(Rdividend, Rscratch, Rresult);
  %}
  
  enc_class fabss (sflt_reg dst, sflt_reg src) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
  
      FloatRegister Fdst = reg_to_SingleFloatRegister_object($dst$$reg);
      FloatRegister Fsrc = reg_to_SingleFloatRegister_object($src$$reg);
  
      __ fabs(FloatRegisterImpl::S, Fsrc, Fdst);
  %}
  
  enc_class fabsd (dflt_reg dst, dflt_reg src) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
  
      FloatRegister Fdst = reg_to_DoubleFloatRegister_object($dst$$reg);
      FloatRegister Fsrc = reg_to_DoubleFloatRegister_object($src$$reg);
  
      __ fabs(FloatRegisterImpl::D, Fsrc, Fdst);
  %}
  
  enc_class fnegd (dflt_reg dst, dflt_reg src) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
  
      FloatRegister Fdst = reg_to_DoubleFloatRegister_object($dst$$reg);
      FloatRegister Fsrc = reg_to_DoubleFloatRegister_object($src$$reg);
  
      __ fneg(FloatRegisterImpl::D, Fsrc, Fdst);
  %}
  
  enc_class fsqrts (sflt_reg dst, sflt_reg src) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
  
      FloatRegister Fdst = reg_to_SingleFloatRegister_object($dst$$reg);
      FloatRegister Fsrc = reg_to_SingleFloatRegister_object($src$$reg);
  
      __ fsqrt(FloatRegisterImpl::S, Fsrc, Fdst);
  %}
  
  enc_class fsqrtd (dflt_reg dst, dflt_reg src) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
  
      FloatRegister Fdst = reg_to_DoubleFloatRegister_object($dst$$reg);
      FloatRegister Fsrc = reg_to_DoubleFloatRegister_object($src$$reg);
  
      __ fsqrt(FloatRegisterImpl::D, Fsrc, Fdst);
  %}
  
  
  enc_class fmadds (sflt_reg dst, sflt_reg a, sflt_reg b, sflt_reg c) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
  
      FloatRegister Frd = reg_to_SingleFloatRegister_object($dst$$reg);
      FloatRegister Fra = reg_to_SingleFloatRegister_object($a$$reg);
      FloatRegister Frb = reg_to_SingleFloatRegister_object($b$$reg);
      FloatRegister Frc = reg_to_SingleFloatRegister_object($c$$reg);
  
      __ fmadd(FloatRegisterImpl::S, Fra, Frb, Frc, Frd);
  %}
  
  enc_class fmaddd (dflt_reg dst, dflt_reg a, dflt_reg b, dflt_reg c) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
  
      FloatRegister Frd = reg_to_DoubleFloatRegister_object($dst$$reg);
      FloatRegister Fra = reg_to_DoubleFloatRegister_object($a$$reg);
      FloatRegister Frb = reg_to_DoubleFloatRegister_object($b$$reg);
      FloatRegister Frc = reg_to_DoubleFloatRegister_object($c$$reg);
  
      __ fmadd(FloatRegisterImpl::D, Fra, Frb, Frc, Frd);
  %}
  
  enc_class fmsubs (sflt_reg dst, sflt_reg a, sflt_reg b, sflt_reg c) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
  
      FloatRegister Frd = reg_to_SingleFloatRegister_object($dst$$reg);
      FloatRegister Fra = reg_to_SingleFloatRegister_object($a$$reg);
      FloatRegister Frb = reg_to_SingleFloatRegister_object($b$$reg);
      FloatRegister Frc = reg_to_SingleFloatRegister_object($c$$reg);
  
      __ fmsub(FloatRegisterImpl::S, Fra, Frb, Frc, Frd);
  %}
  
  enc_class fmsubd (dflt_reg dst, dflt_reg a, dflt_reg b, dflt_reg c) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
  
      FloatRegister Frd = reg_to_DoubleFloatRegister_object($dst$$reg);
      FloatRegister Fra = reg_to_DoubleFloatRegister_object($a$$reg);
      FloatRegister Frb = reg_to_DoubleFloatRegister_object($b$$reg);
      FloatRegister Frc = reg_to_DoubleFloatRegister_object($c$$reg);
  
      __ fmsub(FloatRegisterImpl::D, Fra, Frb, Frc, Frd);
  %}
  
  enc_class fnmadds (sflt_reg dst, sflt_reg a, sflt_reg b, sflt_reg c) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
  
      FloatRegister Frd = reg_to_SingleFloatRegister_object($dst$$reg);
      FloatRegister Fra = reg_to_SingleFloatRegister_object($a$$reg);
      FloatRegister Frb = reg_to_SingleFloatRegister_object($b$$reg);
      FloatRegister Frc = reg_to_SingleFloatRegister_object($c$$reg);
  
      __ fnmadd(FloatRegisterImpl::S, Fra, Frb, Frc, Frd);
  %}
  
  enc_class fnmaddd (dflt_reg dst, dflt_reg a, dflt_reg b, dflt_reg c) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
  
      FloatRegister Frd = reg_to_DoubleFloatRegister_object($dst$$reg);
      FloatRegister Fra = reg_to_DoubleFloatRegister_object($a$$reg);
      FloatRegister Frb = reg_to_DoubleFloatRegister_object($b$$reg);
      FloatRegister Frc = reg_to_DoubleFloatRegister_object($c$$reg);
  
      __ fnmadd(FloatRegisterImpl::D, Fra, Frb, Frc, Frd);
  %}
  
  enc_class fnmsubs (sflt_reg dst, sflt_reg a, sflt_reg b, sflt_reg c) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
  
      FloatRegister Frd = reg_to_SingleFloatRegister_object($dst$$reg);
      FloatRegister Fra = reg_to_SingleFloatRegister_object($a$$reg);
      FloatRegister Frb = reg_to_SingleFloatRegister_object($b$$reg);
      FloatRegister Frc = reg_to_SingleFloatRegister_object($c$$reg);
  
      __ fnmsub(FloatRegisterImpl::S, Fra, Frb, Frc, Frd);
  %}
  
  enc_class fnmsubd (dflt_reg dst, dflt_reg a, dflt_reg b, dflt_reg c) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
  
      FloatRegister Frd = reg_to_DoubleFloatRegister_object($dst$$reg);
      FloatRegister Fra = reg_to_DoubleFloatRegister_object($a$$reg);
      FloatRegister Frb = reg_to_DoubleFloatRegister_object($b$$reg);
      FloatRegister Frc = reg_to_DoubleFloatRegister_object($c$$reg);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2743,29 ***</span>
      __ fnmsub(FloatRegisterImpl::D, Fra, Frb, Frc, Frd);
  %}
  
  
  enc_class fmovs (dflt_reg dst, dflt_reg src) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
  
      FloatRegister Fdst = reg_to_SingleFloatRegister_object($dst$$reg);
      FloatRegister Fsrc = reg_to_SingleFloatRegister_object($src$$reg);
  
      __ fmov(FloatRegisterImpl::S, Fsrc, Fdst);
  %}
  
  enc_class fmovd (dflt_reg dst, dflt_reg src) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
  
      FloatRegister Fdst = reg_to_DoubleFloatRegister_object($dst$$reg);
      FloatRegister Fsrc = reg_to_DoubleFloatRegister_object($src$$reg);
  
      __ fmov(FloatRegisterImpl::D, Fsrc, Fdst);
  %}
  
  enc_class Fast_Lock(iRegP oop, iRegP box, o7RegP scratch, iRegP scratch2) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
  
      Register Roop  = reg_to_register_object($oop$$reg);
      Register Rbox  = reg_to_register_object($box$$reg);
      Register Rscratch = reg_to_register_object($scratch$$reg);
      Register Rmark =    reg_to_register_object($scratch2$$reg);
<span class="line-new-header">--- 2751,29 ---</span>
      __ fnmsub(FloatRegisterImpl::D, Fra, Frb, Frc, Frd);
  %}
  
  
  enc_class fmovs (dflt_reg dst, dflt_reg src) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
  
      FloatRegister Fdst = reg_to_SingleFloatRegister_object($dst$$reg);
      FloatRegister Fsrc = reg_to_SingleFloatRegister_object($src$$reg);
  
      __ fmov(FloatRegisterImpl::S, Fsrc, Fdst);
  %}
  
  enc_class fmovd (dflt_reg dst, dflt_reg src) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
  
      FloatRegister Fdst = reg_to_DoubleFloatRegister_object($dst$$reg);
      FloatRegister Fsrc = reg_to_DoubleFloatRegister_object($src$$reg);
  
      __ fmov(FloatRegisterImpl::D, Fsrc, Fdst);
  %}
  
  enc_class Fast_Lock(iRegP oop, iRegP box, o7RegP scratch, iRegP scratch2) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
  
      Register Roop  = reg_to_register_object($oop$$reg);
      Register Rbox  = reg_to_register_object($box$$reg);
      Register Rscratch = reg_to_register_object($scratch$$reg);
      Register Rmark =    reg_to_register_object($scratch2$$reg);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2777,11 ***</span>
  
      __ compiler_lock_object(Roop, Rmark, Rbox, Rscratch, _counters, UseBiasedLocking &amp;&amp; !UseOptoBiasInlining);
  %}
  
  enc_class Fast_Unlock(iRegP oop, iRegP box, o7RegP scratch, iRegP scratch2) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
  
      Register Roop  = reg_to_register_object($oop$$reg);
      Register Rbox  = reg_to_register_object($box$$reg);
      Register Rscratch = reg_to_register_object($scratch$$reg);
      Register Rmark =    reg_to_register_object($scratch2$$reg);
<span class="line-new-header">--- 2785,11 ---</span>
  
      __ compiler_lock_object(Roop, Rmark, Rbox, Rscratch, _counters, UseBiasedLocking &amp;&amp; !UseOptoBiasInlining);
  %}
  
  enc_class Fast_Unlock(iRegP oop, iRegP box, o7RegP scratch, iRegP scratch2) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
  
      Register Roop  = reg_to_register_object($oop$$reg);
      Register Rbox  = reg_to_register_object($box$$reg);
      Register Rscratch = reg_to_register_object($scratch$$reg);
      Register Rmark =    reg_to_register_object($scratch2$$reg);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2793,11 ***</span>
  
      __ compiler_unlock_object(Roop, Rmark, Rbox, Rscratch, UseBiasedLocking &amp;&amp; !UseOptoBiasInlining);
    %}
  
    enc_class enc_cas( iRegP mem, iRegP old, iRegP new ) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      Register Rmem = reg_to_register_object($mem$$reg);
      Register Rold = reg_to_register_object($old$$reg);
      Register Rnew = reg_to_register_object($new$$reg);
  
      __ cas_ptr(Rmem, Rold, Rnew); // Swap(*Rmem,Rnew) if *Rmem == Rold
<span class="line-new-header">--- 2801,11 ---</span>
  
      __ compiler_unlock_object(Roop, Rmark, Rbox, Rscratch, UseBiasedLocking &amp;&amp; !UseOptoBiasInlining);
    %}
  
    enc_class enc_cas( iRegP mem, iRegP old, iRegP new ) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register Rmem = reg_to_register_object($mem$$reg);
      Register Rold = reg_to_register_object($old$$reg);
      Register Rnew = reg_to_register_object($new$$reg);
  
      __ cas_ptr(Rmem, Rold, Rnew); // Swap(*Rmem,Rnew) if *Rmem == Rold
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2807,11 ***</span>
    enc_class enc_casx( iRegP mem, iRegL old, iRegL new) %{
      Register Rmem = reg_to_register_object($mem$$reg);
      Register Rold = reg_to_register_object($old$$reg);
      Register Rnew = reg_to_register_object($new$$reg);
  
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      __ mov(Rnew, O7);
      __ casx(Rmem, Rold, O7);
      __ cmp( Rold, O7 );
    %}
  
<span class="line-new-header">--- 2815,11 ---</span>
    enc_class enc_casx( iRegP mem, iRegL old, iRegL new) %{
      Register Rmem = reg_to_register_object($mem$$reg);
      Register Rold = reg_to_register_object($old$$reg);
      Register Rnew = reg_to_register_object($new$$reg);
  
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      __ mov(Rnew, O7);
      __ casx(Rmem, Rold, O7);
      __ cmp( Rold, O7 );
    %}
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2819,11 ***</span>
    enc_class enc_casi( iRegP mem, iRegL old, iRegL new) %{
      Register Rmem = reg_to_register_object($mem$$reg);
      Register Rold = reg_to_register_object($old$$reg);
      Register Rnew = reg_to_register_object($new$$reg);
  
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      __ mov(Rnew, O7);
      __ cas(Rmem, Rold, O7);
      __ cmp( Rold, O7 );
    %}
  
<span class="line-new-header">--- 2827,11 ---</span>
    enc_class enc_casi( iRegP mem, iRegL old, iRegL new) %{
      Register Rmem = reg_to_register_object($mem$$reg);
      Register Rold = reg_to_register_object($old$$reg);
      Register Rnew = reg_to_register_object($new$$reg);
  
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      __ mov(Rnew, O7);
      __ cas(Rmem, Rold, O7);
      __ cmp( Rold, O7 );
    %}
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2831,42 ***</span>
    enc_class enc_casi_exch( iRegP mem, iRegL old, iRegL new) %{
      Register Rmem = reg_to_register_object($mem$$reg);
      Register Rold = reg_to_register_object($old$$reg);
      Register Rnew = reg_to_register_object($new$$reg);
  
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      __ cas(Rmem, Rold, Rnew);
    %}
  
    // 64-bit cas without using tmp register for compareAndExchange
    enc_class enc_casx_exch( iRegP mem, iRegL old, iRegL new) %{
      Register Rmem = reg_to_register_object($mem$$reg);
      Register Rold = reg_to_register_object($old$$reg);
      Register Rnew = reg_to_register_object($new$$reg);
  
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      __ casx(Rmem, Rold, Rnew);
    %}
  
    enc_class enc_lflags_ne_to_boolean( iRegI res ) %{
      Register Rres = reg_to_register_object($res$$reg);
  
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      __ mov(1, Rres);
      __ movcc( Assembler::notEqual, false, Assembler::xcc, G0, Rres );
    %}
  
    enc_class enc_iflags_ne_to_boolean( iRegI res ) %{
      Register Rres = reg_to_register_object($res$$reg);
  
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      __ mov(1, Rres);
      __ movcc( Assembler::notEqual, false, Assembler::icc, G0, Rres );
    %}
  
    enc_class floating_cmp ( iRegP dst, regF src1, regF src2 ) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      Register Rdst = reg_to_register_object($dst$$reg);
      FloatRegister Fsrc1 = $primary ? reg_to_SingleFloatRegister_object($src1$$reg)
                                       : reg_to_DoubleFloatRegister_object($src1$$reg);
      FloatRegister Fsrc2 = $primary ? reg_to_SingleFloatRegister_object($src2$$reg)
                                       : reg_to_DoubleFloatRegister_object($src2$$reg);
<span class="line-new-header">--- 2839,42 ---</span>
    enc_class enc_casi_exch( iRegP mem, iRegL old, iRegL new) %{
      Register Rmem = reg_to_register_object($mem$$reg);
      Register Rold = reg_to_register_object($old$$reg);
      Register Rnew = reg_to_register_object($new$$reg);
  
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      __ cas(Rmem, Rold, Rnew);
    %}
  
    // 64-bit cas without using tmp register for compareAndExchange
    enc_class enc_casx_exch( iRegP mem, iRegL old, iRegL new) %{
      Register Rmem = reg_to_register_object($mem$$reg);
      Register Rold = reg_to_register_object($old$$reg);
      Register Rnew = reg_to_register_object($new$$reg);
  
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      __ casx(Rmem, Rold, Rnew);
    %}
  
    enc_class enc_lflags_ne_to_boolean( iRegI res ) %{
      Register Rres = reg_to_register_object($res$$reg);
  
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      __ mov(1, Rres);
      __ movcc( Assembler::notEqual, false, Assembler::xcc, G0, Rres );
    %}
  
    enc_class enc_iflags_ne_to_boolean( iRegI res ) %{
      Register Rres = reg_to_register_object($res$$reg);
  
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      __ mov(1, Rres);
      __ movcc( Assembler::notEqual, false, Assembler::icc, G0, Rres );
    %}
  
    enc_class floating_cmp ( iRegP dst, regF src1, regF src2 ) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register Rdst = reg_to_register_object($dst$$reg);
      FloatRegister Fsrc1 = $primary ? reg_to_SingleFloatRegister_object($src1$$reg)
                                       : reg_to_DoubleFloatRegister_object($src1$$reg);
      FloatRegister Fsrc2 = $primary ? reg_to_SingleFloatRegister_object($src2$$reg)
                                       : reg_to_DoubleFloatRegister_object($src2$$reg);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2878,11 ***</span>
    enc_class enc_rethrow() %{
      cbuf.set_insts_mark();
      Register temp_reg = G3;
      AddressLiteral rethrow_stub(OptoRuntime::rethrow_stub());
      assert(temp_reg != reg_to_register_object(R_I0_num), &quot;temp must not break oop_reg&quot;);
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
  #ifdef ASSERT
      __ save_frame(0);
      AddressLiteral last_rethrow_addrlit(&amp;last_rethrow);
      __ sethi(last_rethrow_addrlit, L1);
      Address addr(L1, last_rethrow_addrlit.low10());
<span class="line-new-header">--- 2886,11 ---</span>
    enc_class enc_rethrow() %{
      cbuf.set_insts_mark();
      Register temp_reg = G3;
      AddressLiteral rethrow_stub(OptoRuntime::rethrow_stub());
      assert(temp_reg != reg_to_register_object(R_I0_num), &quot;temp must not break oop_reg&quot;);
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
  #ifdef ASSERT
      __ save_frame(0);
      AddressLiteral last_rethrow_addrlit(&amp;last_rethrow);
      __ sethi(last_rethrow_addrlit, L1);
      Address addr(L1, last_rethrow_addrlit.low10());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2909,21 ***</span>
      // Generates the instruction BPN,PN .
      cbuf.insts()-&gt;emit_int32((unsigned int) 0x00400000);
    %}
  
    enc_class enc_membar_acquire %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      __ membar( Assembler::Membar_mask_bits(Assembler::LoadStore | Assembler::LoadLoad) );
    %}
  
    enc_class enc_membar_release %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      __ membar( Assembler::Membar_mask_bits(Assembler::LoadStore | Assembler::StoreStore) );
    %}
  
    enc_class enc_membar_volatile %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      __ membar( Assembler::Membar_mask_bits(Assembler::StoreLoad) );
    %}
  
  %}
  
<span class="line-new-header">--- 2917,21 ---</span>
      // Generates the instruction BPN,PN .
      cbuf.insts()-&gt;emit_int32((unsigned int) 0x00400000);
    %}
  
    enc_class enc_membar_acquire %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      __ membar( Assembler::Membar_mask_bits(Assembler::LoadStore | Assembler::LoadLoad) );
    %}
  
    enc_class enc_membar_release %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      __ membar( Assembler::Membar_mask_bits(Assembler::LoadStore | Assembler::StoreStore) );
    %}
  
    enc_class enc_membar_volatile %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      __ membar( Assembler::Membar_mask_bits(Assembler::StoreLoad) );
    %}
  
  %}
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3373,19 ***</span>
  
    format %{ %}
    interface(CONST_INTER);
  %}
  
<span class="line-removed">- operand immP_poll() %{</span>
<span class="line-removed">-   predicate(n-&gt;get_ptr() != 0 &amp;&amp; n-&gt;get_ptr() == (intptr_t)os::get_polling_page());</span>
<span class="line-removed">-   match(ConP);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // formats are generated automatically for constants and base registers</span>
<span class="line-removed">-   format %{ %}</span>
<span class="line-removed">-   interface(CONST_INTER);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
  // Pointer Immediate
  operand immN()
  %{
    match(ConN);
  
<span class="line-new-header">--- 3381,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4490,16 ***</span>
  pipe_class loadConP( iRegP dst, immP src ) %{
      instruction_count(0); multiple_bundles;
      fixed_latency(6);
  %}
  
<span class="line-removed">- // Polling Address</span>
<span class="line-removed">- pipe_class loadConP_poll( iRegP dst, immP_poll src ) %{</span>
<span class="line-removed">-     instruction_count(0); multiple_bundles;</span>
<span class="line-removed">-     fixed_latency(6);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
  // Long Constant small
  pipe_class loadConLlo( iRegL dst, immL src ) %{
      instruction_count(2);
      dst   : E(write);
      IALU  : R;
<span class="line-new-header">--- 4489,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5881,21 ***</span>
      __ clr($dst$$Register);
    %}
    ins_pipe(ialu_imm);
  %}
  
<span class="line-removed">- instruct loadConP_poll(iRegP dst, immP_poll src) %{</span>
<span class="line-removed">-   match(Set dst src);</span>
<span class="line-removed">-   ins_cost(DEFAULT_COST);</span>
<span class="line-removed">-   format %{ &quot;SET    $src,$dst\t!ptr&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     AddressLiteral polling_page(os::get_polling_page());</span>
<span class="line-removed">-     __ sethi(polling_page, reg_to_register_object($dst$$reg));</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe(loadConP_poll);</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
  instruct loadConN0(iRegN dst, immN0 src) %{
    match(Set dst src);
  
    size(4);
    format %{ &quot;CLR    $dst\t! compressed NULL ptr&quot; %}
<span class="line-new-header">--- 5874,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8852,11 ***</span>
      Register label_reg = O7;
      // If we are calculating the size of this instruction don&#39;t trust
      // zero offsets because they might change when
      // MachConstantBaseNode decides to optimize the constant table
      // base.
<span class="line-modified">!     if ((constant_offset() == 0) &amp;&amp; !Compile::current()-&gt;in_scratch_emit_size()) {</span>
        table_reg = $constanttablebase;
      } else {
        table_reg = O7;
        RegisterOrConstant con_offset = __ ensure_simm13_or_reg($constantoffset, O7);
        __ add($constanttablebase, con_offset, table_reg);
<span class="line-new-header">--- 8834,11 ---</span>
      Register label_reg = O7;
      // If we are calculating the size of this instruction don&#39;t trust
      // zero offsets because they might change when
      // MachConstantBaseNode decides to optimize the constant table
      // base.
<span class="line-modified">!     if ((constant_offset() == 0) &amp;&amp; !Compile::current()-&gt;output()-&gt;in_scratch_emit_size()) {</span>
        table_reg = $constanttablebase;
      } else {
        table_reg = O7;
        RegisterOrConstant con_offset = __ ensure_simm13_or_reg($constantoffset, O7);
        __ add($constanttablebase, con_offset, table_reg);
</pre>
<center><a href="sharedRuntime_sparc.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="templateTable_sparc.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/s390/c1_LIRAssembler_s390.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * Copyright (c) 2016, 2019, SAP SE. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;c1/c1_Compilation.hpp&quot;
  29 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  30 #include &quot;c1/c1_MacroAssembler.hpp&quot;
  31 #include &quot;c1/c1_Runtime1.hpp&quot;
  32 #include &quot;c1/c1_ValueStack.hpp&quot;
  33 #include &quot;ci/ciArrayKlass.hpp&quot;
  34 #include &quot;ci/ciInstance.hpp&quot;
  35 #include &quot;gc/shared/collectedHeap.hpp&quot;
  36 #include &quot;memory/universe.hpp&quot;
  37 #include &quot;nativeInst_s390.hpp&quot;
  38 #include &quot;oops/objArrayKlass.hpp&quot;
  39 #include &quot;runtime/frame.inline.hpp&quot;
  40 #include &quot;runtime/safepointMechanism.inline.hpp&quot;
  41 #include &quot;runtime/sharedRuntime.hpp&quot;
  42 #include &quot;utilities/powerOfTwo.hpp&quot;
  43 #include &quot;vmreg_s390.inline.hpp&quot;
  44 
  45 #define __ _masm-&gt;
  46 
  47 #ifndef PRODUCT
  48 #undef __
  49 #define __ (Verbose ? (_masm-&gt;block_comment(FILE_AND_LINE),_masm) : _masm)-&gt;
  50 #endif
  51 
  52 //------------------------------------------------------------
  53 
  54 bool LIR_Assembler::is_small_constant(LIR_Opr opr) {
  55   // Not used on ZARCH_64
  56   ShouldNotCallThis();
  57   return false;
  58 }
  59 
  60 LIR_Opr LIR_Assembler::receiverOpr() {
  61   return FrameMap::Z_R2_oop_opr;
  62 }
  63 
  64 LIR_Opr LIR_Assembler::osrBufferPointer() {
  65   return FrameMap::Z_R2_opr;
  66 }
  67 
  68 int LIR_Assembler::initial_frame_size_in_bytes() const {
  69   return in_bytes(frame_map()-&gt;framesize_in_bytes());
  70 }
  71 
  72 // Inline cache check: done before the frame is built.
  73 // The inline cached class is in Z_inline_cache(Z_R9).
  74 // We fetch the class of the receiver and compare it with the cached class.
  75 // If they do not match we jump to the slow case.
  76 int LIR_Assembler::check_icache() {
  77   Register receiver = receiverOpr()-&gt;as_register();
  78   int offset = __ offset();
  79   __ inline_cache_check(receiver, Z_inline_cache);
  80   return offset;
  81 }
  82 
  83 void LIR_Assembler::clinit_barrier(ciMethod* method) {
  84   assert(!method-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);
  85 
  86   Label L_skip_barrier;
  87   Register klass = Z_R1_scratch;
  88 
  89   metadata2reg(method-&gt;holder()-&gt;constant_encoding(), klass);
  90   __ clinit_barrier(klass, Z_thread, &amp;L_skip_barrier /*L_fast_path*/);
  91 
  92   __ load_const_optimized(klass, SharedRuntime::get_handle_wrong_method_stub());
  93   __ z_br(klass);
  94 
  95   __ bind(L_skip_barrier);
  96 }
  97 
  98 void LIR_Assembler::osr_entry() {
  99   // On-stack-replacement entry sequence (interpreter frame layout described in interpreter_sparc.cpp):
 100   //
 101   //   1. Create a new compiled activation.
 102   //   2. Initialize local variables in the compiled activation. The expression stack must be empty
 103   //      at the osr_bci; it is not initialized.
 104   //   3. Jump to the continuation address in compiled code to resume execution.
 105 
 106   // OSR entry point
 107   offsets()-&gt;set_value(CodeOffsets::OSR_Entry, code_offset());
 108   BlockBegin* osr_entry = compilation()-&gt;hir()-&gt;osr_entry();
 109   ValueStack* entry_state = osr_entry-&gt;end()-&gt;state();
 110   int number_of_locks = entry_state-&gt;locks_size();
 111 
 112   // Create a frame for the compiled activation.
 113   __ build_frame(initial_frame_size_in_bytes(), bang_size_in_bytes());
 114 
 115   // OSR buffer is
 116   //
 117   // locals[nlocals-1..0]
 118   // monitors[number_of_locks-1..0]
 119   //
 120   // Locals is a direct copy of the interpreter frame so in the osr buffer
 121   // the first slot in the local array is the last local from the interpreter
 122   // and the last slot is local[0] (receiver) from the interpreter
 123   //
 124   // Similarly with locks. The first lock slot in the osr buffer is the nth lock
 125   // from the interpreter frame, the nth lock slot in the osr buffer is 0th lock
 126   // in the interpreter frame (the method lock if a sync method)
 127 
 128   // Initialize monitors in the compiled activation.
 129   //   I0: pointer to osr buffer
 130   //
 131   // All other registers are dead at this point and the locals will be
 132   // copied into place by code emitted in the IR.
 133 
 134   Register OSR_buf = osrBufferPointer()-&gt;as_register();
 135   { assert(frame::interpreter_frame_monitor_size() == BasicObjectLock::size(), &quot;adjust code below&quot;);
 136     int monitor_offset = BytesPerWord * method()-&gt;max_locals() +
 137       (2 * BytesPerWord) * (number_of_locks - 1);
 138     // SharedRuntime::OSR_migration_begin() packs BasicObjectLocks in
 139     // the OSR buffer using 2 word entries: first the lock and then
 140     // the oop.
 141     for (int i = 0; i &lt; number_of_locks; i++) {
 142       int slot_offset = monitor_offset - ((i * 2) * BytesPerWord);
 143       // Verify the interpreter&#39;s monitor has a non-null object.
 144       __ asm_assert_mem8_isnot_zero(slot_offset + 1*BytesPerWord, OSR_buf, &quot;locked object is NULL&quot;, __LINE__);
 145       // Copy the lock field into the compiled activation.
 146       __ z_lg(Z_R1_scratch, slot_offset + 0, OSR_buf);
 147       __ z_stg(Z_R1_scratch, frame_map()-&gt;address_for_monitor_lock(i));
 148       __ z_lg(Z_R1_scratch, slot_offset + 1*BytesPerWord, OSR_buf);
 149       __ z_stg(Z_R1_scratch, frame_map()-&gt;address_for_monitor_object(i));
 150     }
 151   }
 152 }
 153 
 154 // --------------------------------------------------------------------------------------------
 155 
 156 address LIR_Assembler::emit_call_c(address a) {
 157   __ align_call_far_patchable(__ pc());
 158   address call_addr = __ call_c_opt(a);
 159   if (call_addr == NULL) {
 160     bailout(&quot;const section overflow&quot;);
 161   }
 162   return call_addr;
 163 }
 164 
 165 int LIR_Assembler::emit_exception_handler() {
 166   // If the last instruction is a call (typically to do a throw which
 167   // is coming at the end after block reordering) the return address
 168   // must still point into the code area in order to avoid assertion
 169   // failures when searching for the corresponding bci. =&gt; Add a nop.
 170   // (was bug 5/14/1999 - gri)
 171   __ nop();
 172 
 173   // Generate code for exception handler.
 174   address handler_base = __ start_a_stub(exception_handler_size());
 175   if (handler_base == NULL) {
 176     // Not enough space left for the handler.
 177     bailout(&quot;exception handler overflow&quot;);
 178     return -1;
 179   }
 180 
 181   int offset = code_offset();
 182 
 183   address a = Runtime1::entry_for (Runtime1::handle_exception_from_callee_id);
 184   address call_addr = emit_call_c(a);
 185   CHECK_BAILOUT_(-1);
 186   __ should_not_reach_here();
 187   guarantee(code_offset() - offset &lt;= exception_handler_size(), &quot;overflow&quot;);
 188   __ end_a_stub();
 189 
 190   return offset;
 191 }
 192 
 193 // Emit the code to remove the frame from the stack in the exception
 194 // unwind path.
 195 int LIR_Assembler::emit_unwind_handler() {
 196 #ifndef PRODUCT
 197   if (CommentedAssembly) {
 198     _masm-&gt;block_comment(&quot;Unwind handler&quot;);
 199   }
 200 #endif
 201 
 202   int offset = code_offset();
 203   Register exception_oop_callee_saved = Z_R10; // Z_R10 is callee-saved.
 204   Register Rtmp1                      = Z_R11;
 205   Register Rtmp2                      = Z_R12;
 206 
 207   // Fetch the exception from TLS and clear out exception related thread state.
 208   Address exc_oop_addr = Address(Z_thread, JavaThread::exception_oop_offset());
 209   Address exc_pc_addr  = Address(Z_thread, JavaThread::exception_pc_offset());
 210   __ z_lg(Z_EXC_OOP, exc_oop_addr);
 211   __ clear_mem(exc_oop_addr, sizeof(oop));
 212   __ clear_mem(exc_pc_addr, sizeof(intptr_t));
 213 
 214   __ bind(_unwind_handler_entry);
 215   __ verify_not_null_oop(Z_EXC_OOP);
 216   if (method()-&gt;is_synchronized() || compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 217     __ lgr_if_needed(exception_oop_callee_saved, Z_EXC_OOP); // Preserve the exception.
 218   }
 219 
 220   // Preform needed unlocking.
 221   MonitorExitStub* stub = NULL;
 222   if (method()-&gt;is_synchronized()) {
 223     // Runtime1::monitorexit_id expects lock address in Z_R1_scratch.
 224     LIR_Opr lock = FrameMap::as_opr(Z_R1_scratch);
 225     monitor_address(0, lock);
 226     stub = new MonitorExitStub(lock, true, 0);
 227     __ unlock_object(Rtmp1, Rtmp2, lock-&gt;as_register(), *stub-&gt;entry());
 228     __ bind(*stub-&gt;continuation());
 229   }
 230 
 231   if (compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 232     ShouldNotReachHere(); // Not supported.
 233 #if 0
 234     __ mov(rdi, r15_thread);
 235     __ mov_metadata(rsi, method()-&gt;constant_encoding());
 236     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_exit)));
 237 #endif
 238   }
 239 
 240   if (method()-&gt;is_synchronized() || compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 241     __ lgr_if_needed(Z_EXC_OOP, exception_oop_callee_saved);  // Restore the exception.
 242   }
 243 
 244   // Remove the activation and dispatch to the unwind handler.
 245   __ pop_frame();
 246   __ z_lg(Z_EXC_PC, _z_abi16(return_pc), Z_SP);
 247 
 248   // Z_EXC_OOP: exception oop
 249   // Z_EXC_PC: exception pc
 250 
 251   // Dispatch to the unwind logic.
 252   __ load_const_optimized(Z_R5, Runtime1::entry_for (Runtime1::unwind_exception_id));
 253   __ z_br(Z_R5);
 254 
 255   // Emit the slow path assembly.
 256   if (stub != NULL) {
 257     stub-&gt;emit_code(this);
 258   }
 259 
 260   return offset;
 261 }
 262 
 263 int LIR_Assembler::emit_deopt_handler() {
 264   // If the last instruction is a call (typically to do a throw which
 265   // is coming at the end after block reordering) the return address
 266   // must still point into the code area in order to avoid assertion
 267   // failures when searching for the corresponding bci. =&gt; Add a nop.
 268   // (was bug 5/14/1999 - gri)
 269   __ nop();
 270 
 271   // Generate code for exception handler.
 272   address handler_base = __ start_a_stub(deopt_handler_size());
 273   if (handler_base == NULL) {
 274     // Not enough space left for the handler.
 275     bailout(&quot;deopt handler overflow&quot;);
 276     return -1;
 277   }  int offset = code_offset();
 278   // Size must be constant (see HandlerImpl::emit_deopt_handler).
 279   __ load_const(Z_R1_scratch, SharedRuntime::deopt_blob()-&gt;unpack());
 280   __ call(Z_R1_scratch);
 281   guarantee(code_offset() - offset &lt;= deopt_handler_size(), &quot;overflow&quot;);
 282   __ end_a_stub();
 283 
 284   return offset;
 285 }
 286 
 287 void LIR_Assembler::jobject2reg(jobject o, Register reg) {
 288   if (o == NULL) {
 289     __ clear_reg(reg, true/*64bit*/, false/*set cc*/); // Must not kill cc set by cmove.
 290   } else {
 291     AddressLiteral a = __ allocate_oop_address(o);
 292     bool success = __ load_oop_from_toc(reg, a, reg);
 293     if (!success) {
 294       bailout(&quot;const section overflow&quot;);
 295     }
 296   }
 297 }
 298 
 299 void LIR_Assembler::jobject2reg_with_patching(Register reg, CodeEmitInfo *info) {
 300   // Allocate a new index in table to hold the object once it&#39;s been patched.
 301   int oop_index = __ oop_recorder()-&gt;allocate_oop_index(NULL);
 302   PatchingStub* patch = new PatchingStub(_masm, patching_id(info), oop_index);
 303 
 304   AddressLiteral addrlit((intptr_t)0, oop_Relocation::spec(oop_index));
 305   assert(addrlit.rspec().type() == relocInfo::oop_type, &quot;must be an oop reloc&quot;);
 306   // The NULL will be dynamically patched later so the sequence to
 307   // load the address literal must not be optimized.
 308   __ load_const(reg, addrlit);
 309 
 310   patching_epilog(patch, lir_patch_normal, reg, info);
 311 }
 312 
 313 void LIR_Assembler::metadata2reg(Metadata* md, Register reg) {
 314   bool success = __ set_metadata_constant(md, reg);
 315   if (!success) {
 316     bailout(&quot;const section overflow&quot;);
 317     return;
 318   }
 319 }
 320 
 321 void LIR_Assembler::klass2reg_with_patching(Register reg, CodeEmitInfo *info) {
 322   // Allocate a new index in table to hold the klass once it&#39;s been patched.
 323   int index = __ oop_recorder()-&gt;allocate_metadata_index(NULL);
 324   PatchingStub* patch = new PatchingStub(_masm, PatchingStub::load_klass_id, index);
 325   AddressLiteral addrlit((intptr_t)0, metadata_Relocation::spec(index));
 326   assert(addrlit.rspec().type() == relocInfo::metadata_type, &quot;must be an metadata reloc&quot;);
 327   // The NULL will be dynamically patched later so the sequence to
 328   // load the address literal must not be optimized.
 329   __ load_const(reg, addrlit);
 330 
 331   patching_epilog(patch, lir_patch_normal, reg, info);
 332 }
 333 
 334 void LIR_Assembler::emit_op3(LIR_Op3* op) {
 335   switch (op-&gt;code()) {
 336     case lir_idiv:
 337     case lir_irem:
 338       arithmetic_idiv(op-&gt;code(),
 339                       op-&gt;in_opr1(),
 340                       op-&gt;in_opr2(),
 341                       op-&gt;in_opr3(),
 342                       op-&gt;result_opr(),
 343                       op-&gt;info());
 344       break;
 345     case lir_fmad: {
 346       const FloatRegister opr1 = op-&gt;in_opr1()-&gt;as_double_reg(),
 347                           opr2 = op-&gt;in_opr2()-&gt;as_double_reg(),
 348                           opr3 = op-&gt;in_opr3()-&gt;as_double_reg(),
 349                           res  = op-&gt;result_opr()-&gt;as_double_reg();
 350       __ z_madbr(opr3, opr1, opr2);
 351       if (res != opr3) { __ z_ldr(res, opr3); }
 352     } break;
 353     case lir_fmaf: {
 354       const FloatRegister opr1 = op-&gt;in_opr1()-&gt;as_float_reg(),
 355                           opr2 = op-&gt;in_opr2()-&gt;as_float_reg(),
 356                           opr3 = op-&gt;in_opr3()-&gt;as_float_reg(),
 357                           res  = op-&gt;result_opr()-&gt;as_float_reg();
 358       __ z_maebr(opr3, opr1, opr2);
 359       if (res != opr3) { __ z_ler(res, opr3); }
 360     } break;
 361     default: ShouldNotReachHere(); break;
 362   }
 363 }
 364 
 365 
 366 void LIR_Assembler::emit_opBranch(LIR_OpBranch* op) {
 367 #ifdef ASSERT
 368   assert(op-&gt;block() == NULL || op-&gt;block()-&gt;label() == op-&gt;label(), &quot;wrong label&quot;);
 369   if (op-&gt;block() != NULL)  { _branch_target_blocks.append(op-&gt;block()); }
 370   if (op-&gt;ublock() != NULL) { _branch_target_blocks.append(op-&gt;ublock()); }
 371 #endif
 372 
 373   if (op-&gt;cond() == lir_cond_always) {
 374     if (op-&gt;info() != NULL) { add_debug_info_for_branch(op-&gt;info()); }
 375     __ branch_optimized(Assembler::bcondAlways, *(op-&gt;label()));
 376   } else {
 377     Assembler::branch_condition acond = Assembler::bcondZero;
 378     if (op-&gt;code() == lir_cond_float_branch) {
 379       assert(op-&gt;ublock() != NULL, &quot;must have unordered successor&quot;);
 380       __ branch_optimized(Assembler::bcondNotOrdered, *(op-&gt;ublock()-&gt;label()));
 381     }
 382     switch (op-&gt;cond()) {
 383       case lir_cond_equal:        acond = Assembler::bcondEqual;     break;
 384       case lir_cond_notEqual:     acond = Assembler::bcondNotEqual;  break;
 385       case lir_cond_less:         acond = Assembler::bcondLow;       break;
 386       case lir_cond_lessEqual:    acond = Assembler::bcondNotHigh;   break;
 387       case lir_cond_greaterEqual: acond = Assembler::bcondNotLow;    break;
 388       case lir_cond_greater:      acond = Assembler::bcondHigh;      break;
 389       case lir_cond_belowEqual:   acond = Assembler::bcondNotHigh;   break;
 390       case lir_cond_aboveEqual:   acond = Assembler::bcondNotLow;    break;
 391       default:                         ShouldNotReachHere();
 392     }
 393     __ branch_optimized(acond,*(op-&gt;label()));
 394   }
 395 }
 396 
 397 
 398 void LIR_Assembler::emit_opConvert(LIR_OpConvert* op) {
 399   LIR_Opr src  = op-&gt;in_opr();
 400   LIR_Opr dest = op-&gt;result_opr();
 401 
 402   switch (op-&gt;bytecode()) {
 403     case Bytecodes::_i2l:
 404       __ move_reg_if_needed(dest-&gt;as_register_lo(), T_LONG, src-&gt;as_register(), T_INT);
 405       break;
 406 
 407     case Bytecodes::_l2i:
 408       __ move_reg_if_needed(dest-&gt;as_register(), T_INT, src-&gt;as_register_lo(), T_LONG);
 409       break;
 410 
 411     case Bytecodes::_i2b:
 412       __ move_reg_if_needed(dest-&gt;as_register(), T_BYTE, src-&gt;as_register(), T_INT);
 413       break;
 414 
 415     case Bytecodes::_i2c:
 416       __ move_reg_if_needed(dest-&gt;as_register(), T_CHAR, src-&gt;as_register(), T_INT);
 417       break;
 418 
 419     case Bytecodes::_i2s:
 420       __ move_reg_if_needed(dest-&gt;as_register(), T_SHORT, src-&gt;as_register(), T_INT);
 421       break;
 422 
 423     case Bytecodes::_f2d:
 424       assert(dest-&gt;is_double_fpu(), &quot;check&quot;);
 425       __ move_freg_if_needed(dest-&gt;as_double_reg(), T_DOUBLE, src-&gt;as_float_reg(), T_FLOAT);
 426       break;
 427 
 428     case Bytecodes::_d2f:
 429       assert(dest-&gt;is_single_fpu(), &quot;check&quot;);
 430       __ move_freg_if_needed(dest-&gt;as_float_reg(), T_FLOAT, src-&gt;as_double_reg(), T_DOUBLE);
 431       break;
 432 
 433     case Bytecodes::_i2f:
 434       __ z_cefbr(dest-&gt;as_float_reg(), src-&gt;as_register());
 435       break;
 436 
 437     case Bytecodes::_i2d:
 438       __ z_cdfbr(dest-&gt;as_double_reg(), src-&gt;as_register());
 439       break;
 440 
 441     case Bytecodes::_l2f:
 442       __ z_cegbr(dest-&gt;as_float_reg(), src-&gt;as_register_lo());
 443       break;
 444     case Bytecodes::_l2d:
 445       __ z_cdgbr(dest-&gt;as_double_reg(), src-&gt;as_register_lo());
 446       break;
 447 
 448     case Bytecodes::_f2i:
 449     case Bytecodes::_f2l: {
 450       Label done;
 451       FloatRegister Rsrc = src-&gt;as_float_reg();
 452       Register Rdst = (op-&gt;bytecode() == Bytecodes::_f2i ? dest-&gt;as_register() : dest-&gt;as_register_lo());
 453       __ clear_reg(Rdst, true, false);
 454       __ z_cebr(Rsrc, Rsrc);
 455       __ z_brno(done); // NaN -&gt; 0
 456       if (op-&gt;bytecode() == Bytecodes::_f2i) {
 457         __ z_cfebr(Rdst, Rsrc, Assembler::to_zero);
 458       } else { // op-&gt;bytecode() == Bytecodes::_f2l
 459         __ z_cgebr(Rdst, Rsrc, Assembler::to_zero);
 460       }
 461       __ bind(done);
 462     }
 463     break;
 464 
 465     case Bytecodes::_d2i:
 466     case Bytecodes::_d2l: {
 467       Label done;
 468       FloatRegister Rsrc = src-&gt;as_double_reg();
 469       Register Rdst = (op-&gt;bytecode() == Bytecodes::_d2i ? dest-&gt;as_register() : dest-&gt;as_register_lo());
 470       __ clear_reg(Rdst, true, false);  // Don&#39;t set CC.
 471       __ z_cdbr(Rsrc, Rsrc);
 472       __ z_brno(done); // NaN -&gt; 0
 473       if (op-&gt;bytecode() == Bytecodes::_d2i) {
 474         __ z_cfdbr(Rdst, Rsrc, Assembler::to_zero);
 475       } else { // Bytecodes::_d2l
 476         __ z_cgdbr(Rdst, Rsrc, Assembler::to_zero);
 477       }
 478       __ bind(done);
 479     }
 480     break;
 481 
 482     default: ShouldNotReachHere();
 483   }
 484 }
 485 
 486 void LIR_Assembler::align_call(LIR_Code code) {
 487   // End of call instruction must be 4 byte aligned.
 488   int offset = __ offset();
 489   switch (code) {
 490     case lir_icvirtual_call:
 491       offset += MacroAssembler::load_const_from_toc_size();
 492       // no break
 493     case lir_static_call:
 494     case lir_optvirtual_call:
 495     case lir_dynamic_call:
 496       offset += NativeCall::call_far_pcrelative_displacement_offset;
 497       break;
 498     case lir_virtual_call:   // currently, sparc-specific for niagara
 499     default: ShouldNotReachHere();
 500   }
 501   if ((offset &amp; (NativeCall::call_far_pcrelative_displacement_alignment-1)) != 0) {
 502     __ nop();
 503   }
 504 }
 505 
 506 void LIR_Assembler::call(LIR_OpJavaCall* op, relocInfo::relocType rtype) {
 507   assert((__ offset() + NativeCall::call_far_pcrelative_displacement_offset) % NativeCall::call_far_pcrelative_displacement_alignment == 0,
 508          &quot;must be aligned (offset=%d)&quot;, __ offset());
 509   assert(rtype == relocInfo::none ||
 510          rtype == relocInfo::opt_virtual_call_type ||
 511          rtype == relocInfo::static_call_type, &quot;unexpected rtype&quot;);
 512   // Prepend each BRASL with a nop.
 513   __ relocate(rtype);
 514   __ z_nop();
 515   __ z_brasl(Z_R14, op-&gt;addr());
 516   add_call_info(code_offset(), op-&gt;info());
 517 }
 518 
 519 void LIR_Assembler::ic_call(LIR_OpJavaCall* op) {
 520   address virtual_call_oop_addr = NULL;
 521   AddressLiteral empty_ic((address) Universe::non_oop_word());
 522   virtual_call_oop_addr = __ pc();
 523   bool success = __ load_const_from_toc(Z_inline_cache, empty_ic);
 524   if (!success) {
 525     bailout(&quot;const section overflow&quot;);
 526     return;
 527   }
 528 
 529   // CALL to fixup routine. Fixup routine uses ScopeDesc info
 530   // to determine who we intended to call.
 531   __ relocate(virtual_call_Relocation::spec(virtual_call_oop_addr));
 532   call(op, relocInfo::none);
 533 }
 534 
 535 // not supported
 536 void LIR_Assembler::vtable_call(LIR_OpJavaCall* op) {
 537   ShouldNotReachHere();
 538 }
 539 
 540 void LIR_Assembler::move_regs(Register from_reg, Register to_reg) {
 541   if (from_reg != to_reg) __ z_lgr(to_reg, from_reg);
 542 }
 543 
 544 void LIR_Assembler::const2stack(LIR_Opr src, LIR_Opr dest) {
 545   assert(src-&gt;is_constant(), &quot;should not call otherwise&quot;);
 546   assert(dest-&gt;is_stack(), &quot;should not call otherwise&quot;);
 547   LIR_Const* c = src-&gt;as_constant_ptr();
 548 
 549   unsigned int lmem = 0;
 550   unsigned int lcon = 0;
 551   int64_t cbits = 0;
 552   Address dest_addr;
 553   switch (c-&gt;type()) {
 554     case T_INT:  // fall through
 555     case T_FLOAT:
 556       dest_addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 557       lmem = 4; lcon = 4; cbits = c-&gt;as_jint_bits();
 558       break;
 559 
 560     case T_ADDRESS:
 561       dest_addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 562       lmem = 8; lcon = 4; cbits = c-&gt;as_jint_bits();
 563       break;
 564 
 565     case T_OBJECT:
 566       dest_addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 567       if (c-&gt;as_jobject() == NULL) {
 568         __ store_const(dest_addr, (int64_t)NULL_WORD, 8, 8);
 569       } else {
 570         jobject2reg(c-&gt;as_jobject(), Z_R1_scratch);
 571         __ reg2mem_opt(Z_R1_scratch, dest_addr, true);
 572       }
 573       return;
 574 
 575     case T_LONG:  // fall through
 576     case T_DOUBLE:
 577       dest_addr = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix());
 578       lmem = 8; lcon = 8; cbits = (int64_t)(c-&gt;as_jlong_bits());
 579       break;
 580 
 581     default:
 582       ShouldNotReachHere();
 583   }
 584 
 585   __ store_const(dest_addr, cbits, lmem, lcon);
 586 }
 587 
 588 void LIR_Assembler::const2mem(LIR_Opr src, LIR_Opr dest, BasicType type, CodeEmitInfo* info, bool wide) {
 589   assert(src-&gt;is_constant(), &quot;should not call otherwise&quot;);
 590   assert(dest-&gt;is_address(), &quot;should not call otherwise&quot;);
 591 
 592   LIR_Const* c = src-&gt;as_constant_ptr();
 593   Address addr = as_Address(dest-&gt;as_address_ptr());
 594 
 595   int store_offset = -1;
 596 
 597   if (dest-&gt;as_address_ptr()-&gt;index()-&gt;is_valid()) {
 598     switch (type) {
 599       case T_INT:    // fall through
 600       case T_FLOAT:
 601         __ load_const_optimized(Z_R0_scratch, c-&gt;as_jint_bits());
 602         store_offset = __ offset();
 603         if (Immediate::is_uimm12(addr.disp())) {
 604           __ z_st(Z_R0_scratch, addr);
 605         } else {
 606           __ z_sty(Z_R0_scratch, addr);
 607         }
 608         break;
 609 
 610       case T_ADDRESS:
 611         __ load_const_optimized(Z_R1_scratch, c-&gt;as_jint_bits());
 612         store_offset = __ reg2mem_opt(Z_R1_scratch, addr, true);
 613         break;
 614 
 615       case T_OBJECT:  // fall through
 616       case T_ARRAY:
 617         if (c-&gt;as_jobject() == NULL) {
 618           if (UseCompressedOops &amp;&amp; !wide) {
 619             __ clear_reg(Z_R1_scratch, false);
 620             store_offset = __ reg2mem_opt(Z_R1_scratch, addr, false);
 621           } else {
 622             __ clear_reg(Z_R1_scratch, true);
 623             store_offset = __ reg2mem_opt(Z_R1_scratch, addr, true);
 624           }
 625         } else {
 626           jobject2reg(c-&gt;as_jobject(), Z_R1_scratch);
 627           if (UseCompressedOops &amp;&amp; !wide) {
 628             __ encode_heap_oop(Z_R1_scratch);
 629             store_offset = __ reg2mem_opt(Z_R1_scratch, addr, false);
 630           } else {
 631             store_offset = __ reg2mem_opt(Z_R1_scratch, addr, true);
 632           }
 633         }
 634         assert(store_offset &gt;= 0, &quot;check&quot;);
 635         break;
 636 
 637       case T_LONG:    // fall through
 638       case T_DOUBLE:
 639         __ load_const_optimized(Z_R1_scratch, (int64_t)(c-&gt;as_jlong_bits()));
 640         store_offset = __ reg2mem_opt(Z_R1_scratch, addr, true);
 641         break;
 642 
 643       case T_BOOLEAN: // fall through
 644       case T_BYTE:
 645         __ load_const_optimized(Z_R0_scratch, (int8_t)(c-&gt;as_jint()));
 646         store_offset = __ offset();
 647         if (Immediate::is_uimm12(addr.disp())) {
 648           __ z_stc(Z_R0_scratch, addr);
 649         } else {
 650           __ z_stcy(Z_R0_scratch, addr);
 651         }
 652         break;
 653 
 654       case T_CHAR:    // fall through
 655       case T_SHORT:
 656         __ load_const_optimized(Z_R0_scratch, (int16_t)(c-&gt;as_jint()));
 657         store_offset = __ offset();
 658         if (Immediate::is_uimm12(addr.disp())) {
 659           __ z_sth(Z_R0_scratch, addr);
 660         } else {
 661           __ z_sthy(Z_R0_scratch, addr);
 662         }
 663         break;
 664 
 665       default:
 666         ShouldNotReachHere();
 667     }
 668 
 669   } else { // no index
 670 
 671     unsigned int lmem = 0;
 672     unsigned int lcon = 0;
 673     int64_t cbits = 0;
 674 
 675     switch (type) {
 676       case T_INT:    // fall through
 677       case T_FLOAT:
 678         lmem = 4; lcon = 4; cbits = c-&gt;as_jint_bits();
 679         break;
 680 
 681       case T_ADDRESS:
 682         lmem = 8; lcon = 4; cbits = c-&gt;as_jint_bits();
 683         break;
 684 
 685       case T_OBJECT:  // fall through
 686       case T_ARRAY:
 687         if (c-&gt;as_jobject() == NULL) {
 688           if (UseCompressedOops &amp;&amp; !wide) {
 689             store_offset = __ store_const(addr, (int32_t)NULL_WORD, 4, 4);
 690           } else {
 691             store_offset = __ store_const(addr, (int64_t)NULL_WORD, 8, 8);
 692           }
 693         } else {
 694           jobject2reg(c-&gt;as_jobject(), Z_R1_scratch);
 695           if (UseCompressedOops &amp;&amp; !wide) {
 696             __ encode_heap_oop(Z_R1_scratch);
 697             store_offset = __ reg2mem_opt(Z_R1_scratch, addr, false);
 698           } else {
 699             store_offset = __ reg2mem_opt(Z_R1_scratch, addr, true);
 700           }
 701         }
 702         assert(store_offset &gt;= 0, &quot;check&quot;);
 703         break;
 704 
 705       case T_LONG:    // fall through
 706       case T_DOUBLE:
 707         lmem = 8; lcon = 8; cbits = (int64_t)(c-&gt;as_jlong_bits());
 708         break;
 709 
 710       case T_BOOLEAN: // fall through
 711       case T_BYTE:
 712         lmem = 1; lcon = 1; cbits = (int8_t)(c-&gt;as_jint());
 713         break;
 714 
 715       case T_CHAR:    // fall through
 716       case T_SHORT:
 717         lmem = 2; lcon = 2; cbits = (int16_t)(c-&gt;as_jint());
 718         break;
 719 
 720       default:
 721         ShouldNotReachHere();
 722     }
 723 
 724     if (store_offset == -1) {
 725       store_offset = __ store_const(addr, cbits, lmem, lcon);
 726       assert(store_offset &gt;= 0, &quot;check&quot;);
 727     }
 728   }
 729 
 730   if (info != NULL) {
 731     add_debug_info_for_null_check(store_offset, info);
 732   }
 733 }
 734 
 735 void LIR_Assembler::const2reg(LIR_Opr src, LIR_Opr dest, LIR_PatchCode patch_code, CodeEmitInfo* info) {
 736   assert(src-&gt;is_constant(), &quot;should not call otherwise&quot;);
 737   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
 738   LIR_Const* c = src-&gt;as_constant_ptr();
 739 
 740   switch (c-&gt;type()) {
 741     case T_INT: {
 742       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 743       __ load_const_optimized(dest-&gt;as_register(), c-&gt;as_jint());
 744       break;
 745     }
 746 
 747     case T_ADDRESS: {
 748       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 749       __ load_const_optimized(dest-&gt;as_register(), c-&gt;as_jint());
 750       break;
 751     }
 752 
 753     case T_LONG: {
 754       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 755       __ load_const_optimized(dest-&gt;as_register_lo(), (intptr_t)c-&gt;as_jlong());
 756       break;
 757     }
 758 
 759     case T_OBJECT: {
 760       if (patch_code != lir_patch_none) {
 761         jobject2reg_with_patching(dest-&gt;as_register(), info);
 762       } else {
 763         jobject2reg(c-&gt;as_jobject(), dest-&gt;as_register());
 764       }
 765       break;
 766     }
 767 
 768     case T_METADATA: {
 769       if (patch_code != lir_patch_none) {
 770         klass2reg_with_patching(dest-&gt;as_register(), info);
 771       } else {
 772         metadata2reg(c-&gt;as_metadata(), dest-&gt;as_register());
 773       }
 774       break;
 775     }
 776 
 777     case T_FLOAT: {
 778       Register toc_reg = Z_R1_scratch;
 779       __ load_toc(toc_reg);
 780       address const_addr = __ float_constant(c-&gt;as_jfloat());
 781       if (const_addr == NULL) {
 782         bailout(&quot;const section overflow&quot;);
 783         break;
 784       }
 785       int displ = const_addr - _masm-&gt;code()-&gt;consts()-&gt;start();
 786       if (dest-&gt;is_single_fpu()) {
 787         __ z_ley(dest-&gt;as_float_reg(), displ, toc_reg);
 788       } else {
 789         assert(dest-&gt;is_single_cpu(), &quot;Must be a cpu register.&quot;);
 790         __ z_ly(dest-&gt;as_register(), displ, toc_reg);
 791       }
 792     }
 793     break;
 794 
 795     case T_DOUBLE: {
 796       Register toc_reg = Z_R1_scratch;
 797       __ load_toc(toc_reg);
 798       address const_addr = __ double_constant(c-&gt;as_jdouble());
 799       if (const_addr == NULL) {
 800         bailout(&quot;const section overflow&quot;);
 801         break;
 802       }
 803       int displ = const_addr - _masm-&gt;code()-&gt;consts()-&gt;start();
 804       if (dest-&gt;is_double_fpu()) {
 805         __ z_ldy(dest-&gt;as_double_reg(), displ, toc_reg);
 806       } else {
 807         assert(dest-&gt;is_double_cpu(), &quot;Must be a long register.&quot;);
 808         __ z_lg(dest-&gt;as_register_lo(), displ, toc_reg);
 809       }
 810     }
 811     break;
 812 
 813     default:
 814       ShouldNotReachHere();
 815   }
 816 }
 817 
 818 Address LIR_Assembler::as_Address(LIR_Address* addr) {
 819   if (addr-&gt;base()-&gt;is_illegal()) {
 820     Unimplemented();
 821   }
 822 
 823   Register base = addr-&gt;base()-&gt;as_pointer_register();
 824 
 825   if (addr-&gt;index()-&gt;is_illegal()) {
 826     return Address(base, addr-&gt;disp());
 827   } else if (addr-&gt;index()-&gt;is_cpu_register()) {
 828     Register index = addr-&gt;index()-&gt;as_pointer_register();
 829     return Address(base, index, addr-&gt;disp());
 830   } else if (addr-&gt;index()-&gt;is_constant()) {
 831     intptr_t addr_offset = addr-&gt;index()-&gt;as_constant_ptr()-&gt;as_jint() + addr-&gt;disp();
 832     return Address(base, addr_offset);
 833   } else {
 834     ShouldNotReachHere();
 835     return Address();
 836   }
 837 }
 838 
 839 void LIR_Assembler::stack2stack(LIR_Opr src, LIR_Opr dest, BasicType type) {
 840   switch (type) {
 841     case T_INT:
 842     case T_FLOAT: {
 843       Register tmp = Z_R1_scratch;
 844       Address from = frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix());
 845       Address to   = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 846       __ mem2reg_opt(tmp, from, false);
 847       __ reg2mem_opt(tmp, to, false);
 848       break;
 849     }
 850     case T_ADDRESS:
 851     case T_OBJECT: {
 852       Register tmp = Z_R1_scratch;
 853       Address from = frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix());
 854       Address to   = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 855       __ mem2reg_opt(tmp, from, true);
 856       __ reg2mem_opt(tmp, to, true);
 857       break;
 858     }
 859     case T_LONG:
 860     case T_DOUBLE: {
 861       Register tmp = Z_R1_scratch;
 862       Address from = frame_map()-&gt;address_for_double_slot(src-&gt;double_stack_ix());
 863       Address to   = frame_map()-&gt;address_for_double_slot(dest-&gt;double_stack_ix());
 864       __ mem2reg_opt(tmp, from, true);
 865       __ reg2mem_opt(tmp, to, true);
 866       break;
 867     }
 868 
 869     default:
 870       ShouldNotReachHere();
 871   }
 872 }
 873 
 874 // 4-byte accesses only! Don&#39;t use it to access 8 bytes!
 875 Address LIR_Assembler::as_Address_hi(LIR_Address* addr) {
 876   ShouldNotCallThis();
 877   return 0; // unused
 878 }
 879 
 880 // 4-byte accesses only! Don&#39;t use it to access 8 bytes!
 881 Address LIR_Assembler::as_Address_lo(LIR_Address* addr) {
 882   ShouldNotCallThis();
 883   return 0; // unused
 884 }
 885 
 886 void LIR_Assembler::mem2reg(LIR_Opr src_opr, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code,
 887                             CodeEmitInfo* info, bool wide, bool unaligned) {
 888 
 889   assert(type != T_METADATA, &quot;load of metadata ptr not supported&quot;);
 890   LIR_Address* addr = src_opr-&gt;as_address_ptr();
 891   LIR_Opr to_reg = dest;
 892 
 893   Register src = addr-&gt;base()-&gt;as_pointer_register();
 894   Register disp_reg = Z_R0;
 895   int disp_value = addr-&gt;disp();
 896   bool needs_patching = (patch_code != lir_patch_none);
 897 
 898   if (addr-&gt;base()-&gt;type() == T_OBJECT) {
 899     __ verify_oop(src, FILE_AND_LINE);
 900   }
 901 
 902   PatchingStub* patch = NULL;
 903   if (needs_patching) {
 904     patch = new PatchingStub(_masm, PatchingStub::access_field_id);
 905     assert(!to_reg-&gt;is_double_cpu() ||
 906            patch_code == lir_patch_none ||
 907            patch_code == lir_patch_normal, &quot;patching doesn&#39;t match register&quot;);
 908   }
 909 
 910   if (addr-&gt;index()-&gt;is_illegal()) {
 911     if (!Immediate::is_simm20(disp_value)) {
 912       if (needs_patching) {
 913         __ load_const(Z_R1_scratch, (intptr_t)0);
 914       } else {
 915         __ load_const_optimized(Z_R1_scratch, disp_value);
 916       }
 917       disp_reg = Z_R1_scratch;
 918       disp_value = 0;
 919     }
 920   } else {
 921     if (!Immediate::is_simm20(disp_value)) {
 922       __ load_const_optimized(Z_R1_scratch, disp_value);
 923       __ z_la(Z_R1_scratch, 0, Z_R1_scratch, addr-&gt;index()-&gt;as_register());
 924       disp_reg = Z_R1_scratch;
 925       disp_value = 0;
 926     }
 927     disp_reg = addr-&gt;index()-&gt;as_pointer_register();
 928   }
 929 
 930   // Remember the offset of the load. The patching_epilog must be done
 931   // before the call to add_debug_info, otherwise the PcDescs don&#39;t get
 932   // entered in increasing order.
 933   int offset = code_offset();
 934 
 935   assert(disp_reg != Z_R0 || Immediate::is_simm20(disp_value), &quot;should have set this up&quot;);
 936 
 937   bool short_disp = Immediate::is_uimm12(disp_value);
 938 
 939   switch (type) {
 940     case T_BOOLEAN: // fall through
 941     case T_BYTE  :  __ z_lb(dest-&gt;as_register(),   disp_value, disp_reg, src); break;
 942     case T_CHAR  :  __ z_llgh(dest-&gt;as_register(), disp_value, disp_reg, src); break;
 943     case T_SHORT :
 944       if (short_disp) {
 945                     __ z_lh(dest-&gt;as_register(),   disp_value, disp_reg, src);
 946       } else {
 947                     __ z_lhy(dest-&gt;as_register(),  disp_value, disp_reg, src);
 948       }
 949       break;
 950     case T_INT   :
 951       if (short_disp) {
 952                     __ z_l(dest-&gt;as_register(),    disp_value, disp_reg, src);
 953       } else {
 954                     __ z_ly(dest-&gt;as_register(),   disp_value, disp_reg, src);
 955       }
 956       break;
 957     case T_ADDRESS:
 958       if (UseCompressedClassPointers &amp;&amp; addr-&gt;disp() == oopDesc::klass_offset_in_bytes()) {
 959         __ z_llgf(dest-&gt;as_register(), disp_value, disp_reg, src);
 960         __ decode_klass_not_null(dest-&gt;as_register());
 961       } else {
 962         __ z_lg(dest-&gt;as_register(), disp_value, disp_reg, src);
 963       }
 964       break;
 965     case T_ARRAY : // fall through
 966     case T_OBJECT:
 967     {
 968       if (UseCompressedOops &amp;&amp; !wide) {
 969         __ z_llgf(dest-&gt;as_register(), disp_value, disp_reg, src);
 970         __ oop_decoder(dest-&gt;as_register(), dest-&gt;as_register(), true);
 971       } else {
 972         __ z_lg(dest-&gt;as_register(), disp_value, disp_reg, src);
 973       }
 974       __ verify_oop(dest-&gt;as_register(), FILE_AND_LINE);
 975       break;
 976     }
 977     case T_FLOAT:
 978       if (short_disp) {
 979                     __ z_le(dest-&gt;as_float_reg(),  disp_value, disp_reg, src);
 980       } else {
 981                     __ z_ley(dest-&gt;as_float_reg(), disp_value, disp_reg, src);
 982       }
 983       break;
 984     case T_DOUBLE:
 985       if (short_disp) {
 986                     __ z_ld(dest-&gt;as_double_reg(),  disp_value, disp_reg, src);
 987       } else {
 988                     __ z_ldy(dest-&gt;as_double_reg(), disp_value, disp_reg, src);
 989       }
 990       break;
 991     case T_LONG  :  __ z_lg(dest-&gt;as_register_lo(), disp_value, disp_reg, src); break;
 992     default      : ShouldNotReachHere();
 993   }
 994 
 995   if (patch != NULL) {
 996     patching_epilog(patch, patch_code, src, info);
 997   }
 998   if (info != NULL) add_debug_info_for_null_check(offset, info);
 999 }
1000 
1001 void LIR_Assembler::stack2reg(LIR_Opr src, LIR_Opr dest, BasicType type) {
1002   assert(src-&gt;is_stack(), &quot;should not call otherwise&quot;);
1003   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
1004 
1005   if (dest-&gt;is_single_cpu()) {
1006     if (is_reference_type(type)) {
1007       __ mem2reg_opt(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()), true);
1008       __ verify_oop(dest-&gt;as_register(), FILE_AND_LINE);
1009     } else if (type == T_METADATA || type == T_ADDRESS) {
1010       __ mem2reg_opt(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()), true);
1011     } else {
1012       __ mem2reg_opt(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()), false);
1013     }
1014   } else if (dest-&gt;is_double_cpu()) {
1015     Address src_addr_LO = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix());
1016     __ mem2reg_opt(dest-&gt;as_register_lo(), src_addr_LO, true);
1017   } else if (dest-&gt;is_single_fpu()) {
1018     Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix());
1019     __ mem2freg_opt(dest-&gt;as_float_reg(), src_addr, false);
1020   } else if (dest-&gt;is_double_fpu()) {
1021     Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix());
1022     __ mem2freg_opt(dest-&gt;as_double_reg(), src_addr, true);
1023   } else {
1024     ShouldNotReachHere();
1025   }
1026 }
1027 
1028 void LIR_Assembler::reg2stack(LIR_Opr src, LIR_Opr dest, BasicType type, bool pop_fpu_stack) {
1029   assert(src-&gt;is_register(), &quot;should not call otherwise&quot;);
1030   assert(dest-&gt;is_stack(), &quot;should not call otherwise&quot;);
1031 
1032   if (src-&gt;is_single_cpu()) {
1033     const Address dst = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
1034     if (is_reference_type(type)) {
1035       __ verify_oop(src-&gt;as_register(), FILE_AND_LINE);
1036       __ reg2mem_opt(src-&gt;as_register(), dst, true);
1037     } else if (type == T_METADATA || type == T_ADDRESS) {
1038       __ reg2mem_opt(src-&gt;as_register(), dst, true);
1039     } else {
1040       __ reg2mem_opt(src-&gt;as_register(), dst, false);
1041     }
1042   } else if (src-&gt;is_double_cpu()) {
1043     Address dstLO = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix());
1044     __ reg2mem_opt(src-&gt;as_register_lo(), dstLO, true);
1045   } else if (src-&gt;is_single_fpu()) {
1046     Address dst_addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
1047     __ freg2mem_opt(src-&gt;as_float_reg(), dst_addr, false);
1048   } else if (src-&gt;is_double_fpu()) {
1049     Address dst_addr = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix());
1050     __ freg2mem_opt(src-&gt;as_double_reg(), dst_addr, true);
1051   } else {
1052     ShouldNotReachHere();
1053   }
1054 }
1055 
1056 void LIR_Assembler::reg2reg(LIR_Opr from_reg, LIR_Opr to_reg) {
1057   if (from_reg-&gt;is_float_kind() &amp;&amp; to_reg-&gt;is_float_kind()) {
1058     if (from_reg-&gt;is_double_fpu()) {
1059       // double to double moves
1060       assert(to_reg-&gt;is_double_fpu(), &quot;should match&quot;);
1061       __ z_ldr(to_reg-&gt;as_double_reg(), from_reg-&gt;as_double_reg());
1062     } else {
1063       // float to float moves
1064       assert(to_reg-&gt;is_single_fpu(), &quot;should match&quot;);
1065       __ z_ler(to_reg-&gt;as_float_reg(), from_reg-&gt;as_float_reg());
1066     }
1067   } else if (!from_reg-&gt;is_float_kind() &amp;&amp; !to_reg-&gt;is_float_kind()) {
1068     if (from_reg-&gt;is_double_cpu()) {
1069       __ z_lgr(to_reg-&gt;as_pointer_register(), from_reg-&gt;as_pointer_register());
1070     } else if (to_reg-&gt;is_double_cpu()) {
1071       // int to int moves
1072       __ z_lgr(to_reg-&gt;as_register_lo(), from_reg-&gt;as_register());
1073     } else {
1074       // int to int moves
1075       __ z_lgr(to_reg-&gt;as_register(), from_reg-&gt;as_register());
1076     }
1077   } else {
1078     ShouldNotReachHere();
1079   }
1080   if (is_reference_type(to_reg-&gt;type())) {
1081     __ verify_oop(to_reg-&gt;as_register(), FILE_AND_LINE);
1082   }
1083 }
1084 
1085 void LIR_Assembler::reg2mem(LIR_Opr from, LIR_Opr dest_opr, BasicType type,
1086                             LIR_PatchCode patch_code, CodeEmitInfo* info, bool pop_fpu_stack,
1087                             bool wide, bool unaligned) {
1088   assert(type != T_METADATA, &quot;store of metadata ptr not supported&quot;);
1089   LIR_Address* addr = dest_opr-&gt;as_address_ptr();
1090 
1091   Register dest = addr-&gt;base()-&gt;as_pointer_register();
1092   Register disp_reg = Z_R0;
1093   int disp_value = addr-&gt;disp();
1094   bool needs_patching = (patch_code != lir_patch_none);
1095 
1096   if (addr-&gt;base()-&gt;is_oop_register()) {
1097     __ verify_oop(dest, FILE_AND_LINE);
1098   }
1099 
1100   PatchingStub* patch = NULL;
1101   if (needs_patching) {
1102     patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1103     assert(!from-&gt;is_double_cpu() ||
1104            patch_code == lir_patch_none ||
1105            patch_code == lir_patch_normal, &quot;patching doesn&#39;t match register&quot;);
1106   }
1107 
1108   assert(!needs_patching || (!Immediate::is_simm20(disp_value) &amp;&amp; addr-&gt;index()-&gt;is_illegal()), &quot;assumption&quot;);
1109   if (addr-&gt;index()-&gt;is_illegal()) {
1110     if (!Immediate::is_simm20(disp_value)) {
1111       if (needs_patching) {
1112         __ load_const(Z_R1_scratch, (intptr_t)0);
1113       } else {
1114         __ load_const_optimized(Z_R1_scratch, disp_value);
1115       }
1116       disp_reg = Z_R1_scratch;
1117       disp_value = 0;
1118     }
1119   } else {
1120     if (!Immediate::is_simm20(disp_value)) {
1121       __ load_const_optimized(Z_R1_scratch, disp_value);
1122       __ z_la(Z_R1_scratch, 0, Z_R1_scratch, addr-&gt;index()-&gt;as_register());
1123       disp_reg = Z_R1_scratch;
1124       disp_value = 0;
1125     }
1126     disp_reg = addr-&gt;index()-&gt;as_pointer_register();
1127   }
1128 
1129   assert(disp_reg != Z_R0 || Immediate::is_simm20(disp_value), &quot;should have set this up&quot;);
1130 
1131   if (is_reference_type(type)) {
1132     __ verify_oop(from-&gt;as_register(), FILE_AND_LINE);
1133   }
1134 
1135   bool short_disp = Immediate::is_uimm12(disp_value);
1136 
1137   // Remember the offset of the store. The patching_epilog must be done
1138   // before the call to add_debug_info_for_null_check, otherwise the PcDescs don&#39;t get
1139   // entered in increasing order.
1140   int offset = code_offset();
1141   switch (type) {
1142     case T_BOOLEAN: // fall through
1143     case T_BYTE  :
1144       if (short_disp) {
1145                     __ z_stc(from-&gt;as_register(),  disp_value, disp_reg, dest);
1146       } else {
1147                     __ z_stcy(from-&gt;as_register(), disp_value, disp_reg, dest);
1148       }
1149       break;
1150     case T_CHAR  : // fall through
1151     case T_SHORT :
1152       if (short_disp) {
1153                     __ z_sth(from-&gt;as_register(),  disp_value, disp_reg, dest);
1154       } else {
1155                     __ z_sthy(from-&gt;as_register(), disp_value, disp_reg, dest);
1156       }
1157       break;
1158     case T_INT   :
1159       if (short_disp) {
1160                     __ z_st(from-&gt;as_register(),  disp_value, disp_reg, dest);
1161       } else {
1162                     __ z_sty(from-&gt;as_register(), disp_value, disp_reg, dest);
1163       }
1164       break;
1165     case T_LONG  :  __ z_stg(from-&gt;as_register_lo(), disp_value, disp_reg, dest); break;
1166     case T_ADDRESS: __ z_stg(from-&gt;as_register(),    disp_value, disp_reg, dest); break;
1167       break;
1168     case T_ARRAY : // fall through
1169     case T_OBJECT:
1170       {
1171         if (UseCompressedOops &amp;&amp; !wide) {
1172           Register compressed_src = Z_R14;
1173           __ oop_encoder(compressed_src, from-&gt;as_register(), true, (disp_reg != Z_R1) ? Z_R1 : Z_R0, -1, true);
1174           offset = code_offset();
1175           if (short_disp) {
1176             __ z_st(compressed_src,  disp_value, disp_reg, dest);
1177           } else {
1178             __ z_sty(compressed_src, disp_value, disp_reg, dest);
1179           }
1180         } else {
1181           __ z_stg(from-&gt;as_register(), disp_value, disp_reg, dest);
1182         }
1183         break;
1184       }
1185     case T_FLOAT :
1186       if (short_disp) {
1187         __ z_ste(from-&gt;as_float_reg(),  disp_value, disp_reg, dest);
1188       } else {
1189         __ z_stey(from-&gt;as_float_reg(), disp_value, disp_reg, dest);
1190       }
1191       break;
1192     case T_DOUBLE:
1193       if (short_disp) {
1194         __ z_std(from-&gt;as_double_reg(),  disp_value, disp_reg, dest);
1195       } else {
1196         __ z_stdy(from-&gt;as_double_reg(), disp_value, disp_reg, dest);
1197       }
1198       break;
1199     default: ShouldNotReachHere();
1200   }
1201 
1202   if (patch != NULL) {
1203     patching_epilog(patch, patch_code, dest, info);
1204   }
1205 
1206   if (info != NULL) add_debug_info_for_null_check(offset, info);
1207 }
1208 
1209 
1210 void LIR_Assembler::return_op(LIR_Opr result) {
1211   assert(result-&gt;is_illegal() ||
1212          (result-&gt;is_single_cpu() &amp;&amp; result-&gt;as_register() == Z_R2) ||
1213          (result-&gt;is_double_cpu() &amp;&amp; result-&gt;as_register_lo() == Z_R2) ||
1214          (result-&gt;is_single_fpu() &amp;&amp; result-&gt;as_float_reg() == Z_F0) ||
1215          (result-&gt;is_double_fpu() &amp;&amp; result-&gt;as_double_reg() == Z_F0), &quot;convention&quot;);
1216 
<a name="2" id="anc2"></a><span class="line-modified">1217   __ z_lg(Z_R1_scratch, Address(Z_thread, Thread::polling_page_offset()));</span>





1218 
1219   // Pop the frame before the safepoint code.
1220   __ pop_frame_restore_retPC(initial_frame_size_in_bytes());
1221 
1222   if (StackReservedPages &gt; 0 &amp;&amp; compilation()-&gt;has_reserved_stack_access()) {
1223     __ reserved_stack_check(Z_R14);
1224   }
1225 
1226   // We need to mark the code position where the load from the safepoint
1227   // polling page was emitted as relocInfo::poll_return_type here.
1228   __ relocate(relocInfo::poll_return_type);
1229   __ load_from_polling_page(Z_R1_scratch);
1230 
1231   __ z_br(Z_R14); // Return to caller.
1232 }
1233 
1234 int LIR_Assembler::safepoint_poll(LIR_Opr tmp, CodeEmitInfo* info) {
1235   const Register poll_addr = tmp-&gt;as_register_lo();
<a name="3" id="anc3"></a><span class="line-modified">1236   __ z_lg(poll_addr, Address(Z_thread, Thread::polling_page_offset()));</span>





1237   guarantee(info != NULL, &quot;Shouldn&#39;t be NULL&quot;);
1238   add_debug_info_for_branch(info);
1239   int offset = __ offset();
1240   __ relocate(relocInfo::poll_type);
1241   __ load_from_polling_page(poll_addr);
1242   return offset;
1243 }
1244 
1245 void LIR_Assembler::emit_static_call_stub() {
1246 
1247   // Stub is fixed up when the corresponding call is converted from calling
1248   // compiled code to calling interpreted code.
1249 
1250   address call_pc = __ pc();
1251   address stub = __ start_a_stub(call_stub_size());
1252   if (stub == NULL) {
1253     bailout(&quot;static call stub overflow&quot;);
1254     return;
1255   }
1256 
1257   int start = __ offset();
1258 
1259   __ relocate(static_stub_Relocation::spec(call_pc));
1260 
1261   // See also Matcher::interpreter_method_oop_reg().
1262   AddressLiteral meta = __ allocate_metadata_address(NULL);
1263   bool success = __ load_const_from_toc(Z_method, meta);
1264 
1265   __ set_inst_mark();
1266   AddressLiteral a((address)-1);
1267   success = success &amp;&amp; __ load_const_from_toc(Z_R1, a);
1268   if (!success) {
1269     bailout(&quot;const section overflow&quot;);
1270     return;
1271   }
1272 
1273   __ z_br(Z_R1);
1274   assert(__ offset() - start &lt;= call_stub_size(), &quot;stub too big&quot;);
1275   __ end_a_stub(); // Update current stubs pointer and restore insts_end.
1276 }
1277 
1278 void LIR_Assembler::comp_op(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, LIR_Op2* op) {
1279   bool unsigned_comp = condition == lir_cond_belowEqual || condition == lir_cond_aboveEqual;
1280   if (opr1-&gt;is_single_cpu()) {
1281     Register reg1 = opr1-&gt;as_register();
1282     if (opr2-&gt;is_single_cpu()) {
1283       // cpu register - cpu register
1284       if (is_reference_type(opr1-&gt;type())) {
1285         __ z_clgr(reg1, opr2-&gt;as_register());
1286       } else {
1287         assert(!is_reference_type(opr2-&gt;type()), &quot;cmp int, oop?&quot;);
1288         if (unsigned_comp) {
1289           __ z_clr(reg1, opr2-&gt;as_register());
1290         } else {
1291           __ z_cr(reg1, opr2-&gt;as_register());
1292         }
1293       }
1294     } else if (opr2-&gt;is_stack()) {
1295       // cpu register - stack
1296       if (is_reference_type(opr1-&gt;type())) {
1297         __ z_cg(reg1, frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()));
1298       } else {
1299         if (unsigned_comp) {
1300           __ z_cly(reg1, frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()));
1301         } else {
1302           __ z_cy(reg1, frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()));
1303         }
1304       }
1305     } else if (opr2-&gt;is_constant()) {
1306       // cpu register - constant
1307       LIR_Const* c = opr2-&gt;as_constant_ptr();
1308       if (c-&gt;type() == T_INT) {
1309         if (unsigned_comp) {
1310           __ z_clfi(reg1, c-&gt;as_jint());
1311         } else {
1312           __ z_cfi(reg1, c-&gt;as_jint());
1313         }
1314       } else if (c-&gt;type() == T_METADATA) {
1315         // We only need, for now, comparison with NULL for metadata.
1316         assert(condition == lir_cond_equal || condition == lir_cond_notEqual, &quot;oops&quot;);
1317         Metadata* m = c-&gt;as_metadata();
1318         if (m == NULL) {
1319           __ z_cghi(reg1, 0);
1320         } else {
1321           ShouldNotReachHere();
1322         }
1323       } else if (is_reference_type(c-&gt;type())) {
1324         // In 64bit oops are single register.
1325         jobject o = c-&gt;as_jobject();
1326         if (o == NULL) {
1327           __ z_ltgr(reg1, reg1);
1328         } else {
1329           jobject2reg(o, Z_R1_scratch);
1330           __ z_cgr(reg1, Z_R1_scratch);
1331         }
1332       } else {
1333         fatal(&quot;unexpected type: %s&quot;, basictype_to_str(c-&gt;type()));
1334       }
1335       // cpu register - address
1336     } else if (opr2-&gt;is_address()) {
1337       if (op-&gt;info() != NULL) {
1338         add_debug_info_for_null_check_here(op-&gt;info());
1339       }
1340       if (unsigned_comp) {
1341         __ z_cly(reg1, as_Address(opr2-&gt;as_address_ptr()));
1342       } else {
1343         __ z_cy(reg1, as_Address(opr2-&gt;as_address_ptr()));
1344       }
1345     } else {
1346       ShouldNotReachHere();
1347     }
1348 
1349   } else if (opr1-&gt;is_double_cpu()) {
1350     assert(!unsigned_comp, &quot;unexpected&quot;);
1351     Register xlo = opr1-&gt;as_register_lo();
1352     Register xhi = opr1-&gt;as_register_hi();
1353     if (opr2-&gt;is_double_cpu()) {
1354       __ z_cgr(xlo, opr2-&gt;as_register_lo());
1355     } else if (opr2-&gt;is_constant()) {
1356       // cpu register - constant 0
1357       assert(opr2-&gt;as_jlong() == (jlong)0, &quot;only handles zero&quot;);
1358       __ z_ltgr(xlo, xlo);
1359     } else {
1360       ShouldNotReachHere();
1361     }
1362 
1363   } else if (opr1-&gt;is_single_fpu()) {
1364     if (opr2-&gt;is_single_fpu()) {
1365       __ z_cebr(opr1-&gt;as_float_reg(), opr2-&gt;as_float_reg());
1366     } else {
1367       // stack slot
1368       Address addr = frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix());
1369       if (Immediate::is_uimm12(addr.disp())) {
1370         __ z_ceb(opr1-&gt;as_float_reg(), addr);
1371       } else {
1372         __ z_ley(Z_fscratch_1, addr);
1373         __ z_cebr(opr1-&gt;as_float_reg(), Z_fscratch_1);
1374       }
1375     }
1376   } else if (opr1-&gt;is_double_fpu()) {
1377     if (opr2-&gt;is_double_fpu()) {
1378     __ z_cdbr(opr1-&gt;as_double_reg(), opr2-&gt;as_double_reg());
1379     } else {
1380       // stack slot
1381       Address addr = frame_map()-&gt;address_for_slot(opr2-&gt;double_stack_ix());
1382       if (Immediate::is_uimm12(addr.disp())) {
1383         __ z_cdb(opr1-&gt;as_double_reg(), addr);
1384       } else {
1385         __ z_ldy(Z_fscratch_1, addr);
1386         __ z_cdbr(opr1-&gt;as_double_reg(), Z_fscratch_1);
1387       }
1388     }
1389   } else {
1390     ShouldNotReachHere();
1391   }
1392 }
1393 
1394 void LIR_Assembler::comp_fl2i(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dst, LIR_Op2* op) {
1395   Label    done;
1396   Register dreg = dst-&gt;as_register();
1397 
1398   if (code == lir_cmp_fd2i || code == lir_ucmp_fd2i) {
1399     assert((left-&gt;is_single_fpu() &amp;&amp; right-&gt;is_single_fpu()) ||
1400            (left-&gt;is_double_fpu() &amp;&amp; right-&gt;is_double_fpu()), &quot;unexpected operand types&quot;);
1401     bool is_single = left-&gt;is_single_fpu();
1402     bool is_unordered_less = (code == lir_ucmp_fd2i);
1403     FloatRegister lreg = is_single ? left-&gt;as_float_reg() : left-&gt;as_double_reg();
1404     FloatRegister rreg = is_single ? right-&gt;as_float_reg() : right-&gt;as_double_reg();
1405     if (is_single) {
1406       __ z_cebr(lreg, rreg);
1407     } else {
1408       __ z_cdbr(lreg, rreg);
1409     }
1410     if (VM_Version::has_LoadStoreConditional()) {
1411       Register one       = Z_R0_scratch;
1412       Register minus_one = Z_R1_scratch;
1413       __ z_lghi(minus_one, -1);
1414       __ z_lghi(one,  1);
1415       __ z_lghi(dreg, 0);
1416       __ z_locgr(dreg, one,       is_unordered_less ? Assembler::bcondHigh            : Assembler::bcondHighOrNotOrdered);
1417       __ z_locgr(dreg, minus_one, is_unordered_less ? Assembler::bcondLowOrNotOrdered : Assembler::bcondLow);
1418     } else {
1419       __ clear_reg(dreg, true, false);
1420       __ z_bre(done); // if (left == right) dst = 0
1421 
1422       // if (left &gt; right || ((code ~= cmpg) &amp;&amp; (left &lt;&gt; right)) dst := 1
1423       __ z_lhi(dreg, 1);
1424       __ z_brc(is_unordered_less ? Assembler::bcondHigh : Assembler::bcondHighOrNotOrdered, done);
1425 
1426       // if (left &lt; right || ((code ~= cmpl) &amp;&amp; (left &lt;&gt; right)) dst := -1
1427       __ z_lhi(dreg, -1);
1428     }
1429   } else {
1430     assert(code == lir_cmp_l2i, &quot;check&quot;);
1431     if (VM_Version::has_LoadStoreConditional()) {
1432       Register one       = Z_R0_scratch;
1433       Register minus_one = Z_R1_scratch;
1434       __ z_cgr(left-&gt;as_register_lo(), right-&gt;as_register_lo());
1435       __ z_lghi(minus_one, -1);
1436       __ z_lghi(one,  1);
1437       __ z_lghi(dreg, 0);
1438       __ z_locgr(dreg, one, Assembler::bcondHigh);
1439       __ z_locgr(dreg, minus_one, Assembler::bcondLow);
1440     } else {
1441       __ z_cgr(left-&gt;as_register_lo(), right-&gt;as_register_lo());
1442       __ z_lghi(dreg,  0);     // eq value
1443       __ z_bre(done);
1444       __ z_lghi(dreg,  1);     // gt value
1445       __ z_brh(done);
1446       __ z_lghi(dreg, -1);     // lt value
1447     }
1448   }
1449   __ bind(done);
1450 }
1451 
1452 // result = condition ? opr1 : opr2
1453 void LIR_Assembler::cmove(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, LIR_Opr result, BasicType type) {
1454   Assembler::branch_condition acond = Assembler::bcondEqual, ncond = Assembler::bcondNotEqual;
1455   switch (condition) {
1456     case lir_cond_equal:        acond = Assembler::bcondEqual;    ncond = Assembler::bcondNotEqual; break;
1457     case lir_cond_notEqual:     acond = Assembler::bcondNotEqual; ncond = Assembler::bcondEqual;    break;
1458     case lir_cond_less:         acond = Assembler::bcondLow;      ncond = Assembler::bcondNotLow;   break;
1459     case lir_cond_lessEqual:    acond = Assembler::bcondNotHigh;  ncond = Assembler::bcondHigh;     break;
1460     case lir_cond_greaterEqual: acond = Assembler::bcondNotLow;   ncond = Assembler::bcondLow;      break;
1461     case lir_cond_greater:      acond = Assembler::bcondHigh;     ncond = Assembler::bcondNotHigh;  break;
1462     case lir_cond_belowEqual:   acond = Assembler::bcondNotHigh;  ncond = Assembler::bcondHigh;     break;
1463     case lir_cond_aboveEqual:   acond = Assembler::bcondNotLow;   ncond = Assembler::bcondLow;      break;
1464     default:                    ShouldNotReachHere();
1465   }
1466 
1467   if (opr1-&gt;is_cpu_register()) {
1468     reg2reg(opr1, result);
1469   } else if (opr1-&gt;is_stack()) {
1470     stack2reg(opr1, result, result-&gt;type());
1471   } else if (opr1-&gt;is_constant()) {
1472     const2reg(opr1, result, lir_patch_none, NULL);
1473   } else {
1474     ShouldNotReachHere();
1475   }
1476 
1477   if (VM_Version::has_LoadStoreConditional() &amp;&amp; !opr2-&gt;is_constant()) {
1478     // Optimized version that does not require a branch.
1479     if (opr2-&gt;is_single_cpu()) {
1480       assert(opr2-&gt;cpu_regnr() != result-&gt;cpu_regnr(), &quot;opr2 already overwritten by previous move&quot;);
1481       __ z_locgr(result-&gt;as_register(), opr2-&gt;as_register(), ncond);
1482     } else if (opr2-&gt;is_double_cpu()) {
1483       assert(opr2-&gt;cpu_regnrLo() != result-&gt;cpu_regnrLo() &amp;&amp; opr2-&gt;cpu_regnrLo() != result-&gt;cpu_regnrHi(), &quot;opr2 already overwritten by previous move&quot;);
1484       assert(opr2-&gt;cpu_regnrHi() != result-&gt;cpu_regnrLo() &amp;&amp; opr2-&gt;cpu_regnrHi() != result-&gt;cpu_regnrHi(), &quot;opr2 already overwritten by previous move&quot;);
1485       __ z_locgr(result-&gt;as_register_lo(), opr2-&gt;as_register_lo(), ncond);
1486     } else if (opr2-&gt;is_single_stack()) {
1487       __ z_loc(result-&gt;as_register(), frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()), ncond);
1488     } else if (opr2-&gt;is_double_stack()) {
1489       __ z_locg(result-&gt;as_register_lo(), frame_map()-&gt;address_for_slot(opr2-&gt;double_stack_ix()), ncond);
1490     } else {
1491       ShouldNotReachHere();
1492     }
1493   } else {
1494     Label skip;
1495     __ z_brc(acond, skip);
1496     if (opr2-&gt;is_cpu_register()) {
1497       reg2reg(opr2, result);
1498     } else if (opr2-&gt;is_stack()) {
1499       stack2reg(opr2, result, result-&gt;type());
1500     } else if (opr2-&gt;is_constant()) {
1501       const2reg(opr2, result, lir_patch_none, NULL);
1502     } else {
1503       ShouldNotReachHere();
1504     }
1505     __ bind(skip);
1506   }
1507 }
1508 
1509 void LIR_Assembler::arith_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dest,
1510                              CodeEmitInfo* info, bool pop_fpu_stack) {
1511   assert(info == NULL, &quot;should never be used, idiv/irem and ldiv/lrem not handled by this method&quot;);
1512 
1513   if (left-&gt;is_single_cpu()) {
1514     assert(left == dest, &quot;left and dest must be equal&quot;);
1515     Register lreg = left-&gt;as_register();
1516 
1517     if (right-&gt;is_single_cpu()) {
1518       // cpu register - cpu register
1519       Register rreg = right-&gt;as_register();
1520       switch (code) {
1521         case lir_add: __ z_ar (lreg, rreg); break;
1522         case lir_sub: __ z_sr (lreg, rreg); break;
1523         case lir_mul: __ z_msr(lreg, rreg); break;
1524         default: ShouldNotReachHere();
1525       }
1526 
1527     } else if (right-&gt;is_stack()) {
1528       // cpu register - stack
1529       Address raddr = frame_map()-&gt;address_for_slot(right-&gt;single_stack_ix());
1530       switch (code) {
1531         case lir_add: __ z_ay(lreg, raddr); break;
1532         case lir_sub: __ z_sy(lreg, raddr); break;
1533         default: ShouldNotReachHere();
1534       }
1535 
1536     } else if (right-&gt;is_constant()) {
1537       // cpu register - constant
1538       jint c = right-&gt;as_constant_ptr()-&gt;as_jint();
1539       switch (code) {
1540         case lir_add: __ z_agfi(lreg, c);  break;
1541         case lir_sub: __ z_agfi(lreg, -c); break; // note: -min_jint == min_jint
1542         case lir_mul: __ z_msfi(lreg, c);  break;
1543         default: ShouldNotReachHere();
1544       }
1545 
1546     } else {
1547       ShouldNotReachHere();
1548     }
1549 
1550   } else if (left-&gt;is_double_cpu()) {
1551     assert(left == dest, &quot;left and dest must be equal&quot;);
1552     Register lreg_lo = left-&gt;as_register_lo();
1553     Register lreg_hi = left-&gt;as_register_hi();
1554 
1555     if (right-&gt;is_double_cpu()) {
1556       // cpu register - cpu register
1557       Register rreg_lo = right-&gt;as_register_lo();
1558       Register rreg_hi = right-&gt;as_register_hi();
1559       assert_different_registers(lreg_lo, rreg_lo);
1560       switch (code) {
1561         case lir_add:
1562           __ z_agr(lreg_lo, rreg_lo);
1563           break;
1564         case lir_sub:
1565           __ z_sgr(lreg_lo, rreg_lo);
1566           break;
1567         case lir_mul:
1568           __ z_msgr(lreg_lo, rreg_lo);
1569           break;
1570         default:
1571           ShouldNotReachHere();
1572       }
1573 
1574     } else if (right-&gt;is_constant()) {
1575       // cpu register - constant
1576       jlong c = right-&gt;as_constant_ptr()-&gt;as_jlong_bits();
1577       switch (code) {
1578         case lir_add: __ z_agfi(lreg_lo, c); break;
1579         case lir_sub:
1580           if (c != min_jint) {
1581                       __ z_agfi(lreg_lo, -c);
1582           } else {
1583             // -min_jint cannot be represented as simm32 in z_agfi
1584             // min_jint sign extended:      0xffffffff80000000
1585             // -min_jint as 64 bit integer: 0x0000000080000000
1586             // 0x80000000 can be represented as uimm32 in z_algfi
1587             // lreg_lo := lreg_lo + -min_jint == lreg_lo + 0x80000000
1588                       __ z_algfi(lreg_lo, UCONST64(0x80000000));
1589           }
1590           break;
1591         case lir_mul: __ z_msgfi(lreg_lo, c); break;
1592         default:
1593           ShouldNotReachHere();
1594       }
1595 
1596     } else {
1597       ShouldNotReachHere();
1598     }
1599 
1600   } else if (left-&gt;is_single_fpu()) {
1601     assert(left == dest, &quot;left and dest must be equal&quot;);
1602     FloatRegister lreg = left-&gt;as_float_reg();
1603     FloatRegister rreg = right-&gt;is_single_fpu() ? right-&gt;as_float_reg() : fnoreg;
1604     Address raddr;
1605 
1606     if (rreg == fnoreg) {
1607       assert(right-&gt;is_single_stack(), &quot;constants should be loaded into register&quot;);
1608       raddr = frame_map()-&gt;address_for_slot(right-&gt;single_stack_ix());
1609       if (!Immediate::is_uimm12(raddr.disp())) {
1610         __ mem2freg_opt(rreg = Z_fscratch_1, raddr, false);
1611       }
1612     }
1613 
1614     if (rreg != fnoreg) {
1615       switch (code) {
1616         case lir_add: __ z_aebr(lreg, rreg);  break;
1617         case lir_sub: __ z_sebr(lreg, rreg);  break;
1618         case lir_mul_strictfp: // fall through
1619         case lir_mul: __ z_meebr(lreg, rreg); break;
1620         case lir_div_strictfp: // fall through
1621         case lir_div: __ z_debr(lreg, rreg);  break;
1622         default: ShouldNotReachHere();
1623       }
1624     } else {
1625       switch (code) {
1626         case lir_add: __ z_aeb(lreg, raddr);  break;
1627         case lir_sub: __ z_seb(lreg, raddr);  break;
1628         case lir_mul_strictfp: // fall through
1629         case lir_mul: __ z_meeb(lreg, raddr);  break;
1630         case lir_div_strictfp: // fall through
1631         case lir_div: __ z_deb(lreg, raddr);  break;
1632         default: ShouldNotReachHere();
1633       }
1634     }
1635   } else if (left-&gt;is_double_fpu()) {
1636     assert(left == dest, &quot;left and dest must be equal&quot;);
1637     FloatRegister lreg = left-&gt;as_double_reg();
1638     FloatRegister rreg = right-&gt;is_double_fpu() ? right-&gt;as_double_reg() : fnoreg;
1639     Address raddr;
1640 
1641     if (rreg == fnoreg) {
1642       assert(right-&gt;is_double_stack(), &quot;constants should be loaded into register&quot;);
1643       raddr = frame_map()-&gt;address_for_slot(right-&gt;double_stack_ix());
1644       if (!Immediate::is_uimm12(raddr.disp())) {
1645         __ mem2freg_opt(rreg = Z_fscratch_1, raddr, true);
1646       }
1647     }
1648 
1649     if (rreg != fnoreg) {
1650       switch (code) {
1651         case lir_add: __ z_adbr(lreg, rreg); break;
1652         case lir_sub: __ z_sdbr(lreg, rreg); break;
1653         case lir_mul_strictfp: // fall through
1654         case lir_mul: __ z_mdbr(lreg, rreg); break;
1655         case lir_div_strictfp: // fall through
1656         case lir_div: __ z_ddbr(lreg, rreg); break;
1657         default: ShouldNotReachHere();
1658       }
1659     } else {
1660       switch (code) {
1661         case lir_add: __ z_adb(lreg, raddr); break;
1662         case lir_sub: __ z_sdb(lreg, raddr); break;
1663         case lir_mul_strictfp: // fall through
1664         case lir_mul: __ z_mdb(lreg, raddr); break;
1665         case lir_div_strictfp: // fall through
1666         case lir_div: __ z_ddb(lreg, raddr); break;
1667         default: ShouldNotReachHere();
1668       }
1669     }
1670   } else if (left-&gt;is_address()) {
1671     assert(left == dest, &quot;left and dest must be equal&quot;);
1672     assert(code == lir_add, &quot;unsupported operation&quot;);
1673     assert(right-&gt;is_constant(), &quot;unsupported operand&quot;);
1674     jint c = right-&gt;as_constant_ptr()-&gt;as_jint();
1675     LIR_Address* lir_addr = left-&gt;as_address_ptr();
1676     Address addr = as_Address(lir_addr);
1677     switch (lir_addr-&gt;type()) {
1678       case T_INT:
1679         __ add2mem_32(addr, c, Z_R1_scratch);
1680         break;
1681       case T_LONG:
1682         __ add2mem_64(addr, c, Z_R1_scratch);
1683         break;
1684       default:
1685         ShouldNotReachHere();
1686     }
1687   } else {
1688     ShouldNotReachHere();
1689   }
1690 }
1691 
1692 void LIR_Assembler::intrinsic_op(LIR_Code code, LIR_Opr value, LIR_Opr thread, LIR_Opr dest, LIR_Op* op) {
1693   switch (code) {
1694     case lir_sqrt: {
1695       assert(!thread-&gt;is_valid(), &quot;there is no need for a thread_reg for dsqrt&quot;);
1696       FloatRegister src_reg = value-&gt;as_double_reg();
1697       FloatRegister dst_reg = dest-&gt;as_double_reg();
1698       __ z_sqdbr(dst_reg, src_reg);
1699       break;
1700     }
1701     case lir_abs: {
1702       assert(!thread-&gt;is_valid(), &quot;there is no need for a thread_reg for fabs&quot;);
1703       FloatRegister src_reg = value-&gt;as_double_reg();
1704       FloatRegister dst_reg = dest-&gt;as_double_reg();
1705       __ z_lpdbr(dst_reg, src_reg);
1706       break;
1707     }
1708     default: {
1709       ShouldNotReachHere();
1710       break;
1711     }
1712   }
1713 }
1714 
1715 void LIR_Assembler::logic_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dst) {
1716   if (left-&gt;is_single_cpu()) {
1717     Register reg = left-&gt;as_register();
1718     if (right-&gt;is_constant()) {
1719       int val = right-&gt;as_constant_ptr()-&gt;as_jint();
1720       switch (code) {
1721         case lir_logic_and: __ z_nilf(reg, val); break;
1722         case lir_logic_or:  __ z_oilf(reg, val); break;
1723         case lir_logic_xor: __ z_xilf(reg, val); break;
1724         default: ShouldNotReachHere();
1725       }
1726     } else if (right-&gt;is_stack()) {
1727       Address raddr = frame_map()-&gt;address_for_slot(right-&gt;single_stack_ix());
1728       switch (code) {
1729         case lir_logic_and: __ z_ny(reg, raddr); break;
1730         case lir_logic_or:  __ z_oy(reg, raddr); break;
1731         case lir_logic_xor: __ z_xy(reg, raddr); break;
1732         default: ShouldNotReachHere();
1733       }
1734     } else {
1735       Register rright = right-&gt;as_register();
1736       switch (code) {
1737         case lir_logic_and: __ z_nr(reg, rright); break;
1738         case lir_logic_or : __ z_or(reg, rright); break;
1739         case lir_logic_xor: __ z_xr(reg, rright); break;
1740         default: ShouldNotReachHere();
1741       }
1742     }
1743     move_regs(reg, dst-&gt;as_register());
1744   } else {
1745     Register l_lo = left-&gt;as_register_lo();
1746     if (right-&gt;is_constant()) {
1747       __ load_const_optimized(Z_R1_scratch, right-&gt;as_constant_ptr()-&gt;as_jlong());
1748       switch (code) {
1749         case lir_logic_and:
1750           __ z_ngr(l_lo, Z_R1_scratch);
1751           break;
1752         case lir_logic_or:
1753           __ z_ogr(l_lo, Z_R1_scratch);
1754           break;
1755         case lir_logic_xor:
1756           __ z_xgr(l_lo, Z_R1_scratch);
1757           break;
1758         default: ShouldNotReachHere();
1759       }
1760     } else {
1761       Register r_lo;
1762       if (is_reference_type(right-&gt;type())) {
1763         r_lo = right-&gt;as_register();
1764       } else {
1765         r_lo = right-&gt;as_register_lo();
1766       }
1767       switch (code) {
1768         case lir_logic_and:
1769           __ z_ngr(l_lo, r_lo);
1770           break;
1771         case lir_logic_or:
1772           __ z_ogr(l_lo, r_lo);
1773           break;
1774         case lir_logic_xor:
1775           __ z_xgr(l_lo, r_lo);
1776           break;
1777         default: ShouldNotReachHere();
1778       }
1779     }
1780 
1781     Register dst_lo = dst-&gt;as_register_lo();
1782 
1783     move_regs(l_lo, dst_lo);
1784   }
1785 }
1786 
1787 // See operand selection in LIRGenerator::do_ArithmeticOp_Int().
1788 void LIR_Assembler::arithmetic_idiv(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr temp, LIR_Opr result, CodeEmitInfo* info) {
1789   if (left-&gt;is_double_cpu()) {
1790     // 64 bit integer case
1791     assert(left-&gt;is_double_cpu(), &quot;left must be register&quot;);
1792     assert(right-&gt;is_double_cpu() || is_power_of_2(right-&gt;as_jlong()),
1793            &quot;right must be register or power of 2 constant&quot;);
1794     assert(result-&gt;is_double_cpu(), &quot;result must be register&quot;);
1795 
1796     Register lreg = left-&gt;as_register_lo();
1797     Register dreg = result-&gt;as_register_lo();
1798 
1799     if (right-&gt;is_constant()) {
1800       // Convert division by a power of two into some shifts and logical operations.
1801       Register treg1 = Z_R0_scratch;
1802       Register treg2 = Z_R1_scratch;
1803       jlong divisor = right-&gt;as_jlong();
1804       jlong log_divisor = log2_long(right-&gt;as_jlong());
1805 
1806       if (divisor == min_jlong) {
1807         // Min_jlong is special. Result is &#39;0&#39; except for min_jlong/min_jlong = 1.
1808         if (dreg == lreg) {
1809           NearLabel done;
1810           __ load_const_optimized(treg2, min_jlong);
1811           __ z_cgr(lreg, treg2);
1812           __ z_lghi(dreg, 0);           // Preserves condition code.
1813           __ z_brne(done);
1814           __ z_lghi(dreg, 1);           // min_jlong / min_jlong = 1
1815           __ bind(done);
1816         } else {
1817           assert_different_registers(dreg, lreg);
1818           NearLabel done;
1819           __ z_lghi(dreg, 0);
1820           __ compare64_and_branch(lreg, min_jlong, Assembler::bcondNotEqual, done);
1821           __ z_lghi(dreg, 1);
1822           __ bind(done);
1823         }
1824         return;
1825       }
1826       __ move_reg_if_needed(dreg, T_LONG, lreg, T_LONG);
1827       if (divisor == 2) {
1828         __ z_srlg(treg2, dreg, 63);     // dividend &lt; 0 ? 1 : 0
1829       } else {
1830         __ z_srag(treg2, dreg, 63);     // dividend &lt; 0 ? -1 : 0
1831         __ and_imm(treg2, divisor - 1, treg1, true);
1832       }
1833       if (code == lir_idiv) {
1834         __ z_agr(dreg, treg2);
1835         __ z_srag(dreg, dreg, log_divisor);
1836       } else {
1837         assert(code == lir_irem, &quot;check&quot;);
1838         __ z_agr(treg2, dreg);
1839         __ and_imm(treg2, ~(divisor - 1), treg1, true);
1840         __ z_sgr(dreg, treg2);
1841       }
1842       return;
1843     }
1844 
1845     // Divisor is not a power of 2 constant.
1846     Register rreg = right-&gt;as_register_lo();
1847     Register treg = temp-&gt;as_register_lo();
1848     assert(right-&gt;is_double_cpu(), &quot;right must be register&quot;);
1849     assert(lreg == Z_R11, &quot;see ldivInOpr()&quot;);
1850     assert(rreg != lreg, &quot;right register must not be same as left register&quot;);
1851     assert((code == lir_idiv &amp;&amp; dreg == Z_R11 &amp;&amp; treg == Z_R10) ||
1852            (code == lir_irem &amp;&amp; dreg == Z_R10 &amp;&amp; treg == Z_R11), &quot;see ldivInOpr(), ldivOutOpr(), lremOutOpr()&quot;);
1853 
1854     Register R1 = lreg-&gt;predecessor();
1855     Register R2 = rreg;
1856     assert(code != lir_idiv || lreg==dreg, &quot;see code below&quot;);
1857     if (code == lir_idiv) {
1858       __ z_lcgr(lreg, lreg);
1859     } else {
1860       __ clear_reg(dreg, true, false);
1861     }
1862     NearLabel done;
1863     __ compare64_and_branch(R2, -1, Assembler::bcondEqual, done);
1864     if (code == lir_idiv) {
1865       __ z_lcgr(lreg, lreg); // Revert lcgr above.
1866     }
1867     if (ImplicitDiv0Checks) {
1868       // No debug info because the idiv won&#39;t trap.
1869       // Add_debug_info_for_div0 would instantiate another DivByZeroStub,
1870       // which is unnecessary, too.
1871       add_debug_info_for_div0(__ offset(), info);
1872     }
1873     __ z_dsgr(R1, R2);
1874     __ bind(done);
1875     return;
1876   }
1877 
1878   // 32 bit integer case
1879 
1880   assert(left-&gt;is_single_cpu(), &quot;left must be register&quot;);
1881   assert(right-&gt;is_single_cpu() || is_power_of_2(right-&gt;as_jint()), &quot;right must be register or power of 2 constant&quot;);
1882   assert(result-&gt;is_single_cpu(), &quot;result must be register&quot;);
1883 
1884   Register lreg = left-&gt;as_register();
1885   Register dreg = result-&gt;as_register();
1886 
1887   if (right-&gt;is_constant()) {
1888     // Convert division by a power of two into some shifts and logical operations.
1889     Register treg1 = Z_R0_scratch;
1890     Register treg2 = Z_R1_scratch;
1891     jlong divisor = right-&gt;as_jint();
1892     jlong log_divisor = log2_long(right-&gt;as_jint());
1893     __ move_reg_if_needed(dreg, T_LONG, lreg, T_INT); // sign extend
1894     if (divisor == 2) {
1895       __ z_srlg(treg2, dreg, 63);     // dividend &lt; 0 ?  1 : 0
1896     } else {
1897       __ z_srag(treg2, dreg, 63);     // dividend &lt; 0 ? -1 : 0
1898       __ and_imm(treg2, divisor - 1, treg1, true);
1899     }
1900     if (code == lir_idiv) {
1901       __ z_agr(dreg, treg2);
1902       __ z_srag(dreg, dreg, log_divisor);
1903     } else {
1904       assert(code == lir_irem, &quot;check&quot;);
1905       __ z_agr(treg2, dreg);
1906       __ and_imm(treg2, ~(divisor - 1), treg1, true);
1907       __ z_sgr(dreg, treg2);
1908     }
1909     return;
1910   }
1911 
1912   // Divisor is not a power of 2 constant.
1913   Register rreg = right-&gt;as_register();
1914   Register treg = temp-&gt;as_register();
1915   assert(right-&gt;is_single_cpu(), &quot;right must be register&quot;);
1916   assert(lreg == Z_R11, &quot;left register must be rax,&quot;);
1917   assert(rreg != lreg, &quot;right register must not be same as left register&quot;);
1918   assert((code == lir_idiv &amp;&amp; dreg == Z_R11 &amp;&amp; treg == Z_R10)
1919       || (code == lir_irem &amp;&amp; dreg == Z_R10 &amp;&amp; treg == Z_R11), &quot;see divInOpr(), divOutOpr(), remOutOpr()&quot;);
1920 
1921   Register R1 = lreg-&gt;predecessor();
1922   Register R2 = rreg;
1923   __ move_reg_if_needed(lreg, T_LONG, lreg, T_INT); // sign extend
1924   if (ImplicitDiv0Checks) {
1925     // No debug info because the idiv won&#39;t trap.
1926     // Add_debug_info_for_div0 would instantiate another DivByZeroStub,
1927     // which is unnecessary, too.
1928     add_debug_info_for_div0(__ offset(), info);
1929   }
1930   __ z_dsgfr(R1, R2);
1931 }
1932 
1933 void LIR_Assembler::throw_op(LIR_Opr exceptionPC, LIR_Opr exceptionOop, CodeEmitInfo* info) {
1934   assert(exceptionOop-&gt;as_register() == Z_EXC_OOP, &quot;should match&quot;);
1935   assert(exceptionPC-&gt;as_register() == Z_EXC_PC, &quot;should match&quot;);
1936 
1937   // Exception object is not added to oop map by LinearScan
1938   // (LinearScan assumes that no oops are in fixed registers).
1939   info-&gt;add_register_oop(exceptionOop);
1940 
1941   // Reuse the debug info from the safepoint poll for the throw op itself.
1942   __ get_PC(Z_EXC_PC);
1943   add_call_info(__ offset(), info); // for exception handler
1944   address stub = Runtime1::entry_for (compilation()-&gt;has_fpu_code() ? Runtime1::handle_exception_id
1945                                                                     : Runtime1::handle_exception_nofpu_id);
1946   emit_call_c(stub);
1947 }
1948 
1949 void LIR_Assembler::unwind_op(LIR_Opr exceptionOop) {
1950   assert(exceptionOop-&gt;as_register() == Z_EXC_OOP, &quot;should match&quot;);
1951 
1952   __ branch_optimized(Assembler::bcondAlways, _unwind_handler_entry);
1953 }
1954 
1955 void LIR_Assembler::emit_arraycopy(LIR_OpArrayCopy* op) {
1956   ciArrayKlass* default_type = op-&gt;expected_type();
1957   Register src = op-&gt;src()-&gt;as_register();
1958   Register dst = op-&gt;dst()-&gt;as_register();
1959   Register src_pos = op-&gt;src_pos()-&gt;as_register();
1960   Register dst_pos = op-&gt;dst_pos()-&gt;as_register();
1961   Register length  = op-&gt;length()-&gt;as_register();
1962   Register tmp = op-&gt;tmp()-&gt;as_register();
1963 
1964   CodeStub* stub = op-&gt;stub();
1965   int flags = op-&gt;flags();
1966   BasicType basic_type = default_type != NULL ? default_type-&gt;element_type()-&gt;basic_type() : T_ILLEGAL;
1967   if (basic_type == T_ARRAY) basic_type = T_OBJECT;
1968 
1969   // If we don&#39;t know anything, just go through the generic arraycopy.
1970   if (default_type == NULL) {
1971     address copyfunc_addr = StubRoutines::generic_arraycopy();
1972 
1973     if (copyfunc_addr == NULL) {
1974       // Take a slow path for generic arraycopy.
1975       __ branch_optimized(Assembler::bcondAlways, *stub-&gt;entry());
1976       __ bind(*stub-&gt;continuation());
1977       return;
1978     }
1979 
1980     // Save outgoing arguments in callee saved registers (C convention) in case
1981     // a call to System.arraycopy is needed.
1982     Register callee_saved_src     = Z_R10;
1983     Register callee_saved_src_pos = Z_R11;
1984     Register callee_saved_dst     = Z_R12;
1985     Register callee_saved_dst_pos = Z_R13;
1986     Register callee_saved_length  = Z_ARG5; // Z_ARG5 == Z_R6 is callee saved.
1987 
1988     __ lgr_if_needed(callee_saved_src, src);
1989     __ lgr_if_needed(callee_saved_src_pos, src_pos);
1990     __ lgr_if_needed(callee_saved_dst, dst);
1991     __ lgr_if_needed(callee_saved_dst_pos, dst_pos);
1992     __ lgr_if_needed(callee_saved_length, length);
1993 
1994     // C function requires 64 bit values.
1995     __ z_lgfr(src_pos, src_pos);
1996     __ z_lgfr(dst_pos, dst_pos);
1997     __ z_lgfr(length, length);
1998 
1999     // Pass arguments: may push as this is not a safepoint; SP must be fix at each safepoint.
2000 
2001     // The arguments are in the corresponding registers.
2002     assert(Z_ARG1 == src,     &quot;assumption&quot;);
2003     assert(Z_ARG2 == src_pos, &quot;assumption&quot;);
2004     assert(Z_ARG3 == dst,     &quot;assumption&quot;);
2005     assert(Z_ARG4 == dst_pos, &quot;assumption&quot;);
2006     assert(Z_ARG5 == length,  &quot;assumption&quot;);
2007 #ifndef PRODUCT
2008     if (PrintC1Statistics) {
2009       __ load_const_optimized(Z_R1_scratch, (address)&amp;Runtime1::_generic_arraycopystub_cnt);
2010       __ add2mem_32(Address(Z_R1_scratch), 1, Z_R0_scratch);
2011     }
2012 #endif
2013     emit_call_c(copyfunc_addr);
2014     CHECK_BAILOUT();
2015 
2016     __ compare32_and_branch(Z_RET, (intptr_t)0, Assembler::bcondEqual, *stub-&gt;continuation());
2017 
2018     __ z_lgr(tmp, Z_RET);
2019     __ z_xilf(tmp, -1);
2020 
2021     // Restore values from callee saved registers so they are where the stub
2022     // expects them.
2023     __ lgr_if_needed(src, callee_saved_src);
2024     __ lgr_if_needed(src_pos, callee_saved_src_pos);
2025     __ lgr_if_needed(dst, callee_saved_dst);
2026     __ lgr_if_needed(dst_pos, callee_saved_dst_pos);
2027     __ lgr_if_needed(length, callee_saved_length);
2028 
2029     __ z_sr(length, tmp);
2030     __ z_ar(src_pos, tmp);
2031     __ z_ar(dst_pos, tmp);
2032     __ branch_optimized(Assembler::bcondAlways, *stub-&gt;entry());
2033 
2034     __ bind(*stub-&gt;continuation());
2035     return;
2036   }
2037 
2038   assert(default_type != NULL &amp;&amp; default_type-&gt;is_array_klass() &amp;&amp; default_type-&gt;is_loaded(), &quot;must be true at this point&quot;);
2039 
2040   int elem_size = type2aelembytes(basic_type);
2041   int shift_amount;
2042 
2043   switch (elem_size) {
2044     case 1 :
2045       shift_amount = 0;
2046       break;
2047     case 2 :
2048       shift_amount = 1;
2049       break;
2050     case 4 :
2051       shift_amount = 2;
2052       break;
2053     case 8 :
2054       shift_amount = 3;
2055       break;
2056     default:
2057       shift_amount = -1;
2058       ShouldNotReachHere();
2059   }
2060 
2061   Address src_length_addr = Address(src, arrayOopDesc::length_offset_in_bytes());
2062   Address dst_length_addr = Address(dst, arrayOopDesc::length_offset_in_bytes());
2063   Address src_klass_addr = Address(src, oopDesc::klass_offset_in_bytes());
2064   Address dst_klass_addr = Address(dst, oopDesc::klass_offset_in_bytes());
2065 
2066   // Length and pos&#39;s are all sign extended at this point on 64bit.
2067 
2068   // test for NULL
2069   if (flags &amp; LIR_OpArrayCopy::src_null_check) {
2070     __ compareU64_and_branch(src, (intptr_t)0, Assembler::bcondZero, *stub-&gt;entry());
2071   }
2072   if (flags &amp; LIR_OpArrayCopy::dst_null_check) {
2073     __ compareU64_and_branch(dst, (intptr_t)0, Assembler::bcondZero, *stub-&gt;entry());
2074   }
2075 
2076   // Check if negative.
2077   if (flags &amp; LIR_OpArrayCopy::src_pos_positive_check) {
2078     __ compare32_and_branch(src_pos, (intptr_t)0, Assembler::bcondLow, *stub-&gt;entry());
2079   }
2080   if (flags &amp; LIR_OpArrayCopy::dst_pos_positive_check) {
2081     __ compare32_and_branch(dst_pos, (intptr_t)0, Assembler::bcondLow, *stub-&gt;entry());
2082   }
2083 
2084   // If the compiler was not able to prove that exact type of the source or the destination
2085   // of the arraycopy is an array type, check at runtime if the source or the destination is
2086   // an instance type.
2087   if (flags &amp; LIR_OpArrayCopy::type_check) {
2088     assert(Klass::_lh_neutral_value == 0, &quot;or replace z_lt instructions&quot;);
2089 
2090     if (!(flags &amp; LIR_OpArrayCopy::dst_objarray)) {
2091       __ load_klass(tmp, dst);
2092       __ z_lt(tmp, Address(tmp, in_bytes(Klass::layout_helper_offset())));
2093       __ branch_optimized(Assembler::bcondNotLow, *stub-&gt;entry());
2094     }
2095 
2096     if (!(flags &amp; LIR_OpArrayCopy::src_objarray)) {
2097       __ load_klass(tmp, src);
2098       __ z_lt(tmp, Address(tmp, in_bytes(Klass::layout_helper_offset())));
2099       __ branch_optimized(Assembler::bcondNotLow, *stub-&gt;entry());
2100     }
2101   }
2102 
2103   if (flags &amp; LIR_OpArrayCopy::src_range_check) {
2104     __ z_la(tmp, Address(src_pos, length));
2105     __ z_cl(tmp, src_length_addr);
2106     __ branch_optimized(Assembler::bcondHigh, *stub-&gt;entry());
2107   }
2108   if (flags &amp; LIR_OpArrayCopy::dst_range_check) {
2109     __ z_la(tmp, Address(dst_pos, length));
2110     __ z_cl(tmp, dst_length_addr);
2111     __ branch_optimized(Assembler::bcondHigh, *stub-&gt;entry());
2112   }
2113 
2114   if (flags &amp; LIR_OpArrayCopy::length_positive_check) {
2115     __ z_ltr(length, length);
2116     __ branch_optimized(Assembler::bcondNegative, *stub-&gt;entry());
2117   }
2118 
2119   // Stubs require 64 bit values.
2120   __ z_lgfr(src_pos, src_pos); // int -&gt; long
2121   __ z_lgfr(dst_pos, dst_pos); // int -&gt; long
2122   __ z_lgfr(length, length);   // int -&gt; long
2123 
2124   if (flags &amp; LIR_OpArrayCopy::type_check) {
2125     // We don&#39;t know the array types are compatible.
2126     if (basic_type != T_OBJECT) {
2127       // Simple test for basic type arrays.
2128       if (UseCompressedClassPointers) {
2129         __ z_l(tmp, src_klass_addr);
2130         __ z_c(tmp, dst_klass_addr);
2131       } else {
2132         __ z_lg(tmp, src_klass_addr);
2133         __ z_cg(tmp, dst_klass_addr);
2134       }
2135       __ branch_optimized(Assembler::bcondNotEqual, *stub-&gt;entry());
2136     } else {
2137       // For object arrays, if src is a sub class of dst then we can
2138       // safely do the copy.
2139       NearLabel cont, slow;
2140       Register src_klass = Z_R1_scratch;
2141       Register dst_klass = Z_R10;
2142 
2143       __ load_klass(src_klass, src);
2144       __ load_klass(dst_klass, dst);
2145 
2146       __ check_klass_subtype_fast_path(src_klass, dst_klass, tmp, &amp;cont, &amp;slow, NULL);
2147 
2148       store_parameter(src_klass, 0); // sub
2149       store_parameter(dst_klass, 1); // super
2150       emit_call_c(Runtime1::entry_for (Runtime1::slow_subtype_check_id));
2151       CHECK_BAILOUT2(cont, slow);
2152       // Sets condition code 0 for match (2 otherwise).
2153       __ branch_optimized(Assembler::bcondEqual, cont);
2154 
2155       __ bind(slow);
2156 
2157       address copyfunc_addr = StubRoutines::checkcast_arraycopy();
2158       if (copyfunc_addr != NULL) { // use stub if available
2159         // Src is not a sub class of dst so we have to do a
2160         // per-element check.
2161 
2162         int mask = LIR_OpArrayCopy::src_objarray|LIR_OpArrayCopy::dst_objarray;
2163         if ((flags &amp; mask) != mask) {
2164           // Check that at least both of them object arrays.
2165           assert(flags &amp; mask, &quot;one of the two should be known to be an object array&quot;);
2166 
2167           if (!(flags &amp; LIR_OpArrayCopy::src_objarray)) {
2168             __ load_klass(tmp, src);
2169           } else if (!(flags &amp; LIR_OpArrayCopy::dst_objarray)) {
2170             __ load_klass(tmp, dst);
2171           }
2172           Address klass_lh_addr(tmp, Klass::layout_helper_offset());
2173           jint objArray_lh = Klass::array_layout_helper(T_OBJECT);
2174           __ load_const_optimized(Z_R1_scratch, objArray_lh);
2175           __ z_c(Z_R1_scratch, klass_lh_addr);
2176           __ branch_optimized(Assembler::bcondNotEqual, *stub-&gt;entry());
2177         }
2178 
2179         // Save outgoing arguments in callee saved registers (C convention) in case
2180         // a call to System.arraycopy is needed.
2181         Register callee_saved_src     = Z_R10;
2182         Register callee_saved_src_pos = Z_R11;
2183         Register callee_saved_dst     = Z_R12;
2184         Register callee_saved_dst_pos = Z_R13;
2185         Register callee_saved_length  = Z_ARG5; // Z_ARG5 == Z_R6 is callee saved.
2186 
2187         __ lgr_if_needed(callee_saved_src, src);
2188         __ lgr_if_needed(callee_saved_src_pos, src_pos);
2189         __ lgr_if_needed(callee_saved_dst, dst);
2190         __ lgr_if_needed(callee_saved_dst_pos, dst_pos);
2191         __ lgr_if_needed(callee_saved_length, length);
2192 
2193         __ z_llgfr(length, length); // Higher 32bits must be null.
2194 
2195         __ z_sllg(Z_ARG1, src_pos, shift_amount); // index -&gt; byte offset
2196         __ z_sllg(Z_ARG2, dst_pos, shift_amount); // index -&gt; byte offset
2197 
2198         __ z_la(Z_ARG1, Address(src, Z_ARG1, arrayOopDesc::base_offset_in_bytes(basic_type)));
2199         assert_different_registers(Z_ARG1, dst, dst_pos, length);
2200         __ z_la(Z_ARG2, Address(dst, Z_ARG2, arrayOopDesc::base_offset_in_bytes(basic_type)));
2201         assert_different_registers(Z_ARG2, dst, length);
2202 
2203         __ z_lgr(Z_ARG3, length);
2204         assert_different_registers(Z_ARG3, dst);
2205 
2206         __ load_klass(Z_ARG5, dst);
2207         __ z_lg(Z_ARG5, Address(Z_ARG5, ObjArrayKlass::element_klass_offset()));
2208         __ z_lg(Z_ARG4, Address(Z_ARG5, Klass::super_check_offset_offset()));
2209         emit_call_c(copyfunc_addr);
2210         CHECK_BAILOUT2(cont, slow);
2211 
2212 #ifndef PRODUCT
2213         if (PrintC1Statistics) {
2214           NearLabel failed;
2215           __ compareU32_and_branch(Z_RET, (intptr_t)0, Assembler::bcondNotEqual, failed);
2216           __ load_const_optimized(Z_R1_scratch, (address)&amp;Runtime1::_arraycopy_checkcast_cnt);
2217           __ add2mem_32(Address(Z_R1_scratch), 1, Z_R0_scratch);
2218           __ bind(failed);
2219         }
2220 #endif
2221 
2222         __ compareU32_and_branch(Z_RET, (intptr_t)0, Assembler::bcondEqual, *stub-&gt;continuation());
2223 
2224 #ifndef PRODUCT
2225         if (PrintC1Statistics) {
2226           __ load_const_optimized(Z_R1_scratch, (address)&amp;Runtime1::_arraycopy_checkcast_attempt_cnt);
2227           __ add2mem_32(Address(Z_R1_scratch), 1, Z_R0_scratch);
2228         }
2229 #endif
2230 
2231         __ z_lgr(tmp, Z_RET);
2232         __ z_xilf(tmp, -1);
2233 
2234         // Restore previously spilled arguments
2235         __ lgr_if_needed(src, callee_saved_src);
2236         __ lgr_if_needed(src_pos, callee_saved_src_pos);
2237         __ lgr_if_needed(dst, callee_saved_dst);
2238         __ lgr_if_needed(dst_pos, callee_saved_dst_pos);
2239         __ lgr_if_needed(length, callee_saved_length);
2240 
2241         __ z_sr(length, tmp);
2242         __ z_ar(src_pos, tmp);
2243         __ z_ar(dst_pos, tmp);
2244       }
2245 
2246       __ branch_optimized(Assembler::bcondAlways, *stub-&gt;entry());
2247 
2248       __ bind(cont);
2249     }
2250   }
2251 
2252 #ifdef ASSERT
2253   if (basic_type != T_OBJECT || !(flags &amp; LIR_OpArrayCopy::type_check)) {
2254     // Sanity check the known type with the incoming class. For the
2255     // primitive case the types must match exactly with src.klass and
2256     // dst.klass each exactly matching the default type. For the
2257     // object array case, if no type check is needed then either the
2258     // dst type is exactly the expected type and the src type is a
2259     // subtype which we can&#39;t check or src is the same array as dst
2260     // but not necessarily exactly of type default_type.
2261     NearLabel known_ok, halt;
2262     metadata2reg(default_type-&gt;constant_encoding(), tmp);
2263     if (UseCompressedClassPointers) {
2264       __ encode_klass_not_null(tmp);
2265     }
2266 
2267     if (basic_type != T_OBJECT) {
2268       if (UseCompressedClassPointers)         { __ z_c (tmp, dst_klass_addr); }
2269       else                                    { __ z_cg(tmp, dst_klass_addr); }
2270       __ branch_optimized(Assembler::bcondNotEqual, halt);
2271       if (UseCompressedClassPointers)         { __ z_c (tmp, src_klass_addr); }
2272       else                                    { __ z_cg(tmp, src_klass_addr); }
2273       __ branch_optimized(Assembler::bcondEqual, known_ok);
2274     } else {
2275       if (UseCompressedClassPointers)         { __ z_c (tmp, dst_klass_addr); }
2276       else                                    { __ z_cg(tmp, dst_klass_addr); }
2277       __ branch_optimized(Assembler::bcondEqual, known_ok);
2278       __ compareU64_and_branch(src, dst, Assembler::bcondEqual, known_ok);
2279     }
2280     __ bind(halt);
2281     __ stop(&quot;incorrect type information in arraycopy&quot;);
2282     __ bind(known_ok);
2283   }
2284 #endif
2285 
2286 #ifndef PRODUCT
2287   if (PrintC1Statistics) {
2288     __ load_const_optimized(Z_R1_scratch, Runtime1::arraycopy_count_address(basic_type));
2289     __ add2mem_32(Address(Z_R1_scratch), 1, Z_R0_scratch);
2290   }
2291 #endif
2292 
2293   __ z_sllg(tmp, src_pos, shift_amount); // index -&gt; byte offset
2294   __ z_sllg(Z_R1_scratch, dst_pos, shift_amount); // index -&gt; byte offset
2295 
2296   assert_different_registers(Z_ARG1, dst, dst_pos, length);
2297   __ z_la(Z_ARG1, Address(src, tmp, arrayOopDesc::base_offset_in_bytes(basic_type)));
2298   assert_different_registers(Z_ARG2, length);
2299   __ z_la(Z_ARG2, Address(dst, Z_R1_scratch, arrayOopDesc::base_offset_in_bytes(basic_type)));
2300   __ lgr_if_needed(Z_ARG3, length);
2301 
2302   bool disjoint = (flags &amp; LIR_OpArrayCopy::overlapping) == 0;
2303   bool aligned = (flags &amp; LIR_OpArrayCopy::unaligned) == 0;
2304   const char *name;
2305   address entry = StubRoutines::select_arraycopy_function(basic_type, aligned, disjoint, name, false);
2306   __ call_VM_leaf(entry);
2307 
2308   __ bind(*stub-&gt;continuation());
2309 }
2310 
2311 void LIR_Assembler::shift_op(LIR_Code code, LIR_Opr left, LIR_Opr count, LIR_Opr dest, LIR_Opr tmp) {
2312   if (dest-&gt;is_single_cpu()) {
2313     if (left-&gt;type() == T_OBJECT) {
2314       switch (code) {
2315         case lir_shl:  __ z_sllg (dest-&gt;as_register(), left-&gt;as_register(), 0, count-&gt;as_register()); break;
2316         case lir_shr:  __ z_srag (dest-&gt;as_register(), left-&gt;as_register(), 0, count-&gt;as_register()); break;
2317         case lir_ushr: __ z_srlg (dest-&gt;as_register(), left-&gt;as_register(), 0, count-&gt;as_register()); break;
2318         default: ShouldNotReachHere();
2319       }
2320     } else {
2321       assert(code == lir_shl || left == dest, &quot;left and dest must be equal for 2 operand form right shifts&quot;);
2322       Register masked_count = Z_R1_scratch;
2323       __ z_lr(masked_count, count-&gt;as_register());
2324       __ z_nill(masked_count, 31);
2325       switch (code) {
2326         case lir_shl:  __ z_sllg (dest-&gt;as_register(), left-&gt;as_register(), 0, masked_count); break;
2327         case lir_shr:  __ z_sra  (dest-&gt;as_register(), 0, masked_count); break;
2328         case lir_ushr: __ z_srl  (dest-&gt;as_register(), 0, masked_count); break;
2329         default: ShouldNotReachHere();
2330       }
2331     }
2332   } else {
2333     switch (code) {
2334       case lir_shl:  __ z_sllg (dest-&gt;as_register_lo(), left-&gt;as_register_lo(), 0, count-&gt;as_register()); break;
2335       case lir_shr:  __ z_srag (dest-&gt;as_register_lo(), left-&gt;as_register_lo(), 0, count-&gt;as_register()); break;
2336       case lir_ushr: __ z_srlg (dest-&gt;as_register_lo(), left-&gt;as_register_lo(), 0, count-&gt;as_register()); break;
2337       default: ShouldNotReachHere();
2338     }
2339   }
2340 }
2341 
2342 void LIR_Assembler::shift_op(LIR_Code code, LIR_Opr left, jint count, LIR_Opr dest) {
2343   if (left-&gt;type() == T_OBJECT) {
2344     count = count &amp; 63;  // Shouldn&#39;t shift by more than sizeof(intptr_t).
2345     Register l = left-&gt;as_register();
2346     Register d = dest-&gt;as_register_lo();
2347     switch (code) {
2348       case lir_shl:  __ z_sllg (d, l, count); break;
2349       case lir_shr:  __ z_srag (d, l, count); break;
2350       case lir_ushr: __ z_srlg (d, l, count); break;
2351       default: ShouldNotReachHere();
2352     }
2353     return;
2354   }
2355   if (dest-&gt;is_single_cpu()) {
2356     assert(code == lir_shl || left == dest, &quot;left and dest must be equal for 2 operand form right shifts&quot;);
2357     count = count &amp; 0x1F; // Java spec
2358     switch (code) {
2359       case lir_shl:  __ z_sllg (dest-&gt;as_register(), left-&gt;as_register(), count); break;
2360       case lir_shr:  __ z_sra  (dest-&gt;as_register(), count); break;
2361       case lir_ushr: __ z_srl  (dest-&gt;as_register(), count); break;
2362       default: ShouldNotReachHere();
2363     }
2364   } else if (dest-&gt;is_double_cpu()) {
2365     count = count &amp; 63; // Java spec
2366     Register l = left-&gt;as_pointer_register();
2367     Register d = dest-&gt;as_pointer_register();
2368     switch (code) {
2369       case lir_shl:  __ z_sllg (d, l, count); break;
2370       case lir_shr:  __ z_srag (d, l, count); break;
2371       case lir_ushr: __ z_srlg (d, l, count); break;
2372       default: ShouldNotReachHere();
2373     }
2374   } else {
2375     ShouldNotReachHere();
2376   }
2377 }
2378 
2379 void LIR_Assembler::emit_alloc_obj(LIR_OpAllocObj* op) {
2380   if (op-&gt;init_check()) {
2381     // Make sure klass is initialized &amp; doesn&#39;t have finalizer.
2382     const int state_offset = in_bytes(InstanceKlass::init_state_offset());
2383     Register iklass = op-&gt;klass()-&gt;as_register();
2384     add_debug_info_for_null_check_here(op-&gt;stub()-&gt;info());
2385     if (Immediate::is_uimm12(state_offset)) {
2386       __ z_cli(state_offset, iklass, InstanceKlass::fully_initialized);
2387     } else {
2388       __ z_cliy(state_offset, iklass, InstanceKlass::fully_initialized);
2389     }
2390     __ branch_optimized(Assembler::bcondNotEqual, *op-&gt;stub()-&gt;entry()); // Use long branch, because slow_case might be far.
2391   }
2392   __ allocate_object(op-&gt;obj()-&gt;as_register(),
2393                      op-&gt;tmp1()-&gt;as_register(),
2394                      op-&gt;tmp2()-&gt;as_register(),
2395                      op-&gt;header_size(),
2396                      op-&gt;object_size(),
2397                      op-&gt;klass()-&gt;as_register(),
2398                      *op-&gt;stub()-&gt;entry());
2399   __ bind(*op-&gt;stub()-&gt;continuation());
2400   __ verify_oop(op-&gt;obj()-&gt;as_register(), FILE_AND_LINE);
2401 }
2402 
2403 void LIR_Assembler::emit_alloc_array(LIR_OpAllocArray* op) {
2404   Register len = op-&gt;len()-&gt;as_register();
2405   __ move_reg_if_needed(len, T_LONG, len, T_INT); // sign extend
2406 
2407   if (UseSlowPath ||
2408       (!UseFastNewObjectArray &amp;&amp; (is_reference_type(op-&gt;type()))) ||
2409       (!UseFastNewTypeArray   &amp;&amp; (!is_reference_type(op-&gt;type())))) {
2410     __ z_brul(*op-&gt;stub()-&gt;entry());
2411   } else {
2412     __ allocate_array(op-&gt;obj()-&gt;as_register(),
2413                       op-&gt;len()-&gt;as_register(),
2414                       op-&gt;tmp1()-&gt;as_register(),
2415                       op-&gt;tmp2()-&gt;as_register(),
2416                       arrayOopDesc::header_size(op-&gt;type()),
2417                       type2aelembytes(op-&gt;type()),
2418                       op-&gt;klass()-&gt;as_register(),
2419                       *op-&gt;stub()-&gt;entry());
2420   }
2421   __ bind(*op-&gt;stub()-&gt;continuation());
2422 }
2423 
2424 void LIR_Assembler::type_profile_helper(Register mdo, ciMethodData *md, ciProfileData *data,
2425                                         Register recv, Register tmp1, Label* update_done) {
2426   uint i;
2427   for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
2428     Label next_test;
2429     // See if the receiver is receiver[n].
2430     Address receiver_addr(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_offset(i)));
2431     __ z_cg(recv, receiver_addr);
2432     __ z_brne(next_test);
2433     Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_count_offset(i)));
2434     __ add2mem_64(data_addr, DataLayout::counter_increment, tmp1);
2435     __ branch_optimized(Assembler::bcondAlways, *update_done);
2436     __ bind(next_test);
2437   }
2438 
2439   // Didn&#39;t find receiver; find next empty slot and fill it in.
2440   for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
2441     Label next_test;
2442     Address recv_addr(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_offset(i)));
2443     __ z_ltg(Z_R0_scratch, recv_addr);
2444     __ z_brne(next_test);
2445     __ z_stg(recv, recv_addr);
2446     __ load_const_optimized(tmp1, DataLayout::counter_increment);
2447     __ z_stg(tmp1, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_count_offset(i)), mdo);
2448     __ branch_optimized(Assembler::bcondAlways, *update_done);
2449     __ bind(next_test);
2450   }
2451 }
2452 
2453 void LIR_Assembler::setup_md_access(ciMethod* method, int bci,
2454                                     ciMethodData*&amp; md, ciProfileData*&amp; data, int&amp; mdo_offset_bias) {
2455   Unimplemented();
2456 }
2457 
2458 void LIR_Assembler::store_parameter(Register r, int param_num) {
2459   assert(param_num &gt;= 0, &quot;invalid num&quot;);
2460   int offset_in_bytes = param_num * BytesPerWord + FrameMap::first_available_sp_in_frame;
2461   assert(offset_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
2462   __ z_stg(r, offset_in_bytes, Z_SP);
2463 }
2464 
2465 void LIR_Assembler::store_parameter(jint c, int param_num) {
2466   assert(param_num &gt;= 0, &quot;invalid num&quot;);
2467   int offset_in_bytes = param_num * BytesPerWord + FrameMap::first_available_sp_in_frame;
2468   assert(offset_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
2469   __ store_const(Address(Z_SP, offset_in_bytes), c, Z_R1_scratch, true);
2470 }
2471 
2472 void LIR_Assembler::emit_typecheck_helper(LIR_OpTypeCheck *op, Label* success, Label* failure, Label* obj_is_null) {
2473   // We always need a stub for the failure case.
2474   CodeStub* stub = op-&gt;stub();
2475   Register obj = op-&gt;object()-&gt;as_register();
2476   Register k_RInfo = op-&gt;tmp1()-&gt;as_register();
2477   Register klass_RInfo = op-&gt;tmp2()-&gt;as_register();
2478   Register dst = op-&gt;result_opr()-&gt;as_register();
2479   Register Rtmp1 = Z_R1_scratch;
2480   ciKlass* k = op-&gt;klass();
2481 
2482   assert(!op-&gt;tmp3()-&gt;is_valid(), &quot;tmp3&#39;s not needed&quot;);
2483 
2484   // Check if it needs to be profiled.
2485   ciMethodData* md = NULL;
2486   ciProfileData* data = NULL;
2487 
2488   if (op-&gt;should_profile()) {
2489     ciMethod* method = op-&gt;profiled_method();
2490     assert(method != NULL, &quot;Should have method&quot;);
2491     int bci = op-&gt;profiled_bci();
2492     md = method-&gt;method_data_or_null();
2493     assert(md != NULL, &quot;Sanity&quot;);
2494     data = md-&gt;bci_to_data(bci);
2495     assert(data != NULL,                &quot;need data for type check&quot;);
2496     assert(data-&gt;is_ReceiverTypeData(), &quot;need ReceiverTypeData for type check&quot;);
2497   }
2498 
2499   // Temp operands do not overlap with inputs, if this is their last
2500   // use (end of range is exclusive), so a register conflict is possible.
2501   if (obj == k_RInfo) {
2502     k_RInfo = dst;
2503   } else if (obj == klass_RInfo) {
2504     klass_RInfo = dst;
2505   }
2506   assert_different_registers(obj, k_RInfo, klass_RInfo);
2507 
2508   if (op-&gt;should_profile()) {
2509     NearLabel not_null;
2510     __ compareU64_and_branch(obj, (intptr_t) 0, Assembler::bcondNotEqual, not_null);
2511     // Object is null; update MDO and exit.
2512     Register mdo = klass_RInfo;
2513     metadata2reg(md-&gt;constant_encoding(), mdo);
2514     Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, DataLayout::header_offset()));
2515     int header_bits = DataLayout::flag_mask_to_header_mask(BitData::null_seen_byte_constant());
2516     __ or2mem_8(data_addr, header_bits);
2517     __ branch_optimized(Assembler::bcondAlways, *obj_is_null);
2518     __ bind(not_null);
2519   } else {
2520     __ compareU64_and_branch(obj, (intptr_t) 0, Assembler::bcondEqual, *obj_is_null);
2521   }
2522 
2523   NearLabel profile_cast_failure, profile_cast_success;
2524   Label *failure_target = op-&gt;should_profile() ? &amp;profile_cast_failure : failure;
2525   Label *success_target = op-&gt;should_profile() ? &amp;profile_cast_success : success;
2526 
2527   // Patching may screw with our temporaries on sparc,
2528   // so let&#39;s do it before loading the class.
2529   if (k-&gt;is_loaded()) {
2530     metadata2reg(k-&gt;constant_encoding(), k_RInfo);
2531   } else {
2532     klass2reg_with_patching(k_RInfo, op-&gt;info_for_patch());
2533   }
2534   assert(obj != k_RInfo, &quot;must be different&quot;);
2535 
2536   __ verify_oop(obj, FILE_AND_LINE);
2537 
2538   // Get object class.
2539   // Not a safepoint as obj null check happens earlier.
2540   if (op-&gt;fast_check()) {
2541     if (UseCompressedClassPointers) {
2542       __ load_klass(klass_RInfo, obj);
2543       __ compareU64_and_branch(k_RInfo, klass_RInfo, Assembler::bcondNotEqual, *failure_target);
2544     } else {
2545       __ z_cg(k_RInfo, Address(obj, oopDesc::klass_offset_in_bytes()));
2546       __ branch_optimized(Assembler::bcondNotEqual, *failure_target);
2547     }
2548     // Successful cast, fall through to profile or jump.
2549   } else {
2550     bool need_slow_path = !k-&gt;is_loaded() ||
2551                           ((int) k-&gt;super_check_offset() == in_bytes(Klass::secondary_super_cache_offset()));
2552     intptr_t super_check_offset = k-&gt;is_loaded() ? k-&gt;super_check_offset() : -1L;
2553     __ load_klass(klass_RInfo, obj);
2554     // Perform the fast part of the checking logic.
2555     __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1,
2556                                      (need_slow_path ? success_target : NULL),
2557                                      failure_target, NULL,
2558                                      RegisterOrConstant(super_check_offset));
2559     if (need_slow_path) {
2560       // Call out-of-line instance of __ check_klass_subtype_slow_path(...):
2561       address a = Runtime1::entry_for (Runtime1::slow_subtype_check_id);
2562       store_parameter(klass_RInfo, 0); // sub
2563       store_parameter(k_RInfo, 1);     // super
2564       emit_call_c(a); // Sets condition code 0 for match (2 otherwise).
2565       CHECK_BAILOUT2(profile_cast_failure, profile_cast_success);
2566       __ branch_optimized(Assembler::bcondNotEqual, *failure_target);
2567       // Fall through to success case.
2568     }
2569   }
2570 
2571   if (op-&gt;should_profile()) {
2572     Register mdo = klass_RInfo, recv = k_RInfo;
2573     assert_different_registers(obj, mdo, recv);
2574     __ bind(profile_cast_success);
2575     metadata2reg(md-&gt;constant_encoding(), mdo);
2576     __ load_klass(recv, obj);
2577     type_profile_helper(mdo, md, data, recv, Rtmp1, success);
2578     __ branch_optimized(Assembler::bcondAlways, *success);
2579 
2580     __ bind(profile_cast_failure);
2581     metadata2reg(md-&gt;constant_encoding(), mdo);
2582     __ add2mem_64(Address(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset())), -(int)DataLayout::counter_increment, Rtmp1);
2583     __ branch_optimized(Assembler::bcondAlways, *failure);
2584   } else {
2585     __ branch_optimized(Assembler::bcondAlways, *success);
2586   }
2587 }
2588 
2589 void LIR_Assembler::emit_opTypeCheck(LIR_OpTypeCheck* op) {
2590   LIR_Code code = op-&gt;code();
2591   if (code == lir_store_check) {
2592     Register value = op-&gt;object()-&gt;as_register();
2593     Register array = op-&gt;array()-&gt;as_register();
2594     Register k_RInfo = op-&gt;tmp1()-&gt;as_register();
2595     Register klass_RInfo = op-&gt;tmp2()-&gt;as_register();
2596     Register Rtmp1 = Z_R1_scratch;
2597 
2598     CodeStub* stub = op-&gt;stub();
2599 
2600     // Check if it needs to be profiled.
2601     ciMethodData* md = NULL;
2602     ciProfileData* data = NULL;
2603 
2604     assert_different_registers(value, k_RInfo, klass_RInfo);
2605 
2606     if (op-&gt;should_profile()) {
2607       ciMethod* method = op-&gt;profiled_method();
2608       assert(method != NULL, &quot;Should have method&quot;);
2609       int bci = op-&gt;profiled_bci();
2610       md = method-&gt;method_data_or_null();
2611       assert(md != NULL, &quot;Sanity&quot;);
2612       data = md-&gt;bci_to_data(bci);
2613       assert(data != NULL,                &quot;need data for type check&quot;);
2614       assert(data-&gt;is_ReceiverTypeData(), &quot;need ReceiverTypeData for type check&quot;);
2615     }
2616     NearLabel profile_cast_success, profile_cast_failure, done;
2617     Label *success_target = op-&gt;should_profile() ? &amp;profile_cast_success : &amp;done;
2618     Label *failure_target = op-&gt;should_profile() ? &amp;profile_cast_failure : stub-&gt;entry();
2619 
2620     if (op-&gt;should_profile()) {
2621       NearLabel not_null;
2622       __ compareU64_and_branch(value, (intptr_t) 0, Assembler::bcondNotEqual, not_null);
2623       // Object is null; update MDO and exit.
2624       Register mdo = klass_RInfo;
2625       metadata2reg(md-&gt;constant_encoding(), mdo);
2626       Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, DataLayout::header_offset()));
2627       int header_bits = DataLayout::flag_mask_to_header_mask(BitData::null_seen_byte_constant());
2628       __ or2mem_8(data_addr, header_bits);
2629       __ branch_optimized(Assembler::bcondAlways, done);
2630       __ bind(not_null);
2631     } else {
2632       __ compareU64_and_branch(value, (intptr_t) 0, Assembler::bcondEqual, done);
2633     }
2634 
2635     add_debug_info_for_null_check_here(op-&gt;info_for_exception());
2636     __ load_klass(k_RInfo, array);
2637     __ load_klass(klass_RInfo, value);
2638 
2639     // Get instance klass (it&#39;s already uncompressed).
2640     __ z_lg(k_RInfo, Address(k_RInfo, ObjArrayKlass::element_klass_offset()));
2641     // Perform the fast part of the checking logic.
2642     __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, NULL);
2643     // Call out-of-line instance of __ check_klass_subtype_slow_path(...):
2644     address a = Runtime1::entry_for (Runtime1::slow_subtype_check_id);
2645     store_parameter(klass_RInfo, 0); // sub
2646     store_parameter(k_RInfo, 1);     // super
2647     emit_call_c(a); // Sets condition code 0 for match (2 otherwise).
2648     CHECK_BAILOUT3(profile_cast_success, profile_cast_failure, done);
2649     __ branch_optimized(Assembler::bcondNotEqual, *failure_target);
2650     // Fall through to success case.
2651 
2652     if (op-&gt;should_profile()) {
2653       Register mdo = klass_RInfo, recv = k_RInfo;
2654       assert_different_registers(value, mdo, recv);
2655       __ bind(profile_cast_success);
2656       metadata2reg(md-&gt;constant_encoding(), mdo);
2657       __ load_klass(recv, value);
2658       type_profile_helper(mdo, md, data, recv, Rtmp1, &amp;done);
2659       __ branch_optimized(Assembler::bcondAlways, done);
2660 
2661       __ bind(profile_cast_failure);
2662       metadata2reg(md-&gt;constant_encoding(), mdo);
2663       __ add2mem_64(Address(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset())), -(int)DataLayout::counter_increment, Rtmp1);
2664       __ branch_optimized(Assembler::bcondAlways, *stub-&gt;entry());
2665     }
2666 
2667     __ bind(done);
2668   } else {
2669     if (code == lir_checkcast) {
2670       Register obj = op-&gt;object()-&gt;as_register();
2671       Register dst = op-&gt;result_opr()-&gt;as_register();
2672       NearLabel success;
2673       emit_typecheck_helper(op, &amp;success, op-&gt;stub()-&gt;entry(), &amp;success);
2674       __ bind(success);
2675       __ lgr_if_needed(dst, obj);
2676     } else {
2677       if (code == lir_instanceof) {
2678         Register obj = op-&gt;object()-&gt;as_register();
2679         Register dst = op-&gt;result_opr()-&gt;as_register();
2680         NearLabel success, failure, done;
2681         emit_typecheck_helper(op, &amp;success, &amp;failure, &amp;failure);
2682         __ bind(failure);
2683         __ clear_reg(dst);
2684         __ branch_optimized(Assembler::bcondAlways, done);
2685         __ bind(success);
2686         __ load_const_optimized(dst, 1);
2687         __ bind(done);
2688       } else {
2689         ShouldNotReachHere();
2690       }
2691     }
2692   }
2693 }
2694 
2695 void LIR_Assembler::emit_compare_and_swap(LIR_OpCompareAndSwap* op) {
2696   Register addr = op-&gt;addr()-&gt;as_pointer_register();
2697   Register t1_cmp = Z_R1_scratch;
2698   if (op-&gt;code() == lir_cas_long) {
2699     assert(VM_Version::supports_cx8(), &quot;wrong machine&quot;);
2700     Register cmp_value_lo = op-&gt;cmp_value()-&gt;as_register_lo();
2701     Register new_value_lo = op-&gt;new_value()-&gt;as_register_lo();
2702     __ z_lgr(t1_cmp, cmp_value_lo);
2703     // Perform the compare and swap operation.
2704     __ z_csg(t1_cmp, new_value_lo, 0, addr);
2705   } else if (op-&gt;code() == lir_cas_int || op-&gt;code() == lir_cas_obj) {
2706     Register cmp_value = op-&gt;cmp_value()-&gt;as_register();
2707     Register new_value = op-&gt;new_value()-&gt;as_register();
2708     if (op-&gt;code() == lir_cas_obj) {
2709       if (UseCompressedOops) {
2710                  t1_cmp = op-&gt;tmp1()-&gt;as_register();
2711         Register t2_new = op-&gt;tmp2()-&gt;as_register();
2712         assert_different_registers(cmp_value, new_value, addr, t1_cmp, t2_new);
2713         __ oop_encoder(t1_cmp, cmp_value, true /*maybe null*/);
2714         __ oop_encoder(t2_new, new_value, true /*maybe null*/);
2715         __ z_cs(t1_cmp, t2_new, 0, addr);
2716       } else {
2717         __ z_lgr(t1_cmp, cmp_value);
2718         __ z_csg(t1_cmp, new_value, 0, addr);
2719       }
2720     } else {
2721       __ z_lr(t1_cmp, cmp_value);
2722       __ z_cs(t1_cmp, new_value, 0, addr);
2723     }
2724   } else {
2725     ShouldNotReachHere(); // new lir_cas_??
2726   }
2727 }
2728 
2729 void LIR_Assembler::breakpoint() {
2730   Unimplemented();
2731   //  __ breakpoint_trap();
2732 }
2733 
2734 void LIR_Assembler::push(LIR_Opr opr) {
2735   ShouldNotCallThis(); // unused
2736 }
2737 
2738 void LIR_Assembler::pop(LIR_Opr opr) {
2739   ShouldNotCallThis(); // unused
2740 }
2741 
2742 void LIR_Assembler::monitor_address(int monitor_no, LIR_Opr dst_opr) {
2743   Address addr = frame_map()-&gt;address_for_monitor_lock(monitor_no);
2744   __ add2reg(dst_opr-&gt;as_register(), addr.disp(), addr.base());
2745 }
2746 
2747 void LIR_Assembler::emit_lock(LIR_OpLock* op) {
2748   Register obj = op-&gt;obj_opr()-&gt;as_register();  // May not be an oop.
2749   Register hdr = op-&gt;hdr_opr()-&gt;as_register();
2750   Register lock = op-&gt;lock_opr()-&gt;as_register();
2751   if (!UseFastLocking) {
2752     __ branch_optimized(Assembler::bcondAlways, *op-&gt;stub()-&gt;entry());
2753   } else if (op-&gt;code() == lir_lock) {
2754     assert(BasicLock::displaced_header_offset_in_bytes() == 0, &quot;lock_reg must point to the displaced header&quot;);
2755     // Add debug info for NullPointerException only if one is possible.
2756     if (op-&gt;info() != NULL) {
2757       add_debug_info_for_null_check_here(op-&gt;info());
2758     }
2759     __ lock_object(hdr, obj, lock, *op-&gt;stub()-&gt;entry());
2760     // done
2761   } else if (op-&gt;code() == lir_unlock) {
2762     assert(BasicLock::displaced_header_offset_in_bytes() == 0, &quot;lock_reg must point to the displaced header&quot;);
2763     __ unlock_object(hdr, obj, lock, *op-&gt;stub()-&gt;entry());
2764   } else {
2765     ShouldNotReachHere();
2766   }
2767   __ bind(*op-&gt;stub()-&gt;continuation());
2768 }
2769 
2770 void LIR_Assembler::emit_profile_call(LIR_OpProfileCall* op) {
2771   ciMethod* method = op-&gt;profiled_method();
2772   int bci          = op-&gt;profiled_bci();
2773   ciMethod* callee = op-&gt;profiled_callee();
2774 
2775   // Update counter for all call types.
2776   ciMethodData* md = method-&gt;method_data_or_null();
2777   assert(md != NULL, &quot;Sanity&quot;);
2778   ciProfileData* data = md-&gt;bci_to_data(bci);
2779   assert(data != NULL &amp;&amp; data-&gt;is_CounterData(), &quot;need CounterData for calls&quot;);
2780   assert(op-&gt;mdo()-&gt;is_single_cpu(),  &quot;mdo must be allocated&quot;);
2781   Register mdo  = op-&gt;mdo()-&gt;as_register();
2782   assert(op-&gt;tmp1()-&gt;is_double_cpu(), &quot;tmp1 must be allocated&quot;);
2783   Register tmp1 = op-&gt;tmp1()-&gt;as_register_lo();
2784   metadata2reg(md-&gt;constant_encoding(), mdo);
2785 
2786   Address counter_addr(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()));
2787   // Perform additional virtual call profiling for invokevirtual and
2788   // invokeinterface bytecodes
2789   if (op-&gt;should_profile_receiver_type()) {
2790     assert(op-&gt;recv()-&gt;is_single_cpu(), &quot;recv must be allocated&quot;);
2791     Register recv = op-&gt;recv()-&gt;as_register();
2792     assert_different_registers(mdo, tmp1, recv);
2793     assert(data-&gt;is_VirtualCallData(), &quot;need VirtualCallData for virtual calls&quot;);
2794     ciKlass* known_klass = op-&gt;known_holder();
2795     if (C1OptimizeVirtualCallProfiling &amp;&amp; known_klass != NULL) {
2796       // We know the type that will be seen at this call site; we can
2797       // statically update the MethodData* rather than needing to do
2798       // dynamic tests on the receiver type.
2799 
2800       // NOTE: we should probably put a lock around this search to
2801       // avoid collisions by concurrent compilations.
2802       ciVirtualCallData* vc_data = (ciVirtualCallData*) data;
2803       uint i;
2804       for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
2805         ciKlass* receiver = vc_data-&gt;receiver(i);
2806         if (known_klass-&gt;equals(receiver)) {
2807           Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_count_offset(i)));
2808           __ add2mem_64(data_addr, DataLayout::counter_increment, tmp1);
2809           return;
2810         }
2811       }
2812 
2813       // Receiver type not found in profile data. Select an empty slot.
2814 
2815       // Note that this is less efficient than it should be because it
2816       // always does a write to the receiver part of the
2817       // VirtualCallData rather than just the first time.
2818       for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
2819         ciKlass* receiver = vc_data-&gt;receiver(i);
2820         if (receiver == NULL) {
2821           Address recv_addr(mdo, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_offset(i)));
2822           metadata2reg(known_klass-&gt;constant_encoding(), tmp1);
2823           __ z_stg(tmp1, recv_addr);
2824           Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_count_offset(i)));
2825           __ add2mem_64(data_addr, DataLayout::counter_increment, tmp1);
2826           return;
2827         }
2828       }
2829     } else {
2830       __ load_klass(recv, recv);
2831       NearLabel update_done;
2832       type_profile_helper(mdo, md, data, recv, tmp1, &amp;update_done);
2833       // Receiver did not match any saved receiver and there is no empty row for it.
2834       // Increment total counter to indicate polymorphic case.
2835       __ add2mem_64(counter_addr, DataLayout::counter_increment, tmp1);
2836       __ bind(update_done);
2837     }
2838   } else {
2839     // static call
2840     __ add2mem_64(counter_addr, DataLayout::counter_increment, tmp1);
2841   }
2842 }
2843 
2844 void LIR_Assembler::align_backward_branch_target() {
2845   __ align(OptoLoopAlignment);
2846 }
2847 
2848 void LIR_Assembler::emit_delay(LIR_OpDelay* op) {
2849   ShouldNotCallThis(); // There are no delay slots on ZARCH_64.
2850 }
2851 
2852 void LIR_Assembler::negate(LIR_Opr left, LIR_Opr dest, LIR_Opr tmp) {
2853   // tmp must be unused
2854   assert(tmp-&gt;is_illegal(), &quot;wasting a register if tmp is allocated&quot;);
2855   assert(left-&gt;is_register(), &quot;can only handle registers&quot;);
2856 
2857   if (left-&gt;is_single_cpu()) {
2858     __ z_lcr(dest-&gt;as_register(), left-&gt;as_register());
2859   } else if (left-&gt;is_single_fpu()) {
2860     __ z_lcebr(dest-&gt;as_float_reg(), left-&gt;as_float_reg());
2861   } else if (left-&gt;is_double_fpu()) {
2862     __ z_lcdbr(dest-&gt;as_double_reg(), left-&gt;as_double_reg());
2863   } else {
2864     assert(left-&gt;is_double_cpu(), &quot;Must be a long&quot;);
2865     __ z_lcgr(dest-&gt;as_register_lo(), left-&gt;as_register_lo());
2866   }
2867 }
2868 
2869 void LIR_Assembler::rt_call(LIR_Opr result, address dest,
2870                             const LIR_OprList* args, LIR_Opr tmp, CodeEmitInfo* info) {
2871   assert(!tmp-&gt;is_valid(), &quot;don&#39;t need temporary&quot;);
2872   emit_call_c(dest);
2873   CHECK_BAILOUT();
2874   if (info != NULL) {
2875     add_call_info_here(info);
2876   }
2877 }
2878 
2879 void LIR_Assembler::volatile_move_op(LIR_Opr src, LIR_Opr dest, BasicType type, CodeEmitInfo* info) {
2880   ShouldNotCallThis(); // not needed on ZARCH_64
2881 }
2882 
2883 void LIR_Assembler::membar() {
2884   __ z_fence();
2885 }
2886 
2887 void LIR_Assembler::membar_acquire() {
2888   __ z_acquire();
2889 }
2890 
2891 void LIR_Assembler::membar_release() {
2892   __ z_release();
2893 }
2894 
2895 void LIR_Assembler::membar_loadload() {
2896   __ z_acquire();
2897 }
2898 
2899 void LIR_Assembler::membar_storestore() {
2900   __ z_release();
2901 }
2902 
2903 void LIR_Assembler::membar_loadstore() {
2904   __ z_acquire();
2905 }
2906 
2907 void LIR_Assembler::membar_storeload() {
2908   __ z_fence();
2909 }
2910 
2911 void LIR_Assembler::on_spin_wait() {
2912   Unimplemented();
2913 }
2914 
2915 void LIR_Assembler::leal(LIR_Opr addr_opr, LIR_Opr dest, LIR_PatchCode patch_code, CodeEmitInfo* info) {
2916   assert(patch_code == lir_patch_none, &quot;Patch code not supported&quot;);
2917   LIR_Address* addr = addr_opr-&gt;as_address_ptr();
2918   assert(addr-&gt;scale() == LIR_Address::times_1, &quot;scaling unsupported&quot;);
2919   __ load_address(dest-&gt;as_pointer_register(), as_Address(addr));
2920 }
2921 
2922 void LIR_Assembler::get_thread(LIR_Opr result_reg) {
2923   ShouldNotCallThis(); // unused
2924 }
2925 
2926 #ifdef ASSERT
2927 // Emit run-time assertion.
2928 void LIR_Assembler::emit_assert(LIR_OpAssert* op) {
2929   Unimplemented();
2930 }
2931 #endif
2932 
2933 void LIR_Assembler::peephole(LIR_List*) {
2934   // Do nothing for now.
2935 }
2936 
2937 void LIR_Assembler::atomic_op(LIR_Code code, LIR_Opr src, LIR_Opr data, LIR_Opr dest, LIR_Opr tmp) {
2938   assert(code == lir_xadd, &quot;lir_xchg not supported&quot;);
2939   Address src_addr = as_Address(src-&gt;as_address_ptr());
2940   Register base = src_addr.base();
2941   intptr_t disp = src_addr.disp();
2942   if (src_addr.index()-&gt;is_valid()) {
2943     // LAA and LAAG do not support index register.
2944     __ load_address(Z_R1_scratch, src_addr);
2945     base = Z_R1_scratch;
2946     disp = 0;
2947   }
2948   if (data-&gt;type() == T_INT) {
2949     __ z_laa(dest-&gt;as_register(), data-&gt;as_register(), disp, base);
2950   } else if (data-&gt;type() == T_LONG) {
2951     assert(data-&gt;as_register_lo() == data-&gt;as_register_hi(), &quot;should be a single register&quot;);
2952     __ z_laag(dest-&gt;as_register_lo(), data-&gt;as_register_lo(), disp, base);
2953   } else {
2954     ShouldNotReachHere();
2955   }
2956 }
2957 
2958 void LIR_Assembler::emit_profile_type(LIR_OpProfileType* op) {
2959   Register obj = op-&gt;obj()-&gt;as_register();
2960   Register tmp1 = op-&gt;tmp()-&gt;as_pointer_register();
2961   Register tmp2 = Z_R1_scratch;
2962   Address mdo_addr = as_Address(op-&gt;mdp()-&gt;as_address_ptr());
2963   ciKlass* exact_klass = op-&gt;exact_klass();
2964   intptr_t current_klass = op-&gt;current_klass();
2965   bool not_null = op-&gt;not_null();
2966   bool no_conflict = op-&gt;no_conflict();
2967 
2968   Label update, next, none, null_seen, init_klass;
2969 
2970   bool do_null = !not_null;
2971   bool exact_klass_set = exact_klass != NULL &amp;&amp; ciTypeEntries::valid_ciklass(current_klass) == exact_klass;
2972   bool do_update = !TypeEntries::is_type_unknown(current_klass) &amp;&amp; !exact_klass_set;
2973 
2974   assert(do_null || do_update, &quot;why are we here?&quot;);
2975   assert(!TypeEntries::was_null_seen(current_klass) || do_update, &quot;why are we here?&quot;);
2976 
2977   __ verify_oop(obj, FILE_AND_LINE);
2978 
2979   if (do_null || tmp1 != obj DEBUG_ONLY(|| true)) {
2980     __ z_ltgr(tmp1, obj);
2981   }
2982   if (do_null) {
2983     __ z_brnz(update);
2984     if (!TypeEntries::was_null_seen(current_klass)) {
2985       __ z_lg(tmp1, mdo_addr);
2986       __ z_oill(tmp1, TypeEntries::null_seen);
2987       __ z_stg(tmp1, mdo_addr);
2988     }
2989     if (do_update) {
2990       __ z_bru(next);
2991     }
2992   } else {
2993     __ asm_assert_ne(&quot;unexpect null obj&quot;, __LINE__);
2994   }
2995 
2996   __ bind(update);
2997 
2998   if (do_update) {
2999 #ifdef ASSERT
3000     if (exact_klass != NULL) {
3001       __ load_klass(tmp1, tmp1);
3002       metadata2reg(exact_klass-&gt;constant_encoding(), tmp2);
3003       __ z_cgr(tmp1, tmp2);
3004       __ asm_assert_eq(&quot;exact klass and actual klass differ&quot;, __LINE__);
3005     }
3006 #endif
3007 
3008     Label do_update;
3009     __ z_lg(tmp2, mdo_addr);
3010 
3011     if (!no_conflict) {
3012       if (exact_klass == NULL || TypeEntries::is_type_none(current_klass)) {
3013         if (exact_klass != NULL) {
3014           metadata2reg(exact_klass-&gt;constant_encoding(), tmp1);
3015         } else {
3016           __ load_klass(tmp1, tmp1);
3017         }
3018 
3019         // Klass seen before: nothing to do (regardless of unknown bit).
3020         __ z_lgr(Z_R0_scratch, tmp2);
3021         assert(Immediate::is_uimm(~TypeEntries::type_klass_mask, 16), &quot;or change following instruction&quot;);
3022         __ z_nill(Z_R0_scratch, TypeEntries::type_klass_mask &amp; 0xFFFF);
3023         __ compareU64_and_branch(Z_R0_scratch, tmp1, Assembler::bcondEqual, next);
3024 
3025         // Already unknown: Nothing to do anymore.
3026         __ z_tmll(tmp2, TypeEntries::type_unknown);
3027         __ z_brc(Assembler::bcondAllOne, next);
3028 
3029         if (TypeEntries::is_type_none(current_klass)) {
3030           __ z_lgr(Z_R0_scratch, tmp2);
3031           assert(Immediate::is_uimm(~TypeEntries::type_mask, 16), &quot;or change following instruction&quot;);
3032           __ z_nill(Z_R0_scratch, TypeEntries::type_mask &amp; 0xFFFF);
3033           __ compareU64_and_branch(Z_R0_scratch, (intptr_t)0, Assembler::bcondEqual, init_klass);
3034         }
3035       } else {
3036         assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &amp;&amp;
3037                ciTypeEntries::valid_ciklass(current_klass) != exact_klass, &quot;conflict only&quot;);
3038 
3039         // Already unknown: Nothing to do anymore.
3040         __ z_tmll(tmp2, TypeEntries::type_unknown);
3041         __ z_brc(Assembler::bcondAllOne, next);
3042       }
3043 
3044       // Different than before. Cannot keep accurate profile.
3045       __ z_oill(tmp2, TypeEntries::type_unknown);
3046       __ z_bru(do_update);
3047     } else {
3048       // There&#39;s a single possible klass at this profile point.
3049       assert(exact_klass != NULL, &quot;should be&quot;);
3050       if (TypeEntries::is_type_none(current_klass)) {
3051         metadata2reg(exact_klass-&gt;constant_encoding(), tmp1);
3052         __ z_lgr(Z_R0_scratch, tmp2);
3053         assert(Immediate::is_uimm(~TypeEntries::type_klass_mask, 16), &quot;or change following instruction&quot;);
3054         __ z_nill(Z_R0_scratch, TypeEntries::type_klass_mask &amp; 0xFFFF);
3055         __ compareU64_and_branch(Z_R0_scratch, tmp1, Assembler::bcondEqual, next);
3056 #ifdef ASSERT
3057         {
3058           Label ok;
3059           __ z_lgr(Z_R0_scratch, tmp2);
3060           assert(Immediate::is_uimm(~TypeEntries::type_mask, 16), &quot;or change following instruction&quot;);
3061           __ z_nill(Z_R0_scratch, TypeEntries::type_mask &amp; 0xFFFF);
3062           __ compareU64_and_branch(Z_R0_scratch, (intptr_t)0, Assembler::bcondEqual, ok);
3063           __ stop(&quot;unexpected profiling mismatch&quot;);
3064           __ bind(ok);
3065         }
3066 #endif
3067 
3068       } else {
3069         assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &amp;&amp;
3070                ciTypeEntries::valid_ciklass(current_klass) != exact_klass, &quot;inconsistent&quot;);
3071 
3072         // Already unknown: Nothing to do anymore.
3073         __ z_tmll(tmp2, TypeEntries::type_unknown);
3074         __ z_brc(Assembler::bcondAllOne, next);
3075         __ z_oill(tmp2, TypeEntries::type_unknown);
3076         __ z_bru(do_update);
3077       }
3078     }
3079 
3080     __ bind(init_klass);
3081     // Combine klass and null_seen bit (only used if (tmp &amp; type_mask)==0).
3082     __ z_ogr(tmp2, tmp1);
3083 
3084     __ bind(do_update);
3085     __ z_stg(tmp2, mdo_addr);
3086 
3087     __ bind(next);
3088   }
3089 }
3090 
3091 void LIR_Assembler::emit_updatecrc32(LIR_OpUpdateCRC32* op) {
3092   assert(op-&gt;crc()-&gt;is_single_cpu(), &quot;crc must be register&quot;);
3093   assert(op-&gt;val()-&gt;is_single_cpu(), &quot;byte value must be register&quot;);
3094   assert(op-&gt;result_opr()-&gt;is_single_cpu(), &quot;result must be register&quot;);
3095   Register crc = op-&gt;crc()-&gt;as_register();
3096   Register val = op-&gt;val()-&gt;as_register();
3097   Register res = op-&gt;result_opr()-&gt;as_register();
3098 
3099   assert_different_registers(val, crc, res);
3100 
3101   __ load_const_optimized(res, StubRoutines::crc_table_addr());
3102   __ kernel_crc32_singleByteReg(crc, val, res, true);
3103   __ z_lgfr(res, crc);
3104 }
3105 
3106 #undef __
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/cpu/s390/macroAssembler_s390.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="interp_masm_s390.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_s390.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/s390/macroAssembler_s390.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * Copyright (c) 2016, 2019, SAP SE. All rights reserved.
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -35,15 +35,10 @@</span>
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;memory/universe.hpp&quot;
  #include &quot;oops/accessDecorators.hpp&quot;
  #include &quot;oops/compressedOops.inline.hpp&quot;
  #include &quot;oops/klass.inline.hpp&quot;
<span class="udiff-line-removed">- #ifdef COMPILER2</span>
<span class="udiff-line-removed">- #include &quot;opto/compile.hpp&quot;</span>
<span class="udiff-line-removed">- #include &quot;opto/intrinsicnode.hpp&quot;</span>
<span class="udiff-line-removed">- #include &quot;opto/matcher.hpp&quot;</span>
<span class="udiff-line-removed">- #endif</span>
  #include &quot;prims/methodHandles.hpp&quot;
  #include &quot;registerSaver_s390.hpp&quot;
  #include &quot;runtime/biasedLocking.hpp&quot;
  #include &quot;runtime/icache.hpp&quot;
  #include &quot;runtime/interfaceSupport.inline.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2687,20 +2682,14 @@</span>
    ShouldNotReachHere();
    return 0;
  }
  
  void MacroAssembler::safepoint_poll(Label&amp; slow_path, Register temp_reg) {
<span class="udiff-line-modified-removed">-   if (SafepointMechanism::uses_thread_local_poll()) {</span>
<span class="udiff-line-modified-removed">-     const Address poll_byte_addr(Z_thread, in_bytes(Thread::polling_page_offset()) + 7 /* Big Endian */);</span>
<span class="udiff-line-modified-removed">-     // Armed page has poll_bit set.</span>
<span class="udiff-line-modified-removed">-     z_tm(poll_byte_addr, SafepointMechanism::poll_bit());</span>
<span class="udiff-line-removed">-     z_brnaz(slow_path);</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     load_const_optimized(temp_reg, SafepointSynchronize::address_of_state());</span>
<span class="udiff-line-removed">-     z_cli(/*SafepointSynchronize::sz_state()*/4-1, temp_reg, SafepointSynchronize::_not_synchronized);</span>
<span class="udiff-line-removed">-     z_brne(slow_path);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+   const Address poll_byte_addr(Z_thread, in_bytes(Thread::polling_page_offset()) + 7 /* Big Endian */);</span>
<span class="udiff-line-modified-added">+   // Armed page has poll_bit set.</span>
<span class="udiff-line-modified-added">+   z_tm(poll_byte_addr, SafepointMechanism::poll_bit());</span>
<span class="udiff-line-modified-added">+   z_brnaz(slow_path);</span>
  }
  
  // Don&#39;t rely on register locking, always use Z_R1 as scratch register instead.
  void MacroAssembler::bang_stack_with_offset(int offset) {
    // Stack grows down, caller passes positive offset.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4591,1260 +4580,10 @@</span>
  
    int block_end = offset();
    return block_end - block_start;
  }
  
<span class="udiff-line-removed">- #ifdef COMPILER2</span>
<span class="udiff-line-removed">- //------------------------------------------------------</span>
<span class="udiff-line-removed">- //   Special String Intrinsics. Implementation</span>
<span class="udiff-line-removed">- //------------------------------------------------------</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- // Intrinsics for CompactStrings</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- // Compress char[] to byte[].</span>
<span class="udiff-line-removed">- //   Restores: src, dst</span>
<span class="udiff-line-removed">- //   Uses:     cnt</span>
<span class="udiff-line-removed">- //   Kills:    tmp, Z_R0, Z_R1.</span>
<span class="udiff-line-removed">- //   Early clobber: result.</span>
<span class="udiff-line-removed">- // Note:</span>
<span class="udiff-line-removed">- //   cnt is signed int. Do not rely on high word!</span>
<span class="udiff-line-removed">- //       counts # characters, not bytes.</span>
<span class="udiff-line-removed">- // The result is the number of characters copied before the first incompatible character was found.</span>
<span class="udiff-line-removed">- // If precise is true, the processing stops exactly at this point. Otherwise, the result may be off</span>
<span class="udiff-line-removed">- // by a few bytes. The result always indicates the number of copied characters.</span>
<span class="udiff-line-removed">- // When used as a character index, the returned value points to the first incompatible character.</span>
<span class="udiff-line-removed">- //</span>
<span class="udiff-line-removed">- // Note: Does not behave exactly like package private StringUTF16 compress java implementation in case of failure:</span>
<span class="udiff-line-removed">- // - Different number of characters may have been written to dead array (if precise is false).</span>
<span class="udiff-line-removed">- // - Returns a number &lt;cnt instead of 0. (Result gets compared with cnt.)</span>
<span class="udiff-line-removed">- unsigned int MacroAssembler::string_compress(Register result, Register src, Register dst, Register cnt,</span>
<span class="udiff-line-removed">-                                              Register tmp,    bool precise) {</span>
<span class="udiff-line-removed">-   assert_different_registers(Z_R0, Z_R1, result, src, dst, cnt, tmp);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (precise) {</span>
<span class="udiff-line-removed">-     BLOCK_COMMENT(&quot;encode_iso_array {&quot;);</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     BLOCK_COMMENT(&quot;string_compress {&quot;);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   int  block_start = offset();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   Register       Rsrc  = src;</span>
<span class="udiff-line-removed">-   Register       Rdst  = dst;</span>
<span class="udiff-line-removed">-   Register       Rix   = tmp;</span>
<span class="udiff-line-removed">-   Register       Rcnt  = cnt;</span>
<span class="udiff-line-removed">-   Register       Rmask = result;  // holds incompatibility check mask until result value is stored.</span>
<span class="udiff-line-removed">-   Label          ScalarShortcut, AllDone;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   z_iilf(Rmask, 0xFF00FF00);</span>
<span class="udiff-line-removed">-   z_iihf(Rmask, 0xFF00FF00);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #if 0  // Sacrifice shortcuts for code compactness</span>
<span class="udiff-line-removed">-   {</span>
<span class="udiff-line-removed">-     //---&lt;  shortcuts for short strings (very frequent)   &gt;---</span>
<span class="udiff-line-removed">-     //   Strings with 4 and 8 characters were fond to occur very frequently.</span>
<span class="udiff-line-removed">-     //   Therefore, we handle them right away with minimal overhead.</span>
<span class="udiff-line-removed">-     Label     skipShortcut, skip4Shortcut, skip8Shortcut;</span>
<span class="udiff-line-removed">-     Register  Rout = Z_R0;</span>
<span class="udiff-line-removed">-     z_chi(Rcnt, 4);</span>
<span class="udiff-line-removed">-     z_brne(skip4Shortcut);                 // 4 characters are very frequent</span>
<span class="udiff-line-removed">-       z_lg(Z_R0, 0, Rsrc);                 // Treat exactly 4 characters specially.</span>
<span class="udiff-line-removed">-       if (VM_Version::has_DistinctOpnds()) {</span>
<span class="udiff-line-removed">-         Rout = Z_R0;</span>
<span class="udiff-line-removed">-         z_ngrk(Rix, Z_R0, Rmask);</span>
<span class="udiff-line-removed">-       } else {</span>
<span class="udiff-line-removed">-         Rout = Rix;</span>
<span class="udiff-line-removed">-         z_lgr(Rix, Z_R0);</span>
<span class="udiff-line-removed">-         z_ngr(Z_R0, Rmask);</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       z_brnz(skipShortcut);</span>
<span class="udiff-line-removed">-       z_stcmh(Rout, 5, 0, Rdst);</span>
<span class="udiff-line-removed">-       z_stcm(Rout,  5, 2, Rdst);</span>
<span class="udiff-line-removed">-       z_lgfr(result, Rcnt);</span>
<span class="udiff-line-removed">-       z_bru(AllDone);</span>
<span class="udiff-line-removed">-     bind(skip4Shortcut);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     z_chi(Rcnt, 8);</span>
<span class="udiff-line-removed">-     z_brne(skip8Shortcut);                 // There&#39;s more to do...</span>
<span class="udiff-line-removed">-       z_lmg(Z_R0, Z_R1, 0, Rsrc);          // Treat exactly 8 characters specially.</span>
<span class="udiff-line-removed">-       if (VM_Version::has_DistinctOpnds()) {</span>
<span class="udiff-line-removed">-         Rout = Z_R0;</span>
<span class="udiff-line-removed">-         z_ogrk(Rix, Z_R0, Z_R1);</span>
<span class="udiff-line-removed">-         z_ngr(Rix, Rmask);</span>
<span class="udiff-line-removed">-       } else {</span>
<span class="udiff-line-removed">-         Rout = Rix;</span>
<span class="udiff-line-removed">-         z_lgr(Rix, Z_R0);</span>
<span class="udiff-line-removed">-         z_ogr(Z_R0, Z_R1);</span>
<span class="udiff-line-removed">-         z_ngr(Z_R0, Rmask);</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       z_brnz(skipShortcut);</span>
<span class="udiff-line-removed">-       z_stcmh(Rout, 5, 0, Rdst);</span>
<span class="udiff-line-removed">-       z_stcm(Rout,  5, 2, Rdst);</span>
<span class="udiff-line-removed">-       z_stcmh(Z_R1, 5, 4, Rdst);</span>
<span class="udiff-line-removed">-       z_stcm(Z_R1,  5, 6, Rdst);</span>
<span class="udiff-line-removed">-       z_lgfr(result, Rcnt);</span>
<span class="udiff-line-removed">-       z_bru(AllDone);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     bind(skip8Shortcut);</span>
<span class="udiff-line-removed">-     clear_reg(Z_R0, true, false);          // #characters already processed (none). Precond for scalar loop.</span>
<span class="udiff-line-removed">-     z_brl(ScalarShortcut);                 // Just a few characters</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     bind(skipShortcut);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-   clear_reg(Z_R0);                         // make sure register is properly initialized.</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (VM_Version::has_VectorFacility()) {</span>
<span class="udiff-line-removed">-     const int  min_vcnt     = 32;          // Minimum #characters required to use vector instructions.</span>
<span class="udiff-line-removed">-                                            // Otherwise just do nothing in vector mode.</span>
<span class="udiff-line-removed">-                                            // Must be multiple of 2*(vector register length in chars (8 HW = 128 bits)).</span>
<span class="udiff-line-removed">-     const int  log_min_vcnt = exact_log2(min_vcnt);</span>
<span class="udiff-line-removed">-     Label      VectorLoop, VectorDone, VectorBreak;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     VectorRegister Vtmp1      = Z_V16;</span>
<span class="udiff-line-removed">-     VectorRegister Vtmp2      = Z_V17;</span>
<span class="udiff-line-removed">-     VectorRegister Vmask      = Z_V18;</span>
<span class="udiff-line-removed">-     VectorRegister Vzero      = Z_V19;</span>
<span class="udiff-line-removed">-     VectorRegister Vsrc_first = Z_V20;</span>
<span class="udiff-line-removed">-     VectorRegister Vsrc_last  = Z_V23;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     assert((Vsrc_last-&gt;encoding() - Vsrc_first-&gt;encoding() + 1) == min_vcnt/8, &quot;logic error&quot;);</span>
<span class="udiff-line-removed">-     assert(VM_Version::has_DistinctOpnds(), &quot;Assumption when has_VectorFacility()&quot;);</span>
<span class="udiff-line-removed">-     z_srak(Rix, Rcnt, log_min_vcnt);       // # vector loop iterations</span>
<span class="udiff-line-removed">-     z_brz(VectorDone);                     // not enough data for vector loop</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     z_vzero(Vzero);                        // all zeroes</span>
<span class="udiff-line-removed">-     z_vgmh(Vmask, 0, 7);                   // generate 0xff00 mask for all 2-byte elements</span>
<span class="udiff-line-removed">-     z_sllg(Z_R0, Rix, log_min_vcnt);       // remember #chars that will be processed by vector loop</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     bind(VectorLoop);</span>
<span class="udiff-line-removed">-       z_vlm(Vsrc_first, Vsrc_last, 0, Rsrc);</span>
<span class="udiff-line-removed">-       add2reg(Rsrc, min_vcnt*2);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       //---&lt;  check for incompatible character  &gt;---</span>
<span class="udiff-line-removed">-       z_vo(Vtmp1, Z_V20, Z_V21);</span>
<span class="udiff-line-removed">-       z_vo(Vtmp2, Z_V22, Z_V23);</span>
<span class="udiff-line-removed">-       z_vo(Vtmp1, Vtmp1, Vtmp2);</span>
<span class="udiff-line-removed">-       z_vn(Vtmp1, Vtmp1, Vmask);</span>
<span class="udiff-line-removed">-       z_vceqhs(Vtmp1, Vtmp1, Vzero);       // high half of all chars must be zero for successful compress.</span>
<span class="udiff-line-removed">-       z_bvnt(VectorBreak);                 // break vector loop if not all vector elements compare eq -&gt; incompatible character found.</span>
<span class="udiff-line-removed">-                                            // re-process data from current iteration in break handler.</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       //---&lt;  pack &amp; store characters  &gt;---</span>
<span class="udiff-line-removed">-       z_vpkh(Vtmp1, Z_V20, Z_V21);         // pack (src1, src2) -&gt; tmp1</span>
<span class="udiff-line-removed">-       z_vpkh(Vtmp2, Z_V22, Z_V23);         // pack (src3, src4) -&gt; tmp2</span>
<span class="udiff-line-removed">-       z_vstm(Vtmp1, Vtmp2, 0, Rdst);       // store packed string</span>
<span class="udiff-line-removed">-       add2reg(Rdst, min_vcnt);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       z_brct(Rix, VectorLoop);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     z_bru(VectorDone);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     bind(VectorBreak);</span>
<span class="udiff-line-removed">-       add2reg(Rsrc, -min_vcnt*2);          // Fix Rsrc. Rsrc was already updated, but Rdst and Rix are not.</span>
<span class="udiff-line-removed">-       z_sll(Rix, log_min_vcnt);            // # chars processed so far in VectorLoop, excl. current iteration.</span>
<span class="udiff-line-removed">-       z_sr(Z_R0, Rix);                     // correct # chars processed in total.</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     bind(VectorDone);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   {</span>
<span class="udiff-line-removed">-     const int  min_cnt     =  8;           // Minimum #characters required to use unrolled loop.</span>
<span class="udiff-line-removed">-                                            // Otherwise just do nothing in unrolled loop.</span>
<span class="udiff-line-removed">-                                            // Must be multiple of 8.</span>
<span class="udiff-line-removed">-     const int  log_min_cnt = exact_log2(min_cnt);</span>
<span class="udiff-line-removed">-     Label      UnrolledLoop, UnrolledDone, UnrolledBreak;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (VM_Version::has_DistinctOpnds()) {</span>
<span class="udiff-line-removed">-       z_srk(Rix, Rcnt, Z_R0);              // remaining # chars to compress in unrolled loop</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       z_lr(Rix, Rcnt);</span>
<span class="udiff-line-removed">-       z_sr(Rix, Z_R0);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     z_sra(Rix, log_min_cnt);             // unrolled loop count</span>
<span class="udiff-line-removed">-     z_brz(UnrolledDone);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     bind(UnrolledLoop);</span>
<span class="udiff-line-removed">-       z_lmg(Z_R0, Z_R1, 0, Rsrc);</span>
<span class="udiff-line-removed">-       if (precise) {</span>
<span class="udiff-line-removed">-         z_ogr(Z_R1, Z_R0);                 // check all 8 chars for incompatibility</span>
<span class="udiff-line-removed">-         z_ngr(Z_R1, Rmask);</span>
<span class="udiff-line-removed">-         z_brnz(UnrolledBreak);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         z_lg(Z_R1, 8, Rsrc);               // reload destroyed register</span>
<span class="udiff-line-removed">-         z_stcmh(Z_R0, 5, 0, Rdst);</span>
<span class="udiff-line-removed">-         z_stcm(Z_R0,  5, 2, Rdst);</span>
<span class="udiff-line-removed">-       } else {</span>
<span class="udiff-line-removed">-         z_stcmh(Z_R0, 5, 0, Rdst);</span>
<span class="udiff-line-removed">-         z_stcm(Z_R0,  5, 2, Rdst);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         z_ogr(Z_R0, Z_R1);</span>
<span class="udiff-line-removed">-         z_ngr(Z_R0, Rmask);</span>
<span class="udiff-line-removed">-         z_brnz(UnrolledBreak);</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       z_stcmh(Z_R1, 5, 4, Rdst);</span>
<span class="udiff-line-removed">-       z_stcm(Z_R1,  5, 6, Rdst);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       add2reg(Rsrc, min_cnt*2);</span>
<span class="udiff-line-removed">-       add2reg(Rdst, min_cnt);</span>
<span class="udiff-line-removed">-       z_brct(Rix, UnrolledLoop);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     z_lgfr(Z_R0, Rcnt);                    // # chars processed in total after unrolled loop.</span>
<span class="udiff-line-removed">-     z_nilf(Z_R0, ~(min_cnt-1));</span>
<span class="udiff-line-removed">-     z_tmll(Rcnt, min_cnt-1);</span>
<span class="udiff-line-removed">-     z_brnaz(ScalarShortcut);               // if all bits zero, there is nothing left to do for scalar loop.</span>
<span class="udiff-line-removed">-                                            // Rix == 0 in all cases.</span>
<span class="udiff-line-removed">-     z_sllg(Z_R1, Rcnt, 1);                 // # src bytes already processed. Only lower 32 bits are valid!</span>
<span class="udiff-line-removed">-                                            //   Z_R1 contents must be treated as unsigned operand! For huge strings,</span>
<span class="udiff-line-removed">-                                            //   (Rcnt &gt;= 2**30), the value may spill into the sign bit by sllg.</span>
<span class="udiff-line-removed">-     z_lgfr(result, Rcnt);                  // all characters processed.</span>
<span class="udiff-line-removed">-     z_slgfr(Rdst, Rcnt);                   // restore ptr</span>
<span class="udiff-line-removed">-     z_slgfr(Rsrc, Z_R1);                   // restore ptr, double the element count for Rsrc restore</span>
<span class="udiff-line-removed">-     z_bru(AllDone);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     bind(UnrolledBreak);</span>
<span class="udiff-line-removed">-     z_lgfr(Z_R0, Rcnt);                    // # chars processed in total after unrolled loop</span>
<span class="udiff-line-removed">-     z_nilf(Z_R0, ~(min_cnt-1));</span>
<span class="udiff-line-removed">-     z_sll(Rix, log_min_cnt);               // # chars not yet processed in UnrolledLoop (due to break), broken iteration not included.</span>
<span class="udiff-line-removed">-     z_sr(Z_R0, Rix);                       // fix # chars processed OK so far.</span>
<span class="udiff-line-removed">-     if (!precise) {</span>
<span class="udiff-line-removed">-       z_lgfr(result, Z_R0);</span>
<span class="udiff-line-removed">-       z_sllg(Z_R1, Z_R0, 1);               // # src bytes already processed. Only lower 32 bits are valid!</span>
<span class="udiff-line-removed">-                                            //   Z_R1 contents must be treated as unsigned operand! For huge strings,</span>
<span class="udiff-line-removed">-                                            //   (Rcnt &gt;= 2**30), the value may spill into the sign bit by sllg.</span>
<span class="udiff-line-removed">-       z_aghi(result, min_cnt/2);           // min_cnt/2 characters have already been written</span>
<span class="udiff-line-removed">-                                            // but ptrs were not updated yet.</span>
<span class="udiff-line-removed">-       z_slgfr(Rdst, Z_R0);                 // restore ptr</span>
<span class="udiff-line-removed">-       z_slgfr(Rsrc, Z_R1);                 // restore ptr, double the element count for Rsrc restore</span>
<span class="udiff-line-removed">-       z_bru(AllDone);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     bind(UnrolledDone);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   {</span>
<span class="udiff-line-removed">-     Label     ScalarLoop, ScalarDone, ScalarBreak;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     bind(ScalarShortcut);</span>
<span class="udiff-line-removed">-     z_ltgfr(result, Rcnt);</span>
<span class="udiff-line-removed">-     z_brz(AllDone);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #if 0  // Sacrifice shortcuts for code compactness</span>
<span class="udiff-line-removed">-     {</span>
<span class="udiff-line-removed">-       //---&lt;  Special treatment for very short strings (one or two characters)  &gt;---</span>
<span class="udiff-line-removed">-       //   For these strings, we are sure that the above code was skipped.</span>
<span class="udiff-line-removed">-       //   Thus, no registers were modified, register restore is not required.</span>
<span class="udiff-line-removed">-       Label     ScalarDoit, Scalar2Char;</span>
<span class="udiff-line-removed">-       z_chi(Rcnt, 2);</span>
<span class="udiff-line-removed">-       z_brh(ScalarDoit);</span>
<span class="udiff-line-removed">-       z_llh(Z_R1,  0, Z_R0, Rsrc);</span>
<span class="udiff-line-removed">-       z_bre(Scalar2Char);</span>
<span class="udiff-line-removed">-       z_tmll(Z_R1, 0xff00);</span>
<span class="udiff-line-removed">-       z_lghi(result, 0);                   // cnt == 1, first char invalid, no chars successfully processed</span>
<span class="udiff-line-removed">-       z_brnaz(AllDone);</span>
<span class="udiff-line-removed">-       z_stc(Z_R1,  0, Z_R0, Rdst);</span>
<span class="udiff-line-removed">-       z_lghi(result, 1);</span>
<span class="udiff-line-removed">-       z_bru(AllDone);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       bind(Scalar2Char);</span>
<span class="udiff-line-removed">-       z_llh(Z_R0,  2, Z_R0, Rsrc);</span>
<span class="udiff-line-removed">-       z_tmll(Z_R1, 0xff00);</span>
<span class="udiff-line-removed">-       z_lghi(result, 0);                   // cnt == 2, first char invalid, no chars successfully processed</span>
<span class="udiff-line-removed">-       z_brnaz(AllDone);</span>
<span class="udiff-line-removed">-       z_stc(Z_R1,  0, Z_R0, Rdst);</span>
<span class="udiff-line-removed">-       z_tmll(Z_R0, 0xff00);</span>
<span class="udiff-line-removed">-       z_lghi(result, 1);                   // cnt == 2, second char invalid, one char successfully processed</span>
<span class="udiff-line-removed">-       z_brnaz(AllDone);</span>
<span class="udiff-line-removed">-       z_stc(Z_R0,  1, Z_R0, Rdst);</span>
<span class="udiff-line-removed">-       z_lghi(result, 2);</span>
<span class="udiff-line-removed">-       z_bru(AllDone);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       bind(ScalarDoit);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (VM_Version::has_DistinctOpnds()) {</span>
<span class="udiff-line-removed">-       z_srk(Rix, Rcnt, Z_R0);              // remaining # chars to compress in unrolled loop</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       z_lr(Rix, Rcnt);</span>
<span class="udiff-line-removed">-       z_sr(Rix, Z_R0);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     z_lgfr(result, Rcnt);                  // # processed characters (if all runs ok).</span>
<span class="udiff-line-removed">-     z_brz(ScalarDone);                     // uses CC from Rix calculation</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     bind(ScalarLoop);</span>
<span class="udiff-line-removed">-       z_llh(Z_R1, 0, Z_R0, Rsrc);</span>
<span class="udiff-line-removed">-       z_tmll(Z_R1, 0xff00);</span>
<span class="udiff-line-removed">-       z_brnaz(ScalarBreak);</span>
<span class="udiff-line-removed">-       z_stc(Z_R1, 0, Z_R0, Rdst);</span>
<span class="udiff-line-removed">-       add2reg(Rsrc, 2);</span>
<span class="udiff-line-removed">-       add2reg(Rdst, 1);</span>
<span class="udiff-line-removed">-       z_brct(Rix, ScalarLoop);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     z_bru(ScalarDone);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     bind(ScalarBreak);</span>
<span class="udiff-line-removed">-     z_sr(result, Rix);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     bind(ScalarDone);</span>
<span class="udiff-line-removed">-     z_sgfr(Rdst, result);                  // restore ptr</span>
<span class="udiff-line-removed">-     z_sgfr(Rsrc, result);                  // restore ptr, double the element count for Rsrc restore</span>
<span class="udiff-line-removed">-     z_sgfr(Rsrc, result);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   bind(AllDone);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (precise) {</span>
<span class="udiff-line-removed">-     BLOCK_COMMENT(&quot;} encode_iso_array&quot;);</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     BLOCK_COMMENT(&quot;} string_compress&quot;);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   return offset() - block_start;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- // Inflate byte[] to char[].</span>
<span class="udiff-line-removed">- unsigned int MacroAssembler::string_inflate_trot(Register src, Register dst, Register cnt, Register tmp) {</span>
<span class="udiff-line-removed">-   int block_start = offset();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   BLOCK_COMMENT(&quot;string_inflate {&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   Register stop_char = Z_R0;</span>
<span class="udiff-line-removed">-   Register table     = Z_R1;</span>
<span class="udiff-line-removed">-   Register src_addr  = tmp;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   assert_different_registers(Z_R0, Z_R1, tmp, src, dst, cnt);</span>
<span class="udiff-line-removed">-   assert(dst-&gt;encoding()%2 == 0, &quot;must be even reg&quot;);</span>
<span class="udiff-line-removed">-   assert(cnt-&gt;encoding()%2 == 1, &quot;must be odd reg&quot;);</span>
<span class="udiff-line-removed">-   assert(cnt-&gt;encoding() - dst-&gt;encoding() == 1, &quot;must be even/odd pair&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   StubRoutines::zarch::generate_load_trot_table_addr(this, table);  // kills Z_R0 (if ASSERT)</span>
<span class="udiff-line-removed">-   clear_reg(stop_char);  // Stop character. Not used here, but initialized to have a defined value.</span>
<span class="udiff-line-removed">-   lgr_if_needed(src_addr, src);</span>
<span class="udiff-line-removed">-   z_llgfr(cnt, cnt);     // # src characters, must be a positive simm32.</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   translate_ot(dst, src_addr, /* mask = */ 0x0001);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   BLOCK_COMMENT(&quot;} string_inflate&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   return offset() - block_start;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- // Inflate byte[] to char[].</span>
<span class="udiff-line-removed">- //   Restores: src, dst</span>
<span class="udiff-line-removed">- //   Uses:     cnt</span>
<span class="udiff-line-removed">- //   Kills:    tmp, Z_R0, Z_R1.</span>
<span class="udiff-line-removed">- // Note:</span>
<span class="udiff-line-removed">- //   cnt is signed int. Do not rely on high word!</span>
<span class="udiff-line-removed">- //       counts # characters, not bytes.</span>
<span class="udiff-line-removed">- unsigned int MacroAssembler::string_inflate(Register src, Register dst, Register cnt, Register tmp) {</span>
<span class="udiff-line-removed">-   assert_different_registers(Z_R0, Z_R1, src, dst, cnt, tmp);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   BLOCK_COMMENT(&quot;string_inflate {&quot;);</span>
<span class="udiff-line-removed">-   int block_start = offset();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   Register   Rcnt = cnt;   // # characters (src: bytes, dst: char (2-byte)), remaining after current loop.</span>
<span class="udiff-line-removed">-   Register   Rix  = tmp;   // loop index</span>
<span class="udiff-line-removed">-   Register   Rsrc = src;   // addr(src array)</span>
<span class="udiff-line-removed">-   Register   Rdst = dst;   // addr(dst array)</span>
<span class="udiff-line-removed">-   Label      ScalarShortcut, AllDone;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #if 0  // Sacrifice shortcuts for code compactness</span>
<span class="udiff-line-removed">-   {</span>
<span class="udiff-line-removed">-     //---&lt;  shortcuts for short strings (very frequent)   &gt;---</span>
<span class="udiff-line-removed">-     Label   skipShortcut, skip4Shortcut;</span>
<span class="udiff-line-removed">-     z_ltr(Rcnt, Rcnt);                     // absolutely nothing to do for strings of len == 0.</span>
<span class="udiff-line-removed">-     z_brz(AllDone);</span>
<span class="udiff-line-removed">-     clear_reg(Z_R0);                       // make sure registers are properly initialized.</span>
<span class="udiff-line-removed">-     clear_reg(Z_R1);</span>
<span class="udiff-line-removed">-     z_chi(Rcnt, 4);</span>
<span class="udiff-line-removed">-     z_brne(skip4Shortcut);                 // 4 characters are very frequent</span>
<span class="udiff-line-removed">-       z_icm(Z_R0, 5,    0, Rsrc);          // Treat exactly 4 characters specially.</span>
<span class="udiff-line-removed">-       z_icm(Z_R1, 5,    2, Rsrc);</span>
<span class="udiff-line-removed">-       z_stm(Z_R0, Z_R1, 0, Rdst);</span>
<span class="udiff-line-removed">-       z_bru(AllDone);</span>
<span class="udiff-line-removed">-     bind(skip4Shortcut);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     z_chi(Rcnt, 8);</span>
<span class="udiff-line-removed">-     z_brh(skipShortcut);                   // There&#39;s a lot to do...</span>
<span class="udiff-line-removed">-     z_lgfr(Z_R0, Rcnt);                    // remaining #characters (&lt;= 8). Precond for scalar loop.</span>
<span class="udiff-line-removed">-                                            // This does not destroy the &quot;register cleared&quot; state of Z_R0.</span>
<span class="udiff-line-removed">-     z_brl(ScalarShortcut);                 // Just a few characters</span>
<span class="udiff-line-removed">-       z_icmh(Z_R0, 5, 0, Rsrc);            // Treat exactly 8 characters specially.</span>
<span class="udiff-line-removed">-       z_icmh(Z_R1, 5, 4, Rsrc);</span>
<span class="udiff-line-removed">-       z_icm(Z_R0,  5, 2, Rsrc);</span>
<span class="udiff-line-removed">-       z_icm(Z_R1,  5, 6, Rsrc);</span>
<span class="udiff-line-removed">-       z_stmg(Z_R0, Z_R1, 0, Rdst);</span>
<span class="udiff-line-removed">-       z_bru(AllDone);</span>
<span class="udiff-line-removed">-     bind(skipShortcut);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-   clear_reg(Z_R0);                         // make sure register is properly initialized.</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (VM_Version::has_VectorFacility()) {</span>
<span class="udiff-line-removed">-     const int  min_vcnt     = 32;          // Minimum #characters required to use vector instructions.</span>
<span class="udiff-line-removed">-                                            // Otherwise just do nothing in vector mode.</span>
<span class="udiff-line-removed">-                                            // Must be multiple of vector register length (16 bytes = 128 bits).</span>
<span class="udiff-line-removed">-     const int  log_min_vcnt = exact_log2(min_vcnt);</span>
<span class="udiff-line-removed">-     Label      VectorLoop, VectorDone;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     assert(VM_Version::has_DistinctOpnds(), &quot;Assumption when has_VectorFacility()&quot;);</span>
<span class="udiff-line-removed">-     z_srak(Rix, Rcnt, log_min_vcnt);       // calculate # vector loop iterations</span>
<span class="udiff-line-removed">-     z_brz(VectorDone);                     // skip if none</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     z_sllg(Z_R0, Rix, log_min_vcnt);       // remember #chars that will be processed by vector loop</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     bind(VectorLoop);</span>
<span class="udiff-line-removed">-       z_vlm(Z_V20, Z_V21, 0, Rsrc);        // get next 32 characters (single-byte)</span>
<span class="udiff-line-removed">-       add2reg(Rsrc, min_vcnt);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       z_vuplhb(Z_V22, Z_V20);              // V2 &lt;- (expand) V0(high)</span>
<span class="udiff-line-removed">-       z_vupllb(Z_V23, Z_V20);              // V3 &lt;- (expand) V0(low)</span>
<span class="udiff-line-removed">-       z_vuplhb(Z_V24, Z_V21);              // V4 &lt;- (expand) V1(high)</span>
<span class="udiff-line-removed">-       z_vupllb(Z_V25, Z_V21);              // V5 &lt;- (expand) V1(low)</span>
<span class="udiff-line-removed">-       z_vstm(Z_V22, Z_V25, 0, Rdst);       // store next 32 bytes</span>
<span class="udiff-line-removed">-       add2reg(Rdst, min_vcnt*2);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       z_brct(Rix, VectorLoop);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     bind(VectorDone);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   const int  min_cnt     =  8;             // Minimum #characters required to use unrolled scalar loop.</span>
<span class="udiff-line-removed">-                                            // Otherwise just do nothing in unrolled scalar mode.</span>
<span class="udiff-line-removed">-                                            // Must be multiple of 8.</span>
<span class="udiff-line-removed">-   {</span>
<span class="udiff-line-removed">-     const int  log_min_cnt = exact_log2(min_cnt);</span>
<span class="udiff-line-removed">-     Label      UnrolledLoop, UnrolledDone;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (VM_Version::has_DistinctOpnds()) {</span>
<span class="udiff-line-removed">-       z_srk(Rix, Rcnt, Z_R0);              // remaining # chars to process in unrolled loop</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       z_lr(Rix, Rcnt);</span>
<span class="udiff-line-removed">-       z_sr(Rix, Z_R0);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     z_sra(Rix, log_min_cnt);               // unrolled loop count</span>
<span class="udiff-line-removed">-     z_brz(UnrolledDone);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     clear_reg(Z_R0);</span>
<span class="udiff-line-removed">-     clear_reg(Z_R1);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     bind(UnrolledLoop);</span>
<span class="udiff-line-removed">-       z_icmh(Z_R0, 5, 0, Rsrc);</span>
<span class="udiff-line-removed">-       z_icmh(Z_R1, 5, 4, Rsrc);</span>
<span class="udiff-line-removed">-       z_icm(Z_R0,  5, 2, Rsrc);</span>
<span class="udiff-line-removed">-       z_icm(Z_R1,  5, 6, Rsrc);</span>
<span class="udiff-line-removed">-       add2reg(Rsrc, min_cnt);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       z_stmg(Z_R0, Z_R1, 0, Rdst);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       add2reg(Rdst, min_cnt*2);</span>
<span class="udiff-line-removed">-       z_brct(Rix, UnrolledLoop);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     bind(UnrolledDone);</span>
<span class="udiff-line-removed">-     z_lgfr(Z_R0, Rcnt);                    // # chars left over after unrolled loop.</span>
<span class="udiff-line-removed">-     z_nilf(Z_R0, min_cnt-1);</span>
<span class="udiff-line-removed">-     z_brnz(ScalarShortcut);                // if zero, there is nothing left to do for scalar loop.</span>
<span class="udiff-line-removed">-                                            // Rix == 0 in all cases.</span>
<span class="udiff-line-removed">-     z_sgfr(Z_R0, Rcnt);                    // negative # characters the ptrs have been advanced previously.</span>
<span class="udiff-line-removed">-     z_agr(Rdst, Z_R0);                     // restore ptr, double the element count for Rdst restore.</span>
<span class="udiff-line-removed">-     z_agr(Rdst, Z_R0);</span>
<span class="udiff-line-removed">-     z_agr(Rsrc, Z_R0);                     // restore ptr.</span>
<span class="udiff-line-removed">-     z_bru(AllDone);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   {</span>
<span class="udiff-line-removed">-     bind(ScalarShortcut);</span>
<span class="udiff-line-removed">-     // Z_R0 must contain remaining # characters as 64-bit signed int here.</span>
<span class="udiff-line-removed">-     //      register contents is preserved over scalar processing (for register fixup).</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #if 0  // Sacrifice shortcuts for code compactness</span>
<span class="udiff-line-removed">-     {</span>
<span class="udiff-line-removed">-       Label      ScalarDefault;</span>
<span class="udiff-line-removed">-       z_chi(Rcnt, 2);</span>
<span class="udiff-line-removed">-       z_brh(ScalarDefault);</span>
<span class="udiff-line-removed">-       z_llc(Z_R0,  0, Z_R0, Rsrc);     // 6 bytes</span>
<span class="udiff-line-removed">-       z_sth(Z_R0,  0, Z_R0, Rdst);     // 4 bytes</span>
<span class="udiff-line-removed">-       z_brl(AllDone);</span>
<span class="udiff-line-removed">-       z_llc(Z_R0,  1, Z_R0, Rsrc);     // 6 bytes</span>
<span class="udiff-line-removed">-       z_sth(Z_R0,  2, Z_R0, Rdst);     // 4 bytes</span>
<span class="udiff-line-removed">-       z_bru(AllDone);</span>
<span class="udiff-line-removed">-       bind(ScalarDefault);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     Label   CodeTable;</span>
<span class="udiff-line-removed">-     // Some comments on Rix calculation:</span>
<span class="udiff-line-removed">-     //  - Rcnt is small, therefore no bits shifted out of low word (sll(g) instructions).</span>
<span class="udiff-line-removed">-     //  - high word of both Rix and Rcnt may contain garbage</span>
<span class="udiff-line-removed">-     //  - the final lngfr takes care of that garbage, extending the sign to high word</span>
<span class="udiff-line-removed">-     z_sllg(Rix, Z_R0, 2);                // calculate 10*Rix = (4*Rix + Rix)*2</span>
<span class="udiff-line-removed">-     z_ar(Rix, Z_R0);</span>
<span class="udiff-line-removed">-     z_larl(Z_R1, CodeTable);</span>
<span class="udiff-line-removed">-     z_sll(Rix, 1);</span>
<span class="udiff-line-removed">-     z_lngfr(Rix, Rix);      // ix range: [0..7], after inversion &amp; mult: [-(7*12)..(0*12)].</span>
<span class="udiff-line-removed">-     z_bc(Assembler::bcondAlways, 0, Rix, Z_R1);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     z_llc(Z_R1,  6, Z_R0, Rsrc);  // 6 bytes</span>
<span class="udiff-line-removed">-     z_sth(Z_R1, 12, Z_R0, Rdst);  // 4 bytes</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     z_llc(Z_R1,  5, Z_R0, Rsrc);</span>
<span class="udiff-line-removed">-     z_sth(Z_R1, 10, Z_R0, Rdst);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     z_llc(Z_R1,  4, Z_R0, Rsrc);</span>
<span class="udiff-line-removed">-     z_sth(Z_R1,  8, Z_R0, Rdst);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     z_llc(Z_R1,  3, Z_R0, Rsrc);</span>
<span class="udiff-line-removed">-     z_sth(Z_R1,  6, Z_R0, Rdst);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     z_llc(Z_R1,  2, Z_R0, Rsrc);</span>
<span class="udiff-line-removed">-     z_sth(Z_R1,  4, Z_R0, Rdst);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     z_llc(Z_R1,  1, Z_R0, Rsrc);</span>
<span class="udiff-line-removed">-     z_sth(Z_R1,  2, Z_R0, Rdst);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     z_llc(Z_R1,  0, Z_R0, Rsrc);</span>
<span class="udiff-line-removed">-     z_sth(Z_R1,  0, Z_R0, Rdst);</span>
<span class="udiff-line-removed">-     bind(CodeTable);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     z_chi(Rcnt, 8);                        // no fixup for small strings. Rdst, Rsrc were not modified.</span>
<span class="udiff-line-removed">-     z_brl(AllDone);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     z_sgfr(Z_R0, Rcnt);                    // # characters the ptrs have been advanced previously.</span>
<span class="udiff-line-removed">-     z_agr(Rdst, Z_R0);                     // restore ptr, double the element count for Rdst restore.</span>
<span class="udiff-line-removed">-     z_agr(Rdst, Z_R0);</span>
<span class="udiff-line-removed">-     z_agr(Rsrc, Z_R0);                     // restore ptr.</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   bind(AllDone);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   BLOCK_COMMENT(&quot;} string_inflate&quot;);</span>
<span class="udiff-line-removed">-   return offset() - block_start;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- // Inflate byte[] to char[], length known at compile time.</span>
<span class="udiff-line-removed">- //   Restores: src, dst</span>
<span class="udiff-line-removed">- //   Kills:    tmp, Z_R0, Z_R1.</span>
<span class="udiff-line-removed">- // Note:</span>
<span class="udiff-line-removed">- //   len is signed int. Counts # characters, not bytes.</span>
<span class="udiff-line-removed">- unsigned int MacroAssembler::string_inflate_const(Register src, Register dst, Register tmp, int len) {</span>
<span class="udiff-line-removed">-   assert_different_registers(Z_R0, Z_R1, src, dst, tmp);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   BLOCK_COMMENT(&quot;string_inflate_const {&quot;);</span>
<span class="udiff-line-removed">-   int block_start = offset();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   Register   Rix  = tmp;   // loop index</span>
<span class="udiff-line-removed">-   Register   Rsrc = src;   // addr(src array)</span>
<span class="udiff-line-removed">-   Register   Rdst = dst;   // addr(dst array)</span>
<span class="udiff-line-removed">-   Label      ScalarShortcut, AllDone;</span>
<span class="udiff-line-removed">-   int        nprocessed = 0;</span>
<span class="udiff-line-removed">-   int        src_off    = 0;  // compensate for saved (optimized away) ptr advancement.</span>
<span class="udiff-line-removed">-   int        dst_off    = 0;  // compensate for saved (optimized away) ptr advancement.</span>
<span class="udiff-line-removed">-   bool       restore_inputs = false;</span>
<span class="udiff-line-removed">-   bool       workreg_clear  = false;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if ((len &gt;= 32) &amp;&amp; VM_Version::has_VectorFacility()) {</span>
<span class="udiff-line-removed">-     const int  min_vcnt     = 32;          // Minimum #characters required to use vector instructions.</span>
<span class="udiff-line-removed">-                                            // Otherwise just do nothing in vector mode.</span>
<span class="udiff-line-removed">-                                            // Must be multiple of vector register length (16 bytes = 128 bits).</span>
<span class="udiff-line-removed">-     const int  log_min_vcnt = exact_log2(min_vcnt);</span>
<span class="udiff-line-removed">-     const int  iterations   = (len - nprocessed) &gt;&gt; log_min_vcnt;</span>
<span class="udiff-line-removed">-     nprocessed             += iterations &lt;&lt; log_min_vcnt;</span>
<span class="udiff-line-removed">-     Label      VectorLoop;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (iterations == 1) {</span>
<span class="udiff-line-removed">-       z_vlm(Z_V20, Z_V21, 0+src_off, Rsrc);  // get next 32 characters (single-byte)</span>
<span class="udiff-line-removed">-       z_vuplhb(Z_V22, Z_V20);                // V2 &lt;- (expand) V0(high)</span>
<span class="udiff-line-removed">-       z_vupllb(Z_V23, Z_V20);                // V3 &lt;- (expand) V0(low)</span>
<span class="udiff-line-removed">-       z_vuplhb(Z_V24, Z_V21);                // V4 &lt;- (expand) V1(high)</span>
<span class="udiff-line-removed">-       z_vupllb(Z_V25, Z_V21);                // V5 &lt;- (expand) V1(low)</span>
<span class="udiff-line-removed">-       z_vstm(Z_V22, Z_V25, 0+dst_off, Rdst); // store next 32 bytes</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       src_off += min_vcnt;</span>
<span class="udiff-line-removed">-       dst_off += min_vcnt*2;</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       restore_inputs = true;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       z_lgfi(Rix, len&gt;&gt;log_min_vcnt);</span>
<span class="udiff-line-removed">-       bind(VectorLoop);</span>
<span class="udiff-line-removed">-         z_vlm(Z_V20, Z_V21, 0, Rsrc);        // get next 32 characters (single-byte)</span>
<span class="udiff-line-removed">-         add2reg(Rsrc, min_vcnt);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         z_vuplhb(Z_V22, Z_V20);              // V2 &lt;- (expand) V0(high)</span>
<span class="udiff-line-removed">-         z_vupllb(Z_V23, Z_V20);              // V3 &lt;- (expand) V0(low)</span>
<span class="udiff-line-removed">-         z_vuplhb(Z_V24, Z_V21);              // V4 &lt;- (expand) V1(high)</span>
<span class="udiff-line-removed">-         z_vupllb(Z_V25, Z_V21);              // V5 &lt;- (expand) V1(low)</span>
<span class="udiff-line-removed">-         z_vstm(Z_V22, Z_V25, 0, Rdst);       // store next 32 bytes</span>
<span class="udiff-line-removed">-         add2reg(Rdst, min_vcnt*2);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         z_brct(Rix, VectorLoop);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (((len-nprocessed) &gt;= 16) &amp;&amp; VM_Version::has_VectorFacility()) {</span>
<span class="udiff-line-removed">-     const int  min_vcnt     = 16;          // Minimum #characters required to use vector instructions.</span>
<span class="udiff-line-removed">-                                            // Otherwise just do nothing in vector mode.</span>
<span class="udiff-line-removed">-                                            // Must be multiple of vector register length (16 bytes = 128 bits).</span>
<span class="udiff-line-removed">-     const int  log_min_vcnt = exact_log2(min_vcnt);</span>
<span class="udiff-line-removed">-     const int  iterations   = (len - nprocessed) &gt;&gt; log_min_vcnt;</span>
<span class="udiff-line-removed">-     nprocessed             += iterations &lt;&lt; log_min_vcnt;</span>
<span class="udiff-line-removed">-     assert(iterations == 1, &quot;must be!&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     z_vl(Z_V20, 0+src_off, Z_R0, Rsrc);    // get next 16 characters (single-byte)</span>
<span class="udiff-line-removed">-     z_vuplhb(Z_V22, Z_V20);                // V2 &lt;- (expand) V0(high)</span>
<span class="udiff-line-removed">-     z_vupllb(Z_V23, Z_V20);                // V3 &lt;- (expand) V0(low)</span>
<span class="udiff-line-removed">-     z_vstm(Z_V22, Z_V23, 0+dst_off, Rdst); // store next 32 bytes</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     src_off += min_vcnt;</span>
<span class="udiff-line-removed">-     dst_off += min_vcnt*2;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if ((len-nprocessed) &gt; 8) {</span>
<span class="udiff-line-removed">-     const int  min_cnt     =  8;           // Minimum #characters required to use unrolled scalar loop.</span>
<span class="udiff-line-removed">-                                            // Otherwise just do nothing in unrolled scalar mode.</span>
<span class="udiff-line-removed">-                                            // Must be multiple of 8.</span>
<span class="udiff-line-removed">-     const int  log_min_cnt = exact_log2(min_cnt);</span>
<span class="udiff-line-removed">-     const int  iterations  = (len - nprocessed) &gt;&gt; log_min_cnt;</span>
<span class="udiff-line-removed">-     nprocessed     += iterations &lt;&lt; log_min_cnt;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     //---&lt;  avoid loop overhead/ptr increment for small # iterations  &gt;---</span>
<span class="udiff-line-removed">-     if (iterations &lt;= 2) {</span>
<span class="udiff-line-removed">-       clear_reg(Z_R0);</span>
<span class="udiff-line-removed">-       clear_reg(Z_R1);</span>
<span class="udiff-line-removed">-       workreg_clear = true;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       z_icmh(Z_R0, 5, 0+src_off, Rsrc);</span>
<span class="udiff-line-removed">-       z_icmh(Z_R1, 5, 4+src_off, Rsrc);</span>
<span class="udiff-line-removed">-       z_icm(Z_R0,  5, 2+src_off, Rsrc);</span>
<span class="udiff-line-removed">-       z_icm(Z_R1,  5, 6+src_off, Rsrc);</span>
<span class="udiff-line-removed">-       z_stmg(Z_R0, Z_R1, 0+dst_off, Rdst);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       src_off += min_cnt;</span>
<span class="udiff-line-removed">-       dst_off += min_cnt*2;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (iterations == 2) {</span>
<span class="udiff-line-removed">-       z_icmh(Z_R0, 5, 0+src_off, Rsrc);</span>
<span class="udiff-line-removed">-       z_icmh(Z_R1, 5, 4+src_off, Rsrc);</span>
<span class="udiff-line-removed">-       z_icm(Z_R0,  5, 2+src_off, Rsrc);</span>
<span class="udiff-line-removed">-       z_icm(Z_R1,  5, 6+src_off, Rsrc);</span>
<span class="udiff-line-removed">-       z_stmg(Z_R0, Z_R1, 0+dst_off, Rdst);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       src_off += min_cnt;</span>
<span class="udiff-line-removed">-       dst_off += min_cnt*2;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (iterations &gt; 2) {</span>
<span class="udiff-line-removed">-       Label      UnrolledLoop;</span>
<span class="udiff-line-removed">-       restore_inputs  = true;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       clear_reg(Z_R0);</span>
<span class="udiff-line-removed">-       clear_reg(Z_R1);</span>
<span class="udiff-line-removed">-       workreg_clear = true;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       z_lgfi(Rix, iterations);</span>
<span class="udiff-line-removed">-       bind(UnrolledLoop);</span>
<span class="udiff-line-removed">-         z_icmh(Z_R0, 5, 0, Rsrc);</span>
<span class="udiff-line-removed">-         z_icmh(Z_R1, 5, 4, Rsrc);</span>
<span class="udiff-line-removed">-         z_icm(Z_R0,  5, 2, Rsrc);</span>
<span class="udiff-line-removed">-         z_icm(Z_R1,  5, 6, Rsrc);</span>
<span class="udiff-line-removed">-         add2reg(Rsrc, min_cnt);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         z_stmg(Z_R0, Z_R1, 0, Rdst);</span>
<span class="udiff-line-removed">-         add2reg(Rdst, min_cnt*2);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         z_brct(Rix, UnrolledLoop);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if ((len-nprocessed) &gt; 0) {</span>
<span class="udiff-line-removed">-     switch (len-nprocessed) {</span>
<span class="udiff-line-removed">-       case 8:</span>
<span class="udiff-line-removed">-         if (!workreg_clear) {</span>
<span class="udiff-line-removed">-           clear_reg(Z_R0);</span>
<span class="udiff-line-removed">-           clear_reg(Z_R1);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         z_icmh(Z_R0, 5, 0+src_off, Rsrc);</span>
<span class="udiff-line-removed">-         z_icmh(Z_R1, 5, 4+src_off, Rsrc);</span>
<span class="udiff-line-removed">-         z_icm(Z_R0,  5, 2+src_off, Rsrc);</span>
<span class="udiff-line-removed">-         z_icm(Z_R1,  5, 6+src_off, Rsrc);</span>
<span class="udiff-line-removed">-         z_stmg(Z_R0, Z_R1, 0+dst_off, Rdst);</span>
<span class="udiff-line-removed">-         break;</span>
<span class="udiff-line-removed">-       case 7:</span>
<span class="udiff-line-removed">-         if (!workreg_clear) {</span>
<span class="udiff-line-removed">-           clear_reg(Z_R0);</span>
<span class="udiff-line-removed">-           clear_reg(Z_R1);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         clear_reg(Rix);</span>
<span class="udiff-line-removed">-         z_icm(Z_R0,  5, 0+src_off, Rsrc);</span>
<span class="udiff-line-removed">-         z_icm(Z_R1,  5, 2+src_off, Rsrc);</span>
<span class="udiff-line-removed">-         z_icm(Rix,   5, 4+src_off, Rsrc);</span>
<span class="udiff-line-removed">-         z_stm(Z_R0,  Z_R1, 0+dst_off, Rdst);</span>
<span class="udiff-line-removed">-         z_llc(Z_R0,  6+src_off, Z_R0, Rsrc);</span>
<span class="udiff-line-removed">-         z_st(Rix,    8+dst_off, Z_R0, Rdst);</span>
<span class="udiff-line-removed">-         z_sth(Z_R0, 12+dst_off, Z_R0, Rdst);</span>
<span class="udiff-line-removed">-         break;</span>
<span class="udiff-line-removed">-       case 6:</span>
<span class="udiff-line-removed">-         if (!workreg_clear) {</span>
<span class="udiff-line-removed">-           clear_reg(Z_R0);</span>
<span class="udiff-line-removed">-           clear_reg(Z_R1);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         clear_reg(Rix);</span>
<span class="udiff-line-removed">-         z_icm(Z_R0, 5, 0+src_off, Rsrc);</span>
<span class="udiff-line-removed">-         z_icm(Z_R1, 5, 2+src_off, Rsrc);</span>
<span class="udiff-line-removed">-         z_icm(Rix,  5, 4+src_off, Rsrc);</span>
<span class="udiff-line-removed">-         z_stm(Z_R0, Z_R1, 0+dst_off, Rdst);</span>
<span class="udiff-line-removed">-         z_st(Rix,   8+dst_off, Z_R0, Rdst);</span>
<span class="udiff-line-removed">-         break;</span>
<span class="udiff-line-removed">-       case 5:</span>
<span class="udiff-line-removed">-         if (!workreg_clear) {</span>
<span class="udiff-line-removed">-           clear_reg(Z_R0);</span>
<span class="udiff-line-removed">-           clear_reg(Z_R1);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         z_icm(Z_R0, 5, 0+src_off, Rsrc);</span>
<span class="udiff-line-removed">-         z_icm(Z_R1, 5, 2+src_off, Rsrc);</span>
<span class="udiff-line-removed">-         z_llc(Rix,  4+src_off, Z_R0, Rsrc);</span>
<span class="udiff-line-removed">-         z_stm(Z_R0, Z_R1, 0+dst_off, Rdst);</span>
<span class="udiff-line-removed">-         z_sth(Rix,  8+dst_off, Z_R0, Rdst);</span>
<span class="udiff-line-removed">-         break;</span>
<span class="udiff-line-removed">-       case 4:</span>
<span class="udiff-line-removed">-         if (!workreg_clear) {</span>
<span class="udiff-line-removed">-           clear_reg(Z_R0);</span>
<span class="udiff-line-removed">-           clear_reg(Z_R1);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         z_icm(Z_R0, 5, 0+src_off, Rsrc);</span>
<span class="udiff-line-removed">-         z_icm(Z_R1, 5, 2+src_off, Rsrc);</span>
<span class="udiff-line-removed">-         z_stm(Z_R0, Z_R1, 0+dst_off, Rdst);</span>
<span class="udiff-line-removed">-         break;</span>
<span class="udiff-line-removed">-       case 3:</span>
<span class="udiff-line-removed">-         if (!workreg_clear) {</span>
<span class="udiff-line-removed">-           clear_reg(Z_R0);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         z_llc(Z_R1, 2+src_off, Z_R0, Rsrc);</span>
<span class="udiff-line-removed">-         z_icm(Z_R0, 5, 0+src_off, Rsrc);</span>
<span class="udiff-line-removed">-         z_sth(Z_R1, 4+dst_off, Z_R0, Rdst);</span>
<span class="udiff-line-removed">-         z_st(Z_R0,  0+dst_off, Rdst);</span>
<span class="udiff-line-removed">-         break;</span>
<span class="udiff-line-removed">-       case 2:</span>
<span class="udiff-line-removed">-         z_llc(Z_R0, 0+src_off, Z_R0, Rsrc);</span>
<span class="udiff-line-removed">-         z_llc(Z_R1, 1+src_off, Z_R0, Rsrc);</span>
<span class="udiff-line-removed">-         z_sth(Z_R0, 0+dst_off, Z_R0, Rdst);</span>
<span class="udiff-line-removed">-         z_sth(Z_R1, 2+dst_off, Z_R0, Rdst);</span>
<span class="udiff-line-removed">-         break;</span>
<span class="udiff-line-removed">-       case 1:</span>
<span class="udiff-line-removed">-         z_llc(Z_R0, 0+src_off, Z_R0, Rsrc);</span>
<span class="udiff-line-removed">-         z_sth(Z_R0, 0+dst_off, Z_R0, Rdst);</span>
<span class="udiff-line-removed">-         break;</span>
<span class="udiff-line-removed">-       default:</span>
<span class="udiff-line-removed">-         guarantee(false, &quot;Impossible&quot;);</span>
<span class="udiff-line-removed">-         break;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     src_off   +=  len-nprocessed;</span>
<span class="udiff-line-removed">-     dst_off   += (len-nprocessed)*2;</span>
<span class="udiff-line-removed">-     nprocessed = len;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   //---&lt; restore modified input registers  &gt;---</span>
<span class="udiff-line-removed">-   if ((nprocessed &gt; 0) &amp;&amp; restore_inputs) {</span>
<span class="udiff-line-removed">-     z_agfi(Rsrc, -(nprocessed-src_off));</span>
<span class="udiff-line-removed">-     if (nprocessed &lt; 1000000000) { // avoid int overflow</span>
<span class="udiff-line-removed">-       z_agfi(Rdst, -(nprocessed*2-dst_off));</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       z_agfi(Rdst, -(nprocessed-dst_off));</span>
<span class="udiff-line-removed">-       z_agfi(Rdst, -nprocessed);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   BLOCK_COMMENT(&quot;} string_inflate_const&quot;);</span>
<span class="udiff-line-removed">-   return offset() - block_start;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- // Kills src.</span>
<span class="udiff-line-removed">- unsigned int MacroAssembler::has_negatives(Register result, Register src, Register cnt,</span>
<span class="udiff-line-removed">-                                            Register odd_reg, Register even_reg, Register tmp) {</span>
<span class="udiff-line-removed">-   int block_start = offset();</span>
<span class="udiff-line-removed">-   Label Lloop1, Lloop2, Lslow, Lnotfound, Ldone;</span>
<span class="udiff-line-removed">-   const Register addr = src, mask = tmp;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   BLOCK_COMMENT(&quot;has_negatives {&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   z_llgfr(Z_R1, cnt);      // Number of bytes to read. (Must be a positive simm32.)</span>
<span class="udiff-line-removed">-   z_llilf(mask, 0x80808080);</span>
<span class="udiff-line-removed">-   z_lhi(result, 1);        // Assume true.</span>
<span class="udiff-line-removed">-   // Last possible addr for fast loop.</span>
<span class="udiff-line-removed">-   z_lay(odd_reg, -16, Z_R1, src);</span>
<span class="udiff-line-removed">-   z_chi(cnt, 16);</span>
<span class="udiff-line-removed">-   z_brl(Lslow);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // ind1: index, even_reg: index increment, odd_reg: index limit</span>
<span class="udiff-line-removed">-   z_iihf(mask, 0x80808080);</span>
<span class="udiff-line-removed">-   z_lghi(even_reg, 16);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   bind(Lloop1); // 16 bytes per iteration.</span>
<span class="udiff-line-removed">-   z_lg(Z_R0, Address(addr));</span>
<span class="udiff-line-removed">-   z_lg(Z_R1, Address(addr, 8));</span>
<span class="udiff-line-removed">-   z_ogr(Z_R0, Z_R1);</span>
<span class="udiff-line-removed">-   z_ngr(Z_R0, mask);</span>
<span class="udiff-line-removed">-   z_brne(Ldone);           // If found return 1.</span>
<span class="udiff-line-removed">-   z_brxlg(addr, even_reg, Lloop1);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   bind(Lslow);</span>
<span class="udiff-line-removed">-   z_aghi(odd_reg, 16-1);   // Last possible addr for slow loop.</span>
<span class="udiff-line-removed">-   z_lghi(even_reg, 1);</span>
<span class="udiff-line-removed">-   z_cgr(addr, odd_reg);</span>
<span class="udiff-line-removed">-   z_brh(Lnotfound);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   bind(Lloop2); // 1 byte per iteration.</span>
<span class="udiff-line-removed">-   z_cli(Address(addr), 0x80);</span>
<span class="udiff-line-removed">-   z_brnl(Ldone);           // If found return 1.</span>
<span class="udiff-line-removed">-   z_brxlg(addr, even_reg, Lloop2);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   bind(Lnotfound);</span>
<span class="udiff-line-removed">-   z_lhi(result, 0);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   bind(Ldone);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   BLOCK_COMMENT(&quot;} has_negatives&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   return offset() - block_start;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- // kill: cnt1, cnt2, odd_reg, even_reg; early clobber: result</span>
<span class="udiff-line-removed">- unsigned int MacroAssembler::string_compare(Register str1, Register str2,</span>
<span class="udiff-line-removed">-                                             Register cnt1, Register cnt2,</span>
<span class="udiff-line-removed">-                                             Register odd_reg, Register even_reg, Register result, int ae) {</span>
<span class="udiff-line-removed">-   int block_start = offset();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   assert_different_registers(str1, cnt1, cnt2, odd_reg, even_reg, result);</span>
<span class="udiff-line-removed">-   assert_different_registers(str2, cnt1, cnt2, odd_reg, even_reg, result);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // If strings are equal up to min length, return the length difference.</span>
<span class="udiff-line-removed">-   const Register diff = result, // Pre-set result with length difference.</span>
<span class="udiff-line-removed">-                  min  = cnt1,   // min number of bytes</span>
<span class="udiff-line-removed">-                  tmp  = cnt2;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Note: Making use of the fact that compareTo(a, b) == -compareTo(b, a)</span>
<span class="udiff-line-removed">-   // we interchange str1 and str2 in the UL case and negate the result.</span>
<span class="udiff-line-removed">-   // Like this, str1 is always latin1 encoded, except for the UU case.</span>
<span class="udiff-line-removed">-   // In addition, we need 0 (or sign which is 0) extend when using 64 bit register.</span>
<span class="udiff-line-removed">-   const bool used_as_LU = (ae == StrIntrinsicNode::LU || ae == StrIntrinsicNode::UL);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   BLOCK_COMMENT(&quot;string_compare {&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (used_as_LU) {</span>
<span class="udiff-line-removed">-     z_srl(cnt2, 1);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // See if the lengths are different, and calculate min in cnt1.</span>
<span class="udiff-line-removed">-   // Save diff in case we need it for a tie-breaker.</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // diff = cnt1 - cnt2</span>
<span class="udiff-line-removed">-   if (VM_Version::has_DistinctOpnds()) {</span>
<span class="udiff-line-removed">-     z_srk(diff, cnt1, cnt2);</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     z_lr(diff, cnt1);</span>
<span class="udiff-line-removed">-     z_sr(diff, cnt2);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   if (str1 != str2) {</span>
<span class="udiff-line-removed">-     if (VM_Version::has_LoadStoreConditional()) {</span>
<span class="udiff-line-removed">-       z_locr(min, cnt2, Assembler::bcondHigh);</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       Label Lskip;</span>
<span class="udiff-line-removed">-       z_brl(Lskip);    // min ok if cnt1 &lt; cnt2</span>
<span class="udiff-line-removed">-       z_lr(min, cnt2); // min = cnt2</span>
<span class="udiff-line-removed">-       bind(Lskip);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (ae == StrIntrinsicNode::UU) {</span>
<span class="udiff-line-removed">-     z_sra(diff, 1);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   if (str1 != str2) {</span>
<span class="udiff-line-removed">-     Label Ldone;</span>
<span class="udiff-line-removed">-     if (used_as_LU) {</span>
<span class="udiff-line-removed">-       // Loop which searches the first difference character by character.</span>
<span class="udiff-line-removed">-       Label Lloop;</span>
<span class="udiff-line-removed">-       const Register ind1 = Z_R1,</span>
<span class="udiff-line-removed">-                      ind2 = min;</span>
<span class="udiff-line-removed">-       int stride1 = 1, stride2 = 2; // See comment above.</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       // ind1: index, even_reg: index increment, odd_reg: index limit</span>
<span class="udiff-line-removed">-       z_llilf(ind1, (unsigned int)(-stride1));</span>
<span class="udiff-line-removed">-       z_lhi(even_reg, stride1);</span>
<span class="udiff-line-removed">-       add2reg(odd_reg, -stride1, min);</span>
<span class="udiff-line-removed">-       clear_reg(ind2); // kills min</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       bind(Lloop);</span>
<span class="udiff-line-removed">-       z_brxh(ind1, even_reg, Ldone);</span>
<span class="udiff-line-removed">-       z_llc(tmp, Address(str1, ind1));</span>
<span class="udiff-line-removed">-       z_llh(Z_R0, Address(str2, ind2));</span>
<span class="udiff-line-removed">-       z_ahi(ind2, stride2);</span>
<span class="udiff-line-removed">-       z_sr(tmp, Z_R0);</span>
<span class="udiff-line-removed">-       z_bre(Lloop);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       z_lr(result, tmp);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       // Use clcle in fast loop (only for same encoding).</span>
<span class="udiff-line-removed">-       z_lgr(Z_R0, str1);</span>
<span class="udiff-line-removed">-       z_lgr(even_reg, str2);</span>
<span class="udiff-line-removed">-       z_llgfr(Z_R1, min);</span>
<span class="udiff-line-removed">-       z_llgfr(odd_reg, min);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       if (ae == StrIntrinsicNode::LL) {</span>
<span class="udiff-line-removed">-         compare_long_ext(Z_R0, even_reg, 0);</span>
<span class="udiff-line-removed">-       } else {</span>
<span class="udiff-line-removed">-         compare_long_uni(Z_R0, even_reg, 0);</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       z_bre(Ldone);</span>
<span class="udiff-line-removed">-       z_lgr(Z_R1, Z_R0);</span>
<span class="udiff-line-removed">-       if (ae == StrIntrinsicNode::LL) {</span>
<span class="udiff-line-removed">-         z_llc(Z_R0, Address(even_reg));</span>
<span class="udiff-line-removed">-         z_llc(result, Address(Z_R1));</span>
<span class="udiff-line-removed">-       } else {</span>
<span class="udiff-line-removed">-         z_llh(Z_R0, Address(even_reg));</span>
<span class="udiff-line-removed">-         z_llh(result, Address(Z_R1));</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       z_sr(result, Z_R0);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // Otherwise, return the difference between the first mismatched chars.</span>
<span class="udiff-line-removed">-     bind(Ldone);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (ae == StrIntrinsicNode::UL) {</span>
<span class="udiff-line-removed">-     z_lcr(result, result); // Negate result (see note above).</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   BLOCK_COMMENT(&quot;} string_compare&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   return offset() - block_start;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- unsigned int MacroAssembler::array_equals(bool is_array_equ, Register ary1, Register ary2, Register limit,</span>
<span class="udiff-line-removed">-                                           Register odd_reg, Register even_reg, Register result, bool is_byte) {</span>
<span class="udiff-line-removed">-   int block_start = offset();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   BLOCK_COMMENT(&quot;array_equals {&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   assert_different_registers(ary1, limit, odd_reg, even_reg);</span>
<span class="udiff-line-removed">-   assert_different_registers(ary2, limit, odd_reg, even_reg);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   Label Ldone, Ldone_true, Ldone_false, Lclcle, CLC_template;</span>
<span class="udiff-line-removed">-   int base_offset = 0;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (ary1 != ary2) {</span>
<span class="udiff-line-removed">-     if (is_array_equ) {</span>
<span class="udiff-line-removed">-       base_offset = arrayOopDesc::base_offset_in_bytes(is_byte ? T_BYTE : T_CHAR);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       // Return true if the same array.</span>
<span class="udiff-line-removed">-       compareU64_and_branch(ary1, ary2, Assembler::bcondEqual, Ldone_true);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       // Return false if one of them is NULL.</span>
<span class="udiff-line-removed">-       compareU64_and_branch(ary1, (intptr_t)0, Assembler::bcondEqual, Ldone_false);</span>
<span class="udiff-line-removed">-       compareU64_and_branch(ary2, (intptr_t)0, Assembler::bcondEqual, Ldone_false);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       // Load the lengths of arrays.</span>
<span class="udiff-line-removed">-       z_llgf(odd_reg, Address(ary1, arrayOopDesc::length_offset_in_bytes()));</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       // Return false if the two arrays are not equal length.</span>
<span class="udiff-line-removed">-       z_c(odd_reg, Address(ary2, arrayOopDesc::length_offset_in_bytes()));</span>
<span class="udiff-line-removed">-       z_brne(Ldone_false);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       // string len in bytes (right operand)</span>
<span class="udiff-line-removed">-       if (!is_byte) {</span>
<span class="udiff-line-removed">-         z_chi(odd_reg, 128);</span>
<span class="udiff-line-removed">-         z_sll(odd_reg, 1); // preserves flags</span>
<span class="udiff-line-removed">-         z_brh(Lclcle);</span>
<span class="udiff-line-removed">-       } else {</span>
<span class="udiff-line-removed">-         compareU32_and_branch(odd_reg, (intptr_t)256, Assembler::bcondHigh, Lclcle);</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       z_llgfr(odd_reg, limit); // Need to zero-extend prior to using the value.</span>
<span class="udiff-line-removed">-       compareU32_and_branch(limit, (intptr_t)256, Assembler::bcondHigh, Lclcle);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // Use clc instruction for up to 256 bytes.</span>
<span class="udiff-line-removed">-     {</span>
<span class="udiff-line-removed">-       Register str1_reg = ary1,</span>
<span class="udiff-line-removed">-           str2_reg = ary2;</span>
<span class="udiff-line-removed">-       if (is_array_equ) {</span>
<span class="udiff-line-removed">-         str1_reg = Z_R1;</span>
<span class="udiff-line-removed">-         str2_reg = even_reg;</span>
<span class="udiff-line-removed">-         add2reg(str1_reg, base_offset, ary1); // string addr (left operand)</span>
<span class="udiff-line-removed">-         add2reg(str2_reg, base_offset, ary2); // string addr (right operand)</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       z_ahi(odd_reg, -1); // Clc uses decremented limit. Also compare result to 0.</span>
<span class="udiff-line-removed">-       z_brl(Ldone_true);</span>
<span class="udiff-line-removed">-       // Note: We could jump to the template if equal.</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       assert(VM_Version::has_ExecuteExtensions(), &quot;unsupported hardware&quot;);</span>
<span class="udiff-line-removed">-       z_exrl(odd_reg, CLC_template);</span>
<span class="udiff-line-removed">-       z_bre(Ldone_true);</span>
<span class="udiff-line-removed">-       // fall through</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       bind(Ldone_false);</span>
<span class="udiff-line-removed">-       clear_reg(result);</span>
<span class="udiff-line-removed">-       z_bru(Ldone);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       bind(CLC_template);</span>
<span class="udiff-line-removed">-       z_clc(0, 0, str1_reg, 0, str2_reg);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // Use clcle instruction.</span>
<span class="udiff-line-removed">-     {</span>
<span class="udiff-line-removed">-       bind(Lclcle);</span>
<span class="udiff-line-removed">-       add2reg(even_reg, base_offset, ary2); // string addr (right operand)</span>
<span class="udiff-line-removed">-       add2reg(Z_R0, base_offset, ary1);     // string addr (left operand)</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       z_lgr(Z_R1, odd_reg); // string len in bytes (left operand)</span>
<span class="udiff-line-removed">-       if (is_byte) {</span>
<span class="udiff-line-removed">-         compare_long_ext(Z_R0, even_reg, 0);</span>
<span class="udiff-line-removed">-       } else {</span>
<span class="udiff-line-removed">-         compare_long_uni(Z_R0, even_reg, 0);</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       z_lghi(result, 0); // Preserve flags.</span>
<span class="udiff-line-removed">-       z_brne(Ldone);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   // fall through</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   bind(Ldone_true);</span>
<span class="udiff-line-removed">-   z_lghi(result, 1); // All characters are equal.</span>
<span class="udiff-line-removed">-   bind(Ldone);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   BLOCK_COMMENT(&quot;} array_equals&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   return offset() - block_start;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- // kill: haycnt, needlecnt, odd_reg, even_reg; early clobber: result</span>
<span class="udiff-line-removed">- unsigned int MacroAssembler::string_indexof(Register result, Register haystack, Register haycnt,</span>
<span class="udiff-line-removed">-                                             Register needle, Register needlecnt, int needlecntval,</span>
<span class="udiff-line-removed">-                                             Register odd_reg, Register even_reg, int ae) {</span>
<span class="udiff-line-removed">-   int block_start = offset();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Ensure 0&lt;needlecnt&lt;=haycnt in ideal graph as prerequisite!</span>
<span class="udiff-line-removed">-   assert(ae != StrIntrinsicNode::LU, &quot;Invalid encoding&quot;);</span>
<span class="udiff-line-removed">-   const int h_csize = (ae == StrIntrinsicNode::LL) ? 1 : 2;</span>
<span class="udiff-line-removed">-   const int n_csize = (ae == StrIntrinsicNode::UU) ? 2 : 1;</span>
<span class="udiff-line-removed">-   Label L_needle1, L_Found, L_NotFound;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   BLOCK_COMMENT(&quot;string_indexof {&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (needle == haystack) {</span>
<span class="udiff-line-removed">-     z_lhi(result, 0);</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Load first character of needle (R0 used by search_string instructions).</span>
<span class="udiff-line-removed">-   if (n_csize == 2) { z_llgh(Z_R0, Address(needle)); } else { z_llgc(Z_R0, Address(needle)); }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Compute last haystack addr to use if no match gets found.</span>
<span class="udiff-line-removed">-   if (needlecnt != noreg) { // variable needlecnt</span>
<span class="udiff-line-removed">-     z_ahi(needlecnt, -1); // Remaining characters after first one.</span>
<span class="udiff-line-removed">-     z_sr(haycnt, needlecnt); // Compute index succeeding last element to compare.</span>
<span class="udiff-line-removed">-     if (n_csize == 2) { z_sll(needlecnt, 1); } // In bytes.</span>
<span class="udiff-line-removed">-   } else { // constant needlecnt</span>
<span class="udiff-line-removed">-     assert((needlecntval &amp; 0x7fff) == needlecntval, &quot;must be positive simm16 immediate&quot;);</span>
<span class="udiff-line-removed">-     // Compute index succeeding last element to compare.</span>
<span class="udiff-line-removed">-     if (needlecntval != 1) { z_ahi(haycnt, 1 - needlecntval); }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   z_llgfr(haycnt, haycnt); // Clear high half.</span>
<span class="udiff-line-removed">-   z_lgr(result, haystack); // Final result will be computed from needle start pointer.</span>
<span class="udiff-line-removed">-   if (h_csize == 2) { z_sll(haycnt, 1); } // Scale to number of bytes.</span>
<span class="udiff-line-removed">-   z_agr(haycnt, haystack); // Point to address succeeding last element (haystack+scale*(haycnt-needlecnt+1)).</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (h_csize != n_csize) {</span>
<span class="udiff-line-removed">-     assert(ae == StrIntrinsicNode::UL, &quot;Invalid encoding&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (needlecnt != noreg || needlecntval != 1) {</span>
<span class="udiff-line-removed">-       if (needlecnt != noreg) {</span>
<span class="udiff-line-removed">-         compare32_and_branch(needlecnt, (intptr_t)0, Assembler::bcondEqual, L_needle1);</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       // Main Loop: UL version (now we have at least 2 characters).</span>
<span class="udiff-line-removed">-       Label L_OuterLoop, L_InnerLoop, L_Skip;</span>
<span class="udiff-line-removed">-       bind(L_OuterLoop); // Search for 1st 2 characters.</span>
<span class="udiff-line-removed">-       z_lgr(Z_R1, haycnt);</span>
<span class="udiff-line-removed">-       MacroAssembler::search_string_uni(Z_R1, result);</span>
<span class="udiff-line-removed">-       z_brc(Assembler::bcondNotFound, L_NotFound);</span>
<span class="udiff-line-removed">-       z_lgr(result, Z_R1);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       z_lghi(Z_R1, n_csize);</span>
<span class="udiff-line-removed">-       z_lghi(even_reg, h_csize);</span>
<span class="udiff-line-removed">-       bind(L_InnerLoop);</span>
<span class="udiff-line-removed">-       z_llgc(odd_reg, Address(needle, Z_R1));</span>
<span class="udiff-line-removed">-       z_ch(odd_reg, Address(result, even_reg));</span>
<span class="udiff-line-removed">-       z_brne(L_Skip);</span>
<span class="udiff-line-removed">-       if (needlecnt != noreg) { z_cr(Z_R1, needlecnt); } else { z_chi(Z_R1, needlecntval - 1); }</span>
<span class="udiff-line-removed">-       z_brnl(L_Found);</span>
<span class="udiff-line-removed">-       z_aghi(Z_R1, n_csize);</span>
<span class="udiff-line-removed">-       z_aghi(even_reg, h_csize);</span>
<span class="udiff-line-removed">-       z_bru(L_InnerLoop);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       bind(L_Skip);</span>
<span class="udiff-line-removed">-       z_aghi(result, h_csize); // This is the new address we want to use for comparing.</span>
<span class="udiff-line-removed">-       z_bru(L_OuterLoop);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     const intptr_t needle_bytes = (n_csize == 2) ? ((needlecntval - 1) &lt;&lt; 1) : (needlecntval - 1);</span>
<span class="udiff-line-removed">-     Label L_clcle;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (needlecnt != noreg || (needlecntval != 1 &amp;&amp; needle_bytes &lt;= 256)) {</span>
<span class="udiff-line-removed">-       if (needlecnt != noreg) {</span>
<span class="udiff-line-removed">-         compare32_and_branch(needlecnt, 256, Assembler::bcondHigh, L_clcle);</span>
<span class="udiff-line-removed">-         z_ahi(needlecnt, -1); // remaining bytes -1 (for CLC)</span>
<span class="udiff-line-removed">-         z_brl(L_needle1);</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       // Main Loop: clc version (now we have at least 2 characters).</span>
<span class="udiff-line-removed">-       Label L_OuterLoop, CLC_template;</span>
<span class="udiff-line-removed">-       bind(L_OuterLoop); // Search for 1st 2 characters.</span>
<span class="udiff-line-removed">-       z_lgr(Z_R1, haycnt);</span>
<span class="udiff-line-removed">-       if (h_csize == 1) {</span>
<span class="udiff-line-removed">-         MacroAssembler::search_string(Z_R1, result);</span>
<span class="udiff-line-removed">-       } else {</span>
<span class="udiff-line-removed">-         MacroAssembler::search_string_uni(Z_R1, result);</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       z_brc(Assembler::bcondNotFound, L_NotFound);</span>
<span class="udiff-line-removed">-       z_lgr(result, Z_R1);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       if (needlecnt != noreg) {</span>
<span class="udiff-line-removed">-         assert(VM_Version::has_ExecuteExtensions(), &quot;unsupported hardware&quot;);</span>
<span class="udiff-line-removed">-         z_exrl(needlecnt, CLC_template);</span>
<span class="udiff-line-removed">-       } else {</span>
<span class="udiff-line-removed">-         z_clc(h_csize, needle_bytes -1, Z_R1, n_csize, needle);</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       z_bre(L_Found);</span>
<span class="udiff-line-removed">-       z_aghi(result, h_csize); // This is the new address we want to use for comparing.</span>
<span class="udiff-line-removed">-       z_bru(L_OuterLoop);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       if (needlecnt != noreg) {</span>
<span class="udiff-line-removed">-         bind(CLC_template);</span>
<span class="udiff-line-removed">-         z_clc(h_csize, 0, Z_R1, n_csize, needle);</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (needlecnt != noreg || needle_bytes &gt; 256) {</span>
<span class="udiff-line-removed">-       bind(L_clcle);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       // Main Loop: clcle version (now we have at least 256 bytes).</span>
<span class="udiff-line-removed">-       Label L_OuterLoop, CLC_template;</span>
<span class="udiff-line-removed">-       bind(L_OuterLoop); // Search for 1st 2 characters.</span>
<span class="udiff-line-removed">-       z_lgr(Z_R1, haycnt);</span>
<span class="udiff-line-removed">-       if (h_csize == 1) {</span>
<span class="udiff-line-removed">-         MacroAssembler::search_string(Z_R1, result);</span>
<span class="udiff-line-removed">-       } else {</span>
<span class="udiff-line-removed">-         MacroAssembler::search_string_uni(Z_R1, result);</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       z_brc(Assembler::bcondNotFound, L_NotFound);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       add2reg(Z_R0, n_csize, needle);</span>
<span class="udiff-line-removed">-       add2reg(even_reg, h_csize, Z_R1);</span>
<span class="udiff-line-removed">-       z_lgr(result, Z_R1);</span>
<span class="udiff-line-removed">-       if (needlecnt != noreg) {</span>
<span class="udiff-line-removed">-         z_llgfr(Z_R1, needlecnt); // needle len in bytes (left operand)</span>
<span class="udiff-line-removed">-         z_llgfr(odd_reg, needlecnt);</span>
<span class="udiff-line-removed">-       } else {</span>
<span class="udiff-line-removed">-         load_const_optimized(Z_R1, needle_bytes);</span>
<span class="udiff-line-removed">-         if (Immediate::is_simm16(needle_bytes)) { z_lghi(odd_reg, needle_bytes); } else { z_lgr(odd_reg, Z_R1); }</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       if (h_csize == 1) {</span>
<span class="udiff-line-removed">-         compare_long_ext(Z_R0, even_reg, 0);</span>
<span class="udiff-line-removed">-       } else {</span>
<span class="udiff-line-removed">-         compare_long_uni(Z_R0, even_reg, 0);</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       z_bre(L_Found);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       if (n_csize == 2) { z_llgh(Z_R0, Address(needle)); } else { z_llgc(Z_R0, Address(needle)); } // Reload.</span>
<span class="udiff-line-removed">-       z_aghi(result, h_csize); // This is the new address we want to use for comparing.</span>
<span class="udiff-line-removed">-       z_bru(L_OuterLoop);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (needlecnt != noreg || needlecntval == 1) {</span>
<span class="udiff-line-removed">-     bind(L_needle1);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // Single needle character version.</span>
<span class="udiff-line-removed">-     if (h_csize == 1) {</span>
<span class="udiff-line-removed">-       MacroAssembler::search_string(haycnt, result);</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       MacroAssembler::search_string_uni(haycnt, result);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     z_lgr(result, haycnt);</span>
<span class="udiff-line-removed">-     z_brc(Assembler::bcondFound, L_Found);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   bind(L_NotFound);</span>
<span class="udiff-line-removed">-   add2reg(result, -1, haystack); // Return -1.</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   bind(L_Found); // Return index (or -1 in fallthrough case).</span>
<span class="udiff-line-removed">-   z_sgr(result, haystack);</span>
<span class="udiff-line-removed">-   if (h_csize == 2) { z_srag(result, result, exact_log2(sizeof(jchar))); }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   BLOCK_COMMENT(&quot;} string_indexof&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   return offset() - block_start;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- // early clobber: result</span>
<span class="udiff-line-removed">- unsigned int MacroAssembler::string_indexof_char(Register result, Register haystack, Register haycnt,</span>
<span class="udiff-line-removed">-                                                  Register needle, jchar needleChar, Register odd_reg, Register even_reg, bool is_byte) {</span>
<span class="udiff-line-removed">-   int block_start = offset();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   BLOCK_COMMENT(&quot;string_indexof_char {&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (needle == haystack) {</span>
<span class="udiff-line-removed">-     z_lhi(result, 0);</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   Label Ldone;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   z_llgfr(odd_reg, haycnt);  // Preset loop ctr/searchrange end.</span>
<span class="udiff-line-removed">-   if (needle == noreg) {</span>
<span class="udiff-line-removed">-     load_const_optimized(Z_R0, (unsigned long)needleChar);</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     if (is_byte) {</span>
<span class="udiff-line-removed">-       z_llgcr(Z_R0, needle); // First (and only) needle char.</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       z_llghr(Z_R0, needle); // First (and only) needle char.</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (!is_byte) {</span>
<span class="udiff-line-removed">-     z_agr(odd_reg, odd_reg); // Calc #bytes to be processed with SRSTU.</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   z_lgr(even_reg, haystack); // haystack addr</span>
<span class="udiff-line-removed">-   z_agr(odd_reg, haystack);  // First char after range end.</span>
<span class="udiff-line-removed">-   z_lghi(result, -1);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (is_byte) {</span>
<span class="udiff-line-removed">-     MacroAssembler::search_string(odd_reg, even_reg);</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     MacroAssembler::search_string_uni(odd_reg, even_reg);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   z_brc(Assembler::bcondNotFound, Ldone);</span>
<span class="udiff-line-removed">-   if (is_byte) {</span>
<span class="udiff-line-removed">-     if (VM_Version::has_DistinctOpnds()) {</span>
<span class="udiff-line-removed">-       z_sgrk(result, odd_reg, haystack);</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       z_sgr(odd_reg, haystack);</span>
<span class="udiff-line-removed">-       z_lgr(result, odd_reg);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     z_slgr(odd_reg, haystack);</span>
<span class="udiff-line-removed">-     z_srlg(result, odd_reg, exact_log2(sizeof(jchar)));</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   bind(Ldone);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   BLOCK_COMMENT(&quot;} string_indexof_char&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   return offset() - block_start;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
  //-------------------------------------------------
  //   Constants (scalar and oop) in constant pool
  //-------------------------------------------------
  
  // Add a non-relocated constant to the CP.
</pre>
<center><a href="interp_masm_s390.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_s390.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
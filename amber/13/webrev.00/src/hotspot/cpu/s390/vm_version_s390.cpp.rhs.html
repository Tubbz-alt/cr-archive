<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/s390/vm_version_s390.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2016, 2019 SAP SE. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;jvm.h&quot;
  28 #include &quot;asm/assembler.inline.hpp&quot;
  29 #include &quot;compiler/disassembler.hpp&quot;
  30 #include &quot;code/compiledIC.hpp&quot;
  31 #include &quot;memory/resourceArea.hpp&quot;
  32 #include &quot;runtime/java.hpp&quot;
  33 #include &quot;runtime/stubCodeGenerator.hpp&quot;
  34 #include &quot;runtime/vm_version.hpp&quot;
  35 
  36 # include &lt;sys/sysinfo.h&gt;
  37 
  38 bool VM_Version::_is_determine_features_test_running  = false;
  39 const char*   VM_Version::_model_string;
  40 
  41 unsigned long VM_Version::_features[_features_buffer_len]           = {0, 0, 0, 0};
  42 unsigned long VM_Version::_cipher_features[_features_buffer_len]    = {0, 0, 0, 0};
  43 unsigned long VM_Version::_msgdigest_features[_features_buffer_len] = {0, 0, 0, 0};
  44 unsigned int  VM_Version::_nfeatures                                = 0;
  45 unsigned int  VM_Version::_ncipher_features                         = 0;
  46 unsigned int  VM_Version::_nmsgdigest_features                      = 0;
  47 unsigned int  VM_Version::_Dcache_lineSize                          = DEFAULT_CACHE_LINE_SIZE;
  48 unsigned int  VM_Version::_Icache_lineSize                          = DEFAULT_CACHE_LINE_SIZE;
  49 
  50 static const char* z_gen[]     = {&quot;  &quot;,   &quot;G1&quot;,   &quot;G2&quot;, &quot;G3&quot;,    &quot;G4&quot;,     &quot;G5&quot;,      &quot;G6&quot;,   &quot;G7&quot;   };
  51 static const char* z_machine[] = {&quot;  &quot;, &quot;2064&quot;, &quot;2084&quot;, &quot;2094&quot;,  &quot;2097&quot;,   &quot;2817&quot;,    &quot;  &quot;,   &quot;2964&quot; };
  52 static const char* z_name[]    = {&quot;  &quot;, &quot;z900&quot;, &quot;z990&quot;, &quot;z9 EC&quot;, &quot;z10 EC&quot;, &quot;z196 EC&quot;, &quot;ec12&quot;, &quot;z13&quot;  };
  53 
  54 void VM_Version::initialize() {
  55   determine_features();      // Get processor capabilities.
  56   set_features_string();     // Set a descriptive feature indication.
  57 
  58   if (Verbose) {
  59     print_features();
  60   }
  61 
  62   intx cache_line_size = Dcache_lineSize(0);
  63 
  64 #ifdef COMPILER2
  65   MaxVectorSize = 8;
  66 #endif
  67 
  68   if (has_PrefetchRaw()) {
  69     if (FLAG_IS_DEFAULT(AllocatePrefetchStyle)) {  // not preset
  70       // 0 = no prefetch.
  71       // 1 = Prefetch instructions for each allocation.
  72       // 2 = Use TLAB watermark to gate allocation prefetch.
  73       AllocatePrefetchStyle = 1;
  74     }
  75 
  76     if (AllocatePrefetchStyle &gt; 0) {  // Prefetching turned on at all?
  77       // Distance to prefetch ahead of allocation pointer.
  78       if (FLAG_IS_DEFAULT(AllocatePrefetchDistance) || (AllocatePrefetchDistance &lt; 0)) {  // not preset
  79         AllocatePrefetchDistance = 0;
  80       }
  81 
  82       // Number of lines to prefetch ahead of allocation pointer.
  83       if (FLAG_IS_DEFAULT(AllocatePrefetchLines) || (AllocatePrefetchLines &lt;= 0)) {      // not preset
  84         AllocatePrefetchLines = 3;
  85       }
  86 
  87       // Step size in bytes of sequential prefetch instructions.
  88       if (FLAG_IS_DEFAULT(AllocatePrefetchStepSize) || (AllocatePrefetchStepSize &lt;= 0)) { // not preset
  89         FLAG_SET_DEFAULT(AllocatePrefetchStepSize, cache_line_size);
  90       } else if (AllocatePrefetchStepSize &lt; cache_line_size) {
  91         FLAG_SET_DEFAULT(AllocatePrefetchStepSize, cache_line_size);
  92       } else {
  93         FLAG_SET_DEFAULT(AllocatePrefetchStepSize, cache_line_size);
  94       }
  95     } else {
  96       FLAG_SET_DEFAULT(AllocatePrefetchStyle, 0);
  97       AllocatePrefetchDistance = 0;
  98       AllocatePrefetchLines    = 0;
  99       // Can&#39;t be zero. Will SIGFPE during constraints checking.
 100       FLAG_SET_DEFAULT(AllocatePrefetchStepSize, cache_line_size);
 101     }
 102 
 103   } else {
 104     FLAG_SET_DEFAULT(AllocatePrefetchStyle, 0);
 105     AllocatePrefetchDistance = 0;
 106     AllocatePrefetchLines    = 0;
 107     // Can&#39;t be zero. Will SIGFPE during constraints checking.
 108     FLAG_SET_DEFAULT(AllocatePrefetchStepSize, cache_line_size);
 109   }
 110 
 111   // TODO:
 112   // On z/Architecture, cache line size is significantly large (256 bytes). Do we really need
 113   // to keep contended members that far apart? Performance tests are required.
 114   if (FLAG_IS_DEFAULT(ContendedPaddingWidth) &amp;&amp; (cache_line_size &gt; ContendedPaddingWidth)) {
 115     ContendedPaddingWidth = cache_line_size;
 116   }
 117 
 118   // On z/Architecture, the CRC32/CRC32C intrinsics are implemented &quot;by hand&quot;.
 119   // TODO: Provide implementation based on the vector instructions available from z13.
 120   // Note: The CHECKSUM instruction, which has been there since the very beginning
 121   //       (of z/Architecture), computes &quot;some kind of&quot; a checksum.
 122   //       It has nothing to do with the CRC32 algorithm.
 123   if (FLAG_IS_DEFAULT(UseCRC32Intrinsics)) {
 124     FLAG_SET_DEFAULT(UseCRC32Intrinsics, true);
 125   }
 126   if (FLAG_IS_DEFAULT(UseCRC32CIntrinsics)) {
 127     FLAG_SET_DEFAULT(UseCRC32CIntrinsics, true);
 128   }
 129 
 130   // TODO: Provide implementation.
 131   if (UseAdler32Intrinsics) {
 132     warning(&quot;Adler32Intrinsics not available on this CPU.&quot;);
 133     FLAG_SET_DEFAULT(UseAdler32Intrinsics, false);
 134   }
 135 
 136   // On z/Architecture, we take UseAES as the general switch to enable/disable the AES intrinsics.
 137   // The specific, and yet to be defined, switches UseAESxxxIntrinsics will then be set
 138   // depending on the actual machine capabilities.
 139   // Explicitly setting them via CmdLine option takes precedence, of course.
 140   // TODO: UseAESIntrinsics must be made keylength specific.
 141   // As of March 2015 and Java8, only AES128 is supported by the Java Cryptographic Extensions.
 142   // Therefore, UseAESIntrinsics is of minimal use at the moment.
 143   if (FLAG_IS_DEFAULT(UseAES) &amp;&amp; has_Crypto_AES()) {
 144     FLAG_SET_DEFAULT(UseAES, true);
 145   }
 146   if (UseAES &amp;&amp; !has_Crypto_AES()) {
 147     warning(&quot;AES instructions are not available on this CPU&quot;);
 148     FLAG_SET_DEFAULT(UseAES, false);
 149   }
 150   if (UseAES) {
 151     if (FLAG_IS_DEFAULT(UseAESIntrinsics)) {
 152       FLAG_SET_DEFAULT(UseAESIntrinsics, true);
 153     }
 154   }
 155   if (UseAESIntrinsics &amp;&amp; !has_Crypto_AES()) {
 156     warning(&quot;AES intrinsics are not available on this CPU&quot;);
 157     FLAG_SET_DEFAULT(UseAESIntrinsics, false);
 158   }
 159   if (UseAESIntrinsics &amp;&amp; !UseAES) {
 160     warning(&quot;AES intrinsics require UseAES flag to be enabled. Intrinsics will be disabled.&quot;);
 161     FLAG_SET_DEFAULT(UseAESIntrinsics, false);
 162   }
 163 
 164   // TODO: implement AES/CTR intrinsics
 165   if (UseAESCTRIntrinsics) {
 166     warning(&quot;AES/CTR intrinsics are not available on this CPU&quot;);
 167     FLAG_SET_DEFAULT(UseAESCTRIntrinsics, false);
 168   }
 169 
 170   if (FLAG_IS_DEFAULT(UseGHASHIntrinsics) &amp;&amp; has_Crypto_GHASH()) {
 171     FLAG_SET_DEFAULT(UseGHASHIntrinsics, true);
 172   }
 173   if (UseGHASHIntrinsics &amp;&amp; !has_Crypto_GHASH()) {
 174     warning(&quot;GHASH intrinsics are not available on this CPU&quot;);
 175     FLAG_SET_DEFAULT(UseGHASHIntrinsics, false);
 176   }
 177 
 178   if (FLAG_IS_DEFAULT(UseFMA)) {
 179     FLAG_SET_DEFAULT(UseFMA, true);
 180   }
 181 
 182   // On z/Architecture, we take UseSHA as the general switch to enable/disable the SHA intrinsics.
 183   // The specific switches UseSHAxxxIntrinsics will then be set depending on the actual
 184   // machine capabilities.
 185   // Explicitly setting them via CmdLine option takes precedence, of course.
 186   if (FLAG_IS_DEFAULT(UseSHA) &amp;&amp; has_Crypto_SHA()) {
 187     FLAG_SET_DEFAULT(UseSHA, true);
 188   }
 189   if (UseSHA &amp;&amp; !has_Crypto_SHA()) {
 190     warning(&quot;SHA instructions are not available on this CPU&quot;);
 191     FLAG_SET_DEFAULT(UseSHA, false);
 192   }
 193   if (UseSHA &amp;&amp; has_Crypto_SHA1()) {
 194     if (FLAG_IS_DEFAULT(UseSHA1Intrinsics)) {
 195       FLAG_SET_DEFAULT(UseSHA1Intrinsics, true);
 196     }
 197   } else if (UseSHA1Intrinsics) {
 198     warning(&quot;Intrinsics for SHA-1 crypto hash functions not available on this CPU.&quot;);
 199     FLAG_SET_DEFAULT(UseSHA1Intrinsics, false);
 200   }
 201   if (UseSHA &amp;&amp; has_Crypto_SHA256()) {
 202     if (FLAG_IS_DEFAULT(UseSHA256Intrinsics)) {
 203       FLAG_SET_DEFAULT(UseSHA256Intrinsics, true);
 204     }
 205   } else if (UseSHA256Intrinsics) {
 206     warning(&quot;Intrinsics for SHA-224 and SHA-256 crypto hash functions not available on this CPU.&quot;);
 207     FLAG_SET_DEFAULT(UseSHA256Intrinsics, false);
 208   }
 209   if (UseSHA &amp;&amp; has_Crypto_SHA512()) {
 210     if (FLAG_IS_DEFAULT(UseSHA512Intrinsics)) {
 211       FLAG_SET_DEFAULT(UseSHA512Intrinsics, true);
 212     }
 213   } else if (UseSHA512Intrinsics) {
 214     warning(&quot;Intrinsics for SHA-384 and SHA-512 crypto hash functions not available on this CPU.&quot;);
 215     FLAG_SET_DEFAULT(UseSHA512Intrinsics, false);
 216   }
 217 
 218   if (!(UseSHA1Intrinsics || UseSHA256Intrinsics || UseSHA512Intrinsics)) {
 219     FLAG_SET_DEFAULT(UseSHA, false);
 220   }
 221 
 222 #ifdef COMPILER2
 223   if (FLAG_IS_DEFAULT(UseMultiplyToLenIntrinsic)) {
 224     FLAG_SET_DEFAULT(UseMultiplyToLenIntrinsic, true);
 225   }
 226   if (FLAG_IS_DEFAULT(UseMontgomeryMultiplyIntrinsic)) {
 227     FLAG_SET_DEFAULT(UseMontgomeryMultiplyIntrinsic, true);
 228   }
 229   if (FLAG_IS_DEFAULT(UseMontgomerySquareIntrinsic)) {
 230     FLAG_SET_DEFAULT(UseMontgomerySquareIntrinsic, true);
 231   }
 232 #endif
 233   if (FLAG_IS_DEFAULT(UsePopCountInstruction)) {
 234     FLAG_SET_DEFAULT(UsePopCountInstruction, true);
 235   }
 236 
 237   // z/Architecture supports 8-byte compare-exchange operations
 238   // (see Atomic::cmpxchg)
 239   // and &#39;atomic long memory ops&#39; (see Unsafe_GetLongVolatile).
 240   _supports_cx8 = true;
 241 
 242   _supports_atomic_getadd4 = VM_Version::has_LoadAndALUAtomicV1();
 243   _supports_atomic_getadd8 = VM_Version::has_LoadAndALUAtomicV1();
 244 
 245   // z/Architecture supports unaligned memory accesses.
 246   // Performance penalty is negligible. An additional tick or so
 247   // is lost if the accessed data spans a cache line boundary.
 248   // Unaligned accesses are not atomic, of course.
 249   if (FLAG_IS_DEFAULT(UseUnalignedAccesses)) {
 250     FLAG_SET_DEFAULT(UseUnalignedAccesses, true);
 251   }
 252 }
 253 
 254 
 255 void VM_Version::set_features_string() {
<a name="1" id="anc1"></a><span class="line-modified"> 256   // A note on the _features_string format:</span>
<span class="line-added"> 257   //   There are jtreg tests checking the _features_string for various properties.</span>
<span class="line-added"> 258   //   For some strange reason, these tests require the string to contain</span>
<span class="line-added"> 259   //   only _lowercase_ characters. Keep that in mind when being surprised</span>
<span class="line-added"> 260   //   about the unusual notation of features - and when adding new ones.</span>
<span class="line-added"> 261   //   Features may have one comma at the end.</span>
<span class="line-added"> 262   //   Furthermore, use one, and only one, separator space between features.</span>
<span class="line-added"> 263   //   Multiple spaces are considered separate tokens, messing up everything.</span>
 264   unsigned int ambiguity = 0;
 265   _model_string = z_name[0];
 266   if (is_z13()) {
<a name="2" id="anc2"></a><span class="line-modified"> 267     _features_string = &quot;system-z, g7-z13, ldisp_fast, extimm, pcrel_load/store, cmpb, cond_load/store, interlocked_update, txm, vectorinstr&quot;;</span>
 268     _model_string = z_name[7];
 269     ambiguity++;
 270   }
 271   if (is_ec12()) {
<a name="3" id="anc3"></a><span class="line-modified"> 272     _features_string = &quot;system-z, g6-ec12, ldisp_fast, extimm, pcrel_load/store, cmpb, cond_load/store, interlocked_update, txm&quot;;</span>
 273     _model_string = z_name[6];
 274     ambiguity++;
 275   }
 276   if (is_z196()) {
<a name="4" id="anc4"></a><span class="line-modified"> 277     _features_string = &quot;system-z, g5-z196, ldisp_fast, extimm, pcrel_load/store, cmpb, cond_load/store, interlocked_update&quot;;</span>
 278     _model_string = z_name[5];
 279     ambiguity++;
 280   }
 281   if (is_z10()) {
<a name="5" id="anc5"></a><span class="line-modified"> 282     _features_string = &quot;system-z, g4-z10, ldisp_fast, extimm, pcrel_load/store, cmpb&quot;;</span>
 283     _model_string = z_name[4];
 284     ambiguity++;
 285   }
 286   if (is_z9()) {
<a name="6" id="anc6"></a><span class="line-modified"> 287     _features_string = &quot;system-z, g3-z9, ldisp_fast, extimm, out-of-support as of 2016-04-01&quot;;</span>
 288     _model_string = z_name[3];
 289     ambiguity++;
 290   }
 291   if (is_z990()) {
<a name="7" id="anc7"></a><span class="line-modified"> 292     _features_string = &quot;system-z, g2-z990, ldisp_fast, out-of-support as of 2014-07-01&quot;;</span>
 293     _model_string = z_name[2];
 294     ambiguity++;
 295   }
 296   if (is_z900()) {
<a name="8" id="anc8"></a><span class="line-modified"> 297     _features_string = &quot;system-z, g1-z900, ldisp, out-of-support as of 2014-07-01&quot;;</span>
 298     _model_string = z_name[1];
 299     ambiguity++;
 300   }
 301 
 302   if (ambiguity == 0) {
 303     _features_string = &quot;z/Architecture (unknown generation)&quot;;
 304   } else if (ambiguity &gt; 1) {
 305     tty-&gt;print_cr(&quot;*** WARNING *** Ambiguous z/Architecture detection, ambiguity = %d&quot;, ambiguity);
 306     tty-&gt;print_cr(&quot;                oldest detected generation is %s&quot;, _features_string);
 307     _features_string = &quot;z/Architecture (ambiguous detection)&quot;;
 308   }
 309 
 310   if (has_Crypto_AES()) {
 311     char buf[256];
<a name="9" id="anc9"></a><span class="line-modified"> 312     assert(strlen(_features_string) + 3*8 &lt; sizeof(buf), &quot;increase buffer size&quot;);</span>
<span class="line-modified"> 313     jio_snprintf(buf, sizeof(buf), &quot;%s%s%s%s&quot;,</span>
 314                  _features_string,
<a name="10" id="anc10"></a><span class="line-modified"> 315                  has_Crypto_AES128() ? &quot;, aes128&quot; : &quot;&quot;,</span>
<span class="line-modified"> 316                  has_Crypto_AES192() ? &quot;, aes192&quot; : &quot;&quot;,</span>
<span class="line-modified"> 317                  has_Crypto_AES256() ? &quot;, aes256&quot; : &quot;&quot;);</span>
 318     _features_string = os::strdup(buf);
 319   }
 320 
 321   if (has_Crypto_SHA()) {
 322     char buf[256];
<a name="11" id="anc11"></a><span class="line-modified"> 323     assert(strlen(_features_string) + 6 + 2*8 + 7 &lt; sizeof(buf), &quot;increase buffer size&quot;);</span>
<span class="line-modified"> 324     jio_snprintf(buf, sizeof(buf), &quot;%s%s%s%s%s&quot;,</span>

 325                  _features_string,
<a name="12" id="anc12"></a><span class="line-modified"> 326                  has_Crypto_SHA1()   ? &quot;, sha1&quot;   : &quot;&quot;,</span>
<span class="line-modified"> 327                  has_Crypto_SHA256() ? &quot;, sha256&quot; : &quot;&quot;,</span>
<span class="line-modified"> 328                  has_Crypto_SHA512() ? &quot;, sha512&quot; : &quot;&quot;,</span>
<span class="line-modified"> 329                  has_Crypto_GHASH()  ? &quot;, ghash&quot;  : &quot;&quot;);</span>
 330     if (has_Crypto_AES()) { os::free((void *)_features_string); }
 331     _features_string = os::strdup(buf);
 332   }
 333 }
 334 
 335 // featureBuffer - bit array indicating availability of various features
 336 // featureNum    - bit index of feature to be tested
 337 //                 Featurenum &lt; 0 requests test for any nonzero bit in featureBuffer.
 338 // bufLen        - length of featureBuffer in bits
 339 bool VM_Version::test_feature_bit(unsigned long* featureBuffer, int featureNum, unsigned int bufLen) {
 340   assert(bufLen &gt; 0,             &quot;buffer len must be positive&quot;);
 341   assert((bufLen &amp; 0x0007) == 0, &quot;unaligned buffer len&quot;);
 342   assert(((intptr_t)featureBuffer&amp;0x0007) == 0, &quot;unaligned feature buffer&quot;);
 343   if (featureNum &lt; 0) {
 344     // Any bit set at all?
 345     bool anyBit = false;
 346     for (size_t i = 0; i &lt; bufLen/(8*sizeof(long)); i++) {
 347       anyBit = anyBit || (featureBuffer[i] != 0);
 348     }
 349     return anyBit;
 350   } else {
 351     assert((unsigned int)featureNum &lt; bufLen,    &quot;feature index out of range&quot;);
 352     unsigned char* byteBuffer = (unsigned char*)featureBuffer;
 353     int   byteIndex  = featureNum/(8*sizeof(char));
 354     int   bitIndex   = featureNum%(8*sizeof(char));
 355     // Indexed bit set?
 356     return (byteBuffer[byteIndex] &amp; (1U&lt;&lt;(7-bitIndex))) != 0;
 357   }
 358 }
 359 
 360 void VM_Version::print_features_internal(const char* text, bool print_anyway) {
 361   tty-&gt;print_cr(&quot;%s %s&quot;,       text, features_string());
 362   tty-&gt;print(&quot;%s&quot;, text);
 363   for (unsigned int i = 0; i &lt; _nfeatures; i++) {
 364     tty-&gt;print(&quot;  0x%16.16lx&quot;, _features[i]);
 365   }
 366   tty-&gt;cr();
 367 
 368   if (Verbose || print_anyway) {
 369     // z900
 370     if (has_long_displacement()        ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;LongDispFacility&quot;);
 371     // z990
 372     if (has_long_displacement_fast()   ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;LongDispFacilityHighPerf&quot;);
 373     if (has_ETF2() &amp;&amp; has_ETF3()       ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;ETF2 and ETF3&quot;);
 374     if (has_Crypto()                   ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;CryptoFacility&quot;);
 375     // z9
 376     if (has_extended_immediate()       ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;ExtImmedFacility&quot;);
 377     if (has_StoreFacilityListExtended()) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;StoreFacilityListExtended&quot;);
 378     if (has_StoreClockFast()           ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;StoreClockFast&quot;);
 379     if (has_ETF2Enhancements()         ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;ETF2 Enhancements&quot;);
 380     if (has_ETF3Enhancements()         ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;ETF3 Enhancements&quot;);
 381     if (has_HFPUnnormalized()          ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;HFPUnnormalizedFacility&quot;);
 382     if (has_HFPMultiplyAndAdd()        ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;HFPMultiplyAndAddFacility&quot;);
 383     // z10
 384     if (has_ParsingEnhancements()      ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;Parsing Enhancements&quot;);
 385     if (has_ExtractCPUtime()           ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;ExtractCPUTime&quot;);
 386     if (has_CompareSwapStore()         ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;CompareSwapStore&quot;);
 387     if (has_GnrlInstrExtensions()      ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;General Instruction Extensions&quot;);
 388     if (has_CompareBranch()            ) tty-&gt;print_cr(&quot;  available: %s&quot;, &quot;Compare and Branch&quot;);
 389     if (has_CompareTrap()              ) tty-&gt;print_cr(&quot;  available: %s&quot;, &quot;Compare and Trap&quot;);
 390     if (has_RelativeLoadStore()        ) tty-&gt;print_cr(&quot;  available: %s&quot;, &quot;Relative Load/Store&quot;);
 391     if (has_MultiplySingleImm32()      ) tty-&gt;print_cr(&quot;  available: %s&quot;, &quot;MultiplySingleImm32&quot;);
 392     if (has_Prefetch()                 ) tty-&gt;print_cr(&quot;  available: %s&quot;, &quot;Prefetch&quot;);
 393     if (has_MoveImmToMem()             ) tty-&gt;print_cr(&quot;  available: %s&quot;, &quot;Direct Moves Immediate to Memory&quot;);
 394     if (has_MemWithImmALUOps()         ) tty-&gt;print_cr(&quot;  available: %s&quot;, &quot;Direct ALU Ops Memory .op. Immediate&quot;);
 395     if (has_ExtractCPUAttributes()     ) tty-&gt;print_cr(&quot;  available: %s&quot;, &quot;Extract CPU Atributes&quot;);
 396     if (has_ExecuteExtensions()        ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;ExecuteExtensions&quot;);
 397     if (has_FPSupportEnhancements()    ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;FPSupportEnhancements&quot;);
 398     if (has_DecimalFloatingPoint()     ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;DecimalFloatingPoint&quot;);
 399     // z196
 400     if (has_DistinctOpnds()            ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;Distinct Operands&quot;);
 401     if (has_InterlockedAccessV1()      ) tty-&gt;print_cr(&quot;  available: %s&quot;, &quot;InterlockedAccess V1 (fast)&quot;);
 402     if (has_PopCount()                 ) tty-&gt;print_cr(&quot;  available: %s&quot;, &quot;PopCount&quot;);
 403     if (has_LoadStoreConditional()     ) tty-&gt;print_cr(&quot;  available: %s&quot;, &quot;LoadStoreConditional&quot;);
 404     if (has_HighWordInstr()            ) tty-&gt;print_cr(&quot;  available: %s&quot;, &quot;HighWord Instructions&quot;);
 405     if (has_FastSync()                 ) tty-&gt;print_cr(&quot;  available: %s&quot;, &quot;FastSync (bcr 14,0)&quot;);
 406     if (has_AtomicMemWithImmALUOps()   ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;Atomic Direct ALU Ops Memory .op. Immediate&quot;);
 407     if (has_FPExtensions()             ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;Floatingpoint Extensions&quot;);
 408     if (has_CryptoExt3()               ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;Crypto Extensions 3&quot;);
 409     if (has_CryptoExt4()               ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;Crypto Extensions 4&quot;);
 410     // EC12
 411     if (has_MiscInstrExt()             ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;Miscelaneous Instruction Extensions&quot;);
 412     if (has_ExecutionHint()            ) tty-&gt;print_cr(&quot;  available: %s&quot;, &quot;Execution Hints (branch prediction)&quot;);
 413     if (has_ProcessorAssist()          ) tty-&gt;print_cr(&quot;  available: %s&quot;, &quot;Processor Assists&quot;);
 414     if (has_LoadAndTrap()              ) tty-&gt;print_cr(&quot;  available: %s&quot;, &quot;Load and Trap&quot;);
 415     if (has_TxMem()                    ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;Transactional Memory&quot;);
 416     if (has_InterlockedAccessV2()      ) tty-&gt;print_cr(&quot;  available: %s&quot;, &quot;InterlockedAccess V2 (fast)&quot;);
 417     if (has_DFPZonedConversion()       ) tty-&gt;print_cr(&quot;  available: %s&quot;, &quot;DFP Zoned Conversions&quot;);
 418     // z13
 419     if (has_LoadStoreConditional2()    ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;Load/Store Conditional 2&quot;);
 420     if (has_CryptoExt5()               ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;Crypto Extensions 5&quot;);
 421     if (has_DFPPackedConversion()      ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;DFP Packed Conversions&quot;);
 422     if (has_VectorFacility()           ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;Vector Facility&quot;);
 423     // test switches
 424     if (has_TestFeature1Impl()         ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;TestFeature1Impl&quot;);
 425     if (has_TestFeature2Impl()         ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;TestFeature2Impl&quot;);
 426     if (has_TestFeature4Impl()         ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;TestFeature4Impl&quot;);
 427     if (has_TestFeature8Impl()         ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;TestFeature8Impl&quot;);
 428 
 429     if (has_Crypto()) {
 430       tty-&gt;cr();
 431       tty-&gt;print_cr(&quot;detailed availability of %s capabilities:&quot;, &quot;CryptoFacility&quot;);
 432       if (test_feature_bit(&amp;_cipher_features[0], -1, 2*Cipher::_featureBits)) {
 433         tty-&gt;cr();
 434         tty-&gt;print_cr(&quot;  available: %s&quot;, &quot;Message Cipher Functions&quot;);
 435       }
 436       if (test_feature_bit(&amp;_cipher_features[0], -1, (int)Cipher::_featureBits)) {
 437         tty-&gt;print_cr(&quot;    available Crypto Features of KM  (Cipher Message):&quot;);
 438         for (unsigned int i = 0; i &lt; Cipher::_featureBits; i++) {
 439           if (test_feature_bit(&amp;_cipher_features[0], i, (int)Cipher::_featureBits)) {
 440             switch (i) {
 441               case Cipher::_Query:              tty-&gt;print_cr(&quot;      available: KM   Query&quot;);                  break;
 442               case Cipher::_DEA:                tty-&gt;print_cr(&quot;      available: KM   DEA&quot;);                    break;
 443               case Cipher::_TDEA128:            tty-&gt;print_cr(&quot;      available: KM   TDEA-128&quot;);               break;
 444               case Cipher::_TDEA192:            tty-&gt;print_cr(&quot;      available: KM   TDEA-192&quot;);               break;
 445               case Cipher::_EncryptedDEA:       tty-&gt;print_cr(&quot;      available: KM   Encrypted DEA&quot;);          break;
 446               case Cipher::_EncryptedDEA128:    tty-&gt;print_cr(&quot;      available: KM   Encrypted DEA-128&quot;);      break;
 447               case Cipher::_EncryptedDEA192:    tty-&gt;print_cr(&quot;      available: KM   Encrypted DEA-192&quot;);      break;
 448               case Cipher::_AES128:             tty-&gt;print_cr(&quot;      available: KM   AES-128&quot;);                break;
 449               case Cipher::_AES192:             tty-&gt;print_cr(&quot;      available: KM   AES-192&quot;);                break;
 450               case Cipher::_AES256:             tty-&gt;print_cr(&quot;      available: KM   AES-256&quot;);                break;
 451               case Cipher::_EnccryptedAES128:   tty-&gt;print_cr(&quot;      available: KM   Encrypted-AES-128&quot;);      break;
 452               case Cipher::_EnccryptedAES192:   tty-&gt;print_cr(&quot;      available: KM   Encrypted-AES-192&quot;);      break;
 453               case Cipher::_EnccryptedAES256:   tty-&gt;print_cr(&quot;      available: KM   Encrypted-AES-256&quot;);      break;
 454               case Cipher::_XTSAES128:          tty-&gt;print_cr(&quot;      available: KM   XTS-AES-128&quot;);            break;
 455               case Cipher::_XTSAES256:          tty-&gt;print_cr(&quot;      available: KM   XTS-AES-256&quot;);            break;
 456               case Cipher::_EncryptedXTSAES128: tty-&gt;print_cr(&quot;      available: KM   XTS-Encrypted-AES-128&quot;);  break;
 457               case Cipher::_EncryptedXTSAES256: tty-&gt;print_cr(&quot;      available: KM   XTS-Encrypted-AES-256&quot;);  break;
 458               default: tty-&gt;print_cr(&quot;      available: unknown KM  code %d&quot;, i);      break;
 459             }
 460           }
 461         }
 462       }
 463       if (test_feature_bit(&amp;_cipher_features[2], -1, (int)Cipher::_featureBits)) {
 464         tty-&gt;print_cr(&quot;    available Crypto Features of KMC (Cipher Message with Chaining):&quot;);
 465         for (unsigned int i = 0; i &lt; Cipher::_featureBits; i++) {
 466             if (test_feature_bit(&amp;_cipher_features[2], i, (int)Cipher::_featureBits)) {
 467             switch (i) {
 468               case Cipher::_Query:              tty-&gt;print_cr(&quot;      available: KMC  Query&quot;);                  break;
 469               case Cipher::_DEA:                tty-&gt;print_cr(&quot;      available: KMC  DEA&quot;);                    break;
 470               case Cipher::_TDEA128:            tty-&gt;print_cr(&quot;      available: KMC  TDEA-128&quot;);               break;
 471               case Cipher::_TDEA192:            tty-&gt;print_cr(&quot;      available: KMC  TDEA-192&quot;);               break;
 472               case Cipher::_EncryptedDEA:       tty-&gt;print_cr(&quot;      available: KMC  Encrypted DEA&quot;);          break;
 473               case Cipher::_EncryptedDEA128:    tty-&gt;print_cr(&quot;      available: KMC  Encrypted DEA-128&quot;);      break;
 474               case Cipher::_EncryptedDEA192:    tty-&gt;print_cr(&quot;      available: KMC  Encrypted DEA-192&quot;);      break;
 475               case Cipher::_AES128:             tty-&gt;print_cr(&quot;      available: KMC  AES-128&quot;);                break;
 476               case Cipher::_AES192:             tty-&gt;print_cr(&quot;      available: KMC  AES-192&quot;);                break;
 477               case Cipher::_AES256:             tty-&gt;print_cr(&quot;      available: KMC  AES-256&quot;);                break;
 478               case Cipher::_EnccryptedAES128:   tty-&gt;print_cr(&quot;      available: KMC  Encrypted-AES-128&quot;);      break;
 479               case Cipher::_EnccryptedAES192:   tty-&gt;print_cr(&quot;      available: KMC  Encrypted-AES-192&quot;);      break;
 480               case Cipher::_EnccryptedAES256:   tty-&gt;print_cr(&quot;      available: KMC  Encrypted-AES-256&quot;);      break;
 481               case Cipher::_PRNG:               tty-&gt;print_cr(&quot;      available: KMC  PRNG&quot;);                   break;
 482               default: tty-&gt;print_cr(&quot;      available: unknown KMC code %d&quot;, i);      break;
 483             }
 484           }
 485         }
 486       }
 487 
 488       if (test_feature_bit(&amp;_msgdigest_features[0], -1, 2*MsgDigest::_featureBits)) {
 489         tty-&gt;cr();
 490         tty-&gt;print_cr(&quot;  available: %s&quot;, &quot;Message Digest Functions for SHA&quot;);
 491       }
 492       if (test_feature_bit(&amp;_msgdigest_features[0], -1, (int)MsgDigest::_featureBits)) {
 493         tty-&gt;print_cr(&quot;    available Features of KIMD (Msg Digest):&quot;);
 494         for (unsigned int i = 0; i &lt; MsgDigest::_featureBits; i++) {
 495             if (test_feature_bit(&amp;_msgdigest_features[0], i, (int)MsgDigest::_featureBits)) {
 496             switch (i) {
 497               case MsgDigest::_Query:  tty-&gt;print_cr(&quot;      available: KIMD Query&quot;);   break;
 498               case MsgDigest::_SHA1:   tty-&gt;print_cr(&quot;      available: KIMD SHA-1&quot;);   break;
 499               case MsgDigest::_SHA256: tty-&gt;print_cr(&quot;      available: KIMD SHA-256&quot;); break;
 500               case MsgDigest::_SHA512: tty-&gt;print_cr(&quot;      available: KIMD SHA-512&quot;); break;
 501               case MsgDigest::_GHASH:  tty-&gt;print_cr(&quot;      available: KIMD GHASH&quot;);   break;
 502               default: tty-&gt;print_cr(&quot;      available: unknown code %d&quot;, i);  break;
 503             }
 504           }
 505         }
 506       }
 507       if (test_feature_bit(&amp;_msgdigest_features[2], -1, (int)MsgDigest::_featureBits)) {
 508         tty-&gt;print_cr(&quot;    available Features of KLMD (Msg Digest):&quot;);
 509         for (unsigned int i = 0; i &lt; MsgDigest::_featureBits; i++) {
 510           if (test_feature_bit(&amp;_msgdigest_features[2], i, (int)MsgDigest::_featureBits)) {
 511             switch (i) {
 512               case MsgDigest::_Query:  tty-&gt;print_cr(&quot;      available: KLMD Query&quot;);   break;
 513               case MsgDigest::_SHA1:   tty-&gt;print_cr(&quot;      available: KLMD SHA-1&quot;);   break;
 514               case MsgDigest::_SHA256: tty-&gt;print_cr(&quot;      available: KLMD SHA-256&quot;); break;
 515               case MsgDigest::_SHA512: tty-&gt;print_cr(&quot;      available: KLMD SHA-512&quot;); break;
 516               default: tty-&gt;print_cr(&quot;      available: unknown code %d&quot;, i);  break;
 517             }
 518           }
 519         }
 520       }
 521     }
 522     if (ContendedPaddingWidth &gt; 0) {
 523       tty-&gt;cr();
 524       tty-&gt;print_cr(&quot;ContendedPaddingWidth &quot; INTX_FORMAT, ContendedPaddingWidth);
 525     }
 526   }
 527 }
 528 
 529 void VM_Version::print_platform_virtualization_info(outputStream* st) {
 530   // /proc/sysinfo contains interesting information about
 531   // - LPAR
 532   // - whole &quot;Box&quot; (CPUs )
 533   // - z/VM / KVM (VM&lt;nn&gt;); this is not available in an LPAR-only setup
 534   const char* kw[] = { &quot;LPAR&quot;, &quot;CPUs&quot;, &quot;VM&quot;, NULL };
 535   const char* info_file = &quot;/proc/sysinfo&quot;;
 536 
 537   if (!print_matching_lines_from_file(info_file, st, kw)) {
 538     st-&gt;print_cr(&quot;  &lt;%s Not Available&gt;&quot;, info_file);
 539   }
 540 }
 541 
 542 void VM_Version::print_features() {
 543   print_features_internal(&quot;Version:&quot;);
 544 }
 545 
 546 void VM_Version::reset_features(bool reset) {
 547   if (reset) {
 548     for (unsigned int i = 0; i &lt; _features_buffer_len; i++) {
 549       VM_Version::_features[i] = 0;
 550     }
 551   }
 552 }
 553 
 554 void VM_Version::set_features_z900(bool reset) {
 555   reset_features(reset);
 556 
 557   set_has_long_displacement();
 558   set_has_ETF2();
 559 }
 560 
 561 void VM_Version::set_features_z990(bool reset) {
 562   reset_features(reset);
 563 
 564   set_features_z900(false);
 565   set_has_ETF3();
 566   set_has_long_displacement_fast();
 567   set_has_HFPMultiplyAndAdd();
 568 }
 569 
 570 void VM_Version::set_features_z9(bool reset) {
 571   reset_features(reset);
 572 
 573   set_features_z990(false);
 574   set_has_StoreFacilityListExtended();
 575   // set_has_Crypto();   // Do not set, crypto features must be retrieved separately.
 576   set_has_ETF2Enhancements();
 577   set_has_ETF3Enhancements();
 578   set_has_extended_immediate();
 579   set_has_StoreClockFast();
 580   set_has_HFPUnnormalized();
 581 }
 582 
 583 void VM_Version::set_features_z10(bool reset) {
 584   reset_features(reset);
 585 
 586   set_features_z9(false);
 587   set_has_CompareSwapStore();
 588   set_has_RelativeLoadStore();
 589   set_has_CompareBranch();
 590   set_has_CompareTrap();
 591   set_has_MultiplySingleImm32();
 592   set_has_Prefetch();
 593   set_has_MoveImmToMem();
 594   set_has_MemWithImmALUOps();
 595   set_has_ExecuteExtensions();
 596   set_has_FPSupportEnhancements();
 597   set_has_DecimalFloatingPoint();
 598   set_has_ExtractCPUtime();
 599   set_has_CryptoExt3();
 600 }
 601 
 602 void VM_Version::set_features_z196(bool reset) {
 603   reset_features(reset);
 604 
 605   set_features_z10(false);
 606   set_has_InterlockedAccessV1();
 607   set_has_PopCount();
 608   set_has_LoadStoreConditional();
 609   set_has_HighWordInstr();
 610   set_has_FastSync();
 611   set_has_FPExtensions();
 612   set_has_DistinctOpnds();
 613   set_has_CryptoExt4();
 614 }
 615 
 616 void VM_Version::set_features_ec12(bool reset) {
 617   reset_features(reset);
 618 
 619   set_features_z196(false);
 620   set_has_MiscInstrExt();
 621   set_has_InterlockedAccessV2();
 622   set_has_LoadAndALUAtomicV2();
 623   set_has_TxMem();
 624 }
 625 
 626 void VM_Version::set_features_z13(bool reset) {
 627   reset_features(reset);
 628 
 629   set_features_ec12(false);
 630   set_has_LoadStoreConditional2();
 631   set_has_CryptoExt5();
 632   set_has_VectorFacility();
 633 }
 634 
 635 void VM_Version::set_features_from(const char* march) {
 636   bool err = false;
 637   bool prt = false;
 638 
 639   if ((march != NULL) &amp;&amp; (march[0] != &#39;\0&#39;)) {
 640     const int buf_len = 16;
 641     const int hdr_len =  5;
 642     char buf[buf_len];
 643     if (strlen(march) &gt;= hdr_len) {
 644       memcpy(buf, march, hdr_len);
 645       buf[hdr_len] = &#39;\00&#39;;
 646     } else {
 647       buf[0]       = &#39;\00&#39;;
 648     }
 649 
 650     if (!strcmp(march, &quot;z900&quot;)) {
 651       set_features_z900();
 652     } else if (!strcmp(march, &quot;z990&quot;)) {
 653         set_features_z990();
 654     } else if (!strcmp(march, &quot;z9&quot;)) {
 655         set_features_z9();
 656     } else if (!strcmp(march, &quot;z10&quot;)) {
 657         set_features_z10();
 658     } else if (!strcmp(march, &quot;z196&quot;)) {
 659         set_features_z196();
 660     } else if (!strcmp(march, &quot;ec12&quot;)) {
 661         set_features_ec12();
 662     } else if (!strcmp(march, &quot;z13&quot;)) {
 663         set_features_z13();
 664     } else if (!strcmp(buf, &quot;ztest&quot;)) {
 665       assert(!has_TestFeaturesImpl(), &quot;possible facility list flag conflict&quot;);
 666       if (strlen(march) &gt; hdr_len) {
 667         int itest = 0;
 668         if ((strlen(march)-hdr_len) &gt;= buf_len) err = true;
 669         if (!err) {
 670           memcpy(buf, &amp;march[hdr_len], strlen(march)-hdr_len);
 671           buf[strlen(march)-hdr_len] = &#39;\00&#39;;
 672           for (size_t i = 0; !err &amp;&amp; (i &lt; strlen(buf)); i++) {
 673             itest = itest*10 + buf[i]-&#39;0&#39;;
 674             err   = err || ((buf[i]-&#39;0&#39;) &lt; 0) || ((buf[i]-&#39;0&#39;) &gt; 9) || (itest &gt; 15);
 675           }
 676         }
 677         if (!err) {
 678           prt = true;
 679           if (itest &amp; 0x01) { set_has_TestFeature1Impl(); }
 680           if (itest &amp; 0x02) { set_has_TestFeature2Impl(); }
 681           if (itest &amp; 0x04) { set_has_TestFeature4Impl(); }
 682           if (itest &amp; 0x08) { set_has_TestFeature8Impl(); }
 683         }
 684       } else {
 685         prt = true;
 686         set_has_TestFeature1Impl();
 687         set_has_TestFeature2Impl();
 688         set_has_TestFeature4Impl();
 689         set_has_TestFeature8Impl();
 690       }
 691     } else {
 692       err = true;
 693     }
 694     if (!err) {
 695       set_features_string();
 696       if (prt || PrintAssembly) {
 697         print_features_internal(&quot;CPU Version as set by cmdline option:&quot;, prt);
 698       }
 699     } else {
 700       tty-&gt;print_cr(&quot;***Warning: Unsupported ProcessorArchitecture: %s, internal settings left undisturbed.&quot;, march);
 701     }
 702   }
 703 
 704 }
 705 
 706 static long (*getFeatures)(unsigned long*, int, int) = NULL;
 707 
 708 void VM_Version::set_getFeatures(address entryPoint) {
 709   if (getFeatures == NULL) {
 710     getFeatures = (long(*)(unsigned long*, int, int))entryPoint;
 711   }
 712 }
 713 
 714 long VM_Version::call_getFeatures(unsigned long* buffer, int buflen, int functionCode) {
 715   VM_Version::_is_determine_features_test_running = true;
 716   long functionResult = (*getFeatures)(buffer, buflen, functionCode);
 717   VM_Version::_is_determine_features_test_running = false;
 718   return functionResult;
 719 }
 720 
 721 // Helper function for &quot;extract cache attribute&quot; instruction.
 722 int VM_Version::calculate_ECAG_functionCode(unsigned int attributeIndication,
 723                                             unsigned int levelIndication,
 724                                             unsigned int typeIndication) {
 725   return (attributeIndication&lt;&lt;4) | (levelIndication&lt;&lt;1) | typeIndication;
 726 }
 727 
 728 void VM_Version::determine_features() {
 729 
 730   const int      cbuf_size = _code_buffer_len;
 731   const int      buf_len   = _features_buffer_len;
 732 
 733   // Allocate code buffer space for the detection code.
 734   ResourceMark    rm;
 735   CodeBuffer      cbuf(&quot;determine CPU features&quot;, cbuf_size, 0);
 736   MacroAssembler* a = new MacroAssembler(&amp;cbuf);
 737 
 738   // Emit code.
 739   set_getFeatures(a-&gt;pc());
 740   address   code = a-&gt;pc();
 741 
 742   // Try STFLE. Possible INVOP will cause defaults to be used.
 743   Label    getFEATURES;
 744   Label    getCPUFEATURES;                   // fcode = -1 (cache)
 745   Label    getCIPHERFEATURES;                // fcode = -2 (cipher)
 746   Label    getMSGDIGESTFEATURES;             // fcode = -3 (SHA)
 747   Label    getVECTORFEATURES;                // fcode = -4 (OS support for vector instructions)
 748   Label    errRTN;
 749   a-&gt;z_ltgfr(Z_R0, Z_ARG2);                  // Buf len to r0 and test.
 750   a-&gt;z_brl(getFEATURES);                     // negative -&gt; Get machine features not covered by facility list.
 751   a-&gt;z_lghi(Z_R1,0);
 752   a-&gt;z_brz(errRTN);                          // zero -&gt; Function code currently not used, indicate &quot;aborted&quot;.
 753 
 754   a-&gt;z_aghi(Z_R0, -1);
 755   a-&gt;z_stfle(0, Z_ARG1);
 756   a-&gt;z_lg(Z_R1, 0, Z_ARG1);                  // Get first DW of facility list.
 757   a-&gt;z_lgr(Z_RET, Z_R0);                     // Calculate rtn value for success.
 758   a-&gt;z_la(Z_RET, 1, Z_RET);
 759   a-&gt;z_brnz(errRTN);                         // Instr failed if non-zero CC.
 760   a-&gt;z_ltgr(Z_R1, Z_R1);                     // Instr failed if first DW == 0.
 761   a-&gt;z_bcr(Assembler::bcondNotZero, Z_R14);  // Successful return.
 762 
 763   a-&gt;bind(errRTN);
 764   a-&gt;z_lngr(Z_RET, Z_RET);
 765   a-&gt;z_ltgr(Z_R1, Z_R1);
 766   a-&gt;z_bcr(Assembler::bcondNotZero, Z_R14);  // Return &quot;buffer too small&quot;.
 767   a-&gt;z_xgr(Z_RET, Z_RET);
 768   a-&gt;z_br(Z_R14);                            // Return &quot;operation aborted&quot;.
 769 
 770   a-&gt;bind(getFEATURES);
 771   a-&gt;z_cghi(Z_R0, -1);                       // -1: Extract CPU attributes, currently: cache layout only.
 772   a-&gt;z_bre(getCPUFEATURES);
 773   a-&gt;z_cghi(Z_R0, -2);                       // -2: Extract detailed crypto capabilities (cipher instructions).
 774   a-&gt;z_bre(getCIPHERFEATURES);
 775   a-&gt;z_cghi(Z_R0, -3);                       // -3: Extract detailed crypto capabilities (msg digest instructions).
 776   a-&gt;z_bre(getMSGDIGESTFEATURES);
 777   a-&gt;z_cghi(Z_R0, -4);                       // -4: Verify vector instruction availability (OS support).
 778   a-&gt;z_bre(getVECTORFEATURES);
 779 
 780   a-&gt;z_xgr(Z_RET, Z_RET);                    // Not a valid function code.
 781   a-&gt;z_br(Z_R14);                            // Return &quot;operation aborted&quot;.
 782 
 783   // Try KIMD/KLMD query function to get details about msg digest (secure hash, SHA) instructions.
 784   a-&gt;bind(getMSGDIGESTFEATURES);
 785   a-&gt;z_lghi(Z_R0,(int)MsgDigest::_Query);    // query function code
 786   a-&gt;z_lgr(Z_R1,Z_R2);                       // param block addr, 2*16 bytes min size
 787   a-&gt;z_kimd(Z_R2,Z_R2);                      // Get available KIMD functions (bit pattern in param blk).
 788   a-&gt;z_la(Z_R1,16,Z_R1);                     // next param block addr
 789   a-&gt;z_klmd(Z_R2,Z_R2);                      // Get available KLMD functions (bit pattern in param blk).
 790   a-&gt;z_lghi(Z_RET,4);
 791   a-&gt;z_br(Z_R14);
 792 
 793   // Try KM/KMC query function to get details about crypto instructions.
 794   a-&gt;bind(getCIPHERFEATURES);
 795   a-&gt;z_lghi(Z_R0,(int)Cipher::_Query);       // query function code
 796   a-&gt;z_lgr(Z_R1,Z_R2);                       // param block addr, 2*16 bytes min size (KIMD/KLMD output)
 797   a-&gt;z_km(Z_R2,Z_R2);                        // get available KM functions
 798   a-&gt;z_la(Z_R1,16,Z_R1);                     // next param block addr
 799   a-&gt;z_kmc(Z_R2,Z_R2);                       // get available KMC functions
 800   a-&gt;z_lghi(Z_RET,4);
 801   a-&gt;z_br(Z_R14);
 802 
 803   // Use EXTRACT CPU ATTRIBUTE instruction to get information about cache layout.
 804   a-&gt;bind(getCPUFEATURES);
 805   a-&gt;z_xgr(Z_R0,Z_R0);                       // as recommended in instruction documentation
 806   a-&gt;z_ecag(Z_RET,Z_R0,0,Z_ARG3);            // Extract information as requested by Z_ARG1 contents.
 807   a-&gt;z_br(Z_R14);
 808 
 809   // Use a vector instruction to verify OS support. Will fail with SIGFPE if OS support is missing.
 810   a-&gt;bind(getVECTORFEATURES);
 811   a-&gt;z_vtm(Z_V0,Z_V0);                       // non-destructive vector instruction. Will cause SIGFPE if not supported.
 812   a-&gt;z_br(Z_R14);
 813 
 814   address code_end = a-&gt;pc();
 815   a-&gt;flush();
 816 
 817   cbuf.insts()-&gt;set_end(code_end);
 818 
 819   // Print the detection code.
 820   bool printVerbose = Verbose || PrintAssembly || PrintStubCode;
 821   if (printVerbose) {
 822     ttyLocker ttyl;
 823     tty-&gt;print_cr(&quot;Decoding CPU feature detection stub at &quot; INTPTR_FORMAT &quot; before execution:&quot;, p2i(code));
 824     tty-&gt;print_cr(&quot;Stub length is %ld bytes, codebuffer reserves %d bytes, %ld bytes spare.&quot;,
 825                   code_end-code, cbuf_size, cbuf_size-(code_end-code));
 826 
 827     // Use existing decode function. This enables the [MachCode] format which is needed to DecodeErrorFile.
 828     Disassembler::decode(&amp;cbuf, code, code_end, tty);
 829   }
 830 
 831   // Prepare for detection code execution and clear work buffer.
 832   _nfeatures        = 0;
 833   _ncipher_features = 0;
 834   unsigned long  buffer[buf_len];
 835 
 836   for (int i = 0; i &lt; buf_len; i++) {
 837     buffer[i] = 0L;
 838   }
 839 
 840   // execute code
 841   // Illegal instructions will be replaced by 0 in signal handler.
 842   // In case of problems, call_getFeatures will return a not-positive result.
 843   long used_len = call_getFeatures(buffer, buf_len, 0);
 844 
 845   bool ok;
 846   if (used_len == 1) {
 847     ok = true;
 848   } else if (used_len &gt; 1) {
 849     unsigned int used_lenU = (unsigned int)used_len;
 850     ok = true;
 851     for (unsigned int i = 1; i &lt; used_lenU; i++) {
 852       ok = ok &amp;&amp; (buffer[i] == 0L);
 853     }
 854     if (printVerbose &amp;&amp; !ok) {
 855       bool compact = false;
 856       tty-&gt;print_cr(&quot;Note: feature list has %d (i.e. more than one) array elements.&quot;, used_lenU);
 857       if (compact) {
 858         tty-&gt;print(&quot;non-zero feature list elements:&quot;);
 859         for (unsigned int i = 0; i &lt; used_lenU; i++) {
 860           tty-&gt;print(&quot;  [%d]: 0x%16.16lx&quot;, i, buffer[i]);
 861         }
 862         tty-&gt;cr();
 863       } else {
 864         for (unsigned int i = 0; i &lt; used_lenU; i++) {
 865           tty-&gt;print_cr(&quot;non-zero feature list[%d]: 0x%16.16lx&quot;, i, buffer[i]);
 866         }
 867       }
 868 
 869       if (compact) {
 870         tty-&gt;print_cr(&quot;Active features (compact view):&quot;);
 871         for (unsigned int k = 0; k &lt; used_lenU; k++) {
 872           tty-&gt;print_cr(&quot;  buffer[%d]:&quot;, k);
 873           for (unsigned int j = k*sizeof(long); j &lt; (k+1)*sizeof(long); j++) {
 874             bool line = false;
 875             for (unsigned int i = j*8; i &lt; (j+1)*8; i++) {
 876               bool bit  = test_feature_bit(buffer, i, used_lenU*sizeof(long)*8);
 877               if (bit) {
 878                 if (!line) {
 879                   tty-&gt;print(&quot;    byte[%d]:&quot;, j);
 880                   line = true;
 881                 }
 882                 tty-&gt;print(&quot;  [%3.3d]&quot;, i);
 883               }
 884             }
 885             if (line) {
 886               tty-&gt;cr();
 887             }
 888           }
 889         }
 890       } else {
 891         tty-&gt;print_cr(&quot;Active features (full view):&quot;);
 892         for (unsigned int k = 0; k &lt; used_lenU; k++) {
 893           tty-&gt;print_cr(&quot;  buffer[%d]:&quot;, k);
 894           for (unsigned int j = k*sizeof(long); j &lt; (k+1)*sizeof(long); j++) {
 895             tty-&gt;print(&quot;    byte[%d]:&quot;, j);
 896             for (unsigned int i = j*8; i &lt; (j+1)*8; i++) {
 897               bool bit  = test_feature_bit(buffer, i, used_lenU*sizeof(long)*8);
 898               if (bit) {
 899                 tty-&gt;print(&quot;  [%3.3d]&quot;, i);
 900               } else {
 901                 tty-&gt;print(&quot;       &quot;);
 902               }
 903             }
 904             tty-&gt;cr();
 905           }
 906         }
 907       }
 908     }
 909     ok = true;
 910   } else {  // No features retrieved if we reach here. Buffer too short or instr not available.
 911     if (used_len &lt; 0) {
 912       ok = false;
 913       if (printVerbose) {
 914         tty-&gt;print_cr(&quot;feature list buffer[%d] too short, required: buffer[%ld]&quot;, buf_len, -used_len);
 915       }
 916     } else {
 917       if (printVerbose) {
 918         tty-&gt;print_cr(&quot;feature list could not be retrieved. Running on z900 or z990? Trying to find out...&quot;);
 919       }
 920       used_len = call_getFeatures(buffer, 0, 0);       // Must provide at least two DW buffer elements!!!!
 921 
 922       ok = used_len &gt; 0;
 923       if (ok) {
 924         if (buffer[1]*10 &lt; buffer[0]) {
 925           set_features_z900();
 926         } else {
 927           set_features_z990();
 928         }
 929 
 930         if (printVerbose) {
 931           tty-&gt;print_cr(&quot;Note: high-speed long displacement test used %ld iterations.&quot;, used_len);
 932           tty-&gt;print_cr(&quot;      Positive displacement loads took %8.8lu microseconds.&quot;, buffer[1]);
 933           tty-&gt;print_cr(&quot;      Negative displacement loads took %8.8lu microseconds.&quot;, buffer[0]);
 934           if (has_long_displacement_fast()) {
 935             tty-&gt;print_cr(&quot;      assuming high-speed long displacement IS     available.&quot;);
 936           } else {
 937             tty-&gt;print_cr(&quot;      assuming high-speed long displacement is NOT available.&quot;);
 938           }
 939         }
 940       } else {
 941         if (printVerbose) {
 942           tty-&gt;print_cr(&quot;Note: high-speed long displacement test was not successful.&quot;);
 943           tty-&gt;print_cr(&quot;      assuming long displacement is NOT available.&quot;);
 944         }
 945       }
 946       return; // Do not copy buffer to _features, no test for cipher features.
 947     }
 948   }
 949 
 950   if (ok) {
 951     // Fill features buffer.
 952     // Clear work buffer.
 953     for (int i = 0; i &lt; buf_len; i++) {
 954       _features[i]           = buffer[i];
 955       _cipher_features[i]    = 0;
 956       _msgdigest_features[i] = 0;
 957       buffer[i]              = 0L;
 958     }
 959     _nfeatures = used_len;
 960   } else {
 961     for (int i = 0; i &lt; buf_len; i++) {
 962       _features[i]           = 0;
 963       _cipher_features[i]    = 0;
 964       _msgdigest_features[i] = 0;
 965       buffer[i]              = 0L;
 966     }
 967     _nfeatures = 0;
 968   }
 969 
 970   if (has_VectorFacility()) {
 971     // Verify that feature can actually be used. OS support required.
 972     call_getFeatures(buffer, -4, 0);
 973     if (printVerbose) {
 974       ttyLocker ttyl;
 975       if (has_VectorFacility()) {
 976         tty-&gt;print_cr(&quot;  Vector Facility has been verified to be supported by OS&quot;);
 977       } else {
 978         tty-&gt;print_cr(&quot;  Vector Facility has been disabled - not supported by OS&quot;);
 979       }
 980     }
 981   }
 982 
 983   // Extract Crypto Facility details.
 984   if (has_Crypto()) {
 985     // Get cipher features.
 986     used_len = call_getFeatures(buffer, -2, 0);
 987     for (int i = 0; i &lt; buf_len; i++) {
 988       _cipher_features[i] = buffer[i];
 989     }
 990     _ncipher_features = used_len;
 991 
 992     // Get msg digest features.
 993     used_len = call_getFeatures(buffer, -3, 0);
 994     for (int i = 0; i &lt; buf_len; i++) {
 995       _msgdigest_features[i] = buffer[i];
 996     }
 997     _nmsgdigest_features = used_len;
 998   }
 999 
1000   static int   levelProperties[_max_cache_levels];     // All property indications per level.
1001   static int   levelScope[_max_cache_levels];          // private/shared
1002   static const char* levelScopeText[4] = {&quot;No cache   &quot;,
1003                                           &quot;CPU private&quot;,
1004                                           &quot;shared     &quot;,
1005                                           &quot;reserved   &quot;};
1006 
1007   static int   levelType[_max_cache_levels];           // D/I/mixed
1008   static const char* levelTypeText[4]  = {&quot;separate D and I caches&quot;,
1009                                           &quot;I cache only           &quot;,
1010                                           &quot;D-cache only           &quot;,
1011                                           &quot;combined D/I cache     &quot;};
1012 
1013   static unsigned int levelReserved[_max_cache_levels];    // reserved property bits
1014   static unsigned int levelLineSize[_max_cache_levels];
1015   static unsigned int levelTotalSize[_max_cache_levels];
1016   static unsigned int levelAssociativity[_max_cache_levels];
1017 
1018 
1019   // Extract Cache Layout details.
1020   if (has_ExtractCPUAttributes() &amp;&amp; printVerbose) { // For information only, as of now.
1021     bool         lineSize_mismatch;
1022     bool         print_something;
1023     long         functionResult;
1024     unsigned int attributeIndication = 0; // 0..15
1025     unsigned int levelIndication     = 0; // 0..8
1026     unsigned int typeIndication      = 0; // 0..1 (D-Cache, I-Cache)
1027     int          functionCode        = calculate_ECAG_functionCode(attributeIndication, levelIndication, typeIndication);
1028 
1029     // Get cache topology.
1030     functionResult = call_getFeatures(buffer, -1, functionCode);
1031 
1032     for (unsigned int i = 0; i &lt; _max_cache_levels; i++) {
1033       if (functionResult &gt; 0) {
1034         int shiftVal          = 8*(_max_cache_levels-(i+1));
1035         levelProperties[i]    = (functionResult &amp; (0xffUL&lt;&lt;shiftVal)) &gt;&gt; shiftVal;
1036         levelReserved[i]      = (levelProperties[i] &amp; 0xf0) &gt;&gt; 4;
1037         levelScope[i]         = (levelProperties[i] &amp; 0x0c) &gt;&gt; 2;
1038         levelType[i]          = (levelProperties[i] &amp; 0x03);
1039       } else {
1040         levelProperties[i]    = 0;
1041         levelReserved[i]      = 0;
1042         levelScope[i]         = 0;
1043         levelType[i]          = 0;
1044       }
1045       levelLineSize[i]      = 0;
1046       levelTotalSize[i]     = 0;
1047       levelAssociativity[i] = 0;
1048     }
1049 
1050     tty-&gt;cr();
1051     tty-&gt;print_cr(&quot;------------------------------------&quot;);
1052     tty-&gt;print_cr(&quot;---  Cache Topology Information  ---&quot;);
1053     tty-&gt;print_cr(&quot;------------------------------------&quot;);
1054     for (unsigned int i = 0; (i &lt; _max_cache_levels) &amp;&amp; (levelProperties[i] != 0); i++) {
1055       tty-&gt;print_cr(&quot;  Cache Level %d: &lt;scope&gt;  %s | &lt;type&gt;  %s&quot;,
1056                     i+1, levelScopeText[levelScope[i]], levelTypeText[levelType[i]]);
1057     }
1058 
1059     // Get D-cache details per level.
1060     _Dcache_lineSize   = 0;
1061     lineSize_mismatch  = false;
1062     print_something    = false;
1063     typeIndication     = 0; // 0..1 (D-Cache, I-Cache)
1064     for (unsigned int i = 0; (i &lt; _max_cache_levels) &amp;&amp; (levelProperties[i] != 0); i++) {
1065       if ((levelType[i] == 0) || (levelType[i] == 2)) {
1066         print_something     = true;
1067 
1068         // Get cache line size of level i.
1069         attributeIndication   = 1;
1070         functionCode          = calculate_ECAG_functionCode(attributeIndication, i, typeIndication);
1071         levelLineSize[i]      = (unsigned int)call_getFeatures(buffer, -1, functionCode);
1072 
1073         // Get cache total size of level i.
1074         attributeIndication   = 2;
1075         functionCode          = calculate_ECAG_functionCode(attributeIndication, i, typeIndication);
1076         levelTotalSize[i]     = (unsigned int)call_getFeatures(buffer, -1, functionCode);
1077 
1078         // Get cache associativity of level i.
1079         attributeIndication   = 3;
1080         functionCode          = calculate_ECAG_functionCode(attributeIndication, i, typeIndication);
1081         levelAssociativity[i] = (unsigned int)call_getFeatures(buffer, -1, functionCode);
1082 
1083         _Dcache_lineSize      = _Dcache_lineSize == 0 ? levelLineSize[i] : _Dcache_lineSize;
1084         lineSize_mismatch     = lineSize_mismatch || (_Dcache_lineSize != levelLineSize[i]);
1085       } else {
1086         levelLineSize[i]      = 0;
1087       }
1088     }
1089 
1090     if (print_something) {
1091       tty-&gt;cr();
1092       tty-&gt;print_cr(&quot;------------------------------------&quot;);
1093       tty-&gt;print_cr(&quot;---  D-Cache Detail Information  ---&quot;);
1094       tty-&gt;print_cr(&quot;------------------------------------&quot;);
1095       if (lineSize_mismatch) {
1096         tty-&gt;print_cr(&quot;WARNING: D-Cache line size mismatch!&quot;);
1097       }
1098       for (unsigned int i = 0; (i &lt; _max_cache_levels) &amp;&amp; (levelProperties[i] != 0); i++) {
1099         if (levelLineSize[i] &gt; 0) {
1100           tty-&gt;print_cr(&quot;  D-Cache Level %d: line size = %4d,  total size = %6dKB,  associativity = %2d&quot;,
1101                         i+1, levelLineSize[i], levelTotalSize[i]/(int)K, levelAssociativity[i]);
1102         }
1103       }
1104     }
1105 
1106     // Get I-cache details per level.
1107     _Icache_lineSize   = 0;
1108     lineSize_mismatch  = false;
1109     print_something    = false;
1110     typeIndication     = 1; // 0..1 (D-Cache, I-Cache)
1111     for (unsigned int i = 0; (i &lt; _max_cache_levels) &amp;&amp; (levelProperties[i] != 0); i++) {
1112       if ((levelType[i] == 0) || (levelType[i] == 1)) {
1113         print_something     = true;
1114 
1115         // Get cache line size of level i.
1116         attributeIndication   = 1;
1117         functionCode          = calculate_ECAG_functionCode(attributeIndication, i, typeIndication);
1118         levelLineSize[i]      = (unsigned int)call_getFeatures(buffer, -1, functionCode);
1119 
1120         // Get cache total size of level i.
1121         attributeIndication   = 2;
1122         functionCode          = calculate_ECAG_functionCode(attributeIndication, i, typeIndication);
1123         levelTotalSize[i]     = (unsigned int)call_getFeatures(buffer, -1, functionCode);
1124 
1125         // Get cache associativity of level i.
1126         attributeIndication   = 3;
1127         functionCode          = calculate_ECAG_functionCode(attributeIndication, i, typeIndication);
1128         levelAssociativity[i] = (unsigned int)call_getFeatures(buffer, -1, functionCode);
1129 
1130         _Icache_lineSize      = _Icache_lineSize == 0 ? levelLineSize[i] : _Icache_lineSize;
1131         lineSize_mismatch     = lineSize_mismatch || (_Icache_lineSize != levelLineSize[i]);
1132       } else {
1133         levelLineSize[i]      = 0;
1134       }
1135     }
1136 
1137     if (print_something) {
1138       tty-&gt;cr();
1139       tty-&gt;print_cr(&quot;------------------------------------&quot;);
1140       tty-&gt;print_cr(&quot;---  I-Cache Detail Information  ---&quot;);
1141       tty-&gt;print_cr(&quot;------------------------------------&quot;);
1142       if (lineSize_mismatch) {
1143         tty-&gt;print_cr(&quot;WARNING: I-Cache line size mismatch!&quot;);
1144       }
1145       for (unsigned int i = 0; (i &lt; _max_cache_levels) &amp;&amp; (levelProperties[i] != 0); i++) {
1146         if (levelLineSize[i] &gt; 0) {
1147           tty-&gt;print_cr(&quot;  I-Cache Level %d: line size = %4d,  total size = %6dKB,  associativity = %2d&quot;,
1148                         i+1, levelLineSize[i], levelTotalSize[i]/(int)K, levelAssociativity[i]);
1149         }
1150       }
1151     }
1152 
1153     // Get D/I-cache details per level.
1154     lineSize_mismatch  = false;
1155     print_something    = false;
1156     typeIndication     = 0; // 0..1 (D-Cache, I-Cache)
1157     for (unsigned int i = 0; (i &lt; _max_cache_levels) &amp;&amp; (levelProperties[i] != 0); i++) {
1158       if (levelType[i] == 3) {
1159         print_something     = true;
1160 
1161         // Get cache line size of level i.
1162         attributeIndication   = 1;
1163         functionCode          = calculate_ECAG_functionCode(attributeIndication, i, typeIndication);
1164         levelLineSize[i]      = (unsigned int)call_getFeatures(buffer, -1, functionCode);
1165 
1166         // Get cache total size of level i.
1167         attributeIndication   = 2;
1168         functionCode          = calculate_ECAG_functionCode(attributeIndication, i, typeIndication);
1169         levelTotalSize[i]     = (unsigned int)call_getFeatures(buffer, -1, functionCode);
1170 
1171         // Get cache associativity of level i.
1172         attributeIndication   = 3;
1173         functionCode          = calculate_ECAG_functionCode(attributeIndication, i, typeIndication);
1174         levelAssociativity[i] = (unsigned int)call_getFeatures(buffer, -1, functionCode);
1175 
1176         _Dcache_lineSize      = _Dcache_lineSize == 0 ? levelLineSize[i] : _Dcache_lineSize;
1177         _Icache_lineSize      = _Icache_lineSize == 0 ? levelLineSize[i] : _Icache_lineSize;
1178         lineSize_mismatch     = lineSize_mismatch || (_Dcache_lineSize != levelLineSize[i])
1179                                                   || (_Icache_lineSize != levelLineSize[i]);
1180       } else {
1181         levelLineSize[i]      = 0;
1182       }
1183     }
1184 
1185     if (print_something) {
1186       tty-&gt;cr();
1187       tty-&gt;print_cr(&quot;--------------------------------------&quot;);
1188       tty-&gt;print_cr(&quot;---  D/I-Cache Detail Information  ---&quot;);
1189       tty-&gt;print_cr(&quot;--------------------------------------&quot;);
1190       if (lineSize_mismatch) {
1191         tty-&gt;print_cr(&quot;WARNING: D/I-Cache line size mismatch!&quot;);
1192       }
1193       for (unsigned int i = 0; (i &lt; _max_cache_levels) &amp;&amp; (levelProperties[i] != 0); i++) {
1194         if (levelLineSize[i] &gt; 0) {
1195           tty-&gt;print_cr(&quot;  D/I-Cache Level %d: line size = %4d,  total size = %6dKB,  associativity = %2d&quot;,
1196                         i+1, levelLineSize[i], levelTotalSize[i]/(int)K, levelAssociativity[i]);
1197         }
1198       }
1199     }
1200     tty-&gt;cr();
1201   }
1202   return;
1203 }
1204 
1205 unsigned long VM_Version::z_SIGILL() {
1206   unsigned long   ZeroBuffer = 0;
1207   unsigned long   work;
1208   asm(
1209     &quot;     LA      %[work],%[buffer]  \n\t&quot;   // Load address of buffer.
1210     &quot;     LARL    14,+6              \n\t&quot;   // Load address of faulting instruction.
1211     &quot;     BCR     15,%[work]         \n\t&quot;   // Branch into buffer, execute whatever is in there.
1212     : [buffer]  &quot;+Q&quot;  (ZeroBuffer)   /* outputs   */
1213     , [work]   &quot;=&amp;a&quot;  (work)         /* outputs   */
1214     :                                /* inputs    */
1215     : &quot;cc&quot;                           /* clobbered */
1216  );
1217   return ZeroBuffer;
1218 }
1219 
1220 unsigned long VM_Version::z_SIGSEGV() {
1221   unsigned long   ZeroBuffer = 0;
1222   unsigned long   work;
1223   asm(
1224     &quot;     LG      %[work],%[buffer]  \n\t&quot;   // Load zero address.
1225     &quot;     STG     %[work],0(,%[work])\n\t&quot;   // Store to address zero.
1226     : [buffer]  &quot;+Q&quot;  (ZeroBuffer)   /* outputs   */
1227     , [work]   &quot;=&amp;a&quot;  (work)         /* outputs   */
1228     :                                /* inputs    */
1229     : &quot;cc&quot;                           /* clobbered */
1230  );
1231   return ZeroBuffer;
1232 }
1233 
<a name="13" id="anc13"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="13" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/cpu/s390/c2_MacroAssembler_s390.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/assembler.hpp&quot;
  27 #include &quot;asm/assembler.inline.hpp&quot;
  28 #include &quot;opto/c2_MacroAssembler.hpp&quot;
  29 #include &quot;opto/intrinsicnode.hpp&quot;
  30 
  31 #define BLOCK_COMMENT(str) block_comment(str)
  32 #define BIND(label)        bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
  33 
  34 //------------------------------------------------------
  35 //   Special String Intrinsics. Implementation
  36 //------------------------------------------------------
  37 
  38 // Intrinsics for CompactStrings
  39 
  40 // Compress char[] to byte[].
  41 //   Restores: src, dst
  42 //   Uses:     cnt
  43 //   Kills:    tmp, Z_R0, Z_R1.
  44 //   Early clobber: result.
  45 // Note:
  46 //   cnt is signed int. Do not rely on high word!
  47 //       counts # characters, not bytes.
  48 // The result is the number of characters copied before the first incompatible character was found.
  49 // If precise is true, the processing stops exactly at this point. Otherwise, the result may be off
  50 // by a few bytes. The result always indicates the number of copied characters.
  51 // When used as a character index, the returned value points to the first incompatible character.
  52 //
  53 // Note: Does not behave exactly like package private StringUTF16 compress java implementation in case of failure:
  54 // - Different number of characters may have been written to dead array (if precise is false).
  55 // - Returns a number &lt;cnt instead of 0. (Result gets compared with cnt.)
  56 unsigned int C2_MacroAssembler::string_compress(Register result, Register src, Register dst, Register cnt,
  57                                                 Register tmp,    bool precise) {
  58   assert_different_registers(Z_R0, Z_R1, result, src, dst, cnt, tmp);
  59 
  60   if (precise) {
  61     BLOCK_COMMENT(&quot;encode_iso_array {&quot;);
  62   } else {
  63     BLOCK_COMMENT(&quot;string_compress {&quot;);
  64   }
  65   int  block_start = offset();
  66 
  67   Register       Rsrc  = src;
  68   Register       Rdst  = dst;
  69   Register       Rix   = tmp;
  70   Register       Rcnt  = cnt;
  71   Register       Rmask = result;  // holds incompatibility check mask until result value is stored.
  72   Label          ScalarShortcut, AllDone;
  73 
  74   z_iilf(Rmask, 0xFF00FF00);
  75   z_iihf(Rmask, 0xFF00FF00);
  76 
  77 #if 0  // Sacrifice shortcuts for code compactness
  78   {
  79     //---&lt;  shortcuts for short strings (very frequent)   &gt;---
  80     //   Strings with 4 and 8 characters were fond to occur very frequently.
  81     //   Therefore, we handle them right away with minimal overhead.
  82     Label     skipShortcut, skip4Shortcut, skip8Shortcut;
  83     Register  Rout = Z_R0;
  84     z_chi(Rcnt, 4);
  85     z_brne(skip4Shortcut);                 // 4 characters are very frequent
  86       z_lg(Z_R0, 0, Rsrc);                 // Treat exactly 4 characters specially.
  87       if (VM_Version::has_DistinctOpnds()) {
  88         Rout = Z_R0;
  89         z_ngrk(Rix, Z_R0, Rmask);
  90       } else {
  91         Rout = Rix;
  92         z_lgr(Rix, Z_R0);
  93         z_ngr(Z_R0, Rmask);
  94       }
  95       z_brnz(skipShortcut);
  96       z_stcmh(Rout, 5, 0, Rdst);
  97       z_stcm(Rout,  5, 2, Rdst);
  98       z_lgfr(result, Rcnt);
  99       z_bru(AllDone);
 100     bind(skip4Shortcut);
 101 
 102     z_chi(Rcnt, 8);
 103     z_brne(skip8Shortcut);                 // There&#39;s more to do...
 104       z_lmg(Z_R0, Z_R1, 0, Rsrc);          // Treat exactly 8 characters specially.
 105       if (VM_Version::has_DistinctOpnds()) {
 106         Rout = Z_R0;
 107         z_ogrk(Rix, Z_R0, Z_R1);
 108         z_ngr(Rix, Rmask);
 109       } else {
 110         Rout = Rix;
 111         z_lgr(Rix, Z_R0);
 112         z_ogr(Z_R0, Z_R1);
 113         z_ngr(Z_R0, Rmask);
 114       }
 115       z_brnz(skipShortcut);
 116       z_stcmh(Rout, 5, 0, Rdst);
 117       z_stcm(Rout,  5, 2, Rdst);
 118       z_stcmh(Z_R1, 5, 4, Rdst);
 119       z_stcm(Z_R1,  5, 6, Rdst);
 120       z_lgfr(result, Rcnt);
 121       z_bru(AllDone);
 122 
 123     bind(skip8Shortcut);
 124     clear_reg(Z_R0, true, false);          // #characters already processed (none). Precond for scalar loop.
 125     z_brl(ScalarShortcut);                 // Just a few characters
 126 
 127     bind(skipShortcut);
 128   }
 129 #endif
 130   clear_reg(Z_R0);                         // make sure register is properly initialized.
 131 
 132   if (VM_Version::has_VectorFacility()) {
 133     const int  min_vcnt     = 32;          // Minimum #characters required to use vector instructions.
 134                                            // Otherwise just do nothing in vector mode.
 135                                            // Must be multiple of 2*(vector register length in chars (8 HW = 128 bits)).
 136     const int  log_min_vcnt = exact_log2(min_vcnt);
 137     Label      VectorLoop, VectorDone, VectorBreak;
 138 
 139     VectorRegister Vtmp1      = Z_V16;
 140     VectorRegister Vtmp2      = Z_V17;
 141     VectorRegister Vmask      = Z_V18;
 142     VectorRegister Vzero      = Z_V19;
 143     VectorRegister Vsrc_first = Z_V20;
 144     VectorRegister Vsrc_last  = Z_V23;
 145 
 146     assert((Vsrc_last-&gt;encoding() - Vsrc_first-&gt;encoding() + 1) == min_vcnt/8, &quot;logic error&quot;);
 147     assert(VM_Version::has_DistinctOpnds(), &quot;Assumption when has_VectorFacility()&quot;);
 148     z_srak(Rix, Rcnt, log_min_vcnt);       // # vector loop iterations
 149     z_brz(VectorDone);                     // not enough data for vector loop
 150 
 151     z_vzero(Vzero);                        // all zeroes
 152     z_vgmh(Vmask, 0, 7);                   // generate 0xff00 mask for all 2-byte elements
 153     z_sllg(Z_R0, Rix, log_min_vcnt);       // remember #chars that will be processed by vector loop
 154 
 155     bind(VectorLoop);
 156       z_vlm(Vsrc_first, Vsrc_last, 0, Rsrc);
 157       add2reg(Rsrc, min_vcnt*2);
 158 
 159       //---&lt;  check for incompatible character  &gt;---
 160       z_vo(Vtmp1, Z_V20, Z_V21);
 161       z_vo(Vtmp2, Z_V22, Z_V23);
 162       z_vo(Vtmp1, Vtmp1, Vtmp2);
 163       z_vn(Vtmp1, Vtmp1, Vmask);
 164       z_vceqhs(Vtmp1, Vtmp1, Vzero);       // high half of all chars must be zero for successful compress.
 165       z_bvnt(VectorBreak);                 // break vector loop if not all vector elements compare eq -&gt; incompatible character found.
 166                                            // re-process data from current iteration in break handler.
 167 
 168       //---&lt;  pack &amp; store characters  &gt;---
 169       z_vpkh(Vtmp1, Z_V20, Z_V21);         // pack (src1, src2) -&gt; tmp1
 170       z_vpkh(Vtmp2, Z_V22, Z_V23);         // pack (src3, src4) -&gt; tmp2
 171       z_vstm(Vtmp1, Vtmp2, 0, Rdst);       // store packed string
 172       add2reg(Rdst, min_vcnt);
 173 
 174       z_brct(Rix, VectorLoop);
 175 
 176     z_bru(VectorDone);
 177 
 178     bind(VectorBreak);
 179       add2reg(Rsrc, -min_vcnt*2);          // Fix Rsrc. Rsrc was already updated, but Rdst and Rix are not.
 180       z_sll(Rix, log_min_vcnt);            // # chars processed so far in VectorLoop, excl. current iteration.
 181       z_sr(Z_R0, Rix);                     // correct # chars processed in total.
 182 
 183     bind(VectorDone);
 184   }
 185 
 186   {
 187     const int  min_cnt     =  8;           // Minimum #characters required to use unrolled loop.
 188                                            // Otherwise just do nothing in unrolled loop.
 189                                            // Must be multiple of 8.
 190     const int  log_min_cnt = exact_log2(min_cnt);
 191     Label      UnrolledLoop, UnrolledDone, UnrolledBreak;
 192 
 193     if (VM_Version::has_DistinctOpnds()) {
 194       z_srk(Rix, Rcnt, Z_R0);              // remaining # chars to compress in unrolled loop
 195     } else {
 196       z_lr(Rix, Rcnt);
 197       z_sr(Rix, Z_R0);
 198     }
 199     z_sra(Rix, log_min_cnt);             // unrolled loop count
 200     z_brz(UnrolledDone);
 201 
 202     bind(UnrolledLoop);
 203       z_lmg(Z_R0, Z_R1, 0, Rsrc);
 204       if (precise) {
 205         z_ogr(Z_R1, Z_R0);                 // check all 8 chars for incompatibility
 206         z_ngr(Z_R1, Rmask);
 207         z_brnz(UnrolledBreak);
 208 
 209         z_lg(Z_R1, 8, Rsrc);               // reload destroyed register
 210         z_stcmh(Z_R0, 5, 0, Rdst);
 211         z_stcm(Z_R0,  5, 2, Rdst);
 212       } else {
 213         z_stcmh(Z_R0, 5, 0, Rdst);
 214         z_stcm(Z_R0,  5, 2, Rdst);
 215 
 216         z_ogr(Z_R0, Z_R1);
 217         z_ngr(Z_R0, Rmask);
 218         z_brnz(UnrolledBreak);
 219       }
 220       z_stcmh(Z_R1, 5, 4, Rdst);
 221       z_stcm(Z_R1,  5, 6, Rdst);
 222 
 223       add2reg(Rsrc, min_cnt*2);
 224       add2reg(Rdst, min_cnt);
 225       z_brct(Rix, UnrolledLoop);
 226 
 227     z_lgfr(Z_R0, Rcnt);                    // # chars processed in total after unrolled loop.
 228     z_nilf(Z_R0, ~(min_cnt-1));
 229     z_tmll(Rcnt, min_cnt-1);
 230     z_brnaz(ScalarShortcut);               // if all bits zero, there is nothing left to do for scalar loop.
 231                                            // Rix == 0 in all cases.
 232     z_sllg(Z_R1, Rcnt, 1);                 // # src bytes already processed. Only lower 32 bits are valid!
 233                                            //   Z_R1 contents must be treated as unsigned operand! For huge strings,
 234                                            //   (Rcnt &gt;= 2**30), the value may spill into the sign bit by sllg.
 235     z_lgfr(result, Rcnt);                  // all characters processed.
 236     z_slgfr(Rdst, Rcnt);                   // restore ptr
 237     z_slgfr(Rsrc, Z_R1);                   // restore ptr, double the element count for Rsrc restore
 238     z_bru(AllDone);
 239 
 240     bind(UnrolledBreak);
 241     z_lgfr(Z_R0, Rcnt);                    // # chars processed in total after unrolled loop
 242     z_nilf(Z_R0, ~(min_cnt-1));
 243     z_sll(Rix, log_min_cnt);               // # chars not yet processed in UnrolledLoop (due to break), broken iteration not included.
 244     z_sr(Z_R0, Rix);                       // fix # chars processed OK so far.
 245     if (!precise) {
 246       z_lgfr(result, Z_R0);
 247       z_sllg(Z_R1, Z_R0, 1);               // # src bytes already processed. Only lower 32 bits are valid!
 248                                            //   Z_R1 contents must be treated as unsigned operand! For huge strings,
 249                                            //   (Rcnt &gt;= 2**30), the value may spill into the sign bit by sllg.
 250       z_aghi(result, min_cnt/2);           // min_cnt/2 characters have already been written
 251                                            // but ptrs were not updated yet.
 252       z_slgfr(Rdst, Z_R0);                 // restore ptr
 253       z_slgfr(Rsrc, Z_R1);                 // restore ptr, double the element count for Rsrc restore
 254       z_bru(AllDone);
 255     }
 256     bind(UnrolledDone);
 257   }
 258 
 259   {
 260     Label     ScalarLoop, ScalarDone, ScalarBreak;
 261 
 262     bind(ScalarShortcut);
 263     z_ltgfr(result, Rcnt);
 264     z_brz(AllDone);
 265 
 266 #if 0  // Sacrifice shortcuts for code compactness
 267     {
 268       //---&lt;  Special treatment for very short strings (one or two characters)  &gt;---
 269       //   For these strings, we are sure that the above code was skipped.
 270       //   Thus, no registers were modified, register restore is not required.
 271       Label     ScalarDoit, Scalar2Char;
 272       z_chi(Rcnt, 2);
 273       z_brh(ScalarDoit);
 274       z_llh(Z_R1,  0, Z_R0, Rsrc);
 275       z_bre(Scalar2Char);
 276       z_tmll(Z_R1, 0xff00);
 277       z_lghi(result, 0);                   // cnt == 1, first char invalid, no chars successfully processed
 278       z_brnaz(AllDone);
 279       z_stc(Z_R1,  0, Z_R0, Rdst);
 280       z_lghi(result, 1);
 281       z_bru(AllDone);
 282 
 283       bind(Scalar2Char);
 284       z_llh(Z_R0,  2, Z_R0, Rsrc);
 285       z_tmll(Z_R1, 0xff00);
 286       z_lghi(result, 0);                   // cnt == 2, first char invalid, no chars successfully processed
 287       z_brnaz(AllDone);
 288       z_stc(Z_R1,  0, Z_R0, Rdst);
 289       z_tmll(Z_R0, 0xff00);
 290       z_lghi(result, 1);                   // cnt == 2, second char invalid, one char successfully processed
 291       z_brnaz(AllDone);
 292       z_stc(Z_R0,  1, Z_R0, Rdst);
 293       z_lghi(result, 2);
 294       z_bru(AllDone);
 295 
 296       bind(ScalarDoit);
 297     }
 298 #endif
 299 
 300     if (VM_Version::has_DistinctOpnds()) {
 301       z_srk(Rix, Rcnt, Z_R0);              // remaining # chars to compress in unrolled loop
 302     } else {
 303       z_lr(Rix, Rcnt);
 304       z_sr(Rix, Z_R0);
 305     }
 306     z_lgfr(result, Rcnt);                  // # processed characters (if all runs ok).
 307     z_brz(ScalarDone);                     // uses CC from Rix calculation
 308 
 309     bind(ScalarLoop);
 310       z_llh(Z_R1, 0, Z_R0, Rsrc);
 311       z_tmll(Z_R1, 0xff00);
 312       z_brnaz(ScalarBreak);
 313       z_stc(Z_R1, 0, Z_R0, Rdst);
 314       add2reg(Rsrc, 2);
 315       add2reg(Rdst, 1);
 316       z_brct(Rix, ScalarLoop);
 317 
 318     z_bru(ScalarDone);
 319 
 320     bind(ScalarBreak);
 321     z_sr(result, Rix);
 322 
 323     bind(ScalarDone);
 324     z_sgfr(Rdst, result);                  // restore ptr
 325     z_sgfr(Rsrc, result);                  // restore ptr, double the element count for Rsrc restore
 326     z_sgfr(Rsrc, result);
 327   }
 328   bind(AllDone);
 329 
 330   if (precise) {
 331     BLOCK_COMMENT(&quot;} encode_iso_array&quot;);
 332   } else {
 333     BLOCK_COMMENT(&quot;} string_compress&quot;);
 334   }
 335   return offset() - block_start;
 336 }
 337 
 338 // Inflate byte[] to char[].
 339 unsigned int C2_MacroAssembler::string_inflate_trot(Register src, Register dst, Register cnt, Register tmp) {
 340   int block_start = offset();
 341 
 342   BLOCK_COMMENT(&quot;string_inflate {&quot;);
 343 
 344   Register stop_char = Z_R0;
 345   Register table     = Z_R1;
 346   Register src_addr  = tmp;
 347 
 348   assert_different_registers(Z_R0, Z_R1, tmp, src, dst, cnt);
 349   assert(dst-&gt;encoding()%2 == 0, &quot;must be even reg&quot;);
 350   assert(cnt-&gt;encoding()%2 == 1, &quot;must be odd reg&quot;);
 351   assert(cnt-&gt;encoding() - dst-&gt;encoding() == 1, &quot;must be even/odd pair&quot;);
 352 
 353   StubRoutines::zarch::generate_load_trot_table_addr(this, table);  // kills Z_R0 (if ASSERT)
 354   clear_reg(stop_char);  // Stop character. Not used here, but initialized to have a defined value.
 355   lgr_if_needed(src_addr, src);
 356   z_llgfr(cnt, cnt);     // # src characters, must be a positive simm32.
 357 
 358   translate_ot(dst, src_addr, /* mask = */ 0x0001);
 359 
 360   BLOCK_COMMENT(&quot;} string_inflate&quot;);
 361 
 362   return offset() - block_start;
 363 }
 364 
 365 // Inflate byte[] to char[].
 366 //   Restores: src, dst
 367 //   Uses:     cnt
 368 //   Kills:    tmp, Z_R0, Z_R1.
 369 // Note:
 370 //   cnt is signed int. Do not rely on high word!
 371 //       counts # characters, not bytes.
 372 unsigned int C2_MacroAssembler::string_inflate(Register src, Register dst, Register cnt, Register tmp) {
 373   assert_different_registers(Z_R0, Z_R1, src, dst, cnt, tmp);
 374 
 375   BLOCK_COMMENT(&quot;string_inflate {&quot;);
 376   int block_start = offset();
 377 
 378   Register   Rcnt = cnt;   // # characters (src: bytes, dst: char (2-byte)), remaining after current loop.
 379   Register   Rix  = tmp;   // loop index
 380   Register   Rsrc = src;   // addr(src array)
 381   Register   Rdst = dst;   // addr(dst array)
 382   Label      ScalarShortcut, AllDone;
 383 
 384 #if 0  // Sacrifice shortcuts for code compactness
 385   {
 386     //---&lt;  shortcuts for short strings (very frequent)   &gt;---
 387     Label   skipShortcut, skip4Shortcut;
 388     z_ltr(Rcnt, Rcnt);                     // absolutely nothing to do for strings of len == 0.
 389     z_brz(AllDone);
 390     clear_reg(Z_R0);                       // make sure registers are properly initialized.
 391     clear_reg(Z_R1);
 392     z_chi(Rcnt, 4);
 393     z_brne(skip4Shortcut);                 // 4 characters are very frequent
 394       z_icm(Z_R0, 5,    0, Rsrc);          // Treat exactly 4 characters specially.
 395       z_icm(Z_R1, 5,    2, Rsrc);
 396       z_stm(Z_R0, Z_R1, 0, Rdst);
 397       z_bru(AllDone);
 398     bind(skip4Shortcut);
 399 
 400     z_chi(Rcnt, 8);
 401     z_brh(skipShortcut);                   // There&#39;s a lot to do...
 402     z_lgfr(Z_R0, Rcnt);                    // remaining #characters (&lt;= 8). Precond for scalar loop.
 403                                            // This does not destroy the &quot;register cleared&quot; state of Z_R0.
 404     z_brl(ScalarShortcut);                 // Just a few characters
 405       z_icmh(Z_R0, 5, 0, Rsrc);            // Treat exactly 8 characters specially.
 406       z_icmh(Z_R1, 5, 4, Rsrc);
 407       z_icm(Z_R0,  5, 2, Rsrc);
 408       z_icm(Z_R1,  5, 6, Rsrc);
 409       z_stmg(Z_R0, Z_R1, 0, Rdst);
 410       z_bru(AllDone);
 411     bind(skipShortcut);
 412   }
 413 #endif
 414   clear_reg(Z_R0);                         // make sure register is properly initialized.
 415 
 416   if (VM_Version::has_VectorFacility()) {
 417     const int  min_vcnt     = 32;          // Minimum #characters required to use vector instructions.
 418                                            // Otherwise just do nothing in vector mode.
 419                                            // Must be multiple of vector register length (16 bytes = 128 bits).
 420     const int  log_min_vcnt = exact_log2(min_vcnt);
 421     Label      VectorLoop, VectorDone;
 422 
 423     assert(VM_Version::has_DistinctOpnds(), &quot;Assumption when has_VectorFacility()&quot;);
 424     z_srak(Rix, Rcnt, log_min_vcnt);       // calculate # vector loop iterations
 425     z_brz(VectorDone);                     // skip if none
 426 
 427     z_sllg(Z_R0, Rix, log_min_vcnt);       // remember #chars that will be processed by vector loop
 428 
 429     bind(VectorLoop);
 430       z_vlm(Z_V20, Z_V21, 0, Rsrc);        // get next 32 characters (single-byte)
 431       add2reg(Rsrc, min_vcnt);
 432 
 433       z_vuplhb(Z_V22, Z_V20);              // V2 &lt;- (expand) V0(high)
 434       z_vupllb(Z_V23, Z_V20);              // V3 &lt;- (expand) V0(low)
 435       z_vuplhb(Z_V24, Z_V21);              // V4 &lt;- (expand) V1(high)
 436       z_vupllb(Z_V25, Z_V21);              // V5 &lt;- (expand) V1(low)
 437       z_vstm(Z_V22, Z_V25, 0, Rdst);       // store next 32 bytes
 438       add2reg(Rdst, min_vcnt*2);
 439 
 440       z_brct(Rix, VectorLoop);
 441 
 442     bind(VectorDone);
 443   }
 444 
 445   const int  min_cnt     =  8;             // Minimum #characters required to use unrolled scalar loop.
 446                                            // Otherwise just do nothing in unrolled scalar mode.
 447                                            // Must be multiple of 8.
 448   {
 449     const int  log_min_cnt = exact_log2(min_cnt);
 450     Label      UnrolledLoop, UnrolledDone;
 451 
 452 
 453     if (VM_Version::has_DistinctOpnds()) {
 454       z_srk(Rix, Rcnt, Z_R0);              // remaining # chars to process in unrolled loop
 455     } else {
 456       z_lr(Rix, Rcnt);
 457       z_sr(Rix, Z_R0);
 458     }
 459     z_sra(Rix, log_min_cnt);               // unrolled loop count
 460     z_brz(UnrolledDone);
 461 
 462     clear_reg(Z_R0);
 463     clear_reg(Z_R1);
 464 
 465     bind(UnrolledLoop);
 466       z_icmh(Z_R0, 5, 0, Rsrc);
 467       z_icmh(Z_R1, 5, 4, Rsrc);
 468       z_icm(Z_R0,  5, 2, Rsrc);
 469       z_icm(Z_R1,  5, 6, Rsrc);
 470       add2reg(Rsrc, min_cnt);
 471 
 472       z_stmg(Z_R0, Z_R1, 0, Rdst);
 473 
 474       add2reg(Rdst, min_cnt*2);
 475       z_brct(Rix, UnrolledLoop);
 476 
 477     bind(UnrolledDone);
 478     z_lgfr(Z_R0, Rcnt);                    // # chars left over after unrolled loop.
 479     z_nilf(Z_R0, min_cnt-1);
 480     z_brnz(ScalarShortcut);                // if zero, there is nothing left to do for scalar loop.
 481                                            // Rix == 0 in all cases.
 482     z_sgfr(Z_R0, Rcnt);                    // negative # characters the ptrs have been advanced previously.
 483     z_agr(Rdst, Z_R0);                     // restore ptr, double the element count for Rdst restore.
 484     z_agr(Rdst, Z_R0);
 485     z_agr(Rsrc, Z_R0);                     // restore ptr.
 486     z_bru(AllDone);
 487   }
 488 
 489   {
 490     bind(ScalarShortcut);
 491     // Z_R0 must contain remaining # characters as 64-bit signed int here.
 492     //      register contents is preserved over scalar processing (for register fixup).
 493 
 494 #if 0  // Sacrifice shortcuts for code compactness
 495     {
 496       Label      ScalarDefault;
 497       z_chi(Rcnt, 2);
 498       z_brh(ScalarDefault);
 499       z_llc(Z_R0,  0, Z_R0, Rsrc);     // 6 bytes
 500       z_sth(Z_R0,  0, Z_R0, Rdst);     // 4 bytes
 501       z_brl(AllDone);
 502       z_llc(Z_R0,  1, Z_R0, Rsrc);     // 6 bytes
 503       z_sth(Z_R0,  2, Z_R0, Rdst);     // 4 bytes
 504       z_bru(AllDone);
 505       bind(ScalarDefault);
 506     }
 507 #endif
 508 
 509     Label   CodeTable;
 510     // Some comments on Rix calculation:
 511     //  - Rcnt is small, therefore no bits shifted out of low word (sll(g) instructions).
 512     //  - high word of both Rix and Rcnt may contain garbage
 513     //  - the final lngfr takes care of that garbage, extending the sign to high word
 514     z_sllg(Rix, Z_R0, 2);                // calculate 10*Rix = (4*Rix + Rix)*2
 515     z_ar(Rix, Z_R0);
 516     z_larl(Z_R1, CodeTable);
 517     z_sll(Rix, 1);
 518     z_lngfr(Rix, Rix);      // ix range: [0..7], after inversion &amp; mult: [-(7*12)..(0*12)].
 519     z_bc(Assembler::bcondAlways, 0, Rix, Z_R1);
 520 
 521     z_llc(Z_R1,  6, Z_R0, Rsrc);  // 6 bytes
 522     z_sth(Z_R1, 12, Z_R0, Rdst);  // 4 bytes
 523 
 524     z_llc(Z_R1,  5, Z_R0, Rsrc);
 525     z_sth(Z_R1, 10, Z_R0, Rdst);
 526 
 527     z_llc(Z_R1,  4, Z_R0, Rsrc);
 528     z_sth(Z_R1,  8, Z_R0, Rdst);
 529 
 530     z_llc(Z_R1,  3, Z_R0, Rsrc);
 531     z_sth(Z_R1,  6, Z_R0, Rdst);
 532 
 533     z_llc(Z_R1,  2, Z_R0, Rsrc);
 534     z_sth(Z_R1,  4, Z_R0, Rdst);
 535 
 536     z_llc(Z_R1,  1, Z_R0, Rsrc);
 537     z_sth(Z_R1,  2, Z_R0, Rdst);
 538 
 539     z_llc(Z_R1,  0, Z_R0, Rsrc);
 540     z_sth(Z_R1,  0, Z_R0, Rdst);
 541     bind(CodeTable);
 542 
 543     z_chi(Rcnt, 8);                        // no fixup for small strings. Rdst, Rsrc were not modified.
 544     z_brl(AllDone);
 545 
 546     z_sgfr(Z_R0, Rcnt);                    // # characters the ptrs have been advanced previously.
 547     z_agr(Rdst, Z_R0);                     // restore ptr, double the element count for Rdst restore.
 548     z_agr(Rdst, Z_R0);
 549     z_agr(Rsrc, Z_R0);                     // restore ptr.
 550   }
 551   bind(AllDone);
 552 
 553   BLOCK_COMMENT(&quot;} string_inflate&quot;);
 554   return offset() - block_start;
 555 }
 556 
 557 // Inflate byte[] to char[], length known at compile time.
 558 //   Restores: src, dst
 559 //   Kills:    tmp, Z_R0, Z_R1.
 560 // Note:
 561 //   len is signed int. Counts # characters, not bytes.
 562 unsigned int C2_MacroAssembler::string_inflate_const(Register src, Register dst, Register tmp, int len) {
 563   assert_different_registers(Z_R0, Z_R1, src, dst, tmp);
 564 
 565   BLOCK_COMMENT(&quot;string_inflate_const {&quot;);
 566   int block_start = offset();
 567 
 568   Register   Rix  = tmp;   // loop index
 569   Register   Rsrc = src;   // addr(src array)
 570   Register   Rdst = dst;   // addr(dst array)
 571   Label      ScalarShortcut, AllDone;
 572   int        nprocessed = 0;
 573   int        src_off    = 0;  // compensate for saved (optimized away) ptr advancement.
 574   int        dst_off    = 0;  // compensate for saved (optimized away) ptr advancement.
 575   bool       restore_inputs = false;
 576   bool       workreg_clear  = false;
 577 
 578   if ((len &gt;= 32) &amp;&amp; VM_Version::has_VectorFacility()) {
 579     const int  min_vcnt     = 32;          // Minimum #characters required to use vector instructions.
 580                                            // Otherwise just do nothing in vector mode.
 581                                            // Must be multiple of vector register length (16 bytes = 128 bits).
 582     const int  log_min_vcnt = exact_log2(min_vcnt);
 583     const int  iterations   = (len - nprocessed) &gt;&gt; log_min_vcnt;
 584     nprocessed             += iterations &lt;&lt; log_min_vcnt;
 585     Label      VectorLoop;
 586 
 587     if (iterations == 1) {
 588       z_vlm(Z_V20, Z_V21, 0+src_off, Rsrc);  // get next 32 characters (single-byte)
 589       z_vuplhb(Z_V22, Z_V20);                // V2 &lt;- (expand) V0(high)
 590       z_vupllb(Z_V23, Z_V20);                // V3 &lt;- (expand) V0(low)
 591       z_vuplhb(Z_V24, Z_V21);                // V4 &lt;- (expand) V1(high)
 592       z_vupllb(Z_V25, Z_V21);                // V5 &lt;- (expand) V1(low)
 593       z_vstm(Z_V22, Z_V25, 0+dst_off, Rdst); // store next 32 bytes
 594 
 595       src_off += min_vcnt;
 596       dst_off += min_vcnt*2;
 597     } else {
 598       restore_inputs = true;
 599 
 600       z_lgfi(Rix, len&gt;&gt;log_min_vcnt);
 601       bind(VectorLoop);
 602         z_vlm(Z_V20, Z_V21, 0, Rsrc);        // get next 32 characters (single-byte)
 603         add2reg(Rsrc, min_vcnt);
 604 
 605         z_vuplhb(Z_V22, Z_V20);              // V2 &lt;- (expand) V0(high)
 606         z_vupllb(Z_V23, Z_V20);              // V3 &lt;- (expand) V0(low)
 607         z_vuplhb(Z_V24, Z_V21);              // V4 &lt;- (expand) V1(high)
 608         z_vupllb(Z_V25, Z_V21);              // V5 &lt;- (expand) V1(low)
 609         z_vstm(Z_V22, Z_V25, 0, Rdst);       // store next 32 bytes
 610         add2reg(Rdst, min_vcnt*2);
 611 
 612         z_brct(Rix, VectorLoop);
 613     }
 614   }
 615 
 616   if (((len-nprocessed) &gt;= 16) &amp;&amp; VM_Version::has_VectorFacility()) {
 617     const int  min_vcnt     = 16;          // Minimum #characters required to use vector instructions.
 618                                            // Otherwise just do nothing in vector mode.
 619                                            // Must be multiple of vector register length (16 bytes = 128 bits).
 620     const int  log_min_vcnt = exact_log2(min_vcnt);
 621     const int  iterations   = (len - nprocessed) &gt;&gt; log_min_vcnt;
 622     nprocessed             += iterations &lt;&lt; log_min_vcnt;
 623     assert(iterations == 1, &quot;must be!&quot;);
 624 
 625     z_vl(Z_V20, 0+src_off, Z_R0, Rsrc);    // get next 16 characters (single-byte)
 626     z_vuplhb(Z_V22, Z_V20);                // V2 &lt;- (expand) V0(high)
 627     z_vupllb(Z_V23, Z_V20);                // V3 &lt;- (expand) V0(low)
 628     z_vstm(Z_V22, Z_V23, 0+dst_off, Rdst); // store next 32 bytes
 629 
 630     src_off += min_vcnt;
 631     dst_off += min_vcnt*2;
 632   }
 633 
 634   if ((len-nprocessed) &gt; 8) {
 635     const int  min_cnt     =  8;           // Minimum #characters required to use unrolled scalar loop.
 636                                            // Otherwise just do nothing in unrolled scalar mode.
 637                                            // Must be multiple of 8.
 638     const int  log_min_cnt = exact_log2(min_cnt);
 639     const int  iterations  = (len - nprocessed) &gt;&gt; log_min_cnt;
 640     nprocessed     += iterations &lt;&lt; log_min_cnt;
 641 
 642     //---&lt;  avoid loop overhead/ptr increment for small # iterations  &gt;---
 643     if (iterations &lt;= 2) {
 644       clear_reg(Z_R0);
 645       clear_reg(Z_R1);
 646       workreg_clear = true;
 647 
 648       z_icmh(Z_R0, 5, 0+src_off, Rsrc);
 649       z_icmh(Z_R1, 5, 4+src_off, Rsrc);
 650       z_icm(Z_R0,  5, 2+src_off, Rsrc);
 651       z_icm(Z_R1,  5, 6+src_off, Rsrc);
 652       z_stmg(Z_R0, Z_R1, 0+dst_off, Rdst);
 653 
 654       src_off += min_cnt;
 655       dst_off += min_cnt*2;
 656     }
 657 
 658     if (iterations == 2) {
 659       z_icmh(Z_R0, 5, 0+src_off, Rsrc);
 660       z_icmh(Z_R1, 5, 4+src_off, Rsrc);
 661       z_icm(Z_R0,  5, 2+src_off, Rsrc);
 662       z_icm(Z_R1,  5, 6+src_off, Rsrc);
 663       z_stmg(Z_R0, Z_R1, 0+dst_off, Rdst);
 664 
 665       src_off += min_cnt;
 666       dst_off += min_cnt*2;
 667     }
 668 
 669     if (iterations &gt; 2) {
 670       Label      UnrolledLoop;
 671       restore_inputs  = true;
 672 
 673       clear_reg(Z_R0);
 674       clear_reg(Z_R1);
 675       workreg_clear = true;
 676 
 677       z_lgfi(Rix, iterations);
 678       bind(UnrolledLoop);
 679         z_icmh(Z_R0, 5, 0, Rsrc);
 680         z_icmh(Z_R1, 5, 4, Rsrc);
 681         z_icm(Z_R0,  5, 2, Rsrc);
 682         z_icm(Z_R1,  5, 6, Rsrc);
 683         add2reg(Rsrc, min_cnt);
 684 
 685         z_stmg(Z_R0, Z_R1, 0, Rdst);
 686         add2reg(Rdst, min_cnt*2);
 687 
 688         z_brct(Rix, UnrolledLoop);
 689     }
 690   }
 691 
 692   if ((len-nprocessed) &gt; 0) {
 693     switch (len-nprocessed) {
 694       case 8:
 695         if (!workreg_clear) {
 696           clear_reg(Z_R0);
 697           clear_reg(Z_R1);
 698         }
 699         z_icmh(Z_R0, 5, 0+src_off, Rsrc);
 700         z_icmh(Z_R1, 5, 4+src_off, Rsrc);
 701         z_icm(Z_R0,  5, 2+src_off, Rsrc);
 702         z_icm(Z_R1,  5, 6+src_off, Rsrc);
 703         z_stmg(Z_R0, Z_R1, 0+dst_off, Rdst);
 704         break;
 705       case 7:
 706         if (!workreg_clear) {
 707           clear_reg(Z_R0);
 708           clear_reg(Z_R1);
 709         }
 710         clear_reg(Rix);
 711         z_icm(Z_R0,  5, 0+src_off, Rsrc);
 712         z_icm(Z_R1,  5, 2+src_off, Rsrc);
 713         z_icm(Rix,   5, 4+src_off, Rsrc);
 714         z_stm(Z_R0,  Z_R1, 0+dst_off, Rdst);
 715         z_llc(Z_R0,  6+src_off, Z_R0, Rsrc);
 716         z_st(Rix,    8+dst_off, Z_R0, Rdst);
 717         z_sth(Z_R0, 12+dst_off, Z_R0, Rdst);
 718         break;
 719       case 6:
 720         if (!workreg_clear) {
 721           clear_reg(Z_R0);
 722           clear_reg(Z_R1);
 723         }
 724         clear_reg(Rix);
 725         z_icm(Z_R0, 5, 0+src_off, Rsrc);
 726         z_icm(Z_R1, 5, 2+src_off, Rsrc);
 727         z_icm(Rix,  5, 4+src_off, Rsrc);
 728         z_stm(Z_R0, Z_R1, 0+dst_off, Rdst);
 729         z_st(Rix,   8+dst_off, Z_R0, Rdst);
 730         break;
 731       case 5:
 732         if (!workreg_clear) {
 733           clear_reg(Z_R0);
 734           clear_reg(Z_R1);
 735         }
 736         z_icm(Z_R0, 5, 0+src_off, Rsrc);
 737         z_icm(Z_R1, 5, 2+src_off, Rsrc);
 738         z_llc(Rix,  4+src_off, Z_R0, Rsrc);
 739         z_stm(Z_R0, Z_R1, 0+dst_off, Rdst);
 740         z_sth(Rix,  8+dst_off, Z_R0, Rdst);
 741         break;
 742       case 4:
 743         if (!workreg_clear) {
 744           clear_reg(Z_R0);
 745           clear_reg(Z_R1);
 746         }
 747         z_icm(Z_R0, 5, 0+src_off, Rsrc);
 748         z_icm(Z_R1, 5, 2+src_off, Rsrc);
 749         z_stm(Z_R0, Z_R1, 0+dst_off, Rdst);
 750         break;
 751       case 3:
 752         if (!workreg_clear) {
 753           clear_reg(Z_R0);
 754         }
 755         z_llc(Z_R1, 2+src_off, Z_R0, Rsrc);
 756         z_icm(Z_R0, 5, 0+src_off, Rsrc);
 757         z_sth(Z_R1, 4+dst_off, Z_R0, Rdst);
 758         z_st(Z_R0,  0+dst_off, Rdst);
 759         break;
 760       case 2:
 761         z_llc(Z_R0, 0+src_off, Z_R0, Rsrc);
 762         z_llc(Z_R1, 1+src_off, Z_R0, Rsrc);
 763         z_sth(Z_R0, 0+dst_off, Z_R0, Rdst);
 764         z_sth(Z_R1, 2+dst_off, Z_R0, Rdst);
 765         break;
 766       case 1:
 767         z_llc(Z_R0, 0+src_off, Z_R0, Rsrc);
 768         z_sth(Z_R0, 0+dst_off, Z_R0, Rdst);
 769         break;
 770       default:
 771         guarantee(false, &quot;Impossible&quot;);
 772         break;
 773     }
 774     src_off   +=  len-nprocessed;
 775     dst_off   += (len-nprocessed)*2;
 776     nprocessed = len;
 777   }
 778 
 779   //---&lt; restore modified input registers  &gt;---
 780   if ((nprocessed &gt; 0) &amp;&amp; restore_inputs) {
 781     z_agfi(Rsrc, -(nprocessed-src_off));
 782     if (nprocessed &lt; 1000000000) { // avoid int overflow
 783       z_agfi(Rdst, -(nprocessed*2-dst_off));
 784     } else {
 785       z_agfi(Rdst, -(nprocessed-dst_off));
 786       z_agfi(Rdst, -nprocessed);
 787     }
 788   }
 789 
 790   BLOCK_COMMENT(&quot;} string_inflate_const&quot;);
 791   return offset() - block_start;
 792 }
 793 
 794 // Kills src.
 795 unsigned int C2_MacroAssembler::has_negatives(Register result, Register src, Register cnt,
 796                                               Register odd_reg, Register even_reg, Register tmp) {
 797   int block_start = offset();
 798   Label Lloop1, Lloop2, Lslow, Lnotfound, Ldone;
 799   const Register addr = src, mask = tmp;
 800 
 801   BLOCK_COMMENT(&quot;has_negatives {&quot;);
 802 
 803   z_llgfr(Z_R1, cnt);      // Number of bytes to read. (Must be a positive simm32.)
 804   z_llilf(mask, 0x80808080);
 805   z_lhi(result, 1);        // Assume true.
 806   // Last possible addr for fast loop.
 807   z_lay(odd_reg, -16, Z_R1, src);
 808   z_chi(cnt, 16);
 809   z_brl(Lslow);
 810 
 811   // ind1: index, even_reg: index increment, odd_reg: index limit
 812   z_iihf(mask, 0x80808080);
 813   z_lghi(even_reg, 16);
 814 
 815   bind(Lloop1); // 16 bytes per iteration.
 816   z_lg(Z_R0, Address(addr));
 817   z_lg(Z_R1, Address(addr, 8));
 818   z_ogr(Z_R0, Z_R1);
 819   z_ngr(Z_R0, mask);
 820   z_brne(Ldone);           // If found return 1.
 821   z_brxlg(addr, even_reg, Lloop1);
 822 
 823   bind(Lslow);
 824   z_aghi(odd_reg, 16-1);   // Last possible addr for slow loop.
 825   z_lghi(even_reg, 1);
 826   z_cgr(addr, odd_reg);
 827   z_brh(Lnotfound);
 828 
 829   bind(Lloop2); // 1 byte per iteration.
 830   z_cli(Address(addr), 0x80);
 831   z_brnl(Ldone);           // If found return 1.
 832   z_brxlg(addr, even_reg, Lloop2);
 833 
 834   bind(Lnotfound);
 835   z_lhi(result, 0);
 836 
 837   bind(Ldone);
 838 
 839   BLOCK_COMMENT(&quot;} has_negatives&quot;);
 840 
 841   return offset() - block_start;
 842 }
 843 
 844 // kill: cnt1, cnt2, odd_reg, even_reg; early clobber: result
 845 unsigned int C2_MacroAssembler::string_compare(Register str1, Register str2,
 846                                                Register cnt1, Register cnt2,
 847                                                Register odd_reg, Register even_reg, Register result, int ae) {
 848   int block_start = offset();
 849 
 850   assert_different_registers(str1, cnt1, cnt2, odd_reg, even_reg, result);
 851   assert_different_registers(str2, cnt1, cnt2, odd_reg, even_reg, result);
 852 
 853   // If strings are equal up to min length, return the length difference.
 854   const Register diff = result, // Pre-set result with length difference.
 855                  min  = cnt1,   // min number of bytes
 856                  tmp  = cnt2;
 857 
 858   // Note: Making use of the fact that compareTo(a, b) == -compareTo(b, a)
 859   // we interchange str1 and str2 in the UL case and negate the result.
 860   // Like this, str1 is always latin1 encoded, except for the UU case.
 861   // In addition, we need 0 (or sign which is 0) extend when using 64 bit register.
 862   const bool used_as_LU = (ae == StrIntrinsicNode::LU || ae == StrIntrinsicNode::UL);
 863 
 864   BLOCK_COMMENT(&quot;string_compare {&quot;);
 865 
 866   if (used_as_LU) {
 867     z_srl(cnt2, 1);
 868   }
 869 
 870   // See if the lengths are different, and calculate min in cnt1.
 871   // Save diff in case we need it for a tie-breaker.
 872 
 873   // diff = cnt1 - cnt2
 874   if (VM_Version::has_DistinctOpnds()) {
 875     z_srk(diff, cnt1, cnt2);
 876   } else {
 877     z_lr(diff, cnt1);
 878     z_sr(diff, cnt2);
 879   }
 880   if (str1 != str2) {
 881     if (VM_Version::has_LoadStoreConditional()) {
 882       z_locr(min, cnt2, Assembler::bcondHigh);
 883     } else {
 884       Label Lskip;
 885       z_brl(Lskip);    // min ok if cnt1 &lt; cnt2
 886       z_lr(min, cnt2); // min = cnt2
 887       bind(Lskip);
 888     }
 889   }
 890 
 891   if (ae == StrIntrinsicNode::UU) {
 892     z_sra(diff, 1);
 893   }
 894   if (str1 != str2) {
 895     Label Ldone;
 896     if (used_as_LU) {
 897       // Loop which searches the first difference character by character.
 898       Label Lloop;
 899       const Register ind1 = Z_R1,
 900                      ind2 = min;
 901       int stride1 = 1, stride2 = 2; // See comment above.
 902 
 903       // ind1: index, even_reg: index increment, odd_reg: index limit
 904       z_llilf(ind1, (unsigned int)(-stride1));
 905       z_lhi(even_reg, stride1);
 906       add2reg(odd_reg, -stride1, min);
 907       clear_reg(ind2); // kills min
 908 
 909       bind(Lloop);
 910       z_brxh(ind1, even_reg, Ldone);
 911       z_llc(tmp, Address(str1, ind1));
 912       z_llh(Z_R0, Address(str2, ind2));
 913       z_ahi(ind2, stride2);
 914       z_sr(tmp, Z_R0);
 915       z_bre(Lloop);
 916 
 917       z_lr(result, tmp);
 918 
 919     } else {
 920       // Use clcle in fast loop (only for same encoding).
 921       z_lgr(Z_R0, str1);
 922       z_lgr(even_reg, str2);
 923       z_llgfr(Z_R1, min);
 924       z_llgfr(odd_reg, min);
 925 
 926       if (ae == StrIntrinsicNode::LL) {
 927         compare_long_ext(Z_R0, even_reg, 0);
 928       } else {
 929         compare_long_uni(Z_R0, even_reg, 0);
 930       }
 931       z_bre(Ldone);
 932       z_lgr(Z_R1, Z_R0);
 933       if (ae == StrIntrinsicNode::LL) {
 934         z_llc(Z_R0, Address(even_reg));
 935         z_llc(result, Address(Z_R1));
 936       } else {
 937         z_llh(Z_R0, Address(even_reg));
 938         z_llh(result, Address(Z_R1));
 939       }
 940       z_sr(result, Z_R0);
 941     }
 942 
 943     // Otherwise, return the difference between the first mismatched chars.
 944     bind(Ldone);
 945   }
 946 
 947   if (ae == StrIntrinsicNode::UL) {
 948     z_lcr(result, result); // Negate result (see note above).
 949   }
 950 
 951   BLOCK_COMMENT(&quot;} string_compare&quot;);
 952 
 953   return offset() - block_start;
 954 }
 955 
 956 unsigned int C2_MacroAssembler::array_equals(bool is_array_equ, Register ary1, Register ary2, Register limit,
 957                                              Register odd_reg, Register even_reg, Register result, bool is_byte) {
 958   int block_start = offset();
 959 
 960   BLOCK_COMMENT(&quot;array_equals {&quot;);
 961 
 962   assert_different_registers(ary1, limit, odd_reg, even_reg);
 963   assert_different_registers(ary2, limit, odd_reg, even_reg);
 964 
 965   Label Ldone, Ldone_true, Ldone_false, Lclcle, CLC_template;
 966   int base_offset = 0;
 967 
 968   if (ary1 != ary2) {
 969     if (is_array_equ) {
 970       base_offset = arrayOopDesc::base_offset_in_bytes(is_byte ? T_BYTE : T_CHAR);
 971 
 972       // Return true if the same array.
 973       compareU64_and_branch(ary1, ary2, Assembler::bcondEqual, Ldone_true);
 974 
 975       // Return false if one of them is NULL.
 976       compareU64_and_branch(ary1, (intptr_t)0, Assembler::bcondEqual, Ldone_false);
 977       compareU64_and_branch(ary2, (intptr_t)0, Assembler::bcondEqual, Ldone_false);
 978 
 979       // Load the lengths of arrays.
 980       z_llgf(odd_reg, Address(ary1, arrayOopDesc::length_offset_in_bytes()));
 981 
 982       // Return false if the two arrays are not equal length.
 983       z_c(odd_reg, Address(ary2, arrayOopDesc::length_offset_in_bytes()));
 984       z_brne(Ldone_false);
 985 
 986       // string len in bytes (right operand)
 987       if (!is_byte) {
 988         z_chi(odd_reg, 128);
 989         z_sll(odd_reg, 1); // preserves flags
 990         z_brh(Lclcle);
 991       } else {
 992         compareU32_and_branch(odd_reg, (intptr_t)256, Assembler::bcondHigh, Lclcle);
 993       }
 994     } else {
 995       z_llgfr(odd_reg, limit); // Need to zero-extend prior to using the value.
 996       compareU32_and_branch(limit, (intptr_t)256, Assembler::bcondHigh, Lclcle);
 997     }
 998 
 999 
1000     // Use clc instruction for up to 256 bytes.
1001     {
1002       Register str1_reg = ary1,
1003           str2_reg = ary2;
1004       if (is_array_equ) {
1005         str1_reg = Z_R1;
1006         str2_reg = even_reg;
1007         add2reg(str1_reg, base_offset, ary1); // string addr (left operand)
1008         add2reg(str2_reg, base_offset, ary2); // string addr (right operand)
1009       }
1010       z_ahi(odd_reg, -1); // Clc uses decremented limit. Also compare result to 0.
1011       z_brl(Ldone_true);
1012       // Note: We could jump to the template if equal.
1013 
1014       assert(VM_Version::has_ExecuteExtensions(), &quot;unsupported hardware&quot;);
1015       z_exrl(odd_reg, CLC_template);
1016       z_bre(Ldone_true);
1017       // fall through
1018 
1019       bind(Ldone_false);
1020       clear_reg(result);
1021       z_bru(Ldone);
1022 
1023       bind(CLC_template);
1024       z_clc(0, 0, str1_reg, 0, str2_reg);
1025     }
1026 
1027     // Use clcle instruction.
1028     {
1029       bind(Lclcle);
1030       add2reg(even_reg, base_offset, ary2); // string addr (right operand)
1031       add2reg(Z_R0, base_offset, ary1);     // string addr (left operand)
1032 
1033       z_lgr(Z_R1, odd_reg); // string len in bytes (left operand)
1034       if (is_byte) {
1035         compare_long_ext(Z_R0, even_reg, 0);
1036       } else {
1037         compare_long_uni(Z_R0, even_reg, 0);
1038       }
1039       z_lghi(result, 0); // Preserve flags.
1040       z_brne(Ldone);
1041     }
1042   }
1043   // fall through
1044 
1045   bind(Ldone_true);
1046   z_lghi(result, 1); // All characters are equal.
1047   bind(Ldone);
1048 
1049   BLOCK_COMMENT(&quot;} array_equals&quot;);
1050 
1051   return offset() - block_start;
1052 }
1053 
1054 // kill: haycnt, needlecnt, odd_reg, even_reg; early clobber: result
1055 unsigned int C2_MacroAssembler::string_indexof(Register result, Register haystack, Register haycnt,
1056                                                Register needle, Register needlecnt, int needlecntval,
1057                                                Register odd_reg, Register even_reg, int ae) {
1058   int block_start = offset();
1059 
1060   // Ensure 0&lt;needlecnt&lt;=haycnt in ideal graph as prerequisite!
1061   assert(ae != StrIntrinsicNode::LU, &quot;Invalid encoding&quot;);
1062   const int h_csize = (ae == StrIntrinsicNode::LL) ? 1 : 2;
1063   const int n_csize = (ae == StrIntrinsicNode::UU) ? 2 : 1;
1064   Label L_needle1, L_Found, L_NotFound;
1065 
1066   BLOCK_COMMENT(&quot;string_indexof {&quot;);
1067 
1068   if (needle == haystack) {
1069     z_lhi(result, 0);
1070   } else {
1071 
1072   // Load first character of needle (R0 used by search_string instructions).
1073   if (n_csize == 2) { z_llgh(Z_R0, Address(needle)); } else { z_llgc(Z_R0, Address(needle)); }
1074 
1075   // Compute last haystack addr to use if no match gets found.
1076   if (needlecnt != noreg) { // variable needlecnt
1077     z_ahi(needlecnt, -1); // Remaining characters after first one.
1078     z_sr(haycnt, needlecnt); // Compute index succeeding last element to compare.
1079     if (n_csize == 2) { z_sll(needlecnt, 1); } // In bytes.
1080   } else { // constant needlecnt
1081     assert((needlecntval &amp; 0x7fff) == needlecntval, &quot;must be positive simm16 immediate&quot;);
1082     // Compute index succeeding last element to compare.
1083     if (needlecntval != 1) { z_ahi(haycnt, 1 - needlecntval); }
1084   }
1085 
1086   z_llgfr(haycnt, haycnt); // Clear high half.
1087   z_lgr(result, haystack); // Final result will be computed from needle start pointer.
1088   if (h_csize == 2) { z_sll(haycnt, 1); } // Scale to number of bytes.
1089   z_agr(haycnt, haystack); // Point to address succeeding last element (haystack+scale*(haycnt-needlecnt+1)).
1090 
1091   if (h_csize != n_csize) {
1092     assert(ae == StrIntrinsicNode::UL, &quot;Invalid encoding&quot;);
1093 
1094     if (needlecnt != noreg || needlecntval != 1) {
1095       if (needlecnt != noreg) {
1096         compare32_and_branch(needlecnt, (intptr_t)0, Assembler::bcondEqual, L_needle1);
1097       }
1098 
1099       // Main Loop: UL version (now we have at least 2 characters).
1100       Label L_OuterLoop, L_InnerLoop, L_Skip;
1101       bind(L_OuterLoop); // Search for 1st 2 characters.
1102       z_lgr(Z_R1, haycnt);
1103       MacroAssembler::search_string_uni(Z_R1, result);
1104       z_brc(Assembler::bcondNotFound, L_NotFound);
1105       z_lgr(result, Z_R1);
1106 
1107       z_lghi(Z_R1, n_csize);
1108       z_lghi(even_reg, h_csize);
1109       bind(L_InnerLoop);
1110       z_llgc(odd_reg, Address(needle, Z_R1));
1111       z_ch(odd_reg, Address(result, even_reg));
1112       z_brne(L_Skip);
1113       if (needlecnt != noreg) { z_cr(Z_R1, needlecnt); } else { z_chi(Z_R1, needlecntval - 1); }
1114       z_brnl(L_Found);
1115       z_aghi(Z_R1, n_csize);
1116       z_aghi(even_reg, h_csize);
1117       z_bru(L_InnerLoop);
1118 
1119       bind(L_Skip);
1120       z_aghi(result, h_csize); // This is the new address we want to use for comparing.
1121       z_bru(L_OuterLoop);
1122     }
1123 
1124   } else {
1125     const intptr_t needle_bytes = (n_csize == 2) ? ((needlecntval - 1) &lt;&lt; 1) : (needlecntval - 1);
1126     Label L_clcle;
1127 
1128     if (needlecnt != noreg || (needlecntval != 1 &amp;&amp; needle_bytes &lt;= 256)) {
1129       if (needlecnt != noreg) {
1130         compare32_and_branch(needlecnt, 256, Assembler::bcondHigh, L_clcle);
1131         z_ahi(needlecnt, -1); // remaining bytes -1 (for CLC)
1132         z_brl(L_needle1);
1133       }
1134 
1135       // Main Loop: clc version (now we have at least 2 characters).
1136       Label L_OuterLoop, CLC_template;
1137       bind(L_OuterLoop); // Search for 1st 2 characters.
1138       z_lgr(Z_R1, haycnt);
1139       if (h_csize == 1) {
1140         MacroAssembler::search_string(Z_R1, result);
1141       } else {
1142         MacroAssembler::search_string_uni(Z_R1, result);
1143       }
1144       z_brc(Assembler::bcondNotFound, L_NotFound);
1145       z_lgr(result, Z_R1);
1146 
1147       if (needlecnt != noreg) {
1148         assert(VM_Version::has_ExecuteExtensions(), &quot;unsupported hardware&quot;);
1149         z_exrl(needlecnt, CLC_template);
1150       } else {
1151         z_clc(h_csize, needle_bytes -1, Z_R1, n_csize, needle);
1152       }
1153       z_bre(L_Found);
1154       z_aghi(result, h_csize); // This is the new address we want to use for comparing.
1155       z_bru(L_OuterLoop);
1156 
1157       if (needlecnt != noreg) {
1158         bind(CLC_template);
1159         z_clc(h_csize, 0, Z_R1, n_csize, needle);
1160       }
1161     }
1162 
1163     if (needlecnt != noreg || needle_bytes &gt; 256) {
1164       bind(L_clcle);
1165 
1166       // Main Loop: clcle version (now we have at least 256 bytes).
1167       Label L_OuterLoop, CLC_template;
1168       bind(L_OuterLoop); // Search for 1st 2 characters.
1169       z_lgr(Z_R1, haycnt);
1170       if (h_csize == 1) {
1171         MacroAssembler::search_string(Z_R1, result);
1172       } else {
1173         MacroAssembler::search_string_uni(Z_R1, result);
1174       }
1175       z_brc(Assembler::bcondNotFound, L_NotFound);
1176 
1177       add2reg(Z_R0, n_csize, needle);
1178       add2reg(even_reg, h_csize, Z_R1);
1179       z_lgr(result, Z_R1);
1180       if (needlecnt != noreg) {
1181         z_llgfr(Z_R1, needlecnt); // needle len in bytes (left operand)
1182         z_llgfr(odd_reg, needlecnt);
1183       } else {
1184         load_const_optimized(Z_R1, needle_bytes);
1185         if (Immediate::is_simm16(needle_bytes)) { z_lghi(odd_reg, needle_bytes); } else { z_lgr(odd_reg, Z_R1); }
1186       }
1187       if (h_csize == 1) {
1188         compare_long_ext(Z_R0, even_reg, 0);
1189       } else {
1190         compare_long_uni(Z_R0, even_reg, 0);
1191       }
1192       z_bre(L_Found);
1193 
1194       if (n_csize == 2) { z_llgh(Z_R0, Address(needle)); } else { z_llgc(Z_R0, Address(needle)); } // Reload.
1195       z_aghi(result, h_csize); // This is the new address we want to use for comparing.
1196       z_bru(L_OuterLoop);
1197     }
1198   }
1199 
1200   if (needlecnt != noreg || needlecntval == 1) {
1201     bind(L_needle1);
1202 
1203     // Single needle character version.
1204     if (h_csize == 1) {
1205       MacroAssembler::search_string(haycnt, result);
1206     } else {
1207       MacroAssembler::search_string_uni(haycnt, result);
1208     }
1209     z_lgr(result, haycnt);
1210     z_brc(Assembler::bcondFound, L_Found);
1211   }
1212 
1213   bind(L_NotFound);
1214   add2reg(result, -1, haystack); // Return -1.
1215 
1216   bind(L_Found); // Return index (or -1 in fallthrough case).
1217   z_sgr(result, haystack);
1218   if (h_csize == 2) { z_srag(result, result, exact_log2(sizeof(jchar))); }
1219   }
1220   BLOCK_COMMENT(&quot;} string_indexof&quot;);
1221 
1222   return offset() - block_start;
1223 }
1224 
1225 // early clobber: result
1226 unsigned int C2_MacroAssembler::string_indexof_char(Register result, Register haystack, Register haycnt,
1227                                                     Register needle, jchar needleChar, Register odd_reg, Register even_reg, bool is_byte) {
1228   int block_start = offset();
1229 
1230   BLOCK_COMMENT(&quot;string_indexof_char {&quot;);
1231 
1232   if (needle == haystack) {
1233     z_lhi(result, 0);
1234   } else {
1235 
1236   Label Ldone;
1237 
1238   z_llgfr(odd_reg, haycnt);  // Preset loop ctr/searchrange end.
1239   if (needle == noreg) {
1240     load_const_optimized(Z_R0, (unsigned long)needleChar);
1241   } else {
1242     if (is_byte) {
1243       z_llgcr(Z_R0, needle); // First (and only) needle char.
1244     } else {
1245       z_llghr(Z_R0, needle); // First (and only) needle char.
1246     }
1247   }
1248 
1249   if (!is_byte) {
1250     z_agr(odd_reg, odd_reg); // Calc #bytes to be processed with SRSTU.
1251   }
1252 
1253   z_lgr(even_reg, haystack); // haystack addr
1254   z_agr(odd_reg, haystack);  // First char after range end.
1255   z_lghi(result, -1);
1256 
1257   if (is_byte) {
1258     MacroAssembler::search_string(odd_reg, even_reg);
1259   } else {
1260     MacroAssembler::search_string_uni(odd_reg, even_reg);
1261   }
1262   z_brc(Assembler::bcondNotFound, Ldone);
1263   if (is_byte) {
1264     if (VM_Version::has_DistinctOpnds()) {
1265       z_sgrk(result, odd_reg, haystack);
1266     } else {
1267       z_sgr(odd_reg, haystack);
1268       z_lgr(result, odd_reg);
1269     }
1270   } else {
1271     z_slgr(odd_reg, haystack);
1272     z_srlg(result, odd_reg, exact_log2(sizeof(jchar)));
1273   }
1274 
1275   bind(Ldone);
1276   }
1277   BLOCK_COMMENT(&quot;} string_indexof_char&quot;);
1278 
1279   return offset() - block_start;
1280 }
1281 
    </pre>
  </body>
</html>
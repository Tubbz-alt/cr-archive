<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/arm/arm.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../aarch64/vm_version_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIRAssembler_arm.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/arm/arm.ad</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   99 };
  100 
  101 class HandlerImpl {
  102 
  103  public:
  104 
  105   static int emit_exception_handler(CodeBuffer &amp;cbuf);
  106   static int emit_deopt_handler(CodeBuffer&amp; cbuf);
  107 
  108   static uint size_exception_handler() {
  109     return ( 3 * 4 );
  110   }
  111 
  112 
  113   static uint size_deopt_handler() {
  114     return ( 9 * 4 );
  115   }
  116 
  117 };
  118 







  119 %}
  120 
  121 source %{
  122 #define __ _masm.
  123 
  124 static FloatRegister reg_to_FloatRegister_object(int register_encoding);
  125 static Register reg_to_register_object(int register_encoding);
  126 










  127 
  128 // ****************************************************************************
  129 
  130 // REQUIRED FUNCTIONALITY
  131 
  132 // Indicate if the safepoint node needs the polling page as an input.
  133 // Since ARM does not have absolute addressing, it does.
  134 bool SafePointNode::needs_polling_address_input() {
  135   return true;
  136 }
  137 
  138 // emit an interrupt that is caught by the debugger (for debugging compiler)
  139 void emit_break(CodeBuffer &amp;cbuf) {
<span class="line-modified">  140   MacroAssembler _masm(&amp;cbuf);</span>
  141   __ breakpoint();
  142 }
  143 
  144 #ifndef PRODUCT
  145 void MachBreakpointNode::format( PhaseRegAlloc *, outputStream *st ) const {
  146   st-&gt;print(&quot;TA&quot;);
  147 }
  148 #endif
  149 
  150 void MachBreakpointNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  151   emit_break(cbuf);
  152 }
  153 
  154 uint MachBreakpointNode::size(PhaseRegAlloc *ra_) const {
  155   return MachNode::size(ra_);
  156 }
  157 
  158 
  159 void emit_nop(CodeBuffer &amp;cbuf) {
<span class="line-modified">  160   MacroAssembler _masm(&amp;cbuf);</span>
  161   __ nop();
  162 }
  163 
  164 
  165 void emit_call_reloc(CodeBuffer &amp;cbuf, const MachCallNode *n, MachOper *m, RelocationHolder const&amp; rspec) {
  166   int ret_addr_offset0 = n-&gt;as_MachCall()-&gt;ret_addr_offset();
  167   int call_site_offset = cbuf.insts()-&gt;mark_off();
<span class="line-modified">  168   MacroAssembler _masm(&amp;cbuf);</span>
  169   __ set_inst_mark(); // needed in emit_to_interp_stub() to locate the call
  170   address target = (address)m-&gt;method();
  171   assert(n-&gt;as_MachCall()-&gt;entry_point() == target, &quot;sanity&quot;);
  172   assert(maybe_far_call(n) == !__ reachable_from_cache(target), &quot;sanity&quot;);
  173   assert(cache_reachable() == __ cache_fully_reachable(), &quot;sanity&quot;);
  174 
  175   assert(target != NULL, &quot;need real address&quot;);
  176 
  177   int ret_addr_offset = -1;
  178   if (rspec.type() == relocInfo::runtime_call_type) {
  179     __ call(target, rspec);
  180     ret_addr_offset = __ offset();
  181   } else {
  182     // scratches Rtemp
  183     ret_addr_offset = __ patchable_call(target, rspec, true);
  184   }
  185   assert(ret_addr_offset - call_site_offset == ret_addr_offset0, &quot;fix ret_addr_offset()&quot;);
  186 }
  187 
  188 //=============================================================================
  189 // REQUIRED FUNCTIONALITY for encoding
  190 void emit_lo(CodeBuffer &amp;cbuf, int val) {  }
  191 void emit_hi(CodeBuffer &amp;cbuf, int val) {  }
  192 
  193 
  194 //=============================================================================
  195 const RegMask&amp; MachConstantBaseNode::_out_RegMask = PTR_REG_mask();
  196 
<span class="line-modified">  197 int Compile::ConstantTable::calculate_table_base_offset() const {</span>
  198   int offset = -(size() / 2);
  199   // flds, fldd: 8-bit  offset multiplied by 4: +/- 1024
  200   // ldr, ldrb : 12-bit offset:                 +/- 4096
  201   if (!Assembler::is_simm10(offset)) {
  202     offset = Assembler::min_simm10();
  203   }
  204   return offset;
  205 }
  206 
  207 bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
  208 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
  209   ShouldNotReachHere();
  210 }
  211 
  212 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
  213   Compile* C = ra_-&gt;C;
<span class="line-modified">  214   Compile::ConstantTable&amp; constant_table = C-&gt;constant_table();</span>
<span class="line-modified">  215   MacroAssembler _masm(&amp;cbuf);</span>
  216 
  217   Register r = as_Register(ra_-&gt;get_encode(this));
  218   CodeSection* consts_section = __ code()-&gt;consts();
  219   int consts_size = consts_section-&gt;align_at_start(consts_section-&gt;size());
  220   assert(constant_table.size() == consts_size, &quot;must be: %d == %d&quot;, constant_table.size(), consts_size);
  221 
  222   // Materialize the constant table base.
  223   address baseaddr = consts_section-&gt;start() + -(constant_table.table_base_offset());
  224   RelocationHolder rspec = internal_word_Relocation::spec(baseaddr);
  225   __ mov_address(r, baseaddr, rspec);
  226 }
  227 
  228 uint MachConstantBaseNode::size(PhaseRegAlloc*) const {
  229   return 8;
  230 }
  231 
  232 #ifndef PRODUCT
  233 void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  234   char reg[128];
  235   ra_-&gt;dump_register(this, reg);
  236   st-&gt;print(&quot;MOV_SLOW    &amp;constanttable,%s\t! constant table base&quot;, reg);
  237 }
  238 #endif
  239 
  240 #ifndef PRODUCT
  241 void MachPrologNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
  242   Compile* C = ra_-&gt;C;
  243 
  244   for (int i = 0; i &lt; OptoPrologueNops; i++) {
  245     st-&gt;print_cr(&quot;NOP&quot;); st-&gt;print(&quot;\t&quot;);
  246   }
  247 
<span class="line-modified">  248   size_t framesize = C-&gt;frame_size_in_bytes();</span>
  249   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
<span class="line-modified">  250   int bangsize = C-&gt;bang_size_in_bytes();</span>
  251   // Remove two words for return addr and rbp,
  252   framesize -= 2*wordSize;
  253   bangsize -= 2*wordSize;
  254 
  255   // Calls to C2R adapters often do not accept exceptional returns.
  256   // We require that their callers must bang for them.  But be careful, because
  257   // some VM calls (such as call site linkage) can use several kilobytes of
  258   // stack.  But the stack safety zone should account for that.
  259   // See bugs 4446381, 4468289, 4497237.
<span class="line-modified">  260   if (C-&gt;need_stack_bang(bangsize)) {</span>
  261     st-&gt;print_cr(&quot;! stack bang (%d bytes)&quot;, bangsize); st-&gt;print(&quot;\t&quot;);
  262   }
  263   st-&gt;print_cr(&quot;PUSH   R_FP|R_LR_LR&quot;); st-&gt;print(&quot;\t&quot;);
  264   if (framesize != 0) {
  265     st-&gt;print   (&quot;SUB    R_SP, R_SP, &quot; SIZE_FORMAT,framesize);
  266   }
  267 }
  268 #endif
  269 
  270 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  271   Compile* C = ra_-&gt;C;
<span class="line-modified">  272   MacroAssembler _masm(&amp;cbuf);</span>
  273 
  274   for (int i = 0; i &lt; OptoPrologueNops; i++) {
  275     __ nop();
  276   }
  277 
<span class="line-modified">  278   size_t framesize = C-&gt;frame_size_in_bytes();</span>
  279   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
<span class="line-modified">  280   int bangsize = C-&gt;bang_size_in_bytes();</span>
  281   // Remove two words for return addr and fp,
  282   framesize -= 2*wordSize;
  283   bangsize -= 2*wordSize;
  284 
  285   // Calls to C2R adapters often do not accept exceptional returns.
  286   // We require that their callers must bang for them.  But be careful, because
  287   // some VM calls (such as call site linkage) can use several kilobytes of
  288   // stack.  But the stack safety zone should account for that.
  289   // See bugs 4446381, 4468289, 4497237.
<span class="line-modified">  290   if (C-&gt;need_stack_bang(bangsize)) {</span>
  291     __ arm_stack_overflow_check(bangsize, Rtemp);
  292   }
  293 
  294   __ raw_push(FP, LR);
  295   if (framesize != 0) {
  296     __ sub_slow(SP, SP, framesize);
  297   }
  298 
  299   // offset from scratch buffer is not valid
  300   if (strcmp(cbuf.name(), &quot;Compile::Fill_buffer&quot;) == 0) {
<span class="line-modified">  301     C-&gt;set_frame_complete( __ offset() );</span>
  302   }
  303 
  304   if (C-&gt;has_mach_constant_base_node()) {
  305     // NOTE: We set the table base offset here because users might be
  306     // emitted before MachConstantBaseNode.
<span class="line-modified">  307     Compile::ConstantTable&amp; constant_table = C-&gt;constant_table();</span>
  308     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
  309   }
  310 }
  311 
  312 uint MachPrologNode::size(PhaseRegAlloc *ra_) const {
  313   return MachNode::size(ra_);
  314 }
  315 
  316 int MachPrologNode::reloc() const {
  317   return 10; // a large enough number
  318 }
  319 
  320 //=============================================================================
  321 #ifndef PRODUCT
  322 void MachEpilogNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
  323   Compile* C = ra_-&gt;C;
  324 
<span class="line-modified">  325   size_t framesize = C-&gt;frame_size_in_bytes();</span>
  326   framesize -= 2*wordSize;
  327 
  328   if (framesize != 0) {
  329     st-&gt;print(&quot;ADD    R_SP, R_SP, &quot; SIZE_FORMAT &quot;\n\t&quot;,framesize);
  330   }
  331   st-&gt;print(&quot;POP    R_FP|R_LR_LR&quot;);
  332 
  333   if (do_polling() &amp;&amp; ra_-&gt;C-&gt;is_method_compilation()) {
  334     st-&gt;print(&quot;\n\t&quot;);
  335     st-&gt;print(&quot;MOV    Rtemp, #PollAddr\t! Load Polling address\n\t&quot;);
  336     st-&gt;print(&quot;LDR    Rtemp,[Rtemp]\t!Poll for Safepointing&quot;);
  337   }
  338 }
  339 #endif
  340 
  341 void MachEpilogNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<span class="line-modified">  342   MacroAssembler _masm(&amp;cbuf);</span>
  343   Compile* C = ra_-&gt;C;
  344 
<span class="line-modified">  345   size_t framesize = C-&gt;frame_size_in_bytes();</span>
  346   framesize -= 2*wordSize;
  347   if (framesize != 0) {
  348     __ add_slow(SP, SP, framesize);
  349   }
  350   __ raw_pop(FP, LR);
  351 
  352   // If this does safepoint polling, then do it here
  353   if (do_polling() &amp;&amp; ra_-&gt;C-&gt;is_method_compilation()) {
  354     __ read_polling_page(Rtemp, relocInfo::poll_return_type);
  355   }
  356 }
  357 
  358 uint MachEpilogNode::size(PhaseRegAlloc *ra_) const {
  359   return MachNode::size(ra_);
  360 }
  361 
  362 int MachEpilogNode::reloc() const {
  363   return 16; // a large enough number
  364 }
  365 
  366 const Pipeline * MachEpilogNode::pipeline() const {
  367   return MachNode::pipeline_class();
  368 }
  369 
<span class="line-removed">  370 int MachEpilogNode::safepoint_offset() const {</span>
<span class="line-removed">  371   assert( do_polling(), &quot;no return for this epilog node&quot;);</span>
<span class="line-removed">  372   //  return MacroAssembler::size_of_sethi(os::get_polling_page());</span>
<span class="line-removed">  373   Unimplemented();</span>
<span class="line-removed">  374   return 0;</span>
<span class="line-removed">  375 }</span>
<span class="line-removed">  376 </span>
  377 //=============================================================================
  378 
  379 // Figure out which register class each belongs in: rc_int, rc_float, rc_stack
  380 enum RC { rc_bad, rc_int, rc_float, rc_stack };
  381 static enum RC rc_class( OptoReg::Name reg ) {
  382   if (!OptoReg::is_valid(reg)) return rc_bad;
  383   if (OptoReg::is_stack(reg)) return rc_stack;
  384   VMReg r = OptoReg::as_VMReg(reg);
  385   if (r-&gt;is_Register()) return rc_int;
  386   assert(r-&gt;is_FloatRegister(), &quot;must be&quot;);
  387   return rc_float;
  388 }
  389 
  390 static inline bool is_iRegLd_memhd(OptoReg::Name src_first, OptoReg::Name src_second, int offset) {
  391   int rlo = Matcher::_regEncode[src_first];
  392   int rhi = Matcher::_regEncode[src_second];
  393   if (!((rlo&amp;1)==0 &amp;&amp; (rlo+1 == rhi))) {
  394     tty-&gt;print_cr(&quot;CAUGHT BAD LDRD/STRD&quot;);
  395   }
  396   return (rlo&amp;1)==0 &amp;&amp; (rlo+1 == rhi) &amp;&amp; is_memoryHD(offset);
</pre>
<hr />
<pre>
  412   enum RC dst_first_rc = rc_class(dst_first);
  413 
  414   assert( OptoReg::is_valid(src_first) &amp;&amp; OptoReg::is_valid(dst_first), &quot;must move at least 1 register&quot; );
  415 
  416   // Generate spill code!
  417   int size = 0;
  418 
  419   if (src_first == dst_first &amp;&amp; src_second == dst_second)
  420     return size;            // Self copy, no move
  421 
  422 #ifdef TODO
  423   if (bottom_type()-&gt;isa_vect() != NULL) {
  424   }
  425 #endif
  426 
  427   // Shared code does not expect instruction set capability based bailouts here.
  428   // Handle offset unreachable bailout with minimal change in shared code.
  429   // Bailout only for real instruction emit.
  430   // This requires a single comment change in shared code. ( see output.cpp &quot;Normal&quot; instruction case )
  431 
<span class="line-modified">  432   MacroAssembler _masm(cbuf);</span>
  433 
  434   // --------------------------------------
  435   // Check for mem-mem move.  Load into unused float registers and fall into
  436   // the float-store case.
  437   if (src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_stack) {
  438     int offset = ra_-&gt;reg2offset(src_first);
  439     if (cbuf &amp;&amp; !is_memoryfp(offset)) {
  440       ra_-&gt;C-&gt;record_method_not_compilable(&quot;unable to handle large constant offsets&quot;);
  441       return 0;
  442     } else {
  443       if (src_second_rc != rc_bad) {
  444         assert((src_first&amp;1)==0 &amp;&amp; src_first+1 == src_second, &quot;pair of registers must be aligned/contiguous&quot;);
  445         src_first     = OptoReg::Name(R_mem_copy_lo_num);
  446         src_second    = OptoReg::Name(R_mem_copy_hi_num);
  447         src_first_rc  = rc_float;
  448         src_second_rc = rc_float;
  449         if (cbuf) {
  450           __ ldr_double(Rmemcopy, Address(SP, offset));
  451         } else if (!do_size) {
  452           st-&gt;print(LDR_DOUBLE &quot;   R_%s,[R_SP + #%d]\t! spill&quot;,OptoReg::regname(src_first),offset);
</pre>
<hr />
<pre>
  773   implementation( NULL, ra_, false, st );
  774 }
  775 #endif
  776 
  777 void MachSpillCopyNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  778   implementation( &amp;cbuf, ra_, false, NULL );
  779 }
  780 
  781 uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
  782   return implementation( NULL, ra_, true, NULL );
  783 }
  784 
  785 //=============================================================================
  786 #ifndef PRODUCT
  787 void MachNopNode::format( PhaseRegAlloc *, outputStream *st ) const {
  788   st-&gt;print(&quot;NOP \t# %d bytes pad for loops and calls&quot;, 4 * _count);
  789 }
  790 #endif
  791 
  792 void MachNopNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc * ) const {
<span class="line-modified">  793   MacroAssembler _masm(&amp;cbuf);</span>
  794   for(int i = 0; i &lt; _count; i += 1) {
  795     __ nop();
  796   }
  797 }
  798 
  799 uint MachNopNode::size(PhaseRegAlloc *ra_) const {
  800   return 4 * _count;
  801 }
  802 
  803 
  804 //=============================================================================
  805 #ifndef PRODUCT
  806 void BoxLockNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
  807   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
  808   int reg = ra_-&gt;get_reg_first(this);
  809   st-&gt;print(&quot;ADD    %s,R_SP+#%d&quot;,Matcher::regName[reg], offset);
  810 }
  811 #endif
  812 
  813 void BoxLockNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<span class="line-modified">  814   MacroAssembler _masm(&amp;cbuf);</span>
  815   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
  816   int reg = ra_-&gt;get_encode(this);
  817   Register dst = reg_to_register_object(reg);
  818 
  819   if (is_aimm(offset)) {
  820     __ add(dst, SP, offset);
  821   } else {
  822     __ mov_slow(dst, offset);
  823     __ add(dst, SP, dst);
  824   }
  825 }
  826 
  827 uint BoxLockNode::size(PhaseRegAlloc *ra_) const {
  828   // BoxLockNode is not a MachNode, so we can&#39;t just call MachNode::size(ra_)
  829   assert(ra_ == ra_-&gt;C-&gt;regalloc(), &quot;sanity&quot;);
<span class="line-modified">  830   return ra_-&gt;C-&gt;scratch_emit_size(this);</span>
  831 }
  832 
  833 //=============================================================================
  834 #ifndef PRODUCT
  835 #define R_RTEMP &quot;R_R12&quot;
  836 void MachUEPNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
  837   st-&gt;print_cr(&quot;\nUEP:&quot;);
  838   if (UseCompressedClassPointers) {
  839     st-&gt;print_cr(&quot;\tLDR_w &quot; R_RTEMP &quot;,[R_R0 + oopDesc::klass_offset_in_bytes]\t! Inline cache check&quot;);
  840     st-&gt;print_cr(&quot;\tdecode_klass &quot; R_RTEMP);
  841   } else {
  842     st-&gt;print_cr(&quot;\tLDR   &quot; R_RTEMP &quot;,[R_R0 + oopDesc::klass_offset_in_bytes]\t! Inline cache check&quot;);
  843   }
  844   st-&gt;print_cr(&quot;\tCMP   &quot; R_RTEMP &quot;,R_R8&quot; );
  845   st-&gt;print   (&quot;\tB.NE  SharedRuntime::handle_ic_miss_stub&quot;);
  846 }
  847 #endif
  848 
  849 void MachUEPNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<span class="line-modified">  850   MacroAssembler _masm(&amp;cbuf);</span>
  851   Register iCache  = reg_to_register_object(Matcher::inline_cache_reg_encode());
  852   assert(iCache == Ricklass, &quot;should be&quot;);
  853   Register receiver = R0;
  854 
  855   __ load_klass(Rtemp, receiver);
  856   __ cmp(Rtemp, iCache);
  857   __ jump(SharedRuntime::get_ic_miss_stub(), relocInfo::runtime_call_type, noreg, ne);
  858 }
  859 
  860 uint MachUEPNode::size(PhaseRegAlloc *ra_) const {
  861   return MachNode::size(ra_);
  862 }
  863 
  864 
  865 //=============================================================================
  866 
  867 // Emit exception handler code.
  868 int HandlerImpl::emit_exception_handler(CodeBuffer&amp; cbuf) {
<span class="line-modified">  869   MacroAssembler _masm(&amp;cbuf);</span>
  870 
  871   address base = __ start_a_stub(size_exception_handler());
  872   if (base == NULL) {
  873     ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
  874     return 0;  // CodeBuffer::expand failed
  875   }
  876 
  877   int offset = __ offset();
  878 
  879   // OK to trash LR, because exception blob will kill it
  880   __ jump(OptoRuntime::exception_blob()-&gt;entry_point(), relocInfo::runtime_call_type, LR_tmp);
  881 
  882   assert(__ offset() - offset &lt;= (int) size_exception_handler(), &quot;overflow&quot;);
  883 
  884   __ end_a_stub();
  885 
  886   return offset;
  887 }
  888 
  889 int HandlerImpl::emit_deopt_handler(CodeBuffer&amp; cbuf) {
  890   // Can&#39;t use any of the current frame&#39;s registers as we may have deopted
  891   // at a poll and everything can be live.
<span class="line-modified">  892   MacroAssembler _masm(&amp;cbuf);</span>
  893 
  894   address base = __ start_a_stub(size_deopt_handler());
  895   if (base == NULL) {
  896     ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
  897     return 0;  // CodeBuffer::expand failed
  898   }
  899 
  900   int offset = __ offset();
  901   address deopt_pc = __ pc();
  902 
  903   __ sub(SP, SP, wordSize); // make room for saved PC
  904   __ push(LR); // save LR that may be live when we get here
  905   __ mov_relative_address(LR, deopt_pc);
  906   __ str(LR, Address(SP, wordSize)); // save deopt PC
  907   __ pop(LR); // restore LR
  908   __ jump(SharedRuntime::deopt_blob()-&gt;unpack(), relocInfo::runtime_call_type, noreg);
  909 
  910   assert(__ offset() - offset &lt;= (int) size_deopt_handler(), &quot;overflow&quot;);
  911 
  912   __ end_a_stub();
</pre>
<hr />
<pre>
 1075 const bool Matcher::convi2l_type_required = true;
 1076 
 1077 // No support for generic vector operands.
 1078 const bool Matcher::supports_generic_vector_operands  = false;
 1079 
 1080 MachOper* Matcher::specialize_generic_vector_operand(MachOper* original_opnd, uint ideal_reg, bool is_temp) {
 1081   ShouldNotReachHere(); // generic vector operands not supported
 1082   return NULL;
 1083 }
 1084 
 1085 bool Matcher::is_generic_reg2reg_move(MachNode* m) {
 1086   ShouldNotReachHere();  // generic vector operands not supported
 1087   return false;
 1088 }
 1089 
 1090 bool Matcher::is_generic_vector(MachOper* opnd)  {
 1091   ShouldNotReachHere();  // generic vector operands not supported
 1092   return false;
 1093 }
 1094 









 1095 // Should the Matcher clone shifts on addressing modes, expecting them
 1096 // to be subsumed into complex addressing expressions or compute them
 1097 // into registers?
<span class="line-modified"> 1098 bool Matcher::clone_address_expressions(AddPNode* m, Matcher::MStack&amp; mstack, VectorSet&amp; address_visited) {</span>
 1099   return clone_base_plus_offset_address(m, mstack, address_visited);
 1100 }
 1101 
 1102 void Compile::reshape_address(AddPNode* addp) {
 1103 }
 1104 
 1105 bool Matcher::narrow_oop_use_complex_address() {
 1106   NOT_LP64(ShouldNotCallThis());
 1107   assert(UseCompressedOops, &quot;only for compressed oops code&quot;);
 1108   return false;
 1109 }
 1110 
 1111 bool Matcher::narrow_klass_use_complex_address() {
 1112   NOT_LP64(ShouldNotCallThis());
 1113   assert(UseCompressedClassPointers, &quot;only for compressed klass code&quot;);
 1114   return false;
 1115 }
 1116 
 1117 bool Matcher::const_oop_prefer_decode() {
 1118   NOT_LP64(ShouldNotCallThis());
</pre>
<hr />
<pre>
 1263       emit_call_reloc(cbuf, as_MachCall(), $meth, runtime_call_Relocation::spec());
 1264     } else {
 1265       int method_index = resolved_method_index(cbuf);
 1266       RelocationHolder rspec = _optimized_virtual ? opt_virtual_call_Relocation::spec(method_index)
 1267                                                   : static_call_Relocation::spec(method_index);
 1268       emit_call_reloc(cbuf, as_MachCall(), $meth, rspec);
 1269 
 1270       // Emit stubs for static call.
 1271       address stub = CompiledStaticCall::emit_to_interp_stub(cbuf);
 1272       if (stub == NULL) {
 1273         ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 1274         return;
 1275       }
 1276     }
 1277   %}
 1278 
 1279   enc_class save_last_PC %{
 1280     // preserve mark
 1281     address mark = cbuf.insts()-&gt;mark();
 1282     debug_only(int off0 = cbuf.insts_size());
<span class="line-modified"> 1283     MacroAssembler _masm(&amp;cbuf);</span>
 1284     int ret_addr_offset = as_MachCall()-&gt;ret_addr_offset();
 1285     __ adr(LR, mark + ret_addr_offset);
 1286     __ str(LR, Address(Rthread, JavaThread::last_Java_pc_offset()));
 1287     debug_only(int off1 = cbuf.insts_size());
 1288     assert(off1 - off0 == 2 * Assembler::InstructionSize, &quot;correct size prediction&quot;);
 1289     // restore mark
 1290     cbuf.insts()-&gt;set_mark(mark);
 1291   %}
 1292 
 1293   enc_class preserve_SP %{
 1294     // preserve mark
 1295     address mark = cbuf.insts()-&gt;mark();
 1296     debug_only(int off0 = cbuf.insts_size());
<span class="line-modified"> 1297     MacroAssembler _masm(&amp;cbuf);</span>
 1298     // FP is preserved across all calls, even compiled calls.
 1299     // Use it to preserve SP in places where the callee might change the SP.
 1300     __ mov(Rmh_SP_save, SP);
 1301     debug_only(int off1 = cbuf.insts_size());
 1302     assert(off1 - off0 == 4, &quot;correct size prediction&quot;);
 1303     // restore mark
 1304     cbuf.insts()-&gt;set_mark(mark);
 1305   %}
 1306 
 1307   enc_class restore_SP %{
<span class="line-modified"> 1308     MacroAssembler _masm(&amp;cbuf);</span>
 1309     __ mov(SP, Rmh_SP_save);
 1310   %}
 1311 
 1312   enc_class Java_Dynamic_Call (method meth) %{
<span class="line-modified"> 1313     MacroAssembler _masm(&amp;cbuf);</span>
 1314     Register R8_ic_reg = reg_to_register_object(Matcher::inline_cache_reg_encode());
 1315     assert(R8_ic_reg == Ricklass, &quot;should be&quot;);
 1316     __ set_inst_mark();
 1317     __ movw(R8_ic_reg, ((unsigned int)Universe::non_oop_word()) &amp; 0xffff);
 1318     __ movt(R8_ic_reg, ((unsigned int)Universe::non_oop_word()) &gt;&gt; 16);
 1319     address  virtual_call_oop_addr = __ inst_mark();
 1320     // CALL to fixup routine.  Fixup routine uses ScopeDesc info to determine
 1321     // who we intended to call.
 1322     int method_index = resolved_method_index(cbuf);
 1323     __ relocate(virtual_call_Relocation::spec(virtual_call_oop_addr, method_index));
 1324     emit_call_reloc(cbuf, as_MachCall(), $meth, RelocationHolder::none);
 1325   %}
 1326 
 1327   enc_class LdReplImmI(immI src, regD dst, iRegI tmp, int cnt, int wth) %{
 1328     // FIXME: load from constant table?
 1329     // Load a constant replicated &quot;count&quot; times with width &quot;width&quot;
 1330     int count = $cnt$$constant;
 1331     int width = $wth$$constant;
 1332     assert(count*width == 4, &quot;sanity&quot;);
 1333     int val = $src$$constant;
 1334     if (width &lt; 4) {
 1335       int bit_width = width * 8;
 1336       val &amp;= (((int)1) &lt;&lt; bit_width) - 1; // mask off sign bits
 1337       for (int i = 0; i &lt; count - 1; i++) {
 1338         val |= (val &lt;&lt; bit_width);
 1339       }
 1340     }
<span class="line-modified"> 1341     MacroAssembler _masm(&amp;cbuf);</span>
 1342 
 1343     if (val == -1) {
 1344       __ mvn($tmp$$Register, 0);
 1345     } else if (val == 0) {
 1346       __ mov($tmp$$Register, 0);
 1347     } else {
 1348       __ movw($tmp$$Register, val &amp; 0xffff);
 1349       __ movt($tmp$$Register, (unsigned int)val &gt;&gt; 16);
 1350     }
 1351     __ fmdrr($dst$$FloatRegister, $tmp$$Register, $tmp$$Register);
 1352   %}
 1353 
 1354   enc_class LdReplImmF(immF src, regD dst, iRegI tmp) %{
 1355     // Replicate float con 2 times and pack into vector (8 bytes) in regD.
 1356     float fval = $src$$constant;
 1357     int val = *((int*)&amp;fval);
<span class="line-modified"> 1358     MacroAssembler _masm(&amp;cbuf);</span>
 1359 
 1360     if (val == -1) {
 1361       __ mvn($tmp$$Register, 0);
 1362     } else if (val == 0) {
 1363       __ mov($tmp$$Register, 0);
 1364     } else {
 1365       __ movw($tmp$$Register, val &amp; 0xffff);
 1366       __ movt($tmp$$Register, (unsigned int)val &gt;&gt; 16);
 1367     }
 1368     __ fmdrr($dst$$FloatRegister, $tmp$$Register, $tmp$$Register);
 1369   %}
 1370 
 1371   enc_class enc_String_Compare(R0RegP str1, R1RegP str2, R2RegI cnt1, R3RegI cnt2, iRegI result, iRegI tmp1, iRegI tmp2) %{
 1372     Label Ldone, Lloop;
<span class="line-modified"> 1373     MacroAssembler _masm(&amp;cbuf);</span>
 1374 
 1375     Register   str1_reg = $str1$$Register;
 1376     Register   str2_reg = $str2$$Register;
 1377     Register   cnt1_reg = $cnt1$$Register; // int
 1378     Register   cnt2_reg = $cnt2$$Register; // int
 1379     Register   tmp1_reg = $tmp1$$Register;
 1380     Register   tmp2_reg = $tmp2$$Register;
 1381     Register result_reg = $result$$Register;
 1382 
 1383     assert_different_registers(str1_reg, str2_reg, cnt1_reg, cnt2_reg, tmp1_reg, tmp2_reg);
 1384 
 1385     // Compute the minimum of the string lengths(str1_reg) and the
 1386     // difference of the string lengths (stack)
 1387 
 1388     // See if the lengths are different, and calculate min in str1_reg.
 1389     // Stash diff in tmp2 in case we need it for a tie-breaker.
 1390     __ subs_32(tmp2_reg, cnt1_reg, cnt2_reg);
 1391     __ mov(cnt1_reg, AsmOperand(cnt1_reg, lsl, exact_log2(sizeof(jchar)))); // scale the limit
 1392     __ mov(cnt1_reg, AsmOperand(cnt2_reg, lsl, exact_log2(sizeof(jchar))), pl); // scale the limit
 1393 
</pre>
<hr />
<pre>
 1445     __ subs(chr1_reg, chr1_reg, chr2_reg);
 1446     if (result_reg != chr1_reg) {
 1447       __ mov(result_reg, chr1_reg, ne);
 1448     }
 1449     __ b(Ldone, ne);
 1450 
 1451     __ adds(limit_reg, limit_reg, sizeof(jchar));
 1452     __ b(Lloop, ne);
 1453 
 1454     // If strings are equal up to min length, return the length difference.
 1455     if (result_reg != tmp2_reg) {
 1456       __ mov(result_reg, tmp2_reg);
 1457     }
 1458 
 1459     // Otherwise, return the difference between the first mismatched chars.
 1460     __ bind(Ldone);
 1461   %}
 1462 
 1463   enc_class enc_String_Equals(R0RegP str1, R1RegP str2, R2RegI cnt, iRegI result, iRegI tmp1, iRegI tmp2) %{
 1464     Label Lchar, Lchar_loop, Ldone, Lequal;
<span class="line-modified"> 1465     MacroAssembler _masm(&amp;cbuf);</span>
 1466 
 1467     Register   str1_reg = $str1$$Register;
 1468     Register   str2_reg = $str2$$Register;
 1469     Register    cnt_reg = $cnt$$Register; // int
 1470     Register   tmp1_reg = $tmp1$$Register;
 1471     Register   tmp2_reg = $tmp2$$Register;
 1472     Register result_reg = $result$$Register;
 1473 
 1474     assert_different_registers(str1_reg, str2_reg, cnt_reg, tmp1_reg, tmp2_reg, result_reg);
 1475 
 1476     __ cmp(str1_reg, str2_reg); //same char[] ?
 1477     __ b(Lequal, eq);
 1478 
 1479     __ cbz_32(cnt_reg, Lequal); // count == 0
 1480 
 1481     //rename registers
 1482     Register limit_reg = cnt_reg;
 1483     Register  chr1_reg = tmp1_reg;
 1484     Register  chr2_reg = tmp2_reg;
 1485 
</pre>
<hr />
<pre>
 1507     __ add(str2_reg, limit_reg, str2_reg);
 1508     __ neg(limit_reg, limit_reg); //negate count
 1509 
 1510     // Lchar_loop
 1511     __ bind(Lchar_loop);
 1512     __ ldrh(chr1_reg, Address(str1_reg, limit_reg));
 1513     __ ldrh(chr2_reg, Address(str2_reg, limit_reg));
 1514     __ cmp(chr1_reg, chr2_reg);
 1515     __ b(Ldone, ne);
 1516     __ adds(limit_reg, limit_reg, sizeof(jchar));
 1517     __ b(Lchar_loop, ne);
 1518 
 1519     __ bind(Lequal);
 1520     __ mov(result_reg, 1);  //equal
 1521 
 1522     __ bind(Ldone);
 1523   %}
 1524 
 1525   enc_class enc_Array_Equals(R0RegP ary1, R1RegP ary2, iRegI tmp1, iRegI tmp2, iRegI tmp3, iRegI result) %{
 1526     Label Ldone, Lloop, Lequal;
<span class="line-modified"> 1527     MacroAssembler _masm(&amp;cbuf);</span>
 1528 
 1529     Register   ary1_reg = $ary1$$Register;
 1530     Register   ary2_reg = $ary2$$Register;
 1531     Register   tmp1_reg = $tmp1$$Register;
 1532     Register   tmp2_reg = $tmp2$$Register;
 1533     Register   tmp3_reg = $tmp3$$Register;
 1534     Register result_reg = $result$$Register;
 1535 
 1536     assert_different_registers(ary1_reg, ary2_reg, tmp1_reg, tmp2_reg, tmp3_reg, result_reg);
 1537 
 1538     int length_offset  = arrayOopDesc::length_offset_in_bytes();
 1539     int base_offset    = arrayOopDesc::base_offset_in_bytes(T_CHAR);
 1540 
 1541     // return true if the same array
 1542     __ teq(ary1_reg, ary2_reg);
 1543     __ mov(result_reg, 1, eq);
 1544     __ b(Ldone, eq); // equal
 1545 
 1546     __ tst(ary1_reg, ary1_reg);
 1547     __ mov(result_reg, 0, eq);
</pre>
<hr />
<pre>
 2004 
 2005 // Pointer Immediate: 32 or 64-bit
 2006 operand immP() %{
 2007   match(ConP);
 2008 
 2009   op_cost(5);
 2010   // formats are generated automatically for constants and base registers
 2011   format %{ %}
 2012   interface(CONST_INTER);
 2013 %}
 2014 
 2015 operand immP0() %{
 2016   predicate(n-&gt;get_ptr() == 0);
 2017   match(ConP);
 2018   op_cost(0);
 2019 
 2020   format %{ %}
 2021   interface(CONST_INTER);
 2022 %}
 2023 
<span class="line-removed"> 2024 operand immP_poll() %{</span>
<span class="line-removed"> 2025   predicate(n-&gt;get_ptr() != 0 &amp;&amp; n-&gt;get_ptr() == (intptr_t)os::get_polling_page());</span>
<span class="line-removed"> 2026   match(ConP);</span>
<span class="line-removed"> 2027 </span>
<span class="line-removed"> 2028   // formats are generated automatically for constants and base registers</span>
<span class="line-removed"> 2029   format %{ %}</span>
<span class="line-removed"> 2030   interface(CONST_INTER);</span>
<span class="line-removed"> 2031 %}</span>
<span class="line-removed"> 2032 </span>
 2033 // Pointer Immediate
 2034 operand immN()
 2035 %{
 2036   match(ConN);
 2037 
 2038   op_cost(10);
 2039   format %{ %}
 2040   interface(CONST_INTER);
 2041 %}
 2042 
 2043 operand immNKlass()
 2044 %{
 2045   match(ConNKlass);
 2046 
 2047   op_cost(10);
 2048   format %{ %}
 2049   interface(CONST_INTER);
 2050 %}
 2051 
 2052 // NULL Pointer Immediate
</pre>
<hr />
<pre>
 3081 pipe_class ialu_hi_lo_reg(iRegI dst, immI src) %{
 3082     instruction_count(1); multiple_bundles;
 3083     dst   : E(write)+1;
 3084     IALU  : R(2);
 3085 %}
 3086 
 3087 // Long Constant
 3088 pipe_class loadConL( iRegL dst, immL src ) %{
 3089     instruction_count(2); multiple_bundles;
 3090     dst   : E(write)+1;
 3091     IALU  : R(2);
 3092     IALU  : R(2);
 3093 %}
 3094 
 3095 // Pointer Constant
 3096 pipe_class loadConP( iRegP dst, immP src ) %{
 3097     instruction_count(0); multiple_bundles;
 3098     fixed_latency(6);
 3099 %}
 3100 
<span class="line-removed"> 3101 // Polling Address</span>
<span class="line-removed"> 3102 pipe_class loadConP_poll( iRegP dst, immP_poll src ) %{</span>
<span class="line-removed"> 3103     dst   : E(write);</span>
<span class="line-removed"> 3104     IALU  : R;</span>
<span class="line-removed"> 3105 %}</span>
<span class="line-removed"> 3106 </span>
 3107 // Long Constant small
 3108 pipe_class loadConLlo( iRegL dst, immL src ) %{
 3109     instruction_count(2);
 3110     dst   : E(write);
 3111     IALU  : R;
 3112     IALU  : R;
 3113 %}
 3114 
 3115 // [PHH] This is wrong for 64-bit.  See LdImmF/D.
 3116 pipe_class loadConFD(regF dst, immF src, iRegP tmp) %{
 3117     instruction_count(1); multiple_bundles;
 3118     src   : R(read);
 3119     dst   : M(write)+1;
 3120     IALU  : R;
 3121     MS    : E;
 3122 %}
 3123 
 3124 // Integer ALU nop operation
 3125 pipe_class ialu_nop() %{
 3126     single_instruction;
</pre>
<hr />
<pre>
 4269 
 4270 instruct loadConP(iRegP dst, immP src) %{
 4271   match(Set dst src);
 4272   ins_cost(DEFAULT_COST * 3/2);
 4273   format %{ &quot;MOV_SLOW    $dst,$src\t!ptr&quot; %}
 4274   ins_encode %{
 4275     relocInfo::relocType constant_reloc = _opnds[1]-&gt;constant_reloc();
 4276     intptr_t val = $src$$constant;
 4277     if (constant_reloc == relocInfo::oop_type) {
 4278       __ mov_oop($dst$$Register, (jobject)val);
 4279     } else if (constant_reloc == relocInfo::metadata_type) {
 4280       __ mov_metadata($dst$$Register, (Metadata*)val);
 4281     } else {
 4282       __ mov_slow($dst$$Register, val);
 4283     }
 4284   %}
 4285   ins_pipe(loadConP);
 4286 %}
 4287 
 4288 
<span class="line-removed"> 4289 instruct loadConP_poll(iRegP dst, immP_poll src) %{</span>
<span class="line-removed"> 4290   match(Set dst src);</span>
<span class="line-removed"> 4291   ins_cost(DEFAULT_COST);</span>
<span class="line-removed"> 4292   format %{ &quot;MOV_SLOW    $dst,$src\t!ptr&quot; %}</span>
<span class="line-removed"> 4293   ins_encode %{</span>
<span class="line-removed"> 4294       __ mov_slow($dst$$Register, $src$$constant);</span>
<span class="line-removed"> 4295   %}</span>
<span class="line-removed"> 4296   ins_pipe(loadConP_poll);</span>
<span class="line-removed"> 4297 %}</span>
<span class="line-removed"> 4298 </span>
 4299 instruct loadConL(iRegL dst, immL src) %{
 4300   match(Set dst src);
 4301   ins_cost(DEFAULT_COST * 4);
 4302   format %{ &quot;MOV_SLOW   $dst.lo, $src &amp; 0x0FFFFFFFFL \t! long\n\t&quot;
 4303             &quot;MOV_SLOW   $dst.hi, $src &gt;&gt; 32&quot; %}
 4304   ins_encode %{
 4305     __ mov_slow(reg_to_register_object($dst$$reg), $src$$constant &amp; 0x0FFFFFFFFL);
 4306     __ mov_slow(reg_to_register_object($dst$$reg + 1), ((julong)($src$$constant)) &gt;&gt; 32);
 4307   %}
 4308   ins_pipe(loadConL);
 4309 %}
 4310 
 4311 instruct loadConL16( iRegL dst, immL16 src ) %{
 4312   match(Set dst src);
 4313   ins_cost(DEFAULT_COST * 2);
 4314 
 4315   size(8);
 4316   format %{ &quot;MOVW    $dst.lo, $src \n\t&quot;
 4317             &quot;MOVW    $dst.hi, 0 \n\t&quot; %}
 4318   ins_encode %{
</pre>
</td>
<td>
<hr />
<pre>
   99 };
  100 
  101 class HandlerImpl {
  102 
  103  public:
  104 
  105   static int emit_exception_handler(CodeBuffer &amp;cbuf);
  106   static int emit_deopt_handler(CodeBuffer&amp; cbuf);
  107 
  108   static uint size_exception_handler() {
  109     return ( 3 * 4 );
  110   }
  111 
  112 
  113   static uint size_deopt_handler() {
  114     return ( 9 * 4 );
  115   }
  116 
  117 };
  118 
<span class="line-added">  119 class Node::PD {</span>
<span class="line-added">  120 public:</span>
<span class="line-added">  121   enum NodeFlags {</span>
<span class="line-added">  122     _last_flag = Node::_last_flag</span>
<span class="line-added">  123   };</span>
<span class="line-added">  124 };</span>
<span class="line-added">  125 </span>
  126 %}
  127 
  128 source %{
  129 #define __ _masm.
  130 
  131 static FloatRegister reg_to_FloatRegister_object(int register_encoding);
  132 static Register reg_to_register_object(int register_encoding);
  133 
<span class="line-added">  134 void PhaseOutput::pd_perform_mach_node_analysis() {</span>
<span class="line-added">  135 }</span>
<span class="line-added">  136 </span>
<span class="line-added">  137 int MachNode::pd_alignment_required() const {</span>
<span class="line-added">  138   return 1;</span>
<span class="line-added">  139 }</span>
<span class="line-added">  140 </span>
<span class="line-added">  141 int MachNode::compute_padding(int current_offset) const {</span>
<span class="line-added">  142   return 0;</span>
<span class="line-added">  143 }</span>
  144 
  145 // ****************************************************************************
  146 
  147 // REQUIRED FUNCTIONALITY
  148 
  149 // Indicate if the safepoint node needs the polling page as an input.
  150 // Since ARM does not have absolute addressing, it does.
  151 bool SafePointNode::needs_polling_address_input() {
  152   return true;
  153 }
  154 
  155 // emit an interrupt that is caught by the debugger (for debugging compiler)
  156 void emit_break(CodeBuffer &amp;cbuf) {
<span class="line-modified">  157   C2_MacroAssembler _masm(&amp;cbuf);</span>
  158   __ breakpoint();
  159 }
  160 
  161 #ifndef PRODUCT
  162 void MachBreakpointNode::format( PhaseRegAlloc *, outputStream *st ) const {
  163   st-&gt;print(&quot;TA&quot;);
  164 }
  165 #endif
  166 
  167 void MachBreakpointNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  168   emit_break(cbuf);
  169 }
  170 
  171 uint MachBreakpointNode::size(PhaseRegAlloc *ra_) const {
  172   return MachNode::size(ra_);
  173 }
  174 
  175 
  176 void emit_nop(CodeBuffer &amp;cbuf) {
<span class="line-modified">  177   C2_MacroAssembler _masm(&amp;cbuf);</span>
  178   __ nop();
  179 }
  180 
  181 
  182 void emit_call_reloc(CodeBuffer &amp;cbuf, const MachCallNode *n, MachOper *m, RelocationHolder const&amp; rspec) {
  183   int ret_addr_offset0 = n-&gt;as_MachCall()-&gt;ret_addr_offset();
  184   int call_site_offset = cbuf.insts()-&gt;mark_off();
<span class="line-modified">  185   C2_MacroAssembler _masm(&amp;cbuf);</span>
  186   __ set_inst_mark(); // needed in emit_to_interp_stub() to locate the call
  187   address target = (address)m-&gt;method();
  188   assert(n-&gt;as_MachCall()-&gt;entry_point() == target, &quot;sanity&quot;);
  189   assert(maybe_far_call(n) == !__ reachable_from_cache(target), &quot;sanity&quot;);
  190   assert(cache_reachable() == __ cache_fully_reachable(), &quot;sanity&quot;);
  191 
  192   assert(target != NULL, &quot;need real address&quot;);
  193 
  194   int ret_addr_offset = -1;
  195   if (rspec.type() == relocInfo::runtime_call_type) {
  196     __ call(target, rspec);
  197     ret_addr_offset = __ offset();
  198   } else {
  199     // scratches Rtemp
  200     ret_addr_offset = __ patchable_call(target, rspec, true);
  201   }
  202   assert(ret_addr_offset - call_site_offset == ret_addr_offset0, &quot;fix ret_addr_offset()&quot;);
  203 }
  204 
  205 //=============================================================================
  206 // REQUIRED FUNCTIONALITY for encoding
  207 void emit_lo(CodeBuffer &amp;cbuf, int val) {  }
  208 void emit_hi(CodeBuffer &amp;cbuf, int val) {  }
  209 
  210 
  211 //=============================================================================
  212 const RegMask&amp; MachConstantBaseNode::_out_RegMask = PTR_REG_mask();
  213 
<span class="line-modified">  214 int ConstantTable::calculate_table_base_offset() const {</span>
  215   int offset = -(size() / 2);
  216   // flds, fldd: 8-bit  offset multiplied by 4: +/- 1024
  217   // ldr, ldrb : 12-bit offset:                 +/- 4096
  218   if (!Assembler::is_simm10(offset)) {
  219     offset = Assembler::min_simm10();
  220   }
  221   return offset;
  222 }
  223 
  224 bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
  225 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
  226   ShouldNotReachHere();
  227 }
  228 
  229 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
  230   Compile* C = ra_-&gt;C;
<span class="line-modified">  231   ConstantTable&amp; constant_table = C-&gt;output()-&gt;constant_table();</span>
<span class="line-modified">  232   C2_MacroAssembler _masm(&amp;cbuf);</span>
  233 
  234   Register r = as_Register(ra_-&gt;get_encode(this));
  235   CodeSection* consts_section = __ code()-&gt;consts();
  236   int consts_size = consts_section-&gt;align_at_start(consts_section-&gt;size());
  237   assert(constant_table.size() == consts_size, &quot;must be: %d == %d&quot;, constant_table.size(), consts_size);
  238 
  239   // Materialize the constant table base.
  240   address baseaddr = consts_section-&gt;start() + -(constant_table.table_base_offset());
  241   RelocationHolder rspec = internal_word_Relocation::spec(baseaddr);
  242   __ mov_address(r, baseaddr, rspec);
  243 }
  244 
  245 uint MachConstantBaseNode::size(PhaseRegAlloc*) const {
  246   return 8;
  247 }
  248 
  249 #ifndef PRODUCT
  250 void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  251   char reg[128];
  252   ra_-&gt;dump_register(this, reg);
  253   st-&gt;print(&quot;MOV_SLOW    &amp;constanttable,%s\t! constant table base&quot;, reg);
  254 }
  255 #endif
  256 
  257 #ifndef PRODUCT
  258 void MachPrologNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
  259   Compile* C = ra_-&gt;C;
  260 
  261   for (int i = 0; i &lt; OptoPrologueNops; i++) {
  262     st-&gt;print_cr(&quot;NOP&quot;); st-&gt;print(&quot;\t&quot;);
  263   }
  264 
<span class="line-modified">  265   size_t framesize = C-&gt;output()-&gt;frame_size_in_bytes();</span>
  266   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
<span class="line-modified">  267   int bangsize = C-&gt;output()-&gt;bang_size_in_bytes();</span>
  268   // Remove two words for return addr and rbp,
  269   framesize -= 2*wordSize;
  270   bangsize -= 2*wordSize;
  271 
  272   // Calls to C2R adapters often do not accept exceptional returns.
  273   // We require that their callers must bang for them.  But be careful, because
  274   // some VM calls (such as call site linkage) can use several kilobytes of
  275   // stack.  But the stack safety zone should account for that.
  276   // See bugs 4446381, 4468289, 4497237.
<span class="line-modified">  277   if (C-&gt;output()-&gt;need_stack_bang(bangsize)) {</span>
  278     st-&gt;print_cr(&quot;! stack bang (%d bytes)&quot;, bangsize); st-&gt;print(&quot;\t&quot;);
  279   }
  280   st-&gt;print_cr(&quot;PUSH   R_FP|R_LR_LR&quot;); st-&gt;print(&quot;\t&quot;);
  281   if (framesize != 0) {
  282     st-&gt;print   (&quot;SUB    R_SP, R_SP, &quot; SIZE_FORMAT,framesize);
  283   }
  284 }
  285 #endif
  286 
  287 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  288   Compile* C = ra_-&gt;C;
<span class="line-modified">  289   C2_MacroAssembler _masm(&amp;cbuf);</span>
  290 
  291   for (int i = 0; i &lt; OptoPrologueNops; i++) {
  292     __ nop();
  293   }
  294 
<span class="line-modified">  295   size_t framesize = C-&gt;output()-&gt;frame_size_in_bytes();</span>
  296   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
<span class="line-modified">  297   int bangsize = C-&gt;output()-&gt;bang_size_in_bytes();</span>
  298   // Remove two words for return addr and fp,
  299   framesize -= 2*wordSize;
  300   bangsize -= 2*wordSize;
  301 
  302   // Calls to C2R adapters often do not accept exceptional returns.
  303   // We require that their callers must bang for them.  But be careful, because
  304   // some VM calls (such as call site linkage) can use several kilobytes of
  305   // stack.  But the stack safety zone should account for that.
  306   // See bugs 4446381, 4468289, 4497237.
<span class="line-modified">  307   if (C-&gt;output()-&gt;need_stack_bang(bangsize)) {</span>
  308     __ arm_stack_overflow_check(bangsize, Rtemp);
  309   }
  310 
  311   __ raw_push(FP, LR);
  312   if (framesize != 0) {
  313     __ sub_slow(SP, SP, framesize);
  314   }
  315 
  316   // offset from scratch buffer is not valid
  317   if (strcmp(cbuf.name(), &quot;Compile::Fill_buffer&quot;) == 0) {
<span class="line-modified">  318     C-&gt;output()-&gt;set_frame_complete( __ offset() );</span>
  319   }
  320 
  321   if (C-&gt;has_mach_constant_base_node()) {
  322     // NOTE: We set the table base offset here because users might be
  323     // emitted before MachConstantBaseNode.
<span class="line-modified">  324     ConstantTable&amp; constant_table = C-&gt;output()-&gt;constant_table();</span>
  325     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
  326   }
  327 }
  328 
  329 uint MachPrologNode::size(PhaseRegAlloc *ra_) const {
  330   return MachNode::size(ra_);
  331 }
  332 
  333 int MachPrologNode::reloc() const {
  334   return 10; // a large enough number
  335 }
  336 
  337 //=============================================================================
  338 #ifndef PRODUCT
  339 void MachEpilogNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
  340   Compile* C = ra_-&gt;C;
  341 
<span class="line-modified">  342   size_t framesize = C-&gt;output()-&gt;frame_size_in_bytes();</span>
  343   framesize -= 2*wordSize;
  344 
  345   if (framesize != 0) {
  346     st-&gt;print(&quot;ADD    R_SP, R_SP, &quot; SIZE_FORMAT &quot;\n\t&quot;,framesize);
  347   }
  348   st-&gt;print(&quot;POP    R_FP|R_LR_LR&quot;);
  349 
  350   if (do_polling() &amp;&amp; ra_-&gt;C-&gt;is_method_compilation()) {
  351     st-&gt;print(&quot;\n\t&quot;);
  352     st-&gt;print(&quot;MOV    Rtemp, #PollAddr\t! Load Polling address\n\t&quot;);
  353     st-&gt;print(&quot;LDR    Rtemp,[Rtemp]\t!Poll for Safepointing&quot;);
  354   }
  355 }
  356 #endif
  357 
  358 void MachEpilogNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<span class="line-modified">  359   C2_MacroAssembler _masm(&amp;cbuf);</span>
  360   Compile* C = ra_-&gt;C;
  361 
<span class="line-modified">  362   size_t framesize = C-&gt;output()-&gt;frame_size_in_bytes();</span>
  363   framesize -= 2*wordSize;
  364   if (framesize != 0) {
  365     __ add_slow(SP, SP, framesize);
  366   }
  367   __ raw_pop(FP, LR);
  368 
  369   // If this does safepoint polling, then do it here
  370   if (do_polling() &amp;&amp; ra_-&gt;C-&gt;is_method_compilation()) {
  371     __ read_polling_page(Rtemp, relocInfo::poll_return_type);
  372   }
  373 }
  374 
  375 uint MachEpilogNode::size(PhaseRegAlloc *ra_) const {
  376   return MachNode::size(ra_);
  377 }
  378 
  379 int MachEpilogNode::reloc() const {
  380   return 16; // a large enough number
  381 }
  382 
  383 const Pipeline * MachEpilogNode::pipeline() const {
  384   return MachNode::pipeline_class();
  385 }
  386 







  387 //=============================================================================
  388 
  389 // Figure out which register class each belongs in: rc_int, rc_float, rc_stack
  390 enum RC { rc_bad, rc_int, rc_float, rc_stack };
  391 static enum RC rc_class( OptoReg::Name reg ) {
  392   if (!OptoReg::is_valid(reg)) return rc_bad;
  393   if (OptoReg::is_stack(reg)) return rc_stack;
  394   VMReg r = OptoReg::as_VMReg(reg);
  395   if (r-&gt;is_Register()) return rc_int;
  396   assert(r-&gt;is_FloatRegister(), &quot;must be&quot;);
  397   return rc_float;
  398 }
  399 
  400 static inline bool is_iRegLd_memhd(OptoReg::Name src_first, OptoReg::Name src_second, int offset) {
  401   int rlo = Matcher::_regEncode[src_first];
  402   int rhi = Matcher::_regEncode[src_second];
  403   if (!((rlo&amp;1)==0 &amp;&amp; (rlo+1 == rhi))) {
  404     tty-&gt;print_cr(&quot;CAUGHT BAD LDRD/STRD&quot;);
  405   }
  406   return (rlo&amp;1)==0 &amp;&amp; (rlo+1 == rhi) &amp;&amp; is_memoryHD(offset);
</pre>
<hr />
<pre>
  422   enum RC dst_first_rc = rc_class(dst_first);
  423 
  424   assert( OptoReg::is_valid(src_first) &amp;&amp; OptoReg::is_valid(dst_first), &quot;must move at least 1 register&quot; );
  425 
  426   // Generate spill code!
  427   int size = 0;
  428 
  429   if (src_first == dst_first &amp;&amp; src_second == dst_second)
  430     return size;            // Self copy, no move
  431 
  432 #ifdef TODO
  433   if (bottom_type()-&gt;isa_vect() != NULL) {
  434   }
  435 #endif
  436 
  437   // Shared code does not expect instruction set capability based bailouts here.
  438   // Handle offset unreachable bailout with minimal change in shared code.
  439   // Bailout only for real instruction emit.
  440   // This requires a single comment change in shared code. ( see output.cpp &quot;Normal&quot; instruction case )
  441 
<span class="line-modified">  442   C2_MacroAssembler _masm(cbuf);</span>
  443 
  444   // --------------------------------------
  445   // Check for mem-mem move.  Load into unused float registers and fall into
  446   // the float-store case.
  447   if (src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_stack) {
  448     int offset = ra_-&gt;reg2offset(src_first);
  449     if (cbuf &amp;&amp; !is_memoryfp(offset)) {
  450       ra_-&gt;C-&gt;record_method_not_compilable(&quot;unable to handle large constant offsets&quot;);
  451       return 0;
  452     } else {
  453       if (src_second_rc != rc_bad) {
  454         assert((src_first&amp;1)==0 &amp;&amp; src_first+1 == src_second, &quot;pair of registers must be aligned/contiguous&quot;);
  455         src_first     = OptoReg::Name(R_mem_copy_lo_num);
  456         src_second    = OptoReg::Name(R_mem_copy_hi_num);
  457         src_first_rc  = rc_float;
  458         src_second_rc = rc_float;
  459         if (cbuf) {
  460           __ ldr_double(Rmemcopy, Address(SP, offset));
  461         } else if (!do_size) {
  462           st-&gt;print(LDR_DOUBLE &quot;   R_%s,[R_SP + #%d]\t! spill&quot;,OptoReg::regname(src_first),offset);
</pre>
<hr />
<pre>
  783   implementation( NULL, ra_, false, st );
  784 }
  785 #endif
  786 
  787 void MachSpillCopyNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  788   implementation( &amp;cbuf, ra_, false, NULL );
  789 }
  790 
  791 uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
  792   return implementation( NULL, ra_, true, NULL );
  793 }
  794 
  795 //=============================================================================
  796 #ifndef PRODUCT
  797 void MachNopNode::format( PhaseRegAlloc *, outputStream *st ) const {
  798   st-&gt;print(&quot;NOP \t# %d bytes pad for loops and calls&quot;, 4 * _count);
  799 }
  800 #endif
  801 
  802 void MachNopNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc * ) const {
<span class="line-modified">  803   C2_MacroAssembler _masm(&amp;cbuf);</span>
  804   for(int i = 0; i &lt; _count; i += 1) {
  805     __ nop();
  806   }
  807 }
  808 
  809 uint MachNopNode::size(PhaseRegAlloc *ra_) const {
  810   return 4 * _count;
  811 }
  812 
  813 
  814 //=============================================================================
  815 #ifndef PRODUCT
  816 void BoxLockNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
  817   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
  818   int reg = ra_-&gt;get_reg_first(this);
  819   st-&gt;print(&quot;ADD    %s,R_SP+#%d&quot;,Matcher::regName[reg], offset);
  820 }
  821 #endif
  822 
  823 void BoxLockNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<span class="line-modified">  824   C2_MacroAssembler _masm(&amp;cbuf);</span>
  825   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
  826   int reg = ra_-&gt;get_encode(this);
  827   Register dst = reg_to_register_object(reg);
  828 
  829   if (is_aimm(offset)) {
  830     __ add(dst, SP, offset);
  831   } else {
  832     __ mov_slow(dst, offset);
  833     __ add(dst, SP, dst);
  834   }
  835 }
  836 
  837 uint BoxLockNode::size(PhaseRegAlloc *ra_) const {
  838   // BoxLockNode is not a MachNode, so we can&#39;t just call MachNode::size(ra_)
  839   assert(ra_ == ra_-&gt;C-&gt;regalloc(), &quot;sanity&quot;);
<span class="line-modified">  840   return ra_-&gt;C-&gt;output()-&gt;scratch_emit_size(this);</span>
  841 }
  842 
  843 //=============================================================================
  844 #ifndef PRODUCT
  845 #define R_RTEMP &quot;R_R12&quot;
  846 void MachUEPNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
  847   st-&gt;print_cr(&quot;\nUEP:&quot;);
  848   if (UseCompressedClassPointers) {
  849     st-&gt;print_cr(&quot;\tLDR_w &quot; R_RTEMP &quot;,[R_R0 + oopDesc::klass_offset_in_bytes]\t! Inline cache check&quot;);
  850     st-&gt;print_cr(&quot;\tdecode_klass &quot; R_RTEMP);
  851   } else {
  852     st-&gt;print_cr(&quot;\tLDR   &quot; R_RTEMP &quot;,[R_R0 + oopDesc::klass_offset_in_bytes]\t! Inline cache check&quot;);
  853   }
  854   st-&gt;print_cr(&quot;\tCMP   &quot; R_RTEMP &quot;,R_R8&quot; );
  855   st-&gt;print   (&quot;\tB.NE  SharedRuntime::handle_ic_miss_stub&quot;);
  856 }
  857 #endif
  858 
  859 void MachUEPNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<span class="line-modified">  860   C2_MacroAssembler _masm(&amp;cbuf);</span>
  861   Register iCache  = reg_to_register_object(Matcher::inline_cache_reg_encode());
  862   assert(iCache == Ricklass, &quot;should be&quot;);
  863   Register receiver = R0;
  864 
  865   __ load_klass(Rtemp, receiver);
  866   __ cmp(Rtemp, iCache);
  867   __ jump(SharedRuntime::get_ic_miss_stub(), relocInfo::runtime_call_type, noreg, ne);
  868 }
  869 
  870 uint MachUEPNode::size(PhaseRegAlloc *ra_) const {
  871   return MachNode::size(ra_);
  872 }
  873 
  874 
  875 //=============================================================================
  876 
  877 // Emit exception handler code.
  878 int HandlerImpl::emit_exception_handler(CodeBuffer&amp; cbuf) {
<span class="line-modified">  879   C2_MacroAssembler _masm(&amp;cbuf);</span>
  880 
  881   address base = __ start_a_stub(size_exception_handler());
  882   if (base == NULL) {
  883     ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
  884     return 0;  // CodeBuffer::expand failed
  885   }
  886 
  887   int offset = __ offset();
  888 
  889   // OK to trash LR, because exception blob will kill it
  890   __ jump(OptoRuntime::exception_blob()-&gt;entry_point(), relocInfo::runtime_call_type, LR_tmp);
  891 
  892   assert(__ offset() - offset &lt;= (int) size_exception_handler(), &quot;overflow&quot;);
  893 
  894   __ end_a_stub();
  895 
  896   return offset;
  897 }
  898 
  899 int HandlerImpl::emit_deopt_handler(CodeBuffer&amp; cbuf) {
  900   // Can&#39;t use any of the current frame&#39;s registers as we may have deopted
  901   // at a poll and everything can be live.
<span class="line-modified">  902   C2_MacroAssembler _masm(&amp;cbuf);</span>
  903 
  904   address base = __ start_a_stub(size_deopt_handler());
  905   if (base == NULL) {
  906     ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
  907     return 0;  // CodeBuffer::expand failed
  908   }
  909 
  910   int offset = __ offset();
  911   address deopt_pc = __ pc();
  912 
  913   __ sub(SP, SP, wordSize); // make room for saved PC
  914   __ push(LR); // save LR that may be live when we get here
  915   __ mov_relative_address(LR, deopt_pc);
  916   __ str(LR, Address(SP, wordSize)); // save deopt PC
  917   __ pop(LR); // restore LR
  918   __ jump(SharedRuntime::deopt_blob()-&gt;unpack(), relocInfo::runtime_call_type, noreg);
  919 
  920   assert(__ offset() - offset &lt;= (int) size_deopt_handler(), &quot;overflow&quot;);
  921 
  922   __ end_a_stub();
</pre>
<hr />
<pre>
 1085 const bool Matcher::convi2l_type_required = true;
 1086 
 1087 // No support for generic vector operands.
 1088 const bool Matcher::supports_generic_vector_operands  = false;
 1089 
 1090 MachOper* Matcher::specialize_generic_vector_operand(MachOper* original_opnd, uint ideal_reg, bool is_temp) {
 1091   ShouldNotReachHere(); // generic vector operands not supported
 1092   return NULL;
 1093 }
 1094 
 1095 bool Matcher::is_generic_reg2reg_move(MachNode* m) {
 1096   ShouldNotReachHere();  // generic vector operands not supported
 1097   return false;
 1098 }
 1099 
 1100 bool Matcher::is_generic_vector(MachOper* opnd)  {
 1101   ShouldNotReachHere();  // generic vector operands not supported
 1102   return false;
 1103 }
 1104 
<span class="line-added"> 1105 // Should the matcher clone input &#39;m&#39; of node &#39;n&#39;?</span>
<span class="line-added"> 1106 bool Matcher::pd_clone_node(Node* n, Node* m, Matcher::MStack&amp; mstack) {</span>
<span class="line-added"> 1107   if (is_vshift_con_pattern(n, m)) { // ShiftV src (ShiftCntV con)</span>
<span class="line-added"> 1108     mstack.push(m, Visit);           // m = ShiftCntV</span>
<span class="line-added"> 1109     return true;</span>
<span class="line-added"> 1110   }</span>
<span class="line-added"> 1111   return false;</span>
<span class="line-added"> 1112 }</span>
<span class="line-added"> 1113 </span>
 1114 // Should the Matcher clone shifts on addressing modes, expecting them
 1115 // to be subsumed into complex addressing expressions or compute them
 1116 // into registers?
<span class="line-modified"> 1117 bool Matcher::pd_clone_address_expressions(AddPNode* m, Matcher::MStack&amp; mstack, VectorSet&amp; address_visited) {</span>
 1118   return clone_base_plus_offset_address(m, mstack, address_visited);
 1119 }
 1120 
 1121 void Compile::reshape_address(AddPNode* addp) {
 1122 }
 1123 
 1124 bool Matcher::narrow_oop_use_complex_address() {
 1125   NOT_LP64(ShouldNotCallThis());
 1126   assert(UseCompressedOops, &quot;only for compressed oops code&quot;);
 1127   return false;
 1128 }
 1129 
 1130 bool Matcher::narrow_klass_use_complex_address() {
 1131   NOT_LP64(ShouldNotCallThis());
 1132   assert(UseCompressedClassPointers, &quot;only for compressed klass code&quot;);
 1133   return false;
 1134 }
 1135 
 1136 bool Matcher::const_oop_prefer_decode() {
 1137   NOT_LP64(ShouldNotCallThis());
</pre>
<hr />
<pre>
 1282       emit_call_reloc(cbuf, as_MachCall(), $meth, runtime_call_Relocation::spec());
 1283     } else {
 1284       int method_index = resolved_method_index(cbuf);
 1285       RelocationHolder rspec = _optimized_virtual ? opt_virtual_call_Relocation::spec(method_index)
 1286                                                   : static_call_Relocation::spec(method_index);
 1287       emit_call_reloc(cbuf, as_MachCall(), $meth, rspec);
 1288 
 1289       // Emit stubs for static call.
 1290       address stub = CompiledStaticCall::emit_to_interp_stub(cbuf);
 1291       if (stub == NULL) {
 1292         ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 1293         return;
 1294       }
 1295     }
 1296   %}
 1297 
 1298   enc_class save_last_PC %{
 1299     // preserve mark
 1300     address mark = cbuf.insts()-&gt;mark();
 1301     debug_only(int off0 = cbuf.insts_size());
<span class="line-modified"> 1302     C2_MacroAssembler _masm(&amp;cbuf);</span>
 1303     int ret_addr_offset = as_MachCall()-&gt;ret_addr_offset();
 1304     __ adr(LR, mark + ret_addr_offset);
 1305     __ str(LR, Address(Rthread, JavaThread::last_Java_pc_offset()));
 1306     debug_only(int off1 = cbuf.insts_size());
 1307     assert(off1 - off0 == 2 * Assembler::InstructionSize, &quot;correct size prediction&quot;);
 1308     // restore mark
 1309     cbuf.insts()-&gt;set_mark(mark);
 1310   %}
 1311 
 1312   enc_class preserve_SP %{
 1313     // preserve mark
 1314     address mark = cbuf.insts()-&gt;mark();
 1315     debug_only(int off0 = cbuf.insts_size());
<span class="line-modified"> 1316     C2_MacroAssembler _masm(&amp;cbuf);</span>
 1317     // FP is preserved across all calls, even compiled calls.
 1318     // Use it to preserve SP in places where the callee might change the SP.
 1319     __ mov(Rmh_SP_save, SP);
 1320     debug_only(int off1 = cbuf.insts_size());
 1321     assert(off1 - off0 == 4, &quot;correct size prediction&quot;);
 1322     // restore mark
 1323     cbuf.insts()-&gt;set_mark(mark);
 1324   %}
 1325 
 1326   enc_class restore_SP %{
<span class="line-modified"> 1327     C2_MacroAssembler _masm(&amp;cbuf);</span>
 1328     __ mov(SP, Rmh_SP_save);
 1329   %}
 1330 
 1331   enc_class Java_Dynamic_Call (method meth) %{
<span class="line-modified"> 1332     C2_MacroAssembler _masm(&amp;cbuf);</span>
 1333     Register R8_ic_reg = reg_to_register_object(Matcher::inline_cache_reg_encode());
 1334     assert(R8_ic_reg == Ricklass, &quot;should be&quot;);
 1335     __ set_inst_mark();
 1336     __ movw(R8_ic_reg, ((unsigned int)Universe::non_oop_word()) &amp; 0xffff);
 1337     __ movt(R8_ic_reg, ((unsigned int)Universe::non_oop_word()) &gt;&gt; 16);
 1338     address  virtual_call_oop_addr = __ inst_mark();
 1339     // CALL to fixup routine.  Fixup routine uses ScopeDesc info to determine
 1340     // who we intended to call.
 1341     int method_index = resolved_method_index(cbuf);
 1342     __ relocate(virtual_call_Relocation::spec(virtual_call_oop_addr, method_index));
 1343     emit_call_reloc(cbuf, as_MachCall(), $meth, RelocationHolder::none);
 1344   %}
 1345 
 1346   enc_class LdReplImmI(immI src, regD dst, iRegI tmp, int cnt, int wth) %{
 1347     // FIXME: load from constant table?
 1348     // Load a constant replicated &quot;count&quot; times with width &quot;width&quot;
 1349     int count = $cnt$$constant;
 1350     int width = $wth$$constant;
 1351     assert(count*width == 4, &quot;sanity&quot;);
 1352     int val = $src$$constant;
 1353     if (width &lt; 4) {
 1354       int bit_width = width * 8;
 1355       val &amp;= (((int)1) &lt;&lt; bit_width) - 1; // mask off sign bits
 1356       for (int i = 0; i &lt; count - 1; i++) {
 1357         val |= (val &lt;&lt; bit_width);
 1358       }
 1359     }
<span class="line-modified"> 1360     C2_MacroAssembler _masm(&amp;cbuf);</span>
 1361 
 1362     if (val == -1) {
 1363       __ mvn($tmp$$Register, 0);
 1364     } else if (val == 0) {
 1365       __ mov($tmp$$Register, 0);
 1366     } else {
 1367       __ movw($tmp$$Register, val &amp; 0xffff);
 1368       __ movt($tmp$$Register, (unsigned int)val &gt;&gt; 16);
 1369     }
 1370     __ fmdrr($dst$$FloatRegister, $tmp$$Register, $tmp$$Register);
 1371   %}
 1372 
 1373   enc_class LdReplImmF(immF src, regD dst, iRegI tmp) %{
 1374     // Replicate float con 2 times and pack into vector (8 bytes) in regD.
 1375     float fval = $src$$constant;
 1376     int val = *((int*)&amp;fval);
<span class="line-modified"> 1377     C2_MacroAssembler _masm(&amp;cbuf);</span>
 1378 
 1379     if (val == -1) {
 1380       __ mvn($tmp$$Register, 0);
 1381     } else if (val == 0) {
 1382       __ mov($tmp$$Register, 0);
 1383     } else {
 1384       __ movw($tmp$$Register, val &amp; 0xffff);
 1385       __ movt($tmp$$Register, (unsigned int)val &gt;&gt; 16);
 1386     }
 1387     __ fmdrr($dst$$FloatRegister, $tmp$$Register, $tmp$$Register);
 1388   %}
 1389 
 1390   enc_class enc_String_Compare(R0RegP str1, R1RegP str2, R2RegI cnt1, R3RegI cnt2, iRegI result, iRegI tmp1, iRegI tmp2) %{
 1391     Label Ldone, Lloop;
<span class="line-modified"> 1392     C2_MacroAssembler _masm(&amp;cbuf);</span>
 1393 
 1394     Register   str1_reg = $str1$$Register;
 1395     Register   str2_reg = $str2$$Register;
 1396     Register   cnt1_reg = $cnt1$$Register; // int
 1397     Register   cnt2_reg = $cnt2$$Register; // int
 1398     Register   tmp1_reg = $tmp1$$Register;
 1399     Register   tmp2_reg = $tmp2$$Register;
 1400     Register result_reg = $result$$Register;
 1401 
 1402     assert_different_registers(str1_reg, str2_reg, cnt1_reg, cnt2_reg, tmp1_reg, tmp2_reg);
 1403 
 1404     // Compute the minimum of the string lengths(str1_reg) and the
 1405     // difference of the string lengths (stack)
 1406 
 1407     // See if the lengths are different, and calculate min in str1_reg.
 1408     // Stash diff in tmp2 in case we need it for a tie-breaker.
 1409     __ subs_32(tmp2_reg, cnt1_reg, cnt2_reg);
 1410     __ mov(cnt1_reg, AsmOperand(cnt1_reg, lsl, exact_log2(sizeof(jchar)))); // scale the limit
 1411     __ mov(cnt1_reg, AsmOperand(cnt2_reg, lsl, exact_log2(sizeof(jchar))), pl); // scale the limit
 1412 
</pre>
<hr />
<pre>
 1464     __ subs(chr1_reg, chr1_reg, chr2_reg);
 1465     if (result_reg != chr1_reg) {
 1466       __ mov(result_reg, chr1_reg, ne);
 1467     }
 1468     __ b(Ldone, ne);
 1469 
 1470     __ adds(limit_reg, limit_reg, sizeof(jchar));
 1471     __ b(Lloop, ne);
 1472 
 1473     // If strings are equal up to min length, return the length difference.
 1474     if (result_reg != tmp2_reg) {
 1475       __ mov(result_reg, tmp2_reg);
 1476     }
 1477 
 1478     // Otherwise, return the difference between the first mismatched chars.
 1479     __ bind(Ldone);
 1480   %}
 1481 
 1482   enc_class enc_String_Equals(R0RegP str1, R1RegP str2, R2RegI cnt, iRegI result, iRegI tmp1, iRegI tmp2) %{
 1483     Label Lchar, Lchar_loop, Ldone, Lequal;
<span class="line-modified"> 1484     C2_MacroAssembler _masm(&amp;cbuf);</span>
 1485 
 1486     Register   str1_reg = $str1$$Register;
 1487     Register   str2_reg = $str2$$Register;
 1488     Register    cnt_reg = $cnt$$Register; // int
 1489     Register   tmp1_reg = $tmp1$$Register;
 1490     Register   tmp2_reg = $tmp2$$Register;
 1491     Register result_reg = $result$$Register;
 1492 
 1493     assert_different_registers(str1_reg, str2_reg, cnt_reg, tmp1_reg, tmp2_reg, result_reg);
 1494 
 1495     __ cmp(str1_reg, str2_reg); //same char[] ?
 1496     __ b(Lequal, eq);
 1497 
 1498     __ cbz_32(cnt_reg, Lequal); // count == 0
 1499 
 1500     //rename registers
 1501     Register limit_reg = cnt_reg;
 1502     Register  chr1_reg = tmp1_reg;
 1503     Register  chr2_reg = tmp2_reg;
 1504 
</pre>
<hr />
<pre>
 1526     __ add(str2_reg, limit_reg, str2_reg);
 1527     __ neg(limit_reg, limit_reg); //negate count
 1528 
 1529     // Lchar_loop
 1530     __ bind(Lchar_loop);
 1531     __ ldrh(chr1_reg, Address(str1_reg, limit_reg));
 1532     __ ldrh(chr2_reg, Address(str2_reg, limit_reg));
 1533     __ cmp(chr1_reg, chr2_reg);
 1534     __ b(Ldone, ne);
 1535     __ adds(limit_reg, limit_reg, sizeof(jchar));
 1536     __ b(Lchar_loop, ne);
 1537 
 1538     __ bind(Lequal);
 1539     __ mov(result_reg, 1);  //equal
 1540 
 1541     __ bind(Ldone);
 1542   %}
 1543 
 1544   enc_class enc_Array_Equals(R0RegP ary1, R1RegP ary2, iRegI tmp1, iRegI tmp2, iRegI tmp3, iRegI result) %{
 1545     Label Ldone, Lloop, Lequal;
<span class="line-modified"> 1546     C2_MacroAssembler _masm(&amp;cbuf);</span>
 1547 
 1548     Register   ary1_reg = $ary1$$Register;
 1549     Register   ary2_reg = $ary2$$Register;
 1550     Register   tmp1_reg = $tmp1$$Register;
 1551     Register   tmp2_reg = $tmp2$$Register;
 1552     Register   tmp3_reg = $tmp3$$Register;
 1553     Register result_reg = $result$$Register;
 1554 
 1555     assert_different_registers(ary1_reg, ary2_reg, tmp1_reg, tmp2_reg, tmp3_reg, result_reg);
 1556 
 1557     int length_offset  = arrayOopDesc::length_offset_in_bytes();
 1558     int base_offset    = arrayOopDesc::base_offset_in_bytes(T_CHAR);
 1559 
 1560     // return true if the same array
 1561     __ teq(ary1_reg, ary2_reg);
 1562     __ mov(result_reg, 1, eq);
 1563     __ b(Ldone, eq); // equal
 1564 
 1565     __ tst(ary1_reg, ary1_reg);
 1566     __ mov(result_reg, 0, eq);
</pre>
<hr />
<pre>
 2023 
 2024 // Pointer Immediate: 32 or 64-bit
 2025 operand immP() %{
 2026   match(ConP);
 2027 
 2028   op_cost(5);
 2029   // formats are generated automatically for constants and base registers
 2030   format %{ %}
 2031   interface(CONST_INTER);
 2032 %}
 2033 
 2034 operand immP0() %{
 2035   predicate(n-&gt;get_ptr() == 0);
 2036   match(ConP);
 2037   op_cost(0);
 2038 
 2039   format %{ %}
 2040   interface(CONST_INTER);
 2041 %}
 2042 









 2043 // Pointer Immediate
 2044 operand immN()
 2045 %{
 2046   match(ConN);
 2047 
 2048   op_cost(10);
 2049   format %{ %}
 2050   interface(CONST_INTER);
 2051 %}
 2052 
 2053 operand immNKlass()
 2054 %{
 2055   match(ConNKlass);
 2056 
 2057   op_cost(10);
 2058   format %{ %}
 2059   interface(CONST_INTER);
 2060 %}
 2061 
 2062 // NULL Pointer Immediate
</pre>
<hr />
<pre>
 3091 pipe_class ialu_hi_lo_reg(iRegI dst, immI src) %{
 3092     instruction_count(1); multiple_bundles;
 3093     dst   : E(write)+1;
 3094     IALU  : R(2);
 3095 %}
 3096 
 3097 // Long Constant
 3098 pipe_class loadConL( iRegL dst, immL src ) %{
 3099     instruction_count(2); multiple_bundles;
 3100     dst   : E(write)+1;
 3101     IALU  : R(2);
 3102     IALU  : R(2);
 3103 %}
 3104 
 3105 // Pointer Constant
 3106 pipe_class loadConP( iRegP dst, immP src ) %{
 3107     instruction_count(0); multiple_bundles;
 3108     fixed_latency(6);
 3109 %}
 3110 






 3111 // Long Constant small
 3112 pipe_class loadConLlo( iRegL dst, immL src ) %{
 3113     instruction_count(2);
 3114     dst   : E(write);
 3115     IALU  : R;
 3116     IALU  : R;
 3117 %}
 3118 
 3119 // [PHH] This is wrong for 64-bit.  See LdImmF/D.
 3120 pipe_class loadConFD(regF dst, immF src, iRegP tmp) %{
 3121     instruction_count(1); multiple_bundles;
 3122     src   : R(read);
 3123     dst   : M(write)+1;
 3124     IALU  : R;
 3125     MS    : E;
 3126 %}
 3127 
 3128 // Integer ALU nop operation
 3129 pipe_class ialu_nop() %{
 3130     single_instruction;
</pre>
<hr />
<pre>
 4273 
 4274 instruct loadConP(iRegP dst, immP src) %{
 4275   match(Set dst src);
 4276   ins_cost(DEFAULT_COST * 3/2);
 4277   format %{ &quot;MOV_SLOW    $dst,$src\t!ptr&quot; %}
 4278   ins_encode %{
 4279     relocInfo::relocType constant_reloc = _opnds[1]-&gt;constant_reloc();
 4280     intptr_t val = $src$$constant;
 4281     if (constant_reloc == relocInfo::oop_type) {
 4282       __ mov_oop($dst$$Register, (jobject)val);
 4283     } else if (constant_reloc == relocInfo::metadata_type) {
 4284       __ mov_metadata($dst$$Register, (Metadata*)val);
 4285     } else {
 4286       __ mov_slow($dst$$Register, val);
 4287     }
 4288   %}
 4289   ins_pipe(loadConP);
 4290 %}
 4291 
 4292 










 4293 instruct loadConL(iRegL dst, immL src) %{
 4294   match(Set dst src);
 4295   ins_cost(DEFAULT_COST * 4);
 4296   format %{ &quot;MOV_SLOW   $dst.lo, $src &amp; 0x0FFFFFFFFL \t! long\n\t&quot;
 4297             &quot;MOV_SLOW   $dst.hi, $src &gt;&gt; 32&quot; %}
 4298   ins_encode %{
 4299     __ mov_slow(reg_to_register_object($dst$$reg), $src$$constant &amp; 0x0FFFFFFFFL);
 4300     __ mov_slow(reg_to_register_object($dst$$reg + 1), ((julong)($src$$constant)) &gt;&gt; 32);
 4301   %}
 4302   ins_pipe(loadConL);
 4303 %}
 4304 
 4305 instruct loadConL16( iRegL dst, immL16 src ) %{
 4306   match(Set dst src);
 4307   ins_cost(DEFAULT_COST * 2);
 4308 
 4309   size(8);
 4310   format %{ &quot;MOVW    $dst.lo, $src \n\t&quot;
 4311             &quot;MOVW    $dst.hi, 0 \n\t&quot; %}
 4312   ins_encode %{
</pre>
</td>
</tr>
</table>
<center><a href="../aarch64/vm_version_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIRAssembler_arm.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
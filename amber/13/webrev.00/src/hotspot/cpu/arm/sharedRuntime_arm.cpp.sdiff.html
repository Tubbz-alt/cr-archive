<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/arm/sharedRuntime_arm.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macroAssembler_arm.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../ppc/c1_LIRAssembler_ppc.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/arm/sharedRuntime_arm.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1785 
1786   OopMap* map = RegisterSaver::save_live_registers(masm, &amp;frame_size_words, !cause_return);
1787   if (!cause_return) {
1788     // update saved PC with correct value
1789     // need 2 steps because LR can be live in c2 method
1790     __ ldr(LR, Address(Rthread, JavaThread::saved_exception_pc_offset()));
1791     __ str(LR, Address(SP, RegisterSaver::LR_offset * wordSize));
1792   }
1793 
1794   __ mov(R0, Rthread);
1795   int pc_offset = __ set_last_Java_frame(SP, FP, false, Rtemp); // note: FP may not need to be saved (not on x86)
1796   assert(((__ pc()) - start) == __ offset(), &quot;warning: start differs from code_begin&quot;);
1797   __ call(call_ptr);
1798   if (pc_offset == -1) {
1799     pc_offset = __ offset();
1800   }
1801   oop_maps-&gt;add_gc_map(pc_offset, map);
1802   __ reset_last_Java_frame(Rtemp); // Rtemp free since scratched by far call
1803 
1804   if (!cause_return) {
<span class="line-modified">1805     if (SafepointMechanism::uses_thread_local_poll()) {</span>
<span class="line-modified">1806       // If our stashed return pc was modified by the runtime we avoid touching it</span>
<span class="line-modified">1807       __ ldr(R3_tmp, Address(Rthread, JavaThread::saved_exception_pc_offset()));</span>
<span class="line-modified">1808       __ ldr(R2_tmp, Address(SP, RegisterSaver::LR_offset * wordSize));</span>
<span class="line-modified">1809       __ cmp(R2_tmp, R3_tmp);</span>
<span class="line-modified">1810       // Adjust return pc forward to step over the safepoint poll instruction</span>
<span class="line-modified">1811       __ add(R2_tmp, R2_tmp, 4, eq);</span>
<span class="line-removed">1812       __ str(R2_tmp, Address(SP, RegisterSaver::LR_offset * wordSize), eq);</span>
<span class="line-removed">1813     }</span>
1814 
1815     // Check for pending exception
1816     __ ldr(Rtemp, Address(Rthread, Thread::pending_exception_offset()));
1817     __ cmp(Rtemp, 0);
1818 
1819     RegisterSaver::restore_live_registers(masm, false);
1820     __ pop(PC, eq);
1821     __ pop(Rexception_pc);
1822   } else {
1823     // Check for pending exception
1824     __ ldr(Rtemp, Address(Rthread, Thread::pending_exception_offset()));
1825     __ cmp(Rtemp, 0);
1826 
1827     RegisterSaver::restore_live_registers(masm);
1828     __ bx(LR, eq);
1829     __ mov(Rexception_pc, LR);
1830   }
1831 
1832   __ jump(StubRoutines::forward_exception_entry(), relocInfo::runtime_call_type, Rtemp);
1833 
</pre>
</td>
<td>
<hr />
<pre>
1785 
1786   OopMap* map = RegisterSaver::save_live_registers(masm, &amp;frame_size_words, !cause_return);
1787   if (!cause_return) {
1788     // update saved PC with correct value
1789     // need 2 steps because LR can be live in c2 method
1790     __ ldr(LR, Address(Rthread, JavaThread::saved_exception_pc_offset()));
1791     __ str(LR, Address(SP, RegisterSaver::LR_offset * wordSize));
1792   }
1793 
1794   __ mov(R0, Rthread);
1795   int pc_offset = __ set_last_Java_frame(SP, FP, false, Rtemp); // note: FP may not need to be saved (not on x86)
1796   assert(((__ pc()) - start) == __ offset(), &quot;warning: start differs from code_begin&quot;);
1797   __ call(call_ptr);
1798   if (pc_offset == -1) {
1799     pc_offset = __ offset();
1800   }
1801   oop_maps-&gt;add_gc_map(pc_offset, map);
1802   __ reset_last_Java_frame(Rtemp); // Rtemp free since scratched by far call
1803 
1804   if (!cause_return) {
<span class="line-modified">1805     // If our stashed return pc was modified by the runtime we avoid touching it</span>
<span class="line-modified">1806     __ ldr(R3_tmp, Address(Rthread, JavaThread::saved_exception_pc_offset()));</span>
<span class="line-modified">1807     __ ldr(R2_tmp, Address(SP, RegisterSaver::LR_offset * wordSize));</span>
<span class="line-modified">1808     __ cmp(R2_tmp, R3_tmp);</span>
<span class="line-modified">1809     // Adjust return pc forward to step over the safepoint poll instruction</span>
<span class="line-modified">1810     __ add(R2_tmp, R2_tmp, 4, eq);</span>
<span class="line-modified">1811     __ str(R2_tmp, Address(SP, RegisterSaver::LR_offset * wordSize), eq);</span>


1812 
1813     // Check for pending exception
1814     __ ldr(Rtemp, Address(Rthread, Thread::pending_exception_offset()));
1815     __ cmp(Rtemp, 0);
1816 
1817     RegisterSaver::restore_live_registers(masm, false);
1818     __ pop(PC, eq);
1819     __ pop(Rexception_pc);
1820   } else {
1821     // Check for pending exception
1822     __ ldr(Rtemp, Address(Rthread, Thread::pending_exception_offset()));
1823     __ cmp(Rtemp, 0);
1824 
1825     RegisterSaver::restore_live_registers(masm);
1826     __ bx(LR, eq);
1827     __ mov(Rexception_pc, LR);
1828   }
1829 
1830   __ jump(StubRoutines::forward_exception_entry(), relocInfo::runtime_call_type, Rtemp);
1831 
</pre>
</td>
</tr>
</table>
<center><a href="macroAssembler_arm.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../ppc/c1_LIRAssembler_ppc.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
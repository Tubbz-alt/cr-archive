<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/cpu/x86/macroAssembler_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmciCodeInstaller_x86.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_x86.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/macroAssembler_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 47,13 ***</span>
  #include &quot;runtime/sharedRuntime.hpp&quot;
  #include &quot;runtime/stubRoutines.hpp&quot;
  #include &quot;runtime/thread.hpp&quot;
  #include &quot;utilities/macros.hpp&quot;
  #include &quot;crc32c.h&quot;
<span class="line-removed">- #ifdef COMPILER2</span>
<span class="line-removed">- #include &quot;opto/intrinsicnode.hpp&quot;</span>
<span class="line-removed">- #endif</span>
  
  #ifdef PRODUCT
  #define BLOCK_COMMENT(str) /* nothing */
  #define STOP(error) stop(error)
  #else
<span class="line-new-header">--- 47,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1281,776 ***</span>
    andptr(temp_reg, markWord::biased_lock_mask_in_place);
    cmpptr(temp_reg, markWord::biased_lock_pattern);
    jcc(Assembler::equal, done);
  }
  
<span class="line-removed">- #ifdef COMPILER2</span>
<span class="line-removed">- </span>
<span class="line-removed">- #if INCLUDE_RTM_OPT</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Update rtm_counters based on abort status</span>
<span class="line-removed">- // input: abort_status</span>
<span class="line-removed">- //        rtm_counters (RTMLockingCounters*)</span>
<span class="line-removed">- // flags are killed</span>
<span class="line-removed">- void MacroAssembler::rtm_counters_update(Register abort_status, Register rtm_counters) {</span>
<span class="line-removed">- </span>
<span class="line-removed">-   atomic_incptr(Address(rtm_counters, RTMLockingCounters::abort_count_offset()));</span>
<span class="line-removed">-   if (PrintPreciseRTMLockingStatistics) {</span>
<span class="line-removed">-     for (int i = 0; i &lt; RTMLockingCounters::ABORT_STATUS_LIMIT; i++) {</span>
<span class="line-removed">-       Label check_abort;</span>
<span class="line-removed">-       testl(abort_status, (1&lt;&lt;i));</span>
<span class="line-removed">-       jccb(Assembler::equal, check_abort);</span>
<span class="line-removed">-       atomic_incptr(Address(rtm_counters, RTMLockingCounters::abortX_count_offset() + (i * sizeof(uintx))));</span>
<span class="line-removed">-       bind(check_abort);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Branch if (random &amp; (count-1) != 0), count is 2^n</span>
<span class="line-removed">- // tmp, scr and flags are killed</span>
<span class="line-removed">- void MacroAssembler::branch_on_random_using_rdtsc(Register tmp, Register scr, int count, Label&amp; brLabel) {</span>
<span class="line-removed">-   assert(tmp == rax, &quot;&quot;);</span>
<span class="line-removed">-   assert(scr == rdx, &quot;&quot;);</span>
<span class="line-removed">-   rdtsc(); // modifies EDX:EAX</span>
<span class="line-removed">-   andptr(tmp, count-1);</span>
<span class="line-removed">-   jccb(Assembler::notZero, brLabel);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Perform abort ratio calculation, set no_rtm bit if high ratio</span>
<span class="line-removed">- // input:  rtm_counters_Reg (RTMLockingCounters* address)</span>
<span class="line-removed">- // tmpReg, rtm_counters_Reg and flags are killed</span>
<span class="line-removed">- void MacroAssembler::rtm_abort_ratio_calculation(Register tmpReg,</span>
<span class="line-removed">-                                                  Register rtm_counters_Reg,</span>
<span class="line-removed">-                                                  RTMLockingCounters* rtm_counters,</span>
<span class="line-removed">-                                                  Metadata* method_data) {</span>
<span class="line-removed">-   Label L_done, L_check_always_rtm1, L_check_always_rtm2;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (RTMLockingCalculationDelay &gt; 0) {</span>
<span class="line-removed">-     // Delay calculation</span>
<span class="line-removed">-     movptr(tmpReg, ExternalAddress((address) RTMLockingCounters::rtm_calculation_flag_addr()), tmpReg);</span>
<span class="line-removed">-     testptr(tmpReg, tmpReg);</span>
<span class="line-removed">-     jccb(Assembler::equal, L_done);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   // Abort ratio calculation only if abort_count &gt; RTMAbortThreshold</span>
<span class="line-removed">-   //   Aborted transactions = abort_count * 100</span>
<span class="line-removed">-   //   All transactions = total_count *  RTMTotalCountIncrRate</span>
<span class="line-removed">-   //   Set no_rtm bit if (Aborted transactions &gt;= All transactions * RTMAbortRatio)</span>
<span class="line-removed">- </span>
<span class="line-removed">-   movptr(tmpReg, Address(rtm_counters_Reg, RTMLockingCounters::abort_count_offset()));</span>
<span class="line-removed">-   cmpptr(tmpReg, RTMAbortThreshold);</span>
<span class="line-removed">-   jccb(Assembler::below, L_check_always_rtm2);</span>
<span class="line-removed">-   imulptr(tmpReg, tmpReg, 100);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   Register scrReg = rtm_counters_Reg;</span>
<span class="line-removed">-   movptr(scrReg, Address(rtm_counters_Reg, RTMLockingCounters::total_count_offset()));</span>
<span class="line-removed">-   imulptr(scrReg, scrReg, RTMTotalCountIncrRate);</span>
<span class="line-removed">-   imulptr(scrReg, scrReg, RTMAbortRatio);</span>
<span class="line-removed">-   cmpptr(tmpReg, scrReg);</span>
<span class="line-removed">-   jccb(Assembler::below, L_check_always_rtm1);</span>
<span class="line-removed">-   if (method_data != NULL) {</span>
<span class="line-removed">-     // set rtm_state to &quot;no rtm&quot; in MDO</span>
<span class="line-removed">-     mov_metadata(tmpReg, method_data);</span>
<span class="line-removed">-     lock();</span>
<span class="line-removed">-     orl(Address(tmpReg, MethodData::rtm_state_offset_in_bytes()), NoRTM);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   jmpb(L_done);</span>
<span class="line-removed">-   bind(L_check_always_rtm1);</span>
<span class="line-removed">-   // Reload RTMLockingCounters* address</span>
<span class="line-removed">-   lea(rtm_counters_Reg, ExternalAddress((address)rtm_counters));</span>
<span class="line-removed">-   bind(L_check_always_rtm2);</span>
<span class="line-removed">-   movptr(tmpReg, Address(rtm_counters_Reg, RTMLockingCounters::total_count_offset()));</span>
<span class="line-removed">-   cmpptr(tmpReg, RTMLockingThreshold / RTMTotalCountIncrRate);</span>
<span class="line-removed">-   jccb(Assembler::below, L_done);</span>
<span class="line-removed">-   if (method_data != NULL) {</span>
<span class="line-removed">-     // set rtm_state to &quot;always rtm&quot; in MDO</span>
<span class="line-removed">-     mov_metadata(tmpReg, method_data);</span>
<span class="line-removed">-     lock();</span>
<span class="line-removed">-     orl(Address(tmpReg, MethodData::rtm_state_offset_in_bytes()), UseRTM);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   bind(L_done);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Update counters and perform abort ratio calculation</span>
<span class="line-removed">- // input:  abort_status_Reg</span>
<span class="line-removed">- // rtm_counters_Reg, flags are killed</span>
<span class="line-removed">- void MacroAssembler::rtm_profiling(Register abort_status_Reg,</span>
<span class="line-removed">-                                    Register rtm_counters_Reg,</span>
<span class="line-removed">-                                    RTMLockingCounters* rtm_counters,</span>
<span class="line-removed">-                                    Metadata* method_data,</span>
<span class="line-removed">-                                    bool profile_rtm) {</span>
<span class="line-removed">- </span>
<span class="line-removed">-   assert(rtm_counters != NULL, &quot;should not be NULL when profiling RTM&quot;);</span>
<span class="line-removed">-   // update rtm counters based on rax value at abort</span>
<span class="line-removed">-   // reads abort_status_Reg, updates flags</span>
<span class="line-removed">-   lea(rtm_counters_Reg, ExternalAddress((address)rtm_counters));</span>
<span class="line-removed">-   rtm_counters_update(abort_status_Reg, rtm_counters_Reg);</span>
<span class="line-removed">-   if (profile_rtm) {</span>
<span class="line-removed">-     // Save abort status because abort_status_Reg is used by following code.</span>
<span class="line-removed">-     if (RTMRetryCount &gt; 0) {</span>
<span class="line-removed">-       push(abort_status_Reg);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     assert(rtm_counters != NULL, &quot;should not be NULL when profiling RTM&quot;);</span>
<span class="line-removed">-     rtm_abort_ratio_calculation(abort_status_Reg, rtm_counters_Reg, rtm_counters, method_data);</span>
<span class="line-removed">-     // restore abort status</span>
<span class="line-removed">-     if (RTMRetryCount &gt; 0) {</span>
<span class="line-removed">-       pop(abort_status_Reg);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Retry on abort if abort&#39;s status is 0x6: can retry (0x2) | memory conflict (0x4)</span>
<span class="line-removed">- // inputs: retry_count_Reg</span>
<span class="line-removed">- //       : abort_status_Reg</span>
<span class="line-removed">- // output: retry_count_Reg decremented by 1</span>
<span class="line-removed">- // flags are killed</span>
<span class="line-removed">- void MacroAssembler::rtm_retry_lock_on_abort(Register retry_count_Reg, Register abort_status_Reg, Label&amp; retryLabel) {</span>
<span class="line-removed">-   Label doneRetry;</span>
<span class="line-removed">-   assert(abort_status_Reg == rax, &quot;&quot;);</span>
<span class="line-removed">-   // The abort reason bits are in eax (see all states in rtmLocking.hpp)</span>
<span class="line-removed">-   // 0x6 = conflict on which we can retry (0x2) | memory conflict (0x4)</span>
<span class="line-removed">-   // if reason is in 0x6 and retry count != 0 then retry</span>
<span class="line-removed">-   andptr(abort_status_Reg, 0x6);</span>
<span class="line-removed">-   jccb(Assembler::zero, doneRetry);</span>
<span class="line-removed">-   testl(retry_count_Reg, retry_count_Reg);</span>
<span class="line-removed">-   jccb(Assembler::zero, doneRetry);</span>
<span class="line-removed">-   pause();</span>
<span class="line-removed">-   decrementl(retry_count_Reg);</span>
<span class="line-removed">-   jmp(retryLabel);</span>
<span class="line-removed">-   bind(doneRetry);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Spin and retry if lock is busy,</span>
<span class="line-removed">- // inputs: box_Reg (monitor address)</span>
<span class="line-removed">- //       : retry_count_Reg</span>
<span class="line-removed">- // output: retry_count_Reg decremented by 1</span>
<span class="line-removed">- //       : clear z flag if retry count exceeded</span>
<span class="line-removed">- // tmp_Reg, scr_Reg, flags are killed</span>
<span class="line-removed">- void MacroAssembler::rtm_retry_lock_on_busy(Register retry_count_Reg, Register box_Reg,</span>
<span class="line-removed">-                                             Register tmp_Reg, Register scr_Reg, Label&amp; retryLabel) {</span>
<span class="line-removed">-   Label SpinLoop, SpinExit, doneRetry;</span>
<span class="line-removed">-   int owner_offset = OM_OFFSET_NO_MONITOR_VALUE_TAG(owner);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   testl(retry_count_Reg, retry_count_Reg);</span>
<span class="line-removed">-   jccb(Assembler::zero, doneRetry);</span>
<span class="line-removed">-   decrementl(retry_count_Reg);</span>
<span class="line-removed">-   movptr(scr_Reg, RTMSpinLoopCount);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   bind(SpinLoop);</span>
<span class="line-removed">-   pause();</span>
<span class="line-removed">-   decrementl(scr_Reg);</span>
<span class="line-removed">-   jccb(Assembler::lessEqual, SpinExit);</span>
<span class="line-removed">-   movptr(tmp_Reg, Address(box_Reg, owner_offset));</span>
<span class="line-removed">-   testptr(tmp_Reg, tmp_Reg);</span>
<span class="line-removed">-   jccb(Assembler::notZero, SpinLoop);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   bind(SpinExit);</span>
<span class="line-removed">-   jmp(retryLabel);</span>
<span class="line-removed">-   bind(doneRetry);</span>
<span class="line-removed">-   incrementl(retry_count_Reg); // clear z flag</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Use RTM for normal stack locks</span>
<span class="line-removed">- // Input: objReg (object to lock)</span>
<span class="line-removed">- void MacroAssembler::rtm_stack_locking(Register objReg, Register tmpReg, Register scrReg,</span>
<span class="line-removed">-                                        Register retry_on_abort_count_Reg,</span>
<span class="line-removed">-                                        RTMLockingCounters* stack_rtm_counters,</span>
<span class="line-removed">-                                        Metadata* method_data, bool profile_rtm,</span>
<span class="line-removed">-                                        Label&amp; DONE_LABEL, Label&amp; IsInflated) {</span>
<span class="line-removed">-   assert(UseRTMForStackLocks, &quot;why call this otherwise?&quot;);</span>
<span class="line-removed">-   assert(!UseBiasedLocking, &quot;Biased locking is not supported with RTM locking&quot;);</span>
<span class="line-removed">-   assert(tmpReg == rax, &quot;&quot;);</span>
<span class="line-removed">-   assert(scrReg == rdx, &quot;&quot;);</span>
<span class="line-removed">-   Label L_rtm_retry, L_decrement_retry, L_on_abort;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (RTMRetryCount &gt; 0) {</span>
<span class="line-removed">-     movl(retry_on_abort_count_Reg, RTMRetryCount); // Retry on abort</span>
<span class="line-removed">-     bind(L_rtm_retry);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   movptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes()));</span>
<span class="line-removed">-   testptr(tmpReg, markWord::monitor_value);  // inflated vs stack-locked|neutral|biased</span>
<span class="line-removed">-   jcc(Assembler::notZero, IsInflated);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (PrintPreciseRTMLockingStatistics || profile_rtm) {</span>
<span class="line-removed">-     Label L_noincrement;</span>
<span class="line-removed">-     if (RTMTotalCountIncrRate &gt; 1) {</span>
<span class="line-removed">-       // tmpReg, scrReg and flags are killed</span>
<span class="line-removed">-       branch_on_random_using_rdtsc(tmpReg, scrReg, RTMTotalCountIncrRate, L_noincrement);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     assert(stack_rtm_counters != NULL, &quot;should not be NULL when profiling RTM&quot;);</span>
<span class="line-removed">-     atomic_incptr(ExternalAddress((address)stack_rtm_counters-&gt;total_count_addr()), scrReg);</span>
<span class="line-removed">-     bind(L_noincrement);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   xbegin(L_on_abort);</span>
<span class="line-removed">-   movptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes()));       // fetch markword</span>
<span class="line-removed">-   andptr(tmpReg, markWord::biased_lock_mask_in_place); // look at 3 lock bits</span>
<span class="line-removed">-   cmpptr(tmpReg, markWord::unlocked_value);            // bits = 001 unlocked</span>
<span class="line-removed">-   jcc(Assembler::equal, DONE_LABEL);        // all done if unlocked</span>
<span class="line-removed">- </span>
<span class="line-removed">-   Register abort_status_Reg = tmpReg; // status of abort is stored in RAX</span>
<span class="line-removed">-   if (UseRTMXendForLockBusy) {</span>
<span class="line-removed">-     xend();</span>
<span class="line-removed">-     movptr(abort_status_Reg, 0x2);   // Set the abort status to 2 (so we can retry)</span>
<span class="line-removed">-     jmp(L_decrement_retry);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   else {</span>
<span class="line-removed">-     xabort(0);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   bind(L_on_abort);</span>
<span class="line-removed">-   if (PrintPreciseRTMLockingStatistics || profile_rtm) {</span>
<span class="line-removed">-     rtm_profiling(abort_status_Reg, scrReg, stack_rtm_counters, method_data, profile_rtm);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   bind(L_decrement_retry);</span>
<span class="line-removed">-   if (RTMRetryCount &gt; 0) {</span>
<span class="line-removed">-     // retry on lock abort if abort status is &#39;can retry&#39; (0x2) or &#39;memory conflict&#39; (0x4)</span>
<span class="line-removed">-     rtm_retry_lock_on_abort(retry_on_abort_count_Reg, abort_status_Reg, L_rtm_retry);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Use RTM for inflating locks</span>
<span class="line-removed">- // inputs: objReg (object to lock)</span>
<span class="line-removed">- //         boxReg (on-stack box address (displaced header location) - KILLED)</span>
<span class="line-removed">- //         tmpReg (ObjectMonitor address + markWord::monitor_value)</span>
<span class="line-removed">- void MacroAssembler::rtm_inflated_locking(Register objReg, Register boxReg, Register tmpReg,</span>
<span class="line-removed">-                                           Register scrReg, Register retry_on_busy_count_Reg,</span>
<span class="line-removed">-                                           Register retry_on_abort_count_Reg,</span>
<span class="line-removed">-                                           RTMLockingCounters* rtm_counters,</span>
<span class="line-removed">-                                           Metadata* method_data, bool profile_rtm,</span>
<span class="line-removed">-                                           Label&amp; DONE_LABEL) {</span>
<span class="line-removed">-   assert(UseRTMLocking, &quot;why call this otherwise?&quot;);</span>
<span class="line-removed">-   assert(tmpReg == rax, &quot;&quot;);</span>
<span class="line-removed">-   assert(scrReg == rdx, &quot;&quot;);</span>
<span class="line-removed">-   Label L_rtm_retry, L_decrement_retry, L_on_abort;</span>
<span class="line-removed">-   int owner_offset = OM_OFFSET_NO_MONITOR_VALUE_TAG(owner);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Without cast to int32_t this style of movptr will destroy r10 which is typically obj.</span>
<span class="line-removed">-   movptr(Address(boxReg, 0), (int32_t)intptr_t(markWord::unused_mark().value()));</span>
<span class="line-removed">-   movptr(boxReg, tmpReg); // Save ObjectMonitor address</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (RTMRetryCount &gt; 0) {</span>
<span class="line-removed">-     movl(retry_on_busy_count_Reg, RTMRetryCount);  // Retry on lock busy</span>
<span class="line-removed">-     movl(retry_on_abort_count_Reg, RTMRetryCount); // Retry on abort</span>
<span class="line-removed">-     bind(L_rtm_retry);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   if (PrintPreciseRTMLockingStatistics || profile_rtm) {</span>
<span class="line-removed">-     Label L_noincrement;</span>
<span class="line-removed">-     if (RTMTotalCountIncrRate &gt; 1) {</span>
<span class="line-removed">-       // tmpReg, scrReg and flags are killed</span>
<span class="line-removed">-       branch_on_random_using_rdtsc(tmpReg, scrReg, RTMTotalCountIncrRate, L_noincrement);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     assert(rtm_counters != NULL, &quot;should not be NULL when profiling RTM&quot;);</span>
<span class="line-removed">-     atomic_incptr(ExternalAddress((address)rtm_counters-&gt;total_count_addr()), scrReg);</span>
<span class="line-removed">-     bind(L_noincrement);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   xbegin(L_on_abort);</span>
<span class="line-removed">-   movptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes()));</span>
<span class="line-removed">-   movptr(tmpReg, Address(tmpReg, owner_offset));</span>
<span class="line-removed">-   testptr(tmpReg, tmpReg);</span>
<span class="line-removed">-   jcc(Assembler::zero, DONE_LABEL);</span>
<span class="line-removed">-   if (UseRTMXendForLockBusy) {</span>
<span class="line-removed">-     xend();</span>
<span class="line-removed">-     jmp(L_decrement_retry);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   else {</span>
<span class="line-removed">-     xabort(0);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   bind(L_on_abort);</span>
<span class="line-removed">-   Register abort_status_Reg = tmpReg; // status of abort is stored in RAX</span>
<span class="line-removed">-   if (PrintPreciseRTMLockingStatistics || profile_rtm) {</span>
<span class="line-removed">-     rtm_profiling(abort_status_Reg, scrReg, rtm_counters, method_data, profile_rtm);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   if (RTMRetryCount &gt; 0) {</span>
<span class="line-removed">-     // retry on lock abort if abort status is &#39;can retry&#39; (0x2) or &#39;memory conflict&#39; (0x4)</span>
<span class="line-removed">-     rtm_retry_lock_on_abort(retry_on_abort_count_Reg, abort_status_Reg, L_rtm_retry);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   movptr(tmpReg, Address(boxReg, owner_offset)) ;</span>
<span class="line-removed">-   testptr(tmpReg, tmpReg) ;</span>
<span class="line-removed">-   jccb(Assembler::notZero, L_decrement_retry) ;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Appears unlocked - try to swing _owner from null to non-null.</span>
<span class="line-removed">-   // Invariant: tmpReg == 0.  tmpReg is EAX which is the implicit cmpxchg comparand.</span>
<span class="line-removed">- #ifdef _LP64</span>
<span class="line-removed">-   Register threadReg = r15_thread;</span>
<span class="line-removed">- #else</span>
<span class="line-removed">-   get_thread(scrReg);</span>
<span class="line-removed">-   Register threadReg = scrReg;</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">-   lock();</span>
<span class="line-removed">-   cmpxchgptr(threadReg, Address(boxReg, owner_offset)); // Updates tmpReg</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (RTMRetryCount &gt; 0) {</span>
<span class="line-removed">-     // success done else retry</span>
<span class="line-removed">-     jccb(Assembler::equal, DONE_LABEL) ;</span>
<span class="line-removed">-     bind(L_decrement_retry);</span>
<span class="line-removed">-     // Spin and retry if lock is busy.</span>
<span class="line-removed">-     rtm_retry_lock_on_busy(retry_on_busy_count_Reg, boxReg, tmpReg, scrReg, L_rtm_retry);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   else {</span>
<span class="line-removed">-     bind(L_decrement_retry);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- #endif //  INCLUDE_RTM_OPT</span>
<span class="line-removed">- </span>
<span class="line-removed">- // fast_lock and fast_unlock used by C2</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Because the transitions from emitted code to the runtime</span>
<span class="line-removed">- // monitorenter/exit helper stubs are so slow it&#39;s critical that</span>
<span class="line-removed">- // we inline both the stack-locking fast path and the inflated fast path.</span>
<span class="line-removed">- //</span>
<span class="line-removed">- // See also: cmpFastLock and cmpFastUnlock.</span>
<span class="line-removed">- //</span>
<span class="line-removed">- // What follows is a specialized inline transliteration of the code</span>
<span class="line-removed">- // in enter() and exit(). If we&#39;re concerned about I$ bloat another</span>
<span class="line-removed">- // option would be to emit TrySlowEnter and TrySlowExit methods</span>
<span class="line-removed">- // at startup-time.  These methods would accept arguments as</span>
<span class="line-removed">- // (rax,=Obj, rbx=Self, rcx=box, rdx=Scratch) and return success-failure</span>
<span class="line-removed">- // indications in the icc.ZFlag.  fast_lock and fast_unlock would simply</span>
<span class="line-removed">- // marshal the arguments and emit calls to TrySlowEnter and TrySlowExit.</span>
<span class="line-removed">- // In practice, however, the # of lock sites is bounded and is usually small.</span>
<span class="line-removed">- // Besides the call overhead, TrySlowEnter and TrySlowExit might suffer</span>
<span class="line-removed">- // if the processor uses simple bimodal branch predictors keyed by EIP</span>
<span class="line-removed">- // Since the helper routines would be called from multiple synchronization</span>
<span class="line-removed">- // sites.</span>
<span class="line-removed">- //</span>
<span class="line-removed">- // An even better approach would be write &quot;MonitorEnter()&quot; and &quot;MonitorExit()&quot;</span>
<span class="line-removed">- // in java - using j.u.c and unsafe - and just bind the lock and unlock sites</span>
<span class="line-removed">- // to those specialized methods.  That&#39;d give us a mostly platform-independent</span>
<span class="line-removed">- // implementation that the JITs could optimize and inline at their pleasure.</span>
<span class="line-removed">- // Done correctly, the only time we&#39;d need to cross to native could would be</span>
<span class="line-removed">- // to park() or unpark() threads.  We&#39;d also need a few more unsafe operators</span>
<span class="line-removed">- // to (a) prevent compiler-JIT reordering of non-volatile accesses, and</span>
<span class="line-removed">- // (b) explicit barriers or fence operations.</span>
<span class="line-removed">- //</span>
<span class="line-removed">- // TODO:</span>
<span class="line-removed">- //</span>
<span class="line-removed">- // *  Arrange for C2 to pass &quot;Self&quot; into fast_lock and fast_unlock in one of the registers (scr).</span>
<span class="line-removed">- //    This avoids manifesting the Self pointer in the fast_lock and fast_unlock terminals.</span>
<span class="line-removed">- //    Given TLAB allocation, Self is usually manifested in a register, so passing it into</span>
<span class="line-removed">- //    the lock operators would typically be faster than reifying Self.</span>
<span class="line-removed">- //</span>
<span class="line-removed">- // *  Ideally I&#39;d define the primitives as:</span>
<span class="line-removed">- //       fast_lock   (nax Obj, nax box, EAX tmp, nax scr) where box, tmp and scr are KILLED.</span>
<span class="line-removed">- //       fast_unlock (nax Obj, EAX box, nax tmp) where box and tmp are KILLED</span>
<span class="line-removed">- //    Unfortunately ADLC bugs prevent us from expressing the ideal form.</span>
<span class="line-removed">- //    Instead, we&#39;re stuck with a rather awkward and brittle register assignments below.</span>
<span class="line-removed">- //    Furthermore the register assignments are overconstrained, possibly resulting in</span>
<span class="line-removed">- //    sub-optimal code near the synchronization site.</span>
<span class="line-removed">- //</span>
<span class="line-removed">- // *  Eliminate the sp-proximity tests and just use &quot;== Self&quot; tests instead.</span>
<span class="line-removed">- //    Alternately, use a better sp-proximity test.</span>
<span class="line-removed">- //</span>
<span class="line-removed">- // *  Currently ObjectMonitor._Owner can hold either an sp value or a (THREAD *) value.</span>
<span class="line-removed">- //    Either one is sufficient to uniquely identify a thread.</span>
<span class="line-removed">- //    TODO: eliminate use of sp in _owner and use get_thread(tr) instead.</span>
<span class="line-removed">- //</span>
<span class="line-removed">- // *  Intrinsify notify() and notifyAll() for the common cases where the</span>
<span class="line-removed">- //    object is locked by the calling thread but the waitlist is empty.</span>
<span class="line-removed">- //    avoid the expensive JNI call to JVM_Notify() and JVM_NotifyAll().</span>
<span class="line-removed">- //</span>
<span class="line-removed">- // *  use jccb and jmpb instead of jcc and jmp to improve code density.</span>
<span class="line-removed">- //    But beware of excessive branch density on AMD Opterons.</span>
<span class="line-removed">- //</span>
<span class="line-removed">- // *  Both fast_lock and fast_unlock set the ICC.ZF to indicate success</span>
<span class="line-removed">- //    or failure of the fast path.  If the fast path fails then we pass</span>
<span class="line-removed">- //    control to the slow path, typically in C.  In fast_lock and</span>
<span class="line-removed">- //    fast_unlock we often branch to DONE_LABEL, just to find that C2</span>
<span class="line-removed">- //    will emit a conditional branch immediately after the node.</span>
<span class="line-removed">- //    So we have branches to branches and lots of ICC.ZF games.</span>
<span class="line-removed">- //    Instead, it might be better to have C2 pass a &quot;FailureLabel&quot;</span>
<span class="line-removed">- //    into fast_lock and fast_unlock.  In the case of success, control</span>
<span class="line-removed">- //    will drop through the node.  ICC.ZF is undefined at exit.</span>
<span class="line-removed">- //    In the case of failure, the node will branch directly to the</span>
<span class="line-removed">- //    FailureLabel</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
<span class="line-removed">- // obj: object to lock</span>
<span class="line-removed">- // box: on-stack box address (displaced header location) - KILLED</span>
<span class="line-removed">- // rax,: tmp -- KILLED</span>
<span class="line-removed">- // scr: tmp -- KILLED</span>
<span class="line-removed">- void MacroAssembler::fast_lock(Register objReg, Register boxReg, Register tmpReg,</span>
<span class="line-removed">-                                Register scrReg, Register cx1Reg, Register cx2Reg,</span>
<span class="line-removed">-                                BiasedLockingCounters* counters,</span>
<span class="line-removed">-                                RTMLockingCounters* rtm_counters,</span>
<span class="line-removed">-                                RTMLockingCounters* stack_rtm_counters,</span>
<span class="line-removed">-                                Metadata* method_data,</span>
<span class="line-removed">-                                bool use_rtm, bool profile_rtm) {</span>
<span class="line-removed">-   // Ensure the register assignments are disjoint</span>
<span class="line-removed">-   assert(tmpReg == rax, &quot;&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (use_rtm) {</span>
<span class="line-removed">-     assert_different_registers(objReg, boxReg, tmpReg, scrReg, cx1Reg, cx2Reg);</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     assert(cx1Reg == noreg, &quot;&quot;);</span>
<span class="line-removed">-     assert(cx2Reg == noreg, &quot;&quot;);</span>
<span class="line-removed">-     assert_different_registers(objReg, boxReg, tmpReg, scrReg);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (counters != NULL) {</span>
<span class="line-removed">-     atomic_incl(ExternalAddress((address)counters-&gt;total_entry_count_addr()), scrReg);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Possible cases that we&#39;ll encounter in fast_lock</span>
<span class="line-removed">-   // ------------------------------------------------</span>
<span class="line-removed">-   // * Inflated</span>
<span class="line-removed">-   //    -- unlocked</span>
<span class="line-removed">-   //    -- Locked</span>
<span class="line-removed">-   //       = by self</span>
<span class="line-removed">-   //       = by other</span>
<span class="line-removed">-   // * biased</span>
<span class="line-removed">-   //    -- by Self</span>
<span class="line-removed">-   //    -- by other</span>
<span class="line-removed">-   // * neutral</span>
<span class="line-removed">-   // * stack-locked</span>
<span class="line-removed">-   //    -- by self</span>
<span class="line-removed">-   //       = sp-proximity test hits</span>
<span class="line-removed">-   //       = sp-proximity test generates false-negative</span>
<span class="line-removed">-   //    -- by other</span>
<span class="line-removed">-   //</span>
<span class="line-removed">- </span>
<span class="line-removed">-   Label IsInflated, DONE_LABEL;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // it&#39;s stack-locked, biased or neutral</span>
<span class="line-removed">-   // TODO: optimize away redundant LDs of obj-&gt;mark and improve the markword triage</span>
<span class="line-removed">-   // order to reduce the number of conditional branches in the most common cases.</span>
<span class="line-removed">-   // Beware -- there&#39;s a subtle invariant that fetch of the markword</span>
<span class="line-removed">-   // at [FETCH], below, will never observe a biased encoding (*101b).</span>
<span class="line-removed">-   // If this invariant is not held we risk exclusion (safety) failure.</span>
<span class="line-removed">-   if (UseBiasedLocking &amp;&amp; !UseOptoBiasInlining) {</span>
<span class="line-removed">-     biased_locking_enter(boxReg, objReg, tmpReg, scrReg, false, DONE_LABEL, NULL, counters);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">- #if INCLUDE_RTM_OPT</span>
<span class="line-removed">-   if (UseRTMForStackLocks &amp;&amp; use_rtm) {</span>
<span class="line-removed">-     rtm_stack_locking(objReg, tmpReg, scrReg, cx2Reg,</span>
<span class="line-removed">-                       stack_rtm_counters, method_data, profile_rtm,</span>
<span class="line-removed">-                       DONE_LABEL, IsInflated);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- #endif // INCLUDE_RTM_OPT</span>
<span class="line-removed">- </span>
<span class="line-removed">-   movptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes()));          // [FETCH]</span>
<span class="line-removed">-   testptr(tmpReg, markWord::monitor_value); // inflated vs stack-locked|neutral|biased</span>
<span class="line-removed">-   jccb(Assembler::notZero, IsInflated);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Attempt stack-locking ...</span>
<span class="line-removed">-   orptr (tmpReg, markWord::unlocked_value);</span>
<span class="line-removed">-   movptr(Address(boxReg, 0), tmpReg);          // Anticipate successful CAS</span>
<span class="line-removed">-   lock();</span>
<span class="line-removed">-   cmpxchgptr(boxReg, Address(objReg, oopDesc::mark_offset_in_bytes()));      // Updates tmpReg</span>
<span class="line-removed">-   if (counters != NULL) {</span>
<span class="line-removed">-     cond_inc32(Assembler::equal,</span>
<span class="line-removed">-                ExternalAddress((address)counters-&gt;fast_path_entry_count_addr()));</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   jcc(Assembler::equal, DONE_LABEL);           // Success</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Recursive locking.</span>
<span class="line-removed">-   // The object is stack-locked: markword contains stack pointer to BasicLock.</span>
<span class="line-removed">-   // Locked by current thread if difference with current SP is less than one page.</span>
<span class="line-removed">-   subptr(tmpReg, rsp);</span>
<span class="line-removed">-   // Next instruction set ZFlag == 1 (Success) if difference is less then one page.</span>
<span class="line-removed">-   andptr(tmpReg, (int32_t) (NOT_LP64(0xFFFFF003) LP64_ONLY(7 - os::vm_page_size())) );</span>
<span class="line-removed">-   movptr(Address(boxReg, 0), tmpReg);</span>
<span class="line-removed">-   if (counters != NULL) {</span>
<span class="line-removed">-     cond_inc32(Assembler::equal,</span>
<span class="line-removed">-                ExternalAddress((address)counters-&gt;fast_path_entry_count_addr()));</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   jmp(DONE_LABEL);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   bind(IsInflated);</span>
<span class="line-removed">-   // The object is inflated. tmpReg contains pointer to ObjectMonitor* + markWord::monitor_value</span>
<span class="line-removed">- </span>
<span class="line-removed">- #if INCLUDE_RTM_OPT</span>
<span class="line-removed">-   // Use the same RTM locking code in 32- and 64-bit VM.</span>
<span class="line-removed">-   if (use_rtm) {</span>
<span class="line-removed">-     rtm_inflated_locking(objReg, boxReg, tmpReg, scrReg, cx1Reg, cx2Reg,</span>
<span class="line-removed">-                          rtm_counters, method_data, profile_rtm, DONE_LABEL);</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">- #endif // INCLUDE_RTM_OPT</span>
<span class="line-removed">- </span>
<span class="line-removed">- #ifndef _LP64</span>
<span class="line-removed">-   // The object is inflated.</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // boxReg refers to the on-stack BasicLock in the current frame.</span>
<span class="line-removed">-   // We&#39;d like to write:</span>
<span class="line-removed">-   //   set box-&gt;_displaced_header = markWord::unused_mark().  Any non-0 value suffices.</span>
<span class="line-removed">-   // This is convenient but results a ST-before-CAS penalty.  The following CAS suffers</span>
<span class="line-removed">-   // additional latency as we have another ST in the store buffer that must drain.</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // avoid ST-before-CAS</span>
<span class="line-removed">-   // register juggle because we need tmpReg for cmpxchgptr below</span>
<span class="line-removed">-   movptr(scrReg, boxReg);</span>
<span class="line-removed">-   movptr(boxReg, tmpReg);                   // consider: LEA box, [tmp-2]</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Optimistic form: consider XORL tmpReg,tmpReg</span>
<span class="line-removed">-   movptr(tmpReg, NULL_WORD);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Appears unlocked - try to swing _owner from null to non-null.</span>
<span class="line-removed">-   // Ideally, I&#39;d manifest &quot;Self&quot; with get_thread and then attempt</span>
<span class="line-removed">-   // to CAS the register containing Self into m-&gt;Owner.</span>
<span class="line-removed">-   // But we don&#39;t have enough registers, so instead we can either try to CAS</span>
<span class="line-removed">-   // rsp or the address of the box (in scr) into &amp;m-&gt;owner.  If the CAS succeeds</span>
<span class="line-removed">-   // we later store &quot;Self&quot; into m-&gt;Owner.  Transiently storing a stack address</span>
<span class="line-removed">-   // (rsp or the address of the box) into  m-&gt;owner is harmless.</span>
<span class="line-removed">-   // Invariant: tmpReg == 0.  tmpReg is EAX which is the implicit cmpxchg comparand.</span>
<span class="line-removed">-   lock();</span>
<span class="line-removed">-   cmpxchgptr(scrReg, Address(boxReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));</span>
<span class="line-removed">-   movptr(Address(scrReg, 0), 3);          // box-&gt;_displaced_header = 3</span>
<span class="line-removed">-   // If we weren&#39;t able to swing _owner from NULL to the BasicLock</span>
<span class="line-removed">-   // then take the slow path.</span>
<span class="line-removed">-   jccb  (Assembler::notZero, DONE_LABEL);</span>
<span class="line-removed">-   // update _owner from BasicLock to thread</span>
<span class="line-removed">-   get_thread (scrReg);                    // beware: clobbers ICCs</span>
<span class="line-removed">-   movptr(Address(boxReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)), scrReg);</span>
<span class="line-removed">-   xorptr(boxReg, boxReg);                 // set icc.ZFlag = 1 to indicate success</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // If the CAS fails we can either retry or pass control to the slow path.</span>
<span class="line-removed">-   // We use the latter tactic.</span>
<span class="line-removed">-   // Pass the CAS result in the icc.ZFlag into DONE_LABEL</span>
<span class="line-removed">-   // If the CAS was successful ...</span>
<span class="line-removed">-   //   Self has acquired the lock</span>
<span class="line-removed">-   //   Invariant: m-&gt;_recursions should already be 0, so we don&#39;t need to explicitly set it.</span>
<span class="line-removed">-   // Intentional fall-through into DONE_LABEL ...</span>
<span class="line-removed">- #else // _LP64</span>
<span class="line-removed">-   // It&#39;s inflated and we use scrReg for ObjectMonitor* in this section.</span>
<span class="line-removed">-   movq(scrReg, tmpReg);</span>
<span class="line-removed">-   xorq(tmpReg, tmpReg);</span>
<span class="line-removed">-   lock();</span>
<span class="line-removed">-   cmpxchgptr(r15_thread, Address(scrReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));</span>
<span class="line-removed">-   // Unconditionally set box-&gt;_displaced_header = markWord::unused_mark().</span>
<span class="line-removed">-   // Without cast to int32_t this style of movptr will destroy r10 which is typically obj.</span>
<span class="line-removed">-   movptr(Address(boxReg, 0), (int32_t)intptr_t(markWord::unused_mark().value()));</span>
<span class="line-removed">-   // Intentional fall-through into DONE_LABEL ...</span>
<span class="line-removed">-   // Propagate ICC.ZF from CAS above into DONE_LABEL.</span>
<span class="line-removed">- #endif // _LP64</span>
<span class="line-removed">- #if INCLUDE_RTM_OPT</span>
<span class="line-removed">-   } // use_rtm()</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">-   // DONE_LABEL is a hot target - we&#39;d really like to place it at the</span>
<span class="line-removed">-   // start of cache line by padding with NOPs.</span>
<span class="line-removed">-   // See the AMD and Intel software optimization manuals for the</span>
<span class="line-removed">-   // most efficient &quot;long&quot; NOP encodings.</span>
<span class="line-removed">-   // Unfortunately none of our alignment mechanisms suffice.</span>
<span class="line-removed">-   bind(DONE_LABEL);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // At DONE_LABEL the icc ZFlag is set as follows ...</span>
<span class="line-removed">-   // fast_unlock uses the same protocol.</span>
<span class="line-removed">-   // ZFlag == 1 -&gt; Success</span>
<span class="line-removed">-   // ZFlag == 0 -&gt; Failure - force control through the slow path</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- // obj: object to unlock</span>
<span class="line-removed">- // box: box address (displaced header location), killed.  Must be EAX.</span>
<span class="line-removed">- // tmp: killed, cannot be obj nor box.</span>
<span class="line-removed">- //</span>
<span class="line-removed">- // Some commentary on balanced locking:</span>
<span class="line-removed">- //</span>
<span class="line-removed">- // fast_lock and fast_unlock are emitted only for provably balanced lock sites.</span>
<span class="line-removed">- // Methods that don&#39;t have provably balanced locking are forced to run in the</span>
<span class="line-removed">- // interpreter - such methods won&#39;t be compiled to use fast_lock and fast_unlock.</span>
<span class="line-removed">- // The interpreter provides two properties:</span>
<span class="line-removed">- // I1:  At return-time the interpreter automatically and quietly unlocks any</span>
<span class="line-removed">- //      objects acquired the current activation (frame).  Recall that the</span>
<span class="line-removed">- //      interpreter maintains an on-stack list of locks currently held by</span>
<span class="line-removed">- //      a frame.</span>
<span class="line-removed">- // I2:  If a method attempts to unlock an object that is not held by the</span>
<span class="line-removed">- //      the frame the interpreter throws IMSX.</span>
<span class="line-removed">- //</span>
<span class="line-removed">- // Lets say A(), which has provably balanced locking, acquires O and then calls B().</span>
<span class="line-removed">- // B() doesn&#39;t have provably balanced locking so it runs in the interpreter.</span>
<span class="line-removed">- // Control returns to A() and A() unlocks O.  By I1 and I2, above, we know that O</span>
<span class="line-removed">- // is still locked by A().</span>
<span class="line-removed">- //</span>
<span class="line-removed">- // The only other source of unbalanced locking would be JNI.  The &quot;Java Native Interface:</span>
<span class="line-removed">- // Programmer&#39;s Guide and Specification&quot; claims that an object locked by jni_monitorenter</span>
<span class="line-removed">- // should not be unlocked by &quot;normal&quot; java-level locking and vice-versa.  The specification</span>
<span class="line-removed">- // doesn&#39;t specify what will occur if a program engages in such mixed-mode locking, however.</span>
<span class="line-removed">- // Arguably given that the spec legislates the JNI case as undefined our implementation</span>
<span class="line-removed">- // could reasonably *avoid* checking owner in fast_unlock().</span>
<span class="line-removed">- // In the interest of performance we elide m-&gt;Owner==Self check in unlock.</span>
<span class="line-removed">- // A perfectly viable alternative is to elide the owner check except when</span>
<span class="line-removed">- // Xcheck:jni is enabled.</span>
<span class="line-removed">- </span>
<span class="line-removed">- void MacroAssembler::fast_unlock(Register objReg, Register boxReg, Register tmpReg, bool use_rtm) {</span>
<span class="line-removed">-   assert(boxReg == rax, &quot;&quot;);</span>
<span class="line-removed">-   assert_different_registers(objReg, boxReg, tmpReg);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   Label DONE_LABEL, Stacked, CheckSucc;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Critically, the biased locking test must have precedence over</span>
<span class="line-removed">-   // and appear before the (box-&gt;dhw == 0) recursive stack-lock test.</span>
<span class="line-removed">-   if (UseBiasedLocking &amp;&amp; !UseOptoBiasInlining) {</span>
<span class="line-removed">-     biased_locking_exit(objReg, tmpReg, DONE_LABEL);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">- #if INCLUDE_RTM_OPT</span>
<span class="line-removed">-   if (UseRTMForStackLocks &amp;&amp; use_rtm) {</span>
<span class="line-removed">-     assert(!UseBiasedLocking, &quot;Biased locking is not supported with RTM locking&quot;);</span>
<span class="line-removed">-     Label L_regular_unlock;</span>
<span class="line-removed">-     movptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes())); // fetch markword</span>
<span class="line-removed">-     andptr(tmpReg, markWord::biased_lock_mask_in_place);              // look at 3 lock bits</span>
<span class="line-removed">-     cmpptr(tmpReg, markWord::unlocked_value);                         // bits = 001 unlocked</span>
<span class="line-removed">-     jccb(Assembler::notEqual, L_regular_unlock);                      // if !HLE RegularLock</span>
<span class="line-removed">-     xend();                                                           // otherwise end...</span>
<span class="line-removed">-     jmp(DONE_LABEL);                                                  // ... and we&#39;re done</span>
<span class="line-removed">-     bind(L_regular_unlock);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
<span class="line-removed">-   cmpptr(Address(boxReg, 0), (int32_t)NULL_WORD);                   // Examine the displaced header</span>
<span class="line-removed">-   jcc   (Assembler::zero, DONE_LABEL);                              // 0 indicates recursive stack-lock</span>
<span class="line-removed">-   movptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes())); // Examine the object&#39;s markword</span>
<span class="line-removed">-   testptr(tmpReg, markWord::monitor_value);                         // Inflated?</span>
<span class="line-removed">-   jccb  (Assembler::zero, Stacked);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // It&#39;s inflated.</span>
<span class="line-removed">- #if INCLUDE_RTM_OPT</span>
<span class="line-removed">-   if (use_rtm) {</span>
<span class="line-removed">-     Label L_regular_inflated_unlock;</span>
<span class="line-removed">-     int owner_offset = OM_OFFSET_NO_MONITOR_VALUE_TAG(owner);</span>
<span class="line-removed">-     movptr(boxReg, Address(tmpReg, owner_offset));</span>
<span class="line-removed">-     testptr(boxReg, boxReg);</span>
<span class="line-removed">-     jccb(Assembler::notZero, L_regular_inflated_unlock);</span>
<span class="line-removed">-     xend();</span>
<span class="line-removed">-     jmpb(DONE_LABEL);</span>
<span class="line-removed">-     bind(L_regular_inflated_unlock);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Despite our balanced locking property we still check that m-&gt;_owner == Self</span>
<span class="line-removed">-   // as java routines or native JNI code called by this thread might</span>
<span class="line-removed">-   // have released the lock.</span>
<span class="line-removed">-   // Refer to the comments in synchronizer.cpp for how we might encode extra</span>
<span class="line-removed">-   // state in _succ so we can avoid fetching EntryList|cxq.</span>
<span class="line-removed">-   //</span>
<span class="line-removed">-   // I&#39;d like to add more cases in fast_lock() and fast_unlock() --</span>
<span class="line-removed">-   // such as recursive enter and exit -- but we have to be wary of</span>
<span class="line-removed">-   // I$ bloat, T$ effects and BP$ effects.</span>
<span class="line-removed">-   //</span>
<span class="line-removed">-   // If there&#39;s no contention try a 1-0 exit.  That is, exit without</span>
<span class="line-removed">-   // a costly MEMBAR or CAS.  See synchronizer.cpp for details on how</span>
<span class="line-removed">-   // we detect and recover from the race that the 1-0 exit admits.</span>
<span class="line-removed">-   //</span>
<span class="line-removed">-   // Conceptually fast_unlock() must execute a STST|LDST &quot;release&quot; barrier</span>
<span class="line-removed">-   // before it STs null into _owner, releasing the lock.  Updates</span>
<span class="line-removed">-   // to data protected by the critical section must be visible before</span>
<span class="line-removed">-   // we drop the lock (and thus before any other thread could acquire</span>
<span class="line-removed">-   // the lock and observe the fields protected by the lock).</span>
<span class="line-removed">-   // IA32&#39;s memory-model is SPO, so STs are ordered with respect to</span>
<span class="line-removed">-   // each other and there&#39;s no need for an explicit barrier (fence).</span>
<span class="line-removed">-   // See also http://gee.cs.oswego.edu/dl/jmm/cookbook.html.</span>
<span class="line-removed">- #ifndef _LP64</span>
<span class="line-removed">-   get_thread (boxReg);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Note that we could employ various encoding schemes to reduce</span>
<span class="line-removed">-   // the number of loads below (currently 4) to just 2 or 3.</span>
<span class="line-removed">-   // Refer to the comments in synchronizer.cpp.</span>
<span class="line-removed">-   // In practice the chain of fetches doesn&#39;t seem to impact performance, however.</span>
<span class="line-removed">-   xorptr(boxReg, boxReg);</span>
<span class="line-removed">-   orptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));</span>
<span class="line-removed">-   jccb  (Assembler::notZero, DONE_LABEL);</span>
<span class="line-removed">-   movptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(EntryList)));</span>
<span class="line-removed">-   orptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(cxq)));</span>
<span class="line-removed">-   jccb  (Assembler::notZero, CheckSucc);</span>
<span class="line-removed">-   movptr(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)), NULL_WORD);</span>
<span class="line-removed">-   jmpb  (DONE_LABEL);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   bind (Stacked);</span>
<span class="line-removed">-   // It&#39;s not inflated and it&#39;s not recursively stack-locked and it&#39;s not biased.</span>
<span class="line-removed">-   // It must be stack-locked.</span>
<span class="line-removed">-   // Try to reset the header to displaced header.</span>
<span class="line-removed">-   // The &quot;box&quot; value on the stack is stable, so we can reload</span>
<span class="line-removed">-   // and be assured we observe the same value as above.</span>
<span class="line-removed">-   movptr(tmpReg, Address(boxReg, 0));</span>
<span class="line-removed">-   lock();</span>
<span class="line-removed">-   cmpxchgptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes())); // Uses RAX which is box</span>
<span class="line-removed">-   // Intention fall-thru into DONE_LABEL</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // DONE_LABEL is a hot target - we&#39;d really like to place it at the</span>
<span class="line-removed">-   // start of cache line by padding with NOPs.</span>
<span class="line-removed">-   // See the AMD and Intel software optimization manuals for the</span>
<span class="line-removed">-   // most efficient &quot;long&quot; NOP encodings.</span>
<span class="line-removed">-   // Unfortunately none of our alignment mechanisms suffice.</span>
<span class="line-removed">-   bind (CheckSucc);</span>
<span class="line-removed">- #else // _LP64</span>
<span class="line-removed">-   // It&#39;s inflated</span>
<span class="line-removed">-   xorptr(boxReg, boxReg);</span>
<span class="line-removed">-   orptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));</span>
<span class="line-removed">-   jccb  (Assembler::notZero, DONE_LABEL);</span>
<span class="line-removed">-   movptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(cxq)));</span>
<span class="line-removed">-   orptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(EntryList)));</span>
<span class="line-removed">-   jccb  (Assembler::notZero, CheckSucc);</span>
<span class="line-removed">-   // Without cast to int32_t this style of movptr will destroy r10 which is typically obj.</span>
<span class="line-removed">-   movptr(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)), (int32_t)NULL_WORD);</span>
<span class="line-removed">-   jmpb  (DONE_LABEL);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Try to avoid passing control into the slow_path ...</span>
<span class="line-removed">-   Label LSuccess, LGoSlowPath ;</span>
<span class="line-removed">-   bind  (CheckSucc);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // The following optional optimization can be elided if necessary</span>
<span class="line-removed">-   // Effectively: if (succ == null) goto slow path</span>
<span class="line-removed">-   // The code reduces the window for a race, however,</span>
<span class="line-removed">-   // and thus benefits performance.</span>
<span class="line-removed">-   cmpptr(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(succ)), (int32_t)NULL_WORD);</span>
<span class="line-removed">-   jccb  (Assembler::zero, LGoSlowPath);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   xorptr(boxReg, boxReg);</span>
<span class="line-removed">-   // Without cast to int32_t this style of movptr will destroy r10 which is typically obj.</span>
<span class="line-removed">-   movptr(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)), (int32_t)NULL_WORD);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Memory barrier/fence</span>
<span class="line-removed">-   // Dekker pivot point -- fulcrum : ST Owner; MEMBAR; LD Succ</span>
<span class="line-removed">-   // Instead of MFENCE we use a dummy locked add of 0 to the top-of-stack.</span>
<span class="line-removed">-   // This is faster on Nehalem and AMD Shanghai/Barcelona.</span>
<span class="line-removed">-   // See https://blogs.oracle.com/dave/entry/instruction_selection_for_volatile_fences</span>
<span class="line-removed">-   // We might also restructure (ST Owner=0;barrier;LD _Succ) to</span>
<span class="line-removed">-   // (mov box,0; xchgq box, &amp;m-&gt;Owner; LD _succ) .</span>
<span class="line-removed">-   lock(); addl(Address(rsp, 0), 0);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   cmpptr(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(succ)), (int32_t)NULL_WORD);</span>
<span class="line-removed">-   jccb  (Assembler::notZero, LSuccess);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Rare inopportune interleaving - race.</span>
<span class="line-removed">-   // The successor vanished in the small window above.</span>
<span class="line-removed">-   // The lock is contended -- (cxq|EntryList) != null -- and there&#39;s no apparent successor.</span>
<span class="line-removed">-   // We need to ensure progress and succession.</span>
<span class="line-removed">-   // Try to reacquire the lock.</span>
<span class="line-removed">-   // If that fails then the new owner is responsible for succession and this</span>
<span class="line-removed">-   // thread needs to take no further action and can exit via the fast path (success).</span>
<span class="line-removed">-   // If the re-acquire succeeds then pass control into the slow path.</span>
<span class="line-removed">-   // As implemented, this latter mode is horrible because we generated more</span>
<span class="line-removed">-   // coherence traffic on the lock *and* artifically extended the critical section</span>
<span class="line-removed">-   // length while by virtue of passing control into the slow path.</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // box is really RAX -- the following CMPXCHG depends on that binding</span>
<span class="line-removed">-   // cmpxchg R,[M] is equivalent to rax = CAS(M,rax,R)</span>
<span class="line-removed">-   lock();</span>
<span class="line-removed">-   cmpxchgptr(r15_thread, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));</span>
<span class="line-removed">-   // There&#39;s no successor so we tried to regrab the lock.</span>
<span class="line-removed">-   // If that didn&#39;t work, then another thread grabbed the</span>
<span class="line-removed">-   // lock so we&#39;re done (and exit was a success).</span>
<span class="line-removed">-   jccb  (Assembler::notEqual, LSuccess);</span>
<span class="line-removed">-   // Intentional fall-through into slow path</span>
<span class="line-removed">- </span>
<span class="line-removed">-   bind  (LGoSlowPath);</span>
<span class="line-removed">-   orl   (boxReg, 1);                      // set ICC.ZF=0 to indicate failure</span>
<span class="line-removed">-   jmpb  (DONE_LABEL);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   bind  (LSuccess);</span>
<span class="line-removed">-   testl (boxReg, 0);                      // set ICC.ZF=1 to indicate success</span>
<span class="line-removed">-   jmpb  (DONE_LABEL);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   bind  (Stacked);</span>
<span class="line-removed">-   movptr(tmpReg, Address (boxReg, 0));      // re-fetch</span>
<span class="line-removed">-   lock();</span>
<span class="line-removed">-   cmpxchgptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes())); // Uses RAX which is box</span>
<span class="line-removed">- </span>
<span class="line-removed">- #endif</span>
<span class="line-removed">-   bind(DONE_LABEL);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- #endif // COMPILER2</span>
<span class="line-removed">- </span>
  void MacroAssembler::c2bool(Register x) {
    // implements x == 0 ? 0 : 1
    // note: must only look at least-significant byte of x
    //       since C-style booleans are stored in one byte
    //       only! (was bug)
<span class="line-new-header">--- 1278,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2722,21 ***</span>
      lea(rscratch1, src);
      Assembler::divss(dst, Address(rscratch1, 0));
    }
  }
  
<span class="line-removed">- #ifndef _LP64</span>
<span class="line-removed">- void MacroAssembler::empty_FPU_stack() {</span>
<span class="line-removed">-   if (VM_Version::supports_mmx()) {</span>
<span class="line-removed">-     emms();</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     for (int i = 8; i-- &gt; 0; ) ffree(i);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- #endif // !LP64</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
  void MacroAssembler::enter() {
    push(rbp);
    mov(rbp, rsp);
  }
  
<span class="line-new-header">--- 1953,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2751,11 ***</span>
      emit_int8(0x65); // gs:
      emit_int8((unsigned char)0x90);
    }
  }
  
<span class="line-modified">! #if !defined(_LP64)</span>
  void MacroAssembler::fcmp(Register tmp) {
    fcmp(tmp, 1, true, true);
  }
  
  void MacroAssembler::fcmp(Register tmp, int index, bool pop_left, bool pop_right) {
<span class="line-new-header">--- 1971,11 ---</span>
      emit_int8(0x65); // gs:
      emit_int8((unsigned char)0x90);
    }
  }
  
<span class="line-modified">! #ifndef _LP64</span>
  void MacroAssembler::fcmp(Register tmp) {
    fcmp(tmp, 1, true, true);
  }
  
  void MacroAssembler::fcmp(Register tmp, int index, bool pop_left, bool pop_right) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2854,10 ***</span>
<span class="line-new-header">--- 2074,18 ---</span>
    // Note: fxch &amp; fpop to get rid of ST1
    // (otherwise FPU stack could overflow eventually)
    fxch(1);
    fpop();
  }
<span class="line-added">+ </span>
<span class="line-added">+ void MacroAssembler::empty_FPU_stack() {</span>
<span class="line-added">+   if (VM_Version::supports_mmx()) {</span>
<span class="line-added">+     emms();</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     for (int i = 8; i-- &gt; 0; ) ffree(i);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
  #endif // !LP64
  
  void MacroAssembler::mulpd(XMMRegister dst, AddressLiteral src) {
    if (reachable(src)) {
      Assembler::mulpd(dst, as_Address(src));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2866,43 ***</span>
      Assembler::mulpd(dst, Address(rscratch1, 0));
    }
  }
  
  void MacroAssembler::load_float(Address src) {
    if (UseSSE &gt;= 1) {
      movflt(xmm0, src);
    } else {
<span class="line-modified">!     LP64_ONLY(ShouldNotReachHere());</span>
<span class="line-removed">-     NOT_LP64(fld_s(src));</span>
    }
  }
  
  void MacroAssembler::store_float(Address dst) {
    if (UseSSE &gt;= 1) {
      movflt(dst, xmm0);
    } else {
<span class="line-modified">!     LP64_ONLY(ShouldNotReachHere());</span>
<span class="line-removed">-     NOT_LP64(fstp_s(dst));</span>
    }
  }
  
  void MacroAssembler::load_double(Address src) {
    if (UseSSE &gt;= 2) {
      movdbl(xmm0, src);
    } else {
<span class="line-modified">!     LP64_ONLY(ShouldNotReachHere());</span>
<span class="line-removed">-     NOT_LP64(fld_d(src));</span>
    }
  }
  
  void MacroAssembler::store_double(Address dst) {
    if (UseSSE &gt;= 2) {
      movdbl(dst, xmm0);
    } else {
<span class="line-modified">!     LP64_ONLY(ShouldNotReachHere());</span>
<span class="line-removed">-     NOT_LP64(fstp_d(dst));</span>
    }
  }
  
  // dst = c = a * b + c
  void MacroAssembler::fmad(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c) {
    Assembler::vfmadd231sd(c, a, b);
<span class="line-new-header">--- 2094,55 ---</span>
      Assembler::mulpd(dst, Address(rscratch1, 0));
    }
  }
  
  void MacroAssembler::load_float(Address src) {
<span class="line-added">+ #ifdef _LP64</span>
<span class="line-added">+   movflt(xmm0, src);</span>
<span class="line-added">+ #else</span>
    if (UseSSE &gt;= 1) {
      movflt(xmm0, src);
    } else {
<span class="line-modified">!     fld_s(src);</span>
    }
<span class="line-added">+ #endif // LP64</span>
  }
  
  void MacroAssembler::store_float(Address dst) {
<span class="line-added">+ #ifdef _LP64</span>
<span class="line-added">+   movflt(dst, xmm0);</span>
<span class="line-added">+ #else</span>
    if (UseSSE &gt;= 1) {
      movflt(dst, xmm0);
    } else {
<span class="line-modified">!     fstp_s(dst);</span>
    }
<span class="line-added">+ #endif // LP64</span>
  }
  
  void MacroAssembler::load_double(Address src) {
<span class="line-added">+ #ifdef _LP64</span>
<span class="line-added">+   movdbl(xmm0, src);</span>
<span class="line-added">+ #else</span>
    if (UseSSE &gt;= 2) {
      movdbl(xmm0, src);
    } else {
<span class="line-modified">!     fld_d(src);</span>
    }
<span class="line-added">+ #endif // LP64</span>
  }
  
  void MacroAssembler::store_double(Address dst) {
<span class="line-added">+ #ifdef _LP64</span>
<span class="line-added">+   movdbl(dst, xmm0);</span>
<span class="line-added">+ #else</span>
    if (UseSSE &gt;= 2) {
      movdbl(dst, xmm0);
    } else {
<span class="line-modified">!     fstp_d(dst);</span>
    }
<span class="line-added">+ #endif // LP64</span>
  }
  
  // dst = c = a * b + c
  void MacroAssembler::fmad(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c) {
    Assembler::vfmadd231sd(c, a, b);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3203,26 ***</span>
      lea(rscratch1, src);
      movq(dst, Address(rscratch1, 0));
    }
  }
  
<span class="line-removed">- #ifdef COMPILER2</span>
<span class="line-removed">- void MacroAssembler::setvectmask(Register dst, Register src) {</span>
<span class="line-removed">-   guarantee(PostLoopMultiversioning, &quot;must be&quot;);</span>
<span class="line-removed">-   Assembler::movl(dst, 1);</span>
<span class="line-removed">-   Assembler::shlxl(dst, dst, src);</span>
<span class="line-removed">-   Assembler::decl(dst);</span>
<span class="line-removed">-   Assembler::kmovdl(k1, dst);</span>
<span class="line-removed">-   Assembler::movl(dst, src);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void MacroAssembler::restorevectmask() {</span>
<span class="line-removed">-   guarantee(PostLoopMultiversioning, &quot;must be&quot;);</span>
<span class="line-removed">-   Assembler::knotwl(k1, k0);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- #endif // COMPILER2</span>
<span class="line-removed">- </span>
  void MacroAssembler::movdbl(XMMRegister dst, AddressLiteral src) {
    if (reachable(src)) {
      if (UseXmmLoadAndClearUpper) {
        movsd (dst, as_Address(src));
      } else {
<span class="line-new-header">--- 2443,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3479,26 ***</span>
    if (tmp == noreg) push(rax);
    else if (tmp != rax) mov(tmp, rax);
  }
  
  void MacroAssembler::safepoint_poll(Label&amp; slow_path, Register thread_reg, Register temp_reg) {
<span class="line-removed">-   if (SafepointMechanism::uses_thread_local_poll()) {</span>
  #ifdef _LP64
<span class="line-modified">!     assert(thread_reg == r15_thread, &quot;should be&quot;);</span>
  #else
<span class="line-modified">!     if (thread_reg == noreg) {</span>
<span class="line-modified">!       thread_reg = temp_reg;</span>
<span class="line-modified">!       get_thread(thread_reg);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">-     testb(Address(thread_reg, Thread::polling_page_offset()), SafepointMechanism::poll_bit());</span>
<span class="line-removed">-     jcc(Assembler::notZero, slow_path); // handshake bit set implies poll</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     cmp32(ExternalAddress(SafepointSynchronize::address_of_state()),</span>
<span class="line-removed">-         SafepointSynchronize::_not_synchronized);</span>
<span class="line-removed">-     jcc(Assembler::notEqual, slow_path);</span>
    }
  }
  
  // Calls to C land
  //
  // When entering C land, the rbp, &amp; rsp of the last Java frame have to be recorded
<span class="line-new-header">--- 2703,20 ---</span>
    if (tmp == noreg) push(rax);
    else if (tmp != rax) mov(tmp, rax);
  }
  
  void MacroAssembler::safepoint_poll(Label&amp; slow_path, Register thread_reg, Register temp_reg) {
  #ifdef _LP64
<span class="line-modified">!   assert(thread_reg == r15_thread, &quot;should be&quot;);</span>
  #else
<span class="line-modified">!   if (thread_reg == noreg) {</span>
<span class="line-modified">!     thread_reg = temp_reg;</span>
<span class="line-modified">!     get_thread(thread_reg);</span>
    }
<span class="line-added">+ #endif</span>
<span class="line-added">+   testb(Address(thread_reg, Thread::polling_page_offset()), SafepointMechanism::poll_bit());</span>
<span class="line-added">+   jcc(Assembler::notZero, slow_path); // handshake bit set implies poll</span>
  }
  
  // Calls to C land
  //
  // When entering C land, the rbp, &amp; rsp of the last Java frame have to be recorded
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4023,138 ***</span>
    else {
      MacroAssembler::vxorpd(dst, nds, src, vector_len, scratch_reg);
    }
  }
  
<span class="line-removed">- //-------------------------------------------------------------------------------------------</span>
<span class="line-removed">- #ifdef COMPILER2</span>
<span class="line-removed">- // Generic instructions support for use in .ad files C2 code generation</span>
<span class="line-removed">- </span>
<span class="line-removed">- void MacroAssembler::vabsnegd(int opcode, XMMRegister dst, XMMRegister src, Register scr) {</span>
<span class="line-removed">-   if (dst != src) {</span>
<span class="line-removed">-     movdqu(dst, src);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   if (opcode == Op_AbsVD) {</span>
<span class="line-removed">-     andpd(dst, ExternalAddress(StubRoutines::x86::vector_double_sign_mask()), scr);</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     assert((opcode == Op_NegVD),&quot;opcode should be Op_NegD&quot;);</span>
<span class="line-removed">-     xorpd(dst, ExternalAddress(StubRoutines::x86::vector_double_sign_flip()), scr);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void MacroAssembler::vabsnegd(int opcode, XMMRegister dst, XMMRegister src, int vector_len, Register scr) {</span>
<span class="line-removed">-   if (opcode == Op_AbsVD) {</span>
<span class="line-removed">-     vandpd(dst, src, ExternalAddress(StubRoutines::x86::vector_double_sign_mask()), vector_len, scr);</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     assert((opcode == Op_NegVD),&quot;opcode should be Op_NegD&quot;);</span>
<span class="line-removed">-     vxorpd(dst, src, ExternalAddress(StubRoutines::x86::vector_double_sign_flip()), vector_len, scr);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void MacroAssembler::vabsnegf(int opcode, XMMRegister dst, XMMRegister src, Register scr) {</span>
<span class="line-removed">-   if (dst != src) {</span>
<span class="line-removed">-     movdqu(dst, src);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   if (opcode == Op_AbsVF) {</span>
<span class="line-removed">-     andps(dst, ExternalAddress(StubRoutines::x86::vector_float_sign_mask()), scr);</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     assert((opcode == Op_NegVF),&quot;opcode should be Op_NegF&quot;);</span>
<span class="line-removed">-     xorps(dst, ExternalAddress(StubRoutines::x86::vector_float_sign_flip()), scr);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void MacroAssembler::vabsnegf(int opcode, XMMRegister dst, XMMRegister src, int vector_len, Register scr) {</span>
<span class="line-removed">-   if (opcode == Op_AbsVF) {</span>
<span class="line-removed">-     vandps(dst, src, ExternalAddress(StubRoutines::x86::vector_float_sign_mask()), vector_len, scr);</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     assert((opcode == Op_NegVF),&quot;opcode should be Op_NegF&quot;);</span>
<span class="line-removed">-     vxorps(dst, src, ExternalAddress(StubRoutines::x86::vector_float_sign_flip()), vector_len, scr);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void MacroAssembler::vextendbw(bool sign, XMMRegister dst, XMMRegister src) {</span>
<span class="line-removed">-   if (sign) {</span>
<span class="line-removed">-     pmovsxbw(dst, src);</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     pmovzxbw(dst, src);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void MacroAssembler::vextendbw(bool sign, XMMRegister dst, XMMRegister src, int vector_len) {</span>
<span class="line-removed">-   if (sign) {</span>
<span class="line-removed">-     vpmovsxbw(dst, src, vector_len);</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     vpmovzxbw(dst, src, vector_len);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void MacroAssembler::vshiftd(int opcode, XMMRegister dst, XMMRegister src) {</span>
<span class="line-removed">-   if (opcode == Op_RShiftVI) {</span>
<span class="line-removed">-     psrad(dst, src);</span>
<span class="line-removed">-   } else if (opcode == Op_LShiftVI) {</span>
<span class="line-removed">-     pslld(dst, src);</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     assert((opcode == Op_URShiftVI),&quot;opcode should be Op_URShiftVI&quot;);</span>
<span class="line-removed">-     psrld(dst, src);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void MacroAssembler::vshiftd(int opcode, XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {</span>
<span class="line-removed">-   if (opcode == Op_RShiftVI) {</span>
<span class="line-removed">-     vpsrad(dst, nds, src, vector_len);</span>
<span class="line-removed">-   } else if (opcode == Op_LShiftVI) {</span>
<span class="line-removed">-     vpslld(dst, nds, src, vector_len);</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     assert((opcode == Op_URShiftVI),&quot;opcode should be Op_URShiftVI&quot;);</span>
<span class="line-removed">-     vpsrld(dst, nds, src, vector_len);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void MacroAssembler::vshiftw(int opcode, XMMRegister dst, XMMRegister src) {</span>
<span class="line-removed">-   if ((opcode == Op_RShiftVS) || (opcode == Op_RShiftVB)) {</span>
<span class="line-removed">-     psraw(dst, src);</span>
<span class="line-removed">-   } else if ((opcode == Op_LShiftVS) || (opcode == Op_LShiftVB)) {</span>
<span class="line-removed">-     psllw(dst, src);</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     assert(((opcode == Op_URShiftVS) || (opcode == Op_URShiftVB)),&quot;opcode should be one of Op_URShiftVS or Op_URShiftVB&quot;);</span>
<span class="line-removed">-     psrlw(dst, src);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void MacroAssembler::vshiftw(int opcode, XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {</span>
<span class="line-removed">-   if ((opcode == Op_RShiftVS) || (opcode == Op_RShiftVB)) {</span>
<span class="line-removed">-     vpsraw(dst, nds, src, vector_len);</span>
<span class="line-removed">-   } else if ((opcode == Op_LShiftVS) || (opcode == Op_LShiftVB)) {</span>
<span class="line-removed">-     vpsllw(dst, nds, src, vector_len);</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     assert(((opcode == Op_URShiftVS) || (opcode == Op_URShiftVB)),&quot;opcode should be one of Op_URShiftVS or Op_URShiftVB&quot;);</span>
<span class="line-removed">-     vpsrlw(dst, nds, src, vector_len);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void MacroAssembler::vshiftq(int opcode, XMMRegister dst, XMMRegister src) {</span>
<span class="line-removed">-   if (opcode == Op_RShiftVL) {</span>
<span class="line-removed">-     psrlq(dst, src);  // using srl to implement sra on pre-avs512 systems</span>
<span class="line-removed">-   } else if (opcode == Op_LShiftVL) {</span>
<span class="line-removed">-     psllq(dst, src);</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     assert((opcode == Op_URShiftVL),&quot;opcode should be Op_URShiftVL&quot;);</span>
<span class="line-removed">-     psrlq(dst, src);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void MacroAssembler::vshiftq(int opcode, XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {</span>
<span class="line-removed">-   if (opcode == Op_RShiftVL) {</span>
<span class="line-removed">-     evpsraq(dst, nds, src, vector_len);</span>
<span class="line-removed">-   } else if (opcode == Op_LShiftVL) {</span>
<span class="line-removed">-     vpsllq(dst, nds, src, vector_len);</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     assert((opcode == Op_URShiftVL),&quot;opcode should be Op_URShiftVL&quot;);</span>
<span class="line-removed">-     vpsrlq(dst, nds, src, vector_len);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- #endif</span>
  //-------------------------------------------------------------------------------------------
  
  void MacroAssembler::clear_jweak_tag(Register possibly_jweak) {
    const int32_t inverted_jweak_mask = ~static_cast&lt;int32_t&gt;(JNIHandles::weak_tag_mask);
    STATIC_ASSERT(inverted_jweak_mask == -2); // otherwise check this code
<span class="line-new-header">--- 3241,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4665,10 ***</span>
<span class="line-new-header">--- 3755,18 ---</span>
    call(rax);
    // Caller pops the arguments (oop, message) and restores rax, r10
    BLOCK_COMMENT(&quot;} verify_oop&quot;);
  }
  
<span class="line-added">+ void MacroAssembler::vallones(XMMRegister dst, int vector_len) {</span>
<span class="line-added">+   if (UseAVX &gt; 2 &amp;&amp; (vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl())) {</span>
<span class="line-added">+     vpternlogd(dst, 0xFF, dst, dst, vector_len);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     assert(UseAVX &gt; 0, &quot;&quot;);</span>
<span class="line-added">+     vpcmpeqb(dst, dst, dst, vector_len);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
  
  RegisterOrConstant MacroAssembler::delayed_value_impl(intptr_t* delayed_value_addr,
                                                        Register tmp,
                                                        int offset) {
    intptr_t value = *delayed_value_addr;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5821,1431 ***</span>
    }
  
    BIND(DONE);
  }
  
<span class="line-removed">- #ifdef COMPILER2</span>
<span class="line-removed">- </span>
<span class="line-removed">- // IndexOf for constant substrings with size &gt;= 8 chars</span>
<span class="line-removed">- // which don&#39;t need to be loaded through stack.</span>
<span class="line-removed">- void MacroAssembler::string_indexofC8(Register str1, Register str2,</span>
<span class="line-removed">-                                       Register cnt1, Register cnt2,</span>
<span class="line-removed">-                                       int int_cnt2,  Register result,</span>
<span class="line-removed">-                                       XMMRegister vec, Register tmp,</span>
<span class="line-removed">-                                       int ae) {</span>
<span class="line-removed">-   ShortBranchVerifier sbv(this);</span>
<span class="line-removed">-   assert(UseSSE42Intrinsics, &quot;SSE4.2 intrinsics are required&quot;);</span>
<span class="line-removed">-   assert(ae != StrIntrinsicNode::LU, &quot;Invalid encoding&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // This method uses the pcmpestri instruction with bound registers</span>
<span class="line-removed">-   //   inputs:</span>
<span class="line-removed">-   //     xmm - substring</span>
<span class="line-removed">-   //     rax - substring length (elements count)</span>
<span class="line-removed">-   //     mem - scanned string</span>
<span class="line-removed">-   //     rdx - string length (elements count)</span>
<span class="line-removed">-   //     0xd - mode: 1100 (substring search) + 01 (unsigned shorts)</span>
<span class="line-removed">-   //     0xc - mode: 1100 (substring search) + 00 (unsigned bytes)</span>
<span class="line-removed">-   //   outputs:</span>
<span class="line-removed">-   //     rcx - matched index in string</span>
<span class="line-removed">-   assert(cnt1 == rdx &amp;&amp; cnt2 == rax &amp;&amp; tmp == rcx, &quot;pcmpestri&quot;);</span>
<span class="line-removed">-   int mode   = (ae == StrIntrinsicNode::LL) ? 0x0c : 0x0d; // bytes or shorts</span>
<span class="line-removed">-   int stride = (ae == StrIntrinsicNode::LL) ? 16 : 8; //UU, UL -&gt; 8</span>
<span class="line-removed">-   Address::ScaleFactor scale1 = (ae == StrIntrinsicNode::LL) ? Address::times_1 : Address::times_2;</span>
<span class="line-removed">-   Address::ScaleFactor scale2 = (ae == StrIntrinsicNode::UL) ? Address::times_1 : scale1;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   Label RELOAD_SUBSTR, SCAN_TO_SUBSTR, SCAN_SUBSTR,</span>
<span class="line-removed">-         RET_FOUND, RET_NOT_FOUND, EXIT, FOUND_SUBSTR,</span>
<span class="line-removed">-         MATCH_SUBSTR_HEAD, RELOAD_STR, FOUND_CANDIDATE;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Note, inline_string_indexOf() generates checks:</span>
<span class="line-removed">-   // if (substr.count &gt; string.count) return -1;</span>
<span class="line-removed">-   // if (substr.count == 0) return 0;</span>
<span class="line-removed">-   assert(int_cnt2 &gt;= stride, &quot;this code is used only for cnt2 &gt;= 8 chars&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Load substring.</span>
<span class="line-removed">-   if (ae == StrIntrinsicNode::UL) {</span>
<span class="line-removed">-     pmovzxbw(vec, Address(str2, 0));</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     movdqu(vec, Address(str2, 0));</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   movl(cnt2, int_cnt2);</span>
<span class="line-removed">-   movptr(result, str1); // string addr</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (int_cnt2 &gt; stride) {</span>
<span class="line-removed">-     jmpb(SCAN_TO_SUBSTR);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Reload substr for rescan, this code</span>
<span class="line-removed">-     // is executed only for large substrings (&gt; 8 chars)</span>
<span class="line-removed">-     bind(RELOAD_SUBSTR);</span>
<span class="line-removed">-     if (ae == StrIntrinsicNode::UL) {</span>
<span class="line-removed">-       pmovzxbw(vec, Address(str2, 0));</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       movdqu(vec, Address(str2, 0));</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     negptr(cnt2); // Jumped here with negative cnt2, convert to positive</span>
<span class="line-removed">- </span>
<span class="line-removed">-     bind(RELOAD_STR);</span>
<span class="line-removed">-     // We came here after the beginning of the substring was</span>
<span class="line-removed">-     // matched but the rest of it was not so we need to search</span>
<span class="line-removed">-     // again. Start from the next element after the previous match.</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // cnt2 is number of substring reminding elements and</span>
<span class="line-removed">-     // cnt1 is number of string reminding elements when cmp failed.</span>
<span class="line-removed">-     // Restored cnt1 = cnt1 - cnt2 + int_cnt2</span>
<span class="line-removed">-     subl(cnt1, cnt2);</span>
<span class="line-removed">-     addl(cnt1, int_cnt2);</span>
<span class="line-removed">-     movl(cnt2, int_cnt2); // Now restore cnt2</span>
<span class="line-removed">- </span>
<span class="line-removed">-     decrementl(cnt1);     // Shift to next element</span>
<span class="line-removed">-     cmpl(cnt1, cnt2);</span>
<span class="line-removed">-     jcc(Assembler::negative, RET_NOT_FOUND);  // Left less then substring</span>
<span class="line-removed">- </span>
<span class="line-removed">-     addptr(result, (1&lt;&lt;scale1));</span>
<span class="line-removed">- </span>
<span class="line-removed">-   } // (int_cnt2 &gt; 8)</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Scan string for start of substr in 16-byte vectors</span>
<span class="line-removed">-   bind(SCAN_TO_SUBSTR);</span>
<span class="line-removed">-   pcmpestri(vec, Address(result, 0), mode);</span>
<span class="line-removed">-   jccb(Assembler::below, FOUND_CANDIDATE);   // CF == 1</span>
<span class="line-removed">-   subl(cnt1, stride);</span>
<span class="line-removed">-   jccb(Assembler::lessEqual, RET_NOT_FOUND); // Scanned full string</span>
<span class="line-removed">-   cmpl(cnt1, cnt2);</span>
<span class="line-removed">-   jccb(Assembler::negative, RET_NOT_FOUND);  // Left less then substring</span>
<span class="line-removed">-   addptr(result, 16);</span>
<span class="line-removed">-   jmpb(SCAN_TO_SUBSTR);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Found a potential substr</span>
<span class="line-removed">-   bind(FOUND_CANDIDATE);</span>
<span class="line-removed">-   // Matched whole vector if first element matched (tmp(rcx) == 0).</span>
<span class="line-removed">-   if (int_cnt2 == stride) {</span>
<span class="line-removed">-     jccb(Assembler::overflow, RET_FOUND);    // OF == 1</span>
<span class="line-removed">-   } else { // int_cnt2 &gt; 8</span>
<span class="line-removed">-     jccb(Assembler::overflow, FOUND_SUBSTR);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   // After pcmpestri tmp(rcx) contains matched element index</span>
<span class="line-removed">-   // Compute start addr of substr</span>
<span class="line-removed">-   lea(result, Address(result, tmp, scale1));</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Make sure string is still long enough</span>
<span class="line-removed">-   subl(cnt1, tmp);</span>
<span class="line-removed">-   cmpl(cnt1, cnt2);</span>
<span class="line-removed">-   if (int_cnt2 == stride) {</span>
<span class="line-removed">-     jccb(Assembler::greaterEqual, SCAN_TO_SUBSTR);</span>
<span class="line-removed">-   } else { // int_cnt2 &gt; 8</span>
<span class="line-removed">-     jccb(Assembler::greaterEqual, MATCH_SUBSTR_HEAD);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   // Left less then substring.</span>
<span class="line-removed">- </span>
<span class="line-removed">-   bind(RET_NOT_FOUND);</span>
<span class="line-removed">-   movl(result, -1);</span>
<span class="line-removed">-   jmp(EXIT);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (int_cnt2 &gt; stride) {</span>
<span class="line-removed">-     // This code is optimized for the case when whole substring</span>
<span class="line-removed">-     // is matched if its head is matched.</span>
<span class="line-removed">-     bind(MATCH_SUBSTR_HEAD);</span>
<span class="line-removed">-     pcmpestri(vec, Address(result, 0), mode);</span>
<span class="line-removed">-     // Reload only string if does not match</span>
<span class="line-removed">-     jcc(Assembler::noOverflow, RELOAD_STR); // OF == 0</span>
<span class="line-removed">- </span>
<span class="line-removed">-     Label CONT_SCAN_SUBSTR;</span>
<span class="line-removed">-     // Compare the rest of substring (&gt; 8 chars).</span>
<span class="line-removed">-     bind(FOUND_SUBSTR);</span>
<span class="line-removed">-     // First 8 chars are already matched.</span>
<span class="line-removed">-     negptr(cnt2);</span>
<span class="line-removed">-     addptr(cnt2, stride);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     bind(SCAN_SUBSTR);</span>
<span class="line-removed">-     subl(cnt1, stride);</span>
<span class="line-removed">-     cmpl(cnt2, -stride); // Do not read beyond substring</span>
<span class="line-removed">-     jccb(Assembler::lessEqual, CONT_SCAN_SUBSTR);</span>
<span class="line-removed">-     // Back-up strings to avoid reading beyond substring:</span>
<span class="line-removed">-     // cnt1 = cnt1 - cnt2 + 8</span>
<span class="line-removed">-     addl(cnt1, cnt2); // cnt2 is negative</span>
<span class="line-removed">-     addl(cnt1, stride);</span>
<span class="line-removed">-     movl(cnt2, stride); negptr(cnt2);</span>
<span class="line-removed">-     bind(CONT_SCAN_SUBSTR);</span>
<span class="line-removed">-     if (int_cnt2 &lt; (int)G) {</span>
<span class="line-removed">-       int tail_off1 = int_cnt2&lt;&lt;scale1;</span>
<span class="line-removed">-       int tail_off2 = int_cnt2&lt;&lt;scale2;</span>
<span class="line-removed">-       if (ae == StrIntrinsicNode::UL) {</span>
<span class="line-removed">-         pmovzxbw(vec, Address(str2, cnt2, scale2, tail_off2));</span>
<span class="line-removed">-       } else {</span>
<span class="line-removed">-         movdqu(vec, Address(str2, cnt2, scale2, tail_off2));</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       pcmpestri(vec, Address(result, cnt2, scale1, tail_off1), mode);</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       // calculate index in register to avoid integer overflow (int_cnt2*2)</span>
<span class="line-removed">-       movl(tmp, int_cnt2);</span>
<span class="line-removed">-       addptr(tmp, cnt2);</span>
<span class="line-removed">-       if (ae == StrIntrinsicNode::UL) {</span>
<span class="line-removed">-         pmovzxbw(vec, Address(str2, tmp, scale2, 0));</span>
<span class="line-removed">-       } else {</span>
<span class="line-removed">-         movdqu(vec, Address(str2, tmp, scale2, 0));</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       pcmpestri(vec, Address(result, tmp, scale1, 0), mode);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     // Need to reload strings pointers if not matched whole vector</span>
<span class="line-removed">-     jcc(Assembler::noOverflow, RELOAD_SUBSTR); // OF == 0</span>
<span class="line-removed">-     addptr(cnt2, stride);</span>
<span class="line-removed">-     jcc(Assembler::negative, SCAN_SUBSTR);</span>
<span class="line-removed">-     // Fall through if found full substring</span>
<span class="line-removed">- </span>
<span class="line-removed">-   } // (int_cnt2 &gt; 8)</span>
<span class="line-removed">- </span>
<span class="line-removed">-   bind(RET_FOUND);</span>
<span class="line-removed">-   // Found result if we matched full small substring.</span>
<span class="line-removed">-   // Compute substr offset</span>
<span class="line-removed">-   subptr(result, str1);</span>
<span class="line-removed">-   if (ae == StrIntrinsicNode::UU || ae == StrIntrinsicNode::UL) {</span>
<span class="line-removed">-     shrl(result, 1); // index</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   bind(EXIT);</span>
<span class="line-removed">- </span>
<span class="line-removed">- } // string_indexofC8</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Small strings are loaded through stack if they cross page boundary.</span>
<span class="line-removed">- void MacroAssembler::string_indexof(Register str1, Register str2,</span>
<span class="line-removed">-                                     Register cnt1, Register cnt2,</span>
<span class="line-removed">-                                     int int_cnt2,  Register result,</span>
<span class="line-removed">-                                     XMMRegister vec, Register tmp,</span>
<span class="line-removed">-                                     int ae) {</span>
<span class="line-removed">-   ShortBranchVerifier sbv(this);</span>
<span class="line-removed">-   assert(UseSSE42Intrinsics, &quot;SSE4.2 intrinsics are required&quot;);</span>
<span class="line-removed">-   assert(ae != StrIntrinsicNode::LU, &quot;Invalid encoding&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   //</span>
<span class="line-removed">-   // int_cnt2 is length of small (&lt; 8 chars) constant substring</span>
<span class="line-removed">-   // or (-1) for non constant substring in which case its length</span>
<span class="line-removed">-   // is in cnt2 register.</span>
<span class="line-removed">-   //</span>
<span class="line-removed">-   // Note, inline_string_indexOf() generates checks:</span>
<span class="line-removed">-   // if (substr.count &gt; string.count) return -1;</span>
<span class="line-removed">-   // if (substr.count == 0) return 0;</span>
<span class="line-removed">-   //</span>
<span class="line-removed">-   int stride = (ae == StrIntrinsicNode::LL) ? 16 : 8; //UU, UL -&gt; 8</span>
<span class="line-removed">-   assert(int_cnt2 == -1 || (0 &lt; int_cnt2 &amp;&amp; int_cnt2 &lt; stride), &quot;should be != 0&quot;);</span>
<span class="line-removed">-   // This method uses the pcmpestri instruction with bound registers</span>
<span class="line-removed">-   //   inputs:</span>
<span class="line-removed">-   //     xmm - substring</span>
<span class="line-removed">-   //     rax - substring length (elements count)</span>
<span class="line-removed">-   //     mem - scanned string</span>
<span class="line-removed">-   //     rdx - string length (elements count)</span>
<span class="line-removed">-   //     0xd - mode: 1100 (substring search) + 01 (unsigned shorts)</span>
<span class="line-removed">-   //     0xc - mode: 1100 (substring search) + 00 (unsigned bytes)</span>
<span class="line-removed">-   //   outputs:</span>
<span class="line-removed">-   //     rcx - matched index in string</span>
<span class="line-removed">-   assert(cnt1 == rdx &amp;&amp; cnt2 == rax &amp;&amp; tmp == rcx, &quot;pcmpestri&quot;);</span>
<span class="line-removed">-   int mode = (ae == StrIntrinsicNode::LL) ? 0x0c : 0x0d; // bytes or shorts</span>
<span class="line-removed">-   Address::ScaleFactor scale1 = (ae == StrIntrinsicNode::LL) ? Address::times_1 : Address::times_2;</span>
<span class="line-removed">-   Address::ScaleFactor scale2 = (ae == StrIntrinsicNode::UL) ? Address::times_1 : scale1;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   Label RELOAD_SUBSTR, SCAN_TO_SUBSTR, SCAN_SUBSTR, ADJUST_STR,</span>
<span class="line-removed">-         RET_FOUND, RET_NOT_FOUND, CLEANUP, FOUND_SUBSTR,</span>
<span class="line-removed">-         FOUND_CANDIDATE;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   { //========================================================</span>
<span class="line-removed">-     // We don&#39;t know where these strings are located</span>
<span class="line-removed">-     // and we can&#39;t read beyond them. Load them through stack.</span>
<span class="line-removed">-     Label BIG_STRINGS, CHECK_STR, COPY_SUBSTR, COPY_STR;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     movptr(tmp, rsp); // save old SP</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (int_cnt2 &gt; 0) {     // small (&lt; 8 chars) constant substring</span>
<span class="line-removed">-       if (int_cnt2 == (1&gt;&gt;scale2)) { // One byte</span>
<span class="line-removed">-         assert((ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UL), &quot;Only possible for latin1 encoding&quot;);</span>
<span class="line-removed">-         load_unsigned_byte(result, Address(str2, 0));</span>
<span class="line-removed">-         movdl(vec, result); // move 32 bits</span>
<span class="line-removed">-       } else if (ae == StrIntrinsicNode::LL &amp;&amp; int_cnt2 == 3) {  // Three bytes</span>
<span class="line-removed">-         // Not enough header space in 32-bit VM: 12+3 = 15.</span>
<span class="line-removed">-         movl(result, Address(str2, -1));</span>
<span class="line-removed">-         shrl(result, 8);</span>
<span class="line-removed">-         movdl(vec, result); // move 32 bits</span>
<span class="line-removed">-       } else if (ae != StrIntrinsicNode::UL &amp;&amp; int_cnt2 == (2&gt;&gt;scale2)) {  // One char</span>
<span class="line-removed">-         load_unsigned_short(result, Address(str2, 0));</span>
<span class="line-removed">-         movdl(vec, result); // move 32 bits</span>
<span class="line-removed">-       } else if (ae != StrIntrinsicNode::UL &amp;&amp; int_cnt2 == (4&gt;&gt;scale2)) { // Two chars</span>
<span class="line-removed">-         movdl(vec, Address(str2, 0)); // move 32 bits</span>
<span class="line-removed">-       } else if (ae != StrIntrinsicNode::UL &amp;&amp; int_cnt2 == (8&gt;&gt;scale2)) { // Four chars</span>
<span class="line-removed">-         movq(vec, Address(str2, 0));  // move 64 bits</span>
<span class="line-removed">-       } else { // cnt2 = { 3, 5, 6, 7 } || (ae == StrIntrinsicNode::UL &amp;&amp; cnt2 ={2, ..., 7})</span>
<span class="line-removed">-         // Array header size is 12 bytes in 32-bit VM</span>
<span class="line-removed">-         // + 6 bytes for 3 chars == 18 bytes,</span>
<span class="line-removed">-         // enough space to load vec and shift.</span>
<span class="line-removed">-         assert(HeapWordSize*TypeArrayKlass::header_size() &gt;= 12,&quot;sanity&quot;);</span>
<span class="line-removed">-         if (ae == StrIntrinsicNode::UL) {</span>
<span class="line-removed">-           int tail_off = int_cnt2-8;</span>
<span class="line-removed">-           pmovzxbw(vec, Address(str2, tail_off));</span>
<span class="line-removed">-           psrldq(vec, -2*tail_off);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         else {</span>
<span class="line-removed">-           int tail_off = int_cnt2*(1&lt;&lt;scale2);</span>
<span class="line-removed">-           movdqu(vec, Address(str2, tail_off-16));</span>
<span class="line-removed">-           psrldq(vec, 16-tail_off);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     } else { // not constant substring</span>
<span class="line-removed">-       cmpl(cnt2, stride);</span>
<span class="line-removed">-       jccb(Assembler::aboveEqual, BIG_STRINGS); // Both strings are big enough</span>
<span class="line-removed">- </span>
<span class="line-removed">-       // We can read beyond string if srt+16 does not cross page boundary</span>
<span class="line-removed">-       // since heaps are aligned and mapped by pages.</span>
<span class="line-removed">-       assert(os::vm_page_size() &lt; (int)G, &quot;default page should be small&quot;);</span>
<span class="line-removed">-       movl(result, str2); // We need only low 32 bits</span>
<span class="line-removed">-       andl(result, (os::vm_page_size()-1));</span>
<span class="line-removed">-       cmpl(result, (os::vm_page_size()-16));</span>
<span class="line-removed">-       jccb(Assembler::belowEqual, CHECK_STR);</span>
<span class="line-removed">- </span>
<span class="line-removed">-       // Move small strings to stack to allow load 16 bytes into vec.</span>
<span class="line-removed">-       subptr(rsp, 16);</span>
<span class="line-removed">-       int stk_offset = wordSize-(1&lt;&lt;scale2);</span>
<span class="line-removed">-       push(cnt2);</span>
<span class="line-removed">- </span>
<span class="line-removed">-       bind(COPY_SUBSTR);</span>
<span class="line-removed">-       if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UL) {</span>
<span class="line-removed">-         load_unsigned_byte(result, Address(str2, cnt2, scale2, -1));</span>
<span class="line-removed">-         movb(Address(rsp, cnt2, scale2, stk_offset), result);</span>
<span class="line-removed">-       } else if (ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed">-         load_unsigned_short(result, Address(str2, cnt2, scale2, -2));</span>
<span class="line-removed">-         movw(Address(rsp, cnt2, scale2, stk_offset), result);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       decrement(cnt2);</span>
<span class="line-removed">-       jccb(Assembler::notZero, COPY_SUBSTR);</span>
<span class="line-removed">- </span>
<span class="line-removed">-       pop(cnt2);</span>
<span class="line-removed">-       movptr(str2, rsp);  // New substring address</span>
<span class="line-removed">-     } // non constant</span>
<span class="line-removed">- </span>
<span class="line-removed">-     bind(CHECK_STR);</span>
<span class="line-removed">-     cmpl(cnt1, stride);</span>
<span class="line-removed">-     jccb(Assembler::aboveEqual, BIG_STRINGS);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Check cross page boundary.</span>
<span class="line-removed">-     movl(result, str1); // We need only low 32 bits</span>
<span class="line-removed">-     andl(result, (os::vm_page_size()-1));</span>
<span class="line-removed">-     cmpl(result, (os::vm_page_size()-16));</span>
<span class="line-removed">-     jccb(Assembler::belowEqual, BIG_STRINGS);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     subptr(rsp, 16);</span>
<span class="line-removed">-     int stk_offset = -(1&lt;&lt;scale1);</span>
<span class="line-removed">-     if (int_cnt2 &lt; 0) { // not constant</span>
<span class="line-removed">-       push(cnt2);</span>
<span class="line-removed">-       stk_offset += wordSize;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     movl(cnt2, cnt1);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     bind(COPY_STR);</span>
<span class="line-removed">-     if (ae == StrIntrinsicNode::LL) {</span>
<span class="line-removed">-       load_unsigned_byte(result, Address(str1, cnt2, scale1, -1));</span>
<span class="line-removed">-       movb(Address(rsp, cnt2, scale1, stk_offset), result);</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       load_unsigned_short(result, Address(str1, cnt2, scale1, -2));</span>
<span class="line-removed">-       movw(Address(rsp, cnt2, scale1, stk_offset), result);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     decrement(cnt2);</span>
<span class="line-removed">-     jccb(Assembler::notZero, COPY_STR);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (int_cnt2 &lt; 0) { // not constant</span>
<span class="line-removed">-       pop(cnt2);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     movptr(str1, rsp);  // New string address</span>
<span class="line-removed">- </span>
<span class="line-removed">-     bind(BIG_STRINGS);</span>
<span class="line-removed">-     // Load substring.</span>
<span class="line-removed">-     if (int_cnt2 &lt; 0) { // -1</span>
<span class="line-removed">-       if (ae == StrIntrinsicNode::UL) {</span>
<span class="line-removed">-         pmovzxbw(vec, Address(str2, 0));</span>
<span class="line-removed">-       } else {</span>
<span class="line-removed">-         movdqu(vec, Address(str2, 0));</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       push(cnt2);       // substr count</span>
<span class="line-removed">-       push(str2);       // substr addr</span>
<span class="line-removed">-       push(str1);       // string addr</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       // Small (&lt; 8 chars) constant substrings are loaded already.</span>
<span class="line-removed">-       movl(cnt2, int_cnt2);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     push(tmp);  // original SP</span>
<span class="line-removed">- </span>
<span class="line-removed">-   } // Finished loading</span>
<span class="line-removed">- </span>
<span class="line-removed">-   //========================================================</span>
<span class="line-removed">-   // Start search</span>
<span class="line-removed">-   //</span>
<span class="line-removed">- </span>
<span class="line-removed">-   movptr(result, str1); // string addr</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (int_cnt2  &lt; 0) {  // Only for non constant substring</span>
<span class="line-removed">-     jmpb(SCAN_TO_SUBSTR);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // SP saved at sp+0</span>
<span class="line-removed">-     // String saved at sp+1*wordSize</span>
<span class="line-removed">-     // Substr saved at sp+2*wordSize</span>
<span class="line-removed">-     // Substr count saved at sp+3*wordSize</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Reload substr for rescan, this code</span>
<span class="line-removed">-     // is executed only for large substrings (&gt; 8 chars)</span>
<span class="line-removed">-     bind(RELOAD_SUBSTR);</span>
<span class="line-removed">-     movptr(str2, Address(rsp, 2*wordSize));</span>
<span class="line-removed">-     movl(cnt2, Address(rsp, 3*wordSize));</span>
<span class="line-removed">-     if (ae == StrIntrinsicNode::UL) {</span>
<span class="line-removed">-       pmovzxbw(vec, Address(str2, 0));</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       movdqu(vec, Address(str2, 0));</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     // We came here after the beginning of the substring was</span>
<span class="line-removed">-     // matched but the rest of it was not so we need to search</span>
<span class="line-removed">-     // again. Start from the next element after the previous match.</span>
<span class="line-removed">-     subptr(str1, result); // Restore counter</span>
<span class="line-removed">-     if (ae == StrIntrinsicNode::UU || ae == StrIntrinsicNode::UL) {</span>
<span class="line-removed">-       shrl(str1, 1);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     addl(cnt1, str1);</span>
<span class="line-removed">-     decrementl(cnt1);   // Shift to next element</span>
<span class="line-removed">-     cmpl(cnt1, cnt2);</span>
<span class="line-removed">-     jcc(Assembler::negative, RET_NOT_FOUND);  // Left less then substring</span>
<span class="line-removed">- </span>
<span class="line-removed">-     addptr(result, (1&lt;&lt;scale1));</span>
<span class="line-removed">-   } // non constant</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Scan string for start of substr in 16-byte vectors</span>
<span class="line-removed">-   bind(SCAN_TO_SUBSTR);</span>
<span class="line-removed">-   assert(cnt1 == rdx &amp;&amp; cnt2 == rax &amp;&amp; tmp == rcx, &quot;pcmpestri&quot;);</span>
<span class="line-removed">-   pcmpestri(vec, Address(result, 0), mode);</span>
<span class="line-removed">-   jccb(Assembler::below, FOUND_CANDIDATE);   // CF == 1</span>
<span class="line-removed">-   subl(cnt1, stride);</span>
<span class="line-removed">-   jccb(Assembler::lessEqual, RET_NOT_FOUND); // Scanned full string</span>
<span class="line-removed">-   cmpl(cnt1, cnt2);</span>
<span class="line-removed">-   jccb(Assembler::negative, RET_NOT_FOUND);  // Left less then substring</span>
<span class="line-removed">-   addptr(result, 16);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   bind(ADJUST_STR);</span>
<span class="line-removed">-   cmpl(cnt1, stride); // Do not read beyond string</span>
<span class="line-removed">-   jccb(Assembler::greaterEqual, SCAN_TO_SUBSTR);</span>
<span class="line-removed">-   // Back-up string to avoid reading beyond string.</span>
<span class="line-removed">-   lea(result, Address(result, cnt1, scale1, -16));</span>
<span class="line-removed">-   movl(cnt1, stride);</span>
<span class="line-removed">-   jmpb(SCAN_TO_SUBSTR);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Found a potential substr</span>
<span class="line-removed">-   bind(FOUND_CANDIDATE);</span>
<span class="line-removed">-   // After pcmpestri tmp(rcx) contains matched element index</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Make sure string is still long enough</span>
<span class="line-removed">-   subl(cnt1, tmp);</span>
<span class="line-removed">-   cmpl(cnt1, cnt2);</span>
<span class="line-removed">-   jccb(Assembler::greaterEqual, FOUND_SUBSTR);</span>
<span class="line-removed">-   // Left less then substring.</span>
<span class="line-removed">- </span>
<span class="line-removed">-   bind(RET_NOT_FOUND);</span>
<span class="line-removed">-   movl(result, -1);</span>
<span class="line-removed">-   jmp(CLEANUP);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   bind(FOUND_SUBSTR);</span>
<span class="line-removed">-   // Compute start addr of substr</span>
<span class="line-removed">-   lea(result, Address(result, tmp, scale1));</span>
<span class="line-removed">-   if (int_cnt2 &gt; 0) { // Constant substring</span>
<span class="line-removed">-     // Repeat search for small substring (&lt; 8 chars)</span>
<span class="line-removed">-     // from new point without reloading substring.</span>
<span class="line-removed">-     // Have to check that we don&#39;t read beyond string.</span>
<span class="line-removed">-     cmpl(tmp, stride-int_cnt2);</span>
<span class="line-removed">-     jccb(Assembler::greater, ADJUST_STR);</span>
<span class="line-removed">-     // Fall through if matched whole substring.</span>
<span class="line-removed">-   } else { // non constant</span>
<span class="line-removed">-     assert(int_cnt2 == -1, &quot;should be != 0&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     addl(tmp, cnt2);</span>
<span class="line-removed">-     // Found result if we matched whole substring.</span>
<span class="line-removed">-     cmpl(tmp, stride);</span>
<span class="line-removed">-     jcc(Assembler::lessEqual, RET_FOUND);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Repeat search for small substring (&lt;= 8 chars)</span>
<span class="line-removed">-     // from new point &#39;str1&#39; without reloading substring.</span>
<span class="line-removed">-     cmpl(cnt2, stride);</span>
<span class="line-removed">-     // Have to check that we don&#39;t read beyond string.</span>
<span class="line-removed">-     jccb(Assembler::lessEqual, ADJUST_STR);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     Label CHECK_NEXT, CONT_SCAN_SUBSTR, RET_FOUND_LONG;</span>
<span class="line-removed">-     // Compare the rest of substring (&gt; 8 chars).</span>
<span class="line-removed">-     movptr(str1, result);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     cmpl(tmp, cnt2);</span>
<span class="line-removed">-     // First 8 chars are already matched.</span>
<span class="line-removed">-     jccb(Assembler::equal, CHECK_NEXT);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     bind(SCAN_SUBSTR);</span>
<span class="line-removed">-     pcmpestri(vec, Address(str1, 0), mode);</span>
<span class="line-removed">-     // Need to reload strings pointers if not matched whole vector</span>
<span class="line-removed">-     jcc(Assembler::noOverflow, RELOAD_SUBSTR); // OF == 0</span>
<span class="line-removed">- </span>
<span class="line-removed">-     bind(CHECK_NEXT);</span>
<span class="line-removed">-     subl(cnt2, stride);</span>
<span class="line-removed">-     jccb(Assembler::lessEqual, RET_FOUND_LONG); // Found full substring</span>
<span class="line-removed">-     addptr(str1, 16);</span>
<span class="line-removed">-     if (ae == StrIntrinsicNode::UL) {</span>
<span class="line-removed">-       addptr(str2, 8);</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       addptr(str2, 16);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     subl(cnt1, stride);</span>
<span class="line-removed">-     cmpl(cnt2, stride); // Do not read beyond substring</span>
<span class="line-removed">-     jccb(Assembler::greaterEqual, CONT_SCAN_SUBSTR);</span>
<span class="line-removed">-     // Back-up strings to avoid reading beyond substring.</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (ae == StrIntrinsicNode::UL) {</span>
<span class="line-removed">-       lea(str2, Address(str2, cnt2, scale2, -8));</span>
<span class="line-removed">-       lea(str1, Address(str1, cnt2, scale1, -16));</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       lea(str2, Address(str2, cnt2, scale2, -16));</span>
<span class="line-removed">-       lea(str1, Address(str1, cnt2, scale1, -16));</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     subl(cnt1, cnt2);</span>
<span class="line-removed">-     movl(cnt2, stride);</span>
<span class="line-removed">-     addl(cnt1, stride);</span>
<span class="line-removed">-     bind(CONT_SCAN_SUBSTR);</span>
<span class="line-removed">-     if (ae == StrIntrinsicNode::UL) {</span>
<span class="line-removed">-       pmovzxbw(vec, Address(str2, 0));</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       movdqu(vec, Address(str2, 0));</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     jmp(SCAN_SUBSTR);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     bind(RET_FOUND_LONG);</span>
<span class="line-removed">-     movptr(str1, Address(rsp, wordSize));</span>
<span class="line-removed">-   } // non constant</span>
<span class="line-removed">- </span>
<span class="line-removed">-   bind(RET_FOUND);</span>
<span class="line-removed">-   // Compute substr offset</span>
<span class="line-removed">-   subptr(result, str1);</span>
<span class="line-removed">-   if (ae == StrIntrinsicNode::UU || ae == StrIntrinsicNode::UL) {</span>
<span class="line-removed">-     shrl(result, 1); // index</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   bind(CLEANUP);</span>
<span class="line-removed">-   pop(rsp); // restore SP</span>
<span class="line-removed">- </span>
<span class="line-removed">- } // string_indexof</span>
<span class="line-removed">- </span>
<span class="line-removed">- void MacroAssembler::string_indexof_char(Register str1, Register cnt1, Register ch, Register result,</span>
<span class="line-removed">-                                          XMMRegister vec1, XMMRegister vec2, XMMRegister vec3, Register tmp) {</span>
<span class="line-removed">-   ShortBranchVerifier sbv(this);</span>
<span class="line-removed">-   assert(UseSSE42Intrinsics, &quot;SSE4.2 intrinsics are required&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   int stride = 8;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   Label FOUND_CHAR, SCAN_TO_CHAR, SCAN_TO_CHAR_LOOP,</span>
<span class="line-removed">-         SCAN_TO_8_CHAR, SCAN_TO_8_CHAR_LOOP, SCAN_TO_16_CHAR_LOOP,</span>
<span class="line-removed">-         RET_NOT_FOUND, SCAN_TO_8_CHAR_INIT,</span>
<span class="line-removed">-         FOUND_SEQ_CHAR, DONE_LABEL;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   movptr(result, str1);</span>
<span class="line-removed">-   if (UseAVX &gt;= 2) {</span>
<span class="line-removed">-     cmpl(cnt1, stride);</span>
<span class="line-removed">-     jcc(Assembler::less, SCAN_TO_CHAR);</span>
<span class="line-removed">-     cmpl(cnt1, 2*stride);</span>
<span class="line-removed">-     jcc(Assembler::less, SCAN_TO_8_CHAR_INIT);</span>
<span class="line-removed">-     movdl(vec1, ch);</span>
<span class="line-removed">-     vpbroadcastw(vec1, vec1, Assembler::AVX_256bit);</span>
<span class="line-removed">-     vpxor(vec2, vec2);</span>
<span class="line-removed">-     movl(tmp, cnt1);</span>
<span class="line-removed">-     andl(tmp, 0xFFFFFFF0);  //vector count (in chars)</span>
<span class="line-removed">-     andl(cnt1,0x0000000F);  //tail count (in chars)</span>
<span class="line-removed">- </span>
<span class="line-removed">-     bind(SCAN_TO_16_CHAR_LOOP);</span>
<span class="line-removed">-     vmovdqu(vec3, Address(result, 0));</span>
<span class="line-removed">-     vpcmpeqw(vec3, vec3, vec1, 1);</span>
<span class="line-removed">-     vptest(vec2, vec3);</span>
<span class="line-removed">-     jcc(Assembler::carryClear, FOUND_CHAR);</span>
<span class="line-removed">-     addptr(result, 32);</span>
<span class="line-removed">-     subl(tmp, 2*stride);</span>
<span class="line-removed">-     jcc(Assembler::notZero, SCAN_TO_16_CHAR_LOOP);</span>
<span class="line-removed">-     jmp(SCAN_TO_8_CHAR);</span>
<span class="line-removed">-     bind(SCAN_TO_8_CHAR_INIT);</span>
<span class="line-removed">-     movdl(vec1, ch);</span>
<span class="line-removed">-     pshuflw(vec1, vec1, 0x00);</span>
<span class="line-removed">-     pshufd(vec1, vec1, 0);</span>
<span class="line-removed">-     pxor(vec2, vec2);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   bind(SCAN_TO_8_CHAR);</span>
<span class="line-removed">-   cmpl(cnt1, stride);</span>
<span class="line-removed">-   jcc(Assembler::less, SCAN_TO_CHAR);</span>
<span class="line-removed">-   if (UseAVX &lt; 2) {</span>
<span class="line-removed">-     movdl(vec1, ch);</span>
<span class="line-removed">-     pshuflw(vec1, vec1, 0x00);</span>
<span class="line-removed">-     pshufd(vec1, vec1, 0);</span>
<span class="line-removed">-     pxor(vec2, vec2);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   movl(tmp, cnt1);</span>
<span class="line-removed">-   andl(tmp, 0xFFFFFFF8);  //vector count (in chars)</span>
<span class="line-removed">-   andl(cnt1,0x00000007);  //tail count (in chars)</span>
<span class="line-removed">- </span>
<span class="line-removed">-   bind(SCAN_TO_8_CHAR_LOOP);</span>
<span class="line-removed">-   movdqu(vec3, Address(result, 0));</span>
<span class="line-removed">-   pcmpeqw(vec3, vec1);</span>
<span class="line-removed">-   ptest(vec2, vec3);</span>
<span class="line-removed">-   jcc(Assembler::carryClear, FOUND_CHAR);</span>
<span class="line-removed">-   addptr(result, 16);</span>
<span class="line-removed">-   subl(tmp, stride);</span>
<span class="line-removed">-   jcc(Assembler::notZero, SCAN_TO_8_CHAR_LOOP);</span>
<span class="line-removed">-   bind(SCAN_TO_CHAR);</span>
<span class="line-removed">-   testl(cnt1, cnt1);</span>
<span class="line-removed">-   jcc(Assembler::zero, RET_NOT_FOUND);</span>
<span class="line-removed">-   bind(SCAN_TO_CHAR_LOOP);</span>
<span class="line-removed">-   load_unsigned_short(tmp, Address(result, 0));</span>
<span class="line-removed">-   cmpl(ch, tmp);</span>
<span class="line-removed">-   jccb(Assembler::equal, FOUND_SEQ_CHAR);</span>
<span class="line-removed">-   addptr(result, 2);</span>
<span class="line-removed">-   subl(cnt1, 1);</span>
<span class="line-removed">-   jccb(Assembler::zero, RET_NOT_FOUND);</span>
<span class="line-removed">-   jmp(SCAN_TO_CHAR_LOOP);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   bind(RET_NOT_FOUND);</span>
<span class="line-removed">-   movl(result, -1);</span>
<span class="line-removed">-   jmpb(DONE_LABEL);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   bind(FOUND_CHAR);</span>
<span class="line-removed">-   if (UseAVX &gt;= 2) {</span>
<span class="line-removed">-     vpmovmskb(tmp, vec3);</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     pmovmskb(tmp, vec3);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   bsfl(ch, tmp);</span>
<span class="line-removed">-   addl(result, ch);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   bind(FOUND_SEQ_CHAR);</span>
<span class="line-removed">-   subptr(result, str1);</span>
<span class="line-removed">-   shrl(result, 1);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   bind(DONE_LABEL);</span>
<span class="line-removed">- } // string_indexof_char</span>
<span class="line-removed">- </span>
<span class="line-removed">- // helper function for string_compare</span>
<span class="line-removed">- void MacroAssembler::load_next_elements(Register elem1, Register elem2, Register str1, Register str2,</span>
<span class="line-removed">-                                         Address::ScaleFactor scale, Address::ScaleFactor scale1,</span>
<span class="line-removed">-                                         Address::ScaleFactor scale2, Register index, int ae) {</span>
<span class="line-removed">-   if (ae == StrIntrinsicNode::LL) {</span>
<span class="line-removed">-     load_unsigned_byte(elem1, Address(str1, index, scale, 0));</span>
<span class="line-removed">-     load_unsigned_byte(elem2, Address(str2, index, scale, 0));</span>
<span class="line-removed">-   } else if (ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed">-     load_unsigned_short(elem1, Address(str1, index, scale, 0));</span>
<span class="line-removed">-     load_unsigned_short(elem2, Address(str2, index, scale, 0));</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     load_unsigned_byte(elem1, Address(str1, index, scale1, 0));</span>
<span class="line-removed">-     load_unsigned_short(elem2, Address(str2, index, scale2, 0));</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Compare strings, used for char[] and byte[].</span>
<span class="line-removed">- void MacroAssembler::string_compare(Register str1, Register str2,</span>
<span class="line-removed">-                                     Register cnt1, Register cnt2, Register result,</span>
<span class="line-removed">-                                     XMMRegister vec1, int ae) {</span>
<span class="line-removed">-   ShortBranchVerifier sbv(this);</span>
<span class="line-removed">-   Label LENGTH_DIFF_LABEL, POP_LABEL, DONE_LABEL, WHILE_HEAD_LABEL;</span>
<span class="line-removed">-   Label COMPARE_WIDE_VECTORS_LOOP_FAILED;  // used only _LP64 &amp;&amp; AVX3</span>
<span class="line-removed">-   int stride, stride2, adr_stride, adr_stride1, adr_stride2;</span>
<span class="line-removed">-   int stride2x2 = 0x40;</span>
<span class="line-removed">-   Address::ScaleFactor scale = Address::no_scale;</span>
<span class="line-removed">-   Address::ScaleFactor scale1 = Address::no_scale;</span>
<span class="line-removed">-   Address::ScaleFactor scale2 = Address::no_scale;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (ae != StrIntrinsicNode::LL) {</span>
<span class="line-removed">-     stride2x2 = 0x20;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (ae == StrIntrinsicNode::LU || ae == StrIntrinsicNode::UL) {</span>
<span class="line-removed">-     shrl(cnt2, 1);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   // Compute the minimum of the string lengths and the</span>
<span class="line-removed">-   // difference of the string lengths (stack).</span>
<span class="line-removed">-   // Do the conditional move stuff</span>
<span class="line-removed">-   movl(result, cnt1);</span>
<span class="line-removed">-   subl(cnt1, cnt2);</span>
<span class="line-removed">-   push(cnt1);</span>
<span class="line-removed">-   cmov32(Assembler::lessEqual, cnt2, result);    // cnt2 = min(cnt1, cnt2)</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Is the minimum length zero?</span>
<span class="line-removed">-   testl(cnt2, cnt2);</span>
<span class="line-removed">-   jcc(Assembler::zero, LENGTH_DIFF_LABEL);</span>
<span class="line-removed">-   if (ae == StrIntrinsicNode::LL) {</span>
<span class="line-removed">-     // Load first bytes</span>
<span class="line-removed">-     load_unsigned_byte(result, Address(str1, 0));  // result = str1[0]</span>
<span class="line-removed">-     load_unsigned_byte(cnt1, Address(str2, 0));    // cnt1   = str2[0]</span>
<span class="line-removed">-   } else if (ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed">-     // Load first characters</span>
<span class="line-removed">-     load_unsigned_short(result, Address(str1, 0));</span>
<span class="line-removed">-     load_unsigned_short(cnt1, Address(str2, 0));</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     load_unsigned_byte(result, Address(str1, 0));</span>
<span class="line-removed">-     load_unsigned_short(cnt1, Address(str2, 0));</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   subl(result, cnt1);</span>
<span class="line-removed">-   jcc(Assembler::notZero,  POP_LABEL);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed">-     // Divide length by 2 to get number of chars</span>
<span class="line-removed">-     shrl(cnt2, 1);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   cmpl(cnt2, 1);</span>
<span class="line-removed">-   jcc(Assembler::equal, LENGTH_DIFF_LABEL);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Check if the strings start at the same location and setup scale and stride</span>
<span class="line-removed">-   if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed">-     cmpptr(str1, str2);</span>
<span class="line-removed">-     jcc(Assembler::equal, LENGTH_DIFF_LABEL);</span>
<span class="line-removed">-     if (ae == StrIntrinsicNode::LL) {</span>
<span class="line-removed">-       scale = Address::times_1;</span>
<span class="line-removed">-       stride = 16;</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       scale = Address::times_2;</span>
<span class="line-removed">-       stride = 8;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     scale1 = Address::times_1;</span>
<span class="line-removed">-     scale2 = Address::times_2;</span>
<span class="line-removed">-     // scale not used</span>
<span class="line-removed">-     stride = 8;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (UseAVX &gt;= 2 &amp;&amp; UseSSE42Intrinsics) {</span>
<span class="line-removed">-     Label COMPARE_WIDE_VECTORS, VECTOR_NOT_EQUAL, COMPARE_WIDE_TAIL, COMPARE_SMALL_STR;</span>
<span class="line-removed">-     Label COMPARE_WIDE_VECTORS_LOOP, COMPARE_16_CHARS, COMPARE_INDEX_CHAR;</span>
<span class="line-removed">-     Label COMPARE_WIDE_VECTORS_LOOP_AVX2;</span>
<span class="line-removed">-     Label COMPARE_TAIL_LONG;</span>
<span class="line-removed">-     Label COMPARE_WIDE_VECTORS_LOOP_AVX3;  // used only _LP64 &amp;&amp; AVX3</span>
<span class="line-removed">- </span>
<span class="line-removed">-     int pcmpmask = 0x19;</span>
<span class="line-removed">-     if (ae == StrIntrinsicNode::LL) {</span>
<span class="line-removed">-       pcmpmask &amp;= ~0x01;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Setup to compare 16-chars (32-bytes) vectors,</span>
<span class="line-removed">-     // start from first character again because it has aligned address.</span>
<span class="line-removed">-     if (ae == StrIntrinsicNode::LL) {</span>
<span class="line-removed">-       stride2 = 32;</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       stride2 = 16;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed">-       adr_stride = stride &lt;&lt; scale;</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       adr_stride1 = 8;  //stride &lt;&lt; scale1;</span>
<span class="line-removed">-       adr_stride2 = 16; //stride &lt;&lt; scale2;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     assert(result == rax &amp;&amp; cnt2 == rdx &amp;&amp; cnt1 == rcx, &quot;pcmpestri&quot;);</span>
<span class="line-removed">-     // rax and rdx are used by pcmpestri as elements counters</span>
<span class="line-removed">-     movl(result, cnt2);</span>
<span class="line-removed">-     andl(cnt2, ~(stride2-1));   // cnt2 holds the vector count</span>
<span class="line-removed">-     jcc(Assembler::zero, COMPARE_TAIL_LONG);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // fast path : compare first 2 8-char vectors.</span>
<span class="line-removed">-     bind(COMPARE_16_CHARS);</span>
<span class="line-removed">-     if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed">-       movdqu(vec1, Address(str1, 0));</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       pmovzxbw(vec1, Address(str1, 0));</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     pcmpestri(vec1, Address(str2, 0), pcmpmask);</span>
<span class="line-removed">-     jccb(Assembler::below, COMPARE_INDEX_CHAR);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed">-       movdqu(vec1, Address(str1, adr_stride));</span>
<span class="line-removed">-       pcmpestri(vec1, Address(str2, adr_stride), pcmpmask);</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       pmovzxbw(vec1, Address(str1, adr_stride1));</span>
<span class="line-removed">-       pcmpestri(vec1, Address(str2, adr_stride2), pcmpmask);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     jccb(Assembler::aboveEqual, COMPARE_WIDE_VECTORS);</span>
<span class="line-removed">-     addl(cnt1, stride);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Compare the characters at index in cnt1</span>
<span class="line-removed">-     bind(COMPARE_INDEX_CHAR); // cnt1 has the offset of the mismatching character</span>
<span class="line-removed">-     load_next_elements(result, cnt2, str1, str2, scale, scale1, scale2, cnt1, ae);</span>
<span class="line-removed">-     subl(result, cnt2);</span>
<span class="line-removed">-     jmp(POP_LABEL);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Setup the registers to start vector comparison loop</span>
<span class="line-removed">-     bind(COMPARE_WIDE_VECTORS);</span>
<span class="line-removed">-     if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed">-       lea(str1, Address(str1, result, scale));</span>
<span class="line-removed">-       lea(str2, Address(str2, result, scale));</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       lea(str1, Address(str1, result, scale1));</span>
<span class="line-removed">-       lea(str2, Address(str2, result, scale2));</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     subl(result, stride2);</span>
<span class="line-removed">-     subl(cnt2, stride2);</span>
<span class="line-removed">-     jcc(Assembler::zero, COMPARE_WIDE_TAIL);</span>
<span class="line-removed">-     negptr(result);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     //  In a loop, compare 16-chars (32-bytes) at once using (vpxor+vptest)</span>
<span class="line-removed">-     bind(COMPARE_WIDE_VECTORS_LOOP);</span>
<span class="line-removed">- </span>
<span class="line-removed">- #ifdef _LP64</span>
<span class="line-removed">-     if ((AVX3Threshold == 0) &amp;&amp; VM_Version::supports_avx512vlbw()) { // trying 64 bytes fast loop</span>
<span class="line-removed">-       cmpl(cnt2, stride2x2);</span>
<span class="line-removed">-       jccb(Assembler::below, COMPARE_WIDE_VECTORS_LOOP_AVX2);</span>
<span class="line-removed">-       testl(cnt2, stride2x2-1);   // cnt2 holds the vector count</span>
<span class="line-removed">-       jccb(Assembler::notZero, COMPARE_WIDE_VECTORS_LOOP_AVX2);   // means we cannot subtract by 0x40</span>
<span class="line-removed">- </span>
<span class="line-removed">-       bind(COMPARE_WIDE_VECTORS_LOOP_AVX3); // the hottest loop</span>
<span class="line-removed">-       if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed">-         evmovdquq(vec1, Address(str1, result, scale), Assembler::AVX_512bit);</span>
<span class="line-removed">-         evpcmpeqb(k7, vec1, Address(str2, result, scale), Assembler::AVX_512bit); // k7 == 11..11, if operands equal, otherwise k7 has some 0</span>
<span class="line-removed">-       } else {</span>
<span class="line-removed">-         vpmovzxbw(vec1, Address(str1, result, scale1), Assembler::AVX_512bit);</span>
<span class="line-removed">-         evpcmpeqb(k7, vec1, Address(str2, result, scale2), Assembler::AVX_512bit); // k7 == 11..11, if operands equal, otherwise k7 has some 0</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       kortestql(k7, k7);</span>
<span class="line-removed">-       jcc(Assembler::aboveEqual, COMPARE_WIDE_VECTORS_LOOP_FAILED);     // miscompare</span>
<span class="line-removed">-       addptr(result, stride2x2);  // update since we already compared at this addr</span>
<span class="line-removed">-       subl(cnt2, stride2x2);      // and sub the size too</span>
<span class="line-removed">-       jccb(Assembler::notZero, COMPARE_WIDE_VECTORS_LOOP_AVX3);</span>
<span class="line-removed">- </span>
<span class="line-removed">-       vpxor(vec1, vec1);</span>
<span class="line-removed">-       jmpb(COMPARE_WIDE_TAIL);</span>
<span class="line-removed">-     }//if (VM_Version::supports_avx512vlbw())</span>
<span class="line-removed">- #endif // _LP64</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
<span class="line-removed">-     bind(COMPARE_WIDE_VECTORS_LOOP_AVX2);</span>
<span class="line-removed">-     if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed">-       vmovdqu(vec1, Address(str1, result, scale));</span>
<span class="line-removed">-       vpxor(vec1, Address(str2, result, scale));</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       vpmovzxbw(vec1, Address(str1, result, scale1), Assembler::AVX_256bit);</span>
<span class="line-removed">-       vpxor(vec1, Address(str2, result, scale2));</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     vptest(vec1, vec1);</span>
<span class="line-removed">-     jcc(Assembler::notZero, VECTOR_NOT_EQUAL);</span>
<span class="line-removed">-     addptr(result, stride2);</span>
<span class="line-removed">-     subl(cnt2, stride2);</span>
<span class="line-removed">-     jcc(Assembler::notZero, COMPARE_WIDE_VECTORS_LOOP);</span>
<span class="line-removed">-     // clean upper bits of YMM registers</span>
<span class="line-removed">-     vpxor(vec1, vec1);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // compare wide vectors tail</span>
<span class="line-removed">-     bind(COMPARE_WIDE_TAIL);</span>
<span class="line-removed">-     testptr(result, result);</span>
<span class="line-removed">-     jcc(Assembler::zero, LENGTH_DIFF_LABEL);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     movl(result, stride2);</span>
<span class="line-removed">-     movl(cnt2, result);</span>
<span class="line-removed">-     negptr(result);</span>
<span class="line-removed">-     jmp(COMPARE_WIDE_VECTORS_LOOP_AVX2);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Identifies the mismatching (higher or lower)16-bytes in the 32-byte vectors.</span>
<span class="line-removed">-     bind(VECTOR_NOT_EQUAL);</span>
<span class="line-removed">-     // clean upper bits of YMM registers</span>
<span class="line-removed">-     vpxor(vec1, vec1);</span>
<span class="line-removed">-     if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed">-       lea(str1, Address(str1, result, scale));</span>
<span class="line-removed">-       lea(str2, Address(str2, result, scale));</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       lea(str1, Address(str1, result, scale1));</span>
<span class="line-removed">-       lea(str2, Address(str2, result, scale2));</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     jmp(COMPARE_16_CHARS);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Compare tail chars, length between 1 to 15 chars</span>
<span class="line-removed">-     bind(COMPARE_TAIL_LONG);</span>
<span class="line-removed">-     movl(cnt2, result);</span>
<span class="line-removed">-     cmpl(cnt2, stride);</span>
<span class="line-removed">-     jcc(Assembler::less, COMPARE_SMALL_STR);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed">-       movdqu(vec1, Address(str1, 0));</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       pmovzxbw(vec1, Address(str1, 0));</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     pcmpestri(vec1, Address(str2, 0), pcmpmask);</span>
<span class="line-removed">-     jcc(Assembler::below, COMPARE_INDEX_CHAR);</span>
<span class="line-removed">-     subptr(cnt2, stride);</span>
<span class="line-removed">-     jcc(Assembler::zero, LENGTH_DIFF_LABEL);</span>
<span class="line-removed">-     if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed">-       lea(str1, Address(str1, result, scale));</span>
<span class="line-removed">-       lea(str2, Address(str2, result, scale));</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       lea(str1, Address(str1, result, scale1));</span>
<span class="line-removed">-       lea(str2, Address(str2, result, scale2));</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     negptr(cnt2);</span>
<span class="line-removed">-     jmpb(WHILE_HEAD_LABEL);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     bind(COMPARE_SMALL_STR);</span>
<span class="line-removed">-   } else if (UseSSE42Intrinsics) {</span>
<span class="line-removed">-     Label COMPARE_WIDE_VECTORS, VECTOR_NOT_EQUAL, COMPARE_TAIL;</span>
<span class="line-removed">-     int pcmpmask = 0x19;</span>
<span class="line-removed">-     // Setup to compare 8-char (16-byte) vectors,</span>
<span class="line-removed">-     // start from first character again because it has aligned address.</span>
<span class="line-removed">-     movl(result, cnt2);</span>
<span class="line-removed">-     andl(cnt2, ~(stride - 1));   // cnt2 holds the vector count</span>
<span class="line-removed">-     if (ae == StrIntrinsicNode::LL) {</span>
<span class="line-removed">-       pcmpmask &amp;= ~0x01;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     jcc(Assembler::zero, COMPARE_TAIL);</span>
<span class="line-removed">-     if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed">-       lea(str1, Address(str1, result, scale));</span>
<span class="line-removed">-       lea(str2, Address(str2, result, scale));</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       lea(str1, Address(str1, result, scale1));</span>
<span class="line-removed">-       lea(str2, Address(str2, result, scale2));</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     negptr(result);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // pcmpestri</span>
<span class="line-removed">-     //   inputs:</span>
<span class="line-removed">-     //     vec1- substring</span>
<span class="line-removed">-     //     rax - negative string length (elements count)</span>
<span class="line-removed">-     //     mem - scanned string</span>
<span class="line-removed">-     //     rdx - string length (elements count)</span>
<span class="line-removed">-     //     pcmpmask - cmp mode: 11000 (string compare with negated result)</span>
<span class="line-removed">-     //               + 00 (unsigned bytes) or  + 01 (unsigned shorts)</span>
<span class="line-removed">-     //   outputs:</span>
<span class="line-removed">-     //     rcx - first mismatched element index</span>
<span class="line-removed">-     assert(result == rax &amp;&amp; cnt2 == rdx &amp;&amp; cnt1 == rcx, &quot;pcmpestri&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     bind(COMPARE_WIDE_VECTORS);</span>
<span class="line-removed">-     if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed">-       movdqu(vec1, Address(str1, result, scale));</span>
<span class="line-removed">-       pcmpestri(vec1, Address(str2, result, scale), pcmpmask);</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       pmovzxbw(vec1, Address(str1, result, scale1));</span>
<span class="line-removed">-       pcmpestri(vec1, Address(str2, result, scale2), pcmpmask);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     // After pcmpestri cnt1(rcx) contains mismatched element index</span>
<span class="line-removed">- </span>
<span class="line-removed">-     jccb(Assembler::below, VECTOR_NOT_EQUAL);  // CF==1</span>
<span class="line-removed">-     addptr(result, stride);</span>
<span class="line-removed">-     subptr(cnt2, stride);</span>
<span class="line-removed">-     jccb(Assembler::notZero, COMPARE_WIDE_VECTORS);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // compare wide vectors tail</span>
<span class="line-removed">-     testptr(result, result);</span>
<span class="line-removed">-     jcc(Assembler::zero, LENGTH_DIFF_LABEL);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     movl(cnt2, stride);</span>
<span class="line-removed">-     movl(result, stride);</span>
<span class="line-removed">-     negptr(result);</span>
<span class="line-removed">-     if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed">-       movdqu(vec1, Address(str1, result, scale));</span>
<span class="line-removed">-       pcmpestri(vec1, Address(str2, result, scale), pcmpmask);</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       pmovzxbw(vec1, Address(str1, result, scale1));</span>
<span class="line-removed">-       pcmpestri(vec1, Address(str2, result, scale2), pcmpmask);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     jccb(Assembler::aboveEqual, LENGTH_DIFF_LABEL);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Mismatched characters in the vectors</span>
<span class="line-removed">-     bind(VECTOR_NOT_EQUAL);</span>
<span class="line-removed">-     addptr(cnt1, result);</span>
<span class="line-removed">-     load_next_elements(result, cnt2, str1, str2, scale, scale1, scale2, cnt1, ae);</span>
<span class="line-removed">-     subl(result, cnt2);</span>
<span class="line-removed">-     jmpb(POP_LABEL);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     bind(COMPARE_TAIL); // limit is zero</span>
<span class="line-removed">-     movl(cnt2, result);</span>
<span class="line-removed">-     // Fallthru to tail compare</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   // Shift str2 and str1 to the end of the arrays, negate min</span>
<span class="line-removed">-   if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed">-     lea(str1, Address(str1, cnt2, scale));</span>
<span class="line-removed">-     lea(str2, Address(str2, cnt2, scale));</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     lea(str1, Address(str1, cnt2, scale1));</span>
<span class="line-removed">-     lea(str2, Address(str2, cnt2, scale2));</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   decrementl(cnt2);  // first character was compared already</span>
<span class="line-removed">-   negptr(cnt2);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Compare the rest of the elements</span>
<span class="line-removed">-   bind(WHILE_HEAD_LABEL);</span>
<span class="line-removed">-   load_next_elements(result, cnt1, str1, str2, scale, scale1, scale2, cnt2, ae);</span>
<span class="line-removed">-   subl(result, cnt1);</span>
<span class="line-removed">-   jccb(Assembler::notZero, POP_LABEL);</span>
<span class="line-removed">-   increment(cnt2);</span>
<span class="line-removed">-   jccb(Assembler::notZero, WHILE_HEAD_LABEL);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Strings are equal up to min length.  Return the length difference.</span>
<span class="line-removed">-   bind(LENGTH_DIFF_LABEL);</span>
<span class="line-removed">-   pop(result);</span>
<span class="line-removed">-   if (ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed">-     // Divide diff by 2 to get number of chars</span>
<span class="line-removed">-     sarl(result, 1);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   jmpb(DONE_LABEL);</span>
<span class="line-removed">- </span>
<span class="line-removed">- #ifdef _LP64</span>
<span class="line-removed">-   if (VM_Version::supports_avx512vlbw()) {</span>
<span class="line-removed">- </span>
<span class="line-removed">-     bind(COMPARE_WIDE_VECTORS_LOOP_FAILED);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     kmovql(cnt1, k7);</span>
<span class="line-removed">-     notq(cnt1);</span>
<span class="line-removed">-     bsfq(cnt2, cnt1);</span>
<span class="line-removed">-     if (ae != StrIntrinsicNode::LL) {</span>
<span class="line-removed">-       // Divide diff by 2 to get number of chars</span>
<span class="line-removed">-       sarl(cnt2, 1);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     addq(result, cnt2);</span>
<span class="line-removed">-     if (ae == StrIntrinsicNode::LL) {</span>
<span class="line-removed">-       load_unsigned_byte(cnt1, Address(str2, result));</span>
<span class="line-removed">-       load_unsigned_byte(result, Address(str1, result));</span>
<span class="line-removed">-     } else if (ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed">-       load_unsigned_short(cnt1, Address(str2, result, scale));</span>
<span class="line-removed">-       load_unsigned_short(result, Address(str1, result, scale));</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       load_unsigned_short(cnt1, Address(str2, result, scale2));</span>
<span class="line-removed">-       load_unsigned_byte(result, Address(str1, result, scale1));</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     subl(result, cnt1);</span>
<span class="line-removed">-     jmpb(POP_LABEL);</span>
<span class="line-removed">-   }//if (VM_Version::supports_avx512vlbw())</span>
<span class="line-removed">- #endif // _LP64</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Discard the stored length difference</span>
<span class="line-removed">-   bind(POP_LABEL);</span>
<span class="line-removed">-   pop(cnt1);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // That&#39;s it</span>
<span class="line-removed">-   bind(DONE_LABEL);</span>
<span class="line-removed">-   if(ae == StrIntrinsicNode::UL) {</span>
<span class="line-removed">-     negl(result);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Search for Non-ASCII character (Negative byte value) in a byte array,</span>
<span class="line-removed">- // return true if it has any and false otherwise.</span>
<span class="line-removed">- //   ..\jdk\src\java.base\share\classes\java\lang\StringCoding.java</span>
<span class="line-removed">- //   @HotSpotIntrinsicCandidate</span>
<span class="line-removed">- //   private static boolean hasNegatives(byte[] ba, int off, int len) {</span>
<span class="line-removed">- //     for (int i = off; i &lt; off + len; i++) {</span>
<span class="line-removed">- //       if (ba[i] &lt; 0) {</span>
<span class="line-removed">- //         return true;</span>
<span class="line-removed">- //       }</span>
<span class="line-removed">- //     }</span>
<span class="line-removed">- //     return false;</span>
<span class="line-removed">- //   }</span>
<span class="line-removed">- void MacroAssembler::has_negatives(Register ary1, Register len,</span>
<span class="line-removed">-   Register result, Register tmp1,</span>
<span class="line-removed">-   XMMRegister vec1, XMMRegister vec2) {</span>
<span class="line-removed">-   // rsi: byte array</span>
<span class="line-removed">-   // rcx: len</span>
<span class="line-removed">-   // rax: result</span>
<span class="line-removed">-   ShortBranchVerifier sbv(this);</span>
<span class="line-removed">-   assert_different_registers(ary1, len, result, tmp1);</span>
<span class="line-removed">-   assert_different_registers(vec1, vec2);</span>
<span class="line-removed">-   Label TRUE_LABEL, FALSE_LABEL, DONE, COMPARE_CHAR, COMPARE_VECTORS, COMPARE_BYTE;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // len == 0</span>
<span class="line-removed">-   testl(len, len);</span>
<span class="line-removed">-   jcc(Assembler::zero, FALSE_LABEL);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if ((AVX3Threshold == 0) &amp;&amp; (UseAVX &gt; 2) &amp;&amp; // AVX512</span>
<span class="line-removed">-     VM_Version::supports_avx512vlbw() &amp;&amp;</span>
<span class="line-removed">-     VM_Version::supports_bmi2()) {</span>
<span class="line-removed">- </span>
<span class="line-removed">-     Label test_64_loop, test_tail;</span>
<span class="line-removed">-     Register tmp3_aliased = len;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     movl(tmp1, len);</span>
<span class="line-removed">-     vpxor(vec2, vec2, vec2, Assembler::AVX_512bit);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     andl(tmp1, 64 - 1);   // tail count (in chars) 0x3F</span>
<span class="line-removed">-     andl(len, ~(64 - 1));    // vector count (in chars)</span>
<span class="line-removed">-     jccb(Assembler::zero, test_tail);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     lea(ary1, Address(ary1, len, Address::times_1));</span>
<span class="line-removed">-     negptr(len);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     bind(test_64_loop);</span>
<span class="line-removed">-     // Check whether our 64 elements of size byte contain negatives</span>
<span class="line-removed">-     evpcmpgtb(k2, vec2, Address(ary1, len, Address::times_1), Assembler::AVX_512bit);</span>
<span class="line-removed">-     kortestql(k2, k2);</span>
<span class="line-removed">-     jcc(Assembler::notZero, TRUE_LABEL);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     addptr(len, 64);</span>
<span class="line-removed">-     jccb(Assembler::notZero, test_64_loop);</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
<span class="line-removed">-     bind(test_tail);</span>
<span class="line-removed">-     // bail out when there is nothing to be done</span>
<span class="line-removed">-     testl(tmp1, -1);</span>
<span class="line-removed">-     jcc(Assembler::zero, FALSE_LABEL);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // ~(~0 &lt;&lt; len) applied up to two times (for 32-bit scenario)</span>
<span class="line-removed">- #ifdef _LP64</span>
<span class="line-removed">-     mov64(tmp3_aliased, 0xFFFFFFFFFFFFFFFF);</span>
<span class="line-removed">-     shlxq(tmp3_aliased, tmp3_aliased, tmp1);</span>
<span class="line-removed">-     notq(tmp3_aliased);</span>
<span class="line-removed">-     kmovql(k3, tmp3_aliased);</span>
<span class="line-removed">- #else</span>
<span class="line-removed">-     Label k_init;</span>
<span class="line-removed">-     jmp(k_init);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // We could not read 64-bits from a general purpose register thus we move</span>
<span class="line-removed">-     // data required to compose 64 1&#39;s to the instruction stream</span>
<span class="line-removed">-     // We emit 64 byte wide series of elements from 0..63 which later on would</span>
<span class="line-removed">-     // be used as a compare targets with tail count contained in tmp1 register.</span>
<span class="line-removed">-     // Result would be a k register having tmp1 consecutive number or 1</span>
<span class="line-removed">-     // counting from least significant bit.</span>
<span class="line-removed">-     address tmp = pc();</span>
<span class="line-removed">-     emit_int64(0x0706050403020100);</span>
<span class="line-removed">-     emit_int64(0x0F0E0D0C0B0A0908);</span>
<span class="line-removed">-     emit_int64(0x1716151413121110);</span>
<span class="line-removed">-     emit_int64(0x1F1E1D1C1B1A1918);</span>
<span class="line-removed">-     emit_int64(0x2726252423222120);</span>
<span class="line-removed">-     emit_int64(0x2F2E2D2C2B2A2928);</span>
<span class="line-removed">-     emit_int64(0x3736353433323130);</span>
<span class="line-removed">-     emit_int64(0x3F3E3D3C3B3A3938);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     bind(k_init);</span>
<span class="line-removed">-     lea(len, InternalAddress(tmp));</span>
<span class="line-removed">-     // create mask to test for negative byte inside a vector</span>
<span class="line-removed">-     evpbroadcastb(vec1, tmp1, Assembler::AVX_512bit);</span>
<span class="line-removed">-     evpcmpgtb(k3, vec1, Address(len, 0), Assembler::AVX_512bit);</span>
<span class="line-removed">- </span>
<span class="line-removed">- #endif</span>
<span class="line-removed">-     evpcmpgtb(k2, k3, vec2, Address(ary1, 0), Assembler::AVX_512bit);</span>
<span class="line-removed">-     ktestq(k2, k3);</span>
<span class="line-removed">-     jcc(Assembler::notZero, TRUE_LABEL);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     jmp(FALSE_LABEL);</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     movl(result, len); // copy</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (UseAVX &gt;= 2 &amp;&amp; UseSSE &gt;= 2) {</span>
<span class="line-removed">-       // With AVX2, use 32-byte vector compare</span>
<span class="line-removed">-       Label COMPARE_WIDE_VECTORS, COMPARE_TAIL;</span>
<span class="line-removed">- </span>
<span class="line-removed">-       // Compare 32-byte vectors</span>
<span class="line-removed">-       andl(result, 0x0000001f);  //   tail count (in bytes)</span>
<span class="line-removed">-       andl(len, 0xffffffe0);   // vector count (in bytes)</span>
<span class="line-removed">-       jccb(Assembler::zero, COMPARE_TAIL);</span>
<span class="line-removed">- </span>
<span class="line-removed">-       lea(ary1, Address(ary1, len, Address::times_1));</span>
<span class="line-removed">-       negptr(len);</span>
<span class="line-removed">- </span>
<span class="line-removed">-       movl(tmp1, 0x80808080);   // create mask to test for Unicode chars in vector</span>
<span class="line-removed">-       movdl(vec2, tmp1);</span>
<span class="line-removed">-       vpbroadcastd(vec2, vec2, Assembler::AVX_256bit);</span>
<span class="line-removed">- </span>
<span class="line-removed">-       bind(COMPARE_WIDE_VECTORS);</span>
<span class="line-removed">-       vmovdqu(vec1, Address(ary1, len, Address::times_1));</span>
<span class="line-removed">-       vptest(vec1, vec2);</span>
<span class="line-removed">-       jccb(Assembler::notZero, TRUE_LABEL);</span>
<span class="line-removed">-       addptr(len, 32);</span>
<span class="line-removed">-       jcc(Assembler::notZero, COMPARE_WIDE_VECTORS);</span>
<span class="line-removed">- </span>
<span class="line-removed">-       testl(result, result);</span>
<span class="line-removed">-       jccb(Assembler::zero, FALSE_LABEL);</span>
<span class="line-removed">- </span>
<span class="line-removed">-       vmovdqu(vec1, Address(ary1, result, Address::times_1, -32));</span>
<span class="line-removed">-       vptest(vec1, vec2);</span>
<span class="line-removed">-       jccb(Assembler::notZero, TRUE_LABEL);</span>
<span class="line-removed">-       jmpb(FALSE_LABEL);</span>
<span class="line-removed">- </span>
<span class="line-removed">-       bind(COMPARE_TAIL); // len is zero</span>
<span class="line-removed">-       movl(len, result);</span>
<span class="line-removed">-       // Fallthru to tail compare</span>
<span class="line-removed">-     } else if (UseSSE42Intrinsics) {</span>
<span class="line-removed">-       // With SSE4.2, use double quad vector compare</span>
<span class="line-removed">-       Label COMPARE_WIDE_VECTORS, COMPARE_TAIL;</span>
<span class="line-removed">- </span>
<span class="line-removed">-       // Compare 16-byte vectors</span>
<span class="line-removed">-       andl(result, 0x0000000f);  //   tail count (in bytes)</span>
<span class="line-removed">-       andl(len, 0xfffffff0);   // vector count (in bytes)</span>
<span class="line-removed">-       jcc(Assembler::zero, COMPARE_TAIL);</span>
<span class="line-removed">- </span>
<span class="line-removed">-       lea(ary1, Address(ary1, len, Address::times_1));</span>
<span class="line-removed">-       negptr(len);</span>
<span class="line-removed">- </span>
<span class="line-removed">-       movl(tmp1, 0x80808080);</span>
<span class="line-removed">-       movdl(vec2, tmp1);</span>
<span class="line-removed">-       pshufd(vec2, vec2, 0);</span>
<span class="line-removed">- </span>
<span class="line-removed">-       bind(COMPARE_WIDE_VECTORS);</span>
<span class="line-removed">-       movdqu(vec1, Address(ary1, len, Address::times_1));</span>
<span class="line-removed">-       ptest(vec1, vec2);</span>
<span class="line-removed">-       jcc(Assembler::notZero, TRUE_LABEL);</span>
<span class="line-removed">-       addptr(len, 16);</span>
<span class="line-removed">-       jcc(Assembler::notZero, COMPARE_WIDE_VECTORS);</span>
<span class="line-removed">- </span>
<span class="line-removed">-       testl(result, result);</span>
<span class="line-removed">-       jcc(Assembler::zero, FALSE_LABEL);</span>
<span class="line-removed">- </span>
<span class="line-removed">-       movdqu(vec1, Address(ary1, result, Address::times_1, -16));</span>
<span class="line-removed">-       ptest(vec1, vec2);</span>
<span class="line-removed">-       jccb(Assembler::notZero, TRUE_LABEL);</span>
<span class="line-removed">-       jmpb(FALSE_LABEL);</span>
<span class="line-removed">- </span>
<span class="line-removed">-       bind(COMPARE_TAIL); // len is zero</span>
<span class="line-removed">-       movl(len, result);</span>
<span class="line-removed">-       // Fallthru to tail compare</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   // Compare 4-byte vectors</span>
<span class="line-removed">-   andl(len, 0xfffffffc); // vector count (in bytes)</span>
<span class="line-removed">-   jccb(Assembler::zero, COMPARE_CHAR);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   lea(ary1, Address(ary1, len, Address::times_1));</span>
<span class="line-removed">-   negptr(len);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   bind(COMPARE_VECTORS);</span>
<span class="line-removed">-   movl(tmp1, Address(ary1, len, Address::times_1));</span>
<span class="line-removed">-   andl(tmp1, 0x80808080);</span>
<span class="line-removed">-   jccb(Assembler::notZero, TRUE_LABEL);</span>
<span class="line-removed">-   addptr(len, 4);</span>
<span class="line-removed">-   jcc(Assembler::notZero, COMPARE_VECTORS);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Compare trailing char (final 2 bytes), if any</span>
<span class="line-removed">-   bind(COMPARE_CHAR);</span>
<span class="line-removed">-   testl(result, 0x2);   // tail  char</span>
<span class="line-removed">-   jccb(Assembler::zero, COMPARE_BYTE);</span>
<span class="line-removed">-   load_unsigned_short(tmp1, Address(ary1, 0));</span>
<span class="line-removed">-   andl(tmp1, 0x00008080);</span>
<span class="line-removed">-   jccb(Assembler::notZero, TRUE_LABEL);</span>
<span class="line-removed">-   subptr(result, 2);</span>
<span class="line-removed">-   lea(ary1, Address(ary1, 2));</span>
<span class="line-removed">- </span>
<span class="line-removed">-   bind(COMPARE_BYTE);</span>
<span class="line-removed">-   testl(result, 0x1);   // tail  byte</span>
<span class="line-removed">-   jccb(Assembler::zero, FALSE_LABEL);</span>
<span class="line-removed">-   load_unsigned_byte(tmp1, Address(ary1, 0));</span>
<span class="line-removed">-   andl(tmp1, 0x00000080);</span>
<span class="line-removed">-   jccb(Assembler::notEqual, TRUE_LABEL);</span>
<span class="line-removed">-   jmpb(FALSE_LABEL);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   bind(TRUE_LABEL);</span>
<span class="line-removed">-   movl(result, 1);   // return true</span>
<span class="line-removed">-   jmpb(DONE);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   bind(FALSE_LABEL);</span>
<span class="line-removed">-   xorl(result, result); // return false</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // That&#39;s it</span>
<span class="line-removed">-   bind(DONE);</span>
<span class="line-removed">-   if (UseAVX &gt;= 2 &amp;&amp; UseSSE &gt;= 2) {</span>
<span class="line-removed">-     // clean upper bits of YMM registers</span>
<span class="line-removed">-     vpxor(vec1, vec1);</span>
<span class="line-removed">-     vpxor(vec2, vec2);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- // Compare char[] or byte[] arrays aligned to 4 bytes or substrings.</span>
<span class="line-removed">- void MacroAssembler::arrays_equals(bool is_array_equ, Register ary1, Register ary2,</span>
<span class="line-removed">-                                    Register limit, Register result, Register chr,</span>
<span class="line-removed">-                                    XMMRegister vec1, XMMRegister vec2, bool is_char) {</span>
<span class="line-removed">-   ShortBranchVerifier sbv(this);</span>
<span class="line-removed">-   Label TRUE_LABEL, FALSE_LABEL, DONE, COMPARE_VECTORS, COMPARE_CHAR, COMPARE_BYTE;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   int length_offset  = arrayOopDesc::length_offset_in_bytes();</span>
<span class="line-removed">-   int base_offset    = arrayOopDesc::base_offset_in_bytes(is_char ? T_CHAR : T_BYTE);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (is_array_equ) {</span>
<span class="line-removed">-     // Check the input args</span>
<span class="line-removed">-     cmpoop(ary1, ary2);</span>
<span class="line-removed">-     jcc(Assembler::equal, TRUE_LABEL);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Need additional checks for arrays_equals.</span>
<span class="line-removed">-     testptr(ary1, ary1);</span>
<span class="line-removed">-     jcc(Assembler::zero, FALSE_LABEL);</span>
<span class="line-removed">-     testptr(ary2, ary2);</span>
<span class="line-removed">-     jcc(Assembler::zero, FALSE_LABEL);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Check the lengths</span>
<span class="line-removed">-     movl(limit, Address(ary1, length_offset));</span>
<span class="line-removed">-     cmpl(limit, Address(ary2, length_offset));</span>
<span class="line-removed">-     jcc(Assembler::notEqual, FALSE_LABEL);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // count == 0</span>
<span class="line-removed">-   testl(limit, limit);</span>
<span class="line-removed">-   jcc(Assembler::zero, TRUE_LABEL);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (is_array_equ) {</span>
<span class="line-removed">-     // Load array address</span>
<span class="line-removed">-     lea(ary1, Address(ary1, base_offset));</span>
<span class="line-removed">-     lea(ary2, Address(ary2, base_offset));</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (is_array_equ &amp;&amp; is_char) {</span>
<span class="line-removed">-     // arrays_equals when used for char[].</span>
<span class="line-removed">-     shll(limit, 1);      // byte count != 0</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   movl(result, limit); // copy</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (UseAVX &gt;= 2) {</span>
<span class="line-removed">-     // With AVX2, use 32-byte vector compare</span>
<span class="line-removed">-     Label COMPARE_WIDE_VECTORS, COMPARE_TAIL;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Compare 32-byte vectors</span>
<span class="line-removed">-     andl(result, 0x0000001f);  //   tail count (in bytes)</span>
<span class="line-removed">-     andl(limit, 0xffffffe0);   // vector count (in bytes)</span>
<span class="line-removed">-     jcc(Assembler::zero, COMPARE_TAIL);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     lea(ary1, Address(ary1, limit, Address::times_1));</span>
<span class="line-removed">-     lea(ary2, Address(ary2, limit, Address::times_1));</span>
<span class="line-removed">-     negptr(limit);</span>
<span class="line-removed">- </span>
<span class="line-removed">- #ifdef _LP64</span>
<span class="line-removed">-     if ((AVX3Threshold == 0) &amp;&amp; VM_Version::supports_avx512vlbw()) { // trying 64 bytes fast loop</span>
<span class="line-removed">-       Label COMPARE_WIDE_VECTORS_LOOP_AVX2, COMPARE_WIDE_VECTORS_LOOP_AVX3;</span>
<span class="line-removed">- </span>
<span class="line-removed">-       cmpl(limit, -64);</span>
<span class="line-removed">-       jcc(Assembler::greater, COMPARE_WIDE_VECTORS_LOOP_AVX2);</span>
<span class="line-removed">- </span>
<span class="line-removed">-       bind(COMPARE_WIDE_VECTORS_LOOP_AVX3); // the hottest loop</span>
<span class="line-removed">- </span>
<span class="line-removed">-       evmovdquq(vec1, Address(ary1, limit, Address::times_1), Assembler::AVX_512bit);</span>
<span class="line-removed">-       evpcmpeqb(k7, vec1, Address(ary2, limit, Address::times_1), Assembler::AVX_512bit);</span>
<span class="line-removed">-       kortestql(k7, k7);</span>
<span class="line-removed">-       jcc(Assembler::aboveEqual, FALSE_LABEL);     // miscompare</span>
<span class="line-removed">-       addptr(limit, 64);  // update since we already compared at this addr</span>
<span class="line-removed">-       cmpl(limit, -64);</span>
<span class="line-removed">-       jccb(Assembler::lessEqual, COMPARE_WIDE_VECTORS_LOOP_AVX3);</span>
<span class="line-removed">- </span>
<span class="line-removed">-       // At this point we may still need to compare -limit+result bytes.</span>
<span class="line-removed">-       // We could execute the next two instruction and just continue via non-wide path:</span>
<span class="line-removed">-       //  cmpl(limit, 0);</span>
<span class="line-removed">-       //  jcc(Assembler::equal, COMPARE_TAIL);  // true</span>
<span class="line-removed">-       // But since we stopped at the points ary{1,2}+limit which are</span>
<span class="line-removed">-       // not farther than 64 bytes from the ends of arrays ary{1,2}+result</span>
<span class="line-removed">-       // (|limit| &lt;= 32 and result &lt; 32),</span>
<span class="line-removed">-       // we may just compare the last 64 bytes.</span>
<span class="line-removed">-       //</span>
<span class="line-removed">-       addptr(result, -64);   // it is safe, bc we just came from this area</span>
<span class="line-removed">-       evmovdquq(vec1, Address(ary1, result, Address::times_1), Assembler::AVX_512bit);</span>
<span class="line-removed">-       evpcmpeqb(k7, vec1, Address(ary2, result, Address::times_1), Assembler::AVX_512bit);</span>
<span class="line-removed">-       kortestql(k7, k7);</span>
<span class="line-removed">-       jcc(Assembler::aboveEqual, FALSE_LABEL);     // miscompare</span>
<span class="line-removed">- </span>
<span class="line-removed">-       jmp(TRUE_LABEL);</span>
<span class="line-removed">- </span>
<span class="line-removed">-       bind(COMPARE_WIDE_VECTORS_LOOP_AVX2);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     }//if (VM_Version::supports_avx512vlbw())</span>
<span class="line-removed">- #endif //_LP64</span>
<span class="line-removed">-     bind(COMPARE_WIDE_VECTORS);</span>
<span class="line-removed">-     vmovdqu(vec1, Address(ary1, limit, Address::times_1));</span>
<span class="line-removed">-     vmovdqu(vec2, Address(ary2, limit, Address::times_1));</span>
<span class="line-removed">-     vpxor(vec1, vec2);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     vptest(vec1, vec1);</span>
<span class="line-removed">-     jcc(Assembler::notZero, FALSE_LABEL);</span>
<span class="line-removed">-     addptr(limit, 32);</span>
<span class="line-removed">-     jcc(Assembler::notZero, COMPARE_WIDE_VECTORS);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     testl(result, result);</span>
<span class="line-removed">-     jcc(Assembler::zero, TRUE_LABEL);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     vmovdqu(vec1, Address(ary1, result, Address::times_1, -32));</span>
<span class="line-removed">-     vmovdqu(vec2, Address(ary2, result, Address::times_1, -32));</span>
<span class="line-removed">-     vpxor(vec1, vec2);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     vptest(vec1, vec1);</span>
<span class="line-removed">-     jccb(Assembler::notZero, FALSE_LABEL);</span>
<span class="line-removed">-     jmpb(TRUE_LABEL);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     bind(COMPARE_TAIL); // limit is zero</span>
<span class="line-removed">-     movl(limit, result);</span>
<span class="line-removed">-     // Fallthru to tail compare</span>
<span class="line-removed">-   } else if (UseSSE42Intrinsics) {</span>
<span class="line-removed">-     // With SSE4.2, use double quad vector compare</span>
<span class="line-removed">-     Label COMPARE_WIDE_VECTORS, COMPARE_TAIL;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Compare 16-byte vectors</span>
<span class="line-removed">-     andl(result, 0x0000000f);  //   tail count (in bytes)</span>
<span class="line-removed">-     andl(limit, 0xfffffff0);   // vector count (in bytes)</span>
<span class="line-removed">-     jcc(Assembler::zero, COMPARE_TAIL);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     lea(ary1, Address(ary1, limit, Address::times_1));</span>
<span class="line-removed">-     lea(ary2, Address(ary2, limit, Address::times_1));</span>
<span class="line-removed">-     negptr(limit);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     bind(COMPARE_WIDE_VECTORS);</span>
<span class="line-removed">-     movdqu(vec1, Address(ary1, limit, Address::times_1));</span>
<span class="line-removed">-     movdqu(vec2, Address(ary2, limit, Address::times_1));</span>
<span class="line-removed">-     pxor(vec1, vec2);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     ptest(vec1, vec1);</span>
<span class="line-removed">-     jcc(Assembler::notZero, FALSE_LABEL);</span>
<span class="line-removed">-     addptr(limit, 16);</span>
<span class="line-removed">-     jcc(Assembler::notZero, COMPARE_WIDE_VECTORS);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     testl(result, result);</span>
<span class="line-removed">-     jcc(Assembler::zero, TRUE_LABEL);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     movdqu(vec1, Address(ary1, result, Address::times_1, -16));</span>
<span class="line-removed">-     movdqu(vec2, Address(ary2, result, Address::times_1, -16));</span>
<span class="line-removed">-     pxor(vec1, vec2);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     ptest(vec1, vec1);</span>
<span class="line-removed">-     jccb(Assembler::notZero, FALSE_LABEL);</span>
<span class="line-removed">-     jmpb(TRUE_LABEL);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     bind(COMPARE_TAIL); // limit is zero</span>
<span class="line-removed">-     movl(limit, result);</span>
<span class="line-removed">-     // Fallthru to tail compare</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Compare 4-byte vectors</span>
<span class="line-removed">-   andl(limit, 0xfffffffc); // vector count (in bytes)</span>
<span class="line-removed">-   jccb(Assembler::zero, COMPARE_CHAR);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   lea(ary1, Address(ary1, limit, Address::times_1));</span>
<span class="line-removed">-   lea(ary2, Address(ary2, limit, Address::times_1));</span>
<span class="line-removed">-   negptr(limit);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   bind(COMPARE_VECTORS);</span>
<span class="line-removed">-   movl(chr, Address(ary1, limit, Address::times_1));</span>
<span class="line-removed">-   cmpl(chr, Address(ary2, limit, Address::times_1));</span>
<span class="line-removed">-   jccb(Assembler::notEqual, FALSE_LABEL);</span>
<span class="line-removed">-   addptr(limit, 4);</span>
<span class="line-removed">-   jcc(Assembler::notZero, COMPARE_VECTORS);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Compare trailing char (final 2 bytes), if any</span>
<span class="line-removed">-   bind(COMPARE_CHAR);</span>
<span class="line-removed">-   testl(result, 0x2);   // tail  char</span>
<span class="line-removed">-   jccb(Assembler::zero, COMPARE_BYTE);</span>
<span class="line-removed">-   load_unsigned_short(chr, Address(ary1, 0));</span>
<span class="line-removed">-   load_unsigned_short(limit, Address(ary2, 0));</span>
<span class="line-removed">-   cmpl(chr, limit);</span>
<span class="line-removed">-   jccb(Assembler::notEqual, FALSE_LABEL);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (is_array_equ &amp;&amp; is_char) {</span>
<span class="line-removed">-     bind(COMPARE_BYTE);</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     lea(ary1, Address(ary1, 2));</span>
<span class="line-removed">-     lea(ary2, Address(ary2, 2));</span>
<span class="line-removed">- </span>
<span class="line-removed">-     bind(COMPARE_BYTE);</span>
<span class="line-removed">-     testl(result, 0x1);   // tail  byte</span>
<span class="line-removed">-     jccb(Assembler::zero, TRUE_LABEL);</span>
<span class="line-removed">-     load_unsigned_byte(chr, Address(ary1, 0));</span>
<span class="line-removed">-     load_unsigned_byte(limit, Address(ary2, 0));</span>
<span class="line-removed">-     cmpl(chr, limit);</span>
<span class="line-removed">-     jccb(Assembler::notEqual, FALSE_LABEL);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   bind(TRUE_LABEL);</span>
<span class="line-removed">-   movl(result, 1);   // return true</span>
<span class="line-removed">-   jmpb(DONE);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   bind(FALSE_LABEL);</span>
<span class="line-removed">-   xorl(result, result); // return false</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // That&#39;s it</span>
<span class="line-removed">-   bind(DONE);</span>
<span class="line-removed">-   if (UseAVX &gt;= 2) {</span>
<span class="line-removed">-     // clean upper bits of YMM registers</span>
<span class="line-removed">-     vpxor(vec1, vec1);</span>
<span class="line-removed">-     vpxor(vec2, vec2);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
  void MacroAssembler::generate_fill(BasicType t, bool aligned,
                                     Register to, Register value, Register count,
                                     Register rtmp, XMMRegister xtmp) {
    ShortBranchVerifier sbv(this);
    assert_different_registers(to, value, count, rtmp);
<span class="line-new-header">--- 4919,10 ---</span>
</pre>
<center><a href="jvmciCodeInstaller_x86.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_x86.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
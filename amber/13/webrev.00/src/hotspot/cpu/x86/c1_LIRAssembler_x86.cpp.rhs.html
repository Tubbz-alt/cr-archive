<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/x86/c1_LIRAssembler_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/macroAssembler.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;c1/c1_Compilation.hpp&quot;
  29 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  30 #include &quot;c1/c1_MacroAssembler.hpp&quot;
  31 #include &quot;c1/c1_Runtime1.hpp&quot;
  32 #include &quot;c1/c1_ValueStack.hpp&quot;
  33 #include &quot;ci/ciArrayKlass.hpp&quot;
  34 #include &quot;ci/ciInstance.hpp&quot;
  35 #include &quot;gc/shared/collectedHeap.hpp&quot;
  36 #include &quot;nativeInst_x86.hpp&quot;
  37 #include &quot;oops/objArrayKlass.hpp&quot;
  38 #include &quot;runtime/frame.inline.hpp&quot;
  39 #include &quot;runtime/safepointMechanism.hpp&quot;
  40 #include &quot;runtime/sharedRuntime.hpp&quot;
  41 #include &quot;utilities/powerOfTwo.hpp&quot;
  42 #include &quot;vmreg_x86.inline.hpp&quot;
  43 
  44 
  45 // These masks are used to provide 128-bit aligned bitmasks to the XMM
  46 // instructions, to allow sign-masking or sign-bit flipping.  They allow
  47 // fast versions of NegF/NegD and AbsF/AbsD.
  48 
  49 // Note: &#39;double&#39; and &#39;long long&#39; have 32-bits alignment on x86.
  50 static jlong* double_quadword(jlong *adr, jlong lo, jlong hi) {
  51   // Use the expression (adr)&amp;(~0xF) to provide 128-bits aligned address
  52   // of 128-bits operands for SSE instructions.
  53   jlong *operand = (jlong*)(((intptr_t)adr) &amp; ((intptr_t)(~0xF)));
  54   // Store the value to a 128-bits operand.
  55   operand[0] = lo;
  56   operand[1] = hi;
  57   return operand;
  58 }
  59 
  60 // Buffer for 128-bits masks used by SSE instructions.
  61 static jlong fp_signmask_pool[(4+1)*2]; // 4*128bits(data) + 128bits(alignment)
  62 
  63 // Static initialization during VM startup.
  64 static jlong *float_signmask_pool  = double_quadword(&amp;fp_signmask_pool[1*2],         CONST64(0x7FFFFFFF7FFFFFFF),         CONST64(0x7FFFFFFF7FFFFFFF));
  65 static jlong *double_signmask_pool = double_quadword(&amp;fp_signmask_pool[2*2],         CONST64(0x7FFFFFFFFFFFFFFF),         CONST64(0x7FFFFFFFFFFFFFFF));
  66 static jlong *float_signflip_pool  = double_quadword(&amp;fp_signmask_pool[3*2], (jlong)UCONST64(0x8000000080000000), (jlong)UCONST64(0x8000000080000000));
  67 static jlong *double_signflip_pool = double_quadword(&amp;fp_signmask_pool[4*2], (jlong)UCONST64(0x8000000000000000), (jlong)UCONST64(0x8000000000000000));
  68 
  69 
  70 NEEDS_CLEANUP // remove this definitions ?
  71 const Register IC_Klass    = rax;   // where the IC klass is cached
  72 const Register SYNC_header = rax;   // synchronization header
  73 const Register SHIFT_count = rcx;   // where count for shift operations must be
  74 
  75 #define __ _masm-&gt;
  76 
  77 
  78 static void select_different_registers(Register preserve,
  79                                        Register extra,
  80                                        Register &amp;tmp1,
  81                                        Register &amp;tmp2) {
  82   if (tmp1 == preserve) {
  83     assert_different_registers(tmp1, tmp2, extra);
  84     tmp1 = extra;
  85   } else if (tmp2 == preserve) {
  86     assert_different_registers(tmp1, tmp2, extra);
  87     tmp2 = extra;
  88   }
  89   assert_different_registers(preserve, tmp1, tmp2);
  90 }
  91 
  92 
  93 
  94 static void select_different_registers(Register preserve,
  95                                        Register extra,
  96                                        Register &amp;tmp1,
  97                                        Register &amp;tmp2,
  98                                        Register &amp;tmp3) {
  99   if (tmp1 == preserve) {
 100     assert_different_registers(tmp1, tmp2, tmp3, extra);
 101     tmp1 = extra;
 102   } else if (tmp2 == preserve) {
 103     assert_different_registers(tmp1, tmp2, tmp3, extra);
 104     tmp2 = extra;
 105   } else if (tmp3 == preserve) {
 106     assert_different_registers(tmp1, tmp2, tmp3, extra);
 107     tmp3 = extra;
 108   }
 109   assert_different_registers(preserve, tmp1, tmp2, tmp3);
 110 }
 111 
 112 
 113 
 114 bool LIR_Assembler::is_small_constant(LIR_Opr opr) {
 115   if (opr-&gt;is_constant()) {
 116     LIR_Const* constant = opr-&gt;as_constant_ptr();
 117     switch (constant-&gt;type()) {
 118       case T_INT: {
 119         return true;
 120       }
 121 
 122       default:
 123         return false;
 124     }
 125   }
 126   return false;
 127 }
 128 
 129 
 130 LIR_Opr LIR_Assembler::receiverOpr() {
 131   return FrameMap::receiver_opr;
 132 }
 133 
 134 LIR_Opr LIR_Assembler::osrBufferPointer() {
 135   return FrameMap::as_pointer_opr(receiverOpr()-&gt;as_register());
 136 }
 137 
 138 //--------------fpu register translations-----------------------
 139 
 140 
 141 address LIR_Assembler::float_constant(float f) {
 142   address const_addr = __ float_constant(f);
 143   if (const_addr == NULL) {
 144     bailout(&quot;const section overflow&quot;);
 145     return __ code()-&gt;consts()-&gt;start();
 146   } else {
 147     return const_addr;
 148   }
 149 }
 150 
 151 
 152 address LIR_Assembler::double_constant(double d) {
 153   address const_addr = __ double_constant(d);
 154   if (const_addr == NULL) {
 155     bailout(&quot;const section overflow&quot;);
 156     return __ code()-&gt;consts()-&gt;start();
 157   } else {
 158     return const_addr;
 159   }
 160 }
 161 
 162 #ifndef _LP64
 163 void LIR_Assembler::fpop() {
 164   __ fpop();
 165 }
 166 
 167 void LIR_Assembler::fxch(int i) {
 168   __ fxch(i);
 169 }
 170 
 171 void LIR_Assembler::fld(int i) {
 172   __ fld_s(i);
 173 }
 174 
 175 void LIR_Assembler::ffree(int i) {
 176   __ ffree(i);
 177 }
 178 #endif // !_LP64
 179 
 180 void LIR_Assembler::breakpoint() {
 181   __ int3();
 182 }
 183 
 184 void LIR_Assembler::push(LIR_Opr opr) {
 185   if (opr-&gt;is_single_cpu()) {
 186     __ push_reg(opr-&gt;as_register());
 187   } else if (opr-&gt;is_double_cpu()) {
 188     NOT_LP64(__ push_reg(opr-&gt;as_register_hi()));
 189     __ push_reg(opr-&gt;as_register_lo());
 190   } else if (opr-&gt;is_stack()) {
 191     __ push_addr(frame_map()-&gt;address_for_slot(opr-&gt;single_stack_ix()));
 192   } else if (opr-&gt;is_constant()) {
 193     LIR_Const* const_opr = opr-&gt;as_constant_ptr();
 194     if (const_opr-&gt;type() == T_OBJECT) {
 195       __ push_oop(const_opr-&gt;as_jobject());
 196     } else if (const_opr-&gt;type() == T_INT) {
 197       __ push_jint(const_opr-&gt;as_jint());
 198     } else {
 199       ShouldNotReachHere();
 200     }
 201 
 202   } else {
 203     ShouldNotReachHere();
 204   }
 205 }
 206 
 207 void LIR_Assembler::pop(LIR_Opr opr) {
 208   if (opr-&gt;is_single_cpu()) {
 209     __ pop_reg(opr-&gt;as_register());
 210   } else {
 211     ShouldNotReachHere();
 212   }
 213 }
 214 
 215 bool LIR_Assembler::is_literal_address(LIR_Address* addr) {
 216   return addr-&gt;base()-&gt;is_illegal() &amp;&amp; addr-&gt;index()-&gt;is_illegal();
 217 }
 218 
 219 //-------------------------------------------
 220 
 221 Address LIR_Assembler::as_Address(LIR_Address* addr) {
 222   return as_Address(addr, rscratch1);
 223 }
 224 
 225 Address LIR_Assembler::as_Address(LIR_Address* addr, Register tmp) {
 226   if (addr-&gt;base()-&gt;is_illegal()) {
 227     assert(addr-&gt;index()-&gt;is_illegal(), &quot;must be illegal too&quot;);
 228     AddressLiteral laddr((address)addr-&gt;disp(), relocInfo::none);
 229     if (! __ reachable(laddr)) {
 230       __ movptr(tmp, laddr.addr());
 231       Address res(tmp, 0);
 232       return res;
 233     } else {
 234       return __ as_Address(laddr);
 235     }
 236   }
 237 
 238   Register base = addr-&gt;base()-&gt;as_pointer_register();
 239 
 240   if (addr-&gt;index()-&gt;is_illegal()) {
 241     return Address( base, addr-&gt;disp());
 242   } else if (addr-&gt;index()-&gt;is_cpu_register()) {
 243     Register index = addr-&gt;index()-&gt;as_pointer_register();
 244     return Address(base, index, (Address::ScaleFactor) addr-&gt;scale(), addr-&gt;disp());
 245   } else if (addr-&gt;index()-&gt;is_constant()) {
 246     intptr_t addr_offset = (addr-&gt;index()-&gt;as_constant_ptr()-&gt;as_jint() &lt;&lt; addr-&gt;scale()) + addr-&gt;disp();
 247     assert(Assembler::is_simm32(addr_offset), &quot;must be&quot;);
 248 
 249     return Address(base, addr_offset);
 250   } else {
 251     Unimplemented();
 252     return Address();
 253   }
 254 }
 255 
 256 
 257 Address LIR_Assembler::as_Address_hi(LIR_Address* addr) {
 258   Address base = as_Address(addr);
 259   return Address(base._base, base._index, base._scale, base._disp + BytesPerWord);
 260 }
 261 
 262 
 263 Address LIR_Assembler::as_Address_lo(LIR_Address* addr) {
 264   return as_Address(addr);
 265 }
 266 
 267 
 268 void LIR_Assembler::osr_entry() {
 269   offsets()-&gt;set_value(CodeOffsets::OSR_Entry, code_offset());
 270   BlockBegin* osr_entry = compilation()-&gt;hir()-&gt;osr_entry();
 271   ValueStack* entry_state = osr_entry-&gt;state();
 272   int number_of_locks = entry_state-&gt;locks_size();
 273 
 274   // we jump here if osr happens with the interpreter
 275   // state set up to continue at the beginning of the
 276   // loop that triggered osr - in particular, we have
 277   // the following registers setup:
 278   //
 279   // rcx: osr buffer
 280   //
 281 
 282   // build frame
 283   ciMethod* m = compilation()-&gt;method();
 284   __ build_frame(initial_frame_size_in_bytes(), bang_size_in_bytes());
 285 
 286   // OSR buffer is
 287   //
 288   // locals[nlocals-1..0]
 289   // monitors[0..number_of_locks]
 290   //
 291   // locals is a direct copy of the interpreter frame so in the osr buffer
 292   // so first slot in the local array is the last local from the interpreter
 293   // and last slot is local[0] (receiver) from the interpreter
 294   //
 295   // Similarly with locks. The first lock slot in the osr buffer is the nth lock
 296   // from the interpreter frame, the nth lock slot in the osr buffer is 0th lock
 297   // in the interpreter frame (the method lock if a sync method)
 298 
 299   // Initialize monitors in the compiled activation.
 300   //   rcx: pointer to osr buffer
 301   //
 302   // All other registers are dead at this point and the locals will be
 303   // copied into place by code emitted in the IR.
 304 
 305   Register OSR_buf = osrBufferPointer()-&gt;as_pointer_register();
 306   { assert(frame::interpreter_frame_monitor_size() == BasicObjectLock::size(), &quot;adjust code below&quot;);
 307     int monitor_offset = BytesPerWord * method()-&gt;max_locals() +
 308       (BasicObjectLock::size() * BytesPerWord) * (number_of_locks - 1);
 309     // SharedRuntime::OSR_migration_begin() packs BasicObjectLocks in
 310     // the OSR buffer using 2 word entries: first the lock and then
 311     // the oop.
 312     for (int i = 0; i &lt; number_of_locks; i++) {
 313       int slot_offset = monitor_offset - ((i * 2) * BytesPerWord);
 314 #ifdef ASSERT
 315       // verify the interpreter&#39;s monitor has a non-null object
 316       {
 317         Label L;
 318         __ cmpptr(Address(OSR_buf, slot_offset + 1*BytesPerWord), (int32_t)NULL_WORD);
 319         __ jcc(Assembler::notZero, L);
 320         __ stop(&quot;locked object is NULL&quot;);
 321         __ bind(L);
 322       }
 323 #endif
 324       __ movptr(rbx, Address(OSR_buf, slot_offset + 0));
 325       __ movptr(frame_map()-&gt;address_for_monitor_lock(i), rbx);
 326       __ movptr(rbx, Address(OSR_buf, slot_offset + 1*BytesPerWord));
 327       __ movptr(frame_map()-&gt;address_for_monitor_object(i), rbx);
 328     }
 329   }
 330 }
 331 
 332 
 333 // inline cache check; done before the frame is built.
 334 int LIR_Assembler::check_icache() {
 335   Register receiver = FrameMap::receiver_opr-&gt;as_register();
 336   Register ic_klass = IC_Klass;
 337   const int ic_cmp_size = LP64_ONLY(10) NOT_LP64(9);
 338   const bool do_post_padding = VerifyOops || UseCompressedClassPointers;
 339   if (!do_post_padding) {
 340     // insert some nops so that the verified entry point is aligned on CodeEntryAlignment
 341     __ align(CodeEntryAlignment, __ offset() + ic_cmp_size);
 342   }
 343   int offset = __ offset();
 344   __ inline_cache_check(receiver, IC_Klass);
 345   assert(__ offset() % CodeEntryAlignment == 0 || do_post_padding, &quot;alignment must be correct&quot;);
 346   if (do_post_padding) {
 347     // force alignment after the cache check.
 348     // It&#39;s been verified to be aligned if !VerifyOops
 349     __ align(CodeEntryAlignment);
 350   }
 351   return offset;
 352 }
 353 
 354 void LIR_Assembler::clinit_barrier(ciMethod* method) {
 355   assert(VM_Version::supports_fast_class_init_checks(), &quot;sanity&quot;);
 356   assert(!method-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);
 357 
 358   Label L_skip_barrier;
 359   Register klass = rscratch1;
 360   Register thread = LP64_ONLY( r15_thread ) NOT_LP64( noreg );
 361   assert(thread != noreg, &quot;x86_32 not implemented&quot;);
 362 
 363   __ mov_metadata(klass, method-&gt;holder()-&gt;constant_encoding());
 364   __ clinit_barrier(klass, thread, &amp;L_skip_barrier /*L_fast_path*/);
 365 
 366   __ jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub()));
 367 
 368   __ bind(L_skip_barrier);
 369 }
 370 
 371 void LIR_Assembler::jobject2reg_with_patching(Register reg, CodeEmitInfo* info) {
 372   jobject o = NULL;
 373   PatchingStub* patch = new PatchingStub(_masm, patching_id(info));
 374   __ movoop(reg, o);
 375   patching_epilog(patch, lir_patch_normal, reg, info);
 376 }
 377 
 378 void LIR_Assembler::klass2reg_with_patching(Register reg, CodeEmitInfo* info) {
 379   Metadata* o = NULL;
 380   PatchingStub* patch = new PatchingStub(_masm, PatchingStub::load_klass_id);
 381   __ mov_metadata(reg, o);
 382   patching_epilog(patch, lir_patch_normal, reg, info);
 383 }
 384 
 385 // This specifies the rsp decrement needed to build the frame
 386 int LIR_Assembler::initial_frame_size_in_bytes() const {
 387   // if rounding, must let FrameMap know!
 388 
 389   // The frame_map records size in slots (32bit word)
 390 
 391   // subtract two words to account for return address and link
 392   return (frame_map()-&gt;framesize() - (2*VMRegImpl::slots_per_word))  * VMRegImpl::stack_slot_size;
 393 }
 394 
 395 
 396 int LIR_Assembler::emit_exception_handler() {
 397   // if the last instruction is a call (typically to do a throw which
 398   // is coming at the end after block reordering) the return address
 399   // must still point into the code area in order to avoid assertion
 400   // failures when searching for the corresponding bci =&gt; add a nop
 401   // (was bug 5/14/1999 - gri)
 402   __ nop();
 403 
 404   // generate code for exception handler
 405   address handler_base = __ start_a_stub(exception_handler_size());
 406   if (handler_base == NULL) {
 407     // not enough space left for the handler
 408     bailout(&quot;exception handler overflow&quot;);
 409     return -1;
 410   }
 411 
 412   int offset = code_offset();
 413 
 414   // the exception oop and pc are in rax, and rdx
 415   // no other registers need to be preserved, so invalidate them
 416   __ invalidate_registers(false, true, true, false, true, true);
 417 
 418   // check that there is really an exception
 419   __ verify_not_null_oop(rax);
 420 
 421   // search an exception handler (rax: exception oop, rdx: throwing pc)
 422   __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::handle_exception_from_callee_id)));
 423   __ should_not_reach_here();
 424   guarantee(code_offset() - offset &lt;= exception_handler_size(), &quot;overflow&quot;);
 425   __ end_a_stub();
 426 
 427   return offset;
 428 }
 429 
 430 
 431 // Emit the code to remove the frame from the stack in the exception
 432 // unwind path.
 433 int LIR_Assembler::emit_unwind_handler() {
 434 #ifndef PRODUCT
 435   if (CommentedAssembly) {
 436     _masm-&gt;block_comment(&quot;Unwind handler&quot;);
 437   }
 438 #endif
 439 
 440   int offset = code_offset();
 441 
 442   // Fetch the exception from TLS and clear out exception related thread state
 443   Register thread = NOT_LP64(rsi) LP64_ONLY(r15_thread);
 444   NOT_LP64(__ get_thread(rsi));
 445   __ movptr(rax, Address(thread, JavaThread::exception_oop_offset()));
 446   __ movptr(Address(thread, JavaThread::exception_oop_offset()), (intptr_t)NULL_WORD);
 447   __ movptr(Address(thread, JavaThread::exception_pc_offset()), (intptr_t)NULL_WORD);
 448 
 449   __ bind(_unwind_handler_entry);
 450   __ verify_not_null_oop(rax);
 451   if (method()-&gt;is_synchronized() || compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 452     __ mov(rbx, rax);  // Preserve the exception (rbx is always callee-saved)
 453   }
 454 
 455   // Preform needed unlocking
 456   MonitorExitStub* stub = NULL;
 457   if (method()-&gt;is_synchronized()) {
 458     monitor_address(0, FrameMap::rax_opr);
 459     stub = new MonitorExitStub(FrameMap::rax_opr, true, 0);
 460     __ unlock_object(rdi, rsi, rax, *stub-&gt;entry());
 461     __ bind(*stub-&gt;continuation());
 462   }
 463 
 464   if (compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 465 #ifdef _LP64
 466     __ mov(rdi, r15_thread);
 467     __ mov_metadata(rsi, method()-&gt;constant_encoding());
 468 #else
 469     __ get_thread(rax);
 470     __ movptr(Address(rsp, 0), rax);
 471     __ mov_metadata(Address(rsp, sizeof(void*)), method()-&gt;constant_encoding());
 472 #endif
 473     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_exit)));
 474   }
 475 
 476   if (method()-&gt;is_synchronized() || compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 477     __ mov(rax, rbx);  // Restore the exception
 478   }
 479 
 480   // remove the activation and dispatch to the unwind handler
 481   __ remove_frame(initial_frame_size_in_bytes());
 482   __ jump(RuntimeAddress(Runtime1::entry_for(Runtime1::unwind_exception_id)));
 483 
 484   // Emit the slow path assembly
 485   if (stub != NULL) {
 486     stub-&gt;emit_code(this);
 487   }
 488 
 489   return offset;
 490 }
 491 
 492 
 493 int LIR_Assembler::emit_deopt_handler() {
 494   // if the last instruction is a call (typically to do a throw which
 495   // is coming at the end after block reordering) the return address
 496   // must still point into the code area in order to avoid assertion
 497   // failures when searching for the corresponding bci =&gt; add a nop
 498   // (was bug 5/14/1999 - gri)
 499   __ nop();
 500 
 501   // generate code for exception handler
 502   address handler_base = __ start_a_stub(deopt_handler_size());
 503   if (handler_base == NULL) {
 504     // not enough space left for the handler
 505     bailout(&quot;deopt handler overflow&quot;);
 506     return -1;
 507   }
 508 
 509   int offset = code_offset();
 510   InternalAddress here(__ pc());
 511 
 512   __ pushptr(here.addr());
 513   __ jump(RuntimeAddress(SharedRuntime::deopt_blob()-&gt;unpack()));
 514   guarantee(code_offset() - offset &lt;= deopt_handler_size(), &quot;overflow&quot;);
 515   __ end_a_stub();
 516 
 517   return offset;
 518 }
 519 
 520 
 521 void LIR_Assembler::return_op(LIR_Opr result) {
 522   assert(result-&gt;is_illegal() || !result-&gt;is_single_cpu() || result-&gt;as_register() == rax, &quot;word returns are in rax,&quot;);
 523   if (!result-&gt;is_illegal() &amp;&amp; result-&gt;is_float_kind() &amp;&amp; !result-&gt;is_xmm_register()) {
 524     assert(result-&gt;fpu() == 0, &quot;result must already be on TOS&quot;);
 525   }
 526 
 527   // Pop the stack before the safepoint code
 528   __ remove_frame(initial_frame_size_in_bytes());
 529 
 530   if (StackReservedPages &gt; 0 &amp;&amp; compilation()-&gt;has_reserved_stack_access()) {
 531     __ reserved_stack_check();
 532   }
 533 
 534   bool result_is_oop = result-&gt;is_valid() ? result-&gt;is_oop() : false;
 535 
 536   // Note: we do not need to round double result; float result has the right precision
 537   // the poll sets the condition code, but no data registers
 538 
<a name="2" id="anc2"></a>
 539 #ifdef _LP64
<a name="3" id="anc3"></a><span class="line-modified"> 540   const Register poll_addr = rscratch1;</span>
<span class="line-modified"> 541   __ movptr(poll_addr, Address(r15_thread, Thread::polling_page_offset()));</span>
 542 #else
<a name="4" id="anc4"></a><span class="line-modified"> 543   const Register poll_addr = rbx;</span>
<span class="line-modified"> 544   assert(FrameMap::is_caller_save_register(poll_addr), &quot;will overwrite&quot;);</span>
<span class="line-modified"> 545   __ get_thread(poll_addr);</span>
<span class="line-modified"> 546   __ movptr(poll_addr, Address(poll_addr, Thread::polling_page_offset()));</span>
 547 #endif
<a name="5" id="anc5"></a><span class="line-modified"> 548   __ relocate(relocInfo::poll_return_type);</span>
<span class="line-modified"> 549   __ testl(rax, Address(poll_addr, 0));</span>











 550   __ ret(0);
 551 }
 552 
 553 
 554 int LIR_Assembler::safepoint_poll(LIR_Opr tmp, CodeEmitInfo* info) {
 555   guarantee(info != NULL, &quot;Shouldn&#39;t be NULL&quot;);
 556   int offset = __ offset();
<a name="6" id="anc6"></a>
 557 #ifdef _LP64
<a name="7" id="anc7"></a><span class="line-modified"> 558   const Register poll_addr = rscratch1;</span>
<span class="line-modified"> 559   __ movptr(poll_addr, Address(r15_thread, Thread::polling_page_offset()));</span>
 560 #else
<a name="8" id="anc8"></a><span class="line-modified"> 561   assert(tmp-&gt;is_cpu_register(), &quot;needed&quot;);</span>
<span class="line-modified"> 562   const Register poll_addr = tmp-&gt;as_register();</span>
<span class="line-modified"> 563   __ get_thread(poll_addr);</span>
<span class="line-modified"> 564   __ movptr(poll_addr, Address(poll_addr, in_bytes(Thread::polling_page_offset())));</span>
 565 #endif
<a name="9" id="anc9"></a><span class="line-modified"> 566   add_debug_info_for_branch(info);</span>
<span class="line-modified"> 567   __ relocate(relocInfo::poll_type);</span>
<span class="line-modified"> 568   address pre_pc = __ pc();</span>
<span class="line-modified"> 569   __ testl(rax, Address(poll_addr, 0));</span>
<span class="line-modified"> 570   address post_pc = __ pc();</span>
<span class="line-modified"> 571   guarantee(pointer_delta(post_pc, pre_pc, 1) == 2 LP64_ONLY(+1), &quot;must be exact length&quot;);</span>













 572   return offset;
 573 }
 574 
 575 
 576 void LIR_Assembler::move_regs(Register from_reg, Register to_reg) {
 577   if (from_reg != to_reg) __ mov(to_reg, from_reg);
 578 }
 579 
 580 void LIR_Assembler::swap_reg(Register a, Register b) {
 581   __ xchgptr(a, b);
 582 }
 583 
 584 
 585 void LIR_Assembler::const2reg(LIR_Opr src, LIR_Opr dest, LIR_PatchCode patch_code, CodeEmitInfo* info) {
 586   assert(src-&gt;is_constant(), &quot;should not call otherwise&quot;);
 587   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
 588   LIR_Const* c = src-&gt;as_constant_ptr();
 589 
 590   switch (c-&gt;type()) {
 591     case T_INT: {
 592       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 593       __ movl(dest-&gt;as_register(), c-&gt;as_jint());
 594       break;
 595     }
 596 
 597     case T_ADDRESS: {
 598       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 599       __ movptr(dest-&gt;as_register(), c-&gt;as_jint());
 600       break;
 601     }
 602 
 603     case T_LONG: {
 604       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 605 #ifdef _LP64
 606       __ movptr(dest-&gt;as_register_lo(), (intptr_t)c-&gt;as_jlong());
 607 #else
 608       __ movptr(dest-&gt;as_register_lo(), c-&gt;as_jint_lo());
 609       __ movptr(dest-&gt;as_register_hi(), c-&gt;as_jint_hi());
 610 #endif // _LP64
 611       break;
 612     }
 613 
 614     case T_OBJECT: {
 615       if (patch_code != lir_patch_none) {
 616         jobject2reg_with_patching(dest-&gt;as_register(), info);
 617       } else {
 618         __ movoop(dest-&gt;as_register(), c-&gt;as_jobject());
 619       }
 620       break;
 621     }
 622 
 623     case T_METADATA: {
 624       if (patch_code != lir_patch_none) {
 625         klass2reg_with_patching(dest-&gt;as_register(), info);
 626       } else {
 627         __ mov_metadata(dest-&gt;as_register(), c-&gt;as_metadata());
 628       }
 629       break;
 630     }
 631 
 632     case T_FLOAT: {
 633       if (dest-&gt;is_single_xmm()) {
 634         if (LP64_ONLY(UseAVX &lt;= 2 &amp;&amp;) c-&gt;is_zero_float()) {
 635           __ xorps(dest-&gt;as_xmm_float_reg(), dest-&gt;as_xmm_float_reg());
 636         } else {
 637           __ movflt(dest-&gt;as_xmm_float_reg(),
 638                    InternalAddress(float_constant(c-&gt;as_jfloat())));
 639         }
 640       } else {
 641 #ifndef _LP64
 642         assert(dest-&gt;is_single_fpu(), &quot;must be&quot;);
 643         assert(dest-&gt;fpu_regnr() == 0, &quot;dest must be TOS&quot;);
 644         if (c-&gt;is_zero_float()) {
 645           __ fldz();
 646         } else if (c-&gt;is_one_float()) {
 647           __ fld1();
 648         } else {
 649           __ fld_s (InternalAddress(float_constant(c-&gt;as_jfloat())));
 650         }
 651 #else
 652         ShouldNotReachHere();
 653 #endif // !_LP64
 654       }
 655       break;
 656     }
 657 
 658     case T_DOUBLE: {
 659       if (dest-&gt;is_double_xmm()) {
 660         if (LP64_ONLY(UseAVX &lt;= 2 &amp;&amp;) c-&gt;is_zero_double()) {
 661           __ xorpd(dest-&gt;as_xmm_double_reg(), dest-&gt;as_xmm_double_reg());
 662         } else {
 663           __ movdbl(dest-&gt;as_xmm_double_reg(),
 664                     InternalAddress(double_constant(c-&gt;as_jdouble())));
 665         }
 666       } else {
 667 #ifndef _LP64
 668         assert(dest-&gt;is_double_fpu(), &quot;must be&quot;);
 669         assert(dest-&gt;fpu_regnrLo() == 0, &quot;dest must be TOS&quot;);
 670         if (c-&gt;is_zero_double()) {
 671           __ fldz();
 672         } else if (c-&gt;is_one_double()) {
 673           __ fld1();
 674         } else {
 675           __ fld_d (InternalAddress(double_constant(c-&gt;as_jdouble())));
 676         }
 677 #else
 678         ShouldNotReachHere();
 679 #endif // !_LP64
 680       }
 681       break;
 682     }
 683 
 684     default:
 685       ShouldNotReachHere();
 686   }
 687 }
 688 
 689 void LIR_Assembler::const2stack(LIR_Opr src, LIR_Opr dest) {
 690   assert(src-&gt;is_constant(), &quot;should not call otherwise&quot;);
 691   assert(dest-&gt;is_stack(), &quot;should not call otherwise&quot;);
 692   LIR_Const* c = src-&gt;as_constant_ptr();
 693 
 694   switch (c-&gt;type()) {
 695     case T_INT:  // fall through
 696     case T_FLOAT:
 697       __ movl(frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()), c-&gt;as_jint_bits());
 698       break;
 699 
 700     case T_ADDRESS:
 701       __ movptr(frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()), c-&gt;as_jint_bits());
 702       break;
 703 
 704     case T_OBJECT:
 705       __ movoop(frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()), c-&gt;as_jobject());
 706       break;
 707 
 708     case T_LONG:  // fall through
 709     case T_DOUBLE:
 710 #ifdef _LP64
 711       __ movptr(frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(),
 712                                             lo_word_offset_in_bytes), (intptr_t)c-&gt;as_jlong_bits());
 713 #else
 714       __ movptr(frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(),
 715                                               lo_word_offset_in_bytes), c-&gt;as_jint_lo_bits());
 716       __ movptr(frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(),
 717                                               hi_word_offset_in_bytes), c-&gt;as_jint_hi_bits());
 718 #endif // _LP64
 719       break;
 720 
 721     default:
 722       ShouldNotReachHere();
 723   }
 724 }
 725 
 726 void LIR_Assembler::const2mem(LIR_Opr src, LIR_Opr dest, BasicType type, CodeEmitInfo* info, bool wide) {
 727   assert(src-&gt;is_constant(), &quot;should not call otherwise&quot;);
 728   assert(dest-&gt;is_address(), &quot;should not call otherwise&quot;);
 729   LIR_Const* c = src-&gt;as_constant_ptr();
 730   LIR_Address* addr = dest-&gt;as_address_ptr();
 731 
 732   int null_check_here = code_offset();
 733   switch (type) {
 734     case T_INT:    // fall through
 735     case T_FLOAT:
 736       __ movl(as_Address(addr), c-&gt;as_jint_bits());
 737       break;
 738 
 739     case T_ADDRESS:
 740       __ movptr(as_Address(addr), c-&gt;as_jint_bits());
 741       break;
 742 
 743     case T_OBJECT:  // fall through
 744     case T_ARRAY:
 745       if (c-&gt;as_jobject() == NULL) {
 746         if (UseCompressedOops &amp;&amp; !wide) {
 747           __ movl(as_Address(addr), (int32_t)NULL_WORD);
 748         } else {
 749 #ifdef _LP64
 750           __ xorptr(rscratch1, rscratch1);
 751           null_check_here = code_offset();
 752           __ movptr(as_Address(addr), rscratch1);
 753 #else
 754           __ movptr(as_Address(addr), NULL_WORD);
 755 #endif
 756         }
 757       } else {
 758         if (is_literal_address(addr)) {
 759           ShouldNotReachHere();
 760           __ movoop(as_Address(addr, noreg), c-&gt;as_jobject());
 761         } else {
 762 #ifdef _LP64
 763           __ movoop(rscratch1, c-&gt;as_jobject());
 764           if (UseCompressedOops &amp;&amp; !wide) {
 765             __ encode_heap_oop(rscratch1);
 766             null_check_here = code_offset();
 767             __ movl(as_Address_lo(addr), rscratch1);
 768           } else {
 769             null_check_here = code_offset();
 770             __ movptr(as_Address_lo(addr), rscratch1);
 771           }
 772 #else
 773           __ movoop(as_Address(addr), c-&gt;as_jobject());
 774 #endif
 775         }
 776       }
 777       break;
 778 
 779     case T_LONG:    // fall through
 780     case T_DOUBLE:
 781 #ifdef _LP64
 782       if (is_literal_address(addr)) {
 783         ShouldNotReachHere();
 784         __ movptr(as_Address(addr, r15_thread), (intptr_t)c-&gt;as_jlong_bits());
 785       } else {
 786         __ movptr(r10, (intptr_t)c-&gt;as_jlong_bits());
 787         null_check_here = code_offset();
 788         __ movptr(as_Address_lo(addr), r10);
 789       }
 790 #else
 791       // Always reachable in 32bit so this doesn&#39;t produce useless move literal
 792       __ movptr(as_Address_hi(addr), c-&gt;as_jint_hi_bits());
 793       __ movptr(as_Address_lo(addr), c-&gt;as_jint_lo_bits());
 794 #endif // _LP64
 795       break;
 796 
 797     case T_BOOLEAN: // fall through
 798     case T_BYTE:
 799       __ movb(as_Address(addr), c-&gt;as_jint() &amp; 0xFF);
 800       break;
 801 
 802     case T_CHAR:    // fall through
 803     case T_SHORT:
 804       __ movw(as_Address(addr), c-&gt;as_jint() &amp; 0xFFFF);
 805       break;
 806 
 807     default:
 808       ShouldNotReachHere();
 809   };
 810 
 811   if (info != NULL) {
 812     add_debug_info_for_null_check(null_check_here, info);
 813   }
 814 }
 815 
 816 
 817 void LIR_Assembler::reg2reg(LIR_Opr src, LIR_Opr dest) {
 818   assert(src-&gt;is_register(), &quot;should not call otherwise&quot;);
 819   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
 820 
 821   // move between cpu-registers
 822   if (dest-&gt;is_single_cpu()) {
 823 #ifdef _LP64
 824     if (src-&gt;type() == T_LONG) {
 825       // Can do LONG -&gt; OBJECT
 826       move_regs(src-&gt;as_register_lo(), dest-&gt;as_register());
 827       return;
 828     }
 829 #endif
 830     assert(src-&gt;is_single_cpu(), &quot;must match&quot;);
 831     if (src-&gt;type() == T_OBJECT) {
 832       __ verify_oop(src-&gt;as_register());
 833     }
 834     move_regs(src-&gt;as_register(), dest-&gt;as_register());
 835 
 836   } else if (dest-&gt;is_double_cpu()) {
 837 #ifdef _LP64
 838     if (is_reference_type(src-&gt;type())) {
 839       // Surprising to me but we can see move of a long to t_object
 840       __ verify_oop(src-&gt;as_register());
 841       move_regs(src-&gt;as_register(), dest-&gt;as_register_lo());
 842       return;
 843     }
 844 #endif
 845     assert(src-&gt;is_double_cpu(), &quot;must match&quot;);
 846     Register f_lo = src-&gt;as_register_lo();
 847     Register f_hi = src-&gt;as_register_hi();
 848     Register t_lo = dest-&gt;as_register_lo();
 849     Register t_hi = dest-&gt;as_register_hi();
 850 #ifdef _LP64
 851     assert(f_hi == f_lo, &quot;must be same&quot;);
 852     assert(t_hi == t_lo, &quot;must be same&quot;);
 853     move_regs(f_lo, t_lo);
 854 #else
 855     assert(f_lo != f_hi &amp;&amp; t_lo != t_hi, &quot;invalid register allocation&quot;);
 856 
 857 
 858     if (f_lo == t_hi &amp;&amp; f_hi == t_lo) {
 859       swap_reg(f_lo, f_hi);
 860     } else if (f_hi == t_lo) {
 861       assert(f_lo != t_hi, &quot;overwriting register&quot;);
 862       move_regs(f_hi, t_hi);
 863       move_regs(f_lo, t_lo);
 864     } else {
 865       assert(f_hi != t_lo, &quot;overwriting register&quot;);
 866       move_regs(f_lo, t_lo);
 867       move_regs(f_hi, t_hi);
 868     }
 869 #endif // LP64
 870 
 871 #ifndef _LP64
 872     // special moves from fpu-register to xmm-register
 873     // necessary for method results
 874   } else if (src-&gt;is_single_xmm() &amp;&amp; !dest-&gt;is_single_xmm()) {
 875     __ movflt(Address(rsp, 0), src-&gt;as_xmm_float_reg());
 876     __ fld_s(Address(rsp, 0));
 877   } else if (src-&gt;is_double_xmm() &amp;&amp; !dest-&gt;is_double_xmm()) {
 878     __ movdbl(Address(rsp, 0), src-&gt;as_xmm_double_reg());
 879     __ fld_d(Address(rsp, 0));
 880   } else if (dest-&gt;is_single_xmm() &amp;&amp; !src-&gt;is_single_xmm()) {
 881     __ fstp_s(Address(rsp, 0));
 882     __ movflt(dest-&gt;as_xmm_float_reg(), Address(rsp, 0));
 883   } else if (dest-&gt;is_double_xmm() &amp;&amp; !src-&gt;is_double_xmm()) {
 884     __ fstp_d(Address(rsp, 0));
 885     __ movdbl(dest-&gt;as_xmm_double_reg(), Address(rsp, 0));
 886 #endif // !_LP64
 887 
 888     // move between xmm-registers
 889   } else if (dest-&gt;is_single_xmm()) {
 890     assert(src-&gt;is_single_xmm(), &quot;must match&quot;);
 891     __ movflt(dest-&gt;as_xmm_float_reg(), src-&gt;as_xmm_float_reg());
 892   } else if (dest-&gt;is_double_xmm()) {
 893     assert(src-&gt;is_double_xmm(), &quot;must match&quot;);
 894     __ movdbl(dest-&gt;as_xmm_double_reg(), src-&gt;as_xmm_double_reg());
 895 
 896 #ifndef _LP64
 897     // move between fpu-registers (no instruction necessary because of fpu-stack)
 898   } else if (dest-&gt;is_single_fpu() || dest-&gt;is_double_fpu()) {
 899     assert(src-&gt;is_single_fpu() || src-&gt;is_double_fpu(), &quot;must match&quot;);
 900     assert(src-&gt;fpu() == dest-&gt;fpu(), &quot;currently should be nothing to do&quot;);
 901 #endif // !_LP64
 902 
 903   } else {
 904     ShouldNotReachHere();
 905   }
 906 }
 907 
 908 void LIR_Assembler::reg2stack(LIR_Opr src, LIR_Opr dest, BasicType type, bool pop_fpu_stack) {
 909   assert(src-&gt;is_register(), &quot;should not call otherwise&quot;);
 910   assert(dest-&gt;is_stack(), &quot;should not call otherwise&quot;);
 911 
 912   if (src-&gt;is_single_cpu()) {
 913     Address dst = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 914     if (is_reference_type(type)) {
 915       __ verify_oop(src-&gt;as_register());
 916       __ movptr (dst, src-&gt;as_register());
 917     } else if (type == T_METADATA || type == T_ADDRESS) {
 918       __ movptr (dst, src-&gt;as_register());
 919     } else {
 920       __ movl (dst, src-&gt;as_register());
 921     }
 922 
 923   } else if (src-&gt;is_double_cpu()) {
 924     Address dstLO = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(), lo_word_offset_in_bytes);
 925     Address dstHI = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(), hi_word_offset_in_bytes);
 926     __ movptr (dstLO, src-&gt;as_register_lo());
 927     NOT_LP64(__ movptr (dstHI, src-&gt;as_register_hi()));
 928 
 929   } else if (src-&gt;is_single_xmm()) {
 930     Address dst_addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 931     __ movflt(dst_addr, src-&gt;as_xmm_float_reg());
 932 
 933   } else if (src-&gt;is_double_xmm()) {
 934     Address dst_addr = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix());
 935     __ movdbl(dst_addr, src-&gt;as_xmm_double_reg());
 936 
 937 #ifndef _LP64
 938   } else if (src-&gt;is_single_fpu()) {
 939     assert(src-&gt;fpu_regnr() == 0, &quot;argument must be on TOS&quot;);
 940     Address dst_addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 941     if (pop_fpu_stack)     __ fstp_s (dst_addr);
 942     else                   __ fst_s  (dst_addr);
 943 
 944   } else if (src-&gt;is_double_fpu()) {
 945     assert(src-&gt;fpu_regnrLo() == 0, &quot;argument must be on TOS&quot;);
 946     Address dst_addr = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix());
 947     if (pop_fpu_stack)     __ fstp_d (dst_addr);
 948     else                   __ fst_d  (dst_addr);
 949 #endif // !_LP64
 950 
 951   } else {
 952     ShouldNotReachHere();
 953   }
 954 }
 955 
 956 
 957 void LIR_Assembler::reg2mem(LIR_Opr src, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code, CodeEmitInfo* info, bool pop_fpu_stack, bool wide, bool /* unaligned */) {
 958   LIR_Address* to_addr = dest-&gt;as_address_ptr();
 959   PatchingStub* patch = NULL;
 960   Register compressed_src = rscratch1;
 961 
 962   if (is_reference_type(type)) {
 963     __ verify_oop(src-&gt;as_register());
 964 #ifdef _LP64
 965     if (UseCompressedOops &amp;&amp; !wide) {
 966       __ movptr(compressed_src, src-&gt;as_register());
 967       __ encode_heap_oop(compressed_src);
 968       if (patch_code != lir_patch_none) {
 969         info-&gt;oop_map()-&gt;set_narrowoop(compressed_src-&gt;as_VMReg());
 970       }
 971     }
 972 #endif
 973   }
 974 
 975   if (patch_code != lir_patch_none) {
 976     patch = new PatchingStub(_masm, PatchingStub::access_field_id);
 977     Address toa = as_Address(to_addr);
 978     assert(toa.disp() != 0, &quot;must have&quot;);
 979   }
 980 
 981   int null_check_here = code_offset();
 982   switch (type) {
 983     case T_FLOAT: {
 984 #ifdef _LP64
 985       assert(src-&gt;is_single_xmm(), &quot;not a float&quot;);
 986       __ movflt(as_Address(to_addr), src-&gt;as_xmm_float_reg());
 987 #else
 988       if (src-&gt;is_single_xmm()) {
 989         __ movflt(as_Address(to_addr), src-&gt;as_xmm_float_reg());
 990       } else {
 991         assert(src-&gt;is_single_fpu(), &quot;must be&quot;);
 992         assert(src-&gt;fpu_regnr() == 0, &quot;argument must be on TOS&quot;);
 993         if (pop_fpu_stack)      __ fstp_s(as_Address(to_addr));
 994         else                    __ fst_s (as_Address(to_addr));
 995       }
 996 #endif // _LP64
 997       break;
 998     }
 999 
1000     case T_DOUBLE: {
1001 #ifdef _LP64
1002       assert(src-&gt;is_double_xmm(), &quot;not a double&quot;);
1003       __ movdbl(as_Address(to_addr), src-&gt;as_xmm_double_reg());
1004 #else
1005       if (src-&gt;is_double_xmm()) {
1006         __ movdbl(as_Address(to_addr), src-&gt;as_xmm_double_reg());
1007       } else {
1008         assert(src-&gt;is_double_fpu(), &quot;must be&quot;);
1009         assert(src-&gt;fpu_regnrLo() == 0, &quot;argument must be on TOS&quot;);
1010         if (pop_fpu_stack)      __ fstp_d(as_Address(to_addr));
1011         else                    __ fst_d (as_Address(to_addr));
1012       }
1013 #endif // _LP64
1014       break;
1015     }
1016 
1017     case T_ARRAY:   // fall through
1018     case T_OBJECT:  // fall through
1019       if (UseCompressedOops &amp;&amp; !wide) {
1020         __ movl(as_Address(to_addr), compressed_src);
1021       } else {
1022         __ movptr(as_Address(to_addr), src-&gt;as_register());
1023       }
1024       break;
1025     case T_METADATA:
1026       // We get here to store a method pointer to the stack to pass to
1027       // a dtrace runtime call. This can&#39;t work on 64 bit with
1028       // compressed klass ptrs: T_METADATA can be a compressed klass
1029       // ptr or a 64 bit method pointer.
1030       LP64_ONLY(ShouldNotReachHere());
1031       __ movptr(as_Address(to_addr), src-&gt;as_register());
1032       break;
1033     case T_ADDRESS:
1034       __ movptr(as_Address(to_addr), src-&gt;as_register());
1035       break;
1036     case T_INT:
1037       __ movl(as_Address(to_addr), src-&gt;as_register());
1038       break;
1039 
1040     case T_LONG: {
1041       Register from_lo = src-&gt;as_register_lo();
1042       Register from_hi = src-&gt;as_register_hi();
1043 #ifdef _LP64
1044       __ movptr(as_Address_lo(to_addr), from_lo);
1045 #else
1046       Register base = to_addr-&gt;base()-&gt;as_register();
1047       Register index = noreg;
1048       if (to_addr-&gt;index()-&gt;is_register()) {
1049         index = to_addr-&gt;index()-&gt;as_register();
1050       }
1051       if (base == from_lo || index == from_lo) {
1052         assert(base != from_hi, &quot;can&#39;t be&quot;);
1053         assert(index == noreg || (index != base &amp;&amp; index != from_hi), &quot;can&#39;t handle this&quot;);
1054         __ movl(as_Address_hi(to_addr), from_hi);
1055         if (patch != NULL) {
1056           patching_epilog(patch, lir_patch_high, base, info);
1057           patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1058           patch_code = lir_patch_low;
1059         }
1060         __ movl(as_Address_lo(to_addr), from_lo);
1061       } else {
1062         assert(index == noreg || (index != base &amp;&amp; index != from_lo), &quot;can&#39;t handle this&quot;);
1063         __ movl(as_Address_lo(to_addr), from_lo);
1064         if (patch != NULL) {
1065           patching_epilog(patch, lir_patch_low, base, info);
1066           patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1067           patch_code = lir_patch_high;
1068         }
1069         __ movl(as_Address_hi(to_addr), from_hi);
1070       }
1071 #endif // _LP64
1072       break;
1073     }
1074 
1075     case T_BYTE:    // fall through
1076     case T_BOOLEAN: {
1077       Register src_reg = src-&gt;as_register();
1078       Address dst_addr = as_Address(to_addr);
1079       assert(VM_Version::is_P6() || src_reg-&gt;has_byte_register(), &quot;must use byte registers if not P6&quot;);
1080       __ movb(dst_addr, src_reg);
1081       break;
1082     }
1083 
1084     case T_CHAR:    // fall through
1085     case T_SHORT:
1086       __ movw(as_Address(to_addr), src-&gt;as_register());
1087       break;
1088 
1089     default:
1090       ShouldNotReachHere();
1091   }
1092   if (info != NULL) {
1093     add_debug_info_for_null_check(null_check_here, info);
1094   }
1095 
1096   if (patch_code != lir_patch_none) {
1097     patching_epilog(patch, patch_code, to_addr-&gt;base()-&gt;as_register(), info);
1098   }
1099 }
1100 
1101 
1102 void LIR_Assembler::stack2reg(LIR_Opr src, LIR_Opr dest, BasicType type) {
1103   assert(src-&gt;is_stack(), &quot;should not call otherwise&quot;);
1104   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
1105 
1106   if (dest-&gt;is_single_cpu()) {
1107     if (is_reference_type(type)) {
1108       __ movptr(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()));
1109       __ verify_oop(dest-&gt;as_register());
1110     } else if (type == T_METADATA || type == T_ADDRESS) {
1111       __ movptr(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()));
1112     } else {
1113       __ movl(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()));
1114     }
1115 
1116   } else if (dest-&gt;is_double_cpu()) {
1117     Address src_addr_LO = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix(), lo_word_offset_in_bytes);
1118     Address src_addr_HI = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix(), hi_word_offset_in_bytes);
1119     __ movptr(dest-&gt;as_register_lo(), src_addr_LO);
1120     NOT_LP64(__ movptr(dest-&gt;as_register_hi(), src_addr_HI));
1121 
1122   } else if (dest-&gt;is_single_xmm()) {
1123     Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix());
1124     __ movflt(dest-&gt;as_xmm_float_reg(), src_addr);
1125 
1126   } else if (dest-&gt;is_double_xmm()) {
1127     Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix());
1128     __ movdbl(dest-&gt;as_xmm_double_reg(), src_addr);
1129 
1130 #ifndef _LP64
1131   } else if (dest-&gt;is_single_fpu()) {
1132     assert(dest-&gt;fpu_regnr() == 0, &quot;dest must be TOS&quot;);
1133     Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix());
1134     __ fld_s(src_addr);
1135 
1136   } else if (dest-&gt;is_double_fpu()) {
1137     assert(dest-&gt;fpu_regnrLo() == 0, &quot;dest must be TOS&quot;);
1138     Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix());
1139     __ fld_d(src_addr);
1140 #endif // _LP64
1141 
1142   } else {
1143     ShouldNotReachHere();
1144   }
1145 }
1146 
1147 
1148 void LIR_Assembler::stack2stack(LIR_Opr src, LIR_Opr dest, BasicType type) {
1149   if (src-&gt;is_single_stack()) {
1150     if (is_reference_type(type)) {
1151       __ pushptr(frame_map()-&gt;address_for_slot(src -&gt;single_stack_ix()));
1152       __ popptr (frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));
1153     } else {
1154 #ifndef _LP64
1155       __ pushl(frame_map()-&gt;address_for_slot(src -&gt;single_stack_ix()));
1156       __ popl (frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));
1157 #else
1158       //no pushl on 64bits
1159       __ movl(rscratch1, frame_map()-&gt;address_for_slot(src -&gt;single_stack_ix()));
1160       __ movl(frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()), rscratch1);
1161 #endif
1162     }
1163 
1164   } else if (src-&gt;is_double_stack()) {
1165 #ifdef _LP64
1166     __ pushptr(frame_map()-&gt;address_for_slot(src -&gt;double_stack_ix()));
1167     __ popptr (frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix()));
1168 #else
1169     __ pushl(frame_map()-&gt;address_for_slot(src -&gt;double_stack_ix(), 0));
1170     // push and pop the part at src + wordSize, adding wordSize for the previous push
1171     __ pushl(frame_map()-&gt;address_for_slot(src -&gt;double_stack_ix(), 2 * wordSize));
1172     __ popl (frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(), 2 * wordSize));
1173     __ popl (frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(), 0));
1174 #endif // _LP64
1175 
1176   } else {
1177     ShouldNotReachHere();
1178   }
1179 }
1180 
1181 
1182 void LIR_Assembler::mem2reg(LIR_Opr src, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code, CodeEmitInfo* info, bool wide, bool /* unaligned */) {
1183   assert(src-&gt;is_address(), &quot;should not call otherwise&quot;);
1184   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
1185 
1186   LIR_Address* addr = src-&gt;as_address_ptr();
1187   Address from_addr = as_Address(addr);
1188 
1189   if (addr-&gt;base()-&gt;type() == T_OBJECT) {
1190     __ verify_oop(addr-&gt;base()-&gt;as_pointer_register());
1191   }
1192 
1193   switch (type) {
1194     case T_BOOLEAN: // fall through
1195     case T_BYTE:    // fall through
1196     case T_CHAR:    // fall through
1197     case T_SHORT:
1198       if (!VM_Version::is_P6() &amp;&amp; !from_addr.uses(dest-&gt;as_register())) {
1199         // on pre P6 processors we may get partial register stalls
1200         // so blow away the value of to_rinfo before loading a
1201         // partial word into it.  Do it here so that it precedes
1202         // the potential patch point below.
1203         __ xorptr(dest-&gt;as_register(), dest-&gt;as_register());
1204       }
1205       break;
1206    default:
1207      break;
1208   }
1209 
1210   PatchingStub* patch = NULL;
1211   if (patch_code != lir_patch_none) {
1212     patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1213     assert(from_addr.disp() != 0, &quot;must have&quot;);
1214   }
1215   if (info != NULL) {
1216     add_debug_info_for_null_check_here(info);
1217   }
1218 
1219   switch (type) {
1220     case T_FLOAT: {
1221       if (dest-&gt;is_single_xmm()) {
1222         __ movflt(dest-&gt;as_xmm_float_reg(), from_addr);
1223       } else {
1224 #ifndef _LP64
1225         assert(dest-&gt;is_single_fpu(), &quot;must be&quot;);
1226         assert(dest-&gt;fpu_regnr() == 0, &quot;dest must be TOS&quot;);
1227         __ fld_s(from_addr);
1228 #else
1229         ShouldNotReachHere();
1230 #endif // !LP64
1231       }
1232       break;
1233     }
1234 
1235     case T_DOUBLE: {
1236       if (dest-&gt;is_double_xmm()) {
1237         __ movdbl(dest-&gt;as_xmm_double_reg(), from_addr);
1238       } else {
1239 #ifndef _LP64
1240         assert(dest-&gt;is_double_fpu(), &quot;must be&quot;);
1241         assert(dest-&gt;fpu_regnrLo() == 0, &quot;dest must be TOS&quot;);
1242         __ fld_d(from_addr);
1243 #else
1244         ShouldNotReachHere();
1245 #endif // !LP64
1246       }
1247       break;
1248     }
1249 
1250     case T_OBJECT:  // fall through
1251     case T_ARRAY:   // fall through
1252       if (UseCompressedOops &amp;&amp; !wide) {
1253         __ movl(dest-&gt;as_register(), from_addr);
1254       } else {
1255         __ movptr(dest-&gt;as_register(), from_addr);
1256       }
1257       break;
1258 
1259     case T_ADDRESS:
1260       if (UseCompressedClassPointers &amp;&amp; addr-&gt;disp() == oopDesc::klass_offset_in_bytes()) {
1261         __ movl(dest-&gt;as_register(), from_addr);
1262       } else {
1263         __ movptr(dest-&gt;as_register(), from_addr);
1264       }
1265       break;
1266     case T_INT:
1267       __ movl(dest-&gt;as_register(), from_addr);
1268       break;
1269 
1270     case T_LONG: {
1271       Register to_lo = dest-&gt;as_register_lo();
1272       Register to_hi = dest-&gt;as_register_hi();
1273 #ifdef _LP64
1274       __ movptr(to_lo, as_Address_lo(addr));
1275 #else
1276       Register base = addr-&gt;base()-&gt;as_register();
1277       Register index = noreg;
1278       if (addr-&gt;index()-&gt;is_register()) {
1279         index = addr-&gt;index()-&gt;as_register();
1280       }
1281       if ((base == to_lo &amp;&amp; index == to_hi) ||
1282           (base == to_hi &amp;&amp; index == to_lo)) {
1283         // addresses with 2 registers are only formed as a result of
1284         // array access so this code will never have to deal with
1285         // patches or null checks.
1286         assert(info == NULL &amp;&amp; patch == NULL, &quot;must be&quot;);
1287         __ lea(to_hi, as_Address(addr));
1288         __ movl(to_lo, Address(to_hi, 0));
1289         __ movl(to_hi, Address(to_hi, BytesPerWord));
1290       } else if (base == to_lo || index == to_lo) {
1291         assert(base != to_hi, &quot;can&#39;t be&quot;);
1292         assert(index == noreg || (index != base &amp;&amp; index != to_hi), &quot;can&#39;t handle this&quot;);
1293         __ movl(to_hi, as_Address_hi(addr));
1294         if (patch != NULL) {
1295           patching_epilog(patch, lir_patch_high, base, info);
1296           patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1297           patch_code = lir_patch_low;
1298         }
1299         __ movl(to_lo, as_Address_lo(addr));
1300       } else {
1301         assert(index == noreg || (index != base &amp;&amp; index != to_lo), &quot;can&#39;t handle this&quot;);
1302         __ movl(to_lo, as_Address_lo(addr));
1303         if (patch != NULL) {
1304           patching_epilog(patch, lir_patch_low, base, info);
1305           patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1306           patch_code = lir_patch_high;
1307         }
1308         __ movl(to_hi, as_Address_hi(addr));
1309       }
1310 #endif // _LP64
1311       break;
1312     }
1313 
1314     case T_BOOLEAN: // fall through
1315     case T_BYTE: {
1316       Register dest_reg = dest-&gt;as_register();
1317       assert(VM_Version::is_P6() || dest_reg-&gt;has_byte_register(), &quot;must use byte registers if not P6&quot;);
1318       if (VM_Version::is_P6() || from_addr.uses(dest_reg)) {
1319         __ movsbl(dest_reg, from_addr);
1320       } else {
1321         __ movb(dest_reg, from_addr);
1322         __ shll(dest_reg, 24);
1323         __ sarl(dest_reg, 24);
1324       }
1325       break;
1326     }
1327 
1328     case T_CHAR: {
1329       Register dest_reg = dest-&gt;as_register();
1330       assert(VM_Version::is_P6() || dest_reg-&gt;has_byte_register(), &quot;must use byte registers if not P6&quot;);
1331       if (VM_Version::is_P6() || from_addr.uses(dest_reg)) {
1332         __ movzwl(dest_reg, from_addr);
1333       } else {
1334         __ movw(dest_reg, from_addr);
1335       }
1336       break;
1337     }
1338 
1339     case T_SHORT: {
1340       Register dest_reg = dest-&gt;as_register();
1341       if (VM_Version::is_P6() || from_addr.uses(dest_reg)) {
1342         __ movswl(dest_reg, from_addr);
1343       } else {
1344         __ movw(dest_reg, from_addr);
1345         __ shll(dest_reg, 16);
1346         __ sarl(dest_reg, 16);
1347       }
1348       break;
1349     }
1350 
1351     default:
1352       ShouldNotReachHere();
1353   }
1354 
1355   if (patch != NULL) {
1356     patching_epilog(patch, patch_code, addr-&gt;base()-&gt;as_register(), info);
1357   }
1358 
1359   if (is_reference_type(type)) {
1360 #ifdef _LP64
1361     if (UseCompressedOops &amp;&amp; !wide) {
1362       __ decode_heap_oop(dest-&gt;as_register());
1363     }
1364 #endif
1365 
1366     // Load barrier has not yet been applied, so ZGC can&#39;t verify the oop here
1367     if (!UseZGC) {
1368       __ verify_oop(dest-&gt;as_register());
1369     }
1370   } else if (type == T_ADDRESS &amp;&amp; addr-&gt;disp() == oopDesc::klass_offset_in_bytes()) {
1371 #ifdef _LP64
1372     if (UseCompressedClassPointers) {
1373       __ decode_klass_not_null(dest-&gt;as_register());
1374     }
1375 #endif
1376   }
1377 }
1378 
1379 
1380 NEEDS_CLEANUP; // This could be static?
1381 Address::ScaleFactor LIR_Assembler::array_element_size(BasicType type) const {
1382   int elem_size = type2aelembytes(type);
1383   switch (elem_size) {
1384     case 1: return Address::times_1;
1385     case 2: return Address::times_2;
1386     case 4: return Address::times_4;
1387     case 8: return Address::times_8;
1388   }
1389   ShouldNotReachHere();
1390   return Address::no_scale;
1391 }
1392 
1393 
1394 void LIR_Assembler::emit_op3(LIR_Op3* op) {
1395   switch (op-&gt;code()) {
1396     case lir_idiv:
1397     case lir_irem:
1398       arithmetic_idiv(op-&gt;code(),
1399                       op-&gt;in_opr1(),
1400                       op-&gt;in_opr2(),
1401                       op-&gt;in_opr3(),
1402                       op-&gt;result_opr(),
1403                       op-&gt;info());
1404       break;
1405     case lir_fmad:
1406       __ fmad(op-&gt;result_opr()-&gt;as_xmm_double_reg(),
1407               op-&gt;in_opr1()-&gt;as_xmm_double_reg(),
1408               op-&gt;in_opr2()-&gt;as_xmm_double_reg(),
1409               op-&gt;in_opr3()-&gt;as_xmm_double_reg());
1410       break;
1411     case lir_fmaf:
1412       __ fmaf(op-&gt;result_opr()-&gt;as_xmm_float_reg(),
1413               op-&gt;in_opr1()-&gt;as_xmm_float_reg(),
1414               op-&gt;in_opr2()-&gt;as_xmm_float_reg(),
1415               op-&gt;in_opr3()-&gt;as_xmm_float_reg());
1416       break;
1417     default:      ShouldNotReachHere(); break;
1418   }
1419 }
1420 
1421 void LIR_Assembler::emit_opBranch(LIR_OpBranch* op) {
1422 #ifdef ASSERT
1423   assert(op-&gt;block() == NULL || op-&gt;block()-&gt;label() == op-&gt;label(), &quot;wrong label&quot;);
1424   if (op-&gt;block() != NULL)  _branch_target_blocks.append(op-&gt;block());
1425   if (op-&gt;ublock() != NULL) _branch_target_blocks.append(op-&gt;ublock());
1426 #endif
1427 
1428   if (op-&gt;cond() == lir_cond_always) {
1429     if (op-&gt;info() != NULL) add_debug_info_for_branch(op-&gt;info());
1430     __ jmp (*(op-&gt;label()));
1431   } else {
1432     Assembler::Condition acond = Assembler::zero;
1433     if (op-&gt;code() == lir_cond_float_branch) {
1434       assert(op-&gt;ublock() != NULL, &quot;must have unordered successor&quot;);
1435       __ jcc(Assembler::parity, *(op-&gt;ublock()-&gt;label()));
1436       switch(op-&gt;cond()) {
1437         case lir_cond_equal:        acond = Assembler::equal;      break;
1438         case lir_cond_notEqual:     acond = Assembler::notEqual;   break;
1439         case lir_cond_less:         acond = Assembler::below;      break;
1440         case lir_cond_lessEqual:    acond = Assembler::belowEqual; break;
1441         case lir_cond_greaterEqual: acond = Assembler::aboveEqual; break;
1442         case lir_cond_greater:      acond = Assembler::above;      break;
1443         default:                         ShouldNotReachHere();
1444       }
1445     } else {
1446       switch (op-&gt;cond()) {
1447         case lir_cond_equal:        acond = Assembler::equal;       break;
1448         case lir_cond_notEqual:     acond = Assembler::notEqual;    break;
1449         case lir_cond_less:         acond = Assembler::less;        break;
1450         case lir_cond_lessEqual:    acond = Assembler::lessEqual;   break;
1451         case lir_cond_greaterEqual: acond = Assembler::greaterEqual;break;
1452         case lir_cond_greater:      acond = Assembler::greater;     break;
1453         case lir_cond_belowEqual:   acond = Assembler::belowEqual;  break;
1454         case lir_cond_aboveEqual:   acond = Assembler::aboveEqual;  break;
1455         default:                         ShouldNotReachHere();
1456       }
1457     }
1458     __ jcc(acond,*(op-&gt;label()));
1459   }
1460 }
1461 
1462 void LIR_Assembler::emit_opConvert(LIR_OpConvert* op) {
1463   LIR_Opr src  = op-&gt;in_opr();
1464   LIR_Opr dest = op-&gt;result_opr();
1465 
1466   switch (op-&gt;bytecode()) {
1467     case Bytecodes::_i2l:
1468 #ifdef _LP64
1469       __ movl2ptr(dest-&gt;as_register_lo(), src-&gt;as_register());
1470 #else
1471       move_regs(src-&gt;as_register(), dest-&gt;as_register_lo());
1472       move_regs(src-&gt;as_register(), dest-&gt;as_register_hi());
1473       __ sarl(dest-&gt;as_register_hi(), 31);
1474 #endif // LP64
1475       break;
1476 
1477     case Bytecodes::_l2i:
1478 #ifdef _LP64
1479       __ movl(dest-&gt;as_register(), src-&gt;as_register_lo());
1480 #else
1481       move_regs(src-&gt;as_register_lo(), dest-&gt;as_register());
1482 #endif
1483       break;
1484 
1485     case Bytecodes::_i2b:
1486       move_regs(src-&gt;as_register(), dest-&gt;as_register());
1487       __ sign_extend_byte(dest-&gt;as_register());
1488       break;
1489 
1490     case Bytecodes::_i2c:
1491       move_regs(src-&gt;as_register(), dest-&gt;as_register());
1492       __ andl(dest-&gt;as_register(), 0xFFFF);
1493       break;
1494 
1495     case Bytecodes::_i2s:
1496       move_regs(src-&gt;as_register(), dest-&gt;as_register());
1497       __ sign_extend_short(dest-&gt;as_register());
1498       break;
1499 
1500 
1501 #ifdef _LP64
1502     case Bytecodes::_f2d:
1503       __ cvtss2sd(dest-&gt;as_xmm_double_reg(), src-&gt;as_xmm_float_reg());
1504       break;
1505 
1506     case Bytecodes::_d2f:
1507       __ cvtsd2ss(dest-&gt;as_xmm_float_reg(), src-&gt;as_xmm_double_reg());
1508       break;
1509 
1510     case Bytecodes::_i2f:
1511       __ cvtsi2ssl(dest-&gt;as_xmm_float_reg(), src-&gt;as_register());
1512       break;
1513 
1514     case Bytecodes::_i2d:
1515       __ cvtsi2sdl(dest-&gt;as_xmm_double_reg(), src-&gt;as_register());
1516       break;
1517 
1518     case Bytecodes::_l2f:
1519       __ cvtsi2ssq(dest-&gt;as_xmm_float_reg(), src-&gt;as_register_lo());
1520       break;
1521 
1522     case Bytecodes::_l2d:
1523       __ cvtsi2sdq(dest-&gt;as_xmm_double_reg(), src-&gt;as_register_lo());
1524       break;
1525 
1526     case Bytecodes::_f2i:
1527       __ convert_f2i(dest-&gt;as_register(), src-&gt;as_xmm_float_reg());
1528       break;
1529 
1530     case Bytecodes::_d2i:
1531       __ convert_d2i(dest-&gt;as_register(), src-&gt;as_xmm_double_reg());
1532       break;
1533 
1534     case Bytecodes::_f2l:
1535       __ convert_f2l(dest-&gt;as_register_lo(), src-&gt;as_xmm_float_reg());
1536       break;
1537 
1538     case Bytecodes::_d2l:
1539       __ convert_d2l(dest-&gt;as_register_lo(), src-&gt;as_xmm_double_reg());
1540       break;
1541 #else
1542     case Bytecodes::_f2d:
1543     case Bytecodes::_d2f:
1544       if (dest-&gt;is_single_xmm()) {
1545         __ cvtsd2ss(dest-&gt;as_xmm_float_reg(), src-&gt;as_xmm_double_reg());
1546       } else if (dest-&gt;is_double_xmm()) {
1547         __ cvtss2sd(dest-&gt;as_xmm_double_reg(), src-&gt;as_xmm_float_reg());
1548       } else {
1549         assert(src-&gt;fpu() == dest-&gt;fpu(), &quot;register must be equal&quot;);
1550         // do nothing (float result is rounded later through spilling)
1551       }
1552       break;
1553 
1554     case Bytecodes::_i2f:
1555     case Bytecodes::_i2d:
1556       if (dest-&gt;is_single_xmm()) {
1557         __ cvtsi2ssl(dest-&gt;as_xmm_float_reg(), src-&gt;as_register());
1558       } else if (dest-&gt;is_double_xmm()) {
1559         __ cvtsi2sdl(dest-&gt;as_xmm_double_reg(), src-&gt;as_register());
1560       } else {
1561         assert(dest-&gt;fpu() == 0, &quot;result must be on TOS&quot;);
1562         __ movl(Address(rsp, 0), src-&gt;as_register());
1563         __ fild_s(Address(rsp, 0));
1564       }
1565       break;
1566 
1567     case Bytecodes::_l2f:
1568     case Bytecodes::_l2d:
1569       assert(!dest-&gt;is_xmm_register(), &quot;result in xmm register not supported (no SSE instruction present)&quot;);
1570       assert(dest-&gt;fpu() == 0, &quot;result must be on TOS&quot;);
1571       __ movptr(Address(rsp, 0),          src-&gt;as_register_lo());
1572       __ movl(Address(rsp, BytesPerWord), src-&gt;as_register_hi());
1573       __ fild_d(Address(rsp, 0));
1574       // float result is rounded later through spilling
1575       break;
1576 
1577     case Bytecodes::_f2i:
1578     case Bytecodes::_d2i:
1579       if (src-&gt;is_single_xmm()) {
1580         __ cvttss2sil(dest-&gt;as_register(), src-&gt;as_xmm_float_reg());
1581       } else if (src-&gt;is_double_xmm()) {
1582         __ cvttsd2sil(dest-&gt;as_register(), src-&gt;as_xmm_double_reg());
1583       } else {
1584         assert(src-&gt;fpu() == 0, &quot;input must be on TOS&quot;);
1585         __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_trunc()));
1586         __ fist_s(Address(rsp, 0));
1587         __ movl(dest-&gt;as_register(), Address(rsp, 0));
1588         __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_std()));
1589       }
1590       // IA32 conversion instructions do not match JLS for overflow, underflow and NaN -&gt; fixup in stub
1591       assert(op-&gt;stub() != NULL, &quot;stub required&quot;);
1592       __ cmpl(dest-&gt;as_register(), 0x80000000);
1593       __ jcc(Assembler::equal, *op-&gt;stub()-&gt;entry());
1594       __ bind(*op-&gt;stub()-&gt;continuation());
1595       break;
1596 
1597     case Bytecodes::_f2l:
1598     case Bytecodes::_d2l:
1599       assert(!src-&gt;is_xmm_register(), &quot;input in xmm register not supported (no SSE instruction present)&quot;);
1600       assert(src-&gt;fpu() == 0, &quot;input must be on TOS&quot;);
1601       assert(dest == FrameMap::long0_opr, &quot;runtime stub places result in these registers&quot;);
1602 
1603       // instruction sequence too long to inline it here
1604       {
1605         __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::fpu2long_stub_id)));
1606       }
1607       break;
1608 #endif // _LP64
1609 
1610     default: ShouldNotReachHere();
1611   }
1612 }
1613 
1614 void LIR_Assembler::emit_alloc_obj(LIR_OpAllocObj* op) {
1615   if (op-&gt;init_check()) {
1616     add_debug_info_for_null_check_here(op-&gt;stub()-&gt;info());
1617     __ cmpb(Address(op-&gt;klass()-&gt;as_register(),
1618                     InstanceKlass::init_state_offset()),
1619                     InstanceKlass::fully_initialized);
1620     __ jcc(Assembler::notEqual, *op-&gt;stub()-&gt;entry());
1621   }
1622   __ allocate_object(op-&gt;obj()-&gt;as_register(),
1623                      op-&gt;tmp1()-&gt;as_register(),
1624                      op-&gt;tmp2()-&gt;as_register(),
1625                      op-&gt;header_size(),
1626                      op-&gt;object_size(),
1627                      op-&gt;klass()-&gt;as_register(),
1628                      *op-&gt;stub()-&gt;entry());
1629   __ bind(*op-&gt;stub()-&gt;continuation());
1630 }
1631 
1632 void LIR_Assembler::emit_alloc_array(LIR_OpAllocArray* op) {
1633   Register len =  op-&gt;len()-&gt;as_register();
1634   LP64_ONLY( __ movslq(len, len); )
1635 
1636   if (UseSlowPath ||
1637       (!UseFastNewObjectArray &amp;&amp; is_reference_type(op-&gt;type())) ||
1638       (!UseFastNewTypeArray   &amp;&amp; !is_reference_type(op-&gt;type()))) {
1639     __ jmp(*op-&gt;stub()-&gt;entry());
1640   } else {
1641     Register tmp1 = op-&gt;tmp1()-&gt;as_register();
1642     Register tmp2 = op-&gt;tmp2()-&gt;as_register();
1643     Register tmp3 = op-&gt;tmp3()-&gt;as_register();
1644     if (len == tmp1) {
1645       tmp1 = tmp3;
1646     } else if (len == tmp2) {
1647       tmp2 = tmp3;
1648     } else if (len == tmp3) {
1649       // everything is ok
1650     } else {
1651       __ mov(tmp3, len);
1652     }
1653     __ allocate_array(op-&gt;obj()-&gt;as_register(),
1654                       len,
1655                       tmp1,
1656                       tmp2,
1657                       arrayOopDesc::header_size(op-&gt;type()),
1658                       array_element_size(op-&gt;type()),
1659                       op-&gt;klass()-&gt;as_register(),
1660                       *op-&gt;stub()-&gt;entry());
1661   }
1662   __ bind(*op-&gt;stub()-&gt;continuation());
1663 }
1664 
1665 void LIR_Assembler::type_profile_helper(Register mdo,
1666                                         ciMethodData *md, ciProfileData *data,
1667                                         Register recv, Label* update_done) {
1668   for (uint i = 0; i &lt; ReceiverTypeData::row_limit(); i++) {
1669     Label next_test;
1670     // See if the receiver is receiver[n].
1671     __ cmpptr(recv, Address(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_offset(i))));
1672     __ jccb(Assembler::notEqual, next_test);
1673     Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_count_offset(i)));
1674     __ addptr(data_addr, DataLayout::counter_increment);
1675     __ jmp(*update_done);
1676     __ bind(next_test);
1677   }
1678 
1679   // Didn&#39;t find receiver; find next empty slot and fill it in
1680   for (uint i = 0; i &lt; ReceiverTypeData::row_limit(); i++) {
1681     Label next_test;
1682     Address recv_addr(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_offset(i)));
1683     __ cmpptr(recv_addr, (intptr_t)NULL_WORD);
1684     __ jccb(Assembler::notEqual, next_test);
1685     __ movptr(recv_addr, recv);
1686     __ movptr(Address(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_count_offset(i))), DataLayout::counter_increment);
1687     __ jmp(*update_done);
1688     __ bind(next_test);
1689   }
1690 }
1691 
1692 void LIR_Assembler::emit_typecheck_helper(LIR_OpTypeCheck *op, Label* success, Label* failure, Label* obj_is_null) {
1693   // we always need a stub for the failure case.
1694   CodeStub* stub = op-&gt;stub();
1695   Register obj = op-&gt;object()-&gt;as_register();
1696   Register k_RInfo = op-&gt;tmp1()-&gt;as_register();
1697   Register klass_RInfo = op-&gt;tmp2()-&gt;as_register();
1698   Register dst = op-&gt;result_opr()-&gt;as_register();
1699   ciKlass* k = op-&gt;klass();
1700   Register Rtmp1 = noreg;
1701 
1702   // check if it needs to be profiled
1703   ciMethodData* md = NULL;
1704   ciProfileData* data = NULL;
1705 
1706   if (op-&gt;should_profile()) {
1707     ciMethod* method = op-&gt;profiled_method();
1708     assert(method != NULL, &quot;Should have method&quot;);
1709     int bci = op-&gt;profiled_bci();
1710     md = method-&gt;method_data_or_null();
1711     assert(md != NULL, &quot;Sanity&quot;);
1712     data = md-&gt;bci_to_data(bci);
1713     assert(data != NULL,                &quot;need data for type check&quot;);
1714     assert(data-&gt;is_ReceiverTypeData(), &quot;need ReceiverTypeData for type check&quot;);
1715   }
1716   Label profile_cast_success, profile_cast_failure;
1717   Label *success_target = op-&gt;should_profile() ? &amp;profile_cast_success : success;
1718   Label *failure_target = op-&gt;should_profile() ? &amp;profile_cast_failure : failure;
1719 
1720   if (obj == k_RInfo) {
1721     k_RInfo = dst;
1722   } else if (obj == klass_RInfo) {
1723     klass_RInfo = dst;
1724   }
1725   if (k-&gt;is_loaded() &amp;&amp; !UseCompressedClassPointers) {
1726     select_different_registers(obj, dst, k_RInfo, klass_RInfo);
1727   } else {
1728     Rtmp1 = op-&gt;tmp3()-&gt;as_register();
1729     select_different_registers(obj, dst, k_RInfo, klass_RInfo, Rtmp1);
1730   }
1731 
1732   assert_different_registers(obj, k_RInfo, klass_RInfo);
1733 
1734   __ cmpptr(obj, (int32_t)NULL_WORD);
1735   if (op-&gt;should_profile()) {
1736     Label not_null;
1737     __ jccb(Assembler::notEqual, not_null);
1738     // Object is null; update MDO and exit
1739     Register mdo  = klass_RInfo;
1740     __ mov_metadata(mdo, md-&gt;constant_encoding());
1741     Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, DataLayout::flags_offset()));
1742     int header_bits = BitData::null_seen_byte_constant();
1743     __ orb(data_addr, header_bits);
1744     __ jmp(*obj_is_null);
1745     __ bind(not_null);
1746   } else {
1747     __ jcc(Assembler::equal, *obj_is_null);
1748   }
1749 
1750   if (!k-&gt;is_loaded()) {
1751     klass2reg_with_patching(k_RInfo, op-&gt;info_for_patch());
1752   } else {
1753 #ifdef _LP64
1754     __ mov_metadata(k_RInfo, k-&gt;constant_encoding());
1755 #endif // _LP64
1756   }
1757   __ verify_oop(obj);
1758 
1759   if (op-&gt;fast_check()) {
1760     // get object class
1761     // not a safepoint as obj null check happens earlier
1762 #ifdef _LP64
1763     if (UseCompressedClassPointers) {
1764       __ load_klass(Rtmp1, obj);
1765       __ cmpptr(k_RInfo, Rtmp1);
1766     } else {
1767       __ cmpptr(k_RInfo, Address(obj, oopDesc::klass_offset_in_bytes()));
1768     }
1769 #else
1770     if (k-&gt;is_loaded()) {
1771       __ cmpklass(Address(obj, oopDesc::klass_offset_in_bytes()), k-&gt;constant_encoding());
1772     } else {
1773       __ cmpptr(k_RInfo, Address(obj, oopDesc::klass_offset_in_bytes()));
1774     }
1775 #endif
1776     __ jcc(Assembler::notEqual, *failure_target);
1777     // successful cast, fall through to profile or jump
1778   } else {
1779     // get object class
1780     // not a safepoint as obj null check happens earlier
1781     __ load_klass(klass_RInfo, obj);
1782     if (k-&gt;is_loaded()) {
1783       // See if we get an immediate positive hit
1784 #ifdef _LP64
1785       __ cmpptr(k_RInfo, Address(klass_RInfo, k-&gt;super_check_offset()));
1786 #else
1787       __ cmpklass(Address(klass_RInfo, k-&gt;super_check_offset()), k-&gt;constant_encoding());
1788 #endif // _LP64
1789       if ((juint)in_bytes(Klass::secondary_super_cache_offset()) != k-&gt;super_check_offset()) {
1790         __ jcc(Assembler::notEqual, *failure_target);
1791         // successful cast, fall through to profile or jump
1792       } else {
1793         // See if we get an immediate positive hit
1794         __ jcc(Assembler::equal, *success_target);
1795         // check for self
1796 #ifdef _LP64
1797         __ cmpptr(klass_RInfo, k_RInfo);
1798 #else
1799         __ cmpklass(klass_RInfo, k-&gt;constant_encoding());
1800 #endif // _LP64
1801         __ jcc(Assembler::equal, *success_target);
1802 
1803         __ push(klass_RInfo);
1804 #ifdef _LP64
1805         __ push(k_RInfo);
1806 #else
1807         __ pushklass(k-&gt;constant_encoding());
1808 #endif // _LP64
1809         __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
1810         __ pop(klass_RInfo);
1811         __ pop(klass_RInfo);
1812         // result is a boolean
1813         __ cmpl(klass_RInfo, 0);
1814         __ jcc(Assembler::equal, *failure_target);
1815         // successful cast, fall through to profile or jump
1816       }
1817     } else {
1818       // perform the fast part of the checking logic
1819       __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, NULL);
1820       // call out-of-line instance of __ check_klass_subtype_slow_path(...):
1821       __ push(klass_RInfo);
1822       __ push(k_RInfo);
1823       __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
1824       __ pop(klass_RInfo);
1825       __ pop(k_RInfo);
1826       // result is a boolean
1827       __ cmpl(k_RInfo, 0);
1828       __ jcc(Assembler::equal, *failure_target);
1829       // successful cast, fall through to profile or jump
1830     }
1831   }
1832   if (op-&gt;should_profile()) {
1833     Register mdo  = klass_RInfo, recv = k_RInfo;
1834     __ bind(profile_cast_success);
1835     __ mov_metadata(mdo, md-&gt;constant_encoding());
1836     __ load_klass(recv, obj);
1837     type_profile_helper(mdo, md, data, recv, success);
1838     __ jmp(*success);
1839 
1840     __ bind(profile_cast_failure);
1841     __ mov_metadata(mdo, md-&gt;constant_encoding());
1842     Address counter_addr(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()));
1843     __ subptr(counter_addr, DataLayout::counter_increment);
1844     __ jmp(*failure);
1845   }
1846   __ jmp(*success);
1847 }
1848 
1849 
1850 void LIR_Assembler::emit_opTypeCheck(LIR_OpTypeCheck* op) {
1851   LIR_Code code = op-&gt;code();
1852   if (code == lir_store_check) {
1853     Register value = op-&gt;object()-&gt;as_register();
1854     Register array = op-&gt;array()-&gt;as_register();
1855     Register k_RInfo = op-&gt;tmp1()-&gt;as_register();
1856     Register klass_RInfo = op-&gt;tmp2()-&gt;as_register();
1857     Register Rtmp1 = op-&gt;tmp3()-&gt;as_register();
1858 
1859     CodeStub* stub = op-&gt;stub();
1860 
1861     // check if it needs to be profiled
1862     ciMethodData* md = NULL;
1863     ciProfileData* data = NULL;
1864 
1865     if (op-&gt;should_profile()) {
1866       ciMethod* method = op-&gt;profiled_method();
1867       assert(method != NULL, &quot;Should have method&quot;);
1868       int bci = op-&gt;profiled_bci();
1869       md = method-&gt;method_data_or_null();
1870       assert(md != NULL, &quot;Sanity&quot;);
1871       data = md-&gt;bci_to_data(bci);
1872       assert(data != NULL,                &quot;need data for type check&quot;);
1873       assert(data-&gt;is_ReceiverTypeData(), &quot;need ReceiverTypeData for type check&quot;);
1874     }
1875     Label profile_cast_success, profile_cast_failure, done;
1876     Label *success_target = op-&gt;should_profile() ? &amp;profile_cast_success : &amp;done;
1877     Label *failure_target = op-&gt;should_profile() ? &amp;profile_cast_failure : stub-&gt;entry();
1878 
1879     __ cmpptr(value, (int32_t)NULL_WORD);
1880     if (op-&gt;should_profile()) {
1881       Label not_null;
1882       __ jccb(Assembler::notEqual, not_null);
1883       // Object is null; update MDO and exit
1884       Register mdo  = klass_RInfo;
1885       __ mov_metadata(mdo, md-&gt;constant_encoding());
1886       Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, DataLayout::flags_offset()));
1887       int header_bits = BitData::null_seen_byte_constant();
1888       __ orb(data_addr, header_bits);
1889       __ jmp(done);
1890       __ bind(not_null);
1891     } else {
1892       __ jcc(Assembler::equal, done);
1893     }
1894 
1895     add_debug_info_for_null_check_here(op-&gt;info_for_exception());
1896     __ load_klass(k_RInfo, array);
1897     __ load_klass(klass_RInfo, value);
1898 
1899     // get instance klass (it&#39;s already uncompressed)
1900     __ movptr(k_RInfo, Address(k_RInfo, ObjArrayKlass::element_klass_offset()));
1901     // perform the fast part of the checking logic
1902     __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, NULL);
1903     // call out-of-line instance of __ check_klass_subtype_slow_path(...):
1904     __ push(klass_RInfo);
1905     __ push(k_RInfo);
1906     __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
1907     __ pop(klass_RInfo);
1908     __ pop(k_RInfo);
1909     // result is a boolean
1910     __ cmpl(k_RInfo, 0);
1911     __ jcc(Assembler::equal, *failure_target);
1912     // fall through to the success case
1913 
1914     if (op-&gt;should_profile()) {
1915       Register mdo  = klass_RInfo, recv = k_RInfo;
1916       __ bind(profile_cast_success);
1917       __ mov_metadata(mdo, md-&gt;constant_encoding());
1918       __ load_klass(recv, value);
1919       type_profile_helper(mdo, md, data, recv, &amp;done);
1920       __ jmpb(done);
1921 
1922       __ bind(profile_cast_failure);
1923       __ mov_metadata(mdo, md-&gt;constant_encoding());
1924       Address counter_addr(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()));
1925       __ subptr(counter_addr, DataLayout::counter_increment);
1926       __ jmp(*stub-&gt;entry());
1927     }
1928 
1929     __ bind(done);
1930   } else
1931     if (code == lir_checkcast) {
1932       Register obj = op-&gt;object()-&gt;as_register();
1933       Register dst = op-&gt;result_opr()-&gt;as_register();
1934       Label success;
1935       emit_typecheck_helper(op, &amp;success, op-&gt;stub()-&gt;entry(), &amp;success);
1936       __ bind(success);
1937       if (dst != obj) {
1938         __ mov(dst, obj);
1939       }
1940     } else
1941       if (code == lir_instanceof) {
1942         Register obj = op-&gt;object()-&gt;as_register();
1943         Register dst = op-&gt;result_opr()-&gt;as_register();
1944         Label success, failure, done;
1945         emit_typecheck_helper(op, &amp;success, &amp;failure, &amp;failure);
1946         __ bind(failure);
1947         __ xorptr(dst, dst);
1948         __ jmpb(done);
1949         __ bind(success);
1950         __ movptr(dst, 1);
1951         __ bind(done);
1952       } else {
1953         ShouldNotReachHere();
1954       }
1955 
1956 }
1957 
1958 
1959 void LIR_Assembler::emit_compare_and_swap(LIR_OpCompareAndSwap* op) {
1960   if (LP64_ONLY(false &amp;&amp;) op-&gt;code() == lir_cas_long &amp;&amp; VM_Version::supports_cx8()) {
1961     assert(op-&gt;cmp_value()-&gt;as_register_lo() == rax, &quot;wrong register&quot;);
1962     assert(op-&gt;cmp_value()-&gt;as_register_hi() == rdx, &quot;wrong register&quot;);
1963     assert(op-&gt;new_value()-&gt;as_register_lo() == rbx, &quot;wrong register&quot;);
1964     assert(op-&gt;new_value()-&gt;as_register_hi() == rcx, &quot;wrong register&quot;);
1965     Register addr = op-&gt;addr()-&gt;as_register();
1966     __ lock();
1967     NOT_LP64(__ cmpxchg8(Address(addr, 0)));
1968 
1969   } else if (op-&gt;code() == lir_cas_int || op-&gt;code() == lir_cas_obj ) {
1970     NOT_LP64(assert(op-&gt;addr()-&gt;is_single_cpu(), &quot;must be single&quot;);)
1971     Register addr = (op-&gt;addr()-&gt;is_single_cpu() ? op-&gt;addr()-&gt;as_register() : op-&gt;addr()-&gt;as_register_lo());
1972     Register newval = op-&gt;new_value()-&gt;as_register();
1973     Register cmpval = op-&gt;cmp_value()-&gt;as_register();
1974     assert(cmpval == rax, &quot;wrong register&quot;);
1975     assert(newval != NULL, &quot;new val must be register&quot;);
1976     assert(cmpval != newval, &quot;cmp and new values must be in different registers&quot;);
1977     assert(cmpval != addr, &quot;cmp and addr must be in different registers&quot;);
1978     assert(newval != addr, &quot;new value and addr must be in different registers&quot;);
1979 
1980     if ( op-&gt;code() == lir_cas_obj) {
1981 #ifdef _LP64
1982       if (UseCompressedOops) {
1983         __ encode_heap_oop(cmpval);
1984         __ mov(rscratch1, newval);
1985         __ encode_heap_oop(rscratch1);
1986         __ lock();
1987         // cmpval (rax) is implicitly used by this instruction
1988         __ cmpxchgl(rscratch1, Address(addr, 0));
1989       } else
1990 #endif
1991       {
1992         __ lock();
1993         __ cmpxchgptr(newval, Address(addr, 0));
1994       }
1995     } else {
1996       assert(op-&gt;code() == lir_cas_int, &quot;lir_cas_int expected&quot;);
1997       __ lock();
1998       __ cmpxchgl(newval, Address(addr, 0));
1999     }
2000 #ifdef _LP64
2001   } else if (op-&gt;code() == lir_cas_long) {
2002     Register addr = (op-&gt;addr()-&gt;is_single_cpu() ? op-&gt;addr()-&gt;as_register() : op-&gt;addr()-&gt;as_register_lo());
2003     Register newval = op-&gt;new_value()-&gt;as_register_lo();
2004     Register cmpval = op-&gt;cmp_value()-&gt;as_register_lo();
2005     assert(cmpval == rax, &quot;wrong register&quot;);
2006     assert(newval != NULL, &quot;new val must be register&quot;);
2007     assert(cmpval != newval, &quot;cmp and new values must be in different registers&quot;);
2008     assert(cmpval != addr, &quot;cmp and addr must be in different registers&quot;);
2009     assert(newval != addr, &quot;new value and addr must be in different registers&quot;);
2010     __ lock();
2011     __ cmpxchgq(newval, Address(addr, 0));
2012 #endif // _LP64
2013   } else {
2014     Unimplemented();
2015   }
2016 }
2017 
2018 void LIR_Assembler::cmove(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, LIR_Opr result, BasicType type) {
2019   Assembler::Condition acond, ncond;
2020   switch (condition) {
2021     case lir_cond_equal:        acond = Assembler::equal;        ncond = Assembler::notEqual;     break;
2022     case lir_cond_notEqual:     acond = Assembler::notEqual;     ncond = Assembler::equal;        break;
2023     case lir_cond_less:         acond = Assembler::less;         ncond = Assembler::greaterEqual; break;
2024     case lir_cond_lessEqual:    acond = Assembler::lessEqual;    ncond = Assembler::greater;      break;
2025     case lir_cond_greaterEqual: acond = Assembler::greaterEqual; ncond = Assembler::less;         break;
2026     case lir_cond_greater:      acond = Assembler::greater;      ncond = Assembler::lessEqual;    break;
2027     case lir_cond_belowEqual:   acond = Assembler::belowEqual;   ncond = Assembler::above;        break;
2028     case lir_cond_aboveEqual:   acond = Assembler::aboveEqual;   ncond = Assembler::below;        break;
2029     default:                    acond = Assembler::equal;        ncond = Assembler::notEqual;
2030                                 ShouldNotReachHere();
2031   }
2032 
2033   if (opr1-&gt;is_cpu_register()) {
2034     reg2reg(opr1, result);
2035   } else if (opr1-&gt;is_stack()) {
2036     stack2reg(opr1, result, result-&gt;type());
2037   } else if (opr1-&gt;is_constant()) {
2038     const2reg(opr1, result, lir_patch_none, NULL);
2039   } else {
2040     ShouldNotReachHere();
2041   }
2042 
2043   if (VM_Version::supports_cmov() &amp;&amp; !opr2-&gt;is_constant()) {
2044     // optimized version that does not require a branch
2045     if (opr2-&gt;is_single_cpu()) {
2046       assert(opr2-&gt;cpu_regnr() != result-&gt;cpu_regnr(), &quot;opr2 already overwritten by previous move&quot;);
2047       __ cmov(ncond, result-&gt;as_register(), opr2-&gt;as_register());
2048     } else if (opr2-&gt;is_double_cpu()) {
2049       assert(opr2-&gt;cpu_regnrLo() != result-&gt;cpu_regnrLo() &amp;&amp; opr2-&gt;cpu_regnrLo() != result-&gt;cpu_regnrHi(), &quot;opr2 already overwritten by previous move&quot;);
2050       assert(opr2-&gt;cpu_regnrHi() != result-&gt;cpu_regnrLo() &amp;&amp; opr2-&gt;cpu_regnrHi() != result-&gt;cpu_regnrHi(), &quot;opr2 already overwritten by previous move&quot;);
2051       __ cmovptr(ncond, result-&gt;as_register_lo(), opr2-&gt;as_register_lo());
2052       NOT_LP64(__ cmovptr(ncond, result-&gt;as_register_hi(), opr2-&gt;as_register_hi());)
2053     } else if (opr2-&gt;is_single_stack()) {
2054       __ cmovl(ncond, result-&gt;as_register(), frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()));
2055     } else if (opr2-&gt;is_double_stack()) {
2056       __ cmovptr(ncond, result-&gt;as_register_lo(), frame_map()-&gt;address_for_slot(opr2-&gt;double_stack_ix(), lo_word_offset_in_bytes));
2057       NOT_LP64(__ cmovptr(ncond, result-&gt;as_register_hi(), frame_map()-&gt;address_for_slot(opr2-&gt;double_stack_ix(), hi_word_offset_in_bytes));)
2058     } else {
2059       ShouldNotReachHere();
2060     }
2061 
2062   } else {
2063     Label skip;
2064     __ jcc (acond, skip);
2065     if (opr2-&gt;is_cpu_register()) {
2066       reg2reg(opr2, result);
2067     } else if (opr2-&gt;is_stack()) {
2068       stack2reg(opr2, result, result-&gt;type());
2069     } else if (opr2-&gt;is_constant()) {
2070       const2reg(opr2, result, lir_patch_none, NULL);
2071     } else {
2072       ShouldNotReachHere();
2073     }
2074     __ bind(skip);
2075   }
2076 }
2077 
2078 
2079 void LIR_Assembler::arith_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dest, CodeEmitInfo* info, bool pop_fpu_stack) {
2080   assert(info == NULL, &quot;should never be used, idiv/irem and ldiv/lrem not handled by this method&quot;);
2081 
2082   if (left-&gt;is_single_cpu()) {
2083     assert(left == dest, &quot;left and dest must be equal&quot;);
2084     Register lreg = left-&gt;as_register();
2085 
2086     if (right-&gt;is_single_cpu()) {
2087       // cpu register - cpu register
2088       Register rreg = right-&gt;as_register();
2089       switch (code) {
2090         case lir_add: __ addl (lreg, rreg); break;
2091         case lir_sub: __ subl (lreg, rreg); break;
2092         case lir_mul: __ imull(lreg, rreg); break;
2093         default:      ShouldNotReachHere();
2094       }
2095 
2096     } else if (right-&gt;is_stack()) {
2097       // cpu register - stack
2098       Address raddr = frame_map()-&gt;address_for_slot(right-&gt;single_stack_ix());
2099       switch (code) {
2100         case lir_add: __ addl(lreg, raddr); break;
2101         case lir_sub: __ subl(lreg, raddr); break;
2102         default:      ShouldNotReachHere();
2103       }
2104 
2105     } else if (right-&gt;is_constant()) {
2106       // cpu register - constant
2107       jint c = right-&gt;as_constant_ptr()-&gt;as_jint();
2108       switch (code) {
2109         case lir_add: {
2110           __ incrementl(lreg, c);
2111           break;
2112         }
2113         case lir_sub: {
2114           __ decrementl(lreg, c);
2115           break;
2116         }
2117         default: ShouldNotReachHere();
2118       }
2119 
2120     } else {
2121       ShouldNotReachHere();
2122     }
2123 
2124   } else if (left-&gt;is_double_cpu()) {
2125     assert(left == dest, &quot;left and dest must be equal&quot;);
2126     Register lreg_lo = left-&gt;as_register_lo();
2127     Register lreg_hi = left-&gt;as_register_hi();
2128 
2129     if (right-&gt;is_double_cpu()) {
2130       // cpu register - cpu register
2131       Register rreg_lo = right-&gt;as_register_lo();
2132       Register rreg_hi = right-&gt;as_register_hi();
2133       NOT_LP64(assert_different_registers(lreg_lo, lreg_hi, rreg_lo, rreg_hi));
2134       LP64_ONLY(assert_different_registers(lreg_lo, rreg_lo));
2135       switch (code) {
2136         case lir_add:
2137           __ addptr(lreg_lo, rreg_lo);
2138           NOT_LP64(__ adcl(lreg_hi, rreg_hi));
2139           break;
2140         case lir_sub:
2141           __ subptr(lreg_lo, rreg_lo);
2142           NOT_LP64(__ sbbl(lreg_hi, rreg_hi));
2143           break;
2144         case lir_mul:
2145 #ifdef _LP64
2146           __ imulq(lreg_lo, rreg_lo);
2147 #else
2148           assert(lreg_lo == rax &amp;&amp; lreg_hi == rdx, &quot;must be&quot;);
2149           __ imull(lreg_hi, rreg_lo);
2150           __ imull(rreg_hi, lreg_lo);
2151           __ addl (rreg_hi, lreg_hi);
2152           __ mull (rreg_lo);
2153           __ addl (lreg_hi, rreg_hi);
2154 #endif // _LP64
2155           break;
2156         default:
2157           ShouldNotReachHere();
2158       }
2159 
2160     } else if (right-&gt;is_constant()) {
2161       // cpu register - constant
2162 #ifdef _LP64
2163       jlong c = right-&gt;as_constant_ptr()-&gt;as_jlong_bits();
2164       __ movptr(r10, (intptr_t) c);
2165       switch (code) {
2166         case lir_add:
2167           __ addptr(lreg_lo, r10);
2168           break;
2169         case lir_sub:
2170           __ subptr(lreg_lo, r10);
2171           break;
2172         default:
2173           ShouldNotReachHere();
2174       }
2175 #else
2176       jint c_lo = right-&gt;as_constant_ptr()-&gt;as_jint_lo();
2177       jint c_hi = right-&gt;as_constant_ptr()-&gt;as_jint_hi();
2178       switch (code) {
2179         case lir_add:
2180           __ addptr(lreg_lo, c_lo);
2181           __ adcl(lreg_hi, c_hi);
2182           break;
2183         case lir_sub:
2184           __ subptr(lreg_lo, c_lo);
2185           __ sbbl(lreg_hi, c_hi);
2186           break;
2187         default:
2188           ShouldNotReachHere();
2189       }
2190 #endif // _LP64
2191 
2192     } else {
2193       ShouldNotReachHere();
2194     }
2195 
2196   } else if (left-&gt;is_single_xmm()) {
2197     assert(left == dest, &quot;left and dest must be equal&quot;);
2198     XMMRegister lreg = left-&gt;as_xmm_float_reg();
2199 
2200     if (right-&gt;is_single_xmm()) {
2201       XMMRegister rreg = right-&gt;as_xmm_float_reg();
2202       switch (code) {
2203         case lir_add: __ addss(lreg, rreg);  break;
2204         case lir_sub: __ subss(lreg, rreg);  break;
2205         case lir_mul_strictfp: // fall through
2206         case lir_mul: __ mulss(lreg, rreg);  break;
2207         case lir_div_strictfp: // fall through
2208         case lir_div: __ divss(lreg, rreg);  break;
2209         default: ShouldNotReachHere();
2210       }
2211     } else {
2212       Address raddr;
2213       if (right-&gt;is_single_stack()) {
2214         raddr = frame_map()-&gt;address_for_slot(right-&gt;single_stack_ix());
2215       } else if (right-&gt;is_constant()) {
2216         // hack for now
2217         raddr = __ as_Address(InternalAddress(float_constant(right-&gt;as_jfloat())));
2218       } else {
2219         ShouldNotReachHere();
2220       }
2221       switch (code) {
2222         case lir_add: __ addss(lreg, raddr);  break;
2223         case lir_sub: __ subss(lreg, raddr);  break;
2224         case lir_mul_strictfp: // fall through
2225         case lir_mul: __ mulss(lreg, raddr);  break;
2226         case lir_div_strictfp: // fall through
2227         case lir_div: __ divss(lreg, raddr);  break;
2228         default: ShouldNotReachHere();
2229       }
2230     }
2231 
2232   } else if (left-&gt;is_double_xmm()) {
2233     assert(left == dest, &quot;left and dest must be equal&quot;);
2234 
2235     XMMRegister lreg = left-&gt;as_xmm_double_reg();
2236     if (right-&gt;is_double_xmm()) {
2237       XMMRegister rreg = right-&gt;as_xmm_double_reg();
2238       switch (code) {
2239         case lir_add: __ addsd(lreg, rreg);  break;
2240         case lir_sub: __ subsd(lreg, rreg);  break;
2241         case lir_mul_strictfp: // fall through
2242         case lir_mul: __ mulsd(lreg, rreg);  break;
2243         case lir_div_strictfp: // fall through
2244         case lir_div: __ divsd(lreg, rreg);  break;
2245         default: ShouldNotReachHere();
2246       }
2247     } else {
2248       Address raddr;
2249       if (right-&gt;is_double_stack()) {
2250         raddr = frame_map()-&gt;address_for_slot(right-&gt;double_stack_ix());
2251       } else if (right-&gt;is_constant()) {
2252         // hack for now
2253         raddr = __ as_Address(InternalAddress(double_constant(right-&gt;as_jdouble())));
2254       } else {
2255         ShouldNotReachHere();
2256       }
2257       switch (code) {
2258         case lir_add: __ addsd(lreg, raddr);  break;
2259         case lir_sub: __ subsd(lreg, raddr);  break;
2260         case lir_mul_strictfp: // fall through
2261         case lir_mul: __ mulsd(lreg, raddr);  break;
2262         case lir_div_strictfp: // fall through
2263         case lir_div: __ divsd(lreg, raddr);  break;
2264         default: ShouldNotReachHere();
2265       }
2266     }
2267 
2268 #ifndef _LP64
2269   } else if (left-&gt;is_single_fpu()) {
2270     assert(dest-&gt;is_single_fpu(),  &quot;fpu stack allocation required&quot;);
2271 
2272     if (right-&gt;is_single_fpu()) {
2273       arith_fpu_implementation(code, left-&gt;fpu_regnr(), right-&gt;fpu_regnr(), dest-&gt;fpu_regnr(), pop_fpu_stack);
2274 
2275     } else {
2276       assert(left-&gt;fpu_regnr() == 0, &quot;left must be on TOS&quot;);
2277       assert(dest-&gt;fpu_regnr() == 0, &quot;dest must be on TOS&quot;);
2278 
2279       Address raddr;
2280       if (right-&gt;is_single_stack()) {
2281         raddr = frame_map()-&gt;address_for_slot(right-&gt;single_stack_ix());
2282       } else if (right-&gt;is_constant()) {
2283         address const_addr = float_constant(right-&gt;as_jfloat());
2284         assert(const_addr != NULL, &quot;incorrect float/double constant maintainance&quot;);
2285         // hack for now
2286         raddr = __ as_Address(InternalAddress(const_addr));
2287       } else {
2288         ShouldNotReachHere();
2289       }
2290 
2291       switch (code) {
2292         case lir_add: __ fadd_s(raddr); break;
2293         case lir_sub: __ fsub_s(raddr); break;
2294         case lir_mul_strictfp: // fall through
2295         case lir_mul: __ fmul_s(raddr); break;
2296         case lir_div_strictfp: // fall through
2297         case lir_div: __ fdiv_s(raddr); break;
2298         default:      ShouldNotReachHere();
2299       }
2300     }
2301 
2302   } else if (left-&gt;is_double_fpu()) {
2303     assert(dest-&gt;is_double_fpu(),  &quot;fpu stack allocation required&quot;);
2304 
2305     if (code == lir_mul_strictfp || code == lir_div_strictfp) {
2306       // Double values require special handling for strictfp mul/div on x86
2307       __ fld_x(ExternalAddress(StubRoutines::addr_fpu_subnormal_bias1()));
2308       __ fmulp(left-&gt;fpu_regnrLo() + 1);
2309     }
2310 
2311     if (right-&gt;is_double_fpu()) {
2312       arith_fpu_implementation(code, left-&gt;fpu_regnrLo(), right-&gt;fpu_regnrLo(), dest-&gt;fpu_regnrLo(), pop_fpu_stack);
2313 
2314     } else {
2315       assert(left-&gt;fpu_regnrLo() == 0, &quot;left must be on TOS&quot;);
2316       assert(dest-&gt;fpu_regnrLo() == 0, &quot;dest must be on TOS&quot;);
2317 
2318       Address raddr;
2319       if (right-&gt;is_double_stack()) {
2320         raddr = frame_map()-&gt;address_for_slot(right-&gt;double_stack_ix());
2321       } else if (right-&gt;is_constant()) {
2322         // hack for now
2323         raddr = __ as_Address(InternalAddress(double_constant(right-&gt;as_jdouble())));
2324       } else {
2325         ShouldNotReachHere();
2326       }
2327 
2328       switch (code) {
2329         case lir_add: __ fadd_d(raddr); break;
2330         case lir_sub: __ fsub_d(raddr); break;
2331         case lir_mul_strictfp: // fall through
2332         case lir_mul: __ fmul_d(raddr); break;
2333         case lir_div_strictfp: // fall through
2334         case lir_div: __ fdiv_d(raddr); break;
2335         default: ShouldNotReachHere();
2336       }
2337     }
2338 
2339     if (code == lir_mul_strictfp || code == lir_div_strictfp) {
2340       // Double values require special handling for strictfp mul/div on x86
2341       __ fld_x(ExternalAddress(StubRoutines::addr_fpu_subnormal_bias2()));
2342       __ fmulp(dest-&gt;fpu_regnrLo() + 1);
2343     }
2344 #endif // !_LP64
2345 
2346   } else if (left-&gt;is_single_stack() || left-&gt;is_address()) {
2347     assert(left == dest, &quot;left and dest must be equal&quot;);
2348 
2349     Address laddr;
2350     if (left-&gt;is_single_stack()) {
2351       laddr = frame_map()-&gt;address_for_slot(left-&gt;single_stack_ix());
2352     } else if (left-&gt;is_address()) {
2353       laddr = as_Address(left-&gt;as_address_ptr());
2354     } else {
2355       ShouldNotReachHere();
2356     }
2357 
2358     if (right-&gt;is_single_cpu()) {
2359       Register rreg = right-&gt;as_register();
2360       switch (code) {
2361         case lir_add: __ addl(laddr, rreg); break;
2362         case lir_sub: __ subl(laddr, rreg); break;
2363         default:      ShouldNotReachHere();
2364       }
2365     } else if (right-&gt;is_constant()) {
2366       jint c = right-&gt;as_constant_ptr()-&gt;as_jint();
2367       switch (code) {
2368         case lir_add: {
2369           __ incrementl(laddr, c);
2370           break;
2371         }
2372         case lir_sub: {
2373           __ decrementl(laddr, c);
2374           break;
2375         }
2376         default: ShouldNotReachHere();
2377       }
2378     } else {
2379       ShouldNotReachHere();
2380     }
2381 
2382   } else {
2383     ShouldNotReachHere();
2384   }
2385 }
2386 
2387 #ifndef _LP64
2388 void LIR_Assembler::arith_fpu_implementation(LIR_Code code, int left_index, int right_index, int dest_index, bool pop_fpu_stack) {
2389   assert(pop_fpu_stack  || (left_index     == dest_index || right_index     == dest_index), &quot;invalid LIR&quot;);
2390   assert(!pop_fpu_stack || (left_index - 1 == dest_index || right_index - 1 == dest_index), &quot;invalid LIR&quot;);
2391   assert(left_index == 0 || right_index == 0, &quot;either must be on top of stack&quot;);
2392 
2393   bool left_is_tos = (left_index == 0);
2394   bool dest_is_tos = (dest_index == 0);
2395   int non_tos_index = (left_is_tos ? right_index : left_index);
2396 
2397   switch (code) {
2398     case lir_add:
2399       if (pop_fpu_stack)       __ faddp(non_tos_index);
2400       else if (dest_is_tos)    __ fadd (non_tos_index);
2401       else                     __ fadda(non_tos_index);
2402       break;
2403 
2404     case lir_sub:
2405       if (left_is_tos) {
2406         if (pop_fpu_stack)     __ fsubrp(non_tos_index);
2407         else if (dest_is_tos)  __ fsub  (non_tos_index);
2408         else                   __ fsubra(non_tos_index);
2409       } else {
2410         if (pop_fpu_stack)     __ fsubp (non_tos_index);
2411         else if (dest_is_tos)  __ fsubr (non_tos_index);
2412         else                   __ fsuba (non_tos_index);
2413       }
2414       break;
2415 
2416     case lir_mul_strictfp: // fall through
2417     case lir_mul:
2418       if (pop_fpu_stack)       __ fmulp(non_tos_index);
2419       else if (dest_is_tos)    __ fmul (non_tos_index);
2420       else                     __ fmula(non_tos_index);
2421       break;
2422 
2423     case lir_div_strictfp: // fall through
2424     case lir_div:
2425       if (left_is_tos) {
2426         if (pop_fpu_stack)     __ fdivrp(non_tos_index);
2427         else if (dest_is_tos)  __ fdiv  (non_tos_index);
2428         else                   __ fdivra(non_tos_index);
2429       } else {
2430         if (pop_fpu_stack)     __ fdivp (non_tos_index);
2431         else if (dest_is_tos)  __ fdivr (non_tos_index);
2432         else                   __ fdiva (non_tos_index);
2433       }
2434       break;
2435 
2436     case lir_rem:
2437       assert(left_is_tos &amp;&amp; dest_is_tos &amp;&amp; right_index == 1, &quot;must be guaranteed by FPU stack allocation&quot;);
2438       __ fremr(noreg);
2439       break;
2440 
2441     default:
2442       ShouldNotReachHere();
2443   }
2444 }
2445 #endif // _LP64
2446 
2447 
2448 void LIR_Assembler::intrinsic_op(LIR_Code code, LIR_Opr value, LIR_Opr tmp, LIR_Opr dest, LIR_Op* op) {
2449   if (value-&gt;is_double_xmm()) {
2450     switch(code) {
2451       case lir_abs :
2452         {
2453 #ifdef _LP64
2454           if (UseAVX &gt; 2 &amp;&amp; !VM_Version::supports_avx512vl()) {
2455             assert(tmp-&gt;is_valid(), &quot;need temporary&quot;);
2456             __ vpandn(dest-&gt;as_xmm_double_reg(), tmp-&gt;as_xmm_double_reg(), value-&gt;as_xmm_double_reg(), 2);
2457           } else
2458 #endif
2459           {
2460             if (dest-&gt;as_xmm_double_reg() != value-&gt;as_xmm_double_reg()) {
2461               __ movdbl(dest-&gt;as_xmm_double_reg(), value-&gt;as_xmm_double_reg());
2462             }
2463             assert(!tmp-&gt;is_valid(), &quot;do not need temporary&quot;);
2464             __ andpd(dest-&gt;as_xmm_double_reg(),
2465                      ExternalAddress((address)double_signmask_pool));
2466           }
2467         }
2468         break;
2469 
2470       case lir_sqrt: __ sqrtsd(dest-&gt;as_xmm_double_reg(), value-&gt;as_xmm_double_reg()); break;
2471       // all other intrinsics are not available in the SSE instruction set, so FPU is used
2472       default      : ShouldNotReachHere();
2473     }
2474 
2475 #ifndef _LP64
2476   } else if (value-&gt;is_double_fpu()) {
2477     assert(value-&gt;fpu_regnrLo() == 0 &amp;&amp; dest-&gt;fpu_regnrLo() == 0, &quot;both must be on TOS&quot;);
2478     switch(code) {
2479       case lir_abs   : __ fabs() ; break;
2480       case lir_sqrt  : __ fsqrt(); break;
2481       default      : ShouldNotReachHere();
2482     }
2483 #endif // !_LP64
2484   } else {
2485     Unimplemented();
2486   }
2487 }
2488 
2489 void LIR_Assembler::logic_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dst) {
2490   // assert(left-&gt;destroys_register(), &quot;check&quot;);
2491   if (left-&gt;is_single_cpu()) {
2492     Register reg = left-&gt;as_register();
2493     if (right-&gt;is_constant()) {
2494       int val = right-&gt;as_constant_ptr()-&gt;as_jint();
2495       switch (code) {
2496         case lir_logic_and: __ andl (reg, val); break;
2497         case lir_logic_or:  __ orl  (reg, val); break;
2498         case lir_logic_xor: __ xorl (reg, val); break;
2499         default: ShouldNotReachHere();
2500       }
2501     } else if (right-&gt;is_stack()) {
2502       // added support for stack operands
2503       Address raddr = frame_map()-&gt;address_for_slot(right-&gt;single_stack_ix());
2504       switch (code) {
2505         case lir_logic_and: __ andl (reg, raddr); break;
2506         case lir_logic_or:  __ orl  (reg, raddr); break;
2507         case lir_logic_xor: __ xorl (reg, raddr); break;
2508         default: ShouldNotReachHere();
2509       }
2510     } else {
2511       Register rright = right-&gt;as_register();
2512       switch (code) {
2513         case lir_logic_and: __ andptr (reg, rright); break;
2514         case lir_logic_or : __ orptr  (reg, rright); break;
2515         case lir_logic_xor: __ xorptr (reg, rright); break;
2516         default: ShouldNotReachHere();
2517       }
2518     }
2519     move_regs(reg, dst-&gt;as_register());
2520   } else {
2521     Register l_lo = left-&gt;as_register_lo();
2522     Register l_hi = left-&gt;as_register_hi();
2523     if (right-&gt;is_constant()) {
2524 #ifdef _LP64
2525       __ mov64(rscratch1, right-&gt;as_constant_ptr()-&gt;as_jlong());
2526       switch (code) {
2527         case lir_logic_and:
2528           __ andq(l_lo, rscratch1);
2529           break;
2530         case lir_logic_or:
2531           __ orq(l_lo, rscratch1);
2532           break;
2533         case lir_logic_xor:
2534           __ xorq(l_lo, rscratch1);
2535           break;
2536         default: ShouldNotReachHere();
2537       }
2538 #else
2539       int r_lo = right-&gt;as_constant_ptr()-&gt;as_jint_lo();
2540       int r_hi = right-&gt;as_constant_ptr()-&gt;as_jint_hi();
2541       switch (code) {
2542         case lir_logic_and:
2543           __ andl(l_lo, r_lo);
2544           __ andl(l_hi, r_hi);
2545           break;
2546         case lir_logic_or:
2547           __ orl(l_lo, r_lo);
2548           __ orl(l_hi, r_hi);
2549           break;
2550         case lir_logic_xor:
2551           __ xorl(l_lo, r_lo);
2552           __ xorl(l_hi, r_hi);
2553           break;
2554         default: ShouldNotReachHere();
2555       }
2556 #endif // _LP64
2557     } else {
2558 #ifdef _LP64
2559       Register r_lo;
2560       if (is_reference_type(right-&gt;type())) {
2561         r_lo = right-&gt;as_register();
2562       } else {
2563         r_lo = right-&gt;as_register_lo();
2564       }
2565 #else
2566       Register r_lo = right-&gt;as_register_lo();
2567       Register r_hi = right-&gt;as_register_hi();
2568       assert(l_lo != r_hi, &quot;overwriting registers&quot;);
2569 #endif
2570       switch (code) {
2571         case lir_logic_and:
2572           __ andptr(l_lo, r_lo);
2573           NOT_LP64(__ andptr(l_hi, r_hi);)
2574           break;
2575         case lir_logic_or:
2576           __ orptr(l_lo, r_lo);
2577           NOT_LP64(__ orptr(l_hi, r_hi);)
2578           break;
2579         case lir_logic_xor:
2580           __ xorptr(l_lo, r_lo);
2581           NOT_LP64(__ xorptr(l_hi, r_hi);)
2582           break;
2583         default: ShouldNotReachHere();
2584       }
2585     }
2586 
2587     Register dst_lo = dst-&gt;as_register_lo();
2588     Register dst_hi = dst-&gt;as_register_hi();
2589 
2590 #ifdef _LP64
2591     move_regs(l_lo, dst_lo);
2592 #else
2593     if (dst_lo == l_hi) {
2594       assert(dst_hi != l_lo, &quot;overwriting registers&quot;);
2595       move_regs(l_hi, dst_hi);
2596       move_regs(l_lo, dst_lo);
2597     } else {
2598       assert(dst_lo != l_hi, &quot;overwriting registers&quot;);
2599       move_regs(l_lo, dst_lo);
2600       move_regs(l_hi, dst_hi);
2601     }
2602 #endif // _LP64
2603   }
2604 }
2605 
2606 
2607 // we assume that rax, and rdx can be overwritten
2608 void LIR_Assembler::arithmetic_idiv(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr temp, LIR_Opr result, CodeEmitInfo* info) {
2609 
2610   assert(left-&gt;is_single_cpu(),   &quot;left must be register&quot;);
2611   assert(right-&gt;is_single_cpu() || right-&gt;is_constant(),  &quot;right must be register or constant&quot;);
2612   assert(result-&gt;is_single_cpu(), &quot;result must be register&quot;);
2613 
2614   //  assert(left-&gt;destroys_register(), &quot;check&quot;);
2615   //  assert(right-&gt;destroys_register(), &quot;check&quot;);
2616 
2617   Register lreg = left-&gt;as_register();
2618   Register dreg = result-&gt;as_register();
2619 
2620   if (right-&gt;is_constant()) {
2621     jint divisor = right-&gt;as_constant_ptr()-&gt;as_jint();
2622     assert(divisor &gt; 0 &amp;&amp; is_power_of_2(divisor), &quot;must be&quot;);
2623     if (code == lir_idiv) {
2624       assert(lreg == rax, &quot;must be rax,&quot;);
2625       assert(temp-&gt;as_register() == rdx, &quot;tmp register must be rdx&quot;);
2626       __ cdql(); // sign extend into rdx:rax
2627       if (divisor == 2) {
2628         __ subl(lreg, rdx);
2629       } else {
2630         __ andl(rdx, divisor - 1);
2631         __ addl(lreg, rdx);
2632       }
2633       __ sarl(lreg, log2_jint(divisor));
2634       move_regs(lreg, dreg);
2635     } else if (code == lir_irem) {
2636       Label done;
2637       __ mov(dreg, lreg);
2638       __ andl(dreg, 0x80000000 | (divisor - 1));
2639       __ jcc(Assembler::positive, done);
2640       __ decrement(dreg);
2641       __ orl(dreg, ~(divisor - 1));
2642       __ increment(dreg);
2643       __ bind(done);
2644     } else {
2645       ShouldNotReachHere();
2646     }
2647   } else {
2648     Register rreg = right-&gt;as_register();
2649     assert(lreg == rax, &quot;left register must be rax,&quot;);
2650     assert(rreg != rdx, &quot;right register must not be rdx&quot;);
2651     assert(temp-&gt;as_register() == rdx, &quot;tmp register must be rdx&quot;);
2652 
2653     move_regs(lreg, rax);
2654 
2655     int idivl_offset = __ corrected_idivl(rreg);
2656     if (ImplicitDiv0Checks) {
2657       add_debug_info_for_div0(idivl_offset, info);
2658     }
2659     if (code == lir_irem) {
2660       move_regs(rdx, dreg); // result is in rdx
2661     } else {
2662       move_regs(rax, dreg);
2663     }
2664   }
2665 }
2666 
2667 
2668 void LIR_Assembler::comp_op(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, LIR_Op2* op) {
2669   if (opr1-&gt;is_single_cpu()) {
2670     Register reg1 = opr1-&gt;as_register();
2671     if (opr2-&gt;is_single_cpu()) {
2672       // cpu register - cpu register
2673       if (is_reference_type(opr1-&gt;type())) {
2674         __ cmpoop(reg1, opr2-&gt;as_register());
2675       } else {
2676         assert(!is_reference_type(opr2-&gt;type()), &quot;cmp int, oop?&quot;);
2677         __ cmpl(reg1, opr2-&gt;as_register());
2678       }
2679     } else if (opr2-&gt;is_stack()) {
2680       // cpu register - stack
2681       if (is_reference_type(opr1-&gt;type())) {
2682         __ cmpoop(reg1, frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()));
2683       } else {
2684         __ cmpl(reg1, frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()));
2685       }
2686     } else if (opr2-&gt;is_constant()) {
2687       // cpu register - constant
2688       LIR_Const* c = opr2-&gt;as_constant_ptr();
2689       if (c-&gt;type() == T_INT) {
2690         __ cmpl(reg1, c-&gt;as_jint());
2691       } else if (c-&gt;type() == T_METADATA) {
2692         // All we need for now is a comparison with NULL for equality.
2693         assert(condition == lir_cond_equal || condition == lir_cond_notEqual, &quot;oops&quot;);
2694         Metadata* m = c-&gt;as_metadata();
2695         if (m == NULL) {
2696           __ cmpptr(reg1, (int32_t)0);
2697         } else {
2698           ShouldNotReachHere();
2699         }
2700       } else if (is_reference_type(c-&gt;type())) {
2701         // In 64bit oops are single register
2702         jobject o = c-&gt;as_jobject();
2703         if (o == NULL) {
2704           __ cmpptr(reg1, (int32_t)NULL_WORD);
2705         } else {
2706           __ cmpoop(reg1, o);
2707         }
2708       } else {
2709         fatal(&quot;unexpected type: %s&quot;, basictype_to_str(c-&gt;type()));
2710       }
2711       // cpu register - address
2712     } else if (opr2-&gt;is_address()) {
2713       if (op-&gt;info() != NULL) {
2714         add_debug_info_for_null_check_here(op-&gt;info());
2715       }
2716       __ cmpl(reg1, as_Address(opr2-&gt;as_address_ptr()));
2717     } else {
2718       ShouldNotReachHere();
2719     }
2720 
2721   } else if(opr1-&gt;is_double_cpu()) {
2722     Register xlo = opr1-&gt;as_register_lo();
2723     Register xhi = opr1-&gt;as_register_hi();
2724     if (opr2-&gt;is_double_cpu()) {
2725 #ifdef _LP64
2726       __ cmpptr(xlo, opr2-&gt;as_register_lo());
2727 #else
2728       // cpu register - cpu register
2729       Register ylo = opr2-&gt;as_register_lo();
2730       Register yhi = opr2-&gt;as_register_hi();
2731       __ subl(xlo, ylo);
2732       __ sbbl(xhi, yhi);
2733       if (condition == lir_cond_equal || condition == lir_cond_notEqual) {
2734         __ orl(xhi, xlo);
2735       }
2736 #endif // _LP64
2737     } else if (opr2-&gt;is_constant()) {
2738       // cpu register - constant 0
2739       assert(opr2-&gt;as_jlong() == (jlong)0, &quot;only handles zero&quot;);
2740 #ifdef _LP64
2741       __ cmpptr(xlo, (int32_t)opr2-&gt;as_jlong());
2742 #else
2743       assert(condition == lir_cond_equal || condition == lir_cond_notEqual, &quot;only handles equals case&quot;);
2744       __ orl(xhi, xlo);
2745 #endif // _LP64
2746     } else {
2747       ShouldNotReachHere();
2748     }
2749 
2750   } else if (opr1-&gt;is_single_xmm()) {
2751     XMMRegister reg1 = opr1-&gt;as_xmm_float_reg();
2752     if (opr2-&gt;is_single_xmm()) {
2753       // xmm register - xmm register
2754       __ ucomiss(reg1, opr2-&gt;as_xmm_float_reg());
2755     } else if (opr2-&gt;is_stack()) {
2756       // xmm register - stack
2757       __ ucomiss(reg1, frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()));
2758     } else if (opr2-&gt;is_constant()) {
2759       // xmm register - constant
2760       __ ucomiss(reg1, InternalAddress(float_constant(opr2-&gt;as_jfloat())));
2761     } else if (opr2-&gt;is_address()) {
2762       // xmm register - address
2763       if (op-&gt;info() != NULL) {
2764         add_debug_info_for_null_check_here(op-&gt;info());
2765       }
2766       __ ucomiss(reg1, as_Address(opr2-&gt;as_address_ptr()));
2767     } else {
2768       ShouldNotReachHere();
2769     }
2770 
2771   } else if (opr1-&gt;is_double_xmm()) {
2772     XMMRegister reg1 = opr1-&gt;as_xmm_double_reg();
2773     if (opr2-&gt;is_double_xmm()) {
2774       // xmm register - xmm register
2775       __ ucomisd(reg1, opr2-&gt;as_xmm_double_reg());
2776     } else if (opr2-&gt;is_stack()) {
2777       // xmm register - stack
2778       __ ucomisd(reg1, frame_map()-&gt;address_for_slot(opr2-&gt;double_stack_ix()));
2779     } else if (opr2-&gt;is_constant()) {
2780       // xmm register - constant
2781       __ ucomisd(reg1, InternalAddress(double_constant(opr2-&gt;as_jdouble())));
2782     } else if (opr2-&gt;is_address()) {
2783       // xmm register - address
2784       if (op-&gt;info() != NULL) {
2785         add_debug_info_for_null_check_here(op-&gt;info());
2786       }
2787       __ ucomisd(reg1, as_Address(opr2-&gt;pointer()-&gt;as_address()));
2788     } else {
2789       ShouldNotReachHere();
2790     }
2791 
2792 #ifndef _LP64
2793   } else if(opr1-&gt;is_single_fpu() || opr1-&gt;is_double_fpu()) {
2794     assert(opr1-&gt;is_fpu_register() &amp;&amp; opr1-&gt;fpu() == 0, &quot;currently left-hand side must be on TOS (relax this restriction)&quot;);
2795     assert(opr2-&gt;is_fpu_register(), &quot;both must be registers&quot;);
2796     __ fcmp(noreg, opr2-&gt;fpu(), op-&gt;fpu_pop_count() &gt; 0, op-&gt;fpu_pop_count() &gt; 1);
2797 #endif // LP64
2798 
2799   } else if (opr1-&gt;is_address() &amp;&amp; opr2-&gt;is_constant()) {
2800     LIR_Const* c = opr2-&gt;as_constant_ptr();
2801 #ifdef _LP64
2802     if (is_reference_type(c-&gt;type())) {
2803       assert(condition == lir_cond_equal || condition == lir_cond_notEqual, &quot;need to reverse&quot;);
2804       __ movoop(rscratch1, c-&gt;as_jobject());
2805     }
2806 #endif // LP64
2807     if (op-&gt;info() != NULL) {
2808       add_debug_info_for_null_check_here(op-&gt;info());
2809     }
2810     // special case: address - constant
2811     LIR_Address* addr = opr1-&gt;as_address_ptr();
2812     if (c-&gt;type() == T_INT) {
2813       __ cmpl(as_Address(addr), c-&gt;as_jint());
2814     } else if (is_reference_type(c-&gt;type())) {
2815 #ifdef _LP64
2816       // %%% Make this explode if addr isn&#39;t reachable until we figure out a
2817       // better strategy by giving noreg as the temp for as_Address
2818       __ cmpoop(rscratch1, as_Address(addr, noreg));
2819 #else
2820       __ cmpoop(as_Address(addr), c-&gt;as_jobject());
2821 #endif // _LP64
2822     } else {
2823       ShouldNotReachHere();
2824     }
2825 
2826   } else {
2827     ShouldNotReachHere();
2828   }
2829 }
2830 
2831 void LIR_Assembler::comp_fl2i(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dst, LIR_Op2* op) {
2832   if (code == lir_cmp_fd2i || code == lir_ucmp_fd2i) {
2833     if (left-&gt;is_single_xmm()) {
2834       assert(right-&gt;is_single_xmm(), &quot;must match&quot;);
2835       __ cmpss2int(left-&gt;as_xmm_float_reg(), right-&gt;as_xmm_float_reg(), dst-&gt;as_register(), code == lir_ucmp_fd2i);
2836     } else if (left-&gt;is_double_xmm()) {
2837       assert(right-&gt;is_double_xmm(), &quot;must match&quot;);
2838       __ cmpsd2int(left-&gt;as_xmm_double_reg(), right-&gt;as_xmm_double_reg(), dst-&gt;as_register(), code == lir_ucmp_fd2i);
2839 
2840     } else {
2841 #ifdef _LP64
2842       ShouldNotReachHere();
2843 #else
2844       assert(left-&gt;is_single_fpu() || left-&gt;is_double_fpu(), &quot;must be&quot;);
2845       assert(right-&gt;is_single_fpu() || right-&gt;is_double_fpu(), &quot;must match&quot;);
2846 
2847       assert(left-&gt;fpu() == 0, &quot;left must be on TOS&quot;);
2848       __ fcmp2int(dst-&gt;as_register(), code == lir_ucmp_fd2i, right-&gt;fpu(),
2849                   op-&gt;fpu_pop_count() &gt; 0, op-&gt;fpu_pop_count() &gt; 1);
2850 #endif // LP64
2851     }
2852   } else {
2853     assert(code == lir_cmp_l2i, &quot;check&quot;);
2854 #ifdef _LP64
2855     Label done;
2856     Register dest = dst-&gt;as_register();
2857     __ cmpptr(left-&gt;as_register_lo(), right-&gt;as_register_lo());
2858     __ movl(dest, -1);
2859     __ jccb(Assembler::less, done);
2860     __ set_byte_if_not_zero(dest);
2861     __ movzbl(dest, dest);
2862     __ bind(done);
2863 #else
2864     __ lcmp2int(left-&gt;as_register_hi(),
2865                 left-&gt;as_register_lo(),
2866                 right-&gt;as_register_hi(),
2867                 right-&gt;as_register_lo());
2868     move_regs(left-&gt;as_register_hi(), dst-&gt;as_register());
2869 #endif // _LP64
2870   }
2871 }
2872 
2873 
2874 void LIR_Assembler::align_call(LIR_Code code) {
2875   // make sure that the displacement word of the call ends up word aligned
2876   int offset = __ offset();
2877   switch (code) {
2878   case lir_static_call:
2879   case lir_optvirtual_call:
2880   case lir_dynamic_call:
2881     offset += NativeCall::displacement_offset;
2882     break;
2883   case lir_icvirtual_call:
2884     offset += NativeCall::displacement_offset + NativeMovConstReg::instruction_size;
2885     break;
2886   case lir_virtual_call:  // currently, sparc-specific for niagara
2887   default: ShouldNotReachHere();
2888   }
2889   __ align(BytesPerWord, offset);
2890 }
2891 
2892 
2893 void LIR_Assembler::call(LIR_OpJavaCall* op, relocInfo::relocType rtype) {
2894   assert((__ offset() + NativeCall::displacement_offset) % BytesPerWord == 0,
2895          &quot;must be aligned&quot;);
2896   __ call(AddressLiteral(op-&gt;addr(), rtype));
2897   add_call_info(code_offset(), op-&gt;info());
2898 }
2899 
2900 
2901 void LIR_Assembler::ic_call(LIR_OpJavaCall* op) {
2902   __ ic_call(op-&gt;addr());
2903   add_call_info(code_offset(), op-&gt;info());
2904   assert((__ offset() - NativeCall::instruction_size + NativeCall::displacement_offset) % BytesPerWord == 0,
2905          &quot;must be aligned&quot;);
2906 }
2907 
2908 
2909 /* Currently, vtable-dispatch is only enabled for sparc platforms */
2910 void LIR_Assembler::vtable_call(LIR_OpJavaCall* op) {
2911   ShouldNotReachHere();
2912 }
2913 
2914 
2915 void LIR_Assembler::emit_static_call_stub() {
2916   address call_pc = __ pc();
2917   address stub = __ start_a_stub(call_stub_size());
2918   if (stub == NULL) {
2919     bailout(&quot;static call stub overflow&quot;);
2920     return;
2921   }
2922 
2923   int start = __ offset();
2924 
2925   // make sure that the displacement word of the call ends up word aligned
2926   __ align(BytesPerWord, __ offset() + NativeMovConstReg::instruction_size + NativeCall::displacement_offset);
2927   __ relocate(static_stub_Relocation::spec(call_pc, false /* is_aot */));
2928   __ mov_metadata(rbx, (Metadata*)NULL);
2929   // must be set to -1 at code generation time
2930   assert(((__ offset() + 1) % BytesPerWord) == 0, &quot;must be aligned&quot;);
2931   // On 64bit this will die since it will take a movq &amp; jmp, must be only a jmp
2932   __ jump(RuntimeAddress(__ pc()));
2933 
2934   if (UseAOT) {
2935     // Trampoline to aot code
2936     __ relocate(static_stub_Relocation::spec(call_pc, true /* is_aot */));
2937 #ifdef _LP64
2938     __ mov64(rax, CONST64(0));  // address is zapped till fixup time.
2939 #else
2940     __ movl(rax, 0xdeadffff);  // address is zapped till fixup time.
2941 #endif
2942     __ jmp(rax);
2943   }
2944   assert(__ offset() - start &lt;= call_stub_size(), &quot;stub too big&quot;);
2945   __ end_a_stub();
2946 }
2947 
2948 
2949 void LIR_Assembler::throw_op(LIR_Opr exceptionPC, LIR_Opr exceptionOop, CodeEmitInfo* info) {
2950   assert(exceptionOop-&gt;as_register() == rax, &quot;must match&quot;);
2951   assert(exceptionPC-&gt;as_register() == rdx, &quot;must match&quot;);
2952 
2953   // exception object is not added to oop map by LinearScan
2954   // (LinearScan assumes that no oops are in fixed registers)
2955   info-&gt;add_register_oop(exceptionOop);
2956   Runtime1::StubID unwind_id;
2957 
2958   // get current pc information
2959   // pc is only needed if the method has an exception handler, the unwind code does not need it.
2960   int pc_for_athrow_offset = __ offset();
2961   InternalAddress pc_for_athrow(__ pc());
2962   __ lea(exceptionPC-&gt;as_register(), pc_for_athrow);
2963   add_call_info(pc_for_athrow_offset, info); // for exception handler
2964 
2965   __ verify_not_null_oop(rax);
2966   // search an exception handler (rax: exception oop, rdx: throwing pc)
2967   if (compilation()-&gt;has_fpu_code()) {
2968     unwind_id = Runtime1::handle_exception_id;
2969   } else {
2970     unwind_id = Runtime1::handle_exception_nofpu_id;
2971   }
2972   __ call(RuntimeAddress(Runtime1::entry_for(unwind_id)));
2973 
2974   // enough room for two byte trap
2975   __ nop();
2976 }
2977 
2978 
2979 void LIR_Assembler::unwind_op(LIR_Opr exceptionOop) {
2980   assert(exceptionOop-&gt;as_register() == rax, &quot;must match&quot;);
2981 
2982   __ jmp(_unwind_handler_entry);
2983 }
2984 
2985 
2986 void LIR_Assembler::shift_op(LIR_Code code, LIR_Opr left, LIR_Opr count, LIR_Opr dest, LIR_Opr tmp) {
2987 
2988   // optimized version for linear scan:
2989   // * count must be already in ECX (guaranteed by LinearScan)
2990   // * left and dest must be equal
2991   // * tmp must be unused
2992   assert(count-&gt;as_register() == SHIFT_count, &quot;count must be in ECX&quot;);
2993   assert(left == dest, &quot;left and dest must be equal&quot;);
2994   assert(tmp-&gt;is_illegal(), &quot;wasting a register if tmp is allocated&quot;);
2995 
2996   if (left-&gt;is_single_cpu()) {
2997     Register value = left-&gt;as_register();
2998     assert(value != SHIFT_count, &quot;left cannot be ECX&quot;);
2999 
3000     switch (code) {
3001       case lir_shl:  __ shll(value); break;
3002       case lir_shr:  __ sarl(value); break;
3003       case lir_ushr: __ shrl(value); break;
3004       default: ShouldNotReachHere();
3005     }
3006   } else if (left-&gt;is_double_cpu()) {
3007     Register lo = left-&gt;as_register_lo();
3008     Register hi = left-&gt;as_register_hi();
3009     assert(lo != SHIFT_count &amp;&amp; hi != SHIFT_count, &quot;left cannot be ECX&quot;);
3010 #ifdef _LP64
3011     switch (code) {
3012       case lir_shl:  __ shlptr(lo);        break;
3013       case lir_shr:  __ sarptr(lo);        break;
3014       case lir_ushr: __ shrptr(lo);        break;
3015       default: ShouldNotReachHere();
3016     }
3017 #else
3018 
3019     switch (code) {
3020       case lir_shl:  __ lshl(hi, lo);        break;
3021       case lir_shr:  __ lshr(hi, lo, true);  break;
3022       case lir_ushr: __ lshr(hi, lo, false); break;
3023       default: ShouldNotReachHere();
3024     }
3025 #endif // LP64
3026   } else {
3027     ShouldNotReachHere();
3028   }
3029 }
3030 
3031 
3032 void LIR_Assembler::shift_op(LIR_Code code, LIR_Opr left, jint count, LIR_Opr dest) {
3033   if (dest-&gt;is_single_cpu()) {
3034     // first move left into dest so that left is not destroyed by the shift
3035     Register value = dest-&gt;as_register();
3036     count = count &amp; 0x1F; // Java spec
3037 
3038     move_regs(left-&gt;as_register(), value);
3039     switch (code) {
3040       case lir_shl:  __ shll(value, count); break;
3041       case lir_shr:  __ sarl(value, count); break;
3042       case lir_ushr: __ shrl(value, count); break;
3043       default: ShouldNotReachHere();
3044     }
3045   } else if (dest-&gt;is_double_cpu()) {
3046 #ifndef _LP64
3047     Unimplemented();
3048 #else
3049     // first move left into dest so that left is not destroyed by the shift
3050     Register value = dest-&gt;as_register_lo();
3051     count = count &amp; 0x1F; // Java spec
3052 
3053     move_regs(left-&gt;as_register_lo(), value);
3054     switch (code) {
3055       case lir_shl:  __ shlptr(value, count); break;
3056       case lir_shr:  __ sarptr(value, count); break;
3057       case lir_ushr: __ shrptr(value, count); break;
3058       default: ShouldNotReachHere();
3059     }
3060 #endif // _LP64
3061   } else {
3062     ShouldNotReachHere();
3063   }
3064 }
3065 
3066 
3067 void LIR_Assembler::store_parameter(Register r, int offset_from_rsp_in_words) {
3068   assert(offset_from_rsp_in_words &gt;= 0, &quot;invalid offset from rsp&quot;);
3069   int offset_from_rsp_in_bytes = offset_from_rsp_in_words * BytesPerWord;
3070   assert(offset_from_rsp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
3071   __ movptr (Address(rsp, offset_from_rsp_in_bytes), r);
3072 }
3073 
3074 
3075 void LIR_Assembler::store_parameter(jint c,     int offset_from_rsp_in_words) {
3076   assert(offset_from_rsp_in_words &gt;= 0, &quot;invalid offset from rsp&quot;);
3077   int offset_from_rsp_in_bytes = offset_from_rsp_in_words * BytesPerWord;
3078   assert(offset_from_rsp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
3079   __ movptr (Address(rsp, offset_from_rsp_in_bytes), c);
3080 }
3081 
3082 
3083 void LIR_Assembler::store_parameter(jobject o,  int offset_from_rsp_in_words) {
3084   assert(offset_from_rsp_in_words &gt;= 0, &quot;invalid offset from rsp&quot;);
3085   int offset_from_rsp_in_bytes = offset_from_rsp_in_words * BytesPerWord;
3086   assert(offset_from_rsp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
3087   __ movoop (Address(rsp, offset_from_rsp_in_bytes), o);
3088 }
3089 
3090 
3091 void LIR_Assembler::store_parameter(Metadata* m,  int offset_from_rsp_in_words) {
3092   assert(offset_from_rsp_in_words &gt;= 0, &quot;invalid offset from rsp&quot;);
3093   int offset_from_rsp_in_bytes = offset_from_rsp_in_words * BytesPerWord;
3094   assert(offset_from_rsp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
3095   __ mov_metadata(Address(rsp, offset_from_rsp_in_bytes), m);
3096 }
3097 
3098 
3099 // This code replaces a call to arraycopy; no exception may
3100 // be thrown in this code, they must be thrown in the System.arraycopy
3101 // activation frame; we could save some checks if this would not be the case
3102 void LIR_Assembler::emit_arraycopy(LIR_OpArrayCopy* op) {
3103   ciArrayKlass* default_type = op-&gt;expected_type();
3104   Register src = op-&gt;src()-&gt;as_register();
3105   Register dst = op-&gt;dst()-&gt;as_register();
3106   Register src_pos = op-&gt;src_pos()-&gt;as_register();
3107   Register dst_pos = op-&gt;dst_pos()-&gt;as_register();
3108   Register length  = op-&gt;length()-&gt;as_register();
3109   Register tmp = op-&gt;tmp()-&gt;as_register();
3110 
3111   __ resolve(ACCESS_READ, src);
3112   __ resolve(ACCESS_WRITE, dst);
3113 
3114   CodeStub* stub = op-&gt;stub();
3115   int flags = op-&gt;flags();
3116   BasicType basic_type = default_type != NULL ? default_type-&gt;element_type()-&gt;basic_type() : T_ILLEGAL;
3117   if (is_reference_type(basic_type)) basic_type = T_OBJECT;
3118 
3119   // if we don&#39;t know anything, just go through the generic arraycopy
3120   if (default_type == NULL) {
3121     // save outgoing arguments on stack in case call to System.arraycopy is needed
3122     // HACK ALERT. This code used to push the parameters in a hardwired fashion
3123     // for interpreter calling conventions. Now we have to do it in new style conventions.
3124     // For the moment until C1 gets the new register allocator I just force all the
3125     // args to the right place (except the register args) and then on the back side
3126     // reload the register args properly if we go slow path. Yuck
3127 
3128     // These are proper for the calling convention
3129     store_parameter(length, 2);
3130     store_parameter(dst_pos, 1);
3131     store_parameter(dst, 0);
3132 
3133     // these are just temporary placements until we need to reload
3134     store_parameter(src_pos, 3);
3135     store_parameter(src, 4);
3136     NOT_LP64(assert(src == rcx &amp;&amp; src_pos == rdx, &quot;mismatch in calling convention&quot;);)
3137 
3138     address copyfunc_addr = StubRoutines::generic_arraycopy();
3139     assert(copyfunc_addr != NULL, &quot;generic arraycopy stub required&quot;);
3140 
3141     // pass arguments: may push as this is not a safepoint; SP must be fix at each safepoint
3142 #ifdef _LP64
3143     // The arguments are in java calling convention so we can trivially shift them to C
3144     // convention
3145     assert_different_registers(c_rarg0, j_rarg1, j_rarg2, j_rarg3, j_rarg4);
3146     __ mov(c_rarg0, j_rarg0);
3147     assert_different_registers(c_rarg1, j_rarg2, j_rarg3, j_rarg4);
3148     __ mov(c_rarg1, j_rarg1);
3149     assert_different_registers(c_rarg2, j_rarg3, j_rarg4);
3150     __ mov(c_rarg2, j_rarg2);
3151     assert_different_registers(c_rarg3, j_rarg4);
3152     __ mov(c_rarg3, j_rarg3);
3153 #ifdef _WIN64
3154     // Allocate abi space for args but be sure to keep stack aligned
3155     __ subptr(rsp, 6*wordSize);
3156     store_parameter(j_rarg4, 4);
3157 #ifndef PRODUCT
3158     if (PrintC1Statistics) {
3159       __ incrementl(ExternalAddress((address)&amp;Runtime1::_generic_arraycopystub_cnt));
3160     }
3161 #endif
3162     __ call(RuntimeAddress(copyfunc_addr));
3163     __ addptr(rsp, 6*wordSize);
3164 #else
3165     __ mov(c_rarg4, j_rarg4);
3166 #ifndef PRODUCT
3167     if (PrintC1Statistics) {
3168       __ incrementl(ExternalAddress((address)&amp;Runtime1::_generic_arraycopystub_cnt));
3169     }
3170 #endif
3171     __ call(RuntimeAddress(copyfunc_addr));
3172 #endif // _WIN64
3173 #else
3174     __ push(length);
3175     __ push(dst_pos);
3176     __ push(dst);
3177     __ push(src_pos);
3178     __ push(src);
3179 
3180 #ifndef PRODUCT
3181     if (PrintC1Statistics) {
3182       __ incrementl(ExternalAddress((address)&amp;Runtime1::_generic_arraycopystub_cnt));
3183     }
3184 #endif
3185     __ call_VM_leaf(copyfunc_addr, 5); // removes pushed parameter from the stack
3186 
3187 #endif // _LP64
3188 
3189     __ cmpl(rax, 0);
3190     __ jcc(Assembler::equal, *stub-&gt;continuation());
3191 
3192     __ mov(tmp, rax);
3193     __ xorl(tmp, -1);
3194 
3195     // Reload values from the stack so they are where the stub
3196     // expects them.
3197     __ movptr   (dst,     Address(rsp, 0*BytesPerWord));
3198     __ movptr   (dst_pos, Address(rsp, 1*BytesPerWord));
3199     __ movptr   (length,  Address(rsp, 2*BytesPerWord));
3200     __ movptr   (src_pos, Address(rsp, 3*BytesPerWord));
3201     __ movptr   (src,     Address(rsp, 4*BytesPerWord));
3202 
3203     __ subl(length, tmp);
3204     __ addl(src_pos, tmp);
3205     __ addl(dst_pos, tmp);
3206     __ jmp(*stub-&gt;entry());
3207 
3208     __ bind(*stub-&gt;continuation());
3209     return;
3210   }
3211 
3212   assert(default_type != NULL &amp;&amp; default_type-&gt;is_array_klass() &amp;&amp; default_type-&gt;is_loaded(), &quot;must be true at this point&quot;);
3213 
3214   int elem_size = type2aelembytes(basic_type);
3215   Address::ScaleFactor scale;
3216 
3217   switch (elem_size) {
3218     case 1 :
3219       scale = Address::times_1;
3220       break;
3221     case 2 :
3222       scale = Address::times_2;
3223       break;
3224     case 4 :
3225       scale = Address::times_4;
3226       break;
3227     case 8 :
3228       scale = Address::times_8;
3229       break;
3230     default:
3231       scale = Address::no_scale;
3232       ShouldNotReachHere();
3233   }
3234 
3235   Address src_length_addr = Address(src, arrayOopDesc::length_offset_in_bytes());
3236   Address dst_length_addr = Address(dst, arrayOopDesc::length_offset_in_bytes());
3237   Address src_klass_addr = Address(src, oopDesc::klass_offset_in_bytes());
3238   Address dst_klass_addr = Address(dst, oopDesc::klass_offset_in_bytes());
3239 
3240   // length and pos&#39;s are all sign extended at this point on 64bit
3241 
3242   // test for NULL
3243   if (flags &amp; LIR_OpArrayCopy::src_null_check) {
3244     __ testptr(src, src);
3245     __ jcc(Assembler::zero, *stub-&gt;entry());
3246   }
3247   if (flags &amp; LIR_OpArrayCopy::dst_null_check) {
3248     __ testptr(dst, dst);
3249     __ jcc(Assembler::zero, *stub-&gt;entry());
3250   }
3251 
3252   // If the compiler was not able to prove that exact type of the source or the destination
3253   // of the arraycopy is an array type, check at runtime if the source or the destination is
3254   // an instance type.
3255   if (flags &amp; LIR_OpArrayCopy::type_check) {
3256     if (!(flags &amp; LIR_OpArrayCopy::dst_objarray)) {
3257       __ load_klass(tmp, dst);
3258       __ cmpl(Address(tmp, in_bytes(Klass::layout_helper_offset())), Klass::_lh_neutral_value);
3259       __ jcc(Assembler::greaterEqual, *stub-&gt;entry());
3260     }
3261 
3262     if (!(flags &amp; LIR_OpArrayCopy::src_objarray)) {
3263       __ load_klass(tmp, src);
3264       __ cmpl(Address(tmp, in_bytes(Klass::layout_helper_offset())), Klass::_lh_neutral_value);
3265       __ jcc(Assembler::greaterEqual, *stub-&gt;entry());
3266     }
3267   }
3268 
3269   // check if negative
3270   if (flags &amp; LIR_OpArrayCopy::src_pos_positive_check) {
3271     __ testl(src_pos, src_pos);
3272     __ jcc(Assembler::less, *stub-&gt;entry());
3273   }
3274   if (flags &amp; LIR_OpArrayCopy::dst_pos_positive_check) {
3275     __ testl(dst_pos, dst_pos);
3276     __ jcc(Assembler::less, *stub-&gt;entry());
3277   }
3278 
3279   if (flags &amp; LIR_OpArrayCopy::src_range_check) {
3280     __ lea(tmp, Address(src_pos, length, Address::times_1, 0));
3281     __ cmpl(tmp, src_length_addr);
3282     __ jcc(Assembler::above, *stub-&gt;entry());
3283   }
3284   if (flags &amp; LIR_OpArrayCopy::dst_range_check) {
3285     __ lea(tmp, Address(dst_pos, length, Address::times_1, 0));
3286     __ cmpl(tmp, dst_length_addr);
3287     __ jcc(Assembler::above, *stub-&gt;entry());
3288   }
3289 
3290   if (flags &amp; LIR_OpArrayCopy::length_positive_check) {
3291     __ testl(length, length);
3292     __ jcc(Assembler::less, *stub-&gt;entry());
3293   }
3294 
3295 #ifdef _LP64
3296   __ movl2ptr(src_pos, src_pos); //higher 32bits must be null
3297   __ movl2ptr(dst_pos, dst_pos); //higher 32bits must be null
3298 #endif
3299 
3300   if (flags &amp; LIR_OpArrayCopy::type_check) {
3301     // We don&#39;t know the array types are compatible
3302     if (basic_type != T_OBJECT) {
3303       // Simple test for basic type arrays
3304       if (UseCompressedClassPointers) {
3305         __ movl(tmp, src_klass_addr);
3306         __ cmpl(tmp, dst_klass_addr);
3307       } else {
3308         __ movptr(tmp, src_klass_addr);
3309         __ cmpptr(tmp, dst_klass_addr);
3310       }
3311       __ jcc(Assembler::notEqual, *stub-&gt;entry());
3312     } else {
3313       // For object arrays, if src is a sub class of dst then we can
3314       // safely do the copy.
3315       Label cont, slow;
3316 
3317       __ push(src);
3318       __ push(dst);
3319 
3320       __ load_klass(src, src);
3321       __ load_klass(dst, dst);
3322 
3323       __ check_klass_subtype_fast_path(src, dst, tmp, &amp;cont, &amp;slow, NULL);
3324 
3325       __ push(src);
3326       __ push(dst);
3327       __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
3328       __ pop(dst);
3329       __ pop(src);
3330 
3331       __ cmpl(src, 0);
3332       __ jcc(Assembler::notEqual, cont);
3333 
3334       __ bind(slow);
3335       __ pop(dst);
3336       __ pop(src);
3337 
3338       address copyfunc_addr = StubRoutines::checkcast_arraycopy();
3339       if (copyfunc_addr != NULL) { // use stub if available
3340         // src is not a sub class of dst so we have to do a
3341         // per-element check.
3342 
3343         int mask = LIR_OpArrayCopy::src_objarray|LIR_OpArrayCopy::dst_objarray;
3344         if ((flags &amp; mask) != mask) {
3345           // Check that at least both of them object arrays.
3346           assert(flags &amp; mask, &quot;one of the two should be known to be an object array&quot;);
3347 
3348           if (!(flags &amp; LIR_OpArrayCopy::src_objarray)) {
3349             __ load_klass(tmp, src);
3350           } else if (!(flags &amp; LIR_OpArrayCopy::dst_objarray)) {
3351             __ load_klass(tmp, dst);
3352           }
3353           int lh_offset = in_bytes(Klass::layout_helper_offset());
3354           Address klass_lh_addr(tmp, lh_offset);
3355           jint objArray_lh = Klass::array_layout_helper(T_OBJECT);
3356           __ cmpl(klass_lh_addr, objArray_lh);
3357           __ jcc(Assembler::notEqual, *stub-&gt;entry());
3358         }
3359 
3360        // Spill because stubs can use any register they like and it&#39;s
3361        // easier to restore just those that we care about.
3362        store_parameter(dst, 0);
3363        store_parameter(dst_pos, 1);
3364        store_parameter(length, 2);
3365        store_parameter(src_pos, 3);
3366        store_parameter(src, 4);
3367 
3368 #ifndef _LP64
3369         __ movptr(tmp, dst_klass_addr);
3370         __ movptr(tmp, Address(tmp, ObjArrayKlass::element_klass_offset()));
3371         __ push(tmp);
3372         __ movl(tmp, Address(tmp, Klass::super_check_offset_offset()));
3373         __ push(tmp);
3374         __ push(length);
3375         __ lea(tmp, Address(dst, dst_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3376         __ push(tmp);
3377         __ lea(tmp, Address(src, src_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3378         __ push(tmp);
3379 
3380         __ call_VM_leaf(copyfunc_addr, 5);
3381 #else
3382         __ movl2ptr(length, length); //higher 32bits must be null
3383 
3384         __ lea(c_rarg0, Address(src, src_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3385         assert_different_registers(c_rarg0, dst, dst_pos, length);
3386         __ lea(c_rarg1, Address(dst, dst_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3387         assert_different_registers(c_rarg1, dst, length);
3388 
3389         __ mov(c_rarg2, length);
3390         assert_different_registers(c_rarg2, dst);
3391 
3392 #ifdef _WIN64
3393         // Allocate abi space for args but be sure to keep stack aligned
3394         __ subptr(rsp, 6*wordSize);
3395         __ load_klass(c_rarg3, dst);
3396         __ movptr(c_rarg3, Address(c_rarg3, ObjArrayKlass::element_klass_offset()));
3397         store_parameter(c_rarg3, 4);
3398         __ movl(c_rarg3, Address(c_rarg3, Klass::super_check_offset_offset()));
3399         __ call(RuntimeAddress(copyfunc_addr));
3400         __ addptr(rsp, 6*wordSize);
3401 #else
3402         __ load_klass(c_rarg4, dst);
3403         __ movptr(c_rarg4, Address(c_rarg4, ObjArrayKlass::element_klass_offset()));
3404         __ movl(c_rarg3, Address(c_rarg4, Klass::super_check_offset_offset()));
3405         __ call(RuntimeAddress(copyfunc_addr));
3406 #endif
3407 
3408 #endif
3409 
3410 #ifndef PRODUCT
3411         if (PrintC1Statistics) {
3412           Label failed;
3413           __ testl(rax, rax);
3414           __ jcc(Assembler::notZero, failed);
3415           __ incrementl(ExternalAddress((address)&amp;Runtime1::_arraycopy_checkcast_cnt));
3416           __ bind(failed);
3417         }
3418 #endif
3419 
3420         __ testl(rax, rax);
3421         __ jcc(Assembler::zero, *stub-&gt;continuation());
3422 
3423 #ifndef PRODUCT
3424         if (PrintC1Statistics) {
3425           __ incrementl(ExternalAddress((address)&amp;Runtime1::_arraycopy_checkcast_attempt_cnt));
3426         }
3427 #endif
3428 
3429         __ mov(tmp, rax);
3430 
3431         __ xorl(tmp, -1);
3432 
3433         // Restore previously spilled arguments
3434         __ movptr   (dst,     Address(rsp, 0*BytesPerWord));
3435         __ movptr   (dst_pos, Address(rsp, 1*BytesPerWord));
3436         __ movptr   (length,  Address(rsp, 2*BytesPerWord));
3437         __ movptr   (src_pos, Address(rsp, 3*BytesPerWord));
3438         __ movptr   (src,     Address(rsp, 4*BytesPerWord));
3439 
3440 
3441         __ subl(length, tmp);
3442         __ addl(src_pos, tmp);
3443         __ addl(dst_pos, tmp);
3444       }
3445 
3446       __ jmp(*stub-&gt;entry());
3447 
3448       __ bind(cont);
3449       __ pop(dst);
3450       __ pop(src);
3451     }
3452   }
3453 
3454 #ifdef ASSERT
3455   if (basic_type != T_OBJECT || !(flags &amp; LIR_OpArrayCopy::type_check)) {
3456     // Sanity check the known type with the incoming class.  For the
3457     // primitive case the types must match exactly with src.klass and
3458     // dst.klass each exactly matching the default type.  For the
3459     // object array case, if no type check is needed then either the
3460     // dst type is exactly the expected type and the src type is a
3461     // subtype which we can&#39;t check or src is the same array as dst
3462     // but not necessarily exactly of type default_type.
3463     Label known_ok, halt;
3464     __ mov_metadata(tmp, default_type-&gt;constant_encoding());
3465 #ifdef _LP64
3466     if (UseCompressedClassPointers) {
3467       __ encode_klass_not_null(tmp);
3468     }
3469 #endif
3470 
3471     if (basic_type != T_OBJECT) {
3472 
3473       if (UseCompressedClassPointers)          __ cmpl(tmp, dst_klass_addr);
3474       else                   __ cmpptr(tmp, dst_klass_addr);
3475       __ jcc(Assembler::notEqual, halt);
3476       if (UseCompressedClassPointers)          __ cmpl(tmp, src_klass_addr);
3477       else                   __ cmpptr(tmp, src_klass_addr);
3478       __ jcc(Assembler::equal, known_ok);
3479     } else {
3480       if (UseCompressedClassPointers)          __ cmpl(tmp, dst_klass_addr);
3481       else                   __ cmpptr(tmp, dst_klass_addr);
3482       __ jcc(Assembler::equal, known_ok);
3483       __ cmpptr(src, dst);
3484       __ jcc(Assembler::equal, known_ok);
3485     }
3486     __ bind(halt);
3487     __ stop(&quot;incorrect type information in arraycopy&quot;);
3488     __ bind(known_ok);
3489   }
3490 #endif
3491 
3492 #ifndef PRODUCT
3493   if (PrintC1Statistics) {
3494     __ incrementl(ExternalAddress(Runtime1::arraycopy_count_address(basic_type)));
3495   }
3496 #endif
3497 
3498 #ifdef _LP64
3499   assert_different_registers(c_rarg0, dst, dst_pos, length);
3500   __ lea(c_rarg0, Address(src, src_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3501   assert_different_registers(c_rarg1, length);
3502   __ lea(c_rarg1, Address(dst, dst_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3503   __ mov(c_rarg2, length);
3504 
3505 #else
3506   __ lea(tmp, Address(src, src_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3507   store_parameter(tmp, 0);
3508   __ lea(tmp, Address(dst, dst_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3509   store_parameter(tmp, 1);
3510   store_parameter(length, 2);
3511 #endif // _LP64
3512 
3513   bool disjoint = (flags &amp; LIR_OpArrayCopy::overlapping) == 0;
3514   bool aligned = (flags &amp; LIR_OpArrayCopy::unaligned) == 0;
3515   const char *name;
3516   address entry = StubRoutines::select_arraycopy_function(basic_type, aligned, disjoint, name, false);
3517   __ call_VM_leaf(entry, 0);
3518 
3519   __ bind(*stub-&gt;continuation());
3520 }
3521 
3522 void LIR_Assembler::emit_updatecrc32(LIR_OpUpdateCRC32* op) {
3523   assert(op-&gt;crc()-&gt;is_single_cpu(),  &quot;crc must be register&quot;);
3524   assert(op-&gt;val()-&gt;is_single_cpu(),  &quot;byte value must be register&quot;);
3525   assert(op-&gt;result_opr()-&gt;is_single_cpu(), &quot;result must be register&quot;);
3526   Register crc = op-&gt;crc()-&gt;as_register();
3527   Register val = op-&gt;val()-&gt;as_register();
3528   Register res = op-&gt;result_opr()-&gt;as_register();
3529 
3530   assert_different_registers(val, crc, res);
3531 
3532   __ lea(res, ExternalAddress(StubRoutines::crc_table_addr()));
3533   __ notl(crc); // ~crc
3534   __ update_byte_crc32(crc, val, res);
3535   __ notl(crc); // ~crc
3536   __ mov(res, crc);
3537 }
3538 
3539 void LIR_Assembler::emit_lock(LIR_OpLock* op) {
3540   Register obj = op-&gt;obj_opr()-&gt;as_register();  // may not be an oop
3541   Register hdr = op-&gt;hdr_opr()-&gt;as_register();
3542   Register lock = op-&gt;lock_opr()-&gt;as_register();
3543   if (!UseFastLocking) {
3544     __ jmp(*op-&gt;stub()-&gt;entry());
3545   } else if (op-&gt;code() == lir_lock) {
3546     Register scratch = noreg;
3547     if (UseBiasedLocking) {
3548       scratch = op-&gt;scratch_opr()-&gt;as_register();
3549     }
3550     assert(BasicLock::displaced_header_offset_in_bytes() == 0, &quot;lock_reg must point to the displaced header&quot;);
3551     __ resolve(ACCESS_READ | ACCESS_WRITE, obj);
3552     // add debug info for NullPointerException only if one is possible
3553     int null_check_offset = __ lock_object(hdr, obj, lock, scratch, *op-&gt;stub()-&gt;entry());
3554     if (op-&gt;info() != NULL) {
3555       add_debug_info_for_null_check(null_check_offset, op-&gt;info());
3556     }
3557     // done
3558   } else if (op-&gt;code() == lir_unlock) {
3559     assert(BasicLock::displaced_header_offset_in_bytes() == 0, &quot;lock_reg must point to the displaced header&quot;);
3560     __ unlock_object(hdr, obj, lock, *op-&gt;stub()-&gt;entry());
3561   } else {
3562     Unimplemented();
3563   }
3564   __ bind(*op-&gt;stub()-&gt;continuation());
3565 }
3566 
3567 
3568 void LIR_Assembler::emit_profile_call(LIR_OpProfileCall* op) {
3569   ciMethod* method = op-&gt;profiled_method();
3570   int bci          = op-&gt;profiled_bci();
3571   ciMethod* callee = op-&gt;profiled_callee();
3572 
3573   // Update counter for all call types
3574   ciMethodData* md = method-&gt;method_data_or_null();
3575   assert(md != NULL, &quot;Sanity&quot;);
3576   ciProfileData* data = md-&gt;bci_to_data(bci);
3577   assert(data != NULL &amp;&amp; data-&gt;is_CounterData(), &quot;need CounterData for calls&quot;);
3578   assert(op-&gt;mdo()-&gt;is_single_cpu(),  &quot;mdo must be allocated&quot;);
3579   Register mdo  = op-&gt;mdo()-&gt;as_register();
3580   __ mov_metadata(mdo, md-&gt;constant_encoding());
3581   Address counter_addr(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()));
3582   // Perform additional virtual call profiling for invokevirtual and
3583   // invokeinterface bytecodes
3584   if (op-&gt;should_profile_receiver_type()) {
3585     assert(op-&gt;recv()-&gt;is_single_cpu(), &quot;recv must be allocated&quot;);
3586     Register recv = op-&gt;recv()-&gt;as_register();
3587     assert_different_registers(mdo, recv);
3588     assert(data-&gt;is_VirtualCallData(), &quot;need VirtualCallData for virtual calls&quot;);
3589     ciKlass* known_klass = op-&gt;known_holder();
3590     if (C1OptimizeVirtualCallProfiling &amp;&amp; known_klass != NULL) {
3591       // We know the type that will be seen at this call site; we can
3592       // statically update the MethodData* rather than needing to do
3593       // dynamic tests on the receiver type
3594 
3595       // NOTE: we should probably put a lock around this search to
3596       // avoid collisions by concurrent compilations
3597       ciVirtualCallData* vc_data = (ciVirtualCallData*) data;
3598       uint i;
3599       for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
3600         ciKlass* receiver = vc_data-&gt;receiver(i);
3601         if (known_klass-&gt;equals(receiver)) {
3602           Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_count_offset(i)));
3603           __ addptr(data_addr, DataLayout::counter_increment);
3604           return;
3605         }
3606       }
3607 
3608       // Receiver type not found in profile data; select an empty slot
3609 
3610       // Note that this is less efficient than it should be because it
3611       // always does a write to the receiver part of the
3612       // VirtualCallData rather than just the first time
3613       for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
3614         ciKlass* receiver = vc_data-&gt;receiver(i);
3615         if (receiver == NULL) {
3616           Address recv_addr(mdo, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_offset(i)));
3617           __ mov_metadata(recv_addr, known_klass-&gt;constant_encoding());
3618           Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_count_offset(i)));
3619           __ addptr(data_addr, DataLayout::counter_increment);
3620           return;
3621         }
3622       }
3623     } else {
3624       __ load_klass(recv, recv);
3625       Label update_done;
3626       type_profile_helper(mdo, md, data, recv, &amp;update_done);
3627       // Receiver did not match any saved receiver and there is no empty row for it.
3628       // Increment total counter to indicate polymorphic case.
3629       __ addptr(counter_addr, DataLayout::counter_increment);
3630 
3631       __ bind(update_done);
3632     }
3633   } else {
3634     // Static call
3635     __ addptr(counter_addr, DataLayout::counter_increment);
3636   }
3637 }
3638 
3639 void LIR_Assembler::emit_profile_type(LIR_OpProfileType* op) {
3640   Register obj = op-&gt;obj()-&gt;as_register();
3641   Register tmp = op-&gt;tmp()-&gt;as_pointer_register();
3642   Address mdo_addr = as_Address(op-&gt;mdp()-&gt;as_address_ptr());
3643   ciKlass* exact_klass = op-&gt;exact_klass();
3644   intptr_t current_klass = op-&gt;current_klass();
3645   bool not_null = op-&gt;not_null();
3646   bool no_conflict = op-&gt;no_conflict();
3647 
3648   Label update, next, none;
3649 
3650   bool do_null = !not_null;
3651   bool exact_klass_set = exact_klass != NULL &amp;&amp; ciTypeEntries::valid_ciklass(current_klass) == exact_klass;
3652   bool do_update = !TypeEntries::is_type_unknown(current_klass) &amp;&amp; !exact_klass_set;
3653 
3654   assert(do_null || do_update, &quot;why are we here?&quot;);
3655   assert(!TypeEntries::was_null_seen(current_klass) || do_update, &quot;why are we here?&quot;);
3656 
3657   __ verify_oop(obj);
3658 
3659   if (tmp != obj) {
3660     __ mov(tmp, obj);
3661   }
3662   if (do_null) {
3663     __ testptr(tmp, tmp);
3664     __ jccb(Assembler::notZero, update);
3665     if (!TypeEntries::was_null_seen(current_klass)) {
3666       __ orptr(mdo_addr, TypeEntries::null_seen);
3667     }
3668     if (do_update) {
3669 #ifndef ASSERT
3670       __ jmpb(next);
3671     }
3672 #else
3673       __ jmp(next);
3674     }
3675   } else {
3676     __ testptr(tmp, tmp);
3677     __ jcc(Assembler::notZero, update);
3678     __ stop(&quot;unexpect null obj&quot;);
3679 #endif
3680   }
3681 
3682   __ bind(update);
3683 
3684   if (do_update) {
3685 #ifdef ASSERT
3686     if (exact_klass != NULL) {
3687       Label ok;
3688       __ load_klass(tmp, tmp);
3689       __ push(tmp);
3690       __ mov_metadata(tmp, exact_klass-&gt;constant_encoding());
3691       __ cmpptr(tmp, Address(rsp, 0));
3692       __ jcc(Assembler::equal, ok);
3693       __ stop(&quot;exact klass and actual klass differ&quot;);
3694       __ bind(ok);
3695       __ pop(tmp);
3696     }
3697 #endif
3698     if (!no_conflict) {
3699       if (exact_klass == NULL || TypeEntries::is_type_none(current_klass)) {
3700         if (exact_klass != NULL) {
3701           __ mov_metadata(tmp, exact_klass-&gt;constant_encoding());
3702         } else {
3703           __ load_klass(tmp, tmp);
3704         }
3705 
3706         __ xorptr(tmp, mdo_addr);
3707         __ testptr(tmp, TypeEntries::type_klass_mask);
3708         // klass seen before, nothing to do. The unknown bit may have been
3709         // set already but no need to check.
3710         __ jccb(Assembler::zero, next);
3711 
3712         __ testptr(tmp, TypeEntries::type_unknown);
3713         __ jccb(Assembler::notZero, next); // already unknown. Nothing to do anymore.
3714 
3715         if (TypeEntries::is_type_none(current_klass)) {
3716           __ cmpptr(mdo_addr, 0);
3717           __ jccb(Assembler::equal, none);
3718           __ cmpptr(mdo_addr, TypeEntries::null_seen);
3719           __ jccb(Assembler::equal, none);
3720           // There is a chance that the checks above (re-reading profiling
3721           // data from memory) fail if another thread has just set the
3722           // profiling to this obj&#39;s klass
3723           __ xorptr(tmp, mdo_addr);
3724           __ testptr(tmp, TypeEntries::type_klass_mask);
3725           __ jccb(Assembler::zero, next);
3726         }
3727       } else {
3728         assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &amp;&amp;
3729                ciTypeEntries::valid_ciklass(current_klass) != exact_klass, &quot;conflict only&quot;);
3730 
3731         __ movptr(tmp, mdo_addr);
3732         __ testptr(tmp, TypeEntries::type_unknown);
3733         __ jccb(Assembler::notZero, next); // already unknown. Nothing to do anymore.
3734       }
3735 
3736       // different than before. Cannot keep accurate profile.
3737       __ orptr(mdo_addr, TypeEntries::type_unknown);
3738 
3739       if (TypeEntries::is_type_none(current_klass)) {
3740         __ jmpb(next);
3741 
3742         __ bind(none);
3743         // first time here. Set profile type.
3744         __ movptr(mdo_addr, tmp);
3745       }
3746     } else {
3747       // There&#39;s a single possible klass at this profile point
3748       assert(exact_klass != NULL, &quot;should be&quot;);
3749       if (TypeEntries::is_type_none(current_klass)) {
3750         __ mov_metadata(tmp, exact_klass-&gt;constant_encoding());
3751         __ xorptr(tmp, mdo_addr);
3752         __ testptr(tmp, TypeEntries::type_klass_mask);
3753 #ifdef ASSERT
3754         __ jcc(Assembler::zero, next);
3755 
3756         {
3757           Label ok;
3758           __ push(tmp);
3759           __ cmpptr(mdo_addr, 0);
3760           __ jcc(Assembler::equal, ok);
3761           __ cmpptr(mdo_addr, TypeEntries::null_seen);
3762           __ jcc(Assembler::equal, ok);
3763           // may have been set by another thread
3764           __ mov_metadata(tmp, exact_klass-&gt;constant_encoding());
3765           __ xorptr(tmp, mdo_addr);
3766           __ testptr(tmp, TypeEntries::type_mask);
3767           __ jcc(Assembler::zero, ok);
3768 
3769           __ stop(&quot;unexpected profiling mismatch&quot;);
3770           __ bind(ok);
3771           __ pop(tmp);
3772         }
3773 #else
3774         __ jccb(Assembler::zero, next);
3775 #endif
3776         // first time here. Set profile type.
3777         __ movptr(mdo_addr, tmp);
3778       } else {
3779         assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &amp;&amp;
3780                ciTypeEntries::valid_ciklass(current_klass) != exact_klass, &quot;inconsistent&quot;);
3781 
3782         __ movptr(tmp, mdo_addr);
3783         __ testptr(tmp, TypeEntries::type_unknown);
3784         __ jccb(Assembler::notZero, next); // already unknown. Nothing to do anymore.
3785 
3786         __ orptr(mdo_addr, TypeEntries::type_unknown);
3787       }
3788     }
3789 
3790     __ bind(next);
3791   }
3792 }
3793 
3794 void LIR_Assembler::emit_delay(LIR_OpDelay*) {
3795   Unimplemented();
3796 }
3797 
3798 
3799 void LIR_Assembler::monitor_address(int monitor_no, LIR_Opr dst) {
3800   __ lea(dst-&gt;as_register(), frame_map()-&gt;address_for_monitor_lock(monitor_no));
3801 }
3802 
3803 
3804 void LIR_Assembler::align_backward_branch_target() {
3805   __ align(BytesPerWord);
3806 }
3807 
3808 
3809 void LIR_Assembler::negate(LIR_Opr left, LIR_Opr dest, LIR_Opr tmp) {
3810   if (left-&gt;is_single_cpu()) {
3811     __ negl(left-&gt;as_register());
3812     move_regs(left-&gt;as_register(), dest-&gt;as_register());
3813 
3814   } else if (left-&gt;is_double_cpu()) {
3815     Register lo = left-&gt;as_register_lo();
3816 #ifdef _LP64
3817     Register dst = dest-&gt;as_register_lo();
3818     __ movptr(dst, lo);
3819     __ negptr(dst);
3820 #else
3821     Register hi = left-&gt;as_register_hi();
3822     __ lneg(hi, lo);
3823     if (dest-&gt;as_register_lo() == hi) {
3824       assert(dest-&gt;as_register_hi() != lo, &quot;destroying register&quot;);
3825       move_regs(hi, dest-&gt;as_register_hi());
3826       move_regs(lo, dest-&gt;as_register_lo());
3827     } else {
3828       move_regs(lo, dest-&gt;as_register_lo());
3829       move_regs(hi, dest-&gt;as_register_hi());
3830     }
3831 #endif // _LP64
3832 
3833   } else if (dest-&gt;is_single_xmm()) {
3834 #ifdef _LP64
3835     if (UseAVX &gt; 2 &amp;&amp; !VM_Version::supports_avx512vl()) {
3836       assert(tmp-&gt;is_valid(), &quot;need temporary&quot;);
3837       assert_different_registers(left-&gt;as_xmm_float_reg(), tmp-&gt;as_xmm_float_reg());
3838       __ vpxor(dest-&gt;as_xmm_float_reg(), tmp-&gt;as_xmm_float_reg(), left-&gt;as_xmm_float_reg(), 2);
3839     }
3840     else
3841 #endif
3842     {
3843       assert(!tmp-&gt;is_valid(), &quot;do not need temporary&quot;);
3844       if (left-&gt;as_xmm_float_reg() != dest-&gt;as_xmm_float_reg()) {
3845         __ movflt(dest-&gt;as_xmm_float_reg(), left-&gt;as_xmm_float_reg());
3846       }
3847       __ xorps(dest-&gt;as_xmm_float_reg(),
3848                ExternalAddress((address)float_signflip_pool));
3849     }
3850   } else if (dest-&gt;is_double_xmm()) {
3851 #ifdef _LP64
3852     if (UseAVX &gt; 2 &amp;&amp; !VM_Version::supports_avx512vl()) {
3853       assert(tmp-&gt;is_valid(), &quot;need temporary&quot;);
3854       assert_different_registers(left-&gt;as_xmm_double_reg(), tmp-&gt;as_xmm_double_reg());
3855       __ vpxor(dest-&gt;as_xmm_double_reg(), tmp-&gt;as_xmm_double_reg(), left-&gt;as_xmm_double_reg(), 2);
3856     }
3857     else
3858 #endif
3859     {
3860       assert(!tmp-&gt;is_valid(), &quot;do not need temporary&quot;);
3861       if (left-&gt;as_xmm_double_reg() != dest-&gt;as_xmm_double_reg()) {
3862         __ movdbl(dest-&gt;as_xmm_double_reg(), left-&gt;as_xmm_double_reg());
3863       }
3864       __ xorpd(dest-&gt;as_xmm_double_reg(),
3865                ExternalAddress((address)double_signflip_pool));
3866     }
3867 #ifndef _LP64
3868   } else if (left-&gt;is_single_fpu() || left-&gt;is_double_fpu()) {
3869     assert(left-&gt;fpu() == 0, &quot;arg must be on TOS&quot;);
3870     assert(dest-&gt;fpu() == 0, &quot;dest must be TOS&quot;);
3871     __ fchs();
3872 #endif // !_LP64
3873 
3874   } else {
3875     ShouldNotReachHere();
3876   }
3877 }
3878 
3879 
3880 void LIR_Assembler::leal(LIR_Opr src, LIR_Opr dest, LIR_PatchCode patch_code, CodeEmitInfo* info) {
3881   assert(src-&gt;is_address(), &quot;must be an address&quot;);
3882   assert(dest-&gt;is_register(), &quot;must be a register&quot;);
3883 
3884   PatchingStub* patch = NULL;
3885   if (patch_code != lir_patch_none) {
3886     patch = new PatchingStub(_masm, PatchingStub::access_field_id);
3887   }
3888 
3889   Register reg = dest-&gt;as_pointer_register();
3890   LIR_Address* addr = src-&gt;as_address_ptr();
3891   __ lea(reg, as_Address(addr));
3892 
3893   if (patch != NULL) {
3894     patching_epilog(patch, patch_code, addr-&gt;base()-&gt;as_register(), info);
3895   }
3896 }
3897 
3898 
3899 
3900 void LIR_Assembler::rt_call(LIR_Opr result, address dest, const LIR_OprList* args, LIR_Opr tmp, CodeEmitInfo* info) {
3901   assert(!tmp-&gt;is_valid(), &quot;don&#39;t need temporary&quot;);
3902   __ call(RuntimeAddress(dest));
3903   if (info != NULL) {
3904     add_call_info_here(info);
3905   }
3906 }
3907 
3908 
3909 void LIR_Assembler::volatile_move_op(LIR_Opr src, LIR_Opr dest, BasicType type, CodeEmitInfo* info) {
3910   assert(type == T_LONG, &quot;only for volatile long fields&quot;);
3911 
3912   if (info != NULL) {
3913     add_debug_info_for_null_check_here(info);
3914   }
3915 
3916   if (src-&gt;is_double_xmm()) {
3917     if (dest-&gt;is_double_cpu()) {
3918 #ifdef _LP64
3919       __ movdq(dest-&gt;as_register_lo(), src-&gt;as_xmm_double_reg());
3920 #else
3921       __ movdl(dest-&gt;as_register_lo(), src-&gt;as_xmm_double_reg());
3922       __ psrlq(src-&gt;as_xmm_double_reg(), 32);
3923       __ movdl(dest-&gt;as_register_hi(), src-&gt;as_xmm_double_reg());
3924 #endif // _LP64
3925     } else if (dest-&gt;is_double_stack()) {
3926       __ movdbl(frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix()), src-&gt;as_xmm_double_reg());
3927     } else if (dest-&gt;is_address()) {
3928       __ movdbl(as_Address(dest-&gt;as_address_ptr()), src-&gt;as_xmm_double_reg());
3929     } else {
3930       ShouldNotReachHere();
3931     }
3932 
3933   } else if (dest-&gt;is_double_xmm()) {
3934     if (src-&gt;is_double_stack()) {
3935       __ movdbl(dest-&gt;as_xmm_double_reg(), frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix()));
3936     } else if (src-&gt;is_address()) {
3937       __ movdbl(dest-&gt;as_xmm_double_reg(), as_Address(src-&gt;as_address_ptr()));
3938     } else {
3939       ShouldNotReachHere();
3940     }
3941 
3942 #ifndef _LP64
3943   } else if (src-&gt;is_double_fpu()) {
3944     assert(src-&gt;fpu_regnrLo() == 0, &quot;must be TOS&quot;);
3945     if (dest-&gt;is_double_stack()) {
3946       __ fistp_d(frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix()));
3947     } else if (dest-&gt;is_address()) {
3948       __ fistp_d(as_Address(dest-&gt;as_address_ptr()));
3949     } else {
3950       ShouldNotReachHere();
3951     }
3952 
3953   } else if (dest-&gt;is_double_fpu()) {
3954     assert(dest-&gt;fpu_regnrLo() == 0, &quot;must be TOS&quot;);
3955     if (src-&gt;is_double_stack()) {
3956       __ fild_d(frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix()));
3957     } else if (src-&gt;is_address()) {
3958       __ fild_d(as_Address(src-&gt;as_address_ptr()));
3959     } else {
3960       ShouldNotReachHere();
3961     }
3962 #endif // !_LP64
3963 
3964   } else {
3965     ShouldNotReachHere();
3966   }
3967 }
3968 
3969 #ifdef ASSERT
3970 // emit run-time assertion
3971 void LIR_Assembler::emit_assert(LIR_OpAssert* op) {
3972   assert(op-&gt;code() == lir_assert, &quot;must be&quot;);
3973 
3974   if (op-&gt;in_opr1()-&gt;is_valid()) {
3975     assert(op-&gt;in_opr2()-&gt;is_valid(), &quot;both operands must be valid&quot;);
3976     comp_op(op-&gt;condition(), op-&gt;in_opr1(), op-&gt;in_opr2(), op);
3977   } else {
3978     assert(op-&gt;in_opr2()-&gt;is_illegal(), &quot;both operands must be illegal&quot;);
3979     assert(op-&gt;condition() == lir_cond_always, &quot;no other conditions allowed&quot;);
3980   }
3981 
3982   Label ok;
3983   if (op-&gt;condition() != lir_cond_always) {
3984     Assembler::Condition acond = Assembler::zero;
3985     switch (op-&gt;condition()) {
3986       case lir_cond_equal:        acond = Assembler::equal;       break;
3987       case lir_cond_notEqual:     acond = Assembler::notEqual;    break;
3988       case lir_cond_less:         acond = Assembler::less;        break;
3989       case lir_cond_lessEqual:    acond = Assembler::lessEqual;   break;
3990       case lir_cond_greaterEqual: acond = Assembler::greaterEqual;break;
3991       case lir_cond_greater:      acond = Assembler::greater;     break;
3992       case lir_cond_belowEqual:   acond = Assembler::belowEqual;  break;
3993       case lir_cond_aboveEqual:   acond = Assembler::aboveEqual;  break;
3994       default:                    ShouldNotReachHere();
3995     }
3996     __ jcc(acond, ok);
3997   }
3998   if (op-&gt;halt()) {
3999     const char* str = __ code_string(op-&gt;msg());
4000     __ stop(str);
4001   } else {
4002     breakpoint();
4003   }
4004   __ bind(ok);
4005 }
4006 #endif
4007 
4008 void LIR_Assembler::membar() {
4009   // QQQ sparc TSO uses this,
4010   __ membar( Assembler::Membar_mask_bits(Assembler::StoreLoad));
4011 }
4012 
4013 void LIR_Assembler::membar_acquire() {
4014   // No x86 machines currently require load fences
4015 }
4016 
4017 void LIR_Assembler::membar_release() {
4018   // No x86 machines currently require store fences
4019 }
4020 
4021 void LIR_Assembler::membar_loadload() {
4022   // no-op
4023   //__ membar(Assembler::Membar_mask_bits(Assembler::loadload));
4024 }
4025 
4026 void LIR_Assembler::membar_storestore() {
4027   // no-op
4028   //__ membar(Assembler::Membar_mask_bits(Assembler::storestore));
4029 }
4030 
4031 void LIR_Assembler::membar_loadstore() {
4032   // no-op
4033   //__ membar(Assembler::Membar_mask_bits(Assembler::loadstore));
4034 }
4035 
4036 void LIR_Assembler::membar_storeload() {
4037   __ membar(Assembler::Membar_mask_bits(Assembler::StoreLoad));
4038 }
4039 
4040 void LIR_Assembler::on_spin_wait() {
4041   __ pause ();
4042 }
4043 
4044 void LIR_Assembler::get_thread(LIR_Opr result_reg) {
4045   assert(result_reg-&gt;is_register(), &quot;check&quot;);
4046 #ifdef _LP64
4047   // __ get_thread(result_reg-&gt;as_register_lo());
4048   __ mov(result_reg-&gt;as_register(), r15_thread);
4049 #else
4050   __ get_thread(result_reg-&gt;as_register());
4051 #endif // _LP64
4052 }
4053 
4054 
4055 void LIR_Assembler::peephole(LIR_List*) {
4056   // do nothing for now
4057 }
4058 
4059 void LIR_Assembler::atomic_op(LIR_Code code, LIR_Opr src, LIR_Opr data, LIR_Opr dest, LIR_Opr tmp) {
4060   assert(data == dest, &quot;xchg/xadd uses only 2 operands&quot;);
4061 
4062   if (data-&gt;type() == T_INT) {
4063     if (code == lir_xadd) {
4064       __ lock();
4065       __ xaddl(as_Address(src-&gt;as_address_ptr()), data-&gt;as_register());
4066     } else {
4067       __ xchgl(data-&gt;as_register(), as_Address(src-&gt;as_address_ptr()));
4068     }
4069   } else if (data-&gt;is_oop()) {
4070     assert (code == lir_xchg, &quot;xadd for oops&quot;);
4071     Register obj = data-&gt;as_register();
4072 #ifdef _LP64
4073     if (UseCompressedOops) {
4074       __ encode_heap_oop(obj);
4075       __ xchgl(obj, as_Address(src-&gt;as_address_ptr()));
4076       __ decode_heap_oop(obj);
4077     } else {
4078       __ xchgptr(obj, as_Address(src-&gt;as_address_ptr()));
4079     }
4080 #else
4081     __ xchgl(obj, as_Address(src-&gt;as_address_ptr()));
4082 #endif
4083   } else if (data-&gt;type() == T_LONG) {
4084 #ifdef _LP64
4085     assert(data-&gt;as_register_lo() == data-&gt;as_register_hi(), &quot;should be a single register&quot;);
4086     if (code == lir_xadd) {
4087       __ lock();
4088       __ xaddq(as_Address(src-&gt;as_address_ptr()), data-&gt;as_register_lo());
4089     } else {
4090       __ xchgq(data-&gt;as_register_lo(), as_Address(src-&gt;as_address_ptr()));
4091     }
4092 #else
4093     ShouldNotReachHere();
4094 #endif
4095   } else {
4096     ShouldNotReachHere();
4097   }
4098 }
4099 
4100 #undef __
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
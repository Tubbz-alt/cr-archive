<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/macroAssembler_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmciCodeInstaller_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_x86.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/macroAssembler_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   32 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
   33 #include &quot;interpreter/interpreter.hpp&quot;
   34 #include &quot;memory/resourceArea.hpp&quot;
   35 #include &quot;memory/universe.hpp&quot;
   36 #include &quot;oops/accessDecorators.hpp&quot;
   37 #include &quot;oops/compressedOops.inline.hpp&quot;
   38 #include &quot;oops/klass.inline.hpp&quot;
   39 #include &quot;prims/methodHandles.hpp&quot;
   40 #include &quot;runtime/biasedLocking.hpp&quot;
   41 #include &quot;runtime/flags/flagSetting.hpp&quot;
   42 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
   43 #include &quot;runtime/objectMonitor.hpp&quot;
   44 #include &quot;runtime/os.hpp&quot;
   45 #include &quot;runtime/safepoint.hpp&quot;
   46 #include &quot;runtime/safepointMechanism.hpp&quot;
   47 #include &quot;runtime/sharedRuntime.hpp&quot;
   48 #include &quot;runtime/stubRoutines.hpp&quot;
   49 #include &quot;runtime/thread.hpp&quot;
   50 #include &quot;utilities/macros.hpp&quot;
   51 #include &quot;crc32c.h&quot;
<span class="line-removed">   52 #ifdef COMPILER2</span>
<span class="line-removed">   53 #include &quot;opto/intrinsicnode.hpp&quot;</span>
<span class="line-removed">   54 #endif</span>
   55 
   56 #ifdef PRODUCT
   57 #define BLOCK_COMMENT(str) /* nothing */
   58 #define STOP(error) stop(error)
   59 #else
   60 #define BLOCK_COMMENT(str) block_comment(str)
   61 #define STOP(error) block_comment(error); stop(error)
   62 #endif
   63 
   64 #define BIND(label) bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
   65 
   66 #ifdef ASSERT
   67 bool AbstractAssembler::pd_check_instruction_mark() { return true; }
   68 #endif
   69 
   70 static Assembler::Condition reverse[] = {
   71     Assembler::noOverflow     /* overflow      = 0x0 */ ,
   72     Assembler::overflow       /* noOverflow    = 0x1 */ ,
   73     Assembler::aboveEqual     /* carrySet      = 0x2, below         = 0x2 */ ,
   74     Assembler::below          /* aboveEqual    = 0x3, carryClear    = 0x3 */ ,
</pre>
<hr />
<pre>
 1266   bind(cas_label);
 1267 
 1268   return null_check_offset;
 1269 }
 1270 
 1271 void MacroAssembler::biased_locking_exit(Register obj_reg, Register temp_reg, Label&amp; done) {
 1272   assert(UseBiasedLocking, &quot;why call this otherwise?&quot;);
 1273 
 1274   // Check for biased locking unlock case, which is a no-op
 1275   // Note: we do not have to check the thread ID for two reasons.
 1276   // First, the interpreter checks for IllegalMonitorStateException at
 1277   // a higher level. Second, if the bias was revoked while we held the
 1278   // lock, the object could not be rebiased toward another thread, so
 1279   // the bias bit would be clear.
 1280   movptr(temp_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));
 1281   andptr(temp_reg, markWord::biased_lock_mask_in_place);
 1282   cmpptr(temp_reg, markWord::biased_lock_pattern);
 1283   jcc(Assembler::equal, done);
 1284 }
 1285 
<span class="line-removed"> 1286 #ifdef COMPILER2</span>
<span class="line-removed"> 1287 </span>
<span class="line-removed"> 1288 #if INCLUDE_RTM_OPT</span>
<span class="line-removed"> 1289 </span>
<span class="line-removed"> 1290 // Update rtm_counters based on abort status</span>
<span class="line-removed"> 1291 // input: abort_status</span>
<span class="line-removed"> 1292 //        rtm_counters (RTMLockingCounters*)</span>
<span class="line-removed"> 1293 // flags are killed</span>
<span class="line-removed"> 1294 void MacroAssembler::rtm_counters_update(Register abort_status, Register rtm_counters) {</span>
<span class="line-removed"> 1295 </span>
<span class="line-removed"> 1296   atomic_incptr(Address(rtm_counters, RTMLockingCounters::abort_count_offset()));</span>
<span class="line-removed"> 1297   if (PrintPreciseRTMLockingStatistics) {</span>
<span class="line-removed"> 1298     for (int i = 0; i &lt; RTMLockingCounters::ABORT_STATUS_LIMIT; i++) {</span>
<span class="line-removed"> 1299       Label check_abort;</span>
<span class="line-removed"> 1300       testl(abort_status, (1&lt;&lt;i));</span>
<span class="line-removed"> 1301       jccb(Assembler::equal, check_abort);</span>
<span class="line-removed"> 1302       atomic_incptr(Address(rtm_counters, RTMLockingCounters::abortX_count_offset() + (i * sizeof(uintx))));</span>
<span class="line-removed"> 1303       bind(check_abort);</span>
<span class="line-removed"> 1304     }</span>
<span class="line-removed"> 1305   }</span>
<span class="line-removed"> 1306 }</span>
<span class="line-removed"> 1307 </span>
<span class="line-removed"> 1308 // Branch if (random &amp; (count-1) != 0), count is 2^n</span>
<span class="line-removed"> 1309 // tmp, scr and flags are killed</span>
<span class="line-removed"> 1310 void MacroAssembler::branch_on_random_using_rdtsc(Register tmp, Register scr, int count, Label&amp; brLabel) {</span>
<span class="line-removed"> 1311   assert(tmp == rax, &quot;&quot;);</span>
<span class="line-removed"> 1312   assert(scr == rdx, &quot;&quot;);</span>
<span class="line-removed"> 1313   rdtsc(); // modifies EDX:EAX</span>
<span class="line-removed"> 1314   andptr(tmp, count-1);</span>
<span class="line-removed"> 1315   jccb(Assembler::notZero, brLabel);</span>
<span class="line-removed"> 1316 }</span>
<span class="line-removed"> 1317 </span>
<span class="line-removed"> 1318 // Perform abort ratio calculation, set no_rtm bit if high ratio</span>
<span class="line-removed"> 1319 // input:  rtm_counters_Reg (RTMLockingCounters* address)</span>
<span class="line-removed"> 1320 // tmpReg, rtm_counters_Reg and flags are killed</span>
<span class="line-removed"> 1321 void MacroAssembler::rtm_abort_ratio_calculation(Register tmpReg,</span>
<span class="line-removed"> 1322                                                  Register rtm_counters_Reg,</span>
<span class="line-removed"> 1323                                                  RTMLockingCounters* rtm_counters,</span>
<span class="line-removed"> 1324                                                  Metadata* method_data) {</span>
<span class="line-removed"> 1325   Label L_done, L_check_always_rtm1, L_check_always_rtm2;</span>
<span class="line-removed"> 1326 </span>
<span class="line-removed"> 1327   if (RTMLockingCalculationDelay &gt; 0) {</span>
<span class="line-removed"> 1328     // Delay calculation</span>
<span class="line-removed"> 1329     movptr(tmpReg, ExternalAddress((address) RTMLockingCounters::rtm_calculation_flag_addr()), tmpReg);</span>
<span class="line-removed"> 1330     testptr(tmpReg, tmpReg);</span>
<span class="line-removed"> 1331     jccb(Assembler::equal, L_done);</span>
<span class="line-removed"> 1332   }</span>
<span class="line-removed"> 1333   // Abort ratio calculation only if abort_count &gt; RTMAbortThreshold</span>
<span class="line-removed"> 1334   //   Aborted transactions = abort_count * 100</span>
<span class="line-removed"> 1335   //   All transactions = total_count *  RTMTotalCountIncrRate</span>
<span class="line-removed"> 1336   //   Set no_rtm bit if (Aborted transactions &gt;= All transactions * RTMAbortRatio)</span>
<span class="line-removed"> 1337 </span>
<span class="line-removed"> 1338   movptr(tmpReg, Address(rtm_counters_Reg, RTMLockingCounters::abort_count_offset()));</span>
<span class="line-removed"> 1339   cmpptr(tmpReg, RTMAbortThreshold);</span>
<span class="line-removed"> 1340   jccb(Assembler::below, L_check_always_rtm2);</span>
<span class="line-removed"> 1341   imulptr(tmpReg, tmpReg, 100);</span>
<span class="line-removed"> 1342 </span>
<span class="line-removed"> 1343   Register scrReg = rtm_counters_Reg;</span>
<span class="line-removed"> 1344   movptr(scrReg, Address(rtm_counters_Reg, RTMLockingCounters::total_count_offset()));</span>
<span class="line-removed"> 1345   imulptr(scrReg, scrReg, RTMTotalCountIncrRate);</span>
<span class="line-removed"> 1346   imulptr(scrReg, scrReg, RTMAbortRatio);</span>
<span class="line-removed"> 1347   cmpptr(tmpReg, scrReg);</span>
<span class="line-removed"> 1348   jccb(Assembler::below, L_check_always_rtm1);</span>
<span class="line-removed"> 1349   if (method_data != NULL) {</span>
<span class="line-removed"> 1350     // set rtm_state to &quot;no rtm&quot; in MDO</span>
<span class="line-removed"> 1351     mov_metadata(tmpReg, method_data);</span>
<span class="line-removed"> 1352     lock();</span>
<span class="line-removed"> 1353     orl(Address(tmpReg, MethodData::rtm_state_offset_in_bytes()), NoRTM);</span>
<span class="line-removed"> 1354   }</span>
<span class="line-removed"> 1355   jmpb(L_done);</span>
<span class="line-removed"> 1356   bind(L_check_always_rtm1);</span>
<span class="line-removed"> 1357   // Reload RTMLockingCounters* address</span>
<span class="line-removed"> 1358   lea(rtm_counters_Reg, ExternalAddress((address)rtm_counters));</span>
<span class="line-removed"> 1359   bind(L_check_always_rtm2);</span>
<span class="line-removed"> 1360   movptr(tmpReg, Address(rtm_counters_Reg, RTMLockingCounters::total_count_offset()));</span>
<span class="line-removed"> 1361   cmpptr(tmpReg, RTMLockingThreshold / RTMTotalCountIncrRate);</span>
<span class="line-removed"> 1362   jccb(Assembler::below, L_done);</span>
<span class="line-removed"> 1363   if (method_data != NULL) {</span>
<span class="line-removed"> 1364     // set rtm_state to &quot;always rtm&quot; in MDO</span>
<span class="line-removed"> 1365     mov_metadata(tmpReg, method_data);</span>
<span class="line-removed"> 1366     lock();</span>
<span class="line-removed"> 1367     orl(Address(tmpReg, MethodData::rtm_state_offset_in_bytes()), UseRTM);</span>
<span class="line-removed"> 1368   }</span>
<span class="line-removed"> 1369   bind(L_done);</span>
<span class="line-removed"> 1370 }</span>
<span class="line-removed"> 1371 </span>
<span class="line-removed"> 1372 // Update counters and perform abort ratio calculation</span>
<span class="line-removed"> 1373 // input:  abort_status_Reg</span>
<span class="line-removed"> 1374 // rtm_counters_Reg, flags are killed</span>
<span class="line-removed"> 1375 void MacroAssembler::rtm_profiling(Register abort_status_Reg,</span>
<span class="line-removed"> 1376                                    Register rtm_counters_Reg,</span>
<span class="line-removed"> 1377                                    RTMLockingCounters* rtm_counters,</span>
<span class="line-removed"> 1378                                    Metadata* method_data,</span>
<span class="line-removed"> 1379                                    bool profile_rtm) {</span>
<span class="line-removed"> 1380 </span>
<span class="line-removed"> 1381   assert(rtm_counters != NULL, &quot;should not be NULL when profiling RTM&quot;);</span>
<span class="line-removed"> 1382   // update rtm counters based on rax value at abort</span>
<span class="line-removed"> 1383   // reads abort_status_Reg, updates flags</span>
<span class="line-removed"> 1384   lea(rtm_counters_Reg, ExternalAddress((address)rtm_counters));</span>
<span class="line-removed"> 1385   rtm_counters_update(abort_status_Reg, rtm_counters_Reg);</span>
<span class="line-removed"> 1386   if (profile_rtm) {</span>
<span class="line-removed"> 1387     // Save abort status because abort_status_Reg is used by following code.</span>
<span class="line-removed"> 1388     if (RTMRetryCount &gt; 0) {</span>
<span class="line-removed"> 1389       push(abort_status_Reg);</span>
<span class="line-removed"> 1390     }</span>
<span class="line-removed"> 1391     assert(rtm_counters != NULL, &quot;should not be NULL when profiling RTM&quot;);</span>
<span class="line-removed"> 1392     rtm_abort_ratio_calculation(abort_status_Reg, rtm_counters_Reg, rtm_counters, method_data);</span>
<span class="line-removed"> 1393     // restore abort status</span>
<span class="line-removed"> 1394     if (RTMRetryCount &gt; 0) {</span>
<span class="line-removed"> 1395       pop(abort_status_Reg);</span>
<span class="line-removed"> 1396     }</span>
<span class="line-removed"> 1397   }</span>
<span class="line-removed"> 1398 }</span>
<span class="line-removed"> 1399 </span>
<span class="line-removed"> 1400 // Retry on abort if abort&#39;s status is 0x6: can retry (0x2) | memory conflict (0x4)</span>
<span class="line-removed"> 1401 // inputs: retry_count_Reg</span>
<span class="line-removed"> 1402 //       : abort_status_Reg</span>
<span class="line-removed"> 1403 // output: retry_count_Reg decremented by 1</span>
<span class="line-removed"> 1404 // flags are killed</span>
<span class="line-removed"> 1405 void MacroAssembler::rtm_retry_lock_on_abort(Register retry_count_Reg, Register abort_status_Reg, Label&amp; retryLabel) {</span>
<span class="line-removed"> 1406   Label doneRetry;</span>
<span class="line-removed"> 1407   assert(abort_status_Reg == rax, &quot;&quot;);</span>
<span class="line-removed"> 1408   // The abort reason bits are in eax (see all states in rtmLocking.hpp)</span>
<span class="line-removed"> 1409   // 0x6 = conflict on which we can retry (0x2) | memory conflict (0x4)</span>
<span class="line-removed"> 1410   // if reason is in 0x6 and retry count != 0 then retry</span>
<span class="line-removed"> 1411   andptr(abort_status_Reg, 0x6);</span>
<span class="line-removed"> 1412   jccb(Assembler::zero, doneRetry);</span>
<span class="line-removed"> 1413   testl(retry_count_Reg, retry_count_Reg);</span>
<span class="line-removed"> 1414   jccb(Assembler::zero, doneRetry);</span>
<span class="line-removed"> 1415   pause();</span>
<span class="line-removed"> 1416   decrementl(retry_count_Reg);</span>
<span class="line-removed"> 1417   jmp(retryLabel);</span>
<span class="line-removed"> 1418   bind(doneRetry);</span>
<span class="line-removed"> 1419 }</span>
<span class="line-removed"> 1420 </span>
<span class="line-removed"> 1421 // Spin and retry if lock is busy,</span>
<span class="line-removed"> 1422 // inputs: box_Reg (monitor address)</span>
<span class="line-removed"> 1423 //       : retry_count_Reg</span>
<span class="line-removed"> 1424 // output: retry_count_Reg decremented by 1</span>
<span class="line-removed"> 1425 //       : clear z flag if retry count exceeded</span>
<span class="line-removed"> 1426 // tmp_Reg, scr_Reg, flags are killed</span>
<span class="line-removed"> 1427 void MacroAssembler::rtm_retry_lock_on_busy(Register retry_count_Reg, Register box_Reg,</span>
<span class="line-removed"> 1428                                             Register tmp_Reg, Register scr_Reg, Label&amp; retryLabel) {</span>
<span class="line-removed"> 1429   Label SpinLoop, SpinExit, doneRetry;</span>
<span class="line-removed"> 1430   int owner_offset = OM_OFFSET_NO_MONITOR_VALUE_TAG(owner);</span>
<span class="line-removed"> 1431 </span>
<span class="line-removed"> 1432   testl(retry_count_Reg, retry_count_Reg);</span>
<span class="line-removed"> 1433   jccb(Assembler::zero, doneRetry);</span>
<span class="line-removed"> 1434   decrementl(retry_count_Reg);</span>
<span class="line-removed"> 1435   movptr(scr_Reg, RTMSpinLoopCount);</span>
<span class="line-removed"> 1436 </span>
<span class="line-removed"> 1437   bind(SpinLoop);</span>
<span class="line-removed"> 1438   pause();</span>
<span class="line-removed"> 1439   decrementl(scr_Reg);</span>
<span class="line-removed"> 1440   jccb(Assembler::lessEqual, SpinExit);</span>
<span class="line-removed"> 1441   movptr(tmp_Reg, Address(box_Reg, owner_offset));</span>
<span class="line-removed"> 1442   testptr(tmp_Reg, tmp_Reg);</span>
<span class="line-removed"> 1443   jccb(Assembler::notZero, SpinLoop);</span>
<span class="line-removed"> 1444 </span>
<span class="line-removed"> 1445   bind(SpinExit);</span>
<span class="line-removed"> 1446   jmp(retryLabel);</span>
<span class="line-removed"> 1447   bind(doneRetry);</span>
<span class="line-removed"> 1448   incrementl(retry_count_Reg); // clear z flag</span>
<span class="line-removed"> 1449 }</span>
<span class="line-removed"> 1450 </span>
<span class="line-removed"> 1451 // Use RTM for normal stack locks</span>
<span class="line-removed"> 1452 // Input: objReg (object to lock)</span>
<span class="line-removed"> 1453 void MacroAssembler::rtm_stack_locking(Register objReg, Register tmpReg, Register scrReg,</span>
<span class="line-removed"> 1454                                        Register retry_on_abort_count_Reg,</span>
<span class="line-removed"> 1455                                        RTMLockingCounters* stack_rtm_counters,</span>
<span class="line-removed"> 1456                                        Metadata* method_data, bool profile_rtm,</span>
<span class="line-removed"> 1457                                        Label&amp; DONE_LABEL, Label&amp; IsInflated) {</span>
<span class="line-removed"> 1458   assert(UseRTMForStackLocks, &quot;why call this otherwise?&quot;);</span>
<span class="line-removed"> 1459   assert(!UseBiasedLocking, &quot;Biased locking is not supported with RTM locking&quot;);</span>
<span class="line-removed"> 1460   assert(tmpReg == rax, &quot;&quot;);</span>
<span class="line-removed"> 1461   assert(scrReg == rdx, &quot;&quot;);</span>
<span class="line-removed"> 1462   Label L_rtm_retry, L_decrement_retry, L_on_abort;</span>
<span class="line-removed"> 1463 </span>
<span class="line-removed"> 1464   if (RTMRetryCount &gt; 0) {</span>
<span class="line-removed"> 1465     movl(retry_on_abort_count_Reg, RTMRetryCount); // Retry on abort</span>
<span class="line-removed"> 1466     bind(L_rtm_retry);</span>
<span class="line-removed"> 1467   }</span>
<span class="line-removed"> 1468   movptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes()));</span>
<span class="line-removed"> 1469   testptr(tmpReg, markWord::monitor_value);  // inflated vs stack-locked|neutral|biased</span>
<span class="line-removed"> 1470   jcc(Assembler::notZero, IsInflated);</span>
<span class="line-removed"> 1471 </span>
<span class="line-removed"> 1472   if (PrintPreciseRTMLockingStatistics || profile_rtm) {</span>
<span class="line-removed"> 1473     Label L_noincrement;</span>
<span class="line-removed"> 1474     if (RTMTotalCountIncrRate &gt; 1) {</span>
<span class="line-removed"> 1475       // tmpReg, scrReg and flags are killed</span>
<span class="line-removed"> 1476       branch_on_random_using_rdtsc(tmpReg, scrReg, RTMTotalCountIncrRate, L_noincrement);</span>
<span class="line-removed"> 1477     }</span>
<span class="line-removed"> 1478     assert(stack_rtm_counters != NULL, &quot;should not be NULL when profiling RTM&quot;);</span>
<span class="line-removed"> 1479     atomic_incptr(ExternalAddress((address)stack_rtm_counters-&gt;total_count_addr()), scrReg);</span>
<span class="line-removed"> 1480     bind(L_noincrement);</span>
<span class="line-removed"> 1481   }</span>
<span class="line-removed"> 1482   xbegin(L_on_abort);</span>
<span class="line-removed"> 1483   movptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes()));       // fetch markword</span>
<span class="line-removed"> 1484   andptr(tmpReg, markWord::biased_lock_mask_in_place); // look at 3 lock bits</span>
<span class="line-removed"> 1485   cmpptr(tmpReg, markWord::unlocked_value);            // bits = 001 unlocked</span>
<span class="line-removed"> 1486   jcc(Assembler::equal, DONE_LABEL);        // all done if unlocked</span>
<span class="line-removed"> 1487 </span>
<span class="line-removed"> 1488   Register abort_status_Reg = tmpReg; // status of abort is stored in RAX</span>
<span class="line-removed"> 1489   if (UseRTMXendForLockBusy) {</span>
<span class="line-removed"> 1490     xend();</span>
<span class="line-removed"> 1491     movptr(abort_status_Reg, 0x2);   // Set the abort status to 2 (so we can retry)</span>
<span class="line-removed"> 1492     jmp(L_decrement_retry);</span>
<span class="line-removed"> 1493   }</span>
<span class="line-removed"> 1494   else {</span>
<span class="line-removed"> 1495     xabort(0);</span>
<span class="line-removed"> 1496   }</span>
<span class="line-removed"> 1497   bind(L_on_abort);</span>
<span class="line-removed"> 1498   if (PrintPreciseRTMLockingStatistics || profile_rtm) {</span>
<span class="line-removed"> 1499     rtm_profiling(abort_status_Reg, scrReg, stack_rtm_counters, method_data, profile_rtm);</span>
<span class="line-removed"> 1500   }</span>
<span class="line-removed"> 1501   bind(L_decrement_retry);</span>
<span class="line-removed"> 1502   if (RTMRetryCount &gt; 0) {</span>
<span class="line-removed"> 1503     // retry on lock abort if abort status is &#39;can retry&#39; (0x2) or &#39;memory conflict&#39; (0x4)</span>
<span class="line-removed"> 1504     rtm_retry_lock_on_abort(retry_on_abort_count_Reg, abort_status_Reg, L_rtm_retry);</span>
<span class="line-removed"> 1505   }</span>
<span class="line-removed"> 1506 }</span>
<span class="line-removed"> 1507 </span>
<span class="line-removed"> 1508 // Use RTM for inflating locks</span>
<span class="line-removed"> 1509 // inputs: objReg (object to lock)</span>
<span class="line-removed"> 1510 //         boxReg (on-stack box address (displaced header location) - KILLED)</span>
<span class="line-removed"> 1511 //         tmpReg (ObjectMonitor address + markWord::monitor_value)</span>
<span class="line-removed"> 1512 void MacroAssembler::rtm_inflated_locking(Register objReg, Register boxReg, Register tmpReg,</span>
<span class="line-removed"> 1513                                           Register scrReg, Register retry_on_busy_count_Reg,</span>
<span class="line-removed"> 1514                                           Register retry_on_abort_count_Reg,</span>
<span class="line-removed"> 1515                                           RTMLockingCounters* rtm_counters,</span>
<span class="line-removed"> 1516                                           Metadata* method_data, bool profile_rtm,</span>
<span class="line-removed"> 1517                                           Label&amp; DONE_LABEL) {</span>
<span class="line-removed"> 1518   assert(UseRTMLocking, &quot;why call this otherwise?&quot;);</span>
<span class="line-removed"> 1519   assert(tmpReg == rax, &quot;&quot;);</span>
<span class="line-removed"> 1520   assert(scrReg == rdx, &quot;&quot;);</span>
<span class="line-removed"> 1521   Label L_rtm_retry, L_decrement_retry, L_on_abort;</span>
<span class="line-removed"> 1522   int owner_offset = OM_OFFSET_NO_MONITOR_VALUE_TAG(owner);</span>
<span class="line-removed"> 1523 </span>
<span class="line-removed"> 1524   // Without cast to int32_t this style of movptr will destroy r10 which is typically obj.</span>
<span class="line-removed"> 1525   movptr(Address(boxReg, 0), (int32_t)intptr_t(markWord::unused_mark().value()));</span>
<span class="line-removed"> 1526   movptr(boxReg, tmpReg); // Save ObjectMonitor address</span>
<span class="line-removed"> 1527 </span>
<span class="line-removed"> 1528   if (RTMRetryCount &gt; 0) {</span>
<span class="line-removed"> 1529     movl(retry_on_busy_count_Reg, RTMRetryCount);  // Retry on lock busy</span>
<span class="line-removed"> 1530     movl(retry_on_abort_count_Reg, RTMRetryCount); // Retry on abort</span>
<span class="line-removed"> 1531     bind(L_rtm_retry);</span>
<span class="line-removed"> 1532   }</span>
<span class="line-removed"> 1533   if (PrintPreciseRTMLockingStatistics || profile_rtm) {</span>
<span class="line-removed"> 1534     Label L_noincrement;</span>
<span class="line-removed"> 1535     if (RTMTotalCountIncrRate &gt; 1) {</span>
<span class="line-removed"> 1536       // tmpReg, scrReg and flags are killed</span>
<span class="line-removed"> 1537       branch_on_random_using_rdtsc(tmpReg, scrReg, RTMTotalCountIncrRate, L_noincrement);</span>
<span class="line-removed"> 1538     }</span>
<span class="line-removed"> 1539     assert(rtm_counters != NULL, &quot;should not be NULL when profiling RTM&quot;);</span>
<span class="line-removed"> 1540     atomic_incptr(ExternalAddress((address)rtm_counters-&gt;total_count_addr()), scrReg);</span>
<span class="line-removed"> 1541     bind(L_noincrement);</span>
<span class="line-removed"> 1542   }</span>
<span class="line-removed"> 1543   xbegin(L_on_abort);</span>
<span class="line-removed"> 1544   movptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes()));</span>
<span class="line-removed"> 1545   movptr(tmpReg, Address(tmpReg, owner_offset));</span>
<span class="line-removed"> 1546   testptr(tmpReg, tmpReg);</span>
<span class="line-removed"> 1547   jcc(Assembler::zero, DONE_LABEL);</span>
<span class="line-removed"> 1548   if (UseRTMXendForLockBusy) {</span>
<span class="line-removed"> 1549     xend();</span>
<span class="line-removed"> 1550     jmp(L_decrement_retry);</span>
<span class="line-removed"> 1551   }</span>
<span class="line-removed"> 1552   else {</span>
<span class="line-removed"> 1553     xabort(0);</span>
<span class="line-removed"> 1554   }</span>
<span class="line-removed"> 1555   bind(L_on_abort);</span>
<span class="line-removed"> 1556   Register abort_status_Reg = tmpReg; // status of abort is stored in RAX</span>
<span class="line-removed"> 1557   if (PrintPreciseRTMLockingStatistics || profile_rtm) {</span>
<span class="line-removed"> 1558     rtm_profiling(abort_status_Reg, scrReg, rtm_counters, method_data, profile_rtm);</span>
<span class="line-removed"> 1559   }</span>
<span class="line-removed"> 1560   if (RTMRetryCount &gt; 0) {</span>
<span class="line-removed"> 1561     // retry on lock abort if abort status is &#39;can retry&#39; (0x2) or &#39;memory conflict&#39; (0x4)</span>
<span class="line-removed"> 1562     rtm_retry_lock_on_abort(retry_on_abort_count_Reg, abort_status_Reg, L_rtm_retry);</span>
<span class="line-removed"> 1563   }</span>
<span class="line-removed"> 1564 </span>
<span class="line-removed"> 1565   movptr(tmpReg, Address(boxReg, owner_offset)) ;</span>
<span class="line-removed"> 1566   testptr(tmpReg, tmpReg) ;</span>
<span class="line-removed"> 1567   jccb(Assembler::notZero, L_decrement_retry) ;</span>
<span class="line-removed"> 1568 </span>
<span class="line-removed"> 1569   // Appears unlocked - try to swing _owner from null to non-null.</span>
<span class="line-removed"> 1570   // Invariant: tmpReg == 0.  tmpReg is EAX which is the implicit cmpxchg comparand.</span>
<span class="line-removed"> 1571 #ifdef _LP64</span>
<span class="line-removed"> 1572   Register threadReg = r15_thread;</span>
<span class="line-removed"> 1573 #else</span>
<span class="line-removed"> 1574   get_thread(scrReg);</span>
<span class="line-removed"> 1575   Register threadReg = scrReg;</span>
<span class="line-removed"> 1576 #endif</span>
<span class="line-removed"> 1577   lock();</span>
<span class="line-removed"> 1578   cmpxchgptr(threadReg, Address(boxReg, owner_offset)); // Updates tmpReg</span>
<span class="line-removed"> 1579 </span>
<span class="line-removed"> 1580   if (RTMRetryCount &gt; 0) {</span>
<span class="line-removed"> 1581     // success done else retry</span>
<span class="line-removed"> 1582     jccb(Assembler::equal, DONE_LABEL) ;</span>
<span class="line-removed"> 1583     bind(L_decrement_retry);</span>
<span class="line-removed"> 1584     // Spin and retry if lock is busy.</span>
<span class="line-removed"> 1585     rtm_retry_lock_on_busy(retry_on_busy_count_Reg, boxReg, tmpReg, scrReg, L_rtm_retry);</span>
<span class="line-removed"> 1586   }</span>
<span class="line-removed"> 1587   else {</span>
<span class="line-removed"> 1588     bind(L_decrement_retry);</span>
<span class="line-removed"> 1589   }</span>
<span class="line-removed"> 1590 }</span>
<span class="line-removed"> 1591 </span>
<span class="line-removed"> 1592 #endif //  INCLUDE_RTM_OPT</span>
<span class="line-removed"> 1593 </span>
<span class="line-removed"> 1594 // fast_lock and fast_unlock used by C2</span>
<span class="line-removed"> 1595 </span>
<span class="line-removed"> 1596 // Because the transitions from emitted code to the runtime</span>
<span class="line-removed"> 1597 // monitorenter/exit helper stubs are so slow it&#39;s critical that</span>
<span class="line-removed"> 1598 // we inline both the stack-locking fast path and the inflated fast path.</span>
<span class="line-removed"> 1599 //</span>
<span class="line-removed"> 1600 // See also: cmpFastLock and cmpFastUnlock.</span>
<span class="line-removed"> 1601 //</span>
<span class="line-removed"> 1602 // What follows is a specialized inline transliteration of the code</span>
<span class="line-removed"> 1603 // in enter() and exit(). If we&#39;re concerned about I$ bloat another</span>
<span class="line-removed"> 1604 // option would be to emit TrySlowEnter and TrySlowExit methods</span>
<span class="line-removed"> 1605 // at startup-time.  These methods would accept arguments as</span>
<span class="line-removed"> 1606 // (rax,=Obj, rbx=Self, rcx=box, rdx=Scratch) and return success-failure</span>
<span class="line-removed"> 1607 // indications in the icc.ZFlag.  fast_lock and fast_unlock would simply</span>
<span class="line-removed"> 1608 // marshal the arguments and emit calls to TrySlowEnter and TrySlowExit.</span>
<span class="line-removed"> 1609 // In practice, however, the # of lock sites is bounded and is usually small.</span>
<span class="line-removed"> 1610 // Besides the call overhead, TrySlowEnter and TrySlowExit might suffer</span>
<span class="line-removed"> 1611 // if the processor uses simple bimodal branch predictors keyed by EIP</span>
<span class="line-removed"> 1612 // Since the helper routines would be called from multiple synchronization</span>
<span class="line-removed"> 1613 // sites.</span>
<span class="line-removed"> 1614 //</span>
<span class="line-removed"> 1615 // An even better approach would be write &quot;MonitorEnter()&quot; and &quot;MonitorExit()&quot;</span>
<span class="line-removed"> 1616 // in java - using j.u.c and unsafe - and just bind the lock and unlock sites</span>
<span class="line-removed"> 1617 // to those specialized methods.  That&#39;d give us a mostly platform-independent</span>
<span class="line-removed"> 1618 // implementation that the JITs could optimize and inline at their pleasure.</span>
<span class="line-removed"> 1619 // Done correctly, the only time we&#39;d need to cross to native could would be</span>
<span class="line-removed"> 1620 // to park() or unpark() threads.  We&#39;d also need a few more unsafe operators</span>
<span class="line-removed"> 1621 // to (a) prevent compiler-JIT reordering of non-volatile accesses, and</span>
<span class="line-removed"> 1622 // (b) explicit barriers or fence operations.</span>
<span class="line-removed"> 1623 //</span>
<span class="line-removed"> 1624 // TODO:</span>
<span class="line-removed"> 1625 //</span>
<span class="line-removed"> 1626 // *  Arrange for C2 to pass &quot;Self&quot; into fast_lock and fast_unlock in one of the registers (scr).</span>
<span class="line-removed"> 1627 //    This avoids manifesting the Self pointer in the fast_lock and fast_unlock terminals.</span>
<span class="line-removed"> 1628 //    Given TLAB allocation, Self is usually manifested in a register, so passing it into</span>
<span class="line-removed"> 1629 //    the lock operators would typically be faster than reifying Self.</span>
<span class="line-removed"> 1630 //</span>
<span class="line-removed"> 1631 // *  Ideally I&#39;d define the primitives as:</span>
<span class="line-removed"> 1632 //       fast_lock   (nax Obj, nax box, EAX tmp, nax scr) where box, tmp and scr are KILLED.</span>
<span class="line-removed"> 1633 //       fast_unlock (nax Obj, EAX box, nax tmp) where box and tmp are KILLED</span>
<span class="line-removed"> 1634 //    Unfortunately ADLC bugs prevent us from expressing the ideal form.</span>
<span class="line-removed"> 1635 //    Instead, we&#39;re stuck with a rather awkward and brittle register assignments below.</span>
<span class="line-removed"> 1636 //    Furthermore the register assignments are overconstrained, possibly resulting in</span>
<span class="line-removed"> 1637 //    sub-optimal code near the synchronization site.</span>
<span class="line-removed"> 1638 //</span>
<span class="line-removed"> 1639 // *  Eliminate the sp-proximity tests and just use &quot;== Self&quot; tests instead.</span>
<span class="line-removed"> 1640 //    Alternately, use a better sp-proximity test.</span>
<span class="line-removed"> 1641 //</span>
<span class="line-removed"> 1642 // *  Currently ObjectMonitor._Owner can hold either an sp value or a (THREAD *) value.</span>
<span class="line-removed"> 1643 //    Either one is sufficient to uniquely identify a thread.</span>
<span class="line-removed"> 1644 //    TODO: eliminate use of sp in _owner and use get_thread(tr) instead.</span>
<span class="line-removed"> 1645 //</span>
<span class="line-removed"> 1646 // *  Intrinsify notify() and notifyAll() for the common cases where the</span>
<span class="line-removed"> 1647 //    object is locked by the calling thread but the waitlist is empty.</span>
<span class="line-removed"> 1648 //    avoid the expensive JNI call to JVM_Notify() and JVM_NotifyAll().</span>
<span class="line-removed"> 1649 //</span>
<span class="line-removed"> 1650 // *  use jccb and jmpb instead of jcc and jmp to improve code density.</span>
<span class="line-removed"> 1651 //    But beware of excessive branch density on AMD Opterons.</span>
<span class="line-removed"> 1652 //</span>
<span class="line-removed"> 1653 // *  Both fast_lock and fast_unlock set the ICC.ZF to indicate success</span>
<span class="line-removed"> 1654 //    or failure of the fast path.  If the fast path fails then we pass</span>
<span class="line-removed"> 1655 //    control to the slow path, typically in C.  In fast_lock and</span>
<span class="line-removed"> 1656 //    fast_unlock we often branch to DONE_LABEL, just to find that C2</span>
<span class="line-removed"> 1657 //    will emit a conditional branch immediately after the node.</span>
<span class="line-removed"> 1658 //    So we have branches to branches and lots of ICC.ZF games.</span>
<span class="line-removed"> 1659 //    Instead, it might be better to have C2 pass a &quot;FailureLabel&quot;</span>
<span class="line-removed"> 1660 //    into fast_lock and fast_unlock.  In the case of success, control</span>
<span class="line-removed"> 1661 //    will drop through the node.  ICC.ZF is undefined at exit.</span>
<span class="line-removed"> 1662 //    In the case of failure, the node will branch directly to the</span>
<span class="line-removed"> 1663 //    FailureLabel</span>
<span class="line-removed"> 1664 </span>
<span class="line-removed"> 1665 </span>
<span class="line-removed"> 1666 // obj: object to lock</span>
<span class="line-removed"> 1667 // box: on-stack box address (displaced header location) - KILLED</span>
<span class="line-removed"> 1668 // rax,: tmp -- KILLED</span>
<span class="line-removed"> 1669 // scr: tmp -- KILLED</span>
<span class="line-removed"> 1670 void MacroAssembler::fast_lock(Register objReg, Register boxReg, Register tmpReg,</span>
<span class="line-removed"> 1671                                Register scrReg, Register cx1Reg, Register cx2Reg,</span>
<span class="line-removed"> 1672                                BiasedLockingCounters* counters,</span>
<span class="line-removed"> 1673                                RTMLockingCounters* rtm_counters,</span>
<span class="line-removed"> 1674                                RTMLockingCounters* stack_rtm_counters,</span>
<span class="line-removed"> 1675                                Metadata* method_data,</span>
<span class="line-removed"> 1676                                bool use_rtm, bool profile_rtm) {</span>
<span class="line-removed"> 1677   // Ensure the register assignments are disjoint</span>
<span class="line-removed"> 1678   assert(tmpReg == rax, &quot;&quot;);</span>
<span class="line-removed"> 1679 </span>
<span class="line-removed"> 1680   if (use_rtm) {</span>
<span class="line-removed"> 1681     assert_different_registers(objReg, boxReg, tmpReg, scrReg, cx1Reg, cx2Reg);</span>
<span class="line-removed"> 1682   } else {</span>
<span class="line-removed"> 1683     assert(cx1Reg == noreg, &quot;&quot;);</span>
<span class="line-removed"> 1684     assert(cx2Reg == noreg, &quot;&quot;);</span>
<span class="line-removed"> 1685     assert_different_registers(objReg, boxReg, tmpReg, scrReg);</span>
<span class="line-removed"> 1686   }</span>
<span class="line-removed"> 1687 </span>
<span class="line-removed"> 1688   if (counters != NULL) {</span>
<span class="line-removed"> 1689     atomic_incl(ExternalAddress((address)counters-&gt;total_entry_count_addr()), scrReg);</span>
<span class="line-removed"> 1690   }</span>
<span class="line-removed"> 1691 </span>
<span class="line-removed"> 1692   // Possible cases that we&#39;ll encounter in fast_lock</span>
<span class="line-removed"> 1693   // ------------------------------------------------</span>
<span class="line-removed"> 1694   // * Inflated</span>
<span class="line-removed"> 1695   //    -- unlocked</span>
<span class="line-removed"> 1696   //    -- Locked</span>
<span class="line-removed"> 1697   //       = by self</span>
<span class="line-removed"> 1698   //       = by other</span>
<span class="line-removed"> 1699   // * biased</span>
<span class="line-removed"> 1700   //    -- by Self</span>
<span class="line-removed"> 1701   //    -- by other</span>
<span class="line-removed"> 1702   // * neutral</span>
<span class="line-removed"> 1703   // * stack-locked</span>
<span class="line-removed"> 1704   //    -- by self</span>
<span class="line-removed"> 1705   //       = sp-proximity test hits</span>
<span class="line-removed"> 1706   //       = sp-proximity test generates false-negative</span>
<span class="line-removed"> 1707   //    -- by other</span>
<span class="line-removed"> 1708   //</span>
<span class="line-removed"> 1709 </span>
<span class="line-removed"> 1710   Label IsInflated, DONE_LABEL;</span>
<span class="line-removed"> 1711 </span>
<span class="line-removed"> 1712   // it&#39;s stack-locked, biased or neutral</span>
<span class="line-removed"> 1713   // TODO: optimize away redundant LDs of obj-&gt;mark and improve the markword triage</span>
<span class="line-removed"> 1714   // order to reduce the number of conditional branches in the most common cases.</span>
<span class="line-removed"> 1715   // Beware -- there&#39;s a subtle invariant that fetch of the markword</span>
<span class="line-removed"> 1716   // at [FETCH], below, will never observe a biased encoding (*101b).</span>
<span class="line-removed"> 1717   // If this invariant is not held we risk exclusion (safety) failure.</span>
<span class="line-removed"> 1718   if (UseBiasedLocking &amp;&amp; !UseOptoBiasInlining) {</span>
<span class="line-removed"> 1719     biased_locking_enter(boxReg, objReg, tmpReg, scrReg, false, DONE_LABEL, NULL, counters);</span>
<span class="line-removed"> 1720   }</span>
<span class="line-removed"> 1721 </span>
<span class="line-removed"> 1722 #if INCLUDE_RTM_OPT</span>
<span class="line-removed"> 1723   if (UseRTMForStackLocks &amp;&amp; use_rtm) {</span>
<span class="line-removed"> 1724     rtm_stack_locking(objReg, tmpReg, scrReg, cx2Reg,</span>
<span class="line-removed"> 1725                       stack_rtm_counters, method_data, profile_rtm,</span>
<span class="line-removed"> 1726                       DONE_LABEL, IsInflated);</span>
<span class="line-removed"> 1727   }</span>
<span class="line-removed"> 1728 #endif // INCLUDE_RTM_OPT</span>
<span class="line-removed"> 1729 </span>
<span class="line-removed"> 1730   movptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes()));          // [FETCH]</span>
<span class="line-removed"> 1731   testptr(tmpReg, markWord::monitor_value); // inflated vs stack-locked|neutral|biased</span>
<span class="line-removed"> 1732   jccb(Assembler::notZero, IsInflated);</span>
<span class="line-removed"> 1733 </span>
<span class="line-removed"> 1734   // Attempt stack-locking ...</span>
<span class="line-removed"> 1735   orptr (tmpReg, markWord::unlocked_value);</span>
<span class="line-removed"> 1736   movptr(Address(boxReg, 0), tmpReg);          // Anticipate successful CAS</span>
<span class="line-removed"> 1737   lock();</span>
<span class="line-removed"> 1738   cmpxchgptr(boxReg, Address(objReg, oopDesc::mark_offset_in_bytes()));      // Updates tmpReg</span>
<span class="line-removed"> 1739   if (counters != NULL) {</span>
<span class="line-removed"> 1740     cond_inc32(Assembler::equal,</span>
<span class="line-removed"> 1741                ExternalAddress((address)counters-&gt;fast_path_entry_count_addr()));</span>
<span class="line-removed"> 1742   }</span>
<span class="line-removed"> 1743   jcc(Assembler::equal, DONE_LABEL);           // Success</span>
<span class="line-removed"> 1744 </span>
<span class="line-removed"> 1745   // Recursive locking.</span>
<span class="line-removed"> 1746   // The object is stack-locked: markword contains stack pointer to BasicLock.</span>
<span class="line-removed"> 1747   // Locked by current thread if difference with current SP is less than one page.</span>
<span class="line-removed"> 1748   subptr(tmpReg, rsp);</span>
<span class="line-removed"> 1749   // Next instruction set ZFlag == 1 (Success) if difference is less then one page.</span>
<span class="line-removed"> 1750   andptr(tmpReg, (int32_t) (NOT_LP64(0xFFFFF003) LP64_ONLY(7 - os::vm_page_size())) );</span>
<span class="line-removed"> 1751   movptr(Address(boxReg, 0), tmpReg);</span>
<span class="line-removed"> 1752   if (counters != NULL) {</span>
<span class="line-removed"> 1753     cond_inc32(Assembler::equal,</span>
<span class="line-removed"> 1754                ExternalAddress((address)counters-&gt;fast_path_entry_count_addr()));</span>
<span class="line-removed"> 1755   }</span>
<span class="line-removed"> 1756   jmp(DONE_LABEL);</span>
<span class="line-removed"> 1757 </span>
<span class="line-removed"> 1758   bind(IsInflated);</span>
<span class="line-removed"> 1759   // The object is inflated. tmpReg contains pointer to ObjectMonitor* + markWord::monitor_value</span>
<span class="line-removed"> 1760 </span>
<span class="line-removed"> 1761 #if INCLUDE_RTM_OPT</span>
<span class="line-removed"> 1762   // Use the same RTM locking code in 32- and 64-bit VM.</span>
<span class="line-removed"> 1763   if (use_rtm) {</span>
<span class="line-removed"> 1764     rtm_inflated_locking(objReg, boxReg, tmpReg, scrReg, cx1Reg, cx2Reg,</span>
<span class="line-removed"> 1765                          rtm_counters, method_data, profile_rtm, DONE_LABEL);</span>
<span class="line-removed"> 1766   } else {</span>
<span class="line-removed"> 1767 #endif // INCLUDE_RTM_OPT</span>
<span class="line-removed"> 1768 </span>
<span class="line-removed"> 1769 #ifndef _LP64</span>
<span class="line-removed"> 1770   // The object is inflated.</span>
<span class="line-removed"> 1771 </span>
<span class="line-removed"> 1772   // boxReg refers to the on-stack BasicLock in the current frame.</span>
<span class="line-removed"> 1773   // We&#39;d like to write:</span>
<span class="line-removed"> 1774   //   set box-&gt;_displaced_header = markWord::unused_mark().  Any non-0 value suffices.</span>
<span class="line-removed"> 1775   // This is convenient but results a ST-before-CAS penalty.  The following CAS suffers</span>
<span class="line-removed"> 1776   // additional latency as we have another ST in the store buffer that must drain.</span>
<span class="line-removed"> 1777 </span>
<span class="line-removed"> 1778   // avoid ST-before-CAS</span>
<span class="line-removed"> 1779   // register juggle because we need tmpReg for cmpxchgptr below</span>
<span class="line-removed"> 1780   movptr(scrReg, boxReg);</span>
<span class="line-removed"> 1781   movptr(boxReg, tmpReg);                   // consider: LEA box, [tmp-2]</span>
<span class="line-removed"> 1782 </span>
<span class="line-removed"> 1783   // Optimistic form: consider XORL tmpReg,tmpReg</span>
<span class="line-removed"> 1784   movptr(tmpReg, NULL_WORD);</span>
<span class="line-removed"> 1785 </span>
<span class="line-removed"> 1786   // Appears unlocked - try to swing _owner from null to non-null.</span>
<span class="line-removed"> 1787   // Ideally, I&#39;d manifest &quot;Self&quot; with get_thread and then attempt</span>
<span class="line-removed"> 1788   // to CAS the register containing Self into m-&gt;Owner.</span>
<span class="line-removed"> 1789   // But we don&#39;t have enough registers, so instead we can either try to CAS</span>
<span class="line-removed"> 1790   // rsp or the address of the box (in scr) into &amp;m-&gt;owner.  If the CAS succeeds</span>
<span class="line-removed"> 1791   // we later store &quot;Self&quot; into m-&gt;Owner.  Transiently storing a stack address</span>
<span class="line-removed"> 1792   // (rsp or the address of the box) into  m-&gt;owner is harmless.</span>
<span class="line-removed"> 1793   // Invariant: tmpReg == 0.  tmpReg is EAX which is the implicit cmpxchg comparand.</span>
<span class="line-removed"> 1794   lock();</span>
<span class="line-removed"> 1795   cmpxchgptr(scrReg, Address(boxReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));</span>
<span class="line-removed"> 1796   movptr(Address(scrReg, 0), 3);          // box-&gt;_displaced_header = 3</span>
<span class="line-removed"> 1797   // If we weren&#39;t able to swing _owner from NULL to the BasicLock</span>
<span class="line-removed"> 1798   // then take the slow path.</span>
<span class="line-removed"> 1799   jccb  (Assembler::notZero, DONE_LABEL);</span>
<span class="line-removed"> 1800   // update _owner from BasicLock to thread</span>
<span class="line-removed"> 1801   get_thread (scrReg);                    // beware: clobbers ICCs</span>
<span class="line-removed"> 1802   movptr(Address(boxReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)), scrReg);</span>
<span class="line-removed"> 1803   xorptr(boxReg, boxReg);                 // set icc.ZFlag = 1 to indicate success</span>
<span class="line-removed"> 1804 </span>
<span class="line-removed"> 1805   // If the CAS fails we can either retry or pass control to the slow path.</span>
<span class="line-removed"> 1806   // We use the latter tactic.</span>
<span class="line-removed"> 1807   // Pass the CAS result in the icc.ZFlag into DONE_LABEL</span>
<span class="line-removed"> 1808   // If the CAS was successful ...</span>
<span class="line-removed"> 1809   //   Self has acquired the lock</span>
<span class="line-removed"> 1810   //   Invariant: m-&gt;_recursions should already be 0, so we don&#39;t need to explicitly set it.</span>
<span class="line-removed"> 1811   // Intentional fall-through into DONE_LABEL ...</span>
<span class="line-removed"> 1812 #else // _LP64</span>
<span class="line-removed"> 1813   // It&#39;s inflated and we use scrReg for ObjectMonitor* in this section.</span>
<span class="line-removed"> 1814   movq(scrReg, tmpReg);</span>
<span class="line-removed"> 1815   xorq(tmpReg, tmpReg);</span>
<span class="line-removed"> 1816   lock();</span>
<span class="line-removed"> 1817   cmpxchgptr(r15_thread, Address(scrReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));</span>
<span class="line-removed"> 1818   // Unconditionally set box-&gt;_displaced_header = markWord::unused_mark().</span>
<span class="line-removed"> 1819   // Without cast to int32_t this style of movptr will destroy r10 which is typically obj.</span>
<span class="line-removed"> 1820   movptr(Address(boxReg, 0), (int32_t)intptr_t(markWord::unused_mark().value()));</span>
<span class="line-removed"> 1821   // Intentional fall-through into DONE_LABEL ...</span>
<span class="line-removed"> 1822   // Propagate ICC.ZF from CAS above into DONE_LABEL.</span>
<span class="line-removed"> 1823 #endif // _LP64</span>
<span class="line-removed"> 1824 #if INCLUDE_RTM_OPT</span>
<span class="line-removed"> 1825   } // use_rtm()</span>
<span class="line-removed"> 1826 #endif</span>
<span class="line-removed"> 1827   // DONE_LABEL is a hot target - we&#39;d really like to place it at the</span>
<span class="line-removed"> 1828   // start of cache line by padding with NOPs.</span>
<span class="line-removed"> 1829   // See the AMD and Intel software optimization manuals for the</span>
<span class="line-removed"> 1830   // most efficient &quot;long&quot; NOP encodings.</span>
<span class="line-removed"> 1831   // Unfortunately none of our alignment mechanisms suffice.</span>
<span class="line-removed"> 1832   bind(DONE_LABEL);</span>
<span class="line-removed"> 1833 </span>
<span class="line-removed"> 1834   // At DONE_LABEL the icc ZFlag is set as follows ...</span>
<span class="line-removed"> 1835   // fast_unlock uses the same protocol.</span>
<span class="line-removed"> 1836   // ZFlag == 1 -&gt; Success</span>
<span class="line-removed"> 1837   // ZFlag == 0 -&gt; Failure - force control through the slow path</span>
<span class="line-removed"> 1838 }</span>
<span class="line-removed"> 1839 </span>
<span class="line-removed"> 1840 // obj: object to unlock</span>
<span class="line-removed"> 1841 // box: box address (displaced header location), killed.  Must be EAX.</span>
<span class="line-removed"> 1842 // tmp: killed, cannot be obj nor box.</span>
<span class="line-removed"> 1843 //</span>
<span class="line-removed"> 1844 // Some commentary on balanced locking:</span>
<span class="line-removed"> 1845 //</span>
<span class="line-removed"> 1846 // fast_lock and fast_unlock are emitted only for provably balanced lock sites.</span>
<span class="line-removed"> 1847 // Methods that don&#39;t have provably balanced locking are forced to run in the</span>
<span class="line-removed"> 1848 // interpreter - such methods won&#39;t be compiled to use fast_lock and fast_unlock.</span>
<span class="line-removed"> 1849 // The interpreter provides two properties:</span>
<span class="line-removed"> 1850 // I1:  At return-time the interpreter automatically and quietly unlocks any</span>
<span class="line-removed"> 1851 //      objects acquired the current activation (frame).  Recall that the</span>
<span class="line-removed"> 1852 //      interpreter maintains an on-stack list of locks currently held by</span>
<span class="line-removed"> 1853 //      a frame.</span>
<span class="line-removed"> 1854 // I2:  If a method attempts to unlock an object that is not held by the</span>
<span class="line-removed"> 1855 //      the frame the interpreter throws IMSX.</span>
<span class="line-removed"> 1856 //</span>
<span class="line-removed"> 1857 // Lets say A(), which has provably balanced locking, acquires O and then calls B().</span>
<span class="line-removed"> 1858 // B() doesn&#39;t have provably balanced locking so it runs in the interpreter.</span>
<span class="line-removed"> 1859 // Control returns to A() and A() unlocks O.  By I1 and I2, above, we know that O</span>
<span class="line-removed"> 1860 // is still locked by A().</span>
<span class="line-removed"> 1861 //</span>
<span class="line-removed"> 1862 // The only other source of unbalanced locking would be JNI.  The &quot;Java Native Interface:</span>
<span class="line-removed"> 1863 // Programmer&#39;s Guide and Specification&quot; claims that an object locked by jni_monitorenter</span>
<span class="line-removed"> 1864 // should not be unlocked by &quot;normal&quot; java-level locking and vice-versa.  The specification</span>
<span class="line-removed"> 1865 // doesn&#39;t specify what will occur if a program engages in such mixed-mode locking, however.</span>
<span class="line-removed"> 1866 // Arguably given that the spec legislates the JNI case as undefined our implementation</span>
<span class="line-removed"> 1867 // could reasonably *avoid* checking owner in fast_unlock().</span>
<span class="line-removed"> 1868 // In the interest of performance we elide m-&gt;Owner==Self check in unlock.</span>
<span class="line-removed"> 1869 // A perfectly viable alternative is to elide the owner check except when</span>
<span class="line-removed"> 1870 // Xcheck:jni is enabled.</span>
<span class="line-removed"> 1871 </span>
<span class="line-removed"> 1872 void MacroAssembler::fast_unlock(Register objReg, Register boxReg, Register tmpReg, bool use_rtm) {</span>
<span class="line-removed"> 1873   assert(boxReg == rax, &quot;&quot;);</span>
<span class="line-removed"> 1874   assert_different_registers(objReg, boxReg, tmpReg);</span>
<span class="line-removed"> 1875 </span>
<span class="line-removed"> 1876   Label DONE_LABEL, Stacked, CheckSucc;</span>
<span class="line-removed"> 1877 </span>
<span class="line-removed"> 1878   // Critically, the biased locking test must have precedence over</span>
<span class="line-removed"> 1879   // and appear before the (box-&gt;dhw == 0) recursive stack-lock test.</span>
<span class="line-removed"> 1880   if (UseBiasedLocking &amp;&amp; !UseOptoBiasInlining) {</span>
<span class="line-removed"> 1881     biased_locking_exit(objReg, tmpReg, DONE_LABEL);</span>
<span class="line-removed"> 1882   }</span>
<span class="line-removed"> 1883 </span>
<span class="line-removed"> 1884 #if INCLUDE_RTM_OPT</span>
<span class="line-removed"> 1885   if (UseRTMForStackLocks &amp;&amp; use_rtm) {</span>
<span class="line-removed"> 1886     assert(!UseBiasedLocking, &quot;Biased locking is not supported with RTM locking&quot;);</span>
<span class="line-removed"> 1887     Label L_regular_unlock;</span>
<span class="line-removed"> 1888     movptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes())); // fetch markword</span>
<span class="line-removed"> 1889     andptr(tmpReg, markWord::biased_lock_mask_in_place);              // look at 3 lock bits</span>
<span class="line-removed"> 1890     cmpptr(tmpReg, markWord::unlocked_value);                         // bits = 001 unlocked</span>
<span class="line-removed"> 1891     jccb(Assembler::notEqual, L_regular_unlock);                      // if !HLE RegularLock</span>
<span class="line-removed"> 1892     xend();                                                           // otherwise end...</span>
<span class="line-removed"> 1893     jmp(DONE_LABEL);                                                  // ... and we&#39;re done</span>
<span class="line-removed"> 1894     bind(L_regular_unlock);</span>
<span class="line-removed"> 1895   }</span>
<span class="line-removed"> 1896 #endif</span>
<span class="line-removed"> 1897 </span>
<span class="line-removed"> 1898   cmpptr(Address(boxReg, 0), (int32_t)NULL_WORD);                   // Examine the displaced header</span>
<span class="line-removed"> 1899   jcc   (Assembler::zero, DONE_LABEL);                              // 0 indicates recursive stack-lock</span>
<span class="line-removed"> 1900   movptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes())); // Examine the object&#39;s markword</span>
<span class="line-removed"> 1901   testptr(tmpReg, markWord::monitor_value);                         // Inflated?</span>
<span class="line-removed"> 1902   jccb  (Assembler::zero, Stacked);</span>
<span class="line-removed"> 1903 </span>
<span class="line-removed"> 1904   // It&#39;s inflated.</span>
<span class="line-removed"> 1905 #if INCLUDE_RTM_OPT</span>
<span class="line-removed"> 1906   if (use_rtm) {</span>
<span class="line-removed"> 1907     Label L_regular_inflated_unlock;</span>
<span class="line-removed"> 1908     int owner_offset = OM_OFFSET_NO_MONITOR_VALUE_TAG(owner);</span>
<span class="line-removed"> 1909     movptr(boxReg, Address(tmpReg, owner_offset));</span>
<span class="line-removed"> 1910     testptr(boxReg, boxReg);</span>
<span class="line-removed"> 1911     jccb(Assembler::notZero, L_regular_inflated_unlock);</span>
<span class="line-removed"> 1912     xend();</span>
<span class="line-removed"> 1913     jmpb(DONE_LABEL);</span>
<span class="line-removed"> 1914     bind(L_regular_inflated_unlock);</span>
<span class="line-removed"> 1915   }</span>
<span class="line-removed"> 1916 #endif</span>
<span class="line-removed"> 1917 </span>
<span class="line-removed"> 1918   // Despite our balanced locking property we still check that m-&gt;_owner == Self</span>
<span class="line-removed"> 1919   // as java routines or native JNI code called by this thread might</span>
<span class="line-removed"> 1920   // have released the lock.</span>
<span class="line-removed"> 1921   // Refer to the comments in synchronizer.cpp for how we might encode extra</span>
<span class="line-removed"> 1922   // state in _succ so we can avoid fetching EntryList|cxq.</span>
<span class="line-removed"> 1923   //</span>
<span class="line-removed"> 1924   // I&#39;d like to add more cases in fast_lock() and fast_unlock() --</span>
<span class="line-removed"> 1925   // such as recursive enter and exit -- but we have to be wary of</span>
<span class="line-removed"> 1926   // I$ bloat, T$ effects and BP$ effects.</span>
<span class="line-removed"> 1927   //</span>
<span class="line-removed"> 1928   // If there&#39;s no contention try a 1-0 exit.  That is, exit without</span>
<span class="line-removed"> 1929   // a costly MEMBAR or CAS.  See synchronizer.cpp for details on how</span>
<span class="line-removed"> 1930   // we detect and recover from the race that the 1-0 exit admits.</span>
<span class="line-removed"> 1931   //</span>
<span class="line-removed"> 1932   // Conceptually fast_unlock() must execute a STST|LDST &quot;release&quot; barrier</span>
<span class="line-removed"> 1933   // before it STs null into _owner, releasing the lock.  Updates</span>
<span class="line-removed"> 1934   // to data protected by the critical section must be visible before</span>
<span class="line-removed"> 1935   // we drop the lock (and thus before any other thread could acquire</span>
<span class="line-removed"> 1936   // the lock and observe the fields protected by the lock).</span>
<span class="line-removed"> 1937   // IA32&#39;s memory-model is SPO, so STs are ordered with respect to</span>
<span class="line-removed"> 1938   // each other and there&#39;s no need for an explicit barrier (fence).</span>
<span class="line-removed"> 1939   // See also http://gee.cs.oswego.edu/dl/jmm/cookbook.html.</span>
<span class="line-removed"> 1940 #ifndef _LP64</span>
<span class="line-removed"> 1941   get_thread (boxReg);</span>
<span class="line-removed"> 1942 </span>
<span class="line-removed"> 1943   // Note that we could employ various encoding schemes to reduce</span>
<span class="line-removed"> 1944   // the number of loads below (currently 4) to just 2 or 3.</span>
<span class="line-removed"> 1945   // Refer to the comments in synchronizer.cpp.</span>
<span class="line-removed"> 1946   // In practice the chain of fetches doesn&#39;t seem to impact performance, however.</span>
<span class="line-removed"> 1947   xorptr(boxReg, boxReg);</span>
<span class="line-removed"> 1948   orptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));</span>
<span class="line-removed"> 1949   jccb  (Assembler::notZero, DONE_LABEL);</span>
<span class="line-removed"> 1950   movptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(EntryList)));</span>
<span class="line-removed"> 1951   orptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(cxq)));</span>
<span class="line-removed"> 1952   jccb  (Assembler::notZero, CheckSucc);</span>
<span class="line-removed"> 1953   movptr(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)), NULL_WORD);</span>
<span class="line-removed"> 1954   jmpb  (DONE_LABEL);</span>
<span class="line-removed"> 1955 </span>
<span class="line-removed"> 1956   bind (Stacked);</span>
<span class="line-removed"> 1957   // It&#39;s not inflated and it&#39;s not recursively stack-locked and it&#39;s not biased.</span>
<span class="line-removed"> 1958   // It must be stack-locked.</span>
<span class="line-removed"> 1959   // Try to reset the header to displaced header.</span>
<span class="line-removed"> 1960   // The &quot;box&quot; value on the stack is stable, so we can reload</span>
<span class="line-removed"> 1961   // and be assured we observe the same value as above.</span>
<span class="line-removed"> 1962   movptr(tmpReg, Address(boxReg, 0));</span>
<span class="line-removed"> 1963   lock();</span>
<span class="line-removed"> 1964   cmpxchgptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes())); // Uses RAX which is box</span>
<span class="line-removed"> 1965   // Intention fall-thru into DONE_LABEL</span>
<span class="line-removed"> 1966 </span>
<span class="line-removed"> 1967   // DONE_LABEL is a hot target - we&#39;d really like to place it at the</span>
<span class="line-removed"> 1968   // start of cache line by padding with NOPs.</span>
<span class="line-removed"> 1969   // See the AMD and Intel software optimization manuals for the</span>
<span class="line-removed"> 1970   // most efficient &quot;long&quot; NOP encodings.</span>
<span class="line-removed"> 1971   // Unfortunately none of our alignment mechanisms suffice.</span>
<span class="line-removed"> 1972   bind (CheckSucc);</span>
<span class="line-removed"> 1973 #else // _LP64</span>
<span class="line-removed"> 1974   // It&#39;s inflated</span>
<span class="line-removed"> 1975   xorptr(boxReg, boxReg);</span>
<span class="line-removed"> 1976   orptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));</span>
<span class="line-removed"> 1977   jccb  (Assembler::notZero, DONE_LABEL);</span>
<span class="line-removed"> 1978   movptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(cxq)));</span>
<span class="line-removed"> 1979   orptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(EntryList)));</span>
<span class="line-removed"> 1980   jccb  (Assembler::notZero, CheckSucc);</span>
<span class="line-removed"> 1981   // Without cast to int32_t this style of movptr will destroy r10 which is typically obj.</span>
<span class="line-removed"> 1982   movptr(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)), (int32_t)NULL_WORD);</span>
<span class="line-removed"> 1983   jmpb  (DONE_LABEL);</span>
<span class="line-removed"> 1984 </span>
<span class="line-removed"> 1985   // Try to avoid passing control into the slow_path ...</span>
<span class="line-removed"> 1986   Label LSuccess, LGoSlowPath ;</span>
<span class="line-removed"> 1987   bind  (CheckSucc);</span>
<span class="line-removed"> 1988 </span>
<span class="line-removed"> 1989   // The following optional optimization can be elided if necessary</span>
<span class="line-removed"> 1990   // Effectively: if (succ == null) goto slow path</span>
<span class="line-removed"> 1991   // The code reduces the window for a race, however,</span>
<span class="line-removed"> 1992   // and thus benefits performance.</span>
<span class="line-removed"> 1993   cmpptr(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(succ)), (int32_t)NULL_WORD);</span>
<span class="line-removed"> 1994   jccb  (Assembler::zero, LGoSlowPath);</span>
<span class="line-removed"> 1995 </span>
<span class="line-removed"> 1996   xorptr(boxReg, boxReg);</span>
<span class="line-removed"> 1997   // Without cast to int32_t this style of movptr will destroy r10 which is typically obj.</span>
<span class="line-removed"> 1998   movptr(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)), (int32_t)NULL_WORD);</span>
<span class="line-removed"> 1999 </span>
<span class="line-removed"> 2000   // Memory barrier/fence</span>
<span class="line-removed"> 2001   // Dekker pivot point -- fulcrum : ST Owner; MEMBAR; LD Succ</span>
<span class="line-removed"> 2002   // Instead of MFENCE we use a dummy locked add of 0 to the top-of-stack.</span>
<span class="line-removed"> 2003   // This is faster on Nehalem and AMD Shanghai/Barcelona.</span>
<span class="line-removed"> 2004   // See https://blogs.oracle.com/dave/entry/instruction_selection_for_volatile_fences</span>
<span class="line-removed"> 2005   // We might also restructure (ST Owner=0;barrier;LD _Succ) to</span>
<span class="line-removed"> 2006   // (mov box,0; xchgq box, &amp;m-&gt;Owner; LD _succ) .</span>
<span class="line-removed"> 2007   lock(); addl(Address(rsp, 0), 0);</span>
<span class="line-removed"> 2008 </span>
<span class="line-removed"> 2009   cmpptr(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(succ)), (int32_t)NULL_WORD);</span>
<span class="line-removed"> 2010   jccb  (Assembler::notZero, LSuccess);</span>
<span class="line-removed"> 2011 </span>
<span class="line-removed"> 2012   // Rare inopportune interleaving - race.</span>
<span class="line-removed"> 2013   // The successor vanished in the small window above.</span>
<span class="line-removed"> 2014   // The lock is contended -- (cxq|EntryList) != null -- and there&#39;s no apparent successor.</span>
<span class="line-removed"> 2015   // We need to ensure progress and succession.</span>
<span class="line-removed"> 2016   // Try to reacquire the lock.</span>
<span class="line-removed"> 2017   // If that fails then the new owner is responsible for succession and this</span>
<span class="line-removed"> 2018   // thread needs to take no further action and can exit via the fast path (success).</span>
<span class="line-removed"> 2019   // If the re-acquire succeeds then pass control into the slow path.</span>
<span class="line-removed"> 2020   // As implemented, this latter mode is horrible because we generated more</span>
<span class="line-removed"> 2021   // coherence traffic on the lock *and* artifically extended the critical section</span>
<span class="line-removed"> 2022   // length while by virtue of passing control into the slow path.</span>
<span class="line-removed"> 2023 </span>
<span class="line-removed"> 2024   // box is really RAX -- the following CMPXCHG depends on that binding</span>
<span class="line-removed"> 2025   // cmpxchg R,[M] is equivalent to rax = CAS(M,rax,R)</span>
<span class="line-removed"> 2026   lock();</span>
<span class="line-removed"> 2027   cmpxchgptr(r15_thread, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));</span>
<span class="line-removed"> 2028   // There&#39;s no successor so we tried to regrab the lock.</span>
<span class="line-removed"> 2029   // If that didn&#39;t work, then another thread grabbed the</span>
<span class="line-removed"> 2030   // lock so we&#39;re done (and exit was a success).</span>
<span class="line-removed"> 2031   jccb  (Assembler::notEqual, LSuccess);</span>
<span class="line-removed"> 2032   // Intentional fall-through into slow path</span>
<span class="line-removed"> 2033 </span>
<span class="line-removed"> 2034   bind  (LGoSlowPath);</span>
<span class="line-removed"> 2035   orl   (boxReg, 1);                      // set ICC.ZF=0 to indicate failure</span>
<span class="line-removed"> 2036   jmpb  (DONE_LABEL);</span>
<span class="line-removed"> 2037 </span>
<span class="line-removed"> 2038   bind  (LSuccess);</span>
<span class="line-removed"> 2039   testl (boxReg, 0);                      // set ICC.ZF=1 to indicate success</span>
<span class="line-removed"> 2040   jmpb  (DONE_LABEL);</span>
<span class="line-removed"> 2041 </span>
<span class="line-removed"> 2042   bind  (Stacked);</span>
<span class="line-removed"> 2043   movptr(tmpReg, Address (boxReg, 0));      // re-fetch</span>
<span class="line-removed"> 2044   lock();</span>
<span class="line-removed"> 2045   cmpxchgptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes())); // Uses RAX which is box</span>
<span class="line-removed"> 2046 </span>
<span class="line-removed"> 2047 #endif</span>
<span class="line-removed"> 2048   bind(DONE_LABEL);</span>
<span class="line-removed"> 2049 }</span>
<span class="line-removed"> 2050 #endif // COMPILER2</span>
<span class="line-removed"> 2051 </span>
 2052 void MacroAssembler::c2bool(Register x) {
 2053   // implements x == 0 ? 0 : 1
 2054   // note: must only look at least-significant byte of x
 2055   //       since C-style booleans are stored in one byte
 2056   //       only! (was bug)
 2057   andl(x, 0xFF);
 2058   setb(Assembler::notZero, x);
 2059 }
 2060 
 2061 // Wouldn&#39;t need if AddressLiteral version had new name
 2062 void MacroAssembler::call(Label&amp; L, relocInfo::relocType rtype) {
 2063   Assembler::call(L, rtype);
 2064 }
 2065 
 2066 void MacroAssembler::call(Register entry) {
 2067   Assembler::call(entry);
 2068 }
 2069 
 2070 void MacroAssembler::call(AddressLiteral entry) {
 2071   if (reachable(entry)) {
</pre>
<hr />
<pre>
 2707 }
 2708 
 2709 void MacroAssembler::divsd(XMMRegister dst, AddressLiteral src) {
 2710   if (reachable(src)) {
 2711     Assembler::divsd(dst, as_Address(src));
 2712   } else {
 2713     lea(rscratch1, src);
 2714     Assembler::divsd(dst, Address(rscratch1, 0));
 2715   }
 2716 }
 2717 
 2718 void MacroAssembler::divss(XMMRegister dst, AddressLiteral src) {
 2719   if (reachable(src)) {
 2720     Assembler::divss(dst, as_Address(src));
 2721   } else {
 2722     lea(rscratch1, src);
 2723     Assembler::divss(dst, Address(rscratch1, 0));
 2724   }
 2725 }
 2726 
<span class="line-removed"> 2727 #ifndef _LP64</span>
<span class="line-removed"> 2728 void MacroAssembler::empty_FPU_stack() {</span>
<span class="line-removed"> 2729   if (VM_Version::supports_mmx()) {</span>
<span class="line-removed"> 2730     emms();</span>
<span class="line-removed"> 2731   } else {</span>
<span class="line-removed"> 2732     for (int i = 8; i-- &gt; 0; ) ffree(i);</span>
<span class="line-removed"> 2733   }</span>
<span class="line-removed"> 2734 }</span>
<span class="line-removed"> 2735 #endif // !LP64</span>
<span class="line-removed"> 2736 </span>
<span class="line-removed"> 2737 </span>
 2738 void MacroAssembler::enter() {
 2739   push(rbp);
 2740   mov(rbp, rsp);
 2741 }
 2742 
 2743 // A 5 byte nop that is safe for patching (see patch_verified_entry)
 2744 void MacroAssembler::fat_nop() {
 2745   if (UseAddressNop) {
 2746     addr_nop_5();
 2747   } else {
 2748     emit_int8(0x26); // es:
 2749     emit_int8(0x2e); // cs:
 2750     emit_int8(0x64); // fs:
 2751     emit_int8(0x65); // gs:
 2752     emit_int8((unsigned char)0x90);
 2753   }
 2754 }
 2755 
<span class="line-modified"> 2756 #if !defined(_LP64)</span>
 2757 void MacroAssembler::fcmp(Register tmp) {
 2758   fcmp(tmp, 1, true, true);
 2759 }
 2760 
 2761 void MacroAssembler::fcmp(Register tmp, int index, bool pop_left, bool pop_right) {
 2762   assert(!pop_right || pop_left, &quot;usage error&quot;);
 2763   if (VM_Version::supports_cmov()) {
 2764     assert(tmp == noreg, &quot;unneeded temp&quot;);
 2765     if (pop_left) {
 2766       fucomip(index);
 2767     } else {
 2768       fucomi(index);
 2769     }
 2770     if (pop_right) {
 2771       fpop();
 2772     }
 2773   } else {
 2774     assert(tmp != noreg, &quot;need temp&quot;);
 2775     if (pop_left) {
 2776       if (pop_right) {
</pre>
<hr />
<pre>
 2839   ffree();
 2840   fincstp();
 2841 }
 2842 
 2843 void MacroAssembler::fremr(Register tmp) {
 2844   save_rax(tmp);
 2845   { Label L;
 2846     bind(L);
 2847     fprem();
 2848     fwait(); fnstsw_ax();
 2849     sahf();
 2850     jcc(Assembler::parity, L);
 2851   }
 2852   restore_rax(tmp);
 2853   // Result is in ST0.
 2854   // Note: fxch &amp; fpop to get rid of ST1
 2855   // (otherwise FPU stack could overflow eventually)
 2856   fxch(1);
 2857   fpop();
 2858 }








 2859 #endif // !LP64
 2860 
 2861 void MacroAssembler::mulpd(XMMRegister dst, AddressLiteral src) {
 2862   if (reachable(src)) {
 2863     Assembler::mulpd(dst, as_Address(src));
 2864   } else {
 2865     lea(rscratch1, src);
 2866     Assembler::mulpd(dst, Address(rscratch1, 0));
 2867   }
 2868 }
 2869 
 2870 void MacroAssembler::load_float(Address src) {



 2871   if (UseSSE &gt;= 1) {
 2872     movflt(xmm0, src);
 2873   } else {
<span class="line-modified"> 2874     LP64_ONLY(ShouldNotReachHere());</span>
<span class="line-removed"> 2875     NOT_LP64(fld_s(src));</span>
 2876   }

 2877 }
 2878 
 2879 void MacroAssembler::store_float(Address dst) {



 2880   if (UseSSE &gt;= 1) {
 2881     movflt(dst, xmm0);
 2882   } else {
<span class="line-modified"> 2883     LP64_ONLY(ShouldNotReachHere());</span>
<span class="line-removed"> 2884     NOT_LP64(fstp_s(dst));</span>
 2885   }

 2886 }
 2887 
 2888 void MacroAssembler::load_double(Address src) {



 2889   if (UseSSE &gt;= 2) {
 2890     movdbl(xmm0, src);
 2891   } else {
<span class="line-modified"> 2892     LP64_ONLY(ShouldNotReachHere());</span>
<span class="line-removed"> 2893     NOT_LP64(fld_d(src));</span>
 2894   }

 2895 }
 2896 
 2897 void MacroAssembler::store_double(Address dst) {



 2898   if (UseSSE &gt;= 2) {
 2899     movdbl(dst, xmm0);
 2900   } else {
<span class="line-modified"> 2901     LP64_ONLY(ShouldNotReachHere());</span>
<span class="line-removed"> 2902     NOT_LP64(fstp_d(dst));</span>
 2903   }

 2904 }
 2905 
 2906 // dst = c = a * b + c
 2907 void MacroAssembler::fmad(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c) {
 2908   Assembler::vfmadd231sd(c, a, b);
 2909   if (dst != c) {
 2910     movdbl(dst, c);
 2911   }
 2912 }
 2913 
 2914 // dst = c = a * b + c
 2915 void MacroAssembler::fmaf(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c) {
 2916   Assembler::vfmadd231ss(c, a, b);
 2917   if (dst != c) {
 2918     movflt(dst, c);
 2919   }
 2920 }
 2921 
 2922 // dst = c = a * b + c
 2923 void MacroAssembler::vfmad(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c, int vector_len) {
</pre>
<hr />
<pre>
 3188 }
 3189 
 3190 void MacroAssembler::movdl(XMMRegister dst, AddressLiteral src) {
 3191   if (reachable(src)) {
 3192     movdl(dst, as_Address(src));
 3193   } else {
 3194     lea(rscratch1, src);
 3195     movdl(dst, Address(rscratch1, 0));
 3196   }
 3197 }
 3198 
 3199 void MacroAssembler::movq(XMMRegister dst, AddressLiteral src) {
 3200   if (reachable(src)) {
 3201     movq(dst, as_Address(src));
 3202   } else {
 3203     lea(rscratch1, src);
 3204     movq(dst, Address(rscratch1, 0));
 3205   }
 3206 }
 3207 
<span class="line-removed"> 3208 #ifdef COMPILER2</span>
<span class="line-removed"> 3209 void MacroAssembler::setvectmask(Register dst, Register src) {</span>
<span class="line-removed"> 3210   guarantee(PostLoopMultiversioning, &quot;must be&quot;);</span>
<span class="line-removed"> 3211   Assembler::movl(dst, 1);</span>
<span class="line-removed"> 3212   Assembler::shlxl(dst, dst, src);</span>
<span class="line-removed"> 3213   Assembler::decl(dst);</span>
<span class="line-removed"> 3214   Assembler::kmovdl(k1, dst);</span>
<span class="line-removed"> 3215   Assembler::movl(dst, src);</span>
<span class="line-removed"> 3216 }</span>
<span class="line-removed"> 3217 </span>
<span class="line-removed"> 3218 void MacroAssembler::restorevectmask() {</span>
<span class="line-removed"> 3219   guarantee(PostLoopMultiversioning, &quot;must be&quot;);</span>
<span class="line-removed"> 3220   Assembler::knotwl(k1, k0);</span>
<span class="line-removed"> 3221 }</span>
<span class="line-removed"> 3222 #endif // COMPILER2</span>
<span class="line-removed"> 3223 </span>
 3224 void MacroAssembler::movdbl(XMMRegister dst, AddressLiteral src) {
 3225   if (reachable(src)) {
 3226     if (UseXmmLoadAndClearUpper) {
 3227       movsd (dst, as_Address(src));
 3228     } else {
 3229       movlpd(dst, as_Address(src));
 3230     }
 3231   } else {
 3232     lea(rscratch1, src);
 3233     if (UseXmmLoadAndClearUpper) {
 3234       movsd (dst, Address(rscratch1, 0));
 3235     } else {
 3236       movlpd(dst, Address(rscratch1, 0));
 3237     }
 3238   }
 3239 }
 3240 
 3241 void MacroAssembler::movflt(XMMRegister dst, AddressLiteral src) {
 3242   if (reachable(src)) {
 3243     movss(dst, as_Address(src));
</pre>
<hr />
<pre>
 3464 
 3465   vzeroupper();
 3466 }
 3467 
 3468 void MacroAssembler::restore_rax(Register tmp) {
 3469   if (tmp == noreg) pop(rax);
 3470   else if (tmp != rax) mov(rax, tmp);
 3471 }
 3472 
 3473 void MacroAssembler::round_to(Register reg, int modulus) {
 3474   addptr(reg, modulus - 1);
 3475   andptr(reg, -modulus);
 3476 }
 3477 
 3478 void MacroAssembler::save_rax(Register tmp) {
 3479   if (tmp == noreg) push(rax);
 3480   else if (tmp != rax) mov(tmp, rax);
 3481 }
 3482 
 3483 void MacroAssembler::safepoint_poll(Label&amp; slow_path, Register thread_reg, Register temp_reg) {
<span class="line-removed"> 3484   if (SafepointMechanism::uses_thread_local_poll()) {</span>
 3485 #ifdef _LP64
<span class="line-modified"> 3486     assert(thread_reg == r15_thread, &quot;should be&quot;);</span>
 3487 #else
<span class="line-modified"> 3488     if (thread_reg == noreg) {</span>
<span class="line-modified"> 3489       thread_reg = temp_reg;</span>
<span class="line-modified"> 3490       get_thread(thread_reg);</span>
<span class="line-removed"> 3491     }</span>
<span class="line-removed"> 3492 #endif</span>
<span class="line-removed"> 3493     testb(Address(thread_reg, Thread::polling_page_offset()), SafepointMechanism::poll_bit());</span>
<span class="line-removed"> 3494     jcc(Assembler::notZero, slow_path); // handshake bit set implies poll</span>
<span class="line-removed"> 3495   } else {</span>
<span class="line-removed"> 3496     cmp32(ExternalAddress(SafepointSynchronize::address_of_state()),</span>
<span class="line-removed"> 3497         SafepointSynchronize::_not_synchronized);</span>
<span class="line-removed"> 3498     jcc(Assembler::notEqual, slow_path);</span>
 3499   }



 3500 }
 3501 
 3502 // Calls to C land
 3503 //
 3504 // When entering C land, the rbp, &amp; rsp of the last Java frame have to be recorded
 3505 // in the (thread-local) JavaThread object. When leaving C land, the last Java fp
 3506 // has to be reset to 0. This is required to allow proper stack traversal.
 3507 void MacroAssembler::set_last_Java_frame(Register java_thread,
 3508                                          Register last_java_sp,
 3509                                          Register last_java_fp,
 3510                                          address  last_java_pc) {
 3511   vzeroupper();
 3512   // determine java_thread register
 3513   if (!java_thread-&gt;is_valid()) {
 3514     java_thread = rdi;
 3515     get_thread(java_thread);
 3516   }
 3517   // determine last_java_sp register
 3518   if (!last_java_sp-&gt;is_valid()) {
 3519     last_java_sp = rsp;
</pre>
<hr />
<pre>
 4008   } else {
 4009     lea(scratch_reg, src);
 4010     vxorps(dst, nds, Address(scratch_reg, 0), vector_len);
 4011   }
 4012 }
 4013 
 4014 void MacroAssembler::vpxor(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
 4015   if (UseAVX &gt; 1 || (vector_len &lt; 1)) {
 4016     if (reachable(src)) {
 4017       Assembler::vpxor(dst, nds, as_Address(src), vector_len);
 4018     } else {
 4019       lea(scratch_reg, src);
 4020       Assembler::vpxor(dst, nds, Address(scratch_reg, 0), vector_len);
 4021     }
 4022   }
 4023   else {
 4024     MacroAssembler::vxorpd(dst, nds, src, vector_len, scratch_reg);
 4025   }
 4026 }
 4027 
<span class="line-removed"> 4028 //-------------------------------------------------------------------------------------------</span>
<span class="line-removed"> 4029 #ifdef COMPILER2</span>
<span class="line-removed"> 4030 // Generic instructions support for use in .ad files C2 code generation</span>
<span class="line-removed"> 4031 </span>
<span class="line-removed"> 4032 void MacroAssembler::vabsnegd(int opcode, XMMRegister dst, XMMRegister src, Register scr) {</span>
<span class="line-removed"> 4033   if (dst != src) {</span>
<span class="line-removed"> 4034     movdqu(dst, src);</span>
<span class="line-removed"> 4035   }</span>
<span class="line-removed"> 4036   if (opcode == Op_AbsVD) {</span>
<span class="line-removed"> 4037     andpd(dst, ExternalAddress(StubRoutines::x86::vector_double_sign_mask()), scr);</span>
<span class="line-removed"> 4038   } else {</span>
<span class="line-removed"> 4039     assert((opcode == Op_NegVD),&quot;opcode should be Op_NegD&quot;);</span>
<span class="line-removed"> 4040     xorpd(dst, ExternalAddress(StubRoutines::x86::vector_double_sign_flip()), scr);</span>
<span class="line-removed"> 4041   }</span>
<span class="line-removed"> 4042 }</span>
<span class="line-removed"> 4043 </span>
<span class="line-removed"> 4044 void MacroAssembler::vabsnegd(int opcode, XMMRegister dst, XMMRegister src, int vector_len, Register scr) {</span>
<span class="line-removed"> 4045   if (opcode == Op_AbsVD) {</span>
<span class="line-removed"> 4046     vandpd(dst, src, ExternalAddress(StubRoutines::x86::vector_double_sign_mask()), vector_len, scr);</span>
<span class="line-removed"> 4047   } else {</span>
<span class="line-removed"> 4048     assert((opcode == Op_NegVD),&quot;opcode should be Op_NegD&quot;);</span>
<span class="line-removed"> 4049     vxorpd(dst, src, ExternalAddress(StubRoutines::x86::vector_double_sign_flip()), vector_len, scr);</span>
<span class="line-removed"> 4050   }</span>
<span class="line-removed"> 4051 }</span>
<span class="line-removed"> 4052 </span>
<span class="line-removed"> 4053 void MacroAssembler::vabsnegf(int opcode, XMMRegister dst, XMMRegister src, Register scr) {</span>
<span class="line-removed"> 4054   if (dst != src) {</span>
<span class="line-removed"> 4055     movdqu(dst, src);</span>
<span class="line-removed"> 4056   }</span>
<span class="line-removed"> 4057   if (opcode == Op_AbsVF) {</span>
<span class="line-removed"> 4058     andps(dst, ExternalAddress(StubRoutines::x86::vector_float_sign_mask()), scr);</span>
<span class="line-removed"> 4059   } else {</span>
<span class="line-removed"> 4060     assert((opcode == Op_NegVF),&quot;opcode should be Op_NegF&quot;);</span>
<span class="line-removed"> 4061     xorps(dst, ExternalAddress(StubRoutines::x86::vector_float_sign_flip()), scr);</span>
<span class="line-removed"> 4062   }</span>
<span class="line-removed"> 4063 }</span>
<span class="line-removed"> 4064 </span>
<span class="line-removed"> 4065 void MacroAssembler::vabsnegf(int opcode, XMMRegister dst, XMMRegister src, int vector_len, Register scr) {</span>
<span class="line-removed"> 4066   if (opcode == Op_AbsVF) {</span>
<span class="line-removed"> 4067     vandps(dst, src, ExternalAddress(StubRoutines::x86::vector_float_sign_mask()), vector_len, scr);</span>
<span class="line-removed"> 4068   } else {</span>
<span class="line-removed"> 4069     assert((opcode == Op_NegVF),&quot;opcode should be Op_NegF&quot;);</span>
<span class="line-removed"> 4070     vxorps(dst, src, ExternalAddress(StubRoutines::x86::vector_float_sign_flip()), vector_len, scr);</span>
<span class="line-removed"> 4071   }</span>
<span class="line-removed"> 4072 }</span>
<span class="line-removed"> 4073 </span>
<span class="line-removed"> 4074 void MacroAssembler::vextendbw(bool sign, XMMRegister dst, XMMRegister src) {</span>
<span class="line-removed"> 4075   if (sign) {</span>
<span class="line-removed"> 4076     pmovsxbw(dst, src);</span>
<span class="line-removed"> 4077   } else {</span>
<span class="line-removed"> 4078     pmovzxbw(dst, src);</span>
<span class="line-removed"> 4079   }</span>
<span class="line-removed"> 4080 }</span>
<span class="line-removed"> 4081 </span>
<span class="line-removed"> 4082 void MacroAssembler::vextendbw(bool sign, XMMRegister dst, XMMRegister src, int vector_len) {</span>
<span class="line-removed"> 4083   if (sign) {</span>
<span class="line-removed"> 4084     vpmovsxbw(dst, src, vector_len);</span>
<span class="line-removed"> 4085   } else {</span>
<span class="line-removed"> 4086     vpmovzxbw(dst, src, vector_len);</span>
<span class="line-removed"> 4087   }</span>
<span class="line-removed"> 4088 }</span>
<span class="line-removed"> 4089 </span>
<span class="line-removed"> 4090 void MacroAssembler::vshiftd(int opcode, XMMRegister dst, XMMRegister src) {</span>
<span class="line-removed"> 4091   if (opcode == Op_RShiftVI) {</span>
<span class="line-removed"> 4092     psrad(dst, src);</span>
<span class="line-removed"> 4093   } else if (opcode == Op_LShiftVI) {</span>
<span class="line-removed"> 4094     pslld(dst, src);</span>
<span class="line-removed"> 4095   } else {</span>
<span class="line-removed"> 4096     assert((opcode == Op_URShiftVI),&quot;opcode should be Op_URShiftVI&quot;);</span>
<span class="line-removed"> 4097     psrld(dst, src);</span>
<span class="line-removed"> 4098   }</span>
<span class="line-removed"> 4099 }</span>
<span class="line-removed"> 4100 </span>
<span class="line-removed"> 4101 void MacroAssembler::vshiftd(int opcode, XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {</span>
<span class="line-removed"> 4102   if (opcode == Op_RShiftVI) {</span>
<span class="line-removed"> 4103     vpsrad(dst, nds, src, vector_len);</span>
<span class="line-removed"> 4104   } else if (opcode == Op_LShiftVI) {</span>
<span class="line-removed"> 4105     vpslld(dst, nds, src, vector_len);</span>
<span class="line-removed"> 4106   } else {</span>
<span class="line-removed"> 4107     assert((opcode == Op_URShiftVI),&quot;opcode should be Op_URShiftVI&quot;);</span>
<span class="line-removed"> 4108     vpsrld(dst, nds, src, vector_len);</span>
<span class="line-removed"> 4109   }</span>
<span class="line-removed"> 4110 }</span>
<span class="line-removed"> 4111 </span>
<span class="line-removed"> 4112 void MacroAssembler::vshiftw(int opcode, XMMRegister dst, XMMRegister src) {</span>
<span class="line-removed"> 4113   if ((opcode == Op_RShiftVS) || (opcode == Op_RShiftVB)) {</span>
<span class="line-removed"> 4114     psraw(dst, src);</span>
<span class="line-removed"> 4115   } else if ((opcode == Op_LShiftVS) || (opcode == Op_LShiftVB)) {</span>
<span class="line-removed"> 4116     psllw(dst, src);</span>
<span class="line-removed"> 4117   } else {</span>
<span class="line-removed"> 4118     assert(((opcode == Op_URShiftVS) || (opcode == Op_URShiftVB)),&quot;opcode should be one of Op_URShiftVS or Op_URShiftVB&quot;);</span>
<span class="line-removed"> 4119     psrlw(dst, src);</span>
<span class="line-removed"> 4120   }</span>
<span class="line-removed"> 4121 }</span>
<span class="line-removed"> 4122 </span>
<span class="line-removed"> 4123 void MacroAssembler::vshiftw(int opcode, XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {</span>
<span class="line-removed"> 4124   if ((opcode == Op_RShiftVS) || (opcode == Op_RShiftVB)) {</span>
<span class="line-removed"> 4125     vpsraw(dst, nds, src, vector_len);</span>
<span class="line-removed"> 4126   } else if ((opcode == Op_LShiftVS) || (opcode == Op_LShiftVB)) {</span>
<span class="line-removed"> 4127     vpsllw(dst, nds, src, vector_len);</span>
<span class="line-removed"> 4128   } else {</span>
<span class="line-removed"> 4129     assert(((opcode == Op_URShiftVS) || (opcode == Op_URShiftVB)),&quot;opcode should be one of Op_URShiftVS or Op_URShiftVB&quot;);</span>
<span class="line-removed"> 4130     vpsrlw(dst, nds, src, vector_len);</span>
<span class="line-removed"> 4131   }</span>
<span class="line-removed"> 4132 }</span>
<span class="line-removed"> 4133 </span>
<span class="line-removed"> 4134 void MacroAssembler::vshiftq(int opcode, XMMRegister dst, XMMRegister src) {</span>
<span class="line-removed"> 4135   if (opcode == Op_RShiftVL) {</span>
<span class="line-removed"> 4136     psrlq(dst, src);  // using srl to implement sra on pre-avs512 systems</span>
<span class="line-removed"> 4137   } else if (opcode == Op_LShiftVL) {</span>
<span class="line-removed"> 4138     psllq(dst, src);</span>
<span class="line-removed"> 4139   } else {</span>
<span class="line-removed"> 4140     assert((opcode == Op_URShiftVL),&quot;opcode should be Op_URShiftVL&quot;);</span>
<span class="line-removed"> 4141     psrlq(dst, src);</span>
<span class="line-removed"> 4142   }</span>
<span class="line-removed"> 4143 }</span>
<span class="line-removed"> 4144 </span>
<span class="line-removed"> 4145 void MacroAssembler::vshiftq(int opcode, XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {</span>
<span class="line-removed"> 4146   if (opcode == Op_RShiftVL) {</span>
<span class="line-removed"> 4147     evpsraq(dst, nds, src, vector_len);</span>
<span class="line-removed"> 4148   } else if (opcode == Op_LShiftVL) {</span>
<span class="line-removed"> 4149     vpsllq(dst, nds, src, vector_len);</span>
<span class="line-removed"> 4150   } else {</span>
<span class="line-removed"> 4151     assert((opcode == Op_URShiftVL),&quot;opcode should be Op_URShiftVL&quot;);</span>
<span class="line-removed"> 4152     vpsrlq(dst, nds, src, vector_len);</span>
<span class="line-removed"> 4153   }</span>
<span class="line-removed"> 4154 }</span>
<span class="line-removed"> 4155 #endif</span>
 4156 //-------------------------------------------------------------------------------------------
 4157 
 4158 void MacroAssembler::clear_jweak_tag(Register possibly_jweak) {
 4159   const int32_t inverted_jweak_mask = ~static_cast&lt;int32_t&gt;(JNIHandles::weak_tag_mask);
 4160   STATIC_ASSERT(inverted_jweak_mask == -2); // otherwise check this code
 4161   // The inverted mask is sign-extended
 4162   andptr(possibly_jweak, inverted_jweak_mask);
 4163 }
 4164 
 4165 void MacroAssembler::resolve_jobject(Register value,
 4166                                      Register thread,
 4167                                      Register tmp) {
 4168   assert_different_registers(value, thread, tmp);
 4169   Label done, not_weak;
 4170   testptr(value, value);
 4171   jcc(Assembler::zero, done);                // Use NULL as-is.
 4172   testptr(value, JNIHandles::weak_tag_mask); // Test for jweak tag.
 4173   jcc(Assembler::zero, not_weak);
 4174   // Resolve jweak.
 4175   access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF,
</pre>
<hr />
<pre>
 4650     b = code_string(ss.as_string());
 4651   }
 4652   BLOCK_COMMENT(&quot;verify_oop {&quot;);
 4653 #ifdef _LP64
 4654   push(rscratch1);                    // save r10, trashed by movptr()
 4655 #endif
 4656   push(rax);                          // save rax,
 4657   push(reg);                          // pass register argument
 4658   ExternalAddress buffer((address) b);
 4659   // avoid using pushptr, as it modifies scratch registers
 4660   // and our contract is not to modify anything
 4661   movptr(rax, buffer.addr());
 4662   push(rax);
 4663   // call indirectly to solve generation ordering problem
 4664   movptr(rax, ExternalAddress(StubRoutines::verify_oop_subroutine_entry_address()));
 4665   call(rax);
 4666   // Caller pops the arguments (oop, message) and restores rax, r10
 4667   BLOCK_COMMENT(&quot;} verify_oop&quot;);
 4668 }
 4669 








 4670 
 4671 RegisterOrConstant MacroAssembler::delayed_value_impl(intptr_t* delayed_value_addr,
 4672                                                       Register tmp,
 4673                                                       int offset) {
 4674   intptr_t value = *delayed_value_addr;
 4675   if (value != 0)
 4676     return RegisterOrConstant(value + offset);
 4677 
 4678   // load indirectly to solve generation ordering problem
 4679   movptr(tmp, ExternalAddress((address) delayed_value_addr));
 4680 
 4681 #ifdef ASSERT
 4682   { Label L;
 4683     testptr(tmp, tmp);
 4684     if (WizardMode) {
 4685       const char* buf = NULL;
 4686       {
 4687         ResourceMark rm;
 4688         stringStream ss;
 4689         ss.print(&quot;DelayedValue=&quot; INTPTR_FORMAT, delayed_value_addr[1]);
</pre>
<hr />
<pre>
 5806     jmpb(DONE);
 5807 
 5808     BIND(LONG);
 5809   }
 5810 
 5811   // Use longer rep-prefixed ops for non-small counts:
 5812   if (UseFastStosb) {
 5813     shlptr(cnt, 3); // convert to number of bytes
 5814     rep_stosb();
 5815   } else if (UseXMMForObjInit) {
 5816     movptr(tmp, base);
 5817     xmm_clear_mem(tmp, cnt, xtmp);
 5818   } else {
 5819     NOT_LP64(shlptr(cnt, 1);) // convert to number of 32-bit words for 32-bit VM
 5820     rep_stos();
 5821   }
 5822 
 5823   BIND(DONE);
 5824 }
 5825 
<span class="line-removed"> 5826 #ifdef COMPILER2</span>
<span class="line-removed"> 5827 </span>
<span class="line-removed"> 5828 // IndexOf for constant substrings with size &gt;= 8 chars</span>
<span class="line-removed"> 5829 // which don&#39;t need to be loaded through stack.</span>
<span class="line-removed"> 5830 void MacroAssembler::string_indexofC8(Register str1, Register str2,</span>
<span class="line-removed"> 5831                                       Register cnt1, Register cnt2,</span>
<span class="line-removed"> 5832                                       int int_cnt2,  Register result,</span>
<span class="line-removed"> 5833                                       XMMRegister vec, Register tmp,</span>
<span class="line-removed"> 5834                                       int ae) {</span>
<span class="line-removed"> 5835   ShortBranchVerifier sbv(this);</span>
<span class="line-removed"> 5836   assert(UseSSE42Intrinsics, &quot;SSE4.2 intrinsics are required&quot;);</span>
<span class="line-removed"> 5837   assert(ae != StrIntrinsicNode::LU, &quot;Invalid encoding&quot;);</span>
<span class="line-removed"> 5838 </span>
<span class="line-removed"> 5839   // This method uses the pcmpestri instruction with bound registers</span>
<span class="line-removed"> 5840   //   inputs:</span>
<span class="line-removed"> 5841   //     xmm - substring</span>
<span class="line-removed"> 5842   //     rax - substring length (elements count)</span>
<span class="line-removed"> 5843   //     mem - scanned string</span>
<span class="line-removed"> 5844   //     rdx - string length (elements count)</span>
<span class="line-removed"> 5845   //     0xd - mode: 1100 (substring search) + 01 (unsigned shorts)</span>
<span class="line-removed"> 5846   //     0xc - mode: 1100 (substring search) + 00 (unsigned bytes)</span>
<span class="line-removed"> 5847   //   outputs:</span>
<span class="line-removed"> 5848   //     rcx - matched index in string</span>
<span class="line-removed"> 5849   assert(cnt1 == rdx &amp;&amp; cnt2 == rax &amp;&amp; tmp == rcx, &quot;pcmpestri&quot;);</span>
<span class="line-removed"> 5850   int mode   = (ae == StrIntrinsicNode::LL) ? 0x0c : 0x0d; // bytes or shorts</span>
<span class="line-removed"> 5851   int stride = (ae == StrIntrinsicNode::LL) ? 16 : 8; //UU, UL -&gt; 8</span>
<span class="line-removed"> 5852   Address::ScaleFactor scale1 = (ae == StrIntrinsicNode::LL) ? Address::times_1 : Address::times_2;</span>
<span class="line-removed"> 5853   Address::ScaleFactor scale2 = (ae == StrIntrinsicNode::UL) ? Address::times_1 : scale1;</span>
<span class="line-removed"> 5854 </span>
<span class="line-removed"> 5855   Label RELOAD_SUBSTR, SCAN_TO_SUBSTR, SCAN_SUBSTR,</span>
<span class="line-removed"> 5856         RET_FOUND, RET_NOT_FOUND, EXIT, FOUND_SUBSTR,</span>
<span class="line-removed"> 5857         MATCH_SUBSTR_HEAD, RELOAD_STR, FOUND_CANDIDATE;</span>
<span class="line-removed"> 5858 </span>
<span class="line-removed"> 5859   // Note, inline_string_indexOf() generates checks:</span>
<span class="line-removed"> 5860   // if (substr.count &gt; string.count) return -1;</span>
<span class="line-removed"> 5861   // if (substr.count == 0) return 0;</span>
<span class="line-removed"> 5862   assert(int_cnt2 &gt;= stride, &quot;this code is used only for cnt2 &gt;= 8 chars&quot;);</span>
<span class="line-removed"> 5863 </span>
<span class="line-removed"> 5864   // Load substring.</span>
<span class="line-removed"> 5865   if (ae == StrIntrinsicNode::UL) {</span>
<span class="line-removed"> 5866     pmovzxbw(vec, Address(str2, 0));</span>
<span class="line-removed"> 5867   } else {</span>
<span class="line-removed"> 5868     movdqu(vec, Address(str2, 0));</span>
<span class="line-removed"> 5869   }</span>
<span class="line-removed"> 5870   movl(cnt2, int_cnt2);</span>
<span class="line-removed"> 5871   movptr(result, str1); // string addr</span>
<span class="line-removed"> 5872 </span>
<span class="line-removed"> 5873   if (int_cnt2 &gt; stride) {</span>
<span class="line-removed"> 5874     jmpb(SCAN_TO_SUBSTR);</span>
<span class="line-removed"> 5875 </span>
<span class="line-removed"> 5876     // Reload substr for rescan, this code</span>
<span class="line-removed"> 5877     // is executed only for large substrings (&gt; 8 chars)</span>
<span class="line-removed"> 5878     bind(RELOAD_SUBSTR);</span>
<span class="line-removed"> 5879     if (ae == StrIntrinsicNode::UL) {</span>
<span class="line-removed"> 5880       pmovzxbw(vec, Address(str2, 0));</span>
<span class="line-removed"> 5881     } else {</span>
<span class="line-removed"> 5882       movdqu(vec, Address(str2, 0));</span>
<span class="line-removed"> 5883     }</span>
<span class="line-removed"> 5884     negptr(cnt2); // Jumped here with negative cnt2, convert to positive</span>
<span class="line-removed"> 5885 </span>
<span class="line-removed"> 5886     bind(RELOAD_STR);</span>
<span class="line-removed"> 5887     // We came here after the beginning of the substring was</span>
<span class="line-removed"> 5888     // matched but the rest of it was not so we need to search</span>
<span class="line-removed"> 5889     // again. Start from the next element after the previous match.</span>
<span class="line-removed"> 5890 </span>
<span class="line-removed"> 5891     // cnt2 is number of substring reminding elements and</span>
<span class="line-removed"> 5892     // cnt1 is number of string reminding elements when cmp failed.</span>
<span class="line-removed"> 5893     // Restored cnt1 = cnt1 - cnt2 + int_cnt2</span>
<span class="line-removed"> 5894     subl(cnt1, cnt2);</span>
<span class="line-removed"> 5895     addl(cnt1, int_cnt2);</span>
<span class="line-removed"> 5896     movl(cnt2, int_cnt2); // Now restore cnt2</span>
<span class="line-removed"> 5897 </span>
<span class="line-removed"> 5898     decrementl(cnt1);     // Shift to next element</span>
<span class="line-removed"> 5899     cmpl(cnt1, cnt2);</span>
<span class="line-removed"> 5900     jcc(Assembler::negative, RET_NOT_FOUND);  // Left less then substring</span>
<span class="line-removed"> 5901 </span>
<span class="line-removed"> 5902     addptr(result, (1&lt;&lt;scale1));</span>
<span class="line-removed"> 5903 </span>
<span class="line-removed"> 5904   } // (int_cnt2 &gt; 8)</span>
<span class="line-removed"> 5905 </span>
<span class="line-removed"> 5906   // Scan string for start of substr in 16-byte vectors</span>
<span class="line-removed"> 5907   bind(SCAN_TO_SUBSTR);</span>
<span class="line-removed"> 5908   pcmpestri(vec, Address(result, 0), mode);</span>
<span class="line-removed"> 5909   jccb(Assembler::below, FOUND_CANDIDATE);   // CF == 1</span>
<span class="line-removed"> 5910   subl(cnt1, stride);</span>
<span class="line-removed"> 5911   jccb(Assembler::lessEqual, RET_NOT_FOUND); // Scanned full string</span>
<span class="line-removed"> 5912   cmpl(cnt1, cnt2);</span>
<span class="line-removed"> 5913   jccb(Assembler::negative, RET_NOT_FOUND);  // Left less then substring</span>
<span class="line-removed"> 5914   addptr(result, 16);</span>
<span class="line-removed"> 5915   jmpb(SCAN_TO_SUBSTR);</span>
<span class="line-removed"> 5916 </span>
<span class="line-removed"> 5917   // Found a potential substr</span>
<span class="line-removed"> 5918   bind(FOUND_CANDIDATE);</span>
<span class="line-removed"> 5919   // Matched whole vector if first element matched (tmp(rcx) == 0).</span>
<span class="line-removed"> 5920   if (int_cnt2 == stride) {</span>
<span class="line-removed"> 5921     jccb(Assembler::overflow, RET_FOUND);    // OF == 1</span>
<span class="line-removed"> 5922   } else { // int_cnt2 &gt; 8</span>
<span class="line-removed"> 5923     jccb(Assembler::overflow, FOUND_SUBSTR);</span>
<span class="line-removed"> 5924   }</span>
<span class="line-removed"> 5925   // After pcmpestri tmp(rcx) contains matched element index</span>
<span class="line-removed"> 5926   // Compute start addr of substr</span>
<span class="line-removed"> 5927   lea(result, Address(result, tmp, scale1));</span>
<span class="line-removed"> 5928 </span>
<span class="line-removed"> 5929   // Make sure string is still long enough</span>
<span class="line-removed"> 5930   subl(cnt1, tmp);</span>
<span class="line-removed"> 5931   cmpl(cnt1, cnt2);</span>
<span class="line-removed"> 5932   if (int_cnt2 == stride) {</span>
<span class="line-removed"> 5933     jccb(Assembler::greaterEqual, SCAN_TO_SUBSTR);</span>
<span class="line-removed"> 5934   } else { // int_cnt2 &gt; 8</span>
<span class="line-removed"> 5935     jccb(Assembler::greaterEqual, MATCH_SUBSTR_HEAD);</span>
<span class="line-removed"> 5936   }</span>
<span class="line-removed"> 5937   // Left less then substring.</span>
<span class="line-removed"> 5938 </span>
<span class="line-removed"> 5939   bind(RET_NOT_FOUND);</span>
<span class="line-removed"> 5940   movl(result, -1);</span>
<span class="line-removed"> 5941   jmp(EXIT);</span>
<span class="line-removed"> 5942 </span>
<span class="line-removed"> 5943   if (int_cnt2 &gt; stride) {</span>
<span class="line-removed"> 5944     // This code is optimized for the case when whole substring</span>
<span class="line-removed"> 5945     // is matched if its head is matched.</span>
<span class="line-removed"> 5946     bind(MATCH_SUBSTR_HEAD);</span>
<span class="line-removed"> 5947     pcmpestri(vec, Address(result, 0), mode);</span>
<span class="line-removed"> 5948     // Reload only string if does not match</span>
<span class="line-removed"> 5949     jcc(Assembler::noOverflow, RELOAD_STR); // OF == 0</span>
<span class="line-removed"> 5950 </span>
<span class="line-removed"> 5951     Label CONT_SCAN_SUBSTR;</span>
<span class="line-removed"> 5952     // Compare the rest of substring (&gt; 8 chars).</span>
<span class="line-removed"> 5953     bind(FOUND_SUBSTR);</span>
<span class="line-removed"> 5954     // First 8 chars are already matched.</span>
<span class="line-removed"> 5955     negptr(cnt2);</span>
<span class="line-removed"> 5956     addptr(cnt2, stride);</span>
<span class="line-removed"> 5957 </span>
<span class="line-removed"> 5958     bind(SCAN_SUBSTR);</span>
<span class="line-removed"> 5959     subl(cnt1, stride);</span>
<span class="line-removed"> 5960     cmpl(cnt2, -stride); // Do not read beyond substring</span>
<span class="line-removed"> 5961     jccb(Assembler::lessEqual, CONT_SCAN_SUBSTR);</span>
<span class="line-removed"> 5962     // Back-up strings to avoid reading beyond substring:</span>
<span class="line-removed"> 5963     // cnt1 = cnt1 - cnt2 + 8</span>
<span class="line-removed"> 5964     addl(cnt1, cnt2); // cnt2 is negative</span>
<span class="line-removed"> 5965     addl(cnt1, stride);</span>
<span class="line-removed"> 5966     movl(cnt2, stride); negptr(cnt2);</span>
<span class="line-removed"> 5967     bind(CONT_SCAN_SUBSTR);</span>
<span class="line-removed"> 5968     if (int_cnt2 &lt; (int)G) {</span>
<span class="line-removed"> 5969       int tail_off1 = int_cnt2&lt;&lt;scale1;</span>
<span class="line-removed"> 5970       int tail_off2 = int_cnt2&lt;&lt;scale2;</span>
<span class="line-removed"> 5971       if (ae == StrIntrinsicNode::UL) {</span>
<span class="line-removed"> 5972         pmovzxbw(vec, Address(str2, cnt2, scale2, tail_off2));</span>
<span class="line-removed"> 5973       } else {</span>
<span class="line-removed"> 5974         movdqu(vec, Address(str2, cnt2, scale2, tail_off2));</span>
<span class="line-removed"> 5975       }</span>
<span class="line-removed"> 5976       pcmpestri(vec, Address(result, cnt2, scale1, tail_off1), mode);</span>
<span class="line-removed"> 5977     } else {</span>
<span class="line-removed"> 5978       // calculate index in register to avoid integer overflow (int_cnt2*2)</span>
<span class="line-removed"> 5979       movl(tmp, int_cnt2);</span>
<span class="line-removed"> 5980       addptr(tmp, cnt2);</span>
<span class="line-removed"> 5981       if (ae == StrIntrinsicNode::UL) {</span>
<span class="line-removed"> 5982         pmovzxbw(vec, Address(str2, tmp, scale2, 0));</span>
<span class="line-removed"> 5983       } else {</span>
<span class="line-removed"> 5984         movdqu(vec, Address(str2, tmp, scale2, 0));</span>
<span class="line-removed"> 5985       }</span>
<span class="line-removed"> 5986       pcmpestri(vec, Address(result, tmp, scale1, 0), mode);</span>
<span class="line-removed"> 5987     }</span>
<span class="line-removed"> 5988     // Need to reload strings pointers if not matched whole vector</span>
<span class="line-removed"> 5989     jcc(Assembler::noOverflow, RELOAD_SUBSTR); // OF == 0</span>
<span class="line-removed"> 5990     addptr(cnt2, stride);</span>
<span class="line-removed"> 5991     jcc(Assembler::negative, SCAN_SUBSTR);</span>
<span class="line-removed"> 5992     // Fall through if found full substring</span>
<span class="line-removed"> 5993 </span>
<span class="line-removed"> 5994   } // (int_cnt2 &gt; 8)</span>
<span class="line-removed"> 5995 </span>
<span class="line-removed"> 5996   bind(RET_FOUND);</span>
<span class="line-removed"> 5997   // Found result if we matched full small substring.</span>
<span class="line-removed"> 5998   // Compute substr offset</span>
<span class="line-removed"> 5999   subptr(result, str1);</span>
<span class="line-removed"> 6000   if (ae == StrIntrinsicNode::UU || ae == StrIntrinsicNode::UL) {</span>
<span class="line-removed"> 6001     shrl(result, 1); // index</span>
<span class="line-removed"> 6002   }</span>
<span class="line-removed"> 6003   bind(EXIT);</span>
<span class="line-removed"> 6004 </span>
<span class="line-removed"> 6005 } // string_indexofC8</span>
<span class="line-removed"> 6006 </span>
<span class="line-removed"> 6007 // Small strings are loaded through stack if they cross page boundary.</span>
<span class="line-removed"> 6008 void MacroAssembler::string_indexof(Register str1, Register str2,</span>
<span class="line-removed"> 6009                                     Register cnt1, Register cnt2,</span>
<span class="line-removed"> 6010                                     int int_cnt2,  Register result,</span>
<span class="line-removed"> 6011                                     XMMRegister vec, Register tmp,</span>
<span class="line-removed"> 6012                                     int ae) {</span>
<span class="line-removed"> 6013   ShortBranchVerifier sbv(this);</span>
<span class="line-removed"> 6014   assert(UseSSE42Intrinsics, &quot;SSE4.2 intrinsics are required&quot;);</span>
<span class="line-removed"> 6015   assert(ae != StrIntrinsicNode::LU, &quot;Invalid encoding&quot;);</span>
<span class="line-removed"> 6016 </span>
<span class="line-removed"> 6017   //</span>
<span class="line-removed"> 6018   // int_cnt2 is length of small (&lt; 8 chars) constant substring</span>
<span class="line-removed"> 6019   // or (-1) for non constant substring in which case its length</span>
<span class="line-removed"> 6020   // is in cnt2 register.</span>
<span class="line-removed"> 6021   //</span>
<span class="line-removed"> 6022   // Note, inline_string_indexOf() generates checks:</span>
<span class="line-removed"> 6023   // if (substr.count &gt; string.count) return -1;</span>
<span class="line-removed"> 6024   // if (substr.count == 0) return 0;</span>
<span class="line-removed"> 6025   //</span>
<span class="line-removed"> 6026   int stride = (ae == StrIntrinsicNode::LL) ? 16 : 8; //UU, UL -&gt; 8</span>
<span class="line-removed"> 6027   assert(int_cnt2 == -1 || (0 &lt; int_cnt2 &amp;&amp; int_cnt2 &lt; stride), &quot;should be != 0&quot;);</span>
<span class="line-removed"> 6028   // This method uses the pcmpestri instruction with bound registers</span>
<span class="line-removed"> 6029   //   inputs:</span>
<span class="line-removed"> 6030   //     xmm - substring</span>
<span class="line-removed"> 6031   //     rax - substring length (elements count)</span>
<span class="line-removed"> 6032   //     mem - scanned string</span>
<span class="line-removed"> 6033   //     rdx - string length (elements count)</span>
<span class="line-removed"> 6034   //     0xd - mode: 1100 (substring search) + 01 (unsigned shorts)</span>
<span class="line-removed"> 6035   //     0xc - mode: 1100 (substring search) + 00 (unsigned bytes)</span>
<span class="line-removed"> 6036   //   outputs:</span>
<span class="line-removed"> 6037   //     rcx - matched index in string</span>
<span class="line-removed"> 6038   assert(cnt1 == rdx &amp;&amp; cnt2 == rax &amp;&amp; tmp == rcx, &quot;pcmpestri&quot;);</span>
<span class="line-removed"> 6039   int mode = (ae == StrIntrinsicNode::LL) ? 0x0c : 0x0d; // bytes or shorts</span>
<span class="line-removed"> 6040   Address::ScaleFactor scale1 = (ae == StrIntrinsicNode::LL) ? Address::times_1 : Address::times_2;</span>
<span class="line-removed"> 6041   Address::ScaleFactor scale2 = (ae == StrIntrinsicNode::UL) ? Address::times_1 : scale1;</span>
<span class="line-removed"> 6042 </span>
<span class="line-removed"> 6043   Label RELOAD_SUBSTR, SCAN_TO_SUBSTR, SCAN_SUBSTR, ADJUST_STR,</span>
<span class="line-removed"> 6044         RET_FOUND, RET_NOT_FOUND, CLEANUP, FOUND_SUBSTR,</span>
<span class="line-removed"> 6045         FOUND_CANDIDATE;</span>
<span class="line-removed"> 6046 </span>
<span class="line-removed"> 6047   { //========================================================</span>
<span class="line-removed"> 6048     // We don&#39;t know where these strings are located</span>
<span class="line-removed"> 6049     // and we can&#39;t read beyond them. Load them through stack.</span>
<span class="line-removed"> 6050     Label BIG_STRINGS, CHECK_STR, COPY_SUBSTR, COPY_STR;</span>
<span class="line-removed"> 6051 </span>
<span class="line-removed"> 6052     movptr(tmp, rsp); // save old SP</span>
<span class="line-removed"> 6053 </span>
<span class="line-removed"> 6054     if (int_cnt2 &gt; 0) {     // small (&lt; 8 chars) constant substring</span>
<span class="line-removed"> 6055       if (int_cnt2 == (1&gt;&gt;scale2)) { // One byte</span>
<span class="line-removed"> 6056         assert((ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UL), &quot;Only possible for latin1 encoding&quot;);</span>
<span class="line-removed"> 6057         load_unsigned_byte(result, Address(str2, 0));</span>
<span class="line-removed"> 6058         movdl(vec, result); // move 32 bits</span>
<span class="line-removed"> 6059       } else if (ae == StrIntrinsicNode::LL &amp;&amp; int_cnt2 == 3) {  // Three bytes</span>
<span class="line-removed"> 6060         // Not enough header space in 32-bit VM: 12+3 = 15.</span>
<span class="line-removed"> 6061         movl(result, Address(str2, -1));</span>
<span class="line-removed"> 6062         shrl(result, 8);</span>
<span class="line-removed"> 6063         movdl(vec, result); // move 32 bits</span>
<span class="line-removed"> 6064       } else if (ae != StrIntrinsicNode::UL &amp;&amp; int_cnt2 == (2&gt;&gt;scale2)) {  // One char</span>
<span class="line-removed"> 6065         load_unsigned_short(result, Address(str2, 0));</span>
<span class="line-removed"> 6066         movdl(vec, result); // move 32 bits</span>
<span class="line-removed"> 6067       } else if (ae != StrIntrinsicNode::UL &amp;&amp; int_cnt2 == (4&gt;&gt;scale2)) { // Two chars</span>
<span class="line-removed"> 6068         movdl(vec, Address(str2, 0)); // move 32 bits</span>
<span class="line-removed"> 6069       } else if (ae != StrIntrinsicNode::UL &amp;&amp; int_cnt2 == (8&gt;&gt;scale2)) { // Four chars</span>
<span class="line-removed"> 6070         movq(vec, Address(str2, 0));  // move 64 bits</span>
<span class="line-removed"> 6071       } else { // cnt2 = { 3, 5, 6, 7 } || (ae == StrIntrinsicNode::UL &amp;&amp; cnt2 ={2, ..., 7})</span>
<span class="line-removed"> 6072         // Array header size is 12 bytes in 32-bit VM</span>
<span class="line-removed"> 6073         // + 6 bytes for 3 chars == 18 bytes,</span>
<span class="line-removed"> 6074         // enough space to load vec and shift.</span>
<span class="line-removed"> 6075         assert(HeapWordSize*TypeArrayKlass::header_size() &gt;= 12,&quot;sanity&quot;);</span>
<span class="line-removed"> 6076         if (ae == StrIntrinsicNode::UL) {</span>
<span class="line-removed"> 6077           int tail_off = int_cnt2-8;</span>
<span class="line-removed"> 6078           pmovzxbw(vec, Address(str2, tail_off));</span>
<span class="line-removed"> 6079           psrldq(vec, -2*tail_off);</span>
<span class="line-removed"> 6080         }</span>
<span class="line-removed"> 6081         else {</span>
<span class="line-removed"> 6082           int tail_off = int_cnt2*(1&lt;&lt;scale2);</span>
<span class="line-removed"> 6083           movdqu(vec, Address(str2, tail_off-16));</span>
<span class="line-removed"> 6084           psrldq(vec, 16-tail_off);</span>
<span class="line-removed"> 6085         }</span>
<span class="line-removed"> 6086       }</span>
<span class="line-removed"> 6087     } else { // not constant substring</span>
<span class="line-removed"> 6088       cmpl(cnt2, stride);</span>
<span class="line-removed"> 6089       jccb(Assembler::aboveEqual, BIG_STRINGS); // Both strings are big enough</span>
<span class="line-removed"> 6090 </span>
<span class="line-removed"> 6091       // We can read beyond string if srt+16 does not cross page boundary</span>
<span class="line-removed"> 6092       // since heaps are aligned and mapped by pages.</span>
<span class="line-removed"> 6093       assert(os::vm_page_size() &lt; (int)G, &quot;default page should be small&quot;);</span>
<span class="line-removed"> 6094       movl(result, str2); // We need only low 32 bits</span>
<span class="line-removed"> 6095       andl(result, (os::vm_page_size()-1));</span>
<span class="line-removed"> 6096       cmpl(result, (os::vm_page_size()-16));</span>
<span class="line-removed"> 6097       jccb(Assembler::belowEqual, CHECK_STR);</span>
<span class="line-removed"> 6098 </span>
<span class="line-removed"> 6099       // Move small strings to stack to allow load 16 bytes into vec.</span>
<span class="line-removed"> 6100       subptr(rsp, 16);</span>
<span class="line-removed"> 6101       int stk_offset = wordSize-(1&lt;&lt;scale2);</span>
<span class="line-removed"> 6102       push(cnt2);</span>
<span class="line-removed"> 6103 </span>
<span class="line-removed"> 6104       bind(COPY_SUBSTR);</span>
<span class="line-removed"> 6105       if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UL) {</span>
<span class="line-removed"> 6106         load_unsigned_byte(result, Address(str2, cnt2, scale2, -1));</span>
<span class="line-removed"> 6107         movb(Address(rsp, cnt2, scale2, stk_offset), result);</span>
<span class="line-removed"> 6108       } else if (ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed"> 6109         load_unsigned_short(result, Address(str2, cnt2, scale2, -2));</span>
<span class="line-removed"> 6110         movw(Address(rsp, cnt2, scale2, stk_offset), result);</span>
<span class="line-removed"> 6111       }</span>
<span class="line-removed"> 6112       decrement(cnt2);</span>
<span class="line-removed"> 6113       jccb(Assembler::notZero, COPY_SUBSTR);</span>
<span class="line-removed"> 6114 </span>
<span class="line-removed"> 6115       pop(cnt2);</span>
<span class="line-removed"> 6116       movptr(str2, rsp);  // New substring address</span>
<span class="line-removed"> 6117     } // non constant</span>
<span class="line-removed"> 6118 </span>
<span class="line-removed"> 6119     bind(CHECK_STR);</span>
<span class="line-removed"> 6120     cmpl(cnt1, stride);</span>
<span class="line-removed"> 6121     jccb(Assembler::aboveEqual, BIG_STRINGS);</span>
<span class="line-removed"> 6122 </span>
<span class="line-removed"> 6123     // Check cross page boundary.</span>
<span class="line-removed"> 6124     movl(result, str1); // We need only low 32 bits</span>
<span class="line-removed"> 6125     andl(result, (os::vm_page_size()-1));</span>
<span class="line-removed"> 6126     cmpl(result, (os::vm_page_size()-16));</span>
<span class="line-removed"> 6127     jccb(Assembler::belowEqual, BIG_STRINGS);</span>
<span class="line-removed"> 6128 </span>
<span class="line-removed"> 6129     subptr(rsp, 16);</span>
<span class="line-removed"> 6130     int stk_offset = -(1&lt;&lt;scale1);</span>
<span class="line-removed"> 6131     if (int_cnt2 &lt; 0) { // not constant</span>
<span class="line-removed"> 6132       push(cnt2);</span>
<span class="line-removed"> 6133       stk_offset += wordSize;</span>
<span class="line-removed"> 6134     }</span>
<span class="line-removed"> 6135     movl(cnt2, cnt1);</span>
<span class="line-removed"> 6136 </span>
<span class="line-removed"> 6137     bind(COPY_STR);</span>
<span class="line-removed"> 6138     if (ae == StrIntrinsicNode::LL) {</span>
<span class="line-removed"> 6139       load_unsigned_byte(result, Address(str1, cnt2, scale1, -1));</span>
<span class="line-removed"> 6140       movb(Address(rsp, cnt2, scale1, stk_offset), result);</span>
<span class="line-removed"> 6141     } else {</span>
<span class="line-removed"> 6142       load_unsigned_short(result, Address(str1, cnt2, scale1, -2));</span>
<span class="line-removed"> 6143       movw(Address(rsp, cnt2, scale1, stk_offset), result);</span>
<span class="line-removed"> 6144     }</span>
<span class="line-removed"> 6145     decrement(cnt2);</span>
<span class="line-removed"> 6146     jccb(Assembler::notZero, COPY_STR);</span>
<span class="line-removed"> 6147 </span>
<span class="line-removed"> 6148     if (int_cnt2 &lt; 0) { // not constant</span>
<span class="line-removed"> 6149       pop(cnt2);</span>
<span class="line-removed"> 6150     }</span>
<span class="line-removed"> 6151     movptr(str1, rsp);  // New string address</span>
<span class="line-removed"> 6152 </span>
<span class="line-removed"> 6153     bind(BIG_STRINGS);</span>
<span class="line-removed"> 6154     // Load substring.</span>
<span class="line-removed"> 6155     if (int_cnt2 &lt; 0) { // -1</span>
<span class="line-removed"> 6156       if (ae == StrIntrinsicNode::UL) {</span>
<span class="line-removed"> 6157         pmovzxbw(vec, Address(str2, 0));</span>
<span class="line-removed"> 6158       } else {</span>
<span class="line-removed"> 6159         movdqu(vec, Address(str2, 0));</span>
<span class="line-removed"> 6160       }</span>
<span class="line-removed"> 6161       push(cnt2);       // substr count</span>
<span class="line-removed"> 6162       push(str2);       // substr addr</span>
<span class="line-removed"> 6163       push(str1);       // string addr</span>
<span class="line-removed"> 6164     } else {</span>
<span class="line-removed"> 6165       // Small (&lt; 8 chars) constant substrings are loaded already.</span>
<span class="line-removed"> 6166       movl(cnt2, int_cnt2);</span>
<span class="line-removed"> 6167     }</span>
<span class="line-removed"> 6168     push(tmp);  // original SP</span>
<span class="line-removed"> 6169 </span>
<span class="line-removed"> 6170   } // Finished loading</span>
<span class="line-removed"> 6171 </span>
<span class="line-removed"> 6172   //========================================================</span>
<span class="line-removed"> 6173   // Start search</span>
<span class="line-removed"> 6174   //</span>
<span class="line-removed"> 6175 </span>
<span class="line-removed"> 6176   movptr(result, str1); // string addr</span>
<span class="line-removed"> 6177 </span>
<span class="line-removed"> 6178   if (int_cnt2  &lt; 0) {  // Only for non constant substring</span>
<span class="line-removed"> 6179     jmpb(SCAN_TO_SUBSTR);</span>
<span class="line-removed"> 6180 </span>
<span class="line-removed"> 6181     // SP saved at sp+0</span>
<span class="line-removed"> 6182     // String saved at sp+1*wordSize</span>
<span class="line-removed"> 6183     // Substr saved at sp+2*wordSize</span>
<span class="line-removed"> 6184     // Substr count saved at sp+3*wordSize</span>
<span class="line-removed"> 6185 </span>
<span class="line-removed"> 6186     // Reload substr for rescan, this code</span>
<span class="line-removed"> 6187     // is executed only for large substrings (&gt; 8 chars)</span>
<span class="line-removed"> 6188     bind(RELOAD_SUBSTR);</span>
<span class="line-removed"> 6189     movptr(str2, Address(rsp, 2*wordSize));</span>
<span class="line-removed"> 6190     movl(cnt2, Address(rsp, 3*wordSize));</span>
<span class="line-removed"> 6191     if (ae == StrIntrinsicNode::UL) {</span>
<span class="line-removed"> 6192       pmovzxbw(vec, Address(str2, 0));</span>
<span class="line-removed"> 6193     } else {</span>
<span class="line-removed"> 6194       movdqu(vec, Address(str2, 0));</span>
<span class="line-removed"> 6195     }</span>
<span class="line-removed"> 6196     // We came here after the beginning of the substring was</span>
<span class="line-removed"> 6197     // matched but the rest of it was not so we need to search</span>
<span class="line-removed"> 6198     // again. Start from the next element after the previous match.</span>
<span class="line-removed"> 6199     subptr(str1, result); // Restore counter</span>
<span class="line-removed"> 6200     if (ae == StrIntrinsicNode::UU || ae == StrIntrinsicNode::UL) {</span>
<span class="line-removed"> 6201       shrl(str1, 1);</span>
<span class="line-removed"> 6202     }</span>
<span class="line-removed"> 6203     addl(cnt1, str1);</span>
<span class="line-removed"> 6204     decrementl(cnt1);   // Shift to next element</span>
<span class="line-removed"> 6205     cmpl(cnt1, cnt2);</span>
<span class="line-removed"> 6206     jcc(Assembler::negative, RET_NOT_FOUND);  // Left less then substring</span>
<span class="line-removed"> 6207 </span>
<span class="line-removed"> 6208     addptr(result, (1&lt;&lt;scale1));</span>
<span class="line-removed"> 6209   } // non constant</span>
<span class="line-removed"> 6210 </span>
<span class="line-removed"> 6211   // Scan string for start of substr in 16-byte vectors</span>
<span class="line-removed"> 6212   bind(SCAN_TO_SUBSTR);</span>
<span class="line-removed"> 6213   assert(cnt1 == rdx &amp;&amp; cnt2 == rax &amp;&amp; tmp == rcx, &quot;pcmpestri&quot;);</span>
<span class="line-removed"> 6214   pcmpestri(vec, Address(result, 0), mode);</span>
<span class="line-removed"> 6215   jccb(Assembler::below, FOUND_CANDIDATE);   // CF == 1</span>
<span class="line-removed"> 6216   subl(cnt1, stride);</span>
<span class="line-removed"> 6217   jccb(Assembler::lessEqual, RET_NOT_FOUND); // Scanned full string</span>
<span class="line-removed"> 6218   cmpl(cnt1, cnt2);</span>
<span class="line-removed"> 6219   jccb(Assembler::negative, RET_NOT_FOUND);  // Left less then substring</span>
<span class="line-removed"> 6220   addptr(result, 16);</span>
<span class="line-removed"> 6221 </span>
<span class="line-removed"> 6222   bind(ADJUST_STR);</span>
<span class="line-removed"> 6223   cmpl(cnt1, stride); // Do not read beyond string</span>
<span class="line-removed"> 6224   jccb(Assembler::greaterEqual, SCAN_TO_SUBSTR);</span>
<span class="line-removed"> 6225   // Back-up string to avoid reading beyond string.</span>
<span class="line-removed"> 6226   lea(result, Address(result, cnt1, scale1, -16));</span>
<span class="line-removed"> 6227   movl(cnt1, stride);</span>
<span class="line-removed"> 6228   jmpb(SCAN_TO_SUBSTR);</span>
<span class="line-removed"> 6229 </span>
<span class="line-removed"> 6230   // Found a potential substr</span>
<span class="line-removed"> 6231   bind(FOUND_CANDIDATE);</span>
<span class="line-removed"> 6232   // After pcmpestri tmp(rcx) contains matched element index</span>
<span class="line-removed"> 6233 </span>
<span class="line-removed"> 6234   // Make sure string is still long enough</span>
<span class="line-removed"> 6235   subl(cnt1, tmp);</span>
<span class="line-removed"> 6236   cmpl(cnt1, cnt2);</span>
<span class="line-removed"> 6237   jccb(Assembler::greaterEqual, FOUND_SUBSTR);</span>
<span class="line-removed"> 6238   // Left less then substring.</span>
<span class="line-removed"> 6239 </span>
<span class="line-removed"> 6240   bind(RET_NOT_FOUND);</span>
<span class="line-removed"> 6241   movl(result, -1);</span>
<span class="line-removed"> 6242   jmp(CLEANUP);</span>
<span class="line-removed"> 6243 </span>
<span class="line-removed"> 6244   bind(FOUND_SUBSTR);</span>
<span class="line-removed"> 6245   // Compute start addr of substr</span>
<span class="line-removed"> 6246   lea(result, Address(result, tmp, scale1));</span>
<span class="line-removed"> 6247   if (int_cnt2 &gt; 0) { // Constant substring</span>
<span class="line-removed"> 6248     // Repeat search for small substring (&lt; 8 chars)</span>
<span class="line-removed"> 6249     // from new point without reloading substring.</span>
<span class="line-removed"> 6250     // Have to check that we don&#39;t read beyond string.</span>
<span class="line-removed"> 6251     cmpl(tmp, stride-int_cnt2);</span>
<span class="line-removed"> 6252     jccb(Assembler::greater, ADJUST_STR);</span>
<span class="line-removed"> 6253     // Fall through if matched whole substring.</span>
<span class="line-removed"> 6254   } else { // non constant</span>
<span class="line-removed"> 6255     assert(int_cnt2 == -1, &quot;should be != 0&quot;);</span>
<span class="line-removed"> 6256 </span>
<span class="line-removed"> 6257     addl(tmp, cnt2);</span>
<span class="line-removed"> 6258     // Found result if we matched whole substring.</span>
<span class="line-removed"> 6259     cmpl(tmp, stride);</span>
<span class="line-removed"> 6260     jcc(Assembler::lessEqual, RET_FOUND);</span>
<span class="line-removed"> 6261 </span>
<span class="line-removed"> 6262     // Repeat search for small substring (&lt;= 8 chars)</span>
<span class="line-removed"> 6263     // from new point &#39;str1&#39; without reloading substring.</span>
<span class="line-removed"> 6264     cmpl(cnt2, stride);</span>
<span class="line-removed"> 6265     // Have to check that we don&#39;t read beyond string.</span>
<span class="line-removed"> 6266     jccb(Assembler::lessEqual, ADJUST_STR);</span>
<span class="line-removed"> 6267 </span>
<span class="line-removed"> 6268     Label CHECK_NEXT, CONT_SCAN_SUBSTR, RET_FOUND_LONG;</span>
<span class="line-removed"> 6269     // Compare the rest of substring (&gt; 8 chars).</span>
<span class="line-removed"> 6270     movptr(str1, result);</span>
<span class="line-removed"> 6271 </span>
<span class="line-removed"> 6272     cmpl(tmp, cnt2);</span>
<span class="line-removed"> 6273     // First 8 chars are already matched.</span>
<span class="line-removed"> 6274     jccb(Assembler::equal, CHECK_NEXT);</span>
<span class="line-removed"> 6275 </span>
<span class="line-removed"> 6276     bind(SCAN_SUBSTR);</span>
<span class="line-removed"> 6277     pcmpestri(vec, Address(str1, 0), mode);</span>
<span class="line-removed"> 6278     // Need to reload strings pointers if not matched whole vector</span>
<span class="line-removed"> 6279     jcc(Assembler::noOverflow, RELOAD_SUBSTR); // OF == 0</span>
<span class="line-removed"> 6280 </span>
<span class="line-removed"> 6281     bind(CHECK_NEXT);</span>
<span class="line-removed"> 6282     subl(cnt2, stride);</span>
<span class="line-removed"> 6283     jccb(Assembler::lessEqual, RET_FOUND_LONG); // Found full substring</span>
<span class="line-removed"> 6284     addptr(str1, 16);</span>
<span class="line-removed"> 6285     if (ae == StrIntrinsicNode::UL) {</span>
<span class="line-removed"> 6286       addptr(str2, 8);</span>
<span class="line-removed"> 6287     } else {</span>
<span class="line-removed"> 6288       addptr(str2, 16);</span>
<span class="line-removed"> 6289     }</span>
<span class="line-removed"> 6290     subl(cnt1, stride);</span>
<span class="line-removed"> 6291     cmpl(cnt2, stride); // Do not read beyond substring</span>
<span class="line-removed"> 6292     jccb(Assembler::greaterEqual, CONT_SCAN_SUBSTR);</span>
<span class="line-removed"> 6293     // Back-up strings to avoid reading beyond substring.</span>
<span class="line-removed"> 6294 </span>
<span class="line-removed"> 6295     if (ae == StrIntrinsicNode::UL) {</span>
<span class="line-removed"> 6296       lea(str2, Address(str2, cnt2, scale2, -8));</span>
<span class="line-removed"> 6297       lea(str1, Address(str1, cnt2, scale1, -16));</span>
<span class="line-removed"> 6298     } else {</span>
<span class="line-removed"> 6299       lea(str2, Address(str2, cnt2, scale2, -16));</span>
<span class="line-removed"> 6300       lea(str1, Address(str1, cnt2, scale1, -16));</span>
<span class="line-removed"> 6301     }</span>
<span class="line-removed"> 6302     subl(cnt1, cnt2);</span>
<span class="line-removed"> 6303     movl(cnt2, stride);</span>
<span class="line-removed"> 6304     addl(cnt1, stride);</span>
<span class="line-removed"> 6305     bind(CONT_SCAN_SUBSTR);</span>
<span class="line-removed"> 6306     if (ae == StrIntrinsicNode::UL) {</span>
<span class="line-removed"> 6307       pmovzxbw(vec, Address(str2, 0));</span>
<span class="line-removed"> 6308     } else {</span>
<span class="line-removed"> 6309       movdqu(vec, Address(str2, 0));</span>
<span class="line-removed"> 6310     }</span>
<span class="line-removed"> 6311     jmp(SCAN_SUBSTR);</span>
<span class="line-removed"> 6312 </span>
<span class="line-removed"> 6313     bind(RET_FOUND_LONG);</span>
<span class="line-removed"> 6314     movptr(str1, Address(rsp, wordSize));</span>
<span class="line-removed"> 6315   } // non constant</span>
<span class="line-removed"> 6316 </span>
<span class="line-removed"> 6317   bind(RET_FOUND);</span>
<span class="line-removed"> 6318   // Compute substr offset</span>
<span class="line-removed"> 6319   subptr(result, str1);</span>
<span class="line-removed"> 6320   if (ae == StrIntrinsicNode::UU || ae == StrIntrinsicNode::UL) {</span>
<span class="line-removed"> 6321     shrl(result, 1); // index</span>
<span class="line-removed"> 6322   }</span>
<span class="line-removed"> 6323   bind(CLEANUP);</span>
<span class="line-removed"> 6324   pop(rsp); // restore SP</span>
<span class="line-removed"> 6325 </span>
<span class="line-removed"> 6326 } // string_indexof</span>
<span class="line-removed"> 6327 </span>
<span class="line-removed"> 6328 void MacroAssembler::string_indexof_char(Register str1, Register cnt1, Register ch, Register result,</span>
<span class="line-removed"> 6329                                          XMMRegister vec1, XMMRegister vec2, XMMRegister vec3, Register tmp) {</span>
<span class="line-removed"> 6330   ShortBranchVerifier sbv(this);</span>
<span class="line-removed"> 6331   assert(UseSSE42Intrinsics, &quot;SSE4.2 intrinsics are required&quot;);</span>
<span class="line-removed"> 6332 </span>
<span class="line-removed"> 6333   int stride = 8;</span>
<span class="line-removed"> 6334 </span>
<span class="line-removed"> 6335   Label FOUND_CHAR, SCAN_TO_CHAR, SCAN_TO_CHAR_LOOP,</span>
<span class="line-removed"> 6336         SCAN_TO_8_CHAR, SCAN_TO_8_CHAR_LOOP, SCAN_TO_16_CHAR_LOOP,</span>
<span class="line-removed"> 6337         RET_NOT_FOUND, SCAN_TO_8_CHAR_INIT,</span>
<span class="line-removed"> 6338         FOUND_SEQ_CHAR, DONE_LABEL;</span>
<span class="line-removed"> 6339 </span>
<span class="line-removed"> 6340   movptr(result, str1);</span>
<span class="line-removed"> 6341   if (UseAVX &gt;= 2) {</span>
<span class="line-removed"> 6342     cmpl(cnt1, stride);</span>
<span class="line-removed"> 6343     jcc(Assembler::less, SCAN_TO_CHAR);</span>
<span class="line-removed"> 6344     cmpl(cnt1, 2*stride);</span>
<span class="line-removed"> 6345     jcc(Assembler::less, SCAN_TO_8_CHAR_INIT);</span>
<span class="line-removed"> 6346     movdl(vec1, ch);</span>
<span class="line-removed"> 6347     vpbroadcastw(vec1, vec1, Assembler::AVX_256bit);</span>
<span class="line-removed"> 6348     vpxor(vec2, vec2);</span>
<span class="line-removed"> 6349     movl(tmp, cnt1);</span>
<span class="line-removed"> 6350     andl(tmp, 0xFFFFFFF0);  //vector count (in chars)</span>
<span class="line-removed"> 6351     andl(cnt1,0x0000000F);  //tail count (in chars)</span>
<span class="line-removed"> 6352 </span>
<span class="line-removed"> 6353     bind(SCAN_TO_16_CHAR_LOOP);</span>
<span class="line-removed"> 6354     vmovdqu(vec3, Address(result, 0));</span>
<span class="line-removed"> 6355     vpcmpeqw(vec3, vec3, vec1, 1);</span>
<span class="line-removed"> 6356     vptest(vec2, vec3);</span>
<span class="line-removed"> 6357     jcc(Assembler::carryClear, FOUND_CHAR);</span>
<span class="line-removed"> 6358     addptr(result, 32);</span>
<span class="line-removed"> 6359     subl(tmp, 2*stride);</span>
<span class="line-removed"> 6360     jcc(Assembler::notZero, SCAN_TO_16_CHAR_LOOP);</span>
<span class="line-removed"> 6361     jmp(SCAN_TO_8_CHAR);</span>
<span class="line-removed"> 6362     bind(SCAN_TO_8_CHAR_INIT);</span>
<span class="line-removed"> 6363     movdl(vec1, ch);</span>
<span class="line-removed"> 6364     pshuflw(vec1, vec1, 0x00);</span>
<span class="line-removed"> 6365     pshufd(vec1, vec1, 0);</span>
<span class="line-removed"> 6366     pxor(vec2, vec2);</span>
<span class="line-removed"> 6367   }</span>
<span class="line-removed"> 6368   bind(SCAN_TO_8_CHAR);</span>
<span class="line-removed"> 6369   cmpl(cnt1, stride);</span>
<span class="line-removed"> 6370   jcc(Assembler::less, SCAN_TO_CHAR);</span>
<span class="line-removed"> 6371   if (UseAVX &lt; 2) {</span>
<span class="line-removed"> 6372     movdl(vec1, ch);</span>
<span class="line-removed"> 6373     pshuflw(vec1, vec1, 0x00);</span>
<span class="line-removed"> 6374     pshufd(vec1, vec1, 0);</span>
<span class="line-removed"> 6375     pxor(vec2, vec2);</span>
<span class="line-removed"> 6376   }</span>
<span class="line-removed"> 6377   movl(tmp, cnt1);</span>
<span class="line-removed"> 6378   andl(tmp, 0xFFFFFFF8);  //vector count (in chars)</span>
<span class="line-removed"> 6379   andl(cnt1,0x00000007);  //tail count (in chars)</span>
<span class="line-removed"> 6380 </span>
<span class="line-removed"> 6381   bind(SCAN_TO_8_CHAR_LOOP);</span>
<span class="line-removed"> 6382   movdqu(vec3, Address(result, 0));</span>
<span class="line-removed"> 6383   pcmpeqw(vec3, vec1);</span>
<span class="line-removed"> 6384   ptest(vec2, vec3);</span>
<span class="line-removed"> 6385   jcc(Assembler::carryClear, FOUND_CHAR);</span>
<span class="line-removed"> 6386   addptr(result, 16);</span>
<span class="line-removed"> 6387   subl(tmp, stride);</span>
<span class="line-removed"> 6388   jcc(Assembler::notZero, SCAN_TO_8_CHAR_LOOP);</span>
<span class="line-removed"> 6389   bind(SCAN_TO_CHAR);</span>
<span class="line-removed"> 6390   testl(cnt1, cnt1);</span>
<span class="line-removed"> 6391   jcc(Assembler::zero, RET_NOT_FOUND);</span>
<span class="line-removed"> 6392   bind(SCAN_TO_CHAR_LOOP);</span>
<span class="line-removed"> 6393   load_unsigned_short(tmp, Address(result, 0));</span>
<span class="line-removed"> 6394   cmpl(ch, tmp);</span>
<span class="line-removed"> 6395   jccb(Assembler::equal, FOUND_SEQ_CHAR);</span>
<span class="line-removed"> 6396   addptr(result, 2);</span>
<span class="line-removed"> 6397   subl(cnt1, 1);</span>
<span class="line-removed"> 6398   jccb(Assembler::zero, RET_NOT_FOUND);</span>
<span class="line-removed"> 6399   jmp(SCAN_TO_CHAR_LOOP);</span>
<span class="line-removed"> 6400 </span>
<span class="line-removed"> 6401   bind(RET_NOT_FOUND);</span>
<span class="line-removed"> 6402   movl(result, -1);</span>
<span class="line-removed"> 6403   jmpb(DONE_LABEL);</span>
<span class="line-removed"> 6404 </span>
<span class="line-removed"> 6405   bind(FOUND_CHAR);</span>
<span class="line-removed"> 6406   if (UseAVX &gt;= 2) {</span>
<span class="line-removed"> 6407     vpmovmskb(tmp, vec3);</span>
<span class="line-removed"> 6408   } else {</span>
<span class="line-removed"> 6409     pmovmskb(tmp, vec3);</span>
<span class="line-removed"> 6410   }</span>
<span class="line-removed"> 6411   bsfl(ch, tmp);</span>
<span class="line-removed"> 6412   addl(result, ch);</span>
<span class="line-removed"> 6413 </span>
<span class="line-removed"> 6414   bind(FOUND_SEQ_CHAR);</span>
<span class="line-removed"> 6415   subptr(result, str1);</span>
<span class="line-removed"> 6416   shrl(result, 1);</span>
<span class="line-removed"> 6417 </span>
<span class="line-removed"> 6418   bind(DONE_LABEL);</span>
<span class="line-removed"> 6419 } // string_indexof_char</span>
<span class="line-removed"> 6420 </span>
<span class="line-removed"> 6421 // helper function for string_compare</span>
<span class="line-removed"> 6422 void MacroAssembler::load_next_elements(Register elem1, Register elem2, Register str1, Register str2,</span>
<span class="line-removed"> 6423                                         Address::ScaleFactor scale, Address::ScaleFactor scale1,</span>
<span class="line-removed"> 6424                                         Address::ScaleFactor scale2, Register index, int ae) {</span>
<span class="line-removed"> 6425   if (ae == StrIntrinsicNode::LL) {</span>
<span class="line-removed"> 6426     load_unsigned_byte(elem1, Address(str1, index, scale, 0));</span>
<span class="line-removed"> 6427     load_unsigned_byte(elem2, Address(str2, index, scale, 0));</span>
<span class="line-removed"> 6428   } else if (ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed"> 6429     load_unsigned_short(elem1, Address(str1, index, scale, 0));</span>
<span class="line-removed"> 6430     load_unsigned_short(elem2, Address(str2, index, scale, 0));</span>
<span class="line-removed"> 6431   } else {</span>
<span class="line-removed"> 6432     load_unsigned_byte(elem1, Address(str1, index, scale1, 0));</span>
<span class="line-removed"> 6433     load_unsigned_short(elem2, Address(str2, index, scale2, 0));</span>
<span class="line-removed"> 6434   }</span>
<span class="line-removed"> 6435 }</span>
<span class="line-removed"> 6436 </span>
<span class="line-removed"> 6437 // Compare strings, used for char[] and byte[].</span>
<span class="line-removed"> 6438 void MacroAssembler::string_compare(Register str1, Register str2,</span>
<span class="line-removed"> 6439                                     Register cnt1, Register cnt2, Register result,</span>
<span class="line-removed"> 6440                                     XMMRegister vec1, int ae) {</span>
<span class="line-removed"> 6441   ShortBranchVerifier sbv(this);</span>
<span class="line-removed"> 6442   Label LENGTH_DIFF_LABEL, POP_LABEL, DONE_LABEL, WHILE_HEAD_LABEL;</span>
<span class="line-removed"> 6443   Label COMPARE_WIDE_VECTORS_LOOP_FAILED;  // used only _LP64 &amp;&amp; AVX3</span>
<span class="line-removed"> 6444   int stride, stride2, adr_stride, adr_stride1, adr_stride2;</span>
<span class="line-removed"> 6445   int stride2x2 = 0x40;</span>
<span class="line-removed"> 6446   Address::ScaleFactor scale = Address::no_scale;</span>
<span class="line-removed"> 6447   Address::ScaleFactor scale1 = Address::no_scale;</span>
<span class="line-removed"> 6448   Address::ScaleFactor scale2 = Address::no_scale;</span>
<span class="line-removed"> 6449 </span>
<span class="line-removed"> 6450   if (ae != StrIntrinsicNode::LL) {</span>
<span class="line-removed"> 6451     stride2x2 = 0x20;</span>
<span class="line-removed"> 6452   }</span>
<span class="line-removed"> 6453 </span>
<span class="line-removed"> 6454   if (ae == StrIntrinsicNode::LU || ae == StrIntrinsicNode::UL) {</span>
<span class="line-removed"> 6455     shrl(cnt2, 1);</span>
<span class="line-removed"> 6456   }</span>
<span class="line-removed"> 6457   // Compute the minimum of the string lengths and the</span>
<span class="line-removed"> 6458   // difference of the string lengths (stack).</span>
<span class="line-removed"> 6459   // Do the conditional move stuff</span>
<span class="line-removed"> 6460   movl(result, cnt1);</span>
<span class="line-removed"> 6461   subl(cnt1, cnt2);</span>
<span class="line-removed"> 6462   push(cnt1);</span>
<span class="line-removed"> 6463   cmov32(Assembler::lessEqual, cnt2, result);    // cnt2 = min(cnt1, cnt2)</span>
<span class="line-removed"> 6464 </span>
<span class="line-removed"> 6465   // Is the minimum length zero?</span>
<span class="line-removed"> 6466   testl(cnt2, cnt2);</span>
<span class="line-removed"> 6467   jcc(Assembler::zero, LENGTH_DIFF_LABEL);</span>
<span class="line-removed"> 6468   if (ae == StrIntrinsicNode::LL) {</span>
<span class="line-removed"> 6469     // Load first bytes</span>
<span class="line-removed"> 6470     load_unsigned_byte(result, Address(str1, 0));  // result = str1[0]</span>
<span class="line-removed"> 6471     load_unsigned_byte(cnt1, Address(str2, 0));    // cnt1   = str2[0]</span>
<span class="line-removed"> 6472   } else if (ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed"> 6473     // Load first characters</span>
<span class="line-removed"> 6474     load_unsigned_short(result, Address(str1, 0));</span>
<span class="line-removed"> 6475     load_unsigned_short(cnt1, Address(str2, 0));</span>
<span class="line-removed"> 6476   } else {</span>
<span class="line-removed"> 6477     load_unsigned_byte(result, Address(str1, 0));</span>
<span class="line-removed"> 6478     load_unsigned_short(cnt1, Address(str2, 0));</span>
<span class="line-removed"> 6479   }</span>
<span class="line-removed"> 6480   subl(result, cnt1);</span>
<span class="line-removed"> 6481   jcc(Assembler::notZero,  POP_LABEL);</span>
<span class="line-removed"> 6482 </span>
<span class="line-removed"> 6483   if (ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed"> 6484     // Divide length by 2 to get number of chars</span>
<span class="line-removed"> 6485     shrl(cnt2, 1);</span>
<span class="line-removed"> 6486   }</span>
<span class="line-removed"> 6487   cmpl(cnt2, 1);</span>
<span class="line-removed"> 6488   jcc(Assembler::equal, LENGTH_DIFF_LABEL);</span>
<span class="line-removed"> 6489 </span>
<span class="line-removed"> 6490   // Check if the strings start at the same location and setup scale and stride</span>
<span class="line-removed"> 6491   if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed"> 6492     cmpptr(str1, str2);</span>
<span class="line-removed"> 6493     jcc(Assembler::equal, LENGTH_DIFF_LABEL);</span>
<span class="line-removed"> 6494     if (ae == StrIntrinsicNode::LL) {</span>
<span class="line-removed"> 6495       scale = Address::times_1;</span>
<span class="line-removed"> 6496       stride = 16;</span>
<span class="line-removed"> 6497     } else {</span>
<span class="line-removed"> 6498       scale = Address::times_2;</span>
<span class="line-removed"> 6499       stride = 8;</span>
<span class="line-removed"> 6500     }</span>
<span class="line-removed"> 6501   } else {</span>
<span class="line-removed"> 6502     scale1 = Address::times_1;</span>
<span class="line-removed"> 6503     scale2 = Address::times_2;</span>
<span class="line-removed"> 6504     // scale not used</span>
<span class="line-removed"> 6505     stride = 8;</span>
<span class="line-removed"> 6506   }</span>
<span class="line-removed"> 6507 </span>
<span class="line-removed"> 6508   if (UseAVX &gt;= 2 &amp;&amp; UseSSE42Intrinsics) {</span>
<span class="line-removed"> 6509     Label COMPARE_WIDE_VECTORS, VECTOR_NOT_EQUAL, COMPARE_WIDE_TAIL, COMPARE_SMALL_STR;</span>
<span class="line-removed"> 6510     Label COMPARE_WIDE_VECTORS_LOOP, COMPARE_16_CHARS, COMPARE_INDEX_CHAR;</span>
<span class="line-removed"> 6511     Label COMPARE_WIDE_VECTORS_LOOP_AVX2;</span>
<span class="line-removed"> 6512     Label COMPARE_TAIL_LONG;</span>
<span class="line-removed"> 6513     Label COMPARE_WIDE_VECTORS_LOOP_AVX3;  // used only _LP64 &amp;&amp; AVX3</span>
<span class="line-removed"> 6514 </span>
<span class="line-removed"> 6515     int pcmpmask = 0x19;</span>
<span class="line-removed"> 6516     if (ae == StrIntrinsicNode::LL) {</span>
<span class="line-removed"> 6517       pcmpmask &amp;= ~0x01;</span>
<span class="line-removed"> 6518     }</span>
<span class="line-removed"> 6519 </span>
<span class="line-removed"> 6520     // Setup to compare 16-chars (32-bytes) vectors,</span>
<span class="line-removed"> 6521     // start from first character again because it has aligned address.</span>
<span class="line-removed"> 6522     if (ae == StrIntrinsicNode::LL) {</span>
<span class="line-removed"> 6523       stride2 = 32;</span>
<span class="line-removed"> 6524     } else {</span>
<span class="line-removed"> 6525       stride2 = 16;</span>
<span class="line-removed"> 6526     }</span>
<span class="line-removed"> 6527     if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed"> 6528       adr_stride = stride &lt;&lt; scale;</span>
<span class="line-removed"> 6529     } else {</span>
<span class="line-removed"> 6530       adr_stride1 = 8;  //stride &lt;&lt; scale1;</span>
<span class="line-removed"> 6531       adr_stride2 = 16; //stride &lt;&lt; scale2;</span>
<span class="line-removed"> 6532     }</span>
<span class="line-removed"> 6533 </span>
<span class="line-removed"> 6534     assert(result == rax &amp;&amp; cnt2 == rdx &amp;&amp; cnt1 == rcx, &quot;pcmpestri&quot;);</span>
<span class="line-removed"> 6535     // rax and rdx are used by pcmpestri as elements counters</span>
<span class="line-removed"> 6536     movl(result, cnt2);</span>
<span class="line-removed"> 6537     andl(cnt2, ~(stride2-1));   // cnt2 holds the vector count</span>
<span class="line-removed"> 6538     jcc(Assembler::zero, COMPARE_TAIL_LONG);</span>
<span class="line-removed"> 6539 </span>
<span class="line-removed"> 6540     // fast path : compare first 2 8-char vectors.</span>
<span class="line-removed"> 6541     bind(COMPARE_16_CHARS);</span>
<span class="line-removed"> 6542     if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed"> 6543       movdqu(vec1, Address(str1, 0));</span>
<span class="line-removed"> 6544     } else {</span>
<span class="line-removed"> 6545       pmovzxbw(vec1, Address(str1, 0));</span>
<span class="line-removed"> 6546     }</span>
<span class="line-removed"> 6547     pcmpestri(vec1, Address(str2, 0), pcmpmask);</span>
<span class="line-removed"> 6548     jccb(Assembler::below, COMPARE_INDEX_CHAR);</span>
<span class="line-removed"> 6549 </span>
<span class="line-removed"> 6550     if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed"> 6551       movdqu(vec1, Address(str1, adr_stride));</span>
<span class="line-removed"> 6552       pcmpestri(vec1, Address(str2, adr_stride), pcmpmask);</span>
<span class="line-removed"> 6553     } else {</span>
<span class="line-removed"> 6554       pmovzxbw(vec1, Address(str1, adr_stride1));</span>
<span class="line-removed"> 6555       pcmpestri(vec1, Address(str2, adr_stride2), pcmpmask);</span>
<span class="line-removed"> 6556     }</span>
<span class="line-removed"> 6557     jccb(Assembler::aboveEqual, COMPARE_WIDE_VECTORS);</span>
<span class="line-removed"> 6558     addl(cnt1, stride);</span>
<span class="line-removed"> 6559 </span>
<span class="line-removed"> 6560     // Compare the characters at index in cnt1</span>
<span class="line-removed"> 6561     bind(COMPARE_INDEX_CHAR); // cnt1 has the offset of the mismatching character</span>
<span class="line-removed"> 6562     load_next_elements(result, cnt2, str1, str2, scale, scale1, scale2, cnt1, ae);</span>
<span class="line-removed"> 6563     subl(result, cnt2);</span>
<span class="line-removed"> 6564     jmp(POP_LABEL);</span>
<span class="line-removed"> 6565 </span>
<span class="line-removed"> 6566     // Setup the registers to start vector comparison loop</span>
<span class="line-removed"> 6567     bind(COMPARE_WIDE_VECTORS);</span>
<span class="line-removed"> 6568     if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed"> 6569       lea(str1, Address(str1, result, scale));</span>
<span class="line-removed"> 6570       lea(str2, Address(str2, result, scale));</span>
<span class="line-removed"> 6571     } else {</span>
<span class="line-removed"> 6572       lea(str1, Address(str1, result, scale1));</span>
<span class="line-removed"> 6573       lea(str2, Address(str2, result, scale2));</span>
<span class="line-removed"> 6574     }</span>
<span class="line-removed"> 6575     subl(result, stride2);</span>
<span class="line-removed"> 6576     subl(cnt2, stride2);</span>
<span class="line-removed"> 6577     jcc(Assembler::zero, COMPARE_WIDE_TAIL);</span>
<span class="line-removed"> 6578     negptr(result);</span>
<span class="line-removed"> 6579 </span>
<span class="line-removed"> 6580     //  In a loop, compare 16-chars (32-bytes) at once using (vpxor+vptest)</span>
<span class="line-removed"> 6581     bind(COMPARE_WIDE_VECTORS_LOOP);</span>
<span class="line-removed"> 6582 </span>
<span class="line-removed"> 6583 #ifdef _LP64</span>
<span class="line-removed"> 6584     if ((AVX3Threshold == 0) &amp;&amp; VM_Version::supports_avx512vlbw()) { // trying 64 bytes fast loop</span>
<span class="line-removed"> 6585       cmpl(cnt2, stride2x2);</span>
<span class="line-removed"> 6586       jccb(Assembler::below, COMPARE_WIDE_VECTORS_LOOP_AVX2);</span>
<span class="line-removed"> 6587       testl(cnt2, stride2x2-1);   // cnt2 holds the vector count</span>
<span class="line-removed"> 6588       jccb(Assembler::notZero, COMPARE_WIDE_VECTORS_LOOP_AVX2);   // means we cannot subtract by 0x40</span>
<span class="line-removed"> 6589 </span>
<span class="line-removed"> 6590       bind(COMPARE_WIDE_VECTORS_LOOP_AVX3); // the hottest loop</span>
<span class="line-removed"> 6591       if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed"> 6592         evmovdquq(vec1, Address(str1, result, scale), Assembler::AVX_512bit);</span>
<span class="line-removed"> 6593         evpcmpeqb(k7, vec1, Address(str2, result, scale), Assembler::AVX_512bit); // k7 == 11..11, if operands equal, otherwise k7 has some 0</span>
<span class="line-removed"> 6594       } else {</span>
<span class="line-removed"> 6595         vpmovzxbw(vec1, Address(str1, result, scale1), Assembler::AVX_512bit);</span>
<span class="line-removed"> 6596         evpcmpeqb(k7, vec1, Address(str2, result, scale2), Assembler::AVX_512bit); // k7 == 11..11, if operands equal, otherwise k7 has some 0</span>
<span class="line-removed"> 6597       }</span>
<span class="line-removed"> 6598       kortestql(k7, k7);</span>
<span class="line-removed"> 6599       jcc(Assembler::aboveEqual, COMPARE_WIDE_VECTORS_LOOP_FAILED);     // miscompare</span>
<span class="line-removed"> 6600       addptr(result, stride2x2);  // update since we already compared at this addr</span>
<span class="line-removed"> 6601       subl(cnt2, stride2x2);      // and sub the size too</span>
<span class="line-removed"> 6602       jccb(Assembler::notZero, COMPARE_WIDE_VECTORS_LOOP_AVX3);</span>
<span class="line-removed"> 6603 </span>
<span class="line-removed"> 6604       vpxor(vec1, vec1);</span>
<span class="line-removed"> 6605       jmpb(COMPARE_WIDE_TAIL);</span>
<span class="line-removed"> 6606     }//if (VM_Version::supports_avx512vlbw())</span>
<span class="line-removed"> 6607 #endif // _LP64</span>
<span class="line-removed"> 6608 </span>
<span class="line-removed"> 6609 </span>
<span class="line-removed"> 6610     bind(COMPARE_WIDE_VECTORS_LOOP_AVX2);</span>
<span class="line-removed"> 6611     if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed"> 6612       vmovdqu(vec1, Address(str1, result, scale));</span>
<span class="line-removed"> 6613       vpxor(vec1, Address(str2, result, scale));</span>
<span class="line-removed"> 6614     } else {</span>
<span class="line-removed"> 6615       vpmovzxbw(vec1, Address(str1, result, scale1), Assembler::AVX_256bit);</span>
<span class="line-removed"> 6616       vpxor(vec1, Address(str2, result, scale2));</span>
<span class="line-removed"> 6617     }</span>
<span class="line-removed"> 6618     vptest(vec1, vec1);</span>
<span class="line-removed"> 6619     jcc(Assembler::notZero, VECTOR_NOT_EQUAL);</span>
<span class="line-removed"> 6620     addptr(result, stride2);</span>
<span class="line-removed"> 6621     subl(cnt2, stride2);</span>
<span class="line-removed"> 6622     jcc(Assembler::notZero, COMPARE_WIDE_VECTORS_LOOP);</span>
<span class="line-removed"> 6623     // clean upper bits of YMM registers</span>
<span class="line-removed"> 6624     vpxor(vec1, vec1);</span>
<span class="line-removed"> 6625 </span>
<span class="line-removed"> 6626     // compare wide vectors tail</span>
<span class="line-removed"> 6627     bind(COMPARE_WIDE_TAIL);</span>
<span class="line-removed"> 6628     testptr(result, result);</span>
<span class="line-removed"> 6629     jcc(Assembler::zero, LENGTH_DIFF_LABEL);</span>
<span class="line-removed"> 6630 </span>
<span class="line-removed"> 6631     movl(result, stride2);</span>
<span class="line-removed"> 6632     movl(cnt2, result);</span>
<span class="line-removed"> 6633     negptr(result);</span>
<span class="line-removed"> 6634     jmp(COMPARE_WIDE_VECTORS_LOOP_AVX2);</span>
<span class="line-removed"> 6635 </span>
<span class="line-removed"> 6636     // Identifies the mismatching (higher or lower)16-bytes in the 32-byte vectors.</span>
<span class="line-removed"> 6637     bind(VECTOR_NOT_EQUAL);</span>
<span class="line-removed"> 6638     // clean upper bits of YMM registers</span>
<span class="line-removed"> 6639     vpxor(vec1, vec1);</span>
<span class="line-removed"> 6640     if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed"> 6641       lea(str1, Address(str1, result, scale));</span>
<span class="line-removed"> 6642       lea(str2, Address(str2, result, scale));</span>
<span class="line-removed"> 6643     } else {</span>
<span class="line-removed"> 6644       lea(str1, Address(str1, result, scale1));</span>
<span class="line-removed"> 6645       lea(str2, Address(str2, result, scale2));</span>
<span class="line-removed"> 6646     }</span>
<span class="line-removed"> 6647     jmp(COMPARE_16_CHARS);</span>
<span class="line-removed"> 6648 </span>
<span class="line-removed"> 6649     // Compare tail chars, length between 1 to 15 chars</span>
<span class="line-removed"> 6650     bind(COMPARE_TAIL_LONG);</span>
<span class="line-removed"> 6651     movl(cnt2, result);</span>
<span class="line-removed"> 6652     cmpl(cnt2, stride);</span>
<span class="line-removed"> 6653     jcc(Assembler::less, COMPARE_SMALL_STR);</span>
<span class="line-removed"> 6654 </span>
<span class="line-removed"> 6655     if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed"> 6656       movdqu(vec1, Address(str1, 0));</span>
<span class="line-removed"> 6657     } else {</span>
<span class="line-removed"> 6658       pmovzxbw(vec1, Address(str1, 0));</span>
<span class="line-removed"> 6659     }</span>
<span class="line-removed"> 6660     pcmpestri(vec1, Address(str2, 0), pcmpmask);</span>
<span class="line-removed"> 6661     jcc(Assembler::below, COMPARE_INDEX_CHAR);</span>
<span class="line-removed"> 6662     subptr(cnt2, stride);</span>
<span class="line-removed"> 6663     jcc(Assembler::zero, LENGTH_DIFF_LABEL);</span>
<span class="line-removed"> 6664     if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed"> 6665       lea(str1, Address(str1, result, scale));</span>
<span class="line-removed"> 6666       lea(str2, Address(str2, result, scale));</span>
<span class="line-removed"> 6667     } else {</span>
<span class="line-removed"> 6668       lea(str1, Address(str1, result, scale1));</span>
<span class="line-removed"> 6669       lea(str2, Address(str2, result, scale2));</span>
<span class="line-removed"> 6670     }</span>
<span class="line-removed"> 6671     negptr(cnt2);</span>
<span class="line-removed"> 6672     jmpb(WHILE_HEAD_LABEL);</span>
<span class="line-removed"> 6673 </span>
<span class="line-removed"> 6674     bind(COMPARE_SMALL_STR);</span>
<span class="line-removed"> 6675   } else if (UseSSE42Intrinsics) {</span>
<span class="line-removed"> 6676     Label COMPARE_WIDE_VECTORS, VECTOR_NOT_EQUAL, COMPARE_TAIL;</span>
<span class="line-removed"> 6677     int pcmpmask = 0x19;</span>
<span class="line-removed"> 6678     // Setup to compare 8-char (16-byte) vectors,</span>
<span class="line-removed"> 6679     // start from first character again because it has aligned address.</span>
<span class="line-removed"> 6680     movl(result, cnt2);</span>
<span class="line-removed"> 6681     andl(cnt2, ~(stride - 1));   // cnt2 holds the vector count</span>
<span class="line-removed"> 6682     if (ae == StrIntrinsicNode::LL) {</span>
<span class="line-removed"> 6683       pcmpmask &amp;= ~0x01;</span>
<span class="line-removed"> 6684     }</span>
<span class="line-removed"> 6685     jcc(Assembler::zero, COMPARE_TAIL);</span>
<span class="line-removed"> 6686     if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed"> 6687       lea(str1, Address(str1, result, scale));</span>
<span class="line-removed"> 6688       lea(str2, Address(str2, result, scale));</span>
<span class="line-removed"> 6689     } else {</span>
<span class="line-removed"> 6690       lea(str1, Address(str1, result, scale1));</span>
<span class="line-removed"> 6691       lea(str2, Address(str2, result, scale2));</span>
<span class="line-removed"> 6692     }</span>
<span class="line-removed"> 6693     negptr(result);</span>
<span class="line-removed"> 6694 </span>
<span class="line-removed"> 6695     // pcmpestri</span>
<span class="line-removed"> 6696     //   inputs:</span>
<span class="line-removed"> 6697     //     vec1- substring</span>
<span class="line-removed"> 6698     //     rax - negative string length (elements count)</span>
<span class="line-removed"> 6699     //     mem - scanned string</span>
<span class="line-removed"> 6700     //     rdx - string length (elements count)</span>
<span class="line-removed"> 6701     //     pcmpmask - cmp mode: 11000 (string compare with negated result)</span>
<span class="line-removed"> 6702     //               + 00 (unsigned bytes) or  + 01 (unsigned shorts)</span>
<span class="line-removed"> 6703     //   outputs:</span>
<span class="line-removed"> 6704     //     rcx - first mismatched element index</span>
<span class="line-removed"> 6705     assert(result == rax &amp;&amp; cnt2 == rdx &amp;&amp; cnt1 == rcx, &quot;pcmpestri&quot;);</span>
<span class="line-removed"> 6706 </span>
<span class="line-removed"> 6707     bind(COMPARE_WIDE_VECTORS);</span>
<span class="line-removed"> 6708     if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed"> 6709       movdqu(vec1, Address(str1, result, scale));</span>
<span class="line-removed"> 6710       pcmpestri(vec1, Address(str2, result, scale), pcmpmask);</span>
<span class="line-removed"> 6711     } else {</span>
<span class="line-removed"> 6712       pmovzxbw(vec1, Address(str1, result, scale1));</span>
<span class="line-removed"> 6713       pcmpestri(vec1, Address(str2, result, scale2), pcmpmask);</span>
<span class="line-removed"> 6714     }</span>
<span class="line-removed"> 6715     // After pcmpestri cnt1(rcx) contains mismatched element index</span>
<span class="line-removed"> 6716 </span>
<span class="line-removed"> 6717     jccb(Assembler::below, VECTOR_NOT_EQUAL);  // CF==1</span>
<span class="line-removed"> 6718     addptr(result, stride);</span>
<span class="line-removed"> 6719     subptr(cnt2, stride);</span>
<span class="line-removed"> 6720     jccb(Assembler::notZero, COMPARE_WIDE_VECTORS);</span>
<span class="line-removed"> 6721 </span>
<span class="line-removed"> 6722     // compare wide vectors tail</span>
<span class="line-removed"> 6723     testptr(result, result);</span>
<span class="line-removed"> 6724     jcc(Assembler::zero, LENGTH_DIFF_LABEL);</span>
<span class="line-removed"> 6725 </span>
<span class="line-removed"> 6726     movl(cnt2, stride);</span>
<span class="line-removed"> 6727     movl(result, stride);</span>
<span class="line-removed"> 6728     negptr(result);</span>
<span class="line-removed"> 6729     if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed"> 6730       movdqu(vec1, Address(str1, result, scale));</span>
<span class="line-removed"> 6731       pcmpestri(vec1, Address(str2, result, scale), pcmpmask);</span>
<span class="line-removed"> 6732     } else {</span>
<span class="line-removed"> 6733       pmovzxbw(vec1, Address(str1, result, scale1));</span>
<span class="line-removed"> 6734       pcmpestri(vec1, Address(str2, result, scale2), pcmpmask);</span>
<span class="line-removed"> 6735     }</span>
<span class="line-removed"> 6736     jccb(Assembler::aboveEqual, LENGTH_DIFF_LABEL);</span>
<span class="line-removed"> 6737 </span>
<span class="line-removed"> 6738     // Mismatched characters in the vectors</span>
<span class="line-removed"> 6739     bind(VECTOR_NOT_EQUAL);</span>
<span class="line-removed"> 6740     addptr(cnt1, result);</span>
<span class="line-removed"> 6741     load_next_elements(result, cnt2, str1, str2, scale, scale1, scale2, cnt1, ae);</span>
<span class="line-removed"> 6742     subl(result, cnt2);</span>
<span class="line-removed"> 6743     jmpb(POP_LABEL);</span>
<span class="line-removed"> 6744 </span>
<span class="line-removed"> 6745     bind(COMPARE_TAIL); // limit is zero</span>
<span class="line-removed"> 6746     movl(cnt2, result);</span>
<span class="line-removed"> 6747     // Fallthru to tail compare</span>
<span class="line-removed"> 6748   }</span>
<span class="line-removed"> 6749   // Shift str2 and str1 to the end of the arrays, negate min</span>
<span class="line-removed"> 6750   if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed"> 6751     lea(str1, Address(str1, cnt2, scale));</span>
<span class="line-removed"> 6752     lea(str2, Address(str2, cnt2, scale));</span>
<span class="line-removed"> 6753   } else {</span>
<span class="line-removed"> 6754     lea(str1, Address(str1, cnt2, scale1));</span>
<span class="line-removed"> 6755     lea(str2, Address(str2, cnt2, scale2));</span>
<span class="line-removed"> 6756   }</span>
<span class="line-removed"> 6757   decrementl(cnt2);  // first character was compared already</span>
<span class="line-removed"> 6758   negptr(cnt2);</span>
<span class="line-removed"> 6759 </span>
<span class="line-removed"> 6760   // Compare the rest of the elements</span>
<span class="line-removed"> 6761   bind(WHILE_HEAD_LABEL);</span>
<span class="line-removed"> 6762   load_next_elements(result, cnt1, str1, str2, scale, scale1, scale2, cnt2, ae);</span>
<span class="line-removed"> 6763   subl(result, cnt1);</span>
<span class="line-removed"> 6764   jccb(Assembler::notZero, POP_LABEL);</span>
<span class="line-removed"> 6765   increment(cnt2);</span>
<span class="line-removed"> 6766   jccb(Assembler::notZero, WHILE_HEAD_LABEL);</span>
<span class="line-removed"> 6767 </span>
<span class="line-removed"> 6768   // Strings are equal up to min length.  Return the length difference.</span>
<span class="line-removed"> 6769   bind(LENGTH_DIFF_LABEL);</span>
<span class="line-removed"> 6770   pop(result);</span>
<span class="line-removed"> 6771   if (ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed"> 6772     // Divide diff by 2 to get number of chars</span>
<span class="line-removed"> 6773     sarl(result, 1);</span>
<span class="line-removed"> 6774   }</span>
<span class="line-removed"> 6775   jmpb(DONE_LABEL);</span>
<span class="line-removed"> 6776 </span>
<span class="line-removed"> 6777 #ifdef _LP64</span>
<span class="line-removed"> 6778   if (VM_Version::supports_avx512vlbw()) {</span>
<span class="line-removed"> 6779 </span>
<span class="line-removed"> 6780     bind(COMPARE_WIDE_VECTORS_LOOP_FAILED);</span>
<span class="line-removed"> 6781 </span>
<span class="line-removed"> 6782     kmovql(cnt1, k7);</span>
<span class="line-removed"> 6783     notq(cnt1);</span>
<span class="line-removed"> 6784     bsfq(cnt2, cnt1);</span>
<span class="line-removed"> 6785     if (ae != StrIntrinsicNode::LL) {</span>
<span class="line-removed"> 6786       // Divide diff by 2 to get number of chars</span>
<span class="line-removed"> 6787       sarl(cnt2, 1);</span>
<span class="line-removed"> 6788     }</span>
<span class="line-removed"> 6789     addq(result, cnt2);</span>
<span class="line-removed"> 6790     if (ae == StrIntrinsicNode::LL) {</span>
<span class="line-removed"> 6791       load_unsigned_byte(cnt1, Address(str2, result));</span>
<span class="line-removed"> 6792       load_unsigned_byte(result, Address(str1, result));</span>
<span class="line-removed"> 6793     } else if (ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed"> 6794       load_unsigned_short(cnt1, Address(str2, result, scale));</span>
<span class="line-removed"> 6795       load_unsigned_short(result, Address(str1, result, scale));</span>
<span class="line-removed"> 6796     } else {</span>
<span class="line-removed"> 6797       load_unsigned_short(cnt1, Address(str2, result, scale2));</span>
<span class="line-removed"> 6798       load_unsigned_byte(result, Address(str1, result, scale1));</span>
<span class="line-removed"> 6799     }</span>
<span class="line-removed"> 6800     subl(result, cnt1);</span>
<span class="line-removed"> 6801     jmpb(POP_LABEL);</span>
<span class="line-removed"> 6802   }//if (VM_Version::supports_avx512vlbw())</span>
<span class="line-removed"> 6803 #endif // _LP64</span>
<span class="line-removed"> 6804 </span>
<span class="line-removed"> 6805   // Discard the stored length difference</span>
<span class="line-removed"> 6806   bind(POP_LABEL);</span>
<span class="line-removed"> 6807   pop(cnt1);</span>
<span class="line-removed"> 6808 </span>
<span class="line-removed"> 6809   // That&#39;s it</span>
<span class="line-removed"> 6810   bind(DONE_LABEL);</span>
<span class="line-removed"> 6811   if(ae == StrIntrinsicNode::UL) {</span>
<span class="line-removed"> 6812     negl(result);</span>
<span class="line-removed"> 6813   }</span>
<span class="line-removed"> 6814 </span>
<span class="line-removed"> 6815 }</span>
<span class="line-removed"> 6816 </span>
<span class="line-removed"> 6817 // Search for Non-ASCII character (Negative byte value) in a byte array,</span>
<span class="line-removed"> 6818 // return true if it has any and false otherwise.</span>
<span class="line-removed"> 6819 //   ..\jdk\src\java.base\share\classes\java\lang\StringCoding.java</span>
<span class="line-removed"> 6820 //   @HotSpotIntrinsicCandidate</span>
<span class="line-removed"> 6821 //   private static boolean hasNegatives(byte[] ba, int off, int len) {</span>
<span class="line-removed"> 6822 //     for (int i = off; i &lt; off + len; i++) {</span>
<span class="line-removed"> 6823 //       if (ba[i] &lt; 0) {</span>
<span class="line-removed"> 6824 //         return true;</span>
<span class="line-removed"> 6825 //       }</span>
<span class="line-removed"> 6826 //     }</span>
<span class="line-removed"> 6827 //     return false;</span>
<span class="line-removed"> 6828 //   }</span>
<span class="line-removed"> 6829 void MacroAssembler::has_negatives(Register ary1, Register len,</span>
<span class="line-removed"> 6830   Register result, Register tmp1,</span>
<span class="line-removed"> 6831   XMMRegister vec1, XMMRegister vec2) {</span>
<span class="line-removed"> 6832   // rsi: byte array</span>
<span class="line-removed"> 6833   // rcx: len</span>
<span class="line-removed"> 6834   // rax: result</span>
<span class="line-removed"> 6835   ShortBranchVerifier sbv(this);</span>
<span class="line-removed"> 6836   assert_different_registers(ary1, len, result, tmp1);</span>
<span class="line-removed"> 6837   assert_different_registers(vec1, vec2);</span>
<span class="line-removed"> 6838   Label TRUE_LABEL, FALSE_LABEL, DONE, COMPARE_CHAR, COMPARE_VECTORS, COMPARE_BYTE;</span>
<span class="line-removed"> 6839 </span>
<span class="line-removed"> 6840   // len == 0</span>
<span class="line-removed"> 6841   testl(len, len);</span>
<span class="line-removed"> 6842   jcc(Assembler::zero, FALSE_LABEL);</span>
<span class="line-removed"> 6843 </span>
<span class="line-removed"> 6844   if ((AVX3Threshold == 0) &amp;&amp; (UseAVX &gt; 2) &amp;&amp; // AVX512</span>
<span class="line-removed"> 6845     VM_Version::supports_avx512vlbw() &amp;&amp;</span>
<span class="line-removed"> 6846     VM_Version::supports_bmi2()) {</span>
<span class="line-removed"> 6847 </span>
<span class="line-removed"> 6848     Label test_64_loop, test_tail;</span>
<span class="line-removed"> 6849     Register tmp3_aliased = len;</span>
<span class="line-removed"> 6850 </span>
<span class="line-removed"> 6851     movl(tmp1, len);</span>
<span class="line-removed"> 6852     vpxor(vec2, vec2, vec2, Assembler::AVX_512bit);</span>
<span class="line-removed"> 6853 </span>
<span class="line-removed"> 6854     andl(tmp1, 64 - 1);   // tail count (in chars) 0x3F</span>
<span class="line-removed"> 6855     andl(len, ~(64 - 1));    // vector count (in chars)</span>
<span class="line-removed"> 6856     jccb(Assembler::zero, test_tail);</span>
<span class="line-removed"> 6857 </span>
<span class="line-removed"> 6858     lea(ary1, Address(ary1, len, Address::times_1));</span>
<span class="line-removed"> 6859     negptr(len);</span>
<span class="line-removed"> 6860 </span>
<span class="line-removed"> 6861     bind(test_64_loop);</span>
<span class="line-removed"> 6862     // Check whether our 64 elements of size byte contain negatives</span>
<span class="line-removed"> 6863     evpcmpgtb(k2, vec2, Address(ary1, len, Address::times_1), Assembler::AVX_512bit);</span>
<span class="line-removed"> 6864     kortestql(k2, k2);</span>
<span class="line-removed"> 6865     jcc(Assembler::notZero, TRUE_LABEL);</span>
<span class="line-removed"> 6866 </span>
<span class="line-removed"> 6867     addptr(len, 64);</span>
<span class="line-removed"> 6868     jccb(Assembler::notZero, test_64_loop);</span>
<span class="line-removed"> 6869 </span>
<span class="line-removed"> 6870 </span>
<span class="line-removed"> 6871     bind(test_tail);</span>
<span class="line-removed"> 6872     // bail out when there is nothing to be done</span>
<span class="line-removed"> 6873     testl(tmp1, -1);</span>
<span class="line-removed"> 6874     jcc(Assembler::zero, FALSE_LABEL);</span>
<span class="line-removed"> 6875 </span>
<span class="line-removed"> 6876     // ~(~0 &lt;&lt; len) applied up to two times (for 32-bit scenario)</span>
<span class="line-removed"> 6877 #ifdef _LP64</span>
<span class="line-removed"> 6878     mov64(tmp3_aliased, 0xFFFFFFFFFFFFFFFF);</span>
<span class="line-removed"> 6879     shlxq(tmp3_aliased, tmp3_aliased, tmp1);</span>
<span class="line-removed"> 6880     notq(tmp3_aliased);</span>
<span class="line-removed"> 6881     kmovql(k3, tmp3_aliased);</span>
<span class="line-removed"> 6882 #else</span>
<span class="line-removed"> 6883     Label k_init;</span>
<span class="line-removed"> 6884     jmp(k_init);</span>
<span class="line-removed"> 6885 </span>
<span class="line-removed"> 6886     // We could not read 64-bits from a general purpose register thus we move</span>
<span class="line-removed"> 6887     // data required to compose 64 1&#39;s to the instruction stream</span>
<span class="line-removed"> 6888     // We emit 64 byte wide series of elements from 0..63 which later on would</span>
<span class="line-removed"> 6889     // be used as a compare targets with tail count contained in tmp1 register.</span>
<span class="line-removed"> 6890     // Result would be a k register having tmp1 consecutive number or 1</span>
<span class="line-removed"> 6891     // counting from least significant bit.</span>
<span class="line-removed"> 6892     address tmp = pc();</span>
<span class="line-removed"> 6893     emit_int64(0x0706050403020100);</span>
<span class="line-removed"> 6894     emit_int64(0x0F0E0D0C0B0A0908);</span>
<span class="line-removed"> 6895     emit_int64(0x1716151413121110);</span>
<span class="line-removed"> 6896     emit_int64(0x1F1E1D1C1B1A1918);</span>
<span class="line-removed"> 6897     emit_int64(0x2726252423222120);</span>
<span class="line-removed"> 6898     emit_int64(0x2F2E2D2C2B2A2928);</span>
<span class="line-removed"> 6899     emit_int64(0x3736353433323130);</span>
<span class="line-removed"> 6900     emit_int64(0x3F3E3D3C3B3A3938);</span>
<span class="line-removed"> 6901 </span>
<span class="line-removed"> 6902     bind(k_init);</span>
<span class="line-removed"> 6903     lea(len, InternalAddress(tmp));</span>
<span class="line-removed"> 6904     // create mask to test for negative byte inside a vector</span>
<span class="line-removed"> 6905     evpbroadcastb(vec1, tmp1, Assembler::AVX_512bit);</span>
<span class="line-removed"> 6906     evpcmpgtb(k3, vec1, Address(len, 0), Assembler::AVX_512bit);</span>
<span class="line-removed"> 6907 </span>
<span class="line-removed"> 6908 #endif</span>
<span class="line-removed"> 6909     evpcmpgtb(k2, k3, vec2, Address(ary1, 0), Assembler::AVX_512bit);</span>
<span class="line-removed"> 6910     ktestq(k2, k3);</span>
<span class="line-removed"> 6911     jcc(Assembler::notZero, TRUE_LABEL);</span>
<span class="line-removed"> 6912 </span>
<span class="line-removed"> 6913     jmp(FALSE_LABEL);</span>
<span class="line-removed"> 6914   } else {</span>
<span class="line-removed"> 6915     movl(result, len); // copy</span>
<span class="line-removed"> 6916 </span>
<span class="line-removed"> 6917     if (UseAVX &gt;= 2 &amp;&amp; UseSSE &gt;= 2) {</span>
<span class="line-removed"> 6918       // With AVX2, use 32-byte vector compare</span>
<span class="line-removed"> 6919       Label COMPARE_WIDE_VECTORS, COMPARE_TAIL;</span>
<span class="line-removed"> 6920 </span>
<span class="line-removed"> 6921       // Compare 32-byte vectors</span>
<span class="line-removed"> 6922       andl(result, 0x0000001f);  //   tail count (in bytes)</span>
<span class="line-removed"> 6923       andl(len, 0xffffffe0);   // vector count (in bytes)</span>
<span class="line-removed"> 6924       jccb(Assembler::zero, COMPARE_TAIL);</span>
<span class="line-removed"> 6925 </span>
<span class="line-removed"> 6926       lea(ary1, Address(ary1, len, Address::times_1));</span>
<span class="line-removed"> 6927       negptr(len);</span>
<span class="line-removed"> 6928 </span>
<span class="line-removed"> 6929       movl(tmp1, 0x80808080);   // create mask to test for Unicode chars in vector</span>
<span class="line-removed"> 6930       movdl(vec2, tmp1);</span>
<span class="line-removed"> 6931       vpbroadcastd(vec2, vec2, Assembler::AVX_256bit);</span>
<span class="line-removed"> 6932 </span>
<span class="line-removed"> 6933       bind(COMPARE_WIDE_VECTORS);</span>
<span class="line-removed"> 6934       vmovdqu(vec1, Address(ary1, len, Address::times_1));</span>
<span class="line-removed"> 6935       vptest(vec1, vec2);</span>
<span class="line-removed"> 6936       jccb(Assembler::notZero, TRUE_LABEL);</span>
<span class="line-removed"> 6937       addptr(len, 32);</span>
<span class="line-removed"> 6938       jcc(Assembler::notZero, COMPARE_WIDE_VECTORS);</span>
<span class="line-removed"> 6939 </span>
<span class="line-removed"> 6940       testl(result, result);</span>
<span class="line-removed"> 6941       jccb(Assembler::zero, FALSE_LABEL);</span>
<span class="line-removed"> 6942 </span>
<span class="line-removed"> 6943       vmovdqu(vec1, Address(ary1, result, Address::times_1, -32));</span>
<span class="line-removed"> 6944       vptest(vec1, vec2);</span>
<span class="line-removed"> 6945       jccb(Assembler::notZero, TRUE_LABEL);</span>
<span class="line-removed"> 6946       jmpb(FALSE_LABEL);</span>
<span class="line-removed"> 6947 </span>
<span class="line-removed"> 6948       bind(COMPARE_TAIL); // len is zero</span>
<span class="line-removed"> 6949       movl(len, result);</span>
<span class="line-removed"> 6950       // Fallthru to tail compare</span>
<span class="line-removed"> 6951     } else if (UseSSE42Intrinsics) {</span>
<span class="line-removed"> 6952       // With SSE4.2, use double quad vector compare</span>
<span class="line-removed"> 6953       Label COMPARE_WIDE_VECTORS, COMPARE_TAIL;</span>
<span class="line-removed"> 6954 </span>
<span class="line-removed"> 6955       // Compare 16-byte vectors</span>
<span class="line-removed"> 6956       andl(result, 0x0000000f);  //   tail count (in bytes)</span>
<span class="line-removed"> 6957       andl(len, 0xfffffff0);   // vector count (in bytes)</span>
<span class="line-removed"> 6958       jcc(Assembler::zero, COMPARE_TAIL);</span>
<span class="line-removed"> 6959 </span>
<span class="line-removed"> 6960       lea(ary1, Address(ary1, len, Address::times_1));</span>
<span class="line-removed"> 6961       negptr(len);</span>
<span class="line-removed"> 6962 </span>
<span class="line-removed"> 6963       movl(tmp1, 0x80808080);</span>
<span class="line-removed"> 6964       movdl(vec2, tmp1);</span>
<span class="line-removed"> 6965       pshufd(vec2, vec2, 0);</span>
<span class="line-removed"> 6966 </span>
<span class="line-removed"> 6967       bind(COMPARE_WIDE_VECTORS);</span>
<span class="line-removed"> 6968       movdqu(vec1, Address(ary1, len, Address::times_1));</span>
<span class="line-removed"> 6969       ptest(vec1, vec2);</span>
<span class="line-removed"> 6970       jcc(Assembler::notZero, TRUE_LABEL);</span>
<span class="line-removed"> 6971       addptr(len, 16);</span>
<span class="line-removed"> 6972       jcc(Assembler::notZero, COMPARE_WIDE_VECTORS);</span>
<span class="line-removed"> 6973 </span>
<span class="line-removed"> 6974       testl(result, result);</span>
<span class="line-removed"> 6975       jcc(Assembler::zero, FALSE_LABEL);</span>
<span class="line-removed"> 6976 </span>
<span class="line-removed"> 6977       movdqu(vec1, Address(ary1, result, Address::times_1, -16));</span>
<span class="line-removed"> 6978       ptest(vec1, vec2);</span>
<span class="line-removed"> 6979       jccb(Assembler::notZero, TRUE_LABEL);</span>
<span class="line-removed"> 6980       jmpb(FALSE_LABEL);</span>
<span class="line-removed"> 6981 </span>
<span class="line-removed"> 6982       bind(COMPARE_TAIL); // len is zero</span>
<span class="line-removed"> 6983       movl(len, result);</span>
<span class="line-removed"> 6984       // Fallthru to tail compare</span>
<span class="line-removed"> 6985     }</span>
<span class="line-removed"> 6986   }</span>
<span class="line-removed"> 6987   // Compare 4-byte vectors</span>
<span class="line-removed"> 6988   andl(len, 0xfffffffc); // vector count (in bytes)</span>
<span class="line-removed"> 6989   jccb(Assembler::zero, COMPARE_CHAR);</span>
<span class="line-removed"> 6990 </span>
<span class="line-removed"> 6991   lea(ary1, Address(ary1, len, Address::times_1));</span>
<span class="line-removed"> 6992   negptr(len);</span>
<span class="line-removed"> 6993 </span>
<span class="line-removed"> 6994   bind(COMPARE_VECTORS);</span>
<span class="line-removed"> 6995   movl(tmp1, Address(ary1, len, Address::times_1));</span>
<span class="line-removed"> 6996   andl(tmp1, 0x80808080);</span>
<span class="line-removed"> 6997   jccb(Assembler::notZero, TRUE_LABEL);</span>
<span class="line-removed"> 6998   addptr(len, 4);</span>
<span class="line-removed"> 6999   jcc(Assembler::notZero, COMPARE_VECTORS);</span>
<span class="line-removed"> 7000 </span>
<span class="line-removed"> 7001   // Compare trailing char (final 2 bytes), if any</span>
<span class="line-removed"> 7002   bind(COMPARE_CHAR);</span>
<span class="line-removed"> 7003   testl(result, 0x2);   // tail  char</span>
<span class="line-removed"> 7004   jccb(Assembler::zero, COMPARE_BYTE);</span>
<span class="line-removed"> 7005   load_unsigned_short(tmp1, Address(ary1, 0));</span>
<span class="line-removed"> 7006   andl(tmp1, 0x00008080);</span>
<span class="line-removed"> 7007   jccb(Assembler::notZero, TRUE_LABEL);</span>
<span class="line-removed"> 7008   subptr(result, 2);</span>
<span class="line-removed"> 7009   lea(ary1, Address(ary1, 2));</span>
<span class="line-removed"> 7010 </span>
<span class="line-removed"> 7011   bind(COMPARE_BYTE);</span>
<span class="line-removed"> 7012   testl(result, 0x1);   // tail  byte</span>
<span class="line-removed"> 7013   jccb(Assembler::zero, FALSE_LABEL);</span>
<span class="line-removed"> 7014   load_unsigned_byte(tmp1, Address(ary1, 0));</span>
<span class="line-removed"> 7015   andl(tmp1, 0x00000080);</span>
<span class="line-removed"> 7016   jccb(Assembler::notEqual, TRUE_LABEL);</span>
<span class="line-removed"> 7017   jmpb(FALSE_LABEL);</span>
<span class="line-removed"> 7018 </span>
<span class="line-removed"> 7019   bind(TRUE_LABEL);</span>
<span class="line-removed"> 7020   movl(result, 1);   // return true</span>
<span class="line-removed"> 7021   jmpb(DONE);</span>
<span class="line-removed"> 7022 </span>
<span class="line-removed"> 7023   bind(FALSE_LABEL);</span>
<span class="line-removed"> 7024   xorl(result, result); // return false</span>
<span class="line-removed"> 7025 </span>
<span class="line-removed"> 7026   // That&#39;s it</span>
<span class="line-removed"> 7027   bind(DONE);</span>
<span class="line-removed"> 7028   if (UseAVX &gt;= 2 &amp;&amp; UseSSE &gt;= 2) {</span>
<span class="line-removed"> 7029     // clean upper bits of YMM registers</span>
<span class="line-removed"> 7030     vpxor(vec1, vec1);</span>
<span class="line-removed"> 7031     vpxor(vec2, vec2);</span>
<span class="line-removed"> 7032   }</span>
<span class="line-removed"> 7033 }</span>
<span class="line-removed"> 7034 // Compare char[] or byte[] arrays aligned to 4 bytes or substrings.</span>
<span class="line-removed"> 7035 void MacroAssembler::arrays_equals(bool is_array_equ, Register ary1, Register ary2,</span>
<span class="line-removed"> 7036                                    Register limit, Register result, Register chr,</span>
<span class="line-removed"> 7037                                    XMMRegister vec1, XMMRegister vec2, bool is_char) {</span>
<span class="line-removed"> 7038   ShortBranchVerifier sbv(this);</span>
<span class="line-removed"> 7039   Label TRUE_LABEL, FALSE_LABEL, DONE, COMPARE_VECTORS, COMPARE_CHAR, COMPARE_BYTE;</span>
<span class="line-removed"> 7040 </span>
<span class="line-removed"> 7041   int length_offset  = arrayOopDesc::length_offset_in_bytes();</span>
<span class="line-removed"> 7042   int base_offset    = arrayOopDesc::base_offset_in_bytes(is_char ? T_CHAR : T_BYTE);</span>
<span class="line-removed"> 7043 </span>
<span class="line-removed"> 7044   if (is_array_equ) {</span>
<span class="line-removed"> 7045     // Check the input args</span>
<span class="line-removed"> 7046     cmpoop(ary1, ary2);</span>
<span class="line-removed"> 7047     jcc(Assembler::equal, TRUE_LABEL);</span>
<span class="line-removed"> 7048 </span>
<span class="line-removed"> 7049     // Need additional checks for arrays_equals.</span>
<span class="line-removed"> 7050     testptr(ary1, ary1);</span>
<span class="line-removed"> 7051     jcc(Assembler::zero, FALSE_LABEL);</span>
<span class="line-removed"> 7052     testptr(ary2, ary2);</span>
<span class="line-removed"> 7053     jcc(Assembler::zero, FALSE_LABEL);</span>
<span class="line-removed"> 7054 </span>
<span class="line-removed"> 7055     // Check the lengths</span>
<span class="line-removed"> 7056     movl(limit, Address(ary1, length_offset));</span>
<span class="line-removed"> 7057     cmpl(limit, Address(ary2, length_offset));</span>
<span class="line-removed"> 7058     jcc(Assembler::notEqual, FALSE_LABEL);</span>
<span class="line-removed"> 7059   }</span>
<span class="line-removed"> 7060 </span>
<span class="line-removed"> 7061   // count == 0</span>
<span class="line-removed"> 7062   testl(limit, limit);</span>
<span class="line-removed"> 7063   jcc(Assembler::zero, TRUE_LABEL);</span>
<span class="line-removed"> 7064 </span>
<span class="line-removed"> 7065   if (is_array_equ) {</span>
<span class="line-removed"> 7066     // Load array address</span>
<span class="line-removed"> 7067     lea(ary1, Address(ary1, base_offset));</span>
<span class="line-removed"> 7068     lea(ary2, Address(ary2, base_offset));</span>
<span class="line-removed"> 7069   }</span>
<span class="line-removed"> 7070 </span>
<span class="line-removed"> 7071   if (is_array_equ &amp;&amp; is_char) {</span>
<span class="line-removed"> 7072     // arrays_equals when used for char[].</span>
<span class="line-removed"> 7073     shll(limit, 1);      // byte count != 0</span>
<span class="line-removed"> 7074   }</span>
<span class="line-removed"> 7075   movl(result, limit); // copy</span>
<span class="line-removed"> 7076 </span>
<span class="line-removed"> 7077   if (UseAVX &gt;= 2) {</span>
<span class="line-removed"> 7078     // With AVX2, use 32-byte vector compare</span>
<span class="line-removed"> 7079     Label COMPARE_WIDE_VECTORS, COMPARE_TAIL;</span>
<span class="line-removed"> 7080 </span>
<span class="line-removed"> 7081     // Compare 32-byte vectors</span>
<span class="line-removed"> 7082     andl(result, 0x0000001f);  //   tail count (in bytes)</span>
<span class="line-removed"> 7083     andl(limit, 0xffffffe0);   // vector count (in bytes)</span>
<span class="line-removed"> 7084     jcc(Assembler::zero, COMPARE_TAIL);</span>
<span class="line-removed"> 7085 </span>
<span class="line-removed"> 7086     lea(ary1, Address(ary1, limit, Address::times_1));</span>
<span class="line-removed"> 7087     lea(ary2, Address(ary2, limit, Address::times_1));</span>
<span class="line-removed"> 7088     negptr(limit);</span>
<span class="line-removed"> 7089 </span>
<span class="line-removed"> 7090 #ifdef _LP64</span>
<span class="line-removed"> 7091     if ((AVX3Threshold == 0) &amp;&amp; VM_Version::supports_avx512vlbw()) { // trying 64 bytes fast loop</span>
<span class="line-removed"> 7092       Label COMPARE_WIDE_VECTORS_LOOP_AVX2, COMPARE_WIDE_VECTORS_LOOP_AVX3;</span>
<span class="line-removed"> 7093 </span>
<span class="line-removed"> 7094       cmpl(limit, -64);</span>
<span class="line-removed"> 7095       jcc(Assembler::greater, COMPARE_WIDE_VECTORS_LOOP_AVX2);</span>
<span class="line-removed"> 7096 </span>
<span class="line-removed"> 7097       bind(COMPARE_WIDE_VECTORS_LOOP_AVX3); // the hottest loop</span>
<span class="line-removed"> 7098 </span>
<span class="line-removed"> 7099       evmovdquq(vec1, Address(ary1, limit, Address::times_1), Assembler::AVX_512bit);</span>
<span class="line-removed"> 7100       evpcmpeqb(k7, vec1, Address(ary2, limit, Address::times_1), Assembler::AVX_512bit);</span>
<span class="line-removed"> 7101       kortestql(k7, k7);</span>
<span class="line-removed"> 7102       jcc(Assembler::aboveEqual, FALSE_LABEL);     // miscompare</span>
<span class="line-removed"> 7103       addptr(limit, 64);  // update since we already compared at this addr</span>
<span class="line-removed"> 7104       cmpl(limit, -64);</span>
<span class="line-removed"> 7105       jccb(Assembler::lessEqual, COMPARE_WIDE_VECTORS_LOOP_AVX3);</span>
<span class="line-removed"> 7106 </span>
<span class="line-removed"> 7107       // At this point we may still need to compare -limit+result bytes.</span>
<span class="line-removed"> 7108       // We could execute the next two instruction and just continue via non-wide path:</span>
<span class="line-removed"> 7109       //  cmpl(limit, 0);</span>
<span class="line-removed"> 7110       //  jcc(Assembler::equal, COMPARE_TAIL);  // true</span>
<span class="line-removed"> 7111       // But since we stopped at the points ary{1,2}+limit which are</span>
<span class="line-removed"> 7112       // not farther than 64 bytes from the ends of arrays ary{1,2}+result</span>
<span class="line-removed"> 7113       // (|limit| &lt;= 32 and result &lt; 32),</span>
<span class="line-removed"> 7114       // we may just compare the last 64 bytes.</span>
<span class="line-removed"> 7115       //</span>
<span class="line-removed"> 7116       addptr(result, -64);   // it is safe, bc we just came from this area</span>
<span class="line-removed"> 7117       evmovdquq(vec1, Address(ary1, result, Address::times_1), Assembler::AVX_512bit);</span>
<span class="line-removed"> 7118       evpcmpeqb(k7, vec1, Address(ary2, result, Address::times_1), Assembler::AVX_512bit);</span>
<span class="line-removed"> 7119       kortestql(k7, k7);</span>
<span class="line-removed"> 7120       jcc(Assembler::aboveEqual, FALSE_LABEL);     // miscompare</span>
<span class="line-removed"> 7121 </span>
<span class="line-removed"> 7122       jmp(TRUE_LABEL);</span>
<span class="line-removed"> 7123 </span>
<span class="line-removed"> 7124       bind(COMPARE_WIDE_VECTORS_LOOP_AVX2);</span>
<span class="line-removed"> 7125 </span>
<span class="line-removed"> 7126     }//if (VM_Version::supports_avx512vlbw())</span>
<span class="line-removed"> 7127 #endif //_LP64</span>
<span class="line-removed"> 7128     bind(COMPARE_WIDE_VECTORS);</span>
<span class="line-removed"> 7129     vmovdqu(vec1, Address(ary1, limit, Address::times_1));</span>
<span class="line-removed"> 7130     vmovdqu(vec2, Address(ary2, limit, Address::times_1));</span>
<span class="line-removed"> 7131     vpxor(vec1, vec2);</span>
<span class="line-removed"> 7132 </span>
<span class="line-removed"> 7133     vptest(vec1, vec1);</span>
<span class="line-removed"> 7134     jcc(Assembler::notZero, FALSE_LABEL);</span>
<span class="line-removed"> 7135     addptr(limit, 32);</span>
<span class="line-removed"> 7136     jcc(Assembler::notZero, COMPARE_WIDE_VECTORS);</span>
<span class="line-removed"> 7137 </span>
<span class="line-removed"> 7138     testl(result, result);</span>
<span class="line-removed"> 7139     jcc(Assembler::zero, TRUE_LABEL);</span>
<span class="line-removed"> 7140 </span>
<span class="line-removed"> 7141     vmovdqu(vec1, Address(ary1, result, Address::times_1, -32));</span>
<span class="line-removed"> 7142     vmovdqu(vec2, Address(ary2, result, Address::times_1, -32));</span>
<span class="line-removed"> 7143     vpxor(vec1, vec2);</span>
<span class="line-removed"> 7144 </span>
<span class="line-removed"> 7145     vptest(vec1, vec1);</span>
<span class="line-removed"> 7146     jccb(Assembler::notZero, FALSE_LABEL);</span>
<span class="line-removed"> 7147     jmpb(TRUE_LABEL);</span>
<span class="line-removed"> 7148 </span>
<span class="line-removed"> 7149     bind(COMPARE_TAIL); // limit is zero</span>
<span class="line-removed"> 7150     movl(limit, result);</span>
<span class="line-removed"> 7151     // Fallthru to tail compare</span>
<span class="line-removed"> 7152   } else if (UseSSE42Intrinsics) {</span>
<span class="line-removed"> 7153     // With SSE4.2, use double quad vector compare</span>
<span class="line-removed"> 7154     Label COMPARE_WIDE_VECTORS, COMPARE_TAIL;</span>
<span class="line-removed"> 7155 </span>
<span class="line-removed"> 7156     // Compare 16-byte vectors</span>
<span class="line-removed"> 7157     andl(result, 0x0000000f);  //   tail count (in bytes)</span>
<span class="line-removed"> 7158     andl(limit, 0xfffffff0);   // vector count (in bytes)</span>
<span class="line-removed"> 7159     jcc(Assembler::zero, COMPARE_TAIL);</span>
<span class="line-removed"> 7160 </span>
<span class="line-removed"> 7161     lea(ary1, Address(ary1, limit, Address::times_1));</span>
<span class="line-removed"> 7162     lea(ary2, Address(ary2, limit, Address::times_1));</span>
<span class="line-removed"> 7163     negptr(limit);</span>
<span class="line-removed"> 7164 </span>
<span class="line-removed"> 7165     bind(COMPARE_WIDE_VECTORS);</span>
<span class="line-removed"> 7166     movdqu(vec1, Address(ary1, limit, Address::times_1));</span>
<span class="line-removed"> 7167     movdqu(vec2, Address(ary2, limit, Address::times_1));</span>
<span class="line-removed"> 7168     pxor(vec1, vec2);</span>
<span class="line-removed"> 7169 </span>
<span class="line-removed"> 7170     ptest(vec1, vec1);</span>
<span class="line-removed"> 7171     jcc(Assembler::notZero, FALSE_LABEL);</span>
<span class="line-removed"> 7172     addptr(limit, 16);</span>
<span class="line-removed"> 7173     jcc(Assembler::notZero, COMPARE_WIDE_VECTORS);</span>
<span class="line-removed"> 7174 </span>
<span class="line-removed"> 7175     testl(result, result);</span>
<span class="line-removed"> 7176     jcc(Assembler::zero, TRUE_LABEL);</span>
<span class="line-removed"> 7177 </span>
<span class="line-removed"> 7178     movdqu(vec1, Address(ary1, result, Address::times_1, -16));</span>
<span class="line-removed"> 7179     movdqu(vec2, Address(ary2, result, Address::times_1, -16));</span>
<span class="line-removed"> 7180     pxor(vec1, vec2);</span>
<span class="line-removed"> 7181 </span>
<span class="line-removed"> 7182     ptest(vec1, vec1);</span>
<span class="line-removed"> 7183     jccb(Assembler::notZero, FALSE_LABEL);</span>
<span class="line-removed"> 7184     jmpb(TRUE_LABEL);</span>
<span class="line-removed"> 7185 </span>
<span class="line-removed"> 7186     bind(COMPARE_TAIL); // limit is zero</span>
<span class="line-removed"> 7187     movl(limit, result);</span>
<span class="line-removed"> 7188     // Fallthru to tail compare</span>
<span class="line-removed"> 7189   }</span>
<span class="line-removed"> 7190 </span>
<span class="line-removed"> 7191   // Compare 4-byte vectors</span>
<span class="line-removed"> 7192   andl(limit, 0xfffffffc); // vector count (in bytes)</span>
<span class="line-removed"> 7193   jccb(Assembler::zero, COMPARE_CHAR);</span>
<span class="line-removed"> 7194 </span>
<span class="line-removed"> 7195   lea(ary1, Address(ary1, limit, Address::times_1));</span>
<span class="line-removed"> 7196   lea(ary2, Address(ary2, limit, Address::times_1));</span>
<span class="line-removed"> 7197   negptr(limit);</span>
<span class="line-removed"> 7198 </span>
<span class="line-removed"> 7199   bind(COMPARE_VECTORS);</span>
<span class="line-removed"> 7200   movl(chr, Address(ary1, limit, Address::times_1));</span>
<span class="line-removed"> 7201   cmpl(chr, Address(ary2, limit, Address::times_1));</span>
<span class="line-removed"> 7202   jccb(Assembler::notEqual, FALSE_LABEL);</span>
<span class="line-removed"> 7203   addptr(limit, 4);</span>
<span class="line-removed"> 7204   jcc(Assembler::notZero, COMPARE_VECTORS);</span>
<span class="line-removed"> 7205 </span>
<span class="line-removed"> 7206   // Compare trailing char (final 2 bytes), if any</span>
<span class="line-removed"> 7207   bind(COMPARE_CHAR);</span>
<span class="line-removed"> 7208   testl(result, 0x2);   // tail  char</span>
<span class="line-removed"> 7209   jccb(Assembler::zero, COMPARE_BYTE);</span>
<span class="line-removed"> 7210   load_unsigned_short(chr, Address(ary1, 0));</span>
<span class="line-removed"> 7211   load_unsigned_short(limit, Address(ary2, 0));</span>
<span class="line-removed"> 7212   cmpl(chr, limit);</span>
<span class="line-removed"> 7213   jccb(Assembler::notEqual, FALSE_LABEL);</span>
<span class="line-removed"> 7214 </span>
<span class="line-removed"> 7215   if (is_array_equ &amp;&amp; is_char) {</span>
<span class="line-removed"> 7216     bind(COMPARE_BYTE);</span>
<span class="line-removed"> 7217   } else {</span>
<span class="line-removed"> 7218     lea(ary1, Address(ary1, 2));</span>
<span class="line-removed"> 7219     lea(ary2, Address(ary2, 2));</span>
<span class="line-removed"> 7220 </span>
<span class="line-removed"> 7221     bind(COMPARE_BYTE);</span>
<span class="line-removed"> 7222     testl(result, 0x1);   // tail  byte</span>
<span class="line-removed"> 7223     jccb(Assembler::zero, TRUE_LABEL);</span>
<span class="line-removed"> 7224     load_unsigned_byte(chr, Address(ary1, 0));</span>
<span class="line-removed"> 7225     load_unsigned_byte(limit, Address(ary2, 0));</span>
<span class="line-removed"> 7226     cmpl(chr, limit);</span>
<span class="line-removed"> 7227     jccb(Assembler::notEqual, FALSE_LABEL);</span>
<span class="line-removed"> 7228   }</span>
<span class="line-removed"> 7229   bind(TRUE_LABEL);</span>
<span class="line-removed"> 7230   movl(result, 1);   // return true</span>
<span class="line-removed"> 7231   jmpb(DONE);</span>
<span class="line-removed"> 7232 </span>
<span class="line-removed"> 7233   bind(FALSE_LABEL);</span>
<span class="line-removed"> 7234   xorl(result, result); // return false</span>
<span class="line-removed"> 7235 </span>
<span class="line-removed"> 7236   // That&#39;s it</span>
<span class="line-removed"> 7237   bind(DONE);</span>
<span class="line-removed"> 7238   if (UseAVX &gt;= 2) {</span>
<span class="line-removed"> 7239     // clean upper bits of YMM registers</span>
<span class="line-removed"> 7240     vpxor(vec1, vec1);</span>
<span class="line-removed"> 7241     vpxor(vec2, vec2);</span>
<span class="line-removed"> 7242   }</span>
<span class="line-removed"> 7243 }</span>
<span class="line-removed"> 7244 </span>
<span class="line-removed"> 7245 #endif</span>
<span class="line-removed"> 7246 </span>
 7247 void MacroAssembler::generate_fill(BasicType t, bool aligned,
 7248                                    Register to, Register value, Register count,
 7249                                    Register rtmp, XMMRegister xtmp) {
 7250   ShortBranchVerifier sbv(this);
 7251   assert_different_registers(to, value, count, rtmp);
 7252   Label L_exit;
 7253   Label L_fill_2_bytes, L_fill_4_bytes;
 7254 
 7255   int shift = -1;
 7256   switch (t) {
 7257     case T_BYTE:
 7258       shift = 2;
 7259       break;
 7260     case T_SHORT:
 7261       shift = 1;
 7262       break;
 7263     case T_INT:
 7264       shift = 0;
 7265       break;
 7266     default: ShouldNotReachHere();
</pre>
</td>
<td>
<hr />
<pre>
   32 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
   33 #include &quot;interpreter/interpreter.hpp&quot;
   34 #include &quot;memory/resourceArea.hpp&quot;
   35 #include &quot;memory/universe.hpp&quot;
   36 #include &quot;oops/accessDecorators.hpp&quot;
   37 #include &quot;oops/compressedOops.inline.hpp&quot;
   38 #include &quot;oops/klass.inline.hpp&quot;
   39 #include &quot;prims/methodHandles.hpp&quot;
   40 #include &quot;runtime/biasedLocking.hpp&quot;
   41 #include &quot;runtime/flags/flagSetting.hpp&quot;
   42 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
   43 #include &quot;runtime/objectMonitor.hpp&quot;
   44 #include &quot;runtime/os.hpp&quot;
   45 #include &quot;runtime/safepoint.hpp&quot;
   46 #include &quot;runtime/safepointMechanism.hpp&quot;
   47 #include &quot;runtime/sharedRuntime.hpp&quot;
   48 #include &quot;runtime/stubRoutines.hpp&quot;
   49 #include &quot;runtime/thread.hpp&quot;
   50 #include &quot;utilities/macros.hpp&quot;
   51 #include &quot;crc32c.h&quot;



   52 
   53 #ifdef PRODUCT
   54 #define BLOCK_COMMENT(str) /* nothing */
   55 #define STOP(error) stop(error)
   56 #else
   57 #define BLOCK_COMMENT(str) block_comment(str)
   58 #define STOP(error) block_comment(error); stop(error)
   59 #endif
   60 
   61 #define BIND(label) bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
   62 
   63 #ifdef ASSERT
   64 bool AbstractAssembler::pd_check_instruction_mark() { return true; }
   65 #endif
   66 
   67 static Assembler::Condition reverse[] = {
   68     Assembler::noOverflow     /* overflow      = 0x0 */ ,
   69     Assembler::overflow       /* noOverflow    = 0x1 */ ,
   70     Assembler::aboveEqual     /* carrySet      = 0x2, below         = 0x2 */ ,
   71     Assembler::below          /* aboveEqual    = 0x3, carryClear    = 0x3 */ ,
</pre>
<hr />
<pre>
 1263   bind(cas_label);
 1264 
 1265   return null_check_offset;
 1266 }
 1267 
 1268 void MacroAssembler::biased_locking_exit(Register obj_reg, Register temp_reg, Label&amp; done) {
 1269   assert(UseBiasedLocking, &quot;why call this otherwise?&quot;);
 1270 
 1271   // Check for biased locking unlock case, which is a no-op
 1272   // Note: we do not have to check the thread ID for two reasons.
 1273   // First, the interpreter checks for IllegalMonitorStateException at
 1274   // a higher level. Second, if the bias was revoked while we held the
 1275   // lock, the object could not be rebiased toward another thread, so
 1276   // the bias bit would be clear.
 1277   movptr(temp_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));
 1278   andptr(temp_reg, markWord::biased_lock_mask_in_place);
 1279   cmpptr(temp_reg, markWord::biased_lock_pattern);
 1280   jcc(Assembler::equal, done);
 1281 }
 1282 






























































































































































































































































































































































































































































































































































































































































































































































































 1283 void MacroAssembler::c2bool(Register x) {
 1284   // implements x == 0 ? 0 : 1
 1285   // note: must only look at least-significant byte of x
 1286   //       since C-style booleans are stored in one byte
 1287   //       only! (was bug)
 1288   andl(x, 0xFF);
 1289   setb(Assembler::notZero, x);
 1290 }
 1291 
 1292 // Wouldn&#39;t need if AddressLiteral version had new name
 1293 void MacroAssembler::call(Label&amp; L, relocInfo::relocType rtype) {
 1294   Assembler::call(L, rtype);
 1295 }
 1296 
 1297 void MacroAssembler::call(Register entry) {
 1298   Assembler::call(entry);
 1299 }
 1300 
 1301 void MacroAssembler::call(AddressLiteral entry) {
 1302   if (reachable(entry)) {
</pre>
<hr />
<pre>
 1938 }
 1939 
 1940 void MacroAssembler::divsd(XMMRegister dst, AddressLiteral src) {
 1941   if (reachable(src)) {
 1942     Assembler::divsd(dst, as_Address(src));
 1943   } else {
 1944     lea(rscratch1, src);
 1945     Assembler::divsd(dst, Address(rscratch1, 0));
 1946   }
 1947 }
 1948 
 1949 void MacroAssembler::divss(XMMRegister dst, AddressLiteral src) {
 1950   if (reachable(src)) {
 1951     Assembler::divss(dst, as_Address(src));
 1952   } else {
 1953     lea(rscratch1, src);
 1954     Assembler::divss(dst, Address(rscratch1, 0));
 1955   }
 1956 }
 1957 











 1958 void MacroAssembler::enter() {
 1959   push(rbp);
 1960   mov(rbp, rsp);
 1961 }
 1962 
 1963 // A 5 byte nop that is safe for patching (see patch_verified_entry)
 1964 void MacroAssembler::fat_nop() {
 1965   if (UseAddressNop) {
 1966     addr_nop_5();
 1967   } else {
 1968     emit_int8(0x26); // es:
 1969     emit_int8(0x2e); // cs:
 1970     emit_int8(0x64); // fs:
 1971     emit_int8(0x65); // gs:
 1972     emit_int8((unsigned char)0x90);
 1973   }
 1974 }
 1975 
<span class="line-modified"> 1976 #ifndef _LP64</span>
 1977 void MacroAssembler::fcmp(Register tmp) {
 1978   fcmp(tmp, 1, true, true);
 1979 }
 1980 
 1981 void MacroAssembler::fcmp(Register tmp, int index, bool pop_left, bool pop_right) {
 1982   assert(!pop_right || pop_left, &quot;usage error&quot;);
 1983   if (VM_Version::supports_cmov()) {
 1984     assert(tmp == noreg, &quot;unneeded temp&quot;);
 1985     if (pop_left) {
 1986       fucomip(index);
 1987     } else {
 1988       fucomi(index);
 1989     }
 1990     if (pop_right) {
 1991       fpop();
 1992     }
 1993   } else {
 1994     assert(tmp != noreg, &quot;need temp&quot;);
 1995     if (pop_left) {
 1996       if (pop_right) {
</pre>
<hr />
<pre>
 2059   ffree();
 2060   fincstp();
 2061 }
 2062 
 2063 void MacroAssembler::fremr(Register tmp) {
 2064   save_rax(tmp);
 2065   { Label L;
 2066     bind(L);
 2067     fprem();
 2068     fwait(); fnstsw_ax();
 2069     sahf();
 2070     jcc(Assembler::parity, L);
 2071   }
 2072   restore_rax(tmp);
 2073   // Result is in ST0.
 2074   // Note: fxch &amp; fpop to get rid of ST1
 2075   // (otherwise FPU stack could overflow eventually)
 2076   fxch(1);
 2077   fpop();
 2078 }
<span class="line-added"> 2079 </span>
<span class="line-added"> 2080 void MacroAssembler::empty_FPU_stack() {</span>
<span class="line-added"> 2081   if (VM_Version::supports_mmx()) {</span>
<span class="line-added"> 2082     emms();</span>
<span class="line-added"> 2083   } else {</span>
<span class="line-added"> 2084     for (int i = 8; i-- &gt; 0; ) ffree(i);</span>
<span class="line-added"> 2085   }</span>
<span class="line-added"> 2086 }</span>
 2087 #endif // !LP64
 2088 
 2089 void MacroAssembler::mulpd(XMMRegister dst, AddressLiteral src) {
 2090   if (reachable(src)) {
 2091     Assembler::mulpd(dst, as_Address(src));
 2092   } else {
 2093     lea(rscratch1, src);
 2094     Assembler::mulpd(dst, Address(rscratch1, 0));
 2095   }
 2096 }
 2097 
 2098 void MacroAssembler::load_float(Address src) {
<span class="line-added"> 2099 #ifdef _LP64</span>
<span class="line-added"> 2100   movflt(xmm0, src);</span>
<span class="line-added"> 2101 #else</span>
 2102   if (UseSSE &gt;= 1) {
 2103     movflt(xmm0, src);
 2104   } else {
<span class="line-modified"> 2105     fld_s(src);</span>

 2106   }
<span class="line-added"> 2107 #endif // LP64</span>
 2108 }
 2109 
 2110 void MacroAssembler::store_float(Address dst) {
<span class="line-added"> 2111 #ifdef _LP64</span>
<span class="line-added"> 2112   movflt(dst, xmm0);</span>
<span class="line-added"> 2113 #else</span>
 2114   if (UseSSE &gt;= 1) {
 2115     movflt(dst, xmm0);
 2116   } else {
<span class="line-modified"> 2117     fstp_s(dst);</span>

 2118   }
<span class="line-added"> 2119 #endif // LP64</span>
 2120 }
 2121 
 2122 void MacroAssembler::load_double(Address src) {
<span class="line-added"> 2123 #ifdef _LP64</span>
<span class="line-added"> 2124   movdbl(xmm0, src);</span>
<span class="line-added"> 2125 #else</span>
 2126   if (UseSSE &gt;= 2) {
 2127     movdbl(xmm0, src);
 2128   } else {
<span class="line-modified"> 2129     fld_d(src);</span>

 2130   }
<span class="line-added"> 2131 #endif // LP64</span>
 2132 }
 2133 
 2134 void MacroAssembler::store_double(Address dst) {
<span class="line-added"> 2135 #ifdef _LP64</span>
<span class="line-added"> 2136   movdbl(dst, xmm0);</span>
<span class="line-added"> 2137 #else</span>
 2138   if (UseSSE &gt;= 2) {
 2139     movdbl(dst, xmm0);
 2140   } else {
<span class="line-modified"> 2141     fstp_d(dst);</span>

 2142   }
<span class="line-added"> 2143 #endif // LP64</span>
 2144 }
 2145 
 2146 // dst = c = a * b + c
 2147 void MacroAssembler::fmad(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c) {
 2148   Assembler::vfmadd231sd(c, a, b);
 2149   if (dst != c) {
 2150     movdbl(dst, c);
 2151   }
 2152 }
 2153 
 2154 // dst = c = a * b + c
 2155 void MacroAssembler::fmaf(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c) {
 2156   Assembler::vfmadd231ss(c, a, b);
 2157   if (dst != c) {
 2158     movflt(dst, c);
 2159   }
 2160 }
 2161 
 2162 // dst = c = a * b + c
 2163 void MacroAssembler::vfmad(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c, int vector_len) {
</pre>
<hr />
<pre>
 2428 }
 2429 
 2430 void MacroAssembler::movdl(XMMRegister dst, AddressLiteral src) {
 2431   if (reachable(src)) {
 2432     movdl(dst, as_Address(src));
 2433   } else {
 2434     lea(rscratch1, src);
 2435     movdl(dst, Address(rscratch1, 0));
 2436   }
 2437 }
 2438 
 2439 void MacroAssembler::movq(XMMRegister dst, AddressLiteral src) {
 2440   if (reachable(src)) {
 2441     movq(dst, as_Address(src));
 2442   } else {
 2443     lea(rscratch1, src);
 2444     movq(dst, Address(rscratch1, 0));
 2445   }
 2446 }
 2447 
















 2448 void MacroAssembler::movdbl(XMMRegister dst, AddressLiteral src) {
 2449   if (reachable(src)) {
 2450     if (UseXmmLoadAndClearUpper) {
 2451       movsd (dst, as_Address(src));
 2452     } else {
 2453       movlpd(dst, as_Address(src));
 2454     }
 2455   } else {
 2456     lea(rscratch1, src);
 2457     if (UseXmmLoadAndClearUpper) {
 2458       movsd (dst, Address(rscratch1, 0));
 2459     } else {
 2460       movlpd(dst, Address(rscratch1, 0));
 2461     }
 2462   }
 2463 }
 2464 
 2465 void MacroAssembler::movflt(XMMRegister dst, AddressLiteral src) {
 2466   if (reachable(src)) {
 2467     movss(dst, as_Address(src));
</pre>
<hr />
<pre>
 2688 
 2689   vzeroupper();
 2690 }
 2691 
 2692 void MacroAssembler::restore_rax(Register tmp) {
 2693   if (tmp == noreg) pop(rax);
 2694   else if (tmp != rax) mov(rax, tmp);
 2695 }
 2696 
 2697 void MacroAssembler::round_to(Register reg, int modulus) {
 2698   addptr(reg, modulus - 1);
 2699   andptr(reg, -modulus);
 2700 }
 2701 
 2702 void MacroAssembler::save_rax(Register tmp) {
 2703   if (tmp == noreg) push(rax);
 2704   else if (tmp != rax) mov(tmp, rax);
 2705 }
 2706 
 2707 void MacroAssembler::safepoint_poll(Label&amp; slow_path, Register thread_reg, Register temp_reg) {

 2708 #ifdef _LP64
<span class="line-modified"> 2709   assert(thread_reg == r15_thread, &quot;should be&quot;);</span>
 2710 #else
<span class="line-modified"> 2711   if (thread_reg == noreg) {</span>
<span class="line-modified"> 2712     thread_reg = temp_reg;</span>
<span class="line-modified"> 2713     get_thread(thread_reg);</span>








 2714   }
<span class="line-added"> 2715 #endif</span>
<span class="line-added"> 2716   testb(Address(thread_reg, Thread::polling_page_offset()), SafepointMechanism::poll_bit());</span>
<span class="line-added"> 2717   jcc(Assembler::notZero, slow_path); // handshake bit set implies poll</span>
 2718 }
 2719 
 2720 // Calls to C land
 2721 //
 2722 // When entering C land, the rbp, &amp; rsp of the last Java frame have to be recorded
 2723 // in the (thread-local) JavaThread object. When leaving C land, the last Java fp
 2724 // has to be reset to 0. This is required to allow proper stack traversal.
 2725 void MacroAssembler::set_last_Java_frame(Register java_thread,
 2726                                          Register last_java_sp,
 2727                                          Register last_java_fp,
 2728                                          address  last_java_pc) {
 2729   vzeroupper();
 2730   // determine java_thread register
 2731   if (!java_thread-&gt;is_valid()) {
 2732     java_thread = rdi;
 2733     get_thread(java_thread);
 2734   }
 2735   // determine last_java_sp register
 2736   if (!last_java_sp-&gt;is_valid()) {
 2737     last_java_sp = rsp;
</pre>
<hr />
<pre>
 3226   } else {
 3227     lea(scratch_reg, src);
 3228     vxorps(dst, nds, Address(scratch_reg, 0), vector_len);
 3229   }
 3230 }
 3231 
 3232 void MacroAssembler::vpxor(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
 3233   if (UseAVX &gt; 1 || (vector_len &lt; 1)) {
 3234     if (reachable(src)) {
 3235       Assembler::vpxor(dst, nds, as_Address(src), vector_len);
 3236     } else {
 3237       lea(scratch_reg, src);
 3238       Assembler::vpxor(dst, nds, Address(scratch_reg, 0), vector_len);
 3239     }
 3240   }
 3241   else {
 3242     MacroAssembler::vxorpd(dst, nds, src, vector_len, scratch_reg);
 3243   }
 3244 }
 3245 
































































































































 3246 //-------------------------------------------------------------------------------------------
 3247 
 3248 void MacroAssembler::clear_jweak_tag(Register possibly_jweak) {
 3249   const int32_t inverted_jweak_mask = ~static_cast&lt;int32_t&gt;(JNIHandles::weak_tag_mask);
 3250   STATIC_ASSERT(inverted_jweak_mask == -2); // otherwise check this code
 3251   // The inverted mask is sign-extended
 3252   andptr(possibly_jweak, inverted_jweak_mask);
 3253 }
 3254 
 3255 void MacroAssembler::resolve_jobject(Register value,
 3256                                      Register thread,
 3257                                      Register tmp) {
 3258   assert_different_registers(value, thread, tmp);
 3259   Label done, not_weak;
 3260   testptr(value, value);
 3261   jcc(Assembler::zero, done);                // Use NULL as-is.
 3262   testptr(value, JNIHandles::weak_tag_mask); // Test for jweak tag.
 3263   jcc(Assembler::zero, not_weak);
 3264   // Resolve jweak.
 3265   access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF,
</pre>
<hr />
<pre>
 3740     b = code_string(ss.as_string());
 3741   }
 3742   BLOCK_COMMENT(&quot;verify_oop {&quot;);
 3743 #ifdef _LP64
 3744   push(rscratch1);                    // save r10, trashed by movptr()
 3745 #endif
 3746   push(rax);                          // save rax,
 3747   push(reg);                          // pass register argument
 3748   ExternalAddress buffer((address) b);
 3749   // avoid using pushptr, as it modifies scratch registers
 3750   // and our contract is not to modify anything
 3751   movptr(rax, buffer.addr());
 3752   push(rax);
 3753   // call indirectly to solve generation ordering problem
 3754   movptr(rax, ExternalAddress(StubRoutines::verify_oop_subroutine_entry_address()));
 3755   call(rax);
 3756   // Caller pops the arguments (oop, message) and restores rax, r10
 3757   BLOCK_COMMENT(&quot;} verify_oop&quot;);
 3758 }
 3759 
<span class="line-added"> 3760 void MacroAssembler::vallones(XMMRegister dst, int vector_len) {</span>
<span class="line-added"> 3761   if (UseAVX &gt; 2 &amp;&amp; (vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl())) {</span>
<span class="line-added"> 3762     vpternlogd(dst, 0xFF, dst, dst, vector_len);</span>
<span class="line-added"> 3763   } else {</span>
<span class="line-added"> 3764     assert(UseAVX &gt; 0, &quot;&quot;);</span>
<span class="line-added"> 3765     vpcmpeqb(dst, dst, dst, vector_len);</span>
<span class="line-added"> 3766   }</span>
<span class="line-added"> 3767 }</span>
 3768 
 3769 RegisterOrConstant MacroAssembler::delayed_value_impl(intptr_t* delayed_value_addr,
 3770                                                       Register tmp,
 3771                                                       int offset) {
 3772   intptr_t value = *delayed_value_addr;
 3773   if (value != 0)
 3774     return RegisterOrConstant(value + offset);
 3775 
 3776   // load indirectly to solve generation ordering problem
 3777   movptr(tmp, ExternalAddress((address) delayed_value_addr));
 3778 
 3779 #ifdef ASSERT
 3780   { Label L;
 3781     testptr(tmp, tmp);
 3782     if (WizardMode) {
 3783       const char* buf = NULL;
 3784       {
 3785         ResourceMark rm;
 3786         stringStream ss;
 3787         ss.print(&quot;DelayedValue=&quot; INTPTR_FORMAT, delayed_value_addr[1]);
</pre>
<hr />
<pre>
 4904     jmpb(DONE);
 4905 
 4906     BIND(LONG);
 4907   }
 4908 
 4909   // Use longer rep-prefixed ops for non-small counts:
 4910   if (UseFastStosb) {
 4911     shlptr(cnt, 3); // convert to number of bytes
 4912     rep_stosb();
 4913   } else if (UseXMMForObjInit) {
 4914     movptr(tmp, base);
 4915     xmm_clear_mem(tmp, cnt, xtmp);
 4916   } else {
 4917     NOT_LP64(shlptr(cnt, 1);) // convert to number of 32-bit words for 32-bit VM
 4918     rep_stos();
 4919   }
 4920 
 4921   BIND(DONE);
 4922 }
 4923 













































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































 4924 void MacroAssembler::generate_fill(BasicType t, bool aligned,
 4925                                    Register to, Register value, Register count,
 4926                                    Register rtmp, XMMRegister xtmp) {
 4927   ShortBranchVerifier sbv(this);
 4928   assert_different_registers(to, value, count, rtmp);
 4929   Label L_exit;
 4930   Label L_fill_2_bytes, L_fill_4_bytes;
 4931 
 4932   int shift = -1;
 4933   switch (t) {
 4934     case T_BYTE:
 4935       shift = 2;
 4936       break;
 4937     case T_SHORT:
 4938       shift = 1;
 4939       break;
 4940     case T_INT:
 4941       shift = 0;
 4942       break;
 4943     default: ShouldNotReachHere();
</pre>
</td>
</tr>
</table>
<center><a href="jvmciCodeInstaller_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_x86.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
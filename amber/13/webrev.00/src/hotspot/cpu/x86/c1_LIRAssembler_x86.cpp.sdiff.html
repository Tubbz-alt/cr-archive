<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/c1_LIRAssembler_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="assembler_x86.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIRGenerator_x86.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/c1_LIRAssembler_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
 519 
 520 
 521 void LIR_Assembler::return_op(LIR_Opr result) {
 522   assert(result-&gt;is_illegal() || !result-&gt;is_single_cpu() || result-&gt;as_register() == rax, &quot;word returns are in rax,&quot;);
 523   if (!result-&gt;is_illegal() &amp;&amp; result-&gt;is_float_kind() &amp;&amp; !result-&gt;is_xmm_register()) {
 524     assert(result-&gt;fpu() == 0, &quot;result must already be on TOS&quot;);
 525   }
 526 
 527   // Pop the stack before the safepoint code
 528   __ remove_frame(initial_frame_size_in_bytes());
 529 
 530   if (StackReservedPages &gt; 0 &amp;&amp; compilation()-&gt;has_reserved_stack_access()) {
 531     __ reserved_stack_check();
 532   }
 533 
 534   bool result_is_oop = result-&gt;is_valid() ? result-&gt;is_oop() : false;
 535 
 536   // Note: we do not need to round double result; float result has the right precision
 537   // the poll sets the condition code, but no data registers
 538 
<span class="line-removed"> 539   if (SafepointMechanism::uses_thread_local_poll()) {</span>
 540 #ifdef _LP64
<span class="line-modified"> 541     const Register poll_addr = rscratch1;</span>
<span class="line-modified"> 542     __ movptr(poll_addr, Address(r15_thread, Thread::polling_page_offset()));</span>
 543 #else
<span class="line-modified"> 544     const Register poll_addr = rbx;</span>
<span class="line-modified"> 545     assert(FrameMap::is_caller_save_register(poll_addr), &quot;will overwrite&quot;);</span>
<span class="line-modified"> 546     __ get_thread(poll_addr);</span>
<span class="line-modified"> 547     __ movptr(poll_addr, Address(poll_addr, Thread::polling_page_offset()));</span>
 548 #endif
<span class="line-modified"> 549     __ relocate(relocInfo::poll_return_type);</span>
<span class="line-modified"> 550     __ testl(rax, Address(poll_addr, 0));</span>
<span class="line-removed"> 551   } else {</span>
<span class="line-removed"> 552     AddressLiteral polling_page(os::get_polling_page(), relocInfo::poll_return_type);</span>
<span class="line-removed"> 553 </span>
<span class="line-removed"> 554     if (Assembler::is_polling_page_far()) {</span>
<span class="line-removed"> 555       __ lea(rscratch1, polling_page);</span>
<span class="line-removed"> 556       __ relocate(relocInfo::poll_return_type);</span>
<span class="line-removed"> 557       __ testl(rax, Address(rscratch1, 0));</span>
<span class="line-removed"> 558     } else {</span>
<span class="line-removed"> 559       __ testl(rax, polling_page);</span>
<span class="line-removed"> 560     }</span>
<span class="line-removed"> 561   }</span>
 562   __ ret(0);
 563 }
 564 
 565 
 566 int LIR_Assembler::safepoint_poll(LIR_Opr tmp, CodeEmitInfo* info) {
 567   guarantee(info != NULL, &quot;Shouldn&#39;t be NULL&quot;);
 568   int offset = __ offset();
<span class="line-removed"> 569   if (SafepointMechanism::uses_thread_local_poll()) {</span>
 570 #ifdef _LP64
<span class="line-modified"> 571     const Register poll_addr = rscratch1;</span>
<span class="line-modified"> 572     __ movptr(poll_addr, Address(r15_thread, Thread::polling_page_offset()));</span>
 573 #else
<span class="line-modified"> 574     assert(tmp-&gt;is_cpu_register(), &quot;needed&quot;);</span>
<span class="line-modified"> 575     const Register poll_addr = tmp-&gt;as_register();</span>
<span class="line-modified"> 576     __ get_thread(poll_addr);</span>
<span class="line-modified"> 577     __ movptr(poll_addr, Address(poll_addr, in_bytes(Thread::polling_page_offset())));</span>
 578 #endif
<span class="line-modified"> 579     add_debug_info_for_branch(info);</span>
<span class="line-modified"> 580     __ relocate(relocInfo::poll_type);</span>
<span class="line-modified"> 581     address pre_pc = __ pc();</span>
<span class="line-modified"> 582     __ testl(rax, Address(poll_addr, 0));</span>
<span class="line-modified"> 583     address post_pc = __ pc();</span>
<span class="line-modified"> 584     guarantee(pointer_delta(post_pc, pre_pc, 1) == 2 LP64_ONLY(+1), &quot;must be exact length&quot;);</span>
<span class="line-removed"> 585   } else {</span>
<span class="line-removed"> 586     AddressLiteral polling_page(os::get_polling_page(), relocInfo::poll_type);</span>
<span class="line-removed"> 587     if (Assembler::is_polling_page_far()) {</span>
<span class="line-removed"> 588       __ lea(rscratch1, polling_page);</span>
<span class="line-removed"> 589       offset = __ offset();</span>
<span class="line-removed"> 590       add_debug_info_for_branch(info);</span>
<span class="line-removed"> 591       __ relocate(relocInfo::poll_type);</span>
<span class="line-removed"> 592       __ testl(rax, Address(rscratch1, 0));</span>
<span class="line-removed"> 593     } else {</span>
<span class="line-removed"> 594       add_debug_info_for_branch(info);</span>
<span class="line-removed"> 595       __ testl(rax, polling_page);</span>
<span class="line-removed"> 596     }</span>
<span class="line-removed"> 597   }</span>
 598   return offset;
 599 }
 600 
 601 
 602 void LIR_Assembler::move_regs(Register from_reg, Register to_reg) {
 603   if (from_reg != to_reg) __ mov(to_reg, from_reg);
 604 }
 605 
 606 void LIR_Assembler::swap_reg(Register a, Register b) {
 607   __ xchgptr(a, b);
 608 }
 609 
 610 
 611 void LIR_Assembler::const2reg(LIR_Opr src, LIR_Opr dest, LIR_PatchCode patch_code, CodeEmitInfo* info) {
 612   assert(src-&gt;is_constant(), &quot;should not call otherwise&quot;);
 613   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
 614   LIR_Const* c = src-&gt;as_constant_ptr();
 615 
 616   switch (c-&gt;type()) {
 617     case T_INT: {
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
 519 
 520 
 521 void LIR_Assembler::return_op(LIR_Opr result) {
 522   assert(result-&gt;is_illegal() || !result-&gt;is_single_cpu() || result-&gt;as_register() == rax, &quot;word returns are in rax,&quot;);
 523   if (!result-&gt;is_illegal() &amp;&amp; result-&gt;is_float_kind() &amp;&amp; !result-&gt;is_xmm_register()) {
 524     assert(result-&gt;fpu() == 0, &quot;result must already be on TOS&quot;);
 525   }
 526 
 527   // Pop the stack before the safepoint code
 528   __ remove_frame(initial_frame_size_in_bytes());
 529 
 530   if (StackReservedPages &gt; 0 &amp;&amp; compilation()-&gt;has_reserved_stack_access()) {
 531     __ reserved_stack_check();
 532   }
 533 
 534   bool result_is_oop = result-&gt;is_valid() ? result-&gt;is_oop() : false;
 535 
 536   // Note: we do not need to round double result; float result has the right precision
 537   // the poll sets the condition code, but no data registers
 538 

 539 #ifdef _LP64
<span class="line-modified"> 540   const Register poll_addr = rscratch1;</span>
<span class="line-modified"> 541   __ movptr(poll_addr, Address(r15_thread, Thread::polling_page_offset()));</span>
 542 #else
<span class="line-modified"> 543   const Register poll_addr = rbx;</span>
<span class="line-modified"> 544   assert(FrameMap::is_caller_save_register(poll_addr), &quot;will overwrite&quot;);</span>
<span class="line-modified"> 545   __ get_thread(poll_addr);</span>
<span class="line-modified"> 546   __ movptr(poll_addr, Address(poll_addr, Thread::polling_page_offset()));</span>
 547 #endif
<span class="line-modified"> 548   __ relocate(relocInfo::poll_return_type);</span>
<span class="line-modified"> 549   __ testl(rax, Address(poll_addr, 0));</span>











 550   __ ret(0);
 551 }
 552 
 553 
 554 int LIR_Assembler::safepoint_poll(LIR_Opr tmp, CodeEmitInfo* info) {
 555   guarantee(info != NULL, &quot;Shouldn&#39;t be NULL&quot;);
 556   int offset = __ offset();

 557 #ifdef _LP64
<span class="line-modified"> 558   const Register poll_addr = rscratch1;</span>
<span class="line-modified"> 559   __ movptr(poll_addr, Address(r15_thread, Thread::polling_page_offset()));</span>
 560 #else
<span class="line-modified"> 561   assert(tmp-&gt;is_cpu_register(), &quot;needed&quot;);</span>
<span class="line-modified"> 562   const Register poll_addr = tmp-&gt;as_register();</span>
<span class="line-modified"> 563   __ get_thread(poll_addr);</span>
<span class="line-modified"> 564   __ movptr(poll_addr, Address(poll_addr, in_bytes(Thread::polling_page_offset())));</span>
 565 #endif
<span class="line-modified"> 566   add_debug_info_for_branch(info);</span>
<span class="line-modified"> 567   __ relocate(relocInfo::poll_type);</span>
<span class="line-modified"> 568   address pre_pc = __ pc();</span>
<span class="line-modified"> 569   __ testl(rax, Address(poll_addr, 0));</span>
<span class="line-modified"> 570   address post_pc = __ pc();</span>
<span class="line-modified"> 571   guarantee(pointer_delta(post_pc, pre_pc, 1) == 2 LP64_ONLY(+1), &quot;must be exact length&quot;);</span>













 572   return offset;
 573 }
 574 
 575 
 576 void LIR_Assembler::move_regs(Register from_reg, Register to_reg) {
 577   if (from_reg != to_reg) __ mov(to_reg, from_reg);
 578 }
 579 
 580 void LIR_Assembler::swap_reg(Register a, Register b) {
 581   __ xchgptr(a, b);
 582 }
 583 
 584 
 585 void LIR_Assembler::const2reg(LIR_Opr src, LIR_Opr dest, LIR_PatchCode patch_code, CodeEmitInfo* info) {
 586   assert(src-&gt;is_constant(), &quot;should not call otherwise&quot;);
 587   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
 588   LIR_Const* c = src-&gt;as_constant_ptr();
 589 
 590   switch (c-&gt;type()) {
 591     case T_INT: {
</pre>
</td>
</tr>
</table>
<center><a href="assembler_x86.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIRGenerator_x86.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
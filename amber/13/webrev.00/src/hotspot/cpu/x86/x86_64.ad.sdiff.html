<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/x86_64.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="x86_32.ad.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../zero/frame_zero.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/x86_64.ad</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
    1 //
<span class="line-modified">    2 // Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
    3 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    4 //
    5 // This code is free software; you can redistribute it and/or modify it
    6 // under the terms of the GNU General Public License version 2 only, as
    7 // published by the Free Software Foundation.
    8 //
    9 // This code is distributed in the hope that it will be useful, but WITHOUT
   10 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   11 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   12 // version 2 for more details (a copy is included in the LICENSE file that
   13 // accompanied this code).
   14 //
   15 // You should have received a copy of the GNU General Public License version
   16 // 2 along with this work; if not, write to the Free Software Foundation,
   17 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   18 //
   19 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   20 // or visit www.oracle.com if you need additional information or have any
   21 // questions.
   22 //
</pre>
<hr />
<pre>
  442 int MachCallStaticJavaNode::ret_addr_offset()
  443 {
  444   int offset = 5; // 5 bytes from start of call to where return address points
  445   offset += clear_avx_size();
  446   return offset;
  447 }
  448 
  449 int MachCallDynamicJavaNode::ret_addr_offset()
  450 {
  451   int offset = 15; // 15 bytes from start of call to where return address points
  452   offset += clear_avx_size();
  453   return offset;
  454 }
  455 
  456 int MachCallRuntimeNode::ret_addr_offset() {
  457   int offset = 13; // movq r10,#addr; callq (r10)
  458   offset += clear_avx_size();
  459   return offset;
  460 }
  461 
<span class="line-removed">  462 // Indicate if the safepoint node needs the polling page as an input,</span>
<span class="line-removed">  463 // it does if the polling page is more than disp32 away.</span>
<span class="line-removed">  464 bool SafePointNode::needs_polling_address_input()</span>
<span class="line-removed">  465 {</span>
<span class="line-removed">  466   return SafepointMechanism::uses_thread_local_poll() || Assembler::is_polling_page_far();</span>
<span class="line-removed">  467 }</span>
<span class="line-removed">  468 </span>
  469 //
  470 // Compute padding required for nodes which need alignment
  471 //
  472 
  473 // The address of the call instruction needs to be 4-byte aligned to
  474 // ensure that it does not span a cache line so that it can be patched.
  475 int CallStaticJavaDirectNode::compute_padding(int current_offset) const
  476 {
  477   current_offset += clear_avx_size(); // skip vzeroupper
  478   current_offset += 1; // skip call opcode byte
  479   return align_up(current_offset, alignment_required()) - current_offset;
  480 }
  481 
  482 // The address of the call instruction needs to be 4-byte aligned to
  483 // ensure that it does not span a cache line so that it can be patched.
  484 int CallDynamicJavaDirectNode::compute_padding(int current_offset) const
  485 {
  486   current_offset += clear_avx_size(); // skip vzeroupper
  487   current_offset += 11; // skip movq instruction + call opcode byte
  488   return align_up(current_offset, alignment_required()) - current_offset;
</pre>
<hr />
<pre>
  768     __ movdl(dst, rt);
  769   }
  770   else {
  771     __ mov64(rt, 0x7ff8000000000000L); // Double.NaN
  772     __ movdq(dst, rt);
  773   }
  774   __ jmp(done);
  775 
  776   __ bind(below);
  777   if (single)
  778     __ movflt(dst, min ? a : b);
  779   else
  780     __ movdbl(dst, min ? a : b);
  781 
  782   __ bind(done);
  783 }
  784 
  785 //=============================================================================
  786 const RegMask&amp; MachConstantBaseNode::_out_RegMask = RegMask::Empty;
  787 
<span class="line-modified">  788 int Compile::ConstantTable::calculate_table_base_offset() const {</span>
  789   return 0;  // absolute addressing, no offset
  790 }
  791 
  792 bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
  793 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
  794   ShouldNotReachHere();
  795 }
  796 
  797 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
  798   // Empty encoding
  799 }
  800 
  801 uint MachConstantBaseNode::size(PhaseRegAlloc* ra_) const {
  802   return 0;
  803 }
  804 
  805 #ifndef PRODUCT
  806 void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  807   st-&gt;print(&quot;# MachConstantBaseNode (empty encoding)&quot;);
  808 }
  809 #endif
  810 
  811 
  812 //=============================================================================
  813 #ifndef PRODUCT
  814 void MachPrologNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  815   Compile* C = ra_-&gt;C;
  816 
<span class="line-modified">  817   int framesize = C-&gt;frame_size_in_bytes();</span>
<span class="line-modified">  818   int bangsize = C-&gt;bang_size_in_bytes();</span>
  819   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  820   // Remove wordSize for return addr which is already pushed.
  821   framesize -= wordSize;
  822 
<span class="line-modified">  823   if (C-&gt;need_stack_bang(bangsize)) {</span>
  824     framesize -= wordSize;
  825     st-&gt;print(&quot;# stack bang (%d bytes)&quot;, bangsize);
  826     st-&gt;print(&quot;\n\t&quot;);
  827     st-&gt;print(&quot;pushq   rbp\t# Save rbp&quot;);
  828     if (PreserveFramePointer) {
  829         st-&gt;print(&quot;\n\t&quot;);
  830         st-&gt;print(&quot;movq    rbp, rsp\t# Save the caller&#39;s SP into rbp&quot;);
  831     }
  832     if (framesize) {
  833       st-&gt;print(&quot;\n\t&quot;);
  834       st-&gt;print(&quot;subq    rsp, #%d\t# Create frame&quot;,framesize);
  835     }
  836   } else {
  837     st-&gt;print(&quot;subq    rsp, #%d\t# Create frame&quot;,framesize);
  838     st-&gt;print(&quot;\n\t&quot;);
  839     framesize -= wordSize;
  840     st-&gt;print(&quot;movq    [rsp + #%d], rbp\t# Save rbp&quot;,framesize);
  841     if (PreserveFramePointer) {
  842       st-&gt;print(&quot;\n\t&quot;);
  843       st-&gt;print(&quot;movq    rbp, rsp\t# Save the caller&#39;s SP into rbp&quot;);
</pre>
<hr />
<pre>
  857     st-&gt;print(&quot;# stack alignment check&quot;);
  858 #endif
  859   }
  860   if (C-&gt;stub_function() != NULL &amp;&amp; BarrierSet::barrier_set()-&gt;barrier_set_nmethod() != NULL) {
  861     st-&gt;print(&quot;\n\t&quot;);
  862     st-&gt;print(&quot;cmpl    [r15_thread + #disarmed_offset], #disarmed_value\t&quot;);
  863     st-&gt;print(&quot;\n\t&quot;);
  864     st-&gt;print(&quot;je      fast_entry\t&quot;);
  865     st-&gt;print(&quot;\n\t&quot;);
  866     st-&gt;print(&quot;call    #nmethod_entry_barrier_stub\t&quot;);
  867     st-&gt;print(&quot;\n\tfast_entry:&quot;);
  868   }
  869   st-&gt;cr();
  870 }
  871 #endif
  872 
  873 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  874   Compile* C = ra_-&gt;C;
  875   MacroAssembler _masm(&amp;cbuf);
  876 
<span class="line-modified">  877   int framesize = C-&gt;frame_size_in_bytes();</span>
<span class="line-modified">  878   int bangsize = C-&gt;bang_size_in_bytes();</span>
  879 
  880   if (C-&gt;clinit_barrier_on_entry()) {
  881     assert(VM_Version::supports_fast_class_init_checks(), &quot;sanity&quot;);
  882     assert(!C-&gt;method()-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);
  883 
  884     Label L_skip_barrier;
  885     Register klass = rscratch1;
  886 
  887     __ mov_metadata(klass, C-&gt;method()-&gt;holder()-&gt;constant_encoding());
  888     __ clinit_barrier(klass, r15_thread, &amp;L_skip_barrier /*L_fast_path*/);
  889 
  890     __ jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub())); // slow path
  891 
  892     __ bind(L_skip_barrier);
  893   }
  894 
<span class="line-modified">  895   __ verified_entry(framesize, C-&gt;need_stack_bang(bangsize)?bangsize:0, false, C-&gt;stub_function() != NULL);</span>
  896 
<span class="line-modified">  897   C-&gt;set_frame_complete(cbuf.insts_size());</span>
  898 
  899   if (C-&gt;has_mach_constant_base_node()) {
  900     // NOTE: We set the table base offset here because users might be
  901     // emitted before MachConstantBaseNode.
<span class="line-modified">  902     Compile::ConstantTable&amp; constant_table = C-&gt;constant_table();</span>
  903     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
  904   }
  905 }
  906 
  907 uint MachPrologNode::size(PhaseRegAlloc* ra_) const
  908 {
  909   return MachNode::size(ra_); // too many variables; just compute it
  910                               // the hard way
  911 }
  912 
  913 int MachPrologNode::reloc() const
  914 {
  915   return 0; // a large enough number
  916 }
  917 
  918 //=============================================================================
  919 #ifndef PRODUCT
  920 void MachEpilogNode::format(PhaseRegAlloc* ra_, outputStream* st) const
  921 {
  922   Compile* C = ra_-&gt;C;
  923   if (generate_vzeroupper(C)) {
  924     st-&gt;print(&quot;vzeroupper&quot;);
  925     st-&gt;cr(); st-&gt;print(&quot;\t&quot;);
  926   }
  927 
<span class="line-modified">  928   int framesize = C-&gt;frame_size_in_bytes();</span>
  929   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  930   // Remove word for return adr already pushed
  931   // and RBP
  932   framesize -= 2*wordSize;
  933 
  934   if (framesize) {
  935     st-&gt;print_cr(&quot;addq    rsp, %d\t# Destroy frame&quot;, framesize);
  936     st-&gt;print(&quot;\t&quot;);
  937   }
  938 
  939   st-&gt;print_cr(&quot;popq    rbp&quot;);
  940   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  941     st-&gt;print(&quot;\t&quot;);
<span class="line-modified">  942     if (SafepointMechanism::uses_thread_local_poll()) {</span>
<span class="line-modified">  943       st-&gt;print_cr(&quot;movq    rscratch1, poll_offset[r15_thread] #polling_page_address\n\t&quot;</span>
<span class="line-modified">  944                    &quot;testl   rax, [rscratch1]\t&quot;</span>
<span class="line-removed">  945                    &quot;# Safepoint: poll for GC&quot;);</span>
<span class="line-removed">  946     } else if (Assembler::is_polling_page_far()) {</span>
<span class="line-removed">  947       st-&gt;print_cr(&quot;movq    rscratch1, #polling_page_address\n\t&quot;</span>
<span class="line-removed">  948                    &quot;testl   rax, [rscratch1]\t&quot;</span>
<span class="line-removed">  949                    &quot;# Safepoint: poll for GC&quot;);</span>
<span class="line-removed">  950     } else {</span>
<span class="line-removed">  951       st-&gt;print_cr(&quot;testl   rax, [rip + #offset_to_poll_page]\t&quot;</span>
<span class="line-removed">  952                    &quot;# Safepoint: poll for GC&quot;);</span>
<span class="line-removed">  953     }</span>
  954   }
  955 }
  956 #endif
  957 
  958 void MachEpilogNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
  959 {
  960   Compile* C = ra_-&gt;C;
  961   MacroAssembler _masm(&amp;cbuf);
  962 
  963   if (generate_vzeroupper(C)) {
  964     // Clear upper bits of YMM registers when current compiled code uses
  965     // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
  966     __ vzeroupper();
  967   }
  968 
<span class="line-modified">  969   int framesize = C-&gt;frame_size_in_bytes();</span>
  970   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  971   // Remove word for return adr already pushed
  972   // and RBP
  973   framesize -= 2*wordSize;
  974 
  975   // Note that VerifyStackAtCalls&#39; Majik cookie does not change the frame size popped here
  976 
  977   if (framesize) {
  978     emit_opcode(cbuf, Assembler::REX_W);
  979     if (framesize &lt; 0x80) {
  980       emit_opcode(cbuf, 0x83); // addq rsp, #framesize
  981       emit_rm(cbuf, 0x3, 0x00, RSP_enc);
  982       emit_d8(cbuf, framesize);
  983     } else {
  984       emit_opcode(cbuf, 0x81); // addq rsp, #framesize
  985       emit_rm(cbuf, 0x3, 0x00, RSP_enc);
  986       emit_d32(cbuf, framesize);
  987     }
  988   }
  989 
  990   // popq rbp
  991   emit_opcode(cbuf, 0x58 | RBP_enc);
  992 
  993   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
  994     __ reserved_stack_check();
  995   }
  996 
  997   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  998     MacroAssembler _masm(&amp;cbuf);
<span class="line-modified">  999     if (SafepointMechanism::uses_thread_local_poll()) {</span>
<span class="line-modified"> 1000       __ movq(rscratch1, Address(r15_thread, Thread::polling_page_offset()));</span>
<span class="line-modified"> 1001       __ relocate(relocInfo::poll_return_type);</span>
<span class="line-removed"> 1002       __ testl(rax, Address(rscratch1, 0));</span>
<span class="line-removed"> 1003     } else {</span>
<span class="line-removed"> 1004       AddressLiteral polling_page(os::get_polling_page(), relocInfo::poll_return_type);</span>
<span class="line-removed"> 1005       if (Assembler::is_polling_page_far()) {</span>
<span class="line-removed"> 1006         __ lea(rscratch1, polling_page);</span>
<span class="line-removed"> 1007         __ relocate(relocInfo::poll_return_type);</span>
<span class="line-removed"> 1008         __ testl(rax, Address(rscratch1, 0));</span>
<span class="line-removed"> 1009       } else {</span>
<span class="line-removed"> 1010         __ testl(rax, polling_page);</span>
<span class="line-removed"> 1011       }</span>
<span class="line-removed"> 1012     }</span>
 1013   }
 1014 }
 1015 
 1016 uint MachEpilogNode::size(PhaseRegAlloc* ra_) const
 1017 {
 1018   return MachNode::size(ra_); // too many variables; just compute it
 1019                               // the hard way
 1020 }
 1021 
 1022 int MachEpilogNode::reloc() const
 1023 {
 1024   return 2; // a large enough number
 1025 }
 1026 
 1027 const Pipeline* MachEpilogNode::pipeline() const
 1028 {
 1029   return MachNode::pipeline_class();
 1030 }
 1031 
<span class="line-removed"> 1032 int MachEpilogNode::safepoint_offset() const</span>
<span class="line-removed"> 1033 {</span>
<span class="line-removed"> 1034   return 0;</span>
<span class="line-removed"> 1035 }</span>
<span class="line-removed"> 1036 </span>
 1037 //=============================================================================
 1038 
 1039 enum RC {
 1040   rc_bad,
 1041   rc_int,
 1042   rc_float,
 1043   rc_stack
 1044 };
 1045 
 1046 static enum RC rc_class(OptoReg::Name reg)
 1047 {
 1048   if( !OptoReg::is_valid(reg)  ) return rc_bad;
 1049 
 1050   if (OptoReg::is_stack(reg)) return rc_stack;
 1051 
 1052   VMReg r = OptoReg::as_VMReg(reg);
 1053 
 1054   if (r-&gt;is_Register()) return rc_int;
 1055 
 1056   assert(r-&gt;is_XMMRegister(), &quot;must be&quot;);
</pre>
<hr />
<pre>
 3103   match(ConL);
 3104 
 3105   op_cost(10);
 3106   format %{ %}
 3107   interface(CONST_INTER);
 3108 %}
 3109 
 3110 // Long Immediate 32-bit signed
 3111 operand immL32()
 3112 %{
 3113   predicate(n-&gt;get_long() == (int) (n-&gt;get_long()));
 3114   match(ConL);
 3115 
 3116   op_cost(15);
 3117   format %{ %}
 3118   interface(CONST_INTER);
 3119 %}
 3120 
 3121 operand immL_Pow2()
 3122 %{
<span class="line-modified"> 3123   predicate(is_power_of_2(n-&gt;get_long()));</span>
 3124   match(ConL);
 3125 
 3126   op_cost(15);
 3127   format %{ %}
 3128   interface(CONST_INTER);
 3129 %}
 3130 
 3131 operand immL_NotPow2()
 3132 %{
<span class="line-modified"> 3133   predicate(is_power_of_2(~n-&gt;get_long()));</span>
 3134   match(ConL);
 3135 
 3136   op_cost(15);
 3137   format %{ %}
 3138   interface(CONST_INTER);
 3139 %}
 3140 
 3141 // Long Immediate zero
 3142 operand immL0()
 3143 %{
 3144   predicate(n-&gt;get_long() == 0L);
 3145   match(ConL);
 3146 
 3147   op_cost(10);
 3148   format %{ %}
 3149   interface(CONST_INTER);
 3150 %}
 3151 
 3152 // Constant for increment
 3153 operand immL1()
</pre>
<hr />
<pre>
10012   ins_cost(125);
10013   format %{ &quot;orq     $dst, $src\t# long&quot; %}
10014   opcode(0x81, 0x1); /* Opcode 81 /1 id */
10015   ins_encode(REX_mem_wide(dst), OpcSE(src),
10016              RM_opc_mem(secondary, dst), Con8or32(src));
10017   ins_pipe(ialu_mem_imm);
10018 %}
10019 
10020 instruct btsL_mem_imm(memory dst, immL_Pow2 con, rFlagsReg cr)
10021 %{
10022   // con should be a pure 64-bit power of 2 immediate
10023   // because AND/OR works well enough for 8/32-bit values.
10024   predicate(log2_long(n-&gt;in(3)-&gt;in(2)-&gt;get_long()) &gt; 31);
10025 
10026   match(Set dst (StoreL dst (OrL (LoadL dst) con)));
10027   effect(KILL cr);
10028 
10029   ins_cost(125);
10030   format %{ &quot;btsq    $dst, log2($con)\t# long&quot; %}
10031   ins_encode %{
<span class="line-modified">10032     __ btsq($dst$$Address, log2_long($con$$constant));</span>
10033   %}
10034   ins_pipe(ialu_mem_imm);
10035 %}
10036 
10037 // Xor Instructions
10038 // Xor Register with Register
10039 instruct xorL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
10040 %{
10041   match(Set dst (XorL dst src));
10042   effect(KILL cr);
10043 
10044   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10045   opcode(0x33);
10046   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
10047   ins_pipe(ialu_reg_reg);
10048 %}
10049 
10050 // Xor Register with Immediate -1
10051 instruct xorL_rReg_im1(rRegL dst, immL_M1 imm) %{
10052   match(Set dst (XorL dst imm));
</pre>
<hr />
<pre>
12519     __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,
12520                  $scr$$Register, noreg, noreg, _counters, NULL, NULL, NULL, false, false);
12521   %}
12522   ins_pipe(pipe_slow);
12523 %}
12524 
12525 instruct cmpFastUnlock(rFlagsReg cr, rRegP object, rax_RegP box, rRegP tmp) %{
12526   match(Set cr (FastUnlock object box));
12527   effect(TEMP tmp, USE_KILL box);
12528   ins_cost(300);
12529   format %{ &quot;fastunlock $object,$box\t! kills $box,$tmp&quot; %}
12530   ins_encode %{
12531     __ fast_unlock($object$$Register, $box$$Register, $tmp$$Register, ra_-&gt;C-&gt;use_rtm());
12532   %}
12533   ins_pipe(pipe_slow);
12534 %}
12535 
12536 
12537 // ============================================================================
12538 // Safepoint Instructions
<span class="line-removed">12539 instruct safePoint_poll(rFlagsReg cr)</span>
<span class="line-removed">12540 %{</span>
<span class="line-removed">12541   predicate(!Assembler::is_polling_page_far() &amp;&amp; SafepointMechanism::uses_global_page_poll());</span>
<span class="line-removed">12542   match(SafePoint);</span>
<span class="line-removed">12543   effect(KILL cr);</span>
<span class="line-removed">12544 </span>
<span class="line-removed">12545   format %{ &quot;testl   rax, [rip + #offset_to_poll_page]\t&quot;</span>
<span class="line-removed">12546             &quot;# Safepoint: poll for GC&quot; %}</span>
<span class="line-removed">12547   ins_cost(125);</span>
<span class="line-removed">12548   ins_encode %{</span>
<span class="line-removed">12549     AddressLiteral addr(os::get_polling_page(), relocInfo::poll_type);</span>
<span class="line-removed">12550     __ testl(rax, addr);</span>
<span class="line-removed">12551   %}</span>
<span class="line-removed">12552   ins_pipe(ialu_reg_mem);</span>
<span class="line-removed">12553 %}</span>
<span class="line-removed">12554 </span>
<span class="line-removed">12555 instruct safePoint_poll_far(rFlagsReg cr, rRegP poll)</span>
<span class="line-removed">12556 %{</span>
<span class="line-removed">12557   predicate(Assembler::is_polling_page_far() &amp;&amp; SafepointMechanism::uses_global_page_poll());</span>
<span class="line-removed">12558   match(SafePoint poll);</span>
<span class="line-removed">12559   effect(KILL cr, USE poll);</span>
<span class="line-removed">12560 </span>
<span class="line-removed">12561   format %{ &quot;testl   rax, [$poll]\t&quot;</span>
<span class="line-removed">12562             &quot;# Safepoint: poll for GC&quot; %}</span>
<span class="line-removed">12563   ins_cost(125);</span>
<span class="line-removed">12564   ins_encode %{</span>
<span class="line-removed">12565     __ relocate(relocInfo::poll_type);</span>
<span class="line-removed">12566     __ testl(rax, Address($poll$$Register, 0));</span>
<span class="line-removed">12567   %}</span>
<span class="line-removed">12568   ins_pipe(ialu_reg_mem);</span>
<span class="line-removed">12569 %}</span>
<span class="line-removed">12570 </span>
12571 instruct safePoint_poll_tls(rFlagsReg cr, rRegP poll)
12572 %{
<span class="line-removed">12573   predicate(SafepointMechanism::uses_thread_local_poll());</span>
12574   match(SafePoint poll);
12575   effect(KILL cr, USE poll);
12576 
12577   format %{ &quot;testl   rax, [$poll]\t&quot;
12578             &quot;# Safepoint: poll for GC&quot; %}
12579   ins_cost(125);
12580   size(4); /* setting an explicit size will cause debug builds to assert if size is incorrect */
12581   ins_encode %{
12582     __ relocate(relocInfo::poll_type);
12583     address pre_pc = __ pc();
12584     __ testl(rax, Address($poll$$Register, 0));
12585     assert(nativeInstruction_at(pre_pc)-&gt;is_safepoint_poll(), &quot;must emit test %%eax [reg]&quot;);
12586   %}
12587   ins_pipe(ialu_reg_mem);
12588 %}
12589 
12590 // ============================================================================
12591 // Procedure Call/Return Instructions
12592 // Call Java Static Instruction
12593 // Note: If this code changes, the corresponding ret_addr_offset() and
</pre>
</td>
<td>
<hr />
<pre>
    1 //
<span class="line-modified">    2 // Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
    3 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    4 //
    5 // This code is free software; you can redistribute it and/or modify it
    6 // under the terms of the GNU General Public License version 2 only, as
    7 // published by the Free Software Foundation.
    8 //
    9 // This code is distributed in the hope that it will be useful, but WITHOUT
   10 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   11 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   12 // version 2 for more details (a copy is included in the LICENSE file that
   13 // accompanied this code).
   14 //
   15 // You should have received a copy of the GNU General Public License version
   16 // 2 along with this work; if not, write to the Free Software Foundation,
   17 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   18 //
   19 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   20 // or visit www.oracle.com if you need additional information or have any
   21 // questions.
   22 //
</pre>
<hr />
<pre>
  442 int MachCallStaticJavaNode::ret_addr_offset()
  443 {
  444   int offset = 5; // 5 bytes from start of call to where return address points
  445   offset += clear_avx_size();
  446   return offset;
  447 }
  448 
  449 int MachCallDynamicJavaNode::ret_addr_offset()
  450 {
  451   int offset = 15; // 15 bytes from start of call to where return address points
  452   offset += clear_avx_size();
  453   return offset;
  454 }
  455 
  456 int MachCallRuntimeNode::ret_addr_offset() {
  457   int offset = 13; // movq r10,#addr; callq (r10)
  458   offset += clear_avx_size();
  459   return offset;
  460 }
  461 







  462 //
  463 // Compute padding required for nodes which need alignment
  464 //
  465 
  466 // The address of the call instruction needs to be 4-byte aligned to
  467 // ensure that it does not span a cache line so that it can be patched.
  468 int CallStaticJavaDirectNode::compute_padding(int current_offset) const
  469 {
  470   current_offset += clear_avx_size(); // skip vzeroupper
  471   current_offset += 1; // skip call opcode byte
  472   return align_up(current_offset, alignment_required()) - current_offset;
  473 }
  474 
  475 // The address of the call instruction needs to be 4-byte aligned to
  476 // ensure that it does not span a cache line so that it can be patched.
  477 int CallDynamicJavaDirectNode::compute_padding(int current_offset) const
  478 {
  479   current_offset += clear_avx_size(); // skip vzeroupper
  480   current_offset += 11; // skip movq instruction + call opcode byte
  481   return align_up(current_offset, alignment_required()) - current_offset;
</pre>
<hr />
<pre>
  761     __ movdl(dst, rt);
  762   }
  763   else {
  764     __ mov64(rt, 0x7ff8000000000000L); // Double.NaN
  765     __ movdq(dst, rt);
  766   }
  767   __ jmp(done);
  768 
  769   __ bind(below);
  770   if (single)
  771     __ movflt(dst, min ? a : b);
  772   else
  773     __ movdbl(dst, min ? a : b);
  774 
  775   __ bind(done);
  776 }
  777 
  778 //=============================================================================
  779 const RegMask&amp; MachConstantBaseNode::_out_RegMask = RegMask::Empty;
  780 
<span class="line-modified">  781 int ConstantTable::calculate_table_base_offset() const {</span>
  782   return 0;  // absolute addressing, no offset
  783 }
  784 
  785 bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
  786 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
  787   ShouldNotReachHere();
  788 }
  789 
  790 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
  791   // Empty encoding
  792 }
  793 
  794 uint MachConstantBaseNode::size(PhaseRegAlloc* ra_) const {
  795   return 0;
  796 }
  797 
  798 #ifndef PRODUCT
  799 void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  800   st-&gt;print(&quot;# MachConstantBaseNode (empty encoding)&quot;);
  801 }
  802 #endif
  803 
  804 
  805 //=============================================================================
  806 #ifndef PRODUCT
  807 void MachPrologNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  808   Compile* C = ra_-&gt;C;
  809 
<span class="line-modified">  810   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();</span>
<span class="line-modified">  811   int bangsize = C-&gt;output()-&gt;bang_size_in_bytes();</span>
  812   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  813   // Remove wordSize for return addr which is already pushed.
  814   framesize -= wordSize;
  815 
<span class="line-modified">  816   if (C-&gt;output()-&gt;need_stack_bang(bangsize)) {</span>
  817     framesize -= wordSize;
  818     st-&gt;print(&quot;# stack bang (%d bytes)&quot;, bangsize);
  819     st-&gt;print(&quot;\n\t&quot;);
  820     st-&gt;print(&quot;pushq   rbp\t# Save rbp&quot;);
  821     if (PreserveFramePointer) {
  822         st-&gt;print(&quot;\n\t&quot;);
  823         st-&gt;print(&quot;movq    rbp, rsp\t# Save the caller&#39;s SP into rbp&quot;);
  824     }
  825     if (framesize) {
  826       st-&gt;print(&quot;\n\t&quot;);
  827       st-&gt;print(&quot;subq    rsp, #%d\t# Create frame&quot;,framesize);
  828     }
  829   } else {
  830     st-&gt;print(&quot;subq    rsp, #%d\t# Create frame&quot;,framesize);
  831     st-&gt;print(&quot;\n\t&quot;);
  832     framesize -= wordSize;
  833     st-&gt;print(&quot;movq    [rsp + #%d], rbp\t# Save rbp&quot;,framesize);
  834     if (PreserveFramePointer) {
  835       st-&gt;print(&quot;\n\t&quot;);
  836       st-&gt;print(&quot;movq    rbp, rsp\t# Save the caller&#39;s SP into rbp&quot;);
</pre>
<hr />
<pre>
  850     st-&gt;print(&quot;# stack alignment check&quot;);
  851 #endif
  852   }
  853   if (C-&gt;stub_function() != NULL &amp;&amp; BarrierSet::barrier_set()-&gt;barrier_set_nmethod() != NULL) {
  854     st-&gt;print(&quot;\n\t&quot;);
  855     st-&gt;print(&quot;cmpl    [r15_thread + #disarmed_offset], #disarmed_value\t&quot;);
  856     st-&gt;print(&quot;\n\t&quot;);
  857     st-&gt;print(&quot;je      fast_entry\t&quot;);
  858     st-&gt;print(&quot;\n\t&quot;);
  859     st-&gt;print(&quot;call    #nmethod_entry_barrier_stub\t&quot;);
  860     st-&gt;print(&quot;\n\tfast_entry:&quot;);
  861   }
  862   st-&gt;cr();
  863 }
  864 #endif
  865 
  866 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  867   Compile* C = ra_-&gt;C;
  868   MacroAssembler _masm(&amp;cbuf);
  869 
<span class="line-modified">  870   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();</span>
<span class="line-modified">  871   int bangsize = C-&gt;output()-&gt;bang_size_in_bytes();</span>
  872 
  873   if (C-&gt;clinit_barrier_on_entry()) {
  874     assert(VM_Version::supports_fast_class_init_checks(), &quot;sanity&quot;);
  875     assert(!C-&gt;method()-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);
  876 
  877     Label L_skip_barrier;
  878     Register klass = rscratch1;
  879 
  880     __ mov_metadata(klass, C-&gt;method()-&gt;holder()-&gt;constant_encoding());
  881     __ clinit_barrier(klass, r15_thread, &amp;L_skip_barrier /*L_fast_path*/);
  882 
  883     __ jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub())); // slow path
  884 
  885     __ bind(L_skip_barrier);
  886   }
  887 
<span class="line-modified">  888   __ verified_entry(framesize, C-&gt;output()-&gt;need_stack_bang(bangsize)?bangsize:0, false, C-&gt;stub_function() != NULL);</span>
  889 
<span class="line-modified">  890   C-&gt;output()-&gt;set_frame_complete(cbuf.insts_size());</span>
  891 
  892   if (C-&gt;has_mach_constant_base_node()) {
  893     // NOTE: We set the table base offset here because users might be
  894     // emitted before MachConstantBaseNode.
<span class="line-modified">  895     ConstantTable&amp; constant_table = C-&gt;output()-&gt;constant_table();</span>
  896     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
  897   }
  898 }
  899 
  900 uint MachPrologNode::size(PhaseRegAlloc* ra_) const
  901 {
  902   return MachNode::size(ra_); // too many variables; just compute it
  903                               // the hard way
  904 }
  905 
  906 int MachPrologNode::reloc() const
  907 {
  908   return 0; // a large enough number
  909 }
  910 
  911 //=============================================================================
  912 #ifndef PRODUCT
  913 void MachEpilogNode::format(PhaseRegAlloc* ra_, outputStream* st) const
  914 {
  915   Compile* C = ra_-&gt;C;
  916   if (generate_vzeroupper(C)) {
  917     st-&gt;print(&quot;vzeroupper&quot;);
  918     st-&gt;cr(); st-&gt;print(&quot;\t&quot;);
  919   }
  920 
<span class="line-modified">  921   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();</span>
  922   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  923   // Remove word for return adr already pushed
  924   // and RBP
  925   framesize -= 2*wordSize;
  926 
  927   if (framesize) {
  928     st-&gt;print_cr(&quot;addq    rsp, %d\t# Destroy frame&quot;, framesize);
  929     st-&gt;print(&quot;\t&quot;);
  930   }
  931 
  932   st-&gt;print_cr(&quot;popq    rbp&quot;);
  933   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  934     st-&gt;print(&quot;\t&quot;);
<span class="line-modified">  935     st-&gt;print_cr(&quot;movq    rscratch1, poll_offset[r15_thread] #polling_page_address\n\t&quot;</span>
<span class="line-modified">  936                  &quot;testl   rax, [rscratch1]\t&quot;</span>
<span class="line-modified">  937                  &quot;# Safepoint: poll for GC&quot;);</span>









  938   }
  939 }
  940 #endif
  941 
  942 void MachEpilogNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
  943 {
  944   Compile* C = ra_-&gt;C;
  945   MacroAssembler _masm(&amp;cbuf);
  946 
  947   if (generate_vzeroupper(C)) {
  948     // Clear upper bits of YMM registers when current compiled code uses
  949     // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
  950     __ vzeroupper();
  951   }
  952 
<span class="line-modified">  953   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();</span>
  954   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  955   // Remove word for return adr already pushed
  956   // and RBP
  957   framesize -= 2*wordSize;
  958 
  959   // Note that VerifyStackAtCalls&#39; Majik cookie does not change the frame size popped here
  960 
  961   if (framesize) {
  962     emit_opcode(cbuf, Assembler::REX_W);
  963     if (framesize &lt; 0x80) {
  964       emit_opcode(cbuf, 0x83); // addq rsp, #framesize
  965       emit_rm(cbuf, 0x3, 0x00, RSP_enc);
  966       emit_d8(cbuf, framesize);
  967     } else {
  968       emit_opcode(cbuf, 0x81); // addq rsp, #framesize
  969       emit_rm(cbuf, 0x3, 0x00, RSP_enc);
  970       emit_d32(cbuf, framesize);
  971     }
  972   }
  973 
  974   // popq rbp
  975   emit_opcode(cbuf, 0x58 | RBP_enc);
  976 
  977   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
  978     __ reserved_stack_check();
  979   }
  980 
  981   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  982     MacroAssembler _masm(&amp;cbuf);
<span class="line-modified">  983     __ movq(rscratch1, Address(r15_thread, Thread::polling_page_offset()));</span>
<span class="line-modified">  984     __ relocate(relocInfo::poll_return_type);</span>
<span class="line-modified">  985     __ testl(rax, Address(rscratch1, 0));</span>











  986   }
  987 }
  988 
  989 uint MachEpilogNode::size(PhaseRegAlloc* ra_) const
  990 {
  991   return MachNode::size(ra_); // too many variables; just compute it
  992                               // the hard way
  993 }
  994 
  995 int MachEpilogNode::reloc() const
  996 {
  997   return 2; // a large enough number
  998 }
  999 
 1000 const Pipeline* MachEpilogNode::pipeline() const
 1001 {
 1002   return MachNode::pipeline_class();
 1003 }
 1004 





 1005 //=============================================================================
 1006 
 1007 enum RC {
 1008   rc_bad,
 1009   rc_int,
 1010   rc_float,
 1011   rc_stack
 1012 };
 1013 
 1014 static enum RC rc_class(OptoReg::Name reg)
 1015 {
 1016   if( !OptoReg::is_valid(reg)  ) return rc_bad;
 1017 
 1018   if (OptoReg::is_stack(reg)) return rc_stack;
 1019 
 1020   VMReg r = OptoReg::as_VMReg(reg);
 1021 
 1022   if (r-&gt;is_Register()) return rc_int;
 1023 
 1024   assert(r-&gt;is_XMMRegister(), &quot;must be&quot;);
</pre>
<hr />
<pre>
 3071   match(ConL);
 3072 
 3073   op_cost(10);
 3074   format %{ %}
 3075   interface(CONST_INTER);
 3076 %}
 3077 
 3078 // Long Immediate 32-bit signed
 3079 operand immL32()
 3080 %{
 3081   predicate(n-&gt;get_long() == (int) (n-&gt;get_long()));
 3082   match(ConL);
 3083 
 3084   op_cost(15);
 3085   format %{ %}
 3086   interface(CONST_INTER);
 3087 %}
 3088 
 3089 operand immL_Pow2()
 3090 %{
<span class="line-modified"> 3091   predicate(is_power_of_2((julong)n-&gt;get_long()));</span>
 3092   match(ConL);
 3093 
 3094   op_cost(15);
 3095   format %{ %}
 3096   interface(CONST_INTER);
 3097 %}
 3098 
 3099 operand immL_NotPow2()
 3100 %{
<span class="line-modified"> 3101   predicate(is_power_of_2((julong)~n-&gt;get_long()));</span>
 3102   match(ConL);
 3103 
 3104   op_cost(15);
 3105   format %{ %}
 3106   interface(CONST_INTER);
 3107 %}
 3108 
 3109 // Long Immediate zero
 3110 operand immL0()
 3111 %{
 3112   predicate(n-&gt;get_long() == 0L);
 3113   match(ConL);
 3114 
 3115   op_cost(10);
 3116   format %{ %}
 3117   interface(CONST_INTER);
 3118 %}
 3119 
 3120 // Constant for increment
 3121 operand immL1()
</pre>
<hr />
<pre>
 9980   ins_cost(125);
 9981   format %{ &quot;orq     $dst, $src\t# long&quot; %}
 9982   opcode(0x81, 0x1); /* Opcode 81 /1 id */
 9983   ins_encode(REX_mem_wide(dst), OpcSE(src),
 9984              RM_opc_mem(secondary, dst), Con8or32(src));
 9985   ins_pipe(ialu_mem_imm);
 9986 %}
 9987 
 9988 instruct btsL_mem_imm(memory dst, immL_Pow2 con, rFlagsReg cr)
 9989 %{
 9990   // con should be a pure 64-bit power of 2 immediate
 9991   // because AND/OR works well enough for 8/32-bit values.
 9992   predicate(log2_long(n-&gt;in(3)-&gt;in(2)-&gt;get_long()) &gt; 31);
 9993 
 9994   match(Set dst (StoreL dst (OrL (LoadL dst) con)));
 9995   effect(KILL cr);
 9996 
 9997   ins_cost(125);
 9998   format %{ &quot;btsq    $dst, log2($con)\t# long&quot; %}
 9999   ins_encode %{
<span class="line-modified">10000     __ btsq($dst$$Address, log2_long((julong)$con$$constant));</span>
10001   %}
10002   ins_pipe(ialu_mem_imm);
10003 %}
10004 
10005 // Xor Instructions
10006 // Xor Register with Register
10007 instruct xorL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
10008 %{
10009   match(Set dst (XorL dst src));
10010   effect(KILL cr);
10011 
10012   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10013   opcode(0x33);
10014   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
10015   ins_pipe(ialu_reg_reg);
10016 %}
10017 
10018 // Xor Register with Immediate -1
10019 instruct xorL_rReg_im1(rRegL dst, immL_M1 imm) %{
10020   match(Set dst (XorL dst imm));
</pre>
<hr />
<pre>
12487     __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,
12488                  $scr$$Register, noreg, noreg, _counters, NULL, NULL, NULL, false, false);
12489   %}
12490   ins_pipe(pipe_slow);
12491 %}
12492 
12493 instruct cmpFastUnlock(rFlagsReg cr, rRegP object, rax_RegP box, rRegP tmp) %{
12494   match(Set cr (FastUnlock object box));
12495   effect(TEMP tmp, USE_KILL box);
12496   ins_cost(300);
12497   format %{ &quot;fastunlock $object,$box\t! kills $box,$tmp&quot; %}
12498   ins_encode %{
12499     __ fast_unlock($object$$Register, $box$$Register, $tmp$$Register, ra_-&gt;C-&gt;use_rtm());
12500   %}
12501   ins_pipe(pipe_slow);
12502 %}
12503 
12504 
12505 // ============================================================================
12506 // Safepoint Instructions
































12507 instruct safePoint_poll_tls(rFlagsReg cr, rRegP poll)
12508 %{

12509   match(SafePoint poll);
12510   effect(KILL cr, USE poll);
12511 
12512   format %{ &quot;testl   rax, [$poll]\t&quot;
12513             &quot;# Safepoint: poll for GC&quot; %}
12514   ins_cost(125);
12515   size(4); /* setting an explicit size will cause debug builds to assert if size is incorrect */
12516   ins_encode %{
12517     __ relocate(relocInfo::poll_type);
12518     address pre_pc = __ pc();
12519     __ testl(rax, Address($poll$$Register, 0));
12520     assert(nativeInstruction_at(pre_pc)-&gt;is_safepoint_poll(), &quot;must emit test %%eax [reg]&quot;);
12521   %}
12522   ins_pipe(ialu_reg_mem);
12523 %}
12524 
12525 // ============================================================================
12526 // Procedure Call/Return Instructions
12527 // Call Java Static Instruction
12528 // Note: If this code changes, the corresponding ret_addr_offset() and
</pre>
</td>
</tr>
</table>
<center><a href="x86_32.ad.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../zero/frame_zero.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
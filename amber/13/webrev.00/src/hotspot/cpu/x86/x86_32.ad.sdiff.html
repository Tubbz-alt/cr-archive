<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/x86_32.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="x86.ad.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="x86_64.ad.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/x86_32.ad</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
    1 //
<span class="line-modified">    2 // Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
    3 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    4 //
    5 // This code is free software; you can redistribute it and/or modify it
    6 // under the terms of the GNU General Public License version 2 only, as
    7 // published by the Free Software Foundation.
    8 //
    9 // This code is distributed in the hope that it will be useful, but WITHOUT
   10 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   11 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   12 // version 2 for more details (a copy is included in the LICENSE file that
   13 // accompanied this code).
   14 //
   15 // You should have received a copy of the GNU General Public License version
   16 // 2 along with this work; if not, write to the Free Software Foundation,
   17 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   18 //
   19 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   20 // or visit www.oracle.com if you need additional information or have any
   21 // questions.
   22 //
</pre>
<hr />
<pre>
  297 }
  298 
  299 // !!!!! Special hack to get all type of calls to specify the byte offset
  300 //       from the start of the call to the point where the return address
  301 //       will point.
  302 int MachCallStaticJavaNode::ret_addr_offset() {
  303   return 5 + pre_call_resets_size();  // 5 bytes from start of call to where return address points
  304 }
  305 
  306 int MachCallDynamicJavaNode::ret_addr_offset() {
  307   return 10 + pre_call_resets_size();  // 10 bytes from start of call to where return address points
  308 }
  309 
  310 static int sizeof_FFree_Float_Stack_All = -1;
  311 
  312 int MachCallRuntimeNode::ret_addr_offset() {
  313   assert(sizeof_FFree_Float_Stack_All != -1, &quot;must have been emitted already&quot;);
  314   return sizeof_FFree_Float_Stack_All + 5 + pre_call_resets_size();
  315 }
  316 
<span class="line-removed">  317 // Indicate if the safepoint node needs the polling page as an input.</span>
<span class="line-removed">  318 // Since x86 does have absolute addressing, it doesn&#39;t.</span>
<span class="line-removed">  319 bool SafePointNode::needs_polling_address_input() {</span>
<span class="line-removed">  320   return SafepointMechanism::uses_thread_local_poll();</span>
<span class="line-removed">  321 }</span>
<span class="line-removed">  322 </span>
  323 //
  324 // Compute padding required for nodes which need alignment
  325 //
  326 
  327 // The address of the call instruction needs to be 4-byte aligned to
  328 // ensure that it does not span a cache line so that it can be patched.
  329 int CallStaticJavaDirectNode::compute_padding(int current_offset) const {
  330   current_offset += pre_call_resets_size();  // skip fldcw, if any
  331   current_offset += 1;      // skip call opcode byte
  332   return align_up(current_offset, alignment_required()) - current_offset;
  333 }
  334 
  335 // The address of the call instruction needs to be 4-byte aligned to
  336 // ensure that it does not span a cache line so that it can be patched.
  337 int CallDynamicJavaDirectNode::compute_padding(int current_offset) const {
  338   current_offset += pre_call_resets_size();  // skip fldcw, if any
  339   current_offset += 5;      // skip MOV instruction
  340   current_offset += 1;      // skip call opcode byte
  341   return align_up(current_offset, alignment_required()) - current_offset;
  342 }
</pre>
<hr />
<pre>
  506   //
  507   __ andl(Address(rsp, 0), 0xffffff2b);
  508   __ popf();
  509   __ bind(exit);
  510 }
  511 
  512 void emit_cmpfp3(MacroAssembler&amp; _masm, Register dst) {
  513   Label done;
  514   __ movl(dst, -1);
  515   __ jcc(Assembler::parity, done);
  516   __ jcc(Assembler::below, done);
  517   __ setb(Assembler::notEqual, dst);
  518   __ movzbl(dst, dst);
  519   __ bind(done);
  520 }
  521 
  522 
  523 //=============================================================================
  524 const RegMask&amp; MachConstantBaseNode::_out_RegMask = RegMask::Empty;
  525 
<span class="line-modified">  526 int Compile::ConstantTable::calculate_table_base_offset() const {</span>
  527   return 0;  // absolute addressing, no offset
  528 }
  529 
  530 bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
  531 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
  532   ShouldNotReachHere();
  533 }
  534 
  535 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
  536   // Empty encoding
  537 }
  538 
  539 uint MachConstantBaseNode::size(PhaseRegAlloc* ra_) const {
  540   return 0;
  541 }
  542 
  543 #ifndef PRODUCT
  544 void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  545   st-&gt;print(&quot;# MachConstantBaseNode (empty encoding)&quot;);
  546 }
  547 #endif
  548 
  549 
  550 //=============================================================================
  551 #ifndef PRODUCT
  552 void MachPrologNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  553   Compile* C = ra_-&gt;C;
  554 
<span class="line-modified">  555   int framesize = C-&gt;frame_size_in_bytes();</span>
<span class="line-modified">  556   int bangsize = C-&gt;bang_size_in_bytes();</span>
  557   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  558   // Remove wordSize for return addr which is already pushed.
  559   framesize -= wordSize;
  560 
<span class="line-modified">  561   if (C-&gt;need_stack_bang(bangsize)) {</span>
  562     framesize -= wordSize;
  563     st-&gt;print(&quot;# stack bang (%d bytes)&quot;, bangsize);
  564     st-&gt;print(&quot;\n\t&quot;);
  565     st-&gt;print(&quot;PUSH   EBP\t# Save EBP&quot;);
  566     if (PreserveFramePointer) {
  567       st-&gt;print(&quot;\n\t&quot;);
  568       st-&gt;print(&quot;MOV    EBP, ESP\t# Save the caller&#39;s SP into EBP&quot;);
  569     }
  570     if (framesize) {
  571       st-&gt;print(&quot;\n\t&quot;);
  572       st-&gt;print(&quot;SUB    ESP, #%d\t# Create frame&quot;,framesize);
  573     }
  574   } else {
  575     st-&gt;print(&quot;SUB    ESP, #%d\t# Create frame&quot;,framesize);
  576     st-&gt;print(&quot;\n\t&quot;);
  577     framesize -= wordSize;
  578     st-&gt;print(&quot;MOV    [ESP + #%d], EBP\t# Save EBP&quot;,framesize);
  579     if (PreserveFramePointer) {
  580       st-&gt;print(&quot;\n\t&quot;);
  581       st-&gt;print(&quot;MOV    EBP, ESP\t# Save the caller&#39;s SP into EBP&quot;);
</pre>
<hr />
<pre>
  599   if (UseSSE &gt;= 2 &amp;&amp; VerifyFPU) {
  600     st-&gt;print(&quot;\n\t&quot;);
  601     st-&gt;print(&quot;# verify FPU stack (must be clean on entry)&quot;);
  602   }
  603 
  604 #ifdef ASSERT
  605   if (VerifyStackAtCalls) {
  606     st-&gt;print(&quot;\n\t&quot;);
  607     st-&gt;print(&quot;# stack alignment check&quot;);
  608   }
  609 #endif
  610   st-&gt;cr();
  611 }
  612 #endif
  613 
  614 
  615 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  616   Compile* C = ra_-&gt;C;
  617   MacroAssembler _masm(&amp;cbuf);
  618 
<span class="line-modified">  619   int framesize = C-&gt;frame_size_in_bytes();</span>
<span class="line-modified">  620   int bangsize = C-&gt;bang_size_in_bytes();</span>
  621 
<span class="line-modified">  622   __ verified_entry(framesize, C-&gt;need_stack_bang(bangsize)?bangsize:0, C-&gt;in_24_bit_fp_mode(), C-&gt;stub_function() != NULL);</span>
  623 
<span class="line-modified">  624   C-&gt;set_frame_complete(cbuf.insts_size());</span>
  625 
  626   if (C-&gt;has_mach_constant_base_node()) {
  627     // NOTE: We set the table base offset here because users might be
  628     // emitted before MachConstantBaseNode.
<span class="line-modified">  629     Compile::ConstantTable&amp; constant_table = C-&gt;constant_table();</span>
  630     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
  631   }
  632 }
  633 
  634 uint MachPrologNode::size(PhaseRegAlloc *ra_) const {
  635   return MachNode::size(ra_); // too many variables; just compute it the hard way
  636 }
  637 
  638 int MachPrologNode::reloc() const {
  639   return 0; // a large enough number
  640 }
  641 
  642 //=============================================================================
  643 #ifndef PRODUCT
  644 void MachEpilogNode::format( PhaseRegAlloc *ra_, outputStream* st ) const {
  645   Compile *C = ra_-&gt;C;
<span class="line-modified">  646   int framesize = C-&gt;frame_size_in_bytes();</span>
  647   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  648   // Remove two words for return addr and rbp,
  649   framesize -= 2*wordSize;
  650 
  651   if (C-&gt;max_vector_size() &gt; 16) {
  652     st-&gt;print(&quot;VZEROUPPER&quot;);
  653     st-&gt;cr(); st-&gt;print(&quot;\t&quot;);
  654   }
  655   if (C-&gt;in_24_bit_fp_mode()) {
  656     st-&gt;print(&quot;FLDCW  standard control word&quot;);
  657     st-&gt;cr(); st-&gt;print(&quot;\t&quot;);
  658   }
  659   if (framesize) {
  660     st-&gt;print(&quot;ADD    ESP,%d\t# Destroy frame&quot;,framesize);
  661     st-&gt;cr(); st-&gt;print(&quot;\t&quot;);
  662   }
  663   st-&gt;print_cr(&quot;POPL   EBP&quot;); st-&gt;print(&quot;\t&quot;);
  664   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  665     st-&gt;print(&quot;TEST   PollPage,EAX\t! Poll Safepoint&quot;);
  666     st-&gt;cr(); st-&gt;print(&quot;\t&quot;);
  667   }
  668 }
  669 #endif
  670 
  671 void MachEpilogNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  672   Compile *C = ra_-&gt;C;
  673   MacroAssembler _masm(&amp;cbuf);
  674 
  675   if (C-&gt;max_vector_size() &gt; 16) {
  676     // Clear upper bits of YMM registers when current compiled code uses
  677     // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
  678     _masm.vzeroupper();
  679   }
  680   // If method set FPU control word, restore to standard control word
  681   if (C-&gt;in_24_bit_fp_mode()) {
  682     _masm.fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_std()));
  683   }
  684 
<span class="line-modified">  685   int framesize = C-&gt;frame_size_in_bytes();</span>
  686   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  687   // Remove two words for return addr and rbp,
  688   framesize -= 2*wordSize;
  689 
  690   // Note that VerifyStackAtCalls&#39; Majik cookie does not change the frame size popped here
  691 
  692   if (framesize &gt;= 128) {
  693     emit_opcode(cbuf, 0x81); // add  SP, #framesize
  694     emit_rm(cbuf, 0x3, 0x00, ESP_enc);
  695     emit_d32(cbuf, framesize);
  696   } else if (framesize) {
  697     emit_opcode(cbuf, 0x83); // add  SP, #framesize
  698     emit_rm(cbuf, 0x3, 0x00, ESP_enc);
  699     emit_d8(cbuf, framesize);
  700   }
  701 
  702   emit_opcode(cbuf, 0x58 | EBP_enc);
  703 
  704   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
  705     __ reserved_stack_check();
  706   }
  707 
  708   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
<span class="line-modified">  709     if (SafepointMechanism::uses_thread_local_poll()) {</span>
<span class="line-modified">  710       Register pollReg = as_Register(EBX_enc);</span>
<span class="line-modified">  711       MacroAssembler masm(&amp;cbuf);</span>
<span class="line-modified">  712       masm.get_thread(pollReg);</span>
<span class="line-modified">  713       masm.movl(pollReg, Address(pollReg, in_bytes(Thread::polling_page_offset())));</span>
<span class="line-modified">  714       masm.relocate(relocInfo::poll_return_type);</span>
<span class="line-removed">  715       masm.testl(rax, Address(pollReg, 0));</span>
<span class="line-removed">  716     } else {</span>
<span class="line-removed">  717       cbuf.relocate(cbuf.insts_end(), relocInfo::poll_return_type, 0);</span>
<span class="line-removed">  718       emit_opcode(cbuf,0x85);</span>
<span class="line-removed">  719       emit_rm(cbuf, 0x0, EAX_enc, 0x5); // EAX</span>
<span class="line-removed">  720       emit_d32(cbuf, (intptr_t)os::get_polling_page());</span>
<span class="line-removed">  721     }</span>
  722   }
  723 }
  724 
  725 uint MachEpilogNode::size(PhaseRegAlloc *ra_) const {
  726   return MachNode::size(ra_); // too many variables; just compute it
  727                               // the hard way
  728 }
  729 
  730 int MachEpilogNode::reloc() const {
  731   return 0; // a large enough number
  732 }
  733 
  734 const Pipeline * MachEpilogNode::pipeline() const {
  735   return MachNode::pipeline_class();
  736 }
  737 
<span class="line-removed">  738 int MachEpilogNode::safepoint_offset() const { return 0; }</span>
<span class="line-removed">  739 </span>
  740 //=============================================================================
  741 
  742 enum RC { rc_bad, rc_int, rc_float, rc_xmm, rc_stack };
  743 static enum RC rc_class( OptoReg::Name reg ) {
  744 
  745   if( !OptoReg::is_valid(reg)  ) return rc_bad;
  746   if (OptoReg::is_stack(reg)) return rc_stack;
  747 
  748   VMReg r = OptoReg::as_VMReg(reg);
  749   if (r-&gt;is_Register()) return rc_int;
  750   if (r-&gt;is_FloatRegister()) {
  751     assert(UseSSE &lt; 2, &quot;shouldn&#39;t be used in SSE2+ mode&quot;);
  752     return rc_float;
  753   }
  754   assert(r-&gt;is_XMMRegister(), &quot;must be&quot;);
  755   return rc_xmm;
  756 }
  757 
  758 static int impl_helper( CodeBuffer *cbuf, bool do_size, bool is_load, int offset, int reg,
  759                         int opcode, const char *op_str, int size, outputStream* st ) {
</pre>
<hr />
<pre>
 3131     store_to_stackslot( cbuf, 0x0DF, 0x07, $dst$$disp );
 3132   %}
 3133 
 3134   // Volatile Store Long.  Must be atomic, so move it into
 3135   // the FP TOS and then do a 64-bit FIST.  Has to probe the
 3136   // target address before the store (for null-ptr checks)
 3137   // so the memory operand is used twice in the encoding.
 3138   enc_class enc_storeL_volatile( memory mem, stackSlotL src ) %{
 3139     store_to_stackslot( cbuf, 0x0DF, 0x05, $src$$disp );
 3140     cbuf.set_insts_mark();            // Mark start of FIST in case $mem has an oop
 3141     emit_opcode(cbuf,0xDF);
 3142     int rm_byte_opcode = 0x07;
 3143     int base     = $mem$$base;
 3144     int index    = $mem$$index;
 3145     int scale    = $mem$$scale;
 3146     int displace = $mem$$disp;
 3147     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc(); // disp-as-oop when working with static globals
 3148     encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace, disp_reloc);
 3149   %}
 3150 
<span class="line-removed"> 3151   // Safepoint Poll.  This polls the safepoint page, and causes an</span>
<span class="line-removed"> 3152   // exception if it is not readable. Unfortunately, it kills the condition code</span>
<span class="line-removed"> 3153   // in the process</span>
<span class="line-removed"> 3154   // We current use TESTL [spp],EDI</span>
<span class="line-removed"> 3155   // A better choice might be TESTB [spp + pagesize() - CacheLineSize()],0</span>
<span class="line-removed"> 3156 </span>
<span class="line-removed"> 3157   enc_class Safepoint_Poll() %{</span>
<span class="line-removed"> 3158     cbuf.relocate(cbuf.insts_mark(), relocInfo::poll_type, 0);</span>
<span class="line-removed"> 3159     emit_opcode(cbuf,0x85);</span>
<span class="line-removed"> 3160     emit_rm (cbuf, 0x0, 0x7, 0x5);</span>
<span class="line-removed"> 3161     emit_d32(cbuf, (intptr_t)os::get_polling_page());</span>
<span class="line-removed"> 3162   %}</span>
 3163 %}
 3164 
 3165 
 3166 //----------FRAME--------------------------------------------------------------
 3167 // Definition of frame structure and management information.
 3168 //
 3169 //  S T A C K   L A Y O U T    Allocators stack-slot number
 3170 //                             |   (to get allocators register number
 3171 //  G  Owned by    |        |  v    add OptoReg::stack0())
 3172 //  r   CALLER     |        |
 3173 //  o     |        +--------+      pad to even-align allocators stack-slot
 3174 //  w     V        |  pad0  |        numbers; owned by CALLER
 3175 //  t   -----------+--------+----&gt; Matcher::_in_arg_limit, unaligned
 3176 //  h     ^        |   in   |  5
 3177 //        |        |  args  |  4   Holes in incoming args owned by SELF
 3178 //  |     |        |        |  3
 3179 //  |     |        +--------+
 3180 //  V     |        | old out|      Empty on Intel, window on Sparc
 3181 //        |    old |preserve|      Must be even aligned.
 3182 //        |     SP-+--------+----&gt; Matcher::_old_SP, even aligned
</pre>
<hr />
<pre>
 3379 %}
 3380 
 3381 // Valid scale values for addressing modes
 3382 operand immI2() %{
 3383   predicate(0 &lt;= n-&gt;get_int() &amp;&amp; (n-&gt;get_int() &lt;= 3));
 3384   match(ConI);
 3385 
 3386   format %{ %}
 3387   interface(CONST_INTER);
 3388 %}
 3389 
 3390 operand immI8() %{
 3391   predicate((-128 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt;= 127));
 3392   match(ConI);
 3393 
 3394   op_cost(5);
 3395   format %{ %}
 3396   interface(CONST_INTER);
 3397 %}
 3398 









 3399 operand immI16() %{
 3400   predicate((-32768 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt;= 32767));
 3401   match(ConI);
 3402 
 3403   op_cost(10);
 3404   format %{ %}
 3405   interface(CONST_INTER);
 3406 %}
 3407 
 3408 // Int Immediate non-negative
 3409 operand immU31()
 3410 %{
 3411   predicate(n-&gt;get_int() &gt;= 0);
 3412   match(ConI);
 3413 
 3414   op_cost(0);
 3415   format %{ %}
 3416   interface(CONST_INTER);
 3417 %}
 3418 
</pre>
<hr />
<pre>
13424                  $scr$$Register, noreg, noreg, _counters, NULL, NULL, NULL, false, false);
13425   %}
13426   ins_pipe(pipe_slow);
13427 %}
13428 
13429 instruct cmpFastUnlock(eFlagsReg cr, eRegP object, eAXRegP box, eRegP tmp ) %{
13430   match(Set cr (FastUnlock object box));
13431   effect(TEMP tmp, USE_KILL box);
13432   ins_cost(300);
13433   format %{ &quot;FASTUNLOCK $object,$box\t! kills $box,$tmp&quot; %}
13434   ins_encode %{
13435     __ fast_unlock($object$$Register, $box$$Register, $tmp$$Register, ra_-&gt;C-&gt;use_rtm());
13436   %}
13437   ins_pipe(pipe_slow);
13438 %}
13439 
13440 
13441 
13442 // ============================================================================
13443 // Safepoint Instruction
<span class="line-removed">13444 instruct safePoint_poll(eFlagsReg cr) %{</span>
<span class="line-removed">13445   predicate(SafepointMechanism::uses_global_page_poll());</span>
<span class="line-removed">13446   match(SafePoint);</span>
<span class="line-removed">13447   effect(KILL cr);</span>
<span class="line-removed">13448 </span>
<span class="line-removed">13449   // TODO-FIXME: we currently poll at offset 0 of the safepoint polling page.</span>
<span class="line-removed">13450   // On SPARC that might be acceptable as we can generate the address with</span>
<span class="line-removed">13451   // just a sethi, saving an or.  By polling at offset 0 we can end up</span>
<span class="line-removed">13452   // putting additional pressure on the index-0 in the D$.  Because of</span>
<span class="line-removed">13453   // alignment (just like the situation at hand) the lower indices tend</span>
<span class="line-removed">13454   // to see more traffic.  It&#39;d be better to change the polling address</span>
<span class="line-removed">13455   // to offset 0 of the last $line in the polling page.</span>
<span class="line-removed">13456 </span>
<span class="line-removed">13457   format %{ &quot;TSTL   #polladdr,EAX\t! Safepoint: poll for GC&quot; %}</span>
<span class="line-removed">13458   ins_cost(125);</span>
<span class="line-removed">13459   size(6) ;</span>
<span class="line-removed">13460   ins_encode( Safepoint_Poll() );</span>
<span class="line-removed">13461   ins_pipe( ialu_reg_mem );</span>
<span class="line-removed">13462 %}</span>
<span class="line-removed">13463 </span>
13464 instruct safePoint_poll_tls(eFlagsReg cr, eRegP_no_EBP poll) %{
<span class="line-removed">13465   predicate(SafepointMechanism::uses_thread_local_poll());</span>
13466   match(SafePoint poll);
13467   effect(KILL cr, USE poll);
13468 
13469   format %{ &quot;TSTL   #EAX,[$poll]\t! Safepoint: poll for GC&quot; %}
13470   ins_cost(125);
13471   // EBP would need size(3)
13472   size(2); /* setting an explicit size will cause debug builds to assert if size is incorrect */
13473   ins_encode %{
13474     __ relocate(relocInfo::poll_type);
13475     address pre_pc = __ pc();
13476     __ testl(rax, Address($poll$$Register, 0));
13477     address post_pc = __ pc();
13478     guarantee(pre_pc[0] == 0x85, &quot;must emit test-ax [reg]&quot;);
13479   %}
13480   ins_pipe(ialu_reg_mem);
13481 %}
13482 
13483 
13484 // ============================================================================
13485 // This name is KNOWN by the ADLC and cannot be changed.
</pre>
</td>
<td>
<hr />
<pre>
    1 //
<span class="line-modified">    2 // Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
    3 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    4 //
    5 // This code is free software; you can redistribute it and/or modify it
    6 // under the terms of the GNU General Public License version 2 only, as
    7 // published by the Free Software Foundation.
    8 //
    9 // This code is distributed in the hope that it will be useful, but WITHOUT
   10 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   11 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   12 // version 2 for more details (a copy is included in the LICENSE file that
   13 // accompanied this code).
   14 //
   15 // You should have received a copy of the GNU General Public License version
   16 // 2 along with this work; if not, write to the Free Software Foundation,
   17 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   18 //
   19 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   20 // or visit www.oracle.com if you need additional information or have any
   21 // questions.
   22 //
</pre>
<hr />
<pre>
  297 }
  298 
  299 // !!!!! Special hack to get all type of calls to specify the byte offset
  300 //       from the start of the call to the point where the return address
  301 //       will point.
  302 int MachCallStaticJavaNode::ret_addr_offset() {
  303   return 5 + pre_call_resets_size();  // 5 bytes from start of call to where return address points
  304 }
  305 
  306 int MachCallDynamicJavaNode::ret_addr_offset() {
  307   return 10 + pre_call_resets_size();  // 10 bytes from start of call to where return address points
  308 }
  309 
  310 static int sizeof_FFree_Float_Stack_All = -1;
  311 
  312 int MachCallRuntimeNode::ret_addr_offset() {
  313   assert(sizeof_FFree_Float_Stack_All != -1, &quot;must have been emitted already&quot;);
  314   return sizeof_FFree_Float_Stack_All + 5 + pre_call_resets_size();
  315 }
  316 






  317 //
  318 // Compute padding required for nodes which need alignment
  319 //
  320 
  321 // The address of the call instruction needs to be 4-byte aligned to
  322 // ensure that it does not span a cache line so that it can be patched.
  323 int CallStaticJavaDirectNode::compute_padding(int current_offset) const {
  324   current_offset += pre_call_resets_size();  // skip fldcw, if any
  325   current_offset += 1;      // skip call opcode byte
  326   return align_up(current_offset, alignment_required()) - current_offset;
  327 }
  328 
  329 // The address of the call instruction needs to be 4-byte aligned to
  330 // ensure that it does not span a cache line so that it can be patched.
  331 int CallDynamicJavaDirectNode::compute_padding(int current_offset) const {
  332   current_offset += pre_call_resets_size();  // skip fldcw, if any
  333   current_offset += 5;      // skip MOV instruction
  334   current_offset += 1;      // skip call opcode byte
  335   return align_up(current_offset, alignment_required()) - current_offset;
  336 }
</pre>
<hr />
<pre>
  500   //
  501   __ andl(Address(rsp, 0), 0xffffff2b);
  502   __ popf();
  503   __ bind(exit);
  504 }
  505 
  506 void emit_cmpfp3(MacroAssembler&amp; _masm, Register dst) {
  507   Label done;
  508   __ movl(dst, -1);
  509   __ jcc(Assembler::parity, done);
  510   __ jcc(Assembler::below, done);
  511   __ setb(Assembler::notEqual, dst);
  512   __ movzbl(dst, dst);
  513   __ bind(done);
  514 }
  515 
  516 
  517 //=============================================================================
  518 const RegMask&amp; MachConstantBaseNode::_out_RegMask = RegMask::Empty;
  519 
<span class="line-modified">  520 int ConstantTable::calculate_table_base_offset() const {</span>
  521   return 0;  // absolute addressing, no offset
  522 }
  523 
  524 bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
  525 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
  526   ShouldNotReachHere();
  527 }
  528 
  529 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
  530   // Empty encoding
  531 }
  532 
  533 uint MachConstantBaseNode::size(PhaseRegAlloc* ra_) const {
  534   return 0;
  535 }
  536 
  537 #ifndef PRODUCT
  538 void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  539   st-&gt;print(&quot;# MachConstantBaseNode (empty encoding)&quot;);
  540 }
  541 #endif
  542 
  543 
  544 //=============================================================================
  545 #ifndef PRODUCT
  546 void MachPrologNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  547   Compile* C = ra_-&gt;C;
  548 
<span class="line-modified">  549   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();</span>
<span class="line-modified">  550   int bangsize = C-&gt;output()-&gt;bang_size_in_bytes();</span>
  551   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  552   // Remove wordSize for return addr which is already pushed.
  553   framesize -= wordSize;
  554 
<span class="line-modified">  555   if (C-&gt;output()-&gt;need_stack_bang(bangsize)) {</span>
  556     framesize -= wordSize;
  557     st-&gt;print(&quot;# stack bang (%d bytes)&quot;, bangsize);
  558     st-&gt;print(&quot;\n\t&quot;);
  559     st-&gt;print(&quot;PUSH   EBP\t# Save EBP&quot;);
  560     if (PreserveFramePointer) {
  561       st-&gt;print(&quot;\n\t&quot;);
  562       st-&gt;print(&quot;MOV    EBP, ESP\t# Save the caller&#39;s SP into EBP&quot;);
  563     }
  564     if (framesize) {
  565       st-&gt;print(&quot;\n\t&quot;);
  566       st-&gt;print(&quot;SUB    ESP, #%d\t# Create frame&quot;,framesize);
  567     }
  568   } else {
  569     st-&gt;print(&quot;SUB    ESP, #%d\t# Create frame&quot;,framesize);
  570     st-&gt;print(&quot;\n\t&quot;);
  571     framesize -= wordSize;
  572     st-&gt;print(&quot;MOV    [ESP + #%d], EBP\t# Save EBP&quot;,framesize);
  573     if (PreserveFramePointer) {
  574       st-&gt;print(&quot;\n\t&quot;);
  575       st-&gt;print(&quot;MOV    EBP, ESP\t# Save the caller&#39;s SP into EBP&quot;);
</pre>
<hr />
<pre>
  593   if (UseSSE &gt;= 2 &amp;&amp; VerifyFPU) {
  594     st-&gt;print(&quot;\n\t&quot;);
  595     st-&gt;print(&quot;# verify FPU stack (must be clean on entry)&quot;);
  596   }
  597 
  598 #ifdef ASSERT
  599   if (VerifyStackAtCalls) {
  600     st-&gt;print(&quot;\n\t&quot;);
  601     st-&gt;print(&quot;# stack alignment check&quot;);
  602   }
  603 #endif
  604   st-&gt;cr();
  605 }
  606 #endif
  607 
  608 
  609 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  610   Compile* C = ra_-&gt;C;
  611   MacroAssembler _masm(&amp;cbuf);
  612 
<span class="line-modified">  613   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();</span>
<span class="line-modified">  614   int bangsize = C-&gt;output()-&gt;bang_size_in_bytes();</span>
  615 
<span class="line-modified">  616   __ verified_entry(framesize, C-&gt;output()-&gt;need_stack_bang(bangsize)?bangsize:0, C-&gt;in_24_bit_fp_mode(), C-&gt;stub_function() != NULL);</span>
  617 
<span class="line-modified">  618   C-&gt;output()-&gt;set_frame_complete(cbuf.insts_size());</span>
  619 
  620   if (C-&gt;has_mach_constant_base_node()) {
  621     // NOTE: We set the table base offset here because users might be
  622     // emitted before MachConstantBaseNode.
<span class="line-modified">  623     ConstantTable&amp; constant_table = C-&gt;output()-&gt;constant_table();</span>
  624     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
  625   }
  626 }
  627 
  628 uint MachPrologNode::size(PhaseRegAlloc *ra_) const {
  629   return MachNode::size(ra_); // too many variables; just compute it the hard way
  630 }
  631 
  632 int MachPrologNode::reloc() const {
  633   return 0; // a large enough number
  634 }
  635 
  636 //=============================================================================
  637 #ifndef PRODUCT
  638 void MachEpilogNode::format( PhaseRegAlloc *ra_, outputStream* st ) const {
  639   Compile *C = ra_-&gt;C;
<span class="line-modified">  640   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();</span>
  641   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  642   // Remove two words for return addr and rbp,
  643   framesize -= 2*wordSize;
  644 
  645   if (C-&gt;max_vector_size() &gt; 16) {
  646     st-&gt;print(&quot;VZEROUPPER&quot;);
  647     st-&gt;cr(); st-&gt;print(&quot;\t&quot;);
  648   }
  649   if (C-&gt;in_24_bit_fp_mode()) {
  650     st-&gt;print(&quot;FLDCW  standard control word&quot;);
  651     st-&gt;cr(); st-&gt;print(&quot;\t&quot;);
  652   }
  653   if (framesize) {
  654     st-&gt;print(&quot;ADD    ESP,%d\t# Destroy frame&quot;,framesize);
  655     st-&gt;cr(); st-&gt;print(&quot;\t&quot;);
  656   }
  657   st-&gt;print_cr(&quot;POPL   EBP&quot;); st-&gt;print(&quot;\t&quot;);
  658   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  659     st-&gt;print(&quot;TEST   PollPage,EAX\t! Poll Safepoint&quot;);
  660     st-&gt;cr(); st-&gt;print(&quot;\t&quot;);
  661   }
  662 }
  663 #endif
  664 
  665 void MachEpilogNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  666   Compile *C = ra_-&gt;C;
  667   MacroAssembler _masm(&amp;cbuf);
  668 
  669   if (C-&gt;max_vector_size() &gt; 16) {
  670     // Clear upper bits of YMM registers when current compiled code uses
  671     // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
  672     _masm.vzeroupper();
  673   }
  674   // If method set FPU control word, restore to standard control word
  675   if (C-&gt;in_24_bit_fp_mode()) {
  676     _masm.fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_std()));
  677   }
  678 
<span class="line-modified">  679   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();</span>
  680   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  681   // Remove two words for return addr and rbp,
  682   framesize -= 2*wordSize;
  683 
  684   // Note that VerifyStackAtCalls&#39; Majik cookie does not change the frame size popped here
  685 
  686   if (framesize &gt;= 128) {
  687     emit_opcode(cbuf, 0x81); // add  SP, #framesize
  688     emit_rm(cbuf, 0x3, 0x00, ESP_enc);
  689     emit_d32(cbuf, framesize);
  690   } else if (framesize) {
  691     emit_opcode(cbuf, 0x83); // add  SP, #framesize
  692     emit_rm(cbuf, 0x3, 0x00, ESP_enc);
  693     emit_d8(cbuf, framesize);
  694   }
  695 
  696   emit_opcode(cbuf, 0x58 | EBP_enc);
  697 
  698   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
  699     __ reserved_stack_check();
  700   }
  701 
  702   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
<span class="line-modified">  703     Register pollReg = as_Register(EBX_enc);</span>
<span class="line-modified">  704     MacroAssembler masm(&amp;cbuf);</span>
<span class="line-modified">  705     masm.get_thread(pollReg);</span>
<span class="line-modified">  706     masm.movl(pollReg, Address(pollReg, in_bytes(Thread::polling_page_offset())));</span>
<span class="line-modified">  707     masm.relocate(relocInfo::poll_return_type);</span>
<span class="line-modified">  708     masm.testl(rax, Address(pollReg, 0));</span>







  709   }
  710 }
  711 
  712 uint MachEpilogNode::size(PhaseRegAlloc *ra_) const {
  713   return MachNode::size(ra_); // too many variables; just compute it
  714                               // the hard way
  715 }
  716 
  717 int MachEpilogNode::reloc() const {
  718   return 0; // a large enough number
  719 }
  720 
  721 const Pipeline * MachEpilogNode::pipeline() const {
  722   return MachNode::pipeline_class();
  723 }
  724 


  725 //=============================================================================
  726 
  727 enum RC { rc_bad, rc_int, rc_float, rc_xmm, rc_stack };
  728 static enum RC rc_class( OptoReg::Name reg ) {
  729 
  730   if( !OptoReg::is_valid(reg)  ) return rc_bad;
  731   if (OptoReg::is_stack(reg)) return rc_stack;
  732 
  733   VMReg r = OptoReg::as_VMReg(reg);
  734   if (r-&gt;is_Register()) return rc_int;
  735   if (r-&gt;is_FloatRegister()) {
  736     assert(UseSSE &lt; 2, &quot;shouldn&#39;t be used in SSE2+ mode&quot;);
  737     return rc_float;
  738   }
  739   assert(r-&gt;is_XMMRegister(), &quot;must be&quot;);
  740   return rc_xmm;
  741 }
  742 
  743 static int impl_helper( CodeBuffer *cbuf, bool do_size, bool is_load, int offset, int reg,
  744                         int opcode, const char *op_str, int size, outputStream* st ) {
</pre>
<hr />
<pre>
 3116     store_to_stackslot( cbuf, 0x0DF, 0x07, $dst$$disp );
 3117   %}
 3118 
 3119   // Volatile Store Long.  Must be atomic, so move it into
 3120   // the FP TOS and then do a 64-bit FIST.  Has to probe the
 3121   // target address before the store (for null-ptr checks)
 3122   // so the memory operand is used twice in the encoding.
 3123   enc_class enc_storeL_volatile( memory mem, stackSlotL src ) %{
 3124     store_to_stackslot( cbuf, 0x0DF, 0x05, $src$$disp );
 3125     cbuf.set_insts_mark();            // Mark start of FIST in case $mem has an oop
 3126     emit_opcode(cbuf,0xDF);
 3127     int rm_byte_opcode = 0x07;
 3128     int base     = $mem$$base;
 3129     int index    = $mem$$index;
 3130     int scale    = $mem$$scale;
 3131     int displace = $mem$$disp;
 3132     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc(); // disp-as-oop when working with static globals
 3133     encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace, disp_reloc);
 3134   %}
 3135 












 3136 %}
 3137 
 3138 
 3139 //----------FRAME--------------------------------------------------------------
 3140 // Definition of frame structure and management information.
 3141 //
 3142 //  S T A C K   L A Y O U T    Allocators stack-slot number
 3143 //                             |   (to get allocators register number
 3144 //  G  Owned by    |        |  v    add OptoReg::stack0())
 3145 //  r   CALLER     |        |
 3146 //  o     |        +--------+      pad to even-align allocators stack-slot
 3147 //  w     V        |  pad0  |        numbers; owned by CALLER
 3148 //  t   -----------+--------+----&gt; Matcher::_in_arg_limit, unaligned
 3149 //  h     ^        |   in   |  5
 3150 //        |        |  args  |  4   Holes in incoming args owned by SELF
 3151 //  |     |        |        |  3
 3152 //  |     |        +--------+
 3153 //  V     |        | old out|      Empty on Intel, window on Sparc
 3154 //        |    old |preserve|      Must be even aligned.
 3155 //        |     SP-+--------+----&gt; Matcher::_old_SP, even aligned
</pre>
<hr />
<pre>
 3352 %}
 3353 
 3354 // Valid scale values for addressing modes
 3355 operand immI2() %{
 3356   predicate(0 &lt;= n-&gt;get_int() &amp;&amp; (n-&gt;get_int() &lt;= 3));
 3357   match(ConI);
 3358 
 3359   format %{ %}
 3360   interface(CONST_INTER);
 3361 %}
 3362 
 3363 operand immI8() %{
 3364   predicate((-128 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt;= 127));
 3365   match(ConI);
 3366 
 3367   op_cost(5);
 3368   format %{ %}
 3369   interface(CONST_INTER);
 3370 %}
 3371 
<span class="line-added"> 3372 operand immU8() %{</span>
<span class="line-added"> 3373   predicate((0 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt;= 255));</span>
<span class="line-added"> 3374   match(ConI);</span>
<span class="line-added"> 3375 </span>
<span class="line-added"> 3376   op_cost(5);</span>
<span class="line-added"> 3377   format %{ %}</span>
<span class="line-added"> 3378   interface(CONST_INTER);</span>
<span class="line-added"> 3379 %}</span>
<span class="line-added"> 3380 </span>
 3381 operand immI16() %{
 3382   predicate((-32768 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt;= 32767));
 3383   match(ConI);
 3384 
 3385   op_cost(10);
 3386   format %{ %}
 3387   interface(CONST_INTER);
 3388 %}
 3389 
 3390 // Int Immediate non-negative
 3391 operand immU31()
 3392 %{
 3393   predicate(n-&gt;get_int() &gt;= 0);
 3394   match(ConI);
 3395 
 3396   op_cost(0);
 3397   format %{ %}
 3398   interface(CONST_INTER);
 3399 %}
 3400 
</pre>
<hr />
<pre>
13406                  $scr$$Register, noreg, noreg, _counters, NULL, NULL, NULL, false, false);
13407   %}
13408   ins_pipe(pipe_slow);
13409 %}
13410 
13411 instruct cmpFastUnlock(eFlagsReg cr, eRegP object, eAXRegP box, eRegP tmp ) %{
13412   match(Set cr (FastUnlock object box));
13413   effect(TEMP tmp, USE_KILL box);
13414   ins_cost(300);
13415   format %{ &quot;FASTUNLOCK $object,$box\t! kills $box,$tmp&quot; %}
13416   ins_encode %{
13417     __ fast_unlock($object$$Register, $box$$Register, $tmp$$Register, ra_-&gt;C-&gt;use_rtm());
13418   %}
13419   ins_pipe(pipe_slow);
13420 %}
13421 
13422 
13423 
13424 // ============================================================================
13425 // Safepoint Instruction




















13426 instruct safePoint_poll_tls(eFlagsReg cr, eRegP_no_EBP poll) %{

13427   match(SafePoint poll);
13428   effect(KILL cr, USE poll);
13429 
13430   format %{ &quot;TSTL   #EAX,[$poll]\t! Safepoint: poll for GC&quot; %}
13431   ins_cost(125);
13432   // EBP would need size(3)
13433   size(2); /* setting an explicit size will cause debug builds to assert if size is incorrect */
13434   ins_encode %{
13435     __ relocate(relocInfo::poll_type);
13436     address pre_pc = __ pc();
13437     __ testl(rax, Address($poll$$Register, 0));
13438     address post_pc = __ pc();
13439     guarantee(pre_pc[0] == 0x85, &quot;must emit test-ax [reg]&quot;);
13440   %}
13441   ins_pipe(ialu_reg_mem);
13442 %}
13443 
13444 
13445 // ============================================================================
13446 // This name is KNOWN by the ADLC and cannot be changed.
</pre>
</td>
</tr>
</table>
<center><a href="x86.ad.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="x86_64.ad.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
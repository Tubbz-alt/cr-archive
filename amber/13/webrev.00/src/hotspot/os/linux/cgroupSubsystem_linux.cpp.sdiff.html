<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os/linux/cgroupSubsystem_linux.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../bsd/os_bsd.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="cgroupSubsystem_linux.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/linux/cgroupSubsystem_linux.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 22  *
 23  */
 24 
 25 #include &lt;string.h&gt;
 26 #include &lt;math.h&gt;
 27 #include &lt;errno.h&gt;
 28 #include &quot;cgroupSubsystem_linux.hpp&quot;
 29 #include &quot;cgroupV1Subsystem_linux.hpp&quot;
 30 #include &quot;cgroupV2Subsystem_linux.hpp&quot;
 31 #include &quot;logging/log.hpp&quot;
 32 #include &quot;memory/allocation.hpp&quot;
 33 #include &quot;runtime/globals.hpp&quot;
 34 #include &quot;runtime/os.hpp&quot;
 35 #include &quot;utilities/globalDefinitions.hpp&quot;
 36 
 37 CgroupSubsystem* CgroupSubsystemFactory::create() {
 38   CgroupV1MemoryController* memory = NULL;
 39   CgroupV1Controller* cpuset = NULL;
 40   CgroupV1Controller* cpu = NULL;
 41   CgroupV1Controller* cpuacct = NULL;













































































 42   FILE *mntinfo = NULL;
 43   FILE *cgroups = NULL;
 44   FILE *cgroup = NULL;
 45   char buf[MAXPATHLEN+1];
<span class="line-removed"> 46   char tmproot[MAXPATHLEN+1];</span>
<span class="line-removed"> 47   char tmpmount[MAXPATHLEN+1];</span>
 48   char *p;
 49   bool is_cgroupsV2;
 50   // true iff all controllers, memory, cpu, cpuset, cpuacct are enabled
 51   // at the kernel level.
 52   bool all_controllers_enabled;
 53 
<span class="line-removed"> 54   CgroupInfo cg_infos[CG_INFO_LENGTH];</span>
<span class="line-removed"> 55   int cpuset_idx  = 0;</span>
<span class="line-removed"> 56   int cpu_idx     = 1;</span>
<span class="line-removed"> 57   int cpuacct_idx = 2;</span>
<span class="line-removed"> 58   int memory_idx  = 3;</span>
<span class="line-removed"> 59 </span>
 60   /*
 61    * Read /proc/cgroups so as to be able to distinguish cgroups v2 vs cgroups v1.
 62    *
<span class="line-modified"> 63    * For cgroups v1 unified hierarchy, cpu, cpuacct, cpuset, memory controllers</span>
<span class="line-modified"> 64    * must have non-zero for the hierarchy ID field.</span>


 65    */
<span class="line-modified"> 66   cgroups = fopen(&quot;/proc/cgroups&quot;, &quot;r&quot;);</span>
 67   if (cgroups == NULL) {
<span class="line-modified"> 68       log_debug(os, container)(&quot;Can&#39;t open /proc/cgroups, %s&quot;,</span>
<span class="line-modified"> 69                                os::strerror(errno));</span>
<span class="line-modified"> 70       return NULL;</span>

 71   }
 72 
 73   while ((p = fgets(buf, MAXPATHLEN, cgroups)) != NULL) {
 74     char name[MAXPATHLEN+1];
 75     int  hierarchy_id;
 76     int  enabled;
 77 
 78     // Format of /proc/cgroups documented via man 7 cgroups
 79     if (sscanf(p, &quot;%s %d %*d %d&quot;, name, &amp;hierarchy_id, &amp;enabled) != 3) {
 80       continue;
 81     }
 82     if (strcmp(name, &quot;memory&quot;) == 0) {
<span class="line-modified"> 83       cg_infos[memory_idx]._name = os::strdup(name);</span>
<span class="line-modified"> 84       cg_infos[memory_idx]._hierarchy_id = hierarchy_id;</span>
<span class="line-modified"> 85       cg_infos[memory_idx]._enabled = (enabled == 1);</span>
 86     } else if (strcmp(name, &quot;cpuset&quot;) == 0) {
<span class="line-modified"> 87       cg_infos[cpuset_idx]._name = os::strdup(name);</span>
<span class="line-modified"> 88       cg_infos[cpuset_idx]._hierarchy_id = hierarchy_id;</span>
<span class="line-modified"> 89       cg_infos[cpuset_idx]._enabled = (enabled == 1);</span>
 90     } else if (strcmp(name, &quot;cpu&quot;) == 0) {
<span class="line-modified"> 91       cg_infos[cpu_idx]._name = os::strdup(name);</span>
<span class="line-modified"> 92       cg_infos[cpu_idx]._hierarchy_id = hierarchy_id;</span>
<span class="line-modified"> 93       cg_infos[cpu_idx]._enabled = (enabled == 1);</span>
 94     } else if (strcmp(name, &quot;cpuacct&quot;) == 0) {
<span class="line-modified"> 95       cg_infos[cpuacct_idx]._name = os::strdup(name);</span>
<span class="line-modified"> 96       cg_infos[cpuacct_idx]._hierarchy_id = hierarchy_id;</span>
<span class="line-modified"> 97       cg_infos[cpuacct_idx]._enabled = (enabled == 1);</span>
 98     }
 99   }
100   fclose(cgroups);
101 
102   is_cgroupsV2 = true;
103   all_controllers_enabled = true;
104   for (int i = 0; i &lt; CG_INFO_LENGTH; i++) {
105     is_cgroupsV2 = is_cgroupsV2 &amp;&amp; cg_infos[i]._hierarchy_id == 0;
106     all_controllers_enabled = all_controllers_enabled &amp;&amp; cg_infos[i]._enabled;
107   }
108 
109   if (!all_controllers_enabled) {
110     // one or more controllers disabled, disable container support
111     log_debug(os, container)(&quot;One or more required controllers disabled at kernel level.&quot;);
<span class="line-modified">112     return NULL;</span>


113   }
114 
115   /*
116    * Read /proc/self/cgroup and determine:
117    *  - the cgroup path for cgroups v2 or
118    *  - on a cgroups v1 system, collect info for mapping
119    *    the host mount point to the local one via /proc/self/mountinfo below.
120    */
<span class="line-modified">121   cgroup = fopen(&quot;/proc/self/cgroup&quot;, &quot;r&quot;);</span>
122   if (cgroup == NULL) {
<span class="line-modified">123     log_debug(os, container)(&quot;Can&#39;t open /proc/self/cgroup, %s&quot;,</span>
<span class="line-modified">124                              os::strerror(errno));</span>
<span class="line-modified">125     return NULL;</span>


126   }
127 
128   while ((p = fgets(buf, MAXPATHLEN, cgroup)) != NULL) {
129     char *controllers;
130     char *token;
131     char *hierarchy_id_str;
132     int  hierarchy_id;
133     char *cgroup_path;
134 
135     hierarchy_id_str = strsep(&amp;p, &quot;:&quot;);
136     hierarchy_id = atoi(hierarchy_id_str);
137     /* Get controllers and base */
138     controllers = strsep(&amp;p, &quot;:&quot;);
139     cgroup_path = strsep(&amp;p, &quot;\n&quot;);
140 
141     if (controllers == NULL) {
142       continue;
143     }
144 
145     while (!is_cgroupsV2 &amp;&amp; (token = strsep(&amp;controllers, &quot;,&quot;)) != NULL) {
146       if (strcmp(token, &quot;memory&quot;) == 0) {
<span class="line-modified">147         assert(hierarchy_id == cg_infos[memory_idx]._hierarchy_id, &quot;/proc/cgroups and /proc/self/cgroup hierarchy mismatch&quot;);</span>
<span class="line-modified">148         cg_infos[memory_idx]._cgroup_path = os::strdup(cgroup_path);</span>
149       } else if (strcmp(token, &quot;cpuset&quot;) == 0) {
<span class="line-modified">150         assert(hierarchy_id == cg_infos[cpuset_idx]._hierarchy_id, &quot;/proc/cgroups and /proc/self/cgroup hierarchy mismatch&quot;);</span>
<span class="line-modified">151         cg_infos[cpuset_idx]._cgroup_path = os::strdup(cgroup_path);</span>
152       } else if (strcmp(token, &quot;cpu&quot;) == 0) {
<span class="line-modified">153         assert(hierarchy_id == cg_infos[cpu_idx]._hierarchy_id, &quot;/proc/cgroups and /proc/self/cgroup hierarchy mismatch&quot;);</span>
<span class="line-modified">154         cg_infos[cpu_idx]._cgroup_path = os::strdup(cgroup_path);</span>
155       } else if (strcmp(token, &quot;cpuacct&quot;) == 0) {
<span class="line-modified">156         assert(hierarchy_id == cg_infos[cpuacct_idx]._hierarchy_id, &quot;/proc/cgroups and /proc/self/cgroup hierarchy mismatch&quot;);</span>
<span class="line-modified">157         cg_infos[cpuacct_idx]._cgroup_path = os::strdup(cgroup_path);</span>
158       }
159     }
160     if (is_cgroupsV2) {
161       for (int i = 0; i &lt; CG_INFO_LENGTH; i++) {
162         cg_infos[i]._cgroup_path = os::strdup(cgroup_path);
163       }
164     }
165   }
166   fclose(cgroup);
167 
<span class="line-modified">168   if (is_cgroupsV2) {</span>
<span class="line-modified">169     // Find the cgroup2 mount point by reading /proc/self/mountinfo</span>
<span class="line-modified">170     mntinfo = fopen(&quot;/proc/self/mountinfo&quot;, &quot;r&quot;);</span>
<span class="line-removed">171     if (mntinfo == NULL) {</span>
<span class="line-removed">172         log_debug(os, container)(&quot;Can&#39;t open /proc/self/mountinfo, %s&quot;,</span>
<span class="line-removed">173                                  os::strerror(errno));</span>
<span class="line-removed">174         return NULL;</span>
<span class="line-removed">175     }</span>
<span class="line-removed">176 </span>
<span class="line-removed">177     char cgroupv2_mount[MAXPATHLEN+1];</span>
<span class="line-removed">178     char fstype[MAXPATHLEN+1];</span>
<span class="line-removed">179     bool mount_point_found = false;</span>
<span class="line-removed">180     while ((p = fgets(buf, MAXPATHLEN, mntinfo)) != NULL) {</span>
<span class="line-removed">181       char *tmp_mount_point = cgroupv2_mount;</span>
<span class="line-removed">182       char *tmp_fs_type = fstype;</span>
<span class="line-removed">183 </span>
<span class="line-removed">184       // mountinfo format is documented at https://www.kernel.org/doc/Documentation/filesystems/proc.txt</span>
<span class="line-removed">185       if (sscanf(p, &quot;%*d %*d %*d:%*d %*s %s %*[^-]- %s cgroup2 %*s&quot;, tmp_mount_point, tmp_fs_type) == 2) {</span>
<span class="line-removed">186         // we likely have an early match return, be sure we have cgroup2 as fstype</span>
<span class="line-removed">187         if (strcmp(&quot;cgroup2&quot;, tmp_fs_type) == 0) {</span>
<span class="line-removed">188           mount_point_found = true;</span>
<span class="line-removed">189           break;</span>
<span class="line-removed">190         }</span>
<span class="line-removed">191       }</span>
<span class="line-removed">192     }</span>
<span class="line-removed">193     fclose(mntinfo);</span>
<span class="line-removed">194     if (!mount_point_found) {</span>
<span class="line-removed">195       log_trace(os, container)(&quot;Mount point for cgroupv2 not found in /proc/self/mountinfo&quot;);</span>
<span class="line-removed">196       return NULL;</span>
<span class="line-removed">197     }</span>
<span class="line-removed">198     // Cgroups v2 case, we have all the info we need.</span>
<span class="line-removed">199     // Construct the subsystem, free resources and return</span>
<span class="line-removed">200     // Note: any index in cg_infos will do as the path is the same for</span>
<span class="line-removed">201     //       all controllers.</span>
<span class="line-removed">202     CgroupController* unified = new CgroupV2Controller(cgroupv2_mount, cg_infos[memory_idx]._cgroup_path);</span>
<span class="line-removed">203     for (int i = 0; i &lt; CG_INFO_LENGTH; i++) {</span>
<span class="line-removed">204       os::free(cg_infos[i]._name);</span>
<span class="line-removed">205       os::free(cg_infos[i]._cgroup_path);</span>
<span class="line-removed">206     }</span>
<span class="line-removed">207     log_debug(os, container)(&quot;Detected cgroups v2 unified hierarchy&quot;);</span>
<span class="line-removed">208     return new CgroupV2Subsystem(unified);</span>
<span class="line-removed">209   }</span>
<span class="line-removed">210 </span>
<span class="line-removed">211   // What follows is cgroups v1</span>
<span class="line-removed">212   log_debug(os, container)(&quot;Detected cgroups hybrid or legacy hierarchy, using cgroups v1 controllers&quot;);</span>
<span class="line-removed">213 </span>
<span class="line-removed">214   /*</span>
<span class="line-removed">215    * Find the cgroup mount point for memory and cpuset</span>
<span class="line-removed">216    * by reading /proc/self/mountinfo</span>
<span class="line-removed">217    *</span>
<span class="line-removed">218    * Example for docker:</span>
<span class="line-removed">219    * 219 214 0:29 /docker/7208cebd00fa5f2e342b1094f7bed87fa25661471a4637118e65f1c995be8a34 /sys/fs/cgroup/memory ro,nosuid,nodev,noexec,relatime - cgroup cgroup rw,memory</span>
<span class="line-removed">220    *</span>
<span class="line-removed">221    * Example for host:</span>
<span class="line-removed">222    * 34 28 0:29 / /sys/fs/cgroup/memory rw,nosuid,nodev,noexec,relatime shared:16 - cgroup cgroup rw,memory</span>
<span class="line-removed">223    */</span>
<span class="line-removed">224   mntinfo = fopen(&quot;/proc/self/mountinfo&quot;, &quot;r&quot;);</span>
225   if (mntinfo == NULL) {
<span class="line-modified">226       log_debug(os, container)(&quot;Can&#39;t open /proc/self/mountinfo, %s&quot;,</span>
<span class="line-modified">227                                os::strerror(errno));</span>
<span class="line-modified">228       return NULL;</span>


229   }
230 


231   while ((p = fgets(buf, MAXPATHLEN, mntinfo)) != NULL) {




232     char tmpcgroups[MAXPATHLEN+1];
233     char *cptr = tmpcgroups;
234     char *token;
235 
<span class="line-modified">236     // mountinfo format is documented at https://www.kernel.org/doc/Documentation/filesystems/proc.txt</span>
<span class="line-modified">237     if (sscanf(p, &quot;%*d %*d %*d:%*d %s %s %*[^-]- cgroup %*s %s&quot;, tmproot, tmpmount, tmpcgroups) != 3) {</span>
<span class="line-modified">238       continue;</span>











239     }
<span class="line-modified">240     while ((token = strsep(&amp;cptr, &quot;,&quot;)) != NULL) {</span>
<span class="line-modified">241       if (strcmp(token, &quot;memory&quot;) == 0) {</span>
<span class="line-modified">242         memory = new CgroupV1MemoryController(tmproot, tmpmount);</span>
<span class="line-modified">243       } else if (strcmp(token, &quot;cpuset&quot;) == 0) {</span>
<span class="line-modified">244         cpuset = new CgroupV1Controller(tmproot, tmpmount);</span>
<span class="line-modified">245       } else if (strcmp(token, &quot;cpu&quot;) == 0) {</span>
<span class="line-modified">246         cpu = new CgroupV1Controller(tmproot, tmpmount);</span>
<span class="line-modified">247       } else if (strcmp(token, &quot;cpuacct&quot;) == 0) {</span>
<span class="line-modified">248         cpuacct= new CgroupV1Controller(tmproot, tmpmount);</span>






























249       }
250     }
251   }
<span class="line-removed">252 </span>
253   fclose(mntinfo);
254 
<span class="line-modified">255   if (memory == NULL) {</span>
























256     log_debug(os, container)(&quot;Required cgroup v1 memory subsystem not found&quot;);
<span class="line-modified">257     return NULL;</span>


258   }
<span class="line-modified">259   if (cpuset == NULL) {</span>
260     log_debug(os, container)(&quot;Required cgroup v1 cpuset subsystem not found&quot;);
<span class="line-modified">261     return NULL;</span>


262   }
<span class="line-modified">263   if (cpu == NULL) {</span>
264     log_debug(os, container)(&quot;Required cgroup v1 cpu subsystem not found&quot;);
<span class="line-modified">265     return NULL;</span>


266   }
<span class="line-modified">267   if (cpuacct == NULL) {</span>
268     log_debug(os, container)(&quot;Required cgroup v1 cpuacct subsystem not found&quot;);
<span class="line-modified">269     return NULL;</span>


270   }



271 
<span class="line-modified">272   /*</span>
<span class="line-modified">273    * Use info gathered previously from /proc/self/cgroup</span>
<span class="line-modified">274    * and map host mount point to</span>
<span class="line-modified">275    * local one via /proc/self/mountinfo content above</span>
<span class="line-removed">276    *</span>
<span class="line-removed">277    * Docker example:</span>
<span class="line-removed">278    * 5:memory:/docker/6558aed8fc662b194323ceab5b964f69cf36b3e8af877a14b80256e93aecb044</span>
<span class="line-removed">279    *</span>
<span class="line-removed">280    * Host example:</span>
<span class="line-removed">281    * 5:memory:/user.slice</span>
<span class="line-removed">282    *</span>
<span class="line-removed">283    * Construct a path to the process specific memory and cpuset</span>
<span class="line-removed">284    * cgroup directory.</span>
<span class="line-removed">285    *</span>
<span class="line-removed">286    * For a container running under Docker from memory example above</span>
<span class="line-removed">287    * the paths would be:</span>
<span class="line-removed">288    *</span>
<span class="line-removed">289    * /sys/fs/cgroup/memory</span>
<span class="line-removed">290    *</span>
<span class="line-removed">291    * For a Host from memory example above the path would be:</span>
<span class="line-removed">292    *</span>
<span class="line-removed">293    * /sys/fs/cgroup/memory/user.slice</span>
<span class="line-removed">294    *</span>
<span class="line-removed">295    */</span>
296   for (int i = 0; i &lt; CG_INFO_LENGTH; i++) {
<span class="line-modified">297     CgroupInfo info = cg_infos[i];</span>
<span class="line-modified">298     if (strcmp(info._name, &quot;memory&quot;) == 0) {</span>
<span class="line-modified">299       memory-&gt;set_subsystem_path(info._cgroup_path);</span>
<span class="line-modified">300     } else if (strcmp(info._name, &quot;cpuset&quot;) == 0) {</span>
<span class="line-removed">301       cpuset-&gt;set_subsystem_path(info._cgroup_path);</span>
<span class="line-removed">302     } else if (strcmp(info._name, &quot;cpu&quot;) == 0) {</span>
<span class="line-removed">303       cpu-&gt;set_subsystem_path(info._cgroup_path);</span>
<span class="line-removed">304     } else if (strcmp(info._name, &quot;cpuacct&quot;) == 0) {</span>
<span class="line-removed">305       cpuacct-&gt;set_subsystem_path(info._cgroup_path);</span>
<span class="line-removed">306     }</span>
307   }
<span class="line-removed">308   return new CgroupV1Subsystem(cpuset, cpu, cpuacct, memory);</span>
309 }
310 
311 /* active_processor_count
312  *
313  * Calculate an appropriate number of active processors for the
314  * VM to use based on these three inputs.
315  *
316  * cpu affinity
317  * cgroup cpu quota &amp; cpu period
318  * cgroup cpu shares
319  *
320  * Algorithm:
321  *
322  * Determine the number of available CPUs from sched_getaffinity
323  *
324  * If user specified a quota (quota != -1), calculate the number of
325  * required CPUs by dividing quota by period.
326  *
327  * If shares are in effect (shares != -1), calculate the number
328  * of CPUs required for the shares by dividing the share value
</pre>
</td>
<td>
<hr />
<pre>
 22  *
 23  */
 24 
 25 #include &lt;string.h&gt;
 26 #include &lt;math.h&gt;
 27 #include &lt;errno.h&gt;
 28 #include &quot;cgroupSubsystem_linux.hpp&quot;
 29 #include &quot;cgroupV1Subsystem_linux.hpp&quot;
 30 #include &quot;cgroupV2Subsystem_linux.hpp&quot;
 31 #include &quot;logging/log.hpp&quot;
 32 #include &quot;memory/allocation.hpp&quot;
 33 #include &quot;runtime/globals.hpp&quot;
 34 #include &quot;runtime/os.hpp&quot;
 35 #include &quot;utilities/globalDefinitions.hpp&quot;
 36 
 37 CgroupSubsystem* CgroupSubsystemFactory::create() {
 38   CgroupV1MemoryController* memory = NULL;
 39   CgroupV1Controller* cpuset = NULL;
 40   CgroupV1Controller* cpu = NULL;
 41   CgroupV1Controller* cpuacct = NULL;
<span class="line-added"> 42   CgroupInfo cg_infos[CG_INFO_LENGTH];</span>
<span class="line-added"> 43   u1 cg_type_flags = INVALID_CGROUPS_GENERIC;</span>
<span class="line-added"> 44   const char* proc_cgroups = &quot;/proc/cgroups&quot;;</span>
<span class="line-added"> 45   const char* proc_self_cgroup = &quot;/proc/self/cgroup&quot;;</span>
<span class="line-added"> 46   const char* proc_self_mountinfo = &quot;/proc/self/mountinfo&quot;;</span>
<span class="line-added"> 47 </span>
<span class="line-added"> 48   bool valid_cgroup = determine_type(cg_infos, proc_cgroups, proc_self_cgroup, proc_self_mountinfo, &amp;cg_type_flags);</span>
<span class="line-added"> 49 </span>
<span class="line-added"> 50   if (!valid_cgroup) {</span>
<span class="line-added"> 51     // Could not detect cgroup type</span>
<span class="line-added"> 52     return NULL;</span>
<span class="line-added"> 53   }</span>
<span class="line-added"> 54   assert(is_valid_cgroup(&amp;cg_type_flags), &quot;Expected valid cgroup type&quot;);</span>
<span class="line-added"> 55 </span>
<span class="line-added"> 56   if (is_cgroup_v2(&amp;cg_type_flags)) {</span>
<span class="line-added"> 57     // Cgroups v2 case, we have all the info we need.</span>
<span class="line-added"> 58     // Construct the subsystem, free resources and return</span>
<span class="line-added"> 59     // Note: any index in cg_infos will do as the path is the same for</span>
<span class="line-added"> 60     //       all controllers.</span>
<span class="line-added"> 61     CgroupController* unified = new CgroupV2Controller(cg_infos[MEMORY_IDX]._mount_path, cg_infos[MEMORY_IDX]._cgroup_path);</span>
<span class="line-added"> 62     log_debug(os, container)(&quot;Detected cgroups v2 unified hierarchy&quot;);</span>
<span class="line-added"> 63     cleanup(cg_infos);</span>
<span class="line-added"> 64     return new CgroupV2Subsystem(unified);</span>
<span class="line-added"> 65   }</span>
<span class="line-added"> 66 </span>
<span class="line-added"> 67   /*</span>
<span class="line-added"> 68    * Cgroup v1 case:</span>
<span class="line-added"> 69    *</span>
<span class="line-added"> 70    * Use info gathered previously from /proc/self/cgroup</span>
<span class="line-added"> 71    * and map host mount point to</span>
<span class="line-added"> 72    * local one via /proc/self/mountinfo content above</span>
<span class="line-added"> 73    *</span>
<span class="line-added"> 74    * Docker example:</span>
<span class="line-added"> 75    * 5:memory:/docker/6558aed8fc662b194323ceab5b964f69cf36b3e8af877a14b80256e93aecb044</span>
<span class="line-added"> 76    *</span>
<span class="line-added"> 77    * Host example:</span>
<span class="line-added"> 78    * 5:memory:/user.slice</span>
<span class="line-added"> 79    *</span>
<span class="line-added"> 80    * Construct a path to the process specific memory and cpuset</span>
<span class="line-added"> 81    * cgroup directory.</span>
<span class="line-added"> 82    *</span>
<span class="line-added"> 83    * For a container running under Docker from memory example above</span>
<span class="line-added"> 84    * the paths would be:</span>
<span class="line-added"> 85    *</span>
<span class="line-added"> 86    * /sys/fs/cgroup/memory</span>
<span class="line-added"> 87    *</span>
<span class="line-added"> 88    * For a Host from memory example above the path would be:</span>
<span class="line-added"> 89    *</span>
<span class="line-added"> 90    * /sys/fs/cgroup/memory/user.slice</span>
<span class="line-added"> 91    *</span>
<span class="line-added"> 92    */</span>
<span class="line-added"> 93   assert(is_cgroup_v1(&amp;cg_type_flags), &quot;Cgroup v1 expected&quot;);</span>
<span class="line-added"> 94   for (int i = 0; i &lt; CG_INFO_LENGTH; i++) {</span>
<span class="line-added"> 95     CgroupInfo info = cg_infos[i];</span>
<span class="line-added"> 96     if (strcmp(info._name, &quot;memory&quot;) == 0) {</span>
<span class="line-added"> 97       memory = new CgroupV1MemoryController(info._root_mount_path, info._mount_path);</span>
<span class="line-added"> 98       memory-&gt;set_subsystem_path(info._cgroup_path);</span>
<span class="line-added"> 99     } else if (strcmp(info._name, &quot;cpuset&quot;) == 0) {</span>
<span class="line-added">100       cpuset = new CgroupV1Controller(info._root_mount_path, info._mount_path);</span>
<span class="line-added">101       cpuset-&gt;set_subsystem_path(info._cgroup_path);</span>
<span class="line-added">102     } else if (strcmp(info._name, &quot;cpu&quot;) == 0) {</span>
<span class="line-added">103       cpu = new CgroupV1Controller(info._root_mount_path, info._mount_path);</span>
<span class="line-added">104       cpu-&gt;set_subsystem_path(info._cgroup_path);</span>
<span class="line-added">105     } else if (strcmp(info._name, &quot;cpuacct&quot;) == 0) {</span>
<span class="line-added">106       cpuacct = new CgroupV1Controller(info._root_mount_path, info._mount_path);</span>
<span class="line-added">107       cpuacct-&gt;set_subsystem_path(info._cgroup_path);</span>
<span class="line-added">108     }</span>
<span class="line-added">109   }</span>
<span class="line-added">110   cleanup(cg_infos);</span>
<span class="line-added">111   return new CgroupV1Subsystem(cpuset, cpu, cpuacct, memory);</span>
<span class="line-added">112 }</span>
<span class="line-added">113 </span>
<span class="line-added">114 bool CgroupSubsystemFactory::determine_type(CgroupInfo* cg_infos,</span>
<span class="line-added">115                                             const char* proc_cgroups,</span>
<span class="line-added">116                                             const char* proc_self_cgroup,</span>
<span class="line-added">117                                             const char* proc_self_mountinfo,</span>
<span class="line-added">118                                             u1* flags) {</span>
119   FILE *mntinfo = NULL;
120   FILE *cgroups = NULL;
121   FILE *cgroup = NULL;
122   char buf[MAXPATHLEN+1];


123   char *p;
124   bool is_cgroupsV2;
125   // true iff all controllers, memory, cpu, cpuset, cpuacct are enabled
126   // at the kernel level.
127   bool all_controllers_enabled;
128 






129   /*
130    * Read /proc/cgroups so as to be able to distinguish cgroups v2 vs cgroups v1.
131    *
<span class="line-modified">132    * For cgroups v1 hierarchy (hybrid or legacy), cpu, cpuacct, cpuset, memory controllers</span>
<span class="line-modified">133    * must have non-zero for the hierarchy ID field and relevant controllers mounted.</span>
<span class="line-added">134    * Conversely, for cgroups v2 (unified hierarchy), cpu, cpuacct, cpuset, memory</span>
<span class="line-added">135    * controllers must have hierarchy ID 0 and the unified controller mounted.</span>
136    */
<span class="line-modified">137   cgroups = fopen(proc_cgroups, &quot;r&quot;);</span>
138   if (cgroups == NULL) {
<span class="line-modified">139       log_debug(os, container)(&quot;Can&#39;t open %s, %s&quot;,</span>
<span class="line-modified">140                                proc_cgroups, os::strerror(errno));</span>
<span class="line-modified">141       *flags = INVALID_CGROUPS_GENERIC;</span>
<span class="line-added">142       return false;</span>
143   }
144 
145   while ((p = fgets(buf, MAXPATHLEN, cgroups)) != NULL) {
146     char name[MAXPATHLEN+1];
147     int  hierarchy_id;
148     int  enabled;
149 
150     // Format of /proc/cgroups documented via man 7 cgroups
151     if (sscanf(p, &quot;%s %d %*d %d&quot;, name, &amp;hierarchy_id, &amp;enabled) != 3) {
152       continue;
153     }
154     if (strcmp(name, &quot;memory&quot;) == 0) {
<span class="line-modified">155       cg_infos[MEMORY_IDX]._name = os::strdup(name);</span>
<span class="line-modified">156       cg_infos[MEMORY_IDX]._hierarchy_id = hierarchy_id;</span>
<span class="line-modified">157       cg_infos[MEMORY_IDX]._enabled = (enabled == 1);</span>
158     } else if (strcmp(name, &quot;cpuset&quot;) == 0) {
<span class="line-modified">159       cg_infos[CPUSET_IDX]._name = os::strdup(name);</span>
<span class="line-modified">160       cg_infos[CPUSET_IDX]._hierarchy_id = hierarchy_id;</span>
<span class="line-modified">161       cg_infos[CPUSET_IDX]._enabled = (enabled == 1);</span>
162     } else if (strcmp(name, &quot;cpu&quot;) == 0) {
<span class="line-modified">163       cg_infos[CPU_IDX]._name = os::strdup(name);</span>
<span class="line-modified">164       cg_infos[CPU_IDX]._hierarchy_id = hierarchy_id;</span>
<span class="line-modified">165       cg_infos[CPU_IDX]._enabled = (enabled == 1);</span>
166     } else if (strcmp(name, &quot;cpuacct&quot;) == 0) {
<span class="line-modified">167       cg_infos[CPUACCT_IDX]._name = os::strdup(name);</span>
<span class="line-modified">168       cg_infos[CPUACCT_IDX]._hierarchy_id = hierarchy_id;</span>
<span class="line-modified">169       cg_infos[CPUACCT_IDX]._enabled = (enabled == 1);</span>
170     }
171   }
172   fclose(cgroups);
173 
174   is_cgroupsV2 = true;
175   all_controllers_enabled = true;
176   for (int i = 0; i &lt; CG_INFO_LENGTH; i++) {
177     is_cgroupsV2 = is_cgroupsV2 &amp;&amp; cg_infos[i]._hierarchy_id == 0;
178     all_controllers_enabled = all_controllers_enabled &amp;&amp; cg_infos[i]._enabled;
179   }
180 
181   if (!all_controllers_enabled) {
182     // one or more controllers disabled, disable container support
183     log_debug(os, container)(&quot;One or more required controllers disabled at kernel level.&quot;);
<span class="line-modified">184     cleanup(cg_infos);</span>
<span class="line-added">185     *flags = INVALID_CGROUPS_GENERIC;</span>
<span class="line-added">186     return false;</span>
187   }
188 
189   /*
190    * Read /proc/self/cgroup and determine:
191    *  - the cgroup path for cgroups v2 or
192    *  - on a cgroups v1 system, collect info for mapping
193    *    the host mount point to the local one via /proc/self/mountinfo below.
194    */
<span class="line-modified">195   cgroup = fopen(proc_self_cgroup, &quot;r&quot;);</span>
196   if (cgroup == NULL) {
<span class="line-modified">197     log_debug(os, container)(&quot;Can&#39;t open %s, %s&quot;,</span>
<span class="line-modified">198                              proc_self_cgroup, os::strerror(errno));</span>
<span class="line-modified">199     cleanup(cg_infos);</span>
<span class="line-added">200     *flags = INVALID_CGROUPS_GENERIC;</span>
<span class="line-added">201     return false;</span>
202   }
203 
204   while ((p = fgets(buf, MAXPATHLEN, cgroup)) != NULL) {
205     char *controllers;
206     char *token;
207     char *hierarchy_id_str;
208     int  hierarchy_id;
209     char *cgroup_path;
210 
211     hierarchy_id_str = strsep(&amp;p, &quot;:&quot;);
212     hierarchy_id = atoi(hierarchy_id_str);
213     /* Get controllers and base */
214     controllers = strsep(&amp;p, &quot;:&quot;);
215     cgroup_path = strsep(&amp;p, &quot;\n&quot;);
216 
217     if (controllers == NULL) {
218       continue;
219     }
220 
221     while (!is_cgroupsV2 &amp;&amp; (token = strsep(&amp;controllers, &quot;,&quot;)) != NULL) {
222       if (strcmp(token, &quot;memory&quot;) == 0) {
<span class="line-modified">223         assert(hierarchy_id == cg_infos[MEMORY_IDX]._hierarchy_id, &quot;/proc/cgroups and /proc/self/cgroup hierarchy mismatch&quot;);</span>
<span class="line-modified">224         cg_infos[MEMORY_IDX]._cgroup_path = os::strdup(cgroup_path);</span>
225       } else if (strcmp(token, &quot;cpuset&quot;) == 0) {
<span class="line-modified">226         assert(hierarchy_id == cg_infos[CPUSET_IDX]._hierarchy_id, &quot;/proc/cgroups and /proc/self/cgroup hierarchy mismatch&quot;);</span>
<span class="line-modified">227         cg_infos[CPUSET_IDX]._cgroup_path = os::strdup(cgroup_path);</span>
228       } else if (strcmp(token, &quot;cpu&quot;) == 0) {
<span class="line-modified">229         assert(hierarchy_id == cg_infos[CPU_IDX]._hierarchy_id, &quot;/proc/cgroups and /proc/self/cgroup hierarchy mismatch&quot;);</span>
<span class="line-modified">230         cg_infos[CPU_IDX]._cgroup_path = os::strdup(cgroup_path);</span>
231       } else if (strcmp(token, &quot;cpuacct&quot;) == 0) {
<span class="line-modified">232         assert(hierarchy_id == cg_infos[CPUACCT_IDX]._hierarchy_id, &quot;/proc/cgroups and /proc/self/cgroup hierarchy mismatch&quot;);</span>
<span class="line-modified">233         cg_infos[CPUACCT_IDX]._cgroup_path = os::strdup(cgroup_path);</span>
234       }
235     }
236     if (is_cgroupsV2) {
237       for (int i = 0; i &lt; CG_INFO_LENGTH; i++) {
238         cg_infos[i]._cgroup_path = os::strdup(cgroup_path);
239       }
240     }
241   }
242   fclose(cgroup);
243 
<span class="line-modified">244   // Find various mount points by reading /proc/self/mountinfo</span>
<span class="line-modified">245   // mountinfo format is documented at https://www.kernel.org/doc/Documentation/filesystems/proc.txt</span>
<span class="line-modified">246   mntinfo = fopen(proc_self_mountinfo, &quot;r&quot;);</span>






















































247   if (mntinfo == NULL) {
<span class="line-modified">248       log_debug(os, container)(&quot;Can&#39;t open %s, %s&quot;,</span>
<span class="line-modified">249                                proc_self_mountinfo, os::strerror(errno));</span>
<span class="line-modified">250       cleanup(cg_infos);</span>
<span class="line-added">251       *flags = INVALID_CGROUPS_GENERIC;</span>
<span class="line-added">252       return false;</span>
253   }
254 
<span class="line-added">255   bool cgroupv2_mount_point_found = false;</span>
<span class="line-added">256   bool any_cgroup_mounts_found = false;</span>
257   while ((p = fgets(buf, MAXPATHLEN, mntinfo)) != NULL) {
<span class="line-added">258     char tmp_mount_point[MAXPATHLEN+1];</span>
<span class="line-added">259     char tmp_fs_type[MAXPATHLEN+1];</span>
<span class="line-added">260     char tmproot[MAXPATHLEN+1];</span>
<span class="line-added">261     char tmpmount[MAXPATHLEN+1];</span>
262     char tmpcgroups[MAXPATHLEN+1];
263     char *cptr = tmpcgroups;
264     char *token;
265 
<span class="line-modified">266     // Cgroup v2 relevant info. We only look for the _mount_path iff is_cgroupsV2 so</span>
<span class="line-modified">267     // as to avoid memory stomping of the _mount_path pointer later on in the cgroup v1</span>
<span class="line-modified">268     // block in the hybrid case.</span>
<span class="line-added">269     //</span>
<span class="line-added">270     if (is_cgroupsV2 &amp;&amp; sscanf(p, &quot;%*d %*d %*d:%*d %*s %s %*[^-]- %s cgroup2 %*s&quot;, tmp_mount_point, tmp_fs_type) == 2) {</span>
<span class="line-added">271       // we likely have an early match return (e.g. cgroup fs match), be sure we have cgroup2 as fstype</span>
<span class="line-added">272       if (!cgroupv2_mount_point_found &amp;&amp; strcmp(&quot;cgroup2&quot;, tmp_fs_type) == 0) {</span>
<span class="line-added">273         cgroupv2_mount_point_found = true;</span>
<span class="line-added">274         any_cgroup_mounts_found = true;</span>
<span class="line-added">275         for (int i = 0; i &lt; CG_INFO_LENGTH; i++) {</span>
<span class="line-added">276           assert(cg_infos[i]._mount_path == NULL, &quot;_mount_path memory stomping&quot;);</span>
<span class="line-added">277           cg_infos[i]._mount_path = os::strdup(tmp_mount_point);</span>
<span class="line-added">278         }</span>
<span class="line-added">279       }</span>
280     }
<span class="line-modified">281 </span>
<span class="line-modified">282     /* Cgroup v1 relevant info</span>
<span class="line-modified">283      *</span>
<span class="line-modified">284      * Find the cgroup mount point for memory, cpuset, cpu, cpuacct</span>
<span class="line-modified">285      *</span>
<span class="line-modified">286      * Example for docker:</span>
<span class="line-modified">287      * 219 214 0:29 /docker/7208cebd00fa5f2e342b1094f7bed87fa25661471a4637118e65f1c995be8a34 /sys/fs/cgroup/memory ro,nosuid,nodev,noexec,relatime - cgroup cgroup rw,memory</span>
<span class="line-modified">288      *</span>
<span class="line-modified">289      * Example for host:</span>
<span class="line-added">290      * 34 28 0:29 / /sys/fs/cgroup/memory rw,nosuid,nodev,noexec,relatime shared:16 - cgroup cgroup rw,memory</span>
<span class="line-added">291      */</span>
<span class="line-added">292     if (sscanf(p, &quot;%*d %*d %*d:%*d %s %s %*[^-]- %s cgroup %s&quot;, tmproot, tmpmount, tmp_fs_type, tmpcgroups) == 4) {</span>
<span class="line-added">293       if (strcmp(&quot;cgroup&quot;, tmp_fs_type) != 0) {</span>
<span class="line-added">294         // Skip cgroup2 fs lines on hybrid or unified hierarchy.</span>
<span class="line-added">295         continue;</span>
<span class="line-added">296       }</span>
<span class="line-added">297       any_cgroup_mounts_found = true;</span>
<span class="line-added">298       while ((token = strsep(&amp;cptr, &quot;,&quot;)) != NULL) {</span>
<span class="line-added">299         if (strcmp(token, &quot;memory&quot;) == 0) {</span>
<span class="line-added">300           assert(cg_infos[MEMORY_IDX]._mount_path == NULL, &quot;stomping of _mount_path&quot;);</span>
<span class="line-added">301           cg_infos[MEMORY_IDX]._mount_path = os::strdup(tmpmount);</span>
<span class="line-added">302           cg_infos[MEMORY_IDX]._root_mount_path = os::strdup(tmproot);</span>
<span class="line-added">303           cg_infos[MEMORY_IDX]._data_complete = true;</span>
<span class="line-added">304         } else if (strcmp(token, &quot;cpuset&quot;) == 0) {</span>
<span class="line-added">305           assert(cg_infos[CPUSET_IDX]._mount_path == NULL, &quot;stomping of _mount_path&quot;);</span>
<span class="line-added">306           cg_infos[CPUSET_IDX]._mount_path = os::strdup(tmpmount);</span>
<span class="line-added">307           cg_infos[CPUSET_IDX]._root_mount_path = os::strdup(tmproot);</span>
<span class="line-added">308           cg_infos[CPUSET_IDX]._data_complete = true;</span>
<span class="line-added">309         } else if (strcmp(token, &quot;cpu&quot;) == 0) {</span>
<span class="line-added">310           assert(cg_infos[CPU_IDX]._mount_path == NULL, &quot;stomping of _mount_path&quot;);</span>
<span class="line-added">311           cg_infos[CPU_IDX]._mount_path = os::strdup(tmpmount);</span>
<span class="line-added">312           cg_infos[CPU_IDX]._root_mount_path = os::strdup(tmproot);</span>
<span class="line-added">313           cg_infos[CPU_IDX]._data_complete = true;</span>
<span class="line-added">314         } else if (strcmp(token, &quot;cpuacct&quot;) == 0) {</span>
<span class="line-added">315           assert(cg_infos[CPUACCT_IDX]._mount_path == NULL, &quot;stomping of _mount_path&quot;);</span>
<span class="line-added">316           cg_infos[CPUACCT_IDX]._mount_path = os::strdup(tmpmount);</span>
<span class="line-added">317           cg_infos[CPUACCT_IDX]._root_mount_path = os::strdup(tmproot);</span>
<span class="line-added">318           cg_infos[CPUACCT_IDX]._data_complete = true;</span>
<span class="line-added">319         }</span>
320       }
321     }
322   }

323   fclose(mntinfo);
324 
<span class="line-modified">325   // Neither cgroup2 nor cgroup filesystems mounted via /proc/self/mountinfo</span>
<span class="line-added">326   // No point in continuing.</span>
<span class="line-added">327   if (!any_cgroup_mounts_found) {</span>
<span class="line-added">328     log_trace(os, container)(&quot;No cgroup controllers mounted.&quot;);</span>
<span class="line-added">329     cleanup(cg_infos);</span>
<span class="line-added">330     *flags = INVALID_CGROUPS_NO_MOUNT;</span>
<span class="line-added">331     return false;</span>
<span class="line-added">332   }</span>
<span class="line-added">333 </span>
<span class="line-added">334   if (is_cgroupsV2) {</span>
<span class="line-added">335     if (!cgroupv2_mount_point_found) {</span>
<span class="line-added">336       log_trace(os, container)(&quot;Mount point for cgroupv2 not found in /proc/self/mountinfo&quot;);</span>
<span class="line-added">337       cleanup(cg_infos);</span>
<span class="line-added">338       *flags = INVALID_CGROUPS_V2;</span>
<span class="line-added">339       return false;</span>
<span class="line-added">340     }</span>
<span class="line-added">341     // Cgroups v2 case, we have all the info we need.</span>
<span class="line-added">342     *flags = CGROUPS_V2;</span>
<span class="line-added">343     return true;</span>
<span class="line-added">344   }</span>
<span class="line-added">345 </span>
<span class="line-added">346   // What follows is cgroups v1</span>
<span class="line-added">347   log_debug(os, container)(&quot;Detected cgroups hybrid or legacy hierarchy, using cgroups v1 controllers&quot;);</span>
<span class="line-added">348 </span>
<span class="line-added">349   if (!cg_infos[MEMORY_IDX]._data_complete) {</span>
350     log_debug(os, container)(&quot;Required cgroup v1 memory subsystem not found&quot;);
<span class="line-modified">351     cleanup(cg_infos);</span>
<span class="line-added">352     *flags = INVALID_CGROUPS_V1;</span>
<span class="line-added">353     return false;</span>
354   }
<span class="line-modified">355   if (!cg_infos[CPUSET_IDX]._data_complete) {</span>
356     log_debug(os, container)(&quot;Required cgroup v1 cpuset subsystem not found&quot;);
<span class="line-modified">357     cleanup(cg_infos);</span>
<span class="line-added">358     *flags = INVALID_CGROUPS_V1;</span>
<span class="line-added">359     return false;</span>
360   }
<span class="line-modified">361   if (!cg_infos[CPU_IDX]._data_complete) {</span>
362     log_debug(os, container)(&quot;Required cgroup v1 cpu subsystem not found&quot;);
<span class="line-modified">363     cleanup(cg_infos);</span>
<span class="line-added">364     *flags = INVALID_CGROUPS_V1;</span>
<span class="line-added">365     return false;</span>
366   }
<span class="line-modified">367   if (!cg_infos[CPUACCT_IDX]._data_complete) {</span>
368     log_debug(os, container)(&quot;Required cgroup v1 cpuacct subsystem not found&quot;);
<span class="line-modified">369     cleanup(cg_infos);</span>
<span class="line-added">370     *flags = INVALID_CGROUPS_V1;</span>
<span class="line-added">371     return false;</span>
372   }
<span class="line-added">373   // Cgroups v1 case, we have all the info we need.</span>
<span class="line-added">374   *flags = CGROUPS_V1;</span>
<span class="line-added">375   return true;</span>
376 
<span class="line-modified">377 };</span>
<span class="line-modified">378 </span>
<span class="line-modified">379 void CgroupSubsystemFactory::cleanup(CgroupInfo* cg_infos) {</span>
<span class="line-modified">380   assert(cg_infos != NULL, &quot;Invariant&quot;);</span>




















381   for (int i = 0; i &lt; CG_INFO_LENGTH; i++) {
<span class="line-modified">382     os::free(cg_infos[i]._name);</span>
<span class="line-modified">383     os::free(cg_infos[i]._cgroup_path);</span>
<span class="line-modified">384     os::free(cg_infos[i]._root_mount_path);</span>
<span class="line-modified">385     os::free(cg_infos[i]._mount_path);</span>






386   }

387 }
388 
389 /* active_processor_count
390  *
391  * Calculate an appropriate number of active processors for the
392  * VM to use based on these three inputs.
393  *
394  * cpu affinity
395  * cgroup cpu quota &amp; cpu period
396  * cgroup cpu shares
397  *
398  * Algorithm:
399  *
400  * Determine the number of available CPUs from sched_getaffinity
401  *
402  * If user specified a quota (quota != -1), calculate the number of
403  * required CPUs by dividing quota by period.
404  *
405  * If shares are in effect (shares != -1), calculate the number
406  * of CPUs required for the shares by dividing the share value
</pre>
</td>
</tr>
</table>
<center><a href="../bsd/os_bsd.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="cgroupSubsystem_linux.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
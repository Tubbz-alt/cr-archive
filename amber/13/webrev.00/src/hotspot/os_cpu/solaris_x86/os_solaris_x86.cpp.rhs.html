<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/os_cpu/solaris_x86/os_solaris_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 // no precompiled headers
 26 #include &quot;jvm.h&quot;
 27 #include &quot;asm/macroAssembler.hpp&quot;
 28 #include &quot;classfile/classLoader.hpp&quot;
 29 #include &quot;classfile/systemDictionary.hpp&quot;
 30 #include &quot;classfile/vmSymbols.hpp&quot;
 31 #include &quot;code/codeCache.hpp&quot;
 32 #include &quot;code/icBuffer.hpp&quot;
 33 #include &quot;code/vtableStubs.hpp&quot;
 34 #include &quot;interpreter/interpreter.hpp&quot;
 35 #include &quot;logging/log.hpp&quot;
 36 #include &quot;memory/allocation.inline.hpp&quot;
 37 #include &quot;os_share_solaris.hpp&quot;
 38 #include &quot;prims/jniFastGetField.hpp&quot;
 39 #include &quot;prims/jvm_misc.hpp&quot;
 40 #include &quot;runtime/arguments.hpp&quot;
 41 #include &quot;runtime/extendedPC.hpp&quot;
 42 #include &quot;runtime/frame.inline.hpp&quot;
 43 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 44 #include &quot;runtime/java.hpp&quot;
 45 #include &quot;runtime/javaCalls.hpp&quot;
 46 #include &quot;runtime/mutexLocker.hpp&quot;
 47 #include &quot;runtime/osThread.hpp&quot;
<a name="1" id="anc1"></a><span class="line-added"> 48 #include &quot;runtime/safepointMechanism.hpp&quot;</span>
 49 #include &quot;runtime/sharedRuntime.hpp&quot;
 50 #include &quot;runtime/stubRoutines.hpp&quot;
 51 #include &quot;runtime/thread.inline.hpp&quot;
 52 #include &quot;runtime/timer.hpp&quot;
 53 #include &quot;utilities/align.hpp&quot;
 54 #include &quot;utilities/events.hpp&quot;
 55 #include &quot;utilities/vmError.hpp&quot;
 56 
 57 // put OS-includes here
 58 # include &lt;sys/types.h&gt;
 59 # include &lt;sys/mman.h&gt;
 60 # include &lt;pthread.h&gt;
 61 # include &lt;signal.h&gt;
 62 # include &lt;setjmp.h&gt;
 63 # include &lt;errno.h&gt;
 64 # include &lt;dlfcn.h&gt;
 65 # include &lt;stdio.h&gt;
 66 # include &lt;unistd.h&gt;
 67 # include &lt;sys/resource.h&gt;
 68 # include &lt;thread.h&gt;
 69 # include &lt;sys/stat.h&gt;
 70 # include &lt;sys/time.h&gt;
 71 # include &lt;sys/filio.h&gt;
 72 # include &lt;sys/utsname.h&gt;
 73 # include &lt;sys/systeminfo.h&gt;
 74 # include &lt;sys/socket.h&gt;
 75 # include &lt;sys/trap.h&gt;
 76 # include &lt;sys/lwp.h&gt;
 77 # include &lt;poll.h&gt;
 78 # include &lt;sys/lwp.h&gt;
 79 # include &lt;procfs.h&gt;     //  see comment in &lt;sys/procfs.h&gt;
 80 
 81 #ifndef AMD64
 82 // QQQ seems useless at this point
 83 # define _STRUCTURED_PROC 1  //  this gets us the new structured proc interfaces of 5.6 &amp; later
 84 #endif // AMD64
 85 # include &lt;sys/procfs.h&gt;     //  see comment in &lt;sys/procfs.h&gt;
 86 
 87 
 88 #define MAX_PATH (2 * K)
 89 
 90 // Minimum usable stack sizes required to get to user code. Space for
 91 // HotSpot guard pages is added later.
 92 #ifdef _LP64
 93 // The adlc generated method &#39;State::MachNodeGenerator(int)&#39; used by the C2 compiler
 94 // threads requires a large stack with the Solaris Studio C++ compiler version 5.13
 95 // and product VM builds (debug builds require significantly less stack space).
 96 size_t os::Posix::_compiler_thread_min_stack_allowed = 325 * K;
 97 size_t os::Posix::_java_thread_min_stack_allowed = 48 * K;
 98 size_t os::Posix::_vm_internal_thread_min_stack_allowed = 224 * K;
 99 #else
100 size_t os::Posix::_compiler_thread_min_stack_allowed = 32 * K;
101 size_t os::Posix::_java_thread_min_stack_allowed = 32 * K;
102 size_t os::Posix::_vm_internal_thread_min_stack_allowed = 64 * K;
103 #endif // _LP64
104 
105 #ifdef AMD64
106 #define REG_SP REG_RSP
107 #define REG_PC REG_RIP
108 #define REG_FP REG_RBP
109 #else
110 #define REG_SP UESP
111 #define REG_PC EIP
112 #define REG_FP EBP
113 // 4900493 counter to prevent runaway LDTR refresh attempt
114 
115 static volatile int ldtr_refresh = 0;
116 // the libthread instruction that faults because of the stale LDTR
117 
118 static const unsigned char movlfs[] = { 0x8e, 0xe0    // movl %eax,%fs
119                        };
120 #endif // AMD64
121 
122 char* os::non_memory_address_word() {
123   // Must never look like an address returned by reserve_memory,
124   // even in its subfields (as defined by the CPU immediate fields,
125   // if the CPU splits constants across multiple instructions).
126   return (char*) -1;
127 }
128 
129 //
130 // Validate a ucontext retrieved from walking a uc_link of a ucontext.
131 // There are issues with libthread giving out uc_links for different threads
132 // on the same uc_link chain and bad or circular links.
133 //
134 bool os::Solaris::valid_ucontext(Thread* thread, const ucontext_t* valid, const ucontext_t* suspect) {
135   if (valid &gt;= suspect ||
136       valid-&gt;uc_stack.ss_flags != suspect-&gt;uc_stack.ss_flags ||
137       valid-&gt;uc_stack.ss_sp    != suspect-&gt;uc_stack.ss_sp    ||
138       valid-&gt;uc_stack.ss_size  != suspect-&gt;uc_stack.ss_size) {
139     DEBUG_ONLY(tty-&gt;print_cr(&quot;valid_ucontext: failed test 1&quot;);)
140     return false;
141   }
142 
143   if (thread-&gt;is_Java_thread()) {
<a name="2" id="anc2"></a><span class="line-modified">144     if (!thread-&gt;is_in_full_stack_checked((address)suspect)) {</span>
145       DEBUG_ONLY(tty-&gt;print_cr(&quot;valid_ucontext: uc_link not in thread stack&quot;);)
146       return false;
147     }
<a name="3" id="anc3"></a><span class="line-modified">148     if (!thread-&gt;is_in_full_stack_checked((address) suspect-&gt;uc_mcontext.gregs[REG_SP])) {</span>
149       DEBUG_ONLY(tty-&gt;print_cr(&quot;valid_ucontext: stackpointer not in thread stack&quot;);)
150       return false;
151     }
152   }
153   return true;
154 }
155 
156 // We will only follow one level of uc_link since there are libthread
157 // issues with ucontext linking and it is better to be safe and just
158 // let caller retry later.
159 const ucontext_t* os::Solaris::get_valid_uc_in_signal_handler(Thread *thread,
160   const ucontext_t *uc) {
161 
162   const ucontext_t *retuc = NULL;
163 
164   if (uc != NULL) {
165     if (uc-&gt;uc_link == NULL) {
166       // cannot validate without uc_link so accept current ucontext
167       retuc = uc;
168     } else if (os::Solaris::valid_ucontext(thread, uc, uc-&gt;uc_link)) {
169       // first ucontext is valid so try the next one
170       uc = uc-&gt;uc_link;
171       if (uc-&gt;uc_link == NULL) {
172         // cannot validate without uc_link so accept current ucontext
173         retuc = uc;
174       } else if (os::Solaris::valid_ucontext(thread, uc, uc-&gt;uc_link)) {
175         // the ucontext one level down is also valid so return it
176         retuc = uc;
177       }
178     }
179   }
180   return retuc;
181 }
182 
183 // Assumes ucontext is valid
184 ExtendedPC os::Solaris::ucontext_get_ExtendedPC(const ucontext_t *uc) {
185   return ExtendedPC((address)uc-&gt;uc_mcontext.gregs[REG_PC]);
186 }
187 
188 void os::Solaris::ucontext_set_pc(ucontext_t* uc, address pc) {
189   uc-&gt;uc_mcontext.gregs [REG_PC]  = (greg_t) pc;
190 }
191 
192 // Assumes ucontext is valid
193 intptr_t* os::Solaris::ucontext_get_sp(const ucontext_t *uc) {
194   return (intptr_t*)uc-&gt;uc_mcontext.gregs[REG_SP];
195 }
196 
197 // Assumes ucontext is valid
198 intptr_t* os::Solaris::ucontext_get_fp(const ucontext_t *uc) {
199   return (intptr_t*)uc-&gt;uc_mcontext.gregs[REG_FP];
200 }
201 
202 address os::Solaris::ucontext_get_pc(const ucontext_t *uc) {
203   return (address) uc-&gt;uc_mcontext.gregs[REG_PC];
204 }
205 
206 // For Forte Analyzer AsyncGetCallTrace profiling support - thread
207 // is currently interrupted by SIGPROF.
208 //
209 // The difference between this and os::fetch_frame_from_context() is that
210 // here we try to skip nested signal frames.
211 // This method is also used for stack overflow signal handling.
212 ExtendedPC os::Solaris::fetch_frame_from_ucontext(Thread* thread,
213   const ucontext_t* uc, intptr_t** ret_sp, intptr_t** ret_fp) {
214 
215   assert(thread != NULL, &quot;just checking&quot;);
216   assert(ret_sp != NULL, &quot;just checking&quot;);
217   assert(ret_fp != NULL, &quot;just checking&quot;);
218 
219   const ucontext_t *luc = os::Solaris::get_valid_uc_in_signal_handler(thread, uc);
220   return os::fetch_frame_from_context(luc, ret_sp, ret_fp);
221 }
222 
223 ExtendedPC os::fetch_frame_from_context(const void* ucVoid,
224                     intptr_t** ret_sp, intptr_t** ret_fp) {
225 
226   ExtendedPC  epc;
227   const ucontext_t *uc = (const ucontext_t*)ucVoid;
228 
229   if (uc != NULL) {
230     epc = os::Solaris::ucontext_get_ExtendedPC(uc);
231     if (ret_sp) *ret_sp = os::Solaris::ucontext_get_sp(uc);
232     if (ret_fp) *ret_fp = os::Solaris::ucontext_get_fp(uc);
233   } else {
234     // construct empty ExtendedPC for return value checking
235     epc = ExtendedPC(NULL);
236     if (ret_sp) *ret_sp = (intptr_t *)NULL;
237     if (ret_fp) *ret_fp = (intptr_t *)NULL;
238   }
239 
240   return epc;
241 }
242 
243 frame os::fetch_frame_from_context(const void* ucVoid) {
244   intptr_t* sp;
245   intptr_t* fp;
246   ExtendedPC epc = fetch_frame_from_context(ucVoid, &amp;sp, &amp;fp);
247   return frame(sp, fp, epc.pc());
248 }
249 
250 frame os::fetch_frame_from_ucontext(Thread* thread, void* ucVoid) {
251   intptr_t* sp;
252   intptr_t* fp;
253   ExtendedPC epc = os::Solaris::fetch_frame_from_ucontext(thread, (ucontext_t*)ucVoid, &amp;sp, &amp;fp);
254   return frame(sp, fp, epc.pc());
255 }
256 
257 bool os::Solaris::get_frame_at_stack_banging_point(JavaThread* thread, ucontext_t* uc, frame* fr) {
258  address pc = (address) os::Solaris::ucontext_get_pc(uc);
259   if (Interpreter::contains(pc)) {
260     // interpreter performs stack banging after the fixed frame header has
261     // been generated while the compilers perform it before. To maintain
262     // semantic consistency between interpreted and compiled frames, the
263     // method returns the Java sender of the current frame.
264     *fr = os::fetch_frame_from_ucontext(thread, uc);
265     if (!fr-&gt;is_first_java_frame()) {
266       // get_frame_at_stack_banging_point() is only called when we
267       // have well defined stacks so java_sender() calls do not need
268       // to assert safe_for_sender() first.
269       *fr = fr-&gt;java_sender();
270     }
271   } else {
272     // more complex code with compiled code
273     assert(!Interpreter::contains(pc), &quot;Interpreted methods should have been handled above&quot;);
274     CodeBlob* cb = CodeCache::find_blob(pc);
275     if (cb == NULL || !cb-&gt;is_nmethod() || cb-&gt;is_frame_complete_at(pc)) {
276       // Not sure where the pc points to, fallback to default
277       // stack overflow handling
278       return false;
279     } else {
280       // in compiled code, the stack banging is performed just after the return pc
281       // has been pushed on the stack
282       intptr_t* fp = os::Solaris::ucontext_get_fp(uc);
283       intptr_t* sp = os::Solaris::ucontext_get_sp(uc);
284       *fr = frame(sp + 1, fp, (address)*sp);
285       if (!fr-&gt;is_java_frame()) {
286         // See java_sender() comment above.
287         *fr = fr-&gt;java_sender();
288       }
289     }
290   }
291   assert(fr-&gt;is_java_frame(), &quot;Safety check&quot;);
292   return true;
293 }
294 
295 frame os::get_sender_for_C_frame(frame* fr) {
296   return frame(fr-&gt;sender_sp(), fr-&gt;link(), fr-&gt;sender_pc());
297 }
298 
299 extern &quot;C&quot; intptr_t *_get_current_sp();  // in .il file
300 
301 address os::current_stack_pointer() {
302   return (address)_get_current_sp();
303 }
304 
305 extern &quot;C&quot; intptr_t *_get_current_fp();  // in .il file
306 
307 frame os::current_frame() {
308   intptr_t* fp = _get_current_fp();  // it&#39;s inlined so want current fp
309   // fp is for os::current_frame. We want the fp for our caller.
310   frame myframe((intptr_t*)os::current_stack_pointer(),
311                 (intptr_t*)fp,
312                 CAST_FROM_FN_PTR(address, os::current_frame));
313   frame caller_frame = os::get_sender_for_C_frame(&amp;myframe);
314 
315   if (os::is_first_C_frame(&amp;caller_frame)) {
316     // stack is not walkable
317     frame ret; // This will be a null useless frame
318     return ret;
319   } else {
320     // return frame for our caller&#39;s caller
321     return os::get_sender_for_C_frame(&amp;caller_frame);
322   }
323 }
324 
325 #ifndef AMD64
326 
327 // Detecting SSE support by OS
328 // From solaris_i486.s
329 extern &quot;C&quot; bool sse_check();
330 extern &quot;C&quot; bool sse_unavailable();
331 
332 enum { SSE_UNKNOWN, SSE_NOT_SUPPORTED, SSE_SUPPORTED};
333 static int sse_status = SSE_UNKNOWN;
334 
335 
336 static void  check_for_sse_support() {
337   if (!VM_Version::supports_sse()) {
338     sse_status = SSE_NOT_SUPPORTED;
339     return;
340   }
341   // looking for _sse_hw in libc.so, if it does not exist or
342   // the value (int) is 0, OS has no support for SSE
343   int *sse_hwp;
344   void *h;
345 
346   if ((h=dlopen(&quot;/usr/lib/libc.so&quot;, RTLD_LAZY)) == NULL) {
347     //open failed, presume no support for SSE
348     sse_status = SSE_NOT_SUPPORTED;
349     return;
350   }
351   if ((sse_hwp = (int *)dlsym(h, &quot;_sse_hw&quot;)) == NULL) {
352     sse_status = SSE_NOT_SUPPORTED;
353   } else if (*sse_hwp == 0) {
354     sse_status = SSE_NOT_SUPPORTED;
355   }
356   dlclose(h);
357 
358   if (sse_status == SSE_UNKNOWN) {
359     bool (*try_sse)() = (bool (*)())sse_check;
360     sse_status = (*try_sse)() ? SSE_SUPPORTED : SSE_NOT_SUPPORTED;
361   }
362 
363 }
364 
365 #endif // AMD64
366 
367 bool os::supports_sse() {
368 #ifdef AMD64
369   return true;
370 #else
371   if (sse_status == SSE_UNKNOWN)
372     check_for_sse_support();
373   return sse_status == SSE_SUPPORTED;
374 #endif // AMD64
375 }
376 
377 bool os::is_allocatable(size_t bytes) {
378 #ifdef AMD64
379   return true;
380 #else
381 
382   if (bytes &lt; 2 * G) {
383     return true;
384   }
385 
386   char* addr = reserve_memory(bytes, NULL);
387 
388   if (addr != NULL) {
389     release_memory(addr, bytes);
390   }
391 
392   return addr != NULL;
393 #endif // AMD64
394 
395 }
396 
397 extern &quot;C&quot; JNIEXPORT int
398 JVM_handle_solaris_signal(int sig, siginfo_t* info, void* ucVoid,
399                           int abort_if_unrecognized) {
400   ucontext_t* uc = (ucontext_t*) ucVoid;
401 
402 #ifndef AMD64
403   if (sig == SIGILL &amp;&amp; info-&gt;si_addr == (caddr_t)sse_check) {
404     // the SSE instruction faulted. supports_sse() need return false.
405     uc-&gt;uc_mcontext.gregs[EIP] = (greg_t)sse_unavailable;
406     return true;
407   }
408 #endif // !AMD64
409 
410   Thread* t = Thread::current_or_null_safe();
411 
412   // Must do this before SignalHandlerMark, if crash protection installed we will longjmp away
413   // (no destructors can be run)
414   os::ThreadCrashProtection::check_crash_protection(sig, t);
415 
416   SignalHandlerMark shm(t);
417 
418   if(sig == SIGPIPE || sig == SIGXFSZ) {
419     if (os::Solaris::chained_handler(sig, info, ucVoid)) {
420       return true;
421     } else {
422       // Ignoring SIGPIPE/SIGXFSZ - see bugs 4229104 or 6499219
423       return true;
424     }
425   }
426 
427   JavaThread* thread = NULL;
428   VMThread* vmthread = NULL;
429 
430   if (os::Solaris::signal_handlers_are_installed) {
431     if (t != NULL ){
432       if(t-&gt;is_Java_thread()) {
433         thread = (JavaThread*)t;
434       }
435       else if(t-&gt;is_VM_thread()){
436         vmthread = (VMThread *)t;
437       }
438     }
439   }
440 
441   if (sig == ASYNC_SIGNAL) {
442     if(thread || vmthread){
443       OSThread::SR_handler(t, uc);
444       return true;
445     } else if (os::Solaris::chained_handler(sig, info, ucVoid)) {
446       return true;
447     } else {
448       // If ASYNC_SIGNAL not chained, and this is a non-vm and
449       // non-java thread
450       return true;
451     }
452   }
453 
454   if (info == NULL || info-&gt;si_code &lt;= 0 || info-&gt;si_code == SI_NOINFO) {
455     // can&#39;t decode this kind of signal
456     info = NULL;
457   } else {
458     assert(sig == info-&gt;si_signo, &quot;bad siginfo&quot;);
459   }
460 
461   // decide if this trap can be handled by a stub
462   address stub = NULL;
463 
464   address pc          = NULL;
465 
466   //%note os_trap_1
467   if (info != NULL &amp;&amp; uc != NULL &amp;&amp; thread != NULL) {
468     // factor me: getPCfromContext
469     pc = (address) uc-&gt;uc_mcontext.gregs[REG_PC];
470 
471     if (StubRoutines::is_safefetch_fault(pc)) {
472       os::Solaris::ucontext_set_pc(uc, StubRoutines::continuation_for_safefetch_fault(pc));
473       return true;
474     }
475 
476     // Handle ALL stack overflow variations here
477     if (sig == SIGSEGV &amp;&amp; info-&gt;si_code == SEGV_ACCERR) {
478       address addr = (address) info-&gt;si_addr;
479       if (thread-&gt;in_stack_yellow_reserved_zone(addr)) {
480         if (thread-&gt;thread_state() == _thread_in_Java) {
481           if (thread-&gt;in_stack_reserved_zone(addr)) {
482             frame fr;
483             if (os::Solaris::get_frame_at_stack_banging_point(thread, uc, &amp;fr)) {
484               assert(fr.is_java_frame(), &quot;Must be Java frame&quot;);
485               frame activation = SharedRuntime::look_for_reserved_stack_annotated_method(thread, fr);
486               if (activation.sp() != NULL) {
487                 thread-&gt;disable_stack_reserved_zone();
488                 if (activation.is_interpreted_frame()) {
489                   thread-&gt;set_reserved_stack_activation((address)(
490                     activation.fp() + frame::interpreter_frame_initial_sp_offset));
491                 } else {
492                   thread-&gt;set_reserved_stack_activation((address)activation.unextended_sp());
493                 }
494                 return true;
495               }
496             }
497           }
498           // Throw a stack overflow exception.  Guard pages will be reenabled
499           // while unwinding the stack.
500           thread-&gt;disable_stack_yellow_reserved_zone();
501           stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::STACK_OVERFLOW);
502         } else {
503           // Thread was in the vm or native code.  Return and try to finish.
504           thread-&gt;disable_stack_yellow_reserved_zone();
505           return true;
506         }
507       } else if (thread-&gt;in_stack_red_zone(addr)) {
508         // Fatal red zone violation.  Disable the guard pages and fall through
509         // to handle_unexpected_exception way down below.
510         thread-&gt;disable_stack_red_zone();
511         tty-&gt;print_raw_cr(&quot;An irrecoverable stack overflow has occurred.&quot;);
512       }
513     }
514 
515     if ((sig == SIGSEGV) &amp;&amp; VM_Version::is_cpuinfo_segv_addr(pc)) {
516       // Verify that OS save/restore AVX registers.
517       stub = VM_Version::cpuinfo_cont_addr();
518     }
519 
520     if (thread-&gt;thread_state() == _thread_in_vm ||
521          thread-&gt;thread_state() == _thread_in_native) {
522       if (sig == SIGBUS &amp;&amp; info-&gt;si_code == BUS_OBJERR &amp;&amp; thread-&gt;doing_unsafe_access()) {
523         address next_pc = Assembler::locate_next_instruction(pc);
524         if (UnsafeCopyMemory::contains_pc(pc)) {
525           next_pc = UnsafeCopyMemory::page_error_continue_pc(pc);
526         }
527         stub = SharedRuntime::handle_unsafe_access(thread, next_pc);
528       }
529     }
530 
531     if (thread-&gt;thread_state() == _thread_in_Java) {
532       // Support Safepoint Polling
<a name="4" id="anc4"></a><span class="line-modified">533       if ( sig == SIGSEGV &amp;&amp; SafepointMechanism::is_poll_address((address)info-&gt;si_addr)) {</span>
534         stub = SharedRuntime::get_poll_stub(pc);
535       }
536       else if (sig == SIGBUS &amp;&amp; info-&gt;si_code == BUS_OBJERR) {
537         // BugId 4454115: A read from a MappedByteBuffer can fault
538         // here if the underlying file has been truncated.
539         // Do not crash the VM in such a case.
540         CodeBlob* cb = CodeCache::find_blob_unsafe(pc);
541         if (cb != NULL) {
542           CompiledMethod* nm = cb-&gt;as_compiled_method_or_null();
543           bool is_unsafe_arraycopy = thread-&gt;doing_unsafe_access() &amp;&amp; UnsafeCopyMemory::contains_pc(pc);
544           if ((nm != NULL &amp;&amp; nm-&gt;has_unsafe_access()) || is_unsafe_arraycopy) {
545             address next_pc = Assembler::locate_next_instruction(pc);
546             if (is_unsafe_arraycopy) {
547               next_pc = UnsafeCopyMemory::page_error_continue_pc(pc);
548             }
549             stub = SharedRuntime::handle_unsafe_access(thread, next_pc);
550           }
551         }
552       }
553       else
554       if (sig == SIGFPE &amp;&amp; info-&gt;si_code == FPE_INTDIV) {
555         // integer divide by zero
556         stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_DIVIDE_BY_ZERO);
557       }
558 #ifndef AMD64
559       else if (sig == SIGFPE &amp;&amp; info-&gt;si_code == FPE_FLTDIV) {
560         // floating-point divide by zero
561         stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_DIVIDE_BY_ZERO);
562       }
563       else if (sig == SIGFPE &amp;&amp; info-&gt;si_code == FPE_FLTINV) {
564         // The encoding of D2I in i486.ad can cause an exception prior
565         // to the fist instruction if there was an invalid operation
566         // pending. We want to dismiss that exception. From the win_32
567         // side it also seems that if it really was the fist causing
568         // the exception that we do the d2i by hand with different
569         // rounding. Seems kind of weird. QQQ TODO
570         // Note that we take the exception at the NEXT floating point instruction.
571         if (pc[0] == 0xDB) {
572             assert(pc[0] == 0xDB, &quot;not a FIST opcode&quot;);
573             assert(pc[1] == 0x14, &quot;not a FIST opcode&quot;);
574             assert(pc[2] == 0x24, &quot;not a FIST opcode&quot;);
575             return true;
576         } else {
577             assert(pc[-3] == 0xDB, &quot;not an flt invalid opcode&quot;);
578             assert(pc[-2] == 0x14, &quot;not an flt invalid opcode&quot;);
579             assert(pc[-1] == 0x24, &quot;not an flt invalid opcode&quot;);
580         }
581       }
582       else if (sig == SIGFPE ) {
583         tty-&gt;print_cr(&quot;caught SIGFPE, info 0x%x.&quot;, info-&gt;si_code);
584       }
585 #endif // !AMD64
586 
587         // QQQ It doesn&#39;t seem that we need to do this on x86 because we should be able
588         // to return properly from the handler without this extra stuff on the back side.
589 
590       else if (sig == SIGSEGV &amp;&amp; info-&gt;si_code &gt; 0 &amp;&amp;
591                MacroAssembler::uses_implicit_null_check(info-&gt;si_addr)) {
592         // Determination of interpreter/vtable stub/compiled code null exception
593         stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_NULL);
594       }
595     }
596 
597     // jni_fast_Get&lt;Primitive&gt;Field can trap at certain pc&#39;s if a GC kicks in
598     // and the heap gets shrunk before the field access.
599     if ((sig == SIGSEGV) || (sig == SIGBUS)) {
600       address addr = JNI_FastGetField::find_slowcase_pc(pc);
601       if (addr != (address)-1) {
602         stub = addr;
603       }
604     }
605   }
606 
607   // Execution protection violation
608   //
609   // Preventative code for future versions of Solaris which may
610   // enable execution protection when running the 32-bit VM on AMD64.
611   //
612   // This should be kept as the last step in the triage.  We don&#39;t
613   // have a dedicated trap number for a no-execute fault, so be
614   // conservative and allow other handlers the first shot.
615   //
616   // Note: We don&#39;t test that info-&gt;si_code == SEGV_ACCERR here.
617   // this si_code is so generic that it is almost meaningless; and
618   // the si_code for this condition may change in the future.
619   // Furthermore, a false-positive should be harmless.
620   if (UnguardOnExecutionViolation &gt; 0 &amp;&amp;
621       (sig == SIGSEGV || sig == SIGBUS) &amp;&amp;
622       uc-&gt;uc_mcontext.gregs[TRAPNO] == T_PGFLT) {  // page fault
623     int page_size = os::vm_page_size();
624     address addr = (address) info-&gt;si_addr;
625     address pc = (address) uc-&gt;uc_mcontext.gregs[REG_PC];
626     // Make sure the pc and the faulting address are sane.
627     //
628     // If an instruction spans a page boundary, and the page containing
629     // the beginning of the instruction is executable but the following
630     // page is not, the pc and the faulting address might be slightly
631     // different - we still want to unguard the 2nd page in this case.
632     //
633     // 15 bytes seems to be a (very) safe value for max instruction size.
634     bool pc_is_near_addr =
635       (pointer_delta((void*) addr, (void*) pc, sizeof(char)) &lt; 15);
636     bool instr_spans_page_boundary =
637       (align_down((intptr_t) pc ^ (intptr_t) addr,
638                        (intptr_t) page_size) &gt; 0);
639 
640     if (pc == addr || (pc_is_near_addr &amp;&amp; instr_spans_page_boundary)) {
641       static volatile address last_addr =
642         (address) os::non_memory_address_word();
643 
644       // In conservative mode, don&#39;t unguard unless the address is in the VM
645       if (addr != last_addr &amp;&amp;
646           (UnguardOnExecutionViolation &gt; 1 || os::address_is_in_vm(addr))) {
647 
648         // Make memory rwx and retry
649         address page_start = align_down(addr, page_size);
650         bool res = os::protect_memory((char*) page_start, page_size,
651                                       os::MEM_PROT_RWX);
652 
653         log_debug(os)(&quot;Execution protection violation &quot;
654                       &quot;at &quot; INTPTR_FORMAT
655                       &quot;, unguarding &quot; INTPTR_FORMAT &quot;: %s, errno=%d&quot;, p2i(addr),
656                       p2i(page_start), (res ? &quot;success&quot; : &quot;failed&quot;), errno);
657         stub = pc;
658 
659         // Set last_addr so if we fault again at the same address, we don&#39;t end
660         // up in an endless loop.
661         //
662         // There are two potential complications here.  Two threads trapping at
663         // the same address at the same time could cause one of the threads to
664         // think it already unguarded, and abort the VM.  Likely very rare.
665         //
666         // The other race involves two threads alternately trapping at
667         // different addresses and failing to unguard the page, resulting in
668         // an endless loop.  This condition is probably even more unlikely than
669         // the first.
670         //
671         // Although both cases could be avoided by using locks or thread local
672         // last_addr, these solutions are unnecessary complication: this
673         // handler is a best-effort safety net, not a complete solution.  It is
674         // disabled by default and should only be used as a workaround in case
675         // we missed any no-execute-unsafe VM code.
676 
677         last_addr = addr;
678       }
679     }
680   }
681 
682   if (stub != NULL) {
683     // save all thread context in case we need to restore it
684 
685     if (thread != NULL) thread-&gt;set_saved_exception_pc(pc);
686     // 12/02/99: On Sparc it appears that the full context is also saved
687     // but as yet, no one looks at or restores that saved context
688     os::Solaris::ucontext_set_pc(uc, stub);
689     return true;
690   }
691 
692   // signal-chaining
693   if (os::Solaris::chained_handler(sig, info, ucVoid)) {
694     return true;
695   }
696 
697   if (!abort_if_unrecognized) {
698     // caller wants another chance, so give it to him
699     return false;
700   }
701 
702   if (!os::Solaris::libjsig_is_loaded) {
703     struct sigaction oldAct;
704     sigaction(sig, (struct sigaction *)0, &amp;oldAct);
705     if (oldAct.sa_sigaction != signalHandler) {
706       void* sighand = oldAct.sa_sigaction ? CAST_FROM_FN_PTR(void*,  oldAct.sa_sigaction)
707                                           : CAST_FROM_FN_PTR(void*, oldAct.sa_handler);
708       warning(&quot;Unexpected Signal %d occurred under user-defined signal handler %#lx&quot;, sig, (long)sighand);
709     }
710   }
711 
712   if (pc == NULL &amp;&amp; uc != NULL) {
713     pc = (address) uc-&gt;uc_mcontext.gregs[REG_PC];
714   }
715 
716   // unmask current signal
717   sigset_t newset;
718   sigemptyset(&amp;newset);
719   sigaddset(&amp;newset, sig);
720   sigprocmask(SIG_UNBLOCK, &amp;newset, NULL);
721 
722   // Determine which sort of error to throw.  Out of swap may signal
723   // on the thread stack, which could get a mapping error when touched.
724   address addr = (address) info-&gt;si_addr;
725   if (sig == SIGBUS &amp;&amp; info-&gt;si_code == BUS_OBJERR &amp;&amp; info-&gt;si_errno == ENOMEM) {
726     vm_exit_out_of_memory(0, OOM_MMAP_ERROR, &quot;Out of swap space to map in thread stack.&quot;);
727   }
728 
729   VMError::report_and_die(t, sig, pc, info, ucVoid);
730 
731   ShouldNotReachHere();
732   return false;
733 }
734 
735 void os::print_context(outputStream *st, const void *context) {
736   if (context == NULL) return;
737 
738   const ucontext_t *uc = (const ucontext_t*)context;
739   st-&gt;print_cr(&quot;Registers:&quot;);
740 #ifdef AMD64
741   st-&gt;print(  &quot;RAX=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RAX]);
742   st-&gt;print(&quot;, RBX=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RBX]);
743   st-&gt;print(&quot;, RCX=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RCX]);
744   st-&gt;print(&quot;, RDX=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RDX]);
745   st-&gt;cr();
746   st-&gt;print(  &quot;RSP=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RSP]);
747   st-&gt;print(&quot;, RBP=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RBP]);
748   st-&gt;print(&quot;, RSI=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RSI]);
749   st-&gt;print(&quot;, RDI=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RDI]);
750   st-&gt;cr();
751   st-&gt;print(  &quot;R8 =&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_R8]);
752   st-&gt;print(&quot;, R9 =&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_R9]);
753   st-&gt;print(&quot;, R10=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_R10]);
754   st-&gt;print(&quot;, R11=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_R11]);
755   st-&gt;cr();
756   st-&gt;print(  &quot;R12=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_R12]);
757   st-&gt;print(&quot;, R13=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_R13]);
758   st-&gt;print(&quot;, R14=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_R14]);
759   st-&gt;print(&quot;, R15=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_R15]);
760   st-&gt;cr();
761   st-&gt;print(  &quot;RIP=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RIP]);
762   st-&gt;print(&quot;, RFLAGS=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RFL]);
763 #else
764   st-&gt;print(  &quot;EAX=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[EAX]);
765   st-&gt;print(&quot;, EBX=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[EBX]);
766   st-&gt;print(&quot;, ECX=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[ECX]);
767   st-&gt;print(&quot;, EDX=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[EDX]);
768   st-&gt;cr();
769   st-&gt;print(  &quot;ESP=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[UESP]);
770   st-&gt;print(&quot;, EBP=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[EBP]);
771   st-&gt;print(&quot;, ESI=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[ESI]);
772   st-&gt;print(&quot;, EDI=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[EDI]);
773   st-&gt;cr();
774   st-&gt;print(  &quot;EIP=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[EIP]);
775   st-&gt;print(&quot;, EFLAGS=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[EFL]);
776 #endif // AMD64
777   st-&gt;cr();
778   st-&gt;cr();
779 
780   intptr_t *sp = (intptr_t *)os::Solaris::ucontext_get_sp(uc);
781   st-&gt;print_cr(&quot;Top of Stack: (sp=&quot; PTR_FORMAT &quot;)&quot;, sp);
782   print_hex_dump(st, (address)sp, (address)(sp + 8*sizeof(intptr_t)), sizeof(intptr_t));
783   st-&gt;cr();
784 
785   // Note: it may be unsafe to inspect memory near pc. For example, pc may
786   // point to garbage if entry point in an nmethod is corrupted. Leave
787   // this at the end, and hope for the best.
788   ExtendedPC epc = os::Solaris::ucontext_get_ExtendedPC(uc);
789   address pc = epc.pc();
790   print_instructions(st, pc, sizeof(char));
791   st-&gt;cr();
792 }
793 
794 void os::print_register_info(outputStream *st, const void *context) {
795   if (context == NULL) return;
796 
797   const ucontext_t *uc = (const ucontext_t*)context;
798 
799   st-&gt;print_cr(&quot;Register to memory mapping:&quot;);
800   st-&gt;cr();
801 
802   // this is horrendously verbose but the layout of the registers in the
803   // context does not match how we defined our abstract Register set, so
804   // we can&#39;t just iterate through the gregs area
805 
806   // this is only for the &quot;general purpose&quot; registers
807 
808 #ifdef AMD64
809   st-&gt;print(&quot;RAX=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_RAX]);
810   st-&gt;print(&quot;RBX=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_RBX]);
811   st-&gt;print(&quot;RCX=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_RCX]);
812   st-&gt;print(&quot;RDX=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_RDX]);
813   st-&gt;print(&quot;RSP=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_RSP]);
814   st-&gt;print(&quot;RBP=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_RBP]);
815   st-&gt;print(&quot;RSI=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_RSI]);
816   st-&gt;print(&quot;RDI=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_RDI]);
817   st-&gt;print(&quot;R8 =&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_R8]);
818   st-&gt;print(&quot;R9 =&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_R9]);
819   st-&gt;print(&quot;R10=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_R10]);
820   st-&gt;print(&quot;R11=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_R11]);
821   st-&gt;print(&quot;R12=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_R12]);
822   st-&gt;print(&quot;R13=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_R13]);
823   st-&gt;print(&quot;R14=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_R14]);
824   st-&gt;print(&quot;R15=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_R15]);
825 #else
826   st-&gt;print(&quot;EAX=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[EAX]);
827   st-&gt;print(&quot;EBX=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[EBX]);
828   st-&gt;print(&quot;ECX=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[ECX]);
829   st-&gt;print(&quot;EDX=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[EDX]);
830   st-&gt;print(&quot;ESP=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[UESP]);
831   st-&gt;print(&quot;EBP=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[EBP]);
832   st-&gt;print(&quot;ESI=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[ESI]);
833   st-&gt;print(&quot;EDI=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[EDI]);
834 #endif
835 
836   st-&gt;cr();
837 }
838 
839 
840 #ifdef AMD64
841 void os::Solaris::init_thread_fpu_state(void) {
842   // Nothing to do
843 }
844 #else
845 // From solaris_i486.s
846 extern &quot;C&quot; void fixcw();
847 
848 void os::Solaris::init_thread_fpu_state(void) {
849   // Set fpu to 53 bit precision. This happens too early to use a stub.
850   fixcw();
851 }
852 
853 // These routines are the initial value of atomic_xchg_entry(),
854 // atomic_cmpxchg_entry(), atomic_inc_entry() and fence_entry()
855 // until initialization is complete.
856 // TODO - replace with .il implementation when compiler supports it.
857 
858 typedef int32_t  xchg_func_t        (int32_t,  volatile int32_t*);
859 typedef int32_t  cmpxchg_func_t     (int32_t,  volatile int32_t*,  int32_t);
860 typedef int64_t  cmpxchg_long_func_t(int64_t,  volatile int64_t*,  int64_t);
861 typedef int32_t  add_func_t         (int32_t,  volatile int32_t*);
862 
863 int32_t os::atomic_xchg_bootstrap(int32_t exchange_value, volatile int32_t* dest) {
864   // try to use the stub:
865   xchg_func_t* func = CAST_TO_FN_PTR(xchg_func_t*, StubRoutines::atomic_xchg_entry());
866 
867   if (func != NULL) {
868     os::atomic_xchg_func = func;
869     return (*func)(exchange_value, dest);
870   }
871   assert(Threads::number_of_threads() == 0, &quot;for bootstrap only&quot;);
872 
873   int32_t old_value = *dest;
874   *dest = exchange_value;
875   return old_value;
876 }
877 
878 int32_t os::atomic_cmpxchg_bootstrap(int32_t exchange_value, volatile int32_t* dest, int32_t compare_value) {
879   // try to use the stub:
880   cmpxchg_func_t* func = CAST_TO_FN_PTR(cmpxchg_func_t*, StubRoutines::atomic_cmpxchg_entry());
881 
882   if (func != NULL) {
883     os::atomic_cmpxchg_func = func;
884     return (*func)(exchange_value, dest, compare_value);
885   }
886   assert(Threads::number_of_threads() == 0, &quot;for bootstrap only&quot;);
887 
888   int32_t old_value = *dest;
889   if (old_value == compare_value)
890     *dest = exchange_value;
891   return old_value;
892 }
893 
894 int64_t os::atomic_cmpxchg_long_bootstrap(int64_t exchange_value, volatile int64_t* dest, int64_t compare_value) {
895   // try to use the stub:
896   cmpxchg_long_func_t* func = CAST_TO_FN_PTR(cmpxchg_long_func_t*, StubRoutines::atomic_cmpxchg_long_entry());
897 
898   if (func != NULL) {
899     os::atomic_cmpxchg_long_func = func;
900     return (*func)(exchange_value, dest, compare_value);
901   }
902   assert(Threads::number_of_threads() == 0, &quot;for bootstrap only&quot;);
903 
904   int64_t old_value = *dest;
905   if (old_value == compare_value)
906     *dest = exchange_value;
907   return old_value;
908 }
909 
910 int32_t os::atomic_add_bootstrap(int32_t add_value, volatile int32_t* dest) {
911   // try to use the stub:
912   add_func_t* func = CAST_TO_FN_PTR(add_func_t*, StubRoutines::atomic_add_entry());
913 
914   if (func != NULL) {
915     os::atomic_add_func = func;
916     return (*func)(add_value, dest);
917   }
918   assert(Threads::number_of_threads() == 0, &quot;for bootstrap only&quot;);
919 
920   return (*dest) += add_value;
921 }
922 
923 xchg_func_t*         os::atomic_xchg_func         = os::atomic_xchg_bootstrap;
924 cmpxchg_func_t*      os::atomic_cmpxchg_func      = os::atomic_cmpxchg_bootstrap;
925 cmpxchg_long_func_t* os::atomic_cmpxchg_long_func = os::atomic_cmpxchg_long_bootstrap;
926 add_func_t*          os::atomic_add_func          = os::atomic_add_bootstrap;
927 
928 extern &quot;C&quot; void _solaris_raw_setup_fpu(address ptr);
929 void os::setup_fpu() {
930   address fpu_cntrl = StubRoutines::addr_fpu_cntrl_wrd_std();
931   _solaris_raw_setup_fpu(fpu_cntrl);
932 }
933 #endif // AMD64
934 
935 #ifndef PRODUCT
936 void os::verify_stack_alignment() {
937 #ifdef AMD64
938   assert(((intptr_t)os::current_stack_pointer() &amp; (StackAlignmentInBytes-1)) == 0, &quot;incorrect stack alignment&quot;);
939 #endif
940 }
941 #endif
942 
943 int os::extra_bang_size_in_bytes() {
944   // JDK-8050147 requires the full cache line bang for x86.
945   return VM_Version::L1_line_size();
946 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
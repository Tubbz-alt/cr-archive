<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os_cpu/linux_aarch64/os_linux_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../bsd_x86/os_bsd_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os_linux_aarch64.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os_cpu/linux_aarch64/os_linux_aarch64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 29 #include &quot;classfile/classLoader.hpp&quot;
 30 #include &quot;classfile/systemDictionary.hpp&quot;
 31 #include &quot;classfile/vmSymbols.hpp&quot;
 32 #include &quot;code/codeCache.hpp&quot;
 33 #include &quot;code/icBuffer.hpp&quot;
 34 #include &quot;code/vtableStubs.hpp&quot;
 35 #include &quot;code/nativeInst.hpp&quot;
 36 #include &quot;interpreter/interpreter.hpp&quot;
 37 #include &quot;memory/allocation.inline.hpp&quot;
 38 #include &quot;os_share_linux.hpp&quot;
 39 #include &quot;prims/jniFastGetField.hpp&quot;
 40 #include &quot;prims/jvm_misc.hpp&quot;
 41 #include &quot;runtime/arguments.hpp&quot;
 42 #include &quot;runtime/extendedPC.hpp&quot;
 43 #include &quot;runtime/frame.inline.hpp&quot;
 44 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 45 #include &quot;runtime/java.hpp&quot;
 46 #include &quot;runtime/javaCalls.hpp&quot;
 47 #include &quot;runtime/mutexLocker.hpp&quot;
 48 #include &quot;runtime/osThread.hpp&quot;

 49 #include &quot;runtime/sharedRuntime.hpp&quot;
 50 #include &quot;runtime/stubRoutines.hpp&quot;
 51 #include &quot;runtime/thread.inline.hpp&quot;
 52 #include &quot;runtime/timer.hpp&quot;
 53 #include &quot;utilities/debug.hpp&quot;
 54 #include &quot;utilities/events.hpp&quot;
 55 #include &quot;utilities/vmError.hpp&quot;
 56 
 57 // put OS-includes here
 58 # include &lt;sys/types.h&gt;
 59 # include &lt;sys/mman.h&gt;
 60 # include &lt;pthread.h&gt;
 61 # include &lt;signal.h&gt;
 62 # include &lt;errno.h&gt;
 63 # include &lt;dlfcn.h&gt;
 64 # include &lt;stdlib.h&gt;
 65 # include &lt;stdio.h&gt;
 66 # include &lt;unistd.h&gt;
 67 # include &lt;sys/resource.h&gt;
 68 # include &lt;pthread.h&gt;
</pre>
<hr />
<pre>
347              }
348              thread-&gt;osthread()-&gt;clear_expanding_stack();
349           } else {
350              fatal(&quot;recursive segv. expanding stack.&quot;);
351           }
352         }
353       }
354     }
355 
356     if (thread-&gt;thread_state() == _thread_in_Java) {
357       // Java thread running in Java code =&gt; find exception handler if any
358       // a fault inside compiled code, the interpreter, or a stub
359 
360       // Handle signal from NativeJump::patch_verified_entry().
361       if ((sig == SIGILL || sig == SIGTRAP)
362           &amp;&amp; nativeInstruction_at(pc)-&gt;is_sigill_zombie_not_entrant()) {
363         if (TraceTraps) {
364           tty-&gt;print_cr(&quot;trap: zombie_not_entrant (%s)&quot;, (sig == SIGTRAP) ? &quot;SIGTRAP&quot; : &quot;SIGILL&quot;);
365         }
366         stub = SharedRuntime::get_handle_wrong_method_stub();
<span class="line-modified">367       } else if (sig == SIGSEGV &amp;&amp; os::is_poll_address((address)info-&gt;si_addr)) {</span>
368         stub = SharedRuntime::get_poll_stub(pc);
369       } else if (sig == SIGBUS /* &amp;&amp; info-&gt;si_code == BUS_OBJERR */) {
370         // BugId 4454115: A read from a MappedByteBuffer can fault
371         // here if the underlying file has been truncated.
372         // Do not crash the VM in such a case.
373         CodeBlob* cb = CodeCache::find_blob_unsafe(pc);
374         CompiledMethod* nm = (cb != NULL) ? cb-&gt;as_compiled_method_or_null() : NULL;
375         bool is_unsafe_arraycopy = (thread-&gt;doing_unsafe_access() &amp;&amp; UnsafeCopyMemory::contains_pc(pc));
376         if ((nm != NULL &amp;&amp; nm-&gt;has_unsafe_access()) || is_unsafe_arraycopy) {
377           address next_pc = pc + NativeCall::instruction_size;
378           if (is_unsafe_arraycopy) {
379             next_pc = UnsafeCopyMemory::page_error_continue_pc(pc);
380           }
381           stub = SharedRuntime::handle_unsafe_access(thread, next_pc);
382         }
383       }
384       else
385 
386       if (sig == SIGFPE  &amp;&amp;
387           (info-&gt;si_code == FPE_INTDIV || info-&gt;si_code == FPE_FLTDIV)) {
</pre>
<hr />
<pre>
444   sigemptyset(&amp;newset);
445   sigaddset(&amp;newset, sig);
446   sigprocmask(SIG_UNBLOCK, &amp;newset, NULL);
447 
448   VMError::report_and_die(t, sig, pc, info, ucVoid);
449 
450   ShouldNotReachHere();
451   return true; // Mute compiler
452 }
453 
454 void os::Linux::init_thread_fpu_state(void) {
455 }
456 
457 int os::Linux::get_fpu_control_word(void) {
458   return 0;
459 }
460 
461 void os::Linux::set_fpu_control_word(int fpu_control) {
462 }
463 
<span class="line-removed">464 // Check that the linux kernel version is 2.4 or higher since earlier</span>
<span class="line-removed">465 // versions do not support SSE without patches.</span>
<span class="line-removed">466 bool os::supports_sse() {</span>
<span class="line-removed">467   return true;</span>
<span class="line-removed">468 }</span>
<span class="line-removed">469 </span>
470 bool os::is_allocatable(size_t bytes) {
471   return true;
472 }
473 
474 ////////////////////////////////////////////////////////////////////////////////
475 // thread stack
476 
477 // Minimum usable stack sizes required to get to user code. Space for
478 // HotSpot guard pages is added later.
479 size_t os::Posix::_compiler_thread_min_stack_allowed = 72 * K;
480 size_t os::Posix::_java_thread_min_stack_allowed = 72 * K;
481 size_t os::Posix::_vm_internal_thread_min_stack_allowed = 72 * K;
482 
483 // return default stack size for thr_type
484 size_t os::Posix::default_stack_size(os::ThreadType thr_type) {
485   // default stack size (compiler thread needs larger stack)
486   size_t s = (thr_type == os::compiler_thread ? 4 * M : 1 * M);
487   return s;
488 }
489 
</pre>
</td>
<td>
<hr />
<pre>
 29 #include &quot;classfile/classLoader.hpp&quot;
 30 #include &quot;classfile/systemDictionary.hpp&quot;
 31 #include &quot;classfile/vmSymbols.hpp&quot;
 32 #include &quot;code/codeCache.hpp&quot;
 33 #include &quot;code/icBuffer.hpp&quot;
 34 #include &quot;code/vtableStubs.hpp&quot;
 35 #include &quot;code/nativeInst.hpp&quot;
 36 #include &quot;interpreter/interpreter.hpp&quot;
 37 #include &quot;memory/allocation.inline.hpp&quot;
 38 #include &quot;os_share_linux.hpp&quot;
 39 #include &quot;prims/jniFastGetField.hpp&quot;
 40 #include &quot;prims/jvm_misc.hpp&quot;
 41 #include &quot;runtime/arguments.hpp&quot;
 42 #include &quot;runtime/extendedPC.hpp&quot;
 43 #include &quot;runtime/frame.inline.hpp&quot;
 44 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 45 #include &quot;runtime/java.hpp&quot;
 46 #include &quot;runtime/javaCalls.hpp&quot;
 47 #include &quot;runtime/mutexLocker.hpp&quot;
 48 #include &quot;runtime/osThread.hpp&quot;
<span class="line-added"> 49 #include &quot;runtime/safepointMechanism.hpp&quot;</span>
 50 #include &quot;runtime/sharedRuntime.hpp&quot;
 51 #include &quot;runtime/stubRoutines.hpp&quot;
 52 #include &quot;runtime/thread.inline.hpp&quot;
 53 #include &quot;runtime/timer.hpp&quot;
 54 #include &quot;utilities/debug.hpp&quot;
 55 #include &quot;utilities/events.hpp&quot;
 56 #include &quot;utilities/vmError.hpp&quot;
 57 
 58 // put OS-includes here
 59 # include &lt;sys/types.h&gt;
 60 # include &lt;sys/mman.h&gt;
 61 # include &lt;pthread.h&gt;
 62 # include &lt;signal.h&gt;
 63 # include &lt;errno.h&gt;
 64 # include &lt;dlfcn.h&gt;
 65 # include &lt;stdlib.h&gt;
 66 # include &lt;stdio.h&gt;
 67 # include &lt;unistd.h&gt;
 68 # include &lt;sys/resource.h&gt;
 69 # include &lt;pthread.h&gt;
</pre>
<hr />
<pre>
348              }
349              thread-&gt;osthread()-&gt;clear_expanding_stack();
350           } else {
351              fatal(&quot;recursive segv. expanding stack.&quot;);
352           }
353         }
354       }
355     }
356 
357     if (thread-&gt;thread_state() == _thread_in_Java) {
358       // Java thread running in Java code =&gt; find exception handler if any
359       // a fault inside compiled code, the interpreter, or a stub
360 
361       // Handle signal from NativeJump::patch_verified_entry().
362       if ((sig == SIGILL || sig == SIGTRAP)
363           &amp;&amp; nativeInstruction_at(pc)-&gt;is_sigill_zombie_not_entrant()) {
364         if (TraceTraps) {
365           tty-&gt;print_cr(&quot;trap: zombie_not_entrant (%s)&quot;, (sig == SIGTRAP) ? &quot;SIGTRAP&quot; : &quot;SIGILL&quot;);
366         }
367         stub = SharedRuntime::get_handle_wrong_method_stub();
<span class="line-modified">368       } else if (sig == SIGSEGV &amp;&amp; SafepointMechanism::is_poll_address((address)info-&gt;si_addr)) {</span>
369         stub = SharedRuntime::get_poll_stub(pc);
370       } else if (sig == SIGBUS /* &amp;&amp; info-&gt;si_code == BUS_OBJERR */) {
371         // BugId 4454115: A read from a MappedByteBuffer can fault
372         // here if the underlying file has been truncated.
373         // Do not crash the VM in such a case.
374         CodeBlob* cb = CodeCache::find_blob_unsafe(pc);
375         CompiledMethod* nm = (cb != NULL) ? cb-&gt;as_compiled_method_or_null() : NULL;
376         bool is_unsafe_arraycopy = (thread-&gt;doing_unsafe_access() &amp;&amp; UnsafeCopyMemory::contains_pc(pc));
377         if ((nm != NULL &amp;&amp; nm-&gt;has_unsafe_access()) || is_unsafe_arraycopy) {
378           address next_pc = pc + NativeCall::instruction_size;
379           if (is_unsafe_arraycopy) {
380             next_pc = UnsafeCopyMemory::page_error_continue_pc(pc);
381           }
382           stub = SharedRuntime::handle_unsafe_access(thread, next_pc);
383         }
384       }
385       else
386 
387       if (sig == SIGFPE  &amp;&amp;
388           (info-&gt;si_code == FPE_INTDIV || info-&gt;si_code == FPE_FLTDIV)) {
</pre>
<hr />
<pre>
445   sigemptyset(&amp;newset);
446   sigaddset(&amp;newset, sig);
447   sigprocmask(SIG_UNBLOCK, &amp;newset, NULL);
448 
449   VMError::report_and_die(t, sig, pc, info, ucVoid);
450 
451   ShouldNotReachHere();
452   return true; // Mute compiler
453 }
454 
455 void os::Linux::init_thread_fpu_state(void) {
456 }
457 
458 int os::Linux::get_fpu_control_word(void) {
459   return 0;
460 }
461 
462 void os::Linux::set_fpu_control_word(int fpu_control) {
463 }
464 






465 bool os::is_allocatable(size_t bytes) {
466   return true;
467 }
468 
469 ////////////////////////////////////////////////////////////////////////////////
470 // thread stack
471 
472 // Minimum usable stack sizes required to get to user code. Space for
473 // HotSpot guard pages is added later.
474 size_t os::Posix::_compiler_thread_min_stack_allowed = 72 * K;
475 size_t os::Posix::_java_thread_min_stack_allowed = 72 * K;
476 size_t os::Posix::_vm_internal_thread_min_stack_allowed = 72 * K;
477 
478 // return default stack size for thr_type
479 size_t os::Posix::default_stack_size(os::ThreadType thr_type) {
480   // default stack size (compiler thread needs larger stack)
481   size_t s = (thr_type == os::compiler_thread ? 4 * M : 1 * M);
482   return s;
483 }
484 
</pre>
</td>
</tr>
</table>
<center><a href="../bsd_x86/os_bsd_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os_linux_aarch64.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
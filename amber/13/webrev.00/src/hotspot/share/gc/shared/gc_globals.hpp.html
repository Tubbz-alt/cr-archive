<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/gc/shared/gc_globals.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHARED_GC_GLOBALS_HPP
 26 #define SHARE_GC_SHARED_GC_GLOBALS_HPP
 27 
 28 #include &quot;runtime/globals_shared.hpp&quot;
 29 #include &quot;utilities/macros.hpp&quot;
 30 #if INCLUDE_EPSILONGC
 31 #include &quot;gc/epsilon/epsilon_globals.hpp&quot;
 32 #endif
 33 #if INCLUDE_G1GC
 34 #include &quot;gc/g1/g1_globals.hpp&quot;
 35 #endif
 36 #if INCLUDE_PARALLELGC
 37 #include &quot;gc/parallel/parallel_globals.hpp&quot;
 38 #endif
 39 #if INCLUDE_SERIALGC
 40 #include &quot;gc/serial/serial_globals.hpp&quot;
 41 #endif
 42 #if INCLUDE_SHENANDOAHGC
 43 #include &quot;gc/shenandoah/shenandoah_globals.hpp&quot;
 44 #endif
 45 #if INCLUDE_ZGC
 46 #include &quot;gc/z/z_globals.hpp&quot;
 47 #endif
 48 
 49 #define GC_FLAGS(develop,                                                   \
 50                  develop_pd,                                                \
 51                  product,                                                   \
 52                  product_pd,                                                \
 53                  diagnostic,                                                \
 54                  diagnostic_pd,                                             \
 55                  experimental,                                              \
 56                  notproduct,                                                \
 57                  manageable,                                                \
 58                  product_rw,                                                \
 59                  lp64_product,                                              \
 60                  range,                                                     \
 61                  constraint)                                                \
 62                                                                             \
 63   EPSILONGC_ONLY(GC_EPSILON_FLAGS(                                          \
 64     develop,                                                                \
 65     develop_pd,                                                             \
 66     product,                                                                \
 67     product_pd,                                                             \
 68     diagnostic,                                                             \
 69     diagnostic_pd,                                                          \
 70     experimental,                                                           \
 71     notproduct,                                                             \
 72     manageable,                                                             \
 73     product_rw,                                                             \
 74     lp64_product,                                                           \
 75     range,                                                                  \
 76     constraint))                                                            \
 77                                                                             \
 78   G1GC_ONLY(GC_G1_FLAGS(                                                    \
 79     develop,                                                                \
 80     develop_pd,                                                             \
 81     product,                                                                \
 82     product_pd,                                                             \
 83     diagnostic,                                                             \
 84     diagnostic_pd,                                                          \
 85     experimental,                                                           \
 86     notproduct,                                                             \
 87     manageable,                                                             \
 88     product_rw,                                                             \
 89     lp64_product,                                                           \
 90     range,                                                                  \
 91     constraint))                                                            \
 92                                                                             \
 93   PARALLELGC_ONLY(GC_PARALLEL_FLAGS(                                        \
 94     develop,                                                                \
 95     develop_pd,                                                             \
 96     product,                                                                \
 97     product_pd,                                                             \
 98     diagnostic,                                                             \
 99     diagnostic_pd,                                                          \
100     experimental,                                                           \
101     notproduct,                                                             \
102     manageable,                                                             \
103     product_rw,                                                             \
104     lp64_product,                                                           \
105     range,                                                                  \
106     constraint))                                                            \
107                                                                             \
108   SERIALGC_ONLY(GC_SERIAL_FLAGS(                                            \
109     develop,                                                                \
110     develop_pd,                                                             \
111     product,                                                                \
112     product_pd,                                                             \
113     diagnostic,                                                             \
114     diagnostic_pd,                                                          \
115     experimental,                                                           \
116     notproduct,                                                             \
117     manageable,                                                             \
118     product_rw,                                                             \
119     lp64_product,                                                           \
120     range,                                                                  \
121     constraint))                                                            \
122                                                                             \
123   SHENANDOAHGC_ONLY(GC_SHENANDOAH_FLAGS(                                    \
124     develop,                                                                \
125     develop_pd,                                                             \
126     product,                                                                \
127     product_pd,                                                             \
128     diagnostic,                                                             \
129     diagnostic_pd,                                                          \
130     experimental,                                                           \
131     notproduct,                                                             \
132     manageable,                                                             \
133     product_rw,                                                             \
134     lp64_product,                                                           \
135     range,                                                                  \
136     constraint))                                                            \
137                                                                             \
138   ZGC_ONLY(GC_Z_FLAGS(                                                      \
139     develop,                                                                \
140     develop_pd,                                                             \
141     product,                                                                \
142     product_pd,                                                             \
143     diagnostic,                                                             \
144     diagnostic_pd,                                                          \
145     experimental,                                                           \
146     notproduct,                                                             \
147     manageable,                                                             \
148     product_rw,                                                             \
149     lp64_product,                                                           \
150     range,                                                                  \
151     constraint))                                                            \
152                                                                             \
153   /* gc */                                                                  \
154                                                                             \
155   product(bool, UseSerialGC, false,                                         \
156           &quot;Use the Serial garbage collector&quot;)                               \
157                                                                             \
158   product(bool, UseG1GC, false,                                             \
159           &quot;Use the Garbage-First garbage collector&quot;)                        \
160                                                                             \
161   product(bool, UseParallelGC, false,                                       \
162           &quot;Use the Parallel garbage collector.&quot;)                            \
163                                                                             \
164   experimental(bool, UseEpsilonGC, false,                                   \
165           &quot;Use the Epsilon (no-op) garbage collector&quot;)                      \
166                                                                             \
167   product(bool, UseZGC, false,                                              \
168           &quot;Use the Z garbage collector&quot;)                                    \
169                                                                             \
170   experimental(bool, UseShenandoahGC, false,                                \
171           &quot;Use the Shenandoah garbage collector&quot;)                           \
172                                                                             \
173   product(uint, ParallelGCThreads, 0,                                       \
174           &quot;Number of parallel threads parallel gc will use&quot;)                \
175           constraint(ParallelGCThreadsConstraintFunc,AfterErgo)             \
176                                                                             \
177   diagnostic(bool, UseSemaphoreGCThreadsSynchronization, true,              \
178             &quot;Use semaphore synchronization for the GC Threads, &quot;            \
179             &quot;instead of synchronization based on mutexes&quot;)                  \
180                                                                             \
181   product(bool, UseDynamicNumberOfGCThreads, true,                          \
182           &quot;Dynamically choose the number of threads up to a maximum of &quot;    \
183           &quot;ParallelGCThreads parallel collectors will use for garbage &quot;     \
184           &quot;collection work&quot;)                                                \
185                                                                             \
186   diagnostic(bool, InjectGCWorkerCreationFailure, false,                    \
187              &quot;Inject thread creation failures for &quot;                         \
188              &quot;UseDynamicNumberOfGCThreads&quot;)                                 \
189                                                                             \
190   product(size_t, HeapSizePerGCThread, ScaleForWordSize(32*M),              \
191           &quot;Size of heap (bytes) per GC thread used in calculating the &quot;     \
192           &quot;number of GC threads&quot;)                                           \
193           range((size_t)os::vm_page_size(), (size_t)max_uintx)              \
194                                                                             \
195   product(uint, ConcGCThreads, 0,                                           \
196           &quot;Number of threads concurrent gc will use&quot;)                       \
197           constraint(ConcGCThreadsConstraintFunc,AfterErgo)                 \
198                                                                             \
199   product(bool, AlwaysTenure, false,                                        \
200           &quot;Always tenure objects in eden (ParallelGC only)&quot;)                \
201                                                                             \
202   product(bool, NeverTenure, false,                                         \
203           &quot;Never tenure objects in eden, may tenure on overflow &quot;           \
204           &quot;(ParallelGC only)&quot;)                                              \
205                                                                             \
206   product(bool, ScavengeBeforeFullGC, true,                                 \
207           &quot;Scavenge youngest generation before each full GC.&quot;)              \
208                                                                             \
209   product(bool, ExplicitGCInvokesConcurrent, false,                         \
210           &quot;A System.gc() request invokes a concurrent collection; &quot;         \
211           &quot;(effective only when using concurrent collectors)&quot;)              \
212                                                                             \
213   product(uintx, GCLockerEdenExpansionPercent, 5,                           \
214           &quot;How much the GC can expand the eden by while the GC locker &quot;     \
215           &quot;is active (as a percentage)&quot;)                                    \
216           range(0, 100)                                                     \
217                                                                             \
218   diagnostic(uintx, GCLockerRetryAllocationCount, 2,                        \
219           &quot;Number of times to retry allocations when &quot;                      \
220           &quot;blocked by the GC locker&quot;)                                       \
221           range(0, max_uintx)                                               \
222                                                                             \
223   product(uintx, ParallelGCBufferWastePct, 10,                              \
224           &quot;Wasted fraction of parallel allocation buffer&quot;)                  \
225           range(0, 100)                                                     \
226                                                                             \
227   product(uintx, TargetPLABWastePct, 10,                                    \
228           &quot;Target wasted space in last buffer as percent of overall &quot;       \
229           &quot;allocation&quot;)                                                     \
230           range(1, 100)                                                     \
231                                                                             \
232   product(uintx, PLABWeight, 75,                                            \
233           &quot;Percentage (0-100) used to weight the current sample when &quot;      \
234           &quot;computing exponentially decaying average for ResizePLAB&quot;)        \
235           range(0, 100)                                                     \
236                                                                             \
237   product(bool, ResizePLAB, true,                                           \
238           &quot;Dynamically resize (survivor space) promotion LAB&#39;s&quot;)            \
239                                                                             \
240   product(int, ParGCArrayScanChunk, 50,                                     \
241           &quot;Scan a subset of object array and push remainder, if array is &quot;  \
242           &quot;bigger than this&quot;)                                               \
243           range(1, max_jint/3)                                              \
244                                                                             \
245                                                                             \
246   product(bool, AlwaysPreTouch, false,                                      \
247           &quot;Force all freshly committed pages to be pre-touched&quot;)            \
248                                                                             \
249   product(size_t, PreTouchParallelChunkSize, 1 * G,                         \
250           &quot;Per-thread chunk size for parallel memory pre-touch.&quot;)           \
251           range(1, SIZE_MAX / 2)                                            \
252                                                                             \
253   /* where does the range max value of (max_jint - 1) come from? */         \
254   product(size_t, MarkStackSizeMax, NOT_LP64(4*M) LP64_ONLY(512*M),         \
255           &quot;Maximum size of marking stack&quot;)                                  \
256           range(1, (max_jint - 1))                                          \
257                                                                             \
258   product(size_t, MarkStackSize, NOT_LP64(32*K) LP64_ONLY(4*M),             \
259           &quot;Size of marking stack&quot;)                                          \
260           constraint(MarkStackSizeConstraintFunc,AfterErgo)                 \
261           range(1, (max_jint - 1))                                          \
262                                                                             \
263   product(intx, RefDiscoveryPolicy, 0,                                      \
264           &quot;Select type of reference discovery policy: &quot;                     \
265           &quot;reference-based(0) or referent-based(1)&quot;)                        \
266           range(ReferenceProcessor::DiscoveryPolicyMin,                     \
267                 ReferenceProcessor::DiscoveryPolicyMax)                     \
268                                                                             \
269   product(bool, ParallelRefProcEnabled, false,                              \
270           &quot;Enable parallel reference processing whenever possible&quot;)         \
271                                                                             \
272   product(bool, ParallelRefProcBalancingEnabled, true,                      \
273           &quot;Enable balancing of reference processing queues&quot;)                \
274                                                                             \
275   experimental(size_t, ReferencesPerThread, 1000,                           \
276                &quot;Ergonomically start one thread for this amount of &quot;         \
277                &quot;references for reference processing if &quot;                    \
278                &quot;ParallelRefProcEnabled is true. Specify 0 to disable and &quot;  \
279                &quot;use all threads.&quot;)                                          \
280                                                                             \
281   product(uintx, InitiatingHeapOccupancyPercent, 45,                        \
282           &quot;The percent occupancy (IHOP) of the current old generation &quot;     \
283           &quot;capacity above which a concurrent mark cycle will be initiated &quot; \
284           &quot;Its value may change over time if adaptive IHOP is enabled, &quot;    \
285           &quot;otherwise the value remains constant. &quot;                          \
286           &quot;In the latter case a value of 0 will result as frequent as &quot;     \
287           &quot;possible concurrent marking cycles. A value of 100 disables &quot;    \
288           &quot;concurrent marking. &quot;                                            \
289           &quot;Fragmentation waste in the old generation is not considered &quot;    \
290           &quot;free space in this calculation. (G1 collector only)&quot;)            \
291           range(0, 100)                                                     \
292                                                                             \
293   notproduct(bool, ScavengeALot, false,                                     \
294           &quot;Force scavenge at every Nth exit from the runtime system &quot;       \
295           &quot;(N=ScavengeALotInterval)&quot;)                                       \
296                                                                             \
297   develop(bool, FullGCALot, false,                                          \
298           &quot;Force full gc at every Nth exit from the runtime system &quot;        \
299           &quot;(N=FullGCALotInterval)&quot;)                                         \
300                                                                             \
301   notproduct(bool, GCALotAtAllSafepoints, false,                            \
302           &quot;Enforce ScavengeALot/GCALot at all potential safepoints&quot;)        \
303                                                                             \
304   notproduct(bool, PromotionFailureALot, false,                             \
305           &quot;Use promotion failure handling on every youngest generation &quot;    \
306           &quot;collection&quot;)                                                     \
307                                                                             \
308   develop(uintx, PromotionFailureALotCount, 1000,                           \
309           &quot;Number of promotion failures occurring at PLAB promotion &quot;       \
310           &quot;attempts at young collectors&quot;)                                   \
311                                                                             \
312   develop(uintx, PromotionFailureALotInterval, 5,                           \
313           &quot;Total collections between promotion failures a lot&quot;)             \
314                                                                             \
315   experimental(uintx, WorkStealingSleepMillis, 1,                           \
316           &quot;Sleep time when sleep is used for yields&quot;)                       \
317                                                                             \
318   experimental(uintx, WorkStealingYieldsBeforeSleep, 5000,                  \
319           &quot;Number of yields before a sleep is done during work stealing&quot;)   \
320                                                                             \
321   experimental(uintx, WorkStealingHardSpins, 4096,                          \
322           &quot;Number of iterations in a spin loop between checks on &quot;          \
323           &quot;time out of hard spin&quot;)                                          \
324                                                                             \
325   experimental(uintx, WorkStealingSpinToYieldRatio, 10,                     \
326           &quot;Ratio of hard spins to calls to yield&quot;)                          \
327                                                                             \
328   develop(uintx, ObjArrayMarkingStride, 2048,                               \
329           &quot;Number of object array elements to push onto the marking stack &quot; \
330           &quot;before pushing a continuation entry&quot;)                            \
331                                                                             \
332   develop(bool, MetadataAllocationFailALot, false,                          \
333           &quot;Fail metadata allocations at intervals controlled by &quot;           \
334           &quot;MetadataAllocationFailALotInterval&quot;)                             \
335                                                                             \
336   develop(uintx, MetadataAllocationFailALotInterval, 1000,                  \
337           &quot;Metadata allocation failure a lot interval&quot;)                     \
338                                                                             \
339   product(bool, ExecutingUnitTests, false,                                  \
340           &quot;Whether the JVM is running unit tests or not&quot;)                   \
341                                                                             \
342   product_pd(bool, UseTLAB, &quot;Use thread-local object allocation&quot;)           \
343                                                                             \
344   product_pd(bool, ResizeTLAB,                                              \
345           &quot;Dynamically resize TLAB size for threads&quot;)                       \
346                                                                             \
347   product(bool, ZeroTLAB, false,                                            \
348           &quot;Zero out the newly created TLAB&quot;)                                \
349                                                                             \
350   product(bool, TLABStats, true,                                            \
351           &quot;Provide more detailed and expensive TLAB statistics.&quot;)           \
352                                                                             \
353   product_pd(bool, NeverActAsServerClassMachine,                            \
354           &quot;Never act like a server-class machine&quot;)                          \
355                                                                             \
356   product(bool, AlwaysActAsServerClassMachine, false,                       \
357           &quot;Always act like a server-class machine&quot;)                         \
358                                                                             \
359   product_pd(uint64_t, MaxRAM,                                              \
360           &quot;Real memory size (in bytes) used to set maximum heap size&quot;)      \
361           range(0, 0XFFFFFFFFFFFFFFFF)                                      \
362                                                                             \
363   product(bool, AggressiveHeap, false,                                      \
364           &quot;Optimize heap options for long-running memory intensive apps&quot;)   \
365                                                                             \
366   product(size_t, ErgoHeapSizeLimit, 0,                                     \
367           &quot;Maximum ergonomically set heap size (in bytes); zero means use &quot; \
368           &quot;MaxRAM * MaxRAMPercentage / 100&quot;)                                \
369           range(0, max_uintx)                                               \
370                                                                             \
371   product(uintx, MaxRAMFraction, 4,                                         \
372           &quot;Maximum fraction (1/n) of real memory used for maximum heap &quot;    \
373           &quot;size. &quot;                                                          \
374           &quot;Deprecated, use MaxRAMPercentage instead&quot;)                       \
375           range(1, max_uintx)                                               \
376                                                                             \
377   product(uintx, MinRAMFraction, 2,                                         \
378           &quot;Minimum fraction (1/n) of real memory used for maximum heap &quot;    \
379           &quot;size on systems with small physical memory size. &quot;               \
380           &quot;Deprecated, use MinRAMPercentage instead&quot;)                       \
381           range(1, max_uintx)                                               \
382                                                                             \
383   product(uintx, InitialRAMFraction, 64,                                    \
384           &quot;Fraction (1/n) of real memory used for initial heap size. &quot;      \
385           &quot;Deprecated, use InitialRAMPercentage instead&quot;)                   \
386           range(1, max_uintx)                                               \
387                                                                             \
388   product(double, MaxRAMPercentage, 25.0,                                   \
389           &quot;Maximum percentage of real memory used for maximum heap size&quot;)   \
390           range(0.0, 100.0)                                                 \
391                                                                             \
392   product(double, MinRAMPercentage, 50.0,                                   \
393           &quot;Minimum percentage of real memory used for maximum heap&quot;         \
394           &quot;size on systems with small physical memory size&quot;)                \
395           range(0.0, 100.0)                                                 \
396                                                                             \
397   product(double, InitialRAMPercentage, 1.5625,                             \
398           &quot;Percentage of real memory used for initial heap size&quot;)           \
399           range(0.0, 100.0)                                                 \
400                                                                             \
401   product(int, ActiveProcessorCount, -1,                                    \
402           &quot;Specify the CPU count the VM should use and report as active&quot;)   \
403                                                                             \
404   develop(uintx, MaxVirtMemFraction, 2,                                     \
405           &quot;Maximum fraction (1/n) of virtual memory used for ergonomically &quot;\
406           &quot;determining maximum heap size&quot;)                                  \
407                                                                             \
408   product(bool, UseAdaptiveSizePolicy, true,                                \
409           &quot;Use adaptive generation sizing policies&quot;)                        \
410                                                                             \
411   product(bool, UsePSAdaptiveSurvivorSizePolicy, true,                      \
412           &quot;Use adaptive survivor sizing policies&quot;)                          \
413                                                                             \
414   product(bool, UseAdaptiveGenerationSizePolicyAtMinorCollection, true,     \
415           &quot;Use adaptive young-old sizing policies at minor collections&quot;)    \
416                                                                             \
417   product(bool, UseAdaptiveGenerationSizePolicyAtMajorCollection, true,     \
418           &quot;Use adaptive young-old sizing policies at major collections&quot;)    \
419                                                                             \
420   product(bool, UseAdaptiveSizePolicyWithSystemGC, false,                   \
421           &quot;Include statistics from System.gc() for adaptive size policy&quot;)   \
422                                                                             \
423   product(bool, UseAdaptiveGCBoundary, false,                               \
424           &quot;Allow young-old boundary to move&quot;)                               \
425                                                                             \
426   develop(intx, PSAdaptiveSizePolicyResizeVirtualSpaceAlot, -1,             \
427           &quot;Resize the virtual spaces of the young or old generations&quot;)      \
428           range(-1, 1)                                                      \
429                                                                             \
430   product(uintx, AdaptiveSizeThroughPutPolicy, 0,                           \
431           &quot;Policy for changing generation size for throughput goals&quot;)       \
432           range(0, 1)                                                       \
433                                                                             \
434   product(uintx, AdaptiveSizePolicyInitializingSteps, 20,                   \
435           &quot;Number of steps where heuristics is used before data is used&quot;)   \
436           range(0, max_uintx)                                               \
437                                                                             \
438   develop(uintx, AdaptiveSizePolicyReadyThreshold, 5,                       \
439           &quot;Number of collections before the adaptive sizing is started&quot;)    \
440                                                                             \
441   product(uintx, AdaptiveSizePolicyOutputInterval, 0,                       \
442           &quot;Collection interval for printing information; zero means never&quot;) \
443           range(0, max_uintx)                                               \
444                                                                             \
445   product(bool, UseAdaptiveSizePolicyFootprintGoal, true,                   \
446           &quot;Use adaptive minimum footprint as a goal&quot;)                       \
447                                                                             \
448   product(uintx, AdaptiveSizePolicyWeight, 10,                              \
449           &quot;Weight given to exponential resizing, between 0 and 100&quot;)        \
450           range(0, 100)                                                     \
451                                                                             \
452   product(uintx, AdaptiveTimeWeight,       25,                              \
453           &quot;Weight given to time in adaptive policy, between 0 and 100&quot;)     \
454           range(0, 100)                                                     \
455                                                                             \
456   product(uintx, PausePadding, 1,                                           \
457           &quot;How much buffer to keep for pause time&quot;)                         \
458           range(0, max_juint)                                               \
459                                                                             \
460   product(uintx, PromotedPadding, 3,                                        \
461           &quot;How much buffer to keep for promotion failure&quot;)                  \
462           range(0, max_juint)                                               \
463                                                                             \
464   product(uintx, SurvivorPadding, 3,                                        \
465           &quot;How much buffer to keep for survivor overflow&quot;)                  \
466           range(0, max_juint)                                               \
467                                                                             \
468   product(uintx, ThresholdTolerance, 10,                                    \
469           &quot;Allowed collection cost difference between generations&quot;)         \
470           range(0, 100)                                                     \
471                                                                             \
472   product(uintx, AdaptiveSizePolicyCollectionCostMargin, 50,                \
473           &quot;If collection costs are within margin, reduce both by full &quot;     \
474           &quot;delta&quot;)                                                          \
475           range(0, 100)                                                     \
476                                                                             \
477   product(uintx, YoungGenerationSizeIncrement, 20,                          \
478           &quot;Adaptive size percentage change in young generation&quot;)            \
479           range(0, 100)                                                     \
480                                                                             \
481   product(uintx, YoungGenerationSizeSupplement, 80,                         \
482           &quot;Supplement to YoungedGenerationSizeIncrement used at startup&quot;)   \
483           range(0, 100)                                                     \
484                                                                             \
485   product(uintx, YoungGenerationSizeSupplementDecay, 8,                     \
486           &quot;Decay factor to YoungedGenerationSizeSupplement&quot;)                \
487           range(1, max_uintx)                                               \
488                                                                             \
489   product(uintx, TenuredGenerationSizeIncrement, 20,                        \
490           &quot;Adaptive size percentage change in tenured generation&quot;)          \
491           range(0, 100)                                                     \
492                                                                             \
493   product(uintx, TenuredGenerationSizeSupplement, 80,                       \
494           &quot;Supplement to TenuredGenerationSizeIncrement used at startup&quot;)   \
495           range(0, 100)                                                     \
496                                                                             \
497   product(uintx, TenuredGenerationSizeSupplementDecay, 2,                   \
498           &quot;Decay factor to TenuredGenerationSizeIncrement&quot;)                 \
499           range(1, max_uintx)                                               \
500                                                                             \
501   product(uintx, MaxGCPauseMillis, max_uintx - 1,                           \
502           &quot;Adaptive size policy maximum GC pause time goal in millisecond, &quot;\
503           &quot;or (G1 Only) the maximum GC time per MMU time slice&quot;)            \
504           range(1, max_uintx - 1)                                           \
505           constraint(MaxGCPauseMillisConstraintFunc,AfterErgo)              \
506                                                                             \
507   product(uintx, GCPauseIntervalMillis, 0,                                  \
508           &quot;Time slice for MMU specification&quot;)                               \
509           constraint(GCPauseIntervalMillisConstraintFunc,AfterErgo)         \
510                                                                             \
511   product(uintx, MaxGCMinorPauseMillis, max_uintx,                          \
512           &quot;Adaptive size policy maximum GC minor pause time goal &quot;          \
513           &quot;in millisecond&quot;)                                                 \
514           range(0, max_uintx)                                               \
515                                                                             \
516   product(uintx, GCTimeRatio, 99,                                           \
517           &quot;Adaptive size policy application time to GC time ratio&quot;)         \
518           range(0, max_juint)                                               \
519                                                                             \
520   product(uintx, AdaptiveSizeDecrementScaleFactor, 4,                       \
521           &quot;Adaptive size scale down factor for shrinking&quot;)                  \
522           range(1, max_uintx)                                               \
523                                                                             \
524   product(bool, UseAdaptiveSizeDecayMajorGCCost, true,                      \
525           &quot;Adaptive size decays the major cost for long major intervals&quot;)   \
526                                                                             \
527   product(uintx, AdaptiveSizeMajorGCDecayTimeScale, 10,                     \
528           &quot;Time scale over which major costs decay&quot;)                        \
529           range(0, max_uintx)                                               \
530                                                                             \
531   product(uintx, MinSurvivorRatio, 3,                                       \
532           &quot;Minimum ratio of young generation/survivor space size&quot;)          \
533           range(3, max_uintx)                                               \
534                                                                             \
535   product(uintx, InitialSurvivorRatio, 8,                                   \
536           &quot;Initial ratio of young generation/survivor space size&quot;)          \
537           range(0, max_uintx)                                               \
538                                                                             \
539   product(size_t, BaseFootPrintEstimate, 256*M,                             \
540           &quot;Estimate of footprint other than Java Heap&quot;)                     \
541           range(0, max_uintx)                                               \
542                                                                             \
543   product(bool, UseGCOverheadLimit, true,                                   \
544           &quot;Use policy to limit of proportion of time spent in GC &quot;          \
545           &quot;before an OutOfMemory error is thrown&quot;)                          \
546                                                                             \
547   product(uintx, GCTimeLimit, 98,                                           \
548           &quot;Limit of the proportion of time spent in GC before &quot;             \
549           &quot;an OutOfMemoryError is thrown (used with GCHeapFreeLimit)&quot;)      \
550           range(0, 100)                                                     \
551                                                                             \
552   product(uintx, GCHeapFreeLimit, 2,                                        \
553           &quot;Minimum percentage of free space after a full GC before an &quot;     \
554           &quot;OutOfMemoryError is thrown (used with GCTimeLimit)&quot;)             \
555           range(0, 100)                                                     \
556                                                                             \
557   develop(uintx, GCOverheadLimitThreshold, 5,                               \
558           &quot;Number of consecutive collections before gc time limit fires&quot;)   \
559           range(1, max_uintx)                                               \
560                                                                             \
561   product(intx, PrefetchCopyIntervalInBytes, -1,                            \
562           &quot;How far ahead to prefetch destination area (&lt;= 0 means off)&quot;)    \
563           range(-1, max_jint)                                               \
564                                                                             \
565   product(intx, PrefetchScanIntervalInBytes, -1,                            \
566           &quot;How far ahead to prefetch scan area (&lt;= 0 means off)&quot;)           \
567           range(-1, max_jint)                                               \
568                                                                             \
569   product(intx, PrefetchFieldsAhead, -1,                                    \
570           &quot;How many fields ahead to prefetch in oop scan (&lt;= 0 means off)&quot;) \
571           range(-1, max_jint)                                               \
572                                                                             \
573   diagnostic(bool, VerifyDuringStartup, false,                              \
574           &quot;Verify memory system before executing any Java code &quot;            \
575           &quot;during VM initialization&quot;)                                       \
576                                                                             \
577   diagnostic(bool, VerifyBeforeExit, trueInDebug,                           \
578           &quot;Verify system before exiting&quot;)                                   \
579                                                                             \
580   diagnostic(bool, VerifyBeforeGC, false,                                   \
581           &quot;Verify memory system before GC&quot;)                                 \
582                                                                             \
583   diagnostic(bool, VerifyAfterGC, false,                                    \
584           &quot;Verify memory system after GC&quot;)                                  \
585                                                                             \
586   diagnostic(bool, VerifyDuringGC, false,                                   \
587           &quot;Verify memory system during GC (between phases)&quot;)                \
588                                                                             \
589   diagnostic(ccstrlist, VerifyGCType, &quot;&quot;,                                   \
590              &quot;GC type(s) to verify when Verify*GC is enabled.&quot;              \
591              &quot;Available types are collector specific.&quot;)                     \
592                                                                             \
593   diagnostic(ccstrlist, VerifySubSet, &quot;&quot;,                                   \
594           &quot;Memory sub-systems to verify when Verify*GC flag(s) &quot;            \
595           &quot;are enabled. One or more sub-systems can be specified &quot;          \
596           &quot;in a comma separated string. Sub-systems are: &quot;                  \
597           &quot;threads, heap, symbol_table, string_table, codecache, &quot;          \
598           &quot;dictionary, classloader_data_graph, metaspace, jni_handles, &quot;    \
599           &quot;codecache_oops&quot;)                                                 \
600                                                                             \
601   diagnostic(bool, GCParallelVerificationEnabled, true,                     \
602           &quot;Enable parallel memory system verification&quot;)                     \
603                                                                             \
604   diagnostic(bool, DeferInitialCardMark, false,                             \
605           &quot;When +ReduceInitialCardMarks, explicitly defer any that &quot;        \
606           &quot;may arise from new_pre_store_barrier&quot;)                           \
607                                                                             \
608   product(bool, UseCondCardMark, false,                                     \
609           &quot;Check for already marked card before updating card table&quot;)       \
610                                                                             \
611   diagnostic(bool, VerifyRememberedSets, false,                             \
612           &quot;Verify GC remembered sets&quot;)                                      \
613                                                                             \
614   diagnostic(bool, VerifyObjectStartArray, true,                            \
615           &quot;Verify GC object start array if verify before/after&quot;)            \
616                                                                             \
617   product(bool, DisableExplicitGC, false,                                   \
618           &quot;Ignore calls to System.gc()&quot;)                                    \
619                                                                             \
620   product(bool, PrintGC, false,                                             \
621           &quot;Print message at garbage collection. &quot;                           \
622           &quot;Deprecated, use -Xlog:gc instead.&quot;)                              \
623                                                                             \
624   product(bool, PrintGCDetails, false,                                      \
625           &quot;Print more details at garbage collection. &quot;                      \
626           &quot;Deprecated, use -Xlog:gc* instead.&quot;)                             \
627                                                                             \
628   develop(intx, ConcGCYieldTimeout, 0,                                      \
629           &quot;If non-zero, assert that GC threads yield within this &quot;          \
630           &quot;number of milliseconds&quot;)                                         \
631           range(0, max_intx)                                                \
632                                                                             \
633   notproduct(intx, ScavengeALotInterval,     1,                             \
634           &quot;Interval between which scavenge will occur with +ScavengeALot&quot;)  \
635                                                                             \
636   notproduct(intx, FullGCALotInterval,     1,                               \
637           &quot;Interval between which full gc will occur with +FullGCALot&quot;)     \
638                                                                             \
639   notproduct(intx, FullGCALotStart,     0,                                  \
640           &quot;For which invocation to start FullGCAlot&quot;)                       \
641                                                                             \
642   notproduct(intx, FullGCALotDummies,  32*K,                                \
643           &quot;Dummy object allocated with +FullGCALot, forcing all objects &quot;   \
644           &quot;to move&quot;)                                                        \
645                                                                             \
646   /* gc parameters */                                                       \
647   product(size_t, MinHeapSize, 0,                                           \
648           &quot;Minimum heap size (in bytes); zero means use ergonomics&quot;)        \
649           constraint(MinHeapSizeConstraintFunc,AfterErgo)                   \
650                                                                             \
651   product(size_t, InitialHeapSize, 0,                                       \
652           &quot;Initial heap size (in bytes); zero means use ergonomics&quot;)        \
653           constraint(InitialHeapSizeConstraintFunc,AfterErgo)               \
654                                                                             \
655   product(size_t, MaxHeapSize, ScaleForWordSize(96*M),                      \
656           &quot;Maximum heap size (in bytes)&quot;)                                   \
657           constraint(MaxHeapSizeConstraintFunc,AfterErgo)                   \
658                                                                             \
659   manageable(size_t, SoftMaxHeapSize, 0,                                    \
660           &quot;Soft limit for maximum heap size (in bytes)&quot;)                    \
661           constraint(SoftMaxHeapSizeConstraintFunc,AfterMemoryInit)         \
662                                                                             \
663   product(size_t, OldSize, ScaleForWordSize(4*M),                           \
664           &quot;Initial tenured generation size (in bytes)&quot;)                     \
665           range(0, max_uintx)                                               \
666                                                                             \
667   product(size_t, NewSize, ScaleForWordSize(1*M),                           \
668           &quot;Initial new generation size (in bytes)&quot;)                         \
669           constraint(NewSizeConstraintFunc,AfterErgo)                       \
670                                                                             \
671   product(size_t, MaxNewSize, max_uintx,                                    \
672           &quot;Maximum new generation size (in bytes), max_uintx means set &quot;    \
673           &quot;ergonomically&quot;)                                                  \
674           range(0, max_uintx)                                               \
675                                                                             \
676   product_pd(size_t, HeapBaseMinAddress,                                    \
677           &quot;OS specific low limit for heap base address&quot;)                    \
678           constraint(HeapBaseMinAddressConstraintFunc,AfterErgo)            \
679                                                                             \
680   product(size_t, PretenureSizeThreshold, 0,                                \
681           &quot;Maximum size in bytes of objects allocated in DefNew &quot;           \
682           &quot;generation; zero means no maximum&quot;)                              \
683           range(0, max_uintx)                                               \
684                                                                             \
685   product(size_t, MinTLABSize, 2*K,                                         \
686           &quot;Minimum allowed TLAB size (in bytes)&quot;)                           \
687           range(1, max_uintx/2)                                             \
688           constraint(MinTLABSizeConstraintFunc,AfterMemoryInit)             \
689                                                                             \
690   product(size_t, TLABSize, 0,                                              \
691           &quot;Starting TLAB size (in bytes); zero means set ergonomically&quot;)    \
692           constraint(TLABSizeConstraintFunc,AfterMemoryInit)                \
693                                                                             \
694   product(size_t, YoungPLABSize, 4096,                                      \
695           &quot;Size of young gen promotion LAB&#39;s (in HeapWords)&quot;)               \
696           constraint(YoungPLABSizeConstraintFunc,AfterMemoryInit)           \
697                                                                             \
698   product(size_t, OldPLABSize, 1024,                                        \
699           &quot;Size of old gen promotion LAB&#39;s (in HeapWords)&quot;)                 \
700           constraint(OldPLABSizeConstraintFunc,AfterMemoryInit)             \
701                                                                             \
702   product(uintx, TLABAllocationWeight, 35,                                  \
703           &quot;Allocation averaging weight&quot;)                                    \
704           range(0, 100)                                                     \
705                                                                             \
706   /* Limit the lower bound of this flag to 1 as it is used  */              \
707   /* in a division expression.                              */              \
708   product(uintx, TLABWasteTargetPercent, 1,                                 \
709           &quot;Percentage of Eden that can be wasted&quot;)                          \
710           range(1, 100)                                                     \
711                                                                             \
712   product(uintx, TLABRefillWasteFraction,    64,                            \
713           &quot;Maximum TLAB waste at a refill (internal fragmentation)&quot;)        \
714           range(1, max_juint)                                               \
715                                                                             \
716   product(uintx, TLABWasteIncrement,    4,                                  \
717           &quot;Increment allowed waste at slow allocation&quot;)                     \
718           range(0, max_jint)                                                \
719           constraint(TLABWasteIncrementConstraintFunc,AfterMemoryInit)      \
720                                                                             \
721   product(uintx, SurvivorRatio, 8,                                          \
722           &quot;Ratio of eden/survivor space size&quot;)                              \
723           range(1, max_uintx-2)                                             \
724           constraint(SurvivorRatioConstraintFunc,AfterMemoryInit)           \
725                                                                             \
726   product(uintx, NewRatio, 2,                                               \
727           &quot;Ratio of old/new generation sizes&quot;)                              \
728           range(0, max_uintx-1)                                             \
729                                                                             \
730   product_pd(size_t, NewSizeThreadIncrease,                                 \
731           &quot;Additional size added to desired new generation size per &quot;       \
732           &quot;non-daemon thread (in bytes)&quot;)                                   \
733           range(0, max_uintx)                                               \
734                                                                             \
735   product(uintx, QueuedAllocationWarningCount, 0,                           \
736           &quot;Number of times an allocation that queues behind a GC &quot;          \
737           &quot;will retry before printing a warning&quot;)                           \
738           range(0, max_uintx)                                               \
739                                                                             \
740   diagnostic(uintx, VerifyGCStartAt,   0,                                   \
741           &quot;GC invoke count where +VerifyBefore/AfterGC kicks in&quot;)           \
742           range(0, max_uintx)                                               \
743                                                                             \
744   diagnostic(intx, VerifyGCLevel,     0,                                    \
745           &quot;Generation level at which to start +VerifyBefore/AfterGC&quot;)       \
746           range(0, 1)                                                       \
747                                                                             \
748   product(uintx, MaxTenuringThreshold,    15,                               \
749           &quot;Maximum value for tenuring threshold&quot;)                           \
750           range(0, markWord::max_age + 1)                                   \
751           constraint(MaxTenuringThresholdConstraintFunc,AfterErgo)          \
752                                                                             \
753   product(uintx, InitialTenuringThreshold,    7,                            \
754           &quot;Initial value for tenuring threshold&quot;)                           \
755           range(0, markWord::max_age + 1)                                   \
756           constraint(InitialTenuringThresholdConstraintFunc,AfterErgo)      \
757                                                                             \
758   product(uintx, TargetSurvivorRatio,    50,                                \
759           &quot;Desired percentage of survivor space used after scavenge&quot;)       \
760           range(0, 100)                                                     \
761                                                                             \
762   product(uintx, MarkSweepDeadRatio,     5,                                 \
763           &quot;Percentage (0-100) of the old gen allowed as dead wood. &quot;        \
764           &quot;Serial mark sweep treats this as both the minimum and maximum &quot;  \
765           &quot;value. &quot;                                                         \
766           &quot;Par compact uses a variable scale based on the density of the &quot;  \
767           &quot;generation and treats this as the maximum value when the heap &quot;  \
768           &quot;is either completely full or completely empty.  Par compact &quot;    \
769           &quot;also has a smaller default value; see arguments.cpp.&quot;)           \
770           range(0, 100)                                                     \
771                                                                             \
772   product(uint, MarkSweepAlwaysCompactCount,     4,                         \
773           &quot;How often should we fully compact the heap (ignoring the dead &quot;  \
774           &quot;space parameters)&quot;)                                              \
775           range(1, max_juint)                                               \
776                                                                             \
777   develop(uintx, GCExpandToAllocateDelayMillis, 0,                          \
778           &quot;Delay between expansion and allocation (in milliseconds)&quot;)       \
779                                                                             \
780   product(uintx, GCDrainStackTargetSize, 64,                                \
781           &quot;Number of entries we will try to leave on the stack &quot;            \
782           &quot;during parallel gc&quot;)                                             \
783           range(0, max_juint)
784 
785 #endif // SHARE_GC_SHARED_GC_GLOBALS_HPP
    </pre>
  </body>
</html>
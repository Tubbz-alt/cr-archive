<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/c2/shenandoahSupport.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahBarrierSetC2.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="shenandoahSupport.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/c2/shenandoahSupport.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 843 void ShenandoahBarrierC2Support::follow_barrier_uses(Node* n, Node* ctrl, Unique_Node_List&amp; uses, PhaseIdealLoop* phase) {
 844   for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
 845     Node* u = n-&gt;fast_out(i);
 846     if (!u-&gt;is_CFG() &amp;&amp; phase-&gt;get_ctrl(u) == ctrl &amp;&amp; (!u-&gt;is_Phi() || !u-&gt;in(0)-&gt;is_Loop() || u-&gt;in(LoopNode::LoopBackControl) != n)) {
 847       uses.push(u);
 848     }
 849   }
 850 }
 851 
 852 static void hide_strip_mined_loop(OuterStripMinedLoopNode* outer, CountedLoopNode* inner, PhaseIdealLoop* phase) {
 853   OuterStripMinedLoopEndNode* le = inner-&gt;outer_loop_end();
 854   Node* new_outer = new LoopNode(outer-&gt;in(LoopNode::EntryControl), outer-&gt;in(LoopNode::LoopBackControl));
 855   phase-&gt;register_control(new_outer, phase-&gt;get_loop(outer), outer-&gt;in(LoopNode::EntryControl));
 856   Node* new_le = new IfNode(le-&gt;in(0), le-&gt;in(1), le-&gt;_prob, le-&gt;_fcnt);
 857   phase-&gt;register_control(new_le, phase-&gt;get_loop(le), le-&gt;in(0));
 858   phase-&gt;lazy_replace(outer, new_outer);
 859   phase-&gt;lazy_replace(le, new_le);
 860   inner-&gt;clear_strip_mined();
 861 }
 862 
<span class="line-modified"> 863 void ShenandoahBarrierC2Support::test_heap_stable(Node*&amp; ctrl, Node* raw_mem, Node*&amp; heap_stable_ctrl,</span>
<span class="line-modified"> 864                                                   PhaseIdealLoop* phase) {</span>
 865   IdealLoopTree* loop = phase-&gt;get_loop(ctrl);
 866   Node* thread = new ThreadLocalNode();
 867   phase-&gt;register_new_node(thread, ctrl);
 868   Node* offset = phase-&gt;igvn().MakeConX(in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
 869   phase-&gt;set_ctrl(offset, phase-&gt;C-&gt;root());
 870   Node* gc_state_addr = new AddPNode(phase-&gt;C-&gt;top(), thread, offset);
 871   phase-&gt;register_new_node(gc_state_addr, ctrl);
 872   uint gc_state_idx = Compile::AliasIdxRaw;
 873   const TypePtr* gc_state_adr_type = NULL; // debug-mode-only argument
 874   debug_only(gc_state_adr_type = phase-&gt;C-&gt;get_adr_type(gc_state_idx));
 875 
 876   Node* gc_state = new LoadBNode(ctrl, raw_mem, gc_state_addr, gc_state_adr_type, TypeInt::BYTE, MemNode::unordered);
 877   phase-&gt;register_new_node(gc_state, ctrl);
<span class="line-modified"> 878   Node* heap_stable_and = new AndINode(gc_state, phase-&gt;igvn().intcon(ShenandoahHeap::HAS_FORWARDED));</span>
 879   phase-&gt;register_new_node(heap_stable_and, ctrl);
 880   Node* heap_stable_cmp = new CmpINode(heap_stable_and, phase-&gt;igvn().zerocon(T_INT));
 881   phase-&gt;register_new_node(heap_stable_cmp, ctrl);
 882   Node* heap_stable_test = new BoolNode(heap_stable_cmp, BoolTest::ne);
 883   phase-&gt;register_new_node(heap_stable_test, ctrl);
 884   IfNode* heap_stable_iff = new IfNode(ctrl, heap_stable_test, PROB_UNLIKELY(0.999), COUNT_UNKNOWN);
 885   phase-&gt;register_control(heap_stable_iff, loop, ctrl);
 886 
 887   heap_stable_ctrl = new IfFalseNode(heap_stable_iff);
 888   phase-&gt;register_control(heap_stable_ctrl, loop, heap_stable_iff);
 889   ctrl = new IfTrueNode(heap_stable_iff);
 890   phase-&gt;register_control(ctrl, loop, heap_stable_iff);
 891 
<span class="line-modified"> 892   assert(is_heap_stable_test(heap_stable_iff), &quot;Should match the shape&quot;);</span>
 893 }
 894 
 895 void ShenandoahBarrierC2Support::test_null(Node*&amp; ctrl, Node* val, Node*&amp; null_ctrl, PhaseIdealLoop* phase) {
 896   const Type* val_t = phase-&gt;igvn().type(val);
 897   if (val_t-&gt;meet(TypePtr::NULL_PTR) == val_t) {
 898     IdealLoopTree* loop = phase-&gt;get_loop(ctrl);
 899     Node* null_cmp = new CmpPNode(val, phase-&gt;igvn().zerocon(T_OBJECT));
 900     phase-&gt;register_new_node(null_cmp, ctrl);
 901     Node* null_test = new BoolNode(null_cmp, BoolTest::ne);
 902     phase-&gt;register_new_node(null_test, ctrl);
 903     IfNode* null_iff = new IfNode(ctrl, null_test, PROB_LIKELY(0.999), COUNT_UNKNOWN);
 904     phase-&gt;register_control(null_iff, loop, ctrl);
 905     ctrl = new IfTrueNode(null_iff);
 906     phase-&gt;register_control(ctrl, loop, null_iff);
 907     null_ctrl = new IfFalseNode(null_iff);
 908     phase-&gt;register_control(null_ctrl, loop, null_iff);
 909   }
 910 }
 911 
 912 Node* ShenandoahBarrierC2Support::clone_null_check(Node*&amp; c, Node* val, Node* unc_ctrl, PhaseIdealLoop* phase) {
</pre>
<hr />
<pre>
1127   ShenandoahBarrierSetC2State* state = ShenandoahBarrierSetC2::bsc2()-&gt;state();
1128 
1129   Unique_Node_List uses;
1130   for (int i = 0; i &lt; state-&gt;enqueue_barriers_count(); i++) {
1131     Node* barrier = state-&gt;enqueue_barrier(i);
1132     Node* ctrl = phase-&gt;get_ctrl(barrier);
1133     IdealLoopTree* loop = phase-&gt;get_loop(ctrl);
1134     if (loop-&gt;_head-&gt;is_OuterStripMinedLoop()) {
1135       // Expanding a barrier here will break loop strip mining
1136       // verification. Transform the loop so the loop nest doesn&#39;t
1137       // appear as strip mined.
1138       OuterStripMinedLoopNode* outer = loop-&gt;_head-&gt;as_OuterStripMinedLoop();
1139       hide_strip_mined_loop(outer, outer-&gt;unique_ctrl_out()-&gt;as_CountedLoop(), phase);
1140     }
1141   }
1142 
1143   Node_Stack stack(0);
1144   Node_List clones;
1145   for (int i = state-&gt;load_reference_barriers_count() - 1; i &gt;= 0; i--) {
1146     ShenandoahLoadReferenceBarrierNode* lrb = state-&gt;load_reference_barrier(i);
<span class="line-modified">1147     if (lrb-&gt;get_barrier_strength() == ShenandoahLoadReferenceBarrierNode::NONE) {</span>
1148       continue;
1149     }
1150 
1151     Node* ctrl = phase-&gt;get_ctrl(lrb);
1152     Node* val = lrb-&gt;in(ShenandoahLoadReferenceBarrierNode::ValueIn);
1153 
1154     CallStaticJavaNode* unc = NULL;
1155     Node* unc_ctrl = NULL;
1156     Node* uncasted_val = val;
1157 
1158     for (DUIterator_Fast imax, i = lrb-&gt;fast_outs(imax); i &lt; imax; i++) {
1159       Node* u = lrb-&gt;fast_out(i);
1160       if (u-&gt;Opcode() == Op_CastPP &amp;&amp;
1161           u-&gt;in(0) != NULL &amp;&amp;
1162           phase-&gt;is_dominator(u-&gt;in(0), ctrl)) {
1163         const Type* u_t = phase-&gt;igvn().type(u);
1164 
1165         if (u_t-&gt;meet(TypePtr::NULL_PTR) != u_t &amp;&amp;
1166             u-&gt;in(0)-&gt;Opcode() == Op_IfTrue &amp;&amp;
1167             u-&gt;in(0)-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none) &amp;&amp;
</pre>
<hr />
<pre>
1358                 int nb = u-&gt;replace_edge(n, create_phis_on_call_return(ctrl, c, n, n_clone, projs, phase));
1359                 assert(nb &gt; 0, &quot;should have replaced some uses&quot;);
1360                 replaced = true;
1361               }
1362             }
1363             if (!replaced) {
1364               stack.set_index(idx+1);
1365             }
1366           }
1367         } else {
1368           stack.pop();
1369           clones.pop();
1370         }
1371       } while (stack.size() &gt; 0);
1372       assert(stack.size() == 0 &amp;&amp; clones.size() == 0, &quot;&quot;);
1373     }
1374   }
1375 
1376   for (int i = 0; i &lt; state-&gt;load_reference_barriers_count(); i++) {
1377     ShenandoahLoadReferenceBarrierNode* lrb = state-&gt;load_reference_barrier(i);
<span class="line-modified">1378     if (lrb-&gt;get_barrier_strength() == ShenandoahLoadReferenceBarrierNode::NONE) {</span>
1379       continue;
1380     }
1381     Node* ctrl = phase-&gt;get_ctrl(lrb);
1382     IdealLoopTree* loop = phase-&gt;get_loop(ctrl);
1383     if (loop-&gt;_head-&gt;is_OuterStripMinedLoop()) {
1384       // Expanding a barrier here will break loop strip mining
1385       // verification. Transform the loop so the loop nest doesn&#39;t
1386       // appear as strip mined.
1387       OuterStripMinedLoopNode* outer = loop-&gt;_head-&gt;as_OuterStripMinedLoop();
1388       hide_strip_mined_loop(outer, outer-&gt;unique_ctrl_out()-&gt;as_CountedLoop(), phase);
1389     }
1390   }
1391 
1392   // Expand load-reference-barriers
1393   MemoryGraphFixer fixer(Compile::AliasIdxRaw, true, phase);
1394   Unique_Node_List uses_to_ignore;
1395   for (int i = state-&gt;load_reference_barriers_count() - 1; i &gt;= 0; i--) {
1396     ShenandoahLoadReferenceBarrierNode* lrb = state-&gt;load_reference_barrier(i);
<span class="line-modified">1397     if (lrb-&gt;get_barrier_strength() == ShenandoahLoadReferenceBarrierNode::NONE) {</span>
1398       phase-&gt;igvn().replace_node(lrb, lrb-&gt;in(ShenandoahLoadReferenceBarrierNode::ValueIn));
1399       continue;
1400     }
1401     uint last = phase-&gt;C-&gt;unique();
1402     Node* ctrl = phase-&gt;get_ctrl(lrb);
1403     Node* val = lrb-&gt;in(ShenandoahLoadReferenceBarrierNode::ValueIn);
1404 
1405 
1406     Node* orig_ctrl = ctrl;
1407 
1408     Node* raw_mem = fixer.find_mem(ctrl, lrb);
1409     Node* init_raw_mem = raw_mem;
1410     Node* raw_mem_for_ctrl = fixer.find_mem(ctrl, NULL);
1411 
1412     IdealLoopTree *loop = phase-&gt;get_loop(ctrl);
1413     CallStaticJavaNode* unc = lrb-&gt;pin_and_expand_null_check(phase-&gt;igvn());
1414     Node* unc_ctrl = NULL;
1415     if (unc != NULL) {
1416       if (val-&gt;in(ShenandoahLoadReferenceBarrierNode::Control) != ctrl) {
1417         unc = NULL;
</pre>
<hr />
<pre>
1420       }
1421     }
1422 
1423     Node* uncasted_val = val;
1424     if (unc != NULL) {
1425       uncasted_val = val-&gt;in(1);
1426     }
1427 
1428     Node* heap_stable_ctrl = NULL;
1429     Node* null_ctrl = NULL;
1430 
1431     assert(val-&gt;bottom_type()-&gt;make_oopptr(), &quot;need oop&quot;);
1432     assert(val-&gt;bottom_type()-&gt;make_oopptr()-&gt;const_oop() == NULL, &quot;expect non-constant&quot;);
1433 
1434     enum { _heap_stable = 1, _not_cset, _evac_path, _null_path, PATH_LIMIT };
1435     Node* region = new RegionNode(PATH_LIMIT);
1436     Node* val_phi = new PhiNode(region, uncasted_val-&gt;bottom_type()-&gt;is_oopptr());
1437     Node* raw_mem_phi = PhiNode::make(region, raw_mem, Type::MEMORY, TypeRawPtr::BOTTOM);
1438 
1439     // Stable path.
<span class="line-modified">1440     test_heap_stable(ctrl, raw_mem, heap_stable_ctrl, phase);</span>
1441     IfNode* heap_stable_iff = heap_stable_ctrl-&gt;in(0)-&gt;as_If();
1442 
1443     // Heap stable case
1444     region-&gt;init_req(_heap_stable, heap_stable_ctrl);
1445     val_phi-&gt;init_req(_heap_stable, uncasted_val);
1446     raw_mem_phi-&gt;init_req(_heap_stable, raw_mem);
1447 
1448     Node* reg2_ctrl = NULL;
1449     // Null case
1450     test_null(ctrl, val, null_ctrl, phase);
1451     if (null_ctrl != NULL) {
1452       reg2_ctrl = null_ctrl-&gt;in(0);
1453       region-&gt;init_req(_null_path, null_ctrl);
1454       val_phi-&gt;init_req(_null_path, uncasted_val);
1455       raw_mem_phi-&gt;init_req(_null_path, raw_mem);
1456     } else {
1457       region-&gt;del_req(_null_path);
1458       val_phi-&gt;del_req(_null_path);
1459       raw_mem_phi-&gt;del_req(_null_path);
1460     }
</pre>
<hr />
<pre>
1591     }
1592 
1593     Node* init_ctrl = ctrl;
1594     IdealLoopTree* loop = phase-&gt;get_loop(ctrl);
1595     Node* raw_mem = fixer.find_mem(ctrl, barrier);
1596     Node* init_raw_mem = raw_mem;
1597     Node* raw_mem_for_ctrl = fixer.find_mem(ctrl, NULL);
1598     Node* heap_stable_ctrl = NULL;
1599     Node* null_ctrl = NULL;
1600     uint last = phase-&gt;C-&gt;unique();
1601 
1602     enum { _heap_stable = 1, _heap_unstable, PATH_LIMIT };
1603     Node* region = new RegionNode(PATH_LIMIT);
1604     Node* phi = PhiNode::make(region, raw_mem, Type::MEMORY, TypeRawPtr::BOTTOM);
1605 
1606     enum { _fast_path = 1, _slow_path, _null_path, PATH_LIMIT2 };
1607     Node* region2 = new RegionNode(PATH_LIMIT2);
1608     Node* phi2 = PhiNode::make(region2, raw_mem, Type::MEMORY, TypeRawPtr::BOTTOM);
1609 
1610     // Stable path.
<span class="line-modified">1611     test_heap_stable(ctrl, raw_mem, heap_stable_ctrl, phase);</span>
1612     region-&gt;init_req(_heap_stable, heap_stable_ctrl);
1613     phi-&gt;init_req(_heap_stable, raw_mem);
1614 
1615     // Null path
1616     Node* reg2_ctrl = NULL;
1617     test_null(ctrl, pre_val, null_ctrl, phase);
1618     if (null_ctrl != NULL) {
1619       reg2_ctrl = null_ctrl-&gt;in(0);
1620       region2-&gt;init_req(_null_path, null_ctrl);
1621       phi2-&gt;init_req(_null_path, raw_mem);
1622     } else {
1623       region2-&gt;del_req(_null_path);
1624       phi2-&gt;del_req(_null_path);
1625     }
1626 
1627     const int index_offset = in_bytes(ShenandoahThreadLocalData::satb_mark_queue_index_offset());
1628     const int buffer_offset = in_bytes(ShenandoahThreadLocalData::satb_mark_queue_buffer_offset());
1629     Node* thread = new ThreadLocalNode();
1630     phase-&gt;register_new_node(thread, ctrl);
1631     Node* buffer_adr = new AddPNode(phase-&gt;C-&gt;top(), thread, phase-&gt;igvn().MakeConX(buffer_offset));
</pre>
<hr />
<pre>
2627     uses.push(new_ctrl);
2628     for(uint next = 0; next &lt; uses.size(); next++ ) {
2629       Node *n = uses.at(next);
2630       assert(n-&gt;is_CFG(), &quot;&quot;);
2631       DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ ctrl&quot;); n-&gt;dump(); });
2632       for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
2633         Node* u = n-&gt;fast_out(i);
2634         if (!u-&gt;is_Root() &amp;&amp; u-&gt;is_CFG() &amp;&amp; u != n) {
2635           Node* m = _memory_nodes[u-&gt;_idx];
2636           if (u-&gt;is_Region() &amp;&amp; (!u-&gt;is_OuterStripMinedLoop() || _include_lsm) &amp;&amp;
2637               !has_mem_phi(u) &amp;&amp;
2638               u-&gt;unique_ctrl_out()-&gt;Opcode() != Op_Halt) {
2639             DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ region&quot;); u-&gt;dump(); });
2640             DEBUG_ONLY(if (trace &amp;&amp; m != NULL) { tty-&gt;print(&quot;ZZZ mem&quot;); m-&gt;dump(); });
2641 
2642             if (!mem_is_valid(m, u) || !m-&gt;is_Phi()) {
2643               bool push = true;
2644               bool create_phi = true;
2645               if (_phase-&gt;is_dominator(new_ctrl, u)) {
2646                 create_phi = false;
<span class="line-removed">2647               } else if (!_phase-&gt;C-&gt;has_irreducible_loop()) {</span>
<span class="line-removed">2648                 IdealLoopTree* loop = _phase-&gt;get_loop(ctrl);</span>
<span class="line-removed">2649                 bool do_check = true;</span>
<span class="line-removed">2650                 IdealLoopTree* l = loop;</span>
<span class="line-removed">2651                 create_phi = false;</span>
<span class="line-removed">2652                 while (l != _phase-&gt;ltree_root()) {</span>
<span class="line-removed">2653                   Node* head = l-&gt;_head;</span>
<span class="line-removed">2654                   if (head-&gt;in(0) == NULL) {</span>
<span class="line-removed">2655                     head = _phase-&gt;get_ctrl(head);</span>
<span class="line-removed">2656                   }</span>
<span class="line-removed">2657                   if (_phase-&gt;is_dominator(head, u) &amp;&amp; _phase-&gt;is_dominator(_phase-&gt;idom(u), head)) {</span>
<span class="line-removed">2658                     create_phi = true;</span>
<span class="line-removed">2659                     do_check = false;</span>
<span class="line-removed">2660                     break;</span>
<span class="line-removed">2661                   }</span>
<span class="line-removed">2662                   l = l-&gt;_parent;</span>
<span class="line-removed">2663                 }</span>
<span class="line-removed">2664 </span>
<span class="line-removed">2665                 if (do_check) {</span>
<span class="line-removed">2666                   assert(!create_phi, &quot;&quot;);</span>
<span class="line-removed">2667                   IdealLoopTree* u_loop = _phase-&gt;get_loop(u);</span>
<span class="line-removed">2668                   if (u_loop != _phase-&gt;ltree_root() &amp;&amp; u_loop-&gt;is_member(loop)) {</span>
<span class="line-removed">2669                     Node* c = ctrl;</span>
<span class="line-removed">2670                     while (!_phase-&gt;is_dominator(c, u_loop-&gt;tail())) {</span>
<span class="line-removed">2671                       c = _phase-&gt;idom(c);</span>
<span class="line-removed">2672                     }</span>
<span class="line-removed">2673                     if (!_phase-&gt;is_dominator(c, u)) {</span>
<span class="line-removed">2674                       do_check = false;</span>
<span class="line-removed">2675                     }</span>
<span class="line-removed">2676                   }</span>
<span class="line-removed">2677                 }</span>
<span class="line-removed">2678 </span>
<span class="line-removed">2679                 if (do_check &amp;&amp; _phase-&gt;is_dominator(_phase-&gt;idom(u), new_ctrl)) {</span>
<span class="line-removed">2680                   create_phi = true;</span>
<span class="line-removed">2681                 }</span>
2682               }
2683               if (create_phi) {
2684                 Node* phi = new PhiNode(u, Type::MEMORY, _phase-&gt;C-&gt;get_adr_type(_alias));
2685                 _phase-&gt;register_new_node(phi, u);
2686                 phis.push(phi);
2687                 DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ new phi&quot;); phi-&gt;dump(); });
2688                 if (!mem_is_valid(m, u)) {
2689                   DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ setting mem&quot;); phi-&gt;dump(); });
2690                   _memory_nodes.map(u-&gt;_idx, phi);
2691                 } else {
2692                   DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ NOT setting mem&quot;); m-&gt;dump(); });
2693                   for (;;) {
2694                     assert(m-&gt;is_Mem() || m-&gt;is_LoadStore() || m-&gt;is_Proj(), &quot;&quot;);
2695                     Node* next = NULL;
2696                     if (m-&gt;is_Proj()) {
2697                       next = m-&gt;in(0);
2698                     } else {
2699                       assert(m-&gt;is_Mem() || m-&gt;is_LoadStore(), &quot;&quot;);
2700                       assert(_alias == Compile::AliasIdxRaw, &quot;&quot;);
2701                       next = m-&gt;in(MemNode::Memory);
</pre>
<hr />
<pre>
3173       return needs_barrier_impl(phase, n-&gt;in(2), visited) ||
3174              needs_barrier_impl(phase, n-&gt;in(3), visited);
3175     case Op_ShenandoahEnqueueBarrier:
3176       return needs_barrier_impl(phase, n-&gt;in(1), visited);
3177     case Op_CreateEx:
3178       return false;
3179     default:
3180       break;
3181   }
3182 #ifdef ASSERT
3183   tty-&gt;print(&quot;need barrier on?: &quot;);
3184   tty-&gt;print_cr(&quot;ins:&quot;);
3185   n-&gt;dump(2);
3186   tty-&gt;print_cr(&quot;outs:&quot;);
3187   n-&gt;dump(-2);
3188   ShouldNotReachHere();
3189 #endif
3190   return true;
3191 }
3192 
<span class="line-modified">3193 ShenandoahLoadReferenceBarrierNode::Strength ShenandoahLoadReferenceBarrierNode::get_barrier_strength() {</span>
3194   Unique_Node_List visited;
3195   Node_Stack stack(0);
3196   stack.push(this, 0);
3197 
<span class="line-modified">3198   // Look for strongest strength: go over nodes looking for STRONG ones.</span>
<span class="line-modified">3199   // Stop once we encountered STRONG. Otherwise, walk until we ran out of nodes,</span>
<span class="line-modified">3200   // and then the overall strength is NONE.</span>
<span class="line-modified">3201   Strength strength = NONE;</span>
<span class="line-removed">3202   while (strength != STRONG &amp;&amp; stack.size() &gt; 0) {</span>
3203     Node* n = stack.node();
3204     if (visited.member(n)) {
3205       stack.pop();
3206       continue;
3207     }
3208     visited.push(n);
3209     bool visit_users = false;
3210     switch (n-&gt;Opcode()) {
3211       case Op_CallStaticJava:
3212       case Op_CallDynamicJava:
3213       case Op_CallLeaf:
3214       case Op_CallLeafNoFP:
3215       case Op_CompareAndSwapL:
3216       case Op_CompareAndSwapI:
3217       case Op_CompareAndSwapB:
3218       case Op_CompareAndSwapS:
3219       case Op_CompareAndSwapN:
3220       case Op_CompareAndSwapP:
3221       case Op_CompareAndExchangeL:
3222       case Op_CompareAndExchangeI:
</pre>
<hr />
<pre>
3258       case Op_StoreL:
3259       case Op_StoreLConditional:
3260       case Op_StoreI:
3261       case Op_StoreIConditional:
3262       case Op_StoreN:
3263       case Op_StoreP:
3264       case Op_StoreVector:
3265       case Op_StrInflatedCopy:
3266       case Op_StrCompressedCopy:
3267       case Op_EncodeP:
3268       case Op_CastP2X:
3269       case Op_SafePoint:
3270       case Op_EncodeISOArray:
3271       case Op_AryEq:
3272       case Op_StrEquals:
3273       case Op_StrComp:
3274       case Op_StrIndexOf:
3275       case Op_StrIndexOfChar:
3276       case Op_HasNegatives:
3277         // Known to require barriers
<span class="line-modified">3278         strength = STRONG;</span>
<span class="line-removed">3279         break;</span>
3280       case Op_CmpP: {
3281         if (n-&gt;in(1)-&gt;bottom_type()-&gt;higher_equal(TypePtr::NULL_PTR) ||
3282             n-&gt;in(2)-&gt;bottom_type()-&gt;higher_equal(TypePtr::NULL_PTR)) {
3283           // One of the sides is known null, no need for barrier.
3284         } else {
<span class="line-modified">3285           strength = STRONG;</span>
3286         }
3287         break;
3288       }
3289       case Op_LoadB:
3290       case Op_LoadUB:
3291       case Op_LoadUS:
3292       case Op_LoadD:
3293       case Op_LoadF:
3294       case Op_LoadL:
3295       case Op_LoadI:
3296       case Op_LoadS:
3297       case Op_LoadN:
3298       case Op_LoadP:
3299       case Op_LoadVector: {
3300         const TypePtr* adr_type = n-&gt;adr_type();
3301         int alias_idx = Compile::current()-&gt;get_alias_index(adr_type);
3302         Compile::AliasType* alias_type = Compile::current()-&gt;alias_type(alias_idx);
3303         ciField* field = alias_type-&gt;field();
3304         bool is_static = field != NULL &amp;&amp; field-&gt;is_static();
3305         bool is_final = field != NULL &amp;&amp; field-&gt;is_final();
3306 
3307         if (ShenandoahOptimizeStaticFinals &amp;&amp; is_static &amp;&amp; is_final) {
3308           // Loading the constant does not require barriers: it should be handled
3309           // as part of GC roots already.
3310         } else {
<span class="line-modified">3311           strength = STRONG;</span>
3312         }
3313         break;
3314       }
3315       case Op_Conv2B:
3316       case Op_LoadRange:
3317       case Op_LoadKlass:
3318       case Op_LoadNKlass:
3319         // Do not require barriers
3320         break;
3321       case Op_AddP:
3322       case Op_CheckCastPP:
3323       case Op_CastPP:
3324       case Op_CMoveP:
3325       case Op_Phi:
3326       case Op_ShenandoahLoadReferenceBarrier:
3327         // Whether or not these need the barriers depends on their users
3328         visit_users = true;
3329         break;
3330       default: {
3331 #ifdef ASSERT
<span class="line-modified">3332         fatal(&quot;Unknown node in get_barrier_strength: %s&quot;, NodeClassNames[n-&gt;Opcode()]);</span>
3333 #else
<span class="line-modified">3334         // Default to strong: better to have excess barriers, rather than miss some.</span>
<span class="line-modified">3335         strength = STRONG;</span>
3336 #endif
3337       }
3338     }
3339 
3340     stack.pop();
3341     if (visit_users) {
3342       for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
3343         Node* user = n-&gt;fast_out(i);
3344         if (user != NULL) {
3345           stack.push(user, 0);
3346         }
3347       }
3348     }
3349   }
<span class="line-modified">3350   return strength;</span>


3351 }
3352 
3353 CallStaticJavaNode* ShenandoahLoadReferenceBarrierNode::pin_and_expand_null_check(PhaseIterGVN&amp; igvn) {
3354   Node* val = in(ValueIn);
3355 
3356   const Type* val_t = igvn.type(val);
3357 
3358   if (val_t-&gt;meet(TypePtr::NULL_PTR) != val_t &amp;&amp;
3359       val-&gt;Opcode() == Op_CastPP &amp;&amp;
3360       val-&gt;in(0) != NULL &amp;&amp;
3361       val-&gt;in(0)-&gt;Opcode() == Op_IfTrue &amp;&amp;
3362       val-&gt;in(0)-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none) &amp;&amp;
3363       val-&gt;in(0)-&gt;in(0)-&gt;is_If() &amp;&amp;
3364       val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;Opcode() == Op_Bool &amp;&amp;
3365       val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;as_Bool()-&gt;_test._test == BoolTest::ne &amp;&amp;
3366       val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;Opcode() == Op_CmpP &amp;&amp;
3367       val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(1) == val-&gt;in(1) &amp;&amp;
3368       val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(2)-&gt;bottom_type() == TypePtr::NULL_PTR) {
3369     assert(val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(1) == val-&gt;in(1), &quot;&quot;);
3370     CallStaticJavaNode* unc = val-&gt;in(0)-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none);
</pre>
</td>
<td>
<hr />
<pre>
 843 void ShenandoahBarrierC2Support::follow_barrier_uses(Node* n, Node* ctrl, Unique_Node_List&amp; uses, PhaseIdealLoop* phase) {
 844   for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
 845     Node* u = n-&gt;fast_out(i);
 846     if (!u-&gt;is_CFG() &amp;&amp; phase-&gt;get_ctrl(u) == ctrl &amp;&amp; (!u-&gt;is_Phi() || !u-&gt;in(0)-&gt;is_Loop() || u-&gt;in(LoopNode::LoopBackControl) != n)) {
 847       uses.push(u);
 848     }
 849   }
 850 }
 851 
 852 static void hide_strip_mined_loop(OuterStripMinedLoopNode* outer, CountedLoopNode* inner, PhaseIdealLoop* phase) {
 853   OuterStripMinedLoopEndNode* le = inner-&gt;outer_loop_end();
 854   Node* new_outer = new LoopNode(outer-&gt;in(LoopNode::EntryControl), outer-&gt;in(LoopNode::LoopBackControl));
 855   phase-&gt;register_control(new_outer, phase-&gt;get_loop(outer), outer-&gt;in(LoopNode::EntryControl));
 856   Node* new_le = new IfNode(le-&gt;in(0), le-&gt;in(1), le-&gt;_prob, le-&gt;_fcnt);
 857   phase-&gt;register_control(new_le, phase-&gt;get_loop(le), le-&gt;in(0));
 858   phase-&gt;lazy_replace(outer, new_outer);
 859   phase-&gt;lazy_replace(le, new_le);
 860   inner-&gt;clear_strip_mined();
 861 }
 862 
<span class="line-modified"> 863 void ShenandoahBarrierC2Support::test_heap_state(Node*&amp; ctrl, Node* raw_mem, Node*&amp; heap_stable_ctrl,</span>
<span class="line-modified"> 864                                                  PhaseIdealLoop* phase, int flags) {</span>
 865   IdealLoopTree* loop = phase-&gt;get_loop(ctrl);
 866   Node* thread = new ThreadLocalNode();
 867   phase-&gt;register_new_node(thread, ctrl);
 868   Node* offset = phase-&gt;igvn().MakeConX(in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
 869   phase-&gt;set_ctrl(offset, phase-&gt;C-&gt;root());
 870   Node* gc_state_addr = new AddPNode(phase-&gt;C-&gt;top(), thread, offset);
 871   phase-&gt;register_new_node(gc_state_addr, ctrl);
 872   uint gc_state_idx = Compile::AliasIdxRaw;
 873   const TypePtr* gc_state_adr_type = NULL; // debug-mode-only argument
 874   debug_only(gc_state_adr_type = phase-&gt;C-&gt;get_adr_type(gc_state_idx));
 875 
 876   Node* gc_state = new LoadBNode(ctrl, raw_mem, gc_state_addr, gc_state_adr_type, TypeInt::BYTE, MemNode::unordered);
 877   phase-&gt;register_new_node(gc_state, ctrl);
<span class="line-modified"> 878   Node* heap_stable_and = new AndINode(gc_state, phase-&gt;igvn().intcon(flags));</span>
 879   phase-&gt;register_new_node(heap_stable_and, ctrl);
 880   Node* heap_stable_cmp = new CmpINode(heap_stable_and, phase-&gt;igvn().zerocon(T_INT));
 881   phase-&gt;register_new_node(heap_stable_cmp, ctrl);
 882   Node* heap_stable_test = new BoolNode(heap_stable_cmp, BoolTest::ne);
 883   phase-&gt;register_new_node(heap_stable_test, ctrl);
 884   IfNode* heap_stable_iff = new IfNode(ctrl, heap_stable_test, PROB_UNLIKELY(0.999), COUNT_UNKNOWN);
 885   phase-&gt;register_control(heap_stable_iff, loop, ctrl);
 886 
 887   heap_stable_ctrl = new IfFalseNode(heap_stable_iff);
 888   phase-&gt;register_control(heap_stable_ctrl, loop, heap_stable_iff);
 889   ctrl = new IfTrueNode(heap_stable_iff);
 890   phase-&gt;register_control(ctrl, loop, heap_stable_iff);
 891 
<span class="line-modified"> 892   assert(is_heap_state_test(heap_stable_iff, flags), &quot;Should match the shape&quot;);</span>
 893 }
 894 
 895 void ShenandoahBarrierC2Support::test_null(Node*&amp; ctrl, Node* val, Node*&amp; null_ctrl, PhaseIdealLoop* phase) {
 896   const Type* val_t = phase-&gt;igvn().type(val);
 897   if (val_t-&gt;meet(TypePtr::NULL_PTR) == val_t) {
 898     IdealLoopTree* loop = phase-&gt;get_loop(ctrl);
 899     Node* null_cmp = new CmpPNode(val, phase-&gt;igvn().zerocon(T_OBJECT));
 900     phase-&gt;register_new_node(null_cmp, ctrl);
 901     Node* null_test = new BoolNode(null_cmp, BoolTest::ne);
 902     phase-&gt;register_new_node(null_test, ctrl);
 903     IfNode* null_iff = new IfNode(ctrl, null_test, PROB_LIKELY(0.999), COUNT_UNKNOWN);
 904     phase-&gt;register_control(null_iff, loop, ctrl);
 905     ctrl = new IfTrueNode(null_iff);
 906     phase-&gt;register_control(ctrl, loop, null_iff);
 907     null_ctrl = new IfFalseNode(null_iff);
 908     phase-&gt;register_control(null_ctrl, loop, null_iff);
 909   }
 910 }
 911 
 912 Node* ShenandoahBarrierC2Support::clone_null_check(Node*&amp; c, Node* val, Node* unc_ctrl, PhaseIdealLoop* phase) {
</pre>
<hr />
<pre>
1127   ShenandoahBarrierSetC2State* state = ShenandoahBarrierSetC2::bsc2()-&gt;state();
1128 
1129   Unique_Node_List uses;
1130   for (int i = 0; i &lt; state-&gt;enqueue_barriers_count(); i++) {
1131     Node* barrier = state-&gt;enqueue_barrier(i);
1132     Node* ctrl = phase-&gt;get_ctrl(barrier);
1133     IdealLoopTree* loop = phase-&gt;get_loop(ctrl);
1134     if (loop-&gt;_head-&gt;is_OuterStripMinedLoop()) {
1135       // Expanding a barrier here will break loop strip mining
1136       // verification. Transform the loop so the loop nest doesn&#39;t
1137       // appear as strip mined.
1138       OuterStripMinedLoopNode* outer = loop-&gt;_head-&gt;as_OuterStripMinedLoop();
1139       hide_strip_mined_loop(outer, outer-&gt;unique_ctrl_out()-&gt;as_CountedLoop(), phase);
1140     }
1141   }
1142 
1143   Node_Stack stack(0);
1144   Node_List clones;
1145   for (int i = state-&gt;load_reference_barriers_count() - 1; i &gt;= 0; i--) {
1146     ShenandoahLoadReferenceBarrierNode* lrb = state-&gt;load_reference_barrier(i);
<span class="line-modified">1147     if (lrb-&gt;is_redundant()) {</span>
1148       continue;
1149     }
1150 
1151     Node* ctrl = phase-&gt;get_ctrl(lrb);
1152     Node* val = lrb-&gt;in(ShenandoahLoadReferenceBarrierNode::ValueIn);
1153 
1154     CallStaticJavaNode* unc = NULL;
1155     Node* unc_ctrl = NULL;
1156     Node* uncasted_val = val;
1157 
1158     for (DUIterator_Fast imax, i = lrb-&gt;fast_outs(imax); i &lt; imax; i++) {
1159       Node* u = lrb-&gt;fast_out(i);
1160       if (u-&gt;Opcode() == Op_CastPP &amp;&amp;
1161           u-&gt;in(0) != NULL &amp;&amp;
1162           phase-&gt;is_dominator(u-&gt;in(0), ctrl)) {
1163         const Type* u_t = phase-&gt;igvn().type(u);
1164 
1165         if (u_t-&gt;meet(TypePtr::NULL_PTR) != u_t &amp;&amp;
1166             u-&gt;in(0)-&gt;Opcode() == Op_IfTrue &amp;&amp;
1167             u-&gt;in(0)-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none) &amp;&amp;
</pre>
<hr />
<pre>
1358                 int nb = u-&gt;replace_edge(n, create_phis_on_call_return(ctrl, c, n, n_clone, projs, phase));
1359                 assert(nb &gt; 0, &quot;should have replaced some uses&quot;);
1360                 replaced = true;
1361               }
1362             }
1363             if (!replaced) {
1364               stack.set_index(idx+1);
1365             }
1366           }
1367         } else {
1368           stack.pop();
1369           clones.pop();
1370         }
1371       } while (stack.size() &gt; 0);
1372       assert(stack.size() == 0 &amp;&amp; clones.size() == 0, &quot;&quot;);
1373     }
1374   }
1375 
1376   for (int i = 0; i &lt; state-&gt;load_reference_barriers_count(); i++) {
1377     ShenandoahLoadReferenceBarrierNode* lrb = state-&gt;load_reference_barrier(i);
<span class="line-modified">1378     if (lrb-&gt;is_redundant()) {</span>
1379       continue;
1380     }
1381     Node* ctrl = phase-&gt;get_ctrl(lrb);
1382     IdealLoopTree* loop = phase-&gt;get_loop(ctrl);
1383     if (loop-&gt;_head-&gt;is_OuterStripMinedLoop()) {
1384       // Expanding a barrier here will break loop strip mining
1385       // verification. Transform the loop so the loop nest doesn&#39;t
1386       // appear as strip mined.
1387       OuterStripMinedLoopNode* outer = loop-&gt;_head-&gt;as_OuterStripMinedLoop();
1388       hide_strip_mined_loop(outer, outer-&gt;unique_ctrl_out()-&gt;as_CountedLoop(), phase);
1389     }
1390   }
1391 
1392   // Expand load-reference-barriers
1393   MemoryGraphFixer fixer(Compile::AliasIdxRaw, true, phase);
1394   Unique_Node_List uses_to_ignore;
1395   for (int i = state-&gt;load_reference_barriers_count() - 1; i &gt;= 0; i--) {
1396     ShenandoahLoadReferenceBarrierNode* lrb = state-&gt;load_reference_barrier(i);
<span class="line-modified">1397     if (lrb-&gt;is_redundant()) {</span>
1398       phase-&gt;igvn().replace_node(lrb, lrb-&gt;in(ShenandoahLoadReferenceBarrierNode::ValueIn));
1399       continue;
1400     }
1401     uint last = phase-&gt;C-&gt;unique();
1402     Node* ctrl = phase-&gt;get_ctrl(lrb);
1403     Node* val = lrb-&gt;in(ShenandoahLoadReferenceBarrierNode::ValueIn);
1404 
1405 
1406     Node* orig_ctrl = ctrl;
1407 
1408     Node* raw_mem = fixer.find_mem(ctrl, lrb);
1409     Node* init_raw_mem = raw_mem;
1410     Node* raw_mem_for_ctrl = fixer.find_mem(ctrl, NULL);
1411 
1412     IdealLoopTree *loop = phase-&gt;get_loop(ctrl);
1413     CallStaticJavaNode* unc = lrb-&gt;pin_and_expand_null_check(phase-&gt;igvn());
1414     Node* unc_ctrl = NULL;
1415     if (unc != NULL) {
1416       if (val-&gt;in(ShenandoahLoadReferenceBarrierNode::Control) != ctrl) {
1417         unc = NULL;
</pre>
<hr />
<pre>
1420       }
1421     }
1422 
1423     Node* uncasted_val = val;
1424     if (unc != NULL) {
1425       uncasted_val = val-&gt;in(1);
1426     }
1427 
1428     Node* heap_stable_ctrl = NULL;
1429     Node* null_ctrl = NULL;
1430 
1431     assert(val-&gt;bottom_type()-&gt;make_oopptr(), &quot;need oop&quot;);
1432     assert(val-&gt;bottom_type()-&gt;make_oopptr()-&gt;const_oop() == NULL, &quot;expect non-constant&quot;);
1433 
1434     enum { _heap_stable = 1, _not_cset, _evac_path, _null_path, PATH_LIMIT };
1435     Node* region = new RegionNode(PATH_LIMIT);
1436     Node* val_phi = new PhiNode(region, uncasted_val-&gt;bottom_type()-&gt;is_oopptr());
1437     Node* raw_mem_phi = PhiNode::make(region, raw_mem, Type::MEMORY, TypeRawPtr::BOTTOM);
1438 
1439     // Stable path.
<span class="line-modified">1440     test_heap_state(ctrl, raw_mem, heap_stable_ctrl, phase, ShenandoahHeap::HAS_FORWARDED);</span>
1441     IfNode* heap_stable_iff = heap_stable_ctrl-&gt;in(0)-&gt;as_If();
1442 
1443     // Heap stable case
1444     region-&gt;init_req(_heap_stable, heap_stable_ctrl);
1445     val_phi-&gt;init_req(_heap_stable, uncasted_val);
1446     raw_mem_phi-&gt;init_req(_heap_stable, raw_mem);
1447 
1448     Node* reg2_ctrl = NULL;
1449     // Null case
1450     test_null(ctrl, val, null_ctrl, phase);
1451     if (null_ctrl != NULL) {
1452       reg2_ctrl = null_ctrl-&gt;in(0);
1453       region-&gt;init_req(_null_path, null_ctrl);
1454       val_phi-&gt;init_req(_null_path, uncasted_val);
1455       raw_mem_phi-&gt;init_req(_null_path, raw_mem);
1456     } else {
1457       region-&gt;del_req(_null_path);
1458       val_phi-&gt;del_req(_null_path);
1459       raw_mem_phi-&gt;del_req(_null_path);
1460     }
</pre>
<hr />
<pre>
1591     }
1592 
1593     Node* init_ctrl = ctrl;
1594     IdealLoopTree* loop = phase-&gt;get_loop(ctrl);
1595     Node* raw_mem = fixer.find_mem(ctrl, barrier);
1596     Node* init_raw_mem = raw_mem;
1597     Node* raw_mem_for_ctrl = fixer.find_mem(ctrl, NULL);
1598     Node* heap_stable_ctrl = NULL;
1599     Node* null_ctrl = NULL;
1600     uint last = phase-&gt;C-&gt;unique();
1601 
1602     enum { _heap_stable = 1, _heap_unstable, PATH_LIMIT };
1603     Node* region = new RegionNode(PATH_LIMIT);
1604     Node* phi = PhiNode::make(region, raw_mem, Type::MEMORY, TypeRawPtr::BOTTOM);
1605 
1606     enum { _fast_path = 1, _slow_path, _null_path, PATH_LIMIT2 };
1607     Node* region2 = new RegionNode(PATH_LIMIT2);
1608     Node* phi2 = PhiNode::make(region2, raw_mem, Type::MEMORY, TypeRawPtr::BOTTOM);
1609 
1610     // Stable path.
<span class="line-modified">1611     test_heap_state(ctrl, raw_mem, heap_stable_ctrl, phase, ShenandoahHeap::MARKING);</span>
1612     region-&gt;init_req(_heap_stable, heap_stable_ctrl);
1613     phi-&gt;init_req(_heap_stable, raw_mem);
1614 
1615     // Null path
1616     Node* reg2_ctrl = NULL;
1617     test_null(ctrl, pre_val, null_ctrl, phase);
1618     if (null_ctrl != NULL) {
1619       reg2_ctrl = null_ctrl-&gt;in(0);
1620       region2-&gt;init_req(_null_path, null_ctrl);
1621       phi2-&gt;init_req(_null_path, raw_mem);
1622     } else {
1623       region2-&gt;del_req(_null_path);
1624       phi2-&gt;del_req(_null_path);
1625     }
1626 
1627     const int index_offset = in_bytes(ShenandoahThreadLocalData::satb_mark_queue_index_offset());
1628     const int buffer_offset = in_bytes(ShenandoahThreadLocalData::satb_mark_queue_buffer_offset());
1629     Node* thread = new ThreadLocalNode();
1630     phase-&gt;register_new_node(thread, ctrl);
1631     Node* buffer_adr = new AddPNode(phase-&gt;C-&gt;top(), thread, phase-&gt;igvn().MakeConX(buffer_offset));
</pre>
<hr />
<pre>
2627     uses.push(new_ctrl);
2628     for(uint next = 0; next &lt; uses.size(); next++ ) {
2629       Node *n = uses.at(next);
2630       assert(n-&gt;is_CFG(), &quot;&quot;);
2631       DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ ctrl&quot;); n-&gt;dump(); });
2632       for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
2633         Node* u = n-&gt;fast_out(i);
2634         if (!u-&gt;is_Root() &amp;&amp; u-&gt;is_CFG() &amp;&amp; u != n) {
2635           Node* m = _memory_nodes[u-&gt;_idx];
2636           if (u-&gt;is_Region() &amp;&amp; (!u-&gt;is_OuterStripMinedLoop() || _include_lsm) &amp;&amp;
2637               !has_mem_phi(u) &amp;&amp;
2638               u-&gt;unique_ctrl_out()-&gt;Opcode() != Op_Halt) {
2639             DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ region&quot;); u-&gt;dump(); });
2640             DEBUG_ONLY(if (trace &amp;&amp; m != NULL) { tty-&gt;print(&quot;ZZZ mem&quot;); m-&gt;dump(); });
2641 
2642             if (!mem_is_valid(m, u) || !m-&gt;is_Phi()) {
2643               bool push = true;
2644               bool create_phi = true;
2645               if (_phase-&gt;is_dominator(new_ctrl, u)) {
2646                 create_phi = false;



































2647               }
2648               if (create_phi) {
2649                 Node* phi = new PhiNode(u, Type::MEMORY, _phase-&gt;C-&gt;get_adr_type(_alias));
2650                 _phase-&gt;register_new_node(phi, u);
2651                 phis.push(phi);
2652                 DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ new phi&quot;); phi-&gt;dump(); });
2653                 if (!mem_is_valid(m, u)) {
2654                   DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ setting mem&quot;); phi-&gt;dump(); });
2655                   _memory_nodes.map(u-&gt;_idx, phi);
2656                 } else {
2657                   DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ NOT setting mem&quot;); m-&gt;dump(); });
2658                   for (;;) {
2659                     assert(m-&gt;is_Mem() || m-&gt;is_LoadStore() || m-&gt;is_Proj(), &quot;&quot;);
2660                     Node* next = NULL;
2661                     if (m-&gt;is_Proj()) {
2662                       next = m-&gt;in(0);
2663                     } else {
2664                       assert(m-&gt;is_Mem() || m-&gt;is_LoadStore(), &quot;&quot;);
2665                       assert(_alias == Compile::AliasIdxRaw, &quot;&quot;);
2666                       next = m-&gt;in(MemNode::Memory);
</pre>
<hr />
<pre>
3138       return needs_barrier_impl(phase, n-&gt;in(2), visited) ||
3139              needs_barrier_impl(phase, n-&gt;in(3), visited);
3140     case Op_ShenandoahEnqueueBarrier:
3141       return needs_barrier_impl(phase, n-&gt;in(1), visited);
3142     case Op_CreateEx:
3143       return false;
3144     default:
3145       break;
3146   }
3147 #ifdef ASSERT
3148   tty-&gt;print(&quot;need barrier on?: &quot;);
3149   tty-&gt;print_cr(&quot;ins:&quot;);
3150   n-&gt;dump(2);
3151   tty-&gt;print_cr(&quot;outs:&quot;);
3152   n-&gt;dump(-2);
3153   ShouldNotReachHere();
3154 #endif
3155   return true;
3156 }
3157 
<span class="line-modified">3158 bool ShenandoahLoadReferenceBarrierNode::is_redundant() {</span>
3159   Unique_Node_List visited;
3160   Node_Stack stack(0);
3161   stack.push(this, 0);
3162 
<span class="line-modified">3163   // Check if the barrier is actually useful: go over nodes looking for useful uses</span>
<span class="line-modified">3164   // (e.g. memory accesses). Stop once we detected a required use. Otherwise, walk</span>
<span class="line-modified">3165   // until we ran out of nodes, and then declare the barrier redundant.</span>
<span class="line-modified">3166   while (stack.size() &gt; 0) {</span>

3167     Node* n = stack.node();
3168     if (visited.member(n)) {
3169       stack.pop();
3170       continue;
3171     }
3172     visited.push(n);
3173     bool visit_users = false;
3174     switch (n-&gt;Opcode()) {
3175       case Op_CallStaticJava:
3176       case Op_CallDynamicJava:
3177       case Op_CallLeaf:
3178       case Op_CallLeafNoFP:
3179       case Op_CompareAndSwapL:
3180       case Op_CompareAndSwapI:
3181       case Op_CompareAndSwapB:
3182       case Op_CompareAndSwapS:
3183       case Op_CompareAndSwapN:
3184       case Op_CompareAndSwapP:
3185       case Op_CompareAndExchangeL:
3186       case Op_CompareAndExchangeI:
</pre>
<hr />
<pre>
3222       case Op_StoreL:
3223       case Op_StoreLConditional:
3224       case Op_StoreI:
3225       case Op_StoreIConditional:
3226       case Op_StoreN:
3227       case Op_StoreP:
3228       case Op_StoreVector:
3229       case Op_StrInflatedCopy:
3230       case Op_StrCompressedCopy:
3231       case Op_EncodeP:
3232       case Op_CastP2X:
3233       case Op_SafePoint:
3234       case Op_EncodeISOArray:
3235       case Op_AryEq:
3236       case Op_StrEquals:
3237       case Op_StrComp:
3238       case Op_StrIndexOf:
3239       case Op_StrIndexOfChar:
3240       case Op_HasNegatives:
3241         // Known to require barriers
<span class="line-modified">3242         return false;</span>

3243       case Op_CmpP: {
3244         if (n-&gt;in(1)-&gt;bottom_type()-&gt;higher_equal(TypePtr::NULL_PTR) ||
3245             n-&gt;in(2)-&gt;bottom_type()-&gt;higher_equal(TypePtr::NULL_PTR)) {
3246           // One of the sides is known null, no need for barrier.
3247         } else {
<span class="line-modified">3248           return false;</span>
3249         }
3250         break;
3251       }
3252       case Op_LoadB:
3253       case Op_LoadUB:
3254       case Op_LoadUS:
3255       case Op_LoadD:
3256       case Op_LoadF:
3257       case Op_LoadL:
3258       case Op_LoadI:
3259       case Op_LoadS:
3260       case Op_LoadN:
3261       case Op_LoadP:
3262       case Op_LoadVector: {
3263         const TypePtr* adr_type = n-&gt;adr_type();
3264         int alias_idx = Compile::current()-&gt;get_alias_index(adr_type);
3265         Compile::AliasType* alias_type = Compile::current()-&gt;alias_type(alias_idx);
3266         ciField* field = alias_type-&gt;field();
3267         bool is_static = field != NULL &amp;&amp; field-&gt;is_static();
3268         bool is_final = field != NULL &amp;&amp; field-&gt;is_final();
3269 
3270         if (ShenandoahOptimizeStaticFinals &amp;&amp; is_static &amp;&amp; is_final) {
3271           // Loading the constant does not require barriers: it should be handled
3272           // as part of GC roots already.
3273         } else {
<span class="line-modified">3274           return false;</span>
3275         }
3276         break;
3277       }
3278       case Op_Conv2B:
3279       case Op_LoadRange:
3280       case Op_LoadKlass:
3281       case Op_LoadNKlass:
3282         // Do not require barriers
3283         break;
3284       case Op_AddP:
3285       case Op_CheckCastPP:
3286       case Op_CastPP:
3287       case Op_CMoveP:
3288       case Op_Phi:
3289       case Op_ShenandoahLoadReferenceBarrier:
3290         // Whether or not these need the barriers depends on their users
3291         visit_users = true;
3292         break;
3293       default: {
3294 #ifdef ASSERT
<span class="line-modified">3295         fatal(&quot;Unknown node in is_redundant: %s&quot;, NodeClassNames[n-&gt;Opcode()]);</span>
3296 #else
<span class="line-modified">3297         // Default to have excess barriers, rather than miss some.</span>
<span class="line-modified">3298         return false;</span>
3299 #endif
3300       }
3301     }
3302 
3303     stack.pop();
3304     if (visit_users) {
3305       for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
3306         Node* user = n-&gt;fast_out(i);
3307         if (user != NULL) {
3308           stack.push(user, 0);
3309         }
3310       }
3311     }
3312   }
<span class="line-modified">3313 </span>
<span class="line-added">3314   // No need for barrier found.</span>
<span class="line-added">3315   return true;</span>
3316 }
3317 
3318 CallStaticJavaNode* ShenandoahLoadReferenceBarrierNode::pin_and_expand_null_check(PhaseIterGVN&amp; igvn) {
3319   Node* val = in(ValueIn);
3320 
3321   const Type* val_t = igvn.type(val);
3322 
3323   if (val_t-&gt;meet(TypePtr::NULL_PTR) != val_t &amp;&amp;
3324       val-&gt;Opcode() == Op_CastPP &amp;&amp;
3325       val-&gt;in(0) != NULL &amp;&amp;
3326       val-&gt;in(0)-&gt;Opcode() == Op_IfTrue &amp;&amp;
3327       val-&gt;in(0)-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none) &amp;&amp;
3328       val-&gt;in(0)-&gt;in(0)-&gt;is_If() &amp;&amp;
3329       val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;Opcode() == Op_Bool &amp;&amp;
3330       val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;as_Bool()-&gt;_test._test == BoolTest::ne &amp;&amp;
3331       val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;Opcode() == Op_CmpP &amp;&amp;
3332       val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(1) == val-&gt;in(1) &amp;&amp;
3333       val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(2)-&gt;bottom_type() == TypePtr::NULL_PTR) {
3334     assert(val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(1) == val-&gt;in(1), &quot;&quot;);
3335     CallStaticJavaNode* unc = val-&gt;in(0)-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none);
</pre>
</td>
</tr>
</table>
<center><a href="shenandoahBarrierSetC2.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="shenandoahSupport.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
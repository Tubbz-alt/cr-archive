<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/gc/shenandoah/shenandoahHeap.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2013, 2020, Red Hat, Inc. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;memory/allocation.hpp&quot;
  27 #include &quot;memory/universe.hpp&quot;
  28 
  29 #include &quot;gc/shared/gcArguments.hpp&quot;
  30 #include &quot;gc/shared/gcTimer.hpp&quot;
  31 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
  32 #include &quot;gc/shared/locationPrinter.inline.hpp&quot;
  33 #include &quot;gc/shared/memAllocator.hpp&quot;
  34 #include &quot;gc/shared/oopStorageSet.hpp&quot;
  35 #include &quot;gc/shared/plab.hpp&quot;
  36 
  37 #include &quot;gc/shenandoah/shenandoahBarrierSet.hpp&quot;
  38 #include &quot;gc/shenandoah/shenandoahClosures.inline.hpp&quot;
  39 #include &quot;gc/shenandoah/shenandoahCollectionSet.hpp&quot;
  40 #include &quot;gc/shenandoah/shenandoahCollectorPolicy.hpp&quot;
  41 #include &quot;gc/shenandoah/shenandoahConcurrentMark.inline.hpp&quot;
  42 #include &quot;gc/shenandoah/shenandoahConcurrentRoots.hpp&quot;
  43 #include &quot;gc/shenandoah/shenandoahControlThread.hpp&quot;
  44 #include &quot;gc/shenandoah/shenandoahFreeSet.hpp&quot;
  45 #include &quot;gc/shenandoah/shenandoahPhaseTimings.hpp&quot;
  46 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
  47 #include &quot;gc/shenandoah/shenandoahHeapRegion.inline.hpp&quot;
  48 #include &quot;gc/shenandoah/shenandoahHeapRegionSet.hpp&quot;
  49 #include &quot;gc/shenandoah/shenandoahIUMode.hpp&quot;
  50 #include &quot;gc/shenandoah/shenandoahMarkCompact.hpp&quot;
  51 #include &quot;gc/shenandoah/shenandoahMarkingContext.inline.hpp&quot;
  52 #include &quot;gc/shenandoah/shenandoahMemoryPool.hpp&quot;
  53 #include &quot;gc/shenandoah/shenandoahMetrics.hpp&quot;
  54 #include &quot;gc/shenandoah/shenandoahMonitoringSupport.hpp&quot;
  55 #include &quot;gc/shenandoah/shenandoahNormalMode.hpp&quot;
  56 #include &quot;gc/shenandoah/shenandoahOopClosures.inline.hpp&quot;
  57 #include &quot;gc/shenandoah/shenandoahPacer.inline.hpp&quot;
  58 #include &quot;gc/shenandoah/shenandoahPadding.hpp&quot;
  59 #include &quot;gc/shenandoah/shenandoahParallelCleaning.inline.hpp&quot;
  60 #include &quot;gc/shenandoah/shenandoahPassiveMode.hpp&quot;
  61 #include &quot;gc/shenandoah/shenandoahRootProcessor.inline.hpp&quot;
  62 #include &quot;gc/shenandoah/shenandoahStringDedup.hpp&quot;
  63 #include &quot;gc/shenandoah/shenandoahTaskqueue.hpp&quot;
  64 #include &quot;gc/shenandoah/shenandoahUtils.hpp&quot;
  65 #include &quot;gc/shenandoah/shenandoahVerifier.hpp&quot;
  66 #include &quot;gc/shenandoah/shenandoahCodeRoots.hpp&quot;
  67 #include &quot;gc/shenandoah/shenandoahVMOperations.hpp&quot;
  68 #include &quot;gc/shenandoah/shenandoahWorkGroup.hpp&quot;
  69 #include &quot;gc/shenandoah/shenandoahWorkerPolicy.hpp&quot;
  70 #if INCLUDE_JFR
  71 #include &quot;gc/shenandoah/shenandoahJfrSupport.hpp&quot;
  72 #endif
  73 
  74 #include &quot;memory/metaspace.hpp&quot;
  75 #include &quot;oops/compressedOops.inline.hpp&quot;
  76 #include &quot;runtime/atomic.hpp&quot;
  77 #include &quot;runtime/globals.hpp&quot;
  78 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  79 #include &quot;runtime/orderAccess.hpp&quot;
  80 #include &quot;runtime/safepointMechanism.hpp&quot;
  81 #include &quot;runtime/vmThread.hpp&quot;
  82 #include &quot;services/mallocTracker.hpp&quot;
  83 #include &quot;utilities/powerOfTwo.hpp&quot;
  84 
  85 ShenandoahHeap* ShenandoahHeap::_heap = NULL;
  86 
  87 #ifdef ASSERT
  88 template &lt;class T&gt;
  89 void ShenandoahAssertToSpaceClosure::do_oop_work(T* p) {
  90   T o = RawAccess&lt;&gt;::oop_load(p);
  91   if (! CompressedOops::is_null(o)) {
  92     oop obj = CompressedOops::decode_not_null(o);
  93     shenandoah_assert_not_forwarded(p, obj);
  94   }
  95 }
  96 
  97 void ShenandoahAssertToSpaceClosure::do_oop(narrowOop* p) { do_oop_work(p); }
  98 void ShenandoahAssertToSpaceClosure::do_oop(oop* p)       { do_oop_work(p); }
  99 #endif
 100 
 101 class ShenandoahPretouchHeapTask : public AbstractGangTask {
 102 private:
 103   ShenandoahRegionIterator _regions;
 104   const size_t _page_size;
 105 public:
 106   ShenandoahPretouchHeapTask(size_t page_size) :
 107     AbstractGangTask(&quot;Shenandoah Pretouch Heap&quot;),
 108     _page_size(page_size) {}
 109 
 110   virtual void work(uint worker_id) {
 111     ShenandoahHeapRegion* r = _regions.next();
 112     while (r != NULL) {
 113       os::pretouch_memory(r-&gt;bottom(), r-&gt;end(), _page_size);
 114       r = _regions.next();
 115     }
 116   }
 117 };
 118 
 119 class ShenandoahPretouchBitmapTask : public AbstractGangTask {
 120 private:
 121   ShenandoahRegionIterator _regions;
 122   char* _bitmap_base;
 123   const size_t _bitmap_size;
 124   const size_t _page_size;
 125 public:
 126   ShenandoahPretouchBitmapTask(char* bitmap_base, size_t bitmap_size, size_t page_size) :
 127     AbstractGangTask(&quot;Shenandoah Pretouch Bitmap&quot;),
 128     _bitmap_base(bitmap_base),
 129     _bitmap_size(bitmap_size),
 130     _page_size(page_size) {}
 131 
 132   virtual void work(uint worker_id) {
 133     ShenandoahHeapRegion* r = _regions.next();
 134     while (r != NULL) {
 135       size_t start = r-&gt;index()       * ShenandoahHeapRegion::region_size_bytes() / MarkBitMap::heap_map_factor();
 136       size_t end   = (r-&gt;index() + 1) * ShenandoahHeapRegion::region_size_bytes() / MarkBitMap::heap_map_factor();
 137       assert (end &lt;= _bitmap_size, &quot;end is sane: &quot; SIZE_FORMAT &quot; &lt; &quot; SIZE_FORMAT, end, _bitmap_size);
 138 
 139       os::pretouch_memory(_bitmap_base + start, _bitmap_base + end, _page_size);
 140 
 141       r = _regions.next();
 142     }
 143   }
 144 };
 145 
 146 jint ShenandoahHeap::initialize() {
 147   //
 148   // Figure out heap sizing
 149   //
 150 
 151   size_t init_byte_size = InitialHeapSize;
 152   size_t min_byte_size  = MinHeapSize;
 153   size_t max_byte_size  = MaxHeapSize;
 154   size_t heap_alignment = HeapAlignment;
 155 
 156   size_t reg_size_bytes = ShenandoahHeapRegion::region_size_bytes();
 157 
 158   if (ShenandoahAlwaysPreTouch) {
 159     // Enabled pre-touch means the entire heap is committed right away.
 160     init_byte_size = max_byte_size;
 161   }
 162 
 163   Universe::check_alignment(max_byte_size,  reg_size_bytes, &quot;Shenandoah heap&quot;);
 164   Universe::check_alignment(init_byte_size, reg_size_bytes, &quot;Shenandoah heap&quot;);
 165 
 166   _num_regions = ShenandoahHeapRegion::region_count();
 167 
 168   // Now we know the number of regions, initialize the heuristics.
 169   initialize_heuristics();
 170 
 171   size_t num_committed_regions = init_byte_size / reg_size_bytes;
 172   num_committed_regions = MIN2(num_committed_regions, _num_regions);
 173   assert(num_committed_regions &lt;= _num_regions, &quot;sanity&quot;);
 174   _initial_size = num_committed_regions * reg_size_bytes;
 175 
 176   size_t num_min_regions = min_byte_size / reg_size_bytes;
 177   num_min_regions = MIN2(num_min_regions, _num_regions);
 178   assert(num_min_regions &lt;= _num_regions, &quot;sanity&quot;);
 179   _minimum_size = num_min_regions * reg_size_bytes;
 180 
 181   _committed = _initial_size;
 182 
 183   size_t heap_page_size   = UseLargePages ? (size_t)os::large_page_size() : (size_t)os::vm_page_size();
 184   size_t bitmap_page_size = UseLargePages ? (size_t)os::large_page_size() : (size_t)os::vm_page_size();
 185   size_t region_page_size = UseLargePages ? (size_t)os::large_page_size() : (size_t)os::vm_page_size();
 186 
 187   //
 188   // Reserve and commit memory for heap
 189   //
 190 
 191   ReservedHeapSpace heap_rs = Universe::reserve_heap(max_byte_size, heap_alignment);
 192   initialize_reserved_region(heap_rs);
 193   _heap_region = MemRegion((HeapWord*)heap_rs.base(), heap_rs.size() / HeapWordSize);
 194   _heap_region_special = heap_rs.special();
 195 
 196   assert((((size_t) base()) &amp; ShenandoahHeapRegion::region_size_bytes_mask()) == 0,
 197          &quot;Misaligned heap: &quot; PTR_FORMAT, p2i(base()));
 198 
 199 #if SHENANDOAH_OPTIMIZED_OBJTASK
 200   // The optimized ObjArrayChunkedTask takes some bits away from the full object bits.
 201   // Fail if we ever attempt to address more than we can.
 202   if ((uintptr_t)heap_rs.end() &gt;= ObjArrayChunkedTask::max_addressable()) {
 203     FormatBuffer&lt;512&gt; buf(&quot;Shenandoah reserved [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT&quot;) for the heap, \n&quot;
 204                           &quot;but max object address is &quot; PTR_FORMAT &quot;. Try to reduce heap size, or try other \n&quot;
 205                           &quot;VM options that allocate heap at lower addresses (HeapBaseMinAddress, AllocateHeapAt, etc).&quot;,
 206                 p2i(heap_rs.base()), p2i(heap_rs.end()), ObjArrayChunkedTask::max_addressable());
 207     vm_exit_during_initialization(&quot;Fatal Error&quot;, buf);
 208   }
 209 #endif
 210 
 211   ReservedSpace sh_rs = heap_rs.first_part(max_byte_size);
 212   if (!_heap_region_special) {
 213     os::commit_memory_or_exit(sh_rs.base(), _initial_size, heap_alignment, false,
 214                               &quot;Cannot commit heap memory&quot;);
 215   }
 216 
 217   //
 218   // Reserve and commit memory for bitmap(s)
 219   //
 220 
 221   _bitmap_size = MarkBitMap::compute_size(heap_rs.size());
 222   _bitmap_size = align_up(_bitmap_size, bitmap_page_size);
 223 
 224   size_t bitmap_bytes_per_region = reg_size_bytes / MarkBitMap::heap_map_factor();
 225 
 226   guarantee(bitmap_bytes_per_region != 0,
 227             &quot;Bitmap bytes per region should not be zero&quot;);
 228   guarantee(is_power_of_2(bitmap_bytes_per_region),
 229             &quot;Bitmap bytes per region should be power of two: &quot; SIZE_FORMAT, bitmap_bytes_per_region);
 230 
 231   if (bitmap_page_size &gt; bitmap_bytes_per_region) {
 232     _bitmap_regions_per_slice = bitmap_page_size / bitmap_bytes_per_region;
 233     _bitmap_bytes_per_slice = bitmap_page_size;
 234   } else {
 235     _bitmap_regions_per_slice = 1;
 236     _bitmap_bytes_per_slice = bitmap_bytes_per_region;
 237   }
 238 
 239   guarantee(_bitmap_regions_per_slice &gt;= 1,
 240             &quot;Should have at least one region per slice: &quot; SIZE_FORMAT,
 241             _bitmap_regions_per_slice);
 242 
 243   guarantee(((_bitmap_bytes_per_slice) % bitmap_page_size) == 0,
 244             &quot;Bitmap slices should be page-granular: bps = &quot; SIZE_FORMAT &quot;, page size = &quot; SIZE_FORMAT,
 245             _bitmap_bytes_per_slice, bitmap_page_size);
 246 
 247   ReservedSpace bitmap(_bitmap_size, bitmap_page_size);
 248   MemTracker::record_virtual_memory_type(bitmap.base(), mtGC);
 249   _bitmap_region = MemRegion((HeapWord*) bitmap.base(), bitmap.size() / HeapWordSize);
 250   _bitmap_region_special = bitmap.special();
 251 
 252   size_t bitmap_init_commit = _bitmap_bytes_per_slice *
 253                               align_up(num_committed_regions, _bitmap_regions_per_slice) / _bitmap_regions_per_slice;
 254   bitmap_init_commit = MIN2(_bitmap_size, bitmap_init_commit);
 255   if (!_bitmap_region_special) {
 256     os::commit_memory_or_exit((char *) _bitmap_region.start(), bitmap_init_commit, bitmap_page_size, false,
 257                               &quot;Cannot commit bitmap memory&quot;);
 258   }
 259 
 260   _marking_context = new ShenandoahMarkingContext(_heap_region, _bitmap_region, _num_regions);
 261 
 262   if (ShenandoahVerify) {
 263     ReservedSpace verify_bitmap(_bitmap_size, bitmap_page_size);
 264     if (!verify_bitmap.special()) {
 265       os::commit_memory_or_exit(verify_bitmap.base(), verify_bitmap.size(), bitmap_page_size, false,
 266                                 &quot;Cannot commit verification bitmap memory&quot;);
 267     }
 268     MemTracker::record_virtual_memory_type(verify_bitmap.base(), mtGC);
 269     MemRegion verify_bitmap_region = MemRegion((HeapWord *) verify_bitmap.base(), verify_bitmap.size() / HeapWordSize);
 270     _verification_bit_map.initialize(_heap_region, verify_bitmap_region);
 271     _verifier = new ShenandoahVerifier(this, &amp;_verification_bit_map);
 272   }
 273 
 274   // Reserve aux bitmap for use in object_iterate(). We don&#39;t commit it here.
 275   ReservedSpace aux_bitmap(_bitmap_size, bitmap_page_size);
 276   MemTracker::record_virtual_memory_type(aux_bitmap.base(), mtGC);
 277   _aux_bitmap_region = MemRegion((HeapWord*) aux_bitmap.base(), aux_bitmap.size() / HeapWordSize);
 278   _aux_bitmap_region_special = aux_bitmap.special();
 279   _aux_bit_map.initialize(_heap_region, _aux_bitmap_region);
 280 
 281   //
 282   // Create regions and region sets
 283   //
 284   size_t region_align = align_up(sizeof(ShenandoahHeapRegion), SHENANDOAH_CACHE_LINE_SIZE);
 285   size_t region_storage_size = align_up(region_align * _num_regions, region_page_size);
 286   region_storage_size = align_up(region_storage_size, os::vm_allocation_granularity());
 287 
 288   ReservedSpace region_storage(region_storage_size, region_page_size);
 289   MemTracker::record_virtual_memory_type(region_storage.base(), mtGC);
 290   if (!region_storage.special()) {
 291     os::commit_memory_or_exit(region_storage.base(), region_storage_size, region_page_size, false,
 292                               &quot;Cannot commit region memory&quot;);
 293   }
 294 
 295   _regions = NEW_C_HEAP_ARRAY(ShenandoahHeapRegion*, _num_regions, mtGC);
 296   _free_set = new ShenandoahFreeSet(this, _num_regions);
 297   _collection_set = new ShenandoahCollectionSet(this, sh_rs.base(), sh_rs.size());
 298 
 299   {
 300     ShenandoahHeapLocker locker(lock());
 301 
 302     for (size_t i = 0; i &lt; _num_regions; i++) {
 303       HeapWord* start = (HeapWord*)sh_rs.base() + ShenandoahHeapRegion::region_size_words() * i;
 304       bool is_committed = i &lt; num_committed_regions;
 305       void* loc = region_storage.base() + i * region_align;
 306 
 307       ShenandoahHeapRegion* r = new (loc) ShenandoahHeapRegion(start, i, is_committed);
 308       assert(is_aligned(r, SHENANDOAH_CACHE_LINE_SIZE), &quot;Sanity&quot;);
 309 
 310       _marking_context-&gt;initialize_top_at_mark_start(r);
 311       _regions[i] = r;
 312       assert(!collection_set()-&gt;is_in(i), &quot;New region should not be in collection set&quot;);
 313     }
 314 
 315     // Initialize to complete
 316     _marking_context-&gt;mark_complete();
 317 
 318     _free_set-&gt;rebuild();
 319   }
 320 
 321   if (ShenandoahAlwaysPreTouch) {
 322     assert(!AlwaysPreTouch, &quot;Should have been overridden&quot;);
 323 
 324     // For NUMA, it is important to pre-touch the storage under bitmaps with worker threads,
 325     // before initialize() below zeroes it with initializing thread. For any given region,
 326     // we touch the region and the corresponding bitmaps from the same thread.
 327     ShenandoahPushWorkerScope scope(workers(), _max_workers, false);
 328 
 329     size_t pretouch_heap_page_size = heap_page_size;
 330     size_t pretouch_bitmap_page_size = bitmap_page_size;
 331 
 332 #ifdef LINUX
 333     // UseTransparentHugePages would madvise that backing memory can be coalesced into huge
 334     // pages. But, the kernel needs to know that every small page is used, in order to coalesce
 335     // them into huge one. Therefore, we need to pretouch with smaller pages.
 336     if (UseTransparentHugePages) {
 337       pretouch_heap_page_size = (size_t)os::vm_page_size();
 338       pretouch_bitmap_page_size = (size_t)os::vm_page_size();
 339     }
 340 #endif
 341 
 342     // OS memory managers may want to coalesce back-to-back pages. Make their jobs
 343     // simpler by pre-touching continuous spaces (heap and bitmap) separately.
 344 
 345     log_info(gc, init)(&quot;Pretouch bitmap: &quot; SIZE_FORMAT &quot; regions, &quot; SIZE_FORMAT &quot; bytes page&quot;,
 346                        _num_regions, pretouch_bitmap_page_size);
 347     ShenandoahPretouchBitmapTask bcl(bitmap.base(), _bitmap_size, pretouch_bitmap_page_size);
 348     _workers-&gt;run_task(&amp;bcl);
 349 
 350     log_info(gc, init)(&quot;Pretouch heap: &quot; SIZE_FORMAT &quot; regions, &quot; SIZE_FORMAT &quot; bytes page&quot;,
 351                        _num_regions, pretouch_heap_page_size);
 352     ShenandoahPretouchHeapTask hcl(pretouch_heap_page_size);
 353     _workers-&gt;run_task(&amp;hcl);
 354   }
 355 
 356   //
 357   // Initialize the rest of GC subsystems
 358   //
 359 
 360   _liveness_cache = NEW_C_HEAP_ARRAY(ShenandoahLiveData*, _max_workers, mtGC);
 361   for (uint worker = 0; worker &lt; _max_workers; worker++) {
 362     _liveness_cache[worker] = NEW_C_HEAP_ARRAY(ShenandoahLiveData, _num_regions, mtGC);
 363     Copy::fill_to_bytes(_liveness_cache[worker], _num_regions * sizeof(ShenandoahLiveData));
 364   }
 365 
 366   // There should probably be Shenandoah-specific options for these,
 367   // just as there are G1-specific options.
 368   {
 369     ShenandoahSATBMarkQueueSet&amp; satbqs = ShenandoahBarrierSet::satb_mark_queue_set();
 370     satbqs.set_process_completed_buffers_threshold(20); // G1SATBProcessCompletedThreshold
 371     satbqs.set_buffer_enqueue_threshold_percentage(60); // G1SATBBufferEnqueueingThresholdPercent
 372   }
 373 
 374   _monitoring_support = new ShenandoahMonitoringSupport(this);
 375   _phase_timings = new ShenandoahPhaseTimings();
 376   ShenandoahStringDedup::initialize();
 377   ShenandoahCodeRoots::initialize();
 378 
 379   if (ShenandoahPacing) {
 380     _pacer = new ShenandoahPacer(this);
 381     _pacer-&gt;setup_for_idle();
 382   } else {
 383     _pacer = NULL;
 384   }
 385 
 386   _control_thread = new ShenandoahControlThread();
 387 
 388   log_info(gc, init)(&quot;Initialize Shenandoah heap: &quot; SIZE_FORMAT &quot;%s initial, &quot; SIZE_FORMAT &quot;%s min, &quot; SIZE_FORMAT &quot;%s max&quot;,
 389                      byte_size_in_proper_unit(_initial_size),  proper_unit_for_byte_size(_initial_size),
 390                      byte_size_in_proper_unit(_minimum_size),  proper_unit_for_byte_size(_minimum_size),
 391                      byte_size_in_proper_unit(max_capacity()), proper_unit_for_byte_size(max_capacity())
 392   );
 393 
 394   log_info(gc, init)(&quot;Safepointing mechanism: thread-local poll&quot;);
 395 
 396   return JNI_OK;
 397 }
 398 
 399 void ShenandoahHeap::initialize_heuristics() {
 400   if (ShenandoahGCMode != NULL) {
 401     if (strcmp(ShenandoahGCMode, &quot;normal&quot;) == 0) {
 402       _gc_mode = new ShenandoahNormalMode();
 403     } else if (strcmp(ShenandoahGCMode, &quot;iu&quot;) == 0) {
 404       _gc_mode = new ShenandoahIUMode();
 405     } else if (strcmp(ShenandoahGCMode, &quot;passive&quot;) == 0) {
 406       _gc_mode = new ShenandoahPassiveMode();
 407     } else {
 408       vm_exit_during_initialization(&quot;Unknown -XX:ShenandoahGCMode option&quot;);
 409     }
 410   } else {
 411     ShouldNotReachHere();
 412   }
 413   _gc_mode-&gt;initialize_flags();
 414   if (_gc_mode-&gt;is_diagnostic() &amp;&amp; !UnlockDiagnosticVMOptions) {
 415     vm_exit_during_initialization(
 416             err_msg(&quot;GC mode \&quot;%s\&quot; is diagnostic, and must be enabled via -XX:+UnlockDiagnosticVMOptions.&quot;,
 417                     _gc_mode-&gt;name()));
 418   }
 419   if (_gc_mode-&gt;is_experimental() &amp;&amp; !UnlockExperimentalVMOptions) {
 420     vm_exit_during_initialization(
 421             err_msg(&quot;GC mode \&quot;%s\&quot; is experimental, and must be enabled via -XX:+UnlockExperimentalVMOptions.&quot;,
 422                     _gc_mode-&gt;name()));
 423   }
 424   log_info(gc, init)(&quot;Shenandoah GC mode: %s&quot;,
 425                      _gc_mode-&gt;name());
 426 
 427   _heuristics = _gc_mode-&gt;initialize_heuristics();
 428 
 429   if (_heuristics-&gt;is_diagnostic() &amp;&amp; !UnlockDiagnosticVMOptions) {
 430     vm_exit_during_initialization(
 431             err_msg(&quot;Heuristics \&quot;%s\&quot; is diagnostic, and must be enabled via -XX:+UnlockDiagnosticVMOptions.&quot;,
 432                     _heuristics-&gt;name()));
 433   }
 434   if (_heuristics-&gt;is_experimental() &amp;&amp; !UnlockExperimentalVMOptions) {
 435     vm_exit_during_initialization(
 436             err_msg(&quot;Heuristics \&quot;%s\&quot; is experimental, and must be enabled via -XX:+UnlockExperimentalVMOptions.&quot;,
 437                     _heuristics-&gt;name()));
 438   }
 439   log_info(gc, init)(&quot;Shenandoah heuristics: %s&quot;,
 440                      _heuristics-&gt;name());
 441 }
 442 
 443 #ifdef _MSC_VER
 444 #pragma warning( push )
 445 #pragma warning( disable:4355 ) // &#39;this&#39; : used in base member initializer list
 446 #endif
 447 
 448 ShenandoahHeap::ShenandoahHeap(ShenandoahCollectorPolicy* policy) :
 449   CollectedHeap(),
 450   _initial_size(0),
 451   _used(0),
 452   _committed(0),
 453   _bytes_allocated_since_gc_start(0),
 454   _max_workers(MAX2(ConcGCThreads, ParallelGCThreads)),
 455   _workers(NULL),
 456   _safepoint_workers(NULL),
 457   _heap_region_special(false),
 458   _num_regions(0),
 459   _regions(NULL),
 460   _update_refs_iterator(this),
 461   _control_thread(NULL),
 462   _shenandoah_policy(policy),
 463   _heuristics(NULL),
 464   _free_set(NULL),
 465   _scm(new ShenandoahConcurrentMark()),
 466   _full_gc(new ShenandoahMarkCompact()),
 467   _pacer(NULL),
 468   _verifier(NULL),
 469   _phase_timings(NULL),
 470   _monitoring_support(NULL),
 471   _memory_pool(NULL),
 472   _stw_memory_manager(&quot;Shenandoah Pauses&quot;, &quot;end of GC pause&quot;),
 473   _cycle_memory_manager(&quot;Shenandoah Cycles&quot;, &quot;end of GC cycle&quot;),
 474   _gc_timer(new (ResourceObj::C_HEAP, mtGC) ConcurrentGCTimer()),
 475   _soft_ref_policy(),
 476   _log_min_obj_alignment_in_bytes(LogMinObjAlignmentInBytes),
 477   _ref_processor(NULL),
 478   _marking_context(NULL),
 479   _bitmap_size(0),
 480   _bitmap_regions_per_slice(0),
 481   _bitmap_bytes_per_slice(0),
 482   _bitmap_region_special(false),
 483   _aux_bitmap_region_special(false),
 484   _liveness_cache(NULL),
 485   _collection_set(NULL)
 486 {
 487   _heap = this;
 488 
 489   log_info(gc, init)(&quot;GC threads: &quot; UINT32_FORMAT &quot; parallel, &quot; UINT32_FORMAT &quot; concurrent&quot;, ParallelGCThreads, ConcGCThreads);
 490   log_info(gc, init)(&quot;Reference processing: %s&quot;, ParallelRefProcEnabled ? &quot;parallel&quot; : &quot;serial&quot;);
 491 
 492   BarrierSet::set_barrier_set(new ShenandoahBarrierSet(this));
 493 
 494   _max_workers = MAX2(_max_workers, 1U);
 495   _workers = new ShenandoahWorkGang(&quot;Shenandoah GC Threads&quot;, _max_workers,
 496                             /* are_GC_task_threads */ true,
 497                             /* are_ConcurrentGC_threads */ true);
 498   if (_workers == NULL) {
 499     vm_exit_during_initialization(&quot;Failed necessary allocation.&quot;);
 500   } else {
 501     _workers-&gt;initialize_workers();
 502   }
 503 
 504   if (ParallelGCThreads &gt; 1) {
 505     _safepoint_workers = new ShenandoahWorkGang(&quot;Safepoint Cleanup Thread&quot;,
 506                                                 ParallelGCThreads,
 507                       /* are_GC_task_threads */ false,
 508                  /* are_ConcurrentGC_threads */ false);
 509     _safepoint_workers-&gt;initialize_workers();
 510   }
 511 }
 512 
 513 #ifdef _MSC_VER
 514 #pragma warning( pop )
 515 #endif
 516 
 517 class ShenandoahResetBitmapTask : public AbstractGangTask {
 518 private:
 519   ShenandoahRegionIterator _regions;
 520 
 521 public:
 522   ShenandoahResetBitmapTask() :
 523     AbstractGangTask(&quot;Parallel Reset Bitmap Task&quot;) {}
 524 
 525   void work(uint worker_id) {
 526     ShenandoahHeapRegion* region = _regions.next();
 527     ShenandoahHeap* heap = ShenandoahHeap::heap();
 528     ShenandoahMarkingContext* const ctx = heap-&gt;marking_context();
 529     while (region != NULL) {
 530       if (heap-&gt;is_bitmap_slice_committed(region)) {
 531         ctx-&gt;clear_bitmap(region);
 532       }
 533       region = _regions.next();
 534     }
 535   }
 536 };
 537 
 538 void ShenandoahHeap::reset_mark_bitmap() {
 539   assert_gc_workers(_workers-&gt;active_workers());
 540   mark_incomplete_marking_context();
 541 
 542   ShenandoahResetBitmapTask task;
 543   _workers-&gt;run_task(&amp;task);
 544 }
 545 
 546 void ShenandoahHeap::print_on(outputStream* st) const {
 547   st-&gt;print_cr(&quot;Shenandoah Heap&quot;);
 548   st-&gt;print_cr(&quot; &quot; SIZE_FORMAT &quot;%s total, &quot; SIZE_FORMAT &quot;%s committed, &quot; SIZE_FORMAT &quot;%s used&quot;,
 549                byte_size_in_proper_unit(max_capacity()), proper_unit_for_byte_size(max_capacity()),
 550                byte_size_in_proper_unit(committed()),    proper_unit_for_byte_size(committed()),
 551                byte_size_in_proper_unit(used()),         proper_unit_for_byte_size(used()));
 552   st-&gt;print_cr(&quot; &quot; SIZE_FORMAT &quot; x &quot; SIZE_FORMAT&quot;%s regions&quot;,
 553                num_regions(),
 554                byte_size_in_proper_unit(ShenandoahHeapRegion::region_size_bytes()),
 555                proper_unit_for_byte_size(ShenandoahHeapRegion::region_size_bytes()));
 556 
 557   st-&gt;print(&quot;Status: &quot;);
 558   if (has_forwarded_objects())               st-&gt;print(&quot;has forwarded objects, &quot;);
 559   if (is_concurrent_mark_in_progress())      st-&gt;print(&quot;marking, &quot;);
 560   if (is_evacuation_in_progress())           st-&gt;print(&quot;evacuating, &quot;);
 561   if (is_update_refs_in_progress())          st-&gt;print(&quot;updating refs, &quot;);
 562   if (is_degenerated_gc_in_progress())       st-&gt;print(&quot;degenerated gc, &quot;);
 563   if (is_full_gc_in_progress())              st-&gt;print(&quot;full gc, &quot;);
 564   if (is_full_gc_move_in_progress())         st-&gt;print(&quot;full gc move, &quot;);
 565   if (is_concurrent_root_in_progress())      st-&gt;print(&quot;concurrent roots, &quot;);
 566 
 567   if (cancelled_gc()) {
 568     st-&gt;print(&quot;cancelled&quot;);
 569   } else {
 570     st-&gt;print(&quot;not cancelled&quot;);
 571   }
 572   st-&gt;cr();
 573 
 574   st-&gt;print_cr(&quot;Reserved region:&quot;);
 575   st-&gt;print_cr(&quot; - [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;) &quot;,
 576                p2i(reserved_region().start()),
 577                p2i(reserved_region().end()));
 578 
 579   ShenandoahCollectionSet* cset = collection_set();
 580   st-&gt;print_cr(&quot;Collection set:&quot;);
 581   if (cset != NULL) {
 582     st-&gt;print_cr(&quot; - map (vanilla): &quot; PTR_FORMAT, p2i(cset-&gt;map_address()));
 583     st-&gt;print_cr(&quot; - map (biased):  &quot; PTR_FORMAT, p2i(cset-&gt;biased_map_address()));
 584   } else {
 585     st-&gt;print_cr(&quot; (NULL)&quot;);
 586   }
 587 
 588   st-&gt;cr();
 589   MetaspaceUtils::print_on(st);
 590 
 591   if (Verbose) {
 592     print_heap_regions_on(st);
 593   }
 594 }
 595 
 596 class ShenandoahInitWorkerGCLABClosure : public ThreadClosure {
 597 public:
 598   void do_thread(Thread* thread) {
 599     assert(thread != NULL, &quot;Sanity&quot;);
 600     assert(thread-&gt;is_Worker_thread(), &quot;Only worker thread expected&quot;);
 601     ShenandoahThreadLocalData::initialize_gclab(thread);
 602   }
 603 };
 604 
 605 void ShenandoahHeap::post_initialize() {
 606   CollectedHeap::post_initialize();
 607   MutexLocker ml(Threads_lock);
 608 
 609   ShenandoahInitWorkerGCLABClosure init_gclabs;
 610   _workers-&gt;threads_do(&amp;init_gclabs);
 611 
 612   // gclab can not be initialized early during VM startup, as it can not determinate its max_size.
 613   // Now, we will let WorkGang to initialize gclab when new worker is created.
 614   _workers-&gt;set_initialize_gclab();
 615 
 616   _scm-&gt;initialize(_max_workers);
 617   _full_gc-&gt;initialize(_gc_timer);
 618 
 619   ref_processing_init();
 620 
 621   _heuristics-&gt;initialize();
 622 
 623   JFR_ONLY(ShenandoahJFRSupport::register_jfr_type_serializers());
 624 }
 625 
 626 size_t ShenandoahHeap::used() const {
 627   return Atomic::load_acquire(&amp;_used);
 628 }
 629 
 630 size_t ShenandoahHeap::committed() const {
 631   OrderAccess::acquire();
 632   return _committed;
 633 }
 634 
 635 void ShenandoahHeap::increase_committed(size_t bytes) {
 636   shenandoah_assert_heaplocked_or_safepoint();
 637   _committed += bytes;
 638 }
 639 
 640 void ShenandoahHeap::decrease_committed(size_t bytes) {
 641   shenandoah_assert_heaplocked_or_safepoint();
 642   _committed -= bytes;
 643 }
 644 
 645 void ShenandoahHeap::increase_used(size_t bytes) {
 646   Atomic::add(&amp;_used, bytes);
 647 }
 648 
 649 void ShenandoahHeap::set_used(size_t bytes) {
 650   Atomic::release_store_fence(&amp;_used, bytes);
 651 }
 652 
 653 void ShenandoahHeap::decrease_used(size_t bytes) {
 654   assert(used() &gt;= bytes, &quot;never decrease heap size by more than we&#39;ve left&quot;);
 655   Atomic::sub(&amp;_used, bytes);
 656 }
 657 
 658 void ShenandoahHeap::increase_allocated(size_t bytes) {
 659   Atomic::add(&amp;_bytes_allocated_since_gc_start, bytes);
 660 }
 661 
 662 void ShenandoahHeap::notify_mutator_alloc_words(size_t words, bool waste) {
 663   size_t bytes = words * HeapWordSize;
 664   if (!waste) {
 665     increase_used(bytes);
 666   }
 667   increase_allocated(bytes);
 668   if (ShenandoahPacing) {
 669     control_thread()-&gt;pacing_notify_alloc(words);
 670     if (waste) {
 671       pacer()-&gt;claim_for_alloc(words, true);
 672     }
 673   }
 674 }
 675 
 676 size_t ShenandoahHeap::capacity() const {
 677   return committed();
 678 }
 679 
 680 size_t ShenandoahHeap::max_capacity() const {
 681   return _num_regions * ShenandoahHeapRegion::region_size_bytes();
 682 }
 683 
 684 size_t ShenandoahHeap::min_capacity() const {
 685   return _minimum_size;
 686 }
 687 
 688 size_t ShenandoahHeap::initial_capacity() const {
 689   return _initial_size;
 690 }
 691 
 692 bool ShenandoahHeap::is_in(const void* p) const {
 693   HeapWord* heap_base = (HeapWord*) base();
 694   HeapWord* last_region_end = heap_base + ShenandoahHeapRegion::region_size_words() * num_regions();
 695   return p &gt;= heap_base &amp;&amp; p &lt; last_region_end;
 696 }
 697 
 698 void ShenandoahHeap::op_uncommit(double shrink_before) {
 699   assert (ShenandoahUncommit, &quot;should be enabled&quot;);
 700 
 701   // Application allocates from the beginning of the heap, and GC allocates at
 702   // the end of it. It is more efficient to uncommit from the end, so that applications
 703   // could enjoy the near committed regions. GC allocations are much less frequent,
 704   // and therefore can accept the committing costs.
 705 
 706   size_t count = 0;
 707   for (size_t i = num_regions(); i &gt; 0; i--) { // care about size_t underflow
 708     ShenandoahHeapRegion* r = get_region(i - 1);
 709     if (r-&gt;is_empty_committed() &amp;&amp; (r-&gt;empty_time() &lt; shrink_before)) {
 710       ShenandoahHeapLocker locker(lock());
 711       if (r-&gt;is_empty_committed()) {
 712         // Do not uncommit below minimal capacity
 713         if (committed() &lt; min_capacity() + ShenandoahHeapRegion::region_size_bytes()) {
 714           break;
 715         }
 716 
 717         r-&gt;make_uncommitted();
 718         count++;
 719       }
 720     }
 721     SpinPause(); // allow allocators to take the lock
 722   }
 723 
 724   if (count &gt; 0) {
 725     control_thread()-&gt;notify_heap_changed();
 726   }
 727 }
 728 
 729 HeapWord* ShenandoahHeap::allocate_from_gclab_slow(Thread* thread, size_t size) {
 730   // New object should fit the GCLAB size
 731   size_t min_size = MAX2(size, PLAB::min_size());
 732 
 733   // Figure out size of new GCLAB, looking back at heuristics. Expand aggressively.
 734   size_t new_size = ShenandoahThreadLocalData::gclab_size(thread) * 2;
 735   new_size = MIN2(new_size, PLAB::max_size());
 736   new_size = MAX2(new_size, PLAB::min_size());
 737 
 738   // Record new heuristic value even if we take any shortcut. This captures
 739   // the case when moderately-sized objects always take a shortcut. At some point,
 740   // heuristics should catch up with them.
 741   ShenandoahThreadLocalData::set_gclab_size(thread, new_size);
 742 
 743   if (new_size &lt; size) {
 744     // New size still does not fit the object. Fall back to shared allocation.
 745     // This avoids retiring perfectly good GCLABs, when we encounter a large object.
 746     return NULL;
 747   }
 748 
 749   // Retire current GCLAB, and allocate a new one.
 750   PLAB* gclab = ShenandoahThreadLocalData::gclab(thread);
 751   gclab-&gt;retire();
 752 
 753   size_t actual_size = 0;
 754   HeapWord* gclab_buf = allocate_new_gclab(min_size, new_size, &amp;actual_size);
 755   if (gclab_buf == NULL) {
 756     return NULL;
 757   }
 758 
 759   assert (size &lt;= actual_size, &quot;allocation should fit&quot;);
 760 
 761   if (ZeroTLAB) {
 762     // ..and clear it.
 763     Copy::zero_to_words(gclab_buf, actual_size);
 764   } else {
 765     // ...and zap just allocated object.
 766 #ifdef ASSERT
 767     // Skip mangling the space corresponding to the object header to
 768     // ensure that the returned space is not considered parsable by
 769     // any concurrent GC thread.
 770     size_t hdr_size = oopDesc::header_size();
 771     Copy::fill_to_words(gclab_buf + hdr_size, actual_size - hdr_size, badHeapWordVal);
 772 #endif // ASSERT
 773   }
 774   gclab-&gt;set_buf(gclab_buf, actual_size);
 775   return gclab-&gt;allocate(size);
 776 }
 777 
 778 HeapWord* ShenandoahHeap::allocate_new_tlab(size_t min_size,
 779                                             size_t requested_size,
 780                                             size_t* actual_size) {
 781   ShenandoahAllocRequest req = ShenandoahAllocRequest::for_tlab(min_size, requested_size);
 782   HeapWord* res = allocate_memory(req);
 783   if (res != NULL) {
 784     *actual_size = req.actual_size();
 785   } else {
 786     *actual_size = 0;
 787   }
 788   return res;
 789 }
 790 
 791 HeapWord* ShenandoahHeap::allocate_new_gclab(size_t min_size,
 792                                              size_t word_size,
 793                                              size_t* actual_size) {
 794   ShenandoahAllocRequest req = ShenandoahAllocRequest::for_gclab(min_size, word_size);
 795   HeapWord* res = allocate_memory(req);
 796   if (res != NULL) {
 797     *actual_size = req.actual_size();
 798   } else {
 799     *actual_size = 0;
 800   }
 801   return res;
 802 }
 803 
 804 HeapWord* ShenandoahHeap::allocate_memory(ShenandoahAllocRequest&amp; req) {
 805   intptr_t pacer_epoch = 0;
 806   bool in_new_region = false;
 807   HeapWord* result = NULL;
 808 
 809   if (req.is_mutator_alloc()) {
 810     if (ShenandoahPacing) {
 811       pacer()-&gt;pace_for_alloc(req.size());
 812       pacer_epoch = pacer()-&gt;epoch();
 813     }
 814 
 815     if (!ShenandoahAllocFailureALot || !should_inject_alloc_failure()) {
 816       result = allocate_memory_under_lock(req, in_new_region);
 817     }
 818 
 819     // Allocation failed, block until control thread reacted, then retry allocation.
 820     //
 821     // It might happen that one of the threads requesting allocation would unblock
 822     // way later after GC happened, only to fail the second allocation, because
 823     // other threads have already depleted the free storage. In this case, a better
 824     // strategy is to try again, as long as GC makes progress.
 825     //
 826     // Then, we need to make sure the allocation was retried after at least one
 827     // Full GC, which means we want to try more than ShenandoahFullGCThreshold times.
 828 
 829     size_t tries = 0;
 830 
 831     while (result == NULL &amp;&amp; _progress_last_gc.is_set()) {
 832       tries++;
 833       control_thread()-&gt;handle_alloc_failure(req);
 834       result = allocate_memory_under_lock(req, in_new_region);
 835     }
 836 
 837     while (result == NULL &amp;&amp; tries &lt;= ShenandoahFullGCThreshold) {
 838       tries++;
 839       control_thread()-&gt;handle_alloc_failure(req);
 840       result = allocate_memory_under_lock(req, in_new_region);
 841     }
 842 
 843   } else {
 844     assert(req.is_gc_alloc(), &quot;Can only accept GC allocs here&quot;);
 845     result = allocate_memory_under_lock(req, in_new_region);
 846     // Do not call handle_alloc_failure() here, because we cannot block.
 847     // The allocation failure would be handled by the LRB slowpath with handle_alloc_failure_evac().
 848   }
 849 
 850   if (in_new_region) {
 851     control_thread()-&gt;notify_heap_changed();
 852   }
 853 
 854   if (result != NULL) {
 855     size_t requested = req.size();
 856     size_t actual = req.actual_size();
 857 
 858     assert (req.is_lab_alloc() || (requested == actual),
 859             &quot;Only LAB allocations are elastic: %s, requested = &quot; SIZE_FORMAT &quot;, actual = &quot; SIZE_FORMAT,
 860             ShenandoahAllocRequest::alloc_type_to_string(req.type()), requested, actual);
 861 
 862     if (req.is_mutator_alloc()) {
 863       notify_mutator_alloc_words(actual, false);
 864 
 865       // If we requested more than we were granted, give the rest back to pacer.
 866       // This only matters if we are in the same pacing epoch: do not try to unpace
 867       // over the budget for the other phase.
 868       if (ShenandoahPacing &amp;&amp; (pacer_epoch &gt; 0) &amp;&amp; (requested &gt; actual)) {
 869         pacer()-&gt;unpace_for_alloc(pacer_epoch, requested - actual);
 870       }
 871     } else {
 872       increase_used(actual*HeapWordSize);
 873     }
 874   }
 875 
 876   return result;
 877 }
 878 
 879 HeapWord* ShenandoahHeap::allocate_memory_under_lock(ShenandoahAllocRequest&amp; req, bool&amp; in_new_region) {
 880   ShenandoahHeapLocker locker(lock());
 881   return _free_set-&gt;allocate(req, in_new_region);
 882 }
 883 
 884 HeapWord* ShenandoahHeap::mem_allocate(size_t size,
 885                                         bool*  gc_overhead_limit_was_exceeded) {
 886   ShenandoahAllocRequest req = ShenandoahAllocRequest::for_shared(size);
 887   return allocate_memory(req);
 888 }
 889 
 890 MetaWord* ShenandoahHeap::satisfy_failed_metadata_allocation(ClassLoaderData* loader_data,
 891                                                              size_t size,
 892                                                              Metaspace::MetadataType mdtype) {
 893   MetaWord* result;
 894 
 895   // Inform metaspace OOM to GC heuristics if class unloading is possible.
 896   if (heuristics()-&gt;can_unload_classes()) {
 897     ShenandoahHeuristics* h = heuristics();
 898     h-&gt;record_metaspace_oom();
 899   }
 900 
 901   // Expand and retry allocation
 902   result = loader_data-&gt;metaspace_non_null()-&gt;expand_and_allocate(size, mdtype);
 903   if (result != NULL) {
 904     return result;
 905   }
 906 
 907   // Start full GC
 908   collect(GCCause::_metadata_GC_clear_soft_refs);
 909 
 910   // Retry allocation
 911   result = loader_data-&gt;metaspace_non_null()-&gt;allocate(size, mdtype);
 912   if (result != NULL) {
 913     return result;
 914   }
 915 
 916   // Expand and retry allocation
 917   result = loader_data-&gt;metaspace_non_null()-&gt;expand_and_allocate(size, mdtype);
 918   if (result != NULL) {
 919     return result;
 920   }
 921 
 922   // Out of memory
 923   return NULL;
 924 }
 925 
 926 class ShenandoahConcurrentEvacuateRegionObjectClosure : public ObjectClosure {
 927 private:
 928   ShenandoahHeap* const _heap;
 929   Thread* const _thread;
 930 public:
 931   ShenandoahConcurrentEvacuateRegionObjectClosure(ShenandoahHeap* heap) :
 932     _heap(heap), _thread(Thread::current()) {}
 933 
 934   void do_object(oop p) {
 935     shenandoah_assert_marked(NULL, p);
 936     if (!p-&gt;is_forwarded()) {
 937       _heap-&gt;evacuate_object(p, _thread);
 938     }
 939   }
 940 };
 941 
 942 class ShenandoahEvacuationTask : public AbstractGangTask {
 943 private:
 944   ShenandoahHeap* const _sh;
 945   ShenandoahCollectionSet* const _cs;
 946   bool _concurrent;
 947 public:
 948   ShenandoahEvacuationTask(ShenandoahHeap* sh,
 949                            ShenandoahCollectionSet* cs,
 950                            bool concurrent) :
 951     AbstractGangTask(&quot;Parallel Evacuation Task&quot;),
 952     _sh(sh),
 953     _cs(cs),
 954     _concurrent(concurrent)
 955   {}
 956 
 957   void work(uint worker_id) {
 958     if (_concurrent) {
 959       ShenandoahConcurrentWorkerSession worker_session(worker_id);
 960       ShenandoahSuspendibleThreadSetJoiner stsj(ShenandoahSuspendibleWorkers);
 961       ShenandoahEvacOOMScope oom_evac_scope;
 962       do_work();
 963     } else {
 964       ShenandoahParallelWorkerSession worker_session(worker_id);
 965       ShenandoahEvacOOMScope oom_evac_scope;
 966       do_work();
 967     }
 968   }
 969 
 970 private:
 971   void do_work() {
 972     ShenandoahConcurrentEvacuateRegionObjectClosure cl(_sh);
 973     ShenandoahHeapRegion* r;
 974     while ((r =_cs-&gt;claim_next()) != NULL) {
 975       assert(r-&gt;has_live(), &quot;Region &quot; SIZE_FORMAT &quot; should have been reclaimed early&quot;, r-&gt;index());
 976       _sh-&gt;marked_object_iterate(r, &amp;cl);
 977 
 978       if (ShenandoahPacing) {
 979         _sh-&gt;pacer()-&gt;report_evac(r-&gt;used() &gt;&gt; LogHeapWordSize);
 980       }
 981 
 982       if (_sh-&gt;check_cancelled_gc_and_yield(_concurrent)) {
 983         break;
 984       }
 985     }
 986   }
 987 };
 988 
 989 void ShenandoahHeap::trash_cset_regions() {
 990   ShenandoahHeapLocker locker(lock());
 991 
 992   ShenandoahCollectionSet* set = collection_set();
 993   ShenandoahHeapRegion* r;
 994   set-&gt;clear_current_index();
 995   while ((r = set-&gt;next()) != NULL) {
 996     r-&gt;make_trash();
 997   }
 998   collection_set()-&gt;clear();
 999 }
1000 
1001 void ShenandoahHeap::print_heap_regions_on(outputStream* st) const {
1002   st-&gt;print_cr(&quot;Heap Regions:&quot;);
1003   st-&gt;print_cr(&quot;EU=empty-uncommitted, EC=empty-committed, R=regular, H=humongous start, HC=humongous continuation, CS=collection set, T=trash, P=pinned&quot;);
1004   st-&gt;print_cr(&quot;BTE=bottom/top/end, U=used, T=TLAB allocs, G=GCLAB allocs, S=shared allocs, L=live data&quot;);
1005   st-&gt;print_cr(&quot;R=root, CP=critical pins, TAMS=top-at-mark-start, UWM=update watermark&quot;);
1006   st-&gt;print_cr(&quot;SN=alloc sequence number&quot;);
1007 
1008   for (size_t i = 0; i &lt; num_regions(); i++) {
1009     get_region(i)-&gt;print_on(st);
1010   }
1011 }
1012 
1013 void ShenandoahHeap::trash_humongous_region_at(ShenandoahHeapRegion* start) {
1014   assert(start-&gt;is_humongous_start(), &quot;reclaim regions starting with the first one&quot;);
1015 
1016   oop humongous_obj = oop(start-&gt;bottom());
1017   size_t size = humongous_obj-&gt;size();
1018   size_t required_regions = ShenandoahHeapRegion::required_regions(size * HeapWordSize);
1019   size_t index = start-&gt;index() + required_regions - 1;
1020 
1021   assert(!start-&gt;has_live(), &quot;liveness must be zero&quot;);
1022 
1023   for(size_t i = 0; i &lt; required_regions; i++) {
1024     // Reclaim from tail. Otherwise, assertion fails when printing region to trace log,
1025     // as it expects that every region belongs to a humongous region starting with a humongous start region.
1026     ShenandoahHeapRegion* region = get_region(index --);
1027 
1028     assert(region-&gt;is_humongous(), &quot;expect correct humongous start or continuation&quot;);
1029     assert(!region-&gt;is_cset(), &quot;Humongous region should not be in collection set&quot;);
1030 
1031     region-&gt;make_trash_immediate();
1032   }
1033 }
1034 
1035 class ShenandoahRetireGCLABClosure : public ThreadClosure {
1036 public:
1037   void do_thread(Thread* thread) {
1038     PLAB* gclab = ShenandoahThreadLocalData::gclab(thread);
1039     assert(gclab != NULL, &quot;GCLAB should be initialized for %s&quot;, thread-&gt;name());
1040     gclab-&gt;retire();
1041   }
1042 };
1043 
1044 void ShenandoahHeap::make_parsable(bool retire_tlabs) {
1045   if (UseTLAB) {
1046     CollectedHeap::ensure_parsability(retire_tlabs);
1047   }
1048   ShenandoahRetireGCLABClosure cl;
1049   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *t = jtiwh.next(); ) {
1050     cl.do_thread(t);
1051   }
1052   workers()-&gt;threads_do(&amp;cl);
1053 }
1054 
1055 void ShenandoahHeap::resize_tlabs() {
1056   CollectedHeap::resize_all_tlabs();
1057 }
1058 
1059 class ShenandoahEvacuateUpdateRootsTask : public AbstractGangTask {
1060 private:
1061   ShenandoahRootEvacuator* _rp;
1062 
1063 public:
1064   ShenandoahEvacuateUpdateRootsTask(ShenandoahRootEvacuator* rp) :
1065     AbstractGangTask(&quot;Shenandoah evacuate and update roots&quot;),
1066     _rp(rp) {}
1067 
1068   void work(uint worker_id) {
1069     ShenandoahParallelWorkerSession worker_session(worker_id);
1070     ShenandoahEvacOOMScope oom_evac_scope;
1071     ShenandoahEvacuateUpdateRootsClosure&lt;&gt; cl;
1072     MarkingCodeBlobClosure blobsCl(&amp;cl, CodeBlobToOopClosure::FixRelocations);
1073     _rp-&gt;roots_do(worker_id, &amp;cl);
1074   }
1075 };
1076 
1077 void ShenandoahHeap::evacuate_and_update_roots() {
1078 #if COMPILER2_OR_JVMCI
1079   DerivedPointerTable::clear();
1080 #endif
1081   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Only iterate roots while world is stopped&quot;);
1082   {
1083     // Include concurrent roots if current cycle can not process those roots concurrently
1084     ShenandoahRootEvacuator rp(workers()-&gt;active_workers(),
1085                                ShenandoahPhaseTimings::init_evac,
1086                                !ShenandoahConcurrentRoots::should_do_concurrent_roots(),
1087                                !ShenandoahConcurrentRoots::should_do_concurrent_class_unloading());
1088     ShenandoahEvacuateUpdateRootsTask roots_task(&amp;rp);
1089     workers()-&gt;run_task(&amp;roots_task);
1090   }
1091 
1092 #if COMPILER2_OR_JVMCI
1093   DerivedPointerTable::update_pointers();
1094 #endif
1095 }
1096 
1097 // Returns size in bytes
1098 size_t ShenandoahHeap::unsafe_max_tlab_alloc(Thread *thread) const {
1099   if (ShenandoahElasticTLAB) {
1100     // With Elastic TLABs, return the max allowed size, and let the allocation path
1101     // figure out the safe size for current allocation.
1102     return ShenandoahHeapRegion::max_tlab_size_bytes();
1103   } else {
1104     return MIN2(_free_set-&gt;unsafe_peek_free(), ShenandoahHeapRegion::max_tlab_size_bytes());
1105   }
1106 }
1107 
1108 size_t ShenandoahHeap::max_tlab_size() const {
1109   // Returns size in words
1110   return ShenandoahHeapRegion::max_tlab_size_words();
1111 }
1112 
1113 class ShenandoahRetireAndResetGCLABClosure : public ThreadClosure {
1114 public:
1115   void do_thread(Thread* thread) {
1116     PLAB* gclab = ShenandoahThreadLocalData::gclab(thread);
1117     gclab-&gt;retire();
1118     if (ShenandoahThreadLocalData::gclab_size(thread) &gt; 0) {
1119       ShenandoahThreadLocalData::set_gclab_size(thread, 0);
1120     }
1121   }
1122 };
1123 
1124 void ShenandoahHeap::retire_and_reset_gclabs() {
1125   ShenandoahRetireAndResetGCLABClosure cl;
1126   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *t = jtiwh.next(); ) {
1127     cl.do_thread(t);
1128   }
1129   workers()-&gt;threads_do(&amp;cl);
1130 }
1131 
1132 void ShenandoahHeap::collect(GCCause::Cause cause) {
1133   control_thread()-&gt;request_gc(cause);
1134 }
1135 
1136 void ShenandoahHeap::do_full_collection(bool clear_all_soft_refs) {
1137   //assert(false, &quot;Shouldn&#39;t need to do full collections&quot;);
1138 }
1139 
1140 HeapWord* ShenandoahHeap::block_start(const void* addr) const {
1141   ShenandoahHeapRegion* r = heap_region_containing(addr);
1142   if (r != NULL) {
1143     return r-&gt;block_start(addr);
1144   }
1145   return NULL;
1146 }
1147 
1148 bool ShenandoahHeap::block_is_obj(const HeapWord* addr) const {
1149   ShenandoahHeapRegion* r = heap_region_containing(addr);
1150   return r-&gt;block_is_obj(addr);
1151 }
1152 
1153 bool ShenandoahHeap::print_location(outputStream* st, void* addr) const {
1154   return BlockLocationPrinter&lt;ShenandoahHeap&gt;::print_location(st, addr);
1155 }
1156 
1157 jlong ShenandoahHeap::millis_since_last_gc() {
1158   double v = heuristics()-&gt;time_since_last_gc() * 1000;
1159   assert(0 &lt;= v &amp;&amp; v &lt;= max_jlong, &quot;value should fit: %f&quot;, v);
1160   return (jlong)v;
1161 }
1162 
1163 void ShenandoahHeap::prepare_for_verify() {
1164   if (SafepointSynchronize::is_at_safepoint() || ! UseTLAB) {
1165     make_parsable(false);
1166   }
1167 }
1168 
1169 void ShenandoahHeap::print_gc_threads_on(outputStream* st) const {
1170   workers()-&gt;print_worker_threads_on(st);
1171   if (ShenandoahStringDedup::is_enabled()) {
1172     ShenandoahStringDedup::print_worker_threads_on(st);
1173   }
1174 }
1175 
1176 void ShenandoahHeap::gc_threads_do(ThreadClosure* tcl) const {
1177   workers()-&gt;threads_do(tcl);
1178   if (_safepoint_workers != NULL) {
1179     _safepoint_workers-&gt;threads_do(tcl);
1180   }
1181   if (ShenandoahStringDedup::is_enabled()) {
1182     ShenandoahStringDedup::threads_do(tcl);
1183   }
1184 }
1185 
1186 void ShenandoahHeap::print_tracing_info() const {
1187   LogTarget(Info, gc, stats) lt;
1188   if (lt.is_enabled()) {
1189     ResourceMark rm;
1190     LogStream ls(lt);
1191 
1192     phase_timings()-&gt;print_on(&amp;ls);
1193 
1194     ls.cr();
1195     ls.cr();
1196 
1197     shenandoah_policy()-&gt;print_gc_stats(&amp;ls);
1198 
1199     ls.cr();
1200     ls.cr();
1201 
1202     if (ShenandoahPacing) {
1203       pacer()-&gt;print_on(&amp;ls);
1204     }
1205 
1206     ls.cr();
1207     ls.cr();
1208   }
1209 }
1210 
1211 void ShenandoahHeap::verify(VerifyOption vo) {
1212   if (ShenandoahSafepoint::is_at_shenandoah_safepoint()) {
1213     if (ShenandoahVerify) {
1214       verifier()-&gt;verify_generic(vo);
1215     } else {
1216       // TODO: Consider allocating verification bitmaps on demand,
1217       // and turn this on unconditionally.
1218     }
1219   }
1220 }
1221 size_t ShenandoahHeap::tlab_capacity(Thread *thr) const {
1222   return _free_set-&gt;capacity();
1223 }
1224 
1225 class ObjectIterateScanRootClosure : public BasicOopIterateClosure {
1226 private:
1227   MarkBitMap* _bitmap;
1228   Stack&lt;oop,mtGC&gt;* _oop_stack;
1229   ShenandoahHeap* const _heap;
1230   ShenandoahMarkingContext* const _marking_context;
1231 
1232   template &lt;class T&gt;
1233   void do_oop_work(T* p) {
1234     T o = RawAccess&lt;&gt;::oop_load(p);
1235     if (!CompressedOops::is_null(o)) {
1236       oop obj = CompressedOops::decode_not_null(o);
1237       if (_heap-&gt;is_concurrent_root_in_progress() &amp;&amp; !_marking_context-&gt;is_marked(obj)) {
1238         // There may be dead oops in weak roots in concurrent root phase, do not touch them.
1239         return;
1240       }
1241       obj = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);
1242 
1243       assert(oopDesc::is_oop(obj), &quot;must be a valid oop&quot;);
1244       if (!_bitmap-&gt;is_marked(obj)) {
1245         _bitmap-&gt;mark(obj);
1246         _oop_stack-&gt;push(obj);
1247       }
1248     }
1249   }
1250 public:
1251   ObjectIterateScanRootClosure(MarkBitMap* bitmap, Stack&lt;oop,mtGC&gt;* oop_stack) :
1252     _bitmap(bitmap), _oop_stack(oop_stack), _heap(ShenandoahHeap::heap()),
1253     _marking_context(_heap-&gt;marking_context()) {}
1254   void do_oop(oop* p)       { do_oop_work(p); }
1255   void do_oop(narrowOop* p) { do_oop_work(p); }
1256 };
1257 
1258 /*
1259  * This is public API, used in preparation of object_iterate().
1260  * Since we don&#39;t do linear scan of heap in object_iterate() (see comment below), we don&#39;t
1261  * need to make the heap parsable. For Shenandoah-internal linear heap scans that we can
1262  * control, we call SH::make_tlabs_parsable().
1263  */
1264 void ShenandoahHeap::ensure_parsability(bool retire_tlabs) {
1265   // No-op.
1266 }
1267 
1268 /*
1269  * Iterates objects in the heap. This is public API, used for, e.g., heap dumping.
1270  *
1271  * We cannot safely iterate objects by doing a linear scan at random points in time. Linear
1272  * scanning needs to deal with dead objects, which may have dead Klass* pointers (e.g.
1273  * calling oopDesc::size() would crash) or dangling reference fields (crashes) etc. Linear
1274  * scanning therefore depends on having a valid marking bitmap to support it. However, we only
1275  * have a valid marking bitmap after successful marking. In particular, we *don&#39;t* have a valid
1276  * marking bitmap during marking, after aborted marking or during/after cleanup (when we just
1277  * wiped the bitmap in preparation for next marking).
1278  *
1279  * For all those reasons, we implement object iteration as a single marking traversal, reporting
1280  * objects as we mark+traverse through the heap, starting from GC roots. JVMTI IterateThroughHeap
1281  * is allowed to report dead objects, but is not required to do so.
1282  */
1283 void ShenandoahHeap::object_iterate(ObjectClosure* cl) {
1284   assert(SafepointSynchronize::is_at_safepoint(), &quot;safe iteration is only available during safepoints&quot;);
1285   if (!_aux_bitmap_region_special &amp;&amp; !os::commit_memory((char*)_aux_bitmap_region.start(), _aux_bitmap_region.byte_size(), false)) {
1286     log_warning(gc)(&quot;Could not commit native memory for auxiliary marking bitmap for heap iteration&quot;);
1287     return;
1288   }
1289 
1290   // Reset bitmap
1291   _aux_bit_map.clear();
1292 
1293   Stack&lt;oop,mtGC&gt; oop_stack;
1294 
1295   // First, we process GC roots according to current GC cycle. This populates the work stack with initial objects.
1296   ShenandoahHeapIterationRootScanner rp;
1297   ObjectIterateScanRootClosure oops(&amp;_aux_bit_map, &amp;oop_stack);
1298 
1299   rp.roots_do(&amp;oops);
1300 
1301   // Work through the oop stack to traverse heap.
1302   while (! oop_stack.is_empty()) {
1303     oop obj = oop_stack.pop();
1304     assert(oopDesc::is_oop(obj), &quot;must be a valid oop&quot;);
1305     cl-&gt;do_object(obj);
1306     obj-&gt;oop_iterate(&amp;oops);
1307   }
1308 
1309   assert(oop_stack.is_empty(), &quot;should be empty&quot;);
1310 
1311   if (!_aux_bitmap_region_special &amp;&amp; !os::uncommit_memory((char*)_aux_bitmap_region.start(), _aux_bitmap_region.byte_size())) {
1312     log_warning(gc)(&quot;Could not uncommit native memory for auxiliary marking bitmap for heap iteration&quot;);
1313   }
1314 }
1315 
1316 // Keep alive an object that was loaded with AS_NO_KEEPALIVE.
1317 void ShenandoahHeap::keep_alive(oop obj) {
1318   if (is_concurrent_mark_in_progress()) {
1319     ShenandoahBarrierSet::barrier_set()-&gt;enqueue(obj);
1320   }
1321 }
1322 
1323 void ShenandoahHeap::heap_region_iterate(ShenandoahHeapRegionClosure* blk) const {
1324   for (size_t i = 0; i &lt; num_regions(); i++) {
1325     ShenandoahHeapRegion* current = get_region(i);
1326     blk-&gt;heap_region_do(current);
1327   }
1328 }
1329 
1330 class ShenandoahParallelHeapRegionTask : public AbstractGangTask {
1331 private:
1332   ShenandoahHeap* const _heap;
1333   ShenandoahHeapRegionClosure* const _blk;
1334 
1335   shenandoah_padding(0);
1336   volatile size_t _index;
1337   shenandoah_padding(1);
1338 
1339 public:
1340   ShenandoahParallelHeapRegionTask(ShenandoahHeapRegionClosure* blk) :
1341           AbstractGangTask(&quot;Parallel Region Task&quot;),
1342           _heap(ShenandoahHeap::heap()), _blk(blk), _index(0) {}
1343 
1344   void work(uint worker_id) {
1345     size_t stride = ShenandoahParallelRegionStride;
1346 
1347     size_t max = _heap-&gt;num_regions();
1348     while (_index &lt; max) {
1349       size_t cur = Atomic::fetch_and_add(&amp;_index, stride);
1350       size_t start = cur;
1351       size_t end = MIN2(cur + stride, max);
1352       if (start &gt;= max) break;
1353 
1354       for (size_t i = cur; i &lt; end; i++) {
1355         ShenandoahHeapRegion* current = _heap-&gt;get_region(i);
1356         _blk-&gt;heap_region_do(current);
1357       }
1358     }
1359   }
1360 };
1361 
1362 void ShenandoahHeap::parallel_heap_region_iterate(ShenandoahHeapRegionClosure* blk) const {
1363   assert(blk-&gt;is_thread_safe(), &quot;Only thread-safe closures here&quot;);
1364   if (num_regions() &gt; ShenandoahParallelRegionStride) {
1365     ShenandoahParallelHeapRegionTask task(blk);
1366     workers()-&gt;run_task(&amp;task);
1367   } else {
1368     heap_region_iterate(blk);
1369   }
1370 }
1371 
1372 class ShenandoahInitMarkUpdateRegionStateClosure : public ShenandoahHeapRegionClosure {
1373 private:
1374   ShenandoahMarkingContext* const _ctx;
1375 public:
1376   ShenandoahInitMarkUpdateRegionStateClosure() : _ctx(ShenandoahHeap::heap()-&gt;marking_context()) {}
1377 
1378   void heap_region_do(ShenandoahHeapRegion* r) {
1379     if (r-&gt;is_active()) {
1380       r-&gt;clear_live_data();
1381       _ctx-&gt;capture_top_at_mark_start(r);
1382     } else {
1383       assert(!r-&gt;has_live(), &quot;Region &quot; SIZE_FORMAT &quot; should have no live data&quot;, r-&gt;index());
1384       assert(_ctx-&gt;top_at_mark_start(r) == r-&gt;top(),
1385              &quot;Region &quot; SIZE_FORMAT &quot; should already have correct TAMS&quot;, r-&gt;index());
1386     }
1387   }
1388 
1389   bool is_thread_safe() { return true; }
1390 };
1391 
1392 void ShenandoahHeap::op_init_mark() {
1393   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Should be at safepoint&quot;);
1394   assert(Thread::current()-&gt;is_VM_thread(), &quot;can only do this in VMThread&quot;);
1395 
1396   assert(marking_context()-&gt;is_bitmap_clear(), &quot;need clear marking bitmap&quot;);
1397   assert(!marking_context()-&gt;is_complete(), &quot;should not be complete&quot;);
1398   assert(!has_forwarded_objects(), &quot;No forwarded objects on this path&quot;);
1399 
1400   if (ShenandoahVerify) {
1401     verifier()-&gt;verify_before_concmark();
1402   }
1403 
1404   if (VerifyBeforeGC) {
1405     Universe::verify();
1406   }
1407 
1408   set_concurrent_mark_in_progress(true);
1409   // We need to reset all TLABs because we&#39;d lose marks on all objects allocated in them.
1410   {
1411     ShenandoahGCSubPhase phase(ShenandoahPhaseTimings::make_parsable);
1412     make_parsable(true);
1413   }
1414 
1415   {
1416     ShenandoahGCSubPhase phase(ShenandoahPhaseTimings::init_update_region_states);
1417     ShenandoahInitMarkUpdateRegionStateClosure cl;
1418     parallel_heap_region_iterate(&amp;cl);
1419   }
1420 
1421   // Make above changes visible to worker threads
1422   OrderAccess::fence();
1423 
1424   concurrent_mark()-&gt;mark_roots(ShenandoahPhaseTimings::scan_roots);
1425 
1426   if (UseTLAB) {
1427     ShenandoahGCSubPhase phase(ShenandoahPhaseTimings::resize_tlabs);
1428     resize_tlabs();
1429   }
1430 
1431   if (ShenandoahPacing) {
1432     pacer()-&gt;setup_for_mark();
1433   }
1434 
1435   // Arm nmethods for concurrent marking. When a nmethod is about to be executed,
1436   // we need to make sure that all its metadata are marked. alternative is to remark
1437   // thread roots at final mark pause, but it can be potential latency killer.
1438   if (ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {
1439     ShenandoahCodeRoots::arm_nmethods();
1440   }
1441 }
1442 
1443 void ShenandoahHeap::op_mark() {
1444   concurrent_mark()-&gt;mark_from_roots();
1445 }
1446 
1447 class ShenandoahFinalMarkUpdateRegionStateClosure : public ShenandoahHeapRegionClosure {
1448 private:
1449   ShenandoahMarkingContext* const _ctx;
1450   ShenandoahHeapLock* const _lock;
1451 
1452 public:
1453   ShenandoahFinalMarkUpdateRegionStateClosure() :
1454     _ctx(ShenandoahHeap::heap()-&gt;complete_marking_context()), _lock(ShenandoahHeap::heap()-&gt;lock()) {}
1455 
1456   void heap_region_do(ShenandoahHeapRegion* r) {
1457     if (r-&gt;is_active()) {
1458       // All allocations past TAMS are implicitly live, adjust the region data.
1459       // Bitmaps/TAMS are swapped at this point, so we need to poll complete bitmap.
1460       HeapWord *tams = _ctx-&gt;top_at_mark_start(r);
1461       HeapWord *top = r-&gt;top();
1462       if (top &gt; tams) {
1463         r-&gt;increase_live_data_alloc_words(pointer_delta(top, tams));
1464       }
1465 
1466       // We are about to select the collection set, make sure it knows about
1467       // current pinning status. Also, this allows trashing more regions that
1468       // now have their pinning status dropped.
1469       if (r-&gt;is_pinned()) {
1470         if (r-&gt;pin_count() == 0) {
1471           ShenandoahHeapLocker locker(_lock);
1472           r-&gt;make_unpinned();
1473         }
1474       } else {
1475         if (r-&gt;pin_count() &gt; 0) {
1476           ShenandoahHeapLocker locker(_lock);
1477           r-&gt;make_pinned();
1478         }
1479       }
1480 
1481       // Remember limit for updating refs. It&#39;s guaranteed that we get no
1482       // from-space-refs written from here on.
1483       r-&gt;set_update_watermark(r-&gt;top());
1484     } else {
1485       assert(!r-&gt;has_live(), &quot;Region &quot; SIZE_FORMAT &quot; should have no live data&quot;, r-&gt;index());
1486       assert(_ctx-&gt;top_at_mark_start(r) == r-&gt;top(),
1487              &quot;Region &quot; SIZE_FORMAT &quot; should have correct TAMS&quot;, r-&gt;index());
1488     }
1489   }
1490 
1491   bool is_thread_safe() { return true; }
1492 };
1493 
1494 void ShenandoahHeap::op_final_mark() {
1495   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Should be at safepoint&quot;);
1496   assert(!has_forwarded_objects(), &quot;No forwarded objects on this path&quot;);
1497 
1498   // It is critical that we
1499   // evacuate roots right after finishing marking, so that we don&#39;t
1500   // get unmarked objects in the roots.
1501 
1502   if (!cancelled_gc()) {
1503     concurrent_mark()-&gt;finish_mark_from_roots(/* full_gc = */ false);
1504 
1505     // Marking is completed, deactivate SATB barrier
1506     set_concurrent_mark_in_progress(false);
1507     mark_complete_marking_context();
1508 
1509     parallel_cleaning(false /* full gc*/);
1510 
1511     if (ShenandoahVerify) {
1512       verifier()-&gt;verify_roots_no_forwarded();
1513     }
1514 
1515     {
1516       ShenandoahGCSubPhase phase(ShenandoahPhaseTimings::final_update_region_states);
1517       ShenandoahFinalMarkUpdateRegionStateClosure cl;
1518       parallel_heap_region_iterate(&amp;cl);
1519 
1520       assert_pinned_region_status();
1521     }
1522 
1523     // Force the threads to reacquire their TLABs outside the collection set.
1524     {
1525       ShenandoahGCSubPhase phase(ShenandoahPhaseTimings::retire_tlabs);
1526       make_parsable(true);
1527     }
1528 
1529     {
1530       ShenandoahGCSubPhase phase(ShenandoahPhaseTimings::choose_cset);
1531       ShenandoahHeapLocker locker(lock());
1532       _collection_set-&gt;clear();
1533       heuristics()-&gt;choose_collection_set(_collection_set);
1534     }
1535 
1536     {
1537       ShenandoahGCSubPhase phase(ShenandoahPhaseTimings::final_rebuild_freeset);
1538       ShenandoahHeapLocker locker(lock());
1539       _free_set-&gt;rebuild();
1540     }
1541 
1542     if (!is_degenerated_gc_in_progress()) {
1543       prepare_concurrent_roots();
1544       prepare_concurrent_unloading();
1545     }
1546 
1547     // If collection set has candidates, start evacuation.
1548     // Otherwise, bypass the rest of the cycle.
1549     if (!collection_set()-&gt;is_empty()) {
1550       ShenandoahGCSubPhase init_evac(ShenandoahPhaseTimings::init_evac);
1551 
1552       if (ShenandoahVerify) {
1553         verifier()-&gt;verify_before_evacuation();
1554       }
1555 
1556       set_evacuation_in_progress(true);
1557       // From here on, we need to update references.
1558       set_has_forwarded_objects(true);
1559 
1560       if (!is_degenerated_gc_in_progress()) {
1561         if (ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {
1562           ShenandoahCodeRoots::arm_nmethods();
1563         }
1564         evacuate_and_update_roots();
1565       }
1566 
1567       if (ShenandoahPacing) {
1568         pacer()-&gt;setup_for_evac();
1569       }
1570 
1571       if (ShenandoahVerify) {
1572         ShenandoahRootVerifier::RootTypes types = ShenandoahRootVerifier::None;
1573         if (ShenandoahConcurrentRoots::should_do_concurrent_roots()) {
1574           types = ShenandoahRootVerifier::combine(ShenandoahRootVerifier::JNIHandleRoots, ShenandoahRootVerifier::WeakRoots);
1575           types = ShenandoahRootVerifier::combine(types, ShenandoahRootVerifier::CLDGRoots);
1576           types = ShenandoahRootVerifier::combine(types, ShenandoahRootVerifier::StringDedupRoots);
1577         }
1578 
1579         if (ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {
1580           types = ShenandoahRootVerifier::combine(types, ShenandoahRootVerifier::CodeRoots);
1581         }
1582         verifier()-&gt;verify_roots_no_forwarded_except(types);
1583         verifier()-&gt;verify_during_evacuation();
1584       }
1585     } else {
1586       if (ShenandoahVerify) {
1587         verifier()-&gt;verify_after_concmark();
1588       }
1589 
1590       if (VerifyAfterGC) {
1591         Universe::verify();
1592       }
1593     }
1594 
1595   } else {
1596     // If this cycle was updating references, we need to keep the has_forwarded_objects
1597     // flag on, for subsequent phases to deal with it.
1598     concurrent_mark()-&gt;cancel();
1599     set_concurrent_mark_in_progress(false);
1600 
1601     if (process_references()) {
1602       // Abandon reference processing right away: pre-cleaning must have failed.
1603       ReferenceProcessor *rp = ref_processor();
1604       rp-&gt;disable_discovery();
1605       rp-&gt;abandon_partial_discovery();
1606       rp-&gt;verify_no_references_recorded();
1607     }
1608   }
1609 }
1610 
1611 void ShenandoahHeap::op_conc_evac() {
1612   ShenandoahEvacuationTask task(this, _collection_set, true);
1613   workers()-&gt;run_task(&amp;task);
1614 }
1615 
1616 void ShenandoahHeap::op_stw_evac() {
1617   ShenandoahEvacuationTask task(this, _collection_set, false);
1618   workers()-&gt;run_task(&amp;task);
1619 }
1620 
1621 void ShenandoahHeap::op_updaterefs() {
1622   update_heap_references(true);
1623 }
1624 
1625 void ShenandoahHeap::op_cleanup() {
1626   free_set()-&gt;recycle_trash();
1627 }
1628 
1629 class ShenandoahConcurrentRootsEvacUpdateTask : public AbstractGangTask {
1630 private:
1631   ShenandoahVMRoots&lt;true /*concurrent*/&gt;        _vm_roots;
1632   ShenandoahWeakRoots&lt;true /*concurrent*/&gt;      _weak_roots;
1633   ShenandoahClassLoaderDataRoots&lt;true /*concurrent*/, false /*single threaded*/&gt; _cld_roots;
1634   ShenandoahConcurrentStringDedupRoots          _dedup_roots;
1635   bool                                          _include_weak_roots;
1636 
1637 public:
1638   ShenandoahConcurrentRootsEvacUpdateTask(bool include_weak_roots) :
1639     AbstractGangTask(&quot;Shenandoah Evacuate/Update Concurrent Roots Task&quot;),
1640     _include_weak_roots(include_weak_roots) {
1641   }
1642 
1643   void work(uint worker_id) {
1644     ShenandoahEvacOOMScope oom;
1645     {
1646       // vm_roots and weak_roots are OopStorage backed roots, concurrent iteration
1647       // may race against OopStorage::release() calls.
1648       ShenandoahEvacUpdateOopStorageRootsClosure cl;
1649       _vm_roots.oops_do&lt;ShenandoahEvacUpdateOopStorageRootsClosure&gt;(&amp;cl);
1650 
1651       if (_include_weak_roots) {
1652         _weak_roots.oops_do&lt;ShenandoahEvacUpdateOopStorageRootsClosure&gt;(&amp;cl);
1653       }
1654     }
1655 
1656     {
1657       ShenandoahEvacuateUpdateRootsClosure&lt;&gt; cl;
1658       CLDToOopClosure clds(&amp;cl, ClassLoaderData::_claim_strong);
1659       _cld_roots.cld_do(&amp;clds);
1660     }
1661 
1662     {
1663       ShenandoahForwardedIsAliveClosure is_alive;
1664       ShenandoahEvacuateUpdateRootsClosure&lt;MO_RELEASE&gt; keep_alive;
1665       _dedup_roots.oops_do(&amp;is_alive, &amp;keep_alive, worker_id);
1666     }
1667   }
1668 };
1669 
1670 class ShenandoahEvacUpdateCleanupOopStorageRootsClosure : public BasicOopIterateClosure {
1671 private:
1672   ShenandoahHeap* const _heap;
1673   ShenandoahMarkingContext* const _mark_context;
1674   bool  _evac_in_progress;
1675   Thread* const _thread;
1676   size_t  _dead_counter;
1677 
1678 public:
1679   ShenandoahEvacUpdateCleanupOopStorageRootsClosure();
1680   void do_oop(oop* p);
1681   void do_oop(narrowOop* p);
1682 
1683   size_t dead_counter() const;
1684   void reset_dead_counter();
1685 };
1686 
1687 ShenandoahEvacUpdateCleanupOopStorageRootsClosure::ShenandoahEvacUpdateCleanupOopStorageRootsClosure() :
1688   _heap(ShenandoahHeap::heap()),
1689   _mark_context(ShenandoahHeap::heap()-&gt;marking_context()),
1690   _evac_in_progress(ShenandoahHeap::heap()-&gt;is_evacuation_in_progress()),
1691   _thread(Thread::current()),
1692   _dead_counter(0) {
1693 }
1694 
1695 void ShenandoahEvacUpdateCleanupOopStorageRootsClosure::do_oop(oop* p) {
1696   const oop obj = RawAccess&lt;&gt;::oop_load(p);
1697   if (!CompressedOops::is_null(obj)) {
1698     if (!_mark_context-&gt;is_marked(obj)) {
1699       shenandoah_assert_correct(p, obj);
1700       oop old = Atomic::cmpxchg(p, obj, oop(NULL));
1701       if (obj == old) {
1702         _dead_counter ++;
1703       }
1704     } else if (_evac_in_progress &amp;&amp; _heap-&gt;in_collection_set(obj)) {
1705       oop resolved = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);
1706       if (resolved == obj) {
1707         resolved = _heap-&gt;evacuate_object(obj, _thread);
1708       }
1709       Atomic::cmpxchg(p, obj, resolved);
1710       assert(_heap-&gt;cancelled_gc() ||
1711              _mark_context-&gt;is_marked(resolved) &amp;&amp; !_heap-&gt;in_collection_set(resolved),
1712              &quot;Sanity&quot;);
1713     }
1714   }
1715 }
1716 
1717 void ShenandoahEvacUpdateCleanupOopStorageRootsClosure::do_oop(narrowOop* p) {
1718   ShouldNotReachHere();
1719 }
1720 
1721 size_t ShenandoahEvacUpdateCleanupOopStorageRootsClosure::dead_counter() const {
1722   return _dead_counter;
1723 }
1724 
1725 void ShenandoahEvacUpdateCleanupOopStorageRootsClosure::reset_dead_counter() {
1726   _dead_counter = 0;
1727 }
1728 
1729 // This task not only evacuates/updates marked weak roots, but also &quot;NULL&quot;
1730 // dead weak roots.
1731 class ShenandoahConcurrentWeakRootsEvacUpdateTask : public AbstractGangTask {
1732 private:
1733   ShenandoahWeakRoot&lt;true /*concurrent*/&gt;  _jni_roots;
1734   ShenandoahWeakRoot&lt;true /*concurrent*/&gt;  _string_table_roots;
1735   ShenandoahWeakRoot&lt;true /*concurrent*/&gt;  _resolved_method_table_roots;
1736   ShenandoahWeakRoot&lt;true /*concurrent*/&gt;  _vm_roots;
1737 
1738 public:
1739   ShenandoahConcurrentWeakRootsEvacUpdateTask() :
1740     AbstractGangTask(&quot;Shenandoah Concurrent Weak Root Task&quot;),
1741     _jni_roots(OopStorageSet::jni_weak(), ShenandoahPhaseTimings::JNIWeakRoots),
1742     _string_table_roots(OopStorageSet::string_table_weak(), ShenandoahPhaseTimings::StringTableRoots),
1743     _resolved_method_table_roots(OopStorageSet::resolved_method_table_weak(), ShenandoahPhaseTimings::ResolvedMethodTableRoots),
1744     _vm_roots(OopStorageSet::vm_weak(), ShenandoahPhaseTimings::VMWeakRoots) {
1745     StringTable::reset_dead_counter();
1746     ResolvedMethodTable::reset_dead_counter();
1747   }
1748 
1749   ~ShenandoahConcurrentWeakRootsEvacUpdateTask() {
1750     StringTable::finish_dead_counter();
1751     ResolvedMethodTable::finish_dead_counter();
1752   }
1753 
1754   void work(uint worker_id) {
1755     ShenandoahEvacOOMScope oom;
1756     // jni_roots and weak_roots are OopStorage backed roots, concurrent iteration
1757     // may race against OopStorage::release() calls.
1758     ShenandoahEvacUpdateCleanupOopStorageRootsClosure cl;
1759     _jni_roots.oops_do(&amp;cl, worker_id);
1760     _vm_roots.oops_do(&amp;cl, worker_id);
1761 
1762     cl.reset_dead_counter();
1763     _string_table_roots.oops_do(&amp;cl, worker_id);
1764     StringTable::inc_dead_counter(cl.dead_counter());
1765 
1766     cl.reset_dead_counter();
1767     _resolved_method_table_roots.oops_do(&amp;cl, worker_id);
1768     ResolvedMethodTable::inc_dead_counter(cl.dead_counter());
1769   }
1770 };
1771 
1772 void ShenandoahHeap::op_roots() {
1773   if (is_concurrent_root_in_progress()) {
1774     if (ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {
1775       // Concurrent weak root processing
1776       ShenandoahConcurrentWeakRootsEvacUpdateTask task;
1777       workers()-&gt;run_task(&amp;task);
1778 
1779       _unloader.unload();
1780     }
1781 
1782     if (ShenandoahConcurrentRoots::should_do_concurrent_roots()) {
1783       ShenandoahConcurrentRootsEvacUpdateTask task(!ShenandoahConcurrentRoots::should_do_concurrent_class_unloading());
1784       workers()-&gt;run_task(&amp;task);
1785     }
1786   }
1787 
1788   set_concurrent_root_in_progress(false);
1789 }
1790 
1791 void ShenandoahHeap::op_reset() {
1792   if (ShenandoahPacing) {
1793     pacer()-&gt;setup_for_reset();
1794   }
1795   reset_mark_bitmap();
1796 }
1797 
1798 void ShenandoahHeap::op_preclean() {
1799   if (ShenandoahPacing) {
1800     pacer()-&gt;setup_for_preclean();
1801   }
1802   concurrent_mark()-&gt;preclean_weak_refs();
1803 }
1804 
1805 void ShenandoahHeap::op_full(GCCause::Cause cause) {
1806   ShenandoahMetricsSnapshot metrics;
1807   metrics.snap_before();
1808 
1809   full_gc()-&gt;do_it(cause);
1810   if (UseTLAB) {
1811     ShenandoahGCSubPhase phase(ShenandoahPhaseTimings::full_gc_resize_tlabs);
1812     resize_all_tlabs();
1813   }
1814 
1815   metrics.snap_after();
1816 
1817   if (metrics.is_good_progress()) {
1818     _progress_last_gc.set();
1819   } else {
1820     // Nothing to do. Tell the allocation path that we have failed to make
1821     // progress, and it can finally fail.
1822     _progress_last_gc.unset();
1823   }
1824 }
1825 
1826 void ShenandoahHeap::op_degenerated(ShenandoahDegenPoint point) {
1827   // Degenerated GC is STW, but it can also fail. Current mechanics communicates
1828   // GC failure via cancelled_concgc() flag. So, if we detect the failure after
1829   // some phase, we have to upgrade the Degenerate GC to Full GC.
1830 
1831   clear_cancelled_gc();
1832 
1833   ShenandoahMetricsSnapshot metrics;
1834   metrics.snap_before();
1835 
1836   switch (point) {
1837     // The cases below form the Duff&#39;s-like device: it describes the actual GC cycle,
1838     // but enters it at different points, depending on which concurrent phase had
1839     // degenerated.
1840 
1841     case _degenerated_outside_cycle:
1842       // We have degenerated from outside the cycle, which means something is bad with
1843       // the heap, most probably heavy humongous fragmentation, or we are very low on free
1844       // space. It makes little sense to wait for Full GC to reclaim as much as it can, when
1845       // we can do the most aggressive degen cycle, which includes processing references and
1846       // class unloading, unless those features are explicitly disabled.
1847       //
1848       // Note that we can only do this for &quot;outside-cycle&quot; degens, otherwise we would risk
1849       // changing the cycle parameters mid-cycle during concurrent -&gt; degenerated handover.
1850       set_process_references(heuristics()-&gt;can_process_references());
1851       set_unload_classes(heuristics()-&gt;can_unload_classes());
1852 
1853       op_reset();
1854 
1855       op_init_mark();
1856       if (cancelled_gc()) {
1857         op_degenerated_fail();
1858         return;
1859       }
1860 
1861     case _degenerated_mark:
1862       op_final_mark();
1863       if (cancelled_gc()) {
1864         op_degenerated_fail();
1865         return;
1866       }
1867 
1868       if (!has_forwarded_objects() &amp;&amp; ShenandoahConcurrentRoots::can_do_concurrent_class_unloading()) {
1869         // Disarm nmethods that armed for concurrent mark. On normal cycle, it would
1870         // be disarmed while conc-roots phase is running.
1871         // TODO: Call op_conc_roots() here instead
1872         ShenandoahCodeRoots::disarm_nmethods();
1873       }
1874 
1875       op_cleanup();
1876 
1877     case _degenerated_evac:
1878       // If heuristics thinks we should do the cycle, this flag would be set,
1879       // and we can do evacuation. Otherwise, it would be the shortcut cycle.
1880       if (is_evacuation_in_progress()) {
1881 
1882         // Degeneration under oom-evac protocol might have left some objects in
1883         // collection set un-evacuated. Restart evacuation from the beginning to
1884         // capture all objects. For all the objects that are already evacuated,
1885         // it would be a simple check, which is supposed to be fast. This is also
1886         // safe to do even without degeneration, as CSet iterator is at beginning
1887         // in preparation for evacuation anyway.
1888         //
1889         // Before doing that, we need to make sure we never had any cset-pinned
1890         // regions. This may happen if allocation failure happened when evacuating
1891         // the about-to-be-pinned object, oom-evac protocol left the object in
1892         // the collection set, and then the pin reached the cset region. If we continue
1893         // the cycle here, we would trash the cset and alive objects in it. To avoid
1894         // it, we fail degeneration right away and slide into Full GC to recover.
1895 
1896         {
1897           sync_pinned_region_status();
1898           collection_set()-&gt;clear_current_index();
1899 
1900           ShenandoahHeapRegion* r;
1901           while ((r = collection_set()-&gt;next()) != NULL) {
1902             if (r-&gt;is_pinned()) {
1903               cancel_gc(GCCause::_shenandoah_upgrade_to_full_gc);
1904               op_degenerated_fail();
1905               return;
1906             }
1907           }
1908 
1909           collection_set()-&gt;clear_current_index();
1910         }
1911 
1912         op_stw_evac();
1913         if (cancelled_gc()) {
1914           op_degenerated_fail();
1915           return;
1916         }
1917       }
1918 
1919       // If heuristics thinks we should do the cycle, this flag would be set,
1920       // and we need to do update-refs. Otherwise, it would be the shortcut cycle.
1921       if (has_forwarded_objects()) {
1922         op_init_updaterefs();
1923         if (cancelled_gc()) {
1924           op_degenerated_fail();
1925           return;
1926         }
1927       }
1928 
1929     case _degenerated_updaterefs:
1930       if (has_forwarded_objects()) {
1931         op_final_updaterefs();
1932         if (cancelled_gc()) {
1933           op_degenerated_fail();
1934           return;
1935         }
1936       }
1937 
1938       op_cleanup();
1939       break;
1940 
1941     default:
1942       ShouldNotReachHere();
1943   }
1944 
1945   if (ShenandoahVerify) {
1946     verifier()-&gt;verify_after_degenerated();
1947   }
1948 
1949   if (VerifyAfterGC) {
1950     Universe::verify();
1951   }
1952 
1953   metrics.snap_after();
1954 
1955   // Check for futility and fail. There is no reason to do several back-to-back Degenerated cycles,
1956   // because that probably means the heap is overloaded and/or fragmented.
1957   if (!metrics.is_good_progress()) {
1958     _progress_last_gc.unset();
1959     cancel_gc(GCCause::_shenandoah_upgrade_to_full_gc);
1960     op_degenerated_futile();
1961   } else {
1962     _progress_last_gc.set();
1963   }
1964 }
1965 
1966 void ShenandoahHeap::op_degenerated_fail() {
1967   log_info(gc)(&quot;Cannot finish degeneration, upgrading to Full GC&quot;);
1968   shenandoah_policy()-&gt;record_degenerated_upgrade_to_full();
1969   op_full(GCCause::_shenandoah_upgrade_to_full_gc);
1970 }
1971 
1972 void ShenandoahHeap::op_degenerated_futile() {
1973   shenandoah_policy()-&gt;record_degenerated_upgrade_to_full();
1974   op_full(GCCause::_shenandoah_upgrade_to_full_gc);
1975 }
1976 
1977 void ShenandoahHeap::force_satb_flush_all_threads() {
1978   if (!is_concurrent_mark_in_progress()) {
1979     // No need to flush SATBs
1980     return;
1981   }
1982 
1983   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *t = jtiwh.next(); ) {
1984     ShenandoahThreadLocalData::set_force_satb_flush(t, true);
1985   }
1986   // The threads are not &quot;acquiring&quot; their thread-local data, but it does not
1987   // hurt to &quot;release&quot; the updates here anyway.
1988   OrderAccess::fence();
1989 }
1990 
1991 void ShenandoahHeap::set_gc_state_all_threads(char state) {
1992   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *t = jtiwh.next(); ) {
1993     ShenandoahThreadLocalData::set_gc_state(t, state);
1994   }
1995 }
1996 
1997 void ShenandoahHeap::set_gc_state_mask(uint mask, bool value) {
1998   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Should really be Shenandoah safepoint&quot;);
1999   _gc_state.set_cond(mask, value);
2000   set_gc_state_all_threads(_gc_state.raw_value());
2001 }
2002 
2003 void ShenandoahHeap::set_concurrent_mark_in_progress(bool in_progress) {
2004   if (has_forwarded_objects()) {
2005     set_gc_state_mask(MARKING | UPDATEREFS, in_progress);
2006   } else {
2007     set_gc_state_mask(MARKING, in_progress);
2008   }
2009   ShenandoahBarrierSet::satb_mark_queue_set().set_active_all_threads(in_progress, !in_progress);
2010 }
2011 
2012 void ShenandoahHeap::set_evacuation_in_progress(bool in_progress) {
2013   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Only call this at safepoint&quot;);
2014   set_gc_state_mask(EVACUATION, in_progress);
2015 }
2016 
2017 void ShenandoahHeap::set_concurrent_root_in_progress(bool in_progress) {
2018   assert(ShenandoahConcurrentRoots::can_do_concurrent_roots(), &quot;Why set the flag?&quot;);
2019   if (in_progress) {
2020     _concurrent_root_in_progress.set();
2021   } else {
2022     _concurrent_root_in_progress.unset();
2023   }
2024 }
2025 
2026 void ShenandoahHeap::ref_processing_init() {
2027   assert(_max_workers &gt; 0, &quot;Sanity&quot;);
2028 
2029   _ref_processor =
2030     new ReferenceProcessor(&amp;_subject_to_discovery,  // is_subject_to_discovery
2031                            ParallelRefProcEnabled,  // MT processing
2032                            _max_workers,            // Degree of MT processing
2033                            true,                    // MT discovery
2034                            _max_workers,            // Degree of MT discovery
2035                            false,                   // Reference discovery is not atomic
2036                            NULL,                    // No closure, should be installed before use
2037                            true);                   // Scale worker threads
2038 
2039   shenandoah_assert_rp_isalive_not_installed();
2040 }
2041 
2042 GCTracer* ShenandoahHeap::tracer() {
2043   return shenandoah_policy()-&gt;tracer();
2044 }
2045 
2046 size_t ShenandoahHeap::tlab_used(Thread* thread) const {
2047   return _free_set-&gt;used();
2048 }
2049 
2050 bool ShenandoahHeap::try_cancel_gc() {
2051   while (true) {
2052     jbyte prev = _cancelled_gc.cmpxchg(CANCELLED, CANCELLABLE);
2053     if (prev == CANCELLABLE) return true;
2054     else if (prev == CANCELLED) return false;
2055     assert(ShenandoahSuspendibleWorkers, &quot;should not get here when not using suspendible workers&quot;);
2056     assert(prev == NOT_CANCELLED, &quot;must be NOT_CANCELLED&quot;);
2057     if (Thread::current()-&gt;is_Java_thread()) {
2058       // We need to provide a safepoint here, otherwise we might
2059       // spin forever if a SP is pending.
2060       ThreadBlockInVM sp(JavaThread::current());
2061       SpinPause();
2062     }
2063   }
2064 }
2065 
2066 void ShenandoahHeap::cancel_gc(GCCause::Cause cause) {
2067   if (try_cancel_gc()) {
2068     FormatBuffer&lt;&gt; msg(&quot;Cancelling GC: %s&quot;, GCCause::to_string(cause));
2069     log_info(gc)(&quot;%s&quot;, msg.buffer());
2070     Events::log(Thread::current(), &quot;%s&quot;, msg.buffer());
2071   }
2072 }
2073 
2074 uint ShenandoahHeap::max_workers() {
2075   return _max_workers;
2076 }
2077 
2078 void ShenandoahHeap::stop() {
2079   // The shutdown sequence should be able to terminate when GC is running.
2080 
2081   // Step 0. Notify policy to disable event recording.
2082   _shenandoah_policy-&gt;record_shutdown();
2083 
2084   // Step 1. Notify control thread that we are in shutdown.
2085   // Note that we cannot do that with stop(), because stop() is blocking and waits for the actual shutdown.
2086   // Doing stop() here would wait for the normal GC cycle to complete, never falling through to cancel below.
2087   control_thread()-&gt;prepare_for_graceful_shutdown();
2088 
2089   // Step 2. Notify GC workers that we are cancelling GC.
2090   cancel_gc(GCCause::_shenandoah_stop_vm);
2091 
2092   // Step 3. Wait until GC worker exits normally.
2093   control_thread()-&gt;stop();
2094 
2095   // Step 4. Stop String Dedup thread if it is active
2096   if (ShenandoahStringDedup::is_enabled()) {
2097     ShenandoahStringDedup::stop();
2098   }
2099 }
2100 
2101 void ShenandoahHeap::stw_unload_classes(bool full_gc) {
2102   if (!unload_classes()) return;
2103   bool purged_class;
2104 
2105   // Unload classes and purge SystemDictionary.
2106   {
2107     ShenandoahGCSubPhase phase(full_gc ?
2108                                ShenandoahPhaseTimings::full_gc_purge_class_unload :
2109                                ShenandoahPhaseTimings::purge_class_unload);
2110     purged_class = SystemDictionary::do_unloading(gc_timer());
2111   }
2112 
2113   {
2114     ShenandoahGCSubPhase phase(full_gc ?
2115                                ShenandoahPhaseTimings::full_gc_purge_par :
2116                                ShenandoahPhaseTimings::purge_par);
2117     ShenandoahIsAliveSelector is_alive;
2118     uint num_workers = _workers-&gt;active_workers();
2119     ShenandoahClassUnloadingTask unlink_task(is_alive.is_alive_closure(), num_workers, purged_class);
2120     _workers-&gt;run_task(&amp;unlink_task);
2121   }
2122 
2123   {
2124     ShenandoahGCSubPhase phase(full_gc ?
2125                                ShenandoahPhaseTimings::full_gc_purge_cldg :
2126                                ShenandoahPhaseTimings::purge_cldg);
2127     ClassLoaderDataGraph::purge();
2128   }
2129   // Resize and verify metaspace
2130   MetaspaceGC::compute_new_size();
2131   MetaspaceUtils::verify_metrics();
2132 }
2133 
2134 // Weak roots are either pre-evacuated (final mark) or updated (final updaterefs),
2135 // so they should not have forwarded oops.
2136 // However, we do need to &quot;null&quot; dead oops in the roots, if can not be done
2137 // in concurrent cycles.
2138 void ShenandoahHeap::stw_process_weak_roots(bool full_gc) {
2139   ShenandoahGCSubPhase root_phase(full_gc ?
2140                                   ShenandoahPhaseTimings::full_gc_purge :
2141                                   ShenandoahPhaseTimings::purge);
2142   uint num_workers = _workers-&gt;active_workers();
2143   ShenandoahPhaseTimings::Phase timing_phase = full_gc ?
2144                                                ShenandoahPhaseTimings::full_gc_purge_par :
2145                                                ShenandoahPhaseTimings::purge_par;
2146   ShenandoahGCSubPhase phase(timing_phase);
2147   ShenandoahGCWorkerPhase worker_phase(timing_phase);
2148 
2149   // Cleanup weak roots
2150   if (has_forwarded_objects()) {
2151     ShenandoahForwardedIsAliveClosure is_alive;
2152     ShenandoahUpdateRefsClosure keep_alive;
2153     ShenandoahParallelWeakRootsCleaningTask&lt;ShenandoahForwardedIsAliveClosure, ShenandoahUpdateRefsClosure&gt;
2154       cleaning_task(&amp;is_alive, &amp;keep_alive, num_workers, !ShenandoahConcurrentRoots::should_do_concurrent_class_unloading());
2155     _workers-&gt;run_task(&amp;cleaning_task);
2156   } else {
2157     ShenandoahIsAliveClosure is_alive;
2158 #ifdef ASSERT
2159     ShenandoahAssertNotForwardedClosure verify_cl;
2160     ShenandoahParallelWeakRootsCleaningTask&lt;ShenandoahIsAliveClosure, ShenandoahAssertNotForwardedClosure&gt;
2161       cleaning_task(&amp;is_alive, &amp;verify_cl, num_workers, !ShenandoahConcurrentRoots::should_do_concurrent_class_unloading());
2162 #else
2163     ShenandoahParallelWeakRootsCleaningTask&lt;ShenandoahIsAliveClosure, DoNothingClosure&gt;
2164       cleaning_task(&amp;is_alive, &amp;do_nothing_cl, num_workers, !ShenandoahConcurrentRoots::should_do_concurrent_class_unloading());
2165 #endif
2166     _workers-&gt;run_task(&amp;cleaning_task);
2167   }
2168 }
2169 
2170 void ShenandoahHeap::parallel_cleaning(bool full_gc) {
2171   assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at a safepoint&quot;);
2172   stw_process_weak_roots(full_gc);
2173   if (!ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {
2174     stw_unload_classes(full_gc);
2175   }
2176 }
2177 
2178 void ShenandoahHeap::set_has_forwarded_objects(bool cond) {
2179   set_gc_state_mask(HAS_FORWARDED, cond);
2180 }
2181 
2182 void ShenandoahHeap::set_process_references(bool pr) {
2183   _process_references.set_cond(pr);
2184 }
2185 
2186 void ShenandoahHeap::set_unload_classes(bool uc) {
2187   _unload_classes.set_cond(uc);
2188 }
2189 
2190 bool ShenandoahHeap::process_references() const {
2191   return _process_references.is_set();
2192 }
2193 
2194 bool ShenandoahHeap::unload_classes() const {
2195   return _unload_classes.is_set();
2196 }
2197 
2198 address ShenandoahHeap::in_cset_fast_test_addr() {
2199   ShenandoahHeap* heap = ShenandoahHeap::heap();
2200   assert(heap-&gt;collection_set() != NULL, &quot;Sanity&quot;);
2201   return (address) heap-&gt;collection_set()-&gt;biased_map_address();
2202 }
2203 
2204 address ShenandoahHeap::cancelled_gc_addr() {
2205   return (address) ShenandoahHeap::heap()-&gt;_cancelled_gc.addr_of();
2206 }
2207 
2208 address ShenandoahHeap::gc_state_addr() {
2209   return (address) ShenandoahHeap::heap()-&gt;_gc_state.addr_of();
2210 }
2211 
2212 size_t ShenandoahHeap::bytes_allocated_since_gc_start() {
2213   return Atomic::load_acquire(&amp;_bytes_allocated_since_gc_start);
2214 }
2215 
2216 void ShenandoahHeap::reset_bytes_allocated_since_gc_start() {
2217   Atomic::release_store_fence(&amp;_bytes_allocated_since_gc_start, (size_t)0);
2218 }
2219 
2220 void ShenandoahHeap::set_degenerated_gc_in_progress(bool in_progress) {
2221   _degenerated_gc_in_progress.set_cond(in_progress);
2222 }
2223 
2224 void ShenandoahHeap::set_full_gc_in_progress(bool in_progress) {
2225   _full_gc_in_progress.set_cond(in_progress);
2226 }
2227 
2228 void ShenandoahHeap::set_full_gc_move_in_progress(bool in_progress) {
2229   assert (is_full_gc_in_progress(), &quot;should be&quot;);
2230   _full_gc_move_in_progress.set_cond(in_progress);
2231 }
2232 
2233 void ShenandoahHeap::set_update_refs_in_progress(bool in_progress) {
2234   set_gc_state_mask(UPDATEREFS, in_progress);
2235 }
2236 
2237 void ShenandoahHeap::register_nmethod(nmethod* nm) {
2238   ShenandoahCodeRoots::register_nmethod(nm);
2239 }
2240 
2241 void ShenandoahHeap::unregister_nmethod(nmethod* nm) {
2242   ShenandoahCodeRoots::unregister_nmethod(nm);
2243 }
2244 
2245 void ShenandoahHeap::flush_nmethod(nmethod* nm) {
2246   ShenandoahCodeRoots::flush_nmethod(nm);
2247 }
2248 
2249 oop ShenandoahHeap::pin_object(JavaThread* thr, oop o) {
2250   heap_region_containing(o)-&gt;record_pin();
2251   return o;
2252 }
2253 
2254 void ShenandoahHeap::unpin_object(JavaThread* thr, oop o) {
2255   heap_region_containing(o)-&gt;record_unpin();
2256 }
2257 
2258 void ShenandoahHeap::sync_pinned_region_status() {
2259   ShenandoahHeapLocker locker(lock());
2260 
2261   for (size_t i = 0; i &lt; num_regions(); i++) {
2262     ShenandoahHeapRegion *r = get_region(i);
2263     if (r-&gt;is_active()) {
2264       if (r-&gt;is_pinned()) {
2265         if (r-&gt;pin_count() == 0) {
2266           r-&gt;make_unpinned();
2267         }
2268       } else {
2269         if (r-&gt;pin_count() &gt; 0) {
2270           r-&gt;make_pinned();
2271         }
2272       }
2273     }
2274   }
2275 
2276   assert_pinned_region_status();
2277 }
2278 
2279 #ifdef ASSERT
2280 void ShenandoahHeap::assert_pinned_region_status() {
2281   for (size_t i = 0; i &lt; num_regions(); i++) {
2282     ShenandoahHeapRegion* r = get_region(i);
2283     assert((r-&gt;is_pinned() &amp;&amp; r-&gt;pin_count() &gt; 0) || (!r-&gt;is_pinned() &amp;&amp; r-&gt;pin_count() == 0),
2284            &quot;Region &quot; SIZE_FORMAT &quot; pinning status is inconsistent&quot;, i);
2285   }
2286 }
2287 #endif
2288 
2289 ConcurrentGCTimer* ShenandoahHeap::gc_timer() const {
2290   return _gc_timer;
2291 }
2292 
2293 void ShenandoahHeap::prepare_concurrent_roots() {
2294   assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at a safepoint&quot;);
2295   if (ShenandoahConcurrentRoots::should_do_concurrent_roots()) {
2296     set_concurrent_root_in_progress(true);
2297   }
2298 }
2299 
2300 void ShenandoahHeap::prepare_concurrent_unloading() {
2301   assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at a safepoint&quot;);
2302   if (ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {
2303     _unloader.prepare();
2304   }
2305 }
2306 
2307 void ShenandoahHeap::finish_concurrent_unloading() {
2308   assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at a safepoint&quot;);
2309   if (ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {
2310     _unloader.finish();
2311   }
2312 }
2313 
2314 #ifdef ASSERT
2315 void ShenandoahHeap::assert_gc_workers(uint nworkers) {
2316   assert(nworkers &gt; 0 &amp;&amp; nworkers &lt;= max_workers(), &quot;Sanity&quot;);
2317 
2318   if (ShenandoahSafepoint::is_at_shenandoah_safepoint()) {
2319     if (UseDynamicNumberOfGCThreads) {
2320       assert(nworkers &lt;= ParallelGCThreads, &quot;Cannot use more than it has&quot;);
2321     } else {
2322       // Use ParallelGCThreads inside safepoints
2323       assert(nworkers == ParallelGCThreads, &quot;Use ParallelGCThreads within safepoints&quot;);
2324     }
2325   } else {
2326     if (UseDynamicNumberOfGCThreads) {
2327       assert(nworkers &lt;= ConcGCThreads, &quot;Cannot use more than it has&quot;);
2328     } else {
2329       // Use ConcGCThreads outside safepoints
2330       assert(nworkers == ConcGCThreads, &quot;Use ConcGCThreads outside safepoints&quot;);
2331     }
2332   }
2333 }
2334 #endif
2335 
2336 ShenandoahVerifier* ShenandoahHeap::verifier() {
2337   guarantee(ShenandoahVerify, &quot;Should be enabled&quot;);
2338   assert (_verifier != NULL, &quot;sanity&quot;);
2339   return _verifier;
2340 }
2341 
2342 template&lt;class T&gt;
2343 class ShenandoahUpdateHeapRefsTask : public AbstractGangTask {
2344 private:
2345   T cl;
2346   ShenandoahHeap* _heap;
2347   ShenandoahRegionIterator* _regions;
2348   bool _concurrent;
2349 public:
2350   ShenandoahUpdateHeapRefsTask(ShenandoahRegionIterator* regions, bool concurrent) :
2351     AbstractGangTask(&quot;Concurrent Update References Task&quot;),
2352     cl(T()),
2353     _heap(ShenandoahHeap::heap()),
2354     _regions(regions),
2355     _concurrent(concurrent) {
2356   }
2357 
2358   void work(uint worker_id) {
2359     if (_concurrent) {
2360       ShenandoahConcurrentWorkerSession worker_session(worker_id);
2361       ShenandoahSuspendibleThreadSetJoiner stsj(ShenandoahSuspendibleWorkers);
2362       do_work();
2363     } else {
2364       ShenandoahParallelWorkerSession worker_session(worker_id);
2365       do_work();
2366     }
2367   }
2368 
2369 private:
2370   void do_work() {
2371     ShenandoahHeapRegion* r = _regions-&gt;next();
2372     ShenandoahMarkingContext* const ctx = _heap-&gt;complete_marking_context();
2373     while (r != NULL) {
2374       HeapWord* update_watermark = r-&gt;get_update_watermark();
2375       assert (update_watermark &gt;= r-&gt;bottom(), &quot;sanity&quot;);
2376       if (r-&gt;is_active() &amp;&amp; !r-&gt;is_cset()) {
2377         _heap-&gt;marked_object_oop_iterate(r, &amp;cl, update_watermark);
2378       }
2379       if (ShenandoahPacing) {
2380         _heap-&gt;pacer()-&gt;report_updaterefs(pointer_delta(update_watermark, r-&gt;bottom()));
2381       }
2382       if (_heap-&gt;check_cancelled_gc_and_yield(_concurrent)) {
2383         return;
2384       }
2385       r = _regions-&gt;next();
2386     }
2387   }
2388 };
2389 
2390 void ShenandoahHeap::update_heap_references(bool concurrent) {
2391   ShenandoahUpdateHeapRefsTask&lt;ShenandoahUpdateHeapRefsClosure&gt; task(&amp;_update_refs_iterator, concurrent);
2392   workers()-&gt;run_task(&amp;task);
2393 }
2394 
2395 void ShenandoahHeap::op_init_updaterefs() {
2396   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;must be at safepoint&quot;);
2397 
2398   set_evacuation_in_progress(false);
2399 
2400   {
2401     ShenandoahGCSubPhase phase(ShenandoahPhaseTimings::init_update_refs_retire_gclabs);
2402     retire_and_reset_gclabs();
2403   }
2404 
2405   if (ShenandoahVerify) {
2406     if (!is_degenerated_gc_in_progress()) {
2407       verifier()-&gt;verify_roots_in_to_space_except(ShenandoahRootVerifier::ThreadRoots);
2408     }
2409     verifier()-&gt;verify_before_updaterefs();
2410   }
2411 
2412   set_update_refs_in_progress(true);
2413 
2414   {
2415     ShenandoahGCSubPhase phase(ShenandoahPhaseTimings::init_update_refs_prepare);
2416 
2417     make_parsable(true);
2418 
2419     // Reset iterator.
2420     _update_refs_iterator.reset();
2421   }
2422 
2423   if (ShenandoahPacing) {
2424     pacer()-&gt;setup_for_updaterefs();
2425   }
2426 }
2427 
2428 class ShenandoahFinalUpdateRefsUpdateRegionStateClosure : public ShenandoahHeapRegionClosure {
2429 private:
2430   ShenandoahHeapLock* const _lock;
2431 
2432 public:
2433   ShenandoahFinalUpdateRefsUpdateRegionStateClosure() : _lock(ShenandoahHeap::heap()-&gt;lock()) {}
2434 
2435   void heap_region_do(ShenandoahHeapRegion* r) {
2436     // Drop unnecessary &quot;pinned&quot; state from regions that does not have CP marks
2437     // anymore, as this would allow trashing them.
2438 
2439     if (r-&gt;is_active()) {
2440       if (r-&gt;is_pinned()) {
2441         if (r-&gt;pin_count() == 0) {
2442           ShenandoahHeapLocker locker(_lock);
2443           r-&gt;make_unpinned();
2444         }
2445       } else {
2446         if (r-&gt;pin_count() &gt; 0) {
2447           ShenandoahHeapLocker locker(_lock);
2448           r-&gt;make_pinned();
2449         }
2450       }
2451     }
2452   }
2453 
2454   bool is_thread_safe() { return true; }
2455 };
2456 
2457 void ShenandoahHeap::op_final_updaterefs() {
2458   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;must be at safepoint&quot;);
2459 
2460   finish_concurrent_unloading();
2461 
2462   // Check if there is left-over work, and finish it
2463   if (_update_refs_iterator.has_next()) {
2464     ShenandoahGCSubPhase phase(ShenandoahPhaseTimings::final_update_refs_finish_work);
2465 
2466     // Finish updating references where we left off.
2467     clear_cancelled_gc();
2468     update_heap_references(false);
2469   }
2470 
2471   // Clear cancelled GC, if set. On cancellation path, the block before would handle
2472   // everything. On degenerated paths, cancelled gc would not be set anyway.
2473   if (cancelled_gc()) {
2474     clear_cancelled_gc();
2475   }
2476   assert(!cancelled_gc(), &quot;Should have been done right before&quot;);
2477 
2478   if (ShenandoahVerify &amp;&amp; !is_degenerated_gc_in_progress()) {
2479     verifier()-&gt;verify_roots_in_to_space_except(ShenandoahRootVerifier::ThreadRoots);
2480   }
2481 
2482   if (is_degenerated_gc_in_progress()) {
2483     concurrent_mark()-&gt;update_roots(ShenandoahPhaseTimings::degen_gc_update_roots);
2484   } else {
2485     concurrent_mark()-&gt;update_thread_roots(ShenandoahPhaseTimings::final_update_refs_roots);
2486   }
2487 
2488   // Has to be done before cset is clear
2489   if (ShenandoahVerify) {
2490     verifier()-&gt;verify_roots_in_to_space();
2491   }
2492 
2493   {
2494     ShenandoahGCSubPhase phase(ShenandoahPhaseTimings::final_update_refs_update_region_states);
2495     ShenandoahFinalUpdateRefsUpdateRegionStateClosure cl;
2496     parallel_heap_region_iterate(&amp;cl);
2497 
2498     assert_pinned_region_status();
2499   }
2500 
2501   {
2502     ShenandoahGCSubPhase phase(ShenandoahPhaseTimings::final_update_refs_trash_cset);
2503     trash_cset_regions();
2504   }
2505 
2506   set_has_forwarded_objects(false);
2507   set_update_refs_in_progress(false);
2508 
2509   if (ShenandoahVerify) {
2510     verifier()-&gt;verify_after_updaterefs();
2511   }
2512 
2513   if (VerifyAfterGC) {
2514     Universe::verify();
2515   }
2516 
2517   {
2518     ShenandoahGCSubPhase phase(ShenandoahPhaseTimings::final_update_refs_rebuild_freeset);
2519     ShenandoahHeapLocker locker(lock());
2520     _free_set-&gt;rebuild();
2521   }
2522 }
2523 
2524 void ShenandoahHeap::print_extended_on(outputStream *st) const {
2525   print_on(st);
2526   print_heap_regions_on(st);
2527 }
2528 
2529 bool ShenandoahHeap::is_bitmap_slice_committed(ShenandoahHeapRegion* r, bool skip_self) {
2530   size_t slice = r-&gt;index() / _bitmap_regions_per_slice;
2531 
2532   size_t regions_from = _bitmap_regions_per_slice * slice;
2533   size_t regions_to   = MIN2(num_regions(), _bitmap_regions_per_slice * (slice + 1));
2534   for (size_t g = regions_from; g &lt; regions_to; g++) {
2535     assert (g / _bitmap_regions_per_slice == slice, &quot;same slice&quot;);
2536     if (skip_self &amp;&amp; g == r-&gt;index()) continue;
2537     if (get_region(g)-&gt;is_committed()) {
2538       return true;
2539     }
2540   }
2541   return false;
2542 }
2543 
2544 bool ShenandoahHeap::commit_bitmap_slice(ShenandoahHeapRegion* r) {
2545   shenandoah_assert_heaplocked();
2546 
2547   // Bitmaps in special regions do not need commits
2548   if (_bitmap_region_special) {
2549     return true;
2550   }
2551 
2552   if (is_bitmap_slice_committed(r, true)) {
2553     // Some other region from the group is already committed, meaning the bitmap
2554     // slice is already committed, we exit right away.
2555     return true;
2556   }
2557 
2558   // Commit the bitmap slice:
2559   size_t slice = r-&gt;index() / _bitmap_regions_per_slice;
2560   size_t off = _bitmap_bytes_per_slice * slice;
2561   size_t len = _bitmap_bytes_per_slice;
2562   if (!os::commit_memory((char*)_bitmap_region.start() + off, len, false)) {
2563     return false;
2564   }
2565   return true;
2566 }
2567 
2568 bool ShenandoahHeap::uncommit_bitmap_slice(ShenandoahHeapRegion *r) {
2569   shenandoah_assert_heaplocked();
2570 
2571   // Bitmaps in special regions do not need uncommits
2572   if (_bitmap_region_special) {
2573     return true;
2574   }
2575 
2576   if (is_bitmap_slice_committed(r, true)) {
2577     // Some other region from the group is still committed, meaning the bitmap
2578     // slice is should stay committed, exit right away.
2579     return true;
2580   }
2581 
2582   // Uncommit the bitmap slice:
2583   size_t slice = r-&gt;index() / _bitmap_regions_per_slice;
2584   size_t off = _bitmap_bytes_per_slice * slice;
2585   size_t len = _bitmap_bytes_per_slice;
2586   if (!os::uncommit_memory((char*)_bitmap_region.start() + off, len)) {
2587     return false;
2588   }
2589   return true;
2590 }
2591 
2592 void ShenandoahHeap::safepoint_synchronize_begin() {
2593   if (ShenandoahSuspendibleWorkers || UseStringDeduplication) {
2594     SuspendibleThreadSet::synchronize();
2595   }
2596 }
2597 
2598 void ShenandoahHeap::safepoint_synchronize_end() {
2599   if (ShenandoahSuspendibleWorkers || UseStringDeduplication) {
2600     SuspendibleThreadSet::desynchronize();
2601   }
2602 }
2603 
2604 void ShenandoahHeap::vmop_entry_init_mark() {
2605   TraceCollectorStats tcs(monitoring_support()-&gt;stw_collection_counters());
2606   ShenandoahGCPhase total(ShenandoahPhaseTimings::total_pause_gross);
2607   ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_mark_gross);
2608 
2609   try_inject_alloc_failure();
2610   VM_ShenandoahInitMark op;
2611   VMThread::execute(&amp;op); // jump to entry_init_mark() under safepoint
2612 }
2613 
2614 void ShenandoahHeap::vmop_entry_final_mark() {
2615   TraceCollectorStats tcs(monitoring_support()-&gt;stw_collection_counters());
2616   ShenandoahGCPhase total(ShenandoahPhaseTimings::total_pause_gross);
2617   ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_mark_gross);
2618 
2619   try_inject_alloc_failure();
2620   VM_ShenandoahFinalMarkStartEvac op;
2621   VMThread::execute(&amp;op); // jump to entry_final_mark under safepoint
2622 }
2623 
2624 void ShenandoahHeap::vmop_entry_init_updaterefs() {
2625   TraceCollectorStats tcs(monitoring_support()-&gt;stw_collection_counters());
2626   ShenandoahGCPhase total(ShenandoahPhaseTimings::total_pause_gross);
2627   ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_update_refs_gross);
2628 
2629   try_inject_alloc_failure();
2630   VM_ShenandoahInitUpdateRefs op;
2631   VMThread::execute(&amp;op);
2632 }
2633 
2634 void ShenandoahHeap::vmop_entry_final_updaterefs() {
2635   TraceCollectorStats tcs(monitoring_support()-&gt;stw_collection_counters());
2636   ShenandoahGCPhase total(ShenandoahPhaseTimings::total_pause_gross);
2637   ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_update_refs_gross);
2638 
2639   try_inject_alloc_failure();
2640   VM_ShenandoahFinalUpdateRefs op;
2641   VMThread::execute(&amp;op);
2642 }
2643 
2644 void ShenandoahHeap::vmop_entry_full(GCCause::Cause cause) {
2645   TraceCollectorStats tcs(monitoring_support()-&gt;full_stw_collection_counters());
2646   ShenandoahGCPhase total(ShenandoahPhaseTimings::total_pause_gross);
2647   ShenandoahGCPhase phase(ShenandoahPhaseTimings::full_gc_gross);
2648 
2649   try_inject_alloc_failure();
2650   VM_ShenandoahFullGC op(cause);
2651   VMThread::execute(&amp;op);
2652 }
2653 
2654 void ShenandoahHeap::vmop_degenerated(ShenandoahDegenPoint point) {
2655   TraceCollectorStats tcs(monitoring_support()-&gt;full_stw_collection_counters());
2656   ShenandoahGCPhase total(ShenandoahPhaseTimings::total_pause_gross);
2657   ShenandoahGCPhase phase(ShenandoahPhaseTimings::degen_gc_gross);
2658 
2659   VM_ShenandoahDegeneratedGC degenerated_gc((int)point);
2660   VMThread::execute(&amp;degenerated_gc);
2661 }
2662 
2663 void ShenandoahHeap::entry_init_mark() {
2664   const char* msg = init_mark_event_message();
2665   ShenandoahPausePhase gc_phase(msg);
2666   EventMark em(&quot;%s&quot;, msg);
2667 
2668   ShenandoahGCPhase total_phase(ShenandoahPhaseTimings::total_pause);
2669   ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_mark);
2670 
2671   ShenandoahWorkerScope scope(workers(),
2672                               ShenandoahWorkerPolicy::calc_workers_for_init_marking(),
2673                               &quot;init marking&quot;);
2674 
2675   op_init_mark();
2676 }
2677 
2678 void ShenandoahHeap::entry_final_mark() {
2679   const char* msg = final_mark_event_message();
2680   ShenandoahPausePhase gc_phase(msg);
2681   EventMark em(&quot;%s&quot;, msg);
2682 
2683   ShenandoahGCPhase total_phase(ShenandoahPhaseTimings::total_pause);
2684   ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_mark);
2685 
2686   ShenandoahWorkerScope scope(workers(),
2687                               ShenandoahWorkerPolicy::calc_workers_for_final_marking(),
2688                               &quot;final marking&quot;);
2689 
2690   op_final_mark();
2691 }
2692 
2693 void ShenandoahHeap::entry_init_updaterefs() {
2694   static const char* msg = &quot;Pause Init Update Refs&quot;;
2695   ShenandoahPausePhase gc_phase(msg);
2696   EventMark em(&quot;%s&quot;, msg);
2697 
2698   ShenandoahGCPhase total_phase(ShenandoahPhaseTimings::total_pause);
2699   ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_update_refs);
2700 
2701   // No workers used in this phase, no setup required
2702 
2703   op_init_updaterefs();
2704 }
2705 
2706 void ShenandoahHeap::entry_final_updaterefs() {
2707   static const char* msg = &quot;Pause Final Update Refs&quot;;
2708   ShenandoahPausePhase gc_phase(msg);
2709   EventMark em(&quot;%s&quot;, msg);
2710 
2711   ShenandoahGCPhase total_phase(ShenandoahPhaseTimings::total_pause);
2712   ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_update_refs);
2713 
2714   ShenandoahWorkerScope scope(workers(),
2715                               ShenandoahWorkerPolicy::calc_workers_for_final_update_ref(),
2716                               &quot;final reference update&quot;);
2717 
2718   op_final_updaterefs();
2719 }
2720 
2721 void ShenandoahHeap::entry_full(GCCause::Cause cause) {
2722   static const char* msg = &quot;Pause Full&quot;;
2723   ShenandoahPausePhase gc_phase(msg);
2724   EventMark em(&quot;%s&quot;, msg);
2725 
2726   ShenandoahGCPhase total_phase(ShenandoahPhaseTimings::total_pause);
2727   ShenandoahGCPhase phase(ShenandoahPhaseTimings::full_gc);
2728 
2729   ShenandoahWorkerScope scope(workers(),
2730                               ShenandoahWorkerPolicy::calc_workers_for_fullgc(),
2731                               &quot;full gc&quot;);
2732 
2733   op_full(cause);
2734 }
2735 
2736 void ShenandoahHeap::entry_degenerated(int point) {
2737   ShenandoahDegenPoint dpoint = (ShenandoahDegenPoint)point;
2738   const char* msg = degen_event_message(dpoint);
2739   ShenandoahPausePhase gc_phase(msg);
2740   EventMark em(&quot;%s&quot;, msg);
2741 
2742   ShenandoahGCPhase total_phase(ShenandoahPhaseTimings::total_pause);
2743   ShenandoahGCPhase phase(ShenandoahPhaseTimings::degen_gc);
2744 
2745   ShenandoahWorkerScope scope(workers(),
2746                               ShenandoahWorkerPolicy::calc_workers_for_stw_degenerated(),
2747                               &quot;stw degenerated gc&quot;);
2748 
2749   set_degenerated_gc_in_progress(true);
2750   op_degenerated(dpoint);
2751   set_degenerated_gc_in_progress(false);
2752 }
2753 
2754 void ShenandoahHeap::entry_mark() {
2755   TraceCollectorStats tcs(monitoring_support()-&gt;concurrent_collection_counters());
2756 
2757   const char* msg = conc_mark_event_message();
2758   ShenandoahConcurrentPhase gc_phase(msg);
2759   EventMark em(&quot;%s&quot;, msg);
2760 
2761   ShenandoahGCPhase conc_mark_phase(ShenandoahPhaseTimings::conc_mark);
2762 
2763   ShenandoahWorkerScope scope(workers(),
2764                               ShenandoahWorkerPolicy::calc_workers_for_conc_marking(),
2765                               &quot;concurrent marking&quot;);
2766 
2767   try_inject_alloc_failure();
2768   op_mark();
2769 }
2770 
2771 void ShenandoahHeap::entry_evac() {
2772   TraceCollectorStats tcs(monitoring_support()-&gt;concurrent_collection_counters());
2773 
2774   static const char* msg = &quot;Concurrent evacuation&quot;;
2775   ShenandoahConcurrentPhase gc_phase(msg);
2776   EventMark em(&quot;%s&quot;, msg);
2777 
2778   ShenandoahGCPhase conc_evac_phase(ShenandoahPhaseTimings::conc_evac);
2779 
2780   ShenandoahWorkerScope scope(workers(),
2781                               ShenandoahWorkerPolicy::calc_workers_for_conc_evac(),
2782                               &quot;concurrent evacuation&quot;);
2783 
2784   try_inject_alloc_failure();
2785   op_conc_evac();
2786 }
2787 
2788 void ShenandoahHeap::entry_updaterefs() {
2789   static const char* msg = &quot;Concurrent update references&quot;;
2790   ShenandoahConcurrentPhase gc_phase(msg);
2791   EventMark em(&quot;%s&quot;, msg);
2792 
2793   ShenandoahGCPhase phase(ShenandoahPhaseTimings::conc_update_refs);
2794 
2795   ShenandoahWorkerScope scope(workers(),
2796                               ShenandoahWorkerPolicy::calc_workers_for_conc_update_ref(),
2797                               &quot;concurrent reference update&quot;);
2798 
2799   try_inject_alloc_failure();
2800   op_updaterefs();
2801 }
2802 
2803 void ShenandoahHeap::entry_roots() {
2804   static const char* msg = &quot;Concurrent roots processing&quot;;
2805   ShenandoahConcurrentPhase gc_phase(msg);
2806   EventMark em(&quot;%s&quot;, msg);
2807 
2808   ShenandoahGCPhase phase(ShenandoahPhaseTimings::conc_roots);
2809 
2810   ShenandoahWorkerScope scope(workers(),
2811                               ShenandoahWorkerPolicy::calc_workers_for_conc_root_processing(),
2812                               &quot;concurrent root processing&quot;);
2813 
2814   try_inject_alloc_failure();
2815   op_roots();
2816 }
2817 
2818 void ShenandoahHeap::entry_cleanup() {
2819   static const char* msg = &quot;Concurrent cleanup&quot;;
2820   ShenandoahConcurrentPhase gc_phase(msg,  true /* log_heap_usage */);
2821   EventMark em(&quot;%s&quot;, msg);
2822 
2823   ShenandoahGCSubPhase phase(ShenandoahPhaseTimings::conc_cleanup);
2824 
2825   // This phase does not use workers, no need for setup
2826 
2827   try_inject_alloc_failure();
2828   op_cleanup();
2829 }
2830 
2831 void ShenandoahHeap::entry_reset() {
2832   static const char* msg = &quot;Concurrent reset&quot;;
2833   ShenandoahConcurrentPhase gc_phase(msg);
2834   EventMark em(&quot;%s&quot;, msg);
2835 
2836   ShenandoahGCSubPhase phase(ShenandoahPhaseTimings::conc_reset);
2837 
2838   ShenandoahWorkerScope scope(workers(),
2839                               ShenandoahWorkerPolicy::calc_workers_for_conc_reset(),
2840                               &quot;concurrent reset&quot;);
2841 
2842   try_inject_alloc_failure();
2843   op_reset();
2844 }
2845 
2846 void ShenandoahHeap::entry_preclean() {
2847   if (ShenandoahPreclean &amp;&amp; process_references()) {
2848     static const char* msg = &quot;Concurrent precleaning&quot;;
2849     ShenandoahConcurrentPhase gc_phase(msg);
2850     EventMark em(&quot;%s&quot;, msg);
2851 
2852     ShenandoahGCSubPhase conc_preclean(ShenandoahPhaseTimings::conc_preclean);
2853 
2854     ShenandoahWorkerScope scope(workers(),
2855                                 ShenandoahWorkerPolicy::calc_workers_for_conc_preclean(),
2856                                 &quot;concurrent preclean&quot;,
2857                                 /* check_workers = */ false);
2858 
2859     try_inject_alloc_failure();
2860     op_preclean();
2861   }
2862 }
2863 
2864 void ShenandoahHeap::entry_uncommit(double shrink_before) {
2865   static const char *msg = &quot;Concurrent uncommit&quot;;
2866   ShenandoahConcurrentPhase gc_phase(msg);
2867   EventMark em(&quot;%s&quot;, msg);
2868 
2869   ShenandoahGCSubPhase phase(ShenandoahPhaseTimings::conc_uncommit);
2870 
2871   op_uncommit(shrink_before);
2872 }
2873 
2874 void ShenandoahHeap::try_inject_alloc_failure() {
2875   if (ShenandoahAllocFailureALot &amp;&amp; !cancelled_gc() &amp;&amp; ((os::random() % 1000) &gt; 950)) {
2876     _inject_alloc_failure.set();
2877     os::naked_short_sleep(1);
2878     if (cancelled_gc()) {
2879       log_info(gc)(&quot;Allocation failure was successfully injected&quot;);
2880     }
2881   }
2882 }
2883 
2884 bool ShenandoahHeap::should_inject_alloc_failure() {
2885   return _inject_alloc_failure.is_set() &amp;&amp; _inject_alloc_failure.try_unset();
2886 }
2887 
2888 void ShenandoahHeap::initialize_serviceability() {
2889   _memory_pool = new ShenandoahMemoryPool(this);
2890   _cycle_memory_manager.add_pool(_memory_pool);
2891   _stw_memory_manager.add_pool(_memory_pool);
2892 }
2893 
2894 GrowableArray&lt;GCMemoryManager*&gt; ShenandoahHeap::memory_managers() {
2895   GrowableArray&lt;GCMemoryManager*&gt; memory_managers(2);
2896   memory_managers.append(&amp;_cycle_memory_manager);
2897   memory_managers.append(&amp;_stw_memory_manager);
2898   return memory_managers;
2899 }
2900 
2901 GrowableArray&lt;MemoryPool*&gt; ShenandoahHeap::memory_pools() {
2902   GrowableArray&lt;MemoryPool*&gt; memory_pools(1);
2903   memory_pools.append(_memory_pool);
2904   return memory_pools;
2905 }
2906 
2907 MemoryUsage ShenandoahHeap::memory_usage() {
2908   return _memory_pool-&gt;get_memory_usage();
2909 }
2910 
2911 void ShenandoahHeap::enter_evacuation() {
2912   _oom_evac_handler.enter_evacuation();
2913 }
2914 
2915 void ShenandoahHeap::leave_evacuation() {
2916   _oom_evac_handler.leave_evacuation();
2917 }
2918 
2919 ShenandoahRegionIterator::ShenandoahRegionIterator() :
2920   _heap(ShenandoahHeap::heap()),
2921   _index(0) {}
2922 
2923 ShenandoahRegionIterator::ShenandoahRegionIterator(ShenandoahHeap* heap) :
2924   _heap(heap),
2925   _index(0) {}
2926 
2927 void ShenandoahRegionIterator::reset() {
2928   _index = 0;
2929 }
2930 
2931 bool ShenandoahRegionIterator::has_next() const {
2932   return _index &lt; _heap-&gt;num_regions();
2933 }
2934 
2935 char ShenandoahHeap::gc_state() const {
2936   return _gc_state.raw_value();
2937 }
2938 
2939 void ShenandoahHeap::deduplicate_string(oop str) {
2940   assert(java_lang_String::is_instance(str), &quot;invariant&quot;);
2941 
2942   if (ShenandoahStringDedup::is_enabled()) {
2943     ShenandoahStringDedup::deduplicate(str);
2944   }
2945 }
2946 
2947 const char* ShenandoahHeap::init_mark_event_message() const {
2948   assert(!has_forwarded_objects(), &quot;Should not have forwarded objects here&quot;);
2949 
2950   bool proc_refs = process_references();
2951   bool unload_cls = unload_classes();
2952 
2953   if (proc_refs &amp;&amp; unload_cls) {
2954     return &quot;Pause Init Mark (process weakrefs) (unload classes)&quot;;
2955   } else if (proc_refs) {
2956     return &quot;Pause Init Mark (process weakrefs)&quot;;
2957   } else if (unload_cls) {
2958     return &quot;Pause Init Mark (unload classes)&quot;;
2959   } else {
2960     return &quot;Pause Init Mark&quot;;
2961   }
2962 }
2963 
2964 const char* ShenandoahHeap::final_mark_event_message() const {
2965   assert(!has_forwarded_objects(), &quot;Should not have forwarded objects here&quot;);
2966 
2967   bool proc_refs = process_references();
2968   bool unload_cls = unload_classes();
2969 
2970   if (proc_refs &amp;&amp; unload_cls) {
2971     return &quot;Pause Final Mark (process weakrefs) (unload classes)&quot;;
2972   } else if (proc_refs) {
2973     return &quot;Pause Final Mark (process weakrefs)&quot;;
2974   } else if (unload_cls) {
2975     return &quot;Pause Final Mark (unload classes)&quot;;
2976   } else {
2977     return &quot;Pause Final Mark&quot;;
2978   }
2979 }
2980 
2981 const char* ShenandoahHeap::conc_mark_event_message() const {
2982   assert(!has_forwarded_objects(), &quot;Should not have forwarded objects here&quot;);
2983 
2984   bool proc_refs = process_references();
2985   bool unload_cls = unload_classes();
2986 
2987   if (proc_refs &amp;&amp; unload_cls) {
2988     return &quot;Concurrent marking (process weakrefs) (unload classes)&quot;;
2989   } else if (proc_refs) {
2990     return &quot;Concurrent marking (process weakrefs)&quot;;
2991   } else if (unload_cls) {
2992     return &quot;Concurrent marking (unload classes)&quot;;
2993   } else {
2994     return &quot;Concurrent marking&quot;;
2995   }
2996 }
2997 
2998 const char* ShenandoahHeap::degen_event_message(ShenandoahDegenPoint point) const {
2999   switch (point) {
3000     case _degenerated_unset:
3001       return &quot;Pause Degenerated GC (&lt;UNSET&gt;)&quot;;
3002     case _degenerated_outside_cycle:
3003       return &quot;Pause Degenerated GC (Outside of Cycle)&quot;;
3004     case _degenerated_mark:
3005       return &quot;Pause Degenerated GC (Mark)&quot;;
3006     case _degenerated_evac:
3007       return &quot;Pause Degenerated GC (Evacuation)&quot;;
3008     case _degenerated_updaterefs:
3009       return &quot;Pause Degenerated GC (Update Refs)&quot;;
3010     default:
3011       ShouldNotReachHere();
3012       return &quot;ERROR&quot;;
3013   }
3014 }
3015 
3016 ShenandoahLiveData* ShenandoahHeap::get_liveness_cache(uint worker_id) {
3017 #ifdef ASSERT
3018   assert(_liveness_cache != NULL, &quot;sanity&quot;);
3019   assert(worker_id &lt; _max_workers, &quot;sanity&quot;);
3020   for (uint i = 0; i &lt; num_regions(); i++) {
3021     assert(_liveness_cache[worker_id][i] == 0, &quot;liveness cache should be empty&quot;);
3022   }
3023 #endif
3024   return _liveness_cache[worker_id];
3025 }
3026 
3027 void ShenandoahHeap::flush_liveness_cache(uint worker_id) {
3028   assert(worker_id &lt; _max_workers, &quot;sanity&quot;);
3029   assert(_liveness_cache != NULL, &quot;sanity&quot;);
3030   ShenandoahLiveData* ld = _liveness_cache[worker_id];
3031   for (uint i = 0; i &lt; num_regions(); i++) {
3032     ShenandoahLiveData live = ld[i];
3033     if (live &gt; 0) {
3034       ShenandoahHeapRegion* r = get_region(i);
3035       r-&gt;increase_live_data_gc_words(live);
3036       ld[i] = 0;
3037     }
3038   }
3039 }
    </pre>
  </body>
</html>
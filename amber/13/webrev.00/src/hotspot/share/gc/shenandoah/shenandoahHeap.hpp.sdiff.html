<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/shenandoahHeap.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahHeap.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahHeap.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahHeap.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHENANDOAH_SHENANDOAHHEAP_HPP
 26 #define SHARE_GC_SHENANDOAH_SHENANDOAHHEAP_HPP
 27 
 28 #include &quot;gc/shared/markBitMap.hpp&quot;
 29 #include &quot;gc/shared/softRefPolicy.hpp&quot;
 30 #include &quot;gc/shared/collectedHeap.hpp&quot;
 31 #include &quot;gc/shenandoah/shenandoahAsserts.hpp&quot;
 32 #include &quot;gc/shenandoah/shenandoahAllocRequest.hpp&quot;
 33 #include &quot;gc/shenandoah/shenandoahLock.hpp&quot;
 34 #include &quot;gc/shenandoah/shenandoahEvacOOMHandler.hpp&quot;

 35 #include &quot;gc/shenandoah/shenandoahSharedVariables.hpp&quot;
 36 #include &quot;gc/shenandoah/shenandoahUnload.hpp&quot;
 37 #include &quot;services/memoryManager.hpp&quot;
 38 #include &quot;utilities/globalDefinitions.hpp&quot;
 39 
 40 class ConcurrentGCTimer;
 41 class ReferenceProcessor;
<span class="line-removed"> 42 class ShenandoahAllocTracker;</span>
 43 class ShenandoahCollectorPolicy;
 44 class ShenandoahControlThread;
 45 class ShenandoahGCSession;
 46 class ShenandoahGCStateResetter;
 47 class ShenandoahHeuristics;
 48 class ShenandoahMarkingContext;
 49 class ShenandoahMarkCompact;
 50 class ShenandoahMode;
 51 class ShenandoahPhaseTimings;
 52 class ShenandoahHeap;
 53 class ShenandoahHeapRegion;
 54 class ShenandoahHeapRegionClosure;
 55 class ShenandoahCollectionSet;
 56 class ShenandoahFreeSet;
 57 class ShenandoahConcurrentMark;
 58 class ShenandoahMarkCompact;
 59 class ShenandoahMonitoringSupport;
 60 class ShenandoahPacer;
<span class="line-removed"> 61 class ShenandoahTraversalGC;</span>
 62 class ShenandoahVerifier;
 63 class ShenandoahWorkGang;
 64 class VMStructs;
 65 










 66 class ShenandoahRegionIterator : public StackObj {
 67 private:
 68   ShenandoahHeap* _heap;
 69 
<span class="line-modified"> 70   DEFINE_PAD_MINUS_SIZE(0, DEFAULT_CACHE_LINE_SIZE, sizeof(volatile size_t));</span>
 71   volatile size_t _index;
<span class="line-modified"> 72   DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, 0);</span>
 73 
 74   // No implicit copying: iterators should be passed by reference to capture the state
 75   NONCOPYABLE(ShenandoahRegionIterator);
 76 
 77 public:
 78   ShenandoahRegionIterator();
 79   ShenandoahRegionIterator(ShenandoahHeap* heap);
 80 
 81   // Reset iterator to default state
 82   void reset();
 83 
 84   // Returns next region, or NULL if there are no more regions.
 85   // This is multi-thread-safe.
 86   inline ShenandoahHeapRegion* next();
 87 
 88   // This is *not* MT safe. However, in the absence of multithreaded access, it
 89   // can be used to determine if there is more work to do.
 90   bool has_next() const;
 91 };
 92 
</pre>
<hr />
<pre>
113 // Shenandoah GC is low-pause concurrent GC that uses Brooks forwarding pointers
114 // to encode forwarding data. See BrooksPointer for details on forwarding data encoding.
115 // See ShenandoahControlThread for GC cycle structure.
116 //
117 class ShenandoahHeap : public CollectedHeap {
118   friend class ShenandoahAsserts;
119   friend class VMStructs;
120   friend class ShenandoahGCSession;
121   friend class ShenandoahGCStateResetter;
122 
123 // ---------- Locks that guard important data structures in Heap
124 //
125 private:
126   ShenandoahHeapLock _lock;
127 
128 public:
129   ShenandoahHeapLock* lock() {
130     return &amp;_lock;
131   }
132 
<span class="line-removed">133   void assert_heaplock_owned_by_current_thread()     NOT_DEBUG_RETURN;</span>
<span class="line-removed">134   void assert_heaplock_not_owned_by_current_thread() NOT_DEBUG_RETURN;</span>
<span class="line-removed">135   void assert_heaplock_or_safepoint()                NOT_DEBUG_RETURN;</span>
<span class="line-removed">136 </span>
137 // ---------- Initialization, termination, identification, printing routines
138 //



139 public:
140   static ShenandoahHeap* heap();
<span class="line-removed">141   static ShenandoahHeap* heap_no_check();</span>
142 
143   const char* name()          const { return &quot;Shenandoah&quot;; }
144   ShenandoahHeap::Name kind() const { return CollectedHeap::Shenandoah; }
145 
146   ShenandoahHeap(ShenandoahCollectorPolicy* policy);
147   jint initialize();
148   void post_initialize();
149   void initialize_heuristics();
150 
151   void initialize_serviceability();
152 
153   void print_on(outputStream* st)              const;
154   void print_extended_on(outputStream *st)     const;
155   void print_tracing_info()                    const;
156   void print_gc_threads_on(outputStream* st)   const;
157   void print_heap_regions_on(outputStream* st) const;
158 
159   void stop();
160 
161   void prepare_for_verify();
162   void verify(VerifyOption vo);
163 
164 // ---------- Heap counters and metrics
165 //
166 private:
167            size_t _initial_size;
168            size_t _minimum_size;
<span class="line-modified">169   DEFINE_PAD_MINUS_SIZE(0, DEFAULT_CACHE_LINE_SIZE, sizeof(volatile size_t));</span>
170   volatile size_t _used;
171   volatile size_t _committed;
172   volatile size_t _bytes_allocated_since_gc_start;
<span class="line-modified">173   DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, 0);</span>
174 
175 public:
176   void increase_used(size_t bytes);
177   void decrease_used(size_t bytes);
178   void set_used(size_t bytes);
179 
180   void increase_committed(size_t bytes);
181   void decrease_committed(size_t bytes);
182   void increase_allocated(size_t bytes);
183 
184   size_t bytes_allocated_since_gc_start();
185   void reset_bytes_allocated_since_gc_start();
186 
187   size_t min_capacity()     const;
188   size_t max_capacity()     const;
189   size_t initial_capacity() const;
190   size_t capacity()         const;
191   size_t used()             const;
192   size_t committed()        const;
193 
</pre>
<hr />
<pre>
236 // GC state describes the important parts of collector state, that may be
237 // used to make barrier selection decisions in the native and generated code.
238 // Multiple bits can be set at once.
239 //
240 // Important invariant: when GC state is zero, the heap is stable, and no barriers
241 // are required.
242 //
243 public:
244   enum GCStateBitPos {
245     // Heap has forwarded objects: needs LRB barriers.
246     HAS_FORWARDED_BITPOS   = 0,
247 
248     // Heap is under marking: needs SATB barriers.
249     MARKING_BITPOS    = 1,
250 
251     // Heap is under evacuation: needs LRB barriers. (Set together with HAS_FORWARDED)
252     EVACUATION_BITPOS = 2,
253 
254     // Heap is under updating: needs no additional barriers.
255     UPDATEREFS_BITPOS = 3,
<span class="line-removed">256 </span>
<span class="line-removed">257     // Heap is under traversal collection</span>
<span class="line-removed">258     TRAVERSAL_BITPOS  = 4</span>
259   };
260 
261   enum GCState {
262     STABLE        = 0,
263     HAS_FORWARDED = 1 &lt;&lt; HAS_FORWARDED_BITPOS,
264     MARKING       = 1 &lt;&lt; MARKING_BITPOS,
265     EVACUATION    = 1 &lt;&lt; EVACUATION_BITPOS,
266     UPDATEREFS    = 1 &lt;&lt; UPDATEREFS_BITPOS,
<span class="line-removed">267     TRAVERSAL     = 1 &lt;&lt; TRAVERSAL_BITPOS</span>
268   };
269 
270 private:
271   ShenandoahSharedBitmap _gc_state;
272   ShenandoahSharedFlag   _degenerated_gc_in_progress;
273   ShenandoahSharedFlag   _full_gc_in_progress;
274   ShenandoahSharedFlag   _full_gc_move_in_progress;
275   ShenandoahSharedFlag   _progress_last_gc;
276   ShenandoahSharedFlag   _concurrent_root_in_progress;
277 
278   void set_gc_state_all_threads(char state);
279   void set_gc_state_mask(uint mask, bool value);
280 
281 public:
282   char gc_state() const;
283   static address gc_state_addr();
284 
285   void set_concurrent_mark_in_progress(bool in_progress);
286   void set_evacuation_in_progress(bool in_progress);
287   void set_update_refs_in_progress(bool in_progress);
288   void set_degenerated_gc_in_progress(bool in_progress);
289   void set_full_gc_in_progress(bool in_progress);
290   void set_full_gc_move_in_progress(bool in_progress);
<span class="line-removed">291   void set_concurrent_traversal_in_progress(bool in_progress);</span>
292   void set_has_forwarded_objects(bool cond);
293   void set_concurrent_root_in_progress(bool cond);
294 
295   inline bool is_stable() const;
296   inline bool is_idle() const;
297   inline bool is_concurrent_mark_in_progress() const;
298   inline bool is_update_refs_in_progress() const;
299   inline bool is_evacuation_in_progress() const;
300   inline bool is_degenerated_gc_in_progress() const;
301   inline bool is_full_gc_in_progress() const;
302   inline bool is_full_gc_move_in_progress() const;
<span class="line-removed">303   inline bool is_concurrent_traversal_in_progress() const;</span>
304   inline bool has_forwarded_objects() const;
305   inline bool is_gc_in_progress_mask(uint mask) const;
306   inline bool is_stw_gc_in_progress() const;
307   inline bool is_concurrent_root_in_progress() const;
308 
309 // ---------- GC cancellation and degeneration machinery
310 //
311 // Cancelled GC flag is used to notify concurrent phases that they should terminate.
312 //
313 public:
314   enum ShenandoahDegenPoint {
315     _degenerated_unset,
<span class="line-removed">316     _degenerated_traversal,</span>
317     _degenerated_outside_cycle,
318     _degenerated_mark,
319     _degenerated_evac,
320     _degenerated_updaterefs,
321     _DEGENERATED_LIMIT
322   };
323 
324   static const char* degen_point_to_string(ShenandoahDegenPoint point) {
325     switch (point) {
326       case _degenerated_unset:
327         return &quot;&lt;UNSET&gt;&quot;;
<span class="line-removed">328       case _degenerated_traversal:</span>
<span class="line-removed">329         return &quot;Traversal&quot;;</span>
330       case _degenerated_outside_cycle:
331         return &quot;Outside of Cycle&quot;;
332       case _degenerated_mark:
333         return &quot;Mark&quot;;
334       case _degenerated_evac:
335         return &quot;Evacuation&quot;;
336       case _degenerated_updaterefs:
337         return &quot;Update Refs&quot;;
338       default:
339         ShouldNotReachHere();
340         return &quot;ERROR&quot;;
341     }
342   };
343 
344 private:
345   enum CancelState {
346     // Normal state. GC has not been cancelled and is open for cancellation.
347     // Worker threads can suspend for safepoint.
348     CANCELLABLE,
349 
</pre>
<hr />
<pre>
360   ShenandoahSharedEnumFlag&lt;CancelState&gt; _cancelled_gc;
361   bool try_cancel_gc();
362 
363 public:
364   static address cancelled_gc_addr();
365 
366   inline bool cancelled_gc() const;
367   inline bool check_cancelled_gc_and_yield(bool sts_active = true);
368 
369   inline void clear_cancelled_gc();
370 
371   void cancel_gc(GCCause::Cause cause);
372 
373 // ---------- GC operations entry points
374 //
375 public:
376   // Entry points to STW GC operations, these cause a related safepoint, that then
377   // call the entry method below
378   void vmop_entry_init_mark();
379   void vmop_entry_final_mark();
<span class="line-removed">380   void vmop_entry_final_evac();</span>
381   void vmop_entry_init_updaterefs();
382   void vmop_entry_final_updaterefs();
<span class="line-removed">383   void vmop_entry_init_traversal();</span>
<span class="line-removed">384   void vmop_entry_final_traversal();</span>
385   void vmop_entry_full(GCCause::Cause cause);
386   void vmop_degenerated(ShenandoahDegenPoint point);
387 
388   // Entry methods to normally STW GC operations. These set up logging, monitoring
389   // and workers for net VM operation
390   void entry_init_mark();
391   void entry_final_mark();
<span class="line-removed">392   void entry_final_evac();</span>
393   void entry_init_updaterefs();
394   void entry_final_updaterefs();
<span class="line-removed">395   void entry_init_traversal();</span>
<span class="line-removed">396   void entry_final_traversal();</span>
397   void entry_full(GCCause::Cause cause);
398   void entry_degenerated(int point);
399 
400   // Entry methods to normally concurrent GC operations. These set up logging, monitoring
401   // for concurrent operation.
402   void entry_reset();
403   void entry_mark();
404   void entry_preclean();
405   void entry_roots();
406   void entry_cleanup();
407   void entry_evac();
408   void entry_updaterefs();
<span class="line-removed">409   void entry_traversal();</span>
410   void entry_uncommit(double shrink_before);
411 
412 private:
413   // Actual work for the phases
414   void op_init_mark();
415   void op_final_mark();
<span class="line-removed">416   void op_final_evac();</span>
417   void op_init_updaterefs();
418   void op_final_updaterefs();
<span class="line-removed">419   void op_init_traversal();</span>
<span class="line-removed">420   void op_final_traversal();</span>
421   void op_full(GCCause::Cause cause);
422   void op_degenerated(ShenandoahDegenPoint point);
423   void op_degenerated_fail();
424   void op_degenerated_futile();
425 
426   void op_reset();
427   void op_mark();
428   void op_preclean();
429   void op_roots();
430   void op_cleanup();
431   void op_conc_evac();
432   void op_stw_evac();
433   void op_updaterefs();
<span class="line-removed">434   void op_traversal();</span>
435   void op_uncommit(double shrink_before);
436 
437   // Messages for GC trace events, they have to be immortal for
438   // passing around the logging/tracing systems
439   const char* init_mark_event_message() const;
440   const char* final_mark_event_message() const;
441   const char* conc_mark_event_message() const;
<span class="line-removed">442   const char* init_traversal_event_message() const;</span>
<span class="line-removed">443   const char* final_traversal_event_message() const;</span>
<span class="line-removed">444   const char* conc_traversal_event_message() const;</span>
445   const char* degen_event_message(ShenandoahDegenPoint point) const;
446 
447 // ---------- GC subsystems
448 //
449 private:
450   ShenandoahControlThread*   _control_thread;
451   ShenandoahCollectorPolicy* _shenandoah_policy;
452   ShenandoahMode*            _gc_mode;
453   ShenandoahHeuristics*      _heuristics;
454   ShenandoahFreeSet*         _free_set;
455   ShenandoahConcurrentMark*  _scm;
<span class="line-removed">456   ShenandoahTraversalGC*     _traversal_gc;</span>
457   ShenandoahMarkCompact*     _full_gc;
458   ShenandoahPacer*           _pacer;
459   ShenandoahVerifier*        _verifier;
460 
461   ShenandoahPhaseTimings*    _phase_timings;
462 
463   ShenandoahControlThread*   control_thread()          { return _control_thread;    }
464   ShenandoahMarkCompact*     full_gc()                 { return _full_gc;           }
465 
466 public:
467   ShenandoahCollectorPolicy* shenandoah_policy() const { return _shenandoah_policy; }
468   ShenandoahHeuristics*      heuristics()        const { return _heuristics;        }
469   ShenandoahFreeSet*         free_set()          const { return _free_set;          }
470   ShenandoahConcurrentMark*  concurrent_mark()         { return _scm;               }
<span class="line-removed">471   ShenandoahTraversalGC*     traversal_gc()      const { return _traversal_gc;      }</span>
<span class="line-removed">472   bool                       is_traversal_mode() const { return _traversal_gc != NULL; }</span>
473   ShenandoahPacer*           pacer()             const { return _pacer;             }
474 
475   ShenandoahPhaseTimings*    phase_timings()     const { return _phase_timings;     }
476 
477   ShenandoahVerifier*        verifier();
478 
479 // ---------- VM subsystem bindings
480 //
481 private:
482   ShenandoahMonitoringSupport* _monitoring_support;
483   MemoryPool*                  _memory_pool;
484   GCMemoryManager              _stw_memory_manager;
485   GCMemoryManager              _cycle_memory_manager;
486   ConcurrentGCTimer*           _gc_timer;
487   SoftRefPolicy                _soft_ref_policy;
488 
489   // For exporting to SA
490   int                          _log_min_obj_alignment_in_bytes;
491 public:
492   ShenandoahMonitoringSupport* monitoring_support() { return _monitoring_support;    }
493   GCMemoryManager* cycle_memory_manager()           { return &amp;_cycle_memory_manager; }
494   GCMemoryManager* stw_memory_manager()             { return &amp;_stw_memory_manager;   }
495   SoftRefPolicy* soft_ref_policy()                  { return &amp;_soft_ref_policy;      }
496 
497   GrowableArray&lt;GCMemoryManager*&gt; memory_managers();
498   GrowableArray&lt;MemoryPool*&gt; memory_pools();
499   MemoryUsage memory_usage();
500   GCTracer* tracer();
<span class="line-modified">501   GCTimer* gc_timer() const;</span>
502 
503 // ---------- Reference processing
504 //
505 private:
506   AlwaysTrueClosure    _subject_to_discovery;
507   ReferenceProcessor*  _ref_processor;
508   ShenandoahSharedFlag _process_references;
509 
510   void ref_processing_init();
511 
512 public:
513   ReferenceProcessor* ref_processor() { return _ref_processor; }
514   void set_process_references(bool pr);
515   bool process_references() const;
516 
517 // ---------- Class Unloading
518 //
519 private:
520   ShenandoahSharedFlag _unload_classes;
521   ShenandoahUnload     _unloader;
</pre>
<hr />
<pre>
625 
626   void ensure_parsability(bool retire_tlabs);
627   void make_parsable(bool retire_tlabs);
628 
629 // ---------- Marking support
630 //
631 private:
632   ShenandoahMarkingContext* _marking_context;
633   MemRegion  _bitmap_region;
634   MemRegion  _aux_bitmap_region;
635   MarkBitMap _verification_bit_map;
636   MarkBitMap _aux_bit_map;
637 
638   size_t _bitmap_size;
639   size_t _bitmap_regions_per_slice;
640   size_t _bitmap_bytes_per_slice;
641 
642   bool _bitmap_region_special;
643   bool _aux_bitmap_region_special;
644 
<span class="line-modified">645   // Used for buffering per-region liveness data.</span>
<span class="line-removed">646   // Needed since ShenandoahHeapRegion uses atomics to update liveness.</span>
<span class="line-removed">647   //</span>
<span class="line-removed">648   // The array has max-workers elements, each of which is an array of</span>
<span class="line-removed">649   // jushort * max_regions. The choice of jushort is not accidental:</span>
<span class="line-removed">650   // there is a tradeoff between static/dynamic footprint that translates</span>
<span class="line-removed">651   // into cache pressure (which is already high during marking), and</span>
<span class="line-removed">652   // too many atomic updates. size_t/jint is too large, jbyte is too small.</span>
<span class="line-removed">653   jushort** _liveness_cache;</span>
654 
655 public:
656   inline ShenandoahMarkingContext* complete_marking_context() const;
657   inline ShenandoahMarkingContext* marking_context() const;
658   inline void mark_complete_marking_context();
659   inline void mark_incomplete_marking_context();
660 
661   template&lt;class T&gt;
662   inline void marked_object_iterate(ShenandoahHeapRegion* region, T* cl);
663 
664   template&lt;class T&gt;
665   inline void marked_object_iterate(ShenandoahHeapRegion* region, T* cl, HeapWord* limit);
666 
667   template&lt;class T&gt;
668   inline void marked_object_oop_iterate(ShenandoahHeapRegion* region, T* cl, HeapWord* limit);
669 
670   void reset_mark_bitmap();
671 
672   // SATB barriers hooks
673   template&lt;bool RESOLVE&gt;
674   inline bool requires_marking(const void* entry) const;
675   void force_satb_flush_all_threads();
676 
677   // Support for bitmap uncommits
678   bool commit_bitmap_slice(ShenandoahHeapRegion *r);
679   bool uncommit_bitmap_slice(ShenandoahHeapRegion *r);
680   bool is_bitmap_slice_committed(ShenandoahHeapRegion* r, bool skip_self = false);
681 
682   // Liveness caching support
<span class="line-modified">683   jushort* get_liveness_cache(uint worker_id);</span>
684   void flush_liveness_cache(uint worker_id);
685 
686 // ---------- Evacuation support
687 //
688 private:
689   ShenandoahCollectionSet* _collection_set;
690   ShenandoahEvacOOMHandler _oom_evac_handler;
691 
692   void evacuate_and_update_roots();
693 
694 public:
695   static address in_cset_fast_test_addr();
696 
697   ShenandoahCollectionSet* collection_set() const { return _collection_set; }
698 
699   // Checks if object is in the collection set.
700   inline bool in_collection_set(oop obj) const;
701 
702   // Checks if location is in the collection set. Can be interior pointer, not the oop itself.
703   inline bool in_collection_set_loc(void* loc) const;
</pre>
</td>
<td>
<hr />
<pre>
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHENANDOAH_SHENANDOAHHEAP_HPP
 26 #define SHARE_GC_SHENANDOAH_SHENANDOAHHEAP_HPP
 27 
 28 #include &quot;gc/shared/markBitMap.hpp&quot;
 29 #include &quot;gc/shared/softRefPolicy.hpp&quot;
 30 #include &quot;gc/shared/collectedHeap.hpp&quot;
 31 #include &quot;gc/shenandoah/shenandoahAsserts.hpp&quot;
 32 #include &quot;gc/shenandoah/shenandoahAllocRequest.hpp&quot;
 33 #include &quot;gc/shenandoah/shenandoahLock.hpp&quot;
 34 #include &quot;gc/shenandoah/shenandoahEvacOOMHandler.hpp&quot;
<span class="line-added"> 35 #include &quot;gc/shenandoah/shenandoahPadding.hpp&quot;</span>
 36 #include &quot;gc/shenandoah/shenandoahSharedVariables.hpp&quot;
 37 #include &quot;gc/shenandoah/shenandoahUnload.hpp&quot;
 38 #include &quot;services/memoryManager.hpp&quot;
 39 #include &quot;utilities/globalDefinitions.hpp&quot;
 40 
 41 class ConcurrentGCTimer;
 42 class ReferenceProcessor;

 43 class ShenandoahCollectorPolicy;
 44 class ShenandoahControlThread;
 45 class ShenandoahGCSession;
 46 class ShenandoahGCStateResetter;
 47 class ShenandoahHeuristics;
 48 class ShenandoahMarkingContext;
 49 class ShenandoahMarkCompact;
 50 class ShenandoahMode;
 51 class ShenandoahPhaseTimings;
 52 class ShenandoahHeap;
 53 class ShenandoahHeapRegion;
 54 class ShenandoahHeapRegionClosure;
 55 class ShenandoahCollectionSet;
 56 class ShenandoahFreeSet;
 57 class ShenandoahConcurrentMark;
 58 class ShenandoahMarkCompact;
 59 class ShenandoahMonitoringSupport;
 60 class ShenandoahPacer;

 61 class ShenandoahVerifier;
 62 class ShenandoahWorkGang;
 63 class VMStructs;
 64 
<span class="line-added"> 65 // Used for buffering per-region liveness data.</span>
<span class="line-added"> 66 // Needed since ShenandoahHeapRegion uses atomics to update liveness.</span>
<span class="line-added"> 67 // The ShenandoahHeap array has max-workers elements, each of which is an array of</span>
<span class="line-added"> 68 // uint16_t * max_regions. The choice of uint16_t is not accidental:</span>
<span class="line-added"> 69 // there is a tradeoff between static/dynamic footprint that translates</span>
<span class="line-added"> 70 // into cache pressure (which is already high during marking), and</span>
<span class="line-added"> 71 // too many atomic updates. uint32_t is too large, uint8_t is too small.</span>
<span class="line-added"> 72 typedef uint16_t ShenandoahLiveData;</span>
<span class="line-added"> 73 #define SHENANDOAH_LIVEDATA_MAX ((ShenandoahLiveData)-1)</span>
<span class="line-added"> 74 </span>
 75 class ShenandoahRegionIterator : public StackObj {
 76 private:
 77   ShenandoahHeap* _heap;
 78 
<span class="line-modified"> 79   shenandoah_padding(0);</span>
 80   volatile size_t _index;
<span class="line-modified"> 81   shenandoah_padding(1);</span>
 82 
 83   // No implicit copying: iterators should be passed by reference to capture the state
 84   NONCOPYABLE(ShenandoahRegionIterator);
 85 
 86 public:
 87   ShenandoahRegionIterator();
 88   ShenandoahRegionIterator(ShenandoahHeap* heap);
 89 
 90   // Reset iterator to default state
 91   void reset();
 92 
 93   // Returns next region, or NULL if there are no more regions.
 94   // This is multi-thread-safe.
 95   inline ShenandoahHeapRegion* next();
 96 
 97   // This is *not* MT safe. However, in the absence of multithreaded access, it
 98   // can be used to determine if there is more work to do.
 99   bool has_next() const;
100 };
101 
</pre>
<hr />
<pre>
122 // Shenandoah GC is low-pause concurrent GC that uses Brooks forwarding pointers
123 // to encode forwarding data. See BrooksPointer for details on forwarding data encoding.
124 // See ShenandoahControlThread for GC cycle structure.
125 //
126 class ShenandoahHeap : public CollectedHeap {
127   friend class ShenandoahAsserts;
128   friend class VMStructs;
129   friend class ShenandoahGCSession;
130   friend class ShenandoahGCStateResetter;
131 
132 // ---------- Locks that guard important data structures in Heap
133 //
134 private:
135   ShenandoahHeapLock _lock;
136 
137 public:
138   ShenandoahHeapLock* lock() {
139     return &amp;_lock;
140   }
141 




142 // ---------- Initialization, termination, identification, printing routines
143 //
<span class="line-added">144 private:</span>
<span class="line-added">145   static ShenandoahHeap* _heap;</span>
<span class="line-added">146 </span>
147 public:
148   static ShenandoahHeap* heap();

149 
150   const char* name()          const { return &quot;Shenandoah&quot;; }
151   ShenandoahHeap::Name kind() const { return CollectedHeap::Shenandoah; }
152 
153   ShenandoahHeap(ShenandoahCollectorPolicy* policy);
154   jint initialize();
155   void post_initialize();
156   void initialize_heuristics();
157 
158   void initialize_serviceability();
159 
160   void print_on(outputStream* st)              const;
161   void print_extended_on(outputStream *st)     const;
162   void print_tracing_info()                    const;
163   void print_gc_threads_on(outputStream* st)   const;
164   void print_heap_regions_on(outputStream* st) const;
165 
166   void stop();
167 
168   void prepare_for_verify();
169   void verify(VerifyOption vo);
170 
171 // ---------- Heap counters and metrics
172 //
173 private:
174            size_t _initial_size;
175            size_t _minimum_size;
<span class="line-modified">176   shenandoah_padding(0);</span>
177   volatile size_t _used;
178   volatile size_t _committed;
179   volatile size_t _bytes_allocated_since_gc_start;
<span class="line-modified">180   shenandoah_padding(1);</span>
181 
182 public:
183   void increase_used(size_t bytes);
184   void decrease_used(size_t bytes);
185   void set_used(size_t bytes);
186 
187   void increase_committed(size_t bytes);
188   void decrease_committed(size_t bytes);
189   void increase_allocated(size_t bytes);
190 
191   size_t bytes_allocated_since_gc_start();
192   void reset_bytes_allocated_since_gc_start();
193 
194   size_t min_capacity()     const;
195   size_t max_capacity()     const;
196   size_t initial_capacity() const;
197   size_t capacity()         const;
198   size_t used()             const;
199   size_t committed()        const;
200 
</pre>
<hr />
<pre>
243 // GC state describes the important parts of collector state, that may be
244 // used to make barrier selection decisions in the native and generated code.
245 // Multiple bits can be set at once.
246 //
247 // Important invariant: when GC state is zero, the heap is stable, and no barriers
248 // are required.
249 //
250 public:
251   enum GCStateBitPos {
252     // Heap has forwarded objects: needs LRB barriers.
253     HAS_FORWARDED_BITPOS   = 0,
254 
255     // Heap is under marking: needs SATB barriers.
256     MARKING_BITPOS    = 1,
257 
258     // Heap is under evacuation: needs LRB barriers. (Set together with HAS_FORWARDED)
259     EVACUATION_BITPOS = 2,
260 
261     // Heap is under updating: needs no additional barriers.
262     UPDATEREFS_BITPOS = 3,



263   };
264 
265   enum GCState {
266     STABLE        = 0,
267     HAS_FORWARDED = 1 &lt;&lt; HAS_FORWARDED_BITPOS,
268     MARKING       = 1 &lt;&lt; MARKING_BITPOS,
269     EVACUATION    = 1 &lt;&lt; EVACUATION_BITPOS,
270     UPDATEREFS    = 1 &lt;&lt; UPDATEREFS_BITPOS,

271   };
272 
273 private:
274   ShenandoahSharedBitmap _gc_state;
275   ShenandoahSharedFlag   _degenerated_gc_in_progress;
276   ShenandoahSharedFlag   _full_gc_in_progress;
277   ShenandoahSharedFlag   _full_gc_move_in_progress;
278   ShenandoahSharedFlag   _progress_last_gc;
279   ShenandoahSharedFlag   _concurrent_root_in_progress;
280 
281   void set_gc_state_all_threads(char state);
282   void set_gc_state_mask(uint mask, bool value);
283 
284 public:
285   char gc_state() const;
286   static address gc_state_addr();
287 
288   void set_concurrent_mark_in_progress(bool in_progress);
289   void set_evacuation_in_progress(bool in_progress);
290   void set_update_refs_in_progress(bool in_progress);
291   void set_degenerated_gc_in_progress(bool in_progress);
292   void set_full_gc_in_progress(bool in_progress);
293   void set_full_gc_move_in_progress(bool in_progress);

294   void set_has_forwarded_objects(bool cond);
295   void set_concurrent_root_in_progress(bool cond);
296 
297   inline bool is_stable() const;
298   inline bool is_idle() const;
299   inline bool is_concurrent_mark_in_progress() const;
300   inline bool is_update_refs_in_progress() const;
301   inline bool is_evacuation_in_progress() const;
302   inline bool is_degenerated_gc_in_progress() const;
303   inline bool is_full_gc_in_progress() const;
304   inline bool is_full_gc_move_in_progress() const;

305   inline bool has_forwarded_objects() const;
306   inline bool is_gc_in_progress_mask(uint mask) const;
307   inline bool is_stw_gc_in_progress() const;
308   inline bool is_concurrent_root_in_progress() const;
309 
310 // ---------- GC cancellation and degeneration machinery
311 //
312 // Cancelled GC flag is used to notify concurrent phases that they should terminate.
313 //
314 public:
315   enum ShenandoahDegenPoint {
316     _degenerated_unset,

317     _degenerated_outside_cycle,
318     _degenerated_mark,
319     _degenerated_evac,
320     _degenerated_updaterefs,
321     _DEGENERATED_LIMIT
322   };
323 
324   static const char* degen_point_to_string(ShenandoahDegenPoint point) {
325     switch (point) {
326       case _degenerated_unset:
327         return &quot;&lt;UNSET&gt;&quot;;


328       case _degenerated_outside_cycle:
329         return &quot;Outside of Cycle&quot;;
330       case _degenerated_mark:
331         return &quot;Mark&quot;;
332       case _degenerated_evac:
333         return &quot;Evacuation&quot;;
334       case _degenerated_updaterefs:
335         return &quot;Update Refs&quot;;
336       default:
337         ShouldNotReachHere();
338         return &quot;ERROR&quot;;
339     }
340   };
341 
342 private:
343   enum CancelState {
344     // Normal state. GC has not been cancelled and is open for cancellation.
345     // Worker threads can suspend for safepoint.
346     CANCELLABLE,
347 
</pre>
<hr />
<pre>
358   ShenandoahSharedEnumFlag&lt;CancelState&gt; _cancelled_gc;
359   bool try_cancel_gc();
360 
361 public:
362   static address cancelled_gc_addr();
363 
364   inline bool cancelled_gc() const;
365   inline bool check_cancelled_gc_and_yield(bool sts_active = true);
366 
367   inline void clear_cancelled_gc();
368 
369   void cancel_gc(GCCause::Cause cause);
370 
371 // ---------- GC operations entry points
372 //
373 public:
374   // Entry points to STW GC operations, these cause a related safepoint, that then
375   // call the entry method below
376   void vmop_entry_init_mark();
377   void vmop_entry_final_mark();

378   void vmop_entry_init_updaterefs();
379   void vmop_entry_final_updaterefs();


380   void vmop_entry_full(GCCause::Cause cause);
381   void vmop_degenerated(ShenandoahDegenPoint point);
382 
383   // Entry methods to normally STW GC operations. These set up logging, monitoring
384   // and workers for net VM operation
385   void entry_init_mark();
386   void entry_final_mark();

387   void entry_init_updaterefs();
388   void entry_final_updaterefs();


389   void entry_full(GCCause::Cause cause);
390   void entry_degenerated(int point);
391 
392   // Entry methods to normally concurrent GC operations. These set up logging, monitoring
393   // for concurrent operation.
394   void entry_reset();
395   void entry_mark();
396   void entry_preclean();
397   void entry_roots();
398   void entry_cleanup();
399   void entry_evac();
400   void entry_updaterefs();

401   void entry_uncommit(double shrink_before);
402 
403 private:
404   // Actual work for the phases
405   void op_init_mark();
406   void op_final_mark();

407   void op_init_updaterefs();
408   void op_final_updaterefs();


409   void op_full(GCCause::Cause cause);
410   void op_degenerated(ShenandoahDegenPoint point);
411   void op_degenerated_fail();
412   void op_degenerated_futile();
413 
414   void op_reset();
415   void op_mark();
416   void op_preclean();
417   void op_roots();
418   void op_cleanup();
419   void op_conc_evac();
420   void op_stw_evac();
421   void op_updaterefs();

422   void op_uncommit(double shrink_before);
423 
424   // Messages for GC trace events, they have to be immortal for
425   // passing around the logging/tracing systems
426   const char* init_mark_event_message() const;
427   const char* final_mark_event_message() const;
428   const char* conc_mark_event_message() const;



429   const char* degen_event_message(ShenandoahDegenPoint point) const;
430 
431 // ---------- GC subsystems
432 //
433 private:
434   ShenandoahControlThread*   _control_thread;
435   ShenandoahCollectorPolicy* _shenandoah_policy;
436   ShenandoahMode*            _gc_mode;
437   ShenandoahHeuristics*      _heuristics;
438   ShenandoahFreeSet*         _free_set;
439   ShenandoahConcurrentMark*  _scm;

440   ShenandoahMarkCompact*     _full_gc;
441   ShenandoahPacer*           _pacer;
442   ShenandoahVerifier*        _verifier;
443 
444   ShenandoahPhaseTimings*    _phase_timings;
445 
446   ShenandoahControlThread*   control_thread()          { return _control_thread;    }
447   ShenandoahMarkCompact*     full_gc()                 { return _full_gc;           }
448 
449 public:
450   ShenandoahCollectorPolicy* shenandoah_policy() const { return _shenandoah_policy; }
451   ShenandoahHeuristics*      heuristics()        const { return _heuristics;        }
452   ShenandoahFreeSet*         free_set()          const { return _free_set;          }
453   ShenandoahConcurrentMark*  concurrent_mark()         { return _scm;               }


454   ShenandoahPacer*           pacer()             const { return _pacer;             }
455 
456   ShenandoahPhaseTimings*    phase_timings()     const { return _phase_timings;     }
457 
458   ShenandoahVerifier*        verifier();
459 
460 // ---------- VM subsystem bindings
461 //
462 private:
463   ShenandoahMonitoringSupport* _monitoring_support;
464   MemoryPool*                  _memory_pool;
465   GCMemoryManager              _stw_memory_manager;
466   GCMemoryManager              _cycle_memory_manager;
467   ConcurrentGCTimer*           _gc_timer;
468   SoftRefPolicy                _soft_ref_policy;
469 
470   // For exporting to SA
471   int                          _log_min_obj_alignment_in_bytes;
472 public:
473   ShenandoahMonitoringSupport* monitoring_support() { return _monitoring_support;    }
474   GCMemoryManager* cycle_memory_manager()           { return &amp;_cycle_memory_manager; }
475   GCMemoryManager* stw_memory_manager()             { return &amp;_stw_memory_manager;   }
476   SoftRefPolicy* soft_ref_policy()                  { return &amp;_soft_ref_policy;      }
477 
478   GrowableArray&lt;GCMemoryManager*&gt; memory_managers();
479   GrowableArray&lt;MemoryPool*&gt; memory_pools();
480   MemoryUsage memory_usage();
481   GCTracer* tracer();
<span class="line-modified">482   ConcurrentGCTimer* gc_timer() const;</span>
483 
484 // ---------- Reference processing
485 //
486 private:
487   AlwaysTrueClosure    _subject_to_discovery;
488   ReferenceProcessor*  _ref_processor;
489   ShenandoahSharedFlag _process_references;
490 
491   void ref_processing_init();
492 
493 public:
494   ReferenceProcessor* ref_processor() { return _ref_processor; }
495   void set_process_references(bool pr);
496   bool process_references() const;
497 
498 // ---------- Class Unloading
499 //
500 private:
501   ShenandoahSharedFlag _unload_classes;
502   ShenandoahUnload     _unloader;
</pre>
<hr />
<pre>
606 
607   void ensure_parsability(bool retire_tlabs);
608   void make_parsable(bool retire_tlabs);
609 
610 // ---------- Marking support
611 //
612 private:
613   ShenandoahMarkingContext* _marking_context;
614   MemRegion  _bitmap_region;
615   MemRegion  _aux_bitmap_region;
616   MarkBitMap _verification_bit_map;
617   MarkBitMap _aux_bit_map;
618 
619   size_t _bitmap_size;
620   size_t _bitmap_regions_per_slice;
621   size_t _bitmap_bytes_per_slice;
622 
623   bool _bitmap_region_special;
624   bool _aux_bitmap_region_special;
625 
<span class="line-modified">626   ShenandoahLiveData** _liveness_cache;</span>








627 
628 public:
629   inline ShenandoahMarkingContext* complete_marking_context() const;
630   inline ShenandoahMarkingContext* marking_context() const;
631   inline void mark_complete_marking_context();
632   inline void mark_incomplete_marking_context();
633 
634   template&lt;class T&gt;
635   inline void marked_object_iterate(ShenandoahHeapRegion* region, T* cl);
636 
637   template&lt;class T&gt;
638   inline void marked_object_iterate(ShenandoahHeapRegion* region, T* cl, HeapWord* limit);
639 
640   template&lt;class T&gt;
641   inline void marked_object_oop_iterate(ShenandoahHeapRegion* region, T* cl, HeapWord* limit);
642 
643   void reset_mark_bitmap();
644 
645   // SATB barriers hooks
646   template&lt;bool RESOLVE&gt;
647   inline bool requires_marking(const void* entry) const;
648   void force_satb_flush_all_threads();
649 
650   // Support for bitmap uncommits
651   bool commit_bitmap_slice(ShenandoahHeapRegion *r);
652   bool uncommit_bitmap_slice(ShenandoahHeapRegion *r);
653   bool is_bitmap_slice_committed(ShenandoahHeapRegion* r, bool skip_self = false);
654 
655   // Liveness caching support
<span class="line-modified">656   ShenandoahLiveData* get_liveness_cache(uint worker_id);</span>
657   void flush_liveness_cache(uint worker_id);
658 
659 // ---------- Evacuation support
660 //
661 private:
662   ShenandoahCollectionSet* _collection_set;
663   ShenandoahEvacOOMHandler _oom_evac_handler;
664 
665   void evacuate_and_update_roots();
666 
667 public:
668   static address in_cset_fast_test_addr();
669 
670   ShenandoahCollectionSet* collection_set() const { return _collection_set; }
671 
672   // Checks if object is in the collection set.
673   inline bool in_collection_set(oop obj) const;
674 
675   // Checks if location is in the collection set. Can be interior pointer, not the oop itself.
676   inline bool in_collection_set_loc(void* loc) const;
</pre>
</td>
</tr>
</table>
<center><a href="shenandoahHeap.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahHeap.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
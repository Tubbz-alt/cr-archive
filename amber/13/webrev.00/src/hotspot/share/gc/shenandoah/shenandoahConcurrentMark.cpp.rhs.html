<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/shenandoah/shenandoahConcurrentMark.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2013, 2020, Red Hat, Inc. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 
 27 #include &quot;classfile/symbolTable.hpp&quot;
 28 #include &quot;classfile/systemDictionary.hpp&quot;
 29 #include &quot;code/codeCache.hpp&quot;
 30 
 31 #include &quot;gc/shared/weakProcessor.inline.hpp&quot;
 32 #include &quot;gc/shared/gcTimer.hpp&quot;
<a name="1" id="anc1"></a><span class="line-added"> 33 #include &quot;gc/shared/gcTrace.hpp&quot;</span>
 34 #include &quot;gc/shared/referenceProcessor.hpp&quot;
 35 #include &quot;gc/shared/referenceProcessorPhaseTimes.hpp&quot;
 36 #include &quot;gc/shared/strongRootsScope.hpp&quot;
 37 
 38 #include &quot;gc/shenandoah/shenandoahBarrierSet.inline.hpp&quot;
 39 #include &quot;gc/shenandoah/shenandoahClosures.inline.hpp&quot;
 40 #include &quot;gc/shenandoah/shenandoahConcurrentMark.inline.hpp&quot;
 41 #include &quot;gc/shenandoah/shenandoahMarkCompact.hpp&quot;
 42 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
 43 #include &quot;gc/shenandoah/shenandoahRootProcessor.inline.hpp&quot;
 44 #include &quot;gc/shenandoah/shenandoahOopClosures.inline.hpp&quot;
<a name="2" id="anc2"></a><span class="line-added"> 45 #include &quot;gc/shenandoah/shenandoahPhaseTimings.hpp&quot;</span>
 46 #include &quot;gc/shenandoah/shenandoahTaskqueue.inline.hpp&quot;
<a name="3" id="anc3"></a>
 47 #include &quot;gc/shenandoah/shenandoahUtils.hpp&quot;
 48 
 49 #include &quot;memory/iterator.inline.hpp&quot;
 50 #include &quot;memory/metaspace.hpp&quot;
 51 #include &quot;memory/resourceArea.hpp&quot;
 52 #include &quot;oops/oop.inline.hpp&quot;
 53 #include &quot;runtime/handles.inline.hpp&quot;
 54 
 55 template&lt;UpdateRefsMode UPDATE_REFS&gt;
 56 class ShenandoahInitMarkRootsClosure : public OopClosure {
 57 private:
 58   ShenandoahObjToScanQueue* _queue;
 59   ShenandoahHeap* _heap;
 60   ShenandoahMarkingContext* const _mark_context;
 61 
 62   template &lt;class T&gt;
 63   inline void do_oop_work(T* p) {
 64     ShenandoahConcurrentMark::mark_through_ref&lt;T, UPDATE_REFS, NO_DEDUP&gt;(p, _heap, _queue, _mark_context);
 65   }
 66 
 67 public:
 68   ShenandoahInitMarkRootsClosure(ShenandoahObjToScanQueue* q) :
 69     _queue(q),
 70     _heap(ShenandoahHeap::heap()),
 71     _mark_context(_heap-&gt;marking_context()) {};
 72 
 73   void do_oop(narrowOop* p) { do_oop_work(p); }
 74   void do_oop(oop* p)       { do_oop_work(p); }
 75 };
 76 
 77 ShenandoahMarkRefsSuperClosure::ShenandoahMarkRefsSuperClosure(ShenandoahObjToScanQueue* q, ReferenceProcessor* rp) :
 78   MetadataVisitingOopIterateClosure(rp),
 79   _queue(q),
 80   _heap(ShenandoahHeap::heap()),
 81   _mark_context(_heap-&gt;marking_context())
 82 { }
 83 
 84 template&lt;UpdateRefsMode UPDATE_REFS&gt;
 85 class ShenandoahInitMarkRootsTask : public AbstractGangTask {
 86 private:
 87   ShenandoahAllRootScanner* _rp;
<a name="4" id="anc4"></a>
 88 public:
<a name="5" id="anc5"></a><span class="line-modified"> 89   ShenandoahInitMarkRootsTask(ShenandoahAllRootScanner* rp) :</span>
 90     AbstractGangTask(&quot;Shenandoah init mark roots task&quot;),
<a name="6" id="anc6"></a><span class="line-modified"> 91     _rp(rp) {</span>

 92   }
 93 
 94   void work(uint worker_id) {
 95     assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
 96     ShenandoahParallelWorkerSession worker_session(worker_id);
 97 
 98     ShenandoahHeap* heap = ShenandoahHeap::heap();
 99     ShenandoahObjToScanQueueSet* queues = heap-&gt;concurrent_mark()-&gt;task_queues();
100     assert(queues-&gt;get_reserved() &gt; worker_id, &quot;Queue has not been reserved for worker id: %d&quot;, worker_id);
101 
102     ShenandoahObjToScanQueue* q = queues-&gt;queue(worker_id);
103 
104     ShenandoahInitMarkRootsClosure&lt;UPDATE_REFS&gt; mark_cl(q);
105     do_work(heap, &amp;mark_cl, worker_id);
106   }
107 
108 private:
109   void do_work(ShenandoahHeap* heap, OopClosure* oops, uint worker_id) {
110     // The rationale for selecting the roots to scan is as follows:
111     //   a. With unload_classes = true, we only want to scan the actual strong roots from the
112     //      code cache. This will allow us to identify the dead classes, unload them, *and*
113     //      invalidate the relevant code cache blobs. This could be only done together with
114     //      class unloading.
115     //   b. With unload_classes = false, we have to nominally retain all the references from code
116     //      cache, because there could be the case of embedded class/oop in the generated code,
117     //      which we will never visit during mark. Without code cache invalidation, as in (a),
118     //      we risk executing that code cache blob, and crashing.
119     if (heap-&gt;unload_classes()) {
120       _rp-&gt;strong_roots_do(worker_id, oops);
121     } else {
122       _rp-&gt;roots_do(worker_id, oops);
123     }
124   }
125 };
126 
127 class ShenandoahUpdateRootsTask : public AbstractGangTask {
128 private:
129   ShenandoahRootUpdater*  _root_updater;
130   bool                    _check_alive;
131 public:
132   ShenandoahUpdateRootsTask(ShenandoahRootUpdater* root_updater, bool check_alive) :
133     AbstractGangTask(&quot;Shenandoah update roots task&quot;),
134     _root_updater(root_updater),
135     _check_alive(check_alive){
136   }
137 
138   void work(uint worker_id) {
139     assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
140     ShenandoahParallelWorkerSession worker_session(worker_id);
141 
142     ShenandoahHeap* heap = ShenandoahHeap::heap();
143     ShenandoahUpdateRefsClosure cl;
144     if (_check_alive) {
145       ShenandoahForwardedIsAliveClosure is_alive;
146       _root_updater-&gt;roots_do&lt;ShenandoahForwardedIsAliveClosure, ShenandoahUpdateRefsClosure&gt;(worker_id, &amp;is_alive, &amp;cl);
147     } else {
148       AlwaysTrueClosure always_true;;
149       _root_updater-&gt;roots_do&lt;AlwaysTrueClosure, ShenandoahUpdateRefsClosure&gt;(worker_id, &amp;always_true, &amp;cl);
150     }
151   }
152 };
153 
154 class ShenandoahConcurrentMarkingTask : public AbstractGangTask {
155 private:
156   ShenandoahConcurrentMark* _cm;
157   TaskTerminator* _terminator;
158 
159 public:
160   ShenandoahConcurrentMarkingTask(ShenandoahConcurrentMark* cm, TaskTerminator* terminator) :
161     AbstractGangTask(&quot;Root Region Scan&quot;), _cm(cm), _terminator(terminator) {
162   }
163 
164   void work(uint worker_id) {
165     ShenandoahHeap* heap = ShenandoahHeap::heap();
166     ShenandoahConcurrentWorkerSession worker_session(worker_id);
167     ShenandoahSuspendibleThreadSetJoiner stsj(ShenandoahSuspendibleWorkers);
168     ShenandoahObjToScanQueue* q = _cm-&gt;get_queue(worker_id);
169     ReferenceProcessor* rp;
170     if (heap-&gt;process_references()) {
171       rp = heap-&gt;ref_processor();
172       shenandoah_assert_rp_isalive_installed();
173     } else {
174       rp = NULL;
175     }
176 
177     _cm-&gt;concurrent_scan_code_roots(worker_id, rp);
178     _cm-&gt;mark_loop(worker_id, _terminator, rp,
179                    true, // cancellable
180                    ShenandoahStringDedup::is_enabled()); // perform string dedup
181   }
182 };
183 
<a name="7" id="anc7"></a><span class="line-modified">184 class ShenandoahSATBAndRemarkCodeRootsThreadsClosure : public ThreadClosure {</span>
185 private:
186   ShenandoahSATBBufferClosure* _satb_cl;
<a name="8" id="anc8"></a><span class="line-added">187   OopClosure*            const _cl;</span>
<span class="line-added">188   MarkingCodeBlobClosure*      _code_cl;</span>
189   uintx _claim_token;
190 
191 public:
<a name="9" id="anc9"></a><span class="line-modified">192   ShenandoahSATBAndRemarkCodeRootsThreadsClosure(ShenandoahSATBBufferClosure* satb_cl, OopClosure* cl, MarkingCodeBlobClosure* code_cl) :</span>
<span class="line-modified">193     _satb_cl(satb_cl), _cl(cl), _code_cl(code_cl),</span>
194     _claim_token(Threads::thread_claim_token()) {}
195 
196   void do_thread(Thread* thread) {
197     if (thread-&gt;claim_threads_do(true, _claim_token)) {
198       ShenandoahThreadLocalData::satb_mark_queue(thread).apply_closure_and_empty(_satb_cl);
<a name="10" id="anc10"></a><span class="line-added">199       if (thread-&gt;is_Java_thread()) {</span>
<span class="line-added">200         if (_cl != NULL) {</span>
<span class="line-added">201           ResourceMark rm;</span>
<span class="line-added">202           thread-&gt;oops_do(_cl, _code_cl);</span>
<span class="line-added">203         } else if (_code_cl != NULL) {</span>
<span class="line-added">204           // In theory it should not be neccessary to explicitly walk the nmethods to find roots for concurrent marking</span>
<span class="line-added">205           // however the liveness of oops reachable from nmethods have very complex lifecycles:</span>
<span class="line-added">206           // * Alive if on the stack of an executing method</span>
<span class="line-added">207           // * Weakly reachable otherwise</span>
<span class="line-added">208           // Some objects reachable from nmethods, such as the class loader (or klass_holder) of the receiver should be</span>
<span class="line-added">209           // live by the SATB invariant but other oops recorded in nmethods may behave differently.</span>
<span class="line-added">210           JavaThread* jt = (JavaThread*)thread;</span>
<span class="line-added">211           jt-&gt;nmethods_do(_code_cl);</span>
<span class="line-added">212         }</span>
<span class="line-added">213       }</span>
214     }
215   }
216 };
217 
218 class ShenandoahFinalMarkingTask : public AbstractGangTask {
219 private:
220   ShenandoahConcurrentMark* _cm;
221   TaskTerminator*           _terminator;
222   bool _dedup_string;
223 
224 public:
225   ShenandoahFinalMarkingTask(ShenandoahConcurrentMark* cm, TaskTerminator* terminator, bool dedup_string) :
226     AbstractGangTask(&quot;Shenandoah Final Marking&quot;), _cm(cm), _terminator(terminator), _dedup_string(dedup_string) {
227   }
228 
229   void work(uint worker_id) {
230     ShenandoahHeap* heap = ShenandoahHeap::heap();
231 
232     ShenandoahParallelWorkerSession worker_session(worker_id);
<a name="11" id="anc11"></a><span class="line-added">233     ReferenceProcessor* rp;</span>
<span class="line-added">234     if (heap-&gt;process_references()) {</span>
<span class="line-added">235       rp = heap-&gt;ref_processor();</span>
<span class="line-added">236       shenandoah_assert_rp_isalive_installed();</span>
<span class="line-added">237     } else {</span>
<span class="line-added">238       rp = NULL;</span>
<span class="line-added">239     }</span>
<span class="line-added">240 </span>
241     // First drain remaining SATB buffers.
242     // Notice that this is not strictly necessary for mark-compact. But since
243     // it requires a StrongRootsScope around the task, we need to claim the
244     // threads, and performance-wise it doesn&#39;t really matter. Adds about 1ms to
245     // full-gc.
246     {
247       ShenandoahObjToScanQueue* q = _cm-&gt;get_queue(worker_id);
<a name="12" id="anc12"></a><span class="line-added">248 </span>
249       ShenandoahSATBBufferClosure cl(q);
250       SATBMarkQueueSet&amp; satb_mq_set = ShenandoahBarrierSet::satb_mark_queue_set();
251       while (satb_mq_set.apply_closure_to_completed_buffer(&amp;cl));
<a name="13" id="anc13"></a><span class="line-modified">252       bool do_nmethods = heap-&gt;unload_classes() &amp;&amp; !ShenandoahConcurrentRoots::can_do_concurrent_class_unloading();</span>
<span class="line-modified">253       if (heap-&gt;has_forwarded_objects()) {</span>
<span class="line-modified">254         ShenandoahMarkResolveRefsClosure resolve_mark_cl(q, rp);</span>
<span class="line-modified">255         MarkingCodeBlobClosure blobsCl(&amp;resolve_mark_cl, !CodeBlobToOopClosure::FixRelocations);</span>
<span class="line-modified">256         ShenandoahSATBAndRemarkCodeRootsThreadsClosure tc(&amp;cl,</span>
<span class="line-modified">257                                                           ShenandoahStoreValEnqueueBarrier ? &amp;resolve_mark_cl : NULL,</span>
<span class="line-modified">258                                                           do_nmethods ? &amp;blobsCl : NULL);</span>
<span class="line-modified">259         Threads::threads_do(&amp;tc);</span>
<span class="line-modified">260       } else {</span>
<span class="line-modified">261         ShenandoahMarkRefsClosure mark_cl(q, rp);</span>
<span class="line-added">262         MarkingCodeBlobClosure blobsCl(&amp;mark_cl, !CodeBlobToOopClosure::FixRelocations);</span>
<span class="line-added">263         ShenandoahSATBAndRemarkCodeRootsThreadsClosure tc(&amp;cl,</span>
<span class="line-added">264                                                           ShenandoahStoreValEnqueueBarrier ? &amp;mark_cl : NULL,</span>
<span class="line-added">265                                                           do_nmethods ? &amp;blobsCl : NULL);</span>
<span class="line-added">266         Threads::threads_do(&amp;tc);</span>
<span class="line-added">267       }</span>
268     }
269 
270     if (heap-&gt;is_degenerated_gc_in_progress()) {
271       // Degenerated cycle may bypass concurrent cycle, so code roots might not be scanned,
272       // let&#39;s check here.
273       _cm-&gt;concurrent_scan_code_roots(worker_id, rp);
274     }
275 
276     _cm-&gt;mark_loop(worker_id, _terminator, rp,
277                    false, // not cancellable
278                    _dedup_string);
279 
280     assert(_cm-&gt;task_queues()-&gt;is_empty(), &quot;Should be empty&quot;);
281   }
282 };
283 
284 void ShenandoahConcurrentMark::mark_roots(ShenandoahPhaseTimings::Phase root_phase) {
285   assert(Thread::current()-&gt;is_VM_thread(), &quot;can only do this in VMThread&quot;);
286   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
287 
288   ShenandoahHeap* heap = ShenandoahHeap::heap();
289 
290   ShenandoahGCPhase phase(root_phase);
291 
292   WorkGang* workers = heap-&gt;workers();
293   uint nworkers = workers-&gt;active_workers();
294 
295   assert(nworkers &lt;= task_queues()-&gt;size(), &quot;Just check&quot;);
296 
297   ShenandoahAllRootScanner root_proc(nworkers, root_phase);
298   TASKQUEUE_STATS_ONLY(task_queues()-&gt;reset_taskqueue_stats());
299   task_queues()-&gt;reserve(nworkers);
300 
301   if (heap-&gt;has_forwarded_objects()) {
<a name="14" id="anc14"></a><span class="line-modified">302     ShenandoahInitMarkRootsTask&lt;RESOLVE&gt; mark_roots(&amp;root_proc);</span>
303     workers-&gt;run_task(&amp;mark_roots);
304   } else {
305     // No need to update references, which means the heap is stable.
306     // Can save time not walking through forwarding pointers.
<a name="15" id="anc15"></a><span class="line-modified">307     ShenandoahInitMarkRootsTask&lt;NONE&gt; mark_roots(&amp;root_proc);</span>
308     workers-&gt;run_task(&amp;mark_roots);
309   }
310 
311   if (ShenandoahConcurrentScanCodeRoots) {
312     clear_claim_codecache();
313   }
314 }
315 
316 void ShenandoahConcurrentMark::update_roots(ShenandoahPhaseTimings::Phase root_phase) {
317   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
318   assert(root_phase == ShenandoahPhaseTimings::full_gc_roots ||
319          root_phase == ShenandoahPhaseTimings::degen_gc_update_roots,
320          &quot;Only for these phases&quot;);
321 
322   ShenandoahGCPhase phase(root_phase);
323 
324   bool check_alive = root_phase == ShenandoahPhaseTimings::degen_gc_update_roots;
325 
326 #if COMPILER2_OR_JVMCI
327   DerivedPointerTable::clear();
328 #endif
329 
330   uint nworkers = _heap-&gt;workers()-&gt;active_workers();
331 
332   ShenandoahRootUpdater root_updater(nworkers, root_phase);
333   ShenandoahUpdateRootsTask update_roots(&amp;root_updater, check_alive);
334   _heap-&gt;workers()-&gt;run_task(&amp;update_roots);
335 
336 #if COMPILER2_OR_JVMCI
337   DerivedPointerTable::update_pointers();
338 #endif
339 }
340 
341 class ShenandoahUpdateThreadRootsTask : public AbstractGangTask {
342 private:
343   ShenandoahThreadRoots           _thread_roots;
344   ShenandoahPhaseTimings::Phase   _phase;
<a name="16" id="anc16"></a><span class="line-added">345   ShenandoahGCWorkerPhase         _worker_phase;</span>
346 public:
347   ShenandoahUpdateThreadRootsTask(bool is_par, ShenandoahPhaseTimings::Phase phase) :
348     AbstractGangTask(&quot;Shenandoah Update Thread Roots&quot;),
349     _thread_roots(is_par),
<a name="17" id="anc17"></a><span class="line-modified">350     _phase(phase),</span>
<span class="line-modified">351     _worker_phase(phase) {}</span>

352 
<a name="18" id="anc18"></a>


353   void work(uint worker_id) {
354     ShenandoahUpdateRefsClosure cl;
355     _thread_roots.oops_do(&amp;cl, NULL, worker_id);
356   }
357 };
358 
359 void ShenandoahConcurrentMark::update_thread_roots(ShenandoahPhaseTimings::Phase root_phase) {
360   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
361 
362   ShenandoahGCPhase phase(root_phase);
363 
364 #if COMPILER2_OR_JVMCI
365   DerivedPointerTable::clear();
366 #endif
367 
368   WorkGang* workers = _heap-&gt;workers();
369   bool is_par = workers-&gt;active_workers() &gt; 1;
370 
371   ShenandoahUpdateThreadRootsTask task(is_par, root_phase);
372   workers-&gt;run_task(&amp;task);
373 
374 #if COMPILER2_OR_JVMCI
375   DerivedPointerTable::update_pointers();
376 #endif
377 }
378 
379 void ShenandoahConcurrentMark::initialize(uint workers) {
380   _heap = ShenandoahHeap::heap();
381 
382   uint num_queues = MAX2(workers, 1U);
383 
384   _task_queues = new ShenandoahObjToScanQueueSet((int) num_queues);
385 
386   for (uint i = 0; i &lt; num_queues; ++i) {
387     ShenandoahObjToScanQueue* task_queue = new ShenandoahObjToScanQueue();
388     task_queue-&gt;initialize();
389     _task_queues-&gt;register_queue(i, task_queue);
390   }
391 }
392 
393 void ShenandoahConcurrentMark::concurrent_scan_code_roots(uint worker_id, ReferenceProcessor* rp) {
394   if (ShenandoahConcurrentScanCodeRoots &amp;&amp; claim_codecache()) {
395     ShenandoahObjToScanQueue* q = task_queues()-&gt;queue(worker_id);
396     if (!_heap-&gt;unload_classes()) {
397       MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
398       // TODO: We can not honor StringDeduplication here, due to lock ranking
399       // inversion. So, we may miss some deduplication candidates.
400       if (_heap-&gt;has_forwarded_objects()) {
401         ShenandoahMarkResolveRefsClosure cl(q, rp);
402         CodeBlobToOopClosure blobs(&amp;cl, !CodeBlobToOopClosure::FixRelocations);
403         CodeCache::blobs_do(&amp;blobs);
404       } else {
405         ShenandoahMarkRefsClosure cl(q, rp);
406         CodeBlobToOopClosure blobs(&amp;cl, !CodeBlobToOopClosure::FixRelocations);
407         CodeCache::blobs_do(&amp;blobs);
408       }
409     }
410   }
411 }
412 
413 void ShenandoahConcurrentMark::mark_from_roots() {
414   WorkGang* workers = _heap-&gt;workers();
415   uint nworkers = workers-&gt;active_workers();
416 
417   ShenandoahGCPhase conc_mark_phase(ShenandoahPhaseTimings::conc_mark);
418 
419   if (_heap-&gt;process_references()) {
420     ReferenceProcessor* rp = _heap-&gt;ref_processor();
421     rp-&gt;set_active_mt_degree(nworkers);
422 
423     // enable (&quot;weak&quot;) refs discovery
424     rp-&gt;enable_discovery(true /*verify_no_refs*/);
425     rp-&gt;setup_policy(_heap-&gt;soft_ref_policy()-&gt;should_clear_all_soft_refs());
426   }
427 
428   shenandoah_assert_rp_isalive_not_installed();
429   ShenandoahIsAliveSelector is_alive;
430   ReferenceProcessorIsAliveMutator fix_isalive(_heap-&gt;ref_processor(), is_alive.is_alive_closure());
431 
432   task_queues()-&gt;reserve(nworkers);
433 
434   {
435     TaskTerminator terminator(nworkers, task_queues());
436     ShenandoahConcurrentMarkingTask task(this, &amp;terminator);
437     workers-&gt;run_task(&amp;task);
438   }
439 
440   assert(task_queues()-&gt;is_empty() || _heap-&gt;cancelled_gc(), &quot;Should be empty when not cancelled&quot;);
441 }
442 
443 void ShenandoahConcurrentMark::finish_mark_from_roots(bool full_gc) {
444   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
445 
446   uint nworkers = _heap-&gt;workers()-&gt;active_workers();
447 
448   // Finally mark everything else we&#39;ve got in our queues during the previous steps.
449   // It does two different things for concurrent vs. mark-compact GC:
450   // - For concurrent GC, it starts with empty task queues, drains the remaining
451   //   SATB buffers, and then completes the marking closure.
452   // - For mark-compact GC, it starts out with the task queues seeded by initial
453   //   root scan, and completes the closure, thus marking through all live objects
454   // The implementation is the same, so it&#39;s shared here.
455   {
456     ShenandoahGCPhase phase(full_gc ?
457                             ShenandoahPhaseTimings::full_gc_mark_finish_queues :
458                             ShenandoahPhaseTimings::finish_queues);
459     task_queues()-&gt;reserve(nworkers);
460 
461     shenandoah_assert_rp_isalive_not_installed();
462     ShenandoahIsAliveSelector is_alive;
463     ReferenceProcessorIsAliveMutator fix_isalive(_heap-&gt;ref_processor(), is_alive.is_alive_closure());
464 
465     StrongRootsScope scope(nworkers);
466     TaskTerminator terminator(nworkers, task_queues());
467     ShenandoahFinalMarkingTask task(this, &amp;terminator, ShenandoahStringDedup::is_enabled());
468     _heap-&gt;workers()-&gt;run_task(&amp;task);
469   }
470 
471   assert(task_queues()-&gt;is_empty(), &quot;Should be empty&quot;);
472 
473   // When we&#39;re done marking everything, we process weak references.
474   if (_heap-&gt;process_references()) {
475     weak_refs_work(full_gc);
476   }
477 
478   assert(task_queues()-&gt;is_empty(), &quot;Should be empty&quot;);
479   TASKQUEUE_STATS_ONLY(task_queues()-&gt;print_taskqueue_stats());
480   TASKQUEUE_STATS_ONLY(task_queues()-&gt;reset_taskqueue_stats());
481 }
482 
483 // Weak Reference Closures
484 class ShenandoahCMDrainMarkingStackClosure: public VoidClosure {
485   uint _worker_id;
486   TaskTerminator* _terminator;
487   bool _reset_terminator;
488 
489 public:
490   ShenandoahCMDrainMarkingStackClosure(uint worker_id, TaskTerminator* t, bool reset_terminator = false):
491     _worker_id(worker_id),
492     _terminator(t),
493     _reset_terminator(reset_terminator) {
494   }
495 
496   void do_void() {
497     assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
498 
499     ShenandoahHeap* sh = ShenandoahHeap::heap();
500     ShenandoahConcurrentMark* scm = sh-&gt;concurrent_mark();
501     assert(sh-&gt;process_references(), &quot;why else would we be here?&quot;);
502     ReferenceProcessor* rp = sh-&gt;ref_processor();
503 
504     shenandoah_assert_rp_isalive_installed();
505 
506     scm-&gt;mark_loop(_worker_id, _terminator, rp,
507                    false,   // not cancellable
508                    false);  // do not do strdedup
509 
510     if (_reset_terminator) {
511       _terminator-&gt;reset_for_reuse();
512     }
513   }
514 };
515 
516 class ShenandoahCMKeepAliveClosure : public OopClosure {
517 private:
518   ShenandoahObjToScanQueue* _queue;
519   ShenandoahHeap* _heap;
520   ShenandoahMarkingContext* const _mark_context;
521 
522   template &lt;class T&gt;
523   inline void do_oop_work(T* p) {
524     ShenandoahConcurrentMark::mark_through_ref&lt;T, NONE, NO_DEDUP&gt;(p, _heap, _queue, _mark_context);
525   }
526 
527 public:
528   ShenandoahCMKeepAliveClosure(ShenandoahObjToScanQueue* q) :
529     _queue(q),
530     _heap(ShenandoahHeap::heap()),
531     _mark_context(_heap-&gt;marking_context()) {}
532 
533   void do_oop(narrowOop* p) { do_oop_work(p); }
534   void do_oop(oop* p)       { do_oop_work(p); }
535 };
536 
537 class ShenandoahCMKeepAliveUpdateClosure : public OopClosure {
538 private:
539   ShenandoahObjToScanQueue* _queue;
540   ShenandoahHeap* _heap;
541   ShenandoahMarkingContext* const _mark_context;
542 
543   template &lt;class T&gt;
544   inline void do_oop_work(T* p) {
545     ShenandoahConcurrentMark::mark_through_ref&lt;T, SIMPLE, NO_DEDUP&gt;(p, _heap, _queue, _mark_context);
546   }
547 
548 public:
549   ShenandoahCMKeepAliveUpdateClosure(ShenandoahObjToScanQueue* q) :
550     _queue(q),
551     _heap(ShenandoahHeap::heap()),
552     _mark_context(_heap-&gt;marking_context()) {}
553 
554   void do_oop(narrowOop* p) { do_oop_work(p); }
555   void do_oop(oop* p)       { do_oop_work(p); }
556 };
557 
558 class ShenandoahWeakUpdateClosure : public OopClosure {
559 private:
560   ShenandoahHeap* const _heap;
561 
562   template &lt;class T&gt;
563   inline void do_oop_work(T* p) {
564     oop o = _heap-&gt;maybe_update_with_forwarded(p);
565     shenandoah_assert_marked_except(p, o, o == NULL);
566   }
567 
568 public:
569   ShenandoahWeakUpdateClosure() : _heap(ShenandoahHeap::heap()) {}
570 
571   void do_oop(narrowOop* p) { do_oop_work(p); }
572   void do_oop(oop* p)       { do_oop_work(p); }
573 };
574 
575 class ShenandoahRefProcTaskProxy : public AbstractGangTask {
576 private:
577   AbstractRefProcTaskExecutor::ProcessTask&amp; _proc_task;
578   TaskTerminator* _terminator;
579 
580 public:
581   ShenandoahRefProcTaskProxy(AbstractRefProcTaskExecutor::ProcessTask&amp; proc_task,
582                              TaskTerminator* t) :
583     AbstractGangTask(&quot;Process reference objects in parallel&quot;),
584     _proc_task(proc_task),
585     _terminator(t) {
586   }
587 
588   void work(uint worker_id) {
589     ResourceMark rm;
590     HandleMark hm;
591     assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
592     ShenandoahHeap* heap = ShenandoahHeap::heap();
593     ShenandoahCMDrainMarkingStackClosure complete_gc(worker_id, _terminator);
594     if (heap-&gt;has_forwarded_objects()) {
595       ShenandoahForwardedIsAliveClosure is_alive;
596       ShenandoahCMKeepAliveUpdateClosure keep_alive(heap-&gt;concurrent_mark()-&gt;get_queue(worker_id));
597       _proc_task.work(worker_id, is_alive, keep_alive, complete_gc);
598     } else {
599       ShenandoahIsAliveClosure is_alive;
600       ShenandoahCMKeepAliveClosure keep_alive(heap-&gt;concurrent_mark()-&gt;get_queue(worker_id));
601       _proc_task.work(worker_id, is_alive, keep_alive, complete_gc);
602     }
603   }
604 };
605 
606 class ShenandoahRefProcTaskExecutor : public AbstractRefProcTaskExecutor {
607 private:
608   WorkGang* _workers;
609 
610 public:
611   ShenandoahRefProcTaskExecutor(WorkGang* workers) :
612     _workers(workers) {
613   }
614 
615   // Executes a task using worker threads.
616   void execute(ProcessTask&amp; task, uint ergo_workers) {
617     assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
618 
619     ShenandoahHeap* heap = ShenandoahHeap::heap();
620     ShenandoahConcurrentMark* cm = heap-&gt;concurrent_mark();
621     ShenandoahPushWorkerQueuesScope scope(_workers, cm-&gt;task_queues(),
622                                           ergo_workers,
623                                           /* do_check = */ false);
624     uint nworkers = _workers-&gt;active_workers();
625     cm-&gt;task_queues()-&gt;reserve(nworkers);
626     TaskTerminator terminator(nworkers, cm-&gt;task_queues());
627     ShenandoahRefProcTaskProxy proc_task_proxy(task, &amp;terminator);
628     _workers-&gt;run_task(&amp;proc_task_proxy);
629   }
630 };
631 
632 void ShenandoahConcurrentMark::weak_refs_work(bool full_gc) {
633   assert(_heap-&gt;process_references(), &quot;sanity&quot;);
634 
635   ShenandoahPhaseTimings::Phase phase_root =
636           full_gc ?
637           ShenandoahPhaseTimings::full_gc_weakrefs :
638           ShenandoahPhaseTimings::weakrefs;
639 
640   ShenandoahGCPhase phase(phase_root);
641 
642   ReferenceProcessor* rp = _heap-&gt;ref_processor();
643 
644   // NOTE: We cannot shortcut on has_discovered_references() here, because
645   // we will miss marking JNI Weak refs then, see implementation in
646   // ReferenceProcessor::process_discovered_references.
647   weak_refs_work_doit(full_gc);
648 
649   rp-&gt;verify_no_references_recorded();
650   assert(!rp-&gt;discovery_enabled(), &quot;Post condition&quot;);
651 
652 }
653 
654 void ShenandoahConcurrentMark::weak_refs_work_doit(bool full_gc) {
655   ReferenceProcessor* rp = _heap-&gt;ref_processor();
656 
657   ShenandoahPhaseTimings::Phase phase_process =
658           full_gc ?
659           ShenandoahPhaseTimings::full_gc_weakrefs_process :
660           ShenandoahPhaseTimings::weakrefs_process;
661 
662   shenandoah_assert_rp_isalive_not_installed();
663   ShenandoahIsAliveSelector is_alive;
664   ReferenceProcessorIsAliveMutator fix_isalive(rp, is_alive.is_alive_closure());
665 
666   WorkGang* workers = _heap-&gt;workers();
667   uint nworkers = workers-&gt;active_workers();
668 
669   rp-&gt;setup_policy(_heap-&gt;soft_ref_policy()-&gt;should_clear_all_soft_refs());
670   rp-&gt;set_active_mt_degree(nworkers);
671 
672   assert(task_queues()-&gt;is_empty(), &quot;Should be empty&quot;);
673 
674   // complete_gc and keep_alive closures instantiated here are only needed for
675   // single-threaded path in RP. They share the queue 0 for tracking work, which
676   // simplifies implementation. Since RP may decide to call complete_gc several
677   // times, we need to be able to reuse the terminator.
678   uint serial_worker_id = 0;
679   TaskTerminator terminator(1, task_queues());
680   ShenandoahCMDrainMarkingStackClosure complete_gc(serial_worker_id, &amp;terminator, /* reset_terminator = */ true);
681 
682   ShenandoahRefProcTaskExecutor executor(workers);
683 
684   ReferenceProcessorPhaseTimes pt(_heap-&gt;gc_timer(), rp-&gt;num_queues());
685 
686   {
687     ShenandoahGCPhase phase(phase_process);
688 
689     if (_heap-&gt;has_forwarded_objects()) {
690       ShenandoahCMKeepAliveUpdateClosure keep_alive(get_queue(serial_worker_id));
<a name="19" id="anc19"></a><span class="line-modified">691       const ReferenceProcessorStats&amp; stats =</span>
<span class="line-modified">692         rp-&gt;process_discovered_references(is_alive.is_alive_closure(), &amp;keep_alive,</span>
<span class="line-modified">693                                           &amp;complete_gc, &amp;executor,</span>
<span class="line-modified">694                                           &amp;pt);</span>
<span class="line-added">695        _heap-&gt;tracer()-&gt;report_gc_reference_stats(stats);</span>
696     } else {
697       ShenandoahCMKeepAliveClosure keep_alive(get_queue(serial_worker_id));
<a name="20" id="anc20"></a><span class="line-modified">698       const ReferenceProcessorStats&amp; stats =</span>
<span class="line-modified">699         rp-&gt;process_discovered_references(is_alive.is_alive_closure(), &amp;keep_alive,</span>
<span class="line-modified">700                                           &amp;complete_gc, &amp;executor,</span>
<span class="line-modified">701                                           &amp;pt);</span>
<span class="line-added">702       _heap-&gt;tracer()-&gt;report_gc_reference_stats(stats);</span>
703     }
704 
705     pt.print_all_references();
706 
707     assert(task_queues()-&gt;is_empty(), &quot;Should be empty&quot;);
708   }
709 }
710 
711 class ShenandoahCancelledGCYieldClosure : public YieldClosure {
712 private:
713   ShenandoahHeap* const _heap;
714 public:
715   ShenandoahCancelledGCYieldClosure() : _heap(ShenandoahHeap::heap()) {};
716   virtual bool should_return() { return _heap-&gt;cancelled_gc(); }
717 };
718 
719 class ShenandoahPrecleanCompleteGCClosure : public VoidClosure {
720 public:
721   void do_void() {
722     ShenandoahHeap* sh = ShenandoahHeap::heap();
723     ShenandoahConcurrentMark* scm = sh-&gt;concurrent_mark();
724     assert(sh-&gt;process_references(), &quot;why else would we be here?&quot;);
725     TaskTerminator terminator(1, scm-&gt;task_queues());
726 
727     ReferenceProcessor* rp = sh-&gt;ref_processor();
728     shenandoah_assert_rp_isalive_installed();
729 
730     scm-&gt;mark_loop(0, &amp;terminator, rp,
731                    false, // not cancellable
732                    false); // do not do strdedup
733   }
734 };
735 
<a name="21" id="anc21"></a>




















736 class ShenandoahPrecleanTask : public AbstractGangTask {
737 private:
738   ReferenceProcessor* _rp;
739 
740 public:
741   ShenandoahPrecleanTask(ReferenceProcessor* rp) :
742           AbstractGangTask(&quot;Precleaning task&quot;),
743           _rp(rp) {}
744 
745   void work(uint worker_id) {
746     assert(worker_id == 0, &quot;The code below is single-threaded, only one worker is expected&quot;);
747     ShenandoahParallelWorkerSession worker_session(worker_id);
748 
749     ShenandoahHeap* sh = ShenandoahHeap::heap();
<a name="22" id="anc22"></a><span class="line-added">750     assert(!sh-&gt;has_forwarded_objects(), &quot;No forwarded objects expected here&quot;);</span>
751 
752     ShenandoahObjToScanQueue* q = sh-&gt;concurrent_mark()-&gt;get_queue(worker_id);
753 
754     ShenandoahCancelledGCYieldClosure yield;
755     ShenandoahPrecleanCompleteGCClosure complete_gc;
756 
<a name="23" id="anc23"></a><span class="line-modified">757     ShenandoahIsAliveClosure is_alive;</span>
<span class="line-modified">758     ShenandoahCMKeepAliveClosure keep_alive(q);</span>
<span class="line-modified">759     ResourceMark rm;</span>
<span class="line-modified">760     _rp-&gt;preclean_discovered_references(&amp;is_alive, &amp;keep_alive,</span>
<span class="line-modified">761                                         &amp;complete_gc, &amp;yield,</span>
<span class="line-modified">762                                         NULL);</span>









763   }
764 };
765 
766 void ShenandoahConcurrentMark::preclean_weak_refs() {
767   // Pre-cleaning weak references before diving into STW makes sense at the
768   // end of concurrent mark. This will filter out the references which referents
769   // are alive. Note that ReferenceProcessor already filters out these on reference
770   // discovery, and the bulk of work is done here. This phase processes leftovers
771   // that missed the initial filtering, i.e. when referent was marked alive after
772   // reference was discovered by RP.
773 
774   assert(_heap-&gt;process_references(), &quot;sanity&quot;);
775 
776   // Shortcut if no references were discovered to avoid winding up threads.
777   ReferenceProcessor* rp = _heap-&gt;ref_processor();
778   if (!rp-&gt;has_discovered_references()) {
779     return;
780   }
781 
782   assert(task_queues()-&gt;is_empty(), &quot;Should be empty&quot;);
783 
784   ReferenceProcessorMTDiscoveryMutator fix_mt_discovery(rp, false);
785 
786   shenandoah_assert_rp_isalive_not_installed();
787   ShenandoahIsAliveSelector is_alive;
788   ReferenceProcessorIsAliveMutator fix_isalive(rp, is_alive.is_alive_closure());
789 
790   // Execute precleaning in the worker thread: it will give us GCLABs, String dedup
791   // queues and other goodies. When upstream ReferenceProcessor starts supporting
792   // parallel precleans, we can extend this to more threads.
793   WorkGang* workers = _heap-&gt;workers();
794   uint nworkers = workers-&gt;active_workers();
795   assert(nworkers == 1, &quot;This code uses only a single worker&quot;);
796   task_queues()-&gt;reserve(nworkers);
797 
798   ShenandoahPrecleanTask task(rp);
799   workers-&gt;run_task(&amp;task);
800 
801   assert(task_queues()-&gt;is_empty(), &quot;Should be empty&quot;);
802 }
803 
804 void ShenandoahConcurrentMark::cancel() {
805   // Clean up marking stacks.
806   ShenandoahObjToScanQueueSet* queues = task_queues();
807   queues-&gt;clear();
808 
809   // Cancel SATB buffers.
810   ShenandoahBarrierSet::satb_mark_queue_set().abandon_partial_marking();
811 }
812 
813 ShenandoahObjToScanQueue* ShenandoahConcurrentMark::get_queue(uint worker_id) {
814   assert(task_queues()-&gt;get_reserved() &gt; worker_id, &quot;No reserved queue for worker id: %d&quot;, worker_id);
815   return _task_queues-&gt;queue(worker_id);
816 }
817 
818 template &lt;bool CANCELLABLE&gt;
819 void ShenandoahConcurrentMark::mark_loop_prework(uint w, TaskTerminator *t, ReferenceProcessor *rp,
820                                                  bool strdedup) {
821   ShenandoahObjToScanQueue* q = get_queue(w);
822 
<a name="24" id="anc24"></a><span class="line-modified">823   ShenandoahLiveData* ld = _heap-&gt;get_liveness_cache(w);</span>
824 
825   // TODO: We can clean up this if we figure out how to do templated oop closures that
826   // play nice with specialized_oop_iterators.
827   if (_heap-&gt;unload_classes()) {
828     if (_heap-&gt;has_forwarded_objects()) {
829       if (strdedup) {
830         ShenandoahMarkUpdateRefsMetadataDedupClosure cl(q, rp);
831         mark_loop_work&lt;ShenandoahMarkUpdateRefsMetadataDedupClosure, CANCELLABLE&gt;(&amp;cl, ld, w, t);
832       } else {
833         ShenandoahMarkUpdateRefsMetadataClosure cl(q, rp);
834         mark_loop_work&lt;ShenandoahMarkUpdateRefsMetadataClosure, CANCELLABLE&gt;(&amp;cl, ld, w, t);
835       }
836     } else {
837       if (strdedup) {
838         ShenandoahMarkRefsMetadataDedupClosure cl(q, rp);
839         mark_loop_work&lt;ShenandoahMarkRefsMetadataDedupClosure, CANCELLABLE&gt;(&amp;cl, ld, w, t);
840       } else {
841         ShenandoahMarkRefsMetadataClosure cl(q, rp);
842         mark_loop_work&lt;ShenandoahMarkRefsMetadataClosure, CANCELLABLE&gt;(&amp;cl, ld, w, t);
843       }
844     }
845   } else {
846     if (_heap-&gt;has_forwarded_objects()) {
847       if (strdedup) {
848         ShenandoahMarkUpdateRefsDedupClosure cl(q, rp);
849         mark_loop_work&lt;ShenandoahMarkUpdateRefsDedupClosure, CANCELLABLE&gt;(&amp;cl, ld, w, t);
850       } else {
851         ShenandoahMarkUpdateRefsClosure cl(q, rp);
852         mark_loop_work&lt;ShenandoahMarkUpdateRefsClosure, CANCELLABLE&gt;(&amp;cl, ld, w, t);
853       }
854     } else {
855       if (strdedup) {
856         ShenandoahMarkRefsDedupClosure cl(q, rp);
857         mark_loop_work&lt;ShenandoahMarkRefsDedupClosure, CANCELLABLE&gt;(&amp;cl, ld, w, t);
858       } else {
859         ShenandoahMarkRefsClosure cl(q, rp);
860         mark_loop_work&lt;ShenandoahMarkRefsClosure, CANCELLABLE&gt;(&amp;cl, ld, w, t);
861       }
862     }
863   }
864 
865   _heap-&gt;flush_liveness_cache(w);
866 }
867 
868 template &lt;class T, bool CANCELLABLE&gt;
<a name="25" id="anc25"></a><span class="line-modified">869 void ShenandoahConcurrentMark::mark_loop_work(T* cl, ShenandoahLiveData* live_data, uint worker_id, TaskTerminator *terminator) {</span>
870   uintx stride = ShenandoahMarkLoopStride;
871 
872   ShenandoahHeap* heap = ShenandoahHeap::heap();
873   ShenandoahObjToScanQueueSet* queues = task_queues();
874   ShenandoahObjToScanQueue* q;
875   ShenandoahMarkTask t;
876 
877   /*
878    * Process outstanding queues, if any.
879    *
880    * There can be more queues than workers. To deal with the imbalance, we claim
881    * extra queues first. Since marking can push new tasks into the queue associated
882    * with this worker id, we come back to process this queue in the normal loop.
883    */
884   assert(queues-&gt;get_reserved() == heap-&gt;workers()-&gt;active_workers(),
885          &quot;Need to reserve proper number of queues: reserved: %u, active: %u&quot;, queues-&gt;get_reserved(), heap-&gt;workers()-&gt;active_workers());
886 
887   q = queues-&gt;claim_next();
888   while (q != NULL) {
889     if (CANCELLABLE &amp;&amp; heap-&gt;check_cancelled_gc_and_yield()) {
890       return;
891     }
892 
893     for (uint i = 0; i &lt; stride; i++) {
894       if (q-&gt;pop(t)) {
895         do_task&lt;T&gt;(q, cl, live_data, &amp;t);
896       } else {
897         assert(q-&gt;is_empty(), &quot;Must be empty&quot;);
898         q = queues-&gt;claim_next();
899         break;
900       }
901     }
902   }
903   q = get_queue(worker_id);
904 
905   ShenandoahSATBBufferClosure drain_satb(q);
906   SATBMarkQueueSet&amp; satb_mq_set = ShenandoahBarrierSet::satb_mark_queue_set();
907 
908   /*
909    * Normal marking loop:
910    */
911   while (true) {
912     if (CANCELLABLE &amp;&amp; heap-&gt;check_cancelled_gc_and_yield()) {
913       return;
914     }
915 
916     while (satb_mq_set.completed_buffers_num() &gt; 0) {
917       satb_mq_set.apply_closure_to_completed_buffer(&amp;drain_satb);
918     }
919 
920     uint work = 0;
921     for (uint i = 0; i &lt; stride; i++) {
922       if (q-&gt;pop(t) ||
923           queues-&gt;steal(worker_id, t)) {
924         do_task&lt;T&gt;(q, cl, live_data, &amp;t);
925         work++;
926       } else {
927         break;
928       }
929     }
930 
931     if (work == 0) {
932       // No work encountered in current stride, try to terminate.
933       // Need to leave the STS here otherwise it might block safepoints.
934       ShenandoahSuspendibleThreadSetLeaver stsl(CANCELLABLE &amp;&amp; ShenandoahSuspendibleWorkers);
935       ShenandoahTerminatorTerminator tt(heap);
936       if (terminator-&gt;offer_termination(&amp;tt)) return;
937     }
938   }
939 }
940 
941 bool ShenandoahConcurrentMark::claim_codecache() {
942   assert(ShenandoahConcurrentScanCodeRoots, &quot;must not be called otherwise&quot;);
943   return _claimed_codecache.try_set();
944 }
945 
946 void ShenandoahConcurrentMark::clear_claim_codecache() {
947   assert(ShenandoahConcurrentScanCodeRoots, &quot;must not be called otherwise&quot;);
948   _claimed_codecache.unset();
949 }
<a name="26" id="anc26"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="26" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/shenandoahHeapRegion.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahHeap.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahHeapRegion.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahHeapRegion.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;memory/allocation.hpp&quot;
 27 #include &quot;gc/shenandoah/shenandoahHeapRegionSet.inline.hpp&quot;
 28 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
 29 #include &quot;gc/shenandoah/shenandoahHeapRegion.hpp&quot;
 30 #include &quot;gc/shenandoah/shenandoahMarkingContext.inline.hpp&quot;
<span class="line-removed"> 31 #include &quot;gc/shenandoah/shenandoahTraversalGC.hpp&quot;</span>
 32 #include &quot;gc/shared/space.inline.hpp&quot;
 33 #include &quot;jfr/jfrEvents.hpp&quot;
 34 #include &quot;memory/iterator.inline.hpp&quot;
 35 #include &quot;memory/resourceArea.hpp&quot;
 36 #include &quot;memory/universe.hpp&quot;
 37 #include &quot;oops/oop.inline.hpp&quot;
 38 #include &quot;runtime/atomic.hpp&quot;
 39 #include &quot;runtime/java.hpp&quot;
 40 #include &quot;runtime/mutexLocker.hpp&quot;
 41 #include &quot;runtime/os.hpp&quot;
 42 #include &quot;runtime/safepoint.hpp&quot;
 43 
 44 size_t ShenandoahHeapRegion::RegionCount = 0;
 45 size_t ShenandoahHeapRegion::RegionSizeBytes = 0;
 46 size_t ShenandoahHeapRegion::RegionSizeWords = 0;
 47 size_t ShenandoahHeapRegion::RegionSizeBytesShift = 0;
 48 size_t ShenandoahHeapRegion::RegionSizeWordsShift = 0;
 49 size_t ShenandoahHeapRegion::RegionSizeBytesMask = 0;
 50 size_t ShenandoahHeapRegion::RegionSizeWordsMask = 0;
 51 size_t ShenandoahHeapRegion::HumongousThresholdBytes = 0;
 52 size_t ShenandoahHeapRegion::HumongousThresholdWords = 0;
 53 size_t ShenandoahHeapRegion::MaxTLABSizeBytes = 0;
 54 size_t ShenandoahHeapRegion::MaxTLABSizeWords = 0;
 55 
<span class="line-modified"> 56 ShenandoahHeapRegion::PaddedAllocSeqNum ShenandoahHeapRegion::_alloc_seq_num;</span>
<span class="line-modified"> 57 </span>
<span class="line-modified"> 58 ShenandoahHeapRegion::ShenandoahHeapRegion(ShenandoahHeap* heap, HeapWord* start,</span>
<span class="line-modified"> 59                                            size_t size_words, size_t index, bool committed) :</span>
<span class="line-removed"> 60   _heap(heap),</span>
<span class="line-removed"> 61   _reserved(MemRegion(start, size_words)),</span>
<span class="line-removed"> 62   _region_number(index),</span>
 63   _new_top(NULL),
 64   _empty_time(os::elapsedTime()),
 65   _state(committed ? _empty_committed : _empty_uncommitted),

 66   _tlab_allocs(0),
 67   _gclab_allocs(0),
<span class="line-removed"> 68   _shared_allocs(0),</span>
<span class="line-removed"> 69   _seqnum_first_alloc_mutator(0),</span>
<span class="line-removed"> 70   _seqnum_first_alloc_gc(0),</span>
<span class="line-removed"> 71   _seqnum_last_alloc_mutator(0),</span>
<span class="line-removed"> 72   _seqnum_last_alloc_gc(0),</span>
 73   _live_data(0),
<span class="line-modified"> 74   _critical_pins(0) {</span>
<span class="line-modified"> 75 </span>
<span class="line-removed"> 76   ContiguousSpace::initialize(_reserved, true, committed);</span>
<span class="line-removed"> 77 }</span>
 78 
<span class="line-modified"> 79 size_t ShenandoahHeapRegion::region_number() const {</span>
<span class="line-modified"> 80   return _region_number;</span>



 81 }
 82 
 83 void ShenandoahHeapRegion::report_illegal_transition(const char *method) {
 84   ResourceMark rm;
 85   stringStream ss;
 86   ss.print(&quot;Illegal region state transition from \&quot;%s\&quot;, at %s\n  &quot;, region_state_to_string(_state), method);
 87   print_on(&amp;ss);
 88   fatal(&quot;%s&quot;, ss.as_string());
 89 }
 90 
 91 void ShenandoahHeapRegion::make_regular_allocation() {
<span class="line-modified"> 92   _heap-&gt;assert_heaplock_owned_by_current_thread();</span>
 93 
 94   switch (_state) {
 95     case _empty_uncommitted:
 96       do_commit();
 97     case _empty_committed:
 98       set_state(_regular);
 99     case _regular:
100     case _pinned:
101       return;
102     default:
103       report_illegal_transition(&quot;regular allocation&quot;);
104   }
105 }
106 
107 void ShenandoahHeapRegion::make_regular_bypass() {
<span class="line-modified">108   _heap-&gt;assert_heaplock_owned_by_current_thread();</span>
<span class="line-modified">109   assert (_heap-&gt;is_full_gc_in_progress() || _heap-&gt;is_degenerated_gc_in_progress(),</span>
110           &quot;only for full or degen GC&quot;);
111 
112   switch (_state) {
113     case _empty_uncommitted:
114       do_commit();
115     case _empty_committed:
116     case _cset:
117     case _humongous_start:
118     case _humongous_cont:
119       set_state(_regular);
120       return;
121     case _pinned_cset:
122       set_state(_pinned);
123       return;
124     case _regular:
125     case _pinned:
126       return;
127     default:
128       report_illegal_transition(&quot;regular bypass&quot;);
129   }
130 }
131 
132 void ShenandoahHeapRegion::make_humongous_start() {
<span class="line-modified">133   _heap-&gt;assert_heaplock_owned_by_current_thread();</span>
134   switch (_state) {
135     case _empty_uncommitted:
136       do_commit();
137     case _empty_committed:
138       set_state(_humongous_start);
139       return;
140     default:
141       report_illegal_transition(&quot;humongous start allocation&quot;);
142   }
143 }
144 
145 void ShenandoahHeapRegion::make_humongous_start_bypass() {
<span class="line-modified">146   _heap-&gt;assert_heaplock_owned_by_current_thread();</span>
<span class="line-modified">147   assert (_heap-&gt;is_full_gc_in_progress(), &quot;only for full GC&quot;);</span>
148 
149   switch (_state) {
150     case _empty_committed:
151     case _regular:
152     case _humongous_start:
153     case _humongous_cont:
154       set_state(_humongous_start);
155       return;
156     default:
157       report_illegal_transition(&quot;humongous start bypass&quot;);
158   }
159 }
160 
161 void ShenandoahHeapRegion::make_humongous_cont() {
<span class="line-modified">162   _heap-&gt;assert_heaplock_owned_by_current_thread();</span>
163   switch (_state) {
164     case _empty_uncommitted:
165       do_commit();
166     case _empty_committed:
167      set_state(_humongous_cont);
168       return;
169     default:
170       report_illegal_transition(&quot;humongous continuation allocation&quot;);
171   }
172 }
173 
174 void ShenandoahHeapRegion::make_humongous_cont_bypass() {
<span class="line-modified">175   _heap-&gt;assert_heaplock_owned_by_current_thread();</span>
<span class="line-modified">176   assert (_heap-&gt;is_full_gc_in_progress(), &quot;only for full GC&quot;);</span>
177 
178   switch (_state) {
179     case _empty_committed:
180     case _regular:
181     case _humongous_start:
182     case _humongous_cont:
183       set_state(_humongous_cont);
184       return;
185     default:
186       report_illegal_transition(&quot;humongous continuation bypass&quot;);
187   }
188 }
189 
190 void ShenandoahHeapRegion::make_pinned() {
<span class="line-modified">191   _heap-&gt;assert_heaplock_owned_by_current_thread();</span>
192   assert(pin_count() &gt; 0, &quot;Should have pins: &quot; SIZE_FORMAT, pin_count());
193 
194   switch (_state) {
195     case _regular:
196       set_state(_pinned);
197     case _pinned_cset:
198     case _pinned:
199       return;
200     case _humongous_start:
201       set_state(_pinned_humongous_start);
202     case _pinned_humongous_start:
203       return;
204     case _cset:
205       _state = _pinned_cset;
206       return;
207     default:
208       report_illegal_transition(&quot;pinning&quot;);
209   }
210 }
211 
212 void ShenandoahHeapRegion::make_unpinned() {
<span class="line-modified">213   _heap-&gt;assert_heaplock_owned_by_current_thread();</span>
214   assert(pin_count() == 0, &quot;Should not have pins: &quot; SIZE_FORMAT, pin_count());
215 
216   switch (_state) {
217     case _pinned:
218       set_state(_regular);
219       return;
220     case _regular:
221     case _humongous_start:
222       return;
223     case _pinned_cset:
224       set_state(_cset);
225       return;
226     case _pinned_humongous_start:
227       set_state(_humongous_start);
228       return;
229     default:
230       report_illegal_transition(&quot;unpinning&quot;);
231   }
232 }
233 
234 void ShenandoahHeapRegion::make_cset() {
<span class="line-modified">235   _heap-&gt;assert_heaplock_owned_by_current_thread();</span>
236   switch (_state) {
237     case _regular:
238       set_state(_cset);
239     case _cset:
240       return;
241     default:
242       report_illegal_transition(&quot;cset&quot;);
243   }
244 }
245 
246 void ShenandoahHeapRegion::make_trash() {
<span class="line-modified">247   _heap-&gt;assert_heaplock_owned_by_current_thread();</span>
248   switch (_state) {
249     case _cset:
250       // Reclaiming cset regions
251     case _humongous_start:
252     case _humongous_cont:
253       // Reclaiming humongous regions
254     case _regular:
255       // Immediate region reclaim
256       set_state(_trash);
257       return;
258     default:
259       report_illegal_transition(&quot;trashing&quot;);
260   }
261 }
262 
263 void ShenandoahHeapRegion::make_trash_immediate() {
264   make_trash();
265 
266   // On this path, we know there are no marked objects in the region,
267   // tell marking context about it to bypass bitmap resets.
<span class="line-modified">268   _heap-&gt;complete_marking_context()-&gt;reset_top_bitmap(this);</span>
269 }
270 
271 void ShenandoahHeapRegion::make_empty() {
<span class="line-modified">272   _heap-&gt;assert_heaplock_owned_by_current_thread();</span>
273   switch (_state) {
274     case _trash:
275       set_state(_empty_committed);
276       _empty_time = os::elapsedTime();
277       return;
278     default:
279       report_illegal_transition(&quot;emptying&quot;);
280   }
281 }
282 
283 void ShenandoahHeapRegion::make_uncommitted() {
<span class="line-modified">284   _heap-&gt;assert_heaplock_owned_by_current_thread();</span>
285   switch (_state) {
286     case _empty_committed:
287       do_uncommit();
288       set_state(_empty_uncommitted);
289       return;
290     default:
291       report_illegal_transition(&quot;uncommiting&quot;);
292   }
293 }
294 
295 void ShenandoahHeapRegion::make_committed_bypass() {
<span class="line-modified">296   _heap-&gt;assert_heaplock_owned_by_current_thread();</span>
<span class="line-modified">297   assert (_heap-&gt;is_full_gc_in_progress(), &quot;only for full GC&quot;);</span>
298 
299   switch (_state) {
300     case _empty_uncommitted:
301       do_commit();
302       set_state(_empty_committed);
303       return;
304     default:
305       report_illegal_transition(&quot;commit bypass&quot;);
306   }
307 }
308 
<span class="line-removed">309 void ShenandoahHeapRegion::clear_live_data() {</span>
<span class="line-removed">310   Atomic::release_store_fence(&amp;_live_data, (size_t)0);</span>
<span class="line-removed">311 }</span>
<span class="line-removed">312 </span>
313 void ShenandoahHeapRegion::reset_alloc_metadata() {
314   _tlab_allocs = 0;
315   _gclab_allocs = 0;
<span class="line-removed">316   _shared_allocs = 0;</span>
<span class="line-removed">317   _seqnum_first_alloc_mutator = 0;</span>
<span class="line-removed">318   _seqnum_last_alloc_mutator = 0;</span>
<span class="line-removed">319   _seqnum_first_alloc_gc = 0;</span>
<span class="line-removed">320   _seqnum_last_alloc_gc = 0;</span>
<span class="line-removed">321 }</span>
<span class="line-removed">322 </span>
<span class="line-removed">323 void ShenandoahHeapRegion::reset_alloc_metadata_to_shared() {</span>
<span class="line-removed">324   if (used() &gt; 0) {</span>
<span class="line-removed">325     _tlab_allocs = 0;</span>
<span class="line-removed">326     _gclab_allocs = 0;</span>
<span class="line-removed">327     _shared_allocs = used() &gt;&gt; LogHeapWordSize;</span>
<span class="line-removed">328     uint64_t next = _alloc_seq_num.value++;</span>
<span class="line-removed">329     _seqnum_first_alloc_mutator = next;</span>
<span class="line-removed">330     _seqnum_last_alloc_mutator = next;</span>
<span class="line-removed">331     _seqnum_first_alloc_gc = 0;</span>
<span class="line-removed">332     _seqnum_last_alloc_gc = 0;</span>
<span class="line-removed">333   } else {</span>
<span class="line-removed">334     reset_alloc_metadata();</span>
<span class="line-removed">335   }</span>
336 }
337 
338 size_t ShenandoahHeapRegion::get_shared_allocs() const {
<span class="line-modified">339   return _shared_allocs * HeapWordSize;</span>
340 }
341 
342 size_t ShenandoahHeapRegion::get_tlab_allocs() const {
343   return _tlab_allocs * HeapWordSize;
344 }
345 
346 size_t ShenandoahHeapRegion::get_gclab_allocs() const {
347   return _gclab_allocs * HeapWordSize;
348 }
349 
350 void ShenandoahHeapRegion::set_live_data(size_t s) {
351   assert(Thread::current()-&gt;is_VM_thread(), &quot;by VM thread&quot;);
352   _live_data = (s &gt;&gt; LogHeapWordSize);
353 }
354 
<span class="line-removed">355 size_t ShenandoahHeapRegion::get_live_data_words() const {</span>
<span class="line-removed">356   return Atomic::load_acquire(&amp;_live_data);</span>
<span class="line-removed">357 }</span>
<span class="line-removed">358 </span>
<span class="line-removed">359 size_t ShenandoahHeapRegion::get_live_data_bytes() const {</span>
<span class="line-removed">360   return get_live_data_words() * HeapWordSize;</span>
<span class="line-removed">361 }</span>
<span class="line-removed">362 </span>
<span class="line-removed">363 bool ShenandoahHeapRegion::has_live() const {</span>
<span class="line-removed">364   return get_live_data_words() != 0;</span>
<span class="line-removed">365 }</span>
<span class="line-removed">366 </span>
<span class="line-removed">367 size_t ShenandoahHeapRegion::garbage() const {</span>
<span class="line-removed">368   assert(used() &gt;= get_live_data_bytes(), &quot;Live Data must be a subset of used() live: &quot; SIZE_FORMAT &quot; used: &quot; SIZE_FORMAT,</span>
<span class="line-removed">369          get_live_data_bytes(), used());</span>
<span class="line-removed">370 </span>
<span class="line-removed">371   size_t result = used() - get_live_data_bytes();</span>
<span class="line-removed">372   return result;</span>
<span class="line-removed">373 }</span>
<span class="line-removed">374 </span>
375 void ShenandoahHeapRegion::print_on(outputStream* st) const {
376   st-&gt;print(&quot;|&quot;);
<span class="line-modified">377   st-&gt;print(SIZE_FORMAT_W(5), this-&gt;_region_number);</span>
378 
379   switch (_state) {
380     case _empty_uncommitted:
381       st-&gt;print(&quot;|EU &quot;);
382       break;
383     case _empty_committed:
384       st-&gt;print(&quot;|EC &quot;);
385       break;
386     case _regular:
387       st-&gt;print(&quot;|R  &quot;);
388       break;
389     case _humongous_start:
390       st-&gt;print(&quot;|H  &quot;);
391       break;
392     case _pinned_humongous_start:
393       st-&gt;print(&quot;|HP &quot;);
394       break;
395     case _humongous_cont:
396       st-&gt;print(&quot;|HC &quot;);
397       break;
398     case _cset:
399       st-&gt;print(&quot;|CS &quot;);
400       break;
401     case _trash:
402       st-&gt;print(&quot;|T  &quot;);
403       break;
404     case _pinned:
405       st-&gt;print(&quot;|P  &quot;);
406       break;
407     case _pinned_cset:
408       st-&gt;print(&quot;|CSP&quot;);
409       break;
410     default:
411       ShouldNotReachHere();
412   }
413   st-&gt;print(&quot;|BTE &quot; INTPTR_FORMAT_W(12) &quot;, &quot; INTPTR_FORMAT_W(12) &quot;, &quot; INTPTR_FORMAT_W(12),
414             p2i(bottom()), p2i(top()), p2i(end()));
415   st-&gt;print(&quot;|TAMS &quot; INTPTR_FORMAT_W(12),
<span class="line-modified">416             p2i(_heap-&gt;marking_context()-&gt;top_at_mark_start(const_cast&lt;ShenandoahHeapRegion*&gt;(this))));</span>


417   st-&gt;print(&quot;|U &quot; SIZE_FORMAT_W(5) &quot;%1s&quot;, byte_size_in_proper_unit(used()),                proper_unit_for_byte_size(used()));
418   st-&gt;print(&quot;|T &quot; SIZE_FORMAT_W(5) &quot;%1s&quot;, byte_size_in_proper_unit(get_tlab_allocs()),     proper_unit_for_byte_size(get_tlab_allocs()));
419   st-&gt;print(&quot;|G &quot; SIZE_FORMAT_W(5) &quot;%1s&quot;, byte_size_in_proper_unit(get_gclab_allocs()),    proper_unit_for_byte_size(get_gclab_allocs()));
420   st-&gt;print(&quot;|S &quot; SIZE_FORMAT_W(5) &quot;%1s&quot;, byte_size_in_proper_unit(get_shared_allocs()),   proper_unit_for_byte_size(get_shared_allocs()));
421   st-&gt;print(&quot;|L &quot; SIZE_FORMAT_W(5) &quot;%1s&quot;, byte_size_in_proper_unit(get_live_data_bytes()), proper_unit_for_byte_size(get_live_data_bytes()));
422   st-&gt;print(&quot;|CP &quot; SIZE_FORMAT_W(3), pin_count());
<span class="line-removed">423   st-&gt;print(&quot;|SN &quot; UINT64_FORMAT_X_W(12) &quot;, &quot; UINT64_FORMAT_X_W(8) &quot;, &quot; UINT64_FORMAT_X_W(8) &quot;, &quot; UINT64_FORMAT_X_W(8),</span>
<span class="line-removed">424             seqnum_first_alloc_mutator(), seqnum_last_alloc_mutator(),</span>
<span class="line-removed">425             seqnum_first_alloc_gc(), seqnum_last_alloc_gc());</span>
426   st-&gt;cr();
427 }
428 
429 void ShenandoahHeapRegion::oop_iterate(OopIterateClosure* blk) {
430   if (!is_active()) return;
431   if (is_humongous()) {
432     oop_iterate_humongous(blk);
433   } else {
434     oop_iterate_objects(blk);
435   }
436 }
437 
438 void ShenandoahHeapRegion::oop_iterate_objects(OopIterateClosure* blk) {
439   assert(! is_humongous(), &quot;no humongous region here&quot;);
440   HeapWord* obj_addr = bottom();
441   HeapWord* t = top();
442   // Could call objects iterate, but this is easier.
443   while (obj_addr &lt; t) {
444     oop obj = oop(obj_addr);
445     obj_addr += obj-&gt;oop_iterate_size(blk);
446   }
447 }
448 
449 void ShenandoahHeapRegion::oop_iterate_humongous(OopIterateClosure* blk) {
450   assert(is_humongous(), &quot;only humongous region here&quot;);
451   // Find head.
452   ShenandoahHeapRegion* r = humongous_start_region();
453   assert(r-&gt;is_humongous_start(), &quot;need humongous head here&quot;);
454   oop obj = oop(r-&gt;bottom());
455   obj-&gt;oop_iterate(blk, MemRegion(bottom(), top()));
456 }
457 
458 ShenandoahHeapRegion* ShenandoahHeapRegion::humongous_start_region() const {

459   assert(is_humongous(), &quot;Must be a part of the humongous region&quot;);
<span class="line-modified">460   size_t reg_num = region_number();</span>
461   ShenandoahHeapRegion* r = const_cast&lt;ShenandoahHeapRegion*&gt;(this);
462   while (!r-&gt;is_humongous_start()) {
<span class="line-modified">463     assert(reg_num &gt; 0, &quot;Sanity&quot;);</span>
<span class="line-modified">464     reg_num --;</span>
<span class="line-modified">465     r = _heap-&gt;get_region(reg_num);</span>
466     assert(r-&gt;is_humongous(), &quot;Must be a part of the humongous region&quot;);
467   }
468   assert(r-&gt;is_humongous_start(), &quot;Must be&quot;);
469   return r;
470 }
471 
472 void ShenandoahHeapRegion::recycle() {
<span class="line-modified">473   ContiguousSpace::clear(false);</span>
<span class="line-removed">474   if (ZapUnusedHeapArea) {</span>
<span class="line-removed">475     ContiguousSpace::mangle_unused_area_complete();</span>
<span class="line-removed">476   }</span>
477   clear_live_data();
478 
479   reset_alloc_metadata();
480 
<span class="line-modified">481   _heap-&gt;marking_context()-&gt;reset_top_at_mark_start(this);</span>

482 
483   make_empty();




484 }
485 
<span class="line-modified">486 HeapWord* ShenandoahHeapRegion::block_start_const(const void* p) const {</span>
487   assert(MemRegion(bottom(), end()).contains(p),
488          &quot;p (&quot; PTR_FORMAT &quot;) not in space [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;)&quot;,
489          p2i(p), p2i(bottom()), p2i(end()));
490   if (p &gt;= top()) {
491     return top();
492   } else {
493     HeapWord* last = bottom();
494     HeapWord* cur = last;
495     while (cur &lt;= p) {
496       last = cur;
497       cur += oop(cur)-&gt;size();
498     }
499     shenandoah_assert_correct(NULL, oop(last));
500     return last;
501   }
502 }
503 












504 void ShenandoahHeapRegion::setup_sizes(size_t max_heap_size) {
505   // Absolute minimums we should not ever break.
506   static const size_t MIN_REGION_SIZE = 256*K;
507 
508   if (FLAG_IS_DEFAULT(ShenandoahMinRegionSize)) {
509     FLAG_SET_DEFAULT(ShenandoahMinRegionSize, MIN_REGION_SIZE);
510   }
511 
512   size_t region_size;
<span class="line-modified">513   if (FLAG_IS_DEFAULT(ShenandoahHeapRegionSize)) {</span>
514     if (ShenandoahMinRegionSize &gt; max_heap_size / MIN_NUM_REGIONS) {
515       err_msg message(&quot;Max heap size (&quot; SIZE_FORMAT &quot;%s) is too low to afford the minimum number &quot;
516                       &quot;of regions (&quot; SIZE_FORMAT &quot;) of minimum region size (&quot; SIZE_FORMAT &quot;%s).&quot;,
517                       byte_size_in_proper_unit(max_heap_size), proper_unit_for_byte_size(max_heap_size),
518                       MIN_NUM_REGIONS,
519                       byte_size_in_proper_unit(ShenandoahMinRegionSize), proper_unit_for_byte_size(ShenandoahMinRegionSize));
520       vm_exit_during_initialization(&quot;Invalid -XX:ShenandoahMinRegionSize option&quot;, message);
521     }
522     if (ShenandoahMinRegionSize &lt; MIN_REGION_SIZE) {
523       err_msg message(&quot;&quot; SIZE_FORMAT &quot;%s should not be lower than minimum region size (&quot; SIZE_FORMAT &quot;%s).&quot;,
524                       byte_size_in_proper_unit(ShenandoahMinRegionSize), proper_unit_for_byte_size(ShenandoahMinRegionSize),
525                       byte_size_in_proper_unit(MIN_REGION_SIZE),         proper_unit_for_byte_size(MIN_REGION_SIZE));
526       vm_exit_during_initialization(&quot;Invalid -XX:ShenandoahMinRegionSize option&quot;, message);
527     }
528     if (ShenandoahMinRegionSize &lt; MinTLABSize) {
529       err_msg message(&quot;&quot; SIZE_FORMAT &quot;%s should not be lower than TLAB size size (&quot; SIZE_FORMAT &quot;%s).&quot;,
530                       byte_size_in_proper_unit(ShenandoahMinRegionSize), proper_unit_for_byte_size(ShenandoahMinRegionSize),
531                       byte_size_in_proper_unit(MinTLABSize),             proper_unit_for_byte_size(MinTLABSize));
532       vm_exit_during_initialization(&quot;Invalid -XX:ShenandoahMinRegionSize option&quot;, message);
533     }
</pre>
<hr />
<pre>
536                       byte_size_in_proper_unit(ShenandoahMaxRegionSize), proper_unit_for_byte_size(ShenandoahMaxRegionSize),
537                       byte_size_in_proper_unit(MIN_REGION_SIZE),         proper_unit_for_byte_size(MIN_REGION_SIZE));
538       vm_exit_during_initialization(&quot;Invalid -XX:ShenandoahMaxRegionSize option&quot;, message);
539     }
540     if (ShenandoahMinRegionSize &gt; ShenandoahMaxRegionSize) {
541       err_msg message(&quot;Minimum (&quot; SIZE_FORMAT &quot;%s) should be larger than maximum (&quot; SIZE_FORMAT &quot;%s).&quot;,
542                       byte_size_in_proper_unit(ShenandoahMinRegionSize), proper_unit_for_byte_size(ShenandoahMinRegionSize),
543                       byte_size_in_proper_unit(ShenandoahMaxRegionSize), proper_unit_for_byte_size(ShenandoahMaxRegionSize));
544       vm_exit_during_initialization(&quot;Invalid -XX:ShenandoahMinRegionSize or -XX:ShenandoahMaxRegionSize&quot;, message);
545     }
546 
547     // We rapidly expand to max_heap_size in most scenarios, so that is the measure
548     // for usual heap sizes. Do not depend on initial_heap_size here.
549     region_size = max_heap_size / ShenandoahTargetNumRegions;
550 
551     // Now make sure that we don&#39;t go over or under our limits.
552     region_size = MAX2(ShenandoahMinRegionSize, region_size);
553     region_size = MIN2(ShenandoahMaxRegionSize, region_size);
554 
555   } else {
<span class="line-modified">556     if (ShenandoahHeapRegionSize &gt; max_heap_size / MIN_NUM_REGIONS) {</span>
557       err_msg message(&quot;Max heap size (&quot; SIZE_FORMAT &quot;%s) is too low to afford the minimum number &quot;
558                               &quot;of regions (&quot; SIZE_FORMAT &quot;) of requested size (&quot; SIZE_FORMAT &quot;%s).&quot;,
559                       byte_size_in_proper_unit(max_heap_size), proper_unit_for_byte_size(max_heap_size),
560                       MIN_NUM_REGIONS,
<span class="line-modified">561                       byte_size_in_proper_unit(ShenandoahHeapRegionSize), proper_unit_for_byte_size(ShenandoahHeapRegionSize));</span>
<span class="line-modified">562       vm_exit_during_initialization(&quot;Invalid -XX:ShenandoahHeapRegionSize option&quot;, message);</span>
563     }
<span class="line-modified">564     if (ShenandoahHeapRegionSize &lt; ShenandoahMinRegionSize) {</span>
565       err_msg message(&quot;Heap region size (&quot; SIZE_FORMAT &quot;%s) should be larger than min region size (&quot; SIZE_FORMAT &quot;%s).&quot;,
<span class="line-modified">566                       byte_size_in_proper_unit(ShenandoahHeapRegionSize), proper_unit_for_byte_size(ShenandoahHeapRegionSize),</span>
567                       byte_size_in_proper_unit(ShenandoahMinRegionSize),  proper_unit_for_byte_size(ShenandoahMinRegionSize));
<span class="line-modified">568       vm_exit_during_initialization(&quot;Invalid -XX:ShenandoahHeapRegionSize option&quot;, message);</span>
569     }
<span class="line-modified">570     if (ShenandoahHeapRegionSize &gt; ShenandoahMaxRegionSize) {</span>
571       err_msg message(&quot;Heap region size (&quot; SIZE_FORMAT &quot;%s) should be lower than max region size (&quot; SIZE_FORMAT &quot;%s).&quot;,
<span class="line-modified">572                       byte_size_in_proper_unit(ShenandoahHeapRegionSize), proper_unit_for_byte_size(ShenandoahHeapRegionSize),</span>
573                       byte_size_in_proper_unit(ShenandoahMaxRegionSize),  proper_unit_for_byte_size(ShenandoahMaxRegionSize));
<span class="line-modified">574       vm_exit_during_initialization(&quot;Invalid -XX:ShenandoahHeapRegionSize option&quot;, message);</span>
575     }
<span class="line-modified">576     region_size = ShenandoahHeapRegionSize;</span>
577   }
578 
579   // Make sure region size is at least one large page, if enabled.
580   // Otherwise, uncommitting one region may falsely uncommit the adjacent
581   // regions too.
582   // Also see shenandoahArguments.cpp, where it handles UseLargePages.
583   if (UseLargePages &amp;&amp; ShenandoahUncommit) {
584     region_size = MAX2(region_size, os::large_page_size());
585   }
586 
587   int region_size_log = log2_long((jlong) region_size);
588   // Recalculate the region size to make sure it&#39;s a power of
589   // 2. This means that region_size is the largest power of 2 that&#39;s
590   // &lt;= what we&#39;ve calculated so far.
591   region_size = size_t(1) &lt;&lt; region_size_log;
592 
593   // Now, set up the globals.
594   guarantee(RegionSizeBytesShift == 0, &quot;we should only set it once&quot;);
595   RegionSizeBytesShift = (size_t)region_size_log;
596 
</pre>
<hr />
<pre>
639   //
640   // The whole thing is mitigated if Elastic TLABs are enabled.
641   //
642   guarantee(MaxTLABSizeWords == 0, &quot;we should only set it once&quot;);
643   MaxTLABSizeWords = MIN2(ShenandoahElasticTLAB ? RegionSizeWords : (RegionSizeWords / 8), HumongousThresholdWords);
644   MaxTLABSizeWords = align_down(MaxTLABSizeWords, MinObjAlignment);
645 
646   guarantee(MaxTLABSizeBytes == 0, &quot;we should only set it once&quot;);
647   MaxTLABSizeBytes = MaxTLABSizeWords * HeapWordSize;
648   assert (MaxTLABSizeBytes &gt; MinTLABSize, &quot;should be larger&quot;);
649 
650   log_info(gc, init)(&quot;Regions: &quot; SIZE_FORMAT &quot; x &quot; SIZE_FORMAT &quot;%s&quot;,
651                      RegionCount, byte_size_in_proper_unit(RegionSizeBytes), proper_unit_for_byte_size(RegionSizeBytes));
652   log_info(gc, init)(&quot;Humongous object threshold: &quot; SIZE_FORMAT &quot;%s&quot;,
653                      byte_size_in_proper_unit(HumongousThresholdBytes), proper_unit_for_byte_size(HumongousThresholdBytes));
654   log_info(gc, init)(&quot;Max TLAB size: &quot; SIZE_FORMAT &quot;%s&quot;,
655                      byte_size_in_proper_unit(MaxTLABSizeBytes), proper_unit_for_byte_size(MaxTLABSizeBytes));
656 }
657 
658 void ShenandoahHeapRegion::do_commit() {
<span class="line-modified">659   if (!_heap-&gt;is_heap_region_special() &amp;&amp; !os::commit_memory((char *) _reserved.start(), _reserved.byte_size(), false)) {</span>

660     report_java_out_of_memory(&quot;Unable to commit region&quot;);
661   }
<span class="line-modified">662   if (!_heap-&gt;commit_bitmap_slice(this)) {</span>
663     report_java_out_of_memory(&quot;Unable to commit bitmaps for region&quot;);
664   }
<span class="line-modified">665   _heap-&gt;increase_committed(ShenandoahHeapRegion::region_size_bytes());</span>
666 }
667 
668 void ShenandoahHeapRegion::do_uncommit() {
<span class="line-modified">669   if (!_heap-&gt;is_heap_region_special() &amp;&amp; !os::uncommit_memory((char *) _reserved.start(), _reserved.byte_size())) {</span>

670     report_java_out_of_memory(&quot;Unable to uncommit region&quot;);
671   }
<span class="line-modified">672   if (!_heap-&gt;uncommit_bitmap_slice(this)) {</span>
673     report_java_out_of_memory(&quot;Unable to uncommit bitmaps for region&quot;);
674   }
<span class="line-modified">675   _heap-&gt;decrease_committed(ShenandoahHeapRegion::region_size_bytes());</span>
676 }
677 
678 void ShenandoahHeapRegion::set_state(RegionState to) {
679   EventShenandoahHeapRegionStateChange evt;
680   if (evt.should_commit()){
<span class="line-modified">681     evt.set_index((unsigned)region_number());</span>
682     evt.set_start((uintptr_t)bottom());
683     evt.set_used(used());
684     evt.set_from(_state);
685     evt.set_to(to);
686     evt.commit();
687   }
688   _state = to;
689 }
690 
691 void ShenandoahHeapRegion::record_pin() {
692   Atomic::add(&amp;_critical_pins, (size_t)1);
693 }
694 
695 void ShenandoahHeapRegion::record_unpin() {
<span class="line-modified">696   assert(pin_count() &gt; 0, &quot;Region &quot; SIZE_FORMAT &quot; should have non-zero pins&quot;, region_number());</span>
697   Atomic::sub(&amp;_critical_pins, (size_t)1);
698 }
699 
700 size_t ShenandoahHeapRegion::pin_count() const {
701   return Atomic::load(&amp;_critical_pins);
702 }
</pre>
</td>
<td>
<hr />
<pre>
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;memory/allocation.hpp&quot;
 27 #include &quot;gc/shenandoah/shenandoahHeapRegionSet.inline.hpp&quot;
 28 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
 29 #include &quot;gc/shenandoah/shenandoahHeapRegion.hpp&quot;
 30 #include &quot;gc/shenandoah/shenandoahMarkingContext.inline.hpp&quot;

 31 #include &quot;gc/shared/space.inline.hpp&quot;
 32 #include &quot;jfr/jfrEvents.hpp&quot;
 33 #include &quot;memory/iterator.inline.hpp&quot;
 34 #include &quot;memory/resourceArea.hpp&quot;
 35 #include &quot;memory/universe.hpp&quot;
 36 #include &quot;oops/oop.inline.hpp&quot;
 37 #include &quot;runtime/atomic.hpp&quot;
 38 #include &quot;runtime/java.hpp&quot;
 39 #include &quot;runtime/mutexLocker.hpp&quot;
 40 #include &quot;runtime/os.hpp&quot;
 41 #include &quot;runtime/safepoint.hpp&quot;
 42 
 43 size_t ShenandoahHeapRegion::RegionCount = 0;
 44 size_t ShenandoahHeapRegion::RegionSizeBytes = 0;
 45 size_t ShenandoahHeapRegion::RegionSizeWords = 0;
 46 size_t ShenandoahHeapRegion::RegionSizeBytesShift = 0;
 47 size_t ShenandoahHeapRegion::RegionSizeWordsShift = 0;
 48 size_t ShenandoahHeapRegion::RegionSizeBytesMask = 0;
 49 size_t ShenandoahHeapRegion::RegionSizeWordsMask = 0;
 50 size_t ShenandoahHeapRegion::HumongousThresholdBytes = 0;
 51 size_t ShenandoahHeapRegion::HumongousThresholdWords = 0;
 52 size_t ShenandoahHeapRegion::MaxTLABSizeBytes = 0;
 53 size_t ShenandoahHeapRegion::MaxTLABSizeWords = 0;
 54 
<span class="line-modified"> 55 ShenandoahHeapRegion::ShenandoahHeapRegion(HeapWord* start, size_t index, bool committed) :</span>
<span class="line-modified"> 56   _index(index),</span>
<span class="line-modified"> 57   _bottom(start),</span>
<span class="line-modified"> 58   _end(start + RegionSizeWords),</span>



 59   _new_top(NULL),
 60   _empty_time(os::elapsedTime()),
 61   _state(committed ? _empty_committed : _empty_uncommitted),
<span class="line-added"> 62   _top(start),</span>
 63   _tlab_allocs(0),
 64   _gclab_allocs(0),





 65   _live_data(0),
<span class="line-modified"> 66   _critical_pins(0),</span>
<span class="line-modified"> 67   _update_watermark(start) {</span>


 68 
<span class="line-modified"> 69   assert(Universe::on_page_boundary(_bottom) &amp;&amp; Universe::on_page_boundary(_end),</span>
<span class="line-modified"> 70          &quot;invalid space boundaries&quot;);</span>
<span class="line-added"> 71   if (ZapUnusedHeapArea &amp;&amp; committed) {</span>
<span class="line-added"> 72     SpaceMangler::mangle_region(MemRegion(_bottom, _end));</span>
<span class="line-added"> 73   }</span>
 74 }
 75 
 76 void ShenandoahHeapRegion::report_illegal_transition(const char *method) {
 77   ResourceMark rm;
 78   stringStream ss;
 79   ss.print(&quot;Illegal region state transition from \&quot;%s\&quot;, at %s\n  &quot;, region_state_to_string(_state), method);
 80   print_on(&amp;ss);
 81   fatal(&quot;%s&quot;, ss.as_string());
 82 }
 83 
 84 void ShenandoahHeapRegion::make_regular_allocation() {
<span class="line-modified"> 85   shenandoah_assert_heaplocked();</span>
 86 
 87   switch (_state) {
 88     case _empty_uncommitted:
 89       do_commit();
 90     case _empty_committed:
 91       set_state(_regular);
 92     case _regular:
 93     case _pinned:
 94       return;
 95     default:
 96       report_illegal_transition(&quot;regular allocation&quot;);
 97   }
 98 }
 99 
100 void ShenandoahHeapRegion::make_regular_bypass() {
<span class="line-modified">101   shenandoah_assert_heaplocked();</span>
<span class="line-modified">102   assert (ShenandoahHeap::heap()-&gt;is_full_gc_in_progress() || ShenandoahHeap::heap()-&gt;is_degenerated_gc_in_progress(),</span>
103           &quot;only for full or degen GC&quot;);
104 
105   switch (_state) {
106     case _empty_uncommitted:
107       do_commit();
108     case _empty_committed:
109     case _cset:
110     case _humongous_start:
111     case _humongous_cont:
112       set_state(_regular);
113       return;
114     case _pinned_cset:
115       set_state(_pinned);
116       return;
117     case _regular:
118     case _pinned:
119       return;
120     default:
121       report_illegal_transition(&quot;regular bypass&quot;);
122   }
123 }
124 
125 void ShenandoahHeapRegion::make_humongous_start() {
<span class="line-modified">126   shenandoah_assert_heaplocked();</span>
127   switch (_state) {
128     case _empty_uncommitted:
129       do_commit();
130     case _empty_committed:
131       set_state(_humongous_start);
132       return;
133     default:
134       report_illegal_transition(&quot;humongous start allocation&quot;);
135   }
136 }
137 
138 void ShenandoahHeapRegion::make_humongous_start_bypass() {
<span class="line-modified">139   shenandoah_assert_heaplocked();</span>
<span class="line-modified">140   assert (ShenandoahHeap::heap()-&gt;is_full_gc_in_progress(), &quot;only for full GC&quot;);</span>
141 
142   switch (_state) {
143     case _empty_committed:
144     case _regular:
145     case _humongous_start:
146     case _humongous_cont:
147       set_state(_humongous_start);
148       return;
149     default:
150       report_illegal_transition(&quot;humongous start bypass&quot;);
151   }
152 }
153 
154 void ShenandoahHeapRegion::make_humongous_cont() {
<span class="line-modified">155   shenandoah_assert_heaplocked();</span>
156   switch (_state) {
157     case _empty_uncommitted:
158       do_commit();
159     case _empty_committed:
160      set_state(_humongous_cont);
161       return;
162     default:
163       report_illegal_transition(&quot;humongous continuation allocation&quot;);
164   }
165 }
166 
167 void ShenandoahHeapRegion::make_humongous_cont_bypass() {
<span class="line-modified">168   shenandoah_assert_heaplocked();</span>
<span class="line-modified">169   assert (ShenandoahHeap::heap()-&gt;is_full_gc_in_progress(), &quot;only for full GC&quot;);</span>
170 
171   switch (_state) {
172     case _empty_committed:
173     case _regular:
174     case _humongous_start:
175     case _humongous_cont:
176       set_state(_humongous_cont);
177       return;
178     default:
179       report_illegal_transition(&quot;humongous continuation bypass&quot;);
180   }
181 }
182 
183 void ShenandoahHeapRegion::make_pinned() {
<span class="line-modified">184   shenandoah_assert_heaplocked();</span>
185   assert(pin_count() &gt; 0, &quot;Should have pins: &quot; SIZE_FORMAT, pin_count());
186 
187   switch (_state) {
188     case _regular:
189       set_state(_pinned);
190     case _pinned_cset:
191     case _pinned:
192       return;
193     case _humongous_start:
194       set_state(_pinned_humongous_start);
195     case _pinned_humongous_start:
196       return;
197     case _cset:
198       _state = _pinned_cset;
199       return;
200     default:
201       report_illegal_transition(&quot;pinning&quot;);
202   }
203 }
204 
205 void ShenandoahHeapRegion::make_unpinned() {
<span class="line-modified">206   shenandoah_assert_heaplocked();</span>
207   assert(pin_count() == 0, &quot;Should not have pins: &quot; SIZE_FORMAT, pin_count());
208 
209   switch (_state) {
210     case _pinned:
211       set_state(_regular);
212       return;
213     case _regular:
214     case _humongous_start:
215       return;
216     case _pinned_cset:
217       set_state(_cset);
218       return;
219     case _pinned_humongous_start:
220       set_state(_humongous_start);
221       return;
222     default:
223       report_illegal_transition(&quot;unpinning&quot;);
224   }
225 }
226 
227 void ShenandoahHeapRegion::make_cset() {
<span class="line-modified">228   shenandoah_assert_heaplocked();</span>
229   switch (_state) {
230     case _regular:
231       set_state(_cset);
232     case _cset:
233       return;
234     default:
235       report_illegal_transition(&quot;cset&quot;);
236   }
237 }
238 
239 void ShenandoahHeapRegion::make_trash() {
<span class="line-modified">240   shenandoah_assert_heaplocked();</span>
241   switch (_state) {
242     case _cset:
243       // Reclaiming cset regions
244     case _humongous_start:
245     case _humongous_cont:
246       // Reclaiming humongous regions
247     case _regular:
248       // Immediate region reclaim
249       set_state(_trash);
250       return;
251     default:
252       report_illegal_transition(&quot;trashing&quot;);
253   }
254 }
255 
256 void ShenandoahHeapRegion::make_trash_immediate() {
257   make_trash();
258 
259   // On this path, we know there are no marked objects in the region,
260   // tell marking context about it to bypass bitmap resets.
<span class="line-modified">261   ShenandoahHeap::heap()-&gt;complete_marking_context()-&gt;reset_top_bitmap(this);</span>
262 }
263 
264 void ShenandoahHeapRegion::make_empty() {
<span class="line-modified">265   shenandoah_assert_heaplocked();</span>
266   switch (_state) {
267     case _trash:
268       set_state(_empty_committed);
269       _empty_time = os::elapsedTime();
270       return;
271     default:
272       report_illegal_transition(&quot;emptying&quot;);
273   }
274 }
275 
276 void ShenandoahHeapRegion::make_uncommitted() {
<span class="line-modified">277   shenandoah_assert_heaplocked();</span>
278   switch (_state) {
279     case _empty_committed:
280       do_uncommit();
281       set_state(_empty_uncommitted);
282       return;
283     default:
284       report_illegal_transition(&quot;uncommiting&quot;);
285   }
286 }
287 
288 void ShenandoahHeapRegion::make_committed_bypass() {
<span class="line-modified">289   shenandoah_assert_heaplocked();</span>
<span class="line-modified">290   assert (ShenandoahHeap::heap()-&gt;is_full_gc_in_progress(), &quot;only for full GC&quot;);</span>
291 
292   switch (_state) {
293     case _empty_uncommitted:
294       do_commit();
295       set_state(_empty_committed);
296       return;
297     default:
298       report_illegal_transition(&quot;commit bypass&quot;);
299   }
300 }
301 




302 void ShenandoahHeapRegion::reset_alloc_metadata() {
303   _tlab_allocs = 0;
304   _gclab_allocs = 0;




















305 }
306 
307 size_t ShenandoahHeapRegion::get_shared_allocs() const {
<span class="line-modified">308   return used() - (_tlab_allocs + _gclab_allocs) * HeapWordSize;</span>
309 }
310 
311 size_t ShenandoahHeapRegion::get_tlab_allocs() const {
312   return _tlab_allocs * HeapWordSize;
313 }
314 
315 size_t ShenandoahHeapRegion::get_gclab_allocs() const {
316   return _gclab_allocs * HeapWordSize;
317 }
318 
319 void ShenandoahHeapRegion::set_live_data(size_t s) {
320   assert(Thread::current()-&gt;is_VM_thread(), &quot;by VM thread&quot;);
321   _live_data = (s &gt;&gt; LogHeapWordSize);
322 }
323 




















324 void ShenandoahHeapRegion::print_on(outputStream* st) const {
325   st-&gt;print(&quot;|&quot;);
<span class="line-modified">326   st-&gt;print(SIZE_FORMAT_W(5), this-&gt;_index);</span>
327 
328   switch (_state) {
329     case _empty_uncommitted:
330       st-&gt;print(&quot;|EU &quot;);
331       break;
332     case _empty_committed:
333       st-&gt;print(&quot;|EC &quot;);
334       break;
335     case _regular:
336       st-&gt;print(&quot;|R  &quot;);
337       break;
338     case _humongous_start:
339       st-&gt;print(&quot;|H  &quot;);
340       break;
341     case _pinned_humongous_start:
342       st-&gt;print(&quot;|HP &quot;);
343       break;
344     case _humongous_cont:
345       st-&gt;print(&quot;|HC &quot;);
346       break;
347     case _cset:
348       st-&gt;print(&quot;|CS &quot;);
349       break;
350     case _trash:
351       st-&gt;print(&quot;|T  &quot;);
352       break;
353     case _pinned:
354       st-&gt;print(&quot;|P  &quot;);
355       break;
356     case _pinned_cset:
357       st-&gt;print(&quot;|CSP&quot;);
358       break;
359     default:
360       ShouldNotReachHere();
361   }
362   st-&gt;print(&quot;|BTE &quot; INTPTR_FORMAT_W(12) &quot;, &quot; INTPTR_FORMAT_W(12) &quot;, &quot; INTPTR_FORMAT_W(12),
363             p2i(bottom()), p2i(top()), p2i(end()));
364   st-&gt;print(&quot;|TAMS &quot; INTPTR_FORMAT_W(12),
<span class="line-modified">365             p2i(ShenandoahHeap::heap()-&gt;marking_context()-&gt;top_at_mark_start(const_cast&lt;ShenandoahHeapRegion*&gt;(this))));</span>
<span class="line-added">366   st-&gt;print(&quot;|UWM &quot; INTPTR_FORMAT_W(12),</span>
<span class="line-added">367             p2i(_update_watermark));</span>
368   st-&gt;print(&quot;|U &quot; SIZE_FORMAT_W(5) &quot;%1s&quot;, byte_size_in_proper_unit(used()),                proper_unit_for_byte_size(used()));
369   st-&gt;print(&quot;|T &quot; SIZE_FORMAT_W(5) &quot;%1s&quot;, byte_size_in_proper_unit(get_tlab_allocs()),     proper_unit_for_byte_size(get_tlab_allocs()));
370   st-&gt;print(&quot;|G &quot; SIZE_FORMAT_W(5) &quot;%1s&quot;, byte_size_in_proper_unit(get_gclab_allocs()),    proper_unit_for_byte_size(get_gclab_allocs()));
371   st-&gt;print(&quot;|S &quot; SIZE_FORMAT_W(5) &quot;%1s&quot;, byte_size_in_proper_unit(get_shared_allocs()),   proper_unit_for_byte_size(get_shared_allocs()));
372   st-&gt;print(&quot;|L &quot; SIZE_FORMAT_W(5) &quot;%1s&quot;, byte_size_in_proper_unit(get_live_data_bytes()), proper_unit_for_byte_size(get_live_data_bytes()));
373   st-&gt;print(&quot;|CP &quot; SIZE_FORMAT_W(3), pin_count());



374   st-&gt;cr();
375 }
376 
377 void ShenandoahHeapRegion::oop_iterate(OopIterateClosure* blk) {
378   if (!is_active()) return;
379   if (is_humongous()) {
380     oop_iterate_humongous(blk);
381   } else {
382     oop_iterate_objects(blk);
383   }
384 }
385 
386 void ShenandoahHeapRegion::oop_iterate_objects(OopIterateClosure* blk) {
387   assert(! is_humongous(), &quot;no humongous region here&quot;);
388   HeapWord* obj_addr = bottom();
389   HeapWord* t = top();
390   // Could call objects iterate, but this is easier.
391   while (obj_addr &lt; t) {
392     oop obj = oop(obj_addr);
393     obj_addr += obj-&gt;oop_iterate_size(blk);
394   }
395 }
396 
397 void ShenandoahHeapRegion::oop_iterate_humongous(OopIterateClosure* blk) {
398   assert(is_humongous(), &quot;only humongous region here&quot;);
399   // Find head.
400   ShenandoahHeapRegion* r = humongous_start_region();
401   assert(r-&gt;is_humongous_start(), &quot;need humongous head here&quot;);
402   oop obj = oop(r-&gt;bottom());
403   obj-&gt;oop_iterate(blk, MemRegion(bottom(), top()));
404 }
405 
406 ShenandoahHeapRegion* ShenandoahHeapRegion::humongous_start_region() const {
<span class="line-added">407   ShenandoahHeap* heap = ShenandoahHeap::heap();</span>
408   assert(is_humongous(), &quot;Must be a part of the humongous region&quot;);
<span class="line-modified">409   size_t i = index();</span>
410   ShenandoahHeapRegion* r = const_cast&lt;ShenandoahHeapRegion*&gt;(this);
411   while (!r-&gt;is_humongous_start()) {
<span class="line-modified">412     assert(i &gt; 0, &quot;Sanity&quot;);</span>
<span class="line-modified">413     i--;</span>
<span class="line-modified">414     r = heap-&gt;get_region(i);</span>
415     assert(r-&gt;is_humongous(), &quot;Must be a part of the humongous region&quot;);
416   }
417   assert(r-&gt;is_humongous_start(), &quot;Must be&quot;);
418   return r;
419 }
420 
421 void ShenandoahHeapRegion::recycle() {
<span class="line-modified">422   set_top(bottom());</span>



423   clear_live_data();
424 
425   reset_alloc_metadata();
426 
<span class="line-modified">427   ShenandoahHeap::heap()-&gt;marking_context()-&gt;reset_top_at_mark_start(this);</span>
<span class="line-added">428   set_update_watermark(bottom());</span>
429 
430   make_empty();
<span class="line-added">431 </span>
<span class="line-added">432   if (ZapUnusedHeapArea) {</span>
<span class="line-added">433     SpaceMangler::mangle_region(MemRegion(bottom(), end()));</span>
<span class="line-added">434   }</span>
435 }
436 
<span class="line-modified">437 HeapWord* ShenandoahHeapRegion::block_start(const void* p) const {</span>
438   assert(MemRegion(bottom(), end()).contains(p),
439          &quot;p (&quot; PTR_FORMAT &quot;) not in space [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;)&quot;,
440          p2i(p), p2i(bottom()), p2i(end()));
441   if (p &gt;= top()) {
442     return top();
443   } else {
444     HeapWord* last = bottom();
445     HeapWord* cur = last;
446     while (cur &lt;= p) {
447       last = cur;
448       cur += oop(cur)-&gt;size();
449     }
450     shenandoah_assert_correct(NULL, oop(last));
451     return last;
452   }
453 }
454 
<span class="line-added">455 size_t ShenandoahHeapRegion::block_size(const HeapWord* p) const {</span>
<span class="line-added">456   assert(MemRegion(bottom(), end()).contains(p),</span>
<span class="line-added">457          &quot;p (&quot; PTR_FORMAT &quot;) not in space [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;)&quot;,</span>
<span class="line-added">458          p2i(p), p2i(bottom()), p2i(end()));</span>
<span class="line-added">459   if (p &lt; top()) {</span>
<span class="line-added">460     return oop(p)-&gt;size();</span>
<span class="line-added">461   } else {</span>
<span class="line-added">462     assert(p == top(), &quot;just checking&quot;);</span>
<span class="line-added">463     return pointer_delta(end(), (HeapWord*) p);</span>
<span class="line-added">464   }</span>
<span class="line-added">465 }</span>
<span class="line-added">466 </span>
467 void ShenandoahHeapRegion::setup_sizes(size_t max_heap_size) {
468   // Absolute minimums we should not ever break.
469   static const size_t MIN_REGION_SIZE = 256*K;
470 
471   if (FLAG_IS_DEFAULT(ShenandoahMinRegionSize)) {
472     FLAG_SET_DEFAULT(ShenandoahMinRegionSize, MIN_REGION_SIZE);
473   }
474 
475   size_t region_size;
<span class="line-modified">476   if (FLAG_IS_DEFAULT(ShenandoahRegionSize)) {</span>
477     if (ShenandoahMinRegionSize &gt; max_heap_size / MIN_NUM_REGIONS) {
478       err_msg message(&quot;Max heap size (&quot; SIZE_FORMAT &quot;%s) is too low to afford the minimum number &quot;
479                       &quot;of regions (&quot; SIZE_FORMAT &quot;) of minimum region size (&quot; SIZE_FORMAT &quot;%s).&quot;,
480                       byte_size_in_proper_unit(max_heap_size), proper_unit_for_byte_size(max_heap_size),
481                       MIN_NUM_REGIONS,
482                       byte_size_in_proper_unit(ShenandoahMinRegionSize), proper_unit_for_byte_size(ShenandoahMinRegionSize));
483       vm_exit_during_initialization(&quot;Invalid -XX:ShenandoahMinRegionSize option&quot;, message);
484     }
485     if (ShenandoahMinRegionSize &lt; MIN_REGION_SIZE) {
486       err_msg message(&quot;&quot; SIZE_FORMAT &quot;%s should not be lower than minimum region size (&quot; SIZE_FORMAT &quot;%s).&quot;,
487                       byte_size_in_proper_unit(ShenandoahMinRegionSize), proper_unit_for_byte_size(ShenandoahMinRegionSize),
488                       byte_size_in_proper_unit(MIN_REGION_SIZE),         proper_unit_for_byte_size(MIN_REGION_SIZE));
489       vm_exit_during_initialization(&quot;Invalid -XX:ShenandoahMinRegionSize option&quot;, message);
490     }
491     if (ShenandoahMinRegionSize &lt; MinTLABSize) {
492       err_msg message(&quot;&quot; SIZE_FORMAT &quot;%s should not be lower than TLAB size size (&quot; SIZE_FORMAT &quot;%s).&quot;,
493                       byte_size_in_proper_unit(ShenandoahMinRegionSize), proper_unit_for_byte_size(ShenandoahMinRegionSize),
494                       byte_size_in_proper_unit(MinTLABSize),             proper_unit_for_byte_size(MinTLABSize));
495       vm_exit_during_initialization(&quot;Invalid -XX:ShenandoahMinRegionSize option&quot;, message);
496     }
</pre>
<hr />
<pre>
499                       byte_size_in_proper_unit(ShenandoahMaxRegionSize), proper_unit_for_byte_size(ShenandoahMaxRegionSize),
500                       byte_size_in_proper_unit(MIN_REGION_SIZE),         proper_unit_for_byte_size(MIN_REGION_SIZE));
501       vm_exit_during_initialization(&quot;Invalid -XX:ShenandoahMaxRegionSize option&quot;, message);
502     }
503     if (ShenandoahMinRegionSize &gt; ShenandoahMaxRegionSize) {
504       err_msg message(&quot;Minimum (&quot; SIZE_FORMAT &quot;%s) should be larger than maximum (&quot; SIZE_FORMAT &quot;%s).&quot;,
505                       byte_size_in_proper_unit(ShenandoahMinRegionSize), proper_unit_for_byte_size(ShenandoahMinRegionSize),
506                       byte_size_in_proper_unit(ShenandoahMaxRegionSize), proper_unit_for_byte_size(ShenandoahMaxRegionSize));
507       vm_exit_during_initialization(&quot;Invalid -XX:ShenandoahMinRegionSize or -XX:ShenandoahMaxRegionSize&quot;, message);
508     }
509 
510     // We rapidly expand to max_heap_size in most scenarios, so that is the measure
511     // for usual heap sizes. Do not depend on initial_heap_size here.
512     region_size = max_heap_size / ShenandoahTargetNumRegions;
513 
514     // Now make sure that we don&#39;t go over or under our limits.
515     region_size = MAX2(ShenandoahMinRegionSize, region_size);
516     region_size = MIN2(ShenandoahMaxRegionSize, region_size);
517 
518   } else {
<span class="line-modified">519     if (ShenandoahRegionSize &gt; max_heap_size / MIN_NUM_REGIONS) {</span>
520       err_msg message(&quot;Max heap size (&quot; SIZE_FORMAT &quot;%s) is too low to afford the minimum number &quot;
521                               &quot;of regions (&quot; SIZE_FORMAT &quot;) of requested size (&quot; SIZE_FORMAT &quot;%s).&quot;,
522                       byte_size_in_proper_unit(max_heap_size), proper_unit_for_byte_size(max_heap_size),
523                       MIN_NUM_REGIONS,
<span class="line-modified">524                       byte_size_in_proper_unit(ShenandoahRegionSize), proper_unit_for_byte_size(ShenandoahRegionSize));</span>
<span class="line-modified">525       vm_exit_during_initialization(&quot;Invalid -XX:ShenandoahRegionSize option&quot;, message);</span>
526     }
<span class="line-modified">527     if (ShenandoahRegionSize &lt; ShenandoahMinRegionSize) {</span>
528       err_msg message(&quot;Heap region size (&quot; SIZE_FORMAT &quot;%s) should be larger than min region size (&quot; SIZE_FORMAT &quot;%s).&quot;,
<span class="line-modified">529                       byte_size_in_proper_unit(ShenandoahRegionSize), proper_unit_for_byte_size(ShenandoahRegionSize),</span>
530                       byte_size_in_proper_unit(ShenandoahMinRegionSize),  proper_unit_for_byte_size(ShenandoahMinRegionSize));
<span class="line-modified">531       vm_exit_during_initialization(&quot;Invalid -XX:ShenandoahRegionSize option&quot;, message);</span>
532     }
<span class="line-modified">533     if (ShenandoahRegionSize &gt; ShenandoahMaxRegionSize) {</span>
534       err_msg message(&quot;Heap region size (&quot; SIZE_FORMAT &quot;%s) should be lower than max region size (&quot; SIZE_FORMAT &quot;%s).&quot;,
<span class="line-modified">535                       byte_size_in_proper_unit(ShenandoahRegionSize), proper_unit_for_byte_size(ShenandoahRegionSize),</span>
536                       byte_size_in_proper_unit(ShenandoahMaxRegionSize),  proper_unit_for_byte_size(ShenandoahMaxRegionSize));
<span class="line-modified">537       vm_exit_during_initialization(&quot;Invalid -XX:ShenandoahRegionSize option&quot;, message);</span>
538     }
<span class="line-modified">539     region_size = ShenandoahRegionSize;</span>
540   }
541 
542   // Make sure region size is at least one large page, if enabled.
543   // Otherwise, uncommitting one region may falsely uncommit the adjacent
544   // regions too.
545   // Also see shenandoahArguments.cpp, where it handles UseLargePages.
546   if (UseLargePages &amp;&amp; ShenandoahUncommit) {
547     region_size = MAX2(region_size, os::large_page_size());
548   }
549 
550   int region_size_log = log2_long((jlong) region_size);
551   // Recalculate the region size to make sure it&#39;s a power of
552   // 2. This means that region_size is the largest power of 2 that&#39;s
553   // &lt;= what we&#39;ve calculated so far.
554   region_size = size_t(1) &lt;&lt; region_size_log;
555 
556   // Now, set up the globals.
557   guarantee(RegionSizeBytesShift == 0, &quot;we should only set it once&quot;);
558   RegionSizeBytesShift = (size_t)region_size_log;
559 
</pre>
<hr />
<pre>
602   //
603   // The whole thing is mitigated if Elastic TLABs are enabled.
604   //
605   guarantee(MaxTLABSizeWords == 0, &quot;we should only set it once&quot;);
606   MaxTLABSizeWords = MIN2(ShenandoahElasticTLAB ? RegionSizeWords : (RegionSizeWords / 8), HumongousThresholdWords);
607   MaxTLABSizeWords = align_down(MaxTLABSizeWords, MinObjAlignment);
608 
609   guarantee(MaxTLABSizeBytes == 0, &quot;we should only set it once&quot;);
610   MaxTLABSizeBytes = MaxTLABSizeWords * HeapWordSize;
611   assert (MaxTLABSizeBytes &gt; MinTLABSize, &quot;should be larger&quot;);
612 
613   log_info(gc, init)(&quot;Regions: &quot; SIZE_FORMAT &quot; x &quot; SIZE_FORMAT &quot;%s&quot;,
614                      RegionCount, byte_size_in_proper_unit(RegionSizeBytes), proper_unit_for_byte_size(RegionSizeBytes));
615   log_info(gc, init)(&quot;Humongous object threshold: &quot; SIZE_FORMAT &quot;%s&quot;,
616                      byte_size_in_proper_unit(HumongousThresholdBytes), proper_unit_for_byte_size(HumongousThresholdBytes));
617   log_info(gc, init)(&quot;Max TLAB size: &quot; SIZE_FORMAT &quot;%s&quot;,
618                      byte_size_in_proper_unit(MaxTLABSizeBytes), proper_unit_for_byte_size(MaxTLABSizeBytes));
619 }
620 
621 void ShenandoahHeapRegion::do_commit() {
<span class="line-modified">622   ShenandoahHeap* heap = ShenandoahHeap::heap();</span>
<span class="line-added">623   if (!heap-&gt;is_heap_region_special() &amp;&amp; !os::commit_memory((char *) bottom(), RegionSizeBytes, false)) {</span>
624     report_java_out_of_memory(&quot;Unable to commit region&quot;);
625   }
<span class="line-modified">626   if (!heap-&gt;commit_bitmap_slice(this)) {</span>
627     report_java_out_of_memory(&quot;Unable to commit bitmaps for region&quot;);
628   }
<span class="line-modified">629   heap-&gt;increase_committed(ShenandoahHeapRegion::region_size_bytes());</span>
630 }
631 
632 void ShenandoahHeapRegion::do_uncommit() {
<span class="line-modified">633   ShenandoahHeap* heap = ShenandoahHeap::heap();</span>
<span class="line-added">634   if (!heap-&gt;is_heap_region_special() &amp;&amp; !os::uncommit_memory((char *) bottom(), RegionSizeBytes)) {</span>
635     report_java_out_of_memory(&quot;Unable to uncommit region&quot;);
636   }
<span class="line-modified">637   if (!heap-&gt;uncommit_bitmap_slice(this)) {</span>
638     report_java_out_of_memory(&quot;Unable to uncommit bitmaps for region&quot;);
639   }
<span class="line-modified">640   heap-&gt;decrease_committed(ShenandoahHeapRegion::region_size_bytes());</span>
641 }
642 
643 void ShenandoahHeapRegion::set_state(RegionState to) {
644   EventShenandoahHeapRegionStateChange evt;
645   if (evt.should_commit()){
<span class="line-modified">646     evt.set_index((unsigned) index());</span>
647     evt.set_start((uintptr_t)bottom());
648     evt.set_used(used());
649     evt.set_from(_state);
650     evt.set_to(to);
651     evt.commit();
652   }
653   _state = to;
654 }
655 
656 void ShenandoahHeapRegion::record_pin() {
657   Atomic::add(&amp;_critical_pins, (size_t)1);
658 }
659 
660 void ShenandoahHeapRegion::record_unpin() {
<span class="line-modified">661   assert(pin_count() &gt; 0, &quot;Region &quot; SIZE_FORMAT &quot; should have non-zero pins&quot;, index());</span>
662   Atomic::sub(&amp;_critical_pins, (size_t)1);
663 }
664 
665 size_t ShenandoahHeapRegion::pin_count() const {
666   return Atomic::load(&amp;_critical_pins);
667 }
</pre>
</td>
</tr>
</table>
<center><a href="shenandoahHeap.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahHeapRegion.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
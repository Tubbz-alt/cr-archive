<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/shenandoah/shenandoahVerifier.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2017, 2020, Red Hat, Inc. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 
  27 #include &quot;gc/shenandoah/shenandoahAsserts.hpp&quot;
  28 #include &quot;gc/shenandoah/shenandoahConcurrentRoots.hpp&quot;
  29 #include &quot;gc/shenandoah/shenandoahForwarding.inline.hpp&quot;
  30 #include &quot;gc/shenandoah/shenandoahPhaseTimings.hpp&quot;
  31 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
<a name="1" id="anc1"></a><span class="line-added">  32 #include &quot;gc/shenandoah/shenandoahHeapRegion.inline.hpp&quot;</span>
  33 #include &quot;gc/shenandoah/shenandoahRootProcessor.hpp&quot;
  34 #include &quot;gc/shenandoah/shenandoahTaskqueue.inline.hpp&quot;
  35 #include &quot;gc/shenandoah/shenandoahUtils.hpp&quot;
  36 #include &quot;gc/shenandoah/shenandoahVerifier.hpp&quot;
  37 #include &quot;memory/allocation.hpp&quot;
  38 #include &quot;memory/iterator.inline.hpp&quot;
  39 #include &quot;memory/resourceArea.hpp&quot;
  40 #include &quot;oops/compressedOops.inline.hpp&quot;
  41 #include &quot;runtime/atomic.hpp&quot;
  42 #include &quot;runtime/orderAccess.hpp&quot;
  43 #include &quot;utilities/align.hpp&quot;
  44 
  45 // Avoid name collision on verify_oop (defined in macroAssembler_arm.hpp)
  46 #ifdef verify_oop
  47 #undef verify_oop
  48 #endif
  49 
  50 class ShenandoahVerifyOopClosure : public BasicOopIterateClosure {
  51 private:
  52   const char* _phase;
  53   ShenandoahVerifier::VerifyOptions _options;
  54   ShenandoahVerifierStack* _stack;
  55   ShenandoahHeap* _heap;
  56   MarkBitMap* _map;
  57   ShenandoahLivenessData* _ld;
  58   void* _interior_loc;
  59   oop _loc;
  60 
  61 public:
  62   ShenandoahVerifyOopClosure(ShenandoahVerifierStack* stack, MarkBitMap* map, ShenandoahLivenessData* ld,
  63                              const char* phase, ShenandoahVerifier::VerifyOptions options) :
  64     _phase(phase),
  65     _options(options),
  66     _stack(stack),
  67     _heap(ShenandoahHeap::heap()),
  68     _map(map),
  69     _ld(ld),
  70     _interior_loc(NULL),
  71     _loc(NULL) { }
  72 
  73 private:
  74   void check(ShenandoahAsserts::SafeLevel level, oop obj, bool test, const char* label) {
  75     if (!test) {
  76       ShenandoahAsserts::print_failure(level, obj, _interior_loc, _loc, _phase, label, __FILE__, __LINE__);
  77     }
  78   }
  79 
  80   template &lt;class T&gt;
  81   void do_oop_work(T* p) {
  82     T o = RawAccess&lt;&gt;::oop_load(p);
  83     if (!CompressedOops::is_null(o)) {
  84       oop obj = CompressedOops::decode_not_null(o);
  85 
  86       // Single threaded verification can use faster non-atomic stack and bitmap
  87       // methods.
  88       //
  89       // For performance reasons, only fully verify non-marked field values.
  90       // We are here when the host object for *p is already marked.
  91 
  92       if (_map-&gt;par_mark(obj)) {
  93         verify_oop_at(p, obj);
  94         _stack-&gt;push(ShenandoahVerifierTask(obj));
  95       }
  96     }
  97   }
  98 
  99   void verify_oop(oop obj) {
 100     // Perform consistency checks with gradually decreasing safety level. This guarantees
 101     // that failure report would not try to touch something that was not yet verified to be
 102     // safe to process.
 103 
 104     check(ShenandoahAsserts::_safe_unknown, obj, _heap-&gt;is_in(obj),
 105               &quot;oop must be in heap&quot;);
 106     check(ShenandoahAsserts::_safe_unknown, obj, is_object_aligned(obj),
 107               &quot;oop must be aligned&quot;);
 108 
 109     ShenandoahHeapRegion *obj_reg = _heap-&gt;heap_region_containing(obj);
 110     Klass* obj_klass = obj-&gt;klass_or_null();
 111 
 112     // Verify that obj is not in dead space:
 113     {
 114       // Do this before touching obj-&gt;size()
 115       check(ShenandoahAsserts::_safe_unknown, obj, obj_klass != NULL,
 116              &quot;Object klass pointer should not be NULL&quot;);
 117       check(ShenandoahAsserts::_safe_unknown, obj, Metaspace::contains(obj_klass),
 118              &quot;Object klass pointer must go to metaspace&quot;);
 119 
 120       HeapWord *obj_addr = cast_from_oop&lt;HeapWord*&gt;(obj);
 121       check(ShenandoahAsserts::_safe_unknown, obj, obj_addr &lt; obj_reg-&gt;top(),
 122              &quot;Object start should be within the region&quot;);
 123 
 124       if (!obj_reg-&gt;is_humongous()) {
 125         check(ShenandoahAsserts::_safe_unknown, obj, (obj_addr + obj-&gt;size()) &lt;= obj_reg-&gt;top(),
 126                &quot;Object end should be within the region&quot;);
 127       } else {
<a name="2" id="anc2"></a><span class="line-modified"> 128         size_t humongous_start = obj_reg-&gt;index();</span>
 129         size_t humongous_end = humongous_start + (obj-&gt;size() &gt;&gt; ShenandoahHeapRegion::region_size_words_shift());
 130         for (size_t idx = humongous_start + 1; idx &lt; humongous_end; idx++) {
 131           check(ShenandoahAsserts::_safe_unknown, obj, _heap-&gt;get_region(idx)-&gt;is_humongous_continuation(),
 132                  &quot;Humongous object is in continuation that fits it&quot;);
 133         }
 134       }
 135 
 136       // ------------ obj is safe at this point --------------
 137 
 138       check(ShenandoahAsserts::_safe_oop, obj, obj_reg-&gt;is_active(),
 139             &quot;Object should be in active region&quot;);
 140 
 141       switch (_options._verify_liveness) {
 142         case ShenandoahVerifier::_verify_liveness_disable:
 143           // skip
 144           break;
 145         case ShenandoahVerifier::_verify_liveness_complete:
<a name="3" id="anc3"></a><span class="line-modified"> 146           Atomic::add(&amp;_ld[obj_reg-&gt;index()], (uint) obj-&gt;size());</span>
 147           // fallthrough for fast failure for un-live regions:
 148         case ShenandoahVerifier::_verify_liveness_conservative:
 149           check(ShenandoahAsserts::_safe_oop, obj, obj_reg-&gt;has_live(),
 150                    &quot;Object must belong to region with live data&quot;);
 151           break;
 152         default:
 153           assert(false, &quot;Unhandled liveness verification&quot;);
 154       }
 155     }
 156 
 157     oop fwd = (oop) ShenandoahForwarding::get_forwardee_raw_unchecked(obj);
 158 
 159     ShenandoahHeapRegion* fwd_reg = NULL;
 160 
 161     if (obj != fwd) {
 162       check(ShenandoahAsserts::_safe_oop, obj, _heap-&gt;is_in(fwd),
 163              &quot;Forwardee must be in heap&quot;);
 164       check(ShenandoahAsserts::_safe_oop, obj, !CompressedOops::is_null(fwd),
 165              &quot;Forwardee is set&quot;);
 166       check(ShenandoahAsserts::_safe_oop, obj, is_object_aligned(fwd),
 167              &quot;Forwardee must be aligned&quot;);
 168 
 169       // Do this before touching fwd-&gt;size()
 170       Klass* fwd_klass = fwd-&gt;klass_or_null();
 171       check(ShenandoahAsserts::_safe_oop, obj, fwd_klass != NULL,
 172              &quot;Forwardee klass pointer should not be NULL&quot;);
 173       check(ShenandoahAsserts::_safe_oop, obj, Metaspace::contains(fwd_klass),
 174              &quot;Forwardee klass pointer must go to metaspace&quot;);
 175       check(ShenandoahAsserts::_safe_oop, obj, obj_klass == fwd_klass,
 176              &quot;Forwardee klass pointer must go to metaspace&quot;);
 177 
 178       fwd_reg = _heap-&gt;heap_region_containing(fwd);
 179 
 180       // Verify that forwardee is not in the dead space:
 181       check(ShenandoahAsserts::_safe_oop, obj, !fwd_reg-&gt;is_humongous(),
 182              &quot;Should have no humongous forwardees&quot;);
 183 
 184       HeapWord *fwd_addr = cast_from_oop&lt;HeapWord *&gt;(fwd);
 185       check(ShenandoahAsserts::_safe_oop, obj, fwd_addr &lt; fwd_reg-&gt;top(),
 186              &quot;Forwardee start should be within the region&quot;);
 187       check(ShenandoahAsserts::_safe_oop, obj, (fwd_addr + fwd-&gt;size()) &lt;= fwd_reg-&gt;top(),
 188              &quot;Forwardee end should be within the region&quot;);
 189 
 190       oop fwd2 = (oop) ShenandoahForwarding::get_forwardee_raw_unchecked(fwd);
 191       check(ShenandoahAsserts::_safe_oop, obj, (fwd == fwd2),
 192              &quot;Double forwarding&quot;);
 193     } else {
 194       fwd_reg = obj_reg;
 195     }
 196 
 197     // ------------ obj and fwd are safe at this point --------------
 198 
 199     switch (_options._verify_marked) {
 200       case ShenandoahVerifier::_verify_marked_disable:
 201         // skip
 202         break;
 203       case ShenandoahVerifier::_verify_marked_incomplete:
 204         check(ShenandoahAsserts::_safe_all, obj, _heap-&gt;marking_context()-&gt;is_marked(obj),
 205                &quot;Must be marked in incomplete bitmap&quot;);
 206         break;
 207       case ShenandoahVerifier::_verify_marked_complete:
 208         check(ShenandoahAsserts::_safe_all, obj, _heap-&gt;complete_marking_context()-&gt;is_marked(obj),
 209                &quot;Must be marked in complete bitmap&quot;);
 210         break;
 211       default:
 212         assert(false, &quot;Unhandled mark verification&quot;);
 213     }
 214 
 215     switch (_options._verify_forwarded) {
 216       case ShenandoahVerifier::_verify_forwarded_disable:
 217         // skip
 218         break;
 219       case ShenandoahVerifier::_verify_forwarded_none: {
 220         check(ShenandoahAsserts::_safe_all, obj, (obj == fwd),
 221                &quot;Should not be forwarded&quot;);
 222         break;
 223       }
 224       case ShenandoahVerifier::_verify_forwarded_allow: {
 225         if (obj != fwd) {
 226           check(ShenandoahAsserts::_safe_all, obj, obj_reg != fwd_reg,
 227                  &quot;Forwardee should be in another region&quot;);
 228         }
 229         break;
 230       }
 231       default:
 232         assert(false, &quot;Unhandled forwarding verification&quot;);
 233     }
 234 
 235     switch (_options._verify_cset) {
 236       case ShenandoahVerifier::_verify_cset_disable:
 237         // skip
 238         break;
 239       case ShenandoahVerifier::_verify_cset_none:
 240         check(ShenandoahAsserts::_safe_all, obj, !_heap-&gt;in_collection_set(obj),
 241                &quot;Should not have references to collection set&quot;);
 242         break;
 243       case ShenandoahVerifier::_verify_cset_forwarded:
 244         if (_heap-&gt;in_collection_set(obj)) {
 245           check(ShenandoahAsserts::_safe_all, obj, (obj != fwd),
 246                  &quot;Object in collection set, should have forwardee&quot;);
 247         }
 248         break;
 249       default:
 250         assert(false, &quot;Unhandled cset verification&quot;);
 251     }
 252 
 253   }
 254 
 255 public:
 256   /**
 257    * Verify object with known interior reference.
 258    * @param p interior reference where the object is referenced from; can be off-heap
 259    * @param obj verified object
 260    */
 261   template &lt;class T&gt;
 262   void verify_oop_at(T* p, oop obj) {
 263     _interior_loc = p;
 264     verify_oop(obj);
 265     _interior_loc = NULL;
 266   }
 267 
 268   /**
 269    * Verify object without known interior reference.
 270    * Useful when picking up the object at known offset in heap,
 271    * but without knowing what objects reference it.
 272    * @param obj verified object
 273    */
 274   void verify_oop_standalone(oop obj) {
 275     _interior_loc = NULL;
 276     verify_oop(obj);
 277     _interior_loc = NULL;
 278   }
 279 
 280   /**
 281    * Verify oop fields from this object.
 282    * @param obj host object for verified fields
 283    */
 284   void verify_oops_from(oop obj) {
 285     _loc = obj;
 286     obj-&gt;oop_iterate(this);
 287     _loc = NULL;
 288   }
 289 
 290   virtual void do_oop(oop* p) { do_oop_work(p); }
 291   virtual void do_oop(narrowOop* p) { do_oop_work(p); }
 292 };
 293 
 294 class ShenandoahCalculateRegionStatsClosure : public ShenandoahHeapRegionClosure {
 295 private:
 296   size_t _used, _committed, _garbage;
 297 public:
 298   ShenandoahCalculateRegionStatsClosure() : _used(0), _committed(0), _garbage(0) {};
 299 
 300   void heap_region_do(ShenandoahHeapRegion* r) {
 301     _used += r-&gt;used();
 302     _garbage += r-&gt;garbage();
 303     _committed += r-&gt;is_committed() ? ShenandoahHeapRegion::region_size_bytes() : 0;
 304   }
 305 
 306   size_t used() { return _used; }
 307   size_t committed() { return _committed; }
 308   size_t garbage() { return _garbage; }
 309 };
 310 
 311 class ShenandoahVerifyHeapRegionClosure : public ShenandoahHeapRegionClosure {
 312 private:
 313   ShenandoahHeap* _heap;
 314   const char* _phase;
 315   ShenandoahVerifier::VerifyRegions _regions;
 316 public:
 317   ShenandoahVerifyHeapRegionClosure(const char* phase, ShenandoahVerifier::VerifyRegions regions) :
 318     _heap(ShenandoahHeap::heap()),
 319     _phase(phase),
 320     _regions(regions) {};
 321 
 322   void print_failure(ShenandoahHeapRegion* r, const char* label) {
 323     ResourceMark rm;
 324 
 325     ShenandoahMessageBuffer msg(&quot;Shenandoah verification failed; %s: %s\n\n&quot;, _phase, label);
 326 
 327     stringStream ss;
 328     r-&gt;print_on(&amp;ss);
 329     msg.append(&quot;%s&quot;, ss.as_string());
 330 
 331     report_vm_error(__FILE__, __LINE__, msg.buffer());
 332   }
 333 
 334   void verify(ShenandoahHeapRegion* r, bool test, const char* msg) {
 335     if (!test) {
 336       print_failure(r, msg);
 337     }
 338   }
 339 
 340   void heap_region_do(ShenandoahHeapRegion* r) {
 341     switch (_regions) {
 342       case ShenandoahVerifier::_verify_regions_disable:
 343         break;
 344       case ShenandoahVerifier::_verify_regions_notrash:
 345         verify(r, !r-&gt;is_trash(),
 346                &quot;Should not have trash regions&quot;);
 347         break;
 348       case ShenandoahVerifier::_verify_regions_nocset:
 349         verify(r, !r-&gt;is_cset(),
 350                &quot;Should not have cset regions&quot;);
 351         break;
 352       case ShenandoahVerifier::_verify_regions_notrash_nocset:
 353         verify(r, !r-&gt;is_trash(),
 354                &quot;Should not have trash regions&quot;);
 355         verify(r, !r-&gt;is_cset(),
 356                &quot;Should not have cset regions&quot;);
 357         break;
 358       default:
 359         ShouldNotReachHere();
 360     }
 361 
 362     verify(r, r-&gt;capacity() == ShenandoahHeapRegion::region_size_bytes(),
 363            &quot;Capacity should match region size&quot;);
 364 
 365     verify(r, r-&gt;bottom() &lt;= r-&gt;top(),
 366            &quot;Region top should not be less than bottom&quot;);
 367 
 368     verify(r, r-&gt;bottom() &lt;= _heap-&gt;marking_context()-&gt;top_at_mark_start(r),
 369            &quot;Region TAMS should not be less than bottom&quot;);
 370 
 371     verify(r, _heap-&gt;marking_context()-&gt;top_at_mark_start(r) &lt;= r-&gt;top(),
 372            &quot;Complete TAMS should not be larger than top&quot;);
 373 
 374     verify(r, r-&gt;get_live_data_bytes() &lt;= r-&gt;capacity(),
 375            &quot;Live data cannot be larger than capacity&quot;);
 376 
 377     verify(r, r-&gt;garbage() &lt;= r-&gt;capacity(),
 378            &quot;Garbage cannot be larger than capacity&quot;);
 379 
 380     verify(r, r-&gt;used() &lt;= r-&gt;capacity(),
 381            &quot;Used cannot be larger than capacity&quot;);
 382 
 383     verify(r, r-&gt;get_shared_allocs() &lt;= r-&gt;capacity(),
 384            &quot;Shared alloc count should not be larger than capacity&quot;);
 385 
 386     verify(r, r-&gt;get_tlab_allocs() &lt;= r-&gt;capacity(),
 387            &quot;TLAB alloc count should not be larger than capacity&quot;);
 388 
 389     verify(r, r-&gt;get_gclab_allocs() &lt;= r-&gt;capacity(),
 390            &quot;GCLAB alloc count should not be larger than capacity&quot;);
 391 
 392     verify(r, r-&gt;get_shared_allocs() + r-&gt;get_tlab_allocs() + r-&gt;get_gclab_allocs() == r-&gt;used(),
 393            &quot;Accurate accounting: shared + TLAB + GCLAB = used&quot;);
 394 
 395     verify(r, !r-&gt;is_empty() || !r-&gt;has_live(),
 396            &quot;Empty regions should not have live data&quot;);
 397 
 398     verify(r, r-&gt;is_cset() == _heap-&gt;collection_set()-&gt;is_in(r),
 399            &quot;Transitional: region flags and collection set agree&quot;);
<a name="4" id="anc4"></a>




















 400   }
 401 };
 402 
 403 class ShenandoahVerifierReachableTask : public AbstractGangTask {
 404 private:
 405   const char* _label;
 406   ShenandoahRootVerifier* _verifier;
 407   ShenandoahVerifier::VerifyOptions _options;
 408   ShenandoahHeap* _heap;
 409   ShenandoahLivenessData* _ld;
 410   MarkBitMap* _bitmap;
 411   volatile size_t _processed;
 412 
 413 public:
 414   ShenandoahVerifierReachableTask(MarkBitMap* bitmap,
 415                                   ShenandoahLivenessData* ld,
 416                                   ShenandoahRootVerifier* verifier,
 417                                   const char* label,
 418                                   ShenandoahVerifier::VerifyOptions options) :
 419     AbstractGangTask(&quot;Shenandoah Parallel Verifier Reachable Task&quot;),
 420     _label(label),
 421     _verifier(verifier),
 422     _options(options),
 423     _heap(ShenandoahHeap::heap()),
 424     _ld(ld),
 425     _bitmap(bitmap),
 426     _processed(0) {};
 427 
 428   size_t processed() {
 429     return _processed;
 430   }
 431 
 432   virtual void work(uint worker_id) {
 433     ResourceMark rm;
 434     ShenandoahVerifierStack stack;
 435 
 436     // On level 2, we need to only check the roots once.
 437     // On level 3, we want to check the roots, and seed the local stack.
 438     // It is a lesser evil to accept multiple root scans at level 3, because
 439     // extended parallelism would buy us out.
 440     if (((ShenandoahVerifyLevel == 2) &amp;&amp; (worker_id == 0))
 441         || (ShenandoahVerifyLevel &gt;= 3)) {
 442         ShenandoahVerifyOopClosure cl(&amp;stack, _bitmap, _ld,
 443                                       ShenandoahMessageBuffer(&quot;%s, Roots&quot;, _label),
 444                                       _options);
 445         if (_heap-&gt;unload_classes()) {
 446           _verifier-&gt;strong_roots_do(&amp;cl);
 447         } else {
 448           _verifier-&gt;roots_do(&amp;cl);
 449         }
 450     }
 451 
 452     size_t processed = 0;
 453 
 454     if (ShenandoahVerifyLevel &gt;= 3) {
 455       ShenandoahVerifyOopClosure cl(&amp;stack, _bitmap, _ld,
 456                                     ShenandoahMessageBuffer(&quot;%s, Reachable&quot;, _label),
 457                                     _options);
 458       while (!stack.is_empty()) {
 459         processed++;
 460         ShenandoahVerifierTask task = stack.pop();
 461         cl.verify_oops_from(task.obj());
 462       }
 463     }
 464 
 465     Atomic::add(&amp;_processed, processed);
 466   }
 467 };
 468 
 469 class ShenandoahVerifierMarkedRegionTask : public AbstractGangTask {
 470 private:
 471   const char* _label;
 472   ShenandoahVerifier::VerifyOptions _options;
 473   ShenandoahHeap *_heap;
 474   MarkBitMap* _bitmap;
 475   ShenandoahLivenessData* _ld;
 476   volatile size_t _claimed;
 477   volatile size_t _processed;
 478 
 479 public:
 480   ShenandoahVerifierMarkedRegionTask(MarkBitMap* bitmap,
 481                                      ShenandoahLivenessData* ld,
 482                                      const char* label,
 483                                      ShenandoahVerifier::VerifyOptions options) :
 484           AbstractGangTask(&quot;Shenandoah Parallel Verifier Marked Region&quot;),
 485           _label(label),
 486           _options(options),
 487           _heap(ShenandoahHeap::heap()),
 488           _bitmap(bitmap),
 489           _ld(ld),
 490           _claimed(0),
 491           _processed(0) {};
 492 
 493   size_t processed() {
 494     return _processed;
 495   }
 496 
 497   virtual void work(uint worker_id) {
 498     ShenandoahVerifierStack stack;
 499     ShenandoahVerifyOopClosure cl(&amp;stack, _bitmap, _ld,
 500                                   ShenandoahMessageBuffer(&quot;%s, Marked&quot;, _label),
 501                                   _options);
 502 
 503     while (true) {
 504       size_t v = Atomic::fetch_and_add(&amp;_claimed, 1u);
 505       if (v &lt; _heap-&gt;num_regions()) {
 506         ShenandoahHeapRegion* r = _heap-&gt;get_region(v);
 507         if (!r-&gt;is_humongous() &amp;&amp; !r-&gt;is_trash()) {
 508           work_regular(r, stack, cl);
 509         } else if (r-&gt;is_humongous_start()) {
 510           work_humongous(r, stack, cl);
 511         }
 512       } else {
 513         break;
 514       }
 515     }
 516   }
 517 
 518   virtual void work_humongous(ShenandoahHeapRegion *r, ShenandoahVerifierStack&amp; stack, ShenandoahVerifyOopClosure&amp; cl) {
 519     size_t processed = 0;
 520     HeapWord* obj = r-&gt;bottom();
 521     if (_heap-&gt;complete_marking_context()-&gt;is_marked((oop)obj)) {
 522       verify_and_follow(obj, stack, cl, &amp;processed);
 523     }
 524     Atomic::add(&amp;_processed, processed);
 525   }
 526 
 527   virtual void work_regular(ShenandoahHeapRegion *r, ShenandoahVerifierStack &amp;stack, ShenandoahVerifyOopClosure &amp;cl) {
 528     size_t processed = 0;
 529     MarkBitMap* mark_bit_map = _heap-&gt;complete_marking_context()-&gt;mark_bit_map();
 530     HeapWord* tams = _heap-&gt;complete_marking_context()-&gt;top_at_mark_start(r);
 531 
 532     // Bitmaps, before TAMS
 533     if (tams &gt; r-&gt;bottom()) {
 534       HeapWord* start = r-&gt;bottom();
 535       HeapWord* addr = mark_bit_map-&gt;get_next_marked_addr(start, tams);
 536 
 537       while (addr &lt; tams) {
 538         verify_and_follow(addr, stack, cl, &amp;processed);
 539         addr += 1;
 540         if (addr &lt; tams) {
 541           addr = mark_bit_map-&gt;get_next_marked_addr(addr, tams);
 542         }
 543       }
 544     }
 545 
 546     // Size-based, after TAMS
 547     {
 548       HeapWord* limit = r-&gt;top();
 549       HeapWord* addr = tams;
 550 
 551       while (addr &lt; limit) {
 552         verify_and_follow(addr, stack, cl, &amp;processed);
 553         addr += oop(addr)-&gt;size();
 554       }
 555     }
 556 
 557     Atomic::add(&amp;_processed, processed);
 558   }
 559 
 560   void verify_and_follow(HeapWord *addr, ShenandoahVerifierStack &amp;stack, ShenandoahVerifyOopClosure &amp;cl, size_t *processed) {
 561     if (!_bitmap-&gt;par_mark(addr)) return;
 562 
 563     // Verify the object itself:
 564     oop obj = oop(addr);
 565     cl.verify_oop_standalone(obj);
 566 
 567     // Verify everything reachable from that object too, hopefully realizing
 568     // everything was already marked, and never touching further:
 569     cl.verify_oops_from(obj);
 570     (*processed)++;
 571 
 572     while (!stack.is_empty()) {
 573       ShenandoahVerifierTask task = stack.pop();
 574       cl.verify_oops_from(task.obj());
 575       (*processed)++;
 576     }
 577   }
 578 };
 579 
 580 class VerifyThreadGCState : public ThreadClosure {
 581 private:
 582   const char* _label;
 583   char _expected;
 584 
 585 public:
 586   VerifyThreadGCState(const char* label, char expected) : _expected(expected) {}
 587   void do_thread(Thread* t) {
 588     char actual = ShenandoahThreadLocalData::gc_state(t);
 589     if (actual != _expected) {
 590       fatal(&quot;%s: Thread %s: expected gc-state %d, actual %d&quot;, _label, t-&gt;name(), _expected, actual);
 591     }
 592   }
 593 };
 594 
 595 class ShenandoahGCStateResetter : public StackObj {
 596 private:
 597   ShenandoahHeap* const _heap;
 598   char _gc_state;
 599 
 600 public:
 601   ShenandoahGCStateResetter() : _heap(ShenandoahHeap::heap()) {
 602     _gc_state = _heap-&gt;gc_state();
 603     _heap-&gt;_gc_state.clear();
 604   }
 605 
 606   ~ShenandoahGCStateResetter() {
 607     _heap-&gt;_gc_state.set(_gc_state);
 608     assert(_heap-&gt;gc_state() == _gc_state, &quot;Should be restored&quot;);
 609   }
 610 };
 611 
 612 void ShenandoahVerifier::verify_at_safepoint(const char *label,
 613                                              VerifyForwarded forwarded, VerifyMarked marked,
 614                                              VerifyCollectionSet cset,
 615                                              VerifyLiveness liveness, VerifyRegions regions,
 616                                              VerifyGCState gcstate,
 617                                              VerifyWeakRoots weak_roots) {
 618   guarantee(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;only when nothing else happens&quot;);
 619   guarantee(ShenandoahVerify, &quot;only when enabled, and bitmap is initialized in ShenandoahHeap::initialize&quot;);
 620 
 621   // Avoid side-effect of changing workers&#39; active thread count, but bypass concurrent/parallel protocol check
 622   ShenandoahPushWorkerScope verify_worker_scope(_heap-&gt;workers(), _heap-&gt;max_workers(), false /*bypass check*/);
 623 
 624   log_info(gc,start)(&quot;Verify %s, Level &quot; INTX_FORMAT, label, ShenandoahVerifyLevel);
 625 
 626   // GC state checks
 627   {
 628     char expected = -1;
 629     bool enabled;
 630     switch (gcstate) {
 631       case _verify_gcstate_disable:
 632         enabled = false;
 633         break;
 634       case _verify_gcstate_forwarded:
 635         enabled = true;
 636         expected = ShenandoahHeap::HAS_FORWARDED;
 637         break;
 638       case _verify_gcstate_evacuation:
 639         enabled = true;
 640         expected = ShenandoahHeap::HAS_FORWARDED | ShenandoahHeap::EVACUATION;
 641         break;
 642       case _verify_gcstate_stable:
 643         enabled = true;
 644         expected = ShenandoahHeap::STABLE;
 645         break;
 646       default:
 647         enabled = false;
 648         assert(false, &quot;Unhandled gc-state verification&quot;);
 649     }
 650 
 651     if (enabled) {
 652       char actual = _heap-&gt;gc_state();
 653       if (actual != expected) {
 654         fatal(&quot;%s: Global gc-state: expected %d, actual %d&quot;, label, expected, actual);
 655       }
 656 
 657       VerifyThreadGCState vtgcs(label, expected);
 658       Threads::java_threads_do(&amp;vtgcs);
 659     }
 660   }
 661 
 662   // Deactivate barriers temporarily: Verifier wants plain heap accesses
 663   ShenandoahGCStateResetter resetter;
 664 
 665   // Heap size checks
 666   {
 667     ShenandoahHeapLocker lock(_heap-&gt;lock());
 668 
 669     ShenandoahCalculateRegionStatsClosure cl;
 670     _heap-&gt;heap_region_iterate(&amp;cl);
 671     size_t heap_used = _heap-&gt;used();
 672     guarantee(cl.used() == heap_used,
 673               &quot;%s: heap used size must be consistent: heap-used = &quot; SIZE_FORMAT &quot;%s, regions-used = &quot; SIZE_FORMAT &quot;%s&quot;,
 674               label,
 675               byte_size_in_proper_unit(heap_used), proper_unit_for_byte_size(heap_used),
 676               byte_size_in_proper_unit(cl.used()), proper_unit_for_byte_size(cl.used()));
 677 
 678     size_t heap_committed = _heap-&gt;committed();
 679     guarantee(cl.committed() == heap_committed,
 680               &quot;%s: heap committed size must be consistent: heap-committed = &quot; SIZE_FORMAT &quot;%s, regions-committed = &quot; SIZE_FORMAT &quot;%s&quot;,
 681               label,
 682               byte_size_in_proper_unit(heap_committed), proper_unit_for_byte_size(heap_committed),
 683               byte_size_in_proper_unit(cl.committed()), proper_unit_for_byte_size(cl.committed()));
 684   }
 685 
 686   // Internal heap region checks
 687   if (ShenandoahVerifyLevel &gt;= 1) {
 688     ShenandoahVerifyHeapRegionClosure cl(label, regions);
 689     _heap-&gt;heap_region_iterate(&amp;cl);
 690   }
 691 
 692   OrderAccess::fence();
 693   _heap-&gt;make_parsable(false);
 694 
 695   // Allocate temporary bitmap for storing marking wavefront:
 696   _verification_bit_map-&gt;clear();
 697 
 698   // Allocate temporary array for storing liveness data
 699   ShenandoahLivenessData* ld = NEW_C_HEAP_ARRAY(ShenandoahLivenessData, _heap-&gt;num_regions(), mtGC);
 700   Copy::fill_to_bytes((void*)ld, _heap-&gt;num_regions()*sizeof(ShenandoahLivenessData), 0);
 701 
 702   const VerifyOptions&amp; options = ShenandoahVerifier::VerifyOptions(forwarded, marked, cset, liveness, regions, gcstate);
 703 
 704   // Steps 1-2. Scan root set to get initial reachable set. Finish walking the reachable heap.
 705   // This verifies what application can see, since it only cares about reachable objects.
 706   size_t count_reachable = 0;
 707   if (ShenandoahVerifyLevel &gt;= 2) {
 708     ShenandoahRootVerifier verifier;
 709     switch (weak_roots) {
 710       case _verify_serial_weak_roots:
 711         verifier.excludes(ShenandoahRootVerifier::ConcurrentWeakRoots);
 712         break;
 713       case _verify_concurrent_weak_roots:
 714         verifier.excludes(ShenandoahRootVerifier::SerialWeakRoots);
 715         break;
 716       case _verify_all_weak_roots:
 717         break;
 718       default:
 719         ShouldNotReachHere();
 720     }
 721 
 722     ShenandoahVerifierReachableTask task(_verification_bit_map, ld, &amp;verifier, label, options);
 723     _heap-&gt;workers()-&gt;run_task(&amp;task);
 724     count_reachable = task.processed();
 725   }
 726 
 727   // Step 3. Walk marked objects. Marked objects might be unreachable. This verifies what collector,
 728   // not the application, can see during the region scans. There is no reason to process the objects
 729   // that were already verified, e.g. those marked in verification bitmap. There is interaction with TAMS:
 730   // before TAMS, we verify the bitmaps, if available; after TAMS, we walk until the top(). It mimics
 731   // what marked_object_iterate is doing, without calling into that optimized (and possibly incorrect)
 732   // version
 733 
 734   size_t count_marked = 0;
 735   if (ShenandoahVerifyLevel &gt;= 4 &amp;&amp; marked == _verify_marked_complete) {
 736     guarantee(_heap-&gt;marking_context()-&gt;is_complete(), &quot;Marking context should be complete&quot;);
 737     ShenandoahVerifierMarkedRegionTask task(_verification_bit_map, ld, label, options);
 738     _heap-&gt;workers()-&gt;run_task(&amp;task);
 739     count_marked = task.processed();
 740   } else {
 741     guarantee(ShenandoahVerifyLevel &lt; 4 || marked == _verify_marked_incomplete || marked == _verify_marked_disable, &quot;Should be&quot;);
 742   }
 743 
 744   // Step 4. Verify accumulated liveness data, if needed. Only reliable if verification level includes
 745   // marked objects.
 746 
 747   if (ShenandoahVerifyLevel &gt;= 4 &amp;&amp; marked == _verify_marked_complete &amp;&amp; liveness == _verify_liveness_complete) {
 748     for (size_t i = 0; i &lt; _heap-&gt;num_regions(); i++) {
 749       ShenandoahHeapRegion* r = _heap-&gt;get_region(i);
 750 
 751       juint verf_live = 0;
 752       if (r-&gt;is_humongous()) {
 753         // For humongous objects, test if start region is marked live, and if so,
 754         // all humongous regions in that chain have live data equal to their &quot;used&quot;.
<a name="5" id="anc5"></a><span class="line-modified"> 755         juint start_live = Atomic::load_acquire(&amp;ld[r-&gt;humongous_start_region()-&gt;index()]);</span>
 756         if (start_live &gt; 0) {
 757           verf_live = (juint)(r-&gt;used() / HeapWordSize);
 758         }
 759       } else {
<a name="6" id="anc6"></a><span class="line-modified"> 760         verf_live = Atomic::load_acquire(&amp;ld[r-&gt;index()]);</span>
 761       }
 762 
 763       size_t reg_live = r-&gt;get_live_data_words();
 764       if (reg_live != verf_live) {
 765         ResourceMark rm;
 766         stringStream ss;
 767         r-&gt;print_on(&amp;ss);
 768         fatal(&quot;%s: Live data should match: region-live = &quot; SIZE_FORMAT &quot;, verifier-live = &quot; UINT32_FORMAT &quot;\n%s&quot;,
 769               label, reg_live, verf_live, ss.as_string());
 770       }
 771     }
 772   }
 773 
 774   log_info(gc)(&quot;Verify %s, Level &quot; INTX_FORMAT &quot; (&quot; SIZE_FORMAT &quot; reachable, &quot; SIZE_FORMAT &quot; marked)&quot;,
 775                label, ShenandoahVerifyLevel, count_reachable, count_marked);
 776 
 777   FREE_C_HEAP_ARRAY(ShenandoahLivenessData, ld);
 778 }
 779 
 780 void ShenandoahVerifier::verify_generic(VerifyOption vo) {
 781   verify_at_safepoint(
 782           &quot;Generic Verification&quot;,
 783           _verify_forwarded_allow,     // conservatively allow forwarded
 784           _verify_marked_disable,      // do not verify marked: lots ot time wasted checking dead allocations
 785           _verify_cset_disable,        // cset may be inconsistent
 786           _verify_liveness_disable,    // no reliable liveness data
 787           _verify_regions_disable,     // no reliable region data
 788           _verify_gcstate_disable,     // no data about gcstate
 789           _verify_all_weak_roots
 790   );
 791 }
 792 
 793 void ShenandoahVerifier::verify_before_concmark() {
<a name="7" id="anc7"></a>
 794     verify_at_safepoint(
<a name="8" id="anc8"></a><span class="line-modified"> 795           &quot;Before Mark&quot;,</span>
<span class="line-modified"> 796           _verify_forwarded_none,      // UR should have fixed up</span>
<span class="line-modified"> 797           _verify_marked_disable,      // do not verify marked: lots ot time wasted checking dead allocations</span>
<span class="line-modified"> 798           _verify_cset_none,           // UR should have fixed this</span>
<span class="line-modified"> 799           _verify_liveness_disable,    // no reliable liveness data</span>
<span class="line-modified"> 800           _verify_regions_notrash,     // no trash regions</span>
<span class="line-modified"> 801           _verify_gcstate_stable,      // there are no forwarded objects</span>
<span class="line-modified"> 802           _verify_all_weak_roots</span>
<span class="line-modified"> 803   );</span>












 804 }
 805 
 806 void ShenandoahVerifier::verify_after_concmark() {
 807   verify_at_safepoint(
 808           &quot;After Mark&quot;,
 809           _verify_forwarded_none,      // no forwarded references
 810           _verify_marked_complete,     // bitmaps as precise as we can get
 811           _verify_cset_none,           // no references to cset anymore
 812           _verify_liveness_complete,   // liveness data must be complete here
 813           _verify_regions_disable,     // trash regions not yet recycled
 814           _verify_gcstate_stable,       // mark should have stabilized the heap
 815           _verify_all_weak_roots
 816   );
 817 }
 818 
 819 void ShenandoahVerifier::verify_before_evacuation() {
 820   // Concurrent weak roots are evacuated during concurrent phase
 821   VerifyWeakRoots verify_weak_roots = ShenandoahConcurrentRoots::should_do_concurrent_class_unloading() ?
 822                                       _verify_serial_weak_roots :
 823                                       _verify_all_weak_roots;
 824 
 825   verify_at_safepoint(
 826           &quot;Before Evacuation&quot;,
 827           _verify_forwarded_none,    // no forwarded references
 828           _verify_marked_complete,   // walk over marked objects too
 829           _verify_cset_disable,      // non-forwarded references to cset expected
 830           _verify_liveness_complete, // liveness data must be complete here
 831           _verify_regions_disable,   // trash regions not yet recycled
 832           _verify_gcstate_stable,    // mark should have stabilized the heap
 833           verify_weak_roots
 834   );
 835 }
 836 
 837 void ShenandoahVerifier::verify_during_evacuation() {
 838   // Concurrent weak roots are evacuated during concurrent phase
 839   VerifyWeakRoots verify_weak_roots = ShenandoahConcurrentRoots::should_do_concurrent_class_unloading() ?
 840                                       _verify_serial_weak_roots :
 841                                       _verify_all_weak_roots;
 842 
 843   verify_at_safepoint(
 844           &quot;During Evacuation&quot;,
 845           _verify_forwarded_allow,    // some forwarded references are allowed
 846           _verify_marked_disable,     // walk only roots
 847           _verify_cset_disable,       // some cset references are not forwarded yet
 848           _verify_liveness_disable,   // liveness data might be already stale after pre-evacs
 849           _verify_regions_disable,    // trash regions not yet recycled
 850           _verify_gcstate_evacuation, // evacuation is in progress
 851           verify_weak_roots
 852   );
 853 }
 854 
 855 void ShenandoahVerifier::verify_after_evacuation() {
 856   verify_at_safepoint(
 857           &quot;After Evacuation&quot;,
 858           _verify_forwarded_allow,     // objects are still forwarded
 859           _verify_marked_complete,     // bitmaps might be stale, but alloc-after-mark should be well
 860           _verify_cset_forwarded,      // all cset refs are fully forwarded
 861           _verify_liveness_disable,    // no reliable liveness data anymore
 862           _verify_regions_notrash,     // trash regions have been recycled already
 863           _verify_gcstate_forwarded,   // evacuation produced some forwarded objects
 864           _verify_all_weak_roots
 865   );
 866 }
 867 
 868 void ShenandoahVerifier::verify_before_updaterefs() {
 869   verify_at_safepoint(
 870           &quot;Before Updating References&quot;,
 871           _verify_forwarded_allow,     // forwarded references allowed
 872           _verify_marked_complete,     // bitmaps might be stale, but alloc-after-mark should be well
 873           _verify_cset_forwarded,      // all cset refs are fully forwarded
 874           _verify_liveness_disable,    // no reliable liveness data anymore
 875           _verify_regions_notrash,     // trash regions have been recycled already
 876           _verify_gcstate_forwarded,   // evacuation should have produced some forwarded objects
 877           _verify_all_weak_roots
 878   );
 879 }
 880 
 881 void ShenandoahVerifier::verify_after_updaterefs() {
 882   verify_at_safepoint(
 883           &quot;After Updating References&quot;,
 884           _verify_forwarded_none,      // no forwarded references
 885           _verify_marked_complete,     // bitmaps might be stale, but alloc-after-mark should be well
 886           _verify_cset_none,           // no cset references, all updated
 887           _verify_liveness_disable,    // no reliable liveness data anymore
 888           _verify_regions_nocset,      // no cset regions, trash regions have appeared
 889           _verify_gcstate_stable,      // update refs had cleaned up forwarded objects
 890           _verify_all_weak_roots
 891   );
 892 }
 893 
 894 void ShenandoahVerifier::verify_after_degenerated() {
 895   verify_at_safepoint(
 896           &quot;After Degenerated GC&quot;,
 897           _verify_forwarded_none,      // all objects are non-forwarded
 898           _verify_marked_complete,     // all objects are marked in complete bitmap
 899           _verify_cset_none,           // no cset references
 900           _verify_liveness_disable,    // no reliable liveness data anymore
 901           _verify_regions_notrash_nocset, // no trash, no cset
 902           _verify_gcstate_stable,       // degenerated refs had cleaned up forwarded objects
 903           _verify_all_weak_roots
 904   );
 905 }
 906 
<a name="9" id="anc9"></a>

























 907 void ShenandoahVerifier::verify_before_fullgc() {
 908   verify_at_safepoint(
 909           &quot;Before Full GC&quot;,
 910           _verify_forwarded_allow,     // can have forwarded objects
 911           _verify_marked_disable,      // do not verify marked: lots ot time wasted checking dead allocations
 912           _verify_cset_disable,        // cset might be foobared
 913           _verify_liveness_disable,    // no reliable liveness data anymore
 914           _verify_regions_disable,     // no reliable region data here
 915           _verify_gcstate_disable,     // no reliable gcstate data
 916           _verify_all_weak_roots
 917   );
 918 }
 919 
 920 void ShenandoahVerifier::verify_after_fullgc() {
 921   verify_at_safepoint(
 922           &quot;After Full GC&quot;,
 923           _verify_forwarded_none,      // all objects are non-forwarded
 924           _verify_marked_complete,     // all objects are marked in complete bitmap
 925           _verify_cset_none,           // no cset references
 926           _verify_liveness_disable,    // no reliable liveness data anymore
 927           _verify_regions_notrash_nocset, // no trash, no cset
 928           _verify_gcstate_stable,       // full gc cleaned up everything
 929           _verify_all_weak_roots
 930   );
 931 }
 932 
 933 class ShenandoahVerifyNoForwared : public OopClosure {
 934 private:
 935   template &lt;class T&gt;
 936   void do_oop_work(T* p) {
 937     T o = RawAccess&lt;&gt;::oop_load(p);
 938     if (!CompressedOops::is_null(o)) {
 939       oop obj = CompressedOops::decode_not_null(o);
 940       oop fwd = (oop) ShenandoahForwarding::get_forwardee_raw_unchecked(obj);
 941       if (obj != fwd) {
 942         ShenandoahAsserts::print_failure(ShenandoahAsserts::_safe_all, obj, p, NULL,
 943                                          &quot;Verify Roots&quot;, &quot;Should not be forwarded&quot;, __FILE__, __LINE__);
 944       }
 945     }
 946   }
 947 
 948 public:
 949   void do_oop(narrowOop* p) { do_oop_work(p); }
 950   void do_oop(oop* p)       { do_oop_work(p); }
 951 };
 952 
 953 class ShenandoahVerifyInToSpaceClosure : public OopClosure {
 954 private:
 955   template &lt;class T&gt;
 956   void do_oop_work(T* p) {
 957     T o = RawAccess&lt;&gt;::oop_load(p);
 958     if (!CompressedOops::is_null(o)) {
 959       oop obj = CompressedOops::decode_not_null(o);
<a name="10" id="anc10"></a><span class="line-modified"> 960       ShenandoahHeap* heap = ShenandoahHeap::heap();</span>
 961 
 962       if (!heap-&gt;marking_context()-&gt;is_marked(obj)) {
 963         ShenandoahAsserts::print_failure(ShenandoahAsserts::_safe_all, obj, p, NULL,
 964                 &quot;Verify Roots In To-Space&quot;, &quot;Should be marked&quot;, __FILE__, __LINE__);
 965       }
 966 
 967       if (heap-&gt;in_collection_set(obj)) {
 968         ShenandoahAsserts::print_failure(ShenandoahAsserts::_safe_all, obj, p, NULL,
 969                 &quot;Verify Roots In To-Space&quot;, &quot;Should not be in collection set&quot;, __FILE__, __LINE__);
 970       }
 971 
 972       oop fwd = (oop) ShenandoahForwarding::get_forwardee_raw_unchecked(obj);
 973       if (obj != fwd) {
 974         ShenandoahAsserts::print_failure(ShenandoahAsserts::_safe_all, obj, p, NULL,
 975                 &quot;Verify Roots In To-Space&quot;, &quot;Should not be forwarded&quot;, __FILE__, __LINE__);
 976       }
 977     }
 978   }
 979 
 980 public:
 981   void do_oop(narrowOop* p) { do_oop_work(p); }
 982   void do_oop(oop* p)       { do_oop_work(p); }
 983 };
 984 
 985 void ShenandoahVerifier::verify_roots_in_to_space() {
 986   ShenandoahRootVerifier verifier;
 987   ShenandoahVerifyInToSpaceClosure cl;
 988   verifier.oops_do(&amp;cl);
 989 }
 990 
 991 void ShenandoahVerifier::verify_roots_in_to_space_except(ShenandoahRootVerifier::RootTypes types) {
 992   ShenandoahRootVerifier verifier;
 993   verifier.excludes(types);
 994   ShenandoahVerifyInToSpaceClosure cl;
 995   verifier.oops_do(&amp;cl);
 996 }
 997 
 998 void ShenandoahVerifier::verify_roots_no_forwarded() {
 999   ShenandoahRootVerifier verifier;
1000   ShenandoahVerifyNoForwared cl;
1001   verifier.oops_do(&amp;cl);
1002 }
1003 
1004 void ShenandoahVerifier::verify_roots_no_forwarded_except(ShenandoahRootVerifier::RootTypes types) {
1005   ShenandoahRootVerifier verifier;
1006   verifier.excludes(types);
1007   ShenandoahVerifyNoForwared cl;
1008   verifier.oops_do(&amp;cl);
1009 }
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/shenandoah/shenandoahHeapRegion.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahHeap.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahHeapRegion.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahHeapRegion.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 26,11 ***</span>
  #include &quot;memory/allocation.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahHeapRegionSet.inline.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahHeapRegion.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahMarkingContext.inline.hpp&quot;
<span class="line-removed">- #include &quot;gc/shenandoah/shenandoahTraversalGC.hpp&quot;</span>
  #include &quot;gc/shared/space.inline.hpp&quot;
  #include &quot;jfr/jfrEvents.hpp&quot;
  #include &quot;memory/iterator.inline.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;memory/universe.hpp&quot;
<span class="line-new-header">--- 26,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 51,35 ***</span>
  size_t ShenandoahHeapRegion::HumongousThresholdBytes = 0;
  size_t ShenandoahHeapRegion::HumongousThresholdWords = 0;
  size_t ShenandoahHeapRegion::MaxTLABSizeBytes = 0;
  size_t ShenandoahHeapRegion::MaxTLABSizeWords = 0;
  
<span class="line-modified">! ShenandoahHeapRegion::PaddedAllocSeqNum ShenandoahHeapRegion::_alloc_seq_num;</span>
<span class="line-modified">! </span>
<span class="line-modified">! ShenandoahHeapRegion::ShenandoahHeapRegion(ShenandoahHeap* heap, HeapWord* start,</span>
<span class="line-modified">!                                            size_t size_words, size_t index, bool committed) :</span>
<span class="line-removed">-   _heap(heap),</span>
<span class="line-removed">-   _reserved(MemRegion(start, size_words)),</span>
<span class="line-removed">-   _region_number(index),</span>
    _new_top(NULL),
    _empty_time(os::elapsedTime()),
    _state(committed ? _empty_committed : _empty_uncommitted),
    _tlab_allocs(0),
    _gclab_allocs(0),
<span class="line-removed">-   _shared_allocs(0),</span>
<span class="line-removed">-   _seqnum_first_alloc_mutator(0),</span>
<span class="line-removed">-   _seqnum_first_alloc_gc(0),</span>
<span class="line-removed">-   _seqnum_last_alloc_mutator(0),</span>
<span class="line-removed">-   _seqnum_last_alloc_gc(0),</span>
    _live_data(0),
<span class="line-modified">!   _critical_pins(0) {</span>
<span class="line-modified">! </span>
<span class="line-removed">-   ContiguousSpace::initialize(_reserved, true, committed);</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! size_t ShenandoahHeapRegion::region_number() const {</span>
<span class="line-modified">!   return _region_number;</span>
  }
  
  void ShenandoahHeapRegion::report_illegal_transition(const char *method) {
    ResourceMark rm;
    stringStream ss;
<span class="line-new-header">--- 50,29 ---</span>
  size_t ShenandoahHeapRegion::HumongousThresholdBytes = 0;
  size_t ShenandoahHeapRegion::HumongousThresholdWords = 0;
  size_t ShenandoahHeapRegion::MaxTLABSizeBytes = 0;
  size_t ShenandoahHeapRegion::MaxTLABSizeWords = 0;
  
<span class="line-modified">! ShenandoahHeapRegion::ShenandoahHeapRegion(HeapWord* start, size_t index, bool committed) :</span>
<span class="line-modified">!   _index(index),</span>
<span class="line-modified">!   _bottom(start),</span>
<span class="line-modified">!   _end(start + RegionSizeWords),</span>
    _new_top(NULL),
    _empty_time(os::elapsedTime()),
    _state(committed ? _empty_committed : _empty_uncommitted),
<span class="line-added">+   _top(start),</span>
    _tlab_allocs(0),
    _gclab_allocs(0),
    _live_data(0),
<span class="line-modified">!   _critical_pins(0),</span>
<span class="line-modified">!   _update_watermark(start) {</span>
  
<span class="line-modified">!   assert(Universe::on_page_boundary(_bottom) &amp;&amp; Universe::on_page_boundary(_end),</span>
<span class="line-modified">!          &quot;invalid space boundaries&quot;);</span>
<span class="line-added">+   if (ZapUnusedHeapArea &amp;&amp; committed) {</span>
<span class="line-added">+     SpaceMangler::mangle_region(MemRegion(_bottom, _end));</span>
<span class="line-added">+   }</span>
  }
  
  void ShenandoahHeapRegion::report_illegal_transition(const char *method) {
    ResourceMark rm;
    stringStream ss;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 87,11 ***</span>
    print_on(&amp;ss);
    fatal(&quot;%s&quot;, ss.as_string());
  }
  
  void ShenandoahHeapRegion::make_regular_allocation() {
<span class="line-modified">!   _heap-&gt;assert_heaplock_owned_by_current_thread();</span>
  
    switch (_state) {
      case _empty_uncommitted:
        do_commit();
      case _empty_committed:
<span class="line-new-header">--- 80,11 ---</span>
    print_on(&amp;ss);
    fatal(&quot;%s&quot;, ss.as_string());
  }
  
  void ShenandoahHeapRegion::make_regular_allocation() {
<span class="line-modified">!   shenandoah_assert_heaplocked();</span>
  
    switch (_state) {
      case _empty_uncommitted:
        do_commit();
      case _empty_committed:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 103,12 ***</span>
        report_illegal_transition(&quot;regular allocation&quot;);
    }
  }
  
  void ShenandoahHeapRegion::make_regular_bypass() {
<span class="line-modified">!   _heap-&gt;assert_heaplock_owned_by_current_thread();</span>
<span class="line-modified">!   assert (_heap-&gt;is_full_gc_in_progress() || _heap-&gt;is_degenerated_gc_in_progress(),</span>
            &quot;only for full or degen GC&quot;);
  
    switch (_state) {
      case _empty_uncommitted:
        do_commit();
<span class="line-new-header">--- 96,12 ---</span>
        report_illegal_transition(&quot;regular allocation&quot;);
    }
  }
  
  void ShenandoahHeapRegion::make_regular_bypass() {
<span class="line-modified">!   shenandoah_assert_heaplocked();</span>
<span class="line-modified">!   assert (ShenandoahHeap::heap()-&gt;is_full_gc_in_progress() || ShenandoahHeap::heap()-&gt;is_degenerated_gc_in_progress(),</span>
            &quot;only for full or degen GC&quot;);
  
    switch (_state) {
      case _empty_uncommitted:
        do_commit();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 128,11 ***</span>
        report_illegal_transition(&quot;regular bypass&quot;);
    }
  }
  
  void ShenandoahHeapRegion::make_humongous_start() {
<span class="line-modified">!   _heap-&gt;assert_heaplock_owned_by_current_thread();</span>
    switch (_state) {
      case _empty_uncommitted:
        do_commit();
      case _empty_committed:
        set_state(_humongous_start);
<span class="line-new-header">--- 121,11 ---</span>
        report_illegal_transition(&quot;regular bypass&quot;);
    }
  }
  
  void ShenandoahHeapRegion::make_humongous_start() {
<span class="line-modified">!   shenandoah_assert_heaplocked();</span>
    switch (_state) {
      case _empty_uncommitted:
        do_commit();
      case _empty_committed:
        set_state(_humongous_start);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 141,12 ***</span>
        report_illegal_transition(&quot;humongous start allocation&quot;);
    }
  }
  
  void ShenandoahHeapRegion::make_humongous_start_bypass() {
<span class="line-modified">!   _heap-&gt;assert_heaplock_owned_by_current_thread();</span>
<span class="line-modified">!   assert (_heap-&gt;is_full_gc_in_progress(), &quot;only for full GC&quot;);</span>
  
    switch (_state) {
      case _empty_committed:
      case _regular:
      case _humongous_start:
<span class="line-new-header">--- 134,12 ---</span>
        report_illegal_transition(&quot;humongous start allocation&quot;);
    }
  }
  
  void ShenandoahHeapRegion::make_humongous_start_bypass() {
<span class="line-modified">!   shenandoah_assert_heaplocked();</span>
<span class="line-modified">!   assert (ShenandoahHeap::heap()-&gt;is_full_gc_in_progress(), &quot;only for full GC&quot;);</span>
  
    switch (_state) {
      case _empty_committed:
      case _regular:
      case _humongous_start:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 157,11 ***</span>
        report_illegal_transition(&quot;humongous start bypass&quot;);
    }
  }
  
  void ShenandoahHeapRegion::make_humongous_cont() {
<span class="line-modified">!   _heap-&gt;assert_heaplock_owned_by_current_thread();</span>
    switch (_state) {
      case _empty_uncommitted:
        do_commit();
      case _empty_committed:
       set_state(_humongous_cont);
<span class="line-new-header">--- 150,11 ---</span>
        report_illegal_transition(&quot;humongous start bypass&quot;);
    }
  }
  
  void ShenandoahHeapRegion::make_humongous_cont() {
<span class="line-modified">!   shenandoah_assert_heaplocked();</span>
    switch (_state) {
      case _empty_uncommitted:
        do_commit();
      case _empty_committed:
       set_state(_humongous_cont);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 170,12 ***</span>
        report_illegal_transition(&quot;humongous continuation allocation&quot;);
    }
  }
  
  void ShenandoahHeapRegion::make_humongous_cont_bypass() {
<span class="line-modified">!   _heap-&gt;assert_heaplock_owned_by_current_thread();</span>
<span class="line-modified">!   assert (_heap-&gt;is_full_gc_in_progress(), &quot;only for full GC&quot;);</span>
  
    switch (_state) {
      case _empty_committed:
      case _regular:
      case _humongous_start:
<span class="line-new-header">--- 163,12 ---</span>
        report_illegal_transition(&quot;humongous continuation allocation&quot;);
    }
  }
  
  void ShenandoahHeapRegion::make_humongous_cont_bypass() {
<span class="line-modified">!   shenandoah_assert_heaplocked();</span>
<span class="line-modified">!   assert (ShenandoahHeap::heap()-&gt;is_full_gc_in_progress(), &quot;only for full GC&quot;);</span>
  
    switch (_state) {
      case _empty_committed:
      case _regular:
      case _humongous_start:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 186,11 ***</span>
        report_illegal_transition(&quot;humongous continuation bypass&quot;);
    }
  }
  
  void ShenandoahHeapRegion::make_pinned() {
<span class="line-modified">!   _heap-&gt;assert_heaplock_owned_by_current_thread();</span>
    assert(pin_count() &gt; 0, &quot;Should have pins: &quot; SIZE_FORMAT, pin_count());
  
    switch (_state) {
      case _regular:
        set_state(_pinned);
<span class="line-new-header">--- 179,11 ---</span>
        report_illegal_transition(&quot;humongous continuation bypass&quot;);
    }
  }
  
  void ShenandoahHeapRegion::make_pinned() {
<span class="line-modified">!   shenandoah_assert_heaplocked();</span>
    assert(pin_count() &gt; 0, &quot;Should have pins: &quot; SIZE_FORMAT, pin_count());
  
    switch (_state) {
      case _regular:
        set_state(_pinned);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 208,11 ***</span>
        report_illegal_transition(&quot;pinning&quot;);
    }
  }
  
  void ShenandoahHeapRegion::make_unpinned() {
<span class="line-modified">!   _heap-&gt;assert_heaplock_owned_by_current_thread();</span>
    assert(pin_count() == 0, &quot;Should not have pins: &quot; SIZE_FORMAT, pin_count());
  
    switch (_state) {
      case _pinned:
        set_state(_regular);
<span class="line-new-header">--- 201,11 ---</span>
        report_illegal_transition(&quot;pinning&quot;);
    }
  }
  
  void ShenandoahHeapRegion::make_unpinned() {
<span class="line-modified">!   shenandoah_assert_heaplocked();</span>
    assert(pin_count() == 0, &quot;Should not have pins: &quot; SIZE_FORMAT, pin_count());
  
    switch (_state) {
      case _pinned:
        set_state(_regular);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 230,11 ***</span>
        report_illegal_transition(&quot;unpinning&quot;);
    }
  }
  
  void ShenandoahHeapRegion::make_cset() {
<span class="line-modified">!   _heap-&gt;assert_heaplock_owned_by_current_thread();</span>
    switch (_state) {
      case _regular:
        set_state(_cset);
      case _cset:
        return;
<span class="line-new-header">--- 223,11 ---</span>
        report_illegal_transition(&quot;unpinning&quot;);
    }
  }
  
  void ShenandoahHeapRegion::make_cset() {
<span class="line-modified">!   shenandoah_assert_heaplocked();</span>
    switch (_state) {
      case _regular:
        set_state(_cset);
      case _cset:
        return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 242,11 ***</span>
        report_illegal_transition(&quot;cset&quot;);
    }
  }
  
  void ShenandoahHeapRegion::make_trash() {
<span class="line-modified">!   _heap-&gt;assert_heaplock_owned_by_current_thread();</span>
    switch (_state) {
      case _cset:
        // Reclaiming cset regions
      case _humongous_start:
      case _humongous_cont:
<span class="line-new-header">--- 235,11 ---</span>
        report_illegal_transition(&quot;cset&quot;);
    }
  }
  
  void ShenandoahHeapRegion::make_trash() {
<span class="line-modified">!   shenandoah_assert_heaplocked();</span>
    switch (_state) {
      case _cset:
        // Reclaiming cset regions
      case _humongous_start:
      case _humongous_cont:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 263,15 ***</span>
  void ShenandoahHeapRegion::make_trash_immediate() {
    make_trash();
  
    // On this path, we know there are no marked objects in the region,
    // tell marking context about it to bypass bitmap resets.
<span class="line-modified">!   _heap-&gt;complete_marking_context()-&gt;reset_top_bitmap(this);</span>
  }
  
  void ShenandoahHeapRegion::make_empty() {
<span class="line-modified">!   _heap-&gt;assert_heaplock_owned_by_current_thread();</span>
    switch (_state) {
      case _trash:
        set_state(_empty_committed);
        _empty_time = os::elapsedTime();
        return;
<span class="line-new-header">--- 256,15 ---</span>
  void ShenandoahHeapRegion::make_trash_immediate() {
    make_trash();
  
    // On this path, we know there are no marked objects in the region,
    // tell marking context about it to bypass bitmap resets.
<span class="line-modified">!   ShenandoahHeap::heap()-&gt;complete_marking_context()-&gt;reset_top_bitmap(this);</span>
  }
  
  void ShenandoahHeapRegion::make_empty() {
<span class="line-modified">!   shenandoah_assert_heaplocked();</span>
    switch (_state) {
      case _trash:
        set_state(_empty_committed);
        _empty_time = os::elapsedTime();
        return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 279,11 ***</span>
        report_illegal_transition(&quot;emptying&quot;);
    }
  }
  
  void ShenandoahHeapRegion::make_uncommitted() {
<span class="line-modified">!   _heap-&gt;assert_heaplock_owned_by_current_thread();</span>
    switch (_state) {
      case _empty_committed:
        do_uncommit();
        set_state(_empty_uncommitted);
        return;
<span class="line-new-header">--- 272,11 ---</span>
        report_illegal_transition(&quot;emptying&quot;);
    }
  }
  
  void ShenandoahHeapRegion::make_uncommitted() {
<span class="line-modified">!   shenandoah_assert_heaplocked();</span>
    switch (_state) {
      case _empty_committed:
        do_uncommit();
        set_state(_empty_uncommitted);
        return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 291,12 ***</span>
        report_illegal_transition(&quot;uncommiting&quot;);
    }
  }
  
  void ShenandoahHeapRegion::make_committed_bypass() {
<span class="line-modified">!   _heap-&gt;assert_heaplock_owned_by_current_thread();</span>
<span class="line-modified">!   assert (_heap-&gt;is_full_gc_in_progress(), &quot;only for full GC&quot;);</span>
  
    switch (_state) {
      case _empty_uncommitted:
        do_commit();
        set_state(_empty_committed);
<span class="line-new-header">--- 284,12 ---</span>
        report_illegal_transition(&quot;uncommiting&quot;);
    }
  }
  
  void ShenandoahHeapRegion::make_committed_bypass() {
<span class="line-modified">!   shenandoah_assert_heaplocked();</span>
<span class="line-modified">!   assert (ShenandoahHeap::heap()-&gt;is_full_gc_in_progress(), &quot;only for full GC&quot;);</span>
  
    switch (_state) {
      case _empty_uncommitted:
        do_commit();
        set_state(_empty_committed);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 304,41 ***</span>
      default:
        report_illegal_transition(&quot;commit bypass&quot;);
    }
  }
  
<span class="line-removed">- void ShenandoahHeapRegion::clear_live_data() {</span>
<span class="line-removed">-   Atomic::release_store_fence(&amp;_live_data, (size_t)0);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void ShenandoahHeapRegion::reset_alloc_metadata() {
    _tlab_allocs = 0;
    _gclab_allocs = 0;
<span class="line-removed">-   _shared_allocs = 0;</span>
<span class="line-removed">-   _seqnum_first_alloc_mutator = 0;</span>
<span class="line-removed">-   _seqnum_last_alloc_mutator = 0;</span>
<span class="line-removed">-   _seqnum_first_alloc_gc = 0;</span>
<span class="line-removed">-   _seqnum_last_alloc_gc = 0;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void ShenandoahHeapRegion::reset_alloc_metadata_to_shared() {</span>
<span class="line-removed">-   if (used() &gt; 0) {</span>
<span class="line-removed">-     _tlab_allocs = 0;</span>
<span class="line-removed">-     _gclab_allocs = 0;</span>
<span class="line-removed">-     _shared_allocs = used() &gt;&gt; LogHeapWordSize;</span>
<span class="line-removed">-     uint64_t next = _alloc_seq_num.value++;</span>
<span class="line-removed">-     _seqnum_first_alloc_mutator = next;</span>
<span class="line-removed">-     _seqnum_last_alloc_mutator = next;</span>
<span class="line-removed">-     _seqnum_first_alloc_gc = 0;</span>
<span class="line-removed">-     _seqnum_last_alloc_gc = 0;</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     reset_alloc_metadata();</span>
<span class="line-removed">-   }</span>
  }
  
  size_t ShenandoahHeapRegion::get_shared_allocs() const {
<span class="line-modified">!   return _shared_allocs * HeapWordSize;</span>
  }
  
  size_t ShenandoahHeapRegion::get_tlab_allocs() const {
    return _tlab_allocs * HeapWordSize;
  }
<span class="line-new-header">--- 297,17 ---</span>
      default:
        report_illegal_transition(&quot;commit bypass&quot;);
    }
  }
  
  void ShenandoahHeapRegion::reset_alloc_metadata() {
    _tlab_allocs = 0;
    _gclab_allocs = 0;
  }
  
  size_t ShenandoahHeapRegion::get_shared_allocs() const {
<span class="line-modified">!   return used() - (_tlab_allocs + _gclab_allocs) * HeapWordSize;</span>
  }
  
  size_t ShenandoahHeapRegion::get_tlab_allocs() const {
    return _tlab_allocs * HeapWordSize;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 350,33 ***</span>
  void ShenandoahHeapRegion::set_live_data(size_t s) {
    assert(Thread::current()-&gt;is_VM_thread(), &quot;by VM thread&quot;);
    _live_data = (s &gt;&gt; LogHeapWordSize);
  }
  
<span class="line-removed">- size_t ShenandoahHeapRegion::get_live_data_words() const {</span>
<span class="line-removed">-   return Atomic::load_acquire(&amp;_live_data);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- size_t ShenandoahHeapRegion::get_live_data_bytes() const {</span>
<span class="line-removed">-   return get_live_data_words() * HeapWordSize;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool ShenandoahHeapRegion::has_live() const {</span>
<span class="line-removed">-   return get_live_data_words() != 0;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- size_t ShenandoahHeapRegion::garbage() const {</span>
<span class="line-removed">-   assert(used() &gt;= get_live_data_bytes(), &quot;Live Data must be a subset of used() live: &quot; SIZE_FORMAT &quot; used: &quot; SIZE_FORMAT,</span>
<span class="line-removed">-          get_live_data_bytes(), used());</span>
<span class="line-removed">- </span>
<span class="line-removed">-   size_t result = used() - get_live_data_bytes();</span>
<span class="line-removed">-   return result;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void ShenandoahHeapRegion::print_on(outputStream* st) const {
    st-&gt;print(&quot;|&quot;);
<span class="line-modified">!   st-&gt;print(SIZE_FORMAT_W(5), this-&gt;_region_number);</span>
  
    switch (_state) {
      case _empty_uncommitted:
        st-&gt;print(&quot;|EU &quot;);
        break;
<span class="line-new-header">--- 319,13 ---</span>
  void ShenandoahHeapRegion::set_live_data(size_t s) {
    assert(Thread::current()-&gt;is_VM_thread(), &quot;by VM thread&quot;);
    _live_data = (s &gt;&gt; LogHeapWordSize);
  }
  
  void ShenandoahHeapRegion::print_on(outputStream* st) const {
    st-&gt;print(&quot;|&quot;);
<span class="line-modified">!   st-&gt;print(SIZE_FORMAT_W(5), this-&gt;_index);</span>
  
    switch (_state) {
      case _empty_uncommitted:
        st-&gt;print(&quot;|EU &quot;);
        break;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 411,20 ***</span>
        ShouldNotReachHere();
    }
    st-&gt;print(&quot;|BTE &quot; INTPTR_FORMAT_W(12) &quot;, &quot; INTPTR_FORMAT_W(12) &quot;, &quot; INTPTR_FORMAT_W(12),
              p2i(bottom()), p2i(top()), p2i(end()));
    st-&gt;print(&quot;|TAMS &quot; INTPTR_FORMAT_W(12),
<span class="line-modified">!             p2i(_heap-&gt;marking_context()-&gt;top_at_mark_start(const_cast&lt;ShenandoahHeapRegion*&gt;(this))));</span>
    st-&gt;print(&quot;|U &quot; SIZE_FORMAT_W(5) &quot;%1s&quot;, byte_size_in_proper_unit(used()),                proper_unit_for_byte_size(used()));
    st-&gt;print(&quot;|T &quot; SIZE_FORMAT_W(5) &quot;%1s&quot;, byte_size_in_proper_unit(get_tlab_allocs()),     proper_unit_for_byte_size(get_tlab_allocs()));
    st-&gt;print(&quot;|G &quot; SIZE_FORMAT_W(5) &quot;%1s&quot;, byte_size_in_proper_unit(get_gclab_allocs()),    proper_unit_for_byte_size(get_gclab_allocs()));
    st-&gt;print(&quot;|S &quot; SIZE_FORMAT_W(5) &quot;%1s&quot;, byte_size_in_proper_unit(get_shared_allocs()),   proper_unit_for_byte_size(get_shared_allocs()));
    st-&gt;print(&quot;|L &quot; SIZE_FORMAT_W(5) &quot;%1s&quot;, byte_size_in_proper_unit(get_live_data_bytes()), proper_unit_for_byte_size(get_live_data_bytes()));
    st-&gt;print(&quot;|CP &quot; SIZE_FORMAT_W(3), pin_count());
<span class="line-removed">-   st-&gt;print(&quot;|SN &quot; UINT64_FORMAT_X_W(12) &quot;, &quot; UINT64_FORMAT_X_W(8) &quot;, &quot; UINT64_FORMAT_X_W(8) &quot;, &quot; UINT64_FORMAT_X_W(8),</span>
<span class="line-removed">-             seqnum_first_alloc_mutator(), seqnum_last_alloc_mutator(),</span>
<span class="line-removed">-             seqnum_first_alloc_gc(), seqnum_last_alloc_gc());</span>
    st-&gt;cr();
  }
  
  void ShenandoahHeapRegion::oop_iterate(OopIterateClosure* blk) {
    if (!is_active()) return;
<span class="line-new-header">--- 360,19 ---</span>
        ShouldNotReachHere();
    }
    st-&gt;print(&quot;|BTE &quot; INTPTR_FORMAT_W(12) &quot;, &quot; INTPTR_FORMAT_W(12) &quot;, &quot; INTPTR_FORMAT_W(12),
              p2i(bottom()), p2i(top()), p2i(end()));
    st-&gt;print(&quot;|TAMS &quot; INTPTR_FORMAT_W(12),
<span class="line-modified">!             p2i(ShenandoahHeap::heap()-&gt;marking_context()-&gt;top_at_mark_start(const_cast&lt;ShenandoahHeapRegion*&gt;(this))));</span>
<span class="line-added">+   st-&gt;print(&quot;|UWM &quot; INTPTR_FORMAT_W(12),</span>
<span class="line-added">+             p2i(_update_watermark));</span>
    st-&gt;print(&quot;|U &quot; SIZE_FORMAT_W(5) &quot;%1s&quot;, byte_size_in_proper_unit(used()),                proper_unit_for_byte_size(used()));
    st-&gt;print(&quot;|T &quot; SIZE_FORMAT_W(5) &quot;%1s&quot;, byte_size_in_proper_unit(get_tlab_allocs()),     proper_unit_for_byte_size(get_tlab_allocs()));
    st-&gt;print(&quot;|G &quot; SIZE_FORMAT_W(5) &quot;%1s&quot;, byte_size_in_proper_unit(get_gclab_allocs()),    proper_unit_for_byte_size(get_gclab_allocs()));
    st-&gt;print(&quot;|S &quot; SIZE_FORMAT_W(5) &quot;%1s&quot;, byte_size_in_proper_unit(get_shared_allocs()),   proper_unit_for_byte_size(get_shared_allocs()));
    st-&gt;print(&quot;|L &quot; SIZE_FORMAT_W(5) &quot;%1s&quot;, byte_size_in_proper_unit(get_live_data_bytes()), proper_unit_for_byte_size(get_live_data_bytes()));
    st-&gt;print(&quot;|CP &quot; SIZE_FORMAT_W(3), pin_count());
    st-&gt;cr();
  }
  
  void ShenandoahHeapRegion::oop_iterate(OopIterateClosure* blk) {
    if (!is_active()) return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 454,38 ***</span>
    oop obj = oop(r-&gt;bottom());
    obj-&gt;oop_iterate(blk, MemRegion(bottom(), top()));
  }
  
  ShenandoahHeapRegion* ShenandoahHeapRegion::humongous_start_region() const {
    assert(is_humongous(), &quot;Must be a part of the humongous region&quot;);
<span class="line-modified">!   size_t reg_num = region_number();</span>
    ShenandoahHeapRegion* r = const_cast&lt;ShenandoahHeapRegion*&gt;(this);
    while (!r-&gt;is_humongous_start()) {
<span class="line-modified">!     assert(reg_num &gt; 0, &quot;Sanity&quot;);</span>
<span class="line-modified">!     reg_num --;</span>
<span class="line-modified">!     r = _heap-&gt;get_region(reg_num);</span>
      assert(r-&gt;is_humongous(), &quot;Must be a part of the humongous region&quot;);
    }
    assert(r-&gt;is_humongous_start(), &quot;Must be&quot;);
    return r;
  }
  
  void ShenandoahHeapRegion::recycle() {
<span class="line-modified">!   ContiguousSpace::clear(false);</span>
<span class="line-removed">-   if (ZapUnusedHeapArea) {</span>
<span class="line-removed">-     ContiguousSpace::mangle_unused_area_complete();</span>
<span class="line-removed">-   }</span>
    clear_live_data();
  
    reset_alloc_metadata();
  
<span class="line-modified">!   _heap-&gt;marking_context()-&gt;reset_top_at_mark_start(this);</span>
  
    make_empty();
  }
  
<span class="line-modified">! HeapWord* ShenandoahHeapRegion::block_start_const(const void* p) const {</span>
    assert(MemRegion(bottom(), end()).contains(p),
           &quot;p (&quot; PTR_FORMAT &quot;) not in space [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;)&quot;,
           p2i(p), p2i(bottom()), p2i(end()));
    if (p &gt;= top()) {
      return top();
<span class="line-new-header">--- 402,41 ---</span>
    oop obj = oop(r-&gt;bottom());
    obj-&gt;oop_iterate(blk, MemRegion(bottom(), top()));
  }
  
  ShenandoahHeapRegion* ShenandoahHeapRegion::humongous_start_region() const {
<span class="line-added">+   ShenandoahHeap* heap = ShenandoahHeap::heap();</span>
    assert(is_humongous(), &quot;Must be a part of the humongous region&quot;);
<span class="line-modified">!   size_t i = index();</span>
    ShenandoahHeapRegion* r = const_cast&lt;ShenandoahHeapRegion*&gt;(this);
    while (!r-&gt;is_humongous_start()) {
<span class="line-modified">!     assert(i &gt; 0, &quot;Sanity&quot;);</span>
<span class="line-modified">!     i--;</span>
<span class="line-modified">!     r = heap-&gt;get_region(i);</span>
      assert(r-&gt;is_humongous(), &quot;Must be a part of the humongous region&quot;);
    }
    assert(r-&gt;is_humongous_start(), &quot;Must be&quot;);
    return r;
  }
  
  void ShenandoahHeapRegion::recycle() {
<span class="line-modified">!   set_top(bottom());</span>
    clear_live_data();
  
    reset_alloc_metadata();
  
<span class="line-modified">!   ShenandoahHeap::heap()-&gt;marking_context()-&gt;reset_top_at_mark_start(this);</span>
<span class="line-added">+   set_update_watermark(bottom());</span>
  
    make_empty();
<span class="line-added">+ </span>
<span class="line-added">+   if (ZapUnusedHeapArea) {</span>
<span class="line-added">+     SpaceMangler::mangle_region(MemRegion(bottom(), end()));</span>
<span class="line-added">+   }</span>
  }
  
<span class="line-modified">! HeapWord* ShenandoahHeapRegion::block_start(const void* p) const {</span>
    assert(MemRegion(bottom(), end()).contains(p),
           &quot;p (&quot; PTR_FORMAT &quot;) not in space [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;)&quot;,
           p2i(p), p2i(bottom()), p2i(end()));
    if (p &gt;= top()) {
      return top();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 499,20 ***</span>
      shenandoah_assert_correct(NULL, oop(last));
      return last;
    }
  }
  
  void ShenandoahHeapRegion::setup_sizes(size_t max_heap_size) {
    // Absolute minimums we should not ever break.
    static const size_t MIN_REGION_SIZE = 256*K;
  
    if (FLAG_IS_DEFAULT(ShenandoahMinRegionSize)) {
      FLAG_SET_DEFAULT(ShenandoahMinRegionSize, MIN_REGION_SIZE);
    }
  
    size_t region_size;
<span class="line-modified">!   if (FLAG_IS_DEFAULT(ShenandoahHeapRegionSize)) {</span>
      if (ShenandoahMinRegionSize &gt; max_heap_size / MIN_NUM_REGIONS) {
        err_msg message(&quot;Max heap size (&quot; SIZE_FORMAT &quot;%s) is too low to afford the minimum number &quot;
                        &quot;of regions (&quot; SIZE_FORMAT &quot;) of minimum region size (&quot; SIZE_FORMAT &quot;%s).&quot;,
                        byte_size_in_proper_unit(max_heap_size), proper_unit_for_byte_size(max_heap_size),
                        MIN_NUM_REGIONS,
<span class="line-new-header">--- 450,32 ---</span>
      shenandoah_assert_correct(NULL, oop(last));
      return last;
    }
  }
  
<span class="line-added">+ size_t ShenandoahHeapRegion::block_size(const HeapWord* p) const {</span>
<span class="line-added">+   assert(MemRegion(bottom(), end()).contains(p),</span>
<span class="line-added">+          &quot;p (&quot; PTR_FORMAT &quot;) not in space [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;)&quot;,</span>
<span class="line-added">+          p2i(p), p2i(bottom()), p2i(end()));</span>
<span class="line-added">+   if (p &lt; top()) {</span>
<span class="line-added">+     return oop(p)-&gt;size();</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     assert(p == top(), &quot;just checking&quot;);</span>
<span class="line-added">+     return pointer_delta(end(), (HeapWord*) p);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void ShenandoahHeapRegion::setup_sizes(size_t max_heap_size) {
    // Absolute minimums we should not ever break.
    static const size_t MIN_REGION_SIZE = 256*K;
  
    if (FLAG_IS_DEFAULT(ShenandoahMinRegionSize)) {
      FLAG_SET_DEFAULT(ShenandoahMinRegionSize, MIN_REGION_SIZE);
    }
  
    size_t region_size;
<span class="line-modified">!   if (FLAG_IS_DEFAULT(ShenandoahRegionSize)) {</span>
      if (ShenandoahMinRegionSize &gt; max_heap_size / MIN_NUM_REGIONS) {
        err_msg message(&quot;Max heap size (&quot; SIZE_FORMAT &quot;%s) is too low to afford the minimum number &quot;
                        &quot;of regions (&quot; SIZE_FORMAT &quot;) of minimum region size (&quot; SIZE_FORMAT &quot;%s).&quot;,
                        byte_size_in_proper_unit(max_heap_size), proper_unit_for_byte_size(max_heap_size),
                        MIN_NUM_REGIONS,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 551,31 ***</span>
      // Now make sure that we don&#39;t go over or under our limits.
      region_size = MAX2(ShenandoahMinRegionSize, region_size);
      region_size = MIN2(ShenandoahMaxRegionSize, region_size);
  
    } else {
<span class="line-modified">!     if (ShenandoahHeapRegionSize &gt; max_heap_size / MIN_NUM_REGIONS) {</span>
        err_msg message(&quot;Max heap size (&quot; SIZE_FORMAT &quot;%s) is too low to afford the minimum number &quot;
                                &quot;of regions (&quot; SIZE_FORMAT &quot;) of requested size (&quot; SIZE_FORMAT &quot;%s).&quot;,
                        byte_size_in_proper_unit(max_heap_size), proper_unit_for_byte_size(max_heap_size),
                        MIN_NUM_REGIONS,
<span class="line-modified">!                       byte_size_in_proper_unit(ShenandoahHeapRegionSize), proper_unit_for_byte_size(ShenandoahHeapRegionSize));</span>
<span class="line-modified">!       vm_exit_during_initialization(&quot;Invalid -XX:ShenandoahHeapRegionSize option&quot;, message);</span>
      }
<span class="line-modified">!     if (ShenandoahHeapRegionSize &lt; ShenandoahMinRegionSize) {</span>
        err_msg message(&quot;Heap region size (&quot; SIZE_FORMAT &quot;%s) should be larger than min region size (&quot; SIZE_FORMAT &quot;%s).&quot;,
<span class="line-modified">!                       byte_size_in_proper_unit(ShenandoahHeapRegionSize), proper_unit_for_byte_size(ShenandoahHeapRegionSize),</span>
                        byte_size_in_proper_unit(ShenandoahMinRegionSize),  proper_unit_for_byte_size(ShenandoahMinRegionSize));
<span class="line-modified">!       vm_exit_during_initialization(&quot;Invalid -XX:ShenandoahHeapRegionSize option&quot;, message);</span>
      }
<span class="line-modified">!     if (ShenandoahHeapRegionSize &gt; ShenandoahMaxRegionSize) {</span>
        err_msg message(&quot;Heap region size (&quot; SIZE_FORMAT &quot;%s) should be lower than max region size (&quot; SIZE_FORMAT &quot;%s).&quot;,
<span class="line-modified">!                       byte_size_in_proper_unit(ShenandoahHeapRegionSize), proper_unit_for_byte_size(ShenandoahHeapRegionSize),</span>
                        byte_size_in_proper_unit(ShenandoahMaxRegionSize),  proper_unit_for_byte_size(ShenandoahMaxRegionSize));
<span class="line-modified">!       vm_exit_during_initialization(&quot;Invalid -XX:ShenandoahHeapRegionSize option&quot;, message);</span>
      }
<span class="line-modified">!     region_size = ShenandoahHeapRegionSize;</span>
    }
  
    // Make sure region size is at least one large page, if enabled.
    // Otherwise, uncommitting one region may falsely uncommit the adjacent
    // regions too.
<span class="line-new-header">--- 514,31 ---</span>
      // Now make sure that we don&#39;t go over or under our limits.
      region_size = MAX2(ShenandoahMinRegionSize, region_size);
      region_size = MIN2(ShenandoahMaxRegionSize, region_size);
  
    } else {
<span class="line-modified">!     if (ShenandoahRegionSize &gt; max_heap_size / MIN_NUM_REGIONS) {</span>
        err_msg message(&quot;Max heap size (&quot; SIZE_FORMAT &quot;%s) is too low to afford the minimum number &quot;
                                &quot;of regions (&quot; SIZE_FORMAT &quot;) of requested size (&quot; SIZE_FORMAT &quot;%s).&quot;,
                        byte_size_in_proper_unit(max_heap_size), proper_unit_for_byte_size(max_heap_size),
                        MIN_NUM_REGIONS,
<span class="line-modified">!                       byte_size_in_proper_unit(ShenandoahRegionSize), proper_unit_for_byte_size(ShenandoahRegionSize));</span>
<span class="line-modified">!       vm_exit_during_initialization(&quot;Invalid -XX:ShenandoahRegionSize option&quot;, message);</span>
      }
<span class="line-modified">!     if (ShenandoahRegionSize &lt; ShenandoahMinRegionSize) {</span>
        err_msg message(&quot;Heap region size (&quot; SIZE_FORMAT &quot;%s) should be larger than min region size (&quot; SIZE_FORMAT &quot;%s).&quot;,
<span class="line-modified">!                       byte_size_in_proper_unit(ShenandoahRegionSize), proper_unit_for_byte_size(ShenandoahRegionSize),</span>
                        byte_size_in_proper_unit(ShenandoahMinRegionSize),  proper_unit_for_byte_size(ShenandoahMinRegionSize));
<span class="line-modified">!       vm_exit_during_initialization(&quot;Invalid -XX:ShenandoahRegionSize option&quot;, message);</span>
      }
<span class="line-modified">!     if (ShenandoahRegionSize &gt; ShenandoahMaxRegionSize) {</span>
        err_msg message(&quot;Heap region size (&quot; SIZE_FORMAT &quot;%s) should be lower than max region size (&quot; SIZE_FORMAT &quot;%s).&quot;,
<span class="line-modified">!                       byte_size_in_proper_unit(ShenandoahRegionSize), proper_unit_for_byte_size(ShenandoahRegionSize),</span>
                        byte_size_in_proper_unit(ShenandoahMaxRegionSize),  proper_unit_for_byte_size(ShenandoahMaxRegionSize));
<span class="line-modified">!       vm_exit_during_initialization(&quot;Invalid -XX:ShenandoahRegionSize option&quot;, message);</span>
      }
<span class="line-modified">!     region_size = ShenandoahRegionSize;</span>
    }
  
    // Make sure region size is at least one large page, if enabled.
    // Otherwise, uncommitting one region may falsely uncommit the adjacent
    // regions too.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 654,33 ***</span>
    log_info(gc, init)(&quot;Max TLAB size: &quot; SIZE_FORMAT &quot;%s&quot;,
                       byte_size_in_proper_unit(MaxTLABSizeBytes), proper_unit_for_byte_size(MaxTLABSizeBytes));
  }
  
  void ShenandoahHeapRegion::do_commit() {
<span class="line-modified">!   if (!_heap-&gt;is_heap_region_special() &amp;&amp; !os::commit_memory((char *) _reserved.start(), _reserved.byte_size(), false)) {</span>
      report_java_out_of_memory(&quot;Unable to commit region&quot;);
    }
<span class="line-modified">!   if (!_heap-&gt;commit_bitmap_slice(this)) {</span>
      report_java_out_of_memory(&quot;Unable to commit bitmaps for region&quot;);
    }
<span class="line-modified">!   _heap-&gt;increase_committed(ShenandoahHeapRegion::region_size_bytes());</span>
  }
  
  void ShenandoahHeapRegion::do_uncommit() {
<span class="line-modified">!   if (!_heap-&gt;is_heap_region_special() &amp;&amp; !os::uncommit_memory((char *) _reserved.start(), _reserved.byte_size())) {</span>
      report_java_out_of_memory(&quot;Unable to uncommit region&quot;);
    }
<span class="line-modified">!   if (!_heap-&gt;uncommit_bitmap_slice(this)) {</span>
      report_java_out_of_memory(&quot;Unable to uncommit bitmaps for region&quot;);
    }
<span class="line-modified">!   _heap-&gt;decrease_committed(ShenandoahHeapRegion::region_size_bytes());</span>
  }
  
  void ShenandoahHeapRegion::set_state(RegionState to) {
    EventShenandoahHeapRegionStateChange evt;
    if (evt.should_commit()){
<span class="line-modified">!     evt.set_index((unsigned)region_number());</span>
      evt.set_start((uintptr_t)bottom());
      evt.set_used(used());
      evt.set_from(_state);
      evt.set_to(to);
      evt.commit();
<span class="line-new-header">--- 617,35 ---</span>
    log_info(gc, init)(&quot;Max TLAB size: &quot; SIZE_FORMAT &quot;%s&quot;,
                       byte_size_in_proper_unit(MaxTLABSizeBytes), proper_unit_for_byte_size(MaxTLABSizeBytes));
  }
  
  void ShenandoahHeapRegion::do_commit() {
<span class="line-modified">!   ShenandoahHeap* heap = ShenandoahHeap::heap();</span>
<span class="line-added">+   if (!heap-&gt;is_heap_region_special() &amp;&amp; !os::commit_memory((char *) bottom(), RegionSizeBytes, false)) {</span>
      report_java_out_of_memory(&quot;Unable to commit region&quot;);
    }
<span class="line-modified">!   if (!heap-&gt;commit_bitmap_slice(this)) {</span>
      report_java_out_of_memory(&quot;Unable to commit bitmaps for region&quot;);
    }
<span class="line-modified">!   heap-&gt;increase_committed(ShenandoahHeapRegion::region_size_bytes());</span>
  }
  
  void ShenandoahHeapRegion::do_uncommit() {
<span class="line-modified">!   ShenandoahHeap* heap = ShenandoahHeap::heap();</span>
<span class="line-added">+   if (!heap-&gt;is_heap_region_special() &amp;&amp; !os::uncommit_memory((char *) bottom(), RegionSizeBytes)) {</span>
      report_java_out_of_memory(&quot;Unable to uncommit region&quot;);
    }
<span class="line-modified">!   if (!heap-&gt;uncommit_bitmap_slice(this)) {</span>
      report_java_out_of_memory(&quot;Unable to uncommit bitmaps for region&quot;);
    }
<span class="line-modified">!   heap-&gt;decrease_committed(ShenandoahHeapRegion::region_size_bytes());</span>
  }
  
  void ShenandoahHeapRegion::set_state(RegionState to) {
    EventShenandoahHeapRegionStateChange evt;
    if (evt.should_commit()){
<span class="line-modified">!     evt.set_index((unsigned) index());</span>
      evt.set_start((uintptr_t)bottom());
      evt.set_used(used());
      evt.set_from(_state);
      evt.set_to(to);
      evt.commit();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 691,11 ***</span>
  void ShenandoahHeapRegion::record_pin() {
    Atomic::add(&amp;_critical_pins, (size_t)1);
  }
  
  void ShenandoahHeapRegion::record_unpin() {
<span class="line-modified">!   assert(pin_count() &gt; 0, &quot;Region &quot; SIZE_FORMAT &quot; should have non-zero pins&quot;, region_number());</span>
    Atomic::sub(&amp;_critical_pins, (size_t)1);
  }
  
  size_t ShenandoahHeapRegion::pin_count() const {
    return Atomic::load(&amp;_critical_pins);
<span class="line-new-header">--- 656,11 ---</span>
  void ShenandoahHeapRegion::record_pin() {
    Atomic::add(&amp;_critical_pins, (size_t)1);
  }
  
  void ShenandoahHeapRegion::record_unpin() {
<span class="line-modified">!   assert(pin_count() &gt; 0, &quot;Region &quot; SIZE_FORMAT &quot; should have non-zero pins&quot;, index());</span>
    Atomic::sub(&amp;_critical_pins, (size_t)1);
  }
  
  size_t ShenandoahHeapRegion::pin_count() const {
    return Atomic::load(&amp;_critical_pins);
</pre>
<center><a href="shenandoahHeap.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahHeapRegion.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
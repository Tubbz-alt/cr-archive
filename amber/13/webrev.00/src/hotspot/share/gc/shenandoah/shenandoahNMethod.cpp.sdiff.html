<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/shenandoahNMethod.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahMonitoringSupport.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahNMethod.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahNMethod.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 40       _oops[c] = oops.at(c);
 41     }
 42   }
 43   _has_non_immed_oops = non_immediate_oops;
 44 
 45   assert_same_oops();
 46 }
 47 
 48 ShenandoahNMethod::~ShenandoahNMethod() {
 49   if (_oops != NULL) {
 50     FREE_C_HEAP_ARRAY(oop*, _oops);
 51   }
 52 }
 53 
 54 class ShenandoahHasCSetOopClosure : public OopClosure {
 55 private:
 56   ShenandoahHeap* const _heap;
 57   bool                  _has_cset_oops;
 58 
 59 public:
<span class="line-modified"> 60   ShenandoahHasCSetOopClosure() :</span>
<span class="line-modified"> 61     _heap(ShenandoahHeap::heap()),</span>
 62     _has_cset_oops(false) {
 63   }
 64 
 65   bool has_cset_oops() const {
 66     return _has_cset_oops;
 67   }
 68 
 69   void do_oop(oop* p) {
 70     oop value = RawAccess&lt;&gt;::oop_load(p);
 71     if (!_has_cset_oops &amp;&amp; _heap-&gt;in_collection_set(value)) {
 72       _has_cset_oops = true;
 73     }
 74   }
 75 
 76   void do_oop(narrowOop* p) {
 77     ShouldNotReachHere();
 78   }
 79 };
 80 
 81 bool ShenandoahNMethod::has_cset_oops(ShenandoahHeap *heap) {
<span class="line-modified"> 82   ShenandoahHasCSetOopClosure cl;</span>
 83   oops_do(&amp;cl);
 84   return cl.has_cset_oops();
 85 }
 86 
 87 void ShenandoahNMethod::update() {
 88   ResourceMark rm;
 89   bool non_immediate_oops = false;
 90   GrowableArray&lt;oop*&gt; oops;
 91 
 92   detect_reloc_oops(nm(), oops, non_immediate_oops);
 93   if (oops.length() != _oops_count) {
 94     if (_oops != NULL) {
 95       FREE_C_HEAP_ARRAY(oop*, _oops);
 96       _oops = NULL;
 97     }
 98 
 99     _oops_count = oops.length();
100     if (_oops_count &gt; 0) {
101       _oops = NEW_C_HEAP_ARRAY(oop*, _oops_count, mtGC);
102     }
</pre>
<hr />
<pre>
158     }
159   }
160 }
161 
162 ShenandoahNMethod* ShenandoahNMethod::for_nmethod(nmethod* nm) {
163   ResourceMark rm;
164   bool non_immediate_oops = false;
165   GrowableArray&lt;oop*&gt; oops;
166 
167   detect_reloc_oops(nm, oops, non_immediate_oops);
168 
169   // No embedded oops
170   if(!ShenandoahConcurrentRoots::can_do_concurrent_class_unloading() &amp;&amp;
171     oops.is_empty() &amp;&amp; nm-&gt;oops_begin() &gt;= nm-&gt;oops_end()) {
172     return NULL;
173   }
174 
175   return new ShenandoahNMethod(nm, oops, non_immediate_oops);
176 }
177 
























178 void ShenandoahNMethod::heal_nmethod(nmethod* nm) {
<span class="line-removed">179   assert(ShenandoahHeap::heap()-&gt;is_concurrent_root_in_progress(), &quot;Only this phase&quot;);</span>
180   ShenandoahNMethod* data = gc_data(nm);
181   assert(data != NULL, &quot;Sanity&quot;);
182   assert(data-&gt;lock()-&gt;owned_by_self(), &quot;Must hold the lock&quot;);
183 
<span class="line-modified">184   ShenandoahEvacOOMScope evac_scope;</span>
<span class="line-modified">185   ShenandoahEvacuateUpdateRootsClosure&lt;&gt; cl;</span>
<span class="line-modified">186   data-&gt;oops_do(&amp;cl, true /*fix relocation*/);</span>
















187 }
188 
189 #ifdef ASSERT
190 void ShenandoahNMethod::assert_alive_and_correct() {
191   assert(_nm-&gt;is_alive(), &quot;only alive nmethods here&quot;);
192   ShenandoahHeap* heap = ShenandoahHeap::heap();
193   for (int c = 0; c &lt; _oops_count; c++) {
194     oop *loc = _oops[c];
195     assert(_nm-&gt;code_contains((address) loc) || _nm-&gt;oops_contains(loc), &quot;nmethod should contain the oop*&quot;);
196     oop o = RawAccess&lt;&gt;::oop_load(loc);
197     shenandoah_assert_correct_except(loc, o, o == NULL || heap-&gt;is_full_gc_move_in_progress());
198   }
199 
200   oop* const begin = _nm-&gt;oops_begin();
201   oop* const end = _nm-&gt;oops_end();
202   for (oop* p = begin; p &lt; end; p++) {
203     if (*p != Universe::non_oop_word()) {
204       oop o = RawAccess&lt;&gt;::oop_load(p);
205       shenandoah_assert_correct_except(p, o, o == NULL || heap-&gt;is_full_gc_move_in_progress());
206     }
</pre>
</td>
<td>
<hr />
<pre>
 40       _oops[c] = oops.at(c);
 41     }
 42   }
 43   _has_non_immed_oops = non_immediate_oops;
 44 
 45   assert_same_oops();
 46 }
 47 
 48 ShenandoahNMethod::~ShenandoahNMethod() {
 49   if (_oops != NULL) {
 50     FREE_C_HEAP_ARRAY(oop*, _oops);
 51   }
 52 }
 53 
 54 class ShenandoahHasCSetOopClosure : public OopClosure {
 55 private:
 56   ShenandoahHeap* const _heap;
 57   bool                  _has_cset_oops;
 58 
 59 public:
<span class="line-modified"> 60   ShenandoahHasCSetOopClosure(ShenandoahHeap *heap) :</span>
<span class="line-modified"> 61     _heap(heap),</span>
 62     _has_cset_oops(false) {
 63   }
 64 
 65   bool has_cset_oops() const {
 66     return _has_cset_oops;
 67   }
 68 
 69   void do_oop(oop* p) {
 70     oop value = RawAccess&lt;&gt;::oop_load(p);
 71     if (!_has_cset_oops &amp;&amp; _heap-&gt;in_collection_set(value)) {
 72       _has_cset_oops = true;
 73     }
 74   }
 75 
 76   void do_oop(narrowOop* p) {
 77     ShouldNotReachHere();
 78   }
 79 };
 80 
 81 bool ShenandoahNMethod::has_cset_oops(ShenandoahHeap *heap) {
<span class="line-modified"> 82   ShenandoahHasCSetOopClosure cl(heap);</span>
 83   oops_do(&amp;cl);
 84   return cl.has_cset_oops();
 85 }
 86 
 87 void ShenandoahNMethod::update() {
 88   ResourceMark rm;
 89   bool non_immediate_oops = false;
 90   GrowableArray&lt;oop*&gt; oops;
 91 
 92   detect_reloc_oops(nm(), oops, non_immediate_oops);
 93   if (oops.length() != _oops_count) {
 94     if (_oops != NULL) {
 95       FREE_C_HEAP_ARRAY(oop*, _oops);
 96       _oops = NULL;
 97     }
 98 
 99     _oops_count = oops.length();
100     if (_oops_count &gt; 0) {
101       _oops = NEW_C_HEAP_ARRAY(oop*, _oops_count, mtGC);
102     }
</pre>
<hr />
<pre>
158     }
159   }
160 }
161 
162 ShenandoahNMethod* ShenandoahNMethod::for_nmethod(nmethod* nm) {
163   ResourceMark rm;
164   bool non_immediate_oops = false;
165   GrowableArray&lt;oop*&gt; oops;
166 
167   detect_reloc_oops(nm, oops, non_immediate_oops);
168 
169   // No embedded oops
170   if(!ShenandoahConcurrentRoots::can_do_concurrent_class_unloading() &amp;&amp;
171     oops.is_empty() &amp;&amp; nm-&gt;oops_begin() &gt;= nm-&gt;oops_end()) {
172     return NULL;
173   }
174 
175   return new ShenandoahNMethod(nm, oops, non_immediate_oops);
176 }
177 
<span class="line-added">178 template &lt;bool HAS_FWD&gt;</span>
<span class="line-added">179 class ShenandoahKeepNMethodMetadataAliveClosure : public OopClosure {</span>
<span class="line-added">180 private:</span>
<span class="line-added">181   ShenandoahBarrierSet* const _bs;</span>
<span class="line-added">182 public:</span>
<span class="line-added">183   ShenandoahKeepNMethodMetadataAliveClosure() :</span>
<span class="line-added">184     _bs(static_cast&lt;ShenandoahBarrierSet*&gt;(BarrierSet::barrier_set())) {</span>
<span class="line-added">185   }</span>
<span class="line-added">186 </span>
<span class="line-added">187   virtual void do_oop(oop* p) {</span>
<span class="line-added">188     oop obj = RawAccess&lt;&gt;::oop_load(p);</span>
<span class="line-added">189     if (!CompressedOops::is_null(obj)) {</span>
<span class="line-added">190       if (HAS_FWD) {</span>
<span class="line-added">191         obj = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);</span>
<span class="line-added">192       }</span>
<span class="line-added">193       _bs-&gt;enqueue(obj);</span>
<span class="line-added">194     }</span>
<span class="line-added">195   }</span>
<span class="line-added">196 </span>
<span class="line-added">197   virtual void do_oop(narrowOop* p) {</span>
<span class="line-added">198     ShouldNotReachHere();</span>
<span class="line-added">199   }</span>
<span class="line-added">200 };</span>
<span class="line-added">201 </span>
202 void ShenandoahNMethod::heal_nmethod(nmethod* nm) {

203   ShenandoahNMethod* data = gc_data(nm);
204   assert(data != NULL, &quot;Sanity&quot;);
205   assert(data-&gt;lock()-&gt;owned_by_self(), &quot;Must hold the lock&quot;);
206 
<span class="line-modified">207   ShenandoahHeap* const heap = ShenandoahHeap::heap();</span>
<span class="line-modified">208   if (heap-&gt;is_concurrent_mark_in_progress()) {</span>
<span class="line-modified">209     if (heap-&gt;has_forwarded_objects()) {</span>
<span class="line-added">210       ShenandoahKeepNMethodMetadataAliveClosure&lt;true&gt; cl;</span>
<span class="line-added">211       data-&gt;oops_do(&amp;cl);</span>
<span class="line-added">212     } else {</span>
<span class="line-added">213       ShenandoahKeepNMethodMetadataAliveClosure&lt;false&gt; cl;</span>
<span class="line-added">214       data-&gt;oops_do(&amp;cl);</span>
<span class="line-added">215     }</span>
<span class="line-added">216   } else if (heap-&gt;is_concurrent_root_in_progress()) {</span>
<span class="line-added">217     ShenandoahEvacOOMScope evac_scope;</span>
<span class="line-added">218     ShenandoahEvacuateUpdateRootsClosure&lt;&gt; cl;</span>
<span class="line-added">219     data-&gt;oops_do(&amp;cl, true /*fix relocation*/);</span>
<span class="line-added">220   } else {</span>
<span class="line-added">221     // There is possibility that GC is cancelled when it arrives final mark.</span>
<span class="line-added">222     // In this case, concurrent root phase is skipped and degenerated GC should be</span>
<span class="line-added">223     // followed, where nmethods are disarmed.</span>
<span class="line-added">224     assert(heap-&gt;cancelled_gc(), &quot;What else?&quot;);</span>
<span class="line-added">225   }</span>
226 }
227 
228 #ifdef ASSERT
229 void ShenandoahNMethod::assert_alive_and_correct() {
230   assert(_nm-&gt;is_alive(), &quot;only alive nmethods here&quot;);
231   ShenandoahHeap* heap = ShenandoahHeap::heap();
232   for (int c = 0; c &lt; _oops_count; c++) {
233     oop *loc = _oops[c];
234     assert(_nm-&gt;code_contains((address) loc) || _nm-&gt;oops_contains(loc), &quot;nmethod should contain the oop*&quot;);
235     oop o = RawAccess&lt;&gt;::oop_load(loc);
236     shenandoah_assert_correct_except(loc, o, o == NULL || heap-&gt;is_full_gc_move_in_progress());
237   }
238 
239   oop* const begin = _nm-&gt;oops_begin();
240   oop* const end = _nm-&gt;oops_end();
241   for (oop* p = begin; p &lt; end; p++) {
242     if (*p != Universe::non_oop_word()) {
243       oop o = RawAccess&lt;&gt;::oop_load(p);
244       shenandoah_assert_correct_except(p, o, o == NULL || heap-&gt;is_full_gc_move_in_progress());
245     }
</pre>
</td>
</tr>
</table>
<center><a href="shenandoahMonitoringSupport.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahNMethod.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/shenandoahClosures.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahClosures.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahCodeRoots.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahClosures.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 #ifndef SHARE_GC_SHENANDOAH_SHENANDOAHCLOSURES_INLINE_HPP
 25 #define SHARE_GC_SHENANDOAH_SHENANDOAHCLOSURES_INLINE_HPP
 26 
 27 #include &quot;gc/shared/barrierSetNMethod.hpp&quot;
 28 #include &quot;gc/shenandoah/shenandoahAsserts.hpp&quot;
 29 #include &quot;gc/shenandoah/shenandoahClosures.hpp&quot;
 30 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
 31 #include &quot;gc/shenandoah/shenandoahNMethod.inline.hpp&quot;
<span class="line-removed"> 32 #include &quot;gc/shenandoah/shenandoahTraversalGC.hpp&quot;</span>
 33 #include &quot;oops/compressedOops.inline.hpp&quot;
 34 #include &quot;runtime/atomic.hpp&quot;
 35 #include &quot;runtime/thread.hpp&quot;
 36 
 37 ShenandoahForwardedIsAliveClosure::ShenandoahForwardedIsAliveClosure() :
 38   _mark_context(ShenandoahHeap::heap()-&gt;marking_context()) {
 39 }
 40 
 41 bool ShenandoahForwardedIsAliveClosure::do_object_b(oop obj) {
 42   if (CompressedOops::is_null(obj)) {
 43     return false;
 44   }
 45   obj = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);
<span class="line-modified"> 46   shenandoah_assert_not_forwarded_if(NULL, obj,</span>
<span class="line-removed"> 47                                      (ShenandoahHeap::heap()-&gt;is_concurrent_mark_in_progress() ||</span>
<span class="line-removed"> 48                                      ShenandoahHeap::heap()-&gt;is_concurrent_traversal_in_progress()));</span>
 49   return _mark_context-&gt;is_marked(obj);
 50 }
 51 
 52 ShenandoahIsAliveClosure::ShenandoahIsAliveClosure() :
 53   _mark_context(ShenandoahHeap::heap()-&gt;marking_context()) {
 54 }
 55 
 56 bool ShenandoahIsAliveClosure::do_object_b(oop obj) {
 57   if (CompressedOops::is_null(obj)) {
 58     return false;
 59   }
 60   shenandoah_assert_not_forwarded(NULL, obj);
 61   return _mark_context-&gt;is_marked(obj);
 62 }
 63 
 64 BoolObjectClosure* ShenandoahIsAliveSelector::is_alive_closure() {
 65   return ShenandoahHeap::heap()-&gt;has_forwarded_objects() ?
 66          reinterpret_cast&lt;BoolObjectClosure*&gt;(&amp;_fwd_alive_cl) :
 67          reinterpret_cast&lt;BoolObjectClosure*&gt;(&amp;_alive_cl);
 68 }
 69 
 70 ShenandoahUpdateRefsClosure::ShenandoahUpdateRefsClosure() :
 71   _heap(ShenandoahHeap::heap()) {
 72 }
 73 
 74 template &lt;class T&gt;
 75 void ShenandoahUpdateRefsClosure::do_oop_work(T* p) {
 76   T o = RawAccess&lt;&gt;::oop_load(p);
 77   if (!CompressedOops::is_null(o)) {
 78     oop obj = CompressedOops::decode_not_null(o);
 79     _heap-&gt;update_with_forwarded_not_null(p, obj);
 80   }
 81 }
 82 
 83 void ShenandoahUpdateRefsClosure::do_oop(oop* p)       { do_oop_work(p); }
 84 void ShenandoahUpdateRefsClosure::do_oop(narrowOop* p) { do_oop_work(p); }
 85 
<span class="line-removed"> 86 ShenandoahTraversalUpdateRefsClosure::ShenandoahTraversalUpdateRefsClosure() :</span>
<span class="line-removed"> 87   _heap(ShenandoahHeap::heap()),</span>
<span class="line-removed"> 88   _traversal_set(ShenandoahHeap::heap()-&gt;traversal_gc()-&gt;traversal_set()) {</span>
<span class="line-removed"> 89   assert(_heap-&gt;is_traversal_mode(), &quot;Why we here?&quot;);</span>
<span class="line-removed"> 90 }</span>
<span class="line-removed"> 91 </span>
<span class="line-removed"> 92 template &lt;class T&gt;</span>
<span class="line-removed"> 93 void ShenandoahTraversalUpdateRefsClosure::do_oop_work(T* p) {</span>
<span class="line-removed"> 94   T o = RawAccess&lt;&gt;::oop_load(p);</span>
<span class="line-removed"> 95   if (!CompressedOops::is_null(o)) {</span>
<span class="line-removed"> 96     oop obj = CompressedOops::decode_not_null(o);</span>
<span class="line-removed"> 97     if (_heap-&gt;in_collection_set(obj) || _traversal_set-&gt;is_in(obj)) {</span>
<span class="line-removed"> 98       obj = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);</span>
<span class="line-removed"> 99       RawAccess&lt;IS_NOT_NULL&gt;::oop_store(p, obj);</span>
<span class="line-removed">100     } else {</span>
<span class="line-removed">101       shenandoah_assert_not_forwarded(p, obj);</span>
<span class="line-removed">102     }</span>
<span class="line-removed">103   }</span>
<span class="line-removed">104 }</span>
<span class="line-removed">105 </span>
<span class="line-removed">106 void ShenandoahTraversalUpdateRefsClosure::do_oop(oop* p)       { do_oop_work(p); }</span>
<span class="line-removed">107 void ShenandoahTraversalUpdateRefsClosure::do_oop(narrowOop* p) { do_oop_work(p); }</span>
<span class="line-removed">108 </span>
109 template &lt;DecoratorSet MO&gt;
110 ShenandoahEvacuateUpdateRootsClosure&lt;MO&gt;::ShenandoahEvacuateUpdateRootsClosure() :
111   _heap(ShenandoahHeap::heap()), _thread(Thread::current()) {
112 }
113 
114 template &lt;DecoratorSet MO&gt;
115 template &lt;class T&gt;
116 void ShenandoahEvacuateUpdateRootsClosure&lt;MO&gt;::do_oop_work(T* p) {
117   assert(_heap-&gt;is_concurrent_root_in_progress(), &quot;Only do this when evacuation is in progress&quot;);
118 
119   T o = RawAccess&lt;&gt;::oop_load(p);
120   if (! CompressedOops::is_null(o)) {
121     oop obj = CompressedOops::decode_not_null(o);
122     if (_heap-&gt;in_collection_set(obj)) {
123       assert(_heap-&gt;is_evacuation_in_progress(), &quot;Only do this when evacuation is in progress&quot;);
124       shenandoah_assert_marked(p, obj);
125       oop resolved = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);
126       if (resolved == obj) {
127         resolved = _heap-&gt;evacuate_object(obj, _thread);
128       }
</pre>
</td>
<td>
<hr />
<pre>
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 #ifndef SHARE_GC_SHENANDOAH_SHENANDOAHCLOSURES_INLINE_HPP
 25 #define SHARE_GC_SHENANDOAH_SHENANDOAHCLOSURES_INLINE_HPP
 26 
 27 #include &quot;gc/shared/barrierSetNMethod.hpp&quot;
 28 #include &quot;gc/shenandoah/shenandoahAsserts.hpp&quot;
 29 #include &quot;gc/shenandoah/shenandoahClosures.hpp&quot;
 30 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
 31 #include &quot;gc/shenandoah/shenandoahNMethod.inline.hpp&quot;

 32 #include &quot;oops/compressedOops.inline.hpp&quot;
 33 #include &quot;runtime/atomic.hpp&quot;
 34 #include &quot;runtime/thread.hpp&quot;
 35 
 36 ShenandoahForwardedIsAliveClosure::ShenandoahForwardedIsAliveClosure() :
 37   _mark_context(ShenandoahHeap::heap()-&gt;marking_context()) {
 38 }
 39 
 40 bool ShenandoahForwardedIsAliveClosure::do_object_b(oop obj) {
 41   if (CompressedOops::is_null(obj)) {
 42     return false;
 43   }
 44   obj = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);
<span class="line-modified"> 45   shenandoah_assert_not_forwarded_if(NULL, obj, ShenandoahHeap::heap()-&gt;is_concurrent_mark_in_progress());</span>


 46   return _mark_context-&gt;is_marked(obj);
 47 }
 48 
 49 ShenandoahIsAliveClosure::ShenandoahIsAliveClosure() :
 50   _mark_context(ShenandoahHeap::heap()-&gt;marking_context()) {
 51 }
 52 
 53 bool ShenandoahIsAliveClosure::do_object_b(oop obj) {
 54   if (CompressedOops::is_null(obj)) {
 55     return false;
 56   }
 57   shenandoah_assert_not_forwarded(NULL, obj);
 58   return _mark_context-&gt;is_marked(obj);
 59 }
 60 
 61 BoolObjectClosure* ShenandoahIsAliveSelector::is_alive_closure() {
 62   return ShenandoahHeap::heap()-&gt;has_forwarded_objects() ?
 63          reinterpret_cast&lt;BoolObjectClosure*&gt;(&amp;_fwd_alive_cl) :
 64          reinterpret_cast&lt;BoolObjectClosure*&gt;(&amp;_alive_cl);
 65 }
 66 
 67 ShenandoahUpdateRefsClosure::ShenandoahUpdateRefsClosure() :
 68   _heap(ShenandoahHeap::heap()) {
 69 }
 70 
 71 template &lt;class T&gt;
 72 void ShenandoahUpdateRefsClosure::do_oop_work(T* p) {
 73   T o = RawAccess&lt;&gt;::oop_load(p);
 74   if (!CompressedOops::is_null(o)) {
 75     oop obj = CompressedOops::decode_not_null(o);
 76     _heap-&gt;update_with_forwarded_not_null(p, obj);
 77   }
 78 }
 79 
 80 void ShenandoahUpdateRefsClosure::do_oop(oop* p)       { do_oop_work(p); }
 81 void ShenandoahUpdateRefsClosure::do_oop(narrowOop* p) { do_oop_work(p); }
 82 























 83 template &lt;DecoratorSet MO&gt;
 84 ShenandoahEvacuateUpdateRootsClosure&lt;MO&gt;::ShenandoahEvacuateUpdateRootsClosure() :
 85   _heap(ShenandoahHeap::heap()), _thread(Thread::current()) {
 86 }
 87 
 88 template &lt;DecoratorSet MO&gt;
 89 template &lt;class T&gt;
 90 void ShenandoahEvacuateUpdateRootsClosure&lt;MO&gt;::do_oop_work(T* p) {
 91   assert(_heap-&gt;is_concurrent_root_in_progress(), &quot;Only do this when evacuation is in progress&quot;);
 92 
 93   T o = RawAccess&lt;&gt;::oop_load(p);
 94   if (! CompressedOops::is_null(o)) {
 95     oop obj = CompressedOops::decode_not_null(o);
 96     if (_heap-&gt;in_collection_set(obj)) {
 97       assert(_heap-&gt;is_evacuation_in_progress(), &quot;Only do this when evacuation is in progress&quot;);
 98       shenandoah_assert_marked(p, obj);
 99       oop resolved = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);
100       if (resolved == obj) {
101         resolved = _heap-&gt;evacuate_object(obj, _thread);
102       }
</pre>
</td>
</tr>
</table>
<center><a href="shenandoahClosures.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahCodeRoots.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/shenandoah/shenandoahHeap.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2013, 2020, Red Hat, Inc. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;memory/allocation.hpp&quot;
  27 #include &quot;memory/universe.hpp&quot;
  28 
  29 #include &quot;gc/shared/gcArguments.hpp&quot;
  30 #include &quot;gc/shared/gcTimer.hpp&quot;
  31 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
  32 #include &quot;gc/shared/locationPrinter.inline.hpp&quot;
  33 #include &quot;gc/shared/memAllocator.hpp&quot;
  34 #include &quot;gc/shared/oopStorageSet.hpp&quot;
  35 #include &quot;gc/shared/plab.hpp&quot;
  36 
<a name="1" id="anc1"></a><span class="line-removed">  37 #include &quot;gc/shenandoah/shenandoahAllocTracker.hpp&quot;</span>
  38 #include &quot;gc/shenandoah/shenandoahBarrierSet.hpp&quot;
  39 #include &quot;gc/shenandoah/shenandoahClosures.inline.hpp&quot;
  40 #include &quot;gc/shenandoah/shenandoahCollectionSet.hpp&quot;
  41 #include &quot;gc/shenandoah/shenandoahCollectorPolicy.hpp&quot;
  42 #include &quot;gc/shenandoah/shenandoahConcurrentMark.inline.hpp&quot;
  43 #include &quot;gc/shenandoah/shenandoahConcurrentRoots.hpp&quot;
  44 #include &quot;gc/shenandoah/shenandoahControlThread.hpp&quot;
  45 #include &quot;gc/shenandoah/shenandoahFreeSet.hpp&quot;
  46 #include &quot;gc/shenandoah/shenandoahPhaseTimings.hpp&quot;
  47 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
<a name="2" id="anc2"></a><span class="line-modified">  48 #include &quot;gc/shenandoah/shenandoahHeapRegion.hpp&quot;</span>
  49 #include &quot;gc/shenandoah/shenandoahHeapRegionSet.hpp&quot;
<a name="3" id="anc3"></a>
  50 #include &quot;gc/shenandoah/shenandoahMarkCompact.hpp&quot;
  51 #include &quot;gc/shenandoah/shenandoahMarkingContext.inline.hpp&quot;
  52 #include &quot;gc/shenandoah/shenandoahMemoryPool.hpp&quot;
  53 #include &quot;gc/shenandoah/shenandoahMetrics.hpp&quot;
  54 #include &quot;gc/shenandoah/shenandoahMonitoringSupport.hpp&quot;
  55 #include &quot;gc/shenandoah/shenandoahNormalMode.hpp&quot;
  56 #include &quot;gc/shenandoah/shenandoahOopClosures.inline.hpp&quot;
  57 #include &quot;gc/shenandoah/shenandoahPacer.inline.hpp&quot;
<a name="4" id="anc4"></a>
  58 #include &quot;gc/shenandoah/shenandoahParallelCleaning.inline.hpp&quot;
  59 #include &quot;gc/shenandoah/shenandoahPassiveMode.hpp&quot;
  60 #include &quot;gc/shenandoah/shenandoahRootProcessor.inline.hpp&quot;
  61 #include &quot;gc/shenandoah/shenandoahStringDedup.hpp&quot;
  62 #include &quot;gc/shenandoah/shenandoahTaskqueue.hpp&quot;
<a name="5" id="anc5"></a><span class="line-removed">  63 #include &quot;gc/shenandoah/shenandoahTraversalMode.hpp&quot;</span>
  64 #include &quot;gc/shenandoah/shenandoahUtils.hpp&quot;
  65 #include &quot;gc/shenandoah/shenandoahVerifier.hpp&quot;
  66 #include &quot;gc/shenandoah/shenandoahCodeRoots.hpp&quot;
  67 #include &quot;gc/shenandoah/shenandoahVMOperations.hpp&quot;
  68 #include &quot;gc/shenandoah/shenandoahWorkGroup.hpp&quot;
  69 #include &quot;gc/shenandoah/shenandoahWorkerPolicy.hpp&quot;
  70 #if INCLUDE_JFR
  71 #include &quot;gc/shenandoah/shenandoahJfrSupport.hpp&quot;
  72 #endif
  73 
  74 #include &quot;memory/metaspace.hpp&quot;
  75 #include &quot;oops/compressedOops.inline.hpp&quot;
  76 #include &quot;runtime/atomic.hpp&quot;
  77 #include &quot;runtime/globals.hpp&quot;
  78 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  79 #include &quot;runtime/orderAccess.hpp&quot;
  80 #include &quot;runtime/safepointMechanism.hpp&quot;
  81 #include &quot;runtime/vmThread.hpp&quot;
  82 #include &quot;services/mallocTracker.hpp&quot;
  83 #include &quot;utilities/powerOfTwo.hpp&quot;
  84 
<a name="6" id="anc6"></a>

  85 #ifdef ASSERT
  86 template &lt;class T&gt;
  87 void ShenandoahAssertToSpaceClosure::do_oop_work(T* p) {
  88   T o = RawAccess&lt;&gt;::oop_load(p);
  89   if (! CompressedOops::is_null(o)) {
  90     oop obj = CompressedOops::decode_not_null(o);
  91     shenandoah_assert_not_forwarded(p, obj);
  92   }
  93 }
  94 
  95 void ShenandoahAssertToSpaceClosure::do_oop(narrowOop* p) { do_oop_work(p); }
  96 void ShenandoahAssertToSpaceClosure::do_oop(oop* p)       { do_oop_work(p); }
  97 #endif
  98 
  99 class ShenandoahPretouchHeapTask : public AbstractGangTask {
 100 private:
 101   ShenandoahRegionIterator _regions;
 102   const size_t _page_size;
 103 public:
 104   ShenandoahPretouchHeapTask(size_t page_size) :
 105     AbstractGangTask(&quot;Shenandoah Pretouch Heap&quot;),
 106     _page_size(page_size) {}
 107 
 108   virtual void work(uint worker_id) {
 109     ShenandoahHeapRegion* r = _regions.next();
 110     while (r != NULL) {
 111       os::pretouch_memory(r-&gt;bottom(), r-&gt;end(), _page_size);
 112       r = _regions.next();
 113     }
 114   }
 115 };
 116 
 117 class ShenandoahPretouchBitmapTask : public AbstractGangTask {
 118 private:
 119   ShenandoahRegionIterator _regions;
 120   char* _bitmap_base;
 121   const size_t _bitmap_size;
 122   const size_t _page_size;
 123 public:
 124   ShenandoahPretouchBitmapTask(char* bitmap_base, size_t bitmap_size, size_t page_size) :
 125     AbstractGangTask(&quot;Shenandoah Pretouch Bitmap&quot;),
 126     _bitmap_base(bitmap_base),
 127     _bitmap_size(bitmap_size),
 128     _page_size(page_size) {}
 129 
 130   virtual void work(uint worker_id) {
 131     ShenandoahHeapRegion* r = _regions.next();
 132     while (r != NULL) {
<a name="7" id="anc7"></a><span class="line-modified"> 133       size_t start = r-&gt;region_number()       * ShenandoahHeapRegion::region_size_bytes() / MarkBitMap::heap_map_factor();</span>
<span class="line-modified"> 134       size_t end   = (r-&gt;region_number() + 1) * ShenandoahHeapRegion::region_size_bytes() / MarkBitMap::heap_map_factor();</span>
 135       assert (end &lt;= _bitmap_size, &quot;end is sane: &quot; SIZE_FORMAT &quot; &lt; &quot; SIZE_FORMAT, end, _bitmap_size);
 136 
 137       os::pretouch_memory(_bitmap_base + start, _bitmap_base + end, _page_size);
 138 
 139       r = _regions.next();
 140     }
 141   }
 142 };
 143 
 144 jint ShenandoahHeap::initialize() {
<a name="8" id="anc8"></a><span class="line-removed"> 145   initialize_heuristics();</span>
<span class="line-removed"> 146 </span>
 147   //
 148   // Figure out heap sizing
 149   //
 150 
 151   size_t init_byte_size = InitialHeapSize;
 152   size_t min_byte_size  = MinHeapSize;
 153   size_t max_byte_size  = MaxHeapSize;
 154   size_t heap_alignment = HeapAlignment;
 155 
 156   size_t reg_size_bytes = ShenandoahHeapRegion::region_size_bytes();
 157 
 158   if (ShenandoahAlwaysPreTouch) {
 159     // Enabled pre-touch means the entire heap is committed right away.
 160     init_byte_size = max_byte_size;
 161   }
 162 
 163   Universe::check_alignment(max_byte_size,  reg_size_bytes, &quot;Shenandoah heap&quot;);
 164   Universe::check_alignment(init_byte_size, reg_size_bytes, &quot;Shenandoah heap&quot;);
 165 
 166   _num_regions = ShenandoahHeapRegion::region_count();
 167 
<a name="9" id="anc9"></a>


 168   size_t num_committed_regions = init_byte_size / reg_size_bytes;
 169   num_committed_regions = MIN2(num_committed_regions, _num_regions);
 170   assert(num_committed_regions &lt;= _num_regions, &quot;sanity&quot;);
 171   _initial_size = num_committed_regions * reg_size_bytes;
 172 
 173   size_t num_min_regions = min_byte_size / reg_size_bytes;
 174   num_min_regions = MIN2(num_min_regions, _num_regions);
 175   assert(num_min_regions &lt;= _num_regions, &quot;sanity&quot;);
 176   _minimum_size = num_min_regions * reg_size_bytes;
 177 
 178   _committed = _initial_size;
 179 
 180   size_t heap_page_size   = UseLargePages ? (size_t)os::large_page_size() : (size_t)os::vm_page_size();
 181   size_t bitmap_page_size = UseLargePages ? (size_t)os::large_page_size() : (size_t)os::vm_page_size();
<a name="10" id="anc10"></a>
 182 
 183   //
 184   // Reserve and commit memory for heap
 185   //
 186 
 187   ReservedHeapSpace heap_rs = Universe::reserve_heap(max_byte_size, heap_alignment);
 188   initialize_reserved_region(heap_rs);
 189   _heap_region = MemRegion((HeapWord*)heap_rs.base(), heap_rs.size() / HeapWordSize);
 190   _heap_region_special = heap_rs.special();
 191 
 192   assert((((size_t) base()) &amp; ShenandoahHeapRegion::region_size_bytes_mask()) == 0,
 193          &quot;Misaligned heap: &quot; PTR_FORMAT, p2i(base()));
 194 
 195 #if SHENANDOAH_OPTIMIZED_OBJTASK
 196   // The optimized ObjArrayChunkedTask takes some bits away from the full object bits.
 197   // Fail if we ever attempt to address more than we can.
 198   if ((uintptr_t)heap_rs.end() &gt;= ObjArrayChunkedTask::max_addressable()) {
 199     FormatBuffer&lt;512&gt; buf(&quot;Shenandoah reserved [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT&quot;) for the heap, \n&quot;
 200                           &quot;but max object address is &quot; PTR_FORMAT &quot;. Try to reduce heap size, or try other \n&quot;
 201                           &quot;VM options that allocate heap at lower addresses (HeapBaseMinAddress, AllocateHeapAt, etc).&quot;,
 202                 p2i(heap_rs.base()), p2i(heap_rs.end()), ObjArrayChunkedTask::max_addressable());
 203     vm_exit_during_initialization(&quot;Fatal Error&quot;, buf);
 204   }
 205 #endif
 206 
 207   ReservedSpace sh_rs = heap_rs.first_part(max_byte_size);
 208   if (!_heap_region_special) {
 209     os::commit_memory_or_exit(sh_rs.base(), _initial_size, heap_alignment, false,
 210                               &quot;Cannot commit heap memory&quot;);
 211   }
 212 
 213   //
 214   // Reserve and commit memory for bitmap(s)
 215   //
 216 
 217   _bitmap_size = MarkBitMap::compute_size(heap_rs.size());
 218   _bitmap_size = align_up(_bitmap_size, bitmap_page_size);
 219 
 220   size_t bitmap_bytes_per_region = reg_size_bytes / MarkBitMap::heap_map_factor();
 221 
 222   guarantee(bitmap_bytes_per_region != 0,
 223             &quot;Bitmap bytes per region should not be zero&quot;);
 224   guarantee(is_power_of_2(bitmap_bytes_per_region),
 225             &quot;Bitmap bytes per region should be power of two: &quot; SIZE_FORMAT, bitmap_bytes_per_region);
 226 
 227   if (bitmap_page_size &gt; bitmap_bytes_per_region) {
 228     _bitmap_regions_per_slice = bitmap_page_size / bitmap_bytes_per_region;
 229     _bitmap_bytes_per_slice = bitmap_page_size;
 230   } else {
 231     _bitmap_regions_per_slice = 1;
 232     _bitmap_bytes_per_slice = bitmap_bytes_per_region;
 233   }
 234 
 235   guarantee(_bitmap_regions_per_slice &gt;= 1,
 236             &quot;Should have at least one region per slice: &quot; SIZE_FORMAT,
 237             _bitmap_regions_per_slice);
 238 
 239   guarantee(((_bitmap_bytes_per_slice) % bitmap_page_size) == 0,
 240             &quot;Bitmap slices should be page-granular: bps = &quot; SIZE_FORMAT &quot;, page size = &quot; SIZE_FORMAT,
 241             _bitmap_bytes_per_slice, bitmap_page_size);
 242 
 243   ReservedSpace bitmap(_bitmap_size, bitmap_page_size);
 244   MemTracker::record_virtual_memory_type(bitmap.base(), mtGC);
 245   _bitmap_region = MemRegion((HeapWord*) bitmap.base(), bitmap.size() / HeapWordSize);
 246   _bitmap_region_special = bitmap.special();
 247 
 248   size_t bitmap_init_commit = _bitmap_bytes_per_slice *
 249                               align_up(num_committed_regions, _bitmap_regions_per_slice) / _bitmap_regions_per_slice;
 250   bitmap_init_commit = MIN2(_bitmap_size, bitmap_init_commit);
 251   if (!_bitmap_region_special) {
 252     os::commit_memory_or_exit((char *) _bitmap_region.start(), bitmap_init_commit, bitmap_page_size, false,
 253                               &quot;Cannot commit bitmap memory&quot;);
 254   }
 255 
 256   _marking_context = new ShenandoahMarkingContext(_heap_region, _bitmap_region, _num_regions);
 257 
 258   if (ShenandoahVerify) {
 259     ReservedSpace verify_bitmap(_bitmap_size, bitmap_page_size);
 260     if (!verify_bitmap.special()) {
 261       os::commit_memory_or_exit(verify_bitmap.base(), verify_bitmap.size(), bitmap_page_size, false,
 262                                 &quot;Cannot commit verification bitmap memory&quot;);
 263     }
 264     MemTracker::record_virtual_memory_type(verify_bitmap.base(), mtGC);
 265     MemRegion verify_bitmap_region = MemRegion((HeapWord *) verify_bitmap.base(), verify_bitmap.size() / HeapWordSize);
 266     _verification_bit_map.initialize(_heap_region, verify_bitmap_region);
 267     _verifier = new ShenandoahVerifier(this, &amp;_verification_bit_map);
 268   }
 269 
 270   // Reserve aux bitmap for use in object_iterate(). We don&#39;t commit it here.
 271   ReservedSpace aux_bitmap(_bitmap_size, bitmap_page_size);
 272   MemTracker::record_virtual_memory_type(aux_bitmap.base(), mtGC);
 273   _aux_bitmap_region = MemRegion((HeapWord*) aux_bitmap.base(), aux_bitmap.size() / HeapWordSize);
 274   _aux_bitmap_region_special = aux_bitmap.special();
 275   _aux_bit_map.initialize(_heap_region, _aux_bitmap_region);
 276 
 277   //
 278   // Create regions and region sets
 279   //
<a name="11" id="anc11"></a>









 280 
 281   _regions = NEW_C_HEAP_ARRAY(ShenandoahHeapRegion*, _num_regions, mtGC);
 282   _free_set = new ShenandoahFreeSet(this, _num_regions);
 283   _collection_set = new ShenandoahCollectionSet(this, sh_rs.base(), sh_rs.size());
 284 
 285   {
 286     ShenandoahHeapLocker locker(lock());
 287 
<a name="12" id="anc12"></a><span class="line-removed"> 288     size_t size_words = ShenandoahHeapRegion::region_size_words();</span>
<span class="line-removed"> 289 </span>
 290     for (size_t i = 0; i &lt; _num_regions; i++) {
<a name="13" id="anc13"></a><span class="line-modified"> 291       HeapWord* start = (HeapWord*)sh_rs.base() + size_words * i;</span>
 292       bool is_committed = i &lt; num_committed_regions;
<a name="14" id="anc14"></a><span class="line-modified"> 293       ShenandoahHeapRegion* r = new ShenandoahHeapRegion(this, start, size_words, i, is_committed);</span>



 294 
 295       _marking_context-&gt;initialize_top_at_mark_start(r);
 296       _regions[i] = r;
 297       assert(!collection_set()-&gt;is_in(i), &quot;New region should not be in collection set&quot;);
 298     }
 299 
 300     // Initialize to complete
 301     _marking_context-&gt;mark_complete();
 302 
 303     _free_set-&gt;rebuild();
 304   }
 305 
 306   if (ShenandoahAlwaysPreTouch) {
 307     assert(!AlwaysPreTouch, &quot;Should have been overridden&quot;);
 308 
 309     // For NUMA, it is important to pre-touch the storage under bitmaps with worker threads,
 310     // before initialize() below zeroes it with initializing thread. For any given region,
 311     // we touch the region and the corresponding bitmaps from the same thread.
 312     ShenandoahPushWorkerScope scope(workers(), _max_workers, false);
 313 
 314     size_t pretouch_heap_page_size = heap_page_size;
 315     size_t pretouch_bitmap_page_size = bitmap_page_size;
 316 
 317 #ifdef LINUX
 318     // UseTransparentHugePages would madvise that backing memory can be coalesced into huge
 319     // pages. But, the kernel needs to know that every small page is used, in order to coalesce
 320     // them into huge one. Therefore, we need to pretouch with smaller pages.
 321     if (UseTransparentHugePages) {
 322       pretouch_heap_page_size = (size_t)os::vm_page_size();
 323       pretouch_bitmap_page_size = (size_t)os::vm_page_size();
 324     }
 325 #endif
 326 
 327     // OS memory managers may want to coalesce back-to-back pages. Make their jobs
 328     // simpler by pre-touching continuous spaces (heap and bitmap) separately.
 329 
 330     log_info(gc, init)(&quot;Pretouch bitmap: &quot; SIZE_FORMAT &quot; regions, &quot; SIZE_FORMAT &quot; bytes page&quot;,
 331                        _num_regions, pretouch_bitmap_page_size);
 332     ShenandoahPretouchBitmapTask bcl(bitmap.base(), _bitmap_size, pretouch_bitmap_page_size);
 333     _workers-&gt;run_task(&amp;bcl);
 334 
 335     log_info(gc, init)(&quot;Pretouch heap: &quot; SIZE_FORMAT &quot; regions, &quot; SIZE_FORMAT &quot; bytes page&quot;,
 336                        _num_regions, pretouch_heap_page_size);
 337     ShenandoahPretouchHeapTask hcl(pretouch_heap_page_size);
 338     _workers-&gt;run_task(&amp;hcl);
 339   }
 340 
 341   //
 342   // Initialize the rest of GC subsystems
 343   //
 344 
<a name="15" id="anc15"></a><span class="line-modified"> 345   _liveness_cache = NEW_C_HEAP_ARRAY(jushort*, _max_workers, mtGC);</span>
 346   for (uint worker = 0; worker &lt; _max_workers; worker++) {
<a name="16" id="anc16"></a><span class="line-modified"> 347     _liveness_cache[worker] = NEW_C_HEAP_ARRAY(jushort, _num_regions, mtGC);</span>
<span class="line-modified"> 348     Copy::fill_to_bytes(_liveness_cache[worker], _num_regions * sizeof(jushort));</span>
 349   }
 350 
 351   // There should probably be Shenandoah-specific options for these,
 352   // just as there are G1-specific options.
 353   {
 354     ShenandoahSATBMarkQueueSet&amp; satbqs = ShenandoahBarrierSet::satb_mark_queue_set();
 355     satbqs.set_process_completed_buffers_threshold(20); // G1SATBProcessCompletedThreshold
 356     satbqs.set_buffer_enqueue_threshold_percentage(60); // G1SATBBufferEnqueueingThresholdPercent
 357   }
 358 
 359   _monitoring_support = new ShenandoahMonitoringSupport(this);
 360   _phase_timings = new ShenandoahPhaseTimings();
 361   ShenandoahStringDedup::initialize();
 362   ShenandoahCodeRoots::initialize();
 363 
 364   if (ShenandoahPacing) {
 365     _pacer = new ShenandoahPacer(this);
 366     _pacer-&gt;setup_for_idle();
 367   } else {
 368     _pacer = NULL;
 369   }
 370 
<a name="17" id="anc17"></a><span class="line-removed"> 371   _traversal_gc = strcmp(ShenandoahGCMode, &quot;traversal&quot;) == 0 ?</span>
<span class="line-removed"> 372                   new ShenandoahTraversalGC(this, _num_regions) :</span>
<span class="line-removed"> 373                   NULL;</span>
<span class="line-removed"> 374 </span>
 375   _control_thread = new ShenandoahControlThread();
 376 
 377   log_info(gc, init)(&quot;Initialize Shenandoah heap: &quot; SIZE_FORMAT &quot;%s initial, &quot; SIZE_FORMAT &quot;%s min, &quot; SIZE_FORMAT &quot;%s max&quot;,
 378                      byte_size_in_proper_unit(_initial_size),  proper_unit_for_byte_size(_initial_size),
 379                      byte_size_in_proper_unit(_minimum_size),  proper_unit_for_byte_size(_minimum_size),
 380                      byte_size_in_proper_unit(max_capacity()), proper_unit_for_byte_size(max_capacity())
 381   );
 382 
<a name="18" id="anc18"></a><span class="line-modified"> 383   log_info(gc, init)(&quot;Safepointing mechanism: %s&quot;,</span>
<span class="line-removed"> 384                      SafepointMechanism::uses_thread_local_poll() ? &quot;thread-local poll&quot; :</span>
<span class="line-removed"> 385                      (SafepointMechanism::uses_global_page_poll() ? &quot;global-page poll&quot; : &quot;unknown&quot;));</span>
 386 
 387   return JNI_OK;
 388 }
 389 
 390 void ShenandoahHeap::initialize_heuristics() {
 391   if (ShenandoahGCMode != NULL) {
<a name="19" id="anc19"></a><span class="line-modified"> 392     if (strcmp(ShenandoahGCMode, &quot;traversal&quot;) == 0) {</span>
<span class="line-removed"> 393       _gc_mode = new ShenandoahTraversalMode();</span>
<span class="line-removed"> 394     } else if (strcmp(ShenandoahGCMode, &quot;normal&quot;) == 0) {</span>
 395       _gc_mode = new ShenandoahNormalMode();
<a name="20" id="anc20"></a>

 396     } else if (strcmp(ShenandoahGCMode, &quot;passive&quot;) == 0) {
 397       _gc_mode = new ShenandoahPassiveMode();
 398     } else {
 399       vm_exit_during_initialization(&quot;Unknown -XX:ShenandoahGCMode option&quot;);
 400     }
 401   } else {
 402     ShouldNotReachHere();
 403   }
 404   _gc_mode-&gt;initialize_flags();
<a name="21" id="anc21"></a>












 405   _heuristics = _gc_mode-&gt;initialize_heuristics();
 406 
 407   if (_heuristics-&gt;is_diagnostic() &amp;&amp; !UnlockDiagnosticVMOptions) {
 408     vm_exit_during_initialization(
 409             err_msg(&quot;Heuristics \&quot;%s\&quot; is diagnostic, and must be enabled via -XX:+UnlockDiagnosticVMOptions.&quot;,
 410                     _heuristics-&gt;name()));
 411   }
 412   if (_heuristics-&gt;is_experimental() &amp;&amp; !UnlockExperimentalVMOptions) {
 413     vm_exit_during_initialization(
 414             err_msg(&quot;Heuristics \&quot;%s\&quot; is experimental, and must be enabled via -XX:+UnlockExperimentalVMOptions.&quot;,
 415                     _heuristics-&gt;name()));
 416   }
 417   log_info(gc, init)(&quot;Shenandoah heuristics: %s&quot;,
 418                      _heuristics-&gt;name());
 419 }
 420 
 421 #ifdef _MSC_VER
 422 #pragma warning( push )
 423 #pragma warning( disable:4355 ) // &#39;this&#39; : used in base member initializer list
 424 #endif
 425 
 426 ShenandoahHeap::ShenandoahHeap(ShenandoahCollectorPolicy* policy) :
 427   CollectedHeap(),
 428   _initial_size(0),
 429   _used(0),
 430   _committed(0),
 431   _bytes_allocated_since_gc_start(0),
 432   _max_workers(MAX2(ConcGCThreads, ParallelGCThreads)),
 433   _workers(NULL),
 434   _safepoint_workers(NULL),
 435   _heap_region_special(false),
 436   _num_regions(0),
 437   _regions(NULL),
 438   _update_refs_iterator(this),
 439   _control_thread(NULL),
 440   _shenandoah_policy(policy),
 441   _heuristics(NULL),
 442   _free_set(NULL),
 443   _scm(new ShenandoahConcurrentMark()),
<a name="22" id="anc22"></a><span class="line-removed"> 444   _traversal_gc(NULL),</span>
 445   _full_gc(new ShenandoahMarkCompact()),
 446   _pacer(NULL),
 447   _verifier(NULL),
 448   _phase_timings(NULL),
 449   _monitoring_support(NULL),
 450   _memory_pool(NULL),
 451   _stw_memory_manager(&quot;Shenandoah Pauses&quot;, &quot;end of GC pause&quot;),
 452   _cycle_memory_manager(&quot;Shenandoah Cycles&quot;, &quot;end of GC cycle&quot;),
 453   _gc_timer(new (ResourceObj::C_HEAP, mtGC) ConcurrentGCTimer()),
 454   _soft_ref_policy(),
 455   _log_min_obj_alignment_in_bytes(LogMinObjAlignmentInBytes),
 456   _ref_processor(NULL),
 457   _marking_context(NULL),
 458   _bitmap_size(0),
 459   _bitmap_regions_per_slice(0),
 460   _bitmap_bytes_per_slice(0),
 461   _bitmap_region_special(false),
 462   _aux_bitmap_region_special(false),
 463   _liveness_cache(NULL),
 464   _collection_set(NULL)
 465 {
<a name="23" id="anc23"></a>

 466   log_info(gc, init)(&quot;GC threads: &quot; UINT32_FORMAT &quot; parallel, &quot; UINT32_FORMAT &quot; concurrent&quot;, ParallelGCThreads, ConcGCThreads);
 467   log_info(gc, init)(&quot;Reference processing: %s&quot;, ParallelRefProcEnabled ? &quot;parallel&quot; : &quot;serial&quot;);
 468 
 469   BarrierSet::set_barrier_set(new ShenandoahBarrierSet(this));
 470 
 471   _max_workers = MAX2(_max_workers, 1U);
 472   _workers = new ShenandoahWorkGang(&quot;Shenandoah GC Threads&quot;, _max_workers,
 473                             /* are_GC_task_threads */ true,
 474                             /* are_ConcurrentGC_threads */ true);
 475   if (_workers == NULL) {
 476     vm_exit_during_initialization(&quot;Failed necessary allocation.&quot;);
 477   } else {
 478     _workers-&gt;initialize_workers();
 479   }
 480 
 481   if (ParallelGCThreads &gt; 1) {
 482     _safepoint_workers = new ShenandoahWorkGang(&quot;Safepoint Cleanup Thread&quot;,
 483                                                 ParallelGCThreads,
 484                       /* are_GC_task_threads */ false,
 485                  /* are_ConcurrentGC_threads */ false);
 486     _safepoint_workers-&gt;initialize_workers();
 487   }
 488 }
 489 
 490 #ifdef _MSC_VER
 491 #pragma warning( pop )
 492 #endif
 493 
 494 class ShenandoahResetBitmapTask : public AbstractGangTask {
 495 private:
 496   ShenandoahRegionIterator _regions;
 497 
 498 public:
 499   ShenandoahResetBitmapTask() :
 500     AbstractGangTask(&quot;Parallel Reset Bitmap Task&quot;) {}
 501 
 502   void work(uint worker_id) {
 503     ShenandoahHeapRegion* region = _regions.next();
 504     ShenandoahHeap* heap = ShenandoahHeap::heap();
 505     ShenandoahMarkingContext* const ctx = heap-&gt;marking_context();
 506     while (region != NULL) {
 507       if (heap-&gt;is_bitmap_slice_committed(region)) {
 508         ctx-&gt;clear_bitmap(region);
 509       }
 510       region = _regions.next();
 511     }
 512   }
 513 };
 514 
 515 void ShenandoahHeap::reset_mark_bitmap() {
 516   assert_gc_workers(_workers-&gt;active_workers());
 517   mark_incomplete_marking_context();
 518 
 519   ShenandoahResetBitmapTask task;
 520   _workers-&gt;run_task(&amp;task);
 521 }
 522 
 523 void ShenandoahHeap::print_on(outputStream* st) const {
 524   st-&gt;print_cr(&quot;Shenandoah Heap&quot;);
 525   st-&gt;print_cr(&quot; &quot; SIZE_FORMAT &quot;%s total, &quot; SIZE_FORMAT &quot;%s committed, &quot; SIZE_FORMAT &quot;%s used&quot;,
 526                byte_size_in_proper_unit(max_capacity()), proper_unit_for_byte_size(max_capacity()),
 527                byte_size_in_proper_unit(committed()),    proper_unit_for_byte_size(committed()),
 528                byte_size_in_proper_unit(used()),         proper_unit_for_byte_size(used()));
 529   st-&gt;print_cr(&quot; &quot; SIZE_FORMAT &quot; x &quot; SIZE_FORMAT&quot;%s regions&quot;,
 530                num_regions(),
 531                byte_size_in_proper_unit(ShenandoahHeapRegion::region_size_bytes()),
 532                proper_unit_for_byte_size(ShenandoahHeapRegion::region_size_bytes()));
 533 
 534   st-&gt;print(&quot;Status: &quot;);
 535   if (has_forwarded_objects())               st-&gt;print(&quot;has forwarded objects, &quot;);
 536   if (is_concurrent_mark_in_progress())      st-&gt;print(&quot;marking, &quot;);
 537   if (is_evacuation_in_progress())           st-&gt;print(&quot;evacuating, &quot;);
 538   if (is_update_refs_in_progress())          st-&gt;print(&quot;updating refs, &quot;);
<a name="24" id="anc24"></a><span class="line-removed"> 539   if (is_concurrent_traversal_in_progress()) st-&gt;print(&quot;traversal, &quot;);</span>
 540   if (is_degenerated_gc_in_progress())       st-&gt;print(&quot;degenerated gc, &quot;);
 541   if (is_full_gc_in_progress())              st-&gt;print(&quot;full gc, &quot;);
 542   if (is_full_gc_move_in_progress())         st-&gt;print(&quot;full gc move, &quot;);
 543   if (is_concurrent_root_in_progress())      st-&gt;print(&quot;concurrent roots, &quot;);
 544 
 545   if (cancelled_gc()) {
 546     st-&gt;print(&quot;cancelled&quot;);
 547   } else {
 548     st-&gt;print(&quot;not cancelled&quot;);
 549   }
 550   st-&gt;cr();
 551 
 552   st-&gt;print_cr(&quot;Reserved region:&quot;);
 553   st-&gt;print_cr(&quot; - [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;) &quot;,
 554                p2i(reserved_region().start()),
 555                p2i(reserved_region().end()));
 556 
 557   ShenandoahCollectionSet* cset = collection_set();
 558   st-&gt;print_cr(&quot;Collection set:&quot;);
 559   if (cset != NULL) {
 560     st-&gt;print_cr(&quot; - map (vanilla): &quot; PTR_FORMAT, p2i(cset-&gt;map_address()));
 561     st-&gt;print_cr(&quot; - map (biased):  &quot; PTR_FORMAT, p2i(cset-&gt;biased_map_address()));
 562   } else {
 563     st-&gt;print_cr(&quot; (NULL)&quot;);
 564   }
 565 
 566   st-&gt;cr();
 567   MetaspaceUtils::print_on(st);
 568 
 569   if (Verbose) {
 570     print_heap_regions_on(st);
 571   }
 572 }
 573 
 574 class ShenandoahInitWorkerGCLABClosure : public ThreadClosure {
 575 public:
 576   void do_thread(Thread* thread) {
 577     assert(thread != NULL, &quot;Sanity&quot;);
 578     assert(thread-&gt;is_Worker_thread(), &quot;Only worker thread expected&quot;);
 579     ShenandoahThreadLocalData::initialize_gclab(thread);
 580   }
 581 };
 582 
 583 void ShenandoahHeap::post_initialize() {
 584   CollectedHeap::post_initialize();
 585   MutexLocker ml(Threads_lock);
 586 
 587   ShenandoahInitWorkerGCLABClosure init_gclabs;
 588   _workers-&gt;threads_do(&amp;init_gclabs);
 589 
 590   // gclab can not be initialized early during VM startup, as it can not determinate its max_size.
 591   // Now, we will let WorkGang to initialize gclab when new worker is created.
 592   _workers-&gt;set_initialize_gclab();
 593 
 594   _scm-&gt;initialize(_max_workers);
 595   _full_gc-&gt;initialize(_gc_timer);
 596 
 597   ref_processing_init();
 598 
 599   _heuristics-&gt;initialize();
 600 
 601   JFR_ONLY(ShenandoahJFRSupport::register_jfr_type_serializers());
 602 }
 603 
 604 size_t ShenandoahHeap::used() const {
 605   return Atomic::load_acquire(&amp;_used);
 606 }
 607 
 608 size_t ShenandoahHeap::committed() const {
 609   OrderAccess::acquire();
 610   return _committed;
 611 }
 612 
 613 void ShenandoahHeap::increase_committed(size_t bytes) {
<a name="25" id="anc25"></a><span class="line-modified"> 614   assert_heaplock_or_safepoint();</span>
 615   _committed += bytes;
 616 }
 617 
 618 void ShenandoahHeap::decrease_committed(size_t bytes) {
<a name="26" id="anc26"></a><span class="line-modified"> 619   assert_heaplock_or_safepoint();</span>
 620   _committed -= bytes;
 621 }
 622 
 623 void ShenandoahHeap::increase_used(size_t bytes) {
 624   Atomic::add(&amp;_used, bytes);
 625 }
 626 
 627 void ShenandoahHeap::set_used(size_t bytes) {
 628   Atomic::release_store_fence(&amp;_used, bytes);
 629 }
 630 
 631 void ShenandoahHeap::decrease_used(size_t bytes) {
 632   assert(used() &gt;= bytes, &quot;never decrease heap size by more than we&#39;ve left&quot;);
 633   Atomic::sub(&amp;_used, bytes);
 634 }
 635 
 636 void ShenandoahHeap::increase_allocated(size_t bytes) {
 637   Atomic::add(&amp;_bytes_allocated_since_gc_start, bytes);
 638 }
 639 
 640 void ShenandoahHeap::notify_mutator_alloc_words(size_t words, bool waste) {
 641   size_t bytes = words * HeapWordSize;
 642   if (!waste) {
 643     increase_used(bytes);
 644   }
 645   increase_allocated(bytes);
 646   if (ShenandoahPacing) {
 647     control_thread()-&gt;pacing_notify_alloc(words);
 648     if (waste) {
 649       pacer()-&gt;claim_for_alloc(words, true);
 650     }
 651   }
 652 }
 653 
 654 size_t ShenandoahHeap::capacity() const {
 655   return committed();
 656 }
 657 
 658 size_t ShenandoahHeap::max_capacity() const {
 659   return _num_regions * ShenandoahHeapRegion::region_size_bytes();
 660 }
 661 
 662 size_t ShenandoahHeap::min_capacity() const {
 663   return _minimum_size;
 664 }
 665 
 666 size_t ShenandoahHeap::initial_capacity() const {
 667   return _initial_size;
 668 }
 669 
 670 bool ShenandoahHeap::is_in(const void* p) const {
 671   HeapWord* heap_base = (HeapWord*) base();
 672   HeapWord* last_region_end = heap_base + ShenandoahHeapRegion::region_size_words() * num_regions();
 673   return p &gt;= heap_base &amp;&amp; p &lt; last_region_end;
 674 }
 675 
 676 void ShenandoahHeap::op_uncommit(double shrink_before) {
 677   assert (ShenandoahUncommit, &quot;should be enabled&quot;);
 678 
 679   // Application allocates from the beginning of the heap, and GC allocates at
 680   // the end of it. It is more efficient to uncommit from the end, so that applications
 681   // could enjoy the near committed regions. GC allocations are much less frequent,
 682   // and therefore can accept the committing costs.
 683 
 684   size_t count = 0;
 685   for (size_t i = num_regions(); i &gt; 0; i--) { // care about size_t underflow
 686     ShenandoahHeapRegion* r = get_region(i - 1);
 687     if (r-&gt;is_empty_committed() &amp;&amp; (r-&gt;empty_time() &lt; shrink_before)) {
 688       ShenandoahHeapLocker locker(lock());
 689       if (r-&gt;is_empty_committed()) {
 690         // Do not uncommit below minimal capacity
 691         if (committed() &lt; min_capacity() + ShenandoahHeapRegion::region_size_bytes()) {
 692           break;
 693         }
 694 
 695         r-&gt;make_uncommitted();
 696         count++;
 697       }
 698     }
 699     SpinPause(); // allow allocators to take the lock
 700   }
 701 
 702   if (count &gt; 0) {
 703     control_thread()-&gt;notify_heap_changed();
 704   }
 705 }
 706 
 707 HeapWord* ShenandoahHeap::allocate_from_gclab_slow(Thread* thread, size_t size) {
 708   // New object should fit the GCLAB size
 709   size_t min_size = MAX2(size, PLAB::min_size());
 710 
 711   // Figure out size of new GCLAB, looking back at heuristics. Expand aggressively.
 712   size_t new_size = ShenandoahThreadLocalData::gclab_size(thread) * 2;
 713   new_size = MIN2(new_size, PLAB::max_size());
 714   new_size = MAX2(new_size, PLAB::min_size());
 715 
 716   // Record new heuristic value even if we take any shortcut. This captures
 717   // the case when moderately-sized objects always take a shortcut. At some point,
 718   // heuristics should catch up with them.
 719   ShenandoahThreadLocalData::set_gclab_size(thread, new_size);
 720 
 721   if (new_size &lt; size) {
 722     // New size still does not fit the object. Fall back to shared allocation.
 723     // This avoids retiring perfectly good GCLABs, when we encounter a large object.
 724     return NULL;
 725   }
 726 
 727   // Retire current GCLAB, and allocate a new one.
 728   PLAB* gclab = ShenandoahThreadLocalData::gclab(thread);
 729   gclab-&gt;retire();
 730 
 731   size_t actual_size = 0;
 732   HeapWord* gclab_buf = allocate_new_gclab(min_size, new_size, &amp;actual_size);
 733   if (gclab_buf == NULL) {
 734     return NULL;
 735   }
 736 
 737   assert (size &lt;= actual_size, &quot;allocation should fit&quot;);
 738 
 739   if (ZeroTLAB) {
 740     // ..and clear it.
 741     Copy::zero_to_words(gclab_buf, actual_size);
 742   } else {
 743     // ...and zap just allocated object.
 744 #ifdef ASSERT
 745     // Skip mangling the space corresponding to the object header to
 746     // ensure that the returned space is not considered parsable by
 747     // any concurrent GC thread.
 748     size_t hdr_size = oopDesc::header_size();
 749     Copy::fill_to_words(gclab_buf + hdr_size, actual_size - hdr_size, badHeapWordVal);
 750 #endif // ASSERT
 751   }
 752   gclab-&gt;set_buf(gclab_buf, actual_size);
 753   return gclab-&gt;allocate(size);
 754 }
 755 
 756 HeapWord* ShenandoahHeap::allocate_new_tlab(size_t min_size,
 757                                             size_t requested_size,
 758                                             size_t* actual_size) {
 759   ShenandoahAllocRequest req = ShenandoahAllocRequest::for_tlab(min_size, requested_size);
 760   HeapWord* res = allocate_memory(req);
 761   if (res != NULL) {
 762     *actual_size = req.actual_size();
 763   } else {
 764     *actual_size = 0;
 765   }
 766   return res;
 767 }
 768 
 769 HeapWord* ShenandoahHeap::allocate_new_gclab(size_t min_size,
 770                                              size_t word_size,
 771                                              size_t* actual_size) {
 772   ShenandoahAllocRequest req = ShenandoahAllocRequest::for_gclab(min_size, word_size);
 773   HeapWord* res = allocate_memory(req);
 774   if (res != NULL) {
 775     *actual_size = req.actual_size();
 776   } else {
 777     *actual_size = 0;
 778   }
 779   return res;
 780 }
 781 
<a name="27" id="anc27"></a><span class="line-removed"> 782 ShenandoahHeap* ShenandoahHeap::heap() {</span>
<span class="line-removed"> 783   CollectedHeap* heap = Universe::heap();</span>
<span class="line-removed"> 784   assert(heap != NULL, &quot;Unitialized access to ShenandoahHeap::heap()&quot;);</span>
<span class="line-removed"> 785   assert(heap-&gt;kind() == CollectedHeap::Shenandoah, &quot;not a shenandoah heap&quot;);</span>
<span class="line-removed"> 786   return (ShenandoahHeap*) heap;</span>
<span class="line-removed"> 787 }</span>
<span class="line-removed"> 788 </span>
<span class="line-removed"> 789 ShenandoahHeap* ShenandoahHeap::heap_no_check() {</span>
<span class="line-removed"> 790   CollectedHeap* heap = Universe::heap();</span>
<span class="line-removed"> 791   return (ShenandoahHeap*) heap;</span>
<span class="line-removed"> 792 }</span>
<span class="line-removed"> 793 </span>
 794 HeapWord* ShenandoahHeap::allocate_memory(ShenandoahAllocRequest&amp; req) {
 795   intptr_t pacer_epoch = 0;
 796   bool in_new_region = false;
 797   HeapWord* result = NULL;
 798 
 799   if (req.is_mutator_alloc()) {
 800     if (ShenandoahPacing) {
 801       pacer()-&gt;pace_for_alloc(req.size());
 802       pacer_epoch = pacer()-&gt;epoch();
 803     }
 804 
 805     if (!ShenandoahAllocFailureALot || !should_inject_alloc_failure()) {
 806       result = allocate_memory_under_lock(req, in_new_region);
 807     }
 808 
 809     // Allocation failed, block until control thread reacted, then retry allocation.
 810     //
 811     // It might happen that one of the threads requesting allocation would unblock
 812     // way later after GC happened, only to fail the second allocation, because
 813     // other threads have already depleted the free storage. In this case, a better
 814     // strategy is to try again, as long as GC makes progress.
 815     //
 816     // Then, we need to make sure the allocation was retried after at least one
 817     // Full GC, which means we want to try more than ShenandoahFullGCThreshold times.
 818 
 819     size_t tries = 0;
 820 
 821     while (result == NULL &amp;&amp; _progress_last_gc.is_set()) {
 822       tries++;
<a name="28" id="anc28"></a><span class="line-modified"> 823       control_thread()-&gt;handle_alloc_failure(req.size());</span>
 824       result = allocate_memory_under_lock(req, in_new_region);
 825     }
 826 
 827     while (result == NULL &amp;&amp; tries &lt;= ShenandoahFullGCThreshold) {
 828       tries++;
<a name="29" id="anc29"></a><span class="line-modified"> 829       control_thread()-&gt;handle_alloc_failure(req.size());</span>
 830       result = allocate_memory_under_lock(req, in_new_region);
 831     }
 832 
 833   } else {
 834     assert(req.is_gc_alloc(), &quot;Can only accept GC allocs here&quot;);
 835     result = allocate_memory_under_lock(req, in_new_region);
 836     // Do not call handle_alloc_failure() here, because we cannot block.
 837     // The allocation failure would be handled by the LRB slowpath with handle_alloc_failure_evac().
 838   }
 839 
 840   if (in_new_region) {
 841     control_thread()-&gt;notify_heap_changed();
 842   }
 843 
 844   if (result != NULL) {
 845     size_t requested = req.size();
 846     size_t actual = req.actual_size();
 847 
 848     assert (req.is_lab_alloc() || (requested == actual),
 849             &quot;Only LAB allocations are elastic: %s, requested = &quot; SIZE_FORMAT &quot;, actual = &quot; SIZE_FORMAT,
 850             ShenandoahAllocRequest::alloc_type_to_string(req.type()), requested, actual);
 851 
 852     if (req.is_mutator_alloc()) {
 853       notify_mutator_alloc_words(actual, false);
 854 
 855       // If we requested more than we were granted, give the rest back to pacer.
 856       // This only matters if we are in the same pacing epoch: do not try to unpace
 857       // over the budget for the other phase.
 858       if (ShenandoahPacing &amp;&amp; (pacer_epoch &gt; 0) &amp;&amp; (requested &gt; actual)) {
 859         pacer()-&gt;unpace_for_alloc(pacer_epoch, requested - actual);
 860       }
 861     } else {
 862       increase_used(actual*HeapWordSize);
 863     }
 864   }
 865 
 866   return result;
 867 }
 868 
 869 HeapWord* ShenandoahHeap::allocate_memory_under_lock(ShenandoahAllocRequest&amp; req, bool&amp; in_new_region) {
 870   ShenandoahHeapLocker locker(lock());
 871   return _free_set-&gt;allocate(req, in_new_region);
 872 }
 873 
 874 HeapWord* ShenandoahHeap::mem_allocate(size_t size,
 875                                         bool*  gc_overhead_limit_was_exceeded) {
 876   ShenandoahAllocRequest req = ShenandoahAllocRequest::for_shared(size);
 877   return allocate_memory(req);
 878 }
 879 
 880 MetaWord* ShenandoahHeap::satisfy_failed_metadata_allocation(ClassLoaderData* loader_data,
 881                                                              size_t size,
 882                                                              Metaspace::MetadataType mdtype) {
 883   MetaWord* result;
 884 
 885   // Inform metaspace OOM to GC heuristics if class unloading is possible.
 886   if (heuristics()-&gt;can_unload_classes()) {
 887     ShenandoahHeuristics* h = heuristics();
 888     h-&gt;record_metaspace_oom();
 889   }
 890 
 891   // Expand and retry allocation
 892   result = loader_data-&gt;metaspace_non_null()-&gt;expand_and_allocate(size, mdtype);
 893   if (result != NULL) {
 894     return result;
 895   }
 896 
 897   // Start full GC
 898   collect(GCCause::_metadata_GC_clear_soft_refs);
 899 
 900   // Retry allocation
 901   result = loader_data-&gt;metaspace_non_null()-&gt;allocate(size, mdtype);
 902   if (result != NULL) {
 903     return result;
 904   }
 905 
 906   // Expand and retry allocation
 907   result = loader_data-&gt;metaspace_non_null()-&gt;expand_and_allocate(size, mdtype);
 908   if (result != NULL) {
 909     return result;
 910   }
 911 
 912   // Out of memory
 913   return NULL;
 914 }
 915 
 916 class ShenandoahConcurrentEvacuateRegionObjectClosure : public ObjectClosure {
 917 private:
 918   ShenandoahHeap* const _heap;
 919   Thread* const _thread;
 920 public:
 921   ShenandoahConcurrentEvacuateRegionObjectClosure(ShenandoahHeap* heap) :
 922     _heap(heap), _thread(Thread::current()) {}
 923 
 924   void do_object(oop p) {
 925     shenandoah_assert_marked(NULL, p);
 926     if (!p-&gt;is_forwarded()) {
 927       _heap-&gt;evacuate_object(p, _thread);
 928     }
 929   }
 930 };
 931 
 932 class ShenandoahEvacuationTask : public AbstractGangTask {
 933 private:
 934   ShenandoahHeap* const _sh;
 935   ShenandoahCollectionSet* const _cs;
 936   bool _concurrent;
 937 public:
 938   ShenandoahEvacuationTask(ShenandoahHeap* sh,
 939                            ShenandoahCollectionSet* cs,
 940                            bool concurrent) :
 941     AbstractGangTask(&quot;Parallel Evacuation Task&quot;),
 942     _sh(sh),
 943     _cs(cs),
 944     _concurrent(concurrent)
 945   {}
 946 
 947   void work(uint worker_id) {
 948     if (_concurrent) {
 949       ShenandoahConcurrentWorkerSession worker_session(worker_id);
 950       ShenandoahSuspendibleThreadSetJoiner stsj(ShenandoahSuspendibleWorkers);
 951       ShenandoahEvacOOMScope oom_evac_scope;
 952       do_work();
 953     } else {
 954       ShenandoahParallelWorkerSession worker_session(worker_id);
 955       ShenandoahEvacOOMScope oom_evac_scope;
 956       do_work();
 957     }
 958   }
 959 
 960 private:
 961   void do_work() {
 962     ShenandoahConcurrentEvacuateRegionObjectClosure cl(_sh);
 963     ShenandoahHeapRegion* r;
 964     while ((r =_cs-&gt;claim_next()) != NULL) {
<a name="30" id="anc30"></a><span class="line-modified"> 965       assert(r-&gt;has_live(), &quot;Region &quot; SIZE_FORMAT &quot; should have been reclaimed early&quot;, r-&gt;region_number());</span>
 966       _sh-&gt;marked_object_iterate(r, &amp;cl);
 967 
 968       if (ShenandoahPacing) {
 969         _sh-&gt;pacer()-&gt;report_evac(r-&gt;used() &gt;&gt; LogHeapWordSize);
 970       }
 971 
 972       if (_sh-&gt;check_cancelled_gc_and_yield(_concurrent)) {
 973         break;
 974       }
 975     }
 976   }
 977 };
 978 
 979 void ShenandoahHeap::trash_cset_regions() {
 980   ShenandoahHeapLocker locker(lock());
 981 
 982   ShenandoahCollectionSet* set = collection_set();
 983   ShenandoahHeapRegion* r;
 984   set-&gt;clear_current_index();
 985   while ((r = set-&gt;next()) != NULL) {
 986     r-&gt;make_trash();
 987   }
 988   collection_set()-&gt;clear();
 989 }
 990 
 991 void ShenandoahHeap::print_heap_regions_on(outputStream* st) const {
 992   st-&gt;print_cr(&quot;Heap Regions:&quot;);
 993   st-&gt;print_cr(&quot;EU=empty-uncommitted, EC=empty-committed, R=regular, H=humongous start, HC=humongous continuation, CS=collection set, T=trash, P=pinned&quot;);
 994   st-&gt;print_cr(&quot;BTE=bottom/top/end, U=used, T=TLAB allocs, G=GCLAB allocs, S=shared allocs, L=live data&quot;);
<a name="31" id="anc31"></a><span class="line-modified"> 995   st-&gt;print_cr(&quot;R=root, CP=critical pins, TAMS=top-at-mark-start (previous, next)&quot;);</span>
<span class="line-modified"> 996   st-&gt;print_cr(&quot;SN=alloc sequence numbers (first mutator, last mutator, first gc, last gc)&quot;);</span>
 997 
 998   for (size_t i = 0; i &lt; num_regions(); i++) {
 999     get_region(i)-&gt;print_on(st);
1000   }
1001 }
1002 
1003 void ShenandoahHeap::trash_humongous_region_at(ShenandoahHeapRegion* start) {
1004   assert(start-&gt;is_humongous_start(), &quot;reclaim regions starting with the first one&quot;);
1005 
1006   oop humongous_obj = oop(start-&gt;bottom());
1007   size_t size = humongous_obj-&gt;size();
1008   size_t required_regions = ShenandoahHeapRegion::required_regions(size * HeapWordSize);
<a name="32" id="anc32"></a><span class="line-modified">1009   size_t index = start-&gt;region_number() + required_regions - 1;</span>
1010 
1011   assert(!start-&gt;has_live(), &quot;liveness must be zero&quot;);
1012 
1013   for(size_t i = 0; i &lt; required_regions; i++) {
1014     // Reclaim from tail. Otherwise, assertion fails when printing region to trace log,
1015     // as it expects that every region belongs to a humongous region starting with a humongous start region.
1016     ShenandoahHeapRegion* region = get_region(index --);
1017 
1018     assert(region-&gt;is_humongous(), &quot;expect correct humongous start or continuation&quot;);
1019     assert(!region-&gt;is_cset(), &quot;Humongous region should not be in collection set&quot;);
1020 
1021     region-&gt;make_trash_immediate();
1022   }
1023 }
1024 
1025 class ShenandoahRetireGCLABClosure : public ThreadClosure {
1026 public:
1027   void do_thread(Thread* thread) {
1028     PLAB* gclab = ShenandoahThreadLocalData::gclab(thread);
1029     assert(gclab != NULL, &quot;GCLAB should be initialized for %s&quot;, thread-&gt;name());
1030     gclab-&gt;retire();
1031   }
1032 };
1033 
1034 void ShenandoahHeap::make_parsable(bool retire_tlabs) {
1035   if (UseTLAB) {
1036     CollectedHeap::ensure_parsability(retire_tlabs);
1037   }
1038   ShenandoahRetireGCLABClosure cl;
1039   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *t = jtiwh.next(); ) {
1040     cl.do_thread(t);
1041   }
1042   workers()-&gt;threads_do(&amp;cl);
1043 }
1044 
1045 void ShenandoahHeap::resize_tlabs() {
1046   CollectedHeap::resize_all_tlabs();
1047 }
1048 
1049 class ShenandoahEvacuateUpdateRootsTask : public AbstractGangTask {
1050 private:
1051   ShenandoahRootEvacuator* _rp;
1052 
1053 public:
1054   ShenandoahEvacuateUpdateRootsTask(ShenandoahRootEvacuator* rp) :
1055     AbstractGangTask(&quot;Shenandoah evacuate and update roots&quot;),
1056     _rp(rp) {}
1057 
1058   void work(uint worker_id) {
1059     ShenandoahParallelWorkerSession worker_session(worker_id);
1060     ShenandoahEvacOOMScope oom_evac_scope;
1061     ShenandoahEvacuateUpdateRootsClosure&lt;&gt; cl;
1062     MarkingCodeBlobClosure blobsCl(&amp;cl, CodeBlobToOopClosure::FixRelocations);
1063     _rp-&gt;roots_do(worker_id, &amp;cl);
1064   }
1065 };
1066 
1067 void ShenandoahHeap::evacuate_and_update_roots() {
1068 #if COMPILER2_OR_JVMCI
1069   DerivedPointerTable::clear();
1070 #endif
1071   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Only iterate roots while world is stopped&quot;);
1072   {
1073     // Include concurrent roots if current cycle can not process those roots concurrently
1074     ShenandoahRootEvacuator rp(workers()-&gt;active_workers(),
1075                                ShenandoahPhaseTimings::init_evac,
1076                                !ShenandoahConcurrentRoots::should_do_concurrent_roots(),
1077                                !ShenandoahConcurrentRoots::should_do_concurrent_class_unloading());
1078     ShenandoahEvacuateUpdateRootsTask roots_task(&amp;rp);
1079     workers()-&gt;run_task(&amp;roots_task);
1080   }
1081 
1082 #if COMPILER2_OR_JVMCI
1083   DerivedPointerTable::update_pointers();
1084 #endif
1085 }
1086 
1087 // Returns size in bytes
1088 size_t ShenandoahHeap::unsafe_max_tlab_alloc(Thread *thread) const {
1089   if (ShenandoahElasticTLAB) {
1090     // With Elastic TLABs, return the max allowed size, and let the allocation path
1091     // figure out the safe size for current allocation.
1092     return ShenandoahHeapRegion::max_tlab_size_bytes();
1093   } else {
1094     return MIN2(_free_set-&gt;unsafe_peek_free(), ShenandoahHeapRegion::max_tlab_size_bytes());
1095   }
1096 }
1097 
1098 size_t ShenandoahHeap::max_tlab_size() const {
1099   // Returns size in words
1100   return ShenandoahHeapRegion::max_tlab_size_words();
1101 }
1102 
1103 class ShenandoahRetireAndResetGCLABClosure : public ThreadClosure {
1104 public:
1105   void do_thread(Thread* thread) {
1106     PLAB* gclab = ShenandoahThreadLocalData::gclab(thread);
1107     gclab-&gt;retire();
1108     if (ShenandoahThreadLocalData::gclab_size(thread) &gt; 0) {
1109       ShenandoahThreadLocalData::set_gclab_size(thread, 0);
1110     }
1111   }
1112 };
1113 
1114 void ShenandoahHeap::retire_and_reset_gclabs() {
1115   ShenandoahRetireAndResetGCLABClosure cl;
1116   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *t = jtiwh.next(); ) {
1117     cl.do_thread(t);
1118   }
1119   workers()-&gt;threads_do(&amp;cl);
1120 }
1121 
1122 void ShenandoahHeap::collect(GCCause::Cause cause) {
1123   control_thread()-&gt;request_gc(cause);
1124 }
1125 
1126 void ShenandoahHeap::do_full_collection(bool clear_all_soft_refs) {
1127   //assert(false, &quot;Shouldn&#39;t need to do full collections&quot;);
1128 }
1129 
1130 HeapWord* ShenandoahHeap::block_start(const void* addr) const {
<a name="33" id="anc33"></a><span class="line-modified">1131   Space* sp = heap_region_containing(addr);</span>
<span class="line-modified">1132   if (sp != NULL) {</span>
<span class="line-modified">1133     return sp-&gt;block_start(addr);</span>
1134   }
1135   return NULL;
1136 }
1137 
1138 bool ShenandoahHeap::block_is_obj(const HeapWord* addr) const {
<a name="34" id="anc34"></a><span class="line-modified">1139   Space* sp = heap_region_containing(addr);</span>
<span class="line-modified">1140   return sp-&gt;block_is_obj(addr);</span>
1141 }
1142 
1143 bool ShenandoahHeap::print_location(outputStream* st, void* addr) const {
1144   return BlockLocationPrinter&lt;ShenandoahHeap&gt;::print_location(st, addr);
1145 }
1146 
1147 jlong ShenandoahHeap::millis_since_last_gc() {
1148   double v = heuristics()-&gt;time_since_last_gc() * 1000;
1149   assert(0 &lt;= v &amp;&amp; v &lt;= max_jlong, &quot;value should fit: %f&quot;, v);
1150   return (jlong)v;
1151 }
1152 
1153 void ShenandoahHeap::prepare_for_verify() {
1154   if (SafepointSynchronize::is_at_safepoint() || ! UseTLAB) {
1155     make_parsable(false);
1156   }
1157 }
1158 
1159 void ShenandoahHeap::print_gc_threads_on(outputStream* st) const {
1160   workers()-&gt;print_worker_threads_on(st);
1161   if (ShenandoahStringDedup::is_enabled()) {
1162     ShenandoahStringDedup::print_worker_threads_on(st);
1163   }
1164 }
1165 
1166 void ShenandoahHeap::gc_threads_do(ThreadClosure* tcl) const {
1167   workers()-&gt;threads_do(tcl);
1168   if (_safepoint_workers != NULL) {
1169     _safepoint_workers-&gt;threads_do(tcl);
1170   }
1171   if (ShenandoahStringDedup::is_enabled()) {
1172     ShenandoahStringDedup::threads_do(tcl);
1173   }
1174 }
1175 
1176 void ShenandoahHeap::print_tracing_info() const {
1177   LogTarget(Info, gc, stats) lt;
1178   if (lt.is_enabled()) {
1179     ResourceMark rm;
1180     LogStream ls(lt);
1181 
1182     phase_timings()-&gt;print_on(&amp;ls);
1183 
1184     ls.cr();
1185     ls.cr();
1186 
1187     shenandoah_policy()-&gt;print_gc_stats(&amp;ls);
1188 
1189     ls.cr();
1190     ls.cr();
1191 
1192     if (ShenandoahPacing) {
1193       pacer()-&gt;print_on(&amp;ls);
1194     }
1195 
1196     ls.cr();
1197     ls.cr();
1198   }
1199 }
1200 
1201 void ShenandoahHeap::verify(VerifyOption vo) {
1202   if (ShenandoahSafepoint::is_at_shenandoah_safepoint()) {
1203     if (ShenandoahVerify) {
1204       verifier()-&gt;verify_generic(vo);
1205     } else {
1206       // TODO: Consider allocating verification bitmaps on demand,
1207       // and turn this on unconditionally.
1208     }
1209   }
1210 }
1211 size_t ShenandoahHeap::tlab_capacity(Thread *thr) const {
1212   return _free_set-&gt;capacity();
1213 }
1214 
1215 class ObjectIterateScanRootClosure : public BasicOopIterateClosure {
1216 private:
1217   MarkBitMap* _bitmap;
1218   Stack&lt;oop,mtGC&gt;* _oop_stack;
1219   ShenandoahHeap* const _heap;
1220   ShenandoahMarkingContext* const _marking_context;
1221 
1222   template &lt;class T&gt;
1223   void do_oop_work(T* p) {
1224     T o = RawAccess&lt;&gt;::oop_load(p);
1225     if (!CompressedOops::is_null(o)) {
1226       oop obj = CompressedOops::decode_not_null(o);
1227       if (_heap-&gt;is_concurrent_root_in_progress() &amp;&amp; !_marking_context-&gt;is_marked(obj)) {
1228         // There may be dead oops in weak roots in concurrent root phase, do not touch them.
1229         return;
1230       }
1231       obj = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);
1232 
1233       assert(oopDesc::is_oop(obj), &quot;must be a valid oop&quot;);
1234       if (!_bitmap-&gt;is_marked(obj)) {
1235         _bitmap-&gt;mark(obj);
1236         _oop_stack-&gt;push(obj);
1237       }
1238     }
1239   }
1240 public:
1241   ObjectIterateScanRootClosure(MarkBitMap* bitmap, Stack&lt;oop,mtGC&gt;* oop_stack) :
1242     _bitmap(bitmap), _oop_stack(oop_stack), _heap(ShenandoahHeap::heap()),
1243     _marking_context(_heap-&gt;marking_context()) {}
1244   void do_oop(oop* p)       { do_oop_work(p); }
1245   void do_oop(narrowOop* p) { do_oop_work(p); }
1246 };
1247 
1248 /*
1249  * This is public API, used in preparation of object_iterate().
1250  * Since we don&#39;t do linear scan of heap in object_iterate() (see comment below), we don&#39;t
1251  * need to make the heap parsable. For Shenandoah-internal linear heap scans that we can
1252  * control, we call SH::make_tlabs_parsable().
1253  */
1254 void ShenandoahHeap::ensure_parsability(bool retire_tlabs) {
1255   // No-op.
1256 }
1257 
1258 /*
1259  * Iterates objects in the heap. This is public API, used for, e.g., heap dumping.
1260  *
1261  * We cannot safely iterate objects by doing a linear scan at random points in time. Linear
1262  * scanning needs to deal with dead objects, which may have dead Klass* pointers (e.g.
1263  * calling oopDesc::size() would crash) or dangling reference fields (crashes) etc. Linear
1264  * scanning therefore depends on having a valid marking bitmap to support it. However, we only
1265  * have a valid marking bitmap after successful marking. In particular, we *don&#39;t* have a valid
1266  * marking bitmap during marking, after aborted marking or during/after cleanup (when we just
1267  * wiped the bitmap in preparation for next marking).
1268  *
1269  * For all those reasons, we implement object iteration as a single marking traversal, reporting
1270  * objects as we mark+traverse through the heap, starting from GC roots. JVMTI IterateThroughHeap
1271  * is allowed to report dead objects, but is not required to do so.
1272  */
1273 void ShenandoahHeap::object_iterate(ObjectClosure* cl) {
1274   assert(SafepointSynchronize::is_at_safepoint(), &quot;safe iteration is only available during safepoints&quot;);
1275   if (!_aux_bitmap_region_special &amp;&amp; !os::commit_memory((char*)_aux_bitmap_region.start(), _aux_bitmap_region.byte_size(), false)) {
1276     log_warning(gc)(&quot;Could not commit native memory for auxiliary marking bitmap for heap iteration&quot;);
1277     return;
1278   }
1279 
1280   // Reset bitmap
1281   _aux_bit_map.clear();
1282 
1283   Stack&lt;oop,mtGC&gt; oop_stack;
1284 
1285   // First, we process GC roots according to current GC cycle. This populates the work stack with initial objects.
1286   ShenandoahHeapIterationRootScanner rp;
1287   ObjectIterateScanRootClosure oops(&amp;_aux_bit_map, &amp;oop_stack);
1288 
1289   rp.roots_do(&amp;oops);
1290 
1291   // Work through the oop stack to traverse heap.
1292   while (! oop_stack.is_empty()) {
1293     oop obj = oop_stack.pop();
1294     assert(oopDesc::is_oop(obj), &quot;must be a valid oop&quot;);
1295     cl-&gt;do_object(obj);
1296     obj-&gt;oop_iterate(&amp;oops);
1297   }
1298 
1299   assert(oop_stack.is_empty(), &quot;should be empty&quot;);
1300 
1301   if (!_aux_bitmap_region_special &amp;&amp; !os::uncommit_memory((char*)_aux_bitmap_region.start(), _aux_bitmap_region.byte_size())) {
1302     log_warning(gc)(&quot;Could not uncommit native memory for auxiliary marking bitmap for heap iteration&quot;);
1303   }
1304 }
1305 
1306 // Keep alive an object that was loaded with AS_NO_KEEPALIVE.
1307 void ShenandoahHeap::keep_alive(oop obj) {
1308   if (is_concurrent_mark_in_progress()) {
1309     ShenandoahBarrierSet::barrier_set()-&gt;enqueue(obj);
1310   }
1311 }
1312 
1313 void ShenandoahHeap::heap_region_iterate(ShenandoahHeapRegionClosure* blk) const {
1314   for (size_t i = 0; i &lt; num_regions(); i++) {
1315     ShenandoahHeapRegion* current = get_region(i);
1316     blk-&gt;heap_region_do(current);
1317   }
1318 }
1319 
1320 class ShenandoahParallelHeapRegionTask : public AbstractGangTask {
1321 private:
1322   ShenandoahHeap* const _heap;
1323   ShenandoahHeapRegionClosure* const _blk;
1324 
<a name="35" id="anc35"></a><span class="line-modified">1325   DEFINE_PAD_MINUS_SIZE(0, DEFAULT_CACHE_LINE_SIZE, sizeof(volatile size_t));</span>
1326   volatile size_t _index;
<a name="36" id="anc36"></a><span class="line-modified">1327   DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, 0);</span>
1328 
1329 public:
1330   ShenandoahParallelHeapRegionTask(ShenandoahHeapRegionClosure* blk) :
1331           AbstractGangTask(&quot;Parallel Region Task&quot;),
1332           _heap(ShenandoahHeap::heap()), _blk(blk), _index(0) {}
1333 
1334   void work(uint worker_id) {
1335     size_t stride = ShenandoahParallelRegionStride;
1336 
1337     size_t max = _heap-&gt;num_regions();
1338     while (_index &lt; max) {
1339       size_t cur = Atomic::fetch_and_add(&amp;_index, stride);
1340       size_t start = cur;
1341       size_t end = MIN2(cur + stride, max);
1342       if (start &gt;= max) break;
1343 
1344       for (size_t i = cur; i &lt; end; i++) {
1345         ShenandoahHeapRegion* current = _heap-&gt;get_region(i);
1346         _blk-&gt;heap_region_do(current);
1347       }
1348     }
1349   }
1350 };
1351 
1352 void ShenandoahHeap::parallel_heap_region_iterate(ShenandoahHeapRegionClosure* blk) const {
1353   assert(blk-&gt;is_thread_safe(), &quot;Only thread-safe closures here&quot;);
1354   if (num_regions() &gt; ShenandoahParallelRegionStride) {
1355     ShenandoahParallelHeapRegionTask task(blk);
1356     workers()-&gt;run_task(&amp;task);
1357   } else {
1358     heap_region_iterate(blk);
1359   }
1360 }
1361 
<a name="37" id="anc37"></a><span class="line-modified">1362 class ShenandoahClearLivenessClosure : public ShenandoahHeapRegionClosure {</span>
1363 private:
1364   ShenandoahMarkingContext* const _ctx;
1365 public:
<a name="38" id="anc38"></a><span class="line-modified">1366   ShenandoahClearLivenessClosure() : _ctx(ShenandoahHeap::heap()-&gt;marking_context()) {}</span>
1367 
1368   void heap_region_do(ShenandoahHeapRegion* r) {
1369     if (r-&gt;is_active()) {
1370       r-&gt;clear_live_data();
1371       _ctx-&gt;capture_top_at_mark_start(r);
1372     } else {
<a name="39" id="anc39"></a><span class="line-modified">1373       assert(!r-&gt;has_live(), &quot;Region &quot; SIZE_FORMAT &quot; should have no live data&quot;, r-&gt;region_number());</span>
1374       assert(_ctx-&gt;top_at_mark_start(r) == r-&gt;top(),
<a name="40" id="anc40"></a><span class="line-modified">1375              &quot;Region &quot; SIZE_FORMAT &quot; should already have correct TAMS&quot;, r-&gt;region_number());</span>
1376     }
1377   }
1378 
1379   bool is_thread_safe() { return true; }
1380 };
1381 
1382 void ShenandoahHeap::op_init_mark() {
1383   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Should be at safepoint&quot;);
1384   assert(Thread::current()-&gt;is_VM_thread(), &quot;can only do this in VMThread&quot;);
1385 
1386   assert(marking_context()-&gt;is_bitmap_clear(), &quot;need clear marking bitmap&quot;);
1387   assert(!marking_context()-&gt;is_complete(), &quot;should not be complete&quot;);
<a name="41" id="anc41"></a>
1388 
1389   if (ShenandoahVerify) {
1390     verifier()-&gt;verify_before_concmark();
1391   }
1392 
1393   if (VerifyBeforeGC) {
1394     Universe::verify();
1395   }
1396 
1397   set_concurrent_mark_in_progress(true);
1398   // We need to reset all TLABs because we&#39;d lose marks on all objects allocated in them.
1399   {
<a name="42" id="anc42"></a><span class="line-modified">1400     ShenandoahGCPhase phase(ShenandoahPhaseTimings::make_parsable);</span>
1401     make_parsable(true);
1402   }
1403 
1404   {
<a name="43" id="anc43"></a><span class="line-modified">1405     ShenandoahGCPhase phase(ShenandoahPhaseTimings::clear_liveness);</span>
<span class="line-modified">1406     ShenandoahClearLivenessClosure clc;</span>
<span class="line-modified">1407     parallel_heap_region_iterate(&amp;clc);</span>
1408   }
1409 
1410   // Make above changes visible to worker threads
1411   OrderAccess::fence();
1412 
1413   concurrent_mark()-&gt;mark_roots(ShenandoahPhaseTimings::scan_roots);
1414 
1415   if (UseTLAB) {
<a name="44" id="anc44"></a><span class="line-modified">1416     ShenandoahGCPhase phase(ShenandoahPhaseTimings::resize_tlabs);</span>
1417     resize_tlabs();
1418   }
1419 
1420   if (ShenandoahPacing) {
1421     pacer()-&gt;setup_for_mark();
1422   }
<a name="45" id="anc45"></a>






1423 }
1424 
1425 void ShenandoahHeap::op_mark() {
1426   concurrent_mark()-&gt;mark_from_roots();
1427 }
1428 
<a name="46" id="anc46"></a><span class="line-modified">1429 class ShenandoahCompleteLivenessClosure : public ShenandoahHeapRegionClosure {</span>
1430 private:
1431   ShenandoahMarkingContext* const _ctx;
<a name="47" id="anc47"></a>

1432 public:
<a name="48" id="anc48"></a><span class="line-modified">1433   ShenandoahCompleteLivenessClosure() : _ctx(ShenandoahHeap::heap()-&gt;complete_marking_context()) {}</span>

1434 
1435   void heap_region_do(ShenandoahHeapRegion* r) {
1436     if (r-&gt;is_active()) {
<a name="49" id="anc49"></a>

1437       HeapWord *tams = _ctx-&gt;top_at_mark_start(r);
1438       HeapWord *top = r-&gt;top();
1439       if (top &gt; tams) {
1440         r-&gt;increase_live_data_alloc_words(pointer_delta(top, tams));
1441       }
<a name="50" id="anc50"></a>


















1442     } else {
<a name="51" id="anc51"></a><span class="line-modified">1443       assert(!r-&gt;has_live(), &quot;Region &quot; SIZE_FORMAT &quot; should have no live data&quot;, r-&gt;region_number());</span>
1444       assert(_ctx-&gt;top_at_mark_start(r) == r-&gt;top(),
<a name="52" id="anc52"></a><span class="line-modified">1445              &quot;Region &quot; SIZE_FORMAT &quot; should have correct TAMS&quot;, r-&gt;region_number());</span>
1446     }
1447   }
1448 
1449   bool is_thread_safe() { return true; }
1450 };
1451 
1452 void ShenandoahHeap::op_final_mark() {
1453   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Should be at safepoint&quot;);
<a name="53" id="anc53"></a>
1454 
1455   // It is critical that we
1456   // evacuate roots right after finishing marking, so that we don&#39;t
1457   // get unmarked objects in the roots.
1458 
1459   if (!cancelled_gc()) {
1460     concurrent_mark()-&gt;finish_mark_from_roots(/* full_gc = */ false);
1461 
1462     // Marking is completed, deactivate SATB barrier
1463     set_concurrent_mark_in_progress(false);
1464     mark_complete_marking_context();
1465 
1466     parallel_cleaning(false /* full gc*/);
1467 
<a name="54" id="anc54"></a><span class="line-removed">1468     if (has_forwarded_objects()) {</span>
<span class="line-removed">1469       // Degen may be caused by failed evacuation of roots</span>
<span class="line-removed">1470       if (is_degenerated_gc_in_progress()) {</span>
<span class="line-removed">1471         concurrent_mark()-&gt;update_roots(ShenandoahPhaseTimings::degen_gc_update_roots);</span>
<span class="line-removed">1472       } else {</span>
<span class="line-removed">1473         concurrent_mark()-&gt;update_thread_roots(ShenandoahPhaseTimings::update_roots);</span>
<span class="line-removed">1474       }</span>
<span class="line-removed">1475       set_has_forwarded_objects(false);</span>
<span class="line-removed">1476    }</span>
<span class="line-removed">1477 </span>
1478     if (ShenandoahVerify) {
1479       verifier()-&gt;verify_roots_no_forwarded();
1480     }
<a name="55" id="anc55"></a><span class="line-modified">1481     // All allocations past TAMS are implicitly live, adjust the region data.</span>
<span class="line-removed">1482     // Bitmaps/TAMS are swapped at this point, so we need to poll complete bitmap.</span>
1483     {
<a name="56" id="anc56"></a><span class="line-modified">1484       ShenandoahGCPhase phase(ShenandoahPhaseTimings::complete_liveness);</span>
<span class="line-modified">1485       ShenandoahCompleteLivenessClosure cl;</span>
1486       parallel_heap_region_iterate(&amp;cl);
<a name="57" id="anc57"></a>

1487     }
1488 
1489     // Force the threads to reacquire their TLABs outside the collection set.
1490     {
<a name="58" id="anc58"></a><span class="line-modified">1491       ShenandoahGCPhase phase(ShenandoahPhaseTimings::retire_tlabs);</span>
1492       make_parsable(true);
1493     }
1494 
<a name="59" id="anc59"></a><span class="line-removed">1495     // We are about to select the collection set, make sure it knows about</span>
<span class="line-removed">1496     // current pinning status. Also, this allows trashing more regions that</span>
<span class="line-removed">1497     // now have their pinning status dropped.</span>
<span class="line-removed">1498     {</span>
<span class="line-removed">1499       ShenandoahGCPhase phase(ShenandoahPhaseTimings::sync_pinned);</span>
<span class="line-removed">1500       sync_pinned_region_status();</span>
<span class="line-removed">1501     }</span>
<span class="line-removed">1502 </span>
<span class="line-removed">1503     // Trash the collection set left over from previous cycle, if any.</span>
<span class="line-removed">1504     {</span>
<span class="line-removed">1505       ShenandoahGCPhase phase(ShenandoahPhaseTimings::trash_cset);</span>
<span class="line-removed">1506       trash_cset_regions();</span>
<span class="line-removed">1507     }</span>
<span class="line-removed">1508 </span>
1509     {
<a name="60" id="anc60"></a><span class="line-modified">1510       ShenandoahGCPhase phase(ShenandoahPhaseTimings::prepare_evac);</span>
<span class="line-removed">1511 </span>
1512       ShenandoahHeapLocker locker(lock());
1513       _collection_set-&gt;clear();
<a name="61" id="anc61"></a><span class="line-removed">1514       _free_set-&gt;clear();</span>
<span class="line-removed">1515 </span>
1516       heuristics()-&gt;choose_collection_set(_collection_set);
<a name="62" id="anc62"></a>
1517 
<a name="63" id="anc63"></a>


1518       _free_set-&gt;rebuild();
1519     }
1520 
1521     if (!is_degenerated_gc_in_progress()) {
1522       prepare_concurrent_roots();
1523       prepare_concurrent_unloading();
1524     }
1525 
1526     // If collection set has candidates, start evacuation.
1527     // Otherwise, bypass the rest of the cycle.
1528     if (!collection_set()-&gt;is_empty()) {
<a name="64" id="anc64"></a><span class="line-modified">1529       ShenandoahGCPhase init_evac(ShenandoahPhaseTimings::init_evac);</span>
1530 
1531       if (ShenandoahVerify) {
1532         verifier()-&gt;verify_before_evacuation();
1533       }
1534 
1535       set_evacuation_in_progress(true);
1536       // From here on, we need to update references.
1537       set_has_forwarded_objects(true);
1538 
1539       if (!is_degenerated_gc_in_progress()) {
1540         if (ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {
1541           ShenandoahCodeRoots::arm_nmethods();
1542         }
1543         evacuate_and_update_roots();
1544       }
1545 
1546       if (ShenandoahPacing) {
1547         pacer()-&gt;setup_for_evac();
1548       }
1549 
1550       if (ShenandoahVerify) {
1551         ShenandoahRootVerifier::RootTypes types = ShenandoahRootVerifier::None;
1552         if (ShenandoahConcurrentRoots::should_do_concurrent_roots()) {
1553           types = ShenandoahRootVerifier::combine(ShenandoahRootVerifier::JNIHandleRoots, ShenandoahRootVerifier::WeakRoots);
1554           types = ShenandoahRootVerifier::combine(types, ShenandoahRootVerifier::CLDGRoots);
1555           types = ShenandoahRootVerifier::combine(types, ShenandoahRootVerifier::StringDedupRoots);
1556         }
1557 
1558         if (ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {
1559           types = ShenandoahRootVerifier::combine(types, ShenandoahRootVerifier::CodeRoots);
1560         }
1561         verifier()-&gt;verify_roots_no_forwarded_except(types);
1562         verifier()-&gt;verify_during_evacuation();
1563       }
1564     } else {
1565       if (ShenandoahVerify) {
1566         verifier()-&gt;verify_after_concmark();
1567       }
1568 
1569       if (VerifyAfterGC) {
1570         Universe::verify();
1571       }
1572     }
1573 
1574   } else {
1575     // If this cycle was updating references, we need to keep the has_forwarded_objects
1576     // flag on, for subsequent phases to deal with it.
1577     concurrent_mark()-&gt;cancel();
1578     set_concurrent_mark_in_progress(false);
1579 
1580     if (process_references()) {
1581       // Abandon reference processing right away: pre-cleaning must have failed.
1582       ReferenceProcessor *rp = ref_processor();
1583       rp-&gt;disable_discovery();
1584       rp-&gt;abandon_partial_discovery();
1585       rp-&gt;verify_no_references_recorded();
1586     }
1587   }
1588 }
1589 
<a name="65" id="anc65"></a><span class="line-removed">1590 void ShenandoahHeap::op_final_evac() {</span>
<span class="line-removed">1591   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Should be at safepoint&quot;);</span>
<span class="line-removed">1592 </span>
<span class="line-removed">1593   set_evacuation_in_progress(false);</span>
<span class="line-removed">1594 </span>
<span class="line-removed">1595   {</span>
<span class="line-removed">1596     ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_evac_retire_gclabs);</span>
<span class="line-removed">1597     retire_and_reset_gclabs();</span>
<span class="line-removed">1598   }</span>
<span class="line-removed">1599 </span>
<span class="line-removed">1600   if (ShenandoahVerify) {</span>
<span class="line-removed">1601     verifier()-&gt;verify_after_evacuation();</span>
<span class="line-removed">1602   }</span>
<span class="line-removed">1603 </span>
<span class="line-removed">1604   if (VerifyAfterGC) {</span>
<span class="line-removed">1605     Universe::verify();</span>
<span class="line-removed">1606   }</span>
<span class="line-removed">1607 }</span>
<span class="line-removed">1608 </span>
1609 void ShenandoahHeap::op_conc_evac() {
1610   ShenandoahEvacuationTask task(this, _collection_set, true);
1611   workers()-&gt;run_task(&amp;task);
1612 }
1613 
1614 void ShenandoahHeap::op_stw_evac() {
1615   ShenandoahEvacuationTask task(this, _collection_set, false);
1616   workers()-&gt;run_task(&amp;task);
1617 }
1618 
1619 void ShenandoahHeap::op_updaterefs() {
1620   update_heap_references(true);
1621 }
1622 
1623 void ShenandoahHeap::op_cleanup() {
1624   free_set()-&gt;recycle_trash();
1625 }
1626 
1627 class ShenandoahConcurrentRootsEvacUpdateTask : public AbstractGangTask {
1628 private:
1629   ShenandoahVMRoots&lt;true /*concurrent*/&gt;        _vm_roots;
1630   ShenandoahWeakRoots&lt;true /*concurrent*/&gt;      _weak_roots;
1631   ShenandoahClassLoaderDataRoots&lt;true /*concurrent*/, false /*single threaded*/&gt; _cld_roots;
1632   ShenandoahConcurrentStringDedupRoots          _dedup_roots;
1633   bool                                          _include_weak_roots;
1634 
1635 public:
1636   ShenandoahConcurrentRootsEvacUpdateTask(bool include_weak_roots) :
1637     AbstractGangTask(&quot;Shenandoah Evacuate/Update Concurrent Roots Task&quot;),
1638     _include_weak_roots(include_weak_roots) {
1639   }
1640 
1641   void work(uint worker_id) {
1642     ShenandoahEvacOOMScope oom;
1643     {
1644       // vm_roots and weak_roots are OopStorage backed roots, concurrent iteration
1645       // may race against OopStorage::release() calls.
1646       ShenandoahEvacUpdateOopStorageRootsClosure cl;
1647       _vm_roots.oops_do&lt;ShenandoahEvacUpdateOopStorageRootsClosure&gt;(&amp;cl);
1648 
1649       if (_include_weak_roots) {
1650         _weak_roots.oops_do&lt;ShenandoahEvacUpdateOopStorageRootsClosure&gt;(&amp;cl);
1651       }
1652     }
1653 
1654     {
1655       ShenandoahEvacuateUpdateRootsClosure&lt;&gt; cl;
1656       CLDToOopClosure clds(&amp;cl, ClassLoaderData::_claim_strong);
1657       _cld_roots.cld_do(&amp;clds);
1658     }
1659 
1660     {
1661       ShenandoahForwardedIsAliveClosure is_alive;
1662       ShenandoahEvacuateUpdateRootsClosure&lt;MO_RELEASE&gt; keep_alive;
1663       _dedup_roots.oops_do(&amp;is_alive, &amp;keep_alive, worker_id);
1664     }
1665   }
1666 };
1667 
1668 class ShenandoahEvacUpdateCleanupOopStorageRootsClosure : public BasicOopIterateClosure {
1669 private:
1670   ShenandoahHeap* const _heap;
1671   ShenandoahMarkingContext* const _mark_context;
1672   bool  _evac_in_progress;
1673   Thread* const _thread;
1674   size_t  _dead_counter;
1675 
1676 public:
1677   ShenandoahEvacUpdateCleanupOopStorageRootsClosure();
1678   void do_oop(oop* p);
1679   void do_oop(narrowOop* p);
1680 
1681   size_t dead_counter() const;
1682   void reset_dead_counter();
1683 };
1684 
1685 ShenandoahEvacUpdateCleanupOopStorageRootsClosure::ShenandoahEvacUpdateCleanupOopStorageRootsClosure() :
1686   _heap(ShenandoahHeap::heap()),
1687   _mark_context(ShenandoahHeap::heap()-&gt;marking_context()),
1688   _evac_in_progress(ShenandoahHeap::heap()-&gt;is_evacuation_in_progress()),
1689   _thread(Thread::current()),
1690   _dead_counter(0) {
1691 }
1692 
1693 void ShenandoahEvacUpdateCleanupOopStorageRootsClosure::do_oop(oop* p) {
1694   const oop obj = RawAccess&lt;&gt;::oop_load(p);
1695   if (!CompressedOops::is_null(obj)) {
1696     if (!_mark_context-&gt;is_marked(obj)) {
1697       shenandoah_assert_correct(p, obj);
1698       oop old = Atomic::cmpxchg(p, obj, oop(NULL));
1699       if (obj == old) {
1700         _dead_counter ++;
1701       }
1702     } else if (_evac_in_progress &amp;&amp; _heap-&gt;in_collection_set(obj)) {
1703       oop resolved = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);
1704       if (resolved == obj) {
1705         resolved = _heap-&gt;evacuate_object(obj, _thread);
1706       }
1707       Atomic::cmpxchg(p, obj, resolved);
1708       assert(_heap-&gt;cancelled_gc() ||
1709              _mark_context-&gt;is_marked(resolved) &amp;&amp; !_heap-&gt;in_collection_set(resolved),
1710              &quot;Sanity&quot;);
1711     }
1712   }
1713 }
1714 
1715 void ShenandoahEvacUpdateCleanupOopStorageRootsClosure::do_oop(narrowOop* p) {
1716   ShouldNotReachHere();
1717 }
1718 
1719 size_t ShenandoahEvacUpdateCleanupOopStorageRootsClosure::dead_counter() const {
1720   return _dead_counter;
1721 }
1722 
1723 void ShenandoahEvacUpdateCleanupOopStorageRootsClosure::reset_dead_counter() {
1724   _dead_counter = 0;
1725 }
1726 
1727 // This task not only evacuates/updates marked weak roots, but also &quot;NULL&quot;
1728 // dead weak roots.
1729 class ShenandoahConcurrentWeakRootsEvacUpdateTask : public AbstractGangTask {
1730 private:
1731   ShenandoahWeakRoot&lt;true /*concurrent*/&gt;  _jni_roots;
1732   ShenandoahWeakRoot&lt;true /*concurrent*/&gt;  _string_table_roots;
1733   ShenandoahWeakRoot&lt;true /*concurrent*/&gt;  _resolved_method_table_roots;
1734   ShenandoahWeakRoot&lt;true /*concurrent*/&gt;  _vm_roots;
1735 
1736 public:
1737   ShenandoahConcurrentWeakRootsEvacUpdateTask() :
1738     AbstractGangTask(&quot;Shenandoah Concurrent Weak Root Task&quot;),
1739     _jni_roots(OopStorageSet::jni_weak(), ShenandoahPhaseTimings::JNIWeakRoots),
1740     _string_table_roots(OopStorageSet::string_table_weak(), ShenandoahPhaseTimings::StringTableRoots),
1741     _resolved_method_table_roots(OopStorageSet::resolved_method_table_weak(), ShenandoahPhaseTimings::ResolvedMethodTableRoots),
1742     _vm_roots(OopStorageSet::vm_weak(), ShenandoahPhaseTimings::VMWeakRoots) {
1743     StringTable::reset_dead_counter();
1744     ResolvedMethodTable::reset_dead_counter();
1745   }
1746 
1747   ~ShenandoahConcurrentWeakRootsEvacUpdateTask() {
1748     StringTable::finish_dead_counter();
1749     ResolvedMethodTable::finish_dead_counter();
1750   }
1751 
1752   void work(uint worker_id) {
1753     ShenandoahEvacOOMScope oom;
1754     // jni_roots and weak_roots are OopStorage backed roots, concurrent iteration
1755     // may race against OopStorage::release() calls.
1756     ShenandoahEvacUpdateCleanupOopStorageRootsClosure cl;
1757     _jni_roots.oops_do(&amp;cl, worker_id);
1758     _vm_roots.oops_do(&amp;cl, worker_id);
1759 
1760     cl.reset_dead_counter();
1761     _string_table_roots.oops_do(&amp;cl, worker_id);
1762     StringTable::inc_dead_counter(cl.dead_counter());
1763 
1764     cl.reset_dead_counter();
1765     _resolved_method_table_roots.oops_do(&amp;cl, worker_id);
1766     ResolvedMethodTable::inc_dead_counter(cl.dead_counter());
1767   }
1768 };
1769 
1770 void ShenandoahHeap::op_roots() {
1771   if (is_concurrent_root_in_progress()) {
1772     if (ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {
1773       // Concurrent weak root processing
1774       ShenandoahConcurrentWeakRootsEvacUpdateTask task;
1775       workers()-&gt;run_task(&amp;task);
1776 
1777       _unloader.unload();
1778     }
1779 
1780     if (ShenandoahConcurrentRoots::should_do_concurrent_roots()) {
1781       ShenandoahConcurrentRootsEvacUpdateTask task(!ShenandoahConcurrentRoots::should_do_concurrent_class_unloading());
1782       workers()-&gt;run_task(&amp;task);
1783     }
1784   }
1785 
1786   set_concurrent_root_in_progress(false);
1787 }
1788 
1789 void ShenandoahHeap::op_reset() {
1790   if (ShenandoahPacing) {
1791     pacer()-&gt;setup_for_reset();
1792   }
1793   reset_mark_bitmap();
1794 }
1795 
1796 void ShenandoahHeap::op_preclean() {
1797   if (ShenandoahPacing) {
1798     pacer()-&gt;setup_for_preclean();
1799   }
1800   concurrent_mark()-&gt;preclean_weak_refs();
1801 }
1802 
<a name="66" id="anc66"></a><span class="line-removed">1803 void ShenandoahHeap::op_init_traversal() {</span>
<span class="line-removed">1804   traversal_gc()-&gt;init_traversal_collection();</span>
<span class="line-removed">1805 }</span>
<span class="line-removed">1806 </span>
<span class="line-removed">1807 void ShenandoahHeap::op_traversal() {</span>
<span class="line-removed">1808   traversal_gc()-&gt;concurrent_traversal_collection();</span>
<span class="line-removed">1809 }</span>
<span class="line-removed">1810 </span>
<span class="line-removed">1811 void ShenandoahHeap::op_final_traversal() {</span>
<span class="line-removed">1812   traversal_gc()-&gt;final_traversal_collection();</span>
<span class="line-removed">1813 }</span>
<span class="line-removed">1814 </span>
1815 void ShenandoahHeap::op_full(GCCause::Cause cause) {
1816   ShenandoahMetricsSnapshot metrics;
1817   metrics.snap_before();
1818 
1819   full_gc()-&gt;do_it(cause);
1820   if (UseTLAB) {
<a name="67" id="anc67"></a><span class="line-modified">1821     ShenandoahGCPhase phase(ShenandoahPhaseTimings::full_gc_resize_tlabs);</span>
1822     resize_all_tlabs();
1823   }
1824 
1825   metrics.snap_after();
1826 
1827   if (metrics.is_good_progress()) {
1828     _progress_last_gc.set();
1829   } else {
1830     // Nothing to do. Tell the allocation path that we have failed to make
1831     // progress, and it can finally fail.
1832     _progress_last_gc.unset();
1833   }
1834 }
1835 
1836 void ShenandoahHeap::op_degenerated(ShenandoahDegenPoint point) {
1837   // Degenerated GC is STW, but it can also fail. Current mechanics communicates
1838   // GC failure via cancelled_concgc() flag. So, if we detect the failure after
1839   // some phase, we have to upgrade the Degenerate GC to Full GC.
1840 
1841   clear_cancelled_gc();
1842 
1843   ShenandoahMetricsSnapshot metrics;
1844   metrics.snap_before();
1845 
1846   switch (point) {
<a name="68" id="anc68"></a><span class="line-removed">1847     case _degenerated_traversal:</span>
<span class="line-removed">1848       {</span>
<span class="line-removed">1849         // Drop the collection set. Note: this leaves some already forwarded objects</span>
<span class="line-removed">1850         // behind, which may be problematic, see comments for ShenandoahEvacAssist</span>
<span class="line-removed">1851         // workarounds in ShenandoahTraversalHeuristics.</span>
<span class="line-removed">1852 </span>
<span class="line-removed">1853         ShenandoahHeapLocker locker(lock());</span>
<span class="line-removed">1854         collection_set()-&gt;clear_current_index();</span>
<span class="line-removed">1855         for (size_t i = 0; i &lt; collection_set()-&gt;count(); i++) {</span>
<span class="line-removed">1856           ShenandoahHeapRegion* r = collection_set()-&gt;next();</span>
<span class="line-removed">1857           r-&gt;make_regular_bypass();</span>
<span class="line-removed">1858         }</span>
<span class="line-removed">1859         collection_set()-&gt;clear();</span>
<span class="line-removed">1860       }</span>
<span class="line-removed">1861       op_final_traversal();</span>
<span class="line-removed">1862       op_cleanup();</span>
<span class="line-removed">1863       return;</span>
<span class="line-removed">1864 </span>
1865     // The cases below form the Duff&#39;s-like device: it describes the actual GC cycle,
1866     // but enters it at different points, depending on which concurrent phase had
1867     // degenerated.
1868 
1869     case _degenerated_outside_cycle:
1870       // We have degenerated from outside the cycle, which means something is bad with
1871       // the heap, most probably heavy humongous fragmentation, or we are very low on free
1872       // space. It makes little sense to wait for Full GC to reclaim as much as it can, when
1873       // we can do the most aggressive degen cycle, which includes processing references and
1874       // class unloading, unless those features are explicitly disabled.
1875       //
1876       // Note that we can only do this for &quot;outside-cycle&quot; degens, otherwise we would risk
1877       // changing the cycle parameters mid-cycle during concurrent -&gt; degenerated handover.
1878       set_process_references(heuristics()-&gt;can_process_references());
1879       set_unload_classes(heuristics()-&gt;can_unload_classes());
1880 
<a name="69" id="anc69"></a><span class="line-removed">1881       if (is_traversal_mode()) {</span>
<span class="line-removed">1882         // Not possible to degenerate from here, upgrade to Full GC right away.</span>
<span class="line-removed">1883         cancel_gc(GCCause::_shenandoah_upgrade_to_full_gc);</span>
<span class="line-removed">1884         op_degenerated_fail();</span>
<span class="line-removed">1885         return;</span>
<span class="line-removed">1886       }</span>
<span class="line-removed">1887 </span>
1888       op_reset();
1889 
1890       op_init_mark();
1891       if (cancelled_gc()) {
1892         op_degenerated_fail();
1893         return;
1894       }
1895 
1896     case _degenerated_mark:
1897       op_final_mark();
1898       if (cancelled_gc()) {
1899         op_degenerated_fail();
1900         return;
1901       }
1902 
<a name="70" id="anc70"></a>






1903       op_cleanup();
1904 
1905     case _degenerated_evac:
1906       // If heuristics thinks we should do the cycle, this flag would be set,
1907       // and we can do evacuation. Otherwise, it would be the shortcut cycle.
1908       if (is_evacuation_in_progress()) {
1909 
1910         // Degeneration under oom-evac protocol might have left some objects in
1911         // collection set un-evacuated. Restart evacuation from the beginning to
1912         // capture all objects. For all the objects that are already evacuated,
1913         // it would be a simple check, which is supposed to be fast. This is also
1914         // safe to do even without degeneration, as CSet iterator is at beginning
1915         // in preparation for evacuation anyway.
1916         //
1917         // Before doing that, we need to make sure we never had any cset-pinned
1918         // regions. This may happen if allocation failure happened when evacuating
1919         // the about-to-be-pinned object, oom-evac protocol left the object in
1920         // the collection set, and then the pin reached the cset region. If we continue
1921         // the cycle here, we would trash the cset and alive objects in it. To avoid
1922         // it, we fail degeneration right away and slide into Full GC to recover.
1923 
1924         {
1925           sync_pinned_region_status();
1926           collection_set()-&gt;clear_current_index();
1927 
1928           ShenandoahHeapRegion* r;
1929           while ((r = collection_set()-&gt;next()) != NULL) {
1930             if (r-&gt;is_pinned()) {
1931               cancel_gc(GCCause::_shenandoah_upgrade_to_full_gc);
1932               op_degenerated_fail();
1933               return;
1934             }
1935           }
1936 
1937           collection_set()-&gt;clear_current_index();
1938         }
1939 
1940         op_stw_evac();
1941         if (cancelled_gc()) {
1942           op_degenerated_fail();
1943           return;
1944         }
1945       }
1946 
1947       // If heuristics thinks we should do the cycle, this flag would be set,
1948       // and we need to do update-refs. Otherwise, it would be the shortcut cycle.
1949       if (has_forwarded_objects()) {
1950         op_init_updaterefs();
1951         if (cancelled_gc()) {
1952           op_degenerated_fail();
1953           return;
1954         }
1955       }
1956 
1957     case _degenerated_updaterefs:
1958       if (has_forwarded_objects()) {
1959         op_final_updaterefs();
1960         if (cancelled_gc()) {
1961           op_degenerated_fail();
1962           return;
1963         }
1964       }
1965 
1966       op_cleanup();
1967       break;
1968 
1969     default:
1970       ShouldNotReachHere();
1971   }
1972 
1973   if (ShenandoahVerify) {
1974     verifier()-&gt;verify_after_degenerated();
1975   }
1976 
1977   if (VerifyAfterGC) {
1978     Universe::verify();
1979   }
1980 
1981   metrics.snap_after();
1982 
1983   // Check for futility and fail. There is no reason to do several back-to-back Degenerated cycles,
1984   // because that probably means the heap is overloaded and/or fragmented.
1985   if (!metrics.is_good_progress()) {
1986     _progress_last_gc.unset();
1987     cancel_gc(GCCause::_shenandoah_upgrade_to_full_gc);
1988     op_degenerated_futile();
1989   } else {
1990     _progress_last_gc.set();
1991   }
1992 }
1993 
1994 void ShenandoahHeap::op_degenerated_fail() {
1995   log_info(gc)(&quot;Cannot finish degeneration, upgrading to Full GC&quot;);
1996   shenandoah_policy()-&gt;record_degenerated_upgrade_to_full();
1997   op_full(GCCause::_shenandoah_upgrade_to_full_gc);
1998 }
1999 
2000 void ShenandoahHeap::op_degenerated_futile() {
2001   shenandoah_policy()-&gt;record_degenerated_upgrade_to_full();
2002   op_full(GCCause::_shenandoah_upgrade_to_full_gc);
2003 }
2004 
2005 void ShenandoahHeap::force_satb_flush_all_threads() {
<a name="71" id="anc71"></a><span class="line-modified">2006   if (!is_concurrent_mark_in_progress() &amp;&amp; !is_concurrent_traversal_in_progress()) {</span>
2007     // No need to flush SATBs
2008     return;
2009   }
2010 
2011   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *t = jtiwh.next(); ) {
2012     ShenandoahThreadLocalData::set_force_satb_flush(t, true);
2013   }
2014   // The threads are not &quot;acquiring&quot; their thread-local data, but it does not
2015   // hurt to &quot;release&quot; the updates here anyway.
2016   OrderAccess::fence();
2017 }
2018 
2019 void ShenandoahHeap::set_gc_state_all_threads(char state) {
2020   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *t = jtiwh.next(); ) {
2021     ShenandoahThreadLocalData::set_gc_state(t, state);
2022   }
2023 }
2024 
2025 void ShenandoahHeap::set_gc_state_mask(uint mask, bool value) {
2026   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Should really be Shenandoah safepoint&quot;);
2027   _gc_state.set_cond(mask, value);
2028   set_gc_state_all_threads(_gc_state.raw_value());
2029 }
2030 
2031 void ShenandoahHeap::set_concurrent_mark_in_progress(bool in_progress) {
2032   if (has_forwarded_objects()) {
2033     set_gc_state_mask(MARKING | UPDATEREFS, in_progress);
2034   } else {
2035     set_gc_state_mask(MARKING, in_progress);
2036   }
2037   ShenandoahBarrierSet::satb_mark_queue_set().set_active_all_threads(in_progress, !in_progress);
2038 }
2039 
<a name="72" id="anc72"></a><span class="line-removed">2040 void ShenandoahHeap::set_concurrent_traversal_in_progress(bool in_progress) {</span>
<span class="line-removed">2041    set_gc_state_mask(TRAVERSAL, in_progress);</span>
<span class="line-removed">2042    ShenandoahBarrierSet::satb_mark_queue_set().set_active_all_threads(in_progress, !in_progress);</span>
<span class="line-removed">2043 }</span>
<span class="line-removed">2044 </span>
2045 void ShenandoahHeap::set_evacuation_in_progress(bool in_progress) {
2046   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Only call this at safepoint&quot;);
2047   set_gc_state_mask(EVACUATION, in_progress);
2048 }
2049 
2050 void ShenandoahHeap::set_concurrent_root_in_progress(bool in_progress) {
2051   assert(ShenandoahConcurrentRoots::can_do_concurrent_roots(), &quot;Why set the flag?&quot;);
2052   if (in_progress) {
2053     _concurrent_root_in_progress.set();
2054   } else {
2055     _concurrent_root_in_progress.unset();
2056   }
2057 }
2058 
2059 void ShenandoahHeap::ref_processing_init() {
2060   assert(_max_workers &gt; 0, &quot;Sanity&quot;);
2061 
2062   _ref_processor =
2063     new ReferenceProcessor(&amp;_subject_to_discovery,  // is_subject_to_discovery
2064                            ParallelRefProcEnabled,  // MT processing
2065                            _max_workers,            // Degree of MT processing
2066                            true,                    // MT discovery
2067                            _max_workers,            // Degree of MT discovery
2068                            false,                   // Reference discovery is not atomic
2069                            NULL,                    // No closure, should be installed before use
2070                            true);                   // Scale worker threads
2071 
2072   shenandoah_assert_rp_isalive_not_installed();
2073 }
2074 
2075 GCTracer* ShenandoahHeap::tracer() {
2076   return shenandoah_policy()-&gt;tracer();
2077 }
2078 
2079 size_t ShenandoahHeap::tlab_used(Thread* thread) const {
2080   return _free_set-&gt;used();
2081 }
2082 
2083 bool ShenandoahHeap::try_cancel_gc() {
2084   while (true) {
2085     jbyte prev = _cancelled_gc.cmpxchg(CANCELLED, CANCELLABLE);
2086     if (prev == CANCELLABLE) return true;
2087     else if (prev == CANCELLED) return false;
2088     assert(ShenandoahSuspendibleWorkers, &quot;should not get here when not using suspendible workers&quot;);
2089     assert(prev == NOT_CANCELLED, &quot;must be NOT_CANCELLED&quot;);
2090     if (Thread::current()-&gt;is_Java_thread()) {
2091       // We need to provide a safepoint here, otherwise we might
2092       // spin forever if a SP is pending.
2093       ThreadBlockInVM sp(JavaThread::current());
2094       SpinPause();
2095     }
2096   }
2097 }
2098 
2099 void ShenandoahHeap::cancel_gc(GCCause::Cause cause) {
2100   if (try_cancel_gc()) {
2101     FormatBuffer&lt;&gt; msg(&quot;Cancelling GC: %s&quot;, GCCause::to_string(cause));
2102     log_info(gc)(&quot;%s&quot;, msg.buffer());
2103     Events::log(Thread::current(), &quot;%s&quot;, msg.buffer());
2104   }
2105 }
2106 
2107 uint ShenandoahHeap::max_workers() {
2108   return _max_workers;
2109 }
2110 
2111 void ShenandoahHeap::stop() {
2112   // The shutdown sequence should be able to terminate when GC is running.
2113 
2114   // Step 0. Notify policy to disable event recording.
2115   _shenandoah_policy-&gt;record_shutdown();
2116 
2117   // Step 1. Notify control thread that we are in shutdown.
2118   // Note that we cannot do that with stop(), because stop() is blocking and waits for the actual shutdown.
2119   // Doing stop() here would wait for the normal GC cycle to complete, never falling through to cancel below.
2120   control_thread()-&gt;prepare_for_graceful_shutdown();
2121 
2122   // Step 2. Notify GC workers that we are cancelling GC.
2123   cancel_gc(GCCause::_shenandoah_stop_vm);
2124 
2125   // Step 3. Wait until GC worker exits normally.
2126   control_thread()-&gt;stop();
2127 
2128   // Step 4. Stop String Dedup thread if it is active
2129   if (ShenandoahStringDedup::is_enabled()) {
2130     ShenandoahStringDedup::stop();
2131   }
2132 }
2133 
2134 void ShenandoahHeap::stw_unload_classes(bool full_gc) {
2135   if (!unload_classes()) return;
2136   bool purged_class;
2137 
2138   // Unload classes and purge SystemDictionary.
2139   {
<a name="73" id="anc73"></a><span class="line-modified">2140     ShenandoahGCPhase phase(full_gc ?</span>
<span class="line-modified">2141                             ShenandoahPhaseTimings::full_gc_purge_class_unload :</span>
<span class="line-modified">2142                             ShenandoahPhaseTimings::purge_class_unload);</span>
2143     purged_class = SystemDictionary::do_unloading(gc_timer());
2144   }
2145 
2146   {
<a name="74" id="anc74"></a><span class="line-modified">2147     ShenandoahGCPhase phase(full_gc ?</span>
<span class="line-modified">2148                             ShenandoahPhaseTimings::full_gc_purge_par :</span>
<span class="line-modified">2149                             ShenandoahPhaseTimings::purge_par);</span>
2150     ShenandoahIsAliveSelector is_alive;
2151     uint num_workers = _workers-&gt;active_workers();
2152     ShenandoahClassUnloadingTask unlink_task(is_alive.is_alive_closure(), num_workers, purged_class);
2153     _workers-&gt;run_task(&amp;unlink_task);
2154   }
2155 
2156   {
<a name="75" id="anc75"></a><span class="line-modified">2157     ShenandoahGCPhase phase(full_gc ?</span>
<span class="line-modified">2158                             ShenandoahPhaseTimings::full_gc_purge_cldg :</span>
<span class="line-modified">2159                             ShenandoahPhaseTimings::purge_cldg);</span>
2160     ClassLoaderDataGraph::purge();
2161   }
2162   // Resize and verify metaspace
2163   MetaspaceGC::compute_new_size();
2164   MetaspaceUtils::verify_metrics();
2165 }
2166 
2167 // Weak roots are either pre-evacuated (final mark) or updated (final updaterefs),
2168 // so they should not have forwarded oops.
2169 // However, we do need to &quot;null&quot; dead oops in the roots, if can not be done
2170 // in concurrent cycles.
2171 void ShenandoahHeap::stw_process_weak_roots(bool full_gc) {
<a name="76" id="anc76"></a><span class="line-modified">2172   ShenandoahGCPhase root_phase(full_gc ?</span>
<span class="line-modified">2173                                ShenandoahPhaseTimings::full_gc_purge :</span>
<span class="line-modified">2174                                ShenandoahPhaseTimings::purge);</span>
2175   uint num_workers = _workers-&gt;active_workers();
2176   ShenandoahPhaseTimings::Phase timing_phase = full_gc ?
2177                                                ShenandoahPhaseTimings::full_gc_purge_par :
2178                                                ShenandoahPhaseTimings::purge_par;
<a name="77" id="anc77"></a>


2179   // Cleanup weak roots
<a name="78" id="anc78"></a><span class="line-removed">2180   ShenandoahGCPhase phase(timing_phase);</span>
<span class="line-removed">2181   phase_timings()-&gt;record_workers_start(timing_phase);</span>
2182   if (has_forwarded_objects()) {
<a name="79" id="anc79"></a><span class="line-modified">2183     if (is_traversal_mode()) {</span>
<span class="line-modified">2184       ShenandoahForwardedIsAliveClosure is_alive;</span>
<span class="line-modified">2185       ShenandoahTraversalUpdateRefsClosure keep_alive;</span>
<span class="line-modified">2186       ShenandoahParallelWeakRootsCleaningTask&lt;ShenandoahForwardedIsAliveClosure, ShenandoahTraversalUpdateRefsClosure&gt;</span>
<span class="line-modified">2187         cleaning_task(&amp;is_alive, &amp;keep_alive, num_workers, !ShenandoahConcurrentRoots::should_do_concurrent_class_unloading());</span>
<span class="line-removed">2188       _workers-&gt;run_task(&amp;cleaning_task);</span>
<span class="line-removed">2189     } else {</span>
<span class="line-removed">2190       ShenandoahForwardedIsAliveClosure is_alive;</span>
<span class="line-removed">2191       ShenandoahUpdateRefsClosure keep_alive;</span>
<span class="line-removed">2192       ShenandoahParallelWeakRootsCleaningTask&lt;ShenandoahForwardedIsAliveClosure, ShenandoahUpdateRefsClosure&gt;</span>
<span class="line-removed">2193         cleaning_task(&amp;is_alive, &amp;keep_alive, num_workers, !ShenandoahConcurrentRoots::should_do_concurrent_class_unloading());</span>
<span class="line-removed">2194       _workers-&gt;run_task(&amp;cleaning_task);</span>
<span class="line-removed">2195     }</span>
2196   } else {
2197     ShenandoahIsAliveClosure is_alive;
2198 #ifdef ASSERT
2199     ShenandoahAssertNotForwardedClosure verify_cl;
2200     ShenandoahParallelWeakRootsCleaningTask&lt;ShenandoahIsAliveClosure, ShenandoahAssertNotForwardedClosure&gt;
2201       cleaning_task(&amp;is_alive, &amp;verify_cl, num_workers, !ShenandoahConcurrentRoots::should_do_concurrent_class_unloading());
2202 #else
2203     ShenandoahParallelWeakRootsCleaningTask&lt;ShenandoahIsAliveClosure, DoNothingClosure&gt;
2204       cleaning_task(&amp;is_alive, &amp;do_nothing_cl, num_workers, !ShenandoahConcurrentRoots::should_do_concurrent_class_unloading());
2205 #endif
2206     _workers-&gt;run_task(&amp;cleaning_task);
2207   }
<a name="80" id="anc80"></a><span class="line-removed">2208   phase_timings()-&gt;record_workers_end(timing_phase);</span>
2209 }
2210 
2211 void ShenandoahHeap::parallel_cleaning(bool full_gc) {
2212   assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at a safepoint&quot;);
2213   stw_process_weak_roots(full_gc);
2214   if (!ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {
2215     stw_unload_classes(full_gc);
2216   }
2217 }
2218 
2219 void ShenandoahHeap::set_has_forwarded_objects(bool cond) {
<a name="81" id="anc81"></a><span class="line-modified">2220   if (is_traversal_mode()) {</span>
<span class="line-removed">2221     set_gc_state_mask(HAS_FORWARDED | UPDATEREFS, cond);</span>
<span class="line-removed">2222   } else {</span>
<span class="line-removed">2223     set_gc_state_mask(HAS_FORWARDED, cond);</span>
<span class="line-removed">2224   }</span>
<span class="line-removed">2225 </span>
2226 }
2227 
2228 void ShenandoahHeap::set_process_references(bool pr) {
2229   _process_references.set_cond(pr);
2230 }
2231 
2232 void ShenandoahHeap::set_unload_classes(bool uc) {
2233   _unload_classes.set_cond(uc);
2234 }
2235 
2236 bool ShenandoahHeap::process_references() const {
2237   return _process_references.is_set();
2238 }
2239 
2240 bool ShenandoahHeap::unload_classes() const {
2241   return _unload_classes.is_set();
2242 }
2243 
2244 address ShenandoahHeap::in_cset_fast_test_addr() {
2245   ShenandoahHeap* heap = ShenandoahHeap::heap();
2246   assert(heap-&gt;collection_set() != NULL, &quot;Sanity&quot;);
2247   return (address) heap-&gt;collection_set()-&gt;biased_map_address();
2248 }
2249 
2250 address ShenandoahHeap::cancelled_gc_addr() {
2251   return (address) ShenandoahHeap::heap()-&gt;_cancelled_gc.addr_of();
2252 }
2253 
2254 address ShenandoahHeap::gc_state_addr() {
2255   return (address) ShenandoahHeap::heap()-&gt;_gc_state.addr_of();
2256 }
2257 
2258 size_t ShenandoahHeap::bytes_allocated_since_gc_start() {
2259   return Atomic::load_acquire(&amp;_bytes_allocated_since_gc_start);
2260 }
2261 
2262 void ShenandoahHeap::reset_bytes_allocated_since_gc_start() {
2263   Atomic::release_store_fence(&amp;_bytes_allocated_since_gc_start, (size_t)0);
2264 }
2265 
2266 void ShenandoahHeap::set_degenerated_gc_in_progress(bool in_progress) {
2267   _degenerated_gc_in_progress.set_cond(in_progress);
2268 }
2269 
2270 void ShenandoahHeap::set_full_gc_in_progress(bool in_progress) {
2271   _full_gc_in_progress.set_cond(in_progress);
2272 }
2273 
2274 void ShenandoahHeap::set_full_gc_move_in_progress(bool in_progress) {
2275   assert (is_full_gc_in_progress(), &quot;should be&quot;);
2276   _full_gc_move_in_progress.set_cond(in_progress);
2277 }
2278 
2279 void ShenandoahHeap::set_update_refs_in_progress(bool in_progress) {
2280   set_gc_state_mask(UPDATEREFS, in_progress);
2281 }
2282 
2283 void ShenandoahHeap::register_nmethod(nmethod* nm) {
2284   ShenandoahCodeRoots::register_nmethod(nm);
2285 }
2286 
2287 void ShenandoahHeap::unregister_nmethod(nmethod* nm) {
2288   ShenandoahCodeRoots::unregister_nmethod(nm);
2289 }
2290 
2291 void ShenandoahHeap::flush_nmethod(nmethod* nm) {
2292   ShenandoahCodeRoots::flush_nmethod(nm);
2293 }
2294 
2295 oop ShenandoahHeap::pin_object(JavaThread* thr, oop o) {
2296   heap_region_containing(o)-&gt;record_pin();
2297   return o;
2298 }
2299 
2300 void ShenandoahHeap::unpin_object(JavaThread* thr, oop o) {
2301   heap_region_containing(o)-&gt;record_unpin();
2302 }
2303 
2304 void ShenandoahHeap::sync_pinned_region_status() {
2305   ShenandoahHeapLocker locker(lock());
2306 
2307   for (size_t i = 0; i &lt; num_regions(); i++) {
2308     ShenandoahHeapRegion *r = get_region(i);
2309     if (r-&gt;is_active()) {
2310       if (r-&gt;is_pinned()) {
2311         if (r-&gt;pin_count() == 0) {
2312           r-&gt;make_unpinned();
2313         }
2314       } else {
2315         if (r-&gt;pin_count() &gt; 0) {
2316           r-&gt;make_pinned();
2317         }
2318       }
2319     }
2320   }
2321 
2322   assert_pinned_region_status();
2323 }
2324 
2325 #ifdef ASSERT
2326 void ShenandoahHeap::assert_pinned_region_status() {
2327   for (size_t i = 0; i &lt; num_regions(); i++) {
2328     ShenandoahHeapRegion* r = get_region(i);
2329     assert((r-&gt;is_pinned() &amp;&amp; r-&gt;pin_count() &gt; 0) || (!r-&gt;is_pinned() &amp;&amp; r-&gt;pin_count() == 0),
2330            &quot;Region &quot; SIZE_FORMAT &quot; pinning status is inconsistent&quot;, i);
2331   }
2332 }
2333 #endif
2334 
<a name="82" id="anc82"></a><span class="line-modified">2335 GCTimer* ShenandoahHeap::gc_timer() const {</span>
2336   return _gc_timer;
2337 }
2338 
2339 void ShenandoahHeap::prepare_concurrent_roots() {
2340   assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at a safepoint&quot;);
2341   if (ShenandoahConcurrentRoots::should_do_concurrent_roots()) {
2342     set_concurrent_root_in_progress(true);
2343   }
2344 }
2345 
2346 void ShenandoahHeap::prepare_concurrent_unloading() {
2347   assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at a safepoint&quot;);
2348   if (ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {
2349     _unloader.prepare();
2350   }
2351 }
2352 
2353 void ShenandoahHeap::finish_concurrent_unloading() {
2354   assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at a safepoint&quot;);
2355   if (ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {
2356     _unloader.finish();
2357   }
2358 }
2359 
2360 #ifdef ASSERT
2361 void ShenandoahHeap::assert_gc_workers(uint nworkers) {
2362   assert(nworkers &gt; 0 &amp;&amp; nworkers &lt;= max_workers(), &quot;Sanity&quot;);
2363 
2364   if (ShenandoahSafepoint::is_at_shenandoah_safepoint()) {
<a name="83" id="anc83"></a><span class="line-modified">2365     if (UseDynamicNumberOfGCThreads ||</span>
<span class="line-removed">2366         (FLAG_IS_DEFAULT(ParallelGCThreads) &amp;&amp; ForceDynamicNumberOfGCThreads)) {</span>
2367       assert(nworkers &lt;= ParallelGCThreads, &quot;Cannot use more than it has&quot;);
2368     } else {
2369       // Use ParallelGCThreads inside safepoints
<a name="84" id="anc84"></a><span class="line-modified">2370       assert(nworkers == ParallelGCThreads, &quot;Use ParalleGCThreads within safepoints&quot;);</span>
2371     }
2372   } else {
<a name="85" id="anc85"></a><span class="line-modified">2373     if (UseDynamicNumberOfGCThreads ||</span>
<span class="line-removed">2374         (FLAG_IS_DEFAULT(ConcGCThreads) &amp;&amp; ForceDynamicNumberOfGCThreads)) {</span>
2375       assert(nworkers &lt;= ConcGCThreads, &quot;Cannot use more than it has&quot;);
2376     } else {
2377       // Use ConcGCThreads outside safepoints
2378       assert(nworkers == ConcGCThreads, &quot;Use ConcGCThreads outside safepoints&quot;);
2379     }
2380   }
2381 }
2382 #endif
2383 
2384 ShenandoahVerifier* ShenandoahHeap::verifier() {
2385   guarantee(ShenandoahVerify, &quot;Should be enabled&quot;);
2386   assert (_verifier != NULL, &quot;sanity&quot;);
2387   return _verifier;
2388 }
2389 
2390 template&lt;class T&gt;
2391 class ShenandoahUpdateHeapRefsTask : public AbstractGangTask {
2392 private:
2393   T cl;
2394   ShenandoahHeap* _heap;
2395   ShenandoahRegionIterator* _regions;
2396   bool _concurrent;
2397 public:
2398   ShenandoahUpdateHeapRefsTask(ShenandoahRegionIterator* regions, bool concurrent) :
2399     AbstractGangTask(&quot;Concurrent Update References Task&quot;),
2400     cl(T()),
2401     _heap(ShenandoahHeap::heap()),
2402     _regions(regions),
2403     _concurrent(concurrent) {
2404   }
2405 
2406   void work(uint worker_id) {
2407     if (_concurrent) {
2408       ShenandoahConcurrentWorkerSession worker_session(worker_id);
2409       ShenandoahSuspendibleThreadSetJoiner stsj(ShenandoahSuspendibleWorkers);
2410       do_work();
2411     } else {
2412       ShenandoahParallelWorkerSession worker_session(worker_id);
2413       do_work();
2414     }
2415   }
2416 
2417 private:
2418   void do_work() {
2419     ShenandoahHeapRegion* r = _regions-&gt;next();
2420     ShenandoahMarkingContext* const ctx = _heap-&gt;complete_marking_context();
2421     while (r != NULL) {
<a name="86" id="anc86"></a><span class="line-modified">2422       HeapWord* top_at_start_ur = r-&gt;concurrent_iteration_safe_limit();</span>
<span class="line-modified">2423       assert (top_at_start_ur &gt;= r-&gt;bottom(), &quot;sanity&quot;);</span>
2424       if (r-&gt;is_active() &amp;&amp; !r-&gt;is_cset()) {
<a name="87" id="anc87"></a><span class="line-modified">2425         _heap-&gt;marked_object_oop_iterate(r, &amp;cl, top_at_start_ur);</span>
2426       }
2427       if (ShenandoahPacing) {
<a name="88" id="anc88"></a><span class="line-modified">2428         _heap-&gt;pacer()-&gt;report_updaterefs(pointer_delta(top_at_start_ur, r-&gt;bottom()));</span>
2429       }
2430       if (_heap-&gt;check_cancelled_gc_and_yield(_concurrent)) {
2431         return;
2432       }
2433       r = _regions-&gt;next();
2434     }
2435   }
2436 };
2437 
2438 void ShenandoahHeap::update_heap_references(bool concurrent) {
2439   ShenandoahUpdateHeapRefsTask&lt;ShenandoahUpdateHeapRefsClosure&gt; task(&amp;_update_refs_iterator, concurrent);
2440   workers()-&gt;run_task(&amp;task);
2441 }
2442 
2443 void ShenandoahHeap::op_init_updaterefs() {
2444   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;must be at safepoint&quot;);
2445 
2446   set_evacuation_in_progress(false);
2447 
2448   {
<a name="89" id="anc89"></a><span class="line-modified">2449     ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_update_refs_retire_gclabs);</span>
2450     retire_and_reset_gclabs();
2451   }
2452 
2453   if (ShenandoahVerify) {
2454     if (!is_degenerated_gc_in_progress()) {
2455       verifier()-&gt;verify_roots_in_to_space_except(ShenandoahRootVerifier::ThreadRoots);
2456     }
2457     verifier()-&gt;verify_before_updaterefs();
2458   }
2459 
2460   set_update_refs_in_progress(true);
2461 
2462   {
<a name="90" id="anc90"></a><span class="line-modified">2463     ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_update_refs_prepare);</span>
2464 
2465     make_parsable(true);
<a name="91" id="anc91"></a><span class="line-removed">2466     for (uint i = 0; i &lt; num_regions(); i++) {</span>
<span class="line-removed">2467       ShenandoahHeapRegion* r = get_region(i);</span>
<span class="line-removed">2468       r-&gt;set_concurrent_iteration_safe_limit(r-&gt;top());</span>
<span class="line-removed">2469     }</span>
2470 
2471     // Reset iterator.
2472     _update_refs_iterator.reset();
2473   }
2474 
2475   if (ShenandoahPacing) {
2476     pacer()-&gt;setup_for_updaterefs();
2477   }
2478 }
2479 
<a name="92" id="anc92"></a>




























2480 void ShenandoahHeap::op_final_updaterefs() {
2481   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;must be at safepoint&quot;);
2482 
2483   finish_concurrent_unloading();
2484 
2485   // Check if there is left-over work, and finish it
2486   if (_update_refs_iterator.has_next()) {
<a name="93" id="anc93"></a><span class="line-modified">2487     ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_update_refs_finish_work);</span>
2488 
2489     // Finish updating references where we left off.
2490     clear_cancelled_gc();
2491     update_heap_references(false);
2492   }
2493 
2494   // Clear cancelled GC, if set. On cancellation path, the block before would handle
2495   // everything. On degenerated paths, cancelled gc would not be set anyway.
2496   if (cancelled_gc()) {
2497     clear_cancelled_gc();
2498   }
2499   assert(!cancelled_gc(), &quot;Should have been done right before&quot;);
2500 
2501   if (ShenandoahVerify &amp;&amp; !is_degenerated_gc_in_progress()) {
2502     verifier()-&gt;verify_roots_in_to_space_except(ShenandoahRootVerifier::ThreadRoots);
2503   }
2504 
2505   if (is_degenerated_gc_in_progress()) {
2506     concurrent_mark()-&gt;update_roots(ShenandoahPhaseTimings::degen_gc_update_roots);
2507   } else {
2508     concurrent_mark()-&gt;update_thread_roots(ShenandoahPhaseTimings::final_update_refs_roots);
2509   }
2510 
2511   // Has to be done before cset is clear
2512   if (ShenandoahVerify) {
2513     verifier()-&gt;verify_roots_in_to_space();
2514   }
2515 
<a name="94" id="anc94"></a><span class="line-removed">2516   // Drop unnecessary &quot;pinned&quot; state from regions that does not have CP marks</span>
<span class="line-removed">2517   // anymore, as this would allow trashing them below.</span>
2518   {
<a name="95" id="anc95"></a><span class="line-modified">2519     ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_update_refs_sync_pinned);</span>
<span class="line-modified">2520     sync_pinned_region_status();</span>



2521   }
2522 
2523   {
<a name="96" id="anc96"></a><span class="line-modified">2524     ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_update_refs_trash_cset);</span>
2525     trash_cset_regions();
2526   }
2527 
2528   set_has_forwarded_objects(false);
2529   set_update_refs_in_progress(false);
2530 
2531   if (ShenandoahVerify) {
2532     verifier()-&gt;verify_after_updaterefs();
2533   }
2534 
2535   if (VerifyAfterGC) {
2536     Universe::verify();
2537   }
2538 
2539   {
<a name="97" id="anc97"></a>
2540     ShenandoahHeapLocker locker(lock());
2541     _free_set-&gt;rebuild();
2542   }
2543 }
2544 
<a name="98" id="anc98"></a><span class="line-removed">2545 #ifdef ASSERT</span>
<span class="line-removed">2546 void ShenandoahHeap::assert_heaplock_owned_by_current_thread() {</span>
<span class="line-removed">2547   _lock.assert_owned_by_current_thread();</span>
<span class="line-removed">2548 }</span>
<span class="line-removed">2549 </span>
<span class="line-removed">2550 void ShenandoahHeap::assert_heaplock_not_owned_by_current_thread() {</span>
<span class="line-removed">2551   _lock.assert_not_owned_by_current_thread();</span>
<span class="line-removed">2552 }</span>
<span class="line-removed">2553 </span>
<span class="line-removed">2554 void ShenandoahHeap::assert_heaplock_or_safepoint() {</span>
<span class="line-removed">2555   _lock.assert_owned_by_current_thread_or_safepoint();</span>
<span class="line-removed">2556 }</span>
<span class="line-removed">2557 #endif</span>
<span class="line-removed">2558 </span>
2559 void ShenandoahHeap::print_extended_on(outputStream *st) const {
2560   print_on(st);
2561   print_heap_regions_on(st);
2562 }
2563 
2564 bool ShenandoahHeap::is_bitmap_slice_committed(ShenandoahHeapRegion* r, bool skip_self) {
<a name="99" id="anc99"></a><span class="line-modified">2565   size_t slice = r-&gt;region_number() / _bitmap_regions_per_slice;</span>
2566 
2567   size_t regions_from = _bitmap_regions_per_slice * slice;
2568   size_t regions_to   = MIN2(num_regions(), _bitmap_regions_per_slice * (slice + 1));
2569   for (size_t g = regions_from; g &lt; regions_to; g++) {
2570     assert (g / _bitmap_regions_per_slice == slice, &quot;same slice&quot;);
<a name="100" id="anc100"></a><span class="line-modified">2571     if (skip_self &amp;&amp; g == r-&gt;region_number()) continue;</span>
2572     if (get_region(g)-&gt;is_committed()) {
2573       return true;
2574     }
2575   }
2576   return false;
2577 }
2578 
2579 bool ShenandoahHeap::commit_bitmap_slice(ShenandoahHeapRegion* r) {
<a name="101" id="anc101"></a><span class="line-modified">2580   assert_heaplock_owned_by_current_thread();</span>
2581 
2582   // Bitmaps in special regions do not need commits
2583   if (_bitmap_region_special) {
2584     return true;
2585   }
2586 
2587   if (is_bitmap_slice_committed(r, true)) {
2588     // Some other region from the group is already committed, meaning the bitmap
2589     // slice is already committed, we exit right away.
2590     return true;
2591   }
2592 
2593   // Commit the bitmap slice:
<a name="102" id="anc102"></a><span class="line-modified">2594   size_t slice = r-&gt;region_number() / _bitmap_regions_per_slice;</span>
2595   size_t off = _bitmap_bytes_per_slice * slice;
2596   size_t len = _bitmap_bytes_per_slice;
2597   if (!os::commit_memory((char*)_bitmap_region.start() + off, len, false)) {
2598     return false;
2599   }
2600   return true;
2601 }
2602 
2603 bool ShenandoahHeap::uncommit_bitmap_slice(ShenandoahHeapRegion *r) {
<a name="103" id="anc103"></a><span class="line-modified">2604   assert_heaplock_owned_by_current_thread();</span>
2605 
2606   // Bitmaps in special regions do not need uncommits
2607   if (_bitmap_region_special) {
2608     return true;
2609   }
2610 
2611   if (is_bitmap_slice_committed(r, true)) {
2612     // Some other region from the group is still committed, meaning the bitmap
2613     // slice is should stay committed, exit right away.
2614     return true;
2615   }
2616 
2617   // Uncommit the bitmap slice:
<a name="104" id="anc104"></a><span class="line-modified">2618   size_t slice = r-&gt;region_number() / _bitmap_regions_per_slice;</span>
2619   size_t off = _bitmap_bytes_per_slice * slice;
2620   size_t len = _bitmap_bytes_per_slice;
2621   if (!os::uncommit_memory((char*)_bitmap_region.start() + off, len)) {
2622     return false;
2623   }
2624   return true;
2625 }
2626 
2627 void ShenandoahHeap::safepoint_synchronize_begin() {
2628   if (ShenandoahSuspendibleWorkers || UseStringDeduplication) {
2629     SuspendibleThreadSet::synchronize();
2630   }
2631 }
2632 
2633 void ShenandoahHeap::safepoint_synchronize_end() {
2634   if (ShenandoahSuspendibleWorkers || UseStringDeduplication) {
2635     SuspendibleThreadSet::desynchronize();
2636   }
2637 }
2638 
2639 void ShenandoahHeap::vmop_entry_init_mark() {
2640   TraceCollectorStats tcs(monitoring_support()-&gt;stw_collection_counters());
2641   ShenandoahGCPhase total(ShenandoahPhaseTimings::total_pause_gross);
2642   ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_mark_gross);
2643 
2644   try_inject_alloc_failure();
2645   VM_ShenandoahInitMark op;
2646   VMThread::execute(&amp;op); // jump to entry_init_mark() under safepoint
2647 }
2648 
2649 void ShenandoahHeap::vmop_entry_final_mark() {
2650   TraceCollectorStats tcs(monitoring_support()-&gt;stw_collection_counters());
2651   ShenandoahGCPhase total(ShenandoahPhaseTimings::total_pause_gross);
2652   ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_mark_gross);
2653 
2654   try_inject_alloc_failure();
2655   VM_ShenandoahFinalMarkStartEvac op;
2656   VMThread::execute(&amp;op); // jump to entry_final_mark under safepoint
2657 }
2658 
<a name="105" id="anc105"></a><span class="line-removed">2659 void ShenandoahHeap::vmop_entry_final_evac() {</span>
<span class="line-removed">2660   TraceCollectorStats tcs(monitoring_support()-&gt;stw_collection_counters());</span>
<span class="line-removed">2661   ShenandoahGCPhase total(ShenandoahPhaseTimings::total_pause_gross);</span>
<span class="line-removed">2662   ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_evac_gross);</span>
<span class="line-removed">2663 </span>
<span class="line-removed">2664   VM_ShenandoahFinalEvac op;</span>
<span class="line-removed">2665   VMThread::execute(&amp;op); // jump to entry_final_evac under safepoint</span>
<span class="line-removed">2666 }</span>
<span class="line-removed">2667 </span>
2668 void ShenandoahHeap::vmop_entry_init_updaterefs() {
2669   TraceCollectorStats tcs(monitoring_support()-&gt;stw_collection_counters());
2670   ShenandoahGCPhase total(ShenandoahPhaseTimings::total_pause_gross);
2671   ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_update_refs_gross);
2672 
2673   try_inject_alloc_failure();
2674   VM_ShenandoahInitUpdateRefs op;
2675   VMThread::execute(&amp;op);
2676 }
2677 
2678 void ShenandoahHeap::vmop_entry_final_updaterefs() {
2679   TraceCollectorStats tcs(monitoring_support()-&gt;stw_collection_counters());
2680   ShenandoahGCPhase total(ShenandoahPhaseTimings::total_pause_gross);
2681   ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_update_refs_gross);
2682 
2683   try_inject_alloc_failure();
2684   VM_ShenandoahFinalUpdateRefs op;
2685   VMThread::execute(&amp;op);
2686 }
2687 
<a name="106" id="anc106"></a><span class="line-removed">2688 void ShenandoahHeap::vmop_entry_init_traversal() {</span>
<span class="line-removed">2689   TraceCollectorStats tcs(monitoring_support()-&gt;stw_collection_counters());</span>
<span class="line-removed">2690   ShenandoahGCPhase total(ShenandoahPhaseTimings::total_pause_gross);</span>
<span class="line-removed">2691   ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_traversal_gc_gross);</span>
<span class="line-removed">2692 </span>
<span class="line-removed">2693   try_inject_alloc_failure();</span>
<span class="line-removed">2694   VM_ShenandoahInitTraversalGC op;</span>
<span class="line-removed">2695   VMThread::execute(&amp;op);</span>
<span class="line-removed">2696 }</span>
<span class="line-removed">2697 </span>
<span class="line-removed">2698 void ShenandoahHeap::vmop_entry_final_traversal() {</span>
<span class="line-removed">2699   TraceCollectorStats tcs(monitoring_support()-&gt;stw_collection_counters());</span>
<span class="line-removed">2700   ShenandoahGCPhase total(ShenandoahPhaseTimings::total_pause_gross);</span>
<span class="line-removed">2701   ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_traversal_gc_gross);</span>
<span class="line-removed">2702 </span>
<span class="line-removed">2703   try_inject_alloc_failure();</span>
<span class="line-removed">2704   VM_ShenandoahFinalTraversalGC op;</span>
<span class="line-removed">2705   VMThread::execute(&amp;op);</span>
<span class="line-removed">2706 }</span>
<span class="line-removed">2707 </span>
2708 void ShenandoahHeap::vmop_entry_full(GCCause::Cause cause) {
2709   TraceCollectorStats tcs(monitoring_support()-&gt;full_stw_collection_counters());
2710   ShenandoahGCPhase total(ShenandoahPhaseTimings::total_pause_gross);
2711   ShenandoahGCPhase phase(ShenandoahPhaseTimings::full_gc_gross);
2712 
2713   try_inject_alloc_failure();
2714   VM_ShenandoahFullGC op(cause);
2715   VMThread::execute(&amp;op);
2716 }
2717 
2718 void ShenandoahHeap::vmop_degenerated(ShenandoahDegenPoint point) {
2719   TraceCollectorStats tcs(monitoring_support()-&gt;full_stw_collection_counters());
2720   ShenandoahGCPhase total(ShenandoahPhaseTimings::total_pause_gross);
2721   ShenandoahGCPhase phase(ShenandoahPhaseTimings::degen_gc_gross);
2722 
2723   VM_ShenandoahDegeneratedGC degenerated_gc((int)point);
2724   VMThread::execute(&amp;degenerated_gc);
2725 }
2726 
2727 void ShenandoahHeap::entry_init_mark() {
<a name="107" id="anc107"></a><span class="line-removed">2728   ShenandoahGCPhase total_phase(ShenandoahPhaseTimings::total_pause);</span>
<span class="line-removed">2729   ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_mark);</span>
2730   const char* msg = init_mark_event_message();
<a name="108" id="anc108"></a><span class="line-modified">2731   GCTraceTime(Info, gc) time(msg, gc_timer());</span>
2732   EventMark em(&quot;%s&quot;, msg);
2733 
<a name="109" id="anc109"></a>


2734   ShenandoahWorkerScope scope(workers(),
2735                               ShenandoahWorkerPolicy::calc_workers_for_init_marking(),
2736                               &quot;init marking&quot;);
2737 
2738   op_init_mark();
2739 }
2740 
2741 void ShenandoahHeap::entry_final_mark() {
<a name="110" id="anc110"></a><span class="line-removed">2742   ShenandoahGCPhase total_phase(ShenandoahPhaseTimings::total_pause);</span>
<span class="line-removed">2743   ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_mark);</span>
2744   const char* msg = final_mark_event_message();
<a name="111" id="anc111"></a><span class="line-modified">2745   GCTraceTime(Info, gc) time(msg, gc_timer());</span>
2746   EventMark em(&quot;%s&quot;, msg);
2747 
<a name="112" id="anc112"></a>


2748   ShenandoahWorkerScope scope(workers(),
2749                               ShenandoahWorkerPolicy::calc_workers_for_final_marking(),
2750                               &quot;final marking&quot;);
2751 
2752   op_final_mark();
2753 }
2754 
<a name="113" id="anc113"></a><span class="line-modified">2755 void ShenandoahHeap::entry_final_evac() {</span>
<span class="line-modified">2756   ShenandoahGCPhase total_phase(ShenandoahPhaseTimings::total_pause);</span>
<span class="line-modified">2757   ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_evac);</span>
<span class="line-removed">2758   static const char* msg = &quot;Pause Final Evac&quot;;</span>
<span class="line-removed">2759   GCTraceTime(Info, gc) time(msg, gc_timer());</span>
2760   EventMark em(&quot;%s&quot;, msg);
2761 
<a name="114" id="anc114"></a><span class="line-removed">2762   op_final_evac();</span>
<span class="line-removed">2763 }</span>
<span class="line-removed">2764 </span>
<span class="line-removed">2765 void ShenandoahHeap::entry_init_updaterefs() {</span>
2766   ShenandoahGCPhase total_phase(ShenandoahPhaseTimings::total_pause);
2767   ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_update_refs);
2768 
<a name="115" id="anc115"></a><span class="line-removed">2769   static const char* msg = &quot;Pause Init Update Refs&quot;;</span>
<span class="line-removed">2770   GCTraceTime(Info, gc) time(msg, gc_timer());</span>
<span class="line-removed">2771   EventMark em(&quot;%s&quot;, msg);</span>
<span class="line-removed">2772 </span>
2773   // No workers used in this phase, no setup required
2774 
2775   op_init_updaterefs();
2776 }
2777 
2778 void ShenandoahHeap::entry_final_updaterefs() {
<a name="116" id="anc116"></a><span class="line-removed">2779   ShenandoahGCPhase total_phase(ShenandoahPhaseTimings::total_pause);</span>
<span class="line-removed">2780   ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_update_refs);</span>
<span class="line-removed">2781 </span>
2782   static const char* msg = &quot;Pause Final Update Refs&quot;;
<a name="117" id="anc117"></a><span class="line-modified">2783   GCTraceTime(Info, gc) time(msg, gc_timer());</span>
2784   EventMark em(&quot;%s&quot;, msg);
2785 
<a name="118" id="anc118"></a>


2786   ShenandoahWorkerScope scope(workers(),
2787                               ShenandoahWorkerPolicy::calc_workers_for_final_update_ref(),
2788                               &quot;final reference update&quot;);
2789 
2790   op_final_updaterefs();
2791 }
2792 
<a name="119" id="anc119"></a><span class="line-modified">2793 void ShenandoahHeap::entry_init_traversal() {</span>
<span class="line-modified">2794   ShenandoahGCPhase total_phase(ShenandoahPhaseTimings::total_pause);</span>
<span class="line-modified">2795   ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_traversal_gc);</span>
<span class="line-removed">2796 </span>
<span class="line-removed">2797   static const char* msg = init_traversal_event_message();</span>
<span class="line-removed">2798   GCTraceTime(Info, gc) time(msg, gc_timer());</span>
<span class="line-removed">2799   EventMark em(&quot;%s&quot;, msg);</span>
<span class="line-removed">2800 </span>
<span class="line-removed">2801   ShenandoahWorkerScope scope(workers(),</span>
<span class="line-removed">2802                               ShenandoahWorkerPolicy::calc_workers_for_stw_traversal(),</span>
<span class="line-removed">2803                               &quot;init traversal&quot;);</span>
<span class="line-removed">2804 </span>
<span class="line-removed">2805   op_init_traversal();</span>
<span class="line-removed">2806 }</span>
<span class="line-removed">2807 </span>
<span class="line-removed">2808 void ShenandoahHeap::entry_final_traversal() {</span>
<span class="line-removed">2809   ShenandoahGCPhase total_phase(ShenandoahPhaseTimings::total_pause);</span>
<span class="line-removed">2810   ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_traversal_gc);</span>
<span class="line-removed">2811 </span>
<span class="line-removed">2812   static const char* msg = final_traversal_event_message();</span>
<span class="line-removed">2813   GCTraceTime(Info, gc) time(msg, gc_timer());</span>
2814   EventMark em(&quot;%s&quot;, msg);
2815 
<a name="120" id="anc120"></a><span class="line-removed">2816   ShenandoahWorkerScope scope(workers(),</span>
<span class="line-removed">2817                               ShenandoahWorkerPolicy::calc_workers_for_stw_traversal(),</span>
<span class="line-removed">2818                               &quot;final traversal&quot;);</span>
<span class="line-removed">2819 </span>
<span class="line-removed">2820   op_final_traversal();</span>
<span class="line-removed">2821 }</span>
<span class="line-removed">2822 </span>
<span class="line-removed">2823 void ShenandoahHeap::entry_full(GCCause::Cause cause) {</span>
2824   ShenandoahGCPhase total_phase(ShenandoahPhaseTimings::total_pause);
2825   ShenandoahGCPhase phase(ShenandoahPhaseTimings::full_gc);
2826 
<a name="121" id="anc121"></a><span class="line-removed">2827   static const char* msg = &quot;Pause Full&quot;;</span>
<span class="line-removed">2828   GCTraceTime(Info, gc) time(msg, gc_timer(), cause, true);</span>
<span class="line-removed">2829   EventMark em(&quot;%s&quot;, msg);</span>
<span class="line-removed">2830 </span>
2831   ShenandoahWorkerScope scope(workers(),
2832                               ShenandoahWorkerPolicy::calc_workers_for_fullgc(),
2833                               &quot;full gc&quot;);
2834 
2835   op_full(cause);
2836 }
2837 
2838 void ShenandoahHeap::entry_degenerated(int point) {
<a name="122" id="anc122"></a><span class="line-removed">2839   ShenandoahGCPhase total_phase(ShenandoahPhaseTimings::total_pause);</span>
<span class="line-removed">2840   ShenandoahGCPhase phase(ShenandoahPhaseTimings::degen_gc);</span>
<span class="line-removed">2841 </span>
2842   ShenandoahDegenPoint dpoint = (ShenandoahDegenPoint)point;
2843   const char* msg = degen_event_message(dpoint);
<a name="123" id="anc123"></a><span class="line-modified">2844   GCTraceTime(Info, gc) time(msg, NULL, GCCause::_no_gc, true);</span>
2845   EventMark em(&quot;%s&quot;, msg);
2846 
<a name="124" id="anc124"></a>


2847   ShenandoahWorkerScope scope(workers(),
2848                               ShenandoahWorkerPolicy::calc_workers_for_stw_degenerated(),
2849                               &quot;stw degenerated gc&quot;);
2850 
2851   set_degenerated_gc_in_progress(true);
2852   op_degenerated(dpoint);
2853   set_degenerated_gc_in_progress(false);
2854 }
2855 
2856 void ShenandoahHeap::entry_mark() {
2857   TraceCollectorStats tcs(monitoring_support()-&gt;concurrent_collection_counters());
2858 
2859   const char* msg = conc_mark_event_message();
<a name="125" id="anc125"></a><span class="line-modified">2860   GCTraceTime(Info, gc) time(msg, NULL, GCCause::_no_gc, true);</span>
2861   EventMark em(&quot;%s&quot;, msg);
2862 
<a name="126" id="anc126"></a>

2863   ShenandoahWorkerScope scope(workers(),
2864                               ShenandoahWorkerPolicy::calc_workers_for_conc_marking(),
2865                               &quot;concurrent marking&quot;);
2866 
2867   try_inject_alloc_failure();
2868   op_mark();
2869 }
2870 
2871 void ShenandoahHeap::entry_evac() {
<a name="127" id="anc127"></a><span class="line-removed">2872   ShenandoahGCPhase conc_evac_phase(ShenandoahPhaseTimings::conc_evac);</span>
2873   TraceCollectorStats tcs(monitoring_support()-&gt;concurrent_collection_counters());
2874 
2875   static const char* msg = &quot;Concurrent evacuation&quot;;
<a name="128" id="anc128"></a><span class="line-modified">2876   GCTraceTime(Info, gc) time(msg, NULL, GCCause::_no_gc, true);</span>
2877   EventMark em(&quot;%s&quot;, msg);
2878 
<a name="129" id="anc129"></a>

2879   ShenandoahWorkerScope scope(workers(),
2880                               ShenandoahWorkerPolicy::calc_workers_for_conc_evac(),
2881                               &quot;concurrent evacuation&quot;);
2882 
2883   try_inject_alloc_failure();
2884   op_conc_evac();
2885 }
2886 
2887 void ShenandoahHeap::entry_updaterefs() {
<a name="130" id="anc130"></a><span class="line-removed">2888   ShenandoahGCPhase phase(ShenandoahPhaseTimings::conc_update_refs);</span>
<span class="line-removed">2889 </span>
2890   static const char* msg = &quot;Concurrent update references&quot;;
<a name="131" id="anc131"></a><span class="line-modified">2891   GCTraceTime(Info, gc) time(msg, NULL, GCCause::_no_gc, true);</span>
2892   EventMark em(&quot;%s&quot;, msg);
2893 
<a name="132" id="anc132"></a>

2894   ShenandoahWorkerScope scope(workers(),
2895                               ShenandoahWorkerPolicy::calc_workers_for_conc_update_ref(),
2896                               &quot;concurrent reference update&quot;);
2897 
2898   try_inject_alloc_failure();
2899   op_updaterefs();
2900 }
2901 
2902 void ShenandoahHeap::entry_roots() {
<a name="133" id="anc133"></a><span class="line-removed">2903   ShenandoahGCPhase phase(ShenandoahPhaseTimings::conc_roots);</span>
<span class="line-removed">2904 </span>
2905   static const char* msg = &quot;Concurrent roots processing&quot;;
<a name="134" id="anc134"></a><span class="line-modified">2906   GCTraceTime(Info, gc) time(msg, NULL, GCCause::_no_gc, true);</span>
2907   EventMark em(&quot;%s&quot;, msg);
2908 
<a name="135" id="anc135"></a>

2909   ShenandoahWorkerScope scope(workers(),
2910                               ShenandoahWorkerPolicy::calc_workers_for_conc_root_processing(),
2911                               &quot;concurrent root processing&quot;);
2912 
2913   try_inject_alloc_failure();
2914   op_roots();
2915 }
2916 
2917 void ShenandoahHeap::entry_cleanup() {
<a name="136" id="anc136"></a><span class="line-removed">2918   ShenandoahGCPhase phase(ShenandoahPhaseTimings::conc_cleanup);</span>
<span class="line-removed">2919 </span>
2920   static const char* msg = &quot;Concurrent cleanup&quot;;
<a name="137" id="anc137"></a><span class="line-modified">2921   GCTraceTime(Info, gc) time(msg, NULL, GCCause::_no_gc, true);</span>
2922   EventMark em(&quot;%s&quot;, msg);
2923 
<a name="138" id="anc138"></a>

2924   // This phase does not use workers, no need for setup
2925 
2926   try_inject_alloc_failure();
2927   op_cleanup();
2928 }
2929 
2930 void ShenandoahHeap::entry_reset() {
<a name="139" id="anc139"></a><span class="line-removed">2931   ShenandoahGCPhase phase(ShenandoahPhaseTimings::conc_reset);</span>
<span class="line-removed">2932 </span>
2933   static const char* msg = &quot;Concurrent reset&quot;;
<a name="140" id="anc140"></a><span class="line-modified">2934   GCTraceTime(Info, gc) time(msg, NULL, GCCause::_no_gc, true);</span>
2935   EventMark em(&quot;%s&quot;, msg);
2936 
<a name="141" id="anc141"></a>

2937   ShenandoahWorkerScope scope(workers(),
2938                               ShenandoahWorkerPolicy::calc_workers_for_conc_reset(),
2939                               &quot;concurrent reset&quot;);
2940 
2941   try_inject_alloc_failure();
2942   op_reset();
2943 }
2944 
2945 void ShenandoahHeap::entry_preclean() {
2946   if (ShenandoahPreclean &amp;&amp; process_references()) {
2947     static const char* msg = &quot;Concurrent precleaning&quot;;
<a name="142" id="anc142"></a><span class="line-modified">2948     GCTraceTime(Info, gc) time(msg, NULL, GCCause::_no_gc, true);</span>
2949     EventMark em(&quot;%s&quot;, msg);
2950 
<a name="143" id="anc143"></a><span class="line-modified">2951     ShenandoahGCPhase conc_preclean(ShenandoahPhaseTimings::conc_preclean);</span>
2952 
2953     ShenandoahWorkerScope scope(workers(),
2954                                 ShenandoahWorkerPolicy::calc_workers_for_conc_preclean(),
2955                                 &quot;concurrent preclean&quot;,
2956                                 /* check_workers = */ false);
2957 
2958     try_inject_alloc_failure();
2959     op_preclean();
2960   }
2961 }
2962 
<a name="144" id="anc144"></a><span class="line-removed">2963 void ShenandoahHeap::entry_traversal() {</span>
<span class="line-removed">2964   static const char* msg = conc_traversal_event_message();</span>
<span class="line-removed">2965   GCTraceTime(Info, gc) time(msg, NULL, GCCause::_no_gc, true);</span>
<span class="line-removed">2966   EventMark em(&quot;%s&quot;, msg);</span>
<span class="line-removed">2967 </span>
<span class="line-removed">2968   TraceCollectorStats tcs(monitoring_support()-&gt;concurrent_collection_counters());</span>
<span class="line-removed">2969 </span>
<span class="line-removed">2970   ShenandoahWorkerScope scope(workers(),</span>
<span class="line-removed">2971                               ShenandoahWorkerPolicy::calc_workers_for_conc_traversal(),</span>
<span class="line-removed">2972                               &quot;concurrent traversal&quot;);</span>
<span class="line-removed">2973 </span>
<span class="line-removed">2974   try_inject_alloc_failure();</span>
<span class="line-removed">2975   op_traversal();</span>
<span class="line-removed">2976 }</span>
<span class="line-removed">2977 </span>
2978 void ShenandoahHeap::entry_uncommit(double shrink_before) {
2979   static const char *msg = &quot;Concurrent uncommit&quot;;
<a name="145" id="anc145"></a><span class="line-modified">2980   GCTraceTime(Info, gc) time(msg, NULL, GCCause::_no_gc, true);</span>
2981   EventMark em(&quot;%s&quot;, msg);
2982 
<a name="146" id="anc146"></a><span class="line-modified">2983   ShenandoahGCPhase phase(ShenandoahPhaseTimings::conc_uncommit);</span>
2984 
2985   op_uncommit(shrink_before);
2986 }
2987 
2988 void ShenandoahHeap::try_inject_alloc_failure() {
2989   if (ShenandoahAllocFailureALot &amp;&amp; !cancelled_gc() &amp;&amp; ((os::random() % 1000) &gt; 950)) {
2990     _inject_alloc_failure.set();
2991     os::naked_short_sleep(1);
2992     if (cancelled_gc()) {
2993       log_info(gc)(&quot;Allocation failure was successfully injected&quot;);
2994     }
2995   }
2996 }
2997 
2998 bool ShenandoahHeap::should_inject_alloc_failure() {
2999   return _inject_alloc_failure.is_set() &amp;&amp; _inject_alloc_failure.try_unset();
3000 }
3001 
3002 void ShenandoahHeap::initialize_serviceability() {
3003   _memory_pool = new ShenandoahMemoryPool(this);
3004   _cycle_memory_manager.add_pool(_memory_pool);
3005   _stw_memory_manager.add_pool(_memory_pool);
3006 }
3007 
3008 GrowableArray&lt;GCMemoryManager*&gt; ShenandoahHeap::memory_managers() {
3009   GrowableArray&lt;GCMemoryManager*&gt; memory_managers(2);
3010   memory_managers.append(&amp;_cycle_memory_manager);
3011   memory_managers.append(&amp;_stw_memory_manager);
3012   return memory_managers;
3013 }
3014 
3015 GrowableArray&lt;MemoryPool*&gt; ShenandoahHeap::memory_pools() {
3016   GrowableArray&lt;MemoryPool*&gt; memory_pools(1);
3017   memory_pools.append(_memory_pool);
3018   return memory_pools;
3019 }
3020 
3021 MemoryUsage ShenandoahHeap::memory_usage() {
3022   return _memory_pool-&gt;get_memory_usage();
3023 }
3024 
3025 void ShenandoahHeap::enter_evacuation() {
3026   _oom_evac_handler.enter_evacuation();
3027 }
3028 
3029 void ShenandoahHeap::leave_evacuation() {
3030   _oom_evac_handler.leave_evacuation();
3031 }
3032 
3033 ShenandoahRegionIterator::ShenandoahRegionIterator() :
3034   _heap(ShenandoahHeap::heap()),
3035   _index(0) {}
3036 
3037 ShenandoahRegionIterator::ShenandoahRegionIterator(ShenandoahHeap* heap) :
3038   _heap(heap),
3039   _index(0) {}
3040 
3041 void ShenandoahRegionIterator::reset() {
3042   _index = 0;
3043 }
3044 
3045 bool ShenandoahRegionIterator::has_next() const {
3046   return _index &lt; _heap-&gt;num_regions();
3047 }
3048 
3049 char ShenandoahHeap::gc_state() const {
3050   return _gc_state.raw_value();
3051 }
3052 
3053 void ShenandoahHeap::deduplicate_string(oop str) {
3054   assert(java_lang_String::is_instance(str), &quot;invariant&quot;);
3055 
3056   if (ShenandoahStringDedup::is_enabled()) {
3057     ShenandoahStringDedup::deduplicate(str);
3058   }
3059 }
3060 
3061 const char* ShenandoahHeap::init_mark_event_message() const {
<a name="147" id="anc147"></a><span class="line-modified">3062   bool update_refs = has_forwarded_objects();</span>

3063   bool proc_refs = process_references();
3064   bool unload_cls = unload_classes();
3065 
<a name="148" id="anc148"></a><span class="line-modified">3066   if (update_refs &amp;&amp; proc_refs &amp;&amp; unload_cls) {</span>
<span class="line-removed">3067     return &quot;Pause Init Mark (update refs) (process weakrefs) (unload classes)&quot;;</span>
<span class="line-removed">3068   } else if (update_refs &amp;&amp; proc_refs) {</span>
<span class="line-removed">3069     return &quot;Pause Init Mark (update refs) (process weakrefs)&quot;;</span>
<span class="line-removed">3070   } else if (update_refs &amp;&amp; unload_cls) {</span>
<span class="line-removed">3071     return &quot;Pause Init Mark (update refs) (unload classes)&quot;;</span>
<span class="line-removed">3072   } else if (proc_refs &amp;&amp; unload_cls) {</span>
3073     return &quot;Pause Init Mark (process weakrefs) (unload classes)&quot;;
<a name="149" id="anc149"></a><span class="line-removed">3074   } else if (update_refs) {</span>
<span class="line-removed">3075     return &quot;Pause Init Mark (update refs)&quot;;</span>
3076   } else if (proc_refs) {
3077     return &quot;Pause Init Mark (process weakrefs)&quot;;
3078   } else if (unload_cls) {
3079     return &quot;Pause Init Mark (unload classes)&quot;;
3080   } else {
3081     return &quot;Pause Init Mark&quot;;
3082   }
3083 }
3084 
3085 const char* ShenandoahHeap::final_mark_event_message() const {
<a name="150" id="anc150"></a><span class="line-modified">3086   bool update_refs = has_forwarded_objects();</span>

3087   bool proc_refs = process_references();
3088   bool unload_cls = unload_classes();
3089 
<a name="151" id="anc151"></a><span class="line-modified">3090   if (update_refs &amp;&amp; proc_refs &amp;&amp; unload_cls) {</span>
<span class="line-removed">3091     return &quot;Pause Final Mark (update refs) (process weakrefs) (unload classes)&quot;;</span>
<span class="line-removed">3092   } else if (update_refs &amp;&amp; proc_refs) {</span>
<span class="line-removed">3093     return &quot;Pause Final Mark (update refs) (process weakrefs)&quot;;</span>
<span class="line-removed">3094   } else if (update_refs &amp;&amp; unload_cls) {</span>
<span class="line-removed">3095     return &quot;Pause Final Mark (update refs) (unload classes)&quot;;</span>
<span class="line-removed">3096   } else if (proc_refs &amp;&amp; unload_cls) {</span>
3097     return &quot;Pause Final Mark (process weakrefs) (unload classes)&quot;;
<a name="152" id="anc152"></a><span class="line-removed">3098   } else if (update_refs) {</span>
<span class="line-removed">3099     return &quot;Pause Final Mark (update refs)&quot;;</span>
3100   } else if (proc_refs) {
3101     return &quot;Pause Final Mark (process weakrefs)&quot;;
3102   } else if (unload_cls) {
3103     return &quot;Pause Final Mark (unload classes)&quot;;
3104   } else {
3105     return &quot;Pause Final Mark&quot;;
3106   }
3107 }
3108 
3109 const char* ShenandoahHeap::conc_mark_event_message() const {
<a name="153" id="anc153"></a><span class="line-modified">3110   bool update_refs = has_forwarded_objects();</span>

3111   bool proc_refs = process_references();
3112   bool unload_cls = unload_classes();
3113 
<a name="154" id="anc154"></a><span class="line-modified">3114   if (update_refs &amp;&amp; proc_refs &amp;&amp; unload_cls) {</span>
<span class="line-removed">3115     return &quot;Concurrent marking (update refs) (process weakrefs) (unload classes)&quot;;</span>
<span class="line-removed">3116   } else if (update_refs &amp;&amp; proc_refs) {</span>
<span class="line-removed">3117     return &quot;Concurrent marking (update refs) (process weakrefs)&quot;;</span>
<span class="line-removed">3118   } else if (update_refs &amp;&amp; unload_cls) {</span>
<span class="line-removed">3119     return &quot;Concurrent marking (update refs) (unload classes)&quot;;</span>
<span class="line-removed">3120   } else if (proc_refs &amp;&amp; unload_cls) {</span>
3121     return &quot;Concurrent marking (process weakrefs) (unload classes)&quot;;
<a name="155" id="anc155"></a><span class="line-removed">3122   } else if (update_refs) {</span>
<span class="line-removed">3123     return &quot;Concurrent marking (update refs)&quot;;</span>
3124   } else if (proc_refs) {
3125     return &quot;Concurrent marking (process weakrefs)&quot;;
3126   } else if (unload_cls) {
3127     return &quot;Concurrent marking (unload classes)&quot;;
3128   } else {
3129     return &quot;Concurrent marking&quot;;
3130   }
3131 }
3132 
<a name="156" id="anc156"></a><span class="line-removed">3133 const char* ShenandoahHeap::init_traversal_event_message() const {</span>
<span class="line-removed">3134   bool proc_refs = process_references();</span>
<span class="line-removed">3135   bool unload_cls = unload_classes();</span>
<span class="line-removed">3136 </span>
<span class="line-removed">3137   if (proc_refs &amp;&amp; unload_cls) {</span>
<span class="line-removed">3138     return &quot;Pause Init Traversal (process weakrefs) (unload classes)&quot;;</span>
<span class="line-removed">3139   } else if (proc_refs) {</span>
<span class="line-removed">3140     return &quot;Pause Init Traversal (process weakrefs)&quot;;</span>
<span class="line-removed">3141   } else if (unload_cls) {</span>
<span class="line-removed">3142     return &quot;Pause Init Traversal (unload classes)&quot;;</span>
<span class="line-removed">3143   } else {</span>
<span class="line-removed">3144     return &quot;Pause Init Traversal&quot;;</span>
<span class="line-removed">3145   }</span>
<span class="line-removed">3146 }</span>
<span class="line-removed">3147 </span>
<span class="line-removed">3148 const char* ShenandoahHeap::final_traversal_event_message() const {</span>
<span class="line-removed">3149   bool proc_refs = process_references();</span>
<span class="line-removed">3150   bool unload_cls = unload_classes();</span>
<span class="line-removed">3151 </span>
<span class="line-removed">3152   if (proc_refs &amp;&amp; unload_cls) {</span>
<span class="line-removed">3153     return &quot;Pause Final Traversal (process weakrefs) (unload classes)&quot;;</span>
<span class="line-removed">3154   } else if (proc_refs) {</span>
<span class="line-removed">3155     return &quot;Pause Final Traversal (process weakrefs)&quot;;</span>
<span class="line-removed">3156   } else if (unload_cls) {</span>
<span class="line-removed">3157     return &quot;Pause Final Traversal (unload classes)&quot;;</span>
<span class="line-removed">3158   } else {</span>
<span class="line-removed">3159     return &quot;Pause Final Traversal&quot;;</span>
<span class="line-removed">3160   }</span>
<span class="line-removed">3161 }</span>
<span class="line-removed">3162 </span>
<span class="line-removed">3163 const char* ShenandoahHeap::conc_traversal_event_message() const {</span>
<span class="line-removed">3164   bool proc_refs = process_references();</span>
<span class="line-removed">3165   bool unload_cls = unload_classes();</span>
<span class="line-removed">3166 </span>
<span class="line-removed">3167   if (proc_refs &amp;&amp; unload_cls) {</span>
<span class="line-removed">3168     return &quot;Concurrent Traversal (process weakrefs) (unload classes)&quot;;</span>
<span class="line-removed">3169   } else if (proc_refs) {</span>
<span class="line-removed">3170     return &quot;Concurrent Traversal (process weakrefs)&quot;;</span>
<span class="line-removed">3171   } else if (unload_cls) {</span>
<span class="line-removed">3172     return &quot;Concurrent Traversal (unload classes)&quot;;</span>
<span class="line-removed">3173   } else {</span>
<span class="line-removed">3174     return &quot;Concurrent Traversal&quot;;</span>
<span class="line-removed">3175   }</span>
<span class="line-removed">3176 }</span>
<span class="line-removed">3177 </span>
3178 const char* ShenandoahHeap::degen_event_message(ShenandoahDegenPoint point) const {
3179   switch (point) {
3180     case _degenerated_unset:
3181       return &quot;Pause Degenerated GC (&lt;UNSET&gt;)&quot;;
<a name="157" id="anc157"></a><span class="line-removed">3182     case _degenerated_traversal:</span>
<span class="line-removed">3183       return &quot;Pause Degenerated GC (Traversal)&quot;;</span>
3184     case _degenerated_outside_cycle:
3185       return &quot;Pause Degenerated GC (Outside of Cycle)&quot;;
3186     case _degenerated_mark:
3187       return &quot;Pause Degenerated GC (Mark)&quot;;
3188     case _degenerated_evac:
3189       return &quot;Pause Degenerated GC (Evacuation)&quot;;
3190     case _degenerated_updaterefs:
3191       return &quot;Pause Degenerated GC (Update Refs)&quot;;
3192     default:
3193       ShouldNotReachHere();
3194       return &quot;ERROR&quot;;
3195   }
3196 }
3197 
<a name="158" id="anc158"></a><span class="line-modified">3198 jushort* ShenandoahHeap::get_liveness_cache(uint worker_id) {</span>
3199 #ifdef ASSERT
3200   assert(_liveness_cache != NULL, &quot;sanity&quot;);
3201   assert(worker_id &lt; _max_workers, &quot;sanity&quot;);
3202   for (uint i = 0; i &lt; num_regions(); i++) {
3203     assert(_liveness_cache[worker_id][i] == 0, &quot;liveness cache should be empty&quot;);
3204   }
3205 #endif
3206   return _liveness_cache[worker_id];
3207 }
3208 
3209 void ShenandoahHeap::flush_liveness_cache(uint worker_id) {
3210   assert(worker_id &lt; _max_workers, &quot;sanity&quot;);
3211   assert(_liveness_cache != NULL, &quot;sanity&quot;);
<a name="159" id="anc159"></a><span class="line-modified">3212   jushort* ld = _liveness_cache[worker_id];</span>
3213   for (uint i = 0; i &lt; num_regions(); i++) {
<a name="160" id="anc160"></a><span class="line-modified">3214     ShenandoahHeapRegion* r = get_region(i);</span>
<span class="line-removed">3215     jushort live = ld[i];</span>
3216     if (live &gt; 0) {
<a name="161" id="anc161"></a>
3217       r-&gt;increase_live_data_gc_words(live);
3218       ld[i] = 0;
3219     }
3220   }
3221 }
<a name="162" id="anc162"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="162" type="hidden" />
</body>
</html>
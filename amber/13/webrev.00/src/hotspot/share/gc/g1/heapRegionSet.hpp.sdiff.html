<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/heapRegionSet.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="heapRegionRemSet.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="heterogeneousHeapRegionManager.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/heapRegionSet.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
212   // Removes from head or tail based on the given argument.
213   HeapRegion* remove_region(bool from_head);
214 
215   HeapRegion* remove_region_with_node_index(bool from_head,
216                                             uint requested_node_index);
217 
218   // Merge two ordered lists. The result is also ordered. The order is
219   // determined by hrm_index.
220   void add_ordered(FreeRegionList* from_list);
221   void append_ordered(FreeRegionList* from_list);
222 
223   // It empties the list by removing all regions from it.
224   void remove_all();
225 
226   // Abandon current free list. Requires that all regions in the current list
227   // are taken care of separately, to allow a rebuild.
228   void abandon();
229 
230   // Remove all (contiguous) regions from first to first + num_regions -1 from
231   // this list.
<span class="line-modified">232   // Num_regions must be &gt; 1.</span>
233   void remove_starting_at(HeapRegion* first, uint num_regions);
234 
235   virtual void verify();
236 
237   uint num_of_regions_in_range(uint start, uint end) const;
238 
239   using HeapRegionSetBase::length;
240   uint length(uint node_index) const;
241 };
242 
243 // Iterator class that provides a convenient way to iterate over the
244 // regions of a FreeRegionList.
245 
246 class FreeRegionListIterator : public StackObj {
247 private:
248   FreeRegionList* _list;
249   HeapRegion*     _curr;
250 
251 public:
252   bool more_available() {
</pre>
</td>
<td>
<hr />
<pre>
212   // Removes from head or tail based on the given argument.
213   HeapRegion* remove_region(bool from_head);
214 
215   HeapRegion* remove_region_with_node_index(bool from_head,
216                                             uint requested_node_index);
217 
218   // Merge two ordered lists. The result is also ordered. The order is
219   // determined by hrm_index.
220   void add_ordered(FreeRegionList* from_list);
221   void append_ordered(FreeRegionList* from_list);
222 
223   // It empties the list by removing all regions from it.
224   void remove_all();
225 
226   // Abandon current free list. Requires that all regions in the current list
227   // are taken care of separately, to allow a rebuild.
228   void abandon();
229 
230   // Remove all (contiguous) regions from first to first + num_regions -1 from
231   // this list.
<span class="line-modified">232   // Num_regions must be &gt;= 1.</span>
233   void remove_starting_at(HeapRegion* first, uint num_regions);
234 
235   virtual void verify();
236 
237   uint num_of_regions_in_range(uint start, uint end) const;
238 
239   using HeapRegionSetBase::length;
240   uint length(uint node_index) const;
241 };
242 
243 // Iterator class that provides a convenient way to iterate over the
244 // regions of a FreeRegionList.
245 
246 class FreeRegionListIterator : public StackObj {
247 private:
248   FreeRegionList* _list;
249   HeapRegion*     _curr;
250 
251 public:
252   bool more_available() {
</pre>
</td>
</tr>
</table>
<center><a href="heapRegionRemSet.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="heterogeneousHeapRegionManager.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
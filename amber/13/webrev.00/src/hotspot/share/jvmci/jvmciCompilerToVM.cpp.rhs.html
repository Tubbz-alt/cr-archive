<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/jvmci/jvmciCompilerToVM.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 #include &quot;precompiled.hpp&quot;
  25 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  26 #include &quot;classfile/javaClasses.inline.hpp&quot;
  27 #include &quot;classfile/stringTable.hpp&quot;
  28 #include &quot;classfile/symbolTable.hpp&quot;
  29 #include &quot;code/scopeDesc.hpp&quot;
  30 #include &quot;compiler/compileBroker.hpp&quot;
<a name="1" id="anc1"></a><span class="line-added">  31 #include &quot;compiler/compilerEvent.hpp&quot;</span>
  32 #include &quot;compiler/disassembler.hpp&quot;
  33 #include &quot;interpreter/linkResolver.hpp&quot;
  34 #include &quot;interpreter/bytecodeStream.hpp&quot;
  35 #include &quot;jvmci/jvmciCompilerToVM.hpp&quot;
  36 #include &quot;jvmci/jvmciCodeInstaller.hpp&quot;
  37 #include &quot;jvmci/jvmciRuntime.hpp&quot;
  38 #include &quot;logging/log.hpp&quot;
  39 #include &quot;logging/logTag.hpp&quot;
  40 #include &quot;memory/oopFactory.hpp&quot;
  41 #include &quot;memory/universe.hpp&quot;
  42 #include &quot;oops/constantPool.inline.hpp&quot;
  43 #include &quot;oops/method.inline.hpp&quot;
  44 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  45 #include &quot;prims/nativeLookup.hpp&quot;
  46 #include &quot;runtime/atomic.hpp&quot;
  47 #include &quot;runtime/deoptimization.hpp&quot;
  48 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  49 #include &quot;runtime/frame.inline.hpp&quot;
  50 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  51 #include &quot;runtime/jniHandles.inline.hpp&quot;
  52 #include &quot;runtime/timerTrace.hpp&quot;
  53 #include &quot;runtime/vframe_hp.hpp&quot;
  54 
  55 JVMCIKlassHandle::JVMCIKlassHandle(Thread* thread, Klass* klass) {
  56   _thread = thread;
  57   _klass = klass;
  58   if (klass != NULL) {
  59     _holder = Handle(_thread, klass-&gt;klass_holder());
  60   }
  61 }
  62 
  63 JVMCIKlassHandle&amp; JVMCIKlassHandle::operator=(Klass* klass) {
  64   _klass = klass;
  65   if (klass != NULL) {
  66     _holder = Handle(_thread, klass-&gt;klass_holder());
  67   }
  68   return *this;
  69 }
  70 
  71 static void requireInHotSpot(const char* caller, JVMCI_TRAPS) {
  72   if (!JVMCIENV-&gt;is_hotspot()) {
  73     JVMCI_THROW_MSG(IllegalStateException, err_msg(&quot;Cannot call %s from JVMCI shared library&quot;, caller));
  74   }
  75 }
  76 
  77 void JNIHandleMark::push_jni_handle_block(JavaThread* thread) {
  78   if (thread != NULL) {
  79     // Allocate a new block for JNI handles.
  80     // Inlined code from jni_PushLocalFrame()
  81     JNIHandleBlock* java_handles = thread-&gt;active_handles();
  82     JNIHandleBlock* compile_handles = JNIHandleBlock::allocate_block(thread);
  83     assert(compile_handles != NULL &amp;&amp; java_handles != NULL, &quot;should not be NULL&quot;);
  84     compile_handles-&gt;set_pop_frame_link(java_handles);
  85     thread-&gt;set_active_handles(compile_handles);
  86   }
  87 }
  88 
  89 void JNIHandleMark::pop_jni_handle_block(JavaThread* thread) {
  90   if (thread != NULL) {
  91     // Release our JNI handle block
  92     JNIHandleBlock* compile_handles = thread-&gt;active_handles();
  93     JNIHandleBlock* java_handles = compile_handles-&gt;pop_frame_link();
  94     thread-&gt;set_active_handles(java_handles);
  95     compile_handles-&gt;set_pop_frame_link(NULL);
  96     JNIHandleBlock::release_block(compile_handles, thread); // may block
  97   }
  98 }
  99 
 100 class JVMCITraceMark : public StackObj {
 101   const char* _msg;
 102  public:
 103   JVMCITraceMark(const char* msg) {
 104     _msg = msg;
 105     if (JVMCITraceLevel &gt;= 1) {
 106       tty-&gt;print_cr(PTR_FORMAT &quot; JVMCITrace-1: Enter %s&quot;, p2i(JavaThread::current()), _msg);
 107     }
 108   }
 109   ~JVMCITraceMark() {
 110     if (JVMCITraceLevel &gt;= 1) {
 111       tty-&gt;print_cr(PTR_FORMAT &quot; JVMCITrace-1: Exit %s&quot;, p2i(JavaThread::current()), _msg);
 112     }
 113   }
 114 };
 115 
 116 
 117 Handle JavaArgumentUnboxer::next_arg(BasicType expectedType) {
 118   assert(_index &lt; _args-&gt;length(), &quot;out of bounds&quot;);
 119   oop arg=((objArrayOop) (_args))-&gt;obj_at(_index++);
 120   assert(expectedType == T_OBJECT || java_lang_boxing_object::is_instance(arg, expectedType), &quot;arg type mismatch&quot;);
 121   return Handle(Thread::current(), arg);
 122 }
 123 
 124 // Bring the JVMCI compiler thread into the VM state.
 125 #define JVMCI_VM_ENTRY_MARK                   \
 126   ThreadInVMfromNative __tiv(thread);         \
 127   ResetNoHandleMark rnhm;                     \
 128   HandleMarkCleaner __hm(thread);             \
 129   Thread* THREAD = thread;                    \
 130   debug_only(VMNativeEntryWrapper __vew;)
 131 
 132 // Native method block that transitions current thread to &#39;_thread_in_vm&#39;.
 133 #define C2V_BLOCK(result_type, name, signature)      \
 134   TRACE_CALL(result_type, jvmci_ ## name signature)  \
 135   JVMCI_VM_ENTRY_MARK;                               \
 136   ResourceMark rm;                                   \
 137   JNI_JVMCIENV(thread, env);
 138 
 139 static Thread* get_current_thread() {
 140   return Thread::current_or_null_safe();
 141 }
 142 
 143 // Entry to native method implementation that transitions
 144 // current thread to &#39;_thread_in_vm&#39;.
 145 #define C2V_VMENTRY(result_type, name, signature)        \
 146   JNIEXPORT result_type JNICALL c2v_ ## name signature { \
 147   Thread* base_thread = get_current_thread();            \
 148   if (base_thread == NULL) {                             \
 149     env-&gt;ThrowNew(JNIJVMCI::InternalError::clazz(),      \
 150         err_msg(&quot;Cannot call into HotSpot from JVMCI shared library without attaching current thread&quot;)); \
 151     return;                                              \
 152   }                                                      \
 153   assert(base_thread-&gt;is_Java_thread(), &quot;just checking&quot;);\
 154   JavaThread* thread = (JavaThread*) base_thread;        \
 155   JVMCITraceMark jtm(&quot;CompilerToVM::&quot; #name);            \
 156   C2V_BLOCK(result_type, name, signature)
 157 
 158 #define C2V_VMENTRY_(result_type, name, signature, result) \
 159   JNIEXPORT result_type JNICALL c2v_ ## name signature { \
 160   Thread* base_thread = get_current_thread();            \
 161   if (base_thread == NULL) {                             \
 162     env-&gt;ThrowNew(JNIJVMCI::InternalError::clazz(),      \
 163         err_msg(&quot;Cannot call into HotSpot from JVMCI shared library without attaching current thread&quot;)); \
 164     return result;                                       \
 165   }                                                      \
 166   assert(base_thread-&gt;is_Java_thread(), &quot;just checking&quot;);\
 167   JavaThread* thread = (JavaThread*) base_thread;        \
 168   JVMCITraceMark jtm(&quot;CompilerToVM::&quot; #name);            \
 169   C2V_BLOCK(result_type, name, signature)
 170 
 171 #define C2V_VMENTRY_NULL(result_type, name, signature) C2V_VMENTRY_(result_type, name, signature, NULL)
 172 #define C2V_VMENTRY_0(result_type, name, signature) C2V_VMENTRY_(result_type, name, signature, 0)
 173 
 174 // Entry to native method implementation that does not transition
 175 // current thread to &#39;_thread_in_vm&#39;.
 176 #define C2V_VMENTRY_PREFIX(result_type, name, signature) \
 177   JNIEXPORT result_type JNICALL c2v_ ## name signature { \
 178   Thread* base_thread = get_current_thread();
 179 
 180 #define C2V_END }
 181 
 182 #define JNI_THROW(caller, name, msg) do {                                         \
 183     jint __throw_res = env-&gt;ThrowNew(JNIJVMCI::name::clazz(), msg);               \
 184     if (__throw_res != JNI_OK) {                                                  \
 185       tty-&gt;print_cr(&quot;Throwing &quot; #name &quot; in &quot; caller &quot; returned %d&quot;, __throw_res); \
 186     }                                                                             \
 187     return;                                                                       \
 188   } while (0);
 189 
 190 #define JNI_THROW_(caller, name, msg, result) do {                                \
 191     jint __throw_res = env-&gt;ThrowNew(JNIJVMCI::name::clazz(), msg);               \
 192     if (__throw_res != JNI_OK) {                                                  \
 193       tty-&gt;print_cr(&quot;Throwing &quot; #name &quot; in &quot; caller &quot; returned %d&quot;, __throw_res); \
 194     }                                                                             \
 195     return result;                                                                \
 196   } while (0)
 197 
 198 jobjectArray readConfiguration0(JNIEnv *env, JVMCI_TRAPS);
 199 
 200 C2V_VMENTRY_NULL(jobjectArray, readConfiguration, (JNIEnv* env))
 201   jobjectArray config = readConfiguration0(env, JVMCI_CHECK_NULL);
 202   return config;
 203 }
 204 
 205 C2V_VMENTRY_NULL(jobject, getFlagValue, (JNIEnv* env, jobject c2vm, jobject name_handle))
 206 #define RETURN_BOXED_LONG(value) jvalue p; p.j = (jlong) (value); JVMCIObject box = JVMCIENV-&gt;create_box(T_LONG, &amp;p, JVMCI_CHECK_NULL); return box.as_jobject();
 207 #define RETURN_BOXED_DOUBLE(value) jvalue p; p.d = (jdouble) (value); JVMCIObject box = JVMCIENV-&gt;create_box(T_DOUBLE, &amp;p, JVMCI_CHECK_NULL); return box.as_jobject();
 208   JVMCIObject name = JVMCIENV-&gt;wrap(name_handle);
 209   if (name.is_null()) {
 210     JVMCI_THROW_NULL(NullPointerException);
 211   }
 212   const char* cstring = JVMCIENV-&gt;as_utf8_string(name);
 213   const JVMFlag* flag = JVMFlag::find_declared_flag(cstring);
 214   if (flag == NULL) {
 215     return c2vm;
 216   }
 217   if (flag-&gt;is_bool()) {
 218     jvalue prim;
 219     prim.z = flag-&gt;get_bool();
 220     JVMCIObject box = JVMCIENV-&gt;create_box(T_BOOLEAN, &amp;prim, JVMCI_CHECK_NULL);
 221     return JVMCIENV-&gt;get_jobject(box);
 222   } else if (flag-&gt;is_ccstr()) {
 223     JVMCIObject value = JVMCIENV-&gt;create_string(flag-&gt;get_ccstr(), JVMCI_CHECK_NULL);
 224     return JVMCIENV-&gt;get_jobject(value);
 225   } else if (flag-&gt;is_intx()) {
 226     RETURN_BOXED_LONG(flag-&gt;get_intx());
 227   } else if (flag-&gt;is_int()) {
 228     RETURN_BOXED_LONG(flag-&gt;get_int());
 229   } else if (flag-&gt;is_uint()) {
 230     RETURN_BOXED_LONG(flag-&gt;get_uint());
 231   } else if (flag-&gt;is_uint64_t()) {
 232     RETURN_BOXED_LONG(flag-&gt;get_uint64_t());
 233   } else if (flag-&gt;is_size_t()) {
 234     RETURN_BOXED_LONG(flag-&gt;get_size_t());
 235   } else if (flag-&gt;is_uintx()) {
 236     RETURN_BOXED_LONG(flag-&gt;get_uintx());
 237   } else if (flag-&gt;is_double()) {
 238     RETURN_BOXED_DOUBLE(flag-&gt;get_double());
 239   } else {
 240     JVMCI_ERROR_NULL(&quot;VM flag %s has unsupported type %s&quot;, flag-&gt;_name, flag-&gt;_type);
 241   }
 242 #undef RETURN_BOXED_LONG
 243 #undef RETURN_BOXED_DOUBLE
 244 C2V_END
 245 
 246 C2V_VMENTRY_NULL(jobject, getObjectAtAddress, (JNIEnv* env, jobject c2vm, jlong oop_address))
 247   requireInHotSpot(&quot;getObjectAtAddress&quot;, JVMCI_CHECK_NULL);
 248   if (oop_address == 0) {
 249     JVMCI_THROW_MSG_NULL(InternalError, &quot;Handle must be non-zero&quot;);
 250   }
 251   oop obj = *((oopDesc**) oop_address);
 252   if (obj != NULL) {
 253     oopDesc::verify(obj);
 254   }
 255   return JNIHandles::make_local(obj);
 256 C2V_END
 257 
 258 C2V_VMENTRY_NULL(jbyteArray, getBytecode, (JNIEnv* env, jobject, jobject jvmci_method))
 259   methodHandle method(THREAD, JVMCIENV-&gt;asMethod(jvmci_method));
 260 
 261   int code_size = method-&gt;code_size();
 262   jbyte* reconstituted_code = NEW_RESOURCE_ARRAY(jbyte, code_size);
 263 
 264   guarantee(method-&gt;method_holder()-&gt;is_rewritten(), &quot;Method&#39;s holder should be rewritten&quot;);
 265   // iterate over all bytecodes and replace non-Java bytecodes
 266 
 267   for (BytecodeStream s(method); s.next() != Bytecodes::_illegal; ) {
 268     Bytecodes::Code code = s.code();
 269     Bytecodes::Code raw_code = s.raw_code();
 270     int bci = s.bci();
 271     int len = s.instruction_size();
 272 
 273     // Restore original byte code.
 274     reconstituted_code[bci] =  (jbyte) (s.is_wide()? Bytecodes::_wide : code);
 275     if (len &gt; 1) {
 276       memcpy(reconstituted_code + (bci + 1), s.bcp()+1, len-1);
 277     }
 278 
 279     if (len &gt; 1) {
 280       // Restore the big-endian constant pool indexes.
 281       // Cf. Rewriter::scan_method
 282       switch (code) {
 283         case Bytecodes::_getstatic:
 284         case Bytecodes::_putstatic:
 285         case Bytecodes::_getfield:
 286         case Bytecodes::_putfield:
 287         case Bytecodes::_invokevirtual:
 288         case Bytecodes::_invokespecial:
 289         case Bytecodes::_invokestatic:
 290         case Bytecodes::_invokeinterface:
 291         case Bytecodes::_invokehandle: {
 292           int cp_index = Bytes::get_native_u2((address) reconstituted_code + (bci + 1));
 293           Bytes::put_Java_u2((address) reconstituted_code + (bci + 1), (u2) cp_index);
 294           break;
 295         }
 296 
 297         case Bytecodes::_invokedynamic: {
 298           int cp_index = Bytes::get_native_u4((address) reconstituted_code + (bci + 1));
 299           Bytes::put_Java_u4((address) reconstituted_code + (bci + 1), (u4) cp_index);
 300           break;
 301         }
 302 
 303         default:
 304           break;
 305       }
 306 
 307       // Not all ldc byte code are rewritten.
 308       switch (raw_code) {
 309         case Bytecodes::_fast_aldc: {
 310           int cpc_index = reconstituted_code[bci + 1] &amp; 0xff;
 311           int cp_index = method-&gt;constants()-&gt;object_to_cp_index(cpc_index);
 312           assert(cp_index &lt; method-&gt;constants()-&gt;length(), &quot;sanity check&quot;);
 313           reconstituted_code[bci + 1] = (jbyte) cp_index;
 314           break;
 315         }
 316 
 317         case Bytecodes::_fast_aldc_w: {
 318           int cpc_index = Bytes::get_native_u2((address) reconstituted_code + (bci + 1));
 319           int cp_index = method-&gt;constants()-&gt;object_to_cp_index(cpc_index);
 320           assert(cp_index &lt; method-&gt;constants()-&gt;length(), &quot;sanity check&quot;);
 321           Bytes::put_Java_u2((address) reconstituted_code + (bci + 1), (u2) cp_index);
 322           break;
 323         }
 324 
 325         default:
 326           break;
 327       }
 328     }
 329   }
 330 
 331   JVMCIPrimitiveArray result = JVMCIENV-&gt;new_byteArray(code_size, JVMCI_CHECK_NULL);
 332   JVMCIENV-&gt;copy_bytes_from(reconstituted_code, result, 0, code_size);
 333   return JVMCIENV-&gt;get_jbyteArray(result);
 334 C2V_END
 335 
 336 C2V_VMENTRY_0(jint, getExceptionTableLength, (JNIEnv* env, jobject, jobject jvmci_method))
 337   Method* method = JVMCIENV-&gt;asMethod(jvmci_method);
 338   return method-&gt;exception_table_length();
 339 C2V_END
 340 
 341 C2V_VMENTRY_0(jlong, getExceptionTableStart, (JNIEnv* env, jobject, jobject jvmci_method))
 342   Method* method = JVMCIENV-&gt;asMethod(jvmci_method);
 343   if (method-&gt;exception_table_length() == 0) {
 344     return 0L;
 345   }
 346   return (jlong) (address) method-&gt;exception_table_start();
 347 C2V_END
 348 
 349 C2V_VMENTRY_NULL(jobject, asResolvedJavaMethod, (JNIEnv* env, jobject, jobject executable_handle))
 350   requireInHotSpot(&quot;asResolvedJavaMethod&quot;, JVMCI_CHECK_NULL);
 351   oop executable = JNIHandles::resolve(executable_handle);
 352   oop mirror = NULL;
 353   int slot = 0;
 354 
 355   if (executable-&gt;klass() == SystemDictionary::reflect_Constructor_klass()) {
 356     mirror = java_lang_reflect_Constructor::clazz(executable);
 357     slot = java_lang_reflect_Constructor::slot(executable);
 358   } else {
 359     assert(executable-&gt;klass() == SystemDictionary::reflect_Method_klass(), &quot;wrong type&quot;);
 360     mirror = java_lang_reflect_Method::clazz(executable);
 361     slot = java_lang_reflect_Method::slot(executable);
 362   }
 363   Klass* holder = java_lang_Class::as_Klass(mirror);
 364   methodHandle method (THREAD, InstanceKlass::cast(holder)-&gt;method_with_idnum(slot));
 365   JVMCIObject result = JVMCIENV-&gt;get_jvmci_method(method, JVMCI_CHECK_NULL);
 366   return JVMCIENV-&gt;get_jobject(result);
 367 }
 368 
 369 C2V_VMENTRY_NULL(jobject, getResolvedJavaMethod, (JNIEnv* env, jobject, jobject base, jlong offset))
 370   Method* method;
 371   JVMCIObject base_object = JVMCIENV-&gt;wrap(base);
 372   if (base_object.is_null()) {
 373     method = *((Method**)(offset));
 374   } else if (JVMCIENV-&gt;isa_HotSpotObjectConstantImpl(base_object)) {
 375     Handle obj = JVMCIENV-&gt;asConstant(base_object, JVMCI_CHECK_NULL);
 376     if (obj-&gt;is_a(SystemDictionary::ResolvedMethodName_klass())) {
 377       method = (Method*) (intptr_t) obj-&gt;long_field(offset);
 378     } else {
 379       JVMCI_THROW_MSG_NULL(IllegalArgumentException, err_msg(&quot;Unexpected type: %s&quot;, obj-&gt;klass()-&gt;external_name()));
 380     }
 381   } else if (JVMCIENV-&gt;isa_HotSpotResolvedJavaMethodImpl(base_object)) {
 382     method = JVMCIENV-&gt;asMethod(base_object);
 383   }
 384   if (method == NULL) {
 385     JVMCI_THROW_MSG_NULL(IllegalArgumentException, err_msg(&quot;Unexpected type: %s&quot;, JVMCIENV-&gt;klass_name(base_object)));
 386   }
 387   assert (method-&gt;is_method(), &quot;invalid read&quot;);
 388   JVMCIObject result = JVMCIENV-&gt;get_jvmci_method(methodHandle(THREAD, method), JVMCI_CHECK_NULL);
 389   return JVMCIENV-&gt;get_jobject(result);
 390 }
 391 
 392 C2V_VMENTRY_NULL(jobject, getConstantPool, (JNIEnv* env, jobject, jobject object_handle))
 393   ConstantPool* cp = NULL;
 394   JVMCIObject object = JVMCIENV-&gt;wrap(object_handle);
 395   if (object.is_null()) {
 396     JVMCI_THROW_NULL(NullPointerException);
 397   }
 398   if (JVMCIENV-&gt;isa_HotSpotResolvedJavaMethodImpl(object)) {
 399     cp = JVMCIENV-&gt;asMethod(object)-&gt;constMethod()-&gt;constants();
 400   } else if (JVMCIENV-&gt;isa_HotSpotResolvedObjectTypeImpl(object)) {
 401     cp = InstanceKlass::cast(JVMCIENV-&gt;asKlass(object))-&gt;constants();
 402   } else {
 403     JVMCI_THROW_MSG_NULL(IllegalArgumentException,
 404                 err_msg(&quot;Unexpected type: %s&quot;, JVMCIENV-&gt;klass_name(object)));
 405   }
 406   assert(cp != NULL, &quot;npe&quot;);
 407 
 408   JVMCIObject result = JVMCIENV-&gt;get_jvmci_constant_pool(constantPoolHandle(THREAD, cp), JVMCI_CHECK_NULL);
 409   return JVMCIENV-&gt;get_jobject(result);
 410 }
 411 
 412 C2V_VMENTRY_NULL(jobject, getResolvedJavaType0, (JNIEnv* env, jobject, jobject base, jlong offset, jboolean compressed))
 413   JVMCIKlassHandle klass(THREAD);
 414   JVMCIObject base_object = JVMCIENV-&gt;wrap(base);
 415   jlong base_address = 0;
 416   if (base_object.is_non_null() &amp;&amp; offset == oopDesc::klass_offset_in_bytes()) {
 417     // klass = JVMCIENV-&gt;unhandle(base_object)-&gt;klass();
 418     if (JVMCIENV-&gt;isa_HotSpotObjectConstantImpl(base_object)) {
 419       Handle base_oop = JVMCIENV-&gt;asConstant(base_object, JVMCI_CHECK_NULL);
 420       klass = base_oop-&gt;klass();
 421     } else {
 422       assert(false, &quot;What types are we actually expecting here?&quot;);
 423     }
 424   } else if (!compressed) {
 425     if (base_object.is_non_null()) {
 426       if (JVMCIENV-&gt;isa_HotSpotResolvedJavaMethodImpl(base_object)) {
 427         base_address = (intptr_t) JVMCIENV-&gt;asMethod(base_object);
 428       } else if (JVMCIENV-&gt;isa_HotSpotConstantPool(base_object)) {
 429         base_address = (intptr_t) JVMCIENV-&gt;asConstantPool(base_object);
 430       } else if (JVMCIENV-&gt;isa_HotSpotResolvedObjectTypeImpl(base_object)) {
 431         base_address = (intptr_t) JVMCIENV-&gt;asKlass(base_object);
 432       } else if (JVMCIENV-&gt;isa_HotSpotObjectConstantImpl(base_object)) {
 433         Handle base_oop = JVMCIENV-&gt;asConstant(base_object, JVMCI_CHECK_NULL);
 434         if (base_oop-&gt;is_a(SystemDictionary::Class_klass())) {
 435           base_address = cast_from_oop&lt;jlong&gt;(base_oop());
 436         }
 437       }
 438       if (base_address == 0) {
 439         JVMCI_THROW_MSG_NULL(IllegalArgumentException,
 440                     err_msg(&quot;Unexpected arguments: %s &quot; JLONG_FORMAT &quot; %s&quot;, JVMCIENV-&gt;klass_name(base_object), offset, compressed ? &quot;true&quot; : &quot;false&quot;));
 441       }
 442     }
 443     klass = *((Klass**) (intptr_t) (base_address + offset));
 444   } else {
 445     JVMCI_THROW_MSG_NULL(IllegalArgumentException,
 446                 err_msg(&quot;Unexpected arguments: %s &quot; JLONG_FORMAT &quot; %s&quot;,
 447                         base_object.is_non_null() ? JVMCIENV-&gt;klass_name(base_object) : &quot;null&quot;,
 448                         offset, compressed ? &quot;true&quot; : &quot;false&quot;));
 449   }
 450   assert (klass == NULL || klass-&gt;is_klass(), &quot;invalid read&quot;);
 451   JVMCIObject result = JVMCIENV-&gt;get_jvmci_type(klass, JVMCI_CHECK_NULL);
 452   return JVMCIENV-&gt;get_jobject(result);
 453 }
 454 
 455 C2V_VMENTRY_NULL(jobject, findUniqueConcreteMethod, (JNIEnv* env, jobject, jobject jvmci_type, jobject jvmci_method))
 456   methodHandle method (THREAD, JVMCIENV-&gt;asMethod(jvmci_method));
 457   Klass* holder = JVMCIENV-&gt;asKlass(jvmci_type);
 458   if (holder-&gt;is_interface()) {
 459     JVMCI_THROW_MSG_NULL(InternalError, err_msg(&quot;Interface %s should be handled in Java code&quot;, holder-&gt;external_name()));
 460   }
 461   if (method-&gt;can_be_statically_bound()) {
 462     JVMCI_THROW_MSG_NULL(InternalError, err_msg(&quot;Effectively static method %s.%s should be handled in Java code&quot;, method-&gt;method_holder()-&gt;external_name(), method-&gt;external_name()));
 463   }
 464 
 465   methodHandle ucm;
 466   {
 467     MutexLocker locker(Compile_lock);
 468     ucm = methodHandle(THREAD, Dependencies::find_unique_concrete_method(holder, method()));
 469   }
 470   JVMCIObject result = JVMCIENV-&gt;get_jvmci_method(ucm, JVMCI_CHECK_NULL);
 471   return JVMCIENV-&gt;get_jobject(result);
 472 C2V_END
 473 
 474 C2V_VMENTRY_NULL(jobject, getImplementor, (JNIEnv* env, jobject, jobject jvmci_type))
 475   Klass* klass = JVMCIENV-&gt;asKlass(jvmci_type);
 476   if (!klass-&gt;is_interface()) {
 477     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
 478         err_msg(&quot;Expected interface type, got %s&quot;, klass-&gt;external_name()));
 479   }
 480   InstanceKlass* iklass = InstanceKlass::cast(klass);
 481   JVMCIKlassHandle handle(THREAD);
 482   {
 483     // Need Compile_lock around implementor()
 484     MutexLocker locker(Compile_lock);
 485     handle = iklass-&gt;implementor();
 486   }
 487   JVMCIObject implementor = JVMCIENV-&gt;get_jvmci_type(handle, JVMCI_CHECK_NULL);
 488   return JVMCIENV-&gt;get_jobject(implementor);
 489 C2V_END
 490 
 491 C2V_VMENTRY_0(jboolean, methodIsIgnoredBySecurityStackWalk,(JNIEnv* env, jobject, jobject jvmci_method))
 492   Method* method = JVMCIENV-&gt;asMethod(jvmci_method);
 493   return method-&gt;is_ignored_by_security_stack_walk();
 494 C2V_END
 495 
 496 C2V_VMENTRY_0(jboolean, isCompilable,(JNIEnv* env, jobject, jobject jvmci_method))
 497   Method* method = JVMCIENV-&gt;asMethod(jvmci_method);
 498   ConstantPool* cp = method-&gt;constMethod()-&gt;constants();
 499   assert(cp != NULL, &quot;npe&quot;);
 500   // don&#39;t inline method when constant pool contains a CONSTANT_Dynamic
 501   return !method-&gt;is_not_compilable(CompLevel_full_optimization) &amp;&amp; !cp-&gt;has_dynamic_constant();
 502 C2V_END
 503 
 504 C2V_VMENTRY_0(jboolean, hasNeverInlineDirective,(JNIEnv* env, jobject, jobject jvmci_method))
 505   methodHandle method (THREAD, JVMCIENV-&gt;asMethod(jvmci_method));
 506   return !Inline || CompilerOracle::should_not_inline(method) || method-&gt;dont_inline();
 507 C2V_END
 508 
 509 C2V_VMENTRY_0(jboolean, shouldInlineMethod,(JNIEnv* env, jobject, jobject jvmci_method))
 510   methodHandle method (THREAD, JVMCIENV-&gt;asMethod(jvmci_method));
 511   return CompilerOracle::should_inline(method) || method-&gt;force_inline();
 512 C2V_END
 513 
 514 C2V_VMENTRY_NULL(jobject, lookupType, (JNIEnv* env, jobject, jstring jname, jclass accessing_class, jboolean resolve))
 515   JVMCIObject name = JVMCIENV-&gt;wrap(jname);
 516   const char* str = JVMCIENV-&gt;as_utf8_string(name);
 517   TempNewSymbol class_name = SymbolTable::new_symbol(str);
 518 
 519   if (class_name-&gt;utf8_length() &lt;= 1) {
 520     JVMCI_THROW_MSG_0(InternalError, err_msg(&quot;Primitive type %s should be handled in Java code&quot;, class_name-&gt;as_C_string()));
 521   }
 522 
 523   JVMCIKlassHandle resolved_klass(THREAD);
 524   Klass* accessing_klass = NULL;
 525   Handle class_loader;
 526   Handle protection_domain;
 527   if (accessing_class != NULL) {
 528     accessing_klass = JVMCIENV-&gt;asKlass(accessing_class);
 529     class_loader = Handle(THREAD, accessing_klass-&gt;class_loader());
 530     protection_domain = Handle(THREAD, accessing_klass-&gt;protection_domain());
 531   } else {
 532     // Use the System class loader
 533     class_loader = Handle(THREAD, SystemDictionary::java_system_loader());
 534     JVMCIENV-&gt;runtime()-&gt;initialize(JVMCIENV);
 535   }
 536 
 537   if (resolve) {
 538     resolved_klass = SystemDictionary::resolve_or_null(class_name, class_loader, protection_domain, CHECK_NULL);
 539     if (resolved_klass == NULL) {
 540       JVMCI_THROW_MSG_NULL(ClassNotFoundException, str);
 541     }
 542   } else {
 543     if (Signature::has_envelope(class_name)) {
 544       // This is a name from a signature.  Strip off the trimmings.
 545       // Call recursive to keep scope of strippedsym.
 546       TempNewSymbol strippedsym = Signature::strip_envelope(class_name);
 547       resolved_klass = SystemDictionary::find(strippedsym, class_loader, protection_domain, CHECK_NULL);
 548     } else if (Signature::is_array(class_name)) {
 549       SignatureStream ss(class_name, false);
 550       int ndim = ss.skip_array_prefix();
 551       if (ss.type() == T_OBJECT) {
 552         Symbol* strippedsym = ss.as_symbol();
 553         resolved_klass = SystemDictionary::find(strippedsym,
 554                                                 class_loader,
 555                                                 protection_domain,
 556                                                 CHECK_NULL);
 557         if (!resolved_klass.is_null()) {
 558           resolved_klass = resolved_klass-&gt;array_klass(ndim, CHECK_NULL);
 559         }
 560       } else {
 561         resolved_klass = TypeArrayKlass::cast(Universe::typeArrayKlassObj(ss.type()))-&gt;array_klass(ndim, CHECK_NULL);
 562       }
 563     } else {
 564       resolved_klass = SystemDictionary::find(class_name, class_loader, protection_domain, CHECK_NULL);
 565     }
 566   }
 567   JVMCIObject result = JVMCIENV-&gt;get_jvmci_type(resolved_klass, JVMCI_CHECK_NULL);
 568   return JVMCIENV-&gt;get_jobject(result);
 569 C2V_END
 570 
 571 C2V_VMENTRY_NULL(jobject, getArrayType, (JNIEnv* env, jobject, jobject jvmci_type))
 572   if (jvmci_type == NULL) {
 573     JVMCI_THROW_0(NullPointerException);
 574   }
 575 
 576   JVMCIObject jvmci_type_object = JVMCIENV-&gt;wrap(jvmci_type);
 577   JVMCIKlassHandle array_klass(THREAD);
 578   if (JVMCIENV-&gt;isa_HotSpotResolvedPrimitiveType(jvmci_type_object)) {
 579     BasicType type = JVMCIENV-&gt;kindToBasicType(JVMCIENV-&gt;get_HotSpotResolvedPrimitiveType_kind(jvmci_type_object), JVMCI_CHECK_0);
 580     if (type == T_VOID) {
 581       return NULL;
 582     }
 583     array_klass = Universe::typeArrayKlassObj(type);
 584     if (array_klass == NULL) {
 585       JVMCI_THROW_MSG_NULL(InternalError, err_msg(&quot;No array klass for primitive type %s&quot;, type2name(type)));
 586     }
 587   } else {
 588     Klass* klass = JVMCIENV-&gt;asKlass(jvmci_type);
 589     if (klass == NULL) {
 590       JVMCI_THROW_0(NullPointerException);
 591     }
 592     array_klass = klass-&gt;array_klass(CHECK_NULL);
 593   }
 594   JVMCIObject result = JVMCIENV-&gt;get_jvmci_type(array_klass, JVMCI_CHECK_NULL);
 595   return JVMCIENV-&gt;get_jobject(result);
 596 C2V_END
 597 
 598 C2V_VMENTRY_NULL(jobject, lookupClass, (JNIEnv* env, jobject, jclass mirror))
 599   requireInHotSpot(&quot;lookupClass&quot;, JVMCI_CHECK_NULL);
 600   if (mirror == NULL) {
 601     return NULL;
 602   }
 603   JVMCIKlassHandle klass(THREAD);
 604   klass = java_lang_Class::as_Klass(JNIHandles::resolve(mirror));
 605   if (klass == NULL) {
 606     JVMCI_THROW_MSG_NULL(IllegalArgumentException, &quot;Primitive classes are unsupported&quot;);
 607   }
 608   JVMCIObject result = JVMCIENV-&gt;get_jvmci_type(klass, JVMCI_CHECK_NULL);
 609   return JVMCIENV-&gt;get_jobject(result);
 610 }
 611 
 612 C2V_VMENTRY_NULL(jobject, resolvePossiblyCachedConstantInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))
 613   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));
 614   oop result = cp-&gt;resolve_possibly_cached_constant_at(index, CHECK_NULL);
 615   return JVMCIENV-&gt;get_jobject(JVMCIENV-&gt;get_object_constant(result));
 616 C2V_END
 617 
 618 C2V_VMENTRY_0(jint, lookupNameAndTypeRefIndexInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))
 619   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));
 620   return cp-&gt;name_and_type_ref_index_at(index);
 621 C2V_END
 622 
 623 C2V_VMENTRY_NULL(jobject, lookupNameInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint which))
 624   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));
 625   JVMCIObject sym = JVMCIENV-&gt;create_string(cp-&gt;name_ref_at(which), JVMCI_CHECK_NULL);
 626   return JVMCIENV-&gt;get_jobject(sym);
 627 C2V_END
 628 
 629 C2V_VMENTRY_NULL(jobject, lookupSignatureInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint which))
 630   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));
 631   JVMCIObject sym = JVMCIENV-&gt;create_string(cp-&gt;signature_ref_at(which), JVMCI_CHECK_NULL);
 632   return JVMCIENV-&gt;get_jobject(sym);
 633 C2V_END
 634 
 635 C2V_VMENTRY_0(jint, lookupKlassRefIndexInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))
 636   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));
 637   return cp-&gt;klass_ref_index_at(index);
 638 C2V_END
 639 
 640 C2V_VMENTRY_NULL(jobject, resolveTypeInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))
 641   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));
 642   Klass* klass = cp-&gt;klass_at(index, CHECK_NULL);
 643   JVMCIKlassHandle resolved_klass(THREAD, klass);
 644   if (resolved_klass-&gt;is_instance_klass()) {
 645     InstanceKlass::cast(resolved_klass())-&gt;link_class(CHECK_NULL);
 646     if (!InstanceKlass::cast(resolved_klass())-&gt;is_linked()) {
 647       // link_class() should not return here if there is an issue.
 648       JVMCI_THROW_MSG_NULL(InternalError, err_msg(&quot;Class %s must be linked&quot;, resolved_klass()-&gt;external_name()));
 649     }
 650   }
 651   JVMCIObject klassObject = JVMCIENV-&gt;get_jvmci_type(resolved_klass, JVMCI_CHECK_NULL);
 652   return JVMCIENV-&gt;get_jobject(klassObject);
 653 C2V_END
 654 
 655 C2V_VMENTRY_NULL(jobject, lookupKlassInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index, jbyte opcode))
 656   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));
 657   Klass* loading_klass = cp-&gt;pool_holder();
 658   bool is_accessible = false;
 659   JVMCIKlassHandle klass(THREAD, JVMCIRuntime::get_klass_by_index(cp, index, is_accessible, loading_klass));
 660   Symbol* symbol = NULL;
 661   if (klass.is_null()) {
 662     constantTag tag = cp-&gt;tag_at(index);
 663     if (tag.is_klass()) {
 664       // The klass has been inserted into the constant pool
 665       // very recently.
 666       klass = cp-&gt;resolved_klass_at(index);
 667     } else if (tag.is_symbol()) {
 668       symbol = cp-&gt;symbol_at(index);
 669     } else {
 670       assert(cp-&gt;tag_at(index).is_unresolved_klass(), &quot;wrong tag&quot;);
 671       symbol = cp-&gt;klass_name_at(index);
 672     }
 673   }
 674   JVMCIObject result;
 675   if (!klass.is_null()) {
 676     result = JVMCIENV-&gt;get_jvmci_type(klass, JVMCI_CHECK_NULL);
 677   } else {
 678     result = JVMCIENV-&gt;create_string(symbol, JVMCI_CHECK_NULL);
 679   }
 680   return JVMCIENV-&gt;get_jobject(result);
 681 C2V_END
 682 
 683 C2V_VMENTRY_NULL(jobject, lookupAppendixInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))
 684   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));
 685   oop appendix_oop = ConstantPool::appendix_at_if_loaded(cp, index);
 686   return JVMCIENV-&gt;get_jobject(JVMCIENV-&gt;get_object_constant(appendix_oop));
 687 C2V_END
 688 
 689 C2V_VMENTRY_NULL(jobject, lookupMethodInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index, jbyte opcode))
 690   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));
 691   InstanceKlass* pool_holder = cp-&gt;pool_holder();
 692   Bytecodes::Code bc = (Bytecodes::Code) (((int) opcode) &amp; 0xFF);
 693   methodHandle method(THREAD, JVMCIRuntime::get_method_by_index(cp, index, bc, pool_holder));
 694   JVMCIObject result = JVMCIENV-&gt;get_jvmci_method(method, JVMCI_CHECK_NULL);
 695   return JVMCIENV-&gt;get_jobject(result);
 696 C2V_END
 697 
 698 C2V_VMENTRY_0(jint, constantPoolRemapInstructionOperandFromCache, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))
 699   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));
 700   return cp-&gt;remap_instruction_operand_from_cache(index);
 701 C2V_END
 702 
 703 C2V_VMENTRY_NULL(jobject, resolveFieldInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index, jobject jvmci_method, jbyte opcode, jintArray info_handle))
 704   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));
 705   Bytecodes::Code code = (Bytecodes::Code)(((int) opcode) &amp; 0xFF);
 706   fieldDescriptor fd;
 707   methodHandle mh(THREAD, (jvmci_method != NULL) ? JVMCIENV-&gt;asMethod(jvmci_method) : NULL);
 708   LinkInfo link_info(cp, index, mh, CHECK_NULL);
 709   LinkResolver::resolve_field(fd, link_info, Bytecodes::java_code(code), false, CHECK_NULL);
 710   JVMCIPrimitiveArray info = JVMCIENV-&gt;wrap(info_handle);
 711   if (info.is_null() || JVMCIENV-&gt;get_length(info) != 3) {
 712     JVMCI_ERROR_NULL(&quot;info must not be null and have a length of 3&quot;);
 713   }
 714   JVMCIENV-&gt;put_int_at(info, 0, fd.access_flags().as_int());
 715   JVMCIENV-&gt;put_int_at(info, 1, fd.offset());
 716   JVMCIENV-&gt;put_int_at(info, 2, fd.index());
 717   JVMCIKlassHandle handle(THREAD, fd.field_holder());
 718   JVMCIObject field_holder = JVMCIENV-&gt;get_jvmci_type(handle, JVMCI_CHECK_NULL);
 719   return JVMCIENV-&gt;get_jobject(field_holder);
 720 C2V_END
 721 
 722 C2V_VMENTRY_0(jint, getVtableIndexForInterfaceMethod, (JNIEnv* env, jobject, jobject jvmci_type, jobject jvmci_method))
 723   Klass* klass = JVMCIENV-&gt;asKlass(jvmci_type);
 724   methodHandle method(THREAD, JVMCIENV-&gt;asMethod(jvmci_method));
 725   if (klass-&gt;is_interface()) {
 726     JVMCI_THROW_MSG_0(InternalError, err_msg(&quot;Interface %s should be handled in Java code&quot;, klass-&gt;external_name()));
 727   }
 728   if (!method-&gt;method_holder()-&gt;is_interface()) {
 729     JVMCI_THROW_MSG_0(InternalError, err_msg(&quot;Method %s is not held by an interface, this case should be handled in Java code&quot;, method-&gt;name_and_sig_as_C_string()));
 730   }
 731   if (!klass-&gt;is_instance_klass()) {
 732     JVMCI_THROW_MSG_0(InternalError, err_msg(&quot;Class %s must be instance klass&quot;, klass-&gt;external_name()));
 733   }
 734   if (!InstanceKlass::cast(klass)-&gt;is_linked()) {
 735     JVMCI_THROW_MSG_0(InternalError, err_msg(&quot;Class %s must be linked&quot;, klass-&gt;external_name()));
 736   }
 737   return LinkResolver::vtable_index_of_interface_method(klass, method);
 738 C2V_END
 739 
 740 C2V_VMENTRY_NULL(jobject, resolveMethod, (JNIEnv* env, jobject, jobject receiver_jvmci_type, jobject jvmci_method, jobject caller_jvmci_type))
 741   Klass* recv_klass = JVMCIENV-&gt;asKlass(receiver_jvmci_type);
 742   Klass* caller_klass = JVMCIENV-&gt;asKlass(caller_jvmci_type);
 743   methodHandle method(THREAD, JVMCIENV-&gt;asMethod(jvmci_method));
 744 
 745   Klass* resolved     = method-&gt;method_holder();
 746   Symbol* h_name      = method-&gt;name();
 747   Symbol* h_signature = method-&gt;signature();
 748 
 749   if (MethodHandles::is_signature_polymorphic_method(method())) {
 750       // Signature polymorphic methods are already resolved, JVMCI just returns NULL in this case.
 751       return NULL;
 752   }
 753 
 754   if (method-&gt;name() == vmSymbols::clone_name() &amp;&amp;
 755       resolved == SystemDictionary::Object_klass() &amp;&amp;
 756       recv_klass-&gt;is_array_klass()) {
 757     // Resolution of the clone method on arrays always returns Object.clone even though that method
 758     // has protected access.  There&#39;s some trickery in the access checking to make this all work out
 759     // so it&#39;s necessary to pass in the array class as the resolved class to properly trigger this.
 760     // Otherwise it&#39;s impossible to resolve the array clone methods through JVMCI.  See
 761     // LinkResolver::check_method_accessability for the matching logic.
 762     resolved = recv_klass;
 763   }
 764 
 765   LinkInfo link_info(resolved, h_name, h_signature, caller_klass);
 766   Method* m = NULL;
 767   // Only do exact lookup if receiver klass has been linked.  Otherwise,
 768   // the vtable has not been setup, and the LinkResolver will fail.
 769   if (recv_klass-&gt;is_array_klass() ||
 770       (InstanceKlass::cast(recv_klass)-&gt;is_linked() &amp;&amp; !recv_klass-&gt;is_interface())) {
 771     if (resolved-&gt;is_interface()) {
 772       m = LinkResolver::resolve_interface_call_or_null(recv_klass, link_info);
 773     } else {
 774       m = LinkResolver::resolve_virtual_call_or_null(recv_klass, link_info);
 775     }
 776   }
 777 
 778   if (m == NULL) {
 779     // Return NULL if there was a problem with lookup (uninitialized class, etc.)
 780     return NULL;
 781   }
 782 
 783   JVMCIObject result = JVMCIENV-&gt;get_jvmci_method(methodHandle(THREAD, m), JVMCI_CHECK_NULL);
 784   return JVMCIENV-&gt;get_jobject(result);
 785 C2V_END
 786 
 787 C2V_VMENTRY_0(jboolean, hasFinalizableSubclass,(JNIEnv* env, jobject, jobject jvmci_type))
 788   Klass* klass = JVMCIENV-&gt;asKlass(jvmci_type);
 789   assert(klass != NULL, &quot;method must not be called for primitive types&quot;);
 790   return Dependencies::find_finalizable_subclass(klass) != NULL;
 791 C2V_END
 792 
 793 C2V_VMENTRY_NULL(jobject, getClassInitializer, (JNIEnv* env, jobject, jobject jvmci_type))
 794   Klass* klass = JVMCIENV-&gt;asKlass(jvmci_type);
 795   if (!klass-&gt;is_instance_klass()) {
 796     return NULL;
 797   }
 798   InstanceKlass* iklass = InstanceKlass::cast(klass);
 799   methodHandle clinit(THREAD, iklass-&gt;class_initializer());
 800   JVMCIObject result = JVMCIENV-&gt;get_jvmci_method(clinit, JVMCI_CHECK_NULL);
 801   return JVMCIENV-&gt;get_jobject(result);
 802 C2V_END
 803 
 804 C2V_VMENTRY_0(jlong, getMaxCallTargetOffset, (JNIEnv* env, jobject, jlong addr))
 805   address target_addr = (address) addr;
 806   if (target_addr != 0x0) {
 807     int64_t off_low = (int64_t)target_addr - ((int64_t)CodeCache::low_bound() + sizeof(int));
 808     int64_t off_high = (int64_t)target_addr - ((int64_t)CodeCache::high_bound() + sizeof(int));
 809     return MAX2(ABS(off_low), ABS(off_high));
 810   }
 811   return -1;
 812 C2V_END
 813 
 814 C2V_VMENTRY(void, setNotInlinableOrCompilable,(JNIEnv* env, jobject,  jobject jvmci_method))
 815   methodHandle method(THREAD, JVMCIENV-&gt;asMethod(jvmci_method));
 816   method-&gt;set_not_c1_compilable();
 817   method-&gt;set_not_c2_compilable();
 818   method-&gt;set_dont_inline(true);
 819 C2V_END
 820 
 821 C2V_VMENTRY_0(jint, installCode, (JNIEnv *env, jobject, jobject target, jobject compiled_code,
 822             jobject installed_code, jlong failed_speculations_address, jbyteArray speculations_obj))
 823   HandleMark hm;
 824   JNIHandleMark jni_hm(thread);
 825 
 826   JVMCIObject target_handle = JVMCIENV-&gt;wrap(target);
 827   JVMCIObject compiled_code_handle = JVMCIENV-&gt;wrap(compiled_code);
 828   CodeBlob* cb = NULL;
 829   JVMCIObject installed_code_handle = JVMCIENV-&gt;wrap(installed_code);
 830   JVMCIPrimitiveArray speculations_handle = JVMCIENV-&gt;wrap(speculations_obj);
 831 
 832   int speculations_len = JVMCIENV-&gt;get_length(speculations_handle);
 833   char* speculations = NEW_RESOURCE_ARRAY(char, speculations_len);
 834   JVMCIENV-&gt;copy_bytes_to(speculations_handle, (jbyte*) speculations, 0, speculations_len);
 835 
 836   JVMCICompiler* compiler = JVMCICompiler::instance(true, CHECK_JNI_ERR);
 837 
 838   TraceTime install_time(&quot;installCode&quot;, JVMCICompiler::codeInstallTimer());
 839   bool is_immutable_PIC = JVMCIENV-&gt;get_HotSpotCompiledCode_isImmutablePIC(compiled_code_handle) &gt; 0;
 840 
 841   CodeInstaller installer(JVMCIENV, is_immutable_PIC);
 842   JVMCI::CodeInstallResult result = installer.install(compiler,
 843       target_handle,
 844       compiled_code_handle,
 845       cb,
 846       installed_code_handle,
 847       (FailedSpeculation**)(address) failed_speculations_address,
 848       speculations,
 849       speculations_len,
 850       JVMCI_CHECK_0);
 851 
 852   if (PrintCodeCacheOnCompilation) {
 853     stringStream s;
 854     // Dump code cache into a buffer before locking the tty,
 855     {
 856       MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
 857       CodeCache::print_summary(&amp;s, false);
 858     }
 859     ttyLocker ttyl;
 860     tty-&gt;print_raw_cr(s.as_string());
 861   }
 862 
 863   if (result != JVMCI::ok) {
 864     assert(cb == NULL, &quot;should be&quot;);
 865   } else {
 866     if (installed_code_handle.is_non_null()) {
 867       if (cb-&gt;is_nmethod()) {
 868         assert(JVMCIENV-&gt;isa_HotSpotNmethod(installed_code_handle), &quot;wrong type&quot;);
 869         // Clear the link to an old nmethod first
 870         JVMCIObject nmethod_mirror = installed_code_handle;
 871         JVMCIENV-&gt;invalidate_nmethod_mirror(nmethod_mirror, JVMCI_CHECK_0);
 872       } else {
 873         assert(JVMCIENV-&gt;isa_InstalledCode(installed_code_handle), &quot;wrong type&quot;);
 874       }
 875       // Initialize the link to the new code blob
 876       JVMCIENV-&gt;initialize_installed_code(installed_code_handle, cb, JVMCI_CHECK_0);
 877     }
 878   }
 879   return result;
 880 C2V_END
 881 
 882 C2V_VMENTRY_0(jint, getMetadata, (JNIEnv *env, jobject, jobject target, jobject compiled_code, jobject metadata))
 883 #if INCLUDE_AOT
 884   HandleMark hm;
 885   assert(JVMCIENV-&gt;is_hotspot(), &quot;AOT code is executed only in HotSpot mode&quot;);
 886 
 887   JVMCIObject target_handle = JVMCIENV-&gt;wrap(target);
 888   JVMCIObject compiled_code_handle = JVMCIENV-&gt;wrap(compiled_code);
 889   JVMCIObject metadata_handle = JVMCIENV-&gt;wrap(metadata);
 890 
 891   CodeMetadata code_metadata;
 892 
 893   CodeInstaller installer(JVMCIENV, true /* immutable PIC compilation */);
 894   JVMCI::CodeInstallResult result = installer.gather_metadata(target_handle, compiled_code_handle, code_metadata, JVMCI_CHECK_0);
 895   if (result != JVMCI::ok) {
 896     return result;
 897   }
 898 
 899   if (code_metadata.get_nr_pc_desc() &gt; 0) {
 900     int size = sizeof(PcDesc) * code_metadata.get_nr_pc_desc();
 901     JVMCIPrimitiveArray array = JVMCIENV-&gt;new_byteArray(size, JVMCI_CHECK_(JVMCI::cache_full));
 902     JVMCIENV-&gt;copy_bytes_from((jbyte*) code_metadata.get_pc_desc(), array, 0, size);
 903     HotSpotJVMCI::HotSpotMetaData::set_pcDescBytes(JVMCIENV, metadata_handle, array);
 904   }
 905 
 906   if (code_metadata.get_scopes_size() &gt; 0) {
 907     int size = code_metadata.get_scopes_size();
 908     JVMCIPrimitiveArray array = JVMCIENV-&gt;new_byteArray(size, JVMCI_CHECK_(JVMCI::cache_full));
 909     JVMCIENV-&gt;copy_bytes_from((jbyte*) code_metadata.get_scopes_desc(), array, 0, size);
 910     HotSpotJVMCI::HotSpotMetaData::set_scopesDescBytes(JVMCIENV, metadata_handle, array);
 911   }
 912 
 913   RelocBuffer* reloc_buffer = code_metadata.get_reloc_buffer();
 914   int size = (int) reloc_buffer-&gt;size();
 915   JVMCIPrimitiveArray array = JVMCIENV-&gt;new_byteArray(size, JVMCI_CHECK_(JVMCI::cache_full));
 916   JVMCIENV-&gt;copy_bytes_from((jbyte*) reloc_buffer-&gt;begin(), array, 0, size);
 917   HotSpotJVMCI::HotSpotMetaData::set_relocBytes(JVMCIENV, metadata_handle, array);
 918 
 919   const OopMapSet* oopMapSet = installer.oopMapSet();
 920   {
 921     ResourceMark mark;
 922     ImmutableOopMapBuilder builder(oopMapSet);
 923     int size = builder.heap_size();
 924     JVMCIPrimitiveArray array = JVMCIENV-&gt;new_byteArray(size, JVMCI_CHECK_(JVMCI::cache_full));
 925     builder.generate_into((address) HotSpotJVMCI::resolve(array)-&gt;byte_at_addr(0));
 926     HotSpotJVMCI::HotSpotMetaData::set_oopMaps(JVMCIENV, metadata_handle, array);
 927   }
 928 
 929   AOTOopRecorder* recorder = code_metadata.get_oop_recorder();
 930 
 931   int nr_meta_refs = recorder-&gt;nr_meta_refs();
 932   JVMCIObjectArray metadataArray = JVMCIENV-&gt;new_Object_array(nr_meta_refs, JVMCI_CHECK_(JVMCI::cache_full));
 933   for (int i = 0; i &lt; nr_meta_refs; ++i) {
 934     jobject element = recorder-&gt;meta_element(i);
 935     if (element == NULL) {
 936       return JVMCI::cache_full;
 937     }
 938     JVMCIENV-&gt;put_object_at(metadataArray, i, JVMCIENV-&gt;wrap(element));
 939   }
 940   HotSpotJVMCI::HotSpotMetaData::set_metadata(JVMCIENV, metadata_handle, metadataArray);
 941 
 942   ExceptionHandlerTable* handler = code_metadata.get_exception_table();
 943   int table_size = handler-&gt;size_in_bytes();
 944   JVMCIPrimitiveArray exceptionArray = JVMCIENV-&gt;new_byteArray(table_size, JVMCI_CHECK_(JVMCI::cache_full));
 945   if (table_size &gt; 0) {
 946     handler-&gt;copy_bytes_to((address) HotSpotJVMCI::resolve(exceptionArray)-&gt;byte_at_addr(0));
 947   }
 948   HotSpotJVMCI::HotSpotMetaData::set_exceptionBytes(JVMCIENV, metadata_handle, exceptionArray);
 949 
 950   ImplicitExceptionTable* implicit = code_metadata.get_implicit_exception_table();
 951   int implicit_table_size = implicit-&gt;size_in_bytes();
 952   JVMCIPrimitiveArray implicitExceptionArray = JVMCIENV-&gt;new_byteArray(implicit_table_size, JVMCI_CHECK_(JVMCI::cache_full));
 953   if (implicit_table_size &gt; 0) {
 954     implicit-&gt;copy_bytes_to((address) HotSpotJVMCI::resolve(implicitExceptionArray)-&gt;byte_at_addr(0), implicit_table_size);
 955   }
 956   HotSpotJVMCI::HotSpotMetaData::set_implicitExceptionBytes(JVMCIENV, metadata_handle, implicitExceptionArray);
 957 
 958   return result;
 959 #else
 960   JVMCI_THROW_MSG_0(InternalError, &quot;unimplemented&quot;);
 961 #endif
 962 C2V_END
 963 
 964 C2V_VMENTRY(void, resetCompilationStatistics, (JNIEnv* env, jobject))
 965   JVMCICompiler* compiler = JVMCICompiler::instance(true, CHECK);
 966   CompilerStatistics* stats = compiler-&gt;stats();
 967   stats-&gt;_standard.reset();
 968   stats-&gt;_osr.reset();
 969 C2V_END
 970 
 971 C2V_VMENTRY_NULL(jobject, disassembleCodeBlob, (JNIEnv* env, jobject, jobject installedCode))
 972   HandleMark hm;
 973 
 974   if (installedCode == NULL) {
 975     JVMCI_THROW_MSG_NULL(NullPointerException, &quot;installedCode is null&quot;);
 976   }
 977 
 978   JVMCIObject installedCodeObject = JVMCIENV-&gt;wrap(installedCode);
 979   nmethodLocker locker;
 980   CodeBlob* cb = JVMCIENV-&gt;get_code_blob(installedCodeObject, locker);
 981   if (cb == NULL) {
 982     return NULL;
 983   }
 984 
 985   // We don&#39;t want the stringStream buffer to resize during disassembly as it
 986   // uses scoped resource memory. If a nested function called during disassembly uses
 987   // a ResourceMark and the buffer expands within the scope of the mark,
 988   // the buffer becomes garbage when that scope is exited. Experience shows that
 989   // the disassembled code is typically about 10x the code size so a fixed buffer
 990   // sized to 20x code size plus a fixed amount for header info should be sufficient.
 991   int bufferSize = cb-&gt;code_size() * 20 + 1024;
 992   char* buffer = NEW_RESOURCE_ARRAY(char, bufferSize);
 993   stringStream st(buffer, bufferSize);
 994   if (cb-&gt;is_nmethod()) {
 995     nmethod* nm = (nmethod*) cb;
 996     if (!nm-&gt;is_alive()) {
 997       return NULL;
 998     }
 999   }
1000   Disassembler::decode(cb, &amp;st);
1001   if (st.size() &lt;= 0) {
1002     return NULL;
1003   }
1004 
1005   JVMCIObject result = JVMCIENV-&gt;create_string(st.as_string(), JVMCI_CHECK_NULL);
1006   return JVMCIENV-&gt;get_jobject(result);
1007 C2V_END
1008 
1009 C2V_VMENTRY_NULL(jobject, getStackTraceElement, (JNIEnv* env, jobject, jobject jvmci_method, int bci))
1010   HandleMark hm;
1011 
1012   methodHandle method(THREAD, JVMCIENV-&gt;asMethod(jvmci_method));
1013   JVMCIObject element = JVMCIENV-&gt;new_StackTraceElement(method, bci, JVMCI_CHECK_NULL);
1014   return JVMCIENV-&gt;get_jobject(element);
1015 C2V_END
1016 
1017 C2V_VMENTRY_NULL(jobject, executeHotSpotNmethod, (JNIEnv* env, jobject, jobject args, jobject hs_nmethod))
1018   // The incoming arguments array would have to contain JavaConstants instead of regular objects
1019   // and the return value would have to be wrapped as a JavaConstant.
1020   requireInHotSpot(&quot;executeHotSpotNmethod&quot;, JVMCI_CHECK_NULL);
1021 
1022   HandleMark hm;
1023 
1024   JVMCIObject nmethod_mirror = JVMCIENV-&gt;wrap(hs_nmethod);
1025   nmethodLocker locker;
1026   nmethod* nm = JVMCIENV-&gt;get_nmethod(nmethod_mirror, locker);
1027   if (nm == NULL) {
1028     JVMCI_THROW_NULL(InvalidInstalledCodeException);
1029   }
1030   methodHandle mh(THREAD, nm-&gt;method());
1031   Symbol* signature = mh-&gt;signature();
1032   JavaCallArguments jca(mh-&gt;size_of_parameters());
1033 
1034   JavaArgumentUnboxer jap(signature, &amp;jca, (arrayOop) JNIHandles::resolve(args), mh-&gt;is_static());
1035   JavaValue result(jap.return_type());
1036   jca.set_alternative_target(nm);
1037   JavaCalls::call(&amp;result, mh, &amp;jca, CHECK_NULL);
1038 
1039   if (jap.return_type() == T_VOID) {
1040     return NULL;
1041   } else if (is_reference_type(jap.return_type())) {
1042     return JNIHandles::make_local((oop) result.get_jobject());
1043   } else {
1044     jvalue *value = (jvalue *) result.get_value_addr();
1045     // Narrow the value down if required (Important on big endian machines)
1046     switch (jap.return_type()) {
1047       case T_BOOLEAN:
1048        value-&gt;z = (jboolean) value-&gt;i;
1049        break;
1050       case T_BYTE:
1051        value-&gt;b = (jbyte) value-&gt;i;
1052        break;
1053       case T_CHAR:
1054        value-&gt;c = (jchar) value-&gt;i;
1055        break;
1056       case T_SHORT:
1057        value-&gt;s = (jshort) value-&gt;i;
1058        break;
1059       default:
1060         break;
1061     }
1062     JVMCIObject o = JVMCIENV-&gt;create_box(jap.return_type(), value, JVMCI_CHECK_NULL);
1063     return JVMCIENV-&gt;get_jobject(o);
1064   }
1065 C2V_END
1066 
1067 C2V_VMENTRY_NULL(jlongArray, getLineNumberTable, (JNIEnv* env, jobject, jobject jvmci_method))
1068   Method* method = JVMCIENV-&gt;asMethod(jvmci_method);
1069   if (!method-&gt;has_linenumber_table()) {
1070     return NULL;
1071   }
1072   u2 num_entries = 0;
1073   CompressedLineNumberReadStream streamForSize(method-&gt;compressed_linenumber_table());
1074   while (streamForSize.read_pair()) {
1075     num_entries++;
1076   }
1077 
1078   CompressedLineNumberReadStream stream(method-&gt;compressed_linenumber_table());
1079   JVMCIPrimitiveArray result = JVMCIENV-&gt;new_longArray(2 * num_entries, JVMCI_CHECK_NULL);
1080 
1081   int i = 0;
1082   jlong value;
1083   while (stream.read_pair()) {
1084     value = ((long) stream.bci());
1085     JVMCIENV-&gt;put_long_at(result, i, value);
1086     value = ((long) stream.line());
1087     JVMCIENV-&gt;put_long_at(result, i + 1, value);
1088     i += 2;
1089   }
1090 
1091   return (jlongArray) JVMCIENV-&gt;get_jobject(result);
1092 C2V_END
1093 
1094 C2V_VMENTRY_0(jlong, getLocalVariableTableStart, (JNIEnv* env, jobject, jobject jvmci_method))
1095   Method* method = JVMCIENV-&gt;asMethod(jvmci_method);
1096   if (!method-&gt;has_localvariable_table()) {
1097     return 0;
1098   }
1099   return (jlong) (address) method-&gt;localvariable_table_start();
1100 C2V_END
1101 
1102 C2V_VMENTRY_0(jint, getLocalVariableTableLength, (JNIEnv* env, jobject, jobject jvmci_method))
1103   Method* method = JVMCIENV-&gt;asMethod(jvmci_method);
1104   return method-&gt;localvariable_table_length();
1105 C2V_END
1106 
1107 C2V_VMENTRY(void, reprofile, (JNIEnv* env, jobject, jobject jvmci_method))
1108   methodHandle method(THREAD, JVMCIENV-&gt;asMethod(jvmci_method));
1109   MethodCounters* mcs = method-&gt;method_counters();
1110   if (mcs != NULL) {
1111     mcs-&gt;clear_counters();
1112   }
1113   NOT_PRODUCT(method-&gt;set_compiled_invocation_count(0));
1114 
1115   CompiledMethod* code = method-&gt;code();
1116   if (code != NULL) {
1117     code-&gt;make_not_entrant();
1118   }
1119 
1120   MethodData* method_data = method-&gt;method_data();
1121   if (method_data == NULL) {
1122     ClassLoaderData* loader_data = method-&gt;method_holder()-&gt;class_loader_data();
1123     method_data = MethodData::allocate(loader_data, method, CHECK);
1124     method-&gt;set_method_data(method_data);
1125   } else {
1126     method_data-&gt;initialize();
1127   }
1128 C2V_END
1129 
1130 
1131 C2V_VMENTRY(void, invalidateHotSpotNmethod, (JNIEnv* env, jobject, jobject hs_nmethod))
1132   JVMCIObject nmethod_mirror = JVMCIENV-&gt;wrap(hs_nmethod);
1133   JVMCIENV-&gt;invalidate_nmethod_mirror(nmethod_mirror, JVMCI_CHECK);
1134 C2V_END
1135 
1136 C2V_VMENTRY_NULL(jobject, readUncompressedOop, (JNIEnv* env, jobject, jlong addr))
1137   oop ret = RawAccess&lt;&gt;::oop_load((oop*)(address)addr);
1138   return JVMCIENV-&gt;get_jobject(JVMCIENV-&gt;get_object_constant(ret));
1139  C2V_END
1140 
1141 C2V_VMENTRY_NULL(jlongArray, collectCounters, (JNIEnv* env, jobject))
1142   // Returns a zero length array if counters aren&#39;t enabled
1143   JVMCIPrimitiveArray array = JVMCIENV-&gt;new_longArray(JVMCICounterSize, JVMCI_CHECK_NULL);
1144   if (JVMCICounterSize &gt; 0) {
1145     jlong* temp_array = NEW_RESOURCE_ARRAY(jlong, JVMCICounterSize);
1146     JavaThread::collect_counters(temp_array, JVMCICounterSize);
1147     JVMCIENV-&gt;copy_longs_from(temp_array, array, 0, JVMCICounterSize);
1148   }
1149   return (jlongArray) JVMCIENV-&gt;get_jobject(array);
1150 C2V_END
1151 
1152 C2V_VMENTRY_0(jint, getCountersSize, (JNIEnv* env, jobject))
1153   return (jint) JVMCICounterSize;
1154 C2V_END
1155 
1156 C2V_VMENTRY(void, setCountersSize, (JNIEnv* env, jobject, jint new_size))
1157   JavaThread::resize_all_jvmci_counters(new_size);
1158 C2V_END
1159 
1160 C2V_VMENTRY_0(jint, allocateCompileId, (JNIEnv* env, jobject, jobject jvmci_method, int entry_bci))
1161   HandleMark hm;
1162   if (jvmci_method == NULL) {
1163     JVMCI_THROW_0(NullPointerException);
1164   }
1165   methodHandle method(THREAD, JVMCIENV-&gt;asMethod(jvmci_method));
1166   if (entry_bci &gt;= method-&gt;code_size() || entry_bci &lt; -1) {
1167     JVMCI_THROW_MSG_0(IllegalArgumentException, err_msg(&quot;Unexpected bci %d&quot;, entry_bci));
1168   }
1169   return CompileBroker::assign_compile_id_unlocked(THREAD, method, entry_bci);
1170 C2V_END
1171 
1172 
1173 C2V_VMENTRY_0(jboolean, isMature, (JNIEnv* env, jobject, jlong metaspace_method_data))
1174   MethodData* mdo = JVMCIENV-&gt;asMethodData(metaspace_method_data);
1175   return mdo != NULL &amp;&amp; mdo-&gt;is_mature();
1176 C2V_END
1177 
1178 C2V_VMENTRY_0(jboolean, hasCompiledCodeForOSR, (JNIEnv* env, jobject, jobject jvmci_method, int entry_bci, int comp_level))
1179   Method* method = JVMCIENV-&gt;asMethod(jvmci_method);
1180   return method-&gt;lookup_osr_nmethod_for(entry_bci, comp_level, true) != NULL;
1181 C2V_END
1182 
1183 C2V_VMENTRY_NULL(jobject, getSymbol, (JNIEnv* env, jobject, jlong symbol))
1184   JVMCIObject sym = JVMCIENV-&gt;create_string((Symbol*)(address)symbol, JVMCI_CHECK_NULL);
1185   return JVMCIENV-&gt;get_jobject(sym);
1186 C2V_END
1187 
1188 bool matches(jobjectArray methods, Method* method, JVMCIEnv* JVMCIENV) {
1189   objArrayOop methods_oop = (objArrayOop) JNIHandles::resolve(methods);
1190 
1191   for (int i = 0; i &lt; methods_oop-&gt;length(); i++) {
1192     oop resolved = methods_oop-&gt;obj_at(i);
1193     if ((resolved-&gt;klass() == HotSpotJVMCI::HotSpotResolvedJavaMethodImpl::klass()) &amp;&amp; HotSpotJVMCI::asMethod(JVMCIENV, resolved) == method) {
1194       return true;
1195     }
1196   }
1197   return false;
1198 }
1199 
1200 void call_interface(JavaValue* result, Klass* spec_klass, Symbol* name, Symbol* signature, JavaCallArguments* args, TRAPS) {
1201   CallInfo callinfo;
1202   Handle receiver = args-&gt;receiver();
1203   Klass* recvrKlass = receiver.is_null() ? (Klass*)NULL : receiver-&gt;klass();
1204   LinkInfo link_info(spec_klass, name, signature);
1205   LinkResolver::resolve_interface_call(
1206           callinfo, receiver, recvrKlass, link_info, true, CHECK);
1207   methodHandle method(THREAD, callinfo.selected_method());
1208   assert(method.not_null(), &quot;should have thrown exception&quot;);
1209 
1210   // Invoke the method
1211   JavaCalls::call(result, method, args, CHECK);
1212 }
1213 
1214 C2V_VMENTRY_NULL(jobject, iterateFrames, (JNIEnv* env, jobject compilerToVM, jobjectArray initial_methods, jobjectArray match_methods, jint initialSkip, jobject visitor_handle))
1215 
1216   if (!thread-&gt;has_last_Java_frame()) {
1217     return NULL;
1218   }
1219   Handle visitor(THREAD, JNIHandles::resolve_non_null(visitor_handle));
1220 
1221   requireInHotSpot(&quot;iterateFrames&quot;, JVMCI_CHECK_NULL);
1222 
1223   HotSpotJVMCI::HotSpotStackFrameReference::klass()-&gt;initialize(CHECK_NULL);
1224   Handle frame_reference = HotSpotJVMCI::HotSpotStackFrameReference::klass()-&gt;allocate_instance_handle(CHECK_NULL);
1225 
1226   StackFrameStream fst(thread);
1227   jobjectArray methods = initial_methods;
1228 
1229   int frame_number = 0;
1230   vframe* vf = vframe::new_vframe(fst.current(), fst.register_map(), thread);
1231 
1232   while (true) {
1233     // look for the given method
1234     bool realloc_called = false;
1235     while (true) {
1236       StackValueCollection* locals = NULL;
1237       if (vf-&gt;is_compiled_frame()) {
1238         // compiled method frame
1239         compiledVFrame* cvf = compiledVFrame::cast(vf);
1240         if (methods == NULL || matches(methods, cvf-&gt;method(), JVMCIENV)) {
1241           if (initialSkip &gt; 0) {
1242             initialSkip--;
1243           } else {
1244             ScopeDesc* scope = cvf-&gt;scope();
1245             // native wrappers do not have a scope
1246             if (scope != NULL &amp;&amp; scope-&gt;objects() != NULL) {
1247               GrowableArray&lt;ScopeValue*&gt;* objects;
1248               if (!realloc_called) {
1249                 objects = scope-&gt;objects();
1250               } else {
1251                 // some object might already have been re-allocated, only reallocate the non-allocated ones
1252                 objects = new GrowableArray&lt;ScopeValue*&gt;(scope-&gt;objects()-&gt;length());
1253                 for (int i = 0; i &lt; scope-&gt;objects()-&gt;length(); i++) {
1254                   ObjectValue* sv = (ObjectValue*) scope-&gt;objects()-&gt;at(i);
1255                   if (sv-&gt;value().is_null()) {
1256                     objects-&gt;append(sv);
1257                   }
1258                 }
1259               }
1260               bool realloc_failures = Deoptimization::realloc_objects(thread, fst.current(), fst.register_map(), objects, CHECK_NULL);
1261               Deoptimization::reassign_fields(fst.current(), fst.register_map(), objects, realloc_failures, false);
1262               realloc_called = true;
1263 
1264               GrowableArray&lt;ScopeValue*&gt;* local_values = scope-&gt;locals();
1265               assert(local_values != NULL, &quot;NULL locals&quot;);
1266               typeArrayOop array_oop = oopFactory::new_boolArray(local_values-&gt;length(), CHECK_NULL);
1267               typeArrayHandle array(THREAD, array_oop);
1268               for (int i = 0; i &lt; local_values-&gt;length(); i++) {
1269                 ScopeValue* value = local_values-&gt;at(i);
1270                 if (value-&gt;is_object()) {
1271                   array-&gt;bool_at_put(i, true);
1272                 }
1273               }
1274               HotSpotJVMCI::HotSpotStackFrameReference::set_localIsVirtual(JVMCIENV, frame_reference(), array());
1275             } else {
1276               HotSpotJVMCI::HotSpotStackFrameReference::set_localIsVirtual(JVMCIENV, frame_reference(), NULL);
1277             }
1278 
1279             locals = cvf-&gt;locals();
1280             HotSpotJVMCI::HotSpotStackFrameReference::set_bci(JVMCIENV, frame_reference(), cvf-&gt;bci());
1281             methodHandle mh(THREAD, cvf-&gt;method());
1282             JVMCIObject method = JVMCIENV-&gt;get_jvmci_method(mh, JVMCI_CHECK_NULL);
1283             HotSpotJVMCI::HotSpotStackFrameReference::set_method(JVMCIENV, frame_reference(), JNIHandles::resolve(method.as_jobject()));
1284           }
1285         }
1286       } else if (vf-&gt;is_interpreted_frame()) {
1287         // interpreted method frame
1288         interpretedVFrame* ivf = interpretedVFrame::cast(vf);
1289         if (methods == NULL || matches(methods, ivf-&gt;method(), JVMCIENV)) {
1290           if (initialSkip &gt; 0) {
1291             initialSkip--;
1292           } else {
1293             locals = ivf-&gt;locals();
1294             HotSpotJVMCI::HotSpotStackFrameReference::set_bci(JVMCIENV, frame_reference(), ivf-&gt;bci());
1295             methodHandle mh(THREAD, ivf-&gt;method());
1296             JVMCIObject method = JVMCIENV-&gt;get_jvmci_method(mh, JVMCI_CHECK_NULL);
1297             HotSpotJVMCI::HotSpotStackFrameReference::set_method(JVMCIENV, frame_reference(), JNIHandles::resolve(method.as_jobject()));
1298             HotSpotJVMCI::HotSpotStackFrameReference::set_localIsVirtual(JVMCIENV, frame_reference(), NULL);
1299           }
1300         }
1301       }
1302 
1303       // locals != NULL means that we found a matching frame and result is already partially initialized
1304       if (locals != NULL) {
1305         methods = match_methods;
1306         HotSpotJVMCI::HotSpotStackFrameReference::set_compilerToVM(JVMCIENV, frame_reference(), JNIHandles::resolve(compilerToVM));
1307         HotSpotJVMCI::HotSpotStackFrameReference::set_stackPointer(JVMCIENV, frame_reference(), (jlong) fst.current()-&gt;sp());
1308         HotSpotJVMCI::HotSpotStackFrameReference::set_frameNumber(JVMCIENV, frame_reference(), frame_number);
1309 
1310         // initialize the locals array
1311         objArrayOop array_oop = oopFactory::new_objectArray(locals-&gt;size(), CHECK_NULL);
1312         objArrayHandle array(THREAD, array_oop);
1313         for (int i = 0; i &lt; locals-&gt;size(); i++) {
1314           StackValue* var = locals-&gt;at(i);
1315           if (var-&gt;type() == T_OBJECT) {
1316             array-&gt;obj_at_put(i, locals-&gt;at(i)-&gt;get_obj()());
1317           }
1318         }
1319         HotSpotJVMCI::HotSpotStackFrameReference::set_locals(JVMCIENV, frame_reference(), array());
1320         HotSpotJVMCI::HotSpotStackFrameReference::set_objectsMaterialized(JVMCIENV, frame_reference(), JNI_FALSE);
1321 
1322         JavaValue result(T_OBJECT);
1323         JavaCallArguments args(visitor);
1324         args.push_oop(frame_reference);
1325         call_interface(&amp;result, HotSpotJVMCI::InspectedFrameVisitor::klass(), vmSymbols::visitFrame_name(), vmSymbols::visitFrame_signature(), &amp;args, CHECK_NULL);
1326         if (result.get_jobject() != NULL) {
1327           return JNIHandles::make_local(thread, (oop) result.get_jobject());
1328         }
1329         assert(initialSkip == 0, &quot;There should be no match before initialSkip == 0&quot;);
1330         if (HotSpotJVMCI::HotSpotStackFrameReference::objectsMaterialized(JVMCIENV, frame_reference()) == JNI_TRUE) {
1331           // the frame has been deoptimized, we need to re-synchronize the frame and vframe
1332           intptr_t* stack_pointer = (intptr_t*) HotSpotJVMCI::HotSpotStackFrameReference::stackPointer(JVMCIENV, frame_reference());
1333           fst = StackFrameStream(thread);
1334           while (fst.current()-&gt;sp() != stack_pointer &amp;&amp; !fst.is_done()) {
1335             fst.next();
1336           }
1337           if (fst.current()-&gt;sp() != stack_pointer) {
1338             THROW_MSG_NULL(vmSymbols::java_lang_IllegalStateException(), &quot;stack frame not found after deopt&quot;)
1339           }
1340           vf = vframe::new_vframe(fst.current(), fst.register_map(), thread);
1341           if (!vf-&gt;is_compiled_frame()) {
1342             THROW_MSG_NULL(vmSymbols::java_lang_IllegalStateException(), &quot;compiled stack frame expected&quot;)
1343           }
1344           for (int i = 0; i &lt; frame_number; i++) {
1345             if (vf-&gt;is_top()) {
1346               THROW_MSG_NULL(vmSymbols::java_lang_IllegalStateException(), &quot;vframe not found after deopt&quot;)
1347             }
1348             vf = vf-&gt;sender();
1349             assert(vf-&gt;is_compiled_frame(), &quot;Wrong frame type&quot;);
1350           }
1351         }
1352         frame_reference = HotSpotJVMCI::HotSpotStackFrameReference::klass()-&gt;allocate_instance_handle(CHECK_NULL);
1353         HotSpotJVMCI::HotSpotStackFrameReference::klass()-&gt;initialize(CHECK_NULL);
1354       }
1355 
1356       if (vf-&gt;is_top()) {
1357         break;
1358       }
1359       frame_number++;
1360       vf = vf-&gt;sender();
1361     } // end of vframe loop
1362 
1363     if (fst.is_done()) {
1364       break;
1365     }
1366     fst.next();
1367     vf = vframe::new_vframe(fst.current(), fst.register_map(), thread);
1368     frame_number = 0;
1369   } // end of frame loop
1370 
1371   // the end was reached without finding a matching method
1372   return NULL;
1373 C2V_END
1374 
1375 C2V_VMENTRY(void, resolveInvokeDynamicInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))
1376   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));
1377   CallInfo callInfo;
1378   LinkResolver::resolve_invoke(callInfo, Handle(), cp, index, Bytecodes::_invokedynamic, CHECK);
1379   ConstantPoolCacheEntry* cp_cache_entry = cp-&gt;invokedynamic_cp_cache_entry_at(index);
1380   cp_cache_entry-&gt;set_dynamic_call(cp, callInfo);
1381 C2V_END
1382 
1383 C2V_VMENTRY(void, resolveInvokeHandleInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))
1384   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));
1385   Klass* holder = cp-&gt;klass_ref_at(index, CHECK);
1386   Symbol* name = cp-&gt;name_ref_at(index);
1387   if (MethodHandles::is_signature_polymorphic_name(holder, name)) {
1388     CallInfo callInfo;
1389     LinkResolver::resolve_invoke(callInfo, Handle(), cp, index, Bytecodes::_invokehandle, CHECK);
1390     ConstantPoolCacheEntry* cp_cache_entry = cp-&gt;cache()-&gt;entry_at(cp-&gt;decode_cpcache_index(index));
1391     cp_cache_entry-&gt;set_method_handle(cp, callInfo);
1392   }
1393 C2V_END
1394 
1395 C2V_VMENTRY_0(jint, isResolvedInvokeHandleInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))
1396   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));
1397   ConstantPoolCacheEntry* cp_cache_entry = cp-&gt;cache()-&gt;entry_at(cp-&gt;decode_cpcache_index(index));
1398   if (cp_cache_entry-&gt;is_resolved(Bytecodes::_invokehandle)) {
1399     // MethodHandle.invoke* --&gt; LambdaForm?
1400     ResourceMark rm;
1401 
1402     LinkInfo link_info(cp, index, CATCH);
1403 
1404     Klass* resolved_klass = link_info.resolved_klass();
1405 
1406     Symbol* name_sym = cp-&gt;name_ref_at(index);
1407 
1408     vmassert(MethodHandles::is_method_handle_invoke_name(resolved_klass, name_sym), &quot;!&quot;);
1409     vmassert(MethodHandles::is_signature_polymorphic_name(resolved_klass, name_sym), &quot;!&quot;);
1410 
1411     methodHandle adapter_method(THREAD, cp_cache_entry-&gt;f1_as_method());
1412 
1413     methodHandle resolved_method(adapter_method);
1414 
1415     // Can we treat it as a regular invokevirtual?
1416     if (resolved_method-&gt;method_holder() == resolved_klass &amp;&amp; resolved_method-&gt;name() == name_sym) {
1417       vmassert(!resolved_method-&gt;is_static(),&quot;!&quot;);
1418       vmassert(MethodHandles::is_signature_polymorphic_method(resolved_method()),&quot;!&quot;);
1419       vmassert(!MethodHandles::is_signature_polymorphic_static(resolved_method-&gt;intrinsic_id()), &quot;!&quot;);
1420       vmassert(cp_cache_entry-&gt;appendix_if_resolved(cp) == NULL, &quot;!&quot;);
1421 
1422       methodHandle m(THREAD, LinkResolver::linktime_resolve_virtual_method_or_null(link_info));
1423       vmassert(m == resolved_method, &quot;!!&quot;);
1424       return -1;
1425     }
1426 
1427     return Bytecodes::_invokevirtual;
1428   }
1429   if (cp_cache_entry-&gt;is_resolved(Bytecodes::_invokedynamic)) {
1430     return Bytecodes::_invokedynamic;
1431   }
1432   return -1;
1433 C2V_END
1434 
1435 
1436 C2V_VMENTRY_NULL(jobject, getSignaturePolymorphicHolders, (JNIEnv* env, jobject))
1437   JVMCIObjectArray holders = JVMCIENV-&gt;new_String_array(2, JVMCI_CHECK_NULL);
1438   JVMCIObject mh = JVMCIENV-&gt;create_string(&quot;Ljava/lang/invoke/MethodHandle;&quot;, JVMCI_CHECK_NULL);
1439   JVMCIObject vh = JVMCIENV-&gt;create_string(&quot;Ljava/lang/invoke/VarHandle;&quot;, JVMCI_CHECK_NULL);
1440   JVMCIENV-&gt;put_object_at(holders, 0, mh);
1441   JVMCIENV-&gt;put_object_at(holders, 1, vh);
1442   return JVMCIENV-&gt;get_jobject(holders);
1443 C2V_END
1444 
1445 C2V_VMENTRY_0(jboolean, shouldDebugNonSafepoints, (JNIEnv* env, jobject))
1446   //see compute_recording_non_safepoints in debugInfroRec.cpp
1447   if (JvmtiExport::should_post_compiled_method_load() &amp;&amp; FLAG_IS_DEFAULT(DebugNonSafepoints)) {
1448     return true;
1449   }
1450   return DebugNonSafepoints;
1451 C2V_END
1452 
1453 // public native void materializeVirtualObjects(HotSpotStackFrameReference stackFrame, boolean invalidate);
1454 C2V_VMENTRY(void, materializeVirtualObjects, (JNIEnv* env, jobject, jobject _hs_frame, bool invalidate))
1455   JVMCIObject hs_frame = JVMCIENV-&gt;wrap(_hs_frame);
1456   if (hs_frame.is_null()) {
1457     JVMCI_THROW_MSG(NullPointerException, &quot;stack frame is null&quot;);
1458   }
1459 
1460   requireInHotSpot(&quot;materializeVirtualObjects&quot;, JVMCI_CHECK);
1461 
1462   JVMCIENV-&gt;HotSpotStackFrameReference_initialize(JVMCI_CHECK);
1463 
1464   // look for the given stack frame
1465   StackFrameStream fst(thread, false);
1466   intptr_t* stack_pointer = (intptr_t*) JVMCIENV-&gt;get_HotSpotStackFrameReference_stackPointer(hs_frame);
1467   while (fst.current()-&gt;sp() != stack_pointer &amp;&amp; !fst.is_done()) {
1468     fst.next();
1469   }
1470   if (fst.current()-&gt;sp() != stack_pointer) {
1471     JVMCI_THROW_MSG(IllegalStateException, &quot;stack frame not found&quot;);
1472   }
1473 
1474   if (invalidate) {
1475     if (!fst.current()-&gt;is_compiled_frame()) {
1476       JVMCI_THROW_MSG(IllegalStateException, &quot;compiled stack frame expected&quot;);
1477     }
1478     assert(fst.current()-&gt;cb()-&gt;is_nmethod(), &quot;nmethod expected&quot;);
1479     ((nmethod*) fst.current()-&gt;cb())-&gt;make_not_entrant();
1480   }
1481   Deoptimization::deoptimize(thread, *fst.current(), Deoptimization::Reason_none);
1482   // look for the frame again as it has been updated by deopt (pc, deopt state...)
1483   StackFrameStream fstAfterDeopt(thread);
1484   while (fstAfterDeopt.current()-&gt;sp() != stack_pointer &amp;&amp; !fstAfterDeopt.is_done()) {
1485     fstAfterDeopt.next();
1486   }
1487   if (fstAfterDeopt.current()-&gt;sp() != stack_pointer) {
1488     JVMCI_THROW_MSG(IllegalStateException, &quot;stack frame not found after deopt&quot;);
1489   }
1490 
1491   vframe* vf = vframe::new_vframe(fstAfterDeopt.current(), fstAfterDeopt.register_map(), thread);
1492   if (!vf-&gt;is_compiled_frame()) {
1493     JVMCI_THROW_MSG(IllegalStateException, &quot;compiled stack frame expected&quot;);
1494   }
1495 
1496   GrowableArray&lt;compiledVFrame*&gt;* virtualFrames = new GrowableArray&lt;compiledVFrame*&gt;(10);
1497   while (true) {
1498     assert(vf-&gt;is_compiled_frame(), &quot;Wrong frame type&quot;);
1499     virtualFrames-&gt;push(compiledVFrame::cast(vf));
1500     if (vf-&gt;is_top()) {
1501       break;
1502     }
1503     vf = vf-&gt;sender();
1504   }
1505 
1506   int last_frame_number = JVMCIENV-&gt;get_HotSpotStackFrameReference_frameNumber(hs_frame);
1507   if (last_frame_number &gt;= virtualFrames-&gt;length()) {
1508     JVMCI_THROW_MSG(IllegalStateException, &quot;invalid frame number&quot;);
1509   }
1510 
1511   // Reallocate the non-escaping objects and restore their fields.
1512   assert (virtualFrames-&gt;at(last_frame_number)-&gt;scope() != NULL,&quot;invalid scope&quot;);
1513   GrowableArray&lt;ScopeValue*&gt;* objects = virtualFrames-&gt;at(last_frame_number)-&gt;scope()-&gt;objects();
1514 
1515   if (objects == NULL) {
1516     // no objects to materialize
1517     return;
1518   }
1519 
1520   bool realloc_failures = Deoptimization::realloc_objects(thread, fstAfterDeopt.current(), fstAfterDeopt.register_map(), objects, CHECK);
1521   Deoptimization::reassign_fields(fstAfterDeopt.current(), fstAfterDeopt.register_map(), objects, realloc_failures, false);
1522 
1523   for (int frame_index = 0; frame_index &lt; virtualFrames-&gt;length(); frame_index++) {
1524     compiledVFrame* cvf = virtualFrames-&gt;at(frame_index);
1525 
1526     GrowableArray&lt;ScopeValue*&gt;* scopeLocals = cvf-&gt;scope()-&gt;locals();
1527     StackValueCollection* locals = cvf-&gt;locals();
1528     if (locals != NULL) {
1529       for (int i2 = 0; i2 &lt; locals-&gt;size(); i2++) {
1530         StackValue* var = locals-&gt;at(i2);
1531         if (var-&gt;type() == T_OBJECT &amp;&amp; scopeLocals-&gt;at(i2)-&gt;is_object()) {
1532           jvalue val;
1533           val.l = cast_from_oop&lt;jobject&gt;(locals-&gt;at(i2)-&gt;get_obj()());
1534           cvf-&gt;update_local(T_OBJECT, i2, val);
1535         }
1536       }
1537     }
1538 
1539     GrowableArray&lt;ScopeValue*&gt;* scopeExpressions = cvf-&gt;scope()-&gt;expressions();
1540     StackValueCollection* expressions = cvf-&gt;expressions();
1541     if (expressions != NULL) {
1542       for (int i2 = 0; i2 &lt; expressions-&gt;size(); i2++) {
1543         StackValue* var = expressions-&gt;at(i2);
1544         if (var-&gt;type() == T_OBJECT &amp;&amp; scopeExpressions-&gt;at(i2)-&gt;is_object()) {
1545           jvalue val;
1546           val.l = cast_from_oop&lt;jobject&gt;(expressions-&gt;at(i2)-&gt;get_obj()());
1547           cvf-&gt;update_stack(T_OBJECT, i2, val);
1548         }
1549       }
1550     }
1551 
1552     GrowableArray&lt;MonitorValue*&gt;* scopeMonitors = cvf-&gt;scope()-&gt;monitors();
1553     GrowableArray&lt;MonitorInfo*&gt;* monitors = cvf-&gt;monitors();
1554     if (monitors != NULL) {
1555       for (int i2 = 0; i2 &lt; monitors-&gt;length(); i2++) {
1556         cvf-&gt;update_monitor(i2, monitors-&gt;at(i2));
1557       }
1558     }
1559   }
1560 
1561   // all locals are materialized by now
1562   JVMCIENV-&gt;set_HotSpotStackFrameReference_localIsVirtual(hs_frame, NULL);
1563   // update the locals array
1564   JVMCIObjectArray array = JVMCIENV-&gt;get_HotSpotStackFrameReference_locals(hs_frame);
1565   StackValueCollection* locals = virtualFrames-&gt;at(last_frame_number)-&gt;locals();
1566   for (int i = 0; i &lt; locals-&gt;size(); i++) {
1567     StackValue* var = locals-&gt;at(i);
1568     if (var-&gt;type() == T_OBJECT) {
1569       JVMCIENV-&gt;put_object_at(array, i, HotSpotJVMCI::wrap(locals-&gt;at(i)-&gt;get_obj()()));
1570     }
1571   }
1572   HotSpotJVMCI::HotSpotStackFrameReference::set_objectsMaterialized(JVMCIENV, hs_frame, JNI_TRUE);
1573 C2V_END
1574 
1575 // Creates a scope where the current thread is attached and detached
1576 // from HotSpot if it wasn&#39;t already attached when entering the scope.
1577 extern &quot;C&quot; void jio_printf(const char *fmt, ...);
1578 class AttachDetach : public StackObj {
1579  public:
1580   bool _attached;
1581   AttachDetach(JNIEnv* env, Thread* current_thread) {
1582     if (current_thread == NULL) {
1583       extern struct JavaVM_ main_vm;
1584       JNIEnv* hotspotEnv;
1585       jint res = main_vm.AttachCurrentThread((void**)&amp;hotspotEnv, NULL);
1586       _attached = res == JNI_OK;
1587       static volatile int report_attach_error = 0;
1588       if (res != JNI_OK &amp;&amp; report_attach_error == 0 &amp;&amp; Atomic::cmpxchg(&amp;report_attach_error, 0, 1) == 0) {
1589         // Only report an attach error once
1590         jio_printf(&quot;Warning: attaching current thread to VM failed with %d (future attach errors are suppressed)\n&quot;, res);
1591       }
1592     } else {
1593       _attached = false;
1594     }
1595   }
1596   ~AttachDetach() {
1597     if (_attached &amp;&amp; get_current_thread() != NULL) {
1598       extern struct JavaVM_ main_vm;
1599       jint res = main_vm.DetachCurrentThread();
1600       static volatile int report_detach_error = 0;
1601       if (res != JNI_OK &amp;&amp; report_detach_error == 0 &amp;&amp; Atomic::cmpxchg(&amp;report_detach_error, 0, 1) == 0) {
1602         // Only report an attach error once
1603         jio_printf(&quot;Warning: detaching current thread from VM failed with %d (future attach errors are suppressed)\n&quot;, res);
1604       }
1605     }
1606   }
1607 };
1608 
1609 C2V_VMENTRY_PREFIX(jint, writeDebugOutput, (JNIEnv* env, jobject, jbyteArray bytes, jint offset, jint length, bool flush, bool can_throw))
1610   AttachDetach ad(env, base_thread);
1611   bool use_tty = true;
1612   if (base_thread == NULL) {
1613     if (!ad._attached) {
1614       // Can only use tty if the current thread is attached
1615       return 0;
1616     }
1617     base_thread = get_current_thread();
1618   }
1619   JVMCITraceMark jtm(&quot;writeDebugOutput&quot;);
1620   assert(base_thread-&gt;is_Java_thread(), &quot;just checking&quot;);
1621   JavaThread* thread = (JavaThread*) base_thread;
1622   C2V_BLOCK(void, writeDebugOutput, (JNIEnv* env, jobject, jbyteArray bytes, jint offset, jint length))
1623   if (bytes == NULL) {
1624     if (can_throw) {
1625       JVMCI_THROW_0(NullPointerException);
1626     }
1627     return -1;
1628   }
1629   JVMCIPrimitiveArray array = JVMCIENV-&gt;wrap(bytes);
1630 
1631   // Check if offset and length are non negative.
1632   if (offset &lt; 0 || length &lt; 0) {
1633     if (can_throw) {
1634       JVMCI_THROW_0(ArrayIndexOutOfBoundsException);
1635     }
1636     return -2;
1637   }
1638   // Check if the range is valid.
1639   int array_length = JVMCIENV-&gt;get_length(array);
1640   if ((((unsigned int) length + (unsigned int) offset) &gt; (unsigned int) array_length)) {
1641     if (can_throw) {
1642       JVMCI_THROW_0(ArrayIndexOutOfBoundsException);
1643     }
1644     return -2;
1645   }
1646   jbyte buffer[O_BUFLEN];
1647   while (length &gt; 0) {
1648     int copy_len = MIN2(length, (jint)O_BUFLEN);
1649     JVMCIENV-&gt;copy_bytes_to(array, buffer, offset, copy_len);
1650     tty-&gt;write((char*) buffer, copy_len);
1651     length -= O_BUFLEN;
1652     offset += O_BUFLEN;
1653   }
1654   if (flush) {
1655     tty-&gt;flush();
1656   }
1657   return 0;
1658 C2V_END
1659 
1660 C2V_VMENTRY(void, flushDebugOutput, (JNIEnv* env, jobject))
1661   tty-&gt;flush();
1662 C2V_END
1663 
1664 C2V_VMENTRY_0(jint, methodDataProfileDataSize, (JNIEnv* env, jobject, jlong metaspace_method_data, jint position))
1665   MethodData* mdo = JVMCIENV-&gt;asMethodData(metaspace_method_data);
1666   ProfileData* profile_data = mdo-&gt;data_at(position);
1667   if (mdo-&gt;is_valid(profile_data)) {
1668     return profile_data-&gt;size_in_bytes();
1669   }
1670   DataLayout* data    = mdo-&gt;extra_data_base();
1671   DataLayout* end   = mdo-&gt;extra_data_limit();
1672   for (;; data = mdo-&gt;next_extra(data)) {
1673     assert(data &lt; end, &quot;moved past end of extra data&quot;);
1674     profile_data = data-&gt;data_in();
1675     if (mdo-&gt;dp_to_di(profile_data-&gt;dp()) == position) {
1676       return profile_data-&gt;size_in_bytes();
1677     }
1678   }
1679   JVMCI_THROW_MSG_0(IllegalArgumentException, err_msg(&quot;Invalid profile data position %d&quot;, position));
1680 C2V_END
1681 
1682 C2V_VMENTRY_0(jlong, getFingerprint, (JNIEnv* env, jobject, jlong metaspace_klass))
1683 #if INCLUDE_AOT
1684   Klass *k = (Klass*) (address) metaspace_klass;
1685   if (k-&gt;is_instance_klass()) {
1686     return InstanceKlass::cast(k)-&gt;get_stored_fingerprint();
1687   } else {
1688     return 0;
1689   }
1690 #else
1691   JVMCI_THROW_MSG_0(InternalError, &quot;unimplemented&quot;);
1692 #endif
1693 C2V_END
1694 
1695 C2V_VMENTRY_NULL(jobject, getHostClass, (JNIEnv* env, jobject, jobject jvmci_type))
1696   InstanceKlass* k = InstanceKlass::cast(JVMCIENV-&gt;asKlass(jvmci_type));
1697   InstanceKlass* host = k-&gt;unsafe_anonymous_host();
1698   JVMCIKlassHandle handle(THREAD, host);
1699   JVMCIObject result = JVMCIENV-&gt;get_jvmci_type(handle, JVMCI_CHECK_NULL);
1700   return JVMCIENV-&gt;get_jobject(result);
1701 C2V_END
1702 
1703 C2V_VMENTRY_NULL(jobject, getInterfaces, (JNIEnv* env, jobject, jobject jvmci_type))
1704   if (jvmci_type == NULL) {
1705     JVMCI_THROW_0(NullPointerException);
1706   }
1707 
1708   Klass* klass = JVMCIENV-&gt;asKlass(jvmci_type);
1709   if (klass == NULL) {
1710     JVMCI_THROW_0(NullPointerException);
1711   }
1712   if (!klass-&gt;is_instance_klass()) {
1713     JVMCI_THROW_MSG_0(InternalError, err_msg(&quot;Class %s must be instance klass&quot;, klass-&gt;external_name()));
1714   }
1715   InstanceKlass* iklass = InstanceKlass::cast(klass);
1716 
1717   // Regular instance klass, fill in all local interfaces
1718   int size = iklass-&gt;local_interfaces()-&gt;length();
1719   JVMCIObjectArray interfaces = JVMCIENV-&gt;new_HotSpotResolvedObjectTypeImpl_array(size, JVMCI_CHECK_NULL);
1720   for (int index = 0; index &lt; size; index++) {
1721     JVMCIKlassHandle klass(THREAD);
1722     Klass* k = iklass-&gt;local_interfaces()-&gt;at(index);
1723     klass = k;
1724     JVMCIObject type = JVMCIENV-&gt;get_jvmci_type(klass, JVMCI_CHECK_NULL);
1725     JVMCIENV-&gt;put_object_at(interfaces, index, type);
1726   }
1727   return JVMCIENV-&gt;get_jobject(interfaces);
1728 C2V_END
1729 
1730 C2V_VMENTRY_NULL(jobject, getComponentType, (JNIEnv* env, jobject, jobject jvmci_type))
1731   if (jvmci_type == NULL) {
1732     JVMCI_THROW_0(NullPointerException);
1733   }
1734 
1735   Klass* klass = JVMCIENV-&gt;asKlass(jvmci_type);
1736   oop mirror = klass-&gt;java_mirror();
1737   if (java_lang_Class::is_primitive(mirror) ||
1738       !java_lang_Class::as_Klass(mirror)-&gt;is_array_klass()) {
1739     return NULL;
1740   }
1741 
1742   oop component_mirror = java_lang_Class::component_mirror(mirror);
1743   if (component_mirror == NULL) {
1744     return NULL;
1745   }
1746   Klass* component_klass = java_lang_Class::as_Klass(component_mirror);
1747   if (component_klass != NULL) {
1748     JVMCIKlassHandle klass_handle(THREAD);
1749     klass_handle = component_klass;
1750     JVMCIObject result = JVMCIENV-&gt;get_jvmci_type(klass_handle, JVMCI_CHECK_NULL);
1751     return JVMCIENV-&gt;get_jobject(result);
1752   }
1753   BasicType type = java_lang_Class::primitive_type(component_mirror);
1754   JVMCIObject result = JVMCIENV-&gt;get_jvmci_primitive_type(type);
1755   return JVMCIENV-&gt;get_jobject(result);
1756 C2V_END
1757 
1758 C2V_VMENTRY(void, ensureInitialized, (JNIEnv* env, jobject, jobject jvmci_type))
1759   if (jvmci_type == NULL) {
1760     JVMCI_THROW(NullPointerException);
1761   }
1762 
1763   Klass* klass = JVMCIENV-&gt;asKlass(jvmci_type);
1764   if (klass != NULL &amp;&amp; klass-&gt;should_be_initialized()) {
1765     InstanceKlass* k = InstanceKlass::cast(klass);
1766     k-&gt;initialize(CHECK);
1767   }
1768 C2V_END
1769 
1770 C2V_VMENTRY_0(jint, interpreterFrameSize, (JNIEnv* env, jobject, jobject bytecode_frame_handle))
1771   if (bytecode_frame_handle == NULL) {
1772     JVMCI_THROW_0(NullPointerException);
1773   }
1774 
1775   JVMCIObject top_bytecode_frame = JVMCIENV-&gt;wrap(bytecode_frame_handle);
1776   JVMCIObject bytecode_frame = top_bytecode_frame;
1777   int size = 0;
1778   int callee_parameters = 0;
1779   int callee_locals = 0;
1780   Method* method = JVMCIENV-&gt;asMethod(JVMCIENV-&gt;get_BytecodePosition_method(bytecode_frame));
1781   int extra_args = method-&gt;max_stack() - JVMCIENV-&gt;get_BytecodeFrame_numStack(bytecode_frame);
1782 
1783   while (bytecode_frame.is_non_null()) {
1784     int locks = JVMCIENV-&gt;get_BytecodeFrame_numLocks(bytecode_frame);
1785     int temps = JVMCIENV-&gt;get_BytecodeFrame_numStack(bytecode_frame);
1786     bool is_top_frame = (JVMCIENV-&gt;equals(bytecode_frame, top_bytecode_frame));
1787     Method* method = JVMCIENV-&gt;asMethod(JVMCIENV-&gt;get_BytecodePosition_method(bytecode_frame));
1788 
1789     int frame_size = BytesPerWord * Interpreter::size_activation(method-&gt;max_stack(),
1790                                                                  temps + callee_parameters,
1791                                                                  extra_args,
1792                                                                  locks,
1793                                                                  callee_parameters,
1794                                                                  callee_locals,
1795                                                                  is_top_frame);
1796     size += frame_size;
1797 
1798     callee_parameters = method-&gt;size_of_parameters();
1799     callee_locals = method-&gt;max_locals();
1800     extra_args = 0;
1801     bytecode_frame = JVMCIENV-&gt;get_BytecodePosition_caller(bytecode_frame);
1802   }
1803   return size + Deoptimization::last_frame_adjust(0, callee_locals) * BytesPerWord;
1804 C2V_END
1805 
1806 C2V_VMENTRY(void, compileToBytecode, (JNIEnv* env, jobject, jobject lambda_form_handle))
1807   Handle lambda_form = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(lambda_form_handle), JVMCI_CHECK);
1808   if (lambda_form-&gt;is_a(SystemDictionary::LambdaForm_klass())) {
1809     TempNewSymbol compileToBytecode = SymbolTable::new_symbol(&quot;compileToBytecode&quot;);
1810     JavaValue result(T_VOID);
1811     JavaCalls::call_special(&amp;result, lambda_form, SystemDictionary::LambdaForm_klass(), compileToBytecode, vmSymbols::void_method_signature(), CHECK);
1812   } else {
1813     JVMCI_THROW_MSG(IllegalArgumentException,
1814                     err_msg(&quot;Unexpected type: %s&quot;, lambda_form-&gt;klass()-&gt;external_name()))
1815   }
1816 C2V_END
1817 
1818 C2V_VMENTRY_0(jint, getIdentityHashCode, (JNIEnv* env, jobject, jobject object))
1819   Handle obj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(object), JVMCI_CHECK_0);
1820   return obj-&gt;identity_hash();
1821 C2V_END
1822 
1823 C2V_VMENTRY_0(jboolean, isInternedString, (JNIEnv* env, jobject, jobject object))
1824   Handle str = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(object), JVMCI_CHECK_0);
1825   if (!java_lang_String::is_instance(str())) {
1826     return false;
1827   }
1828   int len;
1829   jchar* name = java_lang_String::as_unicode_string(str(), len, CHECK_false);
1830   return (StringTable::lookup(name, len) != NULL);
1831 C2V_END
1832 
1833 
1834 C2V_VMENTRY_NULL(jobject, unboxPrimitive, (JNIEnv* env, jobject, jobject object))
1835   if (object == NULL) {
1836     JVMCI_THROW_0(NullPointerException);
1837   }
1838   Handle box = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(object), JVMCI_CHECK_NULL);
1839   BasicType type = java_lang_boxing_object::basic_type(box());
1840   jvalue result;
1841   if (java_lang_boxing_object::get_value(box(), &amp;result) == T_ILLEGAL) {
1842     return NULL;
1843   }
1844   JVMCIObject boxResult = JVMCIENV-&gt;create_box(type, &amp;result, JVMCI_CHECK_NULL);
1845   return JVMCIENV-&gt;get_jobject(boxResult);
1846 C2V_END
1847 
1848 C2V_VMENTRY_NULL(jobject, boxPrimitive, (JNIEnv* env, jobject, jobject object))
1849   if (object == NULL) {
1850     JVMCI_THROW_0(NullPointerException);
1851   }
1852   JVMCIObject box = JVMCIENV-&gt;wrap(object);
1853   BasicType type = JVMCIENV-&gt;get_box_type(box);
1854   if (type == T_ILLEGAL) {
1855     return NULL;
1856   }
1857   jvalue value = JVMCIENV-&gt;get_boxed_value(type, box);
1858   JavaValue box_result(T_OBJECT);
1859   JavaCallArguments jargs;
1860   Klass* box_klass = NULL;
1861   Symbol* box_signature = NULL;
1862 #define BOX_CASE(bt, v, argtype, name)           \
1863   case bt: \
1864     jargs.push_##argtype(value.v); \
1865     box_klass = SystemDictionary::name##_klass(); \
1866     box_signature = vmSymbols::name##_valueOf_signature(); \
1867     break
1868 
1869   switch (type) {
1870     BOX_CASE(T_BOOLEAN, z, int, Boolean);
1871     BOX_CASE(T_BYTE, b, int, Byte);
1872     BOX_CASE(T_CHAR, c, int, Character);
1873     BOX_CASE(T_SHORT, s, int, Short);
1874     BOX_CASE(T_INT, i, int, Integer);
1875     BOX_CASE(T_LONG, j, long, Long);
1876     BOX_CASE(T_FLOAT, f, float, Float);
1877     BOX_CASE(T_DOUBLE, d, double, Double);
1878     default:
1879       ShouldNotReachHere();
1880   }
1881 #undef BOX_CASE
1882 
1883   JavaCalls::call_static(&amp;box_result,
1884                          box_klass,
1885                          vmSymbols::valueOf_name(),
1886                          box_signature, &amp;jargs, CHECK_NULL);
1887   oop hotspot_box = (oop) box_result.get_jobject();
1888   JVMCIObject result = JVMCIENV-&gt;get_object_constant(hotspot_box, false);
1889   return JVMCIENV-&gt;get_jobject(result);
1890 C2V_END
1891 
1892 C2V_VMENTRY_NULL(jobjectArray, getDeclaredConstructors, (JNIEnv* env, jobject, jobject holder))
1893   if (holder == NULL) {
1894     JVMCI_THROW_0(NullPointerException);
1895   }
1896   Klass* klass = JVMCIENV-&gt;asKlass(holder);
1897   if (!klass-&gt;is_instance_klass()) {
1898     JVMCIObjectArray methods = JVMCIENV-&gt;new_ResolvedJavaMethod_array(0, JVMCI_CHECK_NULL);
1899     return JVMCIENV-&gt;get_jobjectArray(methods);
1900   }
1901 
1902   InstanceKlass* iklass = InstanceKlass::cast(klass);
1903   // Ensure class is linked
1904   iklass-&gt;link_class(CHECK_NULL);
1905 
1906   GrowableArray&lt;Method*&gt; constructors_array;
1907   for (int i = 0; i &lt; iklass-&gt;methods()-&gt;length(); i++) {
1908     Method* m = iklass-&gt;methods()-&gt;at(i);
1909     if (m-&gt;is_initializer() &amp;&amp; !m-&gt;is_static()) {
1910       constructors_array.append(m);
1911     }
1912   }
1913   JVMCIObjectArray methods = JVMCIENV-&gt;new_ResolvedJavaMethod_array(constructors_array.length(), JVMCI_CHECK_NULL);
1914   for (int i = 0; i &lt; constructors_array.length(); i++) {
1915     methodHandle ctor(THREAD, constructors_array.at(i));
1916     JVMCIObject method = JVMCIENV-&gt;get_jvmci_method(ctor, JVMCI_CHECK_NULL);
1917     JVMCIENV-&gt;put_object_at(methods, i, method);
1918   }
1919   return JVMCIENV-&gt;get_jobjectArray(methods);
1920 C2V_END
1921 
1922 C2V_VMENTRY_NULL(jobjectArray, getDeclaredMethods, (JNIEnv* env, jobject, jobject holder))
1923   if (holder == NULL) {
1924     JVMCI_THROW_0(NullPointerException);
1925   }
1926   Klass* klass = JVMCIENV-&gt;asKlass(holder);
1927   if (!klass-&gt;is_instance_klass()) {
1928     JVMCIObjectArray methods = JVMCIENV-&gt;new_ResolvedJavaMethod_array(0, JVMCI_CHECK_NULL);
1929     return JVMCIENV-&gt;get_jobjectArray(methods);
1930   }
1931 
1932   InstanceKlass* iklass = InstanceKlass::cast(klass);
1933   // Ensure class is linked
1934   iklass-&gt;link_class(CHECK_NULL);
1935 
1936   GrowableArray&lt;Method*&gt; methods_array;
1937   for (int i = 0; i &lt; iklass-&gt;methods()-&gt;length(); i++) {
1938     Method* m = iklass-&gt;methods()-&gt;at(i);
1939     if (!m-&gt;is_initializer() &amp;&amp; !m-&gt;is_overpass()) {
1940       methods_array.append(m);
1941     }
1942   }
1943   JVMCIObjectArray methods = JVMCIENV-&gt;new_ResolvedJavaMethod_array(methods_array.length(), JVMCI_CHECK_NULL);
1944   for (int i = 0; i &lt; methods_array.length(); i++) {
1945     methodHandle mh(THREAD, methods_array.at(i));
1946     JVMCIObject method = JVMCIENV-&gt;get_jvmci_method(mh, JVMCI_CHECK_NULL);
1947     JVMCIENV-&gt;put_object_at(methods, i, method);
1948   }
1949   return JVMCIENV-&gt;get_jobjectArray(methods);
1950 C2V_END
1951 
1952 C2V_VMENTRY_NULL(jobject, readFieldValue, (JNIEnv* env, jobject, jobject object, jobject field, jboolean is_volatile))
1953   if (object == NULL || field == NULL) {
1954     JVMCI_THROW_0(NullPointerException);
1955   }
1956   JVMCIObject field_object = JVMCIENV-&gt;wrap(field);
1957   JVMCIObject java_type = JVMCIENV-&gt;get_HotSpotResolvedJavaFieldImpl_type(field_object);
1958   int modifiers = JVMCIENV-&gt;get_HotSpotResolvedJavaFieldImpl_modifiers(field_object);
1959   Klass* holder = JVMCIENV-&gt;asKlass(JVMCIENV-&gt;get_HotSpotResolvedJavaFieldImpl_holder(field_object));
1960   if (!holder-&gt;is_instance_klass()) {
1961     JVMCI_THROW_MSG_0(InternalError, err_msg(&quot;Holder %s must be instance klass&quot;, holder-&gt;external_name()));
1962   }
1963   InstanceKlass* ik = InstanceKlass::cast(holder);
1964   BasicType constant_type;
1965   if (JVMCIENV-&gt;isa_HotSpotResolvedPrimitiveType(java_type)) {
1966     constant_type = JVMCIENV-&gt;kindToBasicType(JVMCIENV-&gt;get_HotSpotResolvedPrimitiveType_kind(java_type), JVMCI_CHECK_NULL);
1967   } else {
1968     constant_type = T_OBJECT;
1969   }
1970   int displacement = JVMCIENV-&gt;get_HotSpotResolvedJavaFieldImpl_offset(field_object);
1971   fieldDescriptor fd;
1972   if (!ik-&gt;find_local_field_from_offset(displacement, (modifiers &amp; JVM_ACC_STATIC) != 0, &amp;fd)) {
1973     JVMCI_THROW_MSG_0(InternalError, err_msg(&quot;Can&#39;t find field with displacement %d&quot;, displacement));
1974   }
1975   JVMCIObject base = JVMCIENV-&gt;wrap(object);
1976   Handle obj;
1977   if (JVMCIENV-&gt;isa_HotSpotObjectConstantImpl(base)) {
1978     obj = JVMCIENV-&gt;asConstant(base, JVMCI_CHECK_NULL);
1979   } else if (JVMCIENV-&gt;isa_HotSpotResolvedObjectTypeImpl(base)) {
1980     Klass* klass = JVMCIENV-&gt;asKlass(base);
1981     obj = Handle(THREAD, klass-&gt;java_mirror());
1982   } else {
1983     JVMCI_THROW_MSG_NULL(IllegalArgumentException,
1984                          err_msg(&quot;Unexpected type: %s&quot;, JVMCIENV-&gt;klass_name(base)));
1985   }
1986   jlong value = 0;
1987   JVMCIObject kind;
1988   switch (constant_type) {
1989     case T_OBJECT: {
1990       oop object = is_volatile ? obj-&gt;obj_field_acquire(displacement) : obj-&gt;obj_field(displacement);
1991       JVMCIObject result = JVMCIENV-&gt;get_object_constant(object);
1992       if (result.is_null()) {
1993         return JVMCIENV-&gt;get_jobject(JVMCIENV-&gt;get_JavaConstant_NULL_POINTER());
1994       }
1995       return JVMCIENV-&gt;get_jobject(result);
1996     }
1997     case T_FLOAT: {
1998       float f = is_volatile ? obj-&gt;float_field_acquire(displacement) : obj-&gt;float_field(displacement);
1999       JVMCIObject result = JVMCIENV-&gt;call_JavaConstant_forFloat(f, JVMCI_CHECK_NULL);
2000       return JVMCIENV-&gt;get_jobject(result);
2001     }
2002     case T_DOUBLE: {
2003       double f = is_volatile ? obj-&gt;double_field_acquire(displacement) : obj-&gt;double_field(displacement);
2004       JVMCIObject result = JVMCIENV-&gt;call_JavaConstant_forDouble(f, JVMCI_CHECK_NULL);
2005       return JVMCIENV-&gt;get_jobject(result);
2006     }
2007     case T_BOOLEAN: value = is_volatile ? obj-&gt;bool_field_acquire(displacement) : obj-&gt;bool_field(displacement); break;
2008     case T_BYTE: value = is_volatile ? obj-&gt;byte_field_acquire(displacement) : obj-&gt;byte_field(displacement); break;
2009     case T_SHORT: value = is_volatile ? obj-&gt;short_field_acquire(displacement) : obj-&gt;short_field(displacement); break;
2010     case T_CHAR: value = is_volatile ? obj-&gt;char_field_acquire(displacement) : obj-&gt;char_field(displacement); break;
2011     case T_INT: value = is_volatile ? obj-&gt;int_field_acquire(displacement) : obj-&gt;int_field(displacement); break;
2012     case T_LONG: value = is_volatile ? obj-&gt;long_field_acquire(displacement) : obj-&gt;long_field(displacement); break;
2013     default:
2014       ShouldNotReachHere();
2015   }
2016   JVMCIObject result = JVMCIENV-&gt;call_PrimitiveConstant_forTypeChar(type2char(constant_type), value, JVMCI_CHECK_NULL);
2017   return JVMCIENV-&gt;get_jobject(result);
2018 C2V_END
2019 
2020 C2V_VMENTRY_0(jboolean, isInstance, (JNIEnv* env, jobject, jobject holder, jobject object))
2021   if (object == NULL || holder == NULL) {
2022     JVMCI_THROW_0(NullPointerException);
2023   }
2024   Handle obj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(object), JVMCI_CHECK_0);
2025   Klass* klass = JVMCIENV-&gt;asKlass(JVMCIENV-&gt;wrap(holder));
2026   return obj-&gt;is_a(klass);
2027 C2V_END
2028 
2029 C2V_VMENTRY_0(jboolean, isAssignableFrom, (JNIEnv* env, jobject, jobject holder, jobject otherHolder))
2030   if (holder == NULL || otherHolder == NULL) {
2031     JVMCI_THROW_0(NullPointerException);
2032   }
2033   Klass* klass = JVMCIENV-&gt;asKlass(JVMCIENV-&gt;wrap(holder));
2034   Klass* otherKlass = JVMCIENV-&gt;asKlass(JVMCIENV-&gt;wrap(otherHolder));
2035   return otherKlass-&gt;is_subtype_of(klass);
2036 C2V_END
2037 
2038 C2V_VMENTRY_0(jboolean, isTrustedForIntrinsics, (JNIEnv* env, jobject, jobject holder))
2039   if (holder == NULL) {
2040     JVMCI_THROW_0(NullPointerException);
2041   }
2042   InstanceKlass* ik = InstanceKlass::cast(JVMCIENV-&gt;asKlass(JVMCIENV-&gt;wrap(holder)));
2043   if (ik-&gt;class_loader_data()-&gt;is_boot_class_loader_data() || ik-&gt;class_loader_data()-&gt;is_platform_class_loader_data()) {
2044     return true;
2045   }
2046   return false;
2047 C2V_END
2048 
2049 C2V_VMENTRY_NULL(jobject, asJavaType, (JNIEnv* env, jobject, jobject object))
2050   if (object == NULL) {
2051     JVMCI_THROW_0(NullPointerException);
2052   }
2053   Handle obj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(object), JVMCI_CHECK_NULL);
2054   if (java_lang_Class::is_instance(obj())) {
2055     if (java_lang_Class::is_primitive(obj())) {
2056       JVMCIObject type = JVMCIENV-&gt;get_jvmci_primitive_type(java_lang_Class::primitive_type(obj()));
2057       return JVMCIENV-&gt;get_jobject(type);
2058     }
2059     Klass* klass = java_lang_Class::as_Klass(obj());
2060     JVMCIKlassHandle klass_handle(THREAD);
2061     klass_handle = klass;
2062     JVMCIObject type = JVMCIENV-&gt;get_jvmci_type(klass_handle, JVMCI_CHECK_NULL);
2063     return JVMCIENV-&gt;get_jobject(type);
2064   }
2065   return NULL;
2066 C2V_END
2067 
2068 
2069 C2V_VMENTRY_NULL(jobject, asString, (JNIEnv* env, jobject, jobject object))
2070   if (object == NULL) {
2071     JVMCI_THROW_0(NullPointerException);
2072   }
2073   Handle obj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(object), JVMCI_CHECK_NULL);
2074   const char* str = java_lang_String::as_utf8_string(obj());
2075   JVMCIObject result = JVMCIENV-&gt;create_string(str, JVMCI_CHECK_NULL);
2076   return JVMCIENV-&gt;get_jobject(result);
2077 C2V_END
2078 
2079 
2080 C2V_VMENTRY_0(jboolean, equals, (JNIEnv* env, jobject, jobject x, jlong xHandle, jobject y, jlong yHandle))
2081   if (x == NULL || y == NULL) {
2082     JVMCI_THROW_0(NullPointerException);
2083   }
2084   return JVMCIENV-&gt;resolve_handle(xHandle) == JVMCIENV-&gt;resolve_handle(yHandle);
2085 C2V_END
2086 
2087 C2V_VMENTRY_NULL(jobject, getJavaMirror, (JNIEnv* env, jobject, jobject object))
2088   if (object == NULL) {
2089     JVMCI_THROW_0(NullPointerException);
2090   }
2091   JVMCIObject base_object = JVMCIENV-&gt;wrap(object);
2092   Handle mirror;
2093   if (JVMCIENV-&gt;isa_HotSpotResolvedObjectTypeImpl(base_object)) {
2094     mirror = Handle(THREAD, JVMCIENV-&gt;asKlass(base_object)-&gt;java_mirror());
2095   } else if (JVMCIENV-&gt;isa_HotSpotResolvedPrimitiveType(base_object)) {
2096     mirror = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;get_HotSpotResolvedPrimitiveType_mirror(base_object), JVMCI_CHECK_NULL);
2097   } else {
2098     JVMCI_THROW_MSG_NULL(IllegalArgumentException,
2099                          err_msg(&quot;Unexpected type: %s&quot;, JVMCIENV-&gt;klass_name(base_object)));
2100  }
2101   JVMCIObject result = JVMCIENV-&gt;get_object_constant(mirror());
2102   return JVMCIENV-&gt;get_jobject(result);
2103 C2V_END
2104 
2105 
2106 C2V_VMENTRY_0(jint, getArrayLength, (JNIEnv* env, jobject, jobject x))
2107   if (x == NULL) {
2108     JVMCI_THROW_0(NullPointerException);
2109   }
2110   Handle xobj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(x), JVMCI_CHECK_0);
2111   if (xobj-&gt;klass()-&gt;is_array_klass()) {
2112     return arrayOop(xobj())-&gt;length();
2113   }
2114   return -1;
2115  C2V_END
2116 
2117 
2118 C2V_VMENTRY_NULL(jobject, readArrayElement, (JNIEnv* env, jobject, jobject x, int index))
2119   if (x == NULL) {
2120     JVMCI_THROW_0(NullPointerException);
2121   }
2122   Handle xobj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(x), JVMCI_CHECK_NULL);
2123   if (xobj-&gt;klass()-&gt;is_array_klass()) {
2124     arrayOop array = arrayOop(xobj());
2125     BasicType element_type = ArrayKlass::cast(array-&gt;klass())-&gt;element_type();
2126     if (index &lt; 0 || index &gt;= array-&gt;length()) {
2127       return NULL;
2128     }
2129     JVMCIObject result;
2130 
2131     if (element_type == T_OBJECT) {
2132       result = JVMCIENV-&gt;get_object_constant(objArrayOop(xobj())-&gt;obj_at(index));
2133       if (result.is_null()) {
2134         result = JVMCIENV-&gt;get_JavaConstant_NULL_POINTER();
2135       }
2136     } else {
2137       jvalue value;
2138       switch (element_type) {
2139         case T_DOUBLE:        value.d = typeArrayOop(xobj())-&gt;double_at(index);        break;
2140         case T_FLOAT:         value.f = typeArrayOop(xobj())-&gt;float_at(index);         break;
2141         case T_LONG:          value.j = typeArrayOop(xobj())-&gt;long_at(index);          break;
2142         case T_INT:           value.i = typeArrayOop(xobj())-&gt;int_at(index);            break;
2143         case T_SHORT:         value.s = typeArrayOop(xobj())-&gt;short_at(index);          break;
2144         case T_CHAR:          value.c = typeArrayOop(xobj())-&gt;char_at(index);           break;
2145         case T_BYTE:          value.b = typeArrayOop(xobj())-&gt;byte_at(index);           break;
2146         case T_BOOLEAN:       value.z = typeArrayOop(xobj())-&gt;byte_at(index) &amp; 1;       break;
2147         default:              ShouldNotReachHere();
2148       }
2149       result = JVMCIENV-&gt;create_box(element_type, &amp;value, JVMCI_CHECK_NULL);
2150     }
2151     assert(!result.is_null(), &quot;must have a value&quot;);
2152     return JVMCIENV-&gt;get_jobject(result);
2153   }
2154   return NULL;;
2155 C2V_END
2156 
2157 
2158 C2V_VMENTRY_0(jint, arrayBaseOffset, (JNIEnv* env, jobject, jobject kind))
2159   if (kind == NULL) {
2160     JVMCI_THROW_0(NullPointerException);
2161   }
2162   BasicType type = JVMCIENV-&gt;kindToBasicType(JVMCIENV-&gt;wrap(kind), JVMCI_CHECK_0);
2163   return arrayOopDesc::header_size(type) * HeapWordSize;
2164 C2V_END
2165 
2166 C2V_VMENTRY_0(jint, arrayIndexScale, (JNIEnv* env, jobject, jobject kind))
2167   if (kind == NULL) {
2168     JVMCI_THROW_0(NullPointerException);
2169   }
2170   BasicType type = JVMCIENV-&gt;kindToBasicType(JVMCIENV-&gt;wrap(kind), JVMCI_CHECK_0);
2171   return type2aelembytes(type);
2172 C2V_END
2173 
2174 C2V_VMENTRY_0(jbyte, getByte, (JNIEnv* env, jobject, jobject x, long displacement))
2175   if (x == NULL) {
2176     JVMCI_THROW_0(NullPointerException);
2177   }
2178   Handle xobj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(x), JVMCI_CHECK_0);
2179   return xobj-&gt;byte_field(displacement);
2180 }
2181 
2182 C2V_VMENTRY_0(jshort, getShort, (JNIEnv* env, jobject, jobject x, long displacement))
2183   if (x == NULL) {
2184     JVMCI_THROW_0(NullPointerException);
2185   }
2186   Handle xobj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(x), JVMCI_CHECK_0);
2187   return xobj-&gt;short_field(displacement);
2188 }
2189 
2190 C2V_VMENTRY_0(jint, getInt, (JNIEnv* env, jobject, jobject x, long displacement))
2191   if (x == NULL) {
2192     JVMCI_THROW_0(NullPointerException);
2193   }
2194   Handle xobj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(x), JVMCI_CHECK_0);
2195   return xobj-&gt;int_field(displacement);
2196 }
2197 
2198 C2V_VMENTRY_0(jlong, getLong, (JNIEnv* env, jobject, jobject x, long displacement))
2199   if (x == NULL) {
2200     JVMCI_THROW_0(NullPointerException);
2201   }
2202   Handle xobj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(x), JVMCI_CHECK_0);
2203   return xobj-&gt;long_field(displacement);
2204 }
2205 
2206 C2V_VMENTRY_NULL(jobject, getObject, (JNIEnv* env, jobject, jobject x, long displacement))
2207   if (x == NULL) {
2208     JVMCI_THROW_0(NullPointerException);
2209   }
2210   Handle xobj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(x), JVMCI_CHECK_0);
2211   oop res = xobj-&gt;obj_field(displacement);
2212   JVMCIObject result = JVMCIENV-&gt;get_object_constant(res);
2213   return JVMCIENV-&gt;get_jobject(result);
2214 }
2215 
2216 C2V_VMENTRY(void, deleteGlobalHandle, (JNIEnv* env, jobject, jlong h))
2217   jobject handle = (jobject)(address)h;
2218   if (handle != NULL) {
2219     JVMCI::destroy_global(handle);
2220   }
2221 }
2222 
2223 static void requireJVMCINativeLibrary(JVMCI_TRAPS) {
2224   if (!UseJVMCINativeLibrary) {
2225     JVMCI_THROW_MSG(UnsupportedOperationException, &quot;JVMCI shared library is not enabled (requires -XX:+UseJVMCINativeLibrary)&quot;);
2226   }
2227 }
2228 
2229 static JavaVM* requireNativeLibraryJavaVM(const char* caller, JVMCI_TRAPS) {
2230   JavaVM* javaVM = JVMCIEnv::get_shared_library_javavm();
2231   if (javaVM == NULL) {
2232     JVMCI_THROW_MSG_NULL(IllegalStateException, err_msg(&quot;Require JVMCI shared library to be initialized in %s&quot;, caller));
2233   }
2234   return javaVM;
2235 }
2236 
2237 C2V_VMENTRY_NULL(jlongArray, registerNativeMethods, (JNIEnv* env, jobject, jclass mirror))
2238   requireJVMCINativeLibrary(JVMCI_CHECK_NULL);
2239   requireInHotSpot(&quot;registerNativeMethods&quot;, JVMCI_CHECK_NULL);
2240   void* shared_library = JVMCIEnv::get_shared_library_handle();
2241   if (shared_library == NULL) {
2242     // Ensure the JVMCI shared library runtime is initialized.
2243     JVMCIEnv __peer_jvmci_env__(thread, false, __FILE__, __LINE__);
2244     JVMCIEnv* peerEnv = &amp;__peer_jvmci_env__;
2245     HandleMark hm;
2246     JVMCIRuntime* runtime = JVMCI::compiler_runtime();
2247     JVMCIObject receiver = runtime-&gt;get_HotSpotJVMCIRuntime(peerEnv);
2248     if (peerEnv-&gt;has_pending_exception()) {
2249       peerEnv-&gt;describe_pending_exception(true);
2250     }
2251     shared_library = JVMCIEnv::get_shared_library_handle();
2252     if (shared_library == NULL) {
2253       JVMCI_THROW_MSG_0(InternalError, &quot;Error initializing JVMCI runtime&quot;);
2254     }
2255   }
2256 
2257   if (mirror == NULL) {
2258     JVMCI_THROW_0(NullPointerException);
2259   }
2260   Klass* klass = java_lang_Class::as_Klass(JNIHandles::resolve(mirror));
2261   if (klass == NULL || !klass-&gt;is_instance_klass()) {
2262     JVMCI_THROW_MSG_0(IllegalArgumentException, &quot;clazz is for primitive type&quot;);
2263   }
2264 
2265   InstanceKlass* iklass = InstanceKlass::cast(klass);
2266   for (int i = 0; i &lt; iklass-&gt;methods()-&gt;length(); i++) {
2267     methodHandle method(THREAD, iklass-&gt;methods()-&gt;at(i));
2268     if (method-&gt;is_native()) {
2269 
2270       // Compute argument size
2271       int args_size = 1                             // JNIEnv
2272                     + (method-&gt;is_static() ? 1 : 0) // class for static methods
2273                     + method-&gt;size_of_parameters(); // actual parameters
2274 
2275       // 1) Try JNI short style
2276       stringStream st;
2277       char* pure_name = NativeLookup::pure_jni_name(method);
2278       os::print_jni_name_prefix_on(&amp;st, args_size);
2279       st.print_raw(pure_name);
2280       os::print_jni_name_suffix_on(&amp;st, args_size);
2281       char* jni_name = st.as_string();
2282 
2283       address entry = (address) os::dll_lookup(shared_library, jni_name);
2284       if (entry == NULL) {
2285         // 2) Try JNI long style
2286         st.reset();
2287         char* long_name = NativeLookup::long_jni_name(method);
2288         os::print_jni_name_prefix_on(&amp;st, args_size);
2289         st.print_raw(pure_name);
2290         st.print_raw(long_name);
2291         os::print_jni_name_suffix_on(&amp;st, args_size);
2292         char* jni_long_name = st.as_string();
2293         entry = (address) os::dll_lookup(shared_library, jni_long_name);
2294         if (entry == NULL) {
2295           JVMCI_THROW_MSG_0(UnsatisfiedLinkError, err_msg(&quot;%s [neither %s nor %s exist in %s]&quot;,
2296               method-&gt;name_and_sig_as_C_string(),
2297               jni_name, jni_long_name, JVMCIEnv::get_shared_library_path()));
2298         }
2299       }
2300 
2301       if (method-&gt;has_native_function() &amp;&amp; entry != method-&gt;native_function()) {
2302         JVMCI_THROW_MSG_0(UnsatisfiedLinkError, err_msg(&quot;%s [cannot re-link from &quot; PTR_FORMAT &quot; to &quot; PTR_FORMAT &quot;]&quot;,
2303             method-&gt;name_and_sig_as_C_string(), p2i(method-&gt;native_function()), p2i(entry)));
2304       }
2305       method-&gt;set_native_function(entry, Method::native_bind_event_is_interesting);
2306       log_debug(jni, resolve)(&quot;[Dynamic-linking native method %s.%s ... JNI]&quot;,
2307                               method-&gt;method_holder()-&gt;external_name(),
2308                               method-&gt;name()-&gt;as_C_string());
2309     }
2310   }
2311 
2312   JavaVM* javaVM = JVMCIEnv::get_shared_library_javavm();
2313   JVMCIPrimitiveArray result = JVMCIENV-&gt;new_longArray(4, JVMCI_CHECK_NULL);
2314   JVMCIENV-&gt;put_long_at(result, 0, (jlong) (address) javaVM);
2315   JVMCIENV-&gt;put_long_at(result, 1, (jlong) (address) javaVM-&gt;functions-&gt;reserved0);
2316   JVMCIENV-&gt;put_long_at(result, 2, (jlong) (address) javaVM-&gt;functions-&gt;reserved1);
2317   JVMCIENV-&gt;put_long_at(result, 3, (jlong) (address) javaVM-&gt;functions-&gt;reserved2);
2318   return (jlongArray) JVMCIENV-&gt;get_jobject(result);
2319 }
2320 
2321 C2V_VMENTRY_PREFIX(jboolean, isCurrentThreadAttached, (JNIEnv* env, jobject c2vm))
2322   if (base_thread == NULL) {
2323     // Called from unattached JVMCI shared library thread
2324     return false;
2325   }
2326   JVMCITraceMark jtm(&quot;isCurrentThreadAttached&quot;);
2327   assert(base_thread-&gt;is_Java_thread(), &quot;just checking&quot;);
2328   JavaThread* thread = (JavaThread*) base_thread;
2329   if (thread-&gt;jni_environment() == env) {
2330     C2V_BLOCK(jboolean, isCurrentThreadAttached, (JNIEnv* env, jobject))
2331     requireJVMCINativeLibrary(JVMCI_CHECK_0);
2332     JavaVM* javaVM = requireNativeLibraryJavaVM(&quot;isCurrentThreadAttached&quot;, JVMCI_CHECK_0);
2333     JNIEnv* peerEnv;
2334     return javaVM-&gt;GetEnv((void**)&amp;peerEnv, JNI_VERSION_1_2) == JNI_OK;
2335   }
2336   return true;
2337 C2V_END
2338 
2339 C2V_VMENTRY_PREFIX(jlong, getCurrentJavaThread, (JNIEnv* env, jobject c2vm))
2340   if (base_thread == NULL) {
2341     // Called from unattached JVMCI shared library thread
2342     return 0L;
2343   }
2344   JVMCITraceMark jtm(&quot;getCurrentJavaThread&quot;);
2345   assert(base_thread-&gt;is_Java_thread(), &quot;just checking&quot;);
2346   return (jlong) p2i(base_thread);
2347 C2V_END
2348 
2349 C2V_VMENTRY_PREFIX(jboolean, attachCurrentThread, (JNIEnv* env, jobject c2vm, jboolean as_daemon))
2350   if (base_thread == NULL) {
2351     // Called from unattached JVMCI shared library thread
2352     extern struct JavaVM_ main_vm;
2353     JNIEnv* hotspotEnv;
2354     jint res = as_daemon ? main_vm.AttachCurrentThreadAsDaemon((void**)&amp;hotspotEnv, NULL) :
2355                            main_vm.AttachCurrentThread((void**)&amp;hotspotEnv, NULL);
2356     if (res != JNI_OK) {
2357       JNI_THROW_(&quot;attachCurrentThread&quot;, InternalError, err_msg(&quot;Trying to attach thread returned %d&quot;, res), false);
2358     }
2359     return true;
2360   }
2361   JVMCITraceMark jtm(&quot;attachCurrentThread&quot;);
2362   assert(base_thread-&gt;is_Java_thread(), &quot;just checking&quot;);\
2363   JavaThread* thread = (JavaThread*) base_thread;
2364   if (thread-&gt;jni_environment() == env) {
2365     // Called from HotSpot
2366     C2V_BLOCK(jboolean, attachCurrentThread, (JNIEnv* env, jobject, jboolean))
2367     requireJVMCINativeLibrary(JVMCI_CHECK_0);
2368     JavaVM* javaVM = requireNativeLibraryJavaVM(&quot;attachCurrentThread&quot;, JVMCI_CHECK_0);
2369     JavaVMAttachArgs attach_args;
2370     attach_args.version = JNI_VERSION_1_2;
2371     attach_args.name = thread-&gt;name();
2372     attach_args.group = NULL;
2373     JNIEnv* peerEnv;
2374     if (javaVM-&gt;GetEnv((void**)&amp;peerEnv, JNI_VERSION_1_2) == JNI_OK) {
2375       return false;
2376     }
2377     jint res = as_daemon ? javaVM-&gt;AttachCurrentThreadAsDaemon((void**)&amp;peerEnv, &amp;attach_args) :
2378                            javaVM-&gt;AttachCurrentThread((void**)&amp;peerEnv, &amp;attach_args);
2379     if (res == JNI_OK) {
2380       guarantee(peerEnv != NULL, &quot;must be&quot;);
2381       return true;
2382     }
2383     JVMCI_THROW_MSG_0(InternalError, err_msg(&quot;Error %d while attaching %s&quot;, res, attach_args.name));
2384   }
2385   // Called from JVMCI shared library
2386   return false;
2387 C2V_END
2388 
2389 C2V_VMENTRY_PREFIX(void, detachCurrentThread, (JNIEnv* env, jobject c2vm))
2390   if (base_thread == NULL) {
2391     // Called from unattached JVMCI shared library thread
2392     JNI_THROW(&quot;detachCurrentThread&quot;, IllegalStateException, err_msg(&quot;Cannot detach non-attached thread&quot;));
2393   }
2394   JVMCITraceMark jtm(&quot;detachCurrentThread&quot;);
2395   assert(base_thread-&gt;is_Java_thread(), &quot;just checking&quot;);\
2396   JavaThread* thread = (JavaThread*) base_thread;
2397   if (thread-&gt;jni_environment() == env) {
2398     // Called from HotSpot
2399     C2V_BLOCK(void, detachCurrentThread, (JNIEnv* env, jobject))
2400     requireJVMCINativeLibrary(JVMCI_CHECK);
2401     requireInHotSpot(&quot;detachCurrentThread&quot;, JVMCI_CHECK);
2402     JavaVM* javaVM = requireNativeLibraryJavaVM(&quot;detachCurrentThread&quot;, JVMCI_CHECK);
2403     JNIEnv* peerEnv;
2404     if (javaVM-&gt;GetEnv((void**)&amp;peerEnv, JNI_VERSION_1_2) != JNI_OK) {
2405       JVMCI_THROW_MSG(IllegalStateException, err_msg(&quot;Cannot detach non-attached thread: %s&quot;, thread-&gt;name()));
2406     }
2407     jint res = javaVM-&gt;DetachCurrentThread();
2408     if (res != JNI_OK) {
2409       JVMCI_THROW_MSG(InternalError, err_msg(&quot;Error %d while attaching %s&quot;, res, thread-&gt;name()));
2410     }
2411   } else {
2412     // Called from attached JVMCI shared library thread
2413     extern struct JavaVM_ main_vm;
2414     jint res = main_vm.DetachCurrentThread();
2415     if (res != JNI_OK) {
2416       JNI_THROW(&quot;detachCurrentThread&quot;, InternalError, err_msg(&quot;Cannot detach non-attached thread&quot;));
2417     }
2418   }
2419 C2V_END
2420 
2421 C2V_VMENTRY_0(jlong, translate, (JNIEnv* env, jobject, jobject obj_handle))
2422   requireJVMCINativeLibrary(JVMCI_CHECK_0);
2423   if (obj_handle == NULL) {
2424     return 0L;
2425   }
2426   JVMCIEnv __peer_jvmci_env__(thread, !JVMCIENV-&gt;is_hotspot(), __FILE__, __LINE__);
2427   JVMCIEnv* peerEnv = &amp;__peer_jvmci_env__;
2428   JVMCIEnv* thisEnv = JVMCIENV;
2429 
2430   JVMCIObject obj = thisEnv-&gt;wrap(obj_handle);
2431   JVMCIObject result;
2432   if (thisEnv-&gt;isa_HotSpotResolvedJavaMethodImpl(obj)) {
2433     methodHandle method(THREAD, thisEnv-&gt;asMethod(obj));
2434     result = peerEnv-&gt;get_jvmci_method(method, JVMCI_CHECK_0);
2435   } else if (thisEnv-&gt;isa_HotSpotResolvedObjectTypeImpl(obj)) {
2436     Klass* klass = thisEnv-&gt;asKlass(obj);
2437     JVMCIKlassHandle klass_handle(THREAD);
2438     klass_handle = klass;
2439     result = peerEnv-&gt;get_jvmci_type(klass_handle, JVMCI_CHECK_0);
2440   } else if (thisEnv-&gt;isa_HotSpotResolvedPrimitiveType(obj)) {
2441     BasicType type = JVMCIENV-&gt;kindToBasicType(JVMCIENV-&gt;get_HotSpotResolvedPrimitiveType_kind(obj), JVMCI_CHECK_0);
2442     result = peerEnv-&gt;get_jvmci_primitive_type(type);
2443   } else if (thisEnv-&gt;isa_IndirectHotSpotObjectConstantImpl(obj) ||
2444              thisEnv-&gt;isa_DirectHotSpotObjectConstantImpl(obj)) {
2445     Handle constant = thisEnv-&gt;asConstant(obj, JVMCI_CHECK_0);
2446     result = peerEnv-&gt;get_object_constant(constant());
2447   } else if (thisEnv-&gt;isa_HotSpotNmethod(obj)) {
2448     nmethodLocker locker;
2449     nmethod* nm = JVMCIENV-&gt;get_nmethod(obj, locker);
2450     if (nm != NULL) {
2451       JVMCINMethodData* data = nm-&gt;jvmci_nmethod_data();
2452       if (data != NULL) {
2453         if (peerEnv-&gt;is_hotspot()) {
2454           // Only the mirror in the HotSpot heap is accessible
2455           // through JVMCINMethodData
2456           oop nmethod_mirror = data-&gt;get_nmethod_mirror(nm, /* phantom_ref */ true);
2457           if (nmethod_mirror != NULL) {
2458             result = HotSpotJVMCI::wrap(nmethod_mirror);
2459           }
2460         }
2461       }
2462     }
2463     if (result.is_null()) {
2464       JVMCIObject methodObject = thisEnv-&gt;get_HotSpotNmethod_method(obj);
2465       methodHandle mh(THREAD, thisEnv-&gt;asMethod(methodObject));
2466       jboolean isDefault = thisEnv-&gt;get_HotSpotNmethod_isDefault(obj);
2467       jlong compileIdSnapshot = thisEnv-&gt;get_HotSpotNmethod_compileIdSnapshot(obj);
2468       JVMCIObject name_string = thisEnv-&gt;get_InstalledCode_name(obj);
2469       const char* cstring = name_string.is_null() ? NULL : thisEnv-&gt;as_utf8_string(name_string);
2470       // Create a new HotSpotNmethod instance in the peer runtime
2471       result = peerEnv-&gt;new_HotSpotNmethod(mh, cstring, isDefault, compileIdSnapshot, JVMCI_CHECK_0);
2472       if (nm == NULL) {
2473         // nmethod must have been unloaded
2474       } else {
2475         // Link the new HotSpotNmethod to the nmethod
2476         peerEnv-&gt;initialize_installed_code(result, nm, JVMCI_CHECK_0);
2477         // Only HotSpotNmethod instances in the HotSpot heap are tracked directly by the runtime.
2478         if (peerEnv-&gt;is_hotspot()) {
2479           JVMCINMethodData* data = nm-&gt;jvmci_nmethod_data();
2480           if (data == NULL) {
2481             JVMCI_THROW_MSG_0(IllegalArgumentException, &quot;Cannot set HotSpotNmethod mirror for default nmethod&quot;);
2482           }
2483           if (data-&gt;get_nmethod_mirror(nm, /* phantom_ref */ false) != NULL) {
2484             JVMCI_THROW_MSG_0(IllegalArgumentException, &quot;Cannot overwrite existing HotSpotNmethod mirror for nmethod&quot;);
2485           }
2486           oop nmethod_mirror = HotSpotJVMCI::resolve(result);
2487           data-&gt;set_nmethod_mirror(nm, nmethod_mirror);
2488         }
2489       }
2490     }
2491   } else {
2492     JVMCI_THROW_MSG_0(IllegalArgumentException,
2493                 err_msg(&quot;Cannot translate object of type: %s&quot;, thisEnv-&gt;klass_name(obj)));
2494   }
2495   return (jlong) peerEnv-&gt;make_global(result).as_jobject();
2496 }
2497 
2498 C2V_VMENTRY_NULL(jobject, unhand, (JNIEnv* env, jobject, jlong obj_handle))
2499   requireJVMCINativeLibrary(JVMCI_CHECK_NULL);
2500   if (obj_handle == 0L) {
2501     return NULL;
2502   }
2503   jobject global_handle = (jobject) obj_handle;
2504   JVMCIObject global_handle_obj = JVMCIENV-&gt;wrap((jobject) obj_handle);
2505   jobject result = JVMCIENV-&gt;make_local(global_handle_obj).as_jobject();
2506 
2507   JVMCIENV-&gt;destroy_global(global_handle_obj);
2508   return result;
2509 }
2510 
2511 C2V_VMENTRY(void, updateHotSpotNmethod, (JNIEnv* env, jobject, jobject code_handle))
2512   JVMCIObject code = JVMCIENV-&gt;wrap(code_handle);
2513   // Execute this operation for the side effect of updating the InstalledCode state
2514   nmethodLocker locker;
2515   JVMCIENV-&gt;get_nmethod(code, locker);
2516 }
2517 
2518 C2V_VMENTRY_NULL(jbyteArray, getCode, (JNIEnv* env, jobject, jobject code_handle))
2519   JVMCIObject code = JVMCIENV-&gt;wrap(code_handle);
2520   nmethodLocker locker;
2521   CodeBlob* cb = JVMCIENV-&gt;get_code_blob(code, locker);
2522   if (cb == NULL) {
2523     return NULL;
2524   }
2525   int code_size = cb-&gt;code_size();
2526   JVMCIPrimitiveArray result = JVMCIENV-&gt;new_byteArray(code_size, JVMCI_CHECK_NULL);
2527   JVMCIENV-&gt;copy_bytes_from((jbyte*) cb-&gt;code_begin(), result, 0, code_size);
2528   return JVMCIENV-&gt;get_jbyteArray(result);
2529 }
2530 
2531 C2V_VMENTRY_NULL(jobject, asReflectionExecutable, (JNIEnv* env, jobject, jobject jvmci_method))
2532   requireInHotSpot(&quot;asReflectionExecutable&quot;, JVMCI_CHECK_NULL);
2533   methodHandle m(THREAD, JVMCIENV-&gt;asMethod(jvmci_method));
2534   oop executable;
2535   if (m-&gt;is_initializer()) {
2536     if (m-&gt;is_static_initializer()) {
2537       JVMCI_THROW_MSG_NULL(IllegalArgumentException,
2538           &quot;Cannot create java.lang.reflect.Method for class initializer&quot;);
2539     }
2540     executable = Reflection::new_constructor(m, CHECK_NULL);
2541   } else {
2542     executable = Reflection::new_method(m, false, CHECK_NULL);
2543   }
2544   return JNIHandles::make_local(THREAD, executable);
2545 }
2546 
2547 C2V_VMENTRY_NULL(jobject, asReflectionField, (JNIEnv* env, jobject, jobject jvmci_type, jint index))
2548   requireInHotSpot(&quot;asReflectionField&quot;, JVMCI_CHECK_NULL);
2549   Klass* klass = JVMCIENV-&gt;asKlass(jvmci_type);
2550   if (!klass-&gt;is_instance_klass()) {
2551     JVMCI_THROW_MSG_NULL(IllegalArgumentException,
2552         err_msg(&quot;Expected non-primitive type, got %s&quot;, klass-&gt;external_name()));
2553   }
2554   InstanceKlass* iklass = InstanceKlass::cast(klass);
2555   Array&lt;u2&gt;* fields = iklass-&gt;fields();
2556   if (index &lt; 0 ||index &gt; fields-&gt;length()) {
2557     JVMCI_THROW_MSG_NULL(IllegalArgumentException,
2558         err_msg(&quot;Field index %d out of bounds for %s&quot;, index, klass-&gt;external_name()));
2559   }
2560   fieldDescriptor fd(iklass, index);
2561   oop reflected = Reflection::new_field(&amp;fd, CHECK_NULL);
2562   return JNIHandles::make_local(env, reflected);
2563 }
2564 
2565 C2V_VMENTRY_NULL(jobjectArray, getFailedSpeculations, (JNIEnv* env, jobject, jlong failed_speculations_address, jobjectArray current))
2566   FailedSpeculation* head = *((FailedSpeculation**)(address) failed_speculations_address);
2567   int result_length = 0;
2568   for (FailedSpeculation* fs = head; fs != NULL; fs = fs-&gt;next()) {
2569     result_length++;
2570   }
2571   int current_length = 0;
2572   JVMCIObjectArray current_array = NULL;
2573   if (current != NULL) {
2574     current_array = JVMCIENV-&gt;wrap(current);
2575     current_length = JVMCIENV-&gt;get_length(current_array);
2576     if (current_length == result_length) {
2577       // No new failures
2578       return current;
2579     }
2580   }
2581   JVMCIObjectArray result = JVMCIENV-&gt;new_byte_array_array(result_length, JVMCI_CHECK_NULL);
2582   int result_index = 0;
2583   for (FailedSpeculation* fs = head; result_index &lt; result_length; fs = fs-&gt;next()) {
2584     assert(fs != NULL, &quot;npe&quot;);
2585     JVMCIPrimitiveArray entry;
2586     if (result_index &lt; current_length) {
2587       entry = (JVMCIPrimitiveArray) JVMCIENV-&gt;get_object_at(current_array, result_index);
2588     } else {
2589       entry = JVMCIENV-&gt;new_byteArray(fs-&gt;data_len(), JVMCI_CHECK_NULL);
2590       JVMCIENV-&gt;copy_bytes_from((jbyte*) fs-&gt;data(), entry, 0, fs-&gt;data_len());
2591     }
2592     JVMCIENV-&gt;put_object_at(result, result_index++, entry);
2593   }
2594   return JVMCIENV-&gt;get_jobjectArray(result);
2595 }
2596 
2597 C2V_VMENTRY_0(jlong, getFailedSpeculationsAddress, (JNIEnv* env, jobject, jobject jvmci_method))
2598   methodHandle method(THREAD, JVMCIENV-&gt;asMethod(jvmci_method));
2599   MethodData* method_data = method-&gt;method_data();
2600   if (method_data == NULL) {
2601     ClassLoaderData* loader_data = method-&gt;method_holder()-&gt;class_loader_data();
2602     method_data = MethodData::allocate(loader_data, method, CHECK_0);
2603     method-&gt;set_method_data(method_data);
2604   }
2605   return (jlong) method_data-&gt;get_failed_speculations_address();
2606 }
2607 
2608 C2V_VMENTRY(void, releaseFailedSpeculations, (JNIEnv* env, jobject, jlong failed_speculations_address))
2609   FailedSpeculation::free_failed_speculations((FailedSpeculation**)(address) failed_speculations_address);
2610 }
2611 
2612 C2V_VMENTRY_0(jboolean, addFailedSpeculation, (JNIEnv* env, jobject, jlong failed_speculations_address, jbyteArray speculation_obj))
2613   JVMCIPrimitiveArray speculation_handle = JVMCIENV-&gt;wrap(speculation_obj);
2614   int speculation_len = JVMCIENV-&gt;get_length(speculation_handle);
2615   char* speculation = NEW_RESOURCE_ARRAY(char, speculation_len);
2616   JVMCIENV-&gt;copy_bytes_to(speculation_handle, (jbyte*) speculation, 0, speculation_len);
2617   return FailedSpeculation::add_failed_speculation(NULL, (FailedSpeculation**)(address) failed_speculations_address, (address) speculation, speculation_len);
2618 }
2619 
2620 C2V_VMENTRY(void, callSystemExit, (JNIEnv* env, jobject, jint status))
2621   JavaValue result(T_VOID);
2622   JavaCallArguments jargs(1);
2623   jargs.push_int(status);
2624   JavaCalls::call_static(&amp;result,
2625                        SystemDictionary::System_klass(),
2626                        vmSymbols::exit_method_name(),
2627                        vmSymbols::int_void_signature(),
2628                        &amp;jargs,
2629                        CHECK);
2630 }
2631 
<a name="2" id="anc2"></a><span class="line-added">2632 C2V_VMENTRY_0(jlong, ticksNow, (JNIEnv* env, jobject))</span>
<span class="line-added">2633   return CompilerEvent::ticksNow();</span>
<span class="line-added">2634 }</span>
<span class="line-added">2635 </span>
<span class="line-added">2636 C2V_VMENTRY_0(jint, registerCompilerPhases, (JNIEnv* env, jobject, jobjectArray jphases))</span>
<span class="line-added">2637 #if INCLUDE_JFR</span>
<span class="line-added">2638   if (jphases == NULL) {</span>
<span class="line-added">2639     return -1;</span>
<span class="line-added">2640   }</span>
<span class="line-added">2641   JVMCIObjectArray phases = JVMCIENV-&gt;wrap(jphases);</span>
<span class="line-added">2642   int len = JVMCIENV-&gt;get_length(phases);</span>
<span class="line-added">2643   GrowableArray&lt;const char*&gt;* jvmci_phase_names = new GrowableArray&lt;const char*&gt;(len);</span>
<span class="line-added">2644   for (int i = 0; i &lt; len; i++) {</span>
<span class="line-added">2645     JVMCIObject phase = JVMCIENV-&gt;get_object_at(phases, i);</span>
<span class="line-added">2646     jvmci_phase_names-&gt;append(strdup(JVMCIENV-&gt;as_utf8_string(phase)));</span>
<span class="line-added">2647   }</span>
<span class="line-added">2648   return CompilerEvent::PhaseEvent::register_phases(jvmci_phase_names);</span>
<span class="line-added">2649 #else</span>
<span class="line-added">2650   return -1;</span>
<span class="line-added">2651 #endif // !INCLUDE_JFR</span>
<span class="line-added">2652 }</span>
<span class="line-added">2653 </span>
<span class="line-added">2654 C2V_VMENTRY(void, notifyCompilerPhaseEvent, (JNIEnv* env, jobject, jlong startTime, jint phase, jint compileId, jint level))</span>
<span class="line-added">2655   EventCompilerPhase event;</span>
<span class="line-added">2656   if (event.should_commit()) {</span>
<span class="line-added">2657     CompilerEvent::PhaseEvent::post(event, startTime, phase, compileId, level);</span>
<span class="line-added">2658   }</span>
<span class="line-added">2659 }</span>
<span class="line-added">2660 </span>
<span class="line-added">2661 C2V_VMENTRY(void, notifyCompilerInliningEvent, (JNIEnv* env, jobject, jint compileId, jobject caller, jobject callee, jboolean succeeded, jstring jmessage, jint bci))</span>
<span class="line-added">2662   EventCompilerInlining event;</span>
<span class="line-added">2663   if (event.should_commit()) {</span>
<span class="line-added">2664     Method* caller_method = JVMCIENV-&gt;asMethod(caller);</span>
<span class="line-added">2665     Method* callee_method = JVMCIENV-&gt;asMethod(callee);</span>
<span class="line-added">2666     JVMCIObject message = JVMCIENV-&gt;wrap(jmessage);</span>
<span class="line-added">2667     CompilerEvent::InlineEvent::post(event, compileId, caller_method, callee_method, succeeded, JVMCIENV-&gt;as_utf8_string(message), bci);</span>
<span class="line-added">2668   }</span>
<span class="line-added">2669 }</span>
<span class="line-added">2670 </span>
2671 #define CC (char*)  /*cast a literal from (const char*)*/
2672 #define FN_PTR(f) CAST_FROM_FN_PTR(void*, &amp;(c2v_ ## f))
2673 
2674 #define STRING                  &quot;Ljava/lang/String;&quot;
2675 #define OBJECT                  &quot;Ljava/lang/Object;&quot;
2676 #define CLASS                   &quot;Ljava/lang/Class;&quot;
2677 #define OBJECTCONSTANT          &quot;Ljdk/vm/ci/hotspot/HotSpotObjectConstantImpl;&quot;
2678 #define HANDLECONSTANT          &quot;Ljdk/vm/ci/hotspot/IndirectHotSpotObjectConstantImpl;&quot;
2679 #define EXECUTABLE              &quot;Ljava/lang/reflect/Executable;&quot;
2680 #define STACK_TRACE_ELEMENT     &quot;Ljava/lang/StackTraceElement;&quot;
2681 #define INSTALLED_CODE          &quot;Ljdk/vm/ci/code/InstalledCode;&quot;
2682 #define TARGET_DESCRIPTION      &quot;Ljdk/vm/ci/code/TargetDescription;&quot;
2683 #define BYTECODE_FRAME          &quot;Ljdk/vm/ci/code/BytecodeFrame;&quot;
2684 #define JAVACONSTANT            &quot;Ljdk/vm/ci/meta/JavaConstant;&quot;
2685 #define INSPECTED_FRAME_VISITOR &quot;Ljdk/vm/ci/code/stack/InspectedFrameVisitor;&quot;
2686 #define RESOLVED_METHOD         &quot;Ljdk/vm/ci/meta/ResolvedJavaMethod;&quot;
2687 #define HS_RESOLVED_METHOD      &quot;Ljdk/vm/ci/hotspot/HotSpotResolvedJavaMethodImpl;&quot;
2688 #define HS_RESOLVED_KLASS       &quot;Ljdk/vm/ci/hotspot/HotSpotResolvedObjectTypeImpl;&quot;
2689 #define HS_RESOLVED_TYPE        &quot;Ljdk/vm/ci/hotspot/HotSpotResolvedJavaType;&quot;
2690 #define HS_RESOLVED_FIELD       &quot;Ljdk/vm/ci/hotspot/HotSpotResolvedJavaField;&quot;
2691 #define HS_INSTALLED_CODE       &quot;Ljdk/vm/ci/hotspot/HotSpotInstalledCode;&quot;
2692 #define HS_NMETHOD              &quot;Ljdk/vm/ci/hotspot/HotSpotNmethod;&quot;
2693 #define HS_CONSTANT_POOL        &quot;Ljdk/vm/ci/hotspot/HotSpotConstantPool;&quot;
2694 #define HS_COMPILED_CODE        &quot;Ljdk/vm/ci/hotspot/HotSpotCompiledCode;&quot;
2695 #define HS_CONFIG               &quot;Ljdk/vm/ci/hotspot/HotSpotVMConfig;&quot;
2696 #define HS_METADATA             &quot;Ljdk/vm/ci/hotspot/HotSpotMetaData;&quot;
2697 #define HS_STACK_FRAME_REF      &quot;Ljdk/vm/ci/hotspot/HotSpotStackFrameReference;&quot;
2698 #define HS_SPECULATION_LOG      &quot;Ljdk/vm/ci/hotspot/HotSpotSpeculationLog;&quot;
2699 #define METASPACE_OBJECT        &quot;Ljdk/vm/ci/hotspot/MetaspaceObject;&quot;
2700 #define REFLECTION_EXECUTABLE   &quot;Ljava/lang/reflect/Executable;&quot;
2701 #define REFLECTION_FIELD        &quot;Ljava/lang/reflect/Field;&quot;
2702 #define METASPACE_METHOD_DATA   &quot;J&quot;
2703 
2704 JNINativeMethod CompilerToVM::methods[] = {
2705   {CC &quot;getBytecode&quot;,                                  CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)[B&quot;,                                                      FN_PTR(getBytecode)},
2706   {CC &quot;getExceptionTableStart&quot;,                       CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)J&quot;,                                                       FN_PTR(getExceptionTableStart)},
2707   {CC &quot;getExceptionTableLength&quot;,                      CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)I&quot;,                                                       FN_PTR(getExceptionTableLength)},
2708   {CC &quot;findUniqueConcreteMethod&quot;,                     CC &quot;(&quot; HS_RESOLVED_KLASS HS_RESOLVED_METHOD &quot;)&quot; HS_RESOLVED_METHOD,                   FN_PTR(findUniqueConcreteMethod)},
2709   {CC &quot;getImplementor&quot;,                               CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)&quot; HS_RESOLVED_KLASS,                                       FN_PTR(getImplementor)},
2710   {CC &quot;getStackTraceElement&quot;,                         CC &quot;(&quot; HS_RESOLVED_METHOD &quot;I)&quot; STACK_TRACE_ELEMENT,                                   FN_PTR(getStackTraceElement)},
2711   {CC &quot;methodIsIgnoredBySecurityStackWalk&quot;,           CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)Z&quot;,                                                       FN_PTR(methodIsIgnoredBySecurityStackWalk)},
2712   {CC &quot;setNotInlinableOrCompilable&quot;,                  CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)V&quot;,                                                       FN_PTR(setNotInlinableOrCompilable)},
2713   {CC &quot;isCompilable&quot;,                                 CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)Z&quot;,                                                       FN_PTR(isCompilable)},
2714   {CC &quot;hasNeverInlineDirective&quot;,                      CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)Z&quot;,                                                       FN_PTR(hasNeverInlineDirective)},
2715   {CC &quot;shouldInlineMethod&quot;,                           CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)Z&quot;,                                                       FN_PTR(shouldInlineMethod)},
2716   {CC &quot;lookupType&quot;,                                   CC &quot;(&quot; STRING HS_RESOLVED_KLASS &quot;Z)&quot; HS_RESOLVED_TYPE,                                FN_PTR(lookupType)},
2717   {CC &quot;getArrayType&quot;,                                 CC &quot;(&quot; HS_RESOLVED_TYPE &quot;)&quot; HS_RESOLVED_KLASS,                                        FN_PTR(getArrayType)},
2718   {CC &quot;lookupClass&quot;,                                  CC &quot;(&quot; CLASS &quot;)&quot; HS_RESOLVED_TYPE,                                                    FN_PTR(lookupClass)},
2719   {CC &quot;lookupNameInPool&quot;,                             CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)&quot; STRING,                                                  FN_PTR(lookupNameInPool)},
2720   {CC &quot;lookupNameAndTypeRefIndexInPool&quot;,              CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)I&quot;,                                                        FN_PTR(lookupNameAndTypeRefIndexInPool)},
2721   {CC &quot;lookupSignatureInPool&quot;,                        CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)&quot; STRING,                                                  FN_PTR(lookupSignatureInPool)},
2722   {CC &quot;lookupKlassRefIndexInPool&quot;,                    CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)I&quot;,                                                        FN_PTR(lookupKlassRefIndexInPool)},
2723   {CC &quot;lookupKlassInPool&quot;,                            CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)Ljava/lang/Object;&quot;,                                       FN_PTR(lookupKlassInPool)},
2724   {CC &quot;lookupAppendixInPool&quot;,                         CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)&quot; OBJECTCONSTANT,                                          FN_PTR(lookupAppendixInPool)},
2725   {CC &quot;lookupMethodInPool&quot;,                           CC &quot;(&quot; HS_CONSTANT_POOL &quot;IB)&quot; HS_RESOLVED_METHOD,                                     FN_PTR(lookupMethodInPool)},
2726   {CC &quot;constantPoolRemapInstructionOperandFromCache&quot;, CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)I&quot;,                                                        FN_PTR(constantPoolRemapInstructionOperandFromCache)},
2727   {CC &quot;resolvePossiblyCachedConstantInPool&quot;,          CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)&quot; OBJECTCONSTANT,                                          FN_PTR(resolvePossiblyCachedConstantInPool)},
2728   {CC &quot;resolveTypeInPool&quot;,                            CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)&quot; HS_RESOLVED_KLASS,                                       FN_PTR(resolveTypeInPool)},
2729   {CC &quot;resolveFieldInPool&quot;,                           CC &quot;(&quot; HS_CONSTANT_POOL &quot;I&quot; HS_RESOLVED_METHOD &quot;B[I)&quot; HS_RESOLVED_KLASS,              FN_PTR(resolveFieldInPool)},
2730   {CC &quot;resolveInvokeDynamicInPool&quot;,                   CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)V&quot;,                                                        FN_PTR(resolveInvokeDynamicInPool)},
2731   {CC &quot;resolveInvokeHandleInPool&quot;,                    CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)V&quot;,                                                        FN_PTR(resolveInvokeHandleInPool)},
2732   {CC &quot;isResolvedInvokeHandleInPool&quot;,                 CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)I&quot;,                                                        FN_PTR(isResolvedInvokeHandleInPool)},
2733   {CC &quot;resolveMethod&quot;,                                CC &quot;(&quot; HS_RESOLVED_KLASS HS_RESOLVED_METHOD HS_RESOLVED_KLASS &quot;)&quot; HS_RESOLVED_METHOD, FN_PTR(resolveMethod)},
2734   {CC &quot;getSignaturePolymorphicHolders&quot;,               CC &quot;()[&quot; STRING,                                                                      FN_PTR(getSignaturePolymorphicHolders)},
2735   {CC &quot;getVtableIndexForInterfaceMethod&quot;,             CC &quot;(&quot; HS_RESOLVED_KLASS HS_RESOLVED_METHOD &quot;)I&quot;,                                     FN_PTR(getVtableIndexForInterfaceMethod)},
2736   {CC &quot;getClassInitializer&quot;,                          CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)&quot; HS_RESOLVED_METHOD,                                      FN_PTR(getClassInitializer)},
2737   {CC &quot;hasFinalizableSubclass&quot;,                       CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)Z&quot;,                                                        FN_PTR(hasFinalizableSubclass)},
2738   {CC &quot;getMaxCallTargetOffset&quot;,                       CC &quot;(J)J&quot;,                                                                            FN_PTR(getMaxCallTargetOffset)},
2739   {CC &quot;asResolvedJavaMethod&quot;,                         CC &quot;(&quot; EXECUTABLE &quot;)&quot; HS_RESOLVED_METHOD,                                             FN_PTR(asResolvedJavaMethod)},
2740   {CC &quot;getResolvedJavaMethod&quot;,                        CC &quot;(&quot; OBJECTCONSTANT &quot;J)&quot; HS_RESOLVED_METHOD,                                        FN_PTR(getResolvedJavaMethod)},
2741   {CC &quot;getConstantPool&quot;,                              CC &quot;(&quot; METASPACE_OBJECT &quot;)&quot; HS_CONSTANT_POOL,                                         FN_PTR(getConstantPool)},
2742   {CC &quot;getResolvedJavaType0&quot;,                         CC &quot;(Ljava/lang/Object;JZ)&quot; HS_RESOLVED_KLASS,                                        FN_PTR(getResolvedJavaType0)},
2743   {CC &quot;readConfiguration&quot;,                            CC &quot;()[&quot; OBJECT,                                                                      FN_PTR(readConfiguration)},
2744   {CC &quot;installCode&quot;,                                  CC &quot;(&quot; TARGET_DESCRIPTION HS_COMPILED_CODE INSTALLED_CODE &quot;J[B)I&quot;,                    FN_PTR(installCode)},
2745   {CC &quot;getMetadata&quot;,                                  CC &quot;(&quot; TARGET_DESCRIPTION HS_COMPILED_CODE HS_METADATA &quot;)I&quot;,                          FN_PTR(getMetadata)},
2746   {CC &quot;resetCompilationStatistics&quot;,                   CC &quot;()V&quot;,                                                                             FN_PTR(resetCompilationStatistics)},
2747   {CC &quot;disassembleCodeBlob&quot;,                          CC &quot;(&quot; INSTALLED_CODE &quot;)&quot; STRING,                                                     FN_PTR(disassembleCodeBlob)},
2748   {CC &quot;executeHotSpotNmethod&quot;,                        CC &quot;([&quot; OBJECT HS_NMETHOD &quot;)&quot; OBJECT,                                                 FN_PTR(executeHotSpotNmethod)},
2749   {CC &quot;getLineNumberTable&quot;,                           CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)[J&quot;,                                                      FN_PTR(getLineNumberTable)},
2750   {CC &quot;getLocalVariableTableStart&quot;,                   CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)J&quot;,                                                       FN_PTR(getLocalVariableTableStart)},
2751   {CC &quot;getLocalVariableTableLength&quot;,                  CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)I&quot;,                                                       FN_PTR(getLocalVariableTableLength)},
2752   {CC &quot;reprofile&quot;,                                    CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)V&quot;,                                                       FN_PTR(reprofile)},
2753   {CC &quot;invalidateHotSpotNmethod&quot;,                     CC &quot;(&quot; HS_NMETHOD &quot;)V&quot;,                                                               FN_PTR(invalidateHotSpotNmethod)},
2754   {CC &quot;readUncompressedOop&quot;,                          CC &quot;(J)&quot; OBJECTCONSTANT,                                                              FN_PTR(readUncompressedOop)},
2755   {CC &quot;collectCounters&quot;,                              CC &quot;()[J&quot;,                                                                            FN_PTR(collectCounters)},
2756   {CC &quot;getCountersSize&quot;,                              CC &quot;()I&quot;,                                                                             FN_PTR(getCountersSize)},
2757   {CC &quot;setCountersSize&quot;,                              CC &quot;(I)V&quot;,                                                                            FN_PTR(setCountersSize)},
2758   {CC &quot;allocateCompileId&quot;,                            CC &quot;(&quot; HS_RESOLVED_METHOD &quot;I)I&quot;,                                                      FN_PTR(allocateCompileId)},
2759   {CC &quot;isMature&quot;,                                     CC &quot;(&quot; METASPACE_METHOD_DATA &quot;)Z&quot;,                                                    FN_PTR(isMature)},
2760   {CC &quot;hasCompiledCodeForOSR&quot;,                        CC &quot;(&quot; HS_RESOLVED_METHOD &quot;II)Z&quot;,                                                     FN_PTR(hasCompiledCodeForOSR)},
2761   {CC &quot;getSymbol&quot;,                                    CC &quot;(J)&quot; STRING,                                                                      FN_PTR(getSymbol)},
2762   {CC &quot;iterateFrames&quot;,                                CC &quot;([&quot; RESOLVED_METHOD &quot;[&quot; RESOLVED_METHOD &quot;I&quot; INSPECTED_FRAME_VISITOR &quot;)&quot; OBJECT,   FN_PTR(iterateFrames)},
2763   {CC &quot;materializeVirtualObjects&quot;,                    CC &quot;(&quot; HS_STACK_FRAME_REF &quot;Z)V&quot;,                                                      FN_PTR(materializeVirtualObjects)},
2764   {CC &quot;shouldDebugNonSafepoints&quot;,                     CC &quot;()Z&quot;,                                                                             FN_PTR(shouldDebugNonSafepoints)},
2765   {CC &quot;writeDebugOutput&quot;,                             CC &quot;([BIIZZ)I&quot;,                                                                       FN_PTR(writeDebugOutput)},
2766   {CC &quot;flushDebugOutput&quot;,                             CC &quot;()V&quot;,                                                                             FN_PTR(flushDebugOutput)},
2767   {CC &quot;methodDataProfileDataSize&quot;,                    CC &quot;(JI)I&quot;,                                                                           FN_PTR(methodDataProfileDataSize)},
2768   {CC &quot;getFingerprint&quot;,                               CC &quot;(J)J&quot;,                                                                            FN_PTR(getFingerprint)},
2769   {CC &quot;getHostClass&quot;,                                 CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)&quot; HS_RESOLVED_KLASS,                                       FN_PTR(getHostClass)},
2770   {CC &quot;interpreterFrameSize&quot;,                         CC &quot;(&quot; BYTECODE_FRAME &quot;)I&quot;,                                                           FN_PTR(interpreterFrameSize)},
2771   {CC &quot;compileToBytecode&quot;,                            CC &quot;(&quot; OBJECTCONSTANT &quot;)V&quot;,                                                           FN_PTR(compileToBytecode)},
2772   {CC &quot;getFlagValue&quot;,                                 CC &quot;(&quot; STRING &quot;)&quot; OBJECT,                                                             FN_PTR(getFlagValue)},
2773   {CC &quot;getObjectAtAddress&quot;,                           CC &quot;(J)&quot; OBJECT,                                                                      FN_PTR(getObjectAtAddress)},
2774   {CC &quot;getInterfaces&quot;,                                CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)[&quot; HS_RESOLVED_KLASS,                                      FN_PTR(getInterfaces)},
2775   {CC &quot;getComponentType&quot;,                             CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)&quot; HS_RESOLVED_TYPE,                                        FN_PTR(getComponentType)},
2776   {CC &quot;ensureInitialized&quot;,                            CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)V&quot;,                                                        FN_PTR(ensureInitialized)},
2777   {CC &quot;getIdentityHashCode&quot;,                          CC &quot;(&quot; OBJECTCONSTANT &quot;)I&quot;,                                                           FN_PTR(getIdentityHashCode)},
2778   {CC &quot;isInternedString&quot;,                             CC &quot;(&quot; OBJECTCONSTANT &quot;)Z&quot;,                                                           FN_PTR(isInternedString)},
2779   {CC &quot;unboxPrimitive&quot;,                               CC &quot;(&quot; OBJECTCONSTANT &quot;)&quot; OBJECT,                                                     FN_PTR(unboxPrimitive)},
2780   {CC &quot;boxPrimitive&quot;,                                 CC &quot;(&quot; OBJECT &quot;)&quot; OBJECTCONSTANT,                                                     FN_PTR(boxPrimitive)},
2781   {CC &quot;getDeclaredConstructors&quot;,                      CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)[&quot; RESOLVED_METHOD,                                        FN_PTR(getDeclaredConstructors)},
2782   {CC &quot;getDeclaredMethods&quot;,                           CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)[&quot; RESOLVED_METHOD,                                        FN_PTR(getDeclaredMethods)},
2783   {CC &quot;readFieldValue&quot;,                               CC &quot;(&quot; HS_RESOLVED_KLASS HS_RESOLVED_FIELD &quot;Z)&quot; JAVACONSTANT,                         FN_PTR(readFieldValue)},
2784   {CC &quot;readFieldValue&quot;,                               CC &quot;(&quot; OBJECTCONSTANT HS_RESOLVED_FIELD &quot;Z)&quot; JAVACONSTANT,                            FN_PTR(readFieldValue)},
2785   {CC &quot;isInstance&quot;,                                   CC &quot;(&quot; HS_RESOLVED_KLASS OBJECTCONSTANT &quot;)Z&quot;,                                         FN_PTR(isInstance)},
2786   {CC &quot;isAssignableFrom&quot;,                             CC &quot;(&quot; HS_RESOLVED_KLASS HS_RESOLVED_KLASS &quot;)Z&quot;,                                      FN_PTR(isAssignableFrom)},
2787   {CC &quot;isTrustedForIntrinsics&quot;,                       CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)Z&quot;,                                                        FN_PTR(isTrustedForIntrinsics)},
2788   {CC &quot;asJavaType&quot;,                                   CC &quot;(&quot; OBJECTCONSTANT &quot;)&quot; HS_RESOLVED_TYPE,                                           FN_PTR(asJavaType)},
2789   {CC &quot;asString&quot;,                                     CC &quot;(&quot; OBJECTCONSTANT &quot;)&quot; STRING,                                                     FN_PTR(asString)},
2790   {CC &quot;equals&quot;,                                       CC &quot;(&quot; OBJECTCONSTANT &quot;J&quot; OBJECTCONSTANT &quot;J)Z&quot;,                                       FN_PTR(equals)},
2791   {CC &quot;getJavaMirror&quot;,                                CC &quot;(&quot; HS_RESOLVED_TYPE &quot;)&quot; OBJECTCONSTANT,                                           FN_PTR(getJavaMirror)},
2792   {CC &quot;getArrayLength&quot;,                               CC &quot;(&quot; OBJECTCONSTANT &quot;)I&quot;,                                                           FN_PTR(getArrayLength)},
2793   {CC &quot;readArrayElement&quot;,                             CC &quot;(&quot; OBJECTCONSTANT &quot;I)Ljava/lang/Object;&quot;,                                         FN_PTR(readArrayElement)},
2794   {CC &quot;arrayBaseOffset&quot;,                              CC &quot;(Ljdk/vm/ci/meta/JavaKind;)I&quot;,                                                    FN_PTR(arrayBaseOffset)},
2795   {CC &quot;arrayIndexScale&quot;,                              CC &quot;(Ljdk/vm/ci/meta/JavaKind;)I&quot;,                                                    FN_PTR(arrayIndexScale)},
2796   {CC &quot;getByte&quot;,                                      CC &quot;(&quot; OBJECTCONSTANT &quot;J)B&quot;,                                                          FN_PTR(getByte)},
2797   {CC &quot;getShort&quot;,                                     CC &quot;(&quot; OBJECTCONSTANT &quot;J)S&quot;,                                                          FN_PTR(getShort)},
2798   {CC &quot;getInt&quot;,                                       CC &quot;(&quot; OBJECTCONSTANT &quot;J)I&quot;,                                                          FN_PTR(getInt)},
2799   {CC &quot;getLong&quot;,                                      CC &quot;(&quot; OBJECTCONSTANT &quot;J)J&quot;,                                                          FN_PTR(getLong)},
2800   {CC &quot;getObject&quot;,                                    CC &quot;(&quot; OBJECTCONSTANT &quot;J)&quot; OBJECTCONSTANT,                                            FN_PTR(getObject)},
2801   {CC &quot;deleteGlobalHandle&quot;,                           CC &quot;(J)V&quot;,                                                                            FN_PTR(deleteGlobalHandle)},
2802   {CC &quot;registerNativeMethods&quot;,                        CC &quot;(&quot; CLASS &quot;)[J&quot;,                                                                   FN_PTR(registerNativeMethods)},
2803   {CC &quot;isCurrentThreadAttached&quot;,                      CC &quot;()Z&quot;,                                                                             FN_PTR(isCurrentThreadAttached)},
2804   {CC &quot;getCurrentJavaThread&quot;,                         CC &quot;()J&quot;,                                                                             FN_PTR(getCurrentJavaThread)},
2805   {CC &quot;attachCurrentThread&quot;,                          CC &quot;(Z)Z&quot;,                                                                            FN_PTR(attachCurrentThread)},
2806   {CC &quot;detachCurrentThread&quot;,                          CC &quot;()V&quot;,                                                                             FN_PTR(detachCurrentThread)},
2807   {CC &quot;translate&quot;,                                    CC &quot;(&quot; OBJECT &quot;)J&quot;,                                                                   FN_PTR(translate)},
2808   {CC &quot;unhand&quot;,                                       CC &quot;(J)&quot; OBJECT,                                                                      FN_PTR(unhand)},
2809   {CC &quot;updateHotSpotNmethod&quot;,                         CC &quot;(&quot; HS_NMETHOD &quot;)V&quot;,                                                               FN_PTR(updateHotSpotNmethod)},
2810   {CC &quot;getCode&quot;,                                      CC &quot;(&quot; HS_INSTALLED_CODE &quot;)[B&quot;,                                                       FN_PTR(getCode)},
2811   {CC &quot;asReflectionExecutable&quot;,                       CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)&quot; REFLECTION_EXECUTABLE,                                  FN_PTR(asReflectionExecutable)},
2812   {CC &quot;asReflectionField&quot;,                            CC &quot;(&quot; HS_RESOLVED_KLASS &quot;I)&quot; REFLECTION_FIELD,                                       FN_PTR(asReflectionField)},
2813   {CC &quot;getFailedSpeculations&quot;,                        CC &quot;(J[[B)[[B&quot;,                                                                       FN_PTR(getFailedSpeculations)},
2814   {CC &quot;getFailedSpeculationsAddress&quot;,                 CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)J&quot;,                                                       FN_PTR(getFailedSpeculationsAddress)},
2815   {CC &quot;releaseFailedSpeculations&quot;,                    CC &quot;(J)V&quot;,                                                                            FN_PTR(releaseFailedSpeculations)},
2816   {CC &quot;addFailedSpeculation&quot;,                         CC &quot;(J[B)Z&quot;,                                                                          FN_PTR(addFailedSpeculation)},
2817   {CC &quot;callSystemExit&quot;,                               CC &quot;(I)V&quot;,                                                                            FN_PTR(callSystemExit)},
<a name="3" id="anc3"></a><span class="line-added">2818   {CC &quot;ticksNow&quot;,                                     CC &quot;()J&quot;,                                                                             FN_PTR(ticksNow)},</span>
<span class="line-added">2819   {CC &quot;registerCompilerPhases&quot;,                       CC &quot;([&quot; STRING &quot;)I&quot;,                                                                  FN_PTR(registerCompilerPhases)},</span>
<span class="line-added">2820   {CC &quot;notifyCompilerPhaseEvent&quot;,                     CC &quot;(JIII)V&quot;,                                                                         FN_PTR(notifyCompilerPhaseEvent)},</span>
<span class="line-added">2821   {CC &quot;notifyCompilerInliningEvent&quot;,                  CC &quot;(I&quot; HS_RESOLVED_METHOD HS_RESOLVED_METHOD &quot;ZLjava/lang/String;I)V&quot;,               FN_PTR(notifyCompilerInliningEvent)},</span>
2822 };
2823 
2824 int CompilerToVM::methods_count() {
2825   return sizeof(methods) / sizeof(JNINativeMethod);
2826 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/oops/methodData.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OOPS_METHODDATA_HPP
  26 #define SHARE_OOPS_METHODDATA_HPP
  27 
  28 #include &quot;interpreter/bytecodes.hpp&quot;
  29 #include &quot;oops/metadata.hpp&quot;
  30 #include &quot;oops/method.hpp&quot;
  31 #include &quot;oops/oop.hpp&quot;
  32 #include &quot;runtime/atomic.hpp&quot;
  33 #include &quot;utilities/align.hpp&quot;
  34 
  35 class BytecodeStream;
  36 
  37 // The MethodData object collects counts and other profile information
  38 // during zeroth-tier (interpretive) and first-tier execution.
  39 // The profile is used later by compilation heuristics.  Some heuristics
  40 // enable use of aggressive (or &quot;heroic&quot;) optimizations.  An aggressive
  41 // optimization often has a down-side, a corner case that it handles
  42 // poorly, but which is thought to be rare.  The profile provides
  43 // evidence of this rarity for a given method or even BCI.  It allows
  44 // the compiler to back out of the optimization at places where it
  45 // has historically been a poor choice.  Other heuristics try to use
  46 // specific information gathered about types observed at a given site.
  47 //
  48 // All data in the profile is approximate.  It is expected to be accurate
  49 // on the whole, but the system expects occasional inaccuraces, due to
  50 // counter overflow, multiprocessor races during data collection, space
  51 // limitations, missing MDO blocks, etc.  Bad or missing data will degrade
  52 // optimization quality but will not affect correctness.  Also, each MDO
  53 // is marked with its birth-date (&quot;creation_mileage&quot;) which can be used
  54 // to assess the quality (&quot;maturity&quot;) of its data.
  55 //
  56 // Short (&lt;32-bit) counters are designed to overflow to a known &quot;saturated&quot;
  57 // state.  Also, certain recorded per-BCI events are given one-bit counters
  58 // which overflow to a saturated state which applied to all counters at
  59 // that BCI.  In other words, there is a small lattice which approximates
  60 // the ideal of an infinite-precision counter for each event at each BCI,
  61 // and the lattice quickly &quot;bottoms out&quot; in a state where all counters
  62 // are taken to be indefinitely large.
  63 //
  64 // The reader will find many data races in profile gathering code, starting
  65 // with invocation counter incrementation.  None of these races harm correct
  66 // execution of the compiled code.
  67 
  68 // forward decl
  69 class ProfileData;
  70 
  71 // DataLayout
  72 //
  73 // Overlay for generic profiling data.
  74 class DataLayout {
  75   friend class VMStructs;
  76   friend class JVMCIVMStructs;
  77 
  78 private:
  79   // Every data layout begins with a header.  This header
  80   // contains a tag, which is used to indicate the size/layout
  81   // of the data, 8 bits of flags, which can be used in any way,
  82   // 32 bits of trap history (none/one reason/many reasons),
  83   // and a bci, which is used to tie this piece of data to a
  84   // specific bci in the bytecodes.
  85   union {
  86     u8 _bits;
  87     struct {
  88       u1 _tag;
  89       u1 _flags;
  90       u2 _bci;
  91       u4 _traps;
  92     } _struct;
  93   } _header;
  94 
  95   // The data layout has an arbitrary number of cells, each sized
  96   // to accomodate a pointer or an integer.
  97   intptr_t _cells[1];
  98 
  99   // Some types of data layouts need a length field.
 100   static bool needs_array_len(u1 tag);
 101 
 102 public:
 103   enum {
 104     counter_increment = 1
 105   };
 106 
 107   enum {
 108     cell_size = sizeof(intptr_t)
 109   };
 110 
 111   // Tag values
 112   enum {
 113     no_tag,
 114     bit_data_tag,
 115     counter_data_tag,
 116     jump_data_tag,
 117     receiver_type_data_tag,
 118     virtual_call_data_tag,
 119     ret_data_tag,
 120     branch_data_tag,
 121     multi_branch_data_tag,
 122     arg_info_data_tag,
 123     call_type_data_tag,
 124     virtual_call_type_data_tag,
 125     parameters_type_data_tag,
 126     speculative_trap_data_tag
 127   };
 128 
 129   enum {
 130     // The trap state breaks down as [recompile:1 | reason:31].
 131     // This further breakdown is defined in deoptimization.cpp.
 132     // See Deoptimization::trap_state_reason for an assert that
 133     // trap_bits is big enough to hold reasons &lt; Reason_RECORDED_LIMIT.
 134     //
 135     // The trap_state is collected only if ProfileTraps is true.
 136     trap_bits = 1+31,  // 31: enough to distinguish [0..Reason_RECORDED_LIMIT].
 137     trap_mask = -1,
 138     first_flag = 0
 139   };
 140 
 141   // Size computation
 142   static int header_size_in_bytes() {
 143     return header_size_in_cells() * cell_size;
 144   }
 145   static int header_size_in_cells() {
 146     return LP64_ONLY(1) NOT_LP64(2);
 147   }
 148 
 149   static int compute_size_in_bytes(int cell_count) {
 150     return header_size_in_bytes() + cell_count * cell_size;
 151   }
 152 
 153   // Initialization
 154   void initialize(u1 tag, u2 bci, int cell_count);
 155 
 156   // Accessors
 157   u1 tag() {
 158     return _header._struct._tag;
 159   }
 160 
 161   // Return 32 bits of trap state.
 162   // The state tells if traps with zero, one, or many reasons have occurred.
 163   // It also tells whether zero or many recompilations have occurred.
 164   // The associated trap histogram in the MDO itself tells whether
 165   // traps are common or not.  If a BCI shows that a trap X has
 166   // occurred, and the MDO shows N occurrences of X, we make the
 167   // simplifying assumption that all N occurrences can be blamed
 168   // on that BCI.
 169   uint trap_state() const {
 170     return _header._struct._traps;
 171   }
 172 
 173   void set_trap_state(uint new_state) {
 174     assert(ProfileTraps, &quot;used only under +ProfileTraps&quot;);
 175     uint old_flags = _header._struct._traps;
 176     _header._struct._traps = new_state | old_flags;
 177   }
 178 
 179   u1 flags() const {
 180     return _header._struct._flags;
 181   }
 182 
 183   u2 bci() const {
 184     return _header._struct._bci;
 185   }
 186 
 187   void set_header(u8 value) {
 188     _header._bits = value;
 189   }
 190   u8 header() {
 191     return _header._bits;
 192   }
 193   void set_cell_at(int index, intptr_t value) {
 194     _cells[index] = value;
 195   }
 196   void release_set_cell_at(int index, intptr_t value);
 197   intptr_t cell_at(int index) const {
 198     return _cells[index];
 199   }
 200 
 201   void set_flag_at(u1 flag_number) {
 202     _header._struct._flags |= (0x1 &lt;&lt; flag_number);
 203   }
 204   bool flag_at(u1 flag_number) const {
 205     return (_header._struct._flags &amp; (0x1 &lt;&lt; flag_number)) != 0;
 206   }
 207 
 208   // Low-level support for code generation.
 209   static ByteSize header_offset() {
 210     return byte_offset_of(DataLayout, _header);
 211   }
 212   static ByteSize tag_offset() {
 213     return byte_offset_of(DataLayout, _header._struct._tag);
 214   }
 215   static ByteSize flags_offset() {
 216     return byte_offset_of(DataLayout, _header._struct._flags);
 217   }
 218   static ByteSize bci_offset() {
 219     return byte_offset_of(DataLayout, _header._struct._bci);
 220   }
 221   static ByteSize cell_offset(int index) {
 222     return byte_offset_of(DataLayout, _cells) + in_ByteSize(index * cell_size);
 223   }
 224   // Return a value which, when or-ed as a byte into _flags, sets the flag.
 225   static u1 flag_number_to_constant(u1 flag_number) {
 226     DataLayout temp; temp.set_header(0);
 227     temp.set_flag_at(flag_number);
 228     return temp._header._struct._flags;
 229   }
 230   // Return a value which, when or-ed as a word into _header, sets the flag.
 231   static u8 flag_mask_to_header_mask(uint byte_constant) {
 232     DataLayout temp; temp.set_header(0);
 233     temp._header._struct._flags = byte_constant;
 234     return temp._header._bits;
 235   }
 236 
 237   ProfileData* data_in();
 238 
 239   // GC support
 240   void clean_weak_klass_links(bool always_clean);
 241 
 242   // Redefinition support
 243   void clean_weak_method_links();
 244   DEBUG_ONLY(void verify_clean_weak_method_links();)
 245 };
 246 
 247 
 248 // ProfileData class hierarchy
 249 class ProfileData;
 250 class   BitData;
 251 class     CounterData;
 252 class       ReceiverTypeData;
 253 class         VirtualCallData;
 254 class           VirtualCallTypeData;
 255 class       RetData;
 256 class       CallTypeData;
 257 class   JumpData;
 258 class     BranchData;
 259 class   ArrayData;
 260 class     MultiBranchData;
 261 class     ArgInfoData;
 262 class     ParametersTypeData;
 263 class   SpeculativeTrapData;
 264 
 265 // ProfileData
 266 //
 267 // A ProfileData object is created to refer to a section of profiling
 268 // data in a structured way.
 269 class ProfileData : public ResourceObj {
 270   friend class TypeEntries;
 271   friend class ReturnTypeEntry;
 272   friend class TypeStackSlotEntries;
 273 private:
 274   enum {
 275     tab_width_one = 16,
 276     tab_width_two = 36
 277   };
 278 
 279   // This is a pointer to a section of profiling data.
 280   DataLayout* _data;
 281 
 282   char* print_data_on_helper(const MethodData* md) const;
 283 
 284 protected:
 285   DataLayout* data() { return _data; }
 286   const DataLayout* data() const { return _data; }
 287 
 288   enum {
 289     cell_size = DataLayout::cell_size
 290   };
 291 
 292 public:
 293   // How many cells are in this?
 294   virtual int cell_count() const {
 295     ShouldNotReachHere();
 296     return -1;
 297   }
 298 
 299   // Return the size of this data.
 300   int size_in_bytes() {
 301     return DataLayout::compute_size_in_bytes(cell_count());
 302   }
 303 
 304 protected:
 305   // Low-level accessors for underlying data
 306   void set_intptr_at(int index, intptr_t value) {
 307     assert(0 &lt;= index &amp;&amp; index &lt; cell_count(), &quot;oob&quot;);
 308     data()-&gt;set_cell_at(index, value);
 309   }
 310   void release_set_intptr_at(int index, intptr_t value);
 311   intptr_t intptr_at(int index) const {
 312     assert(0 &lt;= index &amp;&amp; index &lt; cell_count(), &quot;oob&quot;);
 313     return data()-&gt;cell_at(index);
 314   }
 315   void set_uint_at(int index, uint value) {
 316     set_intptr_at(index, (intptr_t) value);
 317   }
 318   void release_set_uint_at(int index, uint value);
 319   uint uint_at(int index) const {
 320     return (uint)intptr_at(index);
 321   }
 322   void set_int_at(int index, int value) {
 323     set_intptr_at(index, (intptr_t) value);
 324   }
 325   void release_set_int_at(int index, int value);
 326   int int_at(int index) const {
 327     return (int)intptr_at(index);
 328   }
 329   int int_at_unchecked(int index) const {
 330     return (int)data()-&gt;cell_at(index);
 331   }
 332   void set_oop_at(int index, oop value) {
 333     set_intptr_at(index, cast_from_oop&lt;intptr_t&gt;(value));
 334   }
 335   oop oop_at(int index) const {
 336     return cast_to_oop(intptr_at(index));
 337   }
 338 
 339   void set_flag_at(int flag_number) {
 340     data()-&gt;set_flag_at(flag_number);
 341   }
 342   bool flag_at(int flag_number) const {
 343     return data()-&gt;flag_at(flag_number);
 344   }
 345 
 346   // two convenient imports for use by subclasses:
 347   static ByteSize cell_offset(int index) {
 348     return DataLayout::cell_offset(index);
 349   }
 350   static int flag_number_to_constant(int flag_number) {
 351     return DataLayout::flag_number_to_constant(flag_number);
 352   }
 353 
 354   ProfileData(DataLayout* data) {
 355     _data = data;
 356   }
 357 
 358 public:
 359   // Constructor for invalid ProfileData.
 360   ProfileData();
 361 
 362   u2 bci() const {
 363     return data()-&gt;bci();
 364   }
 365 
 366   address dp() {
 367     return (address)_data;
 368   }
 369 
 370   int trap_state() const {
 371     return data()-&gt;trap_state();
 372   }
 373   void set_trap_state(int new_state) {
 374     data()-&gt;set_trap_state(new_state);
 375   }
 376 
 377   // Type checking
 378   virtual bool is_BitData()         const { return false; }
 379   virtual bool is_CounterData()     const { return false; }
 380   virtual bool is_JumpData()        const { return false; }
 381   virtual bool is_ReceiverTypeData()const { return false; }
 382   virtual bool is_VirtualCallData() const { return false; }
 383   virtual bool is_RetData()         const { return false; }
 384   virtual bool is_BranchData()      const { return false; }
 385   virtual bool is_ArrayData()       const { return false; }
 386   virtual bool is_MultiBranchData() const { return false; }
 387   virtual bool is_ArgInfoData()     const { return false; }
 388   virtual bool is_CallTypeData()    const { return false; }
 389   virtual bool is_VirtualCallTypeData()const { return false; }
 390   virtual bool is_ParametersTypeData() const { return false; }
 391   virtual bool is_SpeculativeTrapData()const { return false; }
 392 
 393 
 394   BitData* as_BitData() const {
 395     assert(is_BitData(), &quot;wrong type&quot;);
 396     return is_BitData()         ? (BitData*)        this : NULL;
 397   }
 398   CounterData* as_CounterData() const {
 399     assert(is_CounterData(), &quot;wrong type&quot;);
 400     return is_CounterData()     ? (CounterData*)    this : NULL;
 401   }
 402   JumpData* as_JumpData() const {
 403     assert(is_JumpData(), &quot;wrong type&quot;);
 404     return is_JumpData()        ? (JumpData*)       this : NULL;
 405   }
 406   ReceiverTypeData* as_ReceiverTypeData() const {
 407     assert(is_ReceiverTypeData(), &quot;wrong type&quot;);
 408     return is_ReceiverTypeData() ? (ReceiverTypeData*)this : NULL;
 409   }
 410   VirtualCallData* as_VirtualCallData() const {
 411     assert(is_VirtualCallData(), &quot;wrong type&quot;);
 412     return is_VirtualCallData() ? (VirtualCallData*)this : NULL;
 413   }
 414   RetData* as_RetData() const {
 415     assert(is_RetData(), &quot;wrong type&quot;);
 416     return is_RetData()         ? (RetData*)        this : NULL;
 417   }
 418   BranchData* as_BranchData() const {
 419     assert(is_BranchData(), &quot;wrong type&quot;);
 420     return is_BranchData()      ? (BranchData*)     this : NULL;
 421   }
 422   ArrayData* as_ArrayData() const {
 423     assert(is_ArrayData(), &quot;wrong type&quot;);
 424     return is_ArrayData()       ? (ArrayData*)      this : NULL;
 425   }
 426   MultiBranchData* as_MultiBranchData() const {
 427     assert(is_MultiBranchData(), &quot;wrong type&quot;);
 428     return is_MultiBranchData() ? (MultiBranchData*)this : NULL;
 429   }
 430   ArgInfoData* as_ArgInfoData() const {
 431     assert(is_ArgInfoData(), &quot;wrong type&quot;);
 432     return is_ArgInfoData() ? (ArgInfoData*)this : NULL;
 433   }
 434   CallTypeData* as_CallTypeData() const {
 435     assert(is_CallTypeData(), &quot;wrong type&quot;);
 436     return is_CallTypeData() ? (CallTypeData*)this : NULL;
 437   }
 438   VirtualCallTypeData* as_VirtualCallTypeData() const {
 439     assert(is_VirtualCallTypeData(), &quot;wrong type&quot;);
 440     return is_VirtualCallTypeData() ? (VirtualCallTypeData*)this : NULL;
 441   }
 442   ParametersTypeData* as_ParametersTypeData() const {
 443     assert(is_ParametersTypeData(), &quot;wrong type&quot;);
 444     return is_ParametersTypeData() ? (ParametersTypeData*)this : NULL;
 445   }
 446   SpeculativeTrapData* as_SpeculativeTrapData() const {
 447     assert(is_SpeculativeTrapData(), &quot;wrong type&quot;);
 448     return is_SpeculativeTrapData() ? (SpeculativeTrapData*)this : NULL;
 449   }
 450 
 451 
 452   // Subclass specific initialization
 453   virtual void post_initialize(BytecodeStream* stream, MethodData* mdo) {}
 454 
 455   // GC support
 456   virtual void clean_weak_klass_links(bool always_clean) {}
 457 
 458   // Redefinition support
 459   virtual void clean_weak_method_links() {}
 460   DEBUG_ONLY(virtual void verify_clean_weak_method_links() {})
 461 
 462   // CI translation: ProfileData can represent both MethodDataOop data
 463   // as well as CIMethodData data. This function is provided for translating
 464   // an oop in a ProfileData to the ci equivalent. Generally speaking,
 465   // most ProfileData don&#39;t require any translation, so we provide the null
 466   // translation here, and the required translators are in the ci subclasses.
 467   virtual void translate_from(const ProfileData* data) {}
 468 
 469   virtual void print_data_on(outputStream* st, const char* extra = NULL) const {
 470     ShouldNotReachHere();
 471   }
 472 
 473   void print_data_on(outputStream* st, const MethodData* md) const;
 474 
 475   void print_shared(outputStream* st, const char* name, const char* extra) const;
 476   void tab(outputStream* st, bool first = false) const;
 477 };
 478 
 479 // BitData
 480 //
 481 // A BitData holds a flag or two in its header.
 482 class BitData : public ProfileData {
 483   friend class VMStructs;
 484   friend class JVMCIVMStructs;
 485 protected:
 486   enum {
 487     // null_seen:
 488     //  saw a null operand (cast/aastore/instanceof)
 489       null_seen_flag              = DataLayout::first_flag + 0
 490 #if INCLUDE_JVMCI
 491     // bytecode threw any exception
 492     , exception_seen_flag         = null_seen_flag + 1
 493 #endif
 494   };
 495   enum { bit_cell_count = 0 };  // no additional data fields needed.
 496 public:
 497   BitData(DataLayout* layout) : ProfileData(layout) {
 498   }
 499 
 500   virtual bool is_BitData() const { return true; }
 501 
 502   static int static_cell_count() {
 503     return bit_cell_count;
 504   }
 505 
 506   virtual int cell_count() const {
 507     return static_cell_count();
 508   }
 509 
 510   // Accessor
 511 
 512   // The null_seen flag bit is specially known to the interpreter.
 513   // Consulting it allows the compiler to avoid setting up null_check traps.
 514   bool null_seen()     { return flag_at(null_seen_flag); }
 515   void set_null_seen()    { set_flag_at(null_seen_flag); }
 516 
 517 #if INCLUDE_JVMCI
 518   // true if an exception was thrown at the specific BCI
 519   bool exception_seen() { return flag_at(exception_seen_flag); }
 520   void set_exception_seen() { set_flag_at(exception_seen_flag); }
 521 #endif
 522 
 523   // Code generation support
 524   static int null_seen_byte_constant() {
 525     return flag_number_to_constant(null_seen_flag);
 526   }
 527 
 528   static ByteSize bit_data_size() {
 529     return cell_offset(bit_cell_count);
 530   }
 531 
 532   void print_data_on(outputStream* st, const char* extra = NULL) const;
 533 };
 534 
 535 // CounterData
 536 //
 537 // A CounterData corresponds to a simple counter.
 538 class CounterData : public BitData {
 539   friend class VMStructs;
 540   friend class JVMCIVMStructs;
 541 protected:
 542   enum {
 543     count_off,
 544     counter_cell_count
 545   };
 546 public:
 547   CounterData(DataLayout* layout) : BitData(layout) {}
 548 
 549   virtual bool is_CounterData() const { return true; }
 550 
 551   static int static_cell_count() {
 552     return counter_cell_count;
 553   }
 554 
 555   virtual int cell_count() const {
 556     return static_cell_count();
 557   }
 558 
 559   // Direct accessor
 560   int count() const {
 561     intptr_t raw_data = intptr_at(count_off);
 562     if (raw_data &gt; max_jint) {
 563       raw_data = max_jint;
 564     } else if (raw_data &lt; min_jint) {
 565       raw_data = min_jint;
 566     }
 567     return int(raw_data);
 568   }
 569 
 570   // Code generation support
 571   static ByteSize count_offset() {
 572     return cell_offset(count_off);
 573   }
 574   static ByteSize counter_data_size() {
 575     return cell_offset(counter_cell_count);
 576   }
 577 
 578   void set_count(int count) {
 579     set_int_at(count_off, count);
 580   }
 581 
 582   void print_data_on(outputStream* st, const char* extra = NULL) const;
 583 };
 584 
 585 // JumpData
 586 //
 587 // A JumpData is used to access profiling information for a direct
 588 // branch.  It is a counter, used for counting the number of branches,
 589 // plus a data displacement, used for realigning the data pointer to
 590 // the corresponding target bci.
 591 class JumpData : public ProfileData {
 592   friend class VMStructs;
 593   friend class JVMCIVMStructs;
 594 protected:
 595   enum {
 596     taken_off_set,
 597     displacement_off_set,
 598     jump_cell_count
 599   };
 600 
 601   void set_displacement(int displacement) {
 602     set_int_at(displacement_off_set, displacement);
 603   }
 604 
 605 public:
 606   JumpData(DataLayout* layout) : ProfileData(layout) {
 607     assert(layout-&gt;tag() == DataLayout::jump_data_tag ||
 608       layout-&gt;tag() == DataLayout::branch_data_tag, &quot;wrong type&quot;);
 609   }
 610 
 611   virtual bool is_JumpData() const { return true; }
 612 
 613   static int static_cell_count() {
 614     return jump_cell_count;
 615   }
 616 
 617   virtual int cell_count() const {
 618     return static_cell_count();
 619   }
 620 
 621   // Direct accessor
 622   uint taken() const {
 623     return uint_at(taken_off_set);
 624   }
 625 
 626   void set_taken(uint cnt) {
 627     set_uint_at(taken_off_set, cnt);
 628   }
 629 
 630   // Saturating counter
 631   uint inc_taken() {
 632     uint cnt = taken() + 1;
 633     // Did we wrap? Will compiler screw us??
 634     if (cnt == 0) cnt--;
 635     set_uint_at(taken_off_set, cnt);
 636     return cnt;
 637   }
 638 
 639   int displacement() const {
 640     return int_at(displacement_off_set);
 641   }
 642 
 643   // Code generation support
 644   static ByteSize taken_offset() {
 645     return cell_offset(taken_off_set);
 646   }
 647 
 648   static ByteSize displacement_offset() {
 649     return cell_offset(displacement_off_set);
 650   }
 651 
 652   // Specific initialization.
 653   void post_initialize(BytecodeStream* stream, MethodData* mdo);
 654 
 655   void print_data_on(outputStream* st, const char* extra = NULL) const;
 656 };
 657 
 658 // Entries in a ProfileData object to record types: it can either be
 659 // none (no profile), unknown (conflicting profile data) or a klass if
 660 // a single one is seen. Whether a null reference was seen is also
 661 // recorded. No counter is associated with the type and a single type
 662 // is tracked (unlike VirtualCallData).
 663 class TypeEntries {
 664 
 665 public:
 666 
 667   // A single cell is used to record information for a type:
 668   // - the cell is initialized to 0
 669   // - when a type is discovered it is stored in the cell
 670   // - bit zero of the cell is used to record whether a null reference
 671   // was encountered or not
 672   // - bit 1 is set to record a conflict in the type information
 673 
 674   enum {
 675     null_seen = 1,
 676     type_mask = ~null_seen,
 677     type_unknown = 2,
 678     status_bits = null_seen | type_unknown,
 679     type_klass_mask = ~status_bits
 680   };
 681 
 682   // what to initialize a cell to
 683   static intptr_t type_none() {
 684     return 0;
 685   }
 686 
 687   // null seen = bit 0 set?
 688   static bool was_null_seen(intptr_t v) {
 689     return (v &amp; null_seen) != 0;
 690   }
 691 
 692   // conflicting type information = bit 1 set?
 693   static bool is_type_unknown(intptr_t v) {
 694     return (v &amp; type_unknown) != 0;
 695   }
 696 
 697   // not type information yet = all bits cleared, ignoring bit 0?
 698   static bool is_type_none(intptr_t v) {
 699     return (v &amp; type_mask) == 0;
 700   }
 701 
 702   // recorded type: cell without bit 0 and 1
 703   static intptr_t klass_part(intptr_t v) {
 704     intptr_t r = v &amp; type_klass_mask;
 705     return r;
 706   }
 707 
 708   // type recorded
 709   static Klass* valid_klass(intptr_t k) {
 710     if (!is_type_none(k) &amp;&amp;
 711         !is_type_unknown(k)) {
 712       Klass* res = (Klass*)klass_part(k);
 713       assert(res != NULL, &quot;invalid&quot;);
 714       return res;
 715     } else {
 716       return NULL;
 717     }
 718   }
 719 
 720   static intptr_t with_status(intptr_t k, intptr_t in) {
 721     return k | (in &amp; status_bits);
 722   }
 723 
 724   static intptr_t with_status(Klass* k, intptr_t in) {
 725     return with_status((intptr_t)k, in);
 726   }
 727 
 728   static void print_klass(outputStream* st, intptr_t k);
 729 
 730 protected:
 731   // ProfileData object these entries are part of
 732   ProfileData* _pd;
 733   // offset within the ProfileData object where the entries start
 734   const int _base_off;
 735 
 736   TypeEntries(int base_off)
 737     : _pd(NULL), _base_off(base_off) {}
 738 
 739   void set_intptr_at(int index, intptr_t value) {
 740     _pd-&gt;set_intptr_at(index, value);
 741   }
 742 
 743   intptr_t intptr_at(int index) const {
 744     return _pd-&gt;intptr_at(index);
 745   }
 746 
 747 public:
 748   void set_profile_data(ProfileData* pd) {
 749     _pd = pd;
 750   }
 751 };
 752 
 753 // Type entries used for arguments passed at a call and parameters on
 754 // method entry. 2 cells per entry: one for the type encoded as in
 755 // TypeEntries and one initialized with the stack slot where the
 756 // profiled object is to be found so that the interpreter can locate
 757 // it quickly.
 758 class TypeStackSlotEntries : public TypeEntries {
 759 
 760 private:
 761   enum {
 762     stack_slot_entry,
 763     type_entry,
 764     per_arg_cell_count
 765   };
 766 
 767   // offset of cell for stack slot for entry i within ProfileData object
 768   int stack_slot_offset(int i) const {
 769     return _base_off + stack_slot_local_offset(i);
 770   }
 771 
 772   const int _number_of_entries;
 773 
 774   // offset of cell for type for entry i within ProfileData object
 775   int type_offset_in_cells(int i) const {
 776     return _base_off + type_local_offset(i);
 777   }
 778 
 779 public:
 780 
 781   TypeStackSlotEntries(int base_off, int nb_entries)
 782     : TypeEntries(base_off), _number_of_entries(nb_entries) {}
 783 
 784   static int compute_cell_count(Symbol* signature, bool include_receiver, int max);
 785 
 786   void post_initialize(Symbol* signature, bool has_receiver, bool include_receiver);
 787 
 788   int number_of_entries() const { return _number_of_entries; }
 789 
 790   // offset of cell for stack slot for entry i within this block of cells for a TypeStackSlotEntries
 791   static int stack_slot_local_offset(int i) {
 792     return i * per_arg_cell_count + stack_slot_entry;
 793   }
 794 
 795   // offset of cell for type for entry i within this block of cells for a TypeStackSlotEntries
 796   static int type_local_offset(int i) {
 797     return i * per_arg_cell_count + type_entry;
 798   }
 799 
 800   // stack slot for entry i
 801   uint stack_slot(int i) const {
 802     assert(i &gt;= 0 &amp;&amp; i &lt; _number_of_entries, &quot;oob&quot;);
 803     return _pd-&gt;uint_at(stack_slot_offset(i));
 804   }
 805 
 806   // set stack slot for entry i
 807   void set_stack_slot(int i, uint num) {
 808     assert(i &gt;= 0 &amp;&amp; i &lt; _number_of_entries, &quot;oob&quot;);
 809     _pd-&gt;set_uint_at(stack_slot_offset(i), num);
 810   }
 811 
 812   // type for entry i
 813   intptr_t type(int i) const {
 814     assert(i &gt;= 0 &amp;&amp; i &lt; _number_of_entries, &quot;oob&quot;);
 815     return _pd-&gt;intptr_at(type_offset_in_cells(i));
 816   }
 817 
 818   // set type for entry i
 819   void set_type(int i, intptr_t k) {
 820     assert(i &gt;= 0 &amp;&amp; i &lt; _number_of_entries, &quot;oob&quot;);
 821     _pd-&gt;set_intptr_at(type_offset_in_cells(i), k);
 822   }
 823 
 824   static ByteSize per_arg_size() {
 825     return in_ByteSize(per_arg_cell_count * DataLayout::cell_size);
 826   }
 827 
 828   static int per_arg_count() {
 829     return per_arg_cell_count;
 830   }
 831 
 832   ByteSize type_offset(int i) const {
 833     return DataLayout::cell_offset(type_offset_in_cells(i));
 834   }
 835 
 836   // GC support
 837   void clean_weak_klass_links(bool always_clean);
 838 
 839   void print_data_on(outputStream* st) const;
 840 };
 841 
 842 // Type entry used for return from a call. A single cell to record the
 843 // type.
 844 class ReturnTypeEntry : public TypeEntries {
 845 
 846 private:
 847   enum {
 848     cell_count = 1
 849   };
 850 
 851 public:
 852   ReturnTypeEntry(int base_off)
 853     : TypeEntries(base_off) {}
 854 
 855   void post_initialize() {
 856     set_type(type_none());
 857   }
 858 
 859   intptr_t type() const {
 860     return _pd-&gt;intptr_at(_base_off);
 861   }
 862 
 863   void set_type(intptr_t k) {
 864     _pd-&gt;set_intptr_at(_base_off, k);
 865   }
 866 
 867   static int static_cell_count() {
 868     return cell_count;
 869   }
 870 
 871   static ByteSize size() {
 872     return in_ByteSize(cell_count * DataLayout::cell_size);
 873   }
 874 
 875   ByteSize type_offset() {
 876     return DataLayout::cell_offset(_base_off);
 877   }
 878 
 879   // GC support
 880   void clean_weak_klass_links(bool always_clean);
 881 
 882   void print_data_on(outputStream* st) const;
 883 };
 884 
 885 // Entries to collect type information at a call: contains arguments
 886 // (TypeStackSlotEntries), a return type (ReturnTypeEntry) and a
 887 // number of cells. Because the number of cells for the return type is
 888 // smaller than the number of cells for the type of an arguments, the
 889 // number of cells is used to tell how many arguments are profiled and
 890 // whether a return value is profiled. See has_arguments() and
 891 // has_return().
 892 class TypeEntriesAtCall {
 893 private:
 894   static int stack_slot_local_offset(int i) {
 895     return header_cell_count() + TypeStackSlotEntries::stack_slot_local_offset(i);
 896   }
 897 
 898   static int argument_type_local_offset(int i) {
 899     return header_cell_count() + TypeStackSlotEntries::type_local_offset(i);
 900   }
 901 
 902 public:
 903 
 904   static int header_cell_count() {
 905     return 1;
 906   }
 907 
 908   static int cell_count_local_offset() {
 909     return 0;
 910   }
 911 
 912   static int compute_cell_count(BytecodeStream* stream);
 913 
 914   static void initialize(DataLayout* dl, int base, int cell_count) {
 915     int off = base + cell_count_local_offset();
 916     dl-&gt;set_cell_at(off, cell_count - base - header_cell_count());
 917   }
 918 
 919   static bool arguments_profiling_enabled();
 920   static bool return_profiling_enabled();
 921 
 922   // Code generation support
 923   static ByteSize cell_count_offset() {
 924     return in_ByteSize(cell_count_local_offset() * DataLayout::cell_size);
 925   }
 926 
 927   static ByteSize args_data_offset() {
 928     return in_ByteSize(header_cell_count() * DataLayout::cell_size);
 929   }
 930 
 931   static ByteSize stack_slot_offset(int i) {
 932     return in_ByteSize(stack_slot_local_offset(i) * DataLayout::cell_size);
 933   }
 934 
 935   static ByteSize argument_type_offset(int i) {
 936     return in_ByteSize(argument_type_local_offset(i) * DataLayout::cell_size);
 937   }
 938 
 939   static ByteSize return_only_size() {
 940     return ReturnTypeEntry::size() + in_ByteSize(header_cell_count() * DataLayout::cell_size);
 941   }
 942 
 943 };
 944 
 945 // CallTypeData
 946 //
 947 // A CallTypeData is used to access profiling information about a non
 948 // virtual call for which we collect type information about arguments
 949 // and return value.
 950 class CallTypeData : public CounterData {
 951 private:
 952   // entries for arguments if any
 953   TypeStackSlotEntries _args;
 954   // entry for return type if any
 955   ReturnTypeEntry _ret;
 956 
 957   int cell_count_global_offset() const {
 958     return CounterData::static_cell_count() + TypeEntriesAtCall::cell_count_local_offset();
 959   }
 960 
 961   // number of cells not counting the header
 962   int cell_count_no_header() const {
 963     return uint_at(cell_count_global_offset());
 964   }
 965 
 966   void check_number_of_arguments(int total) {
 967     assert(number_of_arguments() == total, &quot;should be set in DataLayout::initialize&quot;);
 968   }
 969 
 970 public:
 971   CallTypeData(DataLayout* layout) :
 972     CounterData(layout),
 973     _args(CounterData::static_cell_count()+TypeEntriesAtCall::header_cell_count(), number_of_arguments()),
 974     _ret(cell_count() - ReturnTypeEntry::static_cell_count())
 975   {
 976     assert(layout-&gt;tag() == DataLayout::call_type_data_tag, &quot;wrong type&quot;);
 977     // Some compilers (VC++) don&#39;t want this passed in member initialization list
 978     _args.set_profile_data(this);
 979     _ret.set_profile_data(this);
 980   }
 981 
 982   const TypeStackSlotEntries* args() const {
 983     assert(has_arguments(), &quot;no profiling of arguments&quot;);
 984     return &amp;_args;
 985   }
 986 
 987   const ReturnTypeEntry* ret() const {
 988     assert(has_return(), &quot;no profiling of return value&quot;);
 989     return &amp;_ret;
 990   }
 991 
 992   virtual bool is_CallTypeData() const { return true; }
 993 
 994   static int static_cell_count() {
 995     return -1;
 996   }
 997 
 998   static int compute_cell_count(BytecodeStream* stream) {
 999     return CounterData::static_cell_count() + TypeEntriesAtCall::compute_cell_count(stream);
1000   }
1001 
1002   static void initialize(DataLayout* dl, int cell_count) {
1003     TypeEntriesAtCall::initialize(dl, CounterData::static_cell_count(), cell_count);
1004   }
1005 
1006   virtual void post_initialize(BytecodeStream* stream, MethodData* mdo);
1007 
1008   virtual int cell_count() const {
1009     return CounterData::static_cell_count() +
1010       TypeEntriesAtCall::header_cell_count() +
1011       int_at_unchecked(cell_count_global_offset());
1012   }
1013 
1014   int number_of_arguments() const {
1015     return cell_count_no_header() / TypeStackSlotEntries::per_arg_count();
1016   }
1017 
1018   void set_argument_type(int i, Klass* k) {
1019     assert(has_arguments(), &quot;no arguments!&quot;);
1020     intptr_t current = _args.type(i);
1021     _args.set_type(i, TypeEntries::with_status(k, current));
1022   }
1023 
1024   void set_return_type(Klass* k) {
1025     assert(has_return(), &quot;no return!&quot;);
1026     intptr_t current = _ret.type();
1027     _ret.set_type(TypeEntries::with_status(k, current));
1028   }
1029 
1030   // An entry for a return value takes less space than an entry for an
1031   // argument so if the number of cells exceeds the number of cells
1032   // needed for an argument, this object contains type information for
1033   // at least one argument.
1034   bool has_arguments() const {
1035     bool res = cell_count_no_header() &gt;= TypeStackSlotEntries::per_arg_count();
1036     assert (!res || TypeEntriesAtCall::arguments_profiling_enabled(), &quot;no profiling of arguments&quot;);
1037     return res;
1038   }
1039 
1040   // An entry for a return value takes less space than an entry for an
1041   // argument, so if the remainder of the number of cells divided by
1042   // the number of cells for an argument is not null, a return value
1043   // is profiled in this object.
1044   bool has_return() const {
1045     bool res = (cell_count_no_header() % TypeStackSlotEntries::per_arg_count()) != 0;
1046     assert (!res || TypeEntriesAtCall::return_profiling_enabled(), &quot;no profiling of return values&quot;);
1047     return res;
1048   }
1049 
1050   // Code generation support
1051   static ByteSize args_data_offset() {
1052     return cell_offset(CounterData::static_cell_count()) + TypeEntriesAtCall::args_data_offset();
1053   }
1054 
1055   ByteSize argument_type_offset(int i) {
1056     return _args.type_offset(i);
1057   }
1058 
1059   ByteSize return_type_offset() {
1060     return _ret.type_offset();
1061   }
1062 
1063   // GC support
1064   virtual void clean_weak_klass_links(bool always_clean) {
1065     if (has_arguments()) {
1066       _args.clean_weak_klass_links(always_clean);
1067     }
1068     if (has_return()) {
1069       _ret.clean_weak_klass_links(always_clean);
1070     }
1071   }
1072 
1073   virtual void print_data_on(outputStream* st, const char* extra = NULL) const;
1074 };
1075 
1076 // ReceiverTypeData
1077 //
1078 // A ReceiverTypeData is used to access profiling information about a
1079 // dynamic type check.  It consists of a counter which counts the total times
1080 // that the check is reached, and a series of (Klass*, count) pairs
1081 // which are used to store a type profile for the receiver of the check.
1082 class ReceiverTypeData : public CounterData {
1083   friend class VMStructs;
1084   friend class JVMCIVMStructs;
1085 protected:
1086   enum {
1087 #if INCLUDE_JVMCI
1088     // Description of the different counters
1089     // ReceiverTypeData for instanceof/checkcast/aastore:
1090     //   count is decremented for failed type checks
1091     //   JVMCI only: nonprofiled_count is incremented on type overflow
1092     // VirtualCallData for invokevirtual/invokeinterface:
1093     //   count is incremented on type overflow
1094     //   JVMCI only: nonprofiled_count is incremented on method overflow
1095 
1096     // JVMCI is interested in knowing the percentage of type checks involving a type not explicitly in the profile
1097     nonprofiled_count_off_set = counter_cell_count,
1098     receiver0_offset,
1099 #else
1100     receiver0_offset = counter_cell_count,
1101 #endif
1102     count0_offset,
1103     receiver_type_row_cell_count = (count0_offset + 1) - receiver0_offset
1104   };
1105 
1106 public:
1107   ReceiverTypeData(DataLayout* layout) : CounterData(layout) {
1108     assert(layout-&gt;tag() == DataLayout::receiver_type_data_tag ||
1109            layout-&gt;tag() == DataLayout::virtual_call_data_tag ||
1110            layout-&gt;tag() == DataLayout::virtual_call_type_data_tag, &quot;wrong type&quot;);
1111   }
1112 
1113   virtual bool is_ReceiverTypeData() const { return true; }
1114 
1115   static int static_cell_count() {
1116     return counter_cell_count + (uint) TypeProfileWidth * receiver_type_row_cell_count JVMCI_ONLY(+ 1);
1117   }
1118 
1119   virtual int cell_count() const {
1120     return static_cell_count();
1121   }
1122 
1123   // Direct accessors
1124   static uint row_limit() {
1125     return TypeProfileWidth;
1126   }
1127   static int receiver_cell_index(uint row) {
1128     return receiver0_offset + row * receiver_type_row_cell_count;
1129   }
1130   static int receiver_count_cell_index(uint row) {
1131     return count0_offset + row * receiver_type_row_cell_count;
1132   }
1133 
1134   Klass* receiver(uint row) const {
1135     assert(row &lt; row_limit(), &quot;oob&quot;);
1136 
1137     Klass* recv = (Klass*)intptr_at(receiver_cell_index(row));
1138     assert(recv == NULL || recv-&gt;is_klass(), &quot;wrong type&quot;);
1139     return recv;
1140   }
1141 
1142   void set_receiver(uint row, Klass* k) {
1143     assert((uint)row &lt; row_limit(), &quot;oob&quot;);
1144     set_intptr_at(receiver_cell_index(row), (uintptr_t)k);
1145   }
1146 
1147   uint receiver_count(uint row) const {
1148     assert(row &lt; row_limit(), &quot;oob&quot;);
1149     return uint_at(receiver_count_cell_index(row));
1150   }
1151 
1152   void set_receiver_count(uint row, uint count) {
1153     assert(row &lt; row_limit(), &quot;oob&quot;);
1154     set_uint_at(receiver_count_cell_index(row), count);
1155   }
1156 
1157   void clear_row(uint row) {
1158     assert(row &lt; row_limit(), &quot;oob&quot;);
1159     // Clear total count - indicator of polymorphic call site.
1160     // The site may look like as monomorphic after that but
1161     // it allow to have more accurate profiling information because
1162     // there was execution phase change since klasses were unloaded.
1163     // If the site is still polymorphic then MDO will be updated
1164     // to reflect it. But it could be the case that the site becomes
1165     // only bimorphic. Then keeping total count not 0 will be wrong.
1166     // Even if we use monomorphic (when it is not) for compilation
1167     // we will only have trap, deoptimization and recompile again
1168     // with updated MDO after executing method in Interpreter.
1169     // An additional receiver will be recorded in the cleaned row
1170     // during next call execution.
1171     //
1172     // Note: our profiling logic works with empty rows in any slot.
1173     // We do sorting a profiling info (ciCallProfile) for compilation.
1174     //
1175     set_count(0);
1176     set_receiver(row, NULL);
1177     set_receiver_count(row, 0);
1178 #if INCLUDE_JVMCI
1179     if (!this-&gt;is_VirtualCallData()) {
1180       // if this is a ReceiverTypeData for JVMCI, the nonprofiled_count
1181       // must also be reset (see &quot;Description of the different counters&quot; above)
1182       set_nonprofiled_count(0);
1183     }
1184 #endif
1185   }
1186 
1187   // Code generation support
1188   static ByteSize receiver_offset(uint row) {
1189     return cell_offset(receiver_cell_index(row));
1190   }
1191   static ByteSize receiver_count_offset(uint row) {
1192     return cell_offset(receiver_count_cell_index(row));
1193   }
1194 #if INCLUDE_JVMCI
1195   static ByteSize nonprofiled_receiver_count_offset() {
1196     return cell_offset(nonprofiled_count_off_set);
1197   }
1198   uint nonprofiled_count() const {
1199     return uint_at(nonprofiled_count_off_set);
1200   }
1201   void set_nonprofiled_count(uint count) {
1202     set_uint_at(nonprofiled_count_off_set, count);
1203   }
1204 #endif // INCLUDE_JVMCI
1205   static ByteSize receiver_type_data_size() {
1206     return cell_offset(static_cell_count());
1207   }
1208 
1209   // GC support
1210   virtual void clean_weak_klass_links(bool always_clean);
1211 
1212   void print_receiver_data_on(outputStream* st) const;
1213   void print_data_on(outputStream* st, const char* extra = NULL) const;
1214 };
1215 
1216 // VirtualCallData
1217 //
1218 // A VirtualCallData is used to access profiling information about a
1219 // virtual call.  For now, it has nothing more than a ReceiverTypeData.
1220 class VirtualCallData : public ReceiverTypeData {
1221 public:
1222   VirtualCallData(DataLayout* layout) : ReceiverTypeData(layout) {
1223     assert(layout-&gt;tag() == DataLayout::virtual_call_data_tag ||
1224            layout-&gt;tag() == DataLayout::virtual_call_type_data_tag, &quot;wrong type&quot;);
1225   }
1226 
1227   virtual bool is_VirtualCallData() const { return true; }
1228 
1229   static int static_cell_count() {
1230     // At this point we could add more profile state, e.g., for arguments.
1231     // But for now it&#39;s the same size as the base record type.
<a name="1" id="anc1"></a><span class="line-modified">1232     return ReceiverTypeData::static_cell_count();</span>
1233   }
1234 
1235   virtual int cell_count() const {
1236     return static_cell_count();
1237   }
1238 
1239   // Direct accessors
1240   static ByteSize virtual_call_data_size() {
1241     return cell_offset(static_cell_count());
1242   }
1243 
<a name="2" id="anc2"></a>






















































1244   void print_method_data_on(outputStream* st) const NOT_JVMCI_RETURN;
1245   void print_data_on(outputStream* st, const char* extra = NULL) const;
1246 };
1247 
1248 // VirtualCallTypeData
1249 //
1250 // A VirtualCallTypeData is used to access profiling information about
1251 // a virtual call for which we collect type information about
1252 // arguments and return value.
1253 class VirtualCallTypeData : public VirtualCallData {
1254 private:
1255   // entries for arguments if any
1256   TypeStackSlotEntries _args;
1257   // entry for return type if any
1258   ReturnTypeEntry _ret;
1259 
1260   int cell_count_global_offset() const {
1261     return VirtualCallData::static_cell_count() + TypeEntriesAtCall::cell_count_local_offset();
1262   }
1263 
1264   // number of cells not counting the header
1265   int cell_count_no_header() const {
1266     return uint_at(cell_count_global_offset());
1267   }
1268 
1269   void check_number_of_arguments(int total) {
1270     assert(number_of_arguments() == total, &quot;should be set in DataLayout::initialize&quot;);
1271   }
1272 
1273 public:
1274   VirtualCallTypeData(DataLayout* layout) :
1275     VirtualCallData(layout),
1276     _args(VirtualCallData::static_cell_count()+TypeEntriesAtCall::header_cell_count(), number_of_arguments()),
1277     _ret(cell_count() - ReturnTypeEntry::static_cell_count())
1278   {
1279     assert(layout-&gt;tag() == DataLayout::virtual_call_type_data_tag, &quot;wrong type&quot;);
1280     // Some compilers (VC++) don&#39;t want this passed in member initialization list
1281     _args.set_profile_data(this);
1282     _ret.set_profile_data(this);
1283   }
1284 
1285   const TypeStackSlotEntries* args() const {
1286     assert(has_arguments(), &quot;no profiling of arguments&quot;);
1287     return &amp;_args;
1288   }
1289 
1290   const ReturnTypeEntry* ret() const {
1291     assert(has_return(), &quot;no profiling of return value&quot;);
1292     return &amp;_ret;
1293   }
1294 
1295   virtual bool is_VirtualCallTypeData() const { return true; }
1296 
1297   static int static_cell_count() {
1298     return -1;
1299   }
1300 
1301   static int compute_cell_count(BytecodeStream* stream) {
1302     return VirtualCallData::static_cell_count() + TypeEntriesAtCall::compute_cell_count(stream);
1303   }
1304 
1305   static void initialize(DataLayout* dl, int cell_count) {
1306     TypeEntriesAtCall::initialize(dl, VirtualCallData::static_cell_count(), cell_count);
1307   }
1308 
1309   virtual void post_initialize(BytecodeStream* stream, MethodData* mdo);
1310 
1311   virtual int cell_count() const {
1312     return VirtualCallData::static_cell_count() +
1313       TypeEntriesAtCall::header_cell_count() +
1314       int_at_unchecked(cell_count_global_offset());
1315   }
1316 
1317   int number_of_arguments() const {
1318     return cell_count_no_header() / TypeStackSlotEntries::per_arg_count();
1319   }
1320 
1321   void set_argument_type(int i, Klass* k) {
1322     assert(has_arguments(), &quot;no arguments!&quot;);
1323     intptr_t current = _args.type(i);
1324     _args.set_type(i, TypeEntries::with_status(k, current));
1325   }
1326 
1327   void set_return_type(Klass* k) {
1328     assert(has_return(), &quot;no return!&quot;);
1329     intptr_t current = _ret.type();
1330     _ret.set_type(TypeEntries::with_status(k, current));
1331   }
1332 
1333   // An entry for a return value takes less space than an entry for an
1334   // argument, so if the remainder of the number of cells divided by
1335   // the number of cells for an argument is not null, a return value
1336   // is profiled in this object.
1337   bool has_return() const {
1338     bool res = (cell_count_no_header() % TypeStackSlotEntries::per_arg_count()) != 0;
1339     assert (!res || TypeEntriesAtCall::return_profiling_enabled(), &quot;no profiling of return values&quot;);
1340     return res;
1341   }
1342 
1343   // An entry for a return value takes less space than an entry for an
1344   // argument so if the number of cells exceeds the number of cells
1345   // needed for an argument, this object contains type information for
1346   // at least one argument.
1347   bool has_arguments() const {
1348     bool res = cell_count_no_header() &gt;= TypeStackSlotEntries::per_arg_count();
1349     assert (!res || TypeEntriesAtCall::arguments_profiling_enabled(), &quot;no profiling of arguments&quot;);
1350     return res;
1351   }
1352 
1353   // Code generation support
1354   static ByteSize args_data_offset() {
1355     return cell_offset(VirtualCallData::static_cell_count()) + TypeEntriesAtCall::args_data_offset();
1356   }
1357 
1358   ByteSize argument_type_offset(int i) {
1359     return _args.type_offset(i);
1360   }
1361 
1362   ByteSize return_type_offset() {
1363     return _ret.type_offset();
1364   }
1365 
1366   // GC support
1367   virtual void clean_weak_klass_links(bool always_clean) {
1368     ReceiverTypeData::clean_weak_klass_links(always_clean);
1369     if (has_arguments()) {
1370       _args.clean_weak_klass_links(always_clean);
1371     }
1372     if (has_return()) {
1373       _ret.clean_weak_klass_links(always_clean);
1374     }
1375   }
1376 
1377   virtual void print_data_on(outputStream* st, const char* extra = NULL) const;
1378 };
1379 
1380 // RetData
1381 //
1382 // A RetData is used to access profiling information for a ret bytecode.
1383 // It is composed of a count of the number of times that the ret has
1384 // been executed, followed by a series of triples of the form
1385 // (bci, count, di) which count the number of times that some bci was the
1386 // target of the ret and cache a corresponding data displacement.
1387 class RetData : public CounterData {
1388 protected:
1389   enum {
1390     bci0_offset = counter_cell_count,
1391     count0_offset,
1392     displacement0_offset,
1393     ret_row_cell_count = (displacement0_offset + 1) - bci0_offset
1394   };
1395 
1396   void set_bci(uint row, int bci) {
1397     assert((uint)row &lt; row_limit(), &quot;oob&quot;);
1398     set_int_at(bci0_offset + row * ret_row_cell_count, bci);
1399   }
1400   void release_set_bci(uint row, int bci);
1401   void set_bci_count(uint row, uint count) {
1402     assert((uint)row &lt; row_limit(), &quot;oob&quot;);
1403     set_uint_at(count0_offset + row * ret_row_cell_count, count);
1404   }
1405   void set_bci_displacement(uint row, int disp) {
1406     set_int_at(displacement0_offset + row * ret_row_cell_count, disp);
1407   }
1408 
1409 public:
1410   RetData(DataLayout* layout) : CounterData(layout) {
1411     assert(layout-&gt;tag() == DataLayout::ret_data_tag, &quot;wrong type&quot;);
1412   }
1413 
1414   virtual bool is_RetData() const { return true; }
1415 
1416   enum {
1417     no_bci = -1 // value of bci when bci1/2 are not in use.
1418   };
1419 
1420   static int static_cell_count() {
1421     return counter_cell_count + (uint) BciProfileWidth * ret_row_cell_count;
1422   }
1423 
1424   virtual int cell_count() const {
1425     return static_cell_count();
1426   }
1427 
1428   static uint row_limit() {
1429     return BciProfileWidth;
1430   }
1431   static int bci_cell_index(uint row) {
1432     return bci0_offset + row * ret_row_cell_count;
1433   }
1434   static int bci_count_cell_index(uint row) {
1435     return count0_offset + row * ret_row_cell_count;
1436   }
1437   static int bci_displacement_cell_index(uint row) {
1438     return displacement0_offset + row * ret_row_cell_count;
1439   }
1440 
1441   // Direct accessors
1442   int bci(uint row) const {
1443     return int_at(bci_cell_index(row));
1444   }
1445   uint bci_count(uint row) const {
1446     return uint_at(bci_count_cell_index(row));
1447   }
1448   int bci_displacement(uint row) const {
1449     return int_at(bci_displacement_cell_index(row));
1450   }
1451 
1452   // Interpreter Runtime support
1453   address fixup_ret(int return_bci, MethodData* mdo);
1454 
1455   // Code generation support
1456   static ByteSize bci_offset(uint row) {
1457     return cell_offset(bci_cell_index(row));
1458   }
1459   static ByteSize bci_count_offset(uint row) {
1460     return cell_offset(bci_count_cell_index(row));
1461   }
1462   static ByteSize bci_displacement_offset(uint row) {
1463     return cell_offset(bci_displacement_cell_index(row));
1464   }
1465 
1466   // Specific initialization.
1467   void post_initialize(BytecodeStream* stream, MethodData* mdo);
1468 
1469   void print_data_on(outputStream* st, const char* extra = NULL) const;
1470 };
1471 
1472 // BranchData
1473 //
1474 // A BranchData is used to access profiling data for a two-way branch.
1475 // It consists of taken and not_taken counts as well as a data displacement
1476 // for the taken case.
1477 class BranchData : public JumpData {
1478   friend class VMStructs;
1479   friend class JVMCIVMStructs;
1480 protected:
1481   enum {
1482     not_taken_off_set = jump_cell_count,
1483     branch_cell_count
1484   };
1485 
1486   void set_displacement(int displacement) {
1487     set_int_at(displacement_off_set, displacement);
1488   }
1489 
1490 public:
1491   BranchData(DataLayout* layout) : JumpData(layout) {
1492     assert(layout-&gt;tag() == DataLayout::branch_data_tag, &quot;wrong type&quot;);
1493   }
1494 
1495   virtual bool is_BranchData() const { return true; }
1496 
1497   static int static_cell_count() {
1498     return branch_cell_count;
1499   }
1500 
1501   virtual int cell_count() const {
1502     return static_cell_count();
1503   }
1504 
1505   // Direct accessor
1506   uint not_taken() const {
1507     return uint_at(not_taken_off_set);
1508   }
1509 
1510   void set_not_taken(uint cnt) {
1511     set_uint_at(not_taken_off_set, cnt);
1512   }
1513 
1514   uint inc_not_taken() {
1515     uint cnt = not_taken() + 1;
1516     // Did we wrap? Will compiler screw us??
1517     if (cnt == 0) cnt--;
1518     set_uint_at(not_taken_off_set, cnt);
1519     return cnt;
1520   }
1521 
1522   // Code generation support
1523   static ByteSize not_taken_offset() {
1524     return cell_offset(not_taken_off_set);
1525   }
1526   static ByteSize branch_data_size() {
1527     return cell_offset(branch_cell_count);
1528   }
1529 
1530   // Specific initialization.
1531   void post_initialize(BytecodeStream* stream, MethodData* mdo);
1532 
1533   void print_data_on(outputStream* st, const char* extra = NULL) const;
1534 };
1535 
1536 // ArrayData
1537 //
1538 // A ArrayData is a base class for accessing profiling data which does
1539 // not have a statically known size.  It consists of an array length
1540 // and an array start.
1541 class ArrayData : public ProfileData {
1542   friend class VMStructs;
1543   friend class JVMCIVMStructs;
1544 protected:
1545   friend class DataLayout;
1546 
1547   enum {
1548     array_len_off_set,
1549     array_start_off_set
1550   };
1551 
1552   uint array_uint_at(int index) const {
1553     int aindex = index + array_start_off_set;
1554     return uint_at(aindex);
1555   }
1556   int array_int_at(int index) const {
1557     int aindex = index + array_start_off_set;
1558     return int_at(aindex);
1559   }
1560   oop array_oop_at(int index) const {
1561     int aindex = index + array_start_off_set;
1562     return oop_at(aindex);
1563   }
1564   void array_set_int_at(int index, int value) {
1565     int aindex = index + array_start_off_set;
1566     set_int_at(aindex, value);
1567   }
1568 
1569   // Code generation support for subclasses.
1570   static ByteSize array_element_offset(int index) {
1571     return cell_offset(array_start_off_set + index);
1572   }
1573 
1574 public:
1575   ArrayData(DataLayout* layout) : ProfileData(layout) {}
1576 
1577   virtual bool is_ArrayData() const { return true; }
1578 
1579   static int static_cell_count() {
1580     return -1;
1581   }
1582 
1583   int array_len() const {
1584     return int_at_unchecked(array_len_off_set);
1585   }
1586 
1587   virtual int cell_count() const {
1588     return array_len() + 1;
1589   }
1590 
1591   // Code generation support
1592   static ByteSize array_len_offset() {
1593     return cell_offset(array_len_off_set);
1594   }
1595   static ByteSize array_start_offset() {
1596     return cell_offset(array_start_off_set);
1597   }
1598 };
1599 
1600 // MultiBranchData
1601 //
1602 // A MultiBranchData is used to access profiling information for
1603 // a multi-way branch (*switch bytecodes).  It consists of a series
1604 // of (count, displacement) pairs, which count the number of times each
1605 // case was taken and specify the data displacment for each branch target.
1606 class MultiBranchData : public ArrayData {
1607   friend class VMStructs;
1608   friend class JVMCIVMStructs;
1609 protected:
1610   enum {
1611     default_count_off_set,
1612     default_disaplacement_off_set,
1613     case_array_start
1614   };
1615   enum {
1616     relative_count_off_set,
1617     relative_displacement_off_set,
1618     per_case_cell_count
1619   };
1620 
1621   void set_default_displacement(int displacement) {
1622     array_set_int_at(default_disaplacement_off_set, displacement);
1623   }
1624   void set_displacement_at(int index, int displacement) {
1625     array_set_int_at(case_array_start +
1626                      index * per_case_cell_count +
1627                      relative_displacement_off_set,
1628                      displacement);
1629   }
1630 
1631 public:
1632   MultiBranchData(DataLayout* layout) : ArrayData(layout) {
1633     assert(layout-&gt;tag() == DataLayout::multi_branch_data_tag, &quot;wrong type&quot;);
1634   }
1635 
1636   virtual bool is_MultiBranchData() const { return true; }
1637 
1638   static int compute_cell_count(BytecodeStream* stream);
1639 
1640   int number_of_cases() const {
1641     int alen = array_len() - 2; // get rid of default case here.
1642     assert(alen % per_case_cell_count == 0, &quot;must be even&quot;);
1643     return (alen / per_case_cell_count);
1644   }
1645 
1646   uint default_count() const {
1647     return array_uint_at(default_count_off_set);
1648   }
1649   int default_displacement() const {
1650     return array_int_at(default_disaplacement_off_set);
1651   }
1652 
1653   uint count_at(int index) const {
1654     return array_uint_at(case_array_start +
1655                          index * per_case_cell_count +
1656                          relative_count_off_set);
1657   }
1658   int displacement_at(int index) const {
1659     return array_int_at(case_array_start +
1660                         index * per_case_cell_count +
1661                         relative_displacement_off_set);
1662   }
1663 
1664   // Code generation support
1665   static ByteSize default_count_offset() {
1666     return array_element_offset(default_count_off_set);
1667   }
1668   static ByteSize default_displacement_offset() {
1669     return array_element_offset(default_disaplacement_off_set);
1670   }
1671   static ByteSize case_count_offset(int index) {
1672     return case_array_offset() +
1673            (per_case_size() * index) +
1674            relative_count_offset();
1675   }
1676   static ByteSize case_array_offset() {
1677     return array_element_offset(case_array_start);
1678   }
1679   static ByteSize per_case_size() {
1680     return in_ByteSize(per_case_cell_count) * cell_size;
1681   }
1682   static ByteSize relative_count_offset() {
1683     return in_ByteSize(relative_count_off_set) * cell_size;
1684   }
1685   static ByteSize relative_displacement_offset() {
1686     return in_ByteSize(relative_displacement_off_set) * cell_size;
1687   }
1688 
1689   // Specific initialization.
1690   void post_initialize(BytecodeStream* stream, MethodData* mdo);
1691 
1692   void print_data_on(outputStream* st, const char* extra = NULL) const;
1693 };
1694 
1695 class ArgInfoData : public ArrayData {
1696 
1697 public:
1698   ArgInfoData(DataLayout* layout) : ArrayData(layout) {
1699     assert(layout-&gt;tag() == DataLayout::arg_info_data_tag, &quot;wrong type&quot;);
1700   }
1701 
1702   virtual bool is_ArgInfoData() const { return true; }
1703 
1704 
1705   int number_of_args() const {
1706     return array_len();
1707   }
1708 
1709   uint arg_modified(int arg) const {
1710     return array_uint_at(arg);
1711   }
1712 
1713   void set_arg_modified(int arg, uint val) {
1714     array_set_int_at(arg, val);
1715   }
1716 
1717   void print_data_on(outputStream* st, const char* extra = NULL) const;
1718 };
1719 
1720 // ParametersTypeData
1721 //
1722 // A ParametersTypeData is used to access profiling information about
1723 // types of parameters to a method
1724 class ParametersTypeData : public ArrayData {
1725 
1726 private:
1727   TypeStackSlotEntries _parameters;
1728 
1729   static int stack_slot_local_offset(int i) {
1730     assert_profiling_enabled();
1731     return array_start_off_set + TypeStackSlotEntries::stack_slot_local_offset(i);
1732   }
1733 
1734   static int type_local_offset(int i) {
1735     assert_profiling_enabled();
1736     return array_start_off_set + TypeStackSlotEntries::type_local_offset(i);
1737   }
1738 
1739   static bool profiling_enabled();
1740   static void assert_profiling_enabled() {
1741     assert(profiling_enabled(), &quot;method parameters profiling should be on&quot;);
1742   }
1743 
1744 public:
1745   ParametersTypeData(DataLayout* layout) : ArrayData(layout), _parameters(1, number_of_parameters()) {
1746     assert(layout-&gt;tag() == DataLayout::parameters_type_data_tag, &quot;wrong type&quot;);
1747     // Some compilers (VC++) don&#39;t want this passed in member initialization list
1748     _parameters.set_profile_data(this);
1749   }
1750 
1751   static int compute_cell_count(Method* m);
1752 
1753   virtual bool is_ParametersTypeData() const { return true; }
1754 
1755   virtual void post_initialize(BytecodeStream* stream, MethodData* mdo);
1756 
1757   int number_of_parameters() const {
1758     return array_len() / TypeStackSlotEntries::per_arg_count();
1759   }
1760 
1761   const TypeStackSlotEntries* parameters() const { return &amp;_parameters; }
1762 
1763   uint stack_slot(int i) const {
1764     return _parameters.stack_slot(i);
1765   }
1766 
1767   void set_type(int i, Klass* k) {
1768     intptr_t current = _parameters.type(i);
1769     _parameters.set_type(i, TypeEntries::with_status((intptr_t)k, current));
1770   }
1771 
1772   virtual void clean_weak_klass_links(bool always_clean) {
1773     _parameters.clean_weak_klass_links(always_clean);
1774   }
1775 
1776   virtual void print_data_on(outputStream* st, const char* extra = NULL) const;
1777 
1778   static ByteSize stack_slot_offset(int i) {
1779     return cell_offset(stack_slot_local_offset(i));
1780   }
1781 
1782   static ByteSize type_offset(int i) {
1783     return cell_offset(type_local_offset(i));
1784   }
1785 };
1786 
1787 // SpeculativeTrapData
1788 //
1789 // A SpeculativeTrapData is used to record traps due to type
1790 // speculation. It records the root of the compilation: that type
1791 // speculation is wrong in the context of one compilation (for
1792 // method1) doesn&#39;t mean it&#39;s wrong in the context of another one (for
1793 // method2). Type speculation could have more/different data in the
1794 // context of the compilation of method2 and it&#39;s worthwhile to try an
1795 // optimization that failed for compilation of method1 in the context
1796 // of compilation of method2.
1797 // Space for SpeculativeTrapData entries is allocated from the extra
1798 // data space in the MDO. If we run out of space, the trap data for
1799 // the ProfileData at that bci is updated.
1800 class SpeculativeTrapData : public ProfileData {
1801 protected:
1802   enum {
1803     speculative_trap_method,
1804 #ifndef _LP64
1805     // The size of the area for traps is a multiple of the header
1806     // size, 2 cells on 32 bits. Packed at the end of this area are
1807     // argument info entries (with tag
1808     // DataLayout::arg_info_data_tag). The logic in
1809     // MethodData::bci_to_extra_data() that guarantees traps don&#39;t
1810     // overflow over argument info entries assumes the size of a
1811     // SpeculativeTrapData is twice the header size. On 32 bits, a
1812     // SpeculativeTrapData must be 4 cells.
1813     padding,
1814 #endif
1815     speculative_trap_cell_count
1816   };
1817 public:
1818   SpeculativeTrapData(DataLayout* layout) : ProfileData(layout) {
1819     assert(layout-&gt;tag() == DataLayout::speculative_trap_data_tag, &quot;wrong type&quot;);
1820   }
1821 
1822   virtual bool is_SpeculativeTrapData() const { return true; }
1823 
1824   static int static_cell_count() {
1825     return speculative_trap_cell_count;
1826   }
1827 
1828   virtual int cell_count() const {
1829     return static_cell_count();
1830   }
1831 
1832   // Direct accessor
1833   Method* method() const {
1834     return (Method*)intptr_at(speculative_trap_method);
1835   }
1836 
1837   void set_method(Method* m) {
1838     assert(!m-&gt;is_old(), &quot;cannot add old methods&quot;);
1839     set_intptr_at(speculative_trap_method, (intptr_t)m);
1840   }
1841 
1842   static ByteSize method_offset() {
1843     return cell_offset(speculative_trap_method);
1844   }
1845 
1846   virtual void print_data_on(outputStream* st, const char* extra = NULL) const;
1847 };
1848 
1849 // MethodData*
1850 //
1851 // A MethodData* holds information which has been collected about
1852 // a method.  Its layout looks like this:
1853 //
1854 // -----------------------------
1855 // | header                    |
1856 // | klass                     |
1857 // -----------------------------
1858 // | method                    |
1859 // | size of the MethodData* |
1860 // -----------------------------
1861 // | Data entries...           |
1862 // |   (variable size)         |
1863 // |                           |
1864 // .                           .
1865 // .                           .
1866 // .                           .
1867 // |                           |
1868 // -----------------------------
1869 //
1870 // The data entry area is a heterogeneous array of DataLayouts. Each
1871 // DataLayout in the array corresponds to a specific bytecode in the
1872 // method.  The entries in the array are sorted by the corresponding
1873 // bytecode.  Access to the data is via resource-allocated ProfileData,
1874 // which point to the underlying blocks of DataLayout structures.
1875 //
1876 // During interpretation, if profiling in enabled, the interpreter
1877 // maintains a method data pointer (mdp), which points at the entry
1878 // in the array corresponding to the current bci.  In the course of
1879 // intepretation, when a bytecode is encountered that has profile data
1880 // associated with it, the entry pointed to by mdp is updated, then the
1881 // mdp is adjusted to point to the next appropriate DataLayout.  If mdp
1882 // is NULL to begin with, the interpreter assumes that the current method
1883 // is not (yet) being profiled.
1884 //
1885 // In MethodData* parlance, &quot;dp&quot; is a &quot;data pointer&quot;, the actual address
1886 // of a DataLayout element.  A &quot;di&quot; is a &quot;data index&quot;, the offset in bytes
1887 // from the base of the data entry array.  A &quot;displacement&quot; is the byte offset
1888 // in certain ProfileData objects that indicate the amount the mdp must be
1889 // adjusted in the event of a change in control flow.
1890 //
1891 
1892 class CleanExtraDataClosure : public StackObj {
1893 public:
1894   virtual bool is_live(Method* m) = 0;
1895 };
1896 
1897 
1898 #if INCLUDE_JVMCI
1899 // Encapsulates an encoded speculation reason. These are linked together in
1900 // a list that is atomically appended to during deoptimization. Entries are
1901 // never removed from the list.
1902 // @see jdk.vm.ci.hotspot.HotSpotSpeculationLog.HotSpotSpeculationEncoding
1903 class FailedSpeculation: public CHeapObj&lt;mtCompiler&gt; {
1904  private:
1905   // The length of HotSpotSpeculationEncoding.toByteArray(). The data itself
1906   // is an array embedded at the end of this object.
1907   int   _data_len;
1908 
1909   // Next entry in a linked list.
1910   FailedSpeculation* _next;
1911 
1912   FailedSpeculation(address data, int data_len);
1913 
1914   FailedSpeculation** next_adr() { return &amp;_next; }
1915 
1916   // Placement new operator for inlining the speculation data into
1917   // the FailedSpeculation object.
1918   void* operator new(size_t size, size_t fs_size) throw();
1919 
1920  public:
1921   char* data()         { return (char*)(((address) this) + sizeof(FailedSpeculation)); }
1922   int data_len() const { return _data_len; }
1923   FailedSpeculation* next() const { return _next; }
1924 
1925   // Atomically appends a speculation from nm to the list whose head is at (*failed_speculations_address).
1926   // Returns false if the FailedSpeculation object could not be allocated.
1927   static bool add_failed_speculation(nmethod* nm, FailedSpeculation** failed_speculations_address, address speculation, int speculation_len);
1928 
1929   // Frees all entries in the linked list whose head is at (*failed_speculations_address).
1930   static void free_failed_speculations(FailedSpeculation** failed_speculations_address);
1931 };
1932 #endif
1933 
1934 class MethodData : public Metadata {
1935   friend class VMStructs;
1936   friend class JVMCIVMStructs;
1937 private:
1938   friend class ProfileData;
1939   friend class TypeEntriesAtCall;
1940 
1941   // If you add a new field that points to any metaspace object, you
1942   // must add this field to MethodData::metaspace_pointers_do().
1943 
1944   // Back pointer to the Method*
1945   Method* _method;
1946 
1947   // Size of this oop in bytes
1948   int _size;
1949 
1950   // Cached hint for bci_to_dp and bci_to_data
1951   int _hint_di;
1952 
1953   Mutex _extra_data_lock;
1954 
1955   MethodData(const methodHandle&amp; method, int size, TRAPS);
1956 public:
1957   static MethodData* allocate(ClassLoaderData* loader_data, const methodHandle&amp; method, TRAPS);
1958   MethodData() : _extra_data_lock(Mutex::leaf, &quot;MDO extra data lock&quot;) {}; // For ciMethodData
1959 
1960   bool is_methodData() const volatile { return true; }
1961   void initialize();
1962 
1963   // Whole-method sticky bits and flags
1964   enum {
1965     _trap_hist_limit    = 25 JVMCI_ONLY(+5),   // decoupled from Deoptimization::Reason_LIMIT
1966     _trap_hist_mask     = max_jubyte,
1967     _extra_data_count   = 4     // extra DataLayout headers, for trap history
1968   }; // Public flag values
1969 private:
1970   uint _nof_decompiles;             // count of all nmethod removals
1971   uint _nof_overflow_recompiles;    // recompile count, excluding recomp. bits
1972   uint _nof_overflow_traps;         // trap count, excluding _trap_hist
1973   union {
1974     intptr_t _align;
1975     u1 _array[JVMCI_ONLY(2 *) _trap_hist_limit];
1976   } _trap_hist;
1977 
1978   // Support for interprocedural escape analysis, from Thomas Kotzmann.
1979   intx              _eflags;          // flags on escape information
1980   intx              _arg_local;       // bit set of non-escaping arguments
1981   intx              _arg_stack;       // bit set of stack-allocatable arguments
1982   intx              _arg_returned;    // bit set of returned arguments
1983 
1984   int _creation_mileage;              // method mileage at MDO creation
1985 
1986   // How many invocations has this MDO seen?
1987   // These counters are used to determine the exact age of MDO.
1988   // We need those because in tiered a method can be concurrently
1989   // executed at different levels.
1990   InvocationCounter _invocation_counter;
1991   // Same for backedges.
1992   InvocationCounter _backedge_counter;
1993   // Counter values at the time profiling started.
1994   int               _invocation_counter_start;
1995   int               _backedge_counter_start;
1996   uint              _tenure_traps;
1997   int               _invoke_mask;      // per-method Tier0InvokeNotifyFreqLog
1998   int               _backedge_mask;    // per-method Tier0BackedgeNotifyFreqLog
1999 
2000 #if INCLUDE_RTM_OPT
2001   // State of RTM code generation during compilation of the method
2002   int               _rtm_state;
2003 #endif
2004 
2005   // Number of loops and blocks is computed when compiling the first
2006   // time with C1. It is used to determine if method is trivial.
2007   short             _num_loops;
2008   short             _num_blocks;
2009   // Does this method contain anything worth profiling?
2010   enum WouldProfile {unknown, no_profile, profile};
2011   WouldProfile      _would_profile;
2012 
2013 #if INCLUDE_JVMCI
2014   // Support for HotSpotMethodData.setCompiledIRSize(int)
2015   int                _jvmci_ir_size;
2016   FailedSpeculation* _failed_speculations;
2017 #endif
2018 
2019   // Size of _data array in bytes.  (Excludes header and extra_data fields.)
2020   int _data_size;
2021 
2022   // data index for the area dedicated to parameters. -1 if no
2023   // parameter profiling.
2024   enum { no_parameters = -2, parameters_uninitialized = -1 };
2025   int _parameters_type_data_di;
2026 
2027   // Beginning of the data entries
2028   intptr_t _data[1];
2029 
2030   // Helper for size computation
2031   static int compute_data_size(BytecodeStream* stream);
2032   static int bytecode_cell_count(Bytecodes::Code code);
2033   static bool is_speculative_trap_bytecode(Bytecodes::Code code);
2034   enum { no_profile_data = -1, variable_cell_count = -2 };
2035 
2036   // Helper for initialization
2037   DataLayout* data_layout_at(int data_index) const {
2038     assert(data_index % sizeof(intptr_t) == 0, &quot;unaligned&quot;);
2039     return (DataLayout*) (((address)_data) + data_index);
2040   }
2041 
2042   // Initialize an individual data segment.  Returns the size of
2043   // the segment in bytes.
2044   int initialize_data(BytecodeStream* stream, int data_index);
2045 
2046   // Helper for data_at
2047   DataLayout* limit_data_position() const {
2048     return data_layout_at(_data_size);
2049   }
2050   bool out_of_bounds(int data_index) const {
2051     return data_index &gt;= data_size();
2052   }
2053 
2054   // Give each of the data entries a chance to perform specific
2055   // data initialization.
2056   void post_initialize(BytecodeStream* stream);
2057 
2058   // hint accessors
2059   int      hint_di() const  { return _hint_di; }
2060   void set_hint_di(int di)  {
2061     assert(!out_of_bounds(di), &quot;hint_di out of bounds&quot;);
2062     _hint_di = di;
2063   }
2064   ProfileData* data_before(int bci) {
2065     // avoid SEGV on this edge case
2066     if (data_size() == 0)
2067       return NULL;
2068     int hint = hint_di();
2069     if (data_layout_at(hint)-&gt;bci() &lt;= bci)
2070       return data_at(hint);
2071     return first_data();
2072   }
2073 
2074   // What is the index of the first data entry?
2075   int first_di() const { return 0; }
2076 
2077   ProfileData* bci_to_extra_data_helper(int bci, Method* m, DataLayout*&amp; dp, bool concurrent);
2078   // Find or create an extra ProfileData:
2079   ProfileData* bci_to_extra_data(int bci, Method* m, bool create_if_missing);
2080 
2081   // return the argument info cell
2082   ArgInfoData *arg_info();
2083 
2084   enum {
2085     no_type_profile = 0,
2086     type_profile_jsr292 = 1,
2087     type_profile_all = 2
2088   };
2089 
2090   static bool profile_jsr292(const methodHandle&amp; m, int bci);
2091   static bool profile_unsafe(const methodHandle&amp; m, int bci);
2092   static int profile_arguments_flag();
2093   static bool profile_all_arguments();
2094   static bool profile_arguments_for_invoke(const methodHandle&amp; m, int bci);
2095   static int profile_return_flag();
2096   static bool profile_all_return();
2097   static bool profile_return_for_invoke(const methodHandle&amp; m, int bci);
2098   static int profile_parameters_flag();
2099   static bool profile_parameters_jsr292_only();
2100   static bool profile_all_parameters();
2101 
2102   void clean_extra_data_helper(DataLayout* dp, int shift, bool reset = false);
2103   void verify_extra_data_clean(CleanExtraDataClosure* cl);
2104 
2105 public:
2106   void clean_extra_data(CleanExtraDataClosure* cl);
2107 
2108   static int header_size() {
2109     return sizeof(MethodData)/wordSize;
2110   }
2111 
2112   // Compute the size of a MethodData* before it is created.
2113   static int compute_allocation_size_in_bytes(const methodHandle&amp; method);
2114   static int compute_allocation_size_in_words(const methodHandle&amp; method);
2115   static int compute_extra_data_count(int data_size, int empty_bc_count, bool needs_speculative_traps);
2116 
2117   // Determine if a given bytecode can have profile information.
2118   static bool bytecode_has_profile(Bytecodes::Code code) {
2119     return bytecode_cell_count(code) != no_profile_data;
2120   }
2121 
2122   // reset into original state
2123   void init();
2124 
2125   // My size
2126   int size_in_bytes() const { return _size; }
2127   int size() const    { return align_metadata_size(align_up(_size, BytesPerWord)/BytesPerWord); }
2128 
2129   int      creation_mileage() const  { return _creation_mileage; }
2130   void set_creation_mileage(int x)   { _creation_mileage = x; }
2131 
2132   int invocation_count() {
2133     if (invocation_counter()-&gt;carry()) {
2134       return InvocationCounter::count_limit;
2135     }
2136     return invocation_counter()-&gt;count();
2137   }
2138   int backedge_count() {
2139     if (backedge_counter()-&gt;carry()) {
2140       return InvocationCounter::count_limit;
2141     }
2142     return backedge_counter()-&gt;count();
2143   }
2144 
2145   int invocation_count_start() {
2146     if (invocation_counter()-&gt;carry()) {
2147       return 0;
2148     }
2149     return _invocation_counter_start;
2150   }
2151 
2152   int backedge_count_start() {
2153     if (backedge_counter()-&gt;carry()) {
2154       return 0;
2155     }
2156     return _backedge_counter_start;
2157   }
2158 
2159   int invocation_count_delta() { return invocation_count() - invocation_count_start(); }
2160   int backedge_count_delta()   { return backedge_count()   - backedge_count_start();   }
2161 
2162   void reset_start_counters() {
2163     _invocation_counter_start = invocation_count();
2164     _backedge_counter_start = backedge_count();
2165   }
2166 
2167   InvocationCounter* invocation_counter()     { return &amp;_invocation_counter; }
2168   InvocationCounter* backedge_counter()       { return &amp;_backedge_counter;   }
2169 
2170 #if INCLUDE_JVMCI
2171   FailedSpeculation** get_failed_speculations_address() {
2172     return &amp;_failed_speculations;
2173   }
2174 #endif
2175 
2176 #if INCLUDE_RTM_OPT
2177   int rtm_state() const {
2178     return _rtm_state;
2179   }
2180   void set_rtm_state(RTMState rstate) {
2181     _rtm_state = (int)rstate;
2182   }
2183   void atomic_set_rtm_state(RTMState rstate) {
2184     Atomic::store(&amp;_rtm_state, (int)rstate);
2185   }
2186 
2187   static int rtm_state_offset_in_bytes() {
2188     return offset_of(MethodData, _rtm_state);
2189   }
2190 #endif
2191 
2192   void set_would_profile(bool p)              { _would_profile = p ? profile : no_profile; }
2193   bool would_profile() const                  { return _would_profile != no_profile; }
2194 
2195   int num_loops() const                       { return _num_loops;  }
2196   void set_num_loops(int n)                   { _num_loops = n;     }
2197   int num_blocks() const                      { return _num_blocks; }
2198   void set_num_blocks(int n)                  { _num_blocks = n;    }
2199 
2200   bool is_mature() const;  // consult mileage and ProfileMaturityPercentage
2201   static int mileage_of(Method* m);
2202 
2203   // Support for interprocedural escape analysis, from Thomas Kotzmann.
2204   enum EscapeFlag {
2205     estimated    = 1 &lt;&lt; 0,
2206     return_local = 1 &lt;&lt; 1,
2207     return_allocated = 1 &lt;&lt; 2,
2208     allocated_escapes = 1 &lt;&lt; 3,
2209     unknown_modified = 1 &lt;&lt; 4
2210   };
2211 
2212   intx eflags()                                  { return _eflags; }
2213   intx arg_local()                               { return _arg_local; }
2214   intx arg_stack()                               { return _arg_stack; }
2215   intx arg_returned()                            { return _arg_returned; }
2216   uint arg_modified(int a)                       { ArgInfoData *aid = arg_info();
2217                                                    assert(aid != NULL, &quot;arg_info must be not null&quot;);
2218                                                    assert(a &gt;= 0 &amp;&amp; a &lt; aid-&gt;number_of_args(), &quot;valid argument number&quot;);
2219                                                    return aid-&gt;arg_modified(a); }
2220 
2221   void set_eflags(intx v)                        { _eflags = v; }
2222   void set_arg_local(intx v)                     { _arg_local = v; }
2223   void set_arg_stack(intx v)                     { _arg_stack = v; }
2224   void set_arg_returned(intx v)                  { _arg_returned = v; }
2225   void set_arg_modified(int a, uint v)           { ArgInfoData *aid = arg_info();
2226                                                    assert(aid != NULL, &quot;arg_info must be not null&quot;);
2227                                                    assert(a &gt;= 0 &amp;&amp; a &lt; aid-&gt;number_of_args(), &quot;valid argument number&quot;);
2228                                                    aid-&gt;set_arg_modified(a, v); }
2229 
2230   void clear_escape_info()                       { _eflags = _arg_local = _arg_stack = _arg_returned = 0; }
2231 
2232   // Location and size of data area
2233   address data_base() const {
2234     return (address) _data;
2235   }
2236   int data_size() const {
2237     return _data_size;
2238   }
2239 
2240   int parameters_size_in_bytes() const {
2241     ParametersTypeData* param = parameters_type_data();
2242     return param == NULL ? 0 : param-&gt;size_in_bytes();
2243   }
2244 
2245   // Accessors
2246   Method* method() const { return _method; }
2247 
2248   // Get the data at an arbitrary (sort of) data index.
2249   ProfileData* data_at(int data_index) const;
2250 
2251   // Walk through the data in order.
2252   ProfileData* first_data() const { return data_at(first_di()); }
2253   ProfileData* next_data(ProfileData* current) const;
2254   bool is_valid(ProfileData* current) const { return current != NULL; }
2255 
2256   // Convert a dp (data pointer) to a di (data index).
2257   int dp_to_di(address dp) const {
2258     return dp - ((address)_data);
2259   }
2260 
2261   // bci to di/dp conversion.
2262   address bci_to_dp(int bci);
2263   int bci_to_di(int bci) {
2264     return dp_to_di(bci_to_dp(bci));
2265   }
2266 
2267   // Get the data at an arbitrary bci, or NULL if there is none.
2268   ProfileData* bci_to_data(int bci);
2269 
2270   // Same, but try to create an extra_data record if one is needed:
2271   ProfileData* allocate_bci_to_data(int bci, Method* m) {
2272     ProfileData* data = NULL;
2273     // If m not NULL, try to allocate a SpeculativeTrapData entry
2274     if (m == NULL) {
2275       data = bci_to_data(bci);
2276     }
2277     if (data != NULL) {
2278       return data;
2279     }
2280     data = bci_to_extra_data(bci, m, true);
2281     if (data != NULL) {
2282       return data;
2283     }
2284     // If SpeculativeTrapData allocation fails try to allocate a
2285     // regular entry
2286     data = bci_to_data(bci);
2287     if (data != NULL) {
2288       return data;
2289     }
2290     return bci_to_extra_data(bci, NULL, true);
2291   }
2292 
2293   // Add a handful of extra data records, for trap tracking.
2294   DataLayout* extra_data_base() const  { return limit_data_position(); }
2295   DataLayout* extra_data_limit() const { return (DataLayout*)((address)this + size_in_bytes()); }
2296   DataLayout* args_data_limit() const  { return (DataLayout*)((address)this + size_in_bytes() -
2297                                                               parameters_size_in_bytes()); }
2298   int extra_data_size() const          { return (address)extra_data_limit() - (address)extra_data_base(); }
2299   static DataLayout* next_extra(DataLayout* dp);
2300 
2301   // Return (uint)-1 for overflow.
2302   uint trap_count(int reason) const {
2303     assert((uint)reason &lt; JVMCI_ONLY(2*) _trap_hist_limit, &quot;oob&quot;);
2304     return (int)((_trap_hist._array[reason]+1) &amp; _trap_hist_mask) - 1;
2305   }
2306   // For loops:
2307   static uint trap_reason_limit() { return _trap_hist_limit; }
2308   static uint trap_count_limit()  { return _trap_hist_mask; }
2309   uint inc_trap_count(int reason) {
2310     // Count another trap, anywhere in this method.
2311     assert(reason &gt;= 0, &quot;must be single trap&quot;);
2312     assert((uint)reason &lt; JVMCI_ONLY(2*) _trap_hist_limit, &quot;oob&quot;);
2313     uint cnt1 = 1 + _trap_hist._array[reason];
2314     if ((cnt1 &amp; _trap_hist_mask) != 0) {  // if no counter overflow...
2315       _trap_hist._array[reason] = cnt1;
2316       return cnt1;
2317     } else {
2318       return _trap_hist_mask + (++_nof_overflow_traps);
2319     }
2320   }
2321 
2322   uint overflow_trap_count() const {
2323     return _nof_overflow_traps;
2324   }
2325   uint overflow_recompile_count() const {
2326     return _nof_overflow_recompiles;
2327   }
2328   void inc_overflow_recompile_count() {
2329     _nof_overflow_recompiles += 1;
2330   }
2331   uint decompile_count() const {
2332     return _nof_decompiles;
2333   }
2334   void inc_decompile_count() {
2335     _nof_decompiles += 1;
2336     if (decompile_count() &gt; (uint)PerMethodRecompilationCutoff) {
2337       method()-&gt;set_not_compilable(&quot;decompile_count &gt; PerMethodRecompilationCutoff&quot;, CompLevel_full_optimization);
2338     }
2339   }
2340   uint tenure_traps() const {
2341     return _tenure_traps;
2342   }
2343   void inc_tenure_traps() {
2344     _tenure_traps += 1;
2345   }
2346 
2347   // Return pointer to area dedicated to parameters in MDO
2348   ParametersTypeData* parameters_type_data() const {
2349     assert(_parameters_type_data_di != parameters_uninitialized, &quot;called too early&quot;);
2350     return _parameters_type_data_di != no_parameters ? data_layout_at(_parameters_type_data_di)-&gt;data_in()-&gt;as_ParametersTypeData() : NULL;
2351   }
2352 
2353   int parameters_type_data_di() const {
2354     assert(_parameters_type_data_di != parameters_uninitialized &amp;&amp; _parameters_type_data_di != no_parameters, &quot;no args type data&quot;);
2355     return _parameters_type_data_di;
2356   }
2357 
2358   // Support for code generation
2359   static ByteSize data_offset() {
2360     return byte_offset_of(MethodData, _data[0]);
2361   }
2362 
2363   static ByteSize trap_history_offset() {
2364     return byte_offset_of(MethodData, _trap_hist._array);
2365   }
2366 
2367   static ByteSize invocation_counter_offset() {
2368     return byte_offset_of(MethodData, _invocation_counter);
2369   }
2370 
2371   static ByteSize backedge_counter_offset() {
2372     return byte_offset_of(MethodData, _backedge_counter);
2373   }
2374 
2375   static ByteSize invoke_mask_offset() {
2376     return byte_offset_of(MethodData, _invoke_mask);
2377   }
2378 
2379   static ByteSize backedge_mask_offset() {
2380     return byte_offset_of(MethodData, _backedge_mask);
2381   }
2382 
2383   static ByteSize parameters_type_data_di_offset() {
2384     return byte_offset_of(MethodData, _parameters_type_data_di);
2385   }
2386 
2387   virtual void metaspace_pointers_do(MetaspaceClosure* iter);
2388   virtual MetaspaceObj::Type type() const { return MethodDataType; }
2389 
2390   // Deallocation support - no metaspace pointer fields to deallocate
2391   void deallocate_contents(ClassLoaderData* loader_data) {}
2392 
2393   // GC support
2394   void set_size(int object_size_in_bytes) { _size = object_size_in_bytes; }
2395 
2396   // Printing
2397   void print_on      (outputStream* st) const;
2398   void print_value_on(outputStream* st) const;
2399 
2400   // printing support for method data
2401   void print_data_on(outputStream* st) const;
2402 
2403   const char* internal_name() const { return &quot;{method data}&quot;; }
2404 
2405   // verification
2406   void verify_on(outputStream* st);
2407   void verify_data_on(outputStream* st);
2408 
2409   static bool profile_parameters_for_method(const methodHandle&amp; m);
2410   static bool profile_arguments();
2411   static bool profile_arguments_jsr292_only();
2412   static bool profile_return();
2413   static bool profile_parameters();
2414   static bool profile_return_jsr292_only();
2415 
2416   void clean_method_data(bool always_clean);
2417   void clean_weak_method_links();
2418   DEBUG_ONLY(void verify_clean_weak_method_links();)
2419   Mutex* extra_data_lock() { return &amp;_extra_data_lock; }
2420 };
2421 
2422 #endif // SHARE_OOPS_METHODDATA_HPP
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/interpreter/linkResolver.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="abstractInterpreter.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="linkResolver.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/interpreter/linkResolver.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 62,37 ***</span>
  // Implementation of CallInfo
  
  
  void CallInfo::set_static(Klass* resolved_klass, const methodHandle&amp; resolved_method, TRAPS) {
    int vtable_index = Method::nonvirtual_vtable_index;
<span class="line-modified">!   set_common(resolved_klass, resolved_klass, resolved_method, resolved_method, CallInfo::direct_call, vtable_index, CHECK);</span>
  }
  
  
  void CallInfo::set_interface(Klass* resolved_klass,
<span class="line-removed">-                              Klass* selected_klass,</span>
                               const methodHandle&amp; resolved_method,
                               const methodHandle&amp; selected_method,
                               int itable_index, TRAPS) {
    // This is only called for interface methods. If the resolved_method
    // comes from java/lang/Object, it can be the subject of a virtual call, so
    // we should pick the vtable index from the resolved method.
    // In that case, the caller must call set_virtual instead of set_interface.
    assert(resolved_method-&gt;method_holder()-&gt;is_interface(), &quot;&quot;);
    assert(itable_index == resolved_method()-&gt;itable_index(), &quot;&quot;);
<span class="line-modified">!   set_common(resolved_klass, selected_klass, resolved_method, selected_method, CallInfo::itable_call, itable_index, CHECK);</span>
  }
  
  void CallInfo::set_virtual(Klass* resolved_klass,
<span class="line-removed">-                            Klass* selected_klass,</span>
                             const methodHandle&amp; resolved_method,
                             const methodHandle&amp; selected_method,
                             int vtable_index, TRAPS) {
    assert(vtable_index &gt;= 0 || vtable_index == Method::nonvirtual_vtable_index, &quot;valid index&quot;);
    assert(vtable_index &lt; 0 || !resolved_method-&gt;has_vtable_index() || vtable_index == resolved_method-&gt;vtable_index(), &quot;&quot;);
    CallKind kind = (vtable_index &gt;= 0 &amp;&amp; !resolved_method-&gt;can_be_statically_bound() ? CallInfo::vtable_call : CallInfo::direct_call);
<span class="line-modified">!   set_common(resolved_klass, selected_klass, resolved_method, selected_method, kind, vtable_index, CHECK);</span>
    assert(!resolved_method-&gt;is_compiled_lambda_form(), &quot;these must be handled via an invokehandle call&quot;);
  }
  
  void CallInfo::set_handle(const methodHandle&amp; resolved_method,
                            Handle resolved_appendix, TRAPS) {
<span class="line-new-header">--- 62,35 ---</span>
  // Implementation of CallInfo
  
  
  void CallInfo::set_static(Klass* resolved_klass, const methodHandle&amp; resolved_method, TRAPS) {
    int vtable_index = Method::nonvirtual_vtable_index;
<span class="line-modified">!   set_common(resolved_klass, resolved_method, resolved_method, CallInfo::direct_call, vtable_index, CHECK);</span>
  }
  
  
  void CallInfo::set_interface(Klass* resolved_klass,
                               const methodHandle&amp; resolved_method,
                               const methodHandle&amp; selected_method,
                               int itable_index, TRAPS) {
    // This is only called for interface methods. If the resolved_method
    // comes from java/lang/Object, it can be the subject of a virtual call, so
    // we should pick the vtable index from the resolved method.
    // In that case, the caller must call set_virtual instead of set_interface.
    assert(resolved_method-&gt;method_holder()-&gt;is_interface(), &quot;&quot;);
    assert(itable_index == resolved_method()-&gt;itable_index(), &quot;&quot;);
<span class="line-modified">!   set_common(resolved_klass, resolved_method, selected_method, CallInfo::itable_call, itable_index, CHECK);</span>
  }
  
  void CallInfo::set_virtual(Klass* resolved_klass,
                             const methodHandle&amp; resolved_method,
                             const methodHandle&amp; selected_method,
                             int vtable_index, TRAPS) {
    assert(vtable_index &gt;= 0 || vtable_index == Method::nonvirtual_vtable_index, &quot;valid index&quot;);
    assert(vtable_index &lt; 0 || !resolved_method-&gt;has_vtable_index() || vtable_index == resolved_method-&gt;vtable_index(), &quot;&quot;);
    CallKind kind = (vtable_index &gt;= 0 &amp;&amp; !resolved_method-&gt;can_be_statically_bound() ? CallInfo::vtable_call : CallInfo::direct_call);
<span class="line-modified">!   set_common(resolved_klass, resolved_method, selected_method, kind, vtable_index, CHECK);</span>
    assert(!resolved_method-&gt;is_compiled_lambda_form(), &quot;these must be handled via an invokehandle call&quot;);
  }
  
  void CallInfo::set_handle(const methodHandle&amp; resolved_method,
                            Handle resolved_appendix, TRAPS) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 106,24 ***</span>
    assert(resolved_method-&gt;intrinsic_id() == vmIntrinsics::_invokeBasic ||
           resolved_method-&gt;is_compiled_lambda_form(),
           &quot;linkMethod must return one of these&quot;);
    int vtable_index = Method::nonvirtual_vtable_index;
    assert(!resolved_method-&gt;has_vtable_index(), &quot;&quot;);
<span class="line-modified">!   set_common(resolved_klass, resolved_klass, resolved_method, resolved_method, CallInfo::direct_call, vtable_index, CHECK);</span>
    _resolved_appendix = resolved_appendix;
  }
  
  void CallInfo::set_common(Klass* resolved_klass,
<span class="line-removed">-                           Klass* selected_klass,</span>
                            const methodHandle&amp; resolved_method,
                            const methodHandle&amp; selected_method,
                            CallKind kind,
                            int index,
                            TRAPS) {
    assert(resolved_method-&gt;signature() == selected_method-&gt;signature(), &quot;signatures must correspond&quot;);
    _resolved_klass  = resolved_klass;
<span class="line-removed">-   _selected_klass  = selected_klass;</span>
    _resolved_method = resolved_method;
    _selected_method = selected_method;
    _call_kind       = kind;
    _call_index      = index;
    _resolved_appendix = Handle();
<span class="line-new-header">--- 104,22 ---</span>
    assert(resolved_method-&gt;intrinsic_id() == vmIntrinsics::_invokeBasic ||
           resolved_method-&gt;is_compiled_lambda_form(),
           &quot;linkMethod must return one of these&quot;);
    int vtable_index = Method::nonvirtual_vtable_index;
    assert(!resolved_method-&gt;has_vtable_index(), &quot;&quot;);
<span class="line-modified">!   set_common(resolved_klass, resolved_method, resolved_method, CallInfo::direct_call, vtable_index, CHECK);</span>
    _resolved_appendix = resolved_appendix;
  }
  
  void CallInfo::set_common(Klass* resolved_klass,
                            const methodHandle&amp; resolved_method,
                            const methodHandle&amp; selected_method,
                            CallKind kind,
                            int index,
                            TRAPS) {
    assert(resolved_method-&gt;signature() == selected_method-&gt;signature(), &quot;signatures must correspond&quot;);
    _resolved_klass  = resolved_klass;
    _resolved_method = resolved_method;
    _selected_method = selected_method;
    _call_kind       = kind;
    _call_index      = index;
    _resolved_appendix = Handle();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 137,11 ***</span>
    Klass* resolved_method_holder = resolved_method-&gt;method_holder();
    if (resolved_klass == NULL) { // 2nd argument defaults to holder of 1st
      resolved_klass = resolved_method_holder;
    }
    _resolved_klass  = resolved_klass;
<span class="line-removed">-   _selected_klass  = resolved_klass;</span>
    _resolved_method = methodHandle(THREAD, resolved_method);
    _selected_method = methodHandle(THREAD, resolved_method);
    // classify:
    CallKind kind = CallInfo::unknown_kind;
    int index = resolved_method-&gt;vtable_index();
<span class="line-new-header">--- 133,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 275,23 ***</span>
  }
  #endif // PRODUCT
  //------------------------------------------------------------------------------------------------------------------------
  // Klass resolution
  
<span class="line-modified">! void LinkResolver::check_klass_accessability(Klass* ref_klass, Klass* sel_klass,</span>
<span class="line-removed">-                                              bool fold_type_to_class, TRAPS) {</span>
    Klass* base_klass = sel_klass;
<span class="line-modified">!   if (fold_type_to_class) {</span>
<span class="line-modified">!     if (sel_klass-&gt;is_objArray_klass()) {</span>
<span class="line-removed">-       base_klass = ObjArrayKlass::cast(sel_klass)-&gt;bottom_klass();</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     // The element type could be a typeArray - we only need the access</span>
<span class="line-removed">-     // check if it is a reference to another class.</span>
<span class="line-removed">-     if (!base_klass-&gt;is_instance_klass()) {</span>
<span class="line-removed">-       return;  // no relevant check to do</span>
<span class="line-removed">-     }</span>
    }
    Reflection::VerifyClassAccessResults vca_result =
      Reflection::verify_class_access(ref_klass, InstanceKlass::cast(base_klass), true);
    if (vca_result != Reflection::ACCESS_OK) {
      ResourceMark rm(THREAD);
      char* msg = Reflection::verify_class_access_msg(ref_klass,
<span class="line-new-header">--- 270,21 ---</span>
  }
  #endif // PRODUCT
  //------------------------------------------------------------------------------------------------------------------------
  // Klass resolution
  
<span class="line-modified">! void LinkResolver::check_klass_accessibility(Klass* ref_klass, Klass* sel_klass, TRAPS) {</span>
    Klass* base_klass = sel_klass;
<span class="line-modified">!   if (sel_klass-&gt;is_objArray_klass()) {</span>
<span class="line-modified">!     base_klass = ObjArrayKlass::cast(sel_klass)-&gt;bottom_klass();</span>
    }
<span class="line-added">+   // The element type could be a typeArray - we only need the access</span>
<span class="line-added">+   // check if it is a reference to another class.</span>
<span class="line-added">+   if (!base_klass-&gt;is_instance_klass()) {</span>
<span class="line-added">+     return;  // no relevant check to do</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    Reflection::VerifyClassAccessResults vca_result =
      Reflection::verify_class_access(ref_klass, InstanceKlass::cast(base_klass), true);
    if (vca_result != Reflection::ACCESS_OK) {
      ResourceMark rm(THREAD);
      char* msg = Reflection::verify_class_access_msg(ref_klass,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 984,14 ***</span>
      // A final field can be modified only
      // (1) by methods declared in the class declaring the field and
      // (2) by the &lt;clinit&gt; method (in case of a static field)
      //     or by the &lt;init&gt; method (in case of an instance field).
      if (is_put &amp;&amp; fd.access_flags().is_final()) {
<span class="line-removed">-       ResourceMark rm(THREAD);</span>
<span class="line-removed">-       stringStream ss;</span>
  
        if (sel_klass != current_klass) {
          ss.print(&quot;Update to %s final field %s.%s attempted from a different class (%s) than the field&#39;s declaring class&quot;,
                   is_static ? &quot;static&quot; : &quot;non-static&quot;, resolved_klass-&gt;external_name(), fd.name()-&gt;as_C_string(),
                  current_klass-&gt;external_name());
          THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), ss.as_string());
        }
<span class="line-new-header">--- 977,14 ---</span>
      // A final field can be modified only
      // (1) by methods declared in the class declaring the field and
      // (2) by the &lt;clinit&gt; method (in case of a static field)
      //     or by the &lt;init&gt; method (in case of an instance field).
      if (is_put &amp;&amp; fd.access_flags().is_final()) {
  
        if (sel_klass != current_klass) {
<span class="line-added">+         ResourceMark rm(THREAD);</span>
<span class="line-added">+         stringStream ss;</span>
          ss.print(&quot;Update to %s final field %s.%s attempted from a different class (%s) than the field&#39;s declaring class&quot;,
                   is_static ? &quot;static&quot; : &quot;non-static&quot;, resolved_klass-&gt;external_name(), fd.name()-&gt;as_C_string(),
                  current_klass-&gt;external_name());
          THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), ss.as_string());
        }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1005,10 ***</span>
<span class="line-new-header">--- 998,12 ---</span>
          bool is_initialized_instance_final_update = ((byte == Bytecodes::_putfield || byte == Bytecodes::_nofast_putfield) &amp;&amp;
                                                       !fd.is_static() &amp;&amp;
                                                       !m-&gt;is_object_initializer());
  
          if (is_initialized_static_final_update || is_initialized_instance_final_update) {
<span class="line-added">+           ResourceMark rm(THREAD);</span>
<span class="line-added">+           stringStream ss;</span>
            ss.print(&quot;Update to %s final field %s.%s attempted from a different method (%s) than the initializer method %s &quot;,
                     is_static ? &quot;static&quot; : &quot;non-static&quot;, resolved_klass-&gt;external_name(), fd.name()-&gt;as_C_string(),
                     m-&gt;name()-&gt;as_C_string(),
                     is_static ? &quot;&lt;clinit&gt;&quot; : &quot;&lt;init&gt;&quot;);
            THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), ss.as_string());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1393,11 ***</span>
      trace_method_resolution(&quot;invokevirtual selected method: receiver-class:&quot;,
                              recv_klass, resolved_klass, selected_method(),
                              false, vtable_index);
    }
    // setup result
<span class="line-modified">!   result.set_virtual(resolved_klass, recv_klass, resolved_method, selected_method, vtable_index, CHECK);</span>
  }
  
  void LinkResolver::resolve_interface_call(CallInfo&amp; result, Handle recv, Klass* recv_klass,
                                            const LinkInfo&amp; link_info,
                                            bool check_null_and_abstract, TRAPS) {
<span class="line-new-header">--- 1388,11 ---</span>
      trace_method_resolution(&quot;invokevirtual selected method: receiver-class:&quot;,
                              recv_klass, resolved_klass, selected_method(),
                              false, vtable_index);
    }
    // setup result
<span class="line-modified">!   result.set_virtual(resolved_klass, resolved_method, selected_method, vtable_index, CHECK);</span>
  }
  
  void LinkResolver::resolve_interface_call(CallInfo&amp; result, Handle recv, Klass* recv_klass,
                                            const LinkInfo&amp; link_info,
                                            bool check_null_and_abstract, TRAPS) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1489,25 ***</span>
    // setup result
    if (resolved_method-&gt;has_vtable_index()) {
      int vtable_index = resolved_method-&gt;vtable_index();
      log_develop_trace(itables)(&quot;  -- vtable index: %d&quot;, vtable_index);
      assert(vtable_index == selected_method-&gt;vtable_index(), &quot;sanity check&quot;);
<span class="line-modified">!     result.set_virtual(resolved_klass, recv_klass, resolved_method, selected_method, vtable_index, CHECK);</span>
    } else if (resolved_method-&gt;has_itable_index()) {
      int itable_index = resolved_method()-&gt;itable_index();
      log_develop_trace(itables)(&quot;  -- itable index: %d&quot;, itable_index);
<span class="line-modified">!     result.set_interface(resolved_klass, recv_klass, resolved_method, selected_method, itable_index, CHECK);</span>
    } else {
      int index = resolved_method-&gt;vtable_index();
      log_develop_trace(itables)(&quot;  -- non itable/vtable index: %d&quot;, index);
      assert(index == Method::nonvirtual_vtable_index, &quot;Oops hit another case!&quot;);
      assert(resolved_method()-&gt;is_private() ||
             (resolved_method()-&gt;is_final() &amp;&amp; resolved_method-&gt;method_holder() == SystemDictionary::Object_klass()),
             &quot;Should only have non-virtual invokeinterface for private or final-Object methods!&quot;);
      assert(resolved_method()-&gt;can_be_statically_bound(), &quot;Should only have non-virtual invokeinterface for statically bound methods!&quot;);
      // This sets up the nonvirtual form of &quot;virtual&quot; call (as needed for final and private methods)
<span class="line-modified">!     result.set_virtual(resolved_klass, resolved_klass, resolved_method, resolved_method, index, CHECK);</span>
    }
  }
  
  
  Method* LinkResolver::linktime_resolve_interface_method_or_null(
<span class="line-new-header">--- 1484,25 ---</span>
    // setup result
    if (resolved_method-&gt;has_vtable_index()) {
      int vtable_index = resolved_method-&gt;vtable_index();
      log_develop_trace(itables)(&quot;  -- vtable index: %d&quot;, vtable_index);
      assert(vtable_index == selected_method-&gt;vtable_index(), &quot;sanity check&quot;);
<span class="line-modified">!     result.set_virtual(resolved_klass, resolved_method, selected_method, vtable_index, CHECK);</span>
    } else if (resolved_method-&gt;has_itable_index()) {
      int itable_index = resolved_method()-&gt;itable_index();
      log_develop_trace(itables)(&quot;  -- itable index: %d&quot;, itable_index);
<span class="line-modified">!     result.set_interface(resolved_klass, resolved_method, selected_method, itable_index, CHECK);</span>
    } else {
      int index = resolved_method-&gt;vtable_index();
      log_develop_trace(itables)(&quot;  -- non itable/vtable index: %d&quot;, index);
      assert(index == Method::nonvirtual_vtable_index, &quot;Oops hit another case!&quot;);
      assert(resolved_method()-&gt;is_private() ||
             (resolved_method()-&gt;is_final() &amp;&amp; resolved_method-&gt;method_holder() == SystemDictionary::Object_klass()),
             &quot;Should only have non-virtual invokeinterface for private or final-Object methods!&quot;);
      assert(resolved_method()-&gt;can_be_statically_bound(), &quot;Should only have non-virtual invokeinterface for statically bound methods!&quot;);
      // This sets up the nonvirtual form of &quot;virtual&quot; call (as needed for final and private methods)
<span class="line-modified">!     result.set_virtual(resolved_klass, resolved_method, resolved_method, index, CHECK);</span>
    }
  }
  
  
  Method* LinkResolver::linktime_resolve_interface_method_or_null(
</pre>
<center><a href="abstractInterpreter.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="linkResolver.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
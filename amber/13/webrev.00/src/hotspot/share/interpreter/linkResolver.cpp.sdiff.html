<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/interpreter/linkResolver.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="abstractInterpreter.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="linkResolver.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/interpreter/linkResolver.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
  47 #include &quot;oops/objArrayKlass.hpp&quot;
  48 #include &quot;oops/objArrayOop.hpp&quot;
  49 #include &quot;oops/oop.inline.hpp&quot;
  50 #include &quot;prims/methodHandles.hpp&quot;
  51 #include &quot;prims/nativeLookup.hpp&quot;
  52 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  53 #include &quot;runtime/frame.inline.hpp&quot;
  54 #include &quot;runtime/handles.inline.hpp&quot;
  55 #include &quot;runtime/reflection.hpp&quot;
  56 #include &quot;runtime/safepointVerifiers.hpp&quot;
  57 #include &quot;runtime/signature.hpp&quot;
  58 #include &quot;runtime/thread.inline.hpp&quot;
  59 #include &quot;runtime/vmThread.hpp&quot;
  60 
  61 //------------------------------------------------------------------------------------------------------------------------
  62 // Implementation of CallInfo
  63 
  64 
  65 void CallInfo::set_static(Klass* resolved_klass, const methodHandle&amp; resolved_method, TRAPS) {
  66   int vtable_index = Method::nonvirtual_vtable_index;
<span class="line-modified">  67   set_common(resolved_klass, resolved_klass, resolved_method, resolved_method, CallInfo::direct_call, vtable_index, CHECK);</span>
  68 }
  69 
  70 
  71 void CallInfo::set_interface(Klass* resolved_klass,
<span class="line-removed">  72                              Klass* selected_klass,</span>
  73                              const methodHandle&amp; resolved_method,
  74                              const methodHandle&amp; selected_method,
  75                              int itable_index, TRAPS) {
  76   // This is only called for interface methods. If the resolved_method
  77   // comes from java/lang/Object, it can be the subject of a virtual call, so
  78   // we should pick the vtable index from the resolved method.
  79   // In that case, the caller must call set_virtual instead of set_interface.
  80   assert(resolved_method-&gt;method_holder()-&gt;is_interface(), &quot;&quot;);
  81   assert(itable_index == resolved_method()-&gt;itable_index(), &quot;&quot;);
<span class="line-modified">  82   set_common(resolved_klass, selected_klass, resolved_method, selected_method, CallInfo::itable_call, itable_index, CHECK);</span>
  83 }
  84 
  85 void CallInfo::set_virtual(Klass* resolved_klass,
<span class="line-removed">  86                            Klass* selected_klass,</span>
  87                            const methodHandle&amp; resolved_method,
  88                            const methodHandle&amp; selected_method,
  89                            int vtable_index, TRAPS) {
  90   assert(vtable_index &gt;= 0 || vtable_index == Method::nonvirtual_vtable_index, &quot;valid index&quot;);
  91   assert(vtable_index &lt; 0 || !resolved_method-&gt;has_vtable_index() || vtable_index == resolved_method-&gt;vtable_index(), &quot;&quot;);
  92   CallKind kind = (vtable_index &gt;= 0 &amp;&amp; !resolved_method-&gt;can_be_statically_bound() ? CallInfo::vtable_call : CallInfo::direct_call);
<span class="line-modified">  93   set_common(resolved_klass, selected_klass, resolved_method, selected_method, kind, vtable_index, CHECK);</span>
  94   assert(!resolved_method-&gt;is_compiled_lambda_form(), &quot;these must be handled via an invokehandle call&quot;);
  95 }
  96 
  97 void CallInfo::set_handle(const methodHandle&amp; resolved_method,
  98                           Handle resolved_appendix, TRAPS) {
  99   set_handle(SystemDictionary::MethodHandle_klass(), resolved_method, resolved_appendix, CHECK);
 100 }
 101 
 102 void CallInfo::set_handle(Klass* resolved_klass,
 103                           const methodHandle&amp; resolved_method,
 104                           Handle resolved_appendix, TRAPS) {
 105   guarantee(resolved_method.not_null(), &quot;resolved method is null&quot;);
 106   assert(resolved_method-&gt;intrinsic_id() == vmIntrinsics::_invokeBasic ||
 107          resolved_method-&gt;is_compiled_lambda_form(),
 108          &quot;linkMethod must return one of these&quot;);
 109   int vtable_index = Method::nonvirtual_vtable_index;
 110   assert(!resolved_method-&gt;has_vtable_index(), &quot;&quot;);
<span class="line-modified"> 111   set_common(resolved_klass, resolved_klass, resolved_method, resolved_method, CallInfo::direct_call, vtable_index, CHECK);</span>
 112   _resolved_appendix = resolved_appendix;
 113 }
 114 
 115 void CallInfo::set_common(Klass* resolved_klass,
<span class="line-removed"> 116                           Klass* selected_klass,</span>
 117                           const methodHandle&amp; resolved_method,
 118                           const methodHandle&amp; selected_method,
 119                           CallKind kind,
 120                           int index,
 121                           TRAPS) {
 122   assert(resolved_method-&gt;signature() == selected_method-&gt;signature(), &quot;signatures must correspond&quot;);
 123   _resolved_klass  = resolved_klass;
<span class="line-removed"> 124   _selected_klass  = selected_klass;</span>
 125   _resolved_method = resolved_method;
 126   _selected_method = selected_method;
 127   _call_kind       = kind;
 128   _call_index      = index;
 129   _resolved_appendix = Handle();
 130   DEBUG_ONLY(verify());  // verify before making side effects
 131 
 132   CompilationPolicy::compile_if_required(selected_method, THREAD);
 133 }
 134 
 135 // utility query for unreflecting a method
 136 CallInfo::CallInfo(Method* resolved_method, Klass* resolved_klass, TRAPS) {
 137   Klass* resolved_method_holder = resolved_method-&gt;method_holder();
 138   if (resolved_klass == NULL) { // 2nd argument defaults to holder of 1st
 139     resolved_klass = resolved_method_holder;
 140   }
 141   _resolved_klass  = resolved_klass;
<span class="line-removed"> 142   _selected_klass  = resolved_klass;</span>
 143   _resolved_method = methodHandle(THREAD, resolved_method);
 144   _selected_method = methodHandle(THREAD, resolved_method);
 145   // classify:
 146   CallKind kind = CallInfo::unknown_kind;
 147   int index = resolved_method-&gt;vtable_index();
 148   if (resolved_method-&gt;can_be_statically_bound()) {
 149     kind = CallInfo::direct_call;
 150   } else if (!resolved_method_holder-&gt;is_interface()) {
 151     // Could be an Object method inherited into an interface, but still a vtable call.
 152     kind = CallInfo::vtable_call;
 153   } else if (!resolved_klass-&gt;is_interface()) {
 154     // A default or miranda method.  Compute the vtable index.
 155     index = LinkResolver::vtable_index_of_interface_method(resolved_klass,
 156                            _resolved_method);
 157     assert(index &gt;= 0 , &quot;we should have valid vtable index at this point&quot;);
 158 
 159     kind = CallInfo::vtable_call;
 160   } else if (resolved_method-&gt;has_vtable_index()) {
 161     // Can occur if an interface redeclares a method of Object.
 162 
</pre>
<hr />
<pre>
 260   _current_method = methodHandle();
 261 
 262   // Coming from the constant pool always checks access
 263   _check_access  = true;
 264 }
 265 
 266 #ifndef PRODUCT
 267 void LinkInfo::print() {
 268   ResourceMark rm;
 269   tty-&gt;print_cr(&quot;Link resolved_klass=%s name=%s signature=%s current_klass=%s check_access=%s&quot;,
 270                 _resolved_klass-&gt;name()-&gt;as_C_string(),
 271                 _name-&gt;as_C_string(),
 272                 _signature-&gt;as_C_string(),
 273                 _current_klass == NULL ? &quot;(none)&quot; : _current_klass-&gt;name()-&gt;as_C_string(),
 274                 _check_access ? &quot;true&quot; : &quot;false&quot;);
 275 }
 276 #endif // PRODUCT
 277 //------------------------------------------------------------------------------------------------------------------------
 278 // Klass resolution
 279 
<span class="line-modified"> 280 void LinkResolver::check_klass_accessability(Klass* ref_klass, Klass* sel_klass,</span>
<span class="line-removed"> 281                                              bool fold_type_to_class, TRAPS) {</span>
 282   Klass* base_klass = sel_klass;
<span class="line-modified"> 283   if (fold_type_to_class) {</span>
<span class="line-modified"> 284     if (sel_klass-&gt;is_objArray_klass()) {</span>
<span class="line-removed"> 285       base_klass = ObjArrayKlass::cast(sel_klass)-&gt;bottom_klass();</span>
<span class="line-removed"> 286     }</span>
<span class="line-removed"> 287     // The element type could be a typeArray - we only need the access</span>
<span class="line-removed"> 288     // check if it is a reference to another class.</span>
<span class="line-removed"> 289     if (!base_klass-&gt;is_instance_klass()) {</span>
<span class="line-removed"> 290       return;  // no relevant check to do</span>
<span class="line-removed"> 291     }</span>
 292   }






 293   Reflection::VerifyClassAccessResults vca_result =
 294     Reflection::verify_class_access(ref_klass, InstanceKlass::cast(base_klass), true);
 295   if (vca_result != Reflection::ACCESS_OK) {
 296     ResourceMark rm(THREAD);
 297     char* msg = Reflection::verify_class_access_msg(ref_klass,
 298                                                     InstanceKlass::cast(base_klass),
 299                                                     vca_result);
 300     bool same_module = (base_klass-&gt;module() == ref_klass-&gt;module());
 301     if (msg == NULL) {
 302       Exceptions::fthrow(
 303         THREAD_AND_LOCATION,
 304         vmSymbols::java_lang_IllegalAccessError(),
 305         &quot;failed to access class %s from class %s (%s%s%s)&quot;,
 306         base_klass-&gt;external_name(),
 307         ref_klass-&gt;external_name(),
 308         (same_module) ? base_klass-&gt;joint_in_module_of_loader(ref_klass) : base_klass-&gt;class_in_module_of_loader(),
 309         (same_module) ? &quot;&quot; : &quot;; &quot;,
 310         (same_module) ? &quot;&quot; : ref_klass-&gt;class_in_module_of_loader());
 311     } else {
 312       // Use module specific message returned by verify_class_access_msg().
</pre>
<hr />
<pre>
 969   // Access checking may be turned off when calling from within the VM.
 970   Klass* current_klass = link_info.current_klass();
 971   if (link_info.check_access()) {
 972 
 973     // check access
 974     check_field_accessability(current_klass, resolved_klass, sel_klass, fd, CHECK);
 975 
 976     // check for errors
 977     if (is_static != fd.is_static()) {
 978       ResourceMark rm(THREAD);
 979       char msg[200];
 980       jio_snprintf(msg, sizeof(msg), &quot;Expected %s field %s.%s&quot;, is_static ? &quot;static&quot; : &quot;non-static&quot;, resolved_klass-&gt;external_name(), fd.name()-&gt;as_C_string());
 981       THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), msg);
 982     }
 983 
 984     // A final field can be modified only
 985     // (1) by methods declared in the class declaring the field and
 986     // (2) by the &lt;clinit&gt; method (in case of a static field)
 987     //     or by the &lt;init&gt; method (in case of an instance field).
 988     if (is_put &amp;&amp; fd.access_flags().is_final()) {
<span class="line-removed"> 989       ResourceMark rm(THREAD);</span>
<span class="line-removed"> 990       stringStream ss;</span>
 991 
 992       if (sel_klass != current_klass) {


 993         ss.print(&quot;Update to %s final field %s.%s attempted from a different class (%s) than the field&#39;s declaring class&quot;,
 994                  is_static ? &quot;static&quot; : &quot;non-static&quot;, resolved_klass-&gt;external_name(), fd.name()-&gt;as_C_string(),
 995                 current_klass-&gt;external_name());
 996         THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), ss.as_string());
 997       }
 998 
 999       if (fd.constants()-&gt;pool_holder()-&gt;major_version() &gt;= 53) {
1000         Method* m = link_info.current_method();
1001         assert(m != NULL, &quot;information about the current method must be available for &#39;put&#39; bytecodes&quot;);
1002         bool is_initialized_static_final_update = (byte == Bytecodes::_putstatic &amp;&amp;
1003                                                    fd.is_static() &amp;&amp;
1004                                                    !m-&gt;is_static_initializer());
1005         bool is_initialized_instance_final_update = ((byte == Bytecodes::_putfield || byte == Bytecodes::_nofast_putfield) &amp;&amp;
1006                                                      !fd.is_static() &amp;&amp;
1007                                                      !m-&gt;is_object_initializer());
1008 
1009         if (is_initialized_static_final_update || is_initialized_instance_final_update) {


1010           ss.print(&quot;Update to %s final field %s.%s attempted from a different method (%s) than the initializer method %s &quot;,
1011                    is_static ? &quot;static&quot; : &quot;non-static&quot;, resolved_klass-&gt;external_name(), fd.name()-&gt;as_C_string(),
1012                    m-&gt;name()-&gt;as_C_string(),
1013                    is_static ? &quot;&lt;clinit&gt;&quot; : &quot;&lt;init&gt;&quot;);
1014           THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), ss.as_string());
1015         }
1016       }
1017     }
1018 
1019     // initialize resolved_klass if necessary
1020     // note 1: the klass which declared the field must be initialized (i.e, sel_klass)
1021     //         according to the newest JVM spec (5.5, p.170) - was bug (gri 7/28/99)
1022     //
1023     // note 2: we don&#39;t want to force initialization if we are just checking
1024     //         if the field access is legal; e.g., during compilation
1025     if (is_static &amp;&amp; initialize_class) {
1026       sel_klass-&gt;initialize(CHECK);
1027     }
1028   }
1029 
</pre>
<hr />
<pre>
1378     }
1379   }
1380 
1381   // check if method exists
1382   if (selected_method.is_null()) {
1383     throw_abstract_method_error(resolved_method, recv_klass, CHECK);
1384   }
1385 
1386   // check if abstract
1387   if (check_null_and_abstract &amp;&amp; selected_method-&gt;is_abstract()) {
1388     // Pass arguments for generating a verbose error message.
1389     throw_abstract_method_error(resolved_method, selected_method, recv_klass, CHECK);
1390   }
1391 
1392   if (log_develop_is_enabled(Trace, vtables)) {
1393     trace_method_resolution(&quot;invokevirtual selected method: receiver-class:&quot;,
1394                             recv_klass, resolved_klass, selected_method(),
1395                             false, vtable_index);
1396   }
1397   // setup result
<span class="line-modified">1398   result.set_virtual(resolved_klass, recv_klass, resolved_method, selected_method, vtable_index, CHECK);</span>
1399 }
1400 
1401 void LinkResolver::resolve_interface_call(CallInfo&amp; result, Handle recv, Klass* recv_klass,
1402                                           const LinkInfo&amp; link_info,
1403                                           bool check_null_and_abstract, TRAPS) {
1404   // throws linktime exceptions
1405   Method* resolved_method = linktime_resolve_interface_method(link_info, CHECK);
1406   methodHandle mh(THREAD, resolved_method);
1407   runtime_resolve_interface_method(result, mh, link_info.resolved_klass(),
1408                                    recv, recv_klass, check_null_and_abstract, CHECK);
1409 }
1410 
1411 Method* LinkResolver::linktime_resolve_interface_method(const LinkInfo&amp; link_info,
1412                                                              TRAPS) {
1413   // normal interface method resolution
1414   Method* resolved_method = resolve_interface_method(link_info, Bytecodes::_invokeinterface, CHECK_NULL);
1415   assert(resolved_method-&gt;name() != vmSymbols::object_initializer_name(), &quot;should have been checked in verifier&quot;);
1416   assert(resolved_method-&gt;name() != vmSymbols::class_initializer_name (), &quot;should have been checked in verifier&quot;);
1417 
1418   return resolved_method;
</pre>
<hr />
<pre>
1474       ss.print(&quot;&#39;&quot;);
1475       Method::print_external_name(&amp;ss, recv_klass, selected_method-&gt;name(), selected_method-&gt;signature());
1476       ss.print(&quot;&#39;&quot;);
1477       THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), ss.as_string());
1478     }
1479     // check if abstract
1480     if (check_null_and_abstract &amp;&amp; selected_method-&gt;is_abstract()) {
1481       throw_abstract_method_error(resolved_method, selected_method, recv_klass, CHECK);
1482     }
1483   }
1484 
1485   if (log_develop_is_enabled(Trace, itables)) {
1486     trace_method_resolution(&quot;invokeinterface selected method: receiver-class:&quot;,
1487                             recv_klass, resolved_klass, selected_method(), true);
1488   }
1489   // setup result
1490   if (resolved_method-&gt;has_vtable_index()) {
1491     int vtable_index = resolved_method-&gt;vtable_index();
1492     log_develop_trace(itables)(&quot;  -- vtable index: %d&quot;, vtable_index);
1493     assert(vtable_index == selected_method-&gt;vtable_index(), &quot;sanity check&quot;);
<span class="line-modified">1494     result.set_virtual(resolved_klass, recv_klass, resolved_method, selected_method, vtable_index, CHECK);</span>
1495   } else if (resolved_method-&gt;has_itable_index()) {
1496     int itable_index = resolved_method()-&gt;itable_index();
1497     log_develop_trace(itables)(&quot;  -- itable index: %d&quot;, itable_index);
<span class="line-modified">1498     result.set_interface(resolved_klass, recv_klass, resolved_method, selected_method, itable_index, CHECK);</span>
1499   } else {
1500     int index = resolved_method-&gt;vtable_index();
1501     log_develop_trace(itables)(&quot;  -- non itable/vtable index: %d&quot;, index);
1502     assert(index == Method::nonvirtual_vtable_index, &quot;Oops hit another case!&quot;);
1503     assert(resolved_method()-&gt;is_private() ||
1504            (resolved_method()-&gt;is_final() &amp;&amp; resolved_method-&gt;method_holder() == SystemDictionary::Object_klass()),
1505            &quot;Should only have non-virtual invokeinterface for private or final-Object methods!&quot;);
1506     assert(resolved_method()-&gt;can_be_statically_bound(), &quot;Should only have non-virtual invokeinterface for statically bound methods!&quot;);
1507     // This sets up the nonvirtual form of &quot;virtual&quot; call (as needed for final and private methods)
<span class="line-modified">1508     result.set_virtual(resolved_klass, resolved_klass, resolved_method, resolved_method, index, CHECK);</span>
1509   }
1510 }
1511 
1512 
1513 Method* LinkResolver::linktime_resolve_interface_method_or_null(
1514                                                  const LinkInfo&amp; link_info) {
1515   EXCEPTION_MARK;
1516   Method* method_result = linktime_resolve_interface_method(link_info, THREAD);
1517   if (HAS_PENDING_EXCEPTION) {
1518     CLEAR_PENDING_EXCEPTION;
1519     return NULL;
1520   } else {
1521     return method_result;
1522   }
1523 }
1524 
1525 Method* LinkResolver::linktime_resolve_virtual_method_or_null(
1526                                                  const LinkInfo&amp; link_info) {
1527   EXCEPTION_MARK;
1528   Method* method_result = linktime_resolve_virtual_method(link_info, THREAD);
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
  47 #include &quot;oops/objArrayKlass.hpp&quot;
  48 #include &quot;oops/objArrayOop.hpp&quot;
  49 #include &quot;oops/oop.inline.hpp&quot;
  50 #include &quot;prims/methodHandles.hpp&quot;
  51 #include &quot;prims/nativeLookup.hpp&quot;
  52 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  53 #include &quot;runtime/frame.inline.hpp&quot;
  54 #include &quot;runtime/handles.inline.hpp&quot;
  55 #include &quot;runtime/reflection.hpp&quot;
  56 #include &quot;runtime/safepointVerifiers.hpp&quot;
  57 #include &quot;runtime/signature.hpp&quot;
  58 #include &quot;runtime/thread.inline.hpp&quot;
  59 #include &quot;runtime/vmThread.hpp&quot;
  60 
  61 //------------------------------------------------------------------------------------------------------------------------
  62 // Implementation of CallInfo
  63 
  64 
  65 void CallInfo::set_static(Klass* resolved_klass, const methodHandle&amp; resolved_method, TRAPS) {
  66   int vtable_index = Method::nonvirtual_vtable_index;
<span class="line-modified">  67   set_common(resolved_klass, resolved_method, resolved_method, CallInfo::direct_call, vtable_index, CHECK);</span>
  68 }
  69 
  70 
  71 void CallInfo::set_interface(Klass* resolved_klass,

  72                              const methodHandle&amp; resolved_method,
  73                              const methodHandle&amp; selected_method,
  74                              int itable_index, TRAPS) {
  75   // This is only called for interface methods. If the resolved_method
  76   // comes from java/lang/Object, it can be the subject of a virtual call, so
  77   // we should pick the vtable index from the resolved method.
  78   // In that case, the caller must call set_virtual instead of set_interface.
  79   assert(resolved_method-&gt;method_holder()-&gt;is_interface(), &quot;&quot;);
  80   assert(itable_index == resolved_method()-&gt;itable_index(), &quot;&quot;);
<span class="line-modified">  81   set_common(resolved_klass, resolved_method, selected_method, CallInfo::itable_call, itable_index, CHECK);</span>
  82 }
  83 
  84 void CallInfo::set_virtual(Klass* resolved_klass,

  85                            const methodHandle&amp; resolved_method,
  86                            const methodHandle&amp; selected_method,
  87                            int vtable_index, TRAPS) {
  88   assert(vtable_index &gt;= 0 || vtable_index == Method::nonvirtual_vtable_index, &quot;valid index&quot;);
  89   assert(vtable_index &lt; 0 || !resolved_method-&gt;has_vtable_index() || vtable_index == resolved_method-&gt;vtable_index(), &quot;&quot;);
  90   CallKind kind = (vtable_index &gt;= 0 &amp;&amp; !resolved_method-&gt;can_be_statically_bound() ? CallInfo::vtable_call : CallInfo::direct_call);
<span class="line-modified">  91   set_common(resolved_klass, resolved_method, selected_method, kind, vtable_index, CHECK);</span>
  92   assert(!resolved_method-&gt;is_compiled_lambda_form(), &quot;these must be handled via an invokehandle call&quot;);
  93 }
  94 
  95 void CallInfo::set_handle(const methodHandle&amp; resolved_method,
  96                           Handle resolved_appendix, TRAPS) {
  97   set_handle(SystemDictionary::MethodHandle_klass(), resolved_method, resolved_appendix, CHECK);
  98 }
  99 
 100 void CallInfo::set_handle(Klass* resolved_klass,
 101                           const methodHandle&amp; resolved_method,
 102                           Handle resolved_appendix, TRAPS) {
 103   guarantee(resolved_method.not_null(), &quot;resolved method is null&quot;);
 104   assert(resolved_method-&gt;intrinsic_id() == vmIntrinsics::_invokeBasic ||
 105          resolved_method-&gt;is_compiled_lambda_form(),
 106          &quot;linkMethod must return one of these&quot;);
 107   int vtable_index = Method::nonvirtual_vtable_index;
 108   assert(!resolved_method-&gt;has_vtable_index(), &quot;&quot;);
<span class="line-modified"> 109   set_common(resolved_klass, resolved_method, resolved_method, CallInfo::direct_call, vtable_index, CHECK);</span>
 110   _resolved_appendix = resolved_appendix;
 111 }
 112 
 113 void CallInfo::set_common(Klass* resolved_klass,

 114                           const methodHandle&amp; resolved_method,
 115                           const methodHandle&amp; selected_method,
 116                           CallKind kind,
 117                           int index,
 118                           TRAPS) {
 119   assert(resolved_method-&gt;signature() == selected_method-&gt;signature(), &quot;signatures must correspond&quot;);
 120   _resolved_klass  = resolved_klass;

 121   _resolved_method = resolved_method;
 122   _selected_method = selected_method;
 123   _call_kind       = kind;
 124   _call_index      = index;
 125   _resolved_appendix = Handle();
 126   DEBUG_ONLY(verify());  // verify before making side effects
 127 
 128   CompilationPolicy::compile_if_required(selected_method, THREAD);
 129 }
 130 
 131 // utility query for unreflecting a method
 132 CallInfo::CallInfo(Method* resolved_method, Klass* resolved_klass, TRAPS) {
 133   Klass* resolved_method_holder = resolved_method-&gt;method_holder();
 134   if (resolved_klass == NULL) { // 2nd argument defaults to holder of 1st
 135     resolved_klass = resolved_method_holder;
 136   }
 137   _resolved_klass  = resolved_klass;

 138   _resolved_method = methodHandle(THREAD, resolved_method);
 139   _selected_method = methodHandle(THREAD, resolved_method);
 140   // classify:
 141   CallKind kind = CallInfo::unknown_kind;
 142   int index = resolved_method-&gt;vtable_index();
 143   if (resolved_method-&gt;can_be_statically_bound()) {
 144     kind = CallInfo::direct_call;
 145   } else if (!resolved_method_holder-&gt;is_interface()) {
 146     // Could be an Object method inherited into an interface, but still a vtable call.
 147     kind = CallInfo::vtable_call;
 148   } else if (!resolved_klass-&gt;is_interface()) {
 149     // A default or miranda method.  Compute the vtable index.
 150     index = LinkResolver::vtable_index_of_interface_method(resolved_klass,
 151                            _resolved_method);
 152     assert(index &gt;= 0 , &quot;we should have valid vtable index at this point&quot;);
 153 
 154     kind = CallInfo::vtable_call;
 155   } else if (resolved_method-&gt;has_vtable_index()) {
 156     // Can occur if an interface redeclares a method of Object.
 157 
</pre>
<hr />
<pre>
 255   _current_method = methodHandle();
 256 
 257   // Coming from the constant pool always checks access
 258   _check_access  = true;
 259 }
 260 
 261 #ifndef PRODUCT
 262 void LinkInfo::print() {
 263   ResourceMark rm;
 264   tty-&gt;print_cr(&quot;Link resolved_klass=%s name=%s signature=%s current_klass=%s check_access=%s&quot;,
 265                 _resolved_klass-&gt;name()-&gt;as_C_string(),
 266                 _name-&gt;as_C_string(),
 267                 _signature-&gt;as_C_string(),
 268                 _current_klass == NULL ? &quot;(none)&quot; : _current_klass-&gt;name()-&gt;as_C_string(),
 269                 _check_access ? &quot;true&quot; : &quot;false&quot;);
 270 }
 271 #endif // PRODUCT
 272 //------------------------------------------------------------------------------------------------------------------------
 273 // Klass resolution
 274 
<span class="line-modified"> 275 void LinkResolver::check_klass_accessibility(Klass* ref_klass, Klass* sel_klass, TRAPS) {</span>

 276   Klass* base_klass = sel_klass;
<span class="line-modified"> 277   if (sel_klass-&gt;is_objArray_klass()) {</span>
<span class="line-modified"> 278     base_klass = ObjArrayKlass::cast(sel_klass)-&gt;bottom_klass();</span>







 279   }
<span class="line-added"> 280   // The element type could be a typeArray - we only need the access</span>
<span class="line-added"> 281   // check if it is a reference to another class.</span>
<span class="line-added"> 282   if (!base_klass-&gt;is_instance_klass()) {</span>
<span class="line-added"> 283     return;  // no relevant check to do</span>
<span class="line-added"> 284   }</span>
<span class="line-added"> 285 </span>
 286   Reflection::VerifyClassAccessResults vca_result =
 287     Reflection::verify_class_access(ref_klass, InstanceKlass::cast(base_klass), true);
 288   if (vca_result != Reflection::ACCESS_OK) {
 289     ResourceMark rm(THREAD);
 290     char* msg = Reflection::verify_class_access_msg(ref_klass,
 291                                                     InstanceKlass::cast(base_klass),
 292                                                     vca_result);
 293     bool same_module = (base_klass-&gt;module() == ref_klass-&gt;module());
 294     if (msg == NULL) {
 295       Exceptions::fthrow(
 296         THREAD_AND_LOCATION,
 297         vmSymbols::java_lang_IllegalAccessError(),
 298         &quot;failed to access class %s from class %s (%s%s%s)&quot;,
 299         base_klass-&gt;external_name(),
 300         ref_klass-&gt;external_name(),
 301         (same_module) ? base_klass-&gt;joint_in_module_of_loader(ref_klass) : base_klass-&gt;class_in_module_of_loader(),
 302         (same_module) ? &quot;&quot; : &quot;; &quot;,
 303         (same_module) ? &quot;&quot; : ref_klass-&gt;class_in_module_of_loader());
 304     } else {
 305       // Use module specific message returned by verify_class_access_msg().
</pre>
<hr />
<pre>
 962   // Access checking may be turned off when calling from within the VM.
 963   Klass* current_klass = link_info.current_klass();
 964   if (link_info.check_access()) {
 965 
 966     // check access
 967     check_field_accessability(current_klass, resolved_klass, sel_klass, fd, CHECK);
 968 
 969     // check for errors
 970     if (is_static != fd.is_static()) {
 971       ResourceMark rm(THREAD);
 972       char msg[200];
 973       jio_snprintf(msg, sizeof(msg), &quot;Expected %s field %s.%s&quot;, is_static ? &quot;static&quot; : &quot;non-static&quot;, resolved_klass-&gt;external_name(), fd.name()-&gt;as_C_string());
 974       THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), msg);
 975     }
 976 
 977     // A final field can be modified only
 978     // (1) by methods declared in the class declaring the field and
 979     // (2) by the &lt;clinit&gt; method (in case of a static field)
 980     //     or by the &lt;init&gt; method (in case of an instance field).
 981     if (is_put &amp;&amp; fd.access_flags().is_final()) {


 982 
 983       if (sel_klass != current_klass) {
<span class="line-added"> 984         ResourceMark rm(THREAD);</span>
<span class="line-added"> 985         stringStream ss;</span>
 986         ss.print(&quot;Update to %s final field %s.%s attempted from a different class (%s) than the field&#39;s declaring class&quot;,
 987                  is_static ? &quot;static&quot; : &quot;non-static&quot;, resolved_klass-&gt;external_name(), fd.name()-&gt;as_C_string(),
 988                 current_klass-&gt;external_name());
 989         THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), ss.as_string());
 990       }
 991 
 992       if (fd.constants()-&gt;pool_holder()-&gt;major_version() &gt;= 53) {
 993         Method* m = link_info.current_method();
 994         assert(m != NULL, &quot;information about the current method must be available for &#39;put&#39; bytecodes&quot;);
 995         bool is_initialized_static_final_update = (byte == Bytecodes::_putstatic &amp;&amp;
 996                                                    fd.is_static() &amp;&amp;
 997                                                    !m-&gt;is_static_initializer());
 998         bool is_initialized_instance_final_update = ((byte == Bytecodes::_putfield || byte == Bytecodes::_nofast_putfield) &amp;&amp;
 999                                                      !fd.is_static() &amp;&amp;
1000                                                      !m-&gt;is_object_initializer());
1001 
1002         if (is_initialized_static_final_update || is_initialized_instance_final_update) {
<span class="line-added">1003           ResourceMark rm(THREAD);</span>
<span class="line-added">1004           stringStream ss;</span>
1005           ss.print(&quot;Update to %s final field %s.%s attempted from a different method (%s) than the initializer method %s &quot;,
1006                    is_static ? &quot;static&quot; : &quot;non-static&quot;, resolved_klass-&gt;external_name(), fd.name()-&gt;as_C_string(),
1007                    m-&gt;name()-&gt;as_C_string(),
1008                    is_static ? &quot;&lt;clinit&gt;&quot; : &quot;&lt;init&gt;&quot;);
1009           THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), ss.as_string());
1010         }
1011       }
1012     }
1013 
1014     // initialize resolved_klass if necessary
1015     // note 1: the klass which declared the field must be initialized (i.e, sel_klass)
1016     //         according to the newest JVM spec (5.5, p.170) - was bug (gri 7/28/99)
1017     //
1018     // note 2: we don&#39;t want to force initialization if we are just checking
1019     //         if the field access is legal; e.g., during compilation
1020     if (is_static &amp;&amp; initialize_class) {
1021       sel_klass-&gt;initialize(CHECK);
1022     }
1023   }
1024 
</pre>
<hr />
<pre>
1373     }
1374   }
1375 
1376   // check if method exists
1377   if (selected_method.is_null()) {
1378     throw_abstract_method_error(resolved_method, recv_klass, CHECK);
1379   }
1380 
1381   // check if abstract
1382   if (check_null_and_abstract &amp;&amp; selected_method-&gt;is_abstract()) {
1383     // Pass arguments for generating a verbose error message.
1384     throw_abstract_method_error(resolved_method, selected_method, recv_klass, CHECK);
1385   }
1386 
1387   if (log_develop_is_enabled(Trace, vtables)) {
1388     trace_method_resolution(&quot;invokevirtual selected method: receiver-class:&quot;,
1389                             recv_klass, resolved_klass, selected_method(),
1390                             false, vtable_index);
1391   }
1392   // setup result
<span class="line-modified">1393   result.set_virtual(resolved_klass, resolved_method, selected_method, vtable_index, CHECK);</span>
1394 }
1395 
1396 void LinkResolver::resolve_interface_call(CallInfo&amp; result, Handle recv, Klass* recv_klass,
1397                                           const LinkInfo&amp; link_info,
1398                                           bool check_null_and_abstract, TRAPS) {
1399   // throws linktime exceptions
1400   Method* resolved_method = linktime_resolve_interface_method(link_info, CHECK);
1401   methodHandle mh(THREAD, resolved_method);
1402   runtime_resolve_interface_method(result, mh, link_info.resolved_klass(),
1403                                    recv, recv_klass, check_null_and_abstract, CHECK);
1404 }
1405 
1406 Method* LinkResolver::linktime_resolve_interface_method(const LinkInfo&amp; link_info,
1407                                                              TRAPS) {
1408   // normal interface method resolution
1409   Method* resolved_method = resolve_interface_method(link_info, Bytecodes::_invokeinterface, CHECK_NULL);
1410   assert(resolved_method-&gt;name() != vmSymbols::object_initializer_name(), &quot;should have been checked in verifier&quot;);
1411   assert(resolved_method-&gt;name() != vmSymbols::class_initializer_name (), &quot;should have been checked in verifier&quot;);
1412 
1413   return resolved_method;
</pre>
<hr />
<pre>
1469       ss.print(&quot;&#39;&quot;);
1470       Method::print_external_name(&amp;ss, recv_klass, selected_method-&gt;name(), selected_method-&gt;signature());
1471       ss.print(&quot;&#39;&quot;);
1472       THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), ss.as_string());
1473     }
1474     // check if abstract
1475     if (check_null_and_abstract &amp;&amp; selected_method-&gt;is_abstract()) {
1476       throw_abstract_method_error(resolved_method, selected_method, recv_klass, CHECK);
1477     }
1478   }
1479 
1480   if (log_develop_is_enabled(Trace, itables)) {
1481     trace_method_resolution(&quot;invokeinterface selected method: receiver-class:&quot;,
1482                             recv_klass, resolved_klass, selected_method(), true);
1483   }
1484   // setup result
1485   if (resolved_method-&gt;has_vtable_index()) {
1486     int vtable_index = resolved_method-&gt;vtable_index();
1487     log_develop_trace(itables)(&quot;  -- vtable index: %d&quot;, vtable_index);
1488     assert(vtable_index == selected_method-&gt;vtable_index(), &quot;sanity check&quot;);
<span class="line-modified">1489     result.set_virtual(resolved_klass, resolved_method, selected_method, vtable_index, CHECK);</span>
1490   } else if (resolved_method-&gt;has_itable_index()) {
1491     int itable_index = resolved_method()-&gt;itable_index();
1492     log_develop_trace(itables)(&quot;  -- itable index: %d&quot;, itable_index);
<span class="line-modified">1493     result.set_interface(resolved_klass, resolved_method, selected_method, itable_index, CHECK);</span>
1494   } else {
1495     int index = resolved_method-&gt;vtable_index();
1496     log_develop_trace(itables)(&quot;  -- non itable/vtable index: %d&quot;, index);
1497     assert(index == Method::nonvirtual_vtable_index, &quot;Oops hit another case!&quot;);
1498     assert(resolved_method()-&gt;is_private() ||
1499            (resolved_method()-&gt;is_final() &amp;&amp; resolved_method-&gt;method_holder() == SystemDictionary::Object_klass()),
1500            &quot;Should only have non-virtual invokeinterface for private or final-Object methods!&quot;);
1501     assert(resolved_method()-&gt;can_be_statically_bound(), &quot;Should only have non-virtual invokeinterface for statically bound methods!&quot;);
1502     // This sets up the nonvirtual form of &quot;virtual&quot; call (as needed for final and private methods)
<span class="line-modified">1503     result.set_virtual(resolved_klass, resolved_method, resolved_method, index, CHECK);</span>
1504   }
1505 }
1506 
1507 
1508 Method* LinkResolver::linktime_resolve_interface_method_or_null(
1509                                                  const LinkInfo&amp; link_info) {
1510   EXCEPTION_MARK;
1511   Method* method_result = linktime_resolve_interface_method(link_info, THREAD);
1512   if (HAS_PENDING_EXCEPTION) {
1513     CLEAR_PENDING_EXCEPTION;
1514     return NULL;
1515   } else {
1516     return method_result;
1517   }
1518 }
1519 
1520 Method* LinkResolver::linktime_resolve_virtual_method_or_null(
1521                                                  const LinkInfo&amp; link_info) {
1522   EXCEPTION_MARK;
1523   Method* method_result = linktime_resolve_virtual_method(link_info, THREAD);
</pre>
</td>
</tr>
</table>
<center><a href="abstractInterpreter.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="linkResolver.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
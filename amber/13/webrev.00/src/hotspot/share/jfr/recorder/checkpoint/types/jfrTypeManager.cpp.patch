diff a/src/hotspot/share/jfr/recorder/checkpoint/types/jfrTypeManager.cpp b/src/hotspot/share/jfr/recorder/checkpoint/types/jfrTypeManager.cpp
--- a/src/hotspot/share/jfr/recorder/checkpoint/types/jfrTypeManager.cpp
+++ b/src/hotspot/share/jfr/recorder/checkpoint/types/jfrTypeManager.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -184,12 +184,10 @@
     assert(iter.next()->id() != id, "invariant");
   }
 }
 #endif
 
-static bool new_registration = false;
-
 static bool register_static_type(JfrTypeId id, bool permit_cache, JfrSerializer* serializer) {
   assert(serializer != NULL, "invariant");
   JfrSerializerRegistration* const registration = new JfrSerializerRegistration(id, permit_cache, serializer);
   if (registration == NULL) {
     delete serializer;
@@ -198,11 +196,10 @@
   assert(!types.in_list(registration), "invariant");
   DEBUG_ONLY(assert_not_registered_twice(id, types);)
   if (JfrRecorder::is_recording()) {
     JfrCheckpointWriter writer(STATICS);
     registration->invoke(writer);
-    new_registration = true;
   }
   types.prepend(registration);
   return true;
 }
 
@@ -216,11 +213,10 @@
   register_static_type(TYPE_GCTHRESHOLDUPDATER, true, new GCThresholdUpdaterConstant());
   register_static_type(TYPE_METADATATYPE, true, new MetadataTypeConstant());
   register_static_type(TYPE_METASPACEOBJECTTYPE, true, new MetaspaceObjectTypeConstant());
   register_static_type(TYPE_REFERENCETYPE, true, new ReferenceTypeConstant());
   register_static_type(TYPE_NARROWOOPMODE, true, new NarrowOopModeConstant());
-  register_static_type(TYPE_COMPILERPHASETYPE, true, new CompilerPhaseTypeConstant());
   register_static_type(TYPE_CODEBLOBTYPE, true, new CodeBlobTypeConstant());
   register_static_type(TYPE_VMOPERATIONTYPE, true, new VMOperationTypeConstant());
   register_static_type(TYPE_THREADSTATE, true, new ThreadStateConstant());
   register_static_type(TYPE_BYTECODE, true, new BytecodeConstant());
   register_static_type(TYPE_COMPILERTYPE, true, new CompilerTypeConstant());
@@ -231,22 +227,13 @@
 bool JfrSerializer::register_serializer(JfrTypeId id, bool permit_cache, JfrSerializer* serializer) {
   SerializerRegistrationGuard guard;
   return register_static_type(id, permit_cache, serializer);
 }
 
-bool JfrTypeManager::has_new_static_type() {
-  if (new_registration) {
-    SerializerRegistrationGuard guard;
-    new_registration = false;
-    return true;
-  }
-  return false;
-}
 
 void JfrTypeManager::write_static_types(JfrCheckpointWriter& writer) {
   SerializerRegistrationGuard guard;
   const Iterator iter(types);
   while (iter.has_next()) {
     iter.next()->invoke(writer);
   }
-  new_registration = false;
 }

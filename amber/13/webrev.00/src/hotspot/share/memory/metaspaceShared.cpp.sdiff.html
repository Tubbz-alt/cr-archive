<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/memory/metaspaceShared.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="memRegion.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="metaspaceShared.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/memory/metaspaceShared.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1086 #undef fmt_stats
1087 }
1088 
1089 // Populate the shared space.
1090 
1091 class VM_PopulateDumpSharedSpace: public VM_Operation {
1092 private:
1093   GrowableArray&lt;MemRegion&gt; *_closed_archive_heap_regions;
1094   GrowableArray&lt;MemRegion&gt; *_open_archive_heap_regions;
1095 
1096   GrowableArray&lt;ArchiveHeapOopmapInfo&gt; *_closed_archive_heap_oopmaps;
1097   GrowableArray&lt;ArchiveHeapOopmapInfo&gt; *_open_archive_heap_oopmaps;
1098 
1099   void dump_java_heap_objects() NOT_CDS_JAVA_HEAP_RETURN;
1100   void dump_archive_heap_oopmaps() NOT_CDS_JAVA_HEAP_RETURN;
1101   void dump_archive_heap_oopmaps(GrowableArray&lt;MemRegion&gt;* regions,
1102                                  GrowableArray&lt;ArchiveHeapOopmapInfo&gt;* oopmaps);
1103   void dump_symbols();
1104   char* dump_read_only_tables();
1105   void print_class_stats();
<span class="line-modified">1106   void print_region_stats();</span>
1107   void print_bitmap_region_stats(size_t size, size_t total_size);
1108   void print_heap_region_stats(GrowableArray&lt;MemRegion&gt; *heap_mem,
1109                                const char *name, size_t total_size);
1110   void relocate_to_default_base_address(CHeapBitMap* ptrmap);
1111 
1112 public:
1113 
1114   VMOp_Type type() const { return VMOp_PopulateDumpSharedSpace; }
1115   void doit();   // outline because gdb sucks
1116   bool allow_nested_vm_operations() const { return true; }
1117 }; // class VM_PopulateDumpSharedSpace
1118 
1119 class SortedSymbolClosure: public SymbolClosure {
1120   GrowableArray&lt;Symbol*&gt; _symbols;
1121   virtual void do_symbol(Symbol** sym) {
1122     assert((*sym)-&gt;is_permanent(), &quot;archived symbols must be permanent&quot;);
1123     _symbols.append(*sym);
1124   }
1125   static int compare_symbols_by_address(Symbol** a, Symbol** b) {
1126     if (a[0] &lt; b[0]) {
</pre>
<hr />
<pre>
1358     }
1359     // NOTE: after this point, we shouldn&#39;t have any globals that can reach the old
1360     // objects.
1361 
1362     // We cannot use any of the objects in the heap anymore (except for the
1363     // shared strings) because their headers no longer point to valid Klasses.
1364   }
1365 
1366   static void iterate_roots(MetaspaceClosure* it) {
1367     GrowableArray&lt;Symbol*&gt;* symbols = _ssc-&gt;get_sorted_symbols();
1368     for (int i=0; i&lt;symbols-&gt;length(); i++) {
1369       it-&gt;push(symbols-&gt;adr_at(i));
1370     }
1371     if (_global_klass_objects != NULL) {
1372       // Need to fix up the pointers
1373       for (int i = 0; i &lt; _global_klass_objects-&gt;length(); i++) {
1374         // NOTE -- this requires that the vtable is NOT yet patched, or else we are hosed.
1375         it-&gt;push(_global_klass_objects-&gt;adr_at(i));
1376       }
1377     }
<span class="line-modified">1378     FileMapInfo::metaspace_pointers_do(it);</span>
1379     SystemDictionaryShared::dumptime_classes_do(it);
1380     Universe::metaspace_pointers_do(it);
1381     SymbolTable::metaspace_pointers_do(it);
1382     vmSymbols::metaspace_pointers_do(it);
1383 
1384     it-&gt;finish();
1385   }
1386 
1387   static Klass* get_relocated_klass(Klass* orig_klass) {
1388     assert(DumpSharedSpaces, &quot;dump time only&quot;);
1389     address* pp = _new_loc_table-&gt;lookup((address)orig_klass);
1390     assert(pp != NULL, &quot;must be&quot;);
1391     Klass* klass = (Klass*)(*pp);
1392     assert(klass-&gt;is_klass(), &quot;must be&quot;);
1393     return klass;
1394   }
1395 };
1396 
1397 DumpAllocStats* ArchiveCompactor::_alloc_stats;
1398 SortedSymbolClosure* ArchiveCompactor::_ssc;
</pre>
<hr />
<pre>
1406 }
1407 
1408 char* VM_PopulateDumpSharedSpace::dump_read_only_tables() {
1409   ArchiveCompactor::OtherROAllocMark mark;
1410 
1411   log_info(cds)(&quot;Removing java_mirror ... &quot;);
1412   if (!HeapShared::is_heap_object_archiving_allowed()) {
1413     clear_basic_type_mirrors();
1414   }
1415   remove_java_mirror_in_classes();
1416   log_info(cds)(&quot;done. &quot;);
1417 
1418   SystemDictionaryShared::write_to_archive();
1419 
1420   // Write the other data to the output array.
1421   char* start = _ro_region.top();
1422   WriteClosure wc(&amp;_ro_region);
1423   MetaspaceShared::serialize(&amp;wc);
1424 
1425   // Write the bitmaps for patching the archive heap regions


1426   dump_archive_heap_oopmaps();
1427 
1428   return start;
1429 }
1430 
1431 void VM_PopulateDumpSharedSpace::print_class_stats() {
1432   log_info(cds)(&quot;Number of classes %d&quot;, _global_klass_objects-&gt;length());
1433   {
1434     int num_type_array = 0, num_obj_array = 0, num_inst = 0;
1435     for (int i = 0; i &lt; _global_klass_objects-&gt;length(); i++) {
1436       Klass* k = _global_klass_objects-&gt;at(i);
1437       if (k-&gt;is_instance_klass()) {
1438         num_inst ++;
1439       } else if (k-&gt;is_objArray_klass()) {
1440         num_obj_array ++;
1441       } else {
1442         assert(k-&gt;is_typeArray_klass(), &quot;sanity&quot;);
1443         num_type_array ++;
1444       }
1445     }
</pre>
<hr />
<pre>
1555   char* serialized_data = dump_read_only_tables();
1556   _ro_region.pack();
1557 
1558   // The vtable clones contain addresses of the current process.
1559   // We don&#39;t want to write these addresses into the archive.
1560   MetaspaceShared::zero_cpp_vtable_clones_for_writing();
1561 
1562   // relocate the data so that it can be mapped to Arguments::default_SharedBaseAddress()
1563   // without runtime relocation.
1564   relocate_to_default_base_address(&amp;ptrmap);
1565 
1566   // Create and write the archive file that maps the shared spaces.
1567 
1568   FileMapInfo* mapinfo = new FileMapInfo(true);
1569   mapinfo-&gt;populate_header(os::vm_allocation_granularity());
1570   mapinfo-&gt;set_serialized_data(serialized_data);
1571   mapinfo-&gt;set_cloned_vtables(cloned_vtables);
1572   mapinfo-&gt;set_i2i_entry_code_buffers(MetaspaceShared::i2i_entry_code_buffers(),
1573                                       MetaspaceShared::i2i_entry_code_buffers_size());
1574   mapinfo-&gt;open_for_write();
<span class="line-modified">1575   MetaspaceShared::write_core_archive_regions(mapinfo);</span>
1576   _total_closed_archive_region_size = mapinfo-&gt;write_archive_heap_regions(
1577                                         _closed_archive_heap_regions,
1578                                         _closed_archive_heap_oopmaps,
1579                                         MetaspaceShared::first_closed_archive_heap_region,
1580                                         MetaspaceShared::max_closed_archive_heap_region);
1581   _total_open_archive_region_size = mapinfo-&gt;write_archive_heap_regions(
1582                                         _open_archive_heap_regions,
1583                                         _open_archive_heap_oopmaps,
1584                                         MetaspaceShared::first_open_archive_heap_region,
1585                                         MetaspaceShared::max_open_archive_heap_region);
1586 
1587   mapinfo-&gt;set_final_requested_base((char*)Arguments::default_SharedBaseAddress());
1588   mapinfo-&gt;set_header_crc(mapinfo-&gt;compute_header_crc());
1589   mapinfo-&gt;write_header();

1590   mapinfo-&gt;close();
1591 
<span class="line-removed">1592   print_region_stats();</span>
<span class="line-removed">1593 </span>
1594   if (log_is_enabled(Info, cds)) {
1595     ArchiveCompactor::alloc_stats()-&gt;print_stats(int(_ro_region.used()), int(_rw_region.used()),
1596                                                  int(_mc_region.used()));
1597   }
1598 
1599   if (PrintSystemDictionaryAtExit) {
1600     SystemDictionary::print();
1601   }
1602 
1603   if (AllowArchivingWithJavaAgent) {
1604     warning(&quot;This archive was created with AllowArchivingWithJavaAgent. It should be used &quot;
1605             &quot;for testing purposes only and should not be used in a production environment&quot;);
1606   }
1607 
1608   // There may be other pending VM operations that operate on the InstanceKlasses,
1609   // which will fail because InstanceKlasses::remove_unshareable_info()
1610   // has been called. Forget these operations and exit the VM directly.
1611   vm_direct_exit(0);
1612 }
1613 
<span class="line-modified">1614 void VM_PopulateDumpSharedSpace::print_region_stats() {</span>
1615   // Print statistics of all the regions
<span class="line-modified">1616   const size_t bitmap_used = ArchivePtrMarker::ptrmap()-&gt;size_in_bytes();</span>
<span class="line-modified">1617   const size_t bitmap_reserved = align_up(bitmap_used, Metaspace::reserve_alignment());</span>
1618   const size_t total_reserved = _ro_region.reserved()  + _rw_region.reserved() +
1619                                 _mc_region.reserved()  +
1620                                 bitmap_reserved +
1621                                 _total_closed_archive_region_size +
1622                                 _total_open_archive_region_size;
1623   const size_t total_bytes = _ro_region.used()  + _rw_region.used() +
1624                              _mc_region.used()  +
1625                              bitmap_used +
1626                              _total_closed_archive_region_size +
1627                              _total_open_archive_region_size;
1628   const double total_u_perc = percent_of(total_bytes, total_reserved);
1629 
1630   _mc_region.print(total_reserved);
1631   _rw_region.print(total_reserved);
1632   _ro_region.print(total_reserved);
1633   print_bitmap_region_stats(bitmap_reserved, total_reserved);
1634   print_heap_region_stats(_closed_archive_heap_regions, &quot;ca&quot;, total_reserved);
1635   print_heap_region_stats(_open_archive_heap_regions, &quot;oa&quot;, total_reserved);
1636 
1637   log_debug(cds)(&quot;total    : &quot; SIZE_FORMAT_W(9) &quot; [100.0%% of total] out of &quot; SIZE_FORMAT_W(9) &quot; bytes [%5.1f%% used]&quot;,
</pre>
<hr />
<pre>
1639 }
1640 
1641 void VM_PopulateDumpSharedSpace::print_bitmap_region_stats(size_t size, size_t total_size) {
1642   log_debug(cds)(&quot;bm  space: &quot; SIZE_FORMAT_W(9) &quot; [ %4.1f%% of total] out of &quot; SIZE_FORMAT_W(9) &quot; bytes [100.0%% used] at &quot; INTPTR_FORMAT,
1643                  size, size/double(total_size)*100.0, size, p2i(NULL));
1644 }
1645 
1646 void VM_PopulateDumpSharedSpace::print_heap_region_stats(GrowableArray&lt;MemRegion&gt; *heap_mem,
1647                                                          const char *name, size_t total_size) {
1648   int arr_len = heap_mem == NULL ? 0 : heap_mem-&gt;length();
1649   for (int i = 0; i &lt; arr_len; i++) {
1650       char* start = (char*)heap_mem-&gt;at(i).start();
1651       size_t size = heap_mem-&gt;at(i).byte_size();
1652       char* top = start + size;
1653       log_debug(cds)(&quot;%s%d space: &quot; SIZE_FORMAT_W(9) &quot; [ %4.1f%% of total] out of &quot; SIZE_FORMAT_W(9) &quot; bytes [100.0%% used] at &quot; INTPTR_FORMAT,
1654                      name, i, size, size/double(total_size)*100.0, size, p2i(start));
1655 
1656   }
1657 }
1658 
<span class="line-modified">1659 void MetaspaceShared::write_core_archive_regions(FileMapInfo* mapinfo) {</span>


1660   // Make sure NUM_CDS_REGIONS (exported in cds.h) agrees with
1661   // MetaspaceShared::n_regions (internal to hotspot).
1662   assert(NUM_CDS_REGIONS == MetaspaceShared::n_regions, &quot;sanity&quot;);
1663 
1664   // mc contains the trampoline code for method entries, which are patched at run time,
1665   // so it needs to be read/write.
1666   write_region(mapinfo, mc, &amp;_mc_region, /*read_only=*/false,/*allow_exec=*/true);
1667   write_region(mapinfo, rw, &amp;_rw_region, /*read_only=*/false,/*allow_exec=*/false);
1668   write_region(mapinfo, ro, &amp;_ro_region, /*read_only=*/true, /*allow_exec=*/false);
<span class="line-modified">1669   mapinfo-&gt;write_bitmap_region(ArchivePtrMarker::ptrmap());</span>
1670 }
1671 
1672 void MetaspaceShared::write_region(FileMapInfo* mapinfo, int region_idx, DumpRegion* dump_region, bool read_only,  bool allow_exec) {
1673   mapinfo-&gt;write_region(region_idx, dump_region-&gt;base(), dump_region-&gt;used(), read_only, allow_exec);
1674 }
1675 
1676 // Update a Java object to point its Klass* to the new location after
1677 // shared archive has been compacted.
1678 void MetaspaceShared::relocate_klass_ptr(oop o) {
1679   assert(DumpSharedSpaces, &quot;sanity&quot;);
1680   Klass* k = ArchiveCompactor::get_relocated_klass(o-&gt;klass());
1681   o-&gt;set_klass(k);
1682 }
1683 
1684 Klass* MetaspaceShared::get_relocated_klass(Klass *k, bool is_final) {
1685   assert(DumpSharedSpaces, &quot;sanity&quot;);
1686   k = ArchiveCompactor::get_relocated_klass(k);
1687   if (is_final) {
1688     k = (Klass*)(address(k) + final_delta());
1689   }
1690   return k;
1691 }
1692 
1693 class LinkSharedClassesClosure : public KlassClosure {
1694   Thread* THREAD;
1695   bool    _made_progress;
1696  public:
1697   LinkSharedClassesClosure(Thread* thread) : THREAD(thread), _made_progress(false) {}
1698 
1699   void reset()               { _made_progress = false; }
1700   bool made_progress() const { return _made_progress; }
1701 
1702   void do_klass(Klass* k) {
1703     if (k-&gt;is_instance_klass()) {
1704       InstanceKlass* ik = InstanceKlass::cast(k);
<span class="line-modified">1705       // Link the class to cause the bytecodes to be rewritten and the</span>
<span class="line-modified">1706       // cpcache to be created. Class verification is done according</span>
<span class="line-modified">1707       // to -Xverify setting.</span>
<span class="line-modified">1708       _made_progress |= MetaspaceShared::try_link_class(ik, THREAD);</span>
<span class="line-modified">1709       guarantee(!HAS_PENDING_EXCEPTION, &quot;exception in link_class&quot;);</span>



1710 
<span class="line-modified">1711       ik-&gt;constants()-&gt;resolve_class_constants(THREAD);</span>






1712     }
1713   }
1714 };
1715 
1716 void MetaspaceShared::link_and_cleanup_shared_classes(TRAPS) {
1717   // We need to iterate because verification may cause additional classes
1718   // to be loaded.
1719   LinkSharedClassesClosure link_closure(THREAD);
1720   do {
1721     link_closure.reset();
1722     ClassLoaderDataGraph::unlocked_loaded_classes_do(&amp;link_closure);
1723     guarantee(!HAS_PENDING_EXCEPTION, &quot;exception in link_class&quot;);
1724   } while (link_closure.made_progress());
1725 }
1726 
1727 void MetaspaceShared::prepare_for_dumping() {
1728   Arguments::check_unsupported_dumping_properties();
1729   ClassLoader::initialize_shared_path();
1730 }
1731 
</pre>
<hr />
<pre>
1831       if (klass-&gt;is_instance_klass()) {
1832         InstanceKlass* ik = InstanceKlass::cast(klass);
1833 
1834         // Link the class to cause the bytecodes to be rewritten and the
1835         // cpcache to be created. The linking is done as soon as classes
1836         // are loaded in order that the related data structures (klass and
1837         // cpCache) are located together.
1838         try_link_class(ik, THREAD);
1839         guarantee(!HAS_PENDING_EXCEPTION, &quot;exception in link_class&quot;);
1840       }
1841 
1842       class_count++;
1843     }
1844   }
1845 
1846   return class_count;
1847 }
1848 
1849 // Returns true if the class&#39;s status has changed
1850 bool MetaspaceShared::try_link_class(InstanceKlass* ik, TRAPS) {
<span class="line-modified">1851   assert(DumpSharedSpaces, &quot;should only be called during dumping&quot;);</span>
1852   if (ik-&gt;init_state() &lt; InstanceKlass::linked &amp;&amp;
1853       !SystemDictionaryShared::has_class_failed_verification(ik)) {
1854     bool saved = BytecodeVerificationLocal;
1855     if (ik-&gt;is_shared_unregistered_class() &amp;&amp; ik-&gt;class_loader() == NULL) {
1856       // The verification decision is based on BytecodeVerificationRemote
1857       // for non-system classes. Since we are using the NULL classloader
1858       // to load non-system classes for customized class loaders during dumping,
1859       // we need to temporarily change BytecodeVerificationLocal to be the same as
1860       // BytecodeVerificationRemote. Note this can cause the parent system
1861       // classes also being verified. The extra overhead is acceptable during
1862       // dumping.
1863       BytecodeVerificationLocal = BytecodeVerificationRemote;
1864     }
1865     ik-&gt;link_class(THREAD);
1866     if (HAS_PENDING_EXCEPTION) {
1867       ResourceMark rm(THREAD);
1868       log_warning(cds)(&quot;Preload Warning: Verification failed for %s&quot;,
1869                     ik-&gt;external_name());
1870       CLEAR_PENDING_EXCEPTION;
1871       SystemDictionaryShared::set_class_has_failed_verification(ik);
</pre>
<hr />
<pre>
1889   ArchiveCompactor::OtherROAllocMark mark;
1890   HeapShared::write_subgraph_info_table();
1891 }
1892 
1893 void VM_PopulateDumpSharedSpace::dump_archive_heap_oopmaps() {
1894   if (HeapShared::is_heap_object_archiving_allowed()) {
1895     _closed_archive_heap_oopmaps = new GrowableArray&lt;ArchiveHeapOopmapInfo&gt;(2);
1896     dump_archive_heap_oopmaps(_closed_archive_heap_regions, _closed_archive_heap_oopmaps);
1897 
1898     _open_archive_heap_oopmaps = new GrowableArray&lt;ArchiveHeapOopmapInfo&gt;(2);
1899     dump_archive_heap_oopmaps(_open_archive_heap_regions, _open_archive_heap_oopmaps);
1900   }
1901 }
1902 
1903 void VM_PopulateDumpSharedSpace::dump_archive_heap_oopmaps(GrowableArray&lt;MemRegion&gt;* regions,
1904                                                            GrowableArray&lt;ArchiveHeapOopmapInfo&gt;* oopmaps) {
1905   for (int i=0; i&lt;regions-&gt;length(); i++) {
1906     ResourceBitMap oopmap = HeapShared::calculate_oopmap(regions-&gt;at(i));
1907     size_t size_in_bits = oopmap.size();
1908     size_t size_in_bytes = oopmap.size_in_bytes();
<span class="line-modified">1909     uintptr_t* buffer = (uintptr_t*)_ro_region.allocate(size_in_bytes, sizeof(intptr_t));</span>
1910     oopmap.write_to(buffer, size_in_bytes);
1911     log_info(cds, heap)(&quot;Oopmap = &quot; INTPTR_FORMAT &quot; (&quot; SIZE_FORMAT_W(6) &quot; bytes) for heap region &quot;
1912                         INTPTR_FORMAT &quot; (&quot; SIZE_FORMAT_W(8) &quot; bytes)&quot;,
1913                         p2i(buffer), size_in_bytes,
1914                         p2i(regions-&gt;at(i).start()), regions-&gt;at(i).byte_size());
1915 
1916     ArchiveHeapOopmapInfo info;
1917     info._oopmap = (address)buffer;
1918     info._oopmap_size_in_bits = size_in_bits;

1919     oopmaps-&gt;append(info);
1920   }
1921 }
1922 #endif // INCLUDE_CDS_JAVA_HEAP
1923 
1924 void ReadClosure::do_ptr(void** p) {
1925   assert(*p == NULL, &quot;initializing previous initialized pointer.&quot;);
1926   intptr_t obj = nextPtr();
1927   assert((intptr_t)obj &gt;= 0 || (intptr_t)obj &lt; -100,
1928          &quot;hit tag while initializing ptrs.&quot;);
1929   *p = (void*)obj;
1930 }
1931 
1932 void ReadClosure::do_u4(u4* p) {
1933   intptr_t obj = nextPtr();
1934   *p = (u4)(uintx(obj));
1935 }
1936 
1937 void ReadClosure::do_bool(bool* p) {
1938   intptr_t obj = nextPtr();
</pre>
<hr />
<pre>
2322   _i2i_entry_code_buffers = static_mapinfo-&gt;i2i_entry_code_buffers();
2323   _i2i_entry_code_buffers_size = static_mapinfo-&gt;i2i_entry_code_buffers_size();
2324   char* buffer = static_mapinfo-&gt;cloned_vtables();
2325   clone_cpp_vtables((intptr_t*)buffer);
2326 
2327   // Verify various attributes of the archive, plus initialize the
2328   // shared string/symbol tables
2329   buffer = static_mapinfo-&gt;serialized_data();
2330   intptr_t* array = (intptr_t*)buffer;
2331   ReadClosure rc(&amp;array);
2332   serialize(&amp;rc);
2333 
2334   // Initialize the run-time symbol table.
2335   SymbolTable::create_table();
2336 
2337   static_mapinfo-&gt;patch_archived_heap_embedded_pointers();
2338 
2339   // Close the mapinfo file
2340   static_mapinfo-&gt;close();
2341 


2342   FileMapInfo *dynamic_mapinfo = FileMapInfo::dynamic_info();
2343   if (dynamic_mapinfo != NULL) {
2344     intptr_t* buffer = (intptr_t*)dynamic_mapinfo-&gt;serialized_data();
2345     ReadClosure rc(&amp;buffer);
2346     SymbolTable::serialize_shared_table_header(&amp;rc, false);
2347     SystemDictionaryShared::serialize_dictionary_headers(&amp;rc, false);
2348     dynamic_mapinfo-&gt;close();
2349   }
2350 
2351   if (PrintSharedArchiveAndExit) {
2352     if (PrintSharedDictionary) {
2353       tty-&gt;print_cr(&quot;\nShared classes:\n&quot;);
2354       SystemDictionaryShared::print_on(tty);
2355     }
2356     if (FileMapInfo::current_info() == NULL || _archive_loading_failed) {
2357       tty-&gt;print_cr(&quot;archive is invalid&quot;);
2358       vm_exit(1);
2359     } else {
2360       tty-&gt;print_cr(&quot;archive is valid&quot;);
2361       vm_exit(0);
</pre>
</td>
<td>
<hr />
<pre>
1086 #undef fmt_stats
1087 }
1088 
1089 // Populate the shared space.
1090 
1091 class VM_PopulateDumpSharedSpace: public VM_Operation {
1092 private:
1093   GrowableArray&lt;MemRegion&gt; *_closed_archive_heap_regions;
1094   GrowableArray&lt;MemRegion&gt; *_open_archive_heap_regions;
1095 
1096   GrowableArray&lt;ArchiveHeapOopmapInfo&gt; *_closed_archive_heap_oopmaps;
1097   GrowableArray&lt;ArchiveHeapOopmapInfo&gt; *_open_archive_heap_oopmaps;
1098 
1099   void dump_java_heap_objects() NOT_CDS_JAVA_HEAP_RETURN;
1100   void dump_archive_heap_oopmaps() NOT_CDS_JAVA_HEAP_RETURN;
1101   void dump_archive_heap_oopmaps(GrowableArray&lt;MemRegion&gt;* regions,
1102                                  GrowableArray&lt;ArchiveHeapOopmapInfo&gt;* oopmaps);
1103   void dump_symbols();
1104   char* dump_read_only_tables();
1105   void print_class_stats();
<span class="line-modified">1106   void print_region_stats(FileMapInfo* map_info);</span>
1107   void print_bitmap_region_stats(size_t size, size_t total_size);
1108   void print_heap_region_stats(GrowableArray&lt;MemRegion&gt; *heap_mem,
1109                                const char *name, size_t total_size);
1110   void relocate_to_default_base_address(CHeapBitMap* ptrmap);
1111 
1112 public:
1113 
1114   VMOp_Type type() const { return VMOp_PopulateDumpSharedSpace; }
1115   void doit();   // outline because gdb sucks
1116   bool allow_nested_vm_operations() const { return true; }
1117 }; // class VM_PopulateDumpSharedSpace
1118 
1119 class SortedSymbolClosure: public SymbolClosure {
1120   GrowableArray&lt;Symbol*&gt; _symbols;
1121   virtual void do_symbol(Symbol** sym) {
1122     assert((*sym)-&gt;is_permanent(), &quot;archived symbols must be permanent&quot;);
1123     _symbols.append(*sym);
1124   }
1125   static int compare_symbols_by_address(Symbol** a, Symbol** b) {
1126     if (a[0] &lt; b[0]) {
</pre>
<hr />
<pre>
1358     }
1359     // NOTE: after this point, we shouldn&#39;t have any globals that can reach the old
1360     // objects.
1361 
1362     // We cannot use any of the objects in the heap anymore (except for the
1363     // shared strings) because their headers no longer point to valid Klasses.
1364   }
1365 
1366   static void iterate_roots(MetaspaceClosure* it) {
1367     GrowableArray&lt;Symbol*&gt;* symbols = _ssc-&gt;get_sorted_symbols();
1368     for (int i=0; i&lt;symbols-&gt;length(); i++) {
1369       it-&gt;push(symbols-&gt;adr_at(i));
1370     }
1371     if (_global_klass_objects != NULL) {
1372       // Need to fix up the pointers
1373       for (int i = 0; i &lt; _global_klass_objects-&gt;length(); i++) {
1374         // NOTE -- this requires that the vtable is NOT yet patched, or else we are hosed.
1375         it-&gt;push(_global_klass_objects-&gt;adr_at(i));
1376       }
1377     }
<span class="line-modified">1378     FileMapInfo::metaspace_pointers_do(it, false);</span>
1379     SystemDictionaryShared::dumptime_classes_do(it);
1380     Universe::metaspace_pointers_do(it);
1381     SymbolTable::metaspace_pointers_do(it);
1382     vmSymbols::metaspace_pointers_do(it);
1383 
1384     it-&gt;finish();
1385   }
1386 
1387   static Klass* get_relocated_klass(Klass* orig_klass) {
1388     assert(DumpSharedSpaces, &quot;dump time only&quot;);
1389     address* pp = _new_loc_table-&gt;lookup((address)orig_klass);
1390     assert(pp != NULL, &quot;must be&quot;);
1391     Klass* klass = (Klass*)(*pp);
1392     assert(klass-&gt;is_klass(), &quot;must be&quot;);
1393     return klass;
1394   }
1395 };
1396 
1397 DumpAllocStats* ArchiveCompactor::_alloc_stats;
1398 SortedSymbolClosure* ArchiveCompactor::_ssc;
</pre>
<hr />
<pre>
1406 }
1407 
1408 char* VM_PopulateDumpSharedSpace::dump_read_only_tables() {
1409   ArchiveCompactor::OtherROAllocMark mark;
1410 
1411   log_info(cds)(&quot;Removing java_mirror ... &quot;);
1412   if (!HeapShared::is_heap_object_archiving_allowed()) {
1413     clear_basic_type_mirrors();
1414   }
1415   remove_java_mirror_in_classes();
1416   log_info(cds)(&quot;done. &quot;);
1417 
1418   SystemDictionaryShared::write_to_archive();
1419 
1420   // Write the other data to the output array.
1421   char* start = _ro_region.top();
1422   WriteClosure wc(&amp;_ro_region);
1423   MetaspaceShared::serialize(&amp;wc);
1424 
1425   // Write the bitmaps for patching the archive heap regions
<span class="line-added">1426   _closed_archive_heap_oopmaps = NULL;</span>
<span class="line-added">1427   _open_archive_heap_oopmaps = NULL;</span>
1428   dump_archive_heap_oopmaps();
1429 
1430   return start;
1431 }
1432 
1433 void VM_PopulateDumpSharedSpace::print_class_stats() {
1434   log_info(cds)(&quot;Number of classes %d&quot;, _global_klass_objects-&gt;length());
1435   {
1436     int num_type_array = 0, num_obj_array = 0, num_inst = 0;
1437     for (int i = 0; i &lt; _global_klass_objects-&gt;length(); i++) {
1438       Klass* k = _global_klass_objects-&gt;at(i);
1439       if (k-&gt;is_instance_klass()) {
1440         num_inst ++;
1441       } else if (k-&gt;is_objArray_klass()) {
1442         num_obj_array ++;
1443       } else {
1444         assert(k-&gt;is_typeArray_klass(), &quot;sanity&quot;);
1445         num_type_array ++;
1446       }
1447     }
</pre>
<hr />
<pre>
1557   char* serialized_data = dump_read_only_tables();
1558   _ro_region.pack();
1559 
1560   // The vtable clones contain addresses of the current process.
1561   // We don&#39;t want to write these addresses into the archive.
1562   MetaspaceShared::zero_cpp_vtable_clones_for_writing();
1563 
1564   // relocate the data so that it can be mapped to Arguments::default_SharedBaseAddress()
1565   // without runtime relocation.
1566   relocate_to_default_base_address(&amp;ptrmap);
1567 
1568   // Create and write the archive file that maps the shared spaces.
1569 
1570   FileMapInfo* mapinfo = new FileMapInfo(true);
1571   mapinfo-&gt;populate_header(os::vm_allocation_granularity());
1572   mapinfo-&gt;set_serialized_data(serialized_data);
1573   mapinfo-&gt;set_cloned_vtables(cloned_vtables);
1574   mapinfo-&gt;set_i2i_entry_code_buffers(MetaspaceShared::i2i_entry_code_buffers(),
1575                                       MetaspaceShared::i2i_entry_code_buffers_size());
1576   mapinfo-&gt;open_for_write();
<span class="line-modified">1577   MetaspaceShared::write_core_archive_regions(mapinfo, _closed_archive_heap_oopmaps, _open_archive_heap_oopmaps);</span>
1578   _total_closed_archive_region_size = mapinfo-&gt;write_archive_heap_regions(
1579                                         _closed_archive_heap_regions,
1580                                         _closed_archive_heap_oopmaps,
1581                                         MetaspaceShared::first_closed_archive_heap_region,
1582                                         MetaspaceShared::max_closed_archive_heap_region);
1583   _total_open_archive_region_size = mapinfo-&gt;write_archive_heap_regions(
1584                                         _open_archive_heap_regions,
1585                                         _open_archive_heap_oopmaps,
1586                                         MetaspaceShared::first_open_archive_heap_region,
1587                                         MetaspaceShared::max_open_archive_heap_region);
1588 
1589   mapinfo-&gt;set_final_requested_base((char*)Arguments::default_SharedBaseAddress());
1590   mapinfo-&gt;set_header_crc(mapinfo-&gt;compute_header_crc());
1591   mapinfo-&gt;write_header();
<span class="line-added">1592   print_region_stats(mapinfo);</span>
1593   mapinfo-&gt;close();
1594 


1595   if (log_is_enabled(Info, cds)) {
1596     ArchiveCompactor::alloc_stats()-&gt;print_stats(int(_ro_region.used()), int(_rw_region.used()),
1597                                                  int(_mc_region.used()));
1598   }
1599 
1600   if (PrintSystemDictionaryAtExit) {
1601     SystemDictionary::print();
1602   }
1603 
1604   if (AllowArchivingWithJavaAgent) {
1605     warning(&quot;This archive was created with AllowArchivingWithJavaAgent. It should be used &quot;
1606             &quot;for testing purposes only and should not be used in a production environment&quot;);
1607   }
1608 
1609   // There may be other pending VM operations that operate on the InstanceKlasses,
1610   // which will fail because InstanceKlasses::remove_unshareable_info()
1611   // has been called. Forget these operations and exit the VM directly.
1612   vm_direct_exit(0);
1613 }
1614 
<span class="line-modified">1615 void VM_PopulateDumpSharedSpace::print_region_stats(FileMapInfo *map_info) {</span>
1616   // Print statistics of all the regions
<span class="line-modified">1617   const size_t bitmap_used = map_info-&gt;space_at(MetaspaceShared::bm)-&gt;used();</span>
<span class="line-modified">1618   const size_t bitmap_reserved = map_info-&gt;space_at(MetaspaceShared::bm)-&gt;used_aligned();</span>
1619   const size_t total_reserved = _ro_region.reserved()  + _rw_region.reserved() +
1620                                 _mc_region.reserved()  +
1621                                 bitmap_reserved +
1622                                 _total_closed_archive_region_size +
1623                                 _total_open_archive_region_size;
1624   const size_t total_bytes = _ro_region.used()  + _rw_region.used() +
1625                              _mc_region.used()  +
1626                              bitmap_used +
1627                              _total_closed_archive_region_size +
1628                              _total_open_archive_region_size;
1629   const double total_u_perc = percent_of(total_bytes, total_reserved);
1630 
1631   _mc_region.print(total_reserved);
1632   _rw_region.print(total_reserved);
1633   _ro_region.print(total_reserved);
1634   print_bitmap_region_stats(bitmap_reserved, total_reserved);
1635   print_heap_region_stats(_closed_archive_heap_regions, &quot;ca&quot;, total_reserved);
1636   print_heap_region_stats(_open_archive_heap_regions, &quot;oa&quot;, total_reserved);
1637 
1638   log_debug(cds)(&quot;total    : &quot; SIZE_FORMAT_W(9) &quot; [100.0%% of total] out of &quot; SIZE_FORMAT_W(9) &quot; bytes [%5.1f%% used]&quot;,
</pre>
<hr />
<pre>
1640 }
1641 
1642 void VM_PopulateDumpSharedSpace::print_bitmap_region_stats(size_t size, size_t total_size) {
1643   log_debug(cds)(&quot;bm  space: &quot; SIZE_FORMAT_W(9) &quot; [ %4.1f%% of total] out of &quot; SIZE_FORMAT_W(9) &quot; bytes [100.0%% used] at &quot; INTPTR_FORMAT,
1644                  size, size/double(total_size)*100.0, size, p2i(NULL));
1645 }
1646 
1647 void VM_PopulateDumpSharedSpace::print_heap_region_stats(GrowableArray&lt;MemRegion&gt; *heap_mem,
1648                                                          const char *name, size_t total_size) {
1649   int arr_len = heap_mem == NULL ? 0 : heap_mem-&gt;length();
1650   for (int i = 0; i &lt; arr_len; i++) {
1651       char* start = (char*)heap_mem-&gt;at(i).start();
1652       size_t size = heap_mem-&gt;at(i).byte_size();
1653       char* top = start + size;
1654       log_debug(cds)(&quot;%s%d space: &quot; SIZE_FORMAT_W(9) &quot; [ %4.1f%% of total] out of &quot; SIZE_FORMAT_W(9) &quot; bytes [100.0%% used] at &quot; INTPTR_FORMAT,
1655                      name, i, size, size/double(total_size)*100.0, size, p2i(start));
1656 
1657   }
1658 }
1659 
<span class="line-modified">1660 void MetaspaceShared::write_core_archive_regions(FileMapInfo* mapinfo,</span>
<span class="line-added">1661                                                  GrowableArray&lt;ArchiveHeapOopmapInfo&gt;* closed_oopmaps,</span>
<span class="line-added">1662                                                  GrowableArray&lt;ArchiveHeapOopmapInfo&gt;* open_oopmaps) {</span>
1663   // Make sure NUM_CDS_REGIONS (exported in cds.h) agrees with
1664   // MetaspaceShared::n_regions (internal to hotspot).
1665   assert(NUM_CDS_REGIONS == MetaspaceShared::n_regions, &quot;sanity&quot;);
1666 
1667   // mc contains the trampoline code for method entries, which are patched at run time,
1668   // so it needs to be read/write.
1669   write_region(mapinfo, mc, &amp;_mc_region, /*read_only=*/false,/*allow_exec=*/true);
1670   write_region(mapinfo, rw, &amp;_rw_region, /*read_only=*/false,/*allow_exec=*/false);
1671   write_region(mapinfo, ro, &amp;_ro_region, /*read_only=*/true, /*allow_exec=*/false);
<span class="line-modified">1672   mapinfo-&gt;write_bitmap_region(ArchivePtrMarker::ptrmap(), closed_oopmaps, open_oopmaps);</span>
1673 }
1674 
1675 void MetaspaceShared::write_region(FileMapInfo* mapinfo, int region_idx, DumpRegion* dump_region, bool read_only,  bool allow_exec) {
1676   mapinfo-&gt;write_region(region_idx, dump_region-&gt;base(), dump_region-&gt;used(), read_only, allow_exec);
1677 }
1678 
1679 // Update a Java object to point its Klass* to the new location after
1680 // shared archive has been compacted.
1681 void MetaspaceShared::relocate_klass_ptr(oop o) {
1682   assert(DumpSharedSpaces, &quot;sanity&quot;);
1683   Klass* k = ArchiveCompactor::get_relocated_klass(o-&gt;klass());
1684   o-&gt;set_klass(k);
1685 }
1686 
1687 Klass* MetaspaceShared::get_relocated_klass(Klass *k, bool is_final) {
1688   assert(DumpSharedSpaces, &quot;sanity&quot;);
1689   k = ArchiveCompactor::get_relocated_klass(k);
1690   if (is_final) {
1691     k = (Klass*)(address(k) + final_delta());
1692   }
1693   return k;
1694 }
1695 
1696 class LinkSharedClassesClosure : public KlassClosure {
1697   Thread* THREAD;
1698   bool    _made_progress;
1699  public:
1700   LinkSharedClassesClosure(Thread* thread) : THREAD(thread), _made_progress(false) {}
1701 
1702   void reset()               { _made_progress = false; }
1703   bool made_progress() const { return _made_progress; }
1704 
1705   void do_klass(Klass* k) {
1706     if (k-&gt;is_instance_klass()) {
1707       InstanceKlass* ik = InstanceKlass::cast(k);
<span class="line-modified">1708       // For dynamic CDS dump, only link classes loaded by the builtin class loaders.</span>
<span class="line-modified">1709       bool do_linking = DumpSharedSpaces ? true : !ik-&gt;is_shared_unregistered_class();</span>
<span class="line-modified">1710       if (do_linking) {</span>
<span class="line-modified">1711         // Link the class to cause the bytecodes to be rewritten and the</span>
<span class="line-modified">1712         // cpcache to be created. Class verification is done according</span>
<span class="line-added">1713         // to -Xverify setting.</span>
<span class="line-added">1714         _made_progress |= MetaspaceShared::try_link_class(ik, THREAD);</span>
<span class="line-added">1715         guarantee(!HAS_PENDING_EXCEPTION, &quot;exception in link_class&quot;);</span>
1716 
<span class="line-modified">1717         if (DumpSharedSpaces) {</span>
<span class="line-added">1718           // The following function is used to resolve all Strings in the statically</span>
<span class="line-added">1719           // dumped classes to archive all the Strings. The archive heap is not supported</span>
<span class="line-added">1720           // for the dynamic archive.</span>
<span class="line-added">1721           ik-&gt;constants()-&gt;resolve_class_constants(THREAD);</span>
<span class="line-added">1722         }</span>
<span class="line-added">1723       }</span>
1724     }
1725   }
1726 };
1727 
1728 void MetaspaceShared::link_and_cleanup_shared_classes(TRAPS) {
1729   // We need to iterate because verification may cause additional classes
1730   // to be loaded.
1731   LinkSharedClassesClosure link_closure(THREAD);
1732   do {
1733     link_closure.reset();
1734     ClassLoaderDataGraph::unlocked_loaded_classes_do(&amp;link_closure);
1735     guarantee(!HAS_PENDING_EXCEPTION, &quot;exception in link_class&quot;);
1736   } while (link_closure.made_progress());
1737 }
1738 
1739 void MetaspaceShared::prepare_for_dumping() {
1740   Arguments::check_unsupported_dumping_properties();
1741   ClassLoader::initialize_shared_path();
1742 }
1743 
</pre>
<hr />
<pre>
1843       if (klass-&gt;is_instance_klass()) {
1844         InstanceKlass* ik = InstanceKlass::cast(klass);
1845 
1846         // Link the class to cause the bytecodes to be rewritten and the
1847         // cpcache to be created. The linking is done as soon as classes
1848         // are loaded in order that the related data structures (klass and
1849         // cpCache) are located together.
1850         try_link_class(ik, THREAD);
1851         guarantee(!HAS_PENDING_EXCEPTION, &quot;exception in link_class&quot;);
1852       }
1853 
1854       class_count++;
1855     }
1856   }
1857 
1858   return class_count;
1859 }
1860 
1861 // Returns true if the class&#39;s status has changed
1862 bool MetaspaceShared::try_link_class(InstanceKlass* ik, TRAPS) {
<span class="line-modified">1863   Arguments::assert_is_dumping_archive();</span>
1864   if (ik-&gt;init_state() &lt; InstanceKlass::linked &amp;&amp;
1865       !SystemDictionaryShared::has_class_failed_verification(ik)) {
1866     bool saved = BytecodeVerificationLocal;
1867     if (ik-&gt;is_shared_unregistered_class() &amp;&amp; ik-&gt;class_loader() == NULL) {
1868       // The verification decision is based on BytecodeVerificationRemote
1869       // for non-system classes. Since we are using the NULL classloader
1870       // to load non-system classes for customized class loaders during dumping,
1871       // we need to temporarily change BytecodeVerificationLocal to be the same as
1872       // BytecodeVerificationRemote. Note this can cause the parent system
1873       // classes also being verified. The extra overhead is acceptable during
1874       // dumping.
1875       BytecodeVerificationLocal = BytecodeVerificationRemote;
1876     }
1877     ik-&gt;link_class(THREAD);
1878     if (HAS_PENDING_EXCEPTION) {
1879       ResourceMark rm(THREAD);
1880       log_warning(cds)(&quot;Preload Warning: Verification failed for %s&quot;,
1881                     ik-&gt;external_name());
1882       CLEAR_PENDING_EXCEPTION;
1883       SystemDictionaryShared::set_class_has_failed_verification(ik);
</pre>
<hr />
<pre>
1901   ArchiveCompactor::OtherROAllocMark mark;
1902   HeapShared::write_subgraph_info_table();
1903 }
1904 
1905 void VM_PopulateDumpSharedSpace::dump_archive_heap_oopmaps() {
1906   if (HeapShared::is_heap_object_archiving_allowed()) {
1907     _closed_archive_heap_oopmaps = new GrowableArray&lt;ArchiveHeapOopmapInfo&gt;(2);
1908     dump_archive_heap_oopmaps(_closed_archive_heap_regions, _closed_archive_heap_oopmaps);
1909 
1910     _open_archive_heap_oopmaps = new GrowableArray&lt;ArchiveHeapOopmapInfo&gt;(2);
1911     dump_archive_heap_oopmaps(_open_archive_heap_regions, _open_archive_heap_oopmaps);
1912   }
1913 }
1914 
1915 void VM_PopulateDumpSharedSpace::dump_archive_heap_oopmaps(GrowableArray&lt;MemRegion&gt;* regions,
1916                                                            GrowableArray&lt;ArchiveHeapOopmapInfo&gt;* oopmaps) {
1917   for (int i=0; i&lt;regions-&gt;length(); i++) {
1918     ResourceBitMap oopmap = HeapShared::calculate_oopmap(regions-&gt;at(i));
1919     size_t size_in_bits = oopmap.size();
1920     size_t size_in_bytes = oopmap.size_in_bytes();
<span class="line-modified">1921     uintptr_t* buffer = (uintptr_t*)NEW_C_HEAP_ARRAY(char, size_in_bytes, mtInternal);</span>
1922     oopmap.write_to(buffer, size_in_bytes);
1923     log_info(cds, heap)(&quot;Oopmap = &quot; INTPTR_FORMAT &quot; (&quot; SIZE_FORMAT_W(6) &quot; bytes) for heap region &quot;
1924                         INTPTR_FORMAT &quot; (&quot; SIZE_FORMAT_W(8) &quot; bytes)&quot;,
1925                         p2i(buffer), size_in_bytes,
1926                         p2i(regions-&gt;at(i).start()), regions-&gt;at(i).byte_size());
1927 
1928     ArchiveHeapOopmapInfo info;
1929     info._oopmap = (address)buffer;
1930     info._oopmap_size_in_bits = size_in_bits;
<span class="line-added">1931     info._oopmap_size_in_bytes = size_in_bytes;</span>
1932     oopmaps-&gt;append(info);
1933   }
1934 }
1935 #endif // INCLUDE_CDS_JAVA_HEAP
1936 
1937 void ReadClosure::do_ptr(void** p) {
1938   assert(*p == NULL, &quot;initializing previous initialized pointer.&quot;);
1939   intptr_t obj = nextPtr();
1940   assert((intptr_t)obj &gt;= 0 || (intptr_t)obj &lt; -100,
1941          &quot;hit tag while initializing ptrs.&quot;);
1942   *p = (void*)obj;
1943 }
1944 
1945 void ReadClosure::do_u4(u4* p) {
1946   intptr_t obj = nextPtr();
1947   *p = (u4)(uintx(obj));
1948 }
1949 
1950 void ReadClosure::do_bool(bool* p) {
1951   intptr_t obj = nextPtr();
</pre>
<hr />
<pre>
2335   _i2i_entry_code_buffers = static_mapinfo-&gt;i2i_entry_code_buffers();
2336   _i2i_entry_code_buffers_size = static_mapinfo-&gt;i2i_entry_code_buffers_size();
2337   char* buffer = static_mapinfo-&gt;cloned_vtables();
2338   clone_cpp_vtables((intptr_t*)buffer);
2339 
2340   // Verify various attributes of the archive, plus initialize the
2341   // shared string/symbol tables
2342   buffer = static_mapinfo-&gt;serialized_data();
2343   intptr_t* array = (intptr_t*)buffer;
2344   ReadClosure rc(&amp;array);
2345   serialize(&amp;rc);
2346 
2347   // Initialize the run-time symbol table.
2348   SymbolTable::create_table();
2349 
2350   static_mapinfo-&gt;patch_archived_heap_embedded_pointers();
2351 
2352   // Close the mapinfo file
2353   static_mapinfo-&gt;close();
2354 
<span class="line-added">2355   static_mapinfo-&gt;unmap_region(MetaspaceShared::bm);</span>
<span class="line-added">2356 </span>
2357   FileMapInfo *dynamic_mapinfo = FileMapInfo::dynamic_info();
2358   if (dynamic_mapinfo != NULL) {
2359     intptr_t* buffer = (intptr_t*)dynamic_mapinfo-&gt;serialized_data();
2360     ReadClosure rc(&amp;buffer);
2361     SymbolTable::serialize_shared_table_header(&amp;rc, false);
2362     SystemDictionaryShared::serialize_dictionary_headers(&amp;rc, false);
2363     dynamic_mapinfo-&gt;close();
2364   }
2365 
2366   if (PrintSharedArchiveAndExit) {
2367     if (PrintSharedDictionary) {
2368       tty-&gt;print_cr(&quot;\nShared classes:\n&quot;);
2369       SystemDictionaryShared::print_on(tty);
2370     }
2371     if (FileMapInfo::current_info() == NULL || _archive_loading_failed) {
2372       tty-&gt;print_cr(&quot;archive is invalid&quot;);
2373       vm_exit(1);
2374     } else {
2375       tty-&gt;print_cr(&quot;archive is valid&quot;);
2376       vm_exit(0);
</pre>
</td>
</tr>
</table>
<center><a href="memRegion.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="metaspaceShared.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
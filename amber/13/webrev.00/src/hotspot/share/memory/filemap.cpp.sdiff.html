<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/memory/filemap.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="dynamicArchive.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="filemap.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/memory/filemap.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 276     // The file/dir must exist, or it would not have been added
 277     // into ClassLoader::classpath_entry().
 278     //
 279     // If we can&#39;t access a jar file in the boot path, then we can&#39;t
 280     // make assumptions about where classes get loaded from.
 281     FileMapInfo::fail_stop(&quot;Unable to open file %s.&quot;, cpe-&gt;name());
 282   }
 283 
 284   // No need to save the name of the module file, as it will be computed at run time
 285   // to allow relocation of the JDK directory.
 286   const char* name = is_modules_image  ? &quot;&quot; : cpe-&gt;name();
 287   set_name(name, THREAD);
 288 }
 289 
 290 void SharedClassPathEntry::set_name(const char* name, TRAPS) {
 291   size_t len = strlen(name) + 1;
 292   _name = MetadataFactory::new_array&lt;char&gt;(ClassLoaderData::the_null_class_loader_data(), (int)len, THREAD);
 293   strcpy(_name-&gt;data(), name);
 294 }
 295 

















 296 const char* SharedClassPathEntry::name() const {
 297   if (UseSharedSpaces &amp;&amp; is_modules_image()) {
 298     // In order to validate the runtime modules image file size against the archived
 299     // size information, we need to obtain the runtime modules image path. The recorded
 300     // dump time modules image path in the archive may be different from the runtime path
 301     // if the JDK image has beed moved after generating the archive.
 302     return ClassLoader::get_jrt_entry()-&gt;name();
 303   } else {
 304     return _name-&gt;data();
 305   }
 306 }
 307 
 308 bool SharedClassPathEntry::validate(bool is_class_path) const {
 309   assert(UseSharedSpaces, &quot;runtime only&quot;);
 310 
 311   struct stat st;
 312   const char* name = this-&gt;name();
 313 
 314   bool ok = true;
 315   log_info(class, path)(&quot;checking shared classpath entry: %s&quot;, name);
</pre>
<hr />
<pre>
 364   it-&gt;push(&amp;_name);
 365   it-&gt;push(&amp;_manifest);
 366 }
 367 
 368 void SharedPathTable::metaspace_pointers_do(MetaspaceClosure* it) {
 369   it-&gt;push(&amp;_table);
 370   for (int i=0; i&lt;_size; i++) {
 371     path_at(i)-&gt;metaspace_pointers_do(it);
 372   }
 373 }
 374 
 375 void SharedPathTable::dumptime_init(ClassLoaderData* loader_data, Thread* THREAD) {
 376   size_t entry_size = sizeof(SharedClassPathEntry);
 377   int num_entries = 0;
 378   num_entries += ClassLoader::num_boot_classpath_entries();
 379   num_entries += ClassLoader::num_app_classpath_entries();
 380   num_entries += ClassLoader::num_module_path_entries();
 381   num_entries += FileMapInfo::num_non_existent_class_paths();
 382   size_t bytes = entry_size * num_entries;
 383 
<span class="line-modified"> 384   _table = MetadataFactory::new_array&lt;u8&gt;(loader_data, (int)(bytes + 7 / 8), THREAD);</span>
 385   _size = num_entries;
 386 }
 387 
















 388 void FileMapInfo::allocate_shared_path_table() {
 389   Arguments::assert_is_dumping_archive();
 390 
 391   EXCEPTION_MARK; // The following calls should never throw, but would exit VM on error.
 392   ClassLoaderData* loader_data = ClassLoaderData::the_null_class_loader_data();
 393   ClassPathEntry* jrt = ClassLoader::get_jrt_entry();
 394 
 395   assert(jrt != NULL,
 396          &quot;No modular java runtime image present when allocating the CDS classpath entry table&quot;);
 397 
 398   _shared_path_table.dumptime_init(loader_data, THREAD);
 399 
 400   // 1. boot class path
 401   int i = 0;
 402   i = add_shared_classpaths(i, &quot;boot&quot;,   jrt, THREAD);
 403   i = add_shared_classpaths(i, &quot;app&quot;,    ClassLoader::app_classpath_entries(), THREAD);
 404   i = add_shared_classpaths(i, &quot;module&quot;, ClassLoader::module_path_entries(), THREAD);
 405 
 406   for (int x = 0; x &lt; num_non_existent_class_paths(); x++, i++) {
 407     const char* path = _non_existent_class_paths-&gt;at(x);
 408     shared_path(i)-&gt;init_as_non_existent(path, THREAD);
 409   }
 410 
 411   assert(i == _shared_path_table.size(), &quot;number of shared path entry mismatch&quot;);


 412 }
 413 
 414 int FileMapInfo::add_shared_classpaths(int i, const char* which, ClassPathEntry *cpe, TRAPS) {
 415   while (cpe != NULL) {
 416     bool is_jrt = (cpe == ClassLoader::get_jrt_entry());
 417     const char* type = (is_jrt ? &quot;jrt&quot; : (cpe-&gt;is_jar_file() ? &quot;jar&quot; : &quot;dir&quot;));
 418     log_info(class, path)(&quot;add %s shared path (%s) %s&quot;, which, type, cpe-&gt;name());
 419     SharedClassPathEntry* ent = shared_path(i);
 420     ent-&gt;init(is_jrt, cpe, THREAD);
 421     if (cpe-&gt;is_jar_file()) {
 422       update_jar_manifest(cpe, ent, THREAD);
 423     }
 424     if (is_jrt) {
 425       cpe = ClassLoader::get_next_boot_classpath_entry(cpe);
 426     } else {
 427       cpe = cpe-&gt;next();
 428     }
 429     i++;
 430   }
 431 
</pre>
<hr />
<pre>
 920       os::close(fd);
 921       return false;
 922     }
 923     *base_archive_name = NEW_C_HEAP_ARRAY(char, name_size, mtInternal);
 924     n = os::read(fd, *base_archive_name, (unsigned int)name_size);
 925     if (n != name_size) {
 926       fail_continue(&quot;Unable to read the base archive name from the header.&quot;);
 927       FREE_C_HEAP_ARRAY(char, *base_archive_name);
 928       *base_archive_name = NULL;
 929       os::free(dynamic_header);
 930       os::close(fd);
 931       return false;
 932     }
 933   }
 934 
 935   os::free(dynamic_header);
 936   os::close(fd);
 937   return true;
 938 }
 939 
<span class="line-removed"> 940 void FileMapInfo::restore_shared_path_table() {</span>
<span class="line-removed"> 941   _shared_path_table = _current_info-&gt;header()-&gt;shared_path_table();</span>
<span class="line-removed"> 942 }</span>
<span class="line-removed"> 943 </span>
 944 // Read the FileMapInfo information from the file.
 945 
 946 bool FileMapInfo::init_from_file(int fd) {
 947   size_t sz = is_static() ? sizeof(FileMapHeader) : sizeof(DynamicArchiveHeader);
 948   size_t n = os::read(fd, header(), (unsigned int)sz);
 949   if (n != sz) {
 950     fail_continue(&quot;Unable to read the file header.&quot;);
 951     return false;
 952   }
 953 
 954   if (!Arguments::has_jimage()) {
 955     FileMapInfo::fail_continue(&quot;The shared archive file cannot be used with an exploded module build.&quot;);
 956     return false;
 957   }
 958 
 959   unsigned int expected_magic = is_static() ? CDS_ARCHIVE_MAGIC : CDS_DYNAMIC_ARCHIVE_MAGIC;
 960   if (header()-&gt;magic() != expected_magic) {
 961     log_info(cds)(&quot;_magic expected: 0x%08x&quot;, expected_magic);
 962     log_info(cds)(&quot;         actual: 0x%08x&quot;, header()-&gt;magic());
 963     FileMapInfo::fail_continue(&quot;The shared archive file has a bad magic number.&quot;);
</pre>
<hr />
<pre>
1161       target_base = DynamicArchive::buffer_to_target(base);
1162     } else {
1163       target_base = base;
1164     }
1165   }
1166 
1167   si-&gt;set_file_offset(_file_offset);
1168   char* requested_base = (target_base == NULL) ? NULL : target_base + MetaspaceShared::final_delta();
1169   log_debug(cds)(&quot;Shared file region  %d: &quot; SIZE_FORMAT_HEX_W(08)
1170                  &quot; bytes, addr &quot; INTPTR_FORMAT &quot; file offset &quot; SIZE_FORMAT_HEX_W(08),
1171                  region, size, p2i(requested_base), _file_offset);
1172 
1173   int crc = ClassLoader::crc32(0, base, (jint)size);
1174   si-&gt;init(region, target_base, size, read_only, allow_exec, crc);
1175 
1176   if (base != NULL) {
1177     write_bytes_aligned(base, size);
1178   }
1179 }
1180 















1181 
<span class="line-modified">1182 void FileMapInfo::write_bitmap_region(const CHeapBitMap* ptrmap) {</span>


1183   ResourceMark rm;
1184   size_t size_in_bits = ptrmap-&gt;size();
1185   size_t size_in_bytes = ptrmap-&gt;size_in_bytes();






1186   uintptr_t* buffer = (uintptr_t*)NEW_RESOURCE_ARRAY(char, size_in_bytes);
<span class="line-modified">1187   ptrmap-&gt;write_to(buffer, size_in_bytes);</span>
1188   header()-&gt;set_ptrmap_size_in_bits(size_in_bits);
1189 





1190   log_debug(cds)(&quot;ptrmap = &quot; INTPTR_FORMAT &quot; (&quot; SIZE_FORMAT &quot; bytes)&quot;,
1191                  p2i(buffer), size_in_bytes);
1192   write_region(MetaspaceShared::bm, (char*)buffer, size_in_bytes, /*read_only=*/true, /*allow_exec=*/false);
1193 }
1194 
1195 // Write out the given archive heap memory regions.  GC code combines multiple
1196 // consecutive archive GC regions into one MemRegion whenever possible and
1197 // produces the &#39;heap_mem&#39; array.
1198 //
1199 // If the archive heap memory size is smaller than a single dump time GC region
1200 // size, there is only one MemRegion in the array.
1201 //
1202 // If the archive heap memory size is bigger than one dump time GC region size,
1203 // the &#39;heap_mem&#39; array may contain more than one consolidated MemRegions. When
1204 // the first/bottom archive GC region is a partial GC region (with the empty
1205 // portion at the higher address within the region), one MemRegion is used for
1206 // the bottom partial archive GC region. The rest of the consecutive archive
1207 // GC regions are combined into another MemRegion.
1208 //
1209 // Here&#39;s the mapping from (archive heap GC regions) -&gt; (GrowableArray&lt;MemRegion&gt; *regions).
</pre>
<hr />
<pre>
1236               &quot;(current MaxHeapSize is &quot; SIZE_FORMAT &quot;, InitialHeapSize is &quot; SIZE_FORMAT &quot;).&quot;,
1237               MaxHeapSize, InitialHeapSize);
1238   }
1239 
1240   size_t total_size = 0;
1241   for (int i = first_region_id, arr_idx = 0;
1242            i &lt; first_region_id + max_num_regions;
1243            i++, arr_idx++) {
1244     char* start = NULL;
1245     size_t size = 0;
1246     if (arr_idx &lt; arr_len) {
1247       start = (char*)heap_mem-&gt;at(arr_idx).start();
1248       size = heap_mem-&gt;at(arr_idx).byte_size();
1249       total_size += size;
1250     }
1251 
1252     log_debug(cds)(&quot;Archive heap region %d: &quot; INTPTR_FORMAT &quot; - &quot; INTPTR_FORMAT &quot; = &quot; SIZE_FORMAT_W(8) &quot; bytes&quot;,
1253                    i, p2i(start), p2i(start + size), size);
1254     write_region(i, start, size, false, false);
1255     if (size &gt; 0) {
<span class="line-modified">1256       address oopmap = oopmaps-&gt;at(arr_idx)._oopmap;</span>
<span class="line-removed">1257       assert(oopmap &gt;= (address)SharedBaseAddress, &quot;must be&quot;);</span>
<span class="line-removed">1258       space_at(i)-&gt;init_oopmap(oopmap - (address)SharedBaseAddress,</span>
1259                                oopmaps-&gt;at(arr_idx)._oopmap_size_in_bits);
1260     }
1261   }
1262   return total_size;
1263 }
1264 
1265 // Dump bytes to file -- at the current file position.
1266 
1267 void FileMapInfo::write_bytes(const void* buffer, size_t nbytes) {
1268   assert(_file_open, &quot;must be&quot;);
1269   size_t n = os::write(_fd, buffer, (unsigned int)nbytes);
1270   if (n != nbytes) {
1271     // If the shared archive is corrupted, close it and remove it.
1272     close();
1273     remove(_full_path);
1274     fail_stop(&quot;Unable to write to shared archive file.&quot;);
1275   }
1276   _file_offset += nbytes;
1277 }
1278 
</pre>
<hr />
<pre>
1462     }
1463     si-&gt;set_mapped_from_file(true);
1464   }
1465   si-&gt;set_mapped_base(requested_addr);
1466 
1467   if (!rs.is_reserved()) {
1468     // When mapping on Windows for the first attempt, we don&#39;t reserve the address space for the regions
1469     // (Windows can&#39;t mmap into a ReservedSpace). In this case, NMT requires we call it after
1470     // os::map_memory has succeeded.
1471     assert(MetaspaceShared::use_windows_memory_mapping(), &quot;Windows memory mapping only&quot;);
1472     MemTracker::record_virtual_memory_type((address)requested_addr, mtClassShared);
1473   }
1474 
1475   if (VerifySharedSpaces &amp;&amp; !verify_region_checksum(i)) {
1476     return MAP_ARCHIVE_OTHER_FAILURE;
1477   }
1478 
1479   return MAP_ARCHIVE_SUCCESS;
1480 }
1481 
<span class="line-modified">1482 char* FileMapInfo::map_relocation_bitmap(size_t&amp; bitmap_size) {</span>

1483   FileMapRegion* si = space_at(MetaspaceShared::bm);
<span class="line-modified">1484   bitmap_size = si-&gt;used_aligned();</span>


1485   bool read_only = true, allow_exec = false;
1486   char* requested_addr = NULL; // allow OS to pick any location
1487   char* bitmap_base = os::map_memory(_fd, _full_path, si-&gt;file_offset(),
<span class="line-modified">1488                                      requested_addr, bitmap_size, read_only, allow_exec);</span>
1489   if (bitmap_base == NULL) {
1490     log_error(cds)(&quot;failed to map relocation bitmap&quot;);
1491     return NULL;
1492   }
1493 
<span class="line-modified">1494   if (VerifySharedSpaces &amp;&amp; !region_crc_check(bitmap_base, bitmap_size, si-&gt;crc())) {</span>
1495     log_error(cds)(&quot;relocation bitmap CRC error&quot;);
<span class="line-modified">1496     if (!os::unmap_memory(bitmap_base, bitmap_size)) {</span>
1497       fatal(&quot;os::unmap_memory of relocation bitmap failed&quot;);
1498     }
1499     return NULL;
1500   }
1501 


1502   return bitmap_base;
1503 }
1504 
1505 bool FileMapInfo::relocate_pointers(intx addr_delta) {
1506   log_debug(cds, reloc)(&quot;runtime archive relocation start&quot;);
<span class="line-modified">1507   size_t bitmap_size;</span>
<span class="line-removed">1508   char* bitmap_base = map_relocation_bitmap(bitmap_size);</span>
1509 
1510   if (bitmap_base == NULL) {
1511     return false;
1512   } else {
1513     size_t ptrmap_size_in_bits = header()-&gt;ptrmap_size_in_bits();
<span class="line-modified">1514     log_debug(cds, reloc)(&quot;mapped relocation bitmap @ &quot; INTPTR_FORMAT &quot; (&quot; SIZE_FORMAT</span>
<span class="line-modified">1515                           &quot; bytes = &quot; SIZE_FORMAT &quot; bits)&quot;,</span>
<span class="line-removed">1516                           p2i(bitmap_base), bitmap_size, ptrmap_size_in_bits);</span>
1517 
1518     BitMapView ptrmap((BitMap::bm_word_t*)bitmap_base, ptrmap_size_in_bits);
1519 
1520     // Patch all pointers in the the mapped region that are marked by ptrmap.
1521     address patch_base = (address)mapped_base();
1522     address patch_end  = (address)mapped_end();
1523 
1524     // the current value of the pointers to be patched must be within this
1525     // range (i.e., must be between the requesed base address, and the of the current archive).
1526     // Note: top archive may point to objects in the base archive, but not the other way around.
1527     address valid_old_base = (address)header()-&gt;requested_base_address();
1528     address valid_old_end  = valid_old_base + mapping_end_offset();
1529 
1530     // after patching, the pointers must point inside this range
1531     // (the requested location of the archive, as mapped at runtime).
1532     address valid_new_base = (address)header()-&gt;mapped_base_address();
1533     address valid_new_end  = (address)mapped_end();
1534 
1535     SharedDataRelocator&lt;false&gt; patcher((address*)patch_base, (address*)patch_end, valid_old_base, valid_old_end,
1536                                        valid_new_base, valid_new_end, addr_delta);
1537     ptrmap.iterate(&amp;patcher);
1538 
<span class="line-modified">1539     if (!os::unmap_memory(bitmap_base, bitmap_size)) {</span>
<span class="line-modified">1540       fatal(&quot;os::unmap_memory of relocation bitmap failed&quot;);</span>
<span class="line-removed">1541     }</span>
1542     log_debug(cds, reloc)(&quot;runtime archive relocation done&quot;);
1543     return true;
1544   }
1545 }
1546 
1547 size_t FileMapInfo::read_bytes(void* buffer, size_t count) {
1548   assert(_file_open, &quot;Archive file is not open&quot;);
1549   size_t n = os::read(_fd, buffer, (unsigned int)count);
1550   if (n != count) {
1551     // Close the file if there&#39;s a problem reading it.
1552     close();
1553     return 0;
1554   }
1555   _file_offset += count;
1556   return count;
1557 }
1558 
1559 address FileMapInfo::decode_start_address(FileMapRegion* spc, bool with_current_oop_encoding_mode) {
1560   size_t offset = spc-&gt;mapping_offset();
1561   assert(offset == (size_t)(uint32_t)offset, &quot;must be 32-bit only&quot;);
</pre>
<hr />
<pre>
1734   if (has_heap_regions()) {
1735     map_heap_regions_impl();
1736   }
1737 
1738   if (!HeapShared::closed_archive_heap_region_mapped()) {
1739     assert(closed_archive_heap_ranges == NULL &amp;&amp;
1740            num_closed_archive_heap_ranges == 0, &quot;sanity&quot;);
1741   }
1742 
1743   if (!HeapShared::open_archive_heap_region_mapped()) {
1744     assert(open_archive_heap_ranges == NULL &amp;&amp; num_open_archive_heap_ranges == 0, &quot;sanity&quot;);
1745   }
1746 }
1747 
1748 bool FileMapInfo::map_heap_data(MemRegion **heap_mem, int first,
1749                                 int max, int* num, bool is_open_archive) {
1750   MemRegion* regions = MemRegion::create_array(max, mtInternal);
1751 
1752   struct Cleanup {
1753     MemRegion* _regions;

1754     bool _aborted;
<span class="line-modified">1755     Cleanup(MemRegion* regions) : _regions(regions), _aborted(true) { }</span>
<span class="line-modified">1756     ~Cleanup() { if (_aborted) { FREE_C_HEAP_ARRAY(MemRegion, _regions); } }</span>
<span class="line-modified">1757   } cleanup(regions);</span>
1758 
1759   FileMapRegion* si;
1760   int region_num = 0;
1761 
1762   for (int i = first;
1763            i &lt; first + max; i++) {
1764     si = space_at(i);
1765     size_t size = si-&gt;used();
1766     if (size &gt; 0) {
1767       HeapWord* start = (HeapWord*)start_address_as_decoded_from_archive(si);
1768       regions[region_num] = MemRegion(start, size / HeapWordSize);
1769       region_num ++;
1770       log_info(cds)(&quot;Trying to map heap data: region[%d] at &quot; INTPTR_FORMAT &quot;, size = &quot; SIZE_FORMAT_W(8) &quot; bytes&quot;,
1771                     i, p2i(start), size);
1772     }
1773   }
1774 
1775   if (region_num == 0) {
1776     return false; // no archived java heap data
1777   }
</pre>
<hr />
<pre>
1821   *num = region_num;
1822   return true;
1823 }
1824 
1825 void FileMapInfo::patch_archived_heap_embedded_pointers() {
1826   if (!_heap_pointers_need_patching) {
1827     return;
1828   }
1829 
1830   patch_archived_heap_embedded_pointers(closed_archive_heap_ranges,
1831                                         num_closed_archive_heap_ranges,
1832                                         MetaspaceShared::first_closed_archive_heap_region);
1833 
1834   patch_archived_heap_embedded_pointers(open_archive_heap_ranges,
1835                                         num_open_archive_heap_ranges,
1836                                         MetaspaceShared::first_open_archive_heap_region);
1837 }
1838 
1839 void FileMapInfo::patch_archived_heap_embedded_pointers(MemRegion* ranges, int num_ranges,
1840                                                         int first_region_idx) {




1841   for (int i=0; i&lt;num_ranges; i++) {
1842     FileMapRegion* si = space_at(i + first_region_idx);
<span class="line-modified">1843     HeapShared::patch_archived_heap_embedded_pointers(ranges[i], (address)(SharedBaseAddress + si-&gt;oopmap_offset()),</span>
<span class="line-modified">1844                                                       si-&gt;oopmap_size_in_bits());</span>


1845   }
1846 }
1847 
1848 // This internally allocates objects using SystemDictionary::Object_klass(), so it
1849 // must be called after the well-known classes are resolved.
1850 void FileMapInfo::fixup_mapped_heap_regions() {
1851   // If any closed regions were found, call the fill routine to make them parseable.
1852   // Note that closed_archive_heap_ranges may be non-NULL even if no ranges were found.
1853   if (num_closed_archive_heap_ranges != 0) {
1854     assert(closed_archive_heap_ranges != NULL,
1855            &quot;Null closed_archive_heap_ranges array with non-zero count&quot;);
1856     G1CollectedHeap::heap()-&gt;fill_archive_regions(closed_archive_heap_ranges,
1857                                                   num_closed_archive_heap_ranges);
1858   }
1859 
1860   // do the same for mapped open archive heap regions
1861   if (num_open_archive_heap_ranges != 0) {
1862     assert(open_archive_heap_ranges != NULL, &quot;NULL open_archive_heap_ranges array with non-zero count&quot;);
1863     G1CollectedHeap::heap()-&gt;fill_archive_regions(open_archive_heap_ranges,
1864                                                   num_open_archive_heap_ranges);
</pre>
<hr />
<pre>
1909   char* mapped_base = si-&gt;mapped_base();
1910   size_t used = si-&gt;used();
1911   size_t size = align_up(used, os::vm_allocation_granularity());
1912 
1913   if (mapped_base != NULL &amp;&amp; size &gt; 0 &amp;&amp; si-&gt;mapped_from_file()) {
1914     log_info(cds)(&quot;Unmapping region #%d at base &quot; INTPTR_FORMAT &quot; (%s)&quot;, i, p2i(mapped_base),
1915                   shared_region_name[i]);
1916     if (!os::unmap_memory(mapped_base, size)) {
1917       fatal(&quot;os::unmap_memory failed&quot;);
1918     }
1919     si-&gt;set_mapped_base(NULL);
1920   }
1921 }
1922 
1923 void FileMapInfo::assert_mark(bool check) {
1924   if (!check) {
1925     fail_stop(&quot;Mark mismatch while restoring from shared file.&quot;);
1926   }
1927 }
1928 
<span class="line-modified">1929 void FileMapInfo::metaspace_pointers_do(MetaspaceClosure* it) {</span>
<span class="line-modified">1930   _shared_path_table.metaspace_pointers_do(it);</span>




1931 }
1932 
1933 FileMapInfo* FileMapInfo::_current_info = NULL;
1934 FileMapInfo* FileMapInfo::_dynamic_archive_info = NULL;
1935 bool FileMapInfo::_heap_pointers_need_patching = false;
1936 SharedPathTable FileMapInfo::_shared_path_table;

1937 bool FileMapInfo::_validating_shared_path_table = false;
1938 bool FileMapInfo::_memory_mapping_failed = false;
1939 GrowableArray&lt;const char*&gt;* FileMapInfo::_non_existent_class_paths = NULL;
1940 
1941 // Open the shared archive file, read and validate the header
1942 // information (version, boot classpath, etc.).  If initialization
1943 // fails, shared spaces are disabled and the file is closed. [See
1944 // fail_continue.]
1945 //
1946 // Validation of the archive is done in two steps:
1947 //
1948 // [1] validate_header() - done here.
1949 // [2] validate_shared_path_table - this is done later, because the table is in the RW
1950 //     region of the archive, which is not mapped yet.
1951 bool FileMapInfo::initialize() {
1952   assert(UseSharedSpaces, &quot;UseSharedSpaces expected.&quot;);
1953 
1954   if (JvmtiExport::should_post_class_file_load_hook() &amp;&amp; JvmtiExport::has_early_class_hook_env()) {
1955     // CDS assumes that no classes resolved in SystemDictionary::resolve_well_known_classes
1956     // are replaced at runtime by JVMTI ClassFileLoadHook. All of those classes are resolved
</pre>
</td>
<td>
<hr />
<pre>
 276     // The file/dir must exist, or it would not have been added
 277     // into ClassLoader::classpath_entry().
 278     //
 279     // If we can&#39;t access a jar file in the boot path, then we can&#39;t
 280     // make assumptions about where classes get loaded from.
 281     FileMapInfo::fail_stop(&quot;Unable to open file %s.&quot;, cpe-&gt;name());
 282   }
 283 
 284   // No need to save the name of the module file, as it will be computed at run time
 285   // to allow relocation of the JDK directory.
 286   const char* name = is_modules_image  ? &quot;&quot; : cpe-&gt;name();
 287   set_name(name, THREAD);
 288 }
 289 
 290 void SharedClassPathEntry::set_name(const char* name, TRAPS) {
 291   size_t len = strlen(name) + 1;
 292   _name = MetadataFactory::new_array&lt;char&gt;(ClassLoaderData::the_null_class_loader_data(), (int)len, THREAD);
 293   strcpy(_name-&gt;data(), name);
 294 }
 295 
<span class="line-added"> 296 void SharedClassPathEntry::copy_from(SharedClassPathEntry* ent, ClassLoaderData* loader_data, TRAPS) {</span>
<span class="line-added"> 297   _type = ent-&gt;_type;</span>
<span class="line-added"> 298   _timestamp = ent-&gt;_timestamp;</span>
<span class="line-added"> 299   _filesize = ent-&gt;_filesize;</span>
<span class="line-added"> 300   _from_class_path_attr = ent-&gt;_from_class_path_attr;</span>
<span class="line-added"> 301   set_name(ent-&gt;name(), THREAD);</span>
<span class="line-added"> 302 </span>
<span class="line-added"> 303   if (ent-&gt;is_jar() &amp;&amp; !ent-&gt;is_signed() &amp;&amp; ent-&gt;manifest() != NULL) {</span>
<span class="line-added"> 304     Array&lt;u1&gt;* buf = MetadataFactory::new_array&lt;u1&gt;(loader_data,</span>
<span class="line-added"> 305                                                     ent-&gt;manifest_size(),</span>
<span class="line-added"> 306                                                     THREAD);</span>
<span class="line-added"> 307     char* p = (char*)(buf-&gt;data());</span>
<span class="line-added"> 308     memcpy(p, ent-&gt;manifest(), ent-&gt;manifest_size());</span>
<span class="line-added"> 309     set_manifest(buf);</span>
<span class="line-added"> 310   }</span>
<span class="line-added"> 311 }</span>
<span class="line-added"> 312 </span>
 313 const char* SharedClassPathEntry::name() const {
 314   if (UseSharedSpaces &amp;&amp; is_modules_image()) {
 315     // In order to validate the runtime modules image file size against the archived
 316     // size information, we need to obtain the runtime modules image path. The recorded
 317     // dump time modules image path in the archive may be different from the runtime path
 318     // if the JDK image has beed moved after generating the archive.
 319     return ClassLoader::get_jrt_entry()-&gt;name();
 320   } else {
 321     return _name-&gt;data();
 322   }
 323 }
 324 
 325 bool SharedClassPathEntry::validate(bool is_class_path) const {
 326   assert(UseSharedSpaces, &quot;runtime only&quot;);
 327 
 328   struct stat st;
 329   const char* name = this-&gt;name();
 330 
 331   bool ok = true;
 332   log_info(class, path)(&quot;checking shared classpath entry: %s&quot;, name);
</pre>
<hr />
<pre>
 381   it-&gt;push(&amp;_name);
 382   it-&gt;push(&amp;_manifest);
 383 }
 384 
 385 void SharedPathTable::metaspace_pointers_do(MetaspaceClosure* it) {
 386   it-&gt;push(&amp;_table);
 387   for (int i=0; i&lt;_size; i++) {
 388     path_at(i)-&gt;metaspace_pointers_do(it);
 389   }
 390 }
 391 
 392 void SharedPathTable::dumptime_init(ClassLoaderData* loader_data, Thread* THREAD) {
 393   size_t entry_size = sizeof(SharedClassPathEntry);
 394   int num_entries = 0;
 395   num_entries += ClassLoader::num_boot_classpath_entries();
 396   num_entries += ClassLoader::num_app_classpath_entries();
 397   num_entries += ClassLoader::num_module_path_entries();
 398   num_entries += FileMapInfo::num_non_existent_class_paths();
 399   size_t bytes = entry_size * num_entries;
 400 
<span class="line-modified"> 401   _table = MetadataFactory::new_array&lt;u8&gt;(loader_data, (int)bytes, THREAD);</span>
 402   _size = num_entries;
 403 }
 404 
<span class="line-added"> 405 // Make a copy of the _shared_path_table for use during dynamic CDS dump.</span>
<span class="line-added"> 406 // It is needed because some Java code continues to execute after dynamic dump has finished.</span>
<span class="line-added"> 407 // However, during dynamic dump, we have modified FileMapInfo::_shared_path_table so</span>
<span class="line-added"> 408 // FileMapInfo::shared_path(i) returns incorrect information in ClassLoader::record_result().</span>
<span class="line-added"> 409 void FileMapInfo::copy_shared_path_table(ClassLoaderData* loader_data, Thread* THREAD) {</span>
<span class="line-added"> 410   size_t entry_size = sizeof(SharedClassPathEntry);</span>
<span class="line-added"> 411   size_t bytes = entry_size * _shared_path_table.size();</span>
<span class="line-added"> 412 </span>
<span class="line-added"> 413   _saved_shared_path_table = SharedPathTable(MetadataFactory::new_array&lt;u8&gt;(loader_data, (int)bytes, THREAD),</span>
<span class="line-added"> 414                                              _shared_path_table.size());</span>
<span class="line-added"> 415 </span>
<span class="line-added"> 416   for (int i = 0; i &lt; _shared_path_table.size(); i++) {</span>
<span class="line-added"> 417     _saved_shared_path_table.path_at(i)-&gt;copy_from(shared_path(i), loader_data, THREAD);</span>
<span class="line-added"> 418   }</span>
<span class="line-added"> 419 }</span>
<span class="line-added"> 420 </span>
 421 void FileMapInfo::allocate_shared_path_table() {
 422   Arguments::assert_is_dumping_archive();
 423 
 424   EXCEPTION_MARK; // The following calls should never throw, but would exit VM on error.
 425   ClassLoaderData* loader_data = ClassLoaderData::the_null_class_loader_data();
 426   ClassPathEntry* jrt = ClassLoader::get_jrt_entry();
 427 
 428   assert(jrt != NULL,
 429          &quot;No modular java runtime image present when allocating the CDS classpath entry table&quot;);
 430 
 431   _shared_path_table.dumptime_init(loader_data, THREAD);
 432 
 433   // 1. boot class path
 434   int i = 0;
 435   i = add_shared_classpaths(i, &quot;boot&quot;,   jrt, THREAD);
 436   i = add_shared_classpaths(i, &quot;app&quot;,    ClassLoader::app_classpath_entries(), THREAD);
 437   i = add_shared_classpaths(i, &quot;module&quot;, ClassLoader::module_path_entries(), THREAD);
 438 
 439   for (int x = 0; x &lt; num_non_existent_class_paths(); x++, i++) {
 440     const char* path = _non_existent_class_paths-&gt;at(x);
 441     shared_path(i)-&gt;init_as_non_existent(path, THREAD);
 442   }
 443 
 444   assert(i == _shared_path_table.size(), &quot;number of shared path entry mismatch&quot;);
<span class="line-added"> 445 </span>
<span class="line-added"> 446   copy_shared_path_table(loader_data, THREAD);</span>
 447 }
 448 
 449 int FileMapInfo::add_shared_classpaths(int i, const char* which, ClassPathEntry *cpe, TRAPS) {
 450   while (cpe != NULL) {
 451     bool is_jrt = (cpe == ClassLoader::get_jrt_entry());
 452     const char* type = (is_jrt ? &quot;jrt&quot; : (cpe-&gt;is_jar_file() ? &quot;jar&quot; : &quot;dir&quot;));
 453     log_info(class, path)(&quot;add %s shared path (%s) %s&quot;, which, type, cpe-&gt;name());
 454     SharedClassPathEntry* ent = shared_path(i);
 455     ent-&gt;init(is_jrt, cpe, THREAD);
 456     if (cpe-&gt;is_jar_file()) {
 457       update_jar_manifest(cpe, ent, THREAD);
 458     }
 459     if (is_jrt) {
 460       cpe = ClassLoader::get_next_boot_classpath_entry(cpe);
 461     } else {
 462       cpe = cpe-&gt;next();
 463     }
 464     i++;
 465   }
 466 
</pre>
<hr />
<pre>
 955       os::close(fd);
 956       return false;
 957     }
 958     *base_archive_name = NEW_C_HEAP_ARRAY(char, name_size, mtInternal);
 959     n = os::read(fd, *base_archive_name, (unsigned int)name_size);
 960     if (n != name_size) {
 961       fail_continue(&quot;Unable to read the base archive name from the header.&quot;);
 962       FREE_C_HEAP_ARRAY(char, *base_archive_name);
 963       *base_archive_name = NULL;
 964       os::free(dynamic_header);
 965       os::close(fd);
 966       return false;
 967     }
 968   }
 969 
 970   os::free(dynamic_header);
 971   os::close(fd);
 972   return true;
 973 }
 974 




 975 // Read the FileMapInfo information from the file.
 976 
 977 bool FileMapInfo::init_from_file(int fd) {
 978   size_t sz = is_static() ? sizeof(FileMapHeader) : sizeof(DynamicArchiveHeader);
 979   size_t n = os::read(fd, header(), (unsigned int)sz);
 980   if (n != sz) {
 981     fail_continue(&quot;Unable to read the file header.&quot;);
 982     return false;
 983   }
 984 
 985   if (!Arguments::has_jimage()) {
 986     FileMapInfo::fail_continue(&quot;The shared archive file cannot be used with an exploded module build.&quot;);
 987     return false;
 988   }
 989 
 990   unsigned int expected_magic = is_static() ? CDS_ARCHIVE_MAGIC : CDS_DYNAMIC_ARCHIVE_MAGIC;
 991   if (header()-&gt;magic() != expected_magic) {
 992     log_info(cds)(&quot;_magic expected: 0x%08x&quot;, expected_magic);
 993     log_info(cds)(&quot;         actual: 0x%08x&quot;, header()-&gt;magic());
 994     FileMapInfo::fail_continue(&quot;The shared archive file has a bad magic number.&quot;);
</pre>
<hr />
<pre>
1192       target_base = DynamicArchive::buffer_to_target(base);
1193     } else {
1194       target_base = base;
1195     }
1196   }
1197 
1198   si-&gt;set_file_offset(_file_offset);
1199   char* requested_base = (target_base == NULL) ? NULL : target_base + MetaspaceShared::final_delta();
1200   log_debug(cds)(&quot;Shared file region  %d: &quot; SIZE_FORMAT_HEX_W(08)
1201                  &quot; bytes, addr &quot; INTPTR_FORMAT &quot; file offset &quot; SIZE_FORMAT_HEX_W(08),
1202                  region, size, p2i(requested_base), _file_offset);
1203 
1204   int crc = ClassLoader::crc32(0, base, (jint)size);
1205   si-&gt;init(region, target_base, size, read_only, allow_exec, crc);
1206 
1207   if (base != NULL) {
1208     write_bytes_aligned(base, size);
1209   }
1210 }
1211 
<span class="line-added">1212 size_t FileMapInfo::set_oopmaps_offset(GrowableArray&lt;ArchiveHeapOopmapInfo&gt;* oopmaps, size_t curr_size) {</span>
<span class="line-added">1213   for (int i = 0; i &lt; oopmaps-&gt;length(); i++) {</span>
<span class="line-added">1214     oopmaps-&gt;at(i)._offset = curr_size;</span>
<span class="line-added">1215     curr_size += oopmaps-&gt;at(i)._oopmap_size_in_bytes;</span>
<span class="line-added">1216   }</span>
<span class="line-added">1217   return curr_size;</span>
<span class="line-added">1218 }</span>
<span class="line-added">1219 </span>
<span class="line-added">1220 size_t FileMapInfo::write_oopmaps(GrowableArray&lt;ArchiveHeapOopmapInfo&gt;* oopmaps, size_t curr_offset, uintptr_t* buffer) {</span>
<span class="line-added">1221   for (int i = 0; i &lt; oopmaps-&gt;length(); i++) {</span>
<span class="line-added">1222     memcpy(((char*)buffer) + curr_offset, oopmaps-&gt;at(i)._oopmap, oopmaps-&gt;at(i)._oopmap_size_in_bytes);</span>
<span class="line-added">1223     curr_offset += oopmaps-&gt;at(i)._oopmap_size_in_bytes;</span>
<span class="line-added">1224   }</span>
<span class="line-added">1225   return curr_offset;</span>
<span class="line-added">1226 }</span>
1227 
<span class="line-modified">1228 void FileMapInfo::write_bitmap_region(const CHeapBitMap* ptrmap,</span>
<span class="line-added">1229                                       GrowableArray&lt;ArchiveHeapOopmapInfo&gt;* closed_oopmaps,</span>
<span class="line-added">1230                                       GrowableArray&lt;ArchiveHeapOopmapInfo&gt;* open_oopmaps) {</span>
1231   ResourceMark rm;
1232   size_t size_in_bits = ptrmap-&gt;size();
1233   size_t size_in_bytes = ptrmap-&gt;size_in_bytes();
<span class="line-added">1234 </span>
<span class="line-added">1235   if (closed_oopmaps != NULL &amp;&amp; open_oopmaps != NULL) {</span>
<span class="line-added">1236     size_in_bytes = set_oopmaps_offset(closed_oopmaps, size_in_bytes);</span>
<span class="line-added">1237     size_in_bytes = set_oopmaps_offset(open_oopmaps, size_in_bytes);</span>
<span class="line-added">1238   }</span>
<span class="line-added">1239 </span>
1240   uintptr_t* buffer = (uintptr_t*)NEW_RESOURCE_ARRAY(char, size_in_bytes);
<span class="line-modified">1241   ptrmap-&gt;write_to(buffer, ptrmap-&gt;size_in_bytes());</span>
1242   header()-&gt;set_ptrmap_size_in_bits(size_in_bits);
1243 
<span class="line-added">1244   if (closed_oopmaps != NULL &amp;&amp; open_oopmaps != NULL) {</span>
<span class="line-added">1245     size_t curr_offset = write_oopmaps(closed_oopmaps, ptrmap-&gt;size_in_bytes(), buffer);</span>
<span class="line-added">1246     write_oopmaps(open_oopmaps, curr_offset, buffer);</span>
<span class="line-added">1247   }</span>
<span class="line-added">1248 </span>
1249   log_debug(cds)(&quot;ptrmap = &quot; INTPTR_FORMAT &quot; (&quot; SIZE_FORMAT &quot; bytes)&quot;,
1250                  p2i(buffer), size_in_bytes);
1251   write_region(MetaspaceShared::bm, (char*)buffer, size_in_bytes, /*read_only=*/true, /*allow_exec=*/false);
1252 }
1253 
1254 // Write out the given archive heap memory regions.  GC code combines multiple
1255 // consecutive archive GC regions into one MemRegion whenever possible and
1256 // produces the &#39;heap_mem&#39; array.
1257 //
1258 // If the archive heap memory size is smaller than a single dump time GC region
1259 // size, there is only one MemRegion in the array.
1260 //
1261 // If the archive heap memory size is bigger than one dump time GC region size,
1262 // the &#39;heap_mem&#39; array may contain more than one consolidated MemRegions. When
1263 // the first/bottom archive GC region is a partial GC region (with the empty
1264 // portion at the higher address within the region), one MemRegion is used for
1265 // the bottom partial archive GC region. The rest of the consecutive archive
1266 // GC regions are combined into another MemRegion.
1267 //
1268 // Here&#39;s the mapping from (archive heap GC regions) -&gt; (GrowableArray&lt;MemRegion&gt; *regions).
</pre>
<hr />
<pre>
1295               &quot;(current MaxHeapSize is &quot; SIZE_FORMAT &quot;, InitialHeapSize is &quot; SIZE_FORMAT &quot;).&quot;,
1296               MaxHeapSize, InitialHeapSize);
1297   }
1298 
1299   size_t total_size = 0;
1300   for (int i = first_region_id, arr_idx = 0;
1301            i &lt; first_region_id + max_num_regions;
1302            i++, arr_idx++) {
1303     char* start = NULL;
1304     size_t size = 0;
1305     if (arr_idx &lt; arr_len) {
1306       start = (char*)heap_mem-&gt;at(arr_idx).start();
1307       size = heap_mem-&gt;at(arr_idx).byte_size();
1308       total_size += size;
1309     }
1310 
1311     log_debug(cds)(&quot;Archive heap region %d: &quot; INTPTR_FORMAT &quot; - &quot; INTPTR_FORMAT &quot; = &quot; SIZE_FORMAT_W(8) &quot; bytes&quot;,
1312                    i, p2i(start), p2i(start + size), size);
1313     write_region(i, start, size, false, false);
1314     if (size &gt; 0) {
<span class="line-modified">1315       space_at(i)-&gt;init_oopmap(oopmaps-&gt;at(arr_idx)._offset,</span>


1316                                oopmaps-&gt;at(arr_idx)._oopmap_size_in_bits);
1317     }
1318   }
1319   return total_size;
1320 }
1321 
1322 // Dump bytes to file -- at the current file position.
1323 
1324 void FileMapInfo::write_bytes(const void* buffer, size_t nbytes) {
1325   assert(_file_open, &quot;must be&quot;);
1326   size_t n = os::write(_fd, buffer, (unsigned int)nbytes);
1327   if (n != nbytes) {
1328     // If the shared archive is corrupted, close it and remove it.
1329     close();
1330     remove(_full_path);
1331     fail_stop(&quot;Unable to write to shared archive file.&quot;);
1332   }
1333   _file_offset += nbytes;
1334 }
1335 
</pre>
<hr />
<pre>
1519     }
1520     si-&gt;set_mapped_from_file(true);
1521   }
1522   si-&gt;set_mapped_base(requested_addr);
1523 
1524   if (!rs.is_reserved()) {
1525     // When mapping on Windows for the first attempt, we don&#39;t reserve the address space for the regions
1526     // (Windows can&#39;t mmap into a ReservedSpace). In this case, NMT requires we call it after
1527     // os::map_memory has succeeded.
1528     assert(MetaspaceShared::use_windows_memory_mapping(), &quot;Windows memory mapping only&quot;);
1529     MemTracker::record_virtual_memory_type((address)requested_addr, mtClassShared);
1530   }
1531 
1532   if (VerifySharedSpaces &amp;&amp; !verify_region_checksum(i)) {
1533     return MAP_ARCHIVE_OTHER_FAILURE;
1534   }
1535 
1536   return MAP_ARCHIVE_SUCCESS;
1537 }
1538 
<span class="line-modified">1539 // The return value is the location of the archive relocation bitmap.</span>
<span class="line-added">1540 char* FileMapInfo::map_bitmap_region() {</span>
1541   FileMapRegion* si = space_at(MetaspaceShared::bm);
<span class="line-modified">1542   if (si-&gt;mapped_base() != NULL) {</span>
<span class="line-added">1543     return si-&gt;mapped_base();</span>
<span class="line-added">1544   }</span>
1545   bool read_only = true, allow_exec = false;
1546   char* requested_addr = NULL; // allow OS to pick any location
1547   char* bitmap_base = os::map_memory(_fd, _full_path, si-&gt;file_offset(),
<span class="line-modified">1548                                      requested_addr, si-&gt;used_aligned(), read_only, allow_exec);</span>
1549   if (bitmap_base == NULL) {
1550     log_error(cds)(&quot;failed to map relocation bitmap&quot;);
1551     return NULL;
1552   }
1553 
<span class="line-modified">1554   if (VerifySharedSpaces &amp;&amp; !region_crc_check(bitmap_base, si-&gt;used_aligned(), si-&gt;crc())) {</span>
1555     log_error(cds)(&quot;relocation bitmap CRC error&quot;);
<span class="line-modified">1556     if (!os::unmap_memory(bitmap_base, si-&gt;used_aligned())) {</span>
1557       fatal(&quot;os::unmap_memory of relocation bitmap failed&quot;);
1558     }
1559     return NULL;
1560   }
1561 
<span class="line-added">1562   si-&gt;set_mapped_base(bitmap_base);</span>
<span class="line-added">1563   si-&gt;set_mapped_from_file(true);</span>
1564   return bitmap_base;
1565 }
1566 
1567 bool FileMapInfo::relocate_pointers(intx addr_delta) {
1568   log_debug(cds, reloc)(&quot;runtime archive relocation start&quot;);
<span class="line-modified">1569   char* bitmap_base = map_bitmap_region();</span>

1570 
1571   if (bitmap_base == NULL) {
1572     return false;
1573   } else {
1574     size_t ptrmap_size_in_bits = header()-&gt;ptrmap_size_in_bits();
<span class="line-modified">1575     log_debug(cds, reloc)(&quot;mapped relocation bitmap @ &quot; INTPTR_FORMAT &quot; (&quot; SIZE_FORMAT &quot; bits)&quot;,</span>
<span class="line-modified">1576                           p2i(bitmap_base), ptrmap_size_in_bits);</span>

1577 
1578     BitMapView ptrmap((BitMap::bm_word_t*)bitmap_base, ptrmap_size_in_bits);
1579 
1580     // Patch all pointers in the the mapped region that are marked by ptrmap.
1581     address patch_base = (address)mapped_base();
1582     address patch_end  = (address)mapped_end();
1583 
1584     // the current value of the pointers to be patched must be within this
1585     // range (i.e., must be between the requesed base address, and the of the current archive).
1586     // Note: top archive may point to objects in the base archive, but not the other way around.
1587     address valid_old_base = (address)header()-&gt;requested_base_address();
1588     address valid_old_end  = valid_old_base + mapping_end_offset();
1589 
1590     // after patching, the pointers must point inside this range
1591     // (the requested location of the archive, as mapped at runtime).
1592     address valid_new_base = (address)header()-&gt;mapped_base_address();
1593     address valid_new_end  = (address)mapped_end();
1594 
1595     SharedDataRelocator&lt;false&gt; patcher((address*)patch_base, (address*)patch_end, valid_old_base, valid_old_end,
1596                                        valid_new_base, valid_new_end, addr_delta);
1597     ptrmap.iterate(&amp;patcher);
1598 
<span class="line-modified">1599     // The MetaspaceShared::bm region will be unmapped in MetaspaceShared::initialize_shared_spaces().</span>
<span class="line-modified">1600 </span>

1601     log_debug(cds, reloc)(&quot;runtime archive relocation done&quot;);
1602     return true;
1603   }
1604 }
1605 
1606 size_t FileMapInfo::read_bytes(void* buffer, size_t count) {
1607   assert(_file_open, &quot;Archive file is not open&quot;);
1608   size_t n = os::read(_fd, buffer, (unsigned int)count);
1609   if (n != count) {
1610     // Close the file if there&#39;s a problem reading it.
1611     close();
1612     return 0;
1613   }
1614   _file_offset += count;
1615   return count;
1616 }
1617 
1618 address FileMapInfo::decode_start_address(FileMapRegion* spc, bool with_current_oop_encoding_mode) {
1619   size_t offset = spc-&gt;mapping_offset();
1620   assert(offset == (size_t)(uint32_t)offset, &quot;must be 32-bit only&quot;);
</pre>
<hr />
<pre>
1793   if (has_heap_regions()) {
1794     map_heap_regions_impl();
1795   }
1796 
1797   if (!HeapShared::closed_archive_heap_region_mapped()) {
1798     assert(closed_archive_heap_ranges == NULL &amp;&amp;
1799            num_closed_archive_heap_ranges == 0, &quot;sanity&quot;);
1800   }
1801 
1802   if (!HeapShared::open_archive_heap_region_mapped()) {
1803     assert(open_archive_heap_ranges == NULL &amp;&amp; num_open_archive_heap_ranges == 0, &quot;sanity&quot;);
1804   }
1805 }
1806 
1807 bool FileMapInfo::map_heap_data(MemRegion **heap_mem, int first,
1808                                 int max, int* num, bool is_open_archive) {
1809   MemRegion* regions = MemRegion::create_array(max, mtInternal);
1810 
1811   struct Cleanup {
1812     MemRegion* _regions;
<span class="line-added">1813     uint _length;</span>
1814     bool _aborted;
<span class="line-modified">1815     Cleanup(MemRegion* regions, uint length) : _regions(regions), _length(length), _aborted(true) { }</span>
<span class="line-modified">1816     ~Cleanup() { if (_aborted) { MemRegion::destroy_array(_regions, _length); } }</span>
<span class="line-modified">1817   } cleanup(regions, max);</span>
1818 
1819   FileMapRegion* si;
1820   int region_num = 0;
1821 
1822   for (int i = first;
1823            i &lt; first + max; i++) {
1824     si = space_at(i);
1825     size_t size = si-&gt;used();
1826     if (size &gt; 0) {
1827       HeapWord* start = (HeapWord*)start_address_as_decoded_from_archive(si);
1828       regions[region_num] = MemRegion(start, size / HeapWordSize);
1829       region_num ++;
1830       log_info(cds)(&quot;Trying to map heap data: region[%d] at &quot; INTPTR_FORMAT &quot;, size = &quot; SIZE_FORMAT_W(8) &quot; bytes&quot;,
1831                     i, p2i(start), size);
1832     }
1833   }
1834 
1835   if (region_num == 0) {
1836     return false; // no archived java heap data
1837   }
</pre>
<hr />
<pre>
1881   *num = region_num;
1882   return true;
1883 }
1884 
1885 void FileMapInfo::patch_archived_heap_embedded_pointers() {
1886   if (!_heap_pointers_need_patching) {
1887     return;
1888   }
1889 
1890   patch_archived_heap_embedded_pointers(closed_archive_heap_ranges,
1891                                         num_closed_archive_heap_ranges,
1892                                         MetaspaceShared::first_closed_archive_heap_region);
1893 
1894   patch_archived_heap_embedded_pointers(open_archive_heap_ranges,
1895                                         num_open_archive_heap_ranges,
1896                                         MetaspaceShared::first_open_archive_heap_region);
1897 }
1898 
1899 void FileMapInfo::patch_archived_heap_embedded_pointers(MemRegion* ranges, int num_ranges,
1900                                                         int first_region_idx) {
<span class="line-added">1901   char* bitmap_base = map_bitmap_region();</span>
<span class="line-added">1902   if (bitmap_base == NULL) {</span>
<span class="line-added">1903     return;</span>
<span class="line-added">1904   }</span>
1905   for (int i=0; i&lt;num_ranges; i++) {
1906     FileMapRegion* si = space_at(i + first_region_idx);
<span class="line-modified">1907     HeapShared::patch_archived_heap_embedded_pointers(</span>
<span class="line-modified">1908       ranges[i],</span>
<span class="line-added">1909       (address)(space_at(MetaspaceShared::bm)-&gt;mapped_base()) + si-&gt;oopmap_offset(),</span>
<span class="line-added">1910       si-&gt;oopmap_size_in_bits());</span>
1911   }
1912 }
1913 
1914 // This internally allocates objects using SystemDictionary::Object_klass(), so it
1915 // must be called after the well-known classes are resolved.
1916 void FileMapInfo::fixup_mapped_heap_regions() {
1917   // If any closed regions were found, call the fill routine to make them parseable.
1918   // Note that closed_archive_heap_ranges may be non-NULL even if no ranges were found.
1919   if (num_closed_archive_heap_ranges != 0) {
1920     assert(closed_archive_heap_ranges != NULL,
1921            &quot;Null closed_archive_heap_ranges array with non-zero count&quot;);
1922     G1CollectedHeap::heap()-&gt;fill_archive_regions(closed_archive_heap_ranges,
1923                                                   num_closed_archive_heap_ranges);
1924   }
1925 
1926   // do the same for mapped open archive heap regions
1927   if (num_open_archive_heap_ranges != 0) {
1928     assert(open_archive_heap_ranges != NULL, &quot;NULL open_archive_heap_ranges array with non-zero count&quot;);
1929     G1CollectedHeap::heap()-&gt;fill_archive_regions(open_archive_heap_ranges,
1930                                                   num_open_archive_heap_ranges);
</pre>
<hr />
<pre>
1975   char* mapped_base = si-&gt;mapped_base();
1976   size_t used = si-&gt;used();
1977   size_t size = align_up(used, os::vm_allocation_granularity());
1978 
1979   if (mapped_base != NULL &amp;&amp; size &gt; 0 &amp;&amp; si-&gt;mapped_from_file()) {
1980     log_info(cds)(&quot;Unmapping region #%d at base &quot; INTPTR_FORMAT &quot; (%s)&quot;, i, p2i(mapped_base),
1981                   shared_region_name[i]);
1982     if (!os::unmap_memory(mapped_base, size)) {
1983       fatal(&quot;os::unmap_memory failed&quot;);
1984     }
1985     si-&gt;set_mapped_base(NULL);
1986   }
1987 }
1988 
1989 void FileMapInfo::assert_mark(bool check) {
1990   if (!check) {
1991     fail_stop(&quot;Mark mismatch while restoring from shared file.&quot;);
1992   }
1993 }
1994 
<span class="line-modified">1995 void FileMapInfo::metaspace_pointers_do(MetaspaceClosure* it, bool use_copy) {</span>
<span class="line-modified">1996   if (use_copy) {</span>
<span class="line-added">1997     _saved_shared_path_table.metaspace_pointers_do(it);</span>
<span class="line-added">1998   } else {</span>
<span class="line-added">1999     _shared_path_table.metaspace_pointers_do(it);</span>
<span class="line-added">2000   }</span>
2001 }
2002 
2003 FileMapInfo* FileMapInfo::_current_info = NULL;
2004 FileMapInfo* FileMapInfo::_dynamic_archive_info = NULL;
2005 bool FileMapInfo::_heap_pointers_need_patching = false;
2006 SharedPathTable FileMapInfo::_shared_path_table;
<span class="line-added">2007 SharedPathTable FileMapInfo::_saved_shared_path_table;</span>
2008 bool FileMapInfo::_validating_shared_path_table = false;
2009 bool FileMapInfo::_memory_mapping_failed = false;
2010 GrowableArray&lt;const char*&gt;* FileMapInfo::_non_existent_class_paths = NULL;
2011 
2012 // Open the shared archive file, read and validate the header
2013 // information (version, boot classpath, etc.).  If initialization
2014 // fails, shared spaces are disabled and the file is closed. [See
2015 // fail_continue.]
2016 //
2017 // Validation of the archive is done in two steps:
2018 //
2019 // [1] validate_header() - done here.
2020 // [2] validate_shared_path_table - this is done later, because the table is in the RW
2021 //     region of the archive, which is not mapped yet.
2022 bool FileMapInfo::initialize() {
2023   assert(UseSharedSpaces, &quot;UseSharedSpaces expected.&quot;);
2024 
2025   if (JvmtiExport::should_post_class_file_load_hook() &amp;&amp; JvmtiExport::has_early_class_hook_env()) {
2026     // CDS assumes that no classes resolved in SystemDictionary::resolve_well_known_classes
2027     // are replaced at runtime by JVMTI ClassFileLoadHook. All of those classes are resolved
</pre>
</td>
</tr>
</table>
<center><a href="dynamicArchive.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="filemap.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
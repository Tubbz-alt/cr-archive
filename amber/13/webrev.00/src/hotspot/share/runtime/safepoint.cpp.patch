diff a/src/hotspot/share/runtime/safepoint.cpp b/src/hotspot/share/runtime/safepoint.cpp
--- a/src/hotspot/share/runtime/safepoint.cpp
+++ b/src/hotspot/share/runtime/safepoint.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -138,11 +138,10 @@
 const uint64_t SafepointSynchronize::InactiveSafepointCounter = 0;
 int SafepointSynchronize::_current_jni_active_count = 0;
 
 WaitBarrier* SafepointSynchronize::_wait_barrier;
 
-static volatile bool PageArmed = false;        // safepoint polling page is RO|RW vs PROT_NONE
 static bool timeout_error_printed = false;
 
 // Statistic related
 static jlong _safepoint_begin_time = 0;
 static volatile int _nof_threads_hit_polling_page = 0;
@@ -248,17 +247,10 @@
   do {
     // Check if this has taken too long:
     if (SafepointTimeout && safepoint_limit_time < os::javaTimeNanos()) {
       print_safepoint_timeout();
     }
-    if (int(iterations) == -1) { // overflow - something is wrong.
-      // We can only overflow here when we are using global
-      // polling pages. We keep this guarantee in its original
-      // form so that searches of the bug database for this
-      // failure mode find the right bugs.
-      guarantee (!PageArmed, "invariant");
-    }
 
     p_prev = &tss_head;
     ThreadSafepointState *cur_tss = tss_head;
     while (cur_tss != NULL) {
       assert(cur_tss->is_running(), "Illegal initial state");
@@ -295,13 +287,10 @@
   // stopped by different mechanisms:
   //
   //  1. Running interpreted
   //     When executing branching/returning byte codes interpreter
   //     checks if the poll is armed, if so blocks in SS::block().
-  //     When using global polling the interpreter dispatch table
-  //     is changed to force it to check for a safepoint condition
-  //     between bytecodes.
   //  2. Running in native code
   //     When returning from the native code, a Java thread must check
   //     the safepoint _state to see if we must block.  If the
   //     VM thread sees a Java thread in native, it does
   //     not wait for this thread to block.  The order of the memory
@@ -332,30 +321,19 @@
 
   // We are synchronizing
   OrderAccess::storestore(); // Ordered with _safepoint_counter
   _state = _synchronizing;
 
-  if (SafepointMechanism::uses_thread_local_poll()) {
-    // Arming the per thread poll while having _state != _not_synchronized means safepointing
-    log_trace(safepoint)("Setting thread local yield flag for threads");
-    OrderAccess::storestore(); // storestore, global state -> local state
-    for (JavaThreadIteratorWithHandle jtiwh; JavaThread *cur = jtiwh.next(); ) {
-      // Make sure the threads start polling, it is time to yield.
-      SafepointMechanism::arm_local_poll(cur);
-    }
+  // Arming the per thread poll while having _state != _not_synchronized means safepointing
+  log_trace(safepoint)("Setting thread local yield flag for threads");
+  OrderAccess::storestore(); // storestore, global state -> local state
+  for (JavaThreadIteratorWithHandle jtiwh; JavaThread *cur = jtiwh.next(); ) {
+    // Make sure the threads start polling, it is time to yield.
+    SafepointMechanism::arm_local_poll(cur);
   }
-  OrderAccess::fence(); // storestore|storeload, global state -> local state
-
-  if (SafepointMechanism::uses_global_page_poll()) {
-    // Make interpreter safepoint aware
-    Interpreter::notice_safepoints();
 
-    // Make polling safepoint aware
-    guarantee (!PageArmed, "invariant") ;
-    PageArmed = true;
-    os::make_polling_page_unreadable();
-  }
+  OrderAccess::fence(); // storestore|storeload, global state -> local state
 }
 
 // Roll all threads forward to a safepoint and suspend them all
 void SafepointSynchronize::begin() {
   assert(Thread::current()->is_VM_thread(), "Only VM thread may execute a safepoint");
@@ -462,19 +440,10 @@
                 cur->safepoint_state()->is_at_poll_safepoint()),
               "safepoint installed a pending exception");
     }
 #endif // ASSERT
 
-    if (SafepointMechanism::uses_global_page_poll()) {
-      guarantee (PageArmed, "invariant");
-      // Make polling safepoint aware
-      os::make_polling_page_readable();
-      PageArmed = false;
-      // Remove safepoint check from interpreter
-      Interpreter::ignore_safepoints();
-    }
-
     OrderAccess::fence(); // keep read and write of _state from floating up
     assert(_state == _synchronized, "must be synchronized before ending safepoint synchronization");
 
     // Change state first to _not_synchronized.
     // No threads should see _synchronized when running.
@@ -492,12 +461,10 @@
       DEBUG_ONLY(current->reset_visited_for_critical_count(active_safepoint_counter);)
       ThreadSafepointState* cur_state = current->safepoint_state();
       assert(!cur_state->is_running(), "Thread not suspended at safepoint");
       cur_state->restart(); // TSS _running
       assert(cur_state->is_running(), "safepoint state has not been reset");
-
-      SafepointMechanism::disarm_if_needed(current, false /* NO release */);
     }
   } // ~JavaThreadIteratorWithHandle
 
   // Release threads lock, so threads can be created/destroyed again.
   Threads_lock->unlock();
@@ -734,11 +701,10 @@
     return false;
   }
 }
 
 bool SafepointSynchronize::handshake_safe(JavaThread *thread) {
-  assert(Thread::current()->is_VM_thread(), "Must be VMThread");
   if (thread->is_ext_suspended() || thread->is_terminated()) {
     return true;
   }
   JavaThreadState stable_state;
   if (try_stable_load_state(&stable_state, thread, InactiveSafepointCounter)) {
@@ -876,13 +842,10 @@
 
 
 void SafepointSynchronize::handle_polling_page_exception(JavaThread *thread) {
   assert(thread->is_Java_thread(), "polling reference encountered by VM thread");
   assert(thread->thread_state() == _thread_in_Java, "should come from Java code");
-  if (!SafepointMechanism::uses_thread_local_poll()) {
-    assert(SafepointSynchronize::is_synchronizing(), "polling encountered outside safepoint synchronization");
-  }
 
   if (log_is_enabled(Info, safepoint, stats)) {
     Atomic::inc(&_nof_threads_hit_polling_page);
   }
 
@@ -1047,15 +1010,10 @@
 // ---------------------------------------------------------------------------------------------------------------------
 
 // Block the thread at poll or poll return for safepoint/handshake.
 void ThreadSafepointState::handle_polling_page_exception() {
 
-  // If we're using a global poll, then the thread should not be
-  // marked as safepoint safe yet.
-  assert(!SafepointMechanism::uses_global_page_poll() || !_safepoint_safe,
-         "polling page exception on thread safepoint safe");
-
   // Step 1: Find the nmethod from the return address
   address real_return_addr = thread()->saved_exception_pc();
 
   CodeBlob *cb = CodeCache::find_blob(real_return_addr);
   assert(cb != NULL && cb->is_compiled(), "return address should be in nmethod");

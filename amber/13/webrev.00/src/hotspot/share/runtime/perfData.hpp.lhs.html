<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/runtime/perfData.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_RUNTIME_PERFDATA_HPP
 26 #define SHARE_RUNTIME_PERFDATA_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;runtime/perfMemory.hpp&quot;
 30 #include &quot;runtime/timer.hpp&quot;
 31 
 32 template &lt;typename T&gt; class GrowableArray;
 33 
 34 /* jvmstat global and subsystem counter name space - enumeration value
 35  * serve as an index into the PerfDataManager::_name_space[] array
 36  * containing the corresponding name space string. Only the top level
 37  * subsystem name spaces are represented here.
 38  */
 39 enum CounterNS {
 40   // top level name spaces
 41   JAVA_NS,
 42   COM_NS,
 43   SUN_NS,
 44   // subsystem name spaces
 45   JAVA_GC,              // Garbage Collection name spaces
 46   COM_GC,
 47   SUN_GC,
 48   JAVA_CI,              // Compiler name spaces
 49   COM_CI,
 50   SUN_CI,
 51   JAVA_CLS,             // Class Loader name spaces
 52   COM_CLS,
 53   SUN_CLS,
 54   JAVA_RT,              // Runtime name spaces
 55   COM_RT,
 56   SUN_RT,
 57   JAVA_OS,              // Operating System name spaces
 58   COM_OS,
 59   SUN_OS,
 60   JAVA_THREADS,         // Threads System name spaces
 61   COM_THREADS,
 62   SUN_THREADS,
 63   JAVA_PROPERTY,        // Java Property name spaces
 64   COM_PROPERTY,
 65   SUN_PROPERTY,
 66   NULL_NS,
 67   COUNTERNS_LAST = NULL_NS
 68 };
 69 
 70 /*
 71  * Classes to support access to production performance data
 72  *
 73  * The PerfData class structure is provided for creation, access, and update
 74  * of performance data (a.k.a. instrumentation) in a specific memory region
 75  * which is possibly accessible as shared memory. Although not explicitly
 76  * prevented from doing so, developers should not use the values returned
 77  * by accessor methods to make algorithmic decisions as they are potentially
 78  * extracted from a shared memory region. Although any shared memory region
 79  * created is with appropriate access restrictions, allowing read-write access
 80  * only to the principal that created the JVM, it is believed that a the
 81  * shared memory region facilitates an easier attack path than attacks
 82  * launched through mechanisms such as /proc. For this reason, it is
 83  * recommended that data returned by PerfData accessor methods be used
 84  * cautiously.
 85  *
 86  * There are three variability classifications of performance data
 87  *   Constants  -  value is written to the PerfData memory once, on creation
 88  *   Variables  -  value is modifiable, with no particular restrictions
 89  *   Counters   -  value is monotonically changing (increasing or decreasing)
 90  *
 91  * The performance data items can also have various types. The class
 92  * hierarchy and the structure of the memory region are designed to
 93  * accommodate new types as they are needed. Types are specified in
 94  * terms of Java basic types, which accommodates client applications
 95  * written in the Java programming language. The class hierarchy is:
 96  *
 97  * - PerfData (Abstract)
 98  *     - PerfLong (Abstract)
 99  *         - PerfLongConstant        (alias: PerfConstant)
100  *         - PerfLongVariant (Abstract)
101  *             - PerfLongVariable    (alias: PerfVariable)
102  *             - PerfLongCounter     (alias: PerfCounter)
103  *
104  *     - PerfByteArray (Abstract)
105  *         - PerfString (Abstract)
106  *             - PerfStringVariable
107  *             - PerfStringConstant
108  *
109  *
110  * As seen in the class hierarchy, the initially supported types are:
111  *
112  *    Long      - performance data holds a Java long type
113  *    ByteArray - performance data holds an array of Java bytes
114  *                used for holding C++ char arrays.
115  *
116  * The String type is derived from the ByteArray type.
117  *
118  * A PerfData subtype is not required to provide an implementation for
119  * each variability classification. For example, the String type provides
120  * Variable and Constant variability classifications in the PerfStringVariable
121  * and PerfStringConstant classes, but does not provide a counter type.
122  *
123  * Performance data are also described by a unit of measure. Units allow
124  * client applications to make reasonable decisions on how to treat
125  * performance data generically, preventing the need to hard-code the
126  * specifics of a particular data item in client applications. The current
127  * set of units are:
128  *
129  *   None        - the data has no units of measure
130  *   Bytes       - data is measured in bytes
131  *   Ticks       - data is measured in clock ticks
132  *   Events      - data is measured in events. For example,
133  *                 the number of garbage collection events or the
134  *                 number of methods compiled.
135  *   String      - data is not numerical. For example,
136  *                 the java command line options
137  *   Hertz       - data is a frequency
138  *
139  * The performance counters also provide a support attribute, indicating
140  * the stability of the counter as a programmatic interface. The support
141  * level is also implied by the name space in which the counter is created.
142  * The counter name space support conventions follow the Java package, class,
143  * and property support conventions:
144  *
145  *    java.*          - stable, supported interface
146  *    com.sun.*       - unstable, supported interface
147  *    sun.*           - unstable, unsupported interface
148  *
149  * In the above context, unstable is a measure of the interface support
150  * level, not the implementation stability level.
151  *
152  * Currently, instances of PerfData subtypes are considered to have
153  * a life time equal to that of the VM and are managed by the
154  * PerfDataManager class. All constructors for the PerfData class and
155  * its subtypes have protected constructors. Creation of PerfData
156  * instances is performed by invoking various create methods on the
157  * PerfDataManager class. Users should not attempt to delete these
158  * instances as the PerfDataManager class expects to perform deletion
159  * operations on exit of the VM.
160  *
161  * Examples:
162  *
163  * Creating performance counter that holds a monotonically increasing
164  * long data value with units specified in U_Bytes in the &quot;java.gc.*&quot;
165  * name space.
166  *
167  *   PerfLongCounter* foo_counter;
168  *
169  *   foo_counter = PerfDataManager::create_long_counter(JAVA_GC, &quot;foo&quot;,
170  *                                                       PerfData::U_Bytes,
171  *                                                       optionalInitialValue,
172  *                                                       CHECK);
173  *   foo_counter-&gt;inc();
174  *
175  * Creating a performance counter that holds a variably change long
176  * data value with units specified in U_Bytes in the &quot;com.sun.ci
177  * name space.
178  *
179  *   PerfLongVariable* bar_variable;
180  *   bar_variable = PerfDataManager::create_long_variable(COM_CI, &quot;bar&quot;,
181 .*                                                        PerfData::U_Bytes,
182  *                                                        optionalInitialValue,
183  *                                                        CHECK);
184  *
185  *   bar_variable-&gt;inc();
186  *   bar_variable-&gt;set_value(0);
187  *
188  * Creating a performance counter that holds a constant string value in
189  * the &quot;sun.cls.*&quot; name space.
190  *
191  *   PerfDataManager::create_string_constant(SUN_CLS, &quot;foo&quot;, string, CHECK);
192  *
193  *   Although the create_string_constant() factory method returns a pointer
194  *   to the PerfStringConstant object, it can safely be ignored. Developers
195  *   are not encouraged to access the string constant&#39;s value via this
196  *   pointer at this time due to security concerns.
197  *
198  * Creating a performance counter in an arbitrary name space that holds a
199  * value that is sampled by the StatSampler periodic task.
200  *
201  *    PerfDataManager::create_counter(&quot;foo.sampled&quot;, PerfData::U_Events,
202  *                                    &amp;my_jlong, CHECK);
203  *
204  *    In this example, the PerfData pointer can be ignored as the caller
205  *    is relying on the StatSampler PeriodicTask to sample the given
206  *    address at a regular interval. The interval is defined by the
207  *    PerfDataSamplingInterval global variable, and is applied on
208  *    a system wide basis, not on an per-counter basis.
209  *
210  * Creating a performance counter in an arbitrary name space that utilizes
211  * a helper object to return a value to the StatSampler via the take_sample()
212  * method.
213  *
214  *     class MyTimeSampler : public PerfLongSampleHelper {
215  *       public:
216  *         jlong take_sample() { return os::elapsed_counter(); }
217  *     };
218  *
219  *     PerfDataManager::create_counter(SUN_RT, &quot;helped&quot;,
220  *                                     PerfData::U_Ticks,
221  *                                     new MyTimeSampler(), CHECK);
222  *
223  *     In this example, a subtype of PerfLongSampleHelper is instantiated
224  *     and its take_sample() method is overridden to perform whatever
225  *     operation is necessary to generate the data sample. This method
226  *     will be called by the StatSampler at a regular interval, defined
227  *     by the PerfDataSamplingInterval global variable.
228  *
229  *     As before, PerfSampleHelper is an alias for PerfLongSampleHelper.
230  *
231  * For additional uses of PerfData subtypes, see the utility classes
232  * PerfTraceTime and PerfTraceTimedEvent below.
233  *
234  * Always-on non-sampled counters can be created independent of
235  * the UsePerfData flag. Counters will be created on the c-heap
236  * if UsePerfData is false.
237  *
238  * Until further notice, all PerfData objects should be created and
239  * manipulated within a guarded block. The guard variable is
240  * UsePerfData, a product flag set to true by default. This flag may
241  * be removed from the product in the future.
242  *
243  */
244 class PerfData : public CHeapObj&lt;mtInternal&gt; {
245 
246   friend class StatSampler;      // for access to protected void sample()
247   friend class PerfDataManager;  // for access to protected destructor
248   friend class VMStructs;
249 
250   public:
251 
252     // the Variability enum must be kept in synchronization with the
253     // the com.sun.hotspot.perfdata.Variability class
254     enum Variability {
255       V_Constant = 1,
256       V_Monotonic = 2,
257       V_Variable = 3,
258       V_last = V_Variable
259     };
260 
261     // the Units enum must be kept in synchronization with the
262     // the com.sun.hotspot.perfdata.Units class
263     enum Units {
264       U_None = 1,
265       U_Bytes = 2,
266       U_Ticks = 3,
267       U_Events = 4,
268       U_String = 5,
269       U_Hertz = 6,
270       U_Last = U_Hertz
271     };
272 
273     // Miscellaneous flags
274     enum Flags {
275       F_None = 0x0,
276       F_Supported = 0x1    // interface is supported - java.* and com.sun.*
277     };
278 
279   private:
280     char* _name;
281     Variability _v;
282     Units _u;
283     bool _on_c_heap;
284     Flags _flags;
285 
286     PerfDataEntry* _pdep;
287 
288   protected:
289 
290     void *_valuep;
291 
292     PerfData(CounterNS ns, const char* name, Units u, Variability v);
293     virtual ~PerfData();
294 
295     // create the entry for the PerfData item in the PerfData memory region.
296     // this region is maintained separately from the PerfData objects to
297     // facilitate its use by external processes.
298     void create_entry(BasicType dtype, size_t dsize, size_t dlen = 0);
299 
300     // sample the data item given at creation time and write its value
301     // into the its corresponding PerfMemory location.
302     virtual void sample() = 0;
303 
304   public:
305 
306     // returns a boolean indicating the validity of this object.
307     // the object is valid if and only if memory in PerfMemory
308     // region was successfully allocated.
309     inline bool is_valid() { return _valuep != NULL; }
310 
311     // returns a boolean indicating whether the underlying object
312     // was allocated in the PerfMemory region or on the C heap.
313     inline bool is_on_c_heap() { return _on_c_heap; }
314 
315     // returns a pointer to a char* containing the name of the item.
316     // The pointer returned is the pointer to a copy of the name
317     // passed to the constructor, not the pointer to the name in the
318     // PerfData memory region. This redundancy is maintained for
319     // security reasons as the PerfMemory region may be in shared
320     // memory.
321     const char* name() { return _name; }
322 
323     // returns the variability classification associated with this item
324     Variability variability() { return _v; }
325 
326     // returns the units associated with this item.
327     Units units() { return _u; }
328 
329     // returns the flags associated with this item.
330     Flags flags() { return _flags; }
331 
332     // returns the address of the data portion of the item in the
333     // PerfData memory region.
334     inline void* get_address() { return _valuep; }
335 
336     // returns the value of the data portion of the item in the
337     // PerfData memory region formatted as a string.
338     virtual int format(char* cp, int length) = 0;
339 };
340 
341 /*
342  * PerfLongSampleHelper, and its alias PerfSamplerHelper, is a base class
343  * for helper classes that rely upon the StatSampler periodic task to
344  * invoke the take_sample() method and write the value returned to its
345  * appropriate location in the PerfData memory region.
346  */
347 class PerfLongSampleHelper : public CHeapObj&lt;mtInternal&gt; {
348   public:
349     virtual jlong take_sample() = 0;
350 };
351 
352 typedef PerfLongSampleHelper PerfSampleHelper;
353 
354 
355 /*
356  * PerfLong is the base class for the various Long PerfData subtypes.
357  * it contains implementation details that are common among its derived
358  * types.
359  */
360 class PerfLong : public PerfData {
361 
362   protected:
363 
364     PerfLong(CounterNS ns, const char* namep, Units u, Variability v);
365 
366   public:
367     int format(char* buffer, int length);
368 
369     // returns the value of the data portion of the item in the
370     // PerfData memory region.
371     inline jlong get_value() { return *(jlong*)_valuep; }
372 };
373 
374 /*
375  * The PerfLongConstant class, and its alias PerfConstant, implement
376  * a PerfData subtype that holds a jlong data value that is set upon
377  * creation of an instance of this class. This class provides no
378  * methods for changing the data value stored in PerfData memory region.
379  */
380 class PerfLongConstant : public PerfLong {
381 
382   friend class PerfDataManager; // for access to protected constructor
383 
384   private:
385     // hide sample() - no need to sample constants
386     void sample() { }
387 
388   protected:
389 
390     PerfLongConstant(CounterNS ns, const char* namep, Units u,
391                      jlong initial_value=0)
392                     : PerfLong(ns, namep, u, V_Constant) {
393 
394        if (is_valid()) *(jlong*)_valuep = initial_value;
395     }
396 };
397 
398 typedef PerfLongConstant PerfConstant;
399 
400 /*
401  * The PerfLongVariant class, and its alias PerfVariant, implement
402  * a PerfData subtype that holds a jlong data value that can be modified
403  * in an unrestricted manner. This class provides the implementation details
404  * for common functionality among its derived types.
405  */
406 class PerfLongVariant : public PerfLong {
407 
408   protected:
409     jlong* _sampled;
410     PerfLongSampleHelper* _sample_helper;
411 
412     PerfLongVariant(CounterNS ns, const char* namep, Units u, Variability v,
413                     jlong initial_value=0)
414                    : PerfLong(ns, namep, u, v) {
415       if (is_valid()) *(jlong*)_valuep = initial_value;
416     }
417 
418     PerfLongVariant(CounterNS ns, const char* namep, Units u, Variability v,
419                     jlong* sampled);
420 
421     PerfLongVariant(CounterNS ns, const char* namep, Units u, Variability v,
422                     PerfLongSampleHelper* sample_helper);
423 
424     void sample();
425 
426   public:
427     inline void inc() { (*(jlong*)_valuep)++; }
428     inline void inc(jlong val) { (*(jlong*)_valuep) += val; }
429     inline void dec(jlong val) { inc(-val); }
430     inline void add(jlong val) { (*(jlong*)_valuep) += val; }
<a name="1" id="anc1"></a><span class="line-removed">431     void clear_sample_helper() { _sample_helper = NULL; }</span>
432 };
433 
434 /*
435  * The PerfLongCounter class, and its alias PerfCounter, implement
436  * a PerfData subtype that holds a jlong data value that can (should)
437  * be modified in a monotonic manner. The inc(jlong) and add(jlong)
438  * methods can be passed negative values to implement a monotonically
439  * decreasing value. However, we rely upon the programmer to honor
440  * the notion that this counter always moves in the same direction -
441  * either increasing or decreasing.
442  */
443 class PerfLongCounter : public PerfLongVariant {
444 
445   friend class PerfDataManager; // for access to protected constructor
446 
447   protected:
448 
449     PerfLongCounter(CounterNS ns, const char* namep, Units u,
450                     jlong initial_value=0)
451                    : PerfLongVariant(ns, namep, u, V_Monotonic,
452                                      initial_value) { }
453 
454     PerfLongCounter(CounterNS ns, const char* namep, Units u, jlong* sampled)
455                   : PerfLongVariant(ns, namep, u, V_Monotonic, sampled) { }
456 
457     PerfLongCounter(CounterNS ns, const char* namep, Units u,
458                     PerfLongSampleHelper* sample_helper)
459                    : PerfLongVariant(ns, namep, u, V_Monotonic,
460                                      sample_helper) { }
461 };
462 
463 typedef PerfLongCounter PerfCounter;
464 
465 /*
466  * The PerfLongVariable class, and its alias PerfVariable, implement
467  * a PerfData subtype that holds a jlong data value that can
468  * be modified in an unrestricted manner.
469  */
470 class PerfLongVariable : public PerfLongVariant {
471 
472   friend class PerfDataManager; // for access to protected constructor
473 
474   protected:
475 
476     PerfLongVariable(CounterNS ns, const char* namep, Units u,
477                      jlong initial_value=0)
478                     : PerfLongVariant(ns, namep, u, V_Variable,
479                                       initial_value) { }
480 
481     PerfLongVariable(CounterNS ns, const char* namep, Units u, jlong* sampled)
482                     : PerfLongVariant(ns, namep, u, V_Variable, sampled) { }
483 
484     PerfLongVariable(CounterNS ns, const char* namep, Units u,
485                      PerfLongSampleHelper* sample_helper)
486                     : PerfLongVariant(ns, namep, u, V_Variable,
487                                       sample_helper) { }
488 
489   public:
490     inline void set_value(jlong val) { (*(jlong*)_valuep) = val; }
491 };
492 
493 typedef PerfLongVariable PerfVariable;
494 
495 /*
496  * The PerfByteArray provides a PerfData subtype that allows the creation
497  * of a contiguous region of the PerfData memory region for storing a vector
498  * of bytes. This class is currently intended to be a base class for
499  * the PerfString class, and cannot be instantiated directly.
500  */
501 class PerfByteArray : public PerfData {
502 
503   protected:
504     jint _length;
505 
506     PerfByteArray(CounterNS ns, const char* namep, Units u, Variability v,
507                   jint length);
508 };
509 
510 class PerfString : public PerfByteArray {
511 
512   protected:
513 
514     void set_string(const char* s2);
515 
516     PerfString(CounterNS ns, const char* namep, Variability v, jint length,
517                const char* initial_value)
518               : PerfByteArray(ns, namep, U_String, v, length) {
519        if (is_valid()) set_string(initial_value);
520     }
521 
522   public:
523 
524     int format(char* buffer, int length);
525 };
526 
527 /*
528  * The PerfStringConstant class provides a PerfData sub class that
529  * allows a null terminated string of single byte characters to be
530  * stored in the PerfData memory region.
531  */
532 class PerfStringConstant : public PerfString {
533 
534   friend class PerfDataManager; // for access to protected constructor
535 
536   private:
537 
538     // hide sample() - no need to sample constants
539     void sample() { }
540 
541   protected:
542 
543     // Restrict string constant lengths to be &lt;= PerfMaxStringConstLength.
544     // This prevents long string constants, as can occur with very
545     // long classpaths or java command lines, from consuming too much
546     // PerfData memory.
547     PerfStringConstant(CounterNS ns, const char* namep,
548                        const char* initial_value);
549 };
550 
551 /*
552  * The PerfStringVariable class provides a PerfData sub class that
553  * allows a null terminated string of single byte character data
554  * to be stored in PerfData memory region. The string value can be reset
555  * after initialization. If the string value is &gt;= max_length, then
556  * it will be truncated to max_length characters. The copied string
557  * is always null terminated.
558  */
559 class PerfStringVariable : public PerfString {
560 
561   friend class PerfDataManager; // for access to protected constructor
562 
563   protected:
564 
565     // sampling of string variables are not yet supported
566     void sample() { }
567 
568     PerfStringVariable(CounterNS ns, const char* namep, jint max_length,
569                        const char* initial_value)
570                       : PerfString(ns, namep, V_Variable, max_length+1,
571                                    initial_value) { }
572 
573   public:
574     inline void set_value(const char* val) { set_string(val); }
575 };
576 
577 
578 /*
579  * The PerfDataList class is a container class for managing lists
580  * of PerfData items. The intention of this class is to allow for
581  * alternative implementations for management of list of PerfData
582  * items without impacting the code that uses the lists.
583  *
584  * The initial implementation is based upon GrowableArray. Searches
585  * on GrowableArray types is linear in nature and this may become
586  * a performance issue for creation of PerfData items, particularly
587  * from Java code where a test for existence is implemented as a
588  * search over all existing PerfData items.
589  *
590  * The abstraction is not complete. A more general container class
591  * would provide an Iterator abstraction that could be used to
592  * traverse the lists. This implementation still relies upon integer
593  * iterators and the at(int index) method. However, the GrowableArray
594  * is not directly visible outside this class and can be replaced by
595  * some other implementation, as long as that implementation provides
596  * a mechanism to iterate over the container by index.
597  */
598 class PerfDataList : public CHeapObj&lt;mtInternal&gt; {
599 
600   private:
601 
602     // GrowableArray implementation
603     typedef GrowableArray&lt;PerfData*&gt; PerfDataArray;
604 
605     PerfDataArray* _set;
606 
607     // method to search for a instrumentation object by name
608     static bool by_name(void* name, PerfData* pd);
609 
610   protected:
611     // we expose the implementation here to facilitate the clone
612     // method.
613     PerfDataArray* get_impl() { return _set; }
614 
615   public:
616 
617     // create a PerfDataList with the given initial length
618     PerfDataList(int length);
619 
620     // create a PerfDataList as a shallow copy of the given PerfDataList
621     PerfDataList(PerfDataList* p);
622 
623     ~PerfDataList();
624 
625     // return the PerfData item indicated by name,
626     // or NULL if it doesn&#39;t exist.
627     PerfData* find_by_name(const char* name);
628 
629     // return true if a PerfData item with the name specified in the
630     // argument exists, otherwise return false.
631     bool contains(const char* name) { return find_by_name(name) != NULL; }
632 
633     // return the number of PerfData items in this list
634     inline int length();
635 
636     // add a PerfData item to this list
637     inline void append(PerfData *p);
638 
639     // remove the given PerfData item from this list. When called
640     // while iterating over the list, this method will result in a
641     // change in the length of the container. The at(int index)
642     // method is also impacted by this method as elements with an
643     // index greater than the index of the element removed by this
644     // method will be shifted down by one.
645     inline void remove(PerfData *p);
646 
647     // create a new PerfDataList from this list. The new list is
648     // a shallow copy of the original list and care should be taken
649     // with respect to delete operations on the elements of the list
650     // as the are likely in use by another copy of the list.
651     PerfDataList* clone();
652 
653     // for backward compatibility with GrowableArray - need to implement
654     // some form of iterator to provide a cleaner abstraction for
655     // iteration over the container.
656     inline PerfData* at(int index);
657 };
658 
659 
660 /*
661  * The PerfDataManager class is responsible for creating PerfData
662  * subtypes via a set a factory methods and for managing lists
663  * of the various PerfData types.
664  */
665 class PerfDataManager : AllStatic {
666 
667   friend class StatSampler;   // for access to protected PerfDataList methods
668 
669   private:
670     static PerfDataList* _all;
671     static PerfDataList* _sampled;
672     static PerfDataList* _constants;
673     static const char* _name_spaces[];
674     static volatile bool _has_PerfData;
675 
676     // add a PerfData item to the list(s) of know PerfData objects
677     static void add_item(PerfData* p, bool sampled);
678 
679   protected:
680     // return the list of all known PerfData items
681     static PerfDataList* all();
682     static inline int count();
683 
684     // return the list of all known PerfData items that are to be
685     // sampled by the StatSampler.
686     static PerfDataList* sampled();
<a name="2" id="anc2"></a><span class="line-removed">687     static inline int sampled_count();</span>
688 
689     // return the list of all known PerfData items that have a
690     // variability classification of type Constant
691     static PerfDataList* constants();
<a name="3" id="anc3"></a><span class="line-removed">692     static inline int constants_count();</span>
693 
694   public:
695 
696     // method to check for the existence of a PerfData item with
697     // the given name.
698     static inline bool exists(const char* name);
699 
<a name="4" id="anc4"></a><span class="line-removed">700     // method to search for a instrumentation object by name</span>
<span class="line-removed">701     static PerfData* find_by_name(const char* name);</span>
<span class="line-removed">702 </span>
703     // method to map a CounterNS enumeration to a namespace string
704     static const char* ns_to_string(CounterNS ns) {
705       return _name_spaces[ns];
706     }
707 
708     // methods to test the interface stability of a given counter namespace
709     //
710     static bool is_stable_supported(CounterNS ns) {
711       return (ns != NULL_NS) &amp;&amp; ((ns % 3) == JAVA_NS);
712     }
713     static bool is_unstable_supported(CounterNS ns) {
714       return (ns != NULL_NS) &amp;&amp; ((ns % 3) == COM_NS);
715     }
<a name="5" id="anc5"></a><span class="line-removed">716     static bool is_unstable_unsupported(CounterNS ns) {</span>
<span class="line-removed">717       return (ns == NULL_NS) || ((ns % 3) == SUN_NS);</span>
<span class="line-removed">718     }</span>
719 
720     // methods to test the interface stability of a given counter name
721     //
722     static bool is_stable_supported(const char* name) {
723       const char* javadot = &quot;java.&quot;;
724       return strncmp(name, javadot, strlen(javadot)) == 0;
725     }
726     static bool is_unstable_supported(const char* name) {
727       const char* comdot = &quot;com.sun.&quot;;
728       return strncmp(name, comdot, strlen(comdot)) == 0;
729     }
<a name="6" id="anc6"></a><span class="line-removed">730     static bool is_unstable_unsupported(const char* name) {</span>
<span class="line-removed">731       return !(is_stable_supported(name) &amp;&amp; is_unstable_supported(name));</span>
<span class="line-removed">732     }</span>
733 
734     // method to construct counter name strings in a given name space.
735     // The string object is allocated from the Resource Area and calls
736     // to this method must be made within a ResourceMark.
737     //
738     static char* counter_name(const char* name_space, const char* name);
739 
740     // method to construct name space strings in a given name space.
741     // The string object is allocated from the Resource Area and calls
742     // to this method must be made within a ResourceMark.
743     //
744     static char* name_space(const char* name_space, const char* sub_space) {
745       return counter_name(name_space, sub_space);
746     }
747 
748     // same as above, but appends the instance number to the name space
749     //
750     static char* name_space(const char* name_space, const char* sub_space,
751                             int instance);
752     static char* name_space(const char* name_space, int instance);
753 
754 
755     // these methods provide the general interface for creating
756     // performance data resources. The types of performance data
757     // resources can be extended by adding additional create&lt;type&gt;
758     // methods.
759 
760     // Constant Types
761     static PerfStringConstant* create_string_constant(CounterNS ns,
762                                                       const char* name,
763                                                       const char *s, TRAPS);
764 
765     static PerfLongConstant* create_long_constant(CounterNS ns,
766                                                   const char* name,
767                                                   PerfData::Units u,
768                                                   jlong val, TRAPS);
769 
770 
771     // Variable Types
772     static PerfStringVariable* create_string_variable(CounterNS ns,
773                                                       const char* name,
774                                                       int max_length,
775                                                       const char *s, TRAPS);
776 
777     static PerfStringVariable* create_string_variable(CounterNS ns,
778                                                       const char* name,
779                                                       const char *s, TRAPS) {
780       return create_string_variable(ns, name, 0, s, THREAD);
781     };
782 
783     static PerfLongVariable* create_long_variable(CounterNS ns,
784                                                   const char* name,
785                                                   PerfData::Units u,
786                                                   jlong ival, TRAPS);
787 
788     static PerfLongVariable* create_long_variable(CounterNS ns,
789                                                   const char* name,
790                                                   PerfData::Units u, TRAPS) {
791       return create_long_variable(ns, name, u, (jlong)0, THREAD);
792     };
793 
794     static PerfLongVariable* create_long_variable(CounterNS, const char* name,
795                                                   PerfData::Units u,
796                                                   jlong* sp, TRAPS);
797 
798     static PerfLongVariable* create_long_variable(CounterNS ns,
799                                                   const char* name,
800                                                   PerfData::Units u,
801                                                   PerfLongSampleHelper* sh,
802                                                   TRAPS);
803 
804 
805     // Counter Types
806     static PerfLongCounter* create_long_counter(CounterNS ns, const char* name,
807                                                 PerfData::Units u,
808                                                 jlong ival, TRAPS);
809 
810     static PerfLongCounter* create_long_counter(CounterNS ns, const char* name,
811                                                 PerfData::Units u, TRAPS) {
812       return create_long_counter(ns, name, u, (jlong)0, THREAD);
813     };
814 
815     static PerfLongCounter* create_long_counter(CounterNS ns, const char* name,
816                                                 PerfData::Units u, jlong* sp,
817                                                 TRAPS);
818 
819     static PerfLongCounter* create_long_counter(CounterNS ns, const char* name,
820                                                 PerfData::Units u,
821                                                 PerfLongSampleHelper* sh,
822                                                 TRAPS);
823 
824 
825     // these creation methods are provided for ease of use. These allow
826     // Long performance data types to be created with a shorthand syntax.
827 
828     static PerfConstant* create_constant(CounterNS ns, const char* name,
829                                          PerfData::Units u, jlong val, TRAPS) {
830       return create_long_constant(ns, name, u, val, THREAD);
831     }
832 
833     static PerfVariable* create_variable(CounterNS ns, const char* name,
834                                          PerfData::Units u, jlong ival, TRAPS) {
835       return create_long_variable(ns, name, u, ival, THREAD);
836     }
837 
838     static PerfVariable* create_variable(CounterNS ns, const char* name,
839                                          PerfData::Units u, TRAPS) {
840       return create_long_variable(ns, name, u, (jlong)0, THREAD);
841     }
842 
843     static PerfVariable* create_variable(CounterNS ns, const char* name,
844                                          PerfData::Units u, jlong* sp, TRAPS) {
845       return create_long_variable(ns, name, u, sp, THREAD);
846     }
847 
848     static PerfVariable* create_variable(CounterNS ns, const char* name,
849                                          PerfData::Units u,
850                                          PerfSampleHelper* sh, TRAPS) {
851       return create_long_variable(ns, name, u, sh, THREAD);
852     }
853 
854     static PerfCounter* create_counter(CounterNS ns, const char* name,
855                                        PerfData::Units u, jlong ival, TRAPS) {
856       return create_long_counter(ns, name, u, ival, THREAD);
857     }
858 
859     static PerfCounter* create_counter(CounterNS ns, const char* name,
860                                        PerfData::Units u, TRAPS) {
861       return create_long_counter(ns, name, u, (jlong)0, THREAD);
862     }
863 
864     static PerfCounter* create_counter(CounterNS ns, const char* name,
865                                        PerfData::Units u, jlong* sp, TRAPS) {
866       return create_long_counter(ns, name, u, sp, THREAD);
867     }
868 
869     static PerfCounter* create_counter(CounterNS ns, const char* name,
870                                        PerfData::Units u,
871                                        PerfSampleHelper* sh, TRAPS) {
872       return create_long_counter(ns, name, u, sh, THREAD);
873     }
874 
875     static void destroy();
876     static bool has_PerfData() { return _has_PerfData; }
877 };
878 
879 // Useful macros to create the performance counters
880 #define NEWPERFTICKCOUNTER(counter, counter_ns, counter_name)  \
881   {counter = PerfDataManager::create_counter(counter_ns, counter_name, \
882                                              PerfData::U_Ticks,CHECK);}
883 
884 #define NEWPERFEVENTCOUNTER(counter, counter_ns, counter_name)  \
885   {counter = PerfDataManager::create_counter(counter_ns, counter_name, \
886                                              PerfData::U_Events,CHECK);}
887 
888 #define NEWPERFBYTECOUNTER(counter, counter_ns, counter_name)  \
889   {counter = PerfDataManager::create_counter(counter_ns, counter_name, \
890                                              PerfData::U_Bytes,CHECK);}
891 
892 // Utility Classes
893 
894 /*
895  * this class will administer a PerfCounter used as a time accumulator
896  * for a basic block much like the TraceTime class.
897  *
898  * Example:
899  *
900  *    static PerfCounter* my_time_counter = PerfDataManager::create_counter(&quot;my.time.counter&quot;, PerfData::U_Ticks, 0LL, CHECK);
901  *
902  *    {
903  *      PerfTraceTime ptt(my_time_counter);
904  *      // perform the operation you want to measure
905  *    }
906  *
907  * Note: use of this class does not need to occur within a guarded
908  * block. The UsePerfData guard is used with the implementation
909  * of this class.
910  */
911 class PerfTraceTime : public StackObj {
912 
913   protected:
914     elapsedTimer _t;
915     PerfLongCounter* _timerp;
<a name="7" id="anc7"></a><span class="line-removed">916     // pointer to thread-local or global recursion counter variable</span>
<span class="line-removed">917     int* _recursion_counter;</span>
918 
919   public:
<a name="8" id="anc8"></a><span class="line-modified">920     inline PerfTraceTime(PerfLongCounter* timerp) : _timerp(timerp), _recursion_counter(NULL) {</span>
921       if (!UsePerfData) return;
922       _t.start();
923     }
924 
<a name="9" id="anc9"></a><span class="line-removed">925     inline PerfTraceTime(PerfLongCounter* timerp, int* recursion_counter) : _timerp(timerp), _recursion_counter(recursion_counter) {</span>
<span class="line-removed">926       if (!UsePerfData || (_recursion_counter != NULL &amp;&amp;</span>
<span class="line-removed">927                            (*_recursion_counter)++ &gt; 0)) return;</span>
<span class="line-removed">928       _t.start();</span>
<span class="line-removed">929     }</span>
<span class="line-removed">930 </span>
931     inline void suspend() { if (!UsePerfData) return; _t.stop(); }
932     inline void resume() { if (!UsePerfData) return; _t.start(); }
933 
934     ~PerfTraceTime();
935 };
936 
937 /* The PerfTraceTimedEvent class is responsible for counting the
938  * occurrence of some event and measuring the the elapsed time of
939  * the event in two separate PerfCounter instances.
940  *
941  * Example:
942  *
943  *    static PerfCounter* my_time_counter = PerfDataManager::create_counter(&quot;my.time.counter&quot;, PerfData::U_Ticks, CHECK);
944  *    static PerfCounter* my_event_counter = PerfDataManager::create_counter(&quot;my.event.counter&quot;, PerfData::U_Events, CHECK);
945  *
946  *    {
947  *      PerfTraceTimedEvent ptte(my_time_counter, my_event_counter);
948  *      // perform the operation you want to count and measure
949  *    }
950  *
951  * Note: use of this class does not need to occur within a guarded
952  * block. The UsePerfData guard is used with the implementation
953  * of this class.
954  *
955  */
956 class PerfTraceTimedEvent : public PerfTraceTime {
957 
958   protected:
959     PerfLongCounter* _eventp;
960 
961   public:
962     inline PerfTraceTimedEvent(PerfLongCounter* timerp, PerfLongCounter* eventp): PerfTraceTime(timerp), _eventp(eventp) {
963       if (!UsePerfData) return;
964       _eventp-&gt;inc();
965     }
966 
<a name="10" id="anc10"></a><span class="line-removed">967     inline PerfTraceTimedEvent(PerfLongCounter* timerp, PerfLongCounter* eventp, int* recursion_counter): PerfTraceTime(timerp, recursion_counter), _eventp(eventp) {</span>
<span class="line-removed">968       if (!UsePerfData) return;</span>
<span class="line-removed">969       _eventp-&gt;inc();</span>
<span class="line-removed">970     }</span>
971 };
972 
973 #endif // SHARE_RUNTIME_PERFDATA_HPP
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>
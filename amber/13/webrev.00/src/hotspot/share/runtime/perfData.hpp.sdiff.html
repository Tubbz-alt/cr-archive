<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/perfData.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="perfData.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="perfData.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/perfData.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
411 
412     PerfLongVariant(CounterNS ns, const char* namep, Units u, Variability v,
413                     jlong initial_value=0)
414                    : PerfLong(ns, namep, u, v) {
415       if (is_valid()) *(jlong*)_valuep = initial_value;
416     }
417 
418     PerfLongVariant(CounterNS ns, const char* namep, Units u, Variability v,
419                     jlong* sampled);
420 
421     PerfLongVariant(CounterNS ns, const char* namep, Units u, Variability v,
422                     PerfLongSampleHelper* sample_helper);
423 
424     void sample();
425 
426   public:
427     inline void inc() { (*(jlong*)_valuep)++; }
428     inline void inc(jlong val) { (*(jlong*)_valuep) += val; }
429     inline void dec(jlong val) { inc(-val); }
430     inline void add(jlong val) { (*(jlong*)_valuep) += val; }
<span class="line-removed">431     void clear_sample_helper() { _sample_helper = NULL; }</span>
432 };
433 
434 /*
435  * The PerfLongCounter class, and its alias PerfCounter, implement
436  * a PerfData subtype that holds a jlong data value that can (should)
437  * be modified in a monotonic manner. The inc(jlong) and add(jlong)
438  * methods can be passed negative values to implement a monotonically
439  * decreasing value. However, we rely upon the programmer to honor
440  * the notion that this counter always moves in the same direction -
441  * either increasing or decreasing.
442  */
443 class PerfLongCounter : public PerfLongVariant {
444 
445   friend class PerfDataManager; // for access to protected constructor
446 
447   protected:
448 
449     PerfLongCounter(CounterNS ns, const char* namep, Units u,
450                     jlong initial_value=0)
451                    : PerfLongVariant(ns, namep, u, V_Monotonic,
</pre>
<hr />
<pre>
667   friend class StatSampler;   // for access to protected PerfDataList methods
668 
669   private:
670     static PerfDataList* _all;
671     static PerfDataList* _sampled;
672     static PerfDataList* _constants;
673     static const char* _name_spaces[];
674     static volatile bool _has_PerfData;
675 
676     // add a PerfData item to the list(s) of know PerfData objects
677     static void add_item(PerfData* p, bool sampled);
678 
679   protected:
680     // return the list of all known PerfData items
681     static PerfDataList* all();
682     static inline int count();
683 
684     // return the list of all known PerfData items that are to be
685     // sampled by the StatSampler.
686     static PerfDataList* sampled();
<span class="line-removed">687     static inline int sampled_count();</span>
688 
689     // return the list of all known PerfData items that have a
690     // variability classification of type Constant
691     static PerfDataList* constants();
<span class="line-removed">692     static inline int constants_count();</span>
693 
694   public:
695 
696     // method to check for the existence of a PerfData item with
697     // the given name.
698     static inline bool exists(const char* name);
699 
<span class="line-removed">700     // method to search for a instrumentation object by name</span>
<span class="line-removed">701     static PerfData* find_by_name(const char* name);</span>
<span class="line-removed">702 </span>
703     // method to map a CounterNS enumeration to a namespace string
704     static const char* ns_to_string(CounterNS ns) {
705       return _name_spaces[ns];
706     }
707 
708     // methods to test the interface stability of a given counter namespace
709     //
710     static bool is_stable_supported(CounterNS ns) {
711       return (ns != NULL_NS) &amp;&amp; ((ns % 3) == JAVA_NS);
712     }
713     static bool is_unstable_supported(CounterNS ns) {
714       return (ns != NULL_NS) &amp;&amp; ((ns % 3) == COM_NS);
715     }
<span class="line-removed">716     static bool is_unstable_unsupported(CounterNS ns) {</span>
<span class="line-removed">717       return (ns == NULL_NS) || ((ns % 3) == SUN_NS);</span>
<span class="line-removed">718     }</span>
719 
720     // methods to test the interface stability of a given counter name
721     //
722     static bool is_stable_supported(const char* name) {
723       const char* javadot = &quot;java.&quot;;
724       return strncmp(name, javadot, strlen(javadot)) == 0;
725     }
726     static bool is_unstable_supported(const char* name) {
727       const char* comdot = &quot;com.sun.&quot;;
728       return strncmp(name, comdot, strlen(comdot)) == 0;
729     }
<span class="line-removed">730     static bool is_unstable_unsupported(const char* name) {</span>
<span class="line-removed">731       return !(is_stable_supported(name) &amp;&amp; is_unstable_supported(name));</span>
<span class="line-removed">732     }</span>
733 
734     // method to construct counter name strings in a given name space.
735     // The string object is allocated from the Resource Area and calls
736     // to this method must be made within a ResourceMark.
737     //
738     static char* counter_name(const char* name_space, const char* name);
739 
740     // method to construct name space strings in a given name space.
741     // The string object is allocated from the Resource Area and calls
742     // to this method must be made within a ResourceMark.
743     //
744     static char* name_space(const char* name_space, const char* sub_space) {
745       return counter_name(name_space, sub_space);
746     }
747 
748     // same as above, but appends the instance number to the name space
749     //
750     static char* name_space(const char* name_space, const char* sub_space,
751                             int instance);
752     static char* name_space(const char* name_space, int instance);
</pre>
<hr />
<pre>
896  * for a basic block much like the TraceTime class.
897  *
898  * Example:
899  *
900  *    static PerfCounter* my_time_counter = PerfDataManager::create_counter(&quot;my.time.counter&quot;, PerfData::U_Ticks, 0LL, CHECK);
901  *
902  *    {
903  *      PerfTraceTime ptt(my_time_counter);
904  *      // perform the operation you want to measure
905  *    }
906  *
907  * Note: use of this class does not need to occur within a guarded
908  * block. The UsePerfData guard is used with the implementation
909  * of this class.
910  */
911 class PerfTraceTime : public StackObj {
912 
913   protected:
914     elapsedTimer _t;
915     PerfLongCounter* _timerp;
<span class="line-removed">916     // pointer to thread-local or global recursion counter variable</span>
<span class="line-removed">917     int* _recursion_counter;</span>
918 
919   public:
<span class="line-modified">920     inline PerfTraceTime(PerfLongCounter* timerp) : _timerp(timerp), _recursion_counter(NULL) {</span>
921       if (!UsePerfData) return;
922       _t.start();
923     }
924 
<span class="line-removed">925     inline PerfTraceTime(PerfLongCounter* timerp, int* recursion_counter) : _timerp(timerp), _recursion_counter(recursion_counter) {</span>
<span class="line-removed">926       if (!UsePerfData || (_recursion_counter != NULL &amp;&amp;</span>
<span class="line-removed">927                            (*_recursion_counter)++ &gt; 0)) return;</span>
<span class="line-removed">928       _t.start();</span>
<span class="line-removed">929     }</span>
<span class="line-removed">930 </span>
931     inline void suspend() { if (!UsePerfData) return; _t.stop(); }
932     inline void resume() { if (!UsePerfData) return; _t.start(); }
933 
934     ~PerfTraceTime();
935 };
936 
937 /* The PerfTraceTimedEvent class is responsible for counting the
938  * occurrence of some event and measuring the the elapsed time of
939  * the event in two separate PerfCounter instances.
940  *
941  * Example:
942  *
943  *    static PerfCounter* my_time_counter = PerfDataManager::create_counter(&quot;my.time.counter&quot;, PerfData::U_Ticks, CHECK);
944  *    static PerfCounter* my_event_counter = PerfDataManager::create_counter(&quot;my.event.counter&quot;, PerfData::U_Events, CHECK);
945  *
946  *    {
947  *      PerfTraceTimedEvent ptte(my_time_counter, my_event_counter);
948  *      // perform the operation you want to count and measure
949  *    }
950  *
951  * Note: use of this class does not need to occur within a guarded
952  * block. The UsePerfData guard is used with the implementation
953  * of this class.
954  *
955  */
956 class PerfTraceTimedEvent : public PerfTraceTime {
957 
958   protected:
959     PerfLongCounter* _eventp;
960 
961   public:
962     inline PerfTraceTimedEvent(PerfLongCounter* timerp, PerfLongCounter* eventp): PerfTraceTime(timerp), _eventp(eventp) {
963       if (!UsePerfData) return;
964       _eventp-&gt;inc();
965     }
966 
<span class="line-removed">967     inline PerfTraceTimedEvent(PerfLongCounter* timerp, PerfLongCounter* eventp, int* recursion_counter): PerfTraceTime(timerp, recursion_counter), _eventp(eventp) {</span>
<span class="line-removed">968       if (!UsePerfData) return;</span>
<span class="line-removed">969       _eventp-&gt;inc();</span>
<span class="line-removed">970     }</span>
971 };
972 
973 #endif // SHARE_RUNTIME_PERFDATA_HPP
</pre>
</td>
<td>
<hr />
<pre>
411 
412     PerfLongVariant(CounterNS ns, const char* namep, Units u, Variability v,
413                     jlong initial_value=0)
414                    : PerfLong(ns, namep, u, v) {
415       if (is_valid()) *(jlong*)_valuep = initial_value;
416     }
417 
418     PerfLongVariant(CounterNS ns, const char* namep, Units u, Variability v,
419                     jlong* sampled);
420 
421     PerfLongVariant(CounterNS ns, const char* namep, Units u, Variability v,
422                     PerfLongSampleHelper* sample_helper);
423 
424     void sample();
425 
426   public:
427     inline void inc() { (*(jlong*)_valuep)++; }
428     inline void inc(jlong val) { (*(jlong*)_valuep) += val; }
429     inline void dec(jlong val) { inc(-val); }
430     inline void add(jlong val) { (*(jlong*)_valuep) += val; }

431 };
432 
433 /*
434  * The PerfLongCounter class, and its alias PerfCounter, implement
435  * a PerfData subtype that holds a jlong data value that can (should)
436  * be modified in a monotonic manner. The inc(jlong) and add(jlong)
437  * methods can be passed negative values to implement a monotonically
438  * decreasing value. However, we rely upon the programmer to honor
439  * the notion that this counter always moves in the same direction -
440  * either increasing or decreasing.
441  */
442 class PerfLongCounter : public PerfLongVariant {
443 
444   friend class PerfDataManager; // for access to protected constructor
445 
446   protected:
447 
448     PerfLongCounter(CounterNS ns, const char* namep, Units u,
449                     jlong initial_value=0)
450                    : PerfLongVariant(ns, namep, u, V_Monotonic,
</pre>
<hr />
<pre>
666   friend class StatSampler;   // for access to protected PerfDataList methods
667 
668   private:
669     static PerfDataList* _all;
670     static PerfDataList* _sampled;
671     static PerfDataList* _constants;
672     static const char* _name_spaces[];
673     static volatile bool _has_PerfData;
674 
675     // add a PerfData item to the list(s) of know PerfData objects
676     static void add_item(PerfData* p, bool sampled);
677 
678   protected:
679     // return the list of all known PerfData items
680     static PerfDataList* all();
681     static inline int count();
682 
683     // return the list of all known PerfData items that are to be
684     // sampled by the StatSampler.
685     static PerfDataList* sampled();

686 
687     // return the list of all known PerfData items that have a
688     // variability classification of type Constant
689     static PerfDataList* constants();

690 
691   public:
692 
693     // method to check for the existence of a PerfData item with
694     // the given name.
695     static inline bool exists(const char* name);
696 



697     // method to map a CounterNS enumeration to a namespace string
698     static const char* ns_to_string(CounterNS ns) {
699       return _name_spaces[ns];
700     }
701 
702     // methods to test the interface stability of a given counter namespace
703     //
704     static bool is_stable_supported(CounterNS ns) {
705       return (ns != NULL_NS) &amp;&amp; ((ns % 3) == JAVA_NS);
706     }
707     static bool is_unstable_supported(CounterNS ns) {
708       return (ns != NULL_NS) &amp;&amp; ((ns % 3) == COM_NS);
709     }



710 
711     // methods to test the interface stability of a given counter name
712     //
713     static bool is_stable_supported(const char* name) {
714       const char* javadot = &quot;java.&quot;;
715       return strncmp(name, javadot, strlen(javadot)) == 0;
716     }
717     static bool is_unstable_supported(const char* name) {
718       const char* comdot = &quot;com.sun.&quot;;
719       return strncmp(name, comdot, strlen(comdot)) == 0;
720     }



721 
722     // method to construct counter name strings in a given name space.
723     // The string object is allocated from the Resource Area and calls
724     // to this method must be made within a ResourceMark.
725     //
726     static char* counter_name(const char* name_space, const char* name);
727 
728     // method to construct name space strings in a given name space.
729     // The string object is allocated from the Resource Area and calls
730     // to this method must be made within a ResourceMark.
731     //
732     static char* name_space(const char* name_space, const char* sub_space) {
733       return counter_name(name_space, sub_space);
734     }
735 
736     // same as above, but appends the instance number to the name space
737     //
738     static char* name_space(const char* name_space, const char* sub_space,
739                             int instance);
740     static char* name_space(const char* name_space, int instance);
</pre>
<hr />
<pre>
884  * for a basic block much like the TraceTime class.
885  *
886  * Example:
887  *
888  *    static PerfCounter* my_time_counter = PerfDataManager::create_counter(&quot;my.time.counter&quot;, PerfData::U_Ticks, 0LL, CHECK);
889  *
890  *    {
891  *      PerfTraceTime ptt(my_time_counter);
892  *      // perform the operation you want to measure
893  *    }
894  *
895  * Note: use of this class does not need to occur within a guarded
896  * block. The UsePerfData guard is used with the implementation
897  * of this class.
898  */
899 class PerfTraceTime : public StackObj {
900 
901   protected:
902     elapsedTimer _t;
903     PerfLongCounter* _timerp;


904 
905   public:
<span class="line-modified">906     inline PerfTraceTime(PerfLongCounter* timerp) : _timerp(timerp) {</span>
907       if (!UsePerfData) return;
908       _t.start();
909     }
910 






911     inline void suspend() { if (!UsePerfData) return; _t.stop(); }
912     inline void resume() { if (!UsePerfData) return; _t.start(); }
913 
914     ~PerfTraceTime();
915 };
916 
917 /* The PerfTraceTimedEvent class is responsible for counting the
918  * occurrence of some event and measuring the the elapsed time of
919  * the event in two separate PerfCounter instances.
920  *
921  * Example:
922  *
923  *    static PerfCounter* my_time_counter = PerfDataManager::create_counter(&quot;my.time.counter&quot;, PerfData::U_Ticks, CHECK);
924  *    static PerfCounter* my_event_counter = PerfDataManager::create_counter(&quot;my.event.counter&quot;, PerfData::U_Events, CHECK);
925  *
926  *    {
927  *      PerfTraceTimedEvent ptte(my_time_counter, my_event_counter);
928  *      // perform the operation you want to count and measure
929  *    }
930  *
931  * Note: use of this class does not need to occur within a guarded
932  * block. The UsePerfData guard is used with the implementation
933  * of this class.
934  *
935  */
936 class PerfTraceTimedEvent : public PerfTraceTime {
937 
938   protected:
939     PerfLongCounter* _eventp;
940 
941   public:
942     inline PerfTraceTimedEvent(PerfLongCounter* timerp, PerfLongCounter* eventp): PerfTraceTime(timerp), _eventp(eventp) {
943       if (!UsePerfData) return;
944       _eventp-&gt;inc();
945     }
946 




947 };
948 
949 #endif // SHARE_RUNTIME_PERFDATA_HPP
</pre>
</td>
</tr>
</table>
<center><a href="perfData.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="perfData.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/opto/compile.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="classes.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="compile.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/compile.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -74,10 +74,11 @@</span>
  #include &quot;runtime/stubRoutines.hpp&quot;
  #include &quot;runtime/timer.hpp&quot;
  #include &quot;utilities/align.hpp&quot;
  #include &quot;utilities/copy.hpp&quot;
  #include &quot;utilities/macros.hpp&quot;
<span class="udiff-line-added">+ #include &quot;utilities/resourceHash.hpp&quot;</span>
  
  
  // -------------------- Compile::mach_constant_base_node -----------------------
  // Constant table base node singleton.
  MachConstantBaseNode* Compile::mach_constant_base_node() {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -248,11 +249,11 @@</span>
    { ttyLocker ttyl;
      if (xtty != NULL)  xtty-&gt;head(&quot;statistics type=&#39;opto&#39;&quot;);
      Parse::print_statistics();
      PhaseCCP::print_statistics();
      PhaseRegAlloc::print_statistics();
<span class="udiff-line-modified-removed">-     Scheduling::print_statistics();</span>
<span class="udiff-line-modified-added">+     PhaseOutput::print_statistics();</span>
      PhasePeephole::print_statistics();
      PhaseIdealLoop::print_statistics();
      if (xtty != NULL)  xtty-&gt;tail(&quot;statistics&quot;);
    }
    if (_intrinsic_hist_flags[vmIntrinsics::_none] != 0) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -260,21 +261,10 @@</span>
      print_intrinsic_statistics();
    }
  }
  #endif //PRODUCT
  
<span class="udiff-line-removed">- // Support for bundling info</span>
<span class="udiff-line-removed">- Bundle* Compile::node_bundling(const Node *n) {</span>
<span class="udiff-line-removed">-   assert(valid_bundle_info(n), &quot;oob&quot;);</span>
<span class="udiff-line-removed">-   return &amp;_node_bundling_base[n-&gt;_idx];</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- bool Compile::valid_bundle_info(const Node *n) {</span>
<span class="udiff-line-removed">-   return (_node_bundling_limit &gt; n-&gt;_idx);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- </span>
  void Compile::gvn_replace_by(Node* n, Node* nn) {
    for (DUIterator_Last imin, i = n-&gt;last_outs(imin); i &gt;= imin; ) {
      Node* use = n-&gt;last_out(i);
      bool is_in_table = initial_gvn()-&gt;hash_delete(use);
      uint uses_found = 0;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -421,28 +411,10 @@</span>
    remove_useless_late_inlines(&amp;_boxing_late_inlines, useful);
    remove_useless_late_inlines(&amp;_late_inlines, useful);
    debug_only(verify_graph_edges(true/*check for no_dead_code*/);)
  }
  
<span class="udiff-line-removed">- //------------------------------frame_size_in_words-----------------------------</span>
<span class="udiff-line-removed">- // frame_slots in units of words</span>
<span class="udiff-line-removed">- int Compile::frame_size_in_words() const {</span>
<span class="udiff-line-removed">-   // shift is 0 in LP32 and 1 in LP64</span>
<span class="udiff-line-removed">-   const int shift = (LogBytesPerWord - LogBytesPerInt);</span>
<span class="udiff-line-removed">-   int words = _frame_slots &gt;&gt; shift;</span>
<span class="udiff-line-removed">-   assert( words &lt;&lt; shift == _frame_slots, &quot;frame size must be properly aligned in LP64&quot; );</span>
<span class="udiff-line-removed">-   return words;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- // To bang the stack of this compiled method we use the stack size</span>
<span class="udiff-line-removed">- // that the interpreter would need in case of a deoptimization. This</span>
<span class="udiff-line-removed">- // removes the need to bang the stack in the deoptimization blob which</span>
<span class="udiff-line-removed">- // in turn simplifies stack overflow handling.</span>
<span class="udiff-line-removed">- int Compile::bang_size_in_bytes() const {</span>
<span class="udiff-line-removed">-   return MAX2(frame_size_in_bytes() + os::extra_bang_size_in_bytes(), _interpreter_frame_size);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  // ============================================================================
  //------------------------------CompileWrapper---------------------------------
  class CompileWrapper : public StackObj {
    Compile *const _compile;
   public:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -466,18 +438,15 @@</span>
    compile-&gt;set_last_tf(NULL, NULL);
    compile-&gt;set_indexSet_arena(NULL);
    compile-&gt;set_indexSet_free_block_list(NULL);
    compile-&gt;init_type_arena();
    Type::Initialize(compile);
<span class="udiff-line-removed">-   _compile-&gt;set_scratch_buffer_blob(NULL);</span>
    _compile-&gt;begin_method();
    _compile-&gt;clone_map().set_debug(_compile-&gt;has_method() &amp;&amp; _compile-&gt;directive()-&gt;CloneMapDebugOption);
  }
  CompileWrapper::~CompileWrapper() {
    _compile-&gt;end_method();
<span class="udiff-line-removed">-   if (_compile-&gt;scratch_buffer_blob() != NULL)</span>
<span class="udiff-line-removed">-     BufferBlob::free(_compile-&gt;scratch_buffer_blob());</span>
    _compile-&gt;env()-&gt;set_compiler_data(NULL);
  }
  
  
  //----------------------------print_compile_messages---------------------------
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -518,117 +487,19 @@</span>
      }
    }
  #endif
  }
  
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- //-----------------------init_scratch_buffer_blob------------------------------</span>
<span class="udiff-line-removed">- // Construct a temporary BufferBlob and cache it for this compile.</span>
<span class="udiff-line-removed">- void Compile::init_scratch_buffer_blob(int const_size) {</span>
<span class="udiff-line-removed">-   // If there is already a scratch buffer blob allocated and the</span>
<span class="udiff-line-removed">-   // constant section is big enough, use it.  Otherwise free the</span>
<span class="udiff-line-removed">-   // current and allocate a new one.</span>
<span class="udiff-line-removed">-   BufferBlob* blob = scratch_buffer_blob();</span>
<span class="udiff-line-removed">-   if ((blob != NULL) &amp;&amp; (const_size &lt;= _scratch_const_size)) {</span>
<span class="udiff-line-removed">-     // Use the current blob.</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     if (blob != NULL) {</span>
<span class="udiff-line-removed">-       BufferBlob::free(blob);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     ResourceMark rm;</span>
<span class="udiff-line-removed">-     _scratch_const_size = const_size;</span>
<span class="udiff-line-removed">-     int size = C2Compiler::initial_code_buffer_size(const_size);</span>
<span class="udiff-line-removed">-     blob = BufferBlob::create(&quot;Compile::scratch_buffer&quot;, size);</span>
<span class="udiff-line-removed">-     // Record the buffer blob for next time.</span>
<span class="udiff-line-removed">-     set_scratch_buffer_blob(blob);</span>
<span class="udiff-line-removed">-     // Have we run out of code space?</span>
<span class="udiff-line-removed">-     if (scratch_buffer_blob() == NULL) {</span>
<span class="udiff-line-removed">-       // Let CompilerBroker disable further compilations.</span>
<span class="udiff-line-removed">-       record_failure(&quot;Not enough space for scratch buffer in CodeCache&quot;);</span>
<span class="udiff-line-removed">-       return;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Initialize the relocation buffers</span>
<span class="udiff-line-removed">-   relocInfo* locs_buf = (relocInfo*) blob-&gt;content_end() - MAX_locs_size;</span>
<span class="udiff-line-removed">-   set_scratch_locs_memory(locs_buf);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- //-----------------------scratch_emit_size-------------------------------------</span>
<span class="udiff-line-removed">- // Helper function that computes size by emitting code</span>
<span class="udiff-line-removed">- uint Compile::scratch_emit_size(const Node* n) {</span>
<span class="udiff-line-removed">-   // Start scratch_emit_size section.</span>
<span class="udiff-line-removed">-   set_in_scratch_emit_size(true);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Emit into a trash buffer and count bytes emitted.</span>
<span class="udiff-line-removed">-   // This is a pretty expensive way to compute a size,</span>
<span class="udiff-line-removed">-   // but it works well enough if seldom used.</span>
<span class="udiff-line-removed">-   // All common fixed-size instructions are given a size</span>
<span class="udiff-line-removed">-   // method by the AD file.</span>
<span class="udiff-line-removed">-   // Note that the scratch buffer blob and locs memory are</span>
<span class="udiff-line-removed">-   // allocated at the beginning of the compile task, and</span>
<span class="udiff-line-removed">-   // may be shared by several calls to scratch_emit_size.</span>
<span class="udiff-line-removed">-   // The allocation of the scratch buffer blob is particularly</span>
<span class="udiff-line-removed">-   // expensive, since it has to grab the code cache lock.</span>
<span class="udiff-line-removed">-   BufferBlob* blob = this-&gt;scratch_buffer_blob();</span>
<span class="udiff-line-removed">-   assert(blob != NULL, &quot;Initialize BufferBlob at start&quot;);</span>
<span class="udiff-line-removed">-   assert(blob-&gt;size() &gt; MAX_inst_size, &quot;sanity&quot;);</span>
<span class="udiff-line-removed">-   relocInfo* locs_buf = scratch_locs_memory();</span>
<span class="udiff-line-removed">-   address blob_begin = blob-&gt;content_begin();</span>
<span class="udiff-line-removed">-   address blob_end   = (address)locs_buf;</span>
<span class="udiff-line-removed">-   assert(blob-&gt;contains(blob_end), &quot;sanity&quot;);</span>
<span class="udiff-line-removed">-   CodeBuffer buf(blob_begin, blob_end - blob_begin);</span>
<span class="udiff-line-removed">-   buf.initialize_consts_size(_scratch_const_size);</span>
<span class="udiff-line-removed">-   buf.initialize_stubs_size(MAX_stubs_size);</span>
<span class="udiff-line-removed">-   assert(locs_buf != NULL, &quot;sanity&quot;);</span>
<span class="udiff-line-removed">-   int lsize = MAX_locs_size / 3;</span>
<span class="udiff-line-removed">-   buf.consts()-&gt;initialize_shared_locs(&amp;locs_buf[lsize * 0], lsize);</span>
<span class="udiff-line-removed">-   buf.insts()-&gt;initialize_shared_locs( &amp;locs_buf[lsize * 1], lsize);</span>
<span class="udiff-line-removed">-   buf.stubs()-&gt;initialize_shared_locs( &amp;locs_buf[lsize * 2], lsize);</span>
<span class="udiff-line-removed">-   // Mark as scratch buffer.</span>
<span class="udiff-line-removed">-   buf.consts()-&gt;set_scratch_emit();</span>
<span class="udiff-line-removed">-   buf.insts()-&gt;set_scratch_emit();</span>
<span class="udiff-line-removed">-   buf.stubs()-&gt;set_scratch_emit();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Do the emission.</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   Label fakeL; // Fake label for branch instructions.</span>
<span class="udiff-line-removed">-   Label*   saveL = NULL;</span>
<span class="udiff-line-removed">-   uint save_bnum = 0;</span>
<span class="udiff-line-removed">-   bool is_branch = n-&gt;is_MachBranch();</span>
<span class="udiff-line-removed">-   if (is_branch) {</span>
<span class="udiff-line-removed">-     MacroAssembler masm(&amp;buf);</span>
<span class="udiff-line-removed">-     masm.bind(fakeL);</span>
<span class="udiff-line-removed">-     n-&gt;as_MachBranch()-&gt;save_label(&amp;saveL, &amp;save_bnum);</span>
<span class="udiff-line-removed">-     n-&gt;as_MachBranch()-&gt;label_set(&amp;fakeL, 0);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   n-&gt;emit(buf, this-&gt;regalloc());</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Emitting into the scratch buffer should not fail</span>
<span class="udiff-line-removed">-   assert (!failing(), &quot;Must not have pending failure. Reason is: %s&quot;, failure_reason());</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (is_branch) // Restore label.</span>
<span class="udiff-line-removed">-     n-&gt;as_MachBranch()-&gt;label_set(saveL, save_bnum);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // End scratch_emit_size section.</span>
<span class="udiff-line-removed">-   set_in_scratch_emit_size(false);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   return buf.insts_size();</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- </span>
  // ============================================================================
  //------------------------------Compile standard-------------------------------
  debug_only( int Compile::_debug_idx = 100000; )
  
  // Compile a method.  entry_bci is -1 for normal compilations and indicates
  // the continuation bci for on stack replacement.
  
  
<span class="udiff-line-modified-removed">- Compile::Compile( ciEnv* ci_env, C2Compiler* compiler, ciMethod* target, int osr_bci,</span>
<span class="udiff-line-modified-added">+ Compile::Compile( ciEnv* ci_env, ciMethod* target, int osr_bci,</span>
                    bool subsume_loads, bool do_escape_analysis, bool eliminate_boxing, DirectiveSet* directive)
                  : Phase(Compiler),
                    _compile_id(ci_env-&gt;compile_id()),
                    _save_argument_registers(false),
                    _subsume_loads(subsume_loads),
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -638,12 +509,10 @@</span>
                    _entry_bci(osr_bci),
                    _stub_function(NULL),
                    _stub_name(NULL),
                    _stub_entry_point(NULL),
                    _max_node_limit(MaxNodeLimit),
<span class="udiff-line-removed">-                   _orig_pc_slot(0),</span>
<span class="udiff-line-removed">-                   _orig_pc_slot_offset_in_bytes(0),</span>
                    _inlining_progress(false),
                    _inlining_incrementally(false),
                    _do_cleanup(false),
                    _has_reserved_stack_access(target-&gt;has_reserved_stack_access()),
  #ifndef PRODUCT
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -681,16 +550,11 @@</span>
                    _print_inlining_idx(0),
                    _print_inlining_output(NULL),
                    _replay_inline_data(NULL),
                    _java_calls(0),
                    _inner_loops(0),
<span class="udiff-line-modified-removed">-                   _interpreter_frame_size(0),</span>
<span class="udiff-line-removed">-                   _node_bundling_limit(0),</span>
<span class="udiff-line-removed">-                   _node_bundling_base(NULL),</span>
<span class="udiff-line-removed">-                   _code_buffer(&quot;Compile::Fill_buffer&quot;),</span>
<span class="udiff-line-removed">-                   _scratch_const_size(-1),</span>
<span class="udiff-line-removed">-                   _in_scratch_emit_size(false)</span>
<span class="udiff-line-modified-added">+                   _interpreter_frame_size(0)</span>
  #ifndef PRODUCT
                    , _in_dump_cnt(0)
  #endif
  {
    C = this;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -904,56 +768,19 @@</span>
      env()-&gt;dump_inline_data(_compile_id);
    }
  
    // Now that we know the size of all the monitors we can add a fixed slot
    // for the original deopt pc.
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-removed">-   _orig_pc_slot =  fixed_slots();</span>
<span class="udiff-line-removed">-   int next_slot = _orig_pc_slot + (sizeof(address) / VMRegImpl::stack_slot_size);</span>
<span class="udiff-line-modified-added">+   int next_slot = fixed_slots() + (sizeof(address) / VMRegImpl::stack_slot_size);</span>
    set_fixed_slots(next_slot);
  
    // Compute when to use implicit null checks. Used by matching trap based
    // nodes and NullCheck optimization.
    set_allowed_deopt_reasons();
  
    // Now generate code
    Code_Gen();
<span class="udiff-line-removed">-   if (failing())  return;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Check if we want to skip execution of all compiled code.</span>
<span class="udiff-line-removed">-   {</span>
<span class="udiff-line-removed">- #ifndef PRODUCT</span>
<span class="udiff-line-removed">-     if (OptoNoExecute) {</span>
<span class="udiff-line-removed">-       record_method_not_compilable(&quot;+OptoNoExecute&quot;);  // Flag as failed</span>
<span class="udiff-line-removed">-       return;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-     TracePhase tp(&quot;install_code&quot;, &amp;timers[_t_registerMethod]);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (is_osr_compilation()) {</span>
<span class="udiff-line-removed">-       _code_offsets.set_value(CodeOffsets::Verified_Entry, 0);</span>
<span class="udiff-line-removed">-       _code_offsets.set_value(CodeOffsets::OSR_Entry, _first_block_size);</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       _code_offsets.set_value(CodeOffsets::Verified_Entry, _first_block_size);</span>
<span class="udiff-line-removed">-       _code_offsets.set_value(CodeOffsets::OSR_Entry, 0);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     env()-&gt;register_method(_method, _entry_bci,</span>
<span class="udiff-line-removed">-                            &amp;_code_offsets,</span>
<span class="udiff-line-removed">-                            _orig_pc_slot_offset_in_bytes,</span>
<span class="udiff-line-removed">-                            code_buffer(),</span>
<span class="udiff-line-removed">-                            frame_size_in_words(), _oop_map_set,</span>
<span class="udiff-line-removed">-                            &amp;_handler_table, &amp;_inc_table,</span>
<span class="udiff-line-removed">-                            compiler,</span>
<span class="udiff-line-removed">-                            has_unsafe_access(),</span>
<span class="udiff-line-removed">-                            SharedRuntime::is_wide_vector(max_vector_size()),</span>
<span class="udiff-line-removed">-                            rtm_state()</span>
<span class="udiff-line-removed">-                            );</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (log() != NULL) // Print code cache state into compiler log</span>
<span class="udiff-line-removed">-       log()-&gt;code_cache_state();</span>
<span class="udiff-line-removed">-   }</span>
  }
  
  //------------------------------Compile----------------------------------------
  // Compile a runtime stub
  Compile::Compile( ciEnv* ci_env,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -975,12 +802,10 @@</span>
      _entry_bci(InvocationEntryBci),
      _stub_function(stub_function),
      _stub_name(stub_name),
      _stub_entry_point(NULL),
      _max_node_limit(MaxNodeLimit),
<span class="udiff-line-removed">-     _orig_pc_slot(0),</span>
<span class="udiff-line-removed">-     _orig_pc_slot_offset_in_bytes(0),</span>
      _inlining_progress(false),
      _inlining_incrementally(false),
      _has_reserved_stack_access(false),
  #ifndef PRODUCT
      _trace_opto_output(directive-&gt;TraceOptoOutputOption),
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1014,13 +839,10 @@</span>
      _print_inlining_output(NULL),
      _replay_inline_data(NULL),
      _java_calls(0),
      _inner_loops(0),
      _interpreter_frame_size(0),
<span class="udiff-line-removed">-     _node_bundling_limit(0),</span>
<span class="udiff-line-removed">-     _node_bundling_base(NULL),</span>
<span class="udiff-line-removed">-     _code_buffer(&quot;Compile::Fill_buffer&quot;),</span>
  #ifndef PRODUCT
      _in_dump_cnt(0),
  #endif
      _allowed_reasons(0) {
    C = this;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1051,38 +873,12 @@</span>
      GraphKit kit;
      kit.gen_stub(stub_function, stub_name, is_fancy_jump, pass_tls, return_pc);
    }
  
    NOT_PRODUCT( verify_graph_edges(); )
<span class="udiff-line-removed">-   Code_Gen();</span>
<span class="udiff-line-removed">-   if (failing())  return;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Entry point will be accessed using compile-&gt;stub_entry_point();</span>
<span class="udiff-line-removed">-   if (code_buffer() == NULL) {</span>
<span class="udiff-line-removed">-     Matcher::soft_match_failure();</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     if (PrintAssembly &amp;&amp; (WizardMode || Verbose))</span>
<span class="udiff-line-removed">-       tty-&gt;print_cr(&quot;### Stub::%s&quot;, stub_name);</span>
  
<span class="udiff-line-modified-removed">-     if (!failing()) {</span>
<span class="udiff-line-removed">-       assert(_fixed_slots == 0, &quot;no fixed slots used for runtime stubs&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       // Make the NMethod</span>
<span class="udiff-line-removed">-       // For now we mark the frame as never safe for profile stackwalking</span>
<span class="udiff-line-removed">-       RuntimeStub *rs = RuntimeStub::new_runtime_stub(stub_name,</span>
<span class="udiff-line-removed">-                                                       code_buffer(),</span>
<span class="udiff-line-removed">-                                                       CodeOffsets::frame_never_safe,</span>
<span class="udiff-line-removed">-                                                       // _code_offsets.value(CodeOffsets::Frame_Complete),</span>
<span class="udiff-line-removed">-                                                       frame_size_in_words(),</span>
<span class="udiff-line-removed">-                                                       _oop_map_set,</span>
<span class="udiff-line-removed">-                                                       save_arg_registers);</span>
<span class="udiff-line-removed">-       assert(rs != NULL &amp;&amp; rs-&gt;is_runtime_stub(), &quot;sanity check&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       _stub_entry_point = rs-&gt;entry_point();</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+   Code_Gen();</span>
  }
  
  //------------------------------Init-------------------------------------------
  // Prepare for a single compilation
  void Compile::Init(int aliaslevel) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1212,10 +1008,13 @@</span>
    _predicate_opaqs = new(comp_arena()) GrowableArray&lt;Node*&gt;(comp_arena(), 8,  0, NULL);
    _expensive_nodes = new(comp_arena()) GrowableArray&lt;Node*&gt;(comp_arena(), 8,  0, NULL);
    _range_check_casts = new(comp_arena()) GrowableArray&lt;Node*&gt;(comp_arena(), 8,  0, NULL);
    _opaque4_nodes = new(comp_arena()) GrowableArray&lt;Node*&gt;(comp_arena(), 8,  0, NULL);
    register_library_intrinsics();
<span class="udiff-line-added">+ #ifdef ASSERT</span>
<span class="udiff-line-added">+   _type_verify_symmetry = true;</span>
<span class="udiff-line-added">+ #endif</span>
  }
  
  //---------------------------init_start----------------------------------------
  // Install the StartNode on this compile object.
  void Compile::init_start(StartNode* s) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2428,10 +2227,15 @@</span>
    if (opaque4_count() &gt; 0) {
      C-&gt;remove_opaque4_nodes(igvn);
      igvn.optimize();
    }
  
<span class="udiff-line-added">+   if (C-&gt;max_vector_size() &gt; 0) {</span>
<span class="udiff-line-added">+     C-&gt;optimize_logic_cones(igvn);</span>
<span class="udiff-line-added">+     igvn.optimize();</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
    DEBUG_ONLY( _modified_nodes = NULL; )
   } // (End scope of igvn; run destructor if necessary for asserts.)
  
   process_print_inlining();
   // A method with only infinite loops has no edges entering loops from root
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2444,10 +2248,321 @@</span>
   }
  
   print_method(PHASE_OPTIMIZE_FINISHED, 2);
  }
  
<span class="udiff-line-added">+ //---------------------------- Bitwise operation packing optimization ---------------------------</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static bool is_vector_unary_bitwise_op(Node* n) {</span>
<span class="udiff-line-added">+   return n-&gt;Opcode() == Op_XorV &amp;&amp;</span>
<span class="udiff-line-added">+          VectorNode::is_vector_bitwise_not_pattern(n);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static bool is_vector_binary_bitwise_op(Node* n) {</span>
<span class="udiff-line-added">+   switch (n-&gt;Opcode()) {</span>
<span class="udiff-line-added">+     case Op_AndV:</span>
<span class="udiff-line-added">+     case Op_OrV:</span>
<span class="udiff-line-added">+       return true;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     case Op_XorV:</span>
<span class="udiff-line-added">+       return !is_vector_unary_bitwise_op(n);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     default:</span>
<span class="udiff-line-added">+       return false;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static bool is_vector_ternary_bitwise_op(Node* n) {</span>
<span class="udiff-line-added">+   return n-&gt;Opcode() == Op_MacroLogicV;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static bool is_vector_bitwise_op(Node* n) {</span>
<span class="udiff-line-added">+   return is_vector_unary_bitwise_op(n)  ||</span>
<span class="udiff-line-added">+          is_vector_binary_bitwise_op(n) ||</span>
<span class="udiff-line-added">+          is_vector_ternary_bitwise_op(n);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static bool is_vector_bitwise_cone_root(Node* n) {</span>
<span class="udiff-line-added">+   if (!is_vector_bitwise_op(n)) {</span>
<span class="udiff-line-added">+     return false;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="udiff-line-added">+     if (is_vector_bitwise_op(n-&gt;fast_out(i))) {</span>
<span class="udiff-line-added">+       return false;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return true;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static uint collect_unique_inputs(Node* n, Unique_Node_List&amp; partition, Unique_Node_List&amp; inputs) {</span>
<span class="udiff-line-added">+   uint cnt = 0;</span>
<span class="udiff-line-added">+   if (is_vector_bitwise_op(n)) {</span>
<span class="udiff-line-added">+     if (VectorNode::is_vector_bitwise_not_pattern(n)) {</span>
<span class="udiff-line-added">+       for (uint i = 1; i &lt; n-&gt;req(); i++) {</span>
<span class="udiff-line-added">+         Node* in = n-&gt;in(i);</span>
<span class="udiff-line-added">+         bool skip = VectorNode::is_all_ones_vector(in);</span>
<span class="udiff-line-added">+         if (!skip &amp;&amp; !inputs.member(in)) {</span>
<span class="udiff-line-added">+           inputs.push(in);</span>
<span class="udiff-line-added">+           cnt++;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       assert(cnt &lt;= 1, &quot;not unary&quot;);</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       uint last_req = n-&gt;req();</span>
<span class="udiff-line-added">+       if (is_vector_ternary_bitwise_op(n)) {</span>
<span class="udiff-line-added">+         last_req = n-&gt;req() - 1; // skip last input</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       for (uint i = 1; i &lt; last_req; i++) {</span>
<span class="udiff-line-added">+         Node* def = n-&gt;in(i);</span>
<span class="udiff-line-added">+         if (!inputs.member(def)) {</span>
<span class="udiff-line-added">+           inputs.push(def);</span>
<span class="udiff-line-added">+           cnt++;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     partition.push(n);</span>
<span class="udiff-line-added">+   } else { // not a bitwise operations</span>
<span class="udiff-line-added">+     if (!inputs.member(n)) {</span>
<span class="udiff-line-added">+       inputs.push(n);</span>
<span class="udiff-line-added">+       cnt++;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return cnt;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void Compile::collect_logic_cone_roots(Unique_Node_List&amp; list) {</span>
<span class="udiff-line-added">+   Unique_Node_List useful_nodes;</span>
<span class="udiff-line-added">+   C-&gt;identify_useful_nodes(useful_nodes);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   for (uint i = 0; i &lt; useful_nodes.size(); i++) {</span>
<span class="udiff-line-added">+     Node* n = useful_nodes.at(i);</span>
<span class="udiff-line-added">+     if (is_vector_bitwise_cone_root(n)) {</span>
<span class="udiff-line-added">+       list.push(n);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ Node* Compile::xform_to_MacroLogicV(PhaseIterGVN&amp; igvn,</span>
<span class="udiff-line-added">+                                     const TypeVect* vt,</span>
<span class="udiff-line-added">+                                     Unique_Node_List&amp; partition,</span>
<span class="udiff-line-added">+                                     Unique_Node_List&amp; inputs) {</span>
<span class="udiff-line-added">+   assert(partition.size() == 2 || partition.size() == 3, &quot;not supported&quot;);</span>
<span class="udiff-line-added">+   assert(inputs.size()    == 2 || inputs.size()    == 3, &quot;not supported&quot;);</span>
<span class="udiff-line-added">+   assert(Matcher::match_rule_supported_vector(Op_MacroLogicV, vt-&gt;length(), vt-&gt;element_basic_type()), &quot;not supported&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   Node* in1 = inputs.at(0);</span>
<span class="udiff-line-added">+   Node* in2 = inputs.at(1);</span>
<span class="udiff-line-added">+   Node* in3 = (inputs.size() == 3 ? inputs.at(2) : in2);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   uint func = compute_truth_table(partition, inputs);</span>
<span class="udiff-line-added">+   return igvn.transform(MacroLogicVNode::make(igvn, in3, in2, in1, func, vt));</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static uint extract_bit(uint func, uint pos) {</span>
<span class="udiff-line-added">+   return (func &amp; (1 &lt;&lt; pos)) &gt;&gt; pos;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ //</span>
<span class="udiff-line-added">+ //  A macro logic node represents a truth table. It has 4 inputs,</span>
<span class="udiff-line-added">+ //  First three inputs corresponds to 3 columns of a truth table</span>
<span class="udiff-line-added">+ //  and fourth input captures the logic function.</span>
<span class="udiff-line-added">+ //</span>
<span class="udiff-line-added">+ //  eg.  fn = (in1 AND in2) OR in3;</span>
<span class="udiff-line-added">+ //</span>
<span class="udiff-line-added">+ //      MacroNode(in1,in2,in3,fn)</span>
<span class="udiff-line-added">+ //</span>
<span class="udiff-line-added">+ //  -----------------</span>
<span class="udiff-line-added">+ //  in1 in2 in3  fn</span>
<span class="udiff-line-added">+ //  -----------------</span>
<span class="udiff-line-added">+ //  0    0   0    0</span>
<span class="udiff-line-added">+ //  0    0   1    1</span>
<span class="udiff-line-added">+ //  0    1   0    0</span>
<span class="udiff-line-added">+ //  0    1   1    1</span>
<span class="udiff-line-added">+ //  1    0   0    0</span>
<span class="udiff-line-added">+ //  1    0   1    1</span>
<span class="udiff-line-added">+ //  1    1   0    1</span>
<span class="udiff-line-added">+ //  1    1   1    1</span>
<span class="udiff-line-added">+ //</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ uint Compile::eval_macro_logic_op(uint func, uint in1 , uint in2, uint in3) {</span>
<span class="udiff-line-added">+   int res = 0;</span>
<span class="udiff-line-added">+   for (int i = 0; i &lt; 8; i++) {</span>
<span class="udiff-line-added">+     int bit1 = extract_bit(in1, i);</span>
<span class="udiff-line-added">+     int bit2 = extract_bit(in2, i);</span>
<span class="udiff-line-added">+     int bit3 = extract_bit(in3, i);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     int func_bit_pos = (bit1 &lt;&lt; 2 | bit2 &lt;&lt; 1 | bit3);</span>
<span class="udiff-line-added">+     int func_bit = extract_bit(func, func_bit_pos);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     res |= func_bit &lt;&lt; i;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return res;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static uint eval_operand(Node* n, ResourceHashtable&lt;Node*,uint&gt;&amp; eval_map) {</span>
<span class="udiff-line-added">+   assert(n != NULL, &quot;&quot;);</span>
<span class="udiff-line-added">+   assert(eval_map.contains(n), &quot;absent&quot;);</span>
<span class="udiff-line-added">+   return *(eval_map.get(n));</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static void eval_operands(Node* n,</span>
<span class="udiff-line-added">+                           uint&amp; func1, uint&amp; func2, uint&amp; func3,</span>
<span class="udiff-line-added">+                           ResourceHashtable&lt;Node*,uint&gt;&amp; eval_map) {</span>
<span class="udiff-line-added">+   assert(is_vector_bitwise_op(n), &quot;&quot;);</span>
<span class="udiff-line-added">+   func1 = eval_operand(n-&gt;in(1), eval_map);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (is_vector_binary_bitwise_op(n)) {</span>
<span class="udiff-line-added">+     func2 = eval_operand(n-&gt;in(2), eval_map);</span>
<span class="udiff-line-added">+   } else if (is_vector_ternary_bitwise_op(n)) {</span>
<span class="udiff-line-added">+     func2 = eval_operand(n-&gt;in(2), eval_map);</span>
<span class="udiff-line-added">+     func3 = eval_operand(n-&gt;in(3), eval_map);</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     assert(is_vector_unary_bitwise_op(n), &quot;not unary&quot;);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ uint Compile::compute_truth_table(Unique_Node_List&amp; partition, Unique_Node_List&amp; inputs) {</span>
<span class="udiff-line-added">+   assert(inputs.size() &lt;= 3, &quot;sanity&quot;);</span>
<span class="udiff-line-added">+   ResourceMark rm;</span>
<span class="udiff-line-added">+   uint res = 0;</span>
<span class="udiff-line-added">+   ResourceHashtable&lt;Node*,uint&gt; eval_map;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Populate precomputed functions for inputs.</span>
<span class="udiff-line-added">+   // Each input corresponds to one column of 3 input truth-table.</span>
<span class="udiff-line-added">+   uint input_funcs[] = { 0xAA,   // (_, _, a) -&gt; a</span>
<span class="udiff-line-added">+                          0xCC,   // (_, b, _) -&gt; b</span>
<span class="udiff-line-added">+                          0xF0 }; // (c, _, _) -&gt; c</span>
<span class="udiff-line-added">+   for (uint i = 0; i &lt; inputs.size(); i++) {</span>
<span class="udiff-line-added">+     eval_map.put(inputs.at(i), input_funcs[i]);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   for (uint i = 0; i &lt; partition.size(); i++) {</span>
<span class="udiff-line-added">+     Node* n = partition.at(i);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     uint func1 = 0, func2 = 0, func3 = 0;</span>
<span class="udiff-line-added">+     eval_operands(n, func1, func2, func3, eval_map);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     switch (n-&gt;Opcode()) {</span>
<span class="udiff-line-added">+       case Op_OrV:</span>
<span class="udiff-line-added">+         assert(func3 == 0, &quot;not binary&quot;);</span>
<span class="udiff-line-added">+         res = func1 | func2;</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+       case Op_AndV:</span>
<span class="udiff-line-added">+         assert(func3 == 0, &quot;not binary&quot;);</span>
<span class="udiff-line-added">+         res = func1 &amp; func2;</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+       case Op_XorV:</span>
<span class="udiff-line-added">+         if (VectorNode::is_vector_bitwise_not_pattern(n)) {</span>
<span class="udiff-line-added">+           assert(func2 == 0 &amp;&amp; func3 == 0, &quot;not unary&quot;);</span>
<span class="udiff-line-added">+           res = (~func1) &amp; 0xFF;</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+           assert(func3 == 0, &quot;not binary&quot;);</span>
<span class="udiff-line-added">+           res = func1 ^ func2;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+       case Op_MacroLogicV:</span>
<span class="udiff-line-added">+         // Ordering of inputs may change during evaluation of sub-tree</span>
<span class="udiff-line-added">+         // containing MacroLogic node as a child node, thus a re-evaluation</span>
<span class="udiff-line-added">+         // makes sure that function is evaluated in context of current</span>
<span class="udiff-line-added">+         // inputs.</span>
<span class="udiff-line-added">+         res = eval_macro_logic_op(n-&gt;in(4)-&gt;get_int(), func1, func2, func3);</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       default: assert(false, &quot;not supported: %s&quot;, n-&gt;Name());</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     assert(res &lt;= 0xFF, &quot;invalid&quot;);</span>
<span class="udiff-line-added">+     eval_map.put(n, res);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return res;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ bool Compile::compute_logic_cone(Node* n, Unique_Node_List&amp; partition, Unique_Node_List&amp; inputs) {</span>
<span class="udiff-line-added">+   assert(partition.size() == 0, &quot;not empty&quot;);</span>
<span class="udiff-line-added">+   assert(inputs.size() == 0, &quot;not empty&quot;);</span>
<span class="udiff-line-added">+   assert(!is_vector_ternary_bitwise_op(n), &quot;not supported&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   bool is_unary_op = is_vector_unary_bitwise_op(n);</span>
<span class="udiff-line-added">+   if (is_unary_op) {</span>
<span class="udiff-line-added">+     assert(collect_unique_inputs(n, partition, inputs) == 1, &quot;not unary&quot;);</span>
<span class="udiff-line-added">+     return false; // too few inputs</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   assert(is_vector_binary_bitwise_op(n), &quot;not binary&quot;);</span>
<span class="udiff-line-added">+   Node* in1 = n-&gt;in(1);</span>
<span class="udiff-line-added">+   Node* in2 = n-&gt;in(2);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   int in1_unique_inputs_cnt = collect_unique_inputs(in1, partition, inputs);</span>
<span class="udiff-line-added">+   int in2_unique_inputs_cnt = collect_unique_inputs(in2, partition, inputs);</span>
<span class="udiff-line-added">+   partition.push(n);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Too many inputs?</span>
<span class="udiff-line-added">+   if (inputs.size() &gt; 3) {</span>
<span class="udiff-line-added">+     partition.clear();</span>
<span class="udiff-line-added">+     inputs.clear();</span>
<span class="udiff-line-added">+     { // Recompute in2 inputs</span>
<span class="udiff-line-added">+       Unique_Node_List not_used;</span>
<span class="udiff-line-added">+       in2_unique_inputs_cnt = collect_unique_inputs(in2, not_used, not_used);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     // Pick the node with minimum number of inputs.</span>
<span class="udiff-line-added">+     if (in1_unique_inputs_cnt &gt;= 3 &amp;&amp; in2_unique_inputs_cnt &gt;= 3) {</span>
<span class="udiff-line-added">+       return false; // still too many inputs</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     // Recompute partition &amp; inputs.</span>
<span class="udiff-line-added">+     Node* child       = (in1_unique_inputs_cnt &lt; in2_unique_inputs_cnt ? in1 : in2);</span>
<span class="udiff-line-added">+     collect_unique_inputs(child, partition, inputs);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     Node* other_input = (in1_unique_inputs_cnt &lt; in2_unique_inputs_cnt ? in2 : in1);</span>
<span class="udiff-line-added">+     inputs.push(other_input);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     partition.push(n);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   return (partition.size() == 2 || partition.size() == 3) &amp;&amp;</span>
<span class="udiff-line-added">+          (inputs.size()    == 2 || inputs.size()    == 3);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void Compile::process_logic_cone_root(PhaseIterGVN &amp;igvn, Node *n, VectorSet &amp;visited) {</span>
<span class="udiff-line-added">+   assert(is_vector_bitwise_op(n), &quot;not a root&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   visited.set(n-&gt;_idx);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // 1) Do a DFS walk over the logic cone.</span>
<span class="udiff-line-added">+   for (uint i = 1; i &lt; n-&gt;req(); i++) {</span>
<span class="udiff-line-added">+     Node* in = n-&gt;in(i);</span>
<span class="udiff-line-added">+     if (!visited.test(in-&gt;_idx) &amp;&amp; is_vector_bitwise_op(in)) {</span>
<span class="udiff-line-added">+       process_logic_cone_root(igvn, in, visited);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // 2) Bottom up traversal: Merge node[s] with</span>
<span class="udiff-line-added">+   // the parent to form macro logic node.</span>
<span class="udiff-line-added">+   Unique_Node_List partition;</span>
<span class="udiff-line-added">+   Unique_Node_List inputs;</span>
<span class="udiff-line-added">+   if (compute_logic_cone(n, partition, inputs)) {</span>
<span class="udiff-line-added">+     const TypeVect* vt = n-&gt;bottom_type()-&gt;is_vect();</span>
<span class="udiff-line-added">+     Node* macro_logic = xform_to_MacroLogicV(igvn, vt, partition, inputs);</span>
<span class="udiff-line-added">+     igvn.replace_node(n, macro_logic);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void Compile::optimize_logic_cones(PhaseIterGVN &amp;igvn) {</span>
<span class="udiff-line-added">+   ResourceMark rm;</span>
<span class="udiff-line-added">+   if (Matcher::match_rule_supported(Op_MacroLogicV)) {</span>
<span class="udiff-line-added">+     Unique_Node_List list;</span>
<span class="udiff-line-added">+     collect_logic_cone_roots(list);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     while (list.size() &gt; 0) {</span>
<span class="udiff-line-added">+       Node* n = list.pop();</span>
<span class="udiff-line-added">+       const TypeVect* vt = n-&gt;bottom_type()-&gt;is_vect();</span>
<span class="udiff-line-added">+       bool supported = Matcher::match_rule_supported_vector(Op_MacroLogicV, vt-&gt;length(), vt-&gt;element_basic_type());</span>
<span class="udiff-line-added">+       if (supported) {</span>
<span class="udiff-line-added">+         VectorSet visited(comp_arena());</span>
<span class="udiff-line-added">+         process_logic_cone_root(igvn, n, visited);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
  
  //------------------------------Code_Gen---------------------------------------
  // Given a graph, generate code for it
  void Compile::Code_Gen() {
    if (failing()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2544,158 +2659,24 @@</span>
      cfg.postalloc_expand(_regalloc);
    }
  
    // Convert Nodes to instruction bits in a buffer
    {
<span class="udiff-line-modified-removed">-     TraceTime tp(&quot;output&quot;, &amp;timers[_t_output], CITime);</span>
<span class="udiff-line-modified-removed">-     Output();</span>
<span class="udiff-line-modified-added">+     TracePhase tp(&quot;output&quot;, &amp;timers[_t_output]);</span>
<span class="udiff-line-modified-added">+     PhaseOutput output;</span>
<span class="udiff-line-added">+     output.Output();</span>
<span class="udiff-line-added">+     if (failing())  return;</span>
<span class="udiff-line-added">+     output.install();</span>
    }
  
    print_method(PHASE_FINAL_CODE);
  
    // He&#39;s dead, Jim.
    _cfg     = (PhaseCFG*)((intptr_t)0xdeadbeef);
    _regalloc = (PhaseChaitin*)((intptr_t)0xdeadbeef);
  }
  
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- //------------------------------dump_asm---------------------------------------</span>
<span class="udiff-line-removed">- // Dump formatted assembly</span>
<span class="udiff-line-removed">- #if defined(SUPPORT_OPTO_ASSEMBLY)</span>
<span class="udiff-line-removed">- void Compile::dump_asm_on(outputStream* st, int* pcs, uint pc_limit) {</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   int pc_digits = 3; // #chars required for pc</span>
<span class="udiff-line-removed">-   int sb_chars  = 3; // #chars for &quot;start bundle&quot; indicator</span>
<span class="udiff-line-removed">-   int tab_size  = 8;</span>
<span class="udiff-line-removed">-   if (pcs != NULL) {</span>
<span class="udiff-line-removed">-     int max_pc = 0;</span>
<span class="udiff-line-removed">-     for (uint i = 0; i &lt; pc_limit; i++) {</span>
<span class="udiff-line-removed">-       max_pc = (max_pc &lt; pcs[i]) ? pcs[i] : max_pc;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     pc_digits  = ((max_pc &lt; 4096) ? 3 : ((max_pc &lt; 65536) ? 4 : ((max_pc &lt; 65536*256) ? 6 : 8))); // #chars required for pc</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   int prefix_len = ((pc_digits + sb_chars + tab_size - 1)/tab_size)*tab_size;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   bool cut_short = false;</span>
<span class="udiff-line-removed">-   st-&gt;print_cr(&quot;#&quot;);</span>
<span class="udiff-line-removed">-   st-&gt;print(&quot;#  &quot;);  _tf-&gt;dump_on(st);  st-&gt;cr();</span>
<span class="udiff-line-removed">-   st-&gt;print_cr(&quot;#&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // For all blocks</span>
<span class="udiff-line-removed">-   int pc = 0x0;                 // Program counter</span>
<span class="udiff-line-removed">-   char starts_bundle = &#39; &#39;;</span>
<span class="udiff-line-removed">-   _regalloc-&gt;dump_frame();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   Node *n = NULL;</span>
<span class="udiff-line-removed">-   for (uint i = 0; i &lt; _cfg-&gt;number_of_blocks(); i++) {</span>
<span class="udiff-line-removed">-     if (VMThread::should_terminate()) {</span>
<span class="udiff-line-removed">-       cut_short = true;</span>
<span class="udiff-line-removed">-       break;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     Block* block = _cfg-&gt;get_block(i);</span>
<span class="udiff-line-removed">-     if (block-&gt;is_connector() &amp;&amp; !Verbose) {</span>
<span class="udiff-line-removed">-       continue;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     n = block-&gt;head();</span>
<span class="udiff-line-removed">-     if ((pcs != NULL) &amp;&amp; (n-&gt;_idx &lt; pc_limit)) {</span>
<span class="udiff-line-removed">-       pc = pcs[n-&gt;_idx];</span>
<span class="udiff-line-removed">-       st-&gt;print(&quot;%*.*x&quot;, pc_digits, pc_digits, pc);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     st-&gt;fill_to(prefix_len);</span>
<span class="udiff-line-removed">-     block-&gt;dump_head(_cfg, st);</span>
<span class="udiff-line-removed">-     if (block-&gt;is_connector()) {</span>
<span class="udiff-line-removed">-       st-&gt;fill_to(prefix_len);</span>
<span class="udiff-line-removed">-       st-&gt;print_cr(&quot;# Empty connector block&quot;);</span>
<span class="udiff-line-removed">-     } else if (block-&gt;num_preds() == 2 &amp;&amp; block-&gt;pred(1)-&gt;is_CatchProj() &amp;&amp; block-&gt;pred(1)-&gt;as_CatchProj()-&gt;_con == CatchProjNode::fall_through_index) {</span>
<span class="udiff-line-removed">-       st-&gt;fill_to(prefix_len);</span>
<span class="udiff-line-removed">-       st-&gt;print_cr(&quot;# Block is sole successor of call&quot;);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // For all instructions</span>
<span class="udiff-line-removed">-     Node *delay = NULL;</span>
<span class="udiff-line-removed">-     for (uint j = 0; j &lt; block-&gt;number_of_nodes(); j++) {</span>
<span class="udiff-line-removed">-       if (VMThread::should_terminate()) {</span>
<span class="udiff-line-removed">-         cut_short = true;</span>
<span class="udiff-line-removed">-         break;</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       n = block-&gt;get_node(j);</span>
<span class="udiff-line-removed">-       if (valid_bundle_info(n)) {</span>
<span class="udiff-line-removed">-         Bundle* bundle = node_bundling(n);</span>
<span class="udiff-line-removed">-         if (bundle-&gt;used_in_unconditional_delay()) {</span>
<span class="udiff-line-removed">-           delay = n;</span>
<span class="udiff-line-removed">-           continue;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         if (bundle-&gt;starts_bundle()) {</span>
<span class="udiff-line-removed">-           starts_bundle = &#39;+&#39;;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       if (WizardMode) {</span>
<span class="udiff-line-removed">-         n-&gt;dump();</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       if( !n-&gt;is_Region() &amp;&amp;    // Dont print in the Assembly</span>
<span class="udiff-line-removed">-           !n-&gt;is_Phi() &amp;&amp;       // a few noisely useless nodes</span>
<span class="udiff-line-removed">-           !n-&gt;is_Proj() &amp;&amp;</span>
<span class="udiff-line-removed">-           !n-&gt;is_MachTemp() &amp;&amp;</span>
<span class="udiff-line-removed">-           !n-&gt;is_SafePointScalarObject() &amp;&amp;</span>
<span class="udiff-line-removed">-           !n-&gt;is_Catch() &amp;&amp;     // Would be nice to print exception table targets</span>
<span class="udiff-line-removed">-           !n-&gt;is_MergeMem() &amp;&amp;  // Not very interesting</span>
<span class="udiff-line-removed">-           !n-&gt;is_top() &amp;&amp;       // Debug info table constants</span>
<span class="udiff-line-removed">-           !(n-&gt;is_Con() &amp;&amp; !n-&gt;is_Mach())// Debug info table constants</span>
<span class="udiff-line-removed">-           ) {</span>
<span class="udiff-line-removed">-         if ((pcs != NULL) &amp;&amp; (n-&gt;_idx &lt; pc_limit)) {</span>
<span class="udiff-line-removed">-           pc = pcs[n-&gt;_idx];</span>
<span class="udiff-line-removed">-           st-&gt;print(&quot;%*.*x&quot;, pc_digits, pc_digits, pc);</span>
<span class="udiff-line-removed">-         } else {</span>
<span class="udiff-line-removed">-           st-&gt;fill_to(pc_digits);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         st-&gt;print(&quot; %c &quot;, starts_bundle);</span>
<span class="udiff-line-removed">-         starts_bundle = &#39; &#39;;</span>
<span class="udiff-line-removed">-         st-&gt;fill_to(prefix_len);</span>
<span class="udiff-line-removed">-         n-&gt;format(_regalloc, st);</span>
<span class="udiff-line-removed">-         st-&gt;cr();</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       // If we have an instruction with a delay slot, and have seen a delay,</span>
<span class="udiff-line-removed">-       // then back up and print it</span>
<span class="udiff-line-removed">-       if (valid_bundle_info(n) &amp;&amp; node_bundling(n)-&gt;use_unconditional_delay()) {</span>
<span class="udiff-line-removed">-         // Coverity finding - Explicit null dereferenced.</span>
<span class="udiff-line-removed">-         guarantee(delay != NULL, &quot;no unconditional delay instruction&quot;);</span>
<span class="udiff-line-removed">-         if (WizardMode) delay-&gt;dump();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         if (node_bundling(delay)-&gt;starts_bundle())</span>
<span class="udiff-line-removed">-           starts_bundle = &#39;+&#39;;</span>
<span class="udiff-line-removed">-         if ((pcs != NULL) &amp;&amp; (n-&gt;_idx &lt; pc_limit)) {</span>
<span class="udiff-line-removed">-           pc = pcs[n-&gt;_idx];</span>
<span class="udiff-line-removed">-           st-&gt;print(&quot;%*.*x&quot;, pc_digits, pc_digits, pc);</span>
<span class="udiff-line-removed">-         } else {</span>
<span class="udiff-line-removed">-           st-&gt;fill_to(pc_digits);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         st-&gt;print(&quot; %c &quot;, starts_bundle);</span>
<span class="udiff-line-removed">-         starts_bundle = &#39; &#39;;</span>
<span class="udiff-line-removed">-         st-&gt;fill_to(prefix_len);</span>
<span class="udiff-line-removed">-         delay-&gt;format(_regalloc, st);</span>
<span class="udiff-line-removed">-         st-&gt;cr();</span>
<span class="udiff-line-removed">-         delay = NULL;</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       // Dump the exception table as well</span>
<span class="udiff-line-removed">-       if( n-&gt;is_Catch() &amp;&amp; (Verbose || WizardMode) ) {</span>
<span class="udiff-line-removed">-         // Print the exception table for this offset</span>
<span class="udiff-line-removed">-         _handler_table.print_subtable_for(pc);</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       st-&gt;bol(); // Make sure we start on a new line</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     st-&gt;cr(); // one empty line between blocks</span>
<span class="udiff-line-removed">-     assert(cut_short || delay == NULL, &quot;no unconditional delay branch&quot;);</span>
<span class="udiff-line-removed">-   } // End of per-block dump</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (cut_short)  st-&gt;print_cr(&quot;*** disassembly is cut short ***&quot;);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
  //------------------------------Final_Reshape_Counts---------------------------
  // This class defines counters to help identify when a method
  // may/must be executed using hardware with only 24-bit precision.
  struct Final_Reshape_Counts : public StackObj {
    int  _call_count;             // count non-inlined &#39;common&#39; calls
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3371,10 +3352,13 @@</span>
    case Op_MulReductionVL:
    case Op_MulReductionVF:
    case Op_MulReductionVD:
    case Op_MinReductionV:
    case Op_MaxReductionV:
<span class="udiff-line-added">+   case Op_AndReductionV:</span>
<span class="udiff-line-added">+   case Op_OrReductionV:</span>
<span class="udiff-line-added">+   case Op_XorReductionV:</span>
      break;
  
    case Op_PackB:
    case Op_PackS:
    case Op_PackI:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3984,226 +3968,10 @@</span>
    if (_log != NULL) {
      _log-&gt;done(&quot;phase name=&#39;%s&#39; nodes=&#39;%d&#39; live=&#39;%d&#39;&quot;, _phase_name, C-&gt;unique(), C-&gt;live_nodes());
    }
  }
  
<span class="udiff-line-removed">- //=============================================================================</span>
<span class="udiff-line-removed">- // Two Constant&#39;s are equal when the type and the value are equal.</span>
<span class="udiff-line-removed">- bool Compile::Constant::operator==(const Constant&amp; other) {</span>
<span class="udiff-line-removed">-   if (type()          != other.type()         )  return false;</span>
<span class="udiff-line-removed">-   if (can_be_reused() != other.can_be_reused())  return false;</span>
<span class="udiff-line-removed">-   // For floating point values we compare the bit pattern.</span>
<span class="udiff-line-removed">-   switch (type()) {</span>
<span class="udiff-line-removed">-   case T_INT:</span>
<span class="udiff-line-removed">-   case T_FLOAT:   return (_v._value.i == other._v._value.i);</span>
<span class="udiff-line-removed">-   case T_LONG:</span>
<span class="udiff-line-removed">-   case T_DOUBLE:  return (_v._value.j == other._v._value.j);</span>
<span class="udiff-line-removed">-   case T_OBJECT:</span>
<span class="udiff-line-removed">-   case T_ADDRESS: return (_v._value.l == other._v._value.l);</span>
<span class="udiff-line-removed">-   case T_VOID:    return (_v._value.l == other._v._value.l);  // jump-table entries</span>
<span class="udiff-line-removed">-   case T_METADATA: return (_v._metadata == other._v._metadata);</span>
<span class="udiff-line-removed">-   default: ShouldNotReachHere(); return false;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- static int type_to_size_in_bytes(BasicType t) {</span>
<span class="udiff-line-removed">-   switch (t) {</span>
<span class="udiff-line-removed">-   case T_INT:     return sizeof(jint   );</span>
<span class="udiff-line-removed">-   case T_LONG:    return sizeof(jlong  );</span>
<span class="udiff-line-removed">-   case T_FLOAT:   return sizeof(jfloat );</span>
<span class="udiff-line-removed">-   case T_DOUBLE:  return sizeof(jdouble);</span>
<span class="udiff-line-removed">-   case T_METADATA: return sizeof(Metadata*);</span>
<span class="udiff-line-removed">-     // We use T_VOID as marker for jump-table entries (labels) which</span>
<span class="udiff-line-removed">-     // need an internal word relocation.</span>
<span class="udiff-line-removed">-   case T_VOID:</span>
<span class="udiff-line-removed">-   case T_ADDRESS:</span>
<span class="udiff-line-removed">-   case T_OBJECT:  return sizeof(jobject);</span>
<span class="udiff-line-removed">-   default:</span>
<span class="udiff-line-removed">-     ShouldNotReachHere();</span>
<span class="udiff-line-removed">-     return -1;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- int Compile::ConstantTable::qsort_comparator(Constant* a, Constant* b) {</span>
<span class="udiff-line-removed">-   // sort descending</span>
<span class="udiff-line-removed">-   if (a-&gt;freq() &gt; b-&gt;freq())  return -1;</span>
<span class="udiff-line-removed">-   if (a-&gt;freq() &lt; b-&gt;freq())  return  1;</span>
<span class="udiff-line-removed">-   return 0;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void Compile::ConstantTable::calculate_offsets_and_size() {</span>
<span class="udiff-line-removed">-   // First, sort the array by frequencies.</span>
<span class="udiff-line-removed">-   _constants.sort(qsort_comparator);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #ifdef ASSERT</span>
<span class="udiff-line-removed">-   // Make sure all jump-table entries were sorted to the end of the</span>
<span class="udiff-line-removed">-   // array (they have a negative frequency).</span>
<span class="udiff-line-removed">-   bool found_void = false;</span>
<span class="udiff-line-removed">-   for (int i = 0; i &lt; _constants.length(); i++) {</span>
<span class="udiff-line-removed">-     Constant con = _constants.at(i);</span>
<span class="udiff-line-removed">-     if (con.type() == T_VOID)</span>
<span class="udiff-line-removed">-       found_void = true;  // jump-tables</span>
<span class="udiff-line-removed">-     else</span>
<span class="udiff-line-removed">-       assert(!found_void, &quot;wrong sorting&quot;);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   int offset = 0;</span>
<span class="udiff-line-removed">-   for (int i = 0; i &lt; _constants.length(); i++) {</span>
<span class="udiff-line-removed">-     Constant* con = _constants.adr_at(i);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // Align offset for type.</span>
<span class="udiff-line-removed">-     int typesize = type_to_size_in_bytes(con-&gt;type());</span>
<span class="udiff-line-removed">-     offset = align_up(offset, typesize);</span>
<span class="udiff-line-removed">-     con-&gt;set_offset(offset);   // set constant&#39;s offset</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (con-&gt;type() == T_VOID) {</span>
<span class="udiff-line-removed">-       MachConstantNode* n = (MachConstantNode*) con-&gt;get_jobject();</span>
<span class="udiff-line-removed">-       offset = offset + typesize * n-&gt;outcnt();  // expand jump-table</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       offset = offset + typesize;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Align size up to the next section start (which is insts; see</span>
<span class="udiff-line-removed">-   // CodeBuffer::align_at_start).</span>
<span class="udiff-line-removed">-   assert(_size == -1, &quot;already set?&quot;);</span>
<span class="udiff-line-removed">-   _size = align_up(offset, (int)CodeEntryAlignment);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void Compile::ConstantTable::emit(CodeBuffer&amp; cb) {</span>
<span class="udiff-line-removed">-   MacroAssembler _masm(&amp;cb);</span>
<span class="udiff-line-removed">-   for (int i = 0; i &lt; _constants.length(); i++) {</span>
<span class="udiff-line-removed">-     Constant con = _constants.at(i);</span>
<span class="udiff-line-removed">-     address constant_addr = NULL;</span>
<span class="udiff-line-removed">-     switch (con.type()) {</span>
<span class="udiff-line-removed">-     case T_INT:    constant_addr = _masm.int_constant(   con.get_jint()   ); break;</span>
<span class="udiff-line-removed">-     case T_LONG:   constant_addr = _masm.long_constant(  con.get_jlong()  ); break;</span>
<span class="udiff-line-removed">-     case T_FLOAT:  constant_addr = _masm.float_constant( con.get_jfloat() ); break;</span>
<span class="udiff-line-removed">-     case T_DOUBLE: constant_addr = _masm.double_constant(con.get_jdouble()); break;</span>
<span class="udiff-line-removed">-     case T_OBJECT: {</span>
<span class="udiff-line-removed">-       jobject obj = con.get_jobject();</span>
<span class="udiff-line-removed">-       int oop_index = _masm.oop_recorder()-&gt;find_index(obj);</span>
<span class="udiff-line-removed">-       constant_addr = _masm.address_constant((address) obj, oop_Relocation::spec(oop_index));</span>
<span class="udiff-line-removed">-       break;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     case T_ADDRESS: {</span>
<span class="udiff-line-removed">-       address addr = (address) con.get_jobject();</span>
<span class="udiff-line-removed">-       constant_addr = _masm.address_constant(addr);</span>
<span class="udiff-line-removed">-       break;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     // We use T_VOID as marker for jump-table entries (labels) which</span>
<span class="udiff-line-removed">-     // need an internal word relocation.</span>
<span class="udiff-line-removed">-     case T_VOID: {</span>
<span class="udiff-line-removed">-       MachConstantNode* n = (MachConstantNode*) con.get_jobject();</span>
<span class="udiff-line-removed">-       // Fill the jump-table with a dummy word.  The real value is</span>
<span class="udiff-line-removed">-       // filled in later in fill_jump_table.</span>
<span class="udiff-line-removed">-       address dummy = (address) n;</span>
<span class="udiff-line-removed">-       constant_addr = _masm.address_constant(dummy);</span>
<span class="udiff-line-removed">-       // Expand jump-table</span>
<span class="udiff-line-removed">-       for (uint i = 1; i &lt; n-&gt;outcnt(); i++) {</span>
<span class="udiff-line-removed">-         address temp_addr = _masm.address_constant(dummy + i);</span>
<span class="udiff-line-removed">-         assert(temp_addr, &quot;consts section too small&quot;);</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       break;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     case T_METADATA: {</span>
<span class="udiff-line-removed">-       Metadata* obj = con.get_metadata();</span>
<span class="udiff-line-removed">-       int metadata_index = _masm.oop_recorder()-&gt;find_index(obj);</span>
<span class="udiff-line-removed">-       constant_addr = _masm.address_constant((address) obj, metadata_Relocation::spec(metadata_index));</span>
<span class="udiff-line-removed">-       break;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     default: ShouldNotReachHere();</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     assert(constant_addr, &quot;consts section too small&quot;);</span>
<span class="udiff-line-removed">-     assert((constant_addr - _masm.code()-&gt;consts()-&gt;start()) == con.offset(),</span>
<span class="udiff-line-removed">-             &quot;must be: %d == %d&quot;, (int) (constant_addr - _masm.code()-&gt;consts()-&gt;start()), (int)(con.offset()));</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- int Compile::ConstantTable::find_offset(Constant&amp; con) const {</span>
<span class="udiff-line-removed">-   int idx = _constants.find(con);</span>
<span class="udiff-line-removed">-   guarantee(idx != -1, &quot;constant must be in constant table&quot;);</span>
<span class="udiff-line-removed">-   int offset = _constants.at(idx).offset();</span>
<span class="udiff-line-removed">-   guarantee(offset != -1, &quot;constant table not emitted yet?&quot;);</span>
<span class="udiff-line-removed">-   return offset;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void Compile::ConstantTable::add(Constant&amp; con) {</span>
<span class="udiff-line-removed">-   if (con.can_be_reused()) {</span>
<span class="udiff-line-removed">-     int idx = _constants.find(con);</span>
<span class="udiff-line-removed">-     if (idx != -1 &amp;&amp; _constants.at(idx).can_be_reused()) {</span>
<span class="udiff-line-removed">-       _constants.adr_at(idx)-&gt;inc_freq(con.freq());  // increase the frequency by the current value</span>
<span class="udiff-line-removed">-       return;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   (void) _constants.append(con);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- Compile::Constant Compile::ConstantTable::add(MachConstantNode* n, BasicType type, jvalue value) {</span>
<span class="udiff-line-removed">-   Block* b = Compile::current()-&gt;cfg()-&gt;get_block_for_node(n);</span>
<span class="udiff-line-removed">-   Constant con(type, value, b-&gt;_freq);</span>
<span class="udiff-line-removed">-   add(con);</span>
<span class="udiff-line-removed">-   return con;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- Compile::Constant Compile::ConstantTable::add(Metadata* metadata) {</span>
<span class="udiff-line-removed">-   Constant con(metadata);</span>
<span class="udiff-line-removed">-   add(con);</span>
<span class="udiff-line-removed">-   return con;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- Compile::Constant Compile::ConstantTable::add(MachConstantNode* n, MachOper* oper) {</span>
<span class="udiff-line-removed">-   jvalue value;</span>
<span class="udiff-line-removed">-   BasicType type = oper-&gt;type()-&gt;basic_type();</span>
<span class="udiff-line-removed">-   switch (type) {</span>
<span class="udiff-line-removed">-   case T_LONG:    value.j = oper-&gt;constantL(); break;</span>
<span class="udiff-line-removed">-   case T_FLOAT:   value.f = oper-&gt;constantF(); break;</span>
<span class="udiff-line-removed">-   case T_DOUBLE:  value.d = oper-&gt;constantD(); break;</span>
<span class="udiff-line-removed">-   case T_OBJECT:</span>
<span class="udiff-line-removed">-   case T_ADDRESS: value.l = (jobject) oper-&gt;constant(); break;</span>
<span class="udiff-line-removed">-   case T_METADATA: return add((Metadata*)oper-&gt;constant()); break;</span>
<span class="udiff-line-removed">-   default: guarantee(false, &quot;unhandled type: %s&quot;, type2name(type));</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   return add(n, type, value);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- Compile::Constant Compile::ConstantTable::add_jump_table(MachConstantNode* n) {</span>
<span class="udiff-line-removed">-   jvalue value;</span>
<span class="udiff-line-removed">-   // We can use the node pointer here to identify the right jump-table</span>
<span class="udiff-line-removed">-   // as this method is called from Compile::Fill_buffer right before</span>
<span class="udiff-line-removed">-   // the MachNodes are emitted and the jump-table is filled (means the</span>
<span class="udiff-line-removed">-   // MachNode pointers do not change anymore).</span>
<span class="udiff-line-removed">-   value.l = (jobject) n;</span>
<span class="udiff-line-removed">-   Constant con(T_VOID, value, next_jump_table_freq(), false);  // Labels of a jump-table cannot be reused.</span>
<span class="udiff-line-removed">-   add(con);</span>
<span class="udiff-line-removed">-   return con;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void Compile::ConstantTable::fill_jump_table(CodeBuffer&amp; cb, MachConstantNode* n, GrowableArray&lt;Label*&gt; labels) const {</span>
<span class="udiff-line-removed">-   // If called from Compile::scratch_emit_size do nothing.</span>
<span class="udiff-line-removed">-   if (Compile::current()-&gt;in_scratch_emit_size())  return;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   assert(labels.is_nonempty(), &quot;must be&quot;);</span>
<span class="udiff-line-removed">-   assert((uint) labels.length() == n-&gt;outcnt(), &quot;must be equal: %d == %d&quot;, labels.length(), n-&gt;outcnt());</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Since MachConstantNode::constant_offset() also contains</span>
<span class="udiff-line-removed">-   // table_base_offset() we need to subtract the table_base_offset()</span>
<span class="udiff-line-removed">-   // to get the plain offset into the constant table.</span>
<span class="udiff-line-removed">-   int offset = n-&gt;constant_offset() - table_base_offset();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   MacroAssembler _masm(&amp;cb);</span>
<span class="udiff-line-removed">-   address* jump_table_base = (address*) (_masm.code()-&gt;consts()-&gt;start() + offset);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   for (uint i = 0; i &lt; n-&gt;outcnt(); i++) {</span>
<span class="udiff-line-removed">-     address* constant_addr = &amp;jump_table_base[i];</span>
<span class="udiff-line-removed">-     assert(*constant_addr == (((address) n) + i), &quot;all jump-table entries must contain adjusted node pointer: &quot; INTPTR_FORMAT &quot; == &quot; INTPTR_FORMAT, p2i(*constant_addr), p2i(((address) n) + i));</span>
<span class="udiff-line-removed">-     *constant_addr = cb.consts()-&gt;target(*labels.at(i), (address) constant_addr);</span>
<span class="udiff-line-removed">-     cb.consts()-&gt;relocate((address) constant_addr, relocInfo::internal_word_type);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  //----------------------------static_subtype_check-----------------------------
  // Shortcut important common cases when superklass is exact:
  // (0) superklass is java.lang.Object (can occur in reflective code)
  // (1) subklass is already limited to a subtype of superklass =&gt; always ok
  // (2) subklass does not overlap with superklass =&gt; always fail
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4240,13 +4008,10 @@</span>
      if (!ik-&gt;has_subklass() &amp;&amp; !ik-&gt;is_interface()) {
        if (!ik-&gt;is_final()) {
          // Add a dependency if there is a chance of a later subclass.
          dependencies()-&gt;assert_leaf_type(ik);
        }
<span class="udiff-line-removed">-       if (ik-&gt;is_abstract()) {</span>
<span class="udiff-line-removed">-         return SSC_always_false;</span>
<span class="udiff-line-removed">-       }</span>
        return SSC_easy_test;     // (3) caller can do a simple ptr comparison
      }
    } else {
      // A primitive array type has no subtypes.
      return SSC_easy_test;       // (3) caller can do a simple ptr comparison
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4774,5 +4539,23 @@</span>
    if (val != 0) {
      NodeCloneInfo ni(val);
      ni.dump();
    }
  }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Move Allocate nodes to the start of the list</span>
<span class="udiff-line-added">+ void Compile::sort_macro_nodes() {</span>
<span class="udiff-line-added">+   int count = macro_count();</span>
<span class="udiff-line-added">+   int allocates = 0;</span>
<span class="udiff-line-added">+   for (int i = 0; i &lt; count; i++) {</span>
<span class="udiff-line-added">+     Node* n = macro_node(i);</span>
<span class="udiff-line-added">+     if (n-&gt;is_Allocate()) {</span>
<span class="udiff-line-added">+       if (i != allocates) {</span>
<span class="udiff-line-added">+         Node* tmp = macro_node(allocates);</span>
<span class="udiff-line-added">+         _macro_nodes-&gt;at_put(allocates, n);</span>
<span class="udiff-line-added">+         _macro_nodes-&gt;at_put(i, tmp);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       allocates++;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
</pre>
<center><a href="classes.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="compile.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/loopTransform.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="loopPredicate.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="loopUnswitch.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/loopTransform.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1103   } else {                      // raise n to cover LCA of uses
1104     set_ctrl(n, find_non_split_ctrl(back_ctrl-&gt;in(0)));
1105   }
1106   return n;
1107 }
1108 
1109 Node* PhaseIdealLoop::cast_incr_before_loop(Node* incr, Node* ctrl, Node* loop) {
1110   Node* castii = new CastIINode(incr, TypeInt::INT, true);
1111   castii-&gt;set_req(0, ctrl);
1112   register_new_node(castii, ctrl);
1113   for (DUIterator_Fast imax, i = incr-&gt;fast_outs(imax); i &lt; imax; i++) {
1114     Node* n = incr-&gt;fast_out(i);
1115     if (n-&gt;is_Phi() &amp;&amp; n-&gt;in(0) == loop) {
1116       int nrep = n-&gt;replace_edge(incr, castii);
1117       return castii;
1118     }
1119   }
1120   return NULL;
1121 }
1122 













1123 // Make a copy of the skeleton range check predicates before the main
1124 // loop and set the initial value of loop as input. After unrolling,
1125 // the range of values for the induction variable in the main loop can
1126 // fall outside the allowed range of values by the array access (main
1127 // loop is never executed). When that happens, range check
1128 // CastII/ConvI2L nodes cause some data paths to die. For consistency,
1129 // the control paths must die too but the range checks were removed by
1130 // predication. The range checks that we add here guarantee that they do.
<span class="line-modified">1131 void PhaseIdealLoop::duplicate_predicates_helper(Node* predicate, Node* start, Node* end,</span>
1132                                                  IdealLoopTree* outer_loop, LoopNode* outer_main_head,
<span class="line-modified">1133                                                  uint dd_main_head) {</span>


1134   if (predicate != NULL) {




1135     IfNode* iff = predicate-&gt;in(0)-&gt;as_If();
1136     ProjNode* uncommon_proj = iff-&gt;proj_out(1 - predicate-&gt;as_Proj()-&gt;_con);
1137     Node* rgn = uncommon_proj-&gt;unique_ctrl_out();
1138     assert(rgn-&gt;is_Region() || rgn-&gt;is_Call(), &quot;must be a region or call uct&quot;);
1139     assert(iff-&gt;in(1)-&gt;in(1)-&gt;Opcode() == Op_Opaque1, &quot;unexpected predicate shape&quot;);
1140     predicate = iff-&gt;in(0);
1141     Node* current_proj = outer_main_head-&gt;in(LoopNode::EntryControl);
1142     Node* prev_proj = current_proj;
1143     while (predicate != NULL &amp;&amp; predicate-&gt;is_Proj() &amp;&amp; predicate-&gt;in(0)-&gt;is_If()) {
1144       iff = predicate-&gt;in(0)-&gt;as_If();
1145       uncommon_proj = iff-&gt;proj_out(1 - predicate-&gt;as_Proj()-&gt;_con);
1146       if (uncommon_proj-&gt;unique_ctrl_out() != rgn)
1147         break;
1148       if (iff-&gt;in(1)-&gt;Opcode() == Op_Opaque4) {
1149         assert(skeleton_predicate_has_opaque(iff), &quot;unexpected&quot;);
<span class="line-modified">1150         // Clone the predicate twice and initialize one with the initial</span>
1151         // value of the loop induction variable. Leave the other predicate
1152         // to be initialized when increasing the stride during loop unrolling.
1153         prev_proj = clone_skeleton_predicate(iff, start, predicate, uncommon_proj, current_proj, outer_loop, prev_proj);
1154         assert(skeleton_predicate_has_opaque(prev_proj-&gt;in(0)-&gt;as_If()) == (start-&gt;Opcode() == Op_Opaque1), &quot;&quot;);
1155         prev_proj = clone_skeleton_predicate(iff, end, predicate, uncommon_proj, current_proj, outer_loop, prev_proj);
1156         assert(skeleton_predicate_has_opaque(prev_proj-&gt;in(0)-&gt;as_If()) == (end-&gt;Opcode() == Op_Opaque1), &quot;&quot;);























1157         // Remove the skeleton predicate from the pre-loop
1158         _igvn.replace_input_of(iff, 1, _igvn.intcon(1));
1159       }
1160       predicate = predicate-&gt;in(0)-&gt;in(0);
1161     }
1162     _igvn.replace_input_of(outer_main_head, LoopNode::EntryControl, prev_proj);
1163     set_idom(outer_main_head, prev_proj, dd_main_head);
1164   }
1165 }
1166 
1167 static bool skeleton_follow_inputs(Node* n, int op) {
1168   return (n-&gt;is_Bool() ||
1169           n-&gt;is_Cmp() ||
1170           op == Op_AndL ||
1171           op == Op_OrL ||
1172           op == Op_RShiftL ||
1173           op == Op_LShiftL ||
1174           op == Op_AddL ||
1175           op == Op_AddI ||
1176           op == Op_MulL ||
</pre>
<hr />
<pre>
1261   Node* proj = predicate-&gt;clone();
1262   Node* other_proj = uncommon_proj-&gt;clone();
1263   Node* new_iff = iff-&gt;clone();
1264   new_iff-&gt;set_req(1, result);
1265   proj-&gt;set_req(0, new_iff);
1266   other_proj-&gt;set_req(0, new_iff);
1267   Node *frame = new ParmNode(C-&gt;start(), TypeFunc::FramePtr);
1268   register_new_node(frame, C-&gt;start());
1269   // It&#39;s impossible for the predicate to fail at runtime. Use an Halt node.
1270   Node* halt = new HaltNode(other_proj, frame, &quot;duplicated predicate failed which is impossible&quot;);
1271   C-&gt;root()-&gt;add_req(halt);
1272   new_iff-&gt;set_req(0, prev_proj);
1273 
1274   register_control(new_iff, outer_loop-&gt;_parent, prev_proj);
1275   register_control(proj, outer_loop-&gt;_parent, new_iff);
1276   register_control(other_proj, _ltree_root, new_iff);
1277   register_control(halt, _ltree_root, other_proj);
1278   return proj;
1279 }
1280 
<span class="line-modified">1281 void PhaseIdealLoop::duplicate_predicates(CountedLoopNode* pre_head, Node* start, Node* end,</span>
1282                                           IdealLoopTree* outer_loop, LoopNode* outer_main_head,
<span class="line-modified">1283                                           uint dd_main_head) {</span>


1284   if (UseLoopPredicate) {
1285     Node* entry = pre_head-&gt;in(LoopNode::EntryControl);
1286     Node* predicate = NULL;
1287     predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check);
1288     if (predicate != NULL) {
1289       entry = skip_loop_predicates(entry);
1290     }
1291     Node* profile_predicate = NULL;
1292     if (UseProfiledLoopPredicate) {
1293       profile_predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_profile_predicate);
1294       if (profile_predicate != NULL) {
1295         entry = skip_loop_predicates(entry);
1296       }
1297     }
1298     predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_predicate);
<span class="line-modified">1299     duplicate_predicates_helper(predicate, start, end, outer_loop, outer_main_head, dd_main_head);</span>
<span class="line-modified">1300     duplicate_predicates_helper(profile_predicate, start, end, outer_loop, outer_main_head, dd_main_head);</span>




1301   }
1302 }
1303 
1304 //------------------------------insert_pre_post_loops--------------------------
1305 // Insert pre and post loops.  If peel_only is set, the pre-loop can not have
1306 // more iterations added.  It acts as a &#39;peel&#39; only, no lower-bound RCE, no
1307 // alignment.  Useful to unroll loops that do no array accesses.
1308 void PhaseIdealLoop::insert_pre_post_loops(IdealLoopTree *loop, Node_List &amp;old_new, bool peel_only) {
1309 
1310 #ifndef PRODUCT
1311   if (TraceLoopOpts) {
1312     if (peel_only)
1313       tty-&gt;print(&quot;PeelMainPost &quot;);
1314     else
1315       tty-&gt;print(&quot;PreMainPost  &quot;);
1316     loop-&gt;dump_head();
1317   }
1318 #endif
1319   C-&gt;set_major_progress();
1320 
</pre>
<hr />
<pre>
1330   Node *limit     = main_end -&gt;limit();
1331   Node *stride    = main_end -&gt;stride();
1332   Node *cmp       = main_end -&gt;cmp_node();
1333   BoolTest::mask b_test = main_end-&gt;test_trip();
1334 
1335   // Need only 1 user of &#39;bol&#39; because I will be hacking the loop bounds.
1336   Node *bol = main_end-&gt;in(CountedLoopEndNode::TestValue);
1337   if (bol-&gt;outcnt() != 1) {
1338     bol = bol-&gt;clone();
1339     register_new_node(bol,main_end-&gt;in(CountedLoopEndNode::TestControl));
1340     _igvn.replace_input_of(main_end, CountedLoopEndNode::TestValue, bol);
1341   }
1342   // Need only 1 user of &#39;cmp&#39; because I will be hacking the loop bounds.
1343   if (cmp-&gt;outcnt() != 1) {
1344     cmp = cmp-&gt;clone();
1345     register_new_node(cmp,main_end-&gt;in(CountedLoopEndNode::TestControl));
1346     _igvn.replace_input_of(bol, 1, cmp);
1347   }
1348 
1349   // Add the post loop

1350   CountedLoopNode *post_head = NULL;
1351   Node *main_exit = insert_post_loop(loop, old_new, main_head, main_end, incr, limit, post_head);

1352 
1353   //------------------------------
1354   // Step B: Create Pre-Loop.
1355 
1356   // Step B1: Clone the loop body.  The clone becomes the pre-loop.  The main
1357   // loop pre-header illegally has 2 control users (old &amp; new loops).
1358   LoopNode* outer_main_head = main_head;
1359   IdealLoopTree* outer_loop = loop;
1360   if (main_head-&gt;is_strip_mined()) {
1361     main_head-&gt;verify_strip_mined(1);
1362     outer_main_head = main_head-&gt;outer_loop();
1363     outer_loop = loop-&gt;_parent;
1364     assert(outer_loop-&gt;_head == outer_main_head, &quot;broken loop tree&quot;);
1365   }
1366   uint dd_main_head = dom_depth(outer_main_head);
1367   clone_loop(loop, old_new, dd_main_head, ControlAroundStripMined);
1368   CountedLoopNode*    pre_head = old_new[main_head-&gt;_idx]-&gt;as_CountedLoop();
1369   CountedLoopEndNode* pre_end  = old_new[main_end -&gt;_idx]-&gt;as_CountedLoopEnd();
1370   pre_head-&gt;set_pre_loop(main_head);
1371   Node *pre_incr = old_new[incr-&gt;_idx];
</pre>
<hr />
<pre>
1429       _igvn.hash_delete(main_phi);
1430       main_phi-&gt;set_req(LoopNode::EntryControl, fallpre);
1431     }
1432   }
1433 
1434   // Nodes inside the loop may be control dependent on a predicate
1435   // that was moved before the preloop. If the back branch of the main
1436   // or post loops becomes dead, those nodes won&#39;t be dependent on the
1437   // test that guards that loop nest anymore which could lead to an
1438   // incorrect array access because it executes independently of the
1439   // test that was guarding the loop nest. We add a special CastII on
1440   // the if branch that enters the loop, between the input induction
1441   // variable value and the induction variable Phi to preserve correct
1442   // dependencies.
1443 
1444   // CastII for the main loop:
1445   Node* castii = cast_incr_before_loop(pre_incr, min_taken, main_head);
1446   assert(castii != NULL, &quot;no castII inserted&quot;);
1447   Node* opaque_castii = new Opaque1Node(C, castii);
1448   register_new_node(opaque_castii, outer_main_head-&gt;in(LoopNode::EntryControl));
<span class="line-modified">1449   duplicate_predicates(pre_head, castii, opaque_castii, outer_loop, outer_main_head, dd_main_head);</span>


1450 
1451   // Step B4: Shorten the pre-loop to run only 1 iteration (for now).
1452   // RCE and alignment may change this later.
1453   Node *cmp_end = pre_end-&gt;cmp_node();
1454   assert(cmp_end-&gt;in(2) == limit, &quot;&quot;);
1455   Node *pre_limit = new AddINode(init, stride);
1456 
1457   // Save the original loop limit in this Opaque1 node for
1458   // use by range check elimination.
1459   Node *pre_opaq  = new Opaque1Node(C, pre_limit, limit);
1460 
1461   register_new_node(pre_limit, pre_head-&gt;in(0));
1462   register_new_node(pre_opaq , pre_head-&gt;in(0));
1463 
1464   // Since no other users of pre-loop compare, I can hack limit directly
1465   assert(cmp_end-&gt;outcnt() == 1, &quot;no other users&quot;);
1466   _igvn.hash_delete(cmp_end);
1467   cmp_end-&gt;set_req(2, peel_only ? pre_limit : pre_opaq);
1468 
1469   // Special case for not-equal loop bounds:
</pre>
<hr />
<pre>
1715       _igvn.hash_delete(cur_phi);
1716       cur_phi-&gt;set_req(LoopNode::EntryControl, fallnew);
1717     }
1718   }
1719 
1720   // CastII for the new post loop:
1721   Node* castii = cast_incr_before_loop(zer_opaq-&gt;in(1), zer_taken, post_head);
1722   assert(castii != NULL, &quot;no castII inserted&quot;);
1723 
1724   return new_main_exit;
1725 }
1726 
1727 //------------------------------is_invariant-----------------------------
1728 // Return true if n is invariant
1729 bool IdealLoopTree::is_invariant(Node* n) const {
1730   Node *n_c = _phase-&gt;has_ctrl(n) ? _phase-&gt;get_ctrl(n) : n;
1731   if (n_c-&gt;is_top()) return false;
1732   return !is_member(_phase-&gt;get_loop(n_c));
1733 }
1734 
<span class="line-modified">1735 void PhaseIdealLoop::update_skeleton_predicates(Node* ctrl, CountedLoopNode* loop_head, Node* init, int stride_con) {</span>
1736   // Search for skeleton predicates and update them according to the new stride
1737   Node* entry = ctrl;
1738   Node* prev_proj = ctrl;
1739   LoopNode* outer_loop_head = loop_head-&gt;skip_strip_mined();
1740   IdealLoopTree* outer_loop = get_loop(outer_loop_head);
1741   while (entry != NULL &amp;&amp; entry-&gt;is_Proj() &amp;&amp; entry-&gt;in(0)-&gt;is_If()) {
1742     IfNode* iff = entry-&gt;in(0)-&gt;as_If();
1743     ProjNode* proj = iff-&gt;proj_out(1 - entry-&gt;as_Proj()-&gt;_con);
1744     if (proj-&gt;unique_ctrl_out()-&gt;Opcode() != Op_Halt) {
1745       break;
1746     }
1747     if (iff-&gt;in(1)-&gt;Opcode() == Op_Opaque4) {
1748       // Look for predicate with an Opaque1 node that can be used as a template
1749       if (!skeleton_predicate_has_opaque(iff)) {
1750         // No Opaque1 node? It&#39;s either the check for the first value
1751         // of the first iteration or the check for the last value of
1752         // the first iteration of an unrolled loop. We can&#39;t
1753         // tell. Kill it in any case.
1754         _igvn.replace_input_of(iff, 1, iff-&gt;in(1)-&gt;in(2));
1755       } else {
</pre>
<hr />
<pre>
1823     // graph shape is encountered, the compiler bails out loop unrolling;
1824     // compilation of the method will still succeed.
1825     if (!is_canonical_loop_entry(loop_head)) {
1826       return;
1827     }
1828     opaq = loop_head-&gt;skip_predicates()-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(2);
1829     // Zero-trip test uses an &#39;opaque&#39; node which is not shared.
1830     assert(opaq-&gt;outcnt() == 1 &amp;&amp; opaq-&gt;in(1) == limit, &quot;&quot;);
1831   }
1832 
1833   C-&gt;set_major_progress();
1834 
1835   Node* new_limit = NULL;
1836   int stride_con = stride-&gt;get_int();
1837   int stride_p = (stride_con &gt; 0) ? stride_con : -stride_con;
1838   uint old_trip_count = loop_head-&gt;trip_count();
1839   // Verify that unroll policy result is still valid.
1840   assert(old_trip_count &gt; 1 &amp;&amp;
1841       (!adjust_min_trip || stride_p &lt;= (1&lt;&lt;3)*loop_head-&gt;unrolled_count()), &quot;sanity&quot;);
1842 
<span class="line-modified">1843   update_skeleton_predicates(ctrl, loop_head, init, stride_con);</span>
1844 
1845   // Adjust loop limit to keep valid iterations number after unroll.
1846   // Use (limit - stride) instead of (((limit - init)/stride) &amp; (-2))*stride
1847   // which may overflow.
1848   if (!adjust_min_trip) {
1849     assert(old_trip_count &gt; 1 &amp;&amp; (old_trip_count &amp; 1) == 0,
1850         &quot;odd trip count for maximally unroll&quot;);
1851     // Don&#39;t need to adjust limit for maximally unroll since trip count is even.
1852   } else if (loop_head-&gt;has_exact_trip_count() &amp;&amp; init-&gt;is_Con()) {
1853     // Loop&#39;s limit is constant. Loop&#39;s init could be constant when pre-loop
1854     // become peeled iteration.
1855     jlong init_con = init-&gt;get_int();
1856     // We can keep old loop limit if iterations count stays the same:
1857     //   old_trip_count == new_trip_count * 2
1858     // Note: since old_trip_count &gt;= 2 then new_trip_count &gt;= 1
1859     // so we also don&#39;t need to adjust zero trip test.
1860     jlong limit_con  = limit-&gt;get_int();
1861     // (stride_con*2) not overflow since stride_con &lt;= 8.
1862     int new_stride_con = stride_con * 2;
1863     int stride_m    = new_stride_con - (stride_con &gt; 0 ? 1 : -1);
</pre>
</td>
<td>
<hr />
<pre>
1103   } else {                      // raise n to cover LCA of uses
1104     set_ctrl(n, find_non_split_ctrl(back_ctrl-&gt;in(0)));
1105   }
1106   return n;
1107 }
1108 
1109 Node* PhaseIdealLoop::cast_incr_before_loop(Node* incr, Node* ctrl, Node* loop) {
1110   Node* castii = new CastIINode(incr, TypeInt::INT, true);
1111   castii-&gt;set_req(0, ctrl);
1112   register_new_node(castii, ctrl);
1113   for (DUIterator_Fast imax, i = incr-&gt;fast_outs(imax); i &lt; imax; i++) {
1114     Node* n = incr-&gt;fast_out(i);
1115     if (n-&gt;is_Phi() &amp;&amp; n-&gt;in(0) == loop) {
1116       int nrep = n-&gt;replace_edge(incr, castii);
1117       return castii;
1118     }
1119   }
1120   return NULL;
1121 }
1122 
<span class="line-added">1123 #ifdef ASSERT</span>
<span class="line-added">1124 void PhaseIdealLoop::ensure_zero_trip_guard_proj(Node* node, bool is_main_loop) {</span>
<span class="line-added">1125   assert(node-&gt;is_IfProj(), &quot;must be the zero trip guard If node&quot;);</span>
<span class="line-added">1126   Node* zer_bol = node-&gt;in(0)-&gt;in(1);</span>
<span class="line-added">1127   assert(zer_bol != NULL &amp;&amp; zer_bol-&gt;is_Bool(), &quot;must be Bool&quot;);</span>
<span class="line-added">1128   Node* zer_cmp = zer_bol-&gt;in(1);</span>
<span class="line-added">1129   assert(zer_cmp != NULL &amp;&amp; zer_cmp-&gt;Opcode() == Op_CmpI, &quot;must be CmpI&quot;);</span>
<span class="line-added">1130   // For the main loop, the opaque node is the second input to zer_cmp, for the post loop it&#39;s the first input node</span>
<span class="line-added">1131   Node* zer_opaq = zer_cmp-&gt;in(is_main_loop ? 2 : 1);</span>
<span class="line-added">1132   assert(zer_opaq != NULL &amp;&amp; zer_opaq-&gt;Opcode() == Op_Opaque1, &quot;must be Opaque1&quot;);</span>
<span class="line-added">1133 }</span>
<span class="line-added">1134 #endif</span>
<span class="line-added">1135 </span>
1136 // Make a copy of the skeleton range check predicates before the main
1137 // loop and set the initial value of loop as input. After unrolling,
1138 // the range of values for the induction variable in the main loop can
1139 // fall outside the allowed range of values by the array access (main
1140 // loop is never executed). When that happens, range check
1141 // CastII/ConvI2L nodes cause some data paths to die. For consistency,
1142 // the control paths must die too but the range checks were removed by
1143 // predication. The range checks that we add here guarantee that they do.
<span class="line-modified">1144 void PhaseIdealLoop::copy_skeleton_predicates_to_main_loop_helper(Node* predicate, Node* start, Node* end,</span>
1145                                                  IdealLoopTree* outer_loop, LoopNode* outer_main_head,
<span class="line-modified">1146                                                  uint dd_main_head, const uint idx_before_pre_post,</span>
<span class="line-added">1147                                                  const uint idx_after_post_before_pre, Node* zero_trip_guard_proj_main,</span>
<span class="line-added">1148                                                  Node* zero_trip_guard_proj_post, const Node_List &amp;old_new) {</span>
1149   if (predicate != NULL) {
<span class="line-added">1150 #ifdef ASSERT</span>
<span class="line-added">1151     ensure_zero_trip_guard_proj(zero_trip_guard_proj_main, true);</span>
<span class="line-added">1152     ensure_zero_trip_guard_proj(zero_trip_guard_proj_post, false);</span>
<span class="line-added">1153 #endif</span>
1154     IfNode* iff = predicate-&gt;in(0)-&gt;as_If();
1155     ProjNode* uncommon_proj = iff-&gt;proj_out(1 - predicate-&gt;as_Proj()-&gt;_con);
1156     Node* rgn = uncommon_proj-&gt;unique_ctrl_out();
1157     assert(rgn-&gt;is_Region() || rgn-&gt;is_Call(), &quot;must be a region or call uct&quot;);
1158     assert(iff-&gt;in(1)-&gt;in(1)-&gt;Opcode() == Op_Opaque1, &quot;unexpected predicate shape&quot;);
1159     predicate = iff-&gt;in(0);
1160     Node* current_proj = outer_main_head-&gt;in(LoopNode::EntryControl);
1161     Node* prev_proj = current_proj;
1162     while (predicate != NULL &amp;&amp; predicate-&gt;is_Proj() &amp;&amp; predicate-&gt;in(0)-&gt;is_If()) {
1163       iff = predicate-&gt;in(0)-&gt;as_If();
1164       uncommon_proj = iff-&gt;proj_out(1 - predicate-&gt;as_Proj()-&gt;_con);
1165       if (uncommon_proj-&gt;unique_ctrl_out() != rgn)
1166         break;
1167       if (iff-&gt;in(1)-&gt;Opcode() == Op_Opaque4) {
1168         assert(skeleton_predicate_has_opaque(iff), &quot;unexpected&quot;);
<span class="line-modified">1169         // Clone the skeleton predicate twice and initialize one with the initial</span>
1170         // value of the loop induction variable. Leave the other predicate
1171         // to be initialized when increasing the stride during loop unrolling.
1172         prev_proj = clone_skeleton_predicate(iff, start, predicate, uncommon_proj, current_proj, outer_loop, prev_proj);
1173         assert(skeleton_predicate_has_opaque(prev_proj-&gt;in(0)-&gt;as_If()) == (start-&gt;Opcode() == Op_Opaque1), &quot;&quot;);
1174         prev_proj = clone_skeleton_predicate(iff, end, predicate, uncommon_proj, current_proj, outer_loop, prev_proj);
1175         assert(skeleton_predicate_has_opaque(prev_proj-&gt;in(0)-&gt;as_If()) == (end-&gt;Opcode() == Op_Opaque1), &quot;&quot;);
<span class="line-added">1176 </span>
<span class="line-added">1177         // Rewire any control inputs from the cloned skeleton predicates down to the main and post loop for data nodes that are part of the</span>
<span class="line-added">1178         // main loop (and were cloned to the pre and post loop).</span>
<span class="line-added">1179         for (DUIterator i = predicate-&gt;outs(); predicate-&gt;has_out(i); i++) {</span>
<span class="line-added">1180           Node* loop_node = predicate-&gt;out(i);</span>
<span class="line-added">1181           Node* pre_loop_node = old_new[loop_node-&gt;_idx];</span>
<span class="line-added">1182           // Change the control if &#39;loop_node&#39; is part of the main loop. If there is an old-&gt;new mapping and the index of</span>
<span class="line-added">1183           // &#39;pre_loop_node&#39; is greater than idx_before_pre_post, then we know that &#39;loop_node&#39; was cloned and is part of</span>
<span class="line-added">1184           // the main loop (and &#39;pre_loop_node&#39; is part of the pre loop).</span>
<span class="line-added">1185           if (!loop_node-&gt;is_CFG() &amp;&amp; (pre_loop_node != NULL &amp;&amp; pre_loop_node-&gt;_idx &gt; idx_after_post_before_pre)) {</span>
<span class="line-added">1186             // &#39;loop_node&#39; is a data node and part of the main loop. Rewire the control to the projection of the zero-trip guard if node</span>
<span class="line-added">1187             // of the main loop that is immediately preceding the cloned predicates.</span>
<span class="line-added">1188             _igvn.replace_input_of(loop_node, 0, zero_trip_guard_proj_main);</span>
<span class="line-added">1189             --i;</span>
<span class="line-added">1190           } else if (loop_node-&gt;_idx &gt; idx_before_pre_post &amp;&amp; loop_node-&gt;_idx &lt; idx_after_post_before_pre) {</span>
<span class="line-added">1191             // &#39;loop_node&#39; is a data node and part of the post loop. Rewire the control to the projection of the zero-trip guard if node</span>
<span class="line-added">1192             // of the post loop that is immediately preceding the post loop header node (there are no cloned predicates for the post loop).</span>
<span class="line-added">1193             assert(pre_loop_node == NULL, &quot;a node belonging to the post loop should not have an old_new mapping at this stage&quot;);</span>
<span class="line-added">1194             _igvn.replace_input_of(loop_node, 0, zero_trip_guard_proj_post);</span>
<span class="line-added">1195             --i;</span>
<span class="line-added">1196           }</span>
<span class="line-added">1197         }</span>
<span class="line-added">1198 </span>
1199         // Remove the skeleton predicate from the pre-loop
1200         _igvn.replace_input_of(iff, 1, _igvn.intcon(1));
1201       }
1202       predicate = predicate-&gt;in(0)-&gt;in(0);
1203     }
1204     _igvn.replace_input_of(outer_main_head, LoopNode::EntryControl, prev_proj);
1205     set_idom(outer_main_head, prev_proj, dd_main_head);
1206   }
1207 }
1208 
1209 static bool skeleton_follow_inputs(Node* n, int op) {
1210   return (n-&gt;is_Bool() ||
1211           n-&gt;is_Cmp() ||
1212           op == Op_AndL ||
1213           op == Op_OrL ||
1214           op == Op_RShiftL ||
1215           op == Op_LShiftL ||
1216           op == Op_AddL ||
1217           op == Op_AddI ||
1218           op == Op_MulL ||
</pre>
<hr />
<pre>
1303   Node* proj = predicate-&gt;clone();
1304   Node* other_proj = uncommon_proj-&gt;clone();
1305   Node* new_iff = iff-&gt;clone();
1306   new_iff-&gt;set_req(1, result);
1307   proj-&gt;set_req(0, new_iff);
1308   other_proj-&gt;set_req(0, new_iff);
1309   Node *frame = new ParmNode(C-&gt;start(), TypeFunc::FramePtr);
1310   register_new_node(frame, C-&gt;start());
1311   // It&#39;s impossible for the predicate to fail at runtime. Use an Halt node.
1312   Node* halt = new HaltNode(other_proj, frame, &quot;duplicated predicate failed which is impossible&quot;);
1313   C-&gt;root()-&gt;add_req(halt);
1314   new_iff-&gt;set_req(0, prev_proj);
1315 
1316   register_control(new_iff, outer_loop-&gt;_parent, prev_proj);
1317   register_control(proj, outer_loop-&gt;_parent, new_iff);
1318   register_control(other_proj, _ltree_root, new_iff);
1319   register_control(halt, _ltree_root, other_proj);
1320   return proj;
1321 }
1322 
<span class="line-modified">1323 void PhaseIdealLoop::copy_skeleton_predicates_to_main_loop(CountedLoopNode* pre_head, Node* start, Node* end,</span>
1324                                           IdealLoopTree* outer_loop, LoopNode* outer_main_head,
<span class="line-modified">1325                                           uint dd_main_head, const uint idx_before_pre_post,</span>
<span class="line-added">1326                                           const uint idx_after_post_before_pre, Node* zero_trip_guard_proj_main,</span>
<span class="line-added">1327                                           Node* zero_trip_guard_proj_post, const Node_List &amp;old_new) {</span>
1328   if (UseLoopPredicate) {
1329     Node* entry = pre_head-&gt;in(LoopNode::EntryControl);
1330     Node* predicate = NULL;
1331     predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check);
1332     if (predicate != NULL) {
1333       entry = skip_loop_predicates(entry);
1334     }
1335     Node* profile_predicate = NULL;
1336     if (UseProfiledLoopPredicate) {
1337       profile_predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_profile_predicate);
1338       if (profile_predicate != NULL) {
1339         entry = skip_loop_predicates(entry);
1340       }
1341     }
1342     predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_predicate);
<span class="line-modified">1343     copy_skeleton_predicates_to_main_loop_helper(predicate, start, end, outer_loop, outer_main_head, dd_main_head,</span>
<span class="line-modified">1344                                                  idx_before_pre_post, idx_after_post_before_pre, zero_trip_guard_proj_main,</span>
<span class="line-added">1345                                                  zero_trip_guard_proj_post, old_new);</span>
<span class="line-added">1346     copy_skeleton_predicates_to_main_loop_helper(profile_predicate, start, end, outer_loop, outer_main_head, dd_main_head,</span>
<span class="line-added">1347                                                  idx_before_pre_post, idx_after_post_before_pre, zero_trip_guard_proj_main,</span>
<span class="line-added">1348                                                  zero_trip_guard_proj_post, old_new);</span>
1349   }
1350 }
1351 
1352 //------------------------------insert_pre_post_loops--------------------------
1353 // Insert pre and post loops.  If peel_only is set, the pre-loop can not have
1354 // more iterations added.  It acts as a &#39;peel&#39; only, no lower-bound RCE, no
1355 // alignment.  Useful to unroll loops that do no array accesses.
1356 void PhaseIdealLoop::insert_pre_post_loops(IdealLoopTree *loop, Node_List &amp;old_new, bool peel_only) {
1357 
1358 #ifndef PRODUCT
1359   if (TraceLoopOpts) {
1360     if (peel_only)
1361       tty-&gt;print(&quot;PeelMainPost &quot;);
1362     else
1363       tty-&gt;print(&quot;PreMainPost  &quot;);
1364     loop-&gt;dump_head();
1365   }
1366 #endif
1367   C-&gt;set_major_progress();
1368 
</pre>
<hr />
<pre>
1378   Node *limit     = main_end -&gt;limit();
1379   Node *stride    = main_end -&gt;stride();
1380   Node *cmp       = main_end -&gt;cmp_node();
1381   BoolTest::mask b_test = main_end-&gt;test_trip();
1382 
1383   // Need only 1 user of &#39;bol&#39; because I will be hacking the loop bounds.
1384   Node *bol = main_end-&gt;in(CountedLoopEndNode::TestValue);
1385   if (bol-&gt;outcnt() != 1) {
1386     bol = bol-&gt;clone();
1387     register_new_node(bol,main_end-&gt;in(CountedLoopEndNode::TestControl));
1388     _igvn.replace_input_of(main_end, CountedLoopEndNode::TestValue, bol);
1389   }
1390   // Need only 1 user of &#39;cmp&#39; because I will be hacking the loop bounds.
1391   if (cmp-&gt;outcnt() != 1) {
1392     cmp = cmp-&gt;clone();
1393     register_new_node(cmp,main_end-&gt;in(CountedLoopEndNode::TestControl));
1394     _igvn.replace_input_of(bol, 1, cmp);
1395   }
1396 
1397   // Add the post loop
<span class="line-added">1398   const uint idx_before_pre_post = Compile::current()-&gt;unique();</span>
1399   CountedLoopNode *post_head = NULL;
1400   Node *main_exit = insert_post_loop(loop, old_new, main_head, main_end, incr, limit, post_head);
<span class="line-added">1401   const uint idx_after_post_before_pre = Compile::current()-&gt;unique();</span>
1402 
1403   //------------------------------
1404   // Step B: Create Pre-Loop.
1405 
1406   // Step B1: Clone the loop body.  The clone becomes the pre-loop.  The main
1407   // loop pre-header illegally has 2 control users (old &amp; new loops).
1408   LoopNode* outer_main_head = main_head;
1409   IdealLoopTree* outer_loop = loop;
1410   if (main_head-&gt;is_strip_mined()) {
1411     main_head-&gt;verify_strip_mined(1);
1412     outer_main_head = main_head-&gt;outer_loop();
1413     outer_loop = loop-&gt;_parent;
1414     assert(outer_loop-&gt;_head == outer_main_head, &quot;broken loop tree&quot;);
1415   }
1416   uint dd_main_head = dom_depth(outer_main_head);
1417   clone_loop(loop, old_new, dd_main_head, ControlAroundStripMined);
1418   CountedLoopNode*    pre_head = old_new[main_head-&gt;_idx]-&gt;as_CountedLoop();
1419   CountedLoopEndNode* pre_end  = old_new[main_end -&gt;_idx]-&gt;as_CountedLoopEnd();
1420   pre_head-&gt;set_pre_loop(main_head);
1421   Node *pre_incr = old_new[incr-&gt;_idx];
</pre>
<hr />
<pre>
1479       _igvn.hash_delete(main_phi);
1480       main_phi-&gt;set_req(LoopNode::EntryControl, fallpre);
1481     }
1482   }
1483 
1484   // Nodes inside the loop may be control dependent on a predicate
1485   // that was moved before the preloop. If the back branch of the main
1486   // or post loops becomes dead, those nodes won&#39;t be dependent on the
1487   // test that guards that loop nest anymore which could lead to an
1488   // incorrect array access because it executes independently of the
1489   // test that was guarding the loop nest. We add a special CastII on
1490   // the if branch that enters the loop, between the input induction
1491   // variable value and the induction variable Phi to preserve correct
1492   // dependencies.
1493 
1494   // CastII for the main loop:
1495   Node* castii = cast_incr_before_loop(pre_incr, min_taken, main_head);
1496   assert(castii != NULL, &quot;no castII inserted&quot;);
1497   Node* opaque_castii = new Opaque1Node(C, castii);
1498   register_new_node(opaque_castii, outer_main_head-&gt;in(LoopNode::EntryControl));
<span class="line-modified">1499   assert(post_head-&gt;in(1)-&gt;is_IfProj(), &quot;must be zero-trip guard If node projection of the post loop&quot;);</span>
<span class="line-added">1500   copy_skeleton_predicates_to_main_loop(pre_head, castii, opaque_castii, outer_loop, outer_main_head, dd_main_head,</span>
<span class="line-added">1501                                         idx_before_pre_post, idx_after_post_before_pre, min_taken, post_head-&gt;in(1), old_new);</span>
1502 
1503   // Step B4: Shorten the pre-loop to run only 1 iteration (for now).
1504   // RCE and alignment may change this later.
1505   Node *cmp_end = pre_end-&gt;cmp_node();
1506   assert(cmp_end-&gt;in(2) == limit, &quot;&quot;);
1507   Node *pre_limit = new AddINode(init, stride);
1508 
1509   // Save the original loop limit in this Opaque1 node for
1510   // use by range check elimination.
1511   Node *pre_opaq  = new Opaque1Node(C, pre_limit, limit);
1512 
1513   register_new_node(pre_limit, pre_head-&gt;in(0));
1514   register_new_node(pre_opaq , pre_head-&gt;in(0));
1515 
1516   // Since no other users of pre-loop compare, I can hack limit directly
1517   assert(cmp_end-&gt;outcnt() == 1, &quot;no other users&quot;);
1518   _igvn.hash_delete(cmp_end);
1519   cmp_end-&gt;set_req(2, peel_only ? pre_limit : pre_opaq);
1520 
1521   // Special case for not-equal loop bounds:
</pre>
<hr />
<pre>
1767       _igvn.hash_delete(cur_phi);
1768       cur_phi-&gt;set_req(LoopNode::EntryControl, fallnew);
1769     }
1770   }
1771 
1772   // CastII for the new post loop:
1773   Node* castii = cast_incr_before_loop(zer_opaq-&gt;in(1), zer_taken, post_head);
1774   assert(castii != NULL, &quot;no castII inserted&quot;);
1775 
1776   return new_main_exit;
1777 }
1778 
1779 //------------------------------is_invariant-----------------------------
1780 // Return true if n is invariant
1781 bool IdealLoopTree::is_invariant(Node* n) const {
1782   Node *n_c = _phase-&gt;has_ctrl(n) ? _phase-&gt;get_ctrl(n) : n;
1783   if (n_c-&gt;is_top()) return false;
1784   return !is_member(_phase-&gt;get_loop(n_c));
1785 }
1786 
<span class="line-modified">1787 void PhaseIdealLoop::update_main_loop_skeleton_predicates(Node* ctrl, CountedLoopNode* loop_head, Node* init, int stride_con) {</span>
1788   // Search for skeleton predicates and update them according to the new stride
1789   Node* entry = ctrl;
1790   Node* prev_proj = ctrl;
1791   LoopNode* outer_loop_head = loop_head-&gt;skip_strip_mined();
1792   IdealLoopTree* outer_loop = get_loop(outer_loop_head);
1793   while (entry != NULL &amp;&amp; entry-&gt;is_Proj() &amp;&amp; entry-&gt;in(0)-&gt;is_If()) {
1794     IfNode* iff = entry-&gt;in(0)-&gt;as_If();
1795     ProjNode* proj = iff-&gt;proj_out(1 - entry-&gt;as_Proj()-&gt;_con);
1796     if (proj-&gt;unique_ctrl_out()-&gt;Opcode() != Op_Halt) {
1797       break;
1798     }
1799     if (iff-&gt;in(1)-&gt;Opcode() == Op_Opaque4) {
1800       // Look for predicate with an Opaque1 node that can be used as a template
1801       if (!skeleton_predicate_has_opaque(iff)) {
1802         // No Opaque1 node? It&#39;s either the check for the first value
1803         // of the first iteration or the check for the last value of
1804         // the first iteration of an unrolled loop. We can&#39;t
1805         // tell. Kill it in any case.
1806         _igvn.replace_input_of(iff, 1, iff-&gt;in(1)-&gt;in(2));
1807       } else {
</pre>
<hr />
<pre>
1875     // graph shape is encountered, the compiler bails out loop unrolling;
1876     // compilation of the method will still succeed.
1877     if (!is_canonical_loop_entry(loop_head)) {
1878       return;
1879     }
1880     opaq = loop_head-&gt;skip_predicates()-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(2);
1881     // Zero-trip test uses an &#39;opaque&#39; node which is not shared.
1882     assert(opaq-&gt;outcnt() == 1 &amp;&amp; opaq-&gt;in(1) == limit, &quot;&quot;);
1883   }
1884 
1885   C-&gt;set_major_progress();
1886 
1887   Node* new_limit = NULL;
1888   int stride_con = stride-&gt;get_int();
1889   int stride_p = (stride_con &gt; 0) ? stride_con : -stride_con;
1890   uint old_trip_count = loop_head-&gt;trip_count();
1891   // Verify that unroll policy result is still valid.
1892   assert(old_trip_count &gt; 1 &amp;&amp;
1893       (!adjust_min_trip || stride_p &lt;= (1&lt;&lt;3)*loop_head-&gt;unrolled_count()), &quot;sanity&quot;);
1894 
<span class="line-modified">1895   update_main_loop_skeleton_predicates(ctrl, loop_head, init, stride_con);</span>
1896 
1897   // Adjust loop limit to keep valid iterations number after unroll.
1898   // Use (limit - stride) instead of (((limit - init)/stride) &amp; (-2))*stride
1899   // which may overflow.
1900   if (!adjust_min_trip) {
1901     assert(old_trip_count &gt; 1 &amp;&amp; (old_trip_count &amp; 1) == 0,
1902         &quot;odd trip count for maximally unroll&quot;);
1903     // Don&#39;t need to adjust limit for maximally unroll since trip count is even.
1904   } else if (loop_head-&gt;has_exact_trip_count() &amp;&amp; init-&gt;is_Con()) {
1905     // Loop&#39;s limit is constant. Loop&#39;s init could be constant when pre-loop
1906     // become peeled iteration.
1907     jlong init_con = init-&gt;get_int();
1908     // We can keep old loop limit if iterations count stays the same:
1909     //   old_trip_count == new_trip_count * 2
1910     // Note: since old_trip_count &gt;= 2 then new_trip_count &gt;= 1
1911     // so we also don&#39;t need to adjust zero trip test.
1912     jlong limit_con  = limit-&gt;get_int();
1913     // (stride_con*2) not overflow since stride_con &lt;= 8.
1914     int new_stride_con = stride_con * 2;
1915     int stride_m    = new_stride_con - (stride_con &gt; 0 ? 1 : -1);
</pre>
</td>
</tr>
</table>
<center><a href="loopPredicate.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="loopUnswitch.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/type.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OPTO_TYPE_HPP
  26 #define SHARE_OPTO_TYPE_HPP
  27 
  28 #include &quot;opto/adlcVMDeps.hpp&quot;
  29 #include &quot;runtime/handles.hpp&quot;
  30 
  31 // Portions of code courtesy of Clifford Click
  32 
  33 // Optimization - Graph Style
  34 
  35 
  36 // This class defines a Type lattice.  The lattice is used in the constant
  37 // propagation algorithms, and for some type-checking of the iloc code.
  38 // Basic types include RSD&#39;s (lower bound, upper bound, stride for integers),
  39 // float &amp; double precision constants, sets of data-labels and code-labels.
  40 // The complete lattice is described below.  Subtypes have no relationship to
  41 // up or down in the lattice; that is entirely determined by the behavior of
  42 // the MEET/JOIN functions.
  43 
  44 class Dict;
  45 class Type;
  46 class   TypeD;
  47 class   TypeF;
  48 class   TypeInt;
  49 class   TypeLong;
  50 class   TypeNarrowPtr;
  51 class     TypeNarrowOop;
  52 class     TypeNarrowKlass;
  53 class   TypeAry;
  54 class   TypeTuple;
  55 class   TypeVect;
  56 class     TypeVectS;
  57 class     TypeVectD;
  58 class     TypeVectX;
  59 class     TypeVectY;
  60 class     TypeVectZ;
  61 class   TypePtr;
  62 class     TypeRawPtr;
  63 class     TypeOopPtr;
  64 class       TypeInstPtr;
  65 class       TypeAryPtr;
  66 class     TypeKlassPtr;
  67 class     TypeMetadataPtr;
  68 
  69 //------------------------------Type-------------------------------------------
  70 // Basic Type object, represents a set of primitive Values.
  71 // Types are hash-cons&#39;d into a private class dictionary, so only one of each
  72 // different kind of Type exists.  Types are never modified after creation, so
  73 // all their interesting fields are constant.
  74 class Type {
  75   friend class VMStructs;
  76 
  77 public:
  78   enum TYPES {
  79     Bad=0,                      // Type check
  80     Control,                    // Control of code (not in lattice)
  81     Top,                        // Top of the lattice
  82     Int,                        // Integer range (lo-hi)
  83     Long,                       // Long integer range (lo-hi)
  84     Half,                       // Placeholder half of doubleword
  85     NarrowOop,                  // Compressed oop pointer
  86     NarrowKlass,                // Compressed klass pointer
  87 
  88     Tuple,                      // Method signature or object layout
  89     Array,                      // Array types
  90     VectorS,                    //  32bit Vector types
  91     VectorD,                    //  64bit Vector types
  92     VectorX,                    // 128bit Vector types
  93     VectorY,                    // 256bit Vector types
  94     VectorZ,                    // 512bit Vector types
  95 
  96     AnyPtr,                     // Any old raw, klass, inst, or array pointer
  97     RawPtr,                     // Raw (non-oop) pointers
  98     OopPtr,                     // Any and all Java heap entities
  99     InstPtr,                    // Instance pointers (non-array objects)
 100     AryPtr,                     // Array pointers
 101     // (Ptr order matters:  See is_ptr, isa_ptr, is_oopptr, isa_oopptr.)
 102 
 103     MetadataPtr,                // Generic metadata
 104     KlassPtr,                   // Klass pointers
 105 
 106     Function,                   // Function signature
 107     Abio,                       // Abstract I/O
 108     Return_Address,             // Subroutine return address
 109     Memory,                     // Abstract store
 110     FloatTop,                   // No float value
 111     FloatCon,                   // Floating point constant
 112     FloatBot,                   // Any float value
 113     DoubleTop,                  // No double value
 114     DoubleCon,                  // Double precision constant
 115     DoubleBot,                  // Any double value
 116     Bottom,                     // Bottom of lattice
 117     lastype                     // Bogus ending type (not in lattice)
 118   };
 119 
 120   // Signal values for offsets from a base pointer
 121   enum OFFSET_SIGNALS {
 122     OffsetTop = -2000000000,    // undefined offset
 123     OffsetBot = -2000000001     // any possible offset
 124   };
 125 
 126   // Min and max WIDEN values.
 127   enum WIDEN {
 128     WidenMin = 0,
 129     WidenMax = 3
 130   };
 131 
 132 private:
 133   typedef struct {
 134     TYPES                dual_type;
 135     BasicType            basic_type;
 136     const char*          msg;
 137     bool                 isa_oop;
 138     uint                 ideal_reg;
 139     relocInfo::relocType reloc;
 140   } TypeInfo;
 141 
 142   // Dictionary of types shared among compilations.
 143   static Dict* _shared_type_dict;
 144   static const TypeInfo _type_info[];
 145 
 146   static int uhash( const Type *const t );
 147   // Structural equality check.  Assumes that cmp() has already compared
 148   // the _base types and thus knows it can cast &#39;t&#39; appropriately.
 149   virtual bool eq( const Type *t ) const;
 150 
 151   // Top-level hash-table of types
 152   static Dict *type_dict() {
 153     return Compile::current()-&gt;type_dict();
 154   }
 155 
 156   // DUAL operation: reflect around lattice centerline.  Used instead of
 157   // join to ensure my lattice is symmetric up and down.  Dual is computed
 158   // lazily, on demand, and cached in _dual.
 159   const Type *_dual;            // Cached dual value
 160   // Table for efficient dualing of base types
 161   static const TYPES dual_type[lastype];
 162 
 163 #ifdef ASSERT
 164   // One type is interface, the other is oop
 165   virtual bool interface_vs_oop_helper(const Type *t) const;
 166 #endif
 167 
 168   const Type *meet_helper(const Type *t, bool include_speculative) const;
<a name="1" id="anc1"></a><span class="line-added"> 169   void check_symmetrical(const Type *t, const Type *mt) const;</span>
 170 
 171 protected:
 172   // Each class of type is also identified by its base.
 173   const TYPES _base;            // Enum of Types type
 174 
 175   Type( TYPES t ) : _dual(NULL),  _base(t) {} // Simple types
 176   // ~Type();                   // Use fast deallocation
 177   const Type *hashcons();       // Hash-cons the type
 178   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
 179   const Type *join_helper(const Type *t, bool include_speculative) const {
 180     return dual()-&gt;meet_helper(t-&gt;dual(), include_speculative)-&gt;dual();
 181   }
 182 
 183 public:
 184 
 185   inline void* operator new( size_t x ) throw() {
 186     Compile* compile = Compile::current();
 187     compile-&gt;set_type_last_size(x);
 188     return compile-&gt;type_arena()-&gt;Amalloc_D(x);
 189   }
 190   inline void operator delete( void* ptr ) {
 191     Compile* compile = Compile::current();
 192     compile-&gt;type_arena()-&gt;Afree(ptr,compile-&gt;type_last_size());
 193   }
 194 
 195   // Initialize the type system for a particular compilation.
 196   static void Initialize(Compile* compile);
 197 
 198   // Initialize the types shared by all compilations.
 199   static void Initialize_shared(Compile* compile);
 200 
 201   TYPES base() const {
 202     assert(_base &gt; Bad &amp;&amp; _base &lt; lastype, &quot;sanity&quot;);
 203     return _base;
 204   }
 205 
 206   // Create a new hash-consd type
 207   static const Type *make(enum TYPES);
 208   // Test for equivalence of types
 209   static int cmp( const Type *const t1, const Type *const t2 );
 210   // Test for higher or equal in lattice
 211   // Variant that drops the speculative part of the types
 212   bool higher_equal(const Type *t) const {
 213     return !cmp(meet(t),t-&gt;remove_speculative());
 214   }
 215   // Variant that keeps the speculative part of the types
 216   bool higher_equal_speculative(const Type *t) const {
 217     return !cmp(meet_speculative(t),t);
 218   }
 219 
 220   // MEET operation; lower in lattice.
 221   // Variant that drops the speculative part of the types
 222   const Type *meet(const Type *t) const {
 223     return meet_helper(t, false);
 224   }
 225   // Variant that keeps the speculative part of the types
 226   const Type *meet_speculative(const Type *t) const {
 227     return meet_helper(t, true)-&gt;cleanup_speculative();
 228   }
 229   // WIDEN: &#39;widens&#39; for Ints and other range types
 230   virtual const Type *widen( const Type *old, const Type* limit ) const { return this; }
 231   // NARROW: complement for widen, used by pessimistic phases
 232   virtual const Type *narrow( const Type *old ) const { return this; }
 233 
 234   // DUAL operation: reflect around lattice centerline.  Used instead of
 235   // join to ensure my lattice is symmetric up and down.
 236   const Type *dual() const { return _dual; }
 237 
 238   // Compute meet dependent on base type
 239   virtual const Type *xmeet( const Type *t ) const;
 240   virtual const Type *xdual() const;    // Compute dual right now.
 241 
 242   // JOIN operation; higher in lattice.  Done by finding the dual of the
 243   // meet of the dual of the 2 inputs.
 244   // Variant that drops the speculative part of the types
 245   const Type *join(const Type *t) const {
 246     return join_helper(t, false);
 247   }
 248   // Variant that keeps the speculative part of the types
 249   const Type *join_speculative(const Type *t) const {
 250     return join_helper(t, true)-&gt;cleanup_speculative();
 251   }
 252 
 253   // Modified version of JOIN adapted to the needs Node::Value.
 254   // Normalizes all empty values to TOP.  Does not kill _widen bits.
 255   // Currently, it also works around limitations involving interface types.
 256   // Variant that drops the speculative part of the types
 257   const Type *filter(const Type *kills) const {
 258     return filter_helper(kills, false);
 259   }
 260   // Variant that keeps the speculative part of the types
 261   const Type *filter_speculative(const Type *kills) const {
 262     return filter_helper(kills, true)-&gt;cleanup_speculative();
 263   }
 264 
 265 #ifdef ASSERT
 266   // One type is interface, the other is oop
 267   virtual bool interface_vs_oop(const Type *t) const;
 268 #endif
 269 
 270   // Returns true if this pointer points at memory which contains a
 271   // compressed oop references.
 272   bool is_ptr_to_narrowoop() const;
 273   bool is_ptr_to_narrowklass() const;
 274 
 275   bool is_ptr_to_boxing_obj() const;
 276 
 277 
 278   // Convenience access
 279   float getf() const;
 280   double getd() const;
 281 
 282   const TypeInt    *is_int() const;
 283   const TypeInt    *isa_int() const;             // Returns NULL if not an Int
 284   const TypeLong   *is_long() const;
 285   const TypeLong   *isa_long() const;            // Returns NULL if not a Long
 286   const TypeD      *isa_double() const;          // Returns NULL if not a Double{Top,Con,Bot}
 287   const TypeD      *is_double_constant() const;  // Asserts it is a DoubleCon
 288   const TypeD      *isa_double_constant() const; // Returns NULL if not a DoubleCon
 289   const TypeF      *isa_float() const;           // Returns NULL if not a Float{Top,Con,Bot}
 290   const TypeF      *is_float_constant() const;   // Asserts it is a FloatCon
 291   const TypeF      *isa_float_constant() const;  // Returns NULL if not a FloatCon
 292   const TypeTuple  *is_tuple() const;            // Collection of fields, NOT a pointer
 293   const TypeAry    *is_ary() const;              // Array, NOT array pointer
 294   const TypeAry    *isa_ary() const;             // Returns NULL of not ary
 295   const TypeVect   *is_vect() const;             // Vector
 296   const TypeVect   *isa_vect() const;            // Returns NULL if not a Vector
 297   const TypePtr    *is_ptr() const;              // Asserts it is a ptr type
 298   const TypePtr    *isa_ptr() const;             // Returns NULL if not ptr type
 299   const TypeRawPtr *isa_rawptr() const;          // NOT Java oop
 300   const TypeRawPtr *is_rawptr() const;           // Asserts is rawptr
 301   const TypeNarrowOop  *is_narrowoop() const;    // Java-style GC&#39;d pointer
 302   const TypeNarrowOop  *isa_narrowoop() const;   // Returns NULL if not oop ptr type
 303   const TypeNarrowKlass *is_narrowklass() const; // compressed klass pointer
 304   const TypeNarrowKlass *isa_narrowklass() const;// Returns NULL if not oop ptr type
 305   const TypeOopPtr   *isa_oopptr() const;        // Returns NULL if not oop ptr type
 306   const TypeOopPtr   *is_oopptr() const;         // Java-style GC&#39;d pointer
 307   const TypeInstPtr  *isa_instptr() const;       // Returns NULL if not InstPtr
 308   const TypeInstPtr  *is_instptr() const;        // Instance
 309   const TypeAryPtr   *isa_aryptr() const;        // Returns NULL if not AryPtr
 310   const TypeAryPtr   *is_aryptr() const;         // Array oop
 311 
 312   const TypeMetadataPtr   *isa_metadataptr() const;   // Returns NULL if not oop ptr type
 313   const TypeMetadataPtr   *is_metadataptr() const;    // Java-style GC&#39;d pointer
 314   const TypeKlassPtr      *isa_klassptr() const;      // Returns NULL if not KlassPtr
 315   const TypeKlassPtr      *is_klassptr() const;       // assert if not KlassPtr
 316 
 317   virtual bool      is_finite() const;           // Has a finite value
 318   virtual bool      is_nan()    const;           // Is not a number (NaN)
 319 
 320   // Returns this ptr type or the equivalent ptr type for this compressed pointer.
 321   const TypePtr* make_ptr() const;
 322 
 323   // Returns this oopptr type or the equivalent oopptr type for this compressed pointer.
 324   // Asserts if the underlying type is not an oopptr or narrowoop.
 325   const TypeOopPtr* make_oopptr() const;
 326 
 327   // Returns this compressed pointer or the equivalent compressed version
 328   // of this pointer type.
 329   const TypeNarrowOop* make_narrowoop() const;
 330 
 331   // Returns this compressed klass pointer or the equivalent
 332   // compressed version of this pointer type.
 333   const TypeNarrowKlass* make_narrowklass() const;
 334 
 335   // Special test for register pressure heuristic
 336   bool is_floatingpoint() const;        // True if Float or Double base type
 337 
 338   // Do you have memory, directly or through a tuple?
 339   bool has_memory( ) const;
 340 
 341   // TRUE if type is a singleton
 342   virtual bool singleton(void) const;
 343 
 344   // TRUE if type is above the lattice centerline, and is therefore vacuous
 345   virtual bool empty(void) const;
 346 
 347   // Return a hash for this type.  The hash function is public so ConNode
 348   // (constants) can hash on their constant, which is represented by a Type.
 349   virtual int hash() const;
 350 
 351   // Map ideal registers (machine types) to ideal types
 352   static const Type *mreg2type[];
 353 
 354   // Printing, statistics
 355 #ifndef PRODUCT
 356   void         dump_on(outputStream *st) const;
 357   void         dump() const {
 358     dump_on(tty);
 359   }
 360   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
 361   static  void dump_stats();
 362 
 363   static const char* str(const Type* t);
 364 #endif
 365   void typerr(const Type *t) const; // Mixing types error
 366 
 367   // Create basic type
 368   static const Type* get_const_basic_type(BasicType type) {
 369     assert((uint)type &lt;= T_CONFLICT &amp;&amp; _const_basic_type[type] != NULL, &quot;bad type&quot;);
 370     return _const_basic_type[type];
 371   }
 372 
 373   // For two instance arrays of same dimension, return the base element types.
 374   // Otherwise or if the arrays have different dimensions, return NULL.
 375   static void get_arrays_base_elements(const Type *a1, const Type *a2,
 376                                        const TypeInstPtr **e1, const TypeInstPtr **e2);
 377 
 378   // Mapping to the array element&#39;s basic type.
 379   BasicType array_element_basic_type() const;
 380 
 381   // Create standard type for a ciType:
 382   static const Type* get_const_type(ciType* type);
 383 
 384   // Create standard zero value:
 385   static const Type* get_zero_type(BasicType type) {
 386     assert((uint)type &lt;= T_CONFLICT &amp;&amp; _zero_type[type] != NULL, &quot;bad type&quot;);
 387     return _zero_type[type];
 388   }
 389 
 390   // Report if this is a zero value (not top).
 391   bool is_zero_type() const {
 392     BasicType type = basic_type();
 393     if (type == T_VOID || type &gt;= T_CONFLICT)
 394       return false;
 395     else
 396       return (this == _zero_type[type]);
 397   }
 398 
 399   // Convenience common pre-built types.
 400   static const Type *ABIO;
 401   static const Type *BOTTOM;
 402   static const Type *CONTROL;
 403   static const Type *DOUBLE;
 404   static const Type *FLOAT;
 405   static const Type *HALF;
 406   static const Type *MEMORY;
 407   static const Type *MULTI;
 408   static const Type *RETURN_ADDRESS;
 409   static const Type *TOP;
 410 
 411   // Mapping from compiler type to VM BasicType
 412   BasicType basic_type() const       { return _type_info[_base].basic_type; }
 413   uint ideal_reg() const             { return _type_info[_base].ideal_reg; }
 414   const char* msg() const            { return _type_info[_base].msg; }
 415   bool isa_oop_ptr() const           { return _type_info[_base].isa_oop; }
 416   relocInfo::relocType reloc() const { return _type_info[_base].reloc; }
 417 
 418   // Mapping from CI type system to compiler type:
 419   static const Type* get_typeflow_type(ciType* type);
 420 
 421   static const Type* make_from_constant(ciConstant constant,
 422                                         bool require_constant = false,
 423                                         int stable_dimension = 0,
 424                                         bool is_narrow = false,
 425                                         bool is_autobox_cache = false);
 426 
 427   static const Type* make_constant_from_field(ciInstance* holder,
 428                                               int off,
 429                                               bool is_unsigned_load,
 430                                               BasicType loadbt);
 431 
 432   static const Type* make_constant_from_field(ciField* field,
 433                                               ciInstance* holder,
 434                                               BasicType loadbt,
 435                                               bool is_unsigned_load);
 436 
 437   static const Type* make_constant_from_array_element(ciArray* array,
 438                                                       int off,
 439                                                       int stable_dimension,
 440                                                       BasicType loadbt,
 441                                                       bool is_unsigned_load);
 442 
 443   // Speculative type helper methods. See TypePtr.
 444   virtual const TypePtr* speculative() const                                  { return NULL; }
 445   virtual ciKlass* speculative_type() const                                   { return NULL; }
 446   virtual ciKlass* speculative_type_not_null() const                          { return NULL; }
 447   virtual bool speculative_maybe_null() const                                 { return true; }
 448   virtual bool speculative_always_null() const                                { return true; }
 449   virtual const Type* remove_speculative() const                              { return this; }
 450   virtual const Type* cleanup_speculative() const                             { return this; }
 451   virtual bool would_improve_type(ciKlass* exact_kls, int inline_depth) const { return exact_kls != NULL; }
 452   virtual bool would_improve_ptr(ProfilePtrKind ptr_kind) const { return ptr_kind == ProfileAlwaysNull || ptr_kind == ProfileNeverNull; }
 453   const Type* maybe_remove_speculative(bool include_speculative) const;
 454 
 455   virtual bool maybe_null() const { return true; }
 456   virtual bool is_known_instance() const { return false; }
 457 
 458 private:
 459   // support arrays
 460   static const Type*        _zero_type[T_CONFLICT+1];
 461   static const Type* _const_basic_type[T_CONFLICT+1];
 462 };
 463 
 464 //------------------------------TypeF------------------------------------------
 465 // Class of Float-Constant Types.
 466 class TypeF : public Type {
 467   TypeF( float f ) : Type(FloatCon), _f(f) {};
 468 public:
 469   virtual bool eq( const Type *t ) const;
 470   virtual int  hash() const;             // Type specific hashing
 471   virtual bool singleton(void) const;    // TRUE if type is a singleton
 472   virtual bool empty(void) const;        // TRUE if type is vacuous
 473 public:
 474   const float _f;               // Float constant
 475 
 476   static const TypeF *make(float f);
 477 
 478   virtual bool        is_finite() const;  // Has a finite value
 479   virtual bool        is_nan()    const;  // Is not a number (NaN)
 480 
 481   virtual const Type *xmeet( const Type *t ) const;
 482   virtual const Type *xdual() const;    // Compute dual right now.
 483   // Convenience common pre-built types.
 484   static const TypeF *ZERO; // positive zero only
 485   static const TypeF *ONE;
 486   static const TypeF *POS_INF;
 487   static const TypeF *NEG_INF;
 488 #ifndef PRODUCT
 489   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
 490 #endif
 491 };
 492 
 493 //------------------------------TypeD------------------------------------------
 494 // Class of Double-Constant Types.
 495 class TypeD : public Type {
 496   TypeD( double d ) : Type(DoubleCon), _d(d) {};
 497 public:
 498   virtual bool eq( const Type *t ) const;
 499   virtual int  hash() const;             // Type specific hashing
 500   virtual bool singleton(void) const;    // TRUE if type is a singleton
 501   virtual bool empty(void) const;        // TRUE if type is vacuous
 502 public:
 503   const double _d;              // Double constant
 504 
 505   static const TypeD *make(double d);
 506 
 507   virtual bool        is_finite() const;  // Has a finite value
 508   virtual bool        is_nan()    const;  // Is not a number (NaN)
 509 
 510   virtual const Type *xmeet( const Type *t ) const;
 511   virtual const Type *xdual() const;    // Compute dual right now.
 512   // Convenience common pre-built types.
 513   static const TypeD *ZERO; // positive zero only
 514   static const TypeD *ONE;
 515   static const TypeD *POS_INF;
 516   static const TypeD *NEG_INF;
 517 #ifndef PRODUCT
 518   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
 519 #endif
 520 };
 521 
 522 //------------------------------TypeInt----------------------------------------
 523 // Class of integer ranges, the set of integers between a lower bound and an
 524 // upper bound, inclusive.
 525 class TypeInt : public Type {
 526   TypeInt( jint lo, jint hi, int w );
 527 protected:
 528   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
 529 
 530 public:
 531   typedef jint NativeType;
 532   virtual bool eq( const Type *t ) const;
 533   virtual int  hash() const;             // Type specific hashing
 534   virtual bool singleton(void) const;    // TRUE if type is a singleton
 535   virtual bool empty(void) const;        // TRUE if type is vacuous
 536   const jint _lo, _hi;          // Lower bound, upper bound
 537   const short _widen;           // Limit on times we widen this sucker
 538 
 539   static const TypeInt *make(jint lo);
 540   // must always specify w
 541   static const TypeInt *make(jint lo, jint hi, int w);
 542 
 543   // Check for single integer
 544   int is_con() const { return _lo==_hi; }
 545   bool is_con(int i) const { return is_con() &amp;&amp; _lo == i; }
 546   jint get_con() const { assert( is_con(), &quot;&quot; );  return _lo; }
 547 
 548   virtual bool        is_finite() const;  // Has a finite value
 549 
 550   virtual const Type *xmeet( const Type *t ) const;
 551   virtual const Type *xdual() const;    // Compute dual right now.
 552   virtual const Type *widen( const Type *t, const Type* limit_type ) const;
 553   virtual const Type *narrow( const Type *t ) const;
 554   // Do not kill _widen bits.
 555   // Convenience common pre-built types.
 556   static const TypeInt *MINUS_1;
 557   static const TypeInt *ZERO;
 558   static const TypeInt *ONE;
 559   static const TypeInt *BOOL;
 560   static const TypeInt *CC;
 561   static const TypeInt *CC_LT;  // [-1]  == MINUS_1
 562   static const TypeInt *CC_GT;  // [1]   == ONE
 563   static const TypeInt *CC_EQ;  // [0]   == ZERO
 564   static const TypeInt *CC_LE;  // [-1,0]
 565   static const TypeInt *CC_GE;  // [0,1] == BOOL (!)
 566   static const TypeInt *BYTE;
 567   static const TypeInt *UBYTE;
 568   static const TypeInt *CHAR;
 569   static const TypeInt *SHORT;
 570   static const TypeInt *POS;
 571   static const TypeInt *POS1;
 572   static const TypeInt *INT;
 573   static const TypeInt *SYMINT; // symmetric range [-max_jint..max_jint]
 574   static const TypeInt *TYPE_DOMAIN; // alias for TypeInt::INT
 575 
 576   static const TypeInt *as_self(const Type *t) { return t-&gt;is_int(); }
 577 #ifndef PRODUCT
 578   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
 579 #endif
 580 };
 581 
 582 
 583 //------------------------------TypeLong---------------------------------------
 584 // Class of long integer ranges, the set of integers between a lower bound and
 585 // an upper bound, inclusive.
 586 class TypeLong : public Type {
 587   TypeLong( jlong lo, jlong hi, int w );
 588 protected:
 589   // Do not kill _widen bits.
 590   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
 591 public:
 592   typedef jlong NativeType;
 593   virtual bool eq( const Type *t ) const;
 594   virtual int  hash() const;             // Type specific hashing
 595   virtual bool singleton(void) const;    // TRUE if type is a singleton
 596   virtual bool empty(void) const;        // TRUE if type is vacuous
 597 public:
 598   const jlong _lo, _hi;         // Lower bound, upper bound
 599   const short _widen;           // Limit on times we widen this sucker
 600 
 601   static const TypeLong *make(jlong lo);
 602   // must always specify w
 603   static const TypeLong *make(jlong lo, jlong hi, int w);
 604 
 605   // Check for single integer
 606   int is_con() const { return _lo==_hi; }
 607   bool is_con(int i) const { return is_con() &amp;&amp; _lo == i; }
 608   jlong get_con() const { assert( is_con(), &quot;&quot; ); return _lo; }
 609 
 610   // Check for positive 32-bit value.
 611   int is_positive_int() const { return _lo &gt;= 0 &amp;&amp; _hi &lt;= (jlong)max_jint; }
 612 
 613   virtual bool        is_finite() const;  // Has a finite value
 614 
 615 
 616   virtual const Type *xmeet( const Type *t ) const;
 617   virtual const Type *xdual() const;    // Compute dual right now.
 618   virtual const Type *widen( const Type *t, const Type* limit_type ) const;
 619   virtual const Type *narrow( const Type *t ) const;
 620   // Convenience common pre-built types.
 621   static const TypeLong *MINUS_1;
 622   static const TypeLong *ZERO;
 623   static const TypeLong *ONE;
 624   static const TypeLong *POS;
 625   static const TypeLong *LONG;
 626   static const TypeLong *INT;    // 32-bit subrange [min_jint..max_jint]
 627   static const TypeLong *UINT;   // 32-bit unsigned [0..max_juint]
 628   static const TypeLong *TYPE_DOMAIN; // alias for TypeLong::LONG
 629 
 630   // static convenience methods.
 631   static const TypeLong *as_self(const Type *t) { return t-&gt;is_long(); }
 632 
 633 #ifndef PRODUCT
 634   virtual void dump2( Dict &amp;d, uint, outputStream *st  ) const;// Specialized per-Type dumping
 635 #endif
 636 };
 637 
 638 //------------------------------TypeTuple--------------------------------------
 639 // Class of Tuple Types, essentially type collections for function signatures
 640 // and class layouts.  It happens to also be a fast cache for the HotSpot
 641 // signature types.
 642 class TypeTuple : public Type {
 643   TypeTuple( uint cnt, const Type **fields ) : Type(Tuple), _cnt(cnt), _fields(fields) { }
 644 
 645   const uint          _cnt;              // Count of fields
 646   const Type ** const _fields;           // Array of field types
 647 
 648 public:
 649   virtual bool eq( const Type *t ) const;
 650   virtual int  hash() const;             // Type specific hashing
 651   virtual bool singleton(void) const;    // TRUE if type is a singleton
 652   virtual bool empty(void) const;        // TRUE if type is vacuous
 653 
 654   // Accessors:
 655   uint cnt() const { return _cnt; }
 656   const Type* field_at(uint i) const {
 657     assert(i &lt; _cnt, &quot;oob&quot;);
 658     return _fields[i];
 659   }
 660   void set_field_at(uint i, const Type* t) {
 661     assert(i &lt; _cnt, &quot;oob&quot;);
 662     _fields[i] = t;
 663   }
 664 
 665   static const TypeTuple *make( uint cnt, const Type **fields );
 666   static const TypeTuple *make_range(ciSignature *sig);
 667   static const TypeTuple *make_domain(ciInstanceKlass* recv, ciSignature *sig);
 668 
 669   // Subroutine call type with space allocated for argument types
 670   // Memory for Control, I_O, Memory, FramePtr, and ReturnAdr is allocated implicitly
 671   static const Type **fields( uint arg_cnt );
 672 
 673   virtual const Type *xmeet( const Type *t ) const;
 674   virtual const Type *xdual() const;    // Compute dual right now.
 675   // Convenience common pre-built types.
 676   static const TypeTuple *IFBOTH;
 677   static const TypeTuple *IFFALSE;
 678   static const TypeTuple *IFTRUE;
 679   static const TypeTuple *IFNEITHER;
 680   static const TypeTuple *LOOPBODY;
 681   static const TypeTuple *MEMBAR;
 682   static const TypeTuple *STORECONDITIONAL;
 683   static const TypeTuple *START_I2C;
 684   static const TypeTuple *INT_PAIR;
 685   static const TypeTuple *LONG_PAIR;
 686   static const TypeTuple *INT_CC_PAIR;
 687   static const TypeTuple *LONG_CC_PAIR;
 688 #ifndef PRODUCT
 689   virtual void dump2( Dict &amp;d, uint, outputStream *st  ) const; // Specialized per-Type dumping
 690 #endif
 691 };
 692 
 693 //------------------------------TypeAry----------------------------------------
 694 // Class of Array Types
 695 class TypeAry : public Type {
 696   TypeAry(const Type* elem, const TypeInt* size, bool stable) : Type(Array),
 697       _elem(elem), _size(size), _stable(stable) {}
 698 public:
 699   virtual bool eq( const Type *t ) const;
 700   virtual int  hash() const;             // Type specific hashing
 701   virtual bool singleton(void) const;    // TRUE if type is a singleton
 702   virtual bool empty(void) const;        // TRUE if type is vacuous
 703 
 704 private:
 705   const Type *_elem;            // Element type of array
 706   const TypeInt *_size;         // Elements in array
 707   const bool _stable;           // Are elements @Stable?
 708   friend class TypeAryPtr;
 709 
 710 public:
 711   static const TypeAry* make(const Type* elem, const TypeInt* size, bool stable = false);
 712 
 713   virtual const Type *xmeet( const Type *t ) const;
 714   virtual const Type *xdual() const;    // Compute dual right now.
 715   bool ary_must_be_exact() const;  // true if arrays of such are never generic
 716   virtual const Type* remove_speculative() const;
 717   virtual const Type* cleanup_speculative() const;
 718 #ifdef ASSERT
 719   // One type is interface, the other is oop
 720   virtual bool interface_vs_oop(const Type *t) const;
 721 #endif
 722 #ifndef PRODUCT
 723   virtual void dump2( Dict &amp;d, uint, outputStream *st  ) const; // Specialized per-Type dumping
 724 #endif
 725 };
 726 
 727 //------------------------------TypeVect---------------------------------------
 728 // Class of Vector Types
 729 class TypeVect : public Type {
 730   const Type*   _elem;  // Vector&#39;s element type
 731   const uint  _length;  // Elements in vector (power of 2)
 732 
 733 protected:
 734   TypeVect(TYPES t, const Type* elem, uint length) : Type(t),
 735     _elem(elem), _length(length) {}
 736 
 737 public:
 738   const Type* element_type() const { return _elem; }
 739   BasicType element_basic_type() const { return _elem-&gt;array_element_basic_type(); }
 740   uint length() const { return _length; }
 741   uint length_in_bytes() const {
 742    return _length * type2aelembytes(element_basic_type());
 743   }
 744 
 745   virtual bool eq(const Type *t) const;
 746   virtual int  hash() const;             // Type specific hashing
 747   virtual bool singleton(void) const;    // TRUE if type is a singleton
 748   virtual bool empty(void) const;        // TRUE if type is vacuous
 749 
 750   static const TypeVect *make(const BasicType elem_bt, uint length) {
 751     // Use bottom primitive type.
 752     return make(get_const_basic_type(elem_bt), length);
 753   }
 754   // Used directly by Replicate nodes to construct singleton vector.
 755   static const TypeVect *make(const Type* elem, uint length);
 756 
 757   virtual const Type *xmeet( const Type *t) const;
 758   virtual const Type *xdual() const;     // Compute dual right now.
 759 
 760   static const TypeVect *VECTS;
 761   static const TypeVect *VECTD;
 762   static const TypeVect *VECTX;
 763   static const TypeVect *VECTY;
 764   static const TypeVect *VECTZ;
 765 
 766 #ifndef PRODUCT
 767   virtual void dump2(Dict &amp;d, uint, outputStream *st) const; // Specialized per-Type dumping
 768 #endif
 769 };
 770 
 771 class TypeVectS : public TypeVect {
 772   friend class TypeVect;
 773   TypeVectS(const Type* elem, uint length) : TypeVect(VectorS, elem, length) {}
 774 };
 775 
 776 class TypeVectD : public TypeVect {
 777   friend class TypeVect;
 778   TypeVectD(const Type* elem, uint length) : TypeVect(VectorD, elem, length) {}
 779 };
 780 
 781 class TypeVectX : public TypeVect {
 782   friend class TypeVect;
 783   TypeVectX(const Type* elem, uint length) : TypeVect(VectorX, elem, length) {}
 784 };
 785 
 786 class TypeVectY : public TypeVect {
 787   friend class TypeVect;
 788   TypeVectY(const Type* elem, uint length) : TypeVect(VectorY, elem, length) {}
 789 };
 790 
 791 class TypeVectZ : public TypeVect {
 792   friend class TypeVect;
 793   TypeVectZ(const Type* elem, uint length) : TypeVect(VectorZ, elem, length) {}
 794 };
 795 
 796 //------------------------------TypePtr----------------------------------------
 797 // Class of machine Pointer Types: raw data, instances or arrays.
 798 // If the _base enum is AnyPtr, then this refers to all of the above.
 799 // Otherwise the _base will indicate which subset of pointers is affected,
 800 // and the class will be inherited from.
 801 class TypePtr : public Type {
 802   friend class TypeNarrowPtr;
 803 public:
 804   enum PTR { TopPTR, AnyNull, Constant, Null, NotNull, BotPTR, lastPTR };
 805 protected:
 806   TypePtr(TYPES t, PTR ptr, int offset,
 807           const TypePtr* speculative = NULL,
 808           int inline_depth = InlineDepthBottom) :
 809     Type(t), _speculative(speculative), _inline_depth(inline_depth), _offset(offset),
 810     _ptr(ptr) {}
 811   static const PTR ptr_meet[lastPTR][lastPTR];
 812   static const PTR ptr_dual[lastPTR];
 813   static const char * const ptr_msg[lastPTR];
 814 
 815   enum {
 816     InlineDepthBottom = INT_MAX,
 817     InlineDepthTop = -InlineDepthBottom
 818   };
 819 
 820   // Extra type information profiling gave us. We propagate it the
 821   // same way the rest of the type info is propagated. If we want to
 822   // use it, then we have to emit a guard: this part of the type is
 823   // not something we know but something we speculate about the type.
 824   const TypePtr*   _speculative;
 825   // For speculative types, we record at what inlining depth the
 826   // profiling point that provided the data is. We want to favor
 827   // profile data coming from outer scopes which are likely better for
 828   // the current compilation.
 829   int _inline_depth;
 830 
 831   // utility methods to work on the speculative part of the type
 832   const TypePtr* dual_speculative() const;
 833   const TypePtr* xmeet_speculative(const TypePtr* other) const;
 834   bool eq_speculative(const TypePtr* other) const;
 835   int hash_speculative() const;
 836   const TypePtr* add_offset_speculative(intptr_t offset) const;
 837 #ifndef PRODUCT
 838   void dump_speculative(outputStream *st) const;
 839 #endif
 840 
 841   // utility methods to work on the inline depth of the type
 842   int dual_inline_depth() const;
 843   int meet_inline_depth(int depth) const;
 844 #ifndef PRODUCT
 845   void dump_inline_depth(outputStream *st) const;
 846 #endif
 847 
 848 public:
 849   const int _offset;            // Offset into oop, with TOP &amp; BOT
 850   const PTR _ptr;               // Pointer equivalence class
 851 
 852   const int offset() const { return _offset; }
 853   const PTR ptr()    const { return _ptr; }
 854 
 855   static const TypePtr *make(TYPES t, PTR ptr, int offset,
 856                              const TypePtr* speculative = NULL,
 857                              int inline_depth = InlineDepthBottom);
 858 
 859   // Return a &#39;ptr&#39; version of this type
 860   virtual const Type *cast_to_ptr_type(PTR ptr) const;
 861 
 862   virtual intptr_t get_con() const;
 863 
 864   int xadd_offset( intptr_t offset ) const;
 865   virtual const TypePtr *add_offset( intptr_t offset ) const;
 866   virtual bool eq(const Type *t) const;
 867   virtual int  hash() const;             // Type specific hashing
 868 
 869   virtual bool singleton(void) const;    // TRUE if type is a singleton
 870   virtual bool empty(void) const;        // TRUE if type is vacuous
 871   virtual const Type *xmeet( const Type *t ) const;
 872   virtual const Type *xmeet_helper( const Type *t ) const;
 873   int meet_offset( int offset ) const;
 874   int dual_offset( ) const;
 875   virtual const Type *xdual() const;    // Compute dual right now.
 876 
 877   // meet, dual and join over pointer equivalence sets
 878   PTR meet_ptr( const PTR in_ptr ) const { return ptr_meet[in_ptr][ptr()]; }
 879   PTR dual_ptr()                   const { return ptr_dual[ptr()];      }
 880 
 881   // This is textually confusing unless one recalls that
 882   // join(t) == dual()-&gt;meet(t-&gt;dual())-&gt;dual().
 883   PTR join_ptr( const PTR in_ptr ) const {
 884     return ptr_dual[ ptr_meet[ ptr_dual[in_ptr] ] [ dual_ptr() ] ];
 885   }
 886 
 887   // Speculative type helper methods.
 888   virtual const TypePtr* speculative() const { return _speculative; }
 889   int inline_depth() const                   { return _inline_depth; }
 890   virtual ciKlass* speculative_type() const;
 891   virtual ciKlass* speculative_type_not_null() const;
 892   virtual bool speculative_maybe_null() const;
 893   virtual bool speculative_always_null() const;
 894   virtual const Type* remove_speculative() const;
 895   virtual const Type* cleanup_speculative() const;
 896   virtual bool would_improve_type(ciKlass* exact_kls, int inline_depth) const;
 897   virtual bool would_improve_ptr(ProfilePtrKind maybe_null) const;
 898   virtual const TypePtr* with_inline_depth(int depth) const;
 899 
 900   virtual bool maybe_null() const { return meet_ptr(Null) == ptr(); }
 901 
 902   // Tests for relation to centerline of type lattice:
 903   static bool above_centerline(PTR ptr) { return (ptr &lt;= AnyNull); }
 904   static bool below_centerline(PTR ptr) { return (ptr &gt;= NotNull); }
 905   // Convenience common pre-built types.
 906   static const TypePtr *NULL_PTR;
 907   static const TypePtr *NOTNULL;
 908   static const TypePtr *BOTTOM;
 909 #ifndef PRODUCT
 910   virtual void dump2( Dict &amp;d, uint depth, outputStream *st  ) const;
 911 #endif
 912 };
 913 
 914 //------------------------------TypeRawPtr-------------------------------------
 915 // Class of raw pointers, pointers to things other than Oops.  Examples
 916 // include the stack pointer, top of heap, card-marking area, handles, etc.
 917 class TypeRawPtr : public TypePtr {
 918 protected:
 919   TypeRawPtr( PTR ptr, address bits ) : TypePtr(RawPtr,ptr,0), _bits(bits){}
 920 public:
 921   virtual bool eq( const Type *t ) const;
 922   virtual int  hash() const;     // Type specific hashing
 923 
 924   const address _bits;          // Constant value, if applicable
 925 
 926   static const TypeRawPtr *make( PTR ptr );
 927   static const TypeRawPtr *make( address bits );
 928 
 929   // Return a &#39;ptr&#39; version of this type
 930   virtual const Type *cast_to_ptr_type(PTR ptr) const;
 931 
 932   virtual intptr_t get_con() const;
 933 
 934   virtual const TypePtr *add_offset( intptr_t offset ) const;
 935 
 936   virtual const Type *xmeet( const Type *t ) const;
 937   virtual const Type *xdual() const;    // Compute dual right now.
 938   // Convenience common pre-built types.
 939   static const TypeRawPtr *BOTTOM;
 940   static const TypeRawPtr *NOTNULL;
 941 #ifndef PRODUCT
 942   virtual void dump2( Dict &amp;d, uint depth, outputStream *st  ) const;
 943 #endif
 944 };
 945 
 946 //------------------------------TypeOopPtr-------------------------------------
 947 // Some kind of oop (Java pointer), either instance or array.
 948 class TypeOopPtr : public TypePtr {
 949 protected:
 950   TypeOopPtr(TYPES t, PTR ptr, ciKlass* k, bool xk, ciObject* o, int offset, int instance_id,
 951              const TypePtr* speculative, int inline_depth);
 952 public:
 953   virtual bool eq( const Type *t ) const;
 954   virtual int  hash() const;             // Type specific hashing
 955   virtual bool singleton(void) const;    // TRUE if type is a singleton
 956   enum {
 957    InstanceTop = -1,   // undefined instance
 958    InstanceBot = 0     // any possible instance
 959   };
 960 protected:
 961 
 962   // Oop is NULL, unless this is a constant oop.
 963   ciObject*     _const_oop;   // Constant oop
 964   // If _klass is NULL, then so is _sig.  This is an unloaded klass.
 965   ciKlass*      _klass;       // Klass object
 966   // Does the type exclude subclasses of the klass?  (Inexact == polymorphic.)
 967   bool          _klass_is_exact;
 968   bool          _is_ptr_to_narrowoop;
 969   bool          _is_ptr_to_narrowklass;
 970   bool          _is_ptr_to_boxed_value;
 971 
 972   // If not InstanceTop or InstanceBot, indicates that this is
 973   // a particular instance of this type which is distinct.
 974   // This is the node index of the allocation node creating this instance.
 975   int           _instance_id;
 976 
 977   static const TypeOopPtr* make_from_klass_common(ciKlass* klass, bool klass_change, bool try_for_exact);
 978 
 979   int dual_instance_id() const;
 980   int meet_instance_id(int uid) const;
 981 
 982   // Do not allow interface-vs.-noninterface joins to collapse to top.
 983   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
 984 
 985 public:
 986   // Creates a type given a klass. Correctly handles multi-dimensional arrays
 987   // Respects UseUniqueSubclasses.
 988   // If the klass is final, the resulting type will be exact.
 989   static const TypeOopPtr* make_from_klass(ciKlass* klass) {
 990     return make_from_klass_common(klass, true, false);
 991   }
 992   // Same as before, but will produce an exact type, even if
 993   // the klass is not final, as long as it has exactly one implementation.
 994   static const TypeOopPtr* make_from_klass_unique(ciKlass* klass) {
 995     return make_from_klass_common(klass, true, true);
 996   }
 997   // Same as before, but does not respects UseUniqueSubclasses.
 998   // Use this only for creating array element types.
 999   static const TypeOopPtr* make_from_klass_raw(ciKlass* klass) {
1000     return make_from_klass_common(klass, false, false);
1001   }
1002   // Creates a singleton type given an object.
1003   // If the object cannot be rendered as a constant,
1004   // may return a non-singleton type.
1005   // If require_constant, produce a NULL if a singleton is not possible.
1006   static const TypeOopPtr* make_from_constant(ciObject* o,
1007                                               bool require_constant = false);
1008 
1009   // Make a generic (unclassed) pointer to an oop.
1010   static const TypeOopPtr* make(PTR ptr, int offset, int instance_id,
1011                                 const TypePtr* speculative = NULL,
1012                                 int inline_depth = InlineDepthBottom);
1013 
1014   ciObject* const_oop()    const { return _const_oop; }
1015   virtual ciKlass* klass() const { return _klass;     }
1016   bool klass_is_exact()    const { return _klass_is_exact; }
1017 
1018   // Returns true if this pointer points at memory which contains a
1019   // compressed oop references.
1020   bool is_ptr_to_narrowoop_nv() const { return _is_ptr_to_narrowoop; }
1021   bool is_ptr_to_narrowklass_nv() const { return _is_ptr_to_narrowklass; }
1022   bool is_ptr_to_boxed_value()   const { return _is_ptr_to_boxed_value; }
1023   bool is_known_instance()       const { return _instance_id &gt; 0; }
1024   int  instance_id()             const { return _instance_id; }
1025   bool is_known_instance_field() const { return is_known_instance() &amp;&amp; _offset &gt;= 0; }
1026 
1027   virtual intptr_t get_con() const;
1028 
1029   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1030 
1031   virtual const Type *cast_to_exactness(bool klass_is_exact) const;
1032 
1033   virtual const TypeOopPtr *cast_to_instance_id(int instance_id) const;
1034 
1035   // corresponding pointer to klass, for a given instance
1036   const TypeKlassPtr* as_klass_type() const;
1037 
1038   virtual const TypePtr *add_offset( intptr_t offset ) const;
1039 
1040   // Speculative type helper methods.
1041   virtual const Type* remove_speculative() const;
1042   virtual const Type* cleanup_speculative() const;
1043   virtual bool would_improve_type(ciKlass* exact_kls, int inline_depth) const;
1044   virtual const TypePtr* with_inline_depth(int depth) const;
1045 
1046   virtual const TypePtr* with_instance_id(int instance_id) const;
1047 
1048   virtual const Type *xdual() const;    // Compute dual right now.
1049   // the core of the computation of the meet for TypeOopPtr and for its subclasses
1050   virtual const Type *xmeet_helper(const Type *t) const;
1051 
1052   // Convenience common pre-built type.
1053   static const TypeOopPtr *BOTTOM;
1054 #ifndef PRODUCT
1055   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
1056 #endif
1057 };
1058 
1059 //------------------------------TypeInstPtr------------------------------------
1060 // Class of Java object pointers, pointing either to non-array Java instances
1061 // or to a Klass* (including array klasses).
1062 class TypeInstPtr : public TypeOopPtr {
1063   TypeInstPtr(PTR ptr, ciKlass* k, bool xk, ciObject* o, int offset, int instance_id,
1064               const TypePtr* speculative, int inline_depth);
1065   virtual bool eq( const Type *t ) const;
1066   virtual int  hash() const;             // Type specific hashing
1067 
1068   ciSymbol*  _name;        // class name
1069 
1070  public:
1071   ciSymbol* name()         const { return _name; }
1072 
1073   bool  is_loaded() const { return _klass-&gt;is_loaded(); }
1074 
1075   // Make a pointer to a constant oop.
1076   static const TypeInstPtr *make(ciObject* o) {
1077     return make(TypePtr::Constant, o-&gt;klass(), true, o, 0, InstanceBot);
1078   }
1079   // Make a pointer to a constant oop with offset.
1080   static const TypeInstPtr *make(ciObject* o, int offset) {
1081     return make(TypePtr::Constant, o-&gt;klass(), true, o, offset, InstanceBot);
1082   }
1083 
1084   // Make a pointer to some value of type klass.
1085   static const TypeInstPtr *make(PTR ptr, ciKlass* klass) {
1086     return make(ptr, klass, false, NULL, 0, InstanceBot);
1087   }
1088 
1089   // Make a pointer to some non-polymorphic value of exactly type klass.
1090   static const TypeInstPtr *make_exact(PTR ptr, ciKlass* klass) {
1091     return make(ptr, klass, true, NULL, 0, InstanceBot);
1092   }
1093 
1094   // Make a pointer to some value of type klass with offset.
1095   static const TypeInstPtr *make(PTR ptr, ciKlass* klass, int offset) {
1096     return make(ptr, klass, false, NULL, offset, InstanceBot);
1097   }
1098 
1099   // Make a pointer to an oop.
1100   static const TypeInstPtr *make(PTR ptr, ciKlass* k, bool xk, ciObject* o, int offset,
1101                                  int instance_id = InstanceBot,
1102                                  const TypePtr* speculative = NULL,
1103                                  int inline_depth = InlineDepthBottom);
1104 
1105   /** Create constant type for a constant boxed value */
1106   const Type* get_const_boxed_value() const;
1107 
1108   // If this is a java.lang.Class constant, return the type for it or NULL.
1109   // Pass to Type::get_const_type to turn it to a type, which will usually
1110   // be a TypeInstPtr, but may also be a TypeInt::INT for int.class, etc.
1111   ciType* java_mirror_type() const;
1112 
1113   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1114 
1115   virtual const Type *cast_to_exactness(bool klass_is_exact) const;
1116 
1117   virtual const TypeOopPtr *cast_to_instance_id(int instance_id) const;
1118 
1119   virtual const TypePtr *add_offset( intptr_t offset ) const;
1120 
1121   // Speculative type helper methods.
1122   virtual const Type* remove_speculative() const;
1123   virtual const TypePtr* with_inline_depth(int depth) const;
1124   virtual const TypePtr* with_instance_id(int instance_id) const;
1125 
1126   // the core of the computation of the meet of 2 types
1127   virtual const Type *xmeet_helper(const Type *t) const;
1128   virtual const TypeInstPtr *xmeet_unloaded( const TypeInstPtr *t ) const;
1129   virtual const Type *xdual() const;    // Compute dual right now.
1130 
1131   // Convenience common pre-built types.
1132   static const TypeInstPtr *NOTNULL;
1133   static const TypeInstPtr *BOTTOM;
1134   static const TypeInstPtr *MIRROR;
1135   static const TypeInstPtr *MARK;
1136   static const TypeInstPtr *KLASS;
1137 #ifndef PRODUCT
1138   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const; // Specialized per-Type dumping
1139 #endif
1140 };
1141 
1142 //------------------------------TypeAryPtr-------------------------------------
1143 // Class of Java array pointers
1144 class TypeAryPtr : public TypeOopPtr {
1145   TypeAryPtr( PTR ptr, ciObject* o, const TypeAry *ary, ciKlass* k, bool xk,
1146               int offset, int instance_id, bool is_autobox_cache,
1147               const TypePtr* speculative, int inline_depth)
1148     : TypeOopPtr(AryPtr,ptr,k,xk,o,offset, instance_id, speculative, inline_depth),
1149     _ary(ary),
1150     _is_autobox_cache(is_autobox_cache)
1151  {
1152 #ifdef ASSERT
1153     if (k != NULL) {
1154       // Verify that specified klass and TypeAryPtr::klass() follow the same rules.
1155       ciKlass* ck = compute_klass(true);
1156       if (k != ck) {
1157         this-&gt;dump(); tty-&gt;cr();
1158         tty-&gt;print(&quot; k: &quot;);
1159         k-&gt;print(); tty-&gt;cr();
1160         tty-&gt;print(&quot;ck: &quot;);
1161         if (ck != NULL) ck-&gt;print();
1162         else tty-&gt;print(&quot;&lt;NULL&gt;&quot;);
1163         tty-&gt;cr();
1164         assert(false, &quot;unexpected TypeAryPtr::_klass&quot;);
1165       }
1166     }
1167 #endif
1168   }
1169   virtual bool eq( const Type *t ) const;
1170   virtual int hash() const;     // Type specific hashing
1171   const TypeAry *_ary;          // Array we point into
1172   const bool     _is_autobox_cache;
1173 
1174   ciKlass* compute_klass(DEBUG_ONLY(bool verify = false)) const;
1175 
1176 public:
1177   // Accessors
1178   ciKlass* klass() const;
1179   const TypeAry* ary() const  { return _ary; }
1180   const Type*    elem() const { return _ary-&gt;_elem; }
1181   const TypeInt* size() const { return _ary-&gt;_size; }
1182   bool      is_stable() const { return _ary-&gt;_stable; }
1183 
1184   bool is_autobox_cache() const { return _is_autobox_cache; }
1185 
1186   static const TypeAryPtr *make(PTR ptr, const TypeAry *ary, ciKlass* k, bool xk, int offset,
1187                                 int instance_id = InstanceBot,
1188                                 const TypePtr* speculative = NULL,
1189                                 int inline_depth = InlineDepthBottom);
1190   // Constant pointer to array
1191   static const TypeAryPtr *make(PTR ptr, ciObject* o, const TypeAry *ary, ciKlass* k, bool xk, int offset,
1192                                 int instance_id = InstanceBot,
1193                                 const TypePtr* speculative = NULL,
1194                                 int inline_depth = InlineDepthBottom, bool is_autobox_cache = false);
1195 
1196   // Return a &#39;ptr&#39; version of this type
1197   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1198 
1199   virtual const Type *cast_to_exactness(bool klass_is_exact) const;
1200 
1201   virtual const TypeOopPtr *cast_to_instance_id(int instance_id) const;
1202 
1203   virtual const TypeAryPtr* cast_to_size(const TypeInt* size) const;
1204   virtual const TypeInt* narrow_size_type(const TypeInt* size) const;
1205 
1206   virtual bool empty(void) const;        // TRUE if type is vacuous
1207   virtual const TypePtr *add_offset( intptr_t offset ) const;
1208 
1209   // Speculative type helper methods.
1210   virtual const Type* remove_speculative() const;
1211   virtual const TypePtr* with_inline_depth(int depth) const;
1212   virtual const TypePtr* with_instance_id(int instance_id) const;
1213 
1214   // the core of the computation of the meet of 2 types
1215   virtual const Type *xmeet_helper(const Type *t) const;
1216   virtual const Type *xdual() const;    // Compute dual right now.
1217 
1218   const TypeAryPtr* cast_to_stable(bool stable, int stable_dimension = 1) const;
1219   int stable_dimension() const;
1220 
1221   const TypeAryPtr* cast_to_autobox_cache(bool cache) const;
1222 
1223   static jint max_array_length(BasicType etype) ;
1224 
1225   // Convenience common pre-built types.
1226   static const TypeAryPtr *RANGE;
1227   static const TypeAryPtr *OOPS;
1228   static const TypeAryPtr *NARROWOOPS;
1229   static const TypeAryPtr *BYTES;
1230   static const TypeAryPtr *SHORTS;
1231   static const TypeAryPtr *CHARS;
1232   static const TypeAryPtr *INTS;
1233   static const TypeAryPtr *LONGS;
1234   static const TypeAryPtr *FLOATS;
1235   static const TypeAryPtr *DOUBLES;
1236   // selects one of the above:
1237   static const TypeAryPtr *get_array_body_type(BasicType elem) {
1238     assert((uint)elem &lt;= T_CONFLICT &amp;&amp; _array_body_type[elem] != NULL, &quot;bad elem type&quot;);
1239     return _array_body_type[elem];
1240   }
1241   static const TypeAryPtr *_array_body_type[T_CONFLICT+1];
1242   // sharpen the type of an int which is used as an array size
1243 #ifdef ASSERT
1244   // One type is interface, the other is oop
1245   virtual bool interface_vs_oop(const Type *t) const;
1246 #endif
1247 #ifndef PRODUCT
1248   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const; // Specialized per-Type dumping
1249 #endif
1250 };
1251 
1252 //------------------------------TypeMetadataPtr-------------------------------------
1253 // Some kind of metadata, either Method*, MethodData* or CPCacheOop
1254 class TypeMetadataPtr : public TypePtr {
1255 protected:
1256   TypeMetadataPtr(PTR ptr, ciMetadata* metadata, int offset);
1257   // Do not allow interface-vs.-noninterface joins to collapse to top.
1258   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
1259 public:
1260   virtual bool eq( const Type *t ) const;
1261   virtual int  hash() const;             // Type specific hashing
1262   virtual bool singleton(void) const;    // TRUE if type is a singleton
1263 
1264 private:
1265   ciMetadata*   _metadata;
1266 
1267 public:
1268   static const TypeMetadataPtr* make(PTR ptr, ciMetadata* m, int offset);
1269 
1270   static const TypeMetadataPtr* make(ciMethod* m);
1271   static const TypeMetadataPtr* make(ciMethodData* m);
1272 
1273   ciMetadata* metadata() const { return _metadata; }
1274 
1275   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1276 
1277   virtual const TypePtr *add_offset( intptr_t offset ) const;
1278 
1279   virtual const Type *xmeet( const Type *t ) const;
1280   virtual const Type *xdual() const;    // Compute dual right now.
1281 
1282   virtual intptr_t get_con() const;
1283 
1284   // Convenience common pre-built types.
1285   static const TypeMetadataPtr *BOTTOM;
1286 
1287 #ifndef PRODUCT
1288   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
1289 #endif
1290 };
1291 
1292 //------------------------------TypeKlassPtr-----------------------------------
1293 // Class of Java Klass pointers
1294 class TypeKlassPtr : public TypePtr {
1295   TypeKlassPtr( PTR ptr, ciKlass* klass, int offset );
1296 
1297 protected:
1298   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
1299  public:
1300   virtual bool eq( const Type *t ) const;
1301   virtual int hash() const;             // Type specific hashing
1302   virtual bool singleton(void) const;    // TRUE if type is a singleton
1303  private:
1304 
1305   static const TypeKlassPtr* make_from_klass_common(ciKlass* klass, bool klass_change, bool try_for_exact);
1306 
1307   ciKlass* _klass;
1308 
1309   // Does the type exclude subclasses of the klass?  (Inexact == polymorphic.)
1310   bool          _klass_is_exact;
1311 
1312 public:
1313   ciSymbol* name()  const { return klass()-&gt;name(); }
1314 
1315   ciKlass* klass() const { return  _klass; }
1316   bool klass_is_exact()    const { return _klass_is_exact; }
1317 
1318   bool  is_loaded() const { return klass()-&gt;is_loaded(); }
1319 
1320   // Creates a type given a klass. Correctly handles multi-dimensional arrays
1321   // Respects UseUniqueSubclasses.
1322   // If the klass is final, the resulting type will be exact.
1323   static const TypeKlassPtr* make_from_klass(ciKlass* klass) {
1324     return make_from_klass_common(klass, true, false);
1325   }
1326   // Same as before, but will produce an exact type, even if
1327   // the klass is not final, as long as it has exactly one implementation.
1328   static const TypeKlassPtr* make_from_klass_unique(ciKlass* klass) {
1329     return make_from_klass_common(klass, true, true);
1330   }
1331   // Same as before, but does not respects UseUniqueSubclasses.
1332   // Use this only for creating array element types.
1333   static const TypeKlassPtr* make_from_klass_raw(ciKlass* klass) {
1334     return make_from_klass_common(klass, false, false);
1335   }
1336 
1337   // Make a generic (unclassed) pointer to metadata.
1338   static const TypeKlassPtr* make(PTR ptr, int offset);
1339 
1340   // ptr to klass &#39;k&#39;
1341   static const TypeKlassPtr *make( ciKlass* k ) { return make( TypePtr::Constant, k, 0); }
1342   // ptr to klass &#39;k&#39; with offset
1343   static const TypeKlassPtr *make( ciKlass* k, int offset ) { return make( TypePtr::Constant, k, offset); }
1344   // ptr to klass &#39;k&#39; or sub-klass
1345   static const TypeKlassPtr *make( PTR ptr, ciKlass* k, int offset);
1346 
1347   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1348 
1349   virtual const Type *cast_to_exactness(bool klass_is_exact) const;
1350 
1351   // corresponding pointer to instance, for a given class
1352   const TypeOopPtr* as_instance_type() const;
1353 
1354   virtual const TypePtr *add_offset( intptr_t offset ) const;
1355   virtual const Type    *xmeet( const Type *t ) const;
1356   virtual const Type    *xdual() const;      // Compute dual right now.
1357 
1358   virtual intptr_t get_con() const;
1359 
1360   // Convenience common pre-built types.
1361   static const TypeKlassPtr* OBJECT; // Not-null object klass or below
1362   static const TypeKlassPtr* OBJECT_OR_NULL; // Maybe-null version of same
1363 #ifndef PRODUCT
1364   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const; // Specialized per-Type dumping
1365 #endif
1366 };
1367 
1368 class TypeNarrowPtr : public Type {
1369 protected:
1370   const TypePtr* _ptrtype; // Could be TypePtr::NULL_PTR
1371 
1372   TypeNarrowPtr(TYPES t, const TypePtr* ptrtype): Type(t),
1373                                                   _ptrtype(ptrtype) {
1374     assert(ptrtype-&gt;offset() == 0 ||
1375            ptrtype-&gt;offset() == OffsetBot ||
1376            ptrtype-&gt;offset() == OffsetTop, &quot;no real offsets&quot;);
1377   }
1378 
1379   virtual const TypeNarrowPtr *isa_same_narrowptr(const Type *t) const = 0;
1380   virtual const TypeNarrowPtr *is_same_narrowptr(const Type *t) const = 0;
1381   virtual const TypeNarrowPtr *make_same_narrowptr(const TypePtr *t) const = 0;
1382   virtual const TypeNarrowPtr *make_hash_same_narrowptr(const TypePtr *t) const = 0;
1383   // Do not allow interface-vs.-noninterface joins to collapse to top.
1384   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
1385 public:
1386   virtual bool eq( const Type *t ) const;
1387   virtual int  hash() const;             // Type specific hashing
1388   virtual bool singleton(void) const;    // TRUE if type is a singleton
1389 
1390   virtual const Type *xmeet( const Type *t ) const;
1391   virtual const Type *xdual() const;    // Compute dual right now.
1392 
1393   virtual intptr_t get_con() const;
1394 
1395   virtual bool empty(void) const;        // TRUE if type is vacuous
1396 
1397   // returns the equivalent ptr type for this compressed pointer
1398   const TypePtr *get_ptrtype() const {
1399     return _ptrtype;
1400   }
1401 
1402   bool is_known_instance() const {
1403     return _ptrtype-&gt;is_known_instance();
1404   }
1405 
1406 #ifndef PRODUCT
1407   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
1408 #endif
1409 };
1410 
1411 //------------------------------TypeNarrowOop----------------------------------
1412 // A compressed reference to some kind of Oop.  This type wraps around
1413 // a preexisting TypeOopPtr and forwards most of it&#39;s operations to
1414 // the underlying type.  It&#39;s only real purpose is to track the
1415 // oopness of the compressed oop value when we expose the conversion
1416 // between the normal and the compressed form.
1417 class TypeNarrowOop : public TypeNarrowPtr {
1418 protected:
1419   TypeNarrowOop( const TypePtr* ptrtype): TypeNarrowPtr(NarrowOop, ptrtype) {
1420   }
1421 
1422   virtual const TypeNarrowPtr *isa_same_narrowptr(const Type *t) const {
1423     return t-&gt;isa_narrowoop();
1424   }
1425 
1426   virtual const TypeNarrowPtr *is_same_narrowptr(const Type *t) const {
1427     return t-&gt;is_narrowoop();
1428   }
1429 
1430   virtual const TypeNarrowPtr *make_same_narrowptr(const TypePtr *t) const {
1431     return new TypeNarrowOop(t);
1432   }
1433 
1434   virtual const TypeNarrowPtr *make_hash_same_narrowptr(const TypePtr *t) const {
1435     return (const TypeNarrowPtr*)((new TypeNarrowOop(t))-&gt;hashcons());
1436   }
1437 
1438 public:
1439 
1440   static const TypeNarrowOop *make( const TypePtr* type);
1441 
1442   static const TypeNarrowOop* make_from_constant(ciObject* con, bool require_constant = false) {
1443     return make(TypeOopPtr::make_from_constant(con, require_constant));
1444   }
1445 
1446   static const TypeNarrowOop *BOTTOM;
1447   static const TypeNarrowOop *NULL_PTR;
1448 
1449   virtual const Type* remove_speculative() const;
1450   virtual const Type* cleanup_speculative() const;
1451 
1452 #ifndef PRODUCT
1453   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
1454 #endif
1455 };
1456 
1457 //------------------------------TypeNarrowKlass----------------------------------
1458 // A compressed reference to klass pointer.  This type wraps around a
1459 // preexisting TypeKlassPtr and forwards most of it&#39;s operations to
1460 // the underlying type.
1461 class TypeNarrowKlass : public TypeNarrowPtr {
1462 protected:
1463   TypeNarrowKlass( const TypePtr* ptrtype): TypeNarrowPtr(NarrowKlass, ptrtype) {
1464   }
1465 
1466   virtual const TypeNarrowPtr *isa_same_narrowptr(const Type *t) const {
1467     return t-&gt;isa_narrowklass();
1468   }
1469 
1470   virtual const TypeNarrowPtr *is_same_narrowptr(const Type *t) const {
1471     return t-&gt;is_narrowklass();
1472   }
1473 
1474   virtual const TypeNarrowPtr *make_same_narrowptr(const TypePtr *t) const {
1475     return new TypeNarrowKlass(t);
1476   }
1477 
1478   virtual const TypeNarrowPtr *make_hash_same_narrowptr(const TypePtr *t) const {
1479     return (const TypeNarrowPtr*)((new TypeNarrowKlass(t))-&gt;hashcons());
1480   }
1481 
1482 public:
1483   static const TypeNarrowKlass *make( const TypePtr* type);
1484 
1485   // static const TypeNarrowKlass *BOTTOM;
1486   static const TypeNarrowKlass *NULL_PTR;
1487 
1488 #ifndef PRODUCT
1489   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
1490 #endif
1491 };
1492 
1493 //------------------------------TypeFunc---------------------------------------
1494 // Class of Array Types
1495 class TypeFunc : public Type {
1496   TypeFunc( const TypeTuple *domain, const TypeTuple *range ) : Type(Function),  _domain(domain), _range(range) {}
1497   virtual bool eq( const Type *t ) const;
1498   virtual int  hash() const;             // Type specific hashing
1499   virtual bool singleton(void) const;    // TRUE if type is a singleton
1500   virtual bool empty(void) const;        // TRUE if type is vacuous
1501 
1502   const TypeTuple* const _domain;     // Domain of inputs
1503   const TypeTuple* const _range;      // Range of results
1504 
1505 public:
1506   // Constants are shared among ADLC and VM
1507   enum { Control    = AdlcVMDeps::Control,
1508          I_O        = AdlcVMDeps::I_O,
1509          Memory     = AdlcVMDeps::Memory,
1510          FramePtr   = AdlcVMDeps::FramePtr,
1511          ReturnAdr  = AdlcVMDeps::ReturnAdr,
1512          Parms      = AdlcVMDeps::Parms
1513   };
1514 
1515 
1516   // Accessors:
1517   const TypeTuple* domain() const { return _domain; }
1518   const TypeTuple* range()  const { return _range; }
1519 
1520   static const TypeFunc *make(ciMethod* method);
1521   static const TypeFunc *make(ciSignature signature, const Type* extra);
1522   static const TypeFunc *make(const TypeTuple* domain, const TypeTuple* range);
1523 
1524   virtual const Type *xmeet( const Type *t ) const;
1525   virtual const Type *xdual() const;    // Compute dual right now.
1526 
1527   BasicType return_type() const;
1528 
1529 #ifndef PRODUCT
1530   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const; // Specialized per-Type dumping
1531 #endif
1532   // Convenience common pre-built types.
1533 };
1534 
1535 //------------------------------accessors--------------------------------------
1536 inline bool Type::is_ptr_to_narrowoop() const {
1537 #ifdef _LP64
1538   return (isa_oopptr() != NULL &amp;&amp; is_oopptr()-&gt;is_ptr_to_narrowoop_nv());
1539 #else
1540   return false;
1541 #endif
1542 }
1543 
1544 inline bool Type::is_ptr_to_narrowklass() const {
1545 #ifdef _LP64
1546   return (isa_oopptr() != NULL &amp;&amp; is_oopptr()-&gt;is_ptr_to_narrowklass_nv());
1547 #else
1548   return false;
1549 #endif
1550 }
1551 
1552 inline float Type::getf() const {
1553   assert( _base == FloatCon, &quot;Not a FloatCon&quot; );
1554   return ((TypeF*)this)-&gt;_f;
1555 }
1556 
1557 inline double Type::getd() const {
1558   assert( _base == DoubleCon, &quot;Not a DoubleCon&quot; );
1559   return ((TypeD*)this)-&gt;_d;
1560 }
1561 
1562 inline const TypeInt *Type::is_int() const {
1563   assert( _base == Int, &quot;Not an Int&quot; );
1564   return (TypeInt*)this;
1565 }
1566 
1567 inline const TypeInt *Type::isa_int() const {
1568   return ( _base == Int ? (TypeInt*)this : NULL);
1569 }
1570 
1571 inline const TypeLong *Type::is_long() const {
1572   assert( _base == Long, &quot;Not a Long&quot; );
1573   return (TypeLong*)this;
1574 }
1575 
1576 inline const TypeLong *Type::isa_long() const {
1577   return ( _base == Long ? (TypeLong*)this : NULL);
1578 }
1579 
1580 inline const TypeF *Type::isa_float() const {
1581   return ((_base == FloatTop ||
1582            _base == FloatCon ||
1583            _base == FloatBot) ? (TypeF*)this : NULL);
1584 }
1585 
1586 inline const TypeF *Type::is_float_constant() const {
1587   assert( _base == FloatCon, &quot;Not a Float&quot; );
1588   return (TypeF*)this;
1589 }
1590 
1591 inline const TypeF *Type::isa_float_constant() const {
1592   return ( _base == FloatCon ? (TypeF*)this : NULL);
1593 }
1594 
1595 inline const TypeD *Type::isa_double() const {
1596   return ((_base == DoubleTop ||
1597            _base == DoubleCon ||
1598            _base == DoubleBot) ? (TypeD*)this : NULL);
1599 }
1600 
1601 inline const TypeD *Type::is_double_constant() const {
1602   assert( _base == DoubleCon, &quot;Not a Double&quot; );
1603   return (TypeD*)this;
1604 }
1605 
1606 inline const TypeD *Type::isa_double_constant() const {
1607   return ( _base == DoubleCon ? (TypeD*)this : NULL);
1608 }
1609 
1610 inline const TypeTuple *Type::is_tuple() const {
1611   assert( _base == Tuple, &quot;Not a Tuple&quot; );
1612   return (TypeTuple*)this;
1613 }
1614 
1615 inline const TypeAry *Type::is_ary() const {
1616   assert( _base == Array , &quot;Not an Array&quot; );
1617   return (TypeAry*)this;
1618 }
1619 
1620 inline const TypeAry *Type::isa_ary() const {
1621   return ((_base == Array) ? (TypeAry*)this : NULL);
1622 }
1623 
1624 inline const TypeVect *Type::is_vect() const {
1625   assert( _base &gt;= VectorS &amp;&amp; _base &lt;= VectorZ, &quot;Not a Vector&quot; );
1626   return (TypeVect*)this;
1627 }
1628 
1629 inline const TypeVect *Type::isa_vect() const {
1630   return (_base &gt;= VectorS &amp;&amp; _base &lt;= VectorZ) ? (TypeVect*)this : NULL;
1631 }
1632 
1633 inline const TypePtr *Type::is_ptr() const {
1634   // AnyPtr is the first Ptr and KlassPtr the last, with no non-ptrs between.
1635   assert(_base &gt;= AnyPtr &amp;&amp; _base &lt;= KlassPtr, &quot;Not a pointer&quot;);
1636   return (TypePtr*)this;
1637 }
1638 
1639 inline const TypePtr *Type::isa_ptr() const {
1640   // AnyPtr is the first Ptr and KlassPtr the last, with no non-ptrs between.
1641   return (_base &gt;= AnyPtr &amp;&amp; _base &lt;= KlassPtr) ? (TypePtr*)this : NULL;
1642 }
1643 
1644 inline const TypeOopPtr *Type::is_oopptr() const {
1645   // OopPtr is the first and KlassPtr the last, with no non-oops between.
1646   assert(_base &gt;= OopPtr &amp;&amp; _base &lt;= AryPtr, &quot;Not a Java pointer&quot; ) ;
1647   return (TypeOopPtr*)this;
1648 }
1649 
1650 inline const TypeOopPtr *Type::isa_oopptr() const {
1651   // OopPtr is the first and KlassPtr the last, with no non-oops between.
1652   return (_base &gt;= OopPtr &amp;&amp; _base &lt;= AryPtr) ? (TypeOopPtr*)this : NULL;
1653 }
1654 
1655 inline const TypeRawPtr *Type::isa_rawptr() const {
1656   return (_base == RawPtr) ? (TypeRawPtr*)this : NULL;
1657 }
1658 
1659 inline const TypeRawPtr *Type::is_rawptr() const {
1660   assert( _base == RawPtr, &quot;Not a raw pointer&quot; );
1661   return (TypeRawPtr*)this;
1662 }
1663 
1664 inline const TypeInstPtr *Type::isa_instptr() const {
1665   return (_base == InstPtr) ? (TypeInstPtr*)this : NULL;
1666 }
1667 
1668 inline const TypeInstPtr *Type::is_instptr() const {
1669   assert( _base == InstPtr, &quot;Not an object pointer&quot; );
1670   return (TypeInstPtr*)this;
1671 }
1672 
1673 inline const TypeAryPtr *Type::isa_aryptr() const {
1674   return (_base == AryPtr) ? (TypeAryPtr*)this : NULL;
1675 }
1676 
1677 inline const TypeAryPtr *Type::is_aryptr() const {
1678   assert( _base == AryPtr, &quot;Not an array pointer&quot; );
1679   return (TypeAryPtr*)this;
1680 }
1681 
1682 inline const TypeNarrowOop *Type::is_narrowoop() const {
1683   // OopPtr is the first and KlassPtr the last, with no non-oops between.
1684   assert(_base == NarrowOop, &quot;Not a narrow oop&quot; ) ;
1685   return (TypeNarrowOop*)this;
1686 }
1687 
1688 inline const TypeNarrowOop *Type::isa_narrowoop() const {
1689   // OopPtr is the first and KlassPtr the last, with no non-oops between.
1690   return (_base == NarrowOop) ? (TypeNarrowOop*)this : NULL;
1691 }
1692 
1693 inline const TypeNarrowKlass *Type::is_narrowklass() const {
1694   assert(_base == NarrowKlass, &quot;Not a narrow oop&quot; ) ;
1695   return (TypeNarrowKlass*)this;
1696 }
1697 
1698 inline const TypeNarrowKlass *Type::isa_narrowklass() const {
1699   return (_base == NarrowKlass) ? (TypeNarrowKlass*)this : NULL;
1700 }
1701 
1702 inline const TypeMetadataPtr *Type::is_metadataptr() const {
1703   // MetadataPtr is the first and CPCachePtr the last
1704   assert(_base == MetadataPtr, &quot;Not a metadata pointer&quot; ) ;
1705   return (TypeMetadataPtr*)this;
1706 }
1707 
1708 inline const TypeMetadataPtr *Type::isa_metadataptr() const {
1709   return (_base == MetadataPtr) ? (TypeMetadataPtr*)this : NULL;
1710 }
1711 
1712 inline const TypeKlassPtr *Type::isa_klassptr() const {
1713   return (_base == KlassPtr) ? (TypeKlassPtr*)this : NULL;
1714 }
1715 
1716 inline const TypeKlassPtr *Type::is_klassptr() const {
1717   assert( _base == KlassPtr, &quot;Not a klass pointer&quot; );
1718   return (TypeKlassPtr*)this;
1719 }
1720 
1721 inline const TypePtr* Type::make_ptr() const {
1722   return (_base == NarrowOop) ? is_narrowoop()-&gt;get_ptrtype() :
1723                               ((_base == NarrowKlass) ? is_narrowklass()-&gt;get_ptrtype() :
1724                                                        isa_ptr());
1725 }
1726 
1727 inline const TypeOopPtr* Type::make_oopptr() const {
1728   return (_base == NarrowOop) ? is_narrowoop()-&gt;get_ptrtype()-&gt;isa_oopptr() : isa_oopptr();
1729 }
1730 
1731 inline const TypeNarrowOop* Type::make_narrowoop() const {
1732   return (_base == NarrowOop) ? is_narrowoop() :
1733                                 (isa_ptr() ? TypeNarrowOop::make(is_ptr()) : NULL);
1734 }
1735 
1736 inline const TypeNarrowKlass* Type::make_narrowklass() const {
1737   return (_base == NarrowKlass) ? is_narrowklass() :
1738                                   (isa_ptr() ? TypeNarrowKlass::make(is_ptr()) : NULL);
1739 }
1740 
1741 inline bool Type::is_floatingpoint() const {
1742   if( (_base == FloatCon)  || (_base == FloatBot) ||
1743       (_base == DoubleCon) || (_base == DoubleBot) )
1744     return true;
1745   return false;
1746 }
1747 
1748 inline bool Type::is_ptr_to_boxing_obj() const {
1749   const TypeInstPtr* tp = isa_instptr();
1750   return (tp != NULL) &amp;&amp; (tp-&gt;offset() == 0) &amp;&amp;
1751          tp-&gt;klass()-&gt;is_instance_klass()  &amp;&amp;
1752          tp-&gt;klass()-&gt;as_instance_klass()-&gt;is_box_klass();
1753 }
1754 
1755 
1756 // ===============================================================
1757 // Things that need to be 64-bits in the 64-bit build but
1758 // 32-bits in the 32-bit build.  Done this way to get full
1759 // optimization AND strong typing.
1760 #ifdef _LP64
1761 
1762 // For type queries and asserts
1763 #define is_intptr_t  is_long
1764 #define isa_intptr_t isa_long
1765 #define find_intptr_t_type find_long_type
1766 #define find_intptr_t_con  find_long_con
1767 #define TypeX        TypeLong
1768 #define Type_X       Type::Long
1769 #define TypeX_X      TypeLong::LONG
1770 #define TypeX_ZERO   TypeLong::ZERO
1771 // For &#39;ideal_reg&#39; machine registers
1772 #define Op_RegX      Op_RegL
1773 // For phase-&gt;intcon variants
1774 #define MakeConX     longcon
1775 #define ConXNode     ConLNode
1776 // For array index arithmetic
1777 #define MulXNode     MulLNode
1778 #define AndXNode     AndLNode
1779 #define OrXNode      OrLNode
1780 #define CmpXNode     CmpLNode
1781 #define SubXNode     SubLNode
1782 #define LShiftXNode  LShiftLNode
1783 // For object size computation:
1784 #define AddXNode     AddLNode
1785 #define RShiftXNode  RShiftLNode
1786 // For card marks and hashcodes
1787 #define URShiftXNode URShiftLNode
1788 // UseOptoBiasInlining
1789 #define XorXNode     XorLNode
1790 #define StoreXConditionalNode StoreLConditionalNode
1791 #define LoadXNode    LoadLNode
1792 #define StoreXNode   StoreLNode
1793 // Opcodes
1794 #define Op_LShiftX   Op_LShiftL
1795 #define Op_AndX      Op_AndL
1796 #define Op_AddX      Op_AddL
1797 #define Op_SubX      Op_SubL
1798 #define Op_XorX      Op_XorL
1799 #define Op_URShiftX  Op_URShiftL
1800 #define Op_LoadX     Op_LoadL
1801 // conversions
1802 #define ConvI2X(x)   ConvI2L(x)
1803 #define ConvL2X(x)   (x)
1804 #define ConvX2I(x)   ConvL2I(x)
1805 #define ConvX2L(x)   (x)
1806 #define ConvX2UL(x)  (x)
1807 
1808 #else
1809 
1810 // For type queries and asserts
1811 #define is_intptr_t  is_int
1812 #define isa_intptr_t isa_int
1813 #define find_intptr_t_type find_int_type
1814 #define find_intptr_t_con  find_int_con
1815 #define TypeX        TypeInt
1816 #define Type_X       Type::Int
1817 #define TypeX_X      TypeInt::INT
1818 #define TypeX_ZERO   TypeInt::ZERO
1819 // For &#39;ideal_reg&#39; machine registers
1820 #define Op_RegX      Op_RegI
1821 // For phase-&gt;intcon variants
1822 #define MakeConX     intcon
1823 #define ConXNode     ConINode
1824 // For array index arithmetic
1825 #define MulXNode     MulINode
1826 #define AndXNode     AndINode
1827 #define OrXNode      OrINode
1828 #define CmpXNode     CmpINode
1829 #define SubXNode     SubINode
1830 #define LShiftXNode  LShiftINode
1831 // For object size computation:
1832 #define AddXNode     AddINode
1833 #define RShiftXNode  RShiftINode
1834 // For card marks and hashcodes
1835 #define URShiftXNode URShiftINode
1836 // UseOptoBiasInlining
1837 #define XorXNode     XorINode
1838 #define StoreXConditionalNode StoreIConditionalNode
1839 #define LoadXNode    LoadINode
1840 #define StoreXNode   StoreINode
1841 // Opcodes
1842 #define Op_LShiftX   Op_LShiftI
1843 #define Op_AndX      Op_AndI
1844 #define Op_AddX      Op_AddI
1845 #define Op_SubX      Op_SubI
1846 #define Op_XorX      Op_XorI
1847 #define Op_URShiftX  Op_URShiftI
1848 #define Op_LoadX     Op_LoadI
1849 // conversions
1850 #define ConvI2X(x)   (x)
1851 #define ConvL2X(x)   ConvL2I(x)
1852 #define ConvX2I(x)   (x)
1853 #define ConvX2L(x)   ConvI2L(x)
1854 #define ConvX2UL(x)  ConvI2UL(x)
1855 
1856 #endif
1857 
1858 #endif // SHARE_OPTO_TYPE_HPP
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
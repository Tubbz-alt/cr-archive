<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/opto/type.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OPTO_TYPE_HPP
  26 #define SHARE_OPTO_TYPE_HPP
  27 
  28 #include &quot;opto/adlcVMDeps.hpp&quot;
  29 #include &quot;runtime/handles.hpp&quot;
  30 
  31 // Portions of code courtesy of Clifford Click
  32 
  33 // Optimization - Graph Style
  34 
  35 
  36 // This class defines a Type lattice.  The lattice is used in the constant
  37 // propagation algorithms, and for some type-checking of the iloc code.
  38 // Basic types include RSD&#39;s (lower bound, upper bound, stride for integers),
  39 // float &amp; double precision constants, sets of data-labels and code-labels.
  40 // The complete lattice is described below.  Subtypes have no relationship to
  41 // up or down in the lattice; that is entirely determined by the behavior of
  42 // the MEET/JOIN functions.
  43 
  44 class Dict;
  45 class Type;
  46 class   TypeD;
  47 class   TypeF;
  48 class   TypeInt;
  49 class   TypeLong;
  50 class   TypeNarrowPtr;
  51 class     TypeNarrowOop;
  52 class     TypeNarrowKlass;
  53 class   TypeAry;
  54 class   TypeTuple;
  55 class   TypeVect;
  56 class     TypeVectS;
  57 class     TypeVectD;
  58 class     TypeVectX;
  59 class     TypeVectY;
  60 class     TypeVectZ;
  61 class   TypePtr;
  62 class     TypeRawPtr;
  63 class     TypeOopPtr;
  64 class       TypeInstPtr;
  65 class       TypeAryPtr;
  66 class     TypeKlassPtr;
  67 class     TypeMetadataPtr;
  68 
  69 //------------------------------Type-------------------------------------------
  70 // Basic Type object, represents a set of primitive Values.
  71 // Types are hash-cons&#39;d into a private class dictionary, so only one of each
  72 // different kind of Type exists.  Types are never modified after creation, so
  73 // all their interesting fields are constant.
  74 class Type {
  75   friend class VMStructs;
  76 
  77 public:
  78   enum TYPES {
  79     Bad=0,                      // Type check
  80     Control,                    // Control of code (not in lattice)
  81     Top,                        // Top of the lattice
  82     Int,                        // Integer range (lo-hi)
  83     Long,                       // Long integer range (lo-hi)
  84     Half,                       // Placeholder half of doubleword
  85     NarrowOop,                  // Compressed oop pointer
  86     NarrowKlass,                // Compressed klass pointer
  87 
  88     Tuple,                      // Method signature or object layout
  89     Array,                      // Array types
  90     VectorS,                    //  32bit Vector types
  91     VectorD,                    //  64bit Vector types
  92     VectorX,                    // 128bit Vector types
  93     VectorY,                    // 256bit Vector types
  94     VectorZ,                    // 512bit Vector types
  95 
  96     AnyPtr,                     // Any old raw, klass, inst, or array pointer
  97     RawPtr,                     // Raw (non-oop) pointers
  98     OopPtr,                     // Any and all Java heap entities
  99     InstPtr,                    // Instance pointers (non-array objects)
 100     AryPtr,                     // Array pointers
 101     // (Ptr order matters:  See is_ptr, isa_ptr, is_oopptr, isa_oopptr.)
 102 
 103     MetadataPtr,                // Generic metadata
 104     KlassPtr,                   // Klass pointers
 105 
 106     Function,                   // Function signature
 107     Abio,                       // Abstract I/O
 108     Return_Address,             // Subroutine return address
 109     Memory,                     // Abstract store
 110     FloatTop,                   // No float value
 111     FloatCon,                   // Floating point constant
 112     FloatBot,                   // Any float value
 113     DoubleTop,                  // No double value
 114     DoubleCon,                  // Double precision constant
 115     DoubleBot,                  // Any double value
 116     Bottom,                     // Bottom of lattice
 117     lastype                     // Bogus ending type (not in lattice)
 118   };
 119 
 120   // Signal values for offsets from a base pointer
 121   enum OFFSET_SIGNALS {
 122     OffsetTop = -2000000000,    // undefined offset
 123     OffsetBot = -2000000001     // any possible offset
 124   };
 125 
 126   // Min and max WIDEN values.
 127   enum WIDEN {
 128     WidenMin = 0,
 129     WidenMax = 3
 130   };
 131 
 132 private:
 133   typedef struct {
 134     TYPES                dual_type;
 135     BasicType            basic_type;
 136     const char*          msg;
 137     bool                 isa_oop;
 138     uint                 ideal_reg;
 139     relocInfo::relocType reloc;
 140   } TypeInfo;
 141 
 142   // Dictionary of types shared among compilations.
 143   static Dict* _shared_type_dict;
 144   static const TypeInfo _type_info[];
 145 
 146   static int uhash( const Type *const t );
 147   // Structural equality check.  Assumes that cmp() has already compared
 148   // the _base types and thus knows it can cast &#39;t&#39; appropriately.
 149   virtual bool eq( const Type *t ) const;
 150 
 151   // Top-level hash-table of types
 152   static Dict *type_dict() {
 153     return Compile::current()-&gt;type_dict();
 154   }
 155 
 156   // DUAL operation: reflect around lattice centerline.  Used instead of
 157   // join to ensure my lattice is symmetric up and down.  Dual is computed
 158   // lazily, on demand, and cached in _dual.
 159   const Type *_dual;            // Cached dual value
 160   // Table for efficient dualing of base types
 161   static const TYPES dual_type[lastype];
 162 
 163 #ifdef ASSERT
 164   // One type is interface, the other is oop
 165   virtual bool interface_vs_oop_helper(const Type *t) const;
 166 #endif
 167 
 168   const Type *meet_helper(const Type *t, bool include_speculative) const;
 169 
 170 protected:
 171   // Each class of type is also identified by its base.
 172   const TYPES _base;            // Enum of Types type
 173 
 174   Type( TYPES t ) : _dual(NULL),  _base(t) {} // Simple types
 175   // ~Type();                   // Use fast deallocation
 176   const Type *hashcons();       // Hash-cons the type
 177   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
 178   const Type *join_helper(const Type *t, bool include_speculative) const {
 179     return dual()-&gt;meet_helper(t-&gt;dual(), include_speculative)-&gt;dual();
 180   }
 181 
 182 public:
 183 
 184   inline void* operator new( size_t x ) throw() {
 185     Compile* compile = Compile::current();
 186     compile-&gt;set_type_last_size(x);
 187     return compile-&gt;type_arena()-&gt;Amalloc_D(x);
 188   }
 189   inline void operator delete( void* ptr ) {
 190     Compile* compile = Compile::current();
 191     compile-&gt;type_arena()-&gt;Afree(ptr,compile-&gt;type_last_size());
 192   }
 193 
 194   // Initialize the type system for a particular compilation.
 195   static void Initialize(Compile* compile);
 196 
 197   // Initialize the types shared by all compilations.
 198   static void Initialize_shared(Compile* compile);
 199 
 200   TYPES base() const {
 201     assert(_base &gt; Bad &amp;&amp; _base &lt; lastype, &quot;sanity&quot;);
 202     return _base;
 203   }
 204 
 205   // Create a new hash-consd type
 206   static const Type *make(enum TYPES);
 207   // Test for equivalence of types
 208   static int cmp( const Type *const t1, const Type *const t2 );
 209   // Test for higher or equal in lattice
 210   // Variant that drops the speculative part of the types
 211   bool higher_equal(const Type *t) const {
 212     return !cmp(meet(t),t-&gt;remove_speculative());
 213   }
 214   // Variant that keeps the speculative part of the types
 215   bool higher_equal_speculative(const Type *t) const {
 216     return !cmp(meet_speculative(t),t);
 217   }
 218 
 219   // MEET operation; lower in lattice.
 220   // Variant that drops the speculative part of the types
 221   const Type *meet(const Type *t) const {
 222     return meet_helper(t, false);
 223   }
 224   // Variant that keeps the speculative part of the types
 225   const Type *meet_speculative(const Type *t) const {
 226     return meet_helper(t, true)-&gt;cleanup_speculative();
 227   }
 228   // WIDEN: &#39;widens&#39; for Ints and other range types
 229   virtual const Type *widen( const Type *old, const Type* limit ) const { return this; }
 230   // NARROW: complement for widen, used by pessimistic phases
 231   virtual const Type *narrow( const Type *old ) const { return this; }
 232 
 233   // DUAL operation: reflect around lattice centerline.  Used instead of
 234   // join to ensure my lattice is symmetric up and down.
 235   const Type *dual() const { return _dual; }
 236 
 237   // Compute meet dependent on base type
 238   virtual const Type *xmeet( const Type *t ) const;
 239   virtual const Type *xdual() const;    // Compute dual right now.
 240 
 241   // JOIN operation; higher in lattice.  Done by finding the dual of the
 242   // meet of the dual of the 2 inputs.
 243   // Variant that drops the speculative part of the types
 244   const Type *join(const Type *t) const {
 245     return join_helper(t, false);
 246   }
 247   // Variant that keeps the speculative part of the types
 248   const Type *join_speculative(const Type *t) const {
 249     return join_helper(t, true)-&gt;cleanup_speculative();
 250   }
 251 
 252   // Modified version of JOIN adapted to the needs Node::Value.
 253   // Normalizes all empty values to TOP.  Does not kill _widen bits.
 254   // Currently, it also works around limitations involving interface types.
 255   // Variant that drops the speculative part of the types
 256   const Type *filter(const Type *kills) const {
 257     return filter_helper(kills, false);
 258   }
 259   // Variant that keeps the speculative part of the types
 260   const Type *filter_speculative(const Type *kills) const {
 261     return filter_helper(kills, true)-&gt;cleanup_speculative();
 262   }
 263 
 264 #ifdef ASSERT
 265   // One type is interface, the other is oop
 266   virtual bool interface_vs_oop(const Type *t) const;
 267 #endif
 268 
 269   // Returns true if this pointer points at memory which contains a
 270   // compressed oop references.
 271   bool is_ptr_to_narrowoop() const;
 272   bool is_ptr_to_narrowklass() const;
 273 
 274   bool is_ptr_to_boxing_obj() const;
 275 
 276 
 277   // Convenience access
 278   float getf() const;
 279   double getd() const;
 280 
 281   const TypeInt    *is_int() const;
 282   const TypeInt    *isa_int() const;             // Returns NULL if not an Int
 283   const TypeLong   *is_long() const;
 284   const TypeLong   *isa_long() const;            // Returns NULL if not a Long
 285   const TypeD      *isa_double() const;          // Returns NULL if not a Double{Top,Con,Bot}
 286   const TypeD      *is_double_constant() const;  // Asserts it is a DoubleCon
 287   const TypeD      *isa_double_constant() const; // Returns NULL if not a DoubleCon
 288   const TypeF      *isa_float() const;           // Returns NULL if not a Float{Top,Con,Bot}
 289   const TypeF      *is_float_constant() const;   // Asserts it is a FloatCon
 290   const TypeF      *isa_float_constant() const;  // Returns NULL if not a FloatCon
 291   const TypeTuple  *is_tuple() const;            // Collection of fields, NOT a pointer
 292   const TypeAry    *is_ary() const;              // Array, NOT array pointer
 293   const TypeAry    *isa_ary() const;             // Returns NULL of not ary
 294   const TypeVect   *is_vect() const;             // Vector
 295   const TypeVect   *isa_vect() const;            // Returns NULL if not a Vector
 296   const TypePtr    *is_ptr() const;              // Asserts it is a ptr type
 297   const TypePtr    *isa_ptr() const;             // Returns NULL if not ptr type
 298   const TypeRawPtr *isa_rawptr() const;          // NOT Java oop
 299   const TypeRawPtr *is_rawptr() const;           // Asserts is rawptr
 300   const TypeNarrowOop  *is_narrowoop() const;    // Java-style GC&#39;d pointer
 301   const TypeNarrowOop  *isa_narrowoop() const;   // Returns NULL if not oop ptr type
 302   const TypeNarrowKlass *is_narrowklass() const; // compressed klass pointer
 303   const TypeNarrowKlass *isa_narrowklass() const;// Returns NULL if not oop ptr type
 304   const TypeOopPtr   *isa_oopptr() const;        // Returns NULL if not oop ptr type
 305   const TypeOopPtr   *is_oopptr() const;         // Java-style GC&#39;d pointer
 306   const TypeInstPtr  *isa_instptr() const;       // Returns NULL if not InstPtr
 307   const TypeInstPtr  *is_instptr() const;        // Instance
 308   const TypeAryPtr   *isa_aryptr() const;        // Returns NULL if not AryPtr
 309   const TypeAryPtr   *is_aryptr() const;         // Array oop
 310 
 311   const TypeMetadataPtr   *isa_metadataptr() const;   // Returns NULL if not oop ptr type
 312   const TypeMetadataPtr   *is_metadataptr() const;    // Java-style GC&#39;d pointer
 313   const TypeKlassPtr      *isa_klassptr() const;      // Returns NULL if not KlassPtr
 314   const TypeKlassPtr      *is_klassptr() const;       // assert if not KlassPtr
 315 
 316   virtual bool      is_finite() const;           // Has a finite value
 317   virtual bool      is_nan()    const;           // Is not a number (NaN)
 318 
 319   // Returns this ptr type or the equivalent ptr type for this compressed pointer.
 320   const TypePtr* make_ptr() const;
 321 
 322   // Returns this oopptr type or the equivalent oopptr type for this compressed pointer.
 323   // Asserts if the underlying type is not an oopptr or narrowoop.
 324   const TypeOopPtr* make_oopptr() const;
 325 
 326   // Returns this compressed pointer or the equivalent compressed version
 327   // of this pointer type.
 328   const TypeNarrowOop* make_narrowoop() const;
 329 
 330   // Returns this compressed klass pointer or the equivalent
 331   // compressed version of this pointer type.
 332   const TypeNarrowKlass* make_narrowklass() const;
 333 
 334   // Special test for register pressure heuristic
 335   bool is_floatingpoint() const;        // True if Float or Double base type
 336 
 337   // Do you have memory, directly or through a tuple?
 338   bool has_memory( ) const;
 339 
 340   // TRUE if type is a singleton
 341   virtual bool singleton(void) const;
 342 
 343   // TRUE if type is above the lattice centerline, and is therefore vacuous
 344   virtual bool empty(void) const;
 345 
 346   // Return a hash for this type.  The hash function is public so ConNode
 347   // (constants) can hash on their constant, which is represented by a Type.
 348   virtual int hash() const;
 349 
 350   // Map ideal registers (machine types) to ideal types
 351   static const Type *mreg2type[];
 352 
 353   // Printing, statistics
 354 #ifndef PRODUCT
 355   void         dump_on(outputStream *st) const;
 356   void         dump() const {
 357     dump_on(tty);
 358   }
 359   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
 360   static  void dump_stats();
 361 
 362   static const char* str(const Type* t);
 363 #endif
 364   void typerr(const Type *t) const; // Mixing types error
 365 
 366   // Create basic type
 367   static const Type* get_const_basic_type(BasicType type) {
 368     assert((uint)type &lt;= T_CONFLICT &amp;&amp; _const_basic_type[type] != NULL, &quot;bad type&quot;);
 369     return _const_basic_type[type];
 370   }
 371 
 372   // For two instance arrays of same dimension, return the base element types.
 373   // Otherwise or if the arrays have different dimensions, return NULL.
 374   static void get_arrays_base_elements(const Type *a1, const Type *a2,
 375                                        const TypeInstPtr **e1, const TypeInstPtr **e2);
 376 
 377   // Mapping to the array element&#39;s basic type.
 378   BasicType array_element_basic_type() const;
 379 
 380   // Create standard type for a ciType:
 381   static const Type* get_const_type(ciType* type);
 382 
 383   // Create standard zero value:
 384   static const Type* get_zero_type(BasicType type) {
 385     assert((uint)type &lt;= T_CONFLICT &amp;&amp; _zero_type[type] != NULL, &quot;bad type&quot;);
 386     return _zero_type[type];
 387   }
 388 
 389   // Report if this is a zero value (not top).
 390   bool is_zero_type() const {
 391     BasicType type = basic_type();
 392     if (type == T_VOID || type &gt;= T_CONFLICT)
 393       return false;
 394     else
 395       return (this == _zero_type[type]);
 396   }
 397 
 398   // Convenience common pre-built types.
 399   static const Type *ABIO;
 400   static const Type *BOTTOM;
 401   static const Type *CONTROL;
 402   static const Type *DOUBLE;
 403   static const Type *FLOAT;
 404   static const Type *HALF;
 405   static const Type *MEMORY;
 406   static const Type *MULTI;
 407   static const Type *RETURN_ADDRESS;
 408   static const Type *TOP;
 409 
 410   // Mapping from compiler type to VM BasicType
 411   BasicType basic_type() const       { return _type_info[_base].basic_type; }
 412   uint ideal_reg() const             { return _type_info[_base].ideal_reg; }
 413   const char* msg() const            { return _type_info[_base].msg; }
 414   bool isa_oop_ptr() const           { return _type_info[_base].isa_oop; }
 415   relocInfo::relocType reloc() const { return _type_info[_base].reloc; }
 416 
 417   // Mapping from CI type system to compiler type:
 418   static const Type* get_typeflow_type(ciType* type);
 419 
 420   static const Type* make_from_constant(ciConstant constant,
 421                                         bool require_constant = false,
 422                                         int stable_dimension = 0,
 423                                         bool is_narrow = false,
 424                                         bool is_autobox_cache = false);
 425 
 426   static const Type* make_constant_from_field(ciInstance* holder,
 427                                               int off,
 428                                               bool is_unsigned_load,
 429                                               BasicType loadbt);
 430 
 431   static const Type* make_constant_from_field(ciField* field,
 432                                               ciInstance* holder,
 433                                               BasicType loadbt,
 434                                               bool is_unsigned_load);
 435 
 436   static const Type* make_constant_from_array_element(ciArray* array,
 437                                                       int off,
 438                                                       int stable_dimension,
 439                                                       BasicType loadbt,
 440                                                       bool is_unsigned_load);
 441 
 442   // Speculative type helper methods. See TypePtr.
 443   virtual const TypePtr* speculative() const                                  { return NULL; }
 444   virtual ciKlass* speculative_type() const                                   { return NULL; }
 445   virtual ciKlass* speculative_type_not_null() const                          { return NULL; }
 446   virtual bool speculative_maybe_null() const                                 { return true; }
 447   virtual bool speculative_always_null() const                                { return true; }
 448   virtual const Type* remove_speculative() const                              { return this; }
 449   virtual const Type* cleanup_speculative() const                             { return this; }
 450   virtual bool would_improve_type(ciKlass* exact_kls, int inline_depth) const { return exact_kls != NULL; }
 451   virtual bool would_improve_ptr(ProfilePtrKind ptr_kind) const { return ptr_kind == ProfileAlwaysNull || ptr_kind == ProfileNeverNull; }
 452   const Type* maybe_remove_speculative(bool include_speculative) const;
 453 
 454   virtual bool maybe_null() const { return true; }
 455   virtual bool is_known_instance() const { return false; }
 456 
 457 private:
 458   // support arrays
 459   static const Type*        _zero_type[T_CONFLICT+1];
 460   static const Type* _const_basic_type[T_CONFLICT+1];
 461 };
 462 
 463 //------------------------------TypeF------------------------------------------
 464 // Class of Float-Constant Types.
 465 class TypeF : public Type {
 466   TypeF( float f ) : Type(FloatCon), _f(f) {};
 467 public:
 468   virtual bool eq( const Type *t ) const;
 469   virtual int  hash() const;             // Type specific hashing
 470   virtual bool singleton(void) const;    // TRUE if type is a singleton
 471   virtual bool empty(void) const;        // TRUE if type is vacuous
 472 public:
 473   const float _f;               // Float constant
 474 
 475   static const TypeF *make(float f);
 476 
 477   virtual bool        is_finite() const;  // Has a finite value
 478   virtual bool        is_nan()    const;  // Is not a number (NaN)
 479 
 480   virtual const Type *xmeet( const Type *t ) const;
 481   virtual const Type *xdual() const;    // Compute dual right now.
 482   // Convenience common pre-built types.
 483   static const TypeF *ZERO; // positive zero only
 484   static const TypeF *ONE;
 485   static const TypeF *POS_INF;
 486   static const TypeF *NEG_INF;
 487 #ifndef PRODUCT
 488   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
 489 #endif
 490 };
 491 
 492 //------------------------------TypeD------------------------------------------
 493 // Class of Double-Constant Types.
 494 class TypeD : public Type {
 495   TypeD( double d ) : Type(DoubleCon), _d(d) {};
 496 public:
 497   virtual bool eq( const Type *t ) const;
 498   virtual int  hash() const;             // Type specific hashing
 499   virtual bool singleton(void) const;    // TRUE if type is a singleton
 500   virtual bool empty(void) const;        // TRUE if type is vacuous
 501 public:
 502   const double _d;              // Double constant
 503 
 504   static const TypeD *make(double d);
 505 
 506   virtual bool        is_finite() const;  // Has a finite value
 507   virtual bool        is_nan()    const;  // Is not a number (NaN)
 508 
 509   virtual const Type *xmeet( const Type *t ) const;
 510   virtual const Type *xdual() const;    // Compute dual right now.
 511   // Convenience common pre-built types.
 512   static const TypeD *ZERO; // positive zero only
 513   static const TypeD *ONE;
 514   static const TypeD *POS_INF;
 515   static const TypeD *NEG_INF;
 516 #ifndef PRODUCT
 517   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
 518 #endif
 519 };
 520 
 521 //------------------------------TypeInt----------------------------------------
 522 // Class of integer ranges, the set of integers between a lower bound and an
 523 // upper bound, inclusive.
 524 class TypeInt : public Type {
 525   TypeInt( jint lo, jint hi, int w );
 526 protected:
 527   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
 528 
 529 public:
 530   typedef jint NativeType;
 531   virtual bool eq( const Type *t ) const;
 532   virtual int  hash() const;             // Type specific hashing
 533   virtual bool singleton(void) const;    // TRUE if type is a singleton
 534   virtual bool empty(void) const;        // TRUE if type is vacuous
 535   const jint _lo, _hi;          // Lower bound, upper bound
 536   const short _widen;           // Limit on times we widen this sucker
 537 
 538   static const TypeInt *make(jint lo);
 539   // must always specify w
 540   static const TypeInt *make(jint lo, jint hi, int w);
 541 
 542   // Check for single integer
 543   int is_con() const { return _lo==_hi; }
 544   bool is_con(int i) const { return is_con() &amp;&amp; _lo == i; }
 545   jint get_con() const { assert( is_con(), &quot;&quot; );  return _lo; }
 546 
 547   virtual bool        is_finite() const;  // Has a finite value
 548 
 549   virtual const Type *xmeet( const Type *t ) const;
 550   virtual const Type *xdual() const;    // Compute dual right now.
 551   virtual const Type *widen( const Type *t, const Type* limit_type ) const;
 552   virtual const Type *narrow( const Type *t ) const;
 553   // Do not kill _widen bits.
 554   // Convenience common pre-built types.
 555   static const TypeInt *MINUS_1;
 556   static const TypeInt *ZERO;
 557   static const TypeInt *ONE;
 558   static const TypeInt *BOOL;
 559   static const TypeInt *CC;
 560   static const TypeInt *CC_LT;  // [-1]  == MINUS_1
 561   static const TypeInt *CC_GT;  // [1]   == ONE
 562   static const TypeInt *CC_EQ;  // [0]   == ZERO
 563   static const TypeInt *CC_LE;  // [-1,0]
 564   static const TypeInt *CC_GE;  // [0,1] == BOOL (!)
 565   static const TypeInt *BYTE;
 566   static const TypeInt *UBYTE;
 567   static const TypeInt *CHAR;
 568   static const TypeInt *SHORT;
 569   static const TypeInt *POS;
 570   static const TypeInt *POS1;
 571   static const TypeInt *INT;
 572   static const TypeInt *SYMINT; // symmetric range [-max_jint..max_jint]
 573   static const TypeInt *TYPE_DOMAIN; // alias for TypeInt::INT
 574 
 575   static const TypeInt *as_self(const Type *t) { return t-&gt;is_int(); }
 576 #ifndef PRODUCT
 577   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
 578 #endif
 579 };
 580 
 581 
 582 //------------------------------TypeLong---------------------------------------
 583 // Class of long integer ranges, the set of integers between a lower bound and
 584 // an upper bound, inclusive.
 585 class TypeLong : public Type {
 586   TypeLong( jlong lo, jlong hi, int w );
 587 protected:
 588   // Do not kill _widen bits.
 589   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
 590 public:
 591   typedef jlong NativeType;
 592   virtual bool eq( const Type *t ) const;
 593   virtual int  hash() const;             // Type specific hashing
 594   virtual bool singleton(void) const;    // TRUE if type is a singleton
 595   virtual bool empty(void) const;        // TRUE if type is vacuous
 596 public:
 597   const jlong _lo, _hi;         // Lower bound, upper bound
 598   const short _widen;           // Limit on times we widen this sucker
 599 
 600   static const TypeLong *make(jlong lo);
 601   // must always specify w
 602   static const TypeLong *make(jlong lo, jlong hi, int w);
 603 
 604   // Check for single integer
 605   int is_con() const { return _lo==_hi; }
 606   bool is_con(int i) const { return is_con() &amp;&amp; _lo == i; }
 607   jlong get_con() const { assert( is_con(), &quot;&quot; ); return _lo; }
 608 
 609   // Check for positive 32-bit value.
 610   int is_positive_int() const { return _lo &gt;= 0 &amp;&amp; _hi &lt;= (jlong)max_jint; }
 611 
 612   virtual bool        is_finite() const;  // Has a finite value
 613 
 614 
 615   virtual const Type *xmeet( const Type *t ) const;
 616   virtual const Type *xdual() const;    // Compute dual right now.
 617   virtual const Type *widen( const Type *t, const Type* limit_type ) const;
 618   virtual const Type *narrow( const Type *t ) const;
 619   // Convenience common pre-built types.
 620   static const TypeLong *MINUS_1;
 621   static const TypeLong *ZERO;
 622   static const TypeLong *ONE;
 623   static const TypeLong *POS;
 624   static const TypeLong *LONG;
 625   static const TypeLong *INT;    // 32-bit subrange [min_jint..max_jint]
 626   static const TypeLong *UINT;   // 32-bit unsigned [0..max_juint]
 627   static const TypeLong *TYPE_DOMAIN; // alias for TypeLong::LONG
 628 
 629   // static convenience methods.
 630   static const TypeLong *as_self(const Type *t) { return t-&gt;is_long(); }
 631 
 632 #ifndef PRODUCT
 633   virtual void dump2( Dict &amp;d, uint, outputStream *st  ) const;// Specialized per-Type dumping
 634 #endif
 635 };
 636 
 637 //------------------------------TypeTuple--------------------------------------
 638 // Class of Tuple Types, essentially type collections for function signatures
 639 // and class layouts.  It happens to also be a fast cache for the HotSpot
 640 // signature types.
 641 class TypeTuple : public Type {
 642   TypeTuple( uint cnt, const Type **fields ) : Type(Tuple), _cnt(cnt), _fields(fields) { }
 643 
 644   const uint          _cnt;              // Count of fields
 645   const Type ** const _fields;           // Array of field types
 646 
 647 public:
 648   virtual bool eq( const Type *t ) const;
 649   virtual int  hash() const;             // Type specific hashing
 650   virtual bool singleton(void) const;    // TRUE if type is a singleton
 651   virtual bool empty(void) const;        // TRUE if type is vacuous
 652 
 653   // Accessors:
 654   uint cnt() const { return _cnt; }
 655   const Type* field_at(uint i) const {
 656     assert(i &lt; _cnt, &quot;oob&quot;);
 657     return _fields[i];
 658   }
 659   void set_field_at(uint i, const Type* t) {
 660     assert(i &lt; _cnt, &quot;oob&quot;);
 661     _fields[i] = t;
 662   }
 663 
 664   static const TypeTuple *make( uint cnt, const Type **fields );
 665   static const TypeTuple *make_range(ciSignature *sig);
 666   static const TypeTuple *make_domain(ciInstanceKlass* recv, ciSignature *sig);
 667 
 668   // Subroutine call type with space allocated for argument types
 669   // Memory for Control, I_O, Memory, FramePtr, and ReturnAdr is allocated implicitly
 670   static const Type **fields( uint arg_cnt );
 671 
 672   virtual const Type *xmeet( const Type *t ) const;
 673   virtual const Type *xdual() const;    // Compute dual right now.
 674   // Convenience common pre-built types.
 675   static const TypeTuple *IFBOTH;
 676   static const TypeTuple *IFFALSE;
 677   static const TypeTuple *IFTRUE;
 678   static const TypeTuple *IFNEITHER;
 679   static const TypeTuple *LOOPBODY;
 680   static const TypeTuple *MEMBAR;
 681   static const TypeTuple *STORECONDITIONAL;
 682   static const TypeTuple *START_I2C;
 683   static const TypeTuple *INT_PAIR;
 684   static const TypeTuple *LONG_PAIR;
 685   static const TypeTuple *INT_CC_PAIR;
 686   static const TypeTuple *LONG_CC_PAIR;
 687 #ifndef PRODUCT
 688   virtual void dump2( Dict &amp;d, uint, outputStream *st  ) const; // Specialized per-Type dumping
 689 #endif
 690 };
 691 
 692 //------------------------------TypeAry----------------------------------------
 693 // Class of Array Types
 694 class TypeAry : public Type {
 695   TypeAry(const Type* elem, const TypeInt* size, bool stable) : Type(Array),
 696       _elem(elem), _size(size), _stable(stable) {}
 697 public:
 698   virtual bool eq( const Type *t ) const;
 699   virtual int  hash() const;             // Type specific hashing
 700   virtual bool singleton(void) const;    // TRUE if type is a singleton
 701   virtual bool empty(void) const;        // TRUE if type is vacuous
 702 
 703 private:
 704   const Type *_elem;            // Element type of array
 705   const TypeInt *_size;         // Elements in array
 706   const bool _stable;           // Are elements @Stable?
 707   friend class TypeAryPtr;
 708 
 709 public:
 710   static const TypeAry* make(const Type* elem, const TypeInt* size, bool stable = false);
 711 
 712   virtual const Type *xmeet( const Type *t ) const;
 713   virtual const Type *xdual() const;    // Compute dual right now.
 714   bool ary_must_be_exact() const;  // true if arrays of such are never generic
 715   virtual const Type* remove_speculative() const;
 716   virtual const Type* cleanup_speculative() const;
 717 #ifdef ASSERT
 718   // One type is interface, the other is oop
 719   virtual bool interface_vs_oop(const Type *t) const;
 720 #endif
 721 #ifndef PRODUCT
 722   virtual void dump2( Dict &amp;d, uint, outputStream *st  ) const; // Specialized per-Type dumping
 723 #endif
 724 };
 725 
 726 //------------------------------TypeVect---------------------------------------
 727 // Class of Vector Types
 728 class TypeVect : public Type {
 729   const Type*   _elem;  // Vector&#39;s element type
 730   const uint  _length;  // Elements in vector (power of 2)
 731 
 732 protected:
 733   TypeVect(TYPES t, const Type* elem, uint length) : Type(t),
 734     _elem(elem), _length(length) {}
 735 
 736 public:
 737   const Type* element_type() const { return _elem; }
 738   BasicType element_basic_type() const { return _elem-&gt;array_element_basic_type(); }
 739   uint length() const { return _length; }
 740   uint length_in_bytes() const {
 741    return _length * type2aelembytes(element_basic_type());
 742   }
 743 
 744   virtual bool eq(const Type *t) const;
 745   virtual int  hash() const;             // Type specific hashing
 746   virtual bool singleton(void) const;    // TRUE if type is a singleton
 747   virtual bool empty(void) const;        // TRUE if type is vacuous
 748 
 749   static const TypeVect *make(const BasicType elem_bt, uint length) {
 750     // Use bottom primitive type.
 751     return make(get_const_basic_type(elem_bt), length);
 752   }
 753   // Used directly by Replicate nodes to construct singleton vector.
 754   static const TypeVect *make(const Type* elem, uint length);
 755 
 756   virtual const Type *xmeet( const Type *t) const;
 757   virtual const Type *xdual() const;     // Compute dual right now.
 758 
 759   static const TypeVect *VECTS;
 760   static const TypeVect *VECTD;
 761   static const TypeVect *VECTX;
 762   static const TypeVect *VECTY;
 763   static const TypeVect *VECTZ;
 764 
 765 #ifndef PRODUCT
 766   virtual void dump2(Dict &amp;d, uint, outputStream *st) const; // Specialized per-Type dumping
 767 #endif
 768 };
 769 
 770 class TypeVectS : public TypeVect {
 771   friend class TypeVect;
 772   TypeVectS(const Type* elem, uint length) : TypeVect(VectorS, elem, length) {}
 773 };
 774 
 775 class TypeVectD : public TypeVect {
 776   friend class TypeVect;
 777   TypeVectD(const Type* elem, uint length) : TypeVect(VectorD, elem, length) {}
 778 };
 779 
 780 class TypeVectX : public TypeVect {
 781   friend class TypeVect;
 782   TypeVectX(const Type* elem, uint length) : TypeVect(VectorX, elem, length) {}
 783 };
 784 
 785 class TypeVectY : public TypeVect {
 786   friend class TypeVect;
 787   TypeVectY(const Type* elem, uint length) : TypeVect(VectorY, elem, length) {}
 788 };
 789 
 790 class TypeVectZ : public TypeVect {
 791   friend class TypeVect;
 792   TypeVectZ(const Type* elem, uint length) : TypeVect(VectorZ, elem, length) {}
 793 };
 794 
 795 //------------------------------TypePtr----------------------------------------
 796 // Class of machine Pointer Types: raw data, instances or arrays.
 797 // If the _base enum is AnyPtr, then this refers to all of the above.
 798 // Otherwise the _base will indicate which subset of pointers is affected,
 799 // and the class will be inherited from.
 800 class TypePtr : public Type {
 801   friend class TypeNarrowPtr;
 802 public:
 803   enum PTR { TopPTR, AnyNull, Constant, Null, NotNull, BotPTR, lastPTR };
 804 protected:
 805   TypePtr(TYPES t, PTR ptr, int offset,
 806           const TypePtr* speculative = NULL,
 807           int inline_depth = InlineDepthBottom) :
 808     Type(t), _speculative(speculative), _inline_depth(inline_depth), _offset(offset),
 809     _ptr(ptr) {}
 810   static const PTR ptr_meet[lastPTR][lastPTR];
 811   static const PTR ptr_dual[lastPTR];
 812   static const char * const ptr_msg[lastPTR];
 813 
 814   enum {
 815     InlineDepthBottom = INT_MAX,
 816     InlineDepthTop = -InlineDepthBottom
 817   };
 818 
 819   // Extra type information profiling gave us. We propagate it the
 820   // same way the rest of the type info is propagated. If we want to
 821   // use it, then we have to emit a guard: this part of the type is
 822   // not something we know but something we speculate about the type.
 823   const TypePtr*   _speculative;
 824   // For speculative types, we record at what inlining depth the
 825   // profiling point that provided the data is. We want to favor
 826   // profile data coming from outer scopes which are likely better for
 827   // the current compilation.
 828   int _inline_depth;
 829 
 830   // utility methods to work on the speculative part of the type
 831   const TypePtr* dual_speculative() const;
 832   const TypePtr* xmeet_speculative(const TypePtr* other) const;
 833   bool eq_speculative(const TypePtr* other) const;
 834   int hash_speculative() const;
 835   const TypePtr* add_offset_speculative(intptr_t offset) const;
 836 #ifndef PRODUCT
 837   void dump_speculative(outputStream *st) const;
 838 #endif
 839 
 840   // utility methods to work on the inline depth of the type
 841   int dual_inline_depth() const;
 842   int meet_inline_depth(int depth) const;
 843 #ifndef PRODUCT
 844   void dump_inline_depth(outputStream *st) const;
 845 #endif
 846 
 847 public:
 848   const int _offset;            // Offset into oop, with TOP &amp; BOT
 849   const PTR _ptr;               // Pointer equivalence class
 850 
 851   const int offset() const { return _offset; }
 852   const PTR ptr()    const { return _ptr; }
 853 
 854   static const TypePtr *make(TYPES t, PTR ptr, int offset,
 855                              const TypePtr* speculative = NULL,
 856                              int inline_depth = InlineDepthBottom);
 857 
 858   // Return a &#39;ptr&#39; version of this type
 859   virtual const Type *cast_to_ptr_type(PTR ptr) const;
 860 
 861   virtual intptr_t get_con() const;
 862 
 863   int xadd_offset( intptr_t offset ) const;
 864   virtual const TypePtr *add_offset( intptr_t offset ) const;
 865   virtual bool eq(const Type *t) const;
 866   virtual int  hash() const;             // Type specific hashing
 867 
 868   virtual bool singleton(void) const;    // TRUE if type is a singleton
 869   virtual bool empty(void) const;        // TRUE if type is vacuous
 870   virtual const Type *xmeet( const Type *t ) const;
 871   virtual const Type *xmeet_helper( const Type *t ) const;
 872   int meet_offset( int offset ) const;
 873   int dual_offset( ) const;
 874   virtual const Type *xdual() const;    // Compute dual right now.
 875 
 876   // meet, dual and join over pointer equivalence sets
 877   PTR meet_ptr( const PTR in_ptr ) const { return ptr_meet[in_ptr][ptr()]; }
 878   PTR dual_ptr()                   const { return ptr_dual[ptr()];      }
 879 
 880   // This is textually confusing unless one recalls that
 881   // join(t) == dual()-&gt;meet(t-&gt;dual())-&gt;dual().
 882   PTR join_ptr( const PTR in_ptr ) const {
 883     return ptr_dual[ ptr_meet[ ptr_dual[in_ptr] ] [ dual_ptr() ] ];
 884   }
 885 
 886   // Speculative type helper methods.
 887   virtual const TypePtr* speculative() const { return _speculative; }
 888   int inline_depth() const                   { return _inline_depth; }
 889   virtual ciKlass* speculative_type() const;
 890   virtual ciKlass* speculative_type_not_null() const;
 891   virtual bool speculative_maybe_null() const;
 892   virtual bool speculative_always_null() const;
 893   virtual const Type* remove_speculative() const;
 894   virtual const Type* cleanup_speculative() const;
 895   virtual bool would_improve_type(ciKlass* exact_kls, int inline_depth) const;
 896   virtual bool would_improve_ptr(ProfilePtrKind maybe_null) const;
 897   virtual const TypePtr* with_inline_depth(int depth) const;
 898 
 899   virtual bool maybe_null() const { return meet_ptr(Null) == ptr(); }
 900 
 901   // Tests for relation to centerline of type lattice:
 902   static bool above_centerline(PTR ptr) { return (ptr &lt;= AnyNull); }
 903   static bool below_centerline(PTR ptr) { return (ptr &gt;= NotNull); }
 904   // Convenience common pre-built types.
 905   static const TypePtr *NULL_PTR;
 906   static const TypePtr *NOTNULL;
 907   static const TypePtr *BOTTOM;
 908 #ifndef PRODUCT
 909   virtual void dump2( Dict &amp;d, uint depth, outputStream *st  ) const;
 910 #endif
 911 };
 912 
 913 //------------------------------TypeRawPtr-------------------------------------
 914 // Class of raw pointers, pointers to things other than Oops.  Examples
 915 // include the stack pointer, top of heap, card-marking area, handles, etc.
 916 class TypeRawPtr : public TypePtr {
 917 protected:
 918   TypeRawPtr( PTR ptr, address bits ) : TypePtr(RawPtr,ptr,0), _bits(bits){}
 919 public:
 920   virtual bool eq( const Type *t ) const;
 921   virtual int  hash() const;     // Type specific hashing
 922 
 923   const address _bits;          // Constant value, if applicable
 924 
 925   static const TypeRawPtr *make( PTR ptr );
 926   static const TypeRawPtr *make( address bits );
 927 
 928   // Return a &#39;ptr&#39; version of this type
 929   virtual const Type *cast_to_ptr_type(PTR ptr) const;
 930 
 931   virtual intptr_t get_con() const;
 932 
 933   virtual const TypePtr *add_offset( intptr_t offset ) const;
 934 
 935   virtual const Type *xmeet( const Type *t ) const;
 936   virtual const Type *xdual() const;    // Compute dual right now.
 937   // Convenience common pre-built types.
 938   static const TypeRawPtr *BOTTOM;
 939   static const TypeRawPtr *NOTNULL;
 940 #ifndef PRODUCT
 941   virtual void dump2( Dict &amp;d, uint depth, outputStream *st  ) const;
 942 #endif
 943 };
 944 
 945 //------------------------------TypeOopPtr-------------------------------------
 946 // Some kind of oop (Java pointer), either instance or array.
 947 class TypeOopPtr : public TypePtr {
 948 protected:
 949   TypeOopPtr(TYPES t, PTR ptr, ciKlass* k, bool xk, ciObject* o, int offset, int instance_id,
 950              const TypePtr* speculative, int inline_depth);
 951 public:
 952   virtual bool eq( const Type *t ) const;
 953   virtual int  hash() const;             // Type specific hashing
 954   virtual bool singleton(void) const;    // TRUE if type is a singleton
 955   enum {
 956    InstanceTop = -1,   // undefined instance
 957    InstanceBot = 0     // any possible instance
 958   };
 959 protected:
 960 
 961   // Oop is NULL, unless this is a constant oop.
 962   ciObject*     _const_oop;   // Constant oop
 963   // If _klass is NULL, then so is _sig.  This is an unloaded klass.
 964   ciKlass*      _klass;       // Klass object
 965   // Does the type exclude subclasses of the klass?  (Inexact == polymorphic.)
 966   bool          _klass_is_exact;
 967   bool          _is_ptr_to_narrowoop;
 968   bool          _is_ptr_to_narrowklass;
 969   bool          _is_ptr_to_boxed_value;
 970 
 971   // If not InstanceTop or InstanceBot, indicates that this is
 972   // a particular instance of this type which is distinct.
 973   // This is the node index of the allocation node creating this instance.
 974   int           _instance_id;
 975 
 976   static const TypeOopPtr* make_from_klass_common(ciKlass* klass, bool klass_change, bool try_for_exact);
 977 
 978   int dual_instance_id() const;
 979   int meet_instance_id(int uid) const;
 980 
 981   // Do not allow interface-vs.-noninterface joins to collapse to top.
 982   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
 983 
 984 public:
 985   // Creates a type given a klass. Correctly handles multi-dimensional arrays
 986   // Respects UseUniqueSubclasses.
 987   // If the klass is final, the resulting type will be exact.
 988   static const TypeOopPtr* make_from_klass(ciKlass* klass) {
 989     return make_from_klass_common(klass, true, false);
 990   }
 991   // Same as before, but will produce an exact type, even if
 992   // the klass is not final, as long as it has exactly one implementation.
 993   static const TypeOopPtr* make_from_klass_unique(ciKlass* klass) {
 994     return make_from_klass_common(klass, true, true);
 995   }
 996   // Same as before, but does not respects UseUniqueSubclasses.
 997   // Use this only for creating array element types.
 998   static const TypeOopPtr* make_from_klass_raw(ciKlass* klass) {
 999     return make_from_klass_common(klass, false, false);
1000   }
1001   // Creates a singleton type given an object.
1002   // If the object cannot be rendered as a constant,
1003   // may return a non-singleton type.
1004   // If require_constant, produce a NULL if a singleton is not possible.
1005   static const TypeOopPtr* make_from_constant(ciObject* o,
1006                                               bool require_constant = false);
1007 
1008   // Make a generic (unclassed) pointer to an oop.
1009   static const TypeOopPtr* make(PTR ptr, int offset, int instance_id,
1010                                 const TypePtr* speculative = NULL,
1011                                 int inline_depth = InlineDepthBottom);
1012 
1013   ciObject* const_oop()    const { return _const_oop; }
1014   virtual ciKlass* klass() const { return _klass;     }
1015   bool klass_is_exact()    const { return _klass_is_exact; }
1016 
1017   // Returns true if this pointer points at memory which contains a
1018   // compressed oop references.
1019   bool is_ptr_to_narrowoop_nv() const { return _is_ptr_to_narrowoop; }
1020   bool is_ptr_to_narrowklass_nv() const { return _is_ptr_to_narrowklass; }
1021   bool is_ptr_to_boxed_value()   const { return _is_ptr_to_boxed_value; }
1022   bool is_known_instance()       const { return _instance_id &gt; 0; }
1023   int  instance_id()             const { return _instance_id; }
1024   bool is_known_instance_field() const { return is_known_instance() &amp;&amp; _offset &gt;= 0; }
1025 
1026   virtual intptr_t get_con() const;
1027 
1028   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1029 
1030   virtual const Type *cast_to_exactness(bool klass_is_exact) const;
1031 
1032   virtual const TypeOopPtr *cast_to_instance_id(int instance_id) const;
1033 
1034   // corresponding pointer to klass, for a given instance
1035   const TypeKlassPtr* as_klass_type() const;
1036 
1037   virtual const TypePtr *add_offset( intptr_t offset ) const;
1038 
1039   // Speculative type helper methods.
1040   virtual const Type* remove_speculative() const;
1041   virtual const Type* cleanup_speculative() const;
1042   virtual bool would_improve_type(ciKlass* exact_kls, int inline_depth) const;
1043   virtual const TypePtr* with_inline_depth(int depth) const;
1044 
1045   virtual const TypePtr* with_instance_id(int instance_id) const;
1046 
1047   virtual const Type *xdual() const;    // Compute dual right now.
1048   // the core of the computation of the meet for TypeOopPtr and for its subclasses
1049   virtual const Type *xmeet_helper(const Type *t) const;
1050 
1051   // Convenience common pre-built type.
1052   static const TypeOopPtr *BOTTOM;
1053 #ifndef PRODUCT
1054   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
1055 #endif
1056 };
1057 
1058 //------------------------------TypeInstPtr------------------------------------
1059 // Class of Java object pointers, pointing either to non-array Java instances
1060 // or to a Klass* (including array klasses).
1061 class TypeInstPtr : public TypeOopPtr {
1062   TypeInstPtr(PTR ptr, ciKlass* k, bool xk, ciObject* o, int offset, int instance_id,
1063               const TypePtr* speculative, int inline_depth);
1064   virtual bool eq( const Type *t ) const;
1065   virtual int  hash() const;             // Type specific hashing
1066 
1067   ciSymbol*  _name;        // class name
1068 
1069  public:
1070   ciSymbol* name()         const { return _name; }
1071 
1072   bool  is_loaded() const { return _klass-&gt;is_loaded(); }
1073 
1074   // Make a pointer to a constant oop.
1075   static const TypeInstPtr *make(ciObject* o) {
1076     return make(TypePtr::Constant, o-&gt;klass(), true, o, 0, InstanceBot);
1077   }
1078   // Make a pointer to a constant oop with offset.
1079   static const TypeInstPtr *make(ciObject* o, int offset) {
1080     return make(TypePtr::Constant, o-&gt;klass(), true, o, offset, InstanceBot);
1081   }
1082 
1083   // Make a pointer to some value of type klass.
1084   static const TypeInstPtr *make(PTR ptr, ciKlass* klass) {
1085     return make(ptr, klass, false, NULL, 0, InstanceBot);
1086   }
1087 
1088   // Make a pointer to some non-polymorphic value of exactly type klass.
1089   static const TypeInstPtr *make_exact(PTR ptr, ciKlass* klass) {
1090     return make(ptr, klass, true, NULL, 0, InstanceBot);
1091   }
1092 
1093   // Make a pointer to some value of type klass with offset.
1094   static const TypeInstPtr *make(PTR ptr, ciKlass* klass, int offset) {
1095     return make(ptr, klass, false, NULL, offset, InstanceBot);
1096   }
1097 
1098   // Make a pointer to an oop.
1099   static const TypeInstPtr *make(PTR ptr, ciKlass* k, bool xk, ciObject* o, int offset,
1100                                  int instance_id = InstanceBot,
1101                                  const TypePtr* speculative = NULL,
1102                                  int inline_depth = InlineDepthBottom);
1103 
1104   /** Create constant type for a constant boxed value */
1105   const Type* get_const_boxed_value() const;
1106 
1107   // If this is a java.lang.Class constant, return the type for it or NULL.
1108   // Pass to Type::get_const_type to turn it to a type, which will usually
1109   // be a TypeInstPtr, but may also be a TypeInt::INT for int.class, etc.
1110   ciType* java_mirror_type() const;
1111 
1112   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1113 
1114   virtual const Type *cast_to_exactness(bool klass_is_exact) const;
1115 
1116   virtual const TypeOopPtr *cast_to_instance_id(int instance_id) const;
1117 
1118   virtual const TypePtr *add_offset( intptr_t offset ) const;
1119 
1120   // Speculative type helper methods.
1121   virtual const Type* remove_speculative() const;
1122   virtual const TypePtr* with_inline_depth(int depth) const;
1123   virtual const TypePtr* with_instance_id(int instance_id) const;
1124 
1125   // the core of the computation of the meet of 2 types
1126   virtual const Type *xmeet_helper(const Type *t) const;
1127   virtual const TypeInstPtr *xmeet_unloaded( const TypeInstPtr *t ) const;
1128   virtual const Type *xdual() const;    // Compute dual right now.
1129 
1130   // Convenience common pre-built types.
1131   static const TypeInstPtr *NOTNULL;
1132   static const TypeInstPtr *BOTTOM;
1133   static const TypeInstPtr *MIRROR;
1134   static const TypeInstPtr *MARK;
1135   static const TypeInstPtr *KLASS;
1136 #ifndef PRODUCT
1137   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const; // Specialized per-Type dumping
1138 #endif
1139 };
1140 
1141 //------------------------------TypeAryPtr-------------------------------------
1142 // Class of Java array pointers
1143 class TypeAryPtr : public TypeOopPtr {
1144   TypeAryPtr( PTR ptr, ciObject* o, const TypeAry *ary, ciKlass* k, bool xk,
1145               int offset, int instance_id, bool is_autobox_cache,
1146               const TypePtr* speculative, int inline_depth)
1147     : TypeOopPtr(AryPtr,ptr,k,xk,o,offset, instance_id, speculative, inline_depth),
1148     _ary(ary),
1149     _is_autobox_cache(is_autobox_cache)
1150  {
1151 #ifdef ASSERT
1152     if (k != NULL) {
1153       // Verify that specified klass and TypeAryPtr::klass() follow the same rules.
1154       ciKlass* ck = compute_klass(true);
1155       if (k != ck) {
1156         this-&gt;dump(); tty-&gt;cr();
1157         tty-&gt;print(&quot; k: &quot;);
1158         k-&gt;print(); tty-&gt;cr();
1159         tty-&gt;print(&quot;ck: &quot;);
1160         if (ck != NULL) ck-&gt;print();
1161         else tty-&gt;print(&quot;&lt;NULL&gt;&quot;);
1162         tty-&gt;cr();
1163         assert(false, &quot;unexpected TypeAryPtr::_klass&quot;);
1164       }
1165     }
1166 #endif
1167   }
1168   virtual bool eq( const Type *t ) const;
1169   virtual int hash() const;     // Type specific hashing
1170   const TypeAry *_ary;          // Array we point into
1171   const bool     _is_autobox_cache;
1172 
1173   ciKlass* compute_klass(DEBUG_ONLY(bool verify = false)) const;
1174 
1175 public:
1176   // Accessors
1177   ciKlass* klass() const;
1178   const TypeAry* ary() const  { return _ary; }
1179   const Type*    elem() const { return _ary-&gt;_elem; }
1180   const TypeInt* size() const { return _ary-&gt;_size; }
1181   bool      is_stable() const { return _ary-&gt;_stable; }
1182 
1183   bool is_autobox_cache() const { return _is_autobox_cache; }
1184 
1185   static const TypeAryPtr *make(PTR ptr, const TypeAry *ary, ciKlass* k, bool xk, int offset,
1186                                 int instance_id = InstanceBot,
1187                                 const TypePtr* speculative = NULL,
1188                                 int inline_depth = InlineDepthBottom);
1189   // Constant pointer to array
1190   static const TypeAryPtr *make(PTR ptr, ciObject* o, const TypeAry *ary, ciKlass* k, bool xk, int offset,
1191                                 int instance_id = InstanceBot,
1192                                 const TypePtr* speculative = NULL,
1193                                 int inline_depth = InlineDepthBottom, bool is_autobox_cache = false);
1194 
1195   // Return a &#39;ptr&#39; version of this type
1196   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1197 
1198   virtual const Type *cast_to_exactness(bool klass_is_exact) const;
1199 
1200   virtual const TypeOopPtr *cast_to_instance_id(int instance_id) const;
1201 
1202   virtual const TypeAryPtr* cast_to_size(const TypeInt* size) const;
1203   virtual const TypeInt* narrow_size_type(const TypeInt* size) const;
1204 
1205   virtual bool empty(void) const;        // TRUE if type is vacuous
1206   virtual const TypePtr *add_offset( intptr_t offset ) const;
1207 
1208   // Speculative type helper methods.
1209   virtual const Type* remove_speculative() const;
1210   virtual const TypePtr* with_inline_depth(int depth) const;
1211   virtual const TypePtr* with_instance_id(int instance_id) const;
1212 
1213   // the core of the computation of the meet of 2 types
1214   virtual const Type *xmeet_helper(const Type *t) const;
1215   virtual const Type *xdual() const;    // Compute dual right now.
1216 
1217   const TypeAryPtr* cast_to_stable(bool stable, int stable_dimension = 1) const;
1218   int stable_dimension() const;
1219 
1220   const TypeAryPtr* cast_to_autobox_cache(bool cache) const;
1221 
1222   static jint max_array_length(BasicType etype) ;
1223 
1224   // Convenience common pre-built types.
1225   static const TypeAryPtr *RANGE;
1226   static const TypeAryPtr *OOPS;
1227   static const TypeAryPtr *NARROWOOPS;
1228   static const TypeAryPtr *BYTES;
1229   static const TypeAryPtr *SHORTS;
1230   static const TypeAryPtr *CHARS;
1231   static const TypeAryPtr *INTS;
1232   static const TypeAryPtr *LONGS;
1233   static const TypeAryPtr *FLOATS;
1234   static const TypeAryPtr *DOUBLES;
1235   // selects one of the above:
1236   static const TypeAryPtr *get_array_body_type(BasicType elem) {
1237     assert((uint)elem &lt;= T_CONFLICT &amp;&amp; _array_body_type[elem] != NULL, &quot;bad elem type&quot;);
1238     return _array_body_type[elem];
1239   }
1240   static const TypeAryPtr *_array_body_type[T_CONFLICT+1];
1241   // sharpen the type of an int which is used as an array size
1242 #ifdef ASSERT
1243   // One type is interface, the other is oop
1244   virtual bool interface_vs_oop(const Type *t) const;
1245 #endif
1246 #ifndef PRODUCT
1247   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const; // Specialized per-Type dumping
1248 #endif
1249 };
1250 
1251 //------------------------------TypeMetadataPtr-------------------------------------
1252 // Some kind of metadata, either Method*, MethodData* or CPCacheOop
1253 class TypeMetadataPtr : public TypePtr {
1254 protected:
1255   TypeMetadataPtr(PTR ptr, ciMetadata* metadata, int offset);
1256   // Do not allow interface-vs.-noninterface joins to collapse to top.
1257   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
1258 public:
1259   virtual bool eq( const Type *t ) const;
1260   virtual int  hash() const;             // Type specific hashing
1261   virtual bool singleton(void) const;    // TRUE if type is a singleton
1262 
1263 private:
1264   ciMetadata*   _metadata;
1265 
1266 public:
1267   static const TypeMetadataPtr* make(PTR ptr, ciMetadata* m, int offset);
1268 
1269   static const TypeMetadataPtr* make(ciMethod* m);
1270   static const TypeMetadataPtr* make(ciMethodData* m);
1271 
1272   ciMetadata* metadata() const { return _metadata; }
1273 
1274   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1275 
1276   virtual const TypePtr *add_offset( intptr_t offset ) const;
1277 
1278   virtual const Type *xmeet( const Type *t ) const;
1279   virtual const Type *xdual() const;    // Compute dual right now.
1280 
1281   virtual intptr_t get_con() const;
1282 
1283   // Convenience common pre-built types.
1284   static const TypeMetadataPtr *BOTTOM;
1285 
1286 #ifndef PRODUCT
1287   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
1288 #endif
1289 };
1290 
1291 //------------------------------TypeKlassPtr-----------------------------------
1292 // Class of Java Klass pointers
1293 class TypeKlassPtr : public TypePtr {
1294   TypeKlassPtr( PTR ptr, ciKlass* klass, int offset );
1295 
1296 protected:
1297   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
1298  public:
1299   virtual bool eq( const Type *t ) const;
1300   virtual int hash() const;             // Type specific hashing
1301   virtual bool singleton(void) const;    // TRUE if type is a singleton
1302  private:
1303 
1304   static const TypeKlassPtr* make_from_klass_common(ciKlass* klass, bool klass_change, bool try_for_exact);
1305 
1306   ciKlass* _klass;
1307 
1308   // Does the type exclude subclasses of the klass?  (Inexact == polymorphic.)
1309   bool          _klass_is_exact;
1310 
1311 public:
1312   ciSymbol* name()  const { return klass()-&gt;name(); }
1313 
1314   ciKlass* klass() const { return  _klass; }
1315   bool klass_is_exact()    const { return _klass_is_exact; }
1316 
1317   bool  is_loaded() const { return klass()-&gt;is_loaded(); }
1318 
1319   // Creates a type given a klass. Correctly handles multi-dimensional arrays
1320   // Respects UseUniqueSubclasses.
1321   // If the klass is final, the resulting type will be exact.
1322   static const TypeKlassPtr* make_from_klass(ciKlass* klass) {
1323     return make_from_klass_common(klass, true, false);
1324   }
1325   // Same as before, but will produce an exact type, even if
1326   // the klass is not final, as long as it has exactly one implementation.
1327   static const TypeKlassPtr* make_from_klass_unique(ciKlass* klass) {
1328     return make_from_klass_common(klass, true, true);
1329   }
1330   // Same as before, but does not respects UseUniqueSubclasses.
1331   // Use this only for creating array element types.
1332   static const TypeKlassPtr* make_from_klass_raw(ciKlass* klass) {
1333     return make_from_klass_common(klass, false, false);
1334   }
1335 
1336   // Make a generic (unclassed) pointer to metadata.
1337   static const TypeKlassPtr* make(PTR ptr, int offset);
1338 
1339   // ptr to klass &#39;k&#39;
1340   static const TypeKlassPtr *make( ciKlass* k ) { return make( TypePtr::Constant, k, 0); }
1341   // ptr to klass &#39;k&#39; with offset
1342   static const TypeKlassPtr *make( ciKlass* k, int offset ) { return make( TypePtr::Constant, k, offset); }
1343   // ptr to klass &#39;k&#39; or sub-klass
1344   static const TypeKlassPtr *make( PTR ptr, ciKlass* k, int offset);
1345 
1346   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1347 
1348   virtual const Type *cast_to_exactness(bool klass_is_exact) const;
1349 
1350   // corresponding pointer to instance, for a given class
1351   const TypeOopPtr* as_instance_type() const;
1352 
1353   virtual const TypePtr *add_offset( intptr_t offset ) const;
1354   virtual const Type    *xmeet( const Type *t ) const;
1355   virtual const Type    *xdual() const;      // Compute dual right now.
1356 
1357   virtual intptr_t get_con() const;
1358 
1359   // Convenience common pre-built types.
1360   static const TypeKlassPtr* OBJECT; // Not-null object klass or below
1361   static const TypeKlassPtr* OBJECT_OR_NULL; // Maybe-null version of same
1362 #ifndef PRODUCT
1363   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const; // Specialized per-Type dumping
1364 #endif
1365 };
1366 
1367 class TypeNarrowPtr : public Type {
1368 protected:
1369   const TypePtr* _ptrtype; // Could be TypePtr::NULL_PTR
1370 
1371   TypeNarrowPtr(TYPES t, const TypePtr* ptrtype): Type(t),
1372                                                   _ptrtype(ptrtype) {
1373     assert(ptrtype-&gt;offset() == 0 ||
1374            ptrtype-&gt;offset() == OffsetBot ||
1375            ptrtype-&gt;offset() == OffsetTop, &quot;no real offsets&quot;);
1376   }
1377 
1378   virtual const TypeNarrowPtr *isa_same_narrowptr(const Type *t) const = 0;
1379   virtual const TypeNarrowPtr *is_same_narrowptr(const Type *t) const = 0;
1380   virtual const TypeNarrowPtr *make_same_narrowptr(const TypePtr *t) const = 0;
1381   virtual const TypeNarrowPtr *make_hash_same_narrowptr(const TypePtr *t) const = 0;
1382   // Do not allow interface-vs.-noninterface joins to collapse to top.
1383   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
1384 public:
1385   virtual bool eq( const Type *t ) const;
1386   virtual int  hash() const;             // Type specific hashing
1387   virtual bool singleton(void) const;    // TRUE if type is a singleton
1388 
1389   virtual const Type *xmeet( const Type *t ) const;
1390   virtual const Type *xdual() const;    // Compute dual right now.
1391 
1392   virtual intptr_t get_con() const;
1393 
1394   virtual bool empty(void) const;        // TRUE if type is vacuous
1395 
1396   // returns the equivalent ptr type for this compressed pointer
1397   const TypePtr *get_ptrtype() const {
1398     return _ptrtype;
1399   }
1400 
1401   bool is_known_instance() const {
1402     return _ptrtype-&gt;is_known_instance();
1403   }
1404 
1405 #ifndef PRODUCT
1406   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
1407 #endif
1408 };
1409 
1410 //------------------------------TypeNarrowOop----------------------------------
1411 // A compressed reference to some kind of Oop.  This type wraps around
1412 // a preexisting TypeOopPtr and forwards most of it&#39;s operations to
1413 // the underlying type.  It&#39;s only real purpose is to track the
1414 // oopness of the compressed oop value when we expose the conversion
1415 // between the normal and the compressed form.
1416 class TypeNarrowOop : public TypeNarrowPtr {
1417 protected:
1418   TypeNarrowOop( const TypePtr* ptrtype): TypeNarrowPtr(NarrowOop, ptrtype) {
1419   }
1420 
1421   virtual const TypeNarrowPtr *isa_same_narrowptr(const Type *t) const {
1422     return t-&gt;isa_narrowoop();
1423   }
1424 
1425   virtual const TypeNarrowPtr *is_same_narrowptr(const Type *t) const {
1426     return t-&gt;is_narrowoop();
1427   }
1428 
1429   virtual const TypeNarrowPtr *make_same_narrowptr(const TypePtr *t) const {
1430     return new TypeNarrowOop(t);
1431   }
1432 
1433   virtual const TypeNarrowPtr *make_hash_same_narrowptr(const TypePtr *t) const {
1434     return (const TypeNarrowPtr*)((new TypeNarrowOop(t))-&gt;hashcons());
1435   }
1436 
1437 public:
1438 
1439   static const TypeNarrowOop *make( const TypePtr* type);
1440 
1441   static const TypeNarrowOop* make_from_constant(ciObject* con, bool require_constant = false) {
1442     return make(TypeOopPtr::make_from_constant(con, require_constant));
1443   }
1444 
1445   static const TypeNarrowOop *BOTTOM;
1446   static const TypeNarrowOop *NULL_PTR;
1447 
1448   virtual const Type* remove_speculative() const;
1449   virtual const Type* cleanup_speculative() const;
1450 
1451 #ifndef PRODUCT
1452   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
1453 #endif
1454 };
1455 
1456 //------------------------------TypeNarrowKlass----------------------------------
1457 // A compressed reference to klass pointer.  This type wraps around a
1458 // preexisting TypeKlassPtr and forwards most of it&#39;s operations to
1459 // the underlying type.
1460 class TypeNarrowKlass : public TypeNarrowPtr {
1461 protected:
1462   TypeNarrowKlass( const TypePtr* ptrtype): TypeNarrowPtr(NarrowKlass, ptrtype) {
1463   }
1464 
1465   virtual const TypeNarrowPtr *isa_same_narrowptr(const Type *t) const {
1466     return t-&gt;isa_narrowklass();
1467   }
1468 
1469   virtual const TypeNarrowPtr *is_same_narrowptr(const Type *t) const {
1470     return t-&gt;is_narrowklass();
1471   }
1472 
1473   virtual const TypeNarrowPtr *make_same_narrowptr(const TypePtr *t) const {
1474     return new TypeNarrowKlass(t);
1475   }
1476 
1477   virtual const TypeNarrowPtr *make_hash_same_narrowptr(const TypePtr *t) const {
1478     return (const TypeNarrowPtr*)((new TypeNarrowKlass(t))-&gt;hashcons());
1479   }
1480 
1481 public:
1482   static const TypeNarrowKlass *make( const TypePtr* type);
1483 
1484   // static const TypeNarrowKlass *BOTTOM;
1485   static const TypeNarrowKlass *NULL_PTR;
1486 
1487 #ifndef PRODUCT
1488   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
1489 #endif
1490 };
1491 
1492 //------------------------------TypeFunc---------------------------------------
1493 // Class of Array Types
1494 class TypeFunc : public Type {
1495   TypeFunc( const TypeTuple *domain, const TypeTuple *range ) : Type(Function),  _domain(domain), _range(range) {}
1496   virtual bool eq( const Type *t ) const;
1497   virtual int  hash() const;             // Type specific hashing
1498   virtual bool singleton(void) const;    // TRUE if type is a singleton
1499   virtual bool empty(void) const;        // TRUE if type is vacuous
1500 
1501   const TypeTuple* const _domain;     // Domain of inputs
1502   const TypeTuple* const _range;      // Range of results
1503 
1504 public:
1505   // Constants are shared among ADLC and VM
1506   enum { Control    = AdlcVMDeps::Control,
1507          I_O        = AdlcVMDeps::I_O,
1508          Memory     = AdlcVMDeps::Memory,
1509          FramePtr   = AdlcVMDeps::FramePtr,
1510          ReturnAdr  = AdlcVMDeps::ReturnAdr,
1511          Parms      = AdlcVMDeps::Parms
1512   };
1513 
1514 
1515   // Accessors:
1516   const TypeTuple* domain() const { return _domain; }
1517   const TypeTuple* range()  const { return _range; }
1518 
1519   static const TypeFunc *make(ciMethod* method);
1520   static const TypeFunc *make(ciSignature signature, const Type* extra);
1521   static const TypeFunc *make(const TypeTuple* domain, const TypeTuple* range);
1522 
1523   virtual const Type *xmeet( const Type *t ) const;
1524   virtual const Type *xdual() const;    // Compute dual right now.
1525 
1526   BasicType return_type() const;
1527 
1528 #ifndef PRODUCT
1529   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const; // Specialized per-Type dumping
1530 #endif
1531   // Convenience common pre-built types.
1532 };
1533 
1534 //------------------------------accessors--------------------------------------
1535 inline bool Type::is_ptr_to_narrowoop() const {
1536 #ifdef _LP64
1537   return (isa_oopptr() != NULL &amp;&amp; is_oopptr()-&gt;is_ptr_to_narrowoop_nv());
1538 #else
1539   return false;
1540 #endif
1541 }
1542 
1543 inline bool Type::is_ptr_to_narrowklass() const {
1544 #ifdef _LP64
1545   return (isa_oopptr() != NULL &amp;&amp; is_oopptr()-&gt;is_ptr_to_narrowklass_nv());
1546 #else
1547   return false;
1548 #endif
1549 }
1550 
1551 inline float Type::getf() const {
1552   assert( _base == FloatCon, &quot;Not a FloatCon&quot; );
1553   return ((TypeF*)this)-&gt;_f;
1554 }
1555 
1556 inline double Type::getd() const {
1557   assert( _base == DoubleCon, &quot;Not a DoubleCon&quot; );
1558   return ((TypeD*)this)-&gt;_d;
1559 }
1560 
1561 inline const TypeInt *Type::is_int() const {
1562   assert( _base == Int, &quot;Not an Int&quot; );
1563   return (TypeInt*)this;
1564 }
1565 
1566 inline const TypeInt *Type::isa_int() const {
1567   return ( _base == Int ? (TypeInt*)this : NULL);
1568 }
1569 
1570 inline const TypeLong *Type::is_long() const {
1571   assert( _base == Long, &quot;Not a Long&quot; );
1572   return (TypeLong*)this;
1573 }
1574 
1575 inline const TypeLong *Type::isa_long() const {
1576   return ( _base == Long ? (TypeLong*)this : NULL);
1577 }
1578 
1579 inline const TypeF *Type::isa_float() const {
1580   return ((_base == FloatTop ||
1581            _base == FloatCon ||
1582            _base == FloatBot) ? (TypeF*)this : NULL);
1583 }
1584 
1585 inline const TypeF *Type::is_float_constant() const {
1586   assert( _base == FloatCon, &quot;Not a Float&quot; );
1587   return (TypeF*)this;
1588 }
1589 
1590 inline const TypeF *Type::isa_float_constant() const {
1591   return ( _base == FloatCon ? (TypeF*)this : NULL);
1592 }
1593 
1594 inline const TypeD *Type::isa_double() const {
1595   return ((_base == DoubleTop ||
1596            _base == DoubleCon ||
1597            _base == DoubleBot) ? (TypeD*)this : NULL);
1598 }
1599 
1600 inline const TypeD *Type::is_double_constant() const {
1601   assert( _base == DoubleCon, &quot;Not a Double&quot; );
1602   return (TypeD*)this;
1603 }
1604 
1605 inline const TypeD *Type::isa_double_constant() const {
1606   return ( _base == DoubleCon ? (TypeD*)this : NULL);
1607 }
1608 
1609 inline const TypeTuple *Type::is_tuple() const {
1610   assert( _base == Tuple, &quot;Not a Tuple&quot; );
1611   return (TypeTuple*)this;
1612 }
1613 
1614 inline const TypeAry *Type::is_ary() const {
1615   assert( _base == Array , &quot;Not an Array&quot; );
1616   return (TypeAry*)this;
1617 }
1618 
1619 inline const TypeAry *Type::isa_ary() const {
1620   return ((_base == Array) ? (TypeAry*)this : NULL);
1621 }
1622 
1623 inline const TypeVect *Type::is_vect() const {
1624   assert( _base &gt;= VectorS &amp;&amp; _base &lt;= VectorZ, &quot;Not a Vector&quot; );
1625   return (TypeVect*)this;
1626 }
1627 
1628 inline const TypeVect *Type::isa_vect() const {
1629   return (_base &gt;= VectorS &amp;&amp; _base &lt;= VectorZ) ? (TypeVect*)this : NULL;
1630 }
1631 
1632 inline const TypePtr *Type::is_ptr() const {
1633   // AnyPtr is the first Ptr and KlassPtr the last, with no non-ptrs between.
1634   assert(_base &gt;= AnyPtr &amp;&amp; _base &lt;= KlassPtr, &quot;Not a pointer&quot;);
1635   return (TypePtr*)this;
1636 }
1637 
1638 inline const TypePtr *Type::isa_ptr() const {
1639   // AnyPtr is the first Ptr and KlassPtr the last, with no non-ptrs between.
1640   return (_base &gt;= AnyPtr &amp;&amp; _base &lt;= KlassPtr) ? (TypePtr*)this : NULL;
1641 }
1642 
1643 inline const TypeOopPtr *Type::is_oopptr() const {
1644   // OopPtr is the first and KlassPtr the last, with no non-oops between.
1645   assert(_base &gt;= OopPtr &amp;&amp; _base &lt;= AryPtr, &quot;Not a Java pointer&quot; ) ;
1646   return (TypeOopPtr*)this;
1647 }
1648 
1649 inline const TypeOopPtr *Type::isa_oopptr() const {
1650   // OopPtr is the first and KlassPtr the last, with no non-oops between.
1651   return (_base &gt;= OopPtr &amp;&amp; _base &lt;= AryPtr) ? (TypeOopPtr*)this : NULL;
1652 }
1653 
1654 inline const TypeRawPtr *Type::isa_rawptr() const {
1655   return (_base == RawPtr) ? (TypeRawPtr*)this : NULL;
1656 }
1657 
1658 inline const TypeRawPtr *Type::is_rawptr() const {
1659   assert( _base == RawPtr, &quot;Not a raw pointer&quot; );
1660   return (TypeRawPtr*)this;
1661 }
1662 
1663 inline const TypeInstPtr *Type::isa_instptr() const {
1664   return (_base == InstPtr) ? (TypeInstPtr*)this : NULL;
1665 }
1666 
1667 inline const TypeInstPtr *Type::is_instptr() const {
1668   assert( _base == InstPtr, &quot;Not an object pointer&quot; );
1669   return (TypeInstPtr*)this;
1670 }
1671 
1672 inline const TypeAryPtr *Type::isa_aryptr() const {
1673   return (_base == AryPtr) ? (TypeAryPtr*)this : NULL;
1674 }
1675 
1676 inline const TypeAryPtr *Type::is_aryptr() const {
1677   assert( _base == AryPtr, &quot;Not an array pointer&quot; );
1678   return (TypeAryPtr*)this;
1679 }
1680 
1681 inline const TypeNarrowOop *Type::is_narrowoop() const {
1682   // OopPtr is the first and KlassPtr the last, with no non-oops between.
1683   assert(_base == NarrowOop, &quot;Not a narrow oop&quot; ) ;
1684   return (TypeNarrowOop*)this;
1685 }
1686 
1687 inline const TypeNarrowOop *Type::isa_narrowoop() const {
1688   // OopPtr is the first and KlassPtr the last, with no non-oops between.
1689   return (_base == NarrowOop) ? (TypeNarrowOop*)this : NULL;
1690 }
1691 
1692 inline const TypeNarrowKlass *Type::is_narrowklass() const {
1693   assert(_base == NarrowKlass, &quot;Not a narrow oop&quot; ) ;
1694   return (TypeNarrowKlass*)this;
1695 }
1696 
1697 inline const TypeNarrowKlass *Type::isa_narrowklass() const {
1698   return (_base == NarrowKlass) ? (TypeNarrowKlass*)this : NULL;
1699 }
1700 
1701 inline const TypeMetadataPtr *Type::is_metadataptr() const {
1702   // MetadataPtr is the first and CPCachePtr the last
1703   assert(_base == MetadataPtr, &quot;Not a metadata pointer&quot; ) ;
1704   return (TypeMetadataPtr*)this;
1705 }
1706 
1707 inline const TypeMetadataPtr *Type::isa_metadataptr() const {
1708   return (_base == MetadataPtr) ? (TypeMetadataPtr*)this : NULL;
1709 }
1710 
1711 inline const TypeKlassPtr *Type::isa_klassptr() const {
1712   return (_base == KlassPtr) ? (TypeKlassPtr*)this : NULL;
1713 }
1714 
1715 inline const TypeKlassPtr *Type::is_klassptr() const {
1716   assert( _base == KlassPtr, &quot;Not a klass pointer&quot; );
1717   return (TypeKlassPtr*)this;
1718 }
1719 
1720 inline const TypePtr* Type::make_ptr() const {
1721   return (_base == NarrowOop) ? is_narrowoop()-&gt;get_ptrtype() :
1722                               ((_base == NarrowKlass) ? is_narrowklass()-&gt;get_ptrtype() :
1723                                                        isa_ptr());
1724 }
1725 
1726 inline const TypeOopPtr* Type::make_oopptr() const {
1727   return (_base == NarrowOop) ? is_narrowoop()-&gt;get_ptrtype()-&gt;isa_oopptr() : isa_oopptr();
1728 }
1729 
1730 inline const TypeNarrowOop* Type::make_narrowoop() const {
1731   return (_base == NarrowOop) ? is_narrowoop() :
1732                                 (isa_ptr() ? TypeNarrowOop::make(is_ptr()) : NULL);
1733 }
1734 
1735 inline const TypeNarrowKlass* Type::make_narrowklass() const {
1736   return (_base == NarrowKlass) ? is_narrowklass() :
1737                                   (isa_ptr() ? TypeNarrowKlass::make(is_ptr()) : NULL);
1738 }
1739 
1740 inline bool Type::is_floatingpoint() const {
1741   if( (_base == FloatCon)  || (_base == FloatBot) ||
1742       (_base == DoubleCon) || (_base == DoubleBot) )
1743     return true;
1744   return false;
1745 }
1746 
1747 inline bool Type::is_ptr_to_boxing_obj() const {
1748   const TypeInstPtr* tp = isa_instptr();
1749   return (tp != NULL) &amp;&amp; (tp-&gt;offset() == 0) &amp;&amp;
1750          tp-&gt;klass()-&gt;is_instance_klass()  &amp;&amp;
1751          tp-&gt;klass()-&gt;as_instance_klass()-&gt;is_box_klass();
1752 }
1753 
1754 
1755 // ===============================================================
1756 // Things that need to be 64-bits in the 64-bit build but
1757 // 32-bits in the 32-bit build.  Done this way to get full
1758 // optimization AND strong typing.
1759 #ifdef _LP64
1760 
1761 // For type queries and asserts
1762 #define is_intptr_t  is_long
1763 #define isa_intptr_t isa_long
1764 #define find_intptr_t_type find_long_type
1765 #define find_intptr_t_con  find_long_con
1766 #define TypeX        TypeLong
1767 #define Type_X       Type::Long
1768 #define TypeX_X      TypeLong::LONG
1769 #define TypeX_ZERO   TypeLong::ZERO
1770 // For &#39;ideal_reg&#39; machine registers
1771 #define Op_RegX      Op_RegL
1772 // For phase-&gt;intcon variants
1773 #define MakeConX     longcon
1774 #define ConXNode     ConLNode
1775 // For array index arithmetic
1776 #define MulXNode     MulLNode
1777 #define AndXNode     AndLNode
1778 #define OrXNode      OrLNode
1779 #define CmpXNode     CmpLNode
1780 #define SubXNode     SubLNode
1781 #define LShiftXNode  LShiftLNode
1782 // For object size computation:
1783 #define AddXNode     AddLNode
1784 #define RShiftXNode  RShiftLNode
1785 // For card marks and hashcodes
1786 #define URShiftXNode URShiftLNode
1787 // UseOptoBiasInlining
1788 #define XorXNode     XorLNode
1789 #define StoreXConditionalNode StoreLConditionalNode
1790 #define LoadXNode    LoadLNode
1791 #define StoreXNode   StoreLNode
1792 // Opcodes
1793 #define Op_LShiftX   Op_LShiftL
1794 #define Op_AndX      Op_AndL
1795 #define Op_AddX      Op_AddL
1796 #define Op_SubX      Op_SubL
1797 #define Op_XorX      Op_XorL
1798 #define Op_URShiftX  Op_URShiftL
1799 #define Op_LoadX     Op_LoadL
1800 // conversions
1801 #define ConvI2X(x)   ConvI2L(x)
1802 #define ConvL2X(x)   (x)
1803 #define ConvX2I(x)   ConvL2I(x)
1804 #define ConvX2L(x)   (x)
1805 #define ConvX2UL(x)  (x)
1806 
1807 #else
1808 
1809 // For type queries and asserts
1810 #define is_intptr_t  is_int
1811 #define isa_intptr_t isa_int
1812 #define find_intptr_t_type find_int_type
1813 #define find_intptr_t_con  find_int_con
1814 #define TypeX        TypeInt
1815 #define Type_X       Type::Int
1816 #define TypeX_X      TypeInt::INT
1817 #define TypeX_ZERO   TypeInt::ZERO
1818 // For &#39;ideal_reg&#39; machine registers
1819 #define Op_RegX      Op_RegI
1820 // For phase-&gt;intcon variants
1821 #define MakeConX     intcon
1822 #define ConXNode     ConINode
1823 // For array index arithmetic
1824 #define MulXNode     MulINode
1825 #define AndXNode     AndINode
1826 #define OrXNode      OrINode
1827 #define CmpXNode     CmpINode
1828 #define SubXNode     SubINode
1829 #define LShiftXNode  LShiftINode
1830 // For object size computation:
1831 #define AddXNode     AddINode
1832 #define RShiftXNode  RShiftINode
1833 // For card marks and hashcodes
1834 #define URShiftXNode URShiftINode
1835 // UseOptoBiasInlining
1836 #define XorXNode     XorINode
1837 #define StoreXConditionalNode StoreIConditionalNode
1838 #define LoadXNode    LoadINode
1839 #define StoreXNode   StoreINode
1840 // Opcodes
1841 #define Op_LShiftX   Op_LShiftI
1842 #define Op_AndX      Op_AndI
1843 #define Op_AddX      Op_AddI
1844 #define Op_SubX      Op_SubI
1845 #define Op_XorX      Op_XorI
1846 #define Op_URShiftX  Op_URShiftI
1847 #define Op_LoadX     Op_LoadI
1848 // conversions
1849 #define ConvI2X(x)   (x)
1850 #define ConvL2X(x)   ConvL2I(x)
1851 #define ConvX2I(x)   (x)
1852 #define ConvX2L(x)   ConvI2L(x)
1853 #define ConvX2UL(x)  ConvI2UL(x)
1854 
1855 #endif
1856 
1857 #endif // SHARE_OPTO_TYPE_HPP
    </pre>
  </body>
</html>
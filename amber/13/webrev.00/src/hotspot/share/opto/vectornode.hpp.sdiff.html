<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/vectornode.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="vectornode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../prims/jni.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/vectornode.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  34 class VectorNode : public TypeNode {
  35  public:
  36 
  37   VectorNode(Node* n1, const TypeVect* vt) : TypeNode(vt, 2) {
  38     init_class_id(Class_Vector);
  39     init_req(1, n1);
  40   }
  41   VectorNode(Node* n1, Node* n2, const TypeVect* vt) : TypeNode(vt, 3) {
  42     init_class_id(Class_Vector);
  43     init_req(1, n1);
  44     init_req(2, n2);
  45   }
  46 
  47   VectorNode(Node* n1, Node* n2, Node* n3, const TypeVect* vt) : TypeNode(vt, 4) {
  48     init_class_id(Class_Vector);
  49     init_req(1, n1);
  50     init_req(2, n2);
  51     init_req(3, n3);
  52   }
  53 








  54   const TypeVect* vect_type() const { return type()-&gt;is_vect(); }
  55   uint length() const { return vect_type()-&gt;length(); } // Vector length
  56   uint length_in_bytes() const { return vect_type()-&gt;length_in_bytes(); }
  57 
  58   virtual int Opcode() const;
  59 
  60   virtual uint ideal_reg() const { return Matcher::vector_ideal_reg(vect_type()-&gt;length_in_bytes()); }
  61 
  62   static VectorNode* scalar2vector(Node* s, uint vlen, const Type* opd_t);
  63   static VectorNode* shift_count(Node* shift, Node* cnt, uint vlen, BasicType bt);
  64   static VectorNode* make(int opc, Node* n1, Node* n2, uint vlen, BasicType bt);
  65   static VectorNode* make(int opc, Node* n1, Node* n2, Node* n3, uint vlen, BasicType bt);
  66 
  67   static int  opcode(int opc, BasicType bt);
  68   static bool implemented(int opc, uint vlen, BasicType bt);
  69   static bool is_shift(Node* n);
  70   static bool is_type_transition_short_to_int(Node* n);
  71   static bool is_type_transition_to_int(Node* n);
  72   static bool is_muladds2i(Node* n);
  73   static bool is_roundopD(Node * n);
  74   static bool is_invariant_vector(Node* n);



  75   // [Start, end) half-open range defining which operands are vectors
  76   static void vector_operands(Node* n, uint* start, uint* end);
  77 
  78   static bool is_vector_shift(int opc);
  79   static bool is_vector_shift_count(int opc);
  80 
  81   static bool is_vector_shift(Node* n) {
  82     return is_vector_shift(n-&gt;Opcode());
  83   }
  84   static bool is_vector_shift_count(Node* n) {
  85     return is_vector_shift_count(n-&gt;Opcode());
  86   }
  87 };
  88 
  89 //===========================Vector=ALU=Operations=============================
  90 
  91 //------------------------------AddVBNode--------------------------------------
  92 // Vector add byte
  93 class AddVBNode : public VectorNode {
  94  public:
</pre>
<hr />
<pre>
 128   virtual int Opcode() const;
 129 };
 130 
 131 //------------------------------AddVDNode--------------------------------------
 132 // Vector add double
 133 class AddVDNode : public VectorNode {
 134 public:
 135   AddVDNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}
 136   virtual int Opcode() const;
 137 };
 138 
 139 //------------------------------ReductionNode------------------------------------
 140 // Perform reduction of a vector
 141 class ReductionNode : public Node {
 142  public:
 143   ReductionNode(Node *ctrl, Node* in1, Node* in2) : Node(ctrl, in1, in2) {}
 144 
 145   static ReductionNode* make(int opc, Node *ctrl, Node* in1, Node* in2, BasicType bt);
 146   static int  opcode(int opc, BasicType bt);
 147   static bool implemented(int opc, uint vlen, BasicType bt);









 148 };
 149 
 150 //------------------------------AddReductionVINode--------------------------------------
 151 // Vector add int as a reduction
 152 class AddReductionVINode : public ReductionNode {
 153 public:
 154   AddReductionVINode(Node * ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
 155   virtual int Opcode() const;
 156   virtual const Type* bottom_type() const { return TypeInt::INT; }
 157   virtual uint ideal_reg() const { return Op_RegI; }
 158 };
 159 
 160 //------------------------------AddReductionVLNode--------------------------------------
 161 // Vector add long as a reduction
 162 class AddReductionVLNode : public ReductionNode {
 163 public:
 164   AddReductionVLNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
 165   virtual int Opcode() const;
 166   virtual const Type* bottom_type() const { return TypeLong::LONG; }
 167   virtual uint ideal_reg() const { return Op_RegL; }
</pre>
<hr />
<pre>
 596   AndVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
 597   virtual int Opcode() const;
 598 };
 599 
 600 //------------------------------OrVNode---------------------------------------
 601 // Vector or integer
 602 class OrVNode : public VectorNode {
 603  public:
 604   OrVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
 605   virtual int Opcode() const;
 606 };
 607 
 608 //------------------------------XorVNode---------------------------------------
 609 // Vector xor integer
 610 class XorVNode : public VectorNode {
 611  public:
 612   XorVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
 613   virtual int Opcode() const;
 614 };
 615 
























 616 //------------------------------MinVNode--------------------------------------
 617 // Vector min
 618 class MinVNode : public VectorNode {
 619 public:
 620   MinVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}
 621   virtual int Opcode() const;
 622 };
 623 
 624 //------------------------------MaxVNode--------------------------------------
 625 // Vector max
 626 class MaxVNode : public VectorNode {
 627 public:
 628   MaxVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}
 629   virtual int Opcode() const;
 630 };
 631 
 632 //------------------------------MinReductionVNode--------------------------------------
 633 // Vector min as a reduction
 634 class MinReductionVNode : public ReductionNode {
 635 public:
 636   MinReductionVNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
 637   virtual int Opcode() const;
<span class="line-removed"> 638   virtual const Type* bottom_type() const {</span>
<span class="line-removed"> 639     BasicType bt = in(1)-&gt;bottom_type()-&gt;basic_type();</span>
<span class="line-removed"> 640     if (bt == T_FLOAT) {</span>
<span class="line-removed"> 641       return Type::FLOAT;</span>
<span class="line-removed"> 642     } else if (bt == T_DOUBLE) {</span>
<span class="line-removed"> 643       return Type::DOUBLE;</span>
<span class="line-removed"> 644     }</span>
<span class="line-removed"> 645     assert(false, &quot;unsupported basic type&quot;);</span>
<span class="line-removed"> 646     return NULL;</span>
<span class="line-removed"> 647   }</span>
<span class="line-removed"> 648   virtual uint ideal_reg() const {</span>
<span class="line-removed"> 649     BasicType bt = in(1)-&gt;bottom_type()-&gt;basic_type();</span>
<span class="line-removed"> 650     if (bt == T_FLOAT) {</span>
<span class="line-removed"> 651       return Op_RegF;</span>
<span class="line-removed"> 652     } else if (bt == T_DOUBLE) {</span>
<span class="line-removed"> 653       return Op_RegD;</span>
<span class="line-removed"> 654     }</span>
<span class="line-removed"> 655     assert(false, &quot;unsupported basic type&quot;);</span>
<span class="line-removed"> 656     return 0;</span>
<span class="line-removed"> 657   }</span>
 658 };
 659 
 660 //------------------------------MaxReductionVNode--------------------------------------
 661 // Vector max as a reduction
 662 class MaxReductionVNode : public ReductionNode {
 663 public:
 664   MaxReductionVNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
 665   virtual int Opcode() const;
<span class="line-removed"> 666   virtual const Type* bottom_type() const {</span>
<span class="line-removed"> 667     BasicType bt = in(1)-&gt;bottom_type()-&gt;basic_type();</span>
<span class="line-removed"> 668     if (bt == T_FLOAT) {</span>
<span class="line-removed"> 669       return Type::FLOAT;</span>
<span class="line-removed"> 670     } else {</span>
<span class="line-removed"> 671       return Type::DOUBLE;</span>
<span class="line-removed"> 672     }</span>
<span class="line-removed"> 673     assert(false, &quot;unsupported basic type&quot;);</span>
<span class="line-removed"> 674     return NULL;</span>
<span class="line-removed"> 675   }</span>
<span class="line-removed"> 676   virtual uint ideal_reg() const {</span>
<span class="line-removed"> 677     BasicType bt = in(1)-&gt;bottom_type()-&gt;basic_type();</span>
<span class="line-removed"> 678     if (bt == T_FLOAT) {</span>
<span class="line-removed"> 679       return Op_RegF;</span>
<span class="line-removed"> 680     } else {</span>
<span class="line-removed"> 681       return Op_RegD;</span>
<span class="line-removed"> 682     }</span>
<span class="line-removed"> 683     assert(false, &quot;unsupported basic type&quot;);</span>
<span class="line-removed"> 684     return 0;</span>
<span class="line-removed"> 685   }</span>
 686 };
 687 
 688 //================================= M E M O R Y ===============================
 689 
 690 //------------------------------LoadVectorNode---------------------------------
 691 // Load Vector from memory
 692 class LoadVectorNode : public LoadNode {
 693  public:
 694   LoadVectorNode(Node* c, Node* mem, Node* adr, const TypePtr* at, const TypeVect* vt, ControlDependency control_dependency = LoadNode::DependsOnlyOnTest)
 695     : LoadNode(c, mem, adr, at, vt, MemNode::unordered, control_dependency) {
 696     init_class_id(Class_LoadVector);
 697     set_mismatched_access();
 698   }
 699 
 700   const TypeVect* vect_type() const { return type()-&gt;is_vect(); }
 701   uint length() const { return vect_type()-&gt;length(); } // Vector length
 702 
 703   virtual int Opcode() const;
 704 
 705   virtual uint ideal_reg() const  { return Matcher::vector_ideal_reg(memory_size()); }
</pre>
<hr />
<pre>
 972 // Extract a double from a vector at position &quot;pos&quot;
 973 class ExtractDNode : public ExtractNode {
 974  public:
 975   ExtractDNode(Node* src, ConINode* pos) : ExtractNode(src, pos) {}
 976   virtual int Opcode() const;
 977   virtual const Type *bottom_type() const { return Type::DOUBLE; }
 978   virtual uint ideal_reg() const { return Op_RegD; }
 979 };
 980 
 981 //------------------------------SetVectMaskINode-------------------------------
 982 // Provide a mask for a vector predicate machine
 983 class SetVectMaskINode : public Node {
 984 public:
 985   SetVectMaskINode(Node *c, Node *in1) : Node(c, in1) {}
 986   virtual int Opcode() const;
 987   const Type *bottom_type() const { return TypeInt::INT; }
 988   virtual uint ideal_reg() const { return Op_RegI; }
 989   virtual const Type *Value(PhaseGVN *phase) const { return TypeInt::INT; }
 990 };
 991 













 992 #endif // SHARE_OPTO_VECTORNODE_HPP
</pre>
</td>
<td>
<hr />
<pre>
  34 class VectorNode : public TypeNode {
  35  public:
  36 
  37   VectorNode(Node* n1, const TypeVect* vt) : TypeNode(vt, 2) {
  38     init_class_id(Class_Vector);
  39     init_req(1, n1);
  40   }
  41   VectorNode(Node* n1, Node* n2, const TypeVect* vt) : TypeNode(vt, 3) {
  42     init_class_id(Class_Vector);
  43     init_req(1, n1);
  44     init_req(2, n2);
  45   }
  46 
  47   VectorNode(Node* n1, Node* n2, Node* n3, const TypeVect* vt) : TypeNode(vt, 4) {
  48     init_class_id(Class_Vector);
  49     init_req(1, n1);
  50     init_req(2, n2);
  51     init_req(3, n3);
  52   }
  53 
<span class="line-added">  54   VectorNode(Node *n0, Node* n1, Node* n2, Node* n3, const TypeVect* vt) : TypeNode(vt, 5) {</span>
<span class="line-added">  55     init_class_id(Class_Vector);</span>
<span class="line-added">  56     init_req(1, n0);</span>
<span class="line-added">  57     init_req(2, n1);</span>
<span class="line-added">  58     init_req(3, n2);</span>
<span class="line-added">  59     init_req(4, n3);</span>
<span class="line-added">  60   }</span>
<span class="line-added">  61 </span>
  62   const TypeVect* vect_type() const { return type()-&gt;is_vect(); }
  63   uint length() const { return vect_type()-&gt;length(); } // Vector length
  64   uint length_in_bytes() const { return vect_type()-&gt;length_in_bytes(); }
  65 
  66   virtual int Opcode() const;
  67 
  68   virtual uint ideal_reg() const { return Matcher::vector_ideal_reg(vect_type()-&gt;length_in_bytes()); }
  69 
  70   static VectorNode* scalar2vector(Node* s, uint vlen, const Type* opd_t);
  71   static VectorNode* shift_count(Node* shift, Node* cnt, uint vlen, BasicType bt);
  72   static VectorNode* make(int opc, Node* n1, Node* n2, uint vlen, BasicType bt);
  73   static VectorNode* make(int opc, Node* n1, Node* n2, Node* n3, uint vlen, BasicType bt);
  74 
  75   static int  opcode(int opc, BasicType bt);
  76   static bool implemented(int opc, uint vlen, BasicType bt);
  77   static bool is_shift(Node* n);
  78   static bool is_type_transition_short_to_int(Node* n);
  79   static bool is_type_transition_to_int(Node* n);
  80   static bool is_muladds2i(Node* n);
  81   static bool is_roundopD(Node * n);
  82   static bool is_invariant_vector(Node* n);
<span class="line-added">  83   static bool is_all_ones_vector(Node* n);</span>
<span class="line-added">  84   static bool is_vector_bitwise_not_pattern(Node* n);</span>
<span class="line-added">  85 </span>
  86   // [Start, end) half-open range defining which operands are vectors
  87   static void vector_operands(Node* n, uint* start, uint* end);
  88 
  89   static bool is_vector_shift(int opc);
  90   static bool is_vector_shift_count(int opc);
  91 
  92   static bool is_vector_shift(Node* n) {
  93     return is_vector_shift(n-&gt;Opcode());
  94   }
  95   static bool is_vector_shift_count(Node* n) {
  96     return is_vector_shift_count(n-&gt;Opcode());
  97   }
  98 };
  99 
 100 //===========================Vector=ALU=Operations=============================
 101 
 102 //------------------------------AddVBNode--------------------------------------
 103 // Vector add byte
 104 class AddVBNode : public VectorNode {
 105  public:
</pre>
<hr />
<pre>
 139   virtual int Opcode() const;
 140 };
 141 
 142 //------------------------------AddVDNode--------------------------------------
 143 // Vector add double
 144 class AddVDNode : public VectorNode {
 145 public:
 146   AddVDNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}
 147   virtual int Opcode() const;
 148 };
 149 
 150 //------------------------------ReductionNode------------------------------------
 151 // Perform reduction of a vector
 152 class ReductionNode : public Node {
 153  public:
 154   ReductionNode(Node *ctrl, Node* in1, Node* in2) : Node(ctrl, in1, in2) {}
 155 
 156   static ReductionNode* make(int opc, Node *ctrl, Node* in1, Node* in2, BasicType bt);
 157   static int  opcode(int opc, BasicType bt);
 158   static bool implemented(int opc, uint vlen, BasicType bt);
<span class="line-added"> 159 </span>
<span class="line-added"> 160   virtual const Type* bottom_type() const {</span>
<span class="line-added"> 161     BasicType vbt = in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;element_basic_type();</span>
<span class="line-added"> 162     return Type::get_const_basic_type(vbt);</span>
<span class="line-added"> 163   }</span>
<span class="line-added"> 164 </span>
<span class="line-added"> 165   virtual uint ideal_reg() const {</span>
<span class="line-added"> 166     return bottom_type()-&gt;ideal_reg();</span>
<span class="line-added"> 167   }</span>
 168 };
 169 
 170 //------------------------------AddReductionVINode--------------------------------------
 171 // Vector add int as a reduction
 172 class AddReductionVINode : public ReductionNode {
 173 public:
 174   AddReductionVINode(Node * ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
 175   virtual int Opcode() const;
 176   virtual const Type* bottom_type() const { return TypeInt::INT; }
 177   virtual uint ideal_reg() const { return Op_RegI; }
 178 };
 179 
 180 //------------------------------AddReductionVLNode--------------------------------------
 181 // Vector add long as a reduction
 182 class AddReductionVLNode : public ReductionNode {
 183 public:
 184   AddReductionVLNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
 185   virtual int Opcode() const;
 186   virtual const Type* bottom_type() const { return TypeLong::LONG; }
 187   virtual uint ideal_reg() const { return Op_RegL; }
</pre>
<hr />
<pre>
 616   AndVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
 617   virtual int Opcode() const;
 618 };
 619 
 620 //------------------------------OrVNode---------------------------------------
 621 // Vector or integer
 622 class OrVNode : public VectorNode {
 623  public:
 624   OrVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
 625   virtual int Opcode() const;
 626 };
 627 
 628 //------------------------------XorVNode---------------------------------------
 629 // Vector xor integer
 630 class XorVNode : public VectorNode {
 631  public:
 632   XorVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
 633   virtual int Opcode() const;
 634 };
 635 
<span class="line-added"> 636 //------------------------------AndReductionVNode--------------------------------------</span>
<span class="line-added"> 637 // Vector and int, long as a reduction</span>
<span class="line-added"> 638 class AndReductionVNode : public ReductionNode {</span>
<span class="line-added"> 639 public:</span>
<span class="line-added"> 640   AndReductionVNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}</span>
<span class="line-added"> 641   virtual int Opcode() const;</span>
<span class="line-added"> 642 };</span>
<span class="line-added"> 643 </span>
<span class="line-added"> 644 //------------------------------OrReductionVNode--------------------------------------</span>
<span class="line-added"> 645 // Vector or int, long as a reduction</span>
<span class="line-added"> 646 class OrReductionVNode : public ReductionNode {</span>
<span class="line-added"> 647 public:</span>
<span class="line-added"> 648   OrReductionVNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}</span>
<span class="line-added"> 649   virtual int Opcode() const;</span>
<span class="line-added"> 650 };</span>
<span class="line-added"> 651 </span>
<span class="line-added"> 652 //------------------------------XorReductionVNode--------------------------------------</span>
<span class="line-added"> 653 // Vector xor int, long as a reduction</span>
<span class="line-added"> 654 class XorReductionVNode : public ReductionNode {</span>
<span class="line-added"> 655 public:</span>
<span class="line-added"> 656   XorReductionVNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}</span>
<span class="line-added"> 657   virtual int Opcode() const;</span>
<span class="line-added"> 658 };</span>
<span class="line-added"> 659 </span>
 660 //------------------------------MinVNode--------------------------------------
 661 // Vector min
 662 class MinVNode : public VectorNode {
 663 public:
 664   MinVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}
 665   virtual int Opcode() const;
 666 };
 667 
 668 //------------------------------MaxVNode--------------------------------------
 669 // Vector max
 670 class MaxVNode : public VectorNode {
 671 public:
 672   MaxVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}
 673   virtual int Opcode() const;
 674 };
 675 
 676 //------------------------------MinReductionVNode--------------------------------------
 677 // Vector min as a reduction
 678 class MinReductionVNode : public ReductionNode {
 679 public:
 680   MinReductionVNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
 681   virtual int Opcode() const;




















 682 };
 683 
 684 //------------------------------MaxReductionVNode--------------------------------------
 685 // Vector max as a reduction
 686 class MaxReductionVNode : public ReductionNode {
 687 public:
 688   MaxReductionVNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
 689   virtual int Opcode() const;




















 690 };
 691 
 692 //================================= M E M O R Y ===============================
 693 
 694 //------------------------------LoadVectorNode---------------------------------
 695 // Load Vector from memory
 696 class LoadVectorNode : public LoadNode {
 697  public:
 698   LoadVectorNode(Node* c, Node* mem, Node* adr, const TypePtr* at, const TypeVect* vt, ControlDependency control_dependency = LoadNode::DependsOnlyOnTest)
 699     : LoadNode(c, mem, adr, at, vt, MemNode::unordered, control_dependency) {
 700     init_class_id(Class_LoadVector);
 701     set_mismatched_access();
 702   }
 703 
 704   const TypeVect* vect_type() const { return type()-&gt;is_vect(); }
 705   uint length() const { return vect_type()-&gt;length(); } // Vector length
 706 
 707   virtual int Opcode() const;
 708 
 709   virtual uint ideal_reg() const  { return Matcher::vector_ideal_reg(memory_size()); }
</pre>
<hr />
<pre>
 976 // Extract a double from a vector at position &quot;pos&quot;
 977 class ExtractDNode : public ExtractNode {
 978  public:
 979   ExtractDNode(Node* src, ConINode* pos) : ExtractNode(src, pos) {}
 980   virtual int Opcode() const;
 981   virtual const Type *bottom_type() const { return Type::DOUBLE; }
 982   virtual uint ideal_reg() const { return Op_RegD; }
 983 };
 984 
 985 //------------------------------SetVectMaskINode-------------------------------
 986 // Provide a mask for a vector predicate machine
 987 class SetVectMaskINode : public Node {
 988 public:
 989   SetVectMaskINode(Node *c, Node *in1) : Node(c, in1) {}
 990   virtual int Opcode() const;
 991   const Type *bottom_type() const { return TypeInt::INT; }
 992   virtual uint ideal_reg() const { return Op_RegI; }
 993   virtual const Type *Value(PhaseGVN *phase) const { return TypeInt::INT; }
 994 };
 995 
<span class="line-added"> 996 //------------------------------MacroLogicVNode-------------------------------</span>
<span class="line-added"> 997 // Vector logical operations packing node.</span>
<span class="line-added"> 998 class MacroLogicVNode : public VectorNode {</span>
<span class="line-added"> 999 private:</span>
<span class="line-added">1000   MacroLogicVNode(Node* in1, Node* in2, Node* in3, Node* fn, const TypeVect* vt)</span>
<span class="line-added">1001   : VectorNode(in1, in2, in3, fn, vt) {}</span>
<span class="line-added">1002 </span>
<span class="line-added">1003 public:</span>
<span class="line-added">1004   virtual int Opcode() const;</span>
<span class="line-added">1005 </span>
<span class="line-added">1006   static MacroLogicVNode* make(PhaseGVN&amp; igvn, Node* in1, Node* in2, Node* in3, uint truth_table, const TypeVect* vt);</span>
<span class="line-added">1007 };</span>
<span class="line-added">1008 </span>
1009 #endif // SHARE_OPTO_VECTORNODE_HPP
</pre>
</td>
</tr>
</table>
<center><a href="vectornode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../prims/jni.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
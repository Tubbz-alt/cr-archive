<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/loopTransform.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;compiler/compileLog.hpp&quot;
  27 #include &quot;memory/allocation.inline.hpp&quot;
  28 #include &quot;opto/addnode.hpp&quot;
  29 #include &quot;opto/callnode.hpp&quot;
  30 #include &quot;opto/castnode.hpp&quot;
  31 #include &quot;opto/connode.hpp&quot;
  32 #include &quot;opto/convertnode.hpp&quot;
  33 #include &quot;opto/divnode.hpp&quot;
  34 #include &quot;opto/loopnode.hpp&quot;
  35 #include &quot;opto/mulnode.hpp&quot;
  36 #include &quot;opto/movenode.hpp&quot;
  37 #include &quot;opto/opaquenode.hpp&quot;
  38 #include &quot;opto/rootnode.hpp&quot;
  39 #include &quot;opto/runtime.hpp&quot;
  40 #include &quot;opto/subnode.hpp&quot;
  41 #include &quot;opto/superword.hpp&quot;
  42 #include &quot;opto/vectornode.hpp&quot;
  43 
  44 //------------------------------is_loop_exit-----------------------------------
  45 // Given an IfNode, return the loop-exiting projection or NULL if both
  46 // arms remain in the loop.
  47 Node *IdealLoopTree::is_loop_exit(Node *iff) const {
  48   if (iff-&gt;outcnt() != 2) return NULL;  // Ignore partially dead tests
  49   PhaseIdealLoop *phase = _phase;
  50   // Test is an IfNode, has 2 projections.  If BOTH are in the loop
  51   // we need loop unswitching instead of peeling.
  52   if (!is_member(phase-&gt;get_loop(iff-&gt;raw_out(0))))
  53     return iff-&gt;raw_out(0);
  54   if (!is_member(phase-&gt;get_loop(iff-&gt;raw_out(1))))
  55     return iff-&gt;raw_out(1);
  56   return NULL;
  57 }
  58 
  59 
  60 //=============================================================================
  61 
  62 
  63 //------------------------------record_for_igvn----------------------------
  64 // Put loop body on igvn work list
  65 void IdealLoopTree::record_for_igvn() {
  66   for (uint i = 0; i &lt; _body.size(); i++) {
  67     Node *n = _body.at(i);
  68     _phase-&gt;_igvn._worklist.push(n);
  69   }
  70   // put body of outer strip mined loop on igvn work list as well
  71   if (_head-&gt;is_CountedLoop() &amp;&amp; _head-&gt;as_Loop()-&gt;is_strip_mined()) {
  72     CountedLoopNode* l = _head-&gt;as_CountedLoop();
  73     Node* outer_loop = l-&gt;outer_loop();
  74     assert(outer_loop != NULL, &quot;missing piece of strip mined loop&quot;);
  75     _phase-&gt;_igvn._worklist.push(outer_loop);
  76     Node* outer_loop_tail = l-&gt;outer_loop_tail();
  77     assert(outer_loop_tail != NULL, &quot;missing piece of strip mined loop&quot;);
  78     _phase-&gt;_igvn._worklist.push(outer_loop_tail);
  79     Node* outer_loop_end = l-&gt;outer_loop_end();
  80     assert(outer_loop_end != NULL, &quot;missing piece of strip mined loop&quot;);
  81     _phase-&gt;_igvn._worklist.push(outer_loop_end);
  82     Node* outer_safepoint = l-&gt;outer_safepoint();
  83     assert(outer_safepoint != NULL, &quot;missing piece of strip mined loop&quot;);
  84     _phase-&gt;_igvn._worklist.push(outer_safepoint);
  85     Node* cle_out = _head-&gt;as_CountedLoop()-&gt;loopexit()-&gt;proj_out(false);
  86     assert(cle_out != NULL, &quot;missing piece of strip mined loop&quot;);
  87     _phase-&gt;_igvn._worklist.push(cle_out);
  88   }
  89 }
  90 
  91 //------------------------------compute_exact_trip_count-----------------------
  92 // Compute loop trip count if possible. Do not recalculate trip count for
  93 // split loops (pre-main-post) which have their limits and inits behind Opaque node.
  94 void IdealLoopTree::compute_trip_count(PhaseIdealLoop* phase) {
  95   if (!_head-&gt;as_Loop()-&gt;is_valid_counted_loop()) {
  96     return;
  97   }
  98   CountedLoopNode* cl = _head-&gt;as_CountedLoop();
  99   // Trip count may become nonexact for iteration split loops since
 100   // RCE modifies limits. Note, _trip_count value is not reset since
 101   // it is used to limit unrolling of main loop.
 102   cl-&gt;set_nonexact_trip_count();
 103 
 104   // Loop&#39;s test should be part of loop.
 105   if (!phase-&gt;is_member(this, phase-&gt;get_ctrl(cl-&gt;loopexit()-&gt;in(CountedLoopEndNode::TestValue))))
 106     return; // Infinite loop
 107 
 108 #ifdef ASSERT
 109   BoolTest::mask bt = cl-&gt;loopexit()-&gt;test_trip();
 110   assert(bt == BoolTest::lt || bt == BoolTest::gt ||
 111          bt == BoolTest::ne, &quot;canonical test is expected&quot;);
 112 #endif
 113 
 114   Node* init_n = cl-&gt;init_trip();
 115   Node* limit_n = cl-&gt;limit();
 116   if (init_n != NULL &amp;&amp; limit_n != NULL) {
 117     // Use longs to avoid integer overflow.
 118     int stride_con = cl-&gt;stride_con();
 119     const TypeInt* init_type = phase-&gt;_igvn.type(init_n)-&gt;is_int();
 120     const TypeInt* limit_type = phase-&gt;_igvn.type(limit_n)-&gt;is_int();
 121     jlong init_con = (stride_con &gt; 0) ? init_type-&gt;_lo : init_type-&gt;_hi;
 122     jlong limit_con = (stride_con &gt; 0) ? limit_type-&gt;_hi : limit_type-&gt;_lo;
 123     int stride_m = stride_con - (stride_con &gt; 0 ? 1 : -1);
 124     jlong trip_count = (limit_con - init_con + stride_m)/stride_con;
 125     if (trip_count &gt; 0 &amp;&amp; (julong)trip_count &lt; (julong)max_juint) {
 126       if (init_n-&gt;is_Con() &amp;&amp; limit_n-&gt;is_Con()) {
 127         // Set exact trip count.
 128         cl-&gt;set_exact_trip_count((uint)trip_count);
 129       } else if (cl-&gt;unrolled_count() == 1) {
 130         // Set maximum trip count before unrolling.
 131         cl-&gt;set_trip_count((uint)trip_count);
 132       }
 133     }
 134   }
 135 }
 136 
 137 //------------------------------compute_profile_trip_cnt----------------------------
 138 // Compute loop trip count from profile data as
 139 //    (backedge_count + loop_exit_count) / loop_exit_count
 140 
 141 float IdealLoopTree::compute_profile_trip_cnt_helper(Node* n) {
 142   if (n-&gt;is_If()) {
 143     IfNode *iff = n-&gt;as_If();
 144     if (iff-&gt;_fcnt != COUNT_UNKNOWN &amp;&amp; iff-&gt;_prob != PROB_UNKNOWN) {
 145       Node *exit = is_loop_exit(iff);
 146       if (exit) {
 147         float exit_prob = iff-&gt;_prob;
 148         if (exit-&gt;Opcode() == Op_IfFalse) {
 149           exit_prob = 1.0 - exit_prob;
 150         }
 151         if (exit_prob &gt; PROB_MIN) {
 152           float exit_cnt = iff-&gt;_fcnt * exit_prob;
 153           return exit_cnt;
 154         }
 155       }
 156     }
 157   }
 158   if (n-&gt;is_Jump()) {
 159     JumpNode *jmp = n-&gt;as_Jump();
 160     if (jmp-&gt;_fcnt != COUNT_UNKNOWN) {
 161       float* probs = jmp-&gt;_probs;
 162       float exit_prob = 0;
 163       PhaseIdealLoop *phase = _phase;
 164       for (DUIterator_Fast imax, i = jmp-&gt;fast_outs(imax); i &lt; imax; i++) {
 165         JumpProjNode* u = jmp-&gt;fast_out(i)-&gt;as_JumpProj();
 166         if (!is_member(_phase-&gt;get_loop(u))) {
 167           exit_prob += probs[u-&gt;_con];
 168         }
 169       }
 170       return exit_prob * jmp-&gt;_fcnt;
 171     }
 172   }
 173   return 0;
 174 }
 175 
 176 void IdealLoopTree::compute_profile_trip_cnt(PhaseIdealLoop *phase) {
 177   if (!_head-&gt;is_Loop()) {
 178     return;
 179   }
 180   LoopNode* head = _head-&gt;as_Loop();
 181   if (head-&gt;profile_trip_cnt() != COUNT_UNKNOWN) {
 182     return; // Already computed
 183   }
 184   float trip_cnt = (float)max_jint; // default is big
 185 
 186   Node* back = head-&gt;in(LoopNode::LoopBackControl);
 187   while (back != head) {
 188     if ((back-&gt;Opcode() == Op_IfTrue || back-&gt;Opcode() == Op_IfFalse) &amp;&amp;
 189         back-&gt;in(0) &amp;&amp;
 190         back-&gt;in(0)-&gt;is_If() &amp;&amp;
 191         back-&gt;in(0)-&gt;as_If()-&gt;_fcnt != COUNT_UNKNOWN &amp;&amp;
 192         back-&gt;in(0)-&gt;as_If()-&gt;_prob != PROB_UNKNOWN &amp;&amp;
 193         (back-&gt;Opcode() == Op_IfTrue ? 1-back-&gt;in(0)-&gt;as_If()-&gt;_prob : back-&gt;in(0)-&gt;as_If()-&gt;_prob) &gt; PROB_MIN) {
 194       break;
 195     }
 196     back = phase-&gt;idom(back);
 197   }
 198   if (back != head) {
 199     assert((back-&gt;Opcode() == Op_IfTrue || back-&gt;Opcode() == Op_IfFalse) &amp;&amp;
 200            back-&gt;in(0), &quot;if-projection exists&quot;);
 201     IfNode* back_if = back-&gt;in(0)-&gt;as_If();
 202     float loop_back_cnt = back_if-&gt;_fcnt * (back-&gt;Opcode() == Op_IfTrue ? back_if-&gt;_prob : (1 - back_if-&gt;_prob));
 203 
 204     // Now compute a loop exit count
 205     float loop_exit_cnt = 0.0f;
 206     if (_child == NULL) {
 207       for (uint i = 0; i &lt; _body.size(); i++) {
 208         Node *n = _body[i];
 209         loop_exit_cnt += compute_profile_trip_cnt_helper(n);
 210       }
 211     } else {
 212       ResourceMark rm;
 213       Unique_Node_List wq;
 214       wq.push(back);
 215       for (uint i = 0; i &lt; wq.size(); i++) {
 216         Node *n = wq.at(i);
 217         assert(n-&gt;is_CFG(), &quot;only control nodes&quot;);
 218         if (n != head) {
 219           if (n-&gt;is_Region()) {
 220             for (uint j = 1; j &lt; n-&gt;req(); j++) {
 221               wq.push(n-&gt;in(j));
 222             }
 223           } else {
 224             loop_exit_cnt += compute_profile_trip_cnt_helper(n);
 225             wq.push(n-&gt;in(0));
 226           }
 227         }
 228       }
 229 
 230     }
 231     if (loop_exit_cnt &gt; 0.0f) {
 232       trip_cnt = (loop_back_cnt + loop_exit_cnt) / loop_exit_cnt;
 233     } else {
 234       // No exit count so use
 235       trip_cnt = loop_back_cnt;
 236     }
 237   } else {
 238     head-&gt;mark_profile_trip_failed();
 239   }
 240 #ifndef PRODUCT
 241   if (TraceProfileTripCount) {
 242     tty-&gt;print_cr(&quot;compute_profile_trip_cnt  lp: %d cnt: %f\n&quot;, head-&gt;_idx, trip_cnt);
 243   }
 244 #endif
 245   head-&gt;set_profile_trip_cnt(trip_cnt);
 246 }
 247 
 248 //---------------------is_invariant_addition-----------------------------
 249 // Return nonzero index of invariant operand for an Add or Sub
 250 // of (nonconstant) invariant and variant values. Helper for reassociate_invariants.
 251 int IdealLoopTree::is_invariant_addition(Node* n, PhaseIdealLoop *phase) {
 252   int op = n-&gt;Opcode();
 253   if (op == Op_AddI || op == Op_SubI) {
 254     bool in1_invar = this-&gt;is_invariant(n-&gt;in(1));
 255     bool in2_invar = this-&gt;is_invariant(n-&gt;in(2));
 256     if (in1_invar &amp;&amp; !in2_invar) return 1;
 257     if (!in1_invar &amp;&amp; in2_invar) return 2;
 258   }
 259   return 0;
 260 }
 261 
 262 //---------------------reassociate_add_sub-----------------------------
 263 // Reassociate invariant add and subtract expressions:
 264 //
 265 // inv1 + (x + inv2)  =&gt;  ( inv1 + inv2) + x
 266 // (x + inv2) + inv1  =&gt;  ( inv1 + inv2) + x
 267 // inv1 + (x - inv2)  =&gt;  ( inv1 - inv2) + x
 268 // inv1 - (inv2 - x)  =&gt;  ( inv1 - inv2) + x
 269 // (x + inv2) - inv1  =&gt;  (-inv1 + inv2) + x
 270 // (x - inv2) + inv1  =&gt;  ( inv1 - inv2) + x
 271 // (x - inv2) - inv1  =&gt;  (-inv1 - inv2) + x
 272 // inv1 + (inv2 - x)  =&gt;  ( inv1 + inv2) - x
 273 // inv1 - (x - inv2)  =&gt;  ( inv1 + inv2) - x
 274 // (inv2 - x) + inv1  =&gt;  ( inv1 + inv2) - x
 275 // (inv2 - x) - inv1  =&gt;  (-inv1 + inv2) - x
 276 // inv1 - (x + inv2)  =&gt;  ( inv1 - inv2) - x
 277 //
 278 Node* IdealLoopTree::reassociate_add_sub(Node* n1, PhaseIdealLoop *phase) {
 279   if ((!n1-&gt;is_Add() &amp;&amp; !n1-&gt;is_Sub()) || n1-&gt;outcnt() == 0) return NULL;
 280   if (is_invariant(n1)) return NULL;
 281   int inv1_idx = is_invariant_addition(n1, phase);
 282   if (!inv1_idx) return NULL;
 283   // Don&#39;t mess with add of constant (igvn moves them to expression tree root.)
 284   if (n1-&gt;is_Add() &amp;&amp; n1-&gt;in(2)-&gt;is_Con()) return NULL;
 285   Node* inv1 = n1-&gt;in(inv1_idx);
 286   Node* n2 = n1-&gt;in(3 - inv1_idx);
 287   int inv2_idx = is_invariant_addition(n2, phase);
 288   if (!inv2_idx) return NULL;
 289 
 290   if (!phase-&gt;may_require_nodes(10, 10)) return NULL;
 291 
 292   Node* x    = n2-&gt;in(3 - inv2_idx);
 293   Node* inv2 = n2-&gt;in(inv2_idx);
 294 
 295   bool neg_x    = n2-&gt;is_Sub() &amp;&amp; inv2_idx == 1;
 296   bool neg_inv2 = n2-&gt;is_Sub() &amp;&amp; inv2_idx == 2;
 297   bool neg_inv1 = n1-&gt;is_Sub() &amp;&amp; inv1_idx == 2;
 298   if (n1-&gt;is_Sub() &amp;&amp; inv1_idx == 1) {
 299     neg_x    = !neg_x;
 300     neg_inv2 = !neg_inv2;
 301   }
 302   Node* inv1_c = phase-&gt;get_ctrl(inv1);
 303   Node* inv2_c = phase-&gt;get_ctrl(inv2);
 304   Node* n_inv1;
 305   if (neg_inv1) {
 306     Node *zero = phase-&gt;_igvn.intcon(0);
 307     phase-&gt;set_ctrl(zero, phase-&gt;C-&gt;root());
 308     n_inv1 = new SubINode(zero, inv1);
 309     phase-&gt;register_new_node(n_inv1, inv1_c);
 310   } else {
 311     n_inv1 = inv1;
 312   }
 313   Node* inv;
 314   if (neg_inv2) {
 315     inv = new SubINode(n_inv1, inv2);
 316   } else {
 317     inv = new AddINode(n_inv1, inv2);
 318   }
 319   phase-&gt;register_new_node(inv, phase-&gt;get_early_ctrl(inv));
 320 
 321   Node* addx;
 322   if (neg_x) {
 323     addx = new SubINode(inv, x);
 324   } else {
 325     addx = new AddINode(x, inv);
 326   }
 327   phase-&gt;register_new_node(addx, phase-&gt;get_ctrl(x));
 328   phase-&gt;_igvn.replace_node(n1, addx);
 329   assert(phase-&gt;get_loop(phase-&gt;get_ctrl(n1)) == this, &quot;&quot;);
 330   _body.yank(n1);
 331   return addx;
 332 }
 333 
 334 //---------------------reassociate_invariants-----------------------------
 335 // Reassociate invariant expressions:
 336 void IdealLoopTree::reassociate_invariants(PhaseIdealLoop *phase) {
 337   for (int i = _body.size() - 1; i &gt;= 0; i--) {
 338     Node *n = _body.at(i);
 339     for (int j = 0; j &lt; 5; j++) {
 340       Node* nn = reassociate_add_sub(n, phase);
 341       if (nn == NULL) break;
 342       n = nn; // again
 343     }
 344   }
 345 }
 346 
 347 //------------------------------policy_peeling---------------------------------
 348 // Return TRUE if the loop should be peeled, otherwise return FALSE. Peeling
 349 // is applicable if we can make a loop-invariant test (usually a null-check)
 350 // execute before we enter the loop. When TRUE, the estimated node budget is
 351 // also requested.
 352 bool IdealLoopTree::policy_peeling(PhaseIdealLoop *phase) {
 353   uint estimate = estimate_peeling(phase);
 354 
 355   return estimate == 0 ? false : phase-&gt;may_require_nodes(estimate);
 356 }
 357 
 358 // Perform actual policy and size estimate for the loop peeling transform, and
 359 // return the estimated loop size if peeling is applicable, otherwise return
 360 // zero. No node budget is allocated.
 361 uint IdealLoopTree::estimate_peeling(PhaseIdealLoop *phase) {
 362 
 363   // If nodes are depleted, some transform has miscalculated its needs.
 364   assert(!phase-&gt;exceeding_node_budget(), &quot;sanity&quot;);
 365 
 366   // Peeling does loop cloning which can result in O(N^2) node construction.
 367   if (_body.size() &gt; 255) {
 368     return 0;   // Suppress too large body size.
 369   }
 370   // Optimistic estimate that approximates loop body complexity via data and
 371   // control flow fan-out (instead of using the more pessimistic: BodySize^2).
 372   uint estimate = est_loop_clone_sz(2);
 373 
 374   if (phase-&gt;exceeding_node_budget(estimate)) {
 375     return 0;   // Too large to safely clone.
 376   }
 377 
 378   // Check for vectorized loops, any peeling done was already applied.
 379   if (_head-&gt;is_CountedLoop()) {
 380     CountedLoopNode* cl = _head-&gt;as_CountedLoop();
 381     if (cl-&gt;is_unroll_only() || cl-&gt;trip_count() == 1) {
 382       return 0;
 383     }
 384   }
 385 
 386   Node* test = tail();
 387 
 388   while (test != _head) {   // Scan till run off top of loop
 389     if (test-&gt;is_If()) {    // Test?
 390       Node *ctrl = phase-&gt;get_ctrl(test-&gt;in(1));
 391       if (ctrl-&gt;is_top()) {
 392         return 0;           // Found dead test on live IF?  No peeling!
 393       }
 394       // Standard IF only has one input value to check for loop invariance.
 395       assert(test-&gt;Opcode() == Op_If ||
 396              test-&gt;Opcode() == Op_CountedLoopEnd ||
 397              test-&gt;Opcode() == Op_RangeCheck,
 398              &quot;Check this code when new subtype is added&quot;);
 399       // Condition is not a member of this loop?
 400       if (!is_member(phase-&gt;get_loop(ctrl)) &amp;&amp; is_loop_exit(test)) {
 401         return estimate;    // Found reason to peel!
 402       }
 403     }
 404     // Walk up dominators to loop _head looking for test which is executed on
 405     // every path through the loop.
 406     test = phase-&gt;idom(test);
 407   }
 408   return 0;
 409 }
 410 
 411 //------------------------------peeled_dom_test_elim---------------------------
 412 // If we got the effect of peeling, either by actually peeling or by making
 413 // a pre-loop which must execute at least once, we can remove all
 414 // loop-invariant dominated tests in the main body.
 415 void PhaseIdealLoop::peeled_dom_test_elim(IdealLoopTree *loop, Node_List &amp;old_new) {
 416   bool progress = true;
 417   while (progress) {
 418     progress = false;           // Reset for next iteration
 419     Node *prev = loop-&gt;_head-&gt;in(LoopNode::LoopBackControl);//loop-&gt;tail();
 420     Node *test = prev-&gt;in(0);
 421     while (test != loop-&gt;_head) { // Scan till run off top of loop
 422 
 423       int p_op = prev-&gt;Opcode();
 424       if ((p_op == Op_IfFalse || p_op == Op_IfTrue) &amp;&amp;
 425           test-&gt;is_If() &amp;&amp;      // Test?
 426           !test-&gt;in(1)-&gt;is_Con() &amp;&amp; // And not already obvious?
 427           // Condition is not a member of this loop?
 428           !loop-&gt;is_member(get_loop(get_ctrl(test-&gt;in(1))))){
 429         // Walk loop body looking for instances of this test
 430         for (uint i = 0; i &lt; loop-&gt;_body.size(); i++) {
 431           Node *n = loop-&gt;_body.at(i);
 432           if (n-&gt;is_If() &amp;&amp; n-&gt;in(1) == test-&gt;in(1) /*&amp;&amp; n != loop-&gt;tail()-&gt;in(0)*/) {
 433             // IfNode was dominated by version in peeled loop body
 434             progress = true;
 435             dominated_by(old_new[prev-&gt;_idx], n);
 436           }
 437         }
 438       }
 439       prev = test;
 440       test = idom(test);
 441     } // End of scan tests in loop
 442 
 443   } // End of while (progress)
 444 }
 445 
 446 //------------------------------do_peeling-------------------------------------
 447 // Peel the first iteration of the given loop.
 448 // Step 1: Clone the loop body.  The clone becomes the peeled iteration.
 449 //         The pre-loop illegally has 2 control users (old &amp; new loops).
 450 // Step 2: Make the old-loop fall-in edges point to the peeled iteration.
 451 //         Do this by making the old-loop fall-in edges act as if they came
 452 //         around the loopback from the prior iteration (follow the old-loop
 453 //         backedges) and then map to the new peeled iteration.  This leaves
 454 //         the pre-loop with only 1 user (the new peeled iteration), but the
 455 //         peeled-loop backedge has 2 users.
 456 // Step 3: Cut the backedge on the clone (so its not a loop) and remove the
 457 //         extra backedge user.
 458 //
 459 //                   orig
 460 //
 461 //                  stmt1
 462 //                    |
 463 //                    v
 464 //              loop predicate
 465 //                    |
 466 //                    v
 467 //                   loop&lt;----+
 468 //                     |      |
 469 //                   stmt2    |
 470 //                     |      |
 471 //                     v      |
 472 //                    if      ^
 473 //                   / \      |
 474 //                  /   \     |
 475 //                 v     v    |
 476 //               false true   |
 477 //               /       \    |
 478 //              /         ----+
 479 //             |
 480 //             v
 481 //           exit
 482 //
 483 //
 484 //            after clone loop
 485 //
 486 //                   stmt1
 487 //                     |
 488 //                     v
 489 //               loop predicate
 490 //                 /       \
 491 //        clone   /         \   orig
 492 //               /           \
 493 //              /             \
 494 //             v               v
 495 //   +----&gt;loop clone          loop&lt;----+
 496 //   |      |                    |      |
 497 //   |    stmt2 clone          stmt2    |
 498 //   |      |                    |      |
 499 //   |      v                    v      |
 500 //   ^      if clone            If      ^
 501 //   |      / \                / \      |
 502 //   |     /   \              /   \     |
 503 //   |    v     v            v     v    |
 504 //   |    true  false      false true   |
 505 //   |    /         \      /       \    |
 506 //   +----           \    /         ----+
 507 //                    \  /
 508 //                    1v v2
 509 //                  region
 510 //                     |
 511 //                     v
 512 //                   exit
 513 //
 514 //
 515 //         after peel and predicate move
 516 //
 517 //                   stmt1
 518 //                    /
 519 //                   /
 520 //        clone     /            orig
 521 //                 /
 522 //                /              +----------+
 523 //               /               |          |
 524 //              /          loop predicate   |
 525 //             /                 |          |
 526 //            v                  v          |
 527 //   TOP--&gt;loop clone          loop&lt;----+   |
 528 //          |                    |      |   |
 529 //        stmt2 clone          stmt2    |   |
 530 //          |                    |      |   ^
 531 //          v                    v      |   |
 532 //          if clone            If      ^   |
 533 //          / \                / \      |   |
 534 //         /   \              /   \     |   |
 535 //        v     v            v     v    |   |
 536 //      true   false      false  true   |   |
 537 //        |         \      /       \    |   |
 538 //        |          \    /         ----+   ^
 539 //        |           \  /                  |
 540 //        |           1v v2                 |
 541 //        v         region                  |
 542 //        |            |                    |
 543 //        |            v                    |
 544 //        |          exit                   |
 545 //        |                                 |
 546 //        +---------------&gt;-----------------+
 547 //
 548 //
 549 //              final graph
 550 //
 551 //                  stmt1
 552 //                    |
 553 //                    v
 554 //                  stmt2 clone
 555 //                    |
 556 //                    v
 557 //                   if clone
 558 //                  / |
 559 //                 /  |
 560 //                v   v
 561 //            false  true
 562 //             |      |
 563 //             |      v
 564 //             | loop predicate
 565 //             |      |
 566 //             |      v
 567 //             |     loop&lt;----+
 568 //             |      |       |
 569 //             |    stmt2     |
 570 //             |      |       |
 571 //             |      v       |
 572 //             v      if      ^
 573 //             |     /  \     |
 574 //             |    /    \    |
 575 //             |   v     v    |
 576 //             | false  true  |
 577 //             |  |        \  |
 578 //             v  v         --+
 579 //            region
 580 //              |
 581 //              v
 582 //             exit
 583 //
 584 void PhaseIdealLoop::do_peeling(IdealLoopTree *loop, Node_List &amp;old_new) {
 585 
 586   C-&gt;set_major_progress();
 587   // Peeling a &#39;main&#39; loop in a pre/main/post situation obfuscates the
 588   // &#39;pre&#39; loop from the main and the &#39;pre&#39; can no longer have its
 589   // iterations adjusted.  Therefore, we need to declare this loop as
 590   // no longer a &#39;main&#39; loop; it will need new pre and post loops before
 591   // we can do further RCE.
 592 #ifndef PRODUCT
 593   if (TraceLoopOpts) {
 594     tty-&gt;print(&quot;Peel         &quot;);
 595     loop-&gt;dump_head();
 596   }
 597 #endif
 598   LoopNode* head = loop-&gt;_head-&gt;as_Loop();
 599   bool counted_loop = head-&gt;is_CountedLoop();
 600   if (counted_loop) {
 601     CountedLoopNode *cl = head-&gt;as_CountedLoop();
 602     assert(cl-&gt;trip_count() &gt; 0, &quot;peeling a fully unrolled loop&quot;);
 603     cl-&gt;set_trip_count(cl-&gt;trip_count() - 1);
 604     if (cl-&gt;is_main_loop()) {
 605       cl-&gt;set_normal_loop();
 606 #ifndef PRODUCT
 607       if (PrintOpto &amp;&amp; VerifyLoopOptimizations) {
 608         tty-&gt;print(&quot;Peeling a &#39;main&#39; loop; resetting to &#39;normal&#39; &quot;);
 609         loop-&gt;dump_head();
 610       }
 611 #endif
 612     }
 613   }
 614   Node* entry = head-&gt;in(LoopNode::EntryControl);
 615 
 616   // Step 1: Clone the loop body.  The clone becomes the peeled iteration.
 617   //         The pre-loop illegally has 2 control users (old &amp; new loops).
 618   clone_loop(loop, old_new, dom_depth(head-&gt;skip_strip_mined()), ControlAroundStripMined);
 619 
 620   // Step 2: Make the old-loop fall-in edges point to the peeled iteration.
 621   //         Do this by making the old-loop fall-in edges act as if they came
 622   //         around the loopback from the prior iteration (follow the old-loop
 623   //         backedges) and then map to the new peeled iteration.  This leaves
 624   //         the pre-loop with only 1 user (the new peeled iteration), but the
 625   //         peeled-loop backedge has 2 users.
 626   Node* new_entry = old_new[head-&gt;in(LoopNode::LoopBackControl)-&gt;_idx];
 627   _igvn.hash_delete(head-&gt;skip_strip_mined());
 628   head-&gt;skip_strip_mined()-&gt;set_req(LoopNode::EntryControl, new_entry);
 629   for (DUIterator_Fast jmax, j = head-&gt;fast_outs(jmax); j &lt; jmax; j++) {
 630     Node* old = head-&gt;fast_out(j);
 631     if (old-&gt;in(0) == loop-&gt;_head &amp;&amp; old-&gt;req() == 3 &amp;&amp; old-&gt;is_Phi()) {
 632       Node* new_exit_value = old_new[old-&gt;in(LoopNode::LoopBackControl)-&gt;_idx];
 633       if (!new_exit_value)     // Backedge value is ALSO loop invariant?
 634         // Then loop body backedge value remains the same.
 635         new_exit_value = old-&gt;in(LoopNode::LoopBackControl);
 636       _igvn.hash_delete(old);
 637       old-&gt;set_req(LoopNode::EntryControl, new_exit_value);
 638     }
 639   }
 640 
 641 
 642   // Step 3: Cut the backedge on the clone (so its not a loop) and remove the
 643   //         extra backedge user.
 644   Node* new_head = old_new[head-&gt;_idx];
 645   _igvn.hash_delete(new_head);
 646   new_head-&gt;set_req(LoopNode::LoopBackControl, C-&gt;top());
 647   for (DUIterator_Fast j2max, j2 = new_head-&gt;fast_outs(j2max); j2 &lt; j2max; j2++) {
 648     Node* use = new_head-&gt;fast_out(j2);
 649     if (use-&gt;in(0) == new_head &amp;&amp; use-&gt;req() == 3 &amp;&amp; use-&gt;is_Phi()) {
 650       _igvn.hash_delete(use);
 651       use-&gt;set_req(LoopNode::LoopBackControl, C-&gt;top());
 652     }
 653   }
 654 
 655   // Step 4: Correct dom-depth info.  Set to loop-head depth.
 656 
 657   int dd = dom_depth(head-&gt;skip_strip_mined());
 658   set_idom(head-&gt;skip_strip_mined(), head-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl), dd);
 659   for (uint j3 = 0; j3 &lt; loop-&gt;_body.size(); j3++) {
 660     Node *old = loop-&gt;_body.at(j3);
 661     Node *nnn = old_new[old-&gt;_idx];
 662     if (!has_ctrl(nnn)) {
 663       set_idom(nnn, idom(nnn), dd-1);
 664     }
 665   }
 666 
 667   // Now force out all loop-invariant dominating tests.  The optimizer
 668   // finds some, but we _know_ they are all useless.
 669   peeled_dom_test_elim(loop,old_new);
 670 
 671   loop-&gt;record_for_igvn();
 672 }
 673 
 674 //------------------------------policy_maximally_unroll------------------------
 675 // Calculate the exact  loop trip-count and return TRUE if loop can be fully,
 676 // i.e. maximally, unrolled, otherwise return FALSE. When TRUE, the estimated
 677 // node budget is also requested.
 678 bool IdealLoopTree::policy_maximally_unroll(PhaseIdealLoop* phase) const {
 679   CountedLoopNode* cl = _head-&gt;as_CountedLoop();
 680   assert(cl-&gt;is_normal_loop(), &quot;&quot;);
 681   if (!cl-&gt;is_valid_counted_loop()) {
 682     return false;   // Malformed counted loop.
 683   }
 684   if (!cl-&gt;has_exact_trip_count()) {
 685     return false;   // Trip count is not exact.
 686   }
 687 
 688   uint trip_count = cl-&gt;trip_count();
 689   // Note, max_juint is used to indicate unknown trip count.
 690   assert(trip_count &gt; 1, &quot;one iteration loop should be optimized out already&quot;);
 691   assert(trip_count &lt; max_juint, &quot;exact trip_count should be less than max_juint.&quot;);
 692 
 693   // If nodes are depleted, some transform has miscalculated its needs.
 694   assert(!phase-&gt;exceeding_node_budget(), &quot;sanity&quot;);
 695 
 696   // Allow the unrolled body to get larger than the standard loop size limit.
 697   uint unroll_limit = (uint)LoopUnrollLimit * 4;
 698   assert((intx)unroll_limit == LoopUnrollLimit * 4, &quot;LoopUnrollLimit must fit in 32bits&quot;);
 699   if (trip_count &gt; unroll_limit || _body.size() &gt; unroll_limit) {
 700     return false;
 701   }
 702 
 703   uint new_body_size = est_loop_unroll_sz(trip_count);
 704 
 705   if (new_body_size == UINT_MAX) { // Check for bad estimate (overflow).
 706     return false;
 707   }
 708 
 709   // Fully unroll a loop with few iterations, regardless of other conditions,
 710   // since the following (general) loop optimizations will split such loop in
 711   // any case (into pre-main-post).
 712   if (trip_count &lt;= 3) {
 713     return phase-&gt;may_require_nodes(new_body_size);
 714   }
 715 
 716   // Reject if unrolling will result in too much node construction.
 717   if (new_body_size &gt; unroll_limit || phase-&gt;exceeding_node_budget(new_body_size)) {
 718     return false;
 719   }
 720 
 721   // Do not unroll a loop with String intrinsics code.
 722   // String intrinsics are large and have loops.
 723   for (uint k = 0; k &lt; _body.size(); k++) {
 724     Node* n = _body.at(k);
 725     switch (n-&gt;Opcode()) {
 726       case Op_StrComp:
 727       case Op_StrEquals:
 728       case Op_StrIndexOf:
 729       case Op_StrIndexOfChar:
 730       case Op_EncodeISOArray:
 731       case Op_AryEq:
 732       case Op_HasNegatives: {
 733         return false;
 734       }
 735 #if INCLUDE_RTM_OPT
 736       case Op_FastLock:
 737       case Op_FastUnlock: {
 738         // Don&#39;t unroll RTM locking code because it is large.
 739         if (UseRTMLocking) {
 740           return false;
 741         }
 742       }
 743 #endif
 744     } // switch
 745   }
 746 
 747   return phase-&gt;may_require_nodes(new_body_size);
 748 }
 749 
 750 
 751 //------------------------------policy_unroll----------------------------------
 752 // Return TRUE or FALSE if the loop should be unrolled or not. Apply unroll if
 753 // the loop is  a counted loop and  the loop body is small  enough. When TRUE,
 754 // the estimated node budget is also requested.
 755 bool IdealLoopTree::policy_unroll(PhaseIdealLoop *phase) {
 756 
 757   CountedLoopNode *cl = _head-&gt;as_CountedLoop();
 758   assert(cl-&gt;is_normal_loop() || cl-&gt;is_main_loop(), &quot;&quot;);
 759 
 760   if (!cl-&gt;is_valid_counted_loop()) {
 761     return false; // Malformed counted loop
 762   }
 763 
 764   // If nodes are depleted, some transform has miscalculated its needs.
 765   assert(!phase-&gt;exceeding_node_budget(), &quot;sanity&quot;);
 766 
 767   // Protect against over-unrolling.
 768   // After split at least one iteration will be executed in pre-loop.
 769   if (cl-&gt;trip_count() &lt;= (cl-&gt;is_normal_loop() ? 2u : 1u)) {
 770     return false;
 771   }
 772   _local_loop_unroll_limit  = LoopUnrollLimit;
 773   _local_loop_unroll_factor = 4;
 774   int future_unroll_cnt = cl-&gt;unrolled_count() * 2;
 775   if (!cl-&gt;is_vectorized_loop()) {
 776     if (future_unroll_cnt &gt; LoopMaxUnroll) return false;
 777   } else {
 778     // obey user constraints on vector mapped loops with additional unrolling applied
 779     int unroll_constraint = (cl-&gt;slp_max_unroll()) ? cl-&gt;slp_max_unroll() : 1;
 780     if ((future_unroll_cnt / unroll_constraint) &gt; LoopMaxUnroll) return false;
 781   }
 782 
 783   // Check for initial stride being a small enough constant
 784   if (abs(cl-&gt;stride_con()) &gt; (1&lt;&lt;2)*future_unroll_cnt) return false;
 785 
 786   // Don&#39;t unroll if the next round of unrolling would push us
 787   // over the expected trip count of the loop.  One is subtracted
 788   // from the expected trip count because the pre-loop normally
 789   // executes 1 iteration.
 790   if (UnrollLimitForProfileCheck &gt; 0 &amp;&amp;
 791       cl-&gt;profile_trip_cnt() != COUNT_UNKNOWN &amp;&amp;
 792       future_unroll_cnt        &gt; UnrollLimitForProfileCheck &amp;&amp;
 793       (float)future_unroll_cnt &gt; cl-&gt;profile_trip_cnt() - 1.0) {
 794     return false;
 795   }
 796 
 797   // When unroll count is greater than LoopUnrollMin, don&#39;t unroll if:
 798   //   the residual iterations are more than 10% of the trip count
 799   //   and rounds of &quot;unroll,optimize&quot; are not making significant progress
 800   //   Progress defined as current size less than 20% larger than previous size.
 801   if (UseSuperWord &amp;&amp; cl-&gt;node_count_before_unroll() &gt; 0 &amp;&amp;
 802       future_unroll_cnt &gt; LoopUnrollMin &amp;&amp;
 803       (future_unroll_cnt - 1) * (100 / LoopPercentProfileLimit) &gt; cl-&gt;profile_trip_cnt() &amp;&amp;
 804       1.2 * cl-&gt;node_count_before_unroll() &lt; (double)_body.size()) {
 805     return false;
 806   }
 807 
 808   Node *init_n = cl-&gt;init_trip();
 809   Node *limit_n = cl-&gt;limit();
 810   int stride_con = cl-&gt;stride_con();
 811   if (limit_n == NULL) return false; // We will dereference it below.
 812 
 813   // Non-constant bounds.
 814   // Protect against over-unrolling when init or/and limit are not constant
 815   // (so that trip_count&#39;s init value is maxint) but iv range is known.
 816   if (init_n == NULL || !init_n-&gt;is_Con() || !limit_n-&gt;is_Con()) {
 817     Node* phi = cl-&gt;phi();
 818     if (phi != NULL) {
 819       assert(phi-&gt;is_Phi() &amp;&amp; phi-&gt;in(0) == _head, &quot;Counted loop should have iv phi.&quot;);
 820       const TypeInt* iv_type = phase-&gt;_igvn.type(phi)-&gt;is_int();
 821       int next_stride = stride_con * 2; // stride after this unroll
 822       if (next_stride &gt; 0) {
 823         if (iv_type-&gt;_lo + next_stride &lt;= iv_type-&gt;_lo || // overflow
 824             iv_type-&gt;_lo + next_stride &gt;  iv_type-&gt;_hi) {
 825           return false;  // over-unrolling
 826         }
 827       } else if (next_stride &lt; 0) {
 828         if (iv_type-&gt;_hi + next_stride &gt;= iv_type-&gt;_hi || // overflow
 829             iv_type-&gt;_hi + next_stride &lt;  iv_type-&gt;_lo) {
 830           return false;  // over-unrolling
 831         }
 832       }
 833     }
 834   }
 835 
 836   // After unroll limit will be adjusted: new_limit = limit-stride.
 837   // Bailout if adjustment overflow.
 838   const TypeInt* limit_type = phase-&gt;_igvn.type(limit_n)-&gt;is_int();
 839   if ((stride_con &gt; 0 &amp;&amp; ((limit_type-&gt;_hi - stride_con) &gt;= limit_type-&gt;_hi)) ||
 840       (stride_con &lt; 0 &amp;&amp; ((limit_type-&gt;_lo - stride_con) &lt;= limit_type-&gt;_lo)))
 841     return false;  // overflow
 842 
 843   // Adjust body_size to determine if we unroll or not
 844   uint body_size = _body.size();
 845   // Key test to unroll loop in CRC32 java code
 846   int xors_in_loop = 0;
 847   // Also count ModL, DivL and MulL which expand mightly
 848   for (uint k = 0; k &lt; _body.size(); k++) {
 849     Node* n = _body.at(k);
 850     switch (n-&gt;Opcode()) {
 851       case Op_XorI: xors_in_loop++; break; // CRC32 java code
 852       case Op_ModL: body_size += 30; break;
 853       case Op_DivL: body_size += 30; break;
 854       case Op_MulL: body_size += 10; break;
 855       case Op_StrComp:
 856       case Op_StrEquals:
 857       case Op_StrIndexOf:
 858       case Op_StrIndexOfChar:
 859       case Op_EncodeISOArray:
 860       case Op_AryEq:
 861       case Op_HasNegatives: {
 862         // Do not unroll a loop with String intrinsics code.
 863         // String intrinsics are large and have loops.
 864         return false;
 865       }
 866 #if INCLUDE_RTM_OPT
 867       case Op_FastLock:
 868       case Op_FastUnlock: {
 869         // Don&#39;t unroll RTM locking code because it is large.
 870         if (UseRTMLocking) {
 871           return false;
 872         }
 873       }
 874 #endif
 875     } // switch
 876   }
 877 
 878   if (UseSuperWord) {
 879     if (!cl-&gt;is_reduction_loop()) {
 880       phase-&gt;mark_reductions(this);
 881     }
 882 
 883     // Only attempt slp analysis when user controls do not prohibit it
 884     if (LoopMaxUnroll &gt; _local_loop_unroll_factor) {
 885       // Once policy_slp_analysis succeeds, mark the loop with the
 886       // maximal unroll factor so that we minimize analysis passes
 887       if (future_unroll_cnt &gt;= _local_loop_unroll_factor) {
 888         policy_unroll_slp_analysis(cl, phase, future_unroll_cnt);
 889       }
 890     }
 891   }
 892 
 893   int slp_max_unroll_factor = cl-&gt;slp_max_unroll();
 894   if ((LoopMaxUnroll &lt; slp_max_unroll_factor) &amp;&amp; FLAG_IS_DEFAULT(LoopMaxUnroll) &amp;&amp; UseSubwordForMaxVector) {
 895     LoopMaxUnroll = slp_max_unroll_factor;
 896   }
 897 
 898   uint estimate = est_loop_clone_sz(2);
 899 
 900   if (cl-&gt;has_passed_slp()) {
 901     if (slp_max_unroll_factor &gt;= future_unroll_cnt) {
 902       return phase-&gt;may_require_nodes(estimate);
 903     }
 904     return false; // Loop too big.
 905   }
 906 
 907   // Check for being too big
 908   if (body_size &gt; (uint)_local_loop_unroll_limit) {
 909     if ((cl-&gt;is_subword_loop() || xors_in_loop &gt;= 4) &amp;&amp; body_size &lt; 4u * LoopUnrollLimit) {
 910       return phase-&gt;may_require_nodes(estimate);
 911     }
 912     return false; // Loop too big.
 913   }
 914 
 915   if (cl-&gt;is_unroll_only()) {
 916     if (TraceSuperWordLoopUnrollAnalysis) {
 917       tty-&gt;print_cr(&quot;policy_unroll passed vector loop(vlen=%d, factor=%d)\n&quot;,
 918                     slp_max_unroll_factor, future_unroll_cnt);
 919     }
 920   }
 921 
 922   // Unroll once!  (Each trip will soon do double iterations)
 923   return phase-&gt;may_require_nodes(estimate);
 924 }
 925 
 926 void IdealLoopTree::policy_unroll_slp_analysis(CountedLoopNode *cl, PhaseIdealLoop *phase, int future_unroll_cnt) {
 927 
 928   // If nodes are depleted, some transform has miscalculated its needs.
 929   assert(!phase-&gt;exceeding_node_budget(), &quot;sanity&quot;);
 930 
 931   // Enable this functionality target by target as needed
 932   if (SuperWordLoopUnrollAnalysis) {
 933     if (!cl-&gt;was_slp_analyzed()) {
 934       SuperWord sw(phase);
 935       sw.transform_loop(this, false);
 936 
 937       // If the loop is slp canonical analyze it
 938       if (sw.early_return() == false) {
 939         sw.unrolling_analysis(_local_loop_unroll_factor);
 940       }
 941     }
 942 
 943     if (cl-&gt;has_passed_slp()) {
 944       int slp_max_unroll_factor = cl-&gt;slp_max_unroll();
 945       if (slp_max_unroll_factor &gt;= future_unroll_cnt) {
 946         int new_limit = cl-&gt;node_count_before_unroll() * slp_max_unroll_factor;
 947         if (new_limit &gt; LoopUnrollLimit) {
 948           if (TraceSuperWordLoopUnrollAnalysis) {
 949             tty-&gt;print_cr(&quot;slp analysis unroll=%d, default limit=%d\n&quot;, new_limit, _local_loop_unroll_limit);
 950           }
 951           _local_loop_unroll_limit = new_limit;
 952         }
 953       }
 954     }
 955   }
 956 }
 957 
 958 //------------------------------policy_align-----------------------------------
 959 // Return TRUE or FALSE if the loop should be cache-line aligned.  Gather the
 960 // expression that does the alignment.  Note that only one array base can be
 961 // aligned in a loop (unless the VM guarantees mutual alignment).  Note that
 962 // if we vectorize short memory ops into longer memory ops, we may want to
 963 // increase alignment.
 964 bool IdealLoopTree::policy_align(PhaseIdealLoop *phase) const {
 965   return false;
 966 }
 967 
 968 //------------------------------policy_range_check-----------------------------
 969 // Return TRUE or FALSE if the loop should be range-check-eliminated or not.
 970 // When TRUE, the estimated node budget is also requested.
 971 //
 972 // We will actually perform iteration-splitting, a more powerful form of RCE.
 973 bool IdealLoopTree::policy_range_check(PhaseIdealLoop *phase) const {
 974   if (!RangeCheckElimination) return false;
 975 
 976   // If nodes are depleted, some transform has miscalculated its needs.
 977   assert(!phase-&gt;exceeding_node_budget(), &quot;sanity&quot;);
 978 
 979   CountedLoopNode *cl = _head-&gt;as_CountedLoop();
 980   // If we unrolled  with no intention of doing RCE and we  later changed our
 981   // minds, we got no pre-loop.  Either we need to make a new pre-loop, or we
 982   // have to disallow RCE.
 983   if (cl-&gt;is_main_no_pre_loop()) return false; // Disallowed for now.
 984   Node *trip_counter = cl-&gt;phi();
 985 
 986   // check for vectorized loops, some opts are no longer needed
 987   if (cl-&gt;is_unroll_only()) return false;
 988 
 989   // Check loop body for tests of trip-counter plus loop-invariant vs
 990   // loop-invariant.
 991   for (uint i = 0; i &lt; _body.size(); i++) {
 992     Node *iff = _body[i];
 993     if (iff-&gt;Opcode() == Op_If ||
 994         iff-&gt;Opcode() == Op_RangeCheck) { // Test?
 995 
 996       // Comparing trip+off vs limit
 997       Node *bol = iff-&gt;in(1);
 998       if (bol-&gt;req() != 2) {
 999         continue; // dead constant test
1000       }
1001       if (!bol-&gt;is_Bool()) {
1002         assert(bol-&gt;Opcode() == Op_Conv2B, &quot;predicate check only&quot;);
1003         continue;
1004       }
1005       if (bol-&gt;as_Bool()-&gt;_test._test == BoolTest::ne) {
1006         continue; // not RC
1007       }
1008       Node *cmp = bol-&gt;in(1);
1009       Node *rc_exp = cmp-&gt;in(1);
1010       Node *limit = cmp-&gt;in(2);
1011 
1012       Node *limit_c = phase-&gt;get_ctrl(limit);
1013       if (limit_c == phase-&gt;C-&gt;top()) {
1014         return false;           // Found dead test on live IF?  No RCE!
1015       }
1016       if (is_member(phase-&gt;get_loop(limit_c))) {
1017         // Compare might have operands swapped; commute them
1018         rc_exp = cmp-&gt;in(2);
1019         limit  = cmp-&gt;in(1);
1020         limit_c = phase-&gt;get_ctrl(limit);
1021         if (is_member(phase-&gt;get_loop(limit_c))) {
1022           continue;             // Both inputs are loop varying; cannot RCE
1023         }
1024       }
1025 
1026       if (!phase-&gt;is_scaled_iv_plus_offset(rc_exp, trip_counter, NULL, NULL)) {
1027         continue;
1028       }
1029       // Found a test like &#39;trip+off vs limit&#39;. Test is an IfNode, has two (2)
1030       // projections. If BOTH are in the loop we need loop unswitching instead
1031       // of iteration splitting.
1032       if (is_loop_exit(iff)) {
1033         // Found valid reason to split iterations (if there is room).
1034         // NOTE: Usually a gross overestimate.
1035         return phase-&gt;may_require_nodes(est_loop_clone_sz(2));
1036       }
1037     } // End of is IF
1038   }
1039 
1040   return false;
1041 }
1042 
1043 //------------------------------policy_peel_only-------------------------------
1044 // Return TRUE or FALSE if the loop should NEVER be RCE&#39;d or aligned.  Useful
1045 // for unrolling loops with NO array accesses.
1046 bool IdealLoopTree::policy_peel_only(PhaseIdealLoop *phase) const {
1047 
1048   // If nodes are depleted, some transform has miscalculated its needs.
1049   assert(!phase-&gt;exceeding_node_budget(), &quot;sanity&quot;);
1050 
1051   // check for vectorized loops, any peeling done was already applied
1052   if (_head-&gt;is_CountedLoop() &amp;&amp; _head-&gt;as_CountedLoop()-&gt;is_unroll_only()) {
1053     return false;
1054   }
1055 
1056   for (uint i = 0; i &lt; _body.size(); i++) {
1057     if (_body[i]-&gt;is_Mem()) {
1058       return false;
1059     }
1060   }
1061   // No memory accesses at all!
1062   return true;
1063 }
1064 
1065 //------------------------------clone_up_backedge_goo--------------------------
1066 // If Node n lives in the back_ctrl block and cannot float, we clone a private
1067 // version of n in preheader_ctrl block and return that, otherwise return n.
1068 Node *PhaseIdealLoop::clone_up_backedge_goo(Node *back_ctrl, Node *preheader_ctrl, Node *n, VectorSet &amp;visited, Node_Stack &amp;clones) {
1069   if (get_ctrl(n) != back_ctrl) return n;
1070 
1071   // Only visit once
1072   if (visited.test_set(n-&gt;_idx)) {
1073     Node *x = clones.find(n-&gt;_idx);
1074     return (x != NULL) ? x : n;
1075   }
1076 
1077   Node *x = NULL;               // If required, a clone of &#39;n&#39;
1078   // Check for &#39;n&#39; being pinned in the backedge.
1079   if (n-&gt;in(0) &amp;&amp; n-&gt;in(0) == back_ctrl) {
1080     assert(clones.find(n-&gt;_idx) == NULL, &quot;dead loop&quot;);
1081     x = n-&gt;clone();             // Clone a copy of &#39;n&#39; to preheader
1082     clones.push(x, n-&gt;_idx);
1083     x-&gt;set_req(0, preheader_ctrl); // Fix x&#39;s control input to preheader
1084   }
1085 
1086   // Recursive fixup any other input edges into x.
1087   // If there are no changes we can just return &#39;n&#39;, otherwise
1088   // we need to clone a private copy and change it.
1089   for (uint i = 1; i &lt; n-&gt;req(); i++) {
1090     Node *g = clone_up_backedge_goo(back_ctrl, preheader_ctrl, n-&gt;in(i), visited, clones);
1091     if (g != n-&gt;in(i)) {
1092       if (!x) {
1093         assert(clones.find(n-&gt;_idx) == NULL, &quot;dead loop&quot;);
1094         x = n-&gt;clone();
1095         clones.push(x, n-&gt;_idx);
1096       }
1097       x-&gt;set_req(i, g);
1098     }
1099   }
1100   if (x) {                     // x can legally float to pre-header location
1101     register_new_node(x, preheader_ctrl);
1102     return x;
1103   } else {                      // raise n to cover LCA of uses
1104     set_ctrl(n, find_non_split_ctrl(back_ctrl-&gt;in(0)));
1105   }
1106   return n;
1107 }
1108 
1109 Node* PhaseIdealLoop::cast_incr_before_loop(Node* incr, Node* ctrl, Node* loop) {
1110   Node* castii = new CastIINode(incr, TypeInt::INT, true);
1111   castii-&gt;set_req(0, ctrl);
1112   register_new_node(castii, ctrl);
1113   for (DUIterator_Fast imax, i = incr-&gt;fast_outs(imax); i &lt; imax; i++) {
1114     Node* n = incr-&gt;fast_out(i);
1115     if (n-&gt;is_Phi() &amp;&amp; n-&gt;in(0) == loop) {
1116       int nrep = n-&gt;replace_edge(incr, castii);
1117       return castii;
1118     }
1119   }
1120   return NULL;
1121 }
1122 
<a name="1" id="anc1"></a><span class="line-added">1123 #ifdef ASSERT</span>
<span class="line-added">1124 void PhaseIdealLoop::ensure_zero_trip_guard_proj(Node* node, bool is_main_loop) {</span>
<span class="line-added">1125   assert(node-&gt;is_IfProj(), &quot;must be the zero trip guard If node&quot;);</span>
<span class="line-added">1126   Node* zer_bol = node-&gt;in(0)-&gt;in(1);</span>
<span class="line-added">1127   assert(zer_bol != NULL &amp;&amp; zer_bol-&gt;is_Bool(), &quot;must be Bool&quot;);</span>
<span class="line-added">1128   Node* zer_cmp = zer_bol-&gt;in(1);</span>
<span class="line-added">1129   assert(zer_cmp != NULL &amp;&amp; zer_cmp-&gt;Opcode() == Op_CmpI, &quot;must be CmpI&quot;);</span>
<span class="line-added">1130   // For the main loop, the opaque node is the second input to zer_cmp, for the post loop it&#39;s the first input node</span>
<span class="line-added">1131   Node* zer_opaq = zer_cmp-&gt;in(is_main_loop ? 2 : 1);</span>
<span class="line-added">1132   assert(zer_opaq != NULL &amp;&amp; zer_opaq-&gt;Opcode() == Op_Opaque1, &quot;must be Opaque1&quot;);</span>
<span class="line-added">1133 }</span>
<span class="line-added">1134 #endif</span>
<span class="line-added">1135 </span>
1136 // Make a copy of the skeleton range check predicates before the main
1137 // loop and set the initial value of loop as input. After unrolling,
1138 // the range of values for the induction variable in the main loop can
1139 // fall outside the allowed range of values by the array access (main
1140 // loop is never executed). When that happens, range check
1141 // CastII/ConvI2L nodes cause some data paths to die. For consistency,
1142 // the control paths must die too but the range checks were removed by
1143 // predication. The range checks that we add here guarantee that they do.
<a name="2" id="anc2"></a><span class="line-modified">1144 void PhaseIdealLoop::copy_skeleton_predicates_to_main_loop_helper(Node* predicate, Node* start, Node* end,</span>
1145                                                  IdealLoopTree* outer_loop, LoopNode* outer_main_head,
<a name="3" id="anc3"></a><span class="line-modified">1146                                                  uint dd_main_head, const uint idx_before_pre_post,</span>
<span class="line-added">1147                                                  const uint idx_after_post_before_pre, Node* zero_trip_guard_proj_main,</span>
<span class="line-added">1148                                                  Node* zero_trip_guard_proj_post, const Node_List &amp;old_new) {</span>
1149   if (predicate != NULL) {
<a name="4" id="anc4"></a><span class="line-added">1150 #ifdef ASSERT</span>
<span class="line-added">1151     ensure_zero_trip_guard_proj(zero_trip_guard_proj_main, true);</span>
<span class="line-added">1152     ensure_zero_trip_guard_proj(zero_trip_guard_proj_post, false);</span>
<span class="line-added">1153 #endif</span>
1154     IfNode* iff = predicate-&gt;in(0)-&gt;as_If();
1155     ProjNode* uncommon_proj = iff-&gt;proj_out(1 - predicate-&gt;as_Proj()-&gt;_con);
1156     Node* rgn = uncommon_proj-&gt;unique_ctrl_out();
1157     assert(rgn-&gt;is_Region() || rgn-&gt;is_Call(), &quot;must be a region or call uct&quot;);
1158     assert(iff-&gt;in(1)-&gt;in(1)-&gt;Opcode() == Op_Opaque1, &quot;unexpected predicate shape&quot;);
1159     predicate = iff-&gt;in(0);
1160     Node* current_proj = outer_main_head-&gt;in(LoopNode::EntryControl);
1161     Node* prev_proj = current_proj;
1162     while (predicate != NULL &amp;&amp; predicate-&gt;is_Proj() &amp;&amp; predicate-&gt;in(0)-&gt;is_If()) {
1163       iff = predicate-&gt;in(0)-&gt;as_If();
1164       uncommon_proj = iff-&gt;proj_out(1 - predicate-&gt;as_Proj()-&gt;_con);
1165       if (uncommon_proj-&gt;unique_ctrl_out() != rgn)
1166         break;
1167       if (iff-&gt;in(1)-&gt;Opcode() == Op_Opaque4) {
1168         assert(skeleton_predicate_has_opaque(iff), &quot;unexpected&quot;);
<a name="5" id="anc5"></a><span class="line-modified">1169         // Clone the skeleton predicate twice and initialize one with the initial</span>
1170         // value of the loop induction variable. Leave the other predicate
1171         // to be initialized when increasing the stride during loop unrolling.
1172         prev_proj = clone_skeleton_predicate(iff, start, predicate, uncommon_proj, current_proj, outer_loop, prev_proj);
1173         assert(skeleton_predicate_has_opaque(prev_proj-&gt;in(0)-&gt;as_If()) == (start-&gt;Opcode() == Op_Opaque1), &quot;&quot;);
1174         prev_proj = clone_skeleton_predicate(iff, end, predicate, uncommon_proj, current_proj, outer_loop, prev_proj);
1175         assert(skeleton_predicate_has_opaque(prev_proj-&gt;in(0)-&gt;as_If()) == (end-&gt;Opcode() == Op_Opaque1), &quot;&quot;);
<a name="6" id="anc6"></a><span class="line-added">1176 </span>
<span class="line-added">1177         // Rewire any control inputs from the cloned skeleton predicates down to the main and post loop for data nodes that are part of the</span>
<span class="line-added">1178         // main loop (and were cloned to the pre and post loop).</span>
<span class="line-added">1179         for (DUIterator i = predicate-&gt;outs(); predicate-&gt;has_out(i); i++) {</span>
<span class="line-added">1180           Node* loop_node = predicate-&gt;out(i);</span>
<span class="line-added">1181           Node* pre_loop_node = old_new[loop_node-&gt;_idx];</span>
<span class="line-added">1182           // Change the control if &#39;loop_node&#39; is part of the main loop. If there is an old-&gt;new mapping and the index of</span>
<span class="line-added">1183           // &#39;pre_loop_node&#39; is greater than idx_before_pre_post, then we know that &#39;loop_node&#39; was cloned and is part of</span>
<span class="line-added">1184           // the main loop (and &#39;pre_loop_node&#39; is part of the pre loop).</span>
<span class="line-added">1185           if (!loop_node-&gt;is_CFG() &amp;&amp; (pre_loop_node != NULL &amp;&amp; pre_loop_node-&gt;_idx &gt; idx_after_post_before_pre)) {</span>
<span class="line-added">1186             // &#39;loop_node&#39; is a data node and part of the main loop. Rewire the control to the projection of the zero-trip guard if node</span>
<span class="line-added">1187             // of the main loop that is immediately preceding the cloned predicates.</span>
<span class="line-added">1188             _igvn.replace_input_of(loop_node, 0, zero_trip_guard_proj_main);</span>
<span class="line-added">1189             --i;</span>
<span class="line-added">1190           } else if (loop_node-&gt;_idx &gt; idx_before_pre_post &amp;&amp; loop_node-&gt;_idx &lt; idx_after_post_before_pre) {</span>
<span class="line-added">1191             // &#39;loop_node&#39; is a data node and part of the post loop. Rewire the control to the projection of the zero-trip guard if node</span>
<span class="line-added">1192             // of the post loop that is immediately preceding the post loop header node (there are no cloned predicates for the post loop).</span>
<span class="line-added">1193             assert(pre_loop_node == NULL, &quot;a node belonging to the post loop should not have an old_new mapping at this stage&quot;);</span>
<span class="line-added">1194             _igvn.replace_input_of(loop_node, 0, zero_trip_guard_proj_post);</span>
<span class="line-added">1195             --i;</span>
<span class="line-added">1196           }</span>
<span class="line-added">1197         }</span>
<span class="line-added">1198 </span>
1199         // Remove the skeleton predicate from the pre-loop
1200         _igvn.replace_input_of(iff, 1, _igvn.intcon(1));
1201       }
1202       predicate = predicate-&gt;in(0)-&gt;in(0);
1203     }
1204     _igvn.replace_input_of(outer_main_head, LoopNode::EntryControl, prev_proj);
1205     set_idom(outer_main_head, prev_proj, dd_main_head);
1206   }
1207 }
1208 
1209 static bool skeleton_follow_inputs(Node* n, int op) {
1210   return (n-&gt;is_Bool() ||
1211           n-&gt;is_Cmp() ||
1212           op == Op_AndL ||
1213           op == Op_OrL ||
1214           op == Op_RShiftL ||
1215           op == Op_LShiftL ||
1216           op == Op_AddL ||
1217           op == Op_AddI ||
1218           op == Op_MulL ||
1219           op == Op_MulI ||
1220           op == Op_SubL ||
1221           op == Op_SubI ||
1222           op == Op_ConvI2L);
1223 }
1224 
1225 bool PhaseIdealLoop::skeleton_predicate_has_opaque(IfNode* iff) {
1226   ResourceMark rm;
1227   Unique_Node_List wq;
1228   wq.push(iff-&gt;in(1)-&gt;in(1));
1229   for (uint i = 0; i &lt; wq.size(); i++) {
1230     Node* n = wq.at(i);
1231     int op = n-&gt;Opcode();
1232     if (skeleton_follow_inputs(n, op)) {
1233       for (uint j = 1; j &lt; n-&gt;req(); j++) {
1234         Node* m = n-&gt;in(j);
1235         if (m != NULL) {
1236           wq.push(m);
1237         }
1238       }
1239       continue;
1240     }
1241     if (op == Op_Opaque1) {
1242       return true;
1243     }
1244   }
1245   return false;
1246 }
1247 
1248 Node* PhaseIdealLoop::clone_skeleton_predicate(Node* iff, Node* value, Node* predicate, Node* uncommon_proj,
1249                                                Node* current_proj, IdealLoopTree* outer_loop, Node* prev_proj) {
1250   Node_Stack to_clone(2);
1251   to_clone.push(iff-&gt;in(1), 1);
1252   uint current = C-&gt;unique();
1253   Node* result = NULL;
1254   // Look for the opaque node to replace with the new value
1255   // and clone everything in between. We keep the Opaque4 node
1256   // so the duplicated predicates are eliminated once loop
1257   // opts are over: they are here only to keep the IR graph
1258   // consistent.
1259   do {
1260     Node* n = to_clone.node();
1261     uint i = to_clone.index();
1262     Node* m = n-&gt;in(i);
1263     int op = m-&gt;Opcode();
1264     if (skeleton_follow_inputs(m, op)) {
1265         to_clone.push(m, 1);
1266         continue;
1267     }
1268     if (op == Op_Opaque1) {
1269       if (n-&gt;_idx &lt; current) {
1270         n = n-&gt;clone();
1271       }
1272       n-&gt;set_req(i, value);
1273       register_new_node(n, current_proj);
1274       to_clone.set_node(n);
1275     }
1276     for (;;) {
1277       Node* cur = to_clone.node();
1278       uint j = to_clone.index();
1279       if (j+1 &lt; cur-&gt;req()) {
1280         to_clone.set_index(j+1);
1281         break;
1282       }
1283       to_clone.pop();
1284       if (to_clone.size() == 0) {
1285         result = cur;
1286         break;
1287       }
1288       Node* next = to_clone.node();
1289       j = to_clone.index();
1290       if (next-&gt;in(j) != cur) {
1291         assert(cur-&gt;_idx &gt;= current || next-&gt;in(j)-&gt;Opcode() == Op_Opaque1, &quot;new node or Opaque1 being replaced&quot;);
1292         if (next-&gt;_idx &lt; current) {
1293           next = next-&gt;clone();
1294           register_new_node(next, current_proj);
1295           to_clone.set_node(next);
1296         }
1297         next-&gt;set_req(j, cur);
1298       }
1299     }
1300   } while (result == NULL);
1301   assert(result-&gt;_idx &gt;= current, &quot;new node expected&quot;);
1302 
1303   Node* proj = predicate-&gt;clone();
1304   Node* other_proj = uncommon_proj-&gt;clone();
1305   Node* new_iff = iff-&gt;clone();
1306   new_iff-&gt;set_req(1, result);
1307   proj-&gt;set_req(0, new_iff);
1308   other_proj-&gt;set_req(0, new_iff);
1309   Node *frame = new ParmNode(C-&gt;start(), TypeFunc::FramePtr);
1310   register_new_node(frame, C-&gt;start());
1311   // It&#39;s impossible for the predicate to fail at runtime. Use an Halt node.
1312   Node* halt = new HaltNode(other_proj, frame, &quot;duplicated predicate failed which is impossible&quot;);
1313   C-&gt;root()-&gt;add_req(halt);
1314   new_iff-&gt;set_req(0, prev_proj);
1315 
1316   register_control(new_iff, outer_loop-&gt;_parent, prev_proj);
1317   register_control(proj, outer_loop-&gt;_parent, new_iff);
1318   register_control(other_proj, _ltree_root, new_iff);
1319   register_control(halt, _ltree_root, other_proj);
1320   return proj;
1321 }
1322 
<a name="7" id="anc7"></a><span class="line-modified">1323 void PhaseIdealLoop::copy_skeleton_predicates_to_main_loop(CountedLoopNode* pre_head, Node* start, Node* end,</span>
1324                                           IdealLoopTree* outer_loop, LoopNode* outer_main_head,
<a name="8" id="anc8"></a><span class="line-modified">1325                                           uint dd_main_head, const uint idx_before_pre_post,</span>
<span class="line-added">1326                                           const uint idx_after_post_before_pre, Node* zero_trip_guard_proj_main,</span>
<span class="line-added">1327                                           Node* zero_trip_guard_proj_post, const Node_List &amp;old_new) {</span>
1328   if (UseLoopPredicate) {
1329     Node* entry = pre_head-&gt;in(LoopNode::EntryControl);
1330     Node* predicate = NULL;
1331     predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check);
1332     if (predicate != NULL) {
1333       entry = skip_loop_predicates(entry);
1334     }
1335     Node* profile_predicate = NULL;
1336     if (UseProfiledLoopPredicate) {
1337       profile_predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_profile_predicate);
1338       if (profile_predicate != NULL) {
1339         entry = skip_loop_predicates(entry);
1340       }
1341     }
1342     predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_predicate);
<a name="9" id="anc9"></a><span class="line-modified">1343     copy_skeleton_predicates_to_main_loop_helper(predicate, start, end, outer_loop, outer_main_head, dd_main_head,</span>
<span class="line-modified">1344                                                  idx_before_pre_post, idx_after_post_before_pre, zero_trip_guard_proj_main,</span>
<span class="line-added">1345                                                  zero_trip_guard_proj_post, old_new);</span>
<span class="line-added">1346     copy_skeleton_predicates_to_main_loop_helper(profile_predicate, start, end, outer_loop, outer_main_head, dd_main_head,</span>
<span class="line-added">1347                                                  idx_before_pre_post, idx_after_post_before_pre, zero_trip_guard_proj_main,</span>
<span class="line-added">1348                                                  zero_trip_guard_proj_post, old_new);</span>
1349   }
1350 }
1351 
1352 //------------------------------insert_pre_post_loops--------------------------
1353 // Insert pre and post loops.  If peel_only is set, the pre-loop can not have
1354 // more iterations added.  It acts as a &#39;peel&#39; only, no lower-bound RCE, no
1355 // alignment.  Useful to unroll loops that do no array accesses.
1356 void PhaseIdealLoop::insert_pre_post_loops(IdealLoopTree *loop, Node_List &amp;old_new, bool peel_only) {
1357 
1358 #ifndef PRODUCT
1359   if (TraceLoopOpts) {
1360     if (peel_only)
1361       tty-&gt;print(&quot;PeelMainPost &quot;);
1362     else
1363       tty-&gt;print(&quot;PreMainPost  &quot;);
1364     loop-&gt;dump_head();
1365   }
1366 #endif
1367   C-&gt;set_major_progress();
1368 
1369   // Find common pieces of the loop being guarded with pre &amp; post loops
1370   CountedLoopNode *main_head = loop-&gt;_head-&gt;as_CountedLoop();
1371   assert(main_head-&gt;is_normal_loop(), &quot;&quot;);
1372   CountedLoopEndNode *main_end = main_head-&gt;loopexit();
1373   assert(main_end-&gt;outcnt() == 2, &quot;1 true, 1 false path only&quot;);
1374 
1375   Node *pre_header= main_head-&gt;in(LoopNode::EntryControl);
1376   Node *init      = main_head-&gt;init_trip();
1377   Node *incr      = main_end -&gt;incr();
1378   Node *limit     = main_end -&gt;limit();
1379   Node *stride    = main_end -&gt;stride();
1380   Node *cmp       = main_end -&gt;cmp_node();
1381   BoolTest::mask b_test = main_end-&gt;test_trip();
1382 
1383   // Need only 1 user of &#39;bol&#39; because I will be hacking the loop bounds.
1384   Node *bol = main_end-&gt;in(CountedLoopEndNode::TestValue);
1385   if (bol-&gt;outcnt() != 1) {
1386     bol = bol-&gt;clone();
1387     register_new_node(bol,main_end-&gt;in(CountedLoopEndNode::TestControl));
1388     _igvn.replace_input_of(main_end, CountedLoopEndNode::TestValue, bol);
1389   }
1390   // Need only 1 user of &#39;cmp&#39; because I will be hacking the loop bounds.
1391   if (cmp-&gt;outcnt() != 1) {
1392     cmp = cmp-&gt;clone();
1393     register_new_node(cmp,main_end-&gt;in(CountedLoopEndNode::TestControl));
1394     _igvn.replace_input_of(bol, 1, cmp);
1395   }
1396 
1397   // Add the post loop
<a name="10" id="anc10"></a><span class="line-added">1398   const uint idx_before_pre_post = Compile::current()-&gt;unique();</span>
1399   CountedLoopNode *post_head = NULL;
1400   Node *main_exit = insert_post_loop(loop, old_new, main_head, main_end, incr, limit, post_head);
<a name="11" id="anc11"></a><span class="line-added">1401   const uint idx_after_post_before_pre = Compile::current()-&gt;unique();</span>
1402 
1403   //------------------------------
1404   // Step B: Create Pre-Loop.
1405 
1406   // Step B1: Clone the loop body.  The clone becomes the pre-loop.  The main
1407   // loop pre-header illegally has 2 control users (old &amp; new loops).
1408   LoopNode* outer_main_head = main_head;
1409   IdealLoopTree* outer_loop = loop;
1410   if (main_head-&gt;is_strip_mined()) {
1411     main_head-&gt;verify_strip_mined(1);
1412     outer_main_head = main_head-&gt;outer_loop();
1413     outer_loop = loop-&gt;_parent;
1414     assert(outer_loop-&gt;_head == outer_main_head, &quot;broken loop tree&quot;);
1415   }
1416   uint dd_main_head = dom_depth(outer_main_head);
1417   clone_loop(loop, old_new, dd_main_head, ControlAroundStripMined);
1418   CountedLoopNode*    pre_head = old_new[main_head-&gt;_idx]-&gt;as_CountedLoop();
1419   CountedLoopEndNode* pre_end  = old_new[main_end -&gt;_idx]-&gt;as_CountedLoopEnd();
1420   pre_head-&gt;set_pre_loop(main_head);
1421   Node *pre_incr = old_new[incr-&gt;_idx];
1422 
1423   // Reduce the pre-loop trip count.
1424   pre_end-&gt;_prob = PROB_FAIR;
1425 
1426   // Find the pre-loop normal exit.
1427   Node* pre_exit = pre_end-&gt;proj_out(false);
1428   assert(pre_exit-&gt;Opcode() == Op_IfFalse, &quot;&quot;);
1429   IfFalseNode *new_pre_exit = new IfFalseNode(pre_end);
1430   _igvn.register_new_node_with_optimizer(new_pre_exit);
1431   set_idom(new_pre_exit, pre_end, dd_main_head);
1432   set_loop(new_pre_exit, outer_loop-&gt;_parent);
1433 
1434   // Step B2: Build a zero-trip guard for the main-loop.  After leaving the
1435   // pre-loop, the main-loop may not execute at all.  Later in life this
1436   // zero-trip guard will become the minimum-trip guard when we unroll
1437   // the main-loop.
1438   Node *min_opaq = new Opaque1Node(C, limit);
1439   Node *min_cmp  = new CmpINode(pre_incr, min_opaq);
1440   Node *min_bol  = new BoolNode(min_cmp, b_test);
1441   register_new_node(min_opaq, new_pre_exit);
1442   register_new_node(min_cmp , new_pre_exit);
1443   register_new_node(min_bol , new_pre_exit);
1444 
1445   // Build the IfNode (assume the main-loop is executed always).
1446   IfNode *min_iff = new IfNode(new_pre_exit, min_bol, PROB_ALWAYS, COUNT_UNKNOWN);
1447   _igvn.register_new_node_with_optimizer(min_iff);
1448   set_idom(min_iff, new_pre_exit, dd_main_head);
1449   set_loop(min_iff, outer_loop-&gt;_parent);
1450 
1451   // Plug in the false-path, taken if we need to skip main-loop
1452   _igvn.hash_delete(pre_exit);
1453   pre_exit-&gt;set_req(0, min_iff);
1454   set_idom(pre_exit, min_iff, dd_main_head);
1455   set_idom(pre_exit-&gt;unique_ctrl_out(), min_iff, dd_main_head);
1456   // Make the true-path, must enter the main loop
1457   Node *min_taken = new IfTrueNode(min_iff);
1458   _igvn.register_new_node_with_optimizer(min_taken);
1459   set_idom(min_taken, min_iff, dd_main_head);
1460   set_loop(min_taken, outer_loop-&gt;_parent);
1461   // Plug in the true path
1462   _igvn.hash_delete(outer_main_head);
1463   outer_main_head-&gt;set_req(LoopNode::EntryControl, min_taken);
1464   set_idom(outer_main_head, min_taken, dd_main_head);
1465 
1466   Arena *a = Thread::current()-&gt;resource_area();
1467   VectorSet visited(a);
1468   Node_Stack clones(a, main_head-&gt;back_control()-&gt;outcnt());
1469   // Step B3: Make the fall-in values to the main-loop come from the
1470   // fall-out values of the pre-loop.
1471   for (DUIterator_Fast i2max, i2 = main_head-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
1472     Node* main_phi = main_head-&gt;fast_out(i2);
1473     if (main_phi-&gt;is_Phi() &amp;&amp; main_phi-&gt;in(0) == main_head &amp;&amp; main_phi-&gt;outcnt() &gt; 0) {
1474       Node *pre_phi = old_new[main_phi-&gt;_idx];
1475       Node *fallpre  = clone_up_backedge_goo(pre_head-&gt;back_control(),
1476                                              main_head-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl),
1477                                              pre_phi-&gt;in(LoopNode::LoopBackControl),
1478                                              visited, clones);
1479       _igvn.hash_delete(main_phi);
1480       main_phi-&gt;set_req(LoopNode::EntryControl, fallpre);
1481     }
1482   }
1483 
1484   // Nodes inside the loop may be control dependent on a predicate
1485   // that was moved before the preloop. If the back branch of the main
1486   // or post loops becomes dead, those nodes won&#39;t be dependent on the
1487   // test that guards that loop nest anymore which could lead to an
1488   // incorrect array access because it executes independently of the
1489   // test that was guarding the loop nest. We add a special CastII on
1490   // the if branch that enters the loop, between the input induction
1491   // variable value and the induction variable Phi to preserve correct
1492   // dependencies.
1493 
1494   // CastII for the main loop:
1495   Node* castii = cast_incr_before_loop(pre_incr, min_taken, main_head);
1496   assert(castii != NULL, &quot;no castII inserted&quot;);
1497   Node* opaque_castii = new Opaque1Node(C, castii);
1498   register_new_node(opaque_castii, outer_main_head-&gt;in(LoopNode::EntryControl));
<a name="12" id="anc12"></a><span class="line-modified">1499   assert(post_head-&gt;in(1)-&gt;is_IfProj(), &quot;must be zero-trip guard If node projection of the post loop&quot;);</span>
<span class="line-added">1500   copy_skeleton_predicates_to_main_loop(pre_head, castii, opaque_castii, outer_loop, outer_main_head, dd_main_head,</span>
<span class="line-added">1501                                         idx_before_pre_post, idx_after_post_before_pre, min_taken, post_head-&gt;in(1), old_new);</span>
1502 
1503   // Step B4: Shorten the pre-loop to run only 1 iteration (for now).
1504   // RCE and alignment may change this later.
1505   Node *cmp_end = pre_end-&gt;cmp_node();
1506   assert(cmp_end-&gt;in(2) == limit, &quot;&quot;);
1507   Node *pre_limit = new AddINode(init, stride);
1508 
1509   // Save the original loop limit in this Opaque1 node for
1510   // use by range check elimination.
1511   Node *pre_opaq  = new Opaque1Node(C, pre_limit, limit);
1512 
1513   register_new_node(pre_limit, pre_head-&gt;in(0));
1514   register_new_node(pre_opaq , pre_head-&gt;in(0));
1515 
1516   // Since no other users of pre-loop compare, I can hack limit directly
1517   assert(cmp_end-&gt;outcnt() == 1, &quot;no other users&quot;);
1518   _igvn.hash_delete(cmp_end);
1519   cmp_end-&gt;set_req(2, peel_only ? pre_limit : pre_opaq);
1520 
1521   // Special case for not-equal loop bounds:
1522   // Change pre loop test, main loop test, and the
1523   // main loop guard test to use lt or gt depending on stride
1524   // direction:
1525   // positive stride use &lt;
1526   // negative stride use &gt;
1527   //
1528   // not-equal test is kept for post loop to handle case
1529   // when init &gt; limit when stride &gt; 0 (and reverse).
1530 
1531   if (pre_end-&gt;in(CountedLoopEndNode::TestValue)-&gt;as_Bool()-&gt;_test._test == BoolTest::ne) {
1532 
1533     BoolTest::mask new_test = (main_end-&gt;stride_con() &gt; 0) ? BoolTest::lt : BoolTest::gt;
1534     // Modify pre loop end condition
1535     Node* pre_bol = pre_end-&gt;in(CountedLoopEndNode::TestValue)-&gt;as_Bool();
1536     BoolNode* new_bol0 = new BoolNode(pre_bol-&gt;in(1), new_test);
1537     register_new_node(new_bol0, pre_head-&gt;in(0));
1538     _igvn.replace_input_of(pre_end, CountedLoopEndNode::TestValue, new_bol0);
1539     // Modify main loop guard condition
1540     assert(min_iff-&gt;in(CountedLoopEndNode::TestValue) == min_bol, &quot;guard okay&quot;);
1541     BoolNode* new_bol1 = new BoolNode(min_bol-&gt;in(1), new_test);
1542     register_new_node(new_bol1, new_pre_exit);
1543     _igvn.hash_delete(min_iff);
1544     min_iff-&gt;set_req(CountedLoopEndNode::TestValue, new_bol1);
1545     // Modify main loop end condition
1546     BoolNode* main_bol = main_end-&gt;in(CountedLoopEndNode::TestValue)-&gt;as_Bool();
1547     BoolNode* new_bol2 = new BoolNode(main_bol-&gt;in(1), new_test);
1548     register_new_node(new_bol2, main_end-&gt;in(CountedLoopEndNode::TestControl));
1549     _igvn.replace_input_of(main_end, CountedLoopEndNode::TestValue, new_bol2);
1550   }
1551 
1552   // Flag main loop
1553   main_head-&gt;set_main_loop();
1554   if (peel_only) {
1555     main_head-&gt;set_main_no_pre_loop();
1556   }
1557 
1558   // Subtract a trip count for the pre-loop.
1559   main_head-&gt;set_trip_count(main_head-&gt;trip_count() - 1);
1560 
1561   // It&#39;s difficult to be precise about the trip-counts
1562   // for the pre/post loops.  They are usually very short,
1563   // so guess that 4 trips is a reasonable value.
1564   post_head-&gt;set_profile_trip_cnt(4.0);
1565   pre_head-&gt;set_profile_trip_cnt(4.0);
1566 
1567   // Now force out all loop-invariant dominating tests.  The optimizer
1568   // finds some, but we _know_ they are all useless.
1569   peeled_dom_test_elim(loop,old_new);
1570   loop-&gt;record_for_igvn();
1571 }
1572 
1573 //------------------------------insert_vector_post_loop------------------------
1574 // Insert a copy of the atomic unrolled vectorized main loop as a post loop,
1575 // unroll_policy has  already informed  us that more  unrolling is  about to
1576 // happen  to the  main  loop.  The  resultant  post loop  will  serve as  a
1577 // vectorized drain loop.
1578 void PhaseIdealLoop::insert_vector_post_loop(IdealLoopTree *loop, Node_List &amp;old_new) {
1579   if (!loop-&gt;_head-&gt;is_CountedLoop()) return;
1580 
1581   CountedLoopNode *cl = loop-&gt;_head-&gt;as_CountedLoop();
1582 
1583   // only process vectorized main loops
1584   if (!cl-&gt;is_vectorized_loop() || !cl-&gt;is_main_loop()) return;
1585 
1586   int slp_max_unroll_factor = cl-&gt;slp_max_unroll();
1587   int cur_unroll = cl-&gt;unrolled_count();
1588 
1589   if (slp_max_unroll_factor == 0) return;
1590 
1591   // only process atomic unroll vector loops (not super unrolled after vectorization)
1592   if (cur_unroll != slp_max_unroll_factor) return;
1593 
1594   // we only ever process this one time
1595   if (cl-&gt;has_atomic_post_loop()) return;
1596 
1597   if (!may_require_nodes(loop-&gt;est_loop_clone_sz(2))) {
1598     return;
1599   }
1600 
1601 #ifndef PRODUCT
1602   if (TraceLoopOpts) {
1603     tty-&gt;print(&quot;PostVector  &quot;);
1604     loop-&gt;dump_head();
1605   }
1606 #endif
1607   C-&gt;set_major_progress();
1608 
1609   // Find common pieces of the loop being guarded with pre &amp; post loops
1610   CountedLoopNode *main_head = loop-&gt;_head-&gt;as_CountedLoop();
1611   CountedLoopEndNode *main_end = main_head-&gt;loopexit();
1612   // diagnostic to show loop end is not properly formed
1613   assert(main_end-&gt;outcnt() == 2, &quot;1 true, 1 false path only&quot;);
1614 
1615   // mark this loop as processed
1616   main_head-&gt;mark_has_atomic_post_loop();
1617 
1618   Node *incr = main_end-&gt;incr();
1619   Node *limit = main_end-&gt;limit();
1620 
1621   // In this case we throw away the result as we are not using it to connect anything else.
1622   CountedLoopNode *post_head = NULL;
1623   insert_post_loop(loop, old_new, main_head, main_end, incr, limit, post_head);
1624 
1625   // It&#39;s difficult to be precise about the trip-counts
1626   // for post loops.  They are usually very short,
1627   // so guess that unit vector trips is a reasonable value.
1628   post_head-&gt;set_profile_trip_cnt(cur_unroll);
1629 
1630   // Now force out all loop-invariant dominating tests.  The optimizer
1631   // finds some, but we _know_ they are all useless.
1632   peeled_dom_test_elim(loop, old_new);
1633   loop-&gt;record_for_igvn();
1634 }
1635 
1636 
1637 //-------------------------insert_scalar_rced_post_loop------------------------
1638 // Insert a copy of the rce&#39;d main loop as a post loop,
1639 // We have not unrolled the main loop, so this is the right time to inject this.
1640 // Later we will examine the partner of this post loop pair which still has range checks
1641 // to see inject code which tests at runtime if the range checks are applicable.
1642 void PhaseIdealLoop::insert_scalar_rced_post_loop(IdealLoopTree *loop, Node_List &amp;old_new) {
1643   if (!loop-&gt;_head-&gt;is_CountedLoop()) return;
1644 
1645   CountedLoopNode *cl = loop-&gt;_head-&gt;as_CountedLoop();
1646 
1647   // only process RCE&#39;d main loops
1648   if (!cl-&gt;is_main_loop() || cl-&gt;range_checks_present()) return;
1649 
1650 #ifndef PRODUCT
1651   if (TraceLoopOpts) {
1652     tty-&gt;print(&quot;PostScalarRce  &quot;);
1653     loop-&gt;dump_head();
1654   }
1655 #endif
1656   C-&gt;set_major_progress();
1657 
1658   // Find common pieces of the loop being guarded with pre &amp; post loops
1659   CountedLoopNode *main_head = loop-&gt;_head-&gt;as_CountedLoop();
1660   CountedLoopEndNode *main_end = main_head-&gt;loopexit();
1661   // diagnostic to show loop end is not properly formed
1662   assert(main_end-&gt;outcnt() == 2, &quot;1 true, 1 false path only&quot;);
1663 
1664   Node *incr = main_end-&gt;incr();
1665   Node *limit = main_end-&gt;limit();
1666 
1667   // In this case we throw away the result as we are not using it to connect anything else.
1668   CountedLoopNode *post_head = NULL;
1669   insert_post_loop(loop, old_new, main_head, main_end, incr, limit, post_head);
1670 
1671   // It&#39;s difficult to be precise about the trip-counts
1672   // for post loops.  They are usually very short,
1673   // so guess that unit vector trips is a reasonable value.
1674   post_head-&gt;set_profile_trip_cnt(4.0);
1675   post_head-&gt;set_is_rce_post_loop();
1676 
1677   // Now force out all loop-invariant dominating tests.  The optimizer
1678   // finds some, but we _know_ they are all useless.
1679   peeled_dom_test_elim(loop, old_new);
1680   loop-&gt;record_for_igvn();
1681 }
1682 
1683 
1684 //------------------------------insert_post_loop-------------------------------
1685 // Insert post loops.  Add a post loop to the given loop passed.
1686 Node *PhaseIdealLoop::insert_post_loop(IdealLoopTree *loop, Node_List &amp;old_new,
1687                                        CountedLoopNode *main_head, CountedLoopEndNode *main_end,
1688                                        Node *incr, Node *limit, CountedLoopNode *&amp;post_head) {
1689   IfNode* outer_main_end = main_end;
1690   IdealLoopTree* outer_loop = loop;
1691   if (main_head-&gt;is_strip_mined()) {
1692     main_head-&gt;verify_strip_mined(1);
1693     outer_main_end = main_head-&gt;outer_loop_end();
1694     outer_loop = loop-&gt;_parent;
1695     assert(outer_loop-&gt;_head == main_head-&gt;in(LoopNode::EntryControl), &quot;broken loop tree&quot;);
1696   }
1697 
1698   //------------------------------
1699   // Step A: Create a new post-Loop.
1700   Node* main_exit = outer_main_end-&gt;proj_out(false);
1701   assert(main_exit-&gt;Opcode() == Op_IfFalse, &quot;&quot;);
1702   int dd_main_exit = dom_depth(main_exit);
1703 
1704   // Step A1: Clone the loop body of main. The clone becomes the post-loop.
1705   // The main loop pre-header illegally has 2 control users (old &amp; new loops).
1706   clone_loop(loop, old_new, dd_main_exit, ControlAroundStripMined);
1707   assert(old_new[main_end-&gt;_idx]-&gt;Opcode() == Op_CountedLoopEnd, &quot;&quot;);
1708   post_head = old_new[main_head-&gt;_idx]-&gt;as_CountedLoop();
1709   post_head-&gt;set_normal_loop();
1710   post_head-&gt;set_post_loop(main_head);
1711 
1712   // Reduce the post-loop trip count.
1713   CountedLoopEndNode* post_end = old_new[main_end-&gt;_idx]-&gt;as_CountedLoopEnd();
1714   post_end-&gt;_prob = PROB_FAIR;
1715 
1716   // Build the main-loop normal exit.
1717   IfFalseNode *new_main_exit = new IfFalseNode(outer_main_end);
1718   _igvn.register_new_node_with_optimizer(new_main_exit);
1719   set_idom(new_main_exit, outer_main_end, dd_main_exit);
1720   set_loop(new_main_exit, outer_loop-&gt;_parent);
1721 
1722   // Step A2: Build a zero-trip guard for the post-loop.  After leaving the
1723   // main-loop, the post-loop may not execute at all.  We &#39;opaque&#39; the incr
1724   // (the previous loop trip-counter exit value) because we will be changing
1725   // the exit value (via additional unrolling) so we cannot constant-fold away the zero
1726   // trip guard until all unrolling is done.
1727   Node *zer_opaq = new Opaque1Node(C, incr);
1728   Node *zer_cmp = new CmpINode(zer_opaq, limit);
1729   Node *zer_bol = new BoolNode(zer_cmp, main_end-&gt;test_trip());
1730   register_new_node(zer_opaq, new_main_exit);
1731   register_new_node(zer_cmp, new_main_exit);
1732   register_new_node(zer_bol, new_main_exit);
1733 
1734   // Build the IfNode
1735   IfNode *zer_iff = new IfNode(new_main_exit, zer_bol, PROB_FAIR, COUNT_UNKNOWN);
1736   _igvn.register_new_node_with_optimizer(zer_iff);
1737   set_idom(zer_iff, new_main_exit, dd_main_exit);
1738   set_loop(zer_iff, outer_loop-&gt;_parent);
1739 
1740   // Plug in the false-path, taken if we need to skip this post-loop
1741   _igvn.replace_input_of(main_exit, 0, zer_iff);
1742   set_idom(main_exit, zer_iff, dd_main_exit);
1743   set_idom(main_exit-&gt;unique_out(), zer_iff, dd_main_exit);
1744   // Make the true-path, must enter this post loop
1745   Node *zer_taken = new IfTrueNode(zer_iff);
1746   _igvn.register_new_node_with_optimizer(zer_taken);
1747   set_idom(zer_taken, zer_iff, dd_main_exit);
1748   set_loop(zer_taken, outer_loop-&gt;_parent);
1749   // Plug in the true path
1750   _igvn.hash_delete(post_head);
1751   post_head-&gt;set_req(LoopNode::EntryControl, zer_taken);
1752   set_idom(post_head, zer_taken, dd_main_exit);
1753 
1754   Arena *a = Thread::current()-&gt;resource_area();
1755   VectorSet visited(a);
1756   Node_Stack clones(a, main_head-&gt;back_control()-&gt;outcnt());
1757   // Step A3: Make the fall-in values to the post-loop come from the
1758   // fall-out values of the main-loop.
1759   for (DUIterator_Fast imax, i = main_head-&gt;fast_outs(imax); i &lt; imax; i++) {
1760     Node* main_phi = main_head-&gt;fast_out(i);
1761     if (main_phi-&gt;is_Phi() &amp;&amp; main_phi-&gt;in(0) == main_head &amp;&amp; main_phi-&gt;outcnt() &gt; 0) {
1762       Node *cur_phi = old_new[main_phi-&gt;_idx];
1763       Node *fallnew = clone_up_backedge_goo(main_head-&gt;back_control(),
1764                                             post_head-&gt;init_control(),
1765                                             main_phi-&gt;in(LoopNode::LoopBackControl),
1766                                             visited, clones);
1767       _igvn.hash_delete(cur_phi);
1768       cur_phi-&gt;set_req(LoopNode::EntryControl, fallnew);
1769     }
1770   }
1771 
1772   // CastII for the new post loop:
1773   Node* castii = cast_incr_before_loop(zer_opaq-&gt;in(1), zer_taken, post_head);
1774   assert(castii != NULL, &quot;no castII inserted&quot;);
1775 
1776   return new_main_exit;
1777 }
1778 
1779 //------------------------------is_invariant-----------------------------
1780 // Return true if n is invariant
1781 bool IdealLoopTree::is_invariant(Node* n) const {
1782   Node *n_c = _phase-&gt;has_ctrl(n) ? _phase-&gt;get_ctrl(n) : n;
1783   if (n_c-&gt;is_top()) return false;
1784   return !is_member(_phase-&gt;get_loop(n_c));
1785 }
1786 
<a name="13" id="anc13"></a><span class="line-modified">1787 void PhaseIdealLoop::update_main_loop_skeleton_predicates(Node* ctrl, CountedLoopNode* loop_head, Node* init, int stride_con) {</span>
1788   // Search for skeleton predicates and update them according to the new stride
1789   Node* entry = ctrl;
1790   Node* prev_proj = ctrl;
1791   LoopNode* outer_loop_head = loop_head-&gt;skip_strip_mined();
1792   IdealLoopTree* outer_loop = get_loop(outer_loop_head);
1793   while (entry != NULL &amp;&amp; entry-&gt;is_Proj() &amp;&amp; entry-&gt;in(0)-&gt;is_If()) {
1794     IfNode* iff = entry-&gt;in(0)-&gt;as_If();
1795     ProjNode* proj = iff-&gt;proj_out(1 - entry-&gt;as_Proj()-&gt;_con);
1796     if (proj-&gt;unique_ctrl_out()-&gt;Opcode() != Op_Halt) {
1797       break;
1798     }
1799     if (iff-&gt;in(1)-&gt;Opcode() == Op_Opaque4) {
1800       // Look for predicate with an Opaque1 node that can be used as a template
1801       if (!skeleton_predicate_has_opaque(iff)) {
1802         // No Opaque1 node? It&#39;s either the check for the first value
1803         // of the first iteration or the check for the last value of
1804         // the first iteration of an unrolled loop. We can&#39;t
1805         // tell. Kill it in any case.
1806         _igvn.replace_input_of(iff, 1, iff-&gt;in(1)-&gt;in(2));
1807       } else {
1808         // Add back the predicate for the value at the beginning of the first entry
1809         prev_proj = clone_skeleton_predicate(iff, init, entry, proj, ctrl, outer_loop, prev_proj);
1810         assert(!skeleton_predicate_has_opaque(prev_proj-&gt;in(0)-&gt;as_If()), &quot;unexpected&quot;);
1811         // Compute the value of the loop induction variable at the end of the
1812         // first iteration of the unrolled loop: init + new_stride_con - init_inc
1813         int init_inc = stride_con/loop_head-&gt;unrolled_count();
1814         assert(init_inc != 0, &quot;invalid loop increment&quot;);
1815         int new_stride_con = stride_con * 2;
1816         Node* max_value = _igvn.intcon(new_stride_con - init_inc);
1817         max_value = new AddINode(init, max_value);
1818         register_new_node(max_value, get_ctrl(iff-&gt;in(1)));
1819         prev_proj = clone_skeleton_predicate(iff, max_value, entry, proj, ctrl, outer_loop, prev_proj);
1820         assert(!skeleton_predicate_has_opaque(prev_proj-&gt;in(0)-&gt;as_If()), &quot;unexpected&quot;);
1821       }
1822     }
1823     entry = entry-&gt;in(0)-&gt;in(0);
1824   }
1825   if (prev_proj != ctrl) {
1826     _igvn.replace_input_of(outer_loop_head, LoopNode::EntryControl, prev_proj);
1827     set_idom(outer_loop_head, prev_proj, dom_depth(outer_loop_head));
1828   }
1829 }
1830 
1831 //------------------------------do_unroll--------------------------------------
1832 // Unroll the loop body one step - make each trip do 2 iterations.
1833 void PhaseIdealLoop::do_unroll(IdealLoopTree *loop, Node_List &amp;old_new, bool adjust_min_trip) {
1834   assert(LoopUnrollLimit, &quot;&quot;);
1835   CountedLoopNode *loop_head = loop-&gt;_head-&gt;as_CountedLoop();
1836   CountedLoopEndNode *loop_end = loop_head-&gt;loopexit();
1837 #ifndef PRODUCT
1838   if (PrintOpto &amp;&amp; VerifyLoopOptimizations) {
1839     tty-&gt;print(&quot;Unrolling &quot;);
1840     loop-&gt;dump_head();
1841   } else if (TraceLoopOpts) {
1842     if (loop_head-&gt;trip_count() &lt; (uint)LoopUnrollLimit) {
1843       tty-&gt;print(&quot;Unroll %d(%2d) &quot;, loop_head-&gt;unrolled_count()*2, loop_head-&gt;trip_count());
1844     } else {
1845       tty-&gt;print(&quot;Unroll %d     &quot;, loop_head-&gt;unrolled_count()*2);
1846     }
1847     loop-&gt;dump_head();
1848   }
1849 
1850   if (C-&gt;do_vector_loop() &amp;&amp; (PrintOpto &amp;&amp; (VerifyLoopOptimizations || TraceLoopOpts))) {
1851     Arena* arena = Thread::current()-&gt;resource_area();
1852     Node_Stack stack(arena, C-&gt;live_nodes() &gt;&gt; 2);
1853     Node_List rpo_list;
1854     VectorSet visited(arena);
1855     visited.set(loop_head-&gt;_idx);
1856     rpo(loop_head, stack, visited, rpo_list);
1857     dump(loop, rpo_list.size(), rpo_list);
1858   }
1859 #endif
1860 
1861   // Remember loop node count before unrolling to detect
1862   // if rounds of unroll,optimize are making progress
1863   loop_head-&gt;set_node_count_before_unroll(loop-&gt;_body.size());
1864 
1865   Node *ctrl  = loop_head-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl);
1866   Node *limit = loop_head-&gt;limit();
1867   Node *init  = loop_head-&gt;init_trip();
1868   Node *stride = loop_head-&gt;stride();
1869 
1870   Node *opaq = NULL;
1871   if (adjust_min_trip) {       // If not maximally unrolling, need adjustment
1872     // Search for zero-trip guard.
1873 
1874     // Check the shape of the graph at the loop entry. If an inappropriate
1875     // graph shape is encountered, the compiler bails out loop unrolling;
1876     // compilation of the method will still succeed.
1877     if (!is_canonical_loop_entry(loop_head)) {
1878       return;
1879     }
1880     opaq = loop_head-&gt;skip_predicates()-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(2);
1881     // Zero-trip test uses an &#39;opaque&#39; node which is not shared.
1882     assert(opaq-&gt;outcnt() == 1 &amp;&amp; opaq-&gt;in(1) == limit, &quot;&quot;);
1883   }
1884 
1885   C-&gt;set_major_progress();
1886 
1887   Node* new_limit = NULL;
1888   int stride_con = stride-&gt;get_int();
1889   int stride_p = (stride_con &gt; 0) ? stride_con : -stride_con;
1890   uint old_trip_count = loop_head-&gt;trip_count();
1891   // Verify that unroll policy result is still valid.
1892   assert(old_trip_count &gt; 1 &amp;&amp;
1893       (!adjust_min_trip || stride_p &lt;= (1&lt;&lt;3)*loop_head-&gt;unrolled_count()), &quot;sanity&quot;);
1894 
<a name="14" id="anc14"></a><span class="line-modified">1895   update_main_loop_skeleton_predicates(ctrl, loop_head, init, stride_con);</span>
1896 
1897   // Adjust loop limit to keep valid iterations number after unroll.
1898   // Use (limit - stride) instead of (((limit - init)/stride) &amp; (-2))*stride
1899   // which may overflow.
1900   if (!adjust_min_trip) {
1901     assert(old_trip_count &gt; 1 &amp;&amp; (old_trip_count &amp; 1) == 0,
1902         &quot;odd trip count for maximally unroll&quot;);
1903     // Don&#39;t need to adjust limit for maximally unroll since trip count is even.
1904   } else if (loop_head-&gt;has_exact_trip_count() &amp;&amp; init-&gt;is_Con()) {
1905     // Loop&#39;s limit is constant. Loop&#39;s init could be constant when pre-loop
1906     // become peeled iteration.
1907     jlong init_con = init-&gt;get_int();
1908     // We can keep old loop limit if iterations count stays the same:
1909     //   old_trip_count == new_trip_count * 2
1910     // Note: since old_trip_count &gt;= 2 then new_trip_count &gt;= 1
1911     // so we also don&#39;t need to adjust zero trip test.
1912     jlong limit_con  = limit-&gt;get_int();
1913     // (stride_con*2) not overflow since stride_con &lt;= 8.
1914     int new_stride_con = stride_con * 2;
1915     int stride_m    = new_stride_con - (stride_con &gt; 0 ? 1 : -1);
1916     jlong trip_count = (limit_con - init_con + stride_m)/new_stride_con;
1917     // New trip count should satisfy next conditions.
1918     assert(trip_count &gt; 0 &amp;&amp; (julong)trip_count &lt; (julong)max_juint/2, &quot;sanity&quot;);
1919     uint new_trip_count = (uint)trip_count;
1920     adjust_min_trip = (old_trip_count != new_trip_count*2);
1921   }
1922 
1923   if (adjust_min_trip) {
1924     // Step 2: Adjust the trip limit if it is called for.
1925     // The adjustment amount is -stride. Need to make sure if the
1926     // adjustment underflows or overflows, then the main loop is skipped.
1927     Node* cmp = loop_end-&gt;cmp_node();
1928     assert(cmp-&gt;in(2) == limit, &quot;sanity&quot;);
1929     assert(opaq != NULL &amp;&amp; opaq-&gt;in(1) == limit, &quot;sanity&quot;);
1930 
1931     // Verify that policy_unroll result is still valid.
1932     const TypeInt* limit_type = _igvn.type(limit)-&gt;is_int();
1933     assert(stride_con &gt; 0 &amp;&amp; ((limit_type-&gt;_hi - stride_con) &lt; limit_type-&gt;_hi) ||
1934            stride_con &lt; 0 &amp;&amp; ((limit_type-&gt;_lo - stride_con) &gt; limit_type-&gt;_lo),
1935            &quot;sanity&quot;);
1936 
1937     if (limit-&gt;is_Con()) {
1938       // The check in policy_unroll and the assert above guarantee
1939       // no underflow if limit is constant.
1940       new_limit = _igvn.intcon(limit-&gt;get_int() - stride_con);
1941       set_ctrl(new_limit, C-&gt;root());
1942     } else {
1943       // Limit is not constant.
1944       if (loop_head-&gt;unrolled_count() == 1) { // only for first unroll
1945         // Separate limit by Opaque node in case it is an incremented
1946         // variable from previous loop to avoid using pre-incremented
1947         // value which could increase register pressure.
1948         // Otherwise reorg_offsets() optimization will create a separate
1949         // Opaque node for each use of trip-counter and as result
1950         // zero trip guard limit will be different from loop limit.
1951         assert(has_ctrl(opaq), &quot;should have it&quot;);
1952         Node* opaq_ctrl = get_ctrl(opaq);
1953         limit = new Opaque2Node(C, limit);
1954         register_new_node(limit, opaq_ctrl);
1955       }
1956       if ((stride_con &gt; 0 &amp;&amp; (java_subtract(limit_type-&gt;_lo, stride_con) &lt; limit_type-&gt;_lo)) ||
1957           (stride_con &lt; 0 &amp;&amp; (java_subtract(limit_type-&gt;_hi, stride_con) &gt; limit_type-&gt;_hi))) {
1958         // No underflow.
1959         new_limit = new SubINode(limit, stride);
1960       } else {
1961         // (limit - stride) may underflow.
1962         // Clamp the adjustment value with MININT or MAXINT:
1963         //
1964         //   new_limit = limit-stride
1965         //   if (stride &gt; 0)
1966         //     new_limit = (limit &lt; new_limit) ? MININT : new_limit;
1967         //   else
1968         //     new_limit = (limit &gt; new_limit) ? MAXINT : new_limit;
1969         //
1970         BoolTest::mask bt = loop_end-&gt;test_trip();
1971         assert(bt == BoolTest::lt || bt == BoolTest::gt, &quot;canonical test is expected&quot;);
1972         Node* adj_max = _igvn.intcon((stride_con &gt; 0) ? min_jint : max_jint);
1973         set_ctrl(adj_max, C-&gt;root());
1974         Node* old_limit = NULL;
1975         Node* adj_limit = NULL;
1976         Node* bol = limit-&gt;is_CMove() ? limit-&gt;in(CMoveNode::Condition) : NULL;
1977         if (loop_head-&gt;unrolled_count() &gt; 1 &amp;&amp;
1978             limit-&gt;is_CMove() &amp;&amp; limit-&gt;Opcode() == Op_CMoveI &amp;&amp;
1979             limit-&gt;in(CMoveNode::IfTrue) == adj_max &amp;&amp;
1980             bol-&gt;as_Bool()-&gt;_test._test == bt &amp;&amp;
1981             bol-&gt;in(1)-&gt;Opcode() == Op_CmpI &amp;&amp;
1982             bol-&gt;in(1)-&gt;in(2) == limit-&gt;in(CMoveNode::IfFalse)) {
1983           // Loop was unrolled before.
1984           // Optimize the limit to avoid nested CMove:
1985           // use original limit as old limit.
1986           old_limit = bol-&gt;in(1)-&gt;in(1);
1987           // Adjust previous adjusted limit.
1988           adj_limit = limit-&gt;in(CMoveNode::IfFalse);
1989           adj_limit = new SubINode(adj_limit, stride);
1990         } else {
1991           old_limit = limit;
1992           adj_limit = new SubINode(limit, stride);
1993         }
1994         assert(old_limit != NULL &amp;&amp; adj_limit != NULL, &quot;&quot;);
1995         register_new_node(adj_limit, ctrl); // adjust amount
1996         Node* adj_cmp = new CmpINode(old_limit, adj_limit);
1997         register_new_node(adj_cmp, ctrl);
1998         Node* adj_bool = new BoolNode(adj_cmp, bt);
1999         register_new_node(adj_bool, ctrl);
2000         new_limit = new CMoveINode(adj_bool, adj_limit, adj_max, TypeInt::INT);
2001       }
2002       register_new_node(new_limit, ctrl);
2003     }
2004 
2005     assert(new_limit != NULL, &quot;&quot;);
2006     // Replace in loop test.
2007     assert(loop_end-&gt;in(1)-&gt;in(1) == cmp, &quot;sanity&quot;);
2008     if (cmp-&gt;outcnt() == 1 &amp;&amp; loop_end-&gt;in(1)-&gt;outcnt() == 1) {
2009       // Don&#39;t need to create new test since only one user.
2010       _igvn.hash_delete(cmp);
2011       cmp-&gt;set_req(2, new_limit);
2012     } else {
2013       // Create new test since it is shared.
2014       Node* ctrl2 = loop_end-&gt;in(0);
2015       Node* cmp2  = cmp-&gt;clone();
2016       cmp2-&gt;set_req(2, new_limit);
2017       register_new_node(cmp2, ctrl2);
2018       Node* bol2 = loop_end-&gt;in(1)-&gt;clone();
2019       bol2-&gt;set_req(1, cmp2);
2020       register_new_node(bol2, ctrl2);
2021       _igvn.replace_input_of(loop_end, 1, bol2);
2022     }
2023     // Step 3: Find the min-trip test guaranteed before a &#39;main&#39; loop.
2024     // Make it a 1-trip test (means at least 2 trips).
2025 
2026     // Guard test uses an &#39;opaque&#39; node which is not shared.  Hence I
2027     // can edit it&#39;s inputs directly.  Hammer in the new limit for the
2028     // minimum-trip guard.
2029     assert(opaq-&gt;outcnt() == 1, &quot;&quot;);
2030     _igvn.replace_input_of(opaq, 1, new_limit);
2031   }
2032 
2033   // Adjust max trip count. The trip count is intentionally rounded
2034   // down here (e.g. 15-&gt; 7-&gt; 3-&gt; 1) because if we unwittingly over-unroll,
2035   // the main, unrolled, part of the loop will never execute as it is protected
2036   // by the min-trip test.  See bug 4834191 for a case where we over-unrolled
2037   // and later determined that part of the unrolled loop was dead.
2038   loop_head-&gt;set_trip_count(old_trip_count / 2);
2039 
2040   // Double the count of original iterations in the unrolled loop body.
2041   loop_head-&gt;double_unrolled_count();
2042 
2043   // ---------
2044   // Step 4: Clone the loop body.  Move it inside the loop.  This loop body
2045   // represents the odd iterations; since the loop trips an even number of
2046   // times its backedge is never taken.  Kill the backedge.
2047   uint dd = dom_depth(loop_head);
2048   clone_loop(loop, old_new, dd, IgnoreStripMined);
2049 
2050   // Make backedges of the clone equal to backedges of the original.
2051   // Make the fall-in from the original come from the fall-out of the clone.
2052   for (DUIterator_Fast jmax, j = loop_head-&gt;fast_outs(jmax); j &lt; jmax; j++) {
2053     Node* phi = loop_head-&gt;fast_out(j);
2054     if (phi-&gt;is_Phi() &amp;&amp; phi-&gt;in(0) == loop_head &amp;&amp; phi-&gt;outcnt() &gt; 0) {
2055       Node *newphi = old_new[phi-&gt;_idx];
2056       _igvn.hash_delete(phi);
2057       _igvn.hash_delete(newphi);
2058 
2059       phi   -&gt;set_req(LoopNode::   EntryControl, newphi-&gt;in(LoopNode::LoopBackControl));
2060       newphi-&gt;set_req(LoopNode::LoopBackControl, phi   -&gt;in(LoopNode::LoopBackControl));
2061       phi   -&gt;set_req(LoopNode::LoopBackControl, C-&gt;top());
2062     }
2063   }
2064   Node *clone_head = old_new[loop_head-&gt;_idx];
2065   _igvn.hash_delete(clone_head);
2066   loop_head -&gt;set_req(LoopNode::   EntryControl, clone_head-&gt;in(LoopNode::LoopBackControl));
2067   clone_head-&gt;set_req(LoopNode::LoopBackControl, loop_head -&gt;in(LoopNode::LoopBackControl));
2068   loop_head -&gt;set_req(LoopNode::LoopBackControl, C-&gt;top());
2069   loop-&gt;_head = clone_head;     // New loop header
2070 
2071   set_idom(loop_head,  loop_head -&gt;in(LoopNode::EntryControl), dd);
2072   set_idom(clone_head, clone_head-&gt;in(LoopNode::EntryControl), dd);
2073 
2074   // Kill the clone&#39;s backedge
2075   Node *newcle = old_new[loop_end-&gt;_idx];
2076   _igvn.hash_delete(newcle);
2077   Node *one = _igvn.intcon(1);
2078   set_ctrl(one, C-&gt;root());
2079   newcle-&gt;set_req(1, one);
2080   // Force clone into same loop body
2081   uint max = loop-&gt;_body.size();
2082   for (uint k = 0; k &lt; max; k++) {
2083     Node *old = loop-&gt;_body.at(k);
2084     Node *nnn = old_new[old-&gt;_idx];
2085     loop-&gt;_body.push(nnn);
2086     if (!has_ctrl(old)) {
2087       set_loop(nnn, loop);
2088     }
2089   }
2090 
2091   loop-&gt;record_for_igvn();
2092   loop_head-&gt;clear_strip_mined();
2093 
2094 #ifndef PRODUCT
2095   if (C-&gt;do_vector_loop() &amp;&amp; (PrintOpto &amp;&amp; (VerifyLoopOptimizations || TraceLoopOpts))) {
2096     tty-&gt;print(&quot;\nnew loop after unroll\n&quot;);       loop-&gt;dump_head();
2097     for (uint i = 0; i &lt; loop-&gt;_body.size(); i++) {
2098       loop-&gt;_body.at(i)-&gt;dump();
2099     }
2100     if (C-&gt;clone_map().is_debug()) {
2101       tty-&gt;print(&quot;\nCloneMap\n&quot;);
2102       Dict* dict = C-&gt;clone_map().dict();
2103       DictI i(dict);
2104       tty-&gt;print_cr(&quot;Dict@%p[%d] = &quot;, dict, dict-&gt;Size());
2105       for (int ii = 0; i.test(); ++i, ++ii) {
2106         NodeCloneInfo cl((uint64_t)dict-&gt;operator[]((void*)i._key));
2107         tty-&gt;print(&quot;%d-&gt;%d:%d,&quot;, (int)(intptr_t)i._key, cl.idx(), cl.gen());
2108         if (ii % 10 == 9) {
2109           tty-&gt;print_cr(&quot; &quot;);
2110         }
2111       }
2112       tty-&gt;print_cr(&quot; &quot;);
2113     }
2114   }
2115 #endif
2116 }
2117 
2118 //------------------------------do_maximally_unroll----------------------------
2119 
2120 void PhaseIdealLoop::do_maximally_unroll(IdealLoopTree *loop, Node_List &amp;old_new) {
2121   CountedLoopNode *cl = loop-&gt;_head-&gt;as_CountedLoop();
2122   assert(cl-&gt;has_exact_trip_count(), &quot;trip count is not exact&quot;);
2123   assert(cl-&gt;trip_count() &gt; 0, &quot;&quot;);
2124 #ifndef PRODUCT
2125   if (TraceLoopOpts) {
2126     tty-&gt;print(&quot;MaxUnroll  %d &quot;, cl-&gt;trip_count());
2127     loop-&gt;dump_head();
2128   }
2129 #endif
2130 
2131   // If loop is tripping an odd number of times, peel odd iteration
2132   if ((cl-&gt;trip_count() &amp; 1) == 1) {
2133     do_peeling(loop, old_new);
2134   }
2135 
2136   // Now its tripping an even number of times remaining.  Double loop body.
2137   // Do not adjust pre-guards; they are not needed and do not exist.
2138   if (cl-&gt;trip_count() &gt; 0) {
2139     assert((cl-&gt;trip_count() &amp; 1) == 0, &quot;missed peeling&quot;);
2140     do_unroll(loop, old_new, false);
2141   }
2142 }
2143 
2144 void PhaseIdealLoop::mark_reductions(IdealLoopTree *loop) {
2145   if (SuperWordReductions == false) return;
2146 
2147   CountedLoopNode* loop_head = loop-&gt;_head-&gt;as_CountedLoop();
2148   if (loop_head-&gt;unrolled_count() &gt; 1) {
2149     return;
2150   }
2151 
2152   Node* trip_phi = loop_head-&gt;phi();
2153   for (DUIterator_Fast imax, i = loop_head-&gt;fast_outs(imax); i &lt; imax; i++) {
2154     Node* phi = loop_head-&gt;fast_out(i);
2155     if (phi-&gt;is_Phi() &amp;&amp; phi-&gt;outcnt() &gt; 0 &amp;&amp; phi != trip_phi) {
2156       // For definitions which are loop inclusive and not tripcounts.
2157       Node* def_node = phi-&gt;in(LoopNode::LoopBackControl);
2158 
2159       if (def_node != NULL) {
2160         Node* n_ctrl = get_ctrl(def_node);
2161         if (n_ctrl != NULL &amp;&amp; loop-&gt;is_member(get_loop(n_ctrl))) {
2162           // Now test it to see if it fits the standard pattern for a reduction operator.
2163           int opc = def_node-&gt;Opcode();
2164           if (opc != ReductionNode::opcode(opc, def_node-&gt;bottom_type()-&gt;basic_type())
2165               || opc == Op_MinD || opc == Op_MinF || opc == Op_MaxD || opc == Op_MaxF) {
2166             if (!def_node-&gt;is_reduction()) { // Not marked yet
2167               // To be a reduction, the arithmetic node must have the phi as input and provide a def to it
2168               bool ok = false;
2169               for (unsigned j = 1; j &lt; def_node-&gt;req(); j++) {
2170                 Node* in = def_node-&gt;in(j);
2171                 if (in == phi) {
2172                   ok = true;
2173                   break;
2174                 }
2175               }
2176 
2177               // do nothing if we did not match the initial criteria
2178               if (ok == false) {
2179                 continue;
2180               }
2181 
2182               // The result of the reduction must not be used in the loop
2183               for (DUIterator_Fast imax, i = def_node-&gt;fast_outs(imax); i &lt; imax &amp;&amp; ok; i++) {
2184                 Node* u = def_node-&gt;fast_out(i);
2185                 if (!loop-&gt;is_member(get_loop(ctrl_or_self(u)))) {
2186                   continue;
2187                 }
2188                 if (u == phi) {
2189                   continue;
2190                 }
2191                 ok = false;
2192               }
2193 
2194               // iff the uses conform
2195               if (ok) {
2196                 def_node-&gt;add_flag(Node::Flag_is_reduction);
2197                 loop_head-&gt;mark_has_reductions();
2198               }
2199             }
2200           }
2201         }
2202       }
2203     }
2204   }
2205 }
2206 
2207 //------------------------------adjust_limit-----------------------------------
2208 // Helper function for add_constraint().
2209 Node* PhaseIdealLoop::adjust_limit(int stride_con, Node * scale, Node *offset, Node *rc_limit, Node *loop_limit, Node *pre_ctrl, bool round_up) {
2210   // Compute &quot;I :: (limit-offset)/scale&quot;
2211   Node *con = new SubINode(rc_limit, offset);
2212   register_new_node(con, pre_ctrl);
2213   Node *X = new DivINode(0, con, scale);
2214   register_new_node(X, pre_ctrl);
2215 
2216   // When the absolute value of scale is greater than one, the integer
2217   // division may round limit down so add one to the limit.
2218   if (round_up) {
2219     X = new AddINode(X, _igvn.intcon(1));
2220     register_new_node(X, pre_ctrl);
2221   }
2222 
2223   // Adjust loop limit
2224   loop_limit = (stride_con &gt; 0)
2225                ? (Node*)(new MinINode(loop_limit, X))
2226                : (Node*)(new MaxINode(loop_limit, X));
2227   register_new_node(loop_limit, pre_ctrl);
2228   return loop_limit;
2229 }
2230 
2231 //------------------------------add_constraint---------------------------------
2232 // Constrain the main loop iterations so the conditions:
2233 //    low_limit &lt;= scale_con * I + offset  &lt;  upper_limit
2234 // always holds true.  That is, either increase the number of iterations in
2235 // the pre-loop or the post-loop until the condition holds true in the main
2236 // loop.  Stride, scale, offset and limit are all loop invariant.  Further,
2237 // stride and scale are constants (offset and limit often are).
2238 void PhaseIdealLoop::add_constraint(int stride_con, int scale_con, Node *offset, Node *low_limit, Node *upper_limit, Node *pre_ctrl, Node **pre_limit, Node **main_limit) {
2239   // For positive stride, the pre-loop limit always uses a MAX function
2240   // and the main loop a MIN function.  For negative stride these are
2241   // reversed.
2242 
2243   // Also for positive stride*scale the affine function is increasing, so the
2244   // pre-loop must check for underflow and the post-loop for overflow.
2245   // Negative stride*scale reverses this; pre-loop checks for overflow and
2246   // post-loop for underflow.
2247 
2248   Node *scale = _igvn.intcon(scale_con);
2249   set_ctrl(scale, C-&gt;root());
2250 
2251   if ((stride_con^scale_con) &gt;= 0) { // Use XOR to avoid overflow
2252     // The overflow limit: scale*I+offset &lt; upper_limit
2253     // For main-loop compute
2254     //   ( if (scale &gt; 0) /* and stride &gt; 0 */
2255     //       I &lt; (upper_limit-offset)/scale
2256     //     else /* scale &lt; 0 and stride &lt; 0 */
2257     //       I &gt; (upper_limit-offset)/scale
2258     //   )
2259     //
2260     // (upper_limit-offset) may overflow or underflow.
2261     // But it is fine since main loop will either have
2262     // less iterations or will be skipped in such case.
2263     *main_limit = adjust_limit(stride_con, scale, offset, upper_limit, *main_limit, pre_ctrl, false);
2264 
2265     // The underflow limit: low_limit &lt;= scale*I+offset.
2266     // For pre-loop compute
2267     //   NOT(scale*I+offset &gt;= low_limit)
2268     //   scale*I+offset &lt; low_limit
2269     //   ( if (scale &gt; 0) /* and stride &gt; 0 */
2270     //       I &lt; (low_limit-offset)/scale
2271     //     else /* scale &lt; 0 and stride &lt; 0 */
2272     //       I &gt; (low_limit-offset)/scale
2273     //   )
2274 
2275     if (low_limit-&gt;get_int() == -max_jint) {
2276       // We need this guard when scale*pre_limit+offset &gt;= limit
2277       // due to underflow. So we need execute pre-loop until
2278       // scale*I+offset &gt;= min_int. But (min_int-offset) will
2279       // underflow when offset &gt; 0 and X will be &gt; original_limit
2280       // when stride &gt; 0. To avoid it we replace positive offset with 0.
2281       //
2282       // Also (min_int+1 == -max_int) is used instead of min_int here
2283       // to avoid problem with scale == -1 (min_int/(-1) == min_int).
2284       Node* shift = _igvn.intcon(31);
2285       set_ctrl(shift, C-&gt;root());
2286       Node* sign = new RShiftINode(offset, shift);
2287       register_new_node(sign, pre_ctrl);
2288       offset = new AndINode(offset, sign);
2289       register_new_node(offset, pre_ctrl);
2290     } else {
2291       assert(low_limit-&gt;get_int() == 0, &quot;wrong low limit for range check&quot;);
2292       // The only problem we have here when offset == min_int
2293       // since (0-min_int) == min_int. It may be fine for stride &gt; 0
2294       // but for stride &lt; 0 X will be &lt; original_limit. To avoid it
2295       // max(pre_limit, original_limit) is used in do_range_check().
2296     }
2297     // Pass (-stride) to indicate pre_loop_cond = NOT(main_loop_cond);
2298     *pre_limit = adjust_limit((-stride_con), scale, offset, low_limit, *pre_limit, pre_ctrl,
2299                               scale_con &gt; 1 &amp;&amp; stride_con &gt; 0);
2300 
2301   } else { // stride_con*scale_con &lt; 0
2302     // For negative stride*scale pre-loop checks for overflow and
2303     // post-loop for underflow.
2304     //
2305     // The overflow limit: scale*I+offset &lt; upper_limit
2306     // For pre-loop compute
2307     //   NOT(scale*I+offset &lt; upper_limit)
2308     //   scale*I+offset &gt;= upper_limit
2309     //   scale*I+offset+1 &gt; upper_limit
2310     //   ( if (scale &lt; 0) /* and stride &gt; 0 */
2311     //       I &lt; (upper_limit-(offset+1))/scale
2312     //     else /* scale &gt; 0 and stride &lt; 0 */
2313     //       I &gt; (upper_limit-(offset+1))/scale
2314     //   )
2315     //
2316     // (upper_limit-offset-1) may underflow or overflow.
2317     // To avoid it min(pre_limit, original_limit) is used
2318     // in do_range_check() for stride &gt; 0 and max() for &lt; 0.
2319     Node *one  = _igvn.intcon(1);
2320     set_ctrl(one, C-&gt;root());
2321 
2322     Node *plus_one = new AddINode(offset, one);
2323     register_new_node(plus_one, pre_ctrl);
2324     // Pass (-stride) to indicate pre_loop_cond = NOT(main_loop_cond);
2325     *pre_limit = adjust_limit((-stride_con), scale, plus_one, upper_limit, *pre_limit, pre_ctrl,
2326                               scale_con &lt; -1 &amp;&amp; stride_con &gt; 0);
2327 
2328     if (low_limit-&gt;get_int() == -max_jint) {
2329       // We need this guard when scale*main_limit+offset &gt;= limit
2330       // due to underflow. So we need execute main-loop while
2331       // scale*I+offset+1 &gt; min_int. But (min_int-offset-1) will
2332       // underflow when (offset+1) &gt; 0 and X will be &lt; main_limit
2333       // when scale &lt; 0 (and stride &gt; 0). To avoid it we replace
2334       // positive (offset+1) with 0.
2335       //
2336       // Also (min_int+1 == -max_int) is used instead of min_int here
2337       // to avoid problem with scale == -1 (min_int/(-1) == min_int).
2338       Node* shift = _igvn.intcon(31);
2339       set_ctrl(shift, C-&gt;root());
2340       Node* sign = new RShiftINode(plus_one, shift);
2341       register_new_node(sign, pre_ctrl);
2342       plus_one = new AndINode(plus_one, sign);
2343       register_new_node(plus_one, pre_ctrl);
2344     } else {
2345       assert(low_limit-&gt;get_int() == 0, &quot;wrong low limit for range check&quot;);
2346       // The only problem we have here when offset == max_int
2347       // since (max_int+1) == min_int and (0-min_int) == min_int.
2348       // But it is fine since main loop will either have
2349       // less iterations or will be skipped in such case.
2350     }
2351     // The underflow limit: low_limit &lt;= scale*I+offset.
2352     // For main-loop compute
2353     //   scale*I+offset+1 &gt; low_limit
2354     //   ( if (scale &lt; 0) /* and stride &gt; 0 */
2355     //       I &lt; (low_limit-(offset+1))/scale
2356     //     else /* scale &gt; 0 and stride &lt; 0 */
2357     //       I &gt; (low_limit-(offset+1))/scale
2358     //   )
2359 
2360     *main_limit = adjust_limit(stride_con, scale, plus_one, low_limit, *main_limit, pre_ctrl,
2361                                false);
2362   }
2363 }
2364 
2365 
2366 //------------------------------is_scaled_iv---------------------------------
2367 // Return true if exp is a constant times an induction var
2368 bool PhaseIdealLoop::is_scaled_iv(Node* exp, Node* iv, int* p_scale) {
2369   if (exp == iv) {
2370     if (p_scale != NULL) {
2371       *p_scale = 1;
2372     }
2373     return true;
2374   }
2375   int opc = exp-&gt;Opcode();
2376   if (opc == Op_MulI) {
2377     if (exp-&gt;in(1) == iv &amp;&amp; exp-&gt;in(2)-&gt;is_Con()) {
2378       if (p_scale != NULL) {
2379         *p_scale = exp-&gt;in(2)-&gt;get_int();
2380       }
2381       return true;
2382     }
2383     if (exp-&gt;in(2) == iv &amp;&amp; exp-&gt;in(1)-&gt;is_Con()) {
2384       if (p_scale != NULL) {
2385         *p_scale = exp-&gt;in(1)-&gt;get_int();
2386       }
2387       return true;
2388     }
2389   } else if (opc == Op_LShiftI) {
2390     if (exp-&gt;in(1) == iv &amp;&amp; exp-&gt;in(2)-&gt;is_Con()) {
2391       if (p_scale != NULL) {
2392         *p_scale = 1 &lt;&lt; exp-&gt;in(2)-&gt;get_int();
2393       }
2394       return true;
2395     }
2396   }
2397   return false;
2398 }
2399 
2400 //-----------------------------is_scaled_iv_plus_offset------------------------------
2401 // Return true if exp is a simple induction variable expression: k1*iv + (invar + k2)
2402 bool PhaseIdealLoop::is_scaled_iv_plus_offset(Node* exp, Node* iv, int* p_scale, Node** p_offset, int depth) {
2403   if (is_scaled_iv(exp, iv, p_scale)) {
2404     if (p_offset != NULL) {
2405       Node *zero = _igvn.intcon(0);
2406       set_ctrl(zero, C-&gt;root());
2407       *p_offset = zero;
2408     }
2409     return true;
2410   }
2411   int opc = exp-&gt;Opcode();
2412   if (opc == Op_AddI) {
2413     if (is_scaled_iv(exp-&gt;in(1), iv, p_scale)) {
2414       if (p_offset != NULL) {
2415         *p_offset = exp-&gt;in(2);
2416       }
2417       return true;
2418     }
2419     if (is_scaled_iv(exp-&gt;in(2), iv, p_scale)) {
2420       if (p_offset != NULL) {
2421         *p_offset = exp-&gt;in(1);
2422       }
2423       return true;
2424     }
2425     if (exp-&gt;in(2)-&gt;is_Con()) {
2426       Node* offset2 = NULL;
2427       if (depth &lt; 2 &amp;&amp;
2428           is_scaled_iv_plus_offset(exp-&gt;in(1), iv, p_scale,
2429                                    p_offset != NULL ? &amp;offset2 : NULL, depth+1)) {
2430         if (p_offset != NULL) {
2431           Node *ctrl_off2 = get_ctrl(offset2);
2432           Node* offset = new AddINode(offset2, exp-&gt;in(2));
2433           register_new_node(offset, ctrl_off2);
2434           *p_offset = offset;
2435         }
2436         return true;
2437       }
2438     }
2439   } else if (opc == Op_SubI) {
2440     if (is_scaled_iv(exp-&gt;in(1), iv, p_scale)) {
2441       if (p_offset != NULL) {
2442         Node *zero = _igvn.intcon(0);
2443         set_ctrl(zero, C-&gt;root());
2444         Node *ctrl_off = get_ctrl(exp-&gt;in(2));
2445         Node* offset = new SubINode(zero, exp-&gt;in(2));
2446         register_new_node(offset, ctrl_off);
2447         *p_offset = offset;
2448       }
2449       return true;
2450     }
2451     if (is_scaled_iv(exp-&gt;in(2), iv, p_scale)) {
2452       if (p_offset != NULL) {
2453         *p_scale *= -1;
2454         *p_offset = exp-&gt;in(1);
2455       }
2456       return true;
2457     }
2458   }
2459   return false;
2460 }
2461 
2462 // Same as PhaseIdealLoop::duplicate_predicates() but for range checks
2463 // eliminated by iteration splitting.
2464 Node* PhaseIdealLoop::add_range_check_predicate(IdealLoopTree* loop, CountedLoopNode* cl,
2465                                                 Node* predicate_proj, int scale_con, Node* offset,
2466                                                 Node* limit, jint stride_con, Node* value) {
2467   bool overflow = false;
2468   BoolNode* bol = rc_predicate(loop, predicate_proj, scale_con, offset, value, NULL, stride_con, limit, (stride_con &gt; 0) != (scale_con &gt; 0), overflow);
2469   Node* opaque_bol = new Opaque4Node(C, bol, _igvn.intcon(1));
2470   register_new_node(opaque_bol, predicate_proj);
2471   IfNode* new_iff = NULL;
2472   if (overflow) {
2473     new_iff = new IfNode(predicate_proj, opaque_bol, PROB_MAX, COUNT_UNKNOWN);
2474   } else {
2475     new_iff = new RangeCheckNode(predicate_proj, opaque_bol, PROB_MAX, COUNT_UNKNOWN);
2476   }
2477   register_control(new_iff, loop-&gt;_parent, predicate_proj);
2478   Node* iffalse = new IfFalseNode(new_iff);
2479   register_control(iffalse, _ltree_root, new_iff);
2480   ProjNode* iftrue = new IfTrueNode(new_iff);
2481   register_control(iftrue, loop-&gt;_parent, new_iff);
2482   Node *frame = new ParmNode(C-&gt;start(), TypeFunc::FramePtr);
2483   register_new_node(frame, C-&gt;start());
2484   Node* halt = new HaltNode(iffalse, frame, &quot;range check predicate failed which is impossible&quot;);
2485   register_control(halt, _ltree_root, iffalse);
2486   C-&gt;root()-&gt;add_req(halt);
2487   return iftrue;
2488 }
2489 
2490 //------------------------------do_range_check---------------------------------
2491 // Eliminate range-checks and other trip-counter vs loop-invariant tests.
2492 int PhaseIdealLoop::do_range_check(IdealLoopTree *loop, Node_List &amp;old_new) {
2493 #ifndef PRODUCT
2494   if (PrintOpto &amp;&amp; VerifyLoopOptimizations) {
2495     tty-&gt;print(&quot;Range Check Elimination &quot;);
2496     loop-&gt;dump_head();
2497   } else if (TraceLoopOpts) {
2498     tty-&gt;print(&quot;RangeCheck   &quot;);
2499     loop-&gt;dump_head();
2500   }
2501 #endif
2502 
2503   assert(RangeCheckElimination, &quot;&quot;);
2504   CountedLoopNode *cl = loop-&gt;_head-&gt;as_CountedLoop();
2505   // If we fail before trying to eliminate range checks, set multiversion state
2506   int closed_range_checks = 1;
2507 
2508   // protect against stride not being a constant
2509   if (!cl-&gt;stride_is_con()) {
2510     return closed_range_checks;
2511   }
2512   // Find the trip counter; we are iteration splitting based on it
2513   Node *trip_counter = cl-&gt;phi();
2514   // Find the main loop limit; we will trim it&#39;s iterations
2515   // to not ever trip end tests
2516   Node *main_limit = cl-&gt;limit();
2517 
2518   // Check graph shape. Cannot optimize a loop if zero-trip
2519   // Opaque1 node is optimized away and then another round
2520   // of loop opts attempted.
2521   if (!is_canonical_loop_entry(cl)) {
2522     return closed_range_checks;
2523   }
2524 
2525   // Need to find the main-loop zero-trip guard
2526   Node *ctrl = cl-&gt;skip_predicates();
2527   Node *iffm = ctrl-&gt;in(0);
2528   Node *opqzm = iffm-&gt;in(1)-&gt;in(1)-&gt;in(2);
2529   assert(opqzm-&gt;in(1) == main_limit, &quot;do not understand situation&quot;);
2530 
2531   // Find the pre-loop limit; we will expand its iterations to
2532   // not ever trip low tests.
2533   Node *p_f = iffm-&gt;in(0);
2534   // pre loop may have been optimized out
2535   if (p_f-&gt;Opcode() != Op_IfFalse) {
2536     return closed_range_checks;
2537   }
2538   CountedLoopEndNode *pre_end = p_f-&gt;in(0)-&gt;as_CountedLoopEnd();
2539   assert(pre_end-&gt;loopnode()-&gt;is_pre_loop(), &quot;&quot;);
2540   Node *pre_opaq1 = pre_end-&gt;limit();
2541   // Occasionally it&#39;s possible for a pre-loop Opaque1 node to be
2542   // optimized away and then another round of loop opts attempted.
2543   // We can not optimize this particular loop in that case.
2544   if (pre_opaq1-&gt;Opcode() != Op_Opaque1) {
2545     return closed_range_checks;
2546   }
2547   Opaque1Node *pre_opaq = (Opaque1Node*)pre_opaq1;
2548   Node *pre_limit = pre_opaq-&gt;in(1);
2549 
2550   // Where do we put new limit calculations
2551   Node *pre_ctrl = pre_end-&gt;loopnode()-&gt;in(LoopNode::EntryControl);
2552 
2553   // Ensure the original loop limit is available from the
2554   // pre-loop Opaque1 node.
2555   Node *orig_limit = pre_opaq-&gt;original_loop_limit();
2556   if (orig_limit == NULL || _igvn.type(orig_limit) == Type::TOP) {
2557     return closed_range_checks;
2558   }
2559   // Must know if its a count-up or count-down loop
2560 
2561   int stride_con = cl-&gt;stride_con();
2562   Node *zero = _igvn.intcon(0);
2563   Node *one  = _igvn.intcon(1);
2564   // Use symmetrical int range [-max_jint,max_jint]
2565   Node *mini = _igvn.intcon(-max_jint);
2566   set_ctrl(zero, C-&gt;root());
2567   set_ctrl(one,  C-&gt;root());
2568   set_ctrl(mini, C-&gt;root());
2569 
2570   // Range checks that do not dominate the loop backedge (ie.
2571   // conditionally executed) can lengthen the pre loop limit beyond
2572   // the original loop limit. To prevent this, the pre limit is
2573   // (for stride &gt; 0) MINed with the original loop limit (MAXed
2574   // stride &lt; 0) when some range_check (rc) is conditionally
2575   // executed.
2576   bool conditional_rc = false;
2577 
2578   // Count number of range checks and reduce by load range limits, if zero,
2579   // the loop is in canonical form to multiversion.
2580   closed_range_checks = 0;
2581 
2582   Node* predicate_proj = cl-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl);
2583   assert(predicate_proj-&gt;is_Proj() &amp;&amp; predicate_proj-&gt;in(0)-&gt;is_If(), &quot;if projection only&quot;);
2584 
2585   // Check loop body for tests of trip-counter plus loop-invariant vs loop-variant.
2586   for (uint i = 0; i &lt; loop-&gt;_body.size(); i++) {
2587     Node *iff = loop-&gt;_body[i];
2588     if (iff-&gt;Opcode() == Op_If ||
2589         iff-&gt;Opcode() == Op_RangeCheck) { // Test?
2590       // Test is an IfNode, has 2 projections.  If BOTH are in the loop
2591       // we need loop unswitching instead of iteration splitting.
2592       closed_range_checks++;
2593       Node *exit = loop-&gt;is_loop_exit(iff);
2594       if (!exit) continue;
2595       int flip = (exit-&gt;Opcode() == Op_IfTrue) ? 1 : 0;
2596 
2597       // Get boolean condition to test
2598       Node *i1 = iff-&gt;in(1);
2599       if (!i1-&gt;is_Bool()) continue;
2600       BoolNode *bol = i1-&gt;as_Bool();
2601       BoolTest b_test = bol-&gt;_test;
2602       // Flip sense of test if exit condition is flipped
2603       if (flip) {
2604         b_test = b_test.negate();
2605       }
2606       // Get compare
2607       Node *cmp = bol-&gt;in(1);
2608 
2609       // Look for trip_counter + offset vs limit
2610       Node *rc_exp = cmp-&gt;in(1);
2611       Node *limit  = cmp-&gt;in(2);
2612       int scale_con= 1;        // Assume trip counter not scaled
2613 
2614       Node *limit_c = get_ctrl(limit);
2615       if (loop-&gt;is_member(get_loop(limit_c))) {
2616         // Compare might have operands swapped; commute them
2617         b_test = b_test.commute();
2618         rc_exp = cmp-&gt;in(2);
2619         limit  = cmp-&gt;in(1);
2620         limit_c = get_ctrl(limit);
2621         if (loop-&gt;is_member(get_loop(limit_c))) {
2622           continue;             // Both inputs are loop varying; cannot RCE
2623         }
2624       }
2625       // Here we know &#39;limit&#39; is loop invariant
2626 
2627       // &#39;limit&#39; maybe pinned below the zero trip test (probably from a
2628       // previous round of rce), in which case, it can&#39;t be used in the
2629       // zero trip test expression which must occur before the zero test&#39;s if.
2630       if (is_dominator(ctrl, limit_c)) {
2631         continue;  // Don&#39;t rce this check but continue looking for other candidates.
2632       }
2633 
2634       // Check for scaled induction variable plus an offset
2635       Node *offset = NULL;
2636 
2637       if (!is_scaled_iv_plus_offset(rc_exp, trip_counter, &amp;scale_con, &amp;offset)) {
2638         continue;
2639       }
2640 
2641       Node *offset_c = get_ctrl(offset);
2642       if (loop-&gt;is_member(get_loop(offset_c))) {
2643         continue;               // Offset is not really loop invariant
2644       }
2645       // Here we know &#39;offset&#39; is loop invariant.
2646 
2647       // As above for the &#39;limit&#39;, the &#39;offset&#39; maybe pinned below the
2648       // zero trip test.
2649       if (is_dominator(ctrl, offset_c)) {
2650         continue; // Don&#39;t rce this check but continue looking for other candidates.
2651       }
2652 #ifdef ASSERT
2653       if (TraceRangeLimitCheck) {
2654         tty-&gt;print_cr(&quot;RC bool node%s&quot;, flip ? &quot; flipped:&quot; : &quot;:&quot;);
2655         bol-&gt;dump(2);
2656       }
2657 #endif
2658       // At this point we have the expression as:
2659       //   scale_con * trip_counter + offset :: limit
2660       // where scale_con, offset and limit are loop invariant.  Trip_counter
2661       // monotonically increases by stride_con, a constant.  Both (or either)
2662       // stride_con and scale_con can be negative which will flip about the
2663       // sense of the test.
2664 
2665       // Adjust pre and main loop limits to guard the correct iteration set
2666       if (cmp-&gt;Opcode() == Op_CmpU) { // Unsigned compare is really 2 tests
2667         if (b_test._test == BoolTest::lt) { // Range checks always use lt
2668           // The underflow and overflow limits: 0 &lt;= scale*I+offset &lt; limit
2669           add_constraint(stride_con, scale_con, offset, zero, limit, pre_ctrl, &amp;pre_limit, &amp;main_limit);
2670           // (0-offset)/scale could be outside of loop iterations range.
2671           conditional_rc = true;
2672           Node* init = cl-&gt;init_trip();
2673           Node* opaque_init = new Opaque1Node(C, init);
2674           register_new_node(opaque_init, predicate_proj);
2675           // template predicate so it can be updated on next unrolling
2676           predicate_proj = add_range_check_predicate(loop, cl, predicate_proj, scale_con, offset, limit, stride_con, opaque_init);
2677           assert(skeleton_predicate_has_opaque(predicate_proj-&gt;in(0)-&gt;as_If()), &quot;unexpected&quot;);
2678           // predicate on first value of first iteration
2679           predicate_proj = add_range_check_predicate(loop, cl, predicate_proj, scale_con, offset, limit, stride_con, init);
2680           assert(!skeleton_predicate_has_opaque(predicate_proj-&gt;in(0)-&gt;as_If()), &quot;unexpected&quot;);
2681           int init_inc = stride_con/cl-&gt;unrolled_count();
2682           assert(init_inc != 0, &quot;invalid loop increment&quot;);
2683           Node* max_value = _igvn.intcon(stride_con - init_inc);
2684           max_value = new AddINode(init, max_value);
2685           register_new_node(max_value, predicate_proj);
2686           // predicate on last value of first iteration (in case unrolling has already happened)
2687           predicate_proj = add_range_check_predicate(loop, cl, predicate_proj, scale_con, offset, limit, stride_con, max_value);
2688           assert(!skeleton_predicate_has_opaque(predicate_proj-&gt;in(0)-&gt;as_If()), &quot;unexpected&quot;);
2689         } else {
2690           if (PrintOpto) {
2691             tty-&gt;print_cr(&quot;missed RCE opportunity&quot;);
2692           }
2693           continue;             // In release mode, ignore it
2694         }
2695       } else {                  // Otherwise work on normal compares
2696         switch(b_test._test) {
2697         case BoolTest::gt:
2698           // Fall into GE case
2699         case BoolTest::ge:
2700           // Convert (I*scale+offset) &gt;= Limit to (I*(-scale)+(-offset)) &lt;= -Limit
2701           scale_con = -scale_con;
2702           offset = new SubINode(zero, offset);
2703           register_new_node(offset, pre_ctrl);
2704           limit  = new SubINode(zero, limit);
2705           register_new_node(limit, pre_ctrl);
2706           // Fall into LE case
2707         case BoolTest::le:
2708           if (b_test._test != BoolTest::gt) {
2709             // Convert X &lt;= Y to X &lt; Y+1
2710             limit = new AddINode(limit, one);
2711             register_new_node(limit, pre_ctrl);
2712           }
2713           // Fall into LT case
2714         case BoolTest::lt:
2715           // The underflow and overflow limits: MIN_INT &lt;= scale*I+offset &lt; limit
2716           // Note: (MIN_INT+1 == -MAX_INT) is used instead of MIN_INT here
2717           // to avoid problem with scale == -1: MIN_INT/(-1) == MIN_INT.
2718           add_constraint(stride_con, scale_con, offset, mini, limit, pre_ctrl, &amp;pre_limit, &amp;main_limit);
2719           // ((MIN_INT+1)-offset)/scale could be outside of loop iterations range.
2720           // Note: negative offset is replaced with 0 but (MIN_INT+1)/scale could
2721           // still be outside of loop range.
2722           conditional_rc = true;
2723           break;
2724         default:
2725           if (PrintOpto) {
2726             tty-&gt;print_cr(&quot;missed RCE opportunity&quot;);
2727           }
2728           continue;             // Unhandled case
2729         }
2730       }
2731 
2732       // Kill the eliminated test
2733       C-&gt;set_major_progress();
2734       Node *kill_con = _igvn.intcon(1-flip);
2735       set_ctrl(kill_con, C-&gt;root());
2736       _igvn.replace_input_of(iff, 1, kill_con);
2737       // Find surviving projection
2738       assert(iff-&gt;is_If(), &quot;&quot;);
2739       ProjNode* dp = ((IfNode*)iff)-&gt;proj_out(1-flip);
2740       // Find loads off the surviving projection; remove their control edge
2741       for (DUIterator_Fast imax, i = dp-&gt;fast_outs(imax); i &lt; imax; i++) {
2742         Node* cd = dp-&gt;fast_out(i); // Control-dependent node
2743         if (cd-&gt;is_Load() &amp;&amp; cd-&gt;depends_only_on_test()) {   // Loads can now float around in the loop
2744           // Allow the load to float around in the loop, or before it
2745           // but NOT before the pre-loop.
2746           _igvn.replace_input_of(cd, 0, ctrl); // ctrl, not NULL
2747           --i;
2748           --imax;
2749         }
2750       }
2751       if (limit-&gt;Opcode() == Op_LoadRange) {
2752         closed_range_checks--;
2753       }
2754     } // End of is IF
2755   }
2756   if (predicate_proj != cl-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl)) {
2757     _igvn.replace_input_of(cl-&gt;skip_strip_mined(), LoopNode::EntryControl, predicate_proj);
2758     set_idom(cl-&gt;skip_strip_mined(), predicate_proj, dom_depth(cl-&gt;skip_strip_mined()));
2759   }
2760 
2761   // Update loop limits
2762   if (conditional_rc) {
2763     pre_limit = (stride_con &gt; 0) ? (Node*)new MinINode(pre_limit, orig_limit)
2764                                  : (Node*)new MaxINode(pre_limit, orig_limit);
2765     register_new_node(pre_limit, pre_ctrl);
2766   }
2767   _igvn.replace_input_of(pre_opaq, 1, pre_limit);
2768 
2769   // Note:: we are making the main loop limit no longer precise;
2770   // need to round up based on stride.
2771   cl-&gt;set_nonexact_trip_count();
2772   Node *main_cle = cl-&gt;loopexit();
2773   Node *main_bol = main_cle-&gt;in(1);
2774   // Hacking loop bounds; need private copies of exit test
2775   if (main_bol-&gt;outcnt() &gt; 1) {     // BoolNode shared?
2776     main_bol = main_bol-&gt;clone();   // Clone a private BoolNode
2777     register_new_node(main_bol, main_cle-&gt;in(0));
2778     _igvn.replace_input_of(main_cle, 1, main_bol);
2779   }
2780   Node *main_cmp = main_bol-&gt;in(1);
2781   if (main_cmp-&gt;outcnt() &gt; 1) {     // CmpNode shared?
2782     main_cmp = main_cmp-&gt;clone();   // Clone a private CmpNode
2783     register_new_node(main_cmp, main_cle-&gt;in(0));
2784     _igvn.replace_input_of(main_bol, 1, main_cmp);
2785   }
2786   // Hack the now-private loop bounds
2787   _igvn.replace_input_of(main_cmp, 2, main_limit);
2788   // The OpaqueNode is unshared by design
2789   assert(opqzm-&gt;outcnt() == 1, &quot;cannot hack shared node&quot;);
2790   _igvn.replace_input_of(opqzm, 1, main_limit);
2791 
2792   return closed_range_checks;
2793 }
2794 
2795 //------------------------------has_range_checks-------------------------------
2796 // Check to see if RCE cleaned the current loop of range-checks.
2797 void PhaseIdealLoop::has_range_checks(IdealLoopTree *loop) {
2798   assert(RangeCheckElimination, &quot;&quot;);
2799 
2800   // skip if not a counted loop
2801   if (!loop-&gt;is_counted()) return;
2802 
2803   CountedLoopNode *cl = loop-&gt;_head-&gt;as_CountedLoop();
2804 
2805   // skip this loop if it is already checked
2806   if (cl-&gt;has_been_range_checked()) return;
2807 
2808   // Now check for existence of range checks
2809   for (uint i = 0; i &lt; loop-&gt;_body.size(); i++) {
2810     Node *iff = loop-&gt;_body[i];
2811     int iff_opc = iff-&gt;Opcode();
2812     if (iff_opc == Op_If || iff_opc == Op_RangeCheck) {
2813       cl-&gt;mark_has_range_checks();
2814       break;
2815     }
2816   }
2817   cl-&gt;set_has_been_range_checked();
2818 }
2819 
2820 //-------------------------multi_version_post_loops----------------------------
2821 // Check the range checks that remain, if simple, use the bounds to guard
2822 // which version to a post loop we execute, one with range checks or one without
2823 bool PhaseIdealLoop::multi_version_post_loops(IdealLoopTree *rce_loop, IdealLoopTree *legacy_loop) {
2824   bool multi_version_succeeded = false;
2825   assert(RangeCheckElimination, &quot;&quot;);
2826   CountedLoopNode *legacy_cl = legacy_loop-&gt;_head-&gt;as_CountedLoop();
2827   assert(legacy_cl-&gt;is_post_loop(), &quot;&quot;);
2828 
2829   // Check for existence of range checks using the unique instance to make a guard with
2830   Unique_Node_List worklist;
2831   for (uint i = 0; i &lt; legacy_loop-&gt;_body.size(); i++) {
2832     Node *iff = legacy_loop-&gt;_body[i];
2833     int iff_opc = iff-&gt;Opcode();
2834     if (iff_opc == Op_If || iff_opc == Op_RangeCheck) {
2835       worklist.push(iff);
2836     }
2837   }
2838 
2839   // Find RCE&#39;d post loop so that we can stage its guard.
2840   if (!is_canonical_loop_entry(legacy_cl)) return multi_version_succeeded;
2841   Node* ctrl = legacy_cl-&gt;in(LoopNode::EntryControl);
2842   Node* iffm = ctrl-&gt;in(0);
2843 
2844   // Now we test that both the post loops are connected
2845   Node* post_loop_region = iffm-&gt;in(0);
2846   if (post_loop_region == NULL) return multi_version_succeeded;
2847   if (!post_loop_region-&gt;is_Region()) return multi_version_succeeded;
2848   Node* covering_region = post_loop_region-&gt;in(RegionNode::Control+1);
2849   if (covering_region == NULL) return multi_version_succeeded;
2850   if (!covering_region-&gt;is_Region()) return multi_version_succeeded;
2851   Node* p_f = covering_region-&gt;in(RegionNode::Control);
2852   if (p_f == NULL) return multi_version_succeeded;
2853   if (!p_f-&gt;is_IfFalse()) return multi_version_succeeded;
2854   if (!p_f-&gt;in(0)-&gt;is_CountedLoopEnd()) return multi_version_succeeded;
2855   CountedLoopEndNode* rce_loop_end = p_f-&gt;in(0)-&gt;as_CountedLoopEnd();
2856   if (rce_loop_end == NULL) return multi_version_succeeded;
2857   CountedLoopNode* rce_cl = rce_loop_end-&gt;loopnode();
2858   if (rce_cl == NULL || !rce_cl-&gt;is_post_loop()) return multi_version_succeeded;
2859   CountedLoopNode *known_rce_cl = rce_loop-&gt;_head-&gt;as_CountedLoop();
2860   if (rce_cl != known_rce_cl) return multi_version_succeeded;
2861 
2862   // Then we fetch the cover entry test
2863   ctrl = rce_cl-&gt;in(LoopNode::EntryControl);
2864   if (!ctrl-&gt;is_IfTrue() &amp;&amp; !ctrl-&gt;is_IfFalse()) return multi_version_succeeded;
2865 
2866 #ifndef PRODUCT
2867   if (TraceLoopOpts) {
2868     tty-&gt;print(&quot;PostMultiVersion\n&quot;);
2869     rce_loop-&gt;dump_head();
2870     legacy_loop-&gt;dump_head();
2871   }
2872 #endif
2873 
2874   // Now fetch the limit we want to compare against
2875   Node *limit = rce_cl-&gt;limit();
2876   bool first_time = true;
2877 
2878   // If we got this far, we identified the post loop which has been RCE&#39;d and
2879   // we have a work list.  Now we will try to transform the if guard to cause
2880   // the loop pair to be multi version executed with the determination left to runtime
2881   // or the optimizer if full information is known about the given arrays at compile time.
2882   Node *last_min = NULL;
2883   multi_version_succeeded = true;
2884   while (worklist.size()) {
2885     Node* rc_iffm = worklist.pop();
2886     if (rc_iffm-&gt;is_If()) {
2887       Node *rc_bolzm = rc_iffm-&gt;in(1);
2888       if (rc_bolzm-&gt;is_Bool()) {
2889         Node *rc_cmpzm = rc_bolzm-&gt;in(1);
2890         if (rc_cmpzm-&gt;is_Cmp()) {
2891           Node *rc_left = rc_cmpzm-&gt;in(2);
2892           if (rc_left-&gt;Opcode() != Op_LoadRange) {
2893             multi_version_succeeded = false;
2894             break;
2895           }
2896           if (first_time) {
2897             last_min = rc_left;
2898             first_time = false;
2899           } else {
2900             Node *cur_min = new MinINode(last_min, rc_left);
2901             last_min = cur_min;
2902             _igvn.register_new_node_with_optimizer(last_min);
2903           }
2904         }
2905       }
2906     }
2907   }
2908 
2909   // All we have to do is update the limit of the rce loop
2910   // with the min of our expression and the current limit.
2911   // We will use this expression to replace the current limit.
2912   if (last_min &amp;&amp; multi_version_succeeded) {
2913     Node *cur_min = new MinINode(last_min, limit);
2914     _igvn.register_new_node_with_optimizer(cur_min);
2915     Node *cmp_node = rce_loop_end-&gt;cmp_node();
2916     _igvn.replace_input_of(cmp_node, 2, cur_min);
2917     set_ctrl(cur_min, ctrl);
2918     set_loop(cur_min, rce_loop-&gt;_parent);
2919 
2920     legacy_cl-&gt;mark_is_multiversioned();
2921     rce_cl-&gt;mark_is_multiversioned();
2922     multi_version_succeeded = true;
2923 
2924     C-&gt;set_major_progress();
2925   }
2926 
2927   return multi_version_succeeded;
2928 }
2929 
2930 //-------------------------poison_rce_post_loop--------------------------------
2931 // Causes the rce&#39;d post loop to be optimized away if multiversioning fails
2932 void PhaseIdealLoop::poison_rce_post_loop(IdealLoopTree *rce_loop) {
2933   CountedLoopNode *rce_cl = rce_loop-&gt;_head-&gt;as_CountedLoop();
2934   Node* ctrl = rce_cl-&gt;in(LoopNode::EntryControl);
2935   if (ctrl-&gt;is_IfTrue() || ctrl-&gt;is_IfFalse()) {
2936     Node* iffm = ctrl-&gt;in(0);
2937     if (iffm-&gt;is_If()) {
2938       Node* cur_bool = iffm-&gt;in(1);
2939       if (cur_bool-&gt;is_Bool()) {
2940         Node* cur_cmp = cur_bool-&gt;in(1);
2941         if (cur_cmp-&gt;is_Cmp()) {
2942           BoolTest::mask new_test = BoolTest::gt;
2943           BoolNode *new_bool = new BoolNode(cur_cmp, new_test);
2944           _igvn.replace_node(cur_bool, new_bool);
2945           _igvn._worklist.push(new_bool);
2946           Node* left_op = cur_cmp-&gt;in(1);
2947           _igvn.replace_input_of(cur_cmp, 2, left_op);
2948           C-&gt;set_major_progress();
2949         }
2950       }
2951     }
2952   }
2953 }
2954 
2955 //------------------------------DCE_loop_body----------------------------------
2956 // Remove simplistic dead code from loop body
2957 void IdealLoopTree::DCE_loop_body() {
2958   for (uint i = 0; i &lt; _body.size(); i++) {
2959     if (_body.at(i)-&gt;outcnt() == 0) {
2960       _body.map(i, _body.pop());
2961       i--; // Ensure we revisit the updated index.
2962     }
2963   }
2964 }
2965 
2966 
2967 //------------------------------adjust_loop_exit_prob--------------------------
2968 // Look for loop-exit tests with the 50/50 (or worse) guesses from the parsing stage.
2969 // Replace with a 1-in-10 exit guess.
2970 void IdealLoopTree::adjust_loop_exit_prob(PhaseIdealLoop *phase) {
2971   Node *test = tail();
2972   while (test != _head) {
2973     uint top = test-&gt;Opcode();
2974     if (top == Op_IfTrue || top == Op_IfFalse) {
2975       int test_con = ((ProjNode*)test)-&gt;_con;
2976       assert(top == (uint)(test_con? Op_IfTrue: Op_IfFalse), &quot;sanity&quot;);
2977       IfNode *iff = test-&gt;in(0)-&gt;as_If();
2978       if (iff-&gt;outcnt() == 2) {         // Ignore dead tests
2979         Node *bol = iff-&gt;in(1);
2980         if (bol &amp;&amp; bol-&gt;req() &gt; 1 &amp;&amp; bol-&gt;in(1) &amp;&amp;
2981             ((bol-&gt;in(1)-&gt;Opcode() == Op_StorePConditional) ||
2982              (bol-&gt;in(1)-&gt;Opcode() == Op_StoreIConditional) ||
2983              (bol-&gt;in(1)-&gt;Opcode() == Op_StoreLConditional) ||
2984              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndExchangeB) ||
2985              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndExchangeS) ||
2986              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndExchangeI) ||
2987              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndExchangeL) ||
2988              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndExchangeP) ||
2989              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndExchangeN) ||
2990              (bol-&gt;in(1)-&gt;Opcode() == Op_WeakCompareAndSwapB) ||
2991              (bol-&gt;in(1)-&gt;Opcode() == Op_WeakCompareAndSwapS) ||
2992              (bol-&gt;in(1)-&gt;Opcode() == Op_WeakCompareAndSwapI) ||
2993              (bol-&gt;in(1)-&gt;Opcode() == Op_WeakCompareAndSwapL) ||
2994              (bol-&gt;in(1)-&gt;Opcode() == Op_WeakCompareAndSwapP) ||
2995              (bol-&gt;in(1)-&gt;Opcode() == Op_WeakCompareAndSwapN) ||
2996              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndSwapB) ||
2997              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndSwapS) ||
2998              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndSwapI) ||
2999              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndSwapL) ||
3000              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndSwapP) ||
3001              (bol-&gt;in(1)-&gt;Opcode() == Op_CompareAndSwapN) ||
3002              (bol-&gt;in(1)-&gt;Opcode() == Op_ShenandoahCompareAndExchangeP) ||
3003              (bol-&gt;in(1)-&gt;Opcode() == Op_ShenandoahCompareAndExchangeN) ||
3004              (bol-&gt;in(1)-&gt;Opcode() == Op_ShenandoahWeakCompareAndSwapP) ||
3005              (bol-&gt;in(1)-&gt;Opcode() == Op_ShenandoahWeakCompareAndSwapN) ||
3006              (bol-&gt;in(1)-&gt;Opcode() == Op_ShenandoahCompareAndSwapP) ||
3007              (bol-&gt;in(1)-&gt;Opcode() == Op_ShenandoahCompareAndSwapN)))
3008           return;               // Allocation loops RARELY take backedge
3009         // Find the OTHER exit path from the IF
3010         Node* ex = iff-&gt;proj_out(1-test_con);
3011         float p = iff-&gt;_prob;
3012         if (!phase-&gt;is_member(this, ex) &amp;&amp; iff-&gt;_fcnt == COUNT_UNKNOWN) {
3013           if (top == Op_IfTrue) {
3014             if (p &lt; (PROB_FAIR + PROB_UNLIKELY_MAG(3))) {
3015               iff-&gt;_prob = PROB_STATIC_FREQUENT;
3016             }
3017           } else {
3018             if (p &gt; (PROB_FAIR - PROB_UNLIKELY_MAG(3))) {
3019               iff-&gt;_prob = PROB_STATIC_INFREQUENT;
3020             }
3021           }
3022         }
3023       }
3024     }
3025     test = phase-&gt;idom(test);
3026   }
3027 }
3028 
3029 #ifdef ASSERT
3030 static CountedLoopNode* locate_pre_from_main(CountedLoopNode* main_loop) {
3031   assert(!main_loop-&gt;is_main_no_pre_loop(), &quot;Does not have a pre loop&quot;);
3032   Node* ctrl = main_loop-&gt;skip_predicates();
3033   assert(ctrl-&gt;Opcode() == Op_IfTrue || ctrl-&gt;Opcode() == Op_IfFalse, &quot;&quot;);
3034   Node* iffm = ctrl-&gt;in(0);
3035   assert(iffm-&gt;Opcode() == Op_If, &quot;&quot;);
3036   Node* p_f = iffm-&gt;in(0);
3037   assert(p_f-&gt;Opcode() == Op_IfFalse, &quot;&quot;);
3038   CountedLoopNode* pre_loop = p_f-&gt;in(0)-&gt;as_CountedLoopEnd()-&gt;loopnode();
3039   assert(pre_loop-&gt;is_pre_loop(), &quot;No pre loop found&quot;);
3040   return pre_loop;
3041 }
3042 #endif
3043 
3044 // Remove the main and post loops and make the pre loop execute all
3045 // iterations. Useful when the pre loop is found empty.
3046 void IdealLoopTree::remove_main_post_loops(CountedLoopNode *cl, PhaseIdealLoop *phase) {
3047   CountedLoopEndNode* pre_end = cl-&gt;loopexit();
3048   Node* pre_cmp = pre_end-&gt;cmp_node();
3049   if (pre_cmp-&gt;in(2)-&gt;Opcode() != Op_Opaque1) {
3050     // Only safe to remove the main loop if the compiler optimized it
3051     // out based on an unknown number of iterations
3052     return;
3053   }
3054 
3055   // Can we find the main loop?
3056   if (_next == NULL) {
3057     return;
3058   }
3059 
3060   Node* next_head = _next-&gt;_head;
3061   if (!next_head-&gt;is_CountedLoop()) {
3062     return;
3063   }
3064 
3065   CountedLoopNode* main_head = next_head-&gt;as_CountedLoop();
3066   if (!main_head-&gt;is_main_loop() || main_head-&gt;is_main_no_pre_loop()) {
3067     return;
3068   }
3069 
3070   assert(locate_pre_from_main(main_head) == cl, &quot;bad main loop&quot;);
3071   Node* main_iff = main_head-&gt;skip_predicates()-&gt;in(0);
3072 
3073   // Remove the Opaque1Node of the pre loop and make it execute all iterations
3074   phase-&gt;_igvn.replace_input_of(pre_cmp, 2, pre_cmp-&gt;in(2)-&gt;in(2));
3075   // Remove the Opaque1Node of the main loop so it can be optimized out
3076   Node* main_cmp = main_iff-&gt;in(1)-&gt;in(1);
3077   assert(main_cmp-&gt;in(2)-&gt;Opcode() == Op_Opaque1, &quot;main loop has no opaque node?&quot;);
3078   phase-&gt;_igvn.replace_input_of(main_cmp, 2, main_cmp-&gt;in(2)-&gt;in(1));
3079 }
3080 
3081 //------------------------------do_remove_empty_loop---------------------------
3082 // We always attempt remove empty loops.   The approach is to replace the trip
3083 // counter with the value it will have on the last iteration.  This will break
3084 // the loop.
3085 bool IdealLoopTree::do_remove_empty_loop(PhaseIdealLoop *phase) {
3086   // Minimum size must be empty loop
3087   if (_body.size() &gt; EMPTY_LOOP_SIZE) {
3088     return false;
3089   }
3090   if (!_head-&gt;is_CountedLoop()) {
3091     return false;   // Dead loop
3092   }
3093   CountedLoopNode *cl = _head-&gt;as_CountedLoop();
3094   if (!cl-&gt;is_valid_counted_loop()) {
3095     return false;   // Malformed loop
3096   }
3097   if (!phase-&gt;is_member(this, phase-&gt;get_ctrl(cl-&gt;loopexit()-&gt;in(CountedLoopEndNode::TestValue)))) {
3098     return false;   // Infinite loop
3099   }
3100   if (cl-&gt;is_pre_loop()) {
3101     // If the loop we are removing is a pre-loop then the main and post loop
3102     // can be removed as well.
3103     remove_main_post_loops(cl, phase);
3104   }
3105 
3106 #ifdef ASSERT
3107   // Ensure only one phi which is the iv.
3108   Node* iv = NULL;
3109   for (DUIterator_Fast imax, i = cl-&gt;fast_outs(imax); i &lt; imax; i++) {
3110     Node* n = cl-&gt;fast_out(i);
3111     if (n-&gt;Opcode() == Op_Phi) {
3112       assert(iv == NULL, &quot;Too many phis&quot;);
3113       iv = n;
3114     }
3115   }
3116   assert(iv == cl-&gt;phi(), &quot;Wrong phi&quot;);
3117 #endif
3118 
3119   // main and post loops have explicitly created zero trip guard
3120   bool needs_guard = !cl-&gt;is_main_loop() &amp;&amp; !cl-&gt;is_post_loop();
3121   if (needs_guard) {
3122     // Skip guard if values not overlap.
3123     const TypeInt* init_t = phase-&gt;_igvn.type(cl-&gt;init_trip())-&gt;is_int();
3124     const TypeInt* limit_t = phase-&gt;_igvn.type(cl-&gt;limit())-&gt;is_int();
3125     int  stride_con = cl-&gt;stride_con();
3126     if (stride_con &gt; 0) {
3127       needs_guard = (init_t-&gt;_hi &gt;= limit_t-&gt;_lo);
3128     } else {
3129       needs_guard = (init_t-&gt;_lo &lt;= limit_t-&gt;_hi);
3130     }
3131   }
3132   if (needs_guard) {
3133     // Check for an obvious zero trip guard.
3134     Node* inctrl = PhaseIdealLoop::skip_all_loop_predicates(cl-&gt;skip_predicates());
3135     if (inctrl-&gt;Opcode() == Op_IfTrue || inctrl-&gt;Opcode() == Op_IfFalse) {
3136       bool maybe_swapped = (inctrl-&gt;Opcode() == Op_IfFalse);
3137       // The test should look like just the backedge of a CountedLoop
3138       Node* iff = inctrl-&gt;in(0);
3139       if (iff-&gt;is_If()) {
3140         Node* bol = iff-&gt;in(1);
3141         if (bol-&gt;is_Bool()) {
3142           BoolTest test = bol-&gt;as_Bool()-&gt;_test;
3143           if (maybe_swapped) {
3144             test._test = test.commute();
3145             test._test = test.negate();
3146           }
3147           if (test._test == cl-&gt;loopexit()-&gt;test_trip()) {
3148             Node* cmp = bol-&gt;in(1);
3149             int init_idx = maybe_swapped ? 2 : 1;
3150             int limit_idx = maybe_swapped ? 1 : 2;
3151             if (cmp-&gt;is_Cmp() &amp;&amp; cmp-&gt;in(init_idx) == cl-&gt;init_trip() &amp;&amp; cmp-&gt;in(limit_idx) == cl-&gt;limit()) {
3152               needs_guard = false;
3153             }
3154           }
3155         }
3156       }
3157     }
3158   }
3159 
3160 #ifndef PRODUCT
3161   if (PrintOpto) {
3162     tty-&gt;print(&quot;Removing empty loop with%s zero trip guard&quot;, needs_guard ? &quot;out&quot; : &quot;&quot;);
3163     this-&gt;dump_head();
3164   } else if (TraceLoopOpts) {
3165     tty-&gt;print(&quot;Empty with%s zero trip guard   &quot;, needs_guard ? &quot;out&quot; : &quot;&quot;);
3166     this-&gt;dump_head();
3167   }
3168 #endif
3169 
3170   if (needs_guard) {
3171     // Peel the loop to ensure there&#39;s a zero trip guard
3172     Node_List old_new;
3173     phase-&gt;do_peeling(this, old_new);
3174   }
3175 
3176   // Replace the phi at loop head with the final value of the last
3177   // iteration.  Then the CountedLoopEnd will collapse (backedge never
3178   // taken) and all loop-invariant uses of the exit values will be correct.
3179   Node *phi = cl-&gt;phi();
3180   Node *exact_limit = phase-&gt;exact_limit(this);
3181   if (exact_limit != cl-&gt;limit()) {
3182     // We also need to replace the original limit to collapse loop exit.
3183     Node* cmp = cl-&gt;loopexit()-&gt;cmp_node();
3184     assert(cl-&gt;limit() == cmp-&gt;in(2), &quot;sanity&quot;);
3185     // Duplicate cmp node if it has other users
3186     if (cmp-&gt;outcnt() &gt; 1) {
3187       cmp = cmp-&gt;clone();
3188       cmp = phase-&gt;_igvn.register_new_node_with_optimizer(cmp);
3189       BoolNode *bol = cl-&gt;loopexit()-&gt;in(CountedLoopEndNode::TestValue)-&gt;as_Bool();
3190       phase-&gt;_igvn.replace_input_of(bol, 1, cmp); // put bol on worklist
3191     }
3192     phase-&gt;_igvn._worklist.push(cmp-&gt;in(2)); // put limit on worklist
3193     phase-&gt;_igvn.replace_input_of(cmp, 2, exact_limit); // put cmp on worklist
3194   }
3195   // Note: the final value after increment should not overflow since
3196   // counted loop has limit check predicate.
3197   Node *final = new SubINode(exact_limit, cl-&gt;stride());
3198   phase-&gt;register_new_node(final,cl-&gt;in(LoopNode::EntryControl));
3199   phase-&gt;_igvn.replace_node(phi,final);
3200   phase-&gt;C-&gt;set_major_progress();
3201   return true;
3202 }
3203 
3204 //------------------------------do_one_iteration_loop--------------------------
3205 // Convert one iteration loop into normal code.
3206 bool IdealLoopTree::do_one_iteration_loop(PhaseIdealLoop *phase) {
3207   if (!_head-&gt;as_Loop()-&gt;is_valid_counted_loop()) {
3208     return false; // Only for counted loop
3209   }
3210   CountedLoopNode *cl = _head-&gt;as_CountedLoop();
3211   if (!cl-&gt;has_exact_trip_count() || cl-&gt;trip_count() != 1) {
3212     return false;
3213   }
3214 
3215 #ifndef PRODUCT
3216   if (TraceLoopOpts) {
3217     tty-&gt;print(&quot;OneIteration &quot;);
3218     this-&gt;dump_head();
3219   }
3220 #endif
3221 
3222   Node *init_n = cl-&gt;init_trip();
3223 #ifdef ASSERT
3224   // Loop boundaries should be constant since trip count is exact.
3225   assert(init_n-&gt;get_int() + cl-&gt;stride_con() &gt;= cl-&gt;limit()-&gt;get_int(), &quot;should be one iteration&quot;);
3226 #endif
3227   // Replace the phi at loop head with the value of the init_trip.
3228   // Then the CountedLoopEnd will collapse (backedge will not be taken)
3229   // and all loop-invariant uses of the exit values will be correct.
3230   phase-&gt;_igvn.replace_node(cl-&gt;phi(), cl-&gt;init_trip());
3231   phase-&gt;C-&gt;set_major_progress();
3232   return true;
3233 }
3234 
3235 //=============================================================================
3236 //------------------------------iteration_split_impl---------------------------
3237 bool IdealLoopTree::iteration_split_impl(PhaseIdealLoop *phase, Node_List &amp;old_new) {
3238   // Compute loop trip count if possible.
3239   compute_trip_count(phase);
3240 
3241   // Convert one iteration loop into normal code.
3242   if (do_one_iteration_loop(phase)) {
3243     return true;
3244   }
3245   // Check and remove empty loops (spam micro-benchmarks)
3246   if (do_remove_empty_loop(phase)) {
3247     return true;  // Here we removed an empty loop
3248   }
3249 
3250   AutoNodeBudget node_budget(phase);
3251 
3252   // Non-counted loops may be peeled; exactly 1 iteration is peeled.
3253   // This removes loop-invariant tests (usually null checks).
3254   if (!_head-&gt;is_CountedLoop()) { // Non-counted loop
3255     if (PartialPeelLoop &amp;&amp; phase-&gt;partial_peel(this, old_new)) {
3256       // Partial peel succeeded so terminate this round of loop opts
3257       return false;
3258     }
3259     if (policy_peeling(phase)) {    // Should we peel?
3260       if (PrintOpto) { tty-&gt;print_cr(&quot;should_peel&quot;); }
3261       phase-&gt;do_peeling(this, old_new);
3262     } else if (policy_unswitching(phase)) {
3263       phase-&gt;do_unswitching(this, old_new);
3264     }
3265     return true;
3266   }
3267   CountedLoopNode *cl = _head-&gt;as_CountedLoop();
3268 
3269   if (!cl-&gt;is_valid_counted_loop()) return true; // Ignore various kinds of broken loops
3270 
3271   // Do nothing special to pre- and post- loops
3272   if (cl-&gt;is_pre_loop() || cl-&gt;is_post_loop()) return true;
3273 
3274   // Compute loop trip count from profile data
3275   compute_profile_trip_cnt(phase);
3276 
3277   // Before attempting fancy unrolling, RCE or alignment, see if we want
3278   // to completely unroll this loop or do loop unswitching.
3279   if (cl-&gt;is_normal_loop()) {
3280     if (policy_unswitching(phase)) {
3281       phase-&gt;do_unswitching(this, old_new);
3282       return true;
3283     }
3284     if (policy_maximally_unroll(phase)) {
3285       // Here we did some unrolling and peeling.  Eventually we will
3286       // completely unroll this loop and it will no longer be a loop.
3287       phase-&gt;do_maximally_unroll(this, old_new);
3288       return true;
3289     }
3290   }
3291 
3292   uint est_peeling = estimate_peeling(phase);
3293   bool should_peel = 0 &lt; est_peeling;
3294 
3295   // Counted loops may be peeled, may need some iterations run up
3296   // front for RCE, and may want to align loop refs to a cache
3297   // line.  Thus we clone a full loop up front whose trip count is
3298   // at least 1 (if peeling), but may be several more.
3299 
3300   // The main loop will start cache-line aligned with at least 1
3301   // iteration of the unrolled body (zero-trip test required) and
3302   // will have some range checks removed.
3303 
3304   // A post-loop will finish any odd iterations (leftover after
3305   // unrolling), plus any needed for RCE purposes.
3306 
3307   bool should_unroll = policy_unroll(phase);
3308   bool should_rce    = policy_range_check(phase);
3309   // TODO: Remove align -- not used.
3310   bool should_align  = policy_align(phase);
3311 
3312   // If not RCE&#39;ing  (iteration splitting) or Aligning, then we  do not need a
3313   // pre-loop.  We may still need to peel an initial iteration but we will not
3314   // be needing an unknown number of pre-iterations.
3315   //
3316   // Basically, if may_rce_align reports FALSE first time through, we will not
3317   // be able to later do RCE or Aligning on this loop.
3318   bool may_rce_align = !policy_peel_only(phase) || should_rce || should_align;
3319 
3320   // If we have any of these conditions (RCE, alignment, unrolling) met, then
3321   // we switch to the pre-/main-/post-loop model.  This model also covers
3322   // peeling.
3323   if (should_rce || should_align || should_unroll) {
3324     if (cl-&gt;is_normal_loop()) { // Convert to &#39;pre/main/post&#39; loops
3325       uint estimate = est_loop_clone_sz(3);
3326       if (!phase-&gt;may_require_nodes(estimate)) {
3327         return false;
3328       }
3329       phase-&gt;insert_pre_post_loops(this, old_new, !may_rce_align);
3330     }
3331     // Adjust the pre- and main-loop limits to let the pre and  post loops run
3332     // with full checks, but the main-loop with no checks.  Remove said checks
3333     // from the main body.
3334     if (should_rce) {
3335       if (phase-&gt;do_range_check(this, old_new) != 0) {
3336         cl-&gt;mark_has_range_checks();
3337       }
3338     } else if (PostLoopMultiversioning) {
3339       phase-&gt;has_range_checks(this);
3340     }
3341 
3342     if (should_unroll &amp;&amp; !should_peel &amp;&amp; PostLoopMultiversioning) {
3343       // Try to setup multiversioning on main loops before they are unrolled
3344       if (cl-&gt;is_main_loop() &amp;&amp; (cl-&gt;unrolled_count() == 1)) {
3345         phase-&gt;insert_scalar_rced_post_loop(this, old_new);
3346       }
3347     }
3348 
3349     // Double loop body for unrolling.  Adjust the minimum-trip test (will do
3350     // twice as many iterations as before) and the main body limit (only do
3351     // an even number of trips).  If we are peeling, we might enable some RCE
3352     // and we&#39;d rather unroll the post-RCE&#39;d loop SO... do not unroll if
3353     // peeling.
3354     if (should_unroll &amp;&amp; !should_peel) {
3355       if (SuperWordLoopUnrollAnalysis) {
3356         phase-&gt;insert_vector_post_loop(this, old_new);
3357       }
3358       phase-&gt;do_unroll(this, old_new, true);
3359     }
3360 
3361     // Adjust the pre-loop limits to align the main body iterations.
3362     if (should_align) {
3363       Unimplemented();
3364     }
3365   } else {                      // Else we have an unchanged counted loop
3366     if (should_peel) {          // Might want to peel but do nothing else
3367       if (phase-&gt;may_require_nodes(est_peeling)) {
3368         phase-&gt;do_peeling(this, old_new);
3369       }
3370     }
3371   }
3372   return true;
3373 }
3374 
3375 
3376 //=============================================================================
3377 //------------------------------iteration_split--------------------------------
3378 bool IdealLoopTree::iteration_split(PhaseIdealLoop* phase, Node_List &amp;old_new) {
3379   // Recursively iteration split nested loops
3380   if (_child &amp;&amp; !_child-&gt;iteration_split(phase, old_new)) {
3381     return false;
3382   }
3383 
3384   // Clean out prior deadwood
3385   DCE_loop_body();
3386 
3387   // Look for loop-exit tests with my 50/50 guesses from the Parsing stage.
3388   // Replace with a 1-in-10 exit guess.
3389   if (!is_root() &amp;&amp; is_loop()) {
3390     adjust_loop_exit_prob(phase);
3391   }
3392 
3393   // Unrolling, RCE and peeling efforts, iff innermost loop.
3394   if (_allow_optimizations &amp;&amp; is_innermost()) {
3395     if (!_has_call) {
3396       if (!iteration_split_impl(phase, old_new)) {
3397         return false;
3398       }
3399     } else {
3400       AutoNodeBudget node_budget(phase);
3401       if (policy_unswitching(phase)) {
3402         phase-&gt;do_unswitching(this, old_new);
3403       }
3404     }
3405   }
3406 
3407   // Minor offset re-organization to remove loop-fallout uses of
3408   // trip counter when there was no major reshaping.
3409   phase-&gt;reorg_offsets(this);
3410 
3411   if (_next &amp;&amp; !_next-&gt;iteration_split(phase, old_new)) {
3412     return false;
3413   }
3414   return true;
3415 }
3416 
3417 
3418 //=============================================================================
3419 // Process all the loops in the loop tree and replace any fill
3420 // patterns with an intrinsic version.
3421 bool PhaseIdealLoop::do_intrinsify_fill() {
3422   bool changed = false;
3423   for (LoopTreeIterator iter(_ltree_root); !iter.done(); iter.next()) {
3424     IdealLoopTree* lpt = iter.current();
3425     changed |= intrinsify_fill(lpt);
3426   }
3427   return changed;
3428 }
3429 
3430 
3431 // Examine an inner loop looking for a a single store of an invariant
3432 // value in a unit stride loop,
3433 bool PhaseIdealLoop::match_fill_loop(IdealLoopTree* lpt, Node*&amp; store, Node*&amp; store_value,
3434                                      Node*&amp; shift, Node*&amp; con) {
3435   const char* msg = NULL;
3436   Node* msg_node = NULL;
3437 
3438   store_value = NULL;
3439   con = NULL;
3440   shift = NULL;
3441 
3442   // Process the loop looking for stores.  If there are multiple
3443   // stores or extra control flow give at this point.
3444   CountedLoopNode* head = lpt-&gt;_head-&gt;as_CountedLoop();
3445   for (uint i = 0; msg == NULL &amp;&amp; i &lt; lpt-&gt;_body.size(); i++) {
3446     Node* n = lpt-&gt;_body.at(i);
3447     if (n-&gt;outcnt() == 0) continue; // Ignore dead
3448     if (n-&gt;is_Store()) {
3449       if (store != NULL) {
3450         msg = &quot;multiple stores&quot;;
3451         break;
3452       }
3453       int opc = n-&gt;Opcode();
3454       if (opc == Op_StoreP || opc == Op_StoreN || opc == Op_StoreNKlass || opc == Op_StoreCM) {
3455         msg = &quot;oop fills not handled&quot;;
3456         break;
3457       }
3458       Node* value = n-&gt;in(MemNode::ValueIn);
3459       if (!lpt-&gt;is_invariant(value)) {
3460         msg  = &quot;variant store value&quot;;
3461       } else if (!_igvn.type(n-&gt;in(MemNode::Address))-&gt;isa_aryptr()) {
3462         msg = &quot;not array address&quot;;
3463       }
3464       store = n;
3465       store_value = value;
3466     } else if (n-&gt;is_If() &amp;&amp; n != head-&gt;loopexit_or_null()) {
3467       msg = &quot;extra control flow&quot;;
3468       msg_node = n;
3469     }
3470   }
3471 
3472   if (store == NULL) {
3473     // No store in loop
3474     return false;
3475   }
3476 
3477   if (msg == NULL &amp;&amp; head-&gt;stride_con() != 1) {
3478     // could handle negative strides too
3479     if (head-&gt;stride_con() &lt; 0) {
3480       msg = &quot;negative stride&quot;;
3481     } else {
3482       msg = &quot;non-unit stride&quot;;
3483     }
3484   }
3485 
3486   if (msg == NULL &amp;&amp; !store-&gt;in(MemNode::Address)-&gt;is_AddP()) {
3487     msg = &quot;can&#39;t handle store address&quot;;
3488     msg_node = store-&gt;in(MemNode::Address);
3489   }
3490 
3491   if (msg == NULL &amp;&amp;
3492       (!store-&gt;in(MemNode::Memory)-&gt;is_Phi() ||
3493        store-&gt;in(MemNode::Memory)-&gt;in(LoopNode::LoopBackControl) != store)) {
3494     msg = &quot;store memory isn&#39;t proper phi&quot;;
3495     msg_node = store-&gt;in(MemNode::Memory);
3496   }
3497 
3498   // Make sure there is an appropriate fill routine
3499   BasicType t = store-&gt;as_Mem()-&gt;memory_type();
3500   const char* fill_name;
3501   if (msg == NULL &amp;&amp;
3502       StubRoutines::select_fill_function(t, false, fill_name) == NULL) {
3503     msg = &quot;unsupported store&quot;;
3504     msg_node = store;
3505   }
3506 
3507   if (msg != NULL) {
3508 #ifndef PRODUCT
3509     if (TraceOptimizeFill) {
3510       tty-&gt;print_cr(&quot;not fill intrinsic candidate: %s&quot;, msg);
3511       if (msg_node != NULL) msg_node-&gt;dump();
3512     }
3513 #endif
3514     return false;
3515   }
3516 
3517   // Make sure the address expression can be handled.  It should be
3518   // head-&gt;phi * elsize + con.  head-&gt;phi might have a ConvI2L(CastII()).
3519   Node* elements[4];
3520   Node* cast = NULL;
3521   Node* conv = NULL;
3522   bool found_index = false;
3523   int count = store-&gt;in(MemNode::Address)-&gt;as_AddP()-&gt;unpack_offsets(elements, ARRAY_SIZE(elements));
3524   for (int e = 0; e &lt; count; e++) {
3525     Node* n = elements[e];
3526     if (n-&gt;is_Con() &amp;&amp; con == NULL) {
3527       con = n;
3528     } else if (n-&gt;Opcode() == Op_LShiftX &amp;&amp; shift == NULL) {
3529       Node* value = n-&gt;in(1);
3530 #ifdef _LP64
3531       if (value-&gt;Opcode() == Op_ConvI2L) {
3532         conv = value;
3533         value = value-&gt;in(1);
3534       }
3535       if (value-&gt;Opcode() == Op_CastII &amp;&amp;
3536           value-&gt;as_CastII()-&gt;has_range_check()) {
3537         // Skip range check dependent CastII nodes
3538         cast = value;
3539         value = value-&gt;in(1);
3540       }
3541 #endif
3542       if (value != head-&gt;phi()) {
3543         msg = &quot;unhandled shift in address&quot;;
3544       } else {
3545         if (type2aelembytes(store-&gt;as_Mem()-&gt;memory_type(), true) != (1 &lt;&lt; n-&gt;in(2)-&gt;get_int())) {
3546           msg = &quot;scale doesn&#39;t match&quot;;
3547         } else {
3548           found_index = true;
3549           shift = n;
3550         }
3551       }
3552     } else if (n-&gt;Opcode() == Op_ConvI2L &amp;&amp; conv == NULL) {
3553       conv = n;
3554       n = n-&gt;in(1);
3555       if (n-&gt;Opcode() == Op_CastII &amp;&amp;
3556           n-&gt;as_CastII()-&gt;has_range_check()) {
3557         // Skip range check dependent CastII nodes
3558         cast = n;
3559         n = n-&gt;in(1);
3560       }
3561       if (n == head-&gt;phi()) {
3562         found_index = true;
3563       } else {
3564         msg = &quot;unhandled input to ConvI2L&quot;;
3565       }
3566     } else if (n == head-&gt;phi()) {
3567       // no shift, check below for allowed cases
3568       found_index = true;
3569     } else {
3570       msg = &quot;unhandled node in address&quot;;
3571       msg_node = n;
3572     }
3573   }
3574 
3575   if (count == -1) {
3576     msg = &quot;malformed address expression&quot;;
3577     msg_node = store;
3578   }
3579 
3580   if (!found_index) {
3581     msg = &quot;missing use of index&quot;;
3582   }
3583 
3584   // byte sized items won&#39;t have a shift
3585   if (msg == NULL &amp;&amp; shift == NULL &amp;&amp; t != T_BYTE &amp;&amp; t != T_BOOLEAN) {
3586     msg = &quot;can&#39;t find shift&quot;;
3587     msg_node = store;
3588   }
3589 
3590   if (msg != NULL) {
3591 #ifndef PRODUCT
3592     if (TraceOptimizeFill) {
3593       tty-&gt;print_cr(&quot;not fill intrinsic: %s&quot;, msg);
3594       if (msg_node != NULL) msg_node-&gt;dump();
3595     }
3596 #endif
3597     return false;
3598   }
3599 
3600   // No make sure all the other nodes in the loop can be handled
3601   VectorSet ok(Thread::current()-&gt;resource_area());
3602 
3603   // store related values are ok
3604   ok.set(store-&gt;_idx);
3605   ok.set(store-&gt;in(MemNode::Memory)-&gt;_idx);
3606 
3607   CountedLoopEndNode* loop_exit = head-&gt;loopexit();
3608 
3609   // Loop structure is ok
3610   ok.set(head-&gt;_idx);
3611   ok.set(loop_exit-&gt;_idx);
3612   ok.set(head-&gt;phi()-&gt;_idx);
3613   ok.set(head-&gt;incr()-&gt;_idx);
3614   ok.set(loop_exit-&gt;cmp_node()-&gt;_idx);
3615   ok.set(loop_exit-&gt;in(1)-&gt;_idx);
3616 
3617   // Address elements are ok
3618   if (con)   ok.set(con-&gt;_idx);
3619   if (shift) ok.set(shift-&gt;_idx);
3620   if (cast)  ok.set(cast-&gt;_idx);
3621   if (conv)  ok.set(conv-&gt;_idx);
3622 
3623   for (uint i = 0; msg == NULL &amp;&amp; i &lt; lpt-&gt;_body.size(); i++) {
3624     Node* n = lpt-&gt;_body.at(i);
3625     if (n-&gt;outcnt() == 0) continue; // Ignore dead
3626     if (ok.test(n-&gt;_idx)) continue;
3627     // Backedge projection is ok
3628     if (n-&gt;is_IfTrue() &amp;&amp; n-&gt;in(0) == loop_exit) continue;
3629     if (!n-&gt;is_AddP()) {
3630       msg = &quot;unhandled node&quot;;
3631       msg_node = n;
3632       break;
3633     }
3634   }
3635 
3636   // Make sure no unexpected values are used outside the loop
3637   for (uint i = 0; msg == NULL &amp;&amp; i &lt; lpt-&gt;_body.size(); i++) {
3638     Node* n = lpt-&gt;_body.at(i);
3639     // These values can be replaced with other nodes if they are used
3640     // outside the loop.
3641     if (n == store || n == loop_exit || n == head-&gt;incr() || n == store-&gt;in(MemNode::Memory)) continue;
3642     for (SimpleDUIterator iter(n); iter.has_next(); iter.next()) {
3643       Node* use = iter.get();
3644       if (!lpt-&gt;_body.contains(use)) {
3645         msg = &quot;node is used outside loop&quot;;
3646         // lpt-&gt;_body.dump();
3647         msg_node = n;
3648         break;
3649       }
3650     }
3651   }
3652 
3653 #ifdef ASSERT
3654   if (TraceOptimizeFill) {
3655     if (msg != NULL) {
3656       tty-&gt;print_cr(&quot;no fill intrinsic: %s&quot;, msg);
3657       if (msg_node != NULL) msg_node-&gt;dump();
3658     } else {
3659       tty-&gt;print_cr(&quot;fill intrinsic for:&quot;);
3660     }
3661     store-&gt;dump();
3662     if (Verbose) {
3663       lpt-&gt;_body.dump();
3664     }
3665   }
3666 #endif
3667 
3668   return msg == NULL;
3669 }
3670 
3671 
3672 
3673 bool PhaseIdealLoop::intrinsify_fill(IdealLoopTree* lpt) {
3674   // Only for counted inner loops
3675   if (!lpt-&gt;is_counted() || !lpt-&gt;is_innermost()) {
3676     return false;
3677   }
3678 
3679   // Must have constant stride
3680   CountedLoopNode* head = lpt-&gt;_head-&gt;as_CountedLoop();
3681   if (!head-&gt;is_valid_counted_loop() || !head-&gt;is_normal_loop()) {
3682     return false;
3683   }
3684 
3685   head-&gt;verify_strip_mined(1);
3686 
3687   // Check that the body only contains a store of a loop invariant
3688   // value that is indexed by the loop phi.
3689   Node* store = NULL;
3690   Node* store_value = NULL;
3691   Node* shift = NULL;
3692   Node* offset = NULL;
3693   if (!match_fill_loop(lpt, store, store_value, shift, offset)) {
3694     return false;
3695   }
3696 
3697   Node* exit = head-&gt;loopexit()-&gt;proj_out_or_null(0);
3698   if (exit == NULL) {
3699     return false;
3700   }
3701 
3702 #ifndef PRODUCT
3703   if (TraceLoopOpts) {
3704     tty-&gt;print(&quot;ArrayFill    &quot;);
3705     lpt-&gt;dump_head();
3706   }
3707 #endif
3708 
3709   // Now replace the whole loop body by a call to a fill routine that
3710   // covers the same region as the loop.
3711   Node* base = store-&gt;in(MemNode::Address)-&gt;as_AddP()-&gt;in(AddPNode::Base);
3712 
3713   // Build an expression for the beginning of the copy region
3714   Node* index = head-&gt;init_trip();
3715 #ifdef _LP64
3716   index = new ConvI2LNode(index);
3717   _igvn.register_new_node_with_optimizer(index);
3718 #endif
3719   if (shift != NULL) {
3720     // byte arrays don&#39;t require a shift but others do.
3721     index = new LShiftXNode(index, shift-&gt;in(2));
3722     _igvn.register_new_node_with_optimizer(index);
3723   }
3724   index = new AddPNode(base, base, index);
3725   _igvn.register_new_node_with_optimizer(index);
3726   Node* from = new AddPNode(base, index, offset);
3727   _igvn.register_new_node_with_optimizer(from);
3728   // Compute the number of elements to copy
3729   Node* len = new SubINode(head-&gt;limit(), head-&gt;init_trip());
3730   _igvn.register_new_node_with_optimizer(len);
3731 
3732   BasicType t = store-&gt;as_Mem()-&gt;memory_type();
3733   bool aligned = false;
3734   if (offset != NULL &amp;&amp; head-&gt;init_trip()-&gt;is_Con()) {
3735     int element_size = type2aelembytes(t);
3736     aligned = (offset-&gt;find_intptr_t_type()-&gt;get_con() + head-&gt;init_trip()-&gt;get_int() * element_size) % HeapWordSize == 0;
3737   }
3738 
3739   // Build a call to the fill routine
3740   const char* fill_name;
3741   address fill = StubRoutines::select_fill_function(t, aligned, fill_name);
3742   assert(fill != NULL, &quot;what?&quot;);
3743 
3744   // Convert float/double to int/long for fill routines
3745   if (t == T_FLOAT) {
3746     store_value = new MoveF2INode(store_value);
3747     _igvn.register_new_node_with_optimizer(store_value);
3748   } else if (t == T_DOUBLE) {
3749     store_value = new MoveD2LNode(store_value);
3750     _igvn.register_new_node_with_optimizer(store_value);
3751   }
3752 
3753   Node* mem_phi = store-&gt;in(MemNode::Memory);
3754   Node* result_ctrl;
3755   Node* result_mem;
3756   const TypeFunc* call_type = OptoRuntime::array_fill_Type();
3757   CallLeafNode *call = new CallLeafNoFPNode(call_type, fill,
3758                                             fill_name, TypeAryPtr::get_array_body_type(t));
3759   uint cnt = 0;
3760   call-&gt;init_req(TypeFunc::Parms + cnt++, from);
3761   call-&gt;init_req(TypeFunc::Parms + cnt++, store_value);
3762 #ifdef _LP64
3763   len = new ConvI2LNode(len);
3764   _igvn.register_new_node_with_optimizer(len);
3765 #endif
3766   call-&gt;init_req(TypeFunc::Parms + cnt++, len);
3767 #ifdef _LP64
3768   call-&gt;init_req(TypeFunc::Parms + cnt++, C-&gt;top());
3769 #endif
3770   call-&gt;init_req(TypeFunc::Control,   head-&gt;init_control());
3771   call-&gt;init_req(TypeFunc::I_O,       C-&gt;top());       // Does no I/O.
3772   call-&gt;init_req(TypeFunc::Memory,    mem_phi-&gt;in(LoopNode::EntryControl));
3773   call-&gt;init_req(TypeFunc::ReturnAdr, C-&gt;start()-&gt;proj_out_or_null(TypeFunc::ReturnAdr));
3774   call-&gt;init_req(TypeFunc::FramePtr,  C-&gt;start()-&gt;proj_out_or_null(TypeFunc::FramePtr));
3775   _igvn.register_new_node_with_optimizer(call);
3776   result_ctrl = new ProjNode(call,TypeFunc::Control);
3777   _igvn.register_new_node_with_optimizer(result_ctrl);
3778   result_mem = new ProjNode(call,TypeFunc::Memory);
3779   _igvn.register_new_node_with_optimizer(result_mem);
3780 
3781 /* Disable following optimization until proper fix (add missing checks).
3782 
3783   // If this fill is tightly coupled to an allocation and overwrites
3784   // the whole body, allow it to take over the zeroing.
3785   AllocateNode* alloc = AllocateNode::Ideal_allocation(base, this);
3786   if (alloc != NULL &amp;&amp; alloc-&gt;is_AllocateArray()) {
3787     Node* length = alloc-&gt;as_AllocateArray()-&gt;Ideal_length();
3788     if (head-&gt;limit() == length &amp;&amp;
3789         head-&gt;init_trip() == _igvn.intcon(0)) {
3790       if (TraceOptimizeFill) {
3791         tty-&gt;print_cr(&quot;Eliminated zeroing in allocation&quot;);
3792       }
3793       alloc-&gt;maybe_set_complete(&amp;_igvn);
3794     } else {
3795 #ifdef ASSERT
3796       if (TraceOptimizeFill) {
3797         tty-&gt;print_cr(&quot;filling array but bounds don&#39;t match&quot;);
3798         alloc-&gt;dump();
3799         head-&gt;init_trip()-&gt;dump();
3800         head-&gt;limit()-&gt;dump();
3801         length-&gt;dump();
3802       }
3803 #endif
3804     }
3805   }
3806 */
3807 
3808   if (head-&gt;is_strip_mined()) {
3809     // Inner strip mined loop goes away so get rid of outer strip
3810     // mined loop
3811     Node* outer_sfpt = head-&gt;outer_safepoint();
3812     Node* in = outer_sfpt-&gt;in(0);
3813     Node* outer_out = head-&gt;outer_loop_exit();
3814     lazy_replace(outer_out, in);
3815     _igvn.replace_input_of(outer_sfpt, 0, C-&gt;top());
3816   }
3817 
3818   // Redirect the old control and memory edges that are outside the loop.
3819   // Sometimes the memory phi of the head is used as the outgoing
3820   // state of the loop.  It&#39;s safe in this case to replace it with the
3821   // result_mem.
3822   _igvn.replace_node(store-&gt;in(MemNode::Memory), result_mem);
3823   lazy_replace(exit, result_ctrl);
3824   _igvn.replace_node(store, result_mem);
3825   // Any uses the increment outside of the loop become the loop limit.
3826   _igvn.replace_node(head-&gt;incr(), head-&gt;limit());
3827 
3828   // Disconnect the head from the loop.
3829   for (uint i = 0; i &lt; lpt-&gt;_body.size(); i++) {
3830     Node* n = lpt-&gt;_body.at(i);
3831     _igvn.replace_node(n, C-&gt;top());
3832   }
3833 
3834   return true;
3835 }
<a name="15" id="anc15"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="15" type="hidden" />
</body>
</html>
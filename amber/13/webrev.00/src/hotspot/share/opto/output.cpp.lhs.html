<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/output.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/assembler.inline.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;code/compiledIC.hpp&quot;
  29 #include &quot;code/debugInfo.hpp&quot;
  30 #include &quot;code/debugInfoRec.hpp&quot;
  31 #include &quot;compiler/compileBroker.hpp&quot;
  32 #include &quot;compiler/compilerDirectives.hpp&quot;
  33 #include &quot;compiler/oopMap.hpp&quot;
  34 #include &quot;gc/shared/barrierSet.hpp&quot;
  35 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  36 #include &quot;memory/allocation.inline.hpp&quot;
  37 #include &quot;opto/ad.hpp&quot;
<a name="1" id="anc1"></a>

  38 #include &quot;opto/callnode.hpp&quot;
  39 #include &quot;opto/cfgnode.hpp&quot;
  40 #include &quot;opto/locknode.hpp&quot;
  41 #include &quot;opto/machnode.hpp&quot;
<a name="2" id="anc2"></a>
  42 #include &quot;opto/optoreg.hpp&quot;
  43 #include &quot;opto/output.hpp&quot;
  44 #include &quot;opto/regalloc.hpp&quot;
  45 #include &quot;opto/runtime.hpp&quot;
  46 #include &quot;opto/subnode.hpp&quot;
  47 #include &quot;opto/type.hpp&quot;
  48 #include &quot;runtime/handles.inline.hpp&quot;
<a name="3" id="anc3"></a>
  49 #include &quot;utilities/macros.hpp&quot;
  50 #include &quot;utilities/powerOfTwo.hpp&quot;
  51 #include &quot;utilities/xmlstream.hpp&quot;
<a name="4" id="anc4"></a><span class="line-removed">  52 #ifdef X86</span>
<span class="line-removed">  53 #include &quot;c2_intelJccErratum_x86.hpp&quot;</span>
<span class="line-removed">  54 #endif</span>
  55 
  56 #ifndef PRODUCT
  57 #define DEBUG_ARG(x) , x
  58 #else
  59 #define DEBUG_ARG(x)
  60 #endif
  61 
<a name="5" id="anc5"></a>













































































































































































































  62 // Convert Nodes to instruction bits and pass off to the VM
<a name="6" id="anc6"></a><span class="line-modified">  63 void Compile::Output() {</span>
  64   // RootNode goes
<a name="7" id="anc7"></a><span class="line-modified">  65   assert( _cfg-&gt;get_root_block()-&gt;number_of_nodes() == 0, &quot;&quot; );</span>
  66 
  67   // The number of new nodes (mostly MachNop) is proportional to
  68   // the number of java calls and inner loops which are aligned.
  69   if ( C-&gt;check_node_count((NodeLimitFudgeFactor + C-&gt;java_calls()*3 +
  70                             C-&gt;inner_loops()*(OptoLoopAlignment-1)),
  71                            &quot;out of nodes before code generation&quot; ) ) {
  72     return;
  73   }
  74   // Make sure I can find the Start Node
<a name="8" id="anc8"></a><span class="line-modified">  75   Block *entry = _cfg-&gt;get_block(1);</span>
<span class="line-modified">  76   Block *broot = _cfg-&gt;get_root_block();</span>
  77 
  78   const StartNode *start = entry-&gt;head()-&gt;as_Start();
  79 
  80   // Replace StartNode with prolog
  81   MachPrologNode *prolog = new MachPrologNode();
  82   entry-&gt;map_node(prolog, 0);
<a name="9" id="anc9"></a><span class="line-modified">  83   _cfg-&gt;map_node_to_block(prolog, entry);</span>
<span class="line-modified">  84   _cfg-&gt;unmap_node_from_block(start); // start is no longer in any block</span>
  85 
  86   // Virtual methods need an unverified entry point
  87 
<a name="10" id="anc10"></a><span class="line-modified">  88   if( is_osr_compilation() ) {</span>
  89     if( PoisonOSREntry ) {
  90       // TODO: Should use a ShouldNotReachHereNode...
<a name="11" id="anc11"></a><span class="line-modified">  91       _cfg-&gt;insert( broot, 0, new MachBreakpointNode() );</span>
  92     }
  93   } else {
<a name="12" id="anc12"></a><span class="line-modified">  94     if( _method &amp;&amp; !_method-&gt;flags().is_static() ) {</span>
  95       // Insert unvalidated entry point
<a name="13" id="anc13"></a><span class="line-modified">  96       _cfg-&gt;insert( broot, 0, new MachUEPNode() );</span>
  97     }
  98 
  99   }
 100 
 101   // Break before main entry point
<a name="14" id="anc14"></a><span class="line-modified"> 102   if ((_method &amp;&amp; C-&gt;directive()-&gt;BreakAtExecuteOption) ||</span>
<span class="line-modified"> 103       (OptoBreakpoint &amp;&amp; is_method_compilation())       ||</span>
<span class="line-modified"> 104       (OptoBreakpointOSR &amp;&amp; is_osr_compilation())       ||</span>
<span class="line-modified"> 105       (OptoBreakpointC2R &amp;&amp; !_method)                   ) {</span>
<span class="line-modified"> 106     // checking for _method means that OptoBreakpoint does not apply to</span>
 107     // runtime stubs or frame converters
<a name="15" id="anc15"></a><span class="line-modified"> 108     _cfg-&gt;insert( entry, 1, new MachBreakpointNode() );</span>
 109   }
 110 
 111   // Insert epilogs before every return
<a name="16" id="anc16"></a><span class="line-modified"> 112   for (uint i = 0; i &lt; _cfg-&gt;number_of_blocks(); i++) {</span>
<span class="line-modified"> 113     Block* block = _cfg-&gt;get_block(i);</span>
<span class="line-modified"> 114     if (!block-&gt;is_connector() &amp;&amp; block-&gt;non_connector_successor(0) == _cfg-&gt;get_root_block()) { // Found a program exit point?</span>
 115       Node* m = block-&gt;end();
 116       if (m-&gt;is_Mach() &amp;&amp; m-&gt;as_Mach()-&gt;ideal_Opcode() != Op_Halt) {
 117         MachEpilogNode* epilog = new MachEpilogNode(m-&gt;as_Mach()-&gt;ideal_Opcode() == Op_Return);
 118         block-&gt;add_inst(epilog);
<a name="17" id="anc17"></a><span class="line-modified"> 119         _cfg-&gt;map_node_to_block(epilog, block);</span>
 120       }
 121     }
 122   }
 123 
 124   // Keeper of sizing aspects
<a name="18" id="anc18"></a><span class="line-modified"> 125   BufferSizingData buf_sizes = BufferSizingData();</span>
 126 
 127   // Initialize code buffer
<a name="19" id="anc19"></a><span class="line-modified"> 128   estimate_buffer_size(buf_sizes._const);</span>
<span class="line-modified"> 129   if (failing()) return;</span>
 130 
 131   // Pre-compute the length of blocks and replace
 132   // long branches with short if machine supports it.
 133   // Must be done before ScheduleAndBundle due to SPARC delay slots
<a name="20" id="anc20"></a><span class="line-modified"> 134   uint* blk_starts = NEW_RESOURCE_ARRAY(uint, _cfg-&gt;number_of_blocks() + 1);</span>
 135   blk_starts[0] = 0;
<a name="21" id="anc21"></a><span class="line-modified"> 136   shorten_branches(blk_starts, buf_sizes);</span>
 137 
 138   ScheduleAndBundle();
<a name="22" id="anc22"></a><span class="line-modified"> 139   if (failing()) {</span>
 140     return;
 141   }
 142 
<a name="23" id="anc23"></a><span class="line-modified"> 143   // Late barrier analysis must be done after schedule and bundle</span>
<span class="line-removed"> 144   // Otherwise liveness based spilling will fail</span>
<span class="line-removed"> 145   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();</span>
<span class="line-removed"> 146   bs-&gt;late_barrier_analysis();</span>
<span class="line-removed"> 147 </span>
<span class="line-removed"> 148 #ifdef X86</span>
<span class="line-removed"> 149   if (VM_Version::has_intel_jcc_erratum()) {</span>
<span class="line-removed"> 150     int extra_padding = IntelJccErratum::tag_affected_machnodes(this, _cfg, _regalloc);</span>
<span class="line-removed"> 151     buf_sizes._code += extra_padding;</span>
<span class="line-removed"> 152   }</span>
<span class="line-removed"> 153 #endif</span>
 154 
 155   // Complete sizing of codebuffer
<a name="24" id="anc24"></a><span class="line-modified"> 156   CodeBuffer* cb = init_buffer(buf_sizes);</span>
<span class="line-modified"> 157   if (cb == NULL || failing()) {</span>
 158     return;
 159   }
 160 
 161   BuildOopMaps();
 162 
<a name="25" id="anc25"></a><span class="line-modified"> 163   if (failing())  {</span>
 164     return;
 165   }
 166 
 167   fill_buffer(cb, blk_starts);
 168 }
 169 
<a name="26" id="anc26"></a><span class="line-modified"> 170 bool Compile::need_stack_bang(int frame_size_in_bytes) const {</span>
 171   // Determine if we need to generate a stack overflow check.
 172   // Do it if the method is not a stub function and
 173   // has java calls or has frame size &gt; vm_page_size/8.
 174   // The debug VM checks that deoptimization doesn&#39;t trigger an
 175   // unexpected stack overflow (compiled method stack banging should
 176   // guarantee it doesn&#39;t happen) so we always need the stack bang in
 177   // a debug VM.
<a name="27" id="anc27"></a><span class="line-modified"> 178   return (UseStackBanging &amp;&amp; stub_function() == NULL &amp;&amp;</span>
<span class="line-modified"> 179           (has_java_calls() || frame_size_in_bytes &gt; os::vm_page_size()&gt;&gt;3</span>
 180            DEBUG_ONLY(|| true)));
 181 }
 182 
<a name="28" id="anc28"></a><span class="line-modified"> 183 bool Compile::need_register_stack_bang() const {</span>
 184   // Determine if we need to generate a register stack overflow check.
 185   // This is only used on architectures which have split register
 186   // and memory stacks (ie. IA64).
 187   // Bang if the method is not a stub function and has java calls
<a name="29" id="anc29"></a><span class="line-modified"> 188   return (stub_function() == NULL &amp;&amp; has_java_calls());</span>
 189 }
 190 
 191 
 192 // Compute the size of first NumberOfLoopInstrToAlign instructions at the top
 193 // of a loop. When aligning a loop we need to provide enough instructions
 194 // in cpu&#39;s fetch buffer to feed decoders. The loop alignment could be
 195 // avoided if we have enough instructions in fetch buffer at the head of a loop.
 196 // By default, the size is set to 999999 by Block&#39;s constructor so that
 197 // a loop will be aligned if the size is not reset here.
 198 //
 199 // Note: Mach instructions could contain several HW instructions
 200 // so the size is estimated only.
 201 //
<a name="30" id="anc30"></a><span class="line-modified"> 202 void Compile::compute_loop_first_inst_sizes() {</span>
 203   // The next condition is used to gate the loop alignment optimization.
 204   // Don&#39;t aligned a loop if there are enough instructions at the head of a loop
 205   // or alignment padding is larger then MaxLoopPad. By default, MaxLoopPad
 206   // is equal to OptoLoopAlignment-1 except on new Intel cpus, where it is
 207   // equal to 11 bytes which is the largest address NOP instruction.
 208   if (MaxLoopPad &lt; OptoLoopAlignment - 1) {
<a name="31" id="anc31"></a><span class="line-modified"> 209     uint last_block = _cfg-&gt;number_of_blocks() - 1;</span>
 210     for (uint i = 1; i &lt;= last_block; i++) {
<a name="32" id="anc32"></a><span class="line-modified"> 211       Block* block = _cfg-&gt;get_block(i);</span>
 212       // Check the first loop&#39;s block which requires an alignment.
 213       if (block-&gt;loop_alignment() &gt; (uint)relocInfo::addr_unit()) {
 214         uint sum_size = 0;
 215         uint inst_cnt = NumberOfLoopInstrToAlign;
<a name="33" id="anc33"></a><span class="line-modified"> 216         inst_cnt = block-&gt;compute_first_inst_size(sum_size, inst_cnt, _regalloc);</span>
 217 
 218         // Check subsequent fallthrough blocks if the loop&#39;s first
 219         // block(s) does not have enough instructions.
 220         Block *nb = block;
 221         while(inst_cnt &gt; 0 &amp;&amp;
 222               i &lt; last_block &amp;&amp;
<a name="34" id="anc34"></a><span class="line-modified"> 223               !_cfg-&gt;get_block(i + 1)-&gt;has_loop_alignment() &amp;&amp;</span>
 224               !nb-&gt;has_successor(block)) {
 225           i++;
<a name="35" id="anc35"></a><span class="line-modified"> 226           nb = _cfg-&gt;get_block(i);</span>
<span class="line-modified"> 227           inst_cnt  = nb-&gt;compute_first_inst_size(sum_size, inst_cnt, _regalloc);</span>
 228         } // while( inst_cnt &gt; 0 &amp;&amp; i &lt; last_block  )
 229 
 230         block-&gt;set_first_inst_size(sum_size);
 231       } // f( b-&gt;head()-&gt;is_Loop() )
 232     } // for( i &lt;= last_block )
 233   } // if( MaxLoopPad &lt; OptoLoopAlignment-1 )
 234 }
 235 
 236 // The architecture description provides short branch variants for some long
 237 // branch instructions. Replace eligible long branches with short branches.
<a name="36" id="anc36"></a><span class="line-modified"> 238 void Compile::shorten_branches(uint* blk_starts, BufferSizingData&amp; buf_sizes) {</span>
 239   // Compute size of each block, method size, and relocation information size
<a name="37" id="anc37"></a><span class="line-modified"> 240   uint nblocks  = _cfg-&gt;number_of_blocks();</span>
 241 
 242   uint*      jmp_offset = NEW_RESOURCE_ARRAY(uint,nblocks);
 243   uint*      jmp_size   = NEW_RESOURCE_ARRAY(uint,nblocks);
 244   int*       jmp_nidx   = NEW_RESOURCE_ARRAY(int ,nblocks);
 245 
 246   // Collect worst case block paddings
 247   int* block_worst_case_pad = NEW_RESOURCE_ARRAY(int, nblocks);
 248   memset(block_worst_case_pad, 0, nblocks * sizeof(int));
 249 
 250   DEBUG_ONLY( uint *jmp_target = NEW_RESOURCE_ARRAY(uint,nblocks); )
 251   DEBUG_ONLY( uint *jmp_rule = NEW_RESOURCE_ARRAY(uint,nblocks); )
 252 
 253   bool has_short_branch_candidate = false;
 254 
 255   // Initialize the sizes to 0
 256   int code_size  = 0;          // Size in bytes of generated code
 257   int stub_size  = 0;          // Size in bytes of all stub entries
 258   // Size in bytes of all relocation entries, including those in local stubs.
 259   // Start with 2-bytes of reloc info for the unvalidated entry point
 260   int reloc_size = 1;          // Number of relocation entries
 261 
 262   // Make three passes.  The first computes pessimistic blk_starts,
 263   // relative jmp_offset and reloc_size information.  The second performs
 264   // short branch substitution using the pessimistic sizing.  The
 265   // third inserts nops where needed.
 266 
 267   // Step one, perform a pessimistic sizing pass.
 268   uint last_call_adr = max_juint;
 269   uint last_avoid_back_to_back_adr = max_juint;
<a name="38" id="anc38"></a><span class="line-modified"> 270   uint nop_size = (new MachNopNode())-&gt;size(_regalloc);</span>
 271   for (uint i = 0; i &lt; nblocks; i++) { // For all blocks
<a name="39" id="anc39"></a><span class="line-modified"> 272     Block* block = _cfg-&gt;get_block(i);</span>

 273 
 274     // During short branch replacement, we store the relative (to blk_starts)
 275     // offset of jump in jmp_offset, rather than the absolute offset of jump.
 276     // This is so that we do not need to recompute sizes of all nodes when
 277     // we compute correct blk_starts in our next sizing pass.
 278     jmp_offset[i] = 0;
 279     jmp_size[i]   = 0;
 280     jmp_nidx[i]   = -1;
 281     DEBUG_ONLY( jmp_target[i] = 0; )
 282     DEBUG_ONLY( jmp_rule[i]   = 0; )
 283 
 284     // Sum all instruction sizes to compute block size
 285     uint last_inst = block-&gt;number_of_nodes();
 286     uint blk_size = 0;
 287     for (uint j = 0; j &lt; last_inst; j++) {
<a name="40" id="anc40"></a><span class="line-modified"> 288       Node* nj = block-&gt;get_node(j);</span>

 289       // Handle machine instruction nodes
 290       if (nj-&gt;is_Mach()) {
<a name="41" id="anc41"></a><span class="line-modified"> 291         MachNode *mach = nj-&gt;as_Mach();</span>
 292         blk_size += (mach-&gt;alignment_required() - 1) * relocInfo::addr_unit(); // assume worst case padding
<a name="42" id="anc42"></a><span class="line-removed"> 293 #ifdef X86</span>
<span class="line-removed"> 294         if (VM_Version::has_intel_jcc_erratum() &amp;&amp; IntelJccErratum::is_jcc_erratum_branch(block, mach, j)) {</span>
<span class="line-removed"> 295           // Conservatively add worst case padding</span>
<span class="line-removed"> 296           blk_size += IntelJccErratum::largest_jcc_size();</span>
<span class="line-removed"> 297         }</span>
<span class="line-removed"> 298 #endif</span>
<span class="line-removed"> 299 </span>
 300         reloc_size += mach-&gt;reloc();
 301         if (mach-&gt;is_MachCall()) {
 302           // add size information for trampoline stub
 303           // class CallStubImpl is platform-specific and defined in the *.ad files.
 304           stub_size  += CallStubImpl::size_call_trampoline();
 305           reloc_size += CallStubImpl::reloc_call_trampoline();
 306 
 307           MachCallNode *mcall = mach-&gt;as_MachCall();
 308           // This destination address is NOT PC-relative
 309 
 310           mcall-&gt;method_set((intptr_t)mcall-&gt;entry_point());
 311 
 312           if (mcall-&gt;is_MachCallJava() &amp;&amp; mcall-&gt;as_MachCallJava()-&gt;_method) {
 313             stub_size  += CompiledStaticCall::to_interp_stub_size();
 314             reloc_size += CompiledStaticCall::reloc_to_interp_stub();
 315 #if INCLUDE_AOT
 316             stub_size  += CompiledStaticCall::to_aot_stub_size();
 317             reloc_size += CompiledStaticCall::reloc_to_aot_stub();
 318 #endif
 319           }
 320         } else if (mach-&gt;is_MachSafePoint()) {
 321           // If call/safepoint are adjacent, account for possible
 322           // nop to disambiguate the two safepoints.
 323           // ScheduleAndBundle() can rearrange nodes in a block,
 324           // check for all offsets inside this block.
 325           if (last_call_adr &gt;= blk_starts[i]) {
 326             blk_size += nop_size;
 327           }
 328         }
 329         if (mach-&gt;avoid_back_to_back(MachNode::AVOID_BEFORE)) {
 330           // Nop is inserted between &quot;avoid back to back&quot; instructions.
 331           // ScheduleAndBundle() can rearrange nodes in a block,
 332           // check for all offsets inside this block.
 333           if (last_avoid_back_to_back_adr &gt;= blk_starts[i]) {
 334             blk_size += nop_size;
 335           }
 336         }
 337         if (mach-&gt;may_be_short_branch()) {
 338           if (!nj-&gt;is_MachBranch()) {
 339 #ifndef PRODUCT
 340             nj-&gt;dump(3);
 341 #endif
 342             Unimplemented();
 343           }
 344           assert(jmp_nidx[i] == -1, &quot;block should have only one branch&quot;);
 345           jmp_offset[i] = blk_size;
<a name="43" id="anc43"></a><span class="line-modified"> 346           jmp_size[i]   = nj-&gt;size(_regalloc);</span>
 347           jmp_nidx[i]   = j;
 348           has_short_branch_candidate = true;
 349         }
 350       }
<a name="44" id="anc44"></a><span class="line-modified"> 351       blk_size += nj-&gt;size(_regalloc);</span>
 352       // Remember end of call offset
 353       if (nj-&gt;is_MachCall() &amp;&amp; !nj-&gt;is_MachCallLeaf()) {
 354         last_call_adr = blk_starts[i]+blk_size;
 355       }
 356       // Remember end of avoid_back_to_back offset
 357       if (nj-&gt;is_Mach() &amp;&amp; nj-&gt;as_Mach()-&gt;avoid_back_to_back(MachNode::AVOID_AFTER)) {
 358         last_avoid_back_to_back_adr = blk_starts[i]+blk_size;
 359       }
 360     }
 361 
 362     // When the next block starts a loop, we may insert pad NOP
 363     // instructions.  Since we cannot know our future alignment,
 364     // assume the worst.
 365     if (i &lt; nblocks - 1) {
<a name="45" id="anc45"></a><span class="line-modified"> 366       Block* nb = _cfg-&gt;get_block(i + 1);</span>
 367       int max_loop_pad = nb-&gt;code_alignment()-relocInfo::addr_unit();
 368       if (max_loop_pad &gt; 0) {
 369         assert(is_power_of_2(max_loop_pad+relocInfo::addr_unit()), &quot;&quot;);
 370         // Adjust last_call_adr and/or last_avoid_back_to_back_adr.
 371         // If either is the last instruction in this block, bump by
 372         // max_loop_pad in lock-step with blk_size, so sizing
 373         // calculations in subsequent blocks still can conservatively
 374         // detect that it may the last instruction in this block.
 375         if (last_call_adr == blk_starts[i]+blk_size) {
 376           last_call_adr += max_loop_pad;
 377         }
 378         if (last_avoid_back_to_back_adr == blk_starts[i]+blk_size) {
 379           last_avoid_back_to_back_adr += max_loop_pad;
 380         }
 381         blk_size += max_loop_pad;
 382         block_worst_case_pad[i + 1] = max_loop_pad;
 383       }
 384     }
 385 
 386     // Save block size; update total method size
 387     blk_starts[i+1] = blk_starts[i]+blk_size;
 388   }
 389 
 390   // Step two, replace eligible long jumps.
 391   bool progress = true;
 392   uint last_may_be_short_branch_adr = max_juint;
 393   while (has_short_branch_candidate &amp;&amp; progress) {
 394     progress = false;
 395     has_short_branch_candidate = false;
 396     int adjust_block_start = 0;
 397     for (uint i = 0; i &lt; nblocks; i++) {
<a name="46" id="anc46"></a><span class="line-modified"> 398       Block* block = _cfg-&gt;get_block(i);</span>
 399       int idx = jmp_nidx[i];
 400       MachNode* mach = (idx == -1) ? NULL: block-&gt;get_node(idx)-&gt;as_Mach();
 401       if (mach != NULL &amp;&amp; mach-&gt;may_be_short_branch()) {
 402 #ifdef ASSERT
 403         assert(jmp_size[i] &gt; 0 &amp;&amp; mach-&gt;is_MachBranch(), &quot;sanity&quot;);
 404         int j;
 405         // Find the branch; ignore trailing NOPs.
 406         for (j = block-&gt;number_of_nodes()-1; j&gt;=0; j--) {
 407           Node* n = block-&gt;get_node(j);
 408           if (!n-&gt;is_Mach() || n-&gt;as_Mach()-&gt;ideal_Opcode() != Op_Con)
 409             break;
 410         }
 411         assert(j &gt;= 0 &amp;&amp; j == idx &amp;&amp; block-&gt;get_node(j) == (Node*)mach, &quot;sanity&quot;);
 412 #endif
 413         int br_size = jmp_size[i];
 414         int br_offs = blk_starts[i] + jmp_offset[i];
 415 
 416         // This requires the TRUE branch target be in succs[0]
 417         uint bnum = block-&gt;non_connector_successor(0)-&gt;_pre_order;
 418         int offset = blk_starts[bnum] - br_offs;
 419         if (bnum &gt; i) { // adjust following block&#39;s offset
 420           offset -= adjust_block_start;
 421         }
 422 
 423         // This block can be a loop header, account for the padding
 424         // in the previous block.
 425         int block_padding = block_worst_case_pad[i];
 426         assert(i == 0 || block_padding == 0 || br_offs &gt;= block_padding, &quot;Should have at least a padding on top&quot;);
 427         // In the following code a nop could be inserted before
 428         // the branch which will increase the backward distance.
 429         bool needs_padding = ((uint)(br_offs - block_padding) == last_may_be_short_branch_adr);
 430         assert(!needs_padding || jmp_offset[i] == 0, &quot;padding only branches at the beginning of block&quot;);
 431 
 432         if (needs_padding &amp;&amp; offset &lt;= 0)
 433           offset -= nop_size;
 434 
<a name="47" id="anc47"></a><span class="line-modified"> 435         if (_matcher-&gt;is_short_branch_offset(mach-&gt;rule(), br_size, offset)) {</span>
 436           // We&#39;ve got a winner.  Replace this branch.
 437           MachNode* replacement = mach-&gt;as_MachBranch()-&gt;short_branch_version();
 438 
 439           // Update the jmp_size.
<a name="48" id="anc48"></a><span class="line-modified"> 440           int new_size = replacement-&gt;size(_regalloc);</span>
 441           int diff     = br_size - new_size;
 442           assert(diff &gt;= (int)nop_size, &quot;short_branch size should be smaller&quot;);
 443           // Conservatively take into account padding between
 444           // avoid_back_to_back branches. Previous branch could be
 445           // converted into avoid_back_to_back branch during next
 446           // rounds.
 447           if (needs_padding &amp;&amp; replacement-&gt;avoid_back_to_back(MachNode::AVOID_BEFORE)) {
 448             jmp_offset[i] += nop_size;
 449             diff -= nop_size;
 450           }
 451           adjust_block_start += diff;
 452           block-&gt;map_node(replacement, idx);
 453           mach-&gt;subsume_by(replacement, C);
 454           mach = replacement;
 455           progress = true;
 456 
 457           jmp_size[i] = new_size;
 458           DEBUG_ONLY( jmp_target[i] = bnum; );
 459           DEBUG_ONLY( jmp_rule[i] = mach-&gt;rule(); );
 460         } else {
 461           // The jump distance is not short, try again during next iteration.
 462           has_short_branch_candidate = true;
 463         }
 464       } // (mach-&gt;may_be_short_branch())
 465       if (mach != NULL &amp;&amp; (mach-&gt;may_be_short_branch() ||
 466                            mach-&gt;avoid_back_to_back(MachNode::AVOID_AFTER))) {
 467         last_may_be_short_branch_adr = blk_starts[i] + jmp_offset[i] + jmp_size[i];
 468       }
 469       blk_starts[i+1] -= adjust_block_start;
 470     }
 471   }
 472 
 473 #ifdef ASSERT
 474   for (uint i = 0; i &lt; nblocks; i++) { // For all blocks
 475     if (jmp_target[i] != 0) {
 476       int br_size = jmp_size[i];
 477       int offset = blk_starts[jmp_target[i]]-(blk_starts[i] + jmp_offset[i]);
<a name="49" id="anc49"></a><span class="line-modified"> 478       if (!_matcher-&gt;is_short_branch_offset(jmp_rule[i], br_size, offset)) {</span>
 479         tty-&gt;print_cr(&quot;target (%d) - jmp_offset(%d) = offset (%d), jump_size(%d), jmp_block B%d, target_block B%d&quot;, blk_starts[jmp_target[i]], blk_starts[i] + jmp_offset[i], offset, br_size, i, jmp_target[i]);
 480       }
<a name="50" id="anc50"></a><span class="line-modified"> 481       assert(_matcher-&gt;is_short_branch_offset(jmp_rule[i], br_size, offset), &quot;Displacement too large for short jmp&quot;);</span>
 482     }
 483   }
 484 #endif
 485 
 486   // Step 3, compute the offsets of all blocks, will be done in fill_buffer()
 487   // after ScheduleAndBundle().
 488 
 489   // ------------------
 490   // Compute size for code buffer
 491   code_size = blk_starts[nblocks];
 492 
 493   // Relocation records
 494   reloc_size += 1;              // Relo entry for exception handler
 495 
 496   // Adjust reloc_size to number of record of relocation info
 497   // Min is 2 bytes, max is probably 6 or 8, with a tax up to 25% for
 498   // a relocation index.
 499   // The CodeBuffer will expand the locs array if this estimate is too low.
 500   reloc_size *= 10 / sizeof(relocInfo);
 501 
<a name="51" id="anc51"></a><span class="line-modified"> 502   buf_sizes._reloc = reloc_size;</span>
<span class="line-modified"> 503   buf_sizes._code  = code_size;</span>
<span class="line-modified"> 504   buf_sizes._stub  = stub_size;</span>
 505 }
 506 
 507 //------------------------------FillLocArray-----------------------------------
 508 // Create a bit of debug info and append it to the array.  The mapping is from
 509 // Java local or expression stack to constant, register or stack-slot.  For
 510 // doubles, insert 2 mappings and return 1 (to tell the caller that the next
 511 // entry has been taken care of and caller should skip it).
 512 static LocationValue *new_loc_value( PhaseRegAlloc *ra, OptoReg::Name regnum, Location::Type l_type ) {
 513   // This should never have accepted Bad before
 514   assert(OptoReg::is_valid(regnum), &quot;location must be valid&quot;);
 515   return (OptoReg::is_reg(regnum))
 516          ? new LocationValue(Location::new_reg_loc(l_type, OptoReg::as_VMReg(regnum)) )
 517          : new LocationValue(Location::new_stk_loc(l_type,  ra-&gt;reg2offset(regnum)));
 518 }
 519 
 520 
 521 ObjectValue*
<a name="52" id="anc52"></a><span class="line-modified"> 522 Compile::sv_for_node_id(GrowableArray&lt;ScopeValue*&gt; *objs, int id) {</span>
 523   for (int i = 0; i &lt; objs-&gt;length(); i++) {
 524     assert(objs-&gt;at(i)-&gt;is_object(), &quot;corrupt object cache&quot;);
 525     ObjectValue* sv = (ObjectValue*) objs-&gt;at(i);
 526     if (sv-&gt;id() == id) {
 527       return sv;
 528     }
 529   }
 530   // Otherwise..
 531   return NULL;
 532 }
 533 
<a name="53" id="anc53"></a><span class="line-modified"> 534 void Compile::set_sv_for_object_node(GrowableArray&lt;ScopeValue*&gt; *objs,</span>
 535                                      ObjectValue* sv ) {
 536   assert(sv_for_node_id(objs, sv-&gt;id()) == NULL, &quot;Precondition&quot;);
 537   objs-&gt;append(sv);
 538 }
 539 
 540 
<a name="54" id="anc54"></a><span class="line-modified"> 541 void Compile::FillLocArray( int idx, MachSafePointNode* sfpt, Node *local,</span>
 542                             GrowableArray&lt;ScopeValue*&gt; *array,
 543                             GrowableArray&lt;ScopeValue*&gt; *objs ) {
 544   assert( local, &quot;use _top instead of null&quot; );
 545   if (array-&gt;length() != idx) {
 546     assert(array-&gt;length() == idx + 1, &quot;Unexpected array count&quot;);
 547     // Old functionality:
 548     //   return
 549     // New functionality:
 550     //   Assert if the local is not top. In product mode let the new node
 551     //   override the old entry.
<a name="55" id="anc55"></a><span class="line-modified"> 552     assert(local == top(), &quot;LocArray collision&quot;);</span>
<span class="line-modified"> 553     if (local == top()) {</span>
 554       return;
 555     }
 556     array-&gt;pop();
 557   }
 558   const Type *t = local-&gt;bottom_type();
 559 
 560   // Is it a safepoint scalar object node?
 561   if (local-&gt;is_SafePointScalarObject()) {
 562     SafePointScalarObjectNode* spobj = local-&gt;as_SafePointScalarObject();
 563 
<a name="56" id="anc56"></a><span class="line-modified"> 564     ObjectValue* sv = Compile::sv_for_node_id(objs, spobj-&gt;_idx);</span>
 565     if (sv == NULL) {
 566       ciKlass* cik = t-&gt;is_oopptr()-&gt;klass();
 567       assert(cik-&gt;is_instance_klass() ||
 568              cik-&gt;is_array_klass(), &quot;Not supported allocation.&quot;);
 569       sv = new ObjectValue(spobj-&gt;_idx,
 570                            new ConstantOopWriteValue(cik-&gt;java_mirror()-&gt;constant_encoding()));
<a name="57" id="anc57"></a><span class="line-modified"> 571       Compile::set_sv_for_object_node(objs, sv);</span>
 572 
 573       uint first_ind = spobj-&gt;first_index(sfpt-&gt;jvms());
 574       for (uint i = 0; i &lt; spobj-&gt;n_fields(); i++) {
 575         Node* fld_node = sfpt-&gt;in(first_ind+i);
 576         (void)FillLocArray(sv-&gt;field_values()-&gt;length(), sfpt, fld_node, sv-&gt;field_values(), objs);
 577       }
 578     }
 579     array-&gt;append(sv);
 580     return;
 581   }
 582 
 583   // Grab the register number for the local
<a name="58" id="anc58"></a><span class="line-modified"> 584   OptoReg::Name regnum = _regalloc-&gt;get_reg_first(local);</span>
 585   if( OptoReg::is_valid(regnum) ) {// Got a register/stack?
 586     // Record the double as two float registers.
 587     // The register mask for such a value always specifies two adjacent
 588     // float registers, with the lower register number even.
 589     // Normally, the allocation of high and low words to these registers
 590     // is irrelevant, because nearly all operations on register pairs
 591     // (e.g., StoreD) treat them as a single unit.
 592     // Here, we assume in addition that the words in these two registers
 593     // stored &quot;naturally&quot; (by operations like StoreD and double stores
 594     // within the interpreter) such that the lower-numbered register
 595     // is written to the lower memory address.  This may seem like
 596     // a machine dependency, but it is not--it is a requirement on
 597     // the author of the &lt;arch&gt;.ad file to ensure that, for every
 598     // even/odd double-register pair to which a double may be allocated,
 599     // the word in the even single-register is stored to the first
 600     // memory word.  (Note that register numbers are completely
 601     // arbitrary, and are not tied to any machine-level encodings.)
 602 #ifdef _LP64
 603     if( t-&gt;base() == Type::DoubleBot || t-&gt;base() == Type::DoubleCon ) {
 604       array-&gt;append(new ConstantIntValue((jint)0));
<a name="59" id="anc59"></a><span class="line-modified"> 605       array-&gt;append(new_loc_value( _regalloc, regnum, Location::dbl ));</span>
 606     } else if ( t-&gt;base() == Type::Long ) {
 607       array-&gt;append(new ConstantIntValue((jint)0));
<a name="60" id="anc60"></a><span class="line-modified"> 608       array-&gt;append(new_loc_value( _regalloc, regnum, Location::lng ));</span>
 609     } else if ( t-&gt;base() == Type::RawPtr ) {
 610       // jsr/ret return address which must be restored into a the full
 611       // width 64-bit stack slot.
<a name="61" id="anc61"></a><span class="line-modified"> 612       array-&gt;append(new_loc_value( _regalloc, regnum, Location::lng ));</span>
 613     }
 614 #else //_LP64
 615 #ifdef SPARC
 616     if (t-&gt;base() == Type::Long &amp;&amp; OptoReg::is_reg(regnum)) {
 617       // For SPARC we have to swap high and low words for
 618       // long values stored in a single-register (g0-g7).
<a name="62" id="anc62"></a><span class="line-modified"> 619       array-&gt;append(new_loc_value( _regalloc,              regnum   , Location::normal ));</span>
<span class="line-modified"> 620       array-&gt;append(new_loc_value( _regalloc, OptoReg::add(regnum,1), Location::normal ));</span>
 621     } else
 622 #endif //SPARC
 623     if( t-&gt;base() == Type::DoubleBot || t-&gt;base() == Type::DoubleCon || t-&gt;base() == Type::Long ) {
 624       // Repack the double/long as two jints.
 625       // The convention the interpreter uses is that the second local
 626       // holds the first raw word of the native double representation.
 627       // This is actually reasonable, since locals and stack arrays
 628       // grow downwards in all implementations.
 629       // (If, on some machine, the interpreter&#39;s Java locals or stack
 630       // were to grow upwards, the embedded doubles would be word-swapped.)
<a name="63" id="anc63"></a><span class="line-modified"> 631       array-&gt;append(new_loc_value( _regalloc, OptoReg::add(regnum,1), Location::normal ));</span>
<span class="line-modified"> 632       array-&gt;append(new_loc_value( _regalloc,              regnum   , Location::normal ));</span>
 633     }
 634 #endif //_LP64
 635     else if( (t-&gt;base() == Type::FloatBot || t-&gt;base() == Type::FloatCon) &amp;&amp;
 636              OptoReg::is_reg(regnum) ) {
<a name="64" id="anc64"></a><span class="line-modified"> 637       array-&gt;append(new_loc_value( _regalloc, regnum, Matcher::float_in_double()</span>
 638                                                       ? Location::float_in_dbl : Location::normal ));
 639     } else if( t-&gt;base() == Type::Int &amp;&amp; OptoReg::is_reg(regnum) ) {
<a name="65" id="anc65"></a><span class="line-modified"> 640       array-&gt;append(new_loc_value( _regalloc, regnum, Matcher::int_in_long</span>
 641                                                       ? Location::int_in_long : Location::normal ));
 642     } else if( t-&gt;base() == Type::NarrowOop ) {
<a name="66" id="anc66"></a><span class="line-modified"> 643       array-&gt;append(new_loc_value( _regalloc, regnum, Location::narrowoop ));</span>
 644     } else {
<a name="67" id="anc67"></a><span class="line-modified"> 645       array-&gt;append(new_loc_value( _regalloc, regnum, _regalloc-&gt;is_oop(local) ? Location::oop : Location::normal ));</span>
 646     }
 647     return;
 648   }
 649 
 650   // No register.  It must be constant data.
 651   switch (t-&gt;base()) {
 652     case Type::Half:              // Second half of a double
 653       ShouldNotReachHere();       // Caller should skip 2nd halves
 654       break;
 655     case Type::AnyPtr:
 656       array-&gt;append(new ConstantOopWriteValue(NULL));
 657       break;
 658     case Type::AryPtr:
 659     case Type::InstPtr:          // fall through
 660       array-&gt;append(new ConstantOopWriteValue(t-&gt;isa_oopptr()-&gt;const_oop()-&gt;constant_encoding()));
 661       break;
 662     case Type::NarrowOop:
 663       if (t == TypeNarrowOop::NULL_PTR) {
 664         array-&gt;append(new ConstantOopWriteValue(NULL));
 665       } else {
 666         array-&gt;append(new ConstantOopWriteValue(t-&gt;make_ptr()-&gt;isa_oopptr()-&gt;const_oop()-&gt;constant_encoding()));
 667       }
 668       break;
 669     case Type::Int:
 670       array-&gt;append(new ConstantIntValue(t-&gt;is_int()-&gt;get_con()));
 671       break;
 672     case Type::RawPtr:
 673       // A return address (T_ADDRESS).
 674       assert((intptr_t)t-&gt;is_ptr()-&gt;get_con() &lt; (intptr_t)0x10000, &quot;must be a valid BCI&quot;);
 675 #ifdef _LP64
 676       // Must be restored to the full-width 64-bit stack slot.
 677       array-&gt;append(new ConstantLongValue(t-&gt;is_ptr()-&gt;get_con()));
 678 #else
 679       array-&gt;append(new ConstantIntValue(t-&gt;is_ptr()-&gt;get_con()));
 680 #endif
 681       break;
 682     case Type::FloatCon: {
 683       float f = t-&gt;is_float_constant()-&gt;getf();
 684       array-&gt;append(new ConstantIntValue(jint_cast(f)));
 685       break;
 686     }
 687     case Type::DoubleCon: {
 688       jdouble d = t-&gt;is_double_constant()-&gt;getd();
 689 #ifdef _LP64
 690       array-&gt;append(new ConstantIntValue((jint)0));
 691       array-&gt;append(new ConstantDoubleValue(d));
 692 #else
 693       // Repack the double as two jints.
 694     // The convention the interpreter uses is that the second local
 695     // holds the first raw word of the native double representation.
 696     // This is actually reasonable, since locals and stack arrays
 697     // grow downwards in all implementations.
 698     // (If, on some machine, the interpreter&#39;s Java locals or stack
 699     // were to grow upwards, the embedded doubles would be word-swapped.)
 700     jlong_accessor acc;
 701     acc.long_value = jlong_cast(d);
 702     array-&gt;append(new ConstantIntValue(acc.words[1]));
 703     array-&gt;append(new ConstantIntValue(acc.words[0]));
 704 #endif
 705       break;
 706     }
 707     case Type::Long: {
 708       jlong d = t-&gt;is_long()-&gt;get_con();
 709 #ifdef _LP64
 710       array-&gt;append(new ConstantIntValue((jint)0));
 711       array-&gt;append(new ConstantLongValue(d));
 712 #else
 713       // Repack the long as two jints.
 714     // The convention the interpreter uses is that the second local
 715     // holds the first raw word of the native double representation.
 716     // This is actually reasonable, since locals and stack arrays
 717     // grow downwards in all implementations.
 718     // (If, on some machine, the interpreter&#39;s Java locals or stack
 719     // were to grow upwards, the embedded doubles would be word-swapped.)
 720     jlong_accessor acc;
 721     acc.long_value = d;
 722     array-&gt;append(new ConstantIntValue(acc.words[1]));
 723     array-&gt;append(new ConstantIntValue(acc.words[0]));
 724 #endif
 725       break;
 726     }
 727     case Type::Top:               // Add an illegal value here
 728       array-&gt;append(new LocationValue(Location()));
 729       break;
 730     default:
 731       ShouldNotReachHere();
 732       break;
 733   }
 734 }
 735 
 736 // Determine if this node starts a bundle
<a name="68" id="anc68"></a><span class="line-modified"> 737 bool Compile::starts_bundle(const Node *n) const {</span>
 738   return (_node_bundling_limit &gt; n-&gt;_idx &amp;&amp;
 739           _node_bundling_base[n-&gt;_idx].starts_bundle());
 740 }
 741 
 742 //--------------------------Process_OopMap_Node--------------------------------
<a name="69" id="anc69"></a><span class="line-modified"> 743 void Compile::Process_OopMap_Node(MachNode *mach, int current_offset) {</span>
<span class="line-removed"> 744 </span>
 745   // Handle special safepoint nodes for synchronization
 746   MachSafePointNode *sfn   = mach-&gt;as_MachSafePoint();
 747   MachCallNode      *mcall;
 748 
 749   int safepoint_pc_offset = current_offset;
 750   bool is_method_handle_invoke = false;
 751   bool return_oop = false;
 752 
 753   // Add the safepoint in the DebugInfoRecorder
 754   if( !mach-&gt;is_MachCall() ) {
 755     mcall = NULL;
<a name="70" id="anc70"></a><span class="line-modified"> 756     debug_info()-&gt;add_safepoint(safepoint_pc_offset, sfn-&gt;_oop_map);</span>
 757   } else {
 758     mcall = mach-&gt;as_MachCall();
 759 
 760     // Is the call a MethodHandle call?
 761     if (mcall-&gt;is_MachCallJava()) {
 762       if (mcall-&gt;as_MachCallJava()-&gt;_method_handle_invoke) {
<a name="71" id="anc71"></a><span class="line-modified"> 763         assert(has_method_handle_invokes(), &quot;must have been set during call generation&quot;);</span>
 764         is_method_handle_invoke = true;
 765       }
 766     }
 767 
 768     // Check if a call returns an object.
 769     if (mcall-&gt;returns_pointer()) {
 770       return_oop = true;
 771     }
 772     safepoint_pc_offset += mcall-&gt;ret_addr_offset();
<a name="72" id="anc72"></a><span class="line-modified"> 773     debug_info()-&gt;add_safepoint(safepoint_pc_offset, mcall-&gt;_oop_map);</span>
 774   }
 775 
 776   // Loop over the JVMState list to add scope information
 777   // Do not skip safepoints with a NULL method, they need monitor info
 778   JVMState* youngest_jvms = sfn-&gt;jvms();
 779   int max_depth = youngest_jvms-&gt;depth();
 780 
 781   // Allocate the object pool for scalar-replaced objects -- the map from
 782   // small-integer keys (which can be recorded in the local and ostack
 783   // arrays) to descriptions of the object state.
 784   GrowableArray&lt;ScopeValue*&gt; *objs = new GrowableArray&lt;ScopeValue*&gt;();
 785 
 786   // Visit scopes from oldest to youngest.
 787   for (int depth = 1; depth &lt;= max_depth; depth++) {
 788     JVMState* jvms = youngest_jvms-&gt;of_depth(depth);
 789     int idx;
 790     ciMethod* method = jvms-&gt;has_method() ? jvms-&gt;method() : NULL;
 791     // Safepoints that do not have method() set only provide oop-map and monitor info
 792     // to support GC; these do not support deoptimization.
 793     int num_locs = (method == NULL) ? 0 : jvms-&gt;loc_size();
 794     int num_exps = (method == NULL) ? 0 : jvms-&gt;stk_size();
 795     int num_mon  = jvms-&gt;nof_monitors();
 796     assert(method == NULL || jvms-&gt;bci() &lt; 0 || num_locs == method-&gt;max_locals(),
 797            &quot;JVMS local count must match that of the method&quot;);
 798 
 799     // Add Local and Expression Stack Information
 800 
 801     // Insert locals into the locarray
 802     GrowableArray&lt;ScopeValue*&gt; *locarray = new GrowableArray&lt;ScopeValue*&gt;(num_locs);
 803     for( idx = 0; idx &lt; num_locs; idx++ ) {
 804       FillLocArray( idx, sfn, sfn-&gt;local(jvms, idx), locarray, objs );
 805     }
 806 
 807     // Insert expression stack entries into the exparray
 808     GrowableArray&lt;ScopeValue*&gt; *exparray = new GrowableArray&lt;ScopeValue*&gt;(num_exps);
 809     for( idx = 0; idx &lt; num_exps; idx++ ) {
 810       FillLocArray( idx,  sfn, sfn-&gt;stack(jvms, idx), exparray, objs );
 811     }
 812 
 813     // Add in mappings of the monitors
 814     assert( !method ||
 815             !method-&gt;is_synchronized() ||
 816             method-&gt;is_native() ||
 817             num_mon &gt; 0 ||
 818             !GenerateSynchronizationCode,
 819             &quot;monitors must always exist for synchronized methods&quot;);
 820 
 821     // Build the growable array of ScopeValues for exp stack
 822     GrowableArray&lt;MonitorValue*&gt; *monarray = new GrowableArray&lt;MonitorValue*&gt;(num_mon);
 823 
 824     // Loop over monitors and insert into array
 825     for (idx = 0; idx &lt; num_mon; idx++) {
 826       // Grab the node that defines this monitor
 827       Node* box_node = sfn-&gt;monitor_box(jvms, idx);
 828       Node* obj_node = sfn-&gt;monitor_obj(jvms, idx);
 829 
 830       // Create ScopeValue for object
 831       ScopeValue *scval = NULL;
 832 
 833       if (obj_node-&gt;is_SafePointScalarObject()) {
 834         SafePointScalarObjectNode* spobj = obj_node-&gt;as_SafePointScalarObject();
<a name="73" id="anc73"></a><span class="line-modified"> 835         scval = Compile::sv_for_node_id(objs, spobj-&gt;_idx);</span>
 836         if (scval == NULL) {
 837           const Type *t = spobj-&gt;bottom_type();
 838           ciKlass* cik = t-&gt;is_oopptr()-&gt;klass();
 839           assert(cik-&gt;is_instance_klass() ||
 840                  cik-&gt;is_array_klass(), &quot;Not supported allocation.&quot;);
 841           ObjectValue* sv = new ObjectValue(spobj-&gt;_idx,
 842                                             new ConstantOopWriteValue(cik-&gt;java_mirror()-&gt;constant_encoding()));
<a name="74" id="anc74"></a><span class="line-modified"> 843           Compile::set_sv_for_object_node(objs, sv);</span>
 844 
 845           uint first_ind = spobj-&gt;first_index(youngest_jvms);
 846           for (uint i = 0; i &lt; spobj-&gt;n_fields(); i++) {
 847             Node* fld_node = sfn-&gt;in(first_ind+i);
 848             (void)FillLocArray(sv-&gt;field_values()-&gt;length(), sfn, fld_node, sv-&gt;field_values(), objs);
 849           }
 850           scval = sv;
 851         }
 852       } else if (!obj_node-&gt;is_Con()) {
<a name="75" id="anc75"></a><span class="line-modified"> 853         OptoReg::Name obj_reg = _regalloc-&gt;get_reg_first(obj_node);</span>
 854         if( obj_node-&gt;bottom_type()-&gt;base() == Type::NarrowOop ) {
<a name="76" id="anc76"></a><span class="line-modified"> 855           scval = new_loc_value( _regalloc, obj_reg, Location::narrowoop );</span>
 856         } else {
<a name="77" id="anc77"></a><span class="line-modified"> 857           scval = new_loc_value( _regalloc, obj_reg, Location::oop );</span>
 858         }
 859       } else {
 860         const TypePtr *tp = obj_node-&gt;get_ptr_type();
 861         scval = new ConstantOopWriteValue(tp-&gt;is_oopptr()-&gt;const_oop()-&gt;constant_encoding());
 862       }
 863 
 864       OptoReg::Name box_reg = BoxLockNode::reg(box_node);
<a name="78" id="anc78"></a><span class="line-modified"> 865       Location basic_lock = Location::new_stk_loc(Location::normal,_regalloc-&gt;reg2offset(box_reg));</span>
 866       bool eliminated = (box_node-&gt;is_BoxLock() &amp;&amp; box_node-&gt;as_BoxLock()-&gt;is_eliminated());
 867       monarray-&gt;append(new MonitorValue(scval, basic_lock, eliminated));
 868     }
 869 
 870     // We dump the object pool first, since deoptimization reads it in first.
<a name="79" id="anc79"></a><span class="line-modified"> 871     debug_info()-&gt;dump_object_pool(objs);</span>
 872 
 873     // Build first class objects to pass to scope
<a name="80" id="anc80"></a><span class="line-modified"> 874     DebugToken *locvals = debug_info()-&gt;create_scope_values(locarray);</span>
<span class="line-modified"> 875     DebugToken *expvals = debug_info()-&gt;create_scope_values(exparray);</span>
<span class="line-modified"> 876     DebugToken *monvals = debug_info()-&gt;create_monitor_values(monarray);</span>
 877 
 878     // Make method available for all Safepoints
<a name="81" id="anc81"></a><span class="line-modified"> 879     ciMethod* scope_method = method ? method : _method;</span>
 880     // Describe the scope here
 881     assert(jvms-&gt;bci() &gt;= InvocationEntryBci &amp;&amp; jvms-&gt;bci() &lt;= 0x10000, &quot;must be a valid or entry BCI&quot;);
 882     assert(!jvms-&gt;should_reexecute() || depth == max_depth, &quot;reexecute allowed only for the youngest&quot;);
 883     // Now we can describe the scope.
 884     methodHandle null_mh;
 885     bool rethrow_exception = false;
<a name="82" id="anc82"></a><span class="line-modified"> 886     debug_info()-&gt;describe_scope(safepoint_pc_offset, null_mh, scope_method, jvms-&gt;bci(), jvms-&gt;should_reexecute(), rethrow_exception, is_method_handle_invoke, return_oop, locvals, expvals, monvals);</span>
 887   } // End jvms loop
 888 
 889   // Mark the end of the scope set.
<a name="83" id="anc83"></a><span class="line-modified"> 890   debug_info()-&gt;end_safepoint(safepoint_pc_offset);</span>
 891 }
 892 
 893 
 894 
 895 // A simplified version of Process_OopMap_Node, to handle non-safepoints.
 896 class NonSafepointEmitter {
 897     Compile*  C;
 898     JVMState* _pending_jvms;
 899     int       _pending_offset;
 900 
 901     void emit_non_safepoint();
 902 
 903  public:
 904     NonSafepointEmitter(Compile* compile) {
 905       this-&gt;C = compile;
 906       _pending_jvms = NULL;
 907       _pending_offset = 0;
 908     }
 909 
 910     void observe_instruction(Node* n, int pc_offset) {
 911       if (!C-&gt;debug_info()-&gt;recording_non_safepoints())  return;
 912 
 913       Node_Notes* nn = C-&gt;node_notes_at(n-&gt;_idx);
 914       if (nn == NULL || nn-&gt;jvms() == NULL)  return;
 915       if (_pending_jvms != NULL &amp;&amp;
 916           _pending_jvms-&gt;same_calls_as(nn-&gt;jvms())) {
 917         // Repeated JVMS?  Stretch it up here.
 918         _pending_offset = pc_offset;
 919       } else {
 920         if (_pending_jvms != NULL &amp;&amp;
 921             _pending_offset &lt; pc_offset) {
 922           emit_non_safepoint();
 923         }
 924         _pending_jvms = NULL;
 925         if (pc_offset &gt; C-&gt;debug_info()-&gt;last_pc_offset()) {
 926           // This is the only way _pending_jvms can become non-NULL:
 927           _pending_jvms = nn-&gt;jvms();
 928           _pending_offset = pc_offset;
 929         }
 930       }
 931     }
 932 
 933     // Stay out of the way of real safepoints:
 934     void observe_safepoint(JVMState* jvms, int pc_offset) {
 935       if (_pending_jvms != NULL &amp;&amp;
 936           !_pending_jvms-&gt;same_calls_as(jvms) &amp;&amp;
 937           _pending_offset &lt; pc_offset) {
 938         emit_non_safepoint();
 939       }
 940       _pending_jvms = NULL;
 941     }
 942 
 943     void flush_at_end() {
 944       if (_pending_jvms != NULL) {
 945         emit_non_safepoint();
 946       }
 947       _pending_jvms = NULL;
 948     }
 949 };
 950 
 951 void NonSafepointEmitter::emit_non_safepoint() {
 952   JVMState* youngest_jvms = _pending_jvms;
 953   int       pc_offset     = _pending_offset;
 954 
 955   // Clear it now:
 956   _pending_jvms = NULL;
 957 
 958   DebugInformationRecorder* debug_info = C-&gt;debug_info();
 959   assert(debug_info-&gt;recording_non_safepoints(), &quot;sanity&quot;);
 960 
 961   debug_info-&gt;add_non_safepoint(pc_offset);
 962   int max_depth = youngest_jvms-&gt;depth();
 963 
 964   // Visit scopes from oldest to youngest.
 965   for (int depth = 1; depth &lt;= max_depth; depth++) {
 966     JVMState* jvms = youngest_jvms-&gt;of_depth(depth);
 967     ciMethod* method = jvms-&gt;has_method() ? jvms-&gt;method() : NULL;
 968     assert(!jvms-&gt;should_reexecute() || depth==max_depth, &quot;reexecute allowed only for the youngest&quot;);
 969     methodHandle null_mh;
 970     debug_info-&gt;describe_scope(pc_offset, null_mh, method, jvms-&gt;bci(), jvms-&gt;should_reexecute());
 971   }
 972 
 973   // Mark the end of the scope set.
 974   debug_info-&gt;end_non_safepoint(pc_offset);
 975 }
 976 
 977 //------------------------------init_buffer------------------------------------
<a name="84" id="anc84"></a><span class="line-modified"> 978 void Compile::estimate_buffer_size(int&amp; const_req) {</span>
 979 
 980   // Set the initially allocated size
 981   const_req = initial_const_capacity;
 982 
 983   // The extra spacing after the code is necessary on some platforms.
 984   // Sometimes we need to patch in a jump after the last instruction,
 985   // if the nmethod has been deoptimized.  (See 4932387, 4894843.)
 986 
 987   // Compute the byte offset where we can store the deopt pc.
<a name="85" id="anc85"></a><span class="line-modified"> 988   if (fixed_slots() != 0) {</span>
<span class="line-modified"> 989     _orig_pc_slot_offset_in_bytes = _regalloc-&gt;reg2offset(OptoReg::stack2reg(_orig_pc_slot));</span>
 990   }
 991 
 992   // Compute prolog code size
 993   _method_size = 0;
<a name="86" id="anc86"></a><span class="line-modified"> 994   _frame_slots = OptoReg::reg2stack(_matcher-&gt;_old_SP) + _regalloc-&gt;_framesize;</span>
 995 #if defined(IA64) &amp;&amp; !defined(AIX)
 996   if (save_argument_registers()) {
 997     // 4815101: this is a stub with implicit and unknown precision fp args.
 998     // The usual spill mechanism can only generate stfd&#39;s in this case, which
 999     // doesn&#39;t work if the fp reg to spill contains a single-precision denorm.
1000     // Instead, we hack around the normal spill mechanism using stfspill&#39;s and
1001     // ldffill&#39;s in the MachProlog and MachEpilog emit methods.  We allocate
1002     // space here for the fp arg regs (f8-f15) we&#39;re going to thusly spill.
1003     //
1004     // If we ever implement 16-byte &#39;registers&#39; == stack slots, we can
1005     // get rid of this hack and have SpillCopy generate stfspill/ldffill
1006     // instead of stfd/stfs/ldfd/ldfs.
1007     _frame_slots += 8*(16/BytesPerInt);
1008   }
1009 #endif
1010   assert(_frame_slots &gt;= 0 &amp;&amp; _frame_slots &lt; 1000000, &quot;sanity check&quot;);
1011 
<a name="87" id="anc87"></a><span class="line-modified">1012   if (has_mach_constant_base_node()) {</span>
1013     uint add_size = 0;
1014     // Fill the constant table.
1015     // Note:  This must happen before shorten_branches.
<a name="88" id="anc88"></a><span class="line-modified">1016     for (uint i = 0; i &lt; _cfg-&gt;number_of_blocks(); i++) {</span>
<span class="line-modified">1017       Block* b = _cfg-&gt;get_block(i);</span>
1018 
1019       for (uint j = 0; j &lt; b-&gt;number_of_nodes(); j++) {
1020         Node* n = b-&gt;get_node(j);
1021 
1022         // If the node is a MachConstantNode evaluate the constant
1023         // value section.
1024         if (n-&gt;is_MachConstant()) {
1025           MachConstantNode* machcon = n-&gt;as_MachConstant();
1026           machcon-&gt;eval_constant(C);
1027         } else if (n-&gt;is_Mach()) {
1028           // On Power there are more nodes that issue constants.
1029           add_size += (n-&gt;as_Mach()-&gt;ins_num_consts() * 8);
1030         }
1031       }
1032     }
1033 
1034     // Calculate the offsets of the constants and the size of the
1035     // constant table (including the padding to the next section).
1036     constant_table().calculate_offsets_and_size();
1037     const_req = constant_table().size() + add_size;
1038   }
1039 
1040   // Initialize the space for the BufferBlob used to find and verify
1041   // instruction size in MachNode::emit_size()
1042   init_scratch_buffer_blob(const_req);
1043 }
1044 
<a name="89" id="anc89"></a><span class="line-modified">1045 CodeBuffer* Compile::init_buffer(BufferSizingData&amp; buf_sizes) {</span>
<span class="line-modified">1046 </span>
<span class="line-modified">1047   int stub_req  = buf_sizes._stub;</span>
<span class="line-modified">1048   int code_req  = buf_sizes._code;</span>
<span class="line-removed">1049   int const_req = buf_sizes._const;</span>
1050 
1051   int pad_req   = NativeCall::instruction_size;
1052 
1053   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
1054   stub_req += bs-&gt;estimate_stub_size();
1055 
1056   // nmethod and CodeBuffer count stubs &amp; constants as part of method&#39;s code.
1057   // class HandlerImpl is platform-specific and defined in the *.ad files.
1058   int exception_handler_req = HandlerImpl::size_exception_handler() + MAX_stubs_size; // add marginal slop for handler
1059   int deopt_handler_req     = HandlerImpl::size_deopt_handler()     + MAX_stubs_size; // add marginal slop for handler
1060   stub_req += MAX_stubs_size;   // ensure per-stub margin
1061   code_req += MAX_inst_size;    // ensure per-instruction margin
1062 
1063   if (StressCodeBuffers)
1064     code_req = const_req = stub_req = exception_handler_req = deopt_handler_req = 0x10;  // force expansion
1065 
1066   int total_req =
1067           const_req +
1068           code_req +
1069           pad_req +
1070           stub_req +
1071           exception_handler_req +
1072           deopt_handler_req;               // deopt handler
1073 
<a name="90" id="anc90"></a><span class="line-modified">1074   if (has_method_handle_invokes())</span>
1075     total_req += deopt_handler_req;  // deopt MH handler
1076 
1077   CodeBuffer* cb = code_buffer();
<a name="91" id="anc91"></a><span class="line-modified">1078   cb-&gt;initialize(total_req, buf_sizes._reloc);</span>
1079 
1080   // Have we run out of code space?
1081   if ((cb-&gt;blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {
1082     C-&gt;record_failure(&quot;CodeCache is full&quot;);
1083     return NULL;
1084   }
1085   // Configure the code buffer.
1086   cb-&gt;initialize_consts_size(const_req);
1087   cb-&gt;initialize_stubs_size(stub_req);
<a name="92" id="anc92"></a><span class="line-modified">1088   cb-&gt;initialize_oop_recorder(env()-&gt;oop_recorder());</span>
1089 
1090   // fill in the nop array for bundling computations
1091   MachNode *_nop_list[Bundle::_nop_count];
1092   Bundle::initialize_nops(_nop_list);
1093 
1094   return cb;
1095 }
1096 
1097 //------------------------------fill_buffer------------------------------------
<a name="93" id="anc93"></a><span class="line-modified">1098 void Compile::fill_buffer(CodeBuffer* cb, uint* blk_starts) {</span>
1099   // blk_starts[] contains offsets calculated during short branches processing,
1100   // offsets should not be increased during following steps.
1101 
1102   // Compute the size of first NumberOfLoopInstrToAlign instructions at head
1103   // of a loop. It is used to determine the padding for loop alignment.
1104   compute_loop_first_inst_sizes();
1105 
1106   // Create oopmap set.
1107   _oop_map_set = new OopMapSet();
1108 
1109   // !!!!! This preserves old handling of oopmaps for now
<a name="94" id="anc94"></a><span class="line-modified">1110   debug_info()-&gt;set_oopmaps(_oop_map_set);</span>
1111 
<a name="95" id="anc95"></a><span class="line-modified">1112   uint nblocks  = _cfg-&gt;number_of_blocks();</span>
1113   // Count and start of implicit null check instructions
1114   uint inct_cnt = 0;
1115   uint *inct_starts = NEW_RESOURCE_ARRAY(uint, nblocks+1);
1116 
1117   // Count and start of calls
1118   uint *call_returns = NEW_RESOURCE_ARRAY(uint, nblocks+1);
1119 
1120   uint  return_offset = 0;
<a name="96" id="anc96"></a><span class="line-modified">1121   int nop_size = (new MachNopNode())-&gt;size(_regalloc);</span>
1122 
1123   int previous_offset = 0;
1124   int current_offset  = 0;
1125   int last_call_offset = -1;
1126   int last_avoid_back_to_back_offset = -1;
1127 #ifdef ASSERT
1128   uint* jmp_target = NEW_RESOURCE_ARRAY(uint,nblocks);
1129   uint* jmp_offset = NEW_RESOURCE_ARRAY(uint,nblocks);
1130   uint* jmp_size   = NEW_RESOURCE_ARRAY(uint,nblocks);
1131   uint* jmp_rule   = NEW_RESOURCE_ARRAY(uint,nblocks);
1132 #endif
1133 
1134   // Create an array of unused labels, one for each basic block, if printing is enabled
1135 #if defined(SUPPORT_OPTO_ASSEMBLY)
1136   int *node_offsets      = NULL;
<a name="97" id="anc97"></a><span class="line-modified">1137   uint node_offset_limit = unique();</span>
1138 
<a name="98" id="anc98"></a><span class="line-modified">1139   if (print_assembly()) {</span>
1140     node_offsets = NEW_RESOURCE_ARRAY(int, node_offset_limit);
1141   }
1142   if (node_offsets != NULL) {
1143     // We need to initialize. Unused array elements may contain garbage and mess up PrintOptoAssembly.
1144     memset(node_offsets, 0, node_offset_limit*sizeof(int));
1145   }
1146 #endif
1147 
<a name="99" id="anc99"></a><span class="line-modified">1148   NonSafepointEmitter non_safepoints(this);  // emit non-safepoints lazily</span>
1149 
1150   // Emit the constant table.
<a name="100" id="anc100"></a><span class="line-modified">1151   if (has_mach_constant_base_node()) {</span>
1152     constant_table().emit(*cb);
1153   }
1154 
1155   // Create an array of labels, one for each basic block
1156   Label *blk_labels = NEW_RESOURCE_ARRAY(Label, nblocks+1);
1157   for (uint i=0; i &lt;= nblocks; i++) {
1158     blk_labels[i].init();
1159   }
1160 
1161   // ------------------
1162   // Now fill in the code buffer
1163   Node *delay_slot = NULL;
1164 
1165   for (uint i = 0; i &lt; nblocks; i++) {
<a name="101" id="anc101"></a><span class="line-modified">1166     Block* block = _cfg-&gt;get_block(i);</span>

1167     Node* head = block-&gt;head();
1168 
1169     // If this block needs to start aligned (i.e, can be reached other
1170     // than by falling-thru from the previous block), then force the
1171     // start of a new bundle.
1172     if (Pipeline::requires_bundling() &amp;&amp; starts_bundle(head)) {
1173       cb-&gt;flush_bundle(true);
1174     }
1175 
1176 #ifdef ASSERT
1177     if (!block-&gt;is_connector()) {
1178       stringStream st;
<a name="102" id="anc102"></a><span class="line-modified">1179       block-&gt;dump_head(_cfg, &amp;st);</span>
1180       MacroAssembler(cb).block_comment(st.as_string());
1181     }
1182     jmp_target[i] = 0;
1183     jmp_offset[i] = 0;
1184     jmp_size[i]   = 0;
1185     jmp_rule[i]   = 0;
1186 #endif
1187     int blk_offset = current_offset;
1188 
1189     // Define the label at the beginning of the basic block
1190     MacroAssembler(cb).bind(blk_labels[block-&gt;_pre_order]);
1191 
1192     uint last_inst = block-&gt;number_of_nodes();
1193 
1194     // Emit block normally, except for last instruction.
1195     // Emit means &quot;dump code bits into code buffer&quot;.
1196     for (uint j = 0; j&lt;last_inst; j++) {
<a name="103" id="anc103"></a>
1197 
1198       // Get the node
1199       Node* n = block-&gt;get_node(j);
1200 
1201       // See if delay slots are supported
<a name="104" id="anc104"></a><span class="line-modified">1202       if (valid_bundle_info(n) &amp;&amp;</span>
<span class="line-removed">1203           node_bundling(n)-&gt;used_in_unconditional_delay()) {</span>
1204         assert(delay_slot == NULL, &quot;no use of delay slot node&quot;);
<a name="105" id="anc105"></a><span class="line-modified">1205         assert(n-&gt;size(_regalloc) == Pipeline::instr_unit_size(), &quot;delay slot instruction wrong size&quot;);</span>
1206 
1207         delay_slot = n;
1208         continue;
1209       }
1210 
1211       // If this starts a new instruction group, then flush the current one
1212       // (but allow split bundles)
1213       if (Pipeline::requires_bundling() &amp;&amp; starts_bundle(n))
1214         cb-&gt;flush_bundle(false);
1215 
1216       // Special handling for SafePoint/Call Nodes
1217       bool is_mcall = false;
1218       if (n-&gt;is_Mach()) {
1219         MachNode *mach = n-&gt;as_Mach();
1220         is_mcall = n-&gt;is_MachCall();
1221         bool is_sfn = n-&gt;is_MachSafePoint();
1222 
1223         // If this requires all previous instructions be flushed, then do so
1224         if (is_sfn || is_mcall || mach-&gt;alignment_required() != 1) {
1225           cb-&gt;flush_bundle(true);
1226           current_offset = cb-&gt;insts_size();
1227         }
1228 
1229         // A padding may be needed again since a previous instruction
1230         // could be moved to delay slot.
1231 
1232         // align the instruction if necessary
1233         int padding = mach-&gt;compute_padding(current_offset);
1234         // Make sure safepoint node for polling is distinct from a call&#39;s
1235         // return by adding a nop if needed.
1236         if (is_sfn &amp;&amp; !is_mcall &amp;&amp; padding == 0 &amp;&amp; current_offset == last_call_offset) {
1237           padding = nop_size;
1238         }
1239         if (padding == 0 &amp;&amp; mach-&gt;avoid_back_to_back(MachNode::AVOID_BEFORE) &amp;&amp;
1240             current_offset == last_avoid_back_to_back_offset) {
1241           // Avoid back to back some instructions.
1242           padding = nop_size;
1243         }
<a name="106" id="anc106"></a><span class="line-removed">1244 #ifdef X86</span>
<span class="line-removed">1245         if (mach-&gt;flags() &amp; Node::Flag_intel_jcc_erratum) {</span>
<span class="line-removed">1246           assert(padding == 0, &quot;can&#39;t have contradicting padding requirements&quot;);</span>
<span class="line-removed">1247           padding = IntelJccErratum::compute_padding(current_offset, mach, block, j, _regalloc);</span>
<span class="line-removed">1248         }</span>
<span class="line-removed">1249 #endif</span>
1250 
1251         if (padding &gt; 0) {
1252           assert((padding % nop_size) == 0, &quot;padding is not a multiple of NOP size&quot;);
1253           int nops_cnt = padding / nop_size;
1254           MachNode *nop = new MachNopNode(nops_cnt);
1255           block-&gt;insert_node(nop, j++);
1256           last_inst++;
<a name="107" id="anc107"></a><span class="line-modified">1257           _cfg-&gt;map_node_to_block(nop, block);</span>
1258           // Ensure enough space.
1259           cb-&gt;insts()-&gt;maybe_expand_to_ensure_remaining(MAX_inst_size);
1260           if ((cb-&gt;blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {
1261             C-&gt;record_failure(&quot;CodeCache is full&quot;);
1262             return;
1263           }
<a name="108" id="anc108"></a><span class="line-modified">1264           nop-&gt;emit(*cb, _regalloc);</span>
1265           cb-&gt;flush_bundle(true);
1266           current_offset = cb-&gt;insts_size();
1267         }
1268 
1269         // Remember the start of the last call in a basic block
1270         if (is_mcall) {
1271           MachCallNode *mcall = mach-&gt;as_MachCall();
1272 
1273           // This destination address is NOT PC-relative
1274           mcall-&gt;method_set((intptr_t)mcall-&gt;entry_point());
1275 
1276           // Save the return address
1277           call_returns[block-&gt;_pre_order] = current_offset + mcall-&gt;ret_addr_offset();
1278 
1279           if (mcall-&gt;is_MachCallLeaf()) {
1280             is_mcall = false;
1281             is_sfn = false;
1282           }
1283         }
1284 
1285         // sfn will be valid whenever mcall is valid now because of inheritance
1286         if (is_sfn || is_mcall) {
1287 
1288           // Handle special safepoint nodes for synchronization
1289           if (!is_mcall) {
1290             MachSafePointNode *sfn = mach-&gt;as_MachSafePoint();
1291             // !!!!! Stubs only need an oopmap right now, so bail out
1292             if (sfn-&gt;jvms()-&gt;method() == NULL) {
1293               // Write the oopmap directly to the code blob??!!
1294               continue;
1295             }
1296           } // End synchronization
1297 
1298           non_safepoints.observe_safepoint(mach-&gt;as_MachSafePoint()-&gt;jvms(),
1299                                            current_offset);
1300           Process_OopMap_Node(mach, current_offset);
1301         } // End if safepoint
1302 
1303           // If this is a null check, then add the start of the previous instruction to the list
1304         else if( mach-&gt;is_MachNullCheck() ) {
1305           inct_starts[inct_cnt++] = previous_offset;
1306         }
1307 
1308           // If this is a branch, then fill in the label with the target BB&#39;s label
1309         else if (mach-&gt;is_MachBranch()) {
1310           // This requires the TRUE branch target be in succs[0]
1311           uint block_num = block-&gt;non_connector_successor(0)-&gt;_pre_order;
1312 
1313           // Try to replace long branch if delay slot is not used,
1314           // it is mostly for back branches since forward branch&#39;s
1315           // distance is not updated yet.
1316           bool delay_slot_is_used = valid_bundle_info(n) &amp;&amp;
<a name="109" id="anc109"></a><span class="line-modified">1317                                     node_bundling(n)-&gt;use_unconditional_delay();</span>
1318           if (!delay_slot_is_used &amp;&amp; mach-&gt;may_be_short_branch()) {
1319             assert(delay_slot == NULL, &quot;not expecting delay slot node&quot;);
<a name="110" id="anc110"></a><span class="line-modified">1320             int br_size = n-&gt;size(_regalloc);</span>
1321             int offset = blk_starts[block_num] - current_offset;
1322             if (block_num &gt;= i) {
1323               // Current and following block&#39;s offset are not
1324               // finalized yet, adjust distance by the difference
1325               // between calculated and final offsets of current block.
1326               offset -= (blk_starts[i] - blk_offset);
1327             }
1328             // In the following code a nop could be inserted before
1329             // the branch which will increase the backward distance.
1330             bool needs_padding = (current_offset == last_avoid_back_to_back_offset);
1331             if (needs_padding &amp;&amp; offset &lt;= 0)
1332               offset -= nop_size;
1333 
<a name="111" id="anc111"></a><span class="line-modified">1334             if (_matcher-&gt;is_short_branch_offset(mach-&gt;rule(), br_size, offset)) {</span>
1335               // We&#39;ve got a winner.  Replace this branch.
1336               MachNode* replacement = mach-&gt;as_MachBranch()-&gt;short_branch_version();
1337 
1338               // Update the jmp_size.
<a name="112" id="anc112"></a><span class="line-modified">1339               int new_size = replacement-&gt;size(_regalloc);</span>
1340               assert((br_size - new_size) &gt;= (int)nop_size, &quot;short_branch size should be smaller&quot;);
1341               // Insert padding between avoid_back_to_back branches.
1342               if (needs_padding &amp;&amp; replacement-&gt;avoid_back_to_back(MachNode::AVOID_BEFORE)) {
1343                 MachNode *nop = new MachNopNode();
1344                 block-&gt;insert_node(nop, j++);
<a name="113" id="anc113"></a><span class="line-modified">1345                 _cfg-&gt;map_node_to_block(nop, block);</span>
1346                 last_inst++;
<a name="114" id="anc114"></a><span class="line-modified">1347                 nop-&gt;emit(*cb, _regalloc);</span>
1348                 cb-&gt;flush_bundle(true);
1349                 current_offset = cb-&gt;insts_size();
1350               }
1351 #ifdef ASSERT
1352               jmp_target[i] = block_num;
1353               jmp_offset[i] = current_offset - blk_offset;
1354               jmp_size[i]   = new_size;
1355               jmp_rule[i]   = mach-&gt;rule();
1356 #endif
1357               block-&gt;map_node(replacement, j);
1358               mach-&gt;subsume_by(replacement, C);
1359               n    = replacement;
1360               mach = replacement;
1361             }
1362           }
1363           mach-&gt;as_MachBranch()-&gt;label_set( &amp;blk_labels[block_num], block_num );
1364         } else if (mach-&gt;ideal_Opcode() == Op_Jump) {
1365           for (uint h = 0; h &lt; block-&gt;_num_succs; h++) {
1366             Block* succs_block = block-&gt;_succs[h];
1367             for (uint j = 1; j &lt; succs_block-&gt;num_preds(); j++) {
1368               Node* jpn = succs_block-&gt;pred(j);
1369               if (jpn-&gt;is_JumpProj() &amp;&amp; jpn-&gt;in(0) == mach) {
1370                 uint block_num = succs_block-&gt;non_connector()-&gt;_pre_order;
1371                 Label *blkLabel = &amp;blk_labels[block_num];
1372                 mach-&gt;add_case_label(jpn-&gt;as_JumpProj()-&gt;proj_no(), blkLabel);
1373               }
1374             }
1375           }
1376         }
1377 #ifdef ASSERT
1378           // Check that oop-store precedes the card-mark
1379         else if (mach-&gt;ideal_Opcode() == Op_StoreCM) {
1380           uint storeCM_idx = j;
1381           int count = 0;
1382           for (uint prec = mach-&gt;req(); prec &lt; mach-&gt;len(); prec++) {
1383             Node *oop_store = mach-&gt;in(prec);  // Precedence edge
1384             if (oop_store == NULL) continue;
1385             count++;
1386             uint i4;
1387             for (i4 = 0; i4 &lt; last_inst; ++i4) {
1388               if (block-&gt;get_node(i4) == oop_store) {
1389                 break;
1390               }
1391             }
1392             // Note: This test can provide a false failure if other precedence
1393             // edges have been added to the storeCMNode.
1394             assert(i4 == last_inst || i4 &lt; storeCM_idx, &quot;CM card-mark executes before oop-store&quot;);
1395           }
1396           assert(count &gt; 0, &quot;storeCM expects at least one precedence edge&quot;);
1397         }
1398 #endif
1399         else if (!n-&gt;is_Proj()) {
1400           // Remember the beginning of the previous instruction, in case
1401           // it&#39;s followed by a flag-kill and a null-check.  Happens on
1402           // Intel all the time, with add-to-memory kind of opcodes.
1403           previous_offset = current_offset;
1404         }
1405 
1406         // Not an else-if!
1407         // If this is a trap based cmp then add its offset to the list.
1408         if (mach-&gt;is_TrapBasedCheckNode()) {
1409           inct_starts[inct_cnt++] = current_offset;
1410         }
1411       }
1412 
1413       // Verify that there is sufficient space remaining
1414       cb-&gt;insts()-&gt;maybe_expand_to_ensure_remaining(MAX_inst_size);
1415       if ((cb-&gt;blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {
1416         C-&gt;record_failure(&quot;CodeCache is full&quot;);
1417         return;
1418       }
1419 
1420       // Save the offset for the listing
1421 #if defined(SUPPORT_OPTO_ASSEMBLY)
1422       if ((node_offsets != NULL) &amp;&amp; (n-&gt;_idx &lt; node_offset_limit)) {
1423         node_offsets[n-&gt;_idx] = cb-&gt;insts_size();
1424       }
1425 #endif
1426 
1427       // &quot;Normal&quot; instruction case
1428       DEBUG_ONLY( uint instr_offset = cb-&gt;insts_size(); )
<a name="115" id="anc115"></a><span class="line-modified">1429       n-&gt;emit(*cb, _regalloc);</span>
1430       current_offset  = cb-&gt;insts_size();
1431 
1432       // Above we only verified that there is enough space in the instruction section.
1433       // However, the instruction may emit stubs that cause code buffer expansion.
1434       // Bail out here if expansion failed due to a lack of code cache space.
<a name="116" id="anc116"></a><span class="line-modified">1435       if (failing()) {</span>
1436         return;
1437       }
1438 
1439 #ifdef ASSERT
<a name="117" id="anc117"></a><span class="line-modified">1440       if (n-&gt;size(_regalloc) &lt; (current_offset-instr_offset)) {</span>
1441         n-&gt;dump();
1442         assert(false, &quot;wrong size of mach node&quot;);
1443       }
1444 #endif
1445       non_safepoints.observe_instruction(n, current_offset);
1446 
1447       // mcall is last &quot;call&quot; that can be a safepoint
1448       // record it so we can see if a poll will directly follow it
1449       // in which case we&#39;ll need a pad to make the PcDesc sites unique
1450       // see  5010568. This can be slightly inaccurate but conservative
1451       // in the case that return address is not actually at current_offset.
1452       // This is a small price to pay.
1453 
1454       if (is_mcall) {
1455         last_call_offset = current_offset;
1456       }
1457 
1458       if (n-&gt;is_Mach() &amp;&amp; n-&gt;as_Mach()-&gt;avoid_back_to_back(MachNode::AVOID_AFTER)) {
1459         // Avoid back to back some instructions.
1460         last_avoid_back_to_back_offset = current_offset;
1461       }
1462 
1463       // See if this instruction has a delay slot
1464       if (valid_bundle_info(n) &amp;&amp; node_bundling(n)-&gt;use_unconditional_delay()) {
1465         guarantee(delay_slot != NULL, &quot;expecting delay slot node&quot;);
1466 
1467         // Back up 1 instruction
1468         cb-&gt;set_insts_end(cb-&gt;insts_end() - Pipeline::instr_unit_size());
1469 
1470         // Save the offset for the listing
1471 #if defined(SUPPORT_OPTO_ASSEMBLY)
1472         if ((node_offsets != NULL) &amp;&amp; (delay_slot-&gt;_idx &lt; node_offset_limit)) {
1473           node_offsets[delay_slot-&gt;_idx] = cb-&gt;insts_size();
1474         }
1475 #endif
1476 
1477         // Support a SafePoint in the delay slot
1478         if (delay_slot-&gt;is_MachSafePoint()) {
1479           MachNode *mach = delay_slot-&gt;as_Mach();
1480           // !!!!! Stubs only need an oopmap right now, so bail out
1481           if (!mach-&gt;is_MachCall() &amp;&amp; mach-&gt;as_MachSafePoint()-&gt;jvms()-&gt;method() == NULL) {
1482             // Write the oopmap directly to the code blob??!!
1483             delay_slot = NULL;
1484             continue;
1485           }
1486 
1487           int adjusted_offset = current_offset - Pipeline::instr_unit_size();
1488           non_safepoints.observe_safepoint(mach-&gt;as_MachSafePoint()-&gt;jvms(),
1489                                            adjusted_offset);
1490           // Generate an OopMap entry
1491           Process_OopMap_Node(mach, adjusted_offset);
1492         }
1493 
1494         // Insert the delay slot instruction
<a name="118" id="anc118"></a><span class="line-modified">1495         delay_slot-&gt;emit(*cb, _regalloc);</span>
1496 
1497         // Don&#39;t reuse it
1498         delay_slot = NULL;
1499       }
1500 
1501     } // End for all instructions in block
1502 
1503     // If the next block is the top of a loop, pad this block out to align
1504     // the loop top a little. Helps prevent pipe stalls at loop back branches.
1505     if (i &lt; nblocks-1) {
<a name="119" id="anc119"></a><span class="line-modified">1506       Block *nb = _cfg-&gt;get_block(i + 1);</span>
1507       int padding = nb-&gt;alignment_padding(current_offset);
1508       if( padding &gt; 0 ) {
1509         MachNode *nop = new MachNopNode(padding / nop_size);
1510         block-&gt;insert_node(nop, block-&gt;number_of_nodes());
<a name="120" id="anc120"></a><span class="line-modified">1511         _cfg-&gt;map_node_to_block(nop, block);</span>
<span class="line-modified">1512         nop-&gt;emit(*cb, _regalloc);</span>
1513         current_offset = cb-&gt;insts_size();
1514       }
1515     }
1516     // Verify that the distance for generated before forward
1517     // short branches is still valid.
1518     guarantee((int)(blk_starts[i+1] - blk_starts[i]) &gt;= (current_offset - blk_offset), &quot;shouldn&#39;t increase block size&quot;);
1519 
1520     // Save new block start offset
1521     blk_starts[i] = blk_offset;
1522   } // End of for all blocks
1523   blk_starts[nblocks] = current_offset;
1524 
1525   non_safepoints.flush_at_end();
1526 
1527   // Offset too large?
<a name="121" id="anc121"></a><span class="line-modified">1528   if (failing())  return;</span>
1529 
1530   // Define a pseudo-label at the end of the code
1531   MacroAssembler(cb).bind( blk_labels[nblocks] );
1532 
1533   // Compute the size of the first block
1534   _first_block_size = blk_labels[1].loc_pos() - blk_labels[0].loc_pos();
1535 
1536 #ifdef ASSERT
1537   for (uint i = 0; i &lt; nblocks; i++) { // For all blocks
1538     if (jmp_target[i] != 0) {
1539       int br_size = jmp_size[i];
1540       int offset = blk_starts[jmp_target[i]]-(blk_starts[i] + jmp_offset[i]);
<a name="122" id="anc122"></a><span class="line-modified">1541       if (!_matcher-&gt;is_short_branch_offset(jmp_rule[i], br_size, offset)) {</span>
1542         tty-&gt;print_cr(&quot;target (%d) - jmp_offset(%d) = offset (%d), jump_size(%d), jmp_block B%d, target_block B%d&quot;, blk_starts[jmp_target[i]], blk_starts[i] + jmp_offset[i], offset, br_size, i, jmp_target[i]);
1543         assert(false, &quot;Displacement too large for short jmp&quot;);
1544       }
1545     }
1546   }
1547 #endif
1548 
1549   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
1550   bs-&gt;emit_stubs(*cb);
<a name="123" id="anc123"></a><span class="line-modified">1551   if (failing())  return;</span>
1552 
1553 #ifndef PRODUCT
1554   // Information on the size of the method, without the extraneous code
1555   Scheduling::increment_method_size(cb-&gt;insts_size());
1556 #endif
1557 
1558   // ------------------
1559   // Fill in exception table entries.
1560   FillExceptionTables(inct_cnt, call_returns, inct_starts, blk_labels);
1561 
1562   // Only java methods have exception handlers and deopt handlers
1563   // class HandlerImpl is platform-specific and defined in the *.ad files.
<a name="124" id="anc124"></a><span class="line-modified">1564   if (_method) {</span>
1565     // Emit the exception handler code.
1566     _code_offsets.set_value(CodeOffsets::Exceptions, HandlerImpl::emit_exception_handler(*cb));
<a name="125" id="anc125"></a><span class="line-modified">1567     if (failing()) {</span>
1568       return; // CodeBuffer::expand failed
1569     }
1570     // Emit the deopt handler code.
1571     _code_offsets.set_value(CodeOffsets::Deopt, HandlerImpl::emit_deopt_handler(*cb));
1572 
1573     // Emit the MethodHandle deopt handler code (if required).
<a name="126" id="anc126"></a><span class="line-modified">1574     if (has_method_handle_invokes() &amp;&amp; !failing()) {</span>
1575       // We can use the same code as for the normal deopt handler, we
1576       // just need a different entry point address.
1577       _code_offsets.set_value(CodeOffsets::DeoptMH, HandlerImpl::emit_deopt_handler(*cb));
1578     }
1579   }
1580 
1581   // One last check for failed CodeBuffer::expand:
1582   if ((cb-&gt;blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {
1583     C-&gt;record_failure(&quot;CodeCache is full&quot;);
1584     return;
1585   }
1586 
1587 #if defined(SUPPORT_ABSTRACT_ASSEMBLY) || defined(SUPPORT_ASSEMBLY) || defined(SUPPORT_OPTO_ASSEMBLY)
<a name="127" id="anc127"></a><span class="line-modified">1588   if (print_assembly()) {</span>
1589     tty-&gt;cr();
1590     tty-&gt;print_cr(&quot;============================= C2-compiled nmethod ==============================&quot;);
1591   }
1592 #endif
1593 
1594 #if defined(SUPPORT_OPTO_ASSEMBLY)
1595   // Dump the assembly code, including basic-block numbers
<a name="128" id="anc128"></a><span class="line-modified">1596   if (print_assembly()) {</span>
1597     ttyLocker ttyl;  // keep the following output all in one block
1598     if (!VMThread::should_terminate()) {  // test this under the tty lock
1599       // This output goes directly to the tty, not the compiler log.
1600       // To enable tools to match it up with the compilation activity,
1601       // be sure to tag this tty output with the compile ID.
1602       if (xtty != NULL) {
<a name="129" id="anc129"></a><span class="line-modified">1603         xtty-&gt;head(&quot;opto_assembly compile_id=&#39;%d&#39;%s&quot;, compile_id(),</span>
<span class="line-modified">1604                    is_osr_compilation()    ? &quot; compile_kind=&#39;osr&#39;&quot; :</span>
1605                    &quot;&quot;);
1606       }
<a name="130" id="anc130"></a><span class="line-modified">1607       if (method() != NULL) {</span>
<span class="line-modified">1608         tty-&gt;print_cr(&quot;----------------------- MetaData before Compile_id = %d ------------------------&quot;, compile_id());</span>
<span class="line-modified">1609         method()-&gt;print_metadata();</span>
<span class="line-modified">1610       } else if (stub_name() != NULL) {</span>
<span class="line-modified">1611         tty-&gt;print_cr(&quot;----------------------------- RuntimeStub %s -------------------------------&quot;, stub_name());</span>
1612       }
1613       tty-&gt;cr();
<a name="131" id="anc131"></a><span class="line-modified">1614       tty-&gt;print_cr(&quot;------------------------ OptoAssembly for Compile_id = %d -----------------------&quot;, compile_id());</span>
1615       dump_asm(node_offsets, node_offset_limit);
1616       tty-&gt;print_cr(&quot;--------------------------------------------------------------------------------&quot;);
1617       if (xtty != NULL) {
1618         // print_metadata and dump_asm above may safepoint which makes us loose the ttylock.
1619         // Retake lock too make sure the end tag is coherent, and that xmlStream-&gt;pop_tag is done
1620         // thread safe
1621         ttyLocker ttyl2;
1622         xtty-&gt;tail(&quot;opto_assembly&quot;);
1623       }
1624     }
1625   }
1626 #endif
1627 }
1628 
<a name="132" id="anc132"></a><span class="line-modified">1629 void Compile::FillExceptionTables(uint cnt, uint *call_returns, uint *inct_starts, Label *blk_labels) {</span>
1630   _inc_table.set_size(cnt);
1631 
1632   uint inct_cnt = 0;
<a name="133" id="anc133"></a><span class="line-modified">1633   for (uint i = 0; i &lt; _cfg-&gt;number_of_blocks(); i++) {</span>
<span class="line-modified">1634     Block* block = _cfg-&gt;get_block(i);</span>
1635     Node *n = NULL;
1636     int j;
1637 
1638     // Find the branch; ignore trailing NOPs.
1639     for (j = block-&gt;number_of_nodes() - 1; j &gt;= 0; j--) {
1640       n = block-&gt;get_node(j);
1641       if (!n-&gt;is_Mach() || n-&gt;as_Mach()-&gt;ideal_Opcode() != Op_Con) {
1642         break;
1643       }
1644     }
1645 
1646     // If we didn&#39;t find anything, continue
1647     if (j &lt; 0) {
1648       continue;
1649     }
1650 
1651     // Compute ExceptionHandlerTable subtable entry and add it
1652     // (skip empty blocks)
1653     if (n-&gt;is_Catch()) {
1654 
1655       // Get the offset of the return from the call
1656       uint call_return = call_returns[block-&gt;_pre_order];
1657 #ifdef ASSERT
1658       assert( call_return &gt; 0, &quot;no call seen for this basic block&quot; );
1659       while (block-&gt;get_node(--j)-&gt;is_MachProj()) ;
1660       assert(block-&gt;get_node(j)-&gt;is_MachCall(), &quot;CatchProj must follow call&quot;);
1661 #endif
1662       // last instruction is a CatchNode, find it&#39;s CatchProjNodes
1663       int nof_succs = block-&gt;_num_succs;
1664       // allocate space
1665       GrowableArray&lt;intptr_t&gt; handler_bcis(nof_succs);
1666       GrowableArray&lt;intptr_t&gt; handler_pcos(nof_succs);
1667       // iterate through all successors
1668       for (int j = 0; j &lt; nof_succs; j++) {
1669         Block* s = block-&gt;_succs[j];
1670         bool found_p = false;
1671         for (uint k = 1; k &lt; s-&gt;num_preds(); k++) {
1672           Node* pk = s-&gt;pred(k);
1673           if (pk-&gt;is_CatchProj() &amp;&amp; pk-&gt;in(0) == n) {
1674             const CatchProjNode* p = pk-&gt;as_CatchProj();
1675             found_p = true;
1676             // add the corresponding handler bci &amp; pco information
1677             if (p-&gt;_con != CatchProjNode::fall_through_index) {
1678               // p leads to an exception handler (and is not fall through)
<a name="134" id="anc134"></a><span class="line-modified">1679               assert(s == _cfg-&gt;get_block(s-&gt;_pre_order), &quot;bad numbering&quot;);</span>
1680               // no duplicates, please
1681               if (!handler_bcis.contains(p-&gt;handler_bci())) {
1682                 uint block_num = s-&gt;non_connector()-&gt;_pre_order;
1683                 handler_bcis.append(p-&gt;handler_bci());
1684                 handler_pcos.append(blk_labels[block_num].loc_pos());
1685               }
1686             }
1687           }
1688         }
1689         assert(found_p, &quot;no matching predecessor found&quot;);
1690         // Note:  Due to empty block removal, one block may have
1691         // several CatchProj inputs, from the same Catch.
1692       }
1693 
1694       // Set the offset of the return from the call
1695       assert(handler_bcis.find(-1) != -1, &quot;must have default handler&quot;);
1696       _handler_table.add_subtable(call_return, &amp;handler_bcis, NULL, &amp;handler_pcos);
1697       continue;
1698     }
1699 
1700     // Handle implicit null exception table updates
1701     if (n-&gt;is_MachNullCheck()) {
1702       uint block_num = block-&gt;non_connector_successor(0)-&gt;_pre_order;
1703       _inc_table.append(inct_starts[inct_cnt++], blk_labels[block_num].loc_pos());
1704       continue;
1705     }
1706     // Handle implicit exception table updates: trap instructions.
1707     if (n-&gt;is_Mach() &amp;&amp; n-&gt;as_Mach()-&gt;is_TrapBasedCheckNode()) {
1708       uint block_num = block-&gt;non_connector_successor(0)-&gt;_pre_order;
1709       _inc_table.append(inct_starts[inct_cnt++], blk_labels[block_num].loc_pos());
1710       continue;
1711     }
1712   } // End of for all blocks fill in exception table entries
1713 }
1714 
1715 // Static Variables
1716 #ifndef PRODUCT
1717 uint Scheduling::_total_nop_size = 0;
1718 uint Scheduling::_total_method_size = 0;
1719 uint Scheduling::_total_branches = 0;
1720 uint Scheduling::_total_unconditional_delays = 0;
1721 uint Scheduling::_total_instructions_per_bundle[Pipeline::_max_instrs_per_cycle+1];
1722 #endif
1723 
1724 // Initializer for class Scheduling
1725 
1726 Scheduling::Scheduling(Arena *arena, Compile &amp;compile)
1727         : _arena(arena),
1728           _cfg(compile.cfg()),
1729           _regalloc(compile.regalloc()),
1730           _scheduled(arena),
1731           _available(arena),
1732           _reg_node(arena),
1733           _pinch_free_list(arena),
1734           _next_node(NULL),
1735           _bundle_instr_count(0),
1736           _bundle_cycle_number(0),
1737           _bundle_use(0, 0, resource_count, &amp;_bundle_use_elements[0])
1738 #ifndef PRODUCT
1739         , _branches(0)
1740         , _unconditional_delays(0)
1741 #endif
1742 {
1743   // Create a MachNopNode
1744   _nop = new MachNopNode();
1745 
1746   // Now that the nops are in the array, save the count
1747   // (but allow entries for the nops)
1748   _node_bundling_limit = compile.unique();
1749   uint node_max = _regalloc-&gt;node_regs_max_index();
1750 
<a name="135" id="anc135"></a><span class="line-modified">1751   compile.set_node_bundling_limit(_node_bundling_limit);</span>
1752 
1753   // This one is persistent within the Compile class
1754   _node_bundling_base = NEW_ARENA_ARRAY(compile.comp_arena(), Bundle, node_max);
1755 
1756   // Allocate space for fixed-size arrays
1757   _node_latency    = NEW_ARENA_ARRAY(arena, unsigned short, node_max);
1758   _uses            = NEW_ARENA_ARRAY(arena, short,          node_max);
1759   _current_latency = NEW_ARENA_ARRAY(arena, unsigned short, node_max);
1760 
1761   // Clear the arrays
1762   for (uint i = 0; i &lt; node_max; i++) {
1763     ::new (&amp;_node_bundling_base[i]) Bundle();
1764   }
1765   memset(_node_latency,       0, node_max * sizeof(unsigned short));
1766   memset(_uses,               0, node_max * sizeof(short));
1767   memset(_current_latency,    0, node_max * sizeof(unsigned short));
1768 
1769   // Clear the bundling information
1770   memcpy(_bundle_use_elements, Pipeline_Use::elaborated_elements, sizeof(Pipeline_Use::elaborated_elements));
1771 
1772   // Get the last node
1773   Block* block = _cfg-&gt;get_block(_cfg-&gt;number_of_blocks() - 1);
1774 
1775   _next_node = block-&gt;get_node(block-&gt;number_of_nodes() - 1);
1776 }
1777 
1778 #ifndef PRODUCT
1779 // Scheduling destructor
1780 Scheduling::~Scheduling() {
1781   _total_branches             += _branches;
1782   _total_unconditional_delays += _unconditional_delays;
1783 }
1784 #endif
1785 
1786 // Step ahead &quot;i&quot; cycles
1787 void Scheduling::step(uint i) {
1788 
1789   Bundle *bundle = node_bundling(_next_node);
1790   bundle-&gt;set_starts_bundle();
1791 
1792   // Update the bundle record, but leave the flags information alone
1793   if (_bundle_instr_count &gt; 0) {
1794     bundle-&gt;set_instr_count(_bundle_instr_count);
1795     bundle-&gt;set_resources_used(_bundle_use.resourcesUsed());
1796   }
1797 
1798   // Update the state information
1799   _bundle_instr_count = 0;
1800   _bundle_cycle_number += i;
1801   _bundle_use.step(i);
1802 }
1803 
1804 void Scheduling::step_and_clear() {
1805   Bundle *bundle = node_bundling(_next_node);
1806   bundle-&gt;set_starts_bundle();
1807 
1808   // Update the bundle record
1809   if (_bundle_instr_count &gt; 0) {
1810     bundle-&gt;set_instr_count(_bundle_instr_count);
1811     bundle-&gt;set_resources_used(_bundle_use.resourcesUsed());
1812 
1813     _bundle_cycle_number += 1;
1814   }
1815 
1816   // Clear the bundling information
1817   _bundle_instr_count = 0;
1818   _bundle_use.reset();
1819 
1820   memcpy(_bundle_use_elements,
1821          Pipeline_Use::elaborated_elements,
1822          sizeof(Pipeline_Use::elaborated_elements));
1823 }
1824 
1825 // Perform instruction scheduling and bundling over the sequence of
1826 // instructions in backwards order.
<a name="136" id="anc136"></a><span class="line-modified">1827 void Compile::ScheduleAndBundle() {</span>
1828 
1829   // Don&#39;t optimize this if it isn&#39;t a method
<a name="137" id="anc137"></a><span class="line-modified">1830   if (!_method)</span>
1831     return;
1832 
1833   // Don&#39;t optimize this if scheduling is disabled
<a name="138" id="anc138"></a><span class="line-modified">1834   if (!do_scheduling())</span>
1835     return;
1836 
1837   // Scheduling code works only with pairs (16 bytes) maximum.
<a name="139" id="anc139"></a><span class="line-modified">1838   if (max_vector_size() &gt; 16)</span>
1839     return;
1840 
<a name="140" id="anc140"></a><span class="line-modified">1841   TracePhase tp(&quot;isched&quot;, &amp;timers[_t_instrSched]);</span>
1842 
1843   // Create a data structure for all the scheduling information
<a name="141" id="anc141"></a><span class="line-modified">1844   Scheduling scheduling(Thread::current()-&gt;resource_area(), *this);</span>
1845 
1846   // Walk backwards over each basic block, computing the needed alignment
1847   // Walk over all the basic blocks
1848   scheduling.DoScheduling();
1849 
1850 #ifndef PRODUCT
<a name="142" id="anc142"></a><span class="line-modified">1851   if (trace_opto_output()) {</span>
1852     tty-&gt;print(&quot;\n---- After ScheduleAndBundle ----\n&quot;);
<a name="143" id="anc143"></a><span class="line-modified">1853     for (uint i = 0; i &lt; _cfg-&gt;number_of_blocks(); i++) {</span>
1854       tty-&gt;print(&quot;\nBB#%03d:\n&quot;, i);
<a name="144" id="anc144"></a><span class="line-modified">1855       Block* block = _cfg-&gt;get_block(i);</span>
1856       for (uint j = 0; j &lt; block-&gt;number_of_nodes(); j++) {
1857         Node* n = block-&gt;get_node(j);
<a name="145" id="anc145"></a><span class="line-modified">1858         OptoReg::Name reg = _regalloc-&gt;get_reg_first(n);</span>
1859         tty-&gt;print(&quot; %-6s &quot;, reg &gt;= 0 &amp;&amp; reg &lt; REG_COUNT ? Matcher::regName[reg] : &quot;&quot;);
1860         n-&gt;dump();
1861       }
1862     }
1863   }
1864 #endif
1865 }
1866 
1867 // Compute the latency of all the instructions.  This is fairly simple,
1868 // because we already have a legal ordering.  Walk over the instructions
1869 // from first to last, and compute the latency of the instruction based
1870 // on the latency of the preceding instruction(s).
1871 void Scheduling::ComputeLocalLatenciesForward(const Block *bb) {
1872 #ifndef PRODUCT
1873   if (_cfg-&gt;C-&gt;trace_opto_output())
1874     tty-&gt;print(&quot;# -&gt; ComputeLocalLatenciesForward\n&quot;);
1875 #endif
1876 
1877   // Walk over all the schedulable instructions
1878   for( uint j=_bb_start; j &lt; _bb_end; j++ ) {
1879 
1880     // This is a kludge, forcing all latency calculations to start at 1.
1881     // Used to allow latency 0 to force an instruction to the beginning
1882     // of the bb
1883     uint latency = 1;
1884     Node *use = bb-&gt;get_node(j);
1885     uint nlen = use-&gt;len();
1886 
1887     // Walk over all the inputs
1888     for ( uint k=0; k &lt; nlen; k++ ) {
1889       Node *def = use-&gt;in(k);
1890       if (!def)
1891         continue;
1892 
1893       uint l = _node_latency[def-&gt;_idx] + use-&gt;latency(k);
1894       if (latency &lt; l)
1895         latency = l;
1896     }
1897 
1898     _node_latency[use-&gt;_idx] = latency;
1899 
1900 #ifndef PRODUCT
1901     if (_cfg-&gt;C-&gt;trace_opto_output()) {
1902       tty-&gt;print(&quot;# latency %4d: &quot;, latency);
1903       use-&gt;dump();
1904     }
1905 #endif
1906   }
1907 
1908 #ifndef PRODUCT
1909   if (_cfg-&gt;C-&gt;trace_opto_output())
1910     tty-&gt;print(&quot;# &lt;- ComputeLocalLatenciesForward\n&quot;);
1911 #endif
1912 
1913 } // end ComputeLocalLatenciesForward
1914 
1915 // See if this node fits into the present instruction bundle
1916 bool Scheduling::NodeFitsInBundle(Node *n) {
1917   uint n_idx = n-&gt;_idx;
1918 
1919   // If this is the unconditional delay instruction, then it fits
1920   if (n == _unconditional_delay_slot) {
1921 #ifndef PRODUCT
1922     if (_cfg-&gt;C-&gt;trace_opto_output())
1923       tty-&gt;print(&quot;#     NodeFitsInBundle [%4d]: TRUE; is in unconditional delay slot\n&quot;, n-&gt;_idx);
1924 #endif
1925     return (true);
1926   }
1927 
1928   // If the node cannot be scheduled this cycle, skip it
1929   if (_current_latency[n_idx] &gt; _bundle_cycle_number) {
1930 #ifndef PRODUCT
1931     if (_cfg-&gt;C-&gt;trace_opto_output())
1932       tty-&gt;print(&quot;#     NodeFitsInBundle [%4d]: FALSE; latency %4d &gt; %d\n&quot;,
1933                  n-&gt;_idx, _current_latency[n_idx], _bundle_cycle_number);
1934 #endif
1935     return (false);
1936   }
1937 
1938   const Pipeline *node_pipeline = n-&gt;pipeline();
1939 
1940   uint instruction_count = node_pipeline-&gt;instructionCount();
1941   if (node_pipeline-&gt;mayHaveNoCode() &amp;&amp; n-&gt;size(_regalloc) == 0)
1942     instruction_count = 0;
1943   else if (node_pipeline-&gt;hasBranchDelay() &amp;&amp; !_unconditional_delay_slot)
1944     instruction_count++;
1945 
1946   if (_bundle_instr_count + instruction_count &gt; Pipeline::_max_instrs_per_cycle) {
1947 #ifndef PRODUCT
1948     if (_cfg-&gt;C-&gt;trace_opto_output())
1949       tty-&gt;print(&quot;#     NodeFitsInBundle [%4d]: FALSE; too many instructions: %d &gt; %d\n&quot;,
1950                  n-&gt;_idx, _bundle_instr_count + instruction_count, Pipeline::_max_instrs_per_cycle);
1951 #endif
1952     return (false);
1953   }
1954 
1955   // Don&#39;t allow non-machine nodes to be handled this way
1956   if (!n-&gt;is_Mach() &amp;&amp; instruction_count == 0)
1957     return (false);
1958 
1959   // See if there is any overlap
1960   uint delay = _bundle_use.full_latency(0, node_pipeline-&gt;resourceUse());
1961 
1962   if (delay &gt; 0) {
1963 #ifndef PRODUCT
1964     if (_cfg-&gt;C-&gt;trace_opto_output())
1965       tty-&gt;print(&quot;#     NodeFitsInBundle [%4d]: FALSE; functional units overlap\n&quot;, n_idx);
1966 #endif
1967     return false;
1968   }
1969 
1970 #ifndef PRODUCT
1971   if (_cfg-&gt;C-&gt;trace_opto_output())
1972     tty-&gt;print(&quot;#     NodeFitsInBundle [%4d]:  TRUE\n&quot;, n_idx);
1973 #endif
1974 
1975   return true;
1976 }
1977 
1978 Node * Scheduling::ChooseNodeToBundle() {
1979   uint siz = _available.size();
1980 
1981   if (siz == 0) {
1982 
1983 #ifndef PRODUCT
1984     if (_cfg-&gt;C-&gt;trace_opto_output())
1985       tty-&gt;print(&quot;#   ChooseNodeToBundle: NULL\n&quot;);
1986 #endif
1987     return (NULL);
1988   }
1989 
1990   // Fast path, if only 1 instruction in the bundle
1991   if (siz == 1) {
1992 #ifndef PRODUCT
1993     if (_cfg-&gt;C-&gt;trace_opto_output()) {
1994       tty-&gt;print(&quot;#   ChooseNodeToBundle (only 1): &quot;);
1995       _available[0]-&gt;dump();
1996     }
1997 #endif
1998     return (_available[0]);
1999   }
2000 
2001   // Don&#39;t bother, if the bundle is already full
2002   if (_bundle_instr_count &lt; Pipeline::_max_instrs_per_cycle) {
2003     for ( uint i = 0; i &lt; siz; i++ ) {
2004       Node *n = _available[i];
2005 
2006       // Skip projections, we&#39;ll handle them another way
2007       if (n-&gt;is_Proj())
2008         continue;
2009 
2010       // This presupposed that instructions are inserted into the
2011       // available list in a legality order; i.e. instructions that
2012       // must be inserted first are at the head of the list
2013       if (NodeFitsInBundle(n)) {
2014 #ifndef PRODUCT
2015         if (_cfg-&gt;C-&gt;trace_opto_output()) {
2016           tty-&gt;print(&quot;#   ChooseNodeToBundle: &quot;);
2017           n-&gt;dump();
2018         }
2019 #endif
2020         return (n);
2021       }
2022     }
2023   }
2024 
2025   // Nothing fits in this bundle, choose the highest priority
2026 #ifndef PRODUCT
2027   if (_cfg-&gt;C-&gt;trace_opto_output()) {
2028     tty-&gt;print(&quot;#   ChooseNodeToBundle: &quot;);
2029     _available[0]-&gt;dump();
2030   }
2031 #endif
2032 
2033   return _available[0];
2034 }
2035 
2036 void Scheduling::AddNodeToAvailableList(Node *n) {
2037   assert( !n-&gt;is_Proj(), &quot;projections never directly made available&quot; );
2038 #ifndef PRODUCT
2039   if (_cfg-&gt;C-&gt;trace_opto_output()) {
2040     tty-&gt;print(&quot;#   AddNodeToAvailableList: &quot;);
2041     n-&gt;dump();
2042   }
2043 #endif
2044 
2045   int latency = _current_latency[n-&gt;_idx];
2046 
2047   // Insert in latency order (insertion sort)
2048   uint i;
2049   for ( i=0; i &lt; _available.size(); i++ )
2050     if (_current_latency[_available[i]-&gt;_idx] &gt; latency)
2051       break;
2052 
2053   // Special Check for compares following branches
2054   if( n-&gt;is_Mach() &amp;&amp; _scheduled.size() &gt; 0 ) {
2055     int op = n-&gt;as_Mach()-&gt;ideal_Opcode();
2056     Node *last = _scheduled[0];
2057     if( last-&gt;is_MachIf() &amp;&amp; last-&gt;in(1) == n &amp;&amp;
2058         ( op == Op_CmpI ||
2059           op == Op_CmpU ||
2060           op == Op_CmpUL ||
2061           op == Op_CmpP ||
2062           op == Op_CmpF ||
2063           op == Op_CmpD ||
2064           op == Op_CmpL ) ) {
2065 
2066       // Recalculate position, moving to front of same latency
2067       for ( i=0 ; i &lt; _available.size(); i++ )
2068         if (_current_latency[_available[i]-&gt;_idx] &gt;= latency)
2069           break;
2070     }
2071   }
2072 
2073   // Insert the node in the available list
2074   _available.insert(i, n);
2075 
2076 #ifndef PRODUCT
2077   if (_cfg-&gt;C-&gt;trace_opto_output())
2078     dump_available();
2079 #endif
2080 }
2081 
2082 void Scheduling::DecrementUseCounts(Node *n, const Block *bb) {
2083   for ( uint i=0; i &lt; n-&gt;len(); i++ ) {
2084     Node *def = n-&gt;in(i);
2085     if (!def) continue;
2086     if( def-&gt;is_Proj() )        // If this is a machine projection, then
2087       def = def-&gt;in(0);         // propagate usage thru to the base instruction
2088 
2089     if(_cfg-&gt;get_block_for_node(def) != bb) { // Ignore if not block-local
2090       continue;
2091     }
2092 
2093     // Compute the latency
2094     uint l = _bundle_cycle_number + n-&gt;latency(i);
2095     if (_current_latency[def-&gt;_idx] &lt; l)
2096       _current_latency[def-&gt;_idx] = l;
2097 
2098     // If this does not have uses then schedule it
2099     if ((--_uses[def-&gt;_idx]) == 0)
2100       AddNodeToAvailableList(def);
2101   }
2102 }
2103 
2104 void Scheduling::AddNodeToBundle(Node *n, const Block *bb) {
2105 #ifndef PRODUCT
2106   if (_cfg-&gt;C-&gt;trace_opto_output()) {
2107     tty-&gt;print(&quot;#   AddNodeToBundle: &quot;);
2108     n-&gt;dump();
2109   }
2110 #endif
2111 
2112   // Remove this from the available list
2113   uint i;
2114   for (i = 0; i &lt; _available.size(); i++)
2115     if (_available[i] == n)
2116       break;
2117   assert(i &lt; _available.size(), &quot;entry in _available list not found&quot;);
2118   _available.remove(i);
2119 
2120   // See if this fits in the current bundle
2121   const Pipeline *node_pipeline = n-&gt;pipeline();
2122   const Pipeline_Use&amp; node_usage = node_pipeline-&gt;resourceUse();
2123 
2124   // Check for instructions to be placed in the delay slot. We
2125   // do this before we actually schedule the current instruction,
2126   // because the delay slot follows the current instruction.
2127   if (Pipeline::_branch_has_delay_slot &amp;&amp;
2128       node_pipeline-&gt;hasBranchDelay() &amp;&amp;
2129       !_unconditional_delay_slot) {
2130 
2131     uint siz = _available.size();
2132 
2133     // Conditional branches can support an instruction that
2134     // is unconditionally executed and not dependent by the
2135     // branch, OR a conditionally executed instruction if
2136     // the branch is taken.  In practice, this means that
2137     // the first instruction at the branch target is
2138     // copied to the delay slot, and the branch goes to
2139     // the instruction after that at the branch target
2140     if ( n-&gt;is_MachBranch() ) {
2141 
2142       assert( !n-&gt;is_MachNullCheck(), &quot;should not look for delay slot for Null Check&quot; );
2143       assert( !n-&gt;is_Catch(),         &quot;should not look for delay slot for Catch&quot; );
2144 
2145 #ifndef PRODUCT
2146       _branches++;
2147 #endif
2148 
2149       // At least 1 instruction is on the available list
2150       // that is not dependent on the branch
2151       for (uint i = 0; i &lt; siz; i++) {
2152         Node *d = _available[i];
2153         const Pipeline *avail_pipeline = d-&gt;pipeline();
2154 
2155         // Don&#39;t allow safepoints in the branch shadow, that will
2156         // cause a number of difficulties
2157         if ( avail_pipeline-&gt;instructionCount() == 1 &amp;&amp;
2158              !avail_pipeline-&gt;hasMultipleBundles() &amp;&amp;
2159              !avail_pipeline-&gt;hasBranchDelay() &amp;&amp;
2160              Pipeline::instr_has_unit_size() &amp;&amp;
2161              d-&gt;size(_regalloc) == Pipeline::instr_unit_size() &amp;&amp;
2162              NodeFitsInBundle(d) &amp;&amp;
2163              !node_bundling(d)-&gt;used_in_delay()) {
2164 
2165           if (d-&gt;is_Mach() &amp;&amp; !d-&gt;is_MachSafePoint()) {
2166             // A node that fits in the delay slot was found, so we need to
2167             // set the appropriate bits in the bundle pipeline information so
2168             // that it correctly indicates resource usage.  Later, when we
2169             // attempt to add this instruction to the bundle, we will skip
2170             // setting the resource usage.
2171             _unconditional_delay_slot = d;
2172             node_bundling(n)-&gt;set_use_unconditional_delay();
2173             node_bundling(d)-&gt;set_used_in_unconditional_delay();
2174             _bundle_use.add_usage(avail_pipeline-&gt;resourceUse());
2175             _current_latency[d-&gt;_idx] = _bundle_cycle_number;
2176             _next_node = d;
2177             ++_bundle_instr_count;
2178 #ifndef PRODUCT
2179             _unconditional_delays++;
2180 #endif
2181             break;
2182           }
2183         }
2184       }
2185     }
2186 
2187     // No delay slot, add a nop to the usage
2188     if (!_unconditional_delay_slot) {
2189       // See if adding an instruction in the delay slot will overflow
2190       // the bundle.
2191       if (!NodeFitsInBundle(_nop)) {
2192 #ifndef PRODUCT
2193         if (_cfg-&gt;C-&gt;trace_opto_output())
2194           tty-&gt;print(&quot;#  *** STEP(1 instruction for delay slot) ***\n&quot;);
2195 #endif
2196         step(1);
2197       }
2198 
2199       _bundle_use.add_usage(_nop-&gt;pipeline()-&gt;resourceUse());
2200       _next_node = _nop;
2201       ++_bundle_instr_count;
2202     }
2203 
2204     // See if the instruction in the delay slot requires a
2205     // step of the bundles
2206     if (!NodeFitsInBundle(n)) {
2207 #ifndef PRODUCT
2208       if (_cfg-&gt;C-&gt;trace_opto_output())
2209         tty-&gt;print(&quot;#  *** STEP(branch won&#39;t fit) ***\n&quot;);
2210 #endif
2211       // Update the state information
2212       _bundle_instr_count = 0;
2213       _bundle_cycle_number += 1;
2214       _bundle_use.step(1);
2215     }
2216   }
2217 
2218   // Get the number of instructions
2219   uint instruction_count = node_pipeline-&gt;instructionCount();
2220   if (node_pipeline-&gt;mayHaveNoCode() &amp;&amp; n-&gt;size(_regalloc) == 0)
2221     instruction_count = 0;
2222 
2223   // Compute the latency information
2224   uint delay = 0;
2225 
2226   if (instruction_count &gt; 0 || !node_pipeline-&gt;mayHaveNoCode()) {
2227     int relative_latency = _current_latency[n-&gt;_idx] - _bundle_cycle_number;
2228     if (relative_latency &lt; 0)
2229       relative_latency = 0;
2230 
2231     delay = _bundle_use.full_latency(relative_latency, node_usage);
2232 
2233     // Does not fit in this bundle, start a new one
2234     if (delay &gt; 0) {
2235       step(delay);
2236 
2237 #ifndef PRODUCT
2238       if (_cfg-&gt;C-&gt;trace_opto_output())
2239         tty-&gt;print(&quot;#  *** STEP(%d) ***\n&quot;, delay);
2240 #endif
2241     }
2242   }
2243 
2244   // If this was placed in the delay slot, ignore it
2245   if (n != _unconditional_delay_slot) {
2246 
2247     if (delay == 0) {
2248       if (node_pipeline-&gt;hasMultipleBundles()) {
2249 #ifndef PRODUCT
2250         if (_cfg-&gt;C-&gt;trace_opto_output())
2251           tty-&gt;print(&quot;#  *** STEP(multiple instructions) ***\n&quot;);
2252 #endif
2253         step(1);
2254       }
2255 
2256       else if (instruction_count + _bundle_instr_count &gt; Pipeline::_max_instrs_per_cycle) {
2257 #ifndef PRODUCT
2258         if (_cfg-&gt;C-&gt;trace_opto_output())
2259           tty-&gt;print(&quot;#  *** STEP(%d &gt;= %d instructions) ***\n&quot;,
2260                      instruction_count + _bundle_instr_count,
2261                      Pipeline::_max_instrs_per_cycle);
2262 #endif
2263         step(1);
2264       }
2265     }
2266 
2267     if (node_pipeline-&gt;hasBranchDelay() &amp;&amp; !_unconditional_delay_slot)
2268       _bundle_instr_count++;
2269 
2270     // Set the node&#39;s latency
2271     _current_latency[n-&gt;_idx] = _bundle_cycle_number;
2272 
2273     // Now merge the functional unit information
2274     if (instruction_count &gt; 0 || !node_pipeline-&gt;mayHaveNoCode())
2275       _bundle_use.add_usage(node_usage);
2276 
2277     // Increment the number of instructions in this bundle
2278     _bundle_instr_count += instruction_count;
2279 
2280     // Remember this node for later
2281     if (n-&gt;is_Mach())
2282       _next_node = n;
2283   }
2284 
2285   // It&#39;s possible to have a BoxLock in the graph and in the _bbs mapping but
2286   // not in the bb-&gt;_nodes array.  This happens for debug-info-only BoxLocks.
2287   // &#39;Schedule&#39; them (basically ignore in the schedule) but do not insert them
2288   // into the block.  All other scheduled nodes get put in the schedule here.
2289   int op = n-&gt;Opcode();
2290   if( (op == Op_Node &amp;&amp; n-&gt;req() == 0) || // anti-dependence node OR
2291       (op != Op_Node &amp;&amp;         // Not an unused antidepedence node and
2292        // not an unallocated boxlock
2293        (OptoReg::is_valid(_regalloc-&gt;get_reg_first(n)) || op != Op_BoxLock)) ) {
2294 
2295     // Push any trailing projections
2296     if( bb-&gt;get_node(bb-&gt;number_of_nodes()-1) != n ) {
2297       for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
2298         Node *foi = n-&gt;fast_out(i);
2299         if( foi-&gt;is_Proj() )
2300           _scheduled.push(foi);
2301       }
2302     }
2303 
2304     // Put the instruction in the schedule list
2305     _scheduled.push(n);
2306   }
2307 
2308 #ifndef PRODUCT
2309   if (_cfg-&gt;C-&gt;trace_opto_output())
2310     dump_available();
2311 #endif
2312 
2313   // Walk all the definitions, decrementing use counts, and
2314   // if a definition has a 0 use count, place it in the available list.
2315   DecrementUseCounts(n,bb);
2316 }
2317 
2318 // This method sets the use count within a basic block.  We will ignore all
2319 // uses outside the current basic block.  As we are doing a backwards walk,
2320 // any node we reach that has a use count of 0 may be scheduled.  This also
2321 // avoids the problem of cyclic references from phi nodes, as long as phi
2322 // nodes are at the front of the basic block.  This method also initializes
2323 // the available list to the set of instructions that have no uses within this
2324 // basic block.
2325 void Scheduling::ComputeUseCount(const Block *bb) {
2326 #ifndef PRODUCT
2327   if (_cfg-&gt;C-&gt;trace_opto_output())
2328     tty-&gt;print(&quot;# -&gt; ComputeUseCount\n&quot;);
2329 #endif
2330 
2331   // Clear the list of available and scheduled instructions, just in case
2332   _available.clear();
2333   _scheduled.clear();
2334 
2335   // No delay slot specified
2336   _unconditional_delay_slot = NULL;
2337 
2338 #ifdef ASSERT
2339   for( uint i=0; i &lt; bb-&gt;number_of_nodes(); i++ )
2340     assert( _uses[bb-&gt;get_node(i)-&gt;_idx] == 0, &quot;_use array not clean&quot; );
2341 #endif
2342 
2343   // Force the _uses count to never go to zero for unscheduable pieces
2344   // of the block
2345   for( uint k = 0; k &lt; _bb_start; k++ )
2346     _uses[bb-&gt;get_node(k)-&gt;_idx] = 1;
2347   for( uint l = _bb_end; l &lt; bb-&gt;number_of_nodes(); l++ )
2348     _uses[bb-&gt;get_node(l)-&gt;_idx] = 1;
2349 
2350   // Iterate backwards over the instructions in the block.  Don&#39;t count the
2351   // branch projections at end or the block header instructions.
2352   for( uint j = _bb_end-1; j &gt;= _bb_start; j-- ) {
2353     Node *n = bb-&gt;get_node(j);
2354     if( n-&gt;is_Proj() ) continue; // Projections handled another way
2355 
2356     // Account for all uses
2357     for ( uint k = 0; k &lt; n-&gt;len(); k++ ) {
2358       Node *inp = n-&gt;in(k);
2359       if (!inp) continue;
2360       assert(inp != n, &quot;no cycles allowed&quot; );
2361       if (_cfg-&gt;get_block_for_node(inp) == bb) { // Block-local use?
2362         if (inp-&gt;is_Proj()) { // Skip through Proj&#39;s
2363           inp = inp-&gt;in(0);
2364         }
2365         ++_uses[inp-&gt;_idx];     // Count 1 block-local use
2366       }
2367     }
2368 
2369     // If this instruction has a 0 use count, then it is available
2370     if (!_uses[n-&gt;_idx]) {
2371       _current_latency[n-&gt;_idx] = _bundle_cycle_number;
2372       AddNodeToAvailableList(n);
2373     }
2374 
2375 #ifndef PRODUCT
2376     if (_cfg-&gt;C-&gt;trace_opto_output()) {
2377       tty-&gt;print(&quot;#   uses: %3d: &quot;, _uses[n-&gt;_idx]);
2378       n-&gt;dump();
2379     }
2380 #endif
2381   }
2382 
2383 #ifndef PRODUCT
2384   if (_cfg-&gt;C-&gt;trace_opto_output())
2385     tty-&gt;print(&quot;# &lt;- ComputeUseCount\n&quot;);
2386 #endif
2387 }
2388 
2389 // This routine performs scheduling on each basic block in reverse order,
2390 // using instruction latencies and taking into account function unit
2391 // availability.
2392 void Scheduling::DoScheduling() {
2393 #ifndef PRODUCT
2394   if (_cfg-&gt;C-&gt;trace_opto_output())
2395     tty-&gt;print(&quot;# -&gt; DoScheduling\n&quot;);
2396 #endif
2397 
2398   Block *succ_bb = NULL;
2399   Block *bb;
<a name="146" id="anc146"></a>
2400 
2401   // Walk over all the basic blocks in reverse order
2402   for (int i = _cfg-&gt;number_of_blocks() - 1; i &gt;= 0; succ_bb = bb, i--) {
2403     bb = _cfg-&gt;get_block(i);
2404 
2405 #ifndef PRODUCT
2406     if (_cfg-&gt;C-&gt;trace_opto_output()) {
2407       tty-&gt;print(&quot;#  Schedule BB#%03d (initial)\n&quot;, i);
2408       for (uint j = 0; j &lt; bb-&gt;number_of_nodes(); j++) {
2409         bb-&gt;get_node(j)-&gt;dump();
2410       }
2411     }
2412 #endif
2413 
2414     // On the head node, skip processing
2415     if (bb == _cfg-&gt;get_root_block()) {
2416       continue;
2417     }
2418 
2419     // Skip empty, connector blocks
2420     if (bb-&gt;is_connector())
2421       continue;
2422 
2423     // If the following block is not the sole successor of
2424     // this one, then reset the pipeline information
2425     if (bb-&gt;_num_succs != 1 || bb-&gt;non_connector_successor(0) != succ_bb) {
2426 #ifndef PRODUCT
2427       if (_cfg-&gt;C-&gt;trace_opto_output()) {
2428         tty-&gt;print(&quot;*** bundle start of next BB, node %d, for %d instructions\n&quot;,
2429                    _next_node-&gt;_idx, _bundle_instr_count);
2430       }
2431 #endif
2432       step_and_clear();
2433     }
2434 
2435     // Leave untouched the starting instruction, any Phis, a CreateEx node
2436     // or Top.  bb-&gt;get_node(_bb_start) is the first schedulable instruction.
2437     _bb_end = bb-&gt;number_of_nodes()-1;
2438     for( _bb_start=1; _bb_start &lt;= _bb_end; _bb_start++ ) {
2439       Node *n = bb-&gt;get_node(_bb_start);
2440       // Things not matched, like Phinodes and ProjNodes don&#39;t get scheduled.
2441       // Also, MachIdealNodes do not get scheduled
2442       if( !n-&gt;is_Mach() ) continue;     // Skip non-machine nodes
2443       MachNode *mach = n-&gt;as_Mach();
2444       int iop = mach-&gt;ideal_Opcode();
2445       if( iop == Op_CreateEx ) continue; // CreateEx is pinned
2446       if( iop == Op_Con ) continue;      // Do not schedule Top
2447       if( iop == Op_Node &amp;&amp;     // Do not schedule PhiNodes, ProjNodes
2448           mach-&gt;pipeline() == MachNode::pipeline_class() &amp;&amp;
2449           !n-&gt;is_SpillCopy() &amp;&amp; !n-&gt;is_MachMerge() )  // Breakpoints, Prolog, etc
2450         continue;
2451       break;                    // Funny loop structure to be sure...
2452     }
2453     // Compute last &quot;interesting&quot; instruction in block - last instruction we
2454     // might schedule.  _bb_end points just after last schedulable inst.  We
2455     // normally schedule conditional branches (despite them being forced last
2456     // in the block), because they have delay slots we can fill.  Calls all
2457     // have their delay slots filled in the template expansions, so we don&#39;t
2458     // bother scheduling them.
2459     Node *last = bb-&gt;get_node(_bb_end);
2460     // Ignore trailing NOPs.
2461     while (_bb_end &gt; 0 &amp;&amp; last-&gt;is_Mach() &amp;&amp;
2462            last-&gt;as_Mach()-&gt;ideal_Opcode() == Op_Con) {
2463       last = bb-&gt;get_node(--_bb_end);
2464     }
2465     assert(!last-&gt;is_Mach() || last-&gt;as_Mach()-&gt;ideal_Opcode() != Op_Con, &quot;&quot;);
2466     if( last-&gt;is_Catch() ||
2467         (last-&gt;is_Mach() &amp;&amp; last-&gt;as_Mach()-&gt;ideal_Opcode() == Op_Halt) ) {
2468       // There might be a prior call.  Skip it.
2469       while (_bb_start &lt; _bb_end &amp;&amp; bb-&gt;get_node(--_bb_end)-&gt;is_MachProj());
2470     } else if( last-&gt;is_MachNullCheck() ) {
2471       // Backup so the last null-checked memory instruction is
2472       // outside the schedulable range. Skip over the nullcheck,
2473       // projection, and the memory nodes.
2474       Node *mem = last-&gt;in(1);
2475       do {
2476         _bb_end--;
2477       } while (mem != bb-&gt;get_node(_bb_end));
2478     } else {
2479       // Set _bb_end to point after last schedulable inst.
2480       _bb_end++;
2481     }
2482 
2483     assert( _bb_start &lt;= _bb_end, &quot;inverted block ends&quot; );
2484 
2485     // Compute the register antidependencies for the basic block
2486     ComputeRegisterAntidependencies(bb);
<a name="147" id="anc147"></a><span class="line-modified">2487     if (_cfg-&gt;C-&gt;failing())  return;  // too many D-U pinch points</span>
2488 
2489     // Compute intra-bb latencies for the nodes
2490     ComputeLocalLatenciesForward(bb);
2491 
2492     // Compute the usage within the block, and set the list of all nodes
2493     // in the block that have no uses within the block.
2494     ComputeUseCount(bb);
2495 
2496     // Schedule the remaining instructions in the block
2497     while ( _available.size() &gt; 0 ) {
2498       Node *n = ChooseNodeToBundle();
2499       guarantee(n != NULL, &quot;no nodes available&quot;);
2500       AddNodeToBundle(n,bb);
2501     }
2502 
2503     assert( _scheduled.size() == _bb_end - _bb_start, &quot;wrong number of instructions&quot; );
2504 #ifdef ASSERT
2505     for( uint l = _bb_start; l &lt; _bb_end; l++ ) {
2506       Node *n = bb-&gt;get_node(l);
2507       uint m;
2508       for( m = 0; m &lt; _bb_end-_bb_start; m++ )
2509         if( _scheduled[m] == n )
2510           break;
2511       assert( m &lt; _bb_end-_bb_start, &quot;instruction missing in schedule&quot; );
2512     }
2513 #endif
2514 
2515     // Now copy the instructions (in reverse order) back to the block
2516     for ( uint k = _bb_start; k &lt; _bb_end; k++ )
2517       bb-&gt;map_node(_scheduled[_bb_end-k-1], k);
2518 
2519 #ifndef PRODUCT
2520     if (_cfg-&gt;C-&gt;trace_opto_output()) {
2521       tty-&gt;print(&quot;#  Schedule BB#%03d (final)\n&quot;, i);
2522       uint current = 0;
2523       for (uint j = 0; j &lt; bb-&gt;number_of_nodes(); j++) {
2524         Node *n = bb-&gt;get_node(j);
2525         if( valid_bundle_info(n) ) {
2526           Bundle *bundle = node_bundling(n);
2527           if (bundle-&gt;instr_count() &gt; 0 || bundle-&gt;flags() &gt; 0) {
2528             tty-&gt;print(&quot;*** Bundle: &quot;);
2529             bundle-&gt;dump();
2530           }
2531           n-&gt;dump();
2532         }
2533       }
2534     }
2535 #endif
2536 #ifdef ASSERT
2537     verify_good_schedule(bb,&quot;after block local scheduling&quot;);
2538 #endif
2539   }
2540 
2541 #ifndef PRODUCT
2542   if (_cfg-&gt;C-&gt;trace_opto_output())
2543     tty-&gt;print(&quot;# &lt;- DoScheduling\n&quot;);
2544 #endif
2545 
2546   // Record final node-bundling array location
<a name="148" id="anc148"></a><span class="line-modified">2547   _regalloc-&gt;C-&gt;set_node_bundling_base(_node_bundling_base);</span>
2548 
2549 } // end DoScheduling
2550 
2551 // Verify that no live-range used in the block is killed in the block by a
2552 // wrong DEF.  This doesn&#39;t verify live-ranges that span blocks.
2553 
2554 // Check for edge existence.  Used to avoid adding redundant precedence edges.
2555 static bool edge_from_to( Node *from, Node *to ) {
2556   for( uint i=0; i&lt;from-&gt;len(); i++ )
2557     if( from-&gt;in(i) == to )
2558       return true;
2559   return false;
2560 }
2561 
2562 #ifdef ASSERT
2563 void Scheduling::verify_do_def( Node *n, OptoReg::Name def, const char *msg ) {
2564   // Check for bad kills
2565   if( OptoReg::is_valid(def) ) { // Ignore stores &amp; control flow
2566     Node *prior_use = _reg_node[def];
2567     if( prior_use &amp;&amp; !edge_from_to(prior_use,n) ) {
2568       tty-&gt;print(&quot;%s = &quot;,OptoReg::as_VMReg(def)-&gt;name());
2569       n-&gt;dump();
2570       tty-&gt;print_cr(&quot;...&quot;);
2571       prior_use-&gt;dump();
2572       assert(edge_from_to(prior_use,n), &quot;%s&quot;, msg);
2573     }
2574     _reg_node.map(def,NULL); // Kill live USEs
2575   }
2576 }
2577 
2578 void Scheduling::verify_good_schedule( Block *b, const char *msg ) {
2579 
2580   // Zap to something reasonable for the verify code
2581   _reg_node.clear();
2582 
2583   // Walk over the block backwards.  Check to make sure each DEF doesn&#39;t
2584   // kill a live value (other than the one it&#39;s supposed to).  Add each
2585   // USE to the live set.
2586   for( uint i = b-&gt;number_of_nodes()-1; i &gt;= _bb_start; i-- ) {
2587     Node *n = b-&gt;get_node(i);
2588     int n_op = n-&gt;Opcode();
2589     if( n_op == Op_MachProj &amp;&amp; n-&gt;ideal_reg() == MachProjNode::fat_proj ) {
2590       // Fat-proj kills a slew of registers
2591       RegMask rm = n-&gt;out_RegMask();// Make local copy
2592       while( rm.is_NotEmpty() ) {
2593         OptoReg::Name kill = rm.find_first_elem();
2594         rm.Remove(kill);
2595         verify_do_def( n, kill, msg );
2596       }
2597     } else if( n_op != Op_Node ) { // Avoid brand new antidependence nodes
2598       // Get DEF&#39;d registers the normal way
2599       verify_do_def( n, _regalloc-&gt;get_reg_first(n), msg );
2600       verify_do_def( n, _regalloc-&gt;get_reg_second(n), msg );
2601     }
2602 
2603     // Now make all USEs live
2604     for( uint i=1; i&lt;n-&gt;req(); i++ ) {
2605       Node *def = n-&gt;in(i);
2606       assert(def != 0, &quot;input edge required&quot;);
2607       OptoReg::Name reg_lo = _regalloc-&gt;get_reg_first(def);
2608       OptoReg::Name reg_hi = _regalloc-&gt;get_reg_second(def);
2609       if( OptoReg::is_valid(reg_lo) ) {
2610         assert(!_reg_node[reg_lo] || edge_from_to(_reg_node[reg_lo],def), &quot;%s&quot;, msg);
2611         _reg_node.map(reg_lo,n);
2612       }
2613       if( OptoReg::is_valid(reg_hi) ) {
2614         assert(!_reg_node[reg_hi] || edge_from_to(_reg_node[reg_hi],def), &quot;%s&quot;, msg);
2615         _reg_node.map(reg_hi,n);
2616       }
2617     }
2618 
2619   }
2620 
2621   // Zap to something reasonable for the Antidependence code
2622   _reg_node.clear();
2623 }
2624 #endif
2625 
2626 // Conditionally add precedence edges.  Avoid putting edges on Projs.
2627 static void add_prec_edge_from_to( Node *from, Node *to ) {
2628   if( from-&gt;is_Proj() ) {       // Put precedence edge on Proj&#39;s input
2629     assert( from-&gt;req() == 1 &amp;&amp; (from-&gt;len() == 1 || from-&gt;in(1)==0), &quot;no precedence edges on projections&quot; );
2630     from = from-&gt;in(0);
2631   }
2632   if( from != to &amp;&amp;             // No cycles (for things like LD L0,[L0+4] )
2633       !edge_from_to( from, to ) ) // Avoid duplicate edge
2634     from-&gt;add_prec(to);
2635 }
2636 
2637 void Scheduling::anti_do_def( Block *b, Node *def, OptoReg::Name def_reg, int is_def ) {
2638   if( !OptoReg::is_valid(def_reg) ) // Ignore stores &amp; control flow
2639     return;
2640 
2641   Node *pinch = _reg_node[def_reg]; // Get pinch point
2642   if ((pinch == NULL) || _cfg-&gt;get_block_for_node(pinch) != b || // No pinch-point yet?
2643       is_def ) {    // Check for a true def (not a kill)
2644     _reg_node.map(def_reg,def); // Record def/kill as the optimistic pinch-point
2645     return;
2646   }
2647 
2648   Node *kill = def;             // Rename &#39;def&#39; to more descriptive &#39;kill&#39;
2649   debug_only( def = (Node*)((intptr_t)0xdeadbeef); )
2650 
2651   // After some number of kills there _may_ be a later def
2652   Node *later_def = NULL;
2653 
<a name="149" id="anc149"></a>

2654   // Finding a kill requires a real pinch-point.
2655   // Check for not already having a pinch-point.
2656   // Pinch points are Op_Node&#39;s.
2657   if( pinch-&gt;Opcode() != Op_Node ) { // Or later-def/kill as pinch-point?
2658     later_def = pinch;            // Must be def/kill as optimistic pinch-point
2659     if ( _pinch_free_list.size() &gt; 0) {
2660       pinch = _pinch_free_list.pop();
2661     } else {
2662       pinch = new Node(1); // Pinch point to-be
2663     }
2664     if (pinch-&gt;_idx &gt;= _regalloc-&gt;node_regs_max_index()) {
2665       _cfg-&gt;C-&gt;record_method_not_compilable(&quot;too many D-U pinch points&quot;);
2666       return;
2667     }
2668     _cfg-&gt;map_node_to_block(pinch, b);      // Pretend it&#39;s valid in this block (lazy init)
2669     _reg_node.map(def_reg,pinch); // Record pinch-point
<a name="150" id="anc150"></a><span class="line-modified">2670     //_regalloc-&gt;set_bad(pinch-&gt;_idx); // Already initialized this way.</span>
2671     if( later_def-&gt;outcnt() == 0 || later_def-&gt;ideal_reg() == MachProjNode::fat_proj ) { // Distinguish def from kill
<a name="151" id="anc151"></a><span class="line-modified">2672       pinch-&gt;init_req(0, _cfg-&gt;C-&gt;top());     // set not NULL for the next call</span>
2673       add_prec_edge_from_to(later_def,pinch); // Add edge from kill to pinch
2674       later_def = NULL;           // and no later def
2675     }
2676     pinch-&gt;set_req(0,later_def);  // Hook later def so we can find it
2677   } else {                        // Else have valid pinch point
2678     if( pinch-&gt;in(0) )            // If there is a later-def
2679       later_def = pinch-&gt;in(0);   // Get it
2680   }
2681 
2682   // Add output-dependence edge from later def to kill
2683   if( later_def )               // If there is some original def
2684     add_prec_edge_from_to(later_def,kill); // Add edge from def to kill
2685 
2686   // See if current kill is also a use, and so is forced to be the pinch-point.
2687   if( pinch-&gt;Opcode() == Op_Node ) {
2688     Node *uses = kill-&gt;is_Proj() ? kill-&gt;in(0) : kill;
2689     for( uint i=1; i&lt;uses-&gt;req(); i++ ) {
2690       if( _regalloc-&gt;get_reg_first(uses-&gt;in(i)) == def_reg ||
2691           _regalloc-&gt;get_reg_second(uses-&gt;in(i)) == def_reg ) {
2692         // Yes, found a use/kill pinch-point
2693         pinch-&gt;set_req(0,NULL);  //
2694         pinch-&gt;replace_by(kill); // Move anti-dep edges up
2695         pinch = kill;
2696         _reg_node.map(def_reg,pinch);
2697         return;
2698       }
2699     }
2700   }
2701 
2702   // Add edge from kill to pinch-point
2703   add_prec_edge_from_to(kill,pinch);
2704 }
2705 
2706 void Scheduling::anti_do_use( Block *b, Node *use, OptoReg::Name use_reg ) {
2707   if( !OptoReg::is_valid(use_reg) ) // Ignore stores &amp; control flow
2708     return;
2709   Node *pinch = _reg_node[use_reg]; // Get pinch point
2710   // Check for no later def_reg/kill in block
2711   if ((pinch != NULL) &amp;&amp; _cfg-&gt;get_block_for_node(pinch) == b &amp;&amp;
2712       // Use has to be block-local as well
2713       _cfg-&gt;get_block_for_node(use) == b) {
2714     if( pinch-&gt;Opcode() == Op_Node &amp;&amp; // Real pinch-point (not optimistic?)
2715         pinch-&gt;req() == 1 ) {   // pinch not yet in block?
2716       pinch-&gt;del_req(0);        // yank pointer to later-def, also set flag
2717       // Insert the pinch-point in the block just after the last use
2718       b-&gt;insert_node(pinch, b-&gt;find_node(use) + 1);
2719       _bb_end++;                // Increase size scheduled region in block
2720     }
2721 
2722     add_prec_edge_from_to(pinch,use);
2723   }
2724 }
2725 
2726 // We insert antidependences between the reads and following write of
2727 // allocated registers to prevent illegal code motion. Hopefully, the
2728 // number of added references should be fairly small, especially as we
2729 // are only adding references within the current basic block.
2730 void Scheduling::ComputeRegisterAntidependencies(Block *b) {
2731 
2732 #ifdef ASSERT
2733   verify_good_schedule(b,&quot;before block local scheduling&quot;);
2734 #endif
2735 
2736   // A valid schedule, for each register independently, is an endless cycle
2737   // of: a def, then some uses (connected to the def by true dependencies),
2738   // then some kills (defs with no uses), finally the cycle repeats with a new
2739   // def.  The uses are allowed to float relative to each other, as are the
2740   // kills.  No use is allowed to slide past a kill (or def).  This requires
2741   // antidependencies between all uses of a single def and all kills that
2742   // follow, up to the next def.  More edges are redundant, because later defs
2743   // &amp; kills are already serialized with true or antidependencies.  To keep
2744   // the edge count down, we add a &#39;pinch point&#39; node if there&#39;s more than
2745   // one use or more than one kill/def.
2746 
2747   // We add dependencies in one bottom-up pass.
2748 
2749   // For each instruction we handle it&#39;s DEFs/KILLs, then it&#39;s USEs.
2750 
2751   // For each DEF/KILL, we check to see if there&#39;s a prior DEF/KILL for this
2752   // register.  If not, we record the DEF/KILL in _reg_node, the
2753   // register-to-def mapping.  If there is a prior DEF/KILL, we insert a
2754   // &quot;pinch point&quot;, a new Node that&#39;s in the graph but not in the block.
2755   // We put edges from the prior and current DEF/KILLs to the pinch point.
2756   // We put the pinch point in _reg_node.  If there&#39;s already a pinch point
2757   // we merely add an edge from the current DEF/KILL to the pinch point.
2758 
2759   // After doing the DEF/KILLs, we handle USEs.  For each used register, we
2760   // put an edge from the pinch point to the USE.
2761 
2762   // To be expedient, the _reg_node array is pre-allocated for the whole
2763   // compilation.  _reg_node is lazily initialized; it either contains a NULL,
2764   // or a valid def/kill/pinch-point, or a leftover node from some prior
2765   // block.  Leftover node from some prior block is treated like a NULL (no
2766   // prior def, so no anti-dependence needed).  Valid def is distinguished by
2767   // it being in the current block.
2768   bool fat_proj_seen = false;
2769   uint last_safept = _bb_end-1;
2770   Node* end_node         = (_bb_end-1 &gt;= _bb_start) ? b-&gt;get_node(last_safept) : NULL;
2771   Node* last_safept_node = end_node;
2772   for( uint i = _bb_end-1; i &gt;= _bb_start; i-- ) {
2773     Node *n = b-&gt;get_node(i);
2774     int is_def = n-&gt;outcnt();   // def if some uses prior to adding precedence edges
2775     if( n-&gt;is_MachProj() &amp;&amp; n-&gt;ideal_reg() == MachProjNode::fat_proj ) {
2776       // Fat-proj kills a slew of registers
2777       // This can add edges to &#39;n&#39; and obscure whether or not it was a def,
2778       // hence the is_def flag.
2779       fat_proj_seen = true;
2780       RegMask rm = n-&gt;out_RegMask();// Make local copy
2781       while( rm.is_NotEmpty() ) {
2782         OptoReg::Name kill = rm.find_first_elem();
2783         rm.Remove(kill);
2784         anti_do_def( b, n, kill, is_def );
2785       }
2786     } else {
2787       // Get DEF&#39;d registers the normal way
2788       anti_do_def( b, n, _regalloc-&gt;get_reg_first(n), is_def );
2789       anti_do_def( b, n, _regalloc-&gt;get_reg_second(n), is_def );
2790     }
2791 
2792     // Kill projections on a branch should appear to occur on the
2793     // branch, not afterwards, so grab the masks from the projections
2794     // and process them.
2795     if (n-&gt;is_MachBranch() || (n-&gt;is_Mach() &amp;&amp; n-&gt;as_Mach()-&gt;ideal_Opcode() == Op_Jump)) {
2796       for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
2797         Node* use = n-&gt;fast_out(i);
2798         if (use-&gt;is_Proj()) {
2799           RegMask rm = use-&gt;out_RegMask();// Make local copy
2800           while( rm.is_NotEmpty() ) {
2801             OptoReg::Name kill = rm.find_first_elem();
2802             rm.Remove(kill);
2803             anti_do_def( b, n, kill, false );
2804           }
2805         }
2806       }
2807     }
2808 
2809     // Check each register used by this instruction for a following DEF/KILL
2810     // that must occur afterward and requires an anti-dependence edge.
2811     for( uint j=0; j&lt;n-&gt;req(); j++ ) {
2812       Node *def = n-&gt;in(j);
2813       if( def ) {
2814         assert( !def-&gt;is_MachProj() || def-&gt;ideal_reg() != MachProjNode::fat_proj, &quot;&quot; );
2815         anti_do_use( b, n, _regalloc-&gt;get_reg_first(def) );
2816         anti_do_use( b, n, _regalloc-&gt;get_reg_second(def) );
2817       }
2818     }
2819     // Do not allow defs of new derived values to float above GC
2820     // points unless the base is definitely available at the GC point.
2821 
2822     Node *m = b-&gt;get_node(i);
2823 
2824     // Add precedence edge from following safepoint to use of derived pointer
2825     if( last_safept_node != end_node &amp;&amp;
2826         m != last_safept_node) {
2827       for (uint k = 1; k &lt; m-&gt;req(); k++) {
2828         const Type *t = m-&gt;in(k)-&gt;bottom_type();
2829         if( t-&gt;isa_oop_ptr() &amp;&amp;
2830             t-&gt;is_ptr()-&gt;offset() != 0 ) {
2831           last_safept_node-&gt;add_prec( m );
2832           break;
2833         }
2834       }
2835     }
2836 
2837     if( n-&gt;jvms() ) {           // Precedence edge from derived to safept
2838       // Check if last_safept_node was moved by pinch-point insertion in anti_do_use()
2839       if( b-&gt;get_node(last_safept) != last_safept_node ) {
2840         last_safept = b-&gt;find_node(last_safept_node);
2841       }
2842       for( uint j=last_safept; j &gt; i; j-- ) {
2843         Node *mach = b-&gt;get_node(j);
2844         if( mach-&gt;is_Mach() &amp;&amp; mach-&gt;as_Mach()-&gt;ideal_Opcode() == Op_AddP )
2845           mach-&gt;add_prec( n );
2846       }
2847       last_safept = i;
2848       last_safept_node = m;
2849     }
2850   }
2851 
2852   if (fat_proj_seen) {
2853     // Garbage collect pinch nodes that were not consumed.
2854     // They are usually created by a fat kill MachProj for a call.
2855     garbage_collect_pinch_nodes();
2856   }
2857 }
2858 
2859 // Garbage collect pinch nodes for reuse by other blocks.
2860 //
2861 // The block scheduler&#39;s insertion of anti-dependence
2862 // edges creates many pinch nodes when the block contains
2863 // 2 or more Calls.  A pinch node is used to prevent a
2864 // combinatorial explosion of edges.  If a set of kills for a
2865 // register is anti-dependent on a set of uses (or defs), rather
2866 // than adding an edge in the graph between each pair of kill
2867 // and use (or def), a pinch is inserted between them:
2868 //
2869 //            use1   use2  use3
2870 //                \   |   /
2871 //                 \  |  /
2872 //                  pinch
2873 //                 /  |  \
2874 //                /   |   \
2875 //            kill1 kill2 kill3
2876 //
2877 // One pinch node is created per register killed when
2878 // the second call is encountered during a backwards pass
2879 // over the block.  Most of these pinch nodes are never
2880 // wired into the graph because the register is never
2881 // used or def&#39;ed in the block.
2882 //
2883 void Scheduling::garbage_collect_pinch_nodes() {
2884 #ifndef PRODUCT
2885   if (_cfg-&gt;C-&gt;trace_opto_output()) tty-&gt;print(&quot;Reclaimed pinch nodes:&quot;);
2886 #endif
2887   int trace_cnt = 0;
2888   for (uint k = 0; k &lt; _reg_node.Size(); k++) {
2889     Node* pinch = _reg_node[k];
2890     if ((pinch != NULL) &amp;&amp; pinch-&gt;Opcode() == Op_Node &amp;&amp;
2891         // no predecence input edges
2892         (pinch-&gt;req() == pinch-&gt;len() || pinch-&gt;in(pinch-&gt;req()) == NULL) ) {
2893       cleanup_pinch(pinch);
2894       _pinch_free_list.push(pinch);
2895       _reg_node.map(k, NULL);
2896 #ifndef PRODUCT
2897       if (_cfg-&gt;C-&gt;trace_opto_output()) {
2898         trace_cnt++;
2899         if (trace_cnt &gt; 40) {
2900           tty-&gt;print(&quot;\n&quot;);
2901           trace_cnt = 0;
2902         }
2903         tty-&gt;print(&quot; %d&quot;, pinch-&gt;_idx);
2904       }
2905 #endif
2906     }
2907   }
2908 #ifndef PRODUCT
2909   if (_cfg-&gt;C-&gt;trace_opto_output()) tty-&gt;print(&quot;\n&quot;);
2910 #endif
2911 }
2912 
2913 // Clean up a pinch node for reuse.
2914 void Scheduling::cleanup_pinch( Node *pinch ) {
2915   assert (pinch &amp;&amp; pinch-&gt;Opcode() == Op_Node &amp;&amp; pinch-&gt;req() == 1, &quot;just checking&quot;);
2916 
2917   for (DUIterator_Last imin, i = pinch-&gt;last_outs(imin); i &gt;= imin; ) {
2918     Node* use = pinch-&gt;last_out(i);
2919     uint uses_found = 0;
2920     for (uint j = use-&gt;req(); j &lt; use-&gt;len(); j++) {
2921       if (use-&gt;in(j) == pinch) {
2922         use-&gt;rm_prec(j);
2923         uses_found++;
2924       }
2925     }
2926     assert(uses_found &gt; 0, &quot;must be a precedence edge&quot;);
2927     i -= uses_found;    // we deleted 1 or more copies of this edge
2928   }
2929   // May have a later_def entry
2930   pinch-&gt;set_req(0, NULL);
2931 }
2932 
2933 #ifndef PRODUCT
2934 
2935 void Scheduling::dump_available() const {
2936   tty-&gt;print(&quot;#Availist  &quot;);
2937   for (uint i = 0; i &lt; _available.size(); i++)
2938     tty-&gt;print(&quot; N%d/l%d&quot;, _available[i]-&gt;_idx,_current_latency[_available[i]-&gt;_idx]);
2939   tty-&gt;cr();
2940 }
2941 
2942 // Print Scheduling Statistics
2943 void Scheduling::print_statistics() {
2944   // Print the size added by nops for bundling
2945   tty-&gt;print(&quot;Nops added %d bytes to total of %d bytes&quot;,
2946              _total_nop_size, _total_method_size);
2947   if (_total_method_size &gt; 0)
2948     tty-&gt;print(&quot;, for %.2f%%&quot;,
2949                ((double)_total_nop_size) / ((double) _total_method_size) * 100.0);
2950   tty-&gt;print(&quot;\n&quot;);
2951 
2952   // Print the number of branch shadows filled
2953   if (Pipeline::_branch_has_delay_slot) {
2954     tty-&gt;print(&quot;Of %d branches, %d had unconditional delay slots filled&quot;,
2955                _total_branches, _total_unconditional_delays);
2956     if (_total_branches &gt; 0)
2957       tty-&gt;print(&quot;, for %.2f%%&quot;,
2958                  ((double)_total_unconditional_delays) / ((double)_total_branches) * 100.0);
2959     tty-&gt;print(&quot;\n&quot;);
2960   }
2961 
2962   uint total_instructions = 0, total_bundles = 0;
2963 
2964   for (uint i = 1; i &lt;= Pipeline::_max_instrs_per_cycle; i++) {
2965     uint bundle_count   = _total_instructions_per_bundle[i];
2966     total_instructions += bundle_count * i;
2967     total_bundles      += bundle_count;
2968   }
2969 
2970   if (total_bundles &gt; 0)
2971     tty-&gt;print(&quot;Average ILP (excluding nops) is %.2f\n&quot;,
2972                ((double)total_instructions) / ((double)total_bundles));
2973 }
2974 #endif
<a name="152" id="anc152"></a>






























































































































































































































































































































































<a name="153" id="anc153"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="153" type="hidden" />
</body>
</html>
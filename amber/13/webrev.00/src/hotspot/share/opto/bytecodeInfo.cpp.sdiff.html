<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/bytecodeInfo.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="buildOopMap.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c2_globals.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/bytecodeInfo.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;ci/ciReplay.hpp&quot;
 27 #include &quot;classfile/systemDictionary.hpp&quot;
 28 #include &quot;classfile/vmSymbols.hpp&quot;
 29 #include &quot;compiler/compileBroker.hpp&quot;

 30 #include &quot;compiler/compileLog.hpp&quot;
 31 #include &quot;interpreter/linkResolver.hpp&quot;
<span class="line-removed"> 32 #include &quot;jfr/jfrEvents.hpp&quot;</span>
 33 #include &quot;oops/objArrayKlass.hpp&quot;
 34 #include &quot;opto/callGenerator.hpp&quot;
 35 #include &quot;opto/parse.hpp&quot;
 36 #include &quot;runtime/handles.inline.hpp&quot;
 37 #include &quot;utilities/events.hpp&quot;
 38 
 39 //=============================================================================
 40 //------------------------------InlineTree-------------------------------------
 41 InlineTree::InlineTree(Compile* c,
 42                        const InlineTree *caller_tree, ciMethod* callee,
 43                        JVMState* caller_jvms, int caller_bci,
 44                        float site_invoke_ratio, int max_inline_level) :
 45   C(c),
 46   _caller_jvms(caller_jvms),
 47   _method(callee),
 48   _caller_tree((InlineTree*) caller_tree),
 49   _count_inline_bcs(method()-&gt;code_size_for_inlining()),
 50   _site_invoke_ratio(site_invoke_ratio),
 51   _max_inline_level(max_inline_level),
 52   _subtrees(c-&gt;comp_arena(), 2, 0, NULL),
</pre>
<hr />
<pre>
514       // Try to do constant pool resolution if running Xcomp
515       if( !caller_method-&gt;check_call(index, call_bc == Bytecodes::_invokestatic) ) {
516         return false;
517       }
518     }
519   }
520   return true;
521 }
522 
523 //------------------------------check_can_parse--------------------------------
524 const char* InlineTree::check_can_parse(ciMethod* callee) {
525   // Certain methods cannot be parsed at all:
526   if ( callee-&gt;is_native())                     return &quot;native method&quot;;
527   if ( callee-&gt;is_abstract())                   return &quot;abstract method&quot;;
528   if (!callee-&gt;has_balanced_monitors())         return &quot;not compilable (unbalanced monitors)&quot;;
529   if ( callee-&gt;get_flow_analysis()-&gt;failing())  return &quot;not compilable (flow analysis failed)&quot;;
530   if (!callee-&gt;can_be_parsed())                 return &quot;cannot be parsed&quot;;
531   return NULL;
532 }
533 
<span class="line-removed">534 static void post_inlining_event(int compile_id,const char* msg, bool success, int bci, ciMethod* caller, ciMethod* callee) {</span>
<span class="line-removed">535   assert(caller != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">536   assert(callee != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">537   EventCompilerInlining event;</span>
<span class="line-removed">538   if (event.should_commit()) {</span>
<span class="line-removed">539     JfrStructCalleeMethod callee_struct;</span>
<span class="line-removed">540     callee_struct.set_type(callee-&gt;holder()-&gt;name()-&gt;as_utf8());</span>
<span class="line-removed">541     callee_struct.set_name(callee-&gt;name()-&gt;as_utf8());</span>
<span class="line-removed">542     callee_struct.set_descriptor(callee-&gt;signature()-&gt;as_symbol()-&gt;as_utf8());</span>
<span class="line-removed">543     event.set_compileId(compile_id);</span>
<span class="line-removed">544     event.set_message(msg);</span>
<span class="line-removed">545     event.set_succeeded(success);</span>
<span class="line-removed">546     event.set_bci(bci);</span>
<span class="line-removed">547     event.set_caller(caller-&gt;get_Method());</span>
<span class="line-removed">548     event.set_callee(callee_struct);</span>
<span class="line-removed">549     event.commit();</span>
<span class="line-removed">550   }</span>
<span class="line-removed">551 }</span>
<span class="line-removed">552 </span>
553 //------------------------------print_inlining---------------------------------
554 void InlineTree::print_inlining(ciMethod* callee_method, int caller_bci,
555                                 ciMethod* caller_method, bool success) const {
556   const char* inline_msg = msg();
557   assert(inline_msg != NULL, &quot;just checking&quot;);
558   if (C-&gt;log() != NULL) {
559     if (success) {
560       C-&gt;log()-&gt;inline_success(inline_msg);
561     } else {
562       C-&gt;log()-&gt;inline_fail(inline_msg);
563     }
564   }
565   CompileTask::print_inlining_ul(callee_method, inline_level(),
566                                                caller_bci, inline_msg);
567   if (C-&gt;print_inlining()) {
568     C-&gt;print_inlining(callee_method, inline_level(), caller_bci, inline_msg);
<span class="line-modified">569     guarantee(callee_method != NULL, &quot;would crash in post_inlining_event&quot;);</span>
570     if (Verbose) {
571       const InlineTree *top = this;
572       while (top-&gt;caller_tree() != NULL) { top = top-&gt;caller_tree(); }
573       //tty-&gt;print(&quot;  bcs: %d+%d  invoked: %d&quot;, top-&gt;count_inline_bcs(), callee_method-&gt;code_size(), callee_method-&gt;interpreter_invocation_count());
574     }
575   }
<span class="line-modified">576   post_inlining_event(C-&gt;compile_id(), inline_msg, success, caller_bci, caller_method, callee_method);</span>



577 }
578 
579 //------------------------------ok_to_inline-----------------------------------
580 WarmCallInfo* InlineTree::ok_to_inline(ciMethod* callee_method, JVMState* jvms, ciCallProfile&amp; profile, WarmCallInfo* initial_wci, bool&amp; should_delay) {
581   assert(callee_method != NULL, &quot;caller checks for optimized virtual!&quot;);
582   assert(!should_delay, &quot;should be initialized to false&quot;);
583 #ifdef ASSERT
584   // Make sure the incoming jvms has the same information content as me.
585   // This means that we can eventually make this whole class AllStatic.
586   if (jvms-&gt;caller() == NULL) {
587     assert(_caller_jvms == NULL, &quot;redundant instance state&quot;);
588   } else {
589     assert(_caller_jvms-&gt;same_calls_as(jvms-&gt;caller()), &quot;redundant instance state&quot;);
590   }
591   assert(_method == jvms-&gt;method(), &quot;redundant instance state&quot;);
592 #endif
593   int         caller_bci    = jvms-&gt;bci();
594   ciMethod*   caller_method = jvms-&gt;method();
595 
596   // Do some initial checks.
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;ci/ciReplay.hpp&quot;
 27 #include &quot;classfile/systemDictionary.hpp&quot;
 28 #include &quot;classfile/vmSymbols.hpp&quot;
 29 #include &quot;compiler/compileBroker.hpp&quot;
<span class="line-added"> 30 #include &quot;compiler/compilerEvent.hpp&quot;</span>
 31 #include &quot;compiler/compileLog.hpp&quot;
 32 #include &quot;interpreter/linkResolver.hpp&quot;

 33 #include &quot;oops/objArrayKlass.hpp&quot;
 34 #include &quot;opto/callGenerator.hpp&quot;
 35 #include &quot;opto/parse.hpp&quot;
 36 #include &quot;runtime/handles.inline.hpp&quot;
 37 #include &quot;utilities/events.hpp&quot;
 38 
 39 //=============================================================================
 40 //------------------------------InlineTree-------------------------------------
 41 InlineTree::InlineTree(Compile* c,
 42                        const InlineTree *caller_tree, ciMethod* callee,
 43                        JVMState* caller_jvms, int caller_bci,
 44                        float site_invoke_ratio, int max_inline_level) :
 45   C(c),
 46   _caller_jvms(caller_jvms),
 47   _method(callee),
 48   _caller_tree((InlineTree*) caller_tree),
 49   _count_inline_bcs(method()-&gt;code_size_for_inlining()),
 50   _site_invoke_ratio(site_invoke_ratio),
 51   _max_inline_level(max_inline_level),
 52   _subtrees(c-&gt;comp_arena(), 2, 0, NULL),
</pre>
<hr />
<pre>
514       // Try to do constant pool resolution if running Xcomp
515       if( !caller_method-&gt;check_call(index, call_bc == Bytecodes::_invokestatic) ) {
516         return false;
517       }
518     }
519   }
520   return true;
521 }
522 
523 //------------------------------check_can_parse--------------------------------
524 const char* InlineTree::check_can_parse(ciMethod* callee) {
525   // Certain methods cannot be parsed at all:
526   if ( callee-&gt;is_native())                     return &quot;native method&quot;;
527   if ( callee-&gt;is_abstract())                   return &quot;abstract method&quot;;
528   if (!callee-&gt;has_balanced_monitors())         return &quot;not compilable (unbalanced monitors)&quot;;
529   if ( callee-&gt;get_flow_analysis()-&gt;failing())  return &quot;not compilable (flow analysis failed)&quot;;
530   if (!callee-&gt;can_be_parsed())                 return &quot;cannot be parsed&quot;;
531   return NULL;
532 }
533 



















534 //------------------------------print_inlining---------------------------------
535 void InlineTree::print_inlining(ciMethod* callee_method, int caller_bci,
536                                 ciMethod* caller_method, bool success) const {
537   const char* inline_msg = msg();
538   assert(inline_msg != NULL, &quot;just checking&quot;);
539   if (C-&gt;log() != NULL) {
540     if (success) {
541       C-&gt;log()-&gt;inline_success(inline_msg);
542     } else {
543       C-&gt;log()-&gt;inline_fail(inline_msg);
544     }
545   }
546   CompileTask::print_inlining_ul(callee_method, inline_level(),
547                                                caller_bci, inline_msg);
548   if (C-&gt;print_inlining()) {
549     C-&gt;print_inlining(callee_method, inline_level(), caller_bci, inline_msg);
<span class="line-modified">550     guarantee(callee_method != NULL, &quot;would crash in CompilerEvent::InlineEvent::post&quot;);</span>
551     if (Verbose) {
552       const InlineTree *top = this;
553       while (top-&gt;caller_tree() != NULL) { top = top-&gt;caller_tree(); }
554       //tty-&gt;print(&quot;  bcs: %d+%d  invoked: %d&quot;, top-&gt;count_inline_bcs(), callee_method-&gt;code_size(), callee_method-&gt;interpreter_invocation_count());
555     }
556   }
<span class="line-modified">557   EventCompilerInlining event;</span>
<span class="line-added">558   if (event.should_commit()) {</span>
<span class="line-added">559     CompilerEvent::InlineEvent::post(event, C-&gt;compile_id(), caller_method-&gt;get_Method(), callee_method, success, inline_msg, caller_bci);</span>
<span class="line-added">560   }</span>
561 }
562 
563 //------------------------------ok_to_inline-----------------------------------
564 WarmCallInfo* InlineTree::ok_to_inline(ciMethod* callee_method, JVMState* jvms, ciCallProfile&amp; profile, WarmCallInfo* initial_wci, bool&amp; should_delay) {
565   assert(callee_method != NULL, &quot;caller checks for optimized virtual!&quot;);
566   assert(!should_delay, &quot;should be initialized to false&quot;);
567 #ifdef ASSERT
568   // Make sure the incoming jvms has the same information content as me.
569   // This means that we can eventually make this whole class AllStatic.
570   if (jvms-&gt;caller() == NULL) {
571     assert(_caller_jvms == NULL, &quot;redundant instance state&quot;);
572   } else {
573     assert(_caller_jvms-&gt;same_calls_as(jvms-&gt;caller()), &quot;redundant instance state&quot;);
574   }
575   assert(_method == jvms-&gt;method(), &quot;redundant instance state&quot;);
576 #endif
577   int         caller_bci    = jvms-&gt;bci();
578   ciMethod*   caller_method = jvms-&gt;method();
579 
580   // Do some initial checks.
</pre>
</td>
</tr>
</table>
<center><a href="buildOopMap.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c2_globals.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
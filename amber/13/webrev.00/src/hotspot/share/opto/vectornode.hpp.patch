diff a/src/hotspot/share/opto/vectornode.hpp b/src/hotspot/share/opto/vectornode.hpp
--- a/src/hotspot/share/opto/vectornode.hpp
+++ b/src/hotspot/share/opto/vectornode.hpp
@@ -49,10 +49,18 @@
     init_req(1, n1);
     init_req(2, n2);
     init_req(3, n3);
   }
 
+  VectorNode(Node *n0, Node* n1, Node* n2, Node* n3, const TypeVect* vt) : TypeNode(vt, 5) {
+    init_class_id(Class_Vector);
+    init_req(1, n0);
+    init_req(2, n1);
+    init_req(3, n2);
+    init_req(4, n3);
+  }
+
   const TypeVect* vect_type() const { return type()->is_vect(); }
   uint length() const { return vect_type()->length(); } // Vector length
   uint length_in_bytes() const { return vect_type()->length_in_bytes(); }
 
   virtual int Opcode() const;
@@ -70,10 +78,13 @@
   static bool is_type_transition_short_to_int(Node* n);
   static bool is_type_transition_to_int(Node* n);
   static bool is_muladds2i(Node* n);
   static bool is_roundopD(Node * n);
   static bool is_invariant_vector(Node* n);
+  static bool is_all_ones_vector(Node* n);
+  static bool is_vector_bitwise_not_pattern(Node* n);
+
   // [Start, end) half-open range defining which operands are vectors
   static void vector_operands(Node* n, uint* start, uint* end);
 
   static bool is_vector_shift(int opc);
   static bool is_vector_shift_count(int opc);
@@ -143,10 +154,19 @@
   ReductionNode(Node *ctrl, Node* in1, Node* in2) : Node(ctrl, in1, in2) {}
 
   static ReductionNode* make(int opc, Node *ctrl, Node* in1, Node* in2, BasicType bt);
   static int  opcode(int opc, BasicType bt);
   static bool implemented(int opc, uint vlen, BasicType bt);
+
+  virtual const Type* bottom_type() const {
+    BasicType vbt = in(2)->bottom_type()->is_vect()->element_basic_type();
+    return Type::get_const_basic_type(vbt);
+  }
+
+  virtual uint ideal_reg() const {
+    return bottom_type()->ideal_reg();
+  }
 };
 
 //------------------------------AddReductionVINode--------------------------------------
 // Vector add int as a reduction
 class AddReductionVINode : public ReductionNode {
@@ -611,10 +631,34 @@
  public:
   XorVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
   virtual int Opcode() const;
 };
 
+//------------------------------AndReductionVNode--------------------------------------
+// Vector and int, long as a reduction
+class AndReductionVNode : public ReductionNode {
+public:
+  AndReductionVNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
+  virtual int Opcode() const;
+};
+
+//------------------------------OrReductionVNode--------------------------------------
+// Vector or int, long as a reduction
+class OrReductionVNode : public ReductionNode {
+public:
+  OrReductionVNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
+  virtual int Opcode() const;
+};
+
+//------------------------------XorReductionVNode--------------------------------------
+// Vector xor int, long as a reduction
+class XorReductionVNode : public ReductionNode {
+public:
+  XorReductionVNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
+  virtual int Opcode() const;
+};
+
 //------------------------------MinVNode--------------------------------------
 // Vector min
 class MinVNode : public VectorNode {
 public:
   MinVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}
@@ -633,58 +677,18 @@
 // Vector min as a reduction
 class MinReductionVNode : public ReductionNode {
 public:
   MinReductionVNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
   virtual int Opcode() const;
-  virtual const Type* bottom_type() const {
-    BasicType bt = in(1)->bottom_type()->basic_type();
-    if (bt == T_FLOAT) {
-      return Type::FLOAT;
-    } else if (bt == T_DOUBLE) {
-      return Type::DOUBLE;
-    }
-    assert(false, "unsupported basic type");
-    return NULL;
-  }
-  virtual uint ideal_reg() const {
-    BasicType bt = in(1)->bottom_type()->basic_type();
-    if (bt == T_FLOAT) {
-      return Op_RegF;
-    } else if (bt == T_DOUBLE) {
-      return Op_RegD;
-    }
-    assert(false, "unsupported basic type");
-    return 0;
-  }
 };
 
 //------------------------------MaxReductionVNode--------------------------------------
 // Vector max as a reduction
 class MaxReductionVNode : public ReductionNode {
 public:
   MaxReductionVNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
   virtual int Opcode() const;
-  virtual const Type* bottom_type() const {
-    BasicType bt = in(1)->bottom_type()->basic_type();
-    if (bt == T_FLOAT) {
-      return Type::FLOAT;
-    } else {
-      return Type::DOUBLE;
-    }
-    assert(false, "unsupported basic type");
-    return NULL;
-  }
-  virtual uint ideal_reg() const {
-    BasicType bt = in(1)->bottom_type()->basic_type();
-    if (bt == T_FLOAT) {
-      return Op_RegF;
-    } else {
-      return Op_RegD;
-    }
-    assert(false, "unsupported basic type");
-    return 0;
-  }
 };
 
 //================================= M E M O R Y ===============================
 
 //------------------------------LoadVectorNode---------------------------------
@@ -987,6 +991,19 @@
   const Type *bottom_type() const { return TypeInt::INT; }
   virtual uint ideal_reg() const { return Op_RegI; }
   virtual const Type *Value(PhaseGVN *phase) const { return TypeInt::INT; }
 };
 
+//------------------------------MacroLogicVNode-------------------------------
+// Vector logical operations packing node.
+class MacroLogicVNode : public VectorNode {
+private:
+  MacroLogicVNode(Node* in1, Node* in2, Node* in3, Node* fn, const TypeVect* vt)
+  : VectorNode(in1, in2, in3, fn, vt) {}
+
+public:
+  virtual int Opcode() const;
+
+  static MacroLogicVNode* make(PhaseGVN& igvn, Node* in1, Node* in2, Node* in3, uint truth_table, const TypeVect* vt);
+};
+
 #endif // SHARE_OPTO_VECTORNODE_HPP

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/opto/vectornode.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2007, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 #ifndef SHARE_OPTO_VECTORNODE_HPP
  25 #define SHARE_OPTO_VECTORNODE_HPP
  26 
  27 #include &quot;opto/matcher.hpp&quot;
  28 #include &quot;opto/memnode.hpp&quot;
  29 #include &quot;opto/node.hpp&quot;
  30 #include &quot;opto/opcodes.hpp&quot;
  31 
  32 //------------------------------VectorNode-------------------------------------
  33 // Vector Operation
  34 class VectorNode : public TypeNode {
  35  public:
  36 
  37   VectorNode(Node* n1, const TypeVect* vt) : TypeNode(vt, 2) {
  38     init_class_id(Class_Vector);
  39     init_req(1, n1);
  40   }
  41   VectorNode(Node* n1, Node* n2, const TypeVect* vt) : TypeNode(vt, 3) {
  42     init_class_id(Class_Vector);
  43     init_req(1, n1);
  44     init_req(2, n2);
  45   }
  46 
  47   VectorNode(Node* n1, Node* n2, Node* n3, const TypeVect* vt) : TypeNode(vt, 4) {
  48     init_class_id(Class_Vector);
  49     init_req(1, n1);
  50     init_req(2, n2);
  51     init_req(3, n3);
  52   }
  53 
  54   VectorNode(Node *n0, Node* n1, Node* n2, Node* n3, const TypeVect* vt) : TypeNode(vt, 5) {
  55     init_class_id(Class_Vector);
  56     init_req(1, n0);
  57     init_req(2, n1);
  58     init_req(3, n2);
  59     init_req(4, n3);
  60   }
  61 
  62   const TypeVect* vect_type() const { return type()-&gt;is_vect(); }
  63   uint length() const { return vect_type()-&gt;length(); } // Vector length
  64   uint length_in_bytes() const { return vect_type()-&gt;length_in_bytes(); }
  65 
  66   virtual int Opcode() const;
  67 
  68   virtual uint ideal_reg() const { return Matcher::vector_ideal_reg(vect_type()-&gt;length_in_bytes()); }
  69 
  70   static VectorNode* scalar2vector(Node* s, uint vlen, const Type* opd_t);
  71   static VectorNode* shift_count(Node* shift, Node* cnt, uint vlen, BasicType bt);
  72   static VectorNode* make(int opc, Node* n1, Node* n2, uint vlen, BasicType bt);
  73   static VectorNode* make(int opc, Node* n1, Node* n2, Node* n3, uint vlen, BasicType bt);
  74 
  75   static int  opcode(int opc, BasicType bt);
  76   static bool implemented(int opc, uint vlen, BasicType bt);
  77   static bool is_shift(Node* n);
  78   static bool is_type_transition_short_to_int(Node* n);
  79   static bool is_type_transition_to_int(Node* n);
  80   static bool is_muladds2i(Node* n);
  81   static bool is_roundopD(Node * n);
  82   static bool is_invariant_vector(Node* n);
  83   static bool is_all_ones_vector(Node* n);
  84   static bool is_vector_bitwise_not_pattern(Node* n);
  85 
  86   // [Start, end) half-open range defining which operands are vectors
  87   static void vector_operands(Node* n, uint* start, uint* end);
  88 
  89   static bool is_vector_shift(int opc);
  90   static bool is_vector_shift_count(int opc);
  91 
  92   static bool is_vector_shift(Node* n) {
  93     return is_vector_shift(n-&gt;Opcode());
  94   }
  95   static bool is_vector_shift_count(Node* n) {
  96     return is_vector_shift_count(n-&gt;Opcode());
  97   }
  98 };
  99 
 100 //===========================Vector=ALU=Operations=============================
 101 
 102 //------------------------------AddVBNode--------------------------------------
 103 // Vector add byte
 104 class AddVBNode : public VectorNode {
 105  public:
 106   AddVBNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
 107   virtual int Opcode() const;
 108 };
 109 
 110 //------------------------------AddVSNode--------------------------------------
 111 // Vector add char/short
 112 class AddVSNode : public VectorNode {
 113  public:
 114   AddVSNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
 115   virtual int Opcode() const;
 116 };
 117 
 118 //------------------------------AddVINode--------------------------------------
 119 // Vector add int
 120 class AddVINode : public VectorNode {
 121  public:
 122   AddVINode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
 123   virtual int Opcode() const;
 124 };
 125 
 126 //------------------------------AddVLNode--------------------------------------
 127 // Vector add long
 128 class AddVLNode : public VectorNode {
 129 public:
 130   AddVLNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}
 131   virtual int Opcode() const;
 132 };
 133 
 134 //------------------------------AddVFNode--------------------------------------
 135 // Vector add float
 136 class AddVFNode : public VectorNode {
 137 public:
 138   AddVFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}
 139   virtual int Opcode() const;
 140 };
 141 
 142 //------------------------------AddVDNode--------------------------------------
 143 // Vector add double
 144 class AddVDNode : public VectorNode {
 145 public:
 146   AddVDNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}
 147   virtual int Opcode() const;
 148 };
 149 
 150 //------------------------------ReductionNode------------------------------------
 151 // Perform reduction of a vector
 152 class ReductionNode : public Node {
 153  public:
 154   ReductionNode(Node *ctrl, Node* in1, Node* in2) : Node(ctrl, in1, in2) {}
 155 
 156   static ReductionNode* make(int opc, Node *ctrl, Node* in1, Node* in2, BasicType bt);
 157   static int  opcode(int opc, BasicType bt);
 158   static bool implemented(int opc, uint vlen, BasicType bt);
 159 
 160   virtual const Type* bottom_type() const {
 161     BasicType vbt = in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;element_basic_type();
 162     return Type::get_const_basic_type(vbt);
 163   }
 164 
 165   virtual uint ideal_reg() const {
 166     return bottom_type()-&gt;ideal_reg();
 167   }
 168 };
 169 
 170 //------------------------------AddReductionVINode--------------------------------------
 171 // Vector add int as a reduction
 172 class AddReductionVINode : public ReductionNode {
 173 public:
 174   AddReductionVINode(Node * ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
 175   virtual int Opcode() const;
 176   virtual const Type* bottom_type() const { return TypeInt::INT; }
 177   virtual uint ideal_reg() const { return Op_RegI; }
 178 };
 179 
 180 //------------------------------AddReductionVLNode--------------------------------------
 181 // Vector add long as a reduction
 182 class AddReductionVLNode : public ReductionNode {
 183 public:
 184   AddReductionVLNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
 185   virtual int Opcode() const;
 186   virtual const Type* bottom_type() const { return TypeLong::LONG; }
 187   virtual uint ideal_reg() const { return Op_RegL; }
 188 };
 189 
 190 //------------------------------AddReductionVFNode--------------------------------------
 191 // Vector add float as a reduction
 192 class AddReductionVFNode : public ReductionNode {
 193 public:
 194   AddReductionVFNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
 195   virtual int Opcode() const;
 196   virtual const Type* bottom_type() const { return Type::FLOAT; }
 197   virtual uint ideal_reg() const { return Op_RegF; }
 198 };
 199 
 200 //------------------------------AddReductionVDNode--------------------------------------
 201 // Vector add double as a reduction
 202 class AddReductionVDNode : public ReductionNode {
 203 public:
 204   AddReductionVDNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
 205   virtual int Opcode() const;
 206   virtual const Type* bottom_type() const { return Type::DOUBLE; }
 207   virtual uint ideal_reg() const { return Op_RegD; }
 208 };
 209 
 210 //------------------------------SubVBNode--------------------------------------
 211 // Vector subtract byte
 212 class SubVBNode : public VectorNode {
 213  public:
 214   SubVBNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
 215   virtual int Opcode() const;
 216 };
 217 
 218 //------------------------------SubVSNode--------------------------------------
 219 // Vector subtract short
 220 class SubVSNode : public VectorNode {
 221  public:
 222   SubVSNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
 223   virtual int Opcode() const;
 224 };
 225 
 226 //------------------------------SubVINode--------------------------------------
 227 // Vector subtract int
 228 class SubVINode : public VectorNode {
 229  public:
 230   SubVINode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
 231   virtual int Opcode() const;
 232 };
 233 
 234 //------------------------------SubVLNode--------------------------------------
 235 // Vector subtract long
 236 class SubVLNode : public VectorNode {
 237  public:
 238   SubVLNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
 239   virtual int Opcode() const;
 240 };
 241 
 242 //------------------------------SubVFNode--------------------------------------
 243 // Vector subtract float
 244 class SubVFNode : public VectorNode {
 245  public:
 246   SubVFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
 247   virtual int Opcode() const;
 248 };
 249 
 250 //------------------------------SubVDNode--------------------------------------
 251 // Vector subtract double
 252 class SubVDNode : public VectorNode {
 253  public:
 254   SubVDNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
 255   virtual int Opcode() const;
 256 };
 257 
 258 //------------------------------MulVBNode--------------------------------------
 259 // Vector multiply byte
 260 class MulVBNode : public VectorNode {
 261  public:
 262   MulVBNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}
 263   virtual int Opcode() const;
 264 };
 265 
 266 //------------------------------MulVSNode--------------------------------------
 267 // Vector multiply short
 268 class MulVSNode : public VectorNode {
 269  public:
 270   MulVSNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
 271   virtual int Opcode() const;
 272 };
 273 
 274 //------------------------------MulVINode--------------------------------------
 275 // Vector multiply int
 276 class MulVINode : public VectorNode {
 277  public:
 278   MulVINode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
 279   virtual int Opcode() const;
 280 };
 281 
 282 //------------------------------MulVLNode--------------------------------------
 283 // Vector multiply long
 284 class MulVLNode : public VectorNode {
 285 public:
 286   MulVLNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}
 287   virtual int Opcode() const;
 288 };
 289 
 290 //------------------------------MulVFNode--------------------------------------
 291 // Vector multiply float
 292 class MulVFNode : public VectorNode {
 293 public:
 294   MulVFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}
 295   virtual int Opcode() const;
 296 };
 297 
 298 //------------------------------MulVDNode--------------------------------------
 299 // Vector multiply double
 300 class MulVDNode : public VectorNode {
 301 public:
 302   MulVDNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}
 303   virtual int Opcode() const;
 304 };
 305 
 306 //------------------------------MulAddVS2VINode--------------------------------
 307 // Vector multiply shorts to int and add adjacent ints.
 308 class MulAddVS2VINode : public VectorNode {
 309   public:
 310     MulAddVS2VINode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}
 311     virtual int Opcode() const;
 312 };
 313 
 314 //------------------------------FmaVDNode--------------------------------------
 315 // Vector multiply double
 316 class FmaVDNode : public VectorNode {
 317 public:
 318   FmaVDNode(Node* in1, Node* in2, Node* in3, const TypeVect* vt) : VectorNode(in1, in2, in3, vt) {}
 319   virtual int Opcode() const;
 320 };
 321 
 322 //------------------------------FmaVFNode--------------------------------------
 323 // Vector multiply float
 324 class FmaVFNode : public VectorNode {
 325 public:
 326   FmaVFNode(Node* in1, Node* in2, Node* in3, const TypeVect* vt) : VectorNode(in1, in2, in3, vt) {}
 327   virtual int Opcode() const;
 328 };
 329 
 330 //------------------------------CMoveVFNode--------------------------------------
 331 // Vector float conditional move
 332 class CMoveVFNode : public VectorNode {
 333 public:
 334   CMoveVFNode(Node* in1, Node* in2, Node* in3, const TypeVect* vt) : VectorNode(in1, in2, in3, vt) {}
 335   virtual int Opcode() const;
 336 };
 337 
 338 //------------------------------CMoveVDNode--------------------------------------
 339 // Vector double conditional move
 340 class CMoveVDNode : public VectorNode {
 341 public:
 342   CMoveVDNode(Node* in1, Node* in2, Node* in3, const TypeVect* vt) : VectorNode(in1, in2, in3, vt) {}
 343   virtual int Opcode() const;
 344 };
 345 
 346 //------------------------------MulReductionVINode--------------------------------------
 347 // Vector multiply int as a reduction
 348 class MulReductionVINode : public ReductionNode {
 349 public:
 350   MulReductionVINode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
 351   virtual int Opcode() const;
 352   virtual const Type* bottom_type() const { return TypeInt::INT; }
 353   virtual uint ideal_reg() const { return Op_RegI; }
 354 };
 355 
 356 //------------------------------MulReductionVLNode--------------------------------------
 357 // Vector multiply int as a reduction
 358 class MulReductionVLNode : public ReductionNode {
 359 public:
 360   MulReductionVLNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
 361   virtual int Opcode() const;
 362   virtual const Type* bottom_type() const { return TypeLong::LONG; }
 363   virtual uint ideal_reg() const { return Op_RegI; }
 364 };
 365 
 366 //------------------------------MulReductionVFNode--------------------------------------
 367 // Vector multiply float as a reduction
 368 class MulReductionVFNode : public ReductionNode {
 369 public:
 370   MulReductionVFNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
 371   virtual int Opcode() const;
 372   virtual const Type* bottom_type() const { return Type::FLOAT; }
 373   virtual uint ideal_reg() const { return Op_RegF; }
 374 };
 375 
 376 //------------------------------MulReductionVDNode--------------------------------------
 377 // Vector multiply double as a reduction
 378 class MulReductionVDNode : public ReductionNode {
 379 public:
 380   MulReductionVDNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
 381   virtual int Opcode() const;
 382   virtual const Type* bottom_type() const { return Type::DOUBLE; }
 383   virtual uint ideal_reg() const { return Op_RegD; }
 384 };
 385 
 386 //------------------------------DivVFNode--------------------------------------
 387 // Vector divide float
 388 class DivVFNode : public VectorNode {
 389  public:
 390   DivVFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
 391   virtual int Opcode() const;
 392 };
 393 
 394 //------------------------------DivVDNode--------------------------------------
 395 // Vector Divide double
 396 class DivVDNode : public VectorNode {
 397  public:
 398   DivVDNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
 399   virtual int Opcode() const;
 400 };
 401 
 402 //------------------------------AbsVBNode--------------------------------------
 403 // Vector Abs byte
 404 class AbsVBNode : public VectorNode {
 405 public:
 406   AbsVBNode(Node* in, const TypeVect* vt) : VectorNode(in, vt) {}
 407   virtual int Opcode() const;
 408 };
 409 
 410 //------------------------------AbsVSNode--------------------------------------
 411 // Vector Abs short
 412 class AbsVSNode : public VectorNode {
 413 public:
 414   AbsVSNode(Node* in, const TypeVect* vt) : VectorNode(in, vt) {}
 415   virtual int Opcode() const;
 416 };
 417 
 418 //------------------------------AbsVINode--------------------------------------
 419 // Vector Abs int
 420 class AbsVINode : public VectorNode {
 421 public:
 422   AbsVINode(Node* in, const TypeVect* vt) : VectorNode(in, vt) {}
 423   virtual int Opcode() const;
 424 };
 425 
 426 //------------------------------AbsVLNode--------------------------------------
 427 // Vector Abs long
 428 class AbsVLNode : public VectorNode {
 429 public:
 430   AbsVLNode(Node* in, const TypeVect* vt) : VectorNode(in, vt) {}
 431   virtual int Opcode() const;
 432 };
 433 
 434 //------------------------------AbsVFNode--------------------------------------
 435 // Vector Abs float
 436 class AbsVFNode : public VectorNode {
 437  public:
 438   AbsVFNode(Node* in, const TypeVect* vt) : VectorNode(in,vt) {}
 439   virtual int Opcode() const;
 440 };
 441 
 442 //------------------------------AbsVDNode--------------------------------------
 443 // Vector Abs double
 444 class AbsVDNode : public VectorNode {
 445  public:
 446   AbsVDNode(Node* in, const TypeVect* vt) : VectorNode(in,vt) {}
 447   virtual int Opcode() const;
 448 };
 449 
 450 //------------------------------NegVFNode--------------------------------------
 451 // Vector Neg float
 452 class NegVFNode : public VectorNode {
 453  public:
 454   NegVFNode(Node* in, const TypeVect* vt) : VectorNode(in,vt) {}
 455   virtual int Opcode() const;
 456 };
 457 
 458 //------------------------------NegVDNode--------------------------------------
 459 // Vector Neg double
 460 class NegVDNode : public VectorNode {
 461  public:
 462   NegVDNode(Node* in, const TypeVect* vt) : VectorNode(in,vt) {}
 463   virtual int Opcode() const;
 464 };
 465 
 466 //------------------------------PopCountVINode---------------------------------
 467 // Vector popcount integer bits
 468 class PopCountVINode : public VectorNode {
 469  public:
 470   PopCountVINode(Node* in, const TypeVect* vt) : VectorNode(in,vt) {}
 471   virtual int Opcode() const;
 472 };
 473 
 474 //------------------------------SqrtVFNode--------------------------------------
 475 // Vector Sqrt float
 476 class SqrtVFNode : public VectorNode {
 477  public:
 478   SqrtVFNode(Node* in, const TypeVect* vt) : VectorNode(in,vt) {}
 479   virtual int Opcode() const;
 480 };
 481 //------------------------------RoundDoubleVNode--------------------------------
 482 // Vector round double
 483 class RoundDoubleModeVNode : public VectorNode {
 484  public:
 485   RoundDoubleModeVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}
 486   virtual int Opcode() const;
 487 };
 488 
 489 //------------------------------SqrtVDNode--------------------------------------
 490 // Vector Sqrt double
 491 class SqrtVDNode : public VectorNode {
 492  public:
 493   SqrtVDNode(Node* in, const TypeVect* vt) : VectorNode(in,vt) {}
 494   virtual int Opcode() const;
 495 };
 496 
 497 //------------------------------LShiftVBNode-----------------------------------
 498 // Vector left shift bytes
 499 class LShiftVBNode : public VectorNode {
 500  public:
 501   LShiftVBNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
 502   virtual int Opcode() const;
 503 };
 504 
 505 //------------------------------LShiftVSNode-----------------------------------
 506 // Vector left shift shorts
 507 class LShiftVSNode : public VectorNode {
 508  public:
 509   LShiftVSNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
 510   virtual int Opcode() const;
 511 };
 512 
 513 //------------------------------LShiftVINode-----------------------------------
 514 // Vector left shift ints
 515 class LShiftVINode : public VectorNode {
 516  public:
 517   LShiftVINode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
 518   virtual int Opcode() const;
 519 };
 520 
 521 //------------------------------LShiftVLNode-----------------------------------
 522 // Vector left shift longs
 523 class LShiftVLNode : public VectorNode {
 524  public:
 525   LShiftVLNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
 526   virtual int Opcode() const;
 527 };
 528 
 529 //------------------------------RShiftVBNode-----------------------------------
 530 // Vector right arithmetic (signed) shift bytes
 531 class RShiftVBNode : public VectorNode {
 532  public:
 533   RShiftVBNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
 534   virtual int Opcode() const;
 535 };
 536 
 537 //------------------------------RShiftVSNode-----------------------------------
 538 // Vector right arithmetic (signed) shift shorts
 539 class RShiftVSNode : public VectorNode {
 540  public:
 541   RShiftVSNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
 542   virtual int Opcode() const;
 543 };
 544 
 545 //------------------------------RShiftVINode-----------------------------------
 546 // Vector right arithmetic (signed) shift ints
 547 class RShiftVINode : public VectorNode {
 548  public:
 549   RShiftVINode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
 550   virtual int Opcode() const;
 551 };
 552 
 553 //------------------------------RShiftVLNode-----------------------------------
 554 // Vector right arithmetic (signed) shift longs
 555 class RShiftVLNode : public VectorNode {
 556  public:
 557   RShiftVLNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
 558   virtual int Opcode() const;
 559 };
 560 
 561 //------------------------------URShiftVBNode----------------------------------
 562 // Vector right logical (unsigned) shift bytes
 563 class URShiftVBNode : public VectorNode {
 564  public:
 565   URShiftVBNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
 566   virtual int Opcode() const;
 567 };
 568 
 569 //------------------------------URShiftVSNode----------------------------------
 570 // Vector right logical (unsigned) shift shorts
 571 class URShiftVSNode : public VectorNode {
 572  public:
 573   URShiftVSNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
 574   virtual int Opcode() const;
 575 };
 576 
 577 //------------------------------URShiftVINode----------------------------------
 578 // Vector right logical (unsigned) shift ints
 579 class URShiftVINode : public VectorNode {
 580  public:
 581   URShiftVINode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
 582   virtual int Opcode() const;
 583 };
 584 
 585 //------------------------------URShiftVLNode----------------------------------
 586 // Vector right logical (unsigned) shift longs
 587 class URShiftVLNode : public VectorNode {
 588  public:
 589   URShiftVLNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
 590   virtual int Opcode() const;
 591 };
 592 
 593 //------------------------------LShiftCntVNode---------------------------------
 594 // Vector left shift count
 595 class LShiftCntVNode : public VectorNode {
 596  public:
 597   LShiftCntVNode(Node* cnt, const TypeVect* vt) : VectorNode(cnt,vt) {}
 598   virtual int Opcode() const;
 599   virtual uint ideal_reg() const { return Matcher::vector_shift_count_ideal_reg(vect_type()-&gt;length_in_bytes()); }
 600 };
 601 
 602 //------------------------------RShiftCntVNode---------------------------------
 603 // Vector right shift count
 604 class RShiftCntVNode : public VectorNode {
 605  public:
 606   RShiftCntVNode(Node* cnt, const TypeVect* vt) : VectorNode(cnt,vt) {}
 607   virtual int Opcode() const;
 608   virtual uint ideal_reg() const { return Matcher::vector_shift_count_ideal_reg(vect_type()-&gt;length_in_bytes()); }
 609 };
 610 
 611 
 612 //------------------------------AndVNode---------------------------------------
 613 // Vector and integer
 614 class AndVNode : public VectorNode {
 615  public:
 616   AndVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
 617   virtual int Opcode() const;
 618 };
 619 
 620 //------------------------------OrVNode---------------------------------------
 621 // Vector or integer
 622 class OrVNode : public VectorNode {
 623  public:
 624   OrVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
 625   virtual int Opcode() const;
 626 };
 627 
 628 //------------------------------XorVNode---------------------------------------
 629 // Vector xor integer
 630 class XorVNode : public VectorNode {
 631  public:
 632   XorVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
 633   virtual int Opcode() const;
 634 };
 635 
 636 //------------------------------AndReductionVNode--------------------------------------
 637 // Vector and int, long as a reduction
 638 class AndReductionVNode : public ReductionNode {
 639 public:
 640   AndReductionVNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
 641   virtual int Opcode() const;
 642 };
 643 
 644 //------------------------------OrReductionVNode--------------------------------------
 645 // Vector or int, long as a reduction
 646 class OrReductionVNode : public ReductionNode {
 647 public:
 648   OrReductionVNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
 649   virtual int Opcode() const;
 650 };
 651 
 652 //------------------------------XorReductionVNode--------------------------------------
 653 // Vector xor int, long as a reduction
 654 class XorReductionVNode : public ReductionNode {
 655 public:
 656   XorReductionVNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
 657   virtual int Opcode() const;
 658 };
 659 
 660 //------------------------------MinVNode--------------------------------------
 661 // Vector min
 662 class MinVNode : public VectorNode {
 663 public:
 664   MinVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}
 665   virtual int Opcode() const;
 666 };
 667 
 668 //------------------------------MaxVNode--------------------------------------
 669 // Vector max
 670 class MaxVNode : public VectorNode {
 671 public:
 672   MaxVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}
 673   virtual int Opcode() const;
 674 };
 675 
 676 //------------------------------MinReductionVNode--------------------------------------
 677 // Vector min as a reduction
 678 class MinReductionVNode : public ReductionNode {
 679 public:
 680   MinReductionVNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
 681   virtual int Opcode() const;
 682 };
 683 
 684 //------------------------------MaxReductionVNode--------------------------------------
 685 // Vector max as a reduction
 686 class MaxReductionVNode : public ReductionNode {
 687 public:
 688   MaxReductionVNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
 689   virtual int Opcode() const;
 690 };
 691 
 692 //================================= M E M O R Y ===============================
 693 
 694 //------------------------------LoadVectorNode---------------------------------
 695 // Load Vector from memory
 696 class LoadVectorNode : public LoadNode {
 697  public:
 698   LoadVectorNode(Node* c, Node* mem, Node* adr, const TypePtr* at, const TypeVect* vt, ControlDependency control_dependency = LoadNode::DependsOnlyOnTest)
 699     : LoadNode(c, mem, adr, at, vt, MemNode::unordered, control_dependency) {
 700     init_class_id(Class_LoadVector);
 701     set_mismatched_access();
 702   }
 703 
 704   const TypeVect* vect_type() const { return type()-&gt;is_vect(); }
 705   uint length() const { return vect_type()-&gt;length(); } // Vector length
 706 
 707   virtual int Opcode() const;
 708 
 709   virtual uint ideal_reg() const  { return Matcher::vector_ideal_reg(memory_size()); }
 710   virtual BasicType memory_type() const { return T_VOID; }
 711   virtual int memory_size() const { return vect_type()-&gt;length_in_bytes(); }
 712 
 713   virtual int store_Opcode() const { return Op_StoreVector; }
 714 
 715   static LoadVectorNode* make(int opc, Node* ctl, Node* mem,
 716                               Node* adr, const TypePtr* atyp,
 717                               uint vlen, BasicType bt,
 718                               ControlDependency control_dependency = LoadNode::DependsOnlyOnTest);
 719   uint element_size(void) { return type2aelembytes(vect_type()-&gt;element_basic_type()); }
 720 };
 721 
 722 //------------------------------StoreVectorNode--------------------------------
 723 // Store Vector to memory
 724 class StoreVectorNode : public StoreNode {
 725  public:
 726   StoreVectorNode(Node* c, Node* mem, Node* adr, const TypePtr* at, Node* val)
 727     : StoreNode(c, mem, adr, at, val, MemNode::unordered) {
 728     assert(val-&gt;is_Vector() || val-&gt;is_LoadVector(), &quot;sanity&quot;);
 729     init_class_id(Class_StoreVector);
 730     set_mismatched_access();
 731   }
 732 
 733   const TypeVect* vect_type() const { return in(MemNode::ValueIn)-&gt;bottom_type()-&gt;is_vect(); }
 734   uint length() const { return vect_type()-&gt;length(); } // Vector length
 735 
 736   virtual int Opcode() const;
 737 
 738   virtual uint ideal_reg() const  { return Matcher::vector_ideal_reg(memory_size()); }
 739   virtual BasicType memory_type() const { return T_VOID; }
 740   virtual int memory_size() const { return vect_type()-&gt;length_in_bytes(); }
 741 
 742   static StoreVectorNode* make(int opc, Node* ctl, Node* mem,
 743                                Node* adr, const TypePtr* atyp, Node* val,
 744                                uint vlen);
 745 
 746   uint element_size(void) { return type2aelembytes(vect_type()-&gt;element_basic_type()); }
 747 };
 748 
 749 
 750 //=========================Promote_Scalar_to_Vector============================
 751 
 752 //------------------------------ReplicateBNode---------------------------------
 753 // Replicate byte scalar to be vector
 754 class ReplicateBNode : public VectorNode {
 755  public:
 756   ReplicateBNode(Node* in1, const TypeVect* vt) : VectorNode(in1, vt) {}
 757   virtual int Opcode() const;
 758 };
 759 
 760 //------------------------------ReplicateSNode---------------------------------
 761 // Replicate short scalar to be vector
 762 class ReplicateSNode : public VectorNode {
 763  public:
 764   ReplicateSNode(Node* in1, const TypeVect* vt) : VectorNode(in1, vt) {}
 765   virtual int Opcode() const;
 766 };
 767 
 768 //------------------------------ReplicateINode---------------------------------
 769 // Replicate int scalar to be vector
 770 class ReplicateINode : public VectorNode {
 771  public:
 772   ReplicateINode(Node* in1, const TypeVect* vt) : VectorNode(in1, vt) {}
 773   virtual int Opcode() const;
 774 };
 775 
 776 //------------------------------ReplicateLNode---------------------------------
 777 // Replicate long scalar to be vector
 778 class ReplicateLNode : public VectorNode {
 779  public:
 780   ReplicateLNode(Node* in1, const TypeVect* vt) : VectorNode(in1, vt) {}
 781   virtual int Opcode() const;
 782 };
 783 
 784 //------------------------------ReplicateFNode---------------------------------
 785 // Replicate float scalar to be vector
 786 class ReplicateFNode : public VectorNode {
 787  public:
 788   ReplicateFNode(Node* in1, const TypeVect* vt) : VectorNode(in1, vt) {}
 789   virtual int Opcode() const;
 790 };
 791 
 792 //------------------------------ReplicateDNode---------------------------------
 793 // Replicate double scalar to be vector
 794 class ReplicateDNode : public VectorNode {
 795  public:
 796   ReplicateDNode(Node* in1, const TypeVect* vt) : VectorNode(in1, vt) {}
 797   virtual int Opcode() const;
 798 };
 799 
 800 //========================Pack_Scalars_into_a_Vector===========================
 801 
 802 //------------------------------PackNode---------------------------------------
 803 // Pack parent class (not for code generation).
 804 class PackNode : public VectorNode {
 805  public:
 806   PackNode(Node* in1, const TypeVect* vt) : VectorNode(in1, vt) {}
 807   PackNode(Node* in1, Node* n2, const TypeVect* vt) : VectorNode(in1, n2, vt) {}
 808   virtual int Opcode() const;
 809 
 810   void add_opd(Node* n) {
 811     add_req(n);
 812   }
 813 
 814   // Create a binary tree form for Packs. [lo, hi) (half-open) range
 815   PackNode* binary_tree_pack(int lo, int hi);
 816 
 817   static PackNode* make(Node* s, uint vlen, BasicType bt);
 818 };
 819 
 820 //------------------------------PackBNode--------------------------------------
 821 // Pack byte scalars into vector
 822 class PackBNode : public PackNode {
 823  public:
 824   PackBNode(Node* in1, const TypeVect* vt)  : PackNode(in1, vt) {}
 825   virtual int Opcode() const;
 826 };
 827 
 828 //------------------------------PackSNode--------------------------------------
 829 // Pack short scalars into a vector
 830 class PackSNode : public PackNode {
 831  public:
 832   PackSNode(Node* in1, const TypeVect* vt)  : PackNode(in1, vt) {}
 833   PackSNode(Node* in1, Node* in2, const TypeVect* vt) : PackNode(in1, in2, vt) {}
 834   virtual int Opcode() const;
 835 };
 836 
 837 //------------------------------PackINode--------------------------------------
 838 // Pack integer scalars into a vector
 839 class PackINode : public PackNode {
 840  public:
 841   PackINode(Node* in1, const TypeVect* vt)  : PackNode(in1, vt) {}
 842   PackINode(Node* in1, Node* in2, const TypeVect* vt) : PackNode(in1, in2, vt) {}
 843   virtual int Opcode() const;
 844 };
 845 
 846 //------------------------------PackLNode--------------------------------------
 847 // Pack long scalars into a vector
 848 class PackLNode : public PackNode {
 849  public:
 850   PackLNode(Node* in1, const TypeVect* vt)  : PackNode(in1, vt) {}
 851   PackLNode(Node* in1, Node* in2, const TypeVect* vt) : PackNode(in1, in2, vt) {}
 852   virtual int Opcode() const;
 853 };
 854 
 855 //------------------------------Pack2LNode-------------------------------------
 856 // Pack 2 long scalars into a vector
 857 class Pack2LNode : public PackNode {
 858  public:
 859   Pack2LNode(Node* in1, Node* in2, const TypeVect* vt) : PackNode(in1, in2, vt) {}
 860   virtual int Opcode() const;
 861 };
 862 
 863 //------------------------------PackFNode--------------------------------------
 864 // Pack float scalars into vector
 865 class PackFNode : public PackNode {
 866  public:
 867   PackFNode(Node* in1, const TypeVect* vt)  : PackNode(in1, vt) {}
 868   PackFNode(Node* in1, Node* in2, const TypeVect* vt) : PackNode(in1, in2, vt) {}
 869   virtual int Opcode() const;
 870 };
 871 
 872 //------------------------------PackDNode--------------------------------------
 873 // Pack double scalars into a vector
 874 class PackDNode : public PackNode {
 875  public:
 876   PackDNode(Node* in1, const TypeVect* vt) : PackNode(in1, vt) {}
 877   PackDNode(Node* in1, Node* in2, const TypeVect* vt) : PackNode(in1, in2, vt) {}
 878   virtual int Opcode() const;
 879 };
 880 
 881 //------------------------------Pack2DNode-------------------------------------
 882 // Pack 2 double scalars into a vector
 883 class Pack2DNode : public PackNode {
 884  public:
 885   Pack2DNode(Node* in1, Node* in2, const TypeVect* vt) : PackNode(in1, in2, vt) {}
 886   virtual int Opcode() const;
 887 };
 888 
 889 
 890 //========================Extract_Scalar_from_Vector===========================
 891 
 892 //------------------------------ExtractNode------------------------------------
 893 // Extract a scalar from a vector at position &quot;pos&quot;
 894 class ExtractNode : public Node {
 895  public:
 896   ExtractNode(Node* src, ConINode* pos) : Node(NULL, src, (Node*)pos) {
 897     assert(in(2)-&gt;get_int() &gt;= 0, &quot;positive constants&quot;);
 898   }
 899   virtual int Opcode() const;
 900   uint  pos() const { return in(2)-&gt;get_int(); }
 901 
 902   static Node* make(Node* v, uint position, BasicType bt);
 903 };
 904 
 905 //------------------------------ExtractBNode-----------------------------------
 906 // Extract a byte from a vector at position &quot;pos&quot;
 907 class ExtractBNode : public ExtractNode {
 908  public:
 909   ExtractBNode(Node* src, ConINode* pos) : ExtractNode(src, pos) {}
 910   virtual int Opcode() const;
 911   virtual const Type *bottom_type() const { return TypeInt::INT; }
 912   virtual uint ideal_reg() const { return Op_RegI; }
 913 };
 914 
 915 //------------------------------ExtractUBNode----------------------------------
 916 // Extract a boolean from a vector at position &quot;pos&quot;
 917 class ExtractUBNode : public ExtractNode {
 918  public:
 919   ExtractUBNode(Node* src, ConINode* pos) : ExtractNode(src, pos) {}
 920   virtual int Opcode() const;
 921   virtual const Type *bottom_type() const { return TypeInt::INT; }
 922   virtual uint ideal_reg() const { return Op_RegI; }
 923 };
 924 
 925 //------------------------------ExtractCNode-----------------------------------
 926 // Extract a char from a vector at position &quot;pos&quot;
 927 class ExtractCNode : public ExtractNode {
 928  public:
 929   ExtractCNode(Node* src, ConINode* pos) : ExtractNode(src, pos) {}
 930   virtual int Opcode() const;
 931   virtual const Type *bottom_type() const { return TypeInt::INT; }
 932   virtual uint ideal_reg() const { return Op_RegI; }
 933 };
 934 
 935 //------------------------------ExtractSNode-----------------------------------
 936 // Extract a short from a vector at position &quot;pos&quot;
 937 class ExtractSNode : public ExtractNode {
 938  public:
 939   ExtractSNode(Node* src, ConINode* pos) : ExtractNode(src, pos) {}
 940   virtual int Opcode() const;
 941   virtual const Type *bottom_type() const { return TypeInt::INT; }
 942   virtual uint ideal_reg() const { return Op_RegI; }
 943 };
 944 
 945 //------------------------------ExtractINode-----------------------------------
 946 // Extract an int from a vector at position &quot;pos&quot;
 947 class ExtractINode : public ExtractNode {
 948  public:
 949   ExtractINode(Node* src, ConINode* pos) : ExtractNode(src, pos) {}
 950   virtual int Opcode() const;
 951   virtual const Type *bottom_type() const { return TypeInt::INT; }
 952   virtual uint ideal_reg() const { return Op_RegI; }
 953 };
 954 
 955 //------------------------------ExtractLNode-----------------------------------
 956 // Extract a long from a vector at position &quot;pos&quot;
 957 class ExtractLNode : public ExtractNode {
 958  public:
 959   ExtractLNode(Node* src, ConINode* pos) : ExtractNode(src, pos) {}
 960   virtual int Opcode() const;
 961   virtual const Type *bottom_type() const { return TypeLong::LONG; }
 962   virtual uint ideal_reg() const { return Op_RegL; }
 963 };
 964 
 965 //------------------------------ExtractFNode-----------------------------------
 966 // Extract a float from a vector at position &quot;pos&quot;
 967 class ExtractFNode : public ExtractNode {
 968  public:
 969   ExtractFNode(Node* src, ConINode* pos) : ExtractNode(src, pos) {}
 970   virtual int Opcode() const;
 971   virtual const Type *bottom_type() const { return Type::FLOAT; }
 972   virtual uint ideal_reg() const { return Op_RegF; }
 973 };
 974 
 975 //------------------------------ExtractDNode-----------------------------------
 976 // Extract a double from a vector at position &quot;pos&quot;
 977 class ExtractDNode : public ExtractNode {
 978  public:
 979   ExtractDNode(Node* src, ConINode* pos) : ExtractNode(src, pos) {}
 980   virtual int Opcode() const;
 981   virtual const Type *bottom_type() const { return Type::DOUBLE; }
 982   virtual uint ideal_reg() const { return Op_RegD; }
 983 };
 984 
 985 //------------------------------SetVectMaskINode-------------------------------
 986 // Provide a mask for a vector predicate machine
 987 class SetVectMaskINode : public Node {
 988 public:
 989   SetVectMaskINode(Node *c, Node *in1) : Node(c, in1) {}
 990   virtual int Opcode() const;
 991   const Type *bottom_type() const { return TypeInt::INT; }
 992   virtual uint ideal_reg() const { return Op_RegI; }
 993   virtual const Type *Value(PhaseGVN *phase) const { return TypeInt::INT; }
 994 };
 995 
 996 //------------------------------MacroLogicVNode-------------------------------
 997 // Vector logical operations packing node.
 998 class MacroLogicVNode : public VectorNode {
 999 private:
1000   MacroLogicVNode(Node* in1, Node* in2, Node* in3, Node* fn, const TypeVect* vt)
1001   : VectorNode(in1, in2, in3, fn, vt) {}
1002 
1003 public:
1004   virtual int Opcode() const;
1005 
1006   static MacroLogicVNode* make(PhaseGVN&amp; igvn, Node* in1, Node* in2, Node* in3, uint truth_table, const TypeVect* vt);
1007 };
1008 
1009 #endif // SHARE_OPTO_VECTORNODE_HPP
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/asm/codeBuffer.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="assembler.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../c1/c1_GraphBuilder.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/asm/codeBuffer.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
183 
184   void    set_end(address pc)       { assert(allocates2(pc), &quot;not in CodeBuffer memory: &quot; INTPTR_FORMAT &quot; &lt;= &quot; INTPTR_FORMAT &quot; &lt;= &quot; INTPTR_FORMAT, p2i(_start), p2i(pc), p2i(_limit)); _end = pc; }
185   void    set_mark(address pc)      { assert(contains2(pc), &quot;not in codeBuffer&quot;);
186                                       _mark = pc; }
187   void    set_mark_off(int offset)  { assert(contains2(offset+_start),&quot;not in codeBuffer&quot;);
188                                       _mark = offset + _start; }
189   void    set_mark()                { _mark = _end; }
190   void    clear_mark()              { _mark = NULL; }
191 
192   void    set_locs_end(relocInfo* p) {
193     assert(p &lt;= locs_limit(), &quot;locs data fits in allocated buffer&quot;);
194     _locs_end = p;
195   }
196   void    set_locs_point(address pc) {
197     assert(pc &gt;= locs_point(), &quot;relocation addr may not decrease&quot;);
198     assert(allocates2(pc),     &quot;relocation addr must be in this section&quot;);
199     _locs_point = pc;
200   }
201 
202   // Code emission
<span class="line-modified">203   void emit_int8 ( int8_t  x)  { *((int8_t*)  end()) = x; set_end(end() + sizeof(int8_t)); }</span>
<span class="line-modified">204   void emit_int16( int16_t x)  { *((int16_t*) end()) = x; set_end(end() + sizeof(int16_t)); }</span>
<span class="line-modified">205   void emit_int32( int32_t x)  { *((int32_t*) end()) = x; set_end(end() + sizeof(int32_t)); }</span>





























206   void emit_int64( int64_t x)  { *((int64_t*) end()) = x; set_end(end() + sizeof(int64_t)); }
207 
208   void emit_float( jfloat  x)  { *((jfloat*)  end()) = x; set_end(end() + sizeof(jfloat)); }
209   void emit_double(jdouble x)  { *((jdouble*) end()) = x; set_end(end() + sizeof(jdouble)); }
210   void emit_address(address x) { *((address*) end()) = x; set_end(end() + sizeof(address)); }
211 
212   // Share a scratch buffer for relocinfo.  (Hacky; saves a resource allocation.)
213   void initialize_shared_locs(relocInfo* buf, int length);
214 
215   // Manage labels and their addresses.
216   address target(Label&amp; L, address branch_pc);
217 
218   // Emit a relocation.
219   void relocate(address at, RelocationHolder const&amp; rspec, int format = 0);
220   void relocate(address at,    relocInfo::relocType rtype, int format = 0, jint method_index = 0);
221 
222   // alignment requirement for starting offset
223   // Requirements are that the instruction area and the
224   // stubs area must start on CodeEntryAlignment, and
225   // the ctable on sizeof(jdouble)
</pre>
</td>
<td>
<hr />
<pre>
183 
184   void    set_end(address pc)       { assert(allocates2(pc), &quot;not in CodeBuffer memory: &quot; INTPTR_FORMAT &quot; &lt;= &quot; INTPTR_FORMAT &quot; &lt;= &quot; INTPTR_FORMAT, p2i(_start), p2i(pc), p2i(_limit)); _end = pc; }
185   void    set_mark(address pc)      { assert(contains2(pc), &quot;not in codeBuffer&quot;);
186                                       _mark = pc; }
187   void    set_mark_off(int offset)  { assert(contains2(offset+_start),&quot;not in codeBuffer&quot;);
188                                       _mark = offset + _start; }
189   void    set_mark()                { _mark = _end; }
190   void    clear_mark()              { _mark = NULL; }
191 
192   void    set_locs_end(relocInfo* p) {
193     assert(p &lt;= locs_limit(), &quot;locs data fits in allocated buffer&quot;);
194     _locs_end = p;
195   }
196   void    set_locs_point(address pc) {
197     assert(pc &gt;= locs_point(), &quot;relocation addr may not decrease&quot;);
198     assert(allocates2(pc),     &quot;relocation addr must be in this section&quot;);
199     _locs_point = pc;
200   }
201 
202   // Code emission
<span class="line-modified">203   void emit_int8(int8_t x1) {</span>
<span class="line-modified">204     address curr = end();</span>
<span class="line-modified">205     *((int8_t*)  curr++) = x1;</span>
<span class="line-added">206     set_end(curr);</span>
<span class="line-added">207   }</span>
<span class="line-added">208 </span>
<span class="line-added">209   void emit_int16(int16_t x) { *((int16_t*) end()) = x; set_end(end() + sizeof(int16_t)); }</span>
<span class="line-added">210   void emit_int16(int8_t x1, int8_t x2) {</span>
<span class="line-added">211     address curr = end();</span>
<span class="line-added">212     *((int8_t*)  curr++) = x1;</span>
<span class="line-added">213     *((int8_t*)  curr++) = x2;</span>
<span class="line-added">214     set_end(curr);</span>
<span class="line-added">215   }</span>
<span class="line-added">216 </span>
<span class="line-added">217   void emit_int24(int8_t x1, int8_t x2, int8_t x3)  {</span>
<span class="line-added">218     address curr = end();</span>
<span class="line-added">219     *((int8_t*)  curr++) = x1;</span>
<span class="line-added">220     *((int8_t*)  curr++) = x2;</span>
<span class="line-added">221     *((int8_t*)  curr++) = x3;</span>
<span class="line-added">222     set_end(curr);</span>
<span class="line-added">223   }</span>
<span class="line-added">224 </span>
<span class="line-added">225   void emit_int32(int32_t x) { *((int32_t*) end()) = x; set_end(end() + sizeof(int32_t)); }</span>
<span class="line-added">226   void emit_int32(int8_t x1, int8_t x2, int8_t x3, int8_t x4)  {</span>
<span class="line-added">227     address curr = end();</span>
<span class="line-added">228     *((int8_t*)  curr++) = x1;</span>
<span class="line-added">229     *((int8_t*)  curr++) = x2;</span>
<span class="line-added">230     *((int8_t*)  curr++) = x3;</span>
<span class="line-added">231     *((int8_t*)  curr++) = x4;</span>
<span class="line-added">232     set_end(curr);</span>
<span class="line-added">233   }</span>
<span class="line-added">234 </span>
235   void emit_int64( int64_t x)  { *((int64_t*) end()) = x; set_end(end() + sizeof(int64_t)); }
236 
237   void emit_float( jfloat  x)  { *((jfloat*)  end()) = x; set_end(end() + sizeof(jfloat)); }
238   void emit_double(jdouble x)  { *((jdouble*) end()) = x; set_end(end() + sizeof(jdouble)); }
239   void emit_address(address x) { *((address*) end()) = x; set_end(end() + sizeof(address)); }
240 
241   // Share a scratch buffer for relocinfo.  (Hacky; saves a resource allocation.)
242   void initialize_shared_locs(relocInfo* buf, int length);
243 
244   // Manage labels and their addresses.
245   address target(Label&amp; L, address branch_pc);
246 
247   // Emit a relocation.
248   void relocate(address at, RelocationHolder const&amp; rspec, int format = 0);
249   void relocate(address at,    relocInfo::relocType rtype, int format = 0, jint method_index = 0);
250 
251   // alignment requirement for starting offset
252   // Requirements are that the instruction area and the
253   // stubs area must start on CodeEntryAlignment, and
254   // the ctable on sizeof(jdouble)
</pre>
</td>
</tr>
</table>
<center><a href="assembler.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../c1/c1_GraphBuilder.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
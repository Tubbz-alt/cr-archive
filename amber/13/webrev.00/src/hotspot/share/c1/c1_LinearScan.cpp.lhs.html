<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/c1/c1_LinearScan.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;c1/c1_CFGPrinter.hpp&quot;
  27 #include &quot;c1/c1_CodeStubs.hpp&quot;
  28 #include &quot;c1/c1_Compilation.hpp&quot;
  29 #include &quot;c1/c1_FrameMap.hpp&quot;
  30 #include &quot;c1/c1_IR.hpp&quot;
  31 #include &quot;c1/c1_LIRGenerator.hpp&quot;
  32 #include &quot;c1/c1_LinearScan.hpp&quot;
  33 #include &quot;c1/c1_ValueStack.hpp&quot;
  34 #include &quot;code/vmreg.inline.hpp&quot;
  35 #include &quot;runtime/timerTrace.hpp&quot;
  36 #include &quot;utilities/bitMap.inline.hpp&quot;
  37 
  38 #ifndef PRODUCT
  39 
  40   static LinearScanStatistic _stat_before_alloc;
  41   static LinearScanStatistic _stat_after_asign;
  42   static LinearScanStatistic _stat_final;
  43 
  44   static LinearScanTimers _total_timer;
  45 
  46   // helper macro for short definition of timer
  47   #define TIME_LINEAR_SCAN(timer_name)  TraceTime _block_timer(&quot;&quot;, _total_timer.timer(LinearScanTimers::timer_name), TimeLinearScan || TimeEachLinearScan, Verbose);
  48 
  49   // helper macro for short definition of trace-output inside code
  50   #define TRACE_LINEAR_SCAN(level, code)       \
  51     if (TraceLinearScanLevel &gt;= level) {       \
  52       code;                                    \
  53     }
  54 
  55 #else
  56 
  57   #define TIME_LINEAR_SCAN(timer_name)
  58   #define TRACE_LINEAR_SCAN(level, code)
  59 
  60 #endif
  61 
  62 // Map BasicType to spill size in 32-bit words, matching VMReg&#39;s notion of words
  63 #ifdef _LP64
  64 static int type2spill_size[T_CONFLICT+1]={ -1, 0, 0, 0, 1, 1, 1, 2, 1, 1, 1, 2, 2, 2, 0, 2,  1, 2, 1, -1};
  65 #else
  66 static int type2spill_size[T_CONFLICT+1]={ -1, 0, 0, 0, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 0, 1, -1, 1, 1, -1};
  67 #endif
  68 
  69 
  70 // Implementation of LinearScan
  71 
  72 LinearScan::LinearScan(IR* ir, LIRGenerator* gen, FrameMap* frame_map)
  73  : _compilation(ir-&gt;compilation())
  74  , _ir(ir)
  75  , _gen(gen)
  76  , _frame_map(frame_map)
  77  , _cached_blocks(*ir-&gt;linear_scan_order())
  78  , _num_virtual_regs(gen-&gt;max_virtual_register_number())
  79  , _has_fpu_registers(false)
  80  , _num_calls(-1)
  81  , _max_spills(0)
  82  , _unused_spill_slot(-1)
  83  , _intervals(0)   // initialized later with correct length
  84  , _new_intervals_from_allocation(NULL)
  85  , _sorted_intervals(NULL)
  86  , _needs_full_resort(false)
  87  , _lir_ops(0)     // initialized later with correct length
  88  , _block_of_op(0) // initialized later with correct length
  89  , _has_info(0)
  90  , _has_call(0)
  91  , _interval_in_loop(0)  // initialized later with correct length
  92  , _scope_value_cache(0) // initialized later with correct length
  93 #ifdef IA32
  94  , _fpu_stack_allocator(NULL)
  95 #endif
  96 {
  97   assert(this-&gt;ir() != NULL,          &quot;check if valid&quot;);
  98   assert(this-&gt;compilation() != NULL, &quot;check if valid&quot;);
  99   assert(this-&gt;gen() != NULL,         &quot;check if valid&quot;);
 100   assert(this-&gt;frame_map() != NULL,   &quot;check if valid&quot;);
 101 }
 102 
 103 
 104 // ********** functions for converting LIR-Operands to register numbers
 105 //
 106 // Emulate a flat register file comprising physical integer registers,
 107 // physical floating-point registers and virtual registers, in that order.
 108 // Virtual registers already have appropriate numbers, since V0 is
 109 // the number of physical registers.
 110 // Returns -1 for hi word if opr is a single word operand.
 111 //
 112 // Note: the inverse operation (calculating an operand for register numbers)
 113 //       is done in calc_operand_for_interval()
 114 
 115 int LinearScan::reg_num(LIR_Opr opr) {
 116   assert(opr-&gt;is_register(), &quot;should not call this otherwise&quot;);
 117 
 118   if (opr-&gt;is_virtual_register()) {
 119     assert(opr-&gt;vreg_number() &gt;= nof_regs, &quot;found a virtual register with a fixed-register number&quot;);
 120     return opr-&gt;vreg_number();
 121   } else if (opr-&gt;is_single_cpu()) {
 122     return opr-&gt;cpu_regnr();
 123   } else if (opr-&gt;is_double_cpu()) {
 124     return opr-&gt;cpu_regnrLo();
 125 #ifdef X86
 126   } else if (opr-&gt;is_single_xmm()) {
 127     return opr-&gt;fpu_regnr() + pd_first_xmm_reg;
 128   } else if (opr-&gt;is_double_xmm()) {
 129     return opr-&gt;fpu_regnrLo() + pd_first_xmm_reg;
 130 #endif
 131   } else if (opr-&gt;is_single_fpu()) {
 132     return opr-&gt;fpu_regnr() + pd_first_fpu_reg;
 133   } else if (opr-&gt;is_double_fpu()) {
 134     return opr-&gt;fpu_regnrLo() + pd_first_fpu_reg;
 135   } else {
 136     ShouldNotReachHere();
 137     return -1;
 138   }
 139 }
 140 
 141 int LinearScan::reg_numHi(LIR_Opr opr) {
 142   assert(opr-&gt;is_register(), &quot;should not call this otherwise&quot;);
 143 
 144   if (opr-&gt;is_virtual_register()) {
 145     return -1;
 146   } else if (opr-&gt;is_single_cpu()) {
 147     return -1;
 148   } else if (opr-&gt;is_double_cpu()) {
 149     return opr-&gt;cpu_regnrHi();
 150 #ifdef X86
 151   } else if (opr-&gt;is_single_xmm()) {
 152     return -1;
 153   } else if (opr-&gt;is_double_xmm()) {
 154     return -1;
 155 #endif
 156   } else if (opr-&gt;is_single_fpu()) {
 157     return -1;
 158   } else if (opr-&gt;is_double_fpu()) {
 159     return opr-&gt;fpu_regnrHi() + pd_first_fpu_reg;
 160   } else {
 161     ShouldNotReachHere();
 162     return -1;
 163   }
 164 }
 165 
 166 
 167 // ********** functions for classification of intervals
 168 
 169 bool LinearScan::is_precolored_interval(const Interval* i) {
 170   return i-&gt;reg_num() &lt; LinearScan::nof_regs;
 171 }
 172 
 173 bool LinearScan::is_virtual_interval(const Interval* i) {
 174   return i-&gt;reg_num() &gt;= LIR_OprDesc::vreg_base;
 175 }
 176 
 177 bool LinearScan::is_precolored_cpu_interval(const Interval* i) {
 178   return i-&gt;reg_num() &lt; LinearScan::nof_cpu_regs;
 179 }
 180 
 181 bool LinearScan::is_virtual_cpu_interval(const Interval* i) {
 182 #if defined(__SOFTFP__) || defined(E500V2)
 183   return i-&gt;reg_num() &gt;= LIR_OprDesc::vreg_base;
 184 #else
 185   return i-&gt;reg_num() &gt;= LIR_OprDesc::vreg_base &amp;&amp; (i-&gt;type() != T_FLOAT &amp;&amp; i-&gt;type() != T_DOUBLE);
 186 #endif // __SOFTFP__ or E500V2
 187 }
 188 
 189 bool LinearScan::is_precolored_fpu_interval(const Interval* i) {
 190   return i-&gt;reg_num() &gt;= LinearScan::nof_cpu_regs &amp;&amp; i-&gt;reg_num() &lt; LinearScan::nof_regs;
 191 }
 192 
 193 bool LinearScan::is_virtual_fpu_interval(const Interval* i) {
 194 #if defined(__SOFTFP__) || defined(E500V2)
 195   return false;
 196 #else
 197   return i-&gt;reg_num() &gt;= LIR_OprDesc::vreg_base &amp;&amp; (i-&gt;type() == T_FLOAT || i-&gt;type() == T_DOUBLE);
 198 #endif // __SOFTFP__ or E500V2
 199 }
 200 
 201 bool LinearScan::is_in_fpu_register(const Interval* i) {
 202   // fixed intervals not needed for FPU stack allocation
 203   return i-&gt;reg_num() &gt;= nof_regs &amp;&amp; pd_first_fpu_reg &lt;= i-&gt;assigned_reg() &amp;&amp; i-&gt;assigned_reg() &lt;= pd_last_fpu_reg;
 204 }
 205 
 206 bool LinearScan::is_oop_interval(const Interval* i) {
 207   // fixed intervals never contain oops
 208   return i-&gt;reg_num() &gt;= nof_regs &amp;&amp; i-&gt;type() == T_OBJECT;
 209 }
 210 
 211 
 212 // ********** General helper functions
 213 
 214 // compute next unused stack index that can be used for spilling
 215 int LinearScan::allocate_spill_slot(bool double_word) {
 216   int spill_slot;
 217   if (double_word) {
 218     if ((_max_spills &amp; 1) == 1) {
 219       // alignment of double-word values
 220       // the hole because of the alignment is filled with the next single-word value
 221       assert(_unused_spill_slot == -1, &quot;wasting a spill slot&quot;);
 222       _unused_spill_slot = _max_spills;
 223       _max_spills++;
 224     }
 225     spill_slot = _max_spills;
 226     _max_spills += 2;
 227 
 228   } else if (_unused_spill_slot != -1) {
 229     // re-use hole that was the result of a previous double-word alignment
 230     spill_slot = _unused_spill_slot;
 231     _unused_spill_slot = -1;
 232 
 233   } else {
 234     spill_slot = _max_spills;
 235     _max_spills++;
 236   }
 237 
 238   int result = spill_slot + LinearScan::nof_regs + frame_map()-&gt;argcount();
 239 
 240   // the class OopMapValue uses only 11 bits for storing the name of the
 241   // oop location. So a stack slot bigger than 2^11 leads to an overflow
 242   // that is not reported in product builds. Prevent this by checking the
 243   // spill slot here (altough this value and the later used location name
 244   // are slightly different)
 245   if (result &gt; 2000) {
 246     bailout(&quot;too many stack slots used&quot;);
 247   }
 248 
 249   return result;
 250 }
 251 
 252 void LinearScan::assign_spill_slot(Interval* it) {
 253   // assign the canonical spill slot of the parent (if a part of the interval
 254   // is already spilled) or allocate a new spill slot
 255   if (it-&gt;canonical_spill_slot() &gt;= 0) {
 256     it-&gt;assign_reg(it-&gt;canonical_spill_slot());
 257   } else {
 258     int spill = allocate_spill_slot(type2spill_size[it-&gt;type()] == 2);
 259     it-&gt;set_canonical_spill_slot(spill);
 260     it-&gt;assign_reg(spill);
 261   }
 262 }
 263 
 264 void LinearScan::propagate_spill_slots() {
 265   if (!frame_map()-&gt;finalize_frame(max_spills())) {
 266     bailout(&quot;frame too large&quot;);
 267   }
 268 }
 269 
 270 // create a new interval with a predefined reg_num
 271 // (only used for parent intervals that are created during the building phase)
 272 Interval* LinearScan::create_interval(int reg_num) {
 273   assert(_intervals.at(reg_num) == NULL, &quot;overwriting exisiting interval&quot;);
 274 
 275   Interval* interval = new Interval(reg_num);
 276   _intervals.at_put(reg_num, interval);
 277 
 278   // assign register number for precolored intervals
 279   if (reg_num &lt; LIR_OprDesc::vreg_base) {
 280     interval-&gt;assign_reg(reg_num);
 281   }
 282   return interval;
 283 }
 284 
 285 // assign a new reg_num to the interval and append it to the list of intervals
 286 // (only used for child intervals that are created during register allocation)
 287 void LinearScan::append_interval(Interval* it) {
 288   it-&gt;set_reg_num(_intervals.length());
 289   _intervals.append(it);
 290   IntervalList* new_intervals = _new_intervals_from_allocation;
 291   if (new_intervals == NULL) {
 292     new_intervals = _new_intervals_from_allocation = new IntervalList();
 293   }
 294   new_intervals-&gt;append(it);
 295 }
 296 
 297 // copy the vreg-flags if an interval is split
 298 void LinearScan::copy_register_flags(Interval* from, Interval* to) {
 299   if (gen()-&gt;is_vreg_flag_set(from-&gt;reg_num(), LIRGenerator::byte_reg)) {
 300     gen()-&gt;set_vreg_flag(to-&gt;reg_num(), LIRGenerator::byte_reg);
 301   }
 302   if (gen()-&gt;is_vreg_flag_set(from-&gt;reg_num(), LIRGenerator::callee_saved)) {
 303     gen()-&gt;set_vreg_flag(to-&gt;reg_num(), LIRGenerator::callee_saved);
 304   }
 305 
 306   // Note: do not copy the must_start_in_memory flag because it is not necessary for child
 307   //       intervals (only the very beginning of the interval must be in memory)
 308 }
 309 
 310 
 311 // ********** spill move optimization
 312 // eliminate moves from register to stack if stack slot is known to be correct
 313 
 314 // called during building of intervals
 315 void LinearScan::change_spill_definition_pos(Interval* interval, int def_pos) {
 316   assert(interval-&gt;is_split_parent(), &quot;can only be called for split parents&quot;);
 317 
 318   switch (interval-&gt;spill_state()) {
 319     case noDefinitionFound:
 320       assert(interval-&gt;spill_definition_pos() == -1, &quot;must no be set before&quot;);
 321       interval-&gt;set_spill_definition_pos(def_pos);
 322       interval-&gt;set_spill_state(oneDefinitionFound);
 323       break;
 324 
 325     case oneDefinitionFound:
 326       assert(def_pos &lt;= interval-&gt;spill_definition_pos(), &quot;positions are processed in reverse order when intervals are created&quot;);
 327       if (def_pos &lt; interval-&gt;spill_definition_pos() - 2) {
 328         // second definition found, so no spill optimization possible for this interval
 329         interval-&gt;set_spill_state(noOptimization);
 330       } else {
 331         // two consecutive definitions (because of two-operand LIR form)
 332         assert(block_of_op_with_id(def_pos) == block_of_op_with_id(interval-&gt;spill_definition_pos()), &quot;block must be equal&quot;);
 333       }
 334       break;
 335 
 336     case noOptimization:
 337       // nothing to do
 338       break;
 339 
 340     default:
 341       assert(false, &quot;other states not allowed at this time&quot;);
 342   }
 343 }
 344 
 345 // called during register allocation
 346 void LinearScan::change_spill_state(Interval* interval, int spill_pos) {
 347   switch (interval-&gt;spill_state()) {
 348     case oneDefinitionFound: {
 349       int def_loop_depth = block_of_op_with_id(interval-&gt;spill_definition_pos())-&gt;loop_depth();
 350       int spill_loop_depth = block_of_op_with_id(spill_pos)-&gt;loop_depth();
 351 
 352       if (def_loop_depth &lt; spill_loop_depth) {
 353         // the loop depth of the spilling position is higher then the loop depth
 354         // at the definition of the interval -&gt; move write to memory out of loop
 355         // by storing at definitin of the interval
 356         interval-&gt;set_spill_state(storeAtDefinition);
 357       } else {
 358         // the interval is currently spilled only once, so for now there is no
 359         // reason to store the interval at the definition
 360         interval-&gt;set_spill_state(oneMoveInserted);
 361       }
 362       break;
 363     }
 364 
 365     case oneMoveInserted: {
 366       // the interval is spilled more then once, so it is better to store it to
 367       // memory at the definition
 368       interval-&gt;set_spill_state(storeAtDefinition);
 369       break;
 370     }
 371 
 372     case storeAtDefinition:
 373     case startInMemory:
 374     case noOptimization:
 375     case noDefinitionFound:
 376       // nothing to do
 377       break;
 378 
 379     default:
 380       assert(false, &quot;other states not allowed at this time&quot;);
 381   }
 382 }
 383 
 384 
 385 bool LinearScan::must_store_at_definition(const Interval* i) {
 386   return i-&gt;is_split_parent() &amp;&amp; i-&gt;spill_state() == storeAtDefinition;
 387 }
 388 
 389 // called once before asignment of register numbers
 390 void LinearScan::eliminate_spill_moves() {
 391   TIME_LINEAR_SCAN(timer_eliminate_spill_moves);
 392   TRACE_LINEAR_SCAN(3, tty-&gt;print_cr(&quot;***** Eliminating unnecessary spill moves&quot;));
 393 
 394   // collect all intervals that must be stored after their definion.
 395   // the list is sorted by Interval::spill_definition_pos
 396   Interval* interval;
 397   Interval* temp_list;
 398   create_unhandled_lists(&amp;interval, &amp;temp_list, must_store_at_definition, NULL);
 399 
 400 #ifdef ASSERT
 401   Interval* prev = NULL;
 402   Interval* temp = interval;
 403   while (temp != Interval::end()) {
 404     assert(temp-&gt;spill_definition_pos() &gt; 0, &quot;invalid spill definition pos&quot;);
 405     if (prev != NULL) {
 406       assert(temp-&gt;from() &gt;= prev-&gt;from(), &quot;intervals not sorted&quot;);
 407       assert(temp-&gt;spill_definition_pos() &gt;= prev-&gt;spill_definition_pos(), &quot;when intervals are sorted by from, then they must also be sorted by spill_definition_pos&quot;);
 408     }
 409 
 410     assert(temp-&gt;canonical_spill_slot() &gt;= LinearScan::nof_regs, &quot;interval has no spill slot assigned&quot;);
 411     assert(temp-&gt;spill_definition_pos() &gt;= temp-&gt;from(), &quot;invalid order&quot;);
 412     assert(temp-&gt;spill_definition_pos() &lt;= temp-&gt;from() + 2, &quot;only intervals defined once at their start-pos can be optimized&quot;);
 413 
 414     TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;interval %d (from %d to %d) must be stored at %d&quot;, temp-&gt;reg_num(), temp-&gt;from(), temp-&gt;to(), temp-&gt;spill_definition_pos()));
 415 
 416     temp = temp-&gt;next();
 417   }
 418 #endif
 419 
 420   LIR_InsertionBuffer insertion_buffer;
 421   int num_blocks = block_count();
 422   for (int i = 0; i &lt; num_blocks; i++) {
 423     BlockBegin* block = block_at(i);
 424     LIR_OpList* instructions = block-&gt;lir()-&gt;instructions_list();
 425     int         num_inst = instructions-&gt;length();
 426     bool        has_new = false;
 427 
 428     // iterate all instructions of the block. skip the first because it is always a label
 429     for (int j = 1; j &lt; num_inst; j++) {
 430       LIR_Op* op = instructions-&gt;at(j);
 431       int op_id = op-&gt;id();
 432 
 433       if (op_id == -1) {
 434         // remove move from register to stack if the stack slot is guaranteed to be correct.
 435         // only moves that have been inserted by LinearScan can be removed.
 436         assert(op-&gt;code() == lir_move, &quot;only moves can have a op_id of -1&quot;);
 437         assert(op-&gt;as_Op1() != NULL, &quot;move must be LIR_Op1&quot;);
 438         assert(op-&gt;as_Op1()-&gt;result_opr()-&gt;is_virtual(), &quot;LinearScan inserts only moves to virtual registers&quot;);
 439 
 440         LIR_Op1* op1 = (LIR_Op1*)op;
 441         Interval* interval = interval_at(op1-&gt;result_opr()-&gt;vreg_number());
 442 
 443         if (interval-&gt;assigned_reg() &gt;= LinearScan::nof_regs &amp;&amp; interval-&gt;always_in_memory()) {
 444           // move target is a stack slot that is always correct, so eliminate instruction
 445           TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;eliminating move from interval %d to %d&quot;, op1-&gt;in_opr()-&gt;vreg_number(), op1-&gt;result_opr()-&gt;vreg_number()));
 446           instructions-&gt;at_put(j, NULL); // NULL-instructions are deleted by assign_reg_num
 447         }
 448 
 449       } else {
 450         // insert move from register to stack just after the beginning of the interval
 451         assert(interval == Interval::end() || interval-&gt;spill_definition_pos() &gt;= op_id, &quot;invalid order&quot;);
 452         assert(interval == Interval::end() || (interval-&gt;is_split_parent() &amp;&amp; interval-&gt;spill_state() == storeAtDefinition), &quot;invalid interval&quot;);
 453 
 454         while (interval != Interval::end() &amp;&amp; interval-&gt;spill_definition_pos() == op_id) {
 455           if (!has_new) {
 456             // prepare insertion buffer (appended when all instructions of the block are processed)
 457             insertion_buffer.init(block-&gt;lir());
 458             has_new = true;
 459           }
 460 
 461           LIR_Opr from_opr = operand_for_interval(interval);
 462           LIR_Opr to_opr = canonical_spill_opr(interval);
 463           assert(from_opr-&gt;is_fixed_cpu() || from_opr-&gt;is_fixed_fpu(), &quot;from operand must be a register&quot;);
 464           assert(to_opr-&gt;is_stack(), &quot;to operand must be a stack slot&quot;);
 465 
 466           insertion_buffer.move(j, from_opr, to_opr);
 467           TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;inserting move after definition of interval %d to stack slot %d at op_id %d&quot;, interval-&gt;reg_num(), interval-&gt;canonical_spill_slot() - LinearScan::nof_regs, op_id));
 468 
 469           interval = interval-&gt;next();
 470         }
 471       }
 472     } // end of instruction iteration
 473 
 474     if (has_new) {
 475       block-&gt;lir()-&gt;append(&amp;insertion_buffer);
 476     }
 477   } // end of block iteration
 478 
 479   assert(interval == Interval::end(), &quot;missed an interval&quot;);
 480 }
 481 
 482 
 483 // ********** Phase 1: number all instructions in all blocks
 484 // Compute depth-first and linear scan block orders, and number LIR_Op nodes for linear scan.
 485 
 486 void LinearScan::number_instructions() {
 487   {
 488     // dummy-timer to measure the cost of the timer itself
 489     // (this time is then subtracted from all other timers to get the real value)
 490     TIME_LINEAR_SCAN(timer_do_nothing);
 491   }
 492   TIME_LINEAR_SCAN(timer_number_instructions);
 493 
 494   // Assign IDs to LIR nodes and build a mapping, lir_ops, from ID to LIR_Op node.
 495   int num_blocks = block_count();
 496   int num_instructions = 0;
 497   int i;
 498   for (i = 0; i &lt; num_blocks; i++) {
 499     num_instructions += block_at(i)-&gt;lir()-&gt;instructions_list()-&gt;length();
 500   }
 501 
 502   // initialize with correct length
 503   _lir_ops = LIR_OpArray(num_instructions, num_instructions, NULL);
 504   _block_of_op = BlockBeginArray(num_instructions, num_instructions, NULL);
 505 
 506   int op_id = 0;
 507   int idx = 0;
 508 
 509   for (i = 0; i &lt; num_blocks; i++) {
 510     BlockBegin* block = block_at(i);
 511     block-&gt;set_first_lir_instruction_id(op_id);
 512     LIR_OpList* instructions = block-&gt;lir()-&gt;instructions_list();
 513 
 514     int num_inst = instructions-&gt;length();
 515     for (int j = 0; j &lt; num_inst; j++) {
 516       LIR_Op* op = instructions-&gt;at(j);
 517       op-&gt;set_id(op_id);
 518 
 519       _lir_ops.at_put(idx, op);
 520       _block_of_op.at_put(idx, block);
 521       assert(lir_op_with_id(op_id) == op, &quot;must match&quot;);
 522 
 523       idx++;
 524       op_id += 2; // numbering of lir_ops by two
 525     }
 526     block-&gt;set_last_lir_instruction_id(op_id - 2);
 527   }
 528   assert(idx == num_instructions, &quot;must match&quot;);
 529   assert(idx * 2 == op_id, &quot;must match&quot;);
 530 
 531   _has_call.initialize(num_instructions);
 532   _has_info.initialize(num_instructions);
 533 }
 534 
 535 
 536 // ********** Phase 2: compute local live sets separately for each block
 537 // (sets live_gen and live_kill for each block)
 538 
 539 void LinearScan::set_live_gen_kill(Value value, LIR_Op* op, BitMap&amp; live_gen, BitMap&amp; live_kill) {
 540   LIR_Opr opr = value-&gt;operand();
 541   Constant* con = value-&gt;as_Constant();
 542 
 543   // check some asumptions about debug information
 544   assert(!value-&gt;type()-&gt;is_illegal(), &quot;if this local is used by the interpreter it shouldn&#39;t be of indeterminate type&quot;);
 545   assert(con == NULL || opr-&gt;is_virtual() || opr-&gt;is_constant() || opr-&gt;is_illegal(), &quot;asumption: Constant instructions have only constant operands&quot;);
 546   assert(con != NULL || opr-&gt;is_virtual(), &quot;asumption: non-Constant instructions have only virtual operands&quot;);
 547 
 548   if ((con == NULL || con-&gt;is_pinned()) &amp;&amp; opr-&gt;is_register()) {
 549     assert(reg_num(opr) == opr-&gt;vreg_number() &amp;&amp; !is_valid_reg_num(reg_numHi(opr)), &quot;invalid optimization below&quot;);
 550     int reg = opr-&gt;vreg_number();
 551     if (!live_kill.at(reg)) {
 552       live_gen.set_bit(reg);
 553       TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;  Setting live_gen for value %c%d, LIR op_id %d, register number %d&quot;, value-&gt;type()-&gt;tchar(), value-&gt;id(), op-&gt;id(), reg));
 554     }
 555   }
 556 }
 557 
 558 
 559 void LinearScan::compute_local_live_sets() {
 560   TIME_LINEAR_SCAN(timer_compute_local_live_sets);
 561 
 562   int  num_blocks = block_count();
 563   int  live_size = live_set_size();
 564   bool local_has_fpu_registers = false;
 565   int  local_num_calls = 0;
 566   LIR_OpVisitState visitor;
 567 
 568   BitMap2D local_interval_in_loop = BitMap2D(_num_virtual_regs, num_loops());
 569 
 570   // iterate all blocks
 571   for (int i = 0; i &lt; num_blocks; i++) {
 572     BlockBegin* block = block_at(i);
 573 
 574     ResourceBitMap live_gen(live_size);
 575     ResourceBitMap live_kill(live_size);
 576 
 577     if (block-&gt;is_set(BlockBegin::exception_entry_flag)) {
 578       // Phi functions at the begin of an exception handler are
 579       // implicitly defined (= killed) at the beginning of the block.
 580       for_each_phi_fun(block, phi,
 581         if (!phi-&gt;is_illegal()) { live_kill.set_bit(phi-&gt;operand()-&gt;vreg_number()); }
 582       );
 583     }
 584 
 585     LIR_OpList* instructions = block-&gt;lir()-&gt;instructions_list();
 586     int num_inst = instructions-&gt;length();
 587 
 588     // iterate all instructions of the block. skip the first because it is always a label
 589     assert(visitor.no_operands(instructions-&gt;at(0)), &quot;first operation must always be a label&quot;);
 590     for (int j = 1; j &lt; num_inst; j++) {
 591       LIR_Op* op = instructions-&gt;at(j);
 592 
 593       // visit operation to collect all operands
 594       visitor.visit(op);
 595 
 596       if (visitor.has_call()) {
 597         _has_call.set_bit(op-&gt;id() &gt;&gt; 1);
 598         local_num_calls++;
 599       }
 600       if (visitor.info_count() &gt; 0) {
 601         _has_info.set_bit(op-&gt;id() &gt;&gt; 1);
 602       }
 603 
 604       // iterate input operands of instruction
 605       int k, n, reg;
 606       n = visitor.opr_count(LIR_OpVisitState::inputMode);
 607       for (k = 0; k &lt; n; k++) {
 608         LIR_Opr opr = visitor.opr_at(LIR_OpVisitState::inputMode, k);
 609         assert(opr-&gt;is_register(), &quot;visitor should only return register operands&quot;);
 610 
 611         if (opr-&gt;is_virtual_register()) {
 612           assert(reg_num(opr) == opr-&gt;vreg_number() &amp;&amp; !is_valid_reg_num(reg_numHi(opr)), &quot;invalid optimization below&quot;);
 613           reg = opr-&gt;vreg_number();
 614           if (!live_kill.at(reg)) {
 615             live_gen.set_bit(reg);
 616             TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;  Setting live_gen for register %d at instruction %d&quot;, reg, op-&gt;id()));
 617           }
 618           if (block-&gt;loop_index() &gt;= 0) {
 619             local_interval_in_loop.set_bit(reg, block-&gt;loop_index());
 620           }
 621           local_has_fpu_registers = local_has_fpu_registers || opr-&gt;is_virtual_fpu();
 622         }
 623 
 624 #ifdef ASSERT
 625         // fixed intervals are never live at block boundaries, so
 626         // they need not be processed in live sets.
 627         // this is checked by these assertions to be sure about it.
 628         // the entry block may have incoming values in registers, which is ok.
 629         if (!opr-&gt;is_virtual_register() &amp;&amp; block != ir()-&gt;start()) {
 630           reg = reg_num(opr);
 631           if (is_processed_reg_num(reg)) {
 632             assert(live_kill.at(reg), &quot;using fixed register that is not defined in this block&quot;);
 633           }
 634           reg = reg_numHi(opr);
 635           if (is_valid_reg_num(reg) &amp;&amp; is_processed_reg_num(reg)) {
 636             assert(live_kill.at(reg), &quot;using fixed register that is not defined in this block&quot;);
 637           }
 638         }
 639 #endif
 640       }
 641 
 642       // Add uses of live locals from interpreter&#39;s point of view for proper debug information generation
 643       n = visitor.info_count();
 644       for (k = 0; k &lt; n; k++) {
 645         CodeEmitInfo* info = visitor.info_at(k);
 646         ValueStack* stack = info-&gt;stack();
 647         for_each_state_value(stack, value,
 648           set_live_gen_kill(value, op, live_gen, live_kill)
 649         );
 650       }
 651 
 652       // iterate temp operands of instruction
 653       n = visitor.opr_count(LIR_OpVisitState::tempMode);
 654       for (k = 0; k &lt; n; k++) {
 655         LIR_Opr opr = visitor.opr_at(LIR_OpVisitState::tempMode, k);
 656         assert(opr-&gt;is_register(), &quot;visitor should only return register operands&quot;);
 657 
 658         if (opr-&gt;is_virtual_register()) {
 659           assert(reg_num(opr) == opr-&gt;vreg_number() &amp;&amp; !is_valid_reg_num(reg_numHi(opr)), &quot;invalid optimization below&quot;);
 660           reg = opr-&gt;vreg_number();
 661           live_kill.set_bit(reg);
 662           if (block-&gt;loop_index() &gt;= 0) {
 663             local_interval_in_loop.set_bit(reg, block-&gt;loop_index());
 664           }
 665           local_has_fpu_registers = local_has_fpu_registers || opr-&gt;is_virtual_fpu();
 666         }
 667 
 668 #ifdef ASSERT
 669         // fixed intervals are never live at block boundaries, so
 670         // they need not be processed in live sets
 671         // process them only in debug mode so that this can be checked
 672         if (!opr-&gt;is_virtual_register()) {
 673           reg = reg_num(opr);
 674           if (is_processed_reg_num(reg)) {
 675             live_kill.set_bit(reg_num(opr));
 676           }
 677           reg = reg_numHi(opr);
 678           if (is_valid_reg_num(reg) &amp;&amp; is_processed_reg_num(reg)) {
 679             live_kill.set_bit(reg);
 680           }
 681         }
 682 #endif
 683       }
 684 
 685       // iterate output operands of instruction
 686       n = visitor.opr_count(LIR_OpVisitState::outputMode);
 687       for (k = 0; k &lt; n; k++) {
 688         LIR_Opr opr = visitor.opr_at(LIR_OpVisitState::outputMode, k);
 689         assert(opr-&gt;is_register(), &quot;visitor should only return register operands&quot;);
 690 
 691         if (opr-&gt;is_virtual_register()) {
 692           assert(reg_num(opr) == opr-&gt;vreg_number() &amp;&amp; !is_valid_reg_num(reg_numHi(opr)), &quot;invalid optimization below&quot;);
 693           reg = opr-&gt;vreg_number();
 694           live_kill.set_bit(reg);
 695           if (block-&gt;loop_index() &gt;= 0) {
 696             local_interval_in_loop.set_bit(reg, block-&gt;loop_index());
 697           }
 698           local_has_fpu_registers = local_has_fpu_registers || opr-&gt;is_virtual_fpu();
 699         }
 700 
 701 #ifdef ASSERT
 702         // fixed intervals are never live at block boundaries, so
 703         // they need not be processed in live sets
 704         // process them only in debug mode so that this can be checked
 705         if (!opr-&gt;is_virtual_register()) {
 706           reg = reg_num(opr);
 707           if (is_processed_reg_num(reg)) {
 708             live_kill.set_bit(reg_num(opr));
 709           }
 710           reg = reg_numHi(opr);
 711           if (is_valid_reg_num(reg) &amp;&amp; is_processed_reg_num(reg)) {
 712             live_kill.set_bit(reg);
 713           }
 714         }
 715 #endif
 716       }
 717     } // end of instruction iteration
 718 
 719     block-&gt;set_live_gen (live_gen);
 720     block-&gt;set_live_kill(live_kill);
 721     block-&gt;set_live_in  (ResourceBitMap(live_size));
 722     block-&gt;set_live_out (ResourceBitMap(live_size));
 723 
 724     TRACE_LINEAR_SCAN(4, tty-&gt;print(&quot;live_gen  B%d &quot;, block-&gt;block_id()); print_bitmap(block-&gt;live_gen()));
 725     TRACE_LINEAR_SCAN(4, tty-&gt;print(&quot;live_kill B%d &quot;, block-&gt;block_id()); print_bitmap(block-&gt;live_kill()));
 726   } // end of block iteration
 727 
 728   // propagate local calculated information into LinearScan object
 729   _has_fpu_registers = local_has_fpu_registers;
 730   compilation()-&gt;set_has_fpu_code(local_has_fpu_registers);
 731 
 732   _num_calls = local_num_calls;
 733   _interval_in_loop = local_interval_in_loop;
 734 }
 735 
 736 
 737 // ********** Phase 3: perform a backward dataflow analysis to compute global live sets
 738 // (sets live_in and live_out for each block)
 739 
 740 void LinearScan::compute_global_live_sets() {
 741   TIME_LINEAR_SCAN(timer_compute_global_live_sets);
 742 
 743   int  num_blocks = block_count();
 744   bool change_occurred;
 745   bool change_occurred_in_block;
 746   int  iteration_count = 0;
 747   ResourceBitMap live_out(live_set_size()); // scratch set for calculations
 748 
 749   // Perform a backward dataflow analysis to compute live_out and live_in for each block.
 750   // The loop is executed until a fixpoint is reached (no changes in an iteration)
 751   // Exception handlers must be processed because not all live values are
 752   // present in the state array, e.g. because of global value numbering
 753   do {
 754     change_occurred = false;
 755 
 756     // iterate all blocks in reverse order
 757     for (int i = num_blocks - 1; i &gt;= 0; i--) {
 758       BlockBegin* block = block_at(i);
 759 
 760       change_occurred_in_block = false;
 761 
 762       // live_out(block) is the union of live_in(sux), for successors sux of block
 763       int n = block-&gt;number_of_sux();
 764       int e = block-&gt;number_of_exception_handlers();
 765       if (n + e &gt; 0) {
 766         // block has successors
 767         if (n &gt; 0) {
 768           live_out.set_from(block-&gt;sux_at(0)-&gt;live_in());
 769           for (int j = 1; j &lt; n; j++) {
 770             live_out.set_union(block-&gt;sux_at(j)-&gt;live_in());
 771           }
 772         } else {
 773           live_out.clear();
 774         }
 775         for (int j = 0; j &lt; e; j++) {
 776           live_out.set_union(block-&gt;exception_handler_at(j)-&gt;live_in());
 777         }
 778 
 779         if (!block-&gt;live_out().is_same(live_out)) {
 780           // A change occurred.  Swap the old and new live out sets to avoid copying.
 781           ResourceBitMap temp = block-&gt;live_out();
 782           block-&gt;set_live_out(live_out);
 783           live_out = temp;
 784 
 785           change_occurred = true;
 786           change_occurred_in_block = true;
 787         }
 788       }
 789 
 790       if (iteration_count == 0 || change_occurred_in_block) {
 791         // live_in(block) is the union of live_gen(block) with (live_out(block) &amp; !live_kill(block))
 792         // note: live_in has to be computed only in first iteration or if live_out has changed!
 793         ResourceBitMap live_in = block-&gt;live_in();
 794         live_in.set_from(block-&gt;live_out());
 795         live_in.set_difference(block-&gt;live_kill());
 796         live_in.set_union(block-&gt;live_gen());
 797       }
 798 
 799 #ifndef PRODUCT
 800       if (TraceLinearScanLevel &gt;= 4) {
 801         char c = &#39; &#39;;
 802         if (iteration_count == 0 || change_occurred_in_block) {
 803           c = &#39;*&#39;;
 804         }
 805         tty-&gt;print(&quot;(%d) live_in%c  B%d &quot;, iteration_count, c, block-&gt;block_id()); print_bitmap(block-&gt;live_in());
 806         tty-&gt;print(&quot;(%d) live_out%c B%d &quot;, iteration_count, c, block-&gt;block_id()); print_bitmap(block-&gt;live_out());
 807       }
 808 #endif
 809     }
 810     iteration_count++;
 811 
 812     if (change_occurred &amp;&amp; iteration_count &gt; 50) {
 813       BAILOUT(&quot;too many iterations in compute_global_live_sets&quot;);
 814     }
 815   } while (change_occurred);
 816 
 817 
 818 #ifdef ASSERT
 819   // check that fixed intervals are not live at block boundaries
 820   // (live set must be empty at fixed intervals)
 821   for (int i = 0; i &lt; num_blocks; i++) {
 822     BlockBegin* block = block_at(i);
 823     for (int j = 0; j &lt; LIR_OprDesc::vreg_base; j++) {
 824       assert(block-&gt;live_in().at(j)  == false, &quot;live_in  set of fixed register must be empty&quot;);
 825       assert(block-&gt;live_out().at(j) == false, &quot;live_out set of fixed register must be empty&quot;);
 826       assert(block-&gt;live_gen().at(j) == false, &quot;live_gen set of fixed register must be empty&quot;);
 827     }
 828   }
 829 #endif
 830 
 831   // check that the live_in set of the first block is empty
 832   ResourceBitMap live_in_args(ir()-&gt;start()-&gt;live_in().size());
 833   if (!ir()-&gt;start()-&gt;live_in().is_same(live_in_args)) {
 834 #ifdef ASSERT
 835     tty-&gt;print_cr(&quot;Error: live_in set of first block must be empty (when this fails, virtual registers are used before they are defined)&quot;);
 836     tty-&gt;print_cr(&quot;affected registers:&quot;);
 837     print_bitmap(ir()-&gt;start()-&gt;live_in());
 838 
 839     // print some additional information to simplify debugging
 840     for (unsigned int i = 0; i &lt; ir()-&gt;start()-&gt;live_in().size(); i++) {
 841       if (ir()-&gt;start()-&gt;live_in().at(i)) {
 842         Instruction* instr = gen()-&gt;instruction_for_vreg(i);
 843         tty-&gt;print_cr(&quot;* vreg %d (HIR instruction %c%d)&quot;, i, instr == NULL ? &#39; &#39; : instr-&gt;type()-&gt;tchar(), instr == NULL ? 0 : instr-&gt;id());
 844 
 845         for (int j = 0; j &lt; num_blocks; j++) {
 846           BlockBegin* block = block_at(j);
 847           if (block-&gt;live_gen().at(i)) {
 848             tty-&gt;print_cr(&quot;  used in block B%d&quot;, block-&gt;block_id());
 849           }
 850           if (block-&gt;live_kill().at(i)) {
 851             tty-&gt;print_cr(&quot;  defined in block B%d&quot;, block-&gt;block_id());
 852           }
 853         }
 854       }
 855     }
 856 
 857 #endif
 858     // when this fails, virtual registers are used before they are defined.
 859     assert(false, &quot;live_in set of first block must be empty&quot;);
 860     // bailout of if this occurs in product mode.
 861     bailout(&quot;live_in set of first block not empty&quot;);
 862   }
 863 }
 864 
 865 
 866 // ********** Phase 4: build intervals
 867 // (fills the list _intervals)
 868 
 869 void LinearScan::add_use(Value value, int from, int to, IntervalUseKind use_kind) {
 870   assert(!value-&gt;type()-&gt;is_illegal(), &quot;if this value is used by the interpreter it shouldn&#39;t be of indeterminate type&quot;);
 871   LIR_Opr opr = value-&gt;operand();
 872   Constant* con = value-&gt;as_Constant();
 873 
 874   if ((con == NULL || con-&gt;is_pinned()) &amp;&amp; opr-&gt;is_register()) {
 875     assert(reg_num(opr) == opr-&gt;vreg_number() &amp;&amp; !is_valid_reg_num(reg_numHi(opr)), &quot;invalid optimization below&quot;);
 876     add_use(opr, from, to, use_kind);
 877   }
 878 }
 879 
 880 
 881 void LinearScan::add_def(LIR_Opr opr, int def_pos, IntervalUseKind use_kind) {
 882   TRACE_LINEAR_SCAN(2, tty-&gt;print(&quot; def &quot;); opr-&gt;print(tty); tty-&gt;print_cr(&quot; def_pos %d (%d)&quot;, def_pos, use_kind));
 883   assert(opr-&gt;is_register(), &quot;should not be called otherwise&quot;);
 884 
 885   if (opr-&gt;is_virtual_register()) {
 886     assert(reg_num(opr) == opr-&gt;vreg_number() &amp;&amp; !is_valid_reg_num(reg_numHi(opr)), &quot;invalid optimization below&quot;);
 887     add_def(opr-&gt;vreg_number(), def_pos, use_kind, opr-&gt;type_register());
 888 
 889   } else {
 890     int reg = reg_num(opr);
 891     if (is_processed_reg_num(reg)) {
 892       add_def(reg, def_pos, use_kind, opr-&gt;type_register());
 893     }
 894     reg = reg_numHi(opr);
 895     if (is_valid_reg_num(reg) &amp;&amp; is_processed_reg_num(reg)) {
 896       add_def(reg, def_pos, use_kind, opr-&gt;type_register());
 897     }
 898   }
 899 }
 900 
 901 void LinearScan::add_use(LIR_Opr opr, int from, int to, IntervalUseKind use_kind) {
 902   TRACE_LINEAR_SCAN(2, tty-&gt;print(&quot; use &quot;); opr-&gt;print(tty); tty-&gt;print_cr(&quot; from %d to %d (%d)&quot;, from, to, use_kind));
 903   assert(opr-&gt;is_register(), &quot;should not be called otherwise&quot;);
 904 
 905   if (opr-&gt;is_virtual_register()) {
 906     assert(reg_num(opr) == opr-&gt;vreg_number() &amp;&amp; !is_valid_reg_num(reg_numHi(opr)), &quot;invalid optimization below&quot;);
 907     add_use(opr-&gt;vreg_number(), from, to, use_kind, opr-&gt;type_register());
 908 
 909   } else {
 910     int reg = reg_num(opr);
 911     if (is_processed_reg_num(reg)) {
 912       add_use(reg, from, to, use_kind, opr-&gt;type_register());
 913     }
 914     reg = reg_numHi(opr);
 915     if (is_valid_reg_num(reg) &amp;&amp; is_processed_reg_num(reg)) {
 916       add_use(reg, from, to, use_kind, opr-&gt;type_register());
 917     }
 918   }
 919 }
 920 
 921 void LinearScan::add_temp(LIR_Opr opr, int temp_pos, IntervalUseKind use_kind) {
 922   TRACE_LINEAR_SCAN(2, tty-&gt;print(&quot; temp &quot;); opr-&gt;print(tty); tty-&gt;print_cr(&quot; temp_pos %d (%d)&quot;, temp_pos, use_kind));
 923   assert(opr-&gt;is_register(), &quot;should not be called otherwise&quot;);
 924 
 925   if (opr-&gt;is_virtual_register()) {
 926     assert(reg_num(opr) == opr-&gt;vreg_number() &amp;&amp; !is_valid_reg_num(reg_numHi(opr)), &quot;invalid optimization below&quot;);
 927     add_temp(opr-&gt;vreg_number(), temp_pos, use_kind, opr-&gt;type_register());
 928 
 929   } else {
 930     int reg = reg_num(opr);
 931     if (is_processed_reg_num(reg)) {
 932       add_temp(reg, temp_pos, use_kind, opr-&gt;type_register());
 933     }
 934     reg = reg_numHi(opr);
 935     if (is_valid_reg_num(reg) &amp;&amp; is_processed_reg_num(reg)) {
 936       add_temp(reg, temp_pos, use_kind, opr-&gt;type_register());
 937     }
 938   }
 939 }
 940 
 941 
 942 void LinearScan::add_def(int reg_num, int def_pos, IntervalUseKind use_kind, BasicType type) {
 943   Interval* interval = interval_at(reg_num);
 944   if (interval != NULL) {
 945     assert(interval-&gt;reg_num() == reg_num, &quot;wrong interval&quot;);
 946 
 947     if (type != T_ILLEGAL) {
 948       interval-&gt;set_type(type);
 949     }
 950 
 951     Range* r = interval-&gt;first();
 952     if (r-&gt;from() &lt;= def_pos) {
 953       // Update the starting point (when a range is first created for a use, its
 954       // start is the beginning of the current block until a def is encountered.)
 955       r-&gt;set_from(def_pos);
 956       interval-&gt;add_use_pos(def_pos, use_kind);
 957 
 958     } else {
 959       // Dead value - make vacuous interval
 960       // also add use_kind for dead intervals
 961       interval-&gt;add_range(def_pos, def_pos + 1);
 962       interval-&gt;add_use_pos(def_pos, use_kind);
 963       TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;Warning: def of reg %d at %d occurs without use&quot;, reg_num, def_pos));
 964     }
 965 
 966   } else {
 967     // Dead value - make vacuous interval
 968     // also add use_kind for dead intervals
 969     interval = create_interval(reg_num);
 970     if (type != T_ILLEGAL) {
 971       interval-&gt;set_type(type);
 972     }
 973 
 974     interval-&gt;add_range(def_pos, def_pos + 1);
 975     interval-&gt;add_use_pos(def_pos, use_kind);
 976     TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;Warning: dead value %d at %d in live intervals&quot;, reg_num, def_pos));
 977   }
 978 
 979   change_spill_definition_pos(interval, def_pos);
 980   if (use_kind == noUse &amp;&amp; interval-&gt;spill_state() &lt;= startInMemory) {
 981         // detection of method-parameters and roundfp-results
 982         // TODO: move this directly to position where use-kind is computed
 983     interval-&gt;set_spill_state(startInMemory);
 984   }
 985 }
 986 
 987 void LinearScan::add_use(int reg_num, int from, int to, IntervalUseKind use_kind, BasicType type) {
 988   Interval* interval = interval_at(reg_num);
 989   if (interval == NULL) {
 990     interval = create_interval(reg_num);
 991   }
 992   assert(interval-&gt;reg_num() == reg_num, &quot;wrong interval&quot;);
 993 
 994   if (type != T_ILLEGAL) {
 995     interval-&gt;set_type(type);
 996   }
 997 
 998   interval-&gt;add_range(from, to);
 999   interval-&gt;add_use_pos(to, use_kind);
1000 }
1001 
1002 void LinearScan::add_temp(int reg_num, int temp_pos, IntervalUseKind use_kind, BasicType type) {
1003   Interval* interval = interval_at(reg_num);
1004   if (interval == NULL) {
1005     interval = create_interval(reg_num);
1006   }
1007   assert(interval-&gt;reg_num() == reg_num, &quot;wrong interval&quot;);
1008 
1009   if (type != T_ILLEGAL) {
1010     interval-&gt;set_type(type);
1011   }
1012 
1013   interval-&gt;add_range(temp_pos, temp_pos + 1);
1014   interval-&gt;add_use_pos(temp_pos, use_kind);
1015 }
1016 
1017 
1018 // the results of this functions are used for optimizing spilling and reloading
1019 // if the functions return shouldHaveRegister and the interval is spilled,
1020 // it is not reloaded to a register.
1021 IntervalUseKind LinearScan::use_kind_of_output_operand(LIR_Op* op, LIR_Opr opr) {
1022   if (op-&gt;code() == lir_move) {
1023     assert(op-&gt;as_Op1() != NULL, &quot;lir_move must be LIR_Op1&quot;);
1024     LIR_Op1* move = (LIR_Op1*)op;
1025     LIR_Opr res = move-&gt;result_opr();
1026     bool result_in_memory = res-&gt;is_virtual() &amp;&amp; gen()-&gt;is_vreg_flag_set(res-&gt;vreg_number(), LIRGenerator::must_start_in_memory);
1027 
1028     if (result_in_memory) {
1029       // Begin of an interval with must_start_in_memory set.
1030       // This interval will always get a stack slot first, so return noUse.
1031       return noUse;
1032 
1033     } else if (move-&gt;in_opr()-&gt;is_stack()) {
1034       // method argument (condition must be equal to handle_method_arguments)
1035       return noUse;
1036 
1037     } else if (move-&gt;in_opr()-&gt;is_register() &amp;&amp; move-&gt;result_opr()-&gt;is_register()) {
1038       // Move from register to register
1039       if (block_of_op_with_id(op-&gt;id())-&gt;is_set(BlockBegin::osr_entry_flag)) {
1040         // special handling of phi-function moves inside osr-entry blocks
1041         // input operand must have a register instead of output operand (leads to better register allocation)
1042         return shouldHaveRegister;
1043       }
1044     }
1045   }
1046 
1047   if (opr-&gt;is_virtual() &amp;&amp;
1048       gen()-&gt;is_vreg_flag_set(opr-&gt;vreg_number(), LIRGenerator::must_start_in_memory)) {
1049     // result is a stack-slot, so prevent immediate reloading
1050     return noUse;
1051   }
1052 
1053   // all other operands require a register
1054   return mustHaveRegister;
1055 }
1056 
1057 IntervalUseKind LinearScan::use_kind_of_input_operand(LIR_Op* op, LIR_Opr opr) {
1058   if (op-&gt;code() == lir_move) {
1059     assert(op-&gt;as_Op1() != NULL, &quot;lir_move must be LIR_Op1&quot;);
1060     LIR_Op1* move = (LIR_Op1*)op;
1061     LIR_Opr res = move-&gt;result_opr();
1062     bool result_in_memory = res-&gt;is_virtual() &amp;&amp; gen()-&gt;is_vreg_flag_set(res-&gt;vreg_number(), LIRGenerator::must_start_in_memory);
1063 
1064     if (result_in_memory) {
1065       // Move to an interval with must_start_in_memory set.
1066       // To avoid moves from stack to stack (not allowed) force the input operand to a register
1067       return mustHaveRegister;
1068 
1069     } else if (move-&gt;in_opr()-&gt;is_register() &amp;&amp; move-&gt;result_opr()-&gt;is_register()) {
1070       // Move from register to register
1071       if (block_of_op_with_id(op-&gt;id())-&gt;is_set(BlockBegin::osr_entry_flag)) {
1072         // special handling of phi-function moves inside osr-entry blocks
1073         // input operand must have a register instead of output operand (leads to better register allocation)
1074         return mustHaveRegister;
1075       }
1076 
1077       // The input operand is not forced to a register (moves from stack to register are allowed),
1078       // but it is faster if the input operand is in a register
1079       return shouldHaveRegister;
1080     }
1081   }
1082 
1083 
1084 #if defined(X86) || defined(S390)
1085   if (op-&gt;code() == lir_cmove) {
1086     // conditional moves can handle stack operands
1087     assert(op-&gt;result_opr()-&gt;is_register(), &quot;result must always be in a register&quot;);
1088     return shouldHaveRegister;
1089   }
1090 
1091   // optimizations for second input operand of arithmehtic operations on Intel
1092   // this operand is allowed to be on the stack in some cases
1093   BasicType opr_type = opr-&gt;type_register();
1094   if (opr_type == T_FLOAT || opr_type == T_DOUBLE) {
<a name="1" id="anc1"></a><span class="line-modified">1095     if ((UseSSE == 1 &amp;&amp; opr_type == T_FLOAT) || UseSSE &gt;= 2 S390_ONLY(|| true)) {</span>
1096       // SSE float instruction (T_DOUBLE only supported with SSE2)
1097       switch (op-&gt;code()) {
1098         case lir_cmp:
1099         case lir_add:
1100         case lir_sub:
1101         case lir_mul:
1102         case lir_div:
1103         {
1104           assert(op-&gt;as_Op2() != NULL, &quot;must be LIR_Op2&quot;);
1105           LIR_Op2* op2 = (LIR_Op2*)op;
1106           if (op2-&gt;in_opr1() != op2-&gt;in_opr2() &amp;&amp; op2-&gt;in_opr2() == opr) {
1107             assert((op2-&gt;result_opr()-&gt;is_register() || op-&gt;code() == lir_cmp) &amp;&amp; op2-&gt;in_opr1()-&gt;is_register(), &quot;cannot mark second operand as stack if others are not in register&quot;);
1108             return shouldHaveRegister;
1109           }
1110         }
1111         default:
1112           break;
1113       }
1114     } else {
1115       // FPU stack float instruction
1116       switch (op-&gt;code()) {
1117         case lir_add:
1118         case lir_sub:
1119         case lir_mul:
1120         case lir_div:
1121         {
1122           assert(op-&gt;as_Op2() != NULL, &quot;must be LIR_Op2&quot;);
1123           LIR_Op2* op2 = (LIR_Op2*)op;
1124           if (op2-&gt;in_opr1() != op2-&gt;in_opr2() &amp;&amp; op2-&gt;in_opr2() == opr) {
1125             assert((op2-&gt;result_opr()-&gt;is_register() || op-&gt;code() == lir_cmp) &amp;&amp; op2-&gt;in_opr1()-&gt;is_register(), &quot;cannot mark second operand as stack if others are not in register&quot;);
1126             return shouldHaveRegister;
1127           }
1128         }
1129         default:
1130           break;
1131       }
1132     }
1133     // We want to sometimes use logical operations on pointers, in particular in GC barriers.
1134     // Since 64bit logical operations do not current support operands on stack, we have to make sure
1135     // T_OBJECT doesn&#39;t get spilled along with T_LONG.
1136   } else if (opr_type != T_LONG LP64_ONLY(&amp;&amp; opr_type != T_OBJECT)) {
1137     // integer instruction (note: long operands must always be in register)
1138     switch (op-&gt;code()) {
1139       case lir_cmp:
1140       case lir_add:
1141       case lir_sub:
1142       case lir_logic_and:
1143       case lir_logic_or:
1144       case lir_logic_xor:
1145       {
1146         assert(op-&gt;as_Op2() != NULL, &quot;must be LIR_Op2&quot;);
1147         LIR_Op2* op2 = (LIR_Op2*)op;
1148         if (op2-&gt;in_opr1() != op2-&gt;in_opr2() &amp;&amp; op2-&gt;in_opr2() == opr) {
1149           assert((op2-&gt;result_opr()-&gt;is_register() || op-&gt;code() == lir_cmp) &amp;&amp; op2-&gt;in_opr1()-&gt;is_register(), &quot;cannot mark second operand as stack if others are not in register&quot;);
1150           return shouldHaveRegister;
1151         }
1152       }
1153       default:
1154         break;
1155     }
1156   }
<a name="2" id="anc2"></a><span class="line-modified">1157 #endif // X86 S390</span>
1158 
1159   // all other operands require a register
1160   return mustHaveRegister;
1161 }
1162 
1163 
1164 void LinearScan::handle_method_arguments(LIR_Op* op) {
1165   // special handling for method arguments (moves from stack to virtual register):
1166   // the interval gets no register assigned, but the stack slot.
1167   // it is split before the first use by the register allocator.
1168 
1169   if (op-&gt;code() == lir_move) {
1170     assert(op-&gt;as_Op1() != NULL, &quot;must be LIR_Op1&quot;);
1171     LIR_Op1* move = (LIR_Op1*)op;
1172 
1173     if (move-&gt;in_opr()-&gt;is_stack()) {
1174 #ifdef ASSERT
1175       int arg_size = compilation()-&gt;method()-&gt;arg_size();
1176       LIR_Opr o = move-&gt;in_opr();
1177       if (o-&gt;is_single_stack()) {
1178         assert(o-&gt;single_stack_ix() &gt;= 0 &amp;&amp; o-&gt;single_stack_ix() &lt; arg_size, &quot;out of range&quot;);
1179       } else if (o-&gt;is_double_stack()) {
1180         assert(o-&gt;double_stack_ix() &gt;= 0 &amp;&amp; o-&gt;double_stack_ix() &lt; arg_size, &quot;out of range&quot;);
1181       } else {
1182         ShouldNotReachHere();
1183       }
1184 
1185       assert(move-&gt;id() &gt; 0, &quot;invalid id&quot;);
1186       assert(block_of_op_with_id(move-&gt;id())-&gt;number_of_preds() == 0, &quot;move from stack must be in first block&quot;);
1187       assert(move-&gt;result_opr()-&gt;is_virtual(), &quot;result of move must be a virtual register&quot;);
1188 
1189       TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;found move from stack slot %d to vreg %d&quot;, o-&gt;is_single_stack() ? o-&gt;single_stack_ix() : o-&gt;double_stack_ix(), reg_num(move-&gt;result_opr())));
1190 #endif
1191 
1192       Interval* interval = interval_at(reg_num(move-&gt;result_opr()));
1193 
1194       int stack_slot = LinearScan::nof_regs + (move-&gt;in_opr()-&gt;is_single_stack() ? move-&gt;in_opr()-&gt;single_stack_ix() : move-&gt;in_opr()-&gt;double_stack_ix());
1195       interval-&gt;set_canonical_spill_slot(stack_slot);
1196       interval-&gt;assign_reg(stack_slot);
1197     }
1198   }
1199 }
1200 
1201 void LinearScan::handle_doubleword_moves(LIR_Op* op) {
1202   // special handling for doubleword move from memory to register:
1203   // in this case the registers of the input address and the result
1204   // registers must not overlap -&gt; add a temp range for the input registers
1205   if (op-&gt;code() == lir_move) {
1206     assert(op-&gt;as_Op1() != NULL, &quot;must be LIR_Op1&quot;);
1207     LIR_Op1* move = (LIR_Op1*)op;
1208 
1209     if (move-&gt;result_opr()-&gt;is_double_cpu() &amp;&amp; move-&gt;in_opr()-&gt;is_pointer()) {
1210       LIR_Address* address = move-&gt;in_opr()-&gt;as_address_ptr();
1211       if (address != NULL) {
1212         if (address-&gt;base()-&gt;is_valid()) {
1213           add_temp(address-&gt;base(), op-&gt;id(), noUse);
1214         }
1215         if (address-&gt;index()-&gt;is_valid()) {
1216           add_temp(address-&gt;index(), op-&gt;id(), noUse);
1217         }
1218       }
1219     }
1220   }
1221 }
1222 
1223 void LinearScan::add_register_hints(LIR_Op* op) {
1224   switch (op-&gt;code()) {
1225     case lir_move:      // fall through
1226     case lir_convert: {
1227       assert(op-&gt;as_Op1() != NULL, &quot;lir_move, lir_convert must be LIR_Op1&quot;);
1228       LIR_Op1* move = (LIR_Op1*)op;
1229 
1230       LIR_Opr move_from = move-&gt;in_opr();
1231       LIR_Opr move_to = move-&gt;result_opr();
1232 
1233       if (move_to-&gt;is_register() &amp;&amp; move_from-&gt;is_register()) {
1234         Interval* from = interval_at(reg_num(move_from));
1235         Interval* to = interval_at(reg_num(move_to));
1236         if (from != NULL &amp;&amp; to != NULL) {
1237           to-&gt;set_register_hint(from);
1238           TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;operation at op_id %d: added hint from interval %d to %d&quot;, move-&gt;id(), from-&gt;reg_num(), to-&gt;reg_num()));
1239         }
1240       }
1241       break;
1242     }
1243     case lir_cmove: {
1244       assert(op-&gt;as_Op2() != NULL, &quot;lir_cmove must be LIR_Op2&quot;);
1245       LIR_Op2* cmove = (LIR_Op2*)op;
1246 
1247       LIR_Opr move_from = cmove-&gt;in_opr1();
1248       LIR_Opr move_to = cmove-&gt;result_opr();
1249 
1250       if (move_to-&gt;is_register() &amp;&amp; move_from-&gt;is_register()) {
1251         Interval* from = interval_at(reg_num(move_from));
1252         Interval* to = interval_at(reg_num(move_to));
1253         if (from != NULL &amp;&amp; to != NULL) {
1254           to-&gt;set_register_hint(from);
1255           TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;operation at op_id %d: added hint from interval %d to %d&quot;, cmove-&gt;id(), from-&gt;reg_num(), to-&gt;reg_num()));
1256         }
1257       }
1258       break;
1259     }
1260     default:
1261       break;
1262   }
1263 }
1264 
1265 
1266 void LinearScan::build_intervals() {
1267   TIME_LINEAR_SCAN(timer_build_intervals);
1268 
1269   // initialize interval list with expected number of intervals
1270   // (32 is added to have some space for split children without having to resize the list)
1271   _intervals = IntervalList(num_virtual_regs() + 32);
1272   // initialize all slots that are used by build_intervals
1273   _intervals.at_put_grow(num_virtual_regs() - 1, NULL, NULL);
1274 
1275   // create a list with all caller-save registers (cpu, fpu, xmm)
1276   // when an instruction is a call, a temp range is created for all these registers
1277   int num_caller_save_registers = 0;
1278   int caller_save_registers[LinearScan::nof_regs];
1279 
1280   int i;
1281   for (i = 0; i &lt; FrameMap::nof_caller_save_cpu_regs(); i++) {
1282     LIR_Opr opr = FrameMap::caller_save_cpu_reg_at(i);
1283     assert(opr-&gt;is_valid() &amp;&amp; opr-&gt;is_register(), &quot;FrameMap should not return invalid operands&quot;);
1284     assert(reg_numHi(opr) == -1, &quot;missing addition of range for hi-register&quot;);
1285     caller_save_registers[num_caller_save_registers++] = reg_num(opr);
1286   }
1287 
1288   // temp ranges for fpu registers are only created when the method has
1289   // virtual fpu operands. Otherwise no allocation for fpu registers is
1290   // performed and so the temp ranges would be useless
1291   if (has_fpu_registers()) {
1292 #ifdef X86
1293     if (UseSSE &lt; 2) {
<a name="3" id="anc3"></a><span class="line-modified">1294 #endif</span>
1295       for (i = 0; i &lt; FrameMap::nof_caller_save_fpu_regs; i++) {
1296         LIR_Opr opr = FrameMap::caller_save_fpu_reg_at(i);
1297         assert(opr-&gt;is_valid() &amp;&amp; opr-&gt;is_register(), &quot;FrameMap should not return invalid operands&quot;);
1298         assert(reg_numHi(opr) == -1, &quot;missing addition of range for hi-register&quot;);
1299         caller_save_registers[num_caller_save_registers++] = reg_num(opr);
1300       }
1301 #ifdef X86
1302     }
<a name="4" id="anc4"></a>


1303     if (UseSSE &gt; 0) {
1304       int num_caller_save_xmm_regs = FrameMap::get_num_caller_save_xmms();
1305       for (i = 0; i &lt; num_caller_save_xmm_regs; i ++) {
1306         LIR_Opr opr = FrameMap::caller_save_xmm_reg_at(i);
1307         assert(opr-&gt;is_valid() &amp;&amp; opr-&gt;is_register(), &quot;FrameMap should not return invalid operands&quot;);
1308         assert(reg_numHi(opr) == -1, &quot;missing addition of range for hi-register&quot;);
1309         caller_save_registers[num_caller_save_registers++] = reg_num(opr);
1310       }
1311     }
<a name="5" id="anc5"></a><span class="line-modified">1312 #endif</span>
1313   }
1314   assert(num_caller_save_registers &lt;= LinearScan::nof_regs, &quot;out of bounds&quot;);
1315 
1316 
1317   LIR_OpVisitState visitor;
1318 
1319   // iterate all blocks in reverse order
1320   for (i = block_count() - 1; i &gt;= 0; i--) {
1321     BlockBegin* block = block_at(i);
1322     LIR_OpList* instructions = block-&gt;lir()-&gt;instructions_list();
1323     int         block_from =   block-&gt;first_lir_instruction_id();
1324     int         block_to =     block-&gt;last_lir_instruction_id();
1325 
1326     assert(block_from == instructions-&gt;at(0)-&gt;id(), &quot;must be&quot;);
1327     assert(block_to   == instructions-&gt;at(instructions-&gt;length() - 1)-&gt;id(), &quot;must be&quot;);
1328 
1329     // Update intervals for registers live at the end of this block;
1330     ResourceBitMap live = block-&gt;live_out();
1331     int size = (int)live.size();
1332     for (int number = (int)live.get_next_one_offset(0, size); number &lt; size; number = (int)live.get_next_one_offset(number + 1, size)) {
1333       assert(live.at(number), &quot;should not stop here otherwise&quot;);
1334       assert(number &gt;= LIR_OprDesc::vreg_base, &quot;fixed intervals must not be live on block bounds&quot;);
1335       TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;live in %d to %d&quot;, number, block_to + 2));
1336 
1337       add_use(number, block_from, block_to + 2, noUse, T_ILLEGAL);
1338 
1339       // add special use positions for loop-end blocks when the
1340       // interval is used anywhere inside this loop.  It&#39;s possible
1341       // that the block was part of a non-natural loop, so it might
1342       // have an invalid loop index.
1343       if (block-&gt;is_set(BlockBegin::linear_scan_loop_end_flag) &amp;&amp;
1344           block-&gt;loop_index() != -1 &amp;&amp;
1345           is_interval_in_loop(number, block-&gt;loop_index())) {
1346         interval_at(number)-&gt;add_use_pos(block_to + 1, loopEndMarker);
1347       }
1348     }
1349 
1350     // iterate all instructions of the block in reverse order.
1351     // skip the first instruction because it is always a label
1352     // definitions of intervals are processed before uses
1353     assert(visitor.no_operands(instructions-&gt;at(0)), &quot;first operation must always be a label&quot;);
1354     for (int j = instructions-&gt;length() - 1; j &gt;= 1; j--) {
1355       LIR_Op* op = instructions-&gt;at(j);
1356       int op_id = op-&gt;id();
1357 
1358       // visit operation to collect all operands
1359       visitor.visit(op);
1360 
1361       // add a temp range for each register if operation destroys caller-save registers
1362       if (visitor.has_call()) {
1363         for (int k = 0; k &lt; num_caller_save_registers; k++) {
1364           add_temp(caller_save_registers[k], op_id, noUse, T_ILLEGAL);
1365         }
1366         TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;operation destroys all caller-save registers&quot;));
1367       }
1368 
1369       // Add any platform dependent temps
1370       pd_add_temps(op);
1371 
1372       // visit definitions (output and temp operands)
1373       int k, n;
1374       n = visitor.opr_count(LIR_OpVisitState::outputMode);
1375       for (k = 0; k &lt; n; k++) {
1376         LIR_Opr opr = visitor.opr_at(LIR_OpVisitState::outputMode, k);
1377         assert(opr-&gt;is_register(), &quot;visitor should only return register operands&quot;);
1378         add_def(opr, op_id, use_kind_of_output_operand(op, opr));
1379       }
1380 
1381       n = visitor.opr_count(LIR_OpVisitState::tempMode);
1382       for (k = 0; k &lt; n; k++) {
1383         LIR_Opr opr = visitor.opr_at(LIR_OpVisitState::tempMode, k);
1384         assert(opr-&gt;is_register(), &quot;visitor should only return register operands&quot;);
1385         add_temp(opr, op_id, mustHaveRegister);
1386       }
1387 
1388       // visit uses (input operands)
1389       n = visitor.opr_count(LIR_OpVisitState::inputMode);
1390       for (k = 0; k &lt; n; k++) {
1391         LIR_Opr opr = visitor.opr_at(LIR_OpVisitState::inputMode, k);
1392         assert(opr-&gt;is_register(), &quot;visitor should only return register operands&quot;);
1393         add_use(opr, block_from, op_id, use_kind_of_input_operand(op, opr));
1394       }
1395 
1396       // Add uses of live locals from interpreter&#39;s point of view for proper
1397       // debug information generation
1398       // Treat these operands as temp values (if the life range is extended
1399       // to a call site, the value would be in a register at the call otherwise)
1400       n = visitor.info_count();
1401       for (k = 0; k &lt; n; k++) {
1402         CodeEmitInfo* info = visitor.info_at(k);
1403         ValueStack* stack = info-&gt;stack();
1404         for_each_state_value(stack, value,
1405           add_use(value, block_from, op_id + 1, noUse);
1406         );
1407       }
1408 
1409       // special steps for some instructions (especially moves)
1410       handle_method_arguments(op);
1411       handle_doubleword_moves(op);
1412       add_register_hints(op);
1413 
1414     } // end of instruction iteration
1415   } // end of block iteration
1416 
1417 
1418   // add the range [0, 1[ to all fixed intervals
1419   // -&gt; the register allocator need not handle unhandled fixed intervals
1420   for (int n = 0; n &lt; LinearScan::nof_regs; n++) {
1421     Interval* interval = interval_at(n);
1422     if (interval != NULL) {
1423       interval-&gt;add_range(0, 1);
1424     }
1425   }
1426 }
1427 
1428 
1429 // ********** Phase 5: actual register allocation
1430 
1431 int LinearScan::interval_cmp(Interval** a, Interval** b) {
1432   if (*a != NULL) {
1433     if (*b != NULL) {
1434       return (*a)-&gt;from() - (*b)-&gt;from();
1435     } else {
1436       return -1;
1437     }
1438   } else {
1439     if (*b != NULL) {
1440       return 1;
1441     } else {
1442       return 0;
1443     }
1444   }
1445 }
1446 
1447 #ifndef PRODUCT
1448 int interval_cmp(Interval* const&amp; l, Interval* const&amp; r) {
1449   return l-&gt;from() - r-&gt;from();
1450 }
1451 
1452 bool find_interval(Interval* interval, IntervalArray* intervals) {
1453   bool found;
1454   int idx = intervals-&gt;find_sorted&lt;Interval*, interval_cmp&gt;(interval, found);
1455 
1456   if (!found) {
1457     return false;
1458   }
1459 
1460   int from = interval-&gt;from();
1461 
1462   // The index we&#39;ve found using binary search is pointing to an interval
1463   // that is defined in the same place as the interval we were looking for.
1464   // So now we have to look around that index and find exact interval.
1465   for (int i = idx; i &gt;= 0; i--) {
1466     if (intervals-&gt;at(i) == interval) {
1467       return true;
1468     }
1469     if (intervals-&gt;at(i)-&gt;from() != from) {
1470       break;
1471     }
1472   }
1473 
1474   for (int i = idx + 1; i &lt; intervals-&gt;length(); i++) {
1475     if (intervals-&gt;at(i) == interval) {
1476       return true;
1477     }
1478     if (intervals-&gt;at(i)-&gt;from() != from) {
1479       break;
1480     }
1481   }
1482 
1483   return false;
1484 }
1485 
1486 bool LinearScan::is_sorted(IntervalArray* intervals) {
1487   int from = -1;
1488   int null_count = 0;
1489 
1490   for (int i = 0; i &lt; intervals-&gt;length(); i++) {
1491     Interval* it = intervals-&gt;at(i);
1492     if (it != NULL) {
1493       assert(from &lt;= it-&gt;from(), &quot;Intervals are unordered&quot;);
1494       from = it-&gt;from();
1495     } else {
1496       null_count++;
1497     }
1498   }
1499 
1500   assert(null_count == 0, &quot;Sorted intervals should not contain nulls&quot;);
1501 
1502   null_count = 0;
1503 
1504   for (int i = 0; i &lt; interval_count(); i++) {
1505     Interval* interval = interval_at(i);
1506     if (interval != NULL) {
1507       assert(find_interval(interval, intervals), &quot;Lists do not contain same intervals&quot;);
1508     } else {
1509       null_count++;
1510     }
1511   }
1512 
1513   assert(interval_count() - null_count == intervals-&gt;length(),
1514       &quot;Sorted list should contain the same amount of non-NULL intervals as unsorted list&quot;);
1515 
1516   return true;
1517 }
1518 #endif
1519 
1520 void LinearScan::add_to_list(Interval** first, Interval** prev, Interval* interval) {
1521   if (*prev != NULL) {
1522     (*prev)-&gt;set_next(interval);
1523   } else {
1524     *first = interval;
1525   }
1526   *prev = interval;
1527 }
1528 
1529 void LinearScan::create_unhandled_lists(Interval** list1, Interval** list2, bool (is_list1)(const Interval* i), bool (is_list2)(const Interval* i)) {
1530   assert(is_sorted(_sorted_intervals), &quot;interval list is not sorted&quot;);
1531 
1532   *list1 = *list2 = Interval::end();
1533 
1534   Interval* list1_prev = NULL;
1535   Interval* list2_prev = NULL;
1536   Interval* v;
1537 
1538   const int n = _sorted_intervals-&gt;length();
1539   for (int i = 0; i &lt; n; i++) {
1540     v = _sorted_intervals-&gt;at(i);
1541     if (v == NULL) continue;
1542 
1543     if (is_list1(v)) {
1544       add_to_list(list1, &amp;list1_prev, v);
1545     } else if (is_list2 == NULL || is_list2(v)) {
1546       add_to_list(list2, &amp;list2_prev, v);
1547     }
1548   }
1549 
1550   if (list1_prev != NULL) list1_prev-&gt;set_next(Interval::end());
1551   if (list2_prev != NULL) list2_prev-&gt;set_next(Interval::end());
1552 
1553   assert(list1_prev == NULL || list1_prev-&gt;next() == Interval::end(), &quot;linear list ends not with sentinel&quot;);
1554   assert(list2_prev == NULL || list2_prev-&gt;next() == Interval::end(), &quot;linear list ends not with sentinel&quot;);
1555 }
1556 
1557 
1558 void LinearScan::sort_intervals_before_allocation() {
1559   TIME_LINEAR_SCAN(timer_sort_intervals_before);
1560 
1561   if (_needs_full_resort) {
1562     // There is no known reason why this should occur but just in case...
1563     assert(false, &quot;should never occur&quot;);
1564     // Re-sort existing interval list because an Interval::from() has changed
1565     _sorted_intervals-&gt;sort(interval_cmp);
1566     _needs_full_resort = false;
1567   }
1568 
1569   IntervalList* unsorted_list = &amp;_intervals;
1570   int unsorted_len = unsorted_list-&gt;length();
1571   int sorted_len = 0;
1572   int unsorted_idx;
1573   int sorted_idx = 0;
1574   int sorted_from_max = -1;
1575 
1576   // calc number of items for sorted list (sorted list must not contain NULL values)
1577   for (unsorted_idx = 0; unsorted_idx &lt; unsorted_len; unsorted_idx++) {
1578     if (unsorted_list-&gt;at(unsorted_idx) != NULL) {
1579       sorted_len++;
1580     }
1581   }
1582   IntervalArray* sorted_list = new IntervalArray(sorted_len, sorted_len, NULL);
1583 
1584   // special sorting algorithm: the original interval-list is almost sorted,
1585   // only some intervals are swapped. So this is much faster than a complete QuickSort
1586   for (unsorted_idx = 0; unsorted_idx &lt; unsorted_len; unsorted_idx++) {
1587     Interval* cur_interval = unsorted_list-&gt;at(unsorted_idx);
1588 
1589     if (cur_interval != NULL) {
1590       int cur_from = cur_interval-&gt;from();
1591 
1592       if (sorted_from_max &lt;= cur_from) {
1593         sorted_list-&gt;at_put(sorted_idx++, cur_interval);
1594         sorted_from_max = cur_interval-&gt;from();
1595       } else {
1596         // the asumption that the intervals are already sorted failed,
1597         // so this interval must be sorted in manually
1598         int j;
1599         for (j = sorted_idx - 1; j &gt;= 0 &amp;&amp; cur_from &lt; sorted_list-&gt;at(j)-&gt;from(); j--) {
1600           sorted_list-&gt;at_put(j + 1, sorted_list-&gt;at(j));
1601         }
1602         sorted_list-&gt;at_put(j + 1, cur_interval);
1603         sorted_idx++;
1604       }
1605     }
1606   }
1607   _sorted_intervals = sorted_list;
1608   assert(is_sorted(_sorted_intervals), &quot;intervals unsorted&quot;);
1609 }
1610 
1611 void LinearScan::sort_intervals_after_allocation() {
1612   TIME_LINEAR_SCAN(timer_sort_intervals_after);
1613 
1614   if (_needs_full_resort) {
1615     // Re-sort existing interval list because an Interval::from() has changed
1616     _sorted_intervals-&gt;sort(interval_cmp);
1617     _needs_full_resort = false;
1618   }
1619 
1620   IntervalArray* old_list = _sorted_intervals;
1621   IntervalList* new_list = _new_intervals_from_allocation;
1622   int old_len = old_list-&gt;length();
1623   int new_len = new_list == NULL ? 0 : new_list-&gt;length();
1624 
1625   if (new_len == 0) {
1626     // no intervals have been added during allocation, so sorted list is already up to date
1627     assert(is_sorted(_sorted_intervals), &quot;intervals unsorted&quot;);
1628     return;
1629   }
1630 
1631   // conventional sort-algorithm for new intervals
1632   new_list-&gt;sort(interval_cmp);
1633 
1634   // merge old and new list (both already sorted) into one combined list
1635   int combined_list_len = old_len + new_len;
1636   IntervalArray* combined_list = new IntervalArray(combined_list_len, combined_list_len, NULL);
1637   int old_idx = 0;
1638   int new_idx = 0;
1639 
1640   while (old_idx + new_idx &lt; old_len + new_len) {
1641     if (new_idx &gt;= new_len || (old_idx &lt; old_len &amp;&amp; old_list-&gt;at(old_idx)-&gt;from() &lt;= new_list-&gt;at(new_idx)-&gt;from())) {
1642       combined_list-&gt;at_put(old_idx + new_idx, old_list-&gt;at(old_idx));
1643       old_idx++;
1644     } else {
1645       combined_list-&gt;at_put(old_idx + new_idx, new_list-&gt;at(new_idx));
1646       new_idx++;
1647     }
1648   }
1649 
1650   _sorted_intervals = combined_list;
1651   assert(is_sorted(_sorted_intervals), &quot;intervals unsorted&quot;);
1652 }
1653 
1654 
1655 void LinearScan::allocate_registers() {
1656   TIME_LINEAR_SCAN(timer_allocate_registers);
1657 
1658   Interval* precolored_cpu_intervals, *not_precolored_cpu_intervals;
1659   Interval* precolored_fpu_intervals, *not_precolored_fpu_intervals;
1660 
1661   // allocate cpu registers
1662   create_unhandled_lists(&amp;precolored_cpu_intervals, &amp;not_precolored_cpu_intervals,
1663                          is_precolored_cpu_interval, is_virtual_cpu_interval);
1664 
1665   // allocate fpu registers
1666   create_unhandled_lists(&amp;precolored_fpu_intervals, &amp;not_precolored_fpu_intervals,
1667                          is_precolored_fpu_interval, is_virtual_fpu_interval);
1668 
1669   // the fpu interval allocation cannot be moved down below with the fpu section as
1670   // the cpu_lsw.walk() changes interval positions.
1671 
1672   LinearScanWalker cpu_lsw(this, precolored_cpu_intervals, not_precolored_cpu_intervals);
1673   cpu_lsw.walk();
1674   cpu_lsw.finish_allocation();
1675 
1676   if (has_fpu_registers()) {
1677     LinearScanWalker fpu_lsw(this, precolored_fpu_intervals, not_precolored_fpu_intervals);
1678     fpu_lsw.walk();
1679     fpu_lsw.finish_allocation();
1680   }
1681 }
1682 
1683 
1684 // ********** Phase 6: resolve data flow
1685 // (insert moves at edges between blocks if intervals have been split)
1686 
1687 // wrapper for Interval::split_child_at_op_id that performs a bailout in product mode
1688 // instead of returning NULL
1689 Interval* LinearScan::split_child_at_op_id(Interval* interval, int op_id, LIR_OpVisitState::OprMode mode) {
1690   Interval* result = interval-&gt;split_child_at_op_id(op_id, mode);
1691   if (result != NULL) {
1692     return result;
1693   }
1694 
1695   assert(false, &quot;must find an interval, but do a clean bailout in product mode&quot;);
1696   result = new Interval(LIR_OprDesc::vreg_base);
1697   result-&gt;assign_reg(0);
1698   result-&gt;set_type(T_INT);
1699   BAILOUT_(&quot;LinearScan: interval is NULL&quot;, result);
1700 }
1701 
1702 
1703 Interval* LinearScan::interval_at_block_begin(BlockBegin* block, int reg_num) {
1704   assert(LinearScan::nof_regs &lt;= reg_num &amp;&amp; reg_num &lt; num_virtual_regs(), &quot;register number out of bounds&quot;);
1705   assert(interval_at(reg_num) != NULL, &quot;no interval found&quot;);
1706 
1707   return split_child_at_op_id(interval_at(reg_num), block-&gt;first_lir_instruction_id(), LIR_OpVisitState::outputMode);
1708 }
1709 
1710 Interval* LinearScan::interval_at_block_end(BlockBegin* block, int reg_num) {
1711   assert(LinearScan::nof_regs &lt;= reg_num &amp;&amp; reg_num &lt; num_virtual_regs(), &quot;register number out of bounds&quot;);
1712   assert(interval_at(reg_num) != NULL, &quot;no interval found&quot;);
1713 
1714   return split_child_at_op_id(interval_at(reg_num), block-&gt;last_lir_instruction_id() + 1, LIR_OpVisitState::outputMode);
1715 }
1716 
1717 Interval* LinearScan::interval_at_op_id(int reg_num, int op_id) {
1718   assert(LinearScan::nof_regs &lt;= reg_num &amp;&amp; reg_num &lt; num_virtual_regs(), &quot;register number out of bounds&quot;);
1719   assert(interval_at(reg_num) != NULL, &quot;no interval found&quot;);
1720 
1721   return split_child_at_op_id(interval_at(reg_num), op_id, LIR_OpVisitState::inputMode);
1722 }
1723 
1724 
1725 void LinearScan::resolve_collect_mappings(BlockBegin* from_block, BlockBegin* to_block, MoveResolver &amp;move_resolver) {
1726   DEBUG_ONLY(move_resolver.check_empty());
1727 
1728   const int size = live_set_size();
1729   const ResourceBitMap live_at_edge = to_block-&gt;live_in();
1730 
1731   // visit all registers where the live_at_edge bit is set
1732   for (int r = (int)live_at_edge.get_next_one_offset(0, size); r &lt; size; r = (int)live_at_edge.get_next_one_offset(r + 1, size)) {
1733     assert(r &lt; num_virtual_regs(), &quot;live information set for not exisiting interval&quot;);
1734     assert(from_block-&gt;live_out().at(r) &amp;&amp; to_block-&gt;live_in().at(r), &quot;interval not live at this edge&quot;);
1735 
1736     Interval* from_interval = interval_at_block_end(from_block, r);
1737     Interval* to_interval = interval_at_block_begin(to_block, r);
1738 
1739     if (from_interval != to_interval &amp;&amp; (from_interval-&gt;assigned_reg() != to_interval-&gt;assigned_reg() || from_interval-&gt;assigned_regHi() != to_interval-&gt;assigned_regHi())) {
1740       // need to insert move instruction
1741       move_resolver.add_mapping(from_interval, to_interval);
1742     }
1743   }
1744 }
1745 
1746 
1747 void LinearScan::resolve_find_insert_pos(BlockBegin* from_block, BlockBegin* to_block, MoveResolver &amp;move_resolver) {
1748   if (from_block-&gt;number_of_sux() &lt;= 1) {
1749     TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;inserting moves at end of from_block B%d&quot;, from_block-&gt;block_id()));
1750 
1751     LIR_OpList* instructions = from_block-&gt;lir()-&gt;instructions_list();
1752     LIR_OpBranch* branch = instructions-&gt;last()-&gt;as_OpBranch();
1753     if (branch != NULL) {
1754       // insert moves before branch
1755       assert(branch-&gt;cond() == lir_cond_always, &quot;block does not end with an unconditional jump&quot;);
1756       move_resolver.set_insert_position(from_block-&gt;lir(), instructions-&gt;length() - 2);
1757     } else {
1758       move_resolver.set_insert_position(from_block-&gt;lir(), instructions-&gt;length() - 1);
1759     }
1760 
1761   } else {
1762     TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;inserting moves at beginning of to_block B%d&quot;, to_block-&gt;block_id()));
1763 #ifdef ASSERT
1764     assert(from_block-&gt;lir()-&gt;instructions_list()-&gt;at(0)-&gt;as_OpLabel() != NULL, &quot;block does not start with a label&quot;);
1765 
1766     // because the number of predecessor edges matches the number of
1767     // successor edges, blocks which are reached by switch statements
1768     // may have be more than one predecessor but it will be guaranteed
1769     // that all predecessors will be the same.
1770     for (int i = 0; i &lt; to_block-&gt;number_of_preds(); i++) {
1771       assert(from_block == to_block-&gt;pred_at(i), &quot;all critical edges must be broken&quot;);
1772     }
1773 #endif
1774 
1775     move_resolver.set_insert_position(to_block-&gt;lir(), 0);
1776   }
1777 }
1778 
1779 
1780 // insert necessary moves (spilling or reloading) at edges between blocks if interval has been split
1781 void LinearScan::resolve_data_flow() {
1782   TIME_LINEAR_SCAN(timer_resolve_data_flow);
1783 
1784   int num_blocks = block_count();
1785   MoveResolver move_resolver(this);
1786   ResourceBitMap block_completed(num_blocks);
1787   ResourceBitMap already_resolved(num_blocks);
1788 
1789   int i;
1790   for (i = 0; i &lt; num_blocks; i++) {
1791     BlockBegin* block = block_at(i);
1792 
1793     // check if block has only one predecessor and only one successor
1794     if (block-&gt;number_of_preds() == 1 &amp;&amp; block-&gt;number_of_sux() == 1 &amp;&amp; block-&gt;number_of_exception_handlers() == 0) {
1795       LIR_OpList* instructions = block-&gt;lir()-&gt;instructions_list();
1796       assert(instructions-&gt;at(0)-&gt;code() == lir_label, &quot;block must start with label&quot;);
1797       assert(instructions-&gt;last()-&gt;code() == lir_branch, &quot;block with successors must end with branch&quot;);
1798       assert(instructions-&gt;last()-&gt;as_OpBranch()-&gt;cond() == lir_cond_always, &quot;block with successor must end with unconditional branch&quot;);
1799 
1800       // check if block is empty (only label and branch)
1801       if (instructions-&gt;length() == 2) {
1802         BlockBegin* pred = block-&gt;pred_at(0);
1803         BlockBegin* sux = block-&gt;sux_at(0);
1804 
1805         // prevent optimization of two consecutive blocks
1806         if (!block_completed.at(pred-&gt;linear_scan_number()) &amp;&amp; !block_completed.at(sux-&gt;linear_scan_number())) {
1807           TRACE_LINEAR_SCAN(3, tty-&gt;print_cr(&quot;**** optimizing empty block B%d (pred: B%d, sux: B%d)&quot;, block-&gt;block_id(), pred-&gt;block_id(), sux-&gt;block_id()));
1808           block_completed.set_bit(block-&gt;linear_scan_number());
1809 
1810           // directly resolve between pred and sux (without looking at the empty block between)
1811           resolve_collect_mappings(pred, sux, move_resolver);
1812           if (move_resolver.has_mappings()) {
1813             move_resolver.set_insert_position(block-&gt;lir(), 0);
1814             move_resolver.resolve_and_append_moves();
1815           }
1816         }
1817       }
1818     }
1819   }
1820 
1821 
1822   for (i = 0; i &lt; num_blocks; i++) {
1823     if (!block_completed.at(i)) {
1824       BlockBegin* from_block = block_at(i);
1825       already_resolved.set_from(block_completed);
1826 
1827       int num_sux = from_block-&gt;number_of_sux();
1828       for (int s = 0; s &lt; num_sux; s++) {
1829         BlockBegin* to_block = from_block-&gt;sux_at(s);
1830 
1831         // check for duplicate edges between the same blocks (can happen with switch blocks)
1832         if (!already_resolved.at(to_block-&gt;linear_scan_number())) {
1833           TRACE_LINEAR_SCAN(3, tty-&gt;print_cr(&quot;**** processing edge between B%d and B%d&quot;, from_block-&gt;block_id(), to_block-&gt;block_id()));
1834           already_resolved.set_bit(to_block-&gt;linear_scan_number());
1835 
1836           // collect all intervals that have been split between from_block and to_block
1837           resolve_collect_mappings(from_block, to_block, move_resolver);
1838           if (move_resolver.has_mappings()) {
1839             resolve_find_insert_pos(from_block, to_block, move_resolver);
1840             move_resolver.resolve_and_append_moves();
1841           }
1842         }
1843       }
1844     }
1845   }
1846 }
1847 
1848 
1849 void LinearScan::resolve_exception_entry(BlockBegin* block, int reg_num, MoveResolver &amp;move_resolver) {
1850   if (interval_at(reg_num) == NULL) {
1851     // if a phi function is never used, no interval is created -&gt; ignore this
1852     return;
1853   }
1854 
1855   Interval* interval = interval_at_block_begin(block, reg_num);
1856   int reg = interval-&gt;assigned_reg();
1857   int regHi = interval-&gt;assigned_regHi();
1858 
1859   if ((reg &lt; nof_regs &amp;&amp; interval-&gt;always_in_memory()) ||
1860       (use_fpu_stack_allocation() &amp;&amp; reg &gt;= pd_first_fpu_reg &amp;&amp; reg &lt;= pd_last_fpu_reg)) {
1861     // the interval is split to get a short range that is located on the stack
1862     // in the following two cases:
1863     // * the interval started in memory (e.g. method parameter), but is currently in a register
1864     //   this is an optimization for exception handling that reduces the number of moves that
1865     //   are necessary for resolving the states when an exception uses this exception handler
1866     // * the interval would be on the fpu stack at the begin of the exception handler
1867     //   this is not allowed because of the complicated fpu stack handling on Intel
1868 
1869     // range that will be spilled to memory
1870     int from_op_id = block-&gt;first_lir_instruction_id();
1871     int to_op_id = from_op_id + 1;  // short live range of length 1
1872     assert(interval-&gt;from() &lt;= from_op_id &amp;&amp; interval-&gt;to() &gt;= to_op_id,
1873            &quot;no split allowed between exception entry and first instruction&quot;);
1874 
1875     if (interval-&gt;from() != from_op_id) {
1876       // the part before from_op_id is unchanged
1877       interval = interval-&gt;split(from_op_id);
1878       interval-&gt;assign_reg(reg, regHi);
1879       append_interval(interval);
1880     } else {
1881       _needs_full_resort = true;
1882     }
1883     assert(interval-&gt;from() == from_op_id, &quot;must be true now&quot;);
1884 
1885     Interval* spilled_part = interval;
1886     if (interval-&gt;to() != to_op_id) {
1887       // the part after to_op_id is unchanged
1888       spilled_part = interval-&gt;split_from_start(to_op_id);
1889       append_interval(spilled_part);
1890       move_resolver.add_mapping(spilled_part, interval);
1891     }
1892     assign_spill_slot(spilled_part);
1893 
1894     assert(spilled_part-&gt;from() == from_op_id &amp;&amp; spilled_part-&gt;to() == to_op_id, &quot;just checking&quot;);
1895   }
1896 }
1897 
1898 void LinearScan::resolve_exception_entry(BlockBegin* block, MoveResolver &amp;move_resolver) {
1899   assert(block-&gt;is_set(BlockBegin::exception_entry_flag), &quot;should not call otherwise&quot;);
1900   DEBUG_ONLY(move_resolver.check_empty());
1901 
1902   // visit all registers where the live_in bit is set
1903   int size = live_set_size();
1904   for (int r = (int)block-&gt;live_in().get_next_one_offset(0, size); r &lt; size; r = (int)block-&gt;live_in().get_next_one_offset(r + 1, size)) {
1905     resolve_exception_entry(block, r, move_resolver);
1906   }
1907 
1908   // the live_in bits are not set for phi functions of the xhandler entry, so iterate them separately
1909   for_each_phi_fun(block, phi,
1910     if (!phi-&gt;is_illegal()) { resolve_exception_entry(block, phi-&gt;operand()-&gt;vreg_number(), move_resolver); }
1911   );
1912 
1913   if (move_resolver.has_mappings()) {
1914     // insert moves after first instruction
1915     move_resolver.set_insert_position(block-&gt;lir(), 0);
1916     move_resolver.resolve_and_append_moves();
1917   }
1918 }
1919 
1920 
1921 void LinearScan::resolve_exception_edge(XHandler* handler, int throwing_op_id, int reg_num, Phi* phi, MoveResolver &amp;move_resolver) {
1922   if (interval_at(reg_num) == NULL) {
1923     // if a phi function is never used, no interval is created -&gt; ignore this
1924     return;
1925   }
1926 
1927   // the computation of to_interval is equal to resolve_collect_mappings,
1928   // but from_interval is more complicated because of phi functions
1929   BlockBegin* to_block = handler-&gt;entry_block();
1930   Interval* to_interval = interval_at_block_begin(to_block, reg_num);
1931 
1932   if (phi != NULL) {
1933     // phi function of the exception entry block
1934     // no moves are created for this phi function in the LIR_Generator, so the
1935     // interval at the throwing instruction must be searched using the operands
1936     // of the phi function
1937     Value from_value = phi-&gt;operand_at(handler-&gt;phi_operand());
1938 
1939     // with phi functions it can happen that the same from_value is used in
1940     // multiple mappings, so notify move-resolver that this is allowed
1941     move_resolver.set_multiple_reads_allowed();
1942 
1943     Constant* con = from_value-&gt;as_Constant();
1944     if (con != NULL &amp;&amp; !con-&gt;is_pinned()) {
1945       // unpinned constants may have no register, so add mapping from constant to interval
1946       move_resolver.add_mapping(LIR_OprFact::value_type(con-&gt;type()), to_interval);
1947     } else {
1948       // search split child at the throwing op_id
1949       Interval* from_interval = interval_at_op_id(from_value-&gt;operand()-&gt;vreg_number(), throwing_op_id);
1950       move_resolver.add_mapping(from_interval, to_interval);
1951     }
1952 
1953   } else {
1954     // no phi function, so use reg_num also for from_interval
1955     // search split child at the throwing op_id
1956     Interval* from_interval = interval_at_op_id(reg_num, throwing_op_id);
1957     if (from_interval != to_interval) {
1958       // optimization to reduce number of moves: when to_interval is on stack and
1959       // the stack slot is known to be always correct, then no move is necessary
1960       if (!from_interval-&gt;always_in_memory() || from_interval-&gt;canonical_spill_slot() != to_interval-&gt;assigned_reg()) {
1961         move_resolver.add_mapping(from_interval, to_interval);
1962       }
1963     }
1964   }
1965 }
1966 
1967 void LinearScan::resolve_exception_edge(XHandler* handler, int throwing_op_id, MoveResolver &amp;move_resolver) {
1968   TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;resolving exception handler B%d: throwing_op_id=%d&quot;, handler-&gt;entry_block()-&gt;block_id(), throwing_op_id));
1969 
1970   DEBUG_ONLY(move_resolver.check_empty());
1971   assert(handler-&gt;lir_op_id() == -1, &quot;already processed this xhandler&quot;);
1972   DEBUG_ONLY(handler-&gt;set_lir_op_id(throwing_op_id));
1973   assert(handler-&gt;entry_code() == NULL, &quot;code already present&quot;);
1974 
1975   // visit all registers where the live_in bit is set
1976   BlockBegin* block = handler-&gt;entry_block();
1977   int size = live_set_size();
1978   for (int r = (int)block-&gt;live_in().get_next_one_offset(0, size); r &lt; size; r = (int)block-&gt;live_in().get_next_one_offset(r + 1, size)) {
1979     resolve_exception_edge(handler, throwing_op_id, r, NULL, move_resolver);
1980   }
1981 
1982   // the live_in bits are not set for phi functions of the xhandler entry, so iterate them separately
1983   for_each_phi_fun(block, phi,
1984     if (!phi-&gt;is_illegal()) { resolve_exception_edge(handler, throwing_op_id, phi-&gt;operand()-&gt;vreg_number(), phi, move_resolver); }
1985   );
1986 
1987   if (move_resolver.has_mappings()) {
1988     LIR_List* entry_code = new LIR_List(compilation());
1989     move_resolver.set_insert_position(entry_code, 0);
1990     move_resolver.resolve_and_append_moves();
1991 
1992     entry_code-&gt;jump(handler-&gt;entry_block());
1993     handler-&gt;set_entry_code(entry_code);
1994   }
1995 }
1996 
1997 
1998 void LinearScan::resolve_exception_handlers() {
1999   MoveResolver move_resolver(this);
2000   LIR_OpVisitState visitor;
2001   int num_blocks = block_count();
2002 
2003   int i;
2004   for (i = 0; i &lt; num_blocks; i++) {
2005     BlockBegin* block = block_at(i);
2006     if (block-&gt;is_set(BlockBegin::exception_entry_flag)) {
2007       resolve_exception_entry(block, move_resolver);
2008     }
2009   }
2010 
2011   for (i = 0; i &lt; num_blocks; i++) {
2012     BlockBegin* block = block_at(i);
2013     LIR_List* ops = block-&gt;lir();
2014     int num_ops = ops-&gt;length();
2015 
2016     // iterate all instructions of the block. skip the first because it is always a label
2017     assert(visitor.no_operands(ops-&gt;at(0)), &quot;first operation must always be a label&quot;);
2018     for (int j = 1; j &lt; num_ops; j++) {
2019       LIR_Op* op = ops-&gt;at(j);
2020       int op_id = op-&gt;id();
2021 
2022       if (op_id != -1 &amp;&amp; has_info(op_id)) {
2023         // visit operation to collect all operands
2024         visitor.visit(op);
2025         assert(visitor.info_count() &gt; 0, &quot;should not visit otherwise&quot;);
2026 
2027         XHandlers* xhandlers = visitor.all_xhandler();
2028         int n = xhandlers-&gt;length();
2029         for (int k = 0; k &lt; n; k++) {
2030           resolve_exception_edge(xhandlers-&gt;handler_at(k), op_id, move_resolver);
2031         }
2032 
2033 #ifdef ASSERT
2034       } else {
2035         visitor.visit(op);
2036         assert(visitor.all_xhandler()-&gt;length() == 0, &quot;missed exception handler&quot;);
2037 #endif
2038       }
2039     }
2040   }
2041 }
2042 
2043 
2044 // ********** Phase 7: assign register numbers back to LIR
2045 // (includes computation of debug information and oop maps)
2046 
2047 VMReg LinearScan::vm_reg_for_interval(Interval* interval) {
2048   VMReg reg = interval-&gt;cached_vm_reg();
2049   if (!reg-&gt;is_valid() ) {
2050     reg = vm_reg_for_operand(operand_for_interval(interval));
2051     interval-&gt;set_cached_vm_reg(reg);
2052   }
2053   assert(reg == vm_reg_for_operand(operand_for_interval(interval)), &quot;wrong cached value&quot;);
2054   return reg;
2055 }
2056 
2057 VMReg LinearScan::vm_reg_for_operand(LIR_Opr opr) {
2058   assert(opr-&gt;is_oop(), &quot;currently only implemented for oop operands&quot;);
2059   return frame_map()-&gt;regname(opr);
2060 }
2061 
2062 
2063 LIR_Opr LinearScan::operand_for_interval(Interval* interval) {
2064   LIR_Opr opr = interval-&gt;cached_opr();
2065   if (opr-&gt;is_illegal()) {
2066     opr = calc_operand_for_interval(interval);
2067     interval-&gt;set_cached_opr(opr);
2068   }
2069 
2070   assert(opr == calc_operand_for_interval(interval), &quot;wrong cached value&quot;);
2071   return opr;
2072 }
2073 
2074 LIR_Opr LinearScan::calc_operand_for_interval(const Interval* interval) {
2075   int assigned_reg = interval-&gt;assigned_reg();
2076   BasicType type = interval-&gt;type();
2077 
2078   if (assigned_reg &gt;= nof_regs) {
2079     // stack slot
2080     assert(interval-&gt;assigned_regHi() == any_reg, &quot;must not have hi register&quot;);
2081     return LIR_OprFact::stack(assigned_reg - nof_regs, type);
2082 
2083   } else {
2084     // register
2085     switch (type) {
2086       case T_OBJECT: {
2087         assert(assigned_reg &gt;= pd_first_cpu_reg &amp;&amp; assigned_reg &lt;= pd_last_cpu_reg, &quot;no cpu register&quot;);
2088         assert(interval-&gt;assigned_regHi() == any_reg, &quot;must not have hi register&quot;);
2089         return LIR_OprFact::single_cpu_oop(assigned_reg);
2090       }
2091 
2092       case T_ADDRESS: {
2093         assert(assigned_reg &gt;= pd_first_cpu_reg &amp;&amp; assigned_reg &lt;= pd_last_cpu_reg, &quot;no cpu register&quot;);
2094         assert(interval-&gt;assigned_regHi() == any_reg, &quot;must not have hi register&quot;);
2095         return LIR_OprFact::single_cpu_address(assigned_reg);
2096       }
2097 
2098       case T_METADATA: {
2099         assert(assigned_reg &gt;= pd_first_cpu_reg &amp;&amp; assigned_reg &lt;= pd_last_cpu_reg, &quot;no cpu register&quot;);
2100         assert(interval-&gt;assigned_regHi() == any_reg, &quot;must not have hi register&quot;);
2101         return LIR_OprFact::single_cpu_metadata(assigned_reg);
2102       }
2103 
2104 #ifdef __SOFTFP__
2105       case T_FLOAT:  // fall through
2106 #endif // __SOFTFP__
2107       case T_INT: {
2108         assert(assigned_reg &gt;= pd_first_cpu_reg &amp;&amp; assigned_reg &lt;= pd_last_cpu_reg, &quot;no cpu register&quot;);
2109         assert(interval-&gt;assigned_regHi() == any_reg, &quot;must not have hi register&quot;);
2110         return LIR_OprFact::single_cpu(assigned_reg);
2111       }
2112 
2113 #ifdef __SOFTFP__
2114       case T_DOUBLE:  // fall through
2115 #endif // __SOFTFP__
2116       case T_LONG: {
2117         int assigned_regHi = interval-&gt;assigned_regHi();
2118         assert(assigned_reg &gt;= pd_first_cpu_reg &amp;&amp; assigned_reg &lt;= pd_last_cpu_reg, &quot;no cpu register&quot;);
2119         assert(num_physical_regs(T_LONG) == 1 ||
2120                (assigned_regHi &gt;= pd_first_cpu_reg &amp;&amp; assigned_regHi &lt;= pd_last_cpu_reg), &quot;no cpu register&quot;);
2121 
2122         assert(assigned_reg != assigned_regHi, &quot;invalid allocation&quot;);
2123         assert(num_physical_regs(T_LONG) == 1 || assigned_reg &lt; assigned_regHi,
2124                &quot;register numbers must be sorted (ensure that e.g. a move from eax,ebx to ebx,eax can not occur)&quot;);
2125         assert((assigned_regHi != any_reg) ^ (num_physical_regs(T_LONG) == 1), &quot;must be match&quot;);
2126         if (requires_adjacent_regs(T_LONG)) {
2127           assert(assigned_reg % 2 == 0 &amp;&amp; assigned_reg + 1 == assigned_regHi, &quot;must be sequential and even&quot;);
2128         }
2129 
2130 #ifdef _LP64
2131         return LIR_OprFact::double_cpu(assigned_reg, assigned_reg);
2132 #else
2133 #if defined(SPARC) || defined(PPC32)
2134         return LIR_OprFact::double_cpu(assigned_regHi, assigned_reg);
2135 #else
2136         return LIR_OprFact::double_cpu(assigned_reg, assigned_regHi);
2137 #endif // SPARC
2138 #endif // LP64
2139       }
2140 
2141 #ifndef __SOFTFP__
2142       case T_FLOAT: {
2143 #ifdef X86
2144         if (UseSSE &gt;= 1) {
2145           int last_xmm_reg = pd_last_xmm_reg;
2146 #ifdef _LP64
2147           if (UseAVX &lt; 3) {
2148             last_xmm_reg = pd_first_xmm_reg + (pd_nof_xmm_regs_frame_map / 2) - 1;
2149           }
<a name="6" id="anc6"></a><span class="line-modified">2150 #endif</span>
2151           assert(assigned_reg &gt;= pd_first_xmm_reg &amp;&amp; assigned_reg &lt;= last_xmm_reg, &quot;no xmm register&quot;);
2152           assert(interval-&gt;assigned_regHi() == any_reg, &quot;must not have hi register&quot;);
2153           return LIR_OprFact::single_xmm(assigned_reg - pd_first_xmm_reg);
2154         }
<a name="7" id="anc7"></a><span class="line-modified">2155 #endif</span>
2156 
2157         assert(assigned_reg &gt;= pd_first_fpu_reg &amp;&amp; assigned_reg &lt;= pd_last_fpu_reg, &quot;no fpu register&quot;);
2158         assert(interval-&gt;assigned_regHi() == any_reg, &quot;must not have hi register&quot;);
2159         return LIR_OprFact::single_fpu(assigned_reg - pd_first_fpu_reg);
2160       }
2161 
2162       case T_DOUBLE: {
2163 #ifdef X86
2164         if (UseSSE &gt;= 2) {
2165           int last_xmm_reg = pd_last_xmm_reg;
2166 #ifdef _LP64
2167           if (UseAVX &lt; 3) {
2168             last_xmm_reg = pd_first_xmm_reg + (pd_nof_xmm_regs_frame_map / 2) - 1;
2169           }
<a name="8" id="anc8"></a><span class="line-modified">2170 #endif</span>
2171           assert(assigned_reg &gt;= pd_first_xmm_reg &amp;&amp; assigned_reg &lt;= last_xmm_reg, &quot;no xmm register&quot;);
2172           assert(interval-&gt;assigned_regHi() == any_reg, &quot;must not have hi register (double xmm values are stored in one register)&quot;);
2173           return LIR_OprFact::double_xmm(assigned_reg - pd_first_xmm_reg);
2174         }
<a name="9" id="anc9"></a><span class="line-modified">2175 #endif</span>
2176 
2177 #ifdef SPARC
2178         assert(assigned_reg &gt;= pd_first_fpu_reg &amp;&amp; assigned_reg &lt;= pd_last_fpu_reg, &quot;no fpu register&quot;);
2179         assert(interval-&gt;assigned_regHi() &gt;= pd_first_fpu_reg &amp;&amp; interval-&gt;assigned_regHi() &lt;= pd_last_fpu_reg, &quot;no fpu register&quot;);
2180         assert(assigned_reg % 2 == 0 &amp;&amp; assigned_reg + 1 == interval-&gt;assigned_regHi(), &quot;must be sequential and even&quot;);
2181         LIR_Opr result = LIR_OprFact::double_fpu(interval-&gt;assigned_regHi() - pd_first_fpu_reg, assigned_reg - pd_first_fpu_reg);
2182 #elif defined(ARM32)
2183         assert(assigned_reg &gt;= pd_first_fpu_reg &amp;&amp; assigned_reg &lt;= pd_last_fpu_reg, &quot;no fpu register&quot;);
2184         assert(interval-&gt;assigned_regHi() &gt;= pd_first_fpu_reg &amp;&amp; interval-&gt;assigned_regHi() &lt;= pd_last_fpu_reg, &quot;no fpu register&quot;);
2185         assert(assigned_reg % 2 == 0 &amp;&amp; assigned_reg + 1 == interval-&gt;assigned_regHi(), &quot;must be sequential and even&quot;);
2186         LIR_Opr result = LIR_OprFact::double_fpu(assigned_reg - pd_first_fpu_reg, interval-&gt;assigned_regHi() - pd_first_fpu_reg);
2187 #else
2188         assert(assigned_reg &gt;= pd_first_fpu_reg &amp;&amp; assigned_reg &lt;= pd_last_fpu_reg, &quot;no fpu register&quot;);
2189         assert(interval-&gt;assigned_regHi() == any_reg, &quot;must not have hi register (double fpu values are stored in one register on Intel)&quot;);
2190         LIR_Opr result = LIR_OprFact::double_fpu(assigned_reg - pd_first_fpu_reg);
2191 #endif
2192         return result;
2193       }
2194 #endif // __SOFTFP__
2195 
2196       default: {
2197         ShouldNotReachHere();
2198         return LIR_OprFact::illegalOpr;
2199       }
2200     }
2201   }
2202 }
2203 
2204 LIR_Opr LinearScan::canonical_spill_opr(Interval* interval) {
2205   assert(interval-&gt;canonical_spill_slot() &gt;= nof_regs, &quot;canonical spill slot not set&quot;);
2206   return LIR_OprFact::stack(interval-&gt;canonical_spill_slot() - nof_regs, interval-&gt;type());
2207 }
2208 
2209 LIR_Opr LinearScan::color_lir_opr(LIR_Opr opr, int op_id, LIR_OpVisitState::OprMode mode) {
2210   assert(opr-&gt;is_virtual(), &quot;should not call this otherwise&quot;);
2211 
2212   Interval* interval = interval_at(opr-&gt;vreg_number());
2213   assert(interval != NULL, &quot;interval must exist&quot;);
2214 
2215   if (op_id != -1) {
2216 #ifdef ASSERT
2217     BlockBegin* block = block_of_op_with_id(op_id);
2218     if (block-&gt;number_of_sux() &lt;= 1 &amp;&amp; op_id == block-&gt;last_lir_instruction_id()) {
2219       // check if spill moves could have been appended at the end of this block, but
2220       // before the branch instruction. So the split child information for this branch would
2221       // be incorrect.
2222       LIR_OpBranch* branch = block-&gt;lir()-&gt;instructions_list()-&gt;last()-&gt;as_OpBranch();
2223       if (branch != NULL) {
2224         if (block-&gt;live_out().at(opr-&gt;vreg_number())) {
2225           assert(branch-&gt;cond() == lir_cond_always, &quot;block does not end with an unconditional jump&quot;);
2226           assert(false, &quot;can&#39;t get split child for the last branch of a block because the information would be incorrect (moves are inserted before the branch in resolve_data_flow)&quot;);
2227         }
2228       }
2229     }
2230 #endif
2231 
2232     // operands are not changed when an interval is split during allocation,
2233     // so search the right interval here
2234     interval = split_child_at_op_id(interval, op_id, mode);
2235   }
2236 
2237   LIR_Opr res = operand_for_interval(interval);
2238 
2239 #ifdef X86
2240   // new semantic for is_last_use: not only set on definite end of interval,
2241   // but also before hole
2242   // This may still miss some cases (e.g. for dead values), but it is not necessary that the
2243   // last use information is completely correct
2244   // information is only needed for fpu stack allocation
2245   if (res-&gt;is_fpu_register()) {
2246     if (opr-&gt;is_last_use() || op_id == interval-&gt;to() || (op_id != -1 &amp;&amp; interval-&gt;has_hole_between(op_id, op_id + 1))) {
2247       assert(op_id == -1 || !is_block_begin(op_id), &quot;holes at begin of block may also result from control flow&quot;);
2248       res = res-&gt;make_last_use();
2249     }
2250   }
2251 #endif
2252 
2253   assert(!gen()-&gt;is_vreg_flag_set(opr-&gt;vreg_number(), LIRGenerator::callee_saved) || !FrameMap::is_caller_save_register(res), &quot;bad allocation&quot;);
2254 
2255   return res;
2256 }
2257 
2258 
2259 #ifdef ASSERT
2260 // some methods used to check correctness of debug information
2261 
2262 void assert_no_register_values(GrowableArray&lt;ScopeValue*&gt;* values) {
2263   if (values == NULL) {
2264     return;
2265   }
2266 
2267   for (int i = 0; i &lt; values-&gt;length(); i++) {
2268     ScopeValue* value = values-&gt;at(i);
2269 
2270     if (value-&gt;is_location()) {
2271       Location location = ((LocationValue*)value)-&gt;location();
2272       assert(location.where() == Location::on_stack, &quot;value is in register&quot;);
2273     }
2274   }
2275 }
2276 
2277 void assert_no_register_values(GrowableArray&lt;MonitorValue*&gt;* values) {
2278   if (values == NULL) {
2279     return;
2280   }
2281 
2282   for (int i = 0; i &lt; values-&gt;length(); i++) {
2283     MonitorValue* value = values-&gt;at(i);
2284 
2285     if (value-&gt;owner()-&gt;is_location()) {
2286       Location location = ((LocationValue*)value-&gt;owner())-&gt;location();
2287       assert(location.where() == Location::on_stack, &quot;owner is in register&quot;);
2288     }
2289     assert(value-&gt;basic_lock().where() == Location::on_stack, &quot;basic_lock is in register&quot;);
2290   }
2291 }
2292 
2293 void assert_equal(Location l1, Location l2) {
2294   assert(l1.where() == l2.where() &amp;&amp; l1.type() == l2.type() &amp;&amp; l1.offset() == l2.offset(), &quot;&quot;);
2295 }
2296 
2297 void assert_equal(ScopeValue* v1, ScopeValue* v2) {
2298   if (v1-&gt;is_location()) {
2299     assert(v2-&gt;is_location(), &quot;&quot;);
2300     assert_equal(((LocationValue*)v1)-&gt;location(), ((LocationValue*)v2)-&gt;location());
2301   } else if (v1-&gt;is_constant_int()) {
2302     assert(v2-&gt;is_constant_int(), &quot;&quot;);
2303     assert(((ConstantIntValue*)v1)-&gt;value() == ((ConstantIntValue*)v2)-&gt;value(), &quot;&quot;);
2304   } else if (v1-&gt;is_constant_double()) {
2305     assert(v2-&gt;is_constant_double(), &quot;&quot;);
2306     assert(((ConstantDoubleValue*)v1)-&gt;value() == ((ConstantDoubleValue*)v2)-&gt;value(), &quot;&quot;);
2307   } else if (v1-&gt;is_constant_long()) {
2308     assert(v2-&gt;is_constant_long(), &quot;&quot;);
2309     assert(((ConstantLongValue*)v1)-&gt;value() == ((ConstantLongValue*)v2)-&gt;value(), &quot;&quot;);
2310   } else if (v1-&gt;is_constant_oop()) {
2311     assert(v2-&gt;is_constant_oop(), &quot;&quot;);
2312     assert(((ConstantOopWriteValue*)v1)-&gt;value() == ((ConstantOopWriteValue*)v2)-&gt;value(), &quot;&quot;);
2313   } else {
2314     ShouldNotReachHere();
2315   }
2316 }
2317 
2318 void assert_equal(MonitorValue* m1, MonitorValue* m2) {
2319   assert_equal(m1-&gt;owner(), m2-&gt;owner());
2320   assert_equal(m1-&gt;basic_lock(), m2-&gt;basic_lock());
2321 }
2322 
2323 void assert_equal(IRScopeDebugInfo* d1, IRScopeDebugInfo* d2) {
2324   assert(d1-&gt;scope() == d2-&gt;scope(), &quot;not equal&quot;);
2325   assert(d1-&gt;bci() == d2-&gt;bci(), &quot;not equal&quot;);
2326 
2327   if (d1-&gt;locals() != NULL) {
2328     assert(d1-&gt;locals() != NULL &amp;&amp; d2-&gt;locals() != NULL, &quot;not equal&quot;);
2329     assert(d1-&gt;locals()-&gt;length() == d2-&gt;locals()-&gt;length(), &quot;not equal&quot;);
2330     for (int i = 0; i &lt; d1-&gt;locals()-&gt;length(); i++) {
2331       assert_equal(d1-&gt;locals()-&gt;at(i), d2-&gt;locals()-&gt;at(i));
2332     }
2333   } else {
2334     assert(d1-&gt;locals() == NULL &amp;&amp; d2-&gt;locals() == NULL, &quot;not equal&quot;);
2335   }
2336 
2337   if (d1-&gt;expressions() != NULL) {
2338     assert(d1-&gt;expressions() != NULL &amp;&amp; d2-&gt;expressions() != NULL, &quot;not equal&quot;);
2339     assert(d1-&gt;expressions()-&gt;length() == d2-&gt;expressions()-&gt;length(), &quot;not equal&quot;);
2340     for (int i = 0; i &lt; d1-&gt;expressions()-&gt;length(); i++) {
2341       assert_equal(d1-&gt;expressions()-&gt;at(i), d2-&gt;expressions()-&gt;at(i));
2342     }
2343   } else {
2344     assert(d1-&gt;expressions() == NULL &amp;&amp; d2-&gt;expressions() == NULL, &quot;not equal&quot;);
2345   }
2346 
2347   if (d1-&gt;monitors() != NULL) {
2348     assert(d1-&gt;monitors() != NULL &amp;&amp; d2-&gt;monitors() != NULL, &quot;not equal&quot;);
2349     assert(d1-&gt;monitors()-&gt;length() == d2-&gt;monitors()-&gt;length(), &quot;not equal&quot;);
2350     for (int i = 0; i &lt; d1-&gt;monitors()-&gt;length(); i++) {
2351       assert_equal(d1-&gt;monitors()-&gt;at(i), d2-&gt;monitors()-&gt;at(i));
2352     }
2353   } else {
2354     assert(d1-&gt;monitors() == NULL &amp;&amp; d2-&gt;monitors() == NULL, &quot;not equal&quot;);
2355   }
2356 
2357   if (d1-&gt;caller() != NULL) {
2358     assert(d1-&gt;caller() != NULL &amp;&amp; d2-&gt;caller() != NULL, &quot;not equal&quot;);
2359     assert_equal(d1-&gt;caller(), d2-&gt;caller());
2360   } else {
2361     assert(d1-&gt;caller() == NULL &amp;&amp; d2-&gt;caller() == NULL, &quot;not equal&quot;);
2362   }
2363 }
2364 
2365 void check_stack_depth(CodeEmitInfo* info, int stack_end) {
2366   if (info-&gt;stack()-&gt;bci() != SynchronizationEntryBCI &amp;&amp; !info-&gt;scope()-&gt;method()-&gt;is_native()) {
2367     Bytecodes::Code code = info-&gt;scope()-&gt;method()-&gt;java_code_at_bci(info-&gt;stack()-&gt;bci());
2368     switch (code) {
2369       case Bytecodes::_ifnull    : // fall through
2370       case Bytecodes::_ifnonnull : // fall through
2371       case Bytecodes::_ifeq      : // fall through
2372       case Bytecodes::_ifne      : // fall through
2373       case Bytecodes::_iflt      : // fall through
2374       case Bytecodes::_ifge      : // fall through
2375       case Bytecodes::_ifgt      : // fall through
2376       case Bytecodes::_ifle      : // fall through
2377       case Bytecodes::_if_icmpeq : // fall through
2378       case Bytecodes::_if_icmpne : // fall through
2379       case Bytecodes::_if_icmplt : // fall through
2380       case Bytecodes::_if_icmpge : // fall through
2381       case Bytecodes::_if_icmpgt : // fall through
2382       case Bytecodes::_if_icmple : // fall through
2383       case Bytecodes::_if_acmpeq : // fall through
2384       case Bytecodes::_if_acmpne :
2385         assert(stack_end &gt;= -Bytecodes::depth(code), &quot;must have non-empty expression stack at if bytecode&quot;);
2386         break;
2387       default:
2388         break;
2389     }
2390   }
2391 }
2392 
2393 #endif // ASSERT
2394 
2395 
2396 IntervalWalker* LinearScan::init_compute_oop_maps() {
2397   // setup lists of potential oops for walking
2398   Interval* oop_intervals;
2399   Interval* non_oop_intervals;
2400 
2401   create_unhandled_lists(&amp;oop_intervals, &amp;non_oop_intervals, is_oop_interval, NULL);
2402 
2403   // intervals that have no oops inside need not to be processed
2404   // to ensure a walking until the last instruction id, add a dummy interval
2405   // with a high operation id
2406   non_oop_intervals = new Interval(any_reg);
2407   non_oop_intervals-&gt;add_range(max_jint - 2, max_jint - 1);
2408 
2409   return new IntervalWalker(this, oop_intervals, non_oop_intervals);
2410 }
2411 
2412 
2413 OopMap* LinearScan::compute_oop_map(IntervalWalker* iw, LIR_Op* op, CodeEmitInfo* info, bool is_call_site) {
2414   TRACE_LINEAR_SCAN(3, tty-&gt;print_cr(&quot;creating oop map at op_id %d&quot;, op-&gt;id()));
2415 
2416   // walk before the current operation -&gt; intervals that start at
2417   // the operation (= output operands of the operation) are not
2418   // included in the oop map
2419   iw-&gt;walk_before(op-&gt;id());
2420 
2421   int frame_size = frame_map()-&gt;framesize();
2422   int arg_count = frame_map()-&gt;oop_map_arg_count();
2423   OopMap* map = new OopMap(frame_size, arg_count);
2424 
2425   // Iterate through active intervals
2426   for (Interval* interval = iw-&gt;active_first(fixedKind); interval != Interval::end(); interval = interval-&gt;next()) {
2427     int assigned_reg = interval-&gt;assigned_reg();
2428 
2429     assert(interval-&gt;current_from() &lt;= op-&gt;id() &amp;&amp; op-&gt;id() &lt;= interval-&gt;current_to(), &quot;interval should not be active otherwise&quot;);
2430     assert(interval-&gt;assigned_regHi() == any_reg, &quot;oop must be single word&quot;);
2431     assert(interval-&gt;reg_num() &gt;= LIR_OprDesc::vreg_base, &quot;fixed interval found&quot;);
2432 
2433     // Check if this range covers the instruction. Intervals that
2434     // start or end at the current operation are not included in the
2435     // oop map, except in the case of patching moves.  For patching
2436     // moves, any intervals which end at this instruction are included
2437     // in the oop map since we may safepoint while doing the patch
2438     // before we&#39;ve consumed the inputs.
2439     if (op-&gt;is_patching() || op-&gt;id() &lt; interval-&gt;current_to()) {
2440 
2441       // caller-save registers must not be included into oop-maps at calls
2442       assert(!is_call_site || assigned_reg &gt;= nof_regs || !is_caller_save(assigned_reg), &quot;interval is in a caller-save register at a call -&gt; register will be overwritten&quot;);
2443 
2444       VMReg name = vm_reg_for_interval(interval);
2445       set_oop(map, name);
2446 
2447       // Spill optimization: when the stack value is guaranteed to be always correct,
2448       // then it must be added to the oop map even if the interval is currently in a register
2449       if (interval-&gt;always_in_memory() &amp;&amp;
2450           op-&gt;id() &gt; interval-&gt;spill_definition_pos() &amp;&amp;
2451           interval-&gt;assigned_reg() != interval-&gt;canonical_spill_slot()) {
2452         assert(interval-&gt;spill_definition_pos() &gt; 0, &quot;position not set correctly&quot;);
2453         assert(interval-&gt;canonical_spill_slot() &gt;= LinearScan::nof_regs, &quot;no spill slot assigned&quot;);
2454         assert(interval-&gt;assigned_reg() &lt; LinearScan::nof_regs, &quot;interval is on stack, so stack slot is registered twice&quot;);
2455 
2456         set_oop(map, frame_map()-&gt;slot_regname(interval-&gt;canonical_spill_slot() - LinearScan::nof_regs));
2457       }
2458     }
2459   }
2460 
2461   // add oops from lock stack
2462   assert(info-&gt;stack() != NULL, &quot;CodeEmitInfo must always have a stack&quot;);
2463   int locks_count = info-&gt;stack()-&gt;total_locks_size();
2464   for (int i = 0; i &lt; locks_count; i++) {
2465     set_oop(map, frame_map()-&gt;monitor_object_regname(i));
2466   }
2467 
2468   return map;
2469 }
2470 
2471 
2472 void LinearScan::compute_oop_map(IntervalWalker* iw, const LIR_OpVisitState &amp;visitor, LIR_Op* op) {
2473   assert(visitor.info_count() &gt; 0, &quot;no oop map needed&quot;);
2474 
2475   // compute oop_map only for first CodeEmitInfo
2476   // because it is (in most cases) equal for all other infos of the same operation
2477   CodeEmitInfo* first_info = visitor.info_at(0);
2478   OopMap* first_oop_map = compute_oop_map(iw, op, first_info, visitor.has_call());
2479 
2480   for (int i = 0; i &lt; visitor.info_count(); i++) {
2481     CodeEmitInfo* info = visitor.info_at(i);
2482     OopMap* oop_map = first_oop_map;
2483 
2484     // compute worst case interpreter size in case of a deoptimization
2485     _compilation-&gt;update_interpreter_frame_size(info-&gt;interpreter_frame_size());
2486 
2487     if (info-&gt;stack()-&gt;locks_size() != first_info-&gt;stack()-&gt;locks_size()) {
2488       // this info has a different number of locks then the precomputed oop map
2489       // (possible for lock and unlock instructions) -&gt; compute oop map with
2490       // correct lock information
2491       oop_map = compute_oop_map(iw, op, info, visitor.has_call());
2492     }
2493 
2494     if (info-&gt;_oop_map == NULL) {
2495       info-&gt;_oop_map = oop_map;
2496     } else {
2497       // a CodeEmitInfo can not be shared between different LIR-instructions
2498       // because interval splitting can occur anywhere between two instructions
2499       // and so the oop maps must be different
2500       // -&gt; check if the already set oop_map is exactly the one calculated for this operation
2501       assert(info-&gt;_oop_map == oop_map, &quot;same CodeEmitInfo used for multiple LIR instructions&quot;);
2502     }
2503   }
2504 }
2505 
2506 
2507 // frequently used constants
2508 // Allocate them with new so they are never destroyed (otherwise, a
2509 // forced exit could destroy these objects while they are still in
2510 // use).
2511 ConstantOopWriteValue* LinearScan::_oop_null_scope_value = new (ResourceObj::C_HEAP, mtCompiler) ConstantOopWriteValue(NULL);
2512 ConstantIntValue*      LinearScan::_int_m1_scope_value = new (ResourceObj::C_HEAP, mtCompiler) ConstantIntValue(-1);
2513 ConstantIntValue*      LinearScan::_int_0_scope_value =  new (ResourceObj::C_HEAP, mtCompiler) ConstantIntValue((jint)0);
2514 ConstantIntValue*      LinearScan::_int_1_scope_value =  new (ResourceObj::C_HEAP, mtCompiler) ConstantIntValue(1);
2515 ConstantIntValue*      LinearScan::_int_2_scope_value =  new (ResourceObj::C_HEAP, mtCompiler) ConstantIntValue(2);
2516 LocationValue*         _illegal_value = new (ResourceObj::C_HEAP, mtCompiler) LocationValue(Location());
2517 
2518 void LinearScan::init_compute_debug_info() {
2519   // cache for frequently used scope values
2520   // (cpu registers and stack slots)
2521   int cache_size = (LinearScan::nof_cpu_regs + frame_map()-&gt;argcount() + max_spills()) * 2;
2522   _scope_value_cache = ScopeValueArray(cache_size, cache_size, NULL);
2523 }
2524 
2525 MonitorValue* LinearScan::location_for_monitor_index(int monitor_index) {
2526   Location loc;
2527   if (!frame_map()-&gt;location_for_monitor_object(monitor_index, &amp;loc)) {
2528     bailout(&quot;too large frame&quot;);
2529   }
2530   ScopeValue* object_scope_value = new LocationValue(loc);
2531 
2532   if (!frame_map()-&gt;location_for_monitor_lock(monitor_index, &amp;loc)) {
2533     bailout(&quot;too large frame&quot;);
2534   }
2535   return new MonitorValue(object_scope_value, loc);
2536 }
2537 
2538 LocationValue* LinearScan::location_for_name(int name, Location::Type loc_type) {
2539   Location loc;
2540   if (!frame_map()-&gt;locations_for_slot(name, loc_type, &amp;loc)) {
2541     bailout(&quot;too large frame&quot;);
2542   }
2543   return new LocationValue(loc);
2544 }
2545 
2546 
2547 int LinearScan::append_scope_value_for_constant(LIR_Opr opr, GrowableArray&lt;ScopeValue*&gt;* scope_values) {
2548   assert(opr-&gt;is_constant(), &quot;should not be called otherwise&quot;);
2549 
2550   LIR_Const* c = opr-&gt;as_constant_ptr();
2551   BasicType t = c-&gt;type();
2552   switch (t) {
2553     case T_OBJECT: {
2554       jobject value = c-&gt;as_jobject();
2555       if (value == NULL) {
2556         scope_values-&gt;append(_oop_null_scope_value);
2557       } else {
2558         scope_values-&gt;append(new ConstantOopWriteValue(c-&gt;as_jobject()));
2559       }
2560       return 1;
2561     }
2562 
2563     case T_INT: // fall through
2564     case T_FLOAT: {
2565       int value = c-&gt;as_jint_bits();
2566       switch (value) {
2567         case -1: scope_values-&gt;append(_int_m1_scope_value); break;
2568         case 0:  scope_values-&gt;append(_int_0_scope_value); break;
2569         case 1:  scope_values-&gt;append(_int_1_scope_value); break;
2570         case 2:  scope_values-&gt;append(_int_2_scope_value); break;
2571         default: scope_values-&gt;append(new ConstantIntValue(c-&gt;as_jint_bits())); break;
2572       }
2573       return 1;
2574     }
2575 
2576     case T_LONG: // fall through
2577     case T_DOUBLE: {
2578 #ifdef _LP64
2579       scope_values-&gt;append(_int_0_scope_value);
2580       scope_values-&gt;append(new ConstantLongValue(c-&gt;as_jlong_bits()));
2581 #else
2582       if (hi_word_offset_in_bytes &gt; lo_word_offset_in_bytes) {
2583         scope_values-&gt;append(new ConstantIntValue(c-&gt;as_jint_hi_bits()));
2584         scope_values-&gt;append(new ConstantIntValue(c-&gt;as_jint_lo_bits()));
2585       } else {
2586         scope_values-&gt;append(new ConstantIntValue(c-&gt;as_jint_lo_bits()));
2587         scope_values-&gt;append(new ConstantIntValue(c-&gt;as_jint_hi_bits()));
2588       }
2589 #endif
2590       return 2;
2591     }
2592 
2593     case T_ADDRESS: {
2594 #ifdef _LP64
2595       scope_values-&gt;append(new ConstantLongValue(c-&gt;as_jint()));
2596 #else
2597       scope_values-&gt;append(new ConstantIntValue(c-&gt;as_jint()));
2598 #endif
2599       return 1;
2600     }
2601 
2602     default:
2603       ShouldNotReachHere();
2604       return -1;
2605   }
2606 }
2607 
2608 int LinearScan::append_scope_value_for_operand(LIR_Opr opr, GrowableArray&lt;ScopeValue*&gt;* scope_values) {
2609   if (opr-&gt;is_single_stack()) {
2610     int stack_idx = opr-&gt;single_stack_ix();
2611     bool is_oop = opr-&gt;is_oop_register();
2612     int cache_idx = (stack_idx + LinearScan::nof_cpu_regs) * 2 + (is_oop ? 1 : 0);
2613 
2614     ScopeValue* sv = _scope_value_cache.at(cache_idx);
2615     if (sv == NULL) {
2616       Location::Type loc_type = is_oop ? Location::oop : Location::normal;
2617       sv = location_for_name(stack_idx, loc_type);
2618       _scope_value_cache.at_put(cache_idx, sv);
2619     }
2620 
2621     // check if cached value is correct
2622     DEBUG_ONLY(assert_equal(sv, location_for_name(stack_idx, is_oop ? Location::oop : Location::normal)));
2623 
2624     scope_values-&gt;append(sv);
2625     return 1;
2626 
2627   } else if (opr-&gt;is_single_cpu()) {
2628     bool is_oop = opr-&gt;is_oop_register();
2629     int cache_idx = opr-&gt;cpu_regnr() * 2 + (is_oop ? 1 : 0);
2630     Location::Type int_loc_type = NOT_LP64(Location::normal) LP64_ONLY(Location::int_in_long);
2631 
2632     ScopeValue* sv = _scope_value_cache.at(cache_idx);
2633     if (sv == NULL) {
2634       Location::Type loc_type = is_oop ? Location::oop : int_loc_type;
2635       VMReg rname = frame_map()-&gt;regname(opr);
2636       sv = new LocationValue(Location::new_reg_loc(loc_type, rname));
2637       _scope_value_cache.at_put(cache_idx, sv);
2638     }
2639 
2640     // check if cached value is correct
2641     DEBUG_ONLY(assert_equal(sv, new LocationValue(Location::new_reg_loc(is_oop ? Location::oop : int_loc_type, frame_map()-&gt;regname(opr)))));
2642 
2643     scope_values-&gt;append(sv);
2644     return 1;
2645 
2646 #ifdef X86
2647   } else if (opr-&gt;is_single_xmm()) {
2648     VMReg rname = opr-&gt;as_xmm_float_reg()-&gt;as_VMReg();
2649     LocationValue* sv = new LocationValue(Location::new_reg_loc(Location::normal, rname));
2650 
2651     scope_values-&gt;append(sv);
2652     return 1;
2653 #endif
2654 
2655   } else if (opr-&gt;is_single_fpu()) {
2656 #ifdef IA32
2657     // the exact location of fpu stack values is only known
2658     // during fpu stack allocation, so the stack allocator object
2659     // must be present
2660     assert(use_fpu_stack_allocation(), &quot;should not have float stack values without fpu stack allocation (all floats must be SSE2)&quot;);
2661     assert(_fpu_stack_allocator != NULL, &quot;must be present&quot;);
2662     opr = _fpu_stack_allocator-&gt;to_fpu_stack(opr);
2663 #elif defined(AMD64)
2664     assert(false, &quot;FPU not used on x86-64&quot;);
2665 #endif
2666 
2667     Location::Type loc_type = float_saved_as_double ? Location::float_in_dbl : Location::normal;
2668     VMReg rname = frame_map()-&gt;fpu_regname(opr-&gt;fpu_regnr());
2669 #ifndef __SOFTFP__
2670 #ifndef VM_LITTLE_ENDIAN
2671     // On S390 a (single precision) float value occupies only the high
2672     // word of the full double register. So when the double register is
2673     // stored to memory (e.g. by the RegisterSaver), then the float value
2674     // is found at offset 0. I.e. the code below is not needed on S390.
2675 #ifndef S390
2676     if (! float_saved_as_double) {
2677       // On big endian system, we may have an issue if float registers use only
2678       // the low half of the (same) double registers.
2679       // Both the float and the double could have the same regnr but would correspond
2680       // to two different addresses once saved.
2681 
2682       // get next safely (no assertion checks)
2683       VMReg next = VMRegImpl::as_VMReg(1+rname-&gt;value());
2684       if (next-&gt;is_reg() &amp;&amp;
2685           (next-&gt;as_FloatRegister() == rname-&gt;as_FloatRegister())) {
2686         // the back-end does use the same numbering for the double and the float
2687         rname = next; // VMReg for the low bits, e.g. the real VMReg for the float
2688       }
2689     }
2690 #endif // !S390
2691 #endif
2692 #endif
2693     LocationValue* sv = new LocationValue(Location::new_reg_loc(loc_type, rname));
2694 
2695     scope_values-&gt;append(sv);
2696     return 1;
2697 
2698   } else {
2699     // double-size operands
2700 
2701     ScopeValue* first;
2702     ScopeValue* second;
2703 
2704     if (opr-&gt;is_double_stack()) {
2705 #ifdef _LP64
2706       Location loc1;
2707       Location::Type loc_type = opr-&gt;type() == T_LONG ? Location::lng : Location::dbl;
2708       if (!frame_map()-&gt;locations_for_slot(opr-&gt;double_stack_ix(), loc_type, &amp;loc1, NULL)) {
2709         bailout(&quot;too large frame&quot;);
2710       }
2711       // Does this reverse on x86 vs. sparc?
2712       first =  new LocationValue(loc1);
2713       second = _int_0_scope_value;
2714 #else
2715       Location loc1, loc2;
2716       if (!frame_map()-&gt;locations_for_slot(opr-&gt;double_stack_ix(), Location::normal, &amp;loc1, &amp;loc2)) {
2717         bailout(&quot;too large frame&quot;);
2718       }
2719       first =  new LocationValue(loc1);
2720       second = new LocationValue(loc2);
2721 #endif // _LP64
2722 
2723     } else if (opr-&gt;is_double_cpu()) {
2724 #ifdef _LP64
2725       VMReg rname_first = opr-&gt;as_register_lo()-&gt;as_VMReg();
2726       first = new LocationValue(Location::new_reg_loc(Location::lng, rname_first));
2727       second = _int_0_scope_value;
2728 #else
2729       VMReg rname_first = opr-&gt;as_register_lo()-&gt;as_VMReg();
2730       VMReg rname_second = opr-&gt;as_register_hi()-&gt;as_VMReg();
2731 
2732       if (hi_word_offset_in_bytes &lt; lo_word_offset_in_bytes) {
2733         // lo/hi and swapped relative to first and second, so swap them
2734         VMReg tmp = rname_first;
2735         rname_first = rname_second;
2736         rname_second = tmp;
2737       }
2738 
2739       first = new LocationValue(Location::new_reg_loc(Location::normal, rname_first));
2740       second = new LocationValue(Location::new_reg_loc(Location::normal, rname_second));
2741 #endif //_LP64
2742 
2743 
2744 #ifdef X86
2745     } else if (opr-&gt;is_double_xmm()) {
2746       assert(opr-&gt;fpu_regnrLo() == opr-&gt;fpu_regnrHi(), &quot;assumed in calculation&quot;);
2747       VMReg rname_first  = opr-&gt;as_xmm_double_reg()-&gt;as_VMReg();
2748 #  ifdef _LP64
2749       first = new LocationValue(Location::new_reg_loc(Location::dbl, rname_first));
2750       second = _int_0_scope_value;
2751 #  else
2752       first = new LocationValue(Location::new_reg_loc(Location::normal, rname_first));
2753       // %%% This is probably a waste but we&#39;ll keep things as they were for now
2754       if (true) {
2755         VMReg rname_second = rname_first-&gt;next();
2756         second = new LocationValue(Location::new_reg_loc(Location::normal, rname_second));
2757       }
2758 #  endif
2759 #endif
2760 
2761     } else if (opr-&gt;is_double_fpu()) {
2762       // On SPARC, fpu_regnrLo/fpu_regnrHi represents the two halves of
2763       // the double as float registers in the native ordering. On X86,
2764       // fpu_regnrLo is a FPU stack slot whose VMReg represents
2765       // the low-order word of the double and fpu_regnrLo + 1 is the
2766       // name for the other half.  *first and *second must represent the
2767       // least and most significant words, respectively.
2768 
2769 #ifdef IA32
2770       // the exact location of fpu stack values is only known
2771       // during fpu stack allocation, so the stack allocator object
2772       // must be present
2773       assert(use_fpu_stack_allocation(), &quot;should not have float stack values without fpu stack allocation (all floats must be SSE2)&quot;);
2774       assert(_fpu_stack_allocator != NULL, &quot;must be present&quot;);
2775       opr = _fpu_stack_allocator-&gt;to_fpu_stack(opr);
2776 
2777       assert(opr-&gt;fpu_regnrLo() == opr-&gt;fpu_regnrHi(), &quot;assumed in calculation (only fpu_regnrLo is used)&quot;);
2778 #endif
2779 #ifdef AMD64
2780       assert(false, &quot;FPU not used on x86-64&quot;);
2781 #endif
2782 #ifdef SPARC
2783       assert(opr-&gt;fpu_regnrLo() == opr-&gt;fpu_regnrHi() + 1, &quot;assumed in calculation (only fpu_regnrHi is used)&quot;);
2784 #endif
2785 #ifdef ARM32
2786       assert(opr-&gt;fpu_regnrHi() == opr-&gt;fpu_regnrLo() + 1, &quot;assumed in calculation (only fpu_regnrLo is used)&quot;);
2787 #endif
2788 #ifdef PPC32
2789       assert(opr-&gt;fpu_regnrLo() == opr-&gt;fpu_regnrHi(), &quot;assumed in calculation (only fpu_regnrHi is used)&quot;);
2790 #endif
2791 
2792 #ifdef VM_LITTLE_ENDIAN
2793       VMReg rname_first = frame_map()-&gt;fpu_regname(opr-&gt;fpu_regnrLo());
2794 #else
2795       VMReg rname_first = frame_map()-&gt;fpu_regname(opr-&gt;fpu_regnrHi());
2796 #endif
2797 
2798 #ifdef _LP64
2799       first = new LocationValue(Location::new_reg_loc(Location::dbl, rname_first));
2800       second = _int_0_scope_value;
2801 #else
2802       first = new LocationValue(Location::new_reg_loc(Location::normal, rname_first));
2803       // %%% This is probably a waste but we&#39;ll keep things as they were for now
2804       if (true) {
2805         VMReg rname_second = rname_first-&gt;next();
2806         second = new LocationValue(Location::new_reg_loc(Location::normal, rname_second));
2807       }
2808 #endif
2809 
2810     } else {
2811       ShouldNotReachHere();
2812       first = NULL;
2813       second = NULL;
2814     }
2815 
2816     assert(first != NULL &amp;&amp; second != NULL, &quot;must be set&quot;);
2817     // The convention the interpreter uses is that the second local
2818     // holds the first raw word of the native double representation.
2819     // This is actually reasonable, since locals and stack arrays
2820     // grow downwards in all implementations.
2821     // (If, on some machine, the interpreter&#39;s Java locals or stack
2822     // were to grow upwards, the embedded doubles would be word-swapped.)
2823     scope_values-&gt;append(second);
2824     scope_values-&gt;append(first);
2825     return 2;
2826   }
2827 }
2828 
2829 
2830 int LinearScan::append_scope_value(int op_id, Value value, GrowableArray&lt;ScopeValue*&gt;* scope_values) {
2831   if (value != NULL) {
2832     LIR_Opr opr = value-&gt;operand();
2833     Constant* con = value-&gt;as_Constant();
2834 
2835     assert(con == NULL || opr-&gt;is_virtual() || opr-&gt;is_constant() || opr-&gt;is_illegal(), &quot;asumption: Constant instructions have only constant operands (or illegal if constant is optimized away)&quot;);
2836     assert(con != NULL || opr-&gt;is_virtual(), &quot;asumption: non-Constant instructions have only virtual operands&quot;);
2837 
2838     if (con != NULL &amp;&amp; !con-&gt;is_pinned() &amp;&amp; !opr-&gt;is_constant()) {
2839       // Unpinned constants may have a virtual operand for a part of the lifetime
2840       // or may be illegal when it was optimized away,
2841       // so always use a constant operand
2842       opr = LIR_OprFact::value_type(con-&gt;type());
2843     }
2844     assert(opr-&gt;is_virtual() || opr-&gt;is_constant(), &quot;other cases not allowed here&quot;);
2845 
2846     if (opr-&gt;is_virtual()) {
2847       LIR_OpVisitState::OprMode mode = LIR_OpVisitState::inputMode;
2848 
2849       BlockBegin* block = block_of_op_with_id(op_id);
2850       if (block-&gt;number_of_sux() == 1 &amp;&amp; op_id == block-&gt;last_lir_instruction_id()) {
2851         // generating debug information for the last instruction of a block.
2852         // if this instruction is a branch, spill moves are inserted before this branch
2853         // and so the wrong operand would be returned (spill moves at block boundaries are not
2854         // considered in the live ranges of intervals)
2855         // Solution: use the first op_id of the branch target block instead.
2856         if (block-&gt;lir()-&gt;instructions_list()-&gt;last()-&gt;as_OpBranch() != NULL) {
2857           if (block-&gt;live_out().at(opr-&gt;vreg_number())) {
2858             op_id = block-&gt;sux_at(0)-&gt;first_lir_instruction_id();
2859             mode = LIR_OpVisitState::outputMode;
2860           }
2861         }
2862       }
2863 
2864       // Get current location of operand
2865       // The operand must be live because debug information is considered when building the intervals
2866       // if the interval is not live, color_lir_opr will cause an assertion failure
2867       opr = color_lir_opr(opr, op_id, mode);
2868       assert(!has_call(op_id) || opr-&gt;is_stack() || !is_caller_save(reg_num(opr)), &quot;can not have caller-save register operands at calls&quot;);
2869 
2870       // Append to ScopeValue array
2871       return append_scope_value_for_operand(opr, scope_values);
2872 
2873     } else {
2874       assert(value-&gt;as_Constant() != NULL, &quot;all other instructions have only virtual operands&quot;);
2875       assert(opr-&gt;is_constant(), &quot;operand must be constant&quot;);
2876 
2877       return append_scope_value_for_constant(opr, scope_values);
2878     }
2879   } else {
2880     // append a dummy value because real value not needed
2881     scope_values-&gt;append(_illegal_value);
2882     return 1;
2883   }
2884 }
2885 
2886 
2887 IRScopeDebugInfo* LinearScan::compute_debug_info_for_scope(int op_id, IRScope* cur_scope, ValueStack* cur_state, ValueStack* innermost_state) {
2888   IRScopeDebugInfo* caller_debug_info = NULL;
2889 
2890   ValueStack* caller_state = cur_state-&gt;caller_state();
2891   if (caller_state != NULL) {
2892     // process recursively to compute outermost scope first
2893     caller_debug_info = compute_debug_info_for_scope(op_id, cur_scope-&gt;caller(), caller_state, innermost_state);
2894   }
2895 
2896   // initialize these to null.
2897   // If we don&#39;t need deopt info or there are no locals, expressions or monitors,
2898   // then these get recorded as no information and avoids the allocation of 0 length arrays.
2899   GrowableArray&lt;ScopeValue*&gt;*   locals      = NULL;
2900   GrowableArray&lt;ScopeValue*&gt;*   expressions = NULL;
2901   GrowableArray&lt;MonitorValue*&gt;* monitors    = NULL;
2902 
2903   // describe local variable values
2904   int nof_locals = cur_state-&gt;locals_size();
2905   if (nof_locals &gt; 0) {
2906     locals = new GrowableArray&lt;ScopeValue*&gt;(nof_locals);
2907 
2908     int pos = 0;
2909     while (pos &lt; nof_locals) {
2910       assert(pos &lt; cur_state-&gt;locals_size(), &quot;why not?&quot;);
2911 
2912       Value local = cur_state-&gt;local_at(pos);
2913       pos += append_scope_value(op_id, local, locals);
2914 
2915       assert(locals-&gt;length() == pos, &quot;must match&quot;);
2916     }
2917     assert(locals-&gt;length() == cur_scope-&gt;method()-&gt;max_locals(), &quot;wrong number of locals&quot;);
2918     assert(locals-&gt;length() == cur_state-&gt;locals_size(), &quot;wrong number of locals&quot;);
2919   } else if (cur_scope-&gt;method()-&gt;max_locals() &gt; 0) {
2920     assert(cur_state-&gt;kind() == ValueStack::EmptyExceptionState, &quot;should be&quot;);
2921     nof_locals = cur_scope-&gt;method()-&gt;max_locals();
2922     locals = new GrowableArray&lt;ScopeValue*&gt;(nof_locals);
2923     for(int i = 0; i &lt; nof_locals; i++) {
2924       locals-&gt;append(_illegal_value);
2925     }
2926   }
2927 
2928   // describe expression stack
2929   int nof_stack = cur_state-&gt;stack_size();
2930   if (nof_stack &gt; 0) {
2931     expressions = new GrowableArray&lt;ScopeValue*&gt;(nof_stack);
2932 
2933     int pos = 0;
2934     while (pos &lt; nof_stack) {
2935       Value expression = cur_state-&gt;stack_at_inc(pos);
2936       append_scope_value(op_id, expression, expressions);
2937 
2938       assert(expressions-&gt;length() == pos, &quot;must match&quot;);
2939     }
2940     assert(expressions-&gt;length() == cur_state-&gt;stack_size(), &quot;wrong number of stack entries&quot;);
2941   }
2942 
2943   // describe monitors
2944   int nof_locks = cur_state-&gt;locks_size();
2945   if (nof_locks &gt; 0) {
2946     int lock_offset = cur_state-&gt;caller_state() != NULL ? cur_state-&gt;caller_state()-&gt;total_locks_size() : 0;
2947     monitors = new GrowableArray&lt;MonitorValue*&gt;(nof_locks);
2948     for (int i = 0; i &lt; nof_locks; i++) {
2949       monitors-&gt;append(location_for_monitor_index(lock_offset + i));
2950     }
2951   }
2952 
2953   return new IRScopeDebugInfo(cur_scope, cur_state-&gt;bci(), locals, expressions, monitors, caller_debug_info);
2954 }
2955 
2956 
2957 void LinearScan::compute_debug_info(CodeEmitInfo* info, int op_id) {
2958   TRACE_LINEAR_SCAN(3, tty-&gt;print_cr(&quot;creating debug information at op_id %d&quot;, op_id));
2959 
2960   IRScope* innermost_scope = info-&gt;scope();
2961   ValueStack* innermost_state = info-&gt;stack();
2962 
2963   assert(innermost_scope != NULL &amp;&amp; innermost_state != NULL, &quot;why is it missing?&quot;);
2964 
2965   DEBUG_ONLY(check_stack_depth(info, innermost_state-&gt;stack_size()));
2966 
2967   if (info-&gt;_scope_debug_info == NULL) {
2968     // compute debug information
2969     info-&gt;_scope_debug_info = compute_debug_info_for_scope(op_id, innermost_scope, innermost_state, innermost_state);
2970   } else {
2971     // debug information already set. Check that it is correct from the current point of view
2972     DEBUG_ONLY(assert_equal(info-&gt;_scope_debug_info, compute_debug_info_for_scope(op_id, innermost_scope, innermost_state, innermost_state)));
2973   }
2974 }
2975 
2976 
2977 void LinearScan::assign_reg_num(LIR_OpList* instructions, IntervalWalker* iw) {
2978   LIR_OpVisitState visitor;
2979   int num_inst = instructions-&gt;length();
2980   bool has_dead = false;
2981 
2982   for (int j = 0; j &lt; num_inst; j++) {
2983     LIR_Op* op = instructions-&gt;at(j);
2984     if (op == NULL) {  // this can happen when spill-moves are removed in eliminate_spill_moves
2985       has_dead = true;
2986       continue;
2987     }
2988     int op_id = op-&gt;id();
2989 
2990     // visit instruction to get list of operands
2991     visitor.visit(op);
2992 
2993     // iterate all modes of the visitor and process all virtual operands
2994     for_each_visitor_mode(mode) {
2995       int n = visitor.opr_count(mode);
2996       for (int k = 0; k &lt; n; k++) {
2997         LIR_Opr opr = visitor.opr_at(mode, k);
2998         if (opr-&gt;is_virtual_register()) {
2999           visitor.set_opr_at(mode, k, color_lir_opr(opr, op_id, mode));
3000         }
3001       }
3002     }
3003 
3004     if (visitor.info_count() &gt; 0) {
3005       // exception handling
3006       if (compilation()-&gt;has_exception_handlers()) {
3007         XHandlers* xhandlers = visitor.all_xhandler();
3008         int n = xhandlers-&gt;length();
3009         for (int k = 0; k &lt; n; k++) {
3010           XHandler* handler = xhandlers-&gt;handler_at(k);
3011           if (handler-&gt;entry_code() != NULL) {
3012             assign_reg_num(handler-&gt;entry_code()-&gt;instructions_list(), NULL);
3013           }
3014         }
3015       } else {
3016         assert(visitor.all_xhandler()-&gt;length() == 0, &quot;missed exception handler&quot;);
3017       }
3018 
3019       // compute oop map
3020       assert(iw != NULL, &quot;needed for compute_oop_map&quot;);
3021       compute_oop_map(iw, visitor, op);
3022 
3023       // compute debug information
3024       if (!use_fpu_stack_allocation()) {
3025         // compute debug information if fpu stack allocation is not needed.
3026         // when fpu stack allocation is needed, the debug information can not
3027         // be computed here because the exact location of fpu operands is not known
3028         // -&gt; debug information is created inside the fpu stack allocator
3029         int n = visitor.info_count();
3030         for (int k = 0; k &lt; n; k++) {
3031           compute_debug_info(visitor.info_at(k), op_id);
3032         }
3033       }
3034     }
3035 
3036 #ifdef ASSERT
3037     // make sure we haven&#39;t made the op invalid.
3038     op-&gt;verify();
3039 #endif
3040 
3041     // remove useless moves
3042     if (op-&gt;code() == lir_move) {
3043       assert(op-&gt;as_Op1() != NULL, &quot;move must be LIR_Op1&quot;);
3044       LIR_Op1* move = (LIR_Op1*)op;
3045       LIR_Opr src = move-&gt;in_opr();
3046       LIR_Opr dst = move-&gt;result_opr();
3047       if (dst == src ||
3048           (!dst-&gt;is_pointer() &amp;&amp; !src-&gt;is_pointer() &amp;&amp;
3049            src-&gt;is_same_register(dst))) {
3050         instructions-&gt;at_put(j, NULL);
3051         has_dead = true;
3052       }
3053     }
3054   }
3055 
3056   if (has_dead) {
3057     // iterate all instructions of the block and remove all null-values.
3058     int insert_point = 0;
3059     for (int j = 0; j &lt; num_inst; j++) {
3060       LIR_Op* op = instructions-&gt;at(j);
3061       if (op != NULL) {
3062         if (insert_point != j) {
3063           instructions-&gt;at_put(insert_point, op);
3064         }
3065         insert_point++;
3066       }
3067     }
3068     instructions-&gt;trunc_to(insert_point);
3069   }
3070 }
3071 
3072 void LinearScan::assign_reg_num() {
3073   TIME_LINEAR_SCAN(timer_assign_reg_num);
3074 
3075   init_compute_debug_info();
3076   IntervalWalker* iw = init_compute_oop_maps();
3077 
3078   int num_blocks = block_count();
3079   for (int i = 0; i &lt; num_blocks; i++) {
3080     BlockBegin* block = block_at(i);
3081     assign_reg_num(block-&gt;lir()-&gt;instructions_list(), iw);
3082   }
3083 }
3084 
3085 
3086 void LinearScan::do_linear_scan() {
3087   NOT_PRODUCT(_total_timer.begin_method());
3088 
3089   number_instructions();
3090 
3091   NOT_PRODUCT(print_lir(1, &quot;Before Register Allocation&quot;));
3092 
3093   compute_local_live_sets();
3094   compute_global_live_sets();
3095   CHECK_BAILOUT();
3096 
3097   build_intervals();
3098   CHECK_BAILOUT();
3099   sort_intervals_before_allocation();
3100 
3101   NOT_PRODUCT(print_intervals(&quot;Before Register Allocation&quot;));
3102   NOT_PRODUCT(LinearScanStatistic::compute(this, _stat_before_alloc));
3103 
3104   allocate_registers();
3105   CHECK_BAILOUT();
3106 
3107   resolve_data_flow();
3108   if (compilation()-&gt;has_exception_handlers()) {
3109     resolve_exception_handlers();
3110   }
3111   // fill in number of spill slots into frame_map
3112   propagate_spill_slots();
3113   CHECK_BAILOUT();
3114 
3115   NOT_PRODUCT(print_intervals(&quot;After Register Allocation&quot;));
3116   NOT_PRODUCT(print_lir(2, &quot;LIR after register allocation:&quot;));
3117 
3118   sort_intervals_after_allocation();
3119 
3120   DEBUG_ONLY(verify());
3121 
3122   eliminate_spill_moves();
3123   assign_reg_num();
3124   CHECK_BAILOUT();
3125 
3126   NOT_PRODUCT(print_lir(2, &quot;LIR after assignment of register numbers:&quot;));
3127   NOT_PRODUCT(LinearScanStatistic::compute(this, _stat_after_asign));
3128 
3129   { TIME_LINEAR_SCAN(timer_allocate_fpu_stack);
3130 
3131     if (use_fpu_stack_allocation()) {
3132       allocate_fpu_stack(); // Only has effect on Intel
3133       NOT_PRODUCT(print_lir(2, &quot;LIR after FPU stack allocation:&quot;));
3134     }
3135   }
3136 
3137   { TIME_LINEAR_SCAN(timer_optimize_lir);
3138 
3139     EdgeMoveOptimizer::optimize(ir()-&gt;code());
3140     ControlFlowOptimizer::optimize(ir()-&gt;code());
3141     // check that cfg is still correct after optimizations
3142     ir()-&gt;verify();
3143   }
3144 
3145   NOT_PRODUCT(print_lir(1, &quot;Before Code Generation&quot;, false));
3146   NOT_PRODUCT(LinearScanStatistic::compute(this, _stat_final));
3147   NOT_PRODUCT(_total_timer.end_method(this));
3148 }
3149 
3150 
3151 // ********** Printing functions
3152 
3153 #ifndef PRODUCT
3154 
3155 void LinearScan::print_timers(double total) {
3156   _total_timer.print(total);
3157 }
3158 
3159 void LinearScan::print_statistics() {
3160   _stat_before_alloc.print(&quot;before allocation&quot;);
3161   _stat_after_asign.print(&quot;after assignment of register&quot;);
3162   _stat_final.print(&quot;after optimization&quot;);
3163 }
3164 
3165 void LinearScan::print_bitmap(BitMap&amp; b) {
3166   for (unsigned int i = 0; i &lt; b.size(); i++) {
3167     if (b.at(i)) tty-&gt;print(&quot;%d &quot;, i);
3168   }
3169   tty-&gt;cr();
3170 }
3171 
3172 void LinearScan::print_intervals(const char* label) {
3173   if (TraceLinearScanLevel &gt;= 1) {
3174     int i;
3175     tty-&gt;cr();
3176     tty-&gt;print_cr(&quot;%s&quot;, label);
3177 
3178     for (i = 0; i &lt; interval_count(); i++) {
3179       Interval* interval = interval_at(i);
3180       if (interval != NULL) {
3181         interval-&gt;print();
3182       }
3183     }
3184 
3185     tty-&gt;cr();
3186     tty-&gt;print_cr(&quot;--- Basic Blocks ---&quot;);
3187     for (i = 0; i &lt; block_count(); i++) {
3188       BlockBegin* block = block_at(i);
3189       tty-&gt;print(&quot;B%d [%d, %d, %d, %d] &quot;, block-&gt;block_id(), block-&gt;first_lir_instruction_id(), block-&gt;last_lir_instruction_id(), block-&gt;loop_index(), block-&gt;loop_depth());
3190     }
3191     tty-&gt;cr();
3192     tty-&gt;cr();
3193   }
3194 
3195   if (PrintCFGToFile) {
3196     CFGPrinter::print_intervals(&amp;_intervals, label);
3197   }
3198 }
3199 
3200 void LinearScan::print_lir(int level, const char* label, bool hir_valid) {
3201   if (TraceLinearScanLevel &gt;= level) {
3202     tty-&gt;cr();
3203     tty-&gt;print_cr(&quot;%s&quot;, label);
3204     print_LIR(ir()-&gt;linear_scan_order());
3205     tty-&gt;cr();
3206   }
3207 
3208   if (level == 1 &amp;&amp; PrintCFGToFile) {
3209     CFGPrinter::print_cfg(ir()-&gt;linear_scan_order(), label, hir_valid, true);
3210   }
3211 }
3212 
3213 #endif //PRODUCT
3214 
3215 
3216 // ********** verification functions for allocation
3217 // (check that all intervals have a correct register and that no registers are overwritten)
3218 #ifdef ASSERT
3219 
3220 void LinearScan::verify() {
3221   TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;********* verifying intervals ******************************************&quot;));
3222   verify_intervals();
3223 
3224   TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;********* verifying that no oops are in fixed intervals ****************&quot;));
3225   verify_no_oops_in_fixed_intervals();
3226 
3227   TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;********* verifying that unpinned constants are not alive across block boundaries&quot;));
3228   verify_constants();
3229 
3230   TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;********* verifying register allocation ********************************&quot;));
3231   verify_registers();
3232 
3233   TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;********* no errors found **********************************************&quot;));
3234 }
3235 
3236 void LinearScan::verify_intervals() {
3237   int len = interval_count();
3238   bool has_error = false;
3239 
3240   for (int i = 0; i &lt; len; i++) {
3241     Interval* i1 = interval_at(i);
3242     if (i1 == NULL) continue;
3243 
3244     i1-&gt;check_split_children();
3245 
3246     if (i1-&gt;reg_num() != i) {
3247       tty-&gt;print_cr(&quot;Interval %d is on position %d in list&quot;, i1-&gt;reg_num(), i); i1-&gt;print(); tty-&gt;cr();
3248       has_error = true;
3249     }
3250 
3251     if (i1-&gt;reg_num() &gt;= LIR_OprDesc::vreg_base &amp;&amp; i1-&gt;type() == T_ILLEGAL) {
3252       tty-&gt;print_cr(&quot;Interval %d has no type assigned&quot;, i1-&gt;reg_num()); i1-&gt;print(); tty-&gt;cr();
3253       has_error = true;
3254     }
3255 
3256     if (i1-&gt;assigned_reg() == any_reg) {
3257       tty-&gt;print_cr(&quot;Interval %d has no register assigned&quot;, i1-&gt;reg_num()); i1-&gt;print(); tty-&gt;cr();
3258       has_error = true;
3259     }
3260 
3261     if (i1-&gt;assigned_reg() == i1-&gt;assigned_regHi()) {
3262       tty-&gt;print_cr(&quot;Interval %d: low and high register equal&quot;, i1-&gt;reg_num()); i1-&gt;print(); tty-&gt;cr();
3263       has_error = true;
3264     }
3265 
3266     if (!is_processed_reg_num(i1-&gt;assigned_reg())) {
3267       tty-&gt;print_cr(&quot;Can not have an Interval for an ignored register&quot;); i1-&gt;print(); tty-&gt;cr();
3268       has_error = true;
3269     }
3270 
3271     // special intervals that are created in MoveResolver
3272     // -&gt; ignore them because the range information has no meaning there
3273     if (i1-&gt;from() == 1 &amp;&amp; i1-&gt;to() == 2) continue;
3274 
3275     if (i1-&gt;first() == Range::end()) {
3276       tty-&gt;print_cr(&quot;Interval %d has no Range&quot;, i1-&gt;reg_num()); i1-&gt;print(); tty-&gt;cr();
3277       has_error = true;
3278     }
3279 
3280     for (Range* r = i1-&gt;first(); r != Range::end(); r = r-&gt;next()) {
3281       if (r-&gt;from() &gt;= r-&gt;to()) {
3282         tty-&gt;print_cr(&quot;Interval %d has zero length range&quot;, i1-&gt;reg_num()); i1-&gt;print(); tty-&gt;cr();
3283         has_error = true;
3284       }
3285     }
3286 
3287     for (int j = i + 1; j &lt; len; j++) {
3288       Interval* i2 = interval_at(j);
3289       if (i2 == NULL || (i2-&gt;from() == 1 &amp;&amp; i2-&gt;to() == 2)) continue;
3290 
3291       int r1 = i1-&gt;assigned_reg();
3292       int r1Hi = i1-&gt;assigned_regHi();
3293       int r2 = i2-&gt;assigned_reg();
3294       int r2Hi = i2-&gt;assigned_regHi();
3295       if ((r1 == r2 || r1 == r2Hi || (r1Hi != any_reg &amp;&amp; (r1Hi == r2 || r1Hi == r2Hi))) &amp;&amp; i1-&gt;intersects(i2)) {
3296         tty-&gt;print_cr(&quot;Intervals %d and %d overlap and have the same register assigned&quot;, i1-&gt;reg_num(), i2-&gt;reg_num());
3297         i1-&gt;print(); tty-&gt;cr();
3298         i2-&gt;print(); tty-&gt;cr();
3299         has_error = true;
3300       }
3301     }
3302   }
3303 
3304   assert(has_error == false, &quot;register allocation invalid&quot;);
3305 }
3306 
3307 
3308 void LinearScan::verify_no_oops_in_fixed_intervals() {
3309   Interval* fixed_intervals;
3310   Interval* other_intervals;
3311   create_unhandled_lists(&amp;fixed_intervals, &amp;other_intervals, is_precolored_cpu_interval, NULL);
3312 
3313   // to ensure a walking until the last instruction id, add a dummy interval
3314   // with a high operation id
3315   other_intervals = new Interval(any_reg);
3316   other_intervals-&gt;add_range(max_jint - 2, max_jint - 1);
3317   IntervalWalker* iw = new IntervalWalker(this, fixed_intervals, other_intervals);
3318 
3319   LIR_OpVisitState visitor;
3320   for (int i = 0; i &lt; block_count(); i++) {
3321     BlockBegin* block = block_at(i);
3322 
3323     LIR_OpList* instructions = block-&gt;lir()-&gt;instructions_list();
3324 
3325     for (int j = 0; j &lt; instructions-&gt;length(); j++) {
3326       LIR_Op* op = instructions-&gt;at(j);
3327       int op_id = op-&gt;id();
3328 
3329       visitor.visit(op);
3330 
3331       if (visitor.info_count() &gt; 0) {
3332         iw-&gt;walk_before(op-&gt;id());
3333         bool check_live = true;
3334         if (op-&gt;code() == lir_move) {
3335           LIR_Op1* move = (LIR_Op1*)op;
3336           check_live = (move-&gt;patch_code() == lir_patch_none);
3337         }
3338         LIR_OpBranch* branch = op-&gt;as_OpBranch();
3339         if (branch != NULL &amp;&amp; branch-&gt;stub() != NULL &amp;&amp; branch-&gt;stub()-&gt;is_exception_throw_stub()) {
3340           // Don&#39;t bother checking the stub in this case since the
3341           // exception stub will never return to normal control flow.
3342           check_live = false;
3343         }
3344 
3345         // Make sure none of the fixed registers is live across an
3346         // oopmap since we can&#39;t handle that correctly.
3347         if (check_live) {
3348           for (Interval* interval = iw-&gt;active_first(fixedKind);
3349                interval != Interval::end();
3350                interval = interval-&gt;next()) {
3351             if (interval-&gt;current_to() &gt; op-&gt;id() + 1) {
3352               // This interval is live out of this op so make sure
3353               // that this interval represents some value that&#39;s
3354               // referenced by this op either as an input or output.
3355               bool ok = false;
3356               for_each_visitor_mode(mode) {
3357                 int n = visitor.opr_count(mode);
3358                 for (int k = 0; k &lt; n; k++) {
3359                   LIR_Opr opr = visitor.opr_at(mode, k);
3360                   if (opr-&gt;is_fixed_cpu()) {
3361                     if (interval_at(reg_num(opr)) == interval) {
3362                       ok = true;
3363                       break;
3364                     }
3365                     int hi = reg_numHi(opr);
3366                     if (hi != -1 &amp;&amp; interval_at(hi) == interval) {
3367                       ok = true;
3368                       break;
3369                     }
3370                   }
3371                 }
3372               }
3373               assert(ok, &quot;fixed intervals should never be live across an oopmap point&quot;);
3374             }
3375           }
3376         }
3377       }
3378 
3379       // oop-maps at calls do not contain registers, so check is not needed
3380       if (!visitor.has_call()) {
3381 
3382         for_each_visitor_mode(mode) {
3383           int n = visitor.opr_count(mode);
3384           for (int k = 0; k &lt; n; k++) {
3385             LIR_Opr opr = visitor.opr_at(mode, k);
3386 
3387             if (opr-&gt;is_fixed_cpu() &amp;&amp; opr-&gt;is_oop()) {
3388               // operand is a non-virtual cpu register and contains an oop
3389               TRACE_LINEAR_SCAN(4, op-&gt;print_on(tty); tty-&gt;print(&quot;checking operand &quot;); opr-&gt;print(); tty-&gt;cr());
3390 
3391               Interval* interval = interval_at(reg_num(opr));
3392               assert(interval != NULL, &quot;no interval&quot;);
3393 
3394               if (mode == LIR_OpVisitState::inputMode) {
3395                 if (interval-&gt;to() &gt;= op_id + 1) {
3396                   assert(interval-&gt;to() &lt; op_id + 2 ||
3397                          interval-&gt;has_hole_between(op_id, op_id + 2),
3398                          &quot;oop input operand live after instruction&quot;);
3399                 }
3400               } else if (mode == LIR_OpVisitState::outputMode) {
3401                 if (interval-&gt;from() &lt;= op_id - 1) {
3402                   assert(interval-&gt;has_hole_between(op_id - 1, op_id),
3403                          &quot;oop input operand live after instruction&quot;);
3404                 }
3405               }
3406             }
3407           }
3408         }
3409       }
3410     }
3411   }
3412 }
3413 
3414 
3415 void LinearScan::verify_constants() {
3416   int num_regs = num_virtual_regs();
3417   int size = live_set_size();
3418   int num_blocks = block_count();
3419 
3420   for (int i = 0; i &lt; num_blocks; i++) {
3421     BlockBegin* block = block_at(i);
3422     ResourceBitMap live_at_edge = block-&gt;live_in();
3423 
3424     // visit all registers where the live_at_edge bit is set
3425     for (int r = (int)live_at_edge.get_next_one_offset(0, size); r &lt; size; r = (int)live_at_edge.get_next_one_offset(r + 1, size)) {
3426       TRACE_LINEAR_SCAN(4, tty-&gt;print(&quot;checking interval %d of block B%d&quot;, r, block-&gt;block_id()));
3427 
3428       Value value = gen()-&gt;instruction_for_vreg(r);
3429 
3430       assert(value != NULL, &quot;all intervals live across block boundaries must have Value&quot;);
3431       assert(value-&gt;operand()-&gt;is_register() &amp;&amp; value-&gt;operand()-&gt;is_virtual(), &quot;value must have virtual operand&quot;);
3432       assert(value-&gt;operand()-&gt;vreg_number() == r, &quot;register number must match&quot;);
3433       // TKR assert(value-&gt;as_Constant() == NULL || value-&gt;is_pinned(), &quot;only pinned constants can be alive accross block boundaries&quot;);
3434     }
3435   }
3436 }
3437 
3438 
3439 class RegisterVerifier: public StackObj {
3440  private:
3441   LinearScan*   _allocator;
3442   BlockList     _work_list;      // all blocks that must be processed
3443   IntervalsList _saved_states;   // saved information of previous check
3444 
3445   // simplified access to methods of LinearScan
3446   Compilation*  compilation() const              { return _allocator-&gt;compilation(); }
3447   Interval*     interval_at(int reg_num) const   { return _allocator-&gt;interval_at(reg_num); }
3448   int           reg_num(LIR_Opr opr) const       { return _allocator-&gt;reg_num(opr); }
3449 
3450   // currently, only registers are processed
3451   int           state_size()                     { return LinearScan::nof_regs; }
3452 
3453   // accessors
3454   IntervalList* state_for_block(BlockBegin* block) { return _saved_states.at(block-&gt;block_id()); }
3455   void          set_state_for_block(BlockBegin* block, IntervalList* saved_state) { _saved_states.at_put(block-&gt;block_id(), saved_state); }
3456   void          add_to_work_list(BlockBegin* block) { if (!_work_list.contains(block)) _work_list.append(block); }
3457 
3458   // helper functions
3459   IntervalList* copy(IntervalList* input_state);
3460   void          state_put(IntervalList* input_state, int reg, Interval* interval);
3461   bool          check_state(IntervalList* input_state, int reg, Interval* interval);
3462 
3463   void process_block(BlockBegin* block);
3464   void process_xhandler(XHandler* xhandler, IntervalList* input_state);
3465   void process_successor(BlockBegin* block, IntervalList* input_state);
3466   void process_operations(LIR_List* ops, IntervalList* input_state);
3467 
3468  public:
3469   RegisterVerifier(LinearScan* allocator)
3470     : _allocator(allocator)
3471     , _work_list(16)
3472     , _saved_states(BlockBegin::number_of_blocks(), BlockBegin::number_of_blocks(), NULL)
3473   { }
3474 
3475   void verify(BlockBegin* start);
3476 };
3477 
3478 
3479 // entry function from LinearScan that starts the verification
3480 void LinearScan::verify_registers() {
3481   RegisterVerifier verifier(this);
3482   verifier.verify(block_at(0));
3483 }
3484 
3485 
3486 void RegisterVerifier::verify(BlockBegin* start) {
3487   // setup input registers (method arguments) for first block
3488   int input_state_len = state_size();
3489   IntervalList* input_state = new IntervalList(input_state_len, input_state_len, NULL);
3490   CallingConvention* args = compilation()-&gt;frame_map()-&gt;incoming_arguments();
3491   for (int n = 0; n &lt; args-&gt;length(); n++) {
3492     LIR_Opr opr = args-&gt;at(n);
3493     if (opr-&gt;is_register()) {
3494       Interval* interval = interval_at(reg_num(opr));
3495 
3496       if (interval-&gt;assigned_reg() &lt; state_size()) {
3497         input_state-&gt;at_put(interval-&gt;assigned_reg(), interval);
3498       }
3499       if (interval-&gt;assigned_regHi() != LinearScan::any_reg &amp;&amp; interval-&gt;assigned_regHi() &lt; state_size()) {
3500         input_state-&gt;at_put(interval-&gt;assigned_regHi(), interval);
3501       }
3502     }
3503   }
3504 
3505   set_state_for_block(start, input_state);
3506   add_to_work_list(start);
3507 
3508   // main loop for verification
3509   do {
3510     BlockBegin* block = _work_list.at(0);
3511     _work_list.remove_at(0);
3512 
3513     process_block(block);
3514   } while (!_work_list.is_empty());
3515 }
3516 
3517 void RegisterVerifier::process_block(BlockBegin* block) {
3518   TRACE_LINEAR_SCAN(2, tty-&gt;cr(); tty-&gt;print_cr(&quot;process_block B%d&quot;, block-&gt;block_id()));
3519 
3520   // must copy state because it is modified
3521   IntervalList* input_state = copy(state_for_block(block));
3522 
3523   if (TraceLinearScanLevel &gt;= 4) {
3524     tty-&gt;print_cr(&quot;Input-State of intervals:&quot;);
3525     tty-&gt;print(&quot;    &quot;);
3526     for (int i = 0; i &lt; state_size(); i++) {
3527       if (input_state-&gt;at(i) != NULL) {
3528         tty-&gt;print(&quot; %4d&quot;, input_state-&gt;at(i)-&gt;reg_num());
3529       } else {
3530         tty-&gt;print(&quot;   __&quot;);
3531       }
3532     }
3533     tty-&gt;cr();
3534     tty-&gt;cr();
3535   }
3536 
3537   // process all operations of the block
3538   process_operations(block-&gt;lir(), input_state);
3539 
3540   // iterate all successors
3541   for (int i = 0; i &lt; block-&gt;number_of_sux(); i++) {
3542     process_successor(block-&gt;sux_at(i), input_state);
3543   }
3544 }
3545 
3546 void RegisterVerifier::process_xhandler(XHandler* xhandler, IntervalList* input_state) {
3547   TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;process_xhandler B%d&quot;, xhandler-&gt;entry_block()-&gt;block_id()));
3548 
3549   // must copy state because it is modified
3550   input_state = copy(input_state);
3551 
3552   if (xhandler-&gt;entry_code() != NULL) {
3553     process_operations(xhandler-&gt;entry_code(), input_state);
3554   }
3555   process_successor(xhandler-&gt;entry_block(), input_state);
3556 }
3557 
3558 void RegisterVerifier::process_successor(BlockBegin* block, IntervalList* input_state) {
3559   IntervalList* saved_state = state_for_block(block);
3560 
3561   if (saved_state != NULL) {
3562     // this block was already processed before.
3563     // check if new input_state is consistent with saved_state
3564 
3565     bool saved_state_correct = true;
3566     for (int i = 0; i &lt; state_size(); i++) {
3567       if (input_state-&gt;at(i) != saved_state-&gt;at(i)) {
3568         // current input_state and previous saved_state assume a different
3569         // interval in this register -&gt; assume that this register is invalid
3570         if (saved_state-&gt;at(i) != NULL) {
3571           // invalidate old calculation only if it assumed that
3572           // register was valid. when the register was already invalid,
3573           // then the old calculation was correct.
3574           saved_state_correct = false;
3575           saved_state-&gt;at_put(i, NULL);
3576 
3577           TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;process_successor B%d: invalidating slot %d&quot;, block-&gt;block_id(), i));
3578         }
3579       }
3580     }
3581 
3582     if (saved_state_correct) {
3583       // already processed block with correct input_state
3584       TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;process_successor B%d: previous visit already correct&quot;, block-&gt;block_id()));
3585     } else {
3586       // must re-visit this block
3587       TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;process_successor B%d: must re-visit because input state changed&quot;, block-&gt;block_id()));
3588       add_to_work_list(block);
3589     }
3590 
3591   } else {
3592     // block was not processed before, so set initial input_state
3593     TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;process_successor B%d: initial visit&quot;, block-&gt;block_id()));
3594 
3595     set_state_for_block(block, copy(input_state));
3596     add_to_work_list(block);
3597   }
3598 }
3599 
3600 
3601 IntervalList* RegisterVerifier::copy(IntervalList* input_state) {
3602   IntervalList* copy_state = new IntervalList(input_state-&gt;length());
3603   copy_state-&gt;appendAll(input_state);
3604   return copy_state;
3605 }
3606 
3607 void RegisterVerifier::state_put(IntervalList* input_state, int reg, Interval* interval) {
3608   if (reg != LinearScan::any_reg &amp;&amp; reg &lt; state_size()) {
3609     if (interval != NULL) {
3610       TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;        reg[%d] = %d&quot;, reg, interval-&gt;reg_num()));
3611     } else if (input_state-&gt;at(reg) != NULL) {
3612       TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;        reg[%d] = NULL&quot;, reg));
3613     }
3614 
3615     input_state-&gt;at_put(reg, interval);
3616   }
3617 }
3618 
3619 bool RegisterVerifier::check_state(IntervalList* input_state, int reg, Interval* interval) {
3620   if (reg != LinearScan::any_reg &amp;&amp; reg &lt; state_size()) {
3621     if (input_state-&gt;at(reg) != interval) {
3622       tty-&gt;print_cr(&quot;!! Error in register allocation: register %d does not contain interval %d&quot;, reg, interval-&gt;reg_num());
3623       return true;
3624     }
3625   }
3626   return false;
3627 }
3628 
3629 void RegisterVerifier::process_operations(LIR_List* ops, IntervalList* input_state) {
3630   // visit all instructions of the block
3631   LIR_OpVisitState visitor;
3632   bool has_error = false;
3633 
3634   for (int i = 0; i &lt; ops-&gt;length(); i++) {
3635     LIR_Op* op = ops-&gt;at(i);
3636     visitor.visit(op);
3637 
3638     TRACE_LINEAR_SCAN(4, op-&gt;print_on(tty));
3639 
3640     // check if input operands are correct
3641     int j;
3642     int n = visitor.opr_count(LIR_OpVisitState::inputMode);
3643     for (j = 0; j &lt; n; j++) {
3644       LIR_Opr opr = visitor.opr_at(LIR_OpVisitState::inputMode, j);
3645       if (opr-&gt;is_register() &amp;&amp; LinearScan::is_processed_reg_num(reg_num(opr))) {
3646         Interval* interval = interval_at(reg_num(opr));
3647         if (op-&gt;id() != -1) {
3648           interval = interval-&gt;split_child_at_op_id(op-&gt;id(), LIR_OpVisitState::inputMode);
3649         }
3650 
3651         has_error |= check_state(input_state, interval-&gt;assigned_reg(),   interval-&gt;split_parent());
3652         has_error |= check_state(input_state, interval-&gt;assigned_regHi(), interval-&gt;split_parent());
3653 
3654         // When an operand is marked with is_last_use, then the fpu stack allocator
3655         // removes the register from the fpu stack -&gt; the register contains no value
3656         if (opr-&gt;is_last_use()) {
3657           state_put(input_state, interval-&gt;assigned_reg(),   NULL);
3658           state_put(input_state, interval-&gt;assigned_regHi(), NULL);
3659         }
3660       }
3661     }
3662 
3663     // invalidate all caller save registers at calls
3664     if (visitor.has_call()) {
3665       for (j = 0; j &lt; FrameMap::nof_caller_save_cpu_regs(); j++) {
3666         state_put(input_state, reg_num(FrameMap::caller_save_cpu_reg_at(j)), NULL);
3667       }
3668       for (j = 0; j &lt; FrameMap::nof_caller_save_fpu_regs; j++) {
3669         state_put(input_state, reg_num(FrameMap::caller_save_fpu_reg_at(j)), NULL);
3670       }
3671 
3672 #ifdef X86
3673       int num_caller_save_xmm_regs = FrameMap::get_num_caller_save_xmms();
3674       for (j = 0; j &lt; num_caller_save_xmm_regs; j++) {
3675         state_put(input_state, reg_num(FrameMap::caller_save_xmm_reg_at(j)), NULL);
3676       }
3677 #endif
3678     }
3679 
3680     // process xhandler before output and temp operands
3681     XHandlers* xhandlers = visitor.all_xhandler();
3682     n = xhandlers-&gt;length();
3683     for (int k = 0; k &lt; n; k++) {
3684       process_xhandler(xhandlers-&gt;handler_at(k), input_state);
3685     }
3686 
3687     // set temp operands (some operations use temp operands also as output operands, so can&#39;t set them NULL)
3688     n = visitor.opr_count(LIR_OpVisitState::tempMode);
3689     for (j = 0; j &lt; n; j++) {
3690       LIR_Opr opr = visitor.opr_at(LIR_OpVisitState::tempMode, j);
3691       if (opr-&gt;is_register() &amp;&amp; LinearScan::is_processed_reg_num(reg_num(opr))) {
3692         Interval* interval = interval_at(reg_num(opr));
3693         if (op-&gt;id() != -1) {
3694           interval = interval-&gt;split_child_at_op_id(op-&gt;id(), LIR_OpVisitState::tempMode);
3695         }
3696 
3697         state_put(input_state, interval-&gt;assigned_reg(),   interval-&gt;split_parent());
3698         state_put(input_state, interval-&gt;assigned_regHi(), interval-&gt;split_parent());
3699       }
3700     }
3701 
3702     // set output operands
3703     n = visitor.opr_count(LIR_OpVisitState::outputMode);
3704     for (j = 0; j &lt; n; j++) {
3705       LIR_Opr opr = visitor.opr_at(LIR_OpVisitState::outputMode, j);
3706       if (opr-&gt;is_register() &amp;&amp; LinearScan::is_processed_reg_num(reg_num(opr))) {
3707         Interval* interval = interval_at(reg_num(opr));
3708         if (op-&gt;id() != -1) {
3709           interval = interval-&gt;split_child_at_op_id(op-&gt;id(), LIR_OpVisitState::outputMode);
3710         }
3711 
3712         state_put(input_state, interval-&gt;assigned_reg(),   interval-&gt;split_parent());
3713         state_put(input_state, interval-&gt;assigned_regHi(), interval-&gt;split_parent());
3714       }
3715     }
3716   }
3717   assert(has_error == false, &quot;Error in register allocation&quot;);
3718 }
3719 
3720 #endif // ASSERT
3721 
3722 
3723 
3724 // **** Implementation of MoveResolver ******************************
3725 
3726 MoveResolver::MoveResolver(LinearScan* allocator) :
3727   _allocator(allocator),
3728   _insert_list(NULL),
3729   _insert_idx(-1),
3730   _insertion_buffer(),
3731   _mapping_from(8),
3732   _mapping_from_opr(8),
3733   _mapping_to(8),
3734   _multiple_reads_allowed(false)
3735 {
3736   for (int i = 0; i &lt; LinearScan::nof_regs; i++) {
3737     _register_blocked[i] = 0;
3738   }
3739   DEBUG_ONLY(check_empty());
3740 }
3741 
3742 
3743 #ifdef ASSERT
3744 
3745 void MoveResolver::check_empty() {
3746   assert(_mapping_from.length() == 0 &amp;&amp; _mapping_from_opr.length() == 0 &amp;&amp; _mapping_to.length() == 0, &quot;list must be empty before and after processing&quot;);
3747   for (int i = 0; i &lt; LinearScan::nof_regs; i++) {
3748     assert(register_blocked(i) == 0, &quot;register map must be empty before and after processing&quot;);
3749   }
3750   assert(_multiple_reads_allowed == false, &quot;must have default value&quot;);
3751 }
3752 
3753 void MoveResolver::verify_before_resolve() {
3754   assert(_mapping_from.length() == _mapping_from_opr.length(), &quot;length must be equal&quot;);
3755   assert(_mapping_from.length() == _mapping_to.length(), &quot;length must be equal&quot;);
3756   assert(_insert_list != NULL &amp;&amp; _insert_idx != -1, &quot;insert position not set&quot;);
3757 
3758   int i, j;
3759   if (!_multiple_reads_allowed) {
3760     for (i = 0; i &lt; _mapping_from.length(); i++) {
3761       for (j = i + 1; j &lt; _mapping_from.length(); j++) {
3762         assert(_mapping_from.at(i) == NULL || _mapping_from.at(i) != _mapping_from.at(j), &quot;cannot read from same interval twice&quot;);
3763       }
3764     }
3765   }
3766 
3767   for (i = 0; i &lt; _mapping_to.length(); i++) {
3768     for (j = i + 1; j &lt; _mapping_to.length(); j++) {
3769       assert(_mapping_to.at(i) != _mapping_to.at(j), &quot;cannot write to same interval twice&quot;);
3770     }
3771   }
3772 
3773 
3774   ResourceBitMap used_regs(LinearScan::nof_regs + allocator()-&gt;frame_map()-&gt;argcount() + allocator()-&gt;max_spills());
3775   if (!_multiple_reads_allowed) {
3776     for (i = 0; i &lt; _mapping_from.length(); i++) {
3777       Interval* it = _mapping_from.at(i);
3778       if (it != NULL) {
3779         assert(!used_regs.at(it-&gt;assigned_reg()), &quot;cannot read from same register twice&quot;);
3780         used_regs.set_bit(it-&gt;assigned_reg());
3781 
3782         if (it-&gt;assigned_regHi() != LinearScan::any_reg) {
3783           assert(!used_regs.at(it-&gt;assigned_regHi()), &quot;cannot read from same register twice&quot;);
3784           used_regs.set_bit(it-&gt;assigned_regHi());
3785         }
3786       }
3787     }
3788   }
3789 
3790   used_regs.clear();
3791   for (i = 0; i &lt; _mapping_to.length(); i++) {
3792     Interval* it = _mapping_to.at(i);
3793     assert(!used_regs.at(it-&gt;assigned_reg()), &quot;cannot write to same register twice&quot;);
3794     used_regs.set_bit(it-&gt;assigned_reg());
3795 
3796     if (it-&gt;assigned_regHi() != LinearScan::any_reg) {
3797       assert(!used_regs.at(it-&gt;assigned_regHi()), &quot;cannot write to same register twice&quot;);
3798       used_regs.set_bit(it-&gt;assigned_regHi());
3799     }
3800   }
3801 
3802   used_regs.clear();
3803   for (i = 0; i &lt; _mapping_from.length(); i++) {
3804     Interval* it = _mapping_from.at(i);
3805     if (it != NULL &amp;&amp; it-&gt;assigned_reg() &gt;= LinearScan::nof_regs) {
3806       used_regs.set_bit(it-&gt;assigned_reg());
3807     }
3808   }
3809   for (i = 0; i &lt; _mapping_to.length(); i++) {
3810     Interval* it = _mapping_to.at(i);
3811     assert(!used_regs.at(it-&gt;assigned_reg()) || it-&gt;assigned_reg() == _mapping_from.at(i)-&gt;assigned_reg(), &quot;stack slots used in _mapping_from must be disjoint to _mapping_to&quot;);
3812   }
3813 }
3814 
3815 #endif // ASSERT
3816 
3817 
3818 // mark assigned_reg and assigned_regHi of the interval as blocked
3819 void MoveResolver::block_registers(Interval* it) {
3820   int reg = it-&gt;assigned_reg();
3821   if (reg &lt; LinearScan::nof_regs) {
3822     assert(_multiple_reads_allowed || register_blocked(reg) == 0, &quot;register already marked as used&quot;);
3823     set_register_blocked(reg, 1);
3824   }
3825   reg = it-&gt;assigned_regHi();
3826   if (reg != LinearScan::any_reg &amp;&amp; reg &lt; LinearScan::nof_regs) {
3827     assert(_multiple_reads_allowed || register_blocked(reg) == 0, &quot;register already marked as used&quot;);
3828     set_register_blocked(reg, 1);
3829   }
3830 }
3831 
3832 // mark assigned_reg and assigned_regHi of the interval as unblocked
3833 void MoveResolver::unblock_registers(Interval* it) {
3834   int reg = it-&gt;assigned_reg();
3835   if (reg &lt; LinearScan::nof_regs) {
3836     assert(register_blocked(reg) &gt; 0, &quot;register already marked as unused&quot;);
3837     set_register_blocked(reg, -1);
3838   }
3839   reg = it-&gt;assigned_regHi();
3840   if (reg != LinearScan::any_reg &amp;&amp; reg &lt; LinearScan::nof_regs) {
3841     assert(register_blocked(reg) &gt; 0, &quot;register already marked as unused&quot;);
3842     set_register_blocked(reg, -1);
3843   }
3844 }
3845 
3846 // check if assigned_reg and assigned_regHi of the to-interval are not blocked (or only blocked by from)
3847 bool MoveResolver::save_to_process_move(Interval* from, Interval* to) {
3848   int from_reg = -1;
3849   int from_regHi = -1;
3850   if (from != NULL) {
3851     from_reg = from-&gt;assigned_reg();
3852     from_regHi = from-&gt;assigned_regHi();
3853   }
3854 
3855   int reg = to-&gt;assigned_reg();
3856   if (reg &lt; LinearScan::nof_regs) {
3857     if (register_blocked(reg) &gt; 1 || (register_blocked(reg) == 1 &amp;&amp; reg != from_reg &amp;&amp; reg != from_regHi)) {
3858       return false;
3859     }
3860   }
3861   reg = to-&gt;assigned_regHi();
3862   if (reg != LinearScan::any_reg &amp;&amp; reg &lt; LinearScan::nof_regs) {
3863     if (register_blocked(reg) &gt; 1 || (register_blocked(reg) == 1 &amp;&amp; reg != from_reg &amp;&amp; reg != from_regHi)) {
3864       return false;
3865     }
3866   }
3867 
3868   return true;
3869 }
3870 
3871 
3872 void MoveResolver::create_insertion_buffer(LIR_List* list) {
3873   assert(!_insertion_buffer.initialized(), &quot;overwriting existing buffer&quot;);
3874   _insertion_buffer.init(list);
3875 }
3876 
3877 void MoveResolver::append_insertion_buffer() {
3878   if (_insertion_buffer.initialized()) {
3879     _insertion_buffer.lir_list()-&gt;append(&amp;_insertion_buffer);
3880   }
3881   assert(!_insertion_buffer.initialized(), &quot;must be uninitialized now&quot;);
3882 
3883   _insert_list = NULL;
3884   _insert_idx = -1;
3885 }
3886 
3887 void MoveResolver::insert_move(Interval* from_interval, Interval* to_interval) {
3888   assert(from_interval-&gt;reg_num() != to_interval-&gt;reg_num(), &quot;from and to interval equal&quot;);
3889   assert(from_interval-&gt;type() == to_interval-&gt;type(), &quot;move between different types&quot;);
3890   assert(_insert_list != NULL &amp;&amp; _insert_idx != -1, &quot;must setup insert position first&quot;);
3891   assert(_insertion_buffer.lir_list() == _insert_list, &quot;wrong insertion buffer&quot;);
3892 
3893   LIR_Opr from_opr = LIR_OprFact::virtual_register(from_interval-&gt;reg_num(), from_interval-&gt;type());
3894   LIR_Opr to_opr = LIR_OprFact::virtual_register(to_interval-&gt;reg_num(), to_interval-&gt;type());
3895 
3896   if (!_multiple_reads_allowed) {
3897     // the last_use flag is an optimization for FPU stack allocation. When the same
3898     // input interval is used in more than one move, then it is too difficult to determine
3899     // if this move is really the last use.
3900     from_opr = from_opr-&gt;make_last_use();
3901   }
3902   _insertion_buffer.move(_insert_idx, from_opr, to_opr);
3903 
3904   TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;MoveResolver: inserted move from register %d (%d, %d) to %d (%d, %d)&quot;, from_interval-&gt;reg_num(), from_interval-&gt;assigned_reg(), from_interval-&gt;assigned_regHi(), to_interval-&gt;reg_num(), to_interval-&gt;assigned_reg(), to_interval-&gt;assigned_regHi()));
3905 }
3906 
3907 void MoveResolver::insert_move(LIR_Opr from_opr, Interval* to_interval) {
3908   assert(from_opr-&gt;type() == to_interval-&gt;type(), &quot;move between different types&quot;);
3909   assert(_insert_list != NULL &amp;&amp; _insert_idx != -1, &quot;must setup insert position first&quot;);
3910   assert(_insertion_buffer.lir_list() == _insert_list, &quot;wrong insertion buffer&quot;);
3911 
3912   LIR_Opr to_opr = LIR_OprFact::virtual_register(to_interval-&gt;reg_num(), to_interval-&gt;type());
3913   _insertion_buffer.move(_insert_idx, from_opr, to_opr);
3914 
3915   TRACE_LINEAR_SCAN(4, tty-&gt;print(&quot;MoveResolver: inserted move from constant &quot;); from_opr-&gt;print(); tty-&gt;print_cr(&quot;  to %d (%d, %d)&quot;, to_interval-&gt;reg_num(), to_interval-&gt;assigned_reg(), to_interval-&gt;assigned_regHi()));
3916 }
3917 
3918 
3919 void MoveResolver::resolve_mappings() {
3920   TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;MoveResolver: resolving mappings for Block B%d, index %d&quot;, _insert_list-&gt;block() != NULL ? _insert_list-&gt;block()-&gt;block_id() : -1, _insert_idx));
3921   DEBUG_ONLY(verify_before_resolve());
3922 
3923   // Block all registers that are used as input operands of a move.
3924   // When a register is blocked, no move to this register is emitted.
3925   // This is necessary for detecting cycles in moves.
3926   int i;
3927   for (i = _mapping_from.length() - 1; i &gt;= 0; i--) {
3928     Interval* from_interval = _mapping_from.at(i);
3929     if (from_interval != NULL) {
3930       block_registers(from_interval);
3931     }
3932   }
3933 
3934   int spill_candidate = -1;
3935   while (_mapping_from.length() &gt; 0) {
3936     bool processed_interval = false;
3937 
3938     for (i = _mapping_from.length() - 1; i &gt;= 0; i--) {
3939       Interval* from_interval = _mapping_from.at(i);
3940       Interval* to_interval = _mapping_to.at(i);
3941 
3942       if (save_to_process_move(from_interval, to_interval)) {
3943         // this inverval can be processed because target is free
3944         if (from_interval != NULL) {
3945           insert_move(from_interval, to_interval);
3946           unblock_registers(from_interval);
3947         } else {
3948           insert_move(_mapping_from_opr.at(i), to_interval);
3949         }
3950         _mapping_from.remove_at(i);
3951         _mapping_from_opr.remove_at(i);
3952         _mapping_to.remove_at(i);
3953 
3954         processed_interval = true;
3955       } else if (from_interval != NULL &amp;&amp; from_interval-&gt;assigned_reg() &lt; LinearScan::nof_regs) {
3956         // this interval cannot be processed now because target is not free
3957         // it starts in a register, so it is a possible candidate for spilling
3958         spill_candidate = i;
3959       }
3960     }
3961 
3962     if (!processed_interval) {
3963       // no move could be processed because there is a cycle in the move list
3964       // (e.g. r1 -&gt; r2, r2 -&gt; r1), so one interval must be spilled to memory
3965       guarantee(spill_candidate != -1, &quot;no interval in register for spilling found&quot;);
3966 
3967       // create a new spill interval and assign a stack slot to it
3968       Interval* from_interval = _mapping_from.at(spill_candidate);
3969       Interval* spill_interval = new Interval(-1);
3970       spill_interval-&gt;set_type(from_interval-&gt;type());
3971 
3972       // add a dummy range because real position is difficult to calculate
3973       // Note: this range is a special case when the integrity of the allocation is checked
3974       spill_interval-&gt;add_range(1, 2);
3975 
3976       //       do not allocate a new spill slot for temporary interval, but
3977       //       use spill slot assigned to from_interval. Otherwise moves from
3978       //       one stack slot to another can happen (not allowed by LIR_Assembler
3979       int spill_slot = from_interval-&gt;canonical_spill_slot();
3980       if (spill_slot &lt; 0) {
3981         spill_slot = allocator()-&gt;allocate_spill_slot(type2spill_size[spill_interval-&gt;type()] == 2);
3982         from_interval-&gt;set_canonical_spill_slot(spill_slot);
3983       }
3984       spill_interval-&gt;assign_reg(spill_slot);
3985       allocator()-&gt;append_interval(spill_interval);
3986 
3987       TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;created new Interval %d for spilling&quot;, spill_interval-&gt;reg_num()));
3988 
3989       // insert a move from register to stack and update the mapping
3990       insert_move(from_interval, spill_interval);
3991       _mapping_from.at_put(spill_candidate, spill_interval);
3992       unblock_registers(from_interval);
3993     }
3994   }
3995 
3996   // reset to default value
3997   _multiple_reads_allowed = false;
3998 
3999   // check that all intervals have been processed
4000   DEBUG_ONLY(check_empty());
4001 }
4002 
4003 
4004 void MoveResolver::set_insert_position(LIR_List* insert_list, int insert_idx) {
4005   TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;MoveResolver: setting insert position to Block B%d, index %d&quot;, insert_list-&gt;block() != NULL ? insert_list-&gt;block()-&gt;block_id() : -1, insert_idx));
4006   assert(_insert_list == NULL &amp;&amp; _insert_idx == -1, &quot;use move_insert_position instead of set_insert_position when data already set&quot;);
4007 
4008   create_insertion_buffer(insert_list);
4009   _insert_list = insert_list;
4010   _insert_idx = insert_idx;
4011 }
4012 
4013 void MoveResolver::move_insert_position(LIR_List* insert_list, int insert_idx) {
4014   TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;MoveResolver: moving insert position to Block B%d, index %d&quot;, insert_list-&gt;block() != NULL ? insert_list-&gt;block()-&gt;block_id() : -1, insert_idx));
4015 
4016   if (_insert_list != NULL &amp;&amp; (insert_list != _insert_list || insert_idx != _insert_idx)) {
4017     // insert position changed -&gt; resolve current mappings
4018     resolve_mappings();
4019   }
4020 
4021   if (insert_list != _insert_list) {
4022     // block changed -&gt; append insertion_buffer because it is
4023     // bound to a specific block and create a new insertion_buffer
4024     append_insertion_buffer();
4025     create_insertion_buffer(insert_list);
4026   }
4027 
4028   _insert_list = insert_list;
4029   _insert_idx = insert_idx;
4030 }
4031 
4032 void MoveResolver::add_mapping(Interval* from_interval, Interval* to_interval) {
4033   TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;MoveResolver: adding mapping from %d (%d, %d) to %d (%d, %d)&quot;, from_interval-&gt;reg_num(), from_interval-&gt;assigned_reg(), from_interval-&gt;assigned_regHi(), to_interval-&gt;reg_num(), to_interval-&gt;assigned_reg(), to_interval-&gt;assigned_regHi()));
4034 
4035   _mapping_from.append(from_interval);
4036   _mapping_from_opr.append(LIR_OprFact::illegalOpr);
4037   _mapping_to.append(to_interval);
4038 }
4039 
4040 
4041 void MoveResolver::add_mapping(LIR_Opr from_opr, Interval* to_interval) {
4042   TRACE_LINEAR_SCAN(4, tty-&gt;print(&quot;MoveResolver: adding mapping from &quot;); from_opr-&gt;print(); tty-&gt;print_cr(&quot; to %d (%d, %d)&quot;, to_interval-&gt;reg_num(), to_interval-&gt;assigned_reg(), to_interval-&gt;assigned_regHi()));
4043   assert(from_opr-&gt;is_constant(), &quot;only for constants&quot;);
4044 
4045   _mapping_from.append(NULL);
4046   _mapping_from_opr.append(from_opr);
4047   _mapping_to.append(to_interval);
4048 }
4049 
4050 void MoveResolver::resolve_and_append_moves() {
4051   if (has_mappings()) {
4052     resolve_mappings();
4053   }
4054   append_insertion_buffer();
4055 }
4056 
4057 
4058 
4059 // **** Implementation of Range *************************************
4060 
4061 Range::Range(int from, int to, Range* next) :
4062   _from(from),
4063   _to(to),
4064   _next(next)
4065 {
4066 }
4067 
4068 // initialize sentinel
4069 Range* Range::_end = NULL;
4070 void Range::initialize(Arena* arena) {
4071   _end = new (arena) Range(max_jint, max_jint, NULL);
4072 }
4073 
4074 int Range::intersects_at(Range* r2) const {
4075   const Range* r1 = this;
4076 
4077   assert(r1 != NULL &amp;&amp; r2 != NULL, &quot;null ranges not allowed&quot;);
4078   assert(r1 != _end &amp;&amp; r2 != _end, &quot;empty ranges not allowed&quot;);
4079 
4080   do {
4081     if (r1-&gt;from() &lt; r2-&gt;from()) {
4082       if (r1-&gt;to() &lt;= r2-&gt;from()) {
4083         r1 = r1-&gt;next(); if (r1 == _end) return -1;
4084       } else {
4085         return r2-&gt;from();
4086       }
4087     } else if (r2-&gt;from() &lt; r1-&gt;from()) {
4088       if (r2-&gt;to() &lt;= r1-&gt;from()) {
4089         r2 = r2-&gt;next(); if (r2 == _end) return -1;
4090       } else {
4091         return r1-&gt;from();
4092       }
4093     } else { // r1-&gt;from() == r2-&gt;from()
4094       if (r1-&gt;from() == r1-&gt;to()) {
4095         r1 = r1-&gt;next(); if (r1 == _end) return -1;
4096       } else if (r2-&gt;from() == r2-&gt;to()) {
4097         r2 = r2-&gt;next(); if (r2 == _end) return -1;
4098       } else {
4099         return r1-&gt;from();
4100       }
4101     }
4102   } while (true);
4103 }
4104 
4105 #ifndef PRODUCT
4106 void Range::print(outputStream* out) const {
4107   out-&gt;print(&quot;[%d, %d[ &quot;, _from, _to);
4108 }
4109 #endif
4110 
4111 
4112 
4113 // **** Implementation of Interval **********************************
4114 
4115 // initialize sentinel
4116 Interval* Interval::_end = NULL;
4117 void Interval::initialize(Arena* arena) {
4118   Range::initialize(arena);
4119   _end = new (arena) Interval(-1);
4120 }
4121 
4122 Interval::Interval(int reg_num) :
4123   _reg_num(reg_num),
4124   _type(T_ILLEGAL),
4125   _first(Range::end()),
4126   _use_pos_and_kinds(12),
4127   _current(Range::end()),
4128   _next(_end),
4129   _state(invalidState),
4130   _assigned_reg(LinearScan::any_reg),
4131   _assigned_regHi(LinearScan::any_reg),
4132   _cached_to(-1),
4133   _cached_opr(LIR_OprFact::illegalOpr),
4134   _cached_vm_reg(VMRegImpl::Bad()),
4135   _split_children(NULL),
4136   _canonical_spill_slot(-1),
4137   _insert_move_when_activated(false),
4138   _spill_state(noDefinitionFound),
4139   _spill_definition_pos(-1),
4140   _register_hint(NULL)
4141 {
4142   _split_parent = this;
4143   _current_split_child = this;
4144 }
4145 
4146 int Interval::calc_to() {
4147   assert(_first != Range::end(), &quot;interval has no range&quot;);
4148 
4149   Range* r = _first;
4150   while (r-&gt;next() != Range::end()) {
4151     r = r-&gt;next();
4152   }
4153   return r-&gt;to();
4154 }
4155 
4156 
4157 #ifdef ASSERT
4158 // consistency check of split-children
4159 void Interval::check_split_children() {
4160   if (_split_children != NULL &amp;&amp; _split_children-&gt;length() &gt; 0) {
4161     assert(is_split_parent(), &quot;only split parents can have children&quot;);
4162 
4163     for (int i = 0; i &lt; _split_children-&gt;length(); i++) {
4164       Interval* i1 = _split_children-&gt;at(i);
4165 
4166       assert(i1-&gt;split_parent() == this, &quot;not a split child of this interval&quot;);
4167       assert(i1-&gt;type() == type(), &quot;must be equal for all split children&quot;);
4168       assert(i1-&gt;canonical_spill_slot() == canonical_spill_slot(), &quot;must be equal for all split children&quot;);
4169 
4170       for (int j = i + 1; j &lt; _split_children-&gt;length(); j++) {
4171         Interval* i2 = _split_children-&gt;at(j);
4172 
4173         assert(i1-&gt;reg_num() != i2-&gt;reg_num(), &quot;same register number&quot;);
4174 
4175         if (i1-&gt;from() &lt; i2-&gt;from()) {
4176           assert(i1-&gt;to() &lt;= i2-&gt;from() &amp;&amp; i1-&gt;to() &lt; i2-&gt;to(), &quot;intervals overlapping&quot;);
4177         } else {
4178           assert(i2-&gt;from() &lt; i1-&gt;from(), &quot;intervals start at same op_id&quot;);
4179           assert(i2-&gt;to() &lt;= i1-&gt;from() &amp;&amp; i2-&gt;to() &lt; i1-&gt;to(), &quot;intervals overlapping&quot;);
4180         }
4181       }
4182     }
4183   }
4184 }
4185 #endif // ASSERT
4186 
4187 Interval* Interval::register_hint(bool search_split_child) const {
4188   if (!search_split_child) {
4189     return _register_hint;
4190   }
4191 
4192   if (_register_hint != NULL) {
4193     assert(_register_hint-&gt;is_split_parent(), &quot;ony split parents are valid hint registers&quot;);
4194 
4195     if (_register_hint-&gt;assigned_reg() &gt;= 0 &amp;&amp; _register_hint-&gt;assigned_reg() &lt; LinearScan::nof_regs) {
4196       return _register_hint;
4197 
4198     } else if (_register_hint-&gt;_split_children != NULL &amp;&amp; _register_hint-&gt;_split_children-&gt;length() &gt; 0) {
4199       // search the first split child that has a register assigned
4200       int len = _register_hint-&gt;_split_children-&gt;length();
4201       for (int i = 0; i &lt; len; i++) {
4202         Interval* cur = _register_hint-&gt;_split_children-&gt;at(i);
4203 
4204         if (cur-&gt;assigned_reg() &gt;= 0 &amp;&amp; cur-&gt;assigned_reg() &lt; LinearScan::nof_regs) {
4205           return cur;
4206         }
4207       }
4208     }
4209   }
4210 
4211   // no hint interval found that has a register assigned
4212   return NULL;
4213 }
4214 
4215 
4216 Interval* Interval::split_child_at_op_id(int op_id, LIR_OpVisitState::OprMode mode) {
4217   assert(is_split_parent(), &quot;can only be called for split parents&quot;);
4218   assert(op_id &gt;= 0, &quot;invalid op_id (method can not be called for spill moves)&quot;);
4219 
4220   Interval* result;
4221   if (_split_children == NULL || _split_children-&gt;length() == 0) {
4222     result = this;
4223   } else {
4224     result = NULL;
4225     int len = _split_children-&gt;length();
4226 
4227     // in outputMode, the end of the interval (op_id == cur-&gt;to()) is not valid
4228     int to_offset = (mode == LIR_OpVisitState::outputMode ? 0 : 1);
4229 
4230     int i;
4231     for (i = 0; i &lt; len; i++) {
4232       Interval* cur = _split_children-&gt;at(i);
4233       if (cur-&gt;from() &lt;= op_id &amp;&amp; op_id &lt; cur-&gt;to() + to_offset) {
4234         if (i &gt; 0) {
4235           // exchange current split child to start of list (faster access for next call)
4236           _split_children-&gt;at_put(i, _split_children-&gt;at(0));
4237           _split_children-&gt;at_put(0, cur);
4238         }
4239 
4240         // interval found
4241         result = cur;
4242         break;
4243       }
4244     }
4245 
4246 #ifdef ASSERT
4247     for (i = 0; i &lt; len; i++) {
4248       Interval* tmp = _split_children-&gt;at(i);
4249       if (tmp != result &amp;&amp; tmp-&gt;from() &lt;= op_id &amp;&amp; op_id &lt; tmp-&gt;to() + to_offset) {
4250         tty-&gt;print_cr(&quot;two valid result intervals found for op_id %d: %d and %d&quot;, op_id, result-&gt;reg_num(), tmp-&gt;reg_num());
4251         result-&gt;print();
4252         tmp-&gt;print();
4253         assert(false, &quot;two valid result intervals found&quot;);
4254       }
4255     }
4256 #endif
4257   }
4258 
4259   assert(result != NULL, &quot;no matching interval found&quot;);
4260   assert(result-&gt;covers(op_id, mode), &quot;op_id not covered by interval&quot;);
4261 
4262   return result;
4263 }
4264 
4265 
4266 // returns the last split child that ends before the given op_id
4267 Interval* Interval::split_child_before_op_id(int op_id) {
4268   assert(op_id &gt;= 0, &quot;invalid op_id&quot;);
4269 
4270   Interval* parent = split_parent();
4271   Interval* result = NULL;
4272 
4273   assert(parent-&gt;_split_children != NULL, &quot;no split children available&quot;);
4274   int len = parent-&gt;_split_children-&gt;length();
4275   assert(len &gt; 0, &quot;no split children available&quot;);
4276 
4277   for (int i = len - 1; i &gt;= 0; i--) {
4278     Interval* cur = parent-&gt;_split_children-&gt;at(i);
4279     if (cur-&gt;to() &lt;= op_id &amp;&amp; (result == NULL || result-&gt;to() &lt; cur-&gt;to())) {
4280       result = cur;
4281     }
4282   }
4283 
4284   assert(result != NULL, &quot;no split child found&quot;);
4285   return result;
4286 }
4287 
4288 
4289 // Note: use positions are sorted descending -&gt; first use has highest index
4290 int Interval::first_usage(IntervalUseKind min_use_kind) const {
4291   assert(LinearScan::is_virtual_interval(this), &quot;cannot access use positions for fixed intervals&quot;);
4292 
4293   for (int i = _use_pos_and_kinds.length() - 2; i &gt;= 0; i -= 2) {
4294     if (_use_pos_and_kinds.at(i + 1) &gt;= min_use_kind) {
4295       return _use_pos_and_kinds.at(i);
4296     }
4297   }
4298   return max_jint;
4299 }
4300 
4301 int Interval::next_usage(IntervalUseKind min_use_kind, int from) const {
4302   assert(LinearScan::is_virtual_interval(this), &quot;cannot access use positions for fixed intervals&quot;);
4303 
4304   for (int i = _use_pos_and_kinds.length() - 2; i &gt;= 0; i -= 2) {
4305     if (_use_pos_and_kinds.at(i) &gt;= from &amp;&amp; _use_pos_and_kinds.at(i + 1) &gt;= min_use_kind) {
4306       return _use_pos_and_kinds.at(i);
4307     }
4308   }
4309   return max_jint;
4310 }
4311 
4312 int Interval::next_usage_exact(IntervalUseKind exact_use_kind, int from) const {
4313   assert(LinearScan::is_virtual_interval(this), &quot;cannot access use positions for fixed intervals&quot;);
4314 
4315   for (int i = _use_pos_and_kinds.length() - 2; i &gt;= 0; i -= 2) {
4316     if (_use_pos_and_kinds.at(i) &gt;= from &amp;&amp; _use_pos_and_kinds.at(i + 1) == exact_use_kind) {
4317       return _use_pos_and_kinds.at(i);
4318     }
4319   }
4320   return max_jint;
4321 }
4322 
4323 int Interval::previous_usage(IntervalUseKind min_use_kind, int from) const {
4324   assert(LinearScan::is_virtual_interval(this), &quot;cannot access use positions for fixed intervals&quot;);
4325 
4326   int prev = 0;
4327   for (int i = _use_pos_and_kinds.length() - 2; i &gt;= 0; i -= 2) {
4328     if (_use_pos_and_kinds.at(i) &gt; from) {
4329       return prev;
4330     }
4331     if (_use_pos_and_kinds.at(i + 1) &gt;= min_use_kind) {
4332       prev = _use_pos_and_kinds.at(i);
4333     }
4334   }
4335   return prev;
4336 }
4337 
4338 void Interval::add_use_pos(int pos, IntervalUseKind use_kind) {
4339   assert(covers(pos, LIR_OpVisitState::inputMode), &quot;use position not covered by live range&quot;);
4340 
4341   // do not add use positions for precolored intervals because
4342   // they are never used
4343   if (use_kind != noUse &amp;&amp; reg_num() &gt;= LIR_OprDesc::vreg_base) {
4344 #ifdef ASSERT
4345     assert(_use_pos_and_kinds.length() % 2 == 0, &quot;must be&quot;);
4346     for (int i = 0; i &lt; _use_pos_and_kinds.length(); i += 2) {
4347       assert(pos &lt;= _use_pos_and_kinds.at(i), &quot;already added a use-position with lower position&quot;);
4348       assert(_use_pos_and_kinds.at(i + 1) &gt;= firstValidKind &amp;&amp; _use_pos_and_kinds.at(i + 1) &lt;= lastValidKind, &quot;invalid use kind&quot;);
4349       if (i &gt; 0) {
4350         assert(_use_pos_and_kinds.at(i) &lt; _use_pos_and_kinds.at(i - 2), &quot;not sorted descending&quot;);
4351       }
4352     }
4353 #endif
4354 
4355     // Note: add_use is called in descending order, so list gets sorted
4356     //       automatically by just appending new use positions
4357     int len = _use_pos_and_kinds.length();
4358     if (len == 0 || _use_pos_and_kinds.at(len - 2) &gt; pos) {
4359       _use_pos_and_kinds.append(pos);
4360       _use_pos_and_kinds.append(use_kind);
4361     } else if (_use_pos_and_kinds.at(len - 1) &lt; use_kind) {
4362       assert(_use_pos_and_kinds.at(len - 2) == pos, &quot;list not sorted correctly&quot;);
4363       _use_pos_and_kinds.at_put(len - 1, use_kind);
4364     }
4365   }
4366 }
4367 
4368 void Interval::add_range(int from, int to) {
4369   assert(from &lt; to, &quot;invalid range&quot;);
4370   assert(first() == Range::end() || to &lt; first()-&gt;next()-&gt;from(), &quot;not inserting at begin of interval&quot;);
4371   assert(from &lt;= first()-&gt;to(), &quot;not inserting at begin of interval&quot;);
4372 
4373   if (first()-&gt;from() &lt;= to) {
4374     // join intersecting ranges
4375     first()-&gt;set_from(MIN2(from, first()-&gt;from()));
4376     first()-&gt;set_to  (MAX2(to,   first()-&gt;to()));
4377   } else {
4378     // insert new range
4379     _first = new Range(from, to, first());
4380   }
4381 }
4382 
4383 Interval* Interval::new_split_child() {
4384   // allocate new interval
4385   Interval* result = new Interval(-1);
4386   result-&gt;set_type(type());
4387 
4388   Interval* parent = split_parent();
4389   result-&gt;_split_parent = parent;
4390   result-&gt;set_register_hint(parent);
4391 
4392   // insert new interval in children-list of parent
4393   if (parent-&gt;_split_children == NULL) {
4394     assert(is_split_parent(), &quot;list must be initialized at first split&quot;);
4395 
4396     parent-&gt;_split_children = new IntervalList(4);
4397     parent-&gt;_split_children-&gt;append(this);
4398   }
4399   parent-&gt;_split_children-&gt;append(result);
4400 
4401   return result;
4402 }
4403 
4404 // split this interval at the specified position and return
4405 // the remainder as a new interval.
4406 //
4407 // when an interval is split, a bi-directional link is established between the original interval
4408 // (the split parent) and the intervals that are split off this interval (the split children)
4409 // When a split child is split again, the new created interval is also a direct child
4410 // of the original parent (there is no tree of split children stored, but a flat list)
4411 // All split children are spilled to the same stack slot (stored in _canonical_spill_slot)
4412 //
4413 // Note: The new interval has no valid reg_num
4414 Interval* Interval::split(int split_pos) {
4415   assert(LinearScan::is_virtual_interval(this), &quot;cannot split fixed intervals&quot;);
4416 
4417   // allocate new interval
4418   Interval* result = new_split_child();
4419 
4420   // split the ranges
4421   Range* prev = NULL;
4422   Range* cur = _first;
4423   while (cur != Range::end() &amp;&amp; cur-&gt;to() &lt;= split_pos) {
4424     prev = cur;
4425     cur = cur-&gt;next();
4426   }
4427   assert(cur != Range::end(), &quot;split interval after end of last range&quot;);
4428 
4429   if (cur-&gt;from() &lt; split_pos) {
4430     result-&gt;_first = new Range(split_pos, cur-&gt;to(), cur-&gt;next());
4431     cur-&gt;set_to(split_pos);
4432     cur-&gt;set_next(Range::end());
4433 
4434   } else {
4435     assert(prev != NULL, &quot;split before start of first range&quot;);
4436     result-&gt;_first = cur;
4437     prev-&gt;set_next(Range::end());
4438   }
4439   result-&gt;_current = result-&gt;_first;
4440   _cached_to = -1; // clear cached value
4441 
4442   // split list of use positions
4443   int total_len = _use_pos_and_kinds.length();
4444   int start_idx = total_len - 2;
4445   while (start_idx &gt;= 0 &amp;&amp; _use_pos_and_kinds.at(start_idx) &lt; split_pos) {
4446     start_idx -= 2;
4447   }
4448 
4449   intStack new_use_pos_and_kinds(total_len - start_idx);
4450   int i;
4451   for (i = start_idx + 2; i &lt; total_len; i++) {
4452     new_use_pos_and_kinds.append(_use_pos_and_kinds.at(i));
4453   }
4454 
4455   _use_pos_and_kinds.trunc_to(start_idx + 2);
4456   result-&gt;_use_pos_and_kinds = _use_pos_and_kinds;
4457   _use_pos_and_kinds = new_use_pos_and_kinds;
4458 
4459 #ifdef ASSERT
4460   assert(_use_pos_and_kinds.length() % 2 == 0, &quot;must have use kind for each use pos&quot;);
4461   assert(result-&gt;_use_pos_and_kinds.length() % 2 == 0, &quot;must have use kind for each use pos&quot;);
4462   assert(_use_pos_and_kinds.length() + result-&gt;_use_pos_and_kinds.length() == total_len, &quot;missed some entries&quot;);
4463 
4464   for (i = 0; i &lt; _use_pos_and_kinds.length(); i += 2) {
4465     assert(_use_pos_and_kinds.at(i) &lt; split_pos, &quot;must be&quot;);
4466     assert(_use_pos_and_kinds.at(i + 1) &gt;= firstValidKind &amp;&amp; _use_pos_and_kinds.at(i + 1) &lt;= lastValidKind, &quot;invalid use kind&quot;);
4467   }
4468   for (i = 0; i &lt; result-&gt;_use_pos_and_kinds.length(); i += 2) {
4469     assert(result-&gt;_use_pos_and_kinds.at(i) &gt;= split_pos, &quot;must be&quot;);
4470     assert(result-&gt;_use_pos_and_kinds.at(i + 1) &gt;= firstValidKind &amp;&amp; result-&gt;_use_pos_and_kinds.at(i + 1) &lt;= lastValidKind, &quot;invalid use kind&quot;);
4471   }
4472 #endif
4473 
4474   return result;
4475 }
4476 
4477 // split this interval at the specified position and return
4478 // the head as a new interval (the original interval is the tail)
4479 //
4480 // Currently, only the first range can be split, and the new interval
4481 // must not have split positions
4482 Interval* Interval::split_from_start(int split_pos) {
4483   assert(LinearScan::is_virtual_interval(this), &quot;cannot split fixed intervals&quot;);
4484   assert(split_pos &gt; from() &amp;&amp; split_pos &lt; to(), &quot;can only split inside interval&quot;);
4485   assert(split_pos &gt; _first-&gt;from() &amp;&amp; split_pos &lt;= _first-&gt;to(), &quot;can only split inside first range&quot;);
4486   assert(first_usage(noUse) &gt; split_pos, &quot;can not split when use positions are present&quot;);
4487 
4488   // allocate new interval
4489   Interval* result = new_split_child();
4490 
4491   // the new created interval has only one range (checked by assertion above),
4492   // so the splitting of the ranges is very simple
4493   result-&gt;add_range(_first-&gt;from(), split_pos);
4494 
4495   if (split_pos == _first-&gt;to()) {
4496     assert(_first-&gt;next() != Range::end(), &quot;must not be at end&quot;);
4497     _first = _first-&gt;next();
4498   } else {
4499     _first-&gt;set_from(split_pos);
4500   }
4501 
4502   return result;
4503 }
4504 
4505 
4506 // returns true if the op_id is inside the interval
4507 bool Interval::covers(int op_id, LIR_OpVisitState::OprMode mode) const {
4508   Range* cur  = _first;
4509 
4510   while (cur != Range::end() &amp;&amp; cur-&gt;to() &lt; op_id) {
4511     cur = cur-&gt;next();
4512   }
4513   if (cur != Range::end()) {
4514     assert(cur-&gt;to() != cur-&gt;next()-&gt;from(), &quot;ranges not separated&quot;);
4515 
4516     if (mode == LIR_OpVisitState::outputMode) {
4517       return cur-&gt;from() &lt;= op_id &amp;&amp; op_id &lt; cur-&gt;to();
4518     } else {
4519       return cur-&gt;from() &lt;= op_id &amp;&amp; op_id &lt;= cur-&gt;to();
4520     }
4521   }
4522   return false;
4523 }
4524 
4525 // returns true if the interval has any hole between hole_from and hole_to
4526 // (even if the hole has only the length 1)
4527 bool Interval::has_hole_between(int hole_from, int hole_to) {
4528   assert(hole_from &lt; hole_to, &quot;check&quot;);
4529   assert(from() &lt;= hole_from &amp;&amp; hole_to &lt;= to(), &quot;index out of interval&quot;);
4530 
4531   Range* cur  = _first;
4532   while (cur != Range::end()) {
4533     assert(cur-&gt;to() &lt; cur-&gt;next()-&gt;from(), &quot;no space between ranges&quot;);
4534 
4535     // hole-range starts before this range -&gt; hole
4536     if (hole_from &lt; cur-&gt;from()) {
4537       return true;
4538 
4539     // hole-range completely inside this range -&gt; no hole
4540     } else if (hole_to &lt;= cur-&gt;to()) {
4541       return false;
4542 
4543     // overlapping of hole-range with this range -&gt; hole
4544     } else if (hole_from &lt;= cur-&gt;to()) {
4545       return true;
4546     }
4547 
4548     cur = cur-&gt;next();
4549   }
4550 
4551   return false;
4552 }
4553 
4554 
4555 #ifndef PRODUCT
4556 void Interval::print(outputStream* out) const {
4557   const char* SpillState2Name[] = { &quot;no definition&quot;, &quot;no spill store&quot;, &quot;one spill store&quot;, &quot;store at definition&quot;, &quot;start in memory&quot;, &quot;no optimization&quot; };
4558   const char* UseKind2Name[] = { &quot;N&quot;, &quot;L&quot;, &quot;S&quot;, &quot;M&quot; };
4559 
4560   const char* type_name;
4561   LIR_Opr opr = LIR_OprFact::illegal();
4562   if (reg_num() &lt; LIR_OprDesc::vreg_base) {
4563     type_name = &quot;fixed&quot;;
4564     // need a temporary operand for fixed intervals because type() cannot be called
4565 #ifdef X86
4566     int last_xmm_reg = pd_last_xmm_reg;
4567 #ifdef _LP64
4568     if (UseAVX &lt; 3) {
4569       last_xmm_reg = pd_first_xmm_reg + (pd_nof_xmm_regs_frame_map / 2) - 1;
4570     }
4571 #endif
4572 #endif
4573     if (assigned_reg() &gt;= pd_first_cpu_reg &amp;&amp; assigned_reg() &lt;= pd_last_cpu_reg) {
4574       opr = LIR_OprFact::single_cpu(assigned_reg());
4575     } else if (assigned_reg() &gt;= pd_first_fpu_reg &amp;&amp; assigned_reg() &lt;= pd_last_fpu_reg) {
4576       opr = LIR_OprFact::single_fpu(assigned_reg() - pd_first_fpu_reg);
4577 #ifdef X86
4578     } else if (assigned_reg() &gt;= pd_first_xmm_reg &amp;&amp; assigned_reg() &lt;= last_xmm_reg) {
4579       opr = LIR_OprFact::single_xmm(assigned_reg() - pd_first_xmm_reg);
4580 #endif
4581     } else {
4582       ShouldNotReachHere();
4583     }
4584   } else {
4585     type_name = type2name(type());
4586     if (assigned_reg() != -1 &amp;&amp;
4587         (LinearScan::num_physical_regs(type()) == 1 || assigned_regHi() != -1)) {
4588       opr = LinearScan::calc_operand_for_interval(this);
4589     }
4590   }
4591 
4592   out-&gt;print(&quot;%d %s &quot;, reg_num(), type_name);
4593   if (opr-&gt;is_valid()) {
4594     out-&gt;print(&quot;\&quot;&quot;);
4595     opr-&gt;print(out);
4596     out-&gt;print(&quot;\&quot; &quot;);
4597   }
4598   out-&gt;print(&quot;%d %d &quot;, split_parent()-&gt;reg_num(), (register_hint(false) != NULL ? register_hint(false)-&gt;reg_num() : -1));
4599 
4600   // print ranges
4601   Range* cur = _first;
4602   while (cur != Range::end()) {
4603     cur-&gt;print(out);
4604     cur = cur-&gt;next();
4605     assert(cur != NULL, &quot;range list not closed with range sentinel&quot;);
4606   }
4607 
4608   // print use positions
4609   int prev = 0;
4610   assert(_use_pos_and_kinds.length() % 2 == 0, &quot;must be&quot;);
4611   for (int i =_use_pos_and_kinds.length() - 2; i &gt;= 0; i -= 2) {
4612     assert(_use_pos_and_kinds.at(i + 1) &gt;= firstValidKind &amp;&amp; _use_pos_and_kinds.at(i + 1) &lt;= lastValidKind, &quot;invalid use kind&quot;);
4613     assert(prev &lt; _use_pos_and_kinds.at(i), &quot;use positions not sorted&quot;);
4614 
4615     out-&gt;print(&quot;%d %s &quot;, _use_pos_and_kinds.at(i), UseKind2Name[_use_pos_and_kinds.at(i + 1)]);
4616     prev = _use_pos_and_kinds.at(i);
4617   }
4618 
4619   out-&gt;print(&quot; \&quot;%s\&quot;&quot;, SpillState2Name[spill_state()]);
4620   out-&gt;cr();
4621 }
4622 #endif
4623 
4624 
4625 
4626 // **** Implementation of IntervalWalker ****************************
4627 
4628 IntervalWalker::IntervalWalker(LinearScan* allocator, Interval* unhandled_fixed_first, Interval* unhandled_any_first)
4629  : _compilation(allocator-&gt;compilation())
4630  , _allocator(allocator)
4631 {
4632   _unhandled_first[fixedKind] = unhandled_fixed_first;
4633   _unhandled_first[anyKind]   = unhandled_any_first;
4634   _active_first[fixedKind]    = Interval::end();
4635   _inactive_first[fixedKind]  = Interval::end();
4636   _active_first[anyKind]      = Interval::end();
4637   _inactive_first[anyKind]    = Interval::end();
4638   _current_position = -1;
4639   _current = NULL;
4640   next_interval();
4641 }
4642 
4643 
4644 // append interval in order of current range from()
4645 void IntervalWalker::append_sorted(Interval** list, Interval* interval) {
4646   Interval* prev = NULL;
4647   Interval* cur  = *list;
4648   while (cur-&gt;current_from() &lt; interval-&gt;current_from()) {
4649     prev = cur; cur = cur-&gt;next();
4650   }
4651   if (prev == NULL) {
4652     *list = interval;
4653   } else {
4654     prev-&gt;set_next(interval);
4655   }
4656   interval-&gt;set_next(cur);
4657 }
4658 
4659 void IntervalWalker::append_to_unhandled(Interval** list, Interval* interval) {
4660   assert(interval-&gt;from() &gt;= current()-&gt;current_from(), &quot;cannot append new interval before current walk position&quot;);
4661 
4662   Interval* prev = NULL;
4663   Interval* cur  = *list;
4664   while (cur-&gt;from() &lt; interval-&gt;from() || (cur-&gt;from() == interval-&gt;from() &amp;&amp; cur-&gt;first_usage(noUse) &lt; interval-&gt;first_usage(noUse))) {
4665     prev = cur; cur = cur-&gt;next();
4666   }
4667   if (prev == NULL) {
4668     *list = interval;
4669   } else {
4670     prev-&gt;set_next(interval);
4671   }
4672   interval-&gt;set_next(cur);
4673 }
4674 
4675 
4676 inline bool IntervalWalker::remove_from_list(Interval** list, Interval* i) {
4677   while (*list != Interval::end() &amp;&amp; *list != i) {
4678     list = (*list)-&gt;next_addr();
4679   }
4680   if (*list != Interval::end()) {
4681     assert(*list == i, &quot;check&quot;);
4682     *list = (*list)-&gt;next();
4683     return true;
4684   } else {
4685     return false;
4686   }
4687 }
4688 
4689 void IntervalWalker::remove_from_list(Interval* i) {
4690   bool deleted;
4691 
4692   if (i-&gt;state() == activeState) {
4693     deleted = remove_from_list(active_first_addr(anyKind), i);
4694   } else {
4695     assert(i-&gt;state() == inactiveState, &quot;invalid state&quot;);
4696     deleted = remove_from_list(inactive_first_addr(anyKind), i);
4697   }
4698 
4699   assert(deleted, &quot;interval has not been found in list&quot;);
4700 }
4701 
4702 
4703 void IntervalWalker::walk_to(IntervalState state, int from) {
4704   assert (state == activeState || state == inactiveState, &quot;wrong state&quot;);
4705   for_each_interval_kind(kind) {
4706     Interval** prev = state == activeState ? active_first_addr(kind) : inactive_first_addr(kind);
4707     Interval* next   = *prev;
4708     while (next-&gt;current_from() &lt;= from) {
4709       Interval* cur = next;
4710       next = cur-&gt;next();
4711 
4712       bool range_has_changed = false;
4713       while (cur-&gt;current_to() &lt;= from) {
4714         cur-&gt;next_range();
4715         range_has_changed = true;
4716       }
4717 
4718       // also handle move from inactive list to active list
4719       range_has_changed = range_has_changed || (state == inactiveState &amp;&amp; cur-&gt;current_from() &lt;= from);
4720 
4721       if (range_has_changed) {
4722         // remove cur from list
4723         *prev = next;
4724         if (cur-&gt;current_at_end()) {
4725           // move to handled state (not maintained as a list)
4726           cur-&gt;set_state(handledState);
4727           interval_moved(cur, kind, state, handledState);
4728         } else if (cur-&gt;current_from() &lt;= from){
4729           // sort into active list
4730           append_sorted(active_first_addr(kind), cur);
4731           cur-&gt;set_state(activeState);
4732           if (*prev == cur) {
4733             assert(state == activeState, &quot;check&quot;);
4734             prev = cur-&gt;next_addr();
4735           }
4736           interval_moved(cur, kind, state, activeState);
4737         } else {
4738           // sort into inactive list
4739           append_sorted(inactive_first_addr(kind), cur);
4740           cur-&gt;set_state(inactiveState);
4741           if (*prev == cur) {
4742             assert(state == inactiveState, &quot;check&quot;);
4743             prev = cur-&gt;next_addr();
4744           }
4745           interval_moved(cur, kind, state, inactiveState);
4746         }
4747       } else {
4748         prev = cur-&gt;next_addr();
4749         continue;
4750       }
4751     }
4752   }
4753 }
4754 
4755 
4756 void IntervalWalker::next_interval() {
4757   IntervalKind kind;
4758   Interval* any   = _unhandled_first[anyKind];
4759   Interval* fixed = _unhandled_first[fixedKind];
4760 
4761   if (any != Interval::end()) {
4762     // intervals may start at same position -&gt; prefer fixed interval
4763     kind = fixed != Interval::end() &amp;&amp; fixed-&gt;from() &lt;= any-&gt;from() ? fixedKind : anyKind;
4764 
4765     assert (kind == fixedKind &amp;&amp; fixed-&gt;from() &lt;= any-&gt;from() ||
4766             kind == anyKind   &amp;&amp; any-&gt;from() &lt;= fixed-&gt;from(), &quot;wrong interval!!!&quot;);
4767     assert(any == Interval::end() || fixed == Interval::end() || any-&gt;from() != fixed-&gt;from() || kind == fixedKind, &quot;if fixed and any-Interval start at same position, fixed must be processed first&quot;);
4768 
4769   } else if (fixed != Interval::end()) {
4770     kind = fixedKind;
4771   } else {
4772     _current = NULL; return;
4773   }
4774   _current_kind = kind;
4775   _current = _unhandled_first[kind];
4776   _unhandled_first[kind] = _current-&gt;next();
4777   _current-&gt;set_next(Interval::end());
4778   _current-&gt;rewind_range();
4779 }
4780 
4781 
4782 void IntervalWalker::walk_to(int lir_op_id) {
4783   assert(_current_position &lt;= lir_op_id, &quot;can not walk backwards&quot;);
4784   while (current() != NULL) {
4785     bool is_active = current()-&gt;from() &lt;= lir_op_id;
4786     int id = is_active ? current()-&gt;from() : lir_op_id;
4787 
4788     TRACE_LINEAR_SCAN(2, if (_current_position &lt; id) { tty-&gt;cr(); tty-&gt;print_cr(&quot;walk_to(%d) **************************************************************&quot;, id); })
4789 
4790     // set _current_position prior to call of walk_to
4791     _current_position = id;
4792 
4793     // call walk_to even if _current_position == id
4794     walk_to(activeState, id);
4795     walk_to(inactiveState, id);
4796 
4797     if (is_active) {
4798       current()-&gt;set_state(activeState);
4799       if (activate_current()) {
4800         append_sorted(active_first_addr(current_kind()), current());
4801         interval_moved(current(), current_kind(), unhandledState, activeState);
4802       }
4803 
4804       next_interval();
4805     } else {
4806       return;
4807     }
4808   }
4809 }
4810 
4811 void IntervalWalker::interval_moved(Interval* interval, IntervalKind kind, IntervalState from, IntervalState to) {
4812 #ifndef PRODUCT
4813   if (TraceLinearScanLevel &gt;= 4) {
4814     #define print_state(state) \
4815     switch(state) {\
4816       case unhandledState: tty-&gt;print(&quot;unhandled&quot;); break;\
4817       case activeState: tty-&gt;print(&quot;active&quot;); break;\
4818       case inactiveState: tty-&gt;print(&quot;inactive&quot;); break;\
4819       case handledState: tty-&gt;print(&quot;handled&quot;); break;\
4820       default: ShouldNotReachHere(); \
4821     }
4822 
4823     print_state(from); tty-&gt;print(&quot; to &quot;); print_state(to);
4824     tty-&gt;fill_to(23);
4825     interval-&gt;print();
4826 
4827     #undef print_state
4828   }
4829 #endif
4830 }
4831 
4832 
4833 
4834 // **** Implementation of LinearScanWalker **************************
4835 
4836 LinearScanWalker::LinearScanWalker(LinearScan* allocator, Interval* unhandled_fixed_first, Interval* unhandled_any_first)
4837   : IntervalWalker(allocator, unhandled_fixed_first, unhandled_any_first)
4838   , _move_resolver(allocator)
4839 {
4840   for (int i = 0; i &lt; LinearScan::nof_regs; i++) {
4841     _spill_intervals[i] = new IntervalList(2);
4842   }
4843 }
4844 
4845 
4846 inline void LinearScanWalker::init_use_lists(bool only_process_use_pos) {
4847   for (int i = _first_reg; i &lt;= _last_reg; i++) {
4848     _use_pos[i] = max_jint;
4849 
4850     if (!only_process_use_pos) {
4851       _block_pos[i] = max_jint;
4852       _spill_intervals[i]-&gt;clear();
4853     }
4854   }
4855 }
4856 
4857 inline void LinearScanWalker::exclude_from_use(int reg) {
4858   assert(reg &lt; LinearScan::nof_regs, &quot;interval must have a register assigned (stack slots not allowed)&quot;);
4859   if (reg &gt;= _first_reg &amp;&amp; reg &lt;= _last_reg) {
4860     _use_pos[reg] = 0;
4861   }
4862 }
4863 inline void LinearScanWalker::exclude_from_use(Interval* i) {
4864   assert(i-&gt;assigned_reg() != any_reg, &quot;interval has no register assigned&quot;);
4865 
4866   exclude_from_use(i-&gt;assigned_reg());
4867   exclude_from_use(i-&gt;assigned_regHi());
4868 }
4869 
4870 inline void LinearScanWalker::set_use_pos(int reg, Interval* i, int use_pos, bool only_process_use_pos) {
4871   assert(use_pos != 0, &quot;must use exclude_from_use to set use_pos to 0&quot;);
4872 
4873   if (reg &gt;= _first_reg &amp;&amp; reg &lt;= _last_reg) {
4874     if (_use_pos[reg] &gt; use_pos) {
4875       _use_pos[reg] = use_pos;
4876     }
4877     if (!only_process_use_pos) {
4878       _spill_intervals[reg]-&gt;append(i);
4879     }
4880   }
4881 }
4882 inline void LinearScanWalker::set_use_pos(Interval* i, int use_pos, bool only_process_use_pos) {
4883   assert(i-&gt;assigned_reg() != any_reg, &quot;interval has no register assigned&quot;);
4884   if (use_pos != -1) {
4885     set_use_pos(i-&gt;assigned_reg(), i, use_pos, only_process_use_pos);
4886     set_use_pos(i-&gt;assigned_regHi(), i, use_pos, only_process_use_pos);
4887   }
4888 }
4889 
4890 inline void LinearScanWalker::set_block_pos(int reg, Interval* i, int block_pos) {
4891   if (reg &gt;= _first_reg &amp;&amp; reg &lt;= _last_reg) {
4892     if (_block_pos[reg] &gt; block_pos) {
4893       _block_pos[reg] = block_pos;
4894     }
4895     if (_use_pos[reg] &gt; block_pos) {
4896       _use_pos[reg] = block_pos;
4897     }
4898   }
4899 }
4900 inline void LinearScanWalker::set_block_pos(Interval* i, int block_pos) {
4901   assert(i-&gt;assigned_reg() != any_reg, &quot;interval has no register assigned&quot;);
4902   if (block_pos != -1) {
4903     set_block_pos(i-&gt;assigned_reg(), i, block_pos);
4904     set_block_pos(i-&gt;assigned_regHi(), i, block_pos);
4905   }
4906 }
4907 
4908 
4909 void LinearScanWalker::free_exclude_active_fixed() {
4910   Interval* list = active_first(fixedKind);
4911   while (list != Interval::end()) {
4912     assert(list-&gt;assigned_reg() &lt; LinearScan::nof_regs, &quot;active interval must have a register assigned&quot;);
4913     exclude_from_use(list);
4914     list = list-&gt;next();
4915   }
4916 }
4917 
4918 void LinearScanWalker::free_exclude_active_any() {
4919   Interval* list = active_first(anyKind);
4920   while (list != Interval::end()) {
4921     exclude_from_use(list);
4922     list = list-&gt;next();
4923   }
4924 }
4925 
4926 void LinearScanWalker::free_collect_inactive_fixed(Interval* cur) {
4927   Interval* list = inactive_first(fixedKind);
4928   while (list != Interval::end()) {
4929     if (cur-&gt;to() &lt;= list-&gt;current_from()) {
4930       assert(list-&gt;current_intersects_at(cur) == -1, &quot;must not intersect&quot;);
4931       set_use_pos(list, list-&gt;current_from(), true);
4932     } else {
4933       set_use_pos(list, list-&gt;current_intersects_at(cur), true);
4934     }
4935     list = list-&gt;next();
4936   }
4937 }
4938 
4939 void LinearScanWalker::free_collect_inactive_any(Interval* cur) {
4940   Interval* list = inactive_first(anyKind);
4941   while (list != Interval::end()) {
4942     set_use_pos(list, list-&gt;current_intersects_at(cur), true);
4943     list = list-&gt;next();
4944   }
4945 }
4946 
4947 void LinearScanWalker::spill_exclude_active_fixed() {
4948   Interval* list = active_first(fixedKind);
4949   while (list != Interval::end()) {
4950     exclude_from_use(list);
4951     list = list-&gt;next();
4952   }
4953 }
4954 
4955 void LinearScanWalker::spill_block_inactive_fixed(Interval* cur) {
4956   Interval* list = inactive_first(fixedKind);
4957   while (list != Interval::end()) {
4958     if (cur-&gt;to() &gt; list-&gt;current_from()) {
4959       set_block_pos(list, list-&gt;current_intersects_at(cur));
4960     } else {
4961       assert(list-&gt;current_intersects_at(cur) == -1, &quot;invalid optimization: intervals intersect&quot;);
4962     }
4963 
4964     list = list-&gt;next();
4965   }
4966 }
4967 
4968 void LinearScanWalker::spill_collect_active_any() {
4969   Interval* list = active_first(anyKind);
4970   while (list != Interval::end()) {
4971     set_use_pos(list, MIN2(list-&gt;next_usage(loopEndMarker, _current_position), list-&gt;to()), false);
4972     list = list-&gt;next();
4973   }
4974 }
4975 
4976 void LinearScanWalker::spill_collect_inactive_any(Interval* cur) {
4977   Interval* list = inactive_first(anyKind);
4978   while (list != Interval::end()) {
4979     if (list-&gt;current_intersects(cur)) {
4980       set_use_pos(list, MIN2(list-&gt;next_usage(loopEndMarker, _current_position), list-&gt;to()), false);
4981     }
4982     list = list-&gt;next();
4983   }
4984 }
4985 
4986 
4987 void LinearScanWalker::insert_move(int op_id, Interval* src_it, Interval* dst_it) {
4988   // output all moves here. When source and target are equal, the move is
4989   // optimized away later in assign_reg_nums
4990 
4991   op_id = (op_id + 1) &amp; ~1;
4992   BlockBegin* op_block = allocator()-&gt;block_of_op_with_id(op_id);
4993   assert(op_id &gt; 0 &amp;&amp; allocator()-&gt;block_of_op_with_id(op_id - 2) == op_block, &quot;cannot insert move at block boundary&quot;);
4994 
4995   // calculate index of instruction inside instruction list of current block
4996   // the minimal index (for a block with no spill moves) can be calculated because the
4997   // numbering of instructions is known.
4998   // When the block already contains spill moves, the index must be increased until the
4999   // correct index is reached.
5000   LIR_OpList* list = op_block-&gt;lir()-&gt;instructions_list();
5001   int index = (op_id - list-&gt;at(0)-&gt;id()) / 2;
5002   assert(list-&gt;at(index)-&gt;id() &lt;= op_id, &quot;error in calculation&quot;);
5003 
5004   while (list-&gt;at(index)-&gt;id() != op_id) {
5005     index++;
5006     assert(0 &lt;= index &amp;&amp; index &lt; list-&gt;length(), &quot;index out of bounds&quot;);
5007   }
5008   assert(1 &lt;= index &amp;&amp; index &lt; list-&gt;length(), &quot;index out of bounds&quot;);
5009   assert(list-&gt;at(index)-&gt;id() == op_id, &quot;error in calculation&quot;);
5010 
5011   // insert new instruction before instruction at position index
5012   _move_resolver.move_insert_position(op_block-&gt;lir(), index - 1);
5013   _move_resolver.add_mapping(src_it, dst_it);
5014 }
5015 
5016 
5017 int LinearScanWalker::find_optimal_split_pos(BlockBegin* min_block, BlockBegin* max_block, int max_split_pos) {
5018   int from_block_nr = min_block-&gt;linear_scan_number();
5019   int to_block_nr = max_block-&gt;linear_scan_number();
5020 
5021   assert(0 &lt;= from_block_nr &amp;&amp; from_block_nr &lt; block_count(), &quot;out of range&quot;);
5022   assert(0 &lt;= to_block_nr &amp;&amp; to_block_nr &lt; block_count(), &quot;out of range&quot;);
5023   assert(from_block_nr &lt; to_block_nr, &quot;must cross block boundary&quot;);
5024 
5025   // Try to split at end of max_block. If this would be after
5026   // max_split_pos, then use the begin of max_block
5027   int optimal_split_pos = max_block-&gt;last_lir_instruction_id() + 2;
5028   if (optimal_split_pos &gt; max_split_pos) {
5029     optimal_split_pos = max_block-&gt;first_lir_instruction_id();
5030   }
5031 
5032   int min_loop_depth = max_block-&gt;loop_depth();
5033   for (int i = to_block_nr - 1; i &gt;= from_block_nr; i--) {
5034     BlockBegin* cur = block_at(i);
5035 
5036     if (cur-&gt;loop_depth() &lt; min_loop_depth) {
5037       // block with lower loop-depth found -&gt; split at the end of this block
5038       min_loop_depth = cur-&gt;loop_depth();
5039       optimal_split_pos = cur-&gt;last_lir_instruction_id() + 2;
5040     }
5041   }
5042   assert(optimal_split_pos &gt; allocator()-&gt;max_lir_op_id() || allocator()-&gt;is_block_begin(optimal_split_pos), &quot;algorithm must move split pos to block boundary&quot;);
5043 
5044   return optimal_split_pos;
5045 }
5046 
5047 
5048 int LinearScanWalker::find_optimal_split_pos(Interval* it, int min_split_pos, int max_split_pos, bool do_loop_optimization) {
5049   int optimal_split_pos = -1;
5050   if (min_split_pos == max_split_pos) {
5051     // trivial case, no optimization of split position possible
5052     TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      min-pos and max-pos are equal, no optimization possible&quot;));
5053     optimal_split_pos = min_split_pos;
5054 
5055   } else {
5056     assert(min_split_pos &lt; max_split_pos, &quot;must be true then&quot;);
5057     assert(min_split_pos &gt; 0, &quot;cannot access min_split_pos - 1 otherwise&quot;);
5058 
5059     // reason for using min_split_pos - 1: when the minimal split pos is exactly at the
5060     // beginning of a block, then min_split_pos is also a possible split position.
5061     // Use the block before as min_block, because then min_block-&gt;last_lir_instruction_id() + 2 == min_split_pos
5062     BlockBegin* min_block = allocator()-&gt;block_of_op_with_id(min_split_pos - 1);
5063 
5064     // reason for using max_split_pos - 1: otherwise there would be an assertion failure
5065     // when an interval ends at the end of the last block of the method
5066     // (in this case, max_split_pos == allocator()-&gt;max_lir_op_id() + 2, and there is no
5067     // block at this op_id)
5068     BlockBegin* max_block = allocator()-&gt;block_of_op_with_id(max_split_pos - 1);
5069 
5070     assert(min_block-&gt;linear_scan_number() &lt;= max_block-&gt;linear_scan_number(), &quot;invalid order&quot;);
5071     if (min_block == max_block) {
5072       // split position cannot be moved to block boundary, so split as late as possible
5073       TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      cannot move split pos to block boundary because min_pos and max_pos are in same block&quot;));
5074       optimal_split_pos = max_split_pos;
5075 
5076     } else if (it-&gt;has_hole_between(max_split_pos - 1, max_split_pos) &amp;&amp; !allocator()-&gt;is_block_begin(max_split_pos)) {
5077       // Do not move split position if the interval has a hole before max_split_pos.
5078       // Intervals resulting from Phi-Functions have more than one definition (marked
5079       // as mustHaveRegister) with a hole before each definition. When the register is needed
5080       // for the second definition, an earlier reloading is unnecessary.
5081       TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      interval has hole just before max_split_pos, so splitting at max_split_pos&quot;));
5082       optimal_split_pos = max_split_pos;
5083 
5084     } else {
5085       // seach optimal block boundary between min_split_pos and max_split_pos
5086       TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      moving split pos to optimal block boundary between block B%d and B%d&quot;, min_block-&gt;block_id(), max_block-&gt;block_id()));
5087 
5088       if (do_loop_optimization) {
5089         // Loop optimization: if a loop-end marker is found between min- and max-position,
5090         // then split before this loop
5091         int loop_end_pos = it-&gt;next_usage_exact(loopEndMarker, min_block-&gt;last_lir_instruction_id() + 2);
5092         TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      loop optimization: loop end found at pos %d&quot;, loop_end_pos));
5093 
5094         assert(loop_end_pos &gt; min_split_pos, &quot;invalid order&quot;);
5095         if (loop_end_pos &lt; max_split_pos) {
5096           // loop-end marker found between min- and max-position
5097           // if it is not the end marker for the same loop as the min-position, then move
5098           // the max-position to this loop block.
5099           // Desired result: uses tagged as shouldHaveRegister inside a loop cause a reloading
5100           // of the interval (normally, only mustHaveRegister causes a reloading)
5101           BlockBegin* loop_block = allocator()-&gt;block_of_op_with_id(loop_end_pos);
5102 
5103           TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      interval is used in loop that ends in block B%d, so trying to move max_block back from B%d to B%d&quot;, loop_block-&gt;block_id(), max_block-&gt;block_id(), loop_block-&gt;block_id()));
5104           assert(loop_block != min_block, &quot;loop_block and min_block must be different because block boundary is needed between&quot;);
5105 
5106           optimal_split_pos = find_optimal_split_pos(min_block, loop_block, loop_block-&gt;last_lir_instruction_id() + 2);
5107           if (optimal_split_pos == loop_block-&gt;last_lir_instruction_id() + 2) {
5108             optimal_split_pos = -1;
5109             TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      loop optimization not necessary&quot;));
5110           } else {
5111             TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      loop optimization successful&quot;));
5112           }
5113         }
5114       }
5115 
5116       if (optimal_split_pos == -1) {
5117         // not calculated by loop optimization
5118         optimal_split_pos = find_optimal_split_pos(min_block, max_block, max_split_pos);
5119       }
5120     }
5121   }
5122   TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      optimal split position: %d&quot;, optimal_split_pos));
5123 
5124   return optimal_split_pos;
5125 }
5126 
5127 
5128 /*
5129   split an interval at the optimal position between min_split_pos and
5130   max_split_pos in two parts:
5131   1) the left part has already a location assigned
5132   2) the right part is sorted into to the unhandled-list
5133 */
5134 void LinearScanWalker::split_before_usage(Interval* it, int min_split_pos, int max_split_pos) {
5135   TRACE_LINEAR_SCAN(2, tty-&gt;print   (&quot;----- splitting interval: &quot;); it-&gt;print());
5136   TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;      between %d and %d&quot;, min_split_pos, max_split_pos));
5137 
5138   assert(it-&gt;from() &lt; min_split_pos,         &quot;cannot split at start of interval&quot;);
5139   assert(current_position() &lt; min_split_pos, &quot;cannot split before current position&quot;);
5140   assert(min_split_pos &lt;= max_split_pos,     &quot;invalid order&quot;);
5141   assert(max_split_pos &lt;= it-&gt;to(),          &quot;cannot split after end of interval&quot;);
5142 
5143   int optimal_split_pos = find_optimal_split_pos(it, min_split_pos, max_split_pos, true);
5144 
5145   assert(min_split_pos &lt;= optimal_split_pos &amp;&amp; optimal_split_pos &lt;= max_split_pos, &quot;out of range&quot;);
5146   assert(optimal_split_pos &lt;= it-&gt;to(),  &quot;cannot split after end of interval&quot;);
5147   assert(optimal_split_pos &gt; it-&gt;from(), &quot;cannot split at start of interval&quot;);
5148 
5149   if (optimal_split_pos == it-&gt;to() &amp;&amp; it-&gt;next_usage(mustHaveRegister, min_split_pos) == max_jint) {
5150     // the split position would be just before the end of the interval
5151     // -&gt; no split at all necessary
5152     TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      no split necessary because optimal split position is at end of interval&quot;));
5153     return;
5154   }
5155 
5156   // must calculate this before the actual split is performed and before split position is moved to odd op_id
5157   bool move_necessary = !allocator()-&gt;is_block_begin(optimal_split_pos) &amp;&amp; !it-&gt;has_hole_between(optimal_split_pos - 1, optimal_split_pos);
5158 
5159   if (!allocator()-&gt;is_block_begin(optimal_split_pos)) {
5160     // move position before actual instruction (odd op_id)
5161     optimal_split_pos = (optimal_split_pos - 1) | 1;
5162   }
5163 
5164   TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      splitting at position %d&quot;, optimal_split_pos));
5165   assert(allocator()-&gt;is_block_begin(optimal_split_pos) || (optimal_split_pos % 2 == 1), &quot;split pos must be odd when not on block boundary&quot;);
5166   assert(!allocator()-&gt;is_block_begin(optimal_split_pos) || (optimal_split_pos % 2 == 0), &quot;split pos must be even on block boundary&quot;);
5167 
5168   Interval* split_part = it-&gt;split(optimal_split_pos);
5169 
5170   allocator()-&gt;append_interval(split_part);
5171   allocator()-&gt;copy_register_flags(it, split_part);
5172   split_part-&gt;set_insert_move_when_activated(move_necessary);
5173   append_to_unhandled(unhandled_first_addr(anyKind), split_part);
5174 
5175   TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;      split interval in two parts (insert_move_when_activated: %d)&quot;, move_necessary));
5176   TRACE_LINEAR_SCAN(2, tty-&gt;print   (&quot;      &quot;); it-&gt;print());
5177   TRACE_LINEAR_SCAN(2, tty-&gt;print   (&quot;      &quot;); split_part-&gt;print());
5178 }
5179 
5180 /*
5181   split an interval at the optimal position between min_split_pos and
5182   max_split_pos in two parts:
5183   1) the left part has already a location assigned
5184   2) the right part is always on the stack and therefore ignored in further processing
5185 */
5186 void LinearScanWalker::split_for_spilling(Interval* it) {
5187   // calculate allowed range of splitting position
5188   int max_split_pos = current_position();
5189   int min_split_pos = MAX2(it-&gt;previous_usage(shouldHaveRegister, max_split_pos) + 1, it-&gt;from());
5190 
5191   TRACE_LINEAR_SCAN(2, tty-&gt;print   (&quot;----- splitting and spilling interval: &quot;); it-&gt;print());
5192   TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;      between %d and %d&quot;, min_split_pos, max_split_pos));
5193 
5194   assert(it-&gt;state() == activeState,     &quot;why spill interval that is not active?&quot;);
5195   assert(it-&gt;from() &lt;= min_split_pos,    &quot;cannot split before start of interval&quot;);
5196   assert(min_split_pos &lt;= max_split_pos, &quot;invalid order&quot;);
5197   assert(max_split_pos &lt; it-&gt;to(),       &quot;cannot split at end end of interval&quot;);
5198   assert(current_position() &lt; it-&gt;to(),  &quot;interval must not end before current position&quot;);
5199 
5200   if (min_split_pos == it-&gt;from()) {
5201     // the whole interval is never used, so spill it entirely to memory
5202     TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;      spilling entire interval because split pos is at beginning of interval&quot;));
5203     assert(it-&gt;first_usage(shouldHaveRegister) &gt; current_position(), &quot;interval must not have use position before current_position&quot;);
5204 
5205     allocator()-&gt;assign_spill_slot(it);
5206     allocator()-&gt;change_spill_state(it, min_split_pos);
5207 
5208     // Also kick parent intervals out of register to memory when they have no use
5209     // position. This avoids short interval in register surrounded by intervals in
5210     // memory -&gt; avoid useless moves from memory to register and back
5211     Interval* parent = it;
5212     while (parent != NULL &amp;&amp; parent-&gt;is_split_child()) {
5213       parent = parent-&gt;split_child_before_op_id(parent-&gt;from());
5214 
5215       if (parent-&gt;assigned_reg() &lt; LinearScan::nof_regs) {
5216         if (parent-&gt;first_usage(shouldHaveRegister) == max_jint) {
5217           // parent is never used, so kick it out of its assigned register
5218           TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      kicking out interval %d out of its register because it is never used&quot;, parent-&gt;reg_num()));
5219           allocator()-&gt;assign_spill_slot(parent);
5220         } else {
5221           // do not go further back because the register is actually used by the interval
5222           parent = NULL;
5223         }
5224       }
5225     }
5226 
5227   } else {
5228     // search optimal split pos, split interval and spill only the right hand part
5229     int optimal_split_pos = find_optimal_split_pos(it, min_split_pos, max_split_pos, false);
5230 
5231     assert(min_split_pos &lt;= optimal_split_pos &amp;&amp; optimal_split_pos &lt;= max_split_pos, &quot;out of range&quot;);
5232     assert(optimal_split_pos &lt; it-&gt;to(), &quot;cannot split at end of interval&quot;);
5233     assert(optimal_split_pos &gt;= it-&gt;from(), &quot;cannot split before start of interval&quot;);
5234 
5235     if (!allocator()-&gt;is_block_begin(optimal_split_pos)) {
5236       // move position before actual instruction (odd op_id)
5237       optimal_split_pos = (optimal_split_pos - 1) | 1;
5238     }
5239 
5240     TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      splitting at position %d&quot;, optimal_split_pos));
5241     assert(allocator()-&gt;is_block_begin(optimal_split_pos)  || (optimal_split_pos % 2 == 1), &quot;split pos must be odd when not on block boundary&quot;);
5242     assert(!allocator()-&gt;is_block_begin(optimal_split_pos) || (optimal_split_pos % 2 == 0), &quot;split pos must be even on block boundary&quot;);
5243 
5244     Interval* spilled_part = it-&gt;split(optimal_split_pos);
5245     allocator()-&gt;append_interval(spilled_part);
5246     allocator()-&gt;assign_spill_slot(spilled_part);
5247     allocator()-&gt;change_spill_state(spilled_part, optimal_split_pos);
5248 
5249     if (!allocator()-&gt;is_block_begin(optimal_split_pos)) {
5250       TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      inserting move from interval %d to %d&quot;, it-&gt;reg_num(), spilled_part-&gt;reg_num()));
5251       insert_move(optimal_split_pos, it, spilled_part);
5252     }
5253 
5254     // the current_split_child is needed later when moves are inserted for reloading
5255     assert(spilled_part-&gt;current_split_child() == it, &quot;overwriting wrong current_split_child&quot;);
5256     spilled_part-&gt;make_current_split_child();
5257 
5258     TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;      split interval in two parts&quot;));
5259     TRACE_LINEAR_SCAN(2, tty-&gt;print   (&quot;      &quot;); it-&gt;print());
5260     TRACE_LINEAR_SCAN(2, tty-&gt;print   (&quot;      &quot;); spilled_part-&gt;print());
5261   }
5262 }
5263 
5264 
5265 void LinearScanWalker::split_stack_interval(Interval* it) {
5266   int min_split_pos = current_position() + 1;
5267   int max_split_pos = MIN2(it-&gt;first_usage(shouldHaveRegister), it-&gt;to());
5268 
5269   split_before_usage(it, min_split_pos, max_split_pos);
5270 }
5271 
5272 void LinearScanWalker::split_when_partial_register_available(Interval* it, int register_available_until) {
5273   int min_split_pos = MAX2(it-&gt;previous_usage(shouldHaveRegister, register_available_until), it-&gt;from() + 1);
5274   int max_split_pos = register_available_until;
5275 
5276   split_before_usage(it, min_split_pos, max_split_pos);
5277 }
5278 
5279 void LinearScanWalker::split_and_spill_interval(Interval* it) {
5280   assert(it-&gt;state() == activeState || it-&gt;state() == inactiveState, &quot;other states not allowed&quot;);
5281 
5282   int current_pos = current_position();
5283   if (it-&gt;state() == inactiveState) {
5284     // the interval is currently inactive, so no spill slot is needed for now.
5285     // when the split part is activated, the interval has a new chance to get a register,
5286     // so in the best case no stack slot is necessary
5287     assert(it-&gt;has_hole_between(current_pos - 1, current_pos + 1), &quot;interval can not be inactive otherwise&quot;);
5288     split_before_usage(it, current_pos + 1, current_pos + 1);
5289 
5290   } else {
5291     // search the position where the interval must have a register and split
5292     // at the optimal position before.
5293     // The new created part is added to the unhandled list and will get a register
5294     // when it is activated
5295     int min_split_pos = current_pos + 1;
5296     int max_split_pos = MIN2(it-&gt;next_usage(mustHaveRegister, min_split_pos), it-&gt;to());
5297 
5298     split_before_usage(it, min_split_pos, max_split_pos);
5299 
5300     assert(it-&gt;next_usage(mustHaveRegister, current_pos) == max_jint, &quot;the remaining part is spilled to stack and therefore has no register&quot;);
5301     split_for_spilling(it);
5302   }
5303 }
5304 
5305 
5306 int LinearScanWalker::find_free_reg(int reg_needed_until, int interval_to, int hint_reg, int ignore_reg, bool* need_split) {
5307   int min_full_reg = any_reg;
5308   int max_partial_reg = any_reg;
5309 
5310   for (int i = _first_reg; i &lt;= _last_reg; i++) {
5311     if (i == ignore_reg) {
5312       // this register must be ignored
5313 
5314     } else if (_use_pos[i] &gt;= interval_to) {
5315       // this register is free for the full interval
5316       if (min_full_reg == any_reg || i == hint_reg || (_use_pos[i] &lt; _use_pos[min_full_reg] &amp;&amp; min_full_reg != hint_reg)) {
5317         min_full_reg = i;
5318       }
5319     } else if (_use_pos[i] &gt; reg_needed_until) {
5320       // this register is at least free until reg_needed_until
5321       if (max_partial_reg == any_reg || i == hint_reg || (_use_pos[i] &gt; _use_pos[max_partial_reg] &amp;&amp; max_partial_reg != hint_reg)) {
5322         max_partial_reg = i;
5323       }
5324     }
5325   }
5326 
5327   if (min_full_reg != any_reg) {
5328     return min_full_reg;
5329   } else if (max_partial_reg != any_reg) {
5330     *need_split = true;
5331     return max_partial_reg;
5332   } else {
5333     return any_reg;
5334   }
5335 }
5336 
5337 int LinearScanWalker::find_free_double_reg(int reg_needed_until, int interval_to, int hint_reg, bool* need_split) {
5338   assert((_last_reg - _first_reg + 1) % 2 == 0, &quot;adjust algorithm&quot;);
5339 
5340   int min_full_reg = any_reg;
5341   int max_partial_reg = any_reg;
5342 
5343   for (int i = _first_reg; i &lt; _last_reg; i+=2) {
5344     if (_use_pos[i] &gt;= interval_to &amp;&amp; _use_pos[i + 1] &gt;= interval_to) {
5345       // this register is free for the full interval
5346       if (min_full_reg == any_reg || i == hint_reg || (_use_pos[i] &lt; _use_pos[min_full_reg] &amp;&amp; min_full_reg != hint_reg)) {
5347         min_full_reg = i;
5348       }
5349     } else if (_use_pos[i] &gt; reg_needed_until &amp;&amp; _use_pos[i + 1] &gt; reg_needed_until) {
5350       // this register is at least free until reg_needed_until
5351       if (max_partial_reg == any_reg || i == hint_reg || (_use_pos[i] &gt; _use_pos[max_partial_reg] &amp;&amp; max_partial_reg != hint_reg)) {
5352         max_partial_reg = i;
5353       }
5354     }
5355   }
5356 
5357   if (min_full_reg != any_reg) {
5358     return min_full_reg;
5359   } else if (max_partial_reg != any_reg) {
5360     *need_split = true;
5361     return max_partial_reg;
5362   } else {
5363     return any_reg;
5364   }
5365 }
5366 
5367 
5368 bool LinearScanWalker::alloc_free_reg(Interval* cur) {
5369   TRACE_LINEAR_SCAN(2, tty-&gt;print(&quot;trying to find free register for &quot;); cur-&gt;print());
5370 
5371   init_use_lists(true);
5372   free_exclude_active_fixed();
5373   free_exclude_active_any();
5374   free_collect_inactive_fixed(cur);
5375   free_collect_inactive_any(cur);
5376   assert(unhandled_first(fixedKind) == Interval::end(), &quot;must not have unhandled fixed intervals because all fixed intervals have a use at position 0&quot;);
5377 
5378   // _use_pos contains the start of the next interval that has this register assigned
5379   // (either as a fixed register or a normal allocated register in the past)
5380   // only intervals overlapping with cur are processed, non-overlapping invervals can be ignored safely
5381   TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      state of registers:&quot;));
5382   TRACE_LINEAR_SCAN(4, for (int i = _first_reg; i &lt;= _last_reg; i++) tty-&gt;print_cr(&quot;      reg %d: use_pos: %d&quot;, i, _use_pos[i]));
5383 
5384   int hint_reg, hint_regHi;
5385   Interval* register_hint = cur-&gt;register_hint();
5386   if (register_hint != NULL) {
5387     hint_reg = register_hint-&gt;assigned_reg();
5388     hint_regHi = register_hint-&gt;assigned_regHi();
5389 
5390     if (allocator()-&gt;is_precolored_cpu_interval(register_hint)) {
5391       assert(hint_reg != any_reg &amp;&amp; hint_regHi == any_reg, &quot;must be for fixed intervals&quot;);
5392       hint_regHi = hint_reg + 1;  // connect e.g. eax-edx
5393     }
5394     TRACE_LINEAR_SCAN(4, tty-&gt;print(&quot;      hint registers %d, %d from interval &quot;, hint_reg, hint_regHi); register_hint-&gt;print());
5395 
5396   } else {
5397     hint_reg = any_reg;
5398     hint_regHi = any_reg;
5399   }
5400   assert(hint_reg == any_reg || hint_reg != hint_regHi, &quot;hint reg and regHi equal&quot;);
5401   assert(cur-&gt;assigned_reg() == any_reg &amp;&amp; cur-&gt;assigned_regHi() == any_reg, &quot;register already assigned to interval&quot;);
5402 
5403   // the register must be free at least until this position
5404   int reg_needed_until = cur-&gt;from() + 1;
5405   int interval_to = cur-&gt;to();
5406 
5407   bool need_split = false;
5408   int split_pos;
5409   int reg;
5410   int regHi = any_reg;
5411 
5412   if (_adjacent_regs) {
5413     reg = find_free_double_reg(reg_needed_until, interval_to, hint_reg, &amp;need_split);
5414     regHi = reg + 1;
5415     if (reg == any_reg) {
5416       return false;
5417     }
5418     split_pos = MIN2(_use_pos[reg], _use_pos[regHi]);
5419 
5420   } else {
5421     reg = find_free_reg(reg_needed_until, interval_to, hint_reg, any_reg, &amp;need_split);
5422     if (reg == any_reg) {
5423       return false;
5424     }
5425     split_pos = _use_pos[reg];
5426 
5427     if (_num_phys_regs == 2) {
5428       regHi = find_free_reg(reg_needed_until, interval_to, hint_regHi, reg, &amp;need_split);
5429 
5430       if (_use_pos[reg] &lt; interval_to &amp;&amp; regHi == any_reg) {
5431         // do not split interval if only one register can be assigned until the split pos
5432         // (when one register is found for the whole interval, split&amp;spill is only
5433         // performed for the hi register)
5434         return false;
5435 
5436       } else if (regHi != any_reg) {
5437         split_pos = MIN2(split_pos, _use_pos[regHi]);
5438 
5439         // sort register numbers to prevent e.g. a move from eax,ebx to ebx,eax
5440         if (reg &gt; regHi) {
5441           int temp = reg;
5442           reg = regHi;
5443           regHi = temp;
5444         }
5445       }
5446     }
5447   }
5448 
5449   cur-&gt;assign_reg(reg, regHi);
5450   TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;selected register %d, %d&quot;, reg, regHi));
5451 
5452   assert(split_pos &gt; 0, &quot;invalid split_pos&quot;);
5453   if (need_split) {
5454     // register not available for full interval, so split it
5455     split_when_partial_register_available(cur, split_pos);
5456   }
5457 
5458   // only return true if interval is completely assigned
5459   return _num_phys_regs == 1 || regHi != any_reg;
5460 }
5461 
5462 
5463 int LinearScanWalker::find_locked_reg(int reg_needed_until, int interval_to, int ignore_reg, bool* need_split) {
5464   int max_reg = any_reg;
5465 
5466   for (int i = _first_reg; i &lt;= _last_reg; i++) {
5467     if (i == ignore_reg) {
5468       // this register must be ignored
5469 
5470     } else if (_use_pos[i] &gt; reg_needed_until) {
5471       if (max_reg == any_reg || _use_pos[i] &gt; _use_pos[max_reg]) {
5472         max_reg = i;
5473       }
5474     }
5475   }
5476 
5477   if (max_reg != any_reg &amp;&amp; _block_pos[max_reg] &lt;= interval_to) {
5478     *need_split = true;
5479   }
5480 
5481   return max_reg;
5482 }
5483 
5484 int LinearScanWalker::find_locked_double_reg(int reg_needed_until, int interval_to, bool* need_split) {
5485   assert((_last_reg - _first_reg + 1) % 2 == 0, &quot;adjust algorithm&quot;);
5486 
5487   int max_reg = any_reg;
5488 
5489   for (int i = _first_reg; i &lt; _last_reg; i+=2) {
5490     if (_use_pos[i] &gt; reg_needed_until &amp;&amp; _use_pos[i + 1] &gt; reg_needed_until) {
5491       if (max_reg == any_reg || _use_pos[i] &gt; _use_pos[max_reg]) {
5492         max_reg = i;
5493       }
5494     }
5495   }
5496 
5497   if (max_reg != any_reg &amp;&amp;
5498       (_block_pos[max_reg] &lt;= interval_to || _block_pos[max_reg + 1] &lt;= interval_to)) {
5499     *need_split = true;
5500   }
5501 
5502   return max_reg;
5503 }
5504 
5505 void LinearScanWalker::split_and_spill_intersecting_intervals(int reg, int regHi) {
5506   assert(reg != any_reg, &quot;no register assigned&quot;);
5507 
5508   for (int i = 0; i &lt; _spill_intervals[reg]-&gt;length(); i++) {
5509     Interval* it = _spill_intervals[reg]-&gt;at(i);
5510     remove_from_list(it);
5511     split_and_spill_interval(it);
5512   }
5513 
5514   if (regHi != any_reg) {
5515     IntervalList* processed = _spill_intervals[reg];
5516     for (int i = 0; i &lt; _spill_intervals[regHi]-&gt;length(); i++) {
5517       Interval* it = _spill_intervals[regHi]-&gt;at(i);
5518       if (processed-&gt;find(it) == -1) {
5519         remove_from_list(it);
5520         split_and_spill_interval(it);
5521       }
5522     }
5523   }
5524 }
5525 
5526 
5527 // Split an Interval and spill it to memory so that cur can be placed in a register
5528 void LinearScanWalker::alloc_locked_reg(Interval* cur) {
5529   TRACE_LINEAR_SCAN(2, tty-&gt;print(&quot;need to split and spill to get register for &quot;); cur-&gt;print());
5530 
5531   // collect current usage of registers
5532   init_use_lists(false);
5533   spill_exclude_active_fixed();
5534   assert(unhandled_first(fixedKind) == Interval::end(), &quot;must not have unhandled fixed intervals because all fixed intervals have a use at position 0&quot;);
5535   spill_block_inactive_fixed(cur);
5536   spill_collect_active_any();
5537   spill_collect_inactive_any(cur);
5538 
5539 #ifndef PRODUCT
5540   if (TraceLinearScanLevel &gt;= 4) {
5541     tty-&gt;print_cr(&quot;      state of registers:&quot;);
5542     for (int i = _first_reg; i &lt;= _last_reg; i++) {
5543       tty-&gt;print(&quot;      reg %d: use_pos: %d, block_pos: %d, intervals: &quot;, i, _use_pos[i], _block_pos[i]);
5544       for (int j = 0; j &lt; _spill_intervals[i]-&gt;length(); j++) {
5545         tty-&gt;print(&quot;%d &quot;, _spill_intervals[i]-&gt;at(j)-&gt;reg_num());
5546       }
5547       tty-&gt;cr();
5548     }
5549   }
5550 #endif
5551 
5552   // the register must be free at least until this position
5553   int reg_needed_until = MIN2(cur-&gt;first_usage(mustHaveRegister), cur-&gt;from() + 1);
5554   int interval_to = cur-&gt;to();
5555   assert (reg_needed_until &gt; 0 &amp;&amp; reg_needed_until &lt; max_jint, &quot;interval has no use&quot;);
5556 
5557   int split_pos = 0;
5558   int use_pos = 0;
5559   bool need_split = false;
5560   int reg, regHi;
5561 
5562   if (_adjacent_regs) {
5563     reg = find_locked_double_reg(reg_needed_until, interval_to, &amp;need_split);
5564     regHi = reg + 1;
5565 
5566     if (reg != any_reg) {
5567       use_pos = MIN2(_use_pos[reg], _use_pos[regHi]);
5568       split_pos = MIN2(_block_pos[reg], _block_pos[regHi]);
5569     }
5570   } else {
5571     reg = find_locked_reg(reg_needed_until, interval_to, cur-&gt;assigned_reg(), &amp;need_split);
5572     regHi = any_reg;
5573 
5574     if (reg != any_reg) {
5575       use_pos = _use_pos[reg];
5576       split_pos = _block_pos[reg];
5577 
5578       if (_num_phys_regs == 2) {
5579         if (cur-&gt;assigned_reg() != any_reg) {
5580           regHi = reg;
5581           reg = cur-&gt;assigned_reg();
5582         } else {
5583           regHi = find_locked_reg(reg_needed_until, interval_to, reg, &amp;need_split);
5584           if (regHi != any_reg) {
5585             use_pos = MIN2(use_pos, _use_pos[regHi]);
5586             split_pos = MIN2(split_pos, _block_pos[regHi]);
5587           }
5588         }
5589 
5590         if (regHi != any_reg &amp;&amp; reg &gt; regHi) {
5591           // sort register numbers to prevent e.g. a move from eax,ebx to ebx,eax
5592           int temp = reg;
5593           reg = regHi;
5594           regHi = temp;
5595         }
5596       }
5597     }
5598   }
5599 
5600   if (reg == any_reg || (_num_phys_regs == 2 &amp;&amp; regHi == any_reg) || use_pos &lt;= cur-&gt;first_usage(mustHaveRegister)) {
5601     // the first use of cur is later than the spilling position -&gt; spill cur
5602     TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;able to spill current interval. first_usage(register): %d, use_pos: %d&quot;, cur-&gt;first_usage(mustHaveRegister), use_pos));
5603 
5604     if (cur-&gt;first_usage(mustHaveRegister) &lt;= cur-&gt;from() + 1) {
5605       assert(false, &quot;cannot spill interval that is used in first instruction (possible reason: no register found)&quot;);
5606       // assign a reasonable register and do a bailout in product mode to avoid errors
5607       allocator()-&gt;assign_spill_slot(cur);
5608       BAILOUT(&quot;LinearScan: no register found&quot;);
5609     }
5610 
5611     split_and_spill_interval(cur);
5612   } else {
5613     TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;decided to use register %d, %d&quot;, reg, regHi));
5614     assert(reg != any_reg &amp;&amp; (_num_phys_regs == 1 || regHi != any_reg), &quot;no register found&quot;);
5615     assert(split_pos &gt; 0, &quot;invalid split_pos&quot;);
5616     assert(need_split == false || split_pos &gt; cur-&gt;from(), &quot;splitting interval at from&quot;);
5617 
5618     cur-&gt;assign_reg(reg, regHi);
5619     if (need_split) {
5620       // register not available for full interval, so split it
5621       split_when_partial_register_available(cur, split_pos);
5622     }
5623 
5624     // perform splitting and spilling for all affected intervalls
5625     split_and_spill_intersecting_intervals(reg, regHi);
5626   }
5627 }
5628 
5629 bool LinearScanWalker::no_allocation_possible(Interval* cur) {
5630 #ifdef X86
5631   // fast calculation of intervals that can never get a register because the
5632   // the next instruction is a call that blocks all registers
5633   // Note: this does not work if callee-saved registers are available (e.g. on Sparc)
5634 
5635   // check if this interval is the result of a split operation
5636   // (an interval got a register until this position)
5637   int pos = cur-&gt;from();
5638   if ((pos &amp; 1) == 1) {
5639     // the current instruction is a call that blocks all registers
5640     if (pos &lt; allocator()-&gt;max_lir_op_id() &amp;&amp; allocator()-&gt;has_call(pos + 1)) {
5641       TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      free register cannot be available because all registers blocked by following call&quot;));
5642 
5643       // safety check that there is really no register available
5644       assert(alloc_free_reg(cur) == false, &quot;found a register for this interval&quot;);
5645       return true;
5646     }
5647 
5648   }
5649 #endif
5650   return false;
5651 }
5652 
5653 void LinearScanWalker::init_vars_for_alloc(Interval* cur) {
5654   BasicType type = cur-&gt;type();
5655   _num_phys_regs = LinearScan::num_physical_regs(type);
5656   _adjacent_regs = LinearScan::requires_adjacent_regs(type);
5657 
5658   if (pd_init_regs_for_alloc(cur)) {
5659     // the appropriate register range was selected.
5660   } else if (type == T_FLOAT || type == T_DOUBLE) {
5661     _first_reg = pd_first_fpu_reg;
5662     _last_reg = pd_last_fpu_reg;
5663   } else {
5664     _first_reg = pd_first_cpu_reg;
5665     _last_reg = FrameMap::last_cpu_reg();
5666   }
5667 
5668   assert(0 &lt;= _first_reg &amp;&amp; _first_reg &lt; LinearScan::nof_regs, &quot;out of range&quot;);
5669   assert(0 &lt;= _last_reg &amp;&amp; _last_reg &lt; LinearScan::nof_regs, &quot;out of range&quot;);
5670 }
5671 
5672 
5673 bool LinearScanWalker::is_move(LIR_Op* op, Interval* from, Interval* to) {
5674   if (op-&gt;code() != lir_move) {
5675     return false;
5676   }
5677   assert(op-&gt;as_Op1() != NULL, &quot;move must be LIR_Op1&quot;);
5678 
5679   LIR_Opr in = ((LIR_Op1*)op)-&gt;in_opr();
5680   LIR_Opr res = ((LIR_Op1*)op)-&gt;result_opr();
5681   return in-&gt;is_virtual() &amp;&amp; res-&gt;is_virtual() &amp;&amp; in-&gt;vreg_number() == from-&gt;reg_num() &amp;&amp; res-&gt;vreg_number() == to-&gt;reg_num();
5682 }
5683 
5684 // optimization (especially for phi functions of nested loops):
5685 // assign same spill slot to non-intersecting intervals
5686 void LinearScanWalker::combine_spilled_intervals(Interval* cur) {
5687   if (cur-&gt;is_split_child()) {
5688     // optimization is only suitable for split parents
5689     return;
5690   }
5691 
5692   Interval* register_hint = cur-&gt;register_hint(false);
5693   if (register_hint == NULL) {
5694     // cur is not the target of a move, otherwise register_hint would be set
5695     return;
5696   }
5697   assert(register_hint-&gt;is_split_parent(), &quot;register hint must be split parent&quot;);
5698 
5699   if (cur-&gt;spill_state() != noOptimization || register_hint-&gt;spill_state() != noOptimization) {
5700     // combining the stack slots for intervals where spill move optimization is applied
5701     // is not benefitial and would cause problems
5702     return;
5703   }
5704 
5705   int begin_pos = cur-&gt;from();
5706   int end_pos = cur-&gt;to();
5707   if (end_pos &gt; allocator()-&gt;max_lir_op_id() || (begin_pos &amp; 1) != 0 || (end_pos &amp; 1) != 0) {
5708     // safety check that lir_op_with_id is allowed
5709     return;
5710   }
5711 
5712   if (!is_move(allocator()-&gt;lir_op_with_id(begin_pos), register_hint, cur) || !is_move(allocator()-&gt;lir_op_with_id(end_pos), cur, register_hint)) {
5713     // cur and register_hint are not connected with two moves
5714     return;
5715   }
5716 
5717   Interval* begin_hint = register_hint-&gt;split_child_at_op_id(begin_pos, LIR_OpVisitState::inputMode);
5718   Interval* end_hint = register_hint-&gt;split_child_at_op_id(end_pos, LIR_OpVisitState::outputMode);
5719   if (begin_hint == end_hint || begin_hint-&gt;to() != begin_pos || end_hint-&gt;from() != end_pos) {
5720     // register_hint must be split, otherwise the re-writing of use positions does not work
5721     return;
5722   }
5723 
5724   assert(begin_hint-&gt;assigned_reg() != any_reg, &quot;must have register assigned&quot;);
5725   assert(end_hint-&gt;assigned_reg() == any_reg, &quot;must not have register assigned&quot;);
5726   assert(cur-&gt;first_usage(mustHaveRegister) == begin_pos, &quot;must have use position at begin of interval because of move&quot;);
5727   assert(end_hint-&gt;first_usage(mustHaveRegister) == end_pos, &quot;must have use position at begin of interval because of move&quot;);
5728 
5729   if (begin_hint-&gt;assigned_reg() &lt; LinearScan::nof_regs) {
5730     // register_hint is not spilled at begin_pos, so it would not be benefitial to immediately spill cur
5731     return;
5732   }
5733   assert(register_hint-&gt;canonical_spill_slot() != -1, &quot;must be set when part of interval was spilled&quot;);
5734 
5735   // modify intervals such that cur gets the same stack slot as register_hint
5736   // delete use positions to prevent the intervals to get a register at beginning
5737   cur-&gt;set_canonical_spill_slot(register_hint-&gt;canonical_spill_slot());
5738   cur-&gt;remove_first_use_pos();
5739   end_hint-&gt;remove_first_use_pos();
5740 }
5741 
5742 
5743 // allocate a physical register or memory location to an interval
5744 bool LinearScanWalker::activate_current() {
5745   Interval* cur = current();
5746   bool result = true;
5747 
5748   TRACE_LINEAR_SCAN(2, tty-&gt;print   (&quot;+++++ activating interval &quot;); cur-&gt;print());
5749   TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      split_parent: %d, insert_move_when_activated: %d&quot;, cur-&gt;split_parent()-&gt;reg_num(), cur-&gt;insert_move_when_activated()));
5750 
5751   if (cur-&gt;assigned_reg() &gt;= LinearScan::nof_regs) {
5752     // activating an interval that has a stack slot assigned -&gt; split it at first use position
5753     // used for method parameters
5754     TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      interval has spill slot assigned (method parameter) -&gt; split it before first use&quot;));
5755 
5756     split_stack_interval(cur);
5757     result = false;
5758 
5759   } else if (allocator()-&gt;gen()-&gt;is_vreg_flag_set(cur-&gt;reg_num(), LIRGenerator::must_start_in_memory)) {
5760     // activating an interval that must start in a stack slot, but may get a register later
5761     // used for lir_roundfp: rounding is done by store to stack and reload later
5762     TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      interval must start in stack slot -&gt; split it before first use&quot;));
5763     assert(cur-&gt;assigned_reg() == any_reg &amp;&amp; cur-&gt;assigned_regHi() == any_reg, &quot;register already assigned&quot;);
5764 
5765     allocator()-&gt;assign_spill_slot(cur);
5766     split_stack_interval(cur);
5767     result = false;
5768 
5769   } else if (cur-&gt;assigned_reg() == any_reg) {
5770     // interval has not assigned register -&gt; normal allocation
5771     // (this is the normal case for most intervals)
5772     TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      normal allocation of register&quot;));
5773 
5774     // assign same spill slot to non-intersecting intervals
5775     combine_spilled_intervals(cur);
5776 
5777     init_vars_for_alloc(cur);
5778     if (no_allocation_possible(cur) || !alloc_free_reg(cur)) {
5779       // no empty register available.
5780       // split and spill another interval so that this interval gets a register
5781       alloc_locked_reg(cur);
5782     }
5783 
5784     // spilled intervals need not be move to active-list
5785     if (cur-&gt;assigned_reg() &gt;= LinearScan::nof_regs) {
5786       result = false;
5787     }
5788   }
5789 
5790   // load spilled values that become active from stack slot to register
5791   if (cur-&gt;insert_move_when_activated()) {
5792     assert(cur-&gt;is_split_child(), &quot;must be&quot;);
5793     assert(cur-&gt;current_split_child() != NULL, &quot;must be&quot;);
5794     assert(cur-&gt;current_split_child()-&gt;reg_num() != cur-&gt;reg_num(), &quot;cannot insert move between same interval&quot;);
5795     TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;Inserting move from interval %d to %d because insert_move_when_activated is set&quot;, cur-&gt;current_split_child()-&gt;reg_num(), cur-&gt;reg_num()));
5796 
5797     insert_move(cur-&gt;from(), cur-&gt;current_split_child(), cur);
5798   }
5799   cur-&gt;make_current_split_child();
5800 
5801   return result; // true = interval is moved to active list
5802 }
5803 
5804 
5805 // Implementation of EdgeMoveOptimizer
5806 
5807 EdgeMoveOptimizer::EdgeMoveOptimizer() :
5808   _edge_instructions(4),
5809   _edge_instructions_idx(4)
5810 {
5811 }
5812 
5813 void EdgeMoveOptimizer::optimize(BlockList* code) {
5814   EdgeMoveOptimizer optimizer = EdgeMoveOptimizer();
5815 
5816   // ignore the first block in the list (index 0 is not processed)
5817   for (int i = code-&gt;length() - 1; i &gt;= 1; i--) {
5818     BlockBegin* block = code-&gt;at(i);
5819 
5820     if (block-&gt;number_of_preds() &gt; 1 &amp;&amp; !block-&gt;is_set(BlockBegin::exception_entry_flag)) {
5821       optimizer.optimize_moves_at_block_end(block);
5822     }
5823     if (block-&gt;number_of_sux() == 2) {
5824       optimizer.optimize_moves_at_block_begin(block);
5825     }
5826   }
5827 }
5828 
5829 
5830 // clear all internal data structures
5831 void EdgeMoveOptimizer::init_instructions() {
5832   _edge_instructions.clear();
5833   _edge_instructions_idx.clear();
5834 }
5835 
5836 // append a lir-instruction-list and the index of the current operation in to the list
5837 void EdgeMoveOptimizer::append_instructions(LIR_OpList* instructions, int instructions_idx) {
5838   _edge_instructions.append(instructions);
5839   _edge_instructions_idx.append(instructions_idx);
5840 }
5841 
5842 // return the current operation of the given edge (predecessor or successor)
5843 LIR_Op* EdgeMoveOptimizer::instruction_at(int edge) {
5844   LIR_OpList* instructions = _edge_instructions.at(edge);
5845   int idx = _edge_instructions_idx.at(edge);
5846 
5847   if (idx &lt; instructions-&gt;length()) {
5848     return instructions-&gt;at(idx);
5849   } else {
5850     return NULL;
5851   }
5852 }
5853 
5854 // removes the current operation of the given edge (predecessor or successor)
5855 void EdgeMoveOptimizer::remove_cur_instruction(int edge, bool decrement_index) {
5856   LIR_OpList* instructions = _edge_instructions.at(edge);
5857   int idx = _edge_instructions_idx.at(edge);
5858   instructions-&gt;remove_at(idx);
5859 
5860   if (decrement_index) {
5861     _edge_instructions_idx.at_put(edge, idx - 1);
5862   }
5863 }
5864 
5865 
5866 bool EdgeMoveOptimizer::operations_different(LIR_Op* op1, LIR_Op* op2) {
5867   if (op1 == NULL || op2 == NULL) {
5868     // at least one block is already empty -&gt; no optimization possible
5869     return true;
5870   }
5871 
5872   if (op1-&gt;code() == lir_move &amp;&amp; op2-&gt;code() == lir_move) {
5873     assert(op1-&gt;as_Op1() != NULL, &quot;move must be LIR_Op1&quot;);
5874     assert(op2-&gt;as_Op1() != NULL, &quot;move must be LIR_Op1&quot;);
5875     LIR_Op1* move1 = (LIR_Op1*)op1;
5876     LIR_Op1* move2 = (LIR_Op1*)op2;
5877     if (move1-&gt;info() == move2-&gt;info() &amp;&amp; move1-&gt;in_opr() == move2-&gt;in_opr() &amp;&amp; move1-&gt;result_opr() == move2-&gt;result_opr()) {
5878       // these moves are exactly equal and can be optimized
5879       return false;
5880     }
5881 
5882   } else if (op1-&gt;code() == lir_fxch &amp;&amp; op2-&gt;code() == lir_fxch) {
5883     assert(op1-&gt;as_Op1() != NULL, &quot;fxch must be LIR_Op1&quot;);
5884     assert(op2-&gt;as_Op1() != NULL, &quot;fxch must be LIR_Op1&quot;);
5885     LIR_Op1* fxch1 = (LIR_Op1*)op1;
5886     LIR_Op1* fxch2 = (LIR_Op1*)op2;
5887     if (fxch1-&gt;in_opr()-&gt;as_jint() == fxch2-&gt;in_opr()-&gt;as_jint()) {
5888       // equal FPU stack operations can be optimized
5889       return false;
5890     }
5891 
5892   } else if (op1-&gt;code() == lir_fpop_raw &amp;&amp; op2-&gt;code() == lir_fpop_raw) {
5893     // equal FPU stack operations can be optimized
5894     return false;
5895   }
5896 
5897   // no optimization possible
5898   return true;
5899 }
5900 
5901 void EdgeMoveOptimizer::optimize_moves_at_block_end(BlockBegin* block) {
5902   TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;optimizing moves at end of block B%d&quot;, block-&gt;block_id()));
5903 
5904   if (block-&gt;is_predecessor(block)) {
5905     // currently we can&#39;t handle this correctly.
5906     return;
5907   }
5908 
5909   init_instructions();
5910   int num_preds = block-&gt;number_of_preds();
5911   assert(num_preds &gt; 1, &quot;do not call otherwise&quot;);
5912   assert(!block-&gt;is_set(BlockBegin::exception_entry_flag), &quot;exception handlers not allowed&quot;);
5913 
5914   // setup a list with the lir-instructions of all predecessors
5915   int i;
5916   for (i = 0; i &lt; num_preds; i++) {
5917     BlockBegin* pred = block-&gt;pred_at(i);
5918     LIR_OpList* pred_instructions = pred-&gt;lir()-&gt;instructions_list();
5919 
5920     if (pred-&gt;number_of_sux() != 1) {
5921       // this can happen with switch-statements where multiple edges are between
5922       // the same blocks.
5923       return;
5924     }
5925 
5926     assert(pred-&gt;number_of_sux() == 1, &quot;can handle only one successor&quot;);
5927     assert(pred-&gt;sux_at(0) == block, &quot;invalid control flow&quot;);
5928     assert(pred_instructions-&gt;last()-&gt;code() == lir_branch, &quot;block with successor must end with branch&quot;);
5929     assert(pred_instructions-&gt;last()-&gt;as_OpBranch() != NULL, &quot;branch must be LIR_OpBranch&quot;);
5930     assert(pred_instructions-&gt;last()-&gt;as_OpBranch()-&gt;cond() == lir_cond_always, &quot;block must end with unconditional branch&quot;);
5931 
5932     if (pred_instructions-&gt;last()-&gt;info() != NULL) {
5933       // can not optimize instructions when debug info is needed
5934       return;
5935     }
5936 
5937     // ignore the unconditional branch at the end of the block
5938     append_instructions(pred_instructions, pred_instructions-&gt;length() - 2);
5939   }
5940 
5941 
5942   // process lir-instructions while all predecessors end with the same instruction
5943   while (true) {
5944     LIR_Op* op = instruction_at(0);
5945     for (i = 1; i &lt; num_preds; i++) {
5946       if (operations_different(op, instruction_at(i))) {
5947         // these instructions are different and cannot be optimized -&gt;
5948         // no further optimization possible
5949         return;
5950       }
5951     }
5952 
5953     TRACE_LINEAR_SCAN(4, tty-&gt;print(&quot;found instruction that is equal in all %d predecessors: &quot;, num_preds); op-&gt;print());
5954 
5955     // insert the instruction at the beginning of the current block
5956     block-&gt;lir()-&gt;insert_before(1, op);
5957 
5958     // delete the instruction at the end of all predecessors
5959     for (i = 0; i &lt; num_preds; i++) {
5960       remove_cur_instruction(i, true);
5961     }
5962   }
5963 }
5964 
5965 
5966 void EdgeMoveOptimizer::optimize_moves_at_block_begin(BlockBegin* block) {
5967   TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;optimization moves at begin of block B%d&quot;, block-&gt;block_id()));
5968 
5969   init_instructions();
5970   int num_sux = block-&gt;number_of_sux();
5971 
5972   LIR_OpList* cur_instructions = block-&gt;lir()-&gt;instructions_list();
5973 
5974   assert(num_sux == 2, &quot;method should not be called otherwise&quot;);
5975   assert(cur_instructions-&gt;last()-&gt;code() == lir_branch, &quot;block with successor must end with branch&quot;);
5976   assert(cur_instructions-&gt;last()-&gt;as_OpBranch() != NULL, &quot;branch must be LIR_OpBranch&quot;);
5977   assert(cur_instructions-&gt;last()-&gt;as_OpBranch()-&gt;cond() == lir_cond_always, &quot;block must end with unconditional branch&quot;);
5978 
5979   if (cur_instructions-&gt;last()-&gt;info() != NULL) {
5980     // can no optimize instructions when debug info is needed
5981     return;
5982   }
5983 
5984   LIR_Op* branch = cur_instructions-&gt;at(cur_instructions-&gt;length() - 2);
5985   if (branch-&gt;info() != NULL || (branch-&gt;code() != lir_branch &amp;&amp; branch-&gt;code() != lir_cond_float_branch)) {
5986     // not a valid case for optimization
5987     // currently, only blocks that end with two branches (conditional branch followed
5988     // by unconditional branch) are optimized
5989     return;
5990   }
5991 
5992   // now it is guaranteed that the block ends with two branch instructions.
5993   // the instructions are inserted at the end of the block before these two branches
5994   int insert_idx = cur_instructions-&gt;length() - 2;
5995 
5996   int i;
5997 #ifdef ASSERT
5998   for (i = insert_idx - 1; i &gt;= 0; i--) {
5999     LIR_Op* op = cur_instructions-&gt;at(i);
6000     if ((op-&gt;code() == lir_branch || op-&gt;code() == lir_cond_float_branch) &amp;&amp; ((LIR_OpBranch*)op)-&gt;block() != NULL) {
6001       assert(false, &quot;block with two successors can have only two branch instructions&quot;);
6002     }
6003   }
6004 #endif
6005 
6006   // setup a list with the lir-instructions of all successors
6007   for (i = 0; i &lt; num_sux; i++) {
6008     BlockBegin* sux = block-&gt;sux_at(i);
6009     LIR_OpList* sux_instructions = sux-&gt;lir()-&gt;instructions_list();
6010 
6011     assert(sux_instructions-&gt;at(0)-&gt;code() == lir_label, &quot;block must start with label&quot;);
6012 
6013     if (sux-&gt;number_of_preds() != 1) {
6014       // this can happen with switch-statements where multiple edges are between
6015       // the same blocks.
6016       return;
6017     }
6018     assert(sux-&gt;pred_at(0) == block, &quot;invalid control flow&quot;);
6019     assert(!sux-&gt;is_set(BlockBegin::exception_entry_flag), &quot;exception handlers not allowed&quot;);
6020 
6021     // ignore the label at the beginning of the block
6022     append_instructions(sux_instructions, 1);
6023   }
6024 
6025   // process lir-instructions while all successors begin with the same instruction
6026   while (true) {
6027     LIR_Op* op = instruction_at(0);
6028     for (i = 1; i &lt; num_sux; i++) {
6029       if (operations_different(op, instruction_at(i))) {
6030         // these instructions are different and cannot be optimized -&gt;
6031         // no further optimization possible
6032         return;
6033       }
6034     }
6035 
6036     TRACE_LINEAR_SCAN(4, tty-&gt;print(&quot;----- found instruction that is equal in all %d successors: &quot;, num_sux); op-&gt;print());
6037 
6038     // insert instruction at end of current block
6039     block-&gt;lir()-&gt;insert_before(insert_idx, op);
6040     insert_idx++;
6041 
6042     // delete the instructions at the beginning of all successors
6043     for (i = 0; i &lt; num_sux; i++) {
6044       remove_cur_instruction(i, false);
6045     }
6046   }
6047 }
6048 
6049 
6050 // Implementation of ControlFlowOptimizer
6051 
6052 ControlFlowOptimizer::ControlFlowOptimizer() :
6053   _original_preds(4)
6054 {
6055 }
6056 
6057 void ControlFlowOptimizer::optimize(BlockList* code) {
6058   ControlFlowOptimizer optimizer = ControlFlowOptimizer();
6059 
6060   // push the OSR entry block to the end so that we&#39;re not jumping over it.
6061   BlockBegin* osr_entry = code-&gt;at(0)-&gt;end()-&gt;as_Base()-&gt;osr_entry();
6062   if (osr_entry) {
6063     int index = osr_entry-&gt;linear_scan_number();
6064     assert(code-&gt;at(index) == osr_entry, &quot;wrong index&quot;);
6065     code-&gt;remove_at(index);
6066     code-&gt;append(osr_entry);
6067   }
6068 
6069   optimizer.reorder_short_loops(code);
6070   optimizer.delete_empty_blocks(code);
6071   optimizer.delete_unnecessary_jumps(code);
6072   optimizer.delete_jumps_to_return(code);
6073 }
6074 
6075 void ControlFlowOptimizer::reorder_short_loop(BlockList* code, BlockBegin* header_block, int header_idx) {
6076   int i = header_idx + 1;
6077   int max_end = MIN2(header_idx + ShortLoopSize, code-&gt;length());
6078   while (i &lt; max_end &amp;&amp; code-&gt;at(i)-&gt;loop_depth() &gt;= header_block-&gt;loop_depth()) {
6079     i++;
6080   }
6081 
6082   if (i == code-&gt;length() || code-&gt;at(i)-&gt;loop_depth() &lt; header_block-&gt;loop_depth()) {
6083     int end_idx = i - 1;
6084     BlockBegin* end_block = code-&gt;at(end_idx);
6085 
6086     if (end_block-&gt;number_of_sux() == 1 &amp;&amp; end_block-&gt;sux_at(0) == header_block) {
6087       // short loop from header_idx to end_idx found -&gt; reorder blocks such that
6088       // the header_block is the last block instead of the first block of the loop
6089       TRACE_LINEAR_SCAN(1, tty-&gt;print_cr(&quot;Reordering short loop: length %d, header B%d, end B%d&quot;,
6090                                          end_idx - header_idx + 1,
6091                                          header_block-&gt;block_id(), end_block-&gt;block_id()));
6092 
6093       for (int j = header_idx; j &lt; end_idx; j++) {
6094         code-&gt;at_put(j, code-&gt;at(j + 1));
6095       }
6096       code-&gt;at_put(end_idx, header_block);
6097 
6098       // correct the flags so that any loop alignment occurs in the right place.
6099       assert(code-&gt;at(end_idx)-&gt;is_set(BlockBegin::backward_branch_target_flag), &quot;must be backward branch target&quot;);
6100       code-&gt;at(end_idx)-&gt;clear(BlockBegin::backward_branch_target_flag);
6101       code-&gt;at(header_idx)-&gt;set(BlockBegin::backward_branch_target_flag);
6102     }
6103   }
6104 }
6105 
6106 void ControlFlowOptimizer::reorder_short_loops(BlockList* code) {
6107   for (int i = code-&gt;length() - 1; i &gt;= 0; i--) {
6108     BlockBegin* block = code-&gt;at(i);
6109 
6110     if (block-&gt;is_set(BlockBegin::linear_scan_loop_header_flag)) {
6111       reorder_short_loop(code, block, i);
6112     }
6113   }
6114 
6115   DEBUG_ONLY(verify(code));
6116 }
6117 
6118 // only blocks with exactly one successor can be deleted. Such blocks
6119 // must always end with an unconditional branch to this successor
6120 bool ControlFlowOptimizer::can_delete_block(BlockBegin* block) {
6121   if (block-&gt;number_of_sux() != 1 || block-&gt;number_of_exception_handlers() != 0 || block-&gt;is_entry_block()) {
6122     return false;
6123   }
6124 
6125   LIR_OpList* instructions = block-&gt;lir()-&gt;instructions_list();
6126 
6127   assert(instructions-&gt;length() &gt;= 2, &quot;block must have label and branch&quot;);
6128   assert(instructions-&gt;at(0)-&gt;code() == lir_label, &quot;first instruction must always be a label&quot;);
6129   assert(instructions-&gt;last()-&gt;as_OpBranch() != NULL, &quot;last instrcution must always be a branch&quot;);
6130   assert(instructions-&gt;last()-&gt;as_OpBranch()-&gt;cond() == lir_cond_always, &quot;branch must be unconditional&quot;);
6131   assert(instructions-&gt;last()-&gt;as_OpBranch()-&gt;block() == block-&gt;sux_at(0), &quot;branch target must be the successor&quot;);
6132 
6133   // block must have exactly one successor
6134 
6135   if (instructions-&gt;length() == 2 &amp;&amp; instructions-&gt;last()-&gt;info() == NULL) {
6136     return true;
6137   }
6138   return false;
6139 }
6140 
6141 // substitute branch targets in all branch-instructions of this blocks
6142 void ControlFlowOptimizer::substitute_branch_target(BlockBegin* block, BlockBegin* target_from, BlockBegin* target_to) {
6143   TRACE_LINEAR_SCAN(3, tty-&gt;print_cr(&quot;Deleting empty block: substituting from B%d to B%d inside B%d&quot;, target_from-&gt;block_id(), target_to-&gt;block_id(), block-&gt;block_id()));
6144 
6145   LIR_OpList* instructions = block-&gt;lir()-&gt;instructions_list();
6146 
6147   assert(instructions-&gt;at(0)-&gt;code() == lir_label, &quot;first instruction must always be a label&quot;);
6148   for (int i = instructions-&gt;length() - 1; i &gt;= 1; i--) {
6149     LIR_Op* op = instructions-&gt;at(i);
6150 
6151     if (op-&gt;code() == lir_branch || op-&gt;code() == lir_cond_float_branch) {
6152       assert(op-&gt;as_OpBranch() != NULL, &quot;branch must be of type LIR_OpBranch&quot;);
6153       LIR_OpBranch* branch = (LIR_OpBranch*)op;
6154 
6155       if (branch-&gt;block() == target_from) {
6156         branch-&gt;change_block(target_to);
6157       }
6158       if (branch-&gt;ublock() == target_from) {
6159         branch-&gt;change_ublock(target_to);
6160       }
6161     }
6162   }
6163 }
6164 
6165 void ControlFlowOptimizer::delete_empty_blocks(BlockList* code) {
6166   int old_pos = 0;
6167   int new_pos = 0;
6168   int num_blocks = code-&gt;length();
6169 
6170   while (old_pos &lt; num_blocks) {
6171     BlockBegin* block = code-&gt;at(old_pos);
6172 
6173     if (can_delete_block(block)) {
6174       BlockBegin* new_target = block-&gt;sux_at(0);
6175 
6176       // propagate backward branch target flag for correct code alignment
6177       if (block-&gt;is_set(BlockBegin::backward_branch_target_flag)) {
6178         new_target-&gt;set(BlockBegin::backward_branch_target_flag);
6179       }
6180 
6181       // collect a list with all predecessors that contains each predecessor only once
6182       // the predecessors of cur are changed during the substitution, so a copy of the
6183       // predecessor list is necessary
6184       int j;
6185       _original_preds.clear();
6186       for (j = block-&gt;number_of_preds() - 1; j &gt;= 0; j--) {
6187         BlockBegin* pred = block-&gt;pred_at(j);
6188         if (_original_preds.find(pred) == -1) {
6189           _original_preds.append(pred);
6190         }
6191       }
6192 
6193       for (j = _original_preds.length() - 1; j &gt;= 0; j--) {
6194         BlockBegin* pred = _original_preds.at(j);
6195         substitute_branch_target(pred, block, new_target);
6196         pred-&gt;substitute_sux(block, new_target);
6197       }
6198     } else {
6199       // adjust position of this block in the block list if blocks before
6200       // have been deleted
6201       if (new_pos != old_pos) {
6202         code-&gt;at_put(new_pos, code-&gt;at(old_pos));
6203       }
6204       new_pos++;
6205     }
6206     old_pos++;
6207   }
6208   code-&gt;trunc_to(new_pos);
6209 
6210   DEBUG_ONLY(verify(code));
6211 }
6212 
6213 void ControlFlowOptimizer::delete_unnecessary_jumps(BlockList* code) {
6214   // skip the last block because there a branch is always necessary
6215   for (int i = code-&gt;length() - 2; i &gt;= 0; i--) {
6216     BlockBegin* block = code-&gt;at(i);
6217     LIR_OpList* instructions = block-&gt;lir()-&gt;instructions_list();
6218 
6219     LIR_Op* last_op = instructions-&gt;last();
6220     if (last_op-&gt;code() == lir_branch) {
6221       assert(last_op-&gt;as_OpBranch() != NULL, &quot;branch must be of type LIR_OpBranch&quot;);
6222       LIR_OpBranch* last_branch = (LIR_OpBranch*)last_op;
6223 
6224       assert(last_branch-&gt;block() != NULL, &quot;last branch must always have a block as target&quot;);
6225       assert(last_branch-&gt;label() == last_branch-&gt;block()-&gt;label(), &quot;must be equal&quot;);
6226 
6227       if (last_branch-&gt;info() == NULL) {
6228         if (last_branch-&gt;block() == code-&gt;at(i + 1)) {
6229 
6230           TRACE_LINEAR_SCAN(3, tty-&gt;print_cr(&quot;Deleting unconditional branch at end of block B%d&quot;, block-&gt;block_id()));
6231 
6232           // delete last branch instruction
6233           instructions-&gt;trunc_to(instructions-&gt;length() - 1);
6234 
6235         } else {
6236           LIR_Op* prev_op = instructions-&gt;at(instructions-&gt;length() - 2);
6237           if (prev_op-&gt;code() == lir_branch || prev_op-&gt;code() == lir_cond_float_branch) {
6238             assert(prev_op-&gt;as_OpBranch() != NULL, &quot;branch must be of type LIR_OpBranch&quot;);
6239             LIR_OpBranch* prev_branch = (LIR_OpBranch*)prev_op;
6240 
6241             if (prev_branch-&gt;stub() == NULL) {
6242 
6243               LIR_Op2* prev_cmp = NULL;
6244               // There might be a cmove inserted for profiling which depends on the same
6245               // compare. If we change the condition of the respective compare, we have
6246               // to take care of this cmove as well.
6247               LIR_Op2* prev_cmove = NULL;
6248 
6249               for(int j = instructions-&gt;length() - 3; j &gt;= 0 &amp;&amp; prev_cmp == NULL; j--) {
6250                 prev_op = instructions-&gt;at(j);
6251                 // check for the cmove
6252                 if (prev_op-&gt;code() == lir_cmove) {
6253                   assert(prev_op-&gt;as_Op2() != NULL, &quot;cmove must be of type LIR_Op2&quot;);
6254                   prev_cmove = (LIR_Op2*)prev_op;
6255                   assert(prev_branch-&gt;cond() == prev_cmove-&gt;condition(), &quot;should be the same&quot;);
6256                 }
6257                 if (prev_op-&gt;code() == lir_cmp) {
6258                   assert(prev_op-&gt;as_Op2() != NULL, &quot;branch must be of type LIR_Op2&quot;);
6259                   prev_cmp = (LIR_Op2*)prev_op;
6260                   assert(prev_branch-&gt;cond() == prev_cmp-&gt;condition(), &quot;should be the same&quot;);
6261                 }
6262               }
6263               // Guarantee because it is dereferenced below.
6264               guarantee(prev_cmp != NULL, &quot;should have found comp instruction for branch&quot;);
6265               if (prev_branch-&gt;block() == code-&gt;at(i + 1) &amp;&amp; prev_branch-&gt;info() == NULL) {
6266 
6267                 TRACE_LINEAR_SCAN(3, tty-&gt;print_cr(&quot;Negating conditional branch and deleting unconditional branch at end of block B%d&quot;, block-&gt;block_id()));
6268 
6269                 // eliminate a conditional branch to the immediate successor
6270                 prev_branch-&gt;change_block(last_branch-&gt;block());
6271                 prev_branch-&gt;negate_cond();
6272                 prev_cmp-&gt;set_condition(prev_branch-&gt;cond());
6273                 instructions-&gt;trunc_to(instructions-&gt;length() - 1);
6274                 // if we do change the condition, we have to change the cmove as well
6275                 if (prev_cmove != NULL) {
6276                   prev_cmove-&gt;set_condition(prev_branch-&gt;cond());
6277                   LIR_Opr t = prev_cmove-&gt;in_opr1();
6278                   prev_cmove-&gt;set_in_opr1(prev_cmove-&gt;in_opr2());
6279                   prev_cmove-&gt;set_in_opr2(t);
6280                 }
6281               }
6282             }
6283           }
6284         }
6285       }
6286     }
6287   }
6288 
6289   DEBUG_ONLY(verify(code));
6290 }
6291 
6292 void ControlFlowOptimizer::delete_jumps_to_return(BlockList* code) {
6293 #ifdef ASSERT
6294   ResourceBitMap return_converted(BlockBegin::number_of_blocks());
6295 #endif
6296 
6297   for (int i = code-&gt;length() - 1; i &gt;= 0; i--) {
6298     BlockBegin* block = code-&gt;at(i);
6299     LIR_OpList* cur_instructions = block-&gt;lir()-&gt;instructions_list();
6300     LIR_Op*     cur_last_op = cur_instructions-&gt;last();
6301 
6302     assert(cur_instructions-&gt;at(0)-&gt;code() == lir_label, &quot;first instruction must always be a label&quot;);
6303     if (cur_instructions-&gt;length() == 2 &amp;&amp; cur_last_op-&gt;code() == lir_return) {
6304       // the block contains only a label and a return
6305       // if a predecessor ends with an unconditional jump to this block, then the jump
6306       // can be replaced with a return instruction
6307       //
6308       // Note: the original block with only a return statement cannot be deleted completely
6309       //       because the predecessors might have other (conditional) jumps to this block
6310       //       -&gt; this may lead to unnecesary return instructions in the final code
6311 
6312       assert(cur_last_op-&gt;info() == NULL, &quot;return instructions do not have debug information&quot;);
6313       assert(block-&gt;number_of_sux() == 0 ||
6314              (return_converted.at(block-&gt;block_id()) &amp;&amp; block-&gt;number_of_sux() == 1),
6315              &quot;blocks that end with return must not have successors&quot;);
6316 
6317       assert(cur_last_op-&gt;as_Op1() != NULL, &quot;return must be LIR_Op1&quot;);
6318       LIR_Opr return_opr = ((LIR_Op1*)cur_last_op)-&gt;in_opr();
6319 
6320       for (int j = block-&gt;number_of_preds() - 1; j &gt;= 0; j--) {
6321         BlockBegin* pred = block-&gt;pred_at(j);
6322         LIR_OpList* pred_instructions = pred-&gt;lir()-&gt;instructions_list();
6323         LIR_Op*     pred_last_op = pred_instructions-&gt;last();
6324 
6325         if (pred_last_op-&gt;code() == lir_branch) {
6326           assert(pred_last_op-&gt;as_OpBranch() != NULL, &quot;branch must be LIR_OpBranch&quot;);
6327           LIR_OpBranch* pred_last_branch = (LIR_OpBranch*)pred_last_op;
6328 
6329           if (pred_last_branch-&gt;block() == block &amp;&amp; pred_last_branch-&gt;cond() == lir_cond_always &amp;&amp; pred_last_branch-&gt;info() == NULL) {
6330             // replace the jump to a return with a direct return
6331             // Note: currently the edge between the blocks is not deleted
6332             pred_instructions-&gt;at_put(pred_instructions-&gt;length() - 1, new LIR_Op1(lir_return, return_opr));
6333 #ifdef ASSERT
6334             return_converted.set_bit(pred-&gt;block_id());
6335 #endif
6336           }
6337         }
6338       }
6339     }
6340   }
6341 }
6342 
6343 
6344 #ifdef ASSERT
6345 void ControlFlowOptimizer::verify(BlockList* code) {
6346   for (int i = 0; i &lt; code-&gt;length(); i++) {
6347     BlockBegin* block = code-&gt;at(i);
6348     LIR_OpList* instructions = block-&gt;lir()-&gt;instructions_list();
6349 
6350     int j;
6351     for (j = 0; j &lt; instructions-&gt;length(); j++) {
6352       LIR_OpBranch* op_branch = instructions-&gt;at(j)-&gt;as_OpBranch();
6353 
6354       if (op_branch != NULL) {
6355         assert(op_branch-&gt;block() == NULL || code-&gt;find(op_branch-&gt;block()) != -1, &quot;branch target not valid&quot;);
6356         assert(op_branch-&gt;ublock() == NULL || code-&gt;find(op_branch-&gt;ublock()) != -1, &quot;branch target not valid&quot;);
6357       }
6358     }
6359 
6360     for (j = 0; j &lt; block-&gt;number_of_sux() - 1; j++) {
6361       BlockBegin* sux = block-&gt;sux_at(j);
6362       assert(code-&gt;find(sux) != -1, &quot;successor not valid&quot;);
6363     }
6364 
6365     for (j = 0; j &lt; block-&gt;number_of_preds() - 1; j++) {
6366       BlockBegin* pred = block-&gt;pred_at(j);
6367       assert(code-&gt;find(pred) != -1, &quot;successor not valid&quot;);
6368     }
6369   }
6370 }
6371 #endif
6372 
6373 
6374 #ifndef PRODUCT
6375 
6376 // Implementation of LinearStatistic
6377 
6378 const char* LinearScanStatistic::counter_name(int counter_idx) {
6379   switch (counter_idx) {
6380     case counter_method:          return &quot;compiled methods&quot;;
6381     case counter_fpu_method:      return &quot;methods using fpu&quot;;
6382     case counter_loop_method:     return &quot;methods with loops&quot;;
6383     case counter_exception_method:return &quot;methods with xhandler&quot;;
6384 
6385     case counter_loop:            return &quot;loops&quot;;
6386     case counter_block:           return &quot;blocks&quot;;
6387     case counter_loop_block:      return &quot;blocks inside loop&quot;;
6388     case counter_exception_block: return &quot;exception handler entries&quot;;
6389     case counter_interval:        return &quot;intervals&quot;;
6390     case counter_fixed_interval:  return &quot;fixed intervals&quot;;
6391     case counter_range:           return &quot;ranges&quot;;
6392     case counter_fixed_range:     return &quot;fixed ranges&quot;;
6393     case counter_use_pos:         return &quot;use positions&quot;;
6394     case counter_fixed_use_pos:   return &quot;fixed use positions&quot;;
6395     case counter_spill_slots:     return &quot;spill slots&quot;;
6396 
6397     // counter for classes of lir instructions
6398     case counter_instruction:     return &quot;total instructions&quot;;
6399     case counter_label:           return &quot;labels&quot;;
6400     case counter_entry:           return &quot;method entries&quot;;
6401     case counter_return:          return &quot;method returns&quot;;
6402     case counter_call:            return &quot;method calls&quot;;
6403     case counter_move:            return &quot;moves&quot;;
6404     case counter_cmp:             return &quot;compare&quot;;
6405     case counter_cond_branch:     return &quot;conditional branches&quot;;
6406     case counter_uncond_branch:   return &quot;unconditional branches&quot;;
6407     case counter_stub_branch:     return &quot;branches to stub&quot;;
6408     case counter_alu:             return &quot;artithmetic + logic&quot;;
6409     case counter_alloc:           return &quot;allocations&quot;;
6410     case counter_sync:            return &quot;synchronisation&quot;;
6411     case counter_throw:           return &quot;throw&quot;;
6412     case counter_unwind:          return &quot;unwind&quot;;
6413     case counter_typecheck:       return &quot;type+null-checks&quot;;
6414     case counter_fpu_stack:       return &quot;fpu-stack&quot;;
6415     case counter_misc_inst:       return &quot;other instructions&quot;;
6416     case counter_other_inst:      return &quot;misc. instructions&quot;;
6417 
6418     // counter for different types of moves
6419     case counter_move_total:      return &quot;total moves&quot;;
6420     case counter_move_reg_reg:    return &quot;register-&gt;register&quot;;
6421     case counter_move_reg_stack:  return &quot;register-&gt;stack&quot;;
6422     case counter_move_stack_reg:  return &quot;stack-&gt;register&quot;;
6423     case counter_move_stack_stack:return &quot;stack-&gt;stack&quot;;
6424     case counter_move_reg_mem:    return &quot;register-&gt;memory&quot;;
6425     case counter_move_mem_reg:    return &quot;memory-&gt;register&quot;;
6426     case counter_move_const_any:  return &quot;constant-&gt;any&quot;;
6427 
6428     case blank_line_1:            return &quot;&quot;;
6429     case blank_line_2:            return &quot;&quot;;
6430 
6431     default: ShouldNotReachHere(); return &quot;&quot;;
6432   }
6433 }
6434 
6435 LinearScanStatistic::Counter LinearScanStatistic::base_counter(int counter_idx) {
6436   if (counter_idx == counter_fpu_method || counter_idx == counter_loop_method || counter_idx == counter_exception_method) {
6437     return counter_method;
6438   } else if (counter_idx == counter_loop_block || counter_idx == counter_exception_block) {
6439     return counter_block;
6440   } else if (counter_idx &gt;= counter_instruction &amp;&amp; counter_idx &lt;= counter_other_inst) {
6441     return counter_instruction;
6442   } else if (counter_idx &gt;= counter_move_total &amp;&amp; counter_idx &lt;= counter_move_const_any) {
6443     return counter_move_total;
6444   }
6445   return invalid_counter;
6446 }
6447 
6448 LinearScanStatistic::LinearScanStatistic() {
6449   for (int i = 0; i &lt; number_of_counters; i++) {
6450     _counters_sum[i] = 0;
6451     _counters_max[i] = -1;
6452   }
6453 
6454 }
6455 
6456 // add the method-local numbers to the total sum
6457 void LinearScanStatistic::sum_up(LinearScanStatistic &amp;method_statistic) {
6458   for (int i = 0; i &lt; number_of_counters; i++) {
6459     _counters_sum[i] += method_statistic._counters_sum[i];
6460     _counters_max[i] = MAX2(_counters_max[i], method_statistic._counters_sum[i]);
6461   }
6462 }
6463 
6464 void LinearScanStatistic::print(const char* title) {
6465   if (CountLinearScan || TraceLinearScanLevel &gt; 0) {
6466     tty-&gt;cr();
6467     tty-&gt;print_cr(&quot;***** LinearScan statistic - %s *****&quot;, title);
6468 
6469     for (int i = 0; i &lt; number_of_counters; i++) {
6470       if (_counters_sum[i] &gt; 0 || _counters_max[i] &gt;= 0) {
6471         tty-&gt;print(&quot;%25s: %8d&quot;, counter_name(i), _counters_sum[i]);
6472 
6473         LinearScanStatistic::Counter cntr = base_counter(i);
6474         if (cntr != invalid_counter) {
6475           tty-&gt;print(&quot;  (%5.1f%%) &quot;, _counters_sum[i] * 100.0 / _counters_sum[cntr]);
6476         } else {
6477           tty-&gt;print(&quot;           &quot;);
6478         }
6479 
6480         if (_counters_max[i] &gt;= 0) {
6481           tty-&gt;print(&quot;%8d&quot;, _counters_max[i]);
6482         }
6483       }
6484       tty-&gt;cr();
6485     }
6486   }
6487 }
6488 
6489 void LinearScanStatistic::collect(LinearScan* allocator) {
6490   inc_counter(counter_method);
6491   if (allocator-&gt;has_fpu_registers()) {
6492     inc_counter(counter_fpu_method);
6493   }
6494   if (allocator-&gt;num_loops() &gt; 0) {
6495     inc_counter(counter_loop_method);
6496   }
6497   inc_counter(counter_loop, allocator-&gt;num_loops());
6498   inc_counter(counter_spill_slots, allocator-&gt;max_spills());
6499 
6500   int i;
6501   for (i = 0; i &lt; allocator-&gt;interval_count(); i++) {
6502     Interval* cur = allocator-&gt;interval_at(i);
6503 
6504     if (cur != NULL) {
6505       inc_counter(counter_interval);
6506       inc_counter(counter_use_pos, cur-&gt;num_use_positions());
6507       if (LinearScan::is_precolored_interval(cur)) {
6508         inc_counter(counter_fixed_interval);
6509         inc_counter(counter_fixed_use_pos, cur-&gt;num_use_positions());
6510       }
6511 
6512       Range* range = cur-&gt;first();
6513       while (range != Range::end()) {
6514         inc_counter(counter_range);
6515         if (LinearScan::is_precolored_interval(cur)) {
6516           inc_counter(counter_fixed_range);
6517         }
6518         range = range-&gt;next();
6519       }
6520     }
6521   }
6522 
6523   bool has_xhandlers = false;
6524   // Note: only count blocks that are in code-emit order
6525   for (i = 0; i &lt; allocator-&gt;ir()-&gt;code()-&gt;length(); i++) {
6526     BlockBegin* cur = allocator-&gt;ir()-&gt;code()-&gt;at(i);
6527 
6528     inc_counter(counter_block);
6529     if (cur-&gt;loop_depth() &gt; 0) {
6530       inc_counter(counter_loop_block);
6531     }
6532     if (cur-&gt;is_set(BlockBegin::exception_entry_flag)) {
6533       inc_counter(counter_exception_block);
6534       has_xhandlers = true;
6535     }
6536 
6537     LIR_OpList* instructions = cur-&gt;lir()-&gt;instructions_list();
6538     for (int j = 0; j &lt; instructions-&gt;length(); j++) {
6539       LIR_Op* op = instructions-&gt;at(j);
6540 
6541       inc_counter(counter_instruction);
6542 
6543       switch (op-&gt;code()) {
6544         case lir_label:           inc_counter(counter_label); break;
6545         case lir_std_entry:
6546         case lir_osr_entry:       inc_counter(counter_entry); break;
6547         case lir_return:          inc_counter(counter_return); break;
6548 
6549         case lir_rtcall:
6550         case lir_static_call:
6551         case lir_optvirtual_call:
6552         case lir_virtual_call:    inc_counter(counter_call); break;
6553 
6554         case lir_move: {
6555           inc_counter(counter_move);
6556           inc_counter(counter_move_total);
6557 
6558           LIR_Opr in = op-&gt;as_Op1()-&gt;in_opr();
6559           LIR_Opr res = op-&gt;as_Op1()-&gt;result_opr();
6560           if (in-&gt;is_register()) {
6561             if (res-&gt;is_register()) {
6562               inc_counter(counter_move_reg_reg);
6563             } else if (res-&gt;is_stack()) {
6564               inc_counter(counter_move_reg_stack);
6565             } else if (res-&gt;is_address()) {
6566               inc_counter(counter_move_reg_mem);
6567             } else {
6568               ShouldNotReachHere();
6569             }
6570           } else if (in-&gt;is_stack()) {
6571             if (res-&gt;is_register()) {
6572               inc_counter(counter_move_stack_reg);
6573             } else {
6574               inc_counter(counter_move_stack_stack);
6575             }
6576           } else if (in-&gt;is_address()) {
6577             assert(res-&gt;is_register(), &quot;must be&quot;);
6578             inc_counter(counter_move_mem_reg);
6579           } else if (in-&gt;is_constant()) {
6580             inc_counter(counter_move_const_any);
6581           } else {
6582             ShouldNotReachHere();
6583           }
6584           break;
6585         }
6586 
6587         case lir_cmp:             inc_counter(counter_cmp); break;
6588 
6589         case lir_branch:
6590         case lir_cond_float_branch: {
6591           LIR_OpBranch* branch = op-&gt;as_OpBranch();
6592           if (branch-&gt;block() == NULL) {
6593             inc_counter(counter_stub_branch);
6594           } else if (branch-&gt;cond() == lir_cond_always) {
6595             inc_counter(counter_uncond_branch);
6596           } else {
6597             inc_counter(counter_cond_branch);
6598           }
6599           break;
6600         }
6601 
6602         case lir_neg:
6603         case lir_add:
6604         case lir_sub:
6605         case lir_mul:
6606         case lir_mul_strictfp:
6607         case lir_div:
6608         case lir_div_strictfp:
6609         case lir_rem:
6610         case lir_sqrt:
6611         case lir_abs:
6612         case lir_log10:
6613         case lir_logic_and:
6614         case lir_logic_or:
6615         case lir_logic_xor:
6616         case lir_shl:
6617         case lir_shr:
6618         case lir_ushr:            inc_counter(counter_alu); break;
6619 
6620         case lir_alloc_object:
6621         case lir_alloc_array:     inc_counter(counter_alloc); break;
6622 
6623         case lir_monaddr:
6624         case lir_lock:
6625         case lir_unlock:          inc_counter(counter_sync); break;
6626 
6627         case lir_throw:           inc_counter(counter_throw); break;
6628 
6629         case lir_unwind:          inc_counter(counter_unwind); break;
6630 
6631         case lir_null_check:
6632         case lir_leal:
6633         case lir_instanceof:
6634         case lir_checkcast:
6635         case lir_store_check:     inc_counter(counter_typecheck); break;
6636 
6637         case lir_fpop_raw:
6638         case lir_fxch:
6639         case lir_fld:             inc_counter(counter_fpu_stack); break;
6640 
6641         case lir_nop:
6642         case lir_push:
6643         case lir_pop:
6644         case lir_convert:
6645         case lir_roundfp:
6646         case lir_cmove:           inc_counter(counter_misc_inst); break;
6647 
6648         default:                  inc_counter(counter_other_inst); break;
6649       }
6650     }
6651   }
6652 
6653   if (has_xhandlers) {
6654     inc_counter(counter_exception_method);
6655   }
6656 }
6657 
6658 void LinearScanStatistic::compute(LinearScan* allocator, LinearScanStatistic &amp;global_statistic) {
6659   if (CountLinearScan || TraceLinearScanLevel &gt; 0) {
6660 
6661     LinearScanStatistic local_statistic = LinearScanStatistic();
6662 
6663     local_statistic.collect(allocator);
6664     global_statistic.sum_up(local_statistic);
6665 
6666     if (TraceLinearScanLevel &gt; 2) {
6667       local_statistic.print(&quot;current local statistic&quot;);
6668     }
6669   }
6670 }
6671 
6672 
6673 // Implementation of LinearTimers
6674 
6675 LinearScanTimers::LinearScanTimers() {
6676   for (int i = 0; i &lt; number_of_timers; i++) {
6677     timer(i)-&gt;reset();
6678   }
6679 }
6680 
6681 const char* LinearScanTimers::timer_name(int idx) {
6682   switch (idx) {
6683     case timer_do_nothing:               return &quot;Nothing (Time Check)&quot;;
6684     case timer_number_instructions:      return &quot;Number Instructions&quot;;
6685     case timer_compute_local_live_sets:  return &quot;Local Live Sets&quot;;
6686     case timer_compute_global_live_sets: return &quot;Global Live Sets&quot;;
6687     case timer_build_intervals:          return &quot;Build Intervals&quot;;
6688     case timer_sort_intervals_before:    return &quot;Sort Intervals Before&quot;;
6689     case timer_allocate_registers:       return &quot;Allocate Registers&quot;;
6690     case timer_resolve_data_flow:        return &quot;Resolve Data Flow&quot;;
6691     case timer_sort_intervals_after:     return &quot;Sort Intervals After&quot;;
6692     case timer_eliminate_spill_moves:    return &quot;Spill optimization&quot;;
6693     case timer_assign_reg_num:           return &quot;Assign Reg Num&quot;;
6694     case timer_allocate_fpu_stack:       return &quot;Allocate FPU Stack&quot;;
6695     case timer_optimize_lir:             return &quot;Optimize LIR&quot;;
6696     default: ShouldNotReachHere();       return &quot;&quot;;
6697   }
6698 }
6699 
6700 void LinearScanTimers::begin_method() {
6701   if (TimeEachLinearScan) {
6702     // reset all timers to measure only current method
6703     for (int i = 0; i &lt; number_of_timers; i++) {
6704       timer(i)-&gt;reset();
6705     }
6706   }
6707 }
6708 
6709 void LinearScanTimers::end_method(LinearScan* allocator) {
6710   if (TimeEachLinearScan) {
6711 
6712     double c = timer(timer_do_nothing)-&gt;seconds();
6713     double total = 0;
6714     for (int i = 1; i &lt; number_of_timers; i++) {
6715       total += timer(i)-&gt;seconds() - c;
6716     }
6717 
6718     if (total &gt;= 0.0005) {
6719       // print all information in one line for automatic processing
6720       tty-&gt;print(&quot;@&quot;); allocator-&gt;compilation()-&gt;method()-&gt;print_name();
6721 
6722       tty-&gt;print(&quot;@ %d &quot;, allocator-&gt;compilation()-&gt;method()-&gt;code_size());
6723       tty-&gt;print(&quot;@ %d &quot;, allocator-&gt;block_at(allocator-&gt;block_count() - 1)-&gt;last_lir_instruction_id() / 2);
6724       tty-&gt;print(&quot;@ %d &quot;, allocator-&gt;block_count());
6725       tty-&gt;print(&quot;@ %d &quot;, allocator-&gt;num_virtual_regs());
6726       tty-&gt;print(&quot;@ %d &quot;, allocator-&gt;interval_count());
6727       tty-&gt;print(&quot;@ %d &quot;, allocator-&gt;_num_calls);
6728       tty-&gt;print(&quot;@ %d &quot;, allocator-&gt;num_loops());
6729 
6730       tty-&gt;print(&quot;@ %6.6f &quot;, total);
6731       for (int i = 1; i &lt; number_of_timers; i++) {
6732         tty-&gt;print(&quot;@ %4.1f &quot;, ((timer(i)-&gt;seconds() - c) / total) * 100);
6733       }
6734       tty-&gt;cr();
6735     }
6736   }
6737 }
6738 
6739 void LinearScanTimers::print(double total_time) {
6740   if (TimeLinearScan) {
6741     // correction value: sum of dummy-timer that only measures the time that
6742     // is necesary to start and stop itself
6743     double c = timer(timer_do_nothing)-&gt;seconds();
6744 
6745     for (int i = 0; i &lt; number_of_timers; i++) {
6746       double t = timer(i)-&gt;seconds();
6747       tty-&gt;print_cr(&quot;    %25s: %6.3f s (%4.1f%%)  corrected: %6.3f s (%4.1f%%)&quot;, timer_name(i), t, (t / total_time) * 100.0, t - c, (t - c) / (total_time - 2 * number_of_timers * c) * 100);
6748     }
6749   }
6750 }
6751 
6752 #endif // #ifndef PRODUCT
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
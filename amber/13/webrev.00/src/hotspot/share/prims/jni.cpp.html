<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/prims/jni.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2012 Red Hat, Inc.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;jni.h&quot;
  28 #include &quot;jvm.h&quot;
  29 #include &quot;ci/ciReplay.hpp&quot;
  30 #include &quot;classfile/altHashing.hpp&quot;
  31 #include &quot;classfile/classFileStream.hpp&quot;
  32 #include &quot;classfile/classLoader.hpp&quot;
  33 #include &quot;classfile/javaClasses.hpp&quot;
  34 #include &quot;classfile/javaClasses.inline.hpp&quot;
  35 #include &quot;classfile/moduleEntry.hpp&quot;
  36 #include &quot;classfile/modules.hpp&quot;
  37 #include &quot;classfile/symbolTable.hpp&quot;
  38 #include &quot;classfile/systemDictionary.hpp&quot;
  39 #include &quot;classfile/vmSymbols.hpp&quot;
  40 #include &quot;gc/shared/gcLocker.inline.hpp&quot;
  41 #include &quot;interpreter/linkResolver.hpp&quot;
  42 #include &quot;jfr/jfrEvents.hpp&quot;
  43 #include &quot;jfr/support/jfrThreadId.hpp&quot;
  44 #include &quot;logging/log.hpp&quot;
  45 #include &quot;memory/allocation.hpp&quot;
  46 #include &quot;memory/allocation.inline.hpp&quot;
  47 #include &quot;memory/oopFactory.hpp&quot;
  48 #include &quot;memory/resourceArea.hpp&quot;
  49 #include &quot;memory/universe.hpp&quot;
  50 #include &quot;oops/access.inline.hpp&quot;
  51 #include &quot;oops/arrayOop.inline.hpp&quot;
  52 #include &quot;oops/instanceKlass.hpp&quot;
  53 #include &quot;oops/instanceOop.hpp&quot;
  54 #include &quot;oops/markWord.hpp&quot;
  55 #include &quot;oops/method.hpp&quot;
  56 #include &quot;oops/objArrayKlass.hpp&quot;
  57 #include &quot;oops/objArrayOop.inline.hpp&quot;
  58 #include &quot;oops/oop.inline.hpp&quot;
  59 #include &quot;oops/symbol.hpp&quot;
  60 #include &quot;oops/typeArrayKlass.hpp&quot;
  61 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  62 #include &quot;prims/jniCheck.hpp&quot;
  63 #include &quot;prims/jniExport.hpp&quot;
  64 #include &quot;prims/jniFastGetField.hpp&quot;
  65 #include &quot;prims/jvm_misc.hpp&quot;
  66 #include &quot;prims/jvmtiExport.hpp&quot;
  67 #include &quot;prims/jvmtiThreadState.hpp&quot;
  68 #include &quot;runtime/atomic.hpp&quot;
  69 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  70 #include &quot;runtime/handles.inline.hpp&quot;
  71 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  72 #include &quot;runtime/java.hpp&quot;
  73 #include &quot;runtime/javaCalls.hpp&quot;
  74 #include &quot;runtime/jfieldIDWorkaround.hpp&quot;
  75 #include &quot;runtime/jniHandles.inline.hpp&quot;
  76 #include &quot;runtime/reflection.hpp&quot;
  77 #include &quot;runtime/safepointVerifiers.hpp&quot;
  78 #include &quot;runtime/sharedRuntime.hpp&quot;
  79 #include &quot;runtime/signature.hpp&quot;
  80 #include &quot;runtime/thread.inline.hpp&quot;
  81 #include &quot;runtime/vmOperations.hpp&quot;
  82 #include &quot;services/memTracker.hpp&quot;
  83 #include &quot;services/runtimeService.hpp&quot;
  84 #include &quot;utilities/defaultStream.hpp&quot;
  85 #include &quot;utilities/dtrace.hpp&quot;
  86 #include &quot;utilities/events.hpp&quot;
  87 #include &quot;utilities/histogram.hpp&quot;
  88 #include &quot;utilities/macros.hpp&quot;
  89 #include &quot;utilities/vmError.hpp&quot;
  90 #if INCLUDE_JVMCI
  91 #include &quot;jvmci/jvmciCompiler.hpp&quot;
  92 #endif
  93 
  94 static jint CurrentVersion = JNI_VERSION_10;
  95 
  96 #ifdef _WIN32
  97 extern LONG WINAPI topLevelExceptionFilter(_EXCEPTION_POINTERS* );
  98 #endif
  99 
 100 // The DT_RETURN_MARK macros create a scoped object to fire the dtrace
 101 // &#39;-return&#39; probe regardless of the return path is taken out of the function.
 102 // Methods that have multiple return paths use this to avoid having to
 103 // instrument each return path.  Methods that use CHECK or THROW must use this
 104 // since those macros can cause an immedate uninstrumented return.
 105 //
 106 // In order to get the return value, a reference to the variable containing
 107 // the return value must be passed to the contructor of the object, and
 108 // the return value must be set before return (since the mark object has
 109 // a reference to it).
 110 //
 111 // Example:
 112 // DT_RETURN_MARK_DECL(SomeFunc, int);
 113 // JNI_ENTRY(int, SomeFunc, ...)
 114 //   int return_value = 0;
 115 //   DT_RETURN_MARK(SomeFunc, int, (const int&amp;)return_value);
 116 //   foo(CHECK_0)
 117 //   return_value = 5;
 118 //   return return_value;
 119 // JNI_END
 120 #define DT_RETURN_MARK_DECL(name, type, probe)                             \
 121   DTRACE_ONLY(                                                             \
 122     class DTraceReturnProbeMark_##name {                                   \
 123      public:                                                               \
 124       const type&amp; _ret_ref;                                                \
 125       DTraceReturnProbeMark_##name(const type&amp; v) : _ret_ref(v) {}         \
 126       ~DTraceReturnProbeMark_##name() {                                    \
 127         probe;                                                             \
 128       }                                                                    \
 129     }                                                                      \
 130   )
 131 // Void functions are simpler since there&#39;s no return value
 132 #define DT_VOID_RETURN_MARK_DECL(name, probe)                              \
 133   DTRACE_ONLY(                                                             \
 134     class DTraceReturnProbeMark_##name {                                   \
 135      public:                                                               \
 136       ~DTraceReturnProbeMark_##name() {                                    \
 137         probe;                                                             \
 138       }                                                                    \
 139     }                                                                      \
 140   )
 141 
 142 // Place these macros in the function to mark the return.  Non-void
 143 // functions need the type and address of the return value.
 144 #define DT_RETURN_MARK(name, type, ref) \
 145   DTRACE_ONLY( DTraceReturnProbeMark_##name dtrace_return_mark(ref) )
 146 #define DT_VOID_RETURN_MARK(name) \
 147   DTRACE_ONLY( DTraceReturnProbeMark_##name dtrace_return_mark )
 148 
 149 
 150 // Use these to select distinct code for floating-point vs. non-floating point
 151 // situations.  Used from within common macros where we need slightly
 152 // different behavior for Float/Double
 153 #define FP_SELECT_Boolean(intcode, fpcode) intcode
 154 #define FP_SELECT_Byte(intcode, fpcode)    intcode
 155 #define FP_SELECT_Char(intcode, fpcode)    intcode
 156 #define FP_SELECT_Short(intcode, fpcode)   intcode
 157 #define FP_SELECT_Object(intcode, fpcode)  intcode
 158 #define FP_SELECT_Int(intcode, fpcode)     intcode
 159 #define FP_SELECT_Long(intcode, fpcode)    intcode
 160 #define FP_SELECT_Float(intcode, fpcode)   fpcode
 161 #define FP_SELECT_Double(intcode, fpcode)  fpcode
 162 #define FP_SELECT(TypeName, intcode, fpcode) \
 163   FP_SELECT_##TypeName(intcode, fpcode)
 164 
 165 // Choose DT_RETURN_MARK macros  based on the type: float/double -&gt; void
 166 // (dtrace doesn&#39;t do FP yet)
 167 #define DT_RETURN_MARK_DECL_FOR(TypeName, name, type, probe)    \
 168   FP_SELECT(TypeName, \
 169     DT_RETURN_MARK_DECL(name, type, probe), DT_VOID_RETURN_MARK_DECL(name, probe) )
 170 #define DT_RETURN_MARK_FOR(TypeName, name, type, ref) \
 171   FP_SELECT(TypeName, \
 172     DT_RETURN_MARK(name, type, ref), DT_VOID_RETURN_MARK(name) )
 173 
 174 
 175 // out-of-line helpers for class jfieldIDWorkaround:
 176 
 177 bool jfieldIDWorkaround::is_valid_jfieldID(Klass* k, jfieldID id) {
 178   if (jfieldIDWorkaround::is_instance_jfieldID(k, id)) {
 179     uintptr_t as_uint = (uintptr_t) id;
 180     intptr_t offset = raw_instance_offset(id);
 181     if (is_checked_jfieldID(id)) {
 182       if (!klass_hash_ok(k, id)) {
 183         return false;
 184       }
 185     }
 186     return InstanceKlass::cast(k)-&gt;contains_field_offset(offset);
 187   } else {
 188     JNIid* result = (JNIid*) id;
 189 #ifdef ASSERT
 190     return result != NULL &amp;&amp; result-&gt;is_static_field_id();
 191 #else
 192     return result != NULL;
 193 #endif
 194   }
 195 }
 196 
 197 
 198 intptr_t jfieldIDWorkaround::encode_klass_hash(Klass* k, intptr_t offset) {
 199   if (offset &lt;= small_offset_mask) {
 200     Klass* field_klass = k;
 201     Klass* super_klass = field_klass-&gt;super();
 202     // With compressed oops the most super class with nonstatic fields would
 203     // be the owner of fields embedded in the header.
 204     while (InstanceKlass::cast(super_klass)-&gt;has_nonstatic_fields() &amp;&amp;
 205            InstanceKlass::cast(super_klass)-&gt;contains_field_offset(offset)) {
 206       field_klass = super_klass;   // super contains the field also
 207       super_klass = field_klass-&gt;super();
 208     }
 209     debug_only(NoSafepointVerifier nosafepoint;)
 210     uintptr_t klass_hash = field_klass-&gt;identity_hash();
 211     return ((klass_hash &amp; klass_mask) &lt;&lt; klass_shift) | checked_mask_in_place;
 212   } else {
 213 #if 0
 214     #ifndef PRODUCT
 215     {
 216       ResourceMark rm;
 217       warning(&quot;VerifyJNIFields: long offset %d in %s&quot;, offset, k-&gt;external_name());
 218     }
 219     #endif
 220 #endif
 221     return 0;
 222   }
 223 }
 224 
 225 bool jfieldIDWorkaround::klass_hash_ok(Klass* k, jfieldID id) {
 226   uintptr_t as_uint = (uintptr_t) id;
 227   intptr_t klass_hash = (as_uint &gt;&gt; klass_shift) &amp; klass_mask;
 228   do {
 229     debug_only(NoSafepointVerifier nosafepoint;)
 230     // Could use a non-blocking query for identity_hash here...
 231     if ((k-&gt;identity_hash() &amp; klass_mask) == klass_hash)
 232       return true;
 233     k = k-&gt;super();
 234   } while (k != NULL);
 235   return false;
 236 }
 237 
 238 void jfieldIDWorkaround::verify_instance_jfieldID(Klass* k, jfieldID id) {
 239   guarantee(jfieldIDWorkaround::is_instance_jfieldID(k, id), &quot;must be an instance field&quot; );
 240   uintptr_t as_uint = (uintptr_t) id;
 241   intptr_t offset = raw_instance_offset(id);
 242   if (VerifyJNIFields) {
 243     if (is_checked_jfieldID(id)) {
 244       guarantee(klass_hash_ok(k, id),
 245     &quot;Bug in native code: jfieldID class must match object&quot;);
 246     } else {
 247 #if 0
 248       #ifndef PRODUCT
 249       if (Verbose) {
 250   ResourceMark rm;
 251   warning(&quot;VerifyJNIFields: unverified offset %d for %s&quot;, offset, k-&gt;external_name());
 252       }
 253       #endif
 254 #endif
 255     }
 256   }
 257   guarantee(InstanceKlass::cast(k)-&gt;contains_field_offset(offset),
 258       &quot;Bug in native code: jfieldID offset must address interior of object&quot;);
 259 }
 260 
 261 // Wrapper to trace JNI functions
 262 
 263 #ifdef ASSERT
 264   Histogram* JNIHistogram;
 265   static volatile int JNIHistogram_lock = 0;
 266 
 267   class JNIHistogramElement : public HistogramElement {
 268     public:
 269      JNIHistogramElement(const char* name);
 270   };
 271 
 272   JNIHistogramElement::JNIHistogramElement(const char* elementName) {
 273     _name = elementName;
 274     uintx count = 0;
 275 
 276     while (Atomic::cmpxchg(&amp;JNIHistogram_lock, 0, 1) != 0) {
 277       while (Atomic::load_acquire(&amp;JNIHistogram_lock) != 0) {
 278         count +=1;
 279         if ( (WarnOnStalledSpinLock &gt; 0)
 280           &amp;&amp; (count % WarnOnStalledSpinLock == 0)) {
 281           warning(&quot;JNIHistogram_lock seems to be stalled&quot;);
 282         }
 283       }
 284      }
 285 
 286 
 287     if(JNIHistogram == NULL)
 288       JNIHistogram = new Histogram(&quot;JNI Call Counts&quot;,100);
 289 
 290     JNIHistogram-&gt;add_element(this);
 291     Atomic::dec(&amp;JNIHistogram_lock);
 292   }
 293 
 294   #define JNICountWrapper(arg)                                     \
 295      static JNIHistogramElement* e = new JNIHistogramElement(arg); \
 296       /* There is a MT-race condition in VC++. So we need to make sure that that e has been initialized */ \
 297      if (e != NULL) e-&gt;increment_count()
 298   #define JNIWrapper(arg) JNICountWrapper(arg);
 299 #else
 300   #define JNIWrapper(arg)
 301 #endif
 302 
 303 
 304 // Implementation of JNI entries
 305 
 306 DT_RETURN_MARK_DECL(DefineClass, jclass
 307                     , HOTSPOT_JNI_DEFINECLASS_RETURN(_ret_ref));
 308 
 309 JNI_ENTRY(jclass, jni_DefineClass(JNIEnv *env, const char *name, jobject loaderRef,
 310                                   const jbyte *buf, jsize bufLen))
 311   JNIWrapper(&quot;DefineClass&quot;);
 312 
 313   HOTSPOT_JNI_DEFINECLASS_ENTRY(
 314     env, (char*) name, loaderRef, (char*) buf, bufLen);
 315 
 316   jclass cls = NULL;
 317   DT_RETURN_MARK(DefineClass, jclass, (const jclass&amp;)cls);
 318 
 319   TempNewSymbol class_name = NULL;
 320   // Since exceptions can be thrown, class initialization can take place
 321   // if name is NULL no check for class name in .class stream has to be made.
 322   if (name != NULL) {
 323     const int str_len = (int)strlen(name);
 324     if (str_len &gt; Symbol::max_length()) {
 325       // It&#39;s impossible to create this class;  the name cannot fit
 326       // into the constant pool.
 327       Exceptions::fthrow(THREAD_AND_LOCATION,
 328                          vmSymbols::java_lang_NoClassDefFoundError(),
 329                          &quot;Class name exceeds maximum length of %d: %s&quot;,
 330                          Symbol::max_length(),
 331                          name);
 332       return 0;
 333     }
 334     class_name = SymbolTable::new_symbol(name);
 335   }
 336   ResourceMark rm(THREAD);
 337   ClassFileStream st((u1*)buf, bufLen, NULL, ClassFileStream::verify);
 338   Handle class_loader (THREAD, JNIHandles::resolve(loaderRef));
 339 
 340   if (UsePerfData &amp;&amp; !class_loader.is_null()) {
 341     // check whether the current caller thread holds the lock or not.
 342     // If not, increment the corresponding counter
 343     if (ObjectSynchronizer::
 344         query_lock_ownership((JavaThread*)THREAD, class_loader) !=
 345         ObjectSynchronizer::owner_self) {
 346       ClassLoader::sync_JNIDefineClassLockFreeCounter()-&gt;inc();
 347     }
 348   }
 349   Klass* k = SystemDictionary::resolve_from_stream(class_name,
 350                                                    class_loader,
 351                                                    Handle(),
 352                                                    &amp;st,
 353                                                    CHECK_NULL);
 354 
 355   if (log_is_enabled(Debug, class, resolve) &amp;&amp; k != NULL) {
 356     trace_class_resolution(k);
 357   }
 358 
 359   cls = (jclass)JNIHandles::make_local(
 360     env, k-&gt;java_mirror());
 361   return cls;
 362 JNI_END
 363 
 364 
 365 
 366 DT_RETURN_MARK_DECL(FindClass, jclass
 367                     , HOTSPOT_JNI_FINDCLASS_RETURN(_ret_ref));
 368 
 369 JNI_ENTRY(jclass, jni_FindClass(JNIEnv *env, const char *name))
 370   JNIWrapper(&quot;FindClass&quot;);
 371 
 372   HOTSPOT_JNI_FINDCLASS_ENTRY(env, (char *)name);
 373 
 374   jclass result = NULL;
 375   DT_RETURN_MARK(FindClass, jclass, (const jclass&amp;)result);
 376 
 377   // Sanity check the name:  it cannot be null or larger than the maximum size
 378   // name we can fit in the constant pool.
 379   if (name == NULL) {
 380     THROW_MSG_0(vmSymbols::java_lang_NoClassDefFoundError(), &quot;No class name given&quot;);
 381   }
 382   if ((int)strlen(name) &gt; Symbol::max_length()) {
 383     Exceptions::fthrow(THREAD_AND_LOCATION,
 384                        vmSymbols::java_lang_NoClassDefFoundError(),
 385                        &quot;Class name exceeds maximum length of %d: %s&quot;,
 386                        Symbol::max_length(),
 387                        name);
 388     return 0;
 389   }
 390 
 391   //%note jni_3
 392   Handle protection_domain;
 393   // Find calling class
 394   Klass* k = thread-&gt;security_get_caller_class(0);
 395   // default to the system loader when no context
 396   Handle loader(THREAD, SystemDictionary::java_system_loader());
 397   if (k != NULL) {
 398     // Special handling to make sure JNI_OnLoad and JNI_OnUnload are executed
 399     // in the correct class context.
 400     if (k-&gt;class_loader() == NULL &amp;&amp;
 401         k-&gt;name() == vmSymbols::jdk_internal_loader_NativeLibraries()) {
 402       JavaValue result(T_OBJECT);
 403       JavaCalls::call_static(&amp;result, k,
 404                              vmSymbols::getFromClass_name(),
 405                              vmSymbols::void_class_signature(),
 406                              CHECK_NULL);
 407       // When invoked from JNI_OnLoad, NativeLibraries::getFromClass returns
 408       // a non-NULL Class object.  When invoked from JNI_OnUnload,
 409       // it will return NULL to indicate no context.
 410       oop mirror = (oop) result.get_jobject();
 411       if (mirror != NULL) {
 412         Klass* fromClass = java_lang_Class::as_Klass(mirror);
 413         loader = Handle(THREAD, fromClass-&gt;class_loader());
 414         protection_domain = Handle(THREAD, fromClass-&gt;protection_domain());
 415       }
 416     } else {
 417       loader = Handle(THREAD, k-&gt;class_loader());
 418     }
 419   }
 420 
 421   TempNewSymbol sym = SymbolTable::new_symbol(name);
 422   result = find_class_from_class_loader(env, sym, true, loader,
 423                                         protection_domain, true, thread);
 424 
 425   if (log_is_enabled(Debug, class, resolve) &amp;&amp; result != NULL) {
 426     trace_class_resolution(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(result)));
 427   }
 428 
 429   return result;
 430 JNI_END
 431 
 432 DT_RETURN_MARK_DECL(FromReflectedMethod, jmethodID
 433                     , HOTSPOT_JNI_FROMREFLECTEDMETHOD_RETURN((uintptr_t)_ret_ref));
 434 
 435 JNI_ENTRY(jmethodID, jni_FromReflectedMethod(JNIEnv *env, jobject method))
 436   JNIWrapper(&quot;FromReflectedMethod&quot;);
 437 
 438   HOTSPOT_JNI_FROMREFLECTEDMETHOD_ENTRY(env, method);
 439 
 440   jmethodID ret = NULL;
 441   DT_RETURN_MARK(FromReflectedMethod, jmethodID, (const jmethodID&amp;)ret);
 442 
 443   // method is a handle to a java.lang.reflect.Method object
 444   oop reflected  = JNIHandles::resolve_non_null(method);
 445   oop mirror     = NULL;
 446   int slot       = 0;
 447 
 448   if (reflected-&gt;klass() == SystemDictionary::reflect_Constructor_klass()) {
 449     mirror = java_lang_reflect_Constructor::clazz(reflected);
 450     slot   = java_lang_reflect_Constructor::slot(reflected);
 451   } else {
 452     assert(reflected-&gt;klass() == SystemDictionary::reflect_Method_klass(), &quot;wrong type&quot;);
 453     mirror = java_lang_reflect_Method::clazz(reflected);
 454     slot   = java_lang_reflect_Method::slot(reflected);
 455   }
 456   Klass* k1 = java_lang_Class::as_Klass(mirror);
 457 
 458   // Make sure class is initialized before handing id&#39;s out to methods
 459   k1-&gt;initialize(CHECK_NULL);
 460   Method* m = InstanceKlass::cast(k1)-&gt;method_with_idnum(slot);
 461   ret = m==NULL? NULL : m-&gt;jmethod_id();  // return NULL if reflected method deleted
 462   return ret;
 463 JNI_END
 464 
 465 DT_RETURN_MARK_DECL(FromReflectedField, jfieldID
 466                     , HOTSPOT_JNI_FROMREFLECTEDFIELD_RETURN((uintptr_t)_ret_ref));
 467 
 468 JNI_ENTRY(jfieldID, jni_FromReflectedField(JNIEnv *env, jobject field))
 469   JNIWrapper(&quot;FromReflectedField&quot;);
 470 
 471   HOTSPOT_JNI_FROMREFLECTEDFIELD_ENTRY(env, field);
 472 
 473   jfieldID ret = NULL;
 474   DT_RETURN_MARK(FromReflectedField, jfieldID, (const jfieldID&amp;)ret);
 475 
 476   // field is a handle to a java.lang.reflect.Field object
 477   oop reflected   = JNIHandles::resolve_non_null(field);
 478   oop mirror      = java_lang_reflect_Field::clazz(reflected);
 479   Klass* k1       = java_lang_Class::as_Klass(mirror);
 480   int slot        = java_lang_reflect_Field::slot(reflected);
 481   int modifiers   = java_lang_reflect_Field::modifiers(reflected);
 482 
 483   // Make sure class is initialized before handing id&#39;s out to fields
 484   k1-&gt;initialize(CHECK_NULL);
 485 
 486   // First check if this is a static field
 487   if (modifiers &amp; JVM_ACC_STATIC) {
 488     intptr_t offset = InstanceKlass::cast(k1)-&gt;field_offset( slot );
 489     JNIid* id = InstanceKlass::cast(k1)-&gt;jni_id_for(offset);
 490     assert(id != NULL, &quot;corrupt Field object&quot;);
 491     debug_only(id-&gt;set_is_static_field_id();)
 492     // A jfieldID for a static field is a JNIid specifying the field holder and the offset within the Klass*
 493     ret = jfieldIDWorkaround::to_static_jfieldID(id);
 494     return ret;
 495   }
 496 
 497   // The slot is the index of the field description in the field-array
 498   // The jfieldID is the offset of the field within the object
 499   // It may also have hash bits for k, if VerifyJNIFields is turned on.
 500   intptr_t offset = InstanceKlass::cast(k1)-&gt;field_offset( slot );
 501   assert(InstanceKlass::cast(k1)-&gt;contains_field_offset(offset), &quot;stay within object&quot;);
 502   ret = jfieldIDWorkaround::to_instance_jfieldID(k1, offset);
 503   return ret;
 504 JNI_END
 505 
 506 
 507 DT_RETURN_MARK_DECL(ToReflectedMethod, jobject
 508                     , HOTSPOT_JNI_TOREFLECTEDMETHOD_RETURN(_ret_ref));
 509 
 510 JNI_ENTRY(jobject, jni_ToReflectedMethod(JNIEnv *env, jclass cls, jmethodID method_id, jboolean isStatic))
 511   JNIWrapper(&quot;ToReflectedMethod&quot;);
 512 
 513   HOTSPOT_JNI_TOREFLECTEDMETHOD_ENTRY(env, cls, (uintptr_t) method_id, isStatic);
 514 
 515   jobject ret = NULL;
 516   DT_RETURN_MARK(ToReflectedMethod, jobject, (const jobject&amp;)ret);
 517 
 518   methodHandle m (THREAD, Method::resolve_jmethod_id(method_id));
 519   assert(m-&gt;is_static() == (isStatic != 0), &quot;jni_ToReflectedMethod access flags doesn&#39;t match&quot;);
 520   oop reflection_method;
 521   if (m-&gt;is_initializer()) {
 522     reflection_method = Reflection::new_constructor(m, CHECK_NULL);
 523   } else {
 524     reflection_method = Reflection::new_method(m, false, CHECK_NULL);
 525   }
 526   ret = JNIHandles::make_local(env, reflection_method);
 527   return ret;
 528 JNI_END
 529 
 530 DT_RETURN_MARK_DECL(GetSuperclass, jclass
 531                     , HOTSPOT_JNI_GETSUPERCLASS_RETURN(_ret_ref));
 532 
 533 JNI_ENTRY(jclass, jni_GetSuperclass(JNIEnv *env, jclass sub))
 534   JNIWrapper(&quot;GetSuperclass&quot;);
 535 
 536   HOTSPOT_JNI_GETSUPERCLASS_ENTRY(env, sub);
 537 
 538   jclass obj = NULL;
 539   DT_RETURN_MARK(GetSuperclass, jclass, (const jclass&amp;)obj);
 540 
 541   oop mirror = JNIHandles::resolve_non_null(sub);
 542   // primitive classes return NULL
 543   if (java_lang_Class::is_primitive(mirror)) return NULL;
 544 
 545   // Rules of Class.getSuperClass as implemented by KLass::java_super:
 546   // arrays return Object
 547   // interfaces return NULL
 548   // proper classes return Klass::super()
 549   Klass* k = java_lang_Class::as_Klass(mirror);
 550   if (k-&gt;is_interface()) return NULL;
 551 
 552   // return mirror for superclass
 553   Klass* super = k-&gt;java_super();
 554   // super2 is the value computed by the compiler&#39;s getSuperClass intrinsic:
 555   debug_only(Klass* super2 = ( k-&gt;is_array_klass()
 556                                  ? SystemDictionary::Object_klass()
 557                                  : k-&gt;super() ) );
 558   assert(super == super2,
 559          &quot;java_super computation depends on interface, array, other super&quot;);
 560   obj = (super == NULL) ? NULL : (jclass) JNIHandles::make_local(super-&gt;java_mirror());
 561   return obj;
 562 JNI_END
 563 
 564 JNI_ENTRY_NO_PRESERVE(jboolean, jni_IsAssignableFrom(JNIEnv *env, jclass sub, jclass super))
 565   JNIWrapper(&quot;IsSubclassOf&quot;);
 566 
 567   HOTSPOT_JNI_ISASSIGNABLEFROM_ENTRY(env, sub, super);
 568 
 569   oop sub_mirror   = JNIHandles::resolve_non_null(sub);
 570   oop super_mirror = JNIHandles::resolve_non_null(super);
 571   if (java_lang_Class::is_primitive(sub_mirror) ||
 572       java_lang_Class::is_primitive(super_mirror)) {
 573     jboolean ret = (sub_mirror == super_mirror);
 574 
 575     HOTSPOT_JNI_ISASSIGNABLEFROM_RETURN(ret);
 576     return ret;
 577   }
 578   Klass* sub_klass   = java_lang_Class::as_Klass(sub_mirror);
 579   Klass* super_klass = java_lang_Class::as_Klass(super_mirror);
 580   assert(sub_klass != NULL &amp;&amp; super_klass != NULL, &quot;invalid arguments to jni_IsAssignableFrom&quot;);
 581   jboolean ret = sub_klass-&gt;is_subtype_of(super_klass) ?
 582                    JNI_TRUE : JNI_FALSE;
 583 
 584   HOTSPOT_JNI_ISASSIGNABLEFROM_RETURN(ret);
 585   return ret;
 586 JNI_END
 587 
 588 
 589 DT_RETURN_MARK_DECL(Throw, jint
 590                     , HOTSPOT_JNI_THROW_RETURN(_ret_ref));
 591 
 592 JNI_ENTRY(jint, jni_Throw(JNIEnv *env, jthrowable obj))
 593   JNIWrapper(&quot;Throw&quot;);
 594 
 595   HOTSPOT_JNI_THROW_ENTRY(env, obj);
 596 
 597   jint ret = JNI_OK;
 598   DT_RETURN_MARK(Throw, jint, (const jint&amp;)ret);
 599 
 600   THROW_OOP_(JNIHandles::resolve(obj), JNI_OK);
 601   ShouldNotReachHere();
 602   return 0;  // Mute compiler.
 603 JNI_END
 604 
 605 
 606 DT_RETURN_MARK_DECL(ThrowNew, jint
 607                     , HOTSPOT_JNI_THROWNEW_RETURN(_ret_ref));
 608 
 609 JNI_ENTRY(jint, jni_ThrowNew(JNIEnv *env, jclass clazz, const char *message))
 610   JNIWrapper(&quot;ThrowNew&quot;);
 611 
 612   HOTSPOT_JNI_THROWNEW_ENTRY(env, clazz, (char *) message);
 613 
 614   jint ret = JNI_OK;
 615   DT_RETURN_MARK(ThrowNew, jint, (const jint&amp;)ret);
 616 
 617   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz)));
 618   Symbol*  name = k-&gt;name();
 619   Handle class_loader (THREAD,  k-&gt;class_loader());
 620   Handle protection_domain (THREAD, k-&gt;protection_domain());
 621   THROW_MSG_LOADER_(name, (char *)message, class_loader, protection_domain, JNI_OK);
 622   ShouldNotReachHere();
 623   return 0;  // Mute compiler.
 624 JNI_END
 625 
 626 
 627 // JNI functions only transform a pending async exception to a synchronous
 628 // exception in ExceptionOccurred and ExceptionCheck calls, since
 629 // delivering an async exception in other places won&#39;t change the native
 630 // code&#39;s control flow and would be harmful when native code further calls
 631 // JNI functions with a pending exception. Async exception is also checked
 632 // during the call, so ExceptionOccurred/ExceptionCheck won&#39;t return
 633 // false but deliver the async exception at the very end during
 634 // state transition.
 635 
 636 static void jni_check_async_exceptions(JavaThread *thread) {
 637   assert(thread == Thread::current(), &quot;must be itself&quot;);
 638   thread-&gt;check_and_handle_async_exceptions();
 639 }
 640 
 641 JNI_ENTRY_NO_PRESERVE(jthrowable, jni_ExceptionOccurred(JNIEnv *env))
 642   JNIWrapper(&quot;ExceptionOccurred&quot;);
 643 
 644   HOTSPOT_JNI_EXCEPTIONOCCURRED_ENTRY(env);
 645 
 646   jni_check_async_exceptions(thread);
 647   oop exception = thread-&gt;pending_exception();
 648   jthrowable ret = (jthrowable) JNIHandles::make_local(env, exception);
 649 
 650   HOTSPOT_JNI_EXCEPTIONOCCURRED_RETURN(ret);
 651   return ret;
 652 JNI_END
 653 
 654 
 655 JNI_ENTRY_NO_PRESERVE(void, jni_ExceptionDescribe(JNIEnv *env))
 656   JNIWrapper(&quot;ExceptionDescribe&quot;);
 657 
 658   HOTSPOT_JNI_EXCEPTIONDESCRIBE_ENTRY(env);
 659 
 660   if (thread-&gt;has_pending_exception()) {
 661     Handle ex(thread, thread-&gt;pending_exception());
 662     thread-&gt;clear_pending_exception();
 663     if (ex-&gt;is_a(SystemDictionary::ThreadDeath_klass())) {
 664       // Don&#39;t print anything if we are being killed.
 665     } else {
 666       jio_fprintf(defaultStream::error_stream(), &quot;Exception &quot;);
 667       if (thread != NULL &amp;&amp; thread-&gt;threadObj() != NULL) {
 668         ResourceMark rm(THREAD);
 669         jio_fprintf(defaultStream::error_stream(),
 670         &quot;in thread \&quot;%s\&quot; &quot;, thread-&gt;get_thread_name());
 671       }
 672       if (ex-&gt;is_a(SystemDictionary::Throwable_klass())) {
 673         JavaValue result(T_VOID);
 674         JavaCalls::call_virtual(&amp;result,
 675                                 ex,
 676                                 SystemDictionary::Throwable_klass(),
 677                                 vmSymbols::printStackTrace_name(),
 678                                 vmSymbols::void_method_signature(),
 679                                 THREAD);
 680         // If an exception is thrown in the call it gets thrown away. Not much
 681         // we can do with it. The native code that calls this, does not check
 682         // for the exception - hence, it might still be in the thread when DestroyVM gets
 683         // called, potentially causing a few asserts to trigger - since no pending exception
 684         // is expected.
 685         CLEAR_PENDING_EXCEPTION;
 686       } else {
 687         ResourceMark rm(THREAD);
 688         jio_fprintf(defaultStream::error_stream(),
 689         &quot;. Uncaught exception of type %s.&quot;,
 690         ex-&gt;klass()-&gt;external_name());
 691       }
 692     }
 693   }
 694 
 695   HOTSPOT_JNI_EXCEPTIONDESCRIBE_RETURN();
 696 JNI_END
 697 
 698 
 699 JNI_ENTRY_NO_PRESERVE(void, jni_ExceptionClear(JNIEnv *env))
 700   JNIWrapper(&quot;ExceptionClear&quot;);
 701 
 702   HOTSPOT_JNI_EXCEPTIONCLEAR_ENTRY(env);
 703 
 704   // The jni code might be using this API to clear java thrown exception.
 705   // So just mark jvmti thread exception state as exception caught.
 706   JvmtiThreadState *state = JavaThread::current()-&gt;jvmti_thread_state();
 707   if (state != NULL &amp;&amp; state-&gt;is_exception_detected()) {
 708     state-&gt;set_exception_caught();
 709   }
 710   thread-&gt;clear_pending_exception();
 711 
 712   HOTSPOT_JNI_EXCEPTIONCLEAR_RETURN();
 713 JNI_END
 714 
 715 
 716 JNI_ENTRY(void, jni_FatalError(JNIEnv *env, const char *msg))
 717   JNIWrapper(&quot;FatalError&quot;);
 718 
 719   HOTSPOT_JNI_FATALERROR_ENTRY(env, (char *) msg);
 720 
 721   tty-&gt;print_cr(&quot;FATAL ERROR in native method: %s&quot;, msg);
 722   thread-&gt;print_stack();
 723   os::abort(); // Dump core and abort
 724 JNI_END
 725 
 726 
 727 JNI_ENTRY(jint, jni_PushLocalFrame(JNIEnv *env, jint capacity))
 728   JNIWrapper(&quot;PushLocalFrame&quot;);
 729 
 730   HOTSPOT_JNI_PUSHLOCALFRAME_ENTRY(env, capacity);
 731 
 732   //%note jni_11
 733   if (capacity &lt; 0 ||
 734       ((MaxJNILocalCapacity &gt; 0) &amp;&amp; (capacity &gt; MaxJNILocalCapacity))) {
 735     HOTSPOT_JNI_PUSHLOCALFRAME_RETURN((uint32_t)JNI_ERR);
 736     return JNI_ERR;
 737   }
 738   JNIHandleBlock* old_handles = thread-&gt;active_handles();
 739   JNIHandleBlock* new_handles = JNIHandleBlock::allocate_block(thread);
 740   assert(new_handles != NULL, &quot;should not be NULL&quot;);
 741   new_handles-&gt;set_pop_frame_link(old_handles);
 742   thread-&gt;set_active_handles(new_handles);
 743   jint ret = JNI_OK;
 744   HOTSPOT_JNI_PUSHLOCALFRAME_RETURN(ret);
 745   return ret;
 746 JNI_END
 747 
 748 
 749 JNI_ENTRY(jobject, jni_PopLocalFrame(JNIEnv *env, jobject result))
 750   JNIWrapper(&quot;PopLocalFrame&quot;);
 751 
 752   HOTSPOT_JNI_POPLOCALFRAME_ENTRY(env, result);
 753 
 754   //%note jni_11
 755   Handle result_handle(thread, JNIHandles::resolve(result));
 756   JNIHandleBlock* old_handles = thread-&gt;active_handles();
 757   JNIHandleBlock* new_handles = old_handles-&gt;pop_frame_link();
 758   if (new_handles != NULL) {
 759     // As a sanity check we only release the handle blocks if the pop_frame_link is not NULL.
 760     // This way code will still work if PopLocalFrame is called without a corresponding
 761     // PushLocalFrame call. Note that we set the pop_frame_link to NULL explicitly, otherwise
 762     // the release_block call will release the blocks.
 763     thread-&gt;set_active_handles(new_handles);
 764     old_handles-&gt;set_pop_frame_link(NULL);              // clear link we won&#39;t release new_handles below
 765     JNIHandleBlock::release_block(old_handles, thread); // may block
 766     result = JNIHandles::make_local(thread, result_handle());
 767   }
 768   HOTSPOT_JNI_POPLOCALFRAME_RETURN(result);
 769   return result;
 770 JNI_END
 771 
 772 
 773 JNI_ENTRY(jobject, jni_NewGlobalRef(JNIEnv *env, jobject ref))
 774   JNIWrapper(&quot;NewGlobalRef&quot;);
 775 
 776   HOTSPOT_JNI_NEWGLOBALREF_ENTRY(env, ref);
 777 
 778   Handle ref_handle(thread, JNIHandles::resolve(ref));
 779   jobject ret = JNIHandles::make_global(ref_handle);
 780 
 781   HOTSPOT_JNI_NEWGLOBALREF_RETURN(ret);
 782   return ret;
 783 JNI_END
 784 
 785 // Must be JNI_ENTRY (with HandleMark)
 786 JNI_ENTRY_NO_PRESERVE(void, jni_DeleteGlobalRef(JNIEnv *env, jobject ref))
 787   JNIWrapper(&quot;DeleteGlobalRef&quot;);
 788 
 789   HOTSPOT_JNI_DELETEGLOBALREF_ENTRY(env, ref);
 790 
 791   JNIHandles::destroy_global(ref);
 792 
 793   HOTSPOT_JNI_DELETEGLOBALREF_RETURN();
 794 JNI_END
 795 
 796 JNI_ENTRY_NO_PRESERVE(void, jni_DeleteLocalRef(JNIEnv *env, jobject obj))
 797   JNIWrapper(&quot;DeleteLocalRef&quot;);
 798 
 799   HOTSPOT_JNI_DELETELOCALREF_ENTRY(env, obj);
 800 
 801   JNIHandles::destroy_local(obj);
 802 
 803   HOTSPOT_JNI_DELETELOCALREF_RETURN();
 804 JNI_END
 805 
 806 JNI_ENTRY_NO_PRESERVE(jboolean, jni_IsSameObject(JNIEnv *env, jobject r1, jobject r2))
 807   JNIWrapper(&quot;IsSameObject&quot;);
 808 
 809   HOTSPOT_JNI_ISSAMEOBJECT_ENTRY(env, r1, r2);
 810 
 811   jboolean ret = JNIHandles::is_same_object(r1, r2) ? JNI_TRUE : JNI_FALSE;
 812 
 813   HOTSPOT_JNI_ISSAMEOBJECT_RETURN(ret);
 814   return ret;
 815 JNI_END
 816 
 817 
 818 JNI_ENTRY(jobject, jni_NewLocalRef(JNIEnv *env, jobject ref))
 819   JNIWrapper(&quot;NewLocalRef&quot;);
 820 
 821   HOTSPOT_JNI_NEWLOCALREF_ENTRY(env, ref);
 822 
 823   jobject ret = JNIHandles::make_local(env, JNIHandles::resolve(ref));
 824 
 825   HOTSPOT_JNI_NEWLOCALREF_RETURN(ret);
 826   return ret;
 827 JNI_END
 828 
 829 JNI_LEAF(jint, jni_EnsureLocalCapacity(JNIEnv *env, jint capacity))
 830   JNIWrapper(&quot;EnsureLocalCapacity&quot;);
 831 
 832   HOTSPOT_JNI_ENSURELOCALCAPACITY_ENTRY(env, capacity);
 833 
 834   jint ret;
 835   if (capacity &gt;= 0 &amp;&amp;
 836       ((MaxJNILocalCapacity &lt;= 0) || (capacity &lt;= MaxJNILocalCapacity))) {
 837     ret = JNI_OK;
 838   } else {
 839     ret = JNI_ERR;
 840   }
 841 
 842   HOTSPOT_JNI_ENSURELOCALCAPACITY_RETURN(ret);
 843   return ret;
 844 JNI_END
 845 
 846 // Return the Handle Type
 847 JNI_LEAF(jobjectRefType, jni_GetObjectRefType(JNIEnv *env, jobject obj))
 848   JNIWrapper(&quot;GetObjectRefType&quot;);
 849 
 850   HOTSPOT_JNI_GETOBJECTREFTYPE_ENTRY(env, obj);
 851 
 852   jobjectRefType ret = JNIInvalidRefType;
 853   if (obj != NULL) {
 854     ret = JNIHandles::handle_type(thread, obj);
 855   }
 856 
 857   HOTSPOT_JNI_GETOBJECTREFTYPE_RETURN((void *) ret);
 858   return ret;
 859 JNI_END
 860 
 861 
 862 class JNI_ArgumentPusher : public SignatureIterator {
 863  protected:
 864   JavaCallArguments*  _arguments;
 865 
 866   void push_int(jint x)         { _arguments-&gt;push_int(x); }
 867   void push_long(jlong x)       { _arguments-&gt;push_long(x); }
 868   void push_float(jfloat x)     { _arguments-&gt;push_float(x); }
 869   void push_double(jdouble x)   { _arguments-&gt;push_double(x); }
 870   void push_object(jobject x)   { _arguments-&gt;push_jobject(x); }
 871 
 872   void push_boolean(jboolean b) {
 873     // Normalize boolean arguments from native code by converting 1-255 to JNI_TRUE and
 874     // 0 to JNI_FALSE.  Boolean return values from native are normalized the same in
 875     // TemplateInterpreterGenerator::generate_result_handler_for and
 876     // SharedRuntime::generate_native_wrapper.
 877     push_int(b == 0 ? JNI_FALSE : JNI_TRUE);
 878   }
 879 
 880   JNI_ArgumentPusher(Method* method)
 881     : SignatureIterator(method-&gt;signature(),
 882                         Fingerprinter(methodHandle(Thread::current(), method)).fingerprint())
 883   {
 884     _arguments = NULL;
 885   }
 886 
 887  public:
 888   virtual void push_arguments_on(JavaCallArguments* arguments) = 0;
 889 };
 890 
 891 
 892 class JNI_ArgumentPusherVaArg : public JNI_ArgumentPusher {
 893  protected:
 894   va_list _ap;
 895 
 896   void set_ap(va_list rap) {
 897     va_copy(_ap, rap);
 898   }
 899 
 900   friend class SignatureIterator;  // so do_parameters_on can call do_type
 901   void do_type(BasicType type) {
 902     switch (type) {
 903     // these are coerced to int when using va_arg
 904     case T_BYTE:
 905     case T_CHAR:
 906     case T_SHORT:
 907     case T_INT:         push_int(va_arg(_ap, jint)); break;
 908     case T_BOOLEAN:     push_boolean((jboolean) va_arg(_ap, jint)); break;
 909 
 910     // each of these paths is exercised by the various jck Call[Static,Nonvirtual,][Void,Int,..]Method[A,V,] tests
 911 
 912     case T_LONG:        push_long(va_arg(_ap, jlong)); break;
 913     // float is coerced to double w/ va_arg
 914     case T_FLOAT:       push_float((jfloat) va_arg(_ap, jdouble)); break;
 915     case T_DOUBLE:      push_double(va_arg(_ap, jdouble)); break;
 916 
 917     case T_ARRAY:
 918     case T_OBJECT:      push_object(va_arg(_ap, jobject)); break;
 919     default:            ShouldNotReachHere();
 920     }
 921   }
 922 
 923  public:
 924   JNI_ArgumentPusherVaArg(jmethodID method_id, va_list rap)
 925       : JNI_ArgumentPusher(Method::resolve_jmethod_id(method_id)) {
 926     set_ap(rap);
 927   }
 928 
 929   virtual void push_arguments_on(JavaCallArguments* arguments) {
 930     _arguments = arguments;
 931     do_parameters_on(this);
 932   }
 933 };
 934 
 935 
 936 class JNI_ArgumentPusherArray : public JNI_ArgumentPusher {
 937  protected:
 938   const jvalue *_ap;
 939 
 940   inline void set_ap(const jvalue *rap) { _ap = rap; }
 941 
 942   friend class SignatureIterator;  // so do_parameters_on can call do_type
 943   void do_type(BasicType type) {
 944     switch (type) {
 945     case T_CHAR:        push_int((_ap++)-&gt;c); break;
 946     case T_SHORT:       push_int((_ap++)-&gt;s); break;
 947     case T_BYTE:        push_int((_ap++)-&gt;b); break;
 948     case T_INT:         push_int((_ap++)-&gt;i); break;
 949     case T_BOOLEAN:     push_boolean((_ap++)-&gt;z); break;
 950     case T_LONG:        push_long((_ap++)-&gt;j); break;
 951     case T_FLOAT:       push_float((_ap++)-&gt;f); break;
 952     case T_DOUBLE:      push_double((_ap++)-&gt;d); break;
 953     case T_ARRAY:
 954     case T_OBJECT:      push_object((_ap++)-&gt;l); break;
 955     default:            ShouldNotReachHere();
 956     }
 957   }
 958 
 959  public:
 960   JNI_ArgumentPusherArray(jmethodID method_id, const jvalue *rap)
 961       : JNI_ArgumentPusher(Method::resolve_jmethod_id(method_id)) {
 962     set_ap(rap);
 963   }
 964 
 965   virtual void push_arguments_on(JavaCallArguments* arguments) {
 966     _arguments = arguments;
 967     do_parameters_on(this);
 968   }
 969 };
 970 
 971 
 972 enum JNICallType {
 973   JNI_STATIC,
 974   JNI_VIRTUAL,
 975   JNI_NONVIRTUAL
 976 };
 977 
 978 
 979 
 980 static void jni_invoke_static(JNIEnv *env, JavaValue* result, jobject receiver, JNICallType call_type, jmethodID method_id, JNI_ArgumentPusher *args, TRAPS) {
 981   methodHandle method(THREAD, Method::resolve_jmethod_id(method_id));
 982 
 983   // Create object to hold arguments for the JavaCall, and associate it with
 984   // the jni parser
 985   ResourceMark rm(THREAD);
 986   int number_of_parameters = method-&gt;size_of_parameters();
 987   JavaCallArguments java_args(number_of_parameters);
 988 
 989   assert(method-&gt;is_static(), &quot;method should be static&quot;);
 990 
 991   // Fill out JavaCallArguments object
 992   args-&gt;push_arguments_on(&amp;java_args);
 993   // Initialize result type
 994   result-&gt;set_type(args-&gt;return_type());
 995 
 996   // Invoke the method. Result is returned as oop.
 997   JavaCalls::call(result, method, &amp;java_args, CHECK);
 998 
 999   // Convert result
1000   if (is_reference_type(result-&gt;get_type())) {
1001     result-&gt;set_jobject(JNIHandles::make_local(env, (oop) result-&gt;get_jobject()));
1002   }
1003 }
1004 
1005 
1006 static void jni_invoke_nonstatic(JNIEnv *env, JavaValue* result, jobject receiver, JNICallType call_type, jmethodID method_id, JNI_ArgumentPusher *args, TRAPS) {
1007   oop recv = JNIHandles::resolve(receiver);
1008   if (recv == NULL) {
1009     THROW(vmSymbols::java_lang_NullPointerException());
1010   }
1011   Handle h_recv(THREAD, recv);
1012 
1013   int number_of_parameters;
1014   Method* selected_method;
1015   {
1016     Method* m = Method::resolve_jmethod_id(method_id);
1017     number_of_parameters = m-&gt;size_of_parameters();
1018     Klass* holder = m-&gt;method_holder();
1019     if (call_type != JNI_VIRTUAL) {
1020         selected_method = m;
1021     } else if (!m-&gt;has_itable_index()) {
1022       // non-interface call -- for that little speed boost, don&#39;t handlize
1023       debug_only(NoSafepointVerifier nosafepoint;)
1024       // jni_GetMethodID makes sure class is linked and initialized
1025       // so m should have a valid vtable index.
1026       assert(m-&gt;valid_vtable_index(), &quot;no valid vtable index&quot;);
1027       int vtbl_index = m-&gt;vtable_index();
1028       if (vtbl_index != Method::nonvirtual_vtable_index) {
1029         selected_method = h_recv-&gt;klass()-&gt;method_at_vtable(vtbl_index);
1030       } else {
1031         // final method
1032         selected_method = m;
1033       }
1034     } else {
1035       // interface call
1036       int itbl_index = m-&gt;itable_index();
1037       Klass* k = h_recv-&gt;klass();
1038       selected_method = InstanceKlass::cast(k)-&gt;method_at_itable(holder, itbl_index, CHECK);
1039     }
1040   }
1041 
1042   methodHandle method(THREAD, selected_method);
1043 
1044   // Create object to hold arguments for the JavaCall, and associate it with
1045   // the jni parser
1046   ResourceMark rm(THREAD);
1047   JavaCallArguments java_args(number_of_parameters);
1048 
1049   // handle arguments
1050   assert(!method-&gt;is_static(), &quot;method %s should not be static&quot;, method-&gt;name_and_sig_as_C_string());
1051   java_args.push_oop(h_recv); // Push jobject handle
1052 
1053   // Fill out JavaCallArguments object
1054   args-&gt;push_arguments_on(&amp;java_args);
1055   // Initialize result type
1056   result-&gt;set_type(args-&gt;return_type());
1057 
1058   // Invoke the method. Result is returned as oop.
1059   JavaCalls::call(result, method, &amp;java_args, CHECK);
1060 
1061   // Convert result
1062   if (is_reference_type(result-&gt;get_type())) {
1063     result-&gt;set_jobject(JNIHandles::make_local(env, (oop) result-&gt;get_jobject()));
1064   }
1065 }
1066 
1067 
1068 static instanceOop alloc_object(jclass clazz, TRAPS) {
1069   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
1070   if (k == NULL) {
1071     ResourceMark rm(THREAD);
1072     THROW_(vmSymbols::java_lang_InstantiationException(), NULL);
1073   }
1074   k-&gt;check_valid_for_instantiation(false, CHECK_NULL);
1075   k-&gt;initialize(CHECK_NULL);
1076   instanceOop ih = InstanceKlass::cast(k)-&gt;allocate_instance(THREAD);
1077   return ih;
1078 }
1079 
1080 DT_RETURN_MARK_DECL(AllocObject, jobject
1081                     , HOTSPOT_JNI_ALLOCOBJECT_RETURN(_ret_ref));
1082 
1083 JNI_ENTRY(jobject, jni_AllocObject(JNIEnv *env, jclass clazz))
1084   JNIWrapper(&quot;AllocObject&quot;);
1085 
1086   HOTSPOT_JNI_ALLOCOBJECT_ENTRY(env, clazz);
1087 
1088   jobject ret = NULL;
1089   DT_RETURN_MARK(AllocObject, jobject, (const jobject&amp;)ret);
1090 
1091   instanceOop i = alloc_object(clazz, CHECK_NULL);
1092   ret = JNIHandles::make_local(env, i);
1093   return ret;
1094 JNI_END
1095 
1096 DT_RETURN_MARK_DECL(NewObjectA, jobject
1097                     , HOTSPOT_JNI_NEWOBJECTA_RETURN(_ret_ref));
1098 
1099 JNI_ENTRY(jobject, jni_NewObjectA(JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args))
1100   JNIWrapper(&quot;NewObjectA&quot;);
1101 
1102   HOTSPOT_JNI_NEWOBJECTA_ENTRY(env, clazz, (uintptr_t) methodID);
1103 
1104   jobject obj = NULL;
1105   DT_RETURN_MARK(NewObjectA, jobject, (const jobject)obj);
1106 
1107   instanceOop i = alloc_object(clazz, CHECK_NULL);
1108   obj = JNIHandles::make_local(env, i);
1109   JavaValue jvalue(T_VOID);
1110   JNI_ArgumentPusherArray ap(methodID, args);
1111   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_NULL);
1112   return obj;
1113 JNI_END
1114 
1115 
1116 DT_RETURN_MARK_DECL(NewObjectV, jobject
1117                     , HOTSPOT_JNI_NEWOBJECTV_RETURN(_ret_ref));
1118 
1119 JNI_ENTRY(jobject, jni_NewObjectV(JNIEnv *env, jclass clazz, jmethodID methodID, va_list args))
1120   JNIWrapper(&quot;NewObjectV&quot;);
1121 
1122   HOTSPOT_JNI_NEWOBJECTV_ENTRY(env, clazz, (uintptr_t) methodID);
1123 
1124   jobject obj = NULL;
1125   DT_RETURN_MARK(NewObjectV, jobject, (const jobject&amp;)obj);
1126 
1127   instanceOop i = alloc_object(clazz, CHECK_NULL);
1128   obj = JNIHandles::make_local(env, i);
1129   JavaValue jvalue(T_VOID);
1130   JNI_ArgumentPusherVaArg ap(methodID, args);
1131   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_NULL);
1132   return obj;
1133 JNI_END
1134 
1135 
1136 DT_RETURN_MARK_DECL(NewObject, jobject
1137                     , HOTSPOT_JNI_NEWOBJECT_RETURN(_ret_ref));
1138 
1139 JNI_ENTRY(jobject, jni_NewObject(JNIEnv *env, jclass clazz, jmethodID methodID, ...))
1140   JNIWrapper(&quot;NewObject&quot;);
1141 
1142   HOTSPOT_JNI_NEWOBJECT_ENTRY(env, clazz, (uintptr_t) methodID);
1143 
1144   jobject obj = NULL;
1145   DT_RETURN_MARK(NewObject, jobject, (const jobject&amp;)obj);
1146 
1147   instanceOop i = alloc_object(clazz, CHECK_NULL);
1148   obj = JNIHandles::make_local(env, i);
1149   va_list args;
1150   va_start(args, methodID);
1151   JavaValue jvalue(T_VOID);
1152   JNI_ArgumentPusherVaArg ap(methodID, args);
1153   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_NULL);
1154   va_end(args);
1155   return obj;
1156 JNI_END
1157 
1158 
1159 JNI_ENTRY(jclass, jni_GetObjectClass(JNIEnv *env, jobject obj))
1160   JNIWrapper(&quot;GetObjectClass&quot;);
1161 
1162   HOTSPOT_JNI_GETOBJECTCLASS_ENTRY(env, obj);
1163 
1164   Klass* k = JNIHandles::resolve_non_null(obj)-&gt;klass();
1165   jclass ret =
1166     (jclass) JNIHandles::make_local(env, k-&gt;java_mirror());
1167 
1168   HOTSPOT_JNI_GETOBJECTCLASS_RETURN(ret);
1169   return ret;
1170 JNI_END
1171 
1172 JNI_ENTRY_NO_PRESERVE(jboolean, jni_IsInstanceOf(JNIEnv *env, jobject obj, jclass clazz))
1173   JNIWrapper(&quot;IsInstanceOf&quot;);
1174 
1175   HOTSPOT_JNI_ISINSTANCEOF_ENTRY(env, obj, clazz);
1176 
1177   jboolean ret = JNI_TRUE;
1178   if (obj != NULL) {
1179     ret = JNI_FALSE;
1180     Klass* k = java_lang_Class::as_Klass(
1181       JNIHandles::resolve_non_null(clazz));
1182     if (k != NULL) {
1183       ret = JNIHandles::resolve_non_null(obj)-&gt;is_a(k) ? JNI_TRUE : JNI_FALSE;
1184     }
1185   }
1186 
1187   HOTSPOT_JNI_ISINSTANCEOF_RETURN(ret);
1188   return ret;
1189 JNI_END
1190 
1191 
1192 static jmethodID get_method_id(JNIEnv *env, jclass clazz, const char *name_str,
1193                                const char *sig, bool is_static, TRAPS) {
1194   // %%%% This code should probably just call into a method in the LinkResolver
1195   //
1196   // The class should have been loaded (we have an instance of the class
1197   // passed in) so the method and signature should already be in the symbol
1198   // table.  If they&#39;re not there, the method doesn&#39;t exist.
1199   const char *name_to_probe = (name_str == NULL)
1200                         ? vmSymbols::object_initializer_name()-&gt;as_C_string()
1201                         : name_str;
1202   TempNewSymbol name = SymbolTable::probe(name_to_probe, (int)strlen(name_to_probe));
1203   TempNewSymbol signature = SymbolTable::probe(sig, (int)strlen(sig));
1204 
1205   if (name == NULL || signature == NULL) {
1206     THROW_MSG_0(vmSymbols::java_lang_NoSuchMethodError(), name_str);
1207   }
1208 
1209   Klass* klass = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
1210 
1211   // Throw a NoSuchMethodError exception if we have an instance of a
1212   // primitive java.lang.Class
1213   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(clazz))) {
1214     ResourceMark rm;
1215     THROW_MSG_0(vmSymbols::java_lang_NoSuchMethodError(), err_msg(&quot;%s%s.%s%s&quot;, is_static ? &quot;static &quot; : &quot;&quot;, klass-&gt;signature_name(), name_str, sig));
1216   }
1217 
1218   // Make sure class is linked and initialized before handing id&#39;s out to
1219   // Method*s.
1220   klass-&gt;initialize(CHECK_NULL);
1221 
1222   Method* m;
1223   if (name == vmSymbols::object_initializer_name() ||
1224       name == vmSymbols::class_initializer_name()) {
1225     // Never search superclasses for constructors
1226     if (klass-&gt;is_instance_klass()) {
1227       m = InstanceKlass::cast(klass)-&gt;find_method(name, signature);
1228     } else {
1229       m = NULL;
1230     }
1231   } else {
1232     m = klass-&gt;lookup_method(name, signature);
1233     if (m == NULL &amp;&amp;  klass-&gt;is_instance_klass()) {
1234       m = InstanceKlass::cast(klass)-&gt;lookup_method_in_ordered_interfaces(name, signature);
1235     }
1236   }
1237   if (m == NULL || (m-&gt;is_static() != is_static)) {
1238     ResourceMark rm;
1239     THROW_MSG_0(vmSymbols::java_lang_NoSuchMethodError(), err_msg(&quot;%s%s.%s%s&quot;, is_static ? &quot;static &quot; : &quot;&quot;, klass-&gt;signature_name(), name_str, sig));
1240   }
1241   return m-&gt;jmethod_id();
1242 }
1243 
1244 
1245 JNI_ENTRY(jmethodID, jni_GetMethodID(JNIEnv *env, jclass clazz,
1246           const char *name, const char *sig))
1247   JNIWrapper(&quot;GetMethodID&quot;);
1248   HOTSPOT_JNI_GETMETHODID_ENTRY(env, clazz, (char *) name, (char *) sig);
1249   jmethodID ret = get_method_id(env, clazz, name, sig, false, thread);
1250   HOTSPOT_JNI_GETMETHODID_RETURN((uintptr_t) ret);
1251   return ret;
1252 JNI_END
1253 
1254 
1255 JNI_ENTRY(jmethodID, jni_GetStaticMethodID(JNIEnv *env, jclass clazz,
1256           const char *name, const char *sig))
1257   JNIWrapper(&quot;GetStaticMethodID&quot;);
1258   HOTSPOT_JNI_GETSTATICMETHODID_ENTRY(env, (char *) clazz, (char *) name, (char *)sig);
1259   jmethodID ret = get_method_id(env, clazz, name, sig, true, thread);
1260   HOTSPOT_JNI_GETSTATICMETHODID_RETURN((uintptr_t) ret);
1261   return ret;
1262 JNI_END
1263 
1264 
1265 
1266 //
1267 // Calling Methods
1268 //
1269 
1270 
1271 #define DEFINE_CALLMETHOD(ResultType, Result, Tag \
1272                           , EntryProbe, ReturnProbe)    \
1273 \
1274   DT_RETURN_MARK_DECL_FOR(Result, Call##Result##Method, ResultType \
1275                           , ReturnProbe);                          \
1276 \
1277 JNI_ENTRY(ResultType, \
1278           jni_Call##Result##Method(JNIEnv *env, jobject obj, jmethodID methodID, ...)) \
1279   JNIWrapper(&quot;Call&quot; XSTR(Result) &quot;Method&quot;); \
1280 \
1281   EntryProbe; \
1282   ResultType ret = 0;\
1283   DT_RETURN_MARK_FOR(Result, Call##Result##Method, ResultType, \
1284                      (const ResultType&amp;)ret);\
1285 \
1286   va_list args; \
1287   va_start(args, methodID); \
1288   JavaValue jvalue(Tag); \
1289   JNI_ArgumentPusherVaArg ap(methodID, args); \
1290   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_VIRTUAL, methodID, &amp;ap, CHECK_0); \
1291   va_end(args); \
1292   ret = jvalue.get_##ResultType(); \
1293   return ret;\
1294 JNI_END
1295 
1296 // the runtime type of subword integral basic types is integer
1297 DEFINE_CALLMETHOD(jboolean, Boolean, T_BOOLEAN
1298                   , HOTSPOT_JNI_CALLBOOLEANMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1299                   HOTSPOT_JNI_CALLBOOLEANMETHOD_RETURN(_ret_ref))
1300 DEFINE_CALLMETHOD(jbyte,    Byte,    T_BYTE
1301                   , HOTSPOT_JNI_CALLBYTEMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1302                   HOTSPOT_JNI_CALLBYTEMETHOD_RETURN(_ret_ref))
1303 DEFINE_CALLMETHOD(jchar,    Char,    T_CHAR
1304                   , HOTSPOT_JNI_CALLCHARMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1305                   HOTSPOT_JNI_CALLCHARMETHOD_RETURN(_ret_ref))
1306 DEFINE_CALLMETHOD(jshort,   Short,   T_SHORT
1307                   , HOTSPOT_JNI_CALLSHORTMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1308                   HOTSPOT_JNI_CALLSHORTMETHOD_RETURN(_ret_ref))
1309 
1310 DEFINE_CALLMETHOD(jobject,  Object,  T_OBJECT
1311                   , HOTSPOT_JNI_CALLOBJECTMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1312                   HOTSPOT_JNI_CALLOBJECTMETHOD_RETURN(_ret_ref))
1313 DEFINE_CALLMETHOD(jint,     Int,     T_INT,
1314                   HOTSPOT_JNI_CALLINTMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1315                   HOTSPOT_JNI_CALLINTMETHOD_RETURN(_ret_ref))
1316 DEFINE_CALLMETHOD(jlong,    Long,    T_LONG
1317                   , HOTSPOT_JNI_CALLLONGMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1318                   HOTSPOT_JNI_CALLLONGMETHOD_RETURN(_ret_ref))
1319 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1320 DEFINE_CALLMETHOD(jfloat,   Float,   T_FLOAT
1321                   , HOTSPOT_JNI_CALLFLOATMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1322                   HOTSPOT_JNI_CALLFLOATMETHOD_RETURN())
1323 DEFINE_CALLMETHOD(jdouble,  Double,  T_DOUBLE
1324                   , HOTSPOT_JNI_CALLDOUBLEMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1325                   HOTSPOT_JNI_CALLDOUBLEMETHOD_RETURN())
1326 
1327 #define DEFINE_CALLMETHODV(ResultType, Result, Tag \
1328                           , EntryProbe, ReturnProbe)    \
1329 \
1330   DT_RETURN_MARK_DECL_FOR(Result, Call##Result##MethodV, ResultType \
1331                           , ReturnProbe);                          \
1332 \
1333 JNI_ENTRY(ResultType, \
1334           jni_Call##Result##MethodV(JNIEnv *env, jobject obj, jmethodID methodID, va_list args)) \
1335   JNIWrapper(&quot;Call&quot; XSTR(Result) &quot;MethodV&quot;); \
1336 \
1337   EntryProbe;\
1338   ResultType ret = 0;\
1339   DT_RETURN_MARK_FOR(Result, Call##Result##MethodV, ResultType, \
1340                      (const ResultType&amp;)ret);\
1341 \
1342   JavaValue jvalue(Tag); \
1343   JNI_ArgumentPusherVaArg ap(methodID, args); \
1344   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_VIRTUAL, methodID, &amp;ap, CHECK_0); \
1345   ret = jvalue.get_##ResultType(); \
1346   return ret;\
1347 JNI_END
1348 
1349 // the runtime type of subword integral basic types is integer
1350 DEFINE_CALLMETHODV(jboolean, Boolean, T_BOOLEAN
1351                   , HOTSPOT_JNI_CALLBOOLEANMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1352                   HOTSPOT_JNI_CALLBOOLEANMETHODV_RETURN(_ret_ref))
1353 DEFINE_CALLMETHODV(jbyte,    Byte,    T_BYTE
1354                   , HOTSPOT_JNI_CALLBYTEMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1355                   HOTSPOT_JNI_CALLBYTEMETHODV_RETURN(_ret_ref))
1356 DEFINE_CALLMETHODV(jchar,    Char,    T_CHAR
1357                   , HOTSPOT_JNI_CALLCHARMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1358                   HOTSPOT_JNI_CALLCHARMETHODV_RETURN(_ret_ref))
1359 DEFINE_CALLMETHODV(jshort,   Short,   T_SHORT
1360                   , HOTSPOT_JNI_CALLSHORTMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1361                   HOTSPOT_JNI_CALLSHORTMETHODV_RETURN(_ret_ref))
1362 
1363 DEFINE_CALLMETHODV(jobject,  Object,  T_OBJECT
1364                   , HOTSPOT_JNI_CALLOBJECTMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1365                   HOTSPOT_JNI_CALLOBJECTMETHODV_RETURN(_ret_ref))
1366 DEFINE_CALLMETHODV(jint,     Int,     T_INT,
1367                   HOTSPOT_JNI_CALLINTMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1368                   HOTSPOT_JNI_CALLINTMETHODV_RETURN(_ret_ref))
1369 DEFINE_CALLMETHODV(jlong,    Long,    T_LONG
1370                   , HOTSPOT_JNI_CALLLONGMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1371                   HOTSPOT_JNI_CALLLONGMETHODV_RETURN(_ret_ref))
1372 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1373 DEFINE_CALLMETHODV(jfloat,   Float,   T_FLOAT
1374                   , HOTSPOT_JNI_CALLFLOATMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1375                   HOTSPOT_JNI_CALLFLOATMETHODV_RETURN())
1376 DEFINE_CALLMETHODV(jdouble,  Double,  T_DOUBLE
1377                   , HOTSPOT_JNI_CALLDOUBLEMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1378                   HOTSPOT_JNI_CALLDOUBLEMETHODV_RETURN())
1379 
1380 #define DEFINE_CALLMETHODA(ResultType, Result, Tag \
1381                           , EntryProbe, ReturnProbe)    \
1382 \
1383   DT_RETURN_MARK_DECL_FOR(Result, Call##Result##MethodA, ResultType \
1384                           , ReturnProbe);                          \
1385 \
1386 JNI_ENTRY(ResultType, \
1387           jni_Call##Result##MethodA(JNIEnv *env, jobject obj, jmethodID methodID, const jvalue *args)) \
1388   JNIWrapper(&quot;Call&quot; XSTR(Result) &quot;MethodA&quot;); \
1389   EntryProbe; \
1390   ResultType ret = 0;\
1391   DT_RETURN_MARK_FOR(Result, Call##Result##MethodA, ResultType, \
1392                      (const ResultType&amp;)ret);\
1393 \
1394   JavaValue jvalue(Tag); \
1395   JNI_ArgumentPusherArray ap(methodID, args); \
1396   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_VIRTUAL, methodID, &amp;ap, CHECK_0); \
1397   ret = jvalue.get_##ResultType(); \
1398   return ret;\
1399 JNI_END
1400 
1401 // the runtime type of subword integral basic types is integer
1402 DEFINE_CALLMETHODA(jboolean, Boolean, T_BOOLEAN
1403                   , HOTSPOT_JNI_CALLBOOLEANMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1404                   HOTSPOT_JNI_CALLBOOLEANMETHODA_RETURN(_ret_ref))
1405 DEFINE_CALLMETHODA(jbyte,    Byte,    T_BYTE
1406                   , HOTSPOT_JNI_CALLBYTEMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1407                   HOTSPOT_JNI_CALLBYTEMETHODA_RETURN(_ret_ref))
1408 DEFINE_CALLMETHODA(jchar,    Char,    T_CHAR
1409                   , HOTSPOT_JNI_CALLCHARMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1410                   HOTSPOT_JNI_CALLCHARMETHODA_RETURN(_ret_ref))
1411 DEFINE_CALLMETHODA(jshort,   Short,   T_SHORT
1412                   , HOTSPOT_JNI_CALLSHORTMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1413                   HOTSPOT_JNI_CALLSHORTMETHODA_RETURN(_ret_ref))
1414 
1415 DEFINE_CALLMETHODA(jobject,  Object,  T_OBJECT
1416                   , HOTSPOT_JNI_CALLOBJECTMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1417                   HOTSPOT_JNI_CALLOBJECTMETHODA_RETURN(_ret_ref))
1418 DEFINE_CALLMETHODA(jint,     Int,     T_INT,
1419                   HOTSPOT_JNI_CALLINTMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1420                   HOTSPOT_JNI_CALLINTMETHODA_RETURN(_ret_ref))
1421 DEFINE_CALLMETHODA(jlong,    Long,    T_LONG
1422                   , HOTSPOT_JNI_CALLLONGMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1423                   HOTSPOT_JNI_CALLLONGMETHODA_RETURN(_ret_ref))
1424 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1425 DEFINE_CALLMETHODA(jfloat,   Float,   T_FLOAT
1426                   , HOTSPOT_JNI_CALLFLOATMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1427                   HOTSPOT_JNI_CALLFLOATMETHODA_RETURN())
1428 DEFINE_CALLMETHODA(jdouble,  Double,  T_DOUBLE
1429                   , HOTSPOT_JNI_CALLDOUBLEMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1430                   HOTSPOT_JNI_CALLDOUBLEMETHODA_RETURN())
1431 
1432 DT_VOID_RETURN_MARK_DECL(CallVoidMethod, HOTSPOT_JNI_CALLVOIDMETHOD_RETURN());
1433 DT_VOID_RETURN_MARK_DECL(CallVoidMethodV, HOTSPOT_JNI_CALLVOIDMETHODV_RETURN());
1434 DT_VOID_RETURN_MARK_DECL(CallVoidMethodA, HOTSPOT_JNI_CALLVOIDMETHODA_RETURN());
1435 
1436 
1437 JNI_ENTRY(void, jni_CallVoidMethod(JNIEnv *env, jobject obj, jmethodID methodID, ...))
1438   JNIWrapper(&quot;CallVoidMethod&quot;);
1439   HOTSPOT_JNI_CALLVOIDMETHOD_ENTRY(env, obj, (uintptr_t) methodID);
1440   DT_VOID_RETURN_MARK(CallVoidMethod);
1441 
1442   va_list args;
1443   va_start(args, methodID);
1444   JavaValue jvalue(T_VOID);
1445   JNI_ArgumentPusherVaArg ap(methodID, args);
1446   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_VIRTUAL, methodID, &amp;ap, CHECK);
1447   va_end(args);
1448 JNI_END
1449 
1450 
1451 JNI_ENTRY(void, jni_CallVoidMethodV(JNIEnv *env, jobject obj, jmethodID methodID, va_list args))
1452   JNIWrapper(&quot;CallVoidMethodV&quot;);
1453   HOTSPOT_JNI_CALLVOIDMETHODV_ENTRY(env, obj, (uintptr_t) methodID);
1454   DT_VOID_RETURN_MARK(CallVoidMethodV);
1455 
1456   JavaValue jvalue(T_VOID);
1457   JNI_ArgumentPusherVaArg ap(methodID, args);
1458   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_VIRTUAL, methodID, &amp;ap, CHECK);
1459 JNI_END
1460 
1461 
1462 JNI_ENTRY(void, jni_CallVoidMethodA(JNIEnv *env, jobject obj, jmethodID methodID, const jvalue *args))
1463   JNIWrapper(&quot;CallVoidMethodA&quot;);
1464   HOTSPOT_JNI_CALLVOIDMETHODA_ENTRY(env, obj, (uintptr_t) methodID);
1465   DT_VOID_RETURN_MARK(CallVoidMethodA);
1466 
1467   JavaValue jvalue(T_VOID);
1468   JNI_ArgumentPusherArray ap(methodID, args);
1469   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_VIRTUAL, methodID, &amp;ap, CHECK);
1470 JNI_END
1471 
1472 
1473 
1474 #define DEFINE_CALLNONVIRTUALMETHOD(ResultType, Result, Tag \
1475                                     , EntryProbe, ReturnProbe)      \
1476 \
1477   DT_RETURN_MARK_DECL_FOR(Result, CallNonvirtual##Result##Method, ResultType \
1478                           , ReturnProbe);\
1479 \
1480 JNI_ENTRY(ResultType, \
1481           jni_CallNonvirtual##Result##Method(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, ...)) \
1482   JNIWrapper(&quot;CallNonvitual&quot; XSTR(Result) &quot;Method&quot;); \
1483 \
1484   EntryProbe;\
1485   ResultType ret;\
1486   DT_RETURN_MARK_FOR(Result, CallNonvirtual##Result##Method, ResultType, \
1487                      (const ResultType&amp;)ret);\
1488 \
1489   va_list args; \
1490   va_start(args, methodID); \
1491   JavaValue jvalue(Tag); \
1492   JNI_ArgumentPusherVaArg ap(methodID, args); \
1493   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_0); \
1494   va_end(args); \
1495   ret = jvalue.get_##ResultType(); \
1496   return ret;\
1497 JNI_END
1498 
1499 // the runtime type of subword integral basic types is integer
1500 DEFINE_CALLNONVIRTUALMETHOD(jboolean, Boolean, T_BOOLEAN
1501                             , HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1502                             HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHOD_RETURN(_ret_ref))
1503 DEFINE_CALLNONVIRTUALMETHOD(jbyte,    Byte,    T_BYTE
1504                             , HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1505                             HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHOD_RETURN(_ret_ref))
1506 DEFINE_CALLNONVIRTUALMETHOD(jchar,    Char,    T_CHAR
1507                             , HOTSPOT_JNI_CALLNONVIRTUALCHARMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1508                             HOTSPOT_JNI_CALLNONVIRTUALCHARMETHOD_RETURN(_ret_ref))
1509 DEFINE_CALLNONVIRTUALMETHOD(jshort,   Short,   T_SHORT
1510                             , HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1511                             HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHOD_RETURN(_ret_ref))
1512 
1513 DEFINE_CALLNONVIRTUALMETHOD(jobject,  Object,  T_OBJECT
1514                             , HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1515                             HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHOD_RETURN(_ret_ref))
1516 DEFINE_CALLNONVIRTUALMETHOD(jint,     Int,     T_INT
1517                             , HOTSPOT_JNI_CALLNONVIRTUALINTMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1518                             HOTSPOT_JNI_CALLNONVIRTUALINTMETHOD_RETURN(_ret_ref))
1519 DEFINE_CALLNONVIRTUALMETHOD(jlong,    Long,    T_LONG
1520                             , HOTSPOT_JNI_CALLNONVIRTUALLONGMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1521 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1522                             HOTSPOT_JNI_CALLNONVIRTUALLONGMETHOD_RETURN(_ret_ref))
1523 DEFINE_CALLNONVIRTUALMETHOD(jfloat,   Float,   T_FLOAT
1524                             , HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1525                             HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHOD_RETURN())
1526 DEFINE_CALLNONVIRTUALMETHOD(jdouble,  Double,  T_DOUBLE
1527                             , HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1528                             HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHOD_RETURN())
1529 
1530 #define DEFINE_CALLNONVIRTUALMETHODV(ResultType, Result, Tag \
1531                                     , EntryProbe, ReturnProbe)      \
1532 \
1533   DT_RETURN_MARK_DECL_FOR(Result, CallNonvirtual##Result##MethodV, ResultType \
1534                           , ReturnProbe);\
1535 \
1536 JNI_ENTRY(ResultType, \
1537           jni_CallNonvirtual##Result##MethodV(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, va_list args)) \
1538   JNIWrapper(&quot;CallNonvitual&quot; XSTR(Result) &quot;MethodV&quot;); \
1539 \
1540   EntryProbe;\
1541   ResultType ret;\
1542   DT_RETURN_MARK_FOR(Result, CallNonvirtual##Result##MethodV, ResultType, \
1543                      (const ResultType&amp;)ret);\
1544 \
1545   JavaValue jvalue(Tag); \
1546   JNI_ArgumentPusherVaArg ap(methodID, args); \
1547   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_0); \
1548   ret = jvalue.get_##ResultType(); \
1549   return ret;\
1550 JNI_END
1551 
1552 // the runtime type of subword integral basic types is integer
1553 DEFINE_CALLNONVIRTUALMETHODV(jboolean, Boolean, T_BOOLEAN
1554                             , HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1555                             HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHODV_RETURN(_ret_ref))
1556 DEFINE_CALLNONVIRTUALMETHODV(jbyte,    Byte,    T_BYTE
1557                             , HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1558                             HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHODV_RETURN(_ret_ref))
1559 DEFINE_CALLNONVIRTUALMETHODV(jchar,    Char,    T_CHAR
1560                             , HOTSPOT_JNI_CALLNONVIRTUALCHARMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1561                             HOTSPOT_JNI_CALLNONVIRTUALCHARMETHODV_RETURN(_ret_ref))
1562 DEFINE_CALLNONVIRTUALMETHODV(jshort,   Short,   T_SHORT
1563                             , HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1564                             HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHODV_RETURN(_ret_ref))
1565 
1566 DEFINE_CALLNONVIRTUALMETHODV(jobject,  Object,  T_OBJECT
1567                             , HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1568                             HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHODV_RETURN(_ret_ref))
1569 DEFINE_CALLNONVIRTUALMETHODV(jint,     Int,     T_INT
1570                             , HOTSPOT_JNI_CALLNONVIRTUALINTMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1571                             HOTSPOT_JNI_CALLNONVIRTUALINTMETHODV_RETURN(_ret_ref))
1572 DEFINE_CALLNONVIRTUALMETHODV(jlong,    Long,    T_LONG
1573                             , HOTSPOT_JNI_CALLNONVIRTUALLONGMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1574 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1575                             HOTSPOT_JNI_CALLNONVIRTUALLONGMETHODV_RETURN(_ret_ref))
1576 DEFINE_CALLNONVIRTUALMETHODV(jfloat,   Float,   T_FLOAT
1577                             , HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1578                             HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHODV_RETURN())
1579 DEFINE_CALLNONVIRTUALMETHODV(jdouble,  Double,  T_DOUBLE
1580                             , HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1581                             HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHODV_RETURN())
1582 
1583 #define DEFINE_CALLNONVIRTUALMETHODA(ResultType, Result, Tag \
1584                                     , EntryProbe, ReturnProbe)      \
1585 \
1586   DT_RETURN_MARK_DECL_FOR(Result, CallNonvirtual##Result##MethodA, ResultType \
1587                           , ReturnProbe);\
1588 \
1589 JNI_ENTRY(ResultType, \
1590           jni_CallNonvirtual##Result##MethodA(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, const jvalue *args)) \
1591   JNIWrapper(&quot;CallNonvitual&quot; XSTR(Result) &quot;MethodA&quot;); \
1592 \
1593   EntryProbe;\
1594   ResultType ret;\
1595   DT_RETURN_MARK_FOR(Result, CallNonvirtual##Result##MethodA, ResultType, \
1596                      (const ResultType&amp;)ret);\
1597 \
1598   JavaValue jvalue(Tag); \
1599   JNI_ArgumentPusherArray ap(methodID, args); \
1600   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_0); \
1601   ret = jvalue.get_##ResultType(); \
1602   return ret;\
1603 JNI_END
1604 
1605 // the runtime type of subword integral basic types is integer
1606 DEFINE_CALLNONVIRTUALMETHODA(jboolean, Boolean, T_BOOLEAN
1607                             , HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1608                             HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHODA_RETURN(_ret_ref))
1609 DEFINE_CALLNONVIRTUALMETHODA(jbyte,    Byte,    T_BYTE
1610                             , HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1611                             HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHODA_RETURN(_ret_ref))
1612 DEFINE_CALLNONVIRTUALMETHODA(jchar,    Char,    T_CHAR
1613                             , HOTSPOT_JNI_CALLNONVIRTUALCHARMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1614                             HOTSPOT_JNI_CALLNONVIRTUALCHARMETHODA_RETURN(_ret_ref))
1615 DEFINE_CALLNONVIRTUALMETHODA(jshort,   Short,   T_SHORT
1616                             , HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1617                             HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHODA_RETURN(_ret_ref))
1618 
1619 DEFINE_CALLNONVIRTUALMETHODA(jobject,  Object,  T_OBJECT
1620                             , HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1621                             HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHODA_RETURN(_ret_ref))
1622 DEFINE_CALLNONVIRTUALMETHODA(jint,     Int,     T_INT
1623                             , HOTSPOT_JNI_CALLNONVIRTUALINTMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1624                             HOTSPOT_JNI_CALLNONVIRTUALINTMETHODA_RETURN(_ret_ref))
1625 DEFINE_CALLNONVIRTUALMETHODA(jlong,    Long,    T_LONG
1626                             , HOTSPOT_JNI_CALLNONVIRTUALLONGMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1627 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1628                             HOTSPOT_JNI_CALLNONVIRTUALLONGMETHODA_RETURN(_ret_ref))
1629 DEFINE_CALLNONVIRTUALMETHODA(jfloat,   Float,   T_FLOAT
1630                             , HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1631                             HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHODA_RETURN())
1632 DEFINE_CALLNONVIRTUALMETHODA(jdouble,  Double,  T_DOUBLE
1633                             , HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1634                             HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHODA_RETURN())
1635 
1636 DT_VOID_RETURN_MARK_DECL(CallNonvirtualVoidMethod
1637                          , HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHOD_RETURN());
1638 DT_VOID_RETURN_MARK_DECL(CallNonvirtualVoidMethodV
1639                          , HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHODV_RETURN());
1640 DT_VOID_RETURN_MARK_DECL(CallNonvirtualVoidMethodA
1641                          , HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHODA_RETURN());
1642 
1643 JNI_ENTRY(void, jni_CallNonvirtualVoidMethod(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, ...))
1644   JNIWrapper(&quot;CallNonvirtualVoidMethod&quot;);
1645 
1646   HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHOD_ENTRY(env, obj, cls, (uintptr_t) methodID);
1647   DT_VOID_RETURN_MARK(CallNonvirtualVoidMethod);
1648 
1649   va_list args;
1650   va_start(args, methodID);
1651   JavaValue jvalue(T_VOID);
1652   JNI_ArgumentPusherVaArg ap(methodID, args);
1653   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK);
1654   va_end(args);
1655 JNI_END
1656 
1657 
1658 JNI_ENTRY(void, jni_CallNonvirtualVoidMethodV(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, va_list args))
1659   JNIWrapper(&quot;CallNonvirtualVoidMethodV&quot;);
1660 
1661   HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHODV_ENTRY(
1662                env, obj, cls, (uintptr_t) methodID);
1663   DT_VOID_RETURN_MARK(CallNonvirtualVoidMethodV);
1664 
1665   JavaValue jvalue(T_VOID);
1666   JNI_ArgumentPusherVaArg ap(methodID, args);
1667   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK);
1668 JNI_END
1669 
1670 
1671 JNI_ENTRY(void, jni_CallNonvirtualVoidMethodA(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, const jvalue *args))
1672   JNIWrapper(&quot;CallNonvirtualVoidMethodA&quot;);
1673   HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHODA_ENTRY(
1674                 env, obj, cls, (uintptr_t) methodID);
1675   DT_VOID_RETURN_MARK(CallNonvirtualVoidMethodA);
1676   JavaValue jvalue(T_VOID);
1677   JNI_ArgumentPusherArray ap(methodID, args);
1678   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK);
1679 JNI_END
1680 
1681 
1682 
1683 #define DEFINE_CALLSTATICMETHOD(ResultType, Result, Tag \
1684                                 , EntryProbe, ResultProbe) \
1685 \
1686   DT_RETURN_MARK_DECL_FOR(Result, CallStatic##Result##Method, ResultType \
1687                           , ResultProbe);                               \
1688 \
1689 JNI_ENTRY(ResultType, \
1690           jni_CallStatic##Result##Method(JNIEnv *env, jclass cls, jmethodID methodID, ...)) \
1691   JNIWrapper(&quot;CallStatic&quot; XSTR(Result) &quot;Method&quot;); \
1692 \
1693   EntryProbe; \
1694   ResultType ret = 0;\
1695   DT_RETURN_MARK_FOR(Result, CallStatic##Result##Method, ResultType, \
1696                      (const ResultType&amp;)ret);\
1697 \
1698   va_list args; \
1699   va_start(args, methodID); \
1700   JavaValue jvalue(Tag); \
1701   JNI_ArgumentPusherVaArg ap(methodID, args); \
1702   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK_0); \
1703   va_end(args); \
1704   ret = jvalue.get_##ResultType(); \
1705   return ret;\
1706 JNI_END
1707 
1708 // the runtime type of subword integral basic types is integer
1709 DEFINE_CALLSTATICMETHOD(jboolean, Boolean, T_BOOLEAN
1710                         , HOTSPOT_JNI_CALLSTATICBOOLEANMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1711                         HOTSPOT_JNI_CALLSTATICBOOLEANMETHOD_RETURN(_ret_ref));
1712 DEFINE_CALLSTATICMETHOD(jbyte,    Byte,    T_BYTE
1713                         , HOTSPOT_JNI_CALLSTATICBYTEMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1714                         HOTSPOT_JNI_CALLSTATICBYTEMETHOD_RETURN(_ret_ref));
1715 DEFINE_CALLSTATICMETHOD(jchar,    Char,    T_CHAR
1716                         , HOTSPOT_JNI_CALLSTATICCHARMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1717                         HOTSPOT_JNI_CALLSTATICCHARMETHOD_RETURN(_ret_ref));
1718 DEFINE_CALLSTATICMETHOD(jshort,   Short,   T_SHORT
1719                         , HOTSPOT_JNI_CALLSTATICSHORTMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1720                         HOTSPOT_JNI_CALLSTATICSHORTMETHOD_RETURN(_ret_ref));
1721 
1722 DEFINE_CALLSTATICMETHOD(jobject,  Object,  T_OBJECT
1723                         , HOTSPOT_JNI_CALLSTATICOBJECTMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1724                         HOTSPOT_JNI_CALLSTATICOBJECTMETHOD_RETURN(_ret_ref));
1725 DEFINE_CALLSTATICMETHOD(jint,     Int,     T_INT
1726                         , HOTSPOT_JNI_CALLSTATICINTMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1727                         HOTSPOT_JNI_CALLSTATICINTMETHOD_RETURN(_ret_ref));
1728 DEFINE_CALLSTATICMETHOD(jlong,    Long,    T_LONG
1729                         , HOTSPOT_JNI_CALLSTATICLONGMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1730                         HOTSPOT_JNI_CALLSTATICLONGMETHOD_RETURN(_ret_ref));
1731 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1732 DEFINE_CALLSTATICMETHOD(jfloat,   Float,   T_FLOAT
1733                         , HOTSPOT_JNI_CALLSTATICFLOATMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1734                         HOTSPOT_JNI_CALLSTATICFLOATMETHOD_RETURN());
1735 DEFINE_CALLSTATICMETHOD(jdouble,  Double,  T_DOUBLE
1736                         , HOTSPOT_JNI_CALLSTATICDOUBLEMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1737                         HOTSPOT_JNI_CALLSTATICDOUBLEMETHOD_RETURN());
1738 
1739 #define DEFINE_CALLSTATICMETHODV(ResultType, Result, Tag \
1740                                 , EntryProbe, ResultProbe) \
1741 \
1742   DT_RETURN_MARK_DECL_FOR(Result, CallStatic##Result##MethodV, ResultType \
1743                           , ResultProbe);                               \
1744 \
1745 JNI_ENTRY(ResultType, \
1746           jni_CallStatic##Result##MethodV(JNIEnv *env, jclass cls, jmethodID methodID, va_list args)) \
1747   JNIWrapper(&quot;CallStatic&quot; XSTR(Result) &quot;MethodV&quot;); \
1748 \
1749   EntryProbe; \
1750   ResultType ret = 0;\
1751   DT_RETURN_MARK_FOR(Result, CallStatic##Result##MethodV, ResultType, \
1752                      (const ResultType&amp;)ret);\
1753 \
1754   JavaValue jvalue(Tag); \
1755   JNI_ArgumentPusherVaArg ap(methodID, args); \
1756   /* Make sure class is initialized before trying to invoke its method */ \
1757   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls)); \
1758   k-&gt;initialize(CHECK_0); \
1759   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK_0); \
1760   va_end(args); \
1761   ret = jvalue.get_##ResultType(); \
1762   return ret;\
1763 JNI_END
1764 
1765 // the runtime type of subword integral basic types is integer
1766 DEFINE_CALLSTATICMETHODV(jboolean, Boolean, T_BOOLEAN
1767                         , HOTSPOT_JNI_CALLSTATICBOOLEANMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1768                         HOTSPOT_JNI_CALLSTATICBOOLEANMETHODV_RETURN(_ret_ref));
1769 DEFINE_CALLSTATICMETHODV(jbyte,    Byte,    T_BYTE
1770                         , HOTSPOT_JNI_CALLSTATICBYTEMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1771                         HOTSPOT_JNI_CALLSTATICBYTEMETHODV_RETURN(_ret_ref));
1772 DEFINE_CALLSTATICMETHODV(jchar,    Char,    T_CHAR
1773                         , HOTSPOT_JNI_CALLSTATICCHARMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1774                         HOTSPOT_JNI_CALLSTATICCHARMETHODV_RETURN(_ret_ref));
1775 DEFINE_CALLSTATICMETHODV(jshort,   Short,   T_SHORT
1776                         , HOTSPOT_JNI_CALLSTATICSHORTMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1777                         HOTSPOT_JNI_CALLSTATICSHORTMETHODV_RETURN(_ret_ref));
1778 
1779 DEFINE_CALLSTATICMETHODV(jobject,  Object,  T_OBJECT
1780                         , HOTSPOT_JNI_CALLSTATICOBJECTMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1781                         HOTSPOT_JNI_CALLSTATICOBJECTMETHODV_RETURN(_ret_ref));
1782 DEFINE_CALLSTATICMETHODV(jint,     Int,     T_INT
1783                         , HOTSPOT_JNI_CALLSTATICINTMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1784                         HOTSPOT_JNI_CALLSTATICINTMETHODV_RETURN(_ret_ref));
1785 DEFINE_CALLSTATICMETHODV(jlong,    Long,    T_LONG
1786                         , HOTSPOT_JNI_CALLSTATICLONGMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1787                         HOTSPOT_JNI_CALLSTATICLONGMETHODV_RETURN(_ret_ref));
1788 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1789 DEFINE_CALLSTATICMETHODV(jfloat,   Float,   T_FLOAT
1790                         , HOTSPOT_JNI_CALLSTATICFLOATMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1791                         HOTSPOT_JNI_CALLSTATICFLOATMETHODV_RETURN());
1792 DEFINE_CALLSTATICMETHODV(jdouble,  Double,  T_DOUBLE
1793                         , HOTSPOT_JNI_CALLSTATICDOUBLEMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1794                         HOTSPOT_JNI_CALLSTATICDOUBLEMETHODV_RETURN());
1795 
1796 #define DEFINE_CALLSTATICMETHODA(ResultType, Result, Tag \
1797                                 , EntryProbe, ResultProbe) \
1798 \
1799   DT_RETURN_MARK_DECL_FOR(Result, CallStatic##Result##MethodA, ResultType \
1800                           , ResultProbe);                               \
1801 \
1802 JNI_ENTRY(ResultType, \
1803           jni_CallStatic##Result##MethodA(JNIEnv *env, jclass cls, jmethodID methodID, const jvalue *args)) \
1804   JNIWrapper(&quot;CallStatic&quot; XSTR(Result) &quot;MethodA&quot;); \
1805 \
1806   EntryProbe; \
1807   ResultType ret = 0;\
1808   DT_RETURN_MARK_FOR(Result, CallStatic##Result##MethodA, ResultType, \
1809                      (const ResultType&amp;)ret);\
1810 \
1811   JavaValue jvalue(Tag); \
1812   JNI_ArgumentPusherArray ap(methodID, args); \
1813   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK_0); \
1814   ret = jvalue.get_##ResultType(); \
1815   return ret;\
1816 JNI_END
1817 
1818 // the runtime type of subword integral basic types is integer
1819 DEFINE_CALLSTATICMETHODA(jboolean, Boolean, T_BOOLEAN
1820                         , HOTSPOT_JNI_CALLSTATICBOOLEANMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1821                         HOTSPOT_JNI_CALLSTATICBOOLEANMETHODA_RETURN(_ret_ref));
1822 DEFINE_CALLSTATICMETHODA(jbyte,    Byte,    T_BYTE
1823                         , HOTSPOT_JNI_CALLSTATICBYTEMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1824                         HOTSPOT_JNI_CALLSTATICBYTEMETHODA_RETURN(_ret_ref));
1825 DEFINE_CALLSTATICMETHODA(jchar,    Char,    T_CHAR
1826                         , HOTSPOT_JNI_CALLSTATICCHARMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1827                         HOTSPOT_JNI_CALLSTATICCHARMETHODA_RETURN(_ret_ref));
1828 DEFINE_CALLSTATICMETHODA(jshort,   Short,   T_SHORT
1829                         , HOTSPOT_JNI_CALLSTATICSHORTMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1830                         HOTSPOT_JNI_CALLSTATICSHORTMETHODA_RETURN(_ret_ref));
1831 
1832 DEFINE_CALLSTATICMETHODA(jobject,  Object,  T_OBJECT
1833                         , HOTSPOT_JNI_CALLSTATICOBJECTMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1834                         HOTSPOT_JNI_CALLSTATICOBJECTMETHODA_RETURN(_ret_ref));
1835 DEFINE_CALLSTATICMETHODA(jint,     Int,     T_INT
1836                         , HOTSPOT_JNI_CALLSTATICINTMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1837                         HOTSPOT_JNI_CALLSTATICINTMETHODA_RETURN(_ret_ref));
1838 DEFINE_CALLSTATICMETHODA(jlong,    Long,    T_LONG
1839                         , HOTSPOT_JNI_CALLSTATICLONGMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1840                         HOTSPOT_JNI_CALLSTATICLONGMETHODA_RETURN(_ret_ref));
1841 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1842 DEFINE_CALLSTATICMETHODA(jfloat,   Float,   T_FLOAT
1843                         , HOTSPOT_JNI_CALLSTATICFLOATMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1844                         HOTSPOT_JNI_CALLSTATICFLOATMETHODA_RETURN());
1845 DEFINE_CALLSTATICMETHODA(jdouble,  Double,  T_DOUBLE
1846                         , HOTSPOT_JNI_CALLSTATICDOUBLEMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1847                         HOTSPOT_JNI_CALLSTATICDOUBLEMETHODA_RETURN());
1848 
1849 DT_VOID_RETURN_MARK_DECL(CallStaticVoidMethod
1850                          , HOTSPOT_JNI_CALLSTATICVOIDMETHOD_RETURN());
1851 DT_VOID_RETURN_MARK_DECL(CallStaticVoidMethodV
1852                          , HOTSPOT_JNI_CALLSTATICVOIDMETHODV_RETURN());
1853 DT_VOID_RETURN_MARK_DECL(CallStaticVoidMethodA
1854                          , HOTSPOT_JNI_CALLSTATICVOIDMETHODA_RETURN());
1855 
1856 JNI_ENTRY(void, jni_CallStaticVoidMethod(JNIEnv *env, jclass cls, jmethodID methodID, ...))
1857   JNIWrapper(&quot;CallStaticVoidMethod&quot;);
1858   HOTSPOT_JNI_CALLSTATICVOIDMETHOD_ENTRY(env, cls, (uintptr_t) methodID);
1859   DT_VOID_RETURN_MARK(CallStaticVoidMethod);
1860 
1861   va_list args;
1862   va_start(args, methodID);
1863   JavaValue jvalue(T_VOID);
1864   JNI_ArgumentPusherVaArg ap(methodID, args);
1865   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK);
1866   va_end(args);
1867 JNI_END
1868 
1869 
1870 JNI_ENTRY(void, jni_CallStaticVoidMethodV(JNIEnv *env, jclass cls, jmethodID methodID, va_list args))
1871   JNIWrapper(&quot;CallStaticVoidMethodV&quot;);
1872   HOTSPOT_JNI_CALLSTATICVOIDMETHODV_ENTRY(env, cls, (uintptr_t) methodID);
1873   DT_VOID_RETURN_MARK(CallStaticVoidMethodV);
1874 
1875   JavaValue jvalue(T_VOID);
1876   JNI_ArgumentPusherVaArg ap(methodID, args);
1877   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK);
1878 JNI_END
1879 
1880 
1881 JNI_ENTRY(void, jni_CallStaticVoidMethodA(JNIEnv *env, jclass cls, jmethodID methodID, const jvalue *args))
1882   JNIWrapper(&quot;CallStaticVoidMethodA&quot;);
1883   HOTSPOT_JNI_CALLSTATICVOIDMETHODA_ENTRY(env, cls, (uintptr_t) methodID);
1884   DT_VOID_RETURN_MARK(CallStaticVoidMethodA);
1885 
1886   JavaValue jvalue(T_VOID);
1887   JNI_ArgumentPusherArray ap(methodID, args);
1888   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK);
1889 JNI_END
1890 
1891 
1892 //
1893 // Accessing Fields
1894 //
1895 
1896 
1897 DT_RETURN_MARK_DECL(GetFieldID, jfieldID
1898                     , HOTSPOT_JNI_GETFIELDID_RETURN((uintptr_t)_ret_ref));
1899 
1900 JNI_ENTRY(jfieldID, jni_GetFieldID(JNIEnv *env, jclass clazz,
1901           const char *name, const char *sig))
1902   JNIWrapper(&quot;GetFieldID&quot;);
1903   HOTSPOT_JNI_GETFIELDID_ENTRY(env, clazz, (char *) name, (char *) sig);
1904   jfieldID ret = 0;
1905   DT_RETURN_MARK(GetFieldID, jfieldID, (const jfieldID&amp;)ret);
1906 
1907   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
1908 
1909   // The class should have been loaded (we have an instance of the class
1910   // passed in) so the field and signature should already be in the symbol
1911   // table.  If they&#39;re not there, the field doesn&#39;t exist.
1912   TempNewSymbol fieldname = SymbolTable::probe(name, (int)strlen(name));
1913   TempNewSymbol signame = SymbolTable::probe(sig, (int)strlen(sig));
1914   if (fieldname == NULL || signame == NULL) {
1915     ResourceMark rm;
1916     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), err_msg(&quot;%s.%s %s&quot;, k-&gt;external_name(), name, sig));
1917   }
1918 
1919   // Make sure class is initialized before handing id&#39;s out to fields
1920   k-&gt;initialize(CHECK_NULL);
1921 
1922   fieldDescriptor fd;
1923   if (!k-&gt;is_instance_klass() ||
1924       !InstanceKlass::cast(k)-&gt;find_field(fieldname, signame, false, &amp;fd)) {
1925     ResourceMark rm;
1926     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), err_msg(&quot;%s.%s %s&quot;, k-&gt;external_name(), name, sig));
1927   }
1928 
1929   // A jfieldID for a non-static field is simply the offset of the field within the instanceOop
1930   // It may also have hash bits for k, if VerifyJNIFields is turned on.
1931   ret = jfieldIDWorkaround::to_instance_jfieldID(k, fd.offset());
1932   return ret;
1933 JNI_END
1934 
1935 
1936 JNI_ENTRY(jobject, jni_GetObjectField(JNIEnv *env, jobject obj, jfieldID fieldID))
1937   JNIWrapper(&quot;GetObjectField&quot;);
1938   HOTSPOT_JNI_GETOBJECTFIELD_ENTRY(env, obj, (uintptr_t) fieldID);
1939   oop o = JNIHandles::resolve_non_null(obj);
1940   Klass* k = o-&gt;klass();
1941   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);
1942   // Keep JVMTI addition small and only check enabled flag here.
1943   // jni_GetField_probe() assumes that is okay to create handles.
1944   if (JvmtiExport::should_post_field_access()) {
1945     o = JvmtiExport::jni_GetField_probe(thread, obj, o, k, fieldID, false);
1946   }
1947   oop loaded_obj = HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_load_at(o, offset);
1948   jobject ret = JNIHandles::make_local(env, loaded_obj);
1949   HOTSPOT_JNI_GETOBJECTFIELD_RETURN(ret);
1950   return ret;
1951 JNI_END
1952 
1953 
1954 
1955 #define DEFINE_GETFIELD(Return,Fieldname,Result \
1956   , EntryProbe, ReturnProbe) \
1957 \
1958   DT_RETURN_MARK_DECL_FOR(Result, Get##Result##Field, Return \
1959   , ReturnProbe); \
1960 \
1961 JNI_ENTRY_NO_PRESERVE(Return, jni_Get##Result##Field(JNIEnv *env, jobject obj, jfieldID fieldID)) \
1962   JNIWrapper(&quot;Get&quot; XSTR(Result) &quot;Field&quot;); \
1963 \
1964   EntryProbe; \
1965   Return ret = 0;\
1966   DT_RETURN_MARK_FOR(Result, Get##Result##Field, Return, (const Return&amp;)ret);\
1967 \
1968   oop o = JNIHandles::resolve_non_null(obj); \
1969   Klass* k = o-&gt;klass(); \
1970   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);  \
1971   /* Keep JVMTI addition small and only check enabled flag here.       */ \
1972   /* jni_GetField_probe_nh() assumes that is not okay to create handles */ \
1973   /* and creates a ResetNoHandleMark.                                   */ \
1974   if (JvmtiExport::should_post_field_access()) { \
1975     o = JvmtiExport::jni_GetField_probe_nh(thread, obj, o, k, fieldID, false); \
1976   } \
1977   ret = o-&gt;Fieldname##_field(offset); \
1978   return ret; \
1979 JNI_END
1980 
1981 DEFINE_GETFIELD(jboolean, bool,   Boolean
1982                 , HOTSPOT_JNI_GETBOOLEANFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
1983                 HOTSPOT_JNI_GETBOOLEANFIELD_RETURN(_ret_ref))
1984 DEFINE_GETFIELD(jbyte,    byte,   Byte
1985                 , HOTSPOT_JNI_GETBYTEFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
1986                 HOTSPOT_JNI_GETBYTEFIELD_RETURN(_ret_ref))
1987 DEFINE_GETFIELD(jchar,    char,   Char
1988                 , HOTSPOT_JNI_GETCHARFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
1989                 HOTSPOT_JNI_GETCHARFIELD_RETURN(_ret_ref))
1990 DEFINE_GETFIELD(jshort,   short,  Short
1991                 , HOTSPOT_JNI_GETSHORTFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
1992                 HOTSPOT_JNI_GETSHORTFIELD_RETURN(_ret_ref))
1993 DEFINE_GETFIELD(jint,     int,    Int
1994                 , HOTSPOT_JNI_GETINTFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
1995                 HOTSPOT_JNI_GETINTFIELD_RETURN(_ret_ref))
1996 DEFINE_GETFIELD(jlong,    long,   Long
1997                 , HOTSPOT_JNI_GETLONGFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
1998                 HOTSPOT_JNI_GETLONGFIELD_RETURN(_ret_ref))
1999 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
2000 DEFINE_GETFIELD(jfloat,   float,  Float
2001                 , HOTSPOT_JNI_GETFLOATFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2002                 HOTSPOT_JNI_GETFLOATFIELD_RETURN())
2003 DEFINE_GETFIELD(jdouble,  double, Double
2004                 , HOTSPOT_JNI_GETDOUBLEFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2005                 HOTSPOT_JNI_GETDOUBLEFIELD_RETURN())
2006 
2007 address jni_GetBooleanField_addr() {
2008   return (address)jni_GetBooleanField;
2009 }
2010 address jni_GetByteField_addr() {
2011   return (address)jni_GetByteField;
2012 }
2013 address jni_GetCharField_addr() {
2014   return (address)jni_GetCharField;
2015 }
2016 address jni_GetShortField_addr() {
2017   return (address)jni_GetShortField;
2018 }
2019 address jni_GetIntField_addr() {
2020   return (address)jni_GetIntField;
2021 }
2022 address jni_GetLongField_addr() {
2023   return (address)jni_GetLongField;
2024 }
2025 address jni_GetFloatField_addr() {
2026   return (address)jni_GetFloatField;
2027 }
2028 address jni_GetDoubleField_addr() {
2029   return (address)jni_GetDoubleField;
2030 }
2031 
2032 JNI_ENTRY_NO_PRESERVE(void, jni_SetObjectField(JNIEnv *env, jobject obj, jfieldID fieldID, jobject value))
2033   JNIWrapper(&quot;SetObjectField&quot;);
2034   HOTSPOT_JNI_SETOBJECTFIELD_ENTRY(env, obj, (uintptr_t) fieldID, value);
2035   oop o = JNIHandles::resolve_non_null(obj);
2036   Klass* k = o-&gt;klass();
2037   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);
2038   // Keep JVMTI addition small and only check enabled flag here.
2039   // jni_SetField_probe_nh() assumes that is not okay to create handles
2040   // and creates a ResetNoHandleMark.
2041   if (JvmtiExport::should_post_field_modification()) {
2042     jvalue field_value;
2043     field_value.l = value;
2044     o = JvmtiExport::jni_SetField_probe_nh(thread, obj, o, k, fieldID, false, JVM_SIGNATURE_CLASS, (jvalue *)&amp;field_value);
2045   }
2046   HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_store_at(o, offset, JNIHandles::resolve(value));
2047   HOTSPOT_JNI_SETOBJECTFIELD_RETURN();
2048 JNI_END
2049 
2050 
2051 #define DEFINE_SETFIELD(Argument,Fieldname,Result,SigType,unionType \
2052                         , EntryProbe, ReturnProbe) \
2053 \
2054 JNI_ENTRY_NO_PRESERVE(void, jni_Set##Result##Field(JNIEnv *env, jobject obj, jfieldID fieldID, Argument value)) \
2055   JNIWrapper(&quot;Set&quot; XSTR(Result) &quot;Field&quot;); \
2056 \
2057   EntryProbe; \
2058 \
2059   oop o = JNIHandles::resolve_non_null(obj); \
2060   Klass* k = o-&gt;klass(); \
2061   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);  \
2062   /* Keep JVMTI addition small and only check enabled flag here.       */ \
2063   /* jni_SetField_probe_nh() assumes that is not okay to create handles */ \
2064   /* and creates a ResetNoHandleMark.                                   */ \
2065   if (JvmtiExport::should_post_field_modification()) { \
2066     jvalue field_value; \
2067     field_value.unionType = value; \
2068     o = JvmtiExport::jni_SetField_probe_nh(thread, obj, o, k, fieldID, false, SigType, (jvalue *)&amp;field_value); \
2069   } \
2070   if (SigType == JVM_SIGNATURE_BOOLEAN) { value = ((jboolean)value) &amp; 1; } \
2071   o-&gt;Fieldname##_field_put(offset, value); \
2072   ReturnProbe; \
2073 JNI_END
2074 
2075 DEFINE_SETFIELD(jboolean, bool,   Boolean, JVM_SIGNATURE_BOOLEAN, z
2076                 , HOTSPOT_JNI_SETBOOLEANFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2077                 HOTSPOT_JNI_SETBOOLEANFIELD_RETURN())
2078 DEFINE_SETFIELD(jbyte,    byte,   Byte,    JVM_SIGNATURE_BYTE, b
2079                 , HOTSPOT_JNI_SETBYTEFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2080                 HOTSPOT_JNI_SETBYTEFIELD_RETURN())
2081 DEFINE_SETFIELD(jchar,    char,   Char,    JVM_SIGNATURE_CHAR, c
2082                 , HOTSPOT_JNI_SETCHARFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2083                 HOTSPOT_JNI_SETCHARFIELD_RETURN())
2084 DEFINE_SETFIELD(jshort,   short,  Short,   JVM_SIGNATURE_SHORT, s
2085                 , HOTSPOT_JNI_SETSHORTFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2086                 HOTSPOT_JNI_SETSHORTFIELD_RETURN())
2087 DEFINE_SETFIELD(jint,     int,    Int,     JVM_SIGNATURE_INT, i
2088                 , HOTSPOT_JNI_SETINTFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2089                 HOTSPOT_JNI_SETINTFIELD_RETURN())
2090 DEFINE_SETFIELD(jlong,    long,   Long,    JVM_SIGNATURE_LONG, j
2091                 , HOTSPOT_JNI_SETLONGFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2092                 HOTSPOT_JNI_SETLONGFIELD_RETURN())
2093 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
2094 DEFINE_SETFIELD(jfloat,   float,  Float,   JVM_SIGNATURE_FLOAT, f
2095                 , HOTSPOT_JNI_SETFLOATFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2096                 HOTSPOT_JNI_SETFLOATFIELD_RETURN())
2097 DEFINE_SETFIELD(jdouble,  double, Double,  JVM_SIGNATURE_DOUBLE, d
2098                 , HOTSPOT_JNI_SETDOUBLEFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2099                 HOTSPOT_JNI_SETDOUBLEFIELD_RETURN())
2100 
2101 DT_RETURN_MARK_DECL(ToReflectedField, jobject
2102                     , HOTSPOT_JNI_TOREFLECTEDFIELD_RETURN(_ret_ref));
2103 
2104 JNI_ENTRY(jobject, jni_ToReflectedField(JNIEnv *env, jclass cls, jfieldID fieldID, jboolean isStatic))
2105   JNIWrapper(&quot;ToReflectedField&quot;);
2106   HOTSPOT_JNI_TOREFLECTEDFIELD_ENTRY(env, cls, (uintptr_t) fieldID, isStatic);
2107   jobject ret = NULL;
2108   DT_RETURN_MARK(ToReflectedField, jobject, (const jobject&amp;)ret);
2109 
2110   fieldDescriptor fd;
2111   bool found = false;
2112   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2113 
2114   assert(jfieldIDWorkaround::is_static_jfieldID(fieldID) == (isStatic != 0), &quot;invalid fieldID&quot;);
2115 
2116   if (isStatic) {
2117     // Static field. The fieldID a JNIid specifying the field holder and the offset within the Klass*.
2118     JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID);
2119     assert(id-&gt;is_static_field_id(), &quot;invalid static field id&quot;);
2120     found = id-&gt;find_local_field(&amp;fd);
2121   } else {
2122     // Non-static field. The fieldID is really the offset of the field within the instanceOop.
2123     int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);
2124     found = InstanceKlass::cast(k)-&gt;find_field_from_offset(offset, false, &amp;fd);
2125   }
2126   assert(found, &quot;bad fieldID passed into jni_ToReflectedField&quot;);
2127   oop reflected = Reflection::new_field(&amp;fd, CHECK_NULL);
2128   ret = JNIHandles::make_local(env, reflected);
2129   return ret;
2130 JNI_END
2131 
2132 
2133 //
2134 // Accessing Static Fields
2135 //
2136 DT_RETURN_MARK_DECL(GetStaticFieldID, jfieldID
2137                     , HOTSPOT_JNI_GETSTATICFIELDID_RETURN((uintptr_t)_ret_ref));
2138 
2139 JNI_ENTRY(jfieldID, jni_GetStaticFieldID(JNIEnv *env, jclass clazz,
2140           const char *name, const char *sig))
2141   JNIWrapper(&quot;GetStaticFieldID&quot;);
2142   HOTSPOT_JNI_GETSTATICFIELDID_ENTRY(env, clazz, (char *) name, (char *) sig);
2143   jfieldID ret = NULL;
2144   DT_RETURN_MARK(GetStaticFieldID, jfieldID, (const jfieldID&amp;)ret);
2145 
2146   // The class should have been loaded (we have an instance of the class
2147   // passed in) so the field and signature should already be in the symbol
2148   // table.  If they&#39;re not there, the field doesn&#39;t exist.
2149   TempNewSymbol fieldname = SymbolTable::probe(name, (int)strlen(name));
2150   TempNewSymbol signame = SymbolTable::probe(sig, (int)strlen(sig));
2151   if (fieldname == NULL || signame == NULL) {
2152     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), (char*) name);
2153   }
2154   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
2155   // Make sure class is initialized before handing id&#39;s out to static fields
2156   k-&gt;initialize(CHECK_NULL);
2157 
2158   fieldDescriptor fd;
2159   if (!k-&gt;is_instance_klass() ||
2160       !InstanceKlass::cast(k)-&gt;find_field(fieldname, signame, true, &amp;fd)) {
2161     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), (char*) name);
2162   }
2163 
2164   // A jfieldID for a static field is a JNIid specifying the field holder and the offset within the Klass*
2165   JNIid* id = fd.field_holder()-&gt;jni_id_for(fd.offset());
2166   debug_only(id-&gt;set_is_static_field_id();)
2167 
2168   debug_only(id-&gt;verify(fd.field_holder()));
2169 
2170   ret = jfieldIDWorkaround::to_static_jfieldID(id);
2171   return ret;
2172 JNI_END
2173 
2174 
2175 JNI_ENTRY(jobject, jni_GetStaticObjectField(JNIEnv *env, jclass clazz, jfieldID fieldID))
2176   JNIWrapper(&quot;GetStaticObjectField&quot;);
2177   HOTSPOT_JNI_GETSTATICOBJECTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID);
2178 #if INCLUDE_JNI_CHECK
2179   DEBUG_ONLY(Klass* param_k = jniCheck::validate_class(thread, clazz);)
2180 #endif // INCLUDE_JNI_CHECK
2181   JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID);
2182   assert(id-&gt;is_static_field_id(), &quot;invalid static field id&quot;);
2183   // Keep JVMTI addition small and only check enabled flag here.
2184   // jni_GetField_probe() assumes that is okay to create handles.
2185   if (JvmtiExport::should_post_field_access()) {
2186     JvmtiExport::jni_GetField_probe(thread, NULL, NULL, id-&gt;holder(), fieldID, true);
2187   }
2188   jobject ret = JNIHandles::make_local(id-&gt;holder()-&gt;java_mirror()-&gt;obj_field(id-&gt;offset()));
2189   HOTSPOT_JNI_GETSTATICOBJECTFIELD_RETURN(ret);
2190   return ret;
2191 JNI_END
2192 
2193 
2194 #define DEFINE_GETSTATICFIELD(Return,Fieldname,Result \
2195                               , EntryProbe, ReturnProbe) \
2196 \
2197   DT_RETURN_MARK_DECL_FOR(Result, GetStatic##Result##Field, Return \
2198                           , ReturnProbe);                                          \
2199 \
2200 JNI_ENTRY(Return, jni_GetStatic##Result##Field(JNIEnv *env, jclass clazz, jfieldID fieldID)) \
2201   JNIWrapper(&quot;GetStatic&quot; XSTR(Result) &quot;Field&quot;); \
2202   EntryProbe; \
2203   Return ret = 0;\
2204   DT_RETURN_MARK_FOR(Result, GetStatic##Result##Field, Return, \
2205                      (const Return&amp;)ret);\
2206   JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID); \
2207   assert(id-&gt;is_static_field_id(), &quot;invalid static field id&quot;); \
2208   /* Keep JVMTI addition small and only check enabled flag here. */ \
2209   /* jni_GetField_probe() assumes that is okay to create handles. */ \
2210   if (JvmtiExport::should_post_field_access()) { \
2211     JvmtiExport::jni_GetField_probe(thread, NULL, NULL, id-&gt;holder(), fieldID, true); \
2212   } \
2213   ret = id-&gt;holder()-&gt;java_mirror()-&gt; Fieldname##_field (id-&gt;offset()); \
2214   return ret;\
2215 JNI_END
2216 
2217 DEFINE_GETSTATICFIELD(jboolean, bool,   Boolean
2218                       , HOTSPOT_JNI_GETSTATICBOOLEANFIELD_ENTRY(env, clazz, (uintptr_t) fieldID), HOTSPOT_JNI_GETSTATICBOOLEANFIELD_RETURN(_ret_ref))
2219 DEFINE_GETSTATICFIELD(jbyte,    byte,   Byte
2220                       , HOTSPOT_JNI_GETSTATICBYTEFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),    HOTSPOT_JNI_GETSTATICBYTEFIELD_RETURN(_ret_ref)   )
2221 DEFINE_GETSTATICFIELD(jchar,    char,   Char
2222                       , HOTSPOT_JNI_GETSTATICCHARFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),    HOTSPOT_JNI_GETSTATICCHARFIELD_RETURN(_ret_ref)   )
2223 DEFINE_GETSTATICFIELD(jshort,   short,  Short
2224                       , HOTSPOT_JNI_GETSTATICSHORTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),   HOTSPOT_JNI_GETSTATICSHORTFIELD_RETURN(_ret_ref)  )
2225 DEFINE_GETSTATICFIELD(jint,     int,    Int
2226                       , HOTSPOT_JNI_GETSTATICINTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),     HOTSPOT_JNI_GETSTATICINTFIELD_RETURN(_ret_ref)    )
2227 DEFINE_GETSTATICFIELD(jlong,    long,   Long
2228                       , HOTSPOT_JNI_GETSTATICLONGFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),    HOTSPOT_JNI_GETSTATICLONGFIELD_RETURN(_ret_ref)   )
2229 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
2230 DEFINE_GETSTATICFIELD(jfloat,   float,  Float
2231                       , HOTSPOT_JNI_GETSTATICFLOATFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),   HOTSPOT_JNI_GETSTATICFLOATFIELD_RETURN()          )
2232 DEFINE_GETSTATICFIELD(jdouble,  double, Double
2233                       , HOTSPOT_JNI_GETSTATICDOUBLEFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),  HOTSPOT_JNI_GETSTATICDOUBLEFIELD_RETURN()         )
2234 
2235 JNI_ENTRY(void, jni_SetStaticObjectField(JNIEnv *env, jclass clazz, jfieldID fieldID, jobject value))
2236   JNIWrapper(&quot;SetStaticObjectField&quot;);
2237  HOTSPOT_JNI_SETSTATICOBJECTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value);
2238   JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID);
2239   assert(id-&gt;is_static_field_id(), &quot;invalid static field id&quot;);
2240   // Keep JVMTI addition small and only check enabled flag here.
2241   // jni_SetField_probe() assumes that is okay to create handles.
2242   if (JvmtiExport::should_post_field_modification()) {
2243     jvalue field_value;
2244     field_value.l = value;
2245     JvmtiExport::jni_SetField_probe(thread, NULL, NULL, id-&gt;holder(), fieldID, true, JVM_SIGNATURE_CLASS, (jvalue *)&amp;field_value);
2246   }
2247   id-&gt;holder()-&gt;java_mirror()-&gt;obj_field_put(id-&gt;offset(), JNIHandles::resolve(value));
2248   HOTSPOT_JNI_SETSTATICOBJECTFIELD_RETURN();
2249 JNI_END
2250 
2251 
2252 
2253 #define DEFINE_SETSTATICFIELD(Argument,Fieldname,Result,SigType,unionType \
2254                               , EntryProbe, ReturnProbe) \
2255 \
2256 JNI_ENTRY(void, jni_SetStatic##Result##Field(JNIEnv *env, jclass clazz, jfieldID fieldID, Argument value)) \
2257   JNIWrapper(&quot;SetStatic&quot; XSTR(Result) &quot;Field&quot;); \
2258   EntryProbe; \
2259 \
2260   JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID); \
2261   assert(id-&gt;is_static_field_id(), &quot;invalid static field id&quot;); \
2262   /* Keep JVMTI addition small and only check enabled flag here. */ \
2263   /* jni_SetField_probe() assumes that is okay to create handles. */ \
2264   if (JvmtiExport::should_post_field_modification()) { \
2265     jvalue field_value; \
2266     field_value.unionType = value; \
2267     JvmtiExport::jni_SetField_probe(thread, NULL, NULL, id-&gt;holder(), fieldID, true, SigType, (jvalue *)&amp;field_value); \
2268   } \
2269   if (SigType == JVM_SIGNATURE_BOOLEAN) { value = ((jboolean)value) &amp; 1; } \
2270   id-&gt;holder()-&gt;java_mirror()-&gt; Fieldname##_field_put (id-&gt;offset(), value); \
2271   ReturnProbe;\
2272 JNI_END
2273 
2274 DEFINE_SETSTATICFIELD(jboolean, bool,   Boolean, JVM_SIGNATURE_BOOLEAN, z
2275                       , HOTSPOT_JNI_SETSTATICBOOLEANFIELD_ENTRY(env, clazz, (uintptr_t)fieldID, value),
2276                       HOTSPOT_JNI_SETSTATICBOOLEANFIELD_RETURN())
2277 DEFINE_SETSTATICFIELD(jbyte,    byte,   Byte,    JVM_SIGNATURE_BYTE, b
2278                       , HOTSPOT_JNI_SETSTATICBYTEFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
2279                       HOTSPOT_JNI_SETSTATICBYTEFIELD_RETURN())
2280 DEFINE_SETSTATICFIELD(jchar,    char,   Char,    JVM_SIGNATURE_CHAR, c
2281                       , HOTSPOT_JNI_SETSTATICCHARFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
2282                       HOTSPOT_JNI_SETSTATICCHARFIELD_RETURN())
2283 DEFINE_SETSTATICFIELD(jshort,   short,  Short,   JVM_SIGNATURE_SHORT, s
2284                       , HOTSPOT_JNI_SETSTATICSHORTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
2285                       HOTSPOT_JNI_SETSTATICSHORTFIELD_RETURN())
2286 DEFINE_SETSTATICFIELD(jint,     int,    Int,     JVM_SIGNATURE_INT, i
2287                       , HOTSPOT_JNI_SETSTATICINTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
2288                       HOTSPOT_JNI_SETSTATICINTFIELD_RETURN())
2289 DEFINE_SETSTATICFIELD(jlong,    long,   Long,    JVM_SIGNATURE_LONG, j
2290                       , HOTSPOT_JNI_SETSTATICLONGFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
2291                       HOTSPOT_JNI_SETSTATICLONGFIELD_RETURN())
2292 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
2293 DEFINE_SETSTATICFIELD(jfloat,   float,  Float,   JVM_SIGNATURE_FLOAT, f
2294                       , HOTSPOT_JNI_SETSTATICFLOATFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),
2295                       HOTSPOT_JNI_SETSTATICFLOATFIELD_RETURN())
2296 DEFINE_SETSTATICFIELD(jdouble,  double, Double,  JVM_SIGNATURE_DOUBLE, d
2297                       , HOTSPOT_JNI_SETSTATICDOUBLEFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),
2298                       HOTSPOT_JNI_SETSTATICDOUBLEFIELD_RETURN())
2299 
2300 //
2301 // String Operations
2302 //
2303 
2304 // Unicode Interface
2305 
2306 DT_RETURN_MARK_DECL(NewString, jstring
2307                     , HOTSPOT_JNI_NEWSTRING_RETURN(_ret_ref));
2308 
2309 JNI_ENTRY(jstring, jni_NewString(JNIEnv *env, const jchar *unicodeChars, jsize len))
2310   JNIWrapper(&quot;NewString&quot;);
2311  HOTSPOT_JNI_NEWSTRING_ENTRY(env, (uint16_t *) unicodeChars, len);
2312   jstring ret = NULL;
2313   DT_RETURN_MARK(NewString, jstring, (const jstring&amp;)ret);
2314   oop string=java_lang_String::create_oop_from_unicode((jchar*) unicodeChars, len, CHECK_NULL);
2315   ret = (jstring) JNIHandles::make_local(env, string);
2316   return ret;
2317 JNI_END
2318 
2319 
2320 JNI_ENTRY_NO_PRESERVE(jsize, jni_GetStringLength(JNIEnv *env, jstring string))
2321   JNIWrapper(&quot;GetStringLength&quot;);
2322   HOTSPOT_JNI_GETSTRINGLENGTH_ENTRY(env, string);
2323   jsize ret = 0;
2324   oop s = JNIHandles::resolve_non_null(string);
2325   ret = java_lang_String::length(s);
2326  HOTSPOT_JNI_GETSTRINGLENGTH_RETURN(ret);
2327   return ret;
2328 JNI_END
2329 
2330 
2331 JNI_ENTRY_NO_PRESERVE(const jchar*, jni_GetStringChars(
2332   JNIEnv *env, jstring string, jboolean *isCopy))
2333   JNIWrapper(&quot;GetStringChars&quot;);
2334  HOTSPOT_JNI_GETSTRINGCHARS_ENTRY(env, string, (uintptr_t *) isCopy);
2335   jchar* buf = NULL;
2336   oop s = JNIHandles::resolve_non_null(string);
2337   typeArrayOop s_value = java_lang_String::value(s);
2338   if (s_value != NULL) {
2339     int s_len = java_lang_String::length(s, s_value);
2340     bool is_latin1 = java_lang_String::is_latin1(s);
2341     buf = NEW_C_HEAP_ARRAY_RETURN_NULL(jchar, s_len + 1, mtInternal);  // add one for zero termination
2342     /* JNI Specification states return NULL on OOM */
2343     if (buf != NULL) {
2344       if (s_len &gt; 0) {
2345         if (!is_latin1) {
2346           ArrayAccess&lt;&gt;::arraycopy_to_native(s_value, (size_t) typeArrayOopDesc::element_offset&lt;jchar&gt;(0),
2347                                              buf, s_len);
2348         } else {
2349           for (int i = 0; i &lt; s_len; i++) {
2350             buf[i] = ((jchar) s_value-&gt;byte_at(i)) &amp; 0xff;
2351           }
2352         }
2353       }
2354       buf[s_len] = 0;
2355       //%note jni_5
2356       if (isCopy != NULL) {
2357         *isCopy = JNI_TRUE;
2358       }
2359     }
2360   }
2361   HOTSPOT_JNI_GETSTRINGCHARS_RETURN(buf);
2362   return buf;
2363 JNI_END
2364 
2365 
2366 JNI_ENTRY_NO_PRESERVE(void, jni_ReleaseStringChars(JNIEnv *env, jstring str, const jchar *chars))
2367   JNIWrapper(&quot;ReleaseStringChars&quot;);
2368   HOTSPOT_JNI_RELEASESTRINGCHARS_ENTRY(env, str, (uint16_t *) chars);
2369   //%note jni_6
2370   if (chars != NULL) {
2371     // Since String objects are supposed to be immutable, don&#39;t copy any
2372     // new data back.  A bad user will have to go after the char array.
2373     FreeHeap((void*) chars);
2374   }
2375   HOTSPOT_JNI_RELEASESTRINGCHARS_RETURN();
2376 JNI_END
2377 
2378 
2379 // UTF Interface
2380 
2381 DT_RETURN_MARK_DECL(NewStringUTF, jstring
2382                     , HOTSPOT_JNI_NEWSTRINGUTF_RETURN(_ret_ref));
2383 
2384 JNI_ENTRY(jstring, jni_NewStringUTF(JNIEnv *env, const char *bytes))
2385   JNIWrapper(&quot;NewStringUTF&quot;);
2386   HOTSPOT_JNI_NEWSTRINGUTF_ENTRY(env, (char *) bytes);
2387   jstring ret;
2388   DT_RETURN_MARK(NewStringUTF, jstring, (const jstring&amp;)ret);
2389 
2390   oop result = java_lang_String::create_oop_from_str((char*) bytes, CHECK_NULL);
2391   ret = (jstring) JNIHandles::make_local(env, result);
2392   return ret;
2393 JNI_END
2394 
2395 
2396 JNI_ENTRY(jsize, jni_GetStringUTFLength(JNIEnv *env, jstring string))
2397   JNIWrapper(&quot;GetStringUTFLength&quot;);
2398  HOTSPOT_JNI_GETSTRINGUTFLENGTH_ENTRY(env, string);
2399   oop java_string = JNIHandles::resolve_non_null(string);
2400   jsize ret = java_lang_String::utf8_length(java_string);
2401   HOTSPOT_JNI_GETSTRINGUTFLENGTH_RETURN(ret);
2402   return ret;
2403 JNI_END
2404 
2405 
2406 JNI_ENTRY(const char*, jni_GetStringUTFChars(JNIEnv *env, jstring string, jboolean *isCopy))
2407   JNIWrapper(&quot;GetStringUTFChars&quot;);
2408  HOTSPOT_JNI_GETSTRINGUTFCHARS_ENTRY(env, string, (uintptr_t *) isCopy);
2409   char* result = NULL;
2410   oop java_string = JNIHandles::resolve_non_null(string);
2411   typeArrayOop s_value = java_lang_String::value(java_string);
2412   if (s_value != NULL) {
2413     size_t length = java_lang_String::utf8_length(java_string, s_value);
2414     /* JNI Specification states return NULL on OOM */
2415     result = AllocateHeap(length + 1, mtInternal, 0, AllocFailStrategy::RETURN_NULL);
2416     if (result != NULL) {
2417       java_lang_String::as_utf8_string(java_string, s_value, result, (int) length + 1);
2418       if (isCopy != NULL) {
2419         *isCopy = JNI_TRUE;
2420       }
2421     }
2422   }
2423  HOTSPOT_JNI_GETSTRINGUTFCHARS_RETURN(result);
2424   return result;
2425 JNI_END
2426 
2427 
2428 JNI_LEAF(void, jni_ReleaseStringUTFChars(JNIEnv *env, jstring str, const char *chars))
2429   JNIWrapper(&quot;ReleaseStringUTFChars&quot;);
2430  HOTSPOT_JNI_RELEASESTRINGUTFCHARS_ENTRY(env, str, (char *) chars);
2431   if (chars != NULL) {
2432     FreeHeap((char*) chars);
2433   }
2434 HOTSPOT_JNI_RELEASESTRINGUTFCHARS_RETURN();
2435 JNI_END
2436 
2437 
2438 JNI_ENTRY_NO_PRESERVE(jsize, jni_GetArrayLength(JNIEnv *env, jarray array))
2439   JNIWrapper(&quot;GetArrayLength&quot;);
2440  HOTSPOT_JNI_GETARRAYLENGTH_ENTRY(env, array);
2441   arrayOop a = arrayOop(JNIHandles::resolve_non_null(array));
2442   assert(a-&gt;is_array(), &quot;must be array&quot;);
2443   jsize ret = a-&gt;length();
2444  HOTSPOT_JNI_GETARRAYLENGTH_RETURN(ret);
2445   return ret;
2446 JNI_END
2447 
2448 
2449 //
2450 // Object Array Operations
2451 //
2452 
2453 DT_RETURN_MARK_DECL(NewObjectArray, jobjectArray
2454                     , HOTSPOT_JNI_NEWOBJECTARRAY_RETURN(_ret_ref));
2455 
2456 JNI_ENTRY(jobjectArray, jni_NewObjectArray(JNIEnv *env, jsize length, jclass elementClass, jobject initialElement))
2457   JNIWrapper(&quot;NewObjectArray&quot;);
2458  HOTSPOT_JNI_NEWOBJECTARRAY_ENTRY(env, length, elementClass, initialElement);
2459   jobjectArray ret = NULL;
2460   DT_RETURN_MARK(NewObjectArray, jobjectArray, (const jobjectArray&amp;)ret);
2461   Klass* ek = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(elementClass));
2462   Klass* ak = ek-&gt;array_klass(CHECK_NULL);
2463   ObjArrayKlass::cast(ak)-&gt;initialize(CHECK_NULL);
2464   objArrayOop result = ObjArrayKlass::cast(ak)-&gt;allocate(length, CHECK_NULL);
2465   oop initial_value = JNIHandles::resolve(initialElement);
2466   if (initial_value != NULL) {  // array already initialized with NULL
2467     for (int index = 0; index &lt; length; index++) {
2468       result-&gt;obj_at_put(index, initial_value);
2469     }
2470   }
2471   ret = (jobjectArray) JNIHandles::make_local(env, result);
2472   return ret;
2473 JNI_END
2474 
2475 DT_RETURN_MARK_DECL(GetObjectArrayElement, jobject
2476                     , HOTSPOT_JNI_GETOBJECTARRAYELEMENT_RETURN(_ret_ref));
2477 
2478 JNI_ENTRY(jobject, jni_GetObjectArrayElement(JNIEnv *env, jobjectArray array, jsize index))
2479   JNIWrapper(&quot;GetObjectArrayElement&quot;);
2480  HOTSPOT_JNI_GETOBJECTARRAYELEMENT_ENTRY(env, array, index);
2481   jobject ret = NULL;
2482   DT_RETURN_MARK(GetObjectArrayElement, jobject, (const jobject&amp;)ret);
2483   objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));
2484   if (a-&gt;is_within_bounds(index)) {
2485     ret = JNIHandles::make_local(env, a-&gt;obj_at(index));
2486     return ret;
2487   } else {
2488     ResourceMark rm(THREAD);
2489     stringStream ss;
2490     ss.print(&quot;Index %d out of bounds for length %d&quot;, index, a-&gt;length());
2491     THROW_MSG_0(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());
2492   }
2493 JNI_END
2494 
2495 DT_VOID_RETURN_MARK_DECL(SetObjectArrayElement
2496                          , HOTSPOT_JNI_SETOBJECTARRAYELEMENT_RETURN());
2497 
2498 JNI_ENTRY(void, jni_SetObjectArrayElement(JNIEnv *env, jobjectArray array, jsize index, jobject value))
2499   JNIWrapper(&quot;SetObjectArrayElement&quot;);
2500  HOTSPOT_JNI_SETOBJECTARRAYELEMENT_ENTRY(env, array, index, value);
2501   DT_VOID_RETURN_MARK(SetObjectArrayElement);
2502 
2503   objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));
2504   oop v = JNIHandles::resolve(value);
2505   if (a-&gt;is_within_bounds(index)) {
2506     if (v == NULL || v-&gt;is_a(ObjArrayKlass::cast(a-&gt;klass())-&gt;element_klass())) {
2507       a-&gt;obj_at_put(index, v);
2508     } else {
2509       ResourceMark rm(THREAD);
2510       stringStream ss;
2511       Klass *bottom_kl = ObjArrayKlass::cast(a-&gt;klass())-&gt;bottom_klass();
2512       ss.print(&quot;type mismatch: can not store %s to %s[%d]&quot;,
2513                v-&gt;klass()-&gt;external_name(),
2514                bottom_kl-&gt;is_typeArray_klass() ? type2name_tab[ArrayKlass::cast(bottom_kl)-&gt;element_type()] : bottom_kl-&gt;external_name(),
2515                index);
2516       for (int dims = ArrayKlass::cast(a-&gt;klass())-&gt;dimension(); dims &gt; 1; --dims) {
2517         ss.print(&quot;[]&quot;);
2518       }
2519       THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), ss.as_string());
2520     }
2521   } else {
2522     ResourceMark rm(THREAD);
2523     stringStream ss;
2524     ss.print(&quot;Index %d out of bounds for length %d&quot;, index, a-&gt;length());
2525     THROW_MSG(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());
2526   }
2527 JNI_END
2528 
2529 
2530 
2531 #define DEFINE_NEWSCALARARRAY(Return,Allocator,Result \
2532                               ,EntryProbe,ReturnProbe)  \
2533 \
2534   DT_RETURN_MARK_DECL(New##Result##Array, Return \
2535                       , ReturnProbe); \
2536 \
2537 JNI_ENTRY(Return, \
2538           jni_New##Result##Array(JNIEnv *env, jsize len)) \
2539   JNIWrapper(&quot;New&quot; XSTR(Result) &quot;Array&quot;); \
2540   EntryProbe; \
2541   Return ret = NULL;\
2542   DT_RETURN_MARK(New##Result##Array, Return, (const Return&amp;)ret);\
2543 \
2544   oop obj= oopFactory::Allocator(len, CHECK_NULL); \
2545   ret = (Return) JNIHandles::make_local(env, obj); \
2546   return ret;\
2547 JNI_END
2548 
2549 DEFINE_NEWSCALARARRAY(jbooleanArray, new_boolArray,   Boolean,
2550                       HOTSPOT_JNI_NEWBOOLEANARRAY_ENTRY(env, len),
2551                       HOTSPOT_JNI_NEWBOOLEANARRAY_RETURN(_ret_ref))
2552 DEFINE_NEWSCALARARRAY(jbyteArray,    new_byteArray,   Byte,
2553                       HOTSPOT_JNI_NEWBYTEARRAY_ENTRY(env, len),
2554                       HOTSPOT_JNI_NEWBYTEARRAY_RETURN(_ret_ref))
2555 DEFINE_NEWSCALARARRAY(jshortArray,   new_shortArray,  Short,
2556                       HOTSPOT_JNI_NEWSHORTARRAY_ENTRY(env, len),
2557                       HOTSPOT_JNI_NEWSHORTARRAY_RETURN(_ret_ref))
2558 DEFINE_NEWSCALARARRAY(jcharArray,    new_charArray,   Char,
2559                       HOTSPOT_JNI_NEWCHARARRAY_ENTRY(env, len),
2560                       HOTSPOT_JNI_NEWCHARARRAY_RETURN(_ret_ref))
2561 DEFINE_NEWSCALARARRAY(jintArray,     new_intArray,    Int,
2562                       HOTSPOT_JNI_NEWINTARRAY_ENTRY(env, len),
2563                       HOTSPOT_JNI_NEWINTARRAY_RETURN(_ret_ref))
2564 DEFINE_NEWSCALARARRAY(jlongArray,    new_longArray,   Long,
2565                       HOTSPOT_JNI_NEWLONGARRAY_ENTRY(env, len),
2566                       HOTSPOT_JNI_NEWLONGARRAY_RETURN(_ret_ref))
2567 DEFINE_NEWSCALARARRAY(jfloatArray,   new_floatArray,  Float,
2568                       HOTSPOT_JNI_NEWFLOATARRAY_ENTRY(env, len),
2569                       HOTSPOT_JNI_NEWFLOATARRAY_RETURN(_ret_ref))
2570 DEFINE_NEWSCALARARRAY(jdoubleArray,  new_doubleArray, Double,
2571                       HOTSPOT_JNI_NEWDOUBLEARRAY_ENTRY(env, len),
2572                       HOTSPOT_JNI_NEWDOUBLEARRAY_RETURN(_ret_ref))
2573 
2574 // Return an address which will fault if the caller writes to it.
2575 
2576 static char* get_bad_address() {
2577   static char* bad_address = NULL;
2578   if (bad_address == NULL) {
2579     size_t size = os::vm_allocation_granularity();
2580     bad_address = os::reserve_memory(size);
2581     if (bad_address != NULL) {
2582       os::protect_memory(bad_address, size, os::MEM_PROT_READ,
2583                          /*is_committed*/false);
2584       MemTracker::record_virtual_memory_type((void*)bad_address, mtInternal);
2585     }
2586   }
2587   return bad_address;
2588 }
2589 
2590 
2591 
2592 #define DEFINE_GETSCALARARRAYELEMENTS(ElementTag,ElementType,Result, Tag \
2593                                       , EntryProbe, ReturnProbe) \
2594 \
2595 JNI_ENTRY_NO_PRESERVE(ElementType*, \
2596           jni_Get##Result##ArrayElements(JNIEnv *env, ElementType##Array array, jboolean *isCopy)) \
2597   JNIWrapper(&quot;Get&quot; XSTR(Result) &quot;ArrayElements&quot;); \
2598   EntryProbe; \
2599   /* allocate an chunk of memory in c land */ \
2600   typeArrayOop a = typeArrayOop(JNIHandles::resolve_non_null(array)); \
2601   ElementType* result; \
2602   int len = a-&gt;length(); \
2603   if (len == 0) { \
2604     if (isCopy != NULL) { \
2605       *isCopy = JNI_FALSE; \
2606     } \
2607     /* Empty array: legal but useless, can&#39;t return NULL. \
2608      * Return a pointer to something useless. \
2609      * Avoid asserts in typeArrayOop. */ \
2610     result = (ElementType*)get_bad_address(); \
2611   } else { \
2612     /* JNI Specification states return NULL on OOM */                    \
2613     result = NEW_C_HEAP_ARRAY_RETURN_NULL(ElementType, len, mtInternal); \
2614     if (result != NULL) {                                                \
2615       /* copy the array to the c chunk */                                \
2616       ArrayAccess&lt;&gt;::arraycopy_to_native(a, typeArrayOopDesc::element_offset&lt;ElementType&gt;(0), \
2617                                          result, len);                   \
2618       if (isCopy) {                                                      \
2619         *isCopy = JNI_TRUE;                                              \
2620       }                                                                  \
2621     }                                                                    \
2622   } \
2623   ReturnProbe; \
2624   return result; \
2625 JNI_END
2626 
2627 DEFINE_GETSCALARARRAYELEMENTS(T_BOOLEAN, jboolean, Boolean, bool
2628                               , HOTSPOT_JNI_GETBOOLEANARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2629                               HOTSPOT_JNI_GETBOOLEANARRAYELEMENTS_RETURN((uintptr_t*)result))
2630 DEFINE_GETSCALARARRAYELEMENTS(T_BYTE,    jbyte,    Byte,    byte
2631                               , HOTSPOT_JNI_GETBYTEARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2632                               HOTSPOT_JNI_GETBYTEARRAYELEMENTS_RETURN((char*)result))
2633 DEFINE_GETSCALARARRAYELEMENTS(T_SHORT,   jshort,   Short,   short
2634                               , HOTSPOT_JNI_GETSHORTARRAYELEMENTS_ENTRY(env, (uint16_t*) array, (uintptr_t *) isCopy),
2635                               HOTSPOT_JNI_GETSHORTARRAYELEMENTS_RETURN((uint16_t*)result))
2636 DEFINE_GETSCALARARRAYELEMENTS(T_CHAR,    jchar,    Char,    char
2637                               , HOTSPOT_JNI_GETCHARARRAYELEMENTS_ENTRY(env, (uint16_t*) array, (uintptr_t *) isCopy),
2638                               HOTSPOT_JNI_GETCHARARRAYELEMENTS_RETURN(result))
2639 DEFINE_GETSCALARARRAYELEMENTS(T_INT,     jint,     Int,     int
2640                               , HOTSPOT_JNI_GETINTARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2641                               HOTSPOT_JNI_GETINTARRAYELEMENTS_RETURN((uint32_t*)result))
2642 DEFINE_GETSCALARARRAYELEMENTS(T_LONG,    jlong,    Long,    long
2643                               , HOTSPOT_JNI_GETLONGARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2644                               HOTSPOT_JNI_GETLONGARRAYELEMENTS_RETURN(((uintptr_t*)result)))
2645 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
2646 DEFINE_GETSCALARARRAYELEMENTS(T_FLOAT,   jfloat,   Float,   float
2647                               , HOTSPOT_JNI_GETFLOATARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2648                               HOTSPOT_JNI_GETFLOATARRAYELEMENTS_RETURN(result))
2649 DEFINE_GETSCALARARRAYELEMENTS(T_DOUBLE,  jdouble,  Double,  double
2650                               , HOTSPOT_JNI_GETDOUBLEARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2651                               HOTSPOT_JNI_GETDOUBLEARRAYELEMENTS_RETURN(result))
2652 
2653 
2654 #define DEFINE_RELEASESCALARARRAYELEMENTS(ElementTag,ElementType,Result,Tag \
2655                                           , EntryProbe, ReturnProbe);\
2656 \
2657 JNI_ENTRY_NO_PRESERVE(void, \
2658           jni_Release##Result##ArrayElements(JNIEnv *env, ElementType##Array array, \
2659                                              ElementType *buf, jint mode)) \
2660   JNIWrapper(&quot;Release&quot; XSTR(Result) &quot;ArrayElements&quot;); \
2661   EntryProbe; \
2662   typeArrayOop a = typeArrayOop(JNIHandles::resolve_non_null(array)); \
2663   int len = a-&gt;length(); \
2664   if (len != 0) {   /* Empty array:  nothing to free or copy. */  \
2665     if ((mode == 0) || (mode == JNI_COMMIT)) { \
2666       ArrayAccess&lt;&gt;::arraycopy_from_native(buf, a, typeArrayOopDesc::element_offset&lt;ElementType&gt;(0), len); \
2667     } \
2668     if ((mode == 0) || (mode == JNI_ABORT)) { \
2669       FreeHeap(buf); \
2670     } \
2671   } \
2672   ReturnProbe; \
2673 JNI_END
2674 
2675 DEFINE_RELEASESCALARARRAYELEMENTS(T_BOOLEAN, jboolean, Boolean, bool
2676                                   , HOTSPOT_JNI_RELEASEBOOLEANARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) buf, mode),
2677                                   HOTSPOT_JNI_RELEASEBOOLEANARRAYELEMENTS_RETURN())
2678 DEFINE_RELEASESCALARARRAYELEMENTS(T_BYTE,    jbyte,    Byte,    byte
2679                                   , HOTSPOT_JNI_RELEASEBYTEARRAYELEMENTS_ENTRY(env, array, (char *) buf, mode),
2680                                   HOTSPOT_JNI_RELEASEBYTEARRAYELEMENTS_RETURN())
2681 DEFINE_RELEASESCALARARRAYELEMENTS(T_SHORT,   jshort,   Short,   short
2682                                   ,  HOTSPOT_JNI_RELEASESHORTARRAYELEMENTS_ENTRY(env, array, (uint16_t *) buf, mode),
2683                                   HOTSPOT_JNI_RELEASESHORTARRAYELEMENTS_RETURN())
2684 DEFINE_RELEASESCALARARRAYELEMENTS(T_CHAR,    jchar,    Char,    char
2685                                   ,  HOTSPOT_JNI_RELEASECHARARRAYELEMENTS_ENTRY(env, array, (uint16_t *) buf, mode),
2686                                   HOTSPOT_JNI_RELEASECHARARRAYELEMENTS_RETURN())
2687 DEFINE_RELEASESCALARARRAYELEMENTS(T_INT,     jint,     Int,     int
2688                                   , HOTSPOT_JNI_RELEASEINTARRAYELEMENTS_ENTRY(env, array, (uint32_t *) buf, mode),
2689                                   HOTSPOT_JNI_RELEASEINTARRAYELEMENTS_RETURN())
2690 DEFINE_RELEASESCALARARRAYELEMENTS(T_LONG,    jlong,    Long,    long
2691                                   , HOTSPOT_JNI_RELEASELONGARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) buf, mode),
2692                                   HOTSPOT_JNI_RELEASELONGARRAYELEMENTS_RETURN())
2693 DEFINE_RELEASESCALARARRAYELEMENTS(T_FLOAT,   jfloat,   Float,   float
2694                                   , HOTSPOT_JNI_RELEASEFLOATARRAYELEMENTS_ENTRY(env, array, (float *) buf, mode),
2695                                   HOTSPOT_JNI_RELEASEFLOATARRAYELEMENTS_RETURN())
2696 DEFINE_RELEASESCALARARRAYELEMENTS(T_DOUBLE,  jdouble,  Double,  double
2697                                   , HOTSPOT_JNI_RELEASEDOUBLEARRAYELEMENTS_ENTRY(env, array, (double *) buf, mode),
2698                                   HOTSPOT_JNI_RELEASEDOUBLEARRAYELEMENTS_RETURN())
2699 
2700 static void check_bounds(jsize start, jsize copy_len, jsize array_len, TRAPS) {
2701   ResourceMark rm(THREAD);
2702   if (copy_len &lt; 0) {
2703     stringStream ss;
2704     ss.print(&quot;Length %d is negative&quot;, copy_len);
2705     THROW_MSG(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());
2706   } else if (start &lt; 0 || (start &gt; array_len - copy_len)) {
2707     stringStream ss;
2708     ss.print(&quot;Array region %d..&quot; INT64_FORMAT &quot; out of bounds for length %d&quot;,
2709              start, (int64_t)start+(int64_t)copy_len, array_len);
2710     THROW_MSG(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());
2711   }
2712 }
2713 
2714 #define DEFINE_GETSCALARARRAYREGION(ElementTag,ElementType,Result, Tag \
2715                                     , EntryProbe, ReturnProbe); \
2716   DT_VOID_RETURN_MARK_DECL(Get##Result##ArrayRegion \
2717                            , ReturnProbe); \
2718 \
2719 JNI_ENTRY(void, \
2720 jni_Get##Result##ArrayRegion(JNIEnv *env, ElementType##Array array, jsize start, \
2721              jsize len, ElementType *buf)) \
2722   JNIWrapper(&quot;Get&quot; XSTR(Result) &quot;ArrayRegion&quot;); \
2723   EntryProbe; \
2724   DT_VOID_RETURN_MARK(Get##Result##ArrayRegion); \
2725   typeArrayOop src = typeArrayOop(JNIHandles::resolve_non_null(array)); \
2726   check_bounds(start, len, src-&gt;length(), CHECK); \
2727   if (len &gt; 0) {    \
2728     ArrayAccess&lt;&gt;::arraycopy_to_native(src, typeArrayOopDesc::element_offset&lt;ElementType&gt;(start), buf, len); \
2729   } \
2730 JNI_END
2731 
2732 DEFINE_GETSCALARARRAYREGION(T_BOOLEAN, jboolean,Boolean, bool
2733                             , HOTSPOT_JNI_GETBOOLEANARRAYREGION_ENTRY(env, array, start, len, (uintptr_t *) buf),
2734                             HOTSPOT_JNI_GETBOOLEANARRAYREGION_RETURN());
2735 DEFINE_GETSCALARARRAYREGION(T_BYTE,    jbyte,   Byte,    byte
2736                             ,  HOTSPOT_JNI_GETBYTEARRAYREGION_ENTRY(env, array, start, len, (char *) buf),
2737                             HOTSPOT_JNI_GETBYTEARRAYREGION_RETURN());
2738 DEFINE_GETSCALARARRAYREGION(T_SHORT,   jshort,  Short,   short
2739                             , HOTSPOT_JNI_GETSHORTARRAYREGION_ENTRY(env, array, start, len, (uint16_t *) buf),
2740                             HOTSPOT_JNI_GETSHORTARRAYREGION_RETURN());
2741 DEFINE_GETSCALARARRAYREGION(T_CHAR,    jchar,   Char,    char
2742                             ,  HOTSPOT_JNI_GETCHARARRAYREGION_ENTRY(env, array, start, len, (uint16_t*) buf),
2743                             HOTSPOT_JNI_GETCHARARRAYREGION_RETURN());
2744 DEFINE_GETSCALARARRAYREGION(T_INT,     jint,    Int,     int
2745                             , HOTSPOT_JNI_GETINTARRAYREGION_ENTRY(env, array, start, len, (uint32_t*) buf),
2746                             HOTSPOT_JNI_GETINTARRAYREGION_RETURN());
2747 DEFINE_GETSCALARARRAYREGION(T_LONG,    jlong,   Long,    long
2748                             ,  HOTSPOT_JNI_GETLONGARRAYREGION_ENTRY(env, array, start, len, (uintptr_t *) buf),
2749                             HOTSPOT_JNI_GETLONGARRAYREGION_RETURN());
2750 DEFINE_GETSCALARARRAYREGION(T_FLOAT,   jfloat,  Float,   float
2751                             , HOTSPOT_JNI_GETFLOATARRAYREGION_ENTRY(env, array, start, len, (float *) buf),
2752                             HOTSPOT_JNI_GETFLOATARRAYREGION_RETURN());
2753 DEFINE_GETSCALARARRAYREGION(T_DOUBLE,  jdouble, Double,  double
2754                             , HOTSPOT_JNI_GETDOUBLEARRAYREGION_ENTRY(env, array, start, len, (double *) buf),
2755                             HOTSPOT_JNI_GETDOUBLEARRAYREGION_RETURN());
2756 
2757 
2758 #define DEFINE_SETSCALARARRAYREGION(ElementTag,ElementType,Result, Tag \
2759                                     , EntryProbe, ReturnProbe); \
2760   DT_VOID_RETURN_MARK_DECL(Set##Result##ArrayRegion \
2761                            ,ReturnProbe);           \
2762 \
2763 JNI_ENTRY(void, \
2764 jni_Set##Result##ArrayRegion(JNIEnv *env, ElementType##Array array, jsize start, \
2765              jsize len, const ElementType *buf)) \
2766   JNIWrapper(&quot;Set&quot; XSTR(Result) &quot;ArrayRegion&quot;); \
2767   EntryProbe; \
2768   DT_VOID_RETURN_MARK(Set##Result##ArrayRegion); \
2769   typeArrayOop dst = typeArrayOop(JNIHandles::resolve_non_null(array)); \
2770   check_bounds(start, len, dst-&gt;length(), CHECK); \
2771   if (len &gt; 0) { \
2772     ArrayAccess&lt;&gt;::arraycopy_from_native(buf, dst, typeArrayOopDesc::element_offset&lt;ElementType&gt;(start), len); \
2773   } \
2774 JNI_END
2775 
2776 DEFINE_SETSCALARARRAYREGION(T_BOOLEAN, jboolean, Boolean, bool
2777                             , HOTSPOT_JNI_SETBOOLEANARRAYREGION_ENTRY(env, array, start, len, (uintptr_t *)buf),
2778                             HOTSPOT_JNI_SETBOOLEANARRAYREGION_RETURN())
2779 DEFINE_SETSCALARARRAYREGION(T_BYTE,    jbyte,    Byte,    byte
2780                             , HOTSPOT_JNI_SETBYTEARRAYREGION_ENTRY(env, array, start, len, (char *) buf),
2781                             HOTSPOT_JNI_SETBYTEARRAYREGION_RETURN())
2782 DEFINE_SETSCALARARRAYREGION(T_SHORT,   jshort,   Short,   short
2783                             , HOTSPOT_JNI_SETSHORTARRAYREGION_ENTRY(env, array, start, len, (uint16_t *) buf),
2784                             HOTSPOT_JNI_SETSHORTARRAYREGION_RETURN())
2785 DEFINE_SETSCALARARRAYREGION(T_CHAR,    jchar,    Char,    char
2786                             , HOTSPOT_JNI_SETCHARARRAYREGION_ENTRY(env, array, start, len, (uint16_t *) buf),
2787                             HOTSPOT_JNI_SETCHARARRAYREGION_RETURN())
2788 DEFINE_SETSCALARARRAYREGION(T_INT,     jint,     Int,     int
2789                             , HOTSPOT_JNI_SETINTARRAYREGION_ENTRY(env, array, start, len, (uint32_t *) buf),
2790                             HOTSPOT_JNI_SETINTARRAYREGION_RETURN())
2791 DEFINE_SETSCALARARRAYREGION(T_LONG,    jlong,    Long,    long
2792                             , HOTSPOT_JNI_SETLONGARRAYREGION_ENTRY(env, array, start, len, (uintptr_t *) buf),
2793                             HOTSPOT_JNI_SETLONGARRAYREGION_RETURN())
2794 DEFINE_SETSCALARARRAYREGION(T_FLOAT,   jfloat,   Float,   float
2795                             , HOTSPOT_JNI_SETFLOATARRAYREGION_ENTRY(env, array, start, len, (float *) buf),
2796                             HOTSPOT_JNI_SETFLOATARRAYREGION_RETURN())
2797 DEFINE_SETSCALARARRAYREGION(T_DOUBLE,  jdouble,  Double,  double
2798                             , HOTSPOT_JNI_SETDOUBLEARRAYREGION_ENTRY(env, array, start, len, (double *) buf),
2799                             HOTSPOT_JNI_SETDOUBLEARRAYREGION_RETURN())
2800 
2801 
2802 DT_RETURN_MARK_DECL(RegisterNatives, jint
2803                     , HOTSPOT_JNI_REGISTERNATIVES_RETURN(_ret_ref));
2804 
2805 JNI_ENTRY(jint, jni_RegisterNatives(JNIEnv *env, jclass clazz,
2806                                     const JNINativeMethod *methods,
2807                                     jint nMethods))
2808   JNIWrapper(&quot;RegisterNatives&quot;);
2809   HOTSPOT_JNI_REGISTERNATIVES_ENTRY(env, clazz, (void *) methods, nMethods);
2810   jint ret = 0;
2811   DT_RETURN_MARK(RegisterNatives, jint, (const jint&amp;)ret);
2812 
2813   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
2814 
2815   // There are no restrictions on native code registering native methods,
2816   // which allows agents to redefine the bindings to native methods, however
2817   // we issue a warning if any code running outside of the boot/platform
2818   // loader is rebinding any native methods in classes loaded by the
2819   // boot/platform loader that are in named modules. That will catch changes
2820   // to platform classes while excluding classes added to the bootclasspath.
2821   bool do_warning = false;
2822 
2823   // Only instanceKlasses can have native methods
2824   if (k-&gt;is_instance_klass()) {
2825     oop cl = k-&gt;class_loader();
2826     InstanceKlass* ik = InstanceKlass::cast(k);
2827     // Check for a platform class
2828     if ((cl ==  NULL || SystemDictionary::is_platform_class_loader(cl)) &amp;&amp;
2829         ik-&gt;module()-&gt;is_named()) {
2830       Klass* caller = thread-&gt;security_get_caller_class(1);
2831       // If no caller class, or caller class has a different loader, then
2832       // issue a warning below.
2833       do_warning = (caller == NULL) || caller-&gt;class_loader() != cl;
2834     }
2835   }
2836 
2837 
2838   for (int index = 0; index &lt; nMethods; index++) {
2839     const char* meth_name = methods[index].name;
2840     const char* meth_sig = methods[index].signature;
2841     int meth_name_len = (int)strlen(meth_name);
2842 
2843     // The class should have been loaded (we have an instance of the class
2844     // passed in) so the method and signature should already be in the symbol
2845     // table.  If they&#39;re not there, the method doesn&#39;t exist.
2846     TempNewSymbol  name = SymbolTable::probe(meth_name, meth_name_len);
2847     TempNewSymbol  signature = SymbolTable::probe(meth_sig, (int)strlen(meth_sig));
2848 
2849     if (name == NULL || signature == NULL) {
2850       ResourceMark rm(THREAD);
2851       stringStream st;
2852       st.print(&quot;Method %s.%s%s not found&quot;, k-&gt;external_name(), meth_name, meth_sig);
2853       // Must return negative value on failure
2854       THROW_MSG_(vmSymbols::java_lang_NoSuchMethodError(), st.as_string(), -1);
2855     }
2856 
2857     if (do_warning) {
2858       ResourceMark rm(THREAD);
2859       log_warning(jni, resolve)(&quot;Re-registering of platform native method: %s.%s%s &quot;
2860               &quot;from code in a different classloader&quot;, k-&gt;external_name(), meth_name, meth_sig);
2861     }
2862 
2863     bool res = Method::register_native(k, name, signature,
2864                                        (address) methods[index].fnPtr, THREAD);
2865     if (!res) {
2866       ret = -1;
2867       break;
2868     }
2869   }
2870   return ret;
2871 JNI_END
2872 
2873 
2874 JNI_ENTRY(jint, jni_UnregisterNatives(JNIEnv *env, jclass clazz))
2875   JNIWrapper(&quot;UnregisterNatives&quot;);
2876  HOTSPOT_JNI_UNREGISTERNATIVES_ENTRY(env, clazz);
2877   Klass* k   = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
2878   //%note jni_2
2879   if (k-&gt;is_instance_klass()) {
2880     for (int index = 0; index &lt; InstanceKlass::cast(k)-&gt;methods()-&gt;length(); index++) {
2881       Method* m = InstanceKlass::cast(k)-&gt;methods()-&gt;at(index);
2882       if (m-&gt;is_native()) {
2883         m-&gt;clear_native_function();
2884         m-&gt;set_signature_handler(NULL);
2885       }
2886     }
2887   }
2888  HOTSPOT_JNI_UNREGISTERNATIVES_RETURN(0);
2889   return 0;
2890 JNI_END
2891 
2892 //
2893 // Monitor functions
2894 //
2895 
2896 DT_RETURN_MARK_DECL(MonitorEnter, jint
2897                     , HOTSPOT_JNI_MONITORENTER_RETURN(_ret_ref));
2898 
2899 JNI_ENTRY(jint, jni_MonitorEnter(JNIEnv *env, jobject jobj))
2900  HOTSPOT_JNI_MONITORENTER_ENTRY(env, jobj);
2901   jint ret = JNI_ERR;
2902   DT_RETURN_MARK(MonitorEnter, jint, (const jint&amp;)ret);
2903 
2904   // If the object is null, we can&#39;t do anything with it
2905   if (jobj == NULL) {
2906     THROW_(vmSymbols::java_lang_NullPointerException(), JNI_ERR);
2907   }
2908 
2909   Handle obj(thread, JNIHandles::resolve_non_null(jobj));
2910   ObjectSynchronizer::jni_enter(obj, CHECK_(JNI_ERR));
2911   ret = JNI_OK;
2912   return ret;
2913 JNI_END
2914 
2915 DT_RETURN_MARK_DECL(MonitorExit, jint
2916                     , HOTSPOT_JNI_MONITOREXIT_RETURN(_ret_ref));
2917 
2918 JNI_ENTRY(jint, jni_MonitorExit(JNIEnv *env, jobject jobj))
2919  HOTSPOT_JNI_MONITOREXIT_ENTRY(env, jobj);
2920   jint ret = JNI_ERR;
2921   DT_RETURN_MARK(MonitorExit, jint, (const jint&amp;)ret);
2922 
2923   // Don&#39;t do anything with a null object
2924   if (jobj == NULL) {
2925     THROW_(vmSymbols::java_lang_NullPointerException(), JNI_ERR);
2926   }
2927 
2928   Handle obj(THREAD, JNIHandles::resolve_non_null(jobj));
2929   ObjectSynchronizer::jni_exit(obj(), CHECK_(JNI_ERR));
2930 
2931   ret = JNI_OK;
2932   return ret;
2933 JNI_END
2934 
2935 //
2936 // Extensions
2937 //
2938 
2939 DT_VOID_RETURN_MARK_DECL(GetStringRegion
2940                          , HOTSPOT_JNI_GETSTRINGREGION_RETURN());
2941 
2942 JNI_ENTRY(void, jni_GetStringRegion(JNIEnv *env, jstring string, jsize start, jsize len, jchar *buf))
2943   JNIWrapper(&quot;GetStringRegion&quot;);
2944  HOTSPOT_JNI_GETSTRINGREGION_ENTRY(env, string, start, len, buf);
2945   DT_VOID_RETURN_MARK(GetStringRegion);
2946   oop s = JNIHandles::resolve_non_null(string);
2947   typeArrayOop s_value = java_lang_String::value(s);
2948   int s_len = java_lang_String::length(s, s_value);
2949   if (start &lt; 0 || len &lt; 0 || start &gt; s_len - len) {
2950     THROW(vmSymbols::java_lang_StringIndexOutOfBoundsException());
2951   } else {
2952     if (len &gt; 0) {
2953       bool is_latin1 = java_lang_String::is_latin1(s);
2954       if (!is_latin1) {
2955         ArrayAccess&lt;&gt;::arraycopy_to_native(s_value, typeArrayOopDesc::element_offset&lt;jchar&gt;(start),
2956                                            buf, len);
2957       } else {
2958         for (int i = 0; i &lt; len; i++) {
2959           buf[i] = ((jchar) s_value-&gt;byte_at(i + start)) &amp; 0xff;
2960         }
2961       }
2962     }
2963   }
2964 JNI_END
2965 
2966 DT_VOID_RETURN_MARK_DECL(GetStringUTFRegion
2967                          , HOTSPOT_JNI_GETSTRINGUTFREGION_RETURN());
2968 
2969 JNI_ENTRY(void, jni_GetStringUTFRegion(JNIEnv *env, jstring string, jsize start, jsize len, char *buf))
2970   JNIWrapper(&quot;GetStringUTFRegion&quot;);
2971  HOTSPOT_JNI_GETSTRINGUTFREGION_ENTRY(env, string, start, len, buf);
2972   DT_VOID_RETURN_MARK(GetStringUTFRegion);
2973   oop s = JNIHandles::resolve_non_null(string);
2974   typeArrayOop s_value = java_lang_String::value(s);
2975   int s_len = java_lang_String::length(s, s_value);
2976   if (start &lt; 0 || len &lt; 0 || start &gt; s_len - len) {
2977     THROW(vmSymbols::java_lang_StringIndexOutOfBoundsException());
2978   } else {
2979     //%note jni_7
2980     if (len &gt; 0) {
2981       // Assume the buffer is large enough as the JNI spec. does not require user error checking
2982       java_lang_String::as_utf8_string(s, s_value, start, len, buf, INT_MAX);
2983       // as_utf8_string null-terminates the result string
2984     } else {
2985       // JDK null-terminates the buffer even in len is zero
2986       if (buf != NULL) {
2987         buf[0] = 0;
2988       }
2989     }
2990   }
2991 JNI_END
2992 
2993 static oop lock_gc_or_pin_object(JavaThread* thread, jobject obj) {
2994   if (Universe::heap()-&gt;supports_object_pinning()) {
2995     const oop o = JNIHandles::resolve_non_null(obj);
2996     return Universe::heap()-&gt;pin_object(thread, o);
2997   } else {
2998     GCLocker::lock_critical(thread);
2999     return JNIHandles::resolve_non_null(obj);
3000   }
3001 }
3002 
3003 static void unlock_gc_or_unpin_object(JavaThread* thread, jobject obj) {
3004   if (Universe::heap()-&gt;supports_object_pinning()) {
3005     const oop o = JNIHandles::resolve_non_null(obj);
3006     return Universe::heap()-&gt;unpin_object(thread, o);
3007   } else {
3008     GCLocker::unlock_critical(thread);
3009   }
3010 }
3011 
3012 JNI_ENTRY(void*, jni_GetPrimitiveArrayCritical(JNIEnv *env, jarray array, jboolean *isCopy))
3013   JNIWrapper(&quot;GetPrimitiveArrayCritical&quot;);
3014  HOTSPOT_JNI_GETPRIMITIVEARRAYCRITICAL_ENTRY(env, array, (uintptr_t *) isCopy);
3015   if (isCopy != NULL) {
3016     *isCopy = JNI_FALSE;
3017   }
3018   oop a = lock_gc_or_pin_object(thread, array);
3019   assert(a-&gt;is_array(), &quot;just checking&quot;);
3020   BasicType type;
3021   if (a-&gt;is_objArray()) {
3022     type = T_OBJECT;
3023   } else {
3024     type = TypeArrayKlass::cast(a-&gt;klass())-&gt;element_type();
3025   }
3026   void* ret = arrayOop(a)-&gt;base(type);
3027  HOTSPOT_JNI_GETPRIMITIVEARRAYCRITICAL_RETURN(ret);
3028   return ret;
3029 JNI_END
3030 
3031 
3032 JNI_ENTRY(void, jni_ReleasePrimitiveArrayCritical(JNIEnv *env, jarray array, void *carray, jint mode))
3033   JNIWrapper(&quot;ReleasePrimitiveArrayCritical&quot;);
3034   HOTSPOT_JNI_RELEASEPRIMITIVEARRAYCRITICAL_ENTRY(env, array, carray, mode);
3035   unlock_gc_or_unpin_object(thread, array);
3036 HOTSPOT_JNI_RELEASEPRIMITIVEARRAYCRITICAL_RETURN();
3037 JNI_END
3038 
3039 
3040 JNI_ENTRY(const jchar*, jni_GetStringCritical(JNIEnv *env, jstring string, jboolean *isCopy))
3041   JNIWrapper(&quot;GetStringCritical&quot;);
3042   HOTSPOT_JNI_GETSTRINGCRITICAL_ENTRY(env, string, (uintptr_t *) isCopy);
3043   oop s = lock_gc_or_pin_object(thread, string);
3044   typeArrayOop s_value = java_lang_String::value(s);
3045   bool is_latin1 = java_lang_String::is_latin1(s);
3046   if (isCopy != NULL) {
3047     *isCopy = is_latin1 ? JNI_TRUE : JNI_FALSE;
3048   }
3049   jchar* ret;
3050   if (!is_latin1) {
3051     ret = (jchar*) s_value-&gt;base(T_CHAR);
3052   } else {
3053     // Inflate latin1 encoded string to UTF16
3054     int s_len = java_lang_String::length(s, s_value);
3055     ret = NEW_C_HEAP_ARRAY_RETURN_NULL(jchar, s_len + 1, mtInternal);  // add one for zero termination
3056     /* JNI Specification states return NULL on OOM */
3057     if (ret != NULL) {
3058       for (int i = 0; i &lt; s_len; i++) {
3059         ret[i] = ((jchar) s_value-&gt;byte_at(i)) &amp; 0xff;
3060       }
3061       ret[s_len] = 0;
3062     }
3063   }
3064  HOTSPOT_JNI_GETSTRINGCRITICAL_RETURN((uint16_t *) ret);
3065   return ret;
3066 JNI_END
3067 
3068 
3069 JNI_ENTRY(void, jni_ReleaseStringCritical(JNIEnv *env, jstring str, const jchar *chars))
3070   JNIWrapper(&quot;ReleaseStringCritical&quot;);
3071   HOTSPOT_JNI_RELEASESTRINGCRITICAL_ENTRY(env, str, (uint16_t *) chars);
3072   // The str and chars arguments are ignored for UTF16 strings
3073   oop s = JNIHandles::resolve_non_null(str);
3074   bool is_latin1 = java_lang_String::is_latin1(s);
3075   if (is_latin1) {
3076     // For latin1 string, free jchar array allocated by earlier call to GetStringCritical.
3077     // This assumes that ReleaseStringCritical bookends GetStringCritical.
3078     FREE_C_HEAP_ARRAY(jchar, chars);
3079   }
3080   unlock_gc_or_unpin_object(thread, str);
3081 HOTSPOT_JNI_RELEASESTRINGCRITICAL_RETURN();
3082 JNI_END
3083 
3084 
3085 JNI_ENTRY(jweak, jni_NewWeakGlobalRef(JNIEnv *env, jobject ref))
3086   JNIWrapper(&quot;jni_NewWeakGlobalRef&quot;);
3087  HOTSPOT_JNI_NEWWEAKGLOBALREF_ENTRY(env, ref);
3088   Handle ref_handle(thread, JNIHandles::resolve(ref));
3089   jweak ret = JNIHandles::make_weak_global(ref_handle);
3090  HOTSPOT_JNI_NEWWEAKGLOBALREF_RETURN(ret);
3091   return ret;
3092 JNI_END
3093 
3094 // Must be JNI_ENTRY (with HandleMark)
3095 JNI_ENTRY(void, jni_DeleteWeakGlobalRef(JNIEnv *env, jweak ref))
3096   JNIWrapper(&quot;jni_DeleteWeakGlobalRef&quot;);
3097   HOTSPOT_JNI_DELETEWEAKGLOBALREF_ENTRY(env, ref);
3098   JNIHandles::destroy_weak_global(ref);
3099   HOTSPOT_JNI_DELETEWEAKGLOBALREF_RETURN();
3100 JNI_END
3101 
3102 
3103 JNI_ENTRY_NO_PRESERVE(jboolean, jni_ExceptionCheck(JNIEnv *env))
3104   JNIWrapper(&quot;jni_ExceptionCheck&quot;);
3105  HOTSPOT_JNI_EXCEPTIONCHECK_ENTRY(env);
3106   jni_check_async_exceptions(thread);
3107   jboolean ret = (thread-&gt;has_pending_exception()) ? JNI_TRUE : JNI_FALSE;
3108  HOTSPOT_JNI_EXCEPTIONCHECK_RETURN(ret);
3109   return ret;
3110 JNI_END
3111 
3112 
3113 // Initialization state for three routines below relating to
3114 // java.nio.DirectBuffers
3115 static          int directBufferSupportInitializeStarted = 0;
3116 static volatile int directBufferSupportInitializeEnded   = 0;
3117 static volatile int directBufferSupportInitializeFailed  = 0;
3118 static jclass    bufferClass                 = NULL;
3119 static jclass    directBufferClass           = NULL;
3120 static jclass    directByteBufferClass       = NULL;
3121 static jmethodID directByteBufferConstructor = NULL;
3122 static jfieldID  directBufferAddressField    = NULL;
3123 static jfieldID  bufferCapacityField         = NULL;
3124 
3125 static jclass lookupOne(JNIEnv* env, const char* name, TRAPS) {
3126   Handle loader;            // null (bootstrap) loader
3127   Handle protection_domain; // null protection domain
3128 
3129   TempNewSymbol sym = SymbolTable::new_symbol(name);
3130   jclass result =  find_class_from_class_loader(env, sym, true, loader, protection_domain, true, CHECK_NULL);
3131 
3132   if (log_is_enabled(Debug, class, resolve) &amp;&amp; result != NULL) {
3133     trace_class_resolution(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(result)));
3134   }
3135   return result;
3136 }
3137 
3138 // These lookups are done with the NULL (bootstrap) ClassLoader to
3139 // circumvent any security checks that would be done by jni_FindClass.
3140 JNI_ENTRY(bool, lookupDirectBufferClasses(JNIEnv* env))
3141 {
3142   if ((bufferClass           = lookupOne(env, &quot;java/nio/Buffer&quot;, thread))           == NULL) { return false; }
3143   if ((directBufferClass     = lookupOne(env, &quot;sun/nio/ch/DirectBuffer&quot;, thread))   == NULL) { return false; }
3144   if ((directByteBufferClass = lookupOne(env, &quot;java/nio/DirectByteBuffer&quot;, thread)) == NULL) { return false; }
3145   return true;
3146 }
3147 JNI_END
3148 
3149 
3150 static bool initializeDirectBufferSupport(JNIEnv* env, JavaThread* thread) {
3151   if (directBufferSupportInitializeFailed) {
3152     return false;
3153   }
3154 
3155   if (Atomic::cmpxchg(&amp;directBufferSupportInitializeStarted, 0, 1) == 0) {
3156     if (!lookupDirectBufferClasses(env)) {
3157       directBufferSupportInitializeFailed = 1;
3158       return false;
3159     }
3160 
3161     // Make global references for these
3162     bufferClass           = (jclass) env-&gt;NewGlobalRef(bufferClass);
3163     directBufferClass     = (jclass) env-&gt;NewGlobalRef(directBufferClass);
3164     directByteBufferClass = (jclass) env-&gt;NewGlobalRef(directByteBufferClass);
3165 
3166     // Get needed field and method IDs
3167     directByteBufferConstructor = env-&gt;GetMethodID(directByteBufferClass, &quot;&lt;init&gt;&quot;, &quot;(JI)V&quot;);
3168     if (env-&gt;ExceptionCheck()) {
3169       env-&gt;ExceptionClear();
3170       directBufferSupportInitializeFailed = 1;
3171       return false;
3172     }
3173     directBufferAddressField    = env-&gt;GetFieldID(bufferClass, &quot;address&quot;, &quot;J&quot;);
3174     if (env-&gt;ExceptionCheck()) {
3175       env-&gt;ExceptionClear();
3176       directBufferSupportInitializeFailed = 1;
3177       return false;
3178     }
3179     bufferCapacityField         = env-&gt;GetFieldID(bufferClass, &quot;capacity&quot;, &quot;I&quot;);
3180     if (env-&gt;ExceptionCheck()) {
3181       env-&gt;ExceptionClear();
3182       directBufferSupportInitializeFailed = 1;
3183       return false;
3184     }
3185 
3186     if ((directByteBufferConstructor == NULL) ||
3187         (directBufferAddressField    == NULL) ||
3188         (bufferCapacityField         == NULL)) {
3189       directBufferSupportInitializeFailed = 1;
3190       return false;
3191     }
3192 
3193     directBufferSupportInitializeEnded = 1;
3194   } else {
3195     while (!directBufferSupportInitializeEnded &amp;&amp; !directBufferSupportInitializeFailed) {
3196       os::naked_yield();
3197     }
3198   }
3199 
3200   return !directBufferSupportInitializeFailed;
3201 }
3202 
3203 extern &quot;C&quot; jobject JNICALL jni_NewDirectByteBuffer(JNIEnv *env, void* address, jlong capacity)
3204 {
3205   // thread_from_jni_environment() will block if VM is gone.
3206   JavaThread* thread = JavaThread::thread_from_jni_environment(env);
3207 
3208   JNIWrapper(&quot;jni_NewDirectByteBuffer&quot;);
3209  HOTSPOT_JNI_NEWDIRECTBYTEBUFFER_ENTRY(env, address, capacity);
3210 
3211   if (!directBufferSupportInitializeEnded) {
3212     if (!initializeDirectBufferSupport(env, thread)) {
3213       HOTSPOT_JNI_NEWDIRECTBYTEBUFFER_RETURN(NULL);
3214       return NULL;
3215     }
3216   }
3217 
3218   // Being paranoid about accidental sign extension on address
3219   jlong addr = (jlong) ((uintptr_t) address);
3220   // NOTE that package-private DirectByteBuffer constructor currently
3221   // takes int capacity
3222   jint  cap  = (jint)  capacity;
3223   jobject ret = env-&gt;NewObject(directByteBufferClass, directByteBufferConstructor, addr, cap);
3224   HOTSPOT_JNI_NEWDIRECTBYTEBUFFER_RETURN(ret);
3225   return ret;
3226 }
3227 
3228 DT_RETURN_MARK_DECL(GetDirectBufferAddress, void*
3229                     , HOTSPOT_JNI_GETDIRECTBUFFERADDRESS_RETURN((void*) _ret_ref));
3230 
3231 extern &quot;C&quot; void* JNICALL jni_GetDirectBufferAddress(JNIEnv *env, jobject buf)
3232 {
3233   // thread_from_jni_environment() will block if VM is gone.
3234   JavaThread* thread = JavaThread::thread_from_jni_environment(env);
3235 
3236   JNIWrapper(&quot;jni_GetDirectBufferAddress&quot;);
3237   HOTSPOT_JNI_GETDIRECTBUFFERADDRESS_ENTRY(env, buf);
3238   void* ret = NULL;
3239   DT_RETURN_MARK(GetDirectBufferAddress, void*, (const void*&amp;)ret);
3240 
3241   if (!directBufferSupportInitializeEnded) {
3242     if (!initializeDirectBufferSupport(env, thread)) {
3243       return 0;
3244     }
3245   }
3246 
3247   if ((buf != NULL) &amp;&amp; (!env-&gt;IsInstanceOf(buf, directBufferClass))) {
3248     return 0;
3249   }
3250 
3251   ret = (void*)(intptr_t)env-&gt;GetLongField(buf, directBufferAddressField);
3252   return ret;
3253 }
3254 
3255 DT_RETURN_MARK_DECL(GetDirectBufferCapacity, jlong
3256                     , HOTSPOT_JNI_GETDIRECTBUFFERCAPACITY_RETURN(_ret_ref));
3257 
3258 extern &quot;C&quot; jlong JNICALL jni_GetDirectBufferCapacity(JNIEnv *env, jobject buf)
3259 {
3260   // thread_from_jni_environment() will block if VM is gone.
3261   JavaThread* thread = JavaThread::thread_from_jni_environment(env);
3262 
3263   JNIWrapper(&quot;jni_GetDirectBufferCapacity&quot;);
3264   HOTSPOT_JNI_GETDIRECTBUFFERCAPACITY_ENTRY(env, buf);
3265   jlong ret = -1;
3266   DT_RETURN_MARK(GetDirectBufferCapacity, jlong, (const jlong&amp;)ret);
3267 
3268   if (!directBufferSupportInitializeEnded) {
3269     if (!initializeDirectBufferSupport(env, thread)) {
3270       ret = 0;
3271       return ret;
3272     }
3273   }
3274 
3275   if (buf == NULL) {
3276     return -1;
3277   }
3278 
3279   if (!env-&gt;IsInstanceOf(buf, directBufferClass)) {
3280     return -1;
3281   }
3282 
3283   // NOTE that capacity is currently an int in the implementation
3284   ret = env-&gt;GetIntField(buf, bufferCapacityField);
3285   return ret;
3286 }
3287 
3288 
3289 JNI_LEAF(jint, jni_GetVersion(JNIEnv *env))
3290   JNIWrapper(&quot;GetVersion&quot;);
3291   HOTSPOT_JNI_GETVERSION_ENTRY(env);
3292   HOTSPOT_JNI_GETVERSION_RETURN(CurrentVersion);
3293   return CurrentVersion;
3294 JNI_END
3295 
3296 extern struct JavaVM_ main_vm;
3297 
3298 JNI_LEAF(jint, jni_GetJavaVM(JNIEnv *env, JavaVM **vm))
3299   JNIWrapper(&quot;jni_GetJavaVM&quot;);
3300   HOTSPOT_JNI_GETJAVAVM_ENTRY(env, (void **) vm);
3301   *vm  = (JavaVM *)(&amp;main_vm);
3302   HOTSPOT_JNI_GETJAVAVM_RETURN(JNI_OK);
3303   return JNI_OK;
3304 JNI_END
3305 
3306 
3307 JNI_ENTRY(jobject, jni_GetModule(JNIEnv* env, jclass clazz))
3308   JNIWrapper(&quot;GetModule&quot;);
3309   return Modules::get_module(clazz, THREAD);
3310 JNI_END
3311 
3312 
3313 // Structure containing all jni functions
3314 struct JNINativeInterface_ jni_NativeInterface = {
3315     NULL,
3316     NULL,
3317     NULL,
3318 
3319     NULL,
3320 
3321     jni_GetVersion,
3322 
3323     jni_DefineClass,
3324     jni_FindClass,
3325 
3326     jni_FromReflectedMethod,
3327     jni_FromReflectedField,
3328 
3329     jni_ToReflectedMethod,
3330 
3331     jni_GetSuperclass,
3332     jni_IsAssignableFrom,
3333 
3334     jni_ToReflectedField,
3335 
3336     jni_Throw,
3337     jni_ThrowNew,
3338     jni_ExceptionOccurred,
3339     jni_ExceptionDescribe,
3340     jni_ExceptionClear,
3341     jni_FatalError,
3342 
3343     jni_PushLocalFrame,
3344     jni_PopLocalFrame,
3345 
3346     jni_NewGlobalRef,
3347     jni_DeleteGlobalRef,
3348     jni_DeleteLocalRef,
3349     jni_IsSameObject,
3350 
3351     jni_NewLocalRef,
3352     jni_EnsureLocalCapacity,
3353 
3354     jni_AllocObject,
3355     jni_NewObject,
3356     jni_NewObjectV,
3357     jni_NewObjectA,
3358 
3359     jni_GetObjectClass,
3360     jni_IsInstanceOf,
3361 
3362     jni_GetMethodID,
3363 
3364     jni_CallObjectMethod,
3365     jni_CallObjectMethodV,
3366     jni_CallObjectMethodA,
3367     jni_CallBooleanMethod,
3368     jni_CallBooleanMethodV,
3369     jni_CallBooleanMethodA,
3370     jni_CallByteMethod,
3371     jni_CallByteMethodV,
3372     jni_CallByteMethodA,
3373     jni_CallCharMethod,
3374     jni_CallCharMethodV,
3375     jni_CallCharMethodA,
3376     jni_CallShortMethod,
3377     jni_CallShortMethodV,
3378     jni_CallShortMethodA,
3379     jni_CallIntMethod,
3380     jni_CallIntMethodV,
3381     jni_CallIntMethodA,
3382     jni_CallLongMethod,
3383     jni_CallLongMethodV,
3384     jni_CallLongMethodA,
3385     jni_CallFloatMethod,
3386     jni_CallFloatMethodV,
3387     jni_CallFloatMethodA,
3388     jni_CallDoubleMethod,
3389     jni_CallDoubleMethodV,
3390     jni_CallDoubleMethodA,
3391     jni_CallVoidMethod,
3392     jni_CallVoidMethodV,
3393     jni_CallVoidMethodA,
3394 
3395     jni_CallNonvirtualObjectMethod,
3396     jni_CallNonvirtualObjectMethodV,
3397     jni_CallNonvirtualObjectMethodA,
3398     jni_CallNonvirtualBooleanMethod,
3399     jni_CallNonvirtualBooleanMethodV,
3400     jni_CallNonvirtualBooleanMethodA,
3401     jni_CallNonvirtualByteMethod,
3402     jni_CallNonvirtualByteMethodV,
3403     jni_CallNonvirtualByteMethodA,
3404     jni_CallNonvirtualCharMethod,
3405     jni_CallNonvirtualCharMethodV,
3406     jni_CallNonvirtualCharMethodA,
3407     jni_CallNonvirtualShortMethod,
3408     jni_CallNonvirtualShortMethodV,
3409     jni_CallNonvirtualShortMethodA,
3410     jni_CallNonvirtualIntMethod,
3411     jni_CallNonvirtualIntMethodV,
3412     jni_CallNonvirtualIntMethodA,
3413     jni_CallNonvirtualLongMethod,
3414     jni_CallNonvirtualLongMethodV,
3415     jni_CallNonvirtualLongMethodA,
3416     jni_CallNonvirtualFloatMethod,
3417     jni_CallNonvirtualFloatMethodV,
3418     jni_CallNonvirtualFloatMethodA,
3419     jni_CallNonvirtualDoubleMethod,
3420     jni_CallNonvirtualDoubleMethodV,
3421     jni_CallNonvirtualDoubleMethodA,
3422     jni_CallNonvirtualVoidMethod,
3423     jni_CallNonvirtualVoidMethodV,
3424     jni_CallNonvirtualVoidMethodA,
3425 
3426     jni_GetFieldID,
3427 
3428     jni_GetObjectField,
3429     jni_GetBooleanField,
3430     jni_GetByteField,
3431     jni_GetCharField,
3432     jni_GetShortField,
3433     jni_GetIntField,
3434     jni_GetLongField,
3435     jni_GetFloatField,
3436     jni_GetDoubleField,
3437 
3438     jni_SetObjectField,
3439     jni_SetBooleanField,
3440     jni_SetByteField,
3441     jni_SetCharField,
3442     jni_SetShortField,
3443     jni_SetIntField,
3444     jni_SetLongField,
3445     jni_SetFloatField,
3446     jni_SetDoubleField,
3447 
3448     jni_GetStaticMethodID,
3449 
3450     jni_CallStaticObjectMethod,
3451     jni_CallStaticObjectMethodV,
3452     jni_CallStaticObjectMethodA,
3453     jni_CallStaticBooleanMethod,
3454     jni_CallStaticBooleanMethodV,
3455     jni_CallStaticBooleanMethodA,
3456     jni_CallStaticByteMethod,
3457     jni_CallStaticByteMethodV,
3458     jni_CallStaticByteMethodA,
3459     jni_CallStaticCharMethod,
3460     jni_CallStaticCharMethodV,
3461     jni_CallStaticCharMethodA,
3462     jni_CallStaticShortMethod,
3463     jni_CallStaticShortMethodV,
3464     jni_CallStaticShortMethodA,
3465     jni_CallStaticIntMethod,
3466     jni_CallStaticIntMethodV,
3467     jni_CallStaticIntMethodA,
3468     jni_CallStaticLongMethod,
3469     jni_CallStaticLongMethodV,
3470     jni_CallStaticLongMethodA,
3471     jni_CallStaticFloatMethod,
3472     jni_CallStaticFloatMethodV,
3473     jni_CallStaticFloatMethodA,
3474     jni_CallStaticDoubleMethod,
3475     jni_CallStaticDoubleMethodV,
3476     jni_CallStaticDoubleMethodA,
3477     jni_CallStaticVoidMethod,
3478     jni_CallStaticVoidMethodV,
3479     jni_CallStaticVoidMethodA,
3480 
3481     jni_GetStaticFieldID,
3482 
3483     jni_GetStaticObjectField,
3484     jni_GetStaticBooleanField,
3485     jni_GetStaticByteField,
3486     jni_GetStaticCharField,
3487     jni_GetStaticShortField,
3488     jni_GetStaticIntField,
3489     jni_GetStaticLongField,
3490     jni_GetStaticFloatField,
3491     jni_GetStaticDoubleField,
3492 
3493     jni_SetStaticObjectField,
3494     jni_SetStaticBooleanField,
3495     jni_SetStaticByteField,
3496     jni_SetStaticCharField,
3497     jni_SetStaticShortField,
3498     jni_SetStaticIntField,
3499     jni_SetStaticLongField,
3500     jni_SetStaticFloatField,
3501     jni_SetStaticDoubleField,
3502 
3503     jni_NewString,
3504     jni_GetStringLength,
3505     jni_GetStringChars,
3506     jni_ReleaseStringChars,
3507 
3508     jni_NewStringUTF,
3509     jni_GetStringUTFLength,
3510     jni_GetStringUTFChars,
3511     jni_ReleaseStringUTFChars,
3512 
3513     jni_GetArrayLength,
3514 
3515     jni_NewObjectArray,
3516     jni_GetObjectArrayElement,
3517     jni_SetObjectArrayElement,
3518 
3519     jni_NewBooleanArray,
3520     jni_NewByteArray,
3521     jni_NewCharArray,
3522     jni_NewShortArray,
3523     jni_NewIntArray,
3524     jni_NewLongArray,
3525     jni_NewFloatArray,
3526     jni_NewDoubleArray,
3527 
3528     jni_GetBooleanArrayElements,
3529     jni_GetByteArrayElements,
3530     jni_GetCharArrayElements,
3531     jni_GetShortArrayElements,
3532     jni_GetIntArrayElements,
3533     jni_GetLongArrayElements,
3534     jni_GetFloatArrayElements,
3535     jni_GetDoubleArrayElements,
3536 
3537     jni_ReleaseBooleanArrayElements,
3538     jni_ReleaseByteArrayElements,
3539     jni_ReleaseCharArrayElements,
3540     jni_ReleaseShortArrayElements,
3541     jni_ReleaseIntArrayElements,
3542     jni_ReleaseLongArrayElements,
3543     jni_ReleaseFloatArrayElements,
3544     jni_ReleaseDoubleArrayElements,
3545 
3546     jni_GetBooleanArrayRegion,
3547     jni_GetByteArrayRegion,
3548     jni_GetCharArrayRegion,
3549     jni_GetShortArrayRegion,
3550     jni_GetIntArrayRegion,
3551     jni_GetLongArrayRegion,
3552     jni_GetFloatArrayRegion,
3553     jni_GetDoubleArrayRegion,
3554 
3555     jni_SetBooleanArrayRegion,
3556     jni_SetByteArrayRegion,
3557     jni_SetCharArrayRegion,
3558     jni_SetShortArrayRegion,
3559     jni_SetIntArrayRegion,
3560     jni_SetLongArrayRegion,
3561     jni_SetFloatArrayRegion,
3562     jni_SetDoubleArrayRegion,
3563 
3564     jni_RegisterNatives,
3565     jni_UnregisterNatives,
3566 
3567     jni_MonitorEnter,
3568     jni_MonitorExit,
3569 
3570     jni_GetJavaVM,
3571 
3572     jni_GetStringRegion,
3573     jni_GetStringUTFRegion,
3574 
3575     jni_GetPrimitiveArrayCritical,
3576     jni_ReleasePrimitiveArrayCritical,
3577 
3578     jni_GetStringCritical,
3579     jni_ReleaseStringCritical,
3580 
3581     jni_NewWeakGlobalRef,
3582     jni_DeleteWeakGlobalRef,
3583 
3584     jni_ExceptionCheck,
3585 
3586     jni_NewDirectByteBuffer,
3587     jni_GetDirectBufferAddress,
3588     jni_GetDirectBufferCapacity,
3589 
3590     // New 1_6 features
3591 
3592     jni_GetObjectRefType,
3593 
3594     // Module features
3595 
3596     jni_GetModule
3597 };
3598 
3599 
3600 // For jvmti use to modify jni function table.
3601 // Java threads in native contiues to run until it is transitioned
3602 // to VM at safepoint. Before the transition or before it is blocked
3603 // for safepoint it may access jni function table. VM could crash if
3604 // any java thread access the jni function table in the middle of memcpy.
3605 // To avoid this each function pointers are copied automically.
3606 void copy_jni_function_table(const struct JNINativeInterface_ *new_jni_NativeInterface) {
3607   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
3608   intptr_t *a = (intptr_t *) jni_functions();
3609   intptr_t *b = (intptr_t *) new_jni_NativeInterface;
3610   for (uint i=0; i &lt;  sizeof(struct JNINativeInterface_)/sizeof(void *); i++) {
3611     Atomic::store(a++, *b++);
3612   }
3613 }
3614 
3615 void quicken_jni_functions() {
3616   // Replace Get&lt;Primitive&gt;Field with fast versions
3617   if (UseFastJNIAccessors &amp;&amp; !VerifyJNIFields &amp;&amp; !CountJNICalls &amp;&amp; !CheckJNICalls) {
3618     address func;
3619     func = JNI_FastGetField::generate_fast_get_boolean_field();
3620     if (func != (address)-1) {
3621       jni_NativeInterface.GetBooleanField = (GetBooleanField_t)func;
3622     }
3623     func = JNI_FastGetField::generate_fast_get_byte_field();
3624     if (func != (address)-1) {
3625       jni_NativeInterface.GetByteField = (GetByteField_t)func;
3626     }
3627     func = JNI_FastGetField::generate_fast_get_char_field();
3628     if (func != (address)-1) {
3629       jni_NativeInterface.GetCharField = (GetCharField_t)func;
3630     }
3631     func = JNI_FastGetField::generate_fast_get_short_field();
3632     if (func != (address)-1) {
3633       jni_NativeInterface.GetShortField = (GetShortField_t)func;
3634     }
3635     func = JNI_FastGetField::generate_fast_get_int_field();
3636     if (func != (address)-1) {
3637       jni_NativeInterface.GetIntField = (GetIntField_t)func;
3638     }
3639     func = JNI_FastGetField::generate_fast_get_long_field();
3640     if (func != (address)-1) {
3641       jni_NativeInterface.GetLongField = (GetLongField_t)func;
3642     }
3643     func = JNI_FastGetField::generate_fast_get_float_field();
3644     if (func != (address)-1) {
3645       jni_NativeInterface.GetFloatField = (GetFloatField_t)func;
3646     }
3647     func = JNI_FastGetField::generate_fast_get_double_field();
3648     if (func != (address)-1) {
3649       jni_NativeInterface.GetDoubleField = (GetDoubleField_t)func;
3650     }
3651   }
3652 }
3653 
3654 // Returns the function structure
3655 struct JNINativeInterface_* jni_functions() {
3656 #if INCLUDE_JNI_CHECK
3657   if (CheckJNICalls) return jni_functions_check();
3658 #endif // INCLUDE_JNI_CHECK
3659   return &amp;jni_NativeInterface;
3660 }
3661 
3662 // Returns the function structure
3663 struct JNINativeInterface_* jni_functions_nocheck() {
3664   return &amp;jni_NativeInterface;
3665 }
3666 
3667 static void post_thread_start_event(const JavaThread* jt) {
3668   assert(jt != NULL, &quot;invariant&quot;);
3669   EventThreadStart event;
3670   if (event.should_commit()) {
3671     event.set_thread(JFR_THREAD_ID(jt));
3672     event.set_parentThread((traceid)0);
3673 #if INCLUDE_JFR
3674     if (EventThreadStart::is_stacktrace_enabled()) {
3675       jt-&gt;jfr_thread_local()-&gt;set_cached_stack_trace_id((traceid)0);
3676       event.commit();
3677       jt-&gt;jfr_thread_local()-&gt;clear_cached_stack_trace();
3678     } else
3679 #endif
3680     {
3681       event.commit();
3682     }
3683   }
3684 }
3685 
3686 // Invocation API
3687 
3688 
3689 // Forward declaration
3690 extern const struct JNIInvokeInterface_ jni_InvokeInterface;
3691 
3692 // Global invocation API vars
3693 volatile int vm_created = 0;
3694 // Indicate whether it is safe to recreate VM. Recreation is only
3695 // possible after a failed initial creation attempt in some cases.
3696 volatile int safe_to_recreate_vm = 1;
3697 struct JavaVM_ main_vm = {&amp;jni_InvokeInterface};
3698 
3699 
3700 #define JAVASTACKSIZE (400 * 1024)    /* Default size of a thread java stack */
3701 enum { VERIFY_NONE, VERIFY_REMOTE, VERIFY_ALL };
3702 
3703 DT_RETURN_MARK_DECL(GetDefaultJavaVMInitArgs, jint
3704                     , HOTSPOT_JNI_GETDEFAULTJAVAVMINITARGS_RETURN(_ret_ref));
3705 
3706 _JNI_IMPORT_OR_EXPORT_ jint JNICALL JNI_GetDefaultJavaVMInitArgs(void *args_) {
3707   HOTSPOT_JNI_GETDEFAULTJAVAVMINITARGS_ENTRY(args_);
3708   JDK1_1InitArgs *args = (JDK1_1InitArgs *)args_;
3709   jint ret = JNI_ERR;
3710   DT_RETURN_MARK(GetDefaultJavaVMInitArgs, jint, (const jint&amp;)ret);
3711 
3712   if (Threads::is_supported_jni_version(args-&gt;version)) {
3713     ret = JNI_OK;
3714   }
3715   // 1.1 style no longer supported in hotspot.
3716   // According the JNI spec, we should update args-&gt;version on return.
3717   // We also use the structure to communicate with launcher about default
3718   // stack size.
3719   if (args-&gt;version == JNI_VERSION_1_1) {
3720     args-&gt;version = JNI_VERSION_1_2;
3721     // javaStackSize is int in arguments structure
3722     assert(jlong(ThreadStackSize) * K &lt; INT_MAX, &quot;integer overflow&quot;);
3723     args-&gt;javaStackSize = (jint)(ThreadStackSize * K);
3724   }
3725   return ret;
3726 }
3727 
3728 DT_RETURN_MARK_DECL(CreateJavaVM, jint
3729                     , HOTSPOT_JNI_CREATEJAVAVM_RETURN(_ret_ref));
3730 
3731 static jint JNI_CreateJavaVM_inner(JavaVM **vm, void **penv, void *args) {
3732   HOTSPOT_JNI_CREATEJAVAVM_ENTRY((void **) vm, penv, args);
3733 
3734   jint result = JNI_ERR;
3735   DT_RETURN_MARK(CreateJavaVM, jint, (const jint&amp;)result);
3736 
3737   // We&#39;re about to use Atomic::xchg for synchronization.  Some Zero
3738   // platforms use the GCC builtin __sync_lock_test_and_set for this,
3739   // but __sync_lock_test_and_set is not guaranteed to do what we want
3740   // on all architectures.  So we check it works before relying on it.
3741 #if defined(ZERO) &amp;&amp; defined(ASSERT)
3742   {
3743     jint a = 0xcafebabe;
3744     jint b = Atomic::xchg(&amp;a, (jint) 0xdeadbeef);
3745     void *c = &amp;a;
3746     void *d = Atomic::xchg(&amp;c, &amp;b);
3747     assert(a == (jint) 0xdeadbeef &amp;&amp; b == (jint) 0xcafebabe, &quot;Atomic::xchg() works&quot;);
3748     assert(c == &amp;b &amp;&amp; d == &amp;a, &quot;Atomic::xchg() works&quot;);
3749   }
3750 #endif // ZERO &amp;&amp; ASSERT
3751 
3752   // At the moment it&#39;s only possible to have one Java VM,
3753   // since some of the runtime state is in global variables.
3754 
3755   // We cannot use our mutex locks here, since they only work on
3756   // Threads. We do an atomic compare and exchange to ensure only
3757   // one thread can call this method at a time
3758 
3759   // We use Atomic::xchg rather than Atomic::add/dec since on some platforms
3760   // the add/dec implementations are dependent on whether we are running
3761   // on a multiprocessor Atomic::xchg does not have this problem.
3762   if (Atomic::xchg(&amp;vm_created, 1) == 1) {
3763     return JNI_EEXIST;   // already created, or create attempt in progress
3764   }
3765 
3766   // If a previous creation attempt failed but can be retried safely,
3767   // then safe_to_recreate_vm will have been reset to 1 after being
3768   // cleared here. If a previous creation attempt succeeded and we then
3769   // destroyed that VM, we will be prevented from trying to recreate
3770   // the VM in the same process, as the value will still be 0.
3771   if (Atomic::xchg(&amp;safe_to_recreate_vm, 0) == 0) {
3772     return JNI_ERR;
3773   }
3774 
3775   assert(vm_created == 1, &quot;vm_created is true during the creation&quot;);
3776 
3777   /**
3778    * Certain errors during initialization are recoverable and do not
3779    * prevent this method from being called again at a later time
3780    * (perhaps with different arguments).  However, at a certain
3781    * point during initialization if an error occurs we cannot allow
3782    * this function to be called again (or it will crash).  In those
3783    * situations, the &#39;canTryAgain&#39; flag is set to false, which atomically
3784    * sets safe_to_recreate_vm to 1, such that any new call to
3785    * JNI_CreateJavaVM will immediately fail using the above logic.
3786    */
3787   bool can_try_again = true;
3788 
3789   result = Threads::create_vm((JavaVMInitArgs*) args, &amp;can_try_again);
3790   if (result == JNI_OK) {
3791     JavaThread *thread = JavaThread::current();
3792     assert(!thread-&gt;has_pending_exception(), &quot;should have returned not OK&quot;);
3793     /* thread is thread_in_vm here */
3794     *vm = (JavaVM *)(&amp;main_vm);
3795     *(JNIEnv**)penv = thread-&gt;jni_environment();
3796 
3797 #if INCLUDE_JVMCI
3798     if (EnableJVMCI) {
3799       if (UseJVMCICompiler) {
3800         // JVMCI is initialized on a CompilerThread
3801         if (BootstrapJVMCI) {
3802           JavaThread* THREAD = thread;
3803           JVMCICompiler* compiler = JVMCICompiler::instance(true, CATCH);
3804           compiler-&gt;bootstrap(THREAD);
3805           if (HAS_PENDING_EXCEPTION) {
3806             HandleMark hm;
3807             vm_exit_during_initialization(Handle(THREAD, PENDING_EXCEPTION));
3808           }
3809         }
3810       }
3811     }
3812 #endif
3813 
3814     // Notify JVMTI
3815     if (JvmtiExport::should_post_thread_life()) {
3816        JvmtiExport::post_thread_start(thread);
3817     }
3818 
3819     post_thread_start_event(thread);
3820 
3821 #ifndef PRODUCT
3822     if (ReplayCompiles) ciReplay::replay(thread);
3823 
3824     // Some platforms (like Win*) need a wrapper around these test
3825     // functions in order to properly handle error conditions.
3826     VMError::test_error_handler();
3827 #endif
3828 
3829     // Since this is not a JVM_ENTRY we have to set the thread state manually before leaving.
3830     ThreadStateTransition::transition(thread, _thread_in_vm, _thread_in_native);
3831   } else {
3832     // If create_vm exits because of a pending exception, exit with that
3833     // exception.  In the future when we figure out how to reclaim memory,
3834     // we may be able to exit with JNI_ERR and allow the calling application
3835     // to continue.
3836     if (Universe::is_fully_initialized()) {
3837       // otherwise no pending exception possible - VM will already have aborted
3838       JavaThread* THREAD = JavaThread::current();
3839       if (HAS_PENDING_EXCEPTION) {
3840         HandleMark hm;
3841         vm_exit_during_initialization(Handle(THREAD, PENDING_EXCEPTION));
3842       }
3843     }
3844 
3845     if (can_try_again) {
3846       // reset safe_to_recreate_vm to 1 so that retrial would be possible
3847       safe_to_recreate_vm = 1;
3848     }
3849 
3850     // Creation failed. We must reset vm_created
3851     *vm = 0;
3852     *(JNIEnv**)penv = 0;
3853     // reset vm_created last to avoid race condition. Use OrderAccess to
3854     // control both compiler and architectural-based reordering.
3855     Atomic::release_store(&amp;vm_created, 0);
3856   }
3857 
3858   // Flush stdout and stderr before exit.
3859   fflush(stdout);
3860   fflush(stderr);
3861 
3862   return result;
3863 
3864 }
3865 
3866 _JNI_IMPORT_OR_EXPORT_ jint JNICALL JNI_CreateJavaVM(JavaVM **vm, void **penv, void *args) {
3867   jint result = JNI_ERR;
3868   // On Windows, let CreateJavaVM run with SEH protection
3869 #ifdef _WIN32
3870   __try {
3871 #endif
3872     result = JNI_CreateJavaVM_inner(vm, penv, args);
3873 #ifdef _WIN32
3874   } __except(topLevelExceptionFilter((_EXCEPTION_POINTERS*)_exception_info())) {
3875     // Nothing to do.
3876   }
3877 #endif
3878   return result;
3879 }
3880 
3881 _JNI_IMPORT_OR_EXPORT_ jint JNICALL JNI_GetCreatedJavaVMs(JavaVM **vm_buf, jsize bufLen, jsize *numVMs) {
3882   // See bug 4367188, the wrapper can sometimes cause VM crashes
3883   // JNIWrapper(&quot;GetCreatedJavaVMs&quot;);
3884 
3885   HOTSPOT_JNI_GETCREATEDJAVAVMS_ENTRY((void **) vm_buf, bufLen, (uintptr_t *) numVMs);
3886 
3887   if (vm_created == 1) {
3888     if (numVMs != NULL) *numVMs = 1;
3889     if (bufLen &gt; 0)     *vm_buf = (JavaVM *)(&amp;main_vm);
3890   } else {
3891     if (numVMs != NULL) *numVMs = 0;
3892   }
3893   HOTSPOT_JNI_GETCREATEDJAVAVMS_RETURN(JNI_OK);
3894   return JNI_OK;
3895 }
3896 
3897 extern &quot;C&quot; {
3898 
3899 DT_RETURN_MARK_DECL(DestroyJavaVM, jint
3900                     , HOTSPOT_JNI_DESTROYJAVAVM_RETURN(_ret_ref));
3901 
3902 static jint JNICALL jni_DestroyJavaVM_inner(JavaVM *vm) {
3903   HOTSPOT_JNI_DESTROYJAVAVM_ENTRY(vm);
3904   jint res = JNI_ERR;
3905   DT_RETURN_MARK(DestroyJavaVM, jint, (const jint&amp;)res);
3906 
3907   if (vm_created == 0) {
3908     res = JNI_ERR;
3909     return res;
3910   }
3911 
3912   JNIWrapper(&quot;DestroyJavaVM&quot;);
3913   JNIEnv *env;
3914   JavaVMAttachArgs destroyargs;
3915   destroyargs.version = CurrentVersion;
3916   destroyargs.name = (char *)&quot;DestroyJavaVM&quot;;
3917   destroyargs.group = NULL;
3918   res = vm-&gt;AttachCurrentThread((void **)&amp;env, (void *)&amp;destroyargs);
3919   if (res != JNI_OK) {
3920     return res;
3921   }
3922 
3923   // Since this is not a JVM_ENTRY we have to set the thread state manually before entering.
3924   JavaThread* thread = JavaThread::current();
3925   ThreadStateTransition::transition_from_native(thread, _thread_in_vm);
3926   if (Threads::destroy_vm()) {
3927     // Should not change thread state, VM is gone
3928     vm_created = 0;
3929     res = JNI_OK;
3930     return res;
3931   } else {
3932     ThreadStateTransition::transition(thread, _thread_in_vm, _thread_in_native);
3933     res = JNI_ERR;
3934     return res;
3935   }
3936 }
3937 
3938 jint JNICALL jni_DestroyJavaVM(JavaVM *vm) {
3939   jint result = JNI_ERR;
3940   // On Windows, we need SEH protection
3941 #ifdef _WIN32
3942   __try {
3943 #endif
3944     result = jni_DestroyJavaVM_inner(vm);
3945 #ifdef _WIN32
3946   } __except(topLevelExceptionFilter((_EXCEPTION_POINTERS*)_exception_info())) {
3947     // Nothing to do.
3948   }
3949 #endif
3950   return result;
3951 }
3952 
3953 static jint attach_current_thread(JavaVM *vm, void **penv, void *_args, bool daemon) {
3954   JavaVMAttachArgs *args = (JavaVMAttachArgs *) _args;
3955 
3956   // Check below commented out from JDK1.2fcs as well
3957   /*
3958   if (args &amp;&amp; (args-&gt;version != JNI_VERSION_1_1 || args-&gt;version != JNI_VERSION_1_2)) {
3959     return JNI_EVERSION;
3960   }
3961   */
3962 
3963   Thread* t = Thread::current_or_null();
3964   if (t != NULL) {
3965     // If executing from an atexit hook we may be in the VMThread.
3966     if (t-&gt;is_Java_thread()) {
3967       // If the thread has been attached this operation is a no-op
3968       *(JNIEnv**)penv = ((JavaThread*) t)-&gt;jni_environment();
3969       return JNI_OK;
3970     } else {
3971       return JNI_ERR;
3972     }
3973   }
3974 
3975   // Create a thread and mark it as attaching so it will be skipped by the
3976   // ThreadsListEnumerator - see CR 6404306
3977   JavaThread* thread = new JavaThread(true);
3978 
3979   // Set correct safepoint info. The thread is going to call into Java when
3980   // initializing the Java level thread object. Hence, the correct state must
3981   // be set in order for the Safepoint code to deal with it correctly.
3982   thread-&gt;set_thread_state(_thread_in_vm);
3983   thread-&gt;record_stack_base_and_size();
3984   thread-&gt;register_thread_stack_with_NMT();
3985   thread-&gt;initialize_thread_current();
3986 
3987   if (!os::create_attached_thread(thread)) {
3988     thread-&gt;smr_delete();
3989     return JNI_ERR;
3990   }
3991   // Enable stack overflow checks
3992   thread-&gt;create_stack_guard_pages();
3993 
3994   thread-&gt;initialize_tlab();
3995 
3996   thread-&gt;cache_global_variables();
3997 
3998   // This thread will not do a safepoint check, since it has
3999   // not been added to the Thread list yet.
4000   { MutexLocker ml(Threads_lock);
4001     // This must be inside this lock in order to get FullGCALot to work properly, i.e., to
4002     // avoid this thread trying to do a GC before it is added to the thread-list
4003     thread-&gt;set_active_handles(JNIHandleBlock::allocate_block());
4004     Threads::add(thread, daemon);
4005   }
4006   // Create thread group and name info from attach arguments
4007   oop group = NULL;
4008   char* thread_name = NULL;
4009   if (args != NULL &amp;&amp; Threads::is_supported_jni_version(args-&gt;version)) {
4010     group = JNIHandles::resolve(args-&gt;group);
4011     thread_name = args-&gt;name; // may be NULL
4012   }
4013   if (group == NULL) group = Universe::main_thread_group();
4014 
4015   // Create Java level thread object and attach it to this thread
4016   bool attach_failed = false;
4017   {
4018     EXCEPTION_MARK;
4019     HandleMark hm(THREAD);
4020     Handle thread_group(THREAD, group);
4021     thread-&gt;allocate_threadObj(thread_group, thread_name, daemon, THREAD);
4022     if (HAS_PENDING_EXCEPTION) {
4023       CLEAR_PENDING_EXCEPTION;
4024       // cleanup outside the handle mark.
4025       attach_failed = true;
4026     }
4027   }
4028 
4029   if (attach_failed) {
4030     // Added missing cleanup
4031     thread-&gt;cleanup_failed_attach_current_thread(daemon);
4032     return JNI_ERR;
4033   }
4034 
4035   // mark the thread as no longer attaching
4036   // this uses a fence to push the change through so we don&#39;t have
4037   // to regrab the threads_lock
4038   thread-&gt;set_done_attaching_via_jni();
4039 
4040   // Set java thread status.
4041   java_lang_Thread::set_thread_status(thread-&gt;threadObj(),
4042               java_lang_Thread::RUNNABLE);
4043 
4044   // Notify the debugger
4045   if (JvmtiExport::should_post_thread_life()) {
4046     JvmtiExport::post_thread_start(thread);
4047   }
4048 
4049   post_thread_start_event(thread);
4050 
4051   *(JNIEnv**)penv = thread-&gt;jni_environment();
4052 
4053   // Now leaving the VM, so change thread_state. This is normally automatically taken care
4054   // of in the JVM_ENTRY. But in this situation we have to do it manually. Notice, that by
4055   // using ThreadStateTransition::transition, we do a callback to the safepoint code if
4056   // needed.
4057 
4058   ThreadStateTransition::transition(thread, _thread_in_vm, _thread_in_native);
4059 
4060   // Perform any platform dependent FPU setup
4061   os::setup_fpu();
4062 
4063   return JNI_OK;
4064 }
4065 
4066 
4067 jint JNICALL jni_AttachCurrentThread(JavaVM *vm, void **penv, void *_args) {
4068   HOTSPOT_JNI_ATTACHCURRENTTHREAD_ENTRY(vm, penv, _args);
4069   if (vm_created == 0) {
4070     HOTSPOT_JNI_ATTACHCURRENTTHREAD_RETURN((uint32_t) JNI_ERR);
4071     return JNI_ERR;
4072   }
4073 
4074   JNIWrapper(&quot;AttachCurrentThread&quot;);
4075   jint ret = attach_current_thread(vm, penv, _args, false);
4076   HOTSPOT_JNI_ATTACHCURRENTTHREAD_RETURN(ret);
4077   return ret;
4078 }
4079 
4080 
4081 jint JNICALL jni_DetachCurrentThread(JavaVM *vm)  {
4082   HOTSPOT_JNI_DETACHCURRENTTHREAD_ENTRY(vm);
4083   if (vm_created == 0) {
4084     HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN(JNI_ERR);
4085     return JNI_ERR;
4086   }
4087 
4088   JNIWrapper(&quot;DetachCurrentThread&quot;);
4089 
4090   Thread* current = Thread::current_or_null();
4091 
4092   // If the thread has already been detached the operation is a no-op
4093   if (current == NULL) {
4094     HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN(JNI_OK);
4095     return JNI_OK;
4096   }
4097 
4098   // If executing from an atexit hook we may be in the VMThread.
4099   if (!current-&gt;is_Java_thread()) {
4100     HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN((uint32_t) JNI_ERR);
4101     return JNI_ERR;
4102   }
4103 
4104   VM_Exit::block_if_vm_exited();
4105 
4106   JavaThread* thread = (JavaThread*) current;
4107   if (thread-&gt;has_last_Java_frame()) {
4108     HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN((uint32_t) JNI_ERR);
4109     // Can&#39;t detach a thread that&#39;s running java, that can&#39;t work.
4110     return JNI_ERR;
4111   }
4112 
4113   // Safepoint support. Have to do call-back to safepoint code, if in the
4114   // middle of a safepoint operation
4115   ThreadStateTransition::transition_from_native(thread, _thread_in_vm);
4116 
4117   // XXX: Note that JavaThread::exit() call below removes the guards on the
4118   // stack pages set up via enable_stack_{red,yellow}_zone() calls
4119   // above in jni_AttachCurrentThread. Unfortunately, while the setting
4120   // of the guards is visible in jni_AttachCurrentThread above,
4121   // the removal of the guards is buried below in JavaThread::exit()
4122   // here. The abstraction should be more symmetrically either exposed
4123   // or hidden (e.g. it could probably be hidden in the same
4124   // (platform-dependent) methods where we do alternate stack
4125   // maintenance work?)
4126   thread-&gt;exit(false, JavaThread::jni_detach);
4127   thread-&gt;smr_delete();
4128 
4129   HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN(JNI_OK);
4130   return JNI_OK;
4131 }
4132 
4133 DT_RETURN_MARK_DECL(GetEnv, jint
4134                     , HOTSPOT_JNI_GETENV_RETURN(_ret_ref));
4135 
4136 jint JNICALL jni_GetEnv(JavaVM *vm, void **penv, jint version) {
4137   HOTSPOT_JNI_GETENV_ENTRY(vm, penv, version);
4138   jint ret = JNI_ERR;
4139   DT_RETURN_MARK(GetEnv, jint, (const jint&amp;)ret);
4140 
4141   if (vm_created == 0) {
4142     *penv = NULL;
4143     ret = JNI_EDETACHED;
4144     return ret;
4145   }
4146 
4147   if (JniExportedInterface::GetExportedInterface(vm, penv, version, &amp;ret)) {
4148     return ret;
4149   }
4150 
4151 #ifndef JVMPI_VERSION_1
4152 // need these in order to be polite about older agents
4153 #define JVMPI_VERSION_1   ((jint)0x10000001)
4154 #define JVMPI_VERSION_1_1 ((jint)0x10000002)
4155 #define JVMPI_VERSION_1_2 ((jint)0x10000003)
4156 #endif // !JVMPI_VERSION_1
4157 
4158   Thread* thread = Thread::current_or_null();
4159   if (thread != NULL &amp;&amp; thread-&gt;is_Java_thread()) {
4160     if (Threads::is_supported_jni_version_including_1_1(version)) {
4161       *(JNIEnv**)penv = ((JavaThread*) thread)-&gt;jni_environment();
4162       ret = JNI_OK;
4163       return ret;
4164 
4165     } else if (version == JVMPI_VERSION_1 ||
4166                version == JVMPI_VERSION_1_1 ||
4167                version == JVMPI_VERSION_1_2) {
4168       tty-&gt;print_cr(&quot;ERROR: JVMPI, an experimental interface, is no longer supported.&quot;);
4169       tty-&gt;print_cr(&quot;Please use the supported interface: the JVM Tool Interface (JVM TI).&quot;);
4170       ret = JNI_EVERSION;
4171       return ret;
4172     } else if (JvmtiExport::is_jvmdi_version(version)) {
4173       tty-&gt;print_cr(&quot;FATAL ERROR: JVMDI is no longer supported.&quot;);
4174       tty-&gt;print_cr(&quot;Please use the supported interface: the JVM Tool Interface (JVM TI).&quot;);
4175       ret = JNI_EVERSION;
4176       return ret;
4177     } else {
4178       *penv = NULL;
4179       ret = JNI_EVERSION;
4180       return ret;
4181     }
4182   } else {
4183     *penv = NULL;
4184     ret = JNI_EDETACHED;
4185     return ret;
4186   }
4187 }
4188 
4189 
4190 jint JNICALL jni_AttachCurrentThreadAsDaemon(JavaVM *vm, void **penv, void *_args) {
4191   HOTSPOT_JNI_ATTACHCURRENTTHREADASDAEMON_ENTRY(vm, penv, _args);
4192   if (vm_created == 0) {
4193   HOTSPOT_JNI_ATTACHCURRENTTHREADASDAEMON_RETURN((uint32_t) JNI_ERR);
4194     return JNI_ERR;
4195   }
4196 
4197   JNIWrapper(&quot;AttachCurrentThreadAsDaemon&quot;);
4198   jint ret = attach_current_thread(vm, penv, _args, true);
4199   HOTSPOT_JNI_ATTACHCURRENTTHREADASDAEMON_RETURN(ret);
4200   return ret;
4201 }
4202 
4203 
4204 } // End extern &quot;C&quot;
4205 
4206 const struct JNIInvokeInterface_ jni_InvokeInterface = {
4207     NULL,
4208     NULL,
4209     NULL,
4210 
4211     jni_DestroyJavaVM,
4212     jni_AttachCurrentThread,
4213     jni_DetachCurrentThread,
4214     jni_GetEnv,
4215     jni_AttachCurrentThreadAsDaemon
4216 };
    </pre>
  </body>
</html>
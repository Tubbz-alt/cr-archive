<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/classfile/systemDictionaryShared.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2014, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/classFileStream.hpp&quot;
  27 #include &quot;classfile/classListParser.hpp&quot;
  28 #include &quot;classfile/classLoader.hpp&quot;
  29 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  30 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  31 #include &quot;classfile/classLoaderExt.hpp&quot;
  32 #include &quot;classfile/dictionary.hpp&quot;
  33 #include &quot;classfile/javaClasses.hpp&quot;
  34 #include &quot;classfile/symbolTable.hpp&quot;
  35 #include &quot;classfile/systemDictionary.hpp&quot;
  36 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  37 #include &quot;classfile/verificationType.hpp&quot;
  38 #include &quot;classfile/vmSymbols.hpp&quot;
  39 #include &quot;logging/log.hpp&quot;
  40 #include &quot;memory/allocation.hpp&quot;
  41 #include &quot;memory/archiveUtils.hpp&quot;
  42 #include &quot;memory/filemap.hpp&quot;
  43 #include &quot;memory/metadataFactory.hpp&quot;
  44 #include &quot;memory/metaspaceClosure.hpp&quot;
  45 #include &quot;memory/oopFactory.hpp&quot;
  46 #include &quot;memory/resourceArea.hpp&quot;
  47 #include &quot;memory/universe.hpp&quot;
  48 #include &quot;memory/dynamicArchive.hpp&quot;
  49 #include &quot;oops/instanceKlass.hpp&quot;
  50 #include &quot;oops/klass.inline.hpp&quot;
  51 #include &quot;oops/objArrayOop.inline.hpp&quot;
  52 #include &quot;oops/oop.inline.hpp&quot;
  53 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  54 #include &quot;runtime/handles.inline.hpp&quot;
  55 #include &quot;runtime/java.hpp&quot;
  56 #include &quot;runtime/javaCalls.hpp&quot;
  57 #include &quot;runtime/mutexLocker.hpp&quot;
  58 #include &quot;utilities/hashtable.inline.hpp&quot;
  59 #include &quot;utilities/resourceHash.hpp&quot;
  60 #include &quot;utilities/stringUtils.hpp&quot;
  61 
  62 
  63 objArrayOop SystemDictionaryShared::_shared_protection_domains  =  NULL;
  64 objArrayOop SystemDictionaryShared::_shared_jar_urls            =  NULL;
  65 objArrayOop SystemDictionaryShared::_shared_jar_manifests       =  NULL;
  66 DEBUG_ONLY(bool SystemDictionaryShared::_no_class_loading_should_happen = false;)
  67 
  68 class DumpTimeSharedClassInfo: public CHeapObj&lt;mtClass&gt; {
  69   bool                         _excluded;
  70 public:
  71   struct DTConstraint {
  72     Symbol* _name;
  73     Symbol* _from_name;
  74     DTConstraint() : _name(NULL), _from_name(NULL) {}
  75     DTConstraint(Symbol* n, Symbol* fn) : _name(n), _from_name(fn) {}
  76   };
  77 
  78   InstanceKlass*               _klass;
  79   bool                         _failed_verification;
  80   int                          _id;
  81   int                          _clsfile_size;
  82   int                          _clsfile_crc32;
  83   GrowableArray&lt;DTConstraint&gt;* _verifier_constraints;
  84   GrowableArray&lt;char&gt;*         _verifier_constraint_flags;
  85 
  86   DumpTimeSharedClassInfo() {
  87     _klass = NULL;
  88     _failed_verification = false;
  89     _id = -1;
  90     _clsfile_size = -1;
  91     _clsfile_crc32 = -1;
  92     _excluded = false;
  93     _verifier_constraints = NULL;
  94     _verifier_constraint_flags = NULL;
  95   }
  96 
  97   void add_verification_constraint(InstanceKlass* k, Symbol* name,
  98          Symbol* from_name, bool from_field_is_protected, bool from_is_array, bool from_is_object);
  99 
 100   bool is_builtin() {
 101     return SystemDictionaryShared::is_builtin(_klass);
 102   }
 103 
 104   int num_constraints() {
 105     if (_verifier_constraint_flags != NULL) {
 106       return _verifier_constraint_flags-&gt;length();
 107     } else {
 108       return 0;
 109     }
 110   }
 111 
 112   void metaspace_pointers_do(MetaspaceClosure* it) {
 113     it-&gt;push(&amp;_klass);
 114     if (_verifier_constraints != NULL) {
 115       for (int i = 0; i &lt; _verifier_constraints-&gt;length(); i++) {
 116         DTConstraint* cons = _verifier_constraints-&gt;adr_at(i);
 117         it-&gt;push(&amp;cons-&gt;_name);
 118         it-&gt;push(&amp;cons-&gt;_from_name);
 119       }
 120     }
 121   }
 122 
 123   void set_excluded() {
 124     _excluded = true;
 125   }
 126 
 127   bool is_excluded() {
 128     // _klass may become NULL due to DynamicArchiveBuilder::set_to_null
 129     return _excluded || _failed_verification || _klass == NULL;
 130   }
 131 
 132   void set_failed_verification() {
 133     _failed_verification = true;
 134   }
 135 
 136   bool failed_verification() {
 137     return _failed_verification;
 138   }
 139 };
 140 
 141 class DumpTimeSharedClassTable: public ResourceHashtable&lt;
 142   InstanceKlass*,
 143   DumpTimeSharedClassInfo,
 144   primitive_hash&lt;InstanceKlass*&gt;,
 145   primitive_equals&lt;InstanceKlass*&gt;,
 146   15889, // prime number
 147   ResourceObj::C_HEAP&gt;
 148 {
 149   int _builtin_count;
 150   int _unregistered_count;
 151 public:
 152   DumpTimeSharedClassInfo* find_or_allocate_info_for(InstanceKlass* k) {
 153     DumpTimeSharedClassInfo* p = get(k);
 154     if (p == NULL) {
 155       assert(!SystemDictionaryShared::no_class_loading_should_happen(),
 156              &quot;no new classes can be loaded while dumping archive&quot;);
 157       put(k, DumpTimeSharedClassInfo());
 158       p = get(k);
 159       assert(p != NULL, &quot;sanity&quot;);
 160       p-&gt;_klass = k;
 161     }
 162     return p;
 163   }
 164 
 165   class CountClassByCategory : StackObj {
 166     DumpTimeSharedClassTable* _table;
 167   public:
 168     CountClassByCategory(DumpTimeSharedClassTable* table) : _table(table) {}
 169     bool do_entry(InstanceKlass* k, DumpTimeSharedClassInfo&amp; info) {
 170       if (!info.is_excluded()) {
 171         if (info.is_builtin()) {
 172           ++ _table-&gt;_builtin_count;
 173         } else {
 174           ++ _table-&gt;_unregistered_count;
 175         }
 176       }
 177       return true; // keep on iterating
 178     }
 179   };
 180 
 181   void update_counts() {
 182     _builtin_count = 0;
 183     _unregistered_count = 0;
 184     CountClassByCategory counter(this);
 185     iterate(&amp;counter);
 186   }
 187 
 188   int count_of(bool is_builtin) const {
 189     if (is_builtin) {
 190       return _builtin_count;
 191     } else {
 192       return _unregistered_count;
 193     }
 194   }
 195 };
 196 
 197 class RunTimeSharedClassInfo {
 198 public:
 199   struct CrcInfo {
 200     int _clsfile_size;
 201     int _clsfile_crc32;
 202   };
 203 
 204   // This is different than  DumpTimeSharedClassInfo::DTConstraint. We use
 205   // u4 instead of Symbol* to save space on 64-bit CPU.
 206   struct RTConstraint {
 207     u4 _name;
 208     u4 _from_name;
 209   };
 210 
 211   InstanceKlass* _klass;
 212   int _num_constraints;
 213 
 214   // optional CrcInfo      _crc;  (only for UNREGISTERED classes)
 215   // optional RTConstraint _verifier_constraints[_num_constraints]
 216   // optional char         _verifier_constraint_flags[_num_constraints]
 217 
 218 private:
 219   static size_t header_size_size() {
 220     return sizeof(RunTimeSharedClassInfo);
 221   }
 222   static size_t crc_size(InstanceKlass* klass) {
 223     if (!SystemDictionaryShared::is_builtin(klass)) {
 224       return sizeof(CrcInfo);
 225     } else {
 226       return 0;
 227     }
 228   }
 229   static size_t verifier_constraints_size(int num_constraints) {
 230     return sizeof(RTConstraint) * num_constraints;
 231   }
 232   static size_t verifier_constraint_flags_size(int num_constraints) {
 233     return sizeof(char) * num_constraints;
 234   }
 235 
 236 public:
 237   static size_t byte_size(InstanceKlass* klass, int num_constraints) {
 238     return header_size_size() +
 239            crc_size(klass) +
 240            verifier_constraints_size(num_constraints) +
 241            verifier_constraint_flags_size(num_constraints);
 242   }
 243 
 244 private:
 245   size_t crc_offset() const {
 246     return header_size_size();
 247   }
 248   size_t verifier_constraints_offset() const {
 249     return crc_offset() + crc_size(_klass);
 250   }
 251   size_t verifier_constraint_flags_offset() const {
 252     return verifier_constraints_offset() + verifier_constraints_size(_num_constraints);
 253   }
 254 
 255   void check_constraint_offset(int i) const {
 256     assert(0 &lt;= i &amp;&amp; i &lt; _num_constraints, &quot;sanity&quot;);
 257   }
 258 
 259 public:
 260   CrcInfo* crc() const {
 261     assert(crc_size(_klass) &gt; 0, &quot;must be&quot;);
 262     return (CrcInfo*)(address(this) + crc_offset());
 263   }
 264   RTConstraint* verifier_constraints() {
 265     assert(_num_constraints &gt; 0, &quot;sanity&quot;);
 266     return (RTConstraint*)(address(this) + verifier_constraints_offset());
 267   }
 268   RTConstraint* verifier_constraint_at(int i) {
 269     check_constraint_offset(i);
 270     return verifier_constraints() + i;
 271   }
 272 
 273   char* verifier_constraint_flags() {
 274     assert(_num_constraints &gt; 0, &quot;sanity&quot;);
 275     return (char*)(address(this) + verifier_constraint_flags_offset());
 276   }
 277 
 278   static u4 object_delta_u4(Symbol* sym) {
 279     if (DynamicDumpSharedSpaces) {
 280       sym = DynamicArchive::original_to_target(sym);
 281     }
 282     return MetaspaceShared::object_delta_u4(sym);
 283   }
 284 
 285   void init(DumpTimeSharedClassInfo&amp; info) {
 286     _klass = info._klass;
 287     if (!SystemDictionaryShared::is_builtin(_klass)) {
 288       CrcInfo* c = crc();
 289       c-&gt;_clsfile_size = info._clsfile_size;
 290       c-&gt;_clsfile_crc32 = info._clsfile_crc32;
 291     }
 292     _num_constraints = info.num_constraints();
 293     if (_num_constraints &gt; 0) {
 294       RTConstraint* constraints = verifier_constraints();
 295       char* flags = verifier_constraint_flags();
 296       int i;
 297       for (i = 0; i &lt; _num_constraints; i++) {
 298         constraints[i]._name      = object_delta_u4(info._verifier_constraints-&gt;at(i)._name);
 299         constraints[i]._from_name = object_delta_u4(info._verifier_constraints-&gt;at(i)._from_name);
 300       }
 301       for (i = 0; i &lt; _num_constraints; i++) {
 302         flags[i] = info._verifier_constraint_flags-&gt;at(i);
 303       }
 304     }
 305     if (DynamicDumpSharedSpaces) {
 306       _klass = DynamicArchive::original_to_target(info._klass);
 307     }
 308     ArchivePtrMarker::mark_pointer(&amp;_klass);
 309   }
 310 
 311   bool matches(int clsfile_size, int clsfile_crc32) const {
 312     return crc()-&gt;_clsfile_size  == clsfile_size &amp;&amp;
 313            crc()-&gt;_clsfile_crc32 == clsfile_crc32;
 314   }
 315 
 316   Symbol* get_constraint_name(int i) {
 317     return (Symbol*)(SharedBaseAddress + verifier_constraint_at(i)-&gt;_name);
 318   }
 319   Symbol* get_constraint_from_name(int i) {
 320     return (Symbol*)(SharedBaseAddress + verifier_constraint_at(i)-&gt;_from_name);
 321   }
 322 
 323   char get_constraint_flag(int i) {
 324     check_constraint_offset(i);
 325     return verifier_constraint_flags()[i];
 326   }
 327 
 328 private:
 329   // ArchiveCompactor::allocate() has reserved a pointer immediately before
 330   // archived InstanceKlasses. We can use this slot to do a quick
 331   // lookup of InstanceKlass* -&gt; RunTimeSharedClassInfo* without
 332   // building a new hashtable.
 333   //
 334   //  info_pointer_addr(klass) --&gt; 0x0100   RunTimeSharedClassInfo*
 335   //  InstanceKlass* klass     --&gt; 0x0108   &lt;C++ vtbl&gt;
 336   //                               0x0110   fields from Klass ...
 337   static RunTimeSharedClassInfo** info_pointer_addr(InstanceKlass* klass) {
 338     return &amp;((RunTimeSharedClassInfo**)klass)[-1];
 339   }
 340 
 341 public:
 342   static RunTimeSharedClassInfo* get_for(InstanceKlass* klass) {
 343     return *info_pointer_addr(klass);
 344   }
 345   static void set_for(InstanceKlass* klass, RunTimeSharedClassInfo* record) {
 346     if (DynamicDumpSharedSpaces) {
 347       klass = DynamicArchive::original_to_buffer(klass);
 348       *info_pointer_addr(klass) = DynamicArchive::buffer_to_target(record);
 349     } else {
 350       *info_pointer_addr(klass) = record;
 351     }
 352 
 353     ArchivePtrMarker::mark_pointer(info_pointer_addr(klass));
 354   }
 355 
 356   // Used by RunTimeSharedDictionary to implement OffsetCompactHashtable::EQUALS
 357   static inline bool EQUALS(
 358        const RunTimeSharedClassInfo* value, Symbol* key, int len_unused) {
 359     return (value-&gt;_klass-&gt;name() == key);
 360   }
 361 };
 362 
 363 class RunTimeSharedDictionary : public OffsetCompactHashtable&lt;
 364   Symbol*,
 365   const RunTimeSharedClassInfo*,
 366   RunTimeSharedClassInfo::EQUALS&gt; {};
 367 
 368 static DumpTimeSharedClassTable* _dumptime_table = NULL;
 369 // SystemDictionaries in the base layer static archive
 370 static RunTimeSharedDictionary _builtin_dictionary;
 371 static RunTimeSharedDictionary _unregistered_dictionary;
 372 // SystemDictionaries in the top layer dynamic archive
 373 static RunTimeSharedDictionary _dynamic_builtin_dictionary;
 374 static RunTimeSharedDictionary _dynamic_unregistered_dictionary;
 375 
 376 oop SystemDictionaryShared::shared_protection_domain(int index) {
 377   return _shared_protection_domains-&gt;obj_at(index);
 378 }
 379 
 380 oop SystemDictionaryShared::shared_jar_url(int index) {
 381   return _shared_jar_urls-&gt;obj_at(index);
 382 }
 383 
 384 oop SystemDictionaryShared::shared_jar_manifest(int index) {
 385   return _shared_jar_manifests-&gt;obj_at(index);
 386 }
 387 
 388 
 389 Handle SystemDictionaryShared::get_shared_jar_manifest(int shared_path_index, TRAPS) {
 390   Handle manifest ;
 391   if (shared_jar_manifest(shared_path_index) == NULL) {
 392     SharedClassPathEntry* ent = FileMapInfo::shared_path(shared_path_index);
 393     long size = ent-&gt;manifest_size();
 394     if (size &lt;= 0) {
 395       return Handle();
 396     }
 397 
 398     // ByteArrayInputStream bais = new ByteArrayInputStream(buf);
 399     const char* src = ent-&gt;manifest();
 400     assert(src != NULL, &quot;No Manifest data&quot;);
 401     typeArrayOop buf = oopFactory::new_byteArray(size, CHECK_NH);
 402     typeArrayHandle bufhandle(THREAD, buf);
 403     ArrayAccess&lt;&gt;::arraycopy_from_native(reinterpret_cast&lt;const jbyte*&gt;(src),
 404                                          buf, typeArrayOopDesc::element_offset&lt;jbyte&gt;(0), size);
 405 
 406     Handle bais = JavaCalls::construct_new_instance(SystemDictionary::ByteArrayInputStream_klass(),
 407                       vmSymbols::byte_array_void_signature(),
 408                       bufhandle, CHECK_NH);
 409 
 410     // manifest = new Manifest(bais)
 411     manifest = JavaCalls::construct_new_instance(SystemDictionary::Jar_Manifest_klass(),
 412                       vmSymbols::input_stream_void_signature(),
 413                       bais, CHECK_NH);
 414     atomic_set_shared_jar_manifest(shared_path_index, manifest());
 415   }
 416 
 417   manifest = Handle(THREAD, shared_jar_manifest(shared_path_index));
 418   assert(manifest.not_null(), &quot;sanity&quot;);
 419   return manifest;
 420 }
 421 
 422 Handle SystemDictionaryShared::get_shared_jar_url(int shared_path_index, TRAPS) {
 423   Handle url_h;
 424   if (shared_jar_url(shared_path_index) == NULL) {
 425     JavaValue result(T_OBJECT);
 426     const char* path = FileMapInfo::shared_path_name(shared_path_index);
 427     Handle path_string = java_lang_String::create_from_str(path, CHECK_(url_h));
 428     Klass* classLoaders_klass =
 429         SystemDictionary::jdk_internal_loader_ClassLoaders_klass();
 430     JavaCalls::call_static(&amp;result, classLoaders_klass,
 431                            vmSymbols::toFileURL_name(),
 432                            vmSymbols::toFileURL_signature(),
 433                            path_string, CHECK_(url_h));
 434 
 435     atomic_set_shared_jar_url(shared_path_index, (oop)result.get_jobject());
 436   }
 437 
 438   url_h = Handle(THREAD, shared_jar_url(shared_path_index));
 439   assert(url_h.not_null(), &quot;sanity&quot;);
 440   return url_h;
 441 }
 442 
 443 Handle SystemDictionaryShared::get_package_name(Symbol* class_name, TRAPS) {
 444   ResourceMark rm(THREAD);
 445   Handle pkgname_string;
 446   Symbol* pkg = ClassLoader::package_from_class_name(class_name);
 447   if (pkg != NULL) { // Package prefix found
 448     const char* pkgname = pkg-&gt;as_klass_external_name();
 449     pkgname_string = java_lang_String::create_from_str(pkgname,
 450                                                        CHECK_(pkgname_string));
 451   }
 452   return pkgname_string;
 453 }
 454 
 455 // Define Package for shared app classes from JAR file and also checks for
 456 // package sealing (all done in Java code)
 457 // See http://docs.oracle.com/javase/tutorial/deployment/jar/sealman.html
 458 void SystemDictionaryShared::define_shared_package(Symbol*  class_name,
 459                                                    Handle class_loader,
 460                                                    Handle manifest,
 461                                                    Handle url,
 462                                                    TRAPS) {
 463   assert(SystemDictionary::is_system_class_loader(class_loader()), &quot;unexpected class loader&quot;);
 464   // get_package_name() returns a NULL handle if the class is in unnamed package
 465   Handle pkgname_string = get_package_name(class_name, CHECK);
 466   if (pkgname_string.not_null()) {
 467     Klass* app_classLoader_klass = SystemDictionary::jdk_internal_loader_ClassLoaders_AppClassLoader_klass();
 468     JavaValue result(T_OBJECT);
 469     JavaCallArguments args(3);
 470     args.set_receiver(class_loader);
 471     args.push_oop(pkgname_string);
 472     args.push_oop(manifest);
 473     args.push_oop(url);
 474     JavaCalls::call_virtual(&amp;result, app_classLoader_klass,
 475                             vmSymbols::defineOrCheckPackage_name(),
 476                             vmSymbols::defineOrCheckPackage_signature(),
 477                             &amp;args,
 478                             CHECK);
 479   }
 480 }
 481 
 482 // Define Package for shared app/platform classes from named module
 483 void SystemDictionaryShared::define_shared_package(Symbol* class_name,
 484                                                    Handle class_loader,
 485                                                    ModuleEntry* mod_entry,
 486                                                    TRAPS) {
 487   assert(mod_entry != NULL, &quot;module_entry should not be NULL&quot;);
 488   Handle module_handle(THREAD, mod_entry-&gt;module());
 489 
 490   Handle pkg_name = get_package_name(class_name, CHECK);
 491   assert(pkg_name.not_null(), &quot;Package should not be null for class in named module&quot;);
 492 
 493   Klass* classLoader_klass;
 494   if (SystemDictionary::is_system_class_loader(class_loader())) {
 495     classLoader_klass = SystemDictionary::jdk_internal_loader_ClassLoaders_AppClassLoader_klass();
 496   } else {
 497     assert(SystemDictionary::is_platform_class_loader(class_loader()), &quot;unexpected classloader&quot;);
 498     classLoader_klass = SystemDictionary::jdk_internal_loader_ClassLoaders_PlatformClassLoader_klass();
 499   }
 500 
 501   JavaValue result(T_OBJECT);
 502   JavaCallArguments args(2);
 503   args.set_receiver(class_loader);
 504   args.push_oop(pkg_name);
 505   args.push_oop(module_handle);
 506   JavaCalls::call_virtual(&amp;result, classLoader_klass,
 507                           vmSymbols::definePackage_name(),
 508                           vmSymbols::definePackage_signature(),
 509                           &amp;args,
 510                           CHECK);
 511 }
 512 
 513 // Get the ProtectionDomain associated with the CodeSource from the classloader.
 514 Handle SystemDictionaryShared::get_protection_domain_from_classloader(Handle class_loader,
 515                                                                       Handle url, TRAPS) {
 516   // CodeSource cs = new CodeSource(url, null);
 517   Handle cs = JavaCalls::construct_new_instance(SystemDictionary::CodeSource_klass(),
 518                   vmSymbols::url_code_signer_array_void_signature(),
 519                   url, Handle(), CHECK_NH);
 520 
 521   // protection_domain = SecureClassLoader.getProtectionDomain(cs);
 522   Klass* secureClassLoader_klass = SystemDictionary::SecureClassLoader_klass();
 523   JavaValue obj_result(T_OBJECT);
 524   JavaCalls::call_virtual(&amp;obj_result, class_loader, secureClassLoader_klass,
 525                           vmSymbols::getProtectionDomain_name(),
 526                           vmSymbols::getProtectionDomain_signature(),
 527                           cs, CHECK_NH);
 528   return Handle(THREAD, (oop)obj_result.get_jobject());
 529 }
 530 
 531 // Returns the ProtectionDomain associated with the JAR file identified by the url.
 532 Handle SystemDictionaryShared::get_shared_protection_domain(Handle class_loader,
 533                                                             int shared_path_index,
 534                                                             Handle url,
 535                                                             TRAPS) {
 536   Handle protection_domain;
 537   if (shared_protection_domain(shared_path_index) == NULL) {
 538     Handle pd = get_protection_domain_from_classloader(class_loader, url, THREAD);
 539     atomic_set_shared_protection_domain(shared_path_index, pd());
 540   }
 541 
 542   // Acquire from the cache because if another thread beats the current one to
 543   // set the shared protection_domain and the atomic_set fails, the current thread
 544   // needs to get the updated protection_domain from the cache.
 545   protection_domain = Handle(THREAD, shared_protection_domain(shared_path_index));
 546   assert(protection_domain.not_null(), &quot;sanity&quot;);
 547   return protection_domain;
 548 }
 549 
 550 // Returns the ProtectionDomain associated with the moduleEntry.
 551 Handle SystemDictionaryShared::get_shared_protection_domain(Handle class_loader,
 552                                                             ModuleEntry* mod, TRAPS) {
 553   ClassLoaderData *loader_data = mod-&gt;loader_data();
 554   if (mod-&gt;shared_protection_domain() == NULL) {
 555     Symbol* location = mod-&gt;location();
 556     if (location != NULL) {
 557       Handle location_string = java_lang_String::create_from_symbol(
 558                                      location, CHECK_NH);
 559       Handle url;
 560       JavaValue result(T_OBJECT);
 561       if (location-&gt;starts_with(&quot;jrt:/&quot;)) {
 562         url = JavaCalls::construct_new_instance(SystemDictionary::URL_klass(),
 563                                                 vmSymbols::string_void_signature(),
 564                                                 location_string, CHECK_NH);
 565       } else {
 566         Klass* classLoaders_klass =
 567           SystemDictionary::jdk_internal_loader_ClassLoaders_klass();
 568         JavaCalls::call_static(&amp;result, classLoaders_klass, vmSymbols::toFileURL_name(),
 569                                vmSymbols::toFileURL_signature(),
 570                                location_string, CHECK_NH);
 571         url = Handle(THREAD, (oop)result.get_jobject());
 572       }
 573 
 574       Handle pd = get_protection_domain_from_classloader(class_loader, url,
 575                                                          CHECK_NH);
 576       mod-&gt;set_shared_protection_domain(loader_data, pd);
 577     }
 578   }
 579 
 580   Handle protection_domain(THREAD, mod-&gt;shared_protection_domain());
 581   assert(protection_domain.not_null(), &quot;sanity&quot;);
 582   return protection_domain;
 583 }
 584 
 585 // Initializes the java.lang.Package and java.security.ProtectionDomain objects associated with
 586 // the given InstanceKlass.
 587 // Returns the ProtectionDomain for the InstanceKlass.
 588 Handle SystemDictionaryShared::init_security_info(Handle class_loader, InstanceKlass* ik, PackageEntry* pkg_entry, TRAPS) {
 589   Handle pd;
 590 
 591   if (ik != NULL) {
 592     int index = ik-&gt;shared_classpath_index();
 593     assert(index &gt;= 0, &quot;Sanity&quot;);
 594     SharedClassPathEntry* ent = FileMapInfo::shared_path(index);
 595     Symbol* class_name = ik-&gt;name();
 596 
 597     if (ent-&gt;is_modules_image()) {
 598       // For shared app/platform classes originated from the run-time image:
 599       //   The ProtectionDomains are cached in the corresponding ModuleEntries
 600       //   for fast access by the VM.
 601       if (pkg_entry != NULL) {
 602         ModuleEntry* mod_entry = pkg_entry-&gt;module();
 603         pd = get_shared_protection_domain(class_loader, mod_entry, THREAD);
 604         define_shared_package(class_name, class_loader, mod_entry, CHECK_(pd));
 605       }
 606     } else {
 607       // For shared app/platform classes originated from JAR files on the class path:
 608       //   Each of the 3 SystemDictionaryShared::_shared_xxx arrays has the same length
 609       //   as the shared classpath table in the shared archive (see
 610       //   FileMap::_shared_path_table in filemap.hpp for details).
 611       //
 612       //   If a shared InstanceKlass k is loaded from the class path, let
 613       //
 614       //     index = k-&gt;shared_classpath_index():
 615       //
 616       //   FileMap::_shared_path_table[index] identifies the JAR file that contains k.
 617       //
 618       //   k&#39;s protection domain is:
 619       //
 620       //     ProtectionDomain pd = _shared_protection_domains[index];
 621       //
 622       //   and k&#39;s Package is initialized using
 623       //
 624       //     manifest = _shared_jar_manifests[index];
 625       //     url = _shared_jar_urls[index];
 626       //     define_shared_package(class_name, class_loader, manifest, url, CHECK_(pd));
 627       //
 628       //   Note that if an element of these 3 _shared_xxx arrays is NULL, it will be initialized by
 629       //   the corresponding SystemDictionaryShared::get_shared_xxx() function.
 630       Handle manifest = get_shared_jar_manifest(index, CHECK_(pd));
 631       Handle url = get_shared_jar_url(index, CHECK_(pd));
 632       define_shared_package(class_name, class_loader, manifest, url, CHECK_(pd));
 633       pd = get_shared_protection_domain(class_loader, index, url, CHECK_(pd));
 634     }
 635   }
 636   return pd;
 637 }
 638 
 639 bool SystemDictionaryShared::is_sharing_possible(ClassLoaderData* loader_data) {
 640   oop class_loader = loader_data-&gt;class_loader();
 641   return (class_loader == NULL ||
 642           SystemDictionary::is_system_class_loader(class_loader) ||
 643           SystemDictionary::is_platform_class_loader(class_loader));
 644 }
 645 
 646 // Currently AppCDS only archives classes from the run-time image, the
 647 // -Xbootclasspath/a path, the class path, and the module path.
 648 //
 649 // Check if a shared class can be loaded by the specific classloader. Following
 650 // are the &quot;visible&quot; archived classes for different classloaders.
 651 //
 652 // NULL classloader:
 653 //   - see SystemDictionary::is_shared_class_visible()
 654 // Platform classloader:
 655 //   - Module class from runtime image. ModuleEntry must be defined in the
 656 //     classloader.
 657 // App classloader:
 658 //   - Module Class from runtime image and module path. ModuleEntry must be defined in the
 659 //     classloader.
 660 //   - Class from -cp. The class must have no PackageEntry defined in any of the
 661 //     boot/platform/app classloader, or must be in the unnamed module defined in the
 662 //     AppClassLoader.
 663 bool SystemDictionaryShared::is_shared_class_visible_for_classloader(
 664                                                      InstanceKlass* ik,
 665                                                      Handle class_loader,
 666                                                      Symbol* pkg_name,
 667                                                      PackageEntry* pkg_entry,
 668                                                      ModuleEntry* mod_entry,
 669                                                      TRAPS) {
 670   assert(class_loader.not_null(), &quot;Class loader should not be NULL&quot;);
 671   assert(Universe::is_module_initialized(), &quot;Module system is not initialized&quot;);
 672   ResourceMark rm(THREAD);
 673 
 674   int path_index = ik-&gt;shared_classpath_index();
 675   SharedClassPathEntry* ent =
 676             (SharedClassPathEntry*)FileMapInfo::shared_path(path_index);
 677 
 678   if (SystemDictionary::is_platform_class_loader(class_loader())) {
 679     assert(ent != NULL, &quot;shared class for PlatformClassLoader should have valid SharedClassPathEntry&quot;);
 680     // The PlatformClassLoader can only load archived class originated from the
 681     // run-time image. The class&#39; PackageEntry/ModuleEntry must be
 682     // defined by the PlatformClassLoader.
 683     if (mod_entry != NULL) {
 684       // PackageEntry/ModuleEntry is found in the classloader. Check if the
 685       // ModuleEntry&#39;s location agrees with the archived class&#39; origination.
 686       if (ent-&gt;is_modules_image() &amp;&amp; mod_entry-&gt;location()-&gt;starts_with(&quot;jrt:&quot;)) {
 687         return true; // Module class from the runtime image
 688       }
 689     }
 690   } else if (SystemDictionary::is_system_class_loader(class_loader())) {
 691     assert(ent != NULL, &quot;shared class for system loader should have valid SharedClassPathEntry&quot;);
 692     if (pkg_name == NULL) {
 693       // The archived class is in the unnamed package. Currently, the boot image
 694       // does not contain any class in the unnamed package.
 695       assert(!ent-&gt;is_modules_image(), &quot;Class in the unnamed package must be from the classpath&quot;);
 696       if (path_index &gt;= ClassLoaderExt::app_class_paths_start_index()) {
 697         assert(path_index &lt; ClassLoaderExt::app_module_paths_start_index(), &quot;invalid path_index&quot;);
 698         return true;
 699       }
 700     } else {
 701       // Check if this is from a PackageEntry/ModuleEntry defined in the AppClassloader.
 702       if (pkg_entry == NULL) {
 703         // It&#39;s not guaranteed that the class is from the classpath if the
 704         // PackageEntry cannot be found from the AppClassloader. Need to check
 705         // the boot and platform classloader as well.
 706         ClassLoaderData* platform_loader_data =
 707           ClassLoaderData::class_loader_data_or_null(SystemDictionary::java_platform_loader()); // can be NULL during bootstrap
 708         if ((platform_loader_data == NULL ||
 709              ClassLoader::get_package_entry(pkg_name, platform_loader_data) == NULL) &amp;&amp;
 710              ClassLoader::get_package_entry(pkg_name, ClassLoaderData::the_null_class_loader_data()) == NULL) {
 711           // The PackageEntry is not defined in any of the boot/platform/app classloaders.
 712           // The archived class must from -cp path and not from the runtime image.
 713           if (!ent-&gt;is_modules_image() &amp;&amp; path_index &gt;= ClassLoaderExt::app_class_paths_start_index() &amp;&amp;
 714                                           path_index &lt; ClassLoaderExt::app_module_paths_start_index()) {
 715             return true;
 716           }
 717         }
 718       } else if (mod_entry != NULL) {
 719         // The package/module is defined in the AppClassLoader. We support
 720         // archiving application module class from the runtime image or from
 721         // a named module from a module path.
 722         // Packages from the -cp path are in the unnamed_module.
 723         if (ent-&gt;is_modules_image() &amp;&amp; mod_entry-&gt;location()-&gt;starts_with(&quot;jrt:&quot;)) {
 724           // shared module class from runtime image
 725           return true;
 726         } else if (pkg_entry-&gt;in_unnamed_module() &amp;&amp; path_index &gt;= ClassLoaderExt::app_class_paths_start_index() &amp;&amp;
 727             path_index &lt; ClassLoaderExt::app_module_paths_start_index()) {
 728           // shared class from -cp
 729           DEBUG_ONLY( \
 730             ClassLoaderData* loader_data = class_loader_data(class_loader); \
 731             assert(mod_entry == loader_data-&gt;unnamed_module(), &quot;the unnamed module is not defined in the classloader&quot;);)
 732           return true;
 733         } else {
 734           if(!pkg_entry-&gt;in_unnamed_module() &amp;&amp;
 735               (path_index &gt;= ClassLoaderExt::app_module_paths_start_index())&amp;&amp;
 736               (path_index &lt; FileMapInfo::get_number_of_shared_paths()) &amp;&amp;
 737               (strcmp(ent-&gt;name(), ClassLoader::skip_uri_protocol(mod_entry-&gt;location()-&gt;as_C_string())) == 0)) {
 738             // shared module class from module path
 739             return true;
 740           } else {
 741             assert(path_index &lt; FileMapInfo::get_number_of_shared_paths(), &quot;invalid path_index&quot;);
 742           }
 743         }
 744       }
 745     }
 746   } else {
 747     // TEMP: if a shared class can be found by a custom loader, consider it visible now.
 748     // FIXME: is this actually correct?
 749     return true;
 750   }
 751   return false;
 752 }
 753 
 754 bool SystemDictionaryShared::has_platform_or_app_classes() {
 755   if (FileMapInfo::current_info()-&gt;has_platform_or_app_classes()) {
 756     return true;
 757   }
 758   if (DynamicArchive::is_mapped() &amp;&amp;
 759       FileMapInfo::dynamic_info()-&gt;has_platform_or_app_classes()) {
 760     return true;
 761   }
 762   return false;
 763 }
 764 
 765 // The following stack shows how this code is reached:
 766 //
 767 //   [0] SystemDictionaryShared::find_or_load_shared_class()
 768 //   [1] JVM_FindLoadedClass
 769 //   [2] java.lang.ClassLoader.findLoadedClass0()
 770 //   [3] java.lang.ClassLoader.findLoadedClass()
 771 //   [4] jdk.internal.loader.BuiltinClassLoader.loadClassOrNull()
 772 //   [5] jdk.internal.loader.BuiltinClassLoader.loadClass()
 773 //   [6] jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(), or
 774 //       jdk.internal.loader.ClassLoaders$PlatformClassLoader.loadClass()
 775 //
 776 // AppCDS supports fast class loading for these 2 built-in class loaders:
 777 //    jdk.internal.loader.ClassLoaders$PlatformClassLoader
 778 //    jdk.internal.loader.ClassLoaders$AppClassLoader
 779 // with the following assumptions (based on the JDK core library source code):
 780 //
 781 // [a] these two loaders use the BuiltinClassLoader.loadClassOrNull() to
 782 //     load the named class.
 783 // [b] BuiltinClassLoader.loadClassOrNull() first calls findLoadedClass(name).
 784 // [c] At this point, if we can find the named class inside the
 785 //     shared_dictionary, we can perform further checks (see
 786 //     is_shared_class_visible_for_classloader() to ensure that this class
 787 //     was loaded by the same class loader during dump time.
 788 //
 789 // Given these assumptions, we intercept the findLoadedClass() call to invoke
 790 // SystemDictionaryShared::find_or_load_shared_class() to load the shared class from
 791 // the archive for the 2 built-in class loaders. This way,
 792 // we can improve start-up because we avoid decoding the classfile,
 793 // and avoid delegating to the parent loader.
 794 //
 795 // NOTE: there&#39;s a lot of assumption about the Java code. If any of that change, this
 796 // needs to be redesigned.
 797 
 798 InstanceKlass* SystemDictionaryShared::find_or_load_shared_class(
 799                  Symbol* name, Handle class_loader, TRAPS) {
 800   InstanceKlass* k = NULL;
 801   if (UseSharedSpaces) {
 802     if (!has_platform_or_app_classes()) {
 803       return NULL;
 804     }
 805 
 806     if (SystemDictionary::is_system_class_loader(class_loader()) ||
 807         SystemDictionary::is_platform_class_loader(class_loader())) {
 808       // Fix for 4474172; see evaluation for more details
 809       class_loader = Handle(
 810         THREAD, java_lang_ClassLoader::non_reflection_class_loader(class_loader()));
 811       ClassLoaderData *loader_data = register_loader(class_loader);
 812       Dictionary* dictionary = loader_data-&gt;dictionary();
 813 
 814       unsigned int d_hash = dictionary-&gt;compute_hash(name);
 815 
 816       bool DoObjectLock = true;
 817       if (is_parallelCapable(class_loader)) {
 818         DoObjectLock = false;
 819       }
 820 
 821       // Make sure we are synchronized on the class loader before we proceed
 822       //
 823       // Note: currently, find_or_load_shared_class is called only from
 824       // JVM_FindLoadedClass and used for PlatformClassLoader and AppClassLoader,
 825       // which are parallel-capable loaders, so this lock is NOT taken.
 826       Handle lockObject = compute_loader_lock_object(class_loader, THREAD);
 827       check_loader_lock_contention(lockObject, THREAD);
 828       ObjectLocker ol(lockObject, THREAD, DoObjectLock);
 829 
 830       {
 831         MutexLocker mu(THREAD, SystemDictionary_lock);
 832         InstanceKlass* check = find_class(d_hash, name, dictionary);
 833         if (check != NULL) {
 834           return check;
 835         }
 836       }
 837 
 838       k = load_shared_class_for_builtin_loader(name, class_loader, THREAD);
 839       if (k != NULL) {
 840         define_instance_class(k, CHECK_NULL);
 841       }
 842     }
 843   }
 844   return k;
 845 }
 846 
 847 PackageEntry* SystemDictionaryShared::get_package_entry_from_class_name(Handle class_loader, Symbol* class_name) {
 848   PackageEntry* pkg_entry = NULL;
 849   TempNewSymbol pkg_name = ClassLoader::package_from_class_name(class_name);
 850   if (pkg_name != NULL) {
 851     pkg_entry = class_loader_data(class_loader)-&gt;packages()-&gt;lookup_only(pkg_name);
 852   }
 853   return pkg_entry;
 854 }
 855 
 856 InstanceKlass* SystemDictionaryShared::load_shared_class_for_builtin_loader(
 857                  Symbol* class_name, Handle class_loader, TRAPS) {
 858   assert(UseSharedSpaces, &quot;must be&quot;);
 859   InstanceKlass* ik = find_builtin_class(class_name);
 860 
 861   if (ik != NULL) {
 862     if ((ik-&gt;is_shared_app_class() &amp;&amp;
 863          SystemDictionary::is_system_class_loader(class_loader()))  ||
 864         (ik-&gt;is_shared_platform_class() &amp;&amp;
 865          SystemDictionary::is_platform_class_loader(class_loader()))) {
 866       PackageEntry* pkg_entry = get_package_entry_from_class_name(class_loader, class_name);
 867       Handle protection_domain =
 868         SystemDictionaryShared::init_security_info(class_loader, ik, pkg_entry, CHECK_NULL);
 869       return load_shared_class(ik, class_loader, protection_domain, NULL, pkg_entry, THREAD);
 870     }
 871   }
 872   return NULL;
 873 }
 874 
 875 void SystemDictionaryShared::oops_do(OopClosure* f) {
 876   f-&gt;do_oop((oop*)&amp;_shared_protection_domains);
 877   f-&gt;do_oop((oop*)&amp;_shared_jar_urls);
 878   f-&gt;do_oop((oop*)&amp;_shared_jar_manifests);
 879 }
 880 
 881 void SystemDictionaryShared::allocate_shared_protection_domain_array(int size, TRAPS) {
 882   if (_shared_protection_domains == NULL) {
 883     _shared_protection_domains = oopFactory::new_objArray(
 884         SystemDictionary::ProtectionDomain_klass(), size, CHECK);
 885   }
 886 }
 887 
 888 void SystemDictionaryShared::allocate_shared_jar_url_array(int size, TRAPS) {
 889   if (_shared_jar_urls == NULL) {
 890     _shared_jar_urls = oopFactory::new_objArray(
 891         SystemDictionary::URL_klass(), size, CHECK);
 892   }
 893 }
 894 
 895 void SystemDictionaryShared::allocate_shared_jar_manifest_array(int size, TRAPS) {
 896   if (_shared_jar_manifests == NULL) {
 897     _shared_jar_manifests = oopFactory::new_objArray(
 898         SystemDictionary::Jar_Manifest_klass(), size, CHECK);
 899   }
 900 }
 901 
 902 void SystemDictionaryShared::allocate_shared_data_arrays(int size, TRAPS) {
 903   allocate_shared_protection_domain_array(size, CHECK);
 904   allocate_shared_jar_url_array(size, CHECK);
 905   allocate_shared_jar_manifest_array(size, CHECK);
 906 }
 907 
 908 // This function is called for loading only UNREGISTERED classes
 909 InstanceKlass* SystemDictionaryShared::lookup_from_stream(Symbol* class_name,
 910                                                           Handle class_loader,
 911                                                           Handle protection_domain,
 912                                                           const ClassFileStream* cfs,
 913                                                           TRAPS) {
 914   if (!UseSharedSpaces) {
 915     return NULL;
 916   }
 917   if (class_name == NULL) {  // don&#39;t do this for anonymous classes
 918     return NULL;
 919   }
 920   if (class_loader.is_null() ||
 921       SystemDictionary::is_system_class_loader(class_loader()) ||
 922       SystemDictionary::is_platform_class_loader(class_loader())) {
 923     // Do nothing for the BUILTIN loaders.
 924     return NULL;
 925   }
 926 
 927   const RunTimeSharedClassInfo* record = find_record(&amp;_unregistered_dictionary, &amp;_dynamic_unregistered_dictionary, class_name);
 928   if (record == NULL) {
 929     return NULL;
 930   }
 931 
 932   int clsfile_size  = cfs-&gt;length();
 933   int clsfile_crc32 = ClassLoader::crc32(0, (const char*)cfs-&gt;buffer(), cfs-&gt;length());
 934 
 935   if (!record-&gt;matches(clsfile_size, clsfile_crc32)) {
 936     return NULL;
 937   }
 938 
 939   return acquire_class_for_current_thread(record-&gt;_klass, class_loader,
 940                                           protection_domain, cfs,
 941                                           THREAD);
 942 }
 943 
 944 InstanceKlass* SystemDictionaryShared::acquire_class_for_current_thread(
 945                    InstanceKlass *ik,
 946                    Handle class_loader,
 947                    Handle protection_domain,
 948                    const ClassFileStream *cfs,
 949                    TRAPS) {
 950   ClassLoaderData* loader_data = ClassLoaderData::class_loader_data(class_loader());
 951 
 952   {
 953     MutexLocker mu(THREAD, SharedDictionary_lock);
 954     if (ik-&gt;class_loader_data() != NULL) {
 955       //    ik is already loaded (by this loader or by a different loader)
 956       // or ik is being loaded by a different thread (by this loader or by a different loader)
 957       return NULL;
 958     }
 959 
 960     // No other thread has acquired this yet, so give it to *this thread*
 961     ik-&gt;set_class_loader_data(loader_data);
 962   }
 963 
 964   // No longer holding SharedDictionary_lock
 965   // No need to lock, as &lt;ik&gt; can be held only by a single thread.
 966   loader_data-&gt;add_class(ik);
 967 
 968   // Get the package entry.
 969   PackageEntry* pkg_entry = get_package_entry_from_class_name(class_loader, ik-&gt;name());
 970 
 971   // Load and check super/interfaces, restore unsharable info
 972   InstanceKlass* shared_klass = load_shared_class(ik, class_loader, protection_domain,
 973                                                   cfs, pkg_entry, THREAD);
 974   if (shared_klass == NULL || HAS_PENDING_EXCEPTION) {
 975     // TODO: clean up &lt;ik&gt; so it can be used again
 976     return NULL;
 977   }
 978 
 979   return shared_klass;
 980 }
 981 
 982 static ResourceHashtable&lt;
 983   Symbol*, bool,
 984   primitive_hash&lt;Symbol*&gt;,
 985   primitive_equals&lt;Symbol*&gt;,
 986   6661,                             // prime number
 987   ResourceObj::C_HEAP&gt; _loaded_unregistered_classes;
 988 
 989 bool SystemDictionaryShared::add_unregistered_class(InstanceKlass* k, TRAPS) {
 990   assert(DumpSharedSpaces, &quot;only when dumping&quot;);
 991 
 992   Symbol* name = k-&gt;name();
 993   if (_loaded_unregistered_classes.get(name) != NULL) {
 994     // We don&#39;t allow duplicated unregistered classes of the same name.
 995     return false;
 996   } else {
 997     bool isnew = _loaded_unregistered_classes.put(name, true);
 998     assert(isnew, &quot;sanity&quot;);
 999     MutexLocker mu_r(THREAD, Compile_lock); // add_to_hierarchy asserts this.
1000     SystemDictionary::add_to_hierarchy(k, CHECK_false);
1001     return true;
1002   }
1003 }
1004 
1005 // This function is called to resolve the super/interfaces of shared classes for
1006 // non-built-in loaders. E.g., ChildClass in the below example
1007 // where &quot;super:&quot; (and optionally &quot;interface:&quot;) have been specified.
1008 //
1009 // java/lang/Object id: 0
1010 // Interface   id: 2 super: 0 source: cust.jar
1011 // ChildClass  id: 4 super: 0 interfaces: 2 source: cust.jar
1012 InstanceKlass* SystemDictionaryShared::dump_time_resolve_super_or_fail(
1013     Symbol* child_name, Symbol* class_name, Handle class_loader,
1014     Handle protection_domain, bool is_superclass, TRAPS) {
1015 
1016   assert(DumpSharedSpaces, &quot;only when dumping&quot;);
1017 
1018   ClassListParser* parser = ClassListParser::instance();
1019   if (parser == NULL) {
1020     // We&#39;re still loading the well-known classes, before the ClassListParser is created.
1021     return NULL;
1022   }
1023   if (child_name-&gt;equals(parser-&gt;current_class_name())) {
1024     // When this function is called, all the numbered super and interface types
1025     // must have already been loaded. Hence this function is never recursively called.
1026     if (is_superclass) {
1027       return parser-&gt;lookup_super_for_current_class(class_name);
1028     } else {
1029       return parser-&gt;lookup_interface_for_current_class(class_name);
1030     }
1031   } else {
1032     // The VM is not trying to resolve a super type of parser-&gt;current_class_name().
1033     // Instead, it&#39;s resolving an error class (because parser-&gt;current_class_name() has
1034     // failed parsing or verification). Don&#39;t do anything here.
1035     return NULL;
1036   }
1037 }
1038 
1039 DumpTimeSharedClassInfo* SystemDictionaryShared::find_or_allocate_info_for(InstanceKlass* k) {
1040   MutexLocker ml(DumpTimeTable_lock, Mutex::_no_safepoint_check_flag);
1041   if (_dumptime_table == NULL) {
1042     _dumptime_table = new (ResourceObj::C_HEAP, mtClass)DumpTimeSharedClassTable();
1043   }
1044   return _dumptime_table-&gt;find_or_allocate_info_for(k);
1045 }
1046 
1047 void SystemDictionaryShared::set_shared_class_misc_info(InstanceKlass* k, ClassFileStream* cfs) {
1048   Arguments::assert_is_dumping_archive();
1049   assert(!is_builtin(k), &quot;must be unregistered class&quot;);
1050   DumpTimeSharedClassInfo* info = find_or_allocate_info_for(k);
1051   info-&gt;_clsfile_size  = cfs-&gt;length();
1052   info-&gt;_clsfile_crc32 = ClassLoader::crc32(0, (const char*)cfs-&gt;buffer(), cfs-&gt;length());
1053 }
1054 
1055 void SystemDictionaryShared::init_dumptime_info(InstanceKlass* k) {
1056   (void)find_or_allocate_info_for(k);
1057 }
1058 
1059 void SystemDictionaryShared::remove_dumptime_info(InstanceKlass* k) {
1060   MutexLocker ml(DumpTimeTable_lock, Mutex::_no_safepoint_check_flag);
1061   DumpTimeSharedClassInfo* p = _dumptime_table-&gt;get(k);
1062   if (p == NULL) {
1063     return;
1064   }
1065   if (p-&gt;_verifier_constraints != NULL) {
1066     for (int i = 0; i &lt; p-&gt;_verifier_constraints-&gt;length(); i++) {
1067       DumpTimeSharedClassInfo::DTConstraint constraint = p-&gt;_verifier_constraints-&gt;at(i);
1068       if (constraint._name != NULL ) {
1069         constraint._name-&gt;decrement_refcount();
1070       }
1071       if (constraint._from_name != NULL ) {
1072         constraint._from_name-&gt;decrement_refcount();
1073       }
1074     }
1075     FREE_C_HEAP_ARRAY(DTConstraint, p-&gt;_verifier_constraints);
1076     p-&gt;_verifier_constraints = NULL;
1077   }
1078   FREE_C_HEAP_ARRAY(char, p-&gt;_verifier_constraint_flags);
1079   p-&gt;_verifier_constraint_flags = NULL;
1080   _dumptime_table-&gt;remove(k);
1081 }
1082 
1083 bool SystemDictionaryShared::is_jfr_event_class(InstanceKlass *k) {
1084   while (k) {
1085     if (k-&gt;name()-&gt;equals(&quot;jdk/internal/event/Event&quot;)) {
1086       return true;
1087     }
1088     k = k-&gt;java_super();
1089   }
1090   return false;
1091 }
1092 
1093 void SystemDictionaryShared::warn_excluded(InstanceKlass* k, const char* reason) {
1094   ResourceMark rm;
1095   log_warning(cds)(&quot;Skipping %s: %s&quot;, k-&gt;name()-&gt;as_C_string(), reason);
1096 }
1097 
1098 bool SystemDictionaryShared::should_be_excluded(InstanceKlass* k) {
1099   if (k-&gt;class_loader_data()-&gt;is_unsafe_anonymous()) {
1100     warn_excluded(k, &quot;Unsafe anonymous class&quot;);
1101     return true; // unsafe anonymous classes are not archived, skip
1102   }
1103   if (k-&gt;is_in_error_state()) {
1104     warn_excluded(k, &quot;In error state&quot;);
1105     return true;
1106   }
1107   if (k-&gt;has_been_redefined()) {
1108     warn_excluded(k, &quot;Has been redefined&quot;);
1109     return true;
1110   }
1111   if (k-&gt;shared_classpath_index() &lt; 0 &amp;&amp; is_builtin(k)) {
1112     // These are classes loaded from unsupported locations (such as those loaded by JVMTI native
1113     // agent during dump time).
1114     warn_excluded(k, &quot;Unsupported location&quot;);
1115     return true;
1116   }
1117   if (k-&gt;signers() != NULL) {
1118     // We cannot include signed classes in the archive because the certificates
1119     // used during dump time may be different than those used during
1120     // runtime (due to expiration, etc).
1121     warn_excluded(k, &quot;Signed JAR&quot;);
1122     return true;
1123   }
1124   if (is_jfr_event_class(k)) {
1125     // We cannot include JFR event classes because they need runtime-specific
1126     // instrumentation in order to work with -XX:FlightRecorderOptions=retransform=false.
1127     // There are only a small number of these classes, so it&#39;s not worthwhile to
1128     // support them and make CDS more complicated.
1129     warn_excluded(k, &quot;JFR event class&quot;);
1130     return true;
1131   }
1132   if (k-&gt;init_state() &lt; InstanceKlass::linked) {
1133     // In CDS dumping, we will attempt to link all classes. Those that fail to link will
1134     // be recorded in DumpTimeSharedClassInfo.
1135     Arguments::assert_is_dumping_archive();
1136 
1137     // TODO -- rethink how this can be handled.
1138     // We should try to link ik, however, we can&#39;t do it here because
1139     // 1. We are at VM exit
1140     // 2. linking a class may cause other classes to be loaded, which means
1141     //    a custom ClassLoader.loadClass() may be called, at a point where the
1142     //    class loader doesn&#39;t expect it.
1143     if (has_class_failed_verification(k)) {
1144       warn_excluded(k, &quot;Failed verification&quot;);
1145     } else {
1146       warn_excluded(k, &quot;Not linked&quot;);
1147     }
1148     return true;
1149   }
1150   if (k-&gt;major_version() &lt; 50 /*JAVA_6_VERSION*/) {
1151     ResourceMark rm;
1152     log_warning(cds)(&quot;Pre JDK 6 class not supported by CDS: %u.%u %s&quot;,
1153                      k-&gt;major_version(),  k-&gt;minor_version(), k-&gt;name()-&gt;as_C_string());
1154     return true;
1155   }
1156 
1157   InstanceKlass* super = k-&gt;java_super();
1158   if (super != NULL &amp;&amp; should_be_excluded(super)) {
1159     ResourceMark rm;
1160     log_warning(cds)(&quot;Skipping %s: super class %s is excluded&quot;, k-&gt;name()-&gt;as_C_string(), super-&gt;name()-&gt;as_C_string());
1161     return true;
1162   }
1163 
1164   Array&lt;InstanceKlass*&gt;* interfaces = k-&gt;local_interfaces();
1165   int len = interfaces-&gt;length();
1166   for (int i = 0; i &lt; len; i++) {
1167     InstanceKlass* intf = interfaces-&gt;at(i);
1168     if (should_be_excluded(intf)) {
1169       log_warning(cds)(&quot;Skipping %s: interface %s is excluded&quot;, k-&gt;name()-&gt;as_C_string(), intf-&gt;name()-&gt;as_C_string());
1170       return true;
1171     }
1172   }
1173 
1174   return false;
1175 }
1176 
1177 // k is a class before relocating by ArchiveCompactor
1178 void SystemDictionaryShared::validate_before_archiving(InstanceKlass* k) {
1179   ResourceMark rm;
1180   const char* name = k-&gt;name()-&gt;as_C_string();
1181   DumpTimeSharedClassInfo* info = _dumptime_table-&gt;get(k);
1182   assert(_no_class_loading_should_happen, &quot;class loading must be disabled&quot;);
1183   guarantee(info != NULL, &quot;Class %s must be entered into _dumptime_table&quot;, name);
1184   guarantee(!info-&gt;is_excluded(), &quot;Should not attempt to archive excluded class %s&quot;, name);
1185   if (is_builtin(k)) {
1186     guarantee(!k-&gt;is_shared_unregistered_class(),
1187               &quot;Class loader type must be set for BUILTIN class %s&quot;, name);
1188   } else {
1189     guarantee(k-&gt;is_shared_unregistered_class(),
1190               &quot;Class loader type must not be set for UNREGISTERED class %s&quot;, name);
1191   }
1192 }
1193 
1194 class ExcludeDumpTimeSharedClasses : StackObj {
1195 public:
1196   bool do_entry(InstanceKlass* k, DumpTimeSharedClassInfo&amp; info) {
1197     if (SystemDictionaryShared::should_be_excluded(k)) {
1198       info.set_excluded();
1199     }
1200     return true; // keep on iterating
1201   }
1202 };
1203 
1204 void SystemDictionaryShared::check_excluded_classes() {
1205   ExcludeDumpTimeSharedClasses excl;
1206   _dumptime_table-&gt;iterate(&amp;excl);
1207   _dumptime_table-&gt;update_counts();
1208 }
1209 
1210 bool SystemDictionaryShared::is_excluded_class(InstanceKlass* k) {
1211   assert(_no_class_loading_should_happen, &quot;sanity&quot;);
1212   Arguments::assert_is_dumping_archive();
1213   return find_or_allocate_info_for(k)-&gt;is_excluded();
1214 }
1215 
1216 void SystemDictionaryShared::set_class_has_failed_verification(InstanceKlass* ik) {
1217   Arguments::assert_is_dumping_archive();
1218   find_or_allocate_info_for(ik)-&gt;set_failed_verification();
1219 }
1220 
1221 bool SystemDictionaryShared::has_class_failed_verification(InstanceKlass* ik) {
1222   Arguments::assert_is_dumping_archive();
1223   if (_dumptime_table == NULL) {
1224     assert(DynamicDumpSharedSpaces, &quot;sanity&quot;);
1225     assert(ik-&gt;is_shared(), &quot;must be a shared class in the static archive&quot;);
1226     return false;
1227   }
1228   DumpTimeSharedClassInfo* p = _dumptime_table-&gt;get(ik);
1229   return (p == NULL) ? false : p-&gt;failed_verification();
1230 }
1231 
1232 class IterateDumpTimeSharedClassTable : StackObj {
1233   MetaspaceClosure *_it;
1234 public:
1235   IterateDumpTimeSharedClassTable(MetaspaceClosure* it) : _it(it) {}
1236 
1237   bool do_entry(InstanceKlass* k, DumpTimeSharedClassInfo&amp; info) {
1238     if (!info.is_excluded()) {
1239       info.metaspace_pointers_do(_it);
1240     }
1241     return true; // keep on iterating
1242   }
1243 };
1244 
1245 void SystemDictionaryShared::dumptime_classes_do(class MetaspaceClosure* it) {
1246   IterateDumpTimeSharedClassTable iter(it);
1247   _dumptime_table-&gt;iterate(&amp;iter);
1248 }
1249 
1250 bool SystemDictionaryShared::add_verification_constraint(InstanceKlass* k, Symbol* name,
1251          Symbol* from_name, bool from_field_is_protected, bool from_is_array, bool from_is_object) {
1252   Arguments::assert_is_dumping_archive();
1253   DumpTimeSharedClassInfo* info = find_or_allocate_info_for(k);
1254   info-&gt;add_verification_constraint(k, name, from_name, from_field_is_protected,
1255                                     from_is_array, from_is_object);
1256 
1257   if (DynamicDumpSharedSpaces) {
1258     // For dynamic dumping, we can resolve all the constraint classes for all class loaders during
1259     // the initial run prior to creating the archive before vm exit. We will also perform verification
1260     // check when running with the archive.
1261     return false;
1262   } else {
1263     if (is_builtin(k)) {
1264       // For builtin class loaders, we can try to complete the verification check at dump time,
1265       // because we can resolve all the constraint classes. We will also perform verification check
1266       // when running with the archive.
1267       return false;
1268     } else {
1269       // For non-builtin class loaders, we cannot complete the verification check at dump time,
1270       // because at dump time we don&#39;t know how to resolve classes for such loaders.
1271       return true;
1272     }
1273   }
1274 }
1275 
1276 void DumpTimeSharedClassInfo::add_verification_constraint(InstanceKlass* k, Symbol* name,
1277          Symbol* from_name, bool from_field_is_protected, bool from_is_array, bool from_is_object) {
1278   if (_verifier_constraints == NULL) {
1279     _verifier_constraints = new(ResourceObj::C_HEAP, mtClass) GrowableArray&lt;DTConstraint&gt;(4, true, mtClass);
1280   }
1281   if (_verifier_constraint_flags == NULL) {
1282     _verifier_constraint_flags = new(ResourceObj::C_HEAP, mtClass) GrowableArray&lt;char&gt;(4, true, mtClass);
1283   }
1284   GrowableArray&lt;DTConstraint&gt;* vc_array = _verifier_constraints;
1285   for (int i = 0; i &lt; vc_array-&gt;length(); i++) {
1286     DTConstraint* p = vc_array-&gt;adr_at(i);
1287     if (name == p-&gt;_name &amp;&amp; from_name == p-&gt;_from_name) {
1288       return;
1289     }
1290   }
1291   DTConstraint cons(name, from_name);
1292   vc_array-&gt;append(cons);
1293 
1294   GrowableArray&lt;char&gt;* vcflags_array = _verifier_constraint_flags;
1295   char c = 0;
1296   c |= from_field_is_protected ? SystemDictionaryShared::FROM_FIELD_IS_PROTECTED : 0;
1297   c |= from_is_array           ? SystemDictionaryShared::FROM_IS_ARRAY           : 0;
1298   c |= from_is_object          ? SystemDictionaryShared::FROM_IS_OBJECT          : 0;
1299   vcflags_array-&gt;append(c);
1300 
1301   if (log_is_enabled(Trace, cds, verification)) {
1302     ResourceMark rm;
1303     log_trace(cds, verification)(&quot;add_verification_constraint: %s: %s must be subclass of %s [0x%x]&quot;,
1304                                  k-&gt;external_name(), from_name-&gt;as_klass_external_name(),
1305                                  name-&gt;as_klass_external_name(), c);
1306   }
1307 }
1308 
1309 void SystemDictionaryShared::check_verification_constraints(InstanceKlass* klass,
1310                                                             TRAPS) {
1311   assert(!DumpSharedSpaces &amp;&amp; UseSharedSpaces, &quot;called at run time with CDS enabled only&quot;);
1312   RunTimeSharedClassInfo* record = RunTimeSharedClassInfo::get_for(klass);
1313 
1314   int length = record-&gt;_num_constraints;
1315   if (length &gt; 0) {
1316     for (int i = 0; i &lt; length; i++) {
1317       Symbol* name      = record-&gt;get_constraint_name(i);
1318       Symbol* from_name = record-&gt;get_constraint_from_name(i);
1319       char c            = record-&gt;get_constraint_flag(i);
1320 
1321       if (log_is_enabled(Trace, cds, verification)) {
1322         ResourceMark rm(THREAD);
1323         log_trace(cds, verification)(&quot;check_verification_constraint: %s: %s must be subclass of %s [0x%x]&quot;,
1324                                      klass-&gt;external_name(), from_name-&gt;as_klass_external_name(),
1325                                      name-&gt;as_klass_external_name(), c);
1326       }
1327 
1328       bool from_field_is_protected = (c &amp; SystemDictionaryShared::FROM_FIELD_IS_PROTECTED) ? true : false;
1329       bool from_is_array           = (c &amp; SystemDictionaryShared::FROM_IS_ARRAY)           ? true : false;
1330       bool from_is_object          = (c &amp; SystemDictionaryShared::FROM_IS_OBJECT)          ? true : false;
1331 
1332       bool ok = VerificationType::resolve_and_check_assignability(klass, name,
1333          from_name, from_field_is_protected, from_is_array, from_is_object, CHECK);
1334       if (!ok) {
1335         ResourceMark rm(THREAD);
1336         stringStream ss;
1337 
1338         ss.print_cr(&quot;Bad type on operand stack&quot;);
1339         ss.print_cr(&quot;Exception Details:&quot;);
1340         ss.print_cr(&quot;  Location:\n    %s&quot;, klass-&gt;name()-&gt;as_C_string());
1341         ss.print_cr(&quot;  Reason:\n    Type &#39;%s&#39; is not assignable to &#39;%s&#39;&quot;,
1342                     from_name-&gt;as_quoted_ascii(), name-&gt;as_quoted_ascii());
1343         THROW_MSG(vmSymbols::java_lang_VerifyError(), ss.as_string());
1344       }
1345     }
1346   }
1347 }
1348 
1349 class EstimateSizeForArchive : StackObj {
1350   size_t _shared_class_info_size;
1351   int _num_builtin_klasses;
1352   int _num_unregistered_klasses;
1353 
1354 public:
1355   EstimateSizeForArchive() {
1356     _shared_class_info_size = 0;
1357     _num_builtin_klasses = 0;
1358     _num_unregistered_klasses = 0;
1359   }
1360 
1361   bool do_entry(InstanceKlass* k, DumpTimeSharedClassInfo&amp; info) {
1362     if (!info.is_excluded()) {
1363       size_t byte_size = RunTimeSharedClassInfo::byte_size(info._klass, info.num_constraints());
1364       _shared_class_info_size += align_up(byte_size, BytesPerWord);
1365     }
1366     return true; // keep on iterating
1367   }
1368 
1369   size_t total() {
1370     return _shared_class_info_size;
1371   }
1372 };
1373 
1374 size_t SystemDictionaryShared::estimate_size_for_archive() {
1375   EstimateSizeForArchive est;
1376   _dumptime_table-&gt;iterate(&amp;est);
1377   return est.total() +
1378     CompactHashtableWriter::estimate_size(_dumptime_table-&gt;count_of(true)) +
1379     CompactHashtableWriter::estimate_size(_dumptime_table-&gt;count_of(false));
1380 }
1381 
1382 class CopySharedClassInfoToArchive : StackObj {
1383   CompactHashtableWriter* _writer;
1384   bool _is_builtin;
1385 public:
1386   CopySharedClassInfoToArchive(CompactHashtableWriter* writer,
1387                                bool is_builtin,
1388                                bool is_static_archive)
1389     : _writer(writer), _is_builtin(is_builtin) {}
1390 
1391   bool do_entry(InstanceKlass* k, DumpTimeSharedClassInfo&amp; info) {
1392     if (!info.is_excluded() &amp;&amp; info.is_builtin() == _is_builtin) {
1393       size_t byte_size = RunTimeSharedClassInfo::byte_size(info._klass, info.num_constraints());
1394       RunTimeSharedClassInfo* record;
1395       record = (RunTimeSharedClassInfo*)MetaspaceShared::read_only_space_alloc(byte_size);
1396       record-&gt;init(info);
1397 
1398       unsigned int hash;
1399       Symbol* name = info._klass-&gt;name();
1400       if (DynamicDumpSharedSpaces) {
1401         name = DynamicArchive::original_to_target(name);
1402       }
1403       hash = SystemDictionaryShared::hash_for_shared_dictionary(name);
1404       u4 delta;
1405       if (DynamicDumpSharedSpaces) {
1406         delta = MetaspaceShared::object_delta_u4(DynamicArchive::buffer_to_target(record));
1407       } else {
1408         delta = MetaspaceShared::object_delta_u4(record);
1409       }
1410       _writer-&gt;add(hash, delta);
1411       if (log_is_enabled(Trace, cds, hashtables)) {
1412         ResourceMark rm;
1413         log_trace(cds,hashtables)(&quot;%s dictionary: %s&quot;, (_is_builtin ? &quot;builtin&quot; : &quot;unregistered&quot;), info._klass-&gt;external_name());
1414       }
1415 
1416       // Save this for quick runtime lookup of InstanceKlass* -&gt; RunTimeSharedClassInfo*
1417       RunTimeSharedClassInfo::set_for(info._klass, record);
1418     }
1419     return true; // keep on iterating
1420   }
1421 };
1422 
1423 void SystemDictionaryShared::write_dictionary(RunTimeSharedDictionary* dictionary,
1424                                               bool is_builtin,
1425                                               bool is_static_archive) {
1426   CompactHashtableStats stats;
1427   dictionary-&gt;reset();
1428   CompactHashtableWriter writer(_dumptime_table-&gt;count_of(is_builtin), &amp;stats);
1429   CopySharedClassInfoToArchive copy(&amp;writer, is_builtin, is_static_archive);
1430   _dumptime_table-&gt;iterate(&amp;copy);
1431   writer.dump(dictionary, is_builtin ? &quot;builtin dictionary&quot; : &quot;unregistered dictionary&quot;);
1432 }
1433 
1434 void SystemDictionaryShared::write_to_archive(bool is_static_archive) {
1435   if (is_static_archive) {
1436     write_dictionary(&amp;_builtin_dictionary, true);
1437     write_dictionary(&amp;_unregistered_dictionary, false);
1438   } else {
1439     write_dictionary(&amp;_dynamic_builtin_dictionary, true);
1440     write_dictionary(&amp;_dynamic_unregistered_dictionary, false);
1441   }
1442 }
1443 
1444 void SystemDictionaryShared::serialize_dictionary_headers(SerializeClosure* soc,
1445                                                           bool is_static_archive) {
1446   if (is_static_archive) {
1447     _builtin_dictionary.serialize_header(soc);
1448     _unregistered_dictionary.serialize_header(soc);
1449   } else {
1450     _dynamic_builtin_dictionary.serialize_header(soc);
1451     _dynamic_unregistered_dictionary.serialize_header(soc);
1452   }
1453 }
1454 
1455 void SystemDictionaryShared::serialize_well_known_klasses(SerializeClosure* soc) {
1456   for (int i = FIRST_WKID; i &lt; WKID_LIMIT; i++) {
1457     soc-&gt;do_ptr((void**)&amp;_well_known_klasses[i]);
1458   }
1459 }
1460 
1461 const RunTimeSharedClassInfo*
1462 SystemDictionaryShared::find_record(RunTimeSharedDictionary* static_dict, RunTimeSharedDictionary* dynamic_dict, Symbol* name) {
1463   if (!UseSharedSpaces || !name-&gt;is_shared()) {
1464     // The names of all shared classes must also be a shared Symbol.
1465     return NULL;
1466   }
1467 
1468   unsigned int hash = SystemDictionaryShared::hash_for_shared_dictionary(name);
1469   const RunTimeSharedClassInfo* record = NULL;
1470   if (!MetaspaceShared::is_shared_dynamic(name)) {
1471     // The names of all shared classes in the static dict must also be in the
1472     // static archive
1473     record = static_dict-&gt;lookup(name, hash, 0);
1474   }
1475 
1476   if (record == NULL &amp;&amp; DynamicArchive::is_mapped()) {
1477     record = dynamic_dict-&gt;lookup(name, hash, 0);
1478   }
1479 
1480   return record;
1481 }
1482 
1483 InstanceKlass* SystemDictionaryShared::find_builtin_class(Symbol* name) {
1484   const RunTimeSharedClassInfo* record = find_record(&amp;_builtin_dictionary, &amp;_dynamic_builtin_dictionary, name);
1485   if (record != NULL) {
1486     return record-&gt;_klass;
1487   } else {
1488     return NULL;
1489   }
1490 }
1491 
1492 void SystemDictionaryShared::update_shared_entry(InstanceKlass* k, int id) {
1493   assert(DumpSharedSpaces, &quot;supported only when dumping&quot;);
1494   DumpTimeSharedClassInfo* info = find_or_allocate_info_for(k);
1495   info-&gt;_id = id;
1496 }
1497 
1498 class SharedDictionaryPrinter : StackObj {
1499   outputStream* _st;
1500   int _index;
1501 public:
1502   SharedDictionaryPrinter(outputStream* st) : _st(st), _index(0) {}
1503 
1504   void do_value(const RunTimeSharedClassInfo* record) {
1505     ResourceMark rm;
1506     _st-&gt;print_cr(&quot;%4d:  %s&quot;, (_index++), record-&gt;_klass-&gt;external_name());
1507   }
1508 };
1509 
1510 void SystemDictionaryShared::print_on(outputStream* st) {
1511   if (UseSharedSpaces) {
1512     st-&gt;print_cr(&quot;Shared Dictionary&quot;);
1513     SharedDictionaryPrinter p(st);
1514     _builtin_dictionary.iterate(&amp;p);
1515     _unregistered_dictionary.iterate(&amp;p);
1516     if (DynamicArchive::is_mapped()) {
1517       _dynamic_builtin_dictionary.iterate(&amp;p);
1518       _unregistered_dictionary.iterate(&amp;p);
1519     }
1520   }
1521 }
1522 
1523 void SystemDictionaryShared::print_table_statistics(outputStream* st) {
1524   if (UseSharedSpaces) {
1525     _builtin_dictionary.print_table_statistics(st, &quot;Builtin Shared Dictionary&quot;);
1526     _unregistered_dictionary.print_table_statistics(st, &quot;Unregistered Shared Dictionary&quot;);
1527     if (DynamicArchive::is_mapped()) {
1528       _dynamic_builtin_dictionary.print_table_statistics(st, &quot;Dynamic Builtin Shared Dictionary&quot;);
1529       _dynamic_unregistered_dictionary.print_table_statistics(st, &quot;Unregistered Shared Dictionary&quot;);
1530     }
1531   }
1532 }
1533 
1534 bool SystemDictionaryShared::empty_dumptime_table() {
1535   if (_dumptime_table == NULL) {
1536     return true;
1537   }
1538   _dumptime_table-&gt;update_counts();
1539   if (_dumptime_table-&gt;count_of(true) == 0 &amp;&amp; _dumptime_table-&gt;count_of(false) == 0){
1540     return true;
1541   }
1542   return false;
1543 }
    </pre>
  </body>
</html>
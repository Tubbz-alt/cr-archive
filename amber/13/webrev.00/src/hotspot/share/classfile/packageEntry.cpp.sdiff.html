<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/packageEntry.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="modules.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="systemDictionary.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/packageEntry.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 72 void PackageEntry::set_export_walk_required(ClassLoaderData* m_loader_data) {
 73   assert_locked_or_safepoint(Module_lock);
 74   ModuleEntry* this_pkg_mod = module();
 75   if (!_must_walk_exports &amp;&amp;
 76       (this_pkg_mod == NULL || this_pkg_mod-&gt;loader_data() != m_loader_data) &amp;&amp;
 77       !m_loader_data-&gt;is_builtin_class_loader_data()) {
 78     _must_walk_exports = true;
 79     if (log_is_enabled(Trace, module)) {
 80       ResourceMark rm;
 81       assert(name() != NULL, &quot;PackageEntry without a valid name&quot;);
 82       log_trace(module)(&quot;PackageEntry::set_export_walk_required(): package %s defined in module %s, exports list must be walked&quot;,
 83                         name()-&gt;as_C_string(),
 84                         (this_pkg_mod == NULL || this_pkg_mod-&gt;name() == NULL) ?
 85                           UNNAMED_MODULE : this_pkg_mod-&gt;name()-&gt;as_C_string());
 86     }
 87   }
 88 }
 89 
 90 // Set the package&#39;s exported states based on the value of the ModuleEntry.
 91 void PackageEntry::set_exported(ModuleEntry* m) {
<span class="line-modified"> 92   MutexLocker m1(Module_lock);</span>
 93   if (is_unqual_exported()) {
 94     // An exception could be thrown, but choose to simply ignore.
 95     // Illegal to convert an unqualified exported package to be qualifiedly exported
 96     return;
 97   }
 98 
 99   if (m == NULL) {
100     // NULL indicates the package is being unqualifiedly exported.  Clean up
101     // the qualified list at the next safepoint.
102     set_unqual_exported();
103   } else {
104     // Add the exported module
105     add_qexport(m);
106   }
107 }
108 
109 // Set the package as exported to all unnamed modules unless the package is
110 // already unqualifiedly exported.
111 void PackageEntry::set_is_exported_allUnnamed() {
<span class="line-modified">112   if (module()-&gt;is_open()) {</span>
<span class="line-modified">113     // No-op for open modules since all packages are unqualifiedly exported</span>
<span class="line-removed">114     return;</span>
<span class="line-removed">115   }</span>
<span class="line-removed">116 </span>
<span class="line-removed">117   MutexLocker m1(Module_lock);</span>
118   if (!is_unqual_exported()) {
119    _export_flags = PKG_EXP_ALLUNNAMED;
120   }
121 }
122 
123 // Remove dead module entries within the package&#39;s exported list.  Note that
124 // if all of the modules on the _qualified_exports get purged the list does not
125 // get deleted.  This prevents the package from illegally transitioning from
126 // exported to non-exported.
127 void PackageEntry::purge_qualified_exports() {
128   assert_locked_or_safepoint(Module_lock);
129   if (_must_walk_exports &amp;&amp;
130       _qualified_exports != NULL &amp;&amp;
131       !_qualified_exports-&gt;is_empty()) {
<span class="line-removed">132     ModuleEntry* pkg_module = module();</span>
133 
134     // This package&#39;s _must_walk_exports flag will be reset based
135     // on the remaining live modules on the exports list.
136     _must_walk_exports = false;
137 
138     if (log_is_enabled(Trace, module)) {
139       ResourceMark rm;
140       assert(name() != NULL, &quot;PackageEntry without a valid name&quot;);
141       ModuleEntry* pkg_mod = module();
142       log_trace(module)(&quot;PackageEntry::purge_qualified_exports(): package %s defined in module %s, exports list being walked&quot;,
143                         name()-&gt;as_C_string(),
144                         (pkg_mod == NULL || pkg_mod-&gt;name() == NULL) ? UNNAMED_MODULE : pkg_mod-&gt;name()-&gt;as_C_string());
145     }
146 
147     // Go backwards because this removes entries that are dead.
148     int len = _qualified_exports-&gt;length();
149     for (int idx = len - 1; idx &gt;= 0; idx--) {
150       ModuleEntry* module_idx = _qualified_exports-&gt;at(idx);
151       ClassLoaderData* cld_idx = module_idx-&gt;loader_data();
152       if (cld_idx-&gt;is_unloading()) {
</pre>
</td>
<td>
<hr />
<pre>
 72 void PackageEntry::set_export_walk_required(ClassLoaderData* m_loader_data) {
 73   assert_locked_or_safepoint(Module_lock);
 74   ModuleEntry* this_pkg_mod = module();
 75   if (!_must_walk_exports &amp;&amp;
 76       (this_pkg_mod == NULL || this_pkg_mod-&gt;loader_data() != m_loader_data) &amp;&amp;
 77       !m_loader_data-&gt;is_builtin_class_loader_data()) {
 78     _must_walk_exports = true;
 79     if (log_is_enabled(Trace, module)) {
 80       ResourceMark rm;
 81       assert(name() != NULL, &quot;PackageEntry without a valid name&quot;);
 82       log_trace(module)(&quot;PackageEntry::set_export_walk_required(): package %s defined in module %s, exports list must be walked&quot;,
 83                         name()-&gt;as_C_string(),
 84                         (this_pkg_mod == NULL || this_pkg_mod-&gt;name() == NULL) ?
 85                           UNNAMED_MODULE : this_pkg_mod-&gt;name()-&gt;as_C_string());
 86     }
 87   }
 88 }
 89 
 90 // Set the package&#39;s exported states based on the value of the ModuleEntry.
 91 void PackageEntry::set_exported(ModuleEntry* m) {
<span class="line-modified"> 92   assert(Module_lock-&gt;owned_by_self(), &quot;should have the Module_lock&quot;);</span>
 93   if (is_unqual_exported()) {
 94     // An exception could be thrown, but choose to simply ignore.
 95     // Illegal to convert an unqualified exported package to be qualifiedly exported
 96     return;
 97   }
 98 
 99   if (m == NULL) {
100     // NULL indicates the package is being unqualifiedly exported.  Clean up
101     // the qualified list at the next safepoint.
102     set_unqual_exported();
103   } else {
104     // Add the exported module
105     add_qexport(m);
106   }
107 }
108 
109 // Set the package as exported to all unnamed modules unless the package is
110 // already unqualifiedly exported.
111 void PackageEntry::set_is_exported_allUnnamed() {
<span class="line-modified">112   assert(!module()-&gt;is_open(), &quot;should have been checked already&quot;);</span>
<span class="line-modified">113   assert(Module_lock-&gt;owned_by_self(), &quot;should have the Module_lock&quot;);</span>




114   if (!is_unqual_exported()) {
115    _export_flags = PKG_EXP_ALLUNNAMED;
116   }
117 }
118 
119 // Remove dead module entries within the package&#39;s exported list.  Note that
120 // if all of the modules on the _qualified_exports get purged the list does not
121 // get deleted.  This prevents the package from illegally transitioning from
122 // exported to non-exported.
123 void PackageEntry::purge_qualified_exports() {
124   assert_locked_or_safepoint(Module_lock);
125   if (_must_walk_exports &amp;&amp;
126       _qualified_exports != NULL &amp;&amp;
127       !_qualified_exports-&gt;is_empty()) {

128 
129     // This package&#39;s _must_walk_exports flag will be reset based
130     // on the remaining live modules on the exports list.
131     _must_walk_exports = false;
132 
133     if (log_is_enabled(Trace, module)) {
134       ResourceMark rm;
135       assert(name() != NULL, &quot;PackageEntry without a valid name&quot;);
136       ModuleEntry* pkg_mod = module();
137       log_trace(module)(&quot;PackageEntry::purge_qualified_exports(): package %s defined in module %s, exports list being walked&quot;,
138                         name()-&gt;as_C_string(),
139                         (pkg_mod == NULL || pkg_mod-&gt;name() == NULL) ? UNNAMED_MODULE : pkg_mod-&gt;name()-&gt;as_C_string());
140     }
141 
142     // Go backwards because this removes entries that are dead.
143     int len = _qualified_exports-&gt;length();
144     for (int idx = len - 1; idx &gt;= 0; idx--) {
145       ModuleEntry* module_idx = _qualified_exports-&gt;at(idx);
146       ClassLoaderData* cld_idx = module_idx-&gt;loader_data();
147       if (cld_idx-&gt;is_unloading()) {
</pre>
</td>
</tr>
</table>
<center><a href="modules.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="systemDictionary.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
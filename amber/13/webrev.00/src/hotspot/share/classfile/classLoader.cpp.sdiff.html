<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/classLoader.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="classFileParser.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classLoader.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classLoader.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  55 #include &quot;oops/objArrayOop.inline.hpp&quot;
  56 #include &quot;oops/oop.inline.hpp&quot;
  57 #include &quot;oops/symbol.hpp&quot;
  58 #include &quot;prims/jvm_misc.hpp&quot;
  59 #include &quot;runtime/arguments.hpp&quot;
  60 #include &quot;runtime/handles.inline.hpp&quot;
  61 #include &quot;runtime/init.hpp&quot;
  62 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  63 #include &quot;runtime/java.hpp&quot;
  64 #include &quot;runtime/javaCalls.hpp&quot;
  65 #include &quot;runtime/os.inline.hpp&quot;
  66 #include &quot;runtime/threadCritical.hpp&quot;
  67 #include &quot;runtime/timer.hpp&quot;
  68 #include &quot;runtime/vm_version.hpp&quot;
  69 #include &quot;services/management.hpp&quot;
  70 #include &quot;services/threadService.hpp&quot;
  71 #include &quot;utilities/classpathStream.hpp&quot;
  72 #include &quot;utilities/events.hpp&quot;
  73 #include &quot;utilities/hashtable.inline.hpp&quot;
  74 #include &quot;utilities/macros.hpp&quot;

  75 
  76 // Entry point in java.dll for path canonicalization
  77 
  78 typedef int (*canonicalize_fn_t)(const char *orig, char *out, int len);
  79 
  80 static canonicalize_fn_t CanonicalizeEntry  = NULL;
  81 
  82 // Entry points in zip.dll for loading zip/jar file entries
  83 
  84 typedef void * * (*ZipOpen_t)(const char *name, char **pmsg);
  85 typedef void     (*ZipClose_t)(jzfile *zip);
  86 typedef jzentry* (*FindEntry_t)(jzfile *zip, const char *name, jint *sizeP, jint *nameLen);
  87 typedef jboolean (*ReadEntry_t)(jzfile *zip, jzentry *entry, unsigned char *buf, char *namebuf);
  88 typedef jzentry* (*GetNextEntry_t)(jzfile *zip, jint n);
  89 typedef jint     (*Crc32_t)(jint crc, const jbyte *buf, jint len);
  90 
  91 static ZipOpen_t         ZipOpen            = NULL;
  92 static ZipClose_t        ZipClose           = NULL;
  93 static FindEntry_t       FindEntry          = NULL;
  94 static ReadEntry_t       ReadEntry          = NULL;
</pre>
<hr />
<pre>
  99 
 100 static JImageOpen_t                    JImageOpen             = NULL;
 101 static JImageClose_t                   JImageClose            = NULL;
 102 static JImagePackageToModule_t         JImagePackageToModule  = NULL;
 103 static JImageFindResource_t            JImageFindResource     = NULL;
 104 static JImageGetResource_t             JImageGetResource      = NULL;
 105 static JImageResourceIterator_t        JImageResourceIterator = NULL;
 106 
 107 // Globals
 108 
 109 PerfCounter*    ClassLoader::_perf_accumulated_time = NULL;
 110 PerfCounter*    ClassLoader::_perf_classes_inited = NULL;
 111 PerfCounter*    ClassLoader::_perf_class_init_time = NULL;
 112 PerfCounter*    ClassLoader::_perf_class_init_selftime = NULL;
 113 PerfCounter*    ClassLoader::_perf_classes_verified = NULL;
 114 PerfCounter*    ClassLoader::_perf_class_verify_time = NULL;
 115 PerfCounter*    ClassLoader::_perf_class_verify_selftime = NULL;
 116 PerfCounter*    ClassLoader::_perf_classes_linked = NULL;
 117 PerfCounter*    ClassLoader::_perf_class_link_time = NULL;
 118 PerfCounter*    ClassLoader::_perf_class_link_selftime = NULL;
<span class="line-removed"> 119 PerfCounter*    ClassLoader::_perf_class_parse_time = NULL;</span>
<span class="line-removed"> 120 PerfCounter*    ClassLoader::_perf_class_parse_selftime = NULL;</span>
 121 PerfCounter*    ClassLoader::_perf_sys_class_lookup_time = NULL;
 122 PerfCounter*    ClassLoader::_perf_shared_classload_time = NULL;
 123 PerfCounter*    ClassLoader::_perf_sys_classload_time = NULL;
 124 PerfCounter*    ClassLoader::_perf_app_classload_time = NULL;
 125 PerfCounter*    ClassLoader::_perf_app_classload_selftime = NULL;
 126 PerfCounter*    ClassLoader::_perf_app_classload_count = NULL;
 127 PerfCounter*    ClassLoader::_perf_define_appclasses = NULL;
 128 PerfCounter*    ClassLoader::_perf_define_appclass_time = NULL;
 129 PerfCounter*    ClassLoader::_perf_define_appclass_selftime = NULL;
 130 PerfCounter*    ClassLoader::_perf_app_classfile_bytes_read = NULL;
 131 PerfCounter*    ClassLoader::_perf_sys_classfile_bytes_read = NULL;
 132 PerfCounter*    ClassLoader::_sync_systemLoaderLockContentionRate = NULL;
 133 PerfCounter*    ClassLoader::_sync_nonSystemLoaderLockContentionRate = NULL;
 134 PerfCounter*    ClassLoader::_sync_JVMFindLoadedClassLockFreeCounter = NULL;
 135 PerfCounter*    ClassLoader::_sync_JVMDefineClassLockFreeCounter = NULL;
 136 PerfCounter*    ClassLoader::_sync_JNIDefineClassLockFreeCounter = NULL;
 137 PerfCounter*    ClassLoader::_unsafe_defineClassCallCounter = NULL;
 138 
 139 GrowableArray&lt;ModuleClassPathList*&gt;* ClassLoader::_patch_mod_entries = NULL;
 140 GrowableArray&lt;ModuleClassPathList*&gt;* ClassLoader::_exploded_entries = NULL;
</pre>
<hr />
<pre>
 160 
 161 static const char* get_jimage_version_string() {
 162   static char version_string[10] = &quot;&quot;;
 163   if (version_string[0] == &#39;\0&#39;) {
 164     jio_snprintf(version_string, sizeof(version_string), &quot;%d.%d&quot;,
 165                  VM_Version::vm_major_version(), VM_Version::vm_minor_version());
 166   }
 167   return (const char*)version_string;
 168 }
 169 
 170 bool ClassLoader::string_ends_with(const char* str, const char* str_to_find) {
 171   size_t str_len = strlen(str);
 172   size_t str_to_find_len = strlen(str_to_find);
 173   if (str_to_find_len &gt; str_len) {
 174     return false;
 175   }
 176   return (strncmp(str + (str_len - str_to_find_len), str_to_find, str_to_find_len) == 0);
 177 }
 178 
 179 // Used to obtain the package name from a fully qualified class name.
<span class="line-modified"> 180 // It is the responsibility of the caller to establish a ResourceMark.</span>
<span class="line-modified"> 181 const char* ClassLoader::package_from_name(const char* const class_name, bool* bad_class_name) {</span>
<span class="line-removed"> 182   if (class_name == NULL) {</span>
 183     if (bad_class_name != NULL) {
 184       *bad_class_name = true;
 185     }
 186     return NULL;
 187   }
 188 
<span class="line-modified"> 189   if (bad_class_name != NULL) {</span>
<span class="line-modified"> 190     *bad_class_name = false;</span>
<span class="line-modified"> 191   }</span>
<span class="line-modified"> 192 </span>
<span class="line-modified"> 193   const char* const last_slash = strrchr(class_name, JVM_SIGNATURE_SLASH);</span>
<span class="line-removed"> 194   if (last_slash == NULL) {</span>
<span class="line-removed"> 195     // No package name</span>
 196     return NULL;
 197   }
<span class="line-removed"> 198 </span>
<span class="line-removed"> 199   char* class_name_ptr = (char*) class_name;</span>
 200   // Skip over &#39;[&#39;s
<span class="line-modified"> 201   if (*class_name_ptr == JVM_SIGNATURE_ARRAY) {</span>
 202     do {
<span class="line-modified"> 203       class_name_ptr++;</span>
<span class="line-modified"> 204     } while (*class_name_ptr == JVM_SIGNATURE_ARRAY);</span>
 205 
 206     // Fully qualified class names should not contain a &#39;L&#39;.
 207     // Set bad_class_name to true to indicate that the package name
 208     // could not be obtained due to an error condition.
 209     // In this situation, is_same_class_package returns false.
<span class="line-modified"> 210     if (*class_name_ptr == JVM_SIGNATURE_CLASS) {</span>
 211       if (bad_class_name != NULL) {
 212         *bad_class_name = true;
 213       }
 214       return NULL;
 215     }
 216   }
<span class="line-modified"> 217 </span>
<span class="line-modified"> 218   int length = last_slash - class_name_ptr;</span>
<span class="line-modified"> 219 </span>
<span class="line-removed"> 220   // A class name could have just the slash character in the name.</span>
<span class="line-removed"> 221   if (length &lt;= 0) {</span>
 222     // No package name
 223     if (bad_class_name != NULL) {
 224       *bad_class_name = true;
 225     }
 226     return NULL;
 227   }
<span class="line-modified"> 228 </span>
<span class="line-removed"> 229   // drop name after last slash (including slash)</span>
<span class="line-removed"> 230   // Ex., &quot;java/lang/String.class&quot; =&gt; &quot;java/lang&quot;</span>
<span class="line-removed"> 231   char* pkg_name = NEW_RESOURCE_ARRAY(char, length + 1);</span>
<span class="line-removed"> 232   strncpy(pkg_name, class_name_ptr, length);</span>
<span class="line-removed"> 233   *(pkg_name+length) = &#39;\0&#39;;</span>
<span class="line-removed"> 234 </span>
<span class="line-removed"> 235   return (const char *)pkg_name;</span>
 236 }
 237 
<span class="line-modified"> 238 // Given a fully qualified class name, find its defining package in the class loader&#39;s</span>
 239 // package entry table.
<span class="line-modified"> 240 PackageEntry* ClassLoader::get_package_entry(const char* class_name, ClassLoaderData* loader_data, TRAPS) {</span>
<span class="line-removed"> 241   ResourceMark rm(THREAD);</span>
<span class="line-removed"> 242   const char *pkg_name = ClassLoader::package_from_name(class_name);</span>
 243   if (pkg_name == NULL) {
 244     return NULL;
 245   }
 246   PackageEntryTable* pkgEntryTable = loader_data-&gt;packages();
<span class="line-modified"> 247   TempNewSymbol pkg_symbol = SymbolTable::new_symbol(pkg_name);</span>
<span class="line-removed"> 248   return pkgEntryTable-&gt;lookup_only(pkg_symbol);</span>
 249 }
 250 
 251 const char* ClassPathEntry::copy_path(const char* path) {
 252   char* copy = NEW_C_HEAP_ARRAY(char, strlen(path)+1, mtClass);
 253   strcpy(copy, path);
 254   return copy;
 255 }
 256 
 257 ClassFileStream* ClassPathDirEntry::open_stream(const char* name, TRAPS) {
 258   // construct full path name
 259   assert((_dir != NULL) &amp;&amp; (name != NULL), &quot;sanity&quot;);
 260   size_t path_len = strlen(_dir) + strlen(name) + strlen(os::file_separator()) + 1;
 261   char* path = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, path_len);
 262   int len = jio_snprintf(path, path_len, &quot;%s%s%s&quot;, _dir, os::file_separator(), name);
 263   assert(len == (int)(path_len - 1), &quot;sanity&quot;);
 264   // check if file exists
 265   struct stat st;
 266   if (os::stat(path, &amp;st) == 0) {
 267     // found file, open it
 268     int file_handle = os::open(path, 0, 0);
</pre>
<hr />
<pre>
 390     _jimage = NULL;
 391   }
 392 }
 393 
 394 ClassFileStream* ClassPathImageEntry::open_stream(const char* name, TRAPS) {
 395   return open_stream_for_loader(name, ClassLoaderData::the_null_class_loader_data(), THREAD);
 396 }
 397 
 398 // For a class in a named module, look it up in the jimage file using this syntax:
 399 //    /&lt;module-name&gt;/&lt;package-name&gt;/&lt;base-class&gt;
 400 //
 401 // Assumptions:
 402 //     1. There are no unnamed modules in the jimage file.
 403 //     2. A package is in at most one module in the jimage file.
 404 //
 405 ClassFileStream* ClassPathImageEntry::open_stream_for_loader(const char* name, ClassLoaderData* loader_data, TRAPS) {
 406   jlong size;
 407   JImageLocationRef location = (*JImageFindResource)(_jimage, &quot;&quot;, get_jimage_version_string(), name, &amp;size);
 408 
 409   if (location == 0) {
<span class="line-modified"> 410     ResourceMark rm;</span>
<span class="line-modified"> 411     const char* pkg_name = ClassLoader::package_from_name(name);</span>
 412 
 413     if (pkg_name != NULL) {
 414       if (!Universe::is_module_initialized()) {
 415         location = (*JImageFindResource)(_jimage, JAVA_BASE_NAME, get_jimage_version_string(), name, &amp;size);
 416       } else {
<span class="line-modified"> 417         PackageEntry* package_entry = ClassLoader::get_package_entry(name, loader_data, CHECK_NULL);</span>
 418         if (package_entry != NULL) {
<span class="line-modified"> 419           ResourceMark rm;</span>
 420           // Get the module name
 421           ModuleEntry* module = package_entry-&gt;module();
 422           assert(module != NULL, &quot;Boot classLoader package missing module&quot;);
 423           assert(module-&gt;is_named(), &quot;Boot classLoader package is in unnamed module&quot;);
 424           const char* module_name = module-&gt;name()-&gt;as_C_string();
 425           if (module_name != NULL) {
 426             location = (*JImageFindResource)(_jimage, module_name, get_jimage_version_string(), name, &amp;size);
 427           }
 428         }
 429       }
 430     }
 431   }
 432   if (location != 0) {
 433     if (UsePerfData) {
 434       ClassLoader::perf_sys_classfile_bytes_read()-&gt;inc(size);
 435     }
 436     char* data = NEW_RESOURCE_ARRAY(char, size);
 437     (*JImageGetResource)(_jimage, location, data, size);
 438     // Resource allocated
 439     assert(this == (ClassPathImageEntry*)ClassLoader::get_jrt_entry(), &quot;must be&quot;);
</pre>
<hr />
<pre>
1012   void* handle = NULL;
1013   if (os::dll_locate_lib(path, sizeof(path), Arguments::get_dll_dir(), &quot;jimage&quot;)) {
1014     handle = os::dll_load(path, ebuf, sizeof ebuf);
1015   }
1016   if (handle == NULL) {
1017     vm_exit_during_initialization(&quot;Unable to load jimage library&quot;, path);
1018   }
1019 
1020   JImageOpen = CAST_TO_FN_PTR(JImageOpen_t, dll_lookup(handle, &quot;JIMAGE_Open&quot;, path));
1021   JImageClose = CAST_TO_FN_PTR(JImageClose_t, dll_lookup(handle, &quot;JIMAGE_Close&quot;, path));
1022   JImagePackageToModule = CAST_TO_FN_PTR(JImagePackageToModule_t, dll_lookup(handle, &quot;JIMAGE_PackageToModule&quot;, path));
1023   JImageFindResource = CAST_TO_FN_PTR(JImageFindResource_t, dll_lookup(handle, &quot;JIMAGE_FindResource&quot;, path));
1024   JImageGetResource = CAST_TO_FN_PTR(JImageGetResource_t, dll_lookup(handle, &quot;JIMAGE_GetResource&quot;, path));
1025   JImageResourceIterator = CAST_TO_FN_PTR(JImageResourceIterator_t, dll_lookup(handle, &quot;JIMAGE_ResourceIterator&quot;, path));
1026 }
1027 
1028 int ClassLoader::crc32(int crc, const char* buf, int len) {
1029   return (*Crc32)(crc, (const jbyte*)buf, len);
1030 }
1031 
<span class="line-modified">1032 // Function add_package extracts the package from the fully qualified class name</span>
<span class="line-modified">1033 // and checks if the package is in the boot loader&#39;s package entry table.  If so,</span>
<span class="line-modified">1034 // then it sets the classpath_index in the package entry record.</span>
1035 //
1036 // The classpath_index field is used to find the entry on the boot loader class
1037 // path for packages with classes loaded by the boot loader from -Xbootclasspath/a
1038 // in an unnamed module.  It is also used to indicate (for all packages whose
1039 // classes are loaded by the boot loader) that at least one of the package&#39;s
1040 // classes has been loaded.
<span class="line-modified">1041 bool ClassLoader::add_package(const char *fullq_class_name, s2 classpath_index, TRAPS) {</span>
<span class="line-modified">1042   assert(fullq_class_name != NULL, &quot;just checking&quot;);</span>
1043 
<span class="line-modified">1044   // Get package name from fully qualified class name.</span>
<span class="line-modified">1045   ResourceMark rm(THREAD);</span>
<span class="line-removed">1046   const char *cp = package_from_name(fullq_class_name);</span>
<span class="line-removed">1047   if (cp != NULL) {</span>
1048     PackageEntryTable* pkg_entry_tbl = ClassLoaderData::the_null_class_loader_data()-&gt;packages();
<span class="line-modified">1049     TempNewSymbol pkg_symbol = SymbolTable::new_symbol(cp);</span>
<span class="line-removed">1050     PackageEntry* pkg_entry = pkg_entry_tbl-&gt;lookup_only(pkg_symbol);</span>
1051     if (pkg_entry != NULL) {
1052       assert(classpath_index != -1, &quot;Unexpected classpath_index&quot;);
1053       pkg_entry-&gt;set_classpath_index(classpath_index);
1054     } else {
1055       return false;
1056     }
1057   }
1058   return true;
1059 }
1060 
1061 oop ClassLoader::get_system_package(const char* name, TRAPS) {
1062   // Look up the name in the boot loader&#39;s package entry table.
1063   if (name != NULL) {
1064     TempNewSymbol package_sym = SymbolTable::new_symbol(name);
1065     // Look for the package entry in the boot loader&#39;s package entry table.
1066     PackageEntry* package =
1067       ClassLoaderData::the_null_class_loader_data()-&gt;packages()-&gt;lookup_only(package_sym);
1068 
1069     // Return NULL if package does not exist or if no classes in that package
1070     // have been loaded.
</pre>
<hr />
<pre>
1149     ModuleClassPathList* module_cpl = module_list-&gt;at(i);
1150     Symbol* module_cpl_name = module_cpl-&gt;module_name();
1151 
1152     if (module_cpl_name-&gt;fast_compare(class_module_name) == 0) {
1153       // Class&#39; module has been located.
1154       return module_cpl-&gt;module_first_entry();
1155     }
1156   }
1157   return NULL;
1158 }
1159 
1160 
1161 // Search either the patch-module or exploded build entries for class.
1162 ClassFileStream* ClassLoader::search_module_entries(const GrowableArray&lt;ModuleClassPathList*&gt;* const module_list,
1163                                                     const char* const class_name,
1164                                                     const char* const file_name,
1165                                                     TRAPS) {
1166   ClassFileStream* stream = NULL;
1167 
1168   // Find the class&#39; defining module in the boot loader&#39;s module entry table
<span class="line-modified">1169   PackageEntry* pkg_entry = get_package_entry(class_name, ClassLoaderData::the_null_class_loader_data(), CHECK_NULL);</span>


1170   ModuleEntry* mod_entry = (pkg_entry != NULL) ? pkg_entry-&gt;module() : NULL;
1171 
1172   // If the module system has not defined java.base yet, then
1173   // classes loaded are assumed to be defined to java.base.
1174   // When java.base is eventually defined by the module system,
1175   // all packages of classes that have been previously loaded
1176   // are verified in ModuleEntryTable::verify_javabase_packages().
1177   if (!Universe::is_module_initialized() &amp;&amp;
1178       !ModuleEntryTable::javabase_defined() &amp;&amp;
1179       mod_entry == NULL) {
1180     mod_entry = ModuleEntryTable::javabase_moduleEntry();
1181   }
1182 
1183   // The module must be a named module
1184   ClassPathEntry* e = NULL;
1185   if (mod_entry != NULL &amp;&amp; mod_entry-&gt;is_named()) {
1186     if (module_list == _exploded_entries) {
1187       // The exploded build entries can be added to at any time so a lock is
1188       // needed when searching them.
1189       assert(!ClassLoader::has_jrt_entry(), &quot;Must be exploded build&quot;);
</pre>
<hr />
<pre>
1300 
1301   stream-&gt;set_verify(ClassLoaderExt::should_verify(classpath_index));
1302 
1303   ClassLoaderData* loader_data = ClassLoaderData::the_null_class_loader_data();
1304   Handle protection_domain;
1305 
1306   InstanceKlass* result = KlassFactory::create_from_stream(stream,
1307                                                            name,
1308                                                            loader_data,
1309                                                            protection_domain,
1310                                                            NULL, // unsafe_anonymous_host
1311                                                            NULL, // cp_patches
1312                                                            THREAD);
1313   if (HAS_PENDING_EXCEPTION) {
1314     if (DumpSharedSpaces) {
1315       log_error(cds)(&quot;Preload Error: Failed to load %s&quot;, class_name);
1316     }
1317     return NULL;
1318   }
1319 
<span class="line-modified">1320   if (!add_package(file_name, classpath_index, THREAD)) {</span>
1321     return NULL;
1322   }
1323 
1324   return result;
1325 }
1326 
1327 #if INCLUDE_CDS
1328 char* ClassLoader::skip_uri_protocol(char* source) {
1329   if (strncmp(source, &quot;file:&quot;, 5) == 0) {
1330     // file: protocol path could start with file:/ or file:///
1331     // locate the char after all the forward slashes
1332     int offset = 5;
1333     while (*(source + offset) == &#39;/&#39;) {
1334         offset++;
1335     }
1336     source += offset;
1337   // for non-windows platforms, move back one char as the path begins with a &#39;/&#39;
1338 #ifndef _WINDOWS
1339     source -= 1;
1340 #endif
</pre>
<hr />
<pre>
1463 // process the boot classpath into a list ClassPathEntry objects.  Once
1464 // this list has been created, it must not change order (see class PackageInfo)
1465 // it can be appended to and is by jvmti and the kernel vm.
1466 
1467 void ClassLoader::initialize() {
1468   EXCEPTION_MARK;
1469 
1470   if (UsePerfData) {
1471     // jvmstat performance counters
1472     NEWPERFTICKCOUNTER(_perf_accumulated_time, SUN_CLS, &quot;time&quot;);
1473     NEWPERFTICKCOUNTER(_perf_class_init_time, SUN_CLS, &quot;classInitTime&quot;);
1474     NEWPERFTICKCOUNTER(_perf_class_init_selftime, SUN_CLS, &quot;classInitTime.self&quot;);
1475     NEWPERFTICKCOUNTER(_perf_class_verify_time, SUN_CLS, &quot;classVerifyTime&quot;);
1476     NEWPERFTICKCOUNTER(_perf_class_verify_selftime, SUN_CLS, &quot;classVerifyTime.self&quot;);
1477     NEWPERFTICKCOUNTER(_perf_class_link_time, SUN_CLS, &quot;classLinkedTime&quot;);
1478     NEWPERFTICKCOUNTER(_perf_class_link_selftime, SUN_CLS, &quot;classLinkedTime.self&quot;);
1479     NEWPERFEVENTCOUNTER(_perf_classes_inited, SUN_CLS, &quot;initializedClasses&quot;);
1480     NEWPERFEVENTCOUNTER(_perf_classes_linked, SUN_CLS, &quot;linkedClasses&quot;);
1481     NEWPERFEVENTCOUNTER(_perf_classes_verified, SUN_CLS, &quot;verifiedClasses&quot;);
1482 
<span class="line-removed">1483     NEWPERFTICKCOUNTER(_perf_class_parse_time, SUN_CLS, &quot;parseClassTime&quot;);</span>
<span class="line-removed">1484     NEWPERFTICKCOUNTER(_perf_class_parse_selftime, SUN_CLS, &quot;parseClassTime.self&quot;);</span>
1485     NEWPERFTICKCOUNTER(_perf_sys_class_lookup_time, SUN_CLS, &quot;lookupSysClassTime&quot;);
1486     NEWPERFTICKCOUNTER(_perf_shared_classload_time, SUN_CLS, &quot;sharedClassLoadTime&quot;);
1487     NEWPERFTICKCOUNTER(_perf_sys_classload_time, SUN_CLS, &quot;sysClassLoadTime&quot;);
1488     NEWPERFTICKCOUNTER(_perf_app_classload_time, SUN_CLS, &quot;appClassLoadTime&quot;);
1489     NEWPERFTICKCOUNTER(_perf_app_classload_selftime, SUN_CLS, &quot;appClassLoadTime.self&quot;);
1490     NEWPERFEVENTCOUNTER(_perf_app_classload_count, SUN_CLS, &quot;appClassLoadCount&quot;);
1491     NEWPERFTICKCOUNTER(_perf_define_appclasses, SUN_CLS, &quot;defineAppClasses&quot;);
1492     NEWPERFTICKCOUNTER(_perf_define_appclass_time, SUN_CLS, &quot;defineAppClassTime&quot;);
1493     NEWPERFTICKCOUNTER(_perf_define_appclass_selftime, SUN_CLS, &quot;defineAppClassTime.self&quot;);
1494     NEWPERFBYTECOUNTER(_perf_app_classfile_bytes_read, SUN_CLS, &quot;appClassBytes&quot;);
1495     NEWPERFBYTECOUNTER(_perf_sys_classfile_bytes_read, SUN_CLS, &quot;sysClassBytes&quot;);
1496 
1497 
1498     // The following performance counters are added for measuring the impact
1499     // of the bug fix of 6365597. They are mainly focused on finding out
1500     // the behavior of system &amp; user-defined classloader lock, whether
1501     // ClassLoader.loadClass/findClass is being called synchronized or not.
1502     NEWPERFEVENTCOUNTER(_sync_systemLoaderLockContentionRate, SUN_CLS,
1503                         &quot;systemLoaderLockContentionRate&quot;);
1504     NEWPERFEVENTCOUNTER(_sync_nonSystemLoaderLockContentionRate, SUN_CLS,
</pre>
</td>
<td>
<hr />
<pre>
  55 #include &quot;oops/objArrayOop.inline.hpp&quot;
  56 #include &quot;oops/oop.inline.hpp&quot;
  57 #include &quot;oops/symbol.hpp&quot;
  58 #include &quot;prims/jvm_misc.hpp&quot;
  59 #include &quot;runtime/arguments.hpp&quot;
  60 #include &quot;runtime/handles.inline.hpp&quot;
  61 #include &quot;runtime/init.hpp&quot;
  62 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  63 #include &quot;runtime/java.hpp&quot;
  64 #include &quot;runtime/javaCalls.hpp&quot;
  65 #include &quot;runtime/os.inline.hpp&quot;
  66 #include &quot;runtime/threadCritical.hpp&quot;
  67 #include &quot;runtime/timer.hpp&quot;
  68 #include &quot;runtime/vm_version.hpp&quot;
  69 #include &quot;services/management.hpp&quot;
  70 #include &quot;services/threadService.hpp&quot;
  71 #include &quot;utilities/classpathStream.hpp&quot;
  72 #include &quot;utilities/events.hpp&quot;
  73 #include &quot;utilities/hashtable.inline.hpp&quot;
  74 #include &quot;utilities/macros.hpp&quot;
<span class="line-added">  75 #include &quot;utilities/utf8.hpp&quot;</span>
  76 
  77 // Entry point in java.dll for path canonicalization
  78 
  79 typedef int (*canonicalize_fn_t)(const char *orig, char *out, int len);
  80 
  81 static canonicalize_fn_t CanonicalizeEntry  = NULL;
  82 
  83 // Entry points in zip.dll for loading zip/jar file entries
  84 
  85 typedef void * * (*ZipOpen_t)(const char *name, char **pmsg);
  86 typedef void     (*ZipClose_t)(jzfile *zip);
  87 typedef jzentry* (*FindEntry_t)(jzfile *zip, const char *name, jint *sizeP, jint *nameLen);
  88 typedef jboolean (*ReadEntry_t)(jzfile *zip, jzentry *entry, unsigned char *buf, char *namebuf);
  89 typedef jzentry* (*GetNextEntry_t)(jzfile *zip, jint n);
  90 typedef jint     (*Crc32_t)(jint crc, const jbyte *buf, jint len);
  91 
  92 static ZipOpen_t         ZipOpen            = NULL;
  93 static ZipClose_t        ZipClose           = NULL;
  94 static FindEntry_t       FindEntry          = NULL;
  95 static ReadEntry_t       ReadEntry          = NULL;
</pre>
<hr />
<pre>
 100 
 101 static JImageOpen_t                    JImageOpen             = NULL;
 102 static JImageClose_t                   JImageClose            = NULL;
 103 static JImagePackageToModule_t         JImagePackageToModule  = NULL;
 104 static JImageFindResource_t            JImageFindResource     = NULL;
 105 static JImageGetResource_t             JImageGetResource      = NULL;
 106 static JImageResourceIterator_t        JImageResourceIterator = NULL;
 107 
 108 // Globals
 109 
 110 PerfCounter*    ClassLoader::_perf_accumulated_time = NULL;
 111 PerfCounter*    ClassLoader::_perf_classes_inited = NULL;
 112 PerfCounter*    ClassLoader::_perf_class_init_time = NULL;
 113 PerfCounter*    ClassLoader::_perf_class_init_selftime = NULL;
 114 PerfCounter*    ClassLoader::_perf_classes_verified = NULL;
 115 PerfCounter*    ClassLoader::_perf_class_verify_time = NULL;
 116 PerfCounter*    ClassLoader::_perf_class_verify_selftime = NULL;
 117 PerfCounter*    ClassLoader::_perf_classes_linked = NULL;
 118 PerfCounter*    ClassLoader::_perf_class_link_time = NULL;
 119 PerfCounter*    ClassLoader::_perf_class_link_selftime = NULL;


 120 PerfCounter*    ClassLoader::_perf_sys_class_lookup_time = NULL;
 121 PerfCounter*    ClassLoader::_perf_shared_classload_time = NULL;
 122 PerfCounter*    ClassLoader::_perf_sys_classload_time = NULL;
 123 PerfCounter*    ClassLoader::_perf_app_classload_time = NULL;
 124 PerfCounter*    ClassLoader::_perf_app_classload_selftime = NULL;
 125 PerfCounter*    ClassLoader::_perf_app_classload_count = NULL;
 126 PerfCounter*    ClassLoader::_perf_define_appclasses = NULL;
 127 PerfCounter*    ClassLoader::_perf_define_appclass_time = NULL;
 128 PerfCounter*    ClassLoader::_perf_define_appclass_selftime = NULL;
 129 PerfCounter*    ClassLoader::_perf_app_classfile_bytes_read = NULL;
 130 PerfCounter*    ClassLoader::_perf_sys_classfile_bytes_read = NULL;
 131 PerfCounter*    ClassLoader::_sync_systemLoaderLockContentionRate = NULL;
 132 PerfCounter*    ClassLoader::_sync_nonSystemLoaderLockContentionRate = NULL;
 133 PerfCounter*    ClassLoader::_sync_JVMFindLoadedClassLockFreeCounter = NULL;
 134 PerfCounter*    ClassLoader::_sync_JVMDefineClassLockFreeCounter = NULL;
 135 PerfCounter*    ClassLoader::_sync_JNIDefineClassLockFreeCounter = NULL;
 136 PerfCounter*    ClassLoader::_unsafe_defineClassCallCounter = NULL;
 137 
 138 GrowableArray&lt;ModuleClassPathList*&gt;* ClassLoader::_patch_mod_entries = NULL;
 139 GrowableArray&lt;ModuleClassPathList*&gt;* ClassLoader::_exploded_entries = NULL;
</pre>
<hr />
<pre>
 159 
 160 static const char* get_jimage_version_string() {
 161   static char version_string[10] = &quot;&quot;;
 162   if (version_string[0] == &#39;\0&#39;) {
 163     jio_snprintf(version_string, sizeof(version_string), &quot;%d.%d&quot;,
 164                  VM_Version::vm_major_version(), VM_Version::vm_minor_version());
 165   }
 166   return (const char*)version_string;
 167 }
 168 
 169 bool ClassLoader::string_ends_with(const char* str, const char* str_to_find) {
 170   size_t str_len = strlen(str);
 171   size_t str_to_find_len = strlen(str_to_find);
 172   if (str_to_find_len &gt; str_len) {
 173     return false;
 174   }
 175   return (strncmp(str + (str_len - str_to_find_len), str_to_find, str_to_find_len) == 0);
 176 }
 177 
 178 // Used to obtain the package name from a fully qualified class name.
<span class="line-modified"> 179 Symbol* ClassLoader::package_from_class_name(const Symbol* name, bool* bad_class_name) {</span>
<span class="line-modified"> 180   if (name == NULL) {</span>

 181     if (bad_class_name != NULL) {
 182       *bad_class_name = true;
 183     }
 184     return NULL;
 185   }
 186 
<span class="line-modified"> 187   int utf_len = name-&gt;utf8_length();</span>
<span class="line-modified"> 188   const jbyte* base = (const jbyte*)name-&gt;base();</span>
<span class="line-modified"> 189   const jbyte* start = base;</span>
<span class="line-modified"> 190   const jbyte* end = UTF8::strrchr(start, utf_len, JVM_SIGNATURE_SLASH);</span>
<span class="line-modified"> 191   if (end == NULL) {</span>


 192     return NULL;
 193   }


 194   // Skip over &#39;[&#39;s
<span class="line-modified"> 195   if (*start == JVM_SIGNATURE_ARRAY) {</span>
 196     do {
<span class="line-modified"> 197       start++;</span>
<span class="line-modified"> 198     } while (start &lt; end &amp;&amp; *start == JVM_SIGNATURE_ARRAY);</span>
 199 
 200     // Fully qualified class names should not contain a &#39;L&#39;.
 201     // Set bad_class_name to true to indicate that the package name
 202     // could not be obtained due to an error condition.
 203     // In this situation, is_same_class_package returns false.
<span class="line-modified"> 204     if (*start == JVM_SIGNATURE_CLASS) {</span>
 205       if (bad_class_name != NULL) {
 206         *bad_class_name = true;
 207       }
 208       return NULL;
 209     }
 210   }
<span class="line-modified"> 211   // A class name could have just the slash character in the name,</span>
<span class="line-modified"> 212   // in which case start &gt; end</span>
<span class="line-modified"> 213   if (start &gt;= end) {</span>


 214     // No package name
 215     if (bad_class_name != NULL) {
 216       *bad_class_name = true;
 217     }
 218     return NULL;
 219   }
<span class="line-modified"> 220   return SymbolTable::new_symbol(name, start - base, end - base);</span>







 221 }
 222 
<span class="line-modified"> 223 // Given a fully qualified package name, find its defining package in the class loader&#39;s</span>
 224 // package entry table.
<span class="line-modified"> 225 PackageEntry* ClassLoader::get_package_entry(Symbol* pkg_name, ClassLoaderData* loader_data) {</span>


 226   if (pkg_name == NULL) {
 227     return NULL;
 228   }
 229   PackageEntryTable* pkgEntryTable = loader_data-&gt;packages();
<span class="line-modified"> 230   return pkgEntryTable-&gt;lookup_only(pkg_name);</span>

 231 }
 232 
 233 const char* ClassPathEntry::copy_path(const char* path) {
 234   char* copy = NEW_C_HEAP_ARRAY(char, strlen(path)+1, mtClass);
 235   strcpy(copy, path);
 236   return copy;
 237 }
 238 
 239 ClassFileStream* ClassPathDirEntry::open_stream(const char* name, TRAPS) {
 240   // construct full path name
 241   assert((_dir != NULL) &amp;&amp; (name != NULL), &quot;sanity&quot;);
 242   size_t path_len = strlen(_dir) + strlen(name) + strlen(os::file_separator()) + 1;
 243   char* path = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, path_len);
 244   int len = jio_snprintf(path, path_len, &quot;%s%s%s&quot;, _dir, os::file_separator(), name);
 245   assert(len == (int)(path_len - 1), &quot;sanity&quot;);
 246   // check if file exists
 247   struct stat st;
 248   if (os::stat(path, &amp;st) == 0) {
 249     // found file, open it
 250     int file_handle = os::open(path, 0, 0);
</pre>
<hr />
<pre>
 372     _jimage = NULL;
 373   }
 374 }
 375 
 376 ClassFileStream* ClassPathImageEntry::open_stream(const char* name, TRAPS) {
 377   return open_stream_for_loader(name, ClassLoaderData::the_null_class_loader_data(), THREAD);
 378 }
 379 
 380 // For a class in a named module, look it up in the jimage file using this syntax:
 381 //    /&lt;module-name&gt;/&lt;package-name&gt;/&lt;base-class&gt;
 382 //
 383 // Assumptions:
 384 //     1. There are no unnamed modules in the jimage file.
 385 //     2. A package is in at most one module in the jimage file.
 386 //
 387 ClassFileStream* ClassPathImageEntry::open_stream_for_loader(const char* name, ClassLoaderData* loader_data, TRAPS) {
 388   jlong size;
 389   JImageLocationRef location = (*JImageFindResource)(_jimage, &quot;&quot;, get_jimage_version_string(), name, &amp;size);
 390 
 391   if (location == 0) {
<span class="line-modified"> 392     TempNewSymbol class_name = SymbolTable::new_symbol(name);</span>
<span class="line-modified"> 393     TempNewSymbol pkg_name = ClassLoader::package_from_class_name(class_name);</span>
 394 
 395     if (pkg_name != NULL) {
 396       if (!Universe::is_module_initialized()) {
 397         location = (*JImageFindResource)(_jimage, JAVA_BASE_NAME, get_jimage_version_string(), name, &amp;size);
 398       } else {
<span class="line-modified"> 399         PackageEntry* package_entry = ClassLoader::get_package_entry(pkg_name, loader_data);</span>
 400         if (package_entry != NULL) {
<span class="line-modified"> 401           ResourceMark rm(THREAD);</span>
 402           // Get the module name
 403           ModuleEntry* module = package_entry-&gt;module();
 404           assert(module != NULL, &quot;Boot classLoader package missing module&quot;);
 405           assert(module-&gt;is_named(), &quot;Boot classLoader package is in unnamed module&quot;);
 406           const char* module_name = module-&gt;name()-&gt;as_C_string();
 407           if (module_name != NULL) {
 408             location = (*JImageFindResource)(_jimage, module_name, get_jimage_version_string(), name, &amp;size);
 409           }
 410         }
 411       }
 412     }
 413   }
 414   if (location != 0) {
 415     if (UsePerfData) {
 416       ClassLoader::perf_sys_classfile_bytes_read()-&gt;inc(size);
 417     }
 418     char* data = NEW_RESOURCE_ARRAY(char, size);
 419     (*JImageGetResource)(_jimage, location, data, size);
 420     // Resource allocated
 421     assert(this == (ClassPathImageEntry*)ClassLoader::get_jrt_entry(), &quot;must be&quot;);
</pre>
<hr />
<pre>
 994   void* handle = NULL;
 995   if (os::dll_locate_lib(path, sizeof(path), Arguments::get_dll_dir(), &quot;jimage&quot;)) {
 996     handle = os::dll_load(path, ebuf, sizeof ebuf);
 997   }
 998   if (handle == NULL) {
 999     vm_exit_during_initialization(&quot;Unable to load jimage library&quot;, path);
1000   }
1001 
1002   JImageOpen = CAST_TO_FN_PTR(JImageOpen_t, dll_lookup(handle, &quot;JIMAGE_Open&quot;, path));
1003   JImageClose = CAST_TO_FN_PTR(JImageClose_t, dll_lookup(handle, &quot;JIMAGE_Close&quot;, path));
1004   JImagePackageToModule = CAST_TO_FN_PTR(JImagePackageToModule_t, dll_lookup(handle, &quot;JIMAGE_PackageToModule&quot;, path));
1005   JImageFindResource = CAST_TO_FN_PTR(JImageFindResource_t, dll_lookup(handle, &quot;JIMAGE_FindResource&quot;, path));
1006   JImageGetResource = CAST_TO_FN_PTR(JImageGetResource_t, dll_lookup(handle, &quot;JIMAGE_GetResource&quot;, path));
1007   JImageResourceIterator = CAST_TO_FN_PTR(JImageResourceIterator_t, dll_lookup(handle, &quot;JIMAGE_ResourceIterator&quot;, path));
1008 }
1009 
1010 int ClassLoader::crc32(int crc, const char* buf, int len) {
1011   return (*Crc32)(crc, (const jbyte*)buf, len);
1012 }
1013 
<span class="line-modified">1014 // Function add_package checks if the package of the InstanceKlass is in the</span>
<span class="line-modified">1015 // boot loader&#39;s package entry table.  If so, then it sets the classpath_index</span>
<span class="line-modified">1016 // in the package entry record.</span>
1017 //
1018 // The classpath_index field is used to find the entry on the boot loader class
1019 // path for packages with classes loaded by the boot loader from -Xbootclasspath/a
1020 // in an unnamed module.  It is also used to indicate (for all packages whose
1021 // classes are loaded by the boot loader) that at least one of the package&#39;s
1022 // classes has been loaded.
<span class="line-modified">1023 bool ClassLoader::add_package(const InstanceKlass* ik, s2 classpath_index, TRAPS) {</span>
<span class="line-modified">1024   assert(ik != NULL, &quot;just checking&quot;);</span>
1025 
<span class="line-modified">1026   PackageEntry* ik_pkg = ik-&gt;package();</span>
<span class="line-modified">1027   if (ik_pkg != NULL) {</span>


1028     PackageEntryTable* pkg_entry_tbl = ClassLoaderData::the_null_class_loader_data()-&gt;packages();
<span class="line-modified">1029     PackageEntry* pkg_entry = pkg_entry_tbl-&gt;lookup_only(ik_pkg-&gt;name());</span>

1030     if (pkg_entry != NULL) {
1031       assert(classpath_index != -1, &quot;Unexpected classpath_index&quot;);
1032       pkg_entry-&gt;set_classpath_index(classpath_index);
1033     } else {
1034       return false;
1035     }
1036   }
1037   return true;
1038 }
1039 
1040 oop ClassLoader::get_system_package(const char* name, TRAPS) {
1041   // Look up the name in the boot loader&#39;s package entry table.
1042   if (name != NULL) {
1043     TempNewSymbol package_sym = SymbolTable::new_symbol(name);
1044     // Look for the package entry in the boot loader&#39;s package entry table.
1045     PackageEntry* package =
1046       ClassLoaderData::the_null_class_loader_data()-&gt;packages()-&gt;lookup_only(package_sym);
1047 
1048     // Return NULL if package does not exist or if no classes in that package
1049     // have been loaded.
</pre>
<hr />
<pre>
1128     ModuleClassPathList* module_cpl = module_list-&gt;at(i);
1129     Symbol* module_cpl_name = module_cpl-&gt;module_name();
1130 
1131     if (module_cpl_name-&gt;fast_compare(class_module_name) == 0) {
1132       // Class&#39; module has been located.
1133       return module_cpl-&gt;module_first_entry();
1134     }
1135   }
1136   return NULL;
1137 }
1138 
1139 
1140 // Search either the patch-module or exploded build entries for class.
1141 ClassFileStream* ClassLoader::search_module_entries(const GrowableArray&lt;ModuleClassPathList*&gt;* const module_list,
1142                                                     const char* const class_name,
1143                                                     const char* const file_name,
1144                                                     TRAPS) {
1145   ClassFileStream* stream = NULL;
1146 
1147   // Find the class&#39; defining module in the boot loader&#39;s module entry table
<span class="line-modified">1148   TempNewSymbol class_name_symbol = SymbolTable::new_symbol(class_name);</span>
<span class="line-added">1149   TempNewSymbol pkg_name = package_from_class_name(class_name_symbol);</span>
<span class="line-added">1150   PackageEntry* pkg_entry = get_package_entry(pkg_name, ClassLoaderData::the_null_class_loader_data());</span>
1151   ModuleEntry* mod_entry = (pkg_entry != NULL) ? pkg_entry-&gt;module() : NULL;
1152 
1153   // If the module system has not defined java.base yet, then
1154   // classes loaded are assumed to be defined to java.base.
1155   // When java.base is eventually defined by the module system,
1156   // all packages of classes that have been previously loaded
1157   // are verified in ModuleEntryTable::verify_javabase_packages().
1158   if (!Universe::is_module_initialized() &amp;&amp;
1159       !ModuleEntryTable::javabase_defined() &amp;&amp;
1160       mod_entry == NULL) {
1161     mod_entry = ModuleEntryTable::javabase_moduleEntry();
1162   }
1163 
1164   // The module must be a named module
1165   ClassPathEntry* e = NULL;
1166   if (mod_entry != NULL &amp;&amp; mod_entry-&gt;is_named()) {
1167     if (module_list == _exploded_entries) {
1168       // The exploded build entries can be added to at any time so a lock is
1169       // needed when searching them.
1170       assert(!ClassLoader::has_jrt_entry(), &quot;Must be exploded build&quot;);
</pre>
<hr />
<pre>
1281 
1282   stream-&gt;set_verify(ClassLoaderExt::should_verify(classpath_index));
1283 
1284   ClassLoaderData* loader_data = ClassLoaderData::the_null_class_loader_data();
1285   Handle protection_domain;
1286 
1287   InstanceKlass* result = KlassFactory::create_from_stream(stream,
1288                                                            name,
1289                                                            loader_data,
1290                                                            protection_domain,
1291                                                            NULL, // unsafe_anonymous_host
1292                                                            NULL, // cp_patches
1293                                                            THREAD);
1294   if (HAS_PENDING_EXCEPTION) {
1295     if (DumpSharedSpaces) {
1296       log_error(cds)(&quot;Preload Error: Failed to load %s&quot;, class_name);
1297     }
1298     return NULL;
1299   }
1300 
<span class="line-modified">1301   if (!add_package(result, classpath_index, THREAD)) {</span>
1302     return NULL;
1303   }
1304 
1305   return result;
1306 }
1307 
1308 #if INCLUDE_CDS
1309 char* ClassLoader::skip_uri_protocol(char* source) {
1310   if (strncmp(source, &quot;file:&quot;, 5) == 0) {
1311     // file: protocol path could start with file:/ or file:///
1312     // locate the char after all the forward slashes
1313     int offset = 5;
1314     while (*(source + offset) == &#39;/&#39;) {
1315         offset++;
1316     }
1317     source += offset;
1318   // for non-windows platforms, move back one char as the path begins with a &#39;/&#39;
1319 #ifndef _WINDOWS
1320     source -= 1;
1321 #endif
</pre>
<hr />
<pre>
1444 // process the boot classpath into a list ClassPathEntry objects.  Once
1445 // this list has been created, it must not change order (see class PackageInfo)
1446 // it can be appended to and is by jvmti and the kernel vm.
1447 
1448 void ClassLoader::initialize() {
1449   EXCEPTION_MARK;
1450 
1451   if (UsePerfData) {
1452     // jvmstat performance counters
1453     NEWPERFTICKCOUNTER(_perf_accumulated_time, SUN_CLS, &quot;time&quot;);
1454     NEWPERFTICKCOUNTER(_perf_class_init_time, SUN_CLS, &quot;classInitTime&quot;);
1455     NEWPERFTICKCOUNTER(_perf_class_init_selftime, SUN_CLS, &quot;classInitTime.self&quot;);
1456     NEWPERFTICKCOUNTER(_perf_class_verify_time, SUN_CLS, &quot;classVerifyTime&quot;);
1457     NEWPERFTICKCOUNTER(_perf_class_verify_selftime, SUN_CLS, &quot;classVerifyTime.self&quot;);
1458     NEWPERFTICKCOUNTER(_perf_class_link_time, SUN_CLS, &quot;classLinkedTime&quot;);
1459     NEWPERFTICKCOUNTER(_perf_class_link_selftime, SUN_CLS, &quot;classLinkedTime.self&quot;);
1460     NEWPERFEVENTCOUNTER(_perf_classes_inited, SUN_CLS, &quot;initializedClasses&quot;);
1461     NEWPERFEVENTCOUNTER(_perf_classes_linked, SUN_CLS, &quot;linkedClasses&quot;);
1462     NEWPERFEVENTCOUNTER(_perf_classes_verified, SUN_CLS, &quot;verifiedClasses&quot;);
1463 


1464     NEWPERFTICKCOUNTER(_perf_sys_class_lookup_time, SUN_CLS, &quot;lookupSysClassTime&quot;);
1465     NEWPERFTICKCOUNTER(_perf_shared_classload_time, SUN_CLS, &quot;sharedClassLoadTime&quot;);
1466     NEWPERFTICKCOUNTER(_perf_sys_classload_time, SUN_CLS, &quot;sysClassLoadTime&quot;);
1467     NEWPERFTICKCOUNTER(_perf_app_classload_time, SUN_CLS, &quot;appClassLoadTime&quot;);
1468     NEWPERFTICKCOUNTER(_perf_app_classload_selftime, SUN_CLS, &quot;appClassLoadTime.self&quot;);
1469     NEWPERFEVENTCOUNTER(_perf_app_classload_count, SUN_CLS, &quot;appClassLoadCount&quot;);
1470     NEWPERFTICKCOUNTER(_perf_define_appclasses, SUN_CLS, &quot;defineAppClasses&quot;);
1471     NEWPERFTICKCOUNTER(_perf_define_appclass_time, SUN_CLS, &quot;defineAppClassTime&quot;);
1472     NEWPERFTICKCOUNTER(_perf_define_appclass_selftime, SUN_CLS, &quot;defineAppClassTime.self&quot;);
1473     NEWPERFBYTECOUNTER(_perf_app_classfile_bytes_read, SUN_CLS, &quot;appClassBytes&quot;);
1474     NEWPERFBYTECOUNTER(_perf_sys_classfile_bytes_read, SUN_CLS, &quot;sysClassBytes&quot;);
1475 
1476 
1477     // The following performance counters are added for measuring the impact
1478     // of the bug fix of 6365597. They are mainly focused on finding out
1479     // the behavior of system &amp; user-defined classloader lock, whether
1480     // ClassLoader.loadClass/findClass is being called synchronized or not.
1481     NEWPERFEVENTCOUNTER(_sync_systemLoaderLockContentionRate, SUN_CLS,
1482                         &quot;systemLoaderLockContentionRate&quot;);
1483     NEWPERFEVENTCOUNTER(_sync_nonSystemLoaderLockContentionRate, SUN_CLS,
</pre>
</td>
</tr>
</table>
<center><a href="classFileParser.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classLoader.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
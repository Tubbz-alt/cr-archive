<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/systemDictionary.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="packageEntry.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="systemDictionary.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/systemDictionary.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 126   JavaValue result(T_OBJECT);
 127   InstanceKlass* class_loader_klass = SystemDictionary::ClassLoader_klass();
 128   JavaCalls::call_static(&amp;result,
 129                          class_loader_klass,
 130                          vmSymbols::getSystemClassLoader_name(),
 131                          vmSymbols::void_classloader_signature(),
 132                          CHECK);
 133 
 134   _java_system_loader = (oop)result.get_jobject();
 135 
 136   JavaCalls::call_static(&amp;result,
 137                          class_loader_klass,
 138                          vmSymbols::getPlatformClassLoader_name(),
 139                          vmSymbols::void_classloader_signature(),
 140                          CHECK);
 141 
 142   _java_platform_loader = (oop)result.get_jobject();
 143 }
 144 
 145 ClassLoaderData* SystemDictionary::register_loader(Handle class_loader) {
<span class="line-modified"> 146   if (class_loader() == NULL) return ClassLoaderData::the_null_class_loader_data();</span>
 147   return ClassLoaderDataGraph::find_or_create(class_loader);
 148 }
 149 
 150 // ----------------------------------------------------------------------------
 151 // Parallel class loading check
 152 
 153 bool SystemDictionary::is_parallelCapable(Handle class_loader) {
 154   if (class_loader.is_null()) return true;
 155   if (AlwaysLockClassLoader) return false;
 156   return java_lang_ClassLoader::parallelCapable(class_loader());
 157 }
 158 // ----------------------------------------------------------------------------
 159 // ParallelDefineClass flag does not apply to bootclass loader
 160 bool SystemDictionary::is_parallelDefine(Handle class_loader) {
 161    if (class_loader.is_null()) return false;
 162    if (AllowParallelDefineClass &amp;&amp; java_lang_ClassLoader::parallelCapable(class_loader())) {
 163      return true;
 164    }
 165    return false;
 166 }
</pre>
<hr />
<pre>
1140     assert(k != NULL, &quot;Must have an instance klass here!&quot;);
1141     loader_data-&gt;add_to_deallocate_list(k);
1142     return NULL;
1143   }
1144 
1145   // Make sure we have an entry in the SystemDictionary on success
1146   debug_only( {
1147     MutexLocker mu(THREAD, SystemDictionary_lock);
1148 
1149     Klass* check = find_class(h_name, k-&gt;class_loader_data());
1150     assert(check == k, &quot;should be present in the dictionary&quot;);
1151   } );
1152 
1153   return k;
1154 }
1155 
1156 #if INCLUDE_CDS
1157 // Load a class for boot loader from the shared spaces. This also
1158 // forces the super class and all interfaces to be loaded.
1159 InstanceKlass* SystemDictionary::load_shared_boot_class(Symbol* class_name,

1160                                                         TRAPS) {
1161   InstanceKlass* ik = SystemDictionaryShared::find_builtin_class(class_name);
1162   if (ik != NULL &amp;&amp; ik-&gt;is_shared_boot_class()) {
<span class="line-modified">1163     return load_shared_class(ik, Handle(), Handle(), NULL, THREAD);</span>
1164   }
1165   return NULL;
1166 }
1167 
1168 // Check if a shared class can be loaded by the specific classloader:
1169 //
1170 // NULL classloader:
1171 //   - Module class from &quot;modules&quot; jimage. ModuleEntry must be defined in the classloader.
1172 //   - Class from -Xbootclasspath/a. The class has no defined PackageEntry, or must
1173 //     be defined in an unnamed module.
1174 bool SystemDictionary::is_shared_class_visible(Symbol* class_name,
1175                                                InstanceKlass* ik,

1176                                                Handle class_loader, TRAPS) {
1177   assert(!ModuleEntryTable::javabase_moduleEntry()-&gt;is_patched(),
1178          &quot;Cannot use sharing if java.base is patched&quot;);
1179   ResourceMark rm(THREAD);
1180   int path_index = ik-&gt;shared_classpath_index();
1181   ClassLoaderData* loader_data = class_loader_data(class_loader);
1182   if (path_index &lt; 0) {
1183     // path_index &lt; 0 indicates that the class is intended for a custom loader
1184     // and should not be loaded by boot/platform/app loaders
1185     if (loader_data-&gt;is_builtin_class_loader_data()) {
1186       return false;
1187     } else {
1188       return true;
1189     }
1190   }
1191   SharedClassPathEntry* ent =
1192             (SharedClassPathEntry*)FileMapInfo::shared_path(path_index);
1193   if (!Universe::is_module_initialized()) {
1194     assert(ent != NULL &amp;&amp; ent-&gt;is_modules_image(),
1195            &quot;Loading non-bootstrap classes before the module system is initialized&quot;);
1196     assert(class_loader.is_null(), &quot;sanity&quot;);
1197     return true;
1198   }
1199   // Get the pkg_entry from the classloader
<span class="line-removed">1200   TempNewSymbol pkg_name = NULL;</span>
<span class="line-removed">1201   PackageEntry* pkg_entry = NULL;</span>
1202   ModuleEntry* mod_entry = NULL;
<span class="line-modified">1203   pkg_name = InstanceKlass::package_from_name(class_name, CHECK_false);</span>

1204   if (pkg_name != NULL) {
1205     if (loader_data != NULL) {
<span class="line-modified">1206       pkg_entry = loader_data-&gt;packages()-&gt;lookup_only(pkg_name);</span>
<span class="line-modified">1207     }</span>
<span class="line-modified">1208     if (pkg_entry != NULL) {</span>
<span class="line-modified">1209       mod_entry = pkg_entry-&gt;module();</span>




1210     }
1211   }
1212 
<span class="line-removed">1213   // If the archived class is from a module that has been patched at runtime,</span>
<span class="line-removed">1214   // the class cannot be loaded from the archive.</span>
<span class="line-removed">1215   if (mod_entry != NULL &amp;&amp; mod_entry-&gt;is_patched()) {</span>
<span class="line-removed">1216     return false;</span>
<span class="line-removed">1217   }</span>
<span class="line-removed">1218 </span>
1219   if (class_loader.is_null()) {
1220     assert(ent != NULL, &quot;Shared class for NULL classloader must have valid SharedClassPathEntry&quot;);
1221     // The NULL classloader can load archived class originated from the
1222     // &quot;modules&quot; jimage and the -Xbootclasspath/a. For class from the
1223     // &quot;modules&quot; jimage, the PackageEntry/ModuleEntry must be defined
1224     // by the NULL classloader.
1225     if (mod_entry != NULL) {
1226       // PackageEntry/ModuleEntry is found in the classloader. Check if the
1227       // ModuleEntry&#39;s location agrees with the archived class&#39; origination.
1228       if (ent-&gt;is_modules_image() &amp;&amp; mod_entry-&gt;location()-&gt;starts_with(&quot;jrt:&quot;)) {
1229         return true; // Module class from the &quot;module&quot; jimage
1230       }
1231     }
1232 
1233     // If the archived class is not from the &quot;module&quot; jimage, the class can be
1234     // loaded by the NULL classloader if
1235     //
1236     // 1. the class is from the unamed package
1237     // 2. or, the class is not from a module defined in the NULL classloader
1238     // 3. or, the class is from an unamed module
</pre>
<hr />
<pre>
1243           pkg_entry-&gt;in_unnamed_module()) {
1244         assert(mod_entry == NULL ||
1245                mod_entry == loader_data-&gt;unnamed_module(),
1246                &quot;the unnamed module is not defined in the classloader&quot;);
1247         return true;
1248       }
1249     }
1250     return false;
1251   } else {
1252     bool res = SystemDictionaryShared::is_shared_class_visible_for_classloader(
1253               ik, class_loader, pkg_name, pkg_entry, mod_entry, CHECK_(false));
1254     return res;
1255   }
1256 }
1257 
1258 bool SystemDictionary::check_shared_class_super_type(InstanceKlass* child, InstanceKlass* super_type,
1259                                                      Handle class_loader,  Handle protection_domain,
1260                                                      bool is_superclass, TRAPS) {
1261   assert(super_type-&gt;is_shared(), &quot;must be&quot;);
1262 
<span class="line-removed">1263   // Quick check if the super type has been already loaded.</span>
<span class="line-removed">1264   // + Don&#39;t do it for unregistered classes -- they can be unloaded so</span>
<span class="line-removed">1265   //   super_type-&gt;class_loader_data() could be stale.</span>
<span class="line-removed">1266   // + Don&#39;t take the lock if loader data is NULL.</span>
<span class="line-removed">1267   if (!super_type-&gt;is_shared_unregistered_class() &amp;&amp; super_type-&gt;class_loader_data() != NULL) {</span>
<span class="line-removed">1268     MutexLocker mu1(THREAD, SystemDictionary_lock);</span>
<span class="line-removed">1269     // Read loader_data again inside the lock for thread safety</span>
<span class="line-removed">1270     ClassLoaderData* loader_data = super_type-&gt;class_loader_data();</span>
<span class="line-removed">1271     if (loader_data != NULL) {</span>
<span class="line-removed">1272       Symbol* name = super_type-&gt;name();</span>
<span class="line-removed">1273       Dictionary* dictionary = loader_data-&gt;dictionary();</span>
<span class="line-removed">1274       unsigned int d_hash = dictionary-&gt;compute_hash(name);</span>
<span class="line-removed">1275       if (SystemDictionary::find_class(d_hash, name, dictionary) != super_type) {</span>
<span class="line-removed">1276         return true;</span>
<span class="line-removed">1277       }</span>
<span class="line-removed">1278     }</span>
<span class="line-removed">1279   }</span>
<span class="line-removed">1280 </span>
<span class="line-removed">1281   // Not sure if super type is loaded. Do it the slow way.</span>
1282   Klass *found = resolve_super_or_fail(child-&gt;name(), super_type-&gt;name(),
1283                                        class_loader, protection_domain, is_superclass, CHECK_0);
1284   if (found == super_type) {
1285     return true;
1286   } else {
1287     // The dynamically resolved super type is not the same as the one we used during dump time,
1288     // so we cannot use the child class.
1289     return false;
1290   }
1291 }
1292 
1293 bool SystemDictionary::check_shared_class_super_types(InstanceKlass* ik, Handle class_loader,
1294                                                       Handle protection_domain, TRAPS) {
1295   // Check the superclass and interfaces. They must be the same
1296   // as in dump time, because the layout of &lt;ik&gt; depends on
1297   // the specific layout of ik-&gt;super() and ik-&gt;local_interfaces().
1298   //
1299   // If unexpected superclass or interfaces are found, we cannot
1300   // load &lt;ik&gt; from the shared archive.
1301 
</pre>
<hr />
<pre>
1303       !check_shared_class_super_type(ik, InstanceKlass::cast(ik-&gt;super()),
1304                                      class_loader, protection_domain, true, THREAD)) {
1305     return false;
1306   }
1307 
1308   Array&lt;InstanceKlass*&gt;* interfaces = ik-&gt;local_interfaces();
1309   int num_interfaces = interfaces-&gt;length();
1310   for (int index = 0; index &lt; num_interfaces; index++) {
1311     if (!check_shared_class_super_type(ik, interfaces-&gt;at(index), class_loader, protection_domain, false, THREAD)) {
1312       return false;
1313     }
1314   }
1315 
1316   return true;
1317 }
1318 
1319 InstanceKlass* SystemDictionary::load_shared_class(InstanceKlass* ik,
1320                                                    Handle class_loader,
1321                                                    Handle protection_domain,
1322                                                    const ClassFileStream *cfs,

1323                                                    TRAPS) {
1324   assert(ik != NULL, &quot;sanity&quot;);
1325   assert(!ik-&gt;is_unshareable_info_restored(), &quot;shared class can be loaded only once&quot;);
1326   Symbol* class_name = ik-&gt;name();
1327 
1328   bool visible = is_shared_class_visible(
<span class="line-modified">1329                           class_name, ik, class_loader, CHECK_NULL);</span>
1330   if (!visible) {
1331     return NULL;
1332   }
1333 
1334   if (!check_shared_class_super_types(ik, class_loader, protection_domain, THREAD)) {
1335     return NULL;
1336   }
1337 
1338   InstanceKlass* new_ik = KlassFactory::check_shared_class_file_load_hook(
1339       ik, class_name, class_loader, protection_domain, cfs, CHECK_NULL);
1340   if (new_ik != NULL) {
1341     // The class is changed by CFLH. Return the new class. The shared class is
1342     // not used.
1343     return new_ik;
1344   }
1345 
1346   // Adjust methods to recover missing data.  They need addresses for
1347   // interpreter entry points and their default native method address
1348   // must be reset.
1349 
1350   // Updating methods must be done under a lock so multiple
1351   // threads don&#39;t update these in parallel
1352   //
1353   // Shared classes are all currently loaded by either the bootstrap or
1354   // internal parallel class loaders, so this will never cause a deadlock
1355   // on a custom class loader lock.
1356 
1357   ClassLoaderData* loader_data = ClassLoaderData::class_loader_data(class_loader());
1358   {
1359     HandleMark hm(THREAD);
1360     Handle lockObject = compute_loader_lock_object(class_loader, THREAD);
1361     check_loader_lock_contention(lockObject, THREAD);
1362     ObjectLocker ol(lockObject, THREAD, true);
1363     // prohibited package check assumes all classes loaded from archive call
1364     // restore_unshareable_info which calls ik-&gt;set_package()
<span class="line-modified">1365     ik-&gt;restore_unshareable_info(loader_data, protection_domain, CHECK_NULL);</span>
1366   }
1367 
1368   load_shared_class_misc(ik, loader_data, CHECK_NULL);
1369   return ik;
1370 }
1371 
1372 void SystemDictionary::load_shared_class_misc(InstanceKlass* ik, ClassLoaderData* loader_data, TRAPS) {
1373   ik-&gt;print_class_load_logging(loader_data, NULL, NULL);
1374 
1375   // For boot loader, ensure that GetSystemPackage knows that a class in this
1376   // package was loaded.
1377   if (loader_data-&gt;is_the_null_class_loader_data()) {
1378     int path_index = ik-&gt;shared_classpath_index();
<span class="line-modified">1379     ResourceMark rm(THREAD);</span>
<span class="line-removed">1380     ClassLoader::add_package(ik-&gt;name()-&gt;as_C_string(), path_index, THREAD);</span>
1381   }
1382 
1383   if (DumpLoadedClassList != NULL &amp;&amp; classlist_file-&gt;is_open()) {
1384     // Only dump the classes that can be stored into CDS archive
1385     if (SystemDictionaryShared::is_sharing_possible(loader_data)) {
1386       ResourceMark rm(THREAD);
1387       classlist_file-&gt;print_cr(&quot;%s&quot;, ik-&gt;name()-&gt;as_C_string());
1388       classlist_file-&gt;flush();
1389     }
1390   }
1391 
1392   // notify a class loaded from shared object
1393   ClassLoadingService::notify_class_loaded(ik, true /* shared class */);
1394 
1395   ik-&gt;set_has_passed_fingerprint_check(false);
1396   if (UseAOT &amp;&amp; ik-&gt;supers_have_passed_fingerprint_checks()) {
1397     uint64_t aot_fp = AOTLoader::get_saved_fingerprint(ik);
1398     uint64_t cds_fp = ik-&gt;get_stored_fingerprint();
1399     if (aot_fp != 0 &amp;&amp; aot_fp == cds_fp) {
1400       // This class matches with a class saved in an AOT library
</pre>
<hr />
<pre>
1413   assert(klass-&gt;is_shared(), &quot;Must be shared class&quot;);
1414   if (klass-&gt;class_loader_data() != NULL) {
1415     return;
1416   }
1417 
1418   // add super and interfaces first
1419   Klass* super = klass-&gt;super();
1420   if (super != NULL &amp;&amp; super-&gt;class_loader_data() == NULL) {
1421     assert(super-&gt;is_instance_klass(), &quot;Super should be instance klass&quot;);
1422     quick_resolve(InstanceKlass::cast(super), loader_data, domain, CHECK);
1423   }
1424 
1425   Array&lt;InstanceKlass*&gt;* ifs = klass-&gt;local_interfaces();
1426   for (int i = 0; i &lt; ifs-&gt;length(); i++) {
1427     InstanceKlass* ik = ifs-&gt;at(i);
1428     if (ik-&gt;class_loader_data()  == NULL) {
1429       quick_resolve(ik, loader_data, domain, CHECK);
1430     }
1431   }
1432 
<span class="line-modified">1433   klass-&gt;restore_unshareable_info(loader_data, domain, THREAD);</span>
1434   load_shared_class_misc(klass, loader_data, CHECK);
1435   Dictionary* dictionary = loader_data-&gt;dictionary();
1436   unsigned int hash = dictionary-&gt;compute_hash(klass-&gt;name());
1437   dictionary-&gt;add_klass(hash, klass-&gt;name(), klass);
1438   add_to_hierarchy(klass, CHECK);
1439   assert(klass-&gt;is_loaded(), &quot;Must be in at least loaded state&quot;);
1440 }
1441 #endif // INCLUDE_CDS
1442 
1443 InstanceKlass* SystemDictionary::load_instance_class(Symbol* class_name, Handle class_loader, TRAPS) {
1444 
1445   if (class_loader.is_null()) {
1446     ResourceMark rm(THREAD);
1447     PackageEntry* pkg_entry = NULL;
1448     bool search_only_bootloader_append = false;
1449     ClassLoaderData *loader_data = class_loader_data(class_loader);
1450 
1451     // Find the package in the boot loader&#39;s package entry table.
<span class="line-modified">1452     TempNewSymbol pkg_name = InstanceKlass::package_from_name(class_name, CHECK_NULL);</span>
1453     if (pkg_name != NULL) {
1454       pkg_entry = loader_data-&gt;packages()-&gt;lookup_only(pkg_name);
1455     }
1456 
1457     // Prior to attempting to load the class, enforce the boot loader&#39;s
1458     // visibility boundaries.
1459     if (!Universe::is_module_initialized()) {
1460       // During bootstrapping, prior to module initialization, any
1461       // class attempting to be loaded must be checked against the
1462       // java.base packages in the boot loader&#39;s PackageEntryTable.
1463       // No class outside of java.base is allowed to be loaded during
1464       // this bootstrapping window.
1465       if (pkg_entry == NULL || pkg_entry-&gt;in_unnamed_module()) {
1466         // Class is either in the unnamed package or in
1467         // a named package within the unnamed module.  Either
1468         // case is outside of java.base, do not attempt to
1469         // load the class post java.base definition.  If
1470         // java.base has not been defined, let the class load
1471         // and its package will be checked later by
1472         // ModuleEntryTable::verify_javabase_packages.
</pre>
<hr />
<pre>
1493         if (!ClassLoader::has_bootclasspath_append()) {
1494            // If there is no bootclasspath append entry, no need to continue
1495            // searching.
1496            return NULL;
1497         }
1498         search_only_bootloader_append = true;
1499       }
1500     }
1501 
1502     // Prior to bootstrapping&#39;s module initialization, never load a class outside
1503     // of the boot loader&#39;s module path
1504     assert(Universe::is_module_initialized() ||
1505            !search_only_bootloader_append,
1506            &quot;Attempt to load a class outside of boot loader&#39;s module path&quot;);
1507 
1508     // Search for classes in the CDS archive.
1509     InstanceKlass* k = NULL;
1510     {
1511 #if INCLUDE_CDS
1512       PerfTraceTime vmtimer(ClassLoader::perf_shared_classload_time());
<span class="line-modified">1513       k = load_shared_boot_class(class_name, THREAD);</span>
1514 #endif
1515     }
1516 
1517     if (k == NULL) {
1518       // Use VM class loader
1519       PerfTraceTime vmtimer(ClassLoader::perf_sys_classload_time());
1520       k = ClassLoader::load_class(class_name, search_only_bootloader_append, CHECK_NULL);
1521     }
1522 
1523     // find_or_define_instance_class may return a different InstanceKlass
1524     if (k != NULL) {
1525       InstanceKlass* defined_k =
1526         find_or_define_instance_class(class_name, class_loader, k, THREAD);
1527       if (!HAS_PENDING_EXCEPTION &amp;&amp; defined_k != k) {
1528         // If a parallel capable class loader already defined this class, register &#39;k&#39; for cleanup.
1529         assert(defined_k != NULL, &quot;Should have a klass if there&#39;s no exception&quot;);
1530         loader_data-&gt;add_to_deallocate_list(k);
1531         k = defined_k;
1532       } else if (HAS_PENDING_EXCEPTION) {
1533         loader_data-&gt;add_to_deallocate_list(k);
</pre>
<hr />
<pre>
2571          &quot;one or the other, or perhaps neither&quot;);
2572 
2573   // What we have here must be a valid field descriptor,
2574   // and all valid field descriptors are supported.
2575   // Produce the same java.lang.Class that reflection reports.
2576   if (accessing_klass != NULL) {
2577     class_loader      = Handle(THREAD, accessing_klass-&gt;class_loader());
2578     protection_domain = Handle(THREAD, accessing_klass-&gt;protection_domain());
2579   }
2580   ResolvingSignatureStream ss(signature, class_loader, protection_domain, false);
2581   oop mirror_oop = ss.as_java_mirror(failure_mode, CHECK_NH);
2582   if (mirror_oop == NULL) {
2583     return Handle();  // report failure this way
2584   }
2585   Handle mirror(THREAD, mirror_oop);
2586 
2587   if (accessing_klass != NULL) {
2588     // Check accessibility, emulating ConstantPool::verify_constant_pool_resolve.
2589     Klass* sel_klass = java_lang_Class::as_Klass(mirror());
2590     if (sel_klass != NULL) {
<span class="line-modified">2591       bool fold_type_to_class = true;</span>
<span class="line-removed">2592       LinkResolver::check_klass_accessability(accessing_klass, sel_klass,</span>
<span class="line-removed">2593                                               fold_type_to_class, CHECK_NH);</span>
2594     }
2595   }
2596   return mirror;
2597 }
2598 
2599 
2600 // Ask Java code to find or construct a java.lang.invoke.MethodType for the given
2601 // signature, as interpreted relative to the given class loader.
2602 // Because of class loader constraints, all method handle usage must be
2603 // consistent with this loader.
2604 Handle SystemDictionary::find_method_handle_type(Symbol* signature,
2605                                                  Klass* accessing_klass,
2606                                                  TRAPS) {
2607   Handle empty;
2608   vmIntrinsics::ID null_iid = vmIntrinsics::_none;  // distinct from all method handle invoker intrinsics
2609   unsigned int hash  = invoke_method_table()-&gt;compute_hash(signature, null_iid);
2610   int          index = invoke_method_table()-&gt;hash_to_index(hash);
2611   SymbolPropertyEntry* spe = invoke_method_table()-&gt;find_entry(index, hash, signature, null_iid);
2612   if (spe != NULL &amp;&amp; spe-&gt;method_type() != NULL) {
2613     assert(java_lang_invoke_MethodType::is_instance(spe-&gt;method_type()), &quot;&quot;);
</pre>
<hr />
<pre>
2638         // Fall back to accessing_klass context.
2639         can_be_cached = false;
2640       }
2641     }
2642     if (!can_be_cached) {
2643       // Resolve, throwing a real error if it doesn&#39;t work.
2644       mirror = ss.as_java_mirror(class_loader, protection_domain,
2645                                  SignatureStream::NCDFError, CHECK_(empty));
2646     }
2647     assert(mirror != NULL, &quot;%s&quot;, ss.as_symbol()-&gt;as_C_string());
2648     if (ss.at_return_type())
2649       rt = Handle(THREAD, mirror);
2650     else
2651       pts-&gt;obj_at_put(arg++, mirror);
2652 
2653     // Check accessibility.
2654     if (!java_lang_Class::is_primitive(mirror) &amp;&amp; accessing_klass != NULL) {
2655       Klass* sel_klass = java_lang_Class::as_Klass(mirror);
2656       mirror = NULL;  // safety
2657       // Emulate ConstantPool::verify_constant_pool_resolve.
<span class="line-modified">2658       bool fold_type_to_class = true;</span>
<span class="line-removed">2659       LinkResolver::check_klass_accessability(accessing_klass, sel_klass,</span>
<span class="line-removed">2660                                               fold_type_to_class, CHECK_(empty));</span>
2661     }
2662   }
2663   assert(arg == npts, &quot;&quot;);
2664 
2665   // call java.lang.invoke.MethodHandleNatives::findMethodHandleType(Class rt, Class[] pts) -&gt; MethodType
2666   JavaCallArguments args(Handle(THREAD, rt()));
2667   args.push_oop(pts);
2668   JavaValue result(T_OBJECT);
2669   JavaCalls::call_static(&amp;result,
2670                          SystemDictionary::MethodHandleNatives_klass(),
2671                          vmSymbols::findMethodHandleType_name(),
2672                          vmSymbols::findMethodHandleType_signature(),
2673                          &amp;args, CHECK_(empty));
2674   Handle method_type(THREAD, (oop) result.get_jobject());
2675 
2676   if (can_be_cached) {
2677     // We can cache this MethodType inside the JVM.
2678     MutexLocker ml(THREAD, SystemDictionary_lock);
2679     spe = invoke_method_table()-&gt;find_entry(index, hash, signature, null_iid);
2680     if (spe == NULL)
</pre>
</td>
<td>
<hr />
<pre>
 126   JavaValue result(T_OBJECT);
 127   InstanceKlass* class_loader_klass = SystemDictionary::ClassLoader_klass();
 128   JavaCalls::call_static(&amp;result,
 129                          class_loader_klass,
 130                          vmSymbols::getSystemClassLoader_name(),
 131                          vmSymbols::void_classloader_signature(),
 132                          CHECK);
 133 
 134   _java_system_loader = (oop)result.get_jobject();
 135 
 136   JavaCalls::call_static(&amp;result,
 137                          class_loader_klass,
 138                          vmSymbols::getPlatformClassLoader_name(),
 139                          vmSymbols::void_classloader_signature(),
 140                          CHECK);
 141 
 142   _java_platform_loader = (oop)result.get_jobject();
 143 }
 144 
 145 ClassLoaderData* SystemDictionary::register_loader(Handle class_loader) {
<span class="line-modified"> 146   if (class_loader.is_null()) return ClassLoaderData::the_null_class_loader_data();</span>
 147   return ClassLoaderDataGraph::find_or_create(class_loader);
 148 }
 149 
 150 // ----------------------------------------------------------------------------
 151 // Parallel class loading check
 152 
 153 bool SystemDictionary::is_parallelCapable(Handle class_loader) {
 154   if (class_loader.is_null()) return true;
 155   if (AlwaysLockClassLoader) return false;
 156   return java_lang_ClassLoader::parallelCapable(class_loader());
 157 }
 158 // ----------------------------------------------------------------------------
 159 // ParallelDefineClass flag does not apply to bootclass loader
 160 bool SystemDictionary::is_parallelDefine(Handle class_loader) {
 161    if (class_loader.is_null()) return false;
 162    if (AllowParallelDefineClass &amp;&amp; java_lang_ClassLoader::parallelCapable(class_loader())) {
 163      return true;
 164    }
 165    return false;
 166 }
</pre>
<hr />
<pre>
1140     assert(k != NULL, &quot;Must have an instance klass here!&quot;);
1141     loader_data-&gt;add_to_deallocate_list(k);
1142     return NULL;
1143   }
1144 
1145   // Make sure we have an entry in the SystemDictionary on success
1146   debug_only( {
1147     MutexLocker mu(THREAD, SystemDictionary_lock);
1148 
1149     Klass* check = find_class(h_name, k-&gt;class_loader_data());
1150     assert(check == k, &quot;should be present in the dictionary&quot;);
1151   } );
1152 
1153   return k;
1154 }
1155 
1156 #if INCLUDE_CDS
1157 // Load a class for boot loader from the shared spaces. This also
1158 // forces the super class and all interfaces to be loaded.
1159 InstanceKlass* SystemDictionary::load_shared_boot_class(Symbol* class_name,
<span class="line-added">1160                                                         PackageEntry* pkg_entry,</span>
1161                                                         TRAPS) {
1162   InstanceKlass* ik = SystemDictionaryShared::find_builtin_class(class_name);
1163   if (ik != NULL &amp;&amp; ik-&gt;is_shared_boot_class()) {
<span class="line-modified">1164     return load_shared_class(ik, Handle(), Handle(), NULL, pkg_entry, THREAD);</span>
1165   }
1166   return NULL;
1167 }
1168 
1169 // Check if a shared class can be loaded by the specific classloader:
1170 //
1171 // NULL classloader:
1172 //   - Module class from &quot;modules&quot; jimage. ModuleEntry must be defined in the classloader.
1173 //   - Class from -Xbootclasspath/a. The class has no defined PackageEntry, or must
1174 //     be defined in an unnamed module.
1175 bool SystemDictionary::is_shared_class_visible(Symbol* class_name,
1176                                                InstanceKlass* ik,
<span class="line-added">1177                                                PackageEntry* pkg_entry,</span>
1178                                                Handle class_loader, TRAPS) {
1179   assert(!ModuleEntryTable::javabase_moduleEntry()-&gt;is_patched(),
1180          &quot;Cannot use sharing if java.base is patched&quot;);
1181   ResourceMark rm(THREAD);
1182   int path_index = ik-&gt;shared_classpath_index();
1183   ClassLoaderData* loader_data = class_loader_data(class_loader);
1184   if (path_index &lt; 0) {
1185     // path_index &lt; 0 indicates that the class is intended for a custom loader
1186     // and should not be loaded by boot/platform/app loaders
1187     if (loader_data-&gt;is_builtin_class_loader_data()) {
1188       return false;
1189     } else {
1190       return true;
1191     }
1192   }
1193   SharedClassPathEntry* ent =
1194             (SharedClassPathEntry*)FileMapInfo::shared_path(path_index);
1195   if (!Universe::is_module_initialized()) {
1196     assert(ent != NULL &amp;&amp; ent-&gt;is_modules_image(),
1197            &quot;Loading non-bootstrap classes before the module system is initialized&quot;);
1198     assert(class_loader.is_null(), &quot;sanity&quot;);
1199     return true;
1200   }
1201   // Get the pkg_entry from the classloader


1202   ModuleEntry* mod_entry = NULL;
<span class="line-modified">1203   TempNewSymbol pkg_name = pkg_entry != NULL ? pkg_entry-&gt;name() :</span>
<span class="line-added">1204                                                ClassLoader::package_from_class_name(class_name);</span>
1205   if (pkg_name != NULL) {
1206     if (loader_data != NULL) {
<span class="line-modified">1207       if (pkg_entry != NULL) {</span>
<span class="line-modified">1208         mod_entry = pkg_entry-&gt;module();</span>
<span class="line-modified">1209         // If the archived class is from a module that has been patched at runtime,</span>
<span class="line-modified">1210         // the class cannot be loaded from the archive.</span>
<span class="line-added">1211         if (mod_entry != NULL &amp;&amp; mod_entry-&gt;is_patched()) {</span>
<span class="line-added">1212           return false;</span>
<span class="line-added">1213         }</span>
<span class="line-added">1214       }</span>
1215     }
1216   }
1217 






1218   if (class_loader.is_null()) {
1219     assert(ent != NULL, &quot;Shared class for NULL classloader must have valid SharedClassPathEntry&quot;);
1220     // The NULL classloader can load archived class originated from the
1221     // &quot;modules&quot; jimage and the -Xbootclasspath/a. For class from the
1222     // &quot;modules&quot; jimage, the PackageEntry/ModuleEntry must be defined
1223     // by the NULL classloader.
1224     if (mod_entry != NULL) {
1225       // PackageEntry/ModuleEntry is found in the classloader. Check if the
1226       // ModuleEntry&#39;s location agrees with the archived class&#39; origination.
1227       if (ent-&gt;is_modules_image() &amp;&amp; mod_entry-&gt;location()-&gt;starts_with(&quot;jrt:&quot;)) {
1228         return true; // Module class from the &quot;module&quot; jimage
1229       }
1230     }
1231 
1232     // If the archived class is not from the &quot;module&quot; jimage, the class can be
1233     // loaded by the NULL classloader if
1234     //
1235     // 1. the class is from the unamed package
1236     // 2. or, the class is not from a module defined in the NULL classloader
1237     // 3. or, the class is from an unamed module
</pre>
<hr />
<pre>
1242           pkg_entry-&gt;in_unnamed_module()) {
1243         assert(mod_entry == NULL ||
1244                mod_entry == loader_data-&gt;unnamed_module(),
1245                &quot;the unnamed module is not defined in the classloader&quot;);
1246         return true;
1247       }
1248     }
1249     return false;
1250   } else {
1251     bool res = SystemDictionaryShared::is_shared_class_visible_for_classloader(
1252               ik, class_loader, pkg_name, pkg_entry, mod_entry, CHECK_(false));
1253     return res;
1254   }
1255 }
1256 
1257 bool SystemDictionary::check_shared_class_super_type(InstanceKlass* child, InstanceKlass* super_type,
1258                                                      Handle class_loader,  Handle protection_domain,
1259                                                      bool is_superclass, TRAPS) {
1260   assert(super_type-&gt;is_shared(), &quot;must be&quot;);
1261 



















1262   Klass *found = resolve_super_or_fail(child-&gt;name(), super_type-&gt;name(),
1263                                        class_loader, protection_domain, is_superclass, CHECK_0);
1264   if (found == super_type) {
1265     return true;
1266   } else {
1267     // The dynamically resolved super type is not the same as the one we used during dump time,
1268     // so we cannot use the child class.
1269     return false;
1270   }
1271 }
1272 
1273 bool SystemDictionary::check_shared_class_super_types(InstanceKlass* ik, Handle class_loader,
1274                                                       Handle protection_domain, TRAPS) {
1275   // Check the superclass and interfaces. They must be the same
1276   // as in dump time, because the layout of &lt;ik&gt; depends on
1277   // the specific layout of ik-&gt;super() and ik-&gt;local_interfaces().
1278   //
1279   // If unexpected superclass or interfaces are found, we cannot
1280   // load &lt;ik&gt; from the shared archive.
1281 
</pre>
<hr />
<pre>
1283       !check_shared_class_super_type(ik, InstanceKlass::cast(ik-&gt;super()),
1284                                      class_loader, protection_domain, true, THREAD)) {
1285     return false;
1286   }
1287 
1288   Array&lt;InstanceKlass*&gt;* interfaces = ik-&gt;local_interfaces();
1289   int num_interfaces = interfaces-&gt;length();
1290   for (int index = 0; index &lt; num_interfaces; index++) {
1291     if (!check_shared_class_super_type(ik, interfaces-&gt;at(index), class_loader, protection_domain, false, THREAD)) {
1292       return false;
1293     }
1294   }
1295 
1296   return true;
1297 }
1298 
1299 InstanceKlass* SystemDictionary::load_shared_class(InstanceKlass* ik,
1300                                                    Handle class_loader,
1301                                                    Handle protection_domain,
1302                                                    const ClassFileStream *cfs,
<span class="line-added">1303                                                    PackageEntry* pkg_entry,</span>
1304                                                    TRAPS) {
1305   assert(ik != NULL, &quot;sanity&quot;);
1306   assert(!ik-&gt;is_unshareable_info_restored(), &quot;shared class can be loaded only once&quot;);
1307   Symbol* class_name = ik-&gt;name();
1308 
1309   bool visible = is_shared_class_visible(
<span class="line-modified">1310                           class_name, ik, pkg_entry, class_loader, CHECK_NULL);</span>
1311   if (!visible) {
1312     return NULL;
1313   }
1314 
1315   if (!check_shared_class_super_types(ik, class_loader, protection_domain, THREAD)) {
1316     return NULL;
1317   }
1318 
1319   InstanceKlass* new_ik = KlassFactory::check_shared_class_file_load_hook(
1320       ik, class_name, class_loader, protection_domain, cfs, CHECK_NULL);
1321   if (new_ik != NULL) {
1322     // The class is changed by CFLH. Return the new class. The shared class is
1323     // not used.
1324     return new_ik;
1325   }
1326 
1327   // Adjust methods to recover missing data.  They need addresses for
1328   // interpreter entry points and their default native method address
1329   // must be reset.
1330 
1331   // Updating methods must be done under a lock so multiple
1332   // threads don&#39;t update these in parallel
1333   //
1334   // Shared classes are all currently loaded by either the bootstrap or
1335   // internal parallel class loaders, so this will never cause a deadlock
1336   // on a custom class loader lock.
1337 
1338   ClassLoaderData* loader_data = ClassLoaderData::class_loader_data(class_loader());
1339   {
1340     HandleMark hm(THREAD);
1341     Handle lockObject = compute_loader_lock_object(class_loader, THREAD);
1342     check_loader_lock_contention(lockObject, THREAD);
1343     ObjectLocker ol(lockObject, THREAD, true);
1344     // prohibited package check assumes all classes loaded from archive call
1345     // restore_unshareable_info which calls ik-&gt;set_package()
<span class="line-modified">1346     ik-&gt;restore_unshareable_info(loader_data, protection_domain, pkg_entry, CHECK_NULL);</span>
1347   }
1348 
1349   load_shared_class_misc(ik, loader_data, CHECK_NULL);
1350   return ik;
1351 }
1352 
1353 void SystemDictionary::load_shared_class_misc(InstanceKlass* ik, ClassLoaderData* loader_data, TRAPS) {
1354   ik-&gt;print_class_load_logging(loader_data, NULL, NULL);
1355 
1356   // For boot loader, ensure that GetSystemPackage knows that a class in this
1357   // package was loaded.
1358   if (loader_data-&gt;is_the_null_class_loader_data()) {
1359     int path_index = ik-&gt;shared_classpath_index();
<span class="line-modified">1360     ClassLoader::add_package(ik, path_index, THREAD);</span>

1361   }
1362 
1363   if (DumpLoadedClassList != NULL &amp;&amp; classlist_file-&gt;is_open()) {
1364     // Only dump the classes that can be stored into CDS archive
1365     if (SystemDictionaryShared::is_sharing_possible(loader_data)) {
1366       ResourceMark rm(THREAD);
1367       classlist_file-&gt;print_cr(&quot;%s&quot;, ik-&gt;name()-&gt;as_C_string());
1368       classlist_file-&gt;flush();
1369     }
1370   }
1371 
1372   // notify a class loaded from shared object
1373   ClassLoadingService::notify_class_loaded(ik, true /* shared class */);
1374 
1375   ik-&gt;set_has_passed_fingerprint_check(false);
1376   if (UseAOT &amp;&amp; ik-&gt;supers_have_passed_fingerprint_checks()) {
1377     uint64_t aot_fp = AOTLoader::get_saved_fingerprint(ik);
1378     uint64_t cds_fp = ik-&gt;get_stored_fingerprint();
1379     if (aot_fp != 0 &amp;&amp; aot_fp == cds_fp) {
1380       // This class matches with a class saved in an AOT library
</pre>
<hr />
<pre>
1393   assert(klass-&gt;is_shared(), &quot;Must be shared class&quot;);
1394   if (klass-&gt;class_loader_data() != NULL) {
1395     return;
1396   }
1397 
1398   // add super and interfaces first
1399   Klass* super = klass-&gt;super();
1400   if (super != NULL &amp;&amp; super-&gt;class_loader_data() == NULL) {
1401     assert(super-&gt;is_instance_klass(), &quot;Super should be instance klass&quot;);
1402     quick_resolve(InstanceKlass::cast(super), loader_data, domain, CHECK);
1403   }
1404 
1405   Array&lt;InstanceKlass*&gt;* ifs = klass-&gt;local_interfaces();
1406   for (int i = 0; i &lt; ifs-&gt;length(); i++) {
1407     InstanceKlass* ik = ifs-&gt;at(i);
1408     if (ik-&gt;class_loader_data()  == NULL) {
1409       quick_resolve(ik, loader_data, domain, CHECK);
1410     }
1411   }
1412 
<span class="line-modified">1413   klass-&gt;restore_unshareable_info(loader_data, domain, NULL, THREAD);</span>
1414   load_shared_class_misc(klass, loader_data, CHECK);
1415   Dictionary* dictionary = loader_data-&gt;dictionary();
1416   unsigned int hash = dictionary-&gt;compute_hash(klass-&gt;name());
1417   dictionary-&gt;add_klass(hash, klass-&gt;name(), klass);
1418   add_to_hierarchy(klass, CHECK);
1419   assert(klass-&gt;is_loaded(), &quot;Must be in at least loaded state&quot;);
1420 }
1421 #endif // INCLUDE_CDS
1422 
1423 InstanceKlass* SystemDictionary::load_instance_class(Symbol* class_name, Handle class_loader, TRAPS) {
1424 
1425   if (class_loader.is_null()) {
1426     ResourceMark rm(THREAD);
1427     PackageEntry* pkg_entry = NULL;
1428     bool search_only_bootloader_append = false;
1429     ClassLoaderData *loader_data = class_loader_data(class_loader);
1430 
1431     // Find the package in the boot loader&#39;s package entry table.
<span class="line-modified">1432     TempNewSymbol pkg_name = ClassLoader::package_from_class_name(class_name);</span>
1433     if (pkg_name != NULL) {
1434       pkg_entry = loader_data-&gt;packages()-&gt;lookup_only(pkg_name);
1435     }
1436 
1437     // Prior to attempting to load the class, enforce the boot loader&#39;s
1438     // visibility boundaries.
1439     if (!Universe::is_module_initialized()) {
1440       // During bootstrapping, prior to module initialization, any
1441       // class attempting to be loaded must be checked against the
1442       // java.base packages in the boot loader&#39;s PackageEntryTable.
1443       // No class outside of java.base is allowed to be loaded during
1444       // this bootstrapping window.
1445       if (pkg_entry == NULL || pkg_entry-&gt;in_unnamed_module()) {
1446         // Class is either in the unnamed package or in
1447         // a named package within the unnamed module.  Either
1448         // case is outside of java.base, do not attempt to
1449         // load the class post java.base definition.  If
1450         // java.base has not been defined, let the class load
1451         // and its package will be checked later by
1452         // ModuleEntryTable::verify_javabase_packages.
</pre>
<hr />
<pre>
1473         if (!ClassLoader::has_bootclasspath_append()) {
1474            // If there is no bootclasspath append entry, no need to continue
1475            // searching.
1476            return NULL;
1477         }
1478         search_only_bootloader_append = true;
1479       }
1480     }
1481 
1482     // Prior to bootstrapping&#39;s module initialization, never load a class outside
1483     // of the boot loader&#39;s module path
1484     assert(Universe::is_module_initialized() ||
1485            !search_only_bootloader_append,
1486            &quot;Attempt to load a class outside of boot loader&#39;s module path&quot;);
1487 
1488     // Search for classes in the CDS archive.
1489     InstanceKlass* k = NULL;
1490     {
1491 #if INCLUDE_CDS
1492       PerfTraceTime vmtimer(ClassLoader::perf_shared_classload_time());
<span class="line-modified">1493       k = load_shared_boot_class(class_name, pkg_entry, THREAD);</span>
1494 #endif
1495     }
1496 
1497     if (k == NULL) {
1498       // Use VM class loader
1499       PerfTraceTime vmtimer(ClassLoader::perf_sys_classload_time());
1500       k = ClassLoader::load_class(class_name, search_only_bootloader_append, CHECK_NULL);
1501     }
1502 
1503     // find_or_define_instance_class may return a different InstanceKlass
1504     if (k != NULL) {
1505       InstanceKlass* defined_k =
1506         find_or_define_instance_class(class_name, class_loader, k, THREAD);
1507       if (!HAS_PENDING_EXCEPTION &amp;&amp; defined_k != k) {
1508         // If a parallel capable class loader already defined this class, register &#39;k&#39; for cleanup.
1509         assert(defined_k != NULL, &quot;Should have a klass if there&#39;s no exception&quot;);
1510         loader_data-&gt;add_to_deallocate_list(k);
1511         k = defined_k;
1512       } else if (HAS_PENDING_EXCEPTION) {
1513         loader_data-&gt;add_to_deallocate_list(k);
</pre>
<hr />
<pre>
2551          &quot;one or the other, or perhaps neither&quot;);
2552 
2553   // What we have here must be a valid field descriptor,
2554   // and all valid field descriptors are supported.
2555   // Produce the same java.lang.Class that reflection reports.
2556   if (accessing_klass != NULL) {
2557     class_loader      = Handle(THREAD, accessing_klass-&gt;class_loader());
2558     protection_domain = Handle(THREAD, accessing_klass-&gt;protection_domain());
2559   }
2560   ResolvingSignatureStream ss(signature, class_loader, protection_domain, false);
2561   oop mirror_oop = ss.as_java_mirror(failure_mode, CHECK_NH);
2562   if (mirror_oop == NULL) {
2563     return Handle();  // report failure this way
2564   }
2565   Handle mirror(THREAD, mirror_oop);
2566 
2567   if (accessing_klass != NULL) {
2568     // Check accessibility, emulating ConstantPool::verify_constant_pool_resolve.
2569     Klass* sel_klass = java_lang_Class::as_Klass(mirror());
2570     if (sel_klass != NULL) {
<span class="line-modified">2571       LinkResolver::check_klass_accessibility(accessing_klass, sel_klass, CHECK_NH);</span>


2572     }
2573   }
2574   return mirror;
2575 }
2576 
2577 
2578 // Ask Java code to find or construct a java.lang.invoke.MethodType for the given
2579 // signature, as interpreted relative to the given class loader.
2580 // Because of class loader constraints, all method handle usage must be
2581 // consistent with this loader.
2582 Handle SystemDictionary::find_method_handle_type(Symbol* signature,
2583                                                  Klass* accessing_klass,
2584                                                  TRAPS) {
2585   Handle empty;
2586   vmIntrinsics::ID null_iid = vmIntrinsics::_none;  // distinct from all method handle invoker intrinsics
2587   unsigned int hash  = invoke_method_table()-&gt;compute_hash(signature, null_iid);
2588   int          index = invoke_method_table()-&gt;hash_to_index(hash);
2589   SymbolPropertyEntry* spe = invoke_method_table()-&gt;find_entry(index, hash, signature, null_iid);
2590   if (spe != NULL &amp;&amp; spe-&gt;method_type() != NULL) {
2591     assert(java_lang_invoke_MethodType::is_instance(spe-&gt;method_type()), &quot;&quot;);
</pre>
<hr />
<pre>
2616         // Fall back to accessing_klass context.
2617         can_be_cached = false;
2618       }
2619     }
2620     if (!can_be_cached) {
2621       // Resolve, throwing a real error if it doesn&#39;t work.
2622       mirror = ss.as_java_mirror(class_loader, protection_domain,
2623                                  SignatureStream::NCDFError, CHECK_(empty));
2624     }
2625     assert(mirror != NULL, &quot;%s&quot;, ss.as_symbol()-&gt;as_C_string());
2626     if (ss.at_return_type())
2627       rt = Handle(THREAD, mirror);
2628     else
2629       pts-&gt;obj_at_put(arg++, mirror);
2630 
2631     // Check accessibility.
2632     if (!java_lang_Class::is_primitive(mirror) &amp;&amp; accessing_klass != NULL) {
2633       Klass* sel_klass = java_lang_Class::as_Klass(mirror);
2634       mirror = NULL;  // safety
2635       // Emulate ConstantPool::verify_constant_pool_resolve.
<span class="line-modified">2636       LinkResolver::check_klass_accessibility(accessing_klass, sel_klass, CHECK_(empty));</span>


2637     }
2638   }
2639   assert(arg == npts, &quot;&quot;);
2640 
2641   // call java.lang.invoke.MethodHandleNatives::findMethodHandleType(Class rt, Class[] pts) -&gt; MethodType
2642   JavaCallArguments args(Handle(THREAD, rt()));
2643   args.push_oop(pts);
2644   JavaValue result(T_OBJECT);
2645   JavaCalls::call_static(&amp;result,
2646                          SystemDictionary::MethodHandleNatives_klass(),
2647                          vmSymbols::findMethodHandleType_name(),
2648                          vmSymbols::findMethodHandleType_signature(),
2649                          &amp;args, CHECK_(empty));
2650   Handle method_type(THREAD, (oop) result.get_jobject());
2651 
2652   if (can_be_cached) {
2653     // We can cache this MethodType inside the JVM.
2654     MutexLocker ml(THREAD, SystemDictionary_lock);
2655     spe = invoke_method_table()-&gt;find_entry(index, hash, signature, null_iid);
2656     if (spe == NULL)
</pre>
</td>
</tr>
</table>
<center><a href="packageEntry.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="systemDictionary.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
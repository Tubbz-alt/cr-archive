<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.le/share/classes/jdk/internal/org/jline/utils/NonBlockingPumpReader.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="NonBlockingInputStream.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="NonBlockingReader.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.le/share/classes/jdk/internal/org/jline/utils/NonBlockingPumpReader.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
  2  * Copyright (c) 2002-2017, the original author or authors.
  3  *
  4  * This software is distributable under the BSD license. See the terms of the
  5  * BSD license in the documentation provided with this software.
  6  *
  7  * https://opensource.org/licenses/BSD-3-Clause
  8  */
  9 package jdk.internal.org.jline.utils;
 10 
 11 import java.io.IOException;
 12 import java.io.InterruptedIOException;
 13 import java.io.Writer;
<span class="line-modified"> 14 import java.nio.CharBuffer;</span>


 15 
 16 public class NonBlockingPumpReader extends NonBlockingReader {
 17 
 18     private static final int DEFAULT_BUFFER_SIZE = 4096;
 19 
<span class="line-modified"> 20     // Read and write buffer are backed by the same array</span>
<span class="line-modified"> 21     private final CharBuffer readBuffer;</span>
<span class="line-modified"> 22     private final CharBuffer writeBuffer;</span>








 23 
 24     private final Writer writer;
 25 
 26     private boolean closed;
 27 
 28     public NonBlockingPumpReader() {
 29         this(DEFAULT_BUFFER_SIZE);
 30     }
 31 
 32     public NonBlockingPumpReader(int bufferSize) {
<span class="line-modified"> 33         char[] buf = new char[bufferSize];</span>
<span class="line-removed"> 34         this.readBuffer = CharBuffer.wrap(buf);</span>
<span class="line-removed"> 35         this.writeBuffer = CharBuffer.wrap(buf);</span>
 36         this.writer = new NbpWriter();
<span class="line-modified"> 37         // There are no bytes available to read after initialization</span>
<span class="line-modified"> 38         readBuffer.limit(0);</span>

 39     }
 40 
 41     public Writer getWriter() {
 42         return this.writer;
 43     }
 44 
<span class="line-removed"> 45     private int wait(CharBuffer buffer, long timeout) throws InterruptedIOException {</span>
<span class="line-removed"> 46         boolean isInfinite = (timeout &lt;= 0L);</span>
<span class="line-removed"> 47         long end = 0;</span>
<span class="line-removed"> 48         if (!isInfinite) {</span>
<span class="line-removed"> 49             end = System.currentTimeMillis() + timeout;</span>
<span class="line-removed"> 50         }</span>
<span class="line-removed"> 51         while (!closed &amp;&amp; !buffer.hasRemaining() &amp;&amp; (isInfinite || timeout &gt; 0L)) {</span>
<span class="line-removed"> 52             // Wake up waiting readers/writers</span>
<span class="line-removed"> 53             notifyAll();</span>
<span class="line-removed"> 54             try {</span>
<span class="line-removed"> 55                 wait(timeout);</span>
<span class="line-removed"> 56             } catch (InterruptedException e) {</span>
<span class="line-removed"> 57                 throw new InterruptedIOException();</span>
<span class="line-removed"> 58             }</span>
<span class="line-removed"> 59             if (!isInfinite) {</span>
<span class="line-removed"> 60                 timeout = end - System.currentTimeMillis();</span>
<span class="line-removed"> 61             }</span>
<span class="line-removed"> 62         }</span>
<span class="line-removed"> 63         return closed</span>
<span class="line-removed"> 64                 ? EOF</span>
<span class="line-removed"> 65                 : buffer.hasRemaining()</span>
<span class="line-removed"> 66                     ? 0</span>
<span class="line-removed"> 67                     : READ_EXPIRED;</span>
<span class="line-removed"> 68     }</span>
<span class="line-removed"> 69 </span>
<span class="line-removed"> 70     private static boolean rewind(CharBuffer buffer, CharBuffer other) {</span>
<span class="line-removed"> 71         // Extend limit of other buffer if there is additional input/output available</span>
<span class="line-removed"> 72         if (buffer.position() &gt; other.position()) {</span>
<span class="line-removed"> 73             other.limit(buffer.position());</span>
<span class="line-removed"> 74         }</span>
<span class="line-removed"> 75         // If we have reached the end of the buffer, rewind and set the new limit</span>
<span class="line-removed"> 76         if (buffer.position() == buffer.capacity()) {</span>
<span class="line-removed"> 77             buffer.rewind();</span>
<span class="line-removed"> 78             buffer.limit(other.position());</span>
<span class="line-removed"> 79             return true;</span>
<span class="line-removed"> 80         } else {</span>
<span class="line-removed"> 81             return false;</span>
<span class="line-removed"> 82         }</span>
<span class="line-removed"> 83     }</span>
<span class="line-removed"> 84 </span>
 85     @Override
<span class="line-modified"> 86     public synchronized boolean ready() {</span>
<span class="line-modified"> 87         return readBuffer.hasRemaining();</span>
 88     }
 89 
<span class="line-modified"> 90     public synchronized int available() {</span>
<span class="line-modified"> 91         int count = readBuffer.remaining();</span>
<span class="line-modified"> 92         if (writeBuffer.position() &lt; readBuffer.position()) {</span>
<span class="line-modified"> 93             count += writeBuffer.position();</span>



 94         }
<span class="line-removed"> 95         return count;</span>
 96     }
 97 
 98     @Override
<span class="line-modified"> 99     protected synchronized int read(long timeout, boolean isPeek) throws IOException {</span>
<span class="line-modified">100         // Blocks until more input is available or the reader is closed.</span>
<span class="line-modified">101         int res = wait(readBuffer, timeout);</span>
<span class="line-modified">102         if (res &gt;= 0) {</span>
<span class="line-modified">103             res = isPeek ? readBuffer.get(readBuffer.position()) : readBuffer.get();</span>


























104         }
<span class="line-removed">105         rewind(readBuffer, writeBuffer);</span>
<span class="line-removed">106         return res;</span>
107     }
108 
<span class="line-modified">109     synchronized void write(char[] cbuf, int off, int len) throws IOException {</span>
<span class="line-modified">110         while (len &gt; 0) {</span>
<span class="line-modified">111             // Blocks until there is new space available for buffering or the</span>
<span class="line-modified">112             // reader is closed.</span>
<span class="line-modified">113             if (wait(writeBuffer, 0L) == EOF) {</span>
<span class="line-modified">114                 throw new ClosedException();</span>





























115             }
<span class="line-removed">116             // Copy as much characters as we can</span>
<span class="line-removed">117             int count = Math.min(len, writeBuffer.remaining());</span>
<span class="line-removed">118             writeBuffer.put(cbuf, off, count);</span>
<span class="line-removed">119             off += count;</span>
<span class="line-removed">120             len -= count;</span>
<span class="line-removed">121             // Update buffer states and rewind if necessary</span>
<span class="line-removed">122             rewind(writeBuffer, readBuffer);</span>
123         }
124     }
125 
<span class="line-modified">126     synchronized void flush() {</span>
<span class="line-modified">127         // Avoid waking up readers when there is nothing to read</span>
<span class="line-modified">128         if (readBuffer.hasRemaining()) {</span>
<span class="line-modified">129             // Notify readers</span>
<span class="line-modified">130             notifyAll();</span>


























131         }
132     }
133 
134     @Override
<span class="line-modified">135     public synchronized void close() throws IOException {</span>
<span class="line-modified">136         this.closed = true;</span>
<span class="line-modified">137         notifyAll();</span>







138     }
139 
140     private class NbpWriter extends Writer {
141 
142         @Override
143         public void write(char[] cbuf, int off, int len) throws IOException {
144             NonBlockingPumpReader.this.write(cbuf, off, len);
145         }
146 
147         @Override
148         public void flush() throws IOException {
<span class="line-removed">149             NonBlockingPumpReader.this.flush();</span>
150         }
151 
152         @Override
153         public void close() throws IOException {
154             NonBlockingPumpReader.this.close();
155         }
156 
157     }
158 
159 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
  2  * Copyright (c) 2002-2017, the original author or authors.
  3  *
  4  * This software is distributable under the BSD license. See the terms of the
  5  * BSD license in the documentation provided with this software.
  6  *
  7  * https://opensource.org/licenses/BSD-3-Clause
  8  */
  9 package jdk.internal.org.jline.utils;
 10 
 11 import java.io.IOException;
 12 import java.io.InterruptedIOException;
 13 import java.io.Writer;
<span class="line-modified"> 14 import java.util.concurrent.TimeUnit;</span>
<span class="line-added"> 15 import java.util.concurrent.locks.Condition;</span>
<span class="line-added"> 16 import java.util.concurrent.locks.ReentrantLock;</span>
 17 
 18 public class NonBlockingPumpReader extends NonBlockingReader {
 19 
 20     private static final int DEFAULT_BUFFER_SIZE = 4096;
 21 
<span class="line-modified"> 22     private final char[] buffer;</span>
<span class="line-modified"> 23     private int read;</span>
<span class="line-modified"> 24     private int write;</span>
<span class="line-added"> 25     private int count;</span>
<span class="line-added"> 26 </span>
<span class="line-added"> 27     /** Main lock guarding all access */</span>
<span class="line-added"> 28     final ReentrantLock lock;</span>
<span class="line-added"> 29     /** Condition for waiting takes */</span>
<span class="line-added"> 30     private final Condition notEmpty;</span>
<span class="line-added"> 31     /** Condition for waiting puts */</span>
<span class="line-added"> 32     private final Condition notFull;</span>
 33 
 34     private final Writer writer;
 35 
 36     private boolean closed;
 37 
 38     public NonBlockingPumpReader() {
 39         this(DEFAULT_BUFFER_SIZE);
 40     }
 41 
 42     public NonBlockingPumpReader(int bufferSize) {
<span class="line-modified"> 43         this.buffer = new char[bufferSize];</span>


 44         this.writer = new NbpWriter();
<span class="line-modified"> 45         this.lock = new ReentrantLock();</span>
<span class="line-modified"> 46         this.notEmpty = lock.newCondition();</span>
<span class="line-added"> 47         this.notFull = lock.newCondition();</span>
 48     }
 49 
 50     public Writer getWriter() {
 51         return this.writer;
 52     }
 53 








































 54     @Override
<span class="line-modified"> 55     public boolean ready() {</span>
<span class="line-modified"> 56         return available() &gt; 0;</span>
 57     }
 58 
<span class="line-modified"> 59     public int available() {</span>
<span class="line-modified"> 60         final ReentrantLock lock = this.lock;</span>
<span class="line-modified"> 61         lock.lock();</span>
<span class="line-modified"> 62         try {</span>
<span class="line-added"> 63             return count;</span>
<span class="line-added"> 64         } finally {</span>
<span class="line-added"> 65             lock.unlock();</span>
 66         }

 67     }
 68 
 69     @Override
<span class="line-modified"> 70     protected int read(long timeout, boolean isPeek) throws IOException {</span>
<span class="line-modified"> 71         final ReentrantLock lock = this.lock;</span>
<span class="line-modified"> 72         lock.lock();</span>
<span class="line-modified"> 73         try {</span>
<span class="line-modified"> 74             // Blocks until more input is available or the reader is closed.</span>
<span class="line-added"> 75             if (!closed &amp;&amp; count == 0) {</span>
<span class="line-added"> 76                 try {</span>
<span class="line-added"> 77                     notEmpty.await(timeout, TimeUnit.MILLISECONDS);</span>
<span class="line-added"> 78                 } catch (InterruptedException e) {</span>
<span class="line-added"> 79                     throw (IOException) new InterruptedIOException().initCause(e);</span>
<span class="line-added"> 80                 }</span>
<span class="line-added"> 81             }</span>
<span class="line-added"> 82             if (closed) {</span>
<span class="line-added"> 83                 return EOF;</span>
<span class="line-added"> 84             } else if (count == 0) {</span>
<span class="line-added"> 85                 return READ_EXPIRED;</span>
<span class="line-added"> 86             } else {</span>
<span class="line-added"> 87                 if (isPeek) {</span>
<span class="line-added"> 88                     return buffer[read];</span>
<span class="line-added"> 89                 } else {</span>
<span class="line-added"> 90                     int res = buffer[read];</span>
<span class="line-added"> 91                     if (++read == buffer.length) {</span>
<span class="line-added"> 92                         read = 0;</span>
<span class="line-added"> 93                     }</span>
<span class="line-added"> 94                     --count;</span>
<span class="line-added"> 95                     notFull.signal();</span>
<span class="line-added"> 96                     return res;</span>
<span class="line-added"> 97                 }</span>
<span class="line-added"> 98             }</span>
<span class="line-added"> 99         } finally {</span>
<span class="line-added">100             lock.unlock();</span>
101         }


102     }
103 
<span class="line-modified">104     @Override</span>
<span class="line-modified">105     public int readBuffered(char[] b) throws IOException {</span>
<span class="line-modified">106         if (b == null) {</span>
<span class="line-modified">107             throw new NullPointerException();</span>
<span class="line-modified">108         } else if (b.length == 0) {</span>
<span class="line-modified">109             return 0;</span>
<span class="line-added">110         } else {</span>
<span class="line-added">111             final ReentrantLock lock = this.lock;</span>
<span class="line-added">112             lock.lock();</span>
<span class="line-added">113             try {</span>
<span class="line-added">114                 if (!closed &amp;&amp; count == 0) {</span>
<span class="line-added">115                     try {</span>
<span class="line-added">116                         notEmpty.await();</span>
<span class="line-added">117                     } catch (InterruptedException e) {</span>
<span class="line-added">118                         throw (IOException) new InterruptedIOException().initCause(e);</span>
<span class="line-added">119                     }</span>
<span class="line-added">120                 }</span>
<span class="line-added">121                 if (closed) {</span>
<span class="line-added">122                     return EOF;</span>
<span class="line-added">123                 } else if (count == 0) {</span>
<span class="line-added">124                     return READ_EXPIRED;</span>
<span class="line-added">125                 } else {</span>
<span class="line-added">126                     int r = Math.min(b.length, count);</span>
<span class="line-added">127                     for (int i = 0; i &lt; r; i++) {</span>
<span class="line-added">128                         b[i] = buffer[read++];</span>
<span class="line-added">129                         if (read == buffer.length) {</span>
<span class="line-added">130                             read = 0;</span>
<span class="line-added">131                         }</span>
<span class="line-added">132                     }</span>
<span class="line-added">133                     count -= r;</span>
<span class="line-added">134                     notFull.signal();</span>
<span class="line-added">135                     return r;</span>
<span class="line-added">136                 }</span>
<span class="line-added">137             } finally {</span>
<span class="line-added">138                 lock.unlock();</span>
139             }







140         }
141     }
142 
<span class="line-modified">143     void write(char[] cbuf, int off, int len) throws IOException {</span>
<span class="line-modified">144         if (len &gt; 0) {</span>
<span class="line-modified">145             final ReentrantLock lock = this.lock;</span>
<span class="line-modified">146             lock.lock();</span>
<span class="line-modified">147             try {</span>
<span class="line-added">148                 while (len &gt; 0) {</span>
<span class="line-added">149                     // Blocks until there is new space available for buffering or the</span>
<span class="line-added">150                     // reader is closed.</span>
<span class="line-added">151                     if (!closed &amp;&amp; count == buffer.length) {</span>
<span class="line-added">152                         try {</span>
<span class="line-added">153                             notFull.await();</span>
<span class="line-added">154                         } catch (InterruptedException e) {</span>
<span class="line-added">155                             throw (IOException) new InterruptedIOException().initCause(e);</span>
<span class="line-added">156                         }</span>
<span class="line-added">157                     }</span>
<span class="line-added">158                     if (closed) {</span>
<span class="line-added">159                         throw new IOException(&quot;Closed&quot;);</span>
<span class="line-added">160                     }</span>
<span class="line-added">161                     while (len &gt; 0 &amp;&amp; count &lt; buffer.length) {</span>
<span class="line-added">162                         buffer[write++] = cbuf[off++];</span>
<span class="line-added">163                         count++;</span>
<span class="line-added">164                         len--;</span>
<span class="line-added">165                         if (write == buffer.length) {</span>
<span class="line-added">166                             write = 0;</span>
<span class="line-added">167                         }</span>
<span class="line-added">168                     }</span>
<span class="line-added">169                     notEmpty.signal();</span>
<span class="line-added">170                 }</span>
<span class="line-added">171             } finally {</span>
<span class="line-added">172                 lock.unlock();</span>
<span class="line-added">173             }</span>
174         }
175     }
176 
177     @Override
<span class="line-modified">178     public void close() throws IOException {</span>
<span class="line-modified">179         final ReentrantLock lock = this.lock;</span>
<span class="line-modified">180         lock.lock();</span>
<span class="line-added">181         try {</span>
<span class="line-added">182             this.closed = true;</span>
<span class="line-added">183             this.notEmpty.signalAll();</span>
<span class="line-added">184             this.notFull.signalAll();</span>
<span class="line-added">185         } finally {</span>
<span class="line-added">186             lock.unlock();</span>
<span class="line-added">187         }</span>
188     }
189 
190     private class NbpWriter extends Writer {
191 
192         @Override
193         public void write(char[] cbuf, int off, int len) throws IOException {
194             NonBlockingPumpReader.this.write(cbuf, off, len);
195         }
196 
197         @Override
198         public void flush() throws IOException {

199         }
200 
201         @Override
202         public void close() throws IOException {
203             NonBlockingPumpReader.this.close();
204         }
205 
206     }
207 
208 }
</pre>
</td>
</tr>
</table>
<center><a href="NonBlockingInputStream.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="NonBlockingReader.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>